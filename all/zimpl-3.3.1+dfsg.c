/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 34 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/bool.h"
typedef int Bool;
#line 62 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/ratlptypes.h"
struct lpstorage;
#line 62 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/ratlptypes.h"
typedef struct lpstorage Lps;
#line 38 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/conname.h"
enum con_name_format {
    CON_FORM_MAKE = 0,
    CON_FORM_NAME = 1,
    CON_FORM_FULL = 2
} ;
#line 40 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/conname.h"
typedef enum con_name_format ConNameForm;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 140 "/usr/include/x86_64-linux-gnu/gmp.h"
typedef unsigned long mp_limb_t;
#line 144 "/usr/include/x86_64-linux-gnu/gmp.h"
typedef unsigned long mp_bitcnt_t;
#line 149 "/usr/include/x86_64-linux-gnu/gmp.h"
struct __anonstruct___mpz_struct_26 {
   int _mp_alloc ;
   int _mp_size ;
   mp_limb_t *_mp_d ;
};
#line 149 "/usr/include/x86_64-linux-gnu/gmp.h"
typedef struct __anonstruct___mpz_struct_26 __mpz_struct;
#line 165 "/usr/include/x86_64-linux-gnu/gmp.h"
typedef mp_limb_t *mp_ptr;
#line 166 "/usr/include/x86_64-linux-gnu/gmp.h"
typedef mp_limb_t const   *mp_srcptr;
#line 174 "/usr/include/x86_64-linux-gnu/gmp.h"
typedef long mp_size_t;
#line 178 "/usr/include/x86_64-linux-gnu/gmp.h"
struct __anonstruct___mpq_struct_27 {
   __mpz_struct _mp_num ;
   __mpz_struct _mp_den ;
};
#line 178 "/usr/include/x86_64-linux-gnu/gmp.h"
typedef struct __anonstruct___mpq_struct_27 __mpq_struct;
#line 185 "/usr/include/x86_64-linux-gnu/gmp.h"
typedef __mpq_struct mpq_t[1];
#line 223 "/usr/include/x86_64-linux-gnu/gmp.h"
typedef __mpz_struct const   *mpz_srcptr;
#line 224 "/usr/include/x86_64-linux-gnu/gmp.h"
typedef __mpz_struct *mpz_ptr;
#line 227 "/usr/include/x86_64-linux-gnu/gmp.h"
typedef __mpq_struct const   *mpq_srcptr;
#line 228 "/usr/include/x86_64-linux-gnu/gmp.h"
typedef __mpq_struct *mpq_ptr;
#line 38 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/ratlptypes.h"
enum con_type {
    CON_FREE = 0,
    CON_LHS = 1,
    CON_RHS = 2,
    CON_RANGE = 3,
    CON_EQUAL = 4
} ;
#line 39
enum var_type {
    VAR_FREE = 0,
    VAR_LOWER = 1,
    VAR_UPPER = 2,
    VAR_BOXED = 3,
    VAR_FIXED = 4
} ;
#line 40
enum sos_type {
    SOS_ERR = 0,
    SOS_TYPE1 = 1,
    SOS_TYPE2 = 2
} ;
#line 41
enum var_class {
    VAR_CON = 0,
    VAR_IMP = 1,
    VAR_INT = 2
} ;
#line 42
enum lp_direct {
    LP_MIN = 0,
    LP_MAX = 1
} ;
#line 43
enum lp_type {
    LP_ERR = 0,
    LP_LP = 1,
    LP_IP = 2
} ;
#line 44
enum lp_format {
    LP_FORM_ERR = 0,
    LP_FORM_LPF = 1,
    LP_FORM_HUM = 2,
    LP_FORM_MPS = 3,
    LP_FORM_RLP = 4,
    LP_FORM_PIP = 5
} ;
#line 56
struct nonzero;
#line 56 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/ratlptypes.h"
typedef struct nonzero Nzo;
#line 57
struct variable;
#line 57 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/ratlptypes.h"
typedef struct variable Var;
#line 58
struct constraint;
#line 58 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/ratlptypes.h"
typedef struct constraint Con;
#line 59
struct soset;
#line 59 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/ratlptypes.h"
typedef struct soset Sos;
#line 60
struct soselement;
#line 60 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/ratlptypes.h"
typedef struct soselement Sse;
#line 61
struct qmatentry;
#line 61 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/ratlptypes.h"
typedef struct qmatentry Qme;
#line 64 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/ratlptypes.h"
typedef enum con_type ConType;
#line 65 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/ratlptypes.h"
typedef enum sos_type SosType;
#line 66 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/ratlptypes.h"
typedef enum var_class VarClass;
#line 67 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/ratlptypes.h"
typedef enum lp_direct LpDirect;
#line 68 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/ratlptypes.h"
typedef enum lp_type LpType;
#line 69 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/ratlptypes.h"
typedef enum lp_format LpFormat;
#line 63 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/mme.h"
typedef enum var_type VarType;
#line 42 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/term.h"
struct term;
#line 42 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/term.h"
typedef struct term Term;
#line 45 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/ratlpstore.h"
struct storage;
#line 45 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/ratlpstore.h"
typedef struct storage Sto;
#line 47
struct lps_hash;
#line 47 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/ratlpstore.h"
typedef struct lps_hash LpsHash;
#line 49 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/ratlpstore.h"
struct nonzero {
   Var *var ;
   Con *con ;
   Nzo *var_prev ;
   Nzo *var_next ;
   Nzo *con_prev ;
   Nzo *con_next ;
   mpq_t value ;
};
#line 60 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/ratlpstore.h"
struct variable {
   unsigned int sid ;
   char *name ;
   int number ;
   VarClass vclass ;
   VarType type ;
   Bool is_used ;
   int size ;
   mpq_t cost ;
   mpq_t lower ;
   mpq_t upper ;
   mpq_t value ;
   mpq_t startval ;
   int priority ;
   Var *prev ;
   Var *next ;
   Nzo *first ;
};
#line 82 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/ratlpstore.h"
struct constraint {
   unsigned int sid ;
   char *name ;
   int number ;
   unsigned int flags ;
   ConType type ;
   int size ;
   mpq_t lhs ;
   mpq_t rhs ;
   mpq_t scale ;
   Var *ind_var ;
   Bool ind_dir ;
   Con *prev ;
   Con *next ;
   Nzo *first ;
   Qme *qme_first ;
   Term *term ;
};
#line 104 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/ratlpstore.h"
struct lpstorage {
   char *name ;
   LpType type ;
   LpDirect direct ;
   char *probname ;
   char *objname ;
   char *rhsname ;
   char *bndname ;
   char *rngname ;
   int vars ;
   int cons ;
   int soss ;
   int nonzeros ;
   Var *var_root ;
   Con *con_root ;
   Sos *sos_root ;
   Sto *sto_root ;
   Nzo *next ;
   LpsHash *var_hash ;
   LpsHash *con_hash ;
   LpsHash *sos_hash ;
   Var *var_last ;
   Con *con_last ;
   Sos *sos_last ;
   int name_len ;
};
#line 132 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/ratlpstore.h"
struct soselement {
   Var *var ;
   mpq_t weight ;
   Sse *next ;
};
#line 139 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/ratlpstore.h"
struct soset {
   unsigned int sid ;
   char *name ;
   SosType type ;
   int priority ;
   int sses ;
   Sos *next ;
   Sse *first ;
};
#line 152 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/ratlpstore.h"
struct qmatentry {
   unsigned int sid ;
   Var const   *var1 ;
   Var const   *var2 ;
   mpq_t value ;
   Qme *next ;
};
#line 30 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/numb.h"
struct number;
#line 30 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/numb.h"
typedef struct number Numb;
#line 56 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/mme.h"
struct entry;
#line 56 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/mme.h"
typedef struct entry Entry;
#line 64
struct mono;
#line 64 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/mme.h"
typedef struct mono Mono;
#line 38 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/mono.h"
enum mono_function {
    MFUN_SQRT = -2,
    MFUN_NONE = 0,
    MFUN_TRUE = 1,
    MFUN_FALSE = 2,
    MFUN_LOG = 3,
    MFUN_EXP = 4,
    MFUN_LN = 5,
    MFUN_SIN = 6,
    MFUN_COS = 7,
    MFUN_TAN = 8,
    MFUN_ABS = 9,
    MFUN_SGN = 10,
    MFUN_POW = 11,
    MFUN_SGNPOW = 12
} ;
#line 44 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/mono.h"
typedef enum mono_function MFun;
#line 45
struct mono_element;
#line 45 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/mono.h"
typedef struct mono_element MonoElem;
#line 47 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/mono.h"
struct mono_element {
   Entry *entry ;
   MonoElem *next ;
};
#line 58 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/mono.h"
struct mono {
   int count ;
   MFun fun ;
   Numb *coeff ;
   MonoElem first ;
};
#line 57 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/ratlpstore.c"
struct storage {
   int size ;
   Nzo *begin ;
   Sto *next ;
};
#line 70
enum lps_hash_type {
    LHT_ERR = 0,
    LHT_VAR = 1,
    LHT_CON = 2,
    LHT_SOS = 3
} ;
#line 72
struct lps_hash_element;
#line 72 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/ratlpstore.c"
typedef struct lps_hash_element LpsHElem;
#line 73 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/ratlpstore.c"
typedef enum lps_hash_type LpsHashType;
#line 75 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/ratlpstore.c"
union __anonunion_value_33 {
   Con *con ;
   Var *var ;
   Sos *sos ;
};
#line 75 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/ratlpstore.c"
struct lps_hash_element {
   LpsHElem *next ;
   union __anonunion_value_33 value ;
};
#line 86 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/ratlpstore.c"
struct lps_hash {
   unsigned int size ;
   int elems ;
   LpsHashType type ;
   LpsHElem **bucket ;
};
#line 36 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/blkmem.c"
struct memory_block_element;
#line 36 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/blkmem.c"
typedef struct memory_block_element BlkMemElem;
#line 37
struct memory_block;
#line 37 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/blkmem.c"
typedef struct memory_block BlkMem;
#line 39 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/blkmem.c"
struct memory_block_element {
   BlkMemElem *next ;
};
#line 44 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/blkmem.c"
struct memory_block {
   size_t elem_count ;
   BlkMemElem *elem ;
   BlkMem *next ;
};
#line 38 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/bound.h"
enum bound_type {
    BOUND_ERROR = 0,
    BOUND_VALUE = 1,
    BOUND_INFTY = 2,
    BOUND_MINUS_INFTY = 3
} ;
#line 43 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/bound.h"
typedef enum bound_type BoundType;
#line 44
struct bound;
#line 44 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/bound.h"
typedef struct bound Bound;
#line 50 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/hash.h"
enum hash_type {
    HASH_ERR = 0,
    HASH_TUPLE = 1,
    HASH_ENTRY = 2,
    HASH_ELEM_IDX = 3,
    HASH_NUMB = 4,
    HASH_MONO = 5
} ;
#line 52 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/hash.h"
typedef enum hash_type HashType;
#line 53
struct hash;
#line 53 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/hash.h"
typedef struct hash Hash;
#line 47 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/elem.h"
struct element;
#line 47 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/elem.h"
typedef struct element Elem;
#line 41 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/tuple.h"
struct tuple;
#line 41 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/tuple.h"
typedef struct tuple Tuple;
#line 50 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/mme.h"
struct symbol;
#line 50 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/mme.h"
typedef struct symbol Symbol;
#line 52
struct code_node;
#line 52 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/mme.h"
typedef struct code_node CodeNode;
#line 62 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/vinst.c"
enum vbool_cmp_operator {
    VBOOL_LT = 0,
    VBOOL_LE = 1,
    VBOOL_EQ = 2,
    VBOOL_NE = 3,
    VBOOL_GE = 4,
    VBOOL_GT = 5
} ;
#line 63
enum vbool_fixed_result {
    VBOOL_TRUE = 0,
    VBOOL_FALSE = 1,
    VBOOL_OPEN = 2
} ;
#line 65 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/vinst.c"
typedef enum vbool_cmp_operator VBCmpOp;
#line 66 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/vinst.c"
typedef enum vbool_fixed_result VBFixed;
#line 47 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/mme.h"
enum symbol_type {
    SYM_ERR = 0,
    SYM_NUMB = 1,
    SYM_STRG = 2,
    SYM_SET = 3,
    SYM_VAR = 4
} ;
#line 49 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/mme.h"
typedef enum symbol_type SymbolType;
#line 57
union set;
#line 57 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/mme.h"
typedef union set Set;
#line 41 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/prog.h"
struct program;
#line 41 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/prog.h"
typedef struct program Prog;
#line 175 "/usr/include/x86_64-linux-gnu/gmp.h"
typedef long mp_exp_t;
#line 187 "/usr/include/x86_64-linux-gnu/gmp.h"
struct __anonstruct___mpf_struct_28 {
   int _mp_prec ;
   int _mp_size ;
   mp_exp_t _mp_exp ;
   mp_limb_t *_mp_d ;
};
#line 187 "/usr/include/x86_64-linux-gnu/gmp.h"
typedef struct __anonstruct___mpf_struct_28 __mpf_struct;
#line 201 "/usr/include/x86_64-linux-gnu/gmp.h"
typedef __mpf_struct mpf_t[1];
#line 225 "/usr/include/x86_64-linux-gnu/gmp.h"
typedef __mpf_struct const   *mpf_srcptr;
#line 226 "/usr/include/x86_64-linux-gnu/gmp.h"
typedef __mpf_struct *mpf_ptr;
#line 47 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/gmpmisc.c"
union pool_elem;
#line 47 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/gmpmisc.c"
typedef union pool_elem PoolElem;
#line 48
struct pool;
#line 48 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/gmpmisc.c"
typedef struct pool Pool;
#line 50 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/gmpmisc.c"
union pool_elem {
   char pad[16] ;
   PoolElem *next ;
};
#line 56 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/gmpmisc.c"
struct pool {
   PoolElem elem[10000] ;
   Pool *next ;
};
#line 41 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/bound.c"
struct bound {
   BoundType type ;
   Numb *value ;
};
#line 47 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/entry.c"
union entry_value;
#line 47 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/entry.c"
typedef union entry_value EntryValue;
#line 49 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/entry.c"
union entry_value {
   Numb *numb ;
   char const   *strg ;
   Set *set ;
   Var *var ;
};
#line 57 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/entry.c"
struct entry {
   int refc ;
   Tuple *tuple ;
   SymbolType type ;
   EntryValue value ;
};
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 79 "/usr/include/stdio.h"
typedef __gnuc_va_list va_list;
#line 39 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/mme.h"
enum code_type {
    CODE_ERR = 0,
    CODE_NUMB = 1,
    CODE_STRG = 2,
    CODE_NAME = 3,
    CODE_TUPLE = 4,
    CODE_SET = 5,
    CODE_TERM = 6,
    CODE_BOOL = 7,
    CODE_SIZE = 8,
    CODE_IDXSET = 9,
    CODE_LIST = 10,
    CODE_VOID = 11,
    CODE_ENTRY = 12,
    CODE_VARCLASS = 13,
    CODE_CONTYPE = 14,
    CODE_RDEF = 15,
    CODE_RPAR = 16,
    CODE_BITS = 17,
    CODE_SYM = 18,
    CODE_DEF = 19,
    CODE_BOUND = 20
} ;
#line 51 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/mme.h"
typedef enum code_type CodeType;
#line 54 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/mme.h"
typedef CodeNode *(*Inst)(CodeNode *self );
#line 61
struct list;
#line 61 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/mme.h"
typedef struct list List;
#line 44 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/idxset.h"
struct index_set;
#line 44 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/idxset.h"
typedef struct index_set IdxSet;
#line 34 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/rdefpar.h"
struct read_param;
#line 34 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/rdefpar.h"
typedef struct read_param RPar;
#line 35
struct read_definition;
#line 35 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/rdefpar.h"
typedef struct read_definition RDef;
#line 44 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/define.h"
struct define;
#line 44 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/define.h"
typedef struct define Define;
#line 45 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/stmt.h"
struct statement;
#line 45 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/stmt.h"
typedef struct statement Stmt;
#line 57 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/code.c"
union code_value;
#line 57 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/code.c"
typedef union code_value CodeValue;
#line 59 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/code.c"
union code_value {
   Numb *numb ;
   char const   *strg ;
   char const   *name ;
   Tuple *tuple ;
   Set *set ;
   Term *term ;
   Entry *entry ;
   IdxSet *idxset ;
   Bool bool ;
   int size ;
   List *list ;
   VarClass varclass ;
   ConType contype ;
   RDef *rdef ;
   RPar *rpar ;
   unsigned int bits ;
   Symbol *sym ;
   Define *def ;
   Bound *bound ;
};
#line 84 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/code.c"
struct code_node {
   CodeType type ;
   CodeNode *(*eval)(CodeNode *self ) ;
   CodeValue value ;
   CodeNode *child[8] ;
   Stmt const   *stmt ;
   int column ;
};
#line 41 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/define.h"
enum define_type {
    DEF_ERR = 0,
    DEF_NUMB = 1,
    DEF_STRG = 2,
    DEF_BOOL = 3,
    DEF_SET = 4
} ;
#line 43 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/define.h"
typedef enum define_type DefineType;
#line 43 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/define.c"
struct define {
   char const   *name ;
   DefineType type ;
   Tuple *param ;
   CodeNode *code ;
   Define *next ;
};
#line 41 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/elem.h"
enum element_type {
    ELEM_ERR = 0,
    ELEM_FREE = 1,
    ELEM_NUMB = 2,
    ELEM_STRG = 3,
    ELEM_NAME = 4
} ;
#line 46 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/elem.h"
typedef enum element_type ElemType;
#line 44 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/elem.c"
union element_value;
#line 44 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/elem.c"
typedef union element_value ElemValue;
#line 45
struct element_storage;
#line 45 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/elem.c"
typedef struct element_storage ElemStore;
#line 47 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/elem.c"
union element_value {
   Numb *numb ;
   char const   *strg ;
   char const   *name ;
   Elem *next ;
};
#line 55 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/elem.c"
struct element {
   ElemType type ;
   ElemValue value ;
};
#line 62 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/elem.c"
struct element_storage {
   Elem *begin ;
   ElemStore *next ;
};
#line 364 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 129 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 137
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcat)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 36 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/mshell.h"
extern void *mem_malloc(size_t  , char const   * , int const    ) ;
#line 40
extern void *mem_realloc(void * , size_t  , char const   * , int const    ) ;
#line 42
extern char *mem_strdup(char const   * , char const   * , int const    ) ;
#line 44
extern void mem_free(void * , char const   * , int const    ) ;
#line 52 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/local.h"
extern char *local_tostrall(void) ;
#line 45 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/prog.h"
extern void *prog_get_lp(void) ;
#line 51 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/xlpglue.h"
Bool xlp_conname_exists(Lps const   *lp , char const   *conname ) ;
#line 42 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/conname.h"
void conname_format(ConNameForm format ) ;
#line 43
void conname_free(void) ;
#line 45
Bool conname_set(char const   *prefix ) ;
#line 47
char const   *conname_get(void) ;
#line 48
void conname_next(void) ;
#line 49 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/conname.c"
static char *cpfix  =    (char *)((void *)0);
#line 50 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/conname.c"
static int count  =    1;
#line 51 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/conname.c"
static char *cname  =    (char *)((void *)0);
#line 52 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/conname.c"
static size_t clen  =    (size_t )0;
#line 53 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/conname.c"
static ConNameForm cform  =    (ConNameForm )1;
#line 55 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/conname.c"
void conname_format(ConNameForm format ) 
{ 


  {
#line 57
  cform = format;
#line 58
  return;
}
}
#line 60 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/conname.c"
void conname_free(void) 
{ 


  {
  {
#line 65
  mem_free((void *)cname, "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/conname.c",
           (int const   )65);
#line 66
  mem_free((void *)cpfix, "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/conname.c",
           (int const   )66);
#line 68
  cname = (char *)((void *)0);
#line 69
  clen = (size_t )0;
  }
#line 70
  return;
}
}
#line 77 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/conname.c"
Bool conname_set(char const   *prefix ) 
{ 
  size_t tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  Bool tmp___2 ;
  void *tmp___3 ;
  Bool tmp___4 ;
  int tmp___5 ;

  {
  {
#line 82
  cpfix = mem_strdup(prefix, "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/conname.c",
                     (int const   )82);
#line 83
  tmp = strlen((char const   *)cpfix);
#line 83
  clen = tmp + 16UL;
#line 84
  tmp___0 = mem_malloc(clen, "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/conname.c",
                       (int const   )84);
#line 84
  cname = (char *)tmp___0;
  }
#line 88
  if ((unsigned int )cform != 1U) {
#line 89
    return (1);
  }
  {
#line 93
  count = 1;
#line 95
  strcpy((char */* __restrict  */)cname, (char const   */* __restrict  */)cpfix);
#line 96
  strcat((char */* __restrict  */)cname, (char const   */* __restrict  */)"_1");
#line 98
  tmp___1 = prog_get_lp();
#line 98
  tmp___2 = xlp_conname_exists((Lps const   *)tmp___1, (char const   *)cname);
  }
#line 98
  if (tmp___2) {
#line 99
    return (0);
  }
  {
#line 101
  strcat((char */* __restrict  */)cname, (char const   */* __restrict  */)"_a_0");
#line 103
  tmp___3 = prog_get_lp();
#line 103
  tmp___4 = xlp_conname_exists((Lps const   *)tmp___3, (char const   *)cname);
  }
#line 103
  if (tmp___4) {
#line 103
    tmp___5 = 0;
  } else {
#line 103
    tmp___5 = 1;
  }
#line 103
  return (tmp___5);
}
}
#line 106 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/conname.c"
char const   *conname_get(void) 
{ 
  char *localstr ;
  size_t newlen ;
  size_t tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  char const   *tmp___3 ;
  size_t tmp___4 ;

  {
  {
#line 116
  if ((unsigned int )cform == 0U) {
#line 116
    goto case_0;
  }
#line 119
  if ((unsigned int )cform == 1U) {
#line 119
    goto case_1;
  }
#line 122
  if ((unsigned int )cform == 2U) {
#line 122
    goto case_2;
  }
#line 114
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 117
  sprintf((char */* __restrict  */)cname, (char const   */* __restrict  */)"c%d",
          count);
  }
#line 118
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 120
  sprintf((char */* __restrict  */)cname, (char const   */* __restrict  */)"%s_%d",
          cpfix, count);
  }
#line 121
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 123
  localstr = local_tostrall();
#line 124
  tmp = strlen((char const   *)localstr);
#line 124
  tmp___0 = strlen((char const   *)cpfix);
#line 124
  newlen = (tmp + tmp___0) + 16UL;
  }
#line 126
  if (newlen > clen) {
    {
#line 128
    clen = newlen;
#line 129
    tmp___1 = mem_realloc((void *)cname, clen, "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/conname.c",
                          (int const   )129);
#line 129
    cname = (char *)tmp___1;
    }
  }
  {
#line 133
  tmp___4 = strlen((char const   *)localstr);
  }
#line 133
  if (tmp___4 > 0UL) {
#line 133
    tmp___3 = ";";
  } else {
#line 133
    tmp___3 = "";
  }
  {
#line 133
  sprintf((char */* __restrict  */)cname, (char const   */* __restrict  */)"%s_%s%s",
          cpfix, tmp___3, localstr);
#line 138
  mem_free((void *)localstr, "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/conname.c",
           (int const   )138);
  }
#line 139
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 143
  return ((char const   *)cname);
}
}
#line 146 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/conname.c"
void conname_next(void) 
{ 


  {
#line 148
  count ++;
#line 149
  return;
}
}
#line 35 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/random.h"
void rand_init(unsigned long s ) ;
#line 36
unsigned int rand_get_int32(void) ;
#line 38
int rand_get_range(int mini , int maxi ) ;
#line 92 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/random.c"
static unsigned int state[624]  ;
#line 93 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/random.c"
static int left  =    1;
#line 94 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/random.c"
static unsigned int const   *next  ;
#line 97 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/random.c"
void rand_init(unsigned long s ) 
{ 
  int j ;

  {
#line 101
  state[0] = (unsigned int )(s & 4294967295UL);
#line 103
  j = 1;
  {
#line 103
  while (1) {
    while_continue: /* CIL Label */ ;
#line 103
    if (! (j < 624)) {
#line 103
      goto while_break;
    }
#line 105
    state[j] = (unsigned int )(1812433253UL * (unsigned long )(state[j - 1] ^ (state[j - 1] >> 30)) + (unsigned long )j);
#line 111
    state[j] = (unsigned int )((unsigned long )state[j] & 4294967295UL);
#line 103
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 113
  left = 1;
#line 114
  return;
}
}
#line 117 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/random.c"
unsigned int rand_get_int32(void) 
{ 
  unsigned int y ;
  unsigned int *p ;
  int j ;
  unsigned long tmp ;
  unsigned long tmp___0 ;
  unsigned long tmp___1 ;
  unsigned int const   *tmp___2 ;

  {
#line 121
  left --;
#line 121
  if (left == 0) {
#line 123
    p = state;
#line 126
    left = 624;
#line 127
    next = (unsigned int const   *)(state);
#line 129
    j = 228;
    {
#line 129
    while (1) {
      while_continue: /* CIL Label */ ;
#line 129
      j --;
#line 129
      if (! j) {
#line 129
        goto while_break;
      }
#line 130
      if ((unsigned long )*(p + 1) & 1UL) {
#line 130
        tmp = 2567483615UL;
      } else {
#line 130
        tmp = 0UL;
      }
#line 130
      *p = (unsigned int )((unsigned long )*(p + 397) ^ (((((unsigned long )*(p + 0) & 2147483648UL) | ((unsigned long )*(p + 1) & 2147483647UL)) >> 1) ^ tmp));
#line 129
      p ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 132
    j = 397;
    {
#line 132
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 132
      j --;
#line 132
      if (! j) {
#line 132
        goto while_break___0;
      }
#line 133
      if ((unsigned long )*(p + 1) & 1UL) {
#line 133
        tmp___0 = 2567483615UL;
      } else {
#line 133
        tmp___0 = 0UL;
      }
#line 133
      *p = (unsigned int )((unsigned long )*(p + -227) ^ (((((unsigned long )*(p + 0) & 2147483648UL) | ((unsigned long )*(p + 1) & 2147483647UL)) >> 1) ^ tmp___0));
#line 132
      p ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 135
    if ((unsigned long )state[0] & 1UL) {
#line 135
      tmp___1 = 2567483615UL;
    } else {
#line 135
      tmp___1 = 0UL;
    }
#line 135
    *p = (unsigned int )((unsigned long )*(p + -227) ^ (((((unsigned long )*(p + 0) & 2147483648UL) | ((unsigned long )state[0] & 2147483647UL)) >> 1) ^ tmp___1));
  }
#line 137
  tmp___2 = next;
#line 137
  next ++;
#line 137
  y = (unsigned int )*tmp___2;
#line 140
  y ^= y >> 11;
#line 141
  y = (unsigned int )((unsigned long )y ^ ((unsigned long )(y << 7) & 2636928640UL));
#line 142
  y = (unsigned int )((unsigned long )y ^ ((unsigned long )(y << 15) & 4022730752UL));
#line 143
  y ^= y >> 18;
#line 145
  return (y);
}
}
#line 151 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/random.c"
int rand_get_range(int mini , int maxi ) 
{ 
  double r ;
  unsigned int tmp ;

  {
  {
#line 153
  tmp = rand_get_int32();
#line 153
  r = (double )tmp / 4294967295.0;
  }
#line 157
  return ((int )(r * (double )(maxi - mini) + 0.5) + mini);
}
}
/* compiler builtin: 
   long __builtin_expect(long  , long  ) ;  */
#line 356 "/usr/include/stdio.h"
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 573
extern int fputc(int __c , FILE *__stream ) ;
#line 629 "/usr/include/x86_64-linux-gnu/gmp.h"
__inline extern void __gmpz_abs(mpz_ptr __gmp_w , mpz_srcptr __gmp_u ) ;
#line 805
__inline extern int __gmpz_fits_uint_p(mpz_srcptr __gmp_z )  __attribute__((__pure__)) ;
#line 810
__inline extern int __gmpz_fits_ulong_p(mpz_srcptr __gmp_z )  __attribute__((__pure__)) ;
#line 815
__inline extern int __gmpz_fits_ushort_p(mpz_srcptr __gmp_z )  __attribute__((__pure__)) ;
#line 841
__inline extern unsigned long __gmpz_get_ui(mpz_srcptr __gmp_z )  __attribute__((__pure__)) ;
#line 846
__inline extern mp_limb_t __gmpz_getlimbn(mpz_srcptr __gmp_z , mp_size_t __gmp_n )  __attribute__((__pure__)) ;
#line 948
__inline extern void __gmpz_neg(mpz_ptr __gmp_w , mpz_srcptr __gmp_u ) ;
#line 969
__inline extern int __gmpz_perfect_square_p(mpz_srcptr __gmp_a )  __attribute__((__pure__)) ;
#line 974
__inline extern mp_bitcnt_t __gmpz_popcount(mpz_srcptr __gmp_u )  __attribute__((__pure__)) ;
#line 1020
extern void __gmpz_set(mpz_ptr  , mpz_srcptr  ) ;
#line 1030
__inline extern void __gmpz_set_q(mpz_ptr __gmp_w , mpq_srcptr __gmp_u ) ;
#line 1047
__inline extern size_t __gmpz_size(mpz_srcptr __gmp_z )  __attribute__((__pure__)) ;
#line 1081
extern void __gmpz_tdiv_q(mpz_ptr  , mpz_srcptr  , mpz_srcptr  ) ;
#line 1125
__inline extern void __gmpq_abs(mpq_ptr __gmp_w , mpq_srcptr __gmp_u ) ;
#line 1165
extern double __gmpq_get_d(mpq_srcptr  )  __attribute__((__pure__)) ;
#line 1192
__inline extern void __gmpq_neg(mpq_ptr __gmp_w , mpq_srcptr __gmp_u ) ;
#line 1201
extern void __gmpq_set(mpq_ptr  , mpq_srcptr  ) ;
#line 1447
__inline extern mp_limb_t __gmpn_add(mp_ptr __gmp_wp , mp_srcptr __gmp_xp , mp_size_t __gmp_xsize ,
                                     mp_srcptr __gmp_yp , mp_size_t __gmp_ysize ) ;
#line 1452
__inline extern mp_limb_t __gmpn_add_1(mp_ptr __gmp_dst , mp_srcptr __gmp_src , mp_size_t __gmp_size ,
                                       mp_limb_t __gmp_n ) ;
#line 1456
extern mp_limb_t __gmpn_add_n(mp_ptr  , mp_srcptr  , mp_srcptr  , mp_size_t  ) ;
#line 1463
__inline extern int __gmpn_cmp(mp_srcptr __gmp_xp , mp_srcptr __gmp_yp , mp_size_t __gmp_size )  __attribute__((__pure__)) ;
#line 1525
__inline extern mp_limb_t __gmpn_neg(mp_ptr __gmp_rp , mp_srcptr __gmp_up , mp_size_t __gmp_n ) ;
#line 1534
extern int __gmpn_perfect_square_p(mp_srcptr  , mp_size_t  )  __attribute__((__pure__)) ;
#line 1540
extern mp_bitcnt_t __gmpn_popcount(mp_srcptr  , mp_size_t  )  __attribute__((__pure__)) ;
#line 1572
__inline extern mp_limb_t __gmpn_sub(mp_ptr __gmp_wp , mp_srcptr __gmp_xp , mp_size_t __gmp_xsize ,
                                     mp_srcptr __gmp_yp , mp_size_t __gmp_ysize ) ;
#line 1577
__inline extern mp_limb_t __gmpn_sub_1(mp_ptr __gmp_dst , mp_srcptr __gmp_src , mp_size_t __gmp_size ,
                                       mp_limb_t __gmp_n ) ;
#line 1581
extern mp_limb_t __gmpn_sub_n(mp_ptr  , mp_srcptr  , mp_srcptr  , mp_size_t  ) ;
#line 1630 "/usr/include/x86_64-linux-gnu/gmp.h"
__inline extern void __gmpz_abs(mpz_ptr __gmp_w , mpz_srcptr __gmp_u ) 
{ 


  {
#line 1633
  if ((unsigned long )__gmp_w != (unsigned long )__gmp_u) {
    {
#line 1634
    __gmpz_set(__gmp_w, __gmp_u);
    }
  }
#line 1635
  if (__gmp_w->_mp_size >= 0) {
#line 1635
    __gmp_w->_mp_size = __gmp_w->_mp_size;
  } else {
#line 1635
    __gmp_w->_mp_size = - __gmp_w->_mp_size;
  }
#line 1636
  return;
}
}
#line 1654
__inline extern int __gmpz_fits_uint_p(mpz_srcptr __gmp_z )  __attribute__((__pure__)) ;
#line 1654 "/usr/include/x86_64-linux-gnu/gmp.h"
__inline extern int __gmpz_fits_uint_p(mpz_srcptr __gmp_z ) 
{ 
  mp_size_t __gmp_n ;
  mp_ptr __gmp_p ;
  int tmp ;

  {
#line 1659
  __gmp_n = (mp_size_t )__gmp_z->_mp_size;
#line 1659
  __gmp_p = (mp_ptr )__gmp_z->_mp_d;
#line 1659
  if (__gmp_n == 0L) {
#line 1659
    tmp = 1;
  } else
#line 1659
  if (__gmp_n == 1L) {
#line 1659
    if (*(__gmp_p + 0) <= 4294967295UL) {
#line 1659
      tmp = 1;
    } else {
#line 1659
      tmp = 0;
    }
  } else {
#line 1659
    tmp = 0;
  }
#line 1659
  return (tmp);
}
}
#line 1665
__inline extern int __gmpz_fits_ulong_p(mpz_srcptr __gmp_z )  __attribute__((__pure__)) ;
#line 1665 "/usr/include/x86_64-linux-gnu/gmp.h"
__inline extern int __gmpz_fits_ulong_p(mpz_srcptr __gmp_z ) 
{ 
  mp_size_t __gmp_n ;
  mp_ptr __gmp_p ;
  int tmp ;

  {
#line 1670
  __gmp_n = (mp_size_t )__gmp_z->_mp_size;
#line 1670
  __gmp_p = (mp_ptr )__gmp_z->_mp_d;
#line 1670
  if (__gmp_n == 0L) {
#line 1670
    tmp = 1;
  } else
#line 1670
  if (__gmp_n == 1L) {
#line 1670
    if (*(__gmp_p + 0) <= 0xffffffffffffffffUL) {
#line 1670
      tmp = 1;
    } else {
#line 1670
      tmp = 0;
    }
  } else {
#line 1670
    tmp = 0;
  }
#line 1670
  return (tmp);
}
}
#line 1676
__inline extern int __gmpz_fits_ushort_p(mpz_srcptr __gmp_z )  __attribute__((__pure__)) ;
#line 1676 "/usr/include/x86_64-linux-gnu/gmp.h"
__inline extern int __gmpz_fits_ushort_p(mpz_srcptr __gmp_z ) 
{ 
  mp_size_t __gmp_n ;
  mp_ptr __gmp_p ;
  int tmp ;

  {
#line 1681
  __gmp_n = (mp_size_t )__gmp_z->_mp_size;
#line 1681
  __gmp_p = (mp_ptr )__gmp_z->_mp_d;
#line 1681
  if (__gmp_n == 0L) {
#line 1681
    tmp = 1;
  } else
#line 1681
  if (__gmp_n == 1L) {
#line 1681
    if (*(__gmp_p + 0) <= 65535UL) {
#line 1681
      tmp = 1;
    } else {
#line 1681
      tmp = 0;
    }
  } else {
#line 1681
    tmp = 0;
  }
#line 1681
  return (tmp);
}
}
#line 1687
__inline extern unsigned long __gmpz_get_ui(mpz_srcptr __gmp_z )  __attribute__((__pure__)) ;
#line 1687 "/usr/include/x86_64-linux-gnu/gmp.h"
__inline extern unsigned long __gmpz_get_ui(mpz_srcptr __gmp_z ) 
{ 
  mp_ptr __gmp_p ;
  mp_size_t __gmp_n ;
  mp_limb_t __gmp_l ;
  mp_limb_t tmp ;

  {
#line 1692
  __gmp_p = (mp_ptr )__gmp_z->_mp_d;
#line 1693
  __gmp_n = (mp_size_t )__gmp_z->_mp_size;
#line 1694
  __gmp_l = *(__gmp_p + 0);
#line 1701
  if (__gmp_n != 0L) {
#line 1701
    tmp = __gmp_l;
  } else {
#line 1701
    tmp = (mp_limb_t )0;
  }
#line 1701
  return (tmp);
}
}
#line 1715
__inline extern mp_limb_t __gmpz_getlimbn(mpz_srcptr __gmp_z , mp_size_t __gmp_n )  __attribute__((__pure__)) ;
#line 1715 "/usr/include/x86_64-linux-gnu/gmp.h"
__inline extern mp_limb_t __gmpz_getlimbn(mpz_srcptr __gmp_z , mp_size_t __gmp_n ) 
{ 
  mp_limb_t __gmp_result ;
  int tmp ;
  int tmp___0 ;
  long tmp___1 ;

  {
#line 1720
  __gmp_result = (mp_limb_t )0;
#line 1721
  if (__gmp_n >= 0L) {
#line 1721
    if (__gmp_z->_mp_size >= 0) {
#line 1721
      tmp = __gmp_z->_mp_size;
    } else {
#line 1721
      tmp = - __gmp_z->_mp_size;
    }
#line 1721
    if (__gmp_n < (mp_size_t )tmp) {
#line 1721
      tmp___0 = 1;
    } else {
#line 1721
      tmp___0 = 0;
    }
  } else {
#line 1721
    tmp___0 = 0;
  }
  {
#line 1721
  tmp___1 = __builtin_expect((long )(tmp___0 != 0), 1L);
  }
#line 1721
  if (tmp___1) {
#line 1722
    __gmp_result = *(__gmp_z->_mp_d + __gmp_n);
  }
#line 1723
  return (__gmp_result);
}
}
#line 1728 "/usr/include/x86_64-linux-gnu/gmp.h"
__inline extern void __gmpz_neg(mpz_ptr __gmp_w , mpz_srcptr __gmp_u ) 
{ 


  {
#line 1731
  if ((unsigned long )__gmp_w != (unsigned long )__gmp_u) {
    {
#line 1732
    __gmpz_set(__gmp_w, __gmp_u);
    }
  }
#line 1733
  __gmp_w->_mp_size = - __gmp_w->_mp_size;
#line 1734
  return;
}
}
#line 1739
__inline extern int __gmpz_perfect_square_p(mpz_srcptr __gmp_a )  __attribute__((__pure__)) ;
#line 1739 "/usr/include/x86_64-linux-gnu/gmp.h"
__inline extern int __gmpz_perfect_square_p(mpz_srcptr __gmp_a ) 
{ 
  mp_size_t __gmp_asize ;
  int __gmp_result ;
  long tmp ;

  {
  {
#line 1747
  __gmp_asize = (mp_size_t )__gmp_a->_mp_size;
#line 1748
  __gmp_result = __gmp_asize >= 0L;
#line 1749
  tmp = __builtin_expect((long )((__gmp_asize > 0L) != 0), 1L);
  }
#line 1749
  if (tmp) {
    {
#line 1750
    __gmp_result = __gmpn_perfect_square_p((mp_srcptr )__gmp_a->_mp_d, __gmp_asize);
    }
  }
#line 1751
  return (__gmp_result);
}
}
#line 1757
__inline extern mp_bitcnt_t __gmpz_popcount(mpz_srcptr __gmp_u )  __attribute__((__pure__)) ;
#line 1757 "/usr/include/x86_64-linux-gnu/gmp.h"
__inline extern mp_bitcnt_t __gmpz_popcount(mpz_srcptr __gmp_u ) 
{ 
  mp_size_t __gmp_usize ;
  mp_bitcnt_t __gmp_result ;
  long tmp ;

  {
#line 1765
  __gmp_usize = (mp_size_t )__gmp_u->_mp_size;
#line 1766
  if (__gmp_usize < 0L) {
#line 1766
    __gmp_result = ~ 0UL;
  } else {
#line 1766
    __gmp_result = (mp_bitcnt_t )0;
  }
  {
#line 1767
  tmp = __builtin_expect((long )((__gmp_usize > 0L) != 0), 1L);
  }
#line 1767
  if (tmp) {
    {
#line 1768
    __gmp_result = __gmpn_popcount((mp_srcptr )__gmp_u->_mp_d, __gmp_usize);
    }
  }
#line 1769
  return (__gmp_result);
}
}
#line 1775 "/usr/include/x86_64-linux-gnu/gmp.h"
__inline extern void __gmpz_set_q(mpz_ptr __gmp_w , mpq_srcptr __gmp_u ) 
{ 


  {
  {
#line 1780
  __gmpz_tdiv_q(__gmp_w, & __gmp_u->_mp_num, & __gmp_u->_mp_den);
  }
#line 1781
  return;
}
}
#line 1786
__inline extern size_t __gmpz_size(mpz_srcptr __gmp_z )  __attribute__((__pure__)) ;
#line 1786 "/usr/include/x86_64-linux-gnu/gmp.h"
__inline extern size_t __gmpz_size(mpz_srcptr __gmp_z ) 
{ 
  int tmp ;

  {
#line 1791
  if (__gmp_z->_mp_size >= 0) {
#line 1791
    tmp = __gmp_z->_mp_size;
  } else {
#line 1791
    tmp = - __gmp_z->_mp_size;
  }
#line 1791
  return ((size_t )tmp);
}
}
#line 1799 "/usr/include/x86_64-linux-gnu/gmp.h"
__inline extern void __gmpq_abs(mpq_ptr __gmp_w , mpq_srcptr __gmp_u ) 
{ 


  {
#line 1802
  if ((unsigned long )__gmp_w != (unsigned long )__gmp_u) {
    {
#line 1803
    __gmpq_set(__gmp_w, __gmp_u);
    }
  }
#line 1804
  if (__gmp_w->_mp_num._mp_size >= 0) {
#line 1804
    __gmp_w->_mp_num._mp_size = __gmp_w->_mp_num._mp_size;
  } else {
#line 1804
    __gmp_w->_mp_num._mp_size = - __gmp_w->_mp_num._mp_size;
  }
#line 1805
  return;
}
}
#line 1809 "/usr/include/x86_64-linux-gnu/gmp.h"
__inline extern void __gmpq_neg(mpq_ptr __gmp_w , mpq_srcptr __gmp_u ) 
{ 


  {
#line 1812
  if ((unsigned long )__gmp_w != (unsigned long )__gmp_u) {
    {
#line 1813
    __gmpq_set(__gmp_w, __gmp_u);
    }
  }
#line 1814
  __gmp_w->_mp_num._mp_size = - __gmp_w->_mp_num._mp_size;
#line 1815
  return;
}
}
#line 2052 "/usr/include/x86_64-linux-gnu/gmp.h"
__inline extern mp_limb_t __gmpn_add(mp_ptr __gmp_wp , mp_srcptr __gmp_xp , mp_size_t __gmp_xsize ,
                                     mp_srcptr __gmp_yp , mp_size_t __gmp_ysize ) 
{ 
  mp_limb_t __gmp_c ;
  mp_size_t __gmp_i ;
  mp_limb_t __gmp_x ;
  mp_size_t tmp ;
  mp_limb_t tmp___0 ;
  mp_limb_t tmp___1 ;
  mp_size_t __gmp_j ;

  {
  {
#line 2058
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2058
    __gmp_i = __gmp_ysize;
#line 2058
    if (__gmp_i != 0L) {
      {
#line 2058
      tmp___1 = __gmpn_add_n(__gmp_wp, __gmp_xp, __gmp_yp, __gmp_i);
      }
#line 2058
      if (tmp___1) {
        {
#line 2058
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 2058
          if (__gmp_i >= __gmp_xsize) {
#line 2058
            __gmp_c = (mp_limb_t )1;
#line 2058
            goto __gmp_done;
          }
#line 2058
          __gmp_x = (mp_limb_t )*(__gmp_xp + __gmp_i);
#line 2058
          tmp = __gmp_i;
#line 2058
          __gmp_i ++;
#line 2058
          tmp___0 = (__gmp_x + 1UL) & 0xffffffffffffffffUL;
#line 2058
          *(__gmp_wp + tmp) = tmp___0;
#line 2058
          if (! (tmp___0 == 0UL)) {
#line 2058
            goto while_break___0;
          }
        }
        while_break___0: /* CIL Label */ ;
        }
      }
    }
#line 2058
    if ((unsigned long )__gmp_wp != (unsigned long )__gmp_xp) {
      {
#line 2058
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 2058
        __gmp_j = __gmp_i;
        {
#line 2058
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 2058
          if (! (__gmp_j < __gmp_xsize)) {
#line 2058
            goto while_break___2;
          }
#line 2058
          *(__gmp_wp + __gmp_j) = (mp_limb_t )*(__gmp_xp + __gmp_j);
#line 2058
          __gmp_j ++;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 2058
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
#line 2058
    __gmp_c = (mp_limb_t )0;
    __gmp_done: ;
#line 2058
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 2059
  return (__gmp_c);
}
}
#line 2065 "/usr/include/x86_64-linux-gnu/gmp.h"
__inline extern mp_limb_t __gmpn_add_1(mp_ptr __gmp_dst , mp_srcptr __gmp_src , mp_size_t __gmp_size ,
                                       mp_limb_t __gmp_n ) 
{ 
  mp_limb_t __gmp_c ;
  mp_size_t __gmp_i ;
  mp_limb_t __gmp_x ;
  mp_limb_t __gmp_r ;
  mp_size_t __gmp_j ;
  mp_size_t __gmp_j___0 ;

  {
  {
#line 2071
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2071
    __gmp_x = (mp_limb_t )*(__gmp_src + 0);
#line 2071
    __gmp_r = __gmp_x + __gmp_n;
#line 2071
    *(__gmp_dst + 0) = __gmp_r;
#line 2071
    if (__gmp_r < __gmp_n) {
#line 2071
      __gmp_c = (mp_limb_t )1;
#line 2071
      __gmp_i = (mp_size_t )1;
      {
#line 2071
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 2071
        if (! (__gmp_i < __gmp_size)) {
#line 2071
          goto while_break___0;
        }
#line 2071
        __gmp_x = (mp_limb_t )*(__gmp_src + __gmp_i);
#line 2071
        __gmp_r = __gmp_x + 1UL;
#line 2071
        *(__gmp_dst + __gmp_i) = __gmp_r;
#line 2071
        __gmp_i ++;
#line 2071
        if (! (__gmp_r < 1UL)) {
#line 2071
          if ((unsigned long )__gmp_src != (unsigned long )__gmp_dst) {
            {
#line 2071
            while (1) {
              while_continue___1: /* CIL Label */ ;
#line 2071
              __gmp_j = __gmp_i;
              {
#line 2071
              while (1) {
                while_continue___2: /* CIL Label */ ;
#line 2071
                if (! (__gmp_j < __gmp_size)) {
#line 2071
                  goto while_break___2;
                }
#line 2071
                *(__gmp_dst + __gmp_j) = (mp_limb_t )*(__gmp_src + __gmp_j);
#line 2071
                __gmp_j ++;
              }
              while_break___2: /* CIL Label */ ;
              }
#line 2071
              goto while_break___1;
            }
            while_break___1: /* CIL Label */ ;
            }
          }
#line 2071
          __gmp_c = (mp_limb_t )0;
#line 2071
          goto while_break___0;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
    } else {
#line 2071
      if ((unsigned long )__gmp_src != (unsigned long )__gmp_dst) {
        {
#line 2071
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 2071
          __gmp_j___0 = (mp_size_t )1;
          {
#line 2071
          while (1) {
            while_continue___4: /* CIL Label */ ;
#line 2071
            if (! (__gmp_j___0 < __gmp_size)) {
#line 2071
              goto while_break___4;
            }
#line 2071
            *(__gmp_dst + __gmp_j___0) = (mp_limb_t )*(__gmp_src + __gmp_j___0);
#line 2071
            __gmp_j___0 ++;
          }
          while_break___4: /* CIL Label */ ;
          }
#line 2071
          goto while_break___3;
        }
        while_break___3: /* CIL Label */ ;
        }
      }
#line 2071
      __gmp_c = (mp_limb_t )0;
    }
#line 2071
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 2072
  return (__gmp_c);
}
}
#line 2078
__inline extern int __gmpn_cmp(mp_srcptr __gmp_xp , mp_srcptr __gmp_yp , mp_size_t __gmp_size )  __attribute__((__pure__)) ;
#line 2078 "/usr/include/x86_64-linux-gnu/gmp.h"
__inline extern int __gmpn_cmp(mp_srcptr __gmp_xp , mp_srcptr __gmp_yp , mp_size_t __gmp_size ) 
{ 
  int __gmp_result ;
  mp_size_t __gmp_i ;
  mp_limb_t __gmp_x ;
  mp_limb_t __gmp_y ;

  {
  {
#line 2084
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2084
    __gmp_result = 0;
#line 2084
    __gmp_i = __gmp_size;
    {
#line 2084
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2084
      __gmp_i --;
#line 2084
      if (! (__gmp_i >= 0L)) {
#line 2084
        goto while_break___0;
      }
#line 2084
      __gmp_x = (mp_limb_t )*(__gmp_xp + __gmp_i);
#line 2084
      __gmp_y = (mp_limb_t )*(__gmp_yp + __gmp_i);
#line 2084
      if (__gmp_x != __gmp_y) {
#line 2084
        if (__gmp_x > __gmp_y) {
#line 2084
          __gmp_result = 1;
        } else {
#line 2084
          __gmp_result = -1;
        }
#line 2084
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 2084
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 2085
  return (__gmp_result);
}
}
#line 2091 "/usr/include/x86_64-linux-gnu/gmp.h"
__inline extern mp_limb_t __gmpn_sub(mp_ptr __gmp_wp , mp_srcptr __gmp_xp , mp_size_t __gmp_xsize ,
                                     mp_srcptr __gmp_yp , mp_size_t __gmp_ysize ) 
{ 
  mp_limb_t __gmp_c ;
  mp_size_t __gmp_i ;
  mp_limb_t __gmp_x ;
  mp_size_t tmp ;
  mp_limb_t tmp___0 ;
  mp_size_t __gmp_j ;

  {
  {
#line 2097
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2097
    __gmp_i = __gmp_ysize;
#line 2097
    if (__gmp_i != 0L) {
      {
#line 2097
      tmp___0 = __gmpn_sub_n(__gmp_wp, __gmp_xp, __gmp_yp, __gmp_i);
      }
#line 2097
      if (tmp___0) {
        {
#line 2097
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 2097
          if (__gmp_i >= __gmp_xsize) {
#line 2097
            __gmp_c = (mp_limb_t )1;
#line 2097
            goto __gmp_done;
          }
#line 2097
          __gmp_x = (mp_limb_t )*(__gmp_xp + __gmp_i);
#line 2097
          tmp = __gmp_i;
#line 2097
          __gmp_i ++;
#line 2097
          *(__gmp_wp + tmp) = (__gmp_x - 1UL) & 0xffffffffffffffffUL;
#line 2097
          if (! (__gmp_x == 0UL)) {
#line 2097
            goto while_break___0;
          }
        }
        while_break___0: /* CIL Label */ ;
        }
      }
    }
#line 2097
    if ((unsigned long )__gmp_wp != (unsigned long )__gmp_xp) {
      {
#line 2097
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 2097
        __gmp_j = __gmp_i;
        {
#line 2097
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 2097
          if (! (__gmp_j < __gmp_xsize)) {
#line 2097
            goto while_break___2;
          }
#line 2097
          *(__gmp_wp + __gmp_j) = (mp_limb_t )*(__gmp_xp + __gmp_j);
#line 2097
          __gmp_j ++;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 2097
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
#line 2097
    __gmp_c = (mp_limb_t )0;
    __gmp_done: ;
#line 2097
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 2098
  return (__gmp_c);
}
}
#line 2104 "/usr/include/x86_64-linux-gnu/gmp.h"
__inline extern mp_limb_t __gmpn_sub_1(mp_ptr __gmp_dst , mp_srcptr __gmp_src , mp_size_t __gmp_size ,
                                       mp_limb_t __gmp_n ) 
{ 
  mp_limb_t __gmp_c ;
  mp_size_t __gmp_i ;
  mp_limb_t __gmp_x ;
  mp_limb_t __gmp_r ;
  mp_size_t __gmp_j ;
  mp_size_t __gmp_j___0 ;

  {
  {
#line 2110
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2110
    __gmp_x = (mp_limb_t )*(__gmp_src + 0);
#line 2110
    __gmp_r = __gmp_x - __gmp_n;
#line 2110
    *(__gmp_dst + 0) = __gmp_r;
#line 2110
    if (__gmp_x < __gmp_n) {
#line 2110
      __gmp_c = (mp_limb_t )1;
#line 2110
      __gmp_i = (mp_size_t )1;
      {
#line 2110
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 2110
        if (! (__gmp_i < __gmp_size)) {
#line 2110
          goto while_break___0;
        }
#line 2110
        __gmp_x = (mp_limb_t )*(__gmp_src + __gmp_i);
#line 2110
        __gmp_r = __gmp_x - 1UL;
#line 2110
        *(__gmp_dst + __gmp_i) = __gmp_r;
#line 2110
        __gmp_i ++;
#line 2110
        if (! (__gmp_x < 1UL)) {
#line 2110
          if ((unsigned long )__gmp_src != (unsigned long )__gmp_dst) {
            {
#line 2110
            while (1) {
              while_continue___1: /* CIL Label */ ;
#line 2110
              __gmp_j = __gmp_i;
              {
#line 2110
              while (1) {
                while_continue___2: /* CIL Label */ ;
#line 2110
                if (! (__gmp_j < __gmp_size)) {
#line 2110
                  goto while_break___2;
                }
#line 2110
                *(__gmp_dst + __gmp_j) = (mp_limb_t )*(__gmp_src + __gmp_j);
#line 2110
                __gmp_j ++;
              }
              while_break___2: /* CIL Label */ ;
              }
#line 2110
              goto while_break___1;
            }
            while_break___1: /* CIL Label */ ;
            }
          }
#line 2110
          __gmp_c = (mp_limb_t )0;
#line 2110
          goto while_break___0;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
    } else {
#line 2110
      if ((unsigned long )__gmp_src != (unsigned long )__gmp_dst) {
        {
#line 2110
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 2110
          __gmp_j___0 = (mp_size_t )1;
          {
#line 2110
          while (1) {
            while_continue___4: /* CIL Label */ ;
#line 2110
            if (! (__gmp_j___0 < __gmp_size)) {
#line 2110
              goto while_break___4;
            }
#line 2110
            *(__gmp_dst + __gmp_j___0) = (mp_limb_t )*(__gmp_src + __gmp_j___0);
#line 2110
            __gmp_j___0 ++;
          }
          while_break___4: /* CIL Label */ ;
          }
#line 2110
          goto while_break___3;
        }
        while_break___3: /* CIL Label */ ;
        }
      }
#line 2110
      __gmp_c = (mp_limb_t )0;
    }
#line 2110
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 2111
  return (__gmp_c);
}
}
#line 2117 "/usr/include/x86_64-linux-gnu/gmp.h"
__inline extern mp_limb_t __gmpn_neg(mp_ptr __gmp_rp , mp_srcptr __gmp_up , mp_size_t __gmp_n ) 
{ 
  mp_limb_t __gmp_ul ;
  mp_limb_t __gmp_cy ;
  mp_srcptr tmp ;
  mp_ptr tmp___0 ;

  {
#line 2123
  __gmp_cy = (mp_limb_t )0;
  {
#line 2124
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2125
    tmp = __gmp_up;
#line 2125
    __gmp_up ++;
#line 2125
    __gmp_ul = (mp_limb_t )*tmp;
#line 2126
    tmp___0 = __gmp_rp;
#line 2126
    __gmp_rp ++;
#line 2126
    *tmp___0 = - __gmp_ul - __gmp_cy;
#line 2127
    __gmp_cy |= (unsigned long )(__gmp_ul != 0UL);
#line 2124
    __gmp_n --;
#line 2124
    if (! (__gmp_n != 0L)) {
#line 2124
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2129
  return (__gmp_cy);
}
}
#line 189 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/ratlp.h"
void lps_mstfile(Lps const   *lp , FILE *fp , LpFormat format , char const   *text ) ;
#line 166 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/ratlpstore.h"
int lps_getnamesize(Lps const   *lp , LpFormat format ) ;
#line 168
void lps_makename(char *target , int size , char const   *name , int no ) ;
#line 53 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/ratmstwrite.c"
void lps_mstfile(Lps const   *lp , FILE *fp , LpFormat format , char const   *text ) 
{ 
  Var const   *var ;
  int name_size ;
  char *vtmp ;
  void *tmp ;
  double tmp___0 ;

  {
  {
#line 67
  name_size = lps_getnamesize(lp, format);
#line 68
  tmp = mem_malloc((size_t )name_size, "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/ratmstwrite.c",
                   (int const   )68);
#line 68
  vtmp = (char *)tmp;
  }
#line 72
  if ((unsigned long )text != (unsigned long )((void *)0)) {
    {
#line 73
    fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"* %s\n",
            text);
    }
  }
  {
#line 75
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"NAME        %8.8s\n",
          lp->name);
#line 77
  var = (Var const   *)lp->var_root;
  }
  {
#line 77
  while (1) {
    while_continue: /* CIL Label */ ;
#line 77
    if (! ((unsigned long )var != (unsigned long )((void *)0))) {
#line 77
      goto while_break;
    }
#line 79
    if ((unsigned int const   )var->vclass == 0U) {
#line 80
      goto __Cont;
    }
#line 82
    if (var->size == 0) {
#line 83
      goto __Cont;
    }
    {
#line 85
    lps_makename(vtmp, name_size, (char const   *)var->name, (int )var->number);
#line 87
    tmp___0 = __gmpq_get_d((mpq_srcptr )(var->startval));
#line 87
    fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"    %-*s  %.10e",
            name_size - 1, vtmp, tmp___0);
#line 90
    fputc('\n', fp);
    }
    __Cont: /* CIL Label */ 
#line 77
    var = (Var const   *)var->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 92
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"ENDATA\n");
#line 94
  mem_free((void *)vtmp, "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/ratmstwrite.c",
           (int const   )94);
  }
#line 95
  return;
}
}
#line 362 "/usr/include/stdio.h"
extern int printf(char const   * __restrict  __format  , ...) ;
#line 515 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) abort)(void) ;
#line 144 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 236
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 1129 "/usr/include/x86_64-linux-gnu/gmp.h"
extern void __gmpq_add(mpq_ptr  , mpq_srcptr  , mpq_srcptr  ) ;
#line 1135
extern void __gmpq_clear(mpq_ptr  ) ;
#line 1141
extern int __gmpq_cmp(mpq_srcptr  , mpq_srcptr  )  __attribute__((__pure__)) ;
#line 1156
extern int __gmpq_equal(mpq_srcptr  , mpq_srcptr  )  __attribute__((__pure__)) ;
#line 1171
extern void __gmpq_init(mpq_ptr  ) ;
#line 1182
extern void __gmpq_inv(mpq_ptr  , mpq_srcptr  ) ;
#line 1185
extern void __gmpq_mul(mpq_ptr  , mpq_srcptr  , mpq_srcptr  ) ;
#line 1216
extern void __gmpq_set_si(mpq_ptr  , long  , unsigned long  ) ;
#line 1222
extern void __gmpq_set_ui(mpq_ptr  , unsigned long  , unsigned long  ) ;
#line 38 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/mshell.h"
extern void *mem_calloc(size_t  , size_t  , char const   * , int const    ) ;
#line 41 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/gmpmisc.h"
mpq_t const_zero ;
#line 92 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/mono.h"
extern int mono_get_degree(Mono const   *mono ) ;
#line 100
extern Var *mono_get_var(Mono const   *mono , int idx ) ;
#line 55 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/term.h"
extern void term_free(Term *term ) ;
#line 59
extern Term *term_copy(Term const   *term ) ;
#line 87
extern int term_get_elements(Term const   *term ) ;
#line 89
extern Mono *term_get_element(Term const   *term , int i ) ;
#line 50 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/ratlp.h"
Lps *lps_alloc(char const   *name ) ;
#line 52
void lps_free(Lps *lp ) ;
#line 54
void lps_number(Lps const   *lp ) ;
#line 56
Sos *lps_getsos(Lps const   *lp , char const   *name ) ;
#line 58
Var *lps_getvar(Lps const   *lp , char const   *name ) ;
#line 60
Con *lps_getcon(Lps const   *lp , char const   *name ) ;
#line 62
Nzo *lps_getnzo(Lps const   *lp , Con const   *con , Var const   *var ) ;
#line 64
Sos *lps_addsos(Lps *lp , char const   *name , SosType type , int priority ) ;
#line 66
void lps_addsse(Sos *sos , Var *var , __mpq_struct * const  weight ) ;
#line 68
Var *lps_addvar(Lps *lp , char const   *name ) ;
#line 70
void lps_delvar(Lps *lp , Var *var ) ;
#line 72
Con *lps_addcon(Lps *lp , char const   *name ) ;
#line 74
void lps_delcon(Lps *lp , Con *con ) ;
#line 76
void lps_addnzo(Lps *lp , Con *con , Var *var , __mpq_struct * const  value ) ;
#line 78
void lps_delnzo(Lps *lp , Nzo *nzo ) ;
#line 80
void lps_addqme(Lps *lp , Con *con , Var *var1 , Var *var2 , __mpq_struct * const  value ) ;
#line 82
void lps_addterm(Lps *lp , Con *con , Term const   *term ) ;
#line 84
void lps_stat(Lps const   *lp ) ;
#line 86
void lps_setval(Nzo *nzo , __mpq_struct * const  value ) ;
#line 88
void lps_getval(Nzo const   *nzo , __mpq_struct *value ) ;
#line 90
void lps_setdir(Lps *lp , LpDirect direct ) ;
#line 92
void lps_setprobname(Lps *lp , char const   *name ) ;
#line 94
void lps_setobjname(Lps *lp , char const   *name ) ;
#line 96
void lps_setrhsname(Lps *lp , char const   *name ) ;
#line 98
void lps_setbndname(Lps *lp , char const   *name ) ;
#line 100
void lps_setrngname(Lps *lp , char const   *name ) ;
#line 102
void lps_getcost(Var const   *var , __mpq_struct *cost ) ;
#line 104
void lps_setcost(Var *var , __mpq_struct * const  cost ) ;
#line 106
Bool lps_haslower(Var const   *var ) ;
#line 108
void lps_getlower(Var const   *var , __mpq_struct *lower ) ;
#line 110
void lps_setlower(Var *var , __mpq_struct * const  lower ) ;
#line 112
Bool lps_hasupper(Var const   *var ) ;
#line 114
void lps_getupper(Var const   *var , __mpq_struct *upper ) ;
#line 116
void lps_setupper(Var *var , __mpq_struct * const  upper ) ;
#line 118
VarClass lps_getclass(Var const   *var ) ;
#line 120
void lps_setclass(Var *var , VarClass vclass ) ;
#line 122
void lps_setlhs(Con *con , __mpq_struct * const  lhs ) ;
#line 124
void lps_setrhs(Con *con , __mpq_struct * const  rhs ) ;
#line 126
void lps_setcontype(Con *con , ConType type ) ;
#line 128
ConType lps_contype(Con const   *con ) ;
#line 130
VarType lps_vartype(Var const   *var ) ;
#line 132
void lps_getlhs(Con const   *con , __mpq_struct *lhs ) ;
#line 134
void lps_getrhs(Con const   *con , __mpq_struct *rhs ) ;
#line 136
char const   *lps_varname(Var const   *var ) ;
#line 138
void lps_setvartype(Var *var , VarType type ) ;
#line 140
unsigned int lps_flags(Con const   *con ) ;
#line 142
void lps_addflags(Con *con , unsigned int flags ) ;
#line 144
void lps_setscale(Con *con , __mpq_struct * const  scale ) ;
#line 146
void lps_setpriority(Var *var , int priority ) ;
#line 148
void lps_setvalue(Var *var , __mpq_struct * const  value ) ;
#line 150
void lps_setstartval(Var *var , __mpq_struct * const  startval ) ;
#line 152
void lps_setnamelen(Lps *lp , int name_len ) ;
#line 154
void lps_setindicator(Con *con , Var *var , Bool on_true ) ;
#line 156
void lps_write(Lps const   *lp , FILE *fp , LpFormat format , char const   *text ) ;
#line 158
void lps_transtable(Lps const   *lp , FILE *fp , LpFormat format , char const   *head ) ;
#line 160
void lps_scale(Lps const   *lp ) ;
#line 162
Bool lps_has_sos(Lps const   *lp ) ;
#line 164
Bool lps_con_sumup(Con const   *con , __mpq_struct *sum ) ;
#line 174
void lpf_write(Lps const   *lp , FILE *fp , LpFormat format , char const   *text ) ;
#line 179
void mps_write(Lps const   *lp , FILE *fp , char const   *text ) ;
#line 64 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/ratlpstore.c"
static unsigned int const   sto_size  =    (unsigned int const   )1000;
#line 102 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/ratlpstore.c"
static unsigned int hashit(char const   *s ) 
{ 
  unsigned int hcode ;

  {
#line 104
  hcode = 0U;
  {
#line 112
  while (1) {
    while_continue: /* CIL Label */ ;
#line 112
    if (! ((int const   )*s != 0)) {
#line 112
      goto while_break;
    }
#line 113
    hcode = 31U * hcode + (unsigned int )((unsigned char )*s);
#line 112
    s ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 115
  return (hcode);
}
}
#line 118 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/ratlpstore.c"
static LpsHash *lps_hash_new(LpsHashType type ) 
{ 
  LpsHash *hash ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 120
  tmp = mem_calloc((size_t )1, sizeof(*hash), "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/ratlpstore.c",
                   (int const   )120);
#line 120
  hash = (LpsHash *)tmp;
#line 124
  hash->size = 1000003U;
#line 125
  hash->elems = 0;
#line 126
  hash->type = type;
#line 127
  tmp___0 = mem_calloc((size_t )hash->size, sizeof(*(hash->bucket)), "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/ratlpstore.c",
                       (int const   )127);
#line 127
  hash->bucket = (LpsHElem **)tmp___0;
  }
#line 133
  return (hash);
}
}
#line 136 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/ratlpstore.c"
static void lps_hash_free(LpsHash *hash ) 
{ 
  LpsHElem *he ;
  LpsHElem *hq ;
  unsigned int i ;

  {
#line 149
  i = 0U;
  {
#line 149
  while (1) {
    while_continue: /* CIL Label */ ;
#line 149
    if (! (i < hash->size)) {
#line 149
      goto while_break;
    }
#line 151
    he = *(hash->bucket + i);
    {
#line 151
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 151
      if (! ((unsigned long )he != (unsigned long )((void *)0))) {
#line 151
        goto while_break___0;
      }
      {
#line 153
      hq = he->next;
#line 154
      mem_free((void *)he, "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/ratlpstore.c",
               (int const   )154);
#line 151
      he = hq;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 149
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 157
  mem_free((void *)hash->bucket, "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/ratlpstore.c",
           (int const   )157);
#line 158
  mem_free((void *)hash, "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/ratlpstore.c",
           (int const   )158);
  }
#line 159
  return;
}
}
#line 163 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/ratlpstore.c"
static Var *hash_lookup_var(LpsHash const   *hash , char const   *name ) 
{ 
  unsigned int hcode ;
  LpsHElem *he ;
  unsigned int tmp ;
  int tmp___0 ;
  Var *tmp___1 ;

  {
  {
#line 172
  tmp = hashit(name);
#line 172
  hcode = tmp % (unsigned int )hash->size;
#line 174
  he = *(hash->bucket + hcode);
  }
  {
#line 174
  while (1) {
    while_continue: /* CIL Label */ ;
#line 174
    if (! ((unsigned long )he != (unsigned long )((void *)0))) {
#line 174
      goto while_break;
    }
    {
#line 175
    tmp___0 = strcmp((char const   *)(he->value.var)->name, name);
    }
#line 175
    if (! tmp___0) {
#line 176
      goto while_break;
    }
#line 174
    he = he->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 178
  if ((unsigned long )he == (unsigned long )((void *)0)) {
#line 178
    tmp___1 = (Var *)0;
  } else {
#line 178
    tmp___1 = he->value.var;
  }
#line 178
  return (tmp___1);
}
}
#line 183 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/ratlpstore.c"
static Con *hash_lookup_con(LpsHash const   *hash , char const   *name ) 
{ 
  unsigned int hcode ;
  LpsHElem *he ;
  unsigned int tmp ;
  int tmp___0 ;
  Con *tmp___1 ;

  {
  {
#line 192
  tmp = hashit(name);
#line 192
  hcode = tmp % (unsigned int )hash->size;
#line 194
  he = *(hash->bucket + hcode);
  }
  {
#line 194
  while (1) {
    while_continue: /* CIL Label */ ;
#line 194
    if (! ((unsigned long )he != (unsigned long )((void *)0))) {
#line 194
      goto while_break;
    }
    {
#line 195
    tmp___0 = strcmp((char const   *)(he->value.con)->name, name);
    }
#line 195
    if (! tmp___0) {
#line 196
      goto while_break;
    }
#line 194
    he = he->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 198
  if ((unsigned long )he == (unsigned long )((void *)0)) {
#line 198
    tmp___1 = (Con *)0;
  } else {
#line 198
    tmp___1 = he->value.con;
  }
#line 198
  return (tmp___1);
}
}
#line 203 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/ratlpstore.c"
static Sos *hash_lookup_sos(LpsHash const   *hash , char const   *name ) 
{ 
  unsigned int hcode ;
  LpsHElem *he ;
  unsigned int tmp ;
  int tmp___0 ;
  Sos *tmp___1 ;

  {
  {
#line 212
  tmp = hashit(name);
#line 212
  hcode = tmp % (unsigned int )hash->size;
#line 214
  he = *(hash->bucket + hcode);
  }
  {
#line 214
  while (1) {
    while_continue: /* CIL Label */ ;
#line 214
    if (! ((unsigned long )he != (unsigned long )((void *)0))) {
#line 214
      goto while_break;
    }
    {
#line 215
    tmp___0 = strcmp((char const   *)(he->value.sos)->name, name);
    }
#line 215
    if (! tmp___0) {
#line 216
      goto while_break;
    }
#line 214
    he = he->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 218
  if ((unsigned long )he == (unsigned long )((void *)0)) {
#line 218
    tmp___1 = (Sos *)0;
  } else {
#line 218
    tmp___1 = he->value.sos;
  }
#line 218
  return (tmp___1);
}
}
#line 221 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/ratlpstore.c"
static void hash_add_var(LpsHash *hash , Var *var ) 
{ 
  LpsHElem *he ;
  void *tmp ;
  unsigned int hcode ;
  unsigned int tmp___0 ;

  {
  {
#line 223
  tmp = mem_calloc((size_t )1, sizeof(*he), "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/ratlpstore.c",
                   (int const   )223);
#line 223
  he = (LpsHElem *)tmp;
#line 231
  tmp___0 = hashit((char const   *)var->name);
#line 231
  hcode = tmp___0 % hash->size;
#line 232
  he->value.var = var;
#line 233
  he->next = *(hash->bucket + hcode);
#line 234
  *(hash->bucket + hcode) = he;
#line 235
  (hash->elems) ++;
  }
#line 238
  return;
}
}
#line 240 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/ratlpstore.c"
static void hash_del_var(LpsHash *hash , Var const   *var ) 
{ 
  LpsHElem *he ;
  LpsHElem *next___0 ;
  unsigned int hcode ;
  unsigned int tmp ;

  {
  {
#line 250
  tmp = hashit((char const   *)var->name);
#line 250
  hcode = tmp % hash->size;
#line 252
  he = *(hash->bucket + hcode);
#line 252
  next___0 = (LpsHElem *)((void *)0);
  }
  {
#line 252
  while (1) {
    while_continue: /* CIL Label */ ;
#line 252
    if (! ((unsigned long )he != (unsigned long )((void *)0))) {
#line 252
      goto while_break;
    }
#line 253
    if ((unsigned long )he->value.var == (unsigned long )var) {
#line 254
      goto while_break;
    }
#line 252
    next___0 = he;
#line 252
    he = he->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 258
  if ((unsigned long )next___0 == (unsigned long )((void *)0)) {
#line 259
    *(hash->bucket + hcode) = he->next;
  } else {
#line 261
    next___0->next = he->next;
  }
  {
#line 263
  (hash->elems) --;
#line 265
  mem_free((void *)he, "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/ratlpstore.c",
           (int const   )265);
  }
#line 268
  return;
}
}
#line 270 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/ratlpstore.c"
static void hash_add_con(LpsHash *hash , Con *con ) 
{ 
  LpsHElem *he ;
  void *tmp ;
  unsigned int hcode ;
  unsigned int tmp___0 ;

  {
  {
#line 272
  tmp = mem_calloc((size_t )1, sizeof(*he), "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/ratlpstore.c",
                   (int const   )272);
#line 272
  he = (LpsHElem *)tmp;
#line 280
  tmp___0 = hashit((char const   *)con->name);
#line 280
  hcode = tmp___0 % hash->size;
#line 281
  he->value.con = con;
#line 282
  he->next = *(hash->bucket + hcode);
#line 283
  *(hash->bucket + hcode) = he;
#line 284
  (hash->elems) ++;
  }
#line 287
  return;
}
}
#line 289 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/ratlpstore.c"
static void hash_add_sos(LpsHash *hash , Sos *sos ) 
{ 
  LpsHElem *he ;
  void *tmp ;
  unsigned int hcode ;
  unsigned int tmp___0 ;

  {
  {
#line 291
  tmp = mem_calloc((size_t )1, sizeof(*he), "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/ratlpstore.c",
                   (int const   )291);
#line 291
  he = (LpsHElem *)tmp;
#line 299
  tmp___0 = hashit((char const   *)sos->name);
#line 299
  hcode = tmp___0 % hash->size;
#line 300
  he->value.sos = sos;
#line 301
  he->next = *(hash->bucket + hcode);
#line 302
  *(hash->bucket + hcode) = he;
#line 303
  (hash->elems) ++;
  }
#line 306
  return;
}
}
#line 308 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/ratlpstore.c"
static void hash_del_con(LpsHash *hash , Con const   *con ) 
{ 
  LpsHElem *he ;
  LpsHElem *next___0 ;
  unsigned int hcode ;
  unsigned int tmp ;

  {
  {
#line 318
  tmp = hashit((char const   *)con->name);
#line 318
  hcode = tmp % hash->size;
#line 320
  he = *(hash->bucket + hcode);
#line 320
  next___0 = (LpsHElem *)((void *)0);
  }
  {
#line 320
  while (1) {
    while_continue: /* CIL Label */ ;
#line 320
    if (! ((unsigned long )he != (unsigned long )((void *)0))) {
#line 320
      goto while_break;
    }
#line 321
    if ((unsigned long )he->value.con == (unsigned long )con) {
#line 322
      goto while_break;
    }
#line 320
    next___0 = he;
#line 320
    he = he->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 326
  if ((unsigned long )next___0 == (unsigned long )((void *)0)) {
#line 327
    *(hash->bucket + hcode) = he->next;
  } else {
#line 329
    next___0->next = he->next;
  }
  {
#line 331
  (hash->elems) --;
#line 333
  mem_free((void *)he, "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/ratlpstore.c",
           (int const   )333);
  }
#line 336
  return;
}
}
#line 598 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/ratlpstore.c"
static void lps_storage(Lps *lp ) 
{ 
  Sto *s ;
  Nzo *n ;
  unsigned int i ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 607
  tmp = mem_malloc(sizeof(*s), "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/ratlpstore.c",
                   (int const   )607);
#line 607
  s = (Sto *)tmp;
#line 611
  tmp___0 = mem_malloc((unsigned long )sto_size * sizeof(*n), "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/ratlpstore.c",
                       (int const   )611);
#line 611
  n = (Nzo *)tmp___0;
#line 615
  i = 0U;
  }
  {
#line 615
  while (1) {
    while_continue: /* CIL Label */ ;
#line 615
    if (! (i < (unsigned int )(sto_size - 1U))) {
#line 615
      goto while_break;
    }
    {
#line 617
    (n + i)->var_next = n + (i + 1U);
#line 618
    __gmpq_init((n + i)->value);
#line 615
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 628
  (n + i)->var_next = (Nzo *)((void *)0);
#line 629
  __gmpq_init((n + i)->value);
#line 638
  s->size = (int )sto_size;
#line 639
  s->begin = n;
#line 640
  s->next = lp->sto_root;
#line 641
  lp->sto_root = s;
#line 642
  lp->next = s->begin;
  }
#line 643
  return;
}
}
#line 645 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/ratlpstore.c"
Lps *lps_alloc(char const   *name ) 
{ 
  Lps *lp ;
  void *tmp ;

  {
  {
#line 652
  tmp = mem_malloc(sizeof(*lp), "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/ratlpstore.c",
                   (int const   )652);
#line 652
  lp = (Lps *)tmp;
#line 656
  lp->name = mem_strdup(name, "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/ratlpstore.c",
                        (int const   )656);
#line 657
  lp->probname = (char *)((void *)0);
#line 658
  lp->objname = (char *)((void *)0);
#line 659
  lp->rhsname = (char *)((void *)0);
#line 660
  lp->bndname = (char *)((void *)0);
#line 661
  lp->rngname = (char *)((void *)0);
#line 662
  lp->type = (LpType )1;
#line 663
  lp->direct = (LpDirect )0;
#line 664
  lp->vars = 0;
#line 665
  lp->cons = 0;
#line 666
  lp->soss = 0;
#line 667
  lp->nonzeros = 0;
#line 668
  lp->var_root = (Var *)((void *)0);
#line 669
  lp->con_root = (Con *)((void *)0);
#line 670
  lp->sos_root = (Sos *)((void *)0);
#line 671
  lp->sto_root = (Sto *)((void *)0);
#line 672
  lp->next = (Nzo *)((void *)0);
#line 673
  lp->var_hash = lps_hash_new((LpsHashType )1);
#line 674
  lp->con_hash = lps_hash_new((LpsHashType )2);
#line 675
  lp->sos_hash = lps_hash_new((LpsHashType )3);
#line 676
  lp->var_last = (Var *)((void *)0);
#line 677
  lp->con_last = (Con *)((void *)0);
#line 678
  lp->sos_last = (Sos *)((void *)0);
#line 679
  lp->name_len = 0;
  }
#line 683
  return (lp);
}
}
#line 686 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/ratlpstore.c"
void lps_free(Lps *lp ) 
{ 
  Var *var ;
  Var *var_next ;
  Con *con ;
  Con *con_next ;
  Sos *sos ;
  Sos *sos_next ;
  Sse *sse ;
  Sse *sse_next ;
  Sto *sto ;
  Sto *sto_next ;
  unsigned int i ;
  Qme *qme ;
  Qme *qme_next ;

  {
  {
#line 702
  lps_hash_free(lp->var_hash);
#line 703
  lps_hash_free(lp->con_hash);
#line 704
  lps_hash_free(lp->sos_hash);
#line 706
  sto = lp->sto_root;
  }
  {
#line 706
  while (1) {
    while_continue: /* CIL Label */ ;
#line 706
    if (! ((unsigned long )sto != (unsigned long )((void *)0))) {
#line 706
      goto while_break;
    }
#line 708
    i = 0U;
    {
#line 708
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 708
      if (! (i < (unsigned int )sto_size)) {
#line 708
        goto while_break___0;
      }
      {
#line 709
      __gmpq_clear((sto->begin + i)->value);
#line 708
      i ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 711
    sto_next = sto->next;
#line 713
    mem_free((void *)sto->begin, "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/ratlpstore.c",
             (int const   )713);
#line 714
    mem_free((void *)sto, "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/ratlpstore.c",
             (int const   )714);
#line 706
    sto = sto_next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 716
  var = lp->var_root;
  {
#line 716
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 716
    if (! ((unsigned long )var != (unsigned long )((void *)0))) {
#line 716
      goto while_break___1;
    }
    {
#line 718
    var_next = var->next;
#line 719
    var->sid = 0U;
#line 721
    __gmpq_clear(var->cost);
#line 722
    __gmpq_clear(var->lower);
#line 723
    __gmpq_clear(var->upper);
#line 724
    __gmpq_clear(var->value);
#line 725
    __gmpq_clear(var->startval);
#line 727
    mem_free((void *)var->name, "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/ratlpstore.c",
             (int const   )727);
#line 728
    mem_free((void *)var, "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/ratlpstore.c",
             (int const   )728);
#line 716
    var = var_next;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 730
  con = lp->con_root;
  {
#line 730
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 730
    if (! ((unsigned long )con != (unsigned long )((void *)0))) {
#line 730
      goto while_break___2;
    }
#line 735
    con_next = con->next;
#line 736
    con->sid = 0U;
#line 738
    qme = con->qme_first;
    {
#line 738
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 738
      if (! ((unsigned long )qme != (unsigned long )((void *)0))) {
#line 738
        goto while_break___3;
      }
      {
#line 740
      qme_next = qme->next;
#line 742
      __gmpq_clear(qme->value);
#line 743
      mem_free((void *)qme, "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/ratlpstore.c",
               (int const   )743);
#line 738
      qme = qme_next;
      }
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 745
    __gmpq_clear(con->lhs);
#line 746
    __gmpq_clear(con->rhs);
#line 747
    __gmpq_clear(con->scale);
    }
#line 749
    if ((unsigned long )con->term != (unsigned long )((void *)0)) {
      {
#line 750
      term_free(con->term);
      }
    }
    {
#line 752
    mem_free((void *)con->name, "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/ratlpstore.c",
             (int const   )752);
#line 753
    mem_free((void *)con, "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/ratlpstore.c",
             (int const   )753);
#line 730
    con = con_next;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 755
  sos = lp->sos_root;
  {
#line 755
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 755
    if (! ((unsigned long )sos != (unsigned long )((void *)0))) {
#line 755
      goto while_break___4;
    }
#line 757
    sos_next = sos->next;
#line 758
    sos->sid = 0U;
#line 760
    sse = sos->first;
    {
#line 760
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 760
      if (! ((unsigned long )sse != (unsigned long )((void *)0))) {
#line 760
        goto while_break___5;
      }
      {
#line 762
      sse_next = sse->next;
#line 763
      __gmpq_clear(sse->weight);
#line 764
      mem_free((void *)sse, "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/ratlpstore.c",
               (int const   )764);
#line 760
      sse = sse_next;
      }
    }
    while_break___5: /* CIL Label */ ;
    }
    {
#line 766
    mem_free((void *)sos->name, "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/ratlpstore.c",
             (int const   )766);
#line 767
    mem_free((void *)sos, "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/ratlpstore.c",
             (int const   )767);
#line 755
    sos = sos_next;
    }
  }
  while_break___4: /* CIL Label */ ;
  }
#line 769
  if ((unsigned long )lp->probname != (unsigned long )((void *)0)) {
    {
#line 770
    mem_free((void *)lp->probname, "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/ratlpstore.c",
             (int const   )770);
    }
  }
#line 771
  if ((unsigned long )lp->objname != (unsigned long )((void *)0)) {
    {
#line 772
    mem_free((void *)lp->objname, "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/ratlpstore.c",
             (int const   )772);
    }
  }
#line 773
  if ((unsigned long )lp->rhsname != (unsigned long )((void *)0)) {
    {
#line 774
    mem_free((void *)lp->rhsname, "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/ratlpstore.c",
             (int const   )774);
    }
  }
#line 775
  if ((unsigned long )lp->bndname != (unsigned long )((void *)0)) {
    {
#line 776
    mem_free((void *)lp->bndname, "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/ratlpstore.c",
             (int const   )776);
    }
  }
#line 777
  if ((unsigned long )lp->rngname != (unsigned long )((void *)0)) {
    {
#line 778
    mem_free((void *)lp->rngname, "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/ratlpstore.c",
             (int const   )778);
    }
  }
  {
#line 780
  mem_free((void *)lp->name, "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/ratlpstore.c",
           (int const   )780);
#line 781
  mem_free((void *)lp, "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/ratlpstore.c",
           (int const   )781);
  }
#line 782
  return;
}
}
#line 784 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/ratlpstore.c"
void lps_number(Lps const   *lp ) 
{ 
  Var *var ;
  Con *con ;
  int i ;

  {
#line 792
  var = (Var *)lp->var_root;
#line 792
  i = 0;
  {
#line 792
  while (1) {
    while_continue: /* CIL Label */ ;
#line 792
    if (! ((unsigned long )var != (unsigned long )((void *)0))) {
#line 792
      goto while_break;
    }
#line 797
    var->number = i;
#line 792
    var = var->next;
#line 792
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 801
  con = (Con *)lp->con_root;
#line 801
  i = 0;
  {
#line 801
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 801
    if (! ((unsigned long )con != (unsigned long )((void *)0))) {
#line 801
      goto while_break___0;
    }
#line 806
    con->number = i;
#line 801
    con = con->next;
#line 801
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 809
  return;
}
}
#line 811 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/ratlpstore.c"
Var *lps_getvar(Lps const   *lp , char const   *name ) 
{ 
  Var *vr ;

  {
  {
#line 820
  vr = hash_lookup_var((LpsHash const   *)lp->var_hash, name);
  }
#line 836
  return (vr);
}
}
#line 839 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/ratlpstore.c"
Con *lps_getcon(Lps const   *lp , char const   *name ) 
{ 
  Con *cr ;

  {
  {
#line 848
  cr = hash_lookup_con((LpsHash const   *)lp->con_hash, name);
  }
#line 864
  return (cr);
}
}
#line 867 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/ratlpstore.c"
Sos *lps_getsos(Lps const   *lp , char const   *name ) 
{ 
  Sos *sr ;

  {
  {
#line 876
  sr = hash_lookup_sos((LpsHash const   *)lp->sos_hash, name);
  }
#line 892
  return (sr);
}
}
#line 895 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/ratlpstore.c"
Nzo *lps_getnzo(Lps const   *lp , Con const   *con , Var const   *var ) 
{ 
  Nzo *nzo ;

  {
#line 910
  if (var->size <= con->size) {
#line 912
    nzo = (Nzo *)var->first;
    {
#line 912
    while (1) {
      while_continue: /* CIL Label */ ;
#line 912
      if (! ((unsigned long )nzo != (unsigned long )((void *)0))) {
#line 912
        goto while_break;
      }
#line 913
      if ((unsigned long )nzo->con == (unsigned long )con) {
#line 914
        goto while_break;
      }
#line 912
      nzo = nzo->var_next;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 918
    nzo = (Nzo *)con->first;
    {
#line 918
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 918
      if (! ((unsigned long )nzo != (unsigned long )((void *)0))) {
#line 918
        goto while_break___0;
      }
#line 919
      if ((unsigned long )nzo->var == (unsigned long )var) {
#line 920
        goto while_break___0;
      }
#line 918
      nzo = nzo->con_next;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 924
  return (nzo);
}
}
#line 927 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/ratlpstore.c"
Var *lps_addvar(Lps *lp , char const   *name ) 
{ 
  Var *v ;
  void *tmp ;

  {
  {
#line 937
  tmp = mem_malloc(sizeof(*v), "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/ratlpstore.c",
                   (int const   )937);
#line 937
  v = (Var *)tmp;
#line 941
  __gmpq_init(v->cost);
#line 942
  __gmpq_init(v->lower);
#line 943
  __gmpq_init(v->upper);
#line 944
  __gmpq_init(v->value);
#line 945
  __gmpq_init(v->startval);
#line 947
  v->sid = 1582711122U;
#line 948
  v->name = mem_strdup(name, "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/ratlpstore.c",
                       (int const   )948);
#line 949
  v->number = lp->vars;
#line 950
  v->vclass = (VarClass )0;
#line 951
  v->type = (VarType )0;
#line 952
  v->is_used = 0;
#line 953
  v->priority = 0;
#line 954
  v->size = 0;
#line 955
  v->first = (Nzo *)((void *)0);
#line 956
  v->next = (Var *)((void *)0);
#line 957
  v->prev = lp->var_last;
#line 958
  lp->var_last = v;
  }
#line 960
  if ((unsigned long )v->prev == (unsigned long )((void *)0)) {
#line 961
    lp->var_root = v;
  } else {
#line 966
    (v->prev)->next = v;
  }
  {
#line 968
  (lp->vars) ++;
#line 970
  hash_add_var(lp->var_hash, v);
  }
#line 974
  return (v);
}
}
#line 977 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/ratlpstore.c"
void lps_delvar(Lps *lp , Var *var ) 
{ 


  {
  {
#line 985
  while (1) {
    while_continue: /* CIL Label */ ;
#line 985
    if (! ((unsigned long )var->first != (unsigned long )((void *)0))) {
#line 985
      goto while_break;
    }
    {
#line 986
    lps_delnzo(lp, var->first);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 992
  if ((unsigned long )var->prev != (unsigned long )((void *)0)) {
#line 994
    (var->prev)->next = var->next;
  } else {
#line 1002
    lp->var_root = var->next;
  }
#line 1009
  if ((unsigned long )var->next != (unsigned long )((void *)0)) {
#line 1011
    (var->next)->prev = var->prev;
  } else {
#line 1019
    lp->var_last = var->prev;
  }
  {
#line 1023
  hash_del_var(lp->var_hash, (Var const   *)var);
#line 1025
  __gmpq_clear(var->cost);
#line 1026
  __gmpq_clear(var->lower);
#line 1027
  __gmpq_clear(var->upper);
#line 1028
  __gmpq_clear(var->value);
#line 1029
  __gmpq_clear(var->startval);
#line 1031
  var->sid = 0U;
#line 1033
  mem_free((void *)var->name, "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/ratlpstore.c",
           (int const   )1033);
#line 1034
  mem_free((void *)var, "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/ratlpstore.c",
           (int const   )1034);
#line 1036
  (lp->vars) --;
  }
#line 1039
  return;
}
}
#line 1041 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/ratlpstore.c"
Con *lps_addcon(Lps *lp , char const   *name ) 
{ 
  Con *c ;
  void *tmp ;

  {
  {
#line 1051
  tmp = mem_calloc((size_t )1, sizeof(*c), "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/ratlpstore.c",
                   (int const   )1051);
#line 1051
  c = (Con *)tmp;
#line 1055
  __gmpq_init(c->lhs);
#line 1056
  __gmpq_init(c->rhs);
#line 1057
  __gmpq_init(c->scale);
#line 1059
  c->sid = 1581469518U;
#line 1060
  c->name = mem_strdup(name, "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/ratlpstore.c",
                       (int const   )1060);
#line 1061
  c->number = lp->cons;
#line 1062
  c->size = 0;
#line 1063
  c->type = (ConType )0;
#line 1064
  c->flags = 0U;
#line 1065
  c->ind_var = (Var *)((void *)0);
#line 1066
  c->ind_dir = 1;
#line 1067
  c->first = (Nzo *)((void *)0);
#line 1068
  c->qme_first = (Qme *)((void *)0);
#line 1069
  c->term = (Term *)((void *)0);
#line 1070
  c->next = (Con *)((void *)0);
#line 1071
  c->prev = lp->con_last;
#line 1072
  lp->con_last = c;
  }
#line 1074
  if ((unsigned long )c->prev == (unsigned long )((void *)0)) {
#line 1075
    lp->con_root = c;
  } else {
#line 1080
    (c->prev)->next = c;
  }
  {
#line 1082
  (lp->cons) ++;
#line 1084
  hash_add_con(lp->con_hash, c);
  }
#line 1088
  return (c);
}
}
#line 1091 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/ratlpstore.c"
void lps_delcon(Lps *lp , Con *con ) 
{ 


  {
  {
#line 1099
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1099
    if (! ((unsigned long )con->first != (unsigned long )((void *)0))) {
#line 1099
      goto while_break;
    }
    {
#line 1100
    lps_delnzo(lp, con->first);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1106
  if ((unsigned long )con->prev != (unsigned long )((void *)0)) {
#line 1108
    (con->prev)->next = con->next;
  } else {
#line 1116
    lp->con_root = con->next;
  }
#line 1123
  if ((unsigned long )con->next != (unsigned long )((void *)0)) {
#line 1125
    (con->next)->prev = con->prev;
  } else {
#line 1133
    lp->con_last = con->prev;
  }
  {
#line 1137
  hash_del_con(lp->con_hash, (Con const   *)con);
#line 1139
  con->sid = 0U;
#line 1141
  __gmpq_clear(con->lhs);
#line 1142
  __gmpq_clear(con->rhs);
#line 1143
  __gmpq_clear(con->scale);
#line 1145
  mem_free((void *)con->name, "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/ratlpstore.c",
           (int const   )1145);
#line 1146
  mem_free((void *)con, "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/ratlpstore.c",
           (int const   )1146);
#line 1148
  (lp->cons) --;
  }
#line 1153
  return;
}
}
#line 1155 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/ratlpstore.c"
Sos *lps_addsos(Lps *lp , char const   *name , SosType type , int priority ) 
{ 
  Sos *sos ;
  void *tmp ;

  {
  {
#line 1167
  tmp = mem_malloc(sizeof(*sos), "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/ratlpstore.c",
                   (int const   )1167);
#line 1167
  sos = (Sos *)tmp;
#line 1171
  sos->sid = 1582518099U;
#line 1172
  sos->name = mem_strdup(name, "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/ratlpstore.c",
                         (int const   )1172);
#line 1173
  sos->type = type;
#line 1174
  sos->priority = priority;
#line 1175
  sos->sses = 0;
#line 1176
  sos->first = (Sse *)((void *)0);
#line 1177
  sos->next = (Sos *)((void *)0);
  }
#line 1179
  if ((unsigned long )lp->sos_last != (unsigned long )((void *)0)) {
#line 1180
    (lp->sos_last)->next = sos;
  }
#line 1182
  lp->sos_last = sos;
#line 1184
  if ((unsigned long )lp->sos_root == (unsigned long )((void *)0)) {
#line 1185
    lp->sos_root = sos;
  }
  {
#line 1187
  (lp->soss) ++;
#line 1189
  hash_add_sos(lp->sos_hash, sos);
  }
#line 1193
  return (sos);
}
}
#line 1197 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/ratlpstore.c"
void lps_addqme(Lps *lp , Con *con , Var *var1 , Var *var2 , __mpq_struct * const  value ) 
{ 
  Qme *qme ;
  void *tmp ;

  {
  {
#line 1204
  tmp = mem_malloc(sizeof(*qme), "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/ratlpstore.c",
                   (int const   )1204);
#line 1204
  qme = (Qme *)tmp;
#line 1208
  qme->sid = 1364026734U;
#line 1209
  qme->var1 = (Var const   *)var1;
#line 1210
  qme->var2 = (Var const   *)var2;
#line 1212
  __gmpq_init(qme->value);
#line 1213
  __gmpq_set(qme->value, (mpq_srcptr )value);
#line 1215
  qme->next = con->qme_first;
#line 1216
  con->qme_first = qme;
#line 1218
  var1->is_used = 1;
#line 1219
  var2->is_used = 1;
  }
#line 1220
  return;
}
}
#line 1223 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/ratlpstore.c"
void lps_addterm(Lps *lp , Con *con , Term const   *term ) 
{ 
  int i ;
  int k ;
  Mono const   *mono ;
  Mono *tmp ;
  Var *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 1235
  con->term = term_copy(term);
#line 1237
  i = 0;
  }
  {
#line 1237
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1237
    tmp___2 = term_get_elements(term);
    }
#line 1237
    if (! (i < tmp___2)) {
#line 1237
      goto while_break;
    }
    {
#line 1239
    tmp = term_get_element(term, i);
#line 1239
    mono = (Mono const   *)tmp;
#line 1241
    k = 0;
    }
    {
#line 1241
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 1241
      tmp___1 = mono_get_degree(mono);
      }
#line 1241
      if (! (k < tmp___1)) {
#line 1241
        goto while_break___0;
      }
      {
#line 1242
      tmp___0 = mono_get_var(mono, k);
#line 1242
      tmp___0->is_used = 1;
#line 1241
      k ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1237
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1244
  return;
}
}
#line 1246 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/ratlpstore.c"
void lps_addsse(Sos *sos , Var *var , __mpq_struct * const  weight ) 
{ 
  Sse *sse ;
  void *tmp ;

  {
  {
#line 1258
  tmp = mem_malloc(sizeof(*sse), "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/ratlpstore.c",
                   (int const   )1258);
#line 1258
  sse = (Sse *)tmp;
#line 1262
  __gmpq_init(sse->weight);
#line 1263
  __gmpq_set(sse->weight, (mpq_srcptr )weight);
#line 1265
  sse->var = var;
#line 1266
  sse->next = sos->first;
#line 1267
  sos->first = sse;
#line 1269
  (sos->sses) ++;
#line 1271
  (sse->var)->is_used = 1;
  }
#line 1272
  return;
}
}
#line 1274 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/ratlpstore.c"
void lps_addnzo(Lps *lp , Con *con , Var *var , __mpq_struct * const  value ) 
{ 
  Nzo *nzo ;

  {
#line 1290
  if ((unsigned long )lp->next == (unsigned long )((void *)0)) {
    {
#line 1291
    lps_storage(lp);
    }
  }
  {
#line 1293
  nzo = lp->next;
#line 1297
  lp->next = nzo->var_next;
#line 1298
  (lp->nonzeros) ++;
#line 1300
  __gmpq_set(nzo->value, (mpq_srcptr )value);
#line 1304
  nzo->var = var;
#line 1305
  nzo->var_prev = (Nzo *)((void *)0);
#line 1306
  nzo->var_next = var->first;
#line 1307
  var->first = nzo;
#line 1308
  (var->size) ++;
  }
#line 1310
  if ((unsigned long )nzo->var_next != (unsigned long )((void *)0)) {
#line 1314
    (nzo->var_next)->var_prev = nzo;
  }
#line 1319
  nzo->con = con;
#line 1320
  nzo->con_prev = (Nzo *)((void *)0);
#line 1321
  nzo->con_next = con->first;
#line 1322
  con->first = nzo;
#line 1323
  (con->size) ++;
#line 1325
  if ((unsigned long )nzo->con_next != (unsigned long )((void *)0)) {
#line 1329
    (nzo->con_next)->con_prev = nzo;
  }
#line 1332
  return;
}
}
#line 1334 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/ratlpstore.c"
void lps_delnzo(Lps *lp , Nzo *nzo ) 
{ 


  {
#line 1343
  if ((unsigned long )nzo == (unsigned long )(nzo->var)->first) {
#line 1344
    (nzo->var)->first = nzo->var_next;
  }
#line 1346
  if ((unsigned long )nzo->var_prev != (unsigned long )((void *)0)) {
#line 1347
    (nzo->var_prev)->var_next = nzo->var_next;
  }
#line 1348
  if ((unsigned long )nzo->var_next != (unsigned long )((void *)0)) {
#line 1349
    (nzo->var_next)->var_prev = nzo->var_prev;
  }
#line 1350
  ((nzo->var)->size) --;
#line 1354
  if ((unsigned long )nzo == (unsigned long )(nzo->con)->first) {
#line 1355
    (nzo->con)->first = nzo->con_next;
  }
#line 1357
  if ((unsigned long )nzo->con_prev != (unsigned long )((void *)0)) {
#line 1358
    (nzo->con_prev)->con_next = nzo->con_next;
  }
#line 1359
  if ((unsigned long )nzo->con_next != (unsigned long )((void *)0)) {
#line 1360
    (nzo->con_next)->con_prev = nzo->con_prev;
  }
#line 1361
  ((nzo->con)->size) --;
#line 1365
  nzo->var_next = lp->next;
#line 1366
  lp->next = nzo;
#line 1367
  (lp->nonzeros) --;
#line 1370
  return;
}
}
#line 1372 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/ratlpstore.c"
void lps_setval(Nzo *nzo , __mpq_struct * const  value ) 
{ 


  {
  {
#line 1378
  __gmpq_set(nzo->value, (mpq_srcptr )value);
  }
#line 1379
  return;
}
}
#line 1381 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/ratlpstore.c"
void lps_getval(Nzo const   *nzo , __mpq_struct *value ) 
{ 


  {
  {
#line 1387
  __gmpq_set((mpq_ptr )value, (mpq_srcptr )(nzo->value));
  }
#line 1388
  return;
}
}
#line 1390 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/ratlpstore.c"
void lps_setdir(Lps *lp , LpDirect direct ) 
{ 


  {
#line 1396
  lp->direct = direct;
#line 1397
  return;
}
}
#line 1399 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/ratlpstore.c"
void lps_setprobname(Lps *lp , char const   *name ) 
{ 


  {
#line 1406
  if ((unsigned long )lp->probname != (unsigned long )((void *)0)) {
    {
#line 1407
    mem_free((void *)lp->probname, "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/ratlpstore.c",
             (int const   )1407);
    }
  }
  {
#line 1409
  lp->probname = mem_strdup(name, "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/ratlpstore.c",
                            (int const   )1409);
  }
#line 1410
  return;
}
}
#line 1412 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/ratlpstore.c"
void lps_setobjname(Lps *lp , char const   *name ) 
{ 


  {
#line 1419
  if ((unsigned long )lp->objname != (unsigned long )((void *)0)) {
    {
#line 1420
    mem_free((void *)lp->objname, "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/ratlpstore.c",
             (int const   )1420);
    }
  }
  {
#line 1422
  lp->objname = mem_strdup(name, "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/ratlpstore.c",
                           (int const   )1422);
  }
#line 1423
  return;
}
}
#line 1425 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/ratlpstore.c"
void lps_setrhsname(Lps *lp , char const   *name ) 
{ 


  {
#line 1432
  if ((unsigned long )lp->rhsname != (unsigned long )((void *)0)) {
    {
#line 1433
    mem_free((void *)lp->rhsname, "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/ratlpstore.c",
             (int const   )1433);
    }
  }
  {
#line 1435
  lp->rhsname = mem_strdup(name, "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/ratlpstore.c",
                           (int const   )1435);
  }
#line 1436
  return;
}
}
#line 1438 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/ratlpstore.c"
void lps_setbndname(Lps *lp , char const   *name ) 
{ 


  {
#line 1445
  if ((unsigned long )lp->bndname != (unsigned long )((void *)0)) {
    {
#line 1446
    mem_free((void *)lp->bndname, "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/ratlpstore.c",
             (int const   )1446);
    }
  }
  {
#line 1448
  lp->bndname = mem_strdup(name, "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/ratlpstore.c",
                           (int const   )1448);
  }
#line 1449
  return;
}
}
#line 1451 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/ratlpstore.c"
void lps_setrngname(Lps *lp , char const   *name ) 
{ 


  {
#line 1458
  if ((unsigned long )lp->rngname != (unsigned long )((void *)0)) {
    {
#line 1459
    mem_free((void *)lp->rngname, "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/ratlpstore.c",
             (int const   )1459);
    }
  }
  {
#line 1461
  lp->rngname = mem_strdup(name, "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/ratlpstore.c",
                           (int const   )1461);
  }
#line 1462
  return;
}
}
#line 1464 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/ratlpstore.c"
void lps_getcost(Var const   *var , __mpq_struct *cost ) 
{ 


  {
  {
#line 1471
  __gmpq_set((mpq_ptr )cost, (mpq_srcptr )(var->cost));
  }
#line 1472
  return;
}
}
#line 1474 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/ratlpstore.c"
Bool lps_haslower(Var const   *var ) 
{ 
  int tmp ;

  {
#line 1479
  if ((unsigned int const   )var->type != 0U) {
#line 1479
    if ((unsigned int const   )var->type != 2U) {
#line 1479
      tmp = 1;
    } else {
#line 1479
      tmp = 0;
    }
  } else {
#line 1479
    tmp = 0;
  }
#line 1479
  return (tmp);
}
}
#line 1482 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/ratlpstore.c"
void lps_setcost(Var *var , __mpq_struct * const  cost ) 
{ 


  {
  {
#line 1489
  __gmpq_set(var->cost, (mpq_srcptr )cost);
  }
#line 1490
  return;
}
}
#line 1492 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/ratlpstore.c"
void lps_getlower(Var const   *var , __mpq_struct *lower ) 
{ 


  {
  {
#line 1497
  __gmpq_set((mpq_ptr )lower, (mpq_srcptr )(var->lower));
  }
#line 1498
  return;
}
}
#line 1500 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/ratlpstore.c"
void lps_setlower(Var *var , __mpq_struct * const  lower ) 
{ 
  int tmp___0 ;

  {
  {
#line 1507
  __gmpq_set(var->lower, (mpq_srcptr )lower);
  }
#line 1515
  if ((unsigned int )var->type == 0U) {
#line 1516
    var->type = (VarType )1;
  } else
#line 1517
  if ((unsigned int )var->type != 1U) {
    {
#line 1521
    tmp___0 = __gmpq_equal((mpq_srcptr )(var->lower), (mpq_srcptr )(var->upper));
    }
#line 1521
    if (tmp___0) {
#line 1521
      var->type = (VarType )4;
    } else {
#line 1521
      var->type = (VarType )3;
    }
  }
#line 1523
  return;
}
}
#line 1525 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/ratlpstore.c"
Bool lps_hasupper(Var const   *var ) 
{ 
  int tmp ;

  {
#line 1530
  if ((unsigned int const   )var->type != 0U) {
#line 1530
    if ((unsigned int const   )var->type != 1U) {
#line 1530
      tmp = 1;
    } else {
#line 1530
      tmp = 0;
    }
  } else {
#line 1530
    tmp = 0;
  }
#line 1530
  return (tmp);
}
}
#line 1533 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/ratlpstore.c"
void lps_getupper(Var const   *var , __mpq_struct *upper ) 
{ 


  {
  {
#line 1538
  __gmpq_set((mpq_ptr )upper, (mpq_srcptr )(var->upper));
  }
#line 1539
  return;
}
}
#line 1541 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/ratlpstore.c"
void lps_setupper(Var *var , __mpq_struct * const  upper ) 
{ 
  int tmp___0 ;

  {
  {
#line 1548
  __gmpq_set(var->upper, (mpq_srcptr )upper);
  }
#line 1556
  if ((unsigned int )var->type == 0U) {
#line 1557
    var->type = (VarType )2;
  } else
#line 1558
  if ((unsigned int )var->type != 2U) {
    {
#line 1562
    tmp___0 = __gmpq_equal((mpq_srcptr )(var->lower), (mpq_srcptr )(var->upper));
    }
#line 1562
    if (tmp___0) {
#line 1562
      var->type = (VarType )4;
    } else {
#line 1562
      var->type = (VarType )3;
    }
  }
#line 1564
  return;
}
}
#line 1566 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/ratlpstore.c"
void lps_setlhs(Con *con , __mpq_struct * const  lhs ) 
{ 
  int tmp___0 ;

  {
  {
#line 1573
  __gmpq_set(con->lhs, (mpq_srcptr )lhs);
  }
#line 1581
  if ((unsigned int )con->type == 0U) {
#line 1582
    con->type = (ConType )1;
  } else
#line 1583
  if ((unsigned int )con->type != 1U) {
    {
#line 1587
    tmp___0 = __gmpq_equal((mpq_srcptr )(con->lhs), (mpq_srcptr )(con->rhs));
    }
#line 1587
    if (tmp___0) {
#line 1587
      con->type = (ConType )4;
    } else {
#line 1587
      con->type = (ConType )3;
    }
  }
#line 1589
  return;
}
}
#line 1591 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/ratlpstore.c"
void lps_setrhs(Con *con , __mpq_struct * const  rhs ) 
{ 
  int tmp___0 ;

  {
  {
#line 1598
  __gmpq_set(con->rhs, (mpq_srcptr )rhs);
  }
#line 1606
  if ((unsigned int )con->type == 0U) {
#line 1607
    con->type = (ConType )2;
  } else
#line 1608
  if ((unsigned int )con->type != 2U) {
    {
#line 1612
    tmp___0 = __gmpq_equal((mpq_srcptr )(con->lhs), (mpq_srcptr )(con->rhs));
    }
#line 1612
    if (tmp___0) {
#line 1612
      con->type = (ConType )4;
    } else {
#line 1612
      con->type = (ConType )3;
    }
  }
#line 1614
  return;
}
}
#line 1616 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/ratlpstore.c"
void lps_setcontype(Con *con , ConType type ) 
{ 


  {
#line 1621
  con->type = type;
#line 1622
  return;
}
}
#line 1624 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/ratlpstore.c"
ConType lps_contype(Con const   *con ) 
{ 


  {
#line 1629
  return ((ConType )con->type);
}
}
#line 1632 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/ratlpstore.c"
VarType lps_vartype(Var const   *var ) 
{ 


  {
#line 1637
  return ((VarType )var->type);
}
}
#line 1640 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/ratlpstore.c"
VarClass lps_getclass(Var const   *var ) 
{ 


  {
#line 1645
  return ((VarClass )var->vclass);
}
}
#line 1648 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/ratlpstore.c"
void lps_setclass(Var *var , VarClass vclass ) 
{ 


  {
#line 1653
  var->vclass = vclass;
#line 1654
  return;
}
}
#line 1656 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/ratlpstore.c"
void lps_getlhs(Con const   *con , __mpq_struct *lhs ) 
{ 


  {
  {
#line 1663
  __gmpq_set((mpq_ptr )lhs, (mpq_srcptr )(con->lhs));
  }
#line 1664
  return;
}
}
#line 1666 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/ratlpstore.c"
void lps_getrhs(Con const   *con , __mpq_struct *rhs ) 
{ 


  {
  {
#line 1673
  __gmpq_set((mpq_ptr )rhs, (mpq_srcptr )(con->rhs));
  }
#line 1674
  return;
}
}
#line 1676 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/ratlpstore.c"
char const   *lps_varname(Var const   *var ) 
{ 


  {
#line 1681
  return ((char const   *)var->name);
}
}
#line 1684 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/ratlpstore.c"
void lps_setvartype(Var *var , VarType type ) 
{ 


  {
#line 1691
  var->type = type;
#line 1692
  return;
}
}
#line 1694 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/ratlpstore.c"
unsigned int lps_flags(Con const   *con ) 
{ 


  {
#line 1699
  return ((unsigned int )con->flags);
}
}
#line 1702 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/ratlpstore.c"
void lps_addflags(Con *con , unsigned int flags ) 
{ 


  {
#line 1709
  con->flags |= flags;
#line 1710
  return;
}
}
#line 1712 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/ratlpstore.c"
void lps_setscale(Con *con , __mpq_struct * const  scale ) 
{ 


  {
  {
#line 1719
  __gmpq_set(con->scale, (mpq_srcptr )scale);
  }
#line 1720
  return;
}
}
#line 1722 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/ratlpstore.c"
void lps_setpriority(Var *var , int priority ) 
{ 


  {
#line 1729
  var->priority = priority;
#line 1730
  return;
}
}
#line 1732 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/ratlpstore.c"
void lps_setvalue(Var *var , __mpq_struct * const  value ) 
{ 


  {
  {
#line 1739
  __gmpq_set(var->value, (mpq_srcptr )value);
  }
#line 1740
  return;
}
}
#line 1742 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/ratlpstore.c"
void lps_setstartval(Var *var , __mpq_struct * const  startval ) 
{ 


  {
  {
#line 1749
  __gmpq_set(var->startval, (mpq_srcptr )startval);
  }
#line 1750
  return;
}
}
#line 1752 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/ratlpstore.c"
void lps_setnamelen(Lps *lp , int name_len ) 
{ 


  {
#line 1756
  lp->name_len = name_len;
#line 1757
  return;
}
}
#line 1760 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/ratlpstore.c"
void lps_setindicator(Con *con , Var *var , Bool on_true ) 
{ 


  {
#line 1770
  con->ind_var = var;
#line 1771
  con->ind_dir = on_true;
#line 1772
  return;
}
}
#line 1774 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/ratlpstore.c"
void lps_stat(Lps const   *lp ) 
{ 


  {
  {
#line 1778
  printf((char const   */* __restrict  */)"Name: %s   Variables: %d   Constraints: %d   Non Zeros: %d\n",
         lp->name, lp->vars, lp->cons, lp->nonzeros);
  }
#line 1780
  return;
}
}
#line 1782 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/ratlpstore.c"
int lps_getnamesize(Lps const   *lp , LpFormat format ) 
{ 
  int name_size ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 1784
  name_size = 0;
  {
#line 1790
  if ((unsigned int )format == 1U) {
#line 1790
    goto case_1;
  }
#line 1793
  if ((unsigned int )format == 2U) {
#line 1793
    goto case_2;
  }
#line 1796
  if ((unsigned int )format == 3U) {
#line 1796
    goto case_3;
  }
#line 1799
  if ((unsigned int )format == 4U) {
#line 1799
    goto case_4;
  }
#line 1802
  if ((unsigned int )format == 5U) {
#line 1802
    goto case_5;
  }
#line 1805
  goto switch_default;
  case_1: /* CIL Label */ 
#line 1791
  if (lp->name_len < 8) {
#line 1791
    tmp = 16;
  } else {
#line 1791
    tmp = (int )lp->name_len;
  }
#line 1791
  name_size = 1 + tmp;
#line 1792
  goto switch_break;
  case_2: /* CIL Label */ 
#line 1794
  name_size = 4096;
#line 1795
  goto switch_break;
  case_3: /* CIL Label */ 
#line 1797
  if (lp->name_len < 8) {
#line 1797
    tmp___0 = 8;
  } else {
#line 1797
    tmp___0 = (int )lp->name_len;
  }
#line 1797
  name_size = 1 + tmp___0;
#line 1798
  goto switch_break;
  case_4: /* CIL Label */ 
#line 1800
  if (lp->name_len < 8) {
#line 1800
    tmp___1 = 16;
  } else {
#line 1800
    tmp___1 = (int )lp->name_len;
  }
#line 1800
  name_size = 1 + tmp___1;
#line 1801
  goto switch_break;
  case_5: /* CIL Label */ 
#line 1803
  if (lp->name_len < 8) {
#line 1803
    tmp___2 = 255;
  } else {
#line 1803
    tmp___2 = (int )lp->name_len;
  }
#line 1803
  name_size = 1 + tmp___2;
#line 1804
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 1806
  abort();
  }
  switch_break: /* CIL Label */ ;
  }
#line 1810
  return (name_size);
}
}
#line 1813 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/ratlpstore.c"
void lps_write(Lps const   *lp , FILE *fp , LpFormat format , char const   *text ) 
{ 


  {
  {
#line 1822
  lps_number(lp);
  }
  {
#line 1829
  if ((unsigned int )format == 2U) {
#line 1829
    goto case_2;
  }
#line 1829
  if ((unsigned int )format == 5U) {
#line 1829
    goto case_2;
  }
#line 1829
  if ((unsigned int )format == 4U) {
#line 1829
    goto case_2;
  }
#line 1829
  if ((unsigned int )format == 1U) {
#line 1829
    goto case_2;
  }
#line 1832
  if ((unsigned int )format == 3U) {
#line 1832
    goto case_3;
  }
#line 1835
  goto switch_default;
  case_2: /* CIL Label */ 
  case_5: /* CIL Label */ 
  case_4: /* CIL Label */ 
  case_1: /* CIL Label */ 
  {
#line 1830
  lpf_write(lp, fp, format, text);
  }
#line 1831
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 1833
  mps_write(lp, fp, text);
  }
#line 1834
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 1836
  abort();
  }
  switch_break: /* CIL Label */ ;
  }
#line 1838
  return;
}
}
#line 1844
static Bool lpfstrncpy(char *t , char const   *s , int len ) ;
#line 1844 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/ratlpstore.c"
static char const   * const  allowed  =    (char const   */* const  */)"!#$%&()/,.;?_{}|~";
#line 1840 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/ratlpstore.c"
static Bool lpfstrncpy(char *t , char const   *s , int len ) 
{ 
  Bool was_smashed ;
  unsigned short const   **tmp ;
  char *tmp___0 ;

  {
#line 1846
  was_smashed = 0;
  {
#line 1848
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1848
    len --;
#line 1848
    if (len >= 0) {
#line 1848
      if (! ((int const   )*s != 0)) {
#line 1848
        goto while_break;
      }
    } else {
#line 1848
      goto while_break;
    }
    {
#line 1850
    tmp = __ctype_b_loc();
    }
#line 1850
    if ((int const   )*(*tmp + (int )*s) & 8) {
#line 1851
      *t = (char )*s;
    } else {
      {
#line 1850
      tmp___0 = strchr((char const   *)allowed, (int )*s);
      }
#line 1850
      if ((unsigned long )tmp___0 != (unsigned long )((void *)0)) {
#line 1851
        *t = (char )*s;
      } else {
#line 1854
        *t = (char )'_';
#line 1855
        was_smashed = 1;
      }
    }
#line 1857
    s ++;
#line 1858
    t ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1860
  *t = (char )'\000';
#line 1862
  return (was_smashed);
}
}
#line 1865 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/ratlpstore.c"
static void make_full_name(char *target , int size , char const   *name ) 
{ 
  char const   *s ;
  Bool first___0 ;
  Bool in_string ;
  int i ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 1870
  s = name;
#line 1871
  first___0 = 1;
#line 1872
  in_string = 0;
#line 1873
  i = 0;
  {
#line 1881
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1881
    if ((int const   )*s != 0) {
#line 1881
      if (! (size > i + 6)) {
#line 1881
        goto while_break;
      }
    } else {
#line 1881
      goto while_break;
    }
#line 1883
    if ((int const   )*s != 35) {
#line 1883
      if ((int const   )*s != 36) {
#line 1884
        tmp = i;
#line 1884
        i ++;
#line 1884
        *(target + tmp) = (char )*s;
      } else {
#line 1883
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 1887
      if (first___0) {
#line 1889
        first___0 = 0;
#line 1890
        tmp___0 = i;
#line 1890
        i ++;
#line 1890
        *(target + tmp___0) = (char )'[';
      } else {
#line 1894
        if (in_string) {
#line 1896
          tmp___1 = i;
#line 1896
          i ++;
#line 1896
          *(target + tmp___1) = (char )'\"';
#line 1897
          in_string = 0;
        }
#line 1899
        tmp___2 = i;
#line 1899
        i ++;
#line 1899
        *(target + tmp___2) = (char )',';
      }
#line 1901
      if ((int const   )*s == 36) {
#line 1905
        in_string = 1;
#line 1906
        tmp___3 = i;
#line 1906
        i ++;
#line 1906
        *(target + tmp___3) = (char )'\"';
      }
    }
#line 1911
    s ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1913
  if (size > i + 2) {
#line 1915
    if (in_string) {
#line 1916
      tmp___4 = i;
#line 1916
      i ++;
#line 1916
      *(target + tmp___4) = (char )'\"';
    }
#line 1917
    if (! first___0) {
#line 1918
      tmp___5 = i;
#line 1918
      i ++;
#line 1918
      *(target + tmp___5) = (char )']';
    }
  }
#line 1920
  tmp___6 = i;
#line 1920
  i ++;
#line 1920
  *(target + tmp___6) = (char )'\000';
#line 1923
  return;
}
}
#line 1928 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/ratlpstore.c"
void lps_makename(char *target , int size , char const   *name , int no ) 
{ 
  char temp[9] ;
  int len ;
  int nlen ;
  size_t tmp ;
  size_t tmp___0 ;
  Bool tmp___1 ;
  size_t tmp___2 ;

  {
  {
#line 1944
  tmp = strlen(name);
#line 1944
  nlen = (int )tmp;
  }
#line 1957
  if (no == -1) {
    {
#line 1958
    make_full_name(target, size, name);
    }
  } else
#line 1959
  if (nlen < size) {
    {
#line 1961
    tmp___1 = lpfstrncpy(target, name, nlen);
    }
#line 1961
    if (tmp___1) {
      {
#line 1963
      sprintf((char */* __restrict  */)(temp), (char const   */* __restrict  */)"@%x",
              no);
#line 1965
      tmp___0 = strlen((char const   *)(temp));
#line 1965
      len = (size - (int )tmp___0) - 1;
#line 1975
      *(target + len) = (char )'\000';
#line 1976
      strcat((char */* __restrict  */)target, (char const   */* __restrict  */)(temp));
      }
    }
  } else {
    {
#line 1981
    sprintf((char */* __restrict  */)(temp), (char const   */* __restrict  */)"@%x",
            no);
#line 1983
    tmp___2 = strlen((char const   *)(temp));
#line 1983
    len = (size - (int )tmp___2) - 1;
#line 1987
    lpfstrncpy(target, name, len);
#line 1988
    strcat((char */* __restrict  */)target, (char const   */* __restrict  */)(temp));
    }
  }
#line 1991
  return;
}
}
#line 1993 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/ratlpstore.c"
void lps_transtable(Lps const   *lp , FILE *fp , LpFormat format , char const   *head ) 
{ 
  Var *var ;
  Con *con ;
  char *temp ;
  int namelen ;
  void *tmp ;
  double tmp___0 ;
  int tmp___1 ;
  double tmp___2 ;

  {
  {
#line 2005
  namelen = lps_getnamesize(lp, format);
#line 2006
  tmp = mem_malloc((size_t )namelen, "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/ratlpstore.c",
                   (int const   )2006);
#line 2006
  temp = (char *)tmp;
#line 2010
  lps_number(lp);
#line 2012
  var = (Var *)lp->var_root;
  }
  {
#line 2012
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2012
    if (! ((unsigned long )var != (unsigned long )((void *)0))) {
#line 2012
      goto while_break;
    }
    {
#line 2014
    lps_makename(temp, namelen, (char const   *)var->name, var->number);
    }
#line 2016
    if ((unsigned int )var->type == 4U) {
      {
#line 2017
      tmp___0 = __gmpq_get_d((mpq_srcptr )(var->lower));
#line 2017
      fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%s\tv %7d\t%-*s\t\"%s\"\t%.16e\n",
              head, var->number, namelen - 1, temp, var->name, tmp___0);
      }
    } else
#line 2021
    if (var->size > 0) {
      {
#line 2022
      fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%s\tv %7d\t%-*s\t\"%s\"\n",
              head, var->number, namelen - 1, temp, var->name);
      }
    } else {
      {
#line 2021
      tmp___1 = __gmpq_equal((mpq_srcptr )(var->cost), (mpq_srcptr )(const_zero));
      }
#line 2021
      if (! tmp___1) {
        {
#line 2022
        fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%s\tv %7d\t%-*s\t\"%s\"\n",
                head, var->number, namelen - 1, temp, var->name);
        }
      }
    }
#line 2012
    var = var->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 2026
  con = (Con *)lp->con_root;
  {
#line 2026
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2026
    if (! ((unsigned long )con != (unsigned long )((void *)0))) {
#line 2026
      goto while_break___0;
    }
    {
#line 2028
    lps_makename(temp, namelen, (char const   *)con->name, con->number);
#line 2030
    tmp___2 = __gmpq_get_d((mpq_srcptr )(con->scale));
#line 2030
    fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%s\tc %7d\t%-*s\t\"%s\"\t%.16e\n",
            head, con->number, namelen - 1, temp, con->name, tmp___2);
#line 2026
    con = con->next;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 2033
  mem_free((void *)temp, "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/ratlpstore.c",
           (int const   )2033);
  }
#line 2034
  return;
}
}
#line 2036 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/ratlpstore.c"
void lps_scale(Lps const   *lp ) 
{ 
  Con *con ;
  Nzo *nzo ;
  mpq_t maxi ;
  mpq_t v ;
  int tmp ;

  {
  {
#line 2045
  __gmpq_init(maxi);
#line 2046
  __gmpq_init(v);
#line 2048
  con = (Con *)lp->con_root;
  }
  {
#line 2048
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2048
    if (! ((unsigned long )con != (unsigned long )((void *)0))) {
#line 2048
      goto while_break;
    }
#line 2050
    if ((con->flags & 1U) > 0U) {
      {
#line 2052
      __gmpq_set_ui(maxi, 0UL, 1UL);
#line 2054
      nzo = con->first;
      }
      {
#line 2054
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 2054
        if (! ((unsigned long )nzo != (unsigned long )((void *)0))) {
#line 2054
          goto while_break___0;
        }
        {
#line 2056
        __gmpq_abs(v, (mpq_srcptr )(nzo->value));
#line 2058
        tmp = __gmpq_cmp((mpq_srcptr )(v), (mpq_srcptr )(maxi));
        }
#line 2058
        if (tmp > 0) {
          {
#line 2059
          __gmpq_set(maxi, (mpq_srcptr )(v));
          }
        }
#line 2054
        nzo = nzo->con_next;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 2061
      __gmpq_inv(con->scale, (mpq_srcptr )(maxi));
      }
#line 2063
      if ((unsigned int )con->type != 0U) {
#line 2063
        if ((unsigned int )con->type != 1U) {
          {
#line 2064
          __gmpq_mul(con->rhs, (mpq_srcptr )(con->rhs), (mpq_srcptr )(con->scale));
          }
        }
      }
#line 2066
      if ((unsigned int )con->type != 0U) {
#line 2066
        if ((unsigned int )con->type != 2U) {
          {
#line 2067
          __gmpq_mul(con->lhs, (mpq_srcptr )(con->lhs), (mpq_srcptr )(con->scale));
          }
        }
      }
#line 2069
      nzo = con->first;
      {
#line 2069
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 2069
        if (! ((unsigned long )nzo != (unsigned long )((void *)0))) {
#line 2069
          goto while_break___1;
        }
        {
#line 2070
        __gmpq_mul(nzo->value, (mpq_srcptr )(nzo->value), (mpq_srcptr )(con->scale));
#line 2069
        nzo = nzo->con_next;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
    }
#line 2048
    con = con->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2073
  __gmpq_clear(v);
#line 2074
  __gmpq_clear(maxi);
  }
#line 2075
  return;
}
}
#line 2077 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/ratlpstore.c"
Bool lps_has_sos(Lps const   *lp ) 
{ 


  {
#line 2081
  return (lp->soss > 0);
}
}
#line 2084 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/ratlpstore.c"
Bool lps_con_sumup(Con const   *con , __mpq_struct *sum ) 
{ 
  Bool usable ;
  Nzo *nzo ;
  mpq_t val ;

  {
  {
#line 2086
  usable = 1;
#line 2090
  __gmpq_set_si((mpq_ptr )sum, 0L, 1UL);
#line 2091
  __gmpq_init(val);
#line 2093
  nzo = (Nzo *)con->first;
  }
  {
#line 2093
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2093
    if (! ((unsigned long )nzo != (unsigned long )((void *)0))) {
#line 2093
      goto while_break;
    }
#line 2095
    if ((unsigned int )(nzo->var)->vclass != 2U) {
#line 2097
      usable = 0;
#line 2098
      goto while_break;
    }
    {
#line 2100
    __gmpq_mul(val, (mpq_srcptr )(nzo->value), (mpq_srcptr )((nzo->var)->startval));
#line 2101
    __gmpq_add((mpq_ptr )sum, (mpq_srcptr )sum, (mpq_srcptr )(val));
#line 2093
    nzo = nzo->con_next;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2103
  __gmpq_clear(val);
  }
#line 2105
  return (usable);
}
}
#line 35 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/blkmem.h"
void blk_init(void) ;
#line 36
void blk_exit(void) ;
#line 37
void *blk_alloc(int size ) ;
#line 38
void blk_free(void *p , int size ) ;
#line 55 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/blkmem.c"
static BlkMem *blk_anchor[8]  ;
#line 56 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/blkmem.c"
static BlkMemElem *first_free[8]  ;
#line 57 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/blkmem.c"
static int blk_fails  =    0;
#line 58 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/blkmem.c"
static int blk_count  =    0;
#line 60 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/blkmem.c"
static void extend_memory(int chain_no ) 
{ 
  BlkMem *block ;
  void *tmp ;
  size_t elem_size ;
  size_t offset ;
  size_t i ;
  void *tmp___0 ;

  {
  {
#line 62
  tmp = mem_calloc((size_t )1, sizeof(*block), "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/blkmem.c",
                   (int const   )62);
#line 62
  block = (BlkMem *)tmp;
#line 63
  elem_size = ((size_t )chain_no + 1UL) * 8UL;
#line 64
  offset = elem_size / sizeof(BlkMemElem );
  }
#line 72
  if ((unsigned long )blk_anchor[chain_no] == (unsigned long )((void *)0)) {
#line 72
    block->elem_count = (size_t )1024;
  } else {
#line 72
    block->elem_count = (blk_anchor[chain_no])->elem_count * 2UL;
  }
  {
#line 74
  tmp___0 = mem_malloc(block->elem_count * elem_size, "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/blkmem.c",
                       (int const   )74);
#line 74
  block->elem = (BlkMemElem *)tmp___0;
#line 75
  block->next = blk_anchor[chain_no];
#line 76
  blk_anchor[chain_no] = block;
#line 81
  i = (size_t )0;
  }
  {
#line 81
  while (1) {
    while_continue: /* CIL Label */ ;
#line 81
    if (! (i < block->elem_count - 1UL)) {
#line 81
      goto while_break;
    }
#line 82
    (block->elem + i * offset)->next = block->elem + (i + 1UL) * offset;
#line 81
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 86
  (block->elem + i * offset)->next = first_free[chain_no];
#line 87
  first_free[chain_no] = block->elem + 0;
#line 91
  return;
}
}
#line 93 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/blkmem.c"
void blk_init(void) 
{ 
  int i ;

  {
#line 97
  i = 0;
  {
#line 97
  while (1) {
    while_continue: /* CIL Label */ ;
#line 97
    if (! (i < 8)) {
#line 97
      goto while_break;
    }
#line 99
    blk_anchor[i] = (BlkMem *)((void *)0);
#line 100
    first_free[i] = (BlkMemElem *)((void *)0);
#line 97
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 102
  return;
}
}
#line 104 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/blkmem.c"
void blk_exit(void) 
{ 
  int i ;
  BlkMem *anchor___0 ;
  BlkMem *next___0 ;

  {
#line 108
  if (blk_count != 0) {
    {
#line 109
    printf((char const   */* __restrict  */)"Block memory allocation count %d\n",
           blk_count);
    }
  }
#line 116
  i = 0;
  {
#line 116
  while (1) {
    while_continue: /* CIL Label */ ;
#line 116
    if (! (i < 8)) {
#line 116
      goto while_break;
    }
#line 121
    anchor___0 = blk_anchor[i];
    {
#line 121
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 121
      if (! ((unsigned long )anchor___0 != (unsigned long )((void *)0))) {
#line 121
        goto while_break___0;
      }
      {
#line 123
      next___0 = anchor___0->next;
#line 125
      mem_free((void *)anchor___0->elem, "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/blkmem.c",
               (int const   )125);
#line 126
      mem_free((void *)anchor___0, "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/blkmem.c",
               (int const   )126);
#line 121
      anchor___0 = next___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 116
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 129
  return;
}
}
#line 131 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/blkmem.c"
void *blk_alloc(int size ) 
{ 
  BlkMemElem *elem ;
  int chain_no ;
  void *tmp ;

  {
#line 134
  chain_no = (size + 7) / 8 - 1;
#line 140
  if (chain_no >= 8) {
    {
#line 142
    blk_fails ++;
#line 143
    tmp = mem_malloc((size_t )size, "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/blkmem.c",
                     (int const   )143);
    }
#line 143
    return (tmp);
  }
#line 145
  if ((unsigned long )first_free[chain_no] == (unsigned long )((void *)0)) {
    {
#line 146
    extend_memory(chain_no);
    }
  }
#line 150
  elem = first_free[chain_no];
#line 151
  first_free[chain_no] = elem->next;
#line 152
  blk_count ++;
#line 154
  return ((void *)elem);
}
}
#line 157 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/blkmem.c"
void blk_free(void *p , int size ) 
{ 
  int chain_no ;
  BlkMemElem *elem ;

  {
#line 159
  chain_no = (size + 7) / 8 - 1;
#line 160
  elem = (BlkMemElem *)p;
#line 167
  if (chain_no >= 8) {
    {
#line 169
    mem_free(p, "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/blkmem.c",
             (int const   )169);
    }
#line 170
    return;
  }
#line 193
  elem->next = first_free[chain_no];
#line 194
  first_free[chain_no] = elem;
#line 195
  blk_count --;
#line 196
  return;
}
}
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 834 "/usr/include/x86_64-linux-gnu/gmp.h"
extern long __gmpz_get_si(mpz_srcptr  )  __attribute__((__pure__)) ;
#line 44 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/numb.h"
extern void numb_free(Numb *numb ) ;
#line 51
extern Bool numb_equal(Numb const   *numb_a , Numb const   *numb_b ) ;
#line 117
extern Numb const   *numb_zero(void) ;
#line 123
extern Numb const   *numb_unknown(void) ;
#line 133
extern Numb *numb_new_mpq(__mpq_struct * const  val ) ;
#line 135
extern void numb_get_mpq(Numb const   *numb , __mpq_struct *value ) ;
#line 77 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/mme.h"
extern int verbose ;
#line 47 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/bound.h"
Bound *bound_new(BoundType type , Numb const   *value ) ;
#line 55
BoundType bound_get_type(Bound const   *bound ) ;
#line 57
Numb const   *bound_get_value(Bound const   *bound ) ;
#line 90 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/mono.h"
extern Bool mono_is_linear(Mono const   *mono ) ;
#line 94
extern Numb const   *mono_get_coeff(Mono const   *mono ) ;
#line 98
extern MFun mono_get_function(Mono const   *mono ) ;
#line 71 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/term.h"
extern Term *term_simplify(Term const   *term_org ) ;
#line 99
extern Bool term_is_polynomial(Term const   *term ) ;
#line 101
extern int term_get_degree(Term const   *term ) ;
#line 69 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/stmt.h"
extern Bool stmt_trigger_warning(int no ) ;
#line 56 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/hash.h"
extern Hash *hash_new(HashType type , int size ) ;
#line 58
extern void hash_free(Hash *hash ) ;
#line 70
extern void hash_add_numb(Hash *hash , Numb const   *numb ) ;
#line 76
extern Bool hash_has_numb(Hash const   *hash , Numb const   *numb ) ;
#line 47 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/xlpglue.h"
Lps *xlp_alloc(char const   *name , Bool need_startval , void *user_data ) ;
#line 49
void xlp_free(Lps *lp ) ;
#line 53
Bool xlp_addcon_term(Lps *lp , char const   *name , ConType contype , Numb const   *lhs ,
                     Numb const   *rhs , unsigned int flags , Term const   *term_org ) ;
#line 56
Var *xlp_addvar(Lps *lp , char const   *name , VarClass varclass , Bound const   *lower ,
                Bound const   *upper , Numb const   *priority , Numb const   *startval ) ;
#line 59
int xlp_addsos_term(Lps *lp , char const   *name , SosType type , Numb const   *priority ,
                    Term const   *term ) ;
#line 62
char const   *xlp_getvarname(Lps const   *lp , Var const   *var ) ;
#line 64
VarClass xlp_getclass(Lps const   *lp , Var const   *var ) ;
#line 66
Bound *xlp_getlower(Lps const   *lp , Var const   *var ) ;
#line 68
Bound *xlp_getupper(Lps const   *lp , Var const   *var ) ;
#line 70
void xlp_objname(Lps *lp , char const   *name ) ;
#line 72
void xlp_setdir(Lps *lp , Bool minimize ) ;
#line 74
void xlp_addtocost(Lps *lp , Var *var , Numb const   *cost ) ;
#line 70 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/xlpglue.c"
static Bool use_startval  =    0;
#line 82 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/xlpglue.c"
Lps *xlp_alloc(char const   *name , Bool need_startval , void *user_data ) 
{ 
  Lps *tmp ;

  {
  {
#line 89
  use_startval = need_startval;
#line 91
  tmp = lps_alloc(name);
  }
#line 91
  return (tmp);
}
}
#line 97 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/xlpglue.c"
void xlp_free(Lps *lp ) 
{ 


  {
  {
#line 102
  lps_free(lp);
  }
#line 103
  return;
}
}
#line 123 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/xlpglue.c"
Bool xlp_conname_exists(Lps const   *lp , char const   *conname ) 
{ 
  Con *tmp ;

  {
  {
#line 130
  tmp = lps_getcon(lp, conname);
  }
#line 130
  return ((unsigned long )((void *)0) != (unsigned long )tmp);
}
}
#line 137 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/xlpglue.c"
static Bool check_con_is_invalid(Con const   *con ) 
{ 
  Bool is_invalid ;
  mpq_t lhs ;
  mpq_t rhs ;
  mpq_t sum ;
  ConType tmp ;
  double tmp___0 ;
  double tmp___1 ;
  int tmp___2 ;
  Bool tmp___3 ;
  double tmp___4 ;
  double tmp___5 ;
  int tmp___6 ;
  Bool tmp___7 ;
  double tmp___8 ;
  double tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  Bool tmp___12 ;
  double tmp___13 ;
  double tmp___14 ;
  double tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  Bool tmp___18 ;
  Bool tmp___19 ;

  {
#line 140
  is_invalid = 0;
#line 147
  if (! use_startval) {
#line 148
    return (0);
  }
  {
#line 150
  __gmpq_init(sum);
#line 151
  __gmpq_init(lhs);
#line 152
  __gmpq_init(rhs);
#line 157
  tmp___19 = lps_con_sumup(con, (__mpq_struct *)(sum));
  }
#line 157
  if (tmp___19) {
    {
#line 159
    lps_getlhs(con, (__mpq_struct *)(lhs));
#line 160
    lps_getrhs(con, (__mpq_struct *)(rhs));
#line 162
    tmp = lps_contype(con);
    }
    {
#line 164
    if ((unsigned int )tmp == 2U) {
#line 164
      goto case_2;
    }
#line 172
    if ((unsigned int )tmp == 1U) {
#line 172
      goto case_1;
    }
#line 180
    if ((unsigned int )tmp == 4U) {
#line 180
      goto case_4;
    }
#line 188
    if ((unsigned int )tmp == 3U) {
#line 188
      goto case_3;
    }
#line 196
    goto switch_default;
    case_2: /* CIL Label */ 
    {
#line 165
    tmp___2 = __gmpq_cmp((mpq_srcptr )(sum), (mpq_srcptr )(rhs));
    }
#line 165
    if (tmp___2 > 0) {
      {
#line 165
      tmp___3 = stmt_trigger_warning(215);
      }
#line 165
      if (tmp___3) {
        {
#line 167
        is_invalid = 1;
#line 168
        tmp___0 = __gmpq_get_d((mpq_srcptr )(rhs));
#line 168
        tmp___1 = __gmpq_get_d((mpq_srcptr )(sum));
#line 168
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"--- Warning 215: Startvals violate constraint, sum of LHS (%g) <= RHS (%g)\n",
                tmp___1, tmp___0);
        }
      }
    }
#line 171
    goto switch_break;
    case_1: /* CIL Label */ 
    {
#line 173
    tmp___6 = __gmpq_cmp((mpq_srcptr )(lhs), (mpq_srcptr )(sum));
    }
#line 173
    if (tmp___6 > 0) {
      {
#line 173
      tmp___7 = stmt_trigger_warning(215);
      }
#line 173
      if (tmp___7) {
        {
#line 175
        is_invalid = 1;
#line 176
        tmp___4 = __gmpq_get_d((mpq_srcptr )(lhs));
#line 176
        tmp___5 = __gmpq_get_d((mpq_srcptr )(sum));
#line 176
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"--- Warning 215: Startvals violate constraint, sum of LHS (%g) >= RHS (%g)\n",
                tmp___5, tmp___4);
        }
      }
    }
#line 179
    goto switch_break;
    case_4: /* CIL Label */ 
    {
#line 181
    tmp___10 = __gmpq_equal((mpq_srcptr )(lhs), (mpq_srcptr )(sum));
    }
#line 181
    if (tmp___10) {
      {
#line 181
      tmp___11 = __gmpq_equal((mpq_srcptr )(rhs), (mpq_srcptr )(sum));
      }
#line 181
      if (! tmp___11) {
        _L: /* CIL Label */ 
        {
#line 181
        tmp___12 = stmt_trigger_warning(215);
        }
#line 181
        if (tmp___12) {
          {
#line 183
          is_invalid = 1;
#line 184
          tmp___8 = __gmpq_get_d((mpq_srcptr )(rhs));
#line 184
          tmp___9 = __gmpq_get_d((mpq_srcptr )(sum));
#line 184
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"--- Warning 215: Startvals violate constraint, sum of LHS (%g) == RHS (%g)\n",
                  tmp___9, tmp___8);
          }
        }
      }
    } else {
#line 181
      goto _L;
    }
#line 187
    goto switch_break;
    case_3: /* CIL Label */ 
    {
#line 189
    tmp___16 = __gmpq_cmp((mpq_srcptr )(sum), (mpq_srcptr )(rhs));
    }
#line 189
    if (tmp___16 > 0) {
#line 189
      goto _L___0;
    } else {
      {
#line 189
      tmp___17 = __gmpq_cmp((mpq_srcptr )(lhs), (mpq_srcptr )(sum));
      }
#line 189
      if (tmp___17 > 0) {
        _L___0: /* CIL Label */ 
        {
#line 189
        tmp___18 = stmt_trigger_warning(215);
        }
#line 189
        if (tmp___18) {
          {
#line 191
          is_invalid = 1;
#line 192
          tmp___13 = __gmpq_get_d((mpq_srcptr )(rhs));
#line 192
          tmp___14 = __gmpq_get_d((mpq_srcptr )(sum));
#line 192
          tmp___15 = __gmpq_get_d((mpq_srcptr )(lhs));
#line 192
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"--- Warning 215: Startvals violate range, LHS (%g) <= Sum (%g) <= RHS (%g)\n",
                  tmp___15, tmp___14, tmp___13);
          }
        }
      }
    }
#line 195
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 197
    abort();
    }
    switch_break: /* CIL Label */ ;
    }
  }
  {
#line 200
  __gmpq_clear(sum);
#line 201
  __gmpq_clear(rhs);
#line 202
  __gmpq_clear(lhs);
  }
#line 204
  return (is_invalid);
}
}
#line 213 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/xlpglue.c"
Bool xlp_addcon_term(Lps *lp , char const   *name , ConType contype , Numb const   *lhs ,
                     Numb const   *rhs , unsigned int flags , Term const   *term_org ) 
{ 
  Term *term ;
  Con *con ;
  mpq_t tlhs ;
  mpq_t trhs ;
  int i ;
  Mono const   *mono ;
  Mono *tmp ;
  Var *var ;
  Var *tmp___0 ;
  MFun mfun ;
  MFun tmp___1 ;
  mpq_t val1 ;
  Numb const   *tmp___2 ;
  Nzo *nzo ;
  Nzo *tmp___3 ;
  mpq_t val2 ;
  int tmp___4 ;
  Var *tmp___5 ;
  Bool tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  Bool tmp___9 ;
  Bool tmp___10 ;

  {
  {
#line 235
  term = term_simplify(term_org);
#line 237
  con = lps_addcon(lp, name);
#line 241
  __gmpq_init(tlhs);
#line 242
  __gmpq_init(trhs);
#line 244
  numb_get_mpq(rhs, (__mpq_struct *)(trhs));
#line 245
  numb_get_mpq(lhs, (__mpq_struct *)(tlhs));
  }
  {
#line 249
  if ((unsigned int )contype == 2U) {
#line 249
    goto case_2;
  }
#line 252
  if ((unsigned int )contype == 1U) {
#line 252
    goto case_1;
  }
#line 255
  if ((unsigned int )contype == 4U) {
#line 255
    goto case_4;
  }
#line 258
  if ((unsigned int )contype == 3U) {
#line 258
    goto case_3;
  }
#line 262
  goto switch_default;
  case_2: /* CIL Label */ 
  {
#line 250
  lps_setrhs(con, (__mpq_struct */* const  */)(trhs));
  }
#line 251
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 253
  lps_setlhs(con, (__mpq_struct */* const  */)(tlhs));
  }
#line 254
  goto switch_break;
  case_4: /* CIL Label */ ;
  case_3: /* CIL Label */ 
  {
#line 259
  lps_setlhs(con, (__mpq_struct */* const  */)(tlhs));
#line 260
  lps_setrhs(con, (__mpq_struct */* const  */)(trhs));
  }
#line 261
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 263
  abort();
  }
  switch_break: /* CIL Label */ ;
  }
  {
#line 265
  lps_addflags(con, flags);
#line 267
  __gmpq_clear(trhs);
#line 268
  __gmpq_clear(tlhs);
#line 270
  tmp___8 = term_get_degree((Term const   *)term);
  }
#line 270
  if (tmp___8 > 2) {
    {
#line 271
    lps_addterm(lp, con, (Term const   *)term);
    }
  } else {
    {
#line 270
    tmp___9 = term_is_polynomial((Term const   *)term);
    }
#line 270
    if (tmp___9) {
#line 274
      i = 0;
      {
#line 274
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 274
        tmp___7 = term_get_elements((Term const   *)term);
        }
#line 274
        if (! (i < tmp___7)) {
#line 274
          goto while_break;
        }
        {
#line 276
        tmp = term_get_element((Term const   *)term, i);
#line 276
        mono = (Mono const   *)tmp;
#line 277
        tmp___0 = mono_get_var(mono, 0);
#line 277
        var = tmp___0;
#line 278
        tmp___1 = mono_get_function(mono);
#line 278
        mfun = tmp___1;
        }
#line 281
        if ((int )mfun == 1) {
          {
#line 283
          lps_setindicator(con, var, (int )mfun == 1);
          }
#line 284
          goto __Cont;
        } else
#line 281
        if ((int )mfun == 2) {
          {
#line 283
          lps_setindicator(con, var, (int )mfun == 1);
          }
#line 284
          goto __Cont;
        }
        {
#line 289
        __gmpq_init(val1);
#line 291
        tmp___2 = mono_get_coeff(mono);
#line 291
        numb_get_mpq(tmp___2, (__mpq_struct *)(val1));
#line 293
        tmp___6 = mono_is_linear(mono);
        }
#line 293
        if (tmp___6) {
          {
#line 295
          tmp___3 = lps_getnzo((Lps const   *)lp, (Con const   *)con, (Var const   *)var);
#line 295
          nzo = tmp___3;
          }
#line 297
          if ((unsigned long )nzo == (unsigned long )((void *)0)) {
            {
#line 298
            lps_addnzo(lp, con, var, (__mpq_struct */* const  */)(val1));
            }
          } else {
            {
#line 303
            __gmpq_init(val2);
#line 305
            lps_getval((Nzo const   *)nzo, (__mpq_struct *)(val2));
#line 307
            __gmpq_add(val1, (mpq_srcptr )(val1), (mpq_srcptr )(val2));
#line 309
            tmp___4 = __gmpq_equal((mpq_srcptr )(val1), (mpq_srcptr )(const_zero));
            }
#line 309
            if (tmp___4) {
              {
#line 310
              lps_delnzo(lp, nzo);
              }
            } else {
              {
#line 312
              lps_setval(nzo, (__mpq_struct */* const  */)(val1));
              }
            }
            {
#line 314
            __gmpq_clear(val2);
            }
          }
        } else {
          {
#line 321
          tmp___5 = mono_get_var(mono, 1);
#line 321
          lps_addqme(lp, con, var, tmp___5, (__mpq_struct */* const  */)(val1));
          }
        }
        {
#line 323
        __gmpq_clear(val1);
        }
        __Cont: /* CIL Label */ 
#line 274
        i ++;
      }
      while_break: /* CIL Label */ ;
      }
    } else {
      {
#line 271
      lps_addterm(lp, con, (Term const   *)term);
      }
    }
  }
  {
#line 326
  term_free(term);
#line 328
  tmp___10 = check_con_is_invalid((Con const   *)con);
  }
#line 328
  return (tmp___10);
}
}
#line 336 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/xlpglue.c"
Var *xlp_addvar(Lps *lp , char const   *name , VarClass varclass , Bound const   *lower ,
                Bound const   *upper , Numb const   *priority , Numb const   *startval ) 
{ 
  Var *var ;
  mpq_t temp ;
  Numb const   *tmp ;
  BoundType tmp___0 ;
  Numb const   *tmp___1 ;
  BoundType tmp___2 ;
  Numb const   *tmp___3 ;
  Numb const   *tmp___4 ;
  Bool tmp___5 ;
  long tmp___6 ;
  long tmp___7 ;

  {
  {
#line 355
  var = lps_addvar(lp, name);
#line 357
  lps_setclass(var, varclass);
#line 359
  __gmpq_init(temp);
#line 361
  tmp___0 = bound_get_type(lower);
  }
#line 361
  if ((unsigned int )tmp___0 == 1U) {
    {
#line 363
    tmp = bound_get_value(lower);
#line 363
    numb_get_mpq(tmp, (__mpq_struct *)(temp));
#line 364
    lps_setlower(var, (__mpq_struct */* const  */)(temp));
    }
  }
  {
#line 366
  tmp___2 = bound_get_type(upper);
  }
#line 366
  if ((unsigned int )tmp___2 == 1U) {
    {
#line 368
    tmp___1 = bound_get_value(upper);
#line 368
    numb_get_mpq(tmp___1, (__mpq_struct *)(temp));
#line 369
    lps_setupper(var, (__mpq_struct */* const  */)(temp));
    }
  }
  {
#line 371
  tmp___4 = numb_unknown();
#line 371
  tmp___5 = numb_equal(startval, tmp___4);
  }
#line 371
  if (tmp___5) {
    {
#line 372
    tmp___3 = numb_zero();
#line 372
    numb_get_mpq(tmp___3, (__mpq_struct *)(temp));
    }
  } else {
    {
#line 374
    numb_get_mpq(startval, (__mpq_struct *)(temp));
    }
  }
  {
#line 376
  lps_setstartval(var, (__mpq_struct */* const  */)(temp));
#line 378
  numb_get_mpq(priority, (__mpq_struct *)(temp));
#line 381
  tmp___6 = __gmpz_get_si((mpz_srcptr )(& temp[0]._mp_den));
  }
#line 381
  if (tmp___6 != 1L) {
#line 382
    if (verbose > 0) {
      {
#line 383
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"--- Warning 301: variable priority has to be integral\n");
      }
    }
  }
  {
#line 386
  tmp___7 = __gmpz_get_si((mpz_srcptr )(& temp[0]._mp_num));
#line 386
  lps_setpriority(var, (int )tmp___7);
#line 388
  __gmpq_clear(temp);
  }
#line 390
  return (var);
}
}
#line 398 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/xlpglue.c"
int xlp_addsos_term(Lps *lp , char const   *name , SosType type , Numb const   *priority ,
                    Term const   *term ) 
{ 
  Sos *sos ;
  mpq_t temp ;
  Hash *hash ;
  int i ;
  Bool has_duplicates ;
  Bool has_nonintprio ;
  long tmp ;
  long tmp___0 ;
  int tmp___1 ;
  Mono const   *mono ;
  Mono *tmp___2 ;
  Numb const   *coeff ;
  Numb const   *tmp___3 ;
  Var *var ;
  Var *tmp___4 ;
  Bool tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;

  {
  {
#line 409
  has_duplicates = 0;
#line 410
  has_nonintprio = 0;
#line 418
  __gmpq_init(temp);
#line 420
  numb_get_mpq(priority, (__mpq_struct *)(temp));
#line 423
  tmp = __gmpz_get_si((mpz_srcptr )(& temp[0]._mp_den));
  }
#line 423
  if (tmp != 1L) {
#line 424
    has_nonintprio = 1;
  }
  {
#line 427
  tmp___0 = __gmpz_get_si((mpz_srcptr )(& temp[0]._mp_num));
#line 427
  sos = lps_addsos(lp, name, type, (int )tmp___0);
#line 431
  tmp___1 = term_get_elements(term);
#line 431
  hash = hash_new((HashType )4, tmp___1);
#line 435
  i = 0;
  }
  {
#line 435
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 435
    tmp___6 = term_get_elements(term);
    }
#line 435
    if (! (i < tmp___6)) {
#line 435
      goto while_break;
    }
    {
#line 437
    tmp___2 = term_get_element(term, i);
#line 437
    mono = (Mono const   *)tmp___2;
#line 438
    tmp___3 = mono_get_coeff(mono);
#line 438
    coeff = tmp___3;
#line 439
    tmp___4 = mono_get_var(mono, 0);
#line 439
    var = tmp___4;
#line 446
    tmp___5 = hash_has_numb((Hash const   *)hash, coeff);
    }
#line 446
    if (tmp___5) {
#line 447
      has_duplicates = 1;
    }
    {
#line 449
    hash_add_numb(hash, coeff);
#line 451
    numb_get_mpq(coeff, (__mpq_struct *)(temp));
#line 453
    lps_addsse(sos, var, (__mpq_struct */* const  */)(temp));
#line 435
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 455
  hash_free(hash);
#line 457
  __gmpq_clear(temp);
  }
#line 459
  if (has_duplicates) {
#line 459
    tmp___7 = 1;
  } else {
#line 459
    tmp___7 = 0;
  }
#line 459
  if (has_nonintprio) {
#line 459
    tmp___8 = 2;
  } else {
#line 459
    tmp___8 = 0;
  }
#line 459
  return (tmp___7 + tmp___8);
}
}
#line 466 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/xlpglue.c"
char const   *xlp_getvarname(Lps const   *lp , Var const   *var ) 
{ 
  char const   *tmp ;

  {
  {
#line 472
  tmp = lps_varname(var);
  }
#line 472
  return (tmp);
}
}
#line 479 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/xlpglue.c"
VarClass xlp_getclass(Lps const   *lp , Var const   *var ) 
{ 
  VarClass tmp ;

  {
  {
#line 485
  tmp = lps_getclass(var);
  }
#line 485
  return (tmp);
}
}
#line 492 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/xlpglue.c"
Bound *xlp_getlower(Lps const   *lp , Var const   *var ) 
{ 
  Bound *bound ;
  Numb *numb ;
  mpq_t lower ;
  Numb const   *tmp ;
  Bool tmp___0 ;

  {
  {
#line 502
  tmp___0 = lps_haslower(var);
  }
#line 502
  if (tmp___0) {
    {
#line 506
    __gmpq_init(lower);
#line 507
    lps_getlower(var, (__mpq_struct *)(lower));
#line 508
    numb = numb_new_mpq((__mpq_struct */* const  */)(lower));
#line 509
    bound = bound_new((BoundType )1, (Numb const   *)numb);
#line 510
    numb_free(numb);
#line 511
    __gmpq_clear(lower);
    }
  } else {
    {
#line 503
    tmp = numb_zero();
#line 503
    bound = bound_new((BoundType )3, tmp);
    }
  }
#line 513
  return (bound);
}
}
#line 520 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/xlpglue.c"
Bound *xlp_getupper(Lps const   *lp , Var const   *var ) 
{ 
  Bound *bound ;
  Numb *numb ;
  mpq_t upper ;
  Numb const   *tmp ;
  Bool tmp___0 ;

  {
  {
#line 531
  tmp___0 = lps_hasupper(var);
  }
#line 531
  if (tmp___0) {
    {
#line 535
    __gmpq_init(upper);
#line 536
    lps_getupper(var, (__mpq_struct *)(upper));
#line 537
    numb = numb_new_mpq((__mpq_struct */* const  */)(upper));
#line 538
    bound = bound_new((BoundType )1, (Numb const   *)numb);
#line 539
    numb_free(numb);
#line 540
    __gmpq_clear(upper);
    }
  } else {
    {
#line 532
    tmp = numb_zero();
#line 532
    bound = bound_new((BoundType )2, tmp);
    }
  }
#line 542
  return (bound);
}
}
#line 547 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/xlpglue.c"
void xlp_objname(Lps *lp , char const   *name ) 
{ 


  {
  {
#line 554
  lps_setobjname(lp, name);
  }
#line 555
  return;
}
}
#line 559 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/xlpglue.c"
void xlp_setdir(Lps *lp , Bool minimize ) 
{ 
  int tmp ;

  {
#line 565
  if (minimize) {
#line 565
    tmp = 0;
  } else {
#line 565
    tmp = 1;
  }
  {
#line 565
  lps_setdir(lp, (LpDirect )tmp);
  }
#line 566
  return;
}
}
#line 571 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/xlpglue.c"
void xlp_addtocost(Lps *lp , Var *var , Numb const   *cost ) 
{ 
  mpq_t val1 ;
  mpq_t val2 ;

  {
  {
#line 582
  __gmpq_init(val1);
#line 583
  __gmpq_init(val2);
#line 585
  lps_getcost((Var const   *)var, (__mpq_struct *)(val1));
#line 586
  numb_get_mpq(cost, (__mpq_struct *)(val2));
#line 587
  __gmpq_add(val1, (mpq_srcptr )(val1), (mpq_srcptr )(val2));
#line 588
  lps_setcost(var, (__mpq_struct */* const  */)(val1));
#line 590
  __gmpq_clear(val1);
#line 591
  __gmpq_clear(val2);
  }
#line 592
  return;
}
}
#line 41 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/numb.h"
extern Numb *numb_new_integer(int val ) ;
#line 49
extern Numb *numb_copy(Numb const   *source ) ;
#line 53
extern int numb_cmp(Numb const   *numb_a , Numb const   *numb_b ) ;
#line 63
extern Numb *numb_new_sub(Numb const   *numb_a , Numb const   *numb_b ) ;
#line 67
extern Numb *numb_new_mul(Numb const   *numb_a , Numb const   *numb_b ) ;
#line 85
extern void numb_neg(Numb *numb ) ;
#line 87
extern void numb_abs(Numb *numb ) ;
#line 119
extern Numb const   *numb_one(void) ;
#line 121
extern Numb const   *numb_minusone(void) ;
#line 127
extern int numb_toint(Numb const   *numb ) ;
#line 56 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/elem.h"
Elem *elem_new_strg(char const   *strg ) ;
#line 46 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/tuple.h"
extern Tuple *tuple_new(int dim ) ;
#line 48
extern void tuple_free(Tuple *tuple ) ;
#line 58
extern void tuple_set_elem(Tuple *tuple , int idx , Elem *elem ) ;
#line 79 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/mme.h"
extern void zpl_exit(int retval ) ;
#line 88
void interns_init(void) ;
#line 89
void interns_exit(void) ;
#line 54 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/symbol.h"
extern Symbol *symbol_lookup(char const   *name ) ;
#line 60
extern void symbol_add_entry(Symbol *sym , Entry *entry ) ;
#line 49 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/bound.h"
void bound_free(Bound *bound ) ;
#line 47 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/term.h"
extern Term *term_new(int size ) ;
#line 49
extern void term_add_elem(Term *term , Entry const   *entry , Numb const   *coeff ,
                          MFun mfun ) ;
#line 63
extern void term_append_term(Term *term_a , Term const   *term_b ) ;
#line 65
extern Term *term_add_term(Term const   *term_a , Term const   *term_b ) ;
#line 67
extern Term *term_sub_term(Term const   *term_a , Term const   *term_b ) ;
#line 73
extern void term_add_constant(Term *term , Numb const   *value ) ;
#line 77
extern void term_mul_coeff(Term *term , Numb const   *value ) ;
#line 79
extern Numb const   *term_get_constant(Term const   *term ) ;
#line 91
extern Bound *term_get_lower_bound(Term const   *term ) ;
#line 93
extern Bound *term_get_upper_bound(Term const   *term ) ;
#line 95
extern Bool term_is_all_integer(Term const   *term ) ;
#line 103
extern Term *term_make_conditional(Term const   *ind_term , Term const   *cond_term ,
                                   Bool is_true ) ;
#line 47 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/entry.h"
Entry *entry_new_var(Tuple const   *tuple , Var *var ) ;
#line 86 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/code.h"
void code_errmsg(CodeNode const   *node ) ;
#line 96
CodeNode *code_get_child(CodeNode const   *node , int no ) ;
#line 152
void code_value_term(CodeNode *node , Term *term ) ;
#line 174
void code_value_void(CodeNode *node ) ;
#line 181
Numb const   *code_eval_child_numb(CodeNode const   *node , int no ) ;
#line 197
Term const   *code_eval_child_term(CodeNode const   *node , int no ) ;
#line 207
ConType code_eval_child_contype(CodeNode const   *node , int no ) ;
#line 213
unsigned int code_eval_child_bits(CodeNode const   *node , int no ) ;
#line 291 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/inst.h"
CodeNode *i_vabs(CodeNode *self ) ;
#line 293
CodeNode *i_vbool_and(CodeNode *self ) ;
#line 295
CodeNode *i_vbool_eq(CodeNode *self ) ;
#line 297
CodeNode *i_vbool_ne(CodeNode *self ) ;
#line 299
CodeNode *i_vbool_ge(CodeNode *self ) ;
#line 301
CodeNode *i_vbool_gt(CodeNode *self ) ;
#line 303
CodeNode *i_vbool_le(CodeNode *self ) ;
#line 305
CodeNode *i_vbool_lt(CodeNode *self ) ;
#line 307
CodeNode *i_vbool_not(CodeNode *self ) ;
#line 309
CodeNode *i_vbool_or(CodeNode *self ) ;
#line 311
CodeNode *i_vbool_xor(CodeNode *self ) ;
#line 313
CodeNode *i_vexpr_fun(CodeNode *self ) ;
#line 315
CodeNode *i_vif(CodeNode *self ) ;
#line 317
CodeNode *i_vif_else(CodeNode *self ) ;
#line 37 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/strstore.h"
extern char const   *str_new(char const   *s ) ;
#line 68 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/vinst.c"
static int internal_vars  =    0;
#line 69 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/vinst.c"
static int internal_cons  =    0;
#line 71 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/vinst.c"
void interns_init(void) 
{ 


  {
#line 75
  return;
}
}
#line 77 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/vinst.c"
void interns_exit(void) 
{ 


  {
#line 79
  internal_vars = 0;
#line 80
  internal_cons = 0;
#line 81
  return;
}
}
#line 83 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/vinst.c"
static void create_new_constraint(char const   *basename , char const   *extension ,
                                  Term *term , ConType con_type , Numb const   *lrhs ,
                                  unsigned int flags ) 
{ 
  char *cname___0 ;
  size_t tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  void *tmp___3 ;

  {
  {
#line 101
  tmp = strlen(basename);
#line 101
  tmp___0 = strlen(extension);
#line 101
  tmp___1 = mem_malloc(((tmp + tmp___0) + 10UL) + 1UL, "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/vinst.c",
                       (int const   )101);
#line 101
  cname___0 = (char *)tmp___1;
#line 102
  tmp___2 = internal_cons;
#line 102
  internal_cons ++;
#line 102
  sprintf((char */* __restrict  */)cname___0, (char const   */* __restrict  */)"%s%s_%d",
          basename, extension, tmp___2);
#line 103
  tmp___3 = prog_get_lp();
#line 103
  xlp_addcon_term((Lps *)tmp___3, (char const   *)cname___0, con_type, lrhs, lrhs,
                  flags, (Term const   *)term);
#line 105
  term_free(term);
#line 106
  mem_free((void *)cname___0, "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/vinst.c",
           (int const   )106);
  }
#line 107
  return;
}
}
#line 109 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/vinst.c"
static Entry *create_new_var_entry(char const   *basename , char const   *extension ,
                                   VarClass var_class , Bound const   *lower , Bound const   *upper ) 
{ 
  char *vname ;
  Tuple *tuple ;
  Entry *entry ;
  Var *var ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;
  int tmp___3 ;
  Numb const   *tmp___4 ;
  Numb const   *tmp___5 ;
  void *tmp___6 ;
  size_t tmp___7 ;
  char const   *tmp___8 ;
  Elem *tmp___9 ;

  {
  {
#line 129
  tmp = strlen(basename);
#line 129
  tmp___0 = strlen(extension);
#line 129
  tmp___1 = strlen("@@");
#line 129
  tmp___2 = mem_malloc(((tmp + tmp___0) + tmp___1) + 16UL, "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/vinst.c",
                       (int const   )129);
#line 129
  vname = (char *)tmp___2;
#line 130
  tmp___3 = internal_vars;
#line 130
  internal_vars ++;
#line 130
  sprintf((char */* __restrict  */)vname, (char const   */* __restrict  */)"%s%s%s_%d",
          "@@", basename, extension, tmp___3);
#line 131
  tmp___4 = numb_zero();
#line 131
  tmp___5 = numb_zero();
#line 131
  tmp___6 = prog_get_lp();
#line 131
  var = xlp_addvar((Lps *)tmp___6, (char const   *)vname, var_class, lower, upper,
                   tmp___5, tmp___4);
#line 132
  tuple = tuple_new(1);
#line 133
  tmp___7 = strlen("@@");
#line 133
  tmp___8 = str_new((char const   *)(vname + tmp___7));
#line 133
  tmp___9 = elem_new_strg(tmp___8);
#line 133
  tuple_set_elem(tuple, 0, tmp___9);
#line 134
  entry = entry_new_var((Tuple const   *)tuple, var);
#line 136
  tuple_free(tuple);
#line 137
  mem_free((void *)vname, "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/vinst.c",
           (int const   )137);
  }
#line 139
  return (entry);
}
}
#line 142 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/vinst.c"
static VBFixed check_how_fixed(VBCmpOp cmp_op , Numb const   *rhs ) 
{ 
  VBFixed result ;
  Numb const   *tmp ;
  Bool tmp___0 ;
  Numb const   *tmp___1 ;
  Bool tmp___2 ;
  Numb const   *tmp___3 ;
  int tmp___4 ;
  Numb const   *tmp___5 ;
  int tmp___6 ;
  Numb const   *tmp___7 ;
  int tmp___8 ;
  Numb const   *tmp___9 ;
  int tmp___10 ;

  {
#line 146
  result = (VBFixed )1;
  {
#line 150
  if ((unsigned int )cmp_op == 2U) {
#line 150
    goto case_2;
  }
#line 154
  if ((unsigned int )cmp_op == 3U) {
#line 154
    goto case_3;
  }
#line 158
  if ((unsigned int )cmp_op == 1U) {
#line 158
    goto case_1;
  }
#line 162
  if ((unsigned int )cmp_op == 4U) {
#line 162
    goto case_4;
  }
#line 166
  if ((unsigned int )cmp_op == 0U) {
#line 166
    goto case_0;
  }
#line 170
  if ((unsigned int )cmp_op == 5U) {
#line 170
    goto case_5;
  }
#line 174
  goto switch_default;
  case_2: /* CIL Label */ 
  {
#line 151
  tmp = numb_zero();
#line 151
  tmp___0 = numb_equal(rhs, tmp);
  }
#line 151
  if (tmp___0) {
#line 152
    result = (VBFixed )0;
  }
#line 153
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 155
  tmp___1 = numb_zero();
#line 155
  tmp___2 = numb_equal(rhs, tmp___1);
  }
#line 155
  if (! tmp___2) {
#line 156
    result = (VBFixed )0;
  }
#line 157
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 159
  tmp___3 = numb_zero();
#line 159
  tmp___4 = numb_cmp(tmp___3, rhs);
  }
#line 159
  if (tmp___4 <= 0) {
#line 160
    result = (VBFixed )0;
  }
#line 161
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 163
  tmp___5 = numb_zero();
#line 163
  tmp___6 = numb_cmp(tmp___5, rhs);
  }
#line 163
  if (tmp___6 >= 0) {
#line 164
    result = (VBFixed )0;
  }
#line 165
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 167
  tmp___7 = numb_zero();
#line 167
  tmp___8 = numb_cmp(tmp___7, rhs);
  }
#line 167
  if (tmp___8 < 0) {
#line 168
    result = (VBFixed )0;
  }
#line 169
  goto switch_break;
  case_5: /* CIL Label */ 
  {
#line 171
  tmp___9 = numb_zero();
#line 171
  tmp___10 = numb_cmp(tmp___9, rhs);
  }
#line 171
  if (tmp___10 > 0) {
#line 172
    result = (VBFixed )0;
  }
#line 173
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 175
  abort();
  }
  switch_break: /* CIL Label */ ;
  }
#line 177
  return (result);
}
}
#line 180 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/vinst.c"
static VBFixed check_if_fixed(VBCmpOp cmp_op , Numb const   *lower , Numb const   *upper ) 
{ 
  VBFixed result ;
  Bool tmp ;
  Numb const   *tmp___0 ;
  int tmp___1 ;
  Numb const   *tmp___2 ;
  int tmp___3 ;
  Bool tmp___4 ;
  Numb const   *tmp___5 ;
  int tmp___6 ;
  Numb const   *tmp___7 ;
  int tmp___8 ;
  Numb const   *tmp___9 ;
  int tmp___10 ;
  Numb const   *tmp___11 ;
  int tmp___12 ;
  Numb const   *tmp___13 ;
  int tmp___14 ;
  Numb const   *tmp___15 ;
  int tmp___16 ;
  Numb const   *tmp___17 ;
  int tmp___18 ;
  Numb const   *tmp___19 ;
  int tmp___20 ;
  Numb const   *tmp___21 ;
  int tmp___22 ;
  Numb const   *tmp___23 ;
  int tmp___24 ;

  {
#line 185
  result = (VBFixed )2;
  {
#line 193
  if ((unsigned int )cmp_op == 2U) {
#line 193
    goto case_2;
  }
#line 208
  if ((unsigned int )cmp_op == 3U) {
#line 208
    goto case_3;
  }
#line 223
  if ((unsigned int )cmp_op == 1U) {
#line 223
    goto case_1;
  }
#line 229
  if ((unsigned int )cmp_op == 4U) {
#line 229
    goto case_4;
  }
#line 235
  if ((unsigned int )cmp_op == 0U) {
#line 235
    goto case_0;
  }
#line 241
  if ((unsigned int )cmp_op == 5U) {
#line 241
    goto case_5;
  }
#line 247
  goto switch_default;
  case_2: /* CIL Label */ 
  {
#line 194
  tmp___0 = numb_zero();
#line 194
  tmp___1 = numb_cmp(lower, tmp___0);
  }
#line 194
  if (tmp___1 > 0) {
#line 196
    result = (VBFixed )1;
  } else {
    {
#line 194
    tmp___2 = numb_zero();
#line 194
    tmp___3 = numb_cmp(upper, tmp___2);
    }
#line 194
    if (tmp___3 < 0) {
#line 196
      result = (VBFixed )1;
    } else {
      {
#line 199
      tmp = numb_equal(lower, upper);
      }
#line 199
      if (tmp) {
#line 204
        result = (VBFixed )0;
      }
    }
  }
#line 207
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 209
  tmp___5 = numb_zero();
#line 209
  tmp___6 = numb_cmp(lower, tmp___5);
  }
#line 209
  if (tmp___6 > 0) {
#line 211
    result = (VBFixed )0;
  } else {
    {
#line 209
    tmp___7 = numb_zero();
#line 209
    tmp___8 = numb_cmp(upper, tmp___7);
    }
#line 209
    if (tmp___8 < 0) {
#line 211
      result = (VBFixed )0;
    } else {
      {
#line 214
      tmp___4 = numb_equal(lower, upper);
      }
#line 214
      if (tmp___4) {
#line 219
        result = (VBFixed )1;
      }
    }
  }
#line 222
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 224
  tmp___11 = numb_zero();
#line 224
  tmp___12 = numb_cmp(upper, tmp___11);
  }
#line 224
  if (tmp___12 <= 0) {
#line 225
    result = (VBFixed )0;
  } else {
    {
#line 226
    tmp___9 = numb_zero();
#line 226
    tmp___10 = numb_cmp(lower, tmp___9);
    }
#line 226
    if (tmp___10 > 0) {
#line 227
      result = (VBFixed )1;
    }
  }
#line 228
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 230
  tmp___15 = numb_zero();
#line 230
  tmp___16 = numb_cmp(lower, tmp___15);
  }
#line 230
  if (tmp___16 >= 0) {
#line 231
    result = (VBFixed )0;
  } else {
    {
#line 232
    tmp___13 = numb_zero();
#line 232
    tmp___14 = numb_cmp(upper, tmp___13);
    }
#line 232
    if (tmp___14 < 0) {
#line 233
      result = (VBFixed )1;
    }
  }
#line 234
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 236
  tmp___19 = numb_zero();
#line 236
  tmp___20 = numb_cmp(upper, tmp___19);
  }
#line 236
  if (tmp___20 < 0) {
#line 237
    result = (VBFixed )0;
  } else {
    {
#line 238
    tmp___17 = numb_zero();
#line 238
    tmp___18 = numb_cmp(lower, tmp___17);
    }
#line 238
    if (tmp___18 >= 0) {
#line 239
      result = (VBFixed )1;
    }
  }
#line 240
  goto switch_break;
  case_5: /* CIL Label */ 
  {
#line 242
  tmp___23 = numb_zero();
#line 242
  tmp___24 = numb_cmp(lower, tmp___23);
  }
#line 242
  if (tmp___24 > 0) {
#line 243
    result = (VBFixed )0;
  } else {
    {
#line 244
    tmp___21 = numb_zero();
#line 244
    tmp___22 = numb_cmp(upper, tmp___21);
    }
#line 244
    if (tmp___22 <= 0) {
#line 245
      result = (VBFixed )1;
    }
  }
#line 246
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 248
  abort();
  }
  switch_break: /* CIL Label */ ;
  }
#line 250
  return (result);
}
}
#line 254 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/vinst.c"
static CodeNode *handle_vbool_cmp(CodeNode *self , VBCmpOp cmp_op ) 
{ 
  Symbol *sym ;
  Term *term ;
  Term const   *term_lhs ;
  Term const   *term_rhs ;
  Numb *rhs ;
  unsigned int flags ;
  char const   *cname___0 ;
  Bound *lower ;
  Bound *upper ;
  Bound *bound_zero ;
  Bound *bound_one ;
  Entry *entry_xplus ;
  Entry *entry_xminus ;
  Entry *entry_bplus ;
  Entry *entry_bminus ;
  Entry *entry_result ;
  Numb *numb ;
  VBFixed fixed ;
  Numb const   *tmp ;
  Numb const   *tmp___0 ;
  CodeNode *tmp___1 ;
  Bool tmp___2 ;
  Numb const   *tmp___3 ;
  Numb const   *tmp___4 ;
  BoundType tmp___5 ;
  BoundType tmp___6 ;
  CodeNode *tmp___7 ;
  Bool tmp___8 ;
  Numb const   *tmp___9 ;
  Numb const   *tmp___10 ;
  int tmp___11 ;
  CodeNode *tmp___12 ;
  Bool tmp___13 ;
  Numb const   *tmp___14 ;
  Numb const   *tmp___15 ;
  Numb const   *tmp___16 ;
  Numb const   *tmp___17 ;
  int tmp___18 ;
  Numb const   *tmp___19 ;
  Numb const   *tmp___20 ;
  Numb const   *tmp___21 ;
  int tmp___22 ;
  Numb const   *tmp___23 ;
  Numb const   *tmp___24 ;
  Numb const   *tmp___25 ;
  Numb const   *tmp___26 ;
  Numb const   *tmp___27 ;
  Numb const   *tmp___28 ;
  Numb const   *tmp___29 ;
  Numb const   *tmp___30 ;
  Numb const   *tmp___31 ;
  Numb const   *tmp___32 ;
  Numb const   *tmp___33 ;
  Bool tmp___34 ;
  Numb const   *tmp___35 ;
  Numb const   *tmp___36 ;
  Numb const   *tmp___37 ;
  Numb const   *tmp___38 ;
  Numb const   *tmp___39 ;
  Bool tmp___40 ;
  Numb const   *tmp___41 ;
  Numb const   *tmp___42 ;
  Numb const   *tmp___43 ;
  Numb const   *tmp___44 ;
  Numb const   *tmp___45 ;
  Numb const   *tmp___46 ;
  Numb const   *tmp___47 ;
  Numb const   *tmp___48 ;
  Numb const   *tmp___49 ;
  Numb const   *tmp___50 ;
  Numb const   *tmp___51 ;
  Numb const   *tmp___52 ;
  Numb const   *tmp___53 ;
  Numb const   *tmp___54 ;
  Numb const   *tmp___55 ;
  Numb const   *tmp___56 ;
  Numb const   *tmp___57 ;
  Numb const   *tmp___58 ;
  Numb const   *tmp___59 ;
  Numb const   *tmp___60 ;
  Numb const   *tmp___61 ;
  Numb const   *tmp___62 ;
  Numb const   *tmp___63 ;
  Numb const   *tmp___64 ;
  Numb const   *tmp___65 ;
  Numb const   *tmp___66 ;
  Numb const   *tmp___67 ;
  Numb const   *tmp___68 ;
  Numb const   *tmp___69 ;
  Numb const   *tmp___70 ;
  Numb const   *tmp___71 ;
  Numb const   *tmp___72 ;
  Numb const   *tmp___73 ;
  Numb const   *tmp___74 ;
  Numb const   *tmp___75 ;

  {
  {
#line 273
  fixed = (VBFixed )2;
#line 279
  term_lhs = code_eval_child_term((CodeNode const   *)self, 0);
#line 280
  term_rhs = code_eval_child_term((CodeNode const   *)self, 1);
#line 281
  flags = 0U;
#line 283
  tmp = term_get_constant(term_lhs);
#line 283
  tmp___0 = term_get_constant(term_rhs);
#line 283
  rhs = numb_new_sub(tmp___0, tmp);
#line 284
  term = term_sub_term(term_lhs, term_rhs);
#line 286
  tmp___2 = term_is_all_integer((Term const   *)term);
  }
#line 286
  if (! tmp___2) {
    {
#line 288
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"*** Error 177: Boolean constraint not all integer\n");
#line 289
    tmp___1 = code_get_child((CodeNode const   *)self, 0);
#line 289
    code_errmsg((CodeNode const   *)tmp___1);
#line 290
    zpl_exit(1);
    }
  }
  {
#line 294
  sym = symbol_lookup("@@");
#line 298
  cname___0 = conname_get();
#line 299
  tmp___3 = numb_zero();
#line 299
  bound_zero = bound_new((BoundType )1, tmp___3);
#line 300
  tmp___4 = numb_one();
#line 300
  bound_one = bound_new((BoundType )1, tmp___4);
#line 301
  lower = term_get_lower_bound((Term const   *)term);
#line 302
  upper = term_get_upper_bound((Term const   *)term);
#line 304
  tmp___5 = bound_get_type((Bound const   *)lower);
  }
#line 304
  if ((unsigned int )tmp___5 != 1U) {
    {
#line 306
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"*** Error 185: Term in Boolean constraint not bounded\n");
#line 307
    code_errmsg((CodeNode const   *)self);
#line 308
    zpl_exit(1);
    }
  } else {
    {
#line 304
    tmp___6 = bound_get_type((Bound const   *)upper);
    }
#line 304
    if ((unsigned int )tmp___6 != 1U) {
      {
#line 306
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"*** Error 185: Term in Boolean constraint not bounded\n");
#line 307
      code_errmsg((CodeNode const   *)self);
#line 308
      zpl_exit(1);
      }
    }
  }
  {
#line 313
  tmp___11 = term_get_elements((Term const   *)term);
  }
#line 313
  if (tmp___11 == 0) {
    {
#line 315
    tmp___8 = stmt_trigger_warning(176);
    }
#line 315
    if (tmp___8) {
      {
#line 317
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"--- Warning 176: Empty LHS, in Boolean constraint\n");
#line 318
      tmp___7 = code_get_child((CodeNode const   *)self, 0);
#line 318
      code_errmsg((CodeNode const   *)tmp___7);
      }
    }
    {
#line 320
    fixed = check_how_fixed(cmp_op, (Numb const   *)rhs);
    }
  } else {
    {
#line 326
    tmp___9 = bound_get_value((Bound const   *)upper);
#line 326
    tmp___10 = bound_get_value((Bound const   *)lower);
#line 326
    fixed = check_if_fixed(cmp_op, tmp___10, tmp___9);
    }
  }
#line 328
  if ((unsigned int )fixed != 2U) {
#line 330
    if ((unsigned int )fixed == 0U) {
      {
#line 331
      entry_result = create_new_var_entry(cname___0, "_re", (VarClass )2, (Bound const   *)bound_one,
                                          (Bound const   *)bound_one);
      }
    } else {
      {
#line 336
      entry_result = create_new_var_entry(cname___0, "_re", (VarClass )2, (Bound const   *)bound_zero,
                                          (Bound const   *)bound_zero);
      }
    }
    {
#line 338
    tmp___13 = stmt_trigger_warning(178);
    }
#line 338
    if (tmp___13) {
      {
#line 340
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"--- Warning 178: Conditional always true or false due to bounds\n");
#line 342
      tmp___12 = code_get_child((CodeNode const   *)self, 0);
#line 342
      code_errmsg((CodeNode const   *)tmp___12);
      }
    }
    {
#line 344
    term_free(term);
    }
  } else {
    {
#line 350
    term_add_constant(term, (Numb const   *)rhs);
#line 352
    tmp___16 = numb_zero();
#line 352
    tmp___17 = bound_get_value((Bound const   *)lower);
#line 352
    tmp___18 = numb_cmp(tmp___17, tmp___16);
    }
#line 352
    if (tmp___18 < 0) {
      {
#line 354
      tmp___14 = bound_get_value((Bound const   *)lower);
#line 354
      numb = numb_copy(tmp___14);
#line 355
      numb_abs(numb);
#line 356
      bound_free(lower);
#line 357
      lower = bound_new((BoundType )1, (Numb const   *)numb);
#line 358
      numb_free(numb);
      }
    } else {
      {
#line 362
      bound_free(lower);
#line 363
      tmp___15 = numb_zero();
#line 363
      lower = bound_new((BoundType )1, tmp___15);
      }
    }
    {
#line 366
    tmp___20 = numb_zero();
#line 366
    tmp___21 = bound_get_value((Bound const   *)upper);
#line 366
    tmp___22 = numb_cmp(tmp___21, tmp___20);
    }
#line 366
    if (tmp___22 < 0) {
      {
#line 368
      bound_free(upper);
#line 369
      tmp___19 = numb_zero();
#line 369
      upper = bound_new((BoundType )1, tmp___19);
      }
    }
    {
#line 373
    entry_xplus = create_new_var_entry(cname___0, "_xp", (VarClass )2, (Bound const   *)bound_zero,
                                       (Bound const   *)upper);
#line 374
    entry_xminus = create_new_var_entry(cname___0, "_xm", (VarClass )2, (Bound const   *)bound_zero,
                                        (Bound const   *)lower);
#line 375
    entry_bplus = create_new_var_entry(cname___0, "_bp", (VarClass )2, (Bound const   *)bound_zero,
                                       (Bound const   *)bound_one);
#line 376
    entry_bminus = create_new_var_entry(cname___0, "_bm", (VarClass )2, (Bound const   *)bound_zero,
                                        (Bound const   *)bound_one);
#line 377
    entry_result = create_new_var_entry(cname___0, "_re", (VarClass )2, (Bound const   *)bound_zero,
                                        (Bound const   *)bound_one);
#line 381
    tmp___23 = numb_minusone();
#line 381
    term_add_elem(term, (Entry const   *)entry_xplus, tmp___23, (MFun )0);
#line 382
    tmp___24 = numb_one();
#line 382
    term_add_elem(term, (Entry const   *)entry_xminus, tmp___24, (MFun )0);
#line 384
    create_new_constraint(cname___0, "_a", term, (ConType )4, (Numb const   *)rhs,
                          flags);
#line 387
    term = term_new(2);
#line 388
    tmp___25 = numb_one();
#line 388
    term_add_elem(term, (Entry const   *)entry_bplus, tmp___25, (MFun )0);
#line 389
    tmp___26 = numb_minusone();
#line 389
    term_add_elem(term, (Entry const   *)entry_xplus, tmp___26, (MFun )0);
#line 390
    tmp___27 = numb_zero();
#line 390
    create_new_constraint(cname___0, "_b", term, (ConType )2, tmp___27, flags);
#line 393
    term = term_new(2);
#line 394
    tmp___28 = numb_one();
#line 394
    term_add_elem(term, (Entry const   *)entry_bminus, tmp___28, (MFun )0);
#line 395
    tmp___29 = numb_minusone();
#line 395
    term_add_elem(term, (Entry const   *)entry_xminus, tmp___29, (MFun )0);
#line 396
    tmp___30 = numb_zero();
#line 396
    create_new_constraint(cname___0, "_c", term, (ConType )2, tmp___30, flags);
#line 399
    term = term_new(2);
#line 400
    tmp___32 = numb_zero();
#line 400
    tmp___33 = bound_get_value((Bound const   *)upper);
#line 400
    tmp___34 = numb_equal(tmp___33, tmp___32);
    }
#line 400
    if (! tmp___34) {
      {
#line 401
      tmp___31 = bound_get_value((Bound const   *)upper);
#line 401
      term_add_elem(term, (Entry const   *)entry_bplus, tmp___31, (MFun )0);
      }
    }
    {
#line 402
    tmp___35 = numb_minusone();
#line 402
    term_add_elem(term, (Entry const   *)entry_xplus, tmp___35, (MFun )0);
#line 403
    tmp___36 = numb_zero();
#line 403
    create_new_constraint(cname___0, "_d", term, (ConType )1, tmp___36, flags);
#line 406
    term = term_new(2);
#line 407
    tmp___38 = numb_zero();
#line 407
    tmp___39 = bound_get_value((Bound const   *)lower);
#line 407
    tmp___40 = numb_equal(tmp___39, tmp___38);
    }
#line 407
    if (! tmp___40) {
      {
#line 408
      tmp___37 = bound_get_value((Bound const   *)lower);
#line 408
      term_add_elem(term, (Entry const   *)entry_bminus, tmp___37, (MFun )0);
      }
    }
    {
#line 409
    tmp___41 = numb_minusone();
#line 409
    term_add_elem(term, (Entry const   *)entry_xminus, tmp___41, (MFun )0);
#line 410
    tmp___42 = numb_zero();
#line 410
    create_new_constraint(cname___0, "_e", term, (ConType )1, tmp___42, flags);
    }
    {
#line 414
    if ((unsigned int )cmp_op == 2U) {
#line 414
      goto case_2;
    }
#line 422
    if ((unsigned int )cmp_op == 3U) {
#line 422
      goto case_3;
    }
#line 430
    if ((unsigned int )cmp_op == 1U) {
#line 430
      goto case_1;
    }
#line 444
    if ((unsigned int )cmp_op == 4U) {
#line 444
      goto case_4;
    }
#line 458
    if ((unsigned int )cmp_op == 0U) {
#line 458
      goto case_0;
    }
#line 474
    if ((unsigned int )cmp_op == 5U) {
#line 474
      goto case_5;
    }
#line 490
    goto switch_default;
    case_2: /* CIL Label */ 
    {
#line 416
    term = term_new(3);
#line 417
    tmp___43 = numb_one();
#line 417
    term_add_elem(term, (Entry const   *)entry_result, tmp___43, (MFun )0);
#line 418
    tmp___44 = numb_one();
#line 418
    term_add_elem(term, (Entry const   *)entry_bplus, tmp___44, (MFun )0);
#line 419
    tmp___45 = numb_one();
#line 419
    term_add_elem(term, (Entry const   *)entry_bminus, tmp___45, (MFun )0);
#line 420
    tmp___46 = numb_one();
#line 420
    create_new_constraint(cname___0, "_f", term, (ConType )4, tmp___46, flags);
    }
#line 421
    goto switch_break;
    case_3: /* CIL Label */ 
    {
#line 424
    term = term_new(3);
#line 425
    tmp___47 = numb_one();
#line 425
    term_add_elem(term, (Entry const   *)entry_result, tmp___47, (MFun )0);
#line 426
    tmp___48 = numb_minusone();
#line 426
    term_add_elem(term, (Entry const   *)entry_bplus, tmp___48, (MFun )0);
#line 427
    tmp___49 = numb_minusone();
#line 427
    term_add_elem(term, (Entry const   *)entry_bminus, tmp___49, (MFun )0);
#line 428
    tmp___50 = numb_zero();
#line 428
    create_new_constraint(cname___0, "_f", term, (ConType )4, tmp___50, flags);
    }
#line 429
    goto switch_break;
    case_1: /* CIL Label */ 
    {
#line 434
    term = term_new(2);
#line 435
    tmp___51 = numb_one();
#line 435
    term_add_elem(term, (Entry const   *)entry_bplus, tmp___51, (MFun )0);
#line 436
    tmp___52 = numb_one();
#line 436
    term_add_elem(term, (Entry const   *)entry_bminus, tmp___52, (MFun )0);
#line 437
    tmp___53 = numb_one();
#line 437
    create_new_constraint(cname___0, "_f", term, (ConType )2, tmp___53, flags);
#line 439
    term = term_new(2);
#line 440
    tmp___54 = numb_one();
#line 440
    term_add_elem(term, (Entry const   *)entry_result, tmp___54, (MFun )0);
#line 441
    tmp___55 = numb_one();
#line 441
    term_add_elem(term, (Entry const   *)entry_bplus, tmp___55, (MFun )0);
#line 442
    tmp___56 = numb_one();
#line 442
    create_new_constraint(cname___0, "_g", term, (ConType )4, tmp___56, flags);
    }
#line 443
    goto switch_break;
    case_4: /* CIL Label */ 
    {
#line 448
    term = term_new(2);
#line 449
    tmp___57 = numb_one();
#line 449
    term_add_elem(term, (Entry const   *)entry_bplus, tmp___57, (MFun )0);
#line 450
    tmp___58 = numb_one();
#line 450
    term_add_elem(term, (Entry const   *)entry_bminus, tmp___58, (MFun )0);
#line 451
    tmp___59 = numb_one();
#line 451
    create_new_constraint(cname___0, "_f", term, (ConType )2, tmp___59, flags);
#line 453
    term = term_new(2);
#line 454
    tmp___60 = numb_one();
#line 454
    term_add_elem(term, (Entry const   *)entry_result, tmp___60, (MFun )0);
#line 455
    tmp___61 = numb_one();
#line 455
    term_add_elem(term, (Entry const   *)entry_bminus, tmp___61, (MFun )0);
#line 456
    tmp___62 = numb_one();
#line 456
    create_new_constraint(cname___0, "_g", term, (ConType )4, tmp___62, flags);
    }
#line 457
    goto switch_break;
    case_0: /* CIL Label */ 
    {
#line 462
    term = term_new(2);
#line 463
    tmp___63 = numb_one();
#line 463
    term_add_elem(term, (Entry const   *)entry_bplus, tmp___63, (MFun )0);
#line 464
    tmp___64 = numb_one();
#line 464
    term_add_elem(term, (Entry const   *)entry_bminus, tmp___64, (MFun )0);
#line 465
    tmp___65 = numb_one();
#line 465
    create_new_constraint(cname___0, "_f", term, (ConType )2, tmp___65, flags);
#line 469
    term = term_new(2);
#line 470
    tmp___66 = numb_one();
#line 470
    term_add_elem(term, (Entry const   *)entry_result, tmp___66, (MFun )0);
#line 471
    tmp___67 = numb_minusone();
#line 471
    term_add_elem(term, (Entry const   *)entry_bminus, tmp___67, (MFun )0);
#line 472
    tmp___68 = numb_zero();
#line 472
    create_new_constraint(cname___0, "_g", term, (ConType )4, tmp___68, flags);
    }
#line 473
    goto switch_break;
    case_5: /* CIL Label */ 
    {
#line 478
    term = term_new(2);
#line 479
    tmp___69 = numb_one();
#line 479
    term_add_elem(term, (Entry const   *)entry_bplus, tmp___69, (MFun )0);
#line 480
    tmp___70 = numb_one();
#line 480
    term_add_elem(term, (Entry const   *)entry_bminus, tmp___70, (MFun )0);
#line 481
    tmp___71 = numb_one();
#line 481
    create_new_constraint(cname___0, "_f", term, (ConType )2, tmp___71, flags);
#line 485
    term = term_new(2);
#line 486
    tmp___72 = numb_one();
#line 486
    term_add_elem(term, (Entry const   *)entry_result, tmp___72, (MFun )0);
#line 487
    tmp___73 = numb_minusone();
#line 487
    term_add_elem(term, (Entry const   *)entry_bplus, tmp___73, (MFun )0);
#line 488
    tmp___74 = numb_zero();
#line 488
    create_new_constraint(cname___0, "_g", term, (ConType )4, tmp___74, flags);
    }
#line 489
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 491
    abort();
    }
    switch_break: /* CIL Label */ ;
    }
    {
#line 493
    symbol_add_entry(sym, entry_xplus);
#line 494
    symbol_add_entry(sym, entry_xminus);
#line 495
    symbol_add_entry(sym, entry_bplus);
#line 496
    symbol_add_entry(sym, entry_bminus);
    }
  }
  {
#line 498
  term = term_new(1);
#line 499
  tmp___75 = numb_one();
#line 499
  term_add_elem(term, (Entry const   *)entry_result, tmp___75, (MFun )0);
#line 501
  code_value_term(self, term);
#line 503
  symbol_add_entry(sym, entry_result);
#line 505
  bound_free(bound_one);
#line 506
  bound_free(bound_zero);
#line 507
  bound_free(lower);
#line 508
  bound_free(upper);
#line 509
  numb_free(rhs);
  }
#line 511
  return (self);
}
}
#line 514 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/vinst.c"
CodeNode *i_vbool_ne(CodeNode *self ) 
{ 
  CodeNode *tmp ;

  {
  {
#line 518
  tmp = handle_vbool_cmp(self, (VBCmpOp )3);
  }
#line 518
  return (tmp);
}
}
#line 521 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/vinst.c"
CodeNode *i_vbool_eq(CodeNode *self ) 
{ 
  CodeNode *tmp ;

  {
  {
#line 525
  tmp = handle_vbool_cmp(self, (VBCmpOp )2);
  }
#line 525
  return (tmp);
}
}
#line 528 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/vinst.c"
CodeNode *i_vbool_lt(CodeNode *self ) 
{ 
  CodeNode *tmp ;

  {
  {
#line 532
  tmp = handle_vbool_cmp(self, (VBCmpOp )0);
  }
#line 532
  return (tmp);
}
}
#line 535 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/vinst.c"
CodeNode *i_vbool_le(CodeNode *self ) 
{ 
  CodeNode *tmp ;

  {
  {
#line 539
  tmp = handle_vbool_cmp(self, (VBCmpOp )1);
  }
#line 539
  return (tmp);
}
}
#line 542 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/vinst.c"
CodeNode *i_vbool_gt(CodeNode *self ) 
{ 
  CodeNode *tmp ;

  {
  {
#line 546
  tmp = handle_vbool_cmp(self, (VBCmpOp )5);
  }
#line 546
  return (tmp);
}
}
#line 549 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/vinst.c"
CodeNode *i_vbool_ge(CodeNode *self ) 
{ 
  CodeNode *tmp ;

  {
  {
#line 553
  tmp = handle_vbool_cmp(self, (VBCmpOp )4);
  }
#line 553
  return (tmp);
}
}
#line 556 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/vinst.c"
CodeNode *i_vbool_and(CodeNode *self ) 
{ 
  Term const   *term_a ;
  Term const   *term_b ;
  char const   *cname___0 ;
  Term *term ;
  Bound *bound_zero ;
  Bound *bound_one ;
  Entry *entry_result ;
  unsigned int flags ;
  Symbol *sym ;
  Numb const   *tmp ;
  Numb const   *tmp___0 ;
  Numb const   *tmp___1 ;
  Numb const   *tmp___2 ;
  Numb const   *tmp___3 ;
  Numb const   *tmp___4 ;
  Numb const   *tmp___5 ;
  Numb const   *tmp___6 ;
  Numb const   *tmp___7 ;

  {
  {
#line 565
  flags = 0U;
#line 570
  cname___0 = conname_get();
#line 571
  tmp = numb_zero();
#line 571
  bound_zero = bound_new((BoundType )1, tmp);
#line 572
  tmp___0 = numb_one();
#line 572
  bound_one = bound_new((BoundType )1, tmp___0);
#line 573
  term_a = code_eval_child_term((CodeNode const   *)self, 0);
#line 574
  term_b = code_eval_child_term((CodeNode const   *)self, 1);
#line 579
  entry_result = create_new_var_entry(cname___0, "_re", (VarClass )2, (Bound const   *)bound_zero,
                                      (Bound const   *)bound_one);
#line 584
  term = term_copy(term_a);
#line 585
  tmp___1 = numb_minusone();
#line 585
  term_add_elem(term, (Entry const   *)entry_result, tmp___1, (MFun )0);
#line 586
  tmp___2 = numb_zero();
#line 586
  create_new_constraint(cname___0, "_a", term, (ConType )1, tmp___2, flags);
#line 589
  term = term_copy(term_b);
#line 590
  tmp___3 = numb_minusone();
#line 590
  term_add_elem(term, (Entry const   *)entry_result, tmp___3, (MFun )0);
#line 591
  tmp___4 = numb_zero();
#line 591
  create_new_constraint(cname___0, "_b", term, (ConType )1, tmp___4, flags);
#line 594
  term = term_add_term(term_a, term_b);
#line 595
  tmp___5 = numb_minusone();
#line 595
  term_add_elem(term, (Entry const   *)entry_result, tmp___5, (MFun )0);
#line 596
  tmp___6 = numb_one();
#line 596
  create_new_constraint(cname___0, "_c", term, (ConType )2, tmp___6, flags);
#line 600
  term = term_new(1);
#line 601
  tmp___7 = numb_one();
#line 601
  term_add_elem(term, (Entry const   *)entry_result, tmp___7, (MFun )0);
#line 603
  code_value_term(self, term);
#line 607
  sym = symbol_lookup("@@");
#line 611
  symbol_add_entry(sym, entry_result);
#line 613
  bound_free(bound_zero);
#line 614
  bound_free(bound_one);
  }
#line 616
  return (self);
}
}
#line 619 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/vinst.c"
CodeNode *i_vbool_or(CodeNode *self ) 
{ 
  Term const   *term_a ;
  Term const   *term_b ;
  char const   *cname___0 ;
  Term *term ;
  Bound *bound_zero ;
  Bound *bound_one ;
  Entry *entry_result ;
  unsigned int flags ;
  Symbol *sym ;
  Numb const   *tmp ;
  Numb const   *tmp___0 ;
  Numb const   *tmp___1 ;
  Numb const   *tmp___2 ;
  Numb const   *tmp___3 ;
  Numb const   *tmp___4 ;
  Numb const   *tmp___5 ;
  Numb const   *tmp___6 ;
  Numb const   *tmp___7 ;

  {
  {
#line 628
  flags = 0U;
#line 633
  cname___0 = conname_get();
#line 634
  tmp = numb_zero();
#line 634
  bound_zero = bound_new((BoundType )1, tmp);
#line 635
  tmp___0 = numb_one();
#line 635
  bound_one = bound_new((BoundType )1, tmp___0);
#line 636
  term_a = code_eval_child_term((CodeNode const   *)self, 0);
#line 637
  term_b = code_eval_child_term((CodeNode const   *)self, 1);
#line 642
  entry_result = create_new_var_entry(cname___0, "_re", (VarClass )2, (Bound const   *)bound_zero,
                                      (Bound const   *)bound_one);
#line 647
  term = term_copy(term_a);
#line 648
  tmp___1 = numb_minusone();
#line 648
  term_add_elem(term, (Entry const   *)entry_result, tmp___1, (MFun )0);
#line 649
  tmp___2 = numb_zero();
#line 649
  create_new_constraint(cname___0, "_a", term, (ConType )2, tmp___2, flags);
#line 652
  term = term_copy(term_b);
#line 653
  tmp___3 = numb_minusone();
#line 653
  term_add_elem(term, (Entry const   *)entry_result, tmp___3, (MFun )0);
#line 654
  tmp___4 = numb_zero();
#line 654
  create_new_constraint(cname___0, "_b", term, (ConType )2, tmp___4, flags);
#line 657
  term = term_add_term(term_a, term_b);
#line 658
  tmp___5 = numb_minusone();
#line 658
  term_add_elem(term, (Entry const   *)entry_result, tmp___5, (MFun )0);
#line 659
  tmp___6 = numb_zero();
#line 659
  create_new_constraint(cname___0, "_c", term, (ConType )1, tmp___6, flags);
#line 663
  term = term_new(1);
#line 664
  tmp___7 = numb_one();
#line 664
  term_add_elem(term, (Entry const   *)entry_result, tmp___7, (MFun )0);
#line 666
  code_value_term(self, term);
#line 670
  sym = symbol_lookup("@@");
#line 674
  symbol_add_entry(sym, entry_result);
#line 676
  bound_free(bound_zero);
#line 677
  bound_free(bound_one);
  }
#line 679
  return (self);
}
}
#line 682 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/vinst.c"
CodeNode *i_vbool_xor(CodeNode *self ) 
{ 
  Term const   *term_a ;
  Term const   *term_b ;
  char const   *cname___0 ;
  Term *term ;
  Bound *bound_zero ;
  Bound *bound_one ;
  Entry *entry_result ;
  unsigned int flags ;
  Symbol *sym ;
  Numb *numb ;
  Numb const   *tmp ;
  Numb const   *tmp___0 ;
  Numb const   *tmp___1 ;
  Numb const   *tmp___2 ;
  Numb const   *tmp___3 ;
  Numb const   *tmp___4 ;
  Numb const   *tmp___5 ;
  Numb const   *tmp___6 ;
  Numb const   *tmp___7 ;
  Numb const   *tmp___8 ;

  {
  {
#line 691
  flags = 0U;
#line 697
  cname___0 = conname_get();
#line 698
  tmp = numb_zero();
#line 698
  bound_zero = bound_new((BoundType )1, tmp);
#line 699
  tmp___0 = numb_one();
#line 699
  bound_one = bound_new((BoundType )1, tmp___0);
#line 700
  term_a = code_eval_child_term((CodeNode const   *)self, 0);
#line 701
  term_b = code_eval_child_term((CodeNode const   *)self, 1);
#line 706
  entry_result = create_new_var_entry(cname___0, "_re", (VarClass )2, (Bound const   *)bound_zero,
                                      (Bound const   *)bound_one);
#line 711
  term = term_add_term(term_a, term_b);
#line 712
  tmp___1 = numb_minusone();
#line 712
  term_add_elem(term, (Entry const   *)entry_result, tmp___1, (MFun )0);
#line 713
  tmp___2 = numb_zero();
#line 713
  create_new_constraint(cname___0, "_a", term, (ConType )1, tmp___2, flags);
#line 716
  term = term_sub_term(term_a, term_b);
#line 717
  tmp___3 = numb_minusone();
#line 717
  term_add_elem(term, (Entry const   *)entry_result, tmp___3, (MFun )0);
#line 718
  tmp___4 = numb_zero();
#line 718
  create_new_constraint(cname___0, "_b", term, (ConType )2, tmp___4, flags);
#line 721
  term = term_sub_term(term_a, term_b);
#line 722
  tmp___5 = numb_one();
#line 722
  term_add_elem(term, (Entry const   *)entry_result, tmp___5, (MFun )0);
#line 723
  tmp___6 = numb_zero();
#line 723
  create_new_constraint(cname___0, "_c", term, (ConType )1, tmp___6, flags);
#line 726
  numb = numb_new_integer(2);
#line 727
  term = term_add_term(term_a, term_b);
#line 728
  tmp___7 = numb_one();
#line 728
  term_add_elem(term, (Entry const   *)entry_result, tmp___7, (MFun )0);
#line 729
  create_new_constraint(cname___0, "_d", term, (ConType )2, (Numb const   *)numb,
                        flags);
#line 730
  numb_free(numb);
#line 734
  term = term_new(1);
#line 735
  tmp___8 = numb_one();
#line 735
  term_add_elem(term, (Entry const   *)entry_result, tmp___8, (MFun )0);
#line 737
  code_value_term(self, term);
#line 741
  sym = symbol_lookup("@@");
#line 745
  symbol_add_entry(sym, entry_result);
#line 747
  bound_free(bound_zero);
#line 748
  bound_free(bound_one);
  }
#line 750
  return (self);
}
}
#line 753 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/vinst.c"
CodeNode *i_vbool_not(CodeNode *self ) 
{ 
  Term const   *term_a ;
  char const   *cname___0 ;
  Term *term ;
  Bound *bound_zero ;
  Bound *bound_one ;
  Entry *entry_result ;
  unsigned int flags ;
  Symbol *sym ;
  Numb const   *tmp ;
  Numb const   *tmp___0 ;
  Numb const   *tmp___1 ;
  Numb const   *tmp___2 ;
  Numb const   *tmp___3 ;

  {
  {
#line 761
  flags = 0U;
#line 766
  cname___0 = conname_get();
#line 767
  tmp = numb_zero();
#line 767
  bound_zero = bound_new((BoundType )1, tmp);
#line 768
  tmp___0 = numb_one();
#line 768
  bound_one = bound_new((BoundType )1, tmp___0);
#line 769
  term_a = code_eval_child_term((CodeNode const   *)self, 0);
#line 773
  entry_result = create_new_var_entry(cname___0, "_re", (VarClass )2, (Bound const   *)bound_zero,
                                      (Bound const   *)bound_one);
#line 778
  term = term_copy(term_a);
#line 779
  tmp___1 = numb_one();
#line 779
  term_add_elem(term, (Entry const   *)entry_result, tmp___1, (MFun )0);
#line 780
  tmp___2 = numb_one();
#line 780
  create_new_constraint(cname___0, "_a", term, (ConType )4, tmp___2, flags);
#line 784
  term = term_new(1);
#line 785
  tmp___3 = numb_one();
#line 785
  term_add_elem(term, (Entry const   *)entry_result, tmp___3, (MFun )0);
#line 787
  code_value_term(self, term);
#line 791
  sym = symbol_lookup("@@");
#line 795
  symbol_add_entry(sym, entry_result);
#line 797
  bound_free(bound_zero);
#line 798
  bound_free(bound_one);
  }
#line 800
  return (self);
}
}
#line 804 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/vinst.c"
static void generate_conditional_constraint(CodeNode const   *self , Term const   *vif_term ,
                                            Term const   *lhs_term , ConType con_type ,
                                            Numb const   *rhs , unsigned int flags ,
                                            Bool then_case ) 
{ 
  Bound *bound ;
  Numb *big_m ;
  Term *big_term ;
  Numb const   *bound_val ;
  Numb const   *new_rhs ;
  char const   *basename ;
  char *cname___0 ;
  Bound *tmp ;
  Bound *tmp___0 ;
  BoundType tmp___1 ;
  Bool tmp___2 ;
  Numb *tmp___3 ;
  Numb *tmp___4 ;
  size_t tmp___5 ;
  void *tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  void *tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;

  {
#line 825
  if ((unsigned int )con_type == 2U) {
    {
#line 825
    tmp = term_get_upper_bound(lhs_term);
#line 825
    bound = tmp;
    }
  } else {
    {
#line 825
    tmp___0 = term_get_lower_bound(lhs_term);
#line 825
    bound = tmp___0;
    }
  }
  {
#line 829
  tmp___1 = bound_get_type((Bound const   *)bound);
  }
#line 829
  if ((unsigned int )tmp___1 != 1U) {
    {
#line 831
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"*** Error 179: Conditional only possible on bounded constraints\n");
#line 832
    code_errmsg(self);
#line 833
    zpl_exit(1);
    }
  }
  {
#line 835
  bound_val = bound_get_value((Bound const   *)bound);
  }
#line 837
  if ((unsigned int )con_type == 2U) {
    {
#line 837
    tmp___10 = numb_cmp(bound_val, rhs);
    }
#line 837
    if (tmp___10 <= 0) {
#line 837
      goto _L;
    } else {
#line 837
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
#line 837
  if ((unsigned int )con_type == 1U) {
    {
#line 837
    tmp___11 = numb_cmp(bound_val, rhs);
    }
#line 837
    if (tmp___11 >= 0) {
      _L: /* CIL Label */ 
      {
#line 840
      tmp___2 = stmt_trigger_warning(180);
      }
#line 840
      if (tmp___2) {
        {
#line 842
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"--- Warning 180: Conditional constraint always true due to bounds\n");
#line 843
        code_errmsg(self);
        }
      }
    } else {
#line 837
      goto _L___0;
    }
  } else {
    _L___0: /* CIL Label */ 
    {
#line 848
    big_term = term_copy(vif_term);
    }
#line 849
    if (then_case) {
      {
#line 849
      tmp___3 = numb_new_sub(bound_val, rhs);
#line 849
      big_m = tmp___3;
      }
    } else {
      {
#line 849
      tmp___4 = numb_new_sub(rhs, bound_val);
#line 849
      big_m = tmp___4;
      }
    }
#line 850
    if (then_case) {
#line 850
      new_rhs = bound_val;
    } else {
#line 850
      new_rhs = rhs;
    }
    {
#line 852
    term_mul_coeff(big_term, (Numb const   *)big_m);
#line 854
    term_append_term(big_term, lhs_term);
#line 856
    basename = conname_get();
#line 857
    tmp___5 = strlen(basename);
#line 857
    tmp___6 = mem_malloc(tmp___5 + 5UL, "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/vinst.c",
                         (int const   )857);
#line 857
    cname___0 = (char *)tmp___6;
    }
#line 858
    if ((unsigned int )con_type == 2U) {
#line 858
      tmp___7 = 'r';
    } else {
#line 858
      tmp___7 = 'l';
    }
#line 858
    if (then_case) {
#line 858
      tmp___8 = 't';
    } else {
#line 858
      tmp___8 = 'e';
    }
    {
#line 858
    sprintf((char */* __restrict  */)cname___0, (char const   */* __restrict  */)"%s_%c_%c",
            basename, tmp___8, tmp___7);
#line 862
    tmp___9 = prog_get_lp();
#line 862
    xlp_addcon_term((Lps *)tmp___9, (char const   *)cname___0, con_type, new_rhs,
                    new_rhs, flags, (Term const   *)big_term);
#line 864
    numb_free(big_m);
#line 865
    term_free(big_term);
#line 866
    mem_free((void *)cname___0, "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/vinst.c",
             (int const   )866);
    }
  }
  {
#line 868
  bound_free(bound);
  }
#line 869
  return;
}
}
#line 871 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/vinst.c"
static void generate_indicator_constraint(CodeNode const   *self , Term const   *vif_term ,
                                          Term const   *lhs_term , ConType con_type ,
                                          Numb const   *rhs , unsigned int flags ,
                                          Bool then_case ) 
{ 
  Numb *lhs ;
  Term *ind_term ;
  char const   *basename ;
  char *cname___0 ;
  size_t tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;

  {
  {
#line 889
  ind_term = term_make_conditional(vif_term, lhs_term, then_case);
#line 891
  basename = conname_get();
#line 892
  tmp = strlen(basename);
#line 892
  tmp___0 = mem_malloc(tmp + 5UL, "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/vinst.c",
                       (int const   )892);
#line 892
  cname___0 = (char *)tmp___0;
  }
#line 893
  if (then_case) {
#line 893
    tmp___1 = 't';
  } else {
#line 893
    tmp___1 = 'f';
  }
  {
#line 893
  sprintf((char */* __restrict  */)cname___0, (char const   */* __restrict  */)"%s_%c",
          basename, tmp___1);
#line 900
  lhs = numb_copy(rhs);
#line 907
  tmp___2 = prog_get_lp();
#line 907
  xlp_addcon_term((Lps *)tmp___2, (char const   *)cname___0, con_type, (Numb const   *)lhs,
                  rhs, flags, (Term const   *)ind_term);
#line 909
  term_free(ind_term);
#line 910
  numb_free(lhs);
#line 911
  mem_free((void *)cname___0, "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/vinst.c",
           (int const   )911);
  }
#line 912
  return;
}
}
#line 915 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/vinst.c"
static void handle_vif_then_else(CodeNode const   *self , Term const   *vif_term ,
                                 Term const   *lhs_term , ConType con_type , Term const   *rhs_term ,
                                 unsigned int flags , Bool then_case ) 
{ 
  Term *term ;
  Numb *rhs ;
  Numb const   *tmp ;
  Numb const   *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 929
  tmp = term_get_constant(lhs_term);
#line 929
  tmp___0 = term_get_constant(rhs_term);
#line 929
  rhs = numb_new_sub(tmp___0, tmp);
#line 930
  term = term_sub_term(lhs_term, rhs_term);
#line 931
  term_add_constant(term, (Numb const   *)rhs);
#line 935
  tmp___1 = term_get_elements((Term const   *)term);
  }
#line 935
  if (tmp___1 == 0) {
    {
#line 937
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"*** Error 181: Empty LHS, not allowed in conditional constraint\n");
#line 938
    code_errmsg(self);
#line 939
    zpl_exit(1);
    }
  }
#line 943
  if (flags & 8U) {
    {
#line 944
    generate_indicator_constraint(self, vif_term, (Term const   *)term, con_type,
                                  (Numb const   *)rhs, flags, then_case);
    }
  } else {
#line 949
    if ((unsigned int )con_type == 2U) {
      {
#line 950
      generate_conditional_constraint(self, vif_term, (Term const   *)term, (ConType )2,
                                      (Numb const   *)rhs, flags, then_case);
      }
    } else
#line 949
    if ((unsigned int )con_type == 4U) {
      {
#line 950
      generate_conditional_constraint(self, vif_term, (Term const   *)term, (ConType )2,
                                      (Numb const   *)rhs, flags, then_case);
      }
    }
#line 954
    if ((unsigned int )con_type == 1U) {
      {
#line 955
      generate_conditional_constraint(self, vif_term, (Term const   *)term, (ConType )1,
                                      (Numb const   *)rhs, flags, then_case);
      }
    } else
#line 954
    if ((unsigned int )con_type == 4U) {
      {
#line 955
      generate_conditional_constraint(self, vif_term, (Term const   *)term, (ConType )1,
                                      (Numb const   *)rhs, flags, then_case);
      }
    }
  }
  {
#line 958
  numb_free(rhs);
#line 959
  term_free(term);
  }
#line 960
  return;
}
}
#line 962 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/vinst.c"
CodeNode *i_vif_else(CodeNode *self ) 
{ 
  Term const   *vif_term ;
  Term const   *lhs_term ;
  Term const   *rhs_term ;
  ConType con_type ;
  unsigned int flags ;
  CodeNode *tmp ;
  CodeNode *tmp___0 ;

  {
  {
#line 974
  vif_term = code_eval_child_term((CodeNode const   *)self, 0);
#line 975
  flags = code_eval_child_bits((CodeNode const   *)self, 7);
#line 977
  lhs_term = code_eval_child_term((CodeNode const   *)self, 1);
#line 978
  con_type = code_eval_child_contype((CodeNode const   *)self, 2);
#line 979
  rhs_term = code_eval_child_term((CodeNode const   *)self, 3);
#line 981
  tmp = code_get_child((CodeNode const   *)self, 1);
#line 981
  handle_vif_then_else((CodeNode const   *)tmp, vif_term, lhs_term, con_type, rhs_term,
                       flags, 1);
#line 984
  lhs_term = code_eval_child_term((CodeNode const   *)self, 4);
#line 985
  con_type = code_eval_child_contype((CodeNode const   *)self, 5);
#line 986
  rhs_term = code_eval_child_term((CodeNode const   *)self, 6);
#line 988
  tmp___0 = code_get_child((CodeNode const   *)self, 4);
#line 988
  handle_vif_then_else((CodeNode const   *)tmp___0, vif_term, lhs_term, con_type,
                       rhs_term, flags, 0);
#line 991
  code_value_void(self);
#line 993
  conname_next();
  }
#line 995
  return (self);
}
}
#line 998 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/vinst.c"
CodeNode *i_vif(CodeNode *self ) 
{ 
  Term const   *vif_term ;
  Term const   *lhs_term ;
  Term const   *rhs_term ;
  ConType con_type ;
  unsigned int flags ;
  CodeNode *tmp ;

  {
  {
#line 1010
  vif_term = code_eval_child_term((CodeNode const   *)self, 0);
#line 1011
  lhs_term = code_eval_child_term((CodeNode const   *)self, 1);
#line 1012
  con_type = code_eval_child_contype((CodeNode const   *)self, 2);
#line 1013
  rhs_term = code_eval_child_term((CodeNode const   *)self, 3);
#line 1014
  flags = code_eval_child_bits((CodeNode const   *)self, 4);
#line 1016
  tmp = code_get_child((CodeNode const   *)self, 1);
#line 1016
  handle_vif_then_else((CodeNode const   *)tmp, vif_term, lhs_term, con_type, rhs_term,
                       flags, 1);
#line 1019
  code_value_void(self);
#line 1021
  conname_next();
  }
#line 1023
  return (self);
}
}
#line 1026 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/vinst.c"
CodeNode *i_vabs(CodeNode *self ) 
{ 
  Symbol *sym ;
  Term *term ;
  Term const   *term_abs ;
  Numb *rhs ;
  unsigned int flags ;
  char const   *cname___0 ;
  Bound *lower ;
  Bound *upper ;
  Bound const   *bigger ;
  Bound *bound_zero ;
  Bound *bound_one ;
  Entry *entry_xplus ;
  Entry *entry_xminus ;
  Entry *entry_bplus ;
  Entry *entry_result ;
  Numb *numb ;
  Numb const   *tmp ;
  int tmp___0 ;
  Bool tmp___1 ;
  Numb const   *tmp___2 ;
  Numb const   *tmp___3 ;
  BoundType tmp___4 ;
  BoundType tmp___5 ;
  Numb const   *tmp___6 ;
  Numb const   *tmp___7 ;
  Numb const   *tmp___8 ;
  Numb const   *tmp___9 ;
  int tmp___10 ;
  Numb const   *tmp___11 ;
  Numb const   *tmp___12 ;
  Numb const   *tmp___13 ;
  int tmp___14 ;
  Numb const   *tmp___18 ;
  Numb const   *tmp___19 ;
  int tmp___20 ;
  Numb const   *tmp___21 ;
  Numb const   *tmp___22 ;
  Numb const   *tmp___23 ;
  Numb const   *tmp___24 ;
  Numb const   *tmp___25 ;
  Bool tmp___26 ;
  Numb const   *tmp___27 ;
  Numb const   *tmp___28 ;
  Numb const   *tmp___29 ;
  Numb const   *tmp___30 ;
  Numb const   *tmp___31 ;
  Bool tmp___32 ;
  Numb const   *tmp___33 ;
  Numb const   *tmp___34 ;
  Numb const   *tmp___35 ;
  Numb const   *tmp___36 ;
  Numb const   *tmp___37 ;
  Numb const   *tmp___38 ;
  Numb const   *tmp___39 ;

  {
  {
#line 1032
  flags = 0U;
#line 1049
  term_abs = code_eval_child_term((CodeNode const   *)self, 0);
#line 1050
  tmp = term_get_constant(term_abs);
#line 1050
  rhs = numb_copy(tmp);
#line 1051
  term = term_copy(term_abs);
#line 1055
  tmp___0 = term_get_elements((Term const   *)term);
  }
#line 1055
  if (tmp___0 == 0) {
    {
#line 1057
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"*** Error 182: Empty LHS, in variable vabs\n");
#line 1058
    code_errmsg((CodeNode const   *)self);
#line 1059
    zpl_exit(1);
    }
  }
  {
#line 1061
  tmp___1 = term_is_all_integer((Term const   *)term);
  }
#line 1061
  if (! tmp___1) {
    {
#line 1063
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"*** Error 183: vabs term not all integer\n");
#line 1064
    code_errmsg((CodeNode const   *)self);
#line 1065
    zpl_exit(1);
    }
  }
  {
#line 1067
  cname___0 = conname_get();
#line 1068
  tmp___2 = numb_zero();
#line 1068
  bound_zero = bound_new((BoundType )1, tmp___2);
#line 1069
  tmp___3 = numb_one();
#line 1069
  bound_one = bound_new((BoundType )1, tmp___3);
#line 1070
  lower = term_get_lower_bound((Term const   *)term);
#line 1071
  upper = term_get_upper_bound((Term const   *)term);
#line 1073
  tmp___4 = bound_get_type((Bound const   *)lower);
  }
#line 1073
  if ((unsigned int )tmp___4 != 1U) {
    {
#line 1075
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"*** Error 184: vabs term not bounded\n");
#line 1076
    code_errmsg((CodeNode const   *)self);
#line 1077
    zpl_exit(1);
    }
  } else {
    {
#line 1073
    tmp___5 = bound_get_type((Bound const   *)upper);
    }
#line 1073
    if ((unsigned int )tmp___5 != 1U) {
      {
#line 1075
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"*** Error 184: vabs term not bounded\n");
#line 1076
      code_errmsg((CodeNode const   *)self);
#line 1077
      zpl_exit(1);
      }
    }
  }
  {
#line 1079
  numb_neg(rhs);
#line 1080
  term_add_constant(term, (Numb const   *)rhs);
#line 1082
  tmp___8 = numb_zero();
#line 1082
  tmp___9 = bound_get_value((Bound const   *)lower);
#line 1082
  tmp___10 = numb_cmp(tmp___9, tmp___8);
  }
#line 1082
  if (tmp___10 < 0) {
    {
#line 1084
    tmp___6 = bound_get_value((Bound const   *)lower);
#line 1084
    numb = numb_copy(tmp___6);
#line 1085
    numb_abs(numb);
#line 1086
    bound_free(lower);
#line 1087
    lower = bound_new((BoundType )1, (Numb const   *)numb);
#line 1088
    numb_free(numb);
    }
  } else {
    {
#line 1092
    bound_free(lower);
#line 1093
    tmp___7 = numb_zero();
#line 1093
    lower = bound_new((BoundType )1, tmp___7);
    }
  }
  {
#line 1096
  tmp___12 = numb_zero();
#line 1096
  tmp___13 = bound_get_value((Bound const   *)upper);
#line 1096
  tmp___14 = numb_cmp(tmp___13, tmp___12);
  }
#line 1096
  if (tmp___14 < 0) {
    {
#line 1098
    bound_free(upper);
#line 1099
    tmp___11 = numb_zero();
#line 1099
    upper = bound_new((BoundType )1, tmp___11);
    }
  }
  {
#line 1102
  tmp___18 = bound_get_value((Bound const   *)upper);
#line 1102
  tmp___19 = bound_get_value((Bound const   *)lower);
#line 1102
  tmp___20 = numb_cmp(tmp___19, tmp___18);
  }
#line 1102
  if (tmp___20 > 0) {
#line 1102
    bigger = (Bound const   *)lower;
  } else {
#line 1102
    bigger = (Bound const   *)upper;
  }
  {
#line 1107
  entry_xplus = create_new_var_entry(cname___0, "_xp", (VarClass )2, (Bound const   *)bound_zero,
                                     (Bound const   *)upper);
#line 1108
  entry_xminus = create_new_var_entry(cname___0, "_xm", (VarClass )2, (Bound const   *)bound_zero,
                                      (Bound const   *)lower);
#line 1109
  entry_bplus = create_new_var_entry(cname___0, "_bp", (VarClass )2, (Bound const   *)bound_zero,
                                     (Bound const   *)bound_one);
#line 1110
  entry_result = create_new_var_entry(cname___0, "_re", (VarClass )2, (Bound const   *)bound_zero,
                                      bigger);
#line 1114
  tmp___21 = numb_minusone();
#line 1114
  term_add_elem(term, (Entry const   *)entry_xplus, tmp___21, (MFun )0);
#line 1115
  tmp___22 = numb_one();
#line 1115
  term_add_elem(term, (Entry const   *)entry_xminus, tmp___22, (MFun )0);
#line 1116
  create_new_constraint(cname___0, "_a", term, (ConType )4, (Numb const   *)rhs, flags);
#line 1119
  term = term_new(2);
#line 1120
  tmp___24 = numb_zero();
#line 1120
  tmp___25 = bound_get_value((Bound const   *)upper);
#line 1120
  tmp___26 = numb_equal(tmp___25, tmp___24);
  }
#line 1120
  if (! tmp___26) {
    {
#line 1121
    tmp___23 = bound_get_value((Bound const   *)upper);
#line 1121
    term_add_elem(term, (Entry const   *)entry_bplus, tmp___23, (MFun )0);
    }
  }
  {
#line 1122
  tmp___27 = numb_minusone();
#line 1122
  term_add_elem(term, (Entry const   *)entry_xplus, tmp___27, (MFun )0);
#line 1123
  tmp___28 = numb_zero();
#line 1123
  create_new_constraint(cname___0, "_b", term, (ConType )1, tmp___28, flags);
#line 1130
  term = term_new(2);
#line 1131
  tmp___30 = numb_zero();
#line 1131
  tmp___31 = bound_get_value((Bound const   *)lower);
#line 1131
  tmp___32 = numb_equal(tmp___31, tmp___30);
  }
#line 1131
  if (! tmp___32) {
    {
#line 1132
    tmp___29 = bound_get_value((Bound const   *)lower);
#line 1132
    term_add_elem(term, (Entry const   *)entry_bplus, tmp___29, (MFun )0);
    }
  }
  {
#line 1133
  tmp___33 = numb_one();
#line 1133
  term_add_elem(term, (Entry const   *)entry_xminus, tmp___33, (MFun )0);
#line 1134
  tmp___34 = bound_get_value((Bound const   *)lower);
#line 1134
  create_new_constraint(cname___0, "_c", term, (ConType )2, tmp___34, flags);
#line 1138
  term = term_new(3);
#line 1139
  tmp___35 = numb_one();
#line 1139
  term_add_elem(term, (Entry const   *)entry_result, tmp___35, (MFun )0);
#line 1140
  tmp___36 = numb_minusone();
#line 1140
  term_add_elem(term, (Entry const   *)entry_xplus, tmp___36, (MFun )0);
#line 1141
  tmp___37 = numb_minusone();
#line 1141
  term_add_elem(term, (Entry const   *)entry_xminus, tmp___37, (MFun )0);
#line 1142
  tmp___38 = numb_zero();
#line 1142
  create_new_constraint(cname___0, "_d", term, (ConType )4, tmp___38, flags);
#line 1144
  term = term_new(1);
#line 1145
  tmp___39 = numb_one();
#line 1145
  term_add_elem(term, (Entry const   *)entry_result, tmp___39, (MFun )0);
#line 1147
  code_value_term(self, term);
#line 1151
  sym = symbol_lookup("@@");
#line 1155
  symbol_add_entry(sym, entry_xplus);
#line 1156
  symbol_add_entry(sym, entry_xminus);
#line 1157
  symbol_add_entry(sym, entry_bplus);
#line 1158
  symbol_add_entry(sym, entry_result);
#line 1160
  bound_free(bound_one);
#line 1161
  bound_free(bound_zero);
#line 1162
  bound_free(lower);
#line 1163
  bound_free(upper);
#line 1164
  numb_free(rhs);
  }
#line 1166
  return (self);
}
}
#line 1169 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/vinst.c"
CodeNode *i_vexpr_fun(CodeNode *self ) 
{ 
  Symbol *sym ;
  Term const   *term_fun ;
  char const   *cname___0 ;
  Numb const   *expo ;
  Numb const   *funno ;
  unsigned int flags ;
  Term *term ;
  Entry *entry_tmp ;
  Entry *entry_result ;
  Bound *t_lower ;
  Bound *t_upper ;
  Bound *r_lower ;
  Bound *r_upper ;
  MFun mfun ;
  Numb *rhs ;
  int tmp ;
  Numb const   *tmp___0 ;
  Numb const   *tmp___1 ;
  Numb const   *tmp___2 ;
  Numb const   *tmp___3 ;
  Numb const   *tmp___4 ;
  Numb const   *tmp___5 ;
  int tmp___6 ;
  Numb const   *tmp___7 ;
  Numb const   *tmp___8 ;
  Numb const   *tmp___9 ;
  Numb const   *tmp___10 ;
  Numb const   *tmp___11 ;
  Numb const   *tmp___12 ;

  {
  {
#line 1176
  flags = 0U;
#line 1201
  funno = code_eval_child_numb((CodeNode const   *)self, 0);
#line 1205
  tmp = numb_toint(funno);
#line 1205
  mfun = (MFun )tmp;
#line 1206
  term_fun = code_eval_child_term((CodeNode const   *)self, 1);
  }
  {
#line 1210
  if ((int )mfun == -2) {
#line 1210
    goto case_neg_2;
  }
#line 1217
  if ((int )mfun == 5) {
#line 1217
    goto case_5;
  }
#line 1217
  if ((int )mfun == 3) {
#line 1217
    goto case_5;
  }
#line 1226
  if ((int )mfun == 12) {
#line 1226
    goto case_12;
  }
#line 1226
  if ((int )mfun == 11) {
#line 1226
    goto case_12;
  }
#line 1226
  if ((int )mfun == 8) {
#line 1226
    goto case_12;
  }
#line 1226
  if ((int )mfun == 4) {
#line 1226
    goto case_12;
  }
#line 1234
  if ((int )mfun == 10) {
#line 1234
    goto case_10;
  }
#line 1234
  if ((int )mfun == 7) {
#line 1234
    goto case_10;
  }
#line 1234
  if ((int )mfun == 6) {
#line 1234
    goto case_10;
  }
#line 1240
  if ((int )mfun == 9) {
#line 1240
    goto case_9;
  }
#line 1246
  goto switch_default;
  case_neg_2: /* CIL Label */ 
  {
#line 1211
  tmp___0 = numb_zero();
#line 1211
  t_lower = bound_new((BoundType )1, tmp___0);
#line 1212
  t_upper = bound_new((BoundType )2, (Numb const   *)((void *)0));
#line 1213
  tmp___1 = numb_zero();
#line 1213
  r_lower = bound_new((BoundType )1, tmp___1);
#line 1214
  r_upper = bound_new((BoundType )2, (Numb const   *)((void *)0));
  }
#line 1215
  goto switch_break;
  case_5: /* CIL Label */ 
  case_3: /* CIL Label */ 
  {
#line 1218
  tmp___2 = numb_zero();
#line 1218
  t_lower = bound_new((BoundType )1, tmp___2);
#line 1219
  t_upper = bound_new((BoundType )2, (Numb const   *)((void *)0));
#line 1220
  r_lower = bound_new((BoundType )3, (Numb const   *)((void *)0));
#line 1221
  r_upper = bound_new((BoundType )2, (Numb const   *)((void *)0));
  }
#line 1222
  goto switch_break;
  case_12: /* CIL Label */ 
  case_11: /* CIL Label */ 
  case_8: /* CIL Label */ 
  case_4: /* CIL Label */ 
  {
#line 1227
  t_lower = bound_new((BoundType )3, (Numb const   *)((void *)0));
#line 1228
  t_upper = bound_new((BoundType )2, (Numb const   *)((void *)0));
#line 1229
  r_lower = bound_new((BoundType )3, (Numb const   *)((void *)0));
#line 1230
  r_upper = bound_new((BoundType )2, (Numb const   *)((void *)0));
  }
#line 1231
  goto switch_break;
  case_10: /* CIL Label */ 
  case_7: /* CIL Label */ 
  case_6: /* CIL Label */ 
  {
#line 1235
  t_lower = bound_new((BoundType )3, (Numb const   *)((void *)0));
#line 1236
  t_upper = bound_new((BoundType )2, (Numb const   *)((void *)0));
#line 1237
  tmp___3 = numb_minusone();
#line 1237
  r_lower = bound_new((BoundType )1, tmp___3);
#line 1238
  tmp___4 = numb_one();
#line 1238
  r_upper = bound_new((BoundType )1, tmp___4);
  }
#line 1239
  goto switch_break;
  case_9: /* CIL Label */ 
  {
#line 1241
  t_lower = bound_new((BoundType )3, (Numb const   *)((void *)0));
#line 1242
  t_upper = bound_new((BoundType )2, (Numb const   *)((void *)0));
#line 1243
  tmp___5 = numb_zero();
#line 1243
  r_lower = bound_new((BoundType )1, tmp___5);
#line 1244
  r_upper = bound_new((BoundType )2, (Numb const   *)((void *)0));
  }
#line 1245
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 1247
  abort();
  }
  switch_break: /* CIL Label */ ;
  }
#line 1250
  if ((int )mfun == 11) {
    {
#line 1251
    expo = code_eval_child_numb((CodeNode const   *)self, 2);
    }
  } else
#line 1250
  if ((int )mfun == 12) {
    {
#line 1251
    expo = code_eval_child_numb((CodeNode const   *)self, 2);
    }
  } else {
    {
#line 1253
    expo = numb_one();
    }
  }
  {
#line 1255
  cname___0 = conname_get();
#line 1256
  entry_tmp = create_new_var_entry(cname___0, "_t", (VarClass )0, (Bound const   *)t_lower,
                                   (Bound const   *)t_upper);
  }
#line 1257
  if ((int )mfun == 10) {
#line 1257
    tmp___6 = 2;
  } else {
#line 1257
    tmp___6 = 0;
  }
  {
#line 1257
  entry_result = create_new_var_entry(cname___0, "_r", (VarClass )tmp___6, (Bound const   *)r_lower,
                                      (Bound const   *)r_upper);
#line 1261
  term = term_copy(term_fun);
#line 1262
  tmp___7 = numb_minusone();
#line 1262
  term_add_elem(term, (Entry const   *)entry_tmp, tmp___7, (MFun )0);
#line 1264
  tmp___8 = numb_minusone();
#line 1264
  tmp___9 = term_get_constant((Term const   *)term);
#line 1264
  rhs = numb_new_mul(tmp___9, tmp___8);
#line 1265
  term_add_constant(term, (Numb const   *)rhs);
#line 1267
  create_new_constraint(cname___0, "_a", term, (ConType )4, (Numb const   *)rhs, flags);
#line 1269
  numb_free(rhs);
#line 1273
  term = term_new(2);
#line 1274
  tmp___10 = numb_minusone();
#line 1274
  term_add_elem(term, (Entry const   *)entry_result, tmp___10, (MFun )0);
#line 1275
  term_add_elem(term, (Entry const   *)entry_tmp, expo, mfun);
#line 1277
  tmp___11 = numb_zero();
#line 1277
  create_new_constraint(cname___0, "_b", term, (ConType )4, tmp___11, flags);
#line 1279
  term = term_new(1);
#line 1280
  tmp___12 = numb_one();
#line 1280
  term_add_elem(term, (Entry const   *)entry_result, tmp___12, (MFun )0);
#line 1282
  code_value_term(self, term);
#line 1284
  sym = symbol_lookup("@@");
#line 1288
  symbol_add_entry(sym, entry_tmp);
#line 1289
  symbol_add_entry(sym, entry_result);
#line 1291
  bound_free(t_lower);
#line 1292
  bound_free(t_upper);
#line 1293
  bound_free(r_lower);
#line 1294
  bound_free(r_upper);
  }
#line 1296
  return (self);
}
}
#line 57 "/usr/include/getopt.h"
extern char *optarg ;
#line 71
extern int optind ;
#line 150
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getopt)(int ___argc ,
                                                                             char * const  *___argv ,
                                                                             char const   *__shortopts ) ;
#line 169 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 237
extern int fclose(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 695
extern int puts(char const   *__s ) ;
#line 830
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ferror)(FILE *__stream ) ;
#line 846
extern void perror(char const   *__s ) ;
#line 873
extern FILE *popen(char const   *__command , char const   *__modes ) ;
#line 879
extern int pclose(FILE *__stream ) ;
#line 147 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 150
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1), __leaf__)) atol)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 124 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tolower)(int __c ) ;
#line 263 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strrchr)(char const   *__s ,
                                                                                                int __c )  __attribute__((__pure__)) ;
#line 34 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/numb.h"
extern void numb_init(Bool with_management ) ;
#line 51 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/elem.h"
void elem_init(void) ;
#line 49 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/set.h"
extern void set_init(void) ;
#line 52
extern void set_free(Set *set ) ;
#line 77
extern Set *set_pseudo_new(void) ;
#line 48 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/symbol.h"
extern Symbol *symbol_new(char const   *name , SymbolType type , Set const   *set ,
                          int estimated_size , Entry const   *deflt ) ;
#line 80
extern void symbol_print_all(FILE *fp ) ;
#line 42 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/local.h"
extern void local_init(void) ;
#line 43 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/zlpglue.h"
void zlp_stat(Lps *lp ) ;
#line 45
void zlp_setnamelen(Lps *lp , int name_len ) ;
#line 47
void zlp_write(Lps *lp , FILE *fp , LpFormat format , char const   *text ) ;
#line 49
void zlp_transtable(Lps *lp , FILE *fp , LpFormat format ) ;
#line 51
void zlp_orderfile(Lps *lp , FILE *fp , LpFormat format ) ;
#line 53
void zlp_mstfile(Lps *lp , FILE *fp , LpFormat format ) ;
#line 47 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/prog.h"
extern Prog *prog_new(void) ;
#line 53
extern Bool prog_is_empty(Prog const   *prog ) ;
#line 57
extern void prog_print(FILE *fp , Prog const   *prog ) ;
#line 59
extern void prog_execute(Prog const   *prog , void *lp ) ;
#line 61
extern char *prog_tostr(Prog const   *prog , char const   *prefix , char const   *title ,
                        int max_output_line_len ) ;
#line 66
extern void prog_load(Prog *prog , char const   *cmd , char const   *filename ) ;
#line 44 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/metaio.h"
extern void mio_init(void) ;
#line 34 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/strstore.h"
extern void str_init(void) ;
#line 39 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/zimpllib.h"
extern void zpl_add_parameter(char const   *def ) ;
#line 43
extern void zpl_print_banner(FILE *fp , Bool with_license ) ;
#line 66 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/zimpl.c"
extern int yydebug ;
#line 67
extern int yy_flex_debug ;
#line 69 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/zimpl.c"
static char const   * const  options  =    (char const   */* const  */)"bD:fF:hl:mn:o:OP:rs:t:v:V";
#line 70 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/zimpl.c"
static char const   * const  usage  =    (char const   */* const  */)"usage: %s [options] file ...\n";
#line 71 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/zimpl.c"
static char const   * const  title  =    (char const   */* const  */)"This file was automatically generated by Zimpl";
#line 73 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/zimpl.c"
static char const   * const  help  =    (char const   */* const  */)"\n  -b             enable bison debugging output.\n  -D name=value  assign value to parameter name.\n  -f             enable flex debugging output.\n  -F filter      filter output, for example \"gzip -c >%%s.gz\"\n  -h             show this help.\n  -l length      Maximum length of names in output file.\n  -m             write CPLEX MIP start value file.\n  -n cm|cn|cf    name constraint make/name/full\n  -o outfile     select name for the output file. Default is the name of\n                 the input file without extension.\n  -P cmd         Pipe input through command, e.g. \"cpp -DONLY_X %%s\"\n  -r             write CPLEX branching order file.\n  -s seed        random number generator seed.\n  -t lp|mps|hum|rlp|pip  select output format. Either LP (default), MPS format,\n                 human readable HUM, randomly permuted LP, or PIP polynomial IP.\n  -v[0-5]        verbosity level: 0 = quiet, 1 = default, up to 5 = debug\n  -V             print program version\n  filename       is the name of the input ZPL file.\n\n";
#line 115 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/zimpl.c"
static char *add_extention(char const   *filename , char const   *extension ) 
{ 
  char *basename ;
  size_t tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 123
  tmp = strlen(filename);
#line 123
  tmp___0 = strlen(extension);
#line 123
  tmp___1 = mem_malloc((tmp + tmp___0) + 1UL, "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/zimpl.c",
                       (int const   )123);
#line 123
  basename = (char *)tmp___1;
#line 127
  strcpy((char */* __restrict  */)basename, (char const   */* __restrict  */)filename);
#line 130
  tmp___2 = strcat((char */* __restrict  */)basename, (char const   */* __restrict  */)extension);
  }
#line 130
  return (tmp___2);
}
}
#line 133 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/zimpl.c"
static char const   *strip_path(char const   *filename ) 
{ 
  char const   *s ;
  char *tmp ;
  char const   *tmp___0 ;

  {
  {
#line 140
  tmp = strrchr(filename, '/');
#line 140
  s = (char const   *)tmp;
  }
#line 142
  if ((unsigned long )s == (unsigned long )((void *)0)) {
#line 142
    tmp___0 = filename;
  } else {
#line 142
    tmp___0 = s + 1;
  }
#line 142
  return (tmp___0);
}
}
#line 145 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/zimpl.c"
static char *strip_extension(char *filename ) 
{ 
  int i ;
  size_t tmp ;
  size_t tmp___0 ;

  {
  {
#line 152
  tmp = strlen((char const   *)filename);
#line 152
  i = (int )tmp - 1;
  }
  {
#line 152
  while (1) {
    while_continue: /* CIL Label */ ;
#line 152
    if (! (i >= 0)) {
#line 152
      goto while_break;
    }
#line 153
    if ((int )*(filename + i) == 47) {
#line 154
      goto while_break;
    } else
#line 153
    if ((int )*(filename + i) == 46) {
#line 154
      goto while_break;
    }
#line 152
    i --;
  }
  while_break: /* CIL Label */ ;
  }
#line 156
  if (i >= 0) {
#line 156
    if ((int )*(filename + i) == 46) {
#line 157
      *(filename + i) = (char )'\000';
    }
  }
  {
#line 159
  tmp___0 = strlen((char const   *)filename);
#line 159
  i = (int )tmp___0;
  }
#line 161
  if (i == 0) {
    {
#line 163
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"*** Error 101: Bad filename\n");
#line 164
    exit(1);
    }
  } else
#line 161
  if ((int )*(filename + (i - 1)) == 47) {
    {
#line 163
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"*** Error 101: Bad filename\n");
#line 164
    exit(1);
    }
  }
#line 166
  return (filename);
}
}
#line 169 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/zimpl.c"
static void check_write_ok(FILE *fp , char const   *filename ) 
{ 
  int tmp ;

  {
  {
#line 171
  tmp = ferror(fp);
  }
#line 171
  if (tmp) {
    {
#line 173
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"*** Error 102: File write error\n");
#line 174
    perror(filename);
    }
  }
#line 176
  return;
}
}
#line 178 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/zimpl.c"
int main(int argc , char * const  *argv ) 
{ 
  Prog *prog ;
  Set *set ;
  void *lp ;
  char const   *extension ;
  char *filter ;
  char *tmp ;
  char *outfile ;
  char *tblfile ;
  char *ordfile ;
  char *mstfile ;
  char *basefile ;
  char *inppipe ;
  char *outpipe ;
  LpFormat format ;
  FILE *fp ;
  Bool write_order ;
  Bool write_mst ;
  Bool presolve ;
  int name_length ;
  char *prog_text ;
  unsigned long seed ;
  char **param_table ;
  int param_count ;
  int c ;
  int i ;
  FILE *(*openfile)(char const   * , char const   * ) ;
  int (*closefile)(FILE * ) ;
  void *tmp___0 ;
  void *tmp___1 ;
  long tmp___2 ;
  int tmp___3 ;
  char const   *tmp___4 ;
  char *tmp___5 ;
  size_t tmp___6 ;
  size_t tmp___7 ;
  void *tmp___8 ;
  Bool tmp___9 ;
  int tmp___10 ;
  Lps *tmp___11 ;
  char const   *tmp___12 ;
  size_t tmp___13 ;
  void *tmp___14 ;

  {
  {
#line 183
  extension = "";
#line 184
  tmp = mem_strdup("%s", "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/zimpl.c",
                   (int const   )184);
#line 184
  filter = tmp;
#line 189
  basefile = (char *)((void *)0);
#line 190
  inppipe = (char *)((void *)0);
#line 192
  format = (LpFormat )1;
#line 194
  write_order = 0;
#line 195
  write_mst = 0;
#line 196
  presolve = 0;
#line 197
  name_length = 0;
#line 199
  seed = 13021967UL;
#line 201
  param_count = 0;
#line 204
  openfile = (FILE *(*)(char const   * , char const   * ))(& fopen);
#line 205
  closefile = & fclose;
#line 209
  yydebug = 0;
#line 210
  yy_flex_debug = 0;
#line 211
  verbose = 1;
#line 212
  tmp___0 = mem_malloc(sizeof(*param_table), "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/zimpl.c",
                       (int const   )212);
#line 212
  param_table = (char **)tmp___0;
  }
  {
#line 214
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 214
    c = getopt(argc, argv, (char const   *)options);
    }
#line 214
    if (! (c != -1)) {
#line 214
      goto while_break;
    }
    {
#line 218
    if (c == 98) {
#line 218
      goto case_98;
    }
#line 221
    if (c == 68) {
#line 221
      goto case_68;
    }
#line 227
    if (c == 104) {
#line 227
      goto case_104;
    }
#line 232
    if (c == 102) {
#line 232
      goto case_102;
    }
#line 235
    if (c == 70) {
#line 235
      goto case_70;
    }
#line 242
    if (c == 108) {
#line 242
      goto case_108;
    }
#line 245
    if (c == 109) {
#line 245
      goto case_109;
    }
#line 248
    if (c == 110) {
#line 248
      goto case_110;
    }
#line 270
    if (c == 111) {
#line 270
      goto case_111;
    }
#line 273
    if (c == 79) {
#line 273
      goto case_79;
    }
#line 276
    if (c == 80) {
#line 276
      goto case_80;
    }
#line 279
    if (c == 115) {
#line 279
      goto case_115;
    }
#line 282
    if (c == 114) {
#line 282
      goto case_114;
    }
#line 285
    if (c == 116) {
#line 285
      goto case_116;
    }
#line 312
    if (c == 118) {
#line 312
      goto case_118;
    }
#line 315
    if (c == 86) {
#line 315
      goto case_86;
    }
#line 318
    if (c == 63) {
#line 318
      goto case_63;
    }
#line 321
    goto switch_default___1;
    case_98: /* CIL Label */ 
#line 219
    yydebug = 1;
#line 220
    goto switch_break;
    case_68: /* CIL Label */ 
    {
#line 222
    tmp___1 = mem_realloc((void *)param_table, (unsigned long )((unsigned int )param_count + 1U) * sizeof(*param_table),
                          "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/zimpl.c",
                          (int const   )223);
#line 222
    param_table = (char **)tmp___1;
#line 224
    *(param_table + param_count) = mem_strdup((char const   *)optarg, "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/zimpl.c",
                                              (int const   )224);
#line 225
    param_count ++;
    }
#line 226
    goto switch_break;
    case_104: /* CIL Label */ 
    {
#line 228
    zpl_print_banner(stdout, 1);
#line 229
    printf((char const   */* __restrict  */)usage, *(argv + 0));
#line 230
    puts((char const   *)help);
#line 231
    exit(0);
    }
    case_102: /* CIL Label */ 
#line 233
    yy_flex_debug = 1;
#line 234
    goto switch_break;
    case_70: /* CIL Label */ 
    {
#line 236
    mem_free((void *)filter, "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/zimpl.c",
             (int const   )236);
#line 238
    filter = mem_strdup((char const   *)optarg, "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/zimpl.c",
                        (int const   )238);
#line 239
    openfile = & popen;
#line 240
    closefile = & pclose;
    }
#line 241
    goto switch_break;
    case_108: /* CIL Label */ 
    {
#line 243
    name_length = atoi((char const   *)optarg);
    }
#line 244
    goto switch_break;
    case_109: /* CIL Label */ 
#line 246
    write_mst = 1;
#line 247
    goto switch_break;
    case_110: /* CIL Label */ 
#line 249
    if ((int )*optarg != 99) {
      {
#line 251
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)usage,
              *(argv + 0));
#line 252
      exit(0);
      }
    }
    {
#line 256
    if ((int )*(optarg + 1) == 109) {
#line 256
      goto case_109___0;
    }
#line 259
    if ((int )*(optarg + 1) == 110) {
#line 259
      goto case_110___0;
    }
#line 262
    if ((int )*(optarg + 1) == 102) {
#line 262
      goto case_102___0;
    }
#line 265
    goto switch_default;
    case_109___0: /* CIL Label */ 
    {
#line 257
    conname_format((ConNameForm )0);
    }
#line 258
    goto switch_break___0;
    case_110___0: /* CIL Label */ 
    {
#line 260
    conname_format((ConNameForm )1);
    }
#line 261
    goto switch_break___0;
    case_102___0: /* CIL Label */ 
    {
#line 263
    conname_format((ConNameForm )2);
    }
#line 264
    goto switch_break___0;
    switch_default: /* CIL Label */ 
    {
#line 266
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)usage,
            *(argv + 0));
#line 267
    exit(0);
    }
    switch_break___0: /* CIL Label */ ;
    }
#line 269
    goto switch_break;
    case_111: /* CIL Label */ 
    {
#line 271
    basefile = mem_strdup((char const   *)optarg, "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/zimpl.c",
                          (int const   )271);
    }
#line 272
    goto switch_break;
    case_79: /* CIL Label */ 
#line 274
    presolve = 1;
#line 275
    goto switch_break;
    case_80: /* CIL Label */ 
    {
#line 277
    inppipe = mem_strdup((char const   *)optarg, "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/zimpl.c",
                         (int const   )277);
    }
#line 278
    goto switch_break;
    case_115: /* CIL Label */ 
    {
#line 280
    tmp___2 = atol((char const   *)optarg);
#line 280
    seed = (unsigned long )tmp___2;
    }
#line 281
    goto switch_break;
    case_114: /* CIL Label */ 
#line 283
    write_order = 1;
#line 284
    goto switch_break;
    case_116: /* CIL Label */ 
    {
#line 286
    tmp___3 = tolower((int )*optarg);
    }
    {
#line 288
    if (tmp___3 == 104) {
#line 288
      goto case_104___0;
    }
#line 291
    if (tmp___3 == 109) {
#line 291
      goto case_109___1;
    }
#line 294
    if (tmp___3 == 108) {
#line 294
      goto case_108___0;
    }
#line 297
    if (tmp___3 == 112) {
#line 297
      goto case_112;
    }
#line 300
    if (tmp___3 == 114) {
#line 300
      goto case_114___0;
    }
#line 303
    goto switch_default___0;
    case_104___0: /* CIL Label */ 
#line 289
    format = (LpFormat )2;
#line 290
    goto switch_break___1;
    case_109___1: /* CIL Label */ 
#line 292
    format = (LpFormat )3;
#line 293
    goto switch_break___1;
    case_108___0: /* CIL Label */ 
#line 295
    format = (LpFormat )1;
#line 296
    goto switch_break___1;
    case_112: /* CIL Label */ 
#line 298
    format = (LpFormat )5;
#line 299
    goto switch_break___1;
    case_114___0: /* CIL Label */ 
#line 301
    format = (LpFormat )4;
#line 302
    goto switch_break___1;
    switch_default___0: /* CIL Label */ 
#line 304
    if (verbose > 0) {
      {
#line 305
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"--- Warning 103: Output format \"%s\" not supported, using LP format\n",
              optarg);
      }
    }
#line 308
    format = (LpFormat )1;
#line 309
    goto switch_break___1;
    switch_break___1: /* CIL Label */ ;
    }
#line 311
    goto switch_break;
    case_118: /* CIL Label */ 
    {
#line 313
    verbose = atoi((char const   *)optarg);
    }
#line 314
    goto switch_break;
    case_86: /* CIL Label */ 
    {
#line 316
    printf((char const   */* __restrict  */)"%s\n", "3.3.1");
#line 317
    exit(0);
    }
    case_63: /* CIL Label */ 
    {
#line 319
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)usage,
            *(argv + 0));
#line 320
    exit(0);
    }
    switch_default___1: /* CIL Label */ 
    {
#line 322
    abort();
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 325
  if (argc - optind < 1) {
    {
#line 327
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)usage,
            *(argv + 0));
#line 328
    exit(0);
    }
  }
  {
#line 331
  zpl_print_banner(stdout, 1);
  }
#line 333
  if ((unsigned long )basefile == (unsigned long )((void *)0)) {
    {
#line 334
    tmp___4 = strip_path((char const   *)*(argv + optind));
#line 334
    tmp___5 = mem_strdup(tmp___4, "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/zimpl.c",
                         (int const   )334);
#line 334
    basefile = strip_extension(tmp___5);
    }
  }
  {
#line 338
  if ((unsigned int )format == 1U) {
#line 338
    goto case_1;
  }
#line 341
  if ((unsigned int )format == 3U) {
#line 341
    goto case_3;
  }
#line 344
  if ((unsigned int )format == 2U) {
#line 344
    goto case_2;
  }
#line 347
  if ((unsigned int )format == 4U) {
#line 347
    goto case_4;
  }
#line 350
  if ((unsigned int )format == 5U) {
#line 350
    goto case_5;
  }
#line 353
  goto switch_default___2;
  case_1: /* CIL Label */ 
#line 339
  extension = ".lp";
#line 340
  goto switch_break___2;
  case_3: /* CIL Label */ 
#line 342
  extension = ".mps";
#line 343
  goto switch_break___2;
  case_2: /* CIL Label */ 
#line 345
  extension = ".hum";
#line 346
  goto switch_break___2;
  case_4: /* CIL Label */ 
#line 348
  extension = ".rlp";
#line 349
  goto switch_break___2;
  case_5: /* CIL Label */ 
#line 351
  extension = ".pip";
#line 352
  goto switch_break___2;
  switch_default___2: /* CIL Label */ 
  {
#line 354
  abort();
  }
  switch_break___2: /* CIL Label */ ;
  }
  {
#line 358
  outfile = add_extention((char const   *)basefile, extension);
#line 359
  tblfile = add_extention((char const   *)basefile, ".tbl");
#line 360
  ordfile = add_extention((char const   *)basefile, ".ord");
#line 361
  mstfile = add_extention((char const   *)basefile, ".mst");
#line 363
  tmp___6 = strlen((char const   *)basefile);
#line 363
  tmp___7 = strlen((char const   *)filter);
#line 363
  tmp___8 = mem_malloc((tmp___6 + tmp___7) + 256UL, "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/zimpl.c",
                       (int const   )363);
#line 363
  outpipe = (char *)tmp___8;
#line 367
  blk_init();
#line 368
  str_init();
#line 369
  rand_init(seed);
#line 370
  numb_init(1);
#line 371
  elem_init();
#line 372
  set_init();
#line 373
  mio_init();
#line 374
  interns_init();
#line 375
  local_init();
#line 379
  set = set_pseudo_new();
#line 380
  symbol_new("@@", (SymbolType )4, (Set const   *)set, 100, (Entry const   *)((void *)0));
#line 381
  set_free(set);
#line 385
  i = 0;
  }
  {
#line 385
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 385
    if (! (i < param_count)) {
#line 385
      goto while_break___0;
    }
    {
#line 386
    zpl_add_parameter((char const   *)*(param_table + i));
#line 385
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 390
  prog = prog_new();
#line 392
  i = optind;
  }
  {
#line 392
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 392
    if (! (i < argc)) {
#line 392
      goto while_break___1;
    }
    {
#line 393
    prog_load(prog, (char const   *)inppipe, (char const   *)*(argv + i));
#line 392
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 395
  tmp___9 = prog_is_empty((Prog const   *)prog);
  }
#line 395
  if (tmp___9) {
    {
#line 397
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"*** Error 168: No program statements to execute\n");
#line 398
    exit(1);
    }
  }
#line 400
  if (verbose >= 5) {
    {
#line 401
    prog_print(stderr, (Prog const   *)prog);
    }
  }
#line 403
  if (write_mst) {
#line 403
    tmp___10 = 1;
  } else
#line 403
  if (write_order) {
#line 403
    tmp___10 = 1;
  } else {
#line 403
    tmp___10 = 0;
  }
  {
#line 403
  tmp___11 = xlp_alloc((char const   *)*(argv + optind), tmp___10, (void *)0);
#line 403
  lp = (void *)tmp___11;
#line 404
  zlp_setnamelen((Lps *)lp, name_length);
#line 406
  prog_execute((Prog const   *)prog, lp);
  }
#line 410
  if (presolve) {
    {
#line 411
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"--- Warning: Presolve no longer support. If you need it, send me an email\n");
    }
  }
#line 416
  if (verbose >= 1) {
    {
#line 417
    zlp_stat((Lps *)lp);
    }
  }
#line 421
  if (write_order) {
    {
#line 423
    sprintf((char */* __restrict  */)outpipe, (char const   */* __restrict  */)filter,
            ordfile, "ord");
    }
#line 425
    if (verbose >= 1) {
      {
#line 426
      printf((char const   */* __restrict  */)"Writing [%s]\n", outpipe);
      }
    }
    {
#line 428
    fp = (*openfile)((char const   *)outpipe, "w");
    }
#line 428
    if ((unsigned long )((void *)0) == (unsigned long )fp) {
      {
#line 430
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"*** Error 104: File open failed ");
#line 431
      perror((char const   *)ordfile);
#line 432
      exit(1);
      }
    }
    {
#line 434
    zlp_orderfile((Lps *)lp, fp, format);
#line 436
    check_write_ok(fp, (char const   *)ordfile);
#line 438
    (*closefile)(fp);
    }
  }
#line 442
  if (write_mst) {
    {
#line 444
    sprintf((char */* __restrict  */)outpipe, (char const   */* __restrict  */)filter,
            mstfile, "mst");
    }
#line 446
    if (verbose >= 1) {
      {
#line 447
      printf((char const   */* __restrict  */)"Writing [%s]\n", outpipe);
      }
    }
    {
#line 449
    fp = (*openfile)((char const   *)outpipe, "w");
    }
#line 449
    if ((unsigned long )((void *)0) == (unsigned long )fp) {
      {
#line 451
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"*** Error 104: File open failed ");
#line 452
      perror((char const   *)mstfile);
#line 453
      exit(1);
      }
    }
    {
#line 455
    zlp_mstfile((Lps *)lp, fp, format);
#line 457
    check_write_ok(fp, (char const   *)mstfile);
#line 459
    (*closefile)(fp);
    }
  }
  {
#line 463
  sprintf((char */* __restrict  */)outpipe, (char const   */* __restrict  */)filter,
          outfile, "lp");
  }
#line 465
  if (verbose >= 1) {
    {
#line 466
    printf((char const   */* __restrict  */)"Writing [%s]\n", outpipe);
    }
  }
  {
#line 468
  fp = (*openfile)((char const   *)outpipe, "w");
  }
#line 468
  if ((unsigned long )((void *)0) == (unsigned long )fp) {
    {
#line 470
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"*** Error 104: File open failed ");
#line 471
    perror((char const   *)outfile);
#line 472
    exit(1);
    }
  }
#line 474
  if ((unsigned int )format != 4U) {
#line 475
    if ((unsigned int )format == 3U) {
#line 475
      tmp___12 = "* ";
    } else {
#line 475
      tmp___12 = "\\ ";
    }
    {
#line 475
    prog_text = prog_tostr((Prog const   *)prog, tmp___12, (char const   *)title,
                           128);
    }
  } else {
    {
#line 478
    tmp___13 = strlen((char const   *)title);
#line 478
    tmp___14 = mem_malloc(tmp___13 + 4UL, "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/zimpl.c",
                          (int const   )478);
#line 478
    prog_text = (char *)tmp___14;
#line 482
    sprintf((char */* __restrict  */)prog_text, (char const   */* __restrict  */)"\\%s\n",
            title);
    }
  }
  {
#line 484
  zlp_write((Lps *)lp, fp, format, (char const   *)prog_text);
#line 486
  check_write_ok(fp, (char const   *)outfile);
#line 488
  (*closefile)(fp);
  }
#line 493
  if ((unsigned int )format != 2U) {
    {
#line 497
    sprintf((char */* __restrict  */)outpipe, (char const   */* __restrict  */)filter,
            tblfile, "tbl");
    }
#line 499
    if (verbose >= 1) {
      {
#line 500
      printf((char const   */* __restrict  */)"Writing [%s]\n", outpipe);
      }
    }
    {
#line 502
    fp = (*openfile)((char const   *)outpipe, "w");
    }
#line 502
    if ((unsigned long )((void *)0) == (unsigned long )fp) {
      {
#line 504
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"*** Error 104: File open failed");
#line 505
      perror((char const   *)tblfile);
#line 506
      exit(1);
      }
    }
    {
#line 508
    zlp_transtable((Lps *)lp, fp, format);
#line 510
    check_write_ok(fp, (char const   *)tblfile);
#line 512
    (*closefile)(fp);
    }
  }
  {
#line 518
  mem_free((void *)prog_text, "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/zimpl.c",
           (int const   )518);
  }
#line 520
  if (verbose >= 5) {
    {
#line 521
    symbol_print_all(stderr);
    }
  }
#line 562
  return (0);
}
}
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 481 "/usr/include/x86_64-linux-gnu/gmp.h"
extern void __gmp_set_memory_functions(void *(*)(size_t  ) , void *(*)(void * , size_t  ,
                                                                       size_t  ) ,
                                       void (*)(void * , size_t  ) ) ;
#line 497
extern char const   * const  __gmp_version ;
#line 1132
extern void __gmpq_canonicalize(mpq_ptr  ) ;
#line 1197
extern size_t __gmpq_out_str(FILE * , int  , mpq_srcptr  ) ;
#line 1219
extern int __gmpq_set_str(mpq_ptr  , char const   * , int  ) ;
#line 1248
extern void __gmpf_clear(mpf_ptr  ) ;
#line 1323
extern void __gmpf_init(mpf_ptr  ) ;
#line 1368
extern size_t __gmpf_out_str(FILE * , int  , size_t  , mpf_srcptr  ) ;
#line 1396
extern void __gmpf_set_q(mpf_ptr  , mpq_srcptr  ) ;
#line 41 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/gmpmisc.h"
mpq_t const_zero  ;
#line 42 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/gmpmisc.h"
mpq_t const_one  ;
#line 43 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/gmpmisc.h"
mpq_t const_minus_one  ;
#line 46
void gmp_str2mpq(__mpq_struct *value , char const   *num ) ;
#line 48
void gmp_print_mpq(FILE *fp , __mpq_struct * const  qval ) ;
#line 49
void gmp_init(Bool verbose___0 , Bool with_management ) ;
#line 50
void gmp_exit(void) ;
#line 62 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/gmpmisc.c"
static Pool *pool_root  =    (Pool *)((void *)0);
#line 63 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/gmpmisc.c"
static PoolElem *pool_next  =    (PoolElem *)((void *)0);
#line 65 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/gmpmisc.c"
static void *pool_alloc(void) 
{ 
  Pool *pool ;
  PoolElem *elem ;
  int i ;
  void *tmp ;

  {
#line 71
  if ((unsigned long )pool_next == (unsigned long )((void *)0)) {
    {
#line 73
    tmp = mem_malloc(sizeof(*pool), "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/gmpmisc.c",
                     (int const   )73);
#line 73
    pool = (Pool *)tmp;
#line 74
    pool->next = pool_root;
#line 75
    pool_root = pool;
#line 77
    i = 0;
    }
    {
#line 77
    while (1) {
      while_continue: /* CIL Label */ ;
#line 77
      if (! (i < 9999)) {
#line 77
        goto while_break;
      }
#line 78
      pool->elem[i].next = & pool->elem[i + 1];
#line 77
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 80
    pool->elem[i].next = (PoolElem *)((void *)0);
#line 82
    pool_next = & pool->elem[0];
  }
#line 86
  elem = pool_next;
#line 87
  pool_next = elem->next;
#line 89
  return ((void *)elem);
}
}
#line 92 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/gmpmisc.c"
static void pool_free(void *pv ) 
{ 
  PoolElem *elem ;

  {
#line 94
  elem = (PoolElem *)pv;
#line 96
  elem->next = pool_next;
#line 97
  pool_next = elem;
#line 98
  return;
}
}
#line 100 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/gmpmisc.c"
static void pool_exit(void) 
{ 
  Pool *p ;
  Pool *q ;

  {
#line 105
  p = pool_root;
  {
#line 105
  while (1) {
    while_continue: /* CIL Label */ ;
#line 105
    if (! ((unsigned long )p != (unsigned long )((void *)0))) {
#line 105
      goto while_break;
    }
    {
#line 107
    q = p->next;
#line 109
    mem_free((void *)p, "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/gmpmisc.c",
             (int const   )109);
#line 105
    p = q;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 111
  pool_root = (Pool *)((void *)0);
#line 112
  pool_next = (PoolElem *)((void *)0);
#line 113
  return;
}
}
#line 117 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/gmpmisc.c"
void gmp_str2mpq(__mpq_struct *value , char const   *num ) 
{ 
  char tmp[1024] ;
  int i ;
  int k ;
  int exponent ;
  int fraction ;
  unsigned short const   **tmp___0 ;
  int tmp___1 ;
  char const   *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  unsigned short const   **tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;

  {
#line 121
  k = 0;
#line 122
  exponent = 0;
#line 123
  fraction = 0;
  {
#line 132
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 132
    tmp___0 = __ctype_b_loc();
    }
#line 132
    if (! ((int const   )*(*tmp___0 + (int )*num) & 8192)) {
#line 132
      goto while_break;
    }
#line 133
    num ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 137
  if ((int const   )*num == 43) {
#line 138
    num ++;
  } else
#line 139
  if ((int const   )*num == 45) {
#line 140
    tmp___1 = k;
#line 140
    k ++;
#line 140
    tmp___2 = num;
#line 140
    num ++;
#line 140
    tmp[tmp___1] = (char )*tmp___2;
  }
#line 142
  i = 0;
  {
#line 142
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 142
    if (! ((int const   )*(num + i) != 0)) {
#line 142
      goto while_break___0;
    }
    {
#line 144
    tmp___6 = __ctype_b_loc();
    }
#line 144
    if ((int const   )*(*tmp___6 + (int )*(num + i)) & 2048) {
#line 146
      tmp___3 = k;
#line 146
      k ++;
#line 146
      tmp[tmp___3] = (char )*(num + i);
#line 147
      exponent -= fraction;
    } else
#line 149
    if ((int const   )*(num + i) == 46) {
#line 150
      fraction = 1;
    } else {
      {
#line 151
      tmp___5 = tolower((int )*(num + i));
      }
#line 151
      if (tmp___5 == 101) {
        {
#line 153
        tmp___4 = atoi(num + (i + 1));
#line 153
        exponent += tmp___4;
        }
#line 154
        goto while_break___0;
      }
    }
#line 142
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 157
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 157
    if (! (exponent > 0)) {
#line 157
      goto while_break___1;
    }
#line 159
    tmp___7 = k;
#line 159
    k ++;
#line 159
    tmp[tmp___7] = (char )'0';
#line 160
    exponent --;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 162
  tmp___8 = k;
#line 162
  k ++;
#line 162
  tmp[tmp___8] = (char )'/';
#line 163
  tmp___9 = k;
#line 163
  k ++;
#line 163
  tmp[tmp___9] = (char )'1';
  {
#line 165
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 165
    if (! (exponent < 0)) {
#line 165
      goto while_break___2;
    }
#line 167
    tmp___10 = k;
#line 167
    k ++;
#line 167
    tmp[tmp___10] = (char )'0';
#line 168
    exponent ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 170
  tmp[k] = (char )'\000';
#line 174
  __gmpq_set_str((mpq_ptr )value, (char const   *)(tmp), 10);
#line 175
  __gmpq_canonicalize((mpq_ptr )value);
  }
#line 176
  return;
}
}
#line 178 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/gmpmisc.c"
void gmp_print_mpq(FILE *fp , __mpq_struct * const  qval ) 
{ 
  mpf_t fval ;

  {
  {
#line 182
  __gmpf_init(fval);
#line 183
  __gmpf_set_q(fval, (mpq_srcptr )qval);
#line 184
  __gmpf_out_str(fp, 10, (size_t )32, (mpf_srcptr )(fval));
#line 185
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" = ");
#line 186
  __gmpq_out_str(fp, 10, (mpq_srcptr )qval);
#line 187
  fputc('\n', fp);
#line 188
  __gmpf_clear(fval);
  }
#line 189
  return;
}
}
#line 192 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/gmpmisc.c"
static void *gmp_alloc(size_t size ) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
#line 194
  if (size <= 16UL) {
    {
#line 195
    tmp = pool_alloc();
    }
#line 195
    return (tmp);
  }
  {
#line 197
  tmp___0 = mem_malloc(size, "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/gmpmisc.c",
                       (int const   )197);
  }
#line 197
  return (tmp___0);
}
}
#line 201 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/gmpmisc.c"
static void *gmp_realloc(void *ptr , size_t old_size , size_t new_size ) 
{ 
  void *p ;
  void *tmp ;

  {
#line 205
  if (old_size <= 16UL) {
#line 205
    if (new_size <= 16UL) {
#line 206
      return (ptr);
    }
  }
#line 208
  if (old_size <= 16UL) {
    {
#line 213
    p = mem_malloc(new_size, "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/gmpmisc.c",
                   (int const   )213);
#line 215
    memcpy((void */* __restrict  */)p, (void const   */* __restrict  */)ptr, old_size);
#line 217
    pool_free(ptr);
    }
#line 219
    return (p);
  }
#line 221
  if (new_size <= 16UL) {
    {
#line 226
    p = pool_alloc();
#line 228
    memcpy((void */* __restrict  */)p, (void const   */* __restrict  */)ptr, new_size);
#line 230
    mem_free(ptr, "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/gmpmisc.c",
             (int const   )230);
    }
#line 232
    return (p);
  }
  {
#line 234
  tmp = mem_realloc(ptr, new_size, "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/gmpmisc.c",
                    (int const   )234);
  }
#line 234
  return (tmp);
}
}
#line 238 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/gmpmisc.c"
static void gmp_free(void *ptr , size_t size ) 
{ 


  {
#line 240
  if (size <= 16UL) {
    {
#line 241
    pool_free(ptr);
    }
  } else {
    {
#line 243
    mem_free(ptr, "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/gmpmisc.c",
             (int const   )243);
    }
  }
#line 244
  return;
}
}
#line 246 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/gmpmisc.c"
void gmp_init(Bool verbose___0 , Bool with_management ) 
{ 
  char const   *tmp ;

  {
#line 248
  if (with_management) {
    {
#line 249
    __gmp_set_memory_functions(& gmp_alloc, & gmp_realloc, & gmp_free);
    }
  }
  {
#line 251
  __gmpq_init(const_zero);
#line 252
  __gmpq_init(const_one);
#line 253
  __gmpq_init(const_minus_one);
#line 255
  __gmpq_set_ui(const_one, 1UL, 1UL);
#line 256
  __gmpq_set_si(const_minus_one, -1L, 1UL);
  }
#line 258
  if (verbose___0) {
#line 259
    if (with_management) {
#line 259
      tmp = "[memory management redirected]";
    } else {
#line 259
      tmp = "[memory management unchanged]";
    }
    {
#line 259
    printf((char const   */* __restrict  */)"Using GMP Version %s %s\n", __gmp_version,
           tmp);
    }
  }
#line 261
  return;
}
}
#line 263 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/gmpmisc.c"
void gmp_exit(void) 
{ 


  {
  {
#line 265
  __gmpq_clear(const_zero);
#line 266
  __gmpq_clear(const_one);
#line 267
  __gmpq_clear(const_minus_one);
#line 269
  pool_exit();
  }
#line 270
  return;
}
}
#line 111 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/numb.h"
extern void numb_print(FILE *fp , Numb const   *numb ) ;
#line 51 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/bound.h"
Bool bound_is_valid(Bound const   *bound ) ;
#line 53
Bound *bound_copy(Bound const   *source ) ;
#line 59
void bound_print(FILE *fp , Bound const   *bound ) ;
#line 48 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/bound.c"
Bound *bound_new(BoundType type , Numb const   *value ) 
{ 
  Bound *bound ;
  void *tmp ;

  {
  {
#line 50
  tmp = mem_calloc((size_t )1, sizeof(*bound), "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/bound.c",
                   (int const   )50);
#line 50
  bound = (Bound *)tmp;
#line 54
  bound->type = type;
  }
#line 56
  if ((unsigned int )bound->type == 1U) {
    {
#line 60
    bound->value = numb_copy(value);
    }
  }
#line 66
  return (bound);
}
}
#line 69 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/bound.c"
void bound_free(Bound *bound ) 
{ 


  {
#line 73
  if ((unsigned int )bound->type == 1U) {
    {
#line 74
    numb_free(bound->value);
    }
  }
  {
#line 78
  mem_free((void *)bound, "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/bound.c",
           (int const   )78);
  }
#line 79
  return;
}
}
#line 81 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/bound.c"
Bool bound_is_valid(Bound const   *bound ) 
{ 


  {
#line 83
  if ((unsigned long )bound == (unsigned long )((void *)0)) {
#line 86
    return (0);
  } else
#line 83
  if ((unsigned int const   )bound->type == 1U) {
#line 83
    if ((unsigned long )bound->value == (unsigned long )((void *)0)) {
#line 86
      return (0);
    } else {
#line 83
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 83
  if ((unsigned int const   )bound->type != 1U) {
#line 83
    if ((unsigned long )bound->value != (unsigned long )((void *)0)) {
#line 86
      return (0);
    }
  }
#line 90
  return (1);
}
}
#line 93 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/bound.c"
Bound *bound_copy(Bound const   *source ) 
{ 
  Bound *tmp ;

  {
  {
#line 97
  tmp = bound_new((BoundType )source->type, (Numb const   *)source->value);
  }
#line 97
  return (tmp);
}
}
#line 100 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/bound.c"
BoundType bound_get_type(Bound const   *bound ) 
{ 


  {
#line 104
  return ((BoundType )bound->type);
}
}
#line 107 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/bound.c"
Numb const   *bound_get_value(Bound const   *bound ) 
{ 


  {
#line 112
  return ((Numb const   *)bound->value);
}
}
#line 115 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/bound.c"
void bound_print(FILE *fp , Bound const   *bound ) 
{ 


  {
  {
#line 119
  if ((unsigned int const   )bound->type == 2U) {
#line 119
    goto case_2;
  }
#line 122
  if ((unsigned int const   )bound->type == 3U) {
#line 122
    goto case_3;
  }
#line 125
  if ((unsigned int const   )bound->type == 1U) {
#line 125
    goto case_1;
  }
#line 128
  goto switch_default;
  case_2: /* CIL Label */ 
  {
#line 120
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"oo");
  }
#line 121
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 123
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"-oo");
  }
#line 124
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 126
  numb_print(fp, (Numb const   *)bound->value);
  }
#line 127
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 129
  abort();
  }
  switch_break: /* CIL Label */ ;
  }
#line 131
  return;
}
}
#line 184 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/ratlp.h"
void lps_orderfile(Lps const   *lp , FILE *fp , LpFormat format , char const   *text ) ;
#line 49 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/zlpglue.c"
static char const   * const  title___0  =    (char const   */* const  */)"This file was automatically generated by Zimpl";
#line 53 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/zlpglue.c"
void zlp_stat(Lps *lp ) 
{ 


  {
  {
#line 58
  lps_stat((Lps const   *)lp);
  }
#line 59
  return;
}
}
#line 63 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/zlpglue.c"
void zlp_setnamelen(Lps *lp , int name_len ) 
{ 


  {
  {
#line 69
  lps_setnamelen(lp, name_len);
  }
#line 70
  return;
}
}
#line 103 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/zlpglue.c"
void zlp_write(Lps *lp , FILE *fp , LpFormat format , char const   *text ) 
{ 


  {
  {
#line 112
  lps_scale((Lps const   *)lp);
#line 113
  lps_write((Lps const   *)lp, fp, format, text);
  }
#line 114
  return;
}
}
#line 121 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/zlpglue.c"
void zlp_transtable(Lps *lp , FILE *fp , LpFormat format ) 
{ 


  {
  {
#line 129
  lps_transtable((Lps const   *)lp, fp, format, "zimpl");
  }
#line 130
  return;
}
}
#line 134 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/zlpglue.c"
void zlp_orderfile(Lps *lp , FILE *fp , LpFormat format ) 
{ 


  {
  {
#line 142
  lps_orderfile((Lps const   *)lp, fp, format, (char const   *)title___0);
  }
#line 143
  return;
}
}
#line 147 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/zlpglue.c"
void zlp_mstfile(Lps *lp , FILE *fp , LpFormat format ) 
{ 


  {
  {
#line 155
  lps_mstfile((Lps const   *)lp, fp, format, (char const   *)title___0);
  }
#line 156
  return;
}
}
#line 109 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/numb.h"
extern double numb_todbl(Numb const   *numb ) ;
#line 52 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/tuple.h"
extern Tuple *tuple_copy(Tuple const   *tuple ) ;
#line 54
extern Bool tuple_cmp(Tuple const   *tuple_a , Tuple const   *tuple_b ) ;
#line 64
extern void tuple_print(FILE *fp , Tuple const   *tuple ) ;
#line 56 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/set.h"
extern Set *set_copy(Set const   *set ) ;
#line 72
extern void set_print(FILE *fp , Set const   *set ) ;
#line 41 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/entry.h"
Entry *entry_new_numb(Tuple const   *tuple , Numb const   *numb ) ;
#line 43
Entry *entry_new_strg(Tuple const   *tuple , char const   *strg ) ;
#line 45
Entry *entry_new_set(Tuple const   *tuple , Set const   *set ) ;
#line 49
void entry_free(Entry *entry ) ;
#line 51
Bool entry_is_valid(Entry const   *entry ) ;
#line 53
Entry *entry_copy(Entry const   *source ) ;
#line 55
Bool entry_cmp(Entry const   *entry , Tuple const   *tuple ) ;
#line 57
SymbolType entry_get_type(Entry const   *entry ) ;
#line 59
Tuple const   *entry_get_tuple(Entry const   *entry ) ;
#line 61
Numb const   *entry_get_numb(Entry const   *entry ) ;
#line 63
char const   *entry_get_strg(Entry const   *entry ) ;
#line 65
Set const   *entry_get_set(Entry const   *entry ) ;
#line 67
Var *entry_get_var(Entry const   *entry ) ;
#line 69
void entry_print(FILE *fp , Entry const   *entry ) ;
#line 41 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/zimpllib.h"
extern void zpl_var_print(FILE *fp , Var const   *var ) ;
#line 66 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/entry.c"
Entry *entry_new_numb(Tuple const   *tuple , Numb const   *numb ) 
{ 
  Entry *entry ;
  void *tmp ;

  {
  {
#line 68
  tmp = mem_calloc((size_t )1, sizeof(*entry), "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/entry.c",
                   (int const   )68);
#line 68
  entry = (Entry *)tmp;
#line 73
  entry->refc = 1;
#line 74
  entry->tuple = tuple_copy(tuple);
#line 75
  entry->type = (SymbolType )1;
#line 76
  entry->value.numb = numb_copy(numb);
  }
#line 83
  return (entry);
}
}
#line 86 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/entry.c"
Entry *entry_new_strg(Tuple const   *tuple , char const   *strg ) 
{ 
  Entry *entry ;
  void *tmp ;

  {
  {
#line 88
  tmp = mem_calloc((size_t )1, sizeof(*entry), "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/entry.c",
                   (int const   )88);
#line 88
  entry = (Entry *)tmp;
#line 94
  entry->refc = 1;
#line 95
  entry->tuple = tuple_copy(tuple);
#line 96
  entry->type = (SymbolType )2;
#line 97
  entry->value.strg = strg;
  }
#line 102
  return (entry);
}
}
#line 105 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/entry.c"
Entry *entry_new_set(Tuple const   *tuple , Set const   *set ) 
{ 
  Entry *entry ;
  void *tmp ;

  {
  {
#line 107
  tmp = mem_calloc((size_t )1, sizeof(*entry), "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/entry.c",
                   (int const   )107);
#line 107
  entry = (Entry *)tmp;
#line 113
  entry->refc = 1;
#line 114
  entry->tuple = tuple_copy(tuple);
#line 115
  entry->type = (SymbolType )3;
#line 116
  entry->value.set = set_copy(set);
  }
#line 121
  return (entry);
}
}
#line 124 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/entry.c"
Entry *entry_new_var(Tuple const   *tuple , Var *var ) 
{ 
  Entry *entry ;
  void *tmp ;

  {
  {
#line 126
  tmp = mem_calloc((size_t )1, sizeof(*entry), "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/entry.c",
                   (int const   )126);
#line 126
  entry = (Entry *)tmp;
#line 132
  entry->refc = 1;
#line 133
  entry->tuple = tuple_copy(tuple);
#line 134
  entry->type = (SymbolType )4;
#line 135
  entry->value.var = var;
  }
#line 140
  return (entry);
}
}
#line 143 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/entry.c"
void entry_free(Entry *entry ) 
{ 


  {
#line 147
  (entry->refc) --;
#line 149
  if (entry->refc == 0) {
    {
#line 155
    if ((unsigned int )entry->type == 1U) {
#line 155
      goto case_1;
    }
#line 158
    if ((unsigned int )entry->type == 2U) {
#line 158
      goto case_2;
    }
#line 160
    if ((unsigned int )entry->type == 3U) {
#line 160
      goto case_3;
    }
#line 163
    if ((unsigned int )entry->type == 4U) {
#line 163
      goto case_4;
    }
#line 165
    goto switch_default;
    case_1: /* CIL Label */ 
    {
#line 156
    numb_free(entry->value.numb);
    }
#line 157
    goto switch_break;
    case_2: /* CIL Label */ 
#line 159
    goto switch_break;
    case_3: /* CIL Label */ 
    {
#line 161
    set_free(entry->value.set);
    }
#line 162
    goto switch_break;
    case_4: /* CIL Label */ 
#line 164
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 166
    abort();
    }
    switch_break: /* CIL Label */ ;
    }
    {
#line 168
    tuple_free(entry->tuple);
#line 170
    mem_free((void *)entry, "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/entry.c",
             (int const   )170);
    }
  }
#line 172
  return;
}
}
#line 174 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/entry.c"
Bool entry_is_valid(Entry const   *entry ) 
{ 


  {
#line 176
  if ((unsigned long )entry == (unsigned long )((void *)0)) {
#line 177
    return (0);
  }
#line 181
  return (1);
}
}
#line 184 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/entry.c"
Entry *entry_copy(Entry const   *source ) 
{ 
  Entry *entry ;

  {
#line 186
  entry = (Entry *)source;
#line 190
  (entry->refc) ++;
#line 192
  return (entry);
}
}
#line 195 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/entry.c"
Bool entry_cmp(Entry const   *entry , Tuple const   *tuple ) 
{ 
  Bool tmp ;

  {
  {
#line 200
  tmp = tuple_cmp((Tuple const   *)entry->tuple, tuple);
  }
#line 200
  return (tmp);
}
}
#line 203 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/entry.c"
SymbolType entry_get_type(Entry const   *entry ) 
{ 


  {
#line 207
  return ((SymbolType )entry->type);
}
}
#line 210 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/entry.c"
Tuple const   *entry_get_tuple(Entry const   *entry ) 
{ 


  {
#line 215
  return ((Tuple const   *)entry->tuple);
}
}
#line 218 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/entry.c"
Numb const   *entry_get_numb(Entry const   *entry ) 
{ 


  {
#line 223
  return ((Numb const   *)entry->value.numb);
}
}
#line 226 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/entry.c"
char const   *entry_get_strg(Entry const   *entry ) 
{ 


  {
#line 231
  return ((char const   *)entry->value.strg);
}
}
#line 234 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/entry.c"
Set const   *entry_get_set(Entry const   *entry ) 
{ 


  {
#line 239
  return ((Set const   *)entry->value.set);
}
}
#line 242 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/entry.c"
Var *entry_get_var(Entry const   *entry ) 
{ 


  {
#line 247
  return ((Var *)entry->value.var);
}
}
#line 250 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/entry.c"
void entry_print(FILE *fp , Entry const   *entry ) 
{ 
  double tmp ;

  {
  {
#line 254
  tuple_print(fp, (Tuple const   *)entry->tuple);
#line 255
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" -> ");
  }
  {
#line 259
  if ((unsigned int const   )entry->type == 1U) {
#line 259
    goto case_1;
  }
#line 262
  if ((unsigned int const   )entry->type == 2U) {
#line 262
    goto case_2;
  }
#line 265
  if ((unsigned int const   )entry->type == 3U) {
#line 265
    goto case_3;
  }
#line 268
  if ((unsigned int const   )entry->type == 4U) {
#line 268
    goto case_4;
  }
#line 271
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 260
  tmp = numb_todbl((Numb const   *)entry->value.numb);
#line 260
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%.16g", tmp);
  }
#line 261
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 263
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"\"%s\"",
          entry->value.strg);
  }
#line 264
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 266
  set_print(fp, (Set const   *)entry->value.set);
  }
#line 267
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 269
  zpl_var_print(fp, (Var const   *)entry->value.var);
  }
#line 270
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 272
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"Entry-ERR");
  }
#line 273
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 275
  return;
}
}
/* compiler builtin: 
   void __builtin_va_arg(__builtin_va_list  , unsigned long  , void * ) ;  */
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
#line 84 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/mme.h"
extern void show_source(FILE *fp , char const   *text , int column ) ;
#line 52 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/idxset.h"
extern void idxset_free(IdxSet *idxset ) ;
#line 56
extern IdxSet *idxset_copy(IdxSet const   *source ) ;
#line 40 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/rdefpar.h"
extern void rdef_free(RDef *rdef ) ;
#line 44
extern RDef *rdef_copy(RDef const   *rdef ) ;
#line 69
extern void rpar_free(RPar *rpar ) ;
#line 73
extern RPar *rpar_copy(RPar const   *rpar ) ;
#line 53 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/list.h"
extern void list_free(List *list ) ;
#line 63
extern List *list_copy(List const   *list ) ;
#line 57 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/stmt.h"
extern char const   *stmt_get_filename(Stmt const   *stmt ) ;
#line 59
extern int stmt_get_lineno(Stmt const   *stmt ) ;
#line 61
extern char const   *stmt_get_text(Stmt const   *stmt ) ;
#line 79
extern Stmt const   *scan_get_stmt(void) ;
#line 80
extern int scan_get_column(void) ;
#line 50 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/local.h"
extern void local_print_all(FILE *fp ) ;
#line 48 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/code.h"
CodeNode *code_new_inst(CodeNode *(*inst)(CodeNode *self ) , int childs  , ...) ;
#line 50
CodeNode *code_new_numb(Numb *numb ) ;
#line 52
CodeNode *code_new_strg(char const   *strg ) ;
#line 54
CodeNode *code_new_name(char const   *name ) ;
#line 56
CodeNode *code_new_size(int size ) ;
#line 58
CodeNode *code_new_varclass(VarClass varclass ) ;
#line 60
CodeNode *code_new_contype(ConType contype ) ;
#line 62
CodeNode *code_new_bits(unsigned int bits ) ;
#line 64
CodeNode *code_new_symbol(Symbol *sym ) ;
#line 66
CodeNode *code_new_define(Define *def ) ;
#line 68
CodeNode *code_new_bound(BoundType type ) ;
#line 70
void code_free(CodeNode *node ) ;
#line 72
void code_free_value(CodeNode *node ) ;
#line 74
__inline Bool code_is_valid(CodeNode const   *node ) ;
#line 76
CodeType code_get_type(CodeNode const   *node ) ;
#line 78
Inst code_get_inst(CodeNode const   *node ) ;
#line 80
void code_set_root(CodeNode *node ) ;
#line 82
CodeNode *code_get_root(void) ;
#line 84
void code_set_child(CodeNode *node , int idx , CodeNode *child ) ;
#line 92
__inline CodeNode *code_eval(CodeNode *node ) ;
#line 94
Bool code_prune_tree(CodeNode *node ) ;
#line 98
__inline Numb const   *code_get_numb(CodeNode *node ) ;
#line 100
__inline char const   *code_get_strg(CodeNode *node ) ;
#line 102
__inline char const   *code_get_name(CodeNode *node ) ;
#line 103
unsigned int code_get_inst_count(void) ;
#line 105
void code_clear_inst_count(void) ;
#line 106
__inline Tuple const   *code_get_tuple(CodeNode *node ) ;
#line 108
__inline Set const   *code_get_set(CodeNode *node ) ;
#line 110
__inline IdxSet const   *code_get_idxset(CodeNode *node ) ;
#line 112
__inline Entry const   *code_get_entry(CodeNode *node ) ;
#line 114
__inline Term const   *code_get_term(CodeNode *node ) ;
#line 116
__inline int code_get_size(CodeNode *node ) ;
#line 118
__inline Bool code_get_bool(CodeNode *node ) ;
#line 120
__inline List const   *code_get_list(CodeNode *node ) ;
#line 122
__inline VarClass code_get_varclass(CodeNode *node ) ;
#line 124
__inline ConType code_get_contype(CodeNode *node ) ;
#line 126
__inline RDef const   *code_get_rdef(CodeNode *node ) ;
#line 128
__inline RPar const   *code_get_rpar(CodeNode *node ) ;
#line 130
__inline unsigned int code_get_bits(CodeNode *node ) ;
#line 132
__inline Symbol *code_get_symbol(CodeNode *node ) ;
#line 134
__inline Define *code_get_define(CodeNode *node ) ;
#line 136
__inline Bound const   *code_get_bound(CodeNode *node ) ;
#line 138
void code_value_numb(CodeNode *node , Numb *numb ) ;
#line 140
void code_value_strg(CodeNode *node , char const   *strg ) ;
#line 142
void code_value_name(CodeNode *node , char const   *name ) ;
#line 144
void code_value_tuple(CodeNode *node , Tuple *tuple ) ;
#line 146
void code_value_set(CodeNode *node , Set *set ) ;
#line 148
void code_value_idxset(CodeNode *node , IdxSet *idxset ) ;
#line 150
void code_value_entry(CodeNode *node , Entry *entry ) ;
#line 154
Term *code_value_steal_term(CodeNode *node , int no ) ;
#line 156
void code_value_bool(CodeNode *node , Bool bval ) ;
#line 158
void code_value_size(CodeNode *node , int size ) ;
#line 160
void code_value_list(CodeNode *node , List *list ) ;
#line 162
void code_value_varclass(CodeNode *node , VarClass varclass ) ;
#line 164
void code_value_contype(CodeNode *node , ConType contype ) ;
#line 166
void code_value_rdef(CodeNode *node , RDef *rdef ) ;
#line 168
void code_value_rpar(CodeNode *node , RPar *rpar ) ;
#line 170
void code_value_bits(CodeNode *node , unsigned int bits ) ;
#line 172
void code_value_bound(CodeNode *node , Bound *bound ) ;
#line 176
void code_copy_value(CodeNode *dst , CodeNode const   *src ) ;
#line 179
CodeNode *code_eval_child(CodeNode const   *node , int no ) ;
#line 184
char const   *code_eval_child_strg(CodeNode const   *node , int no ) ;
#line 187
char const   *code_eval_child_name(CodeNode const   *node , int no ) ;
#line 189
Tuple const   *code_eval_child_tuple(CodeNode const   *node , int no ) ;
#line 191
Set const   *code_eval_child_set(CodeNode const   *node , int no ) ;
#line 193
IdxSet const   *code_eval_child_idxset(CodeNode const   *node , int no ) ;
#line 195
Entry const   *code_eval_child_entry(CodeNode const   *node , int no ) ;
#line 199
int code_eval_child_size(CodeNode const   *node , int no ) ;
#line 201
Bool code_eval_child_bool(CodeNode const   *node , int no ) ;
#line 203
List const   *code_eval_child_list(CodeNode const   *node , int no ) ;
#line 205
VarClass code_eval_child_varclass(CodeNode const   *node , int no ) ;
#line 209
RDef const   *code_eval_child_rdef(CodeNode const   *node , int no ) ;
#line 211
RPar const   *code_eval_child_rpar(CodeNode const   *node , int no ) ;
#line 215
Symbol *code_eval_child_symbol(CodeNode const   *node , int no ) ;
#line 217
Define *code_eval_child_define(CodeNode const   *node , int no ) ;
#line 219
Bound const   *code_eval_child_bound(CodeNode const   *node , int no ) ;
#line 100 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/inst.h"
extern CodeNode *i_expr_abs(CodeNode *self ) ;
#line 102
extern CodeNode *i_expr_sgn(CodeNode *self ) ;
#line 104
extern CodeNode *i_expr_add(CodeNode *self ) ;
#line 106
extern CodeNode *i_expr_card(CodeNode *self ) ;
#line 108
extern CodeNode *i_expr_ceil(CodeNode *self ) ;
#line 110
extern CodeNode *i_expr_div(CodeNode *self ) ;
#line 112
extern CodeNode *i_expr_exp(CodeNode *self ) ;
#line 114
extern CodeNode *i_expr_sqrt(CodeNode *self ) ;
#line 116
extern CodeNode *i_expr_fac(CodeNode *self ) ;
#line 118
extern CodeNode *i_expr_floor(CodeNode *self ) ;
#line 120
extern CodeNode *i_expr_if_else(CodeNode *self ) ;
#line 122
extern CodeNode *i_expr_intdiv(CodeNode *self ) ;
#line 124
extern CodeNode *i_expr_length(CodeNode *self ) ;
#line 126
extern CodeNode *i_expr_ln(CodeNode *self ) ;
#line 128
extern CodeNode *i_expr_log(CodeNode *self ) ;
#line 130
extern CodeNode *i_expr_ord(CodeNode *self ) ;
#line 132
extern CodeNode *i_expr_prod(CodeNode *self ) ;
#line 136
extern CodeNode *i_expr_round(CodeNode *self ) ;
#line 138
extern CodeNode *i_expr_sum(CodeNode *self ) ;
#line 140
extern CodeNode *i_expr_max(CodeNode *self ) ;
#line 142
extern CodeNode *i_expr_max2(CodeNode *self ) ;
#line 144
extern CodeNode *i_expr_sglmax(CodeNode *self ) ;
#line 146
extern CodeNode *i_expr_min(CodeNode *self ) ;
#line 148
extern CodeNode *i_expr_min2(CodeNode *self ) ;
#line 150
extern CodeNode *i_expr_sglmin(CodeNode *self ) ;
#line 152
extern CodeNode *i_expr_mul(CodeNode *self ) ;
#line 154
extern CodeNode *i_expr_mod(CodeNode *self ) ;
#line 156
extern CodeNode *i_expr_neg(CodeNode *self ) ;
#line 158
extern CodeNode *i_expr_pow(CodeNode *self ) ;
#line 160
extern CodeNode *i_expr_sub(CodeNode *self ) ;
#line 162
extern CodeNode *i_expr_substr(CodeNode *self ) ;
#line 190
extern CodeNode *i_nop(CodeNode *self ) ;
#line 97 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/code.c"
static CodeNode *root  =    (CodeNode *)((void *)0);
#line 98 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/code.c"
static unsigned int inst_count  =    0U;
#line 100 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/code.c"
__inline Bool code_is_valid(CodeNode const   *node ) 
{ 
  int tmp ;

  {
#line 102
  if ((unsigned long )node != (unsigned long )((void *)0)) {
#line 102
    tmp = 1;
  } else {
#line 102
    tmp = 0;
  }
#line 102
  return (tmp);
}
}
#line 105 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/code.c"
CodeNode *code_new_inst(CodeNode *(*inst)(CodeNode *self ) , int childs  , ...) 
{ 
  va_list ap ;
  CodeNode *node ;
  void *tmp ;
  int i ;
  CodeNode *child ;
  CodeNode *tmp___0 ;

  {
  {
#line 108
  tmp = mem_calloc((size_t )1, sizeof(*node), "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/code.c",
                   (int const   )108);
#line 108
  node = (CodeNode *)tmp;
#line 116
  node->type = (CodeType )0;
#line 117
  node->eval = inst;
#line 121
  node->stmt = scan_get_stmt();
#line 122
  node->column = scan_get_column();
#line 128
  __builtin_va_start(ap, childs);
#line 130
  i = 0;
  }
  {
#line 130
  while (1) {
    while_continue: /* CIL Label */ ;
#line 130
    if (! (i < childs)) {
#line 130
      goto while_break;
    }
    {
#line 132
    tmp___0 = __builtin_va_arg(ap, CodeNode *);
#line 132
    child = tmp___0;
#line 134
    node->child[i] = child;
#line 130
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 136
  __builtin_va_end(ap);
  }
#line 139
  return (node);
}
}
#line 144 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/code.c"
CodeNode *code_new_numb(Numb *numb ) 
{ 
  CodeNode *node ;
  void *tmp ;

  {
  {
#line 146
  tmp = mem_calloc((size_t )1, sizeof(*node), "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/code.c",
                   (int const   )146);
#line 146
  node = (CodeNode *)tmp;
#line 150
  node->type = (CodeType )1;
#line 151
  node->eval = & i_nop;
#line 152
  node->value.numb = numb;
#line 153
  node->stmt = scan_get_stmt();
#line 154
  node->column = scan_get_column();
  }
#line 159
  return (node);
}
}
#line 162 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/code.c"
CodeNode *code_new_strg(char const   *strg ) 
{ 
  CodeNode *node ;
  void *tmp ;

  {
  {
#line 164
  tmp = mem_calloc((size_t )1, sizeof(*node), "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/code.c",
                   (int const   )164);
#line 164
  node = (CodeNode *)tmp;
#line 169
  node->type = (CodeType )2;
#line 170
  node->eval = & i_nop;
#line 171
  node->value.strg = strg;
#line 172
  node->stmt = scan_get_stmt();
#line 173
  node->column = scan_get_column();
  }
#line 178
  return (node);
}
}
#line 181 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/code.c"
CodeNode *code_new_name(char const   *name ) 
{ 
  CodeNode *node ;
  void *tmp ;

  {
  {
#line 183
  tmp = mem_calloc((size_t )1, sizeof(*node), "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/code.c",
                   (int const   )183);
#line 183
  node = (CodeNode *)tmp;
#line 188
  node->type = (CodeType )3;
#line 189
  node->eval = & i_nop;
#line 190
  node->value.name = name;
#line 191
  node->stmt = scan_get_stmt();
#line 192
  node->column = scan_get_column();
  }
#line 197
  return (node);
}
}
#line 200 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/code.c"
CodeNode *code_new_size(int size ) 
{ 
  CodeNode *node ;
  void *tmp ;

  {
  {
#line 202
  tmp = mem_calloc((size_t )1, sizeof(*node), "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/code.c",
                   (int const   )202);
#line 202
  node = (CodeNode *)tmp;
#line 207
  node->type = (CodeType )8;
#line 208
  node->eval = & i_nop;
#line 209
  node->value.size = size;
#line 210
  node->stmt = scan_get_stmt();
#line 211
  node->column = scan_get_column();
  }
#line 216
  return (node);
}
}
#line 219 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/code.c"
CodeNode *code_new_varclass(VarClass varclass ) 
{ 
  CodeNode *node ;
  void *tmp ;

  {
  {
#line 221
  tmp = mem_calloc((size_t )1, sizeof(*node), "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/code.c",
                   (int const   )221);
#line 221
  node = (CodeNode *)tmp;
#line 225
  node->type = (CodeType )13;
#line 226
  node->eval = & i_nop;
#line 227
  node->value.varclass = varclass;
#line 228
  node->stmt = scan_get_stmt();
#line 229
  node->column = scan_get_column();
  }
#line 234
  return (node);
}
}
#line 237 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/code.c"
CodeNode *code_new_contype(ConType contype ) 
{ 
  CodeNode *node ;
  void *tmp ;

  {
  {
#line 239
  tmp = mem_calloc((size_t )1, sizeof(*node), "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/code.c",
                   (int const   )239);
#line 239
  node = (CodeNode *)tmp;
#line 243
  node->type = (CodeType )14;
#line 244
  node->eval = & i_nop;
#line 245
  node->value.contype = contype;
#line 246
  node->stmt = scan_get_stmt();
#line 247
  node->column = scan_get_column();
  }
#line 252
  return (node);
}
}
#line 255 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/code.c"
CodeNode *code_new_bits(unsigned int bits ) 
{ 
  CodeNode *node ;
  void *tmp ;

  {
  {
#line 257
  tmp = mem_calloc((size_t )1, sizeof(*node), "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/code.c",
                   (int const   )257);
#line 257
  node = (CodeNode *)tmp;
#line 261
  node->type = (CodeType )17;
#line 262
  node->eval = & i_nop;
#line 263
  node->value.bits = bits;
#line 264
  node->stmt = scan_get_stmt();
#line 265
  node->column = scan_get_column();
  }
#line 270
  return (node);
}
}
#line 273 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/code.c"
CodeNode *code_new_symbol(Symbol *sym ) 
{ 
  CodeNode *node ;
  void *tmp ;

  {
  {
#line 275
  tmp = mem_calloc((size_t )1, sizeof(*node), "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/code.c",
                   (int const   )275);
#line 275
  node = (CodeNode *)tmp;
#line 279
  node->type = (CodeType )18;
#line 280
  node->eval = & i_nop;
#line 281
  node->value.sym = sym;
#line 282
  node->stmt = scan_get_stmt();
#line 283
  node->column = scan_get_column();
  }
#line 288
  return (node);
}
}
#line 291 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/code.c"
CodeNode *code_new_define(Define *def ) 
{ 
  CodeNode *node ;
  void *tmp ;

  {
  {
#line 293
  tmp = mem_calloc((size_t )1, sizeof(*node), "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/code.c",
                   (int const   )293);
#line 293
  node = (CodeNode *)tmp;
#line 297
  node->type = (CodeType )19;
#line 298
  node->eval = & i_nop;
#line 299
  node->value.def = def;
#line 300
  node->stmt = scan_get_stmt();
#line 301
  node->column = scan_get_column();
  }
#line 306
  return (node);
}
}
#line 311 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/code.c"
CodeNode *code_new_bound(BoundType type ) 
{ 
  CodeNode *node ;
  void *tmp ;

  {
  {
#line 313
  tmp = mem_calloc((size_t )1, sizeof(*node), "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/code.c",
                   (int const   )313);
#line 313
  node = (CodeNode *)tmp;
#line 318
  node->type = (CodeType )20;
#line 319
  node->eval = & i_nop;
#line 320
  node->value.bound = bound_new(type, (Numb const   *)((void *)0));
#line 321
  node->stmt = scan_get_stmt();
#line 322
  node->column = scan_get_column();
  }
#line 327
  return (node);
}
}
#line 330 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/code.c"
void code_free_value(CodeNode *node ) 
{ 


  {
  {
#line 337
  if ((unsigned int )node->type == 11U) {
#line 337
    goto case_11;
  }
#line 337
  if ((unsigned int )node->type == 0U) {
#line 337
    goto case_11;
  }
#line 342
  if ((unsigned int )node->type == 1U) {
#line 342
    goto case_1;
  }
#line 347
  if ((unsigned int )node->type == 3U) {
#line 347
    goto case_3;
  }
#line 347
  if ((unsigned int )node->type == 2U) {
#line 347
    goto case_3;
  }
#line 349
  if ((unsigned int )node->type == 4U) {
#line 349
    goto case_4;
  }
#line 355
  if ((unsigned int )node->type == 5U) {
#line 355
    goto case_5;
  }
#line 361
  if ((unsigned int )node->type == 6U) {
#line 361
    goto case_6;
  }
#line 367
  if ((unsigned int )node->type == 12U) {
#line 367
    goto case_12;
  }
#line 373
  if ((unsigned int )node->type == 9U) {
#line 373
    goto case_9;
  }
#line 380
  if ((unsigned int )node->type == 8U) {
#line 380
    goto case_8;
  }
#line 380
  if ((unsigned int )node->type == 7U) {
#line 380
    goto case_8;
  }
#line 382
  if ((unsigned int )node->type == 10U) {
#line 382
    goto case_10;
  }
#line 389
  if ((unsigned int )node->type == 14U) {
#line 389
    goto case_14;
  }
#line 389
  if ((unsigned int )node->type == 13U) {
#line 389
    goto case_14;
  }
#line 391
  if ((unsigned int )node->type == 15U) {
#line 391
    goto case_15;
  }
#line 397
  if ((unsigned int )node->type == 16U) {
#line 397
    goto case_16;
  }
#line 403
  if ((unsigned int )node->type == 17U) {
#line 403
    goto case_17;
  }
#line 405
  if ((unsigned int )node->type == 18U) {
#line 405
    goto case_18;
  }
#line 407
  if ((unsigned int )node->type == 19U) {
#line 407
    goto case_19;
  }
#line 409
  if ((unsigned int )node->type == 20U) {
#line 409
    goto case_20;
  }
#line 413
  goto switch_default;
  case_11: /* CIL Label */ 
  case_0: /* CIL Label */ 
#line 341
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 344
  numb_free(node->value.numb);
  }
#line 345
  goto switch_break;
  case_3: /* CIL Label */ 
  case_2: /* CIL Label */ 
#line 348
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 351
  tuple_free(node->value.tuple);
#line 352
  node->value.tuple = (Tuple *)((void *)0);
#line 353
  node->type = (CodeType )0;
  }
#line 354
  goto switch_break;
  case_5: /* CIL Label */ 
  {
#line 357
  set_free(node->value.set);
#line 358
  node->value.set = (Set *)((void *)0);
#line 359
  node->type = (CodeType )0;
  }
#line 360
  goto switch_break;
  case_6: /* CIL Label */ 
  {
#line 363
  term_free(node->value.term);
#line 364
  node->value.term = (Term *)((void *)0);
#line 365
  node->type = (CodeType )0;
  }
#line 366
  goto switch_break;
  case_12: /* CIL Label */ 
  {
#line 369
  entry_free(node->value.entry);
#line 370
  node->value.entry = (Entry *)((void *)0);
#line 371
  node->type = (CodeType )0;
  }
#line 372
  goto switch_break;
  case_9: /* CIL Label */ 
  {
#line 375
  idxset_free(node->value.idxset);
#line 376
  node->value.entry = (Entry *)((void *)0);
#line 377
  node->type = (CodeType )0;
  }
#line 378
  goto switch_break;
  case_8: /* CIL Label */ 
  case_7: /* CIL Label */ 
#line 381
  goto switch_break;
  case_10: /* CIL Label */ 
  {
#line 384
  list_free(node->value.list);
#line 385
  node->value.list = (List *)((void *)0);
#line 386
  node->type = (CodeType )0;
  }
#line 387
  goto switch_break;
  case_14: /* CIL Label */ 
  case_13: /* CIL Label */ 
#line 390
  goto switch_break;
  case_15: /* CIL Label */ 
  {
#line 393
  rdef_free(node->value.rdef);
#line 394
  node->value.rdef = (RDef *)((void *)0);
#line 395
  node->type = (CodeType )0;
  }
#line 396
  goto switch_break;
  case_16: /* CIL Label */ 
  {
#line 399
  rpar_free(node->value.rpar);
#line 400
  node->value.rpar = (RPar *)((void *)0);
#line 401
  node->type = (CodeType )0;
  }
#line 402
  goto switch_break;
  case_17: /* CIL Label */ 
#line 404
  goto switch_break;
  case_18: /* CIL Label */ 
#line 406
  goto switch_break;
  case_19: /* CIL Label */ 
#line 408
  goto switch_break;
  case_20: /* CIL Label */ 
  {
#line 411
  bound_free(node->value.bound);
  }
#line 412
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 414
  abort();
  }
  switch_break: /* CIL Label */ ;
  }
#line 416
  return;
}
}
#line 418 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/code.c"
void code_free(CodeNode *node ) 
{ 
  int i ;

  {
#line 422
  i = 0;
  {
#line 422
  while (1) {
    while_continue: /* CIL Label */ ;
#line 422
    if (! (i < 8)) {
#line 422
      goto while_break;
    }
#line 423
    if ((unsigned long )node->child[i] != (unsigned long )((void *)0)) {
      {
#line 424
      code_free(node->child[i]);
      }
    }
#line 422
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 426
  code_free_value(node);
#line 428
  mem_free((void *)node, "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/code.c",
           (int const   )428);
  }
#line 429
  return;
}
}
#line 431 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/code.c"
void code_set_child(CodeNode *node , int idx , CodeNode *child ) 
{ 


  {
#line 438
  node->child[idx] = child;
#line 439
  return;
}
}
#line 441 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/code.c"
CodeType code_get_type(CodeNode const   *node ) 
{ 


  {
#line 445
  return ((CodeType )node->type);
}
}
#line 448 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/code.c"
Inst code_get_inst(CodeNode const   *node ) 
{ 


  {
#line 452
  return ((Inst )node->eval);
}
}
#line 455 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/code.c"
void code_set_root(CodeNode *node ) 
{ 


  {
#line 459
  root = node;
#line 460
  return;
}
}
#line 462 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/code.c"
CodeNode *code_get_root(void) 
{ 


  {
#line 464
  return (root);
}
}
#line 467 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/code.c"
unsigned int code_get_inst_count(void) 
{ 


  {
#line 469
  return (inst_count);
}
}
#line 472 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/code.c"
void code_clear_inst_count(void) 
{ 


  {
#line 474
  inst_count = 0U;
#line 475
  return;
}
}
#line 479
__inline static CodeNode *code_check_type(CodeNode *node , CodeType expected ) ;
#line 479 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/code.c"
static char const   * const  tname[21]  = 
#line 479
  {      (char const   */* const  */)"Error",      (char const   */* const  */)"Number",      (char const   */* const  */)"String",      (char const   */* const  */)"Name", 
        (char const   */* const  */)"Tuple",      (char const   */* const  */)"Set",      (char const   */* const  */)"Term",      (char const   */* const  */)"Bool", 
        (char const   */* const  */)"Size",      (char const   */* const  */)"IndexSet",      (char const   */* const  */)"List",      (char const   */* const  */)"Nothing", 
        (char const   */* const  */)"Entry",      (char const   */* const  */)"VarClass",      (char const   */* const  */)"ConType",      (char const   */* const  */)"ReadDefinition", 
        (char const   */* const  */)"ReadParameter",      (char const   */* const  */)"BitFlag",      (char const   */* const  */)"Symbol",      (char const   */* const  */)"Define", 
        (char const   */* const  */)"Bound"};
#line 477 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/code.c"
__inline static CodeNode *code_check_type(CodeNode *node , CodeType expected ) 
{ 


  {
#line 488
  if ((unsigned int )node->type != (unsigned int )expected) {
    {
#line 492
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"*** Error 159: Type error, expected %s got %s\n",
            tname[expected], tname[node->type]);
#line 494
    code_errmsg((CodeNode const   *)node);
#line 495
    zpl_exit(1);
    }
  }
#line 497
  return (node);
}
}
#line 500 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/code.c"
void code_errmsg(CodeNode const   *node ) 
{ 
  int tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;

  {
  {
#line 502
  tmp = stmt_get_lineno((Stmt const   *)node->stmt);
#line 502
  tmp___0 = stmt_get_filename((Stmt const   *)node->stmt);
#line 502
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"*** File: %s Line %d\n",
          tmp___0, tmp);
#line 506
  tmp___1 = stmt_get_text((Stmt const   *)node->stmt);
#line 506
  show_source(stderr, tmp___1, (int )node->column);
  }
#line 508
  if (verbose >= 3) {
    {
#line 509
    local_print_all(stderr);
    }
  }
#line 510
  return;
}
}
#line 512 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/code.c"
__inline CodeNode *code_eval(CodeNode *node ) 
{ 
  CodeNode *tmp ;

  {
  {
#line 516
  inst_count ++;
#line 520
  tmp = (*(node->eval))(node);
  }
#line 520
  return (tmp);
}
}
#line 526 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/code.c"
static Inst const   prunable[32]  = 
#line 526
  {      (Inst const   )(& i_expr_abs),      (Inst const   )(& i_expr_sgn),      (Inst const   )(& i_expr_add),      (Inst const   )(& i_expr_card), 
        (Inst const   )(& i_expr_ceil),      (Inst const   )(& i_expr_div),      (Inst const   )(& i_expr_exp),      (Inst const   )(& i_expr_sqrt), 
        (Inst const   )(& i_expr_fac),      (Inst const   )(& i_expr_floor),      (Inst const   )(& i_expr_if_else),      (Inst const   )(& i_expr_intdiv), 
        (Inst const   )(& i_expr_length),      (Inst const   )(& i_expr_ln),      (Inst const   )(& i_expr_log),      (Inst const   )(& i_expr_ord), 
        (Inst const   )(& i_expr_prod),      (Inst const   )(& i_expr_round),      (Inst const   )(& i_expr_sum),      (Inst const   )(& i_expr_max), 
        (Inst const   )(& i_expr_max2),      (Inst const   )(& i_expr_sglmax),      (Inst const   )(& i_expr_min),      (Inst const   )(& i_expr_min2), 
        (Inst const   )(& i_expr_sglmin),      (Inst const   )(& i_expr_mul),      (Inst const   )(& i_expr_mod),      (Inst const   )(& i_expr_neg), 
        (Inst const   )(& i_expr_pow),      (Inst const   )(& i_expr_sub),      (Inst const   )(& i_expr_substr),      (Inst const   )((void *)0)};
#line 524 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/code.c"
Bool code_prune_tree(CodeNode *node ) 
{ 
  Bool is_all_const ;
  int i ;
  Bool is_const ;
  Bool tmp ;
  int tmp___0 ;

  {
#line 535
  is_all_const = 1;
#line 538
  if ((unsigned long )node->eval == (unsigned long )(& i_nop)) {
#line 539
    return (1);
  }
#line 541
  i = 0;
  {
#line 541
  while (1) {
    while_continue: /* CIL Label */ ;
#line 541
    if (! (i < 8)) {
#line 541
      goto while_break;
    }
#line 543
    if ((unsigned long )node->child[i] != (unsigned long )((void *)0)) {
      {
#line 545
      tmp = code_prune_tree(node->child[i]);
#line 545
      is_const = tmp;
      }
#line 550
      if (is_all_const) {
#line 550
        if (is_const) {
#line 550
          tmp___0 = 1;
        } else {
#line 550
          tmp___0 = 0;
        }
      } else {
#line 550
        tmp___0 = 0;
      }
#line 550
      is_all_const = tmp___0;
    }
#line 541
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 554
  if (is_all_const) {
#line 556
    i = 0;
    {
#line 556
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 556
      if (! ((unsigned long )prunable[i] != (unsigned long )((CodeNode *(*)(CodeNode *self ))0))) {
#line 556
        goto while_break___0;
      }
#line 557
      if ((unsigned long )prunable[i] == (unsigned long )node->eval) {
#line 558
        goto while_break___0;
      }
#line 556
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 560
    if ((unsigned long )prunable[i] == (unsigned long )((CodeNode *(*)(CodeNode *self ))0)) {
#line 561
      return (0);
    }
    {
#line 563
    code_eval(node);
#line 565
    i = 0;
    }
    {
#line 565
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 565
      if (! (i < 8)) {
#line 565
        goto while_break___1;
      }
#line 567
      if ((unsigned long )node->child[i] != (unsigned long )((void *)0)) {
        {
#line 569
        code_free(node->child[i]);
#line 570
        node->child[i] = (CodeNode *)((void *)0);
        }
      }
#line 565
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 573
    node->eval = & i_nop;
  }
#line 575
  return (is_all_const);
}
}
#line 584 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/code.c"
CodeNode *code_get_child(CodeNode const   *node , int no ) 
{ 


  {
#line 591
  return (node->child[no]);
}
}
#line 594 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/code.c"
__inline Numb const   *code_get_numb(CodeNode *node ) 
{ 
  CodeNode *tmp ;

  {
  {
#line 596
  tmp = code_check_type(node, (CodeType )1);
  }
#line 596
  return ((Numb const   *)tmp->value.numb);
}
}
#line 599 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/code.c"
__inline char const   *code_get_strg(CodeNode *node ) 
{ 
  CodeNode *tmp ;

  {
  {
#line 601
  tmp = code_check_type(node, (CodeType )2);
  }
#line 601
  return (tmp->value.strg);
}
}
#line 604 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/code.c"
__inline char const   *code_get_name(CodeNode *node ) 
{ 
  CodeNode *tmp ;

  {
  {
#line 606
  tmp = code_check_type(node, (CodeType )3);
  }
#line 606
  return (tmp->value.name);
}
}
#line 609 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/code.c"
__inline Tuple const   *code_get_tuple(CodeNode *node ) 
{ 
  CodeNode *tmp ;

  {
  {
#line 611
  tmp = code_check_type(node, (CodeType )4);
  }
#line 611
  return ((Tuple const   *)tmp->value.tuple);
}
}
#line 614 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/code.c"
__inline Set const   *code_get_set(CodeNode *node ) 
{ 
  CodeNode *tmp ;

  {
  {
#line 616
  tmp = code_check_type(node, (CodeType )5);
  }
#line 616
  return ((Set const   *)tmp->value.set);
}
}
#line 619 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/code.c"
__inline IdxSet const   *code_get_idxset(CodeNode *node ) 
{ 
  CodeNode *tmp ;

  {
  {
#line 621
  tmp = code_check_type(node, (CodeType )9);
  }
#line 621
  return ((IdxSet const   *)tmp->value.idxset);
}
}
#line 624 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/code.c"
__inline Entry const   *code_get_entry(CodeNode *node ) 
{ 
  CodeNode *tmp ;

  {
  {
#line 626
  tmp = code_check_type(node, (CodeType )12);
  }
#line 626
  return ((Entry const   *)tmp->value.entry);
}
}
#line 629 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/code.c"
__inline Term const   *code_get_term(CodeNode *node ) 
{ 
  CodeNode *tmp ;

  {
  {
#line 631
  tmp = code_check_type(node, (CodeType )6);
  }
#line 631
  return ((Term const   *)tmp->value.term);
}
}
#line 634 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/code.c"
__inline int code_get_size(CodeNode *node ) 
{ 
  CodeNode *tmp ;

  {
  {
#line 636
  tmp = code_check_type(node, (CodeType )8);
  }
#line 636
  return (tmp->value.size);
}
}
#line 639 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/code.c"
__inline Bool code_get_bool(CodeNode *node ) 
{ 
  CodeNode *tmp ;

  {
  {
#line 641
  tmp = code_check_type(node, (CodeType )7);
  }
#line 641
  return (tmp->value.bool);
}
}
#line 644 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/code.c"
__inline List const   *code_get_list(CodeNode *node ) 
{ 
  CodeNode *tmp ;

  {
  {
#line 646
  tmp = code_check_type(node, (CodeType )10);
  }
#line 646
  return ((List const   *)tmp->value.list);
}
}
#line 649 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/code.c"
__inline VarClass code_get_varclass(CodeNode *node ) 
{ 
  CodeNode *tmp ;

  {
  {
#line 651
  tmp = code_check_type(node, (CodeType )13);
  }
#line 651
  return (tmp->value.varclass);
}
}
#line 654 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/code.c"
__inline ConType code_get_contype(CodeNode *node ) 
{ 
  CodeNode *tmp ;

  {
  {
#line 656
  tmp = code_check_type(node, (CodeType )14);
  }
#line 656
  return (tmp->value.contype);
}
}
#line 659 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/code.c"
__inline RDef const   *code_get_rdef(CodeNode *node ) 
{ 
  CodeNode *tmp ;

  {
  {
#line 661
  tmp = code_check_type(node, (CodeType )15);
  }
#line 661
  return ((RDef const   *)tmp->value.rdef);
}
}
#line 664 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/code.c"
__inline RPar const   *code_get_rpar(CodeNode *node ) 
{ 
  CodeNode *tmp ;

  {
  {
#line 666
  tmp = code_check_type(node, (CodeType )16);
  }
#line 666
  return ((RPar const   *)tmp->value.rpar);
}
}
#line 669 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/code.c"
__inline unsigned int code_get_bits(CodeNode *node ) 
{ 
  CodeNode *tmp ;

  {
  {
#line 671
  tmp = code_check_type(node, (CodeType )17);
  }
#line 671
  return (tmp->value.bits);
}
}
#line 674 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/code.c"
__inline Symbol *code_get_symbol(CodeNode *node ) 
{ 
  CodeNode *tmp ;

  {
  {
#line 676
  tmp = code_check_type(node, (CodeType )18);
  }
#line 676
  return (tmp->value.sym);
}
}
#line 679 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/code.c"
__inline Define *code_get_define(CodeNode *node ) 
{ 
  CodeNode *tmp ;

  {
  {
#line 681
  tmp = code_check_type(node, (CodeType )19);
  }
#line 681
  return (tmp->value.def);
}
}
#line 684 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/code.c"
__inline Bound const   *code_get_bound(CodeNode *node ) 
{ 
  CodeNode *tmp ;

  {
  {
#line 686
  tmp = code_check_type(node, (CodeType )20);
  }
#line 686
  return ((Bound const   *)tmp->value.bound);
}
}
#line 693 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/code.c"
void code_value_numb(CodeNode *node , Numb *numb ) 
{ 


  {
  {
#line 697
  code_free_value(node);
#line 699
  node->type = (CodeType )1;
#line 700
  node->value.numb = numb;
  }
#line 701
  return;
}
}
#line 703 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/code.c"
void code_value_strg(CodeNode *node , char const   *strg ) 
{ 


  {
  {
#line 708
  code_free_value(node);
#line 710
  node->type = (CodeType )2;
#line 711
  node->value.strg = strg;
  }
#line 712
  return;
}
}
#line 714 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/code.c"
void code_value_name(CodeNode *node , char const   *name ) 
{ 


  {
  {
#line 719
  code_free_value(node);
#line 721
  node->type = (CodeType )3;
#line 722
  node->value.name = name;
  }
#line 723
  return;
}
}
#line 725 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/code.c"
void code_value_tuple(CodeNode *node , Tuple *tuple ) 
{ 


  {
  {
#line 730
  code_free_value(node);
#line 732
  node->type = (CodeType )4;
#line 733
  node->value.tuple = tuple;
  }
#line 734
  return;
}
}
#line 736 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/code.c"
void code_value_set(CodeNode *node , Set *set ) 
{ 


  {
  {
#line 741
  code_free_value(node);
#line 743
  node->type = (CodeType )5;
#line 744
  node->value.set = set;
  }
#line 745
  return;
}
}
#line 747 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/code.c"
void code_value_idxset(CodeNode *node , IdxSet *idxset ) 
{ 


  {
  {
#line 752
  code_free_value(node);
#line 754
  node->type = (CodeType )9;
#line 755
  node->value.idxset = idxset;
  }
#line 756
  return;
}
}
#line 758 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/code.c"
void code_value_entry(CodeNode *node , Entry *entry ) 
{ 


  {
  {
#line 763
  code_free_value(node);
#line 765
  node->type = (CodeType )12;
#line 766
  node->value.entry = entry;
  }
#line 767
  return;
}
}
#line 769 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/code.c"
void code_value_term(CodeNode *node , Term *term ) 
{ 


  {
  {
#line 774
  code_free_value(node);
#line 776
  node->type = (CodeType )6;
#line 777
  node->value.term = term;
  }
#line 778
  return;
}
}
#line 780 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/code.c"
Term *code_value_steal_term(CodeNode *node , int no ) 
{ 
  CodeNode *child ;
  CodeNode *tmp ;

  {
  {
#line 782
  tmp = code_get_child((CodeNode const   *)node, no);
#line 782
  child = tmp;
#line 787
  code_free_value(node);
#line 789
  node->type = (CodeType )6;
#line 790
  node->value.term = child->value.term;
#line 792
  child->type = (CodeType )0;
#line 793
  child->value.term = (Term *)((void *)0);
  }
#line 795
  return (node->value.term);
}
}
#line 799 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/code.c"
void code_value_bool(CodeNode *node , Bool bval ) 
{ 


  {
  {
#line 803
  code_free_value(node);
#line 805
  node->type = (CodeType )7;
#line 806
  node->value.bool = bval;
  }
#line 807
  return;
}
}
#line 809 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/code.c"
void code_value_size(CodeNode *node , int size ) 
{ 


  {
  {
#line 813
  code_free_value(node);
#line 815
  node->type = (CodeType )8;
#line 816
  node->value.size = size;
  }
#line 817
  return;
}
}
#line 819 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/code.c"
void code_value_list(CodeNode *node , List *list ) 
{ 


  {
  {
#line 824
  code_free_value(node);
#line 826
  node->type = (CodeType )10;
#line 827
  node->value.list = list;
  }
#line 828
  return;
}
}
#line 830 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/code.c"
void code_value_varclass(CodeNode *node , VarClass varclass ) 
{ 


  {
  {
#line 834
  code_free_value(node);
#line 836
  node->type = (CodeType )13;
#line 837
  node->value.varclass = varclass;
  }
#line 838
  return;
}
}
#line 840 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/code.c"
void code_value_contype(CodeNode *node , ConType contype ) 
{ 


  {
  {
#line 844
  code_free_value(node);
#line 846
  node->type = (CodeType )14;
#line 847
  node->value.contype = contype;
  }
#line 848
  return;
}
}
#line 850 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/code.c"
void code_value_rdef(CodeNode *node , RDef *rdef ) 
{ 


  {
  {
#line 855
  code_free_value(node);
#line 857
  node->type = (CodeType )15;
#line 858
  node->value.rdef = rdef;
  }
#line 859
  return;
}
}
#line 861 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/code.c"
void code_value_rpar(CodeNode *node , RPar *rpar ) 
{ 


  {
  {
#line 866
  code_free_value(node);
#line 868
  node->type = (CodeType )16;
#line 869
  node->value.rpar = rpar;
  }
#line 870
  return;
}
}
#line 872 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/code.c"
void code_value_bits(CodeNode *node , unsigned int bits ) 
{ 


  {
  {
#line 876
  code_free_value(node);
#line 878
  node->type = (CodeType )17;
#line 879
  node->value.bits = bits;
  }
#line 880
  return;
}
}
#line 882 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/code.c"
void code_value_bound(CodeNode *node , Bound *bound ) 
{ 


  {
  {
#line 886
  code_free_value(node);
#line 888
  node->type = (CodeType )20;
#line 889
  node->value.bound = bound;
  }
#line 890
  return;
}
}
#line 892 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/code.c"
void code_value_void(CodeNode *node ) 
{ 


  {
  {
#line 896
  code_free_value(node);
#line 898
  node->type = (CodeType )11;
  }
#line 899
  return;
}
}
#line 901 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/code.c"
void code_copy_value(CodeNode *dst , CodeNode const   *src ) 
{ 


  {
  {
#line 906
  code_free_value(dst);
  }
  {
#line 910
  if ((unsigned int const   )src->type == 1U) {
#line 910
    goto case_1;
  }
#line 913
  if ((unsigned int const   )src->type == 2U) {
#line 913
    goto case_2;
  }
#line 916
  if ((unsigned int const   )src->type == 3U) {
#line 916
    goto case_3;
  }
#line 919
  if ((unsigned int const   )src->type == 4U) {
#line 919
    goto case_4;
  }
#line 922
  if ((unsigned int const   )src->type == 5U) {
#line 922
    goto case_5;
  }
#line 925
  if ((unsigned int const   )src->type == 9U) {
#line 925
    goto case_9;
  }
#line 928
  if ((unsigned int const   )src->type == 12U) {
#line 928
    goto case_12;
  }
#line 931
  if ((unsigned int const   )src->type == 6U) {
#line 931
    goto case_6;
  }
#line 934
  if ((unsigned int const   )src->type == 7U) {
#line 934
    goto case_7;
  }
#line 937
  if ((unsigned int const   )src->type == 8U) {
#line 937
    goto case_8;
  }
#line 940
  if ((unsigned int const   )src->type == 10U) {
#line 940
    goto case_10;
  }
#line 943
  if ((unsigned int const   )src->type == 13U) {
#line 943
    goto case_13;
  }
#line 946
  if ((unsigned int const   )src->type == 14U) {
#line 946
    goto case_14;
  }
#line 949
  if ((unsigned int const   )src->type == 15U) {
#line 949
    goto case_15;
  }
#line 952
  if ((unsigned int const   )src->type == 16U) {
#line 952
    goto case_16;
  }
#line 955
  if ((unsigned int const   )src->type == 17U) {
#line 955
    goto case_17;
  }
#line 958
  if ((unsigned int const   )src->type == 20U) {
#line 958
    goto case_20;
  }
#line 961
  if ((unsigned int const   )src->type == 11U) {
#line 961
    goto case_11;
  }
#line 963
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 911
  dst->value.numb = numb_copy((Numb const   *)src->value.numb);
  }
#line 912
  goto switch_break;
  case_2: /* CIL Label */ 
#line 914
  dst->value.strg = (char const   *)src->value.strg;
#line 915
  goto switch_break;
  case_3: /* CIL Label */ 
#line 917
  dst->value.name = (char const   *)src->value.name;
#line 918
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 920
  dst->value.tuple = tuple_copy((Tuple const   *)src->value.tuple);
  }
#line 921
  goto switch_break;
  case_5: /* CIL Label */ 
  {
#line 923
  dst->value.set = set_copy((Set const   *)src->value.set);
  }
#line 924
  goto switch_break;
  case_9: /* CIL Label */ 
  {
#line 926
  dst->value.idxset = idxset_copy((IdxSet const   *)src->value.idxset);
  }
#line 927
  goto switch_break;
  case_12: /* CIL Label */ 
  {
#line 929
  dst->value.entry = entry_copy((Entry const   *)src->value.entry);
  }
#line 930
  goto switch_break;
  case_6: /* CIL Label */ 
  {
#line 932
  dst->value.term = term_copy((Term const   *)src->value.term);
  }
#line 933
  goto switch_break;
  case_7: /* CIL Label */ 
#line 935
  dst->value.bool = (Bool )src->value.bool;
#line 936
  goto switch_break;
  case_8: /* CIL Label */ 
#line 938
  dst->value.size = (int )src->value.size;
#line 939
  goto switch_break;
  case_10: /* CIL Label */ 
  {
#line 941
  dst->value.list = list_copy((List const   *)src->value.list);
  }
#line 942
  goto switch_break;
  case_13: /* CIL Label */ 
#line 944
  dst->value.varclass = (VarClass )src->value.varclass;
#line 945
  goto switch_break;
  case_14: /* CIL Label */ 
#line 947
  dst->value.contype = (ConType )src->value.contype;
#line 948
  goto switch_break;
  case_15: /* CIL Label */ 
  {
#line 950
  dst->value.rdef = rdef_copy((RDef const   *)src->value.rdef);
  }
#line 951
  goto switch_break;
  case_16: /* CIL Label */ 
  {
#line 953
  dst->value.rpar = rpar_copy((RPar const   *)src->value.rpar);
  }
#line 954
  goto switch_break;
  case_17: /* CIL Label */ 
#line 956
  dst->value.bits = (unsigned int )src->value.bits;
#line 957
  goto switch_break;
  case_20: /* CIL Label */ 
  {
#line 959
  dst->value.bound = bound_copy((Bound const   *)src->value.bound);
  }
#line 960
  goto switch_break;
  case_11: /* CIL Label */ 
#line 962
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 964
  abort();
  }
  switch_break: /* CIL Label */ ;
  }
#line 966
  dst->type = (CodeType )src->type;
#line 967
  return;
}
}
#line 973 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/code.c"
CodeNode *code_eval_child(CodeNode const   *node , int no ) 
{ 
  CodeNode *tmp ;
  CodeNode *tmp___0 ;

  {
  {
#line 975
  tmp = code_get_child(node, no);
#line 975
  tmp___0 = code_eval(tmp);
  }
#line 975
  return (tmp___0);
}
}
#line 978 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/code.c"
Numb const   *code_eval_child_numb(CodeNode const   *node , int no ) 
{ 
  CodeNode *tmp ;
  CodeNode *tmp___0 ;
  Numb const   *tmp___1 ;

  {
  {
#line 980
  tmp = code_get_child(node, no);
#line 980
  tmp___0 = code_eval(tmp);
#line 980
  tmp___1 = code_get_numb(tmp___0);
  }
#line 980
  return (tmp___1);
}
}
#line 983 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/code.c"
char const   *code_eval_child_strg(CodeNode const   *node , int no ) 
{ 
  CodeNode *tmp ;
  CodeNode *tmp___0 ;
  char const   *tmp___1 ;

  {
  {
#line 985
  tmp = code_get_child(node, no);
#line 985
  tmp___0 = code_eval(tmp);
#line 985
  tmp___1 = code_get_strg(tmp___0);
  }
#line 985
  return (tmp___1);
}
}
#line 988 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/code.c"
char const   *code_eval_child_name(CodeNode const   *node , int no ) 
{ 
  CodeNode *tmp ;
  CodeNode *tmp___0 ;
  char const   *tmp___1 ;

  {
  {
#line 990
  tmp = code_get_child(node, no);
#line 990
  tmp___0 = code_eval(tmp);
#line 990
  tmp___1 = code_get_name(tmp___0);
  }
#line 990
  return (tmp___1);
}
}
#line 993 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/code.c"
Tuple const   *code_eval_child_tuple(CodeNode const   *node , int no ) 
{ 
  CodeNode *tmp ;
  CodeNode *tmp___0 ;
  Tuple const   *tmp___1 ;

  {
  {
#line 995
  tmp = code_get_child(node, no);
#line 995
  tmp___0 = code_eval(tmp);
#line 995
  tmp___1 = code_get_tuple(tmp___0);
  }
#line 995
  return (tmp___1);
}
}
#line 998 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/code.c"
Set const   *code_eval_child_set(CodeNode const   *node , int no ) 
{ 
  CodeNode *tmp ;
  CodeNode *tmp___0 ;
  Set const   *tmp___1 ;

  {
  {
#line 1000
  tmp = code_get_child(node, no);
#line 1000
  tmp___0 = code_eval(tmp);
#line 1000
  tmp___1 = code_get_set(tmp___0);
  }
#line 1000
  return (tmp___1);
}
}
#line 1003 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/code.c"
IdxSet const   *code_eval_child_idxset(CodeNode const   *node , int no ) 
{ 
  CodeNode *tmp ;
  CodeNode *tmp___0 ;
  IdxSet const   *tmp___1 ;

  {
  {
#line 1005
  tmp = code_get_child(node, no);
#line 1005
  tmp___0 = code_eval(tmp);
#line 1005
  tmp___1 = code_get_idxset(tmp___0);
  }
#line 1005
  return (tmp___1);
}
}
#line 1008 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/code.c"
Entry const   *code_eval_child_entry(CodeNode const   *node , int no ) 
{ 
  CodeNode *tmp ;
  CodeNode *tmp___0 ;
  Entry const   *tmp___1 ;

  {
  {
#line 1010
  tmp = code_get_child(node, no);
#line 1010
  tmp___0 = code_eval(tmp);
#line 1010
  tmp___1 = code_get_entry(tmp___0);
  }
#line 1010
  return (tmp___1);
}
}
#line 1013 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/code.c"
Term const   *code_eval_child_term(CodeNode const   *node , int no ) 
{ 
  CodeNode *tmp ;
  CodeNode *tmp___0 ;
  Term const   *tmp___1 ;

  {
  {
#line 1015
  tmp = code_get_child(node, no);
#line 1015
  tmp___0 = code_eval(tmp);
#line 1015
  tmp___1 = code_get_term(tmp___0);
  }
#line 1015
  return (tmp___1);
}
}
#line 1018 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/code.c"
int code_eval_child_size(CodeNode const   *node , int no ) 
{ 
  CodeNode *tmp ;
  CodeNode *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 1020
  tmp = code_get_child(node, no);
#line 1020
  tmp___0 = code_eval(tmp);
#line 1020
  tmp___1 = code_get_size(tmp___0);
  }
#line 1020
  return (tmp___1);
}
}
#line 1023 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/code.c"
Bool code_eval_child_bool(CodeNode const   *node , int no ) 
{ 
  CodeNode *tmp ;
  CodeNode *tmp___0 ;
  Bool tmp___1 ;

  {
  {
#line 1025
  tmp = code_get_child(node, no);
#line 1025
  tmp___0 = code_eval(tmp);
#line 1025
  tmp___1 = code_get_bool(tmp___0);
  }
#line 1025
  return (tmp___1);
}
}
#line 1028 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/code.c"
List const   *code_eval_child_list(CodeNode const   *node , int no ) 
{ 
  CodeNode *tmp ;
  CodeNode *tmp___0 ;
  List const   *tmp___1 ;

  {
  {
#line 1030
  tmp = code_get_child(node, no);
#line 1030
  tmp___0 = code_eval(tmp);
#line 1030
  tmp___1 = code_get_list(tmp___0);
  }
#line 1030
  return (tmp___1);
}
}
#line 1033 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/code.c"
VarClass code_eval_child_varclass(CodeNode const   *node , int no ) 
{ 
  CodeNode *tmp ;
  CodeNode *tmp___0 ;
  VarClass tmp___1 ;

  {
  {
#line 1035
  tmp = code_get_child(node, no);
#line 1035
  tmp___0 = code_eval(tmp);
#line 1035
  tmp___1 = code_get_varclass(tmp___0);
  }
#line 1035
  return (tmp___1);
}
}
#line 1038 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/code.c"
ConType code_eval_child_contype(CodeNode const   *node , int no ) 
{ 
  CodeNode *tmp ;
  CodeNode *tmp___0 ;
  ConType tmp___1 ;

  {
  {
#line 1040
  tmp = code_get_child(node, no);
#line 1040
  tmp___0 = code_eval(tmp);
#line 1040
  tmp___1 = code_get_contype(tmp___0);
  }
#line 1040
  return (tmp___1);
}
}
#line 1043 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/code.c"
RDef const   *code_eval_child_rdef(CodeNode const   *node , int no ) 
{ 
  CodeNode *tmp ;
  CodeNode *tmp___0 ;
  RDef const   *tmp___1 ;

  {
  {
#line 1045
  tmp = code_get_child(node, no);
#line 1045
  tmp___0 = code_eval(tmp);
#line 1045
  tmp___1 = code_get_rdef(tmp___0);
  }
#line 1045
  return (tmp___1);
}
}
#line 1048 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/code.c"
RPar const   *code_eval_child_rpar(CodeNode const   *node , int no ) 
{ 
  CodeNode *tmp ;
  CodeNode *tmp___0 ;
  RPar const   *tmp___1 ;

  {
  {
#line 1050
  tmp = code_get_child(node, no);
#line 1050
  tmp___0 = code_eval(tmp);
#line 1050
  tmp___1 = code_get_rpar(tmp___0);
  }
#line 1050
  return (tmp___1);
}
}
#line 1053 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/code.c"
unsigned int code_eval_child_bits(CodeNode const   *node , int no ) 
{ 
  CodeNode *tmp ;
  CodeNode *tmp___0 ;
  unsigned int tmp___1 ;

  {
  {
#line 1055
  tmp = code_get_child(node, no);
#line 1055
  tmp___0 = code_eval(tmp);
#line 1055
  tmp___1 = code_get_bits(tmp___0);
  }
#line 1055
  return (tmp___1);
}
}
#line 1058 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/code.c"
Symbol *code_eval_child_symbol(CodeNode const   *node , int no ) 
{ 
  CodeNode *tmp ;
  CodeNode *tmp___0 ;
  Symbol *tmp___1 ;

  {
  {
#line 1060
  tmp = code_get_child(node, no);
#line 1060
  tmp___0 = code_eval(tmp);
#line 1060
  tmp___1 = code_get_symbol(tmp___0);
  }
#line 1060
  return (tmp___1);
}
}
#line 1063 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/code.c"
Define *code_eval_child_define(CodeNode const   *node , int no ) 
{ 
  CodeNode *tmp ;
  CodeNode *tmp___0 ;
  Define *tmp___1 ;

  {
  {
#line 1065
  tmp = code_get_child(node, no);
#line 1065
  tmp___0 = code_eval(tmp);
#line 1065
  tmp___1 = code_get_define(tmp___0);
  }
#line 1065
  return (tmp___1);
}
}
#line 1068 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/code.c"
Bound const   *code_eval_child_bound(CodeNode const   *node , int no ) 
{ 
  CodeNode *tmp ;
  CodeNode *tmp___0 ;
  Bound const   *tmp___1 ;

  {
  {
#line 1070
  tmp = code_get_child(node, no);
#line 1070
  tmp___0 = code_eval(tmp);
#line 1070
  tmp___1 = code_get_bound(tmp___0);
  }
#line 1070
  return (tmp___1);
}
}
#line 47 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/define.h"
Define *define_new(char const   *name , DefineType type ) ;
#line 49
void define_set_param(Define *def , Tuple *param ) ;
#line 51
void define_set_code(Define *def , CodeNode *code ) ;
#line 52
void define_exit(void) ;
#line 54
Bool define_is_valid(Define const   *def ) ;
#line 56
Define *define_lookup(char const   *name ) ;
#line 58
char const   *define_get_name(Define const   *def ) ;
#line 60
DefineType define_get_type(Define const   *def ) ;
#line 62
Tuple const   *define_get_param(Define const   *def ) ;
#line 64
CodeNode *define_get_code(Define const   *def ) ;
#line 56 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/define.c"
static Define anchor  =    {"", (DefineType )0, (Tuple *)((void *)0), (CodeNode *)((void *)0), (Define *)((void *)0)};
#line 59 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/define.c"
Define *define_new(char const   *name , DefineType type ) 
{ 
  Define *def ;
  void *tmp ;

  {
  {
#line 69
  tmp = mem_calloc((size_t )1, sizeof(*def), "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/define.c",
                   (int const   )69);
#line 69
  def = (Define *)tmp;
#line 73
  def->name = name;
#line 74
  def->type = type;
#line 75
  def->param = (Tuple *)((void *)0);
#line 76
  def->code = (CodeNode *)((void *)0);
#line 77
  def->next = anchor.next;
#line 78
  anchor.next = def;
  }
#line 83
  return (def);
}
}
#line 86 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/define.c"
void define_set_param(Define *def , Tuple *param ) 
{ 


  {
#line 93
  def->param = param;
#line 94
  return;
}
}
#line 96 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/define.c"
void define_set_code(Define *def , CodeNode *code ) 
{ 


  {
#line 103
  def->code = code;
#line 104
  return;
}
}
#line 106 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/define.c"
void define_exit(void) 
{ 
  Define *q ;
  Define *p ;

  {
#line 111
  p = anchor.next;
  {
#line 111
  while (1) {
    while_continue: /* CIL Label */ ;
#line 111
    if (! ((unsigned long )p != (unsigned long )((void *)0))) {
#line 111
      goto while_break;
    }
    {
#line 117
    tuple_free(p->param);
#line 119
    q = p->next;
#line 121
    mem_free((void *)p, "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/define.c",
             (int const   )121);
#line 111
    p = q;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 123
  anchor.next = (Define *)((void *)0);
#line 124
  return;
}
}
#line 126 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/define.c"
Bool define_is_valid(Define const   *def ) 
{ 


  {
#line 128
  if ((unsigned long )def == (unsigned long )((void *)0)) {
#line 129
    return (0);
  }
#line 133
  return (1);
}
}
#line 136 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/define.c"
Define *define_lookup(char const   *name ) 
{ 
  Define *def ;
  int tmp ;

  {
#line 142
  def = anchor.next;
  {
#line 142
  while (1) {
    while_continue: /* CIL Label */ ;
#line 142
    if (! ((unsigned long )def != (unsigned long )((void *)0))) {
#line 142
      goto while_break;
    }
    {
#line 143
    tmp = strcmp(def->name, name);
    }
#line 143
    if (! tmp) {
#line 144
      goto while_break;
    }
#line 142
    def = def->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 146
  return (def);
}
}
#line 149 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/define.c"
char const   *define_get_name(Define const   *def ) 
{ 


  {
#line 153
  return ((char const   *)def->name);
}
}
#line 156 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/define.c"
DefineType define_get_type(Define const   *def ) 
{ 


  {
#line 160
  return ((DefineType )def->type);
}
}
#line 163 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/define.c"
Tuple const   *define_get_param(Define const   *def ) 
{ 


  {
#line 167
  return ((Tuple const   *)def->param);
}
}
#line 170 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/define.c"
CodeNode *define_get_code(Define const   *def ) 
{ 


  {
#line 174
  return ((CodeNode *)def->code);
}
}
#line 48 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/ratlpfwrite.c"
static void permute(int size , void **tab ) 
{ 
  int i ;
  void *t ;
  int a ;
  int tmp ;
  int b ;
  int tmp___0 ;

  {
#line 52
  if (size < 3) {
#line 53
    return;
  }
#line 57
  i = 0;
  {
#line 57
  while (1) {
    while_continue: /* CIL Label */ ;
#line 57
    if (! (i < size)) {
#line 57
      goto while_break;
    }
    {
#line 60
    tmp = rand_get_range(0, size - 1);
#line 60
    a = tmp;
#line 61
    tmp___0 = rand_get_range(0, size - 1);
#line 61
    b = tmp___0;
#line 68
    t = *(tab + a);
#line 69
    *(tab + a) = *(tab + b);
#line 70
    *(tab + b) = t;
#line 57
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 72
  return;
}
}
#line 74 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/ratlpfwrite.c"
static void write_val(FILE *fp , LpFormat format , Bool force_sign , __mpq_struct * const  val ) 
{ 
  double tmp ;
  char const   *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 80
  if ((unsigned int )format == 5U) {
#line 80
    goto case_5;
  }
#line 80
  if ((unsigned int )format == 4U) {
#line 80
    goto case_5;
  }
#line 80
  if ((unsigned int )format == 1U) {
#line 80
    goto case_5;
  }
#line 83
  if ((unsigned int )format == 2U) {
#line 83
    goto case_2;
  }
#line 89
  goto switch_default;
  case_5: /* CIL Label */ 
  case_4: /* CIL Label */ 
  case_1: /* CIL Label */ 
  {
#line 81
  tmp = __gmpq_get_d((mpq_srcptr )val);
  }
#line 81
  if (force_sign) {
#line 81
    tmp___0 = "%+.15g";
  } else {
#line 81
    tmp___0 = "%.15g";
  }
  {
#line 81
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)tmp___0, tmp);
  }
#line 82
  goto switch_break;
  case_2: /* CIL Label */ 
#line 84
  if (force_sign) {
#line 84
    if (val->_mp_num._mp_size < 0) {
#line 84
      tmp___1 = -1;
    } else {
#line 84
      tmp___1 = val->_mp_num._mp_size > 0;
    }
#line 84
    if (tmp___1 > 0) {
      {
#line 85
      fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"+");
      }
    }
  }
  {
#line 87
  __gmpq_out_str(fp, 10, (mpq_srcptr )val);
  }
#line 88
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 90
  abort();
  }
  switch_break: /* CIL Label */ ;
  }
#line 92
  return;
}
}
#line 94 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/ratlpfwrite.c"
static void write_lhs(FILE *fp , LpFormat format , Con const   *con , ConType type ) 
{ 


  {
  {
#line 103
  if ((unsigned int )type == 4U) {
#line 103
    goto case_4;
  }
#line 103
  if ((unsigned int )type == 1U) {
#line 103
    goto case_4;
  }
#line 103
  if ((unsigned int )type == 2U) {
#line 103
    goto case_4;
  }
#line 105
  if ((unsigned int )type == 3U) {
#line 105
    goto case_3;
  }
#line 109
  goto switch_default;
  case_4: /* CIL Label */ 
  case_1: /* CIL Label */ 
  case_2: /* CIL Label */ 
#line 104
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 106
  write_val(fp, format, 0, (__mpq_struct */* const  */)(con->lhs));
#line 107
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" <= ");
  }
#line 108
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 110
  abort();
  }
  switch_break: /* CIL Label */ ;
  }
#line 112
  return;
}
}
#line 114 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/ratlpfwrite.c"
static void write_rhs(FILE *fp , LpFormat format , Con const   *con , ConType type ) 
{ 


  {
  {
#line 122
  if ((unsigned int )type == 3U) {
#line 122
    goto case_3;
  }
#line 122
  if ((unsigned int )type == 2U) {
#line 122
    goto case_3;
  }
#line 126
  if ((unsigned int )type == 1U) {
#line 126
    goto case_1;
  }
#line 130
  if ((unsigned int )type == 4U) {
#line 130
    goto case_4;
  }
#line 134
  goto switch_default;
  case_3: /* CIL Label */ 
  case_2: /* CIL Label */ 
  {
#line 123
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" <= ");
#line 124
  write_val(fp, format, 0, (__mpq_struct */* const  */)(con->rhs));
  }
#line 125
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 127
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" >= ");
#line 128
  write_val(fp, format, 0, (__mpq_struct */* const  */)(con->lhs));
  }
#line 129
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 131
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" = ");
#line 132
  write_val(fp, format, 0, (__mpq_struct */* const  */)(con->rhs));
  }
#line 133
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 135
  abort();
  }
  switch_break: /* CIL Label */ ;
  }
  {
#line 137
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"\n");
  }
#line 138
  return;
}
}
#line 140 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/ratlpfwrite.c"
static void write_row(FILE *fp , LpFormat format , Con const   *con , char *name ,
                      int name_size ) 
{ 
  Nzo *nzo ;
  Nzo **nzotab ;
  int cnt ;
  int i ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  Qme *qme ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  Term const   *term ;
  Bool only_comment ;
  int tmp___8 ;
  Mono const   *mono ;
  Mono *tmp___9 ;
  Numb const   *coeff ;
  Numb const   *tmp___10 ;
  MFun fun ;
  MFun tmp___11 ;
  int k ;
  mpq_t t ;
  Numb const   *tmp___12 ;
  Bool tmp___13 ;
  Var *var ;
  Var *tmp___14 ;
  int j ;
  Var *tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  mpq_t t___0 ;
  char const   *tmp___19 ;
  int tmp___20 ;

  {
  {
#line 158
  tmp = mem_calloc((size_t )con->size + 1UL, sizeof(*con), "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/ratlpfwrite.c",
                   (int const   )158);
#line 158
  nzotab = (Nzo **)tmp;
#line 162
  cnt = 0;
#line 162
  nzo = (Nzo *)con->first;
  }
  {
#line 162
  while (1) {
    while_continue: /* CIL Label */ ;
#line 162
    if (! ((unsigned long )nzo != (unsigned long )((void *)0))) {
#line 162
      goto while_break;
    }
#line 163
    tmp___0 = cnt;
#line 163
    cnt ++;
#line 163
    *(nzotab + tmp___0) = nzo;
#line 162
    nzo = nzo->con_next;
  }
  while_break: /* CIL Label */ ;
  }
#line 167
  if ((unsigned int )format == 4U) {
    {
#line 168
    permute((int )con->size, (void **)nzotab);
    }
  }
#line 170
  cnt = 0;
#line 172
  i = 0;
  {
#line 172
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 172
    if (! (i < (int )con->size)) {
#line 172
      goto while_break___0;
    }
#line 174
    nzo = *(nzotab + i);
#line 176
    if ((unsigned int )format == 2U) {
#line 176
      tmp___1 = -1;
    } else {
#line 176
      tmp___1 = (nzo->var)->number;
    }
    {
#line 176
    lps_makename(name, name_size, (char const   *)(nzo->var)->name, tmp___1);
#line 178
    tmp___3 = __gmpq_equal((mpq_srcptr )(nzo->value), (mpq_srcptr )(const_one));
    }
#line 178
    if (tmp___3) {
      {
#line 179
      fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" + %s",
              name);
      }
    } else {
      {
#line 180
      tmp___2 = __gmpq_equal((mpq_srcptr )(nzo->value), (mpq_srcptr )(const_minus_one));
      }
#line 180
      if (tmp___2) {
        {
#line 181
        fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" - %s",
                name);
        }
      } else {
        {
#line 184
        fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" ");
#line 185
        write_val(fp, format, 1, (__mpq_struct */* const  */)(nzo->value));
#line 186
        fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" %s",
                name);
        }
      }
    }
#line 188
    cnt ++;
#line 188
    if (cnt % 6 == 0) {
      {
#line 189
      fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"\n ");
      }
    }
#line 172
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 191
  if ((unsigned long )con->qme_first != (unsigned long )((void *)0)) {
#line 195
    if (cnt % 6 != 0) {
      {
#line 196
      fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"\n ");
      }
    }
#line 198
    cnt = 0;
#line 200
    if ((unsigned int )format == 1U) {
      {
#line 201
      fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" + [");
      }
    } else
#line 200
    if ((unsigned int )format == 4U) {
      {
#line 201
      fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" + [");
      }
    }
#line 203
    qme = (Qme *)con->qme_first;
    {
#line 203
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 203
      if (! ((unsigned long )qme != (unsigned long )((void *)0))) {
#line 203
        goto while_break___1;
      }
#line 205
      if ((unsigned int )format == 2U) {
#line 205
        tmp___4 = -1;
      } else {
#line 205
        tmp___4 = (int )(qme->var1)->number;
      }
      {
#line 205
      lps_makename(name, name_size, (char const   *)(qme->var1)->name, tmp___4);
#line 207
      tmp___6 = __gmpq_equal((mpq_srcptr )(qme->value), (mpq_srcptr )(const_one));
      }
#line 207
      if (tmp___6) {
        {
#line 208
        fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" + %s",
                name);
        }
      } else {
        {
#line 209
        tmp___5 = __gmpq_equal((mpq_srcptr )(qme->value), (mpq_srcptr )(const_minus_one));
        }
#line 209
        if (tmp___5) {
          {
#line 210
          fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" - %s",
                  name);
          }
        } else {
          {
#line 213
          fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" ");
#line 214
          write_val(fp, format, 1, (__mpq_struct */* const  */)(qme->value));
#line 215
          fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" %s",
                  name);
          }
        }
      }
#line 218
      if ((unsigned long )qme->var1 == (unsigned long )qme->var2) {
        {
#line 219
        fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"^2");
        }
      } else {
#line 222
        if ((unsigned int )format == 2U) {
#line 222
          tmp___7 = -1;
        } else {
#line 222
          tmp___7 = (int )(qme->var2)->number;
        }
        {
#line 222
        lps_makename(name, name_size, (char const   *)(qme->var2)->name, tmp___7);
#line 224
        fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" * %s",
                name);
        }
      }
#line 226
      cnt ++;
#line 226
      if (cnt % 6 == 0) {
        {
#line 227
        fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"\n ");
        }
      }
#line 203
      qme = qme->next;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 229
    if ((unsigned int )format == 1U) {
      {
#line 231
      fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" ]\n");
#line 232
      cnt = 0;
      }
    } else
#line 229
    if ((unsigned int )format == 4U) {
      {
#line 231
      fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" ]\n");
#line 232
      cnt = 0;
      }
    }
  }
#line 235
  if ((unsigned long )con->term != (unsigned long )((void *)0)) {
#line 237
    term = (Term const   *)con->term;
#line 238
    only_comment = 0;
#line 242
    if ((unsigned int )format != 5U) {
#line 244
      if (verbose > 0) {
        {
#line 246
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"--- Warning 600: File format can only handle linear and quadratic constraints\n");
#line 247
        tmp___8 = term_get_degree(term);
#line 247
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"                 Constraint %s with degree %d ignored\n",
                con->name, tmp___8);
        }
      }
#line 250
      only_comment = 1;
    }
#line 254
    if (cnt % 6 != 0) {
      {
#line 255
      fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"\n ");
      }
    }
#line 257
    cnt = 0;
#line 259
    if (only_comment) {
      {
#line 260
      fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"\\ ");
      }
    }
#line 262
    i = 0;
    {
#line 262
    while (1) {
      while_continue___2: /* CIL Label */ ;
      {
#line 262
      tmp___20 = term_get_elements(term);
      }
#line 262
      if (! (i < tmp___20)) {
#line 262
        goto while_break___2;
      }
      {
#line 264
      tmp___9 = term_get_element(term, i);
#line 264
      mono = (Mono const   *)tmp___9;
#line 265
      tmp___10 = mono_get_coeff(mono);
#line 265
      coeff = tmp___10;
#line 266
      tmp___11 = mono_get_function(mono);
#line 266
      fun = tmp___11;
      }
#line 269
      if ((int )fun == 0) {
        {
#line 271
        tmp___12 = numb_one();
#line 271
        tmp___13 = numb_equal(coeff, tmp___12);
        }
#line 271
        if (tmp___13) {
          {
#line 272
          fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" +");
          }
        } else {
          {
#line 276
          __gmpq_init(t);
#line 277
          numb_get_mpq(coeff, (__mpq_struct *)(t));
#line 278
          fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" ");
#line 279
          write_val(fp, format, 1, (__mpq_struct */* const  */)(t));
#line 280
          __gmpq_clear(t);
          }
        }
        {
#line 282
        fputc(' ', fp);
        }
      } else {
        {
#line 288
        if ((int )fun == -2) {
#line 288
          goto case_neg_2;
        }
#line 291
        if ((int )fun == 3) {
#line 291
          goto case_3;
        }
#line 294
        if ((int )fun == 4) {
#line 294
          goto case_4;
        }
#line 297
        if ((int )fun == 5) {
#line 297
          goto case_5;
        }
#line 300
        if ((int )fun == 6) {
#line 300
          goto case_6;
        }
#line 303
        if ((int )fun == 7) {
#line 303
          goto case_7;
        }
#line 306
        if ((int )fun == 8) {
#line 306
          goto case_8;
        }
#line 309
        if ((int )fun == 9) {
#line 309
          goto case_9;
        }
#line 312
        if ((int )fun == 10) {
#line 312
          goto case_10;
        }
#line 315
        if ((int )fun == 11) {
#line 315
          goto case_11;
        }
#line 318
        if ((int )fun == 12) {
#line 318
          goto case_12;
        }
#line 323
        goto switch_default;
        case_neg_2: /* CIL Label */ 
        {
#line 289
        fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" + sqrt(");
        }
#line 290
        goto switch_break;
        case_3: /* CIL Label */ 
        {
#line 292
        fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" + log(");
        }
#line 293
        goto switch_break;
        case_4: /* CIL Label */ 
        {
#line 295
        fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" + exp(");
        }
#line 296
        goto switch_break;
        case_5: /* CIL Label */ 
        {
#line 298
        fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" + ln(");
        }
#line 299
        goto switch_break;
        case_6: /* CIL Label */ 
        {
#line 301
        fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" + sin(");
        }
#line 302
        goto switch_break;
        case_7: /* CIL Label */ 
        {
#line 304
        fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" + cos(");
        }
#line 305
        goto switch_break;
        case_8: /* CIL Label */ 
        {
#line 307
        fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" + tan(");
        }
#line 308
        goto switch_break;
        case_9: /* CIL Label */ 
        {
#line 310
        fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" + abs(");
        }
#line 311
        goto switch_break;
        case_10: /* CIL Label */ 
        {
#line 313
        fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" + sgn(");
        }
#line 314
        goto switch_break;
        case_11: /* CIL Label */ 
        {
#line 316
        fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" + pow(");
        }
#line 317
        goto switch_break;
        case_12: /* CIL Label */ 
        {
#line 319
        fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" + sgnpow(");
        }
#line 320
        goto switch_break;
        switch_default: /* CIL Label */ 
        {
#line 324
        abort();
        }
        switch_break: /* CIL Label */ ;
        }
      }
#line 328
      k = 0;
      {
#line 328
      while (1) {
        while_continue___3: /* CIL Label */ ;
        {
#line 328
        tmp___18 = mono_get_degree(mono);
        }
#line 328
        if (! (k < tmp___18)) {
#line 328
          goto while_break___3;
        }
        {
#line 330
        tmp___14 = mono_get_var(mono, k);
#line 330
        var = tmp___14;
        }
#line 333
        if (k > 0) {
          {
#line 334
          fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" * ");
          }
        }
#line 336
        j = 1;
        {
#line 336
        while (1) {
          while_continue___4: /* CIL Label */ ;
          {
#line 336
          tmp___16 = mono_get_degree(mono);
          }
#line 336
          if (! (k + j < tmp___16)) {
#line 336
            goto while_break___4;
          }
          {
#line 337
          tmp___15 = mono_get_var(mono, k + j);
          }
#line 337
          if ((unsigned long )var != (unsigned long )tmp___15) {
#line 338
            goto while_break___4;
          }
#line 336
          j ++;
        }
        while_break___4: /* CIL Label */ ;
        }
#line 340
        if ((unsigned int )format == 2U) {
#line 340
          tmp___17 = -1;
        } else {
#line 340
          tmp___17 = var->number;
        }
        {
#line 340
        lps_makename(name, name_size, (char const   *)var->name, tmp___17);
        }
#line 342
        if (j == 1) {
          {
#line 343
          fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%s",
                  name);
          }
        } else {
          {
#line 346
          fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%s^%d",
                  name, j);
#line 347
          k += j - 1;
          }
        }
#line 328
        k ++;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 350
      if ((int )fun != 0) {
#line 352
        if ((int )fun == 11) {
          {
#line 355
          __gmpq_init(t___0);
#line 356
          numb_get_mpq(coeff, (__mpq_struct *)(t___0));
#line 357
          fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" ,");
#line 358
          write_val(fp, format, 0, (__mpq_struct */* const  */)(t___0));
#line 359
          __gmpq_clear(t___0);
          }
        } else
#line 352
        if ((int )fun == 12) {
          {
#line 355
          __gmpq_init(t___0);
#line 356
          numb_get_mpq(coeff, (__mpq_struct *)(t___0));
#line 357
          fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" ,");
#line 358
          write_val(fp, format, 0, (__mpq_struct */* const  */)(t___0));
#line 359
          __gmpq_clear(t___0);
          }
        }
        {
#line 361
        fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)") ");
        }
      }
#line 363
      cnt ++;
#line 363
      if (cnt % 6 == 0) {
#line 364
        if (only_comment) {
#line 364
          tmp___19 = "\\";
        } else {
#line 364
          tmp___19 = "";
        }
        {
#line 364
        fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"\n%s ",
                tmp___19);
        }
      }
#line 262
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
  }
  {
#line 367
  mem_free((void *)nzotab, "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/ratlpfwrite.c",
           (int const   )367);
  }
#line 368
  return;
}
}
#line 375 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/ratlpfwrite.c"
void lpf_write(Lps const   *lp , FILE *fp , LpFormat format , char const   *text ) 
{ 
  Var const   *var ;
  Con *con ;
  Con **contab ;
  Bool have_integer ;
  Bool have_separate ;
  Bool have_checkonly ;
  int cnt ;
  int i ;
  int k ;
  int name_size ;
  char *name ;
  void *tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  Sos const   *sos ;
  Sse const   *sse ;
  int tmp___15 ;
  int tmp___16 ;
  Bool tmp___17 ;

  {
  {
#line 384
  have_integer = 0;
#line 385
  have_separate = 0;
#line 386
  have_checkonly = 0;
#line 399
  tmp = mem_calloc((size_t )lp->cons + 1UL, sizeof(*contab), "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/ratlpfwrite.c",
                   (int const   )399);
#line 399
  contab = (Con **)tmp;
#line 403
  k = 0;
#line 404
  con = (Con *)lp->con_root;
  }
  {
#line 404
  while (1) {
    while_continue: /* CIL Label */ ;
#line 404
    if (! ((unsigned long )con != (unsigned long )((void *)0))) {
#line 404
      goto while_break;
    }
#line 405
    tmp___0 = k;
#line 405
    k ++;
#line 405
    *(contab + tmp___0) = con;
#line 404
    con = con->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 409
  if ((unsigned int )format == 4U) {
    {
#line 410
    permute((int )lp->cons, (void **)contab);
    }
  }
  {
#line 412
  name_size = lps_getnamesize(lp, (LpFormat )1);
#line 413
  tmp___1 = mem_malloc((size_t )name_size, "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/ratlpfwrite.c",
                       (int const   )413);
#line 413
  name = (char *)tmp___1;
  }
#line 417
  if ((unsigned long )text != (unsigned long )((void *)0)) {
    {
#line 418
    fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%s", text);
    }
  }
  {
#line 420
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"\\Problem name: %s\n",
          lp->name);
  }
#line 421
  if ((unsigned int const   )lp->direct == 0U) {
#line 421
    tmp___2 = "Minimize";
  } else {
#line 421
    tmp___2 = "Maximize";
  }
  {
#line 421
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%s\n", tmp___2);
  }
#line 422
  if ((unsigned long )lp->objname == (unsigned long )((void *)0)) {
#line 422
    tmp___3 = (char const   */* const  */)"Objective";
  } else {
#line 422
    tmp___3 = (char const   */* const  */)lp->objname;
  }
  {
#line 422
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" %s: ", tmp___3);
#line 424
  var = (Var const   *)lp->var_root;
#line 424
  cnt = 0;
  }
  {
#line 424
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 424
    if (! ((unsigned long )var != (unsigned long )((void *)0))) {
#line 424
      goto while_break___0;
    }
    {
#line 428
    tmp___4 = __gmpq_equal((mpq_srcptr )(var->cost), (mpq_srcptr )(const_zero));
    }
#line 428
    if (tmp___4) {
#line 429
      goto __Cont;
    }
#line 431
    if ((unsigned int )format == 2U) {
#line 431
      tmp___5 = -1;
    } else {
#line 431
      tmp___5 = (int )var->number;
    }
    {
#line 431
    lps_makename(name, name_size, (char const   *)var->name, tmp___5);
#line 433
    tmp___7 = __gmpq_equal((mpq_srcptr )(var->cost), (mpq_srcptr )(const_one));
    }
#line 433
    if (tmp___7) {
      {
#line 434
      fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" + %s",
              name);
      }
    } else {
      {
#line 435
      tmp___6 = __gmpq_equal((mpq_srcptr )(var->cost), (mpq_srcptr )(const_minus_one));
      }
#line 435
      if (tmp___6) {
        {
#line 436
        fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" - %s",
                name);
        }
      } else {
        {
#line 439
        fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" ");
#line 440
        write_val(fp, format, 1, (__mpq_struct */* const  */)(var->cost));
#line 441
        fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" %s",
                name);
        }
      }
    }
#line 444
    cnt ++;
#line 444
    if (cnt % 6 == 0) {
      {
#line 445
      fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"\n ");
      }
    }
    __Cont: /* CIL Label */ 
#line 424
    var = (Var const   *)var->next;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 452
  i = 0;
  {
#line 452
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 452
    if (! (i < 3)) {
#line 452
      goto while_break___1;
    }
#line 454
    if (i == 0) {
      {
#line 455
      fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"\nSubject to\n");
      }
    } else
#line 456
    if (i == 1) {
#line 458
      if (! have_separate) {
#line 459
        goto __Cont___0;
      } else {
        {
#line 461
        fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"\nUser Cuts\n");
        }
      }
    } else
#line 463
    if (i == 2) {
#line 465
      if (! have_checkonly) {
#line 466
        goto __Cont___0;
      } else {
        {
#line 468
        fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"\nLazy Constraints\n");
        }
      }
    }
#line 471
    k = 0;
    {
#line 471
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 471
      if (! (k < (int )lp->cons)) {
#line 471
        goto while_break___2;
      }
#line 473
      con = *(contab + k);
#line 475
      if (con->size == 0) {
#line 475
        if ((unsigned long )con->qme_first == (unsigned long )((void *)0)) {
#line 475
          if ((unsigned long )con->term == (unsigned long )((void *)0)) {
#line 476
            goto __Cont___1;
          }
        }
      }
#line 478
      if (i == 0) {
#line 478
        if ((con->flags & 6U) != 0U) {
#line 480
          if ((con->flags & 2U) == 2U) {
#line 481
            have_separate = 1;
          }
#line 482
          if ((con->flags & 4U) == 4U) {
#line 483
            have_checkonly = 1;
          }
#line 485
          goto __Cont___1;
        }
      }
#line 487
      if (i == 1) {
#line 487
        if ((con->flags & 2U) != 2U) {
#line 488
          goto __Cont___1;
        }
      }
#line 490
      if (i == 2) {
#line 490
        if ((con->flags & 4U) != 4U) {
#line 491
          goto __Cont___1;
        }
      }
#line 493
      if ((unsigned int )con->type == 3U) {
#line 495
        if ((unsigned int )format == 2U) {
          {
#line 497
          lps_makename(name, name_size, (char const   *)con->name, -1);
#line 498
          fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" %s:\n ",
                  name);
#line 500
          write_lhs(fp, format, (Con const   *)con, (ConType )3);
#line 501
          write_row(fp, format, (Con const   *)con, name, name_size);
#line 502
          write_rhs(fp, format, (Con const   *)con, (ConType )3);
          }
        } else {
          {
#line 508
          lps_makename(name, name_size, (char const   *)con->name, con->number);
#line 509
          fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" %sR:\n ",
                  name);
#line 511
          write_row(fp, format, (Con const   *)con, name, name_size);
#line 512
          write_rhs(fp, format, (Con const   *)con, (ConType )2);
#line 514
          lps_makename(name, name_size, (char const   *)con->name, con->number);
#line 515
          fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" %sL:\n ",
                  name);
#line 517
          write_row(fp, format, (Con const   *)con, name, name_size);
#line 518
          write_rhs(fp, format, (Con const   *)con, (ConType )1);
          }
        }
      } else {
#line 523
        if ((unsigned int )format == 2U) {
#line 523
          tmp___8 = -1;
        } else {
#line 523
          tmp___8 = con->number;
        }
        {
#line 523
        lps_makename(name, name_size, (char const   *)con->name, tmp___8);
        }
#line 525
        if (i == 0) {
          {
#line 526
          fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" %s:\n ",
                  name);
          }
        } else
#line 527
        if (i == 1) {
          {
#line 528
          fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" %sU:\n ",
                  name);
          }
        } else
#line 529
        if (i == 2) {
          {
#line 530
          fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" %sZ:\n ",
                  name);
          }
        }
#line 532
        if ((unsigned long )con->ind_var != (unsigned long )((void *)0)) {
#line 534
          if ((unsigned int )format == 2U) {
#line 534
            tmp___9 = -1;
          } else {
#line 534
            tmp___9 = (con->ind_var)->number;
          }
          {
#line 534
          lps_makename(name, name_size, (char const   *)(con->ind_var)->name, tmp___9);
          }
#line 535
          if (con->ind_dir) {
#line 535
            tmp___10 = 1;
          } else {
#line 535
            tmp___10 = 0;
          }
          {
#line 535
          fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%s = %d -> ",
                  name, tmp___10);
          }
        }
        {
#line 537
        write_row(fp, format, (Con const   *)con, name, name_size);
#line 538
        write_rhs(fp, format, (Con const   *)con, con->type);
        }
      }
      __Cont___1: /* CIL Label */ 
#line 471
      k ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    __Cont___0: /* CIL Label */ 
#line 452
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 545
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"Bounds\n");
#line 547
  var = (Var const   *)lp->var_root;
  }
  {
#line 547
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 547
    if (! ((unsigned long )var != (unsigned long )((void *)0))) {
#line 547
      goto while_break___3;
    }
#line 553
    if (var->size == 0) {
      {
#line 553
      tmp___11 = __gmpq_equal((mpq_srcptr )(var->cost), (mpq_srcptr )(const_zero));
      }
#line 553
      if (tmp___11) {
#line 553
        if (! var->is_used) {
#line 554
          goto __Cont___2;
        }
      }
    }
#line 556
    if ((unsigned int )format == 2U) {
#line 556
      tmp___12 = -1;
    } else {
#line 556
      tmp___12 = (int )var->number;
    }
    {
#line 556
    lps_makename(name, name_size, (char const   *)var->name, tmp___12);
    }
#line 558
    if ((unsigned int const   )var->type == 4U) {
      {
#line 560
      fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" %s = ",
              name);
#line 561
      write_val(fp, format, 0, (__mpq_struct */* const  */)(var->lower));
#line 562
      fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"\n");
      }
    } else {
#line 568
      if ((unsigned int const   )var->vclass == 2U) {
#line 569
        have_integer = 1;
      }
      {
#line 571
      fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" ");
      }
#line 573
      if ((unsigned int const   )var->type == 1U) {
        {
#line 574
        write_val(fp, format, 0, (__mpq_struct */* const  */)(var->lower));
        }
      } else
#line 573
      if ((unsigned int const   )var->type == 3U) {
        {
#line 574
        write_val(fp, format, 0, (__mpq_struct */* const  */)(var->lower));
        }
      } else {
        {
#line 576
        fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"-inf");
        }
      }
      {
#line 578
      fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" <= %s <= ",
              name);
      }
#line 580
      if ((unsigned int const   )var->type == 2U) {
        {
#line 582
        write_val(fp, format, 0, (__mpq_struct */* const  */)(var->upper));
#line 583
        fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"\n");
        }
      } else
#line 580
      if ((unsigned int const   )var->type == 3U) {
        {
#line 582
        write_val(fp, format, 0, (__mpq_struct */* const  */)(var->upper));
#line 583
        fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"\n");
        }
      } else {
        {
#line 586
        fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"+inf\n");
        }
      }
    }
    __Cont___2: /* CIL Label */ 
#line 547
    var = (Var const   *)var->next;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 592
  if (have_integer) {
    {
#line 594
    fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"General\n");
#line 596
    var = (Var const   *)lp->var_root;
    }
    {
#line 596
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 596
      if (! ((unsigned long )var != (unsigned long )((void *)0))) {
#line 596
        goto while_break___4;
      }
#line 598
      if ((unsigned int const   )var->vclass != 2U) {
#line 599
        goto __Cont___3;
      }
#line 601
      if (var->size == 0) {
        {
#line 601
        tmp___13 = __gmpq_equal((mpq_srcptr )(var->cost), (mpq_srcptr )(const_zero));
        }
#line 601
        if (tmp___13) {
#line 601
          if (! var->is_used) {
#line 602
            goto __Cont___3;
          }
        }
      }
#line 604
      if ((unsigned int )format == 2U) {
#line 604
        tmp___14 = -1;
      } else {
#line 604
        tmp___14 = (int )var->number;
      }
      {
#line 604
      lps_makename(name, name_size, (char const   *)var->name, tmp___14);
#line 606
      fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" %s\n",
              name);
      }
      __Cont___3: /* CIL Label */ 
#line 596
      var = (Var const   *)var->next;
    }
    while_break___4: /* CIL Label */ ;
    }
  }
  {
#line 612
  tmp___17 = lps_has_sos(lp);
  }
#line 612
  if (tmp___17) {
    {
#line 617
    fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"SOS\n");
#line 619
    sos = (Sos const   *)lp->sos_root;
    }
    {
#line 619
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 619
      if (! ((unsigned long )sos != (unsigned long )((void *)0))) {
#line 619
        goto while_break___5;
      }
#line 621
      cnt = 0;
#line 623
      if ((unsigned int const   )sos->type == 1U) {
#line 623
        tmp___15 = 1;
      } else {
#line 623
        tmp___15 = 2;
      }
      {
#line 623
      fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" %s:S%d:: ",
              sos->name, tmp___15);
#line 627
      sse = (Sse const   *)sos->first;
      }
      {
#line 627
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 627
        if (! ((unsigned long )sse != (unsigned long )((void *)0))) {
#line 627
          goto while_break___6;
        }
#line 629
        if ((unsigned int )format == 2U) {
#line 629
          tmp___16 = -1;
        } else {
#line 629
          tmp___16 = (sse->var)->number;
        }
        {
#line 629
        lps_makename(name, name_size, (char const   *)(sse->var)->name, tmp___16);
#line 631
        fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" %s:",
                name);
#line 632
        write_val(fp, format, 0, (__mpq_struct */* const  */)(sse->weight));
#line 634
        cnt ++;
        }
#line 634
        if (cnt % 6 == 0) {
          {
#line 635
          fputc('\n', fp);
          }
        }
#line 627
        sse = (Sse const   *)sse->next;
      }
      while_break___6: /* CIL Label */ ;
      }
#line 637
      if (cnt % 6 != 0) {
        {
#line 638
        fputc('\n', fp);
        }
      }
#line 619
      sos = (Sos const   *)sos->next;
    }
    while_break___5: /* CIL Label */ ;
    }
  }
  {
#line 641
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"End\n");
#line 643
  mem_free((void *)name, "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/ratlpfwrite.c",
           (int const   )643);
#line 644
  mem_free((void *)contab, "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/ratlpfwrite.c",
           (int const   )644);
  }
#line 645
  return;
}
}
#line 52 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/ratordwrite.c"
void lps_orderfile(Lps const   *lp , FILE *fp , LpFormat format , char const   *text ) 
{ 
  Var const   *var ;
  int name_size ;
  char *vtmp ;
  void *tmp ;
  double tmp___0 ;

  {
  {
#line 66
  name_size = lps_getnamesize(lp, format);
#line 67
  tmp = mem_malloc((size_t )name_size, "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/ratordwrite.c",
                   (int const   )67);
#line 67
  vtmp = (char *)tmp;
  }
#line 71
  if ((unsigned long )text != (unsigned long )((void *)0)) {
    {
#line 72
    fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"* %s\n",
            text);
    }
  }
  {
#line 74
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"NAME        %8.8s\n",
          lp->name);
#line 76
  var = (Var const   *)lp->var_root;
  }
  {
#line 76
  while (1) {
    while_continue: /* CIL Label */ ;
#line 76
    if (! ((unsigned long )var != (unsigned long )((void *)0))) {
#line 76
      goto while_break;
    }
#line 78
    if ((unsigned int const   )var->vclass == 0U) {
#line 79
      goto __Cont;
    }
#line 81
    if (var->size == 0) {
#line 82
      goto __Cont;
    }
#line 84
    if ((unsigned int const   )var->type == 4U) {
#line 85
      goto __Cont;
    }
    {
#line 87
    lps_makename(vtmp, name_size, (char const   *)var->name, (int )var->number);
#line 89
    tmp___0 = __gmpq_get_d((mpq_srcptr )(var->startval));
#line 89
    fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"    %-*s  %8d  %.10e\n",
            name_size - 1, vtmp, var->priority, tmp___0);
    }
    __Cont: /* CIL Label */ 
#line 76
    var = (Var const   *)var->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 92
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"ENDATA\n");
#line 94
  mem_free((void *)vtmp, "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/ratordwrite.c",
           (int const   )94);
  }
#line 95
  return;
}
}
#line 113 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/numb.h"
extern unsigned int numb_hash(Numb const   *numb ) ;
#line 52 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/elem.h"
void elem_exit(void) ;
#line 54
Elem *elem_new_numb(Numb const   *numb ) ;
#line 58
Elem *elem_new_name(char const   *name ) ;
#line 60
void elem_free(Elem *elem ) ;
#line 62
Bool elem_is_valid(Elem const   *elem ) ;
#line 64
Elem *elem_copy(Elem const   *source ) ;
#line 66
Bool elem_cmp(Elem const   *elem_a , Elem const   *elem_b ) ;
#line 68
ElemType elem_get_type(Elem const   *elem ) ;
#line 70
Numb const   *elem_get_numb(Elem const   *elem ) ;
#line 72
char const   *elem_get_strg(Elem const   *elem ) ;
#line 74
char const   *elem_get_name(Elem const   *elem ) ;
#line 76
void elem_print(FILE *fp , Elem const   *elem , Bool use_quotes ) ;
#line 78
unsigned int elem_hash(Elem const   *elem ) ;
#line 80
char *elem_tostr(Elem const   *elem ) ;
#line 39 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/strstore.h"
extern unsigned int str_hash(char const   *s ) ;
#line 68 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/elem.c"
static ElemStore *store_anchor  =    (ElemStore *)((void *)0);
#line 69 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/elem.c"
static Elem *store_free  =    (Elem *)((void *)0);
#line 70 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/elem.c"
static int store_count  =    0;
#line 72 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/elem.c"
static void extend_storage(void) 
{ 
  ElemStore *store ;
  void *tmp ;
  Elem *elem ;
  int i ;
  void *tmp___0 ;

  {
  {
#line 74
  tmp = mem_calloc((size_t )1, sizeof(*store), "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/elem.c",
                   (int const   )74);
#line 74
  store = (ElemStore *)tmp;
#line 80
  tmp___0 = mem_malloc(1000UL * sizeof(*(store->begin)), "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/elem.c",
                       (int const   )80);
#line 80
  store->begin = (Elem *)tmp___0;
#line 81
  store->next = store_anchor;
#line 82
  store_anchor = store;
#line 84
  i = 0;
  }
  {
#line 84
  while (1) {
    while_continue: /* CIL Label */ ;
#line 84
    if (! (i < 999)) {
#line 84
      goto while_break;
    }
#line 86
    elem = store->begin + i;
#line 87
    elem->type = (ElemType )1;
#line 88
    elem->value.next = store->begin + (i + 1);
#line 84
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 92
  elem = store->begin + i;
#line 93
  elem->type = (ElemType )1;
#line 94
  elem->value.next = store_free;
#line 98
  store_free = store->begin + 0;
#line 103
  return;
}
}
#line 105 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/elem.c"
static Elem *new_elem(void) 
{ 
  Elem *elem ;

  {
#line 109
  if ((unsigned long )store_free == (unsigned long )((void *)0)) {
    {
#line 110
    extend_storage();
    }
  }
#line 114
  elem = store_free;
#line 115
  store_free = elem->value.next;
#line 117
  store_count ++;
#line 122
  return (elem);
}
}
#line 125 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/elem.c"
void elem_init(void) 
{ 


  {
#line 127
  return;
}
}
#line 129 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/elem.c"
void elem_exit(void) 
{ 
  ElemStore *store ;
  ElemStore *next___0 ;

  {
#line 134
  if (store_count != 0) {
    {
#line 135
    printf((char const   */* __restrict  */)"Elem store count %d\n", store_count);
    }
  }
#line 137
  store = store_anchor;
  {
#line 137
  while (1) {
    while_continue: /* CIL Label */ ;
#line 137
    if (! ((unsigned long )store != (unsigned long )((void *)0))) {
#line 137
      goto while_break;
    }
    {
#line 148
    next___0 = store->next;
#line 150
    mem_free((void *)store->begin, "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/elem.c",
             (int const   )150);
#line 151
    mem_free((void *)store, "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/elem.c",
             (int const   )151);
#line 137
    store = next___0;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 153
  store_anchor = (ElemStore *)((void *)0);
#line 154
  store_free = (Elem *)((void *)0);
#line 155
  store_count = 0;
#line 156
  return;
}
}
#line 158 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/elem.c"
Elem *elem_new_numb(Numb const   *numb ) 
{ 
  Elem *elem ;
  Elem *tmp ;

  {
  {
#line 160
  tmp = new_elem();
#line 160
  elem = tmp;
#line 164
  elem->type = (ElemType )2;
#line 165
  elem->value.numb = numb_copy(numb);
  }
#line 167
  return (elem);
}
}
#line 170 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/elem.c"
Elem *elem_new_strg(char const   *strg ) 
{ 
  Elem *elem ;
  Elem *tmp ;

  {
  {
#line 172
  tmp = new_elem();
#line 172
  elem = tmp;
#line 177
  elem->type = (ElemType )3;
#line 178
  elem->value.strg = strg;
  }
#line 180
  return (elem);
}
}
#line 183 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/elem.c"
Elem *elem_new_name(char const   *name ) 
{ 
  Elem *elem ;
  Elem *tmp ;

  {
  {
#line 185
  tmp = new_elem();
#line 185
  elem = tmp;
#line 190
  elem->type = (ElemType )4;
#line 191
  elem->value.strg = name;
  }
#line 193
  return (elem);
}
}
#line 196 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/elem.c"
void elem_free(Elem *elem ) 
{ 


  {
#line 200
  if ((unsigned int )elem->type == 2U) {
    {
#line 201
    numb_free(elem->value.numb);
    }
  }
#line 203
  elem->type = (ElemType )1;
#line 204
  elem->value.next = store_free;
#line 205
  store_free = elem;
#line 206
  store_count --;
#line 207
  return;
}
}
#line 209 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/elem.c"
Bool elem_is_valid(Elem const   *elem ) 
{ 
  int tmp ;

  {
#line 211
  if ((unsigned long )elem != (unsigned long )((void *)0)) {
#line 211
    tmp = 1;
  } else {
#line 211
    tmp = 0;
  }
#line 211
  return (tmp);
}
}
#line 214 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/elem.c"
Elem *elem_copy(Elem const   *source ) 
{ 
  Elem *elem ;
  Elem *tmp ;

  {
  {
#line 216
  tmp = new_elem();
#line 216
  elem = tmp;
  }
#line 221
  if ((unsigned int const   )source->type != 2U) {
#line 222
    *elem = (Elem )*source;
  } else {
    {
#line 225
    elem->type = (ElemType )2;
#line 226
    elem->value.numb = numb_copy((Numb const   *)source->value.numb);
    }
  }
#line 228
  return (elem);
}
}
#line 233 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/elem.c"
Bool elem_cmp(Elem const   *elem_a , Elem const   *elem_b ) 
{ 
  int tmp ;
  Bool tmp___0 ;
  int tmp___1 ;

  {
#line 242
  if ((unsigned long )elem_a == (unsigned long )elem_b) {
#line 243
    return (0);
  }
#line 245
  if ((unsigned int const   )elem_a->type != (unsigned int const   )elem_b->type) {
    {
#line 247
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"*** Error 160: Comparison of elements with different types ");
#line 249
    elem_print(stderr, elem_a, 1);
#line 250
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" / ");
#line 251
    elem_print(stderr, elem_b, 1);
#line 252
    fputc('\n', stderr);
#line 253
    zpl_exit(1);
    }
  }
#line 257
  if ((unsigned int const   )elem_a->type == 3U) {
    {
#line 258
    tmp = strcmp((char const   *)elem_a->value.strg, (char const   *)elem_b->value.strg);
    }
#line 258
    return (tmp != 0);
  }
  {
#line 262
  tmp___0 = numb_equal((Numb const   *)elem_a->value.numb, (Numb const   *)elem_b->value.numb);
  }
#line 262
  if (tmp___0) {
#line 262
    tmp___1 = 0;
  } else {
#line 262
    tmp___1 = 1;
  }
#line 262
  return (tmp___1);
}
}
#line 265 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/elem.c"
ElemType elem_get_type(Elem const   *elem ) 
{ 


  {
#line 269
  return ((ElemType )elem->type);
}
}
#line 272 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/elem.c"
Numb const   *elem_get_numb(Elem const   *elem ) 
{ 


  {
#line 277
  return ((Numb const   *)elem->value.numb);
}
}
#line 280 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/elem.c"
char const   *elem_get_strg(Elem const   *elem ) 
{ 


  {
#line 286
  return ((char const   *)elem->value.strg);
}
}
#line 289 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/elem.c"
char const   *elem_get_name(Elem const   *elem ) 
{ 


  {
#line 295
  return ((char const   *)elem->value.name);
}
}
#line 298 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/elem.c"
void elem_print(FILE *fp , Elem const   *elem , Bool use_quotes ) 
{ 
  double tmp ;
  char const   *tmp___0 ;

  {
  {
#line 304
  if ((unsigned int const   )elem->type == 2U) {
#line 304
    goto case_2;
  }
#line 307
  if ((unsigned int const   )elem->type == 3U) {
#line 307
    goto case_3;
  }
#line 310
  if ((unsigned int const   )elem->type == 4U) {
#line 310
    goto case_4;
  }
#line 313
  if ((unsigned int const   )elem->type == 1U) {
#line 313
    goto case_1;
  }
#line 316
  goto switch_default;
  case_2: /* CIL Label */ 
  {
#line 305
  tmp = numb_todbl((Numb const   *)elem->value.numb);
#line 305
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%.16g", tmp);
  }
#line 306
  goto switch_break;
  case_3: /* CIL Label */ 
#line 308
  if (use_quotes) {
#line 308
    tmp___0 = "\"%s\"";
  } else {
#line 308
    tmp___0 = "%s";
  }
  {
#line 308
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)tmp___0, elem->value.strg);
  }
#line 309
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 311
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%s", elem->value.name);
  }
#line 312
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 314
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"Unused Elem!");
  }
#line 315
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 317
  abort();
  }
  switch_break: /* CIL Label */ ;
  }
#line 319
  return;
}
}
#line 321 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/elem.c"
unsigned int elem_hash(Elem const   *elem ) 
{ 
  unsigned int hcode ;

  {
#line 323
  hcode = 0U;
  {
#line 327
  if ((unsigned int const   )elem->type == 2U) {
#line 327
    goto case_2;
  }
#line 330
  if ((unsigned int const   )elem->type == 3U) {
#line 330
    goto case_3;
  }
#line 333
  if ((unsigned int const   )elem->type == 4U) {
#line 333
    goto case_4;
  }
#line 337
  goto switch_default;
  case_2: /* CIL Label */ 
  {
#line 328
  hcode = numb_hash((Numb const   *)elem->value.numb);
  }
#line 329
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 331
  hcode = str_hash((char const   *)elem->value.strg);
  }
#line 332
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 334
  hcode = str_hash((char const   *)elem->value.name);
  }
#line 335
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 338
  abort();
  }
  switch_break: /* CIL Label */ ;
  }
#line 340
  return (hcode);
}
}
#line 343 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/elem.c"
char *elem_tostr(Elem const   *elem ) 
{ 
  char *str ;
  void *tmp ;
  double tmp___0 ;

  {
  {
#line 351
  if ((unsigned int const   )elem->type == 2U) {
#line 351
    goto case_2;
  }
#line 358
  if ((unsigned int const   )elem->type == 3U) {
#line 358
    goto case_3;
  }
#line 361
  if ((unsigned int const   )elem->type == 4U) {
#line 361
    goto case_4;
  }
#line 365
  goto switch_default;
  case_2: /* CIL Label */ 
  {
#line 352
  tmp = mem_malloc((size_t )32, "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/elem.c",
                   (int const   )352);
#line 352
  str = (char *)tmp;
#line 356
  tmp___0 = numb_todbl((Numb const   *)elem->value.numb);
#line 356
  sprintf((char */* __restrict  */)str, (char const   */* __restrict  */)"%.16g",
          tmp___0);
  }
#line 357
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 359
  str = mem_strdup((char const   *)elem->value.strg, "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/elem.c",
                   (int const   )359);
  }
#line 360
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 362
  str = mem_strdup((char const   *)elem->value.name, "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/elem.c",
                   (int const   )362);
  }
#line 363
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 366
  abort();
  }
  switch_break: /* CIL Label */ ;
  }
#line 370
  return (str);
}
}
#line 127 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) toupper)(int __c ) ;
#line 1228 "/usr/include/x86_64-linux-gnu/gmp.h"
extern void __gmpq_sub(mpq_ptr  , mpq_srcptr  , mpq_srcptr  ) ;
#line 49 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/ratmpswrite.c"
static void write_data(FILE *fp , Bool use_field5 , int const   indicator1 , int const   indicator2 ,
                       char const   *name1 , char const   *name2 , __mpq_struct * const  value ) 
{ 
  double tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 61
  if (use_field5) {
    {
#line 63
    tmp = __gmpq_get_d((mpq_srcptr )value);
#line 63
    tmp___0 = toupper((int )indicator2);
#line 63
    tmp___1 = toupper((int )indicator1);
#line 63
    fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" %c%c %-8.8s  %-8.8s  %12g\n",
            tmp___1, tmp___0, name1, name2, tmp);
    }
  } else {
    {
#line 68
    tmp___2 = toupper((int )indicator2);
#line 68
    tmp___3 = toupper((int )indicator1);
#line 68
    fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" %c%c %-8.8s  %-8.8s\n",
            tmp___3, tmp___2, name1, name2);
    }
  }
#line 71
  return;
}
}
#line 79
static void write_vars(Lps const   *lp , FILE *fp , VarClass varclass , int name_size ) ;
#line 79 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/ratmpswrite.c"
static Bool first  =    1;
#line 73 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/ratmpswrite.c"
static void write_vars(Lps const   *lp , FILE *fp , VarClass varclass , int name_size ) 
{ 
  Var const   *var ;
  Nzo const   *nzo ;
  char *vtmp ;
  char *ctmp ;
  mpq_t temp ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 90
  tmp = mem_malloc((size_t )name_size, "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/ratmpswrite.c",
                   (int const   )90);
#line 90
  vtmp = (char *)tmp;
#line 91
  tmp___0 = mem_malloc((size_t )name_size, "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/ratmpswrite.c",
                       (int const   )91);
#line 91
  ctmp = (char *)tmp___0;
#line 96
  __gmpq_init(temp);
#line 98
  var = (Var const   *)lp->var_root;
  }
  {
#line 98
  while (1) {
    while_continue: /* CIL Label */ ;
#line 98
    if (! ((unsigned long )var != (unsigned long )((void *)0))) {
#line 98
      goto while_break;
    }
#line 100
    if ((unsigned int const   )var->vclass != (unsigned int const   )varclass) {
#line 101
      goto __Cont;
    }
    {
#line 106
    tmp___1 = __gmpq_equal((mpq_srcptr )(var->cost), (mpq_srcptr )(const_zero));
    }
#line 106
    if (! tmp___1) {
      {
#line 108
      lps_makename(vtmp, name_size, (char const   *)var->name, (int )var->number);
      }
#line 110
      if ((unsigned int const   )lp->direct == 0U) {
        {
#line 111
        __gmpq_set(temp, (mpq_srcptr )(var->cost));
        }
      } else {
        {
#line 114
        __gmpq_neg(temp, (mpq_srcptr )(var->cost));
        }
#line 116
        if (first) {
#line 118
          if (verbose > 0) {
            {
#line 120
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s\n%s\n",
                    "--- Warning: Objective function inverted to make", "             minimization problem for MPS output\n");
            }
          }
#line 124
          first = 0;
        }
      }
      {
#line 127
      write_data(fp, 1, (int const   )' ', (int const   )' ', (char const   *)vtmp,
                 "OBJECTIV", (__mpq_struct */* const  */)(temp));
      }
    }
#line 129
    nzo = (Nzo const   *)var->first;
    {
#line 129
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 129
      if (! ((unsigned long )nzo != (unsigned long )((void *)0))) {
#line 129
        goto while_break___0;
      }
      {
#line 134
      lps_makename(vtmp, name_size, (char const   *)var->name, (int )var->number);
#line 135
      lps_makename(ctmp, name_size, (char const   *)(nzo->con)->name, (nzo->con)->number);
#line 137
      write_data(fp, 1, (int const   )' ', (int const   )' ', (char const   *)vtmp,
                 (char const   *)ctmp, (__mpq_struct */* const  */)(nzo->value));
#line 129
      nzo = (Nzo const   *)nzo->var_next;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
#line 98
    var = (Var const   *)var->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 140
  __gmpq_clear(temp);
#line 142
  mem_free((void *)vtmp, "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/ratmpswrite.c",
           (int const   )142);
#line 143
  mem_free((void *)ctmp, "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/ratmpswrite.c",
           (int const   )143);
  }
#line 144
  return;
}
}
#line 146 "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/ratmpswrite.c"
void mps_write(Lps const   *lp , FILE *fp , char const   *text ) 
{ 
  Var const   *var ;
  Con const   *con ;
  int indicator ;
  Bool has_ranges ;
  int name_size ;
  char *vtmp ;
  char *ctmp ;
  mpq_t temp ;
  void *tmp ;
  void *tmp___0 ;
  ConType tmp___1 ;
  ConType tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  ConType tmp___7 ;
  int tmp___8 ;
  Bool tmp___9 ;
  Sos const   *sos ;
  Sse const   *sse ;
  int tmp___10 ;
  Bool tmp___11 ;

  {
  {
#line 154
  has_ranges = 0;
#line 163
  name_size = lps_getnamesize(lp, (LpFormat )3);
#line 164
  tmp = mem_malloc((size_t )name_size, "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/ratmpswrite.c",
                   (int const   )164);
#line 164
  vtmp = (char *)tmp;
#line 165
  tmp___0 = mem_malloc((size_t )name_size, "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/ratmpswrite.c",
                       (int const   )165);
#line 165
  ctmp = (char *)tmp___0;
#line 170
  __gmpq_init(temp);
  }
#line 172
  if ((unsigned long )text != (unsigned long )((void *)0)) {
    {
#line 173
    fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%s", text);
    }
  }
  {
#line 175
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"NAME        %8.8s\n",
          lp->name);
#line 176
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"ROWS\n");
#line 178
  write_data(fp, 0, (int const   )'N', (int const   )' ', "OBJECTIV", "", (__mpq_struct */* const  */)(const_zero));
#line 180
  con = (Con const   *)lp->con_root;
  }
  {
#line 180
  while (1) {
    while_continue: /* CIL Label */ ;
#line 180
    if (! ((unsigned long )con != (unsigned long )((void *)0))) {
#line 180
      goto while_break;
    }
#line 182
    if (con->size > 0) {
      {
#line 184
      lps_makename(ctmp, name_size, (char const   *)con->name, (int )con->number);
#line 186
      tmp___1 = lps_contype(con);
      }
      {
#line 188
      if ((unsigned int )tmp___1 == 4U) {
#line 188
        goto case_4;
      }
#line 191
      if ((unsigned int )tmp___1 == 1U) {
#line 191
        goto case_1;
      }
#line 194
      if ((unsigned int )tmp___1 == 2U) {
#line 194
        goto case_2;
      }
#line 197
      if ((unsigned int )tmp___1 == 3U) {
#line 197
        goto case_3;
      }
#line 201
      goto switch_default;
      case_4: /* CIL Label */ 
#line 189
      indicator = 'E';
#line 190
      goto switch_break;
      case_1: /* CIL Label */ 
#line 192
      indicator = 'G';
#line 193
      goto switch_break;
      case_2: /* CIL Label */ 
#line 195
      indicator = 'L';
#line 196
      goto switch_break;
      case_3: /* CIL Label */ 
#line 198
      indicator = 'E';
#line 199
      has_ranges = 1;
#line 200
      goto switch_break;
      switch_default: /* CIL Label */ 
      {
#line 202
      abort();
      }
      switch_break: /* CIL Label */ ;
      }
      {
#line 204
      write_data(fp, 0, (int const   )indicator, (int const   )' ', (char const   *)ctmp,
                 "", (__mpq_struct */* const  */)(const_zero));
      }
    }
#line 180
    con = (Con const   *)con->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 207
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"COLUMNS\n");
#line 215
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"    MARK0000  \'MARKER\'                 \'INTORG\'\n");
#line 217
  write_vars(lp, fp, (VarClass )2, name_size);
#line 219
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"    MARK0001  \'MARKER\'                 \'INTEND\'\n");
#line 221
  write_vars(lp, fp, (VarClass )0, name_size);
#line 222
  write_vars(lp, fp, (VarClass )1, name_size);
#line 224
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"RHS\n");
#line 226
  con = (Con const   *)lp->con_root;
  }
  {
#line 226
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 226
    if (! ((unsigned long )con != (unsigned long )((void *)0))) {
#line 226
      goto while_break___0;
    }
    {
#line 228
    lps_makename(ctmp, name_size, (char const   *)con->name, (int )con->number);
#line 230
    tmp___2 = lps_contype(con);
    }
    {
#line 232
    if ((unsigned int )tmp___2 == 4U) {
#line 232
      goto case_4___0;
    }
#line 236
    if ((unsigned int )tmp___2 == 1U) {
#line 236
      goto case_1___0;
    }
#line 240
    if ((unsigned int )tmp___2 == 2U) {
#line 240
      goto case_2___0;
    }
#line 244
    if ((unsigned int )tmp___2 == 3U) {
#line 244
      goto case_3___0;
    }
#line 248
    goto switch_default___0;
    case_4___0: /* CIL Label */ 
    {
#line 233
    tmp___3 = __gmpq_equal((mpq_srcptr )(con->rhs), (mpq_srcptr )(const_zero));
    }
#line 233
    if (! tmp___3) {
      {
#line 234
      write_data(fp, 1, (int const   )' ', (int const   )' ', "RHS", (char const   *)ctmp,
                 (__mpq_struct */* const  */)(con->rhs));
      }
    }
#line 235
    goto switch_break___0;
    case_1___0: /* CIL Label */ 
    {
#line 237
    tmp___4 = __gmpq_equal((mpq_srcptr )(con->lhs), (mpq_srcptr )(const_zero));
    }
#line 237
    if (! tmp___4) {
      {
#line 238
      write_data(fp, 1, (int const   )' ', (int const   )' ', "RHS", (char const   *)ctmp,
                 (__mpq_struct */* const  */)(con->lhs));
      }
    }
#line 239
    goto switch_break___0;
    case_2___0: /* CIL Label */ 
    {
#line 241
    tmp___5 = __gmpq_equal((mpq_srcptr )(con->rhs), (mpq_srcptr )(const_zero));
    }
#line 241
    if (! tmp___5) {
      {
#line 242
      write_data(fp, 1, (int const   )' ', (int const   )' ', "RHS", (char const   *)ctmp,
                 (__mpq_struct */* const  */)(con->rhs));
      }
    }
#line 243
    goto switch_break___0;
    case_3___0: /* CIL Label */ 
    {
#line 245
    tmp___6 = __gmpq_equal((mpq_srcptr )(con->lhs), (mpq_srcptr )(const_zero));
    }
#line 245
    if (! tmp___6) {
      {
#line 246
      write_data(fp, 1, (int const   )' ', (int const   )' ', "RHS", (char const   *)ctmp,
                 (__mpq_struct */* const  */)(con->lhs));
      }
    }
#line 247
    goto switch_break___0;
    switch_default___0: /* CIL Label */ 
    {
#line 249
    abort();
    }
    switch_break___0: /* CIL Label */ ;
    }
#line 226
    con = (Con const   *)con->next;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 252
  if (has_ranges) {
    {
#line 254
    fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"RANGES\n");
#line 256
    con = (Con const   *)lp->con_root;
    }
    {
#line 256
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 256
      if (! ((unsigned long )con != (unsigned long )((void *)0))) {
#line 256
        goto while_break___1;
      }
      {
#line 258
      tmp___7 = lps_contype(con);
      }
#line 258
      if ((unsigned int )tmp___7 == 3U) {
        {
#line 260
        lps_makename(ctmp, name_size, (char const   *)con->name, (int )con->number);
#line 265
        __gmpq_sub(temp, (mpq_srcptr )(con->rhs), (mpq_srcptr )(con->lhs));
#line 269
        write_data(fp, 1, (int const   )' ', (int const   )' ', "RNG", (char const   *)ctmp,
                   (__mpq_struct */* const  */)(temp));
        }
      }
#line 256
      con = (Con const   *)con->next;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  {
#line 274
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"BOUNDS\n");
#line 280
  var = (Var const   *)lp->var_root;
  }
  {
#line 280
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 280
    if (! ((unsigned long )var != (unsigned long )((void *)0))) {
#line 280
      goto while_break___2;
    }
#line 286
    if (var->size == 0) {
      {
#line 286
      tmp___8 = __gmpq_equal((mpq_srcptr )(var->cost), (mpq_srcptr )(const_zero));
      }
#line 286
      if (tmp___8) {
        {
#line 286
        tmp___9 = lps_has_sos(lp);
        }
#line 286
        if (! tmp___9) {
#line 287
          goto __Cont;
        }
      }
    }
    {
#line 296
    lps_makename(vtmp, name_size, (char const   *)var->name, (int )var->number);
    }
#line 298
    if ((unsigned int const   )var->type == 4U) {
      {
#line 299
      write_data(fp, 1, (int const   )'F', (int const   )'X', "BOUND", (char const   *)vtmp,
                 (__mpq_struct */* const  */)(var->lower));
      }
    } else {
#line 302
      if ((unsigned int const   )var->type == 1U) {
        {
#line 303
        write_data(fp, 1, (int const   )'L', (int const   )'O', "BOUND", (char const   *)vtmp,
                   (__mpq_struct */* const  */)(var->lower));
        }
      } else
#line 302
      if ((unsigned int const   )var->type == 3U) {
        {
#line 303
        write_data(fp, 1, (int const   )'L', (int const   )'O', "BOUND", (char const   *)vtmp,
                   (__mpq_struct */* const  */)(var->lower));
        }
      } else {
        {
#line 305
        write_data(fp, 0, (int const   )'M', (int const   )'I', "BOUND", (char const   *)vtmp,
                   (__mpq_struct */* const  */)(const_zero));
        }
      }
#line 307
      if ((unsigned int const   )var->type == 2U) {
        {
#line 308
        write_data(fp, 1, (int const   )'U', (int const   )'P', "BOUND", (char const   *)vtmp,
                   (__mpq_struct */* const  */)(var->upper));
        }
      } else
#line 307
      if ((unsigned int const   )var->type == 3U) {
        {
#line 308
        write_data(fp, 1, (int const   )'U', (int const   )'P', "BOUND", (char const   *)vtmp,
                   (__mpq_struct */* const  */)(var->upper));
        }
      } else {
        {
#line 310
        write_data(fp, 0, (int const   )'P', (int const   )'L', "BOUND", (char const   *)vtmp,
                   (__mpq_struct */* const  */)(const_zero));
        }
      }
    }
    __Cont: /* CIL Label */ 
#line 280
    var = (Var const   *)var->next;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 313
  tmp___11 = lps_has_sos(lp);
  }
#line 313
  if (tmp___11) {
    {
#line 318
    fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"SOS\n");
#line 320
    sos = (Sos const   *)lp->sos_root;
    }
    {
#line 320
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 320
      if (! ((unsigned long )sos != (unsigned long )((void *)0))) {
#line 320
        goto while_break___3;
      }
#line 322
      if ((unsigned int const   )sos->type == 1U) {
#line 322
        tmp___10 = '1';
      } else {
#line 322
        tmp___10 = '2';
      }
      {
#line 322
      write_data(fp, 0, (int const   )'S', (int const   )tmp___10, (char const   *)sos->name,
                 "", (__mpq_struct */* const  */)(const_zero));
#line 324
      sse = (Sse const   *)sos->first;
      }
      {
#line 324
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 324
        if (! ((unsigned long )sse != (unsigned long )((void *)0))) {
#line 324
          goto while_break___4;
        }
        {
#line 326
        lps_makename(vtmp, name_size, (char const   *)(sse->var)->name, (sse->var)->number);
#line 328
        write_data(fp, 1, (int const   )' ', (int const   )' ', "", (char const   *)vtmp,
                   (__mpq_struct */* const  */)(sse->weight));
#line 324
        sse = (Sse const   *)sse->next;
        }
      }
      while_break___4: /* CIL Label */ ;
      }
#line 320
      sos = (Sos const   *)sos->next;
    }
    while_break___3: /* CIL Label */ ;
    }
  }
  {
#line 332
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"ENDATA\n");
#line 334
  __gmpq_clear(temp);
#line 336
  mem_free((void *)vtmp, "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/ratmpswrite.c",
           (int const   )336);
#line 337
  mem_free((void *)ctmp, "/home/june/repo/benchmarks/collector/temp/zimpl-3.3.1+dfsg/src/ratmpswrite.c",
           (int const   )337);
  }
#line 338
  return;
}
}
