/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 49 "/usr/include/stdint.h"
typedef unsigned short uint16_t;
#line 51 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 11 "/home/june/repo/benchmarks/collector2/temp/wraplinux-1.7/elf32.h"
typedef uint16_t Elf32_Half;
#line 13 "/home/june/repo/benchmarks/collector2/temp/wraplinux-1.7/elf32.h"
typedef uint32_t Elf32_Word;
#line 18 "/home/june/repo/benchmarks/collector2/temp/wraplinux-1.7/elf32.h"
typedef uint32_t Elf32_Off;
#line 19 "/home/june/repo/benchmarks/collector2/temp/wraplinux-1.7/elf32.h"
typedef uint32_t Elf32_Addr;
#line 61 "/home/june/repo/benchmarks/collector2/temp/wraplinux-1.7/elf32.h"
struct elf32_hdr {
   unsigned char e_ident[16] ;
   Elf32_Half e_type ;
   Elf32_Half e_machine ;
   Elf32_Word e_version ;
   Elf32_Addr e_entry ;
   Elf32_Off e_phoff ;
   Elf32_Off e_shoff ;
   Elf32_Word e_flags ;
   Elf32_Half e_ehsize ;
   Elf32_Half e_phentsize ;
   Elf32_Half e_phnum ;
   Elf32_Half e_shentsize ;
   Elf32_Half e_shnum ;
   Elf32_Half e_shstrndx ;
};
#line 61 "/home/june/repo/benchmarks/collector2/temp/wraplinux-1.7/elf32.h"
typedef struct elf32_hdr Elf32_Ehdr;
#line 80 "/home/june/repo/benchmarks/collector2/temp/wraplinux-1.7/elf32.h"
struct elf32_phdr {
   Elf32_Word p_type ;
   Elf32_Off p_offset ;
   Elf32_Addr p_vaddr ;
   Elf32_Addr p_paddr ;
   Elf32_Word p_filesz ;
   Elf32_Word p_memsz ;
   Elf32_Word p_flags ;
   Elf32_Word p_align ;
};
#line 80 "/home/june/repo/benchmarks/collector2/temp/wraplinux-1.7/elf32.h"
typedef struct elf32_phdr Elf32_Phdr;
#line 93 "/home/june/repo/benchmarks/collector2/temp/wraplinux-1.7/elf32.h"
struct elf32_shdr {
   Elf32_Word sh_name ;
   Elf32_Word sh_type ;
   Elf32_Word sh_flags ;
   Elf32_Addr sh_addr ;
   Elf32_Off sh_offset ;
   Elf32_Word sh_size ;
   Elf32_Word sh_link ;
   Elf32_Word sh_info ;
   Elf32_Word sh_addralign ;
   Elf32_Word sh_entsize ;
};
#line 93 "/home/june/repo/benchmarks/collector2/temp/wraplinux-1.7/elf32.h"
typedef struct elf32_shdr Elf32_Shdr;
#line 26 "/home/june/repo/benchmarks/collector2/temp/wraplinux-1.7/segment.h"
typedef uint32_t addr_t;
#line 28 "/home/june/repo/benchmarks/collector2/temp/wraplinux-1.7/segment.h"
struct segment {
   struct segment *next ;
   size_t length ;
   int align ;
   addr_t address ;
   uint32_t sh_type ;
   uint32_t sh_flags ;
   char const   *name ;
   void const   *data ;
};
#line 30 "/home/june/repo/benchmarks/collector2/temp/wraplinux-1.7/wraplinux.h"
struct opt {
   char const   *params ;
   int (*output)(struct segment * , addr_t  , FILE * ) ;
   _Bool loadhigh ;
};
#line 22 "/home/june/repo/benchmarks/collector2/temp/wraplinux-1.7/multiboot.h"
struct multiboot_header {
   uint32_t magic ;
   uint32_t flags ;
   uint32_t checksum ;
   uint32_t header_addr ;
   uint32_t load_addr ;
   uint32_t load_end_addr ;
   uint32_t entry_addr ;
   uint32_t mode_type ;
   uint32_t width ;
   uint32_t height ;
   uint32_t depth ;
};
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 79 "/usr/include/stdio.h"
typedef __gnuc_va_list va_list;
#line 48 "/usr/include/stdint.h"
typedef unsigned char uint8_t;
#line 55 "/usr/include/stdint.h"
typedef unsigned long uint64_t;
#line 6 "/home/june/repo/benchmarks/collector2/temp/wraplinux-1.7/setup.h"
struct startup_info {
   uint32_t rd_addr ;
   uint32_t rd_len ;
   uint32_t rd_maxaddr ;
   uint32_t setup_addr ;
   uint32_t cmdline_addr ;
   uint32_t reloc_size ;
};
#line 15 "/home/june/repo/benchmarks/collector2/temp/wraplinux-1.7/setup.h"
struct highmove {
   uint32_t dst ;
   uint32_t src ;
   uint32_t len ;
};
#line 21 "/home/june/repo/benchmarks/collector2/temp/wraplinux-1.7/setup.h"
struct highmove_info {
   uint32_t mv_entry ;
   struct highmove mv[3] ;
};
#line 29 "/home/june/repo/benchmarks/collector2/temp/wraplinux-1.7/setup.h"
struct setup_header {
   uint8_t setup_sects ;
   uint16_t root_flags ;
   uint32_t syssize ;
   uint16_t ram_size ;
   uint16_t vid_mode ;
   uint16_t root_dev ;
   uint16_t boot_flag ;
   uint16_t jump ;
   uint32_t header ;
   uint16_t version ;
   uint32_t realmode_swtch ;
   uint16_t start_sys ;
   uint16_t kernel_version ;
   uint8_t type_of_loader ;
   uint8_t loadflags ;
   uint16_t setup_move_size ;
   uint32_t code32_start ;
   uint32_t ramdisk_image ;
   uint32_t ramdisk_size ;
   uint32_t bootsect_kludge ;
   uint16_t heap_end_ptr ;
   uint16_t _pad1 ;
   uint32_t cmd_line_ptr ;
   uint32_t initrd_addr_max ;
   uint32_t kernel_alignment ;
   uint8_t relocatable_kernel ;
   uint8_t _pad2[3] ;
   uint32_t cmdline_size ;
   uint32_t hardware_subarch ;
   uint64_t hardware_subarch_data ;
} __attribute__((__packed__)) ;
#line 36 "/home/june/repo/benchmarks/collector2/temp/wraplinux-1.7/wraplinux.h"
struct string_list {
   struct string_list *next ;
   char const   *str ;
};
#line 104 "/home/june/repo/benchmarks/collector2/temp/wraplinux-1.7/linux.c"
struct initrd_info {
   int fd ;
   struct segment seg ;
};
#line 124 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 126 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 127 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 130 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 158 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 26 "/home/june/repo/benchmarks/collector2/temp/wraplinux-1.7/nbi.h"
struct nbi_header {
   uint32_t magic ;
   uint32_t flags ;
   uint16_t header_off ;
   uint16_t header_seg ;
   uint32_t entry ;
};
#line 36 "/home/june/repo/benchmarks/collector2/temp/wraplinux-1.7/nbi.h"
struct nbi_image_header {
   uint8_t lengths ;
   uint8_t tags ;
   uint8_t resv ;
   uint8_t flags ;
   uint32_t load_addr ;
   uint32_t filesz ;
   uint32_t memsz ;
};
#line 104 "/usr/include/getopt.h"
struct option {
   char const   *name ;
   int has_arg ;
   int *flag ;
   int val ;
};
#line 55 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdint-gcc.h"
typedef unsigned long long uint64_t___0;
#line 86 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdint-gcc.h"
typedef unsigned int uintptr_t;
#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned int size_t___0;
#line 58 "./reloc/reloc.h"
union __anonunion_reg32_t_1 {
   uint32_t l ;
   uint16_t w[2] ;
   uint8_t b[4] ;
};
#line 58 "./reloc/reloc.h"
typedef union __anonunion_reg32_t_1 reg32_t;
#line 64 "./reloc/reloc.h"
struct __anonstruct_com32sys_t_2 {
   uint16_t gs ;
   uint16_t fs ;
   uint16_t es ;
   uint16_t ds ;
   reg32_t edi ;
   reg32_t esi ;
   reg32_t ebp ;
   reg32_t _unused_esp ;
   reg32_t ebx ;
   reg32_t edx ;
   reg32_t ecx ;
   reg32_t eax ;
   reg32_t eflags ;
};
#line 64 "./reloc/reloc.h"
typedef struct __anonstruct_com32sys_t_2 com32sys_t;
#line 29 "./setup.h"
struct setup_header___0 {
   uint8_t setup_sects ;
   uint16_t root_flags ;
   uint32_t syssize ;
   uint16_t ram_size ;
   uint16_t vid_mode ;
   uint16_t root_dev ;
   uint16_t boot_flag ;
   uint16_t jump ;
   uint32_t header ;
   uint16_t version ;
   uint32_t realmode_swtch ;
   uint16_t start_sys ;
   uint16_t kernel_version ;
   uint8_t type_of_loader ;
   uint8_t loadflags ;
   uint16_t setup_move_size ;
   uint32_t code32_start ;
   uint32_t ramdisk_image ;
   uint32_t ramdisk_size ;
   uint32_t bootsect_kludge ;
   uint16_t heap_end_ptr ;
   uint16_t _pad1 ;
   uint32_t cmd_line_ptr ;
   uint32_t initrd_addr_max ;
   uint32_t kernel_alignment ;
   uint8_t relocatable_kernel ;
   uint8_t _pad2[3] ;
   uint32_t cmdline_size ;
   uint32_t hardware_subarch ;
   uint64_t___0 hardware_subarch_data ;
} __attribute__((__packed__)) ;
#line 74 "/home/june/repo/benchmarks/collector2/temp/wraplinux-1.7/reloc/reloc_linux.c"
struct e820_info {
   uint64_t___0 base ;
   uint64_t___0 len ;
   uint32_t type ;
};
#line 39 "/home/june/repo/benchmarks/collector2/temp/wraplinux-1.7/segment.h"
struct segment *sort_segments(struct segment *list ) ;
#line 40
int output_elf(struct segment *segs , addr_t entry , FILE *out ) ;
#line 41
int output_multiboot(struct segment *segs , addr_t entry , FILE *out ) ;
#line 30 "/home/june/repo/benchmarks/collector2/temp/wraplinux-1.7/wraplinux.h"
struct opt opt  ;
#line 42 "/home/june/repo/benchmarks/collector2/temp/wraplinux-1.7/wraplinux.h"
__inline static addr_t align_up(addr_t addr , int align ) 
{ 
  addr_t align_mask ;

  {
#line 44
  align_mask = (1U << align) - 1U;
#line 45
  return ((addr + align_mask) & ~ align_mask);
}
}
#line 74
size_t c_fwrite(void const   *ptr , size_t bytes , FILE *stream ) ;
#line 75
size_t c_writezero(size_t n , FILE *stream ) ;
#line 69 "/usr/include/assert.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) __assert_fail)(char const   *__assertion ,
                                                                                                   char const   *__file ,
                                                                                                   unsigned int __line ,
                                                                                                   char const   *__function ) ;
#line 66 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 43 "/home/june/repo/benchmarks/collector2/temp/wraplinux-1.7/le.h"
__inline static void wrle16(uint16_t v , uint16_t *p ) 
{ 


  {
#line 45
  *p = v;
#line 46
  return;
}
}
#line 48 "/home/june/repo/benchmarks/collector2/temp/wraplinux-1.7/le.h"
__inline static void wrle32(uint32_t v , uint32_t *p ) 
{ 


  {
#line 50
  *p = v;
#line 51
  return;
}
}
#line 32 "/home/june/repo/benchmarks/collector2/temp/wraplinux-1.7/elf.c"
__inline static uint32_t p_type(struct segment  const  *s ) 
{ 
  int tmp ;

  {
  {
#line 36
  if (s->sh_type == 8U) {
#line 36
    goto case_8;
  }
#line 36
  if (s->sh_type == 1U) {
#line 36
    goto case_8;
  }
#line 38
  if (s->sh_type == 7U) {
#line 38
    goto case_7;
  }
#line 40
  goto switch_default;
  case_8: /* CIL Label */ 
  case_1: /* CIL Label */ 
#line 37
  if (s->sh_flags & 2U) {
#line 37
    tmp = 1;
  } else {
#line 37
    tmp = 0;
  }
#line 37
  return ((uint32_t )tmp);
  case_7: /* CIL Label */ 
#line 39
  return ((uint32_t )4);
  switch_default: /* CIL Label */ 
#line 41
  return ((uint32_t )0);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 48 "/home/june/repo/benchmarks/collector2/temp/wraplinux-1.7/elf.c"
static _Bool merge_phdrs(struct segment  const  *s ) 
{ 
  struct segment  const  *n ;
  uint32_t tmp ;
  uint32_t tmp___0 ;
  addr_t tmp___1 ;

  {
#line 50
  n = (struct segment  const  *)s->next;
#line 52
  if (! n) {
#line 53
    return ((_Bool)0);
  }
  {
#line 55
  tmp = p_type(s);
  }
#line 55
  if (tmp != 1U) {
#line 56
    return ((_Bool)0);
  } else {
    {
#line 55
    tmp___0 = p_type(n);
    }
#line 55
    if (tmp___0 != 1U) {
#line 56
      return ((_Bool)0);
    }
  }
#line 58
  if (s->sh_type != n->sh_type) {
#line 59
    return ((_Bool)0);
  }
#line 61
  if (s->sh_flags != n->sh_flags) {
#line 62
    return ((_Bool)0);
  }
#line 64
  if (s->align < n->align) {
#line 65
    return ((_Bool)0);
  }
  {
#line 67
  tmp___1 = align_up((addr_t )((size_t const   )s->address + s->length), (int )n->align);
  }
#line 67
  if (n->address != (addr_t const   )tmp___1) {
#line 68
    return ((_Bool)0);
  }
#line 70
  return ((_Bool)1);
}
}
#line 73 "/home/june/repo/benchmarks/collector2/temp/wraplinux-1.7/elf.c"
static int gen_elf(struct segment *segs , Elf32_Ehdr *ehdr , FILE *out ) 
{ 
  Elf32_Shdr shdr ;
  Elf32_Phdr phdr ;
  int nsections ;
  int npheader ;
  int namebytes ;
  struct segment *s ;
  uint32_t data_start ;
  uint32_t data_offset ;
  uint32_t file_offset ;
  uint32_t name_offset ;
  size_t tmp ;
  uint32_t memsize ;
  addr_t align ;
  addr_t address ;
  addr_t pad ;
  uint32_t tmp___0 ;
  _Bool tmp___1 ;
  size_t tmp___2 ;
  uint32_t filesize ;
  uint32_t memsize___0 ;
  uint32_t ptype ;
  uint32_t tmp___3 ;
  uint32_t p_flags ;
  uint32_t align___0 ;
  addr_t address___0 ;
  addr_t offset ;
  addr_t pad___0 ;
  _Bool tmp___4 ;
  size_t tmp___5 ;
  uint32_t align___1 ;
  uint32_t pad___1 ;
  size_t tmp___6 ;
  size_t tmp___7 ;
  size_t tmp___8 ;
  uint32_t len ;
  size_t tmp___9 ;
  size_t tmp___10 ;
  size_t tmp___11 ;
  size_t tmp___12 ;
  uint32_t align___2 ;
  uint32_t tmp___13 ;
  size_t tmp___14 ;
  size_t tmp___15 ;

  {
#line 77
  nsections = 0;
#line 77
  npheader = 0;
#line 78
  namebytes = 11;
#line 83
  s = segs;
  {
#line 83
  while (1) {
    while_continue: /* CIL Label */ ;
#line 83
    if (! s) {
#line 83
      goto while_break;
    }
#line 84
    nsections ++;
#line 85
    if (s->name) {
      {
#line 86
      tmp = strlen(s->name);
#line 86
      namebytes = (int )((size_t )namebytes + (tmp + 1UL));
      }
    }
#line 83
    s = s->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 89
  s = segs;
  {
#line 89
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 89
    if (! s) {
#line 89
      goto while_break___0;
    }
    {
#line 91
    align = 1U << s->align;
#line 94
    tmp___0 = p_type((struct segment  const  *)s);
    }
#line 94
    if (tmp___0 == 0U) {
#line 95
      goto __Cont;
    }
#line 97
    npheader ++;
#line 99
    address = s->address;
#line 100
    memsize = (uint32_t )s->length;
    {
#line 102
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 102
      tmp___1 = merge_phdrs((struct segment  const  *)s);
      }
#line 102
      if (! tmp___1) {
#line 102
        goto while_break___1;
      }
#line 103
      s = s->next;
#line 104
      align = 1U << s->align;
#line 105
      pad = (s->address - (address + memsize)) & (align - 1U);
#line 106
      memsize = (uint32_t )((size_t )memsize + ((size_t )pad + s->length));
    }
    while_break___1: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
#line 89
    s = s->next;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 110
  wrle16((uint16_t )sizeof(phdr), & ehdr->e_phentsize);
#line 111
  wrle16((uint16_t )npheader, & ehdr->e_phnum);
#line 112
  wrle16((uint16_t )sizeof(shdr), & ehdr->e_shentsize);
#line 113
  wrle16((uint16_t )(nsections + 2), & ehdr->e_shnum);
#line 114
  wrle16((uint16_t )(nsections + 1), & ehdr->e_shstrndx);
#line 115
  tmp___2 = c_fwrite((void const   *)ehdr, sizeof(*ehdr), out);
#line 115
  file_offset = (uint32_t )tmp___2;
#line 118
  data_start = (uint32_t )(sizeof(*ehdr) + (unsigned long )npheader * sizeof(phdr));
#line 121
  data_offset = data_start;
#line 122
  s = segs;
  }
  {
#line 122
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 122
    if (! s) {
#line 122
      goto while_break___2;
    }
    {
#line 124
    tmp___3 = p_type((struct segment  const  *)s);
#line 124
    ptype = tmp___3;
#line 126
    align___0 = 1U << s->align;
    }
#line 129
    if (s->sh_type == 8U) {
#line 129
      filesize = (uint32_t )0;
    } else {
#line 129
      filesize = (uint32_t )s->length;
    }
#line 130
    if (s->sh_flags & 2U) {
#line 130
      memsize___0 = (uint32_t )s->length;
    } else {
#line 130
      memsize___0 = (uint32_t )0;
    }
#line 132
    if (s->sh_type == 8U) {
#line 133
      pad___0 = (addr_t )0;
    } else {
#line 135
      pad___0 = (s->address - data_offset) & (align___0 - 1U);
    }
#line 137
    data_offset += pad___0;
#line 139
    if (ptype != 0U) {
#line 140
      p_flags = (uint32_t )0;
#line 141
      if (s->sh_flags & 2U) {
#line 142
        p_flags |= 4U;
      }
#line 143
      if (s->sh_flags & 4U) {
#line 144
        p_flags |= 1U;
      }
#line 145
      if (s->sh_flags & 1U) {
#line 146
        p_flags |= 2U;
      }
      {
#line 148
      memset((void *)(& phdr), 0, sizeof(phdr));
#line 149
      wrle32(ptype, & phdr.p_type);
#line 150
      wrle32(data_offset, & phdr.p_offset);
#line 151
      wrle32(s->address, & phdr.p_vaddr);
#line 152
      wrle32(s->address, & phdr.p_paddr);
#line 153
      wrle32(p_flags, & phdr.p_flags);
#line 154
      wrle32(align___0, & phdr.p_align);
#line 156
      address___0 = s->address;
#line 157
      offset = data_offset + filesize;
      }
      {
#line 159
      while (1) {
        while_continue___3: /* CIL Label */ ;
        {
#line 159
        tmp___4 = merge_phdrs((struct segment  const  *)s);
        }
#line 159
        if (! tmp___4) {
#line 159
          goto while_break___3;
        }
#line 160
        s = s->next;
#line 161
        align___0 = 1U << s->align;
#line 162
        pad___0 = (s->address - (address___0 + memsize___0)) & (align___0 - 1U);
#line 164
        if (s->sh_type != 8U) {
#line 165
          if (! (pad___0 == ((s->address - offset) & (align___0 - 1U)))) {
            {
#line 165
            __assert_fail("pad == ((s->address - offset) & (align-1))", "/home/june/repo/benchmarks/collector2/temp/wraplinux-1.7/elf.c",
                          166U, "gen_elf");
            }
          }
#line 167
          filesize = (uint32_t )((size_t )filesize + (s->length + (size_t )pad___0));
#line 168
          offset = (addr_t )((size_t )offset + (s->length + (size_t )pad___0));
        }
#line 170
        memsize___0 = (uint32_t )((size_t )memsize___0 + (s->length + (size_t )pad___0));
      }
      while_break___3: /* CIL Label */ ;
      }
      {
#line 173
      wrle32(filesize, & phdr.p_filesz);
#line 174
      wrle32(memsize___0, & phdr.p_memsz);
#line 176
      tmp___5 = c_fwrite((void const   *)(& phdr), sizeof(phdr), out);
#line 176
      file_offset = (uint32_t )((size_t )file_offset + tmp___5);
      }
    }
#line 178
    data_offset += filesize;
#line 122
    s = s->next;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 182
  if (! (file_offset == data_start)) {
    {
#line 182
    __assert_fail("file_offset == data_start", "/home/june/repo/benchmarks/collector2/temp/wraplinux-1.7/elf.c",
                  182U, "gen_elf");
    }
  }
#line 183
  s = segs;
  {
#line 183
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 183
    if (! s) {
#line 183
      goto while_break___4;
    }
#line 184
    if (s->sh_type != 8U) {
      {
#line 185
      align___1 = 1U << s->align;
#line 186
      pad___1 = (s->address - file_offset) & (align___1 - 1U);
#line 187
      tmp___6 = c_writezero((size_t )pad___1, out);
#line 187
      file_offset = (uint32_t )((size_t )file_offset + tmp___6);
#line 188
      tmp___7 = c_fwrite(s->data, s->length, out);
#line 188
      file_offset = (uint32_t )((size_t )file_offset + tmp___7);
      }
    }
#line 183
    s = s->next;
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 193
  tmp___8 = c_fwrite((void const   *)"", (size_t )1, out);
#line 193
  file_offset = (uint32_t )((size_t )file_offset + tmp___8);
#line 194
  s = segs;
  }
  {
#line 194
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 194
    if (! s) {
#line 194
      goto while_break___5;
    }
    {
#line 195
    tmp___9 = strlen(s->name);
#line 195
    len = (uint32_t )(tmp___9 + 1UL);
#line 196
    tmp___10 = c_fwrite((void const   *)s->name, (size_t )len, out);
#line 196
    file_offset = (uint32_t )((size_t )file_offset + tmp___10);
#line 194
    s = s->next;
    }
  }
  while_break___5: /* CIL Label */ ;
  }
  {
#line 198
  tmp___11 = c_fwrite((void const   *)".shstrtab", (size_t )10, out);
#line 198
  file_offset = (uint32_t )((size_t )file_offset + tmp___11);
#line 201
  tmp___12 = c_writezero((size_t )(- file_offset & 3U), out);
#line 201
  file_offset = (uint32_t )((size_t )file_offset + tmp___12);
#line 204
  wrle32(file_offset, & ehdr->e_shoff);
#line 206
  data_offset = data_start;
#line 208
  memset((void *)(& shdr), 0, sizeof(shdr));
#line 209
  c_fwrite((void const   *)(& shdr), sizeof(shdr), out);
#line 211
  name_offset = (uint32_t )1;
#line 212
  s = segs;
  }
  {
#line 212
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 212
    if (! s) {
#line 212
      goto while_break___6;
    }
#line 213
    align___2 = 1U << s->align;
#line 215
    if (s->sh_type != 8U) {
#line 216
      data_offset += (s->address - data_offset) & (align___2 - 1U);
    }
    {
#line 218
    memset((void *)(& shdr), 0, sizeof(shdr));
    }
#line 219
    if (s->name) {
#line 219
      tmp___13 = name_offset;
    } else {
#line 219
      tmp___13 = (uint32_t )0;
    }
    {
#line 219
    wrle32(tmp___13, & shdr.sh_name);
#line 220
    wrle32(s->sh_type, & shdr.sh_type);
#line 221
    wrle32(s->sh_flags, & shdr.sh_flags);
#line 222
    wrle32(s->address, & shdr.sh_addr);
#line 223
    wrle32(data_offset, & shdr.sh_offset);
#line 224
    wrle32((uint32_t )s->length, & shdr.sh_size);
#line 225
    wrle32(align___2, & shdr.sh_addralign);
#line 227
    tmp___14 = c_fwrite((void const   *)(& shdr), sizeof(shdr), out);
#line 227
    file_offset = (uint32_t )((size_t )file_offset + tmp___14);
    }
#line 229
    if (s->name) {
      {
#line 230
      tmp___15 = strlen(s->name);
#line 230
      name_offset = (uint32_t )((size_t )name_offset + (tmp___15 + 1UL));
      }
    }
#line 232
    if (s->sh_type != 8U) {
#line 233
      data_offset = (uint32_t )((size_t )data_offset + s->length);
    }
#line 212
    s = s->next;
  }
  while_break___6: /* CIL Label */ ;
  }
  {
#line 237
  memset((void *)(& shdr), 0, sizeof(shdr));
#line 238
  wrle32(name_offset, & shdr.sh_name);
#line 239
  wrle32((uint32_t )3, & shdr.sh_type);
#line 240
  wrle32(data_offset, & shdr.sh_offset);
#line 241
  wrle32((uint32_t )namebytes, & shdr.sh_size);
#line 242
  wrle32((uint32_t )1, & shdr.sh_addralign);
#line 244
  c_fwrite((void const   *)(& shdr), sizeof(shdr), out);
  }
#line 246
  return (0);
}
}
#line 250 "/home/june/repo/benchmarks/collector2/temp/wraplinux-1.7/elf.c"
static int do_elf(struct segment *segs , addr_t entry , FILE *out ) 
{ 
  Elf32_Ehdr ehdr ;
  int rv ;
  int tmp ;

  {
  {
#line 255
  memset((void *)(& ehdr), 0, sizeof(ehdr));
#line 257
  ehdr.e_ident[0] = (unsigned char)127;
#line 258
  ehdr.e_ident[1] = (unsigned char )'E';
#line 259
  ehdr.e_ident[2] = (unsigned char )'L';
#line 260
  ehdr.e_ident[3] = (unsigned char )'F';
#line 261
  ehdr.e_ident[4] = (unsigned char)1;
#line 262
  ehdr.e_ident[5] = (unsigned char)1;
#line 263
  ehdr.e_ident[6] = (unsigned char)1;
#line 264
  ehdr.e_ident[7] = (unsigned char)255;
#line 266
  wrle16((uint16_t )2, & ehdr.e_type);
#line 267
  wrle16((uint16_t )3, & ehdr.e_machine);
#line 268
  wrle32((uint32_t )1, & ehdr.e_version);
#line 269
  wrle32((uint32_t )sizeof(ehdr), & ehdr.e_phoff);
#line 270
  wrle32(entry, & ehdr.e_entry);
#line 271
  wrle16((uint16_t )sizeof(ehdr), & ehdr.e_ehsize);
#line 274
  rv = gen_elf(segs, & ehdr, (FILE *)((void *)0));
  }
#line 275
  if (rv) {
#line 276
    return (rv);
  }
  {
#line 279
  tmp = gen_elf(segs, & ehdr, out);
  }
#line 279
  return (tmp);
}
}
#line 282 "/home/june/repo/benchmarks/collector2/temp/wraplinux-1.7/elf.c"
int output_elf(struct segment *segs , addr_t entry , FILE *out ) 
{ 
  int tmp ;

  {
  {
#line 284
  segs = sort_segments(segs);
#line 285
  tmp = do_elf(segs, entry, out);
  }
#line 285
  return (tmp);
}
}
#line 288 "/home/june/repo/benchmarks/collector2/temp/wraplinux-1.7/elf.c"
int output_multiboot(struct segment *segs , addr_t entry , FILE *out ) 
{ 
  struct segment mb_seg ;
  struct multiboot_header mb_hdr ;
  uint32_t magic ;
  uint32_t flags ;
  uint32_t csum ;
  int tmp ;

  {
  {
#line 294
  segs = sort_segments(segs);
#line 298
  mb_seg.next = segs;
#line 299
  mb_seg.length = sizeof(mb_hdr);
#line 300
  mb_seg.align = 2;
#line 301
  mb_seg.address = (addr_t )0;
#line 302
  mb_seg.sh_type = (uint32_t )1;
#line 303
  mb_seg.sh_flags = (uint32_t )0;
#line 304
  mb_seg.name = ".multiboot";
#line 305
  mb_seg.data = (void const   *)(& mb_hdr);
#line 306
  segs = & mb_seg;
#line 309
  magic = (uint32_t )464367618;
#line 310
  flags = (uint32_t )1;
#line 312
  memset((void *)(& mb_hdr), 0, sizeof(mb_hdr));
#line 313
  wrle32(magic, & mb_hdr.magic);
#line 314
  wrle32(flags, & mb_hdr.flags);
#line 316
  csum = magic + flags;
#line 317
  wrle32(- csum, & mb_hdr.checksum);
#line 320
  tmp = do_elf(segs, entry, out);
  }
#line 320
  return (tmp);
}
}
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 468
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) calloc)(size_t __nmemb ,
                                                                               size_t __size )  __attribute__((__malloc__)) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 399
extern  __attribute__((__nothrow__)) int ( /* format attribute */  vasprintf)(char ** __restrict  __ptr ,
                                                                              char const   * __restrict  __f ,
                                                                              __gnuc_va_list __arg ) ;
#line 28 "/home/june/repo/benchmarks/collector2/temp/wraplinux-1.7/wraplinux.h"
char const   *program ;
#line 69
void *xmalloc(size_t size ) ;
#line 70
void *xcalloc(size_t nmemb , size_t size ) ;
#line 71
int xasprintf(char **strp , char const   *fmt  , ...) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 413 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
#line 14 "/home/june/repo/benchmarks/collector2/temp/wraplinux-1.7/xmalloc.c"
void *xmalloc(size_t size ) 
{ 
  void *p ;
  void *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 16
  tmp = malloc(size);
#line 16
  p = tmp;
  }
#line 18
  if (! p) {
    {
#line 19
    tmp___0 = __errno_location();
#line 19
    tmp___1 = strerror(*tmp___0);
#line 19
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s\n",
            program, tmp___1);
#line 20
    exit(71);
    }
  }
#line 23
  return (p);
}
}
#line 26 "/home/june/repo/benchmarks/collector2/temp/wraplinux-1.7/xmalloc.c"
void *xcalloc(size_t nmemb , size_t size ) 
{ 
  void *p ;
  void *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 28
  tmp = calloc(nmemb, size);
#line 28
  p = tmp;
  }
#line 30
  if (! p) {
    {
#line 31
    tmp___0 = __errno_location();
#line 31
    tmp___1 = strerror(*tmp___0);
#line 31
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s\n",
            program, tmp___1);
#line 32
    exit(71);
    }
  }
#line 35
  return (p);
}
}
#line 38 "/home/june/repo/benchmarks/collector2/temp/wraplinux-1.7/xmalloc.c"
int xasprintf(char **strp , char const   *fmt  , ...) 
{ 
  va_list va ;
  int n ;
  int *tmp ;
  char *tmp___0 ;

  {
  {
#line 43
  __builtin_va_start(va, fmt);
#line 44
  n = vasprintf((char **/* __restrict  */)strp, (char const   */* __restrict  */)fmt,
                va);
#line 45
  __builtin_va_end(va);
  }
#line 47
  if (n < 0) {
    {
#line 48
    tmp = __errno_location();
#line 48
    tmp___0 = strerror(*tmp);
#line 48
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s\n",
            program, tmp___0);
#line 49
    exit(71);
    }
  }
#line 52
  return (n);
}
}
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 187 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) unsigned long ( __attribute__((__nonnull__(1),
__leaf__)) strtoul)(char const   * __restrict  __nptr , char ** __restrict  __endptr ,
                    int __base ) ;
#line 214
extern  __attribute__((__nothrow__)) unsigned long long ( __attribute__((__nonnull__(1),
__leaf__)) strtoull)(char const   * __restrict  __nptr , char ** __restrict  __endptr ,
                     int __base ) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 69 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) memcmp)(void const   *__s1 ,
                                                                                               void const   *__s2 ,
                                                                                               size_t __n )  __attribute__((__pure__)) ;
#line 146 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 28 "/home/june/repo/benchmarks/collector2/temp/wraplinux-1.7/le.h"
__inline static uint16_t rdle16(uint16_t const   *p ) 
{ 


  {
#line 30
  return ((uint16_t )*p);
}
}
#line 33 "/home/june/repo/benchmarks/collector2/temp/wraplinux-1.7/le.h"
__inline static uint32_t rdle32(uint32_t const   *p ) 
{ 


  {
#line 35
  return ((uint32_t )*p);
}
}
#line 61 "/home/june/repo/benchmarks/collector2/temp/wraplinux-1.7/wraplinux.h"
int wrap_kernel(char const   *kernel_file , char const   *cmdline , struct string_list  const  *initrd_list ,
                FILE *out ) ;
#line 65
void *mapfile(int fd , size_t *len , _Bool writable ) ;
#line 66
void unmapfile(int fd , void *ptr , size_t len ) ;
#line 36 "/home/june/repo/benchmarks/collector2/temp/wraplinux-1.7/linux.c"
extern char reloc[] ;
#line 37
extern uint32_t reloc_size ;
#line 38
extern char highmove[] ;
#line 39
extern uint32_t highmove_size ;
#line 43 "/home/june/repo/benchmarks/collector2/temp/wraplinux-1.7/linux.c"
static char const   *find_argument(char const   *cmdline , char const   *argument ) 
{ 
  int la ;
  size_t tmp ;
  char const   *p ;
  int wasspace ;
  int tmp___0 ;
  unsigned short const   **tmp___1 ;
  char const   *tmp___2 ;

  {
  {
#line 45
  tmp = strlen(argument);
#line 45
  la = (int )tmp;
#line 46
  p = cmdline;
#line 47
  wasspace = 1;
  }
  {
#line 49
  while (1) {
    while_continue: /* CIL Label */ ;
#line 49
    if (! *p) {
#line 49
      goto while_break;
    }
#line 50
    if (wasspace) {
      {
#line 50
      tmp___0 = memcmp((void const   *)p, (void const   *)argument, (size_t )la);
      }
#line 50
      if (! tmp___0) {
#line 51
        return (p + la);
      }
    }
    {
#line 53
    tmp___1 = __ctype_b_loc();
#line 53
    tmp___2 = p;
#line 53
    p ++;
#line 53
    wasspace = (int )((int const   )*(*tmp___1 + (int )*tmp___2) & 8192);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 56
  return ((char const   *)((void *)0));
}
}
#line 60 "/home/june/repo/benchmarks/collector2/temp/wraplinux-1.7/linux.c"
__inline static uint32_t saturate32(unsigned long long v ) 
{ 
  unsigned int tmp ;

  {
#line 62
  if (v > 4294967295ULL) {
#line 62
    tmp = 4294967295U;
  } else {
#line 62
    tmp = (uint32_t )v;
  }
#line 62
  return (tmp);
}
}
#line 66 "/home/june/repo/benchmarks/collector2/temp/wraplinux-1.7/linux.c"
static unsigned long long suffix_number(char const   *str ) 
{ 
  char *ep ;
  unsigned long long v ;
  int shift ;

  {
  {
#line 72
  v = strtoull((char const   */* __restrict  */)str, (char **/* __restrict  */)(& ep),
               0);
  }
  {
#line 74
  if (((int )*ep | 32) == 107) {
#line 74
    goto case_107;
  }
#line 77
  if (((int )*ep | 32) == 109) {
#line 77
    goto case_109;
  }
#line 80
  if (((int )*ep | 32) == 103) {
#line 80
    goto case_103;
  }
#line 83
  if (((int )*ep | 32) == 116) {
#line 83
    goto case_116;
  }
#line 86
  if (((int )*ep | 32) == 112) {
#line 86
    goto case_112;
  }
#line 89
  if (((int )*ep | 32) == 101) {
#line 89
    goto case_101;
  }
#line 92
  goto switch_default;
  case_107: /* CIL Label */ 
#line 75
  shift = 10;
#line 76
  goto switch_break;
  case_109: /* CIL Label */ 
#line 78
  shift = 20;
#line 79
  goto switch_break;
  case_103: /* CIL Label */ 
#line 81
  shift = 30;
#line 82
  goto switch_break;
  case_116: /* CIL Label */ 
#line 84
  shift = 40;
#line 85
  goto switch_break;
  case_112: /* CIL Label */ 
#line 87
  shift = 50;
#line 88
  goto switch_break;
  case_101: /* CIL Label */ 
#line 90
  shift = 60;
#line 91
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 93
  shift = 0;
#line 94
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 96
  v <<= shift;
#line 98
  return (v);
}
}
#line 101 "/home/june/repo/benchmarks/collector2/temp/wraplinux-1.7/linux.c"
int wrap_kernel(char const   *kernel_file , char const   *cmdline , struct string_list  const  *initrd_list ,
                FILE *out ) 
{ 
  struct initrd_info *ird ;
  int kernel_fd ;
  char *kernel ;
  size_t kernel_len ;
  struct segment srel ;
  struct segment ssup ;
  struct segment scmd ;
  struct segment skrn ;
  struct segment shmv ;
  struct startup_info *info ;
  struct setup_header *hdr ;
  struct highmove_info *hmv ;
  size_t setup_len ;
  size_t initrd_len___0 ;
  size_t initrd_addr___0 ;
  int rv ;
  int ninitrd ;
  int i ;
  struct string_list  const  *ip ;
  int setup_ver ;
  int setup_space ;
  char const   *cmd ;
  uint32_t initrd_max ;
  uint32_t entry ;
  int *tmp ;
  char *tmp___0 ;
  void *tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int *tmp___4 ;
  uint16_t tmp___5 ;
  uint32_t tmp___6 ;
  uint32_t mem ;
  unsigned long long tmp___7 ;
  uint32_t tmp___8 ;
  uint16_t vga ;
  unsigned long tmp___9 ;
  void *tmp___10 ;
  addr_t tmp___11 ;
  int *tmp___12 ;
  char *tmp___13 ;
  void *tmp___14 ;
  int *tmp___15 ;
  char *tmp___16 ;
  size_t tmp___17 ;
  uint32_t rm_base ;
  uint32_t rm_len ;
  uint32_t delta ;
  addr_t tmp___18 ;
  char *name ;
  addr_t tmp___19 ;
  addr_t tmp___20 ;

  {
  {
#line 104
  ird = (struct initrd_info *)((void *)0);
#line 108
  kernel_fd = -1;
#line 109
  kernel = (char *)((void *)0);
#line 110
  kernel_len = (size_t )0;
#line 112
  info = (struct startup_info *)((void *)(reloc));
#line 114
  hmv = (struct highmove_info *)((void *)(highmove));
#line 118
  rv = 70;
#line 119
  ninitrd = 0;
#line 130
  kernel_fd = open(kernel_file, 0);
  }
#line 131
  if (kernel_fd < 0) {
    {
#line 132
    tmp = __errno_location();
#line 132
    tmp___0 = strerror(*tmp);
#line 132
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s: %s\n",
            program, kernel_file, tmp___0);
#line 134
    rv = 66;
    }
#line 135
    goto err;
  }
  {
#line 138
  tmp___1 = mapfile(kernel_fd, & kernel_len, (_Bool)1);
#line 138
  kernel = (char *)tmp___1;
  }
#line 139
  if (! kernel) {
    {
#line 140
    tmp___2 = __errno_location();
#line 140
    tmp___3 = strerror(*tmp___2);
#line 140
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s: %s\n",
            program, kernel_file, tmp___3);
#line 142
    rv = 66;
    }
#line 143
    goto err;
  }
#line 146
  if (kernel_len < 1024UL) {
    {
#line 147
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s: kernel file too small\n",
            program, kernel_file);
#line 149
    rv = 66;
#line 150
    tmp___4 = __errno_location();
#line 150
    *tmp___4 = 22;
    }
#line 151
    goto err;
  }
#line 156
  hdr = (struct setup_header *)(kernel + 497);
#line 157
  setup_len = (size_t )(((int )hdr->setup_sects + 1) << 9);
#line 158
  if (setup_len == 512UL) {
#line 159
    setup_len += 2048UL;
  }
  {
#line 161
  tmp___6 = rdle32((uint32_t const   *)(& hdr->header));
  }
#line 161
  if (tmp___6 != (uint32_t )(((72 + (100 << 8)) + (114 << 16)) + (83 << 24))) {
#line 162
    setup_ver = 0;
  } else {
    {
#line 164
    tmp___5 = rdle16((uint16_t const   *)(& hdr->version));
#line 164
    setup_ver = (int )tmp___5;
    }
  }
#line 166
  if (setup_ver >= 512) {
#line 166
    if ((int )hdr->loadflags & 1) {
#line 167
      skrn.address = (addr_t )1048576;
#line 168
      ssup.address = (addr_t )65536;
#line 169
      if (setup_ver >= 514) {
#line 169
        setup_space = 65536;
      } else {
#line 169
        setup_space = 40960;
      }
    } else {
#line 171
      skrn.address = (addr_t )65536;
#line 172
      ssup.address = (addr_t )589824;
#line 173
      setup_space = 40960;
    }
  } else {
#line 171
    skrn.address = (addr_t )65536;
#line 172
    ssup.address = (addr_t )589824;
#line 173
    setup_space = 40960;
  }
#line 176
  if (setup_ver <= 512) {
#line 177
    initrd_list = (struct string_list  const  *)((void *)0);
  }
#line 179
  if (setup_ver >= 515) {
    {
#line 180
    initrd_max = rdle32((uint32_t const   *)(& hdr->initrd_addr_max));
    }
  } else {
#line 182
    initrd_max = (uint32_t )939524095;
  }
  {
#line 184
  cmd = find_argument(cmdline, "mem=");
  }
#line 184
  if (cmd) {
    {
#line 185
    tmp___7 = suffix_number(cmd);
#line 185
    tmp___8 = saturate32(tmp___7);
#line 185
    mem = tmp___8;
    }
#line 186
    if (initrd_max >= mem) {
#line 187
      initrd_max = mem - 1U;
    }
  }
  {
#line 190
  cmd = find_argument(cmdline, "vga=");
  }
#line 190
  if (cmd) {
    {
#line 194
    if (((int const   )*(cmd + 0) | 32) == 97) {
#line 194
      goto case_97;
    }
#line 197
    if (((int const   )*(cmd + 0) | 32) == 101) {
#line 197
      goto case_101;
    }
#line 200
    if (((int const   )*(cmd + 0) | 32) == 110) {
#line 200
      goto case_110;
    }
#line 203
    goto switch_default;
    case_97: /* CIL Label */ 
#line 195
    vga = (uint16_t )65533;
#line 196
    goto switch_break;
    case_101: /* CIL Label */ 
#line 198
    vga = (uint16_t )65534;
#line 199
    goto switch_break;
    case_110: /* CIL Label */ 
#line 201
    vga = (uint16_t )65535;
#line 202
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 204
    tmp___9 = strtoul((char const   */* __restrict  */)cmd, (char **/* __restrict  */)((void *)0),
                      0);
#line 204
    vga = (uint16_t )tmp___9;
    }
#line 205
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
    {
#line 207
    wrle16(vga, & hdr->vid_mode);
    }
  }
#line 212
  ninitrd = 0;
#line 213
  ip = initrd_list;
  {
#line 213
  while (1) {
    while_continue: /* CIL Label */ ;
#line 213
    if (! ip) {
#line 213
      goto while_break;
    }
#line 214
    ninitrd ++;
#line 213
    ip = (struct string_list  const  *)ip->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 216
  if (ninitrd) {
    {
#line 217
    tmp___10 = xcalloc((size_t )ninitrd, sizeof(*ird));
#line 217
    ird = (struct initrd_info *)tmp___10;
#line 218
    i = 0;
    }
    {
#line 218
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 218
      if (! (i < ninitrd)) {
#line 218
        goto while_break___0;
      }
#line 219
      (ird + i)->fd = -1;
#line 218
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 222
  initrd_len___0 = (size_t )0;
#line 223
  ip = initrd_list;
#line 223
  i = 0;
  {
#line 223
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 223
    if (! ip) {
#line 223
      goto while_break___1;
    }
    {
#line 225
    tmp___11 = align_up((addr_t )initrd_len___0, 2);
#line 225
    initrd_len___0 = (size_t )tmp___11;
#line 227
    (ird + i)->fd = open((char const   *)ip->str, 0);
    }
#line 228
    if ((ird + i)->fd < 0) {
      {
#line 229
      tmp___12 = __errno_location();
#line 229
      tmp___13 = strerror(*tmp___12);
#line 229
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s: %s",
              program, ip->str, tmp___13);
#line 231
      rv = 66;
      }
#line 232
      goto err;
    }
    {
#line 235
    tmp___14 = mapfile((ird + i)->fd, & (ird + i)->seg.length, (_Bool)0);
#line 235
    (ird + i)->seg.data = (void const   *)tmp___14;
    }
#line 236
    if (! (ird + i)->seg.data) {
      {
#line 237
      tmp___15 = __errno_location();
#line 237
      tmp___16 = strerror(*tmp___15);
#line 237
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s: %s",
              program, ip->str, tmp___16);
#line 239
      rv = 66;
      }
#line 240
      goto err;
    }
#line 243
    initrd_len___0 += (ird + i)->seg.length;
#line 223
    ip = (struct string_list  const  *)ip->next;
#line 223
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 249
  srel.next = & ssup;
#line 250
  srel.address = (addr_t )((((size_t )ssup.address + setup_len) + 15UL) & 0xfffffffffffffff0UL);
#line 251
  srel.align = 4;
#line 252
  srel.length = (size_t )reloc_size;
#line 253
  srel.sh_type = (uint32_t )1;
#line 254
  srel.sh_flags = (uint32_t )7;
#line 255
  srel.name = "reloc";
#line 256
  srel.data = (void const   *)(reloc);
#line 259
  ssup.next = & scmd;
#line 260
  ssup.align = 4;
#line 261
  ssup.length = setup_len;
#line 262
  ssup.sh_type = (uint32_t )1;
#line 263
  ssup.sh_flags = (uint32_t )7;
#line 264
  ssup.name = "setup";
#line 265
  ssup.data = (void const   *)kernel;
#line 266
  if (setup_ver >= 512) {
#line 267
    hdr->type_of_loader = (uint8_t )255;
  }
  {
#line 270
  scmd.next = & skrn;
#line 271
  tmp___17 = strlen(cmdline);
#line 271
  scmd.length = tmp___17 + 1UL;
#line 272
  scmd.address = (addr_t )(((size_t )(ssup.address + (addr_t )setup_space) - scmd.length) & 0xfffffffffffffff0UL);
#line 273
  scmd.align = 4;
  }
#line 274
  if (srel.address + reloc_size > scmd.address) {
#line 277
    scmd.address = ((srel.address + reloc_size) + 15U) & 4294967280U;
  }
#line 279
  scmd.sh_type = (uint32_t )1;
#line 280
  scmd.sh_flags = (uint32_t )2;
#line 281
  scmd.name = "cmdline";
#line 282
  scmd.data = (void const   *)cmdline;
#line 283
  if (setup_ver >= 514) {
    {
#line 284
    wrle32(scmd.address, & hdr->cmd_line_ptr);
    }
  } else {
    {
#line 287
    wrle16((uint16_t )41791, (uint16_t *)(kernel + 32));
#line 288
    wrle16((uint16_t )(scmd.address - ssup.address), (uint16_t *)(kernel + 34));
    }
  }
#line 291
  if (setup_ver >= 513) {
    {
#line 292
    wrle16((uint16_t )((scmd.address - ssup.address) - 512U), & hdr->heap_end_ptr);
#line 293
    hdr->loadflags = (uint8_t )((int )hdr->loadflags | (1 << 7));
    }
  }
  {
#line 298
  wrle32(ssup.address, & info->setup_addr);
#line 299
  wrle32(scmd.address, & info->cmdline_addr);
#line 300
  entry = (uint32_t )((unsigned long )srel.address + sizeof(*info));
  }
#line 303
  if (ninitrd) {
#line 303
    skrn.next = & (ird + 0)->seg;
  } else {
#line 303
    skrn.next = (struct segment *)((void *)0);
  }
#line 304
  skrn.align = 4;
#line 305
  skrn.length = kernel_len - setup_len;
#line 306
  skrn.sh_type = (uint32_t )1;
#line 307
  skrn.sh_flags = (uint32_t )2;
#line 308
  skrn.name = "kernel";
#line 309
  skrn.data = (void const   *)(kernel + setup_len);
#line 311
  if (skrn.address < 1048576U) {
#line 312
    initrd_addr___0 = (size_t )1048576;
  } else {
#line 314
    initrd_addr___0 = (size_t )skrn.address + skrn.length;
  }
#line 317
  if (opt.loadhigh) {
#line 320
    if (skrn.address < 1048576U) {
      {
#line 322
      wrle32(skrn.address, & hmv->mv[1].dst);
#line 323
      wrle32((uint32_t )skrn.length, & hmv->mv[1].len);
#line 324
      skrn.address = (addr_t )1048576;
#line 325
      wrle32(skrn.address, & hmv->mv[1].src);
#line 326
      initrd_addr___0 = (size_t )skrn.address + skrn.length;
      }
    }
    {
#line 329
    shmv.next = skrn.next;
#line 330
    skrn.next = & shmv;
#line 331
    shmv.address = align_up((addr_t )initrd_addr___0, 4);
#line 332
    shmv.align = 4;
#line 333
    shmv.length = (size_t )highmove_size;
#line 334
    shmv.sh_type = (uint32_t )1;
#line 335
    shmv.sh_flags = (uint32_t )6;
#line 336
    shmv.name = "highmove";
#line 337
    shmv.data = (void const   *)(highmove);
#line 339
    rm_base = ssup.address;
#line 340
    rm_len = (uint32_t )(((size_t )scmd.address + scmd.length) - (size_t )rm_base);
#line 341
    wrle32(rm_base, & hmv->mv[0].dst);
#line 342
    wrle32(rm_len, & hmv->mv[0].len);
#line 343
    wrle32(entry, & hmv->mv_entry);
#line 345
    entry = (uint32_t )((unsigned long )shmv.address + sizeof(*hmv));
#line 347
    initrd_addr___0 = (size_t )shmv.address + shmv.length;
#line 348
    tmp___18 = align_up((addr_t )initrd_addr___0, 4);
#line 348
    initrd_addr___0 = (size_t )tmp___18;
#line 350
    wrle32((uint32_t )initrd_addr___0, & hmv->mv[0].src);
#line 352
    delta = (uint32_t )(initrd_addr___0 - (size_t )ssup.address);
#line 354
    ssup.address += delta;
#line 355
    srel.address += delta;
#line 356
    scmd.address += delta;
#line 358
    initrd_addr___0 += (size_t )rm_len;
    }
  }
#line 362
  i = 0;
  {
#line 362
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 362
    if (! (i < ninitrd)) {
#line 362
      goto while_break___2;
    }
    {
#line 365
    tmp___19 = align_up((addr_t )initrd_addr___0, 2);
#line 365
    initrd_addr___0 = (size_t )tmp___19;
    }
#line 367
    if (i < ninitrd - 1) {
#line 367
      (ird + i)->seg.next = & (ird + (i + 1))->seg;
    } else {
#line 367
      (ird + i)->seg.next = (struct segment *)0;
    }
    {
#line 368
    (ird + i)->seg.address = (addr_t )initrd_addr___0;
#line 369
    (ird + i)->seg.align = 2;
#line 370
    (ird + i)->seg.sh_type = (uint32_t )1;
#line 371
    (ird + i)->seg.sh_flags = (uint32_t )2;
#line 372
    xasprintf(& name, "initrd.%d", i);
#line 373
    (ird + i)->seg.name = (char const   *)name;
#line 375
    initrd_addr___0 += (ird + i)->seg.length;
#line 362
    i ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 377
  if (setup_ver >= 512) {
    {
#line 378
    wrle32((uint32_t )initrd_len___0, & hdr->ramdisk_size);
    }
  }
#line 381
  if (ninitrd) {
#line 381
    tmp___20 = (ird + 0)->seg.address;
  } else {
#line 381
    tmp___20 = (addr_t )0;
  }
  {
#line 381
  wrle32(tmp___20, & info->rd_addr);
#line 382
  wrle32((uint32_t )initrd_len___0, & info->rd_len);
#line 383
  wrle32(initrd_max, & info->rd_maxaddr);
#line 385
  rv = (*(opt.output))(& srel, entry, out);
  }
  err: 
#line 388
  if (ird) {
#line 389
    i = 0;
    {
#line 389
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 389
      if (! (i < ninitrd)) {
#line 389
        goto while_break___3;
      }
      {
#line 390
      unmapfile((ird + i)->fd, (void *)(ird + i)->seg.data, (ird + i)->seg.length);
#line 389
      i ++;
      }
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 392
    free((void *)ird);
    }
  }
  {
#line 395
  unmapfile(kernel_fd, (void *)kernel, kernel_len);
  }
#line 396
  return (rv);
}
}
/* compiler builtin: 
   void *__builtin_alloca(unsigned long  ) ;  */
#line 765 "/usr/include/stdlib.h"
extern void ( __attribute__((__nonnull__(1,4))) qsort)(void *__base , size_t __nmemb ,
                                                       size_t __size , int (*__compar)(void const   * ,
                                                                                       void const   * ) ) ;
#line 26 "/home/june/repo/benchmarks/collector2/temp/wraplinux-1.7/segment.c"
static int comp_seg(void const   *a , void const   *b ) 
{ 
  struct segment  const  * const  *ap ;
  struct segment  const  * const  *bp ;

  {
#line 28
  ap = (struct segment  const  * const  *)a;
#line 29
  bp = (struct segment  const  * const  *)b;
#line 31
  if ((*ap)->address < (*bp)->address) {
#line 32
    return (-1);
  } else
#line 33
  if ((*ap)->address > (*bp)->address) {
#line 34
    return (1);
  } else {
#line 36
    return (0);
  }
}
}
#line 39 "/home/june/repo/benchmarks/collector2/temp/wraplinux-1.7/segment.c"
struct segment *sort_segments(struct segment *list ) 
{ 
  struct segment **ptrs ;
  int nsegments ;
  int i ;
  struct segment *sp ;
  struct segment **spp ;
  void *tmp ;
  struct segment **tmp___0 ;

  {
#line 45
  nsegments = 0;
#line 46
  sp = list;
  {
#line 46
  while (1) {
    while_continue: /* CIL Label */ ;
#line 46
    if (! sp) {
#line 46
      goto while_break;
    }
#line 47
    nsegments ++;
#line 46
    sp = sp->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 49
  tmp = __builtin_alloca((unsigned long )nsegments * sizeof(*ptrs));
#line 49
  ptrs = (struct segment **)tmp;
#line 50
  spp = ptrs;
#line 51
  sp = list;
  }
  {
#line 51
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 51
    if (! sp) {
#line 51
      goto while_break___0;
    }
#line 52
    tmp___0 = spp;
#line 52
    spp ++;
#line 52
    *tmp___0 = sp;
#line 51
    sp = sp->next;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 54
  qsort((void *)ptrs, (size_t )nsegments, sizeof(*ptrs), & comp_seg);
#line 56
  i = 0;
  }
  {
#line 56
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 56
    if (! (i < nsegments - 1)) {
#line 56
      goto while_break___1;
    }
#line 57
    (*(ptrs + i))->next = *(ptrs + (i + 1));
#line 56
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 58
  (*(ptrs + i))->next = (struct segment *)((void *)0);
#line 60
  return (*(ptrs + 0));
}
}
#line 715 "/usr/include/stdio.h"
extern size_t fwrite(void const   * __restrict  __ptr , size_t __size , size_t __n ,
                     FILE * __restrict  __s ) ;
#line 21 "/home/june/repo/benchmarks/collector2/temp/wraplinux-1.7/cwrite.c"
size_t c_fwrite(void const   *ptr , size_t bytes , FILE *stream ) 
{ 
  size_t tmp ;

  {
#line 23
  if (! stream) {
#line 24
    return (bytes);
  }
  {
#line 26
  tmp = fwrite((void const   */* __restrict  */)ptr, (size_t )1, bytes, (FILE */* __restrict  */)stream);
  }
#line 26
  return (tmp);
}
}
#line 31 "/home/june/repo/benchmarks/collector2/temp/wraplinux-1.7/cwrite.c"
static char const   zerobuf[8192]  ;
#line 29 "/home/june/repo/benchmarks/collector2/temp/wraplinux-1.7/cwrite.c"
size_t c_writezero(size_t n , FILE *stream ) 
{ 
  size_t r ;
  size_t o ;
  size_t w ;
  size_t tmp ;

  {
#line 32
  o = (size_t )0;
#line 34
  if (! stream) {
#line 35
    return (n);
  }
  {
#line 37
  while (1) {
    while_continue: /* CIL Label */ ;
#line 37
    if (! n) {
#line 37
      goto while_break;
    }
#line 38
    if (n < 8192UL) {
#line 38
      tmp = n;
    } else {
#line 38
      tmp = (size_t )8192;
    }
    {
#line 38
    w = tmp;
#line 39
    r = fwrite((void const   */* __restrict  */)(zerobuf), (size_t )1, w, (FILE */* __restrict  */)stream);
#line 40
    o += r;
#line 41
    n -= r;
    }
#line 42
    if (r < w) {
#line 43
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 45
  return (o);
}
}
#line 353 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 57 "/usr/include/x86_64-linux-gnu/sys/mman.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) mmap)(void *__addr ,
                                                                             size_t __len ,
                                                                             int __prot ,
                                                                             int __flags ,
                                                                             int __fd ,
                                                                             __off_t __offset ) ;
#line 76
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) munmap)(void *__addr ,
                                                                             size_t __len ) ;
#line 214 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2), __leaf__)) fstat)(int __fd ,
                                                                                            struct stat *__buf ) ;
#line 31 "/home/june/repo/benchmarks/collector2/temp/wraplinux-1.7/mapfile.c"
void *mapfile(int fd , size_t *len , _Bool writable ) 
{ 
  struct stat st ;
  void *ptr ;
  int prot ;
  int flags ;
  int tmp ;
  void *tmp___0 ;

  {
  {
#line 37
  tmp = fstat(fd, & st);
  }
#line 37
  if (tmp) {
#line 38
    return ((void *)0);
  }
#line 40
  *len = (size_t )st.st_size;
#line 42
  if (writable) {
#line 43
    prot = 3;
#line 44
    flags = 2;
  } else {
#line 46
    prot = 1;
#line 47
    flags = 1;
  }
  {
#line 50
  ptr = mmap((void *)0, (size_t )st.st_size, prot, flags, fd, (__off_t )0);
  }
#line 52
  if ((unsigned long )ptr == (unsigned long )((void *)-1)) {
#line 52
    tmp___0 = (void *)0;
  } else {
#line 52
    tmp___0 = ptr;
  }
#line 52
  return (tmp___0);
}
}
#line 55 "/home/june/repo/benchmarks/collector2/temp/wraplinux-1.7/mapfile.c"
void unmapfile(int fd , void *ptr , size_t len ) 
{ 


  {
#line 57
  if (ptr) {
    {
#line 58
    munmap(ptr, len);
    }
  }
#line 59
  if (fd >= 0) {
    {
#line 60
    close(fd);
    }
  }
#line 61
  return;
}
}
#line 42 "/home/june/repo/benchmarks/collector2/temp/wraplinux-1.7/segment.h"
int output_nbi(struct segment *segs , addr_t entry , FILE *out ) ;
#line 54 "/home/june/repo/benchmarks/collector2/temp/wraplinux-1.7/wraplinux.h"
__inline static addr_t padsize(addr_t addr , int align ) 
{ 
  addr_t align_mask ;

  {
#line 56
  align_mask = (1U << align) - 1U;
#line 57
  return (- addr & align_mask);
}
}
#line 29 "/home/june/repo/benchmarks/collector2/temp/wraplinux-1.7/nbi.c"
__inline static int is_real_seg(struct segment *s ) 
{ 
  int tmp ;

  {
#line 31
  if (s->sh_type == 1U) {
#line 31
    if (s->sh_flags & 2U) {
#line 31
      tmp = 1;
    } else {
#line 31
      tmp = 0;
    }
  } else {
#line 31
    tmp = 0;
  }
#line 31
  return (tmp);
}
}
#line 35 "/home/june/repo/benchmarks/collector2/temp/wraplinux-1.7/nbi.c"
int output_nbi(struct segment *segs , addr_t entry , FILE *out ) 
{ 
  struct nbi_header nhdr ;
  struct nbi_image_header ihdr ;
  uint32_t offset ;
  struct segment *s ;
  addr_t base ;
  addr_t address ;
  addr_t length ;
  int tmp ;
  size_t tmp___0 ;
  addr_t tmp___1 ;
  int tmp___2 ;
  addr_t tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  size_t tmp___6 ;
  size_t tmp___7 ;
  size_t tmp___8 ;
  size_t tmp___9 ;
  addr_t tmp___10 ;
  size_t tmp___11 ;
  size_t tmp___12 ;
  int tmp___13 ;
  addr_t tmp___14 ;
  int tmp___15 ;

  {
  {
#line 44
  segs = sort_segments(segs);
#line 46
  wrle32((uint32_t )453186358, & nhdr.magic);
#line 47
  wrle32((uint32_t )(2147483648UL + (sizeof(nhdr) >> 2)), & nhdr.flags);
#line 48
  wrle32(entry, & nhdr.entry);
#line 55
  base = (addr_t )65536;
#line 56
  s = segs;
  }
  {
#line 56
  while (1) {
    while_continue: /* CIL Label */ ;
#line 56
    if (! s) {
#line 56
      goto while_break;
    }
    {
#line 57
    tmp = is_real_seg(s);
    }
#line 57
    if (tmp) {
#line 58
      if (s->address >= base + 512U) {
#line 59
        goto while_break;
      }
#line 61
      base = (addr_t )((((size_t )s->address + s->length) + 511UL) & 0xfffffffffffffe00UL);
    }
#line 56
    s = s->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 65
  if (s) {
#line 65
    if (base <= 604160U) {
      {
#line 66
      wrle16((uint16_t )0, & nhdr.header_off);
#line 67
      wrle16((uint16_t )(base >> 4), & nhdr.header_seg);
      }
    } else {
      {
#line 70
      wrle16((uint16_t )31744, & nhdr.header_off);
#line 71
      wrle16((uint16_t )0, & nhdr.header_seg);
      }
    }
  } else {
    {
#line 70
    wrle16((uint16_t )31744, & nhdr.header_off);
#line 71
    wrle16((uint16_t )0, & nhdr.header_seg);
    }
  }
  {
#line 74
  tmp___0 = c_fwrite((void const   *)(& nhdr), sizeof(nhdr), out);
#line 74
  offset = (uint32_t )tmp___0;
#line 76
  s = segs;
  }
  {
#line 76
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 76
    if (! s) {
#line 76
      goto while_break___0;
    }
    {
#line 77
    tmp___5 = is_real_seg(s);
    }
#line 77
    if (tmp___5) {
#line 78
      ihdr.lengths = (uint8_t )(sizeof(ihdr) >> 2);
#line 79
      ihdr.tags = (uint8_t )0;
#line 80
      ihdr.resv = (uint8_t )0;
#line 85
      address = s->address;
#line 86
      length = (addr_t )s->length;
      {
#line 88
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 88
        if (s->next) {
          {
#line 88
          tmp___2 = is_real_seg(s->next);
          }
#line 88
          if (tmp___2) {
#line 88
            if ((s->next)->align <= s->align) {
              {
#line 88
              tmp___3 = align_up(address + length, (s->next)->align);
              }
#line 88
              if (! ((s->next)->address == tmp___3)) {
#line 88
                goto while_break___1;
              }
            } else {
#line 88
              goto while_break___1;
            }
          } else {
#line 88
            goto while_break___1;
          }
        } else {
#line 88
          goto while_break___1;
        }
        {
#line 93
        s = s->next;
#line 94
        tmp___1 = padsize(address + length, s->align);
#line 94
        length += tmp___1;
#line 95
        length = (addr_t )((size_t )length + s->length);
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 98
      ihdr.load_addr = address;
#line 99
      ihdr.filesz = length;
#line 100
      ihdr.memsz = length;
#line 101
      if (s->next) {
#line 101
        ihdr.flags = (uint8_t )0;
      } else {
#line 101
        ihdr.flags = (uint8_t )4;
      }
      {
#line 103
      tmp___4 = c_fwrite((void const   *)(& ihdr), sizeof(ihdr), out);
#line 103
      offset = (uint32_t )((size_t )offset + tmp___4);
      }
    }
#line 76
    s = s->next;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 107
  if (offset <= 510U) {
    {
#line 108
    tmp___6 = c_writezero((size_t )(510U - offset), out);
#line 108
    offset = (uint32_t )((size_t )offset + tmp___6);
    }
  }
#line 110
  if (offset == 510U) {
    {
#line 111
    tmp___7 = c_fwrite((void const   *)"U", (size_t )1, out);
#line 111
    offset = (uint32_t )((size_t )offset + tmp___7);
    }
  }
#line 112
  if (offset == 511U) {
    {
#line 113
    tmp___8 = c_fwrite((void const   *)"\252", (size_t )1, out);
#line 113
    offset = (uint32_t )((size_t )offset + tmp___8);
    }
  }
#line 115
  s = segs;
  {
#line 115
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 115
    if (! s) {
#line 115
      goto while_break___2;
    }
    {
#line 116
    tmp___15 = is_real_seg(s);
    }
#line 116
    if (tmp___15) {
      {
#line 117
      address = s->address;
#line 118
      tmp___9 = c_fwrite(s->data, s->length, out);
#line 118
      address = (addr_t )((size_t )address + tmp___9);
      }
      {
#line 120
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 120
        if (s->next) {
          {
#line 120
          tmp___13 = is_real_seg(s->next);
          }
#line 120
          if (tmp___13) {
#line 120
            if ((s->next)->align <= s->align) {
              {
#line 120
              tmp___14 = align_up(address, (s->next)->align);
              }
#line 120
              if (! ((s->next)->address == tmp___14)) {
#line 120
                goto while_break___3;
              }
            } else {
#line 120
              goto while_break___3;
            }
          } else {
#line 120
            goto while_break___3;
          }
        } else {
#line 120
          goto while_break___3;
        }
        {
#line 125
        s = s->next;
#line 126
        tmp___10 = padsize(address, s->align);
#line 126
        tmp___11 = c_writezero((size_t )tmp___10, out);
#line 126
        address = (addr_t )((size_t )address + tmp___11);
#line 129
        tmp___12 = c_fwrite(s->data, s->length, out);
#line 129
        address = (addr_t )((size_t )address + tmp___12);
        }
      }
      while_break___3: /* CIL Label */ ;
      }
    }
#line 115
    s = s->next;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 134
  return (0);
}
}
#line 169 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 362
extern int printf(char const   * __restrict  __format  , ...) ;
#line 57 "/usr/include/getopt.h"
extern char *optarg ;
#line 71
extern int optind ;
#line 173
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getopt_long)(int ___argc ,
                                                                                  char * const  *___argv ,
                                                                                  char const   *__shortopts ,
                                                                                  struct option  const  *__longopts ,
                                                                                  int *__longind ) ;
#line 28 "/home/june/repo/benchmarks/collector2/temp/wraplinux-1.7/wraplinux.h"
char const   *program  ;
#line 38 "/home/june/repo/benchmarks/collector2/temp/wraplinux-1.7/main.c"
struct option  const  long_options[13]  = 
#line 38 "/home/june/repo/benchmarks/collector2/temp/wraplinux-1.7/main.c"
  {      {"params", 1, (int *)0, 'p'}, 
        {"cmdline", 1, (int *)0, 'p'}, 
        {"commandline", 1, (int *)0, 'p'}, 
        {"initrd", 1, (int *)0, 'i'}, 
        {"output", 1, (int *)0, 'o'}, 
        {"load-high", 0, (int *)0, 'l'}, 
        {"no-load-high", 0, (int *)0, 256}, 
        {"elf", 0, (int *)0, 'E'}, 
        {"multiboot", 0, (int *)0, 'M'}, 
        {"nbi", 0, (int *)0, 'N'}, 
        {"help", 0, (int *)0, 'h'}, 
        {"version", 0, (int *)0, 'V'}, 
        {(char const   *)0, 0, (int *)0, 0}};
#line 56 "/home/june/repo/benchmarks/collector2/temp/wraplinux-1.7/main.c"
static void usage(int err ) 
{ 


  {
  {
#line 58
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s %s\nUsage: %s [options] kernel\n  --params       -p    kernel commandline parameters\n  --initrd       -i    initrd (multiple initrd options supported)\n  --output       -o    output filename (default stdout)\n  --elf          -E    output in ELF format (default)\n  --multiboot    -M    output in Multiboot ELF format\n  --nbi          -N    output in NBI format\n  --load-high    -l    load entirely above 1 MB\n                       (default for Multiboot ELF format)\n  --help         -h    display this help text\n  --version      -V    print the program version\n",
          "wraplinux", "1.7", program);
#line 73
  exit(err);
  }
}
}
#line 76 "/home/june/repo/benchmarks/collector2/temp/wraplinux-1.7/main.c"
int main(int argc , char **argv ) 
{ 
  int optch ;
  char const   *kernel ;
  struct string_list *ird ;
  struct string_list **irdp ;
  struct string_list *ip ;
  FILE *out ;
  _Bool loadhighopt ;
  void *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;

  {
#line 80
  ird = (struct string_list *)((void *)0);
#line 80
  irdp = & ird;
#line 81
  out = stdout;
#line 82
  loadhighopt = (_Bool)0;
#line 84
  program = (char const   *)*(argv + 0);
#line 86
  opt.output = & output_elf;
  {
#line 88
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 88
    optch = getopt_long(argc, (char * const  *)argv, "p:i:o:lEMNhV", long_options,
                        (int *)((void *)0));
    }
#line 88
    if (! (optch != -1)) {
#line 88
      goto while_break;
    }
    {
#line 91
    if (optch == 112) {
#line 91
      goto case_112;
    }
#line 94
    if (optch == 105) {
#line 94
      goto case_105;
    }
#line 101
    if (optch == 111) {
#line 101
      goto case_111;
    }
#line 113
    if (optch == 108) {
#line 113
      goto case_108;
    }
#line 117
    if (optch == 256) {
#line 117
      goto case_256;
    }
#line 121
    if (optch == 69) {
#line 121
      goto case_69;
    }
#line 124
    if (optch == 77) {
#line 124
      goto case_77;
    }
#line 127
    if (optch == 78) {
#line 127
      goto case_78;
    }
#line 130
    if (optch == 104) {
#line 130
      goto case_104;
    }
#line 133
    if (optch == 86) {
#line 133
      goto case_86;
    }
#line 136
    goto switch_default;
    case_112: /* CIL Label */ 
#line 92
    opt.params = (char const   *)optarg;
#line 93
    goto switch_break;
    case_105: /* CIL Label */ 
    {
#line 95
    tmp = xmalloc(sizeof(*ip));
#line 95
    ip = (struct string_list *)tmp;
#line 96
    ip->str = (char const   *)optarg;
#line 97
    ip->next = (struct string_list *)((void *)0);
#line 98
    *irdp = ip;
#line 99
    irdp = & ip->next;
    }
#line 100
    goto switch_break;
    case_111: /* CIL Label */ 
#line 102
    if ((int )*(optarg + 0) == 45) {
#line 102
      if (! *(optarg + 1)) {
#line 103
        out = stdout;
      } else {
#line 102
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      {
#line 105
      out = fopen((char const   */* __restrict  */)optarg, (char const   */* __restrict  */)"wb");
      }
#line 106
      if (! out) {
        {
#line 107
        tmp___0 = __errno_location();
#line 107
        tmp___1 = strerror(*tmp___0);
#line 107
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s: %s\n",
                program, optarg, tmp___1);
        }
#line 109
        return (73);
      }
    }
#line 112
    goto switch_break;
    case_108: /* CIL Label */ 
#line 114
    opt.loadhigh = (_Bool)1;
#line 115
    loadhighopt = (_Bool)1;
#line 116
    goto switch_break;
    case_256: /* CIL Label */ 
#line 118
    opt.loadhigh = (_Bool)0;
#line 119
    loadhighopt = (_Bool)1;
#line 120
    goto switch_break;
    case_69: /* CIL Label */ 
#line 122
    opt.output = & output_elf;
#line 123
    goto switch_break;
    case_77: /* CIL Label */ 
#line 125
    opt.output = & output_multiboot;
#line 126
    goto switch_break;
    case_78: /* CIL Label */ 
#line 128
    opt.output = & output_nbi;
#line 129
    goto switch_break;
    case_104: /* CIL Label */ 
    {
#line 131
    usage(0);
    }
#line 132
    goto switch_break;
    case_86: /* CIL Label */ 
    {
#line 134
    printf((char const   */* __restrict  */)"%s %s\n", "wraplinux", "1.7");
#line 135
    exit(0);
    }
    switch_default: /* CIL Label */ 
    {
#line 137
    usage(64);
    }
#line 138
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 142
  if (argc - optind != 1) {
    {
#line 143
    usage(64);
    }
  }
#line 145
  if ((unsigned long )opt.output == (unsigned long )(& output_multiboot)) {
#line 145
    if (! loadhighopt) {
#line 146
      opt.loadhigh = (_Bool)1;
    }
  }
#line 148
  kernel = (char const   *)*(argv + optind);
#line 150
  if (! opt.params) {
#line 151
    opt.params = "";
  }
  {
#line 153
  tmp___2 = wrap_kernel(kernel, opt.params, (struct string_list  const  *)ird, out);
  }
#line 153
  return (tmp___2);
}
}
#line 34 "./reloc/reloc.h"
extern void memmove(void * , void * , size_t___0  ) ;
#line 36
extern void jump_to_kernel(uint32_t rm_segment , uint32_t esp ) ;
#line 38 "./reloc/reloc.h"
__inline static void memset___0(void *dst , int c , size_t___0 len ) 
{ 
  uint32_t ecx ;

  {
#line 40
  ecx = len >> 2;
#line 42
  __asm__  volatile   ("rep; stosl; "
                       "movl %3,%%ecx; "
                       "rep; stosb": "+D" (dst), "+c" (ecx): "a" ((int )((uint8_t )c) * 16843009),
                       "bdS" (len & 3U): "memory");
#line 48
  return;
}
}
#line 101 "./reloc/reloc.h"
__inline static uint16_t SEG(void const volatile   *__p ) 
{ 


  {
#line 103
  return ((uint16_t )((uintptr_t )__p >> 4));
}
}
#line 106 "./reloc/reloc.h"
__inline static uint16_t OFFS(void const volatile   *__p ) 
{ 


  {
#line 109
  return ((uint16_t )((int )((uint16_t )((uintptr_t )__p)) & 15));
}
}
#line 112
extern void intcall(uint8_t intr , com32sys_t const   *ireg , com32sys_t *oreg ) ;
#line 41 "/home/june/repo/benchmarks/collector2/temp/wraplinux-1.7/reloc/reloc_linux.c"
static uint32_t initrd_len  ;
#line 41 "/home/june/repo/benchmarks/collector2/temp/wraplinux-1.7/reloc/reloc_linux.c"
static uint32_t initrd_addr  ;
#line 42 "/home/june/repo/benchmarks/collector2/temp/wraplinux-1.7/reloc/reloc_linux.c"
static uint64_t___0 max_addr  ;
#line 44 "/home/june/repo/benchmarks/collector2/temp/wraplinux-1.7/reloc/reloc_linux.c"
static int initrd_fit(uint32_t base , uint32_t end ) 
{ 
  uint64_t___0 ibase ;

  {
#line 48
  if (end <= base) {
#line 49
    return (-1);
  }
#line 51
  if ((uint64_t___0 )base > max_addr) {
#line 52
    return (-1);
  }
#line 54
  if ((uint64_t___0 )end > max_addr) {
#line 55
    end = (uint32_t )max_addr;
  }
#line 57
  if (end < initrd_len) {
#line 58
    return (-1);
  }
#line 60
  ibase = (uint64_t___0 )((end - initrd_len) & 4294963200U);
#line 61
  if (ibase < (uint64_t___0 )base) {
#line 62
    return (-1);
  }
#line 64
  if ((uint64_t___0 )initrd_addr < ibase) {
#line 65
    initrd_addr = (uint32_t )ibase;
  }
#line 68
  return (0);
}
}
#line 71 "/home/june/repo/benchmarks/collector2/temp/wraplinux-1.7/reloc/reloc_linux.c"
static int probe_memory_e820(void) 
{ 
  com32sys_t regs ;
  struct e820_info buf ;
  int rv ;
  uint32_t copied ;
  int tmp ;

  {
  {
#line 79
  rv = -1;
#line 82
  memset___0((void *)(& regs), 0, (size_t___0 )sizeof(regs));
  }
  {
#line 84
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 85
    regs.eax.l = (uint32_t )59424;
#line 86
    regs.ecx.l = (uint32_t )sizeof(buf);
#line 87
    regs.edx.l = (uint32_t )1397571920;
#line 88
    regs.edi.w[0] = OFFS((void const volatile   *)(& buf));
#line 89
    regs.es = SEG((void const volatile   *)(& buf));
#line 91
    intcall((uint8_t )21, (com32sys_t const   *)(& regs), & regs);
    }
#line 92
    if (regs.eflags.l & 1U) {
#line 92
      copied = (uint32_t )0;
    } else {
#line 92
      copied = regs.ecx.l;
    }
#line 95
    if (regs.eax.l != 1397571920U) {
#line 96
      goto while_break;
    } else
#line 95
    if (copied < 20U) {
#line 96
      goto while_break;
    }
#line 98
    if (buf.type != 1U) {
#line 99
      goto __Cont;
    }
    {
#line 101
    tmp = initrd_fit((uint32_t )buf.base, (uint32_t )(buf.base + buf.len));
#line 101
    rv &= tmp;
    }
    __Cont: /* CIL Label */ 
#line 84
    if (! regs.ebx.l) {
#line 84
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 104
  return (rv);
}
}
#line 107 "/home/june/repo/benchmarks/collector2/temp/wraplinux-1.7/reloc/reloc_linux.c"
static int probe_memory_e801(void) 
{ 
  com32sys_t regs ;
  uint64_t___0 end ;
  int tmp ;

  {
  {
#line 112
  memset___0((void *)(& regs), 0, (size_t___0 )sizeof(regs));
#line 113
  regs.eax.w[0] = (uint16_t )59393;
#line 114
  intcall((uint8_t )21, (com32sys_t const   *)(& regs), & regs);
  }
#line 116
  if (regs.eflags.l & 1U) {
#line 117
    return (-1);
  }
#line 119
  if ((int )regs.eax.w[0] < 15360) {
#line 120
    end = (uint64_t___0 )((int )regs.eax.w[0] << 10) + 1048576ULL;
  } else {
#line 122
    end = (uint64_t___0 )((int )regs.ebx.w[0] << 16) + 16777216ULL;
  }
  {
#line 124
  tmp = initrd_fit((uint32_t )1048576, (uint32_t )end);
  }
#line 124
  return (tmp);
}
}
#line 127 "/home/june/repo/benchmarks/collector2/temp/wraplinux-1.7/reloc/reloc_linux.c"
static int probe_memory_88(void) 
{ 
  com32sys_t regs ;
  int tmp ;

  {
  {
#line 131
  memset___0((void *)(& regs), 0, (size_t___0 )sizeof(regs));
#line 132
  regs.eax.b[1] = (uint8_t )136;
#line 133
  intcall((uint8_t )21, (com32sys_t const   *)(& regs), & regs);
  }
#line 135
  if (regs.eflags.l & 1U) {
#line 136
    return (-1);
  }
  {
#line 138
  tmp = initrd_fit((uint32_t )1048576, (uint32_t )(((int )regs.eax.w[0] << 10) + 1048576));
  }
#line 138
  return (tmp);
}
}
#line 141 "/home/june/repo/benchmarks/collector2/temp/wraplinux-1.7/reloc/reloc_linux.c"
static int place_initrd(void) 
{ 
  int rv ;
  int tmp ;

  {
  {
#line 145
  rv = probe_memory_e820();
  }
#line 146
  if (! rv) {
#line 147
    return (0);
  }
  {
#line 149
  rv = probe_memory_e801();
  }
#line 150
  if (! rv) {
#line 151
    return (0);
  }
  {
#line 153
  tmp = probe_memory_88();
  }
#line 153
  return (tmp);
}
}
#line 156
extern char _end[] ;
#line 158 "/home/june/repo/benchmarks/collector2/temp/wraplinux-1.7/reloc/reloc_linux.c"
static struct startup_info  const  startup_info  __attribute__((__section__(".startupinfo")))  =    {0U,
    0U, 0U, 0U, 0U, (uint32_t )(& _end)};
