/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 28 "/usr/include/x86_64-linux-gnu/bits/sockaddr.h"
typedef unsigned short sa_family_t;
#line 149 "/usr/include/x86_64-linux-gnu/bits/socket.h"
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14] ;
};
#line 49 "/usr/include/stdint.h"
typedef unsigned short uint16_t;
#line 51 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 30 "/usr/include/netinet/in.h"
typedef uint32_t in_addr_t;
#line 31 "/usr/include/netinet/in.h"
struct in_addr {
   in_addr_t s_addr ;
};
#line 117 "/usr/include/netinet/in.h"
typedef uint16_t in_port_t;
#line 237 "/usr/include/netinet/in.h"
struct sockaddr_in {
   sa_family_t sin_family ;
   in_port_t sin_port ;
   struct in_addr sin_addr ;
   unsigned char sin_zero[((sizeof(struct sockaddr ) - sizeof(unsigned short )) - sizeof(in_port_t )) - sizeof(struct in_addr )] ;
};
#line 22 "/home/june/collector/temp/bopm-3.1.3/src/libopm/src/inet.h"
struct _opm_sockaddr;
#line 22 "/home/june/collector/temp/bopm-3.1.3/src/libopm/src/inet.h"
typedef struct _opm_sockaddr opm_sockaddr;
#line 25 "/home/june/collector/temp/bopm-3.1.3/src/libopm/src/inet.h"
struct _opm_sockaddr {
   struct sockaddr_in sa4 ;
};
#line 4 "/home/june/collector/temp/bopm-3.1.3/src/libopm/src/opm_common.h"
struct _libopm_node;
#line 4 "/home/june/collector/temp/bopm-3.1.3/src/libopm/src/opm_common.h"
typedef struct _libopm_node OPM_NODE_T;
#line 5
struct _libopm_list;
#line 5 "/home/june/collector/temp/bopm-3.1.3/src/libopm/src/opm_common.h"
typedef struct _libopm_list OPM_LIST_T;
#line 8 "/home/june/collector/temp/bopm-3.1.3/src/libopm/src/opm_common.h"
struct _libopm_list {
   struct _libopm_node *head ;
   struct _libopm_node *tail ;
   int elements ;
};
#line 16 "/home/june/collector/temp/bopm-3.1.3/src/libopm/src/opm_common.h"
struct _libopm_node {
   struct _libopm_node *next ;
   struct _libopm_node *prev ;
   void *data ;
};
#line 20 "/home/june/collector/temp/bopm-3.1.3/src/libopm/src/opm.h"
struct _OPM_CONFIG;
#line 20 "/home/june/collector/temp/bopm-3.1.3/src/libopm/src/opm.h"
typedef struct _OPM_CONFIG OPM_CONFIG_T;
#line 25 "/home/june/collector/temp/bopm-3.1.3/src/libopm/src/opm.h"
typedef int OPM_ERR_T;
#line 34 "/home/june/collector/temp/bopm-3.1.3/src/libopm/src/opm.h"
struct _OPM_CONFIG {
   void **vars ;
};
#line 6 "/home/june/collector/temp/bopm-3.1.3/src/libopm/src/config.h"
struct _opm_config_hash;
#line 6 "/home/june/collector/temp/bopm-3.1.3/src/libopm/src/config.h"
typedef struct _opm_config_hash OPM_CONFIG_HASH_T;
#line 8 "/home/june/collector/temp/bopm-3.1.3/src/libopm/src/config.h"
struct _opm_config_hash {
   int key ;
   int type ;
};
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 189 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __socklen_t;
#line 109 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __ssize_t ssize_t;
#line 75 "/usr/include/time.h"
typedef __time_t time_t;
#line 33 "/usr/include/x86_64-linux-gnu/bits/socket.h"
typedef __socklen_t socklen_t;
#line 36 "/usr/include/x86_64-linux-gnu/sys/poll.h"
typedef unsigned long nfds_t;
#line 39 "/usr/include/x86_64-linux-gnu/sys/poll.h"
struct pollfd {
   int fd ;
   short events ;
   short revents ;
};
#line 21 "/home/june/collector/temp/bopm-3.1.3/src/libopm/src/opm.h"
struct _OPM;
#line 21 "/home/june/collector/temp/bopm-3.1.3/src/libopm/src/opm.h"
typedef struct _OPM OPM_T;
#line 22
struct _OPM_REMOTE;
#line 22 "/home/june/collector/temp/bopm-3.1.3/src/libopm/src/opm.h"
typedef struct _OPM_REMOTE OPM_REMOTE_T;
#line 23
struct _OPM_CALLBACK;
#line 23 "/home/june/collector/temp/bopm-3.1.3/src/libopm/src/opm.h"
typedef struct _OPM_CALLBACK OPM_CALLBACK_T;
#line 27 "/home/june/collector/temp/bopm-3.1.3/src/libopm/src/opm.h"
typedef void OPM_CALLBACK_FUNC(OPM_T * , OPM_REMOTE_T * , int  , void * );
#line 29 "/home/june/collector/temp/bopm-3.1.3/src/libopm/src/opm.h"
struct _OPM_CALLBACK {
   OPM_CALLBACK_FUNC *func ;
   void *data ;
};
#line 38 "/home/june/collector/temp/bopm-3.1.3/src/libopm/src/opm.h"
struct _OPM {
   OPM_CONFIG_T *config ;
   OPM_LIST_T *queue ;
   OPM_LIST_T *scans ;
   OPM_LIST_T *protocols ;
   unsigned int fd_use ;
   OPM_CALLBACK_T *callbacks ;
};
#line 48 "/home/june/collector/temp/bopm-3.1.3/src/libopm/src/opm.h"
struct _OPM_REMOTE {
   char *ip ;
   unsigned short port ;
   unsigned short protocol ;
   unsigned short bytes_read ;
   OPM_LIST_T *protocols ;
   void *data ;
};
#line 13 "/home/june/collector/temp/bopm-3.1.3/src/libopm/src/libopm.h"
struct _OPM_SCAN;
#line 13 "/home/june/collector/temp/bopm-3.1.3/src/libopm/src/libopm.h"
typedef struct _OPM_SCAN OPM_SCAN_T;
#line 14
struct _OPM_CONNECTION;
#line 14 "/home/june/collector/temp/bopm-3.1.3/src/libopm/src/libopm.h"
typedef struct _OPM_CONNECTION OPM_CONNECTION_T;
#line 15
struct _OPM_PROTOCOL_CONFIG;
#line 15 "/home/june/collector/temp/bopm-3.1.3/src/libopm/src/libopm.h"
typedef struct _OPM_PROTOCOL_CONFIG OPM_PROTOCOL_CONFIG_T;
#line 16
struct _OPM_PROTOCOL;
#line 16 "/home/june/collector/temp/bopm-3.1.3/src/libopm/src/libopm.h"
typedef struct _OPM_PROTOCOL OPM_PROTOCOL_T;
#line 21 "/home/june/collector/temp/bopm-3.1.3/src/libopm/src/libopm.h"
typedef int OPM_PROXYWRITE_T(OPM_T * , OPM_SCAN_T * , OPM_CONNECTION_T * );
#line 22 "/home/june/collector/temp/bopm-3.1.3/src/libopm/src/libopm.h"
typedef int OPM_PROXYREAD_T(OPM_T * , OPM_SCAN_T * , OPM_CONNECTION_T * );
#line 24 "/home/june/collector/temp/bopm-3.1.3/src/libopm/src/libopm.h"
struct _OPM_SCAN {
   opm_sockaddr addr ;
   OPM_REMOTE_T *remote ;
   OPM_LIST_T *connections ;
};
#line 30 "/home/june/collector/temp/bopm-3.1.3/src/libopm/src/libopm.h"
struct _OPM_CONNECTION {
   OPM_PROTOCOL_T *protocol ;
   unsigned short port ;
   int fd ;
   unsigned short bytes_read ;
   char readbuf[129] ;
   unsigned short readlen ;
   unsigned short state ;
   time_t creation ;
};
#line 43 "/home/june/collector/temp/bopm-3.1.3/src/libopm/src/libopm.h"
struct _OPM_PROTOCOL_CONFIG {
   OPM_PROTOCOL_T *type ;
   unsigned short port ;
};
#line 50 "/home/june/collector/temp/bopm-3.1.3/src/libopm/src/libopm.h"
struct _OPM_PROTOCOL {
   int type ;
   OPM_PROXYWRITE_T *write_function ;
   OPM_PROXYREAD_T *read_function ;
};
#line 141 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds_t;
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 79 "/usr/include/stdio.h"
typedef __gnuc_va_list va_list;
#line 30 "/usr/include/x86_64-linux-gnu/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 54 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef long __fd_mask;
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
struct __anonstruct_fd_set_17 {
   __fd_mask __fds_bits[1024 / (8 * (int )sizeof(__fd_mask ))] ;
};
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef struct __anonstruct_fd_set_17 fd_set;
#line 43 "/usr/include/regex.h"
typedef unsigned long reg_syntax_t;
#line 368 "/usr/include/regex.h"
struct re_pattern_buffer {
   unsigned char *__buffer ;
   unsigned long __allocated ;
   unsigned long __used ;
   reg_syntax_t __syntax ;
   char *__fastmap ;
   unsigned char *__translate ;
   size_t re_nsub ;
   unsigned int __can_be_null : 1 ;
   unsigned int __regs_allocated : 2 ;
   unsigned int __fastmap_accurate : 1 ;
   unsigned int __no_sub : 1 ;
   unsigned int __not_bol : 1 ;
   unsigned int __not_eol : 1 ;
   unsigned int __newline_anchor : 1 ;
};
#line 434 "/usr/include/regex.h"
typedef struct re_pattern_buffer regex_t;
#line 437 "/usr/include/regex.h"
typedef int regoff_t;
#line 463 "/usr/include/regex.h"
struct __anonstruct_regmatch_t_36 {
   regoff_t rm_so ;
   regoff_t rm_eo ;
};
#line 463 "/usr/include/regex.h"
typedef struct __anonstruct_regmatch_t_36 regmatch_t;
#line 34 "/home/june/collector/temp/bopm-3.1.3/src/list.h"
struct _node;
#line 34 "/home/june/collector/temp/bopm-3.1.3/src/list.h"
typedef struct _node node_t;
#line 35
struct _list;
#line 35 "/home/june/collector/temp/bopm-3.1.3/src/list.h"
typedef struct _list list_t;
#line 37 "/home/june/collector/temp/bopm-3.1.3/src/list.h"
struct _list {
   struct _node *head ;
   struct _node *tail ;
   int elements ;
};
#line 46 "/home/june/collector/temp/bopm-3.1.3/src/list.h"
struct _node {
   struct _node *next ;
   struct _node *prev ;
   void *data ;
};
#line 19 "/home/june/collector/temp/bopm-3.1.3/src/config.h"
struct IRCConf {
   char *nick ;
   char *username ;
   char *realname ;
   char *server ;
   int port ;
   char *password ;
   char *vhost ;
   char *nickserv ;
   char *oper ;
   char *mode ;
   char *away ;
   char *connregex ;
   char *kline ;
   list_t *channels ;
   list_t *performs ;
};
#line 43 "/home/june/collector/temp/bopm-3.1.3/src/config.h"
struct ChannelConf {
   char *name ;
   char *key ;
   char *invite ;
};
#line 50 "/home/june/collector/temp/bopm-3.1.3/src/config.h"
struct OptionsConf {
   int negcache ;
   unsigned int dns_fdlimit ;
   char *pidfile ;
   char *scanlog ;
};
#line 10 "/home/june/collector/temp/bopm-3.1.3/src/irc.h"
struct bopm_sockaddr {
   struct sockaddr_in sa4 ;
};
#line 16 "/home/june/collector/temp/bopm-3.1.3/src/irc.h"
struct bopm_ircaddr {
   struct in_addr in4 ;
};
#line 22 "/home/june/collector/temp/bopm-3.1.3/src/irc.h"
struct UserInfo {
   char *irc_nick ;
   char *irc_username ;
   char *irc_hostname ;
};
#line 31 "/home/june/collector/temp/bopm-3.1.3/src/irc.h"
struct CommandHash {
   char *command ;
   void (*handler)(char ** , unsigned int  , char * , struct UserInfo * ) ;
};
#line 4 "/home/june/collector/temp/bopm-3.1.3/src/negcache.h"
struct cnode {
   unsigned long ip ;
   time_t seen ;
   unsigned int b ;
   struct cnode *l ;
   struct cnode *r ;
};
#line 58 "/home/june/collector/temp/bopm-3.1.3/src/config.h"
struct UserConf {
   list_t *masks ;
   list_t *scanners ;
};
#line 64 "/home/june/collector/temp/bopm-3.1.3/src/config.h"
struct ScannerConf {
   char *name ;
   list_t *protocols ;
   char *vhost ;
   int fd ;
   char *target_ip ;
   int target_port ;
   int timeout ;
   int max_read ;
   list_t *target_string ;
   int target_string_created ;
};
#line 83 "/home/june/collector/temp/bopm-3.1.3/src/config.h"
struct ProtocolConf {
   int type ;
   unsigned int port ;
};
#line 89 "/home/june/collector/temp/bopm-3.1.3/src/config.h"
struct OpmConf {
   list_t *blacklists ;
   char *dnsbl_from ;
   char *dnsbl_to ;
   char *sendmail ;
};
#line 97
enum BlacklistType {
    A_BITMASK = 1,
    A_REPLY = 2
} ;
#line 102 "/home/june/collector/temp/bopm-3.1.3/src/config.h"
struct BlacklistConf {
   char *name ;
   char *kline ;
   enum BlacklistType type ;
   int ban_unknown ;
   list_t *reply ;
   unsigned int stats_recv ;
};
#line 112 "/home/june/collector/temp/bopm-3.1.3/src/config.h"
struct BlacklistReplyConf {
   char number ;
   char *type ;
};
#line 118 "/home/june/collector/temp/bopm-3.1.3/src/config.h"
struct ExemptConf {
   list_t *masks ;
};
#line 55 "config-parser.y"
union YYSTYPE {
   int number ;
   char *string ;
};
#line 55 "config-parser.y"
typedef union YYSTYPE YYSTYPE;
#line 229 "config-parser.c"
typedef unsigned char yytype_uint8;
#line 250 "config-parser.c"
typedef short yytype_int16;
#line 381 "config-parser.c"
union yyalloc {
   yytype_int16 yyss ;
   YYSTYPE yyvs ;
};
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 81 "/home/june/collector/temp/bopm-3.1.3/src/firedns.h"
struct firedns_result {
   char text[1024] ;
   char lookup[256] ;
   void *info ;
};
#line 6 "/home/june/collector/temp/bopm-3.1.3/src/scan.h"
struct scan_struct {
   char *irc_nick ;
   char *irc_username ;
   char *irc_hostname ;
   char *ip ;
   char *proof ;
   OPM_REMOTE_T *remote ;
   unsigned short scans ;
   unsigned short positive ;
   struct ChannelConf *manual_target ;
};
#line 13 "/home/june/collector/temp/bopm-3.1.3/src/dnsbl.h"
struct dnsbl_scan {
   struct scan_struct *ss ;
   struct BlacklistConf *bl ;
};
#line 135 "/home/june/collector/temp/bopm-3.1.3/src/setup.h"
typedef unsigned int uint32;
#line 48 "/usr/include/stdint.h"
typedef unsigned char uint8_t;
#line 209 "/usr/include/netinet/in.h"
union __anonunion___in6_u_27 {
   uint8_t __u6_addr8[16] ;
   uint16_t __u6_addr16[8] ;
   uint32_t __u6_addr32[4] ;
};
#line 209 "/usr/include/netinet/in.h"
struct in6_addr {
   union __anonunion___in6_u_27 __in6_u ;
};
#line 97 "/home/june/collector/temp/bopm-3.1.3/src/firedns.c"
struct s_connection {
   unsigned char id[2] ;
   unsigned short class ;
   unsigned short type ;
   int fd ;
   void *info ;
   time_t start ;
   char lookup[256] ;
};
#line 116 "/home/june/collector/temp/bopm-3.1.3/src/firedns.c"
struct s_rr_middle {
   unsigned short type ;
   unsigned short class ;
   uint32 ttl ;
   unsigned short rdlength ;
};
#line 126 "/home/june/collector/temp/bopm-3.1.3/src/firedns.c"
struct s_header {
   unsigned char id[2] ;
   unsigned char flags1 ;
   unsigned char flags2 ;
   unsigned short qdcount ;
   unsigned short ancount ;
   unsigned short nscount ;
   unsigned short arcount ;
   unsigned char payload[512] ;
};
#line 133 "/usr/include/time.h"
struct tm {
   int tm_sec ;
   int tm_min ;
   int tm_hour ;
   int tm_mday ;
   int tm_mon ;
   int tm_year ;
   int tm_wday ;
   int tm_yday ;
   int tm_isdst ;
   long tm_gmtoff ;
   char const   *tm_zone ;
};
#line 315 "/usr/include/libio.h"
typedef struct _IO_FILE _IO_FILE;
#line 51 "config-lexer.c"
typedef short flex_int16_t;
#line 52 "config-lexer.c"
typedef int flex_int32_t;
#line 151
struct yy_buffer_state;
#line 151 "config-lexer.c"
typedef struct yy_buffer_state *YY_BUFFER_STATE;
#line 187 "config-lexer.c"
typedef unsigned int yy_size_t;
#line 192 "config-lexer.c"
struct yy_buffer_state {
   FILE *yy_input_file ;
   char *yy_ch_buf ;
   char *yy_buf_pos ;
   yy_size_t yy_buf_size ;
   int yy_n_chars ;
   int yy_is_our_buffer ;
   int yy_is_interactive ;
   int yy_at_bol ;
   int yy_bs_lineno ;
   int yy_bs_column ;
   int yy_fill_buffer ;
   int yy_buffer_status ;
};
#line 341 "config-lexer.c"
typedef unsigned char YY_CHAR;
#line 345 "config-lexer.c"
typedef int yy_state_type;
#line 136 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __rlim_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/resource.h"
typedef __rlim_t rlim_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/resource.h"
struct rlimit {
   rlim_t rlim_cur ;
   rlim_t rlim_max ;
};
#line 42 "/usr/include/x86_64-linux-gnu/sys/resource.h"
typedef int __rlimit_resource_t;
#line 7 "/home/june/collector/temp/bopm-3.1.3/src/stats.h"
struct StatsHash {
   int type ;
   unsigned int count ;
   char *name ;
};
#line 23 "/home/june/collector/temp/bopm-3.1.3/src/scan.h"
struct scanner_struct {
   char *name ;
   OPM_T *scanner ;
   list_t *masks ;
};
#line 30 "/home/june/collector/temp/bopm-3.1.3/src/scan.h"
struct protocol_assoc {
   int type ;
   char *name ;
};
#line 46 "/home/june/collector/temp/bopm-3.1.3/src/scan.h"
struct kline_format_assoc {
   char key ;
   void *data ;
   int type ;
};
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 133 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 135 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __clock_t;
#line 98 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __pid_t pid_t;
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigset.h"
struct __anonstruct___sigset_t_6 {
   unsigned long __val[1024UL / (8UL * sizeof(unsigned long ))] ;
};
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigset.h"
typedef struct __anonstruct___sigset_t_6 __sigset_t;
#line 32 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
union sigval {
   int sival_int ;
   void *sival_ptr ;
};
#line 32 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
typedef union sigval sigval_t;
#line 58 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
typedef __clock_t __sigchld_clock_t;
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__kill_27 {
   __pid_t si_pid ;
   __uid_t si_uid ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__timer_28 {
   int si_tid ;
   int si_overrun ;
   sigval_t si_sigval ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__rt_29 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   sigval_t si_sigval ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigchld_30 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   int si_status ;
   __sigchld_clock_t si_utime ;
   __sigchld_clock_t si_stime ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigfault_31 {
   void *si_addr ;
   short si_addr_lsb ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigpoll_32 {
   long si_band ;
   int si_fd ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigsys_33 {
   void *_call_addr ;
   int _syscall ;
   unsigned int _arch ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
union __anonunion__sifields_26 {
   int _pad[128UL / sizeof(int ) - 4UL] ;
   struct __anonstruct__kill_27 _kill ;
   struct __anonstruct__timer_28 _timer ;
   struct __anonstruct__rt_29 _rt ;
   struct __anonstruct__sigchld_30 _sigchld ;
   struct __anonstruct__sigfault_31 _sigfault ;
   struct __anonstruct__sigpoll_32 _sigpoll ;
   struct __anonstruct__sigsys_33 _sigsys ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct_siginfo_t_25 {
   int si_signo ;
   int si_errno ;
   int si_code ;
   union __anonunion__sifields_26 _sifields ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
typedef struct __anonstruct_siginfo_t_25 siginfo_t;
#line 85 "/usr/include/signal.h"
typedef void (*__sighandler_t)(int  );
#line 24 "/usr/include/x86_64-linux-gnu/bits/sigaction.h"
union __anonunion___sigaction_handler_45 {
   void (*sa_handler)(int  ) ;
   void (*sa_sigaction)(int  , siginfo_t * , void * ) ;
};
#line 24 "/usr/include/x86_64-linux-gnu/bits/sigaction.h"
struct sigaction {
   union __anonunion___sigaction_handler_45 __sigaction_handler ;
   __sigset_t sa_mask ;
   int sa_flags ;
   void (*sa_restorer)(void) ;
};
#line 6 "/home/june/collector/temp/bopm-3.1.3/src/opercmd.h"
struct Command {
   unsigned short type ;
   char *param ;
   char *irc_nick ;
   struct ChannelConf *target ;
   time_t added ;
};
#line 35 "/home/june/collector/temp/bopm-3.1.3/src/opercmd.h"
struct OperCommandHash {
   char *command ;
   void (*handler)(char * , char * , struct ChannelConf * ) ;
};
#line 13 "/home/june/collector/temp/bopm-3.1.3/src/libopm/src/malloc.h"
void *libopm_MyMalloc(size_t bytes ) ;
#line 14
void libopm_MyFree(void **var ) ;
#line 58 "/usr/include/arpa/inet.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) inet_pton)(int __af ,
                                                                                char const   * __restrict  __cp ,
                                                                                void * __restrict  __buf ) ;
#line 13 "/home/june/collector/temp/bopm-3.1.3/src/libopm/src/config.h"
void libopm_config_free(OPM_CONFIG_T *config ) ;
#line 14
void *libopm_config(OPM_CONFIG_T *config , int key ) ;
#line 15
int libopm_config_gettype(int key ) ;
#line 16
OPM_CONFIG_T *libopm_config_create(void) ;
#line 17
OPM_ERR_T libopm_config_set(OPM_CONFIG_T *config , int key , void *value ) ;
#line 33 "/home/june/collector/temp/bopm-3.1.3/src/libopm/src/list.h"
OPM_NODE_T *libopm_node_create(void *data ) ;
#line 34
OPM_LIST_T *libopm_list_create(void) ;
#line 36
OPM_NODE_T *libopm_list_add(OPM_LIST_T *list , OPM_NODE_T *node ) ;
#line 66 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 176
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 40 "/home/june/collector/temp/bopm-3.1.3/src/libopm/src/config.c"
static OPM_CONFIG_HASH_T HASH[8]  = 
#line 40 "/home/june/collector/temp/bopm-3.1.3/src/libopm/src/config.c"
  {      {0, 1}, 
        {1, 3}, 
        {2, 2}, 
        {3, 4}, 
        {4, 2}, 
        {5, 1}, 
        {6, 1}, 
        {7, 1}};
#line 63 "/home/june/collector/temp/bopm-3.1.3/src/libopm/src/config.c"
OPM_CONFIG_T *libopm_config_create(void) 
{ 
  int num ;
  int i ;
  OPM_CONFIG_T *ret ;
  void *tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  OPM_LIST_T *tmp___4 ;

  {
  {
#line 68
  num = (int )(sizeof(HASH) / sizeof(OPM_CONFIG_HASH_T ));
#line 70
  tmp___0 = libopm_MyMalloc(sizeof(OPM_CONFIG_T ));
#line 70
  ret = (OPM_CONFIG_T *)tmp___0;
#line 71
  tmp___1 = libopm_MyMalloc(sizeof(void *) * (unsigned long )num);
#line 71
  ret->vars = (void **)tmp___1;
#line 83
  i = 0;
  }
  {
#line 83
  while (1) {
    while_continue: /* CIL Label */ ;
#line 83
    if (! (i < num)) {
#line 83
      goto while_break;
    }
    {
#line 85
    tmp___2 = libopm_config_gettype(i);
    }
    {
#line 87
    if (tmp___2 == 1) {
#line 87
      goto case_1;
    }
#line 92
    if (tmp___2 == 2) {
#line 92
      goto case_2;
    }
#line 96
    if (tmp___2 == 3) {
#line 96
      goto case_3;
    }
#line 101
    if (tmp___2 == 4) {
#line 101
      goto case_4;
    }
#line 104
    goto switch_default;
    case_1: /* CIL Label */ 
    {
#line 88
    *(ret->vars + i) = libopm_MyMalloc(sizeof(int ));
#line 89
    *((int *)*(ret->vars + i)) = 0;
    }
#line 90
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 93
    tmp___3 = strdup("");
#line 93
    *(ret->vars + i) = (void *)tmp___3;
    }
#line 94
    goto switch_break;
    case_3: /* CIL Label */ 
    {
#line 97
    *(ret->vars + i) = libopm_MyMalloc(sizeof(opm_sockaddr ));
#line 98
    memset((void *)((opm_sockaddr *)*(ret->vars + i)), 0, sizeof(opm_sockaddr ));
    }
#line 99
    goto switch_break;
    case_4: /* CIL Label */ 
    {
#line 102
    tmp___4 = libopm_list_create();
#line 102
    *(ret->vars + i) = (void *)tmp___4;
    }
#line 103
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 105
    *(ret->vars + i) = (void *)0;
    switch_break: /* CIL Label */ ;
    }
#line 83
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 108
  return (ret);
}
}
#line 125 "/home/june/collector/temp/bopm-3.1.3/src/libopm/src/config.c"
void libopm_config_free(OPM_CONFIG_T *config ) 
{ 
  int num ;
  int i ;
  OPM_NODE_T *p ;
  OPM_NODE_T *next ;
  OPM_LIST_T *list ;
  int tmp___0 ;

  {
#line 131
  num = (int )(sizeof(HASH) / sizeof(OPM_CONFIG_HASH_T ));
#line 133
  i = 0;
  {
#line 133
  while (1) {
    while_continue: /* CIL Label */ ;
#line 133
    if (! (i < num)) {
#line 133
      goto while_break;
    }
#line 135
    if ((unsigned long )*(config->vars + i) == (unsigned long )((void *)0)) {
#line 136
      goto __Cont;
    }
    {
#line 138
    tmp___0 = libopm_config_gettype(i);
    }
    {
#line 140
    if (tmp___0 == 4) {
#line 140
      goto case_4;
    }
#line 148
    goto switch_default;
    case_4: /* CIL Label */ 
#line 141
    list = (OPM_LIST_T *)*(config->vars + i);
#line 142
    p = list->head;
#line 142
    if (p) {
#line 142
      next = p->next;
    } else {
#line 142
      next = (OPM_NODE_T *)((void *)0);
    }
    {
#line 142
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 142
      if (! ((unsigned long )p != (unsigned long )((void *)0))) {
#line 142
        goto while_break___0;
      }
      {
#line 144
      libopm_MyFree(& p->data);
#line 145
      libopm_MyFree((void **)(& p));
#line 142
      p = next;
      }
#line 142
      if (p) {
#line 142
        next = p->next;
      } else {
#line 142
        next = (OPM_NODE_T *)((void *)0);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 147
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 149
    libopm_MyFree(config->vars + i);
    }
#line 150
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
#line 133
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 154
  libopm_MyFree((void **)(& config->vars));
#line 155
  libopm_MyFree((void **)(& config));
  }
#line 156
  return;
}
}
#line 175 "/home/june/collector/temp/bopm-3.1.3/src/libopm/src/config.c"
OPM_ERR_T libopm_config_set(OPM_CONFIG_T *config , int key , void *value ) 
{ 
  int num ;
  OPM_NODE_T *node ;
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;

  {
#line 181
  num = (int )(sizeof(HASH) / sizeof(OPM_CONFIG_HASH_T ));
#line 183
  if (key < 0) {
#line 184
    return (2);
  } else
#line 183
  if (key >= num) {
#line 184
    return (2);
  }
  {
#line 186
  tmp___0 = libopm_config_gettype(key);
  }
  {
#line 188
  if (tmp___0 == 2) {
#line 188
    goto case_2;
  }
#line 194
  if (tmp___0 == 1) {
#line 194
    goto case_1;
  }
#line 198
  if (tmp___0 == 3) {
#line 198
    goto case_3;
  }
#line 204
  if (tmp___0 == 4) {
#line 204
    goto case_4;
  }
#line 209
  goto switch_default;
  case_2: /* CIL Label */ 
#line 189
  if ((unsigned long )((char *)*(config->vars + key)) != (unsigned long )((void *)0)) {
    {
#line 190
    libopm_MyFree(config->vars + key);
    }
  }
  {
#line 191
  tmp___1 = strdup((char const   *)((char *)value));
#line 191
  *(config->vars + key) = (void *)tmp___1;
  }
#line 192
  goto switch_break;
  case_1: /* CIL Label */ 
#line 195
  *((int *)*(config->vars + key)) = *((int *)value);
#line 196
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 199
  tmp___2 = inet_pton(2, (char const   */* __restrict  */)((char *)value), (void */* __restrict  */)(& ((opm_sockaddr *)*(config->vars + key))->sa4.sin_addr));
  }
#line 199
  if (tmp___2 <= 0) {
#line 201
    return (3);
  }
#line 202
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 205
  tmp___3 = strdup((char const   *)((char *)value));
#line 205
  node = libopm_node_create((void *)tmp___3);
#line 206
  libopm_list_add((OPM_LIST_T *)*(config->vars + key), node);
  }
#line 207
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 210
  return (2);
  switch_break: /* CIL Label */ ;
  }
#line 214
  return (1);
}
}
#line 232 "/home/june/collector/temp/bopm-3.1.3/src/libopm/src/config.c"
int libopm_config_gettype(int key ) 
{ 
  int num ;
  int i ;

  {
#line 236
  num = (int )(sizeof(HASH) / sizeof(OPM_CONFIG_HASH_T ));
#line 238
  i = 0;
  {
#line 238
  while (1) {
    while_continue: /* CIL Label */ ;
#line 238
    if (! (i < num)) {
#line 238
      goto while_break;
    }
#line 239
    if (HASH[i].key == key) {
#line 240
      return (HASH[i].type);
    }
#line 238
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 242
  return (0);
}
}
#line 261 "/home/june/collector/temp/bopm-3.1.3/src/libopm/src/config.c"
void *libopm_config(OPM_CONFIG_T *config , int key ) 
{ 


  {
#line 263
  return (*(config->vars + key));
}
}
#line 37 "/home/june/collector/temp/bopm-3.1.3/src/libopm/src/list.h"
OPM_NODE_T *libopm_list_remove(OPM_LIST_T *list , OPM_NODE_T *node ) ;
#line 39
void libopm_list_free(OPM_LIST_T *list ) ;
#line 40
void libopm_node_free(OPM_NODE_T *node ) ;
#line 33 "/home/june/collector/temp/bopm-3.1.3/src/libopm/src/list.c"
OPM_NODE_T *libopm_node_create(void *data ) 
{ 
  OPM_NODE_T *node ;
  void *tmp___0 ;

  {
  {
#line 35
  tmp___0 = libopm_MyMalloc(sizeof(*node));
#line 35
  node = (OPM_NODE_T *)tmp___0;
#line 36
  node->next = (struct _libopm_node *)((void *)0);
#line 37
  node->prev = (struct _libopm_node *)((void *)0);
#line 38
  node->data = data;
  }
#line 40
  return (node);
}
}
#line 43 "/home/june/collector/temp/bopm-3.1.3/src/libopm/src/list.c"
OPM_LIST_T *libopm_list_create(void) 
{ 
  OPM_LIST_T *list ;
  void *tmp___0 ;

  {
  {
#line 45
  tmp___0 = libopm_MyMalloc(sizeof(*list));
#line 45
  list = (OPM_LIST_T *)tmp___0;
#line 47
  list->head = (struct _libopm_node *)((void *)0);
#line 48
  list->tail = (struct _libopm_node *)((void *)0);
#line 50
  list->elements = 0;
  }
#line 52
  return (list);
}
}
#line 55 "/home/june/collector/temp/bopm-3.1.3/src/libopm/src/list.c"
OPM_NODE_T *libopm_list_add(OPM_LIST_T *list , OPM_NODE_T *node ) 
{ 


  {
#line 58
  if ((unsigned long )list == (unsigned long )((void *)0)) {
#line 59
    return ((OPM_NODE_T *)((void *)0));
  } else
#line 58
  if ((unsigned long )node == (unsigned long )((void *)0)) {
#line 59
    return ((OPM_NODE_T *)((void *)0));
  }
#line 61
  if ((unsigned long )list->tail == (unsigned long )((void *)0)) {
#line 63
    list->head = node;
#line 64
    list->tail = node;
#line 66
    node->next = (struct _libopm_node *)((void *)0);
#line 67
    node->prev = (struct _libopm_node *)((void *)0);
  } else {
#line 71
    node->prev = list->tail;
#line 72
    (list->tail)->next = node;
#line 73
    list->tail = node;
#line 74
    node->next = (struct _libopm_node *)((void *)0);
  }
#line 77
  (list->elements) ++;
#line 78
  return (node);
}
}
#line 81 "/home/june/collector/temp/bopm-3.1.3/src/libopm/src/list.c"
OPM_NODE_T *libopm_list_remove(OPM_LIST_T *list , OPM_NODE_T *node ) 
{ 


  {
#line 84
  if ((unsigned long )list == (unsigned long )((void *)0)) {
#line 85
    return ((OPM_NODE_T *)((void *)0));
  } else
#line 84
  if ((unsigned long )node == (unsigned long )((void *)0)) {
#line 85
    return ((OPM_NODE_T *)((void *)0));
  }
#line 87
  if ((unsigned long )node == (unsigned long )list->head) {
#line 89
    list->head = node->next;
#line 91
    if (node->next) {
#line 92
      (node->next)->prev = (struct _libopm_node *)((void *)0);
    } else {
#line 94
      list->tail = (struct _libopm_node *)((void *)0);
    }
  } else
#line 96
  if ((unsigned long )node == (unsigned long )list->tail) {
#line 98
    list->tail = (list->tail)->prev;
#line 99
    (list->tail)->next = (struct _libopm_node *)((void *)0);
  } else {
#line 103
    (node->prev)->next = node->next;
#line 104
    (node->next)->prev = node->prev;
  }
#line 107
  (list->elements) --;
#line 108
  return (node);
}
}
#line 111 "/home/june/collector/temp/bopm-3.1.3/src/libopm/src/list.c"
void libopm_list_free(OPM_LIST_T *list ) 
{ 


  {
  {
#line 113
  libopm_MyFree((void **)(& list));
  }
#line 114
  return;
}
}
#line 116 "/home/june/collector/temp/bopm-3.1.3/src/libopm/src/list.c"
void libopm_node_free(OPM_NODE_T *node ) 
{ 


  {
  {
#line 118
  libopm_MyFree((void **)(& node));
  }
#line 119
  return;
}
}
#line 69 "/usr/include/assert.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) __assert_fail)(char const   *__assertion ,
                                                                                                   char const   *__file ,
                                                                                                   unsigned int __line ,
                                                                                                   char const   *__function ) ;
#line 468 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) calloc)(size_t __nmemb ,
                                                                               size_t __size )  __attribute__((__malloc__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 45 "/home/june/collector/temp/bopm-3.1.3/src/libopm/src/malloc.c"
void *libopm_MyMalloc(size_t bytes ) 
{ 
  void *ret ;
  void *tmp___0 ;

  {
  {
#line 47
  tmp___0 = calloc((size_t )1, bytes);
#line 47
  ret = tmp___0;
  }
#line 49
  if (! ret) {
    {
#line 49
    __assert_fail("ret", "/home/june/collector/temp/bopm-3.1.3/src/libopm/src/malloc.c",
                  49U, "libopm_MyMalloc");
    }
  }
#line 51
  return (ret);
}
}
#line 67 "/home/june/collector/temp/bopm-3.1.3/src/libopm/src/malloc.c"
void libopm_MyFree(void **var ) 
{ 


  {
#line 69
  if ((unsigned long )*var != (unsigned long )((void *)0)) {
    {
#line 70
    free(*var);
    }
  }
#line 71
  *var = (void *)0;
#line 72
  return;
}
}
#line 113 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) socket)(int __domain ,
                                                                             int __type ,
                                                                             int __protocol ) ;
#line 123
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) bind)(int __fd ,
                                                                           struct sockaddr  const  *__addr ,
                                                                           socklen_t __len ) ;
#line 137
extern int connect(int __fd , struct sockaddr  const  *__addr , socklen_t __len ) ;
#line 379 "/usr/include/netinet/in.h"
extern  __attribute__((__nothrow__)) uint16_t ( __attribute__((__leaf__)) htons)(uint16_t __hostshort )  __attribute__((__const__)) ;
#line 137 "/usr/include/fcntl.h"
extern int fcntl(int __fd , int __cmd  , ...) ;
#line 57 "/usr/include/x86_64-linux-gnu/sys/poll.h"
extern int poll(struct pollfd *__fds , nfds_t __nfds , int __timeout ) ;
#line 61 "/home/june/collector/temp/bopm-3.1.3/src/libopm/src/opm.h"
OPM_T *opm_create(void) ;
#line 62
void opm_free(OPM_T *scanner ) ;
#line 64
OPM_REMOTE_T *opm_remote_create(char const   *ip ) ;
#line 65
void opm_remote_free(OPM_REMOTE_T *remote ) ;
#line 67
OPM_ERR_T opm_config(OPM_T *scanner , int key , void *value ) ;
#line 68
OPM_ERR_T opm_scan(OPM_T *scanner , OPM_REMOTE_T *remote ) ;
#line 69
void opm_end(OPM_T *scanner , OPM_REMOTE_T *remote ) ;
#line 70
void opm_endscan(OPM_T *scanner , OPM_REMOTE_T *remote ) ;
#line 72
OPM_ERR_T opm_addtype(OPM_T *scanner , int type , unsigned short port ) ;
#line 73
OPM_ERR_T opm_remote_addtype(OPM_REMOTE_T *remote , int type , unsigned short port ) ;
#line 74
OPM_ERR_T opm_callback(OPM_T *scanner , int type , OPM_CALLBACK_FUNC *function , void *data ) ;
#line 76
void opm_cycle(OPM_T *scanner ) ;
#line 78
size_t opm_active(OPM_T *scanner ) ;
#line 6 "/home/june/collector/temp/bopm-3.1.3/src/libopm/src/proxy.h"
int libopm_proxy_http_write(OPM_T *scanner , OPM_SCAN_T *scan , OPM_CONNECTION_T *conn ) ;
#line 7
int libopm_proxy_socks4_write(OPM_T *scanner , OPM_SCAN_T *scan , OPM_CONNECTION_T *conn ) ;
#line 8
int libopm_proxy_socks5_write(OPM_T *scanner , OPM_SCAN_T *scan , OPM_CONNECTION_T *conn ) ;
#line 9
int libopm_proxy_wingate_write(OPM_T *scanner , OPM_SCAN_T *scan , OPM_CONNECTION_T *conn ) ;
#line 10
int libopm_proxy_router_write(OPM_T *scanner , OPM_SCAN_T *scan , OPM_CONNECTION_T *conn ) ;
#line 11
int libopm_proxy_httppost_write(OPM_T *scanner , OPM_SCAN_T *scan , OPM_CONNECTION_T *conn ) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 192 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t ( __attribute__((__leaf__)) time)(time_t *__timer ) ;
#line 353 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 360
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 342 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strstr)(char const   *__haystack ,
                                                                                                 char const   *__needle )  __attribute__((__pure__)) ;
#line 56 "/home/june/collector/temp/bopm-3.1.3/src/libopm/src/libopm.c"
static OPM_PROTOCOL_CONFIG_T *libopm_protocol_config_create(void) ;
#line 57
static void libopm_protocol_config_free(OPM_PROTOCOL_CONFIG_T *protocol ) ;
#line 68
static OPM_SCAN_T *libopm_scan_create(OPM_T *scanner , OPM_REMOTE_T *remote ) ;
#line 69
static void libopm_scan_free(OPM_SCAN_T *scan ) ;
#line 71
static OPM_CONNECTION_T *libopm_connection_create(void) ;
#line 72
static void libopm_connection_free(OPM_CONNECTION_T *conn ) ;
#line 74
static void libopm_check_establish(OPM_T *scanner ) ;
#line 75
static void libopm_check_poll(OPM_T *scanner ) ;
#line 76
static void libopm_check_closed(OPM_T *scanner ) ;
#line 77
static void libopm_check_queue(OPM_T *scanner ) ;
#line 79
static void libopm_do_connect(OPM_T *scanner , OPM_SCAN_T *scan , OPM_CONNECTION_T *conn ) ;
#line 80
static void libopm_do_readready(OPM_T *scanner , OPM_SCAN_T *scan , OPM_CONNECTION_T *conn ) ;
#line 81
static void libopm_do_writeready(OPM_T *scanner , OPM_SCAN_T *scan , OPM_CONNECTION_T *conn ) ;
#line 82
static void libopm_do_hup(OPM_T *scanner , OPM_SCAN_T *scan , OPM_CONNECTION_T *conn ) ;
#line 83
static void libopm_do_read(OPM_T *scanner , OPM_SCAN_T *scan , OPM_CONNECTION_T *conn ) ;
#line 84
static void libopm_do_openproxy(OPM_T *scanner , OPM_SCAN_T *scan , OPM_CONNECTION_T *conn ) ;
#line 86
static void libopm_do_callback(OPM_T *scanner , OPM_REMOTE_T *remote , int type ,
                               int var ) ;
#line 88
static OPM_REMOTE_T *libopm_setup_remote(OPM_REMOTE_T *remote , OPM_CONNECTION_T *conn ) ;
#line 99 "/home/june/collector/temp/bopm-3.1.3/src/libopm/src/libopm.c"
static OPM_PROTOCOL_T OPM_PROTOCOLS[6]  = {      {1, & libopm_proxy_http_write, (OPM_PROXYREAD_T *)((void *)0)}, 
        {2, & libopm_proxy_socks4_write, (OPM_PROXYREAD_T *)((void *)0)}, 
        {3, & libopm_proxy_socks5_write, (OPM_PROXYREAD_T *)((void *)0)}, 
        {5, & libopm_proxy_router_write, (OPM_PROXYREAD_T *)((void *)0)}, 
        {4, & libopm_proxy_wingate_write, (OPM_PROXYREAD_T *)((void *)0)}, 
        {6, & libopm_proxy_httppost_write, (OPM_PROXYREAD_T *)((void *)0)}};
#line 122 "/home/june/collector/temp/bopm-3.1.3/src/libopm/src/libopm.c"
OPM_T *opm_create(void) 
{ 
  int i ;
  OPM_T *ret ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 127
  tmp___0 = libopm_MyMalloc(sizeof(*ret));
#line 127
  ret = (OPM_T *)tmp___0;
#line 129
  ret->config = libopm_config_create();
#line 130
  ret->scans = libopm_list_create();
#line 131
  ret->queue = libopm_list_create();
#line 132
  ret->protocols = libopm_list_create();
#line 133
  ret->fd_use = 0U;
#line 136
  tmp___1 = libopm_MyMalloc(sizeof(OPM_CALLBACK_T ) * 5UL);
#line 136
  ret->callbacks = (OPM_CALLBACK_T *)tmp___1;
#line 137
  i = 0;
  }
  {
#line 137
  while (1) {
    while_continue: /* CIL Label */ ;
#line 137
    if (! (i < 5)) {
#line 137
      goto while_break;
    }
#line 139
    (ret->callbacks + i)->func = (OPM_CALLBACK_FUNC *)((void *)0);
#line 140
    (ret->callbacks + i)->data = (void *)0;
#line 137
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 143
  return (ret);
}
}
#line 162 "/home/june/collector/temp/bopm-3.1.3/src/libopm/src/libopm.c"
OPM_REMOTE_T *opm_remote_create(char const   *ip ) 
{ 
  OPM_REMOTE_T *ret ;
  void *tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 167
  tmp___0 = libopm_MyMalloc(sizeof(*ret));
#line 167
  ret = (OPM_REMOTE_T *)tmp___0;
  }
#line 170
  if ((unsigned long )ip == (unsigned long )((void *)0)) {
#line 171
    return ((OPM_REMOTE_T *)((void *)0));
  }
  {
#line 173
  tmp___1 = strdup(ip);
#line 173
  ret->ip = tmp___1;
#line 175
  ret->port = (unsigned short)0;
#line 176
  ret->protocol = (unsigned short)0;
#line 177
  ret->bytes_read = (unsigned short)0;
#line 179
  ret->data = (void *)0;
#line 181
  ret->protocols = libopm_list_create();
  }
#line 183
  return (ret);
}
}
#line 199 "/home/june/collector/temp/bopm-3.1.3/src/libopm/src/libopm.c"
void opm_remote_free(OPM_REMOTE_T *remote ) 
{ 
  OPM_NODE_T *p ;
  OPM_NODE_T *next ;
  OPM_PROTOCOL_CONFIG_T *ppc ;

  {
  {
#line 205
  libopm_MyFree((void **)(& remote->ip));
#line 207
  p = (remote->protocols)->head;
  }
#line 207
  if (p) {
#line 207
    next = p->next;
  } else {
#line 207
    next = (OPM_NODE_T *)((void *)0);
  }
  {
#line 207
  while (1) {
    while_continue: /* CIL Label */ ;
#line 207
    if (! ((unsigned long )p != (unsigned long )((void *)0))) {
#line 207
      goto while_break;
    }
    {
#line 209
    ppc = (OPM_PROTOCOL_CONFIG_T *)p->data;
#line 211
    libopm_protocol_config_free(ppc);
#line 212
    libopm_list_remove(remote->protocols, p);
#line 213
    libopm_node_free(p);
#line 207
    p = next;
    }
#line 207
    if (p) {
#line 207
      next = p->next;
    } else {
#line 207
      next = (OPM_NODE_T *)((void *)0);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 216
  libopm_list_free(remote->protocols);
#line 218
  libopm_MyFree((void **)(& remote));
  }
#line 219
  return;
}
}
#line 234 "/home/june/collector/temp/bopm-3.1.3/src/libopm/src/libopm.c"
OPM_ERR_T opm_callback(OPM_T *scanner , int type , OPM_CALLBACK_FUNC *function , void *data ) 
{ 


  {
#line 236
  if (type < 0) {
#line 237
    return (6);
  } else
#line 236
  if (type >= 6) {
#line 237
    return (6);
  }
#line 239
  (scanner->callbacks + type)->func = function;
#line 240
  (scanner->callbacks + type)->data = data;
#line 242
  return (1);
}
}
#line 259 "/home/june/collector/temp/bopm-3.1.3/src/libopm/src/libopm.c"
void opm_free(OPM_T *scanner ) 
{ 
  OPM_NODE_T *p ;
  OPM_NODE_T *next ;
  OPM_PROTOCOL_CONFIG_T *ppc ;
  OPM_SCAN_T *scan ;

  {
  {
#line 265
  libopm_config_free(scanner->config);
#line 267
  p = (scanner->protocols)->head;
  }
#line 267
  if (p) {
#line 267
    next = p->next;
  } else {
#line 267
    next = (OPM_NODE_T *)((void *)0);
  }
  {
#line 267
  while (1) {
    while_continue: /* CIL Label */ ;
#line 267
    if (! ((unsigned long )p != (unsigned long )((void *)0))) {
#line 267
      goto while_break;
    }
    {
#line 269
    ppc = (OPM_PROTOCOL_CONFIG_T *)p->data;
#line 271
    libopm_protocol_config_free(ppc);
#line 272
    libopm_list_remove(scanner->protocols, p);
#line 273
    libopm_node_free(p);
#line 267
    p = next;
    }
#line 267
    if (p) {
#line 267
      next = p->next;
    } else {
#line 267
      next = (OPM_NODE_T *)((void *)0);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 276
  p = (scanner->scans)->head;
#line 276
  if (p) {
#line 276
    next = p->next;
  } else {
#line 276
    next = (OPM_NODE_T *)((void *)0);
  }
  {
#line 276
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 276
    if (! ((unsigned long )p != (unsigned long )((void *)0))) {
#line 276
      goto while_break___0;
    }
    {
#line 278
    scan = (OPM_SCAN_T *)p->data;
#line 279
    libopm_scan_free(scan);
#line 280
    libopm_list_remove(scanner->scans, p);
#line 281
    libopm_node_free(p);
#line 276
    p = next;
    }
#line 276
    if (p) {
#line 276
      next = p->next;
    } else {
#line 276
      next = (OPM_NODE_T *)((void *)0);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 284
  p = (scanner->queue)->head;
#line 284
  if (p) {
#line 284
    next = p->next;
  } else {
#line 284
    next = (OPM_NODE_T *)((void *)0);
  }
  {
#line 284
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 284
    if (! ((unsigned long )p != (unsigned long )((void *)0))) {
#line 284
      goto while_break___1;
    }
    {
#line 286
    scan = (OPM_SCAN_T *)p->data;
#line 287
    libopm_scan_free(scan);
#line 288
    libopm_list_remove(scanner->queue, p);
#line 289
    libopm_node_free(p);
#line 284
    p = next;
    }
#line 284
    if (p) {
#line 284
      next = p->next;
    } else {
#line 284
      next = (OPM_NODE_T *)((void *)0);
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 292
  libopm_list_free(scanner->protocols);
#line 293
  libopm_list_free(scanner->scans);
#line 294
  libopm_list_free(scanner->queue);
#line 296
  libopm_MyFree((void **)(& scanner->callbacks));
#line 297
  libopm_MyFree((void **)(& scanner));
  }
#line 298
  return;
}
}
#line 317 "/home/june/collector/temp/bopm-3.1.3/src/libopm/src/libopm.c"
OPM_ERR_T opm_config(OPM_T *scanner , int key , void *value ) 
{ 
  OPM_ERR_T tmp___0 ;

  {
  {
#line 319
  tmp___0 = libopm_config_set(scanner->config, key, value);
  }
#line 319
  return (tmp___0);
}
}
#line 339 "/home/june/collector/temp/bopm-3.1.3/src/libopm/src/libopm.c"
OPM_ERR_T opm_addtype(OPM_T *scanner , int type , unsigned short port ) 
{ 
  unsigned int i ;
  OPM_NODE_T *node ;
  OPM_PROTOCOL_CONFIG_T *protocol_config ;

  {
#line 346
  i = 0U;
  {
#line 346
  while (1) {
    while_continue: /* CIL Label */ ;
#line 346
    if (! ((unsigned long )i < sizeof(OPM_PROTOCOLS) / sizeof(OPM_PROTOCOL_T ))) {
#line 346
      goto while_break;
    }
#line 348
    if (type == OPM_PROTOCOLS[i].type) {
      {
#line 350
      protocol_config = libopm_protocol_config_create();
#line 352
      protocol_config->type = & OPM_PROTOCOLS[i];
#line 353
      protocol_config->port = port;
#line 355
      node = libopm_node_create((void *)protocol_config);
#line 356
      libopm_list_add(scanner->protocols, node);
      }
#line 358
      return (1);
    }
#line 346
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 362
  return (4);
}
}
#line 381 "/home/june/collector/temp/bopm-3.1.3/src/libopm/src/libopm.c"
OPM_ERR_T opm_remote_addtype(OPM_REMOTE_T *remote , int type , unsigned short port ) 
{ 
  unsigned int i ;
  OPM_NODE_T *node ;
  OPM_PROTOCOL_CONFIG_T *protocol_config ;

  {
#line 388
  i = 0U;
  {
#line 388
  while (1) {
    while_continue: /* CIL Label */ ;
#line 388
    if (! ((unsigned long )i < sizeof(OPM_PROTOCOLS) / sizeof(OPM_PROTOCOL_T ))) {
#line 388
      goto while_break;
    }
#line 390
    if (type == OPM_PROTOCOLS[i].type) {
      {
#line 392
      protocol_config = libopm_protocol_config_create();
#line 394
      protocol_config->type = & OPM_PROTOCOLS[i];
#line 395
      protocol_config->port = port;
#line 397
      node = libopm_node_create((void *)protocol_config);
#line 398
      libopm_list_add(remote->protocols, node);
      }
#line 400
      return (1);
    }
#line 388
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 403
  return (4);
}
}
#line 473 "/home/june/collector/temp/bopm-3.1.3/src/libopm/src/libopm.c"
static OPM_PROTOCOL_CONFIG_T *libopm_protocol_config_create(void) 
{ 
  OPM_PROTOCOL_CONFIG_T *ret ;
  void *tmp___0 ;

  {
  {
#line 476
  tmp___0 = libopm_MyMalloc(sizeof(*ret));
#line 476
  ret = (OPM_PROTOCOL_CONFIG_T *)tmp___0;
  }
#line 478
  return (ret);
}
}
#line 495 "/home/june/collector/temp/bopm-3.1.3/src/libopm/src/libopm.c"
static void libopm_protocol_config_free(OPM_PROTOCOL_CONFIG_T *protocol ) 
{ 


  {
  {
#line 497
  libopm_MyFree((void **)(& protocol));
  }
#line 498
  return;
}
}
#line 517 "/home/june/collector/temp/bopm-3.1.3/src/libopm/src/libopm.c"
OPM_ERR_T opm_scan(OPM_T *scanner , OPM_REMOTE_T *remote ) 
{ 
  OPM_SCAN_T *scan ;
  OPM_NODE_T *node ;
  unsigned int fd_limit ;
  void *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 524
  tmp___0 = libopm_config(scanner->config, 0);
#line 524
  fd_limit = (unsigned int )*((int *)tmp___0);
  }
#line 526
  if ((scanner->protocols)->elements == 0) {
#line 526
    if ((remote->protocols)->elements == 0) {
#line 529
      return (8);
    }
  }
  {
#line 532
  scan = libopm_scan_create(scanner, remote);
#line 534
  tmp___1 = inet_pton(2, (char const   */* __restrict  */)remote->ip, (void */* __restrict  */)(& scan->addr.sa4.sin_addr));
  }
#line 534
  if (tmp___1 <= 0) {
    {
#line 536
    libopm_scan_free(scan);
    }
#line 537
    return (7);
  }
  {
#line 540
  node = libopm_node_create((void *)scan);
#line 541
  libopm_list_add(scanner->queue, node);
  }
#line 543
  return (1);
}
}
#line 561 "/home/june/collector/temp/bopm-3.1.3/src/libopm/src/libopm.c"
void opm_end(OPM_T *scanner , OPM_REMOTE_T *remote ) 
{ 
  OPM_NODE_T *node1 ;
  OPM_NODE_T *node2 ;
  OPM_NODE_T *next1 ;
  OPM_NODE_T *next2 ;
  OPM_SCAN_T *scan ;
  OPM_CONNECTION_T *conn ;

  {
  {
#line 569
  opm_endscan(scanner, remote);
#line 574
  node1 = (scanner->queue)->head;
  }
#line 574
  if (node1) {
#line 574
    next1 = node1->next;
  } else {
#line 574
    next1 = (OPM_NODE_T *)((void *)0);
  }
  {
#line 574
  while (1) {
    while_continue: /* CIL Label */ ;
#line 574
    if (! ((unsigned long )node1 != (unsigned long )((void *)0))) {
#line 574
      goto while_break;
    }
#line 576
    scan = (OPM_SCAN_T *)node1->data;
#line 577
    if ((unsigned long )scan->remote == (unsigned long )remote) {
#line 580
      node2 = (scan->connections)->head;
#line 580
      if (node2) {
#line 580
        next2 = node2->next;
      } else {
#line 580
        next2 = (OPM_NODE_T *)((void *)0);
      }
      {
#line 580
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 580
        if (! ((unsigned long )node2 != (unsigned long )((void *)0))) {
#line 580
          goto while_break___0;
        }
        {
#line 583
        conn = (OPM_CONNECTION_T *)node2->data;
#line 585
        libopm_list_remove(scan->connections, node2);
#line 586
        libopm_connection_free(conn);
#line 587
        libopm_node_free(node2);
        }
#line 588
        goto __Cont;
        __Cont: /* CIL Label */ 
#line 580
        node2 = next2;
#line 580
        if (node2) {
#line 580
          next2 = node2->next;
        } else {
#line 580
          next2 = (OPM_NODE_T *)((void *)0);
        }
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 592
      libopm_do_callback(scanner, scan->remote, 2, 0);
#line 595
      libopm_list_remove(scanner->queue, node1);
#line 596
      libopm_scan_free(scan);
#line 597
      libopm_node_free(node1);
      }
    }
#line 574
    node1 = next1;
#line 574
    if (node1) {
#line 574
      next1 = node1->next;
    } else {
#line 574
      next1 = (OPM_NODE_T *)((void *)0);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 600
  return;
}
}
#line 619 "/home/june/collector/temp/bopm-3.1.3/src/libopm/src/libopm.c"
void opm_endscan(OPM_T *scanner , OPM_REMOTE_T *remote ) 
{ 
  OPM_NODE_T *node1 ;
  OPM_NODE_T *node2 ;
  OPM_SCAN_T *scan ;
  OPM_CONNECTION_T *conn ;

  {
#line 631
  node1 = (scanner->scans)->head;
  {
#line 631
  while (1) {
    while_continue: /* CIL Label */ ;
#line 631
    if (! ((unsigned long )node1 != (unsigned long )((void *)0))) {
#line 631
      goto while_break;
    }
#line 633
    scan = (OPM_SCAN_T *)node1->data;
#line 635
    if ((unsigned long )scan->remote == (unsigned long )remote) {
#line 637
      node2 = (scan->connections)->head;
      {
#line 637
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 637
        if (! ((unsigned long )node2 != (unsigned long )((void *)0))) {
#line 637
          goto while_break___0;
        }
#line 639
        conn = (OPM_CONNECTION_T *)node2->data;
#line 640
        conn->state = (unsigned short)4;
#line 637
        node2 = node2->next;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 631
    node1 = node1->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 644
  return;
}
}
#line 660 "/home/june/collector/temp/bopm-3.1.3/src/libopm/src/libopm.c"
size_t opm_active(OPM_T *scanner ) 
{ 


  {
#line 662
  return ((size_t )((scanner->queue)->elements + (scanner->scans)->elements));
}
}
#line 681 "/home/june/collector/temp/bopm-3.1.3/src/libopm/src/libopm.c"
static OPM_SCAN_T *libopm_scan_create(OPM_T *scanner , OPM_REMOTE_T *remote ) 
{ 
  OPM_SCAN_T *ret ;
  OPM_CONNECTION_T *conn ;
  OPM_NODE_T *node ;
  OPM_NODE_T *p ;
  void *tmp___0 ;

  {
  {
#line 687
  tmp___0 = libopm_MyMalloc(sizeof(*ret));
#line 687
  ret = (OPM_SCAN_T *)tmp___0;
#line 689
  ret->remote = remote;
#line 690
  ret->connections = libopm_list_create();
#line 693
  p = (scanner->protocols)->head;
  }
  {
#line 693
  while (1) {
    while_continue: /* CIL Label */ ;
#line 693
    if (! ((unsigned long )p != (unsigned long )((void *)0))) {
#line 693
      goto while_break;
    }
    {
#line 695
    conn = libopm_connection_create();
#line 697
    conn->protocol = ((OPM_PROTOCOL_CONFIG_T *)p->data)->type;
#line 698
    conn->port = ((OPM_PROTOCOL_CONFIG_T *)p->data)->port;
#line 700
    node = libopm_node_create((void *)conn);
#line 702
    libopm_list_add(ret->connections, node);
#line 693
    p = p->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 708
  p = (remote->protocols)->head;
  {
#line 708
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 708
    if (! ((unsigned long )p != (unsigned long )((void *)0))) {
#line 708
      goto while_break___0;
    }
    {
#line 710
    conn = libopm_connection_create();
#line 712
    conn->protocol = ((OPM_PROTOCOL_CONFIG_T *)p->data)->type;
#line 713
    conn->port = ((OPM_PROTOCOL_CONFIG_T *)p->data)->port;
#line 715
    node = libopm_node_create((void *)conn);
#line 717
    libopm_list_add(ret->connections, node);
#line 708
    p = p->next;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 720
  memset((void *)(& ret->addr), 0, sizeof(opm_sockaddr ));
  }
#line 722
  return (ret);
}
}
#line 739 "/home/june/collector/temp/bopm-3.1.3/src/libopm/src/libopm.c"
static void libopm_scan_free(OPM_SCAN_T *scan ) 
{ 
  OPM_NODE_T *p ;
  OPM_NODE_T *next ;
  OPM_CONNECTION_T *conn ;

  {
#line 744
  p = (scan->connections)->head;
#line 744
  if (p) {
#line 744
    next = p->next;
  } else {
#line 744
    next = (OPM_NODE_T *)((void *)0);
  }
  {
#line 744
  while (1) {
    while_continue: /* CIL Label */ ;
#line 744
    if (! ((unsigned long )p != (unsigned long )((void *)0))) {
#line 744
      goto while_break;
    }
    {
#line 746
    conn = (OPM_CONNECTION_T *)p->data;
#line 747
    libopm_connection_free(conn);
#line 749
    libopm_list_remove(scan->connections, p);
#line 750
    libopm_node_free(p);
#line 744
    p = next;
    }
#line 744
    if (p) {
#line 744
      next = p->next;
    } else {
#line 744
      next = (OPM_NODE_T *)((void *)0);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 752
  libopm_list_free(scan->connections);
#line 754
  libopm_MyFree((void **)(& scan));
  }
#line 755
  return;
}
}
#line 771 "/home/june/collector/temp/bopm-3.1.3/src/libopm/src/libopm.c"
static OPM_CONNECTION_T *libopm_connection_create(void) 
{ 
  OPM_CONNECTION_T *ret ;
  void *tmp___0 ;

  {
  {
#line 774
  tmp___0 = libopm_MyMalloc(sizeof(*ret));
#line 774
  ret = (OPM_CONNECTION_T *)tmp___0;
#line 776
  ret->fd = 0;
#line 777
  ret->bytes_read = (unsigned short)0;
#line 778
  ret->readlen = (unsigned short)0;
#line 779
  ret->protocol = (OPM_PROTOCOL_T *)0;
#line 780
  ret->port = (unsigned short)0;
#line 782
  ret->state = (unsigned short)1;
  }
#line 784
  return (ret);
}
}
#line 801 "/home/june/collector/temp/bopm-3.1.3/src/libopm/src/libopm.c"
static void libopm_connection_free(OPM_CONNECTION_T *conn ) 
{ 


  {
  {
#line 803
  libopm_MyFree((void **)(& conn));
  }
#line 804
  return;
}
}
#line 817 "/home/june/collector/temp/bopm-3.1.3/src/libopm/src/libopm.c"
void opm_cycle(OPM_T *scanner ) 
{ 


  {
  {
#line 819
  libopm_check_queue(scanner);
#line 820
  libopm_check_establish(scanner);
#line 821
  libopm_check_poll(scanner);
#line 822
  libopm_check_closed(scanner);
  }
#line 823
  return;
}
}
#line 840 "/home/june/collector/temp/bopm-3.1.3/src/libopm/src/libopm.c"
static void libopm_check_queue(OPM_T *scanner ) 
{ 
  OPM_NODE_T *node ;
  OPM_SCAN_T *scan ;
  unsigned int protocols___0 ;
  unsigned int projected ;
  unsigned int fd_limit ;
  void *tmp___0 ;

  {
#line 847
  if ((scanner->queue)->elements == 0) {
#line 848
    return;
  }
  {
#line 850
  tmp___0 = libopm_config(scanner->config, 0);
#line 850
  fd_limit = (unsigned int )*((int *)tmp___0);
#line 852
  projected = scanner->fd_use;
  }
  {
#line 856
  while (1) {
    while_continue: /* CIL Label */ ;
#line 856
    if (! ((scanner->queue)->elements > 0)) {
#line 856
      goto while_break;
    }
#line 860
    scan = (OPM_SCAN_T *)((scanner->queue)->head)->data;
#line 861
    protocols___0 = (unsigned int )(scan->connections)->elements;
#line 864
    if (protocols___0 + projected > fd_limit) {
#line 865
      goto while_break;
    }
    {
#line 869
    node = libopm_list_remove(scanner->queue, (scanner->queue)->head);
#line 870
    libopm_list_add(scanner->scans, node);
#line 871
    projected += protocols___0;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 874
  return;
}
}
#line 890 "/home/june/collector/temp/bopm-3.1.3/src/libopm/src/libopm.c"
static void libopm_check_establish(OPM_T *scanner ) 
{ 
  OPM_NODE_T *node1 ;
  OPM_NODE_T *node2 ;
  OPM_SCAN_T *scan ;
  OPM_CONNECTION_T *conn ;
  unsigned int fd_limit ;
  void *tmp___0 ;

  {
#line 898
  if ((scanner->scans)->elements == 0) {
#line 899
    return;
  }
  {
#line 901
  tmp___0 = libopm_config(scanner->config, 0);
#line 901
  fd_limit = (unsigned int )*((int *)tmp___0);
  }
#line 903
  if (scanner->fd_use >= fd_limit) {
#line 904
    return;
  }
#line 906
  node1 = (scanner->scans)->head;
  {
#line 906
  while (1) {
    while_continue: /* CIL Label */ ;
#line 906
    if (! ((unsigned long )node1 != (unsigned long )((void *)0))) {
#line 906
      goto while_break;
    }
#line 908
    scan = (OPM_SCAN_T *)node1->data;
#line 909
    node2 = (scan->connections)->head;
    {
#line 909
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 909
      if (! ((unsigned long )node2 != (unsigned long )((void *)0))) {
#line 909
        goto while_break___0;
      }
#line 912
      if (scanner->fd_use >= fd_limit) {
#line 913
        return;
      }
#line 915
      conn = (OPM_CONNECTION_T *)node2->data;
#line 916
      if ((int )conn->state == 1) {
        {
#line 917
        libopm_do_connect(scanner, scan, conn);
        }
      }
#line 909
      node2 = node2->next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 906
    node1 = node1->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 920
  return;
}
}
#line 941 "/home/june/collector/temp/bopm-3.1.3/src/libopm/src/libopm.c"
static void libopm_check_closed(OPM_T *scanner ) 
{ 
  time_t present ;
  OPM_NODE_T *node1 ;
  OPM_NODE_T *node2 ;
  OPM_NODE_T *next1 ;
  OPM_NODE_T *next2 ;
  int timeout___0 ;
  OPM_SCAN_T *scan ;
  OPM_CONNECTION_T *conn ;
  void *tmp___0 ;
  OPM_REMOTE_T *tmp___1 ;

  {
#line 951
  if ((scanner->scans)->elements == 0) {
#line 952
    return;
  }
  {
#line 954
  time(& present);
#line 956
  tmp___0 = libopm_config(scanner->config, 7);
#line 956
  timeout___0 = *((int *)tmp___0);
#line 958
  node1 = (scanner->scans)->head;
  }
#line 958
  if (node1) {
#line 958
    next1 = node1->next;
  } else {
#line 958
    next1 = (OPM_NODE_T *)((void *)0);
  }
  {
#line 958
  while (1) {
    while_continue: /* CIL Label */ ;
#line 958
    if (! ((unsigned long )node1 != (unsigned long )((void *)0))) {
#line 958
      goto while_break;
    }
#line 960
    scan = (OPM_SCAN_T *)node1->data;
#line 961
    node2 = (scan->connections)->head;
#line 961
    if (node2) {
#line 961
      next2 = node2->next;
    } else {
#line 961
      next2 = (OPM_NODE_T *)((void *)0);
    }
    {
#line 961
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 961
      if (! ((unsigned long )node2 != (unsigned long )((void *)0))) {
#line 961
        goto while_break___0;
      }
#line 964
      conn = (OPM_CONNECTION_T *)node2->data;
#line 966
      if ((int )conn->state == 4) {
#line 968
        if (conn->fd > 0) {
          {
#line 969
          close(conn->fd);
          }
        }
        {
#line 971
        (scanner->fd_use) --;
#line 973
        libopm_list_remove(scan->connections, node2);
#line 974
        libopm_connection_free(conn);
#line 975
        libopm_node_free(node2);
        }
#line 976
        goto __Cont;
      }
#line 979
      if (present - conn->creation >= (time_t )timeout___0) {
#line 979
        if ((int )conn->state != 1) {
          {
#line 983
          close(conn->fd);
#line 984
          (scanner->fd_use) --;
#line 986
          tmp___1 = libopm_setup_remote(scan->remote, conn);
#line 986
          libopm_do_callback(scanner, tmp___1, 4, 0);
#line 988
          libopm_list_remove(scan->connections, node2);
#line 989
          libopm_connection_free(conn);
#line 990
          libopm_node_free(node2);
          }
#line 992
          goto __Cont;
        }
      }
      __Cont: /* CIL Label */ 
#line 961
      node2 = next2;
#line 961
      if (node2) {
#line 961
        next2 = node2->next;
      } else {
#line 961
        next2 = (OPM_NODE_T *)((void *)0);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 999
    if ((scan->connections)->elements == 0) {
      {
#line 1001
      libopm_do_callback(scanner, scan->remote, 2, 0);
#line 1003
      libopm_list_remove(scanner->scans, node1);
#line 1004
      libopm_scan_free(scan);
#line 1005
      libopm_node_free(node1);
      }
    }
#line 958
    node1 = next1;
#line 958
    if (node1) {
#line 958
      next1 = node1->next;
    } else {
#line 958
      next1 = (OPM_NODE_T *)((void *)0);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1008
  return;
}
}
#line 1024 "/home/june/collector/temp/bopm-3.1.3/src/libopm/src/libopm.c"
static void libopm_do_connect(OPM_T *scanner , OPM_SCAN_T *scan , OPM_CONNECTION_T *conn ) 
{ 
  opm_sockaddr *bind_ip ;
  struct sockaddr_in *addr___0 ;
  struct sockaddr_in local_addr ;
  void *tmp___0 ;
  OPM_REMOTE_T *tmp___1 ;
  OPM_REMOTE_T *tmp___2 ;
  int tmp___3 ;

  {
  {
#line 1031
  addr___0 = & scan->addr.sa4;
#line 1033
  addr___0->sin_family = (sa_family_t )2;
#line 1034
  addr___0->sin_port = htons(conn->port);
#line 1037
  tmp___0 = libopm_config(scanner->config, 1);
#line 1037
  bind_ip = (opm_sockaddr *)tmp___0;
#line 1039
  conn->fd = socket(2, 1, 0);
#line 1040
  (scanner->fd_use) ++;
  }
#line 1042
  if (conn->fd == -1) {
    {
#line 1044
    tmp___1 = libopm_setup_remote(scan->remote, conn);
#line 1044
    libopm_do_callback(scanner, tmp___1, 3, 10);
#line 1045
    conn->state = (unsigned short)4;
    }
#line 1046
    return;
  }
#line 1049
  if ((unsigned long )bind_ip != (unsigned long )((void *)0)) {
    {
#line 1051
    memset((void *)(& local_addr), 0, sizeof(local_addr));
#line 1052
    local_addr.sin_addr.s_addr = bind_ip->sa4.sin_addr.s_addr;
#line 1053
    local_addr.sin_family = (sa_family_t )2;
#line 1054
    local_addr.sin_port = htons((uint16_t )0);
#line 1056
    tmp___3 = bind(conn->fd, (struct sockaddr  const  *)((struct sockaddr *)(& local_addr)),
                   (socklen_t )sizeof(local_addr));
    }
#line 1056
    if (tmp___3 == -1) {
      {
#line 1058
      tmp___2 = libopm_setup_remote(scan->remote, conn);
#line 1058
      libopm_do_callback(scanner, tmp___2, 3, 9);
#line 1059
      conn->state = (unsigned short)4;
      }
#line 1060
      return;
    }
  }
  {
#line 1065
  fcntl(conn->fd, 4, 2048);
#line 1067
  connect(conn->fd, (struct sockaddr  const  *)((struct sockaddr *)addr___0), (socklen_t )sizeof(*addr___0));
#line 1069
  conn->state = (unsigned short)2;
#line 1070
  time(& conn->creation);
  }
#line 1071
  return;
}
}
#line 1090 "/home/june/collector/temp/bopm-3.1.3/src/libopm/src/libopm.c"
static unsigned int ufds_size  ;
#line 1091 "/home/june/collector/temp/bopm-3.1.3/src/libopm/src/libopm.c"
static struct pollfd *ufds  =    (struct pollfd *)((void *)0);
#line 1084 "/home/june/collector/temp/bopm-3.1.3/src/libopm/src/libopm.c"
static void libopm_check_poll(OPM_T *scanner ) 
{ 
  OPM_NODE_T *node1 ;
  OPM_NODE_T *node2 ;
  OPM_SCAN_T *scan ;
  OPM_CONNECTION_T *conn ;
  unsigned int size ;
  unsigned int i ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;

  {
  {
#line 1094
  size = 0U;
#line 1097
  tmp___3 = libopm_config(scanner->config, 0);
  }
#line 1097
  if (ufds_size < *((unsigned int *)tmp___3)) {
    {
#line 1099
    libopm_MyFree((void **)(& ufds));
#line 1100
    tmp___0 = libopm_config(scanner->config, 0);
#line 1100
    tmp___1 = libopm_MyMalloc(sizeof(*ufds) * (unsigned long )*((unsigned int *)tmp___0));
#line 1100
    ufds = (struct pollfd *)tmp___1;
#line 1101
    tmp___2 = libopm_config(scanner->config, 0);
#line 1101
    ufds_size = *((unsigned int *)tmp___2);
    }
  }
#line 1104
  if ((scanner->scans)->elements == 0) {
#line 1105
    return;
  }
#line 1107
  node1 = (scanner->scans)->head;
  {
#line 1107
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1107
    if (! ((unsigned long )node1 != (unsigned long )((void *)0))) {
#line 1107
      goto while_break;
    }
#line 1109
    scan = (OPM_SCAN_T *)node1->data;
#line 1110
    node2 = (scan->connections)->head;
    {
#line 1110
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1110
      if (! ((unsigned long )node2 != (unsigned long )((void *)0))) {
#line 1110
        goto while_break___0;
      }
#line 1112
      if (size >= ufds_size) {
#line 1113
        goto while_break___0;
      }
#line 1115
      conn = (OPM_CONNECTION_T *)node2->data;
#line 1117
      if ((int )conn->state < 2) {
#line 1119
        goto __Cont;
      } else
#line 1117
      if ((int )conn->state == 4) {
#line 1119
        goto __Cont;
      }
#line 1121
      (ufds + size)->events = (short)0;
#line 1122
      (ufds + size)->revents = (short)0;
#line 1123
      (ufds + size)->fd = conn->fd;
#line 1126
      (ufds + size)->events = (short )((int )(ufds + size)->events | 16);
#line 1128
      (ufds + size)->events = (short )((int )(ufds + size)->events | 32);
      {
#line 1132
      if ((int )conn->state == 2) {
#line 1132
        goto case_2;
      }
#line 1135
      if ((int )conn->state == 3) {
#line 1135
        goto case_3;
      }
#line 1130
      goto switch_break;
      case_2: /* CIL Label */ 
#line 1133
      (ufds + size)->events = (short )((int )(ufds + size)->events | 4);
#line 1134
      goto switch_break;
      case_3: /* CIL Label */ 
#line 1136
      (ufds + size)->events = (short )((int )(ufds + size)->events | 1);
#line 1137
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
#line 1139
      size ++;
      __Cont: /* CIL Label */ 
#line 1110
      node2 = node2->next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1107
    node1 = node1->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1144
  tmp___4 = poll(ufds, (nfds_t )size, 0);
  }
  {
#line 1146
  if (tmp___4 == -1) {
#line 1146
    goto case_neg_1;
  }
#line 1149
  if (tmp___4 == 0) {
#line 1149
    goto case_0;
  }
#line 1144
  goto switch_break___0;
  case_neg_1: /* CIL Label */ 
#line 1148
  return;
  case_0: /* CIL Label */ 
#line 1151
  return;
  switch_break___0: /* CIL Label */ ;
  }
#line 1155
  node1 = (scanner->scans)->head;
  {
#line 1155
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1155
    if (! ((unsigned long )node1 != (unsigned long )((void *)0))) {
#line 1155
      goto while_break___1;
    }
#line 1157
    scan = (OPM_SCAN_T *)node1->data;
#line 1159
    node2 = (scan->connections)->head;
    {
#line 1159
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1159
      if (! ((unsigned long )node2 != (unsigned long )((void *)0))) {
#line 1159
        goto while_break___2;
      }
#line 1161
      conn = (OPM_CONNECTION_T *)node2->data;
#line 1163
      i = 0U;
      {
#line 1163
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 1163
        if (! (i < size)) {
#line 1163
          goto while_break___3;
        }
#line 1165
        if ((ufds + i)->fd == conn->fd) {
#line 1165
          if ((int )conn->state != 4) {
#line 1167
            if ((int )(ufds + i)->revents & 1) {
              {
#line 1168
              libopm_do_readready(scanner, scan, conn);
              }
            }
#line 1169
            if ((int )(ufds + i)->revents & 4) {
              {
#line 1170
              libopm_do_writeready(scanner, scan, conn);
              }
            }
#line 1171
            if ((int )(ufds + i)->revents & 16) {
              {
#line 1172
              libopm_do_hup(scanner, scan, conn);
              }
            }
          }
        }
#line 1163
        i ++;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 1159
      node2 = node2->next;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 1155
    node1 = node1->next;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1177
  return;
}
}
#line 1196 "/home/june/collector/temp/bopm-3.1.3/src/libopm/src/libopm.c"
static void libopm_do_readready(OPM_T *scanner , OPM_SCAN_T *scan , OPM_CONNECTION_T *conn ) 
{ 
  int max_read ;
  char c ;
  void *tmp___0 ;
  ssize_t tmp___1 ;
  int *tmp___2 ;
  OPM_REMOTE_T *tmp___3 ;

  {
#line 1204
  if ((conn->protocol)->read_function) {
    {
#line 1206
    (*((conn->protocol)->read_function))(scanner, scan, conn);
    }
#line 1207
    return;
  }
  {
#line 1210
  tmp___0 = libopm_config(scanner->config, 6);
#line 1210
  max_read = *((int *)tmp___0);
  }
  {
#line 1212
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1214
    tmp___1 = read(conn->fd, (void *)(& c), (size_t )1);
    }
    {
#line 1216
    if (tmp___1 == 0L) {
#line 1216
      goto case_0;
    }
#line 1220
    if (tmp___1 == -1L) {
#line 1220
      goto case_neg_1;
    }
#line 1225
    goto switch_default;
    case_0: /* CIL Label */ 
    {
#line 1217
    libopm_do_hup(scanner, scan, conn);
    }
#line 1218
    return;
    case_neg_1: /* CIL Label */ 
    {
#line 1221
    tmp___2 = __errno_location();
    }
#line 1221
    if (*tmp___2 != 11) {
      {
#line 1222
      libopm_do_hup(scanner, scan, conn);
      }
    }
#line 1223
    return;
    switch_default: /* CIL Label */ 
#line 1227
    conn->bytes_read = (unsigned short )((int )conn->bytes_read + 1);
#line 1229
    if ((int )conn->bytes_read >= max_read) {
      {
#line 1231
      tmp___3 = libopm_setup_remote(scan->remote, conn);
#line 1231
      libopm_do_callback(scanner, tmp___3, 3, 5);
#line 1232
      conn->state = (unsigned short)4;
      }
#line 1233
      return;
    }
#line 1236
    if ((int )c == 0) {
#line 1237
      goto while_continue;
    } else
#line 1236
    if ((int )c == 13) {
#line 1237
      goto while_continue;
    }
#line 1239
    if ((int )c == 10) {
      {
#line 1241
      conn->readbuf[conn->readlen] = (char )'\000';
#line 1242
      conn->readlen = (unsigned short)0;
#line 1243
      libopm_do_read(scanner, scan, conn);
      }
#line 1245
      if ((int )conn->state == 4) {
#line 1246
        return;
      }
#line 1248
      goto while_continue;
    }
#line 1251
    if ((int )conn->readlen < 128) {
#line 1253
      conn->readlen = (unsigned short )((int )conn->readlen + 1);
#line 1253
      conn->readbuf[(int )conn->readlen - 1] = c;
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 1278 "/home/june/collector/temp/bopm-3.1.3/src/libopm/src/libopm.c"
static void libopm_do_read(OPM_T *scanner , OPM_SCAN_T *scan , OPM_CONNECTION_T *conn ) 
{ 
  OPM_LIST_T *list ;
  OPM_NODE_T *node ;
  char *target_string ;
  void *tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 1285
  tmp___0 = libopm_config(scanner->config, 3);
#line 1285
  list = (OPM_LIST_T *)tmp___0;
#line 1286
  node = list->head;
  }
  {
#line 1286
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1286
    if (! ((unsigned long )node != (unsigned long )((void *)0))) {
#line 1286
      goto while_break;
    }
    {
#line 1288
    target_string = (char *)node->data;
#line 1289
    tmp___1 = strstr((char const   *)(conn->readbuf), (char const   *)target_string);
    }
#line 1289
    if (tmp___1) {
      {
#line 1291
      libopm_do_openproxy(scanner, scan, conn);
      }
#line 1292
      goto while_break;
    }
#line 1286
    node = node->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 1295
  return;
}
}
#line 1312 "/home/june/collector/temp/bopm-3.1.3/src/libopm/src/libopm.c"
static void libopm_do_openproxy(OPM_T *scanner , OPM_SCAN_T *scan , OPM_CONNECTION_T *conn ) 
{ 
  OPM_REMOTE_T *remote ;
  OPM_REMOTE_T *tmp___0 ;

  {
  {
#line 1316
  remote = scan->remote;
#line 1319
  conn->state = (unsigned short)4;
#line 1322
  tmp___0 = libopm_setup_remote(scan->remote, conn);
#line 1322
  libopm_do_callback(scanner, tmp___0, 0, 0);
  }
#line 1323
  return;
}
}
#line 1342 "/home/june/collector/temp/bopm-3.1.3/src/libopm/src/libopm.c"
static void libopm_do_writeready(OPM_T *scanner , OPM_SCAN_T *scan , OPM_CONNECTION_T *conn ) 
{ 
  OPM_PROTOCOL_T *protocol ;

  {
#line 1346
  protocol = conn->protocol;
#line 1349
  if (protocol->write_function) {
    {
#line 1350
    (*(protocol->write_function))(scanner, scan, conn);
    }
  }
#line 1353
  conn->state = (unsigned short)3;
#line 1354
  return;
}
}
#line 1372 "/home/june/collector/temp/bopm-3.1.3/src/libopm/src/libopm.c"
static void libopm_do_hup(OPM_T *scanner , OPM_SCAN_T *scan , OPM_CONNECTION_T *conn ) 
{ 
  OPM_REMOTE_T *remote ;
  OPM_REMOTE_T *tmp___0 ;

  {
  {
#line 1376
  remote = scan->remote;
#line 1379
  conn->state = (unsigned short)4;
#line 1381
  tmp___0 = libopm_setup_remote(scan->remote, conn);
#line 1381
  libopm_do_callback(scanner, tmp___0, 1, 0);
  }
#line 1382
  return;
}
}
#line 1400 "/home/june/collector/temp/bopm-3.1.3/src/libopm/src/libopm.c"
static void libopm_do_callback(OPM_T *scanner , OPM_REMOTE_T *remote , int type ,
                               int var ) 
{ 


  {
#line 1403
  if (type < 0) {
#line 1404
    return;
  } else
#line 1403
  if (type >= 6) {
#line 1404
    return;
  }
#line 1406
  if ((scanner->callbacks + type)->func) {
    {
#line 1407
    (*((scanner->callbacks + type)->func))(scanner, remote, var, (scanner->callbacks + type)->data);
    }
  }
#line 1408
  return;
}
}
#line 1425 "/home/june/collector/temp/bopm-3.1.3/src/libopm/src/libopm.c"
static OPM_REMOTE_T *libopm_setup_remote(OPM_REMOTE_T *remote , OPM_CONNECTION_T *conn ) 
{ 


  {
#line 1427
  remote->port = conn->port;
#line 1428
  remote->bytes_read = conn->bytes_read;
#line 1429
  remote->protocol = (unsigned short )(conn->protocol)->type;
#line 1431
  return (remote);
}
}
#line 362 "/usr/include/stdio.h"
extern int printf(char const   * __restrict  __format  , ...) ;
#line 39 "/home/june/collector/temp/bopm-3.1.3/src/libopm/src/test.c"
void open_proxy(OPM_T *scanner , OPM_REMOTE_T *remote , int notused , void *data ) ;
#line 40
void negotiation_failed(OPM_T *scanner , OPM_REMOTE_T *remote , int notused , void *data ) ;
#line 41
void timeout(OPM_T *scanner , OPM_REMOTE_T *remote , int notused , void *data ) ;
#line 42
void end(OPM_T *scanner , OPM_REMOTE_T *remote , int notused , void *data ) ;
#line 43
void handle_error(OPM_T *scanner , OPM_REMOTE_T *remote , int err , void *data ) ;
#line 45 "/home/june/collector/temp/bopm-3.1.3/src/libopm/src/test.c"
int complete  =    0;
#line 47 "/home/june/collector/temp/bopm-3.1.3/src/libopm/src/test.c"
int main(int argc , char **argv ) 
{ 
  OPM_ERR_T err ;
  int fdlimit ;
  int scan_port ;
  int max_read ;
  int scantimeout ;
  unsigned int i ;
  unsigned int s ;
  unsigned short http_ports[4] ;
  unsigned short wingate_ports[1] ;
  unsigned short router_ports[1] ;
  unsigned short socks4_ports[1] ;
  unsigned short socks5_ports[1] ;
  unsigned short httppost_ports[3] ;
  OPM_T *scanner ;
  OPM_REMOTE_T *remote ;

  {
  {
#line 50
  fdlimit = 1024;
#line 51
  scan_port = 6667;
#line 52
  max_read = 4096;
#line 53
  scantimeout = 10;
#line 56
  http_ports[0] = (unsigned short)8000;
#line 56
  http_ports[1] = (unsigned short)8080;
#line 56
  http_ports[2] = (unsigned short)3128;
#line 56
  http_ports[3] = (unsigned short)80;
#line 60
  wingate_ports[0] = (unsigned short)23;
#line 64
  router_ports[0] = (unsigned short)23;
#line 68
  socks4_ports[0] = (unsigned short)1080;
#line 72
  socks5_ports[0] = (unsigned short)1080;
#line 76
  httppost_ports[0] = (unsigned short)80;
#line 76
  httppost_ports[1] = (unsigned short)8090;
#line 76
  httppost_ports[2] = (unsigned short)3128;
#line 83
  scanner = opm_create();
  }
#line 85
  if (argc >= 2) {
    {
#line 86
    remote = opm_remote_create((char const   *)*(argv + 1));
    }
  } else {
    {
#line 88
    remote = opm_remote_create("127.0.0.1");
    }
  }
  {
#line 91
  opm_callback(scanner, 0, & open_proxy, (void *)0);
#line 92
  opm_callback(scanner, 1, & negotiation_failed, (void *)0);
#line 93
  opm_callback(scanner, 4, & timeout, (void *)0);
#line 94
  opm_callback(scanner, 2, & end, (void *)0);
#line 95
  opm_callback(scanner, 3, & handle_error, (void *)0);
#line 99
  opm_config(scanner, 0, (void *)(& fdlimit));
#line 100
  opm_config(scanner, 4, (void *)"216.175.104.202");
#line 101
  opm_config(scanner, 5, (void *)(& scan_port));
#line 102
  opm_config(scanner, 3, (void *)"*** Looking up your hostname...");
#line 103
  opm_config(scanner, 3, (void *)"ERROR :Trying to reconnect too fast.");
#line 104
  opm_config(scanner, 7, (void *)(& scantimeout));
#line 105
  opm_config(scanner, 6, (void *)(& max_read));
#line 108
  s = (unsigned int )(sizeof(http_ports) / sizeof(http_ports[0]));
#line 108
  i = 0U;
  }
  {
#line 108
  while (1) {
    while_continue: /* CIL Label */ ;
#line 108
    if (! (i < s)) {
#line 108
      goto while_break;
    }
    {
#line 109
    opm_addtype(scanner, 1, http_ports[i]);
#line 108
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 112
  s = (unsigned int )(sizeof(wingate_ports) / sizeof(wingate_ports[0]));
#line 112
  i = 0U;
  {
#line 112
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 112
    if (! (i < s)) {
#line 112
      goto while_break___0;
    }
    {
#line 113
    opm_addtype(scanner, 4, wingate_ports[i]);
#line 112
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 116
  s = (unsigned int )(sizeof(router_ports) / sizeof(router_ports[0]));
#line 116
  i = 0U;
  {
#line 116
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 116
    if (! (i < s)) {
#line 116
      goto while_break___1;
    }
    {
#line 117
    opm_addtype(scanner, 5, router_ports[i]);
#line 116
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 120
  s = (unsigned int )(sizeof(socks4_ports) / sizeof(socks4_ports[0]));
#line 120
  i = 0U;
  {
#line 120
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 120
    if (! (i < s)) {
#line 120
      goto while_break___2;
    }
    {
#line 121
    opm_addtype(scanner, 2, socks4_ports[i]);
#line 120
    i ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 124
  s = (unsigned int )(sizeof(socks5_ports) / sizeof(socks5_ports[0]));
#line 124
  i = 0U;
  {
#line 124
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 124
    if (! (i < s)) {
#line 124
      goto while_break___3;
    }
    {
#line 125
    opm_addtype(scanner, 3, socks5_ports[i]);
#line 124
    i ++;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
#line 128
  s = (unsigned int )(sizeof(httppost_ports) / sizeof(httppost_ports[0]));
#line 128
  i = 0U;
  {
#line 128
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 128
    if (! (i < s)) {
#line 128
      goto while_break___4;
    }
    {
#line 129
    opm_addtype(scanner, 6, httppost_ports[i]);
#line 128
    i ++;
    }
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 135
  opm_remote_addtype(remote, 1, (unsigned short)8001);
#line 136
  opm_remote_addtype(remote, 1, (unsigned short)8002);
#line 138
  err = opm_scan(scanner, remote);
  }
  {
#line 140
  if (err == 1) {
#line 140
    goto case_1;
  }
#line 142
  if (err == 7) {
#line 142
    goto case_7;
  }
#line 147
  goto switch_default;
  case_1: /* CIL Label */ 
#line 141
  goto switch_break;
  case_7: /* CIL Label */ 
  {
#line 143
  printf((char const   */* __restrict  */)"Bad address\n");
#line 144
  opm_free(scanner);
#line 145
  opm_remote_free(remote);
  }
#line 146
  return (0);
  switch_default: /* CIL Label */ 
  {
#line 148
  printf((char const   */* __restrict  */)"Unknown Error %d\n", err);
  }
#line 149
  return (0);
  switch_break: /* CIL Label */ ;
  }
  {
#line 153
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 153
    if (! (! complete)) {
#line 153
      goto while_break___5;
    }
    {
#line 154
    opm_cycle(scanner);
    }
  }
  while_break___5: /* CIL Label */ ;
  }
  {
#line 156
  opm_free(scanner);
  }
#line 158
  return (0);
}
}
#line 161 "/home/june/collector/temp/bopm-3.1.3/src/libopm/src/test.c"
void open_proxy(OPM_T *scanner , OPM_REMOTE_T *remote , int notused , void *data ) 
{ 


  {
  {
#line 167
  printf((char const   */* __restrict  */)"Open proxy on %s:%d [%d bytes read]\n",
         remote->ip, (int )remote->port, (int )remote->bytes_read);
#line 169
  opm_end(scanner, remote);
  }
#line 170
  return;
}
}
#line 172 "/home/june/collector/temp/bopm-3.1.3/src/libopm/src/test.c"
void negotiation_failed(OPM_T *scanner , OPM_REMOTE_T *remote , int notused , void *data ) 
{ 


  {
  {
#line 179
  printf((char const   */* __restrict  */)"Negotiation on %s:%d failed [%d bytes read]\n",
         remote->ip, (int )remote->port, (int )remote->bytes_read);
  }
#line 181
  return;
}
}
#line 183 "/home/june/collector/temp/bopm-3.1.3/src/libopm/src/test.c"
void timeout(OPM_T *scanner , OPM_REMOTE_T *remote , int notused , void *data ) 
{ 


  {
  {
#line 189
  printf((char const   */* __restrict  */)"Negotiation timed out on %s:%d\n", remote->ip,
         (int )remote->port);
  }
#line 190
  return;
}
}
#line 192 "/home/june/collector/temp/bopm-3.1.3/src/libopm/src/test.c"
void end(OPM_T *scanner , OPM_REMOTE_T *remote , int notused , void *data ) 
{ 


  {
  {
#line 198
  printf((char const   */* __restrict  */)"Scan on %s has ended\n", remote->ip);
#line 199
  opm_remote_free(remote);
#line 200
  complete = 1;
  }
#line 201
  return;
}
}
#line 203 "/home/june/collector/temp/bopm-3.1.3/src/libopm/src/test.c"
void handle_error(OPM_T *scanner , OPM_REMOTE_T *remote , int err , void *data ) 
{ 


  {
  {
#line 210
  if (err == 5) {
#line 210
    goto case_5;
  }
#line 213
  if (err == 9) {
#line 213
    goto case_9;
  }
#line 216
  if (err == 10) {
#line 216
    goto case_10;
  }
#line 220
  goto switch_default;
  case_5: /* CIL Label */ 
  {
#line 211
  printf((char const   */* __restrict  */)"Reached MAX READ on %s:%d\n", remote->ip,
         (int )remote->port);
  }
#line 212
  goto switch_break;
  case_9: /* CIL Label */ 
  {
#line 214
  printf((char const   */* __restrict  */)"Unable to bind for %s:%d\n", remote->ip,
         (int )remote->port);
  }
#line 215
  goto switch_break;
  case_10: /* CIL Label */ 
  {
#line 217
  printf((char const   */* __restrict  */)"Unable to allocate file descriptor for %s:%d\n",
         remote->ip, (int )remote->port);
  }
#line 219
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 221
  printf((char const   */* __restrict  */)"Unknown error on %s:%d, err = %d\n", remote->ip,
         (int )remote->port, err);
  }
  switch_break: /* CIL Label */ ;
  }
#line 224
  return;
}
}
#line 386 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 399 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 149 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern ssize_t send(int __fd , void const   *__buf , size_t __n , int __flags ) ;
#line 377 "/usr/include/netinet/in.h"
extern  __attribute__((__nothrow__)) uint32_t ( __attribute__((__leaf__)) htonl)(uint32_t __hostlong )  __attribute__((__const__)) ;
#line 73 "/usr/include/arpa/inet.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) inet_aton)(char const   *__cp ,
                                                                                struct in_addr *__inp ) ;
#line 45 "/home/june/collector/temp/bopm-3.1.3/src/libopm/src/proxy.c"
static char SENDBUF[513]  ;
#line 47 "/home/june/collector/temp/bopm-3.1.3/src/libopm/src/proxy.c"
int libopm_proxy_http_write(OPM_T *scanner , OPM_SCAN_T *scan , OPM_CONNECTION_T *conn ) 
{ 
  void *tmp___0 ;
  void *tmp___1 ;
  size_t tmp___2 ;
  ssize_t tmp___3 ;

  {
  {
#line 51
  tmp___0 = libopm_config(scanner->config, 5);
#line 51
  tmp___1 = libopm_config(scanner->config, 4);
#line 51
  snprintf((char */* __restrict  */)(SENDBUF), (size_t )512, (char const   */* __restrict  */)"CONNECT %s:%d HTTP/1.0\r\n\r\n",
           (char *)tmp___1, *((int *)tmp___0));
#line 55
  tmp___2 = strlen((char const   *)(SENDBUF));
#line 55
  tmp___3 = send(conn->fd, (void const   *)(SENDBUF), tmp___2, 0);
  }
#line 55
  if (tmp___3 == -1L) {
#line 56
    return (0);
  }
#line 58
  return (1);
}
}
#line 73 "/home/june/collector/temp/bopm-3.1.3/src/libopm/src/proxy.c"
int libopm_proxy_socks4_write(OPM_T *scanner , OPM_SCAN_T *scan , OPM_CONNECTION_T *conn ) 
{ 
  struct in_addr addr___0 ;
  unsigned long laddr ;
  int len ;
  int scan_port ;
  char *scan_ip ;
  void *tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  uint32_t tmp___3 ;

  {
  {
#line 81
  tmp___0 = libopm_config(scanner->config, 4);
#line 81
  scan_ip = (char *)tmp___0;
#line 82
  tmp___1 = libopm_config(scanner->config, 5);
#line 82
  scan_port = *((int *)tmp___1);
#line 84
  tmp___2 = inet_aton((char const   *)scan_ip, & addr___0);
#line 87
  tmp___3 = htonl(addr___0.s_addr);
#line 87
  laddr = (unsigned long )tmp___3;
#line 89
  len = snprintf((char */* __restrict  */)(SENDBUF), (size_t )512, (char const   */* __restrict  */)"%c%c%c%c%c%c%c%c%c",
                 4, 1, ((int )((unsigned short )scan_port) >> 8) & 255, (int )((unsigned short )scan_port) & 255,
                 (int )((char )(laddr >> 24)) & 255, (int )((char )(laddr >> 16)) & 255,
                 (int )((char )(laddr >> 8)) & 255, (int )((char )laddr) & 255, 0);
#line 95
  send(conn->fd, (void const   *)(SENDBUF), (size_t )((unsigned int )len), 0);
  }
#line 97
  return (1);
}
}
#line 141 "/home/june/collector/temp/bopm-3.1.3/src/libopm/src/proxy.c"
int libopm_proxy_socks5_write(OPM_T *scanner , OPM_SCAN_T *scan , OPM_CONNECTION_T *conn ) 
{ 
  struct in_addr addr___0 ;
  unsigned long laddr ;
  int len ;
  int scan_port ;
  char *scan_ip ;
  void *tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  uint32_t tmp___3 ;

  {
  {
#line 149
  tmp___0 = libopm_config(scanner->config, 4);
#line 149
  scan_ip = (char *)tmp___0;
#line 150
  tmp___1 = libopm_config(scanner->config, 5);
#line 150
  scan_port = *((int *)tmp___1);
#line 152
  tmp___2 = inet_aton((char const   *)scan_ip, & addr___0);
#line 155
  tmp___3 = htonl(addr___0.s_addr);
#line 155
  laddr = (unsigned long )tmp___3;
#line 159
  len = snprintf((char */* __restrict  */)(SENDBUF), (size_t )512, (char const   */* __restrict  */)"%c%c%c",
                 5, 1, 0);
#line 160
  send(conn->fd, (void const   *)(SENDBUF), (size_t )((unsigned int )len), 0);
#line 167
  len = snprintf((char */* __restrict  */)(SENDBUF), (size_t )512, (char const   */* __restrict  */)"%c%c%c%c%c%c%c%c%c%c",
                 5, 1, 0, 1, (int )((char )(laddr >> 24)) & 255, (int )((char )(laddr >> 16)) & 255,
                 (int )((char )(laddr >> 8)) & 255, (int )((char )laddr) & 255, ((int )((unsigned short )scan_port) >> 8) & 255,
                 (int )((unsigned short )scan_port) & 255);
#line 173
  send(conn->fd, (void const   *)(SENDBUF), (size_t )((unsigned int )len), 0);
  }
#line 175
  return (1);
}
}
#line 183 "/home/june/collector/temp/bopm-3.1.3/src/libopm/src/proxy.c"
int libopm_proxy_wingate_write(OPM_T *scanner , OPM_SCAN_T *scan , OPM_CONNECTION_T *conn ) 
{ 
  int scan_port ;
  int len ;
  char *scan_ip ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 189
  tmp___0 = libopm_config(scanner->config, 4);
#line 189
  scan_ip = (char *)tmp___0;
#line 190
  tmp___1 = libopm_config(scanner->config, 5);
#line 190
  scan_port = *((int *)tmp___1);
#line 192
  len = snprintf((char */* __restrict  */)(SENDBUF), (size_t )512, (char const   */* __restrict  */)"%s:%d\r\n",
                 scan_ip, scan_port);
#line 193
  send(conn->fd, (void const   *)(SENDBUF), (size_t )((unsigned int )len), 0);
  }
#line 195
  return (1);
}
}
#line 207 "/home/june/collector/temp/bopm-3.1.3/src/libopm/src/proxy.c"
int libopm_proxy_router_write(OPM_T *scanner , OPM_SCAN_T *scan , OPM_CONNECTION_T *conn ) 
{ 
  int len ;
  int scan_port ;
  char *scan_ip ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 213
  tmp___0 = libopm_config(scanner->config, 4);
#line 213
  scan_ip = (char *)tmp___0;
#line 214
  tmp___1 = libopm_config(scanner->config, 5);
#line 214
  scan_port = *((int *)tmp___1);
#line 216
  len = snprintf((char */* __restrict  */)(SENDBUF), (size_t )512, (char const   */* __restrict  */)"cisco\r\n");
#line 217
  send(conn->fd, (void const   *)(SENDBUF), (size_t )((unsigned int )len), 0);
#line 219
  len = snprintf((char */* __restrict  */)(SENDBUF), (size_t )512, (char const   */* __restrict  */)"telnet %s %d\r\n",
                 scan_ip, scan_port);
#line 220
  send(conn->fd, (void const   *)(SENDBUF), (size_t )((unsigned int )len), 0);
  }
#line 222
  return (1);
}
}
#line 231 "/home/june/collector/temp/bopm-3.1.3/src/libopm/src/proxy.c"
int libopm_proxy_httppost_write(OPM_T *scanner , OPM_SCAN_T *scan , OPM_CONNECTION_T *conn ) 
{ 
  int len ;
  int scan_port ;
  char *scan_ip ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 237
  tmp___0 = libopm_config(scanner->config, 4);
#line 237
  scan_ip = (char *)tmp___0;
#line 238
  tmp___1 = libopm_config(scanner->config, 5);
#line 238
  scan_port = *((int *)tmp___1);
#line 240
  len = snprintf((char */* __restrict  */)(SENDBUF), (size_t )512, (char const   */* __restrict  */)"POST http://%s:%d/ HTTP/1.0\r\nContent-type: text/plain\r\nContent-length: 5\r\n\r\nquit\r\n\r\n",
                 scan_ip, scan_port);
#line 246
  send(conn->fd, (void const   *)(SENDBUF), (size_t )((unsigned int )len), 0);
  }
#line 248
  return (1);
}
}
#line 45 "/home/june/collector/temp/bopm-3.1.3/src/libopm/src/proxy.c"
static char SENDBUF___0[513]  ;
#line 40 "/home/june/collector/temp/bopm-3.1.3/src/libopm/src/config.c"
static OPM_CONFIG_HASH_T HASH___0[8]  = 
#line 40 "/home/june/collector/temp/bopm-3.1.3/src/libopm/src/config.c"
  {      {0, 1}, 
        {1, 3}, 
        {2, 2}, 
        {3, 4}, 
        {4, 2}, 
        {5, 1}, 
        {6, 1}, 
        {7, 1}};
#line 56 "/home/june/collector/temp/bopm-3.1.3/src/libopm/src/libopm.c"
static OPM_PROTOCOL_CONFIG_T *libopm_protocol_config_create___0(void) ;
#line 57
static void libopm_protocol_config_free___0(OPM_PROTOCOL_CONFIG_T *protocol ) ;
#line 68
static OPM_SCAN_T *libopm_scan_create___0(OPM_T *scanner , OPM_REMOTE_T *remote ) ;
#line 69
static void libopm_scan_free___0(OPM_SCAN_T *scan ) ;
#line 71
static OPM_CONNECTION_T *libopm_connection_create___0(void) ;
#line 72
static void libopm_connection_free___0(OPM_CONNECTION_T *conn ) ;
#line 74
static void libopm_check_establish___0(OPM_T *scanner ) ;
#line 75
static void libopm_check_poll___0(OPM_T *scanner ) ;
#line 76
static void libopm_check_closed___0(OPM_T *scanner ) ;
#line 77
static void libopm_check_queue___0(OPM_T *scanner ) ;
#line 79
static void libopm_do_connect___0(OPM_T *scanner , OPM_SCAN_T *scan , OPM_CONNECTION_T *conn ) ;
#line 80
static void libopm_do_readready___0(OPM_T *scanner , OPM_SCAN_T *scan , OPM_CONNECTION_T *conn ) ;
#line 81
static void libopm_do_writeready___0(OPM_T *scanner , OPM_SCAN_T *scan , OPM_CONNECTION_T *conn ) ;
#line 82
static void libopm_do_hup___0(OPM_T *scanner , OPM_SCAN_T *scan , OPM_CONNECTION_T *conn ) ;
#line 83
static void libopm_do_read___0(OPM_T *scanner , OPM_SCAN_T *scan , OPM_CONNECTION_T *conn ) ;
#line 84
static void libopm_do_openproxy___0(OPM_T *scanner , OPM_SCAN_T *scan , OPM_CONNECTION_T *conn ) ;
#line 86
static void libopm_do_callback___0(OPM_T *scanner , OPM_REMOTE_T *remote , int type ,
                                   int var ) ;
#line 88
static OPM_REMOTE_T *libopm_setup_remote___0(OPM_REMOTE_T *remote , OPM_CONNECTION_T *conn ) ;
#line 99 "/home/june/collector/temp/bopm-3.1.3/src/libopm/src/libopm.c"
static OPM_PROTOCOL_T OPM_PROTOCOLS___0[6]  = {      {1, & libopm_proxy_http_write, (OPM_PROXYREAD_T *)((void *)0)}, 
        {2, & libopm_proxy_socks4_write, (OPM_PROXYREAD_T *)((void *)0)}, 
        {3, & libopm_proxy_socks5_write, (OPM_PROXYREAD_T *)((void *)0)}, 
        {5, & libopm_proxy_router_write, (OPM_PROXYREAD_T *)((void *)0)}, 
        {4, & libopm_proxy_wingate_write, (OPM_PROXYREAD_T *)((void *)0)}, 
        {6, & libopm_proxy_httppost_write, (OPM_PROXYREAD_T *)((void *)0)}};
#line 473 "/home/june/collector/temp/bopm-3.1.3/src/libopm/src/libopm.c"
static OPM_PROTOCOL_CONFIG_T *libopm_protocol_config_create___0(void) 
{ 
  OPM_PROTOCOL_CONFIG_T *ret ;
  void *tmp___0 ;

  {
  {
#line 476
  tmp___0 = libopm_MyMalloc(sizeof(*ret));
#line 476
  ret = (OPM_PROTOCOL_CONFIG_T *)tmp___0;
  }
#line 478
  return (ret);
}
}
#line 495 "/home/june/collector/temp/bopm-3.1.3/src/libopm/src/libopm.c"
static void libopm_protocol_config_free___0(OPM_PROTOCOL_CONFIG_T *protocol ) 
{ 


  {
  {
#line 497
  libopm_MyFree((void **)(& protocol));
  }
#line 498
  return;
}
}
#line 681 "/home/june/collector/temp/bopm-3.1.3/src/libopm/src/libopm.c"
static OPM_SCAN_T *libopm_scan_create___0(OPM_T *scanner , OPM_REMOTE_T *remote ) 
{ 
  OPM_SCAN_T *ret ;
  OPM_CONNECTION_T *conn ;
  OPM_NODE_T *node ;
  OPM_NODE_T *p ;
  void *tmp___0 ;

  {
  {
#line 687
  tmp___0 = libopm_MyMalloc(sizeof(*ret));
#line 687
  ret = (OPM_SCAN_T *)tmp___0;
#line 689
  ret->remote = remote;
#line 690
  ret->connections = libopm_list_create();
#line 693
  p = (scanner->protocols)->head;
  }
  {
#line 693
  while (1) {
    while_continue: /* CIL Label */ ;
#line 693
    if (! ((unsigned long )p != (unsigned long )((void *)0))) {
#line 693
      goto while_break;
    }
    {
#line 695
    conn = libopm_connection_create___0();
#line 697
    conn->protocol = ((OPM_PROTOCOL_CONFIG_T *)p->data)->type;
#line 698
    conn->port = ((OPM_PROTOCOL_CONFIG_T *)p->data)->port;
#line 700
    node = libopm_node_create((void *)conn);
#line 702
    libopm_list_add(ret->connections, node);
#line 693
    p = p->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 708
  p = (remote->protocols)->head;
  {
#line 708
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 708
    if (! ((unsigned long )p != (unsigned long )((void *)0))) {
#line 708
      goto while_break___0;
    }
    {
#line 710
    conn = libopm_connection_create___0();
#line 712
    conn->protocol = ((OPM_PROTOCOL_CONFIG_T *)p->data)->type;
#line 713
    conn->port = ((OPM_PROTOCOL_CONFIG_T *)p->data)->port;
#line 715
    node = libopm_node_create((void *)conn);
#line 717
    libopm_list_add(ret->connections, node);
#line 708
    p = p->next;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 720
  memset((void *)(& ret->addr), 0, sizeof(opm_sockaddr ));
  }
#line 722
  return (ret);
}
}
#line 739 "/home/june/collector/temp/bopm-3.1.3/src/libopm/src/libopm.c"
static void libopm_scan_free___0(OPM_SCAN_T *scan ) 
{ 
  OPM_NODE_T *p ;
  OPM_NODE_T *next ;
  OPM_CONNECTION_T *conn ;

  {
#line 744
  p = (scan->connections)->head;
#line 744
  if (p) {
#line 744
    next = p->next;
  } else {
#line 744
    next = (OPM_NODE_T *)((void *)0);
  }
  {
#line 744
  while (1) {
    while_continue: /* CIL Label */ ;
#line 744
    if (! ((unsigned long )p != (unsigned long )((void *)0))) {
#line 744
      goto while_break;
    }
    {
#line 746
    conn = (OPM_CONNECTION_T *)p->data;
#line 747
    libopm_connection_free___0(conn);
#line 749
    libopm_list_remove(scan->connections, p);
#line 750
    libopm_node_free(p);
#line 744
    p = next;
    }
#line 744
    if (p) {
#line 744
      next = p->next;
    } else {
#line 744
      next = (OPM_NODE_T *)((void *)0);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 752
  libopm_list_free(scan->connections);
#line 754
  libopm_MyFree((void **)(& scan));
  }
#line 755
  return;
}
}
#line 771 "/home/june/collector/temp/bopm-3.1.3/src/libopm/src/libopm.c"
static OPM_CONNECTION_T *libopm_connection_create___0(void) 
{ 
  OPM_CONNECTION_T *ret ;
  void *tmp___0 ;

  {
  {
#line 774
  tmp___0 = libopm_MyMalloc(sizeof(*ret));
#line 774
  ret = (OPM_CONNECTION_T *)tmp___0;
#line 776
  ret->fd = 0;
#line 777
  ret->bytes_read = (unsigned short)0;
#line 778
  ret->readlen = (unsigned short)0;
#line 779
  ret->protocol = (OPM_PROTOCOL_T *)0;
#line 780
  ret->port = (unsigned short)0;
#line 782
  ret->state = (unsigned short)1;
  }
#line 784
  return (ret);
}
}
#line 801 "/home/june/collector/temp/bopm-3.1.3/src/libopm/src/libopm.c"
static void libopm_connection_free___0(OPM_CONNECTION_T *conn ) 
{ 


  {
  {
#line 803
  libopm_MyFree((void **)(& conn));
  }
#line 804
  return;
}
}
#line 840 "/home/june/collector/temp/bopm-3.1.3/src/libopm/src/libopm.c"
static void libopm_check_queue___0(OPM_T *scanner ) 
{ 
  OPM_NODE_T *node ;
  OPM_SCAN_T *scan ;
  unsigned int protocols___0 ;
  unsigned int projected ;
  unsigned int fd_limit ;
  void *tmp___0 ;

  {
#line 847
  if ((scanner->queue)->elements == 0) {
#line 848
    return;
  }
  {
#line 850
  tmp___0 = libopm_config(scanner->config, 0);
#line 850
  fd_limit = (unsigned int )*((int *)tmp___0);
#line 852
  projected = scanner->fd_use;
  }
  {
#line 856
  while (1) {
    while_continue: /* CIL Label */ ;
#line 856
    if (! ((scanner->queue)->elements > 0)) {
#line 856
      goto while_break;
    }
#line 860
    scan = (OPM_SCAN_T *)((scanner->queue)->head)->data;
#line 861
    protocols___0 = (unsigned int )(scan->connections)->elements;
#line 864
    if (protocols___0 + projected > fd_limit) {
#line 865
      goto while_break;
    }
    {
#line 869
    node = libopm_list_remove(scanner->queue, (scanner->queue)->head);
#line 870
    libopm_list_add(scanner->scans, node);
#line 871
    projected += protocols___0;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 874
  return;
}
}
#line 890 "/home/june/collector/temp/bopm-3.1.3/src/libopm/src/libopm.c"
static void libopm_check_establish___0(OPM_T *scanner ) 
{ 
  OPM_NODE_T *node1 ;
  OPM_NODE_T *node2 ;
  OPM_SCAN_T *scan ;
  OPM_CONNECTION_T *conn ;
  unsigned int fd_limit ;
  void *tmp___0 ;

  {
#line 898
  if ((scanner->scans)->elements == 0) {
#line 899
    return;
  }
  {
#line 901
  tmp___0 = libopm_config(scanner->config, 0);
#line 901
  fd_limit = (unsigned int )*((int *)tmp___0);
  }
#line 903
  if (scanner->fd_use >= fd_limit) {
#line 904
    return;
  }
#line 906
  node1 = (scanner->scans)->head;
  {
#line 906
  while (1) {
    while_continue: /* CIL Label */ ;
#line 906
    if (! ((unsigned long )node1 != (unsigned long )((void *)0))) {
#line 906
      goto while_break;
    }
#line 908
    scan = (OPM_SCAN_T *)node1->data;
#line 909
    node2 = (scan->connections)->head;
    {
#line 909
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 909
      if (! ((unsigned long )node2 != (unsigned long )((void *)0))) {
#line 909
        goto while_break___0;
      }
#line 912
      if (scanner->fd_use >= fd_limit) {
#line 913
        return;
      }
#line 915
      conn = (OPM_CONNECTION_T *)node2->data;
#line 916
      if ((int )conn->state == 1) {
        {
#line 917
        libopm_do_connect___0(scanner, scan, conn);
        }
      }
#line 909
      node2 = node2->next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 906
    node1 = node1->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 920
  return;
}
}
#line 941 "/home/june/collector/temp/bopm-3.1.3/src/libopm/src/libopm.c"
static void libopm_check_closed___0(OPM_T *scanner ) 
{ 
  time_t present ;
  OPM_NODE_T *node1 ;
  OPM_NODE_T *node2 ;
  OPM_NODE_T *next1 ;
  OPM_NODE_T *next2 ;
  int timeout___0 ;
  OPM_SCAN_T *scan ;
  OPM_CONNECTION_T *conn ;
  void *tmp___0 ;
  OPM_REMOTE_T *tmp___1 ;

  {
#line 951
  if ((scanner->scans)->elements == 0) {
#line 952
    return;
  }
  {
#line 954
  time(& present);
#line 956
  tmp___0 = libopm_config(scanner->config, 7);
#line 956
  timeout___0 = *((int *)tmp___0);
#line 958
  node1 = (scanner->scans)->head;
  }
#line 958
  if (node1) {
#line 958
    next1 = node1->next;
  } else {
#line 958
    next1 = (OPM_NODE_T *)((void *)0);
  }
  {
#line 958
  while (1) {
    while_continue: /* CIL Label */ ;
#line 958
    if (! ((unsigned long )node1 != (unsigned long )((void *)0))) {
#line 958
      goto while_break;
    }
#line 960
    scan = (OPM_SCAN_T *)node1->data;
#line 961
    node2 = (scan->connections)->head;
#line 961
    if (node2) {
#line 961
      next2 = node2->next;
    } else {
#line 961
      next2 = (OPM_NODE_T *)((void *)0);
    }
    {
#line 961
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 961
      if (! ((unsigned long )node2 != (unsigned long )((void *)0))) {
#line 961
        goto while_break___0;
      }
#line 964
      conn = (OPM_CONNECTION_T *)node2->data;
#line 966
      if ((int )conn->state == 4) {
#line 968
        if (conn->fd > 0) {
          {
#line 969
          close(conn->fd);
          }
        }
        {
#line 971
        (scanner->fd_use) --;
#line 973
        libopm_list_remove(scan->connections, node2);
#line 974
        libopm_connection_free___0(conn);
#line 975
        libopm_node_free(node2);
        }
#line 976
        goto __Cont;
      }
#line 979
      if (present - conn->creation >= (time_t )timeout___0) {
#line 979
        if ((int )conn->state != 1) {
          {
#line 983
          close(conn->fd);
#line 984
          (scanner->fd_use) --;
#line 986
          tmp___1 = libopm_setup_remote___0(scan->remote, conn);
#line 986
          libopm_do_callback___0(scanner, tmp___1, 4, 0);
#line 988
          libopm_list_remove(scan->connections, node2);
#line 989
          libopm_connection_free___0(conn);
#line 990
          libopm_node_free(node2);
          }
#line 992
          goto __Cont;
        }
      }
      __Cont: /* CIL Label */ 
#line 961
      node2 = next2;
#line 961
      if (node2) {
#line 961
        next2 = node2->next;
      } else {
#line 961
        next2 = (OPM_NODE_T *)((void *)0);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 999
    if ((scan->connections)->elements == 0) {
      {
#line 1001
      libopm_do_callback___0(scanner, scan->remote, 2, 0);
#line 1003
      libopm_list_remove(scanner->scans, node1);
#line 1004
      libopm_scan_free___0(scan);
#line 1005
      libopm_node_free(node1);
      }
    }
#line 958
    node1 = next1;
#line 958
    if (node1) {
#line 958
      next1 = node1->next;
    } else {
#line 958
      next1 = (OPM_NODE_T *)((void *)0);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1008
  return;
}
}
#line 1024 "/home/june/collector/temp/bopm-3.1.3/src/libopm/src/libopm.c"
static void libopm_do_connect___0(OPM_T *scanner , OPM_SCAN_T *scan , OPM_CONNECTION_T *conn ) 
{ 
  opm_sockaddr *bind_ip ;
  struct sockaddr_in *addr___0 ;
  struct sockaddr_in local_addr ;
  void *tmp___0 ;
  OPM_REMOTE_T *tmp___1 ;
  OPM_REMOTE_T *tmp___2 ;
  int tmp___3 ;

  {
  {
#line 1031
  addr___0 = & scan->addr.sa4;
#line 1033
  addr___0->sin_family = (sa_family_t )2;
#line 1034
  addr___0->sin_port = htons(conn->port);
#line 1037
  tmp___0 = libopm_config(scanner->config, 1);
#line 1037
  bind_ip = (opm_sockaddr *)tmp___0;
#line 1039
  conn->fd = socket(2, 1, 0);
#line 1040
  (scanner->fd_use) ++;
  }
#line 1042
  if (conn->fd == -1) {
    {
#line 1044
    tmp___1 = libopm_setup_remote___0(scan->remote, conn);
#line 1044
    libopm_do_callback___0(scanner, tmp___1, 3, 10);
#line 1045
    conn->state = (unsigned short)4;
    }
#line 1046
    return;
  }
#line 1049
  if ((unsigned long )bind_ip != (unsigned long )((void *)0)) {
    {
#line 1051
    memset((void *)(& local_addr), 0, sizeof(local_addr));
#line 1052
    local_addr.sin_addr.s_addr = bind_ip->sa4.sin_addr.s_addr;
#line 1053
    local_addr.sin_family = (sa_family_t )2;
#line 1054
    local_addr.sin_port = htons((uint16_t )0);
#line 1056
    tmp___3 = bind(conn->fd, (struct sockaddr  const  *)((struct sockaddr *)(& local_addr)),
                   (socklen_t )sizeof(local_addr));
    }
#line 1056
    if (tmp___3 == -1) {
      {
#line 1058
      tmp___2 = libopm_setup_remote___0(scan->remote, conn);
#line 1058
      libopm_do_callback___0(scanner, tmp___2, 3, 9);
#line 1059
      conn->state = (unsigned short)4;
      }
#line 1060
      return;
    }
  }
  {
#line 1065
  fcntl(conn->fd, 4, 2048);
#line 1067
  connect(conn->fd, (struct sockaddr  const  *)((struct sockaddr *)addr___0), (socklen_t )sizeof(*addr___0));
#line 1069
  conn->state = (unsigned short)2;
#line 1070
  time(& conn->creation);
  }
#line 1071
  return;
}
}
#line 1090 "/home/june/collector/temp/bopm-3.1.3/src/libopm/src/libopm.c"
static unsigned int ufds_size___0  ;
#line 1091 "/home/june/collector/temp/bopm-3.1.3/src/libopm/src/libopm.c"
static struct pollfd *ufds___0  =    (struct pollfd *)((void *)0);
#line 1084 "/home/june/collector/temp/bopm-3.1.3/src/libopm/src/libopm.c"
static void libopm_check_poll___0(OPM_T *scanner ) 
{ 
  OPM_NODE_T *node1 ;
  OPM_NODE_T *node2 ;
  OPM_SCAN_T *scan ;
  OPM_CONNECTION_T *conn ;
  unsigned int size ;
  unsigned int i ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;

  {
  {
#line 1094
  size = 0U;
#line 1097
  tmp___3 = libopm_config(scanner->config, 0);
  }
#line 1097
  if (ufds_size___0 < *((unsigned int *)tmp___3)) {
    {
#line 1099
    libopm_MyFree((void **)(& ufds___0));
#line 1100
    tmp___0 = libopm_config(scanner->config, 0);
#line 1100
    tmp___1 = libopm_MyMalloc(sizeof(*ufds___0) * (unsigned long )*((unsigned int *)tmp___0));
#line 1100
    ufds___0 = (struct pollfd *)tmp___1;
#line 1101
    tmp___2 = libopm_config(scanner->config, 0);
#line 1101
    ufds_size___0 = *((unsigned int *)tmp___2);
    }
  }
#line 1104
  if ((scanner->scans)->elements == 0) {
#line 1105
    return;
  }
#line 1107
  node1 = (scanner->scans)->head;
  {
#line 1107
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1107
    if (! ((unsigned long )node1 != (unsigned long )((void *)0))) {
#line 1107
      goto while_break;
    }
#line 1109
    scan = (OPM_SCAN_T *)node1->data;
#line 1110
    node2 = (scan->connections)->head;
    {
#line 1110
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1110
      if (! ((unsigned long )node2 != (unsigned long )((void *)0))) {
#line 1110
        goto while_break___0;
      }
#line 1112
      if (size >= ufds_size___0) {
#line 1113
        goto while_break___0;
      }
#line 1115
      conn = (OPM_CONNECTION_T *)node2->data;
#line 1117
      if ((int )conn->state < 2) {
#line 1119
        goto __Cont;
      } else
#line 1117
      if ((int )conn->state == 4) {
#line 1119
        goto __Cont;
      }
#line 1121
      (ufds___0 + size)->events = (short)0;
#line 1122
      (ufds___0 + size)->revents = (short)0;
#line 1123
      (ufds___0 + size)->fd = conn->fd;
#line 1126
      (ufds___0 + size)->events = (short )((int )(ufds___0 + size)->events | 16);
#line 1128
      (ufds___0 + size)->events = (short )((int )(ufds___0 + size)->events | 32);
      {
#line 1132
      if ((int )conn->state == 2) {
#line 1132
        goto case_2;
      }
#line 1135
      if ((int )conn->state == 3) {
#line 1135
        goto case_3;
      }
#line 1130
      goto switch_break;
      case_2: /* CIL Label */ 
#line 1133
      (ufds___0 + size)->events = (short )((int )(ufds___0 + size)->events | 4);
#line 1134
      goto switch_break;
      case_3: /* CIL Label */ 
#line 1136
      (ufds___0 + size)->events = (short )((int )(ufds___0 + size)->events | 1);
#line 1137
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
#line 1139
      size ++;
      __Cont: /* CIL Label */ 
#line 1110
      node2 = node2->next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1107
    node1 = node1->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1144
  tmp___4 = poll(ufds___0, (nfds_t )size, 0);
  }
  {
#line 1146
  if (tmp___4 == -1) {
#line 1146
    goto case_neg_1;
  }
#line 1149
  if (tmp___4 == 0) {
#line 1149
    goto case_0;
  }
#line 1144
  goto switch_break___0;
  case_neg_1: /* CIL Label */ 
#line 1148
  return;
  case_0: /* CIL Label */ 
#line 1151
  return;
  switch_break___0: /* CIL Label */ ;
  }
#line 1155
  node1 = (scanner->scans)->head;
  {
#line 1155
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1155
    if (! ((unsigned long )node1 != (unsigned long )((void *)0))) {
#line 1155
      goto while_break___1;
    }
#line 1157
    scan = (OPM_SCAN_T *)node1->data;
#line 1159
    node2 = (scan->connections)->head;
    {
#line 1159
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1159
      if (! ((unsigned long )node2 != (unsigned long )((void *)0))) {
#line 1159
        goto while_break___2;
      }
#line 1161
      conn = (OPM_CONNECTION_T *)node2->data;
#line 1163
      i = 0U;
      {
#line 1163
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 1163
        if (! (i < size)) {
#line 1163
          goto while_break___3;
        }
#line 1165
        if ((ufds___0 + i)->fd == conn->fd) {
#line 1165
          if ((int )conn->state != 4) {
#line 1167
            if ((int )(ufds___0 + i)->revents & 1) {
              {
#line 1168
              libopm_do_readready___0(scanner, scan, conn);
              }
            }
#line 1169
            if ((int )(ufds___0 + i)->revents & 4) {
              {
#line 1170
              libopm_do_writeready___0(scanner, scan, conn);
              }
            }
#line 1171
            if ((int )(ufds___0 + i)->revents & 16) {
              {
#line 1172
              libopm_do_hup___0(scanner, scan, conn);
              }
            }
          }
        }
#line 1163
        i ++;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 1159
      node2 = node2->next;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 1155
    node1 = node1->next;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1177
  return;
}
}
#line 1196 "/home/june/collector/temp/bopm-3.1.3/src/libopm/src/libopm.c"
static void libopm_do_readready___0(OPM_T *scanner , OPM_SCAN_T *scan , OPM_CONNECTION_T *conn ) 
{ 
  int max_read ;
  char c ;
  void *tmp___0 ;
  ssize_t tmp___1 ;
  int *tmp___2 ;
  OPM_REMOTE_T *tmp___3 ;

  {
#line 1204
  if ((conn->protocol)->read_function) {
    {
#line 1206
    (*((conn->protocol)->read_function))(scanner, scan, conn);
    }
#line 1207
    return;
  }
  {
#line 1210
  tmp___0 = libopm_config(scanner->config, 6);
#line 1210
  max_read = *((int *)tmp___0);
  }
  {
#line 1212
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1214
    tmp___1 = read(conn->fd, (void *)(& c), (size_t )1);
    }
    {
#line 1216
    if (tmp___1 == 0L) {
#line 1216
      goto case_0;
    }
#line 1220
    if (tmp___1 == -1L) {
#line 1220
      goto case_neg_1;
    }
#line 1225
    goto switch_default;
    case_0: /* CIL Label */ 
    {
#line 1217
    libopm_do_hup___0(scanner, scan, conn);
    }
#line 1218
    return;
    case_neg_1: /* CIL Label */ 
    {
#line 1221
    tmp___2 = __errno_location();
    }
#line 1221
    if (*tmp___2 != 11) {
      {
#line 1222
      libopm_do_hup___0(scanner, scan, conn);
      }
    }
#line 1223
    return;
    switch_default: /* CIL Label */ 
#line 1227
    conn->bytes_read = (unsigned short )((int )conn->bytes_read + 1);
#line 1229
    if ((int )conn->bytes_read >= max_read) {
      {
#line 1231
      tmp___3 = libopm_setup_remote___0(scan->remote, conn);
#line 1231
      libopm_do_callback___0(scanner, tmp___3, 3, 5);
#line 1232
      conn->state = (unsigned short)4;
      }
#line 1233
      return;
    }
#line 1236
    if ((int )c == 0) {
#line 1237
      goto while_continue;
    } else
#line 1236
    if ((int )c == 13) {
#line 1237
      goto while_continue;
    }
#line 1239
    if ((int )c == 10) {
      {
#line 1241
      conn->readbuf[conn->readlen] = (char )'\000';
#line 1242
      conn->readlen = (unsigned short)0;
#line 1243
      libopm_do_read___0(scanner, scan, conn);
      }
#line 1245
      if ((int )conn->state == 4) {
#line 1246
        return;
      }
#line 1248
      goto while_continue;
    }
#line 1251
    if ((int )conn->readlen < 128) {
#line 1253
      conn->readlen = (unsigned short )((int )conn->readlen + 1);
#line 1253
      conn->readbuf[(int )conn->readlen - 1] = c;
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 1278 "/home/june/collector/temp/bopm-3.1.3/src/libopm/src/libopm.c"
static void libopm_do_read___0(OPM_T *scanner , OPM_SCAN_T *scan , OPM_CONNECTION_T *conn ) 
{ 
  OPM_LIST_T *list ;
  OPM_NODE_T *node ;
  char *target_string ;
  void *tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 1285
  tmp___0 = libopm_config(scanner->config, 3);
#line 1285
  list = (OPM_LIST_T *)tmp___0;
#line 1286
  node = list->head;
  }
  {
#line 1286
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1286
    if (! ((unsigned long )node != (unsigned long )((void *)0))) {
#line 1286
      goto while_break;
    }
    {
#line 1288
    target_string = (char *)node->data;
#line 1289
    tmp___1 = strstr((char const   *)(conn->readbuf), (char const   *)target_string);
    }
#line 1289
    if (tmp___1) {
      {
#line 1291
      libopm_do_openproxy___0(scanner, scan, conn);
      }
#line 1292
      goto while_break;
    }
#line 1286
    node = node->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 1295
  return;
}
}
#line 1312 "/home/june/collector/temp/bopm-3.1.3/src/libopm/src/libopm.c"
static void libopm_do_openproxy___0(OPM_T *scanner , OPM_SCAN_T *scan , OPM_CONNECTION_T *conn ) 
{ 
  OPM_REMOTE_T *remote ;
  OPM_REMOTE_T *tmp___0 ;

  {
  {
#line 1316
  remote = scan->remote;
#line 1319
  conn->state = (unsigned short)4;
#line 1322
  tmp___0 = libopm_setup_remote___0(scan->remote, conn);
#line 1322
  libopm_do_callback___0(scanner, tmp___0, 0, 0);
  }
#line 1323
  return;
}
}
#line 1342 "/home/june/collector/temp/bopm-3.1.3/src/libopm/src/libopm.c"
static void libopm_do_writeready___0(OPM_T *scanner , OPM_SCAN_T *scan , OPM_CONNECTION_T *conn ) 
{ 
  OPM_PROTOCOL_T *protocol ;

  {
#line 1346
  protocol = conn->protocol;
#line 1349
  if (protocol->write_function) {
    {
#line 1350
    (*(protocol->write_function))(scanner, scan, conn);
    }
  }
#line 1353
  conn->state = (unsigned short)3;
#line 1354
  return;
}
}
#line 1372 "/home/june/collector/temp/bopm-3.1.3/src/libopm/src/libopm.c"
static void libopm_do_hup___0(OPM_T *scanner , OPM_SCAN_T *scan , OPM_CONNECTION_T *conn ) 
{ 
  OPM_REMOTE_T *remote ;
  OPM_REMOTE_T *tmp___0 ;

  {
  {
#line 1376
  remote = scan->remote;
#line 1379
  conn->state = (unsigned short)4;
#line 1381
  tmp___0 = libopm_setup_remote___0(scan->remote, conn);
#line 1381
  libopm_do_callback___0(scanner, tmp___0, 1, 0);
  }
#line 1382
  return;
}
}
#line 1400 "/home/june/collector/temp/bopm-3.1.3/src/libopm/src/libopm.c"
static void libopm_do_callback___0(OPM_T *scanner , OPM_REMOTE_T *remote , int type ,
                                   int var ) 
{ 


  {
#line 1403
  if (type < 0) {
#line 1404
    return;
  } else
#line 1403
  if (type >= 6) {
#line 1404
    return;
  }
#line 1406
  if ((scanner->callbacks + type)->func) {
    {
#line 1407
    (*((scanner->callbacks + type)->func))(scanner, remote, var, (scanner->callbacks + type)->data);
    }
  }
#line 1408
  return;
}
}
#line 1425 "/home/june/collector/temp/bopm-3.1.3/src/libopm/src/libopm.c"
static OPM_REMOTE_T *libopm_setup_remote___0(OPM_REMOTE_T *remote , OPM_CONNECTION_T *conn ) 
{ 


  {
#line 1427
  remote->port = conn->port;
#line 1428
  remote->bytes_read = conn->bytes_read;
#line 1429
  remote->protocol = (unsigned short )(conn->protocol)->type;
#line 1431
  return (remote);
}
}
#line 56
static OPM_PROTOCOL_CONFIG_T *libopm_protocol_config_create___1(void) ;
#line 57
static void libopm_protocol_config_free___1(OPM_PROTOCOL_CONFIG_T *protocol ) ;
#line 68
static OPM_SCAN_T *libopm_scan_create___1(OPM_T *scanner , OPM_REMOTE_T *remote ) ;
#line 69
static void libopm_scan_free___1(OPM_SCAN_T *scan ) ;
#line 71
static OPM_CONNECTION_T *libopm_connection_create___1(void) ;
#line 72
static void libopm_connection_free___1(OPM_CONNECTION_T *conn ) ;
#line 74
static void libopm_check_establish___1(OPM_T *scanner ) ;
#line 75
static void libopm_check_poll___1(OPM_T *scanner ) ;
#line 76
static void libopm_check_closed___1(OPM_T *scanner ) ;
#line 77
static void libopm_check_queue___1(OPM_T *scanner ) ;
#line 79
static void libopm_do_connect___1(OPM_T *scanner , OPM_SCAN_T *scan , OPM_CONNECTION_T *conn ) ;
#line 80
static void libopm_do_readready___1(OPM_T *scanner , OPM_SCAN_T *scan , OPM_CONNECTION_T *conn ) ;
#line 81
static void libopm_do_writeready___1(OPM_T *scanner , OPM_SCAN_T *scan , OPM_CONNECTION_T *conn ) ;
#line 82
static void libopm_do_hup___1(OPM_T *scanner , OPM_SCAN_T *scan , OPM_CONNECTION_T *conn ) ;
#line 83
static void libopm_do_read___1(OPM_T *scanner , OPM_SCAN_T *scan , OPM_CONNECTION_T *conn ) ;
#line 84
static void libopm_do_openproxy___1(OPM_T *scanner , OPM_SCAN_T *scan , OPM_CONNECTION_T *conn ) ;
#line 86
static void libopm_do_callback___1(OPM_T *scanner , OPM_REMOTE_T *remote , int type ,
                                   int var ) ;
#line 88
static OPM_REMOTE_T *libopm_setup_remote___1(OPM_REMOTE_T *remote , OPM_CONNECTION_T *conn ) ;
#line 99 "/home/june/collector/temp/bopm-3.1.3/src/libopm/src/libopm.c"
static OPM_PROTOCOL_T OPM_PROTOCOLS___1[6]  = {      {1, & libopm_proxy_http_write, (OPM_PROXYREAD_T *)((void *)0)}, 
        {2, & libopm_proxy_socks4_write, (OPM_PROXYREAD_T *)((void *)0)}, 
        {3, & libopm_proxy_socks5_write, (OPM_PROXYREAD_T *)((void *)0)}, 
        {5, & libopm_proxy_router_write, (OPM_PROXYREAD_T *)((void *)0)}, 
        {4, & libopm_proxy_wingate_write, (OPM_PROXYREAD_T *)((void *)0)}, 
        {6, & libopm_proxy_httppost_write, (OPM_PROXYREAD_T *)((void *)0)}};
#line 473 "/home/june/collector/temp/bopm-3.1.3/src/libopm/src/libopm.c"
static OPM_PROTOCOL_CONFIG_T *libopm_protocol_config_create___1(void) 
{ 
  OPM_PROTOCOL_CONFIG_T *ret ;
  void *tmp___0 ;

  {
  {
#line 476
  tmp___0 = libopm_MyMalloc(sizeof(*ret));
#line 476
  ret = (OPM_PROTOCOL_CONFIG_T *)tmp___0;
  }
#line 478
  return (ret);
}
}
#line 495 "/home/june/collector/temp/bopm-3.1.3/src/libopm/src/libopm.c"
static void libopm_protocol_config_free___1(OPM_PROTOCOL_CONFIG_T *protocol ) 
{ 


  {
  {
#line 497
  libopm_MyFree((void **)(& protocol));
  }
#line 498
  return;
}
}
#line 681 "/home/june/collector/temp/bopm-3.1.3/src/libopm/src/libopm.c"
static OPM_SCAN_T *libopm_scan_create___1(OPM_T *scanner , OPM_REMOTE_T *remote ) 
{ 
  OPM_SCAN_T *ret ;
  OPM_CONNECTION_T *conn ;
  OPM_NODE_T *node ;
  OPM_NODE_T *p ;
  void *tmp___0 ;

  {
  {
#line 687
  tmp___0 = libopm_MyMalloc(sizeof(*ret));
#line 687
  ret = (OPM_SCAN_T *)tmp___0;
#line 689
  ret->remote = remote;
#line 690
  ret->connections = libopm_list_create();
#line 693
  p = (scanner->protocols)->head;
  }
  {
#line 693
  while (1) {
    while_continue: /* CIL Label */ ;
#line 693
    if (! ((unsigned long )p != (unsigned long )((void *)0))) {
#line 693
      goto while_break;
    }
    {
#line 695
    conn = libopm_connection_create___1();
#line 697
    conn->protocol = ((OPM_PROTOCOL_CONFIG_T *)p->data)->type;
#line 698
    conn->port = ((OPM_PROTOCOL_CONFIG_T *)p->data)->port;
#line 700
    node = libopm_node_create((void *)conn);
#line 702
    libopm_list_add(ret->connections, node);
#line 693
    p = p->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 708
  p = (remote->protocols)->head;
  {
#line 708
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 708
    if (! ((unsigned long )p != (unsigned long )((void *)0))) {
#line 708
      goto while_break___0;
    }
    {
#line 710
    conn = libopm_connection_create___1();
#line 712
    conn->protocol = ((OPM_PROTOCOL_CONFIG_T *)p->data)->type;
#line 713
    conn->port = ((OPM_PROTOCOL_CONFIG_T *)p->data)->port;
#line 715
    node = libopm_node_create((void *)conn);
#line 717
    libopm_list_add(ret->connections, node);
#line 708
    p = p->next;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 720
  memset((void *)(& ret->addr), 0, sizeof(opm_sockaddr ));
  }
#line 722
  return (ret);
}
}
#line 739 "/home/june/collector/temp/bopm-3.1.3/src/libopm/src/libopm.c"
static void libopm_scan_free___1(OPM_SCAN_T *scan ) 
{ 
  OPM_NODE_T *p ;
  OPM_NODE_T *next ;
  OPM_CONNECTION_T *conn ;

  {
#line 744
  p = (scan->connections)->head;
#line 744
  if (p) {
#line 744
    next = p->next;
  } else {
#line 744
    next = (OPM_NODE_T *)((void *)0);
  }
  {
#line 744
  while (1) {
    while_continue: /* CIL Label */ ;
#line 744
    if (! ((unsigned long )p != (unsigned long )((void *)0))) {
#line 744
      goto while_break;
    }
    {
#line 746
    conn = (OPM_CONNECTION_T *)p->data;
#line 747
    libopm_connection_free___1(conn);
#line 749
    libopm_list_remove(scan->connections, p);
#line 750
    libopm_node_free(p);
#line 744
    p = next;
    }
#line 744
    if (p) {
#line 744
      next = p->next;
    } else {
#line 744
      next = (OPM_NODE_T *)((void *)0);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 752
  libopm_list_free(scan->connections);
#line 754
  libopm_MyFree((void **)(& scan));
  }
#line 755
  return;
}
}
#line 771 "/home/june/collector/temp/bopm-3.1.3/src/libopm/src/libopm.c"
static OPM_CONNECTION_T *libopm_connection_create___1(void) 
{ 
  OPM_CONNECTION_T *ret ;
  void *tmp___0 ;

  {
  {
#line 774
  tmp___0 = libopm_MyMalloc(sizeof(*ret));
#line 774
  ret = (OPM_CONNECTION_T *)tmp___0;
#line 776
  ret->fd = 0;
#line 777
  ret->bytes_read = (unsigned short)0;
#line 778
  ret->readlen = (unsigned short)0;
#line 779
  ret->protocol = (OPM_PROTOCOL_T *)0;
#line 780
  ret->port = (unsigned short)0;
#line 782
  ret->state = (unsigned short)1;
  }
#line 784
  return (ret);
}
}
#line 801 "/home/june/collector/temp/bopm-3.1.3/src/libopm/src/libopm.c"
static void libopm_connection_free___1(OPM_CONNECTION_T *conn ) 
{ 


  {
  {
#line 803
  libopm_MyFree((void **)(& conn));
  }
#line 804
  return;
}
}
#line 840 "/home/june/collector/temp/bopm-3.1.3/src/libopm/src/libopm.c"
static void libopm_check_queue___1(OPM_T *scanner ) 
{ 
  OPM_NODE_T *node ;
  OPM_SCAN_T *scan ;
  unsigned int protocols___0 ;
  unsigned int projected ;
  unsigned int fd_limit ;
  void *tmp___0 ;

  {
#line 847
  if ((scanner->queue)->elements == 0) {
#line 848
    return;
  }
  {
#line 850
  tmp___0 = libopm_config(scanner->config, 0);
#line 850
  fd_limit = (unsigned int )*((int *)tmp___0);
#line 852
  projected = scanner->fd_use;
  }
  {
#line 856
  while (1) {
    while_continue: /* CIL Label */ ;
#line 856
    if (! ((scanner->queue)->elements > 0)) {
#line 856
      goto while_break;
    }
#line 860
    scan = (OPM_SCAN_T *)((scanner->queue)->head)->data;
#line 861
    protocols___0 = (unsigned int )(scan->connections)->elements;
#line 864
    if (protocols___0 + projected > fd_limit) {
#line 865
      goto while_break;
    }
    {
#line 869
    node = libopm_list_remove(scanner->queue, (scanner->queue)->head);
#line 870
    libopm_list_add(scanner->scans, node);
#line 871
    projected += protocols___0;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 874
  return;
}
}
#line 890 "/home/june/collector/temp/bopm-3.1.3/src/libopm/src/libopm.c"
static void libopm_check_establish___1(OPM_T *scanner ) 
{ 
  OPM_NODE_T *node1 ;
  OPM_NODE_T *node2 ;
  OPM_SCAN_T *scan ;
  OPM_CONNECTION_T *conn ;
  unsigned int fd_limit ;
  void *tmp___0 ;

  {
#line 898
  if ((scanner->scans)->elements == 0) {
#line 899
    return;
  }
  {
#line 901
  tmp___0 = libopm_config(scanner->config, 0);
#line 901
  fd_limit = (unsigned int )*((int *)tmp___0);
  }
#line 903
  if (scanner->fd_use >= fd_limit) {
#line 904
    return;
  }
#line 906
  node1 = (scanner->scans)->head;
  {
#line 906
  while (1) {
    while_continue: /* CIL Label */ ;
#line 906
    if (! ((unsigned long )node1 != (unsigned long )((void *)0))) {
#line 906
      goto while_break;
    }
#line 908
    scan = (OPM_SCAN_T *)node1->data;
#line 909
    node2 = (scan->connections)->head;
    {
#line 909
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 909
      if (! ((unsigned long )node2 != (unsigned long )((void *)0))) {
#line 909
        goto while_break___0;
      }
#line 912
      if (scanner->fd_use >= fd_limit) {
#line 913
        return;
      }
#line 915
      conn = (OPM_CONNECTION_T *)node2->data;
#line 916
      if ((int )conn->state == 1) {
        {
#line 917
        libopm_do_connect___1(scanner, scan, conn);
        }
      }
#line 909
      node2 = node2->next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 906
    node1 = node1->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 920
  return;
}
}
#line 941 "/home/june/collector/temp/bopm-3.1.3/src/libopm/src/libopm.c"
static void libopm_check_closed___1(OPM_T *scanner ) 
{ 
  time_t present ;
  OPM_NODE_T *node1 ;
  OPM_NODE_T *node2 ;
  OPM_NODE_T *next1 ;
  OPM_NODE_T *next2 ;
  int timeout___0 ;
  OPM_SCAN_T *scan ;
  OPM_CONNECTION_T *conn ;
  void *tmp___0 ;
  OPM_REMOTE_T *tmp___1 ;

  {
#line 951
  if ((scanner->scans)->elements == 0) {
#line 952
    return;
  }
  {
#line 954
  time(& present);
#line 956
  tmp___0 = libopm_config(scanner->config, 7);
#line 956
  timeout___0 = *((int *)tmp___0);
#line 958
  node1 = (scanner->scans)->head;
  }
#line 958
  if (node1) {
#line 958
    next1 = node1->next;
  } else {
#line 958
    next1 = (OPM_NODE_T *)((void *)0);
  }
  {
#line 958
  while (1) {
    while_continue: /* CIL Label */ ;
#line 958
    if (! ((unsigned long )node1 != (unsigned long )((void *)0))) {
#line 958
      goto while_break;
    }
#line 960
    scan = (OPM_SCAN_T *)node1->data;
#line 961
    node2 = (scan->connections)->head;
#line 961
    if (node2) {
#line 961
      next2 = node2->next;
    } else {
#line 961
      next2 = (OPM_NODE_T *)((void *)0);
    }
    {
#line 961
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 961
      if (! ((unsigned long )node2 != (unsigned long )((void *)0))) {
#line 961
        goto while_break___0;
      }
#line 964
      conn = (OPM_CONNECTION_T *)node2->data;
#line 966
      if ((int )conn->state == 4) {
#line 968
        if (conn->fd > 0) {
          {
#line 969
          close(conn->fd);
          }
        }
        {
#line 971
        (scanner->fd_use) --;
#line 973
        libopm_list_remove(scan->connections, node2);
#line 974
        libopm_connection_free___1(conn);
#line 975
        libopm_node_free(node2);
        }
#line 976
        goto __Cont;
      }
#line 979
      if (present - conn->creation >= (time_t )timeout___0) {
#line 979
        if ((int )conn->state != 1) {
          {
#line 983
          close(conn->fd);
#line 984
          (scanner->fd_use) --;
#line 986
          tmp___1 = libopm_setup_remote___1(scan->remote, conn);
#line 986
          libopm_do_callback___1(scanner, tmp___1, 4, 0);
#line 988
          libopm_list_remove(scan->connections, node2);
#line 989
          libopm_connection_free___1(conn);
#line 990
          libopm_node_free(node2);
          }
#line 992
          goto __Cont;
        }
      }
      __Cont: /* CIL Label */ 
#line 961
      node2 = next2;
#line 961
      if (node2) {
#line 961
        next2 = node2->next;
      } else {
#line 961
        next2 = (OPM_NODE_T *)((void *)0);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 999
    if ((scan->connections)->elements == 0) {
      {
#line 1001
      libopm_do_callback___1(scanner, scan->remote, 2, 0);
#line 1003
      libopm_list_remove(scanner->scans, node1);
#line 1004
      libopm_scan_free___1(scan);
#line 1005
      libopm_node_free(node1);
      }
    }
#line 958
    node1 = next1;
#line 958
    if (node1) {
#line 958
      next1 = node1->next;
    } else {
#line 958
      next1 = (OPM_NODE_T *)((void *)0);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1008
  return;
}
}
#line 1024 "/home/june/collector/temp/bopm-3.1.3/src/libopm/src/libopm.c"
static void libopm_do_connect___1(OPM_T *scanner , OPM_SCAN_T *scan , OPM_CONNECTION_T *conn ) 
{ 
  opm_sockaddr *bind_ip ;
  struct sockaddr_in *addr___0 ;
  struct sockaddr_in local_addr ;
  void *tmp___0 ;
  OPM_REMOTE_T *tmp___1 ;
  OPM_REMOTE_T *tmp___2 ;
  int tmp___3 ;

  {
  {
#line 1031
  addr___0 = & scan->addr.sa4;
#line 1033
  addr___0->sin_family = (sa_family_t )2;
#line 1034
  addr___0->sin_port = htons(conn->port);
#line 1037
  tmp___0 = libopm_config(scanner->config, 1);
#line 1037
  bind_ip = (opm_sockaddr *)tmp___0;
#line 1039
  conn->fd = socket(2, 1, 0);
#line 1040
  (scanner->fd_use) ++;
  }
#line 1042
  if (conn->fd == -1) {
    {
#line 1044
    tmp___1 = libopm_setup_remote___1(scan->remote, conn);
#line 1044
    libopm_do_callback___1(scanner, tmp___1, 3, 10);
#line 1045
    conn->state = (unsigned short)4;
    }
#line 1046
    return;
  }
#line 1049
  if ((unsigned long )bind_ip != (unsigned long )((void *)0)) {
    {
#line 1051
    memset((void *)(& local_addr), 0, sizeof(local_addr));
#line 1052
    local_addr.sin_addr.s_addr = bind_ip->sa4.sin_addr.s_addr;
#line 1053
    local_addr.sin_family = (sa_family_t )2;
#line 1054
    local_addr.sin_port = htons((uint16_t )0);
#line 1056
    tmp___3 = bind(conn->fd, (struct sockaddr  const  *)((struct sockaddr *)(& local_addr)),
                   (socklen_t )sizeof(local_addr));
    }
#line 1056
    if (tmp___3 == -1) {
      {
#line 1058
      tmp___2 = libopm_setup_remote___1(scan->remote, conn);
#line 1058
      libopm_do_callback___1(scanner, tmp___2, 3, 9);
#line 1059
      conn->state = (unsigned short)4;
      }
#line 1060
      return;
    }
  }
  {
#line 1065
  fcntl(conn->fd, 4, 2048);
#line 1067
  connect(conn->fd, (struct sockaddr  const  *)((struct sockaddr *)addr___0), (socklen_t )sizeof(*addr___0));
#line 1069
  conn->state = (unsigned short)2;
#line 1070
  time(& conn->creation);
  }
#line 1071
  return;
}
}
#line 1090 "/home/june/collector/temp/bopm-3.1.3/src/libopm/src/libopm.c"
static unsigned int ufds_size___1  ;
#line 1091 "/home/june/collector/temp/bopm-3.1.3/src/libopm/src/libopm.c"
static struct pollfd *ufds___1  =    (struct pollfd *)((void *)0);
#line 1084 "/home/june/collector/temp/bopm-3.1.3/src/libopm/src/libopm.c"
static void libopm_check_poll___1(OPM_T *scanner ) 
{ 
  OPM_NODE_T *node1 ;
  OPM_NODE_T *node2 ;
  OPM_SCAN_T *scan ;
  OPM_CONNECTION_T *conn ;
  unsigned int size ;
  unsigned int i ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;

  {
  {
#line 1094
  size = 0U;
#line 1097
  tmp___3 = libopm_config(scanner->config, 0);
  }
#line 1097
  if (ufds_size___1 < *((unsigned int *)tmp___3)) {
    {
#line 1099
    libopm_MyFree((void **)(& ufds___1));
#line 1100
    tmp___0 = libopm_config(scanner->config, 0);
#line 1100
    tmp___1 = libopm_MyMalloc(sizeof(*ufds___1) * (unsigned long )*((unsigned int *)tmp___0));
#line 1100
    ufds___1 = (struct pollfd *)tmp___1;
#line 1101
    tmp___2 = libopm_config(scanner->config, 0);
#line 1101
    ufds_size___1 = *((unsigned int *)tmp___2);
    }
  }
#line 1104
  if ((scanner->scans)->elements == 0) {
#line 1105
    return;
  }
#line 1107
  node1 = (scanner->scans)->head;
  {
#line 1107
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1107
    if (! ((unsigned long )node1 != (unsigned long )((void *)0))) {
#line 1107
      goto while_break;
    }
#line 1109
    scan = (OPM_SCAN_T *)node1->data;
#line 1110
    node2 = (scan->connections)->head;
    {
#line 1110
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1110
      if (! ((unsigned long )node2 != (unsigned long )((void *)0))) {
#line 1110
        goto while_break___0;
      }
#line 1112
      if (size >= ufds_size___1) {
#line 1113
        goto while_break___0;
      }
#line 1115
      conn = (OPM_CONNECTION_T *)node2->data;
#line 1117
      if ((int )conn->state < 2) {
#line 1119
        goto __Cont;
      } else
#line 1117
      if ((int )conn->state == 4) {
#line 1119
        goto __Cont;
      }
#line 1121
      (ufds___1 + size)->events = (short)0;
#line 1122
      (ufds___1 + size)->revents = (short)0;
#line 1123
      (ufds___1 + size)->fd = conn->fd;
#line 1126
      (ufds___1 + size)->events = (short )((int )(ufds___1 + size)->events | 16);
#line 1128
      (ufds___1 + size)->events = (short )((int )(ufds___1 + size)->events | 32);
      {
#line 1132
      if ((int )conn->state == 2) {
#line 1132
        goto case_2;
      }
#line 1135
      if ((int )conn->state == 3) {
#line 1135
        goto case_3;
      }
#line 1130
      goto switch_break;
      case_2: /* CIL Label */ 
#line 1133
      (ufds___1 + size)->events = (short )((int )(ufds___1 + size)->events | 4);
#line 1134
      goto switch_break;
      case_3: /* CIL Label */ 
#line 1136
      (ufds___1 + size)->events = (short )((int )(ufds___1 + size)->events | 1);
#line 1137
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
#line 1139
      size ++;
      __Cont: /* CIL Label */ 
#line 1110
      node2 = node2->next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1107
    node1 = node1->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1144
  tmp___4 = poll(ufds___1, (nfds_t )size, 0);
  }
  {
#line 1146
  if (tmp___4 == -1) {
#line 1146
    goto case_neg_1;
  }
#line 1149
  if (tmp___4 == 0) {
#line 1149
    goto case_0;
  }
#line 1144
  goto switch_break___0;
  case_neg_1: /* CIL Label */ 
#line 1148
  return;
  case_0: /* CIL Label */ 
#line 1151
  return;
  switch_break___0: /* CIL Label */ ;
  }
#line 1155
  node1 = (scanner->scans)->head;
  {
#line 1155
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1155
    if (! ((unsigned long )node1 != (unsigned long )((void *)0))) {
#line 1155
      goto while_break___1;
    }
#line 1157
    scan = (OPM_SCAN_T *)node1->data;
#line 1159
    node2 = (scan->connections)->head;
    {
#line 1159
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1159
      if (! ((unsigned long )node2 != (unsigned long )((void *)0))) {
#line 1159
        goto while_break___2;
      }
#line 1161
      conn = (OPM_CONNECTION_T *)node2->data;
#line 1163
      i = 0U;
      {
#line 1163
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 1163
        if (! (i < size)) {
#line 1163
          goto while_break___3;
        }
#line 1165
        if ((ufds___1 + i)->fd == conn->fd) {
#line 1165
          if ((int )conn->state != 4) {
#line 1167
            if ((int )(ufds___1 + i)->revents & 1) {
              {
#line 1168
              libopm_do_readready___1(scanner, scan, conn);
              }
            }
#line 1169
            if ((int )(ufds___1 + i)->revents & 4) {
              {
#line 1170
              libopm_do_writeready___1(scanner, scan, conn);
              }
            }
#line 1171
            if ((int )(ufds___1 + i)->revents & 16) {
              {
#line 1172
              libopm_do_hup___1(scanner, scan, conn);
              }
            }
          }
        }
#line 1163
        i ++;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 1159
      node2 = node2->next;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 1155
    node1 = node1->next;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1177
  return;
}
}
#line 1196 "/home/june/collector/temp/bopm-3.1.3/src/libopm/src/libopm.c"
static void libopm_do_readready___1(OPM_T *scanner , OPM_SCAN_T *scan , OPM_CONNECTION_T *conn ) 
{ 
  int max_read ;
  char c ;
  void *tmp___0 ;
  ssize_t tmp___1 ;
  int *tmp___2 ;
  OPM_REMOTE_T *tmp___3 ;

  {
#line 1204
  if ((conn->protocol)->read_function) {
    {
#line 1206
    (*((conn->protocol)->read_function))(scanner, scan, conn);
    }
#line 1207
    return;
  }
  {
#line 1210
  tmp___0 = libopm_config(scanner->config, 6);
#line 1210
  max_read = *((int *)tmp___0);
  }
  {
#line 1212
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1214
    tmp___1 = read(conn->fd, (void *)(& c), (size_t )1);
    }
    {
#line 1216
    if (tmp___1 == 0L) {
#line 1216
      goto case_0;
    }
#line 1220
    if (tmp___1 == -1L) {
#line 1220
      goto case_neg_1;
    }
#line 1225
    goto switch_default;
    case_0: /* CIL Label */ 
    {
#line 1217
    libopm_do_hup___1(scanner, scan, conn);
    }
#line 1218
    return;
    case_neg_1: /* CIL Label */ 
    {
#line 1221
    tmp___2 = __errno_location();
    }
#line 1221
    if (*tmp___2 != 11) {
      {
#line 1222
      libopm_do_hup___1(scanner, scan, conn);
      }
    }
#line 1223
    return;
    switch_default: /* CIL Label */ 
#line 1227
    conn->bytes_read = (unsigned short )((int )conn->bytes_read + 1);
#line 1229
    if ((int )conn->bytes_read >= max_read) {
      {
#line 1231
      tmp___3 = libopm_setup_remote___1(scan->remote, conn);
#line 1231
      libopm_do_callback___1(scanner, tmp___3, 3, 5);
#line 1232
      conn->state = (unsigned short)4;
      }
#line 1233
      return;
    }
#line 1236
    if ((int )c == 0) {
#line 1237
      goto while_continue;
    } else
#line 1236
    if ((int )c == 13) {
#line 1237
      goto while_continue;
    }
#line 1239
    if ((int )c == 10) {
      {
#line 1241
      conn->readbuf[conn->readlen] = (char )'\000';
#line 1242
      conn->readlen = (unsigned short)0;
#line 1243
      libopm_do_read___1(scanner, scan, conn);
      }
#line 1245
      if ((int )conn->state == 4) {
#line 1246
        return;
      }
#line 1248
      goto while_continue;
    }
#line 1251
    if ((int )conn->readlen < 128) {
#line 1253
      conn->readlen = (unsigned short )((int )conn->readlen + 1);
#line 1253
      conn->readbuf[(int )conn->readlen - 1] = c;
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 1278 "/home/june/collector/temp/bopm-3.1.3/src/libopm/src/libopm.c"
static void libopm_do_read___1(OPM_T *scanner , OPM_SCAN_T *scan , OPM_CONNECTION_T *conn ) 
{ 
  OPM_LIST_T *list ;
  OPM_NODE_T *node ;
  char *target_string ;
  void *tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 1285
  tmp___0 = libopm_config(scanner->config, 3);
#line 1285
  list = (OPM_LIST_T *)tmp___0;
#line 1286
  node = list->head;
  }
  {
#line 1286
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1286
    if (! ((unsigned long )node != (unsigned long )((void *)0))) {
#line 1286
      goto while_break;
    }
    {
#line 1288
    target_string = (char *)node->data;
#line 1289
    tmp___1 = strstr((char const   *)(conn->readbuf), (char const   *)target_string);
    }
#line 1289
    if (tmp___1) {
      {
#line 1291
      libopm_do_openproxy___1(scanner, scan, conn);
      }
#line 1292
      goto while_break;
    }
#line 1286
    node = node->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 1295
  return;
}
}
#line 1312 "/home/june/collector/temp/bopm-3.1.3/src/libopm/src/libopm.c"
static void libopm_do_openproxy___1(OPM_T *scanner , OPM_SCAN_T *scan , OPM_CONNECTION_T *conn ) 
{ 
  OPM_REMOTE_T *remote ;
  OPM_REMOTE_T *tmp___0 ;

  {
  {
#line 1316
  remote = scan->remote;
#line 1319
  conn->state = (unsigned short)4;
#line 1322
  tmp___0 = libopm_setup_remote___1(scan->remote, conn);
#line 1322
  libopm_do_callback___1(scanner, tmp___0, 0, 0);
  }
#line 1323
  return;
}
}
#line 1342 "/home/june/collector/temp/bopm-3.1.3/src/libopm/src/libopm.c"
static void libopm_do_writeready___1(OPM_T *scanner , OPM_SCAN_T *scan , OPM_CONNECTION_T *conn ) 
{ 
  OPM_PROTOCOL_T *protocol ;

  {
#line 1346
  protocol = conn->protocol;
#line 1349
  if (protocol->write_function) {
    {
#line 1350
    (*(protocol->write_function))(scanner, scan, conn);
    }
  }
#line 1353
  conn->state = (unsigned short)3;
#line 1354
  return;
}
}
#line 1372 "/home/june/collector/temp/bopm-3.1.3/src/libopm/src/libopm.c"
static void libopm_do_hup___1(OPM_T *scanner , OPM_SCAN_T *scan , OPM_CONNECTION_T *conn ) 
{ 
  OPM_REMOTE_T *remote ;
  OPM_REMOTE_T *tmp___0 ;

  {
  {
#line 1376
  remote = scan->remote;
#line 1379
  conn->state = (unsigned short)4;
#line 1381
  tmp___0 = libopm_setup_remote___1(scan->remote, conn);
#line 1381
  libopm_do_callback___1(scanner, tmp___0, 1, 0);
  }
#line 1382
  return;
}
}
#line 1400 "/home/june/collector/temp/bopm-3.1.3/src/libopm/src/libopm.c"
static void libopm_do_callback___1(OPM_T *scanner , OPM_REMOTE_T *remote , int type ,
                                   int var ) 
{ 


  {
#line 1403
  if (type < 0) {
#line 1404
    return;
  } else
#line 1403
  if (type >= 6) {
#line 1404
    return;
  }
#line 1406
  if ((scanner->callbacks + type)->func) {
    {
#line 1407
    (*((scanner->callbacks + type)->func))(scanner, remote, var, (scanner->callbacks + type)->data);
    }
  }
#line 1408
  return;
}
}
#line 1425 "/home/june/collector/temp/bopm-3.1.3/src/libopm/src/libopm.c"
static OPM_REMOTE_T *libopm_setup_remote___1(OPM_REMOTE_T *remote , OPM_CONNECTION_T *conn ) 
{ 


  {
#line 1427
  remote->port = conn->port;
#line 1428
  remote->bytes_read = conn->bytes_read;
#line 1429
  remote->protocol = (unsigned short )(conn->protocol)->type;
#line 1431
  return (remote);
}
}
#line 40 "/home/june/collector/temp/bopm-3.1.3/src/libopm/src/config.c"
static OPM_CONFIG_HASH_T HASH___1[8]  = 
#line 40 "/home/june/collector/temp/bopm-3.1.3/src/libopm/src/config.c"
  {      {0, 1}, 
        {1, 3}, 
        {2, 2}, 
        {3, 4}, 
        {4, 2}, 
        {5, 1}, 
        {6, 1}, 
        {7, 1}};
#line 45 "/home/june/collector/temp/bopm-3.1.3/src/libopm/src/proxy.c"
static char SENDBUF___1[513]  ;
#line 40 "/home/june/collector/temp/bopm-3.1.3/src/libopm/src/config.c"
static OPM_CONFIG_HASH_T HASH___2[8]  = 
#line 40 "/home/june/collector/temp/bopm-3.1.3/src/libopm/src/config.c"
  {      {0, 1}, 
        {1, 3}, 
        {2, 2}, 
        {3, 4}, 
        {4, 2}, 
        {5, 1}, 
        {6, 1}, 
        {7, 1}};
#line 4 "/home/june/collector/temp/bopm-3.1.3/src/match.h"
int match(char const   *mask___0 , char const   *name ) ;
#line 5
char *collapse(char *pattern ) ;
#line 39 "/home/june/collector/temp/bopm-3.1.3/src/match.c"
unsigned char const   ToLowerTab[256]  = 
#line 39 "/home/june/collector/temp/bopm-3.1.3/src/match.c"
  {      (unsigned char const   )0,      (unsigned char const   )1,      (unsigned char const   )2,      (unsigned char const   )3, 
        (unsigned char const   )4,      (unsigned char const   )5,      (unsigned char const   )6,      (unsigned char const   )7, 
        (unsigned char const   )8,      (unsigned char const   )9,      (unsigned char const   )10,      (unsigned char const   )11, 
        (unsigned char const   )12,      (unsigned char const   )13,      (unsigned char const   )14,      (unsigned char const   )15, 
        (unsigned char const   )16,      (unsigned char const   )17,      (unsigned char const   )18,      (unsigned char const   )19, 
        (unsigned char const   )20,      (unsigned char const   )21,      (unsigned char const   )22,      (unsigned char const   )23, 
        (unsigned char const   )24,      (unsigned char const   )25,      (unsigned char const   )26,      (unsigned char const   )27, 
        (unsigned char const   )28,      (unsigned char const   )29,      (unsigned char const   )30,      (unsigned char const   )31, 
        (unsigned char const   )' ',      (unsigned char const   )'!',      (unsigned char const   )'\"',      (unsigned char const   )'#', 
        (unsigned char const   )'$',      (unsigned char const   )'%',      (unsigned char const   )'&',      (unsigned char const   )39, 
        (unsigned char const   )'(',      (unsigned char const   )')',      (unsigned char const   )'*',      (unsigned char const   )'+', 
        (unsigned char const   )',',      (unsigned char const   )'-',      (unsigned char const   )'.',      (unsigned char const   )'/', 
        (unsigned char const   )'0',      (unsigned char const   )'1',      (unsigned char const   )'2',      (unsigned char const   )'3', 
        (unsigned char const   )'4',      (unsigned char const   )'5',      (unsigned char const   )'6',      (unsigned char const   )'7', 
        (unsigned char const   )'8',      (unsigned char const   )'9',      (unsigned char const   )':',      (unsigned char const   )';', 
        (unsigned char const   )'<',      (unsigned char const   )'=',      (unsigned char const   )'>',      (unsigned char const   )'?', 
        (unsigned char const   )'@',      (unsigned char const   )'a',      (unsigned char const   )'b',      (unsigned char const   )'c', 
        (unsigned char const   )'d',      (unsigned char const   )'e',      (unsigned char const   )'f',      (unsigned char const   )'g', 
        (unsigned char const   )'h',      (unsigned char const   )'i',      (unsigned char const   )'j',      (unsigned char const   )'k', 
        (unsigned char const   )'l',      (unsigned char const   )'m',      (unsigned char const   )'n',      (unsigned char const   )'o', 
        (unsigned char const   )'p',      (unsigned char const   )'q',      (unsigned char const   )'r',      (unsigned char const   )'s', 
        (unsigned char const   )'t',      (unsigned char const   )'u',      (unsigned char const   )'v',      (unsigned char const   )'w', 
        (unsigned char const   )'x',      (unsigned char const   )'y',      (unsigned char const   )'z',      (unsigned char const   )'[', 
        (unsigned char const   )'\\',      (unsigned char const   )']',      (unsigned char const   )'^',      (unsigned char const   )'_', 
        (unsigned char const   )'`',      (unsigned char const   )'a',      (unsigned char const   )'b',      (unsigned char const   )'c', 
        (unsigned char const   )'d',      (unsigned char const   )'e',      (unsigned char const   )'f',      (unsigned char const   )'g', 
        (unsigned char const   )'h',      (unsigned char const   )'i',      (unsigned char const   )'j',      (unsigned char const   )'k', 
        (unsigned char const   )'l',      (unsigned char const   )'m',      (unsigned char const   )'n',      (unsigned char const   )'o', 
        (unsigned char const   )'p',      (unsigned char const   )'q',      (unsigned char const   )'r',      (unsigned char const   )'s', 
        (unsigned char const   )'t',      (unsigned char const   )'u',      (unsigned char const   )'v',      (unsigned char const   )'w', 
        (unsigned char const   )'x',      (unsigned char const   )'y',      (unsigned char const   )'z',      (unsigned char const   )'{', 
        (unsigned char const   )'|',      (unsigned char const   )'}',      (unsigned char const   )'~',      (unsigned char const   )127, 
        (unsigned char const   )128,      (unsigned char const   )129,      (unsigned char const   )130,      (unsigned char const   )131, 
        (unsigned char const   )132,      (unsigned char const   )133,      (unsigned char const   )134,      (unsigned char const   )135, 
        (unsigned char const   )136,      (unsigned char const   )137,      (unsigned char const   )138,      (unsigned char const   )139, 
        (unsigned char const   )140,      (unsigned char const   )141,      (unsigned char const   )142,      (unsigned char const   )143, 
        (unsigned char const   )144,      (unsigned char const   )145,      (unsigned char const   )146,      (unsigned char const   )147, 
        (unsigned char const   )148,      (unsigned char const   )149,      (unsigned char const   )150,      (unsigned char const   )151, 
        (unsigned char const   )152,      (unsigned char const   )153,      (unsigned char const   )154,      (unsigned char const   )155, 
        (unsigned char const   )156,      (unsigned char const   )157,      (unsigned char const   )158,      (unsigned char const   )159, 
        (unsigned char const   )160,      (unsigned char const   )161,      (unsigned char const   )162,      (unsigned char const   )163, 
        (unsigned char const   )164,      (unsigned char const   )165,      (unsigned char const   )166,      (unsigned char const   )167, 
        (unsigned char const   )168,      (unsigned char const   )169,      (unsigned char const   )170,      (unsigned char const   )171, 
        (unsigned char const   )172,      (unsigned char const   )173,      (unsigned char const   )174,      (unsigned char const   )175, 
        (unsigned char const   )176,      (unsigned char const   )177,      (unsigned char const   )178,      (unsigned char const   )179, 
        (unsigned char const   )180,      (unsigned char const   )181,      (unsigned char const   )182,      (unsigned char const   )183, 
        (unsigned char const   )184,      (unsigned char const   )185,      (unsigned char const   )186,      (unsigned char const   )187, 
        (unsigned char const   )188,      (unsigned char const   )189,      (unsigned char const   )190,      (unsigned char const   )191, 
        (unsigned char const   )192,      (unsigned char const   )193,      (unsigned char const   )194,      (unsigned char const   )195, 
        (unsigned char const   )196,      (unsigned char const   )197,      (unsigned char const   )198,      (unsigned char const   )199, 
        (unsigned char const   )200,      (unsigned char const   )201,      (unsigned char const   )202,      (unsigned char const   )203, 
        (unsigned char const   )204,      (unsigned char const   )205,      (unsigned char const   )206,      (unsigned char const   )207, 
        (unsigned char const   )208,      (unsigned char const   )209,      (unsigned char const   )210,      (unsigned char const   )211, 
        (unsigned char const   )212,      (unsigned char const   )213,      (unsigned char const   )214,      (unsigned char const   )215, 
        (unsigned char const   )216,      (unsigned char const   )217,      (unsigned char const   )218,      (unsigned char const   )219, 
        (unsigned char const   )220,      (unsigned char const   )221,      (unsigned char const   )222,      (unsigned char const   )223, 
        (unsigned char const   )224,      (unsigned char const   )225,      (unsigned char const   )226,      (unsigned char const   )227, 
        (unsigned char const   )228,      (unsigned char const   )229,      (unsigned char const   )230,      (unsigned char const   )231, 
        (unsigned char const   )232,      (unsigned char const   )233,      (unsigned char const   )234,      (unsigned char const   )235, 
        (unsigned char const   )236,      (unsigned char const   )237,      (unsigned char const   )238,      (unsigned char const   )239, 
        (unsigned char const   )240,      (unsigned char const   )241,      (unsigned char const   )242,      (unsigned char const   )243, 
        (unsigned char const   )244,      (unsigned char const   )245,      (unsigned char const   )246,      (unsigned char const   )247, 
        (unsigned char const   )248,      (unsigned char const   )249,      (unsigned char const   )250,      (unsigned char const   )251, 
        (unsigned char const   )252,      (unsigned char const   )253,      (unsigned char const   )254,      (unsigned char const   )255};
#line 112 "/home/june/collector/temp/bopm-3.1.3/src/match.c"
int match(char const   *mask___0 , char const   *name ) 
{ 
  unsigned char const   *m ;
  unsigned char const   *n ;
  unsigned char const   *ma ;
  unsigned char const   *na ;
  int wild ;
  int calls ;
  int tmp___0 ;

  {
#line 114
  m = (unsigned char const   *)mask___0;
#line 115
  n = (unsigned char const   *)name;
#line 116
  ma = (unsigned char const   *)mask___0;
#line 117
  na = (unsigned char const   *)name;
#line 118
  wild = 0;
#line 119
  calls = 0;
#line 121
  if (! ((unsigned long )((char const   *)0) != (unsigned long )mask___0)) {
    {
#line 121
    __assert_fail("0 != mask", "/home/june/collector/temp/bopm-3.1.3/src/match.c",
                  121U, "match");
    }
  }
#line 122
  if (! ((unsigned long )((char const   *)0) != (unsigned long )name)) {
    {
#line 122
    __assert_fail("0 != name", "/home/june/collector/temp/bopm-3.1.3/src/match.c",
                  122U, "match");
    }
  }
#line 124
  if (! mask___0) {
#line 125
    return (0);
  } else
#line 124
  if (! name) {
#line 125
    return (0);
  }
  {
#line 127
  while (1) {
    while_continue: /* CIL Label */ ;
#line 127
    tmp___0 = calls;
#line 127
    calls ++;
#line 127
    if (! (tmp___0 < 512)) {
#line 127
      goto while_break;
    }
#line 129
    if ((int const   )*m == 42) {
      {
#line 135
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 135
        if (! ((int const   )*m == 42)) {
#line 135
          goto while_break___0;
        }
#line 136
        m ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 138
      wild = 1;
#line 139
      ma = m;
#line 140
      na = n;
    }
#line 143
    if (! *m) {
#line 145
      if (! *n) {
#line 146
        return (1);
      }
#line 148
      m --;
      {
#line 148
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 148
        if ((unsigned long )m > (unsigned long )((unsigned char const   *)mask___0)) {
#line 148
          if (! ((int const   )*m == 63)) {
#line 148
            goto while_break___1;
          }
        } else {
#line 148
          goto while_break___1;
        }
#line 148
        m --;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 151
      if ((int const   )*m == 42) {
#line 151
        if ((unsigned long )m > (unsigned long )((unsigned char const   *)mask___0)) {
#line 152
          return (1);
        }
      }
#line 154
      if (! wild) {
#line 155
        return (0);
      }
#line 157
      m = ma;
#line 158
      na ++;
#line 158
      n = na;
    } else
#line 160
    if (! *n) {
      {
#line 166
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 166
        if (! ((int const   )*m == 42)) {
#line 166
          goto while_break___2;
        }
#line 167
        m ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 169
      return ((int const   )*m == 0);
    }
#line 172
    if ((int const   )ToLowerTab[(unsigned char )*m] != (int const   )ToLowerTab[(unsigned char )*n]) {
#line 172
      if ((int const   )*m != 63) {
#line 174
        if (! wild) {
#line 175
          return (0);
        }
#line 177
        m = ma;
#line 178
        na ++;
#line 178
        n = na;
      } else {
#line 172
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 182
      if (*m) {
#line 183
        m ++;
      }
#line 185
      if (*n) {
#line 186
        n ++;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 189
  return (0);
}
}
#line 210 "/home/june/collector/temp/bopm-3.1.3/src/match.c"
char *collapse(char *pattern ) 
{ 
  char *s ;
  char *s1 ;
  char *t ;
  char *tmp___0 ;
  char tmp___1 ;
  char *tmp___2 ;

  {
#line 212
  s = pattern;
#line 217
  if (s) {
    {
#line 219
    while (1) {
      while_continue: /* CIL Label */ ;
#line 219
      if (! *s) {
#line 219
        goto while_break;
      }
#line 221
      if (42 == (int )*s) {
#line 223
        s1 = s + 1;
#line 223
        t = s1;
        {
#line 224
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 224
          if (! (42 == (int )*t)) {
#line 224
            goto while_break___0;
          }
#line 225
          t ++;
        }
        while_break___0: /* CIL Label */ ;
        }
#line 227
        if ((unsigned long )s1 != (unsigned long )t) {
          {
#line 229
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 229
            tmp___0 = s1;
#line 229
            s1 ++;
#line 229
            tmp___2 = t;
#line 229
            t ++;
#line 229
            tmp___1 = *tmp___2;
#line 229
            *tmp___0 = tmp___1;
#line 229
            if (! tmp___1) {
#line 229
              goto while_break___1;
            }
          }
          while_break___1: /* CIL Label */ ;
          }
        }
      }
#line 219
      s ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 235
  return (pattern);
}
}
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
#line 390 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( /* format attribute */  vsnprintf)(char * __restrict  __s ,
                                                                              size_t __maxlen ,
                                                                              char const   * __restrict  __format ,
                                                                              __gnuc_va_list __arg ) ;
#line 444 "/usr/include/unistd.h"
extern unsigned int sleep(unsigned int __seconds ) ;
#line 106 "/usr/include/x86_64-linux-gnu/sys/select.h"
extern int select(int __nfds , fd_set * __restrict  __readfds , fd_set * __restrict  __writefds ,
                  fd_set * __restrict  __exceptfds , struct timeval * __restrict  __timeout ) ;
#line 543 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 129 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 140
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncat)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 236
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 285
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1,2), __leaf__)) strcspn)(char const   *__s ,
                                                                                                   char const   *__reject )  __attribute__((__pure__)) ;
#line 413
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
#line 534
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcasecmp)(char const   *__s1 ,
                                                                                                   char const   *__s2 )  __attribute__((__pure__)) ;
#line 538
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncasecmp)(char const   *__s1 ,
                                                                                                    char const   *__s2 ,
                                                                                                    size_t __n )  __attribute__((__pure__)) ;
#line 573 "/usr/include/regex.h"
extern int regcomp(regex_t * __restrict  __preg , char const   * __restrict  __pattern ,
                   int __cflags ) ;
#line 577
extern int regexec(regex_t const   * __restrict  __preg , char const   * __restrict  __string ,
                   size_t __nmatch , regmatch_t * __restrict  __pmatch , int __eflags ) ;
#line 582
extern size_t regerror(int __errcode , regex_t const   * __restrict  __preg , char * __restrict  __errbuf ,
                       size_t __errbuf_size ) ;
#line 125 "/home/june/collector/temp/bopm-3.1.3/src/config.h"
struct IRCConf *IRCItem ;
#line 126
struct OptionsConf *OptionsItem ;
#line 38 "/home/june/collector/temp/bopm-3.1.3/src/irc.h"
void irc_send(char *data  , ...) ;
#line 39
void irc_send_channels(char *data  , ...) ;
#line 40
void irc_cycle(void) ;
#line 41
void irc_timer(void) ;
#line 9 "/home/june/collector/temp/bopm-3.1.3/src/log.h"
void ( /* format attribute */  log_printf)(char *data  , ...) ;
#line 42 "/home/june/collector/temp/bopm-3.1.3/src/opercmd.h"
void command_userhost(char *reply ) ;
#line 44
void command_parse(char *command , char *msg___0 , struct ChannelConf *target , struct UserInfo *source_p ) ;
#line 39 "/home/june/collector/temp/bopm-3.1.3/src/scan.h"
void scan_connect(char **user , char *msg___0 ) ;
#line 76 "/home/june/collector/temp/bopm-3.1.3/src/firedns.h"
int fdns_errno ;
#line 93
struct in_addr *firedns_resolveip4(char const   * const  name ) ;
#line 97
char *firedns_strerror(int error ) ;
#line 16 "/home/june/collector/temp/bopm-3.1.3/src/stats.h"
void stats_connect(void) ;
#line 5 "/home/june/collector/temp/bopm-3.1.3/src/extern.h"
unsigned int OPT_DEBUG ;
#line 13 "/home/june/collector/temp/bopm-3.1.3/src/negcache.h"
void nc_init(struct cnode **head ) ;
#line 8 "/home/june/collector/temp/bopm-3.1.3/src/malloc.h"
void *MyMalloc(size_t bytes ) ;
#line 9
void _MyFree(void **var ) ;
#line 10
char *DupString(char const   *y ) ;
#line 4 "/home/june/collector/temp/bopm-3.1.3/src/main.h"
void main_restart(void) ;
#line 77 "/home/june/collector/temp/bopm-3.1.3/src/irc.c"
static void irc_init(void) ;
#line 78
static void irc_connect(void) ;
#line 79
static void irc_reconnect(void) ;
#line 80
static void irc_read(void) ;
#line 81
static void irc_parse(void) ;
#line 83
static struct ChannelConf *get_channel(char const   *channel ) ;
#line 85
static struct UserInfo *userinfo_create(char *source ) ;
#line 86
static void userinfo_free(struct UserInfo *source_p ) ;
#line 88
static void m_ping(char **parv___0 , unsigned int parc___0 , char *msg___0 , struct UserInfo *source_p ) ;
#line 89
static void m_invite(char **parv___0 , unsigned int parc___0 , char *msg___0 , struct UserInfo *source_p ) ;
#line 90
static void m_privmsg(char **parv___0 , unsigned int parc___0 , char *msg___0 , struct UserInfo *source_p ) ;
#line 91
static void m_ctcp(char **parv___0 , unsigned int parc___0 , char *msg___0 , struct UserInfo *source_p ) ;
#line 92
static void m_notice(char **parv___0 , unsigned int parc___0 , char *msg___0 , struct UserInfo *source_p ) ;
#line 93
static void m_perform(char **parv___0 , unsigned int parc___0 , char *msg___0 , struct UserInfo *notused ) ;
#line 94
static void m_userhost(char **parv___0 , unsigned int parc___0 , char *msg___0 , struct UserInfo *source_p ) ;
#line 95
static void m_cannot_join(char **parv___0 , unsigned int parc___0 , char *msg___0 ,
                          struct UserInfo *source_p ) ;
#line 96
static void m_kill(char **parv___0 , unsigned int parc___0 , char *msg___0 , struct UserInfo *source_p ) ;
#line 98
struct cnode *nc_head ;
#line 105 "/home/june/collector/temp/bopm-3.1.3/src/irc.c"
char IRC_RAW[513]  ;
#line 106 "/home/june/collector/temp/bopm-3.1.3/src/irc.c"
char IRC_SENDBUFF[513]  ;
#line 107 "/home/june/collector/temp/bopm-3.1.3/src/irc.c"
char IRC_CHANNELS[513]  ;
#line 108 "/home/june/collector/temp/bopm-3.1.3/src/irc.c"
int IRC_RAW_LEN  =    0;
#line 110 "/home/june/collector/temp/bopm-3.1.3/src/irc.c"
int IRC_FD  =    0;
#line 112 "/home/june/collector/temp/bopm-3.1.3/src/irc.c"
struct bopm_sockaddr IRC_SVR  ;
#line 113 "/home/june/collector/temp/bopm-3.1.3/src/irc.c"
struct bopm_ircaddr IRC_LOCAL  ;
#line 115 "/home/june/collector/temp/bopm-3.1.3/src/irc.c"
fd_set IRC_READ_FDSET  ;
#line 116 "/home/june/collector/temp/bopm-3.1.3/src/irc.c"
struct timeval IRC_TIMEOUT  ;
#line 118 "/home/june/collector/temp/bopm-3.1.3/src/irc.c"
time_t IRC_LAST  =    (time_t )0;
#line 119 "/home/june/collector/temp/bopm-3.1.3/src/irc.c"
time_t IRC_LASTRECONNECT  =    (time_t )0;
#line 124 "/home/june/collector/temp/bopm-3.1.3/src/irc.c"
static struct CommandHash COMMAND_TABLE[11]  = 
#line 124
  {      {(char *)"NOTICE", & m_notice}, 
        {(char *)"PRIVMSG", & m_privmsg}, 
        {(char *)"PING", & m_ping}, 
        {(char *)"INVITE", & m_invite}, 
        {(char *)"001", & m_perform}, 
        {(char *)"302", & m_userhost}, 
        {(char *)"471", & m_cannot_join}, 
        {(char *)"473", & m_cannot_join}, 
        {(char *)"474", & m_cannot_join}, 
        {(char *)"475", & m_cannot_join}, 
        {(char *)"KILL", & m_kill}};
#line 150 "/home/june/collector/temp/bopm-3.1.3/src/irc.c"
void irc_cycle(void) 
{ 
  int __d0 ;
  int __d1 ;
  int tmp___0 ;

  {
#line 152
  if (IRC_FD <= 0) {
#line 155
    if (OptionsItem->negcache > 0) {
      {
#line 156
      nc_init(& nc_head);
      }
    }
    {
#line 159
    irc_init();
#line 162
    irc_connect();
    }
#line 164
    return;
  }
#line 167
  IRC_TIMEOUT.tv_sec = (__time_t )0;
#line 169
  IRC_TIMEOUT.tv_usec = (__suseconds_t )25000;
  {
#line 171
  while (1) {
    while_continue: /* CIL Label */ ;
#line 171
    __asm__  volatile   ("cld; rep; "
                         "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                         "1" (& IRC_READ_FDSET.__fds_bits[0]): "memory");
#line 171
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 172
  IRC_READ_FDSET.__fds_bits[IRC_FD / (8 * (int )sizeof(__fd_mask ))] |= 1L << IRC_FD % (8 * (int )sizeof(__fd_mask ));
#line 174
  tmp___0 = select(IRC_FD + 1, (fd_set */* __restrict  */)(& IRC_READ_FDSET), (fd_set */* __restrict  */)0,
                   (fd_set */* __restrict  */)0, (struct timeval */* __restrict  */)(& IRC_TIMEOUT));
  }
  {
#line 176
  if (tmp___0 == -1) {
#line 176
    goto case_neg_1;
  }
#line 179
  if (tmp___0 == 0) {
#line 179
    goto case_0;
  }
#line 181
  goto switch_default;
  case_neg_1: /* CIL Label */ 
#line 177
  return;
#line 178
  goto switch_break;
  case_0: /* CIL Label */ 
#line 180
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 183
  if ((IRC_READ_FDSET.__fds_bits[IRC_FD / (8 * (int )sizeof(__fd_mask ))] & (1L << IRC_FD % (8 * (int )sizeof(__fd_mask )))) != 0L) {
    {
#line 184
    irc_read();
    }
  }
#line 185
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 187
  return;
}
}
#line 204 "/home/june/collector/temp/bopm-3.1.3/src/irc.c"
static void irc_init(void) 
{ 
  node_t *node ;
  struct ChannelConf *chan ;
  struct bopm_sockaddr bsaddr ;
  struct in_addr *irc_host ;
  char *tmp___0 ;
  int *tmp___1 ;
  int bindret ;
  int tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  size_t tmp___5 ;

  {
#line 212
  if (IRC_FD) {
    {
#line 213
    close(IRC_FD);
    }
  }
  {
#line 215
  memset((void *)(& IRC_SVR), 0, sizeof(IRC_SVR));
#line 216
  memset((void *)(& IRC_LOCAL), 0, sizeof(IRC_LOCAL));
#line 217
  memset((void *)(& bsaddr), 0, sizeof(struct bopm_sockaddr ));
#line 220
  irc_host = firedns_resolveip4((char const   */* const  */)IRCItem->server);
  }
#line 220
  if ((unsigned long )irc_host == (unsigned long )((void *)0)) {
    {
#line 222
    tmp___0 = firedns_strerror(fdns_errno);
#line 222
    log_printf((char *)"IRC -> firedns_resolveip4(\"%s\"): %s", IRCItem->server, tmp___0);
#line 224
    exit(1);
    }
  }
  {
#line 227
  IRC_SVR.sa4.sin_family = (sa_family_t )2;
#line 228
  IRC_SVR.sa4.sin_port = htons((uint16_t )IRCItem->port);
#line 229
  IRC_SVR.sa4.sin_addr = *irc_host;
  }
#line 231
  if (IRC_SVR.sa4.sin_addr.s_addr == 4294967295U) {
    {
#line 233
    log_printf((char *)"IRC -> Unknown error resolving remote host (%s)", IRCItem->server);
#line 235
    exit(1);
    }
  }
  {
#line 239
  IRC_FD = socket(2, 1, 0);
  }
#line 241
  if (IRC_FD == -1) {
    {
#line 243
    tmp___1 = __errno_location();
    }
    {
#line 246
    if (*tmp___1 == 93) {
#line 246
      goto case_93;
    }
#line 246
    if (*tmp___1 == 22) {
#line 246
      goto case_93;
    }
#line 250
    if (*tmp___1 == 23) {
#line 250
      goto case_23;
    }
#line 254
    if (*tmp___1 == 24) {
#line 254
      goto case_24;
    }
#line 258
    if (*tmp___1 == 13) {
#line 258
      goto case_13;
    }
#line 262
    if (*tmp___1 == 12) {
#line 262
      goto case_12;
    }
#line 266
    goto switch_default;
    case_93: /* CIL Label */ 
    case_22: /* CIL Label */ 
    {
#line 247
    log_printf((char *)"IRC -> socket(): SOCK_STREAM is not supported on this domain");
    }
#line 249
    goto switch_break;
    case_23: /* CIL Label */ 
    {
#line 251
    log_printf((char *)"IRC -> socket(): Not enough free file descriptors to allocate IRC socket");
    }
#line 253
    goto switch_break;
    case_24: /* CIL Label */ 
    {
#line 255
    log_printf((char *)"IRC -> socket(): Process table overflow when requesting file descriptor");
    }
#line 257
    goto switch_break;
    case_13: /* CIL Label */ 
    {
#line 259
    log_printf((char *)"IRC -> socket(): Permission denied to create socket of type SOCK_STREAM");
    }
#line 261
    goto switch_break;
    case_12: /* CIL Label */ 
    {
#line 263
    log_printf((char *)"IRC -> socket(): Insufficient memory to allocate socket");
    }
#line 265
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 267
    log_printf((char *)"IRC -> socket(): Unknown error allocating socket");
    }
#line 269
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
    {
#line 271
    exit(1);
    }
  }
  {
#line 275
  tmp___5 = strlen((char const   *)IRCItem->vhost);
  }
#line 275
  if (tmp___5 > 0UL) {
    {
#line 277
    bindret = 0;
#line 278
    tmp___2 = inet_pton(2, (char const   */* __restrict  */)IRCItem->vhost, (void */* __restrict  */)(& IRC_LOCAL.in4.s_addr));
    }
#line 278
    if (! tmp___2) {
      {
#line 280
      log_printf((char *)"IRC -> bind(): %s is an invalid address", IRCItem->vhost);
#line 281
      exit(1);
      }
    }
    {
#line 283
    bsaddr.sa4.sin_addr.s_addr = IRC_LOCAL.in4.s_addr;
#line 284
    bsaddr.sa4.sin_family = (sa_family_t )2;
#line 285
    bsaddr.sa4.sin_port = htons((uint16_t )0);
#line 287
    bindret = bind(IRC_FD, (struct sockaddr  const  *)((struct sockaddr *)(& bsaddr.sa4)),
                   (socklen_t )sizeof(bsaddr.sa4));
    }
#line 289
    if (bindret) {
      {
#line 291
      tmp___3 = __errno_location();
      }
      {
#line 293
      if (*tmp___3 == 13) {
#line 293
        goto case_13___0;
      }
#line 297
      goto switch_default___0;
      case_13___0: /* CIL Label */ 
      {
#line 294
      log_printf((char *)"IRC -> bind(): No access to bind to %s", IRCItem->vhost);
      }
#line 296
      goto switch_break___0;
      switch_default___0: /* CIL Label */ 
      {
#line 298
      tmp___4 = __errno_location();
#line 298
      log_printf((char *)"IRC -> bind(): Error binding to %s (%d)", IRCItem->vhost,
                 *tmp___4);
      }
#line 300
      goto switch_break___0;
      switch_break___0: /* CIL Label */ ;
      }
      {
#line 302
      exit(1);
      }
    }
  }
#line 308
  IRC_CHANNELS[0] = (char )'\000';
#line 309
  node = (IRCItem->channels)->head;
  {
#line 309
  while (1) {
    while_continue: /* CIL Label */ ;
#line 309
    if (! ((unsigned long )node != (unsigned long )((void *)0))) {
#line 309
      goto while_break;
    }
    {
#line 311
    chan = (struct ChannelConf *)node->data;
#line 312
    strncat((char */* __restrict  */)(IRC_CHANNELS), (char const   */* __restrict  */)chan->name,
            (size_t )513);
    }
#line 314
    if (node->next) {
      {
#line 315
      strncat((char */* __restrict  */)(IRC_CHANNELS), (char const   */* __restrict  */)",",
              (size_t )513);
      }
    }
#line 309
    node = node->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 317
  IRC_CHANNELS[513] = (char )'\000';
#line 320
  return;
}
}
#line 335 "/home/june/collector/temp/bopm-3.1.3/src/irc.c"
void irc_send(char *data  , ...) 
{ 
  va_list arglist ;
  char data2[513] ;
  char tosend[513] ;
  size_t tmp___0 ;
  ssize_t tmp___1 ;

  {
  {
#line 341
  __builtin_va_start(arglist, data);
#line 342
  vsnprintf((char */* __restrict  */)(data2), (size_t )513, (char const   */* __restrict  */)data,
            arglist);
#line 343
  __builtin_va_end(arglist);
  }
#line 345
  if (OPT_DEBUG >= 2U) {
    {
#line 346
    log_printf((char *)"IRC SEND -> %s", data2);
    }
  }
  {
#line 348
  snprintf((char */* __restrict  */)(tosend), (size_t )513, (char const   */* __restrict  */)"%s\n",
           data2);
#line 350
  tmp___0 = strlen((char const   *)(tosend));
#line 350
  tmp___1 = send(IRC_FD, (void const   *)(tosend), tmp___0, 0);
  }
#line 350
  if (tmp___1 == -1L) {
    {
#line 353
    log_printf((char *)"IRC -> Error sending data to server\n");
#line 354
    irc_reconnect();
    }
  }
#line 356
  return;
}
}
#line 369 "/home/june/collector/temp/bopm-3.1.3/src/irc.c"
void irc_send_channels(char *data  , ...) 
{ 
  va_list arglist ;
  char data2[513] ;
  char tosend[513] ;

  {
  {
#line 375
  __builtin_va_start(arglist, data);
#line 376
  vsnprintf((char */* __restrict  */)(data2), (size_t )513, (char const   */* __restrict  */)data,
            arglist);
#line 377
  __builtin_va_end(arglist);
#line 379
  snprintf((char */* __restrict  */)(tosend), (size_t )513, (char const   */* __restrict  */)"PRIVMSG %s :%s",
           IRC_CHANNELS, data2);
#line 381
  irc_send((char *)"%s", tosend);
  }
#line 382
  return;
}
}
#line 397 "/home/june/collector/temp/bopm-3.1.3/src/irc.c"
static void irc_connect(void) 
{ 
  int *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  size_t tmp___4 ;

  {
  {
#line 400
  tmp___3 = connect(IRC_FD, (struct sockaddr  const  *)((struct sockaddr *)(& IRC_SVR)),
                    (socklen_t )sizeof(IRC_SVR));
  }
#line 400
  if (tmp___3 == -1) {
    {
#line 403
    tmp___0 = __errno_location();
    }
    {
#line 405
    if (*tmp___0 == 106) {
#line 405
      goto case_106;
    }
#line 408
    if (*tmp___0 == 111) {
#line 408
      goto case_111;
    }
#line 412
    if (*tmp___0 == 110) {
#line 412
      goto case_110;
    }
#line 416
    if (*tmp___0 == 101) {
#line 416
      goto case_101;
    }
#line 419
    if (*tmp___0 == 114) {
#line 419
      goto case_114;
    }
#line 422
    goto switch_default;
    case_106: /* CIL Label */ 
#line 407
    return;
    case_111: /* CIL Label */ 
    {
#line 409
    log_printf((char *)"IRC -> connect(): Connection refused by (%s)", IRCItem->server);
    }
#line 411
    goto switch_break;
    case_110: /* CIL Label */ 
    {
#line 413
    log_printf((char *)"IRC -> connect(): Timed out connecting to (%s)", IRCItem->server);
    }
#line 415
    goto switch_break;
    case_101: /* CIL Label */ 
    {
#line 417
    log_printf((char *)"IRC -> connect(): Network unreachable");
    }
#line 418
    goto switch_break;
    case_114: /* CIL Label */ 
#line 421
    return;
    switch_default: /* CIL Label */ 
    {
#line 423
    log_printf((char *)"IRC -> connect(): Unknown error connecting to (%s)", IRCItem->server);
    }
#line 426
    if (OPT_DEBUG >= 1U) {
      {
#line 427
      tmp___1 = __errno_location();
#line 427
      tmp___2 = strerror(*tmp___1);
#line 427
      log_printf((char *)"%s", tmp___2);
      }
    }
    switch_break: /* CIL Label */ ;
    }
    {
#line 430
    irc_reconnect();
    }
#line 431
    return;
  }
  {
#line 434
  irc_send((char *)"NICK %s", IRCItem->nick);
#line 436
  tmp___4 = strlen((char const   *)IRCItem->password);
  }
#line 436
  if (tmp___4 > 0UL) {
    {
#line 437
    irc_send((char *)"PASS %s", IRCItem->password);
    }
  }
  {
#line 439
  irc_send((char *)"USER %s %s %s :%s", IRCItem->username, IRCItem->username, IRCItem->username,
           IRCItem->realname);
#line 443
  time(& IRC_LAST);
  }
#line 444
  return;
}
}
#line 456 "/home/june/collector/temp/bopm-3.1.3/src/irc.c"
static void irc_reconnect(void) 
{ 
  time_t present ;

  {
  {
#line 461
  time(& present);
  }
#line 464
  if (present - IRC_LASTRECONNECT < 30L) {
    {
#line 467
    sleep(1U);
    }
#line 468
    return;
  }
  {
#line 471
  time(& IRC_LASTRECONNECT);
  }
#line 473
  if (IRC_FD > 0) {
    {
#line 474
    close(IRC_FD);
    }
  }
  {
#line 477
  IRC_FD = 0;
#line 479
  log_printf((char *)"IRC -> Connection to (%s) failed, reconnecting.", IRCItem->server);
  }
#line 480
  return;
}
}
#line 494 "/home/june/collector/temp/bopm-3.1.3/src/irc.c"
static void irc_read(void) 
{ 
  int len ;
  char c ;
  int tmp___0 ;
  ssize_t tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;

  {
  {
#line 499
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 499
    tmp___1 = read(IRC_FD, (void *)(& c), (size_t )1);
#line 499
    len = (int )tmp___1;
    }
#line 499
    if (! (len > 0)) {
#line 499
      goto while_break;
    }
#line 501
    if ((int )c == 13) {
#line 502
      goto while_continue;
    }
#line 504
    if ((int )c == 10) {
      {
#line 507
      IRC_RAW[IRC_RAW_LEN] = (char )'\000';
#line 509
      irc_parse();
#line 511
      IRC_RAW_LEN = 0;
      }
#line 512
      goto while_break;
    }
#line 515
    if ((int )c != 13) {
#line 515
      if ((int )c != 10) {
#line 515
        if ((int )c != 0) {
#line 516
          tmp___0 = IRC_RAW_LEN;
#line 516
          IRC_RAW_LEN ++;
#line 516
          IRC_RAW[tmp___0] = c;
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 519
  if (len <= 0) {
    {
#line 519
    tmp___3 = __errno_location();
    }
#line 519
    if (*tmp___3 != 11) {
#line 521
      if (OPT_DEBUG >= 2U) {
        {
#line 522
        tmp___2 = __errno_location();
#line 522
        log_printf((char *)"irc_read -> errno=%d len=%d", *tmp___2, len);
        }
      }
      {
#line 523
      irc_reconnect();
#line 524
      IRC_RAW_LEN = 0;
      }
#line 525
      return;
    }
  }
#line 527
  return;
}
}
#line 555 "/home/june/collector/temp/bopm-3.1.3/src/irc.c"
static char *parv[17]  ;
#line 556 "/home/june/collector/temp/bopm-3.1.3/src/irc.c"
static unsigned int parc  ;
#line 557 "/home/june/collector/temp/bopm-3.1.3/src/irc.c"
static char msg[513]  ;
#line 541 "/home/june/collector/temp/bopm-3.1.3/src/irc.c"
static void irc_parse(void) 
{ 
  struct UserInfo *source_p ;
  char *pos ;
  unsigned int i ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;
  int tmp___3 ;

  {
#line 559
  parc = 1U;
#line 561
  if (IRC_RAW_LEN <= 0) {
#line 562
    return;
  }
#line 564
  if (OPT_DEBUG >= 2U) {
    {
#line 565
    log_printf((char *)"IRC READ -> %s", IRC_RAW);
    }
  }
  {
#line 567
  time(& IRC_LAST);
#line 570
  strcpy((char */* __restrict  */)(msg), (char const   */* __restrict  */)(IRC_RAW));
  }
#line 573
  if ((int )IRC_RAW[0] == 58) {
#line 574
    parv[0] = IRC_RAW + 1;
  } else {
#line 577
    parv[0] = IRCItem->server;
#line 578
    tmp___0 = parc;
#line 578
    parc ++;
#line 578
    parv[tmp___0] = IRC_RAW;
  }
#line 581
  pos = IRC_RAW;
  {
#line 583
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 583
    pos = strchr((char const   *)pos, ' ');
    }
#line 583
    if (pos) {
#line 583
      if (! (parc <= 17U)) {
#line 583
        goto while_break;
      }
    } else {
#line 583
      goto while_break;
    }
#line 587
    if ((int )*(pos + 1) == 32) {
#line 587
      if ((int )*(pos + 1) == 0) {
#line 589
        pos ++;
#line 590
        goto while_continue;
      }
    }
#line 595
    if ((int )*(pos + 1) == 58) {
#line 597
      tmp___1 = parc;
#line 597
      parc ++;
#line 597
      parv[tmp___1] = pos + 2;
#line 598
      *pos = (char )'\000';
#line 599
      goto while_break;
    }
#line 604
    tmp___2 = parc;
#line 604
    parc ++;
#line 604
    parv[tmp___2] = pos + 1;
#line 605
    *pos = (char )'\000';
#line 606
    pos ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 611
  source_p = userinfo_create(parv[0]);
#line 616
  i = 0U;
  }
  {
#line 616
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 616
    if (! ((unsigned long )i < sizeof(COMMAND_TABLE) / sizeof(struct CommandHash ))) {
#line 616
      goto while_break___0;
    }
    {
#line 617
    tmp___3 = strcasecmp((char const   *)COMMAND_TABLE[i].command, (char const   *)parv[1]);
    }
#line 617
    if (tmp___3 == 0) {
      {
#line 619
      (*(COMMAND_TABLE[i].handler))(parv, parc, msg, source_p);
      }
#line 620
      goto while_break___0;
    }
#line 616
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 623
  userinfo_free(source_p);
  }
#line 624
  return;
}
}
#line 638 "/home/june/collector/temp/bopm-3.1.3/src/irc.c"
void irc_timer(void) 
{ 
  time_t present ;
  time_t delta ;

  {
  {
#line 642
  time(& present);
#line 644
  delta = present - IRC_LAST;
  }
#line 647
  if (delta >= 900L) {
    {
#line 649
    log_printf((char *)"IRC -> Timeout awaiting data from server.");
#line 650
    irc_reconnect();
#line 652
    time(& IRC_LAST);
    }
  } else
#line 654
  if (delta >= 450L) {
    {
#line 661
    irc_send((char *)"PING :BOPM");
    }
  }
#line 664
  return;
}
}
#line 680 "/home/june/collector/temp/bopm-3.1.3/src/irc.c"
static struct ChannelConf *get_channel(char const   *channel ) 
{ 
  node_t *node ;
  struct ChannelConf *item ;
  int tmp___0 ;

  {
#line 685
  node = (IRCItem->channels)->head;
  {
#line 685
  while (1) {
    while_continue: /* CIL Label */ ;
#line 685
    if (! ((unsigned long )node != (unsigned long )((void *)0))) {
#line 685
      goto while_break;
    }
    {
#line 687
    item = (struct ChannelConf *)node->data;
#line 689
    tmp___0 = strcasecmp((char const   *)item->name, channel);
    }
#line 689
    if (tmp___0 == 0) {
#line 690
      return (item);
    }
#line 685
    node = node->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 693
  return ((struct ChannelConf *)((void *)0));
}
}
#line 710 "/home/june/collector/temp/bopm-3.1.3/src/irc.c"
static struct UserInfo *userinfo_create(char *source ) 
{ 
  struct UserInfo *ret ;
  char *nick ;
  char *username ;
  char *hostname ;
  char *tmp___0 ;
  int i ;
  int len ;
  size_t tmp___1 ;
  void *tmp___2 ;

  {
  {
#line 721
  hostname = (char *)((void *)0);
#line 721
  username = hostname;
#line 721
  nick = username;
#line 722
  tmp___0 = DupString((char const   *)source);
#line 723
  tmp___1 = strlen((char const   *)tmp___0);
#line 723
  len = (int )tmp___1;
#line 725
  nick = tmp___0;
#line 727
  i = 0;
  }
  {
#line 727
  while (1) {
    while_continue: /* CIL Label */ ;
#line 727
    if (! (i < len)) {
#line 727
      goto while_break;
    }
#line 729
    if ((int )*(tmp___0 + i) == 33) {
#line 731
      *(tmp___0 + i) = (char )'\000';
#line 732
      username = (tmp___0 + i) + 1;
    }
#line 734
    if ((int )*(tmp___0 + i) == 64) {
#line 736
      *(tmp___0 + i) = (char )'\000';
#line 737
      hostname = (tmp___0 + i) + 1;
    }
#line 727
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 741
  if ((unsigned long )nick == (unsigned long )((void *)0)) {
    {
#line 743
    _MyFree((void **)(& tmp___0));
    }
#line 744
    return ((struct UserInfo *)((void *)0));
  } else
#line 741
  if ((unsigned long )username == (unsigned long )((void *)0)) {
    {
#line 743
    _MyFree((void **)(& tmp___0));
    }
#line 744
    return ((struct UserInfo *)((void *)0));
  } else
#line 741
  if ((unsigned long )hostname == (unsigned long )((void *)0)) {
    {
#line 743
    _MyFree((void **)(& tmp___0));
    }
#line 744
    return ((struct UserInfo *)((void *)0));
  }
  {
#line 747
  tmp___2 = MyMalloc(sizeof(*ret));
#line 747
  ret = (struct UserInfo *)tmp___2;
#line 749
  ret->irc_nick = DupString((char const   *)nick);
#line 750
  ret->irc_username = DupString((char const   *)username);
#line 751
  ret->irc_hostname = DupString((char const   *)hostname);
#line 753
  _MyFree((void **)(& tmp___0));
  }
#line 755
  return (ret);
}
}
#line 771 "/home/june/collector/temp/bopm-3.1.3/src/irc.c"
static void userinfo_free(struct UserInfo *source_p ) 
{ 


  {
#line 773
  if ((unsigned long )source_p == (unsigned long )((void *)0)) {
#line 774
    return;
  }
  {
#line 776
  _MyFree((void **)(& source_p->irc_nick));
#line 777
  _MyFree((void **)(& source_p->irc_username));
#line 778
  _MyFree((void **)(& source_p->irc_hostname));
#line 779
  _MyFree((void **)(& source_p));
  }
#line 780
  return;
}
}
#line 797 "/home/june/collector/temp/bopm-3.1.3/src/irc.c"
static void m_perform(char **parv___0 , unsigned int parc___0 , char *msg___0 , struct UserInfo *notused ) 
{ 
  node_t *node ;
  struct ChannelConf *channel ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;

  {
  {
#line 807
  log_printf((char *)"IRC -> Connected to %s:%d", IRCItem->server, IRCItem->port);
#line 810
  tmp___0 = strlen((char const   *)IRCItem->nickserv);
  }
#line 810
  if (tmp___0) {
    {
#line 811
    irc_send((char *)"%s", IRCItem->nickserv);
    }
  }
  {
#line 814
  irc_send((char *)"OPER %s", IRCItem->oper);
#line 817
  irc_send((char *)"MODE %s %s", IRCItem->nick, IRCItem->mode);
#line 820
  irc_send((char *)"AWAY :%s", IRCItem->away);
#line 823
  node = (IRCItem->performs)->head;
  }
  {
#line 823
  while (1) {
    while_continue: /* CIL Label */ ;
#line 823
    if (! ((unsigned long )node != (unsigned long )((void *)0))) {
#line 823
      goto while_break;
    }
    {
#line 824
    irc_send((char *)"%s", (char *)node->data);
#line 823
    node = node->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 827
  node = (IRCItem->channels)->head;
  {
#line 827
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 827
    if (! ((unsigned long )node != (unsigned long )((void *)0))) {
#line 827
      goto while_break___0;
    }
    {
#line 829
    channel = (struct ChannelConf *)node->data;
#line 831
    tmp___1 = strlen((char const   *)channel->name);
    }
#line 831
    if (tmp___1 == 0UL) {
#line 832
      goto __Cont;
    }
    {
#line 834
    tmp___2 = strlen((char const   *)channel->key);
    }
#line 834
    if (tmp___2 > 0UL) {
      {
#line 835
      irc_send((char *)"JOIN %s %s", channel->name, channel->key);
      }
    } else {
      {
#line 837
      irc_send((char *)"JOIN %s", channel->name);
      }
    }
    __Cont: /* CIL Label */ 
#line 827
    node = node->next;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 839
  return;
}
}
#line 851 "/home/june/collector/temp/bopm-3.1.3/src/irc.c"
static void m_ping(char **parv___0 , unsigned int parc___0 , char *msg___0 , struct UserInfo *source_p ) 
{ 


  {
#line 856
  if (parc___0 < 3U) {
#line 857
    return;
  }
#line 859
  if (OPT_DEBUG >= 2U) {
    {
#line 860
    log_printf((char *)"IRC -> PING? PONG!");
    }
  }
  {
#line 862
  irc_send((char *)"PONG %s", *(parv___0 + 2));
  }
#line 863
  return;
}
}
#line 879 "/home/june/collector/temp/bopm-3.1.3/src/irc.c"
static void m_invite(char **parv___0 , unsigned int parc___0 , char *msg___0 , struct UserInfo *source_p ) 
{ 
  struct ChannelConf *channel ;

  {
#line 886
  if (parc___0 < 4U) {
#line 887
    return;
  }
  {
#line 889
  log_printf((char *)"IRC -> Invited to %s by %s", *(parv___0 + 3), *(parv___0 + 0));
#line 891
  channel = get_channel((char const   *)*(parv___0 + 3));
  }
#line 891
  if ((unsigned long )channel == (unsigned long )((void *)0)) {
#line 892
    return;
  }
  {
#line 894
  irc_send((char *)"JOIN %s %s", channel->name, channel->key);
  }
#line 895
  return;
}
}
#line 912 "/home/june/collector/temp/bopm-3.1.3/src/irc.c"
static void m_privmsg(char **parv___0 , unsigned int parc___0 , char *msg___0 , struct UserInfo *source_p ) 
{ 
  struct ChannelConf *channel ;
  size_t nick_len ;
  size_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 917
  if ((unsigned long )source_p == (unsigned long )((void *)0)) {
#line 918
    return;
  }
#line 920
  if (parc___0 < 4U) {
#line 921
    return;
  }
#line 924
  if ((int )*(*(parv___0 + 3) + 0) == 1) {
    {
#line 925
    m_ctcp(parv___0, parc___0, msg___0, source_p);
    }
  }
#line 928
  if ((int )*(*(parv___0 + 2) + 0) != 35) {
#line 928
    if ((int )*(*(parv___0 + 2) + 0) != 38) {
#line 929
      return;
    }
  }
  {
#line 932
  channel = get_channel((char const   *)*(parv___0 + 2));
  }
#line 932
  if ((unsigned long )channel == (unsigned long )((void *)0)) {
#line 933
    return;
  }
  {
#line 936
  nick_len = strcspn((char const   *)*(parv___0 + 3), " :,");
  }
#line 937
  if (nick_len < 3UL) {
    {
#line 937
    tmp___0 = strlen((char const   *)IRCItem->nick);
    }
#line 937
    if (tmp___0 >= 3UL) {
#line 938
      nick_len = (size_t )3;
    }
  }
  {
#line 941
  tmp___1 = strncasecmp((char const   *)*(parv___0 + 3), (char const   *)IRCItem->nick,
                        nick_len);
  }
#line 941
  if (tmp___1 == 0) {
    {
#line 945
    command_parse(*(parv___0 + 3), msg___0, channel, source_p);
    }
  } else {
    {
#line 941
    tmp___2 = strncasecmp((char const   *)*(parv___0 + 3), "!all", (size_t )4);
    }
#line 941
    if (tmp___2 == 0) {
      {
#line 945
      command_parse(*(parv___0 + 3), msg___0, channel, source_p);
      }
    }
  }
#line 947
  return;
}
}
#line 964 "/home/june/collector/temp/bopm-3.1.3/src/irc.c"
static void m_ctcp(char **parv___0 , unsigned int parc___0 , char *msg___0 , struct UserInfo *source_p ) 
{ 
  int tmp___0 ;

  {
  {
#line 969
  tmp___0 = strncasecmp((char const   *)*(parv___0 + 3), "\001VERSION\001", (size_t )9);
  }
#line 969
  if (tmp___0 == 0) {
    {
#line 971
    irc_send((char *)"NOTICE %s :\001VERSION Blitzed Open Proxy Monitor %s\001", source_p->irc_nick,
             "3.1.3");
    }
  }
#line 974
  return;
}
}
#line 997 "/home/june/collector/temp/bopm-3.1.3/src/irc.c"
static regex_t *preg  =    (regex_t *)((void *)0);
#line 1000 "/home/june/collector/temp/bopm-3.1.3/src/irc.c"
static char errmsg[256]  ;
#line 993 "/home/june/collector/temp/bopm-3.1.3/src/irc.c"
static void m_notice(char **parv___0 , unsigned int parc___0 , char *msg___0 , struct UserInfo *source_p ) 
{ 
  regmatch_t pmatch[5] ;
  int errnum ;
  int i ;
  char *user[4] ;
  void *tmp___0 ;
  int tmp___1 ;

  {
#line 1005
  if (parc___0 < 4U) {
#line 1006
    return;
  }
#line 1009
  if ((unsigned long )source_p != (unsigned long )((void *)0)) {
#line 1010
    return;
  }
#line 1013
  if ((unsigned long )preg == (unsigned long )((void *)0)) {
    {
#line 1015
    tmp___0 = MyMalloc(sizeof(*preg));
#line 1015
    preg = (regex_t *)tmp___0;
#line 1017
    errnum = regcomp((regex_t */* __restrict  */)preg, (char const   */* __restrict  */)IRCItem->connregex,
                     (1 << 1) | 1);
    }
#line 1017
    if (errnum != 0) {
      {
#line 1020
      regerror(errnum, (regex_t const   */* __restrict  */)preg, (char */* __restrict  */)(errmsg),
               (size_t )256);
#line 1021
      log_printf((char *)"IRC REGEX -> Error when compiling regular expression");
#line 1022
      log_printf((char *)"IRC REGEX -> %s", errmsg);
#line 1024
      _MyFree((void **)(& preg));
#line 1025
      preg = (regex_t *)((void *)0);
      }
#line 1026
      return;
    }
  }
  {
#line 1031
  tmp___1 = regexec((regex_t const   */* __restrict  */)preg, (char const   */* __restrict  */)*(parv___0 + 3),
                    (size_t )5, (regmatch_t */* __restrict  */)(pmatch), 0);
  }
#line 1031
  if (tmp___1 != 0) {
#line 1032
    return;
  }
#line 1034
  if (OPT_DEBUG > 0U) {
    {
#line 1035
    log_printf((char *)"IRC REGEX -> Regular expression caught connection notice. Parsing.");
    }
  }
#line 1037
  if (pmatch[4].rm_so == -1) {
    {
#line 1039
    log_printf((char *)"IRC REGEX -> pmatch[4].rm_so is -1 while parsing??? Aborting.");
    }
#line 1040
    return;
  }
#line 1053
  i = 0;
  {
#line 1053
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1053
    if (! (i < 4)) {
#line 1053
      goto while_break;
    }
#line 1055
    user[i] = *(parv___0 + 3) + pmatch[i + 1].rm_so;
#line 1056
    *(*(parv___0 + 3) + pmatch[i + 1].rm_eo) = (char )'\000';
#line 1053
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1059
  if (OPT_DEBUG > 0U) {
    {
#line 1060
    log_printf((char *)"IRC REGEX -> Parsed %s!%s@%s [%s] from connection notice.",
               user[0], user[1], user[2], user[3]);
    }
  }
  {
#line 1068
  scan_connect(user, msg___0);
#line 1070
  stats_connect();
  }
#line 1071
  return;
}
}
#line 1086 "/home/june/collector/temp/bopm-3.1.3/src/irc.c"
static void m_userhost(char **parv___0 , unsigned int parc___0 , char *msg___0 , struct UserInfo *source_p ) 
{ 


  {
#line 1092
  if (parc___0 < 4U) {
#line 1093
    return;
  }
  {
#line 1095
  command_userhost(*(parv___0 + 3));
  }
#line 1096
  return;
}
}
#line 1108 "/home/june/collector/temp/bopm-3.1.3/src/irc.c"
static void m_cannot_join(char **parv___0 , unsigned int parc___0 , char *msg___0 ,
                          struct UserInfo *source_p ) 
{ 
  struct ChannelConf *channel ;
  size_t tmp___0 ;

  {
#line 1116
  if (parc___0 < 5U) {
#line 1117
    return;
  }
  {
#line 1120
  channel = get_channel((char const   *)*(parv___0 + 3));
  }
#line 1120
  if ((unsigned long )channel == (unsigned long )((void *)0)) {
#line 1121
    return;
  }
  {
#line 1123
  tmp___0 = strlen((char const   *)channel->invite);
  }
#line 1123
  if (tmp___0 == 0UL) {
#line 1124
    return;
  }
  {
#line 1126
  irc_send((char *)"%s", channel->invite);
  }
#line 1127
  return;
}
}
#line 1140 "/home/june/collector/temp/bopm-3.1.3/src/irc.c"
static void m_kill(char **parv___0 , unsigned int parc___0 , char *msg___0 , struct UserInfo *source_p ) 
{ 


  {
  {
#line 1148
  main_restart();
  }
#line 1149
  return;
}
}
/* compiler builtin: 
   void *__builtin_memcpy(void * , void const   * , unsigned long  ) ;  */
#line 144 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 57 "/home/june/collector/temp/bopm-3.1.3/src/list.h"
node_t *node_create(void *data ) ;
#line 58
list_t *list_create(void) ;
#line 60
node_t *list_add(list_t *list , node_t *node ) ;
#line 8 "/home/june/collector/temp/bopm-3.1.3/src/config.h"
int yylex(void) ;
#line 13
void yyerror(char const   *str ) ;
#line 127
struct OpmConf *OpmItem ;
#line 128
struct ExemptConf *ExemptItem ;
#line 129
list_t *UserItemList ;
#line 130
list_t *ScannerItemList ;
#line 31 "config-parser.y"
int yydebug  =    0;
#line 32 "config-parser.y"
void *tmp  ;
#line 454 "config-parser.c"
static yytype_uint8 const   yytranslate[304]  = 
#line 454 "config-parser.c"
  {      (yytype_uint8 const   )0,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )53,      (yytype_uint8 const   )51, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )52,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )49, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )50,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )2,      (yytype_uint8 const   )3,      (yytype_uint8 const   )4, 
        (yytype_uint8 const   )5,      (yytype_uint8 const   )6,      (yytype_uint8 const   )7,      (yytype_uint8 const   )8, 
        (yytype_uint8 const   )9,      (yytype_uint8 const   )10,      (yytype_uint8 const   )11,      (yytype_uint8 const   )12, 
        (yytype_uint8 const   )13,      (yytype_uint8 const   )14,      (yytype_uint8 const   )15,      (yytype_uint8 const   )16, 
        (yytype_uint8 const   )17,      (yytype_uint8 const   )18,      (yytype_uint8 const   )19,      (yytype_uint8 const   )20, 
        (yytype_uint8 const   )21,      (yytype_uint8 const   )22,      (yytype_uint8 const   )23,      (yytype_uint8 const   )24, 
        (yytype_uint8 const   )25,      (yytype_uint8 const   )26,      (yytype_uint8 const   )27,      (yytype_uint8 const   )28, 
        (yytype_uint8 const   )29,      (yytype_uint8 const   )30,      (yytype_uint8 const   )31,      (yytype_uint8 const   )32, 
        (yytype_uint8 const   )33,      (yytype_uint8 const   )34,      (yytype_uint8 const   )35,      (yytype_uint8 const   )36, 
        (yytype_uint8 const   )37,      (yytype_uint8 const   )38,      (yytype_uint8 const   )39,      (yytype_uint8 const   )40, 
        (yytype_uint8 const   )41,      (yytype_uint8 const   )42,      (yytype_uint8 const   )43,      (yytype_uint8 const   )44, 
        (yytype_uint8 const   )45,      (yytype_uint8 const   )46,      (yytype_uint8 const   )47,      (yytype_uint8 const   )48};
#line 628 "config-parser.c"
static yytype_uint8 const   yyr1[137]  = 
#line 628
  {      (yytype_uint8 const   )0,      (yytype_uint8 const   )54,      (yytype_uint8 const   )55,      (yytype_uint8 const   )55, 
        (yytype_uint8 const   )56,      (yytype_uint8 const   )56,      (yytype_uint8 const   )56,      (yytype_uint8 const   )56, 
        (yytype_uint8 const   )56,      (yytype_uint8 const   )56,      (yytype_uint8 const   )57,      (yytype_uint8 const   )58, 
        (yytype_uint8 const   )58,      (yytype_uint8 const   )58,      (yytype_uint8 const   )59,      (yytype_uint8 const   )59, 
        (yytype_uint8 const   )59,      (yytype_uint8 const   )59,      (yytype_uint8 const   )59,      (yytype_uint8 const   )60, 
        (yytype_uint8 const   )61,      (yytype_uint8 const   )62,      (yytype_uint8 const   )63,      (yytype_uint8 const   )64, 
        (yytype_uint8 const   )65,      (yytype_uint8 const   )65,      (yytype_uint8 const   )66,      (yytype_uint8 const   )66, 
        (yytype_uint8 const   )66,      (yytype_uint8 const   )66,      (yytype_uint8 const   )66,      (yytype_uint8 const   )66, 
        (yytype_uint8 const   )66,      (yytype_uint8 const   )66,      (yytype_uint8 const   )66,      (yytype_uint8 const   )66, 
        (yytype_uint8 const   )66,      (yytype_uint8 const   )66,      (yytype_uint8 const   )66,      (yytype_uint8 const   )66, 
        (yytype_uint8 const   )66,      (yytype_uint8 const   )66,      (yytype_uint8 const   )67,      (yytype_uint8 const   )68, 
        (yytype_uint8 const   )69,      (yytype_uint8 const   )70,      (yytype_uint8 const   )71,      (yytype_uint8 const   )72, 
        (yytype_uint8 const   )73,      (yytype_uint8 const   )74,      (yytype_uint8 const   )75,      (yytype_uint8 const   )76, 
        (yytype_uint8 const   )77,      (yytype_uint8 const   )78,      (yytype_uint8 const   )79,      (yytype_uint8 const   )80, 
        (yytype_uint8 const   )82,      (yytype_uint8 const   )81,      (yytype_uint8 const   )83,      (yytype_uint8 const   )83, 
        (yytype_uint8 const   )84,      (yytype_uint8 const   )84,      (yytype_uint8 const   )84,      (yytype_uint8 const   )85, 
        (yytype_uint8 const   )86,      (yytype_uint8 const   )87,      (yytype_uint8 const   )89,      (yytype_uint8 const   )88, 
        (yytype_uint8 const   )90,      (yytype_uint8 const   )90,      (yytype_uint8 const   )91,      (yytype_uint8 const   )91, 
        (yytype_uint8 const   )91,      (yytype_uint8 const   )92,      (yytype_uint8 const   )93,      (yytype_uint8 const   )95, 
        (yytype_uint8 const   )94,      (yytype_uint8 const   )96,      (yytype_uint8 const   )96,      (yytype_uint8 const   )97, 
        (yytype_uint8 const   )97,      (yytype_uint8 const   )97,      (yytype_uint8 const   )97,      (yytype_uint8 const   )97, 
        (yytype_uint8 const   )97,      (yytype_uint8 const   )97,      (yytype_uint8 const   )97,      (yytype_uint8 const   )97, 
        (yytype_uint8 const   )97,      (yytype_uint8 const   )98,      (yytype_uint8 const   )99,      (yytype_uint8 const   )100, 
        (yytype_uint8 const   )101,      (yytype_uint8 const   )102,      (yytype_uint8 const   )103,      (yytype_uint8 const   )104, 
        (yytype_uint8 const   )105,      (yytype_uint8 const   )106,      (yytype_uint8 const   )107,      (yytype_uint8 const   )108, 
        (yytype_uint8 const   )108,      (yytype_uint8 const   )108,      (yytype_uint8 const   )109,      (yytype_uint8 const   )109, 
        (yytype_uint8 const   )109,      (yytype_uint8 const   )109,      (yytype_uint8 const   )109,      (yytype_uint8 const   )110, 
        (yytype_uint8 const   )111,      (yytype_uint8 const   )112,      (yytype_uint8 const   )114,      (yytype_uint8 const   )113, 
        (yytype_uint8 const   )115,      (yytype_uint8 const   )115,      (yytype_uint8 const   )115,      (yytype_uint8 const   )116, 
        (yytype_uint8 const   )116,      (yytype_uint8 const   )116,      (yytype_uint8 const   )116,      (yytype_uint8 const   )116, 
        (yytype_uint8 const   )116,      (yytype_uint8 const   )117,      (yytype_uint8 const   )118,      (yytype_uint8 const   )119, 
        (yytype_uint8 const   )120,      (yytype_uint8 const   )121,      (yytype_uint8 const   )122,      (yytype_uint8 const   )122, 
        (yytype_uint8 const   )122,      (yytype_uint8 const   )123,      (yytype_uint8 const   )124,      (yytype_uint8 const   )125, 
        (yytype_uint8 const   )125,      (yytype_uint8 const   )125,      (yytype_uint8 const   )126,      (yytype_uint8 const   )126, 
        (yytype_uint8 const   )127};
#line 647 "config-parser.c"
static yytype_uint8 const   yyr2[137]  = 
#line 647
  {      (yytype_uint8 const   )0,      (yytype_uint8 const   )2,      (yytype_uint8 const   )0,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )5,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )4, 
        (yytype_uint8 const   )4,      (yytype_uint8 const   )4,      (yytype_uint8 const   )4,      (yytype_uint8 const   )5, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )4,      (yytype_uint8 const   )4, 
        (yytype_uint8 const   )4,      (yytype_uint8 const   )4,      (yytype_uint8 const   )4,      (yytype_uint8 const   )4, 
        (yytype_uint8 const   )4,      (yytype_uint8 const   )4,      (yytype_uint8 const   )4,      (yytype_uint8 const   )4, 
        (yytype_uint8 const   )4,      (yytype_uint8 const   )4,      (yytype_uint8 const   )4,      (yytype_uint8 const   )4, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )6,      (yytype_uint8 const   )2,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )4, 
        (yytype_uint8 const   )4,      (yytype_uint8 const   )4,      (yytype_uint8 const   )0,      (yytype_uint8 const   )6, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )4,      (yytype_uint8 const   )4,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )6,      (yytype_uint8 const   )2,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )4,      (yytype_uint8 const   )4,      (yytype_uint8 const   )4, 
        (yytype_uint8 const   )4,      (yytype_uint8 const   )4,      (yytype_uint8 const   )4,      (yytype_uint8 const   )4, 
        (yytype_uint8 const   )4,      (yytype_uint8 const   )6,      (yytype_uint8 const   )5,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )4, 
        (yytype_uint8 const   )4,      (yytype_uint8 const   )4,      (yytype_uint8 const   )0,      (yytype_uint8 const   )6, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )2,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )4,      (yytype_uint8 const   )4,      (yytype_uint8 const   )4, 
        (yytype_uint8 const   )4,      (yytype_uint8 const   )5,      (yytype_uint8 const   )0,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )4,      (yytype_uint8 const   )5,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )4};
#line 668 "config-parser.c"
static yytype_uint8 const   yydefact[293]  = 
#line 668
  {      (yytype_uint8 const   )2,      (yytype_uint8 const   )66,      (yytype_uint8 const   )1,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )3, 
        (yytype_uint8 const   )5,      (yytype_uint8 const   )4,      (yytype_uint8 const   )7,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )8,      (yytype_uint8 const   )0,      (yytype_uint8 const   )6,      (yytype_uint8 const   )9, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )135,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )133,      (yytype_uint8 const   )134,      (yytype_uint8 const   )41, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )25, 
        (yytype_uint8 const   )26,      (yytype_uint8 const   )28,      (yytype_uint8 const   )31,      (yytype_uint8 const   )29, 
        (yytype_uint8 const   )30,      (yytype_uint8 const   )32,      (yytype_uint8 const   )33,      (yytype_uint8 const   )39, 
        (yytype_uint8 const   )34,      (yytype_uint8 const   )35,      (yytype_uint8 const   )36,      (yytype_uint8 const   )37, 
        (yytype_uint8 const   )38,      (yytype_uint8 const   )27,      (yytype_uint8 const   )40,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )106,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )101,      (yytype_uint8 const   )102,      (yytype_uint8 const   )103, 
        (yytype_uint8 const   )104,      (yytype_uint8 const   )105,      (yytype_uint8 const   )0,      (yytype_uint8 const   )18, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )13,      (yytype_uint8 const   )14,      (yytype_uint8 const   )15, 
        (yytype_uint8 const   )16,      (yytype_uint8 const   )17,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )132,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )24,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )100,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )12, 
        (yytype_uint8 const   )72,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )69,      (yytype_uint8 const   )70,      (yytype_uint8 const   )71,      (yytype_uint8 const   )88, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )78,      (yytype_uint8 const   )79, 
        (yytype_uint8 const   )80,      (yytype_uint8 const   )82,      (yytype_uint8 const   )84,      (yytype_uint8 const   )81, 
        (yytype_uint8 const   )83,      (yytype_uint8 const   )86,      (yytype_uint8 const   )87,      (yytype_uint8 const   )85, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )130,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )23,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )98,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )10, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )68, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )77,      (yytype_uint8 const   )136, 
        (yytype_uint8 const   )42,      (yytype_uint8 const   )55,      (yytype_uint8 const   )43,      (yytype_uint8 const   )44, 
        (yytype_uint8 const   )45,      (yytype_uint8 const   )46,      (yytype_uint8 const   )47,      (yytype_uint8 const   )48, 
        (yytype_uint8 const   )49,      (yytype_uint8 const   )50,      (yytype_uint8 const   )51,      (yytype_uint8 const   )52, 
        (yytype_uint8 const   )53,      (yytype_uint8 const   )54,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )59,      (yytype_uint8 const   )60, 
        (yytype_uint8 const   )61,      (yytype_uint8 const   )62,      (yytype_uint8 const   )107,      (yytype_uint8 const   )108, 
        (yytype_uint8 const   )109,      (yytype_uint8 const   )120,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )114,      (yytype_uint8 const   )115,      (yytype_uint8 const   )117,      (yytype_uint8 const   )116, 
        (yytype_uint8 const   )118,      (yytype_uint8 const   )119,      (yytype_uint8 const   )21,      (yytype_uint8 const   )19, 
        (yytype_uint8 const   )20,      (yytype_uint8 const   )22,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )67,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )76,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )58, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )126, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )113,      (yytype_uint8 const   )73, 
        (yytype_uint8 const   )74,      (yytype_uint8 const   )93,      (yytype_uint8 const   )96,      (yytype_uint8 const   )89, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )91,      (yytype_uint8 const   )94,      (yytype_uint8 const   )92, 
        (yytype_uint8 const   )95,      (yytype_uint8 const   )90,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )57,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )128, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )111,      (yytype_uint8 const   )0,      (yytype_uint8 const   )65, 
        (yytype_uint8 const   )64,      (yytype_uint8 const   )63,      (yytype_uint8 const   )124,      (yytype_uint8 const   )122, 
        (yytype_uint8 const   )121,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )127, 
        (yytype_uint8 const   )123,      (yytype_uint8 const   )97,      (yytype_uint8 const   )0,      (yytype_uint8 const   )125, 
        (yytype_uint8 const   )129};
#line 703 "config-parser.c"
static yytype_int16 const   yydefgoto[74]  = 
#line 703
  {      (yytype_int16 const   )-1,      (yytype_int16 const   )1,      (yytype_int16 const   )7,      (yytype_int16 const   )8, 
        (yytype_int16 const   )76,      (yytype_int16 const   )77,      (yytype_int16 const   )78,      (yytype_int16 const   )79, 
        (yytype_int16 const   )80,      (yytype_int16 const   )81,      (yytype_int16 const   )9,      (yytype_int16 const   )42, 
        (yytype_int16 const   )43,      (yytype_int16 const   )44,      (yytype_int16 const   )45,      (yytype_int16 const   )46, 
        (yytype_int16 const   )47,      (yytype_int16 const   )48,      (yytype_int16 const   )49,      (yytype_int16 const   )50, 
        (yytype_int16 const   )51,      (yytype_int16 const   )52,      (yytype_int16 const   )53,      (yytype_int16 const   )54, 
        (yytype_int16 const   )55,      (yytype_int16 const   )56,      (yytype_int16 const   )57,      (yytype_int16 const   )58, 
        (yytype_int16 const   )59,      (yytype_int16 const   )205,      (yytype_int16 const   )206,      (yytype_int16 const   )207, 
        (yytype_int16 const   )208,      (yytype_int16 const   )209,      (yytype_int16 const   )10,      (yytype_int16 const   )11, 
        (yytype_int16 const   )119,      (yytype_int16 const   )120,      (yytype_int16 const   )121,      (yytype_int16 const   )122, 
        (yytype_int16 const   )12,      (yytype_int16 const   )13,      (yytype_int16 const   )133,      (yytype_int16 const   )134, 
        (yytype_int16 const   )135,      (yytype_int16 const   )136,      (yytype_int16 const   )137,      (yytype_int16 const   )138, 
        (yytype_int16 const   )139,      (yytype_int16 const   )140,      (yytype_int16 const   )141,      (yytype_int16 const   )142, 
        (yytype_int16 const   )143,      (yytype_int16 const   )14,      (yytype_int16 const   )64,      (yytype_int16 const   )65, 
        (yytype_int16 const   )66,      (yytype_int16 const   )67,      (yytype_int16 const   )68,      (yytype_int16 const   )69, 
        (yytype_int16 const   )70,      (yytype_int16 const   )219,      (yytype_int16 const   )220,      (yytype_int16 const   )221, 
        (yytype_int16 const   )222,      (yytype_int16 const   )223,      (yytype_int16 const   )224,      (yytype_int16 const   )225, 
        (yytype_int16 const   )274,      (yytype_int16 const   )275,      (yytype_int16 const   )15,      (yytype_int16 const   )24, 
        (yytype_int16 const   )25,      (yytype_int16 const   )26};
#line 718 "config-parser.c"
static yytype_int16 const   yypact[293]  = 
#line 718
  {      (yytype_int16 const   )-91,      (yytype_int16 const   )132,      (yytype_int16 const   )-91,      (yytype_int16 const   )-40, 
        (yytype_int16 const   )-39,      (yytype_int16 const   )-34,      (yytype_int16 const   )-30,      (yytype_int16 const   )-91, 
        (yytype_int16 const   )-91,      (yytype_int16 const   )-91,      (yytype_int16 const   )-91,      (yytype_int16 const   )-14, 
        (yytype_int16 const   )-91,      (yytype_int16 const   )-3,      (yytype_int16 const   )-91,      (yytype_int16 const   )-91, 
        (yytype_int16 const   )24,      (yytype_int16 const   )107,      (yytype_int16 const   )2,      (yytype_int16 const   )59, 
        (yytype_int16 const   )-7,      (yytype_int16 const   )-5,      (yytype_int16 const   )-91,      (yytype_int16 const   )-17, 
        (yytype_int16 const   )29,      (yytype_int16 const   )-91,      (yytype_int16 const   )-91,      (yytype_int16 const   )-91, 
        (yytype_int16 const   )-4,      (yytype_int16 const   )9,      (yytype_int16 const   )11,      (yytype_int16 const   )19, 
        (yytype_int16 const   )30,      (yytype_int16 const   )35,      (yytype_int16 const   )38,      (yytype_int16 const   )43, 
        (yytype_int16 const   )44,      (yytype_int16 const   )51,      (yytype_int16 const   )53,      (yytype_int16 const   )55, 
        (yytype_int16 const   )63,      (yytype_int16 const   )66,      (yytype_int16 const   )-1,      (yytype_int16 const   )-91, 
        (yytype_int16 const   )-91,      (yytype_int16 const   )-91,      (yytype_int16 const   )-91,      (yytype_int16 const   )-91, 
        (yytype_int16 const   )-91,      (yytype_int16 const   )-91,      (yytype_int16 const   )-91,      (yytype_int16 const   )-91, 
        (yytype_int16 const   )-91,      (yytype_int16 const   )-91,      (yytype_int16 const   )-91,      (yytype_int16 const   )-91, 
        (yytype_int16 const   )-91,      (yytype_int16 const   )-91,      (yytype_int16 const   )-91,      (yytype_int16 const   )69, 
        (yytype_int16 const   )-91,      (yytype_int16 const   )68,      (yytype_int16 const   )71,      (yytype_int16 const   )72, 
        (yytype_int16 const   )67,      (yytype_int16 const   )-91,      (yytype_int16 const   )-91,      (yytype_int16 const   )-91, 
        (yytype_int16 const   )-91,      (yytype_int16 const   )-91,      (yytype_int16 const   )86,      (yytype_int16 const   )-91, 
        (yytype_int16 const   )76,      (yytype_int16 const   )81,      (yytype_int16 const   )87,      (yytype_int16 const   )89, 
        (yytype_int16 const   )77,      (yytype_int16 const   )-91,      (yytype_int16 const   )-91,      (yytype_int16 const   )-91, 
        (yytype_int16 const   )-91,      (yytype_int16 const   )-91,      (yytype_int16 const   )80,      (yytype_int16 const   )124, 
        (yytype_int16 const   )54,      (yytype_int16 const   )60,      (yytype_int16 const   )-91,      (yytype_int16 const   )73, 
        (yytype_int16 const   )90,      (yytype_int16 const   )99,      (yytype_int16 const   )100,      (yytype_int16 const   )101, 
        (yytype_int16 const   )102,      (yytype_int16 const   )104,      (yytype_int16 const   )106,      (yytype_int16 const   )108, 
        (yytype_int16 const   )112,      (yytype_int16 const   )113,      (yytype_int16 const   )114,      (yytype_int16 const   )119, 
        (yytype_int16 const   )121,      (yytype_int16 const   )109,      (yytype_int16 const   )-91,      (yytype_int16 const   )52, 
        (yytype_int16 const   )123,      (yytype_int16 const   )125,      (yytype_int16 const   )126,      (yytype_int16 const   )127, 
        (yytype_int16 const   )-91,      (yytype_int16 const   )70,      (yytype_int16 const   )128,      (yytype_int16 const   )129, 
        (yytype_int16 const   )131,      (yytype_int16 const   )133,      (yytype_int16 const   )134,      (yytype_int16 const   )-91, 
        (yytype_int16 const   )-91,      (yytype_int16 const   )120,      (yytype_int16 const   )130,      (yytype_int16 const   )23, 
        (yytype_int16 const   )-91,      (yytype_int16 const   )-91,      (yytype_int16 const   )-91,      (yytype_int16 const   )-91, 
        (yytype_int16 const   )135,      (yytype_int16 const   )136,      (yytype_int16 const   )137,      (yytype_int16 const   )138, 
        (yytype_int16 const   )139,      (yytype_int16 const   )140,      (yytype_int16 const   )141,      (yytype_int16 const   )142, 
        (yytype_int16 const   )143,      (yytype_int16 const   )16,      (yytype_int16 const   )-91,      (yytype_int16 const   )-91, 
        (yytype_int16 const   )-91,      (yytype_int16 const   )-91,      (yytype_int16 const   )-91,      (yytype_int16 const   )-91, 
        (yytype_int16 const   )-91,      (yytype_int16 const   )-91,      (yytype_int16 const   )-91,      (yytype_int16 const   )-91, 
        (yytype_int16 const   )145,      (yytype_int16 const   )-91,      (yytype_int16 const   )146,      (yytype_int16 const   )147, 
        (yytype_int16 const   )148,      (yytype_int16 const   )149,      (yytype_int16 const   )150,      (yytype_int16 const   )151, 
        (yytype_int16 const   )152,      (yytype_int16 const   )153,      (yytype_int16 const   )154,      (yytype_int16 const   )155, 
        (yytype_int16 const   )156,      (yytype_int16 const   )157,      (yytype_int16 const   )158,      (yytype_int16 const   )159, 
        (yytype_int16 const   )-91,      (yytype_int16 const   )0,      (yytype_int16 const   )160,      (yytype_int16 const   )161, 
        (yytype_int16 const   )162,      (yytype_int16 const   )-91,      (yytype_int16 const   )49,      (yytype_int16 const   )163, 
        (yytype_int16 const   )164,      (yytype_int16 const   )165,      (yytype_int16 const   )166,      (yytype_int16 const   )-91, 
        (yytype_int16 const   )170,      (yytype_int16 const   )171,      (yytype_int16 const   )169,      (yytype_int16 const   )-91, 
        (yytype_int16 const   )174,      (yytype_int16 const   )175,      (yytype_int16 const   )176,      (yytype_int16 const   )191, 
        (yytype_int16 const   )177,      (yytype_int16 const   )179,      (yytype_int16 const   )180,      (yytype_int16 const   )182, 
        (yytype_int16 const   )183,      (yytype_int16 const   )181,      (yytype_int16 const   )-91,      (yytype_int16 const   )-91, 
        (yytype_int16 const   )-91,      (yytype_int16 const   )-91,      (yytype_int16 const   )-91,      (yytype_int16 const   )-91, 
        (yytype_int16 const   )-91,      (yytype_int16 const   )-91,      (yytype_int16 const   )-91,      (yytype_int16 const   )-91, 
        (yytype_int16 const   )-91,      (yytype_int16 const   )-91,      (yytype_int16 const   )-91,      (yytype_int16 const   )-91, 
        (yytype_int16 const   )-91,      (yytype_int16 const   )-91,      (yytype_int16 const   )178,      (yytype_int16 const   )184, 
        (yytype_int16 const   )185,      (yytype_int16 const   )-12,      (yytype_int16 const   )-91,      (yytype_int16 const   )-91, 
        (yytype_int16 const   )-91,      (yytype_int16 const   )-91,      (yytype_int16 const   )-91,      (yytype_int16 const   )-91, 
        (yytype_int16 const   )-91,      (yytype_int16 const   )-91,      (yytype_int16 const   )186,      (yytype_int16 const   )187, 
        (yytype_int16 const   )188,      (yytype_int16 const   )192,      (yytype_int16 const   )190,      (yytype_int16 const   )50, 
        (yytype_int16 const   )-91,      (yytype_int16 const   )-91,      (yytype_int16 const   )-91,      (yytype_int16 const   )-91, 
        (yytype_int16 const   )-91,      (yytype_int16 const   )-91,      (yytype_int16 const   )-91,      (yytype_int16 const   )-91, 
        (yytype_int16 const   )-91,      (yytype_int16 const   )-91,      (yytype_int16 const   )193,      (yytype_int16 const   )194, 
        (yytype_int16 const   )-91,      (yytype_int16 const   )195,      (yytype_int16 const   )196,      (yytype_int16 const   )197, 
        (yytype_int16 const   )198,      (yytype_int16 const   )199,      (yytype_int16 const   )201,      (yytype_int16 const   )202, 
        (yytype_int16 const   )203,      (yytype_int16 const   )204,      (yytype_int16 const   )-91,      (yytype_int16 const   )208, 
        (yytype_int16 const   )209,      (yytype_int16 const   )210,      (yytype_int16 const   )211,      (yytype_int16 const   )-91, 
        (yytype_int16 const   )212,      (yytype_int16 const   )213,      (yytype_int16 const   )215,      (yytype_int16 const   )217, 
        (yytype_int16 const   )218,      (yytype_int16 const   )214,      (yytype_int16 const   )-91,      (yytype_int16 const   )-91, 
        (yytype_int16 const   )-91,      (yytype_int16 const   )-91,      (yytype_int16 const   )-91,      (yytype_int16 const   )-91, 
        (yytype_int16 const   )220,      (yytype_int16 const   )-91,      (yytype_int16 const   )-91,      (yytype_int16 const   )-91, 
        (yytype_int16 const   )-91,      (yytype_int16 const   )-91,      (yytype_int16 const   )219,      (yytype_int16 const   )221, 
        (yytype_int16 const   )222,      (yytype_int16 const   )-91,      (yytype_int16 const   )223,      (yytype_int16 const   )224, 
        (yytype_int16 const   )225,      (yytype_int16 const   )216,      (yytype_int16 const   )39,      (yytype_int16 const   )-91, 
        (yytype_int16 const   )226,      (yytype_int16 const   )-91,      (yytype_int16 const   )227,      (yytype_int16 const   )-91, 
        (yytype_int16 const   )-91,      (yytype_int16 const   )-91,      (yytype_int16 const   )-91,      (yytype_int16 const   )-91, 
        (yytype_int16 const   )-91,      (yytype_int16 const   )231,      (yytype_int16 const   )229,      (yytype_int16 const   )-91, 
        (yytype_int16 const   )-91,      (yytype_int16 const   )-91,      (yytype_int16 const   )230,      (yytype_int16 const   )-91, 
        (yytype_int16 const   )-91};
#line 753 "config-parser.c"
static yytype_int16 const   yypgoto[74]  = 
#line 753
  {      (yytype_int16 const   )-91,      (yytype_int16 const   )-91,      (yytype_int16 const   )-91,      (yytype_int16 const   )-91, 
        (yytype_int16 const   )-91,      (yytype_int16 const   )110,      (yytype_int16 const   )-91,      (yytype_int16 const   )-91, 
        (yytype_int16 const   )-91,      (yytype_int16 const   )-91,      (yytype_int16 const   )-91,      (yytype_int16 const   )-91, 
        (yytype_int16 const   )207,      (yytype_int16 const   )-91,      (yytype_int16 const   )-91,      (yytype_int16 const   )-91, 
        (yytype_int16 const   )-91,      (yytype_int16 const   )-91,      (yytype_int16 const   )-91,      (yytype_int16 const   )-91, 
        (yytype_int16 const   )-91,      (yytype_int16 const   )-91,      (yytype_int16 const   )-91,      (yytype_int16 const   )-91, 
        (yytype_int16 const   )-91,      (yytype_int16 const   )-91,      (yytype_int16 const   )-91,      (yytype_int16 const   )-91, 
        (yytype_int16 const   )-91,      (yytype_int16 const   )-91,      (yytype_int16 const   )-28,      (yytype_int16 const   )-91, 
        (yytype_int16 const   )-91,      (yytype_int16 const   )-91,      (yytype_int16 const   )-91,      (yytype_int16 const   )-91, 
        (yytype_int16 const   )-91,      (yytype_int16 const   )61,      (yytype_int16 const   )-91,      (yytype_int16 const   )-91, 
        (yytype_int16 const   )-91,      (yytype_int16 const   )-91,      (yytype_int16 const   )-91,      (yytype_int16 const   )94, 
        (yytype_int16 const   )-91,      (yytype_int16 const   )-91,      (yytype_int16 const   )-91,      (yytype_int16 const   )-91, 
        (yytype_int16 const   )-91,      (yytype_int16 const   )-91,      (yytype_int16 const   )-91,      (yytype_int16 const   )-91, 
        (yytype_int16 const   )-91,      (yytype_int16 const   )-91,      (yytype_int16 const   )-91,      (yytype_int16 const   )205, 
        (yytype_int16 const   )-91,      (yytype_int16 const   )-91,      (yytype_int16 const   )-91,      (yytype_int16 const   )-91, 
        (yytype_int16 const   )-91,      (yytype_int16 const   )-91,      (yytype_int16 const   )-36,      (yytype_int16 const   )-91, 
        (yytype_int16 const   )-91,      (yytype_int16 const   )-91,      (yytype_int16 const   )-91,      (yytype_int16 const   )-91, 
        (yytype_int16 const   )-91,      (yytype_int16 const   )-90,      (yytype_int16 const   )-91,      (yytype_int16 const   )-91, 
        (yytype_int16 const   )236,      (yytype_int16 const   )-91};
#line 770 "config-parser.c"
static yytype_int16 const   yytable[282]  = 
#line 770
  {      (yytype_int16 const   )27,      (yytype_int16 const   )202,      (yytype_int16 const   )28,      (yytype_int16 const   )60, 
        (yytype_int16 const   )203,      (yytype_int16 const   )-56,      (yytype_int16 const   )29,      (yytype_int16 const   )-99, 
        (yytype_int16 const   )204,      (yytype_int16 const   )16,      (yytype_int16 const   )17,      (yytype_int16 const   )61, 
        (yytype_int16 const   )62,      (yytype_int16 const   )202,      (yytype_int16 const   )30,      (yytype_int16 const   )18, 
        (yytype_int16 const   )203,      (yytype_int16 const   )123,      (yytype_int16 const   )31,      (yytype_int16 const   )19, 
        (yytype_int16 const   )204,      (yytype_int16 const   )32,      (yytype_int16 const   )33,      (yytype_int16 const   )34, 
        (yytype_int16 const   )116,      (yytype_int16 const   )22,      (yytype_int16 const   )35,      (yytype_int16 const   )36, 
        (yytype_int16 const   )124,      (yytype_int16 const   )37,      (yytype_int16 const   )22,      (yytype_int16 const   )20, 
        (yytype_int16 const   )38,      (yytype_int16 const   )21,      (yytype_int16 const   )125,      (yytype_int16 const   )84, 
        (yytype_int16 const   )126,      (yytype_int16 const   )39,      (yytype_int16 const   )246,      (yytype_int16 const   )63, 
        (yytype_int16 const   )117,      (yytype_int16 const   )23,      (yytype_int16 const   )82,      (yytype_int16 const   )40, 
        (yytype_int16 const   )83,      (yytype_int16 const   )41,      (yytype_int16 const   )23,      (yytype_int16 const   )127, 
        (yytype_int16 const   )87,      (yytype_int16 const   )101,      (yytype_int16 const   )213,      (yytype_int16 const   )213, 
        (yytype_int16 const   )-99,      (yytype_int16 const   )214,      (yytype_int16 const   )214,      (yytype_int16 const   )128, 
        (yytype_int16 const   )129,      (yytype_int16 const   )130,      (yytype_int16 const   )131,      (yytype_int16 const   )118, 
        (yytype_int16 const   )71,      (yytype_int16 const   )88,      (yytype_int16 const   )132,      (yytype_int16 const   )89, 
        (yytype_int16 const   )215,      (yytype_int16 const   )215,      (yytype_int16 const   )185,      (yytype_int16 const   )72, 
        (yytype_int16 const   )60,      (yytype_int16 const   )216,      (yytype_int16 const   )216,      (yytype_int16 const   )90, 
        (yytype_int16 const   )-110,      (yytype_int16 const   )174,      (yytype_int16 const   )-131,      (yytype_int16 const   )103, 
        (yytype_int16 const   )61,      (yytype_int16 const   )62,      (yytype_int16 const   )71,      (yytype_int16 const   )85, 
        (yytype_int16 const   )73,      (yytype_int16 const   )116,      (yytype_int16 const   )91,      (yytype_int16 const   )217, 
        (yytype_int16 const   )217,      (yytype_int16 const   )72,      (yytype_int16 const   )273,      (yytype_int16 const   )92, 
        (yytype_int16 const   )74,      (yytype_int16 const   )286,      (yytype_int16 const   )93,      (yytype_int16 const   )109, 
        (yytype_int16 const   )218,      (yytype_int16 const   )218,      (yytype_int16 const   )75,      (yytype_int16 const   )94, 
        (yytype_int16 const   )95,      (yytype_int16 const   )117,      (yytype_int16 const   )73,      (yytype_int16 const   )-112, 
        (yytype_int16 const   )253,      (yytype_int16 const   )161,      (yytype_int16 const   )144,      (yytype_int16 const   )96, 
        (yytype_int16 const   )63,      (yytype_int16 const   )97,      (yytype_int16 const   )74,      (yytype_int16 const   )98, 
        (yytype_int16 const   )27,      (yytype_int16 const   )-11,      (yytype_int16 const   )28,      (yytype_int16 const   )145, 
        (yytype_int16 const   )75,      (yytype_int16 const   )-56,      (yytype_int16 const   )29,      (yytype_int16 const   )99, 
        (yytype_int16 const   )118,      (yytype_int16 const   )107,      (yytype_int16 const   )100,      (yytype_int16 const   )166, 
        (yytype_int16 const   )104,      (yytype_int16 const   )146,      (yytype_int16 const   )30,      (yytype_int16 const   )105, 
        (yytype_int16 const   )106,      (yytype_int16 const   )123,      (yytype_int16 const   )31,      (yytype_int16 const   )114, 
        (yytype_int16 const   )110,      (yytype_int16 const   )32,      (yytype_int16 const   )33,      (yytype_int16 const   )34, 
        (yytype_int16 const   )2,      (yytype_int16 const   )111,      (yytype_int16 const   )35,      (yytype_int16 const   )36, 
        (yytype_int16 const   )124,      (yytype_int16 const   )37,      (yytype_int16 const   )147,      (yytype_int16 const   )112, 
        (yytype_int16 const   )38,      (yytype_int16 const   )113,      (yytype_int16 const   )125,      (yytype_int16 const   )3, 
        (yytype_int16 const   )126,      (yytype_int16 const   )39,      (yytype_int16 const   )4,      (yytype_int16 const   )148, 
        (yytype_int16 const   )149,      (yytype_int16 const   )150,      (yytype_int16 const   )151,      (yytype_int16 const   )40, 
        (yytype_int16 const   )152,      (yytype_int16 const   )41,      (yytype_int16 const   )153,      (yytype_int16 const   )127, 
        (yytype_int16 const   )154,      (yytype_int16 const   )5,      (yytype_int16 const   )6,      (yytype_int16 const   )155, 
        (yytype_int16 const   )160,      (yytype_int16 const   )156,      (yytype_int16 const   )157,      (yytype_int16 const   )128, 
        (yytype_int16 const   )129,      (yytype_int16 const   )130,      (yytype_int16 const   )131,      (yytype_int16 const   )158, 
        (yytype_int16 const   )-75,      (yytype_int16 const   )159,      (yytype_int16 const   )132,      (yytype_int16 const   )162, 
        (yytype_int16 const   )172,      (yytype_int16 const   )163,      (yytype_int16 const   )164,      (yytype_int16 const   )167, 
        (yytype_int16 const   )168,      (yytype_int16 const   )247,      (yytype_int16 const   )165,      (yytype_int16 const   )169, 
        (yytype_int16 const   )175,      (yytype_int16 const   )170,      (yytype_int16 const   )173,      (yytype_int16 const   )254, 
        (yytype_int16 const   )287,      (yytype_int16 const   )171,      (yytype_int16 const   )115,      (yytype_int16 const   )176, 
        (yytype_int16 const   )177,      (yytype_int16 const   )178,      (yytype_int16 const   )179,      (yytype_int16 const   )180, 
        (yytype_int16 const   )181,      (yytype_int16 const   )182,      (yytype_int16 const   )183,      (yytype_int16 const   )184, 
        (yytype_int16 const   )187,      (yytype_int16 const   )188,      (yytype_int16 const   )189,      (yytype_int16 const   )190, 
        (yytype_int16 const   )191,      (yytype_int16 const   )192,      (yytype_int16 const   )193,      (yytype_int16 const   )194, 
        (yytype_int16 const   )195,      (yytype_int16 const   )196,      (yytype_int16 const   )197,      (yytype_int16 const   )198, 
        (yytype_int16 const   )199,      (yytype_int16 const   )200,      (yytype_int16 const   )201,      (yytype_int16 const   )210, 
        (yytype_int16 const   )211,      (yytype_int16 const   )212,      (yytype_int16 const   )226,      (yytype_int16 const   )227, 
        (yytype_int16 const   )228,      (yytype_int16 const   )229,      (yytype_int16 const   )230,      (yytype_int16 const   )231, 
        (yytype_int16 const   )232,      (yytype_int16 const   )233,      (yytype_int16 const   )234,      (yytype_int16 const   )236, 
        (yytype_int16 const   )235,      (yytype_int16 const   )237,      (yytype_int16 const   )238,      (yytype_int16 const   )186, 
        (yytype_int16 const   )239,      (yytype_int16 const   )240,      (yytype_int16 const   )243,      (yytype_int16 const   )241, 
        (yytype_int16 const   )242,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )244,      (yytype_int16 const   )245,      (yytype_int16 const   )248,      (yytype_int16 const   )249, 
        (yytype_int16 const   )250,      (yytype_int16 const   )251,      (yytype_int16 const   )252,      (yytype_int16 const   )0, 
        (yytype_int16 const   )255,      (yytype_int16 const   )256,      (yytype_int16 const   )257,      (yytype_int16 const   )258, 
        (yytype_int16 const   )259,      (yytype_int16 const   )102,      (yytype_int16 const   )261,      (yytype_int16 const   )260, 
        (yytype_int16 const   )262,      (yytype_int16 const   )263,      (yytype_int16 const   )264,      (yytype_int16 const   )265, 
        (yytype_int16 const   )266,      (yytype_int16 const   )267,      (yytype_int16 const   )268,      (yytype_int16 const   )270, 
        (yytype_int16 const   )86,      (yytype_int16 const   )271,      (yytype_int16 const   )269,      (yytype_int16 const   )272, 
        (yytype_int16 const   )273,      (yytype_int16 const   )277,      (yytype_int16 const   )276,      (yytype_int16 const   )278, 
        (yytype_int16 const   )285,      (yytype_int16 const   )108,      (yytype_int16 const   )279,      (yytype_int16 const   )0, 
        (yytype_int16 const   )280,      (yytype_int16 const   )281,      (yytype_int16 const   )282,      (yytype_int16 const   )283, 
        (yytype_int16 const   )284,      (yytype_int16 const   )288,      (yytype_int16 const   )289,      (yytype_int16 const   )290, 
        (yytype_int16 const   )291,      (yytype_int16 const   )292};
#line 803 "config-parser.c"
static yytype_int16 const   yycheck[282]  = 
#line 803
  {      (yytype_int16 const   )1,      (yytype_int16 const   )13,      (yytype_int16 const   )3,      (yytype_int16 const   )1, 
        (yytype_int16 const   )16,      (yytype_int16 const   )6,      (yytype_int16 const   )7,      (yytype_int16 const   )5, 
        (yytype_int16 const   )20,      (yytype_int16 const   )49,      (yytype_int16 const   )49,      (yytype_int16 const   )9, 
        (yytype_int16 const   )10,      (yytype_int16 const   )13,      (yytype_int16 const   )15,      (yytype_int16 const   )49, 
        (yytype_int16 const   )16,      (yytype_int16 const   )1,      (yytype_int16 const   )19,      (yytype_int16 const   )49, 
        (yytype_int16 const   )20,      (yytype_int16 const   )22,      (yytype_int16 const   )23,      (yytype_int16 const   )24, 
        (yytype_int16 const   )1,      (yytype_int16 const   )1,      (yytype_int16 const   )27,      (yytype_int16 const   )28, 
        (yytype_int16 const   )12,      (yytype_int16 const   )30,      (yytype_int16 const   )1,      (yytype_int16 const   )45, 
        (yytype_int16 const   )33,      (yytype_int16 const   )36,      (yytype_int16 const   )18,      (yytype_int16 const   )52, 
        (yytype_int16 const   )20,      (yytype_int16 const   )38,      (yytype_int16 const   )50,      (yytype_int16 const   )37, 
        (yytype_int16 const   )17,      (yytype_int16 const   )17,      (yytype_int16 const   )49,      (yytype_int16 const   )44, 
        (yytype_int16 const   )49,      (yytype_int16 const   )46,      (yytype_int16 const   )17,      (yytype_int16 const   )31, 
        (yytype_int16 const   )52,      (yytype_int16 const   )50,      (yytype_int16 const   )1,      (yytype_int16 const   )1, 
        (yytype_int16 const   )50,      (yytype_int16 const   )4,      (yytype_int16 const   )4,      (yytype_int16 const   )39, 
        (yytype_int16 const   )40,      (yytype_int16 const   )41,      (yytype_int16 const   )42,      (yytype_int16 const   )36, 
        (yytype_int16 const   )1,      (yytype_int16 const   )52,      (yytype_int16 const   )46,      (yytype_int16 const   )52, 
        (yytype_int16 const   )15,      (yytype_int16 const   )15,      (yytype_int16 const   )50,      (yytype_int16 const   )8, 
        (yytype_int16 const   )1,      (yytype_int16 const   )20,      (yytype_int16 const   )20,      (yytype_int16 const   )52, 
        (yytype_int16 const   )5,      (yytype_int16 const   )50,      (yytype_int16 const   )50,      (yytype_int16 const   )6, 
        (yytype_int16 const   )9,      (yytype_int16 const   )10,      (yytype_int16 const   )1,      (yytype_int16 const   )50, 
        (yytype_int16 const   )21,      (yytype_int16 const   )1,      (yytype_int16 const   )52,      (yytype_int16 const   )34, 
        (yytype_int16 const   )34,      (yytype_int16 const   )8,      (yytype_int16 const   )47,      (yytype_int16 const   )52, 
        (yytype_int16 const   )29,      (yytype_int16 const   )50,      (yytype_int16 const   )52,      (yytype_int16 const   )5, 
        (yytype_int16 const   )43,      (yytype_int16 const   )43,      (yytype_int16 const   )35,      (yytype_int16 const   )52, 
        (yytype_int16 const   )52,      (yytype_int16 const   )17,      (yytype_int16 const   )21,      (yytype_int16 const   )50, 
        (yytype_int16 const   )50,      (yytype_int16 const   )49,      (yytype_int16 const   )48,      (yytype_int16 const   )52, 
        (yytype_int16 const   )37,      (yytype_int16 const   )52,      (yytype_int16 const   )29,      (yytype_int16 const   )52, 
        (yytype_int16 const   )1,      (yytype_int16 const   )50,      (yytype_int16 const   )3,      (yytype_int16 const   )51, 
        (yytype_int16 const   )35,      (yytype_int16 const   )6,      (yytype_int16 const   )7,      (yytype_int16 const   )52, 
        (yytype_int16 const   )36,      (yytype_int16 const   )50,      (yytype_int16 const   )52,      (yytype_int16 const   )49, 
        (yytype_int16 const   )52,      (yytype_int16 const   )48,      (yytype_int16 const   )15,      (yytype_int16 const   )52, 
        (yytype_int16 const   )52,      (yytype_int16 const   )1,      (yytype_int16 const   )19,      (yytype_int16 const   )50, 
        (yytype_int16 const   )52,      (yytype_int16 const   )22,      (yytype_int16 const   )23,      (yytype_int16 const   )24, 
        (yytype_int16 const   )0,      (yytype_int16 const   )52,      (yytype_int16 const   )27,      (yytype_int16 const   )28, 
        (yytype_int16 const   )12,      (yytype_int16 const   )30,      (yytype_int16 const   )48,      (yytype_int16 const   )52, 
        (yytype_int16 const   )33,      (yytype_int16 const   )52,      (yytype_int16 const   )18,      (yytype_int16 const   )11, 
        (yytype_int16 const   )20,      (yytype_int16 const   )38,      (yytype_int16 const   )14,      (yytype_int16 const   )48, 
        (yytype_int16 const   )48,      (yytype_int16 const   )48,      (yytype_int16 const   )48,      (yytype_int16 const   )44, 
        (yytype_int16 const   )48,      (yytype_int16 const   )46,      (yytype_int16 const   )48,      (yytype_int16 const   )31, 
        (yytype_int16 const   )48,      (yytype_int16 const   )25,      (yytype_int16 const   )26,      (yytype_int16 const   )47, 
        (yytype_int16 const   )51,      (yytype_int16 const   )48,      (yytype_int16 const   )48,      (yytype_int16 const   )39, 
        (yytype_int16 const   )40,      (yytype_int16 const   )41,      (yytype_int16 const   )42,      (yytype_int16 const   )48, 
        (yytype_int16 const   )36,      (yytype_int16 const   )48,      (yytype_int16 const   )46,      (yytype_int16 const   )48, 
        (yytype_int16 const   )52,      (yytype_int16 const   )48,      (yytype_int16 const   )48,      (yytype_int16 const   )47, 
        (yytype_int16 const   )47,      (yytype_int16 const   )205,      (yytype_int16 const   )51,      (yytype_int16 const   )48, 
        (yytype_int16 const   )119,      (yytype_int16 const   )48,      (yytype_int16 const   )52,      (yytype_int16 const   )219, 
        (yytype_int16 const   )274,      (yytype_int16 const   )51,      (yytype_int16 const   )76,      (yytype_int16 const   )52, 
        (yytype_int16 const   )52,      (yytype_int16 const   )52,      (yytype_int16 const   )52,      (yytype_int16 const   )52, 
        (yytype_int16 const   )52,      (yytype_int16 const   )52,      (yytype_int16 const   )52,      (yytype_int16 const   )52, 
        (yytype_int16 const   )51,      (yytype_int16 const   )51,      (yytype_int16 const   )51,      (yytype_int16 const   )51, 
        (yytype_int16 const   )51,      (yytype_int16 const   )51,      (yytype_int16 const   )51,      (yytype_int16 const   )51, 
        (yytype_int16 const   )51,      (yytype_int16 const   )51,      (yytype_int16 const   )51,      (yytype_int16 const   )51, 
        (yytype_int16 const   )51,      (yytype_int16 const   )51,      (yytype_int16 const   )51,      (yytype_int16 const   )51, 
        (yytype_int16 const   )51,      (yytype_int16 const   )51,      (yytype_int16 const   )51,      (yytype_int16 const   )51, 
        (yytype_int16 const   )51,      (yytype_int16 const   )51,      (yytype_int16 const   )48,      (yytype_int16 const   )48, 
        (yytype_int16 const   )51,      (yytype_int16 const   )47,      (yytype_int16 const   )47,      (yytype_int16 const   )32, 
        (yytype_int16 const   )48,      (yytype_int16 const   )48,      (yytype_int16 const   )47,      (yytype_int16 const   )133, 
        (yytype_int16 const   )48,      (yytype_int16 const   )47,      (yytype_int16 const   )52,      (yytype_int16 const   )48, 
        (yytype_int16 const   )51,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )52,      (yytype_int16 const   )52,      (yytype_int16 const   )52,      (yytype_int16 const   )52, 
        (yytype_int16 const   )52,      (yytype_int16 const   )49,      (yytype_int16 const   )52,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )51,      (yytype_int16 const   )51,      (yytype_int16 const   )51,      (yytype_int16 const   )51, 
        (yytype_int16 const   )51,      (yytype_int16 const   )42,      (yytype_int16 const   )51,      (yytype_int16 const   )53, 
        (yytype_int16 const   )51,      (yytype_int16 const   )51,      (yytype_int16 const   )51,      (yytype_int16 const   )51, 
        (yytype_int16 const   )48,      (yytype_int16 const   )48,      (yytype_int16 const   )48,      (yytype_int16 const   )47, 
        (yytype_int16 const   )24,      (yytype_int16 const   )48,      (yytype_int16 const   )51,      (yytype_int16 const   )48, 
        (yytype_int16 const   )47,      (yytype_int16 const   )51,      (yytype_int16 const   )48,      (yytype_int16 const   )47, 
        (yytype_int16 const   )52,      (yytype_int16 const   )64,      (yytype_int16 const   )51,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )51,      (yytype_int16 const   )51,      (yytype_int16 const   )51,      (yytype_int16 const   )51, 
        (yytype_int16 const   )51,      (yytype_int16 const   )51,      (yytype_int16 const   )51,      (yytype_int16 const   )48, 
        (yytype_int16 const   )51,      (yytype_int16 const   )51};
#line 838 "config-parser.c"
static yytype_uint8 const   yystos[293]  = 
#line 838
  {      (yytype_uint8 const   )0,      (yytype_uint8 const   )55,      (yytype_uint8 const   )0,      (yytype_uint8 const   )11, 
        (yytype_uint8 const   )14,      (yytype_uint8 const   )25,      (yytype_uint8 const   )26,      (yytype_uint8 const   )56, 
        (yytype_uint8 const   )57,      (yytype_uint8 const   )64,      (yytype_uint8 const   )88,      (yytype_uint8 const   )89, 
        (yytype_uint8 const   )94,      (yytype_uint8 const   )95,      (yytype_uint8 const   )107,      (yytype_uint8 const   )124, 
        (yytype_uint8 const   )49,      (yytype_uint8 const   )49,      (yytype_uint8 const   )49,      (yytype_uint8 const   )49, 
        (yytype_uint8 const   )45,      (yytype_uint8 const   )36,      (yytype_uint8 const   )1,      (yytype_uint8 const   )17, 
        (yytype_uint8 const   )125,      (yytype_uint8 const   )126,      (yytype_uint8 const   )127,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )3,      (yytype_uint8 const   )7,      (yytype_uint8 const   )15,      (yytype_uint8 const   )19, 
        (yytype_uint8 const   )22,      (yytype_uint8 const   )23,      (yytype_uint8 const   )24,      (yytype_uint8 const   )27, 
        (yytype_uint8 const   )28,      (yytype_uint8 const   )30,      (yytype_uint8 const   )33,      (yytype_uint8 const   )38, 
        (yytype_uint8 const   )44,      (yytype_uint8 const   )46,      (yytype_uint8 const   )65,      (yytype_uint8 const   )66, 
        (yytype_uint8 const   )67,      (yytype_uint8 const   )68,      (yytype_uint8 const   )69,      (yytype_uint8 const   )70, 
        (yytype_uint8 const   )71,      (yytype_uint8 const   )72,      (yytype_uint8 const   )73,      (yytype_uint8 const   )74, 
        (yytype_uint8 const   )75,      (yytype_uint8 const   )76,      (yytype_uint8 const   )77,      (yytype_uint8 const   )78, 
        (yytype_uint8 const   )79,      (yytype_uint8 const   )80,      (yytype_uint8 const   )81,      (yytype_uint8 const   )82, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )9,      (yytype_uint8 const   )10,      (yytype_uint8 const   )37, 
        (yytype_uint8 const   )108,      (yytype_uint8 const   )109,      (yytype_uint8 const   )110,      (yytype_uint8 const   )111, 
        (yytype_uint8 const   )112,      (yytype_uint8 const   )113,      (yytype_uint8 const   )114,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )8,      (yytype_uint8 const   )21,      (yytype_uint8 const   )29,      (yytype_uint8 const   )35, 
        (yytype_uint8 const   )58,      (yytype_uint8 const   )59,      (yytype_uint8 const   )60,      (yytype_uint8 const   )61, 
        (yytype_uint8 const   )62,      (yytype_uint8 const   )63,      (yytype_uint8 const   )49,      (yytype_uint8 const   )49, 
        (yytype_uint8 const   )52,      (yytype_uint8 const   )50,      (yytype_uint8 const   )126,      (yytype_uint8 const   )52, 
        (yytype_uint8 const   )52,      (yytype_uint8 const   )52,      (yytype_uint8 const   )52,      (yytype_uint8 const   )52, 
        (yytype_uint8 const   )52,      (yytype_uint8 const   )52,      (yytype_uint8 const   )52,      (yytype_uint8 const   )52, 
        (yytype_uint8 const   )52,      (yytype_uint8 const   )52,      (yytype_uint8 const   )52,      (yytype_uint8 const   )52, 
        (yytype_uint8 const   )52,      (yytype_uint8 const   )50,      (yytype_uint8 const   )66,      (yytype_uint8 const   )6, 
        (yytype_uint8 const   )52,      (yytype_uint8 const   )52,      (yytype_uint8 const   )52,      (yytype_uint8 const   )50, 
        (yytype_uint8 const   )109,      (yytype_uint8 const   )5,      (yytype_uint8 const   )52,      (yytype_uint8 const   )52, 
        (yytype_uint8 const   )52,      (yytype_uint8 const   )52,      (yytype_uint8 const   )50,      (yytype_uint8 const   )59, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )17,      (yytype_uint8 const   )36,      (yytype_uint8 const   )90, 
        (yytype_uint8 const   )91,      (yytype_uint8 const   )92,      (yytype_uint8 const   )93,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )12,      (yytype_uint8 const   )18,      (yytype_uint8 const   )20,      (yytype_uint8 const   )31, 
        (yytype_uint8 const   )39,      (yytype_uint8 const   )40,      (yytype_uint8 const   )41,      (yytype_uint8 const   )42, 
        (yytype_uint8 const   )46,      (yytype_uint8 const   )96,      (yytype_uint8 const   )97,      (yytype_uint8 const   )98, 
        (yytype_uint8 const   )99,      (yytype_uint8 const   )100,      (yytype_uint8 const   )101,      (yytype_uint8 const   )102, 
        (yytype_uint8 const   )103,      (yytype_uint8 const   )104,      (yytype_uint8 const   )105,      (yytype_uint8 const   )106, 
        (yytype_uint8 const   )48,      (yytype_uint8 const   )51,      (yytype_uint8 const   )48,      (yytype_uint8 const   )48, 
        (yytype_uint8 const   )48,      (yytype_uint8 const   )48,      (yytype_uint8 const   )48,      (yytype_uint8 const   )48, 
        (yytype_uint8 const   )48,      (yytype_uint8 const   )48,      (yytype_uint8 const   )48,      (yytype_uint8 const   )47, 
        (yytype_uint8 const   )48,      (yytype_uint8 const   )48,      (yytype_uint8 const   )48,      (yytype_uint8 const   )48, 
        (yytype_uint8 const   )51,      (yytype_uint8 const   )49,      (yytype_uint8 const   )48,      (yytype_uint8 const   )48, 
        (yytype_uint8 const   )48,      (yytype_uint8 const   )51,      (yytype_uint8 const   )49,      (yytype_uint8 const   )47, 
        (yytype_uint8 const   )47,      (yytype_uint8 const   )48,      (yytype_uint8 const   )48,      (yytype_uint8 const   )51, 
        (yytype_uint8 const   )52,      (yytype_uint8 const   )52,      (yytype_uint8 const   )50,      (yytype_uint8 const   )91, 
        (yytype_uint8 const   )52,      (yytype_uint8 const   )52,      (yytype_uint8 const   )52,      (yytype_uint8 const   )52, 
        (yytype_uint8 const   )52,      (yytype_uint8 const   )52,      (yytype_uint8 const   )52,      (yytype_uint8 const   )52, 
        (yytype_uint8 const   )52,      (yytype_uint8 const   )50,      (yytype_uint8 const   )97,      (yytype_uint8 const   )51, 
        (yytype_uint8 const   )51,      (yytype_uint8 const   )51,      (yytype_uint8 const   )51,      (yytype_uint8 const   )51, 
        (yytype_uint8 const   )51,      (yytype_uint8 const   )51,      (yytype_uint8 const   )51,      (yytype_uint8 const   )51, 
        (yytype_uint8 const   )51,      (yytype_uint8 const   )51,      (yytype_uint8 const   )51,      (yytype_uint8 const   )51, 
        (yytype_uint8 const   )51,      (yytype_uint8 const   )51,      (yytype_uint8 const   )13,      (yytype_uint8 const   )16, 
        (yytype_uint8 const   )20,      (yytype_uint8 const   )83,      (yytype_uint8 const   )84,      (yytype_uint8 const   )85, 
        (yytype_uint8 const   )86,      (yytype_uint8 const   )87,      (yytype_uint8 const   )51,      (yytype_uint8 const   )51, 
        (yytype_uint8 const   )51,      (yytype_uint8 const   )1,      (yytype_uint8 const   )4,      (yytype_uint8 const   )15, 
        (yytype_uint8 const   )20,      (yytype_uint8 const   )34,      (yytype_uint8 const   )43,      (yytype_uint8 const   )115, 
        (yytype_uint8 const   )116,      (yytype_uint8 const   )117,      (yytype_uint8 const   )118,      (yytype_uint8 const   )119, 
        (yytype_uint8 const   )120,      (yytype_uint8 const   )121,      (yytype_uint8 const   )51,      (yytype_uint8 const   )51, 
        (yytype_uint8 const   )51,      (yytype_uint8 const   )51,      (yytype_uint8 const   )48,      (yytype_uint8 const   )48, 
        (yytype_uint8 const   )51,      (yytype_uint8 const   )47,      (yytype_uint8 const   )47,      (yytype_uint8 const   )48, 
        (yytype_uint8 const   )32,      (yytype_uint8 const   )48,      (yytype_uint8 const   )47,      (yytype_uint8 const   )48, 
        (yytype_uint8 const   )47,      (yytype_uint8 const   )48,      (yytype_uint8 const   )51,      (yytype_uint8 const   )52, 
        (yytype_uint8 const   )52,      (yytype_uint8 const   )52,      (yytype_uint8 const   )50,      (yytype_uint8 const   )84, 
        (yytype_uint8 const   )52,      (yytype_uint8 const   )52,      (yytype_uint8 const   )52,      (yytype_uint8 const   )49, 
        (yytype_uint8 const   )52,      (yytype_uint8 const   )50,      (yytype_uint8 const   )116,      (yytype_uint8 const   )51, 
        (yytype_uint8 const   )51,      (yytype_uint8 const   )51,      (yytype_uint8 const   )51,      (yytype_uint8 const   )51, 
        (yytype_uint8 const   )53,      (yytype_uint8 const   )51,      (yytype_uint8 const   )51,      (yytype_uint8 const   )51, 
        (yytype_uint8 const   )51,      (yytype_uint8 const   )51,      (yytype_uint8 const   )48,      (yytype_uint8 const   )48, 
        (yytype_uint8 const   )48,      (yytype_uint8 const   )51,      (yytype_uint8 const   )47,      (yytype_uint8 const   )48, 
        (yytype_uint8 const   )48,      (yytype_uint8 const   )47,      (yytype_uint8 const   )122,      (yytype_uint8 const   )123, 
        (yytype_uint8 const   )48,      (yytype_uint8 const   )51,      (yytype_uint8 const   )47,      (yytype_uint8 const   )51, 
        (yytype_uint8 const   )51,      (yytype_uint8 const   )51,      (yytype_uint8 const   )51,      (yytype_uint8 const   )51, 
        (yytype_uint8 const   )51,      (yytype_uint8 const   )52,      (yytype_uint8 const   )50,      (yytype_uint8 const   )123, 
        (yytype_uint8 const   )51,      (yytype_uint8 const   )51,      (yytype_uint8 const   )48,      (yytype_uint8 const   )51, 
        (yytype_uint8 const   )51};
#line 1359 "config-parser.c"
static void yydestruct(char const   *yymsg , int yytype , YYSTYPE *yyvaluep ) 
{ 


  {
#line 1371
  if (! yymsg) {
#line 1372
    yymsg = "Deleting";
  }
  {
#line 1378
  goto switch_default;
  switch_default: /* CIL Label */ 
#line 1379
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1381
  return;
}
}
#line 1394
int yyparse(void) ;
#line 1403 "config-parser.c"
int yychar  ;
#line 1406 "config-parser.c"
YYSTYPE yylval  ;
#line 1409 "config-parser.c"
int yynerrs  ;
#line 1430 "config-parser.c"
int yyparse(void) 
{ 
  int yystate ;
  int yyn ;
  int yyresult ;
  int yyerrstatus ;
  int yytoken ;
  yytype_int16 yyssa[200] ;
  yytype_int16 *yyss ;
  yytype_int16 *yyssp ;
  YYSTYPE yyvsa[200] ;
  YYSTYPE *yyvs ;
  YYSTYPE *yyvsp ;
  unsigned long yystacksize ;
  YYSTYPE yyval ;
  int yylen ;
  unsigned long yysize ;
  yytype_int16 *yyss1 ;
  union yyalloc *yyptr ;
  void *tmp___0 ;
  unsigned long yynewbytes ;
  unsigned long yynewbytes___0 ;
  node_t *node ;
  char *tmp___1 ;
  node_t *node___0 ;
  struct ChannelConf *item ;
  void *tmp___2 ;
  struct ChannelConf *item___0 ;
  struct ChannelConf *item___1 ;
  struct ChannelConf *item___2 ;
  node_t *node___1 ;
  struct UserConf *item___3 ;
  void *tmp___3 ;
  struct UserConf *item___4 ;
  node_t *node___2 ;
  char *tmp___4 ;
  struct UserConf *item___5 ;
  node_t *node___3 ;
  char *tmp___5 ;
  node_t *node___4 ;
  struct ScannerConf *item___6 ;
  struct ScannerConf *olditem ;
  void *tmp___6 ;
  struct ScannerConf *item___7 ;
  struct ScannerConf *item___8 ;
  struct ScannerConf *item___9 ;
  struct ScannerConf *item___10 ;
  node_t *node___5 ;
  struct ScannerConf *item___11 ;
  struct ScannerConf *item___12 ;
  struct ScannerConf *item___13 ;
  struct ScannerConf *item___14 ;
  struct ProtocolConf *item___15 ;
  struct ScannerConf *item2 ;
  node_t *node___6 ;
  void *tmp___7 ;
  node_t *node___7 ;
  struct BlacklistConf *item___16 ;
  void *tmp___8 ;
  struct BlacklistConf *item___17 ;
  struct BlacklistConf *item___18 ;
  struct BlacklistConf *item___19 ;
  int tmp___9 ;
  int tmp___10 ;
  struct BlacklistConf *item___20 ;
  struct BlacklistReplyConf *item___21 ;
  struct BlacklistConf *blacklist ;
  node_t *node___8 ;
  void *tmp___11 ;
  node_t *node___9 ;
  char *tmp___12 ;

  {
#line 1446
  yytoken = 0;
#line 1464
  yyss = yyssa;
#line 1469
  yyvs = yyvsa;
#line 1476
  yystacksize = 200UL;
#line 1485
  yylen = 0;
#line 1489
  yystate = 0;
#line 1490
  yyerrstatus = 0;
#line 1491
  yynerrs = 0;
#line 1492
  yychar = -2;
#line 1499
  yyssp = yyss;
#line 1500
  yyvsp = yyvs;
#line 1502
  goto yysetstate;
  yynewstate: 
#line 1510
  yyssp ++;
  yysetstate: 
#line 1513
  *yyssp = (yytype_int16 )yystate;
#line 1515
  if ((unsigned long )((yyss + yystacksize) - 1) <= (unsigned long )yyssp) {
#line 1518
    yysize = (unsigned long )((yyssp - yyss) + 1L);
#line 1547
    if (10000UL <= yystacksize) {
#line 1548
      goto yyexhaustedlab;
    }
#line 1549
    yystacksize *= 2UL;
#line 1550
    if (10000UL < yystacksize) {
#line 1551
      yystacksize = 10000UL;
    }
    {
#line 1554
    yyss1 = yyss;
#line 1555
    tmp___0 = malloc(yystacksize * (sizeof(yytype_int16 ) + sizeof(YYSTYPE )) + (sizeof(union yyalloc ) - 1UL));
#line 1555
    yyptr = (union yyalloc *)tmp___0;
    }
#line 1557
    if (! yyptr) {
#line 1558
      goto yyexhaustedlab;
    }
    {
#line 1559
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 1559
      __builtin_memcpy((void *)(& yyptr->yyss), (void const   *)yyss, yysize * sizeof(*yyss));
#line 1559
      yyss = & yyptr->yyss;
#line 1559
      yynewbytes = yystacksize * sizeof(*yyss) + (sizeof(union yyalloc ) - 1UL);
#line 1559
      yyptr += yynewbytes / sizeof(*yyptr);
      }
#line 1559
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1560
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 1560
      __builtin_memcpy((void *)(& yyptr->yyvs), (void const   *)yyvs, yysize * sizeof(*yyvs));
#line 1560
      yyvs = & yyptr->yyvs;
#line 1560
      yynewbytes___0 = yystacksize * sizeof(*yyvs) + (sizeof(union yyalloc ) - 1UL);
#line 1560
      yyptr += yynewbytes___0 / sizeof(*yyptr);
      }
#line 1560
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1563
    if ((unsigned long )yyss1 != (unsigned long )(yyssa)) {
      {
#line 1564
      free((void *)yyss1);
      }
    }
#line 1569
    yyssp = (yyss + yysize) - 1;
#line 1570
    yyvsp = (yyvs + yysize) - 1;
#line 1576
    if ((unsigned long )((yyss + yystacksize) - 1) <= (unsigned long )yyssp) {
#line 1577
      goto yyabortlab;
    }
  }
#line 1582
  goto yybackup;
  yybackup: 
#line 1593
  yyn = (int )yypact[yystate];
#line 1594
  if (yyn == -91) {
#line 1595
    goto yydefault;
  }
#line 1600
  if (yychar == -2) {
    {
#line 1603
    yychar = yylex();
    }
  }
#line 1606
  if (yychar <= 0) {
#line 1608
    yytoken = 0;
#line 1608
    yychar = yytoken;
  } else
#line 1613
  if ((unsigned int )yychar <= 303U) {
#line 1613
    yytoken = (int )yytranslate[yychar];
  } else {
#line 1613
    yytoken = 2;
  }
#line 1619
  yyn += yytoken;
#line 1620
  if (yyn < 0) {
#line 1621
    goto yydefault;
  } else
#line 1620
  if (281 < yyn) {
#line 1621
    goto yydefault;
  } else
#line 1620
  if ((int const   )yycheck[yyn] != (int const   )yytoken) {
#line 1621
    goto yydefault;
  }
#line 1622
  yyn = (int )yytable[yyn];
#line 1623
  if (yyn <= 0) {
#line 1625
    if (yyn == 0) {
#line 1626
      goto yyerrlab;
    } else
#line 1625
    if (yyn == -132) {
#line 1626
      goto yyerrlab;
    }
#line 1627
    yyn = - yyn;
#line 1628
    goto yyreduce;
  }
#line 1631
  if (yyn == 2) {
#line 1632
    goto yyacceptlab;
  }
#line 1636
  if (yyerrstatus) {
#line 1637
    yyerrstatus --;
  }
#line 1643
  if (yychar != 0) {
#line 1644
    yychar = -2;
  }
#line 1646
  yystate = yyn;
#line 1647
  yyvsp ++;
#line 1647
  *yyvsp = yylval;
#line 1649
  goto yynewstate;
  yydefault: 
#line 1656
  yyn = (int )yydefact[yystate];
#line 1657
  if (yyn == 0) {
#line 1658
    goto yyerrlab;
  }
#line 1659
  goto yyreduce;
  yyreduce: 
#line 1667
  yylen = (int )yyr2[yyn];
#line 1677
  yyval = *(yyvsp + (1 - yylen));
  {
#line 1683
  if (yyn == 19) {
#line 1683
    goto case_19;
  }
#line 125
  if (yyn == 20) {
#line 125 "config-parser.y"
    goto case_20;
  }
#line 131
  if (yyn == 21) {
#line 131
    goto case_21;
  }
#line 136
  if (yyn == 22) {
#line 136
    goto case_22;
  }
#line 142
  if (yyn == 42) {
#line 142
    goto case_42;
  }
#line 172
  if (yyn == 43) {
#line 172
    goto case_43;
  }
#line 178
  if (yyn == 44) {
#line 178
    goto case_44;
  }
#line 184
  if (yyn == 45) {
#line 184
    goto case_45;
  }
#line 190
  if (yyn == 46) {
#line 190
    goto case_46;
  }
#line 196
  if (yyn == 47) {
#line 196
    goto case_47;
  }
#line 202
  if (yyn == 48) {
#line 202
    goto case_48;
  }
#line 208
  if (yyn == 49) {
#line 208
    goto case_49;
  }
#line 216
  if (yyn == 50) {
#line 216
    goto case_50;
  }
#line 221
  if (yyn == 51) {
#line 221
    goto case_51;
  }
#line 227
  if (yyn == 52) {
#line 227
    goto case_52;
  }
#line 233
  if (yyn == 53) {
#line 233
    goto case_53;
  }
#line 239
  if (yyn == 54) {
#line 239
    goto case_54;
  }
#line 245
  if (yyn == 55) {
#line 245
    goto case_55;
  }
#line 251
  if (yyn == 56) {
#line 251
    goto case_56;
  }
#line 271
  if (yyn == 63) {
#line 271
    goto case_63;
  }
#line 287
  if (yyn == 64) {
#line 287
    goto case_64;
  }
#line 295
  if (yyn == 65) {
#line 295
    goto case_65;
  }
#line 303
  if (yyn == 66) {
#line 303
    goto case_66;
  }
#line 321
  if (yyn == 73) {
#line 321
    goto case_73;
  }
#line 339
  if (yyn == 74) {
#line 339
    goto case_74;
  }
#line 349
  if (yyn == 75) {
#line 349
    goto case_75;
  }
#line 396
  if (yyn == 89) {
#line 396
    goto case_89;
  }
#line 418
  if (yyn == 90) {
#line 418
    goto case_90;
  }
#line 425
  if (yyn == 91) {
#line 425
    goto case_91;
  }
#line 432
  if (yyn == 92) {
#line 432
    goto case_92;
  }
#line 448
  if (yyn == 93) {
#line 448
    goto case_93;
  }
#line 454
  if (yyn == 94) {
#line 454
    goto case_94;
  }
#line 460
  if (yyn == 95) {
#line 460
    goto case_95;
  }
#line 466
  if (yyn == 96) {
#line 466
    goto case_96;
  }
#line 472
  if (yyn == 97) {
#line 472
    goto case_97;
  }
#line 489
  if (yyn == 107) {
#line 489
    goto case_107;
  }
#line 509
  if (yyn == 108) {
#line 509
    goto case_108;
  }
#line 515
  if (yyn == 109) {
#line 515
    goto case_109;
  }
#line 521
  if (yyn == 110) {
#line 521
    goto case_110;
  }
#line 542
  if (yyn == 121) {
#line 542
    goto case_121;
  }
#line 561
  if (yyn == 122) {
#line 561
    goto case_122;
  }
#line 568
  if (yyn == 123) {
#line 568
    goto case_123;
  }
#line 579
  if (yyn == 124) {
#line 579
    goto case_124;
  }
#line 585
  if (yyn == 129) {
#line 585
    goto case_129;
  }
#line 606
  if (yyn == 136) {
#line 606
    goto case_136;
  }
#line 2178 "config-parser.c"
  goto switch_default;
  case_19: /* CIL Label */ 
#line 121 "config-parser.y"
  OptionsItem->negcache = (yyvsp + -1)->number;
#line 123
  goto switch_break;
  case_20: /* CIL Label */ 
  {
#line 126
  _MyFree((void **)(& OptionsItem->pidfile));
#line 127
  OptionsItem->pidfile = DupString((char const   *)(yyvsp + -1)->string);
  }
#line 129
  goto switch_break;
  case_21: /* CIL Label */ 
#line 132
  OptionsItem->dns_fdlimit = (unsigned int )(yyvsp + -1)->number;
#line 134
  goto switch_break;
  case_22: /* CIL Label */ 
  {
#line 137
  _MyFree((void **)(& OptionsItem->scanlog));
#line 138
  OptionsItem->scanlog = DupString((char const   *)(yyvsp + -1)->string);
  }
#line 140
  goto switch_break;
  case_42: /* CIL Label */ 
  {
#line 167
  _MyFree((void **)(& IRCItem->away));
#line 168
  IRCItem->away = DupString((char const   *)(yyvsp + -1)->string);
  }
#line 170
  goto switch_break;
  case_43: /* CIL Label */ 
  {
#line 173
  _MyFree((void **)(& IRCItem->kline));
#line 174
  IRCItem->kline = DupString((char const   *)(yyvsp + -1)->string);
  }
#line 176
  goto switch_break;
  case_44: /* CIL Label */ 
  {
#line 179
  _MyFree((void **)(& IRCItem->mode));
#line 180
  IRCItem->mode = DupString((char const   *)(yyvsp + -1)->string);
  }
#line 182
  goto switch_break;
  case_45: /* CIL Label */ 
  {
#line 185
  _MyFree((void **)(& IRCItem->nick));
#line 186
  IRCItem->nick = DupString((char const   *)(yyvsp + -1)->string);
  }
#line 188
  goto switch_break;
  case_46: /* CIL Label */ 
  {
#line 191
  _MyFree((void **)(& IRCItem->nickserv));
#line 192
  IRCItem->nickserv = DupString((char const   *)(yyvsp + -1)->string);
  }
#line 194
  goto switch_break;
  case_47: /* CIL Label */ 
  {
#line 197
  _MyFree((void **)(& IRCItem->oper));
#line 198
  IRCItem->oper = DupString((char const   *)(yyvsp + -1)->string);
  }
#line 200
  goto switch_break;
  case_48: /* CIL Label */ 
  {
#line 203
  _MyFree((void **)(& IRCItem->password));
#line 204
  IRCItem->password = DupString((char const   *)(yyvsp + -1)->string);
  }
#line 206
  goto switch_break;
  case_49: /* CIL Label */ 
  {
#line 210
  tmp___1 = DupString((char const   *)(yyvsp + -1)->string);
#line 210
  node = node_create((void *)tmp___1);
#line 212
  list_add(IRCItem->performs, node);
  }
#line 214
  goto switch_break;
  case_50: /* CIL Label */ 
#line 217
  IRCItem->port = (yyvsp + -1)->number;
#line 219
  goto switch_break;
  case_51: /* CIL Label */ 
  {
#line 222
  _MyFree((void **)(& IRCItem->realname));
#line 223
  IRCItem->realname = DupString((char const   *)(yyvsp + -1)->string);
  }
#line 225
  goto switch_break;
  case_52: /* CIL Label */ 
  {
#line 228
  _MyFree((void **)(& IRCItem->server));
#line 229
  IRCItem->server = DupString((char const   *)(yyvsp + -1)->string);
  }
#line 231
  goto switch_break;
  case_53: /* CIL Label */ 
  {
#line 234
  _MyFree((void **)(& IRCItem->username));
#line 235
  IRCItem->username = DupString((char const   *)(yyvsp + -1)->string);
  }
#line 237
  goto switch_break;
  case_54: /* CIL Label */ 
  {
#line 240
  _MyFree((void **)(& IRCItem->vhost));
#line 241
  IRCItem->vhost = DupString((char const   *)(yyvsp + -1)->string);
  }
#line 243
  goto switch_break;
  case_55: /* CIL Label */ 
  {
#line 246
  _MyFree((void **)(& IRCItem->connregex));
#line 247
  IRCItem->connregex = DupString((char const   *)(yyvsp + -1)->string);
  }
#line 249
  goto switch_break;
  case_56: /* CIL Label */ 
  {
#line 258
  tmp___2 = MyMalloc(sizeof(*item));
#line 258
  item = (struct ChannelConf *)tmp___2;
#line 260
  item->name = DupString("");
#line 261
  item->key = DupString("");
#line 262
  item->invite = DupString("");
#line 264
  node___0 = node_create((void *)item);
#line 265
  list_add(IRCItem->channels, node___0);
#line 267
  tmp = (void *)item;
  }
#line 269
  goto switch_break;
  case_63: /* CIL Label */ 
  {
#line 280
  item___0 = (struct ChannelConf *)tmp;
#line 282
  _MyFree((void **)(& item___0->name));
#line 283
  item___0->name = DupString((char const   *)(yyvsp + -1)->string);
  }
#line 285
  goto switch_break;
  case_64: /* CIL Label */ 
  {
#line 288
  item___1 = (struct ChannelConf *)tmp;
#line 290
  _MyFree((void **)(& item___1->key));
#line 291
  item___1->key = DupString((char const   *)(yyvsp + -1)->string);
  }
#line 293
  goto switch_break;
  case_65: /* CIL Label */ 
  {
#line 296
  item___2 = (struct ChannelConf *)tmp;
#line 298
  _MyFree((void **)(& item___2->invite));
#line 299
  item___2->invite = DupString((char const   *)(yyvsp + -1)->string);
  }
#line 301
  goto switch_break;
  case_66: /* CIL Label */ 
  {
#line 309
  tmp___3 = MyMalloc(sizeof(*item___3));
#line 309
  item___3 = (struct UserConf *)tmp___3;
#line 311
  item___3->masks = list_create();
#line 312
  item___3->scanners = list_create();
#line 314
  node___1 = node_create((void *)item___3);
#line 315
  list_add(UserItemList, node___1);
#line 317
  tmp = (void *)item___3;
  }
#line 319
  goto switch_break;
  case_73: /* CIL Label */ 
  {
#line 330
  item___4 = (struct UserConf *)tmp;
#line 333
  tmp___4 = DupString((char const   *)(yyvsp + -1)->string);
#line 333
  node___2 = node_create((void *)tmp___4);
#line 335
  list_add(item___4->masks, node___2);
  }
#line 337
  goto switch_break;
  case_74: /* CIL Label */ 
  {
#line 340
  item___5 = (struct UserConf *)tmp;
#line 343
  tmp___5 = DupString((char const   *)(yyvsp + -1)->string);
#line 343
  node___3 = node_create((void *)tmp___5);
#line 345
  list_add(item___5->scanners, node___3);
  }
#line 347
  goto switch_break;
  case_75: /* CIL Label */ 
  {
#line 355
  tmp___6 = MyMalloc(sizeof(*item___6));
#line 355
  item___6 = (struct ScannerConf *)tmp___6;
#line 358
  item___6->name = DupString("undefined");
  }
#line 360
  if (ScannerItemList->elements > 0) {
    {
#line 362
    olditem = (struct ScannerConf *)(ScannerItemList->tail)->data;
#line 364
    item___6->vhost = DupString((char const   *)olditem->vhost);
#line 365
    item___6->fd = olditem->fd;
#line 366
    item___6->target_ip = DupString((char const   *)olditem->target_ip);
#line 367
    item___6->target_port = olditem->target_port;
#line 368
    item___6->timeout = olditem->timeout;
#line 369
    item___6->max_read = olditem->max_read;
#line 371
    item___6->target_string = olditem->target_string;
#line 372
    item___6->target_string_created = 0;
    }
  } else {
    {
#line 376
    item___6->vhost = DupString("0.0.0.0");
#line 377
    item___6->fd = 512;
#line 378
    item___6->target_ip = DupString("127.0.0.1");
#line 379
    item___6->target_port = 6667;
#line 380
    item___6->timeout = 30;
#line 381
    item___6->max_read = 4096;
#line 383
    item___6->target_string = list_create();
#line 384
    item___6->target_string_created = 1;
    }
  }
  {
#line 387
  item___6->protocols = list_create();
#line 389
  node___4 = node_create((void *)item___6);
#line 391
  list_add(ScannerItemList, node___4);
#line 392
  tmp = (void *)item___6;
  }
#line 394
  goto switch_break;
  case_89: /* CIL Label */ 
  {
#line 412
  item___7 = (struct ScannerConf *)tmp;
#line 413
  _MyFree((void **)(& item___7->name));
#line 414
  item___7->name = DupString((char const   *)(yyvsp + -1)->string);
  }
#line 416
  goto switch_break;
  case_90: /* CIL Label */ 
  {
#line 419
  item___8 = (struct ScannerConf *)tmp;
#line 420
  _MyFree((void **)(& item___8->vhost));
#line 421
  item___8->vhost = DupString((char const   *)(yyvsp + -1)->string);
  }
#line 423
  goto switch_break;
  case_91: /* CIL Label */ 
  {
#line 426
  item___9 = (struct ScannerConf *)tmp;
#line 427
  _MyFree((void **)(& item___9->target_ip));
#line 428
  item___9->target_ip = DupString((char const   *)(yyvsp + -1)->string);
  }
#line 430
  goto switch_break;
  case_92: /* CIL Label */ 
  {
#line 433
  item___10 = (struct ScannerConf *)tmp;
#line 436
  node___5 = node_create((void *)(yyvsp + -1)->string);
  }
#line 438
  if (item___10->target_string_created == 0) {
    {
#line 440
    item___10->target_string = list_create();
#line 441
    item___10->target_string_created = 1;
    }
  }
  {
#line 444
  list_add(item___10->target_string, node___5);
  }
#line 446
  goto switch_break;
  case_93: /* CIL Label */ 
#line 449
  item___11 = (struct ScannerConf *)tmp;
#line 450
  item___11->fd = (yyvsp + -1)->number;
#line 452
  goto switch_break;
  case_94: /* CIL Label */ 
#line 455
  item___12 = (struct ScannerConf *)tmp;
#line 456
  item___12->target_port = (yyvsp + -1)->number;
#line 458
  goto switch_break;
  case_95: /* CIL Label */ 
#line 461
  item___13 = (struct ScannerConf *)tmp;
#line 462
  item___13->timeout = (yyvsp + -1)->number;
#line 464
  goto switch_break;
  case_96: /* CIL Label */ 
#line 467
  item___14 = (struct ScannerConf *)tmp;
#line 468
  item___14->max_read = (yyvsp + -1)->number;
#line 470
  goto switch_break;
  case_97: /* CIL Label */ 
  {
#line 478
  tmp___7 = MyMalloc(sizeof(*item___15));
#line 478
  item___15 = (struct ProtocolConf *)tmp___7;
#line 479
  item___15->type = (yyvsp + -3)->number;
#line 480
  item___15->port = (unsigned int )(yyvsp + -1)->number;
#line 482
  item2 = (struct ScannerConf *)tmp;
#line 484
  node___6 = node_create((void *)item___15);
#line 485
  list_add(item2->protocols, node___6);
  }
#line 487
  goto switch_break;
  case_107: /* CIL Label */ 
  {
#line 504
  _MyFree((void **)(& OpmItem->dnsbl_from));
#line 505
  OpmItem->dnsbl_from = DupString((char const   *)(yyvsp + -1)->string);
  }
#line 507
  goto switch_break;
  case_108: /* CIL Label */ 
  {
#line 510
  _MyFree((void **)(& OpmItem->dnsbl_to));
#line 511
  OpmItem->dnsbl_to = DupString((char const   *)(yyvsp + -1)->string);
  }
#line 513
  goto switch_break;
  case_109: /* CIL Label */ 
  {
#line 516
  _MyFree((void **)(& OpmItem->sendmail));
#line 517
  OpmItem->sendmail = DupString((char const   *)(yyvsp + -1)->string);
  }
#line 519
  goto switch_break;
  case_110: /* CIL Label */ 
  {
#line 527
  tmp___8 = MyMalloc(sizeof(*item___16));
#line 527
  item___16 = (struct BlacklistConf *)tmp___8;
#line 529
  item___16->name = DupString("");
#line 530
  item___16->kline = DupString("");
#line 531
  item___16->ban_unknown = 0;
#line 532
  item___16->type = (enum BlacklistType )1;
#line 533
  item___16->reply = list_create();
#line 535
  node___7 = node_create((void *)item___16);
#line 536
  list_add(OpmItem->blacklists, node___7);
#line 538
  tmp = (void *)item___16;
  }
#line 540
  goto switch_break;
  case_121: /* CIL Label */ 
  {
#line 554
  item___17 = (struct BlacklistConf *)tmp;
#line 556
  _MyFree((void **)(& item___17->name));
#line 557
  item___17->name = DupString((char const   *)(yyvsp + -1)->string);
  }
#line 559
  goto switch_break;
  case_122: /* CIL Label */ 
  {
#line 561
  item___18 = (struct BlacklistConf *)tmp;
#line 563
  _MyFree((void **)(& item___18->kline));
#line 564
  item___18->kline = DupString((char const   *)(yyvsp + -1)->string);
  }
#line 566
  goto switch_break;
  case_123: /* CIL Label */ 
  {
#line 568
  item___19 = (struct BlacklistConf *)tmp;
#line 570
  tmp___10 = strcmp("A record bitmask", (char const   *)(yyvsp + -1)->string);
  }
#line 570
  if (tmp___10 == 0) {
#line 571
    item___19->type = (enum BlacklistType )1;
  } else {
    {
#line 572
    tmp___9 = strcmp("A record reply", (char const   *)(yyvsp + -1)->string);
    }
#line 572
    if (tmp___9 == 0) {
#line 573
      item___19->type = (enum BlacklistType )2;
    } else {
      {
#line 575
      yyerror("Unknown blacklist type defined");
      }
    }
  }
#line 577
  goto switch_break;
  case_124: /* CIL Label */ 
#line 579
  item___20 = (struct BlacklistConf *)tmp;
#line 581
  item___20->ban_unknown = (yyvsp + -1)->number;
#line 583
  goto switch_break;
  case_129: /* CIL Label */ 
  {
#line 593
  blacklist = (struct BlacklistConf *)tmp;
#line 596
  tmp___11 = MyMalloc(sizeof(*item___21));
#line 596
  item___21 = (struct BlacklistReplyConf *)tmp___11;
#line 598
  item___21->number = (char )(yyvsp + -3)->number;
#line 599
  item___21->type = DupString((char const   *)(yyvsp + -1)->string);
#line 601
  node___8 = node_create((void *)item___21);
#line 602
  list_add(blacklist->reply, node___8);
  }
#line 604
  goto switch_break;
  case_136: /* CIL Label */ 
  {
#line 620
  tmp___12 = DupString((char const   *)(yyvsp + -1)->string);
#line 620
  node___9 = node_create((void *)tmp___12);
#line 622
  list_add(ExemptItem->masks, node___9);
  }
#line 624
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 2178 "config-parser.c"
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 2182
  yyvsp -= yylen;
#line 2182
  yyssp -= yylen;
#line 2183
  yylen = 0;
#line 2186
  yyvsp ++;
#line 2186
  *yyvsp = yyval;
#line 2193
  yyn = (int )yyr1[yyn];
#line 2195
  yystate = (int )((int const   )yypgoto[yyn - 54] + (int const   )*yyssp);
#line 2196
  if (0 <= yystate) {
#line 2196
    if (yystate <= 281) {
#line 2196
      if ((int const   )yycheck[yystate] == (int const   )*yyssp) {
#line 2197
        yystate = (int )yytable[yystate];
      } else {
#line 2199
        yystate = (int )yydefgoto[yyn - 54];
      }
    } else {
#line 2199
      yystate = (int )yydefgoto[yyn - 54];
    }
  } else {
#line 2199
    yystate = (int )yydefgoto[yyn - 54];
  }
#line 2201
  goto yynewstate;
  yyerrlab: 
#line 2209
  if (! yyerrstatus) {
    {
#line 2211
    yynerrs ++;
#line 2213
    yyerror("syntax error");
    }
  }
#line 2251
  if (yyerrstatus == 3) {
#line 2256
    if (yychar <= 0) {
#line 2259
      if (yychar == 0) {
#line 2260
        goto yyabortlab;
      }
    } else {
      {
#line 2264
      yydestruct("Error: discarding", yytoken, & yylval);
#line 2266
      yychar = -2;
      }
    }
  }
#line 2272
  goto yyerrlab1;
#line 2288
  yyvsp -= yylen;
#line 2288
  yyssp -= yylen;
#line 2289
  yylen = 0;
#line 2291
  yystate = (int )*yyssp;
#line 2292
  goto yyerrlab1;
  yyerrlab1: 
#line 2299
  yyerrstatus = 3;
  {
#line 2301
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 2303
    yyn = (int )yypact[yystate];
#line 2304
    if (yyn != -91) {
#line 2306
      yyn ++;
#line 2307
      if (0 <= yyn) {
#line 2307
        if (yyn <= 281) {
#line 2307
          if ((int const   )yycheck[yyn] == 1) {
#line 2309
            yyn = (int )yytable[yyn];
#line 2310
            if (0 < yyn) {
#line 2311
              goto while_break___1;
            }
          }
        }
      }
    }
#line 2316
    if ((unsigned long )yyssp == (unsigned long )yyss) {
#line 2317
      goto yyabortlab;
    }
    {
#line 2320
    yydestruct("Error: popping", (int )yystos[yystate], yyvsp);
#line 2322
    yyvsp --;
#line 2322
    yyssp --;
#line 2323
    yystate = (int )*yyssp;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 2327
  if (yyn == 2) {
#line 2328
    goto yyacceptlab;
  }
#line 2330
  yyvsp ++;
#line 2330
  *yyvsp = yylval;
#line 2336
  yystate = yyn;
#line 2337
  goto yynewstate;
  yyacceptlab: 
#line 2344
  yyresult = 0;
#line 2345
  goto yyreturn;
  yyabortlab: 
#line 2351
  yyresult = 1;
#line 2352
  goto yyreturn;
  yyexhaustedlab: 
  {
#line 2359
  yyerror("memory exhausted");
#line 2360
  yyresult = 2;
  }
  yyreturn: 
#line 2365
  if (yychar != 0) {
#line 2365
    if (yychar != -2) {
      {
#line 2366
      yydestruct("Cleanup: discarding lookahead", yytoken, & yylval);
      }
    }
  }
#line 2370
  yyvsp -= yylen;
#line 2370
  yyssp -= yylen;
  {
#line 2372
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 2372
    if (! ((unsigned long )yyssp != (unsigned long )yyss)) {
#line 2372
      goto while_break___2;
    }
    {
#line 2374
    yydestruct("Cleanup: popping", (int )yystos[*yyssp], yyvsp);
#line 2376
    yyvsp --;
#line 2376
    yyssp --;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 2379
  if ((unsigned long )yyss != (unsigned long )(yyssa)) {
    {
#line 2380
    free((void *)yyss);
    }
  }
#line 2387
  return (yyresult);
}
}
#line 689 "/usr/include/stdio.h"
extern int fputs(char const   * __restrict  __s , FILE * __restrict  __stream ) ;
#line 873
extern FILE *popen(char const   *__command , char const   *__modes ) ;
#line 879
extern int pclose(FILE *__stream ) ;
#line 132 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 263
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strrchr)(char const   *__s ,
                                                                                                int __c )  __attribute__((__pure__)) ;
#line 88 "/home/june/collector/temp/bopm-3.1.3/src/firedns.h"
int firedns_getip(int type , char const   * const  name , void *info ) ;
#line 96
void firedns_cycle(void) ;
#line 37 "/home/june/collector/temp/bopm-3.1.3/src/scan.h"
char *scan_gettype(int protocol ) ;
#line 40
void scan_checkfinished(struct scan_struct *ss ) ;
#line 44
void scan_positive(struct scan_struct *ss , char *kline , char *type ) ;
#line 7 "/home/june/collector/temp/bopm-3.1.3/src/dnsbl.h"
void dnsbl_add(struct scan_struct *ss ) ;
#line 8
void dnsbl_result(struct firedns_result *res ) ;
#line 9
void dnsbl_cycle(void) ;
#line 10
void dnsbl_report(struct scan_struct *ss ) ;
#line 17 "/home/june/collector/temp/bopm-3.1.3/src/stats.h"
void stats_dnsblrecv(struct BlacklistConf *bl ) ;
#line 18
void stats_dnsblsend(void) ;
#line 57 "/home/june/collector/temp/bopm-3.1.3/src/dnsbl.c"
void dnsbl_add(struct scan_struct *ss ) 
{ 
  struct in_addr in ;
  unsigned char a ;
  unsigned char b ;
  unsigned char c ;
  unsigned char d ;
  char lookup[128] ;
  node_t *p ;
  int res ;
  struct dnsbl_scan *ds ;
  struct BlacklistConf *bl ;
  int tmp___0 ;
  void *tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 67
  tmp___0 = inet_aton((char const   *)ss->ip, & in);
  }
#line 67
  if (! tmp___0) {
    {
#line 69
    log_printf((char *)"DNSBL -> Invalid address \'%s\', ignoring.", ss->ip);
    }
#line 70
    return;
  }
#line 73
  d = (unsigned char )((int )((unsigned char )(in.s_addr >> 24)) & 255);
#line 74
  c = (unsigned char )((int )((unsigned char )(in.s_addr >> 16)) & 255);
#line 75
  b = (unsigned char )((int )((unsigned char )(in.s_addr >> 8)) & 255);
#line 76
  a = (unsigned char )((int )((unsigned char )in.s_addr) & 255);
#line 78
  p = (OpmItem->blacklists)->head;
  {
#line 78
  while (1) {
    while_continue: /* CIL Label */ ;
#line 78
    if (! ((unsigned long )p != (unsigned long )((void *)0))) {
#line 78
      goto while_break;
    }
    {
#line 80
    bl = (struct BlacklistConf *)p->data;
#line 85
    snprintf((char */* __restrict  */)(lookup), (size_t )128, (char const   */* __restrict  */)"%d.%d.%d.%d.%s",
             (int )d, (int )c, (int )b, (int )a, bl->name);
#line 88
    tmp___1 = MyMalloc(sizeof(*ds));
#line 88
    ds = (struct dnsbl_scan *)tmp___1;
#line 89
    ds->ss = ss;
#line 90
    ds->bl = bl;
    }
#line 92
    if (OPT_DEBUG) {
      {
#line 93
      log_printf((char *)"DNSBL -> Passed \'%s\' to resolver", lookup);
      }
    }
    {
#line 95
    res = firedns_getip(1, (char const   */* const  */)(lookup), (void *)ds);
    }
#line 97
    if (res == -1) {
#line 97
      if (fdns_errno != 8) {
        {
#line 99
        tmp___2 = firedns_strerror(fdns_errno);
#line 99
        log_printf((char *)"DNSBL -> Error sending dns lookup for \'%s\': %s", lookup,
                   tmp___2);
#line 100
        free((void *)ds);
        }
      } else {
#line 103
        ss->scans = (unsigned short )((int )ss->scans + 1);
      }
    } else {
#line 103
      ss->scans = (unsigned short )((int )ss->scans + 1);
    }
#line 78
    p = p->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 105
  return;
}
}
#line 107 "/home/june/collector/temp/bopm-3.1.3/src/dnsbl.c"
static void dnsbl_positive(struct scan_struct *ss , struct BlacklistConf *bl , unsigned char type ) 
{ 
  char text_type[128] ;
  struct BlacklistReplyConf *item ;
  node_t *p ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;

  {
#line 114
  text_type[0] = (char )'\000';
#line 116
  if ((unsigned int )bl->type == 1U) {
#line 118
    p = (bl->reply)->head;
    {
#line 118
    while (1) {
      while_continue: /* CIL Label */ ;
#line 118
      if (! ((unsigned long )p != (unsigned long )((void *)0))) {
#line 118
        goto while_break;
      }
#line 120
      item = (struct BlacklistReplyConf *)p->data;
#line 121
      if ((int )item->number & (int )type) {
        {
#line 123
        tmp___0 = strlen((char const   *)(text_type));
#line 123
        strncat((char */* __restrict  */)(text_type), (char const   */* __restrict  */)item->type,
                (sizeof(text_type) - tmp___0) - 2UL);
#line 124
        text_type[sizeof(text_type) - 2UL] = (char )'\000';
#line 125
        tmp___1 = strlen((char const   *)(text_type));
#line 125
        strncat((char */* __restrict  */)(text_type), (char const   */* __restrict  */)", ",
                (sizeof(text_type) - tmp___1) - 1UL);
#line 126
        text_type[sizeof(text_type) - 1UL] = (char )'\000';
        }
      }
#line 118
      p = p->next;
    }
    while_break: /* CIL Label */ ;
    }
#line 129
    if ((int )text_type[0] != 0) {
      {
#line 130
      tmp___2 = strrchr((char const   *)(text_type), ',');
#line 130
      *tmp___2 = (char )'\000';
      }
    }
  } else {
#line 134
    p = (bl->reply)->head;
    {
#line 134
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 134
      if (! ((unsigned long )p != (unsigned long )((void *)0))) {
#line 134
        goto while_break___0;
      }
#line 136
      item = (struct BlacklistReplyConf *)p->data;
#line 137
      if ((int )item->number == (int )type) {
        {
#line 139
        strncpy((char */* __restrict  */)(text_type), (char const   */* __restrict  */)item->type,
                sizeof(text_type));
        }
#line 140
        goto while_break___0;
      }
#line 134
      p = p->next;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 145
  if ((int )text_type[0] == 0) {
#line 145
    if (bl->ban_unknown == 0) {
#line 147
      if (OPT_DEBUG) {
        {
#line 148
        log_printf((char *)"DNSBL -> Unknown result from BL zone %s (%d)", bl->name,
                   (int )type);
        }
      }
#line 149
      return;
    }
  }
#line 152
  if (ss->manual_target) {
    {
#line 154
    irc_send((char *)"PRIVMSG %s :CHECK -> DNSBL -> %s appears in BL zone %s (%s)",
             (ss->manual_target)->name, ss->ip, bl->name, text_type);
    }
  } else
#line 157
  if (! ss->positive) {
#line 160
    if (*(bl->kline + 0)) {
#line 160
      tmp___3 = bl->kline;
    } else {
#line 160
      tmp___3 = IRCItem->kline;
    }
    {
#line 160
    scan_positive(ss, tmp___3, text_type);
#line 163
    irc_send_channels((char *)"DNSBL -> %s!%s@%s appears in BL zone %s (%s)", ss->irc_nick,
                      ss->irc_username, ss->irc_hostname, bl->name, text_type);
#line 166
    log_printf((char *)"DNSBL -> %s!%s@%s appears in BL zone %s (%s)", ss->irc_nick,
               ss->irc_username, ss->irc_hostname, bl->name, text_type);
    }
  }
  {
#line 172
  stats_dnsblrecv(bl);
  }
#line 173
  return;
}
}
#line 175 "/home/june/collector/temp/bopm-3.1.3/src/dnsbl.c"
void dnsbl_result(struct firedns_result *res ) 
{ 
  struct dnsbl_scan *ds ;
  size_t tmp___1 ;
  char *tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;

  {
#line 177
  ds = (struct dnsbl_scan *)res->info;
#line 179
  if (OPT_DEBUG) {
    {
#line 180
    log_printf((char *)"DNSBL -> Lookup result for %s!%s@%s (%s) %d.%d.%d.%d (error: %d)",
               (ds->ss)->irc_nick, (ds->ss)->irc_username, (ds->ss)->irc_hostname,
               res->lookup, (int )((unsigned char )res->text[0]), (int )((unsigned char )res->text[1]),
               (int )((unsigned char )res->text[2]), (int )((unsigned char )res->text[3]),
               fdns_errno);
    }
  }
#line 191
  if ((int )res->text[0] == 0) {
#line 191
    if (fdns_errno == 3) {
#line 193
      if ((unsigned long )(ds->ss)->manual_target != (unsigned long )((void *)0)) {
        {
#line 194
        tmp___3 = strlen((char const   *)(ds->ss)->ip);
#line 194
        tmp___4 = strlen((char const   *)(res->lookup));
        }
#line 194
        if (tmp___3 < tmp___4) {
          {
#line 194
          tmp___1 = strlen((char const   *)(ds->ss)->ip);
#line 194
          tmp___2 = (res->lookup + tmp___1) + 1;
          }
        } else {
#line 194
          tmp___2 = res->lookup;
        }
        {
#line 194
        irc_send((char *)"PRIVMSG %s :CHECK -> DNSBL -> %s does not appear in BL zone %s",
                 ((ds->ss)->manual_target)->name, (ds->ss)->ip, tmp___2);
        }
      }
      {
#line 201
      (ds->ss)->scans = (unsigned short )((int )(ds->ss)->scans - 1);
#line 202
      scan_checkfinished(ds->ss);
#line 203
      _MyFree((void **)(& ds));
      }
#line 204
      return;
    }
  }
#line 209
  if (fdns_errno == 0) {
    {
#line 210
    dnsbl_positive(ds->ss, ds->bl, (unsigned char )res->text[3]);
    }
  } else {
    {
#line 213
    tmp___5 = firedns_strerror(fdns_errno);
#line 213
    log_printf((char *)"DNSBL -> Lookup error on %s: %s", res->lookup, tmp___5);
    }
#line 215
    if (fdns_errno != 6) {
      {
#line 216
      tmp___6 = firedns_strerror(fdns_errno);
#line 216
      irc_send_channels((char *)"DNSBL -> Lookup error on %s: %s", res->lookup, tmp___6);
      }
    }
  }
  {
#line 221
  (ds->ss)->scans = (unsigned short )((int )(ds->ss)->scans - 1);
#line 222
  scan_checkfinished(ds->ss);
#line 223
  _MyFree((void **)(& ds));
  }
#line 224
  return;
}
}
#line 226 "/home/june/collector/temp/bopm-3.1.3/src/dnsbl.c"
void dnsbl_cycle(void) 
{ 


  {
  {
#line 228
  firedns_cycle();
  }
#line 229
  return;
}
}
#line 235 "/home/june/collector/temp/bopm-3.1.3/src/dnsbl.c"
void dnsbl_report(struct scan_struct *ss ) 
{ 
  char buf___0[4096] ;
  char cmdbuf[512] ;
  FILE *fp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  char *tmp___3 ;

  {
#line 240
  if ((unsigned long )ss->ip == (unsigned long )((void *)0)) {
#line 241
    return;
  }
  {
#line 243
  tmp___0 = strlen((char const   *)OpmItem->dnsbl_to);
  }
#line 243
  if (tmp___0 == 0UL) {
#line 244
    return;
  } else {
    {
#line 243
    tmp___1 = strlen((char const   *)OpmItem->dnsbl_from);
    }
#line 243
    if (tmp___1 == 0UL) {
#line 244
      return;
    } else {
      {
#line 243
      tmp___2 = strlen((char const   *)OpmItem->sendmail);
      }
#line 243
      if (tmp___2 == 0UL) {
#line 244
        return;
      }
    }
  }
  {
#line 247
  snprintf((char */* __restrict  */)(cmdbuf), sizeof(cmdbuf), (char const   */* __restrict  */)"%s -t",
           OpmItem->sendmail);
#line 248
  tmp___3 = scan_gettype((int )(ss->remote)->protocol);
#line 248
  snprintf((char */* __restrict  */)(buf___0), sizeof(buf___0), (char const   */* __restrict  */)"From: %s <%s>\nTo: %s\nSubject: BOPM Report\nX-BOPM-Version: %s\n\n%s: %s:%d\n\n%s\n",
           IRCItem->nick, OpmItem->dnsbl_from, OpmItem->dnsbl_to, "3.1.3", tmp___3,
           ss->ip, (int )(ss->remote)->port, ss->proof);
  }
#line 258
  if (OPT_DEBUG >= 3U) {
    {
#line 259
    log_printf((char *)"DNSBL -> Sending following email:\n%s\n", buf___0);
    }
  }
  {
#line 261
  fp = popen((char const   *)(cmdbuf), "w");
  }
#line 261
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
    {
#line 263
    log_printf((char *)"DNSBL -> Failed to create pipe to \'%s\' for email report!",
               cmdbuf);
#line 264
    irc_send_channels((char *)"I was trying to create a pipe to\'%s\' to send a DNSBL report, and it failed! I\'ll give up for now.",
                      cmdbuf);
    }
#line 267
    return;
  }
  {
#line 270
  fputs((char const   */* __restrict  */)(buf___0), (FILE */* __restrict  */)fp);
#line 271
  pclose(fp);
#line 273
  log_printf((char *)"DNSBL -> Sent report to %s [%s]", OpmItem->dnsbl_to, ss->ip);
#line 275
  stats_dnsblsend();
  }
#line 276
  return;
}
}
#line 56 "/home/june/collector/temp/bopm-3.1.3/src/libopm/src/libopm.c"
static OPM_PROTOCOL_CONFIG_T *libopm_protocol_config_create___2(void) ;
#line 57
static void libopm_protocol_config_free___2(OPM_PROTOCOL_CONFIG_T *protocol ) ;
#line 68
static OPM_SCAN_T *libopm_scan_create___2(OPM_T *scanner , OPM_REMOTE_T *remote ) ;
#line 69
static void libopm_scan_free___2(OPM_SCAN_T *scan ) ;
#line 71
static OPM_CONNECTION_T *libopm_connection_create___2(void) ;
#line 72
static void libopm_connection_free___2(OPM_CONNECTION_T *conn ) ;
#line 74
static void libopm_check_establish___2(OPM_T *scanner ) ;
#line 75
static void libopm_check_poll___2(OPM_T *scanner ) ;
#line 76
static void libopm_check_closed___2(OPM_T *scanner ) ;
#line 77
static void libopm_check_queue___2(OPM_T *scanner ) ;
#line 79
static void libopm_do_connect___2(OPM_T *scanner , OPM_SCAN_T *scan , OPM_CONNECTION_T *conn ) ;
#line 80
static void libopm_do_readready___2(OPM_T *scanner , OPM_SCAN_T *scan , OPM_CONNECTION_T *conn ) ;
#line 81
static void libopm_do_writeready___2(OPM_T *scanner , OPM_SCAN_T *scan , OPM_CONNECTION_T *conn ) ;
#line 82
static void libopm_do_hup___2(OPM_T *scanner , OPM_SCAN_T *scan , OPM_CONNECTION_T *conn ) ;
#line 83
static void libopm_do_read___2(OPM_T *scanner , OPM_SCAN_T *scan , OPM_CONNECTION_T *conn ) ;
#line 84
static void libopm_do_openproxy___2(OPM_T *scanner , OPM_SCAN_T *scan , OPM_CONNECTION_T *conn ) ;
#line 86
static void libopm_do_callback___2(OPM_T *scanner , OPM_REMOTE_T *remote , int type ,
                                   int var ) ;
#line 88
static OPM_REMOTE_T *libopm_setup_remote___2(OPM_REMOTE_T *remote , OPM_CONNECTION_T *conn ) ;
#line 99 "/home/june/collector/temp/bopm-3.1.3/src/libopm/src/libopm.c"
static OPM_PROTOCOL_T OPM_PROTOCOLS___2[6]  = {      {1, & libopm_proxy_http_write, (OPM_PROXYREAD_T *)((void *)0)}, 
        {2, & libopm_proxy_socks4_write, (OPM_PROXYREAD_T *)((void *)0)}, 
        {3, & libopm_proxy_socks5_write, (OPM_PROXYREAD_T *)((void *)0)}, 
        {5, & libopm_proxy_router_write, (OPM_PROXYREAD_T *)((void *)0)}, 
        {4, & libopm_proxy_wingate_write, (OPM_PROXYREAD_T *)((void *)0)}, 
        {6, & libopm_proxy_httppost_write, (OPM_PROXYREAD_T *)((void *)0)}};
#line 473 "/home/june/collector/temp/bopm-3.1.3/src/libopm/src/libopm.c"
static OPM_PROTOCOL_CONFIG_T *libopm_protocol_config_create___2(void) 
{ 
  OPM_PROTOCOL_CONFIG_T *ret ;
  void *tmp___0 ;

  {
  {
#line 476
  tmp___0 = libopm_MyMalloc(sizeof(*ret));
#line 476
  ret = (OPM_PROTOCOL_CONFIG_T *)tmp___0;
  }
#line 478
  return (ret);
}
}
#line 495 "/home/june/collector/temp/bopm-3.1.3/src/libopm/src/libopm.c"
static void libopm_protocol_config_free___2(OPM_PROTOCOL_CONFIG_T *protocol ) 
{ 


  {
  {
#line 497
  libopm_MyFree((void **)(& protocol));
  }
#line 498
  return;
}
}
#line 681 "/home/june/collector/temp/bopm-3.1.3/src/libopm/src/libopm.c"
static OPM_SCAN_T *libopm_scan_create___2(OPM_T *scanner , OPM_REMOTE_T *remote ) 
{ 
  OPM_SCAN_T *ret ;
  OPM_CONNECTION_T *conn ;
  OPM_NODE_T *node ;
  OPM_NODE_T *p ;
  void *tmp___0 ;

  {
  {
#line 687
  tmp___0 = libopm_MyMalloc(sizeof(*ret));
#line 687
  ret = (OPM_SCAN_T *)tmp___0;
#line 689
  ret->remote = remote;
#line 690
  ret->connections = libopm_list_create();
#line 693
  p = (scanner->protocols)->head;
  }
  {
#line 693
  while (1) {
    while_continue: /* CIL Label */ ;
#line 693
    if (! ((unsigned long )p != (unsigned long )((void *)0))) {
#line 693
      goto while_break;
    }
    {
#line 695
    conn = libopm_connection_create___2();
#line 697
    conn->protocol = ((OPM_PROTOCOL_CONFIG_T *)p->data)->type;
#line 698
    conn->port = ((OPM_PROTOCOL_CONFIG_T *)p->data)->port;
#line 700
    node = libopm_node_create((void *)conn);
#line 702
    libopm_list_add(ret->connections, node);
#line 693
    p = p->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 708
  p = (remote->protocols)->head;
  {
#line 708
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 708
    if (! ((unsigned long )p != (unsigned long )((void *)0))) {
#line 708
      goto while_break___0;
    }
    {
#line 710
    conn = libopm_connection_create___2();
#line 712
    conn->protocol = ((OPM_PROTOCOL_CONFIG_T *)p->data)->type;
#line 713
    conn->port = ((OPM_PROTOCOL_CONFIG_T *)p->data)->port;
#line 715
    node = libopm_node_create((void *)conn);
#line 717
    libopm_list_add(ret->connections, node);
#line 708
    p = p->next;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 720
  memset((void *)(& ret->addr), 0, sizeof(opm_sockaddr ));
  }
#line 722
  return (ret);
}
}
#line 739 "/home/june/collector/temp/bopm-3.1.3/src/libopm/src/libopm.c"
static void libopm_scan_free___2(OPM_SCAN_T *scan ) 
{ 
  OPM_NODE_T *p ;
  OPM_NODE_T *next ;
  OPM_CONNECTION_T *conn ;

  {
#line 744
  p = (scan->connections)->head;
#line 744
  if (p) {
#line 744
    next = p->next;
  } else {
#line 744
    next = (OPM_NODE_T *)((void *)0);
  }
  {
#line 744
  while (1) {
    while_continue: /* CIL Label */ ;
#line 744
    if (! ((unsigned long )p != (unsigned long )((void *)0))) {
#line 744
      goto while_break;
    }
    {
#line 746
    conn = (OPM_CONNECTION_T *)p->data;
#line 747
    libopm_connection_free___2(conn);
#line 749
    libopm_list_remove(scan->connections, p);
#line 750
    libopm_node_free(p);
#line 744
    p = next;
    }
#line 744
    if (p) {
#line 744
      next = p->next;
    } else {
#line 744
      next = (OPM_NODE_T *)((void *)0);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 752
  libopm_list_free(scan->connections);
#line 754
  libopm_MyFree((void **)(& scan));
  }
#line 755
  return;
}
}
#line 771 "/home/june/collector/temp/bopm-3.1.3/src/libopm/src/libopm.c"
static OPM_CONNECTION_T *libopm_connection_create___2(void) 
{ 
  OPM_CONNECTION_T *ret ;
  void *tmp___0 ;

  {
  {
#line 774
  tmp___0 = libopm_MyMalloc(sizeof(*ret));
#line 774
  ret = (OPM_CONNECTION_T *)tmp___0;
#line 776
  ret->fd = 0;
#line 777
  ret->bytes_read = (unsigned short)0;
#line 778
  ret->readlen = (unsigned short)0;
#line 779
  ret->protocol = (OPM_PROTOCOL_T *)0;
#line 780
  ret->port = (unsigned short)0;
#line 782
  ret->state = (unsigned short)1;
  }
#line 784
  return (ret);
}
}
#line 801 "/home/june/collector/temp/bopm-3.1.3/src/libopm/src/libopm.c"
static void libopm_connection_free___2(OPM_CONNECTION_T *conn ) 
{ 


  {
  {
#line 803
  libopm_MyFree((void **)(& conn));
  }
#line 804
  return;
}
}
#line 840 "/home/june/collector/temp/bopm-3.1.3/src/libopm/src/libopm.c"
static void libopm_check_queue___2(OPM_T *scanner ) 
{ 
  OPM_NODE_T *node ;
  OPM_SCAN_T *scan ;
  unsigned int protocols___0 ;
  unsigned int projected ;
  unsigned int fd_limit ;
  void *tmp___0 ;

  {
#line 847
  if ((scanner->queue)->elements == 0) {
#line 848
    return;
  }
  {
#line 850
  tmp___0 = libopm_config(scanner->config, 0);
#line 850
  fd_limit = (unsigned int )*((int *)tmp___0);
#line 852
  projected = scanner->fd_use;
  }
  {
#line 856
  while (1) {
    while_continue: /* CIL Label */ ;
#line 856
    if (! ((scanner->queue)->elements > 0)) {
#line 856
      goto while_break;
    }
#line 860
    scan = (OPM_SCAN_T *)((scanner->queue)->head)->data;
#line 861
    protocols___0 = (unsigned int )(scan->connections)->elements;
#line 864
    if (protocols___0 + projected > fd_limit) {
#line 865
      goto while_break;
    }
    {
#line 869
    node = libopm_list_remove(scanner->queue, (scanner->queue)->head);
#line 870
    libopm_list_add(scanner->scans, node);
#line 871
    projected += protocols___0;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 874
  return;
}
}
#line 890 "/home/june/collector/temp/bopm-3.1.3/src/libopm/src/libopm.c"
static void libopm_check_establish___2(OPM_T *scanner ) 
{ 
  OPM_NODE_T *node1 ;
  OPM_NODE_T *node2 ;
  OPM_SCAN_T *scan ;
  OPM_CONNECTION_T *conn ;
  unsigned int fd_limit ;
  void *tmp___0 ;

  {
#line 898
  if ((scanner->scans)->elements == 0) {
#line 899
    return;
  }
  {
#line 901
  tmp___0 = libopm_config(scanner->config, 0);
#line 901
  fd_limit = (unsigned int )*((int *)tmp___0);
  }
#line 903
  if (scanner->fd_use >= fd_limit) {
#line 904
    return;
  }
#line 906
  node1 = (scanner->scans)->head;
  {
#line 906
  while (1) {
    while_continue: /* CIL Label */ ;
#line 906
    if (! ((unsigned long )node1 != (unsigned long )((void *)0))) {
#line 906
      goto while_break;
    }
#line 908
    scan = (OPM_SCAN_T *)node1->data;
#line 909
    node2 = (scan->connections)->head;
    {
#line 909
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 909
      if (! ((unsigned long )node2 != (unsigned long )((void *)0))) {
#line 909
        goto while_break___0;
      }
#line 912
      if (scanner->fd_use >= fd_limit) {
#line 913
        return;
      }
#line 915
      conn = (OPM_CONNECTION_T *)node2->data;
#line 916
      if ((int )conn->state == 1) {
        {
#line 917
        libopm_do_connect___2(scanner, scan, conn);
        }
      }
#line 909
      node2 = node2->next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 906
    node1 = node1->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 920
  return;
}
}
#line 941 "/home/june/collector/temp/bopm-3.1.3/src/libopm/src/libopm.c"
static void libopm_check_closed___2(OPM_T *scanner ) 
{ 
  time_t present ;
  OPM_NODE_T *node1 ;
  OPM_NODE_T *node2 ;
  OPM_NODE_T *next1 ;
  OPM_NODE_T *next2 ;
  int timeout___0 ;
  OPM_SCAN_T *scan ;
  OPM_CONNECTION_T *conn ;
  void *tmp___0 ;
  OPM_REMOTE_T *tmp___1 ;

  {
#line 951
  if ((scanner->scans)->elements == 0) {
#line 952
    return;
  }
  {
#line 954
  time(& present);
#line 956
  tmp___0 = libopm_config(scanner->config, 7);
#line 956
  timeout___0 = *((int *)tmp___0);
#line 958
  node1 = (scanner->scans)->head;
  }
#line 958
  if (node1) {
#line 958
    next1 = node1->next;
  } else {
#line 958
    next1 = (OPM_NODE_T *)((void *)0);
  }
  {
#line 958
  while (1) {
    while_continue: /* CIL Label */ ;
#line 958
    if (! ((unsigned long )node1 != (unsigned long )((void *)0))) {
#line 958
      goto while_break;
    }
#line 960
    scan = (OPM_SCAN_T *)node1->data;
#line 961
    node2 = (scan->connections)->head;
#line 961
    if (node2) {
#line 961
      next2 = node2->next;
    } else {
#line 961
      next2 = (OPM_NODE_T *)((void *)0);
    }
    {
#line 961
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 961
      if (! ((unsigned long )node2 != (unsigned long )((void *)0))) {
#line 961
        goto while_break___0;
      }
#line 964
      conn = (OPM_CONNECTION_T *)node2->data;
#line 966
      if ((int )conn->state == 4) {
#line 968
        if (conn->fd > 0) {
          {
#line 969
          close(conn->fd);
          }
        }
        {
#line 971
        (scanner->fd_use) --;
#line 973
        libopm_list_remove(scan->connections, node2);
#line 974
        libopm_connection_free___2(conn);
#line 975
        libopm_node_free(node2);
        }
#line 976
        goto __Cont;
      }
#line 979
      if (present - conn->creation >= (time_t )timeout___0) {
#line 979
        if ((int )conn->state != 1) {
          {
#line 983
          close(conn->fd);
#line 984
          (scanner->fd_use) --;
#line 986
          tmp___1 = libopm_setup_remote___2(scan->remote, conn);
#line 986
          libopm_do_callback___2(scanner, tmp___1, 4, 0);
#line 988
          libopm_list_remove(scan->connections, node2);
#line 989
          libopm_connection_free___2(conn);
#line 990
          libopm_node_free(node2);
          }
#line 992
          goto __Cont;
        }
      }
      __Cont: /* CIL Label */ 
#line 961
      node2 = next2;
#line 961
      if (node2) {
#line 961
        next2 = node2->next;
      } else {
#line 961
        next2 = (OPM_NODE_T *)((void *)0);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 999
    if ((scan->connections)->elements == 0) {
      {
#line 1001
      libopm_do_callback___2(scanner, scan->remote, 2, 0);
#line 1003
      libopm_list_remove(scanner->scans, node1);
#line 1004
      libopm_scan_free___2(scan);
#line 1005
      libopm_node_free(node1);
      }
    }
#line 958
    node1 = next1;
#line 958
    if (node1) {
#line 958
      next1 = node1->next;
    } else {
#line 958
      next1 = (OPM_NODE_T *)((void *)0);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1008
  return;
}
}
#line 1024 "/home/june/collector/temp/bopm-3.1.3/src/libopm/src/libopm.c"
static void libopm_do_connect___2(OPM_T *scanner , OPM_SCAN_T *scan , OPM_CONNECTION_T *conn ) 
{ 
  opm_sockaddr *bind_ip ;
  struct sockaddr_in *addr___0 ;
  struct sockaddr_in local_addr ;
  void *tmp___0 ;
  OPM_REMOTE_T *tmp___1 ;
  OPM_REMOTE_T *tmp___2 ;
  int tmp___3 ;

  {
  {
#line 1031
  addr___0 = & scan->addr.sa4;
#line 1033
  addr___0->sin_family = (sa_family_t )2;
#line 1034
  addr___0->sin_port = htons(conn->port);
#line 1037
  tmp___0 = libopm_config(scanner->config, 1);
#line 1037
  bind_ip = (opm_sockaddr *)tmp___0;
#line 1039
  conn->fd = socket(2, 1, 0);
#line 1040
  (scanner->fd_use) ++;
  }
#line 1042
  if (conn->fd == -1) {
    {
#line 1044
    tmp___1 = libopm_setup_remote___2(scan->remote, conn);
#line 1044
    libopm_do_callback___2(scanner, tmp___1, 3, 10);
#line 1045
    conn->state = (unsigned short)4;
    }
#line 1046
    return;
  }
#line 1049
  if ((unsigned long )bind_ip != (unsigned long )((void *)0)) {
    {
#line 1051
    memset((void *)(& local_addr), 0, sizeof(local_addr));
#line 1052
    local_addr.sin_addr.s_addr = bind_ip->sa4.sin_addr.s_addr;
#line 1053
    local_addr.sin_family = (sa_family_t )2;
#line 1054
    local_addr.sin_port = htons((uint16_t )0);
#line 1056
    tmp___3 = bind(conn->fd, (struct sockaddr  const  *)((struct sockaddr *)(& local_addr)),
                   (socklen_t )sizeof(local_addr));
    }
#line 1056
    if (tmp___3 == -1) {
      {
#line 1058
      tmp___2 = libopm_setup_remote___2(scan->remote, conn);
#line 1058
      libopm_do_callback___2(scanner, tmp___2, 3, 9);
#line 1059
      conn->state = (unsigned short)4;
      }
#line 1060
      return;
    }
  }
  {
#line 1065
  fcntl(conn->fd, 4, 2048);
#line 1067
  connect(conn->fd, (struct sockaddr  const  *)((struct sockaddr *)addr___0), (socklen_t )sizeof(*addr___0));
#line 1069
  conn->state = (unsigned short)2;
#line 1070
  time(& conn->creation);
  }
#line 1071
  return;
}
}
#line 1090 "/home/june/collector/temp/bopm-3.1.3/src/libopm/src/libopm.c"
static unsigned int ufds_size___2  ;
#line 1091 "/home/june/collector/temp/bopm-3.1.3/src/libopm/src/libopm.c"
static struct pollfd *ufds___2  =    (struct pollfd *)((void *)0);
#line 1084 "/home/june/collector/temp/bopm-3.1.3/src/libopm/src/libopm.c"
static void libopm_check_poll___2(OPM_T *scanner ) 
{ 
  OPM_NODE_T *node1 ;
  OPM_NODE_T *node2 ;
  OPM_SCAN_T *scan ;
  OPM_CONNECTION_T *conn ;
  unsigned int size ;
  unsigned int i ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;

  {
  {
#line 1094
  size = 0U;
#line 1097
  tmp___3 = libopm_config(scanner->config, 0);
  }
#line 1097
  if (ufds_size___2 < *((unsigned int *)tmp___3)) {
    {
#line 1099
    libopm_MyFree((void **)(& ufds___2));
#line 1100
    tmp___0 = libopm_config(scanner->config, 0);
#line 1100
    tmp___1 = libopm_MyMalloc(sizeof(*ufds___2) * (unsigned long )*((unsigned int *)tmp___0));
#line 1100
    ufds___2 = (struct pollfd *)tmp___1;
#line 1101
    tmp___2 = libopm_config(scanner->config, 0);
#line 1101
    ufds_size___2 = *((unsigned int *)tmp___2);
    }
  }
#line 1104
  if ((scanner->scans)->elements == 0) {
#line 1105
    return;
  }
#line 1107
  node1 = (scanner->scans)->head;
  {
#line 1107
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1107
    if (! ((unsigned long )node1 != (unsigned long )((void *)0))) {
#line 1107
      goto while_break;
    }
#line 1109
    scan = (OPM_SCAN_T *)node1->data;
#line 1110
    node2 = (scan->connections)->head;
    {
#line 1110
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1110
      if (! ((unsigned long )node2 != (unsigned long )((void *)0))) {
#line 1110
        goto while_break___0;
      }
#line 1112
      if (size >= ufds_size___2) {
#line 1113
        goto while_break___0;
      }
#line 1115
      conn = (OPM_CONNECTION_T *)node2->data;
#line 1117
      if ((int )conn->state < 2) {
#line 1119
        goto __Cont;
      } else
#line 1117
      if ((int )conn->state == 4) {
#line 1119
        goto __Cont;
      }
#line 1121
      (ufds___2 + size)->events = (short)0;
#line 1122
      (ufds___2 + size)->revents = (short)0;
#line 1123
      (ufds___2 + size)->fd = conn->fd;
#line 1126
      (ufds___2 + size)->events = (short )((int )(ufds___2 + size)->events | 16);
#line 1128
      (ufds___2 + size)->events = (short )((int )(ufds___2 + size)->events | 32);
      {
#line 1132
      if ((int )conn->state == 2) {
#line 1132
        goto case_2;
      }
#line 1135
      if ((int )conn->state == 3) {
#line 1135
        goto case_3;
      }
#line 1130
      goto switch_break;
      case_2: /* CIL Label */ 
#line 1133
      (ufds___2 + size)->events = (short )((int )(ufds___2 + size)->events | 4);
#line 1134
      goto switch_break;
      case_3: /* CIL Label */ 
#line 1136
      (ufds___2 + size)->events = (short )((int )(ufds___2 + size)->events | 1);
#line 1137
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
#line 1139
      size ++;
      __Cont: /* CIL Label */ 
#line 1110
      node2 = node2->next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1107
    node1 = node1->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1144
  tmp___4 = poll(ufds___2, (nfds_t )size, 0);
  }
  {
#line 1146
  if (tmp___4 == -1) {
#line 1146
    goto case_neg_1;
  }
#line 1149
  if (tmp___4 == 0) {
#line 1149
    goto case_0;
  }
#line 1144
  goto switch_break___0;
  case_neg_1: /* CIL Label */ 
#line 1148
  return;
  case_0: /* CIL Label */ 
#line 1151
  return;
  switch_break___0: /* CIL Label */ ;
  }
#line 1155
  node1 = (scanner->scans)->head;
  {
#line 1155
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1155
    if (! ((unsigned long )node1 != (unsigned long )((void *)0))) {
#line 1155
      goto while_break___1;
    }
#line 1157
    scan = (OPM_SCAN_T *)node1->data;
#line 1159
    node2 = (scan->connections)->head;
    {
#line 1159
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1159
      if (! ((unsigned long )node2 != (unsigned long )((void *)0))) {
#line 1159
        goto while_break___2;
      }
#line 1161
      conn = (OPM_CONNECTION_T *)node2->data;
#line 1163
      i = 0U;
      {
#line 1163
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 1163
        if (! (i < size)) {
#line 1163
          goto while_break___3;
        }
#line 1165
        if ((ufds___2 + i)->fd == conn->fd) {
#line 1165
          if ((int )conn->state != 4) {
#line 1167
            if ((int )(ufds___2 + i)->revents & 1) {
              {
#line 1168
              libopm_do_readready___2(scanner, scan, conn);
              }
            }
#line 1169
            if ((int )(ufds___2 + i)->revents & 4) {
              {
#line 1170
              libopm_do_writeready___2(scanner, scan, conn);
              }
            }
#line 1171
            if ((int )(ufds___2 + i)->revents & 16) {
              {
#line 1172
              libopm_do_hup___2(scanner, scan, conn);
              }
            }
          }
        }
#line 1163
        i ++;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 1159
      node2 = node2->next;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 1155
    node1 = node1->next;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1177
  return;
}
}
#line 1196 "/home/june/collector/temp/bopm-3.1.3/src/libopm/src/libopm.c"
static void libopm_do_readready___2(OPM_T *scanner , OPM_SCAN_T *scan , OPM_CONNECTION_T *conn ) 
{ 
  int max_read ;
  char c ;
  void *tmp___0 ;
  ssize_t tmp___1 ;
  int *tmp___2 ;
  OPM_REMOTE_T *tmp___3 ;

  {
#line 1204
  if ((conn->protocol)->read_function) {
    {
#line 1206
    (*((conn->protocol)->read_function))(scanner, scan, conn);
    }
#line 1207
    return;
  }
  {
#line 1210
  tmp___0 = libopm_config(scanner->config, 6);
#line 1210
  max_read = *((int *)tmp___0);
  }
  {
#line 1212
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1214
    tmp___1 = read(conn->fd, (void *)(& c), (size_t )1);
    }
    {
#line 1216
    if (tmp___1 == 0L) {
#line 1216
      goto case_0;
    }
#line 1220
    if (tmp___1 == -1L) {
#line 1220
      goto case_neg_1;
    }
#line 1225
    goto switch_default;
    case_0: /* CIL Label */ 
    {
#line 1217
    libopm_do_hup___2(scanner, scan, conn);
    }
#line 1218
    return;
    case_neg_1: /* CIL Label */ 
    {
#line 1221
    tmp___2 = __errno_location();
    }
#line 1221
    if (*tmp___2 != 11) {
      {
#line 1222
      libopm_do_hup___2(scanner, scan, conn);
      }
    }
#line 1223
    return;
    switch_default: /* CIL Label */ 
#line 1227
    conn->bytes_read = (unsigned short )((int )conn->bytes_read + 1);
#line 1229
    if ((int )conn->bytes_read >= max_read) {
      {
#line 1231
      tmp___3 = libopm_setup_remote___2(scan->remote, conn);
#line 1231
      libopm_do_callback___2(scanner, tmp___3, 3, 5);
#line 1232
      conn->state = (unsigned short)4;
      }
#line 1233
      return;
    }
#line 1236
    if ((int )c == 0) {
#line 1237
      goto while_continue;
    } else
#line 1236
    if ((int )c == 13) {
#line 1237
      goto while_continue;
    }
#line 1239
    if ((int )c == 10) {
      {
#line 1241
      conn->readbuf[conn->readlen] = (char )'\000';
#line 1242
      conn->readlen = (unsigned short)0;
#line 1243
      libopm_do_read___2(scanner, scan, conn);
      }
#line 1245
      if ((int )conn->state == 4) {
#line 1246
        return;
      }
#line 1248
      goto while_continue;
    }
#line 1251
    if ((int )conn->readlen < 128) {
#line 1253
      conn->readlen = (unsigned short )((int )conn->readlen + 1);
#line 1253
      conn->readbuf[(int )conn->readlen - 1] = c;
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 1278 "/home/june/collector/temp/bopm-3.1.3/src/libopm/src/libopm.c"
static void libopm_do_read___2(OPM_T *scanner , OPM_SCAN_T *scan , OPM_CONNECTION_T *conn ) 
{ 
  OPM_LIST_T *list ;
  OPM_NODE_T *node ;
  char *target_string ;
  void *tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 1285
  tmp___0 = libopm_config(scanner->config, 3);
#line 1285
  list = (OPM_LIST_T *)tmp___0;
#line 1286
  node = list->head;
  }
  {
#line 1286
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1286
    if (! ((unsigned long )node != (unsigned long )((void *)0))) {
#line 1286
      goto while_break;
    }
    {
#line 1288
    target_string = (char *)node->data;
#line 1289
    tmp___1 = strstr((char const   *)(conn->readbuf), (char const   *)target_string);
    }
#line 1289
    if (tmp___1) {
      {
#line 1291
      libopm_do_openproxy___2(scanner, scan, conn);
      }
#line 1292
      goto while_break;
    }
#line 1286
    node = node->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 1295
  return;
}
}
#line 1312 "/home/june/collector/temp/bopm-3.1.3/src/libopm/src/libopm.c"
static void libopm_do_openproxy___2(OPM_T *scanner , OPM_SCAN_T *scan , OPM_CONNECTION_T *conn ) 
{ 
  OPM_REMOTE_T *remote ;
  OPM_REMOTE_T *tmp___0 ;

  {
  {
#line 1316
  remote = scan->remote;
#line 1319
  conn->state = (unsigned short)4;
#line 1322
  tmp___0 = libopm_setup_remote___2(scan->remote, conn);
#line 1322
  libopm_do_callback___2(scanner, tmp___0, 0, 0);
  }
#line 1323
  return;
}
}
#line 1342 "/home/june/collector/temp/bopm-3.1.3/src/libopm/src/libopm.c"
static void libopm_do_writeready___2(OPM_T *scanner , OPM_SCAN_T *scan , OPM_CONNECTION_T *conn ) 
{ 
  OPM_PROTOCOL_T *protocol ;

  {
#line 1346
  protocol = conn->protocol;
#line 1349
  if (protocol->write_function) {
    {
#line 1350
    (*(protocol->write_function))(scanner, scan, conn);
    }
  }
#line 1353
  conn->state = (unsigned short)3;
#line 1354
  return;
}
}
#line 1372 "/home/june/collector/temp/bopm-3.1.3/src/libopm/src/libopm.c"
static void libopm_do_hup___2(OPM_T *scanner , OPM_SCAN_T *scan , OPM_CONNECTION_T *conn ) 
{ 
  OPM_REMOTE_T *remote ;
  OPM_REMOTE_T *tmp___0 ;

  {
  {
#line 1376
  remote = scan->remote;
#line 1379
  conn->state = (unsigned short)4;
#line 1381
  tmp___0 = libopm_setup_remote___2(scan->remote, conn);
#line 1381
  libopm_do_callback___2(scanner, tmp___0, 1, 0);
  }
#line 1382
  return;
}
}
#line 1400 "/home/june/collector/temp/bopm-3.1.3/src/libopm/src/libopm.c"
static void libopm_do_callback___2(OPM_T *scanner , OPM_REMOTE_T *remote , int type ,
                                   int var ) 
{ 


  {
#line 1403
  if (type < 0) {
#line 1404
    return;
  } else
#line 1403
  if (type >= 6) {
#line 1404
    return;
  }
#line 1406
  if ((scanner->callbacks + type)->func) {
    {
#line 1407
    (*((scanner->callbacks + type)->func))(scanner, remote, var, (scanner->callbacks + type)->data);
    }
  }
#line 1408
  return;
}
}
#line 1425 "/home/june/collector/temp/bopm-3.1.3/src/libopm/src/libopm.c"
static OPM_REMOTE_T *libopm_setup_remote___2(OPM_REMOTE_T *remote , OPM_CONNECTION_T *conn ) 
{ 


  {
#line 1427
  remote->port = conn->port;
#line 1428
  remote->bytes_read = conn->bytes_read;
#line 1429
  remote->protocol = (unsigned short )(conn->protocol)->type;
#line 1431
  return (remote);
}
}
#line 4 "/home/june/collector/temp/bopm-3.1.3/src/misc.h"
char *dissect_time(time_t time___0 ) ;
#line 5
char *clean(char *str ) ;
#line 46 "/home/june/collector/temp/bopm-3.1.3/src/misc.c"
static char buf[64]  ;
#line 44 "/home/june/collector/temp/bopm-3.1.3/src/misc.c"
char *dissect_time(time_t time___0 ) 
{ 
  unsigned int years ;
  unsigned int weeks ;
  unsigned int days ;
  unsigned int hours ;
  unsigned int minutes ;
  unsigned int seconds ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  char const   *tmp___5 ;
  char const   *tmp___6 ;
  char const   *tmp___7 ;
  char const   *tmp___8 ;
  char const   *tmp___9 ;
  char const   *tmp___10 ;
  char const   *tmp___11 ;
  char const   *tmp___12 ;

  {
#line 49
  seconds = 0U;
#line 49
  minutes = seconds;
#line 49
  hours = minutes;
#line 49
  days = hours;
#line 49
  weeks = days;
#line 49
  years = weeks;
  {
#line 51
  while (1) {
    while_continue: /* CIL Label */ ;
#line 51
    if (! (time___0 >= 31536000L)) {
#line 51
      goto while_break;
    }
#line 53
    time___0 -= 31536000L;
#line 54
    years ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 57
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 57
    if (! (time___0 >= 604800L)) {
#line 57
      goto while_break___0;
    }
#line 59
    time___0 -= 604800L;
#line 60
    weeks ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 63
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 63
    if (! (time___0 >= 86400L)) {
#line 63
      goto while_break___1;
    }
#line 65
    time___0 -= 86400L;
#line 66
    days ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 69
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 69
    if (! (time___0 >= 3600L)) {
#line 69
      goto while_break___2;
    }
#line 71
    time___0 -= 3600L;
#line 72
    hours ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 75
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 75
    if (! (time___0 >= 60L)) {
#line 75
      goto while_break___3;
    }
#line 77
    time___0 -= 60L;
#line 78
    minutes ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 81
  seconds = (unsigned int )time___0;
#line 83
  if (years) {
#line 85
    if (days == 1U) {
#line 85
      tmp___0 = "";
    } else {
#line 85
      tmp___0 = "s";
    }
#line 85
    if (weeks == 1U) {
#line 85
      tmp___1 = "";
    } else {
#line 85
      tmp___1 = "s";
    }
#line 85
    if (years == 1U) {
#line 85
      tmp___2 = "";
    } else {
#line 85
      tmp___2 = "s";
    }
    {
#line 85
    snprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)"%d year%s, %d week%s, %d day%s, %02d:%02d:%02d",
             years, tmp___2, weeks, tmp___1, days, tmp___0, hours, minutes, seconds);
    }
  } else
#line 91
  if (weeks) {
#line 93
    if (days == 1U) {
#line 93
      tmp___3 = "";
    } else {
#line 93
      tmp___3 = "s";
    }
#line 93
    if (weeks == 1U) {
#line 93
      tmp___4 = "";
    } else {
#line 93
      tmp___4 = "s";
    }
    {
#line 93
    snprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)"%d week%s, %d day%s, %02d:%02d:%02d",
             weeks, tmp___4, days, tmp___3, hours, minutes, seconds);
    }
  } else
#line 98
  if (days) {
#line 100
    if (days == 1U) {
#line 100
      tmp___5 = "";
    } else {
#line 100
      tmp___5 = "s";
    }
    {
#line 100
    snprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)"%d day%s, %02d:%02d:%02d",
             days, tmp___5, hours, minutes, seconds);
    }
  } else
#line 103
  if (hours) {
#line 105
    if (minutes) {
#line 105
      goto _L;
    } else
#line 105
    if (seconds) {
      _L: /* CIL Label */ 
#line 107
      if (seconds == 1U) {
#line 107
        tmp___6 = "";
      } else {
#line 107
        tmp___6 = "s";
      }
#line 107
      if (minutes == 1U) {
#line 107
        tmp___7 = "";
      } else {
#line 107
        tmp___7 = "s";
      }
#line 107
      if (hours == 1U) {
#line 107
        tmp___8 = "";
      } else {
#line 107
        tmp___8 = "s";
      }
      {
#line 107
      snprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)"%d hour%s, %d minute%s, %d second%s",
               hours, tmp___8, minutes, tmp___7, seconds, tmp___6);
      }
    } else {
#line 115
      if (hours == 1U) {
#line 115
        tmp___9 = "";
      } else {
#line 115
        tmp___9 = "s";
      }
      {
#line 115
      snprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)"%d hour%s",
               hours, tmp___9);
      }
    }
  } else
#line 119
  if (minutes) {
#line 121
    if (seconds == 1U) {
#line 121
      tmp___10 = "";
    } else {
#line 121
      tmp___10 = "s";
    }
#line 121
    if (minutes == 1U) {
#line 121
      tmp___11 = "";
    } else {
#line 121
      tmp___11 = "s";
    }
    {
#line 121
    snprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)"%d minute%s, %d second%s",
             minutes, tmp___11, seconds, tmp___10);
    }
  } else {
#line 127
    if (seconds == 1U) {
#line 127
      tmp___12 = "";
    } else {
#line 127
      tmp___12 = "s";
    }
    {
#line 127
    snprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)"%d second%s",
             seconds, tmp___12);
    }
  }
#line 131
  return (buf);
}
}
#line 139 "/home/june/collector/temp/bopm-3.1.3/src/misc.c"
char *clean(char *str ) 
{ 
  size_t i ;
  int ln ;
  int fn ;
  int gf ;
  size_t tmp___0 ;
  size_t tmp___1 ;

  {
  {
#line 148
  ln = 0;
#line 149
  fn = 0;
#line 150
  gf = 0;
#line 153
  tmp___0 = strlen((char const   *)str);
  }
#line 153
  if (tmp___0 <= 1UL) {
#line 154
    return (str);
  }
#line 156
  i = (size_t )0;
  {
#line 156
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 156
    tmp___1 = strlen((char const   *)str);
    }
#line 156
    if (! (i < tmp___1)) {
#line 156
      goto while_break;
    }
#line 158
    if (fn == 0) {
#line 158
      if ((int )*(str + i) != 32) {
#line 158
        if (! gf) {
#line 160
          fn = (int )i;
#line 161
          gf = 1;
        }
      }
    }
#line 163
    if ((int )*(str + i) != 32) {
#line 164
      ln = (int )i;
    }
#line 156
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 168
  *(str + (ln + 1)) = (char)0;
#line 171
  return (str + fn);
}
}
#line 374 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) rand)(void) ;
#line 376
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) srand)(unsigned int __seed ) ;
#line 156 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern ssize_t recv(int __fd , void *__buf , size_t __n , int __flags ) ;
#line 163
extern ssize_t sendto(int __fd , void const   *__buf , size_t __n , int __flags ,
                      struct sockaddr  const  *__addr , socklen_t __addr_len ) ;
#line 375 "/usr/include/netinet/in.h"
extern  __attribute__((__nothrow__)) uint16_t ( __attribute__((__leaf__)) ntohs)(uint16_t __netshort )  __attribute__((__const__)) ;
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 147
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 289
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1,2), __leaf__)) strspn)(char const   *__s ,
                                                                                                  char const   *__accept )  __attribute__((__pure__)) ;
#line 237 "/usr/include/stdio.h"
extern int fclose(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 622
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 77 "/home/june/collector/temp/bopm-3.1.3/src/firedns.h"
unsigned int fdns_fdinuse ;
#line 79
void firedns_init(void) ;
#line 89
struct firedns_result *firedns_getresult(int const   fd ) ;
#line 92
char *firedns_resolveip(int type , char const   * const  name ) ;
#line 94
struct in6_addr *firedns_resolveip6(char const   * const  name ) ;
#line 61 "/home/june/collector/temp/bopm-3.1.3/src/list.h"
node_t *list_remove(list_t *list , node_t *node ) ;
#line 64
void node_free(node_t *node ) ;
#line 56 "/home/june/collector/temp/bopm-3.1.3/src/firedns.c"
int fdns_errno  =    0;
#line 57 "/home/june/collector/temp/bopm-3.1.3/src/firedns.c"
unsigned int fdns_fdinuse  =    0U;
#line 62 "/home/june/collector/temp/bopm-3.1.3/src/firedns.c"
static struct in_addr servers4[8]  ;
#line 64 "/home/june/collector/temp/bopm-3.1.3/src/firedns.c"
static int i4  ;
#line 75 "/home/june/collector/temp/bopm-3.1.3/src/firedns.c"
static list_t *CONNECTIONS  =    (list_t *)((void *)0);
#line 81 "/home/june/collector/temp/bopm-3.1.3/src/firedns.c"
static char *errors[10]  = 
#line 81
  {      (char *)"Success",      (char *)"Format error",      (char *)"Server failure",      (char *)"Name error", 
        (char *)"Not implemented",      (char *)"Refused",      (char *)"Timeout",      (char *)"Network error", 
        (char *)"FD Limit reached",      (char *)"Unknown error"};
#line 152
static struct s_connection *firedns_add_query(void) ;
#line 153
static int firedns_doquery(struct s_connection *s ) ;
#line 154
static int firedns_build_query_payload(char const   * const  name , unsigned short rr ,
                                       unsigned short class , unsigned char *payload ) ;
#line 156
static int firedns_send_requests(struct s_header *h , struct s_connection *s , int l ) ;
#line 160 "/home/june/collector/temp/bopm-3.1.3/src/firedns.c"
void firedns_init(void) 
{ 
  FILE *f ;
  int i ;
  struct in_addr addr4 ;
  char buf___0[1024] ;
  char *file ;
  time_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;
  size_t tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  char *tmp___8 ;

  {
  {
#line 178
  i4 = 0;
#line 181
  CONNECTIONS = list_create();
#line 183
  tmp___0 = time((time_t *)((void *)0));
#line 183
  srand((unsigned int )tmp___0);
#line 184
  memset((void *)(servers4), '\000', sizeof(struct in_addr ) * 8UL);
#line 190
  f = fopen((char const   */* __restrict  */)"/home/june/bopm/etc/firedns.conf", (char const   */* __restrict  */)"r");
  }
#line 191
  if ((unsigned long )f == (unsigned long )((void *)0)) {
    {
#line 193
    f = fopen((char const   */* __restrict  */)"/etc/resolv.conf", (char const   */* __restrict  */)"r");
    }
#line 194
    if ((unsigned long )f == (unsigned long )((void *)0)) {
      {
#line 196
      log_printf((char *)"Unable to open %s", "/etc/resolv.conf");
      }
#line 197
      return;
    }
#line 199
    file = (char *)"/etc/resolv.conf";
    {
#line 200
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 200
      tmp___4 = fgets((char */* __restrict  */)(buf___0), 1024, (FILE */* __restrict  */)f);
      }
#line 200
      if (! ((unsigned long )tmp___4 != (unsigned long )((void *)0))) {
#line 200
        goto while_break;
      }
      {
#line 202
      tmp___3 = strncmp((char const   *)(buf___0), "nameserver", (size_t )10);
      }
#line 202
      if (tmp___3 == 0) {
#line 204
        i = 10;
        {
#line 205
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 205
          if (! ((int )buf___0[i] == 32)) {
#line 205
            if (! ((int )buf___0[i] == 9)) {
#line 205
              goto while_break___0;
            }
          }
#line 206
          i ++;
        }
        while_break___0: /* CIL Label */ ;
        }
#line 218
        if (i4 < 8) {
          {
#line 220
          tmp___2 = inet_aton((char const   *)(& buf___0[i]), & addr4);
          }
#line 220
          if (tmp___2) {
            {
#line 222
            tmp___1 = i4;
#line 222
            i4 ++;
#line 222
            memcpy((void */* __restrict  */)(& servers4[tmp___1]), (void const   */* __restrict  */)(& addr4),
                   sizeof(struct in_addr ));
            }
          }
        }
      }
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 230
    file = (char *)"/home/june/bopm/etc/firedns.conf";
    {
#line 231
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 231
      tmp___8 = fgets((char */* __restrict  */)(buf___0), 1024, (FILE */* __restrict  */)f);
      }
#line 231
      if (! ((unsigned long )tmp___8 != (unsigned long )((void *)0))) {
#line 231
        goto while_break___1;
      }
      {
#line 233
      tmp___5 = strspn((char const   *)(buf___0), "0123456789.");
#line 233
      buf___0[tmp___5] = (char )'\000';
      }
#line 244
      if (i4 < 8) {
        {
#line 246
        tmp___7 = inet_pton(2, (char const   */* __restrict  */)(buf___0), (void */* __restrict  */)((char *)(& addr4)));
        }
#line 246
        if (tmp___7) {
          {
#line 247
          tmp___6 = i4;
#line 247
          i4 ++;
#line 247
          memcpy((void */* __restrict  */)(& servers4[tmp___6]), (void const   */* __restrict  */)(& addr4),
                 sizeof(struct in_addr ));
          }
        }
      }
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  {
#line 251
  fclose(f);
  }
#line 253
  if (i4 == 0) {
    {
#line 259
    log_printf((char *)"FIREDNS -> No nameservers found in %s", file);
#line 260
    exit(1);
    }
  }
#line 262
  return;
}
}
#line 266 "/home/june/collector/temp/bopm-3.1.3/src/firedns.c"
static struct in_addr addr  ;
#line 264 "/home/june/collector/temp/bopm-3.1.3/src/firedns.c"
struct in_addr *firedns_resolveip4(char const   * const  name ) 
{ 
  int tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 268
  tmp___0 = inet_aton((char const   *)name, & addr);
  }
#line 268
  if (tmp___0) {
#line 269
    return (& addr);
  }
  {
#line 271
  tmp___1 = firedns_resolveip(1, name);
  }
#line 271
  return ((struct in_addr *)tmp___1);
}
}
#line 274 "/home/june/collector/temp/bopm-3.1.3/src/firedns.c"
struct in6_addr *firedns_resolveip6(char const   * const  name ) 
{ 
  char *tmp___0 ;

  {
  {
#line 276
  tmp___0 = firedns_resolveip(28, name);
  }
#line 276
  return ((struct in6_addr *)tmp___0);
}
}
#line 279 "/home/june/collector/temp/bopm-3.1.3/src/firedns.c"
char *firedns_resolveip(int type , char const   * const  name ) 
{ 
  int fd ;
  int t ;
  int i ;
  struct firedns_result *result___0 ;
  struct timeval tv ;
  fd_set s ;
  int __d0 ;
  int __d1 ;

  {
#line 286
  t = 0;
  {
#line 286
  while (1) {
    while_continue: /* CIL Label */ ;
#line 286
    if (! (t < 3)) {
#line 286
      goto while_break;
    }
    {
#line 288
    fd = firedns_getip(type, name, (void *)0);
    }
#line 289
    if (fd == -1) {
#line 290
      return ((char *)((void *)0));
    }
#line 292
    tv.tv_sec = (__time_t )5;
#line 293
    tv.tv_usec = (__suseconds_t )0;
    {
#line 294
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 294
      __asm__  volatile   ("cld; rep; "
                           "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                           "1" (& s.__fds_bits[0]): "memory");
#line 294
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 295
    s.__fds_bits[fd / (8 * (int )sizeof(__fd_mask ))] |= 1L << fd % (8 * (int )sizeof(__fd_mask ));
#line 296
    i = select(fd + 1, (fd_set */* __restrict  */)(& s), (fd_set */* __restrict  */)((void *)0),
               (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)(& tv));
#line 298
    result___0 = firedns_getresult((int const   )fd);
    }
#line 300
    if (fdns_errno == 0) {
#line 303
      return (result___0->text);
    } else
#line 304
    if (fdns_errno == 3) {
#line 305
      return ((char *)((void *)0));
    }
#line 286
    t ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 307
  if (fdns_errno == 0) {
#line 308
    fdns_errno = 6;
  }
#line 309
  return ((char *)((void *)0));
}
}
#line 316 "/home/june/collector/temp/bopm-3.1.3/src/firedns.c"
int firedns_getip(int type , char const   * const  name , void *info ) 
{ 
  struct s_connection *s ;
  node_t *node ;
  int fd ;

  {
  {
#line 322
  s = firedns_add_query();
#line 324
  s->class = (unsigned short)1;
#line 325
  s->type = (unsigned short )type;
#line 326
  strncpy((char */* __restrict  */)(s->lookup), (char const   */* __restrict  */)name,
          (size_t )256);
#line 327
  s->info = info;
  }
#line 329
  if (fdns_fdinuse >= OptionsItem->dns_fdlimit) {
#line 331
    fdns_errno = 8;
#line 333
    if ((unsigned long )info == (unsigned long )((void *)0)) {
      {
#line 335
      _MyFree((void **)(& s));
      }
    } else {
      {
#line 337
      node = node_create((void *)s);
#line 338
      list_add(CONNECTIONS, node);
      }
    }
#line 340
    return (-1);
  }
  {
#line 343
  fd = firedns_doquery(s);
  }
#line 345
  if (fd == -1) {
    {
#line 347
    _MyFree((void **)(& s));
    }
#line 348
    return (-1);
  }
  {
#line 351
  node = node_create((void *)s);
#line 352
  list_add(CONNECTIONS, node);
  }
#line 353
  return (fd);
}
}
#line 356 "/home/june/collector/temp/bopm-3.1.3/src/firedns.c"
static struct s_connection *firedns_add_query(void) 
{ 
  struct s_connection *s ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 361
  tmp___0 = MyMalloc(sizeof(*s));
#line 361
  s = (struct s_connection *)tmp___0;
#line 364
  tmp___1 = rand();
#line 364
  s->id[0] = (unsigned char )(tmp___1 % 255);
#line 365
  tmp___2 = rand();
#line 365
  s->id[1] = (unsigned char )(tmp___2 % 255);
#line 367
  s->fd = -1;
  }
#line 369
  return (s);
}
}
#line 372 "/home/june/collector/temp/bopm-3.1.3/src/firedns.c"
static int firedns_doquery(struct s_connection *s ) 
{ 
  int len ;
  struct s_header h ;
  int tmp___0 ;

  {
  {
#line 377
  len = firedns_build_query_payload((char const   */* const  */)(s->lookup), s->type,
                                    (unsigned short)1, (unsigned char *)(& h.payload));
  }
#line 380
  if (len == -1) {
#line 382
    fdns_errno = 1;
#line 383
    return (-1);
  }
  {
#line 386
  tmp___0 = firedns_send_requests(& h, s, len);
  }
#line 386
  return (tmp___0);
}
}
#line 392 "/home/june/collector/temp/bopm-3.1.3/src/firedns.c"
static int firedns_build_query_payload(char const   * const  name , unsigned short rr ,
                                       unsigned short class , unsigned char *payload ) 
{ 
  short payloadpos ;
  char const   *tempchr ;
  char const   *tempchr2 ;
  unsigned short l ;
  short tmp___0 ;
  char *tmp___1 ;
  size_t tmp___2 ;
  short tmp___3 ;
  short tmp___4 ;

  {
#line 399
  payloadpos = (short)0;
#line 400
  tempchr2 = (char const   *)name;
  {
#line 403
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 403
    tmp___1 = strchr(tempchr2, '.');
#line 403
    tempchr = (char const   *)tmp___1;
    }
#line 403
    if (! ((unsigned long )tempchr != (unsigned long )((void *)0))) {
#line 403
      goto while_break;
    }
#line 405
    l = (unsigned short )(tempchr - tempchr2);
#line 406
    if (((int )payloadpos + (int )l) + 1 > 507) {
#line 407
      return (-1);
    }
    {
#line 408
    tmp___0 = payloadpos;
#line 408
    payloadpos = (short )((int )payloadpos + 1);
#line 408
    *(payload + tmp___0) = (unsigned char )l;
#line 409
    memcpy((void */* __restrict  */)(payload + payloadpos), (void const   */* __restrict  */)tempchr2,
           (size_t )l);
#line 410
    payloadpos = (short )((int )payloadpos + (int )l);
#line 411
    tempchr2 = tempchr + 1;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 413
  tmp___2 = strlen(tempchr2);
#line 413
  l = (unsigned short )tmp___2;
  }
#line 414
  if (l) {
#line 416
    if (((int )payloadpos + (int )l) + 2 > 507) {
#line 417
      return (-1);
    }
    {
#line 418
    tmp___3 = payloadpos;
#line 418
    payloadpos = (short )((int )payloadpos + 1);
#line 418
    *(payload + tmp___3) = (unsigned char )l;
#line 419
    memcpy((void */* __restrict  */)(payload + payloadpos), (void const   */* __restrict  */)tempchr2,
           (size_t )l);
#line 420
    payloadpos = (short )((int )payloadpos + (int )l);
#line 421
    tmp___4 = payloadpos;
#line 421
    payloadpos = (short )((int )payloadpos + 1);
#line 421
    *(payload + tmp___4) = (unsigned char )'\000';
    }
  }
#line 423
  if ((int )payloadpos > 508) {
#line 424
    return (-1);
  }
  {
#line 425
  l = htons(rr);
#line 426
  memcpy((void */* __restrict  */)(payload + payloadpos), (void const   */* __restrict  */)(& l),
         (size_t )2);
#line 427
  l = htons(class);
#line 428
  memcpy((void */* __restrict  */)(payload + ((int )payloadpos + 2)), (void const   */* __restrict  */)(& l),
         (size_t )2);
  }
#line 429
  return ((int )payloadpos + 4);
}
}
#line 433 "/home/june/collector/temp/bopm-3.1.3/src/firedns.c"
static int firedns_send_requests(struct s_header *h , struct s_connection *s , int l ) 
{ 
  int i ;
  int sent_ok ;
  struct sockaddr_in addr4 ;
  int tmp___0 ;
  struct sockaddr_in addr___0 ;
  int tmp___1 ;
  ssize_t tmp___2 ;

  {
  {
#line 436
  sent_ok = 0;
#line 444
  h->flags1 = (unsigned char)1;
#line 445
  h->flags2 = (unsigned char)0;
#line 446
  h->qdcount = htons((uint16_t )1);
#line 447
  h->ancount = htons((uint16_t )0);
#line 448
  h->nscount = htons((uint16_t )0);
#line 449
  h->arcount = htons((uint16_t )0);
#line 450
  memcpy((void */* __restrict  */)(h->id), (void const   */* __restrict  */)(s->id),
         (size_t )2);
#line 483
  s->fd = socket(2, 2, 0);
  }
#line 484
  if (s->fd != -1) {
    {
#line 486
    tmp___0 = fcntl(s->fd, 4, 2048);
    }
#line 486
    if (tmp___0 != 0) {
      {
#line 488
      close(s->fd);
#line 489
      s->fd = -1;
      }
    }
  }
#line 492
  if (s->fd != -1) {
    {
#line 495
    memset((void *)(& addr___0), 0, sizeof(addr___0));
#line 496
    addr___0.sin_family = (sa_family_t )2;
#line 497
    addr___0.sin_port = (in_port_t )0;
#line 498
    addr___0.sin_addr.s_addr = (in_addr_t )0;
#line 499
    tmp___1 = bind(s->fd, (struct sockaddr  const  *)((struct sockaddr *)(& addr___0)),
                   (socklen_t )sizeof(addr___0));
    }
#line 499
    if (tmp___1 != 0) {
      {
#line 501
      close(s->fd);
#line 502
      s->fd = -1;
      }
    }
  }
#line 505
  if (s->fd == -1) {
#line 507
    fdns_errno = 7;
#line 508
    return (-1);
  }
#line 532
  i = 0;
  {
#line 532
  while (1) {
    while_continue: /* CIL Label */ ;
#line 532
    if (! (i < i4)) {
#line 532
      goto while_break;
    }
    {
#line 549
    memset((void *)(& addr4), 0, sizeof(addr4));
#line 550
    memcpy((void */* __restrict  */)(& addr4.sin_addr), (void const   */* __restrict  */)(& servers4[i]),
           sizeof(addr4.sin_addr));
#line 551
    addr4.sin_family = (sa_family_t )2;
#line 552
    addr4.sin_port = htons((uint16_t )53);
#line 553
    tmp___2 = sendto(s->fd, (void const   *)h, (size_t )(l + 12), 0, (struct sockaddr  const  *)((struct sockaddr *)(& addr4)),
                     (socklen_t )sizeof(addr4));
    }
#line 553
    if (tmp___2 > 0L) {
#line 554
      sent_ok = 1;
    }
#line 532
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 557
  if (! sent_ok) {
    {
#line 559
    close(s->fd);
#line 560
    s->fd = -1;
#line 561
    fdns_errno = 7;
    }
#line 562
    return (-1);
  }
  {
#line 565
  time(& s->start);
#line 566
  fdns_fdinuse ++;
#line 567
  fdns_errno = 0;
  }
#line 568
  return (s->fd);
}
}
#line 573 "/home/june/collector/temp/bopm-3.1.3/src/firedns.c"
static struct firedns_result result  ;
#line 571 "/home/june/collector/temp/bopm-3.1.3/src/firedns.c"
struct firedns_result *firedns_getresult(int const   fd ) 
{ 
  struct s_header h ;
  struct s_connection *c ;
  node_t *node ;
  int l ;
  int i ;
  int q ;
  int curanswer ;
  struct s_rr_middle *rr ;
  struct s_rr_middle rrbacking ;
  char *src ;
  char *dst ;
  int bytes ;
  ssize_t tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  uint16_t tmp___3 ;
  uint16_t tmp___4 ;

  {
  {
#line 582
  fdns_errno = 9;
#line 583
  result.info = (void *)0;
#line 584
  memset((void *)(result.text), 0, sizeof(result.text));
#line 587
  node = CONNECTIONS->head;
  }
  {
#line 587
  while (1) {
    while_continue: /* CIL Label */ ;
#line 587
    if (! ((unsigned long )node != (unsigned long )((void *)0))) {
#line 587
      goto while_break;
    }
#line 589
    c = (struct s_connection *)node->data;
#line 590
    if (c->fd == (int )fd) {
#line 591
      goto while_break;
    } else {
#line 593
      c = (struct s_connection *)((void *)0);
    }
#line 587
    node = node->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 597
  if ((unsigned long )c == (unsigned long )((void *)0)) {
#line 598
    return (& result);
  }
  {
#line 602
  tmp___0 = recv(c->fd, (void *)(& h), sizeof(struct s_header ), 0);
#line 602
  l = (int )tmp___0;
#line 603
  result.info = c->info;
#line 604
  strncpy((char */* __restrict  */)(result.lookup), (char const   */* __restrict  */)(c->lookup),
          (size_t )256);
  }
#line 606
  if (l == -1) {
#line 608
    fdns_errno = 7;
#line 609
    goto cleanup;
  }
#line 612
  if (l < 12) {
#line 613
    goto cleanup;
  }
#line 614
  if ((int )c->id[0] != (int )h.id[0]) {
#line 617
    return ((struct firedns_result *)((void *)0));
  } else
#line 614
  if ((int )c->id[1] != (int )h.id[1]) {
#line 617
    return ((struct firedns_result *)((void *)0));
  }
#line 618
  if (((int )h.flags1 & 128) == 0) {
#line 619
    goto cleanup;
  }
#line 620
  if (((int )h.flags1 & 120) != 0) {
#line 621
    goto cleanup;
  }
#line 622
  if (((int )h.flags2 & 15) != 0) {
#line 624
    fdns_errno = (int )h.flags2 & 15;
#line 625
    goto cleanup;
  }
  {
#line 627
  h.ancount = ntohs(h.ancount);
  }
#line 628
  if ((int )h.ancount < 1) {
#line 629
    fdns_errno = 3;
#line 631
    goto cleanup;
  }
  {
#line 634
  i = 0;
#line 635
  q = 0;
#line 636
  l -= 12;
#line 637
  h.qdcount = ntohs(h.qdcount);
  }
  {
#line 638
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 638
    if (q < (int )h.qdcount) {
#line 638
      if (! (i < l)) {
#line 638
        goto while_break___0;
      }
    } else {
#line 638
      goto while_break___0;
    }
#line 640
    if ((int )h.payload[i] > 63) {
#line 642
      i += 6;
#line 643
      q ++;
    } else
#line 647
    if ((int )h.payload[i] == 0) {
#line 649
      q ++;
#line 650
      i += 5;
    } else {
#line 653
      i += (int )h.payload[i] + 1;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 657
  curanswer = 0;
  {
#line 658
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 658
    if (! (curanswer < (int )h.ancount)) {
#line 658
      goto while_break___1;
    }
#line 660
    q = 0;
    {
#line 661
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 661
      if (q == 0) {
#line 661
        if (! (i < l)) {
#line 661
          goto while_break___2;
        }
      } else {
#line 661
        goto while_break___2;
      }
#line 663
      if ((int )h.payload[i] > 63) {
#line 665
        i += 2;
#line 666
        q = 1;
      } else
#line 670
      if ((int )h.payload[i] == 0) {
#line 672
        i ++;
#line 673
        q = 1;
      } else {
#line 676
        i += (int )h.payload[i] + 1;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
#line 679
    if (l - i < 10) {
#line 680
      goto cleanup;
    }
#line 681
    rr = (struct s_rr_middle *)(& h.payload[i]);
#line 682
    src = (char *)rr;
#line 683
    dst = (char *)(& rrbacking);
#line 684
    bytes = (int )sizeof(rrbacking);
    {
#line 684
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 684
      if (! bytes) {
#line 684
        goto while_break___3;
      }
#line 685
      tmp___1 = dst;
#line 685
      dst ++;
#line 685
      tmp___2 = src;
#line 685
      src ++;
#line 685
      *tmp___1 = *tmp___2;
#line 684
      bytes --;
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 686
    rr = & rrbacking;
#line 687
    i += 10;
#line 688
    rr->rdlength = ntohs(rr->rdlength);
#line 689
    tmp___3 = ntohs(rr->type);
    }
#line 689
    if ((int )tmp___3 != (int )c->type) {
#line 691
      curanswer ++;
#line 692
      i += (int )rr->rdlength;
#line 693
      goto while_continue___1;
    }
    {
#line 695
    tmp___4 = ntohs(rr->class);
    }
#line 695
    if ((int )tmp___4 != (int )c->class) {
#line 697
      curanswer ++;
#line 698
      i += (int )rr->rdlength;
#line 699
      goto while_continue___1;
    }
#line 701
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 704
  if (curanswer == (int )h.ancount) {
#line 705
    goto cleanup;
  }
#line 706
  if (i + (int )rr->rdlength > l) {
#line 707
    goto cleanup;
  }
#line 708
  if ((int )rr->rdlength > 1023) {
#line 709
    goto cleanup;
  }
  {
#line 711
  fdns_errno = 0;
#line 712
  memcpy((void */* __restrict  */)(result.text), (void const   */* __restrict  */)(& h.payload[i]),
         (size_t )rr->rdlength);
#line 713
  result.text[rr->rdlength] = (char )'\000';
  }
  cleanup: 
  {
#line 717
  list_remove(CONNECTIONS, node);
#line 718
  node_free(node);
#line 719
  close(c->fd);
#line 720
  fdns_fdinuse --;
#line 721
  _MyFree((void **)(& c));
  }
#line 723
  return (& result);
}
}
#line 731 "/home/june/collector/temp/bopm-3.1.3/src/firedns.c"
static struct pollfd *ufds___3  =    (struct pollfd *)((void *)0);
#line 726 "/home/june/collector/temp/bopm-3.1.3/src/firedns.c"
void firedns_cycle(void) 
{ 
  node_t *node ;
  node_t *next ;
  struct s_connection *p ;
  struct firedns_result *res ;
  struct firedns_result new_result ;
  int fd ;
  unsigned int size ;
  unsigned int i ;
  time_t timenow ;
  void *tmp___0 ;
  int tmp___1 ;

  {
#line 736
  if (CONNECTIONS->elements == 0) {
#line 737
    return;
  }
#line 739
  if ((unsigned long )ufds___3 == (unsigned long )((void *)0)) {
    {
#line 740
    tmp___0 = MyMalloc(sizeof(*ufds___3) * (unsigned long )OptionsItem->dns_fdlimit);
#line 740
    ufds___3 = (struct pollfd *)tmp___0;
    }
  }
  {
#line 742
  time(& timenow);
#line 743
  size = 0U;
#line 745
  node = CONNECTIONS->head;
  }
#line 745
  if (node) {
#line 745
    next = node->next;
  } else {
#line 745
    next = (node_t *)((void *)0);
  }
  {
#line 745
  while (1) {
    while_continue: /* CIL Label */ ;
#line 745
    if (! ((unsigned long )node != (unsigned long )((void *)0))) {
#line 745
      goto while_break;
    }
#line 747
    if (size >= OptionsItem->dns_fdlimit) {
#line 748
      goto while_break;
    }
#line 750
    p = (struct s_connection *)node->data;
#line 752
    if (p->fd < 0) {
#line 753
      goto __Cont;
    }
#line 755
    if (p->fd > 0) {
#line 755
      if (p->start + 5L < timenow) {
        {
#line 758
        list_remove(CONNECTIONS, node);
#line 759
        node_free(node);
#line 761
        memset((void *)(new_result.text), 0, sizeof(new_result.text));
#line 762
        new_result.info = p->info;
#line 763
        strncpy((char */* __restrict  */)(new_result.lookup), (char const   */* __restrict  */)(p->lookup),
                (size_t )256);
#line 765
        close(p->fd);
#line 766
        fdns_fdinuse --;
#line 767
        _MyFree((void **)(& p));
#line 769
        fdns_errno = 6;
        }
#line 771
        if ((unsigned long )new_result.info != (unsigned long )((void *)0)) {
          {
#line 772
          dnsbl_result(& new_result);
          }
        }
#line 774
        goto __Cont;
      }
    }
#line 777
    (ufds___3 + size)->events = (short)0;
#line 778
    (ufds___3 + size)->revents = (short)0;
#line 779
    (ufds___3 + size)->fd = p->fd;
#line 780
    (ufds___3 + size)->events = (short)1;
#line 782
    size ++;
    __Cont: /* CIL Label */ 
#line 745
    node = next;
#line 745
    if (node) {
#line 745
      next = node->next;
    } else {
#line 745
      next = (node_t *)((void *)0);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 786
  tmp___1 = poll(ufds___3, (nfds_t )size, 0);
  }
  {
#line 789
  if (tmp___1 == 0) {
#line 789
    goto case_0;
  }
#line 789
  if (tmp___1 == -1) {
#line 789
    goto case_0;
  }
#line 786
  goto switch_break;
  case_0: /* CIL Label */ 
  case_neg_1: /* CIL Label */ 
#line 790
  return;
  switch_break: /* CIL Label */ ;
  }
#line 793
  node = CONNECTIONS->head;
#line 793
  if (node) {
#line 793
    next = node->next;
  } else {
#line 793
    next = (node_t *)((void *)0);
  }
  {
#line 793
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 793
    if (! ((unsigned long )node != (unsigned long )((void *)0))) {
#line 793
      goto while_break___0;
    }
#line 795
    p = (struct s_connection *)node->data;
#line 796
    if (p->fd > 0) {
#line 798
      i = 0U;
      {
#line 798
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 798
        if (! (i < size)) {
#line 798
          goto while_break___1;
        }
#line 800
        if ((int )(ufds___3 + i)->revents & 1) {
#line 800
          if ((ufds___3 + i)->fd == p->fd) {
            {
#line 802
            fd = p->fd;
#line 803
            res = firedns_getresult((int const   )fd);
            }
#line 805
            if ((unsigned long )res != (unsigned long )((void *)0)) {
#line 805
              if ((unsigned long )res->info != (unsigned long )((void *)0)) {
                {
#line 806
                dnsbl_result(res);
                }
              }
            }
#line 807
            goto while_break___1;
          }
        }
#line 798
        i ++;
      }
      while_break___1: /* CIL Label */ ;
      }
    } else
#line 811
    if (fdns_fdinuse < OptionsItem->dns_fdlimit) {
      {
#line 813
      firedns_doquery(p);
      }
    }
#line 793
    node = next;
#line 793
    if (node) {
#line 793
      next = node->next;
    } else {
#line 793
      next = (node_t *)((void *)0);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 816
  return;
}
}
#line 818 "/home/june/collector/temp/bopm-3.1.3/src/firedns.c"
char *firedns_strerror(int error ) 
{ 
  int *tmp___0 ;
  char *tmp___1 ;

  {
#line 820
  if (error == 7) {
    {
#line 821
    tmp___0 = __errno_location();
#line 821
    tmp___1 = strerror(*tmp___0);
    }
#line 821
    return (tmp___1);
  }
#line 822
  return (errors[error]);
}
}
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 242
extern int fflush(FILE *__stream ) ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 846
extern void perror(char const   *__s ) ;
#line 205 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__)) strftime)(char * __restrict  __s ,
                                                                                  size_t __maxsize ,
                                                                                  char const   * __restrict  __format ,
                                                                                  struct tm  const  * __restrict  __tp ) ;
#line 239
extern  __attribute__((__nothrow__)) struct tm *( __attribute__((__leaf__)) gmtime)(time_t const   *__timer ) ;
#line 4 "/home/june/collector/temp/bopm-3.1.3/src/log.h"
void log_open(char *filename ) ;
#line 5
void log_close(void) ;
#line 6
void scanlog_open(char *filename ) ;
#line 7
void scanlog_close(void) ;
#line 44 "/home/june/collector/temp/bopm-3.1.3/src/log.c"
FILE *logfile  ;
#line 45 "/home/june/collector/temp/bopm-3.1.3/src/log.c"
FILE *scanlogfile  ;
#line 47 "/home/june/collector/temp/bopm-3.1.3/src/log.c"
void log_open(char *filename ) 
{ 


  {
  {
#line 49
  logfile = fopen((char const   */* __restrict  */)filename, (char const   */* __restrict  */)"a");
  }
#line 51
  if (! logfile) {
    {
#line 53
    perror("Cannot open log file. Aborting.");
#line 54
    exit(1);
    }
  }
#line 57
  return;
}
}
#line 59 "/home/june/collector/temp/bopm-3.1.3/src/log.c"
void log_close(void) 
{ 


  {
  {
#line 61
  fclose(logfile);
  }
#line 62
  return;
}
}
#line 64 "/home/june/collector/temp/bopm-3.1.3/src/log.c"
void scanlog_open(char *filename ) 
{ 
  int *tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 66
  scanlogfile = fopen((char const   */* __restrict  */)filename, (char const   */* __restrict  */)"a");
  }
#line 68
  if (! scanlogfile) {
    {
#line 70
    tmp___0 = __errno_location();
#line 70
    tmp___1 = strerror(*tmp___0);
#line 70
    log_printf((char *)"Failed to open scan log file: %s", tmp___1);
    }
  }
#line 72
  return;
}
}
#line 74 "/home/june/collector/temp/bopm-3.1.3/src/log.c"
void scanlog_close(void) 
{ 


  {
#line 76
  if (scanlogfile) {
    {
#line 77
    fclose(scanlogfile);
    }
  }
#line 78
  return;
}
}
#line 80 "/home/june/collector/temp/bopm-3.1.3/src/log.c"
void ( /* format attribute */  log_printf)(char *data  , ...) 
{ 
  char data2[513] ;
  char buf_present[25] ;
  va_list arglist ;
  time_t present ;
  struct tm *tm_present ;

  {
#line 88
  if (! OPT_DEBUG) {
#line 88
    if (! logfile) {
#line 89
      return;
    }
  }
  {
#line 91
  time(& present);
#line 92
  tm_present = gmtime((time_t const   *)(& present));
#line 93
  strftime((char */* __restrict  */)(buf_present), sizeof(buf_present), (char const   */* __restrict  */)"%b %d %H:%M:%S %Y",
           (struct tm  const  */* __restrict  */)tm_present);
#line 95
  __builtin_va_start(arglist, data);
#line 96
  vsnprintf((char */* __restrict  */)(data2), (size_t )512, (char const   */* __restrict  */)data,
            arglist);
#line 97
  __builtin_va_end(arglist);
  }
#line 99
  if (OPT_DEBUG) {
    {
#line 101
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%s] %s\n",
            buf_present, data2);
    }
  } else {
    {
#line 105
    fprintf((FILE */* __restrict  */)logfile, (char const   */* __restrict  */)"[%s] %s\n",
            buf_present, data2);
#line 106
    fflush(logfile);
    }
  }
#line 108
  return;
}
}
#line 434 "/usr/include/libio.h"
extern int _IO_getc(_IO_FILE *__fp ) ;
#line 168 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 169
extern struct _IO_FILE *stdout ;
#line 709
extern size_t fread(void * __restrict  __ptr , size_t __size , size_t __n , FILE * __restrict  __stream ) ;
#line 715
extern size_t fwrite(void const   * __restrict  __ptr , size_t __size , size_t __n ,
                     FILE * __restrict  __s ) ;
#line 826
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) clearerr)(FILE *__stream ) ;
#line 830
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ferror)(FILE *__stream ) ;
#line 858
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) fileno)(FILE *__stream ) ;
#line 147 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 480
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 154 "config-lexer.c"
int yyleng  ;
#line 156
FILE *yyin ;
#line 156
FILE *yyout ;
#line 256 "config-lexer.c"
static size_t yy_buffer_stack_top  =    (size_t )0;
#line 257 "config-lexer.c"
static size_t yy_buffer_stack_max  =    (size_t )0;
#line 258 "config-lexer.c"
static YY_BUFFER_STATE *yy_buffer_stack  =    (YY_BUFFER_STATE *)0;
#line 276 "config-lexer.c"
static char yy_hold_char  ;
#line 277 "config-lexer.c"
static int yy_n_chars  ;
#line 281 "config-lexer.c"
static char *yy_c_buf_p  =    (char *)0;
#line 282 "config-lexer.c"
static int yy_init  =    0;
#line 283 "config-lexer.c"
static int yy_start  =    0;
#line 288 "config-lexer.c"
static int yy_did_buffer_switch_on_eof  ;
#line 290
void yyrestart(FILE *input_file ) ;
#line 291
void yy_switch_to_buffer(YY_BUFFER_STATE new_buffer ) ;
#line 292
YY_BUFFER_STATE yy_create_buffer(FILE *file , int size ) ;
#line 293
void yy_delete_buffer(YY_BUFFER_STATE b ) ;
#line 294
void yy_flush_buffer(YY_BUFFER_STATE b ) ;
#line 295
void yypush_buffer_state(YY_BUFFER_STATE new_buffer ) ;
#line 296
void yypop_buffer_state(void) ;
#line 298
static void yyensure_buffer_stack(void) ;
#line 299
static void yy_load_buffer_state(void) ;
#line 300
static void yy_init_buffer(YY_BUFFER_STATE b , FILE *file ) ;
#line 304
YY_BUFFER_STATE yy_scan_buffer(char *base , yy_size_t size ) ;
#line 305
YY_BUFFER_STATE yy_scan_string(char const   *yystr ) ;
#line 306
YY_BUFFER_STATE yy_scan_bytes(char const   *yybytes , int _yybytes_len ) ;
#line 308
void *yyalloc(yy_size_t size ) ;
#line 309
void *yyrealloc(void *ptr , yy_size_t size ) ;
#line 310
void yyfree(void *ptr ) ;
#line 343 "config-lexer.c"
FILE *yyin  =    (FILE *)0;
#line 343 "config-lexer.c"
FILE *yyout  =    (FILE *)0;
#line 347
int yylineno ;
#line 349 "config-lexer.c"
int yylineno  =    1;
#line 351 "config-lexer.c"
char *yytext  ;
#line 354
static yy_state_type yy_get_previous_state(void) ;
#line 355
static yy_state_type yy_try_NUL_trans(yy_state_type yy_current_state ) ;
#line 356
static int yy_get_next_buffer(void) ;
#line 357
static void yy_fatal_error(char const   *msg___0 ) ;
#line 379 "config-lexer.c"
static flex_int16_t const   yy_accept[284]  = 
#line 379
  {      (flex_int16_t const   )0,      (flex_int16_t const   )61,      (flex_int16_t const   )61,      (flex_int16_t const   )64, 
        (flex_int16_t const   )62,      (flex_int16_t const   )61,      (flex_int16_t const   )60,      (flex_int16_t const   )62, 
        (flex_int16_t const   )2,      (flex_int16_t const   )62,      (flex_int16_t const   )53,      (flex_int16_t const   )62, 
        (flex_int16_t const   )62,      (flex_int16_t const   )62,      (flex_int16_t const   )62,      (flex_int16_t const   )62, 
        (flex_int16_t const   )62,      (flex_int16_t const   )62,      (flex_int16_t const   )62,      (flex_int16_t const   )62, 
        (flex_int16_t const   )62,      (flex_int16_t const   )62,      (flex_int16_t const   )62,      (flex_int16_t const   )62, 
        (flex_int16_t const   )62,      (flex_int16_t const   )62,      (flex_int16_t const   )62,      (flex_int16_t const   )62, 
        (flex_int16_t const   )62,      (flex_int16_t const   )62,      (flex_int16_t const   )62,      (flex_int16_t const   )61, 
        (flex_int16_t const   )60,      (flex_int16_t const   )0,      (flex_int16_t const   )3,      (flex_int16_t const   )2, 
        (flex_int16_t const   )1,      (flex_int16_t const   )53,      (flex_int16_t const   )0,      (flex_int16_t const   )0, 
        (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0, 
        (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )13,      (flex_int16_t const   )0, 
        (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0, 
        (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0, 
        (flex_int16_t const   )0,      (flex_int16_t const   )58,      (flex_int16_t const   )0,      (flex_int16_t const   )56, 
        (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0, 
        (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0, 
        (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0, 
        (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0, 
        (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0, 
        (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0, 
        (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0, 
        (flex_int16_t const   )0,      (flex_int16_t const   )15,      (flex_int16_t const   )17,      (flex_int16_t const   )0, 
        (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0, 
        (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )59,      (flex_int16_t const   )0, 
        (flex_int16_t const   )26,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0, 
        (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0, 
        (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0, 
        (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0, 
        (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0, 
        (flex_int16_t const   )0,      (flex_int16_t const   )55,      (flex_int16_t const   )4,      (flex_int16_t const   )0, 
        (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0, 
        (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )47, 
        (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )18,      (flex_int16_t const   )0, 
        (flex_int16_t const   )20,      (flex_int16_t const   )21,      (flex_int16_t const   )0,      (flex_int16_t const   )23, 
        (flex_int16_t const   )25,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0, 
        (flex_int16_t const   )0,      (flex_int16_t const   )31,      (flex_int16_t const   )0,      (flex_int16_t const   )0, 
        (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0, 
        (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0, 
        (flex_int16_t const   )54,      (flex_int16_t const   )43,      (flex_int16_t const   )44,      (flex_int16_t const   )0, 
        (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0, 
        (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0, 
        (flex_int16_t const   )57,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )16, 
        (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0, 
        (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0, 
        (flex_int16_t const   )0,      (flex_int16_t const   )34,      (flex_int16_t const   )0,      (flex_int16_t const   )0, 
        (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0, 
        (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )46, 
        (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0, 
        (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )12, 
        (flex_int16_t const   )0,      (flex_int16_t const   )14,      (flex_int16_t const   )0,      (flex_int16_t const   )0, 
        (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0, 
        (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )52, 
        (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )38, 
        (flex_int16_t const   )49,      (flex_int16_t const   )50,      (flex_int16_t const   )0,      (flex_int16_t const   )0, 
        (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0, 
        (flex_int16_t const   )7,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0, 
        (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0, 
        (flex_int16_t const   )0,      (flex_int16_t const   )27,      (flex_int16_t const   )0,      (flex_int16_t const   )29, 
        (flex_int16_t const   )30,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )35, 
        (flex_int16_t const   )36,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )42, 
        (flex_int16_t const   )0,      (flex_int16_t const   )51,      (flex_int16_t const   )0,      (flex_int16_t const   )0, 
        (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )11, 
        (flex_int16_t const   )48,      (flex_int16_t const   )19,      (flex_int16_t const   )22,      (flex_int16_t const   )24, 
        (flex_int16_t const   )28,      (flex_int16_t const   )32,      (flex_int16_t const   )33,      (flex_int16_t const   )37, 
        (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )45, 
        (flex_int16_t const   )0,      (flex_int16_t const   )6,      (flex_int16_t const   )8,      (flex_int16_t const   )0, 
        (flex_int16_t const   )0,      (flex_int16_t const   )39,      (flex_int16_t const   )0,      (flex_int16_t const   )0, 
        (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )10,      (flex_int16_t const   )0, 
        (flex_int16_t const   )0,      (flex_int16_t const   )5,      (flex_int16_t const   )9,      (flex_int16_t const   )40, 
        (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )41,      (flex_int16_t const   )0};
#line 414 "config-lexer.c"
static flex_int32_t const   yy_ec[256]  = 
#line 414
  {      (flex_int32_t const   )0,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )2,      (flex_int32_t const   )3,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )2,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )2,      (flex_int32_t const   )1,      (flex_int32_t const   )4,      (flex_int32_t const   )5, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )6,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )7, 
        (flex_int32_t const   )8,      (flex_int32_t const   )8,      (flex_int32_t const   )8,      (flex_int32_t const   )8, 
        (flex_int32_t const   )9,      (flex_int32_t const   )10,      (flex_int32_t const   )8,      (flex_int32_t const   )8, 
        (flex_int32_t const   )8,      (flex_int32_t const   )8,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )12,      (flex_int32_t const   )13,      (flex_int32_t const   )14, 
        (flex_int32_t const   )15,      (flex_int32_t const   )16,      (flex_int32_t const   )17,      (flex_int32_t const   )18, 
        (flex_int32_t const   )19,      (flex_int32_t const   )20,      (flex_int32_t const   )1,      (flex_int32_t const   )21, 
        (flex_int32_t const   )22,      (flex_int32_t const   )23,      (flex_int32_t const   )24,      (flex_int32_t const   )25, 
        (flex_int32_t const   )26,      (flex_int32_t const   )1,      (flex_int32_t const   )27,      (flex_int32_t const   )28, 
        (flex_int32_t const   )29,      (flex_int32_t const   )30,      (flex_int32_t const   )31,      (flex_int32_t const   )32, 
        (flex_int32_t const   )33,      (flex_int32_t const   )34,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )11, 
        (flex_int32_t const   )1,      (flex_int32_t const   )12,      (flex_int32_t const   )13,      (flex_int32_t const   )14, 
        (flex_int32_t const   )15,      (flex_int32_t const   )16,      (flex_int32_t const   )17,      (flex_int32_t const   )18, 
        (flex_int32_t const   )19,      (flex_int32_t const   )20,      (flex_int32_t const   )1,      (flex_int32_t const   )21, 
        (flex_int32_t const   )22,      (flex_int32_t const   )23,      (flex_int32_t const   )24,      (flex_int32_t const   )25, 
        (flex_int32_t const   )26,      (flex_int32_t const   )1,      (flex_int32_t const   )27,      (flex_int32_t const   )28, 
        (flex_int32_t const   )29,      (flex_int32_t const   )30,      (flex_int32_t const   )31,      (flex_int32_t const   )32, 
        (flex_int32_t const   )33,      (flex_int32_t const   )34,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1};
#line 446 "config-lexer.c"
static flex_int32_t const   yy_meta[35]  = 
#line 446
  {      (flex_int32_t const   )0,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )2, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1};
#line 454 "config-lexer.c"
static flex_int16_t const   yy_base[287]  = 
#line 454
  {      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )297, 
        (flex_int16_t const   )298,      (flex_int16_t const   )294,      (flex_int16_t const   )0,      (flex_int16_t const   )32, 
        (flex_int16_t const   )0,      (flex_int16_t const   )289,      (flex_int16_t const   )29,      (flex_int16_t const   )262, 
        (flex_int16_t const   )28,      (flex_int16_t const   )22,      (flex_int16_t const   )269,      (flex_int16_t const   )259, 
        (flex_int16_t const   )30,      (flex_int16_t const   )262,      (flex_int16_t const   )19,      (flex_int16_t const   )32, 
        (flex_int16_t const   )32,      (flex_int16_t const   )39,      (flex_int16_t const   )32,      (flex_int16_t const   )49, 
        (flex_int16_t const   )37,      (flex_int16_t const   )52,      (flex_int16_t const   )51,      (flex_int16_t const   )262, 
        (flex_int16_t const   )270,      (flex_int16_t const   )268,      (flex_int16_t const   )271,      (flex_int16_t const   )284, 
        (flex_int16_t const   )0,      (flex_int16_t const   )69,      (flex_int16_t const   )298,      (flex_int16_t const   )0, 
        (flex_int16_t const   )298,      (flex_int16_t const   )71,      (flex_int16_t const   )273,      (flex_int16_t const   )260, 
        (flex_int16_t const   )271,      (flex_int16_t const   )270,      (flex_int16_t const   )257,      (flex_int16_t const   )252, 
        (flex_int16_t const   )263,      (flex_int16_t const   )256,      (flex_int16_t const   )298,      (flex_int16_t const   )248, 
        (flex_int16_t const   )245,      (flex_int16_t const   )261,      (flex_int16_t const   )240,      (flex_int16_t const   )253, 
        (flex_int16_t const   )42,      (flex_int16_t const   )257,      (flex_int16_t const   )248,      (flex_int16_t const   )252, 
        (flex_int16_t const   )255,      (flex_int16_t const   )298,      (flex_int16_t const   )251,      (flex_int16_t const   )298, 
        (flex_int16_t const   )66,      (flex_int16_t const   )239,      (flex_int16_t const   )239,      (flex_int16_t const   )250, 
        (flex_int16_t const   )237,      (flex_int16_t const   )238,      (flex_int16_t const   )71,      (flex_int16_t const   )232, 
        (flex_int16_t const   )249,      (flex_int16_t const   )60,      (flex_int16_t const   )246,      (flex_int16_t const   )232, 
        (flex_int16_t const   )235,      (flex_int16_t const   )227,      (flex_int16_t const   )230,      (flex_int16_t const   )239, 
        (flex_int16_t const   )229,      (flex_int16_t const   )229,      (flex_int16_t const   )224,      (flex_int16_t const   )217, 
        (flex_int16_t const   )239,      (flex_int16_t const   )235,      (flex_int16_t const   )224,      (flex_int16_t const   )223, 
        (flex_int16_t const   )75,      (flex_int16_t const   )223,      (flex_int16_t const   )217,      (flex_int16_t const   )218, 
        (flex_int16_t const   )223,      (flex_int16_t const   )298,      (flex_int16_t const   )298,      (flex_int16_t const   )218, 
        (flex_int16_t const   )220,      (flex_int16_t const   )229,      (flex_int16_t const   )223,      (flex_int16_t const   )222, 
        (flex_int16_t const   )223,      (flex_int16_t const   )215,      (flex_int16_t const   )298,      (flex_int16_t const   )208, 
        (flex_int16_t const   )298,      (flex_int16_t const   )214,      (flex_int16_t const   )205,      (flex_int16_t const   )215, 
        (flex_int16_t const   )214,      (flex_int16_t const   )201,      (flex_int16_t const   )200,      (flex_int16_t const   )206, 
        (flex_int16_t const   )205,      (flex_int16_t const   )197,      (flex_int16_t const   )201,      (flex_int16_t const   )209, 
        (flex_int16_t const   )192,      (flex_int16_t const   )201,      (flex_int16_t const   )203,      (flex_int16_t const   )204, 
        (flex_int16_t const   )203,      (flex_int16_t const   )202,      (flex_int16_t const   )190,      (flex_int16_t const   )188, 
        (flex_int16_t const   )197,      (flex_int16_t const   )298,      (flex_int16_t const   )298,      (flex_int16_t const   )184, 
        (flex_int16_t const   )192,      (flex_int16_t const   )188,      (flex_int16_t const   )184,      (flex_int16_t const   )193, 
        (flex_int16_t const   )187,      (flex_int16_t const   )182,      (flex_int16_t const   )191,      (flex_int16_t const   )180, 
        (flex_int16_t const   )176,      (flex_int16_t const   )188,      (flex_int16_t const   )298,      (flex_int16_t const   )176, 
        (flex_int16_t const   )298,      (flex_int16_t const   )298,      (flex_int16_t const   )190,      (flex_int16_t const   )173, 
        (flex_int16_t const   )298,      (flex_int16_t const   )175,      (flex_int16_t const   )167,      (flex_int16_t const   )173, 
        (flex_int16_t const   )177,      (flex_int16_t const   )298,      (flex_int16_t const   )171,      (flex_int16_t const   )171, 
        (flex_int16_t const   )160,      (flex_int16_t const   )177,      (flex_int16_t const   )68,      (flex_int16_t const   )169, 
        (flex_int16_t const   )175,      (flex_int16_t const   )162,      (flex_int16_t const   )173,      (flex_int16_t const   )163, 
        (flex_int16_t const   )298,      (flex_int16_t const   )298,      (flex_int16_t const   )163,      (flex_int16_t const   )157, 
        (flex_int16_t const   )173,      (flex_int16_t const   )160,      (flex_int16_t const   )161,      (flex_int16_t const   )166, 
        (flex_int16_t const   )165,      (flex_int16_t const   )165,      (flex_int16_t const   )168,      (flex_int16_t const   )149, 
        (flex_int16_t const   )298,      (flex_int16_t const   )152,      (flex_int16_t const   )160,      (flex_int16_t const   )298, 
        (flex_int16_t const   )159,      (flex_int16_t const   )160,      (flex_int16_t const   )157,      (flex_int16_t const   )148, 
        (flex_int16_t const   )146,      (flex_int16_t const   )143,      (flex_int16_t const   )147,      (flex_int16_t const   )154, 
        (flex_int16_t const   )155,      (flex_int16_t const   )298,      (flex_int16_t const   )139,      (flex_int16_t const   )140, 
        (flex_int16_t const   )148,      (flex_int16_t const   )151,      (flex_int16_t const   )135,      (flex_int16_t const   )84, 
        (flex_int16_t const   )132,      (flex_int16_t const   )130,      (flex_int16_t const   )147,      (flex_int16_t const   )298, 
        (flex_int16_t const   )129,      (flex_int16_t const   )136,      (flex_int16_t const   )136,      (flex_int16_t const   )133, 
        (flex_int16_t const   )136,      (flex_int16_t const   )131,      (flex_int16_t const   )74,      (flex_int16_t const   )298, 
        (flex_int16_t const   )124,      (flex_int16_t const   )298,      (flex_int16_t const   )139,      (flex_int16_t const   )131, 
        (flex_int16_t const   )122,      (flex_int16_t const   )120,      (flex_int16_t const   )120,      (flex_int16_t const   )123, 
        (flex_int16_t const   )129,      (flex_int16_t const   )119,      (flex_int16_t const   )120,      (flex_int16_t const   )298, 
        (flex_int16_t const   )124,      (flex_int16_t const   )114,      (flex_int16_t const   )120,      (flex_int16_t const   )298, 
        (flex_int16_t const   )298,      (flex_int16_t const   )298,      (flex_int16_t const   )128,      (flex_int16_t const   )109, 
        (flex_int16_t const   )114,      (flex_int16_t const   )120,      (flex_int16_t const   )111,      (flex_int16_t const   )106, 
        (flex_int16_t const   )298,      (flex_int16_t const   )117,      (flex_int16_t const   )112,      (flex_int16_t const   )104, 
        (flex_int16_t const   )105,      (flex_int16_t const   )100,      (flex_int16_t const   )113,      (flex_int16_t const   )111, 
        (flex_int16_t const   )95,      (flex_int16_t const   )298,      (flex_int16_t const   )110,      (flex_int16_t const   )298, 
        (flex_int16_t const   )298,      (flex_int16_t const   )102,      (flex_int16_t const   )107,      (flex_int16_t const   )298, 
        (flex_int16_t const   )298,      (flex_int16_t const   )100,      (flex_int16_t const   )76,      (flex_int16_t const   )298, 
        (flex_int16_t const   )105,      (flex_int16_t const   )298,      (flex_int16_t const   )95,      (flex_int16_t const   )90, 
        (flex_int16_t const   )85,      (flex_int16_t const   )94,      (flex_int16_t const   )91,      (flex_int16_t const   )298, 
        (flex_int16_t const   )298,      (flex_int16_t const   )298,      (flex_int16_t const   )298,      (flex_int16_t const   )298, 
        (flex_int16_t const   )298,      (flex_int16_t const   )298,      (flex_int16_t const   )298,      (flex_int16_t const   )298, 
        (flex_int16_t const   )89,      (flex_int16_t const   )89,      (flex_int16_t const   )84,      (flex_int16_t const   )298, 
        (flex_int16_t const   )80,      (flex_int16_t const   )298,      (flex_int16_t const   )298,      (flex_int16_t const   )91, 
        (flex_int16_t const   )87,      (flex_int16_t const   )298,      (flex_int16_t const   )82,      (flex_int16_t const   )81, 
        (flex_int16_t const   )83,      (flex_int16_t const   )72,      (flex_int16_t const   )298,      (flex_int16_t const   )71, 
        (flex_int16_t const   )79,      (flex_int16_t const   )298,      (flex_int16_t const   )298,      (flex_int16_t const   )298, 
        (flex_int16_t const   )74,      (flex_int16_t const   )49,      (flex_int16_t const   )298,      (flex_int16_t const   )298, 
        (flex_int16_t const   )59,      (flex_int16_t const   )104,      (flex_int16_t const   )51};
#line 489 "config-lexer.c"
static flex_int16_t const   yy_def[287]  = 
#line 489
  {      (flex_int16_t const   )0,      (flex_int16_t const   )283,      (flex_int16_t const   )1,      (flex_int16_t const   )283, 
        (flex_int16_t const   )283,      (flex_int16_t const   )283,      (flex_int16_t const   )284,      (flex_int16_t const   )285, 
        (flex_int16_t const   )286,      (flex_int16_t const   )283,      (flex_int16_t const   )283,      (flex_int16_t const   )283, 
        (flex_int16_t const   )283,      (flex_int16_t const   )283,      (flex_int16_t const   )283,      (flex_int16_t const   )283, 
        (flex_int16_t const   )283,      (flex_int16_t const   )283,      (flex_int16_t const   )283,      (flex_int16_t const   )283, 
        (flex_int16_t const   )283,      (flex_int16_t const   )283,      (flex_int16_t const   )283,      (flex_int16_t const   )283, 
        (flex_int16_t const   )283,      (flex_int16_t const   )283,      (flex_int16_t const   )283,      (flex_int16_t const   )283, 
        (flex_int16_t const   )283,      (flex_int16_t const   )283,      (flex_int16_t const   )283,      (flex_int16_t const   )283, 
        (flex_int16_t const   )284,      (flex_int16_t const   )285,      (flex_int16_t const   )283,      (flex_int16_t const   )286, 
        (flex_int16_t const   )283,      (flex_int16_t const   )283,      (flex_int16_t const   )283,      (flex_int16_t const   )283, 
        (flex_int16_t const   )283,      (flex_int16_t const   )283,      (flex_int16_t const   )283,      (flex_int16_t const   )283, 
        (flex_int16_t const   )283,      (flex_int16_t const   )283,      (flex_int16_t const   )283,      (flex_int16_t const   )283, 
        (flex_int16_t const   )283,      (flex_int16_t const   )283,      (flex_int16_t const   )283,      (flex_int16_t const   )283, 
        (flex_int16_t const   )283,      (flex_int16_t const   )283,      (flex_int16_t const   )283,      (flex_int16_t const   )283, 
        (flex_int16_t const   )283,      (flex_int16_t const   )283,      (flex_int16_t const   )283,      (flex_int16_t const   )283, 
        (flex_int16_t const   )283,      (flex_int16_t const   )283,      (flex_int16_t const   )283,      (flex_int16_t const   )283, 
        (flex_int16_t const   )283,      (flex_int16_t const   )283,      (flex_int16_t const   )283,      (flex_int16_t const   )283, 
        (flex_int16_t const   )283,      (flex_int16_t const   )283,      (flex_int16_t const   )283,      (flex_int16_t const   )283, 
        (flex_int16_t const   )283,      (flex_int16_t const   )283,      (flex_int16_t const   )283,      (flex_int16_t const   )283, 
        (flex_int16_t const   )283,      (flex_int16_t const   )283,      (flex_int16_t const   )283,      (flex_int16_t const   )283, 
        (flex_int16_t const   )283,      (flex_int16_t const   )283,      (flex_int16_t const   )283,      (flex_int16_t const   )283, 
        (flex_int16_t const   )283,      (flex_int16_t const   )283,      (flex_int16_t const   )283,      (flex_int16_t const   )283, 
        (flex_int16_t const   )283,      (flex_int16_t const   )283,      (flex_int16_t const   )283,      (flex_int16_t const   )283, 
        (flex_int16_t const   )283,      (flex_int16_t const   )283,      (flex_int16_t const   )283,      (flex_int16_t const   )283, 
        (flex_int16_t const   )283,      (flex_int16_t const   )283,      (flex_int16_t const   )283,      (flex_int16_t const   )283, 
        (flex_int16_t const   )283,      (flex_int16_t const   )283,      (flex_int16_t const   )283,      (flex_int16_t const   )283, 
        (flex_int16_t const   )283,      (flex_int16_t const   )283,      (flex_int16_t const   )283,      (flex_int16_t const   )283, 
        (flex_int16_t const   )283,      (flex_int16_t const   )283,      (flex_int16_t const   )283,      (flex_int16_t const   )283, 
        (flex_int16_t const   )283,      (flex_int16_t const   )283,      (flex_int16_t const   )283,      (flex_int16_t const   )283, 
        (flex_int16_t const   )283,      (flex_int16_t const   )283,      (flex_int16_t const   )283,      (flex_int16_t const   )283, 
        (flex_int16_t const   )283,      (flex_int16_t const   )283,      (flex_int16_t const   )283,      (flex_int16_t const   )283, 
        (flex_int16_t const   )283,      (flex_int16_t const   )283,      (flex_int16_t const   )283,      (flex_int16_t const   )283, 
        (flex_int16_t const   )283,      (flex_int16_t const   )283,      (flex_int16_t const   )283,      (flex_int16_t const   )283, 
        (flex_int16_t const   )283,      (flex_int16_t const   )283,      (flex_int16_t const   )283,      (flex_int16_t const   )283, 
        (flex_int16_t const   )283,      (flex_int16_t const   )283,      (flex_int16_t const   )283,      (flex_int16_t const   )283, 
        (flex_int16_t const   )283,      (flex_int16_t const   )283,      (flex_int16_t const   )283,      (flex_int16_t const   )283, 
        (flex_int16_t const   )283,      (flex_int16_t const   )283,      (flex_int16_t const   )283,      (flex_int16_t const   )283, 
        (flex_int16_t const   )283,      (flex_int16_t const   )283,      (flex_int16_t const   )283,      (flex_int16_t const   )283, 
        (flex_int16_t const   )283,      (flex_int16_t const   )283,      (flex_int16_t const   )283,      (flex_int16_t const   )283, 
        (flex_int16_t const   )283,      (flex_int16_t const   )283,      (flex_int16_t const   )283,      (flex_int16_t const   )283, 
        (flex_int16_t const   )283,      (flex_int16_t const   )283,      (flex_int16_t const   )283,      (flex_int16_t const   )283, 
        (flex_int16_t const   )283,      (flex_int16_t const   )283,      (flex_int16_t const   )283,      (flex_int16_t const   )283, 
        (flex_int16_t const   )283,      (flex_int16_t const   )283,      (flex_int16_t const   )283,      (flex_int16_t const   )283, 
        (flex_int16_t const   )283,      (flex_int16_t const   )283,      (flex_int16_t const   )283,      (flex_int16_t const   )283, 
        (flex_int16_t const   )283,      (flex_int16_t const   )283,      (flex_int16_t const   )283,      (flex_int16_t const   )283, 
        (flex_int16_t const   )283,      (flex_int16_t const   )283,      (flex_int16_t const   )283,      (flex_int16_t const   )283, 
        (flex_int16_t const   )283,      (flex_int16_t const   )283,      (flex_int16_t const   )283,      (flex_int16_t const   )283, 
        (flex_int16_t const   )283,      (flex_int16_t const   )283,      (flex_int16_t const   )283,      (flex_int16_t const   )283, 
        (flex_int16_t const   )283,      (flex_int16_t const   )283,      (flex_int16_t const   )283,      (flex_int16_t const   )283, 
        (flex_int16_t const   )283,      (flex_int16_t const   )283,      (flex_int16_t const   )283,      (flex_int16_t const   )283, 
        (flex_int16_t const   )283,      (flex_int16_t const   )283,      (flex_int16_t const   )283,      (flex_int16_t const   )283, 
        (flex_int16_t const   )283,      (flex_int16_t const   )283,      (flex_int16_t const   )283,      (flex_int16_t const   )283, 
        (flex_int16_t const   )283,      (flex_int16_t const   )283,      (flex_int16_t const   )283,      (flex_int16_t const   )283, 
        (flex_int16_t const   )283,      (flex_int16_t const   )283,      (flex_int16_t const   )283,      (flex_int16_t const   )283, 
        (flex_int16_t const   )283,      (flex_int16_t const   )283,      (flex_int16_t const   )283,      (flex_int16_t const   )283, 
        (flex_int16_t const   )283,      (flex_int16_t const   )283,      (flex_int16_t const   )283,      (flex_int16_t const   )283, 
        (flex_int16_t const   )283,      (flex_int16_t const   )283,      (flex_int16_t const   )283,      (flex_int16_t const   )283, 
        (flex_int16_t const   )283,      (flex_int16_t const   )283,      (flex_int16_t const   )283,      (flex_int16_t const   )283, 
        (flex_int16_t const   )283,      (flex_int16_t const   )283,      (flex_int16_t const   )283,      (flex_int16_t const   )283, 
        (flex_int16_t const   )283,      (flex_int16_t const   )283,      (flex_int16_t const   )283,      (flex_int16_t const   )283, 
        (flex_int16_t const   )283,      (flex_int16_t const   )283,      (flex_int16_t const   )283,      (flex_int16_t const   )283, 
        (flex_int16_t const   )283,      (flex_int16_t const   )283,      (flex_int16_t const   )283,      (flex_int16_t const   )283, 
        (flex_int16_t const   )283,      (flex_int16_t const   )283,      (flex_int16_t const   )283,      (flex_int16_t const   )283, 
        (flex_int16_t const   )283,      (flex_int16_t const   )283,      (flex_int16_t const   )283,      (flex_int16_t const   )283, 
        (flex_int16_t const   )283,      (flex_int16_t const   )283,      (flex_int16_t const   )283,      (flex_int16_t const   )283, 
        (flex_int16_t const   )283,      (flex_int16_t const   )283,      (flex_int16_t const   )283,      (flex_int16_t const   )283, 
        (flex_int16_t const   )283,      (flex_int16_t const   )283,      (flex_int16_t const   )283,      (flex_int16_t const   )283, 
        (flex_int16_t const   )283,      (flex_int16_t const   )283,      (flex_int16_t const   )283,      (flex_int16_t const   )283, 
        (flex_int16_t const   )283,      (flex_int16_t const   )283,      (flex_int16_t const   )283,      (flex_int16_t const   )283, 
        (flex_int16_t const   )283,      (flex_int16_t const   )283,      (flex_int16_t const   )283,      (flex_int16_t const   )283, 
        (flex_int16_t const   )283,      (flex_int16_t const   )283,      (flex_int16_t const   )283,      (flex_int16_t const   )0, 
        (flex_int16_t const   )283,      (flex_int16_t const   )283,      (flex_int16_t const   )283};
#line 524 "config-lexer.c"
static flex_int16_t const   yy_nxt[333]  = 
#line 524
  {      (flex_int16_t const   )0,      (flex_int16_t const   )4,      (flex_int16_t const   )5,      (flex_int16_t const   )6, 
        (flex_int16_t const   )7,      (flex_int16_t const   )8,      (flex_int16_t const   )4,      (flex_int16_t const   )9, 
        (flex_int16_t const   )10,      (flex_int16_t const   )10,      (flex_int16_t const   )10,      (flex_int16_t const   )4, 
        (flex_int16_t const   )11,      (flex_int16_t const   )12,      (flex_int16_t const   )13,      (flex_int16_t const   )14, 
        (flex_int16_t const   )15,      (flex_int16_t const   )16,      (flex_int16_t const   )4,      (flex_int16_t const   )17, 
        (flex_int16_t const   )18,      (flex_int16_t const   )19,      (flex_int16_t const   )4,      (flex_int16_t const   )20, 
        (flex_int16_t const   )21,      (flex_int16_t const   )22,      (flex_int16_t const   )23,      (flex_int16_t const   )24, 
        (flex_int16_t const   )25,      (flex_int16_t const   )26,      (flex_int16_t const   )27,      (flex_int16_t const   )28, 
        (flex_int16_t const   )29,      (flex_int16_t const   )4,      (flex_int16_t const   )30,      (flex_int16_t const   )34, 
        (flex_int16_t const   )34,      (flex_int16_t const   )37,      (flex_int16_t const   )37,      (flex_int16_t const   )37, 
        (flex_int16_t const   )39,      (flex_int16_t const   )41,      (flex_int16_t const   )45,      (flex_int16_t const   )48, 
        (flex_int16_t const   )52,      (flex_int16_t const   )46,      (flex_int16_t const   )49,      (flex_int16_t const   )42, 
        (flex_int16_t const   )50,      (flex_int16_t const   )58,      (flex_int16_t const   )40,      (flex_int16_t const   )54, 
        (flex_int16_t const   )35,      (flex_int16_t const   )66,      (flex_int16_t const   )51,      (flex_int16_t const   )55, 
        (flex_int16_t const   )59,      (flex_int16_t const   )53,      (flex_int16_t const   )60,      (flex_int16_t const   )56, 
        (flex_int16_t const   )32,      (flex_int16_t const   )61,      (flex_int16_t const   )67,      (flex_int16_t const   )71, 
        (flex_int16_t const   )57,      (flex_int16_t const   )62,      (flex_int16_t const   )68,      (flex_int16_t const   )282, 
        (flex_int16_t const   )69,      (flex_int16_t const   )63,      (flex_int16_t const   )92,      (flex_int16_t const   )72, 
        (flex_int16_t const   )34,      (flex_int16_t const   )34,      (flex_int16_t const   )64,      (flex_int16_t const   )93, 
        (flex_int16_t const   )65,      (flex_int16_t const   )70,      (flex_int16_t const   )73,      (flex_int16_t const   )37, 
        (flex_int16_t const   )37,      (flex_int16_t const   )37,      (flex_int16_t const   )99,      (flex_int16_t const   )107, 
        (flex_int16_t const   )111,      (flex_int16_t const   )74,      (flex_int16_t const   )127,      (flex_int16_t const   )112, 
        (flex_int16_t const   )128,      (flex_int16_t const   )100,      (flex_int16_t const   )183,      (flex_int16_t const   )227, 
        (flex_int16_t const   )184,      (flex_int16_t const   )216,      (flex_int16_t const   )217,      (flex_int16_t const   )101, 
        (flex_int16_t const   )260,      (flex_int16_t const   )108,      (flex_int16_t const   )281,      (flex_int16_t const   )280, 
        (flex_int16_t const   )279,      (flex_int16_t const   )278,      (flex_int16_t const   )261,      (flex_int16_t const   )228, 
        (flex_int16_t const   )262,      (flex_int16_t const   )33,      (flex_int16_t const   )33,      (flex_int16_t const   )277, 
        (flex_int16_t const   )276,      (flex_int16_t const   )275,      (flex_int16_t const   )274,      (flex_int16_t const   )273, 
        (flex_int16_t const   )272,      (flex_int16_t const   )271,      (flex_int16_t const   )270,      (flex_int16_t const   )269, 
        (flex_int16_t const   )268,      (flex_int16_t const   )267,      (flex_int16_t const   )266,      (flex_int16_t const   )265, 
        (flex_int16_t const   )264,      (flex_int16_t const   )263,      (flex_int16_t const   )259,      (flex_int16_t const   )258, 
        (flex_int16_t const   )257,      (flex_int16_t const   )256,      (flex_int16_t const   )255,      (flex_int16_t const   )254, 
        (flex_int16_t const   )253,      (flex_int16_t const   )252,      (flex_int16_t const   )251,      (flex_int16_t const   )250, 
        (flex_int16_t const   )249,      (flex_int16_t const   )248,      (flex_int16_t const   )247,      (flex_int16_t const   )246, 
        (flex_int16_t const   )245,      (flex_int16_t const   )244,      (flex_int16_t const   )243,      (flex_int16_t const   )242, 
        (flex_int16_t const   )241,      (flex_int16_t const   )240,      (flex_int16_t const   )239,      (flex_int16_t const   )238, 
        (flex_int16_t const   )237,      (flex_int16_t const   )236,      (flex_int16_t const   )235,      (flex_int16_t const   )234, 
        (flex_int16_t const   )233,      (flex_int16_t const   )232,      (flex_int16_t const   )231,      (flex_int16_t const   )230, 
        (flex_int16_t const   )229,      (flex_int16_t const   )226,      (flex_int16_t const   )225,      (flex_int16_t const   )224, 
        (flex_int16_t const   )223,      (flex_int16_t const   )222,      (flex_int16_t const   )221,      (flex_int16_t const   )220, 
        (flex_int16_t const   )219,      (flex_int16_t const   )218,      (flex_int16_t const   )215,      (flex_int16_t const   )214, 
        (flex_int16_t const   )213,      (flex_int16_t const   )212,      (flex_int16_t const   )211,      (flex_int16_t const   )210, 
        (flex_int16_t const   )209,      (flex_int16_t const   )208,      (flex_int16_t const   )207,      (flex_int16_t const   )206, 
        (flex_int16_t const   )205,      (flex_int16_t const   )204,      (flex_int16_t const   )203,      (flex_int16_t const   )202, 
        (flex_int16_t const   )201,      (flex_int16_t const   )200,      (flex_int16_t const   )199,      (flex_int16_t const   )198, 
        (flex_int16_t const   )197,      (flex_int16_t const   )196,      (flex_int16_t const   )195,      (flex_int16_t const   )194, 
        (flex_int16_t const   )193,      (flex_int16_t const   )192,      (flex_int16_t const   )191,      (flex_int16_t const   )190, 
        (flex_int16_t const   )189,      (flex_int16_t const   )188,      (flex_int16_t const   )187,      (flex_int16_t const   )186, 
        (flex_int16_t const   )185,      (flex_int16_t const   )182,      (flex_int16_t const   )181,      (flex_int16_t const   )180, 
        (flex_int16_t const   )179,      (flex_int16_t const   )178,      (flex_int16_t const   )177,      (flex_int16_t const   )176, 
        (flex_int16_t const   )175,      (flex_int16_t const   )174,      (flex_int16_t const   )173,      (flex_int16_t const   )172, 
        (flex_int16_t const   )171,      (flex_int16_t const   )170,      (flex_int16_t const   )169,      (flex_int16_t const   )168, 
        (flex_int16_t const   )167,      (flex_int16_t const   )166,      (flex_int16_t const   )165,      (flex_int16_t const   )164, 
        (flex_int16_t const   )163,      (flex_int16_t const   )162,      (flex_int16_t const   )161,      (flex_int16_t const   )160, 
        (flex_int16_t const   )159,      (flex_int16_t const   )158,      (flex_int16_t const   )157,      (flex_int16_t const   )156, 
        (flex_int16_t const   )155,      (flex_int16_t const   )154,      (flex_int16_t const   )153,      (flex_int16_t const   )152, 
        (flex_int16_t const   )151,      (flex_int16_t const   )150,      (flex_int16_t const   )149,      (flex_int16_t const   )148, 
        (flex_int16_t const   )147,      (flex_int16_t const   )146,      (flex_int16_t const   )145,      (flex_int16_t const   )144, 
        (flex_int16_t const   )143,      (flex_int16_t const   )142,      (flex_int16_t const   )141,      (flex_int16_t const   )140, 
        (flex_int16_t const   )139,      (flex_int16_t const   )138,      (flex_int16_t const   )137,      (flex_int16_t const   )136, 
        (flex_int16_t const   )135,      (flex_int16_t const   )134,      (flex_int16_t const   )133,      (flex_int16_t const   )132, 
        (flex_int16_t const   )131,      (flex_int16_t const   )130,      (flex_int16_t const   )129,      (flex_int16_t const   )126, 
        (flex_int16_t const   )125,      (flex_int16_t const   )124,      (flex_int16_t const   )123,      (flex_int16_t const   )122, 
        (flex_int16_t const   )121,      (flex_int16_t const   )120,      (flex_int16_t const   )119,      (flex_int16_t const   )118, 
        (flex_int16_t const   )117,      (flex_int16_t const   )116,      (flex_int16_t const   )115,      (flex_int16_t const   )114, 
        (flex_int16_t const   )113,      (flex_int16_t const   )110,      (flex_int16_t const   )109,      (flex_int16_t const   )106, 
        (flex_int16_t const   )105,      (flex_int16_t const   )104,      (flex_int16_t const   )103,      (flex_int16_t const   )102, 
        (flex_int16_t const   )98,      (flex_int16_t const   )97,      (flex_int16_t const   )96,      (flex_int16_t const   )95, 
        (flex_int16_t const   )94,      (flex_int16_t const   )91,      (flex_int16_t const   )90,      (flex_int16_t const   )89, 
        (flex_int16_t const   )88,      (flex_int16_t const   )87,      (flex_int16_t const   )86,      (flex_int16_t const   )85, 
        (flex_int16_t const   )84,      (flex_int16_t const   )83,      (flex_int16_t const   )82,      (flex_int16_t const   )81, 
        (flex_int16_t const   )80,      (flex_int16_t const   )79,      (flex_int16_t const   )31,      (flex_int16_t const   )78, 
        (flex_int16_t const   )77,      (flex_int16_t const   )76,      (flex_int16_t const   )75,      (flex_int16_t const   )47, 
        (flex_int16_t const   )44,      (flex_int16_t const   )43,      (flex_int16_t const   )38,      (flex_int16_t const   )36, 
        (flex_int16_t const   )31,      (flex_int16_t const   )283,      (flex_int16_t const   )3,      (flex_int16_t const   )283, 
        (flex_int16_t const   )283,      (flex_int16_t const   )283,      (flex_int16_t const   )283,      (flex_int16_t const   )283, 
        (flex_int16_t const   )283,      (flex_int16_t const   )283,      (flex_int16_t const   )283,      (flex_int16_t const   )283, 
        (flex_int16_t const   )283,      (flex_int16_t const   )283,      (flex_int16_t const   )283,      (flex_int16_t const   )283, 
        (flex_int16_t const   )283,      (flex_int16_t const   )283,      (flex_int16_t const   )283,      (flex_int16_t const   )283, 
        (flex_int16_t const   )283,      (flex_int16_t const   )283,      (flex_int16_t const   )283,      (flex_int16_t const   )283, 
        (flex_int16_t const   )283,      (flex_int16_t const   )283,      (flex_int16_t const   )283,      (flex_int16_t const   )283, 
        (flex_int16_t const   )283,      (flex_int16_t const   )283,      (flex_int16_t const   )283,      (flex_int16_t const   )283, 
        (flex_int16_t const   )283,      (flex_int16_t const   )283,      (flex_int16_t const   )283,      (flex_int16_t const   )283, 
        (flex_int16_t const   )283};
#line 565 "config-lexer.c"
static flex_int16_t const   yy_chk[333]  = 
#line 565
  {      (flex_int16_t const   )0,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1, 
        (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1, 
        (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1, 
        (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1, 
        (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1, 
        (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1, 
        (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1, 
        (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1, 
        (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )7, 
        (flex_int16_t const   )7,      (flex_int16_t const   )10,      (flex_int16_t const   )10,      (flex_int16_t const   )10, 
        (flex_int16_t const   )12,      (flex_int16_t const   )13,      (flex_int16_t const   )16,      (flex_int16_t const   )18, 
        (flex_int16_t const   )20,      (flex_int16_t const   )16,      (flex_int16_t const   )18,      (flex_int16_t const   )13, 
        (flex_int16_t const   )19,      (flex_int16_t const   )22,      (flex_int16_t const   )12,      (flex_int16_t const   )21, 
        (flex_int16_t const   )286,      (flex_int16_t const   )24,      (flex_int16_t const   )19,      (flex_int16_t const   )21, 
        (flex_int16_t const   )22,      (flex_int16_t const   )20,      (flex_int16_t const   )22,      (flex_int16_t const   )21, 
        (flex_int16_t const   )284,      (flex_int16_t const   )23,      (flex_int16_t const   )24,      (flex_int16_t const   )26, 
        (flex_int16_t const   )21,      (flex_int16_t const   )23,      (flex_int16_t const   )25,      (flex_int16_t const   )281, 
        (flex_int16_t const   )25,      (flex_int16_t const   )23,      (flex_int16_t const   )52,      (flex_int16_t const   )26, 
        (flex_int16_t const   )33,      (flex_int16_t const   )33,      (flex_int16_t const   )23,      (flex_int16_t const   )52, 
        (flex_int16_t const   )23,      (flex_int16_t const   )25,      (flex_int16_t const   )26,      (flex_int16_t const   )37, 
        (flex_int16_t const   )37,      (flex_int16_t const   )37,      (flex_int16_t const   )60,      (flex_int16_t const   )66, 
        (flex_int16_t const   )69,      (flex_int16_t const   )26,      (flex_int16_t const   )84,      (flex_int16_t const   )69, 
        (flex_int16_t const   )84,      (flex_int16_t const   )60,      (flex_int16_t const   )150,      (flex_int16_t const   )198, 
        (flex_int16_t const   )150,      (flex_int16_t const   )187,      (flex_int16_t const   )187,      (flex_int16_t const   )60, 
        (flex_int16_t const   )242,      (flex_int16_t const   )66,      (flex_int16_t const   )280,      (flex_int16_t const   )276, 
        (flex_int16_t const   )275,      (flex_int16_t const   )273,      (flex_int16_t const   )242,      (flex_int16_t const   )198, 
        (flex_int16_t const   )242,      (flex_int16_t const   )285,      (flex_int16_t const   )285,      (flex_int16_t const   )272, 
        (flex_int16_t const   )271,      (flex_int16_t const   )270,      (flex_int16_t const   )268,      (flex_int16_t const   )267, 
        (flex_int16_t const   )264,      (flex_int16_t const   )262,      (flex_int16_t const   )261,      (flex_int16_t const   )260, 
        (flex_int16_t const   )250,      (flex_int16_t const   )249,      (flex_int16_t const   )248,      (flex_int16_t const   )247, 
        (flex_int16_t const   )246,      (flex_int16_t const   )244,      (flex_int16_t const   )241,      (flex_int16_t const   )238, 
        (flex_int16_t const   )237,      (flex_int16_t const   )234,      (flex_int16_t const   )232,      (flex_int16_t const   )231, 
        (flex_int16_t const   )230,      (flex_int16_t const   )229,      (flex_int16_t const   )228,      (flex_int16_t const   )227, 
        (flex_int16_t const   )226,      (flex_int16_t const   )225,      (flex_int16_t const   )223,      (flex_int16_t const   )222, 
        (flex_int16_t const   )221,      (flex_int16_t const   )220,      (flex_int16_t const   )219,      (flex_int16_t const   )218, 
        (flex_int16_t const   )214,      (flex_int16_t const   )213,      (flex_int16_t const   )212,      (flex_int16_t const   )210, 
        (flex_int16_t const   )209,      (flex_int16_t const   )208,      (flex_int16_t const   )207,      (flex_int16_t const   )206, 
        (flex_int16_t const   )205,      (flex_int16_t const   )204,      (flex_int16_t const   )203,      (flex_int16_t const   )202, 
        (flex_int16_t const   )200,      (flex_int16_t const   )197,      (flex_int16_t const   )196,      (flex_int16_t const   )195, 
        (flex_int16_t const   )194,      (flex_int16_t const   )193,      (flex_int16_t const   )192,      (flex_int16_t const   )190, 
        (flex_int16_t const   )189,      (flex_int16_t const   )188,      (flex_int16_t const   )186,      (flex_int16_t const   )185, 
        (flex_int16_t const   )184,      (flex_int16_t const   )183,      (flex_int16_t const   )182,      (flex_int16_t const   )180, 
        (flex_int16_t const   )179,      (flex_int16_t const   )178,      (flex_int16_t const   )177,      (flex_int16_t const   )176, 
        (flex_int16_t const   )175,      (flex_int16_t const   )174,      (flex_int16_t const   )173,      (flex_int16_t const   )172, 
        (flex_int16_t const   )170,      (flex_int16_t const   )169,      (flex_int16_t const   )167,      (flex_int16_t const   )166, 
        (flex_int16_t const   )165,      (flex_int16_t const   )164,      (flex_int16_t const   )163,      (flex_int16_t const   )162, 
        (flex_int16_t const   )161,      (flex_int16_t const   )160,      (flex_int16_t const   )159,      (flex_int16_t const   )158, 
        (flex_int16_t const   )155,      (flex_int16_t const   )154,      (flex_int16_t const   )153,      (flex_int16_t const   )152, 
        (flex_int16_t const   )151,      (flex_int16_t const   )149,      (flex_int16_t const   )148,      (flex_int16_t const   )147, 
        (flex_int16_t const   )146,      (flex_int16_t const   )144,      (flex_int16_t const   )143,      (flex_int16_t const   )142, 
        (flex_int16_t const   )141,      (flex_int16_t const   )139,      (flex_int16_t const   )138,      (flex_int16_t const   )135, 
        (flex_int16_t const   )133,      (flex_int16_t const   )132,      (flex_int16_t const   )131,      (flex_int16_t const   )130, 
        (flex_int16_t const   )129,      (flex_int16_t const   )128,      (flex_int16_t const   )127,      (flex_int16_t const   )126, 
        (flex_int16_t const   )125,      (flex_int16_t const   )124,      (flex_int16_t const   )123,      (flex_int16_t const   )120, 
        (flex_int16_t const   )119,      (flex_int16_t const   )118,      (flex_int16_t const   )117,      (flex_int16_t const   )116, 
        (flex_int16_t const   )115,      (flex_int16_t const   )114,      (flex_int16_t const   )113,      (flex_int16_t const   )112, 
        (flex_int16_t const   )111,      (flex_int16_t const   )110,      (flex_int16_t const   )109,      (flex_int16_t const   )108, 
        (flex_int16_t const   )107,      (flex_int16_t const   )106,      (flex_int16_t const   )105,      (flex_int16_t const   )104, 
        (flex_int16_t const   )103,      (flex_int16_t const   )102,      (flex_int16_t const   )101,      (flex_int16_t const   )99, 
        (flex_int16_t const   )97,      (flex_int16_t const   )96,      (flex_int16_t const   )95,      (flex_int16_t const   )94, 
        (flex_int16_t const   )93,      (flex_int16_t const   )92,      (flex_int16_t const   )91,      (flex_int16_t const   )88, 
        (flex_int16_t const   )87,      (flex_int16_t const   )86,      (flex_int16_t const   )85,      (flex_int16_t const   )83, 
        (flex_int16_t const   )82,      (flex_int16_t const   )81,      (flex_int16_t const   )80,      (flex_int16_t const   )79, 
        (flex_int16_t const   )78,      (flex_int16_t const   )77,      (flex_int16_t const   )76,      (flex_int16_t const   )75, 
        (flex_int16_t const   )74,      (flex_int16_t const   )73,      (flex_int16_t const   )72,      (flex_int16_t const   )71, 
        (flex_int16_t const   )70,      (flex_int16_t const   )68,      (flex_int16_t const   )67,      (flex_int16_t const   )65, 
        (flex_int16_t const   )64,      (flex_int16_t const   )63,      (flex_int16_t const   )62,      (flex_int16_t const   )61, 
        (flex_int16_t const   )58,      (flex_int16_t const   )56,      (flex_int16_t const   )55,      (flex_int16_t const   )54, 
        (flex_int16_t const   )53,      (flex_int16_t const   )51,      (flex_int16_t const   )50,      (flex_int16_t const   )49, 
        (flex_int16_t const   )48,      (flex_int16_t const   )47,      (flex_int16_t const   )45,      (flex_int16_t const   )44, 
        (flex_int16_t const   )43,      (flex_int16_t const   )42,      (flex_int16_t const   )41,      (flex_int16_t const   )40, 
        (flex_int16_t const   )39,      (flex_int16_t const   )38,      (flex_int16_t const   )31,      (flex_int16_t const   )30, 
        (flex_int16_t const   )29,      (flex_int16_t const   )28,      (flex_int16_t const   )27,      (flex_int16_t const   )17, 
        (flex_int16_t const   )15,      (flex_int16_t const   )14,      (flex_int16_t const   )11,      (flex_int16_t const   )9, 
        (flex_int16_t const   )5,      (flex_int16_t const   )3,      (flex_int16_t const   )283,      (flex_int16_t const   )283, 
        (flex_int16_t const   )283,      (flex_int16_t const   )283,      (flex_int16_t const   )283,      (flex_int16_t const   )283, 
        (flex_int16_t const   )283,      (flex_int16_t const   )283,      (flex_int16_t const   )283,      (flex_int16_t const   )283, 
        (flex_int16_t const   )283,      (flex_int16_t const   )283,      (flex_int16_t const   )283,      (flex_int16_t const   )283, 
        (flex_int16_t const   )283,      (flex_int16_t const   )283,      (flex_int16_t const   )283,      (flex_int16_t const   )283, 
        (flex_int16_t const   )283,      (flex_int16_t const   )283,      (flex_int16_t const   )283,      (flex_int16_t const   )283, 
        (flex_int16_t const   )283,      (flex_int16_t const   )283,      (flex_int16_t const   )283,      (flex_int16_t const   )283, 
        (flex_int16_t const   )283,      (flex_int16_t const   )283,      (flex_int16_t const   )283,      (flex_int16_t const   )283, 
        (flex_int16_t const   )283,      (flex_int16_t const   )283,      (flex_int16_t const   )283,      (flex_int16_t const   )283, 
        (flex_int16_t const   )283};
#line 606 "config-lexer.c"
static yy_state_type yy_last_accepting_state  ;
#line 607 "config-lexer.c"
static char *yy_last_accepting_cpos  ;
#line 609
int yy_flex_debug ;
#line 610 "config-lexer.c"
int yy_flex_debug  =    0;
#line 616 "config-lexer.c"
static int yy_more_flag  =    0;
#line 617 "config-lexer.c"
static int yy_more_len  =    0;
#line 10 "/home/june/collector/temp/bopm-3.1.3/src/config.h"
char linebuf[512]  ;
#line 11
int linenum ;
#line 38 "config-lexer.l"
void ccomment(void) ;
#line 39
void hashcomment(void) ;
#line 41 "config-lexer.l"
int linenum  =    1;
#line 779 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) isatty)(int __fd ) ;
#line 677 "config-lexer.c"
static int yy_init_globals(void) ;
#line 704
static int input(void) ;
#line 806 "config-lexer.c"
int yylex(void) 
{ 
  register yy_state_type yy_current_state ;
  register char *yy_cp ;
  register char *yy_bp ;
  register int yy_act ;
  YY_BUFFER_STATE tmp___0 ;
  register YY_CHAR yy_c ;
  int yyless_macro_arg ;
  int i ;
  int j ;
  int yyless_macro_arg___0 ;
  int yy_amount_of_matched_text ;
  yy_state_type yy_next_state ;
  int tmp___1 ;

  {
#line 817
  if (! yy_init) {
#line 819
    yy_init = 1;
#line 825
    if (! yy_start) {
#line 826
      yy_start = 1;
    }
#line 828
    if (! yyin) {
#line 829
      yyin = stdin;
    }
#line 831
    if (! yyout) {
#line 832
      yyout = stdout;
    }
#line 834
    if (yy_buffer_stack) {
#line 834
      tmp___0 = *(yy_buffer_stack + yy_buffer_stack_top);
    } else {
#line 834
      tmp___0 = (YY_BUFFER_STATE )((void *)0);
    }
#line 834
    if (! tmp___0) {
      {
#line 835
      yyensure_buffer_stack();
#line 836
      *(yy_buffer_stack + yy_buffer_stack_top) = yy_create_buffer(yyin, 16384);
      }
    }
    {
#line 840
    yy_load_buffer_state();
    }
  }
  {
#line 843
  while (1) {
    while_continue: /* CIL Label */ ;
#line 845
    yy_more_len = 0;
#line 846
    if (yy_more_flag) {
#line 848
      yy_more_len = (int )(yy_c_buf_p - yytext);
#line 849
      yy_more_flag = 0;
    }
#line 851
    yy_cp = yy_c_buf_p;
#line 854
    *yy_cp = yy_hold_char;
#line 859
    yy_bp = yy_cp;
#line 861
    yy_current_state = yy_start;
    yy_match: 
    {
#line 863
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 865
      yy_c = (YY_CHAR )yy_ec[(unsigned int )((unsigned char )*yy_cp)];
#line 866
      if (yy_accept[yy_current_state]) {
#line 868
        yy_last_accepting_state = yy_current_state;
#line 869
        yy_last_accepting_cpos = yy_cp;
      }
      {
#line 871
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 871
        if (! ((int const   )yy_chk[(int const   )yy_base[yy_current_state] + (int const   )yy_c] != (int const   )yy_current_state)) {
#line 871
          goto while_break___1;
        }
#line 873
        yy_current_state = (int )yy_def[yy_current_state];
#line 874
        if (yy_current_state >= 284) {
#line 875
          yy_c = (YY_CHAR )yy_meta[(unsigned int )yy_c];
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 877
      yy_current_state = (yy_state_type )yy_nxt[(unsigned int )yy_base[yy_current_state] + (unsigned int )yy_c];
#line 878
      yy_cp ++;
#line 863
      if (! ((int const   )yy_base[yy_current_state] != 298)) {
#line 863
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    yy_find_action: 
#line 883
    yy_act = (int )yy_accept[yy_current_state];
#line 884
    if (yy_act == 0) {
#line 886
      yy_cp = yy_last_accepting_cpos;
#line 887
      yy_current_state = yy_last_accepting_state;
#line 888
      yy_act = (int )yy_accept[yy_current_state];
    }
#line 891
    yytext = yy_bp;
#line 891
    yytext -= yy_more_len;
#line 891
    yyleng = (int )((size_t )(yy_cp - yytext));
#line 891
    yy_hold_char = *yy_cp;
#line 891
    *yy_cp = (char )'\000';
#line 891
    yy_c_buf_p = yy_cp;
    do_action: 
    {
#line 897
    if (yy_act == 0) {
#line 897
      goto case_0;
    }
#line 904
    if (yy_act == 1) {
#line 904
      goto case_1;
    }
#line 54
    if (yy_act == 2) {
#line 54 "config-lexer.l"
      goto case_2;
    }
#line 56
    if (yy_act == 3) {
#line 56
      goto case_3;
    }
#line 95
    if (yy_act == 4) {
#line 95
      goto case_4;
    }
#line 97
    if (yy_act == 5) {
#line 97
      goto case_5;
    }
#line 98
    if (yy_act == 6) {
#line 98
      goto case_6;
    }
#line 99
    if (yy_act == 7) {
#line 99
      goto case_7;
    }
#line 100
    if (yy_act == 8) {
#line 100
      goto case_8;
    }
#line 101
    if (yy_act == 9) {
#line 101
      goto case_9;
    }
#line 102
    if (yy_act == 10) {
#line 102
      goto case_10;
    }
#line 103
    if (yy_act == 11) {
#line 103
      goto case_11;
    }
#line 104
    if (yy_act == 12) {
#line 104
      goto case_12;
    }
#line 105
    if (yy_act == 13) {
#line 105
      goto case_13;
    }
#line 106
    if (yy_act == 14) {
#line 106
      goto case_14;
    }
#line 107
    if (yy_act == 15) {
#line 107
      goto case_15;
    }
#line 108
    if (yy_act == 16) {
#line 108
      goto case_16;
    }
#line 109
    if (yy_act == 17) {
#line 109
      goto case_17;
    }
#line 110
    if (yy_act == 18) {
#line 110
      goto case_18;
    }
#line 111
    if (yy_act == 19) {
#line 111
      goto case_19;
    }
#line 112
    if (yy_act == 20) {
#line 112
      goto case_20;
    }
#line 113
    if (yy_act == 21) {
#line 113
      goto case_21;
    }
#line 114
    if (yy_act == 22) {
#line 114
      goto case_22;
    }
#line 115
    if (yy_act == 23) {
#line 115
      goto case_23;
    }
#line 116
    if (yy_act == 24) {
#line 116
      goto case_24;
    }
#line 117
    if (yy_act == 25) {
#line 117
      goto case_25;
    }
#line 118
    if (yy_act == 26) {
#line 118
      goto case_26;
    }
#line 119
    if (yy_act == 27) {
#line 119
      goto case_27;
    }
#line 120
    if (yy_act == 28) {
#line 120
      goto case_28;
    }
#line 121
    if (yy_act == 29) {
#line 121
      goto case_29;
    }
#line 122
    if (yy_act == 30) {
#line 122
      goto case_30;
    }
#line 123
    if (yy_act == 31) {
#line 123
      goto case_31;
    }
#line 124
    if (yy_act == 32) {
#line 124
      goto case_32;
    }
#line 125
    if (yy_act == 33) {
#line 125
      goto case_33;
    }
#line 126
    if (yy_act == 34) {
#line 126
      goto case_34;
    }
#line 127
    if (yy_act == 35) {
#line 127
      goto case_35;
    }
#line 128
    if (yy_act == 36) {
#line 128
      goto case_36;
    }
#line 129
    if (yy_act == 37) {
#line 129
      goto case_37;
    }
#line 130
    if (yy_act == 38) {
#line 130
      goto case_38;
    }
#line 131
    if (yy_act == 39) {
#line 131
      goto case_39;
    }
#line 132
    if (yy_act == 40) {
#line 132
      goto case_40;
    }
#line 133
    if (yy_act == 41) {
#line 133
      goto case_41;
    }
#line 134
    if (yy_act == 42) {
#line 134
      goto case_42;
    }
#line 135
    if (yy_act == 43) {
#line 135
      goto case_43;
    }
#line 136
    if (yy_act == 44) {
#line 136
      goto case_44;
    }
#line 137
    if (yy_act == 45) {
#line 137
      goto case_45;
    }
#line 138
    if (yy_act == 46) {
#line 138
      goto case_46;
    }
#line 139
    if (yy_act == 47) {
#line 139
      goto case_47;
    }
#line 145
    if (yy_act == 48) {
#line 145
      goto case_48;
    }
#line 150
    if (yy_act == 49) {
#line 150
      goto case_49;
    }
#line 155
    if (yy_act == 50) {
#line 155
      goto case_50;
    }
#line 160
    if (yy_act == 51) {
#line 160
      goto case_51;
    }
#line 165
    if (yy_act == 52) {
#line 165
      goto case_52;
    }
#line 170
    if (yy_act == 53) {
#line 170
      goto case_53;
    }
#line 176
    if (yy_act == 54) {
#line 176
      goto case_54;
    }
#line 185
    if (yy_act == 55) {
#line 185
      goto case_55;
    }
#line 189
    if (yy_act == 56) {
#line 189
      goto case_56;
    }
#line 193
    if (yy_act == 57) {
#line 193
      goto case_57;
    }
#line 200
    if (yy_act == 58) {
#line 200
      goto case_58;
    }
#line 205
    if (yy_act == 59) {
#line 205
      goto case_59;
    }
#line 210
    if (yy_act == 60) {
#line 210
      goto case_60;
    }
#line 218
    if (yy_act == 61) {
#line 218
      goto case_61;
    }
#line 220
    if (yy_act == 62) {
#line 220
      goto case_62;
    }
#line 222
    if (yy_act == 63) {
#line 222
      goto case_63;
    }
#line 1302
    if (yy_act == 65) {
#line 1302 "config-lexer.c"
      goto case_65;
    }
#line 1305
    if (yy_act == 64) {
#line 1305
      goto case_64;
    }
#line 1427
    goto switch_default;
    case_0: /* CIL Label */ 
#line 899
    *yy_cp = yy_hold_char;
#line 900
    yy_cp = yy_last_accepting_cpos;
#line 901
    yy_current_state = yy_last_accepting_state;
#line 902
    goto yy_find_action;
    case_1: /* CIL Label */ 
    {
#line 52 "config-lexer.l"
    ccomment();
    }
#line 53
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 54
    hashcomment();
    }
#line 55
    goto switch_break;
    case_3: /* CIL Label */ 
#line 59
    if ((int )*(yytext + (yyleng - 2)) == 92) {
      {
#line 61
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 61
        yyless_macro_arg = yyleng - 1;
#line 61
        *yy_cp = yy_hold_char;
#line 61
        yy_cp = (yy_bp + yyless_macro_arg) - yy_more_len;
#line 61
        yy_c_buf_p = yy_cp;
#line 61
        yytext = yy_bp;
#line 61
        yytext -= yy_more_len;
#line 61
        yyleng = (int )((size_t )(yy_cp - yytext));
#line 61
        yy_hold_char = *yy_cp;
#line 61
        *yy_cp = (char )'\000';
#line 61
        yy_c_buf_p = yy_cp;
#line 61
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 62
      yy_more_flag = 1;
    } else {
#line 66
      yylval.string = yytext + 1;
#line 67
      if (! ((int )*(yylval.string + (yyleng - 2)) != 34)) {
#line 72
        *(yylval.string + (yyleng - 2)) = (char )'\000';
#line 76
        i = 0;
#line 76
        j = i;
        {
#line 76
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 76
          if (! ((int )*(yylval.string + i) != 0)) {
#line 76
            goto while_break___3;
          }
#line 78
          if ((int )*(yylval.string + i) != 92) {
#line 80
            *(yylval.string + j) = *(yylval.string + i);
          } else {
#line 84
            i ++;
#line 85
            *(yylval.string + j) = *(yylval.string + i);
          }
#line 76
          i ++;
#line 76
          j ++;
        }
        while_break___3: /* CIL Label */ ;
        }
#line 88
        *(yylval.string + j) = (char )'\000';
#line 89
        return (303);
      }
    }
#line 94
    goto switch_break;
    case_4: /* CIL Label */ 
#line 95
    return (258);
#line 96
    goto switch_break;
    case_5: /* CIL Label */ 
#line 96
    return (259);
#line 97
    goto switch_break;
    case_6: /* CIL Label */ 
#line 97
    return (260);
#line 98
    goto switch_break;
    case_7: /* CIL Label */ 
#line 98
    return (261);
#line 99
    goto switch_break;
    case_8: /* CIL Label */ 
#line 99
    return (262);
#line 100
    goto switch_break;
    case_9: /* CIL Label */ 
#line 100
    return (263);
#line 101
    goto switch_break;
    case_10: /* CIL Label */ 
#line 101
    return (264);
#line 102
    goto switch_break;
    case_11: /* CIL Label */ 
#line 102
    return (265);
#line 103
    goto switch_break;
    case_12: /* CIL Label */ 
#line 103
    return (266);
#line 104
    goto switch_break;
    case_13: /* CIL Label */ 
#line 104
    return (267);
#line 105
    goto switch_break;
    case_14: /* CIL Label */ 
#line 105
    return (268);
#line 106
    goto switch_break;
    case_15: /* CIL Label */ 
#line 106
    return (269);
#line 107
    goto switch_break;
    case_16: /* CIL Label */ 
#line 107
    return (270);
#line 108
    goto switch_break;
    case_17: /* CIL Label */ 
#line 108
    return (271);
#line 109
    goto switch_break;
    case_18: /* CIL Label */ 
#line 109
    return (272);
#line 110
    goto switch_break;
    case_19: /* CIL Label */ 
#line 110
    return (273);
#line 111
    goto switch_break;
    case_20: /* CIL Label */ 
#line 111
    return (274);
#line 112
    goto switch_break;
    case_21: /* CIL Label */ 
#line 112
    return (275);
#line 113
    goto switch_break;
    case_22: /* CIL Label */ 
#line 113
    return (276);
#line 114
    goto switch_break;
    case_23: /* CIL Label */ 
#line 114
    return (277);
#line 115
    goto switch_break;
    case_24: /* CIL Label */ 
#line 115
    return (278);
#line 116
    goto switch_break;
    case_25: /* CIL Label */ 
#line 116
    return (279);
#line 117
    goto switch_break;
    case_26: /* CIL Label */ 
#line 117
    return (280);
#line 118
    goto switch_break;
    case_27: /* CIL Label */ 
#line 118
    return (281);
#line 119
    goto switch_break;
    case_28: /* CIL Label */ 
#line 119
    return (282);
#line 120
    goto switch_break;
    case_29: /* CIL Label */ 
#line 120
    return (283);
#line 121
    goto switch_break;
    case_30: /* CIL Label */ 
#line 121
    return (284);
#line 122
    goto switch_break;
    case_31: /* CIL Label */ 
#line 122
    return (285);
#line 123
    goto switch_break;
    case_32: /* CIL Label */ 
#line 123
    return (286);
#line 124
    goto switch_break;
    case_33: /* CIL Label */ 
#line 124
    return (288);
#line 125
    goto switch_break;
    case_34: /* CIL Label */ 
#line 125
    return (289);
#line 126
    goto switch_break;
    case_35: /* CIL Label */ 
#line 126
    return (290);
#line 127
    goto switch_break;
    case_36: /* CIL Label */ 
#line 127
    return (291);
#line 128
    goto switch_break;
    case_37: /* CIL Label */ 
#line 128
    return (292);
#line 129
    goto switch_break;
    case_38: /* CIL Label */ 
#line 129
    return (293);
#line 130
    goto switch_break;
    case_39: /* CIL Label */ 
#line 130
    return (294);
#line 131
    goto switch_break;
    case_40: /* CIL Label */ 
#line 131
    return (295);
#line 132
    goto switch_break;
    case_41: /* CIL Label */ 
#line 132
    return (296);
#line 133
    goto switch_break;
    case_42: /* CIL Label */ 
#line 133
    return (297);
#line 134
    goto switch_break;
    case_43: /* CIL Label */ 
#line 134
    return (298);
#line 135
    goto switch_break;
    case_44: /* CIL Label */ 
#line 135
    return (300);
#line 136
    goto switch_break;
    case_45: /* CIL Label */ 
#line 136
    return (299);
#line 137
    goto switch_break;
    case_46: /* CIL Label */ 
#line 137
    return (301);
#line 138
    goto switch_break;
    case_47: /* CIL Label */ 
#line 141
    yylval.number = 1;
#line 142
    return (287);
#line 144
    goto switch_break;
    case_48: /* CIL Label */ 
#line 146
    yylval.number = 6;
#line 147
    return (287);
#line 149
    goto switch_break;
    case_49: /* CIL Label */ 
#line 151
    yylval.number = 2;
#line 152
    return (287);
#line 154
    goto switch_break;
    case_50: /* CIL Label */ 
#line 156
    yylval.number = 3;
#line 157
    return (287);
#line 159
    goto switch_break;
    case_51: /* CIL Label */ 
#line 161
    yylval.number = 4;
#line 162
    return (287);
#line 164
    goto switch_break;
    case_52: /* CIL Label */ 
#line 166
    yylval.number = 5;
#line 167
    return (287);
#line 169
    goto switch_break;
    case_53: /* CIL Label */ 
    {
#line 172
    yylval.number = atoi((char const   *)yytext);
    }
#line 173
    return (302);
#line 175
    goto switch_break;
    case_54: /* CIL Label */ 
#line 181
    yylval.number = 1;
#line 182
    return (302);
#line 184
    goto switch_break;
    case_55: /* CIL Label */ 
#line 185
    yylval.number = 1;
#line 186
    return (302);
#line 188
    goto switch_break;
    case_56: /* CIL Label */ 
#line 189
    yylval.number = 1;
#line 190
    return (302);
#line 192
    goto switch_break;
    case_57: /* CIL Label */ 
#line 196
    yylval.number = 0;
#line 197
    return (302);
#line 199
    goto switch_break;
    case_58: /* CIL Label */ 
#line 201
    yylval.number = 0;
#line 202
    return (302);
#line 204
    goto switch_break;
    case_59: /* CIL Label */ 
#line 206
    yylval.number = 0;
#line 207
    return (302);
#line 209
    goto switch_break;
    case_60: /* CIL Label */ 
    {
#line 213
    strcpy((char */* __restrict  */)(linebuf), (char const   */* __restrict  */)(yytext + 1));
#line 214
    linenum ++;
    }
    {
#line 215
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 215
      yyless_macro_arg___0 = 1;
#line 215
      *yy_cp = yy_hold_char;
#line 215
      yy_cp = (yy_bp + yyless_macro_arg___0) - yy_more_len;
#line 215
      yy_c_buf_p = yy_cp;
#line 215
      yytext = yy_bp;
#line 215
      yytext -= yy_more_len;
#line 215
      yyleng = (int )((size_t )(yy_cp - yytext));
#line 215
      yy_hold_char = *yy_cp;
#line 215
      *yy_cp = (char )'\000';
#line 215
      yy_c_buf_p = yy_cp;
#line 215
      goto while_break___4;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 217
    goto switch_break;
    case_61: /* CIL Label */ ;
#line 219
    goto switch_break;
    case_62: /* CIL Label */ 
#line 220
    return ((int )*(yytext + 0));
#line 221
    goto switch_break;
    case_63: /* CIL Label */ 
    {
#line 222
    fwrite((void const   */* __restrict  */)yytext, (size_t )yyleng, (size_t )1, (FILE */* __restrict  */)yyout);
    }
#line 223
    goto switch_break;
    case_65: /* CIL Label */ 
#line 1303 "config-lexer.c"
    return (0);
    case_64: /* CIL Label */ 
#line 1308
    yy_amount_of_matched_text = (int )(yy_cp - yytext) - 1;
#line 1311
    *yy_cp = yy_hold_char;
#line 1314
    if ((*(yy_buffer_stack + yy_buffer_stack_top))->yy_buffer_status == 0) {
#line 1325
      yy_n_chars = (*(yy_buffer_stack + yy_buffer_stack_top))->yy_n_chars;
#line 1326
      (*(yy_buffer_stack + yy_buffer_stack_top))->yy_input_file = yyin;
#line 1327
      (*(yy_buffer_stack + yy_buffer_stack_top))->yy_buffer_status = 1;
    }
#line 1337
    if ((unsigned long )yy_c_buf_p <= (unsigned long )((*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf + yy_n_chars)) {
      {
#line 1341
      yy_c_buf_p = yytext + yy_amount_of_matched_text;
#line 1343
      yy_current_state = yy_get_previous_state();
#line 1354
      yy_next_state = yy_try_NUL_trans(yy_current_state);
#line 1356
      yy_bp = yytext + yy_more_len;
      }
#line 1358
      if (yy_next_state) {
#line 1361
        yy_c_buf_p ++;
#line 1361
        yy_cp = yy_c_buf_p;
#line 1362
        yy_current_state = yy_next_state;
#line 1363
        goto yy_match;
      } else {
#line 1368
        yy_cp = yy_c_buf_p;
#line 1369
        goto yy_find_action;
      }
    } else {
      {
#line 1373
      tmp___1 = yy_get_next_buffer();
      }
      {
#line 1375
      if (tmp___1 == 1) {
#line 1375
        goto case_1___0;
      }
#line 1404
      if (tmp___1 == 0) {
#line 1404
        goto case_0___0;
      }
#line 1414
      if (tmp___1 == 2) {
#line 1414
        goto case_2___0;
      }
#line 1373
      goto switch_break___0;
      case_1___0: /* CIL Label */ 
#line 1377
      yy_did_buffer_switch_on_eof = 0;
#line 1390
      yy_c_buf_p = yytext + yy_more_len;
#line 1392
      yy_act = (64 + (yy_start - 1) / 2) + 1;
#line 1393
      goto do_action;
#line 1401
      goto switch_break___0;
      case_0___0: /* CIL Label */ 
      {
#line 1405
      yy_c_buf_p = yytext + yy_amount_of_matched_text;
#line 1408
      yy_current_state = yy_get_previous_state();
#line 1410
      yy_cp = yy_c_buf_p;
#line 1411
      yy_bp = yytext + yy_more_len;
      }
#line 1412
      goto yy_match;
      case_2___0: /* CIL Label */ 
      {
#line 1415
      yy_c_buf_p = (*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf + yy_n_chars;
#line 1418
      yy_current_state = yy_get_previous_state();
#line 1420
      yy_cp = yy_c_buf_p;
#line 1421
      yy_bp = yytext + yy_more_len;
      }
#line 1422
      goto yy_find_action;
      switch_break___0: /* CIL Label */ ;
      }
    }
#line 1424
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 1428
    yy_fatal_error("fatal flex scanner internal error--no action found");
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 1441 "config-lexer.c"
static int yy_get_next_buffer(void) 
{ 
  register char *dest ;
  register char *source ;
  register int number_to_move ;
  register int i ;
  int ret_val ;
  char *tmp___0 ;
  char *tmp___1 ;
  int num_to_read ;
  YY_BUFFER_STATE b ;
  YY_BUFFER_STATE tmp___2 ;
  int yy_c_buf_p_offset ;
  int new_size ;
  void *tmp___3 ;
  int c ;
  size_t n ;
  size_t tmp___4 ;
  int tmp___5 ;
  int *tmp___6 ;
  int *tmp___7 ;
  int *tmp___8 ;
  size_t tmp___9 ;
  int tmp___10 ;

  {
#line 1443
  dest = (*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf;
#line 1444
  source = yytext;
#line 1448
  if ((unsigned long )yy_c_buf_p > (unsigned long )((*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf + (yy_n_chars + 1))) {
    {
#line 1449
    yy_fatal_error("fatal flex scanner internal error--end of buffer missed");
    }
  }
#line 1452
  if ((*(yy_buffer_stack + yy_buffer_stack_top))->yy_fill_buffer == 0) {
#line 1454
    if ((yy_c_buf_p - yytext) - (long )yy_more_len == 1L) {
#line 1459
      return (1);
    } else {
#line 1467
      return (2);
    }
  }
#line 1474
  number_to_move = (int )(yy_c_buf_p - yytext) - 1;
#line 1476
  i = 0;
  {
#line 1476
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1476
    if (! (i < number_to_move)) {
#line 1476
      goto while_break;
    }
#line 1477
    tmp___0 = dest;
#line 1477
    dest ++;
#line 1477
    tmp___1 = source;
#line 1477
    source ++;
#line 1477
    *tmp___0 = *tmp___1;
#line 1476
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1479
  if ((*(yy_buffer_stack + yy_buffer_stack_top))->yy_buffer_status == 2) {
#line 1483
    yy_n_chars = 0;
#line 1483
    (*(yy_buffer_stack + yy_buffer_stack_top))->yy_n_chars = yy_n_chars;
  } else {
#line 1487
    num_to_read = (int )(((*(yy_buffer_stack + yy_buffer_stack_top))->yy_buf_size - (yy_size_t )number_to_move) - 1U);
    {
#line 1490
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1490
      if (! (num_to_read <= 0)) {
#line 1490
        goto while_break___0;
      }
#line 1494
      if (yy_buffer_stack) {
#line 1494
        tmp___2 = *(yy_buffer_stack + yy_buffer_stack_top);
      } else {
#line 1494
        tmp___2 = (YY_BUFFER_STATE )((void *)0);
      }
#line 1494
      b = tmp___2;
#line 1496
      yy_c_buf_p_offset = (int )(yy_c_buf_p - b->yy_ch_buf);
#line 1499
      if (b->yy_is_our_buffer) {
#line 1501
        new_size = (int )(b->yy_buf_size * 2U);
#line 1503
        if (new_size <= 0) {
#line 1504
          b->yy_buf_size += b->yy_buf_size / 8U;
        } else {
#line 1506
          b->yy_buf_size *= 2U;
        }
        {
#line 1508
        tmp___3 = yyrealloc((void *)b->yy_ch_buf, b->yy_buf_size + 2U);
#line 1508
        b->yy_ch_buf = (char *)tmp___3;
        }
      } else {
#line 1514
        b->yy_ch_buf = (char *)0;
      }
#line 1516
      if (! b->yy_ch_buf) {
        {
#line 1517
        yy_fatal_error("fatal error - scanner input buffer overflow");
        }
      }
#line 1520
      yy_c_buf_p = b->yy_ch_buf + yy_c_buf_p_offset;
#line 1522
      num_to_read = (int )(((*(yy_buffer_stack + yy_buffer_stack_top))->yy_buf_size - (yy_size_t )number_to_move) - 1U);
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1527
    if (num_to_read > 8192) {
#line 1528
      num_to_read = 8192;
    }
#line 1531
    if ((*(yy_buffer_stack + yy_buffer_stack_top))->yy_is_interactive) {
#line 1531
      c = '*';
#line 1531
      n = (size_t )0;
      {
#line 1531
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1531
        if (n < (size_t )num_to_read) {
          {
#line 1531
          c = _IO_getc(yyin);
          }
#line 1531
          if (c != -1) {
#line 1531
            if (! (c != 10)) {
#line 1531
              goto while_break___1;
            }
          } else {
#line 1531
            goto while_break___1;
          }
        } else {
#line 1531
          goto while_break___1;
        }
#line 1531
        *(((*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf + number_to_move) + n) = (char )c;
#line 1531
        n ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 1531
      if (c == 10) {
#line 1531
        tmp___4 = n;
#line 1531
        n ++;
#line 1531
        *(((*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf + number_to_move) + tmp___4) = (char )c;
      }
#line 1531
      if (c == -1) {
        {
#line 1531
        tmp___5 = ferror(yyin);
        }
#line 1531
        if (tmp___5) {
          {
#line 1531
          yy_fatal_error("input in flex scanner failed");
          }
        }
      }
#line 1531
      yy_n_chars = (int )n;
    } else {
      {
#line 1531
      tmp___6 = __errno_location();
#line 1531
      *tmp___6 = 0;
      }
      {
#line 1531
      while (1) {
        while_continue___2: /* CIL Label */ ;
        {
#line 1531
        tmp___9 = fread((void */* __restrict  */)((*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf + number_to_move),
                        (size_t )1, (size_t )num_to_read, (FILE */* __restrict  */)yyin);
#line 1531
        yy_n_chars = (int )tmp___9;
        }
#line 1531
        if (yy_n_chars == 0) {
          {
#line 1531
          tmp___10 = ferror(yyin);
          }
#line 1531
          if (! tmp___10) {
#line 1531
            goto while_break___2;
          }
        } else {
#line 1531
          goto while_break___2;
        }
        {
#line 1531
        tmp___7 = __errno_location();
        }
#line 1531
        if (*tmp___7 != 4) {
          {
#line 1531
          yy_fatal_error("input in flex scanner failed");
          }
#line 1531
          goto while_break___2;
        }
        {
#line 1531
        tmp___8 = __errno_location();
#line 1531
        *tmp___8 = 0;
#line 1531
        clearerr(yyin);
        }
      }
      while_break___2: /* CIL Label */ ;
      }
    }
#line 1534
    (*(yy_buffer_stack + yy_buffer_stack_top))->yy_n_chars = yy_n_chars;
  }
#line 1537
  if (yy_n_chars == 0) {
#line 1539
    if (number_to_move == yy_more_len) {
      {
#line 1541
      ret_val = 1;
#line 1542
      yyrestart(yyin);
      }
    } else {
#line 1547
      ret_val = 2;
#line 1548
      (*(yy_buffer_stack + yy_buffer_stack_top))->yy_buffer_status = 2;
    }
  } else {
#line 1554
    ret_val = 0;
  }
#line 1556
  yy_n_chars += number_to_move;
#line 1557
  *((*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf + yy_n_chars) = (char)0;
#line 1558
  *((*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf + (yy_n_chars + 1)) = (char)0;
#line 1560
  yytext = (*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf + 0;
#line 1562
  return (ret_val);
}
}
#line 1567 "config-lexer.c"
static yy_state_type yy_get_previous_state(void) 
{ 
  register yy_state_type yy_current_state ;
  register char *yy_cp ;
  register YY_CHAR yy_c ;
  flex_int32_t tmp___0 ;

  {
#line 1572
  yy_current_state = yy_start;
#line 1574
  yy_cp = yytext + yy_more_len;
  {
#line 1574
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1574
    if (! ((unsigned long )yy_cp < (unsigned long )yy_c_buf_p)) {
#line 1574
      goto while_break;
    }
#line 1576
    if (*yy_cp) {
#line 1576
      tmp___0 = yy_ec[(unsigned int )((unsigned char )*yy_cp)];
    } else {
#line 1576
      tmp___0 = (flex_int32_t const   )1;
    }
#line 1576
    yy_c = (YY_CHAR )tmp___0;
#line 1577
    if (yy_accept[yy_current_state]) {
#line 1579
      yy_last_accepting_state = yy_current_state;
#line 1580
      yy_last_accepting_cpos = yy_cp;
    }
    {
#line 1582
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1582
      if (! ((int const   )yy_chk[(int const   )yy_base[yy_current_state] + (int const   )yy_c] != (int const   )yy_current_state)) {
#line 1582
        goto while_break___0;
      }
#line 1584
      yy_current_state = (int )yy_def[yy_current_state];
#line 1585
      if (yy_current_state >= 284) {
#line 1586
        yy_c = (YY_CHAR )yy_meta[(unsigned int )yy_c];
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1588
    yy_current_state = (yy_state_type )yy_nxt[(unsigned int )yy_base[yy_current_state] + (unsigned int )yy_c];
#line 1574
    yy_cp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1591
  return (yy_current_state);
}
}
#line 1599 "config-lexer.c"
static yy_state_type yy_try_NUL_trans(yy_state_type yy_current_state ) 
{ 
  register int yy_is_jam ;
  register char *yy_cp ;
  register YY_CHAR yy_c ;
  int tmp___0 ;

  {
#line 1602
  yy_cp = yy_c_buf_p;
#line 1604
  yy_c = (YY_CHAR )1;
#line 1605
  if (yy_accept[yy_current_state]) {
#line 1607
    yy_last_accepting_state = yy_current_state;
#line 1608
    yy_last_accepting_cpos = yy_cp;
  }
  {
#line 1610
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1610
    if (! ((int const   )yy_chk[(int const   )yy_base[yy_current_state] + (int const   )yy_c] != (int const   )yy_current_state)) {
#line 1610
      goto while_break;
    }
#line 1612
    yy_current_state = (int )yy_def[yy_current_state];
#line 1613
    if (yy_current_state >= 284) {
#line 1614
      yy_c = (YY_CHAR )yy_meta[(unsigned int )yy_c];
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1616
  yy_current_state = (yy_state_type )yy_nxt[(unsigned int )yy_base[yy_current_state] + (unsigned int )yy_c];
#line 1617
  yy_is_jam = yy_current_state == 283;
#line 1619
  if (yy_is_jam) {
#line 1619
    tmp___0 = 0;
  } else {
#line 1619
    tmp___0 = yy_current_state;
  }
#line 1619
  return (tmp___0);
}
}
#line 1626 "config-lexer.c"
static int input(void) 
{ 
  int c ;
  int offset ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 1632
  *yy_c_buf_p = yy_hold_char;
#line 1634
  if ((int )*yy_c_buf_p == 0) {
#line 1640
    if ((unsigned long )yy_c_buf_p < (unsigned long )((*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf + yy_n_chars)) {
#line 1642
      *yy_c_buf_p = (char )'\000';
    } else {
      {
#line 1646
      offset = (int )(yy_c_buf_p - yytext);
#line 1647
      yy_c_buf_p ++;
#line 1649
      tmp___0 = yy_get_next_buffer();
      }
      {
#line 1651
      if (tmp___0 == 2) {
#line 1651
        goto case_2;
      }
#line 1667
      if (tmp___0 == 1) {
#line 1667
        goto case_1;
      }
#line 1681
      if (tmp___0 == 0) {
#line 1681
        goto case_0;
      }
#line 1649
      goto switch_break;
      case_2: /* CIL Label */ 
      {
#line 1663
      yyrestart(yyin);
      }
      case_1: /* CIL Label */ 
#line 1670
      return (-1);
#line 1672
      if (! yy_did_buffer_switch_on_eof) {
        {
#line 1673
        yyrestart(yyin);
        }
      }
      {
#line 1677
      tmp___1 = input();
      }
#line 1677
      return (tmp___1);
      case_0: /* CIL Label */ 
#line 1682
      yy_c_buf_p = yytext + offset;
#line 1683
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
  }
#line 1688
  c = (int )*((unsigned char *)yy_c_buf_p);
#line 1689
  *yy_c_buf_p = (char )'\000';
#line 1690
  yy_c_buf_p ++;
#line 1690
  yy_hold_char = *yy_c_buf_p;
#line 1692
  return (c);
}
}
#line 1701 "config-lexer.c"
void yyrestart(FILE *input_file ) 
{ 
  YY_BUFFER_STATE tmp___0 ;
  YY_BUFFER_STATE tmp___1 ;

  {
#line 1704
  if (yy_buffer_stack) {
#line 1704
    tmp___0 = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
#line 1704
    tmp___0 = (YY_BUFFER_STATE )((void *)0);
  }
#line 1704
  if (! tmp___0) {
    {
#line 1705
    yyensure_buffer_stack();
#line 1706
    *(yy_buffer_stack + yy_buffer_stack_top) = yy_create_buffer(yyin, 16384);
    }
  }
#line 1710
  if (yy_buffer_stack) {
#line 1710
    tmp___1 = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
#line 1710
    tmp___1 = (YY_BUFFER_STATE )((void *)0);
  }
  {
#line 1710
  yy_init_buffer(tmp___1, input_file);
#line 1711
  yy_load_buffer_state();
  }
#line 1712
  return;
}
}
#line 1718 "config-lexer.c"
void yy_switch_to_buffer(YY_BUFFER_STATE new_buffer ) 
{ 
  YY_BUFFER_STATE tmp___0 ;
  YY_BUFFER_STATE tmp___1 ;

  {
  {
#line 1726
  yyensure_buffer_stack();
  }
#line 1727
  if (yy_buffer_stack) {
#line 1727
    tmp___0 = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
#line 1727
    tmp___0 = (YY_BUFFER_STATE )((void *)0);
  }
#line 1727
  if ((unsigned long )tmp___0 == (unsigned long )new_buffer) {
#line 1728
    return;
  }
#line 1730
  if (yy_buffer_stack) {
#line 1730
    tmp___1 = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
#line 1730
    tmp___1 = (YY_BUFFER_STATE )((void *)0);
  }
#line 1730
  if (tmp___1) {
#line 1733
    *yy_c_buf_p = yy_hold_char;
#line 1734
    (*(yy_buffer_stack + yy_buffer_stack_top))->yy_buf_pos = yy_c_buf_p;
#line 1735
    (*(yy_buffer_stack + yy_buffer_stack_top))->yy_n_chars = yy_n_chars;
  }
  {
#line 1738
  *(yy_buffer_stack + yy_buffer_stack_top) = new_buffer;
#line 1739
  yy_load_buffer_state();
#line 1746
  yy_did_buffer_switch_on_eof = 1;
  }
#line 1747
  return;
}
}
#line 1749 "config-lexer.c"
static void yy_load_buffer_state(void) 
{ 


  {
#line 1751
  yy_n_chars = (*(yy_buffer_stack + yy_buffer_stack_top))->yy_n_chars;
#line 1752
  yy_c_buf_p = (*(yy_buffer_stack + yy_buffer_stack_top))->yy_buf_pos;
#line 1752
  yytext = yy_c_buf_p;
#line 1753
  yyin = (*(yy_buffer_stack + yy_buffer_stack_top))->yy_input_file;
#line 1754
  yy_hold_char = *yy_c_buf_p;
#line 1755
  return;
}
}
#line 1763 "config-lexer.c"
YY_BUFFER_STATE yy_create_buffer(FILE *file , int size ) 
{ 
  YY_BUFFER_STATE b ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 1767
  tmp___0 = yyalloc((yy_size_t )sizeof(struct yy_buffer_state ));
#line 1767
  b = (YY_BUFFER_STATE )tmp___0;
  }
#line 1768
  if (! b) {
    {
#line 1769
    yy_fatal_error("out of dynamic memory in yy_create_buffer()");
    }
  }
  {
#line 1771
  b->yy_buf_size = (yy_size_t )size;
#line 1776
  tmp___1 = yyalloc(b->yy_buf_size + 2U);
#line 1776
  b->yy_ch_buf = (char *)tmp___1;
  }
#line 1777
  if (! b->yy_ch_buf) {
    {
#line 1778
    yy_fatal_error("out of dynamic memory in yy_create_buffer()");
    }
  }
  {
#line 1780
  b->yy_is_our_buffer = 1;
#line 1782
  yy_init_buffer(b, file);
  }
#line 1784
  return (b);
}
}
#line 1791 "config-lexer.c"
void yy_delete_buffer(YY_BUFFER_STATE b ) 
{ 
  YY_BUFFER_STATE tmp___0 ;

  {
#line 1794
  if (! b) {
#line 1795
    return;
  }
#line 1797
  if (yy_buffer_stack) {
#line 1797
    tmp___0 = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
#line 1797
    tmp___0 = (YY_BUFFER_STATE )((void *)0);
  }
#line 1797
  if ((unsigned long )b == (unsigned long )tmp___0) {
#line 1798
    *(yy_buffer_stack + yy_buffer_stack_top) = (YY_BUFFER_STATE )0;
  }
#line 1800
  if (b->yy_is_our_buffer) {
    {
#line 1801
    yyfree((void *)b->yy_ch_buf);
    }
  }
  {
#line 1803
  yyfree((void *)b);
  }
#line 1804
  return;
}
}
#line 1814 "config-lexer.c"
static void yy_init_buffer(YY_BUFFER_STATE b , FILE *file ) 
{ 
  int oerrno ;
  int *tmp___0 ;
  YY_BUFFER_STATE tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int *tmp___4 ;

  {
  {
#line 1817
  tmp___0 = __errno_location();
#line 1817
  oerrno = *tmp___0;
#line 1819
  yy_flush_buffer(b);
#line 1821
  b->yy_input_file = file;
#line 1822
  b->yy_fill_buffer = 1;
  }
#line 1828
  if (yy_buffer_stack) {
#line 1828
    tmp___1 = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
#line 1828
    tmp___1 = (YY_BUFFER_STATE )((void *)0);
  }
#line 1828
  if ((unsigned long )b != (unsigned long )tmp___1) {
#line 1829
    b->yy_bs_lineno = 1;
#line 1830
    b->yy_bs_column = 0;
  }
#line 1833
  if (file) {
    {
#line 1833
    tmp___2 = fileno(file);
#line 1833
    tmp___3 = isatty(tmp___2);
#line 1833
    b->yy_is_interactive = tmp___3 > 0;
    }
  } else {
#line 1833
    b->yy_is_interactive = 0;
  }
  {
#line 1835
  tmp___4 = __errno_location();
#line 1835
  *tmp___4 = oerrno;
  }
#line 1836
  return;
}
}
#line 1842 "config-lexer.c"
void yy_flush_buffer(YY_BUFFER_STATE b ) 
{ 
  YY_BUFFER_STATE tmp___0 ;

  {
#line 1844
  if (! b) {
#line 1845
    return;
  }
#line 1847
  b->yy_n_chars = 0;
#line 1853
  *(b->yy_ch_buf + 0) = (char)0;
#line 1854
  *(b->yy_ch_buf + 1) = (char)0;
#line 1856
  b->yy_buf_pos = b->yy_ch_buf + 0;
#line 1858
  b->yy_at_bol = 1;
#line 1859
  b->yy_buffer_status = 0;
#line 1861
  if (yy_buffer_stack) {
#line 1861
    tmp___0 = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
#line 1861
    tmp___0 = (YY_BUFFER_STATE )((void *)0);
  }
#line 1861
  if ((unsigned long )b == (unsigned long )tmp___0) {
    {
#line 1862
    yy_load_buffer_state();
    }
  }
#line 1863
  return;
}
}
#line 1871 "config-lexer.c"
void yypush_buffer_state(YY_BUFFER_STATE new_buffer ) 
{ 
  YY_BUFFER_STATE tmp___0 ;
  YY_BUFFER_STATE tmp___1 ;

  {
#line 1873
  if ((unsigned long )new_buffer == (unsigned long )((void *)0)) {
#line 1874
    return;
  }
  {
#line 1876
  yyensure_buffer_stack();
  }
#line 1879
  if (yy_buffer_stack) {
#line 1879
    tmp___0 = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
#line 1879
    tmp___0 = (YY_BUFFER_STATE )((void *)0);
  }
#line 1879
  if (tmp___0) {
#line 1882
    *yy_c_buf_p = yy_hold_char;
#line 1883
    (*(yy_buffer_stack + yy_buffer_stack_top))->yy_buf_pos = yy_c_buf_p;
#line 1884
    (*(yy_buffer_stack + yy_buffer_stack_top))->yy_n_chars = yy_n_chars;
  }
#line 1888
  if (yy_buffer_stack) {
#line 1888
    tmp___1 = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
#line 1888
    tmp___1 = (YY_BUFFER_STATE )((void *)0);
  }
#line 1888
  if (tmp___1) {
#line 1889
    yy_buffer_stack_top ++;
  }
  {
#line 1890
  *(yy_buffer_stack + yy_buffer_stack_top) = new_buffer;
#line 1893
  yy_load_buffer_state();
#line 1894
  yy_did_buffer_switch_on_eof = 1;
  }
#line 1895
  return;
}
}
#line 1901 "config-lexer.c"
void yypop_buffer_state(void) 
{ 
  YY_BUFFER_STATE tmp___0 ;
  YY_BUFFER_STATE tmp___1 ;
  YY_BUFFER_STATE tmp___2 ;

  {
#line 1903
  if (yy_buffer_stack) {
#line 1903
    tmp___0 = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
#line 1903
    tmp___0 = (YY_BUFFER_STATE )((void *)0);
  }
#line 1903
  if (! tmp___0) {
#line 1904
    return;
  }
#line 1906
  if (yy_buffer_stack) {
#line 1906
    tmp___1 = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
#line 1906
    tmp___1 = (YY_BUFFER_STATE )((void *)0);
  }
  {
#line 1906
  yy_delete_buffer(tmp___1);
#line 1907
  *(yy_buffer_stack + yy_buffer_stack_top) = (YY_BUFFER_STATE )((void *)0);
  }
#line 1908
  if (yy_buffer_stack_top > 0UL) {
#line 1909
    yy_buffer_stack_top --;
  }
#line 1911
  if (yy_buffer_stack) {
#line 1911
    tmp___2 = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
#line 1911
    tmp___2 = (YY_BUFFER_STATE )((void *)0);
  }
#line 1911
  if (tmp___2) {
    {
#line 1912
    yy_load_buffer_state();
#line 1913
    yy_did_buffer_switch_on_eof = 1;
    }
  }
#line 1915
  return;
}
}
#line 1920 "config-lexer.c"
static void yyensure_buffer_stack(void) 
{ 
  int num_to_alloc ;
  void *tmp___0 ;
  int grow_size ;
  void *tmp___1 ;

  {
#line 1924
  if (! yy_buffer_stack) {
    {
#line 1930
    num_to_alloc = 1;
#line 1931
    tmp___0 = yyalloc((yy_size_t )((unsigned long )num_to_alloc * sizeof(struct yy_buffer_state *)));
#line 1931
    yy_buffer_stack = (struct yy_buffer_state **)tmp___0;
#line 1935
    memset((void *)yy_buffer_stack, 0, (unsigned long )num_to_alloc * sizeof(struct yy_buffer_state *));
#line 1937
    yy_buffer_stack_max = (size_t )num_to_alloc;
#line 1938
    yy_buffer_stack_top = (size_t )0;
    }
#line 1939
    return;
  }
#line 1942
  if (yy_buffer_stack_top >= yy_buffer_stack_max - 1UL) {
    {
#line 1945
    grow_size = 8;
#line 1947
    num_to_alloc = (int )(yy_buffer_stack_max + (size_t )grow_size);
#line 1948
    tmp___1 = yyrealloc((void *)yy_buffer_stack, (yy_size_t )((unsigned long )num_to_alloc * sizeof(struct yy_buffer_state *)));
#line 1948
    yy_buffer_stack = (struct yy_buffer_state **)tmp___1;
#line 1954
    memset((void *)(yy_buffer_stack + yy_buffer_stack_max), 0, (unsigned long )grow_size * sizeof(struct yy_buffer_state *));
#line 1955
    yy_buffer_stack_max = (size_t )num_to_alloc;
    }
  }
#line 1957
  return;
}
}
#line 1965 "config-lexer.c"
YY_BUFFER_STATE yy_scan_buffer(char *base , yy_size_t size ) 
{ 
  YY_BUFFER_STATE b ;
  void *tmp___0 ;
  char *tmp___1 ;

  {
#line 1969
  if (size < 2U) {
#line 1973
    return ((YY_BUFFER_STATE )0);
  } else
#line 1969
  if ((int )*(base + (size - 2U)) != 0) {
#line 1973
    return ((YY_BUFFER_STATE )0);
  } else
#line 1969
  if ((int )*(base + (size - 1U)) != 0) {
#line 1973
    return ((YY_BUFFER_STATE )0);
  }
  {
#line 1975
  tmp___0 = yyalloc((yy_size_t )sizeof(struct yy_buffer_state ));
#line 1975
  b = (YY_BUFFER_STATE )tmp___0;
  }
#line 1976
  if (! b) {
    {
#line 1977
    yy_fatal_error("out of dynamic memory in yy_scan_buffer()");
    }
  }
  {
#line 1979
  b->yy_buf_size = size - 2U;
#line 1980
  tmp___1 = base;
#line 1980
  b->yy_ch_buf = tmp___1;
#line 1980
  b->yy_buf_pos = tmp___1;
#line 1981
  b->yy_is_our_buffer = 0;
#line 1982
  b->yy_input_file = (FILE *)0;
#line 1983
  b->yy_n_chars = (int )b->yy_buf_size;
#line 1984
  b->yy_is_interactive = 0;
#line 1985
  b->yy_at_bol = 1;
#line 1986
  b->yy_fill_buffer = 0;
#line 1987
  b->yy_buffer_status = 0;
#line 1989
  yy_switch_to_buffer(b);
  }
#line 1991
  return (b);
}
}
#line 2002 "config-lexer.c"
YY_BUFFER_STATE yy_scan_string(char const   *yystr ) 
{ 
  size_t tmp___0 ;
  YY_BUFFER_STATE tmp___1 ;

  {
  {
#line 2005
  tmp___0 = strlen(yystr);
#line 2005
  tmp___1 = yy_scan_bytes(yystr, (int )tmp___0);
  }
#line 2005
  return (tmp___1);
}
}
#line 2015 "config-lexer.c"
YY_BUFFER_STATE yy_scan_bytes(char const   *yybytes , int _yybytes_len ) 
{ 
  YY_BUFFER_STATE b ;
  char *buf___0 ;
  yy_size_t n ;
  int i ;
  void *tmp___0 ;
  char tmp___1 ;

  {
  {
#line 2023
  n = (yy_size_t )(_yybytes_len + 2);
#line 2024
  tmp___0 = yyalloc(n);
#line 2024
  buf___0 = (char *)tmp___0;
  }
#line 2025
  if (! buf___0) {
    {
#line 2026
    yy_fatal_error("out of dynamic memory in yy_scan_bytes()");
    }
  }
#line 2028
  i = 0;
  {
#line 2028
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2028
    if (! (i < _yybytes_len)) {
#line 2028
      goto while_break;
    }
#line 2029
    *(buf___0 + i) = (char )*(yybytes + i);
#line 2028
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2031
  tmp___1 = (char)0;
#line 2031
  *(buf___0 + (_yybytes_len + 1)) = tmp___1;
#line 2031
  *(buf___0 + _yybytes_len) = tmp___1;
#line 2033
  b = yy_scan_buffer(buf___0, n);
  }
#line 2034
  if (! b) {
    {
#line 2035
    yy_fatal_error("bad buffer in yy_scan_bytes()");
    }
  }
#line 2040
  b->yy_is_our_buffer = 1;
#line 2042
  return (b);
}
}
#line 2049 "config-lexer.c"
static void yy_fatal_error(char const   *msg___0 ) 
{ 


  {
  {
#line 2051
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s\n",
          msg___0);
#line 2052
  exit(2);
  }
}
}
#line 2077 "config-lexer.c"
int yyget_lineno(void) 
{ 


  {
#line 2080
  return (yylineno);
}
}
#line 2086 "config-lexer.c"
FILE *yyget_in(void) 
{ 


  {
#line 2088
  return (yyin);
}
}
#line 2094 "config-lexer.c"
FILE *yyget_out(void) 
{ 


  {
#line 2096
  return (yyout);
}
}
#line 2102 "config-lexer.c"
int yyget_leng(void) 
{ 


  {
#line 2104
  return (yyleng);
}
}
#line 2111 "config-lexer.c"
char *yyget_text(void) 
{ 


  {
#line 2113
  return (yytext);
}
}
#line 2120 "config-lexer.c"
void yyset_lineno(int line_number ) 
{ 


  {
#line 2123
  yylineno = line_number;
#line 2124
  return;
}
}
#line 2132 "config-lexer.c"
void yyset_in(FILE *in_str ) 
{ 


  {
#line 2134
  yyin = in_str;
#line 2135
  return;
}
}
#line 2137 "config-lexer.c"
void yyset_out(FILE *out_str ) 
{ 


  {
#line 2139
  yyout = out_str;
#line 2140
  return;
}
}
#line 2142 "config-lexer.c"
int yyget_debug(void) 
{ 


  {
#line 2144
  return (yy_flex_debug);
}
}
#line 2147 "config-lexer.c"
void yyset_debug(int bdebug ) 
{ 


  {
#line 2149
  yy_flex_debug = bdebug;
#line 2150
  return;
}
}
#line 2152 "config-lexer.c"
static int yy_init_globals(void) 
{ 


  {
#line 2158
  yy_buffer_stack = (YY_BUFFER_STATE *)0;
#line 2159
  yy_buffer_stack_top = (size_t )0;
#line 2160
  yy_buffer_stack_max = (size_t )0;
#line 2161
  yy_c_buf_p = (char *)0;
#line 2162
  yy_init = 0;
#line 2163
  yy_start = 0;
#line 2170
  yyin = (FILE *)0;
#line 2171
  yyout = (FILE *)0;
#line 2177
  return (0);
}
}
#line 2181 "config-lexer.c"
int yylex_destroy(void) 
{ 
  YY_BUFFER_STATE tmp___0 ;
  YY_BUFFER_STATE tmp___1 ;

  {
  {
#line 2185
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2185
    if (yy_buffer_stack) {
#line 2185
      tmp___1 = *(yy_buffer_stack + yy_buffer_stack_top);
    } else {
#line 2185
      tmp___1 = (YY_BUFFER_STATE )((void *)0);
    }
#line 2185
    if (! tmp___1) {
#line 2185
      goto while_break;
    }
#line 2186
    if (yy_buffer_stack) {
#line 2186
      tmp___0 = *(yy_buffer_stack + yy_buffer_stack_top);
    } else {
#line 2186
      tmp___0 = (YY_BUFFER_STATE )((void *)0);
    }
    {
#line 2186
    yy_delete_buffer(tmp___0);
#line 2187
    *(yy_buffer_stack + yy_buffer_stack_top) = (YY_BUFFER_STATE )((void *)0);
#line 2188
    yypop_buffer_state();
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2192
  yyfree((void *)yy_buffer_stack);
#line 2193
  yy_buffer_stack = (YY_BUFFER_STATE *)((void *)0);
#line 2197
  yy_init_globals();
  }
#line 2199
  return (0);
}
}
#line 2226 "config-lexer.c"
void *yyalloc(yy_size_t size ) 
{ 
  void *tmp___0 ;

  {
  {
#line 2228
  tmp___0 = malloc((size_t )size);
  }
#line 2228
  return (tmp___0);
}
}
#line 2231 "config-lexer.c"
void *yyrealloc(void *ptr , yy_size_t size ) 
{ 
  void *tmp___0 ;

  {
  {
#line 2240
  tmp___0 = realloc((void *)((char *)ptr), (size_t )size);
  }
#line 2240
  return (tmp___0);
}
}
#line 2243 "config-lexer.c"
void yyfree(void *ptr ) 
{ 


  {
  {
#line 2245
  free((void *)((char *)ptr));
  }
#line 2246
  return;
}
}
#line 226 "config-lexer.l"
void hashcomment(void) 
{ 


  {
#line 228
  return;
}
}
#line 232 "config-lexer.l"
void ccomment(void) 
{ 
  int c ;

  {
  {
#line 237
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 239
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 239
      c = input();
      }
#line 239
      if (c != 42) {
#line 239
        if (! (c != -1)) {
#line 239
          goto while_break___0;
        }
      } else {
#line 239
        goto while_break___0;
      }
#line 240
      if (c == 10) {
#line 240
        linenum ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 241
    if (c == 42) {
      {
#line 243
      while (1) {
        while_continue___1: /* CIL Label */ ;
        {
#line 243
        c = input();
        }
#line 243
        if (! (c == 42)) {
#line 243
          goto while_break___1;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 244
      if (c == 47) {
#line 244
        goto while_break;
      }
    }
#line 246
    if (c == -1) {
      {
#line 248
      yy_fatal_error("EOF in comment");
      }
#line 255
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 258
  return;
}
}
#line 45 "/home/june/collector/temp/bopm-3.1.3/src/libopm/src/proxy.c"
static char SENDBUF___2[513]  ;
#line 14 "/home/june/collector/temp/bopm-3.1.3/src/config.h"
void config_load(char const   *filename ) ;
#line 36 "/home/june/collector/temp/bopm-3.1.3/src/scan.h"
void scan_init(void) ;
#line 41 "/home/june/collector/temp/bopm-3.1.3/src/opercmd.h"
void command_init(void) ;
#line 14 "/home/june/collector/temp/bopm-3.1.3/src/stats.h"
void stats_init(void) ;
#line 45 "/home/june/collector/temp/bopm-3.1.3/src/config.c"
void config_setup(void) ;
#line 46
void config_init(void) ;
#line 52 "/home/june/collector/temp/bopm-3.1.3/src/config.c"
struct OptionsConf *OptionsItem  =    (struct OptionsConf *)((void *)0);
#line 53 "/home/june/collector/temp/bopm-3.1.3/src/config.c"
struct IRCConf *IRCItem  =    (struct IRCConf *)((void *)0);
#line 54 "/home/june/collector/temp/bopm-3.1.3/src/config.c"
struct OpmConf *OpmItem  =    (struct OpmConf *)((void *)0);
#line 55 "/home/june/collector/temp/bopm-3.1.3/src/config.c"
struct ExemptConf *ExemptItem  =    (struct ExemptConf *)((void *)0);
#line 56 "/home/june/collector/temp/bopm-3.1.3/src/config.c"
list_t *UserItemList  =    (list_t *)((void *)0);
#line 57 "/home/june/collector/temp/bopm-3.1.3/src/config.c"
list_t *ScannerItemList  =    (list_t *)((void *)0);
#line 64 "/home/june/collector/temp/bopm-3.1.3/src/config.c"
void config_load(char const   *filename ) 
{ 


  {
  {
#line 67
  config_init();
#line 68
  config_setup();
#line 70
  log_printf((char *)"CONFIG -> Loading %s", filename);
#line 72
  yyin = fopen((char const   */* __restrict  */)filename, (char const   */* __restrict  */)"r");
  }
#line 72
  if ((unsigned long )yyin == (unsigned long )((void *)0)) {
    {
#line 74
    log_printf((char *)"CONFIG -> Error opening %s", filename);
#line 75
    exit(1);
    }
  }
  {
#line 78
  yyparse();
#line 80
  scan_init();
#line 81
  command_init();
#line 82
  stats_init();
#line 83
  firedns_init();
#line 85
  fclose(yyin);
  }
#line 86
  return;
}
}
#line 89 "/home/june/collector/temp/bopm-3.1.3/src/config.c"
void config_init(void) 
{ 
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;

  {
  {
#line 92
  tmp___0 = MyMalloc(sizeof(*IRCItem));
#line 92
  IRCItem = (struct IRCConf *)tmp___0;
#line 93
  memset((void *)IRCItem, 0, sizeof(*IRCItem));
#line 94
  IRCItem->channels = list_create();
#line 95
  IRCItem->performs = list_create();
#line 98
  tmp___1 = MyMalloc(sizeof(*OptionsItem));
#line 98
  OptionsItem = (struct OptionsConf *)tmp___1;
#line 99
  memset((void *)OptionsItem, 0, sizeof(*OptionsItem));
#line 102
  tmp___2 = MyMalloc(sizeof(*OpmItem));
#line 102
  OpmItem = (struct OpmConf *)tmp___2;
#line 103
  memset((void *)OpmItem, 0, sizeof(*OpmItem));
#line 104
  OpmItem->blacklists = list_create();
#line 107
  UserItemList = list_create();
#line 110
  ScannerItemList = list_create();
#line 113
  tmp___3 = MyMalloc(sizeof(*ExemptItem));
#line 113
  ExemptItem = (struct ExemptConf *)tmp___3;
#line 114
  ExemptItem->masks = list_create();
  }
#line 115
  return;
}
}
#line 119 "/home/june/collector/temp/bopm-3.1.3/src/config.c"
void config_setup(void) 
{ 


  {
  {
#line 123
  IRCItem->away = DupString("I\'m a bot, don\'t message me");
#line 124
  IRCItem->mode = DupString("+cs");
#line 125
  IRCItem->nick = DupString("bopm");
#line 126
  IRCItem->nickserv = DupString("");
#line 127
  IRCItem->password = DupString("");
#line 128
  IRCItem->port = 6667;
#line 129
  IRCItem->oper = DupString("undefined");
#line 130
  IRCItem->username = DupString("bopm");
#line 131
  IRCItem->realname = DupString("Blitzed Open Proxy Monitor");
#line 132
  IRCItem->server = DupString("myserver.blitzed.org");
#line 133
  IRCItem->vhost = DupString("");
#line 134
  IRCItem->connregex = DupString("\\*\\*\\* Notice -- Client connecting: ([^ ]+) \\(([^@]+)@([^\\)]+)\\) \\[([0-9\\.]+)\\].*");
#line 135
  IRCItem->kline = DupString("KLINE %u@%h :Open Proxy found on your host. Please visit www.blitzed.org/proxy?ip=%i for more information.");
#line 139
  OptionsItem->negcache = 0;
#line 140
  OptionsItem->pidfile = DupString("bopm.pid");
#line 141
  OptionsItem->dns_fdlimit = 50U;
#line 142
  OptionsItem->scanlog = (char *)((void *)0);
#line 145
  OpmItem->sendmail = DupString("/usr/sbin/sendmail");
#line 146
  OpmItem->dnsbl_from = DupString("");
#line 147
  OpmItem->dnsbl_to = DupString("");
  }
#line 148
  return;
}
}
#line 150 "/home/june/collector/temp/bopm-3.1.3/src/config.c"
void yyerror(char const   *str ) 
{ 


  {
  {
#line 152
  log_printf((char *)"CONFIG -> %s: line %d", str, linenum);
#line 153
  exit(1);
  }
}
}
#line 531 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) dup)(int __fd ) ;
#line 50 "/usr/include/x86_64-linux-gnu/sys/resource.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getrlimit)(__rlimit_resource_t __resource ,
                                                                                struct rlimit *__rlimits ) ;
#line 15 "/home/june/collector/temp/bopm-3.1.3/src/stats.h"
void stats_openproxy(int type ) ;
#line 19
void stats_output(char *target ) ;
#line 21
void fdstats_output(char *target ) ;
#line 72 "/home/june/collector/temp/bopm-3.1.3/src/stats.c"
static time_t STATS_UPTIME  ;
#line 73 "/home/june/collector/temp/bopm-3.1.3/src/stats.c"
static unsigned int STATS_CONNECTIONS  ;
#line 74 "/home/june/collector/temp/bopm-3.1.3/src/stats.c"
static unsigned int STATS_DNSBLSENT  ;
#line 76 "/home/june/collector/temp/bopm-3.1.3/src/stats.c"
static struct StatsHash STATS_PROXIES[6]  = {      {1, 0U, (char *)"HTTP"}, 
        {6, 0U, (char *)"HTTPPOST"}, 
        {2, 0U, (char *)"SOCKS4"}, 
        {3, 0U, (char *)"SOCKS5"}, 
        {5, 0U, (char *)"ROUTER"}, 
        {4, 0U, (char *)"WINGATE"}};
#line 96 "/home/june/collector/temp/bopm-3.1.3/src/stats.c"
void stats_init(void) 
{ 


  {
  {
#line 98
  time(& STATS_UPTIME);
  }
#line 99
  return;
}
}
#line 114 "/home/june/collector/temp/bopm-3.1.3/src/stats.c"
void stats_openproxy(int type ) 
{ 
  unsigned int i ;

  {
#line 118
  i = 0U;
  {
#line 118
  while (1) {
    while_continue: /* CIL Label */ ;
#line 118
    if (! ((unsigned long )i < sizeof(STATS_PROXIES) / sizeof(struct StatsHash ))) {
#line 118
      goto while_break;
    }
#line 119
    if (STATS_PROXIES[i].type == type) {
#line 120
      (STATS_PROXIES[i].count) ++;
    }
#line 118
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 121
  return;
}
}
#line 136 "/home/june/collector/temp/bopm-3.1.3/src/stats.c"
void stats_connect(void) 
{ 


  {
#line 138
  STATS_CONNECTIONS ++;
#line 139
  return;
}
}
#line 152 "/home/june/collector/temp/bopm-3.1.3/src/stats.c"
void stats_dnsblrecv(struct BlacklistConf *bl ) 
{ 


  {
#line 154
  (bl->stats_recv) ++;
#line 155
  return;
}
}
#line 169 "/home/june/collector/temp/bopm-3.1.3/src/stats.c"
void stats_dnsblsend(void) 
{ 


  {
#line 171
  STATS_DNSBLSENT ++;
#line 172
  return;
}
}
#line 187 "/home/june/collector/temp/bopm-3.1.3/src/stats.c"
void stats_output(char *target ) 
{ 
  unsigned int i ;
  time_t present ;
  time_t uptime ;
  node_t *p ;
  struct BlacklistConf *bl ;
  char *tmp___0 ;
  double tmp___1 ;

  {
  {
#line 195
  time(& present);
#line 196
  uptime = present - STATS_UPTIME;
#line 198
  tmp___0 = dissect_time(uptime);
#line 198
  irc_send((char *)"PRIVMSG %s :Uptime: %s", target, tmp___0);
#line 200
  p = (OpmItem->blacklists)->head;
  }
  {
#line 200
  while (1) {
    while_continue: /* CIL Label */ ;
#line 200
    if (! ((unsigned long )p != (unsigned long )((void *)0))) {
#line 200
      goto while_break;
    }
#line 202
    bl = (struct BlacklistConf *)p->data;
#line 203
    if (bl->stats_recv > 0U) {
      {
#line 205
      irc_send((char *)"PRIVMSG %s :DNSBL: %u successful lookups from %s", target,
               bl->stats_recv, bl->name);
      }
    }
#line 200
    p = p->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 210
  if (STATS_DNSBLSENT > 0U) {
    {
#line 212
    irc_send((char *)"PRIVMSG %s :DNSBL: %u reports sent", target, STATS_DNSBLSENT);
    }
  }
#line 216
  i = 0U;
  {
#line 216
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 216
    if (! ((unsigned long )i < sizeof(STATS_PROXIES) / sizeof(struct StatsHash ))) {
#line 216
      goto while_break___0;
    }
#line 218
    if (STATS_PROXIES[i].count > 0U) {
      {
#line 220
      irc_send((char *)"PRIVMSG %s :Found %u (%s) open.", target, STATS_PROXIES[i].count,
               STATS_PROXIES[i].name);
      }
    }
#line 216
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 225
  if (STATS_CONNECTIONS) {
#line 225
    tmp___1 = (double )((float )STATS_CONNECTIONS) / ((double )((float )uptime) / 60.0);
  } else {
#line 225
    tmp___1 = 0.0;
  }
  {
#line 225
  irc_send((char *)"PRIVMSG %s :Number of connects: %u (%.2f/minute)", target, STATS_CONNECTIONS,
           tmp___1);
  }
#line 229
  return;
}
}
#line 243 "/home/june/collector/temp/bopm-3.1.3/src/stats.c"
void fdstats_output(char *target ) 
{ 
  struct rlimit rlim ;
  unsigned int total_fd_use ;
  unsigned int i ;
  int newfd ;
  int *tmp___0 ;
  char *tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  int *tmp___6 ;
  char *tmp___7 ;
  int *tmp___8 ;

  {
  {
#line 250
  tmp___4 = getrlimit(7, & rlim);
  }
#line 250
  if (tmp___4 == -1) {
    {
#line 252
    tmp___0 = __errno_location();
#line 252
    tmp___1 = strerror(*tmp___0);
#line 252
    log_printf((char *)"FDSTAT -> getrlimit() error retrieving RLIMIT_NOFILE (%s)",
               tmp___1);
#line 253
    tmp___2 = __errno_location();
#line 253
    tmp___3 = strerror(*tmp___2);
#line 253
    irc_send((char *)"PRIVMSG %s :FDSTAT -> getrlimit() error retrieving RLIMIT_NOFILE (%s)",
             target, tmp___3);
    }
#line 255
    return;
  }
#line 262
  total_fd_use = 0U;
#line 263
  i = 0U;
  {
#line 263
  while (1) {
    while_continue: /* CIL Label */ ;
#line 263
    if (! ((rlim_t )i < rlim.rlim_cur)) {
#line 263
      goto while_break;
    }
    {
#line 265
    newfd = dup((int )i);
    }
#line 267
    if (newfd > 0) {
      {
#line 268
      total_fd_use ++;
#line 269
      close(newfd);
      }
    } else {
      {
#line 273
      tmp___5 = __errno_location();
      }
      {
#line 275
      if (*tmp___5 == 24) {
#line 275
        goto case_24;
      }
#line 283
      if (*tmp___5 == 9) {
#line 283
        goto case_9;
      }
#line 287
      if (*tmp___5 == 4) {
#line 287
        goto case_4;
      }
#line 292
      goto switch_default;
      case_24: /* CIL Label */ 
#line 280
      total_fd_use = (unsigned int )rlim.rlim_cur;
#line 280
      i = total_fd_use;
#line 281
      goto switch_break;
      case_9: /* CIL Label */ 
#line 285
      goto switch_break;
      case_4: /* CIL Label */ 
#line 289
      i --;
#line 290
      goto switch_break;
      switch_default: /* CIL Label */ 
      {
#line 294
      tmp___6 = __errno_location();
#line 294
      tmp___7 = strerror(*tmp___6);
#line 294
      tmp___8 = __errno_location();
#line 294
      log_printf((char *)"fd %u errno = %u (%s)", i, *tmp___8, tmp___7);
      }
#line 295
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
#line 263
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 300
  irc_send((char *)"PRIVMSG %s :Total open FD: %u/%d", target, total_fd_use, rlim.rlim_cur);
  }
#line 301
  return;
}
}
#line 63 "/home/june/collector/temp/bopm-3.1.3/src/list.h"
void list_free(list_t *list ) ;
#line 30 "/home/june/collector/temp/bopm-3.1.3/src/list.c"
node_t *node_create(void *data ) 
{ 
  node_t *node ;
  void *tmp___0 ;

  {
  {
#line 32
  tmp___0 = MyMalloc(sizeof(*node));
#line 32
  node = (node_t *)tmp___0;
#line 33
  node->next = (struct _node *)((void *)0);
#line 34
  node->prev = (struct _node *)((void *)0);
#line 35
  node->data = data;
  }
#line 37
  return (node);
}
}
#line 40 "/home/june/collector/temp/bopm-3.1.3/src/list.c"
list_t *list_create(void) 
{ 
  list_t *list ;
  void *tmp___0 ;

  {
  {
#line 42
  tmp___0 = MyMalloc(sizeof(*list));
#line 42
  list = (list_t *)tmp___0;
#line 44
  list->head = (struct _node *)((void *)0);
#line 45
  list->tail = (struct _node *)((void *)0);
#line 47
  list->elements = 0;
  }
#line 49
  return (list);
}
}
#line 52 "/home/june/collector/temp/bopm-3.1.3/src/list.c"
node_t *list_add(list_t *list , node_t *node ) 
{ 


  {
#line 55
  if ((unsigned long )list == (unsigned long )((void *)0)) {
#line 56
    return ((node_t *)((void *)0));
  } else
#line 55
  if ((unsigned long )node == (unsigned long )((void *)0)) {
#line 56
    return ((node_t *)((void *)0));
  }
#line 58
  if ((unsigned long )list->tail == (unsigned long )((void *)0)) {
#line 60
    list->head = node;
#line 61
    list->tail = node;
#line 63
    node->next = (struct _node *)((void *)0);
#line 64
    node->prev = (struct _node *)((void *)0);
  } else {
#line 68
    node->prev = list->tail;
#line 69
    (list->tail)->next = node;
#line 70
    list->tail = node;
#line 71
    node->next = (struct _node *)((void *)0);
  }
#line 74
  (list->elements) ++;
#line 75
  return (node);
}
}
#line 78 "/home/june/collector/temp/bopm-3.1.3/src/list.c"
node_t *list_remove(list_t *list , node_t *node ) 
{ 


  {
#line 80
  if ((unsigned long )list == (unsigned long )((void *)0)) {
#line 81
    return ((node_t *)((void *)0));
  } else
#line 80
  if ((unsigned long )node == (unsigned long )((void *)0)) {
#line 81
    return ((node_t *)((void *)0));
  }
#line 83
  if ((unsigned long )node == (unsigned long )list->head) {
#line 85
    list->head = node->next;
#line 87
    if (node->next) {
#line 88
      (node->next)->prev = (struct _node *)((void *)0);
    } else {
#line 90
      list->tail = (struct _node *)((void *)0);
    }
  } else
#line 92
  if ((unsigned long )node == (unsigned long )list->tail) {
#line 94
    list->tail = (list->tail)->prev;
#line 95
    (list->tail)->next = (struct _node *)((void *)0);
  } else {
#line 99
    (node->prev)->next = node->next;
#line 100
    (node->next)->prev = node->prev;
  }
#line 103
  (list->elements) --;
#line 104
  return (node);
}
}
#line 107 "/home/june/collector/temp/bopm-3.1.3/src/list.c"
void list_free(list_t *list ) 
{ 


  {
  {
#line 109
  _MyFree((void **)(& list));
  }
#line 110
  return;
}
}
#line 112 "/home/june/collector/temp/bopm-3.1.3/src/list.c"
void node_free(node_t *node ) 
{ 


  {
  {
#line 114
  _MyFree((void **)(& node));
  }
#line 115
  return;
}
}
#line 14 "/home/june/collector/temp/bopm-3.1.3/src/negcache.h"
struct cnode *check_neg_cache(unsigned long const   ip ) ;
#line 15
void negcache_insert(char const   *ipstr ) ;
#line 16
void negcache_rebuild(void) ;
#line 72 "/home/june/collector/temp/bopm-3.1.3/src/negcache.c"
static struct cnode *nc_search(struct cnode *head , unsigned long const   ip ) ;
#line 73
static struct cnode *nc_insert(struct cnode *head , unsigned long const   ip ) ;
#line 74
static void nc_rebuild(struct cnode *old_head , struct cnode *new_head , struct cnode *n ,
                       time_t now ) ;
#line 77 "/home/june/collector/temp/bopm-3.1.3/src/negcache.c"
time_t last_nc_expire  ;
#line 78 "/home/june/collector/temp/bopm-3.1.3/src/negcache.c"
unsigned int maxb  ;
#line 90 "/home/june/collector/temp/bopm-3.1.3/src/negcache.c"
void nc_init(struct cnode **head ) 
{ 
  void *tmp___0 ;
  struct cnode *tmp___1 ;

  {
#line 92
  if (*head) {
#line 95
    return;
  }
  {
#line 98
  tmp___0 = MyMalloc(sizeof(*(*head)));
#line 98
  *head = (struct cnode *)tmp___0;
#line 100
  maxb = (unsigned int )(sizeof((*head)->ip) * 8UL);
#line 101
  (*head)->ip = 0UL;
#line 102
  (*head)->b = maxb;
#line 103
  tmp___1 = *head;
#line 103
  (*head)->r = tmp___1;
#line 103
  (*head)->l = tmp___1;
#line 104
  last_nc_expire = time((time_t *)((void *)0));
  }
#line 105
  return;
}
}
#line 112 "/home/june/collector/temp/bopm-3.1.3/src/negcache.c"
static struct cnode *nc_search(struct cnode *head , unsigned long const   ip ) 
{ 
  struct cnode *p ;
  struct cnode *x ;

  {
#line 116
  p = head;
#line 117
  x = head->l;
  {
#line 119
  while (1) {
    while_continue: /* CIL Label */ ;
#line 119
    if (! (p->b > x->b)) {
#line 119
      goto while_break;
    }
#line 121
    p = x;
#line 122
    if ((ip >> x->b) & 1UL) {
#line 122
      x = x->r;
    } else {
#line 122
      x = x->l;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 125
  if (ip == (unsigned long const   )x->ip) {
#line 126
    return (x);
  } else {
#line 128
    return ((struct cnode *)((void *)0));
  }
}
}
#line 134 "/home/june/collector/temp/bopm-3.1.3/src/negcache.c"
static struct cnode *nc_insert(struct cnode *head , unsigned long const   ip ) 
{ 
  unsigned int i ;
  struct cnode *p ;
  struct cnode *t ;
  struct cnode *x ;
  void *tmp___0 ;

  {
#line 139
  i = maxb;
#line 140
  p = head;
#line 141
  t = head->l;
  {
#line 143
  while (1) {
    while_continue: /* CIL Label */ ;
#line 143
    if (! (p->b > t->b)) {
#line 143
      goto while_break;
    }
#line 145
    p = t;
#line 146
    if ((ip >> t->b) & 1UL) {
#line 146
      t = t->r;
    } else {
#line 146
      t = t->l;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 149
  if (ip == (unsigned long const   )t->ip) {
#line 152
    return (t);
  }
  {
#line 155
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 155
    if (! (((t->ip >> i) & 1UL) == (unsigned long )((ip >> i) & 1UL))) {
#line 155
      goto while_break___0;
    }
#line 156
    i --;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 158
  p = head;
#line 159
  x = head->l;
  {
#line 161
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 161
    if (p->b > x->b) {
#line 161
      if (! (x->b > i)) {
#line 161
        goto while_break___1;
      }
    } else {
#line 161
      goto while_break___1;
    }
#line 163
    p = x;
#line 164
    if ((ip >> x->b) & 1UL) {
#line 164
      x = x->r;
    } else {
#line 164
      x = x->l;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 167
  tmp___0 = MyMalloc(sizeof(*t));
#line 167
  t = (struct cnode *)tmp___0;
#line 168
  t->ip = (unsigned long )ip;
#line 169
  t->b = i;
  }
#line 170
  if ((ip >> t->b) & 1UL) {
#line 170
    t->l = x;
  } else {
#line 170
    t->l = t;
  }
#line 171
  if ((ip >> t->b) & 1UL) {
#line 171
    t->r = t;
  } else {
#line 171
    t->r = x;
  }
#line 173
  if ((ip >> p->b) & 1UL) {
#line 174
    p->r = t;
  } else {
#line 176
    p->l = t;
  }
#line 178
  return (t);
}
}
#line 185 "/home/june/collector/temp/bopm-3.1.3/src/negcache.c"
struct cnode *check_neg_cache(unsigned long const   ip ) 
{ 
  time_t now ;
  struct cnode *n ;

  {
#line 190
  if (OptionsItem->negcache <= 0) {
#line 191
    return ((struct cnode *)((void *)0));
  }
  {
#line 193
  n = nc_search(nc_head, ip);
  }
#line 195
  if (n) {
    {
#line 198
    now = time((time_t *)((void *)0));
    }
#line 200
    if (now - n->seen <= (time_t )OptionsItem->negcache) {
#line 201
      return (n);
    }
  }
#line 204
  return ((struct cnode *)((void *)0));
}
}
#line 211 "/home/june/collector/temp/bopm-3.1.3/src/negcache.c"
void negcache_insert(char const   *ipstr ) 
{ 
  struct bopm_sockaddr ip ;
  struct cnode *n ;
  int tmp___0 ;

  {
  {
#line 216
  tmp___0 = inet_pton(2, (char const   */* __restrict  */)ipstr, (void */* __restrict  */)(& ip.sa4.sin_addr));
  }
#line 216
  if (! tmp___0) {
    {
#line 218
    log_printf((char *)"NEGCACHE -> Invalid IPv4 address \'%s\'", ipstr);
    }
#line 219
    return;
  }
  {
#line 222
  n = nc_insert(nc_head, (unsigned long const   )ip.sa4.sin_addr.s_addr);
  }
#line 224
  if (n) {
    {
#line 225
    n->seen = time((time_t *)((void *)0));
    }
  }
#line 226
  return;
}
}
#line 232 "/home/june/collector/temp/bopm-3.1.3/src/negcache.c"
static void nc_rebuild(struct cnode *old_head , struct cnode *new_head , struct cnode *n ,
                       time_t now ) 
{ 
  struct cnode *new ;

  {
#line 237
  if (! n) {
#line 240
    n = old_head->l;
  }
#line 243
  if ((unsigned long )n == (unsigned long )old_head) {
#line 246
    return;
  }
#line 249
  if (n->b > (n->l)->b) {
    {
#line 255
    nc_rebuild(old_head, new_head, n->l, now);
    }
  }
#line 258
  if (n->b > (n->r)->b) {
    {
#line 264
    nc_rebuild(old_head, new_head, n->r, now);
    }
  }
#line 267
  if (now - n->seen < (time_t )OptionsItem->negcache) {
    {
#line 273
    new = nc_insert(new_head, (unsigned long const   )n->ip);
#line 274
    new->seen = n->seen;
    }
  } else
#line 276
  if (OPT_DEBUG >= 2U) {
    {
#line 278
    log_printf((char *)"NEGCACHE -> Deleting negcache node for %lu added at %lu",
               n->ip, n->seen);
    }
  }
  {
#line 283
  _MyFree((void **)(& n));
  }
#line 284
  return;
}
}
#line 289 "/home/june/collector/temp/bopm-3.1.3/src/negcache.c"
void negcache_rebuild(void) 
{ 
  time_t now ;
  struct cnode *new_head ;

  {
  {
#line 294
  now = time((time_t *)((void *)0));
#line 295
  new_head = (struct cnode *)((void *)0);
#line 297
  nc_init(& new_head);
#line 298
  nc_rebuild(nc_head, new_head, (struct cnode *)((void *)0), now);
#line 299
  _MyFree((void **)(& nc_head));
#line 300
  nc_head = new_head;
  }
#line 301
  return;
}
}
#line 137 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcat)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 53 "/usr/include/arpa/inet.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) inet_ntoa)(struct in_addr __in ) ;
#line 38 "/home/june/collector/temp/bopm-3.1.3/src/scan.h"
void scan_cycle(void) ;
#line 41
void scan_manual(char *param , struct ChannelConf *target ) ;
#line 42
int scan_checkexempt(char *mask___0 , char *ipmask___0 ) ;
#line 43
void scan_timer(void) ;
#line 80 "/home/june/collector/temp/bopm-3.1.3/src/scan.c"
static list_t *SCANNERS  =    (list_t *)((void *)0);
#line 81 "/home/june/collector/temp/bopm-3.1.3/src/scan.c"
static list_t *MASKS  =    (list_t *)((void *)0);
#line 85 "/home/june/collector/temp/bopm-3.1.3/src/scan.c"
struct cnode *nc_head  ;
#line 90
struct scan_struct *scan_create(char **user , char *msg___0 ) ;
#line 91
void scan_free(struct scan_struct *ss ) ;
#line 92
static void scan_irckline(struct scan_struct *ss , char *format , char *type ) ;
#line 93
static void scan_negative(struct scan_struct *ss ) ;
#line 94
static void scan_log(OPM_REMOTE_T *remote ) ;
#line 97
void scan_open_proxy(OPM_T *scanner , OPM_REMOTE_T *remote , int notused , void *data ) ;
#line 98
void scan_negotiation_failed(OPM_T *scanner , OPM_REMOTE_T *remote , int notused ,
                             void *data ) ;
#line 99
static void scan_timeout(OPM_T *scanner , OPM_REMOTE_T *remote , int notused , void *data ) ;
#line 100
static void scan_end(OPM_T *scanner , OPM_REMOTE_T *remote , int notused , void *data ) ;
#line 101
static void scan_handle_error(OPM_T *scanner , OPM_REMOTE_T *remote , int err , void *data ) ;
#line 110 "/home/june/collector/temp/bopm-3.1.3/src/scan.c"
void scan_cycle(void) 
{ 
  node_t *p ;
  struct scanner_struct *scs ;

  {
  {
#line 116
  dnsbl_cycle();
#line 119
  p = SCANNERS->head;
  }
  {
#line 119
  while (1) {
    while_continue: /* CIL Label */ ;
#line 119
    if (! ((unsigned long )p != (unsigned long )((void *)0))) {
#line 119
      goto while_break;
    }
    {
#line 121
    scs = (struct scanner_struct *)p->data;
#line 122
    opm_cycle(scs->scanner);
#line 119
    p = p->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 124
  return;
}
}
#line 139 "/home/june/collector/temp/bopm-3.1.3/src/scan.c"
static int nc_counter  ;
#line 137 "/home/june/collector/temp/bopm-3.1.3/src/scan.c"
void scan_timer(void) 
{ 
  int tmp___0 ;

  {
#line 141
  if (OptionsItem->negcache > 0) {
#line 143
    tmp___0 = nc_counter;
#line 143
    nc_counter ++;
#line 143
    if (tmp___0 >= 43200) {
#line 149
      if (OPT_DEBUG) {
        {
#line 150
        log_printf((char *)"SCAN -> Rebuilding negative cache");
        }
      }
      {
#line 152
      negcache_rebuild();
#line 153
      nc_counter = 0;
      }
    }
  }
#line 156
  return;
}
}
#line 175 "/home/june/collector/temp/bopm-3.1.3/src/scan.c"
static char *undef  =    (char *)"undefined";
#line 177 "/home/june/collector/temp/bopm-3.1.3/src/scan.c"
static struct protocol_assoc protocols[6]  = {      {1, (char *)"HTTP"}, 
        {6, (char *)"HTTPPOST"}, 
        {2, (char *)"SOCKS4"}, 
        {3, (char *)"SOCKS5"}, 
        {4, (char *)"WINGATE"}, 
        {5, (char *)"ROUTER"}};
#line 172 "/home/june/collector/temp/bopm-3.1.3/src/scan.c"
char *scan_gettype(int protocol ) 
{ 
  unsigned int i ;

  {
#line 187
  i = 0U;
  {
#line 187
  while (1) {
    while_continue: /* CIL Label */ ;
#line 187
    if (! ((unsigned long )i < sizeof(protocols) / sizeof(struct protocol_assoc ))) {
#line 187
      goto while_break;
    }
#line 188
    if (protocol == protocols[i].type) {
#line 189
      return (protocols[i].name);
    }
#line 187
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 191
  return (undef);
}
}
#line 206 "/home/june/collector/temp/bopm-3.1.3/src/scan.c"
void scan_init(void) 
{ 
  node_t *p ;
  node_t *p2 ;
  node_t *p3 ;
  node_t *p4 ;
  node_t *node ;
  struct UserConf *uc ;
  struct ScannerConf *sc ;
  struct ProtocolConf *pc ;
  struct scanner_struct *scs ;
  char *mask___0 ;
  char *scannername ;
  void *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  OPM_ERR_T tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;

  {
  {
#line 220
  SCANNERS = list_create();
#line 221
  MASKS = list_create();
#line 224
  p = ScannerItemList->head;
  }
  {
#line 224
  while (1) {
    while_continue: /* CIL Label */ ;
#line 224
    if (! ((unsigned long )p != (unsigned long )((void *)0))) {
#line 224
      goto while_break;
    }
    {
#line 226
    sc = (struct ScannerConf *)p->data;
#line 227
    tmp___0 = MyMalloc(sizeof(*scs));
#line 227
    scs = (struct scanner_struct *)tmp___0;
    }
#line 229
    if (OPT_DEBUG) {
      {
#line 230
      log_printf((char *)"SCAN -> Setting up scanner [%s]", sc->name);
      }
    }
    {
#line 233
    scs->scanner = opm_create();
#line 234
    tmp___1 = DupString((char const   *)sc->name);
#line 234
    scs->name = tmp___1;
#line 235
    scs->masks = list_create();
#line 238
    opm_config(scs->scanner, 0, (void *)(& sc->fd));
#line 239
    opm_config(scs->scanner, 4, (void *)sc->target_ip);
#line 240
    opm_config(scs->scanner, 5, (void *)(& sc->target_port));
#line 241
    opm_config(scs->scanner, 7, (void *)(& sc->timeout));
#line 242
    opm_config(scs->scanner, 6, (void *)(& sc->max_read));
#line 243
    opm_config(scs->scanner, 1, (void *)sc->vhost);
#line 246
    p2 = (sc->target_string)->head;
    }
    {
#line 246
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 246
      if (! ((unsigned long )p2 != (unsigned long )((void *)0))) {
#line 246
        goto while_break___0;
      }
      {
#line 247
      opm_config(scs->scanner, 3, (void *)((char *)p2->data));
#line 246
      p2 = p2->next;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 250
    opm_callback(scs->scanner, 0, & scan_open_proxy, (void *)scs);
#line 251
    opm_callback(scs->scanner, 1, & scan_negotiation_failed, (void *)scs);
#line 252
    opm_callback(scs->scanner, 4, & scan_timeout, (void *)scs);
#line 253
    opm_callback(scs->scanner, 2, & scan_end, (void *)scs);
#line 254
    opm_callback(scs->scanner, 3, & scan_handle_error, (void *)scs);
#line 258
    p2 = (sc->protocols)->head;
    }
    {
#line 258
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 258
      if (! ((unsigned long )p2 != (unsigned long )((void *)0))) {
#line 258
        goto while_break___1;
      }
#line 260
      pc = (struct ProtocolConf *)p2->data;
#line 262
      if (OPT_DEBUG >= 2U) {
        {
#line 264
        tmp___2 = scan_gettype(pc->type);
#line 264
        log_printf((char *)"SCAN -> Adding protocol %s:%d to scanner [%s]", tmp___2,
                   pc->port, scs->name);
        }
      }
      {
#line 268
      tmp___4 = opm_addtype(scs->scanner, pc->type, (unsigned short )pc->port);
      }
#line 268
      if (tmp___4 == 4) {
        {
#line 270
        tmp___3 = scan_gettype(pc->type);
#line 270
        log_printf((char *)"SCAN -> Error bad protocol %s:%d in scanner [%s]", tmp___3,
                   pc->port, scs->name);
        }
      }
#line 258
      p2 = p2->next;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 275
    node = node_create((void *)scs);
#line 276
    list_add(SCANNERS, node);
#line 224
    p = p->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 281
  p = SCANNERS->head;
  {
#line 281
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 281
    if (! ((unsigned long )p != (unsigned long )((void *)0))) {
#line 281
      goto while_break___2;
    }
#line 283
    scs = (struct scanner_struct *)p->data;
#line 285
    p2 = UserItemList->head;
    {
#line 285
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 285
      if (! ((unsigned long )p2 != (unsigned long )((void *)0))) {
#line 285
        goto while_break___3;
      }
#line 287
      uc = (struct UserConf *)p2->data;
#line 288
      p3 = (uc->scanners)->head;
      {
#line 288
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 288
        if (! ((unsigned long )p3 != (unsigned long )((void *)0))) {
#line 288
          goto while_break___4;
        }
        {
#line 290
        scannername = (char *)p3->data;
#line 292
        tmp___6 = strcasecmp((char const   *)scannername, (char const   *)scs->name);
        }
#line 292
        if (tmp___6 == 0) {
#line 294
          p4 = (uc->masks)->head;
          {
#line 294
          while (1) {
            while_continue___5: /* CIL Label */ ;
#line 294
            if (! ((unsigned long )p4 != (unsigned long )((void *)0))) {
#line 294
              goto while_break___5;
            }
#line 296
            mask___0 = (char *)p4->data;
#line 298
            if (OPT_DEBUG) {
              {
#line 300
              log_printf((char *)"SCAN -> Linking the mask [%s] to scanner [%s]",
                         mask___0, scannername);
              }
            }
            {
#line 304
            tmp___5 = DupString((char const   *)mask___0);
#line 304
            node = node_create((void *)tmp___5);
#line 305
            list_add(scs->masks, node);
#line 294
            p4 = p4->next;
            }
          }
          while_break___5: /* CIL Label */ ;
          }
#line 307
          goto while_break___4;
        }
#line 288
        p3 = p3->next;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 285
      p2 = p2->next;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 281
    p = p->next;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 314
  if (OptionsItem->negcache > 0) {
#line 316
    if (OPT_DEBUG >= 2U) {
      {
#line 317
      log_printf((char *)"SCAN -> Initializing negative cache");
      }
    }
    {
#line 318
    nc_init(& nc_head);
    }
  }
#line 320
  return;
}
}
#line 355 "/home/june/collector/temp/bopm-3.1.3/src/scan.c"
static char mask[513]  ;
#line 356 "/home/june/collector/temp/bopm-3.1.3/src/scan.c"
static char ipmask[513]  ;
#line 339 "/home/june/collector/temp/bopm-3.1.3/src/scan.c"
void scan_connect(char **user , char *msg___0 ) 
{ 
  struct bopm_sockaddr ip ;
  node_t *p ;
  node_t *p2 ;
  struct scan_struct *ss ;
  struct scanner_struct *scs ;
  char *scsmask ;
  int ret ;
  struct cnode *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  int tmp___5 ;

  {
#line 359
  if (OptionsItem->negcache > 0) {
    {
#line 361
    tmp___1 = inet_pton(2, (char const   */* __restrict  */)*(user + 3), (void */* __restrict  */)(& ip.sa4.sin_addr));
    }
#line 361
    if (tmp___1) {
      {
#line 368
      tmp___0 = check_neg_cache((unsigned long const   )ip.sa4.sin_addr.s_addr);
      }
#line 368
      if ((unsigned long )tmp___0 != (unsigned long )((void *)0)) {
#line 370
        if (OPT_DEBUG) {
          {
#line 372
          log_printf((char *)"SCAN -> %s!%s@%s (%s) is negatively cached. Skipping all tests.",
                     *(user + 0), *(user + 1), *(user + 2), *(user + 3));
          }
        }
#line 376
        return;
      }
    } else {
      {
#line 363
      log_printf((char *)"SCAN -> Invalid IPv4 address \'%s\'!", *(user + 3));
      }
#line 364
      return;
    }
  }
  {
#line 382
  snprintf((char */* __restrict  */)(mask), (size_t )513, (char const   */* __restrict  */)"%s!%s@%s",
           *(user + 0), *(user + 1), *(user + 2));
#line 383
  snprintf((char */* __restrict  */)(ipmask), (size_t )513, (char const   */* __restrict  */)"%s!%s@%s",
           *(user + 0), *(user + 1), *(user + 3));
#line 386
  tmp___2 = scan_checkexempt(mask, ipmask);
  }
#line 386
  if (tmp___2) {
#line 388
    if (OPT_DEBUG) {
      {
#line 389
      log_printf((char *)"SCAN -> %s is exempt from scanning", mask);
      }
    }
#line 390
    return;
  }
  {
#line 394
  ss = scan_create(user, msg___0);
#line 397
  (ss->remote)->data = (void *)ss;
  }
#line 400
  if ((OpmItem->blacklists)->elements > 0) {
    {
#line 401
    dnsbl_add(ss);
    }
  }
#line 404
  p = SCANNERS->head;
  {
#line 404
  while (1) {
    while_continue: /* CIL Label */ ;
#line 404
    if (! ((unsigned long )p != (unsigned long )((void *)0))) {
#line 404
      goto while_break;
    }
#line 406
    scs = (struct scanner_struct *)p->data;
#line 407
    p2 = (scs->masks)->head;
    {
#line 407
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 407
      if (! ((unsigned long )p2 != (unsigned long )((void *)0))) {
#line 407
        goto while_break___0;
      }
      {
#line 409
      scsmask = (char *)p2->data;
#line 410
      tmp___5 = match((char const   *)scsmask, (char const   *)(mask));
      }
#line 410
      if (tmp___5) {
#line 412
        if (OPT_DEBUG) {
          {
#line 414
          log_printf((char *)"SCAN -> Passing %s to scanner [%s]", mask, scs->name);
          }
        }
        {
#line 418
        ret = opm_scan(scs->scanner, ss->remote);
        }
#line 418
        if (ret != 1) {
          {
#line 422
          if (ret == 8) {
#line 422
            goto case_8;
          }
#line 425
          if (ret == 7) {
#line 425
            goto case_7;
          }
#line 430
          goto switch_default;
          case_8: /* CIL Label */ 
#line 423
          goto __Cont;
#line 424
          goto switch_break;
          case_7: /* CIL Label */ 
#line 426
          if (ss->manual_target) {
#line 426
            tmp___3 = (char const   *)(ss->manual_target)->name;
          } else {
#line 426
            tmp___3 = "(unknown)";
          }
          {
#line 426
          log_printf((char *)"OPM -> Bad address %s [%s].", tmp___3, ss->ip);
          }
#line 429
          goto switch_break;
          switch_default: /* CIL Label */ 
#line 431
          if (ss->manual_target) {
#line 431
            tmp___4 = (char const   *)(ss->manual_target)->name;
          } else {
#line 431
            tmp___4 = "(unknown)";
          }
          {
#line 431
          log_printf((char *)"OPM -> Unknown error %s [%s].", tmp___4, ss->ip);
          }
#line 434
          goto switch_break;
          switch_break: /* CIL Label */ ;
          }
        } else {
#line 438
          ss->scans = (unsigned short )((int )ss->scans + 1);
        }
#line 440
        goto while_break___0;
      }
      __Cont: /* CIL Label */ 
#line 407
      p2 = p2->next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 404
    p = p->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 446
  if ((int )ss->scans == 0) {
    {
#line 447
    scan_free(ss);
    }
  }
#line 448
  return;
}
}
#line 470 "/home/june/collector/temp/bopm-3.1.3/src/scan.c"
struct scan_struct *scan_create(char **user , char *msg___0 ) 
{ 
  struct scan_struct *ss ;
  void *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;

  {
  {
#line 474
  tmp___0 = MyMalloc(sizeof(*ss));
#line 474
  ss = (struct scan_struct *)tmp___0;
#line 476
  tmp___1 = DupString((char const   *)*(user + 0));
#line 476
  ss->irc_nick = tmp___1;
#line 477
  tmp___2 = DupString((char const   *)*(user + 1));
#line 477
  ss->irc_username = tmp___2;
#line 478
  tmp___3 = DupString((char const   *)*(user + 2));
#line 478
  ss->irc_hostname = tmp___3;
#line 479
  tmp___4 = DupString((char const   *)*(user + 3));
#line 479
  ss->ip = tmp___4;
#line 480
  tmp___5 = DupString((char const   *)msg___0);
#line 480
  ss->proof = tmp___5;
#line 482
  ss->remote = opm_remote_create((char const   *)ss->ip);
#line 483
  ss->scans = (unsigned short)0;
#line 484
  ss->positive = (unsigned short)0;
#line 486
  ss->manual_target = (struct ChannelConf *)((void *)0);
  }
#line 488
  if (! ss->remote) {
    {
#line 488
    __assert_fail("ss->remote", "/home/june/collector/temp/bopm-3.1.3/src/scan.c",
                  488U, "scan_create");
    }
  }
#line 489
  return (ss);
}
}
#line 507 "/home/june/collector/temp/bopm-3.1.3/src/scan.c"
void scan_free(struct scan_struct *ss ) 
{ 


  {
#line 509
  if ((unsigned long )ss == (unsigned long )((void *)0)) {
#line 510
    return;
  }
  {
#line 512
  _MyFree((void **)(& ss->irc_nick));
#line 513
  _MyFree((void **)(& ss->irc_username));
#line 514
  _MyFree((void **)(& ss->irc_hostname));
#line 515
  _MyFree((void **)(& ss->ip));
#line 516
  _MyFree((void **)(& ss->proof));
#line 518
  opm_remote_free(ss->remote);
#line 519
  _MyFree((void **)(& ss));
  }
#line 520
  return;
}
}
#line 531 "/home/june/collector/temp/bopm-3.1.3/src/scan.c"
void scan_checkfinished(struct scan_struct *ss ) 
{ 


  {
#line 533
  if ((int )ss->scans <= 0) {
#line 536
    if ((unsigned long )ss->manual_target != (unsigned long )((void *)0)) {
      {
#line 538
      irc_send((char *)"PRIVMSG %s :CHECK -> All tests on %s completed.", (ss->manual_target)->name,
               ss->ip);
      }
    } else {
#line 543
      if (OPT_DEBUG) {
        {
#line 546
        log_printf((char *)"SCAN -> All tests on %s!%s@%s complete.", ss->irc_nick,
                   ss->irc_username, ss->irc_hostname);
        }
      }
#line 551
      if (! ss->positive) {
        {
#line 552
        scan_negative(ss);
        }
      }
    }
    {
#line 555
    scan_free(ss);
    }
  }
#line 557
  return;
}
}
#line 575 "/home/june/collector/temp/bopm-3.1.3/src/scan.c"
void scan_positive(struct scan_struct *ss , char *kline , char *type ) 
{ 
  node_t *node ;
  OPM_T *scanner ;

  {
#line 581
  if (ss->positive) {
#line 582
    return;
  }
  {
#line 585
  scan_irckline(ss, kline, type);
#line 589
  node = SCANNERS->head;
  }
  {
#line 589
  while (1) {
    while_continue: /* CIL Label */ ;
#line 589
    if (! ((unsigned long )node != (unsigned long )((void *)0))) {
#line 589
      goto while_break;
    }
    {
#line 591
    scanner = ((struct scanner_struct *)node->data)->scanner;
#line 592
    opm_end(scanner, ss->remote);
#line 589
    node = node->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 596
  ss->positive = (unsigned short)1;
#line 597
  return;
}
}
#line 613 "/home/june/collector/temp/bopm-3.1.3/src/scan.c"
void scan_open_proxy(OPM_T *scanner , OPM_REMOTE_T *remote , int notused , void *data ) 
{ 
  struct scan_struct *ss ;
  struct scanner_struct *scs ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;

  {
  {
#line 623
  scan_log(remote);
#line 625
  scs = (struct scanner_struct *)data;
#line 626
  ss = (struct scan_struct *)remote->data;
  }
#line 628
  if ((unsigned long )ss->manual_target == (unsigned long )((void *)0)) {
    {
#line 631
    tmp___0 = scan_gettype((int )remote->protocol);
#line 631
    scan_positive(ss, IRCItem->kline, tmp___0);
#line 634
    dnsbl_report(ss);
#line 636
    tmp___1 = scan_gettype((int )remote->protocol);
#line 636
    irc_send_channels((char *)"OPEN PROXY -> %s!%s@%s %s:%d (%s) [%s]", ss->irc_nick,
                      ss->irc_username, ss->irc_hostname, remote->ip, (int )remote->port,
                      tmp___1, scs->name);
#line 640
    tmp___2 = scan_gettype((int )remote->protocol);
#line 640
    log_printf((char *)"SCAN -> OPEN PROXY %s!%s@%s %s:%d (%s) [%s]", ss->irc_nick,
               ss->irc_username, ss->irc_hostname, remote->ip, (int )remote->port,
               tmp___2, scs->name);
    }
  } else {
    {
#line 646
    tmp___3 = scan_gettype((int )remote->protocol);
#line 646
    irc_send((char *)"PRIVMSG %s :CHECK -> OPEN PROXY %s:%d (%s) [%s]", (ss->manual_target)->name,
             remote->ip, (int )remote->port, tmp___3, scs->name);
#line 650
    tmp___4 = scan_gettype((int )remote->protocol);
#line 650
    log_printf((char *)"SCAN -> OPEN PROXY %s:%d (%s) [%s]", remote->ip, (int )remote->port,
               tmp___4, scs->name);
    }
  }
  {
#line 656
  stats_openproxy((int )remote->protocol);
  }
#line 657
  return;
}
}
#line 674 "/home/june/collector/temp/bopm-3.1.3/src/scan.c"
void scan_negotiation_failed(OPM_T *scanner , OPM_REMOTE_T *remote , int notused ,
                             void *data ) 
{ 
  struct scan_struct *ss ;
  struct scanner_struct *scs ;
  char *tmp___0 ;

  {
  {
#line 684
  scan_log(remote);
#line 686
  scs = (struct scanner_struct *)data;
#line 687
  ss = (struct scan_struct *)remote->data;
  }
#line 689
  if (OPT_DEBUG) {
    {
#line 691
    tmp___0 = scan_gettype((int )remote->protocol);
#line 691
    log_printf((char *)"SCAN -> Negotiation failed %s:%d (%s) [%s] (%d bytes read)",
               remote->ip, (int )remote->port, tmp___0, scs->name, (int )remote->bytes_read);
    }
  }
#line 704
  return;
}
}
#line 720 "/home/june/collector/temp/bopm-3.1.3/src/scan.c"
static void scan_timeout(OPM_T *scanner , OPM_REMOTE_T *remote , int notused , void *data ) 
{ 
  struct scan_struct *ss ;
  struct scanner_struct *scs ;
  char *tmp___0 ;

  {
  {
#line 730
  scan_log(remote);
#line 732
  scs = (struct scanner_struct *)data;
#line 733
  ss = (struct scan_struct *)remote->data;
  }
#line 735
  if (OPT_DEBUG) {
    {
#line 737
    tmp___0 = scan_gettype((int )remote->protocol);
#line 737
    log_printf((char *)"SCAN -> Negotiation timed out %s:%d (%s) [%s] (%d bytes read)",
               remote->ip, (int )remote->port, tmp___0, scs->name, (int )remote->bytes_read);
    }
  }
#line 751
  return;
}
}
#line 768 "/home/june/collector/temp/bopm-3.1.3/src/scan.c"
static void scan_end(OPM_T *scanner , OPM_REMOTE_T *remote , int notused , void *data ) 
{ 
  struct scan_struct *ss ;
  struct scanner_struct *scs ;

  {
#line 777
  scs = (struct scanner_struct *)data;
#line 778
  ss = (struct scan_struct *)remote->data;
#line 780
  if (OPT_DEBUG) {
    {
#line 781
    log_printf((char *)"SCAN -> Scan %s [%s] completed", remote->ip, scs->name);
    }
  }
  {
#line 783
  ss->scans = (unsigned short )((int )ss->scans - 1);
#line 784
  scan_checkfinished(ss);
  }
#line 785
  return;
}
}
#line 804 "/home/june/collector/temp/bopm-3.1.3/src/scan.c"
static void scan_handle_error(OPM_T *scanner , OPM_REMOTE_T *remote , int err , void *data ) 
{ 
  struct scan_struct *ss ;
  struct scanner_struct *scs ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;

  {
#line 813
  scs = (struct scanner_struct *)data;
#line 814
  ss = (struct scan_struct *)remote->data;
  {
#line 818
  if (err == 5) {
#line 818
    goto case_5;
  }
#line 834
  if (err == 9) {
#line 834
    goto case_9;
  }
#line 838
  if (err == 10) {
#line 838
    goto case_10;
  }
#line 851
  goto switch_default;
  case_5: /* CIL Label */ 
#line 819
  if (OPT_DEBUG >= 2U) {
    {
#line 821
    tmp___0 = scan_gettype((int )remote->protocol);
#line 821
    log_printf((char *)"SCAN -> Max read on %s:%d (%s) [%s] (%d bytes read)", remote->ip,
               (int )remote->port, tmp___0, scs->name, (int )remote->bytes_read);
    }
  }
#line 826
  if ((unsigned long )ss->manual_target != (unsigned long )((void *)0)) {
    {
#line 828
    tmp___1 = scan_gettype((int )remote->protocol);
#line 828
    irc_send((char *)"PRIVMSG %s :CHECK -> Negotiation failed %s:%d (%s) [%s] (%d bytes read)",
             (ss->manual_target)->name, remote->ip, (int )remote->port, tmp___1, scs->name,
             (int )remote->bytes_read);
    }
  }
#line 833
  goto switch_break;
  case_9: /* CIL Label */ 
  {
#line 835
  tmp___2 = scan_gettype((int )remote->protocol);
#line 835
  log_printf((char *)"SCAN -> Bind error on %s:%d (%s) [%s]", remote->ip, (int )remote->port,
             tmp___2, scs->name);
  }
#line 837
  goto switch_break;
  case_10: /* CIL Label */ 
  {
#line 839
  tmp___3 = scan_gettype((int )remote->protocol);
#line 839
  log_printf((char *)"SCAN -> File descriptor allocation error %s:%d (%s) [%s]", remote->ip,
             (int )remote->port, tmp___3, scs->name);
  }
#line 843
  if ((unsigned long )ss->manual_target != (unsigned long )((void *)0)) {
    {
#line 845
    tmp___4 = scan_gettype((int )remote->protocol);
#line 845
    irc_send((char *)"PRIVMSG %s :CHECK -> Scan failed %s:%d (%s) [%s] (file descriptor allocation error)",
             (ss->manual_target)->name, remote->ip, (int )remote->port, tmp___4, scs->name);
    }
  }
#line 850
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 852
  if (OPT_DEBUG) {
    {
#line 854
    tmp___5 = scan_gettype((int )remote->protocol);
#line 854
    log_printf((char *)"SCAN -> Unknown error %s:%d (%s) [%s]", remote->ip, (int )remote->port,
               tmp___5, scs->name);
    }
  }
#line 857
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 859
  return;
}
}
#line 875 "/home/june/collector/temp/bopm-3.1.3/src/scan.c"
static void scan_negative(struct scan_struct *ss ) 
{ 


  {
#line 878
  if (OptionsItem->negcache > 0) {
#line 880
    if (OPT_DEBUG >= 2U) {
      {
#line 881
      log_printf((char *)"SCAN -> Adding %s to negative cache", ss->ip);
      }
    }
    {
#line 882
    negcache_insert((char const   *)ss->ip);
    }
  }
#line 884
  return;
}
}
#line 902 "/home/june/collector/temp/bopm-3.1.3/src/scan.c"
static void scan_irckline(struct scan_struct *ss , char *format , char *type ) 
{ 
  char message[513] ;
  unsigned short pos ;
  unsigned short len ;
  unsigned short size ;
  unsigned int i ;
  struct kline_format_assoc table[5] ;
  unsigned short tmp___0 ;
  size_t tmp___1 ;
  unsigned short tmp___2 ;

  {
#line 907
  pos = (unsigned short)0;
#line 908
  len = (unsigned short)0;
#line 909
  size = (unsigned short)0;
#line 913
  table[0].key = (char )'i';
#line 913
  table[0].data = (void *)0;
#line 913
  table[0].type = 1;
#line 913
  table[1].key = (char )'h';
#line 913
  table[1].data = (void *)0;
#line 913
  table[1].type = 1;
#line 913
  table[2].key = (char )'u';
#line 913
  table[2].data = (void *)0;
#line 913
  table[2].type = 1;
#line 913
  table[3].key = (char )'n';
#line 913
  table[3].data = (void *)0;
#line 913
  table[3].type = 1;
#line 913
  table[4].key = (char )'t';
#line 913
  table[4].data = (void *)0;
#line 913
  table[4].type = 1;
#line 922
  table[0].data = (void *)ss->ip;
#line 923
  table[1].data = (void *)ss->irc_hostname;
#line 924
  table[2].data = (void *)ss->irc_username;
#line 925
  table[3].data = (void *)ss->irc_nick;
#line 926
  table[4].data = (void *)type;
  {
#line 932
  while (1) {
    while_continue: /* CIL Label */ ;
#line 932
    if ((int )*(format + pos) != 0) {
#line 932
      if (! ((int )len < 511)) {
#line 932
        goto while_break;
      }
    } else {
#line 932
      goto while_break;
    }
    {
#line 937
    if ((int )*(format + pos) == 37) {
#line 937
      goto case_37;
    }
#line 979
    goto switch_default___0;
    case_37: /* CIL Label */ 
#line 939
    if ((int )*(format + ((int )pos + 1)) == 0) {
#line 940
      goto while_continue;
    }
#line 943
    if ((int )*(format + ((int )pos + 1)) == 37) {
#line 945
      tmp___0 = len;
#line 945
      len = (unsigned short )((int )len + 1);
#line 945
      message[tmp___0] = (char )'%';
#line 946
      pos = (unsigned short )((int )pos + 1);
#line 947
      goto switch_break;
    }
#line 951
    i = 0U;
    {
#line 951
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 951
      if (! ((unsigned long )i < sizeof(table) / sizeof(struct kline_format_assoc ))) {
#line 951
        goto while_break___0;
      }
#line 953
      if ((int )table[i].key == (int )*(format + ((int )pos + 1))) {
        {
#line 957
        if (table[i].type == 1) {
#line 957
          goto case_1;
        }
#line 970
        goto switch_default;
        case_1: /* CIL Label */ 
        {
#line 959
        tmp___1 = strlen((char const   *)((char *)table[i].data));
#line 959
        size = (unsigned short )tmp___1;
        }
#line 962
        if ((int )size + (int )len > 512) {
#line 963
          goto switch_break___0;
        } else {
          {
#line 966
          strcat((char */* __restrict  */)(message), (char const   */* __restrict  */)((char *)table[i].data));
#line 967
          len = (unsigned short )((int )len + (int )size);
          }
        }
        switch_default: /* CIL Label */ 
#line 971
        goto switch_break___0;
        switch_break___0: /* CIL Label */ ;
        }
      }
#line 951
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 976
    pos = (unsigned short )((int )pos + 1);
#line 977
    goto switch_break;
    switch_default___0: /* CIL Label */ 
#line 980
    tmp___2 = len;
#line 980
    len = (unsigned short )((int )len + 1);
#line 980
    message[tmp___2] = *(format + pos);
#line 981
    message[len] = (char )'\000';
#line 982
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 985
    pos = (unsigned short )((int )pos + 1);
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 987
  irc_send((char *)"%s", message);
  }
#line 988
  return;
}
}
#line 996 "/home/june/collector/temp/bopm-3.1.3/src/scan.c"
void scan_manual(char *param , struct ChannelConf *target ) 
{ 
  struct in_addr *addr___0 ;
  struct scan_struct *ss ;
  struct scanner_struct *scs ;
  char *ip ;
  char *scannername ;
  node_t *p ;
  int ret ;
  void *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;

  {
#line 1009
  if ((unsigned long )param == (unsigned long )((void *)0)) {
    {
#line 1011
    irc_send((char *)"PRIVMSG %s :OPM -> Invalid parameters.", target->name);
    }
#line 1012
    return;
  }
  {
#line 1017
  ip = param;
#line 1019
  scannername = strchr((char const   *)param, ' ');
  }
#line 1019
  if ((unsigned long )scannername != (unsigned long )((void *)0)) {
#line 1021
    *scannername = (char )'\000';
#line 1022
    scannername ++;
  }
  {
#line 1025
  tmp___0 = MyMalloc(sizeof(*ss));
#line 1025
  ss = (struct scan_struct *)tmp___0;
#line 1028
  addr___0 = firedns_resolveip4((char const   */* const  */)ip);
  }
#line 1028
  if (! addr___0) {
    {
#line 1030
    tmp___1 = firedns_strerror(fdns_errno);
#line 1030
    irc_send((char *)"PRIVMSG %s :CHECK -> Error resolving host \'%s\': %s", target->name,
             ip, tmp___1);
    }
#line 1032
    return;
  }
  {
#line 1036
  ip = inet_ntoa(*addr___0);
#line 1039
  ss->irc_nick = (char *)((void *)0);
#line 1040
  ss->irc_username = (char *)((void *)0);
#line 1041
  ss->irc_hostname = (char *)((void *)0);
#line 1042
  ss->proof = (char *)((void *)0);
#line 1044
  ss->ip = DupString((char const   *)ip);
#line 1046
  ss->remote = opm_remote_create((char const   *)ss->ip);
#line 1047
  (ss->remote)->data = (void *)ss;
#line 1048
  ss->scans = (unsigned short)0;
#line 1049
  ss->positive = (unsigned short)0;
#line 1051
  ss->manual_target = target;
  }
#line 1053
  if (! ss->remote) {
    {
#line 1053
    __assert_fail("ss->remote", "/home/june/collector/temp/bopm-3.1.3/src/scan.c",
                  1053U, "scan_manual");
    }
  }
#line 1055
  if ((unsigned long )scannername != (unsigned long )((void *)0)) {
    {
#line 1057
    irc_send((char *)"PRIVMSG %s :CHECK -> Checking \'%s\' for open proxies [%s]",
             target->name, ip, scannername);
    }
  } else {
    {
#line 1062
    irc_send((char *)"PRIVMSG %s :CHECK -> Checking \'%s\' for open proxies on all scanners",
             target->name, ip);
    }
  }
#line 1066
  if ((OpmItem->blacklists)->elements > 0) {
    {
#line 1067
    dnsbl_add(ss);
    }
  }
#line 1070
  p = SCANNERS->head;
  {
#line 1070
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1070
    if (! ((unsigned long )p != (unsigned long )((void *)0))) {
#line 1070
      goto while_break;
    }
#line 1072
    scs = (struct scanner_struct *)p->data;
#line 1076
    if ((unsigned long )scannername != (unsigned long )((void *)0)) {
      {
#line 1077
      tmp___2 = strcasecmp((char const   *)scannername, (char const   *)scs->name);
      }
#line 1077
      if (tmp___2) {
#line 1078
        goto __Cont;
      }
    }
#line 1080
    if (OPT_DEBUG) {
      {
#line 1082
      log_printf((char *)"SCAN -> Passing %s to scanner [%s] (MANUAL SCAN)", ip, scs->name);
      }
    }
    {
#line 1086
    ret = opm_scan(scs->scanner, ss->remote);
    }
#line 1086
    if (ret != 1) {
      {
#line 1090
      if (ret == 8) {
#line 1090
        goto case_8;
      }
#line 1092
      if (ret == 7) {
#line 1092
        goto case_7;
      }
#line 1096
      goto switch_default;
      case_8: /* CIL Label */ 
#line 1091
      goto switch_break;
      case_7: /* CIL Label */ 
      {
#line 1093
      irc_send((char *)"PRIVMSG %s :OPM -> Bad address %s [%s]", (ss->manual_target)->name,
               ss->ip, scs->name);
      }
#line 1095
      goto switch_break;
      switch_default: /* CIL Label */ 
      {
#line 1097
      irc_send((char *)"PRIVMSG %s :OPM -> Unknown error %s [%s]", (ss->manual_target)->name,
               ss->ip, scs->name);
      }
#line 1099
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    } else {
#line 1103
      ss->scans = (unsigned short )((int )ss->scans + 1);
    }
    __Cont: /* CIL Label */ 
#line 1070
    p = p->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 1108
  if ((int )ss->scans == 0) {
#line 1110
    if ((unsigned long )scannername != (unsigned long )((void *)0)) {
      {
#line 1112
      irc_send((char *)"PRIVMSG %s :CHECK -> No such scanner \'%s\', or \'%s\' has 0 protocols.",
               (ss->manual_target)->name, scannername, scannername);
      }
    }
    {
#line 1117
    irc_send((char *)"PRIVMSG %s :CHECK -> No scans active on \'%s\', aborting scan.",
             (ss->manual_target)->name, ss->ip);
#line 1119
    scan_free(ss);
    }
  }
#line 1121
  return;
}
}
#line 1137 "/home/june/collector/temp/bopm-3.1.3/src/scan.c"
int scan_checkexempt(char *mask___0 , char *ipmask___0 ) 
{ 
  node_t *node ;
  char *exempt_mask ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 1142
  node = (ExemptItem->masks)->head;
  {
#line 1142
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1142
    if (! ((unsigned long )node != (unsigned long )((void *)0))) {
#line 1142
      goto while_break;
    }
    {
#line 1144
    exempt_mask = (char *)node->data;
#line 1145
    tmp___0 = match((char const   *)exempt_mask, (char const   *)mask___0);
    }
#line 1145
    if (tmp___0) {
#line 1146
      return (1);
    } else {
      {
#line 1145
      tmp___1 = match((char const   *)exempt_mask, (char const   *)ipmask___0);
      }
#line 1145
      if (tmp___1) {
#line 1146
        return (1);
      }
    }
#line 1142
    node = node->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 1149
  return (0);
}
}
#line 1162 "/home/june/collector/temp/bopm-3.1.3/src/scan.c"
static void scan_log(OPM_REMOTE_T *remote ) 
{ 
  char buf_present[25] ;
  time_t present ;
  struct tm *tm_present ;
  struct scan_struct *ss ;
  char *tmp___0 ;

  {
#line 1167
  ss = (struct scan_struct *)remote->data;
#line 1169
  if (OptionsItem->scanlog) {
#line 1169
    if (! scanlogfile) {
#line 1170
      return;
    }
  } else {
#line 1170
    return;
  }
  {
#line 1172
  time(& present);
#line 1173
  tm_present = gmtime((time_t const   *)(& present));
#line 1174
  strftime((char */* __restrict  */)(buf_present), sizeof(buf_present), (char const   */* __restrict  */)"%b %d %H:%M:%S %Y",
           (struct tm  const  */* __restrict  */)tm_present);
#line 1176
  tmp___0 = scan_gettype((int )remote->protocol);
#line 1176
  fprintf((FILE */* __restrict  */)scanlogfile, (char const   */* __restrict  */)"[%s] %s:%d (%s) \"%s\"\n",
          buf_present, remote->ip, (int )remote->port, tmp___0, ss->proof);
#line 1178
  fflush(scanlogfile);
  }
#line 1179
  return;
}
}
#line 312 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) __mode_t ( __attribute__((__leaf__)) umask)(__mode_t __mask ) ;
#line 102 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) __sighandler_t ( __attribute__((__leaf__)) signal)(int __sig ,
                                                                                        void (*__handler)(int  ) ) ;
#line 259
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sigaction)(int __sig ,
                                                                                struct sigaction  const  * __restrict  __act ,
                                                                                struct sigaction * __restrict  __oact ) ;
#line 432 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) unsigned int ( __attribute__((__leaf__)) alarm)(unsigned int __seconds ) ;
#line 551
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) execve)(char const   *__path ,
                                                                                               char * const  *__argv ,
                                                                                               char * const  *__envp ) ;
#line 603
extern  __attribute__((__noreturn__)) void _exit(int __status ) ;
#line 628
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) getpid)(void) ;
#line 646
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setpgid)(__pid_t __pid ,
                                                                              __pid_t __pgid ) ;
#line 756
extern  __attribute__((__nothrow__)) __pid_t fork(void) ;
#line 57 "/usr/include/getopt.h"
extern char *optarg ;
#line 150
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getopt)(int ___argc ,
                                                                             char * const  *___argv ,
                                                                             char const   *__shortopts ) ;
#line 43 "/home/june/collector/temp/bopm-3.1.3/src/opercmd.h"
void command_timer(void) ;
#line 60 "/home/june/collector/temp/bopm-3.1.3/src/main.c"
static void do_signal(int signum ) ;
#line 62 "/home/june/collector/temp/bopm-3.1.3/src/main.c"
int RESTART  =    0;
#line 63 "/home/june/collector/temp/bopm-3.1.3/src/main.c"
int ALARMED  =    0;
#line 64 "/home/june/collector/temp/bopm-3.1.3/src/main.c"
int REOPEN  =    0;
#line 65 "/home/june/collector/temp/bopm-3.1.3/src/main.c"
unsigned int OPT_DEBUG  =    0U;
#line 67 "/home/june/collector/temp/bopm-3.1.3/src/main.c"
char *CONFNAME  =    (char *)"bopm";
#line 68 "/home/june/collector/temp/bopm-3.1.3/src/main.c"
char *CONFDIR  =    (char *)"/home/june/bopm/etc";
#line 69 "/home/june/collector/temp/bopm-3.1.3/src/main.c"
char *LOGDIR  =    (char *)"/home/june/bopm/var";
#line 70 "/home/june/collector/temp/bopm-3.1.3/src/main.c"
char *CONFFILE  ;
#line 70 "/home/june/collector/temp/bopm-3.1.3/src/main.c"
char *LOGFILE  ;
#line 72 "/home/june/collector/temp/bopm-3.1.3/src/main.c"
struct sigaction ALARMACTION  ;
#line 73 "/home/june/collector/temp/bopm-3.1.3/src/main.c"
struct sigaction INTACTION  ;
#line 74 "/home/june/collector/temp/bopm-3.1.3/src/main.c"
struct sigaction USR1ACTION  ;
#line 274 "/home/june/collector/temp/bopm-3.1.3/src/main.c"
static void do_signal(int signum ) 
{ 


  {
  {
#line 278
  if (signum == 14) {
#line 278
    goto case_14;
  }
#line 282
  if (signum == 2) {
#line 282
    goto case_2;
  }
#line 286
  if (signum == 10) {
#line 286
    goto case_10;
  }
#line 276
  goto switch_break;
  case_14: /* CIL Label */ 
  {
#line 279
  ALARMED = 1;
#line 280
  alarm(1U);
  }
#line 281
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 283
  log_printf((char *)"MAIN -> Caught SIGINT, bye!");
#line 284
  exit(0);
  }
#line 285
  goto switch_break;
  case_10: /* CIL Label */ 
#line 287
  REOPEN = 1;
#line 288
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 290
  return;
}
}
#line 293 "/home/june/collector/temp/bopm-3.1.3/src/main.c"
void main_restart(void) 
{ 


  {
#line 295
  RESTART = 1;
#line 296
  return;
}
}
#line 42 "/home/june/collector/temp/bopm-3.1.3/src/malloc.c"
void *MyMalloc(size_t bytes ) 
{ 
  void *ret ;
  void *tmp___0 ;

  {
  {
#line 44
  tmp___0 = calloc((size_t )1, bytes);
#line 44
  ret = tmp___0;
  }
#line 45
  if (! ret) {
    {
#line 45
    __assert_fail("ret", "/home/june/collector/temp/bopm-3.1.3/src/malloc.c", 45U,
                  "MyMalloc");
    }
  }
#line 47
  return (ret);
}
}
#line 63 "/home/june/collector/temp/bopm-3.1.3/src/malloc.c"
void _MyFree(void **var ) 
{ 


  {
#line 65
  if (! ((unsigned long )var != (unsigned long )((void *)0))) {
    {
#line 65
    __assert_fail("var != ((void *)0)", "/home/june/collector/temp/bopm-3.1.3/src/malloc.c",
                  65U, "_MyFree");
    }
  }
#line 67
  if ((unsigned long )*var != (unsigned long )((void *)0)) {
    {
#line 68
    free(*var);
    }
  }
#line 69
  *var = (void *)0;
#line 70
  return;
}
}
#line 73 "/home/june/collector/temp/bopm-3.1.3/src/malloc.c"
char *DupString(char const   *y ) 
{ 
  char *x ;
  size_t tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 77
  tmp___0 = strlen(y);
#line 77
  tmp___1 = malloc(tmp___0 + 1UL);
#line 77
  x = (char *)tmp___1;
  }
#line 78
  if (! x) {
    {
#line 78
    __assert_fail("x", "/home/june/collector/temp/bopm-3.1.3/src/malloc.c", 78U, "DupString");
    }
  }
  {
#line 79
  strcpy((char */* __restrict  */)x, (char const   */* __restrict  */)y);
  }
#line 81
  return (x);
}
}
#line 48 "/home/june/collector/temp/bopm-3.1.3/src/opercmd.c"
list_t *COMMANDS  =    (list_t *)((void *)0);
#line 51
static struct Command *command_create(unsigned short type , char *param , char *irc_nick ,
                                      struct ChannelConf *target ) ;
#line 52
static void command_free(struct Command *command ) ;
#line 54
static void cmd_check(char *param , char *source , struct ChannelConf *target ) ;
#line 55
static void cmd_stat(char *param , char *source , struct ChannelConf *target ) ;
#line 56
static void cmd_fdstat(char *param , char *source , struct ChannelConf *target ) ;
#line 61 "/home/june/collector/temp/bopm-3.1.3/src/opercmd.c"
static struct OperCommandHash COMMAND_TABLE___0[6]  = {      {(char *)"CHECK", & cmd_check}, 
        {(char *)"SCAN", & cmd_check}, 
        {(char *)"STAT", & cmd_stat}, 
        {(char *)"STATS", & cmd_stat}, 
        {(char *)"STATUS", & cmd_stat}, 
        {(char *)"FDSTAT", & cmd_fdstat}};
#line 83 "/home/june/collector/temp/bopm-3.1.3/src/opercmd.c"
void command_init(void) 
{ 


  {
#line 85
  if ((unsigned long )COMMANDS == (unsigned long )((void *)0)) {
    {
#line 86
    COMMANDS = list_create();
    }
  }
#line 87
  return;
}
}
#line 105 "/home/june/collector/temp/bopm-3.1.3/src/opercmd.c"
static unsigned short interval  ;
#line 102 "/home/june/collector/temp/bopm-3.1.3/src/opercmd.c"
void command_timer(void) 
{ 
  node_t *node ;
  node_t *next ;
  struct Command *cs ;
  time_t present ;
  unsigned short tmp___0 ;

  {
#line 112
  tmp___0 = interval;
#line 112
  interval = (unsigned short )((int )interval + 1);
#line 112
  if ((int )tmp___0 < 10) {
#line 113
    return;
  } else {
#line 115
    interval = (unsigned short)0;
  }
  {
#line 117
  time(& present);
#line 119
  node = COMMANDS->head;
  }
#line 119
  if (node) {
#line 119
    next = node->next;
  } else {
#line 119
    next = (node_t *)((void *)0);
  }
  {
#line 119
  while (1) {
    while_continue: /* CIL Label */ ;
#line 119
    if (! ((unsigned long )node != (unsigned long )((void *)0))) {
#line 119
      goto while_break;
    }
#line 121
    cs = (struct Command *)node->data;
#line 122
    if (present - cs->added > 180L) {
      {
#line 124
      command_free(cs);
#line 125
      list_remove(COMMANDS, node);
#line 126
      node_free(node);
      }
    } else {
#line 129
      return;
    }
#line 119
    node = next;
#line 119
    if (node) {
#line 119
      next = node->next;
    } else {
#line 119
      next = (node_t *)((void *)0);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 131
  return;
}
}
#line 149 "/home/june/collector/temp/bopm-3.1.3/src/opercmd.c"
void command_parse(char *command , char *msg___0 , struct ChannelConf *target , struct UserInfo *source_p ) 
{ 
  unsigned int i ;
  char *param ;
  struct Command *cs ;
  node_t *node ;
  char *tmp___0 ;
  int tmp___1 ;

  {
#line 160
  if (OPT_DEBUG) {
    {
#line 162
    log_printf((char *)"COMMAND -> Parsing command (%s) from %s [%s]", command, source_p->irc_nick,
               target->name);
    }
  }
#line 167
  if (COMMANDS->elements >= 64) {
#line 168
    return;
  }
  {
#line 178
  command = strchr((char const   *)command, ' ');
  }
#line 183
  if ((unsigned long )command == (unsigned long )((void *)0)) {
#line 185
    return;
  } else {
#line 183
    tmp___0 = command;
#line 183
    command ++;
#line 183
    if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
#line 185
      return;
    }
  }
  {
#line 189
  param = strchr((char const   *)command, ' ');
  }
#line 191
  if ((unsigned long )param != (unsigned long )((void *)0)) {
#line 193
    *param = (char )'\000';
#line 194
    param ++;
  } else {
#line 197
    param = (char *)"";
  }
  {
#line 199
  log_printf((char *)"COMMAND -> parsed [%s] [%s]", command, param);
#line 202
  i = 0U;
  }
  {
#line 202
  while (1) {
    while_continue: /* CIL Label */ ;
#line 202
    if (! ((unsigned long )i < sizeof(COMMAND_TABLE___0) / sizeof(struct OperCommandHash ))) {
#line 202
      goto while_break;
    }
    {
#line 204
    tmp___1 = strcasecmp((char const   *)command, (char const   *)COMMAND_TABLE___0[i].command);
    }
#line 204
    if (tmp___1 == 0) {
      {
#line 207
      cs = command_create((unsigned short )i, param, source_p->irc_nick, target);
#line 208
      node = node_create((void *)cs);
#line 209
      list_add(COMMANDS, node);
      }
    }
#line 202
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 213
  irc_send((char *)"USERHOST %s", source_p->irc_nick);
  }
#line 214
  return;
}
}
#line 233 "/home/june/collector/temp/bopm-3.1.3/src/opercmd.c"
static struct Command *command_create(unsigned short type , char *param , char *irc_nick ,
                                      struct ChannelConf *target ) 
{ 
  struct Command *ret ;
  void *tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 237
  tmp___0 = MyMalloc(sizeof(*ret));
#line 237
  ret = (struct Command *)tmp___0;
#line 239
  ret->type = type;
  }
#line 241
  if ((unsigned long )param != (unsigned long )((void *)0)) {
    {
#line 242
    ret->param = DupString((char const   *)param);
    }
  } else {
#line 244
    ret->param = (char *)((void *)0);
  }
  {
#line 246
  tmp___1 = DupString((char const   *)irc_nick);
#line 246
  ret->irc_nick = tmp___1;
#line 247
  ret->target = target;
#line 249
  time(& ret->added);
  }
#line 251
  return (ret);
}
}
#line 267 "/home/june/collector/temp/bopm-3.1.3/src/opercmd.c"
static void command_free(struct Command *command ) 
{ 


  {
#line 269
  if ((unsigned long )command->param != (unsigned long )((void *)0)) {
    {
#line 270
    _MyFree((void **)(& command->param));
    }
  }
  {
#line 271
  _MyFree((void **)(& command->irc_nick));
#line 272
  _MyFree((void **)(& command));
  }
#line 273
  return;
}
}
#line 291 "/home/june/collector/temp/bopm-3.1.3/src/opercmd.c"
void command_userhost(char *reply ) 
{ 
  node_t *node ;
  node_t *next ;
  struct Command *cs ;
  char *tmp___0 ;
  int oper ;
  int tmp___1 ;

  {
  {
#line 297
  oper = 0;
#line 299
  tmp___0 = strchr((char const   *)reply, '=');
  }
#line 302
  if (! tmp___0) {
#line 303
    return;
  }
#line 306
  if ((int )*(tmp___0 - 1) == 42) {
#line 307
    oper = 1;
  }
#line 310
  if (oper) {
#line 311
    tmp___0 --;
#line 311
    *tmp___0 = (char )'\000';
  } else {
#line 313
    *tmp___0 = (char )'\000';
  }
#line 316
  node = COMMANDS->head;
#line 316
  if (node) {
#line 316
    next = node->next;
  } else {
#line 316
    next = (node_t *)((void *)0);
  }
  {
#line 316
  while (1) {
    while_continue: /* CIL Label */ ;
#line 316
    if (! ((unsigned long )node != (unsigned long )((void *)0))) {
#line 316
      goto while_break;
    }
    {
#line 318
    cs = (struct Command *)node->data;
#line 320
    tmp___1 = strcmp((char const   *)cs->irc_nick, (char const   *)reply);
    }
#line 320
    if (tmp___1 == 0) {
#line 322
      if (oper) {
        {
#line 323
        (*(COMMAND_TABLE___0[cs->type].handler))(cs->param, cs->irc_nick, cs->target);
        }
      }
      {
#line 326
      command_free(cs);
#line 327
      list_remove(COMMANDS, node);
#line 328
      node_free(node);
      }
    }
#line 316
    node = next;
#line 316
    if (node) {
#line 316
      next = node->next;
    } else {
#line 316
      next = (node_t *)((void *)0);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 331
  return;
}
}
#line 347 "/home/june/collector/temp/bopm-3.1.3/src/opercmd.c"
static void cmd_check(char *param , char *source , struct ChannelConf *target ) 
{ 


  {
  {
#line 351
  scan_manual(param, target);
  }
#line 352
  return;
}
}
#line 366 "/home/june/collector/temp/bopm-3.1.3/src/opercmd.c"
static void cmd_stat(char *param , char *source , struct ChannelConf *target ) 
{ 


  {
  {
#line 371
  stats_output(target->name);
  }
#line 372
  return;
}
}
#line 385 "/home/june/collector/temp/bopm-3.1.3/src/opercmd.c"
static void cmd_fdstat(char *param , char *source , struct ChannelConf *target ) 
{ 


  {
  {
#line 390
  fdstats_output(target->name);
  }
#line 391
  return;
}
}
