/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 11 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/mksignal.c"
struct signaming {
   int signo ;
   char const   *signame ;
   char const   *sigmsg ;
};
#line 133 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 98 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __pid_t pid_t;
#line 60 "/usr/include/x86_64-linux-gnu/sys/wait.h"
union wait;
#line 66 "/usr/include/x86_64-linux-gnu/bits/waitstatus.h"
struct __anonstruct___wait_terminated_44 {
   unsigned int __w_termsig : 7 ;
   unsigned int __w_coredump : 1 ;
   unsigned int __w_retcode : 8 ;
   unsigned int  : 16 ;
};
#line 66 "/usr/include/x86_64-linux-gnu/bits/waitstatus.h"
struct __anonstruct___wait_stopped_45 {
   unsigned int __w_stopval : 8 ;
   unsigned int __w_stopsig : 8 ;
   unsigned int  : 16 ;
};
#line 66 "/usr/include/x86_64-linux-gnu/bits/waitstatus.h"
union wait {
   int w_status ;
   struct __anonstruct___wait_terminated_44 __wait_terminated ;
   struct __anonstruct___wait_stopped_45 __wait_stopped ;
};
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 98 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h"
typedef __gnuc_va_list va_list;
#line 31 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/rc.h"
struct Format;
#line 31 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/rc.h"
typedef struct Format Format;
#line 45
enum bool {
    FALSE = 0,
    TRUE = 1
} ;
#line 45 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/rc.h"
typedef enum bool bool;
#line 57 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/rc.h"
typedef bool (*Conv)(Format * , int  );
#line 127 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/rc.h"
union __anonunion_u_49 {
   int n ;
   void *p ;
};
#line 127 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/rc.h"
struct Format {
   va_list args ;
   long flags ;
   long f1 ;
   long f2 ;
   char *buf ;
   char *bufbegin ;
   char *bufend ;
   int flushed ;
   void (*grow)(Format * , size_t  ) ;
   union __anonunion_u_49 u ;
};
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 135 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __clock_t;
#line 22 "/usr/include/x86_64-linux-gnu/bits/sigset.h"
typedef int __sig_atomic_t;
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigset.h"
struct __anonstruct___sigset_t_2 {
   unsigned long __val[1024UL / (8UL * sizeof(unsigned long ))] ;
};
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigset.h"
typedef struct __anonstruct___sigset_t_2 __sigset_t;
#line 37 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef __sigset_t sigset_t;
#line 40 "/usr/include/signal.h"
typedef __sig_atomic_t sig_atomic_t;
#line 32 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
union sigval {
   int sival_int ;
   void *sival_ptr ;
};
#line 32 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
typedef union sigval sigval_t;
#line 58 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
typedef __clock_t __sigchld_clock_t;
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__kill_16 {
   __pid_t si_pid ;
   __uid_t si_uid ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__timer_17 {
   int si_tid ;
   int si_overrun ;
   sigval_t si_sigval ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__rt_18 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   sigval_t si_sigval ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigchld_19 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   int si_status ;
   __sigchld_clock_t si_utime ;
   __sigchld_clock_t si_stime ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigfault_20 {
   void *si_addr ;
   short si_addr_lsb ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigpoll_21 {
   long si_band ;
   int si_fd ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigsys_22 {
   void *_call_addr ;
   int _syscall ;
   unsigned int _arch ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
union __anonunion__sifields_15 {
   int _pad[128UL / sizeof(int ) - 4UL] ;
   struct __anonstruct__kill_16 _kill ;
   struct __anonstruct__timer_17 _timer ;
   struct __anonstruct__rt_18 _rt ;
   struct __anonstruct__sigchld_19 _sigchld ;
   struct __anonstruct__sigfault_20 _sigfault ;
   struct __anonstruct__sigpoll_21 _sigpoll ;
   struct __anonstruct__sigsys_22 _sigsys ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct_siginfo_t_14 {
   int si_signo ;
   int si_errno ;
   int si_code ;
   union __anonunion__sifields_15 _sifields ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
typedef struct __anonstruct_siginfo_t_14 siginfo_t;
#line 24 "/usr/include/x86_64-linux-gnu/bits/sigaction.h"
union __anonunion___sigaction_handler_34 {
   void (*sa_handler)(int  ) ;
   void (*sa_sigaction)(int  , siginfo_t * , void * ) ;
};
#line 24 "/usr/include/x86_64-linux-gnu/bits/sigaction.h"
struct sigaction {
   union __anonunion___sigaction_handler_34 __sigaction_handler ;
   __sigset_t sa_mask ;
   int sa_flags ;
   void (*sa_restorer)(void) ;
};
#line 18 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/rc.h"
struct Dup;
#line 21
struct Hq;
#line 21 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/rc.h"
typedef struct Hq Hq;
#line 25
struct Node;
#line 25 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/rc.h"
typedef struct Node Node;
#line 26
struct Pipe;
#line 27
struct Redir;
#line 30
struct Word;
#line 34
enum nodetype {
    nAndalso = 0,
    nAssign = 1,
    nBackq = 2,
    nBang = 3,
    nBody = 4,
    nCbody = 5,
    nNowait = 6,
    nBrace = 7,
    nConcat = 8,
    nCount = 9,
    nElse = 10,
    nFlat = 11,
    nDup = 12,
    nEpilog = 13,
    nNewfn = 14,
    nForin = 15,
    nIf = 16,
    nOrelse = 17,
    nPipe = 18,
    nPre = 19,
    nRedir = 20,
    nRmfn = 21,
    nArgs = 22,
    nSubshell = 23,
    nCase = 24,
    nSwitch = 25,
    nMatch = 26,
    nVar = 27,
    nVarsub = 28,
    nWhile = 29,
    nWord = 30,
    nLappend = 31,
    nNmpipe = 32
} ;
#line 34 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/rc.h"
typedef enum nodetype nodetype;
#line 53
enum redirtype {
    rFrom = 0,
    rCreate = 1,
    rAppend = 2,
    rHeredoc = 3,
    rHerestring = 4
} ;
#line 53 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/rc.h"
typedef enum redirtype redirtype;
#line 78 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/rc.h"
union __anonunion_u_48 {
   char *s ;
   int i ;
   Node *p ;
};
#line 78 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/rc.h"
struct Node {
   nodetype type ;
   union __anonunion_u_48 u[4] ;
};
#line 87 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/rc.h"
struct Pipe {
   int left ;
   int right ;
};
#line 91 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/rc.h"
struct Dup {
   redirtype type ;
   int left ;
   int right ;
};
#line 96 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/rc.h"
struct Redir {
   redirtype type ;
   int fd ;
};
#line 101 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/rc.h"
struct Word {
   char *w ;
   char *m ;
   bool q ;
};
#line 29 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/parse.h"
union __anonunion_YYSTYPE_51 {
   struct Node *node ;
   struct Redir redir ;
   struct Pipe pipe ;
   struct Dup dup ;
   struct Word word ;
   char *keyword ;
};
#line 29 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/parse.h"
typedef union __anonunion_YYSTYPE_51 YYSTYPE;
#line 28 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/lex.c"
enum wordstates {
    NW = 0,
    RW = 1,
    KW = 2
} ;
#line 28 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/lex.c"
typedef enum wordstates wordstates;
#line 24 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/rc.h"
struct List;
#line 24 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/rc.h"
typedef struct List List;
#line 73 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/rc.h"
struct List {
   char *w ;
   char *m ;
   List *n ;
};
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 109 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __ssize_t ssize_t;
#line 28 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/rc.h"
struct Rq;
#line 28 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/rc.h"
typedef struct Rq Rq;
#line 106 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/rc.h"
struct Rq {
   Node *r ;
   struct Rq *n ;
};
#line 9 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/wait.c"
struct Pid;
#line 9 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/wait.c"
typedef struct Pid Pid;
#line 11 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/wait.c"
struct Pid {
   pid_t pid ;
   int stat ;
   bool alive ;
   Pid *n ;
};
#line 22 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/rc.h"
struct Htab;
#line 22 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/rc.h"
typedef struct Htab Htab;
#line 29
struct Variable;
#line 29 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/rc.h"
typedef struct Variable Variable;
#line 116 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/rc.h"
struct Variable {
   List *def ;
   char *extdef ;
   Variable *n ;
};
#line 122 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/rc.h"
struct Htab {
   char *name ;
   void *p ;
};
#line 1 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/sigmsgs.h"
struct __anonstruct_Sigmsgs_1 {
   char *name ;
   char *msg ;
};
#line 1 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/sigmsgs.h"
typedef struct __anonstruct_Sigmsgs_1 Sigmsgs;
#line 124 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 126 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 127 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 130 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 158 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 65 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __gid_t gid_t;
#line 80 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __uid_t uid_t;
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 17 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/rc.h"
struct Block;
#line 17 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/rc.h"
typedef struct Block Block;
#line 19
struct Estack;
#line 19 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/rc.h"
typedef struct Estack Estack;
#line 23
struct Jbwrap;
#line 23 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/rc.h"
typedef struct Jbwrap Jbwrap;
#line 32
union Edata;
#line 32 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/rc.h"
typedef union Edata Edata;
#line 41
enum ecodes {
    eError = 0,
    eBreak = 1,
    eReturn = 2,
    eVarstack = 3,
    eArena = 4,
    eFifo = 5,
    eFd = 6
} ;
#line 41 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/rc.h"
typedef enum ecodes ecodes;
#line 49
enum inputtype {
    iFd = 0,
    iString = 1
} ;
#line 49 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/rc.h"
typedef enum inputtype inputtype;
#line 59 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/rc.h"
union Edata {
   Jbwrap *jb ;
   Block *b ;
   char *name ;
   int fd ;
};
#line 66 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/rc.h"
struct Estack {
   ecodes e ;
   bool interactive ;
   Edata data ;
   Estack *prev ;
};
#line 31 "/usr/include/x86_64-linux-gnu/bits/setjmp.h"
typedef long __jmp_buf[8];
#line 34 "/usr/include/setjmp.h"
struct __jmp_buf_tag {
   __jmp_buf __jmpbuf ;
   int __mask_was_saved ;
   __sigset_t __saved_mask ;
};
#line 92 "/usr/include/setjmp.h"
typedef struct __jmp_buf_tag sigjmp_buf[1];
#line 21 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/jbwrap.h"
struct Jbwrap {
   sigjmp_buf j ;
};
#line 15 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/input.c"
struct Input {
   inputtype t ;
   char *ibuf ;
   int fd ;
   int index ;
   int read ;
   int lineno ;
   int last ;
   bool saved ;
   bool eofread ;
};
#line 15 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/input.c"
typedef struct Input Input;
#line 16 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/rc.h"
typedef void builtin_t(char ** );
#line 125 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/exec.c"
union __anonunion_51 {
   int __in ;
   int __i ;
};
#line 22 "/usr/include/x86_64-linux-gnu/bits/dirent.h"
struct dirent {
   __ino_t d_ino ;
   __off_t d_off ;
   unsigned short d_reclen ;
   unsigned char d_type ;
   char d_name[256] ;
};
#line 127 "/usr/include/dirent.h"
struct __dirstream;
#line 127 "/usr/include/dirent.h"
typedef struct __dirstream DIR;
#line 154 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/glob.c"
struct __anonstruct_slash_52 {
   List l ;
   size_t size ;
};
#line 20 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/rc.h"
struct rc_Function;
#line 20 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/rc.h"
typedef struct rc_Function rc_Function;
#line 111 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/rc.h"
struct rc_Function {
   Node *def ;
   char *extdef ;
};
#line 136 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __rlim_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/resource.h"
typedef __rlim_t rlim_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/resource.h"
struct rlimit {
   rlim_t rlim_cur ;
   rlim_t rlim_max ;
};
#line 42 "/usr/include/x86_64-linux-gnu/sys/resource.h"
typedef int __rlimit_resource_t;
#line 42 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/rlimit.h"
struct Suffix {
   struct Suffix  const  *next ;
   long amount ;
   char *name ;
};
#line 48 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/rlimit.h"
struct Limit {
   char *name ;
   int flag ;
   struct Suffix  const  *suffix ;
};
#line 34 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/builtins.c"
struct __anonstruct_builtins_66 {
   builtin_t *p ;
   char *name ;
};
#line 38 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/status.c"
union __anonunion_52 {
   int __in ;
   int __i ;
};
#line 40 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/status.c"
union __anonunion_53 {
   int __in ;
   int __i ;
};
#line 69 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/status.c"
union __anonunion_54 {
   int __in ;
   int __i ;
};
#line 70 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/status.c"
union __anonunion_55 {
   int __in ;
   int __i ;
};
#line 68 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/status.c"
union __anonunion_56 {
   int __in ;
   int __i ;
};
#line 106 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/status.c"
union __anonunion_57 {
   int __in ;
   int __i ;
};
#line 113 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/status.c"
union __anonunion_58 {
   int __in ;
   int __i ;
};
#line 105 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/status.c"
union __anonunion_59 {
   int __in ;
   int __i ;
};
#line 16 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/proto.h"
typedef long align_t;
#line 4 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/nalloc.c"
struct Block {
   size_t used ;
   size_t size ;
   char *mem ;
   Block *n ;
};
#line 5 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/heredoc.c"
struct Hq {
   Node *doc ;
   char *name ;
   Hq *n ;
   bool quoted ;
};
#line 239 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/hash.c"
struct nameflag {
   char *name ;
   bool flag ;
};
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 237
extern int fclose(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 543 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 17 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/mksignal.c"
static struct signaming signamings[35]  = 
#line 17 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/mksignal.c"
  {      {6, "sigabrt", "abort"}, 
        {14, "sigalrm", "alarm clock"}, 
        {7, "sigbus", "bus error"}, 
        {17, "sigchld", "child stop or exit"}, 
        {17, "sigcld", "child stop or exit"}, 
        {18, "sigcont", "continue"}, 
        {8, "sigfpe", "floating point error"}, 
        {1, "sighup", "hangup"}, 
        {4, "sigill", "illegal instruction"}, 
        {2, "sigint", ""}, 
        {29, "sigio", "socket i/o possible"}, 
        {6, "sigiot", "iot instruction"}, 
        {9, "sigkill", "killed"}, 
        {13, "sigpipe", ""}, 
        {29, "sigpoll", "pollable event occurred"}, 
        {27, "sigprof", "profiling timer alarm"}, 
        {30, "sigpwr", "power-fail restart"}, 
        {3, "sigquit", "quit"}, 
        {11, "sigsegv", "segmentation violation"}, 
        {16, "sigstkflt", "stack fault"}, 
        {19, "sigstop", "stopped by program"}, 
        {31, "sigsys", "invalid argument to system call"}, 
        {15, "sigterm", "terminated"}, 
        {5, "sigtrap", "trace trap"}, 
        {20, "sigtstp", "stopped"}, 
        {21, "sigttin", "background tty read"}, 
        {22, "sigttou", "background tty write"}, 
        {23, "sigurg", "urgent condition on i/o channel"}, 
        {10, "sigusr1", "user defined signal 1"}, 
        {12, "sigusr2", "user defined signal 2"}, 
        {26, "sigvtalrm", "virtual timer alarm"}, 
        {28, "sigwinch", "window size change"}, 
        {24, "sigxcpu", "exceeded cpu time limit"}, 
        {25, "sigxfsz", "exceeded file size limit"}, 
        {0, (char const   *)0, (char const   *)0}};
#line 195 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/mksignal.c"
static void barf(char const   *msg ) 
{ 


  {
  {
#line 196
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"mksignals: %s\n",
          msg);
#line 197
  exit(1);
  }
}
}
#line 200 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/mksignal.c"
int main(void) 
{ 
  int maxsig ;
  int s___0 ;
  struct signaming *snp ;
  FILE *outf ;
  int tmp ;
  int tmp___0 ;

  {
#line 201
  maxsig = 64;
#line 206
  snp = signamings;
  {
#line 206
  while (1) {
    while_continue: /* CIL Label */ ;
#line 206
    if (! snp->signo) {
#line 206
      goto while_break;
    }
#line 207
    if (snp->signo > maxsig) {
#line 208
      maxsig = snp->signo;
    }
#line 206
    snp ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 210
  outf = fopen((char const   */* __restrict  */)"sigmsgs.h", (char const   */* __restrict  */)"w");
  }
#line 211
  if (! outf) {
    {
#line 211
    barf("could not open sigmsgs.h for writing");
    }
  }
  {
#line 212
  fprintf((FILE */* __restrict  */)outf, (char const   */* __restrict  */)"typedef struct {\n");
#line 213
  fprintf((FILE */* __restrict  */)outf, (char const   */* __restrict  */)"\tchar *name, *msg;\n");
#line 214
  fprintf((FILE */* __restrict  */)outf, (char const   */* __restrict  */)"} Sigmsgs;\n");
#line 215
  fprintf((FILE */* __restrict  */)outf, (char const   */* __restrict  */)"extern Sigmsgs signals[];\n");
#line 216
  fprintf((FILE */* __restrict  */)outf, (char const   */* __restrict  */)"#define NUMOFSIGNALS %d\n",
          maxsig + 1);
#line 217
  tmp = fclose(outf);
  }
#line 217
  if (tmp == -1) {
    {
#line 217
    barf("could not fclose sigmsgs.h after writing");
    }
  }
  {
#line 219
  outf = fopen((char const   */* __restrict  */)"sigmsgs.c", (char const   */* __restrict  */)"w");
  }
#line 220
  if (! outf) {
    {
#line 220
    barf("could not open sigmsgs.c for writing");
    }
  }
  {
#line 221
  fprintf((FILE */* __restrict  */)outf, (char const   */* __restrict  */)"#include \"sigmsgs.h\"\n\n");
#line 222
  fprintf((FILE */* __restrict  */)outf, (char const   */* __restrict  */)"Sigmsgs signals[] = {\n");
#line 223
  fprintf((FILE */* __restrict  */)outf, (char const   */* __restrict  */)"\t{\"\",\t\"\"},\n");
#line 226
  s___0 = 1;
  }
  {
#line 226
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 226
    if (! (s___0 <= maxsig)) {
#line 226
      goto while_break___0;
    }
#line 227
    snp = signamings;
    {
#line 227
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 227
      if (snp->signo) {
#line 227
        if (! (snp->signo != s___0)) {
#line 227
          goto while_break___1;
        }
      } else {
#line 227
        goto while_break___1;
      }
#line 227
      snp ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 229
    if (snp->signo) {
      {
#line 230
      fprintf((FILE */* __restrict  */)outf, (char const   */* __restrict  */)"\t{\"%s\",\t\"%s\"},\n",
              snp->signame, snp->sigmsg);
      }
    } else {
      {
#line 233
      fprintf((FILE */* __restrict  */)outf, (char const   */* __restrict  */)"\t{\"sigunknown%d\",\t\"unknown signal %d\"},\n",
              s___0, s___0);
      }
    }
#line 226
    s___0 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 236
  fprintf((FILE */* __restrict  */)outf, (char const   */* __restrict  */)"};\n");
#line 237
  tmp___0 = fclose(outf);
  }
#line 237
  if (tmp___0 == -1) {
    {
#line 237
    barf("could not fclose sigmsgs.c after writing");
    }
  }
#line 238
  return (0);
}
}
#line 362 "/usr/include/stdio.h"
extern int printf(char const   * __restrict  __format  , ...) ;
#line 846
extern void perror(char const   *__s ) ;
#line 102 "/usr/include/x86_64-linux-gnu/sys/wait.h"
extern __pid_t wait(union wait *__stat_loc ) ;
#line 603 "/usr/include/unistd.h"
extern  __attribute__((__noreturn__)) void _exit(int __status ) ;
#line 756
extern  __attribute__((__nothrow__)) __pid_t fork(void) ;
#line 137 "/usr/include/fcntl.h"
extern int fcntl(int __fd , int __cmd  , ...) ;
#line 580 "/usr/include/stdio.h"
extern int putchar(int __c ) ;
#line 695
extern int puts(char const   *__s ) ;
#line 11 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/tripping.c"
static void out0(void) 
{ 


  {
  {
#line 12
  putchar('t');
#line 12
  putchar('r');
#line 13
  putchar('\000');
#line 14
  putchar('u');
#line 14
  putchar('e');
#line 15
  putchar('\n');
  }
#line 16
  return;
}
}
#line 18 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/tripping.c"
static void ctrl_a(void) 
{ 


  {
  {
#line 19
  puts("a\001ab\002b");
  }
#line 20
  return;
}
}
#line 22 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/tripping.c"
static void makenonblock(void) 
{ 
  int flags ;
  int tmp ;

  {
  {
#line 25
  flags = fcntl(0, 3);
  }
#line 25
  if (flags == -1) {
    {
#line 26
    perror("fcntl 1");
    }
  }
  {
#line 27
  flags |= 2048;
#line 28
  tmp = fcntl(0, 4, (long )flags);
  }
#line 28
  if (tmp == -1) {
    {
#line 29
    perror("fcntl 2");
    }
  }
#line 30
  return;
}
}
/* compiler builtin: 
   void __builtin_va_copy(__builtin_va_list  , __builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_arg(__builtin_va_list  , unsigned long  , void * ) ;  */
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 303 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/rc.h"
extern void *ealloc(size_t n ) ;
#line 304
extern void *erealloc(void *p , size_t n ) ;
#line 307
extern void *nalloc(size_t n ) ;
#line 322
extern bool (*fmtinstall(int c , bool (*f)(Format * , int  ) ))(Format * , int  ) ;
#line 323
extern int printfmt(Format *format , char const   *fmt ) ;
#line 324
extern int fmtprint(Format *format , char const   *fmt  , ...) ;
#line 325
extern void fmtappend(Format *format , char const   *s___0 , size_t len ) ;
#line 326
extern void fmtcat(Format *format , char const   *s___0 ) ;
#line 327
extern int fprint(int fd , char const   *fmt  , ...) ;
#line 328
extern char *mprint(char const   *fmt  , ...) ;
#line 329
extern char *nprint(char const   *fmt  , ...) ;
#line 405
extern void writeall(int fd , char *buf , size_t remain ) ;
#line 431
extern  __attribute__((__noreturn__)) void panic(char *s___0 ) ;
#line 22 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/print.c"
static bool uconv(Format *format , int ignore ) 
{ 


  {
#line 22
  format->flags |= 8L;
#line 22
  return ((bool )1);
}
}
#line 23 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/print.c"
static bool rc_lconv(Format *format , int ignore ) 
{ 


  {
#line 23
  format->flags |= 2L;
#line 23
  return ((bool )1);
}
}
#line 29 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/print.c"
static bool altconv(Format *format , int ignore ) 
{ 


  {
#line 29
  format->flags |= 64L;
#line 29
  return ((bool )1);
}
}
#line 30 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/print.c"
static bool leftconv(Format *format , int ignore ) 
{ 


  {
#line 30
  format->flags |= 32L;
#line 30
  return ((bool )1);
}
}
#line 31 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/print.c"
static bool dotconv(Format *format , int ignore ) 
{ 


  {
#line 31
  format->flags |= 256L;
#line 31
  return ((bool )1);
}
}
#line 33 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/print.c"
static bool digitconv(Format *format , int c ) 
{ 


  {
#line 34
  if (format->flags & 256L) {
#line 35
    format->f2 = (10L * format->f2 + (long )c) - 48L;
  } else {
#line 37
    format->flags |= 128L;
#line 38
    format->f1 = (10L * format->f1 + (long )c) - 48L;
  }
#line 40
  return ((bool )1);
}
}
#line 43 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/print.c"
static bool zeroconv(Format *format , int ignore ) 
{ 
  bool tmp ;

  {
#line 44
  if (format->flags & 384L) {
    {
#line 45
    tmp = digitconv(format, '0');
    }
#line 45
    return (tmp);
  }
#line 46
  format->flags |= 16L;
#line 47
  return ((bool )1);
}
}
#line 50 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/print.c"
static void pad(Format *format , size_t len , int c ) 
{ 
  char *tmp ;
  size_t tmp___0 ;

  {
  {
#line 51
  while (1) {
    while_continue: /* CIL Label */ ;
#line 51
    tmp___0 = len;
#line 51
    len --;
#line 51
    if (! (tmp___0 != 0UL)) {
#line 51
      goto while_break;
    }
#line 52
    if ((unsigned long )format->buf >= (unsigned long )format->bufend) {
      {
#line 52
      (*(format->grow))(format, (size_t )1);
      }
    }
#line 52
    tmp = format->buf;
#line 52
    (format->buf) ++;
#line 52
    *tmp = (char )c;
  }
  while_break: /* CIL Label */ ;
  }
#line 53
  return;
}
}
#line 55 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/print.c"
static bool sconv(Format *format , int ignore ) 
{ 
  char *s___0 ;
  char *tmp___0 ;
  size_t len ;
  size_t tmp___1 ;
  size_t width ;

  {
  {
#line 56
  tmp___0 = __builtin_va_arg(format->args, char *);
#line 56
  s___0 = tmp___0;
  }
#line 57
  if ((format->flags & 128L) == 0L) {
    {
#line 58
    fmtcat(format, (char const   *)s___0);
    }
  } else {
    {
#line 60
    tmp___1 = strlen((char const   *)s___0);
#line 60
    len = tmp___1;
#line 60
    width = (size_t )format->f1 - len;
    }
#line 61
    if (format->flags & 32L) {
      {
#line 62
      fmtappend(format, (char const   *)s___0, len);
#line 63
      pad(format, width, ' ');
      }
    } else {
      {
#line 65
      pad(format, width, ' ');
#line 66
      fmtappend(format, (char const   *)s___0, len);
      }
    }
  }
#line 69
  return ((bool )0);
}
}
#line 72 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/print.c"
static char *rc_utoa(unsigned long u , char *t , unsigned int radix , char const   *digit ) 
{ 
  char *tmp ;

  {
#line 73
  if (u >= (unsigned long )radix) {
    {
#line 74
    t = rc_utoa(u / (unsigned long )radix, t, radix, digit);
#line 75
    u %= (unsigned long )radix;
    }
  }
#line 77
  tmp = t;
#line 77
  t ++;
#line 77
  *tmp = (char )*(digit + u);
#line 78
  return (t);
}
}
#line 82
static void intconv(Format *format , unsigned int radix , int upper , char const   *altform ) ;
#line 82 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/print.c"
static char const   * const  table[2]  = {      (char const   */* const  */)"0123456789abcdefghijklmnopqrstuvwxyz",      (char const   */* const  */)"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"};
#line 81 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/print.c"
static void intconv(Format *format , unsigned int radix , int upper , char const   *altform ) 
{ 
  char padchar ;
  size_t len ;
  size_t pre ;
  size_t zeroes ;
  size_t padding ;
  size_t width ;
  long n ;
  long flags ;
  unsigned long u ;
  char number[64] ;
  char prefix[20] ;
  long tmp ;
  long tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  char const   *tmp___3 ;
  char *tmp___4 ;

  {
#line 92
  if (radix > 36U) {
#line 93
    return;
  }
#line 95
  flags = format->flags;
#line 103
  if (flags & 2L) {
    {
#line 104
    tmp = __builtin_va_arg(format->args, long );
#line 104
    n = tmp;
    }
  } else {
    {
#line 106
    tmp___0 = __builtin_va_arg(format->args, int );
#line 106
    n = tmp___0;
    }
  }
#line 108
  pre = (size_t )0;
#line 109
  if (flags & 8L) {
#line 110
    u = (unsigned long )n;
  } else
#line 109
  if (n >= 0L) {
#line 110
    u = (unsigned long )n;
  } else {
#line 112
    tmp___1 = pre;
#line 112
    pre ++;
#line 112
    prefix[tmp___1] = (char )'-';
#line 113
    u = (unsigned long )(- n);
  }
#line 116
  if (flags & 64L) {
    {
#line 117
    while (1) {
      while_continue: /* CIL Label */ ;
#line 117
      if (! ((int const   )*altform != 0)) {
#line 117
        goto while_break;
      }
#line 118
      tmp___2 = pre;
#line 118
      pre ++;
#line 118
      tmp___3 = altform;
#line 118
      altform ++;
#line 118
      prefix[tmp___2] = (char )*tmp___3;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 120
  tmp___4 = rc_utoa(u, number, radix, (char const   *)table[upper]);
#line 120
  len = (size_t )(tmp___4 - number);
  }
#line 121
  if (flags & 256L) {
#line 121
    if ((size_t )format->f2 > len) {
#line 122
      zeroes = (size_t )format->f2 - len;
    } else {
#line 124
      zeroes = (size_t )0;
    }
  } else {
#line 124
    zeroes = (size_t )0;
  }
#line 126
  width = (pre + zeroes) + len;
#line 127
  if (flags & 128L) {
#line 127
    if ((size_t )format->f1 > width) {
#line 128
      padding = (size_t )format->f1 - width;
    } else {
#line 130
      padding = (size_t )0;
    }
  } else {
#line 130
    padding = (size_t )0;
  }
#line 132
  padchar = (char )' ';
#line 133
  if (padding > 0UL) {
#line 133
    if (flags & 16L) {
#line 134
      padchar = (char )'0';
#line 135
      if ((flags & 32L) == 0L) {
#line 136
        zeroes += padding;
#line 137
        padding = (size_t )0;
      }
    }
  }
#line 142
  if ((flags & 32L) == 0L) {
    {
#line 143
    pad(format, padding, (int )padchar);
    }
  }
  {
#line 144
  fmtappend(format, (char const   *)(prefix), pre);
#line 145
  pad(format, zeroes, '0');
#line 146
  fmtappend(format, (char const   *)(number), len);
  }
#line 147
  if (flags & 32L) {
    {
#line 148
    pad(format, padding, (int )padchar);
    }
  }
#line 149
  return;
}
}
#line 151 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/print.c"
static bool cconv(Format *format , int ignore ) 
{ 
  char *tmp ;
  char tmp___0 ;

  {
#line 152
  if ((unsigned long )format->buf >= (unsigned long )format->bufend) {
    {
#line 152
    (*(format->grow))(format, (size_t )1);
    }
  }
  {
#line 152
  tmp = format->buf;
#line 152
  (format->buf) ++;
#line 152
  tmp___0 = __builtin_va_arg(format->args, int );
#line 152
  *tmp = tmp___0;
  }
#line 153
  return ((bool )0);
}
}
#line 156 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/print.c"
static bool dconv(Format *format , int ignore ) 
{ 


  {
  {
#line 157
  intconv(format, 10U, 0, "");
  }
#line 158
  return ((bool )0);
}
}
#line 161 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/print.c"
static bool oconv(Format *format , int ignore ) 
{ 


  {
  {
#line 162
  intconv(format, 8U, 0, "0");
  }
#line 163
  return ((bool )0);
}
}
#line 166 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/print.c"
static bool xconv(Format *format , int ignore ) 
{ 


  {
  {
#line 167
  intconv(format, 16U, 0, "0x");
  }
#line 168
  return ((bool )0);
}
}
#line 171 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/print.c"
static bool pctconv(Format *format , int ignore ) 
{ 
  char *tmp ;

  {
#line 172
  if ((unsigned long )format->buf >= (unsigned long )format->bufend) {
    {
#line 172
    (*(format->grow))(format, (size_t )1);
    }
  }
#line 172
  tmp = format->buf;
#line 172
  (format->buf) ++;
#line 172
  *tmp = (char )'%';
#line 173
  return ((bool )0);
}
}
#line 176 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/print.c"
static bool badconv(Format *ignore , int ign0re ) 
{ 


  {
  {
#line 177
  panic((char *)"bad conversion character in printfmt");
  }
#line 179
  return ((bool )0);
}
}
#line 187 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/print.c"
static Conv fmttab[256]  ;
#line 189 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/print.c"
static void inittab(void) 
{ 
  int i ;

  {
#line 191
  i = 0;
  {
#line 191
  while (1) {
    while_continue: /* CIL Label */ ;
#line 191
    if (! (i < 256)) {
#line 191
      goto while_break;
    }
#line 192
    fmttab[i] = & badconv;
#line 191
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 194
  fmttab['s'] = & sconv;
#line 195
  fmttab['c'] = & cconv;
#line 196
  fmttab['d'] = & dconv;
#line 197
  fmttab['o'] = & oconv;
#line 198
  fmttab['x'] = & xconv;
#line 199
  fmttab['%'] = & pctconv;
#line 201
  fmttab['u'] = & uconv;
#line 202
  fmttab['l'] = & rc_lconv;
#line 203
  fmttab['#'] = & altconv;
#line 204
  fmttab['-'] = & leftconv;
#line 205
  fmttab['.'] = & dotconv;
#line 211
  fmttab['0'] = & zeroconv;
#line 212
  i = '1';
  {
#line 212
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 212
    if (! (i <= 57)) {
#line 212
      goto while_break___0;
    }
#line 213
    fmttab[i] = & digitconv;
#line 212
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 214
  return;
}
}
#line 216 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/print.c"
extern bool (*fmtinstall(int c , bool (*f)(Format * , int  ) ))(Format * , int  ) 
{ 
  bool (*oldf)(Format * , int  ) ;

  {
#line 219
  if ((unsigned long )fmttab[0] == (unsigned long )((void *)0)) {
    {
#line 220
    inittab();
    }
  }
#line 221
  c &= 255;
#line 222
  oldf = fmttab[c];
#line 223
  if ((unsigned long )f != (unsigned long )((void *)0)) {
#line 224
    fmttab[c] = f;
  }
#line 225
  return (oldf);
}
}
#line 233 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/print.c"
extern void fmtappend(Format *format , char const   *s___0 , size_t len ) 
{ 
  size_t split ;

  {
  {
#line 234
  while (1) {
    while_continue: /* CIL Label */ ;
#line 234
    if (! ((unsigned long )(format->buf + len) > (unsigned long )format->bufend)) {
#line 234
      goto while_break;
    }
    {
#line 235
    split = (size_t )(format->bufend - format->buf);
#line 236
    memcpy((void */* __restrict  */)format->buf, (void const   */* __restrict  */)s___0,
           split);
#line 237
    format->buf += split;
#line 238
    s___0 += split;
#line 239
    len -= split;
#line 240
    (*(format->grow))(format, len);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 242
  memcpy((void */* __restrict  */)format->buf, (void const   */* __restrict  */)s___0,
         len);
#line 243
  format->buf += len;
  }
#line 244
  return;
}
}
#line 246 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/print.c"
extern void fmtcat(Format *format , char const   *s___0 ) 
{ 
  size_t tmp ;

  {
  {
#line 247
  tmp = strlen(s___0);
#line 247
  fmtappend(format, s___0, tmp);
  }
#line 248
  return;
}
}
#line 254 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/print.c"
extern int printfmt(Format *format , char const   *fmt ) 
{ 
  unsigned char const   *s___0 ;
  int c ;
  unsigned char const   *tmp ;
  long tmp___0 ;
  long tmp___1 ;
  unsigned char const   *tmp___2 ;
  bool tmp___3 ;
  char *tmp___4 ;

  {
#line 255
  s___0 = (unsigned char const   *)fmt;
#line 257
  if ((unsigned long )fmttab[0] == (unsigned long )((void *)0)) {
    {
#line 258
    inittab();
    }
  }
  {
#line 260
  while (1) {
    while_continue: /* CIL Label */ ;
#line 261
    tmp = s___0;
#line 261
    s___0 ++;
#line 261
    c = (int )*tmp;
    {
#line 263
    if (c == 37) {
#line 263
      goto case_37;
    }
#line 269
    if (c == 0) {
#line 269
      goto case_0;
    }
#line 271
    goto switch_default;
    case_37: /* CIL Label */ 
#line 264
    tmp___1 = 0L;
#line 264
    format->f2 = tmp___1;
#line 264
    tmp___0 = tmp___1;
#line 264
    format->f1 = tmp___0;
#line 264
    format->flags = tmp___0;
    {
#line 265
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 266
      tmp___2 = s___0;
#line 266
      s___0 ++;
#line 266
      c = (int )*tmp___2;
#line 265
      tmp___3 = (*(fmttab[c]))(format, c);
      }
#line 265
      if (! tmp___3) {
#line 265
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 268
    goto switch_break;
    case_0: /* CIL Label */ 
#line 270
    return ((int )((format->buf - format->bufbegin) + (long )format->flushed));
    switch_default: /* CIL Label */ 
#line 272
    if ((unsigned long )format->buf >= (unsigned long )format->bufend) {
      {
#line 272
      (*(format->grow))(format, (size_t )1);
      }
    }
#line 272
    tmp___4 = format->buf;
#line 272
    (format->buf) ++;
#line 272
    *tmp___4 = (char )c;
#line 273
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 283 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/print.c"
extern int fmtprint(Format *format , char const   *fmt  , ...) 
{ 
  int n ;
  va_list ap ;
  va_list saveargs ;
  int tmp ;

  {
  {
#line 284
  n = - format->flushed;
#line 287
  __builtin_va_start(ap, fmt);
#line 288
  __builtin_va_copy(saveargs, format->args);
#line 289
  __builtin_va_copy(format->args, ap);
#line 290
  tmp = printfmt(format, fmt);
#line 290
  n += tmp;
#line 291
  __builtin_va_end(format->args);
#line 292
  __builtin_va_copy(format->args, saveargs);
  }
#line 294
  return (n + format->flushed);
}
}
#line 297 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/print.c"
static void fprint_flush(Format *format , size_t ignore ) 
{ 
  size_t n ;
  char *buf ;

  {
  {
#line 298
  n = (size_t )(format->buf - format->bufbegin);
#line 299
  buf = format->bufbegin;
#line 301
  format->flushed = (int )((size_t )format->flushed + n);
#line 302
  format->buf = format->bufbegin;
#line 303
  writeall(format->u.n, buf, n);
  }
#line 304
  return;
}
}
#line 306 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/print.c"
extern int fprint(int fd , char const   *fmt  , ...) 
{ 
  char buf[1024] ;
  Format format ;
  va_list ap ;

  {
  {
#line 311
  format.buf = buf;
#line 312
  format.bufbegin = buf;
#line 313
  format.bufend = buf + sizeof(buf);
#line 314
  format.grow = & fprint_flush;
#line 315
  format.flushed = 0;
#line 316
  format.u.n = fd;
#line 318
  __builtin_va_start(ap, fmt);
#line 319
  __builtin_va_copy(format.args, ap);
#line 320
  printfmt(& format, fmt);
#line 321
  __builtin_va_end(format.args);
#line 323
  fprint_flush(& format, (size_t )0);
  }
#line 324
  return (format.flushed);
}
}
#line 327 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/print.c"
static void memprint_grow(Format *format , size_t more ) 
{ 
  char *buf ;
  size_t len ;
  size_t used ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 329
  len = (size_t )((format->bufend - format->bufbegin) + 1L);
#line 330
  used = (size_t )(format->buf - format->bufbegin);
#line 332
  if (len >= more) {
#line 332
    len *= 2UL;
  } else {
#line 332
    len = ((len + more) + 64UL) & 0xffffffffffffffc0UL;
  }
#line 335
  if (format->u.n) {
    {
#line 336
    tmp = erealloc((void *)format->bufbegin, len);
#line 336
    buf = (char *)tmp;
    }
  } else {
    {
#line 338
    tmp___0 = nalloc(len);
#line 338
    buf = (char *)tmp___0;
#line 339
    memcpy((void */* __restrict  */)buf, (void const   */* __restrict  */)format->bufbegin,
           used);
    }
  }
#line 341
  format->buf = buf + used;
#line 342
  format->bufbegin = buf;
#line 343
  format->bufend = (buf + len) - 1;
#line 344
  return;
}
}
#line 346 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/print.c"
static char *memprint(Format *format , char const   *fmt , char *buf , size_t len ) 
{ 


  {
  {
#line 347
  format->buf = buf;
#line 348
  format->bufbegin = buf;
#line 349
  format->bufend = (buf + len) - 1;
#line 350
  format->grow = & memprint_grow;
#line 351
  format->flushed = 0;
#line 352
  printfmt(format, fmt);
#line 353
  *(format->buf) = (char )'\000';
  }
#line 354
  return (format->bufbegin);
}
}
#line 357 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/print.c"
extern char *mprint(char const   *fmt  , ...) 
{ 
  Format format ;
  char *result ;
  va_list ap ;
  void *tmp ;

  {
  {
#line 362
  format.u.n = 1;
#line 363
  __builtin_va_start(ap, fmt);
#line 364
  __builtin_va_copy(format.args, ap);
#line 365
  tmp = ealloc((size_t )64);
#line 365
  result = memprint(& format, fmt, (char *)tmp, (size_t )64);
#line 366
  __builtin_va_end(format.args);
  }
#line 367
  return (result);
}
}
#line 370 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/print.c"
extern char *nprint(char const   *fmt  , ...) 
{ 
  Format format ;
  char *result ;
  va_list ap ;
  void *tmp ;

  {
  {
#line 375
  format.u.n = 0;
#line 376
  __builtin_va_start(ap, fmt);
#line 377
  __builtin_va_copy(format.args, ap);
#line 378
  tmp = nalloc((size_t )64);
#line 378
  result = memprint(& format, fmt, (char *)tmp, (size_t )64);
#line 379
  __builtin_va_end(format.args);
  }
#line 380
  return (result);
}
}
#line 218 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) sigfillset)(sigset_t *__set ) ;
#line 259
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sigaction)(int __sig ,
                                                                                struct sigaction  const  * __restrict  __act ,
                                                                                struct sigaction * __restrict  __oact ) ;
#line 385 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/rc.h"
extern void initsignal(void) ;
#line 386
extern void catcher(int s___0 ) ;
#line 387
extern void sigchk(void) ;
#line 388
extern void (*rc_signal(int s___0 , void (*h)(int  ) ))(int  ) ;
#line 389 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/rc.h"
void (*sighandlers[65])(int  )  ;
#line 443
bool forked ;
#line 12 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/signal.c"
static void (*sys_signal(int signum , void (*handler)(int  ) ))(int  ) 
{ 
  struct sigaction new ;
  struct sigaction old ;

  {
  {
#line 15
  new.__sigaction_handler.sa_handler = handler;
#line 16
  new.sa_flags = 0;
#line 17
  sigfillset(& new.sa_mask);
#line 18
  sigaction(signum, (struct sigaction  const  */* __restrict  */)(& new), (struct sigaction */* __restrict  */)(& old));
  }
#line 19
  return (old.__sigaction_handler.sa_handler);
}
}
#line 27 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/signal.c"
static sig_atomic_t volatile   sigcount  ;
#line 27 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/signal.c"
static sig_atomic_t volatile   caught[65]  ;
#line 29 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/signal.c"
extern void catcher(int s___0 ) 
{ 


  {
#line 30
  if (caught[s___0] == (sig_atomic_t volatile   )0) {
#line 31
    sigcount += (sig_atomic_t volatile   )1;
#line 32
    caught[s___0] = (sig_atomic_t volatile   )1;
  }
  {
#line 34
  sys_signal(s___0, & catcher);
  }
#line 46
  return;
}
}
#line 48 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/signal.c"
extern void sigchk(void) 
{ 
  void (*h)(int  ) ;
  int s___0 ;
  int i ;

  {
#line 52
  if (sigcount == (sig_atomic_t volatile   )0) {
#line 53
    return;
  }
#line 54
  if (forked) {
    {
#line 55
    exit(1);
    }
  }
#line 56
  i = 0;
#line 56
  s___0 = -1;
  {
#line 56
  while (1) {
    while_continue: /* CIL Label */ ;
#line 56
    if (! (i < 65)) {
#line 56
      goto while_break;
    }
#line 57
    if (caught[i] != (sig_atomic_t volatile   )0) {
#line 58
      s___0 = i;
#line 59
      sigcount -= (sig_atomic_t volatile   )1;
#line 60
      caught[s___0] = (sig_atomic_t volatile   )0;
#line 61
      goto while_break;
    }
#line 56
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 63
  if (s___0 == -1) {
    {
#line 64
    panic((char *)"all-zero sig vector with nonzero sigcount");
    }
  }
#line 65
  h = sighandlers[s___0];
#line 65
  if ((unsigned long )h == (unsigned long )((void (*)(int  ))0)) {
    {
#line 66
    panic((char *)"caught signal set to SIG_DFL");
    }
  }
#line 67
  if ((unsigned long )h == (unsigned long )((void (*)(int  ))1)) {
    {
#line 68
    panic((char *)"caught signal set to SIG_IGN");
    }
  }
  {
#line 69
  (*h)(s___0);
  }
#line 70
  return;
}
}
#line 72 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/signal.c"
extern void (*rc_signal(int s___0 , void (*h)(int  ) ))(int  ) 
{ 
  void (*old)(int  ) ;

  {
  {
#line 74
  sigchk();
#line 75
  old = sighandlers[s___0];
  }
#line 76
  if ((unsigned long )h == (unsigned long )((void (*)(int  ))0)) {
    {
#line 77
    sighandlers[s___0] = h;
#line 78
    sys_signal(s___0, h);
    }
  } else
#line 76
  if ((unsigned long )h == (unsigned long )((void (*)(int  ))1)) {
    {
#line 77
    sighandlers[s___0] = h;
#line 78
    sys_signal(s___0, h);
    }
  } else {
    {
#line 80
    sighandlers[s___0] = h;
#line 81
    sys_signal(s___0, & catcher);
    }
  }
#line 83
  return (old);
}
}
#line 86 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/signal.c"
extern void initsignal(void) 
{ 
  void (*h)(int  ) ;
  int i ;

  {
  {
#line 92
  h = sys_signal(17, (void (*)(int  ))1);
  }
#line 93
  if ((unsigned long )h != (unsigned long )((void (*)(int  ))1)) {
#line 93
    if ((unsigned long )h != (unsigned long )((void (*)(int  ))-1)) {
      {
#line 94
      sys_signal(17, h);
      }
    } else {
      {
#line 96
      sys_signal(17, (void (*)(int  ))0);
      }
    }
  } else {
    {
#line 96
    sys_signal(17, (void (*)(int  ))0);
    }
  }
#line 99
  i = 1;
  {
#line 99
  while (1) {
    while_continue: /* CIL Label */ ;
#line 99
    if (! (i < 65)) {
#line 99
      goto while_break;
    }
#line 101
    if (i == 9) {
#line 101
      goto __Cont;
    }
#line 104
    if (i == 19) {
#line 104
      goto __Cont;
    }
    {
#line 106
    h = sys_signal(i, (void (*)(int  ))1);
    }
#line 107
    if ((unsigned long )h != (unsigned long )((void (*)(int  ))1)) {
#line 107
      if ((unsigned long )h != (unsigned long )((void (*)(int  ))-1)) {
        {
#line 108
        sys_signal(i, h);
        }
      }
    }
#line 109
    sighandlers[i] = h;
    __Cont: /* CIL Label */ 
#line 99
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 111
  return;
}
}
#line 129 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 144
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 175 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/rc.h"
bool interactive ;
#line 178 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/rc.h"
int lineno  ;
#line 266
struct Hq *hq ;
#line 272
extern int gchar(void) ;
#line 273
extern void ugchar(int c ) ;
#line 275
extern void flushu(void) ;
#line 276
extern void print_prompt2(void) ;
#line 281
int lastchar ;
#line 286
extern bool quotep(char *s___0 , bool dollar___0 ) ;
#line 287
extern int yylex(void) ;
#line 288
extern void inityy(void) ;
#line 289
extern void yyerror(char const   *s___0 ) ;
#line 290
extern void scanerror(char *s___0 ) ;
#line 291
char const   nw[256] ;
#line 291
char const   dnw[256] ;
#line 305
extern void efree(void *p ) ;
#line 37 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/parse.h"
YYSTYPE yylval ;
#line 32 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/lex.c"
static void getpair(int c ) ;
#line 36 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/lex.c"
char const   nw[256]  = 
#line 36
  {      (char const   )1,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )1,      (char const   )1,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )1,      (char const   )1,      (char const   )0,      (char const   )1, 
        (char const   )1,      (char const   )0,      (char const   )1,      (char const   )1, 
        (char const   )1,      (char const   )1,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )1, 
        (char const   )1,      (char const   )1,      (char const   )1,      (char const   )0, 
        (char const   )1,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )1,      (char const   )0,      (char const   )1,      (char const   )0, 
        (char const   )1,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )1, 
        (char const   )1,      (char const   )1,      (char const   )1,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0};
#line 47 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/lex.c"
char const   dnw[256]  = 
#line 47
  {      (char const   )1,      (char const   )1,      (char const   )1,      (char const   )1, 
        (char const   )1,      (char const   )1,      (char const   )1,      (char const   )1, 
        (char const   )1,      (char const   )1,      (char const   )1,      (char const   )1, 
        (char const   )1,      (char const   )1,      (char const   )1,      (char const   )1, 
        (char const   )1,      (char const   )1,      (char const   )1,      (char const   )1, 
        (char const   )1,      (char const   )1,      (char const   )1,      (char const   )1, 
        (char const   )1,      (char const   )1,      (char const   )1,      (char const   )1, 
        (char const   )1,      (char const   )1,      (char const   )1,      (char const   )1, 
        (char const   )1,      (char const   )1,      (char const   )1,      (char const   )1, 
        (char const   )1,      (char const   )1,      (char const   )1,      (char const   )1, 
        (char const   )1,      (char const   )1,      (char const   )0,      (char const   )1, 
        (char const   )1,      (char const   )1,      (char const   )1,      (char const   )1, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )1,      (char const   )1, 
        (char const   )1,      (char const   )1,      (char const   )1,      (char const   )1, 
        (char const   )1,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )1, 
        (char const   )1,      (char const   )1,      (char const   )1,      (char const   )0, 
        (char const   )1,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )1, 
        (char const   )1,      (char const   )1,      (char const   )1,      (char const   )1, 
        (char const   )1,      (char const   )1,      (char const   )1,      (char const   )1, 
        (char const   )1,      (char const   )1,      (char const   )1,      (char const   )1, 
        (char const   )1,      (char const   )1,      (char const   )1,      (char const   )1, 
        (char const   )1,      (char const   )1,      (char const   )1,      (char const   )1, 
        (char const   )1,      (char const   )1,      (char const   )1,      (char const   )1, 
        (char const   )1,      (char const   )1,      (char const   )1,      (char const   )1, 
        (char const   )1,      (char const   )1,      (char const   )1,      (char const   )1, 
        (char const   )1,      (char const   )1,      (char const   )1,      (char const   )1, 
        (char const   )1,      (char const   )1,      (char const   )1,      (char const   )1, 
        (char const   )1,      (char const   )1,      (char const   )1,      (char const   )1, 
        (char const   )1,      (char const   )1,      (char const   )1,      (char const   )1, 
        (char const   )1,      (char const   )1,      (char const   )1,      (char const   )1, 
        (char const   )1,      (char const   )1,      (char const   )1,      (char const   )1, 
        (char const   )1,      (char const   )1,      (char const   )1,      (char const   )1, 
        (char const   )1,      (char const   )1,      (char const   )1,      (char const   )1, 
        (char const   )1,      (char const   )1,      (char const   )1,      (char const   )1, 
        (char const   )1,      (char const   )1,      (char const   )1,      (char const   )1, 
        (char const   )1,      (char const   )1,      (char const   )1,      (char const   )1, 
        (char const   )1,      (char const   )1,      (char const   )1,      (char const   )1, 
        (char const   )1,      (char const   )1,      (char const   )1,      (char const   )1, 
        (char const   )1,      (char const   )1,      (char const   )1,      (char const   )1, 
        (char const   )1,      (char const   )1,      (char const   )1,      (char const   )1, 
        (char const   )1,      (char const   )1,      (char const   )1,      (char const   )1, 
        (char const   )1,      (char const   )1,      (char const   )1,      (char const   )1, 
        (char const   )1,      (char const   )1,      (char const   )1,      (char const   )1, 
        (char const   )1,      (char const   )1,      (char const   )1,      (char const   )1, 
        (char const   )1,      (char const   )1,      (char const   )1,      (char const   )1, 
        (char const   )1,      (char const   )1,      (char const   )1,      (char const   )1, 
        (char const   )1,      (char const   )1,      (char const   )1,      (char const   )1, 
        (char const   )1,      (char const   )1,      (char const   )1,      (char const   )1, 
        (char const   )1,      (char const   )1,      (char const   )1,      (char const   )1, 
        (char const   )1,      (char const   )1,      (char const   )1,      (char const   )1};
#line 58 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/lex.c"
static size_t bufsize  =    (size_t )1000;
#line 59 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/lex.c"
static char *realbuf  =    (char *)((void *)0);
#line 60 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/lex.c"
static bool newline  =    (bool )0;
#line 61 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/lex.c"
static bool errset  =    (bool )0;
#line 62 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/lex.c"
static bool prerror  =    (bool )0;
#line 63 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/lex.c"
static wordstates w  =    (wordstates )0;
#line 64 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/lex.c"
static int fd_left  ;
#line 64 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/lex.c"
static int fd_right  ;
#line 73 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/lex.c"
extern bool quotep(char *s___0 , bool dollar___0 ) 
{ 
  unsigned char c ;
  char const   *meta ;
  char *tmp ;

  {
#line 77
  if (dollar___0) {
#line 77
    meta = dnw;
  } else {
#line 77
    meta = nw;
  }
  {
#line 78
  while (1) {
    while_continue: /* CIL Label */ ;
#line 78
    tmp = s___0;
#line 78
    s___0 ++;
#line 78
    c = (unsigned char )*tmp;
#line 78
    if (! c) {
#line 78
      goto while_break;
    }
#line 79
    if (*(meta + c)) {
#line 80
      return ((bool )1);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 81
  return ((bool )0);
}
}
#line 85 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/lex.c"
static bool dollar  =    (bool )0;
#line 84 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/lex.c"
extern int yylex(void) 
{ 
  bool saw_meta ;
  int c ;
  size_t i ;
  char const   *meta ;
  char *buf ;
  YYSTYPE *y ;
  size_t tmp ;
  void *tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  size_t tmp___8 ;
  void *tmp___9 ;
  char *r ;
  char *s___0 ;
  size_t tmp___10 ;
  void *tmp___11 ;
  int tmp___12 ;
  size_t tmp___13 ;
  void *tmp___14 ;
  size_t tmp___15 ;
  void *tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;

  {
#line 86
  saw_meta = (bool )0;
#line 90
  buf = realbuf;
#line 91
  y = & yylval;
#line 92
  if (errset) {
#line 93
    errset = (bool )0;
#line 94
    return ('\n');
  }
#line 97
  if (dollar) {
#line 97
    meta = dnw;
  } else {
#line 97
    meta = nw;
  }
#line 98
  dollar = (bool )0;
#line 99
  if (newline) {
    {
#line 100
    lineno --;
#line 101
    print_prompt2();
#line 102
    newline = (bool )0;
    }
  }
  top: 
  {
#line 104
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 104
    c = gchar();
    }
#line 104
    if (! (c == 32)) {
#line 104
      if (! (c == 9)) {
#line 104
        goto while_break;
      }
    }
#line 105
    w = (wordstates )0;
  }
  while_break: /* CIL Label */ ;
  }
#line 106
  if (c == -1) {
#line 107
    return (264);
  }
#line 108
  if (! *(meta + (unsigned char )c)) {
#line 109
    if ((unsigned int )w != 0U) {
      {
#line 109
      w = (wordstates )0;
#line 109
      ugchar(c);
      }
#line 109
      return ('^');
    }
#line 110
    w = (wordstates )1;
#line 111
    i = (size_t )0;
    read: 
    {
#line 112
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 113
      tmp = i;
#line 113
      i ++;
#line 113
      *(buf + tmp) = (char )c;
#line 114
      if (c == 63) {
#line 115
        saw_meta = (bool )1;
      } else
#line 114
      if (c == 91) {
#line 115
        saw_meta = (bool )1;
      } else
#line 114
      if (c == 42) {
#line 115
        saw_meta = (bool )1;
      }
#line 116
      if (i >= bufsize) {
        {
#line 117
        bufsize *= 2UL;
#line 117
        tmp___0 = erealloc((void *)buf, bufsize);
#line 117
        realbuf = (char *)tmp___0;
#line 117
        buf = realbuf;
        }
      }
      {
#line 112
      c = gchar();
      }
#line 112
      if (c != -1) {
#line 112
        if (! (! *(meta + (unsigned char )c))) {
#line 112
          goto while_break___0;
        }
      } else {
#line 112
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 119
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 119
      if (! (c == 92)) {
#line 119
        goto while_break___1;
      }
      {
#line 120
      c = gchar();
      }
#line 120
      if (c == 10) {
        {
#line 121
        print_prompt2();
#line 122
        c = ' ';
        }
#line 123
        goto while_break___1;
      } else
      bs: 
#line 125
      if ((unsigned long )meta != (unsigned long )(dnw)) {
#line 126
        tmp___1 = i;
#line 126
        i ++;
#line 126
        *(buf + tmp___1) = (char )'\\';
#line 127
        if (i >= bufsize) {
          {
#line 128
          bufsize *= 2UL;
#line 128
          tmp___2 = erealloc((void *)buf, bufsize);
#line 128
          realbuf = (char *)tmp___2;
#line 128
          buf = realbuf;
          }
        }
#line 129
        if (! *(meta + (unsigned char )c)) {
#line 130
          goto read;
        }
      } else {
        {
#line 132
        ugchar(c);
#line 133
        c = '\\';
        }
#line 134
        goto while_break___1;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 138
    ugchar(c);
#line 139
    *(buf + i) = (char )'\000';
#line 140
    w = (wordstates )2;
    }
#line 141
    if (i == 2UL) {
#line 142
      if ((int )*buf == 105) {
#line 142
        if ((int )*(buf + 1) == 102) {
#line 142
          return (268);
        }
      }
#line 143
      if ((int )*buf == 102) {
#line 143
        if ((int )*(buf + 1) == 110) {
#line 143
          return (266);
        }
      }
#line 144
      if ((int )*buf == 105) {
#line 144
        if ((int )*(buf + 1) == 110) {
#line 144
          return (269);
        }
      }
    }
#line 146
    if ((int )*buf == (int )*"for") {
      {
#line 146
      tmp___3 = strcmp((char const   *)buf, "for");
      }
#line 146
      if (tmp___3 == 0) {
#line 146
        return (267);
      }
    }
#line 147
    if ((int )*buf == (int )*"else") {
      {
#line 147
      tmp___4 = strcmp((char const   *)buf, "else");
      }
#line 147
      if (tmp___4 == 0) {
#line 147
        return (263);
      }
    }
#line 148
    if ((int )*buf == (int )*"switch") {
      {
#line 148
      tmp___5 = strcmp((char const   *)buf, "switch");
      }
#line 148
      if (tmp___5 == 0) {
#line 148
        return (276);
      }
    }
#line 149
    if ((int )*buf == (int )*"while") {
      {
#line 149
      tmp___6 = strcmp((char const   *)buf, "while");
      }
#line 149
      if (tmp___6 == 0) {
#line 149
        return (278);
      }
    }
#line 150
    if ((int )*buf == (int )*"case") {
      {
#line 150
      tmp___7 = strcmp((char const   *)buf, "case");
      }
#line 150
      if (tmp___7 == 0) {
#line 150
        return (260);
      }
    }
    {
#line 151
    w = (wordstates )1;
#line 152
    tmp___8 = strlen((char const   *)buf);
#line 152
    tmp___9 = nalloc(tmp___8 + 1UL);
#line 152
    y->word.w = strcpy((char */* __restrict  */)((char *)tmp___9), (char const   */* __restrict  */)buf);
    }
#line 153
    if (saw_meta) {
      {
#line 156
      tmp___10 = strlen((char const   *)buf);
#line 156
      tmp___11 = nalloc(tmp___10 + 1UL);
#line 156
      y->word.m = (char *)tmp___11;
#line 157
      r = buf;
#line 157
      s___0 = y->word.m;
      }
      {
#line 157
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 157
        if (! ((int )*r != 0)) {
#line 157
          goto while_break___2;
        }
#line 158
        if ((int )*r == 63) {
#line 158
          tmp___12 = 1;
        } else
#line 158
        if ((int )*r == 91) {
#line 158
          tmp___12 = 1;
        } else
#line 158
        if ((int )*r == 42) {
#line 158
          tmp___12 = 1;
        } else {
#line 158
          tmp___12 = 0;
        }
#line 158
        *s___0 = (char )tmp___12;
#line 157
        r ++;
#line 157
        s___0 ++;
      }
      while_break___2: /* CIL Label */ ;
      }
    } else {
#line 160
      y->word.m = (char *)((void *)0);
    }
#line 162
    y->word.q = (bool )0;
#line 163
    return (279);
  }
#line 165
  if (c == 96) {
#line 165
    goto _L;
  } else
#line 165
  if (c == 33) {
#line 165
    goto _L;
  } else
#line 165
  if (c == 64) {
#line 165
    goto _L;
  } else
#line 165
  if (c == 126) {
#line 165
    goto _L;
  } else
#line 165
  if (c == 36) {
#line 165
    goto _L;
  } else
#line 165
  if (c == 39) {
    _L: /* CIL Label */ 
#line 166
    if ((unsigned int )w != 0U) {
      {
#line 166
      w = (wordstates )0;
#line 166
      ugchar(c);
      }
#line 166
      return ('^');
    }
#line 167
    if (c == 33) {
#line 168
      w = (wordstates )2;
    } else
#line 167
    if (c == 64) {
#line 168
      w = (wordstates )2;
    } else
#line 167
    if (c == 126) {
#line 168
      w = (wordstates )2;
    }
  }
  {
#line 171
  if (c == 33) {
#line 171
    goto case_33;
  }
#line 173
  if (c == 64) {
#line 173
    goto case_64;
  }
#line 175
  if (c == 126) {
#line 175
    goto case_126;
  }
#line 177
  if (c == 96) {
#line 177
    goto case_96;
  }
#line 183
  if (c == 36) {
#line 183
    goto case_36;
  }
#line 192
  if (c == 39) {
#line 192
    goto case_39;
  }
#line 214
  if (c == 92) {
#line 214
    goto case_92;
  }
#line 225
  if (c == 40) {
#line 225
    goto case_40;
  }
#line 230
  if (c == 35) {
#line 230
    goto case_35;
  }
#line 235
  if (c == 10) {
#line 235
    goto case_10;
  }
#line 243
  if (c == 125) {
#line 243
    goto case_125;
  }
#line 243
  if (c == 123) {
#line 243
    goto case_125;
  }
#line 243
  if (c == 61) {
#line 243
    goto case_125;
  }
#line 243
  if (c == 41) {
#line 243
    goto case_125;
  }
#line 243
  if (c == 94) {
#line 243
    goto case_125;
  }
#line 243
  if (c == 59) {
#line 243
    goto case_125;
  }
#line 246
  if (c == 38) {
#line 246
    goto case_38;
  }
#line 253
  if (c == 124) {
#line 253
    goto case_124;
  }
#line 270
  if (c == 62) {
#line 270
    goto case_62;
  }
#line 279
  if (c == 60) {
#line 279
    goto case_60;
  }
#line 309
  goto switch_default;
  case_33: /* CIL Label */ 
#line 172
  return (259);
  case_64: /* CIL Label */ 
#line 174
  return (275);
  case_126: /* CIL Label */ 
#line 176
  return (277);
  case_96: /* CIL Label */ 
  {
#line 178
  c = gchar();
  }
#line 179
  if (c == 96) {
#line 180
    return (258);
  }
  {
#line 181
  ugchar(c);
  }
#line 182
  return ('`');
  case_36: /* CIL Label */ 
  {
#line 184
  dollar = (bool )1;
#line 185
  c = gchar();
  }
#line 186
  if (c == 35) {
#line 187
    return (261);
  }
#line 188
  if (c == 94) {
#line 189
    return (265);
  }
  {
#line 190
  ugchar(c);
  }
#line 191
  return ('$');
  case_39: /* CIL Label */ 
#line 193
  w = (wordstates )1;
#line 194
  i = (size_t )0;
  {
#line 196
  while (1) {
    while_continue___3: /* CIL Label */ ;
    {
#line 196
    c = gchar();
    }
#line 196
    if (! (c != 39)) {
      {
#line 196
      c = gchar();
      }
#line 196
      if (! (c == 39)) {
#line 196
        goto while_break___3;
      }
    }
#line 197
    tmp___13 = i;
#line 197
    i ++;
#line 197
    *(buf + tmp___13) = (char )c;
#line 198
    if (c == 10) {
      {
#line 199
      print_prompt2();
      }
    }
#line 200
    if (c == -1) {
      {
#line 201
      w = (wordstates )0;
#line 202
      scanerror((char *)"eof in quoted string");
      }
#line 203
      return (280);
    }
#line 205
    if (i >= bufsize) {
      {
#line 206
      bufsize *= 2UL;
#line 206
      tmp___14 = erealloc((void *)buf, bufsize);
#line 206
      realbuf = (char *)tmp___14;
#line 206
      buf = realbuf;
      }
    }
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 208
  ugchar(c);
#line 209
  *(buf + i) = (char )'\000';
#line 210
  tmp___15 = strlen((char const   *)buf);
#line 210
  tmp___16 = nalloc(tmp___15 + 1UL);
#line 210
  y->word.w = strcpy((char */* __restrict  */)((char *)tmp___16), (char const   */* __restrict  */)buf);
#line 211
  y->word.m = (char *)((void *)0);
#line 212
  y->word.q = (bool )1;
  }
#line 213
  return (279);
  case_92: /* CIL Label */ 
  {
#line 215
  c = gchar();
  }
#line 215
  if (c == 10) {
    {
#line 216
    print_prompt2();
    }
#line 217
    goto top;
  }
  {
#line 219
  ugchar(c);
#line 220
  c = '\\';
  }
#line 221
  if ((unsigned int )w != 0U) {
    {
#line 221
    w = (wordstates )0;
#line 221
    ugchar(c);
    }
#line 221
    return ('^');
  }
  {
#line 222
  c = gchar();
#line 223
  i = (size_t )0;
  }
#line 224
  goto bs;
  case_40: /* CIL Label */ 
#line 226
  if ((unsigned int )w == 1U) {
#line 227
    c = 274;
  }
#line 228
  w = (wordstates )0;
#line 229
  return (c);
  case_35: /* CIL Label */ 
  {
#line 231
  while (1) {
    while_continue___4: /* CIL Label */ ;
    {
#line 231
    c = gchar();
    }
#line 231
    if (! (c != 10)) {
#line 231
      goto while_break___4;
    }
#line 232
    if (c == -1) {
#line 233
      return (264);
    }
  }
  while_break___4: /* CIL Label */ ;
  }
  case_10: /* CIL Label */ 
#line 236
  lineno ++;
#line 237
  newline = (bool )1;
  case_125: /* CIL Label */ 
  case_123: /* CIL Label */ 
  case_61: /* CIL Label */ 
  case_41: /* CIL Label */ 
  case_94: /* CIL Label */ 
  case_59: /* CIL Label */ 
#line 244
  w = (wordstates )0;
#line 245
  return (c);
  case_38: /* CIL Label */ 
  {
#line 247
  w = (wordstates )0;
#line 248
  c = gchar();
  }
#line 249
  if (c == 38) {
#line 250
    return (257);
  }
  {
#line 251
  ugchar(c);
  }
#line 252
  return ('&');
  case_124: /* CIL Label */ 
  {
#line 254
  w = (wordstates )0;
#line 255
  c = gchar();
  }
#line 256
  if (c == 124) {
#line 257
    return (270);
  }
  {
#line 258
  getpair(c);
  }
#line 259
  if (errset) {
#line 260
    return (280);
  }
#line 261
  tmp___17 = fd_left;
#line 261
  y->pipe.left = tmp___17;
#line 261
  if (tmp___17 == -9) {
#line 262
    y->pipe.left = 1;
  }
#line 263
  tmp___18 = fd_right;
#line 263
  y->pipe.right = tmp___18;
#line 263
  if (tmp___18 == -9) {
#line 264
    y->pipe.right = 0;
  }
#line 265
  if (y->pipe.right == -1) {
    {
#line 266
    scanerror((char *)"expected digit after \'=\'");
    }
#line 267
    return (280);
  }
#line 269
  return (271);
  case_62: /* CIL Label */ 
  {
#line 271
  c = gchar();
  }
#line 272
  if (c == 62) {
    {
#line 273
    c = gchar();
#line 274
    y->redir.type = (redirtype )2;
    }
  } else {
#line 276
    y->redir.type = (redirtype )1;
  }
#line 277
  y->redir.fd = 1;
#line 278
  goto common;
  case_60: /* CIL Label */ 
  {
#line 280
  c = gchar();
  }
#line 281
  if (c == 60) {
    {
#line 282
    c = gchar();
    }
#line 283
    if (c == 60) {
      {
#line 284
      c = gchar();
#line 285
      y->redir.type = (redirtype )4;
      }
    } else {
#line 287
      y->redir.type = (redirtype )3;
    }
  } else {
#line 290
    y->redir.type = (redirtype )0;
  }
#line 291
  y->redir.fd = 0;
  common: 
  {
#line 293
  w = (wordstates )0;
#line 294
  getpair(c);
  }
#line 295
  if (errset) {
#line 296
    return (280);
  }
#line 297
  if (fd_right == -9) {
#line 298
    if (fd_left != -9) {
#line 299
      y->redir.fd = fd_left;
#line 300
      return (273);
    }
#line 302
    if ((unsigned int )y->redir.type == 0U) {
#line 302
      tmp___19 = 272;
    } else
#line 302
    if ((unsigned int )y->redir.type == 1U) {
#line 302
      tmp___19 = 272;
    } else {
#line 302
      tmp___19 = 273;
    }
#line 302
    return (tmp___19);
  } else {
#line 304
    y->dup.type = y->redir.type;
#line 305
    y->dup.left = fd_left;
#line 306
    y->dup.right = fd_right;
#line 307
    return (262);
  }
  switch_default: /* CIL Label */ 
#line 310
  w = (wordstates )0;
#line 311
  return (c);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 315 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/lex.c"
extern void yyerror(char const   *s___0 ) 
{ 
  char *tok ;
  char const   *tmp ;

  {
#line 317
  if (prerror) {
#line 318
    prerror = (bool )0;
#line 319
    return;
  }
#line 321
  if (! interactive) {
#line 322
    if ((unsigned int )w != 0U) {
#line 323
      tok = realbuf;
    } else
#line 324
    if (lastchar == -1) {
#line 325
      tok = (char *)"eof";
    } else
#line 326
    if (lastchar == 10) {
#line 327
      tok = (char *)"end of line";
    } else {
#line 329
      if (lastchar < 32) {
#line 329
        tmp = "(decimal %d)";
      } else
#line 329
      if (lastchar > 126) {
#line 329
        tmp = "(decimal %d)";
      } else {
#line 329
        tmp = "\'%c\'";
      }
      {
#line 329
      tok = nprint(tmp, lastchar);
      }
    }
    {
#line 330
    fprint(2, "line %d: %s near %s\n", lineno - (lastchar == 10), s___0, tok);
    }
  } else {
    {
#line 332
    fprint(2, "%s\n", s___0);
    }
  }
#line 333
  return;
}
}
#line 335 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/lex.c"
extern void scanerror(char *s___0 ) 
{ 


  {
  {
#line 336
  flushu();
#line 337
  yyerror((char const   *)s___0);
#line 338
  prerror = (bool )1;
#line 338
  errset = prerror;
  }
#line 339
  return;
}
}
#line 341 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/lex.c"
extern void inityy(void) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
#line 342
  newline = (bool )0;
#line 343
  w = (wordstates )0;
#line 344
  hq = (Hq *)((void *)0);
#line 346
  if (bufsize > 8000UL) {
#line 346
    if ((unsigned long )realbuf != (unsigned long )((void *)0)) {
      {
#line 347
      efree((void *)realbuf);
#line 348
      bufsize = (size_t )1000;
#line 349
      tmp = ealloc(bufsize);
#line 349
      realbuf = (char *)tmp;
      }
    } else {
#line 346
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 350
  if ((unsigned long )realbuf == (unsigned long )((void *)0)) {
    {
#line 351
    tmp___0 = ealloc(bufsize);
#line 351
    realbuf = (char *)tmp___0;
    }
  }
#line 352
  return;
}
}
#line 362 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/lex.c"
static void getpair(int c ) 
{ 
  int n ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 364
  fd_right = -9;
#line 364
  fd_left = fd_right;
#line 365
  if (c != 91) {
    {
#line 366
    ugchar(c);
    }
#line 367
    return;
  }
  {
#line 369
  tmp = gchar();
#line 369
  n = tmp - 48;
  }
#line 369
  if ((unsigned int )n > 9U) {
    {
#line 370
    scanerror((char *)"expected digit after \'[\'");
    }
#line 371
    return;
  }
  {
#line 373
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 373
    tmp___0 = gchar();
#line 373
    c = tmp___0 - 48;
    }
#line 373
    if (! ((unsigned int )c <= 9U)) {
#line 373
      goto while_break;
    }
#line 374
    n = n * 10 + c;
  }
  while_break: /* CIL Label */ ;
  }
#line 375
  fd_left = n;
#line 376
  c += 48;
  {
#line 381
  if (c == 93) {
#line 381
    goto case_93;
  }
#line 383
  if (c == 61) {
#line 383
    goto case_61;
  }
#line 378
  goto switch_default;
  switch_default: /* CIL Label */ 
  {
#line 379
  scanerror((char *)"expected \'=\' or \']\' after digit");
  }
#line 380
  return;
  case_93: /* CIL Label */ 
#line 382
  return;
  case_61: /* CIL Label */ 
  {
#line 384
  tmp___2 = gchar();
#line 384
  n = tmp___2 - 48;
  }
#line 384
  if ((unsigned int )n > 9U) {
#line 385
    if (n != 45) {
      {
#line 386
      scanerror((char *)"expected digit or \']\' after \'=\'");
      }
#line 387
      return;
    }
#line 389
    fd_right = -1;
  } else {
    {
#line 391
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 391
      tmp___1 = gchar();
#line 391
      c = tmp___1 - 48;
      }
#line 391
      if (! ((unsigned int )c <= 9U)) {
#line 391
        goto while_break___0;
      }
#line 392
      n = n * 10 + c;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 393
    if (c != 45) {
      {
#line 394
      scanerror((char *)"expected \']\' after digit");
      }
#line 395
      return;
    }
#line 397
    fd_right = n;
  }
  switch_break: /* CIL Label */ ;
  }
#line 400
  return;
}
}
#line 236 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 69 "/usr/include/assert.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) __assert_fail)(char const   *__assertion ,
                                                                                                   char const   *__file ,
                                                                                                   unsigned int __line ,
                                                                                                   char const   *__function ) ;
#line 206 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/rc.h"
extern char **list2array(List *s___0 , bool print ) ;
#line 207
extern char *get_name(char *s___0 ) ;
#line 208
extern List *parse_var(char *extdef ) ;
#line 209
extern Node *parse_fn(char *extdef ) ;
#line 210
void initprint(void) ;
#line 271
extern Node *parseline(char *extdef ) ;
#line 297
extern int listnel(List *s___0 ) ;
#line 11 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/footobar.c"
static bool Fconv(Format *f , int ignore ) 
{ 
  unsigned char const   *s___0 ;
  unsigned char const   *tmp___0 ;
  int c ;
  char *tmp___1 ;
  unsigned char const   *tmp___2 ;

  {
  {
#line 12
  tmp___0 = __builtin_va_arg(f->args, unsigned char const   *);
#line 12
  s___0 = tmp___0;
  }
  {
#line 15
  while (1) {
    while_continue: /* CIL Label */ ;
#line 15
    tmp___2 = s___0;
#line 15
    s___0 ++;
#line 15
    c = (int )*tmp___2;
#line 15
    if (! (c != 0)) {
#line 15
      goto while_break;
    }
#line 16
    if (dnw[c]) {
      {
#line 17
      fmtprint(f, "__%02x", c);
      }
    } else
#line 16
    if (c == 42) {
      {
#line 17
      fmtprint(f, "__%02x", c);
      }
    } else
#line 16
    if (c == 95) {
#line 16
      if ((int const   )*s___0 == 95) {
        {
#line 17
        fmtprint(f, "__%02x", c);
        }
      } else {
#line 16
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 19
      if ((unsigned long )f->buf >= (unsigned long )f->bufend) {
        {
#line 19
        (*(f->grow))(f, (size_t )1);
        }
      }
#line 19
      tmp___1 = f->buf;
#line 19
      (f->buf) ++;
#line 19
      *tmp___1 = (char )c;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 20
  return ((bool )0);
}
}
#line 26 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/footobar.c"
static bool Dconv(Format *f , int ignore ) 
{ 
  char const   *name ;
  int n ;
  int tmp___0 ;

  {
  {
#line 27
  name = "?";
#line 28
  tmp___0 = __builtin_va_arg(f->args, int );
#line 28
  n = tmp___0;
  }
  {
#line 30
  if (n == 1) {
#line 30
    goto case_1;
  }
#line 31
  if (n == 2) {
#line 31
    goto case_2;
  }
#line 32
  if (n == 0) {
#line 32
    goto case_0;
  }
#line 33
  if (n == 3) {
#line 33
    goto case_3;
  }
#line 34
  if (n == 4) {
#line 34
    goto case_4;
  }
#line 29
  goto switch_break;
  case_1: /* CIL Label */ 
#line 30
  name = ">";
#line 30
  goto switch_break;
  case_2: /* CIL Label */ 
#line 31
  name = ">>";
#line 31
  goto switch_break;
  case_0: /* CIL Label */ 
#line 32
  name = "<";
#line 32
  goto switch_break;
  case_3: /* CIL Label */ 
#line 33
  name = "<<";
#line 33
  goto switch_break;
  case_4: /* CIL Label */ 
#line 34
  name = "<<<";
#line 34
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 36
  fmtcat(f, name);
  }
#line 37
  return ((bool )0);
}
}
#line 42 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/footobar.c"
static int defaultfd(int op ) 
{ 
  int tmp ;

  {
#line 43
  if (op == 1) {
#line 43
    tmp = 1;
  } else
#line 43
  if (op == 2) {
#line 43
    tmp = 1;
  } else {
#line 43
    tmp = 0;
  }
#line 43
  return (tmp);
}
}
#line 79 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/footobar.c"
static bool inlist  ;
#line 48 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/footobar.c"
static bool Tconv(Format *f , int ignore ) 
{ 
  bool dollar___0 ;
  Node *n ;
  Node *tmp___0 ;
  char const   *tmp___2 ;
  bool tmp___3 ;
  char *lp ;
  char *rp ;
  Node *n0 ;
  Node *n0___0 ;
  Node *n00 ;
  int tmp___4 ;
  Node *n0___1 ;
  int ofd ;
  int ifd ;
  int op ;
  int tmp___5 ;
  int op___0 ;
  int tmp___6 ;

  {
  {
#line 49
  dollar___0 = (bool )(f->flags & 64L);
#line 50
  tmp___0 = __builtin_va_arg(f->args, Node *);
#line 50
  n = tmp___0;
  }
#line 52
  if ((unsigned long )n == (unsigned long )((void *)0)) {
    {
#line 53
    fmtprint(f, "()");
    }
#line 54
    return ((bool )0);
  }
  {
#line 57
  if ((unsigned int )n->type == 3U) {
#line 57
    goto case_3;
  }
#line 58
  if ((unsigned int )n->type == 24U) {
#line 58
    goto case_24;
  }
#line 59
  if ((unsigned int )n->type == 6U) {
#line 59
    goto case_6;
  }
#line 60
  if ((unsigned int )n->type == 21U) {
#line 60
    goto case_21;
  }
#line 61
  if ((unsigned int )n->type == 23U) {
#line 61
    goto case_23;
  }
#line 62
  if ((unsigned int )n->type == 0U) {
#line 62
    goto case_0;
  }
#line 63
  if ((unsigned int )n->type == 1U) {
#line 63
    goto case_1;
  }
#line 64
  if ((unsigned int )n->type == 8U) {
#line 64
    goto case_8;
  }
#line 65
  if ((unsigned int )n->type == 10U) {
#line 65
    goto case_10;
  }
#line 66
  if ((unsigned int )n->type == 14U) {
#line 66
    goto case_14;
  }
#line 67
  if ((unsigned int )n->type == 16U) {
#line 67
    goto case_16;
  }
#line 68
  if ((unsigned int )n->type == 17U) {
#line 68
    goto case_17;
  }
#line 69
  if ((unsigned int )n->type == 22U) {
#line 69
    goto case_22;
  }
#line 70
  if ((unsigned int )n->type == 25U) {
#line 70
    goto case_25;
  }
#line 71
  if ((unsigned int )n->type == 26U) {
#line 71
    goto case_26;
  }
#line 72
  if ((unsigned int )n->type == 29U) {
#line 72
    goto case_29;
  }
#line 73
  if ((unsigned int )n->type == 15U) {
#line 73
    goto case_15;
  }
#line 74
  if ((unsigned int )n->type == 28U) {
#line 74
    goto case_28;
  }
#line 75
  if ((unsigned int )n->type == 30U) {
#line 75
    goto case_30;
  }
#line 78
  if ((unsigned int )n->type == 31U) {
#line 78
    goto case_31;
  }
#line 89
  if ((unsigned int )n->type == 27U) {
#line 89
    goto case_27;
  }
#line 89
  if ((unsigned int )n->type == 11U) {
#line 89
    goto case_27;
  }
#line 89
  if ((unsigned int )n->type == 9U) {
#line 89
    goto case_27;
  }
#line 104
  if ((unsigned int )n->type == 12U) {
#line 104
    goto case_12;
  }
#line 110
  if ((unsigned int )n->type == 2U) {
#line 110
    goto case_2;
  }
#line 121
  if ((unsigned int )n->type == 4U) {
#line 121
    goto case_4;
  }
#line 121
  if ((unsigned int )n->type == 5U) {
#line 121
    goto case_4;
  }
#line 132
  if ((unsigned int )n->type == 7U) {
#line 132
    goto case_7;
  }
#line 138
  if ((unsigned int )n->type == 19U) {
#line 138
    goto case_19;
  }
#line 138
  if ((unsigned int )n->type == 13U) {
#line 138
    goto case_19;
  }
#line 143
  if ((unsigned int )n->type == 18U) {
#line 143
    goto case_18;
  }
#line 153
  if ((unsigned int )n->type == 20U) {
#line 153
    goto case_20;
  }
#line 161
  if ((unsigned int )n->type == 32U) {
#line 161
    goto case_32;
  }
#line 56
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 57
  fmtprint(f, "!%T", n->u[0].p);
  }
#line 57
  goto switch_break;
  case_24: /* CIL Label */ 
  {
#line 58
  fmtprint(f, "case %T", n->u[0].p);
  }
#line 58
  goto switch_break;
  case_6: /* CIL Label */ 
  {
#line 59
  fmtprint(f, "%T&", n->u[0].p);
  }
#line 59
  goto switch_break;
  case_21: /* CIL Label */ 
  {
#line 60
  fmtprint(f, "fn %T", n->u[0].p);
  }
#line 60
  goto switch_break;
  case_23: /* CIL Label */ 
  {
#line 61
  fmtprint(f, "@ %T", n->u[0].p);
  }
#line 61
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 62
  fmtprint(f, "%T&&%T", n->u[0].p, n->u[1].p);
  }
#line 62
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 63
  fmtprint(f, "%T=%T", n->u[0].p, n->u[1].p);
  }
#line 63
  goto switch_break;
  case_8: /* CIL Label */ 
  {
#line 64
  fmtprint(f, "%T^%T", n->u[0].p, n->u[1].p);
  }
#line 64
  goto switch_break;
  case_10: /* CIL Label */ 
  {
#line 65
  fmtprint(f, "{%T}else %T", n->u[0].p, n->u[1].p);
  }
#line 65
  goto switch_break;
  case_14: /* CIL Label */ 
  {
#line 66
  fmtprint(f, "fn %T {%T}", n->u[0].p, n->u[1].p);
  }
#line 66
  goto switch_break;
  case_16: /* CIL Label */ 
  {
#line 67
  fmtprint(f, "if(%T)%T", n->u[0].p, n->u[1].p);
  }
#line 67
  goto switch_break;
  case_17: /* CIL Label */ 
  {
#line 68
  fmtprint(f, "%T||%T", n->u[0].p, n->u[1].p);
  }
#line 68
  goto switch_break;
  case_22: /* CIL Label */ 
  {
#line 69
  fmtprint(f, "%T %T", n->u[0].p, n->u[1].p);
  }
#line 69
  goto switch_break;
  case_25: /* CIL Label */ 
  {
#line 70
  fmtprint(f, "switch(%T){%T}", n->u[0].p, n->u[1].p);
  }
#line 70
  goto switch_break;
  case_26: /* CIL Label */ 
  {
#line 71
  fmtprint(f, "~ %T %T", n->u[0].p, n->u[1].p);
  }
#line 71
  goto switch_break;
  case_29: /* CIL Label */ 
  {
#line 72
  fmtprint(f, "while(%T)%T", n->u[0].p, n->u[1].p);
  }
#line 72
  goto switch_break;
  case_15: /* CIL Label */ 
  {
#line 73
  fmtprint(f, "for(%T in %T)%T", n->u[0].p, n->u[1].p, n->u[2].p);
  }
#line 73
  goto switch_break;
  case_28: /* CIL Label */ 
  {
#line 74
  fmtprint(f, "$%T(%T)", n->u[0].p, n->u[1].p);
  }
#line 74
  goto switch_break;
  case_30: /* CIL Label */ 
  {
#line 76
  tmp___3 = quotep(n->u[0].s, dollar___0);
  }
#line 76
  if (tmp___3) {
#line 76
    tmp___2 = "%#S";
  } else {
#line 76
    tmp___2 = "%S";
  }
  {
#line 76
  fmtprint(f, tmp___2, n->u[0].s);
  }
#line 77
  goto switch_break;
  case_31: /* CIL Label */ 
#line 80
  if (! inlist) {
    {
#line 81
    inlist = (bool )1;
#line 82
    fmtprint(f, "(%T %T)", n->u[0].p, n->u[1].p);
#line 83
    inlist = (bool )0;
    }
  } else {
    {
#line 85
    fmtprint(f, "%T %T", n->u[0].p, n->u[1].p);
    }
  }
#line 87
  goto switch_break;
  case_27: /* CIL Label */ 
  case_11: /* CIL Label */ 
  case_9: /* CIL Label */ 
#line 90
  lp = (char *)"";
#line 90
  rp = (char *)"";
#line 91
  n0 = n->u[0].p;
#line 93
  if ((unsigned int )n0->type != 30U) {
#line 94
    lp = (char *)"(";
#line 94
    rp = (char *)")";
  }
  {
#line 98
  if ((unsigned int )n->type == 9U) {
#line 98
    goto case_9___0;
  }
#line 99
  if ((unsigned int )n->type == 11U) {
#line 99
    goto case_11___0;
  }
#line 100
  if ((unsigned int )n->type == 27U) {
#line 100
    goto case_27___0;
  }
#line 97
  goto switch_default;
  switch_default: /* CIL Label */ 
  {
#line 97
  panic((char *)"this can\'t happen");
  }
#line 97
  goto switch_break___0;
  case_9___0: /* CIL Label */ 
  {
#line 98
  fmtprint(f, "$#%s%#T%s", lp, n0, rp);
  }
#line 98
  goto switch_break___0;
  case_11___0: /* CIL Label */ 
  {
#line 99
  fmtprint(f, "$^%s%#T%s", lp, n0, rp);
  }
#line 99
  goto switch_break___0;
  case_27___0: /* CIL Label */ 
  {
#line 100
  fmtprint(f, "$%s%#T%s", lp, n0, rp);
  }
#line 100
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
#line 102
  goto switch_break;
  case_12: /* CIL Label */ 
#line 105
  if (n->u[2].i != -1) {
    {
#line 106
    fmtprint(f, "%D[%d=%d]", n->u[0].i, n->u[1].i, n->u[2].i);
    }
  } else {
    {
#line 108
    fmtprint(f, "%D[%d=]", n->u[0].i, n->u[1].i);
    }
  }
#line 109
  goto switch_break;
  case_2: /* CIL Label */ 
#line 111
  n0___0 = n->u[0].p;
#line 112
  if ((unsigned long )n0___0 != (unsigned long )((void *)0)) {
#line 112
    if ((unsigned int )n0___0->type == 27U) {
#line 112
      n00 = n0___0->u[0].p;
#line 112
      if ((unsigned long )n00 != (unsigned long )((void *)0)) {
#line 112
        if ((unsigned int )n00->type == 30U) {
#line 112
          if ((int )*(n00->u[0].s) == (int )*"ifs") {
            {
#line 112
            tmp___4 = strcmp((char const   *)n00->u[0].s, "ifs");
            }
#line 112
            if (tmp___4 == 0) {
              {
#line 114
              fmtprint(f, "`");
              }
            } else {
              {
#line 116
              fmtprint(f, "``%T", n0___0);
              }
            }
          } else {
            {
#line 116
            fmtprint(f, "``%T", n0___0);
            }
          }
        } else {
          {
#line 116
          fmtprint(f, "``%T", n0___0);
          }
        }
      } else {
        {
#line 116
        fmtprint(f, "``%T", n0___0);
        }
      }
    } else {
      {
#line 116
      fmtprint(f, "``%T", n0___0);
      }
    }
  } else {
    {
#line 116
    fmtprint(f, "``%T", n0___0);
    }
  }
  {
#line 117
  fmtprint(f, "{%T}", n->u[1].p);
  }
#line 118
  goto switch_break;
  case_4: /* CIL Label */ 
  case_5: /* CIL Label */ 
#line 122
  n0___1 = n->u[0].p;
#line 123
  if ((unsigned long )n0___1 != (unsigned long )((void *)0)) {
    {
#line 124
    fmtprint(f, "%T", n->u[0].p);
    }
  }
#line 125
  if ((unsigned long )n->u[1].p != (unsigned long )((void *)0)) {
#line 126
    if ((unsigned long )n0___1 != (unsigned long )((void *)0)) {
#line 126
      if ((unsigned int )n0___1->type != 6U) {
        {
#line 127
        fmtprint(f, ";");
        }
      }
    }
    {
#line 128
    fmtprint(f, "%T", n->u[1].p);
    }
  }
#line 130
  goto switch_break;
  case_7: /* CIL Label */ 
  {
#line 133
  fmtprint(f, "{%T}", n->u[0].p);
  }
#line 134
  if ((unsigned long )n->u[1].p != (unsigned long )((void *)0)) {
    {
#line 135
    fmtprint(f, "%T", n->u[1].p);
    }
  }
#line 136
  goto switch_break;
  case_19: /* CIL Label */ 
  case_13: /* CIL Label */ 
  {
#line 139
  fmtprint(f, "%T", n->u[0].p);
  }
#line 140
  if ((unsigned long )n->u[1].p != (unsigned long )((void *)0)) {
    {
#line 141
    fmtprint(f, " %T", n->u[1].p);
    }
  }
#line 142
  goto switch_break;
  case_18: /* CIL Label */ 
  {
#line 144
  ofd = n->u[0].i;
#line 144
  ifd = n->u[1].i;
#line 145
  fmtprint(f, "%T|", n->u[2].p);
  }
#line 146
  if (ifd != 0) {
    {
#line 147
    fmtprint(f, "[%d=%d]", ofd, ifd);
    }
  } else
#line 148
  if (ofd != 1) {
    {
#line 149
    fmtprint(f, "[%d]", ofd);
    }
  }
  {
#line 150
  fmtprint(f, "%T", n->u[3].p);
  }
#line 151
  goto switch_break;
  case_20: /* CIL Label */ 
  {
#line 154
  op = n->u[0].i;
#line 155
  fmtprint(f, "%D", op);
#line 156
  tmp___5 = defaultfd(op);
  }
#line 156
  if (n->u[1].i != tmp___5) {
    {
#line 157
    fmtprint(f, "[%d]", n->u[1].i);
    }
  }
  {
#line 158
  fmtprint(f, "%T", n->u[2].p);
  }
#line 159
  goto switch_break;
  case_32: /* CIL Label */ 
  {
#line 162
  op___0 = n->u[0].i;
#line 163
  fmtprint(f, "%D", op___0);
#line 164
  tmp___6 = defaultfd(op___0);
  }
#line 164
  if (n->u[1].i != tmp___6) {
    {
#line 165
    fmtprint(f, "[%d]", n->u[1].i);
    }
  }
  {
#line 166
  fmtprint(f, "{%T}", n->u[2].p);
  }
#line 167
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 170
  return ((bool )0);
}
}
#line 175 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/footobar.c"
extern char **list2array(List *s___0 , bool print ) 
{ 
  char **argv ;
  char **av ;
  int tmp ;
  void *tmp___0 ;
  char **tmp___1 ;

  {
#line 178
  if (print) {
    {
#line 179
    fprint(2, "%L\n", s___0, " ");
    }
  }
  {
#line 184
  tmp = listnel(s___0);
#line 184
  tmp___0 = nalloc((unsigned long )(tmp + 4) * sizeof(*av));
#line 184
  av = (char **)tmp___0 + 3;
#line 184
  argv = av;
  }
  {
#line 185
  while (1) {
    while_continue: /* CIL Label */ ;
#line 185
    if (! ((unsigned long )s___0 != (unsigned long )((void *)0))) {
#line 185
      goto while_break;
    }
#line 186
    tmp___1 = av;
#line 186
    av ++;
#line 186
    *tmp___1 = s___0->w;
#line 187
    s___0 = s___0->n;
  }
  while_break: /* CIL Label */ ;
  }
#line 189
  *av = (char *)((void *)0);
#line 190
  return (argv);
}
}
#line 211 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/footobar.c"
static char const   hexchar[17]  = 
#line 211
  {      (char const   )'0',      (char const   )'1',      (char const   )'2',      (char const   )'3', 
        (char const   )'4',      (char const   )'5',      (char const   )'6',      (char const   )'7', 
        (char const   )'8',      (char const   )'9',      (char const   )'a',      (char const   )'b', 
        (char const   )'c',      (char const   )'d',      (char const   )'e',      (char const   )'f', 
        (char const   )'\000'};
#line 195 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/footobar.c"
extern char *get_name(char *s___0 ) 
{ 
  char *eq ;
  char *tmp ;
  char *r ;
  char *result ;
  int c ;
  void *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *h1 ;
  char *tmp___3 ;
  char *h2 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;

  {
  {
#line 196
  tmp = strchr((char const   *)s___0, '=');
#line 196
  eq = tmp;
  }
#line 200
  if ((unsigned long )eq == (unsigned long )((void *)0)) {
#line 201
    return ((char *)((void *)0));
  }
  {
#line 202
  tmp___0 = nalloc((size_t )((eq - s___0) + 1L));
#line 202
  result = (char *)tmp___0;
#line 202
  r = result;
  }
  {
#line 203
  while (1) {
    while_continue: /* CIL Label */ ;
#line 204
    tmp___1 = s___0;
#line 204
    s___0 ++;
#line 204
    c = (int )*tmp___1;
    {
#line 205
    if (c == 61) {
#line 205
      goto case_61;
    }
#line 209
    if (c == 95) {
#line 209
      goto case_95;
    }
#line 222
    goto switch_default;
    case_61: /* CIL Label */ 
#line 206
    tmp___2 = r;
#line 206
    r ++;
#line 206
    *tmp___2 = (char )'\000';
#line 207
    return (result);
    case_95: /* CIL Label */ 
#line 210
    if ((int )*s___0 == 95) {
      {
#line 212
      tmp___3 = strchr(hexchar, (int )*(s___0 + 1));
#line 212
      h1 = tmp___3;
#line 213
      tmp___4 = strchr(hexchar, (int )*(s___0 + 2));
#line 213
      h2 = tmp___4;
      }
#line 214
      if ((unsigned long )h1 != (unsigned long )((void *)0)) {
#line 214
        if ((unsigned long )h2 != (unsigned long )((void *)0)) {
#line 215
          tmp___5 = r;
#line 215
          r ++;
#line 215
          *tmp___5 = (char )(((h1 - (char *)(hexchar)) << 4) | (h2 - (char *)(hexchar)));
#line 216
          s___0 += 3;
#line 217
          goto switch_break;
        }
      }
    }
    switch_default: /* CIL Label */ 
#line 223
    tmp___6 = r;
#line 223
    r ++;
#line 223
    *tmp___6 = (char )c;
#line 224
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 232 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/footobar.c"
extern List *parse_var(char *extdef ) 
{ 
  char *begin ;
  char *end ;
  char *from ;
  char *to ;
  int len ;
  List *first ;
  List *last ;
  List *new ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 237
  last = (List *)((void *)0);
#line 237
  first = last;
#line 238
  begin = strchr((char const   *)extdef, '=');
  }
#line 239
  if (! begin) {
    {
#line 239
    __assert_fail("begin", "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/footobar.c",
                  239U, "parse_var");
    }
  }
  {
#line 240
  while (1) {
    while_continue: /* CIL Label */ ;
#line 240
    if (! *begin) {
#line 240
      goto while_break;
    }
#line 241
    begin ++;
#line 242
    end = begin;
#line 243
    len = 0;
    {
#line 244
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 244
      if ((int )*end != 1) {
#line 244
        if (! ((int )*end != 0)) {
#line 244
          goto while_break___0;
        }
      } else {
#line 244
        goto while_break___0;
      }
#line 245
      if ((int )*end == 2) {
#line 246
        end ++;
#line 247
        if ((int )*end != 1) {
#line 247
          if ((int )*end != 2) {
#line 247
            end --;
          }
        }
      }
#line 249
      end ++;
#line 249
      len ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 251
    tmp = ealloc(sizeof(List ));
#line 251
    new = (List *)tmp;
    }
#line 252
    if (last) {
#line 253
      last->n = new;
    } else {
#line 255
      first = new;
    }
    {
#line 256
    last = new;
#line 257
    tmp___0 = ealloc((size_t )(len + 1));
#line 257
    new->w = (char *)tmp___0;
#line 258
    new->m = (char *)((void *)0);
#line 259
    new->n = (List *)((void *)0);
#line 260
    to = new->w;
#line 261
    from = begin;
    }
    {
#line 261
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 261
      if (! ((unsigned long )from < (unsigned long )end)) {
#line 261
        goto while_break___1;
      }
#line 262
      if ((int )*from == 2) {
#line 263
        from ++;
#line 264
        if ((int )*from != 1) {
#line 264
          if ((int )*from != 2) {
#line 265
            from --;
          }
        }
      }
#line 267
      *to = *from;
#line 268
      to ++;
#line 261
      from ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 270
    *to = (char )'\000';
#line 271
    begin = end;
  }
  while_break: /* CIL Label */ ;
  }
#line 273
  return (first);
}
}
#line 280 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/footobar.c"
extern Node *parse_fn(char *extdef ) 
{ 
  Node *def ;
  char *s___0 ;
  char old[sizeof("fn x") - 1UL] ;
  Node *tmp ;

  {
  {
#line 283
  s___0 = strchr((char const   *)extdef, '=');
  }
#line 283
  if ((unsigned long )s___0 == (unsigned long )((void *)0)) {
#line 284
    return ((Node *)((void *)0));
  }
  {
#line 285
  s___0 -= (sizeof("fn x") - 1UL) - 1UL;
#line 285
  memcpy((void */* __restrict  */)(old), (void const   */* __restrict  */)s___0, sizeof("fn x") - 1UL);
#line 286
  memcpy((void */* __restrict  */)s___0, (void const   */* __restrict  */)"fn x",
         sizeof("fn x") - 1UL);
#line 287
  def = parseline(s___0);
#line 288
  memcpy((void */* __restrict  */)s___0, (void const   */* __restrict  */)(old), sizeof("fn x") - 1UL);
  }
#line 289
  if ((unsigned long )def == (unsigned long )((void *)0)) {
#line 289
    tmp = (Node *)((void *)0);
  } else
#line 289
  if ((unsigned int )def->type != 14U) {
#line 289
    tmp = (Node *)((void *)0);
  } else {
#line 289
    tmp = def->u[1].p;
  }
#line 289
  return (tmp);
}
}
#line 292 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/footobar.c"
static bool Aconv(Format *f , int ignore ) 
{ 
  char **a ;
  char **tmp___0 ;

  {
  {
#line 293
  tmp___0 = __builtin_va_arg(f->args, char **);
#line 293
  a = tmp___0;
  }
#line 294
  if ((unsigned long )*a != (unsigned long )((void *)0)) {
    {
#line 295
    fmtcat(f, (char const   *)*a);
    }
    {
#line 296
    while (1) {
      while_continue: /* CIL Label */ ;
#line 296
      a ++;
#line 296
      if (! ((unsigned long )*a != (unsigned long )((void *)0))) {
#line 296
        goto while_break;
      }
      {
#line 297
      fmtprint(f, " %s", *a);
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 299
  return ((bool )0);
}
}
#line 303 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/footobar.c"
static bool Lconv(Format *f , int ignore ) 
{ 
  bool plain ;
  char *sep ;
  List *l ;
  List *n ;
  List *tmp ;
  char *tmp___0 ;
  char const   *tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 308
  plain = (bool )(f->flags & 32L);
#line 309
  tmp = __builtin_va_arg(f->args, List *);
#line 309
  l = tmp;
#line 310
  tmp___0 = __builtin_va_arg(f->args, char *);
#line 310
  sep = tmp___0;
  }
#line 311
  if ((unsigned long )l == (unsigned long )((void *)0)) {
#line 311
    if ((f->flags & 32L) == 0L) {
      {
#line 312
      fmtprint(f, "()");
      }
    } else {
#line 311
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    {
#line 314
    while (1) {
      while_continue: /* CIL Label */ ;
#line 314
      if (! ((unsigned long )l != (unsigned long )((void *)0))) {
#line 314
        goto while_break;
      }
#line 315
      n = l->n;
#line 316
      if (plain) {
#line 316
        tmp___1 = "%s";
      } else {
#line 316
        tmp___1 = "%-S";
      }
      {
#line 316
      fmtprint(f, tmp___1, l->w);
      }
#line 317
      if ((unsigned long )n != (unsigned long )((void *)0)) {
#line 317
        if ((unsigned long )f->buf >= (unsigned long )f->bufend) {
          {
#line 317
          (*(f->grow))(f, (size_t )1);
          }
        }
#line 317
        tmp___2 = f->buf;
#line 317
        (f->buf) ++;
#line 317
        *tmp___2 = *sep;
      }
#line 314
      l = n;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 320
  return ((bool )0);
}
}
#line 324 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/footobar.c"
static bool Wconv(Format *f , int ignore ) 
{ 
  List *l ;
  List *n ;
  List *tmp ;
  char c ;
  char *s___0 ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 327
  tmp = __builtin_va_arg(f->args, List *);
#line 327
  l = tmp;
  }
  {
#line 328
  while (1) {
    while_continue: /* CIL Label */ ;
#line 328
    if (! ((unsigned long )l != (unsigned long )((void *)0))) {
#line 328
      goto while_break;
    }
#line 331
    s___0 = l->w;
    {
#line 331
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 331
      c = *s___0;
#line 331
      if (! ((int )c != 0)) {
#line 331
        goto while_break___0;
      }
#line 332
      if ((int )c == 1) {
#line 332
        goto _L;
      } else
#line 332
      if ((int )c == 2) {
        _L: /* CIL Label */ 
#line 333
        if ((unsigned long )f->buf >= (unsigned long )f->bufend) {
          {
#line 333
          (*(f->grow))(f, (size_t )1);
          }
        }
#line 333
        tmp___0 = f->buf;
#line 333
        (f->buf) ++;
#line 333
        *tmp___0 = (char )'\002';
      }
#line 334
      if ((unsigned long )f->buf >= (unsigned long )f->bufend) {
        {
#line 334
        (*(f->grow))(f, (size_t )1);
        }
      }
#line 334
      tmp___1 = f->buf;
#line 334
      (f->buf) ++;
#line 334
      *tmp___1 = c;
#line 331
      s___0 ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 336
    n = l->n;
#line 337
    if ((unsigned long )n != (unsigned long )((void *)0)) {
#line 337
      if ((unsigned long )f->buf >= (unsigned long )f->bufend) {
        {
#line 337
        (*(f->grow))(f, (size_t )1);
        }
      }
#line 337
      tmp___2 = f->buf;
#line 337
      (f->buf) ++;
#line 337
      *tmp___2 = (char )'\001';
    }
#line 328
    l = n;
  }
  while_break: /* CIL Label */ ;
  }
#line 339
  return ((bool )0);
}
}
#line 344 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/footobar.c"
static bool Sconv(Format *f , int ignore ) 
{ 
  int c ;
  unsigned char *s___0 ;
  unsigned char *tmp___0 ;
  unsigned char *t ;
  bool quoted ;
  bool metaquote ;
  unsigned char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  unsigned char *tmp___5 ;
  char *tmp___6 ;

  {
  {
#line 346
  tmp___0 = __builtin_va_arg(f->args, unsigned char *);
#line 346
  s___0 = tmp___0;
#line 346
  t = s___0;
#line 347
  quoted = (bool )((f->flags & 64L) != 0L);
#line 348
  metaquote = (bool )((f->flags & 32L) != 0L);
  }
#line 349
  if ((int )*s___0 == 0) {
    {
#line 350
    fmtprint(f, "\'\'");
    }
#line 351
    return ((bool )0);
  }
#line 353
  if (! quoted) {
    {
#line 354
    while (1) {
      while_continue: /* CIL Label */ ;
#line 354
      tmp___1 = t;
#line 354
      t ++;
#line 354
      c = (int )*tmp___1;
#line 354
      if (! (c != 0)) {
#line 354
        goto while_break;
      }
#line 355
      if ((int const   )nw[c] == 1) {
#line 356
        goto quoteit;
      } else
#line 355
      if (metaquote) {
#line 355
        if (c == 42) {
#line 356
          goto quoteit;
        } else
#line 355
        if (c == 63) {
#line 356
          goto quoteit;
        } else
#line 355
        if (c == 91) {
#line 356
          goto quoteit;
        }
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 357
    fmtprint(f, "%s", s___0);
    }
#line 358
    return ((bool )0);
  }
  quoteit: 
#line 361
  if ((unsigned long )f->buf >= (unsigned long )f->bufend) {
    {
#line 361
    (*(f->grow))(f, (size_t )1);
    }
  }
#line 361
  tmp___2 = f->buf;
#line 361
  (f->buf) ++;
#line 361
  *tmp___2 = (char )'\'';
  {
#line 362
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 362
    tmp___5 = s___0;
#line 362
    s___0 ++;
#line 362
    c = (int )*tmp___5;
#line 362
    if (! (c != 0)) {
#line 362
      goto while_break___0;
    }
#line 363
    if ((unsigned long )f->buf >= (unsigned long )f->bufend) {
      {
#line 363
      (*(f->grow))(f, (size_t )1);
      }
    }
#line 363
    tmp___3 = f->buf;
#line 363
    (f->buf) ++;
#line 363
    *tmp___3 = (char )c;
#line 364
    if (c == 39) {
#line 365
      if ((unsigned long )f->buf >= (unsigned long )f->bufend) {
        {
#line 365
        (*(f->grow))(f, (size_t )1);
        }
      }
#line 365
      tmp___4 = f->buf;
#line 365
      (f->buf) ++;
#line 365
      *tmp___4 = (char )'\'';
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 368
  if ((unsigned long )f->buf >= (unsigned long )f->bufend) {
    {
#line 368
    (*(f->grow))(f, (size_t )1);
    }
  }
#line 368
  tmp___6 = f->buf;
#line 368
  (f->buf) ++;
#line 368
  *tmp___6 = (char )'\'';
#line 369
  return ((bool )0);
}
}
#line 372 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/footobar.c"
void initprint(void) 
{ 


  {
  {
#line 373
  fmtinstall('A', & Aconv);
#line 374
  fmtinstall('L', & Lconv);
#line 375
  fmtinstall('S', & Sconv);
#line 376
  fmtinstall('T', & Tconv);
#line 377
  fmtinstall('D', & Dconv);
#line 378
  fmtinstall('W', & Wconv);
#line 380
  fmtinstall('F', & Fconv);
  }
#line 384
  return;
}
}
#line 366 "/usr/include/unistd.h"
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 3 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/system.c"
extern void writeall(int fd , char *buf , size_t remain ) 
{ 
  int i ;
  ssize_t tmp ;

  {
#line 6
  i = 0;
  {
#line 6
  while (1) {
    while_continue: /* CIL Label */ ;
#line 6
    if (! (remain > 0UL)) {
#line 6
      goto while_break;
    }
    {
#line 7
    tmp = write(fd, (void const   *)buf, remain);
#line 7
    i = (int )tmp;
    }
#line 7
    if (i <= 0) {
#line 8
      goto while_break;
    }
#line 6
    buf += i;
#line 6
    remain -= (size_t )i;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 9
  sigchk();
  }
#line 10
  return;
}
}
#line 353 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 417
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) pipe)(int *__pipedes ) ;
#line 534
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) dup2)(int __fd ,
                                                                           int __fd2 ) ;
#line 174 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/rc.h"
Rq *redirq ;
#line 192
extern void rc_error(char *s___0 ) ;
#line 221
extern List *glob(List *s___0 ) ;
#line 227
extern List *flatten(List *s___0 ) ;
#line 228
extern List *glom(Node *n ) ;
#line 254
extern void setsigdefaults(bool sysvbackground ) ;
#line 312
extern int rc_open(char const   *name , redirtype m ) ;
#line 381
extern void doredirs(void) ;
#line 428
extern int mvfd(int i , int j ) ;
#line 436
extern void uerror(char *s___0 ) ;
#line 439
extern pid_t rc_fork(void) ;
#line 16 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/redir.c"
extern void doredirs(void) 
{ 
  List *fname ;
  int fd ;
  int p[2] ;
  Rq *r ;
  List *tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  pid_t tmp___3 ;
  List *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 20
  r = redirq;
  {
#line 20
  while (1) {
    while_continue: /* CIL Label */ ;
#line 20
    if (! ((unsigned long )r != (unsigned long )((void *)0))) {
#line 20
      goto while_break;
    }
    {
#line 25
    if ((unsigned int )(r->r)->type == 20U) {
#line 25
      goto case_20;
    }
#line 65
    if ((unsigned int )(r->r)->type == 12U) {
#line 65
      goto case_12;
    }
#line 22
    goto switch_default;
    switch_default: /* CIL Label */ 
    {
#line 23
    panic((char *)"unexpected node in doredirs");
    }
    case_20: /* CIL Label */ 
#line 26
    if ((r->r)->u[0].i == 4) {
      {
#line 27
      tmp = glom((r->r)->u[2].p);
#line 27
      fname = flatten(tmp);
#line 28
      tmp___0 = pipe((int *)(p));
      }
#line 28
      if (tmp___0 < 0) {
        {
#line 29
        uerror((char *)"pipe");
#line 30
        rc_error((char *)((void *)0));
        }
      }
      {
#line 32
      tmp___3 = rc_fork();
      }
#line 32
      if (tmp___3 == 0) {
        {
#line 33
        setsigdefaults((bool )0);
#line 34
        close(p[0]);
        }
#line 35
        if ((unsigned long )fname != (unsigned long )((void *)0)) {
          {
#line 36
          tmp___1 = strlen((char const   *)fname->w);
#line 36
          writeall(p[1], fname->w, tmp___1);
          }
        }
        {
#line 37
        exit(0);
        }
      } else {
        {
#line 39
        close(p[1]);
#line 40
        tmp___2 = mvfd(p[0], (r->r)->u[1].i);
        }
#line 40
        if (tmp___2 < 0) {
          {
#line 41
          rc_error((char *)((void *)0));
          }
        }
      }
    } else {
      {
#line 44
      tmp___4 = glom((r->r)->u[2].p);
#line 44
      fname = glob(tmp___4);
      }
#line 45
      if ((unsigned long )fname == (unsigned long )((void *)0)) {
        {
#line 46
        rc_error((char *)"null filename in redirection");
        }
      }
#line 47
      if ((unsigned long )fname->n != (unsigned long )((void *)0)) {
        {
#line 48
        rc_error((char *)"multi-word filename in redirection");
        }
      }
      {
#line 53
      if ((r->r)->u[0].i == 0) {
#line 53
        goto case_0;
      }
#line 53
      if ((r->r)->u[0].i == 2) {
#line 53
        goto case_0;
      }
#line 53
      if ((r->r)->u[0].i == 1) {
#line 53
        goto case_0;
      }
#line 50
      goto switch_default___0;
      switch_default___0: /* CIL Label */ 
      {
#line 51
      panic((char *)"unexpected node in doredirs");
      }
      case_0: /* CIL Label */ 
      case_2: /* CIL Label */ 
      case_1: /* CIL Label */ 
      {
#line 54
      fd = rc_open((char const   *)fname->w, (redirtype )(r->r)->u[0].i);
      }
#line 55
      goto switch_break___0;
      switch_break___0: /* CIL Label */ ;
      }
#line 57
      if (fd < 0) {
        {
#line 58
        uerror(fname->w);
#line 59
        rc_error((char *)((void *)0));
        }
      }
      {
#line 61
      tmp___5 = mvfd(fd, (r->r)->u[1].i);
      }
#line 61
      if (tmp___5 < 0) {
        {
#line 62
        rc_error((char *)((void *)0));
        }
      }
    }
#line 64
    goto switch_break;
    case_12: /* CIL Label */ 
#line 66
    if ((r->r)->u[2].i == -1) {
      {
#line 67
      close((r->r)->u[1].i);
      }
    } else
#line 68
    if ((r->r)->u[2].i != (r->r)->u[1].i) {
      {
#line 69
      tmp___6 = dup2((r->r)->u[2].i, (r->r)->u[1].i);
      }
#line 69
      if (tmp___6 < 0) {
        {
#line 70
        uerror((char *)"dup2");
#line 71
        rc_error((char *)((void *)0));
        }
      }
    }
    switch_break: /* CIL Label */ ;
    }
#line 20
    r = r->n;
  }
  while_break: /* CIL Label */ ;
  }
#line 76
  redirq = (Rq *)((void *)0);
#line 77
  return;
}
}
#line 395 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/rc.h"
extern void set(bool code ) ;
#line 396
extern void setstatus(pid_t pid , int i ) ;
#line 440
extern pid_t rc_wait4(pid_t pid , int *stat___0 , bool nointr ) ;
#line 441
extern List *sgetapids(void) ;
#line 442
extern void waitforall(void) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 7 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/wait.c"
bool forked  =    (bool )0;
#line 11 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/wait.c"
static struct Pid *plist  =    (struct Pid *)((void *)0);
#line 18 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/wait.c"
extern pid_t rc_fork(void) 
{ 
  Pid *new ;
  struct Pid *p ;
  struct Pid *q ;
  pid_t pid ;
  __pid_t tmp ;
  void *tmp___0 ;

  {
  {
#line 21
  tmp = fork();
#line 21
  pid = tmp;
  }
  {
#line 24
  if (pid == -1) {
#line 24
    goto case_neg_1;
  }
#line 28
  if (pid == 0) {
#line 28
    goto case_0;
  }
#line 40
  goto switch_default;
  case_neg_1: /* CIL Label */ 
  {
#line 25
  uerror((char *)"fork");
#line 26
  rc_error((char *)((void *)0));
  }
  case_0: /* CIL Label */ 
  {
#line 29
  forked = (bool )1;
#line 30
  sigchk();
#line 31
  p = plist;
#line 31
  q = (struct Pid *)0;
  }
  {
#line 32
  while (1) {
    while_continue: /* CIL Label */ ;
#line 32
    if (! p) {
#line 32
      goto while_break;
    }
#line 33
    if (q) {
      {
#line 33
      efree((void *)q);
      }
    }
#line 34
    q = p;
#line 35
    p = p->n;
  }
  while_break: /* CIL Label */ ;
  }
#line 37
  if (q) {
    {
#line 37
    efree((void *)q);
    }
  }
#line 38
  plist = (struct Pid *)0;
#line 39
  return (0);
  switch_default: /* CIL Label */ 
  {
#line 41
  tmp___0 = ealloc(sizeof(Pid ));
#line 41
  new = (Pid *)tmp___0;
#line 42
  new->pid = pid;
#line 43
  new->alive = (bool )1;
#line 44
  new->n = plist;
#line 45
  plist = new;
  }
#line 46
  return (pid);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 50 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/wait.c"
extern pid_t rc_wait4(pid_t pid , int *stat___0 , bool nointr ) 
{ 
  Pid *r ;
  Pid *prev ;
  int *tmp ;
  int ret ;
  Pid *q ;
  int *tmp___0 ;

  {
#line 54
  r = plist;
#line 54
  prev = (Pid *)((void *)0);
  {
#line 54
  while (1) {
    while_continue: /* CIL Label */ ;
#line 54
    if (! ((unsigned long )r != (unsigned long )((void *)0))) {
#line 54
      goto while_break;
    }
#line 55
    if (r->pid == pid) {
#line 56
      goto while_break;
    }
#line 54
    prev = r;
#line 54
    r = r->n;
  }
  while_break: /* CIL Label */ ;
  }
#line 59
  if ((unsigned long )r == (unsigned long )((void *)0)) {
    {
#line 60
    tmp = __errno_location();
#line 60
    *tmp = 10;
#line 61
    uerror((char *)"wait");
#line 62
    *stat___0 = 256;
    }
#line 63
    return (-1);
  }
  {
#line 67
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 67
    if (! r->alive) {
#line 67
      goto while_break___0;
    }
    {
#line 71
    ret = wait((union wait *)stat___0);
    }
#line 73
    if (ret < 0) {
      {
#line 74
      tmp___0 = __errno_location();
      }
#line 74
      if (*tmp___0 == 10) {
        {
#line 75
        panic((char *)"lost child");
        }
      }
#line 76
      if (nointr) {
#line 77
        goto while_continue___0;
      } else {
#line 79
        return (ret);
      }
    }
#line 82
    q = plist;
    {
#line 82
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 82
      if (! ((unsigned long )q != (unsigned long )((void *)0))) {
#line 82
        goto while_break___1;
      }
#line 83
      if (q->pid == ret) {
#line 84
        q->alive = (bool )0;
#line 85
        q->stat = *stat___0;
#line 86
        goto while_break___1;
      }
#line 82
      q = q->n;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 89
  *stat___0 = r->stat;
#line 90
  if ((unsigned long )prev == (unsigned long )((void *)0)) {
#line 91
    plist = r->n;
  } else {
#line 93
    prev->n = r->n;
  }
  {
#line 94
  efree((void *)r);
  }
#line 95
  return (pid);
}
}
#line 98 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/wait.c"
extern List *sgetapids(void) 
{ 
  List *r ;
  Pid *p ;
  List *q ;
  void *tmp ;

  {
#line 101
  r = (List *)((void *)0);
#line 101
  p = plist;
  {
#line 101
  while (1) {
    while_continue: /* CIL Label */ ;
#line 101
    if (! ((unsigned long )p != (unsigned long )((void *)0))) {
#line 101
      goto while_break;
    }
#line 103
    if (! p->alive) {
#line 104
      goto __Cont;
    }
    {
#line 105
    tmp = nalloc(sizeof(List ));
#line 105
    q = (List *)tmp;
#line 106
    q->w = nprint("%d", p->pid);
#line 107
    q->m = (char *)((void *)0);
#line 108
    q->n = r;
#line 109
    r = q;
    }
    __Cont: /* CIL Label */ 
#line 101
    p = p->n;
  }
  while_break: /* CIL Label */ ;
  }
#line 111
  return (r);
}
}
#line 114 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/wait.c"
extern void waitforall(void) 
{ 
  int stat___0 ;
  pid_t pid ;
  pid_t tmp ;
  int *tmp___0 ;

  {
  {
#line 117
  while (1) {
    while_continue: /* CIL Label */ ;
#line 117
    if (! ((unsigned long )plist != (unsigned long )((void *)0))) {
#line 117
      goto while_break;
    }
    {
#line 118
    tmp = rc_wait4(plist->pid, & stat___0, (bool )0);
#line 118
    pid = tmp;
    }
#line 119
    if (pid > 0) {
      {
#line 120
      setstatus(pid, stat___0);
      }
    } else {
      {
#line 122
      set((bool )0);
#line 123
      tmp___0 = __errno_location();
      }
#line 123
      if (*tmp___0 == 4) {
#line 124
        return;
      }
    }
    {
#line 126
    sigchk();
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 128
  return;
}
}
#line 234 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/rc.h"
Htab *vp ;
#line 235
extern void *lookup(char *s___0 , Htab *ht ) ;
#line 237
extern List *varlookup(char *name ) ;
#line 239
extern Variable *get_var_place(char *s___0 , bool stack ) ;
#line 240
extern bool varassign_string(char *extdef ) ;
#line 243
extern char *varlookup_string(char *name ) ;
#line 244
extern void alias(char *name , List *s___0 , bool stack ) ;
#line 245
extern void starassign(char *dollarzero , char **a , bool stack ) ;
#line 247
extern void delete_var(char *s___0 , bool stack ) ;
#line 253
void set_exportable(char *s___0 , bool b ) ;
#line 256
extern void varassign(char *name , List *def , bool stack ) ;
#line 257
extern void varrm(char *name , bool stack ) ;
#line 260
extern void prettyprint_var(int fd , char *name , List *s___0 ) ;
#line 295
extern List *listcpy(List *s___0 , void *(*alloc)(size_t  ) ) ;
#line 397
extern List *sgetstatus(void) ;
#line 427
extern int n2u(char *s___0 , unsigned int base ) ;
#line 5 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/var.c"
static void colonassign(char *name , List *def , bool stack ) ;
#line 6
static void listassign(char *name , List *def , bool stack ) ;
#line 7
static int hasalias(char *name ) ;
#line 9 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/var.c"
static char * const  aliases[6]  = {      (char */* const  */)"home",      (char */* const  */)"HOME",      (char */* const  */)"path",      (char */* const  */)"PATH", 
        (char */* const  */)"cdpath",      (char */* const  */)"CDPATH"};
#line 15 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/var.c"
extern void varassign(char *name , List *def , bool stack ) 
{ 
  Variable *new ;
  List *newdef ;
  List *tmp ;

  {
  {
#line 17
  tmp = listcpy(def, & ealloc);
#line 17
  newdef = tmp;
#line 18
  new = get_var_place(name, stack);
#line 19
  new->def = newdef;
#line 20
  new->extdef = (char *)((void *)0);
#line 21
  set_exportable(name, (bool )1);
  }
#line 26
  return;
}
}
#line 31 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/var.c"
static bool aliasset[6]  = {      (bool )0,      (bool )0,      (bool )0,      (bool )0, 
        (bool )0,      (bool )0};
#line 30 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/var.c"
extern bool varassign_string(char *extdef ) 
{ 
  char *name ;
  char *tmp ;
  Variable *new ;
  int i ;
  size_t tmp___0 ;
  void *tmp___1 ;
  List *tmp___2 ;

  {
  {
#line 34
  tmp = get_name(extdef);
#line 34
  name = tmp;
  }
#line 37
  if ((unsigned long )name == (unsigned long )((void *)0)) {
#line 38
    return ((bool )0);
  }
  {
#line 39
  i = hasalias(name);
  }
#line 39
  if (i != -1) {
#line 40
    aliasset[i] = (bool )1;
#line 41
    i ^= 1;
#line 42
    if (i & 1) {
#line 42
      if (aliasset[i]) {
#line 43
        return ((bool )1);
      }
    }
  }
  {
#line 45
  new = get_var_place(name, (bool )0);
#line 46
  new->def = (List *)((void *)0);
#line 47
  tmp___0 = strlen((char const   *)extdef);
#line 47
  tmp___1 = ealloc(tmp___0 + 1UL);
#line 47
  new->extdef = (char *)tmp___1;
#line 48
  strcpy((char */* __restrict  */)new->extdef, (char const   */* __restrict  */)extdef);
  }
#line 49
  if (i != -1) {
    {
#line 50
    tmp___2 = varlookup(name);
#line 50
    alias(name, tmp___2, (bool )0);
    }
  }
  {
#line 51
  set_exportable(name, (bool )1);
  }
#line 52
  return ((bool )1);
}
}
#line 62 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/var.c"
extern List *varlookup(char *name ) 
{ 
  Variable *look ;
  List *ret ;
  List *l ;
  int sub ;
  List *tmp ;
  int tmp___0 ;
  List *tmp___1 ;
  int tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  List *tmp___5 ;

  {
#line 66
  if ((int )*name == (int )*"apids") {
    {
#line 66
    tmp___0 = strcmp((char const   *)name, "apids");
    }
#line 66
    if (tmp___0 == 0) {
      {
#line 67
      tmp = sgetapids();
      }
#line 67
      return (tmp);
    }
  }
#line 68
  if ((int )*name == (int )*"status") {
    {
#line 68
    tmp___2 = strcmp((char const   *)name, "status");
    }
#line 68
    if (tmp___2 == 0) {
      {
#line 69
      tmp___1 = sgetstatus();
      }
#line 69
      return (tmp___1);
    }
  }
#line 70
  if ((int )*name != 0) {
    {
#line 70
    sub = n2u(name, 10U);
    }
#line 70
    if (sub != -1) {
      {
#line 71
      l = varlookup((char *)"*");
      }
      {
#line 71
      while (1) {
        while_continue: /* CIL Label */ ;
#line 71
        if ((unsigned long )l != (unsigned long )((void *)0)) {
#line 71
          if (! (sub != 0)) {
#line 71
            goto while_break;
          }
        } else {
#line 71
          goto while_break;
        }
#line 72
        l = l->n;
#line 71
        sub --;
      }
      while_break: /* CIL Label */ ;
      }
#line 73
      if ((unsigned long )l == (unsigned long )((void *)0)) {
#line 74
        return ((List *)((void *)0));
      }
      {
#line 75
      tmp___3 = nalloc(sizeof(List ));
#line 75
      ret = (List *)tmp___3;
#line 76
      ret->w = l->w;
#line 77
      ret->m = (char *)((void *)0);
#line 78
      ret->n = (List *)((void *)0);
      }
#line 79
      return (ret);
    }
  }
  {
#line 81
  tmp___4 = lookup(name, vp);
#line 81
  look = (Variable *)tmp___4;
  }
#line 82
  if ((unsigned long )look == (unsigned long )((void *)0)) {
#line 83
    return ((List *)((void *)0));
  }
#line 84
  if ((unsigned long )look->def != (unsigned long )((void *)0)) {
#line 85
    return (look->def);
  }
#line 86
  if ((unsigned long )look->extdef == (unsigned long )((void *)0)) {
#line 87
    return ((List *)((void *)0));
  }
  {
#line 88
  ret = parse_var(look->extdef);
  }
#line 89
  if ((unsigned long )ret == (unsigned long )((void *)0)) {
#line 90
    look->extdef = (char *)((void *)0);
#line 91
    return ((List *)((void *)0));
  }
#line 93
  tmp___5 = ret;
#line 93
  look->def = tmp___5;
#line 93
  return (tmp___5);
}
}
#line 98 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/var.c"
extern char *varlookup_string(char *name ) 
{ 
  Variable *look ;
  void *tmp ;
  char *tmp___0 ;

  {
  {
#line 100
  tmp = lookup(name, vp);
#line 100
  look = (Variable *)tmp;
  }
#line 101
  if ((unsigned long )look == (unsigned long )((void *)0)) {
#line 102
    return ((char *)((void *)0));
  }
#line 103
  if ((unsigned long )look->extdef != (unsigned long )((void *)0)) {
#line 104
    return (look->extdef);
  }
#line 105
  if ((unsigned long )look->def == (unsigned long )((void *)0)) {
#line 106
    return ((char *)((void *)0));
  }
  {
#line 107
  tmp___0 = mprint("%F=%W", name, look->def);
#line 107
  look->extdef = tmp___0;
  }
#line 107
  return (tmp___0);
}
}
#line 112 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/var.c"
extern void varrm(char *name , bool stack ) 
{ 
  int i ;
  int tmp ;
  List *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 113
  tmp = hasalias(name);
#line 113
  i = tmp;
  }
#line 114
  if ((int )*name == (int )*"*") {
    {
#line 114
    tmp___1 = strcmp((char const   *)name, "*");
    }
#line 114
    if (tmp___1 == 0) {
#line 114
      if (! stack) {
        {
#line 115
        tmp___0 = varlookup((char *)"0");
#line 115
        varassign((char *)"*", tmp___0, (bool )0);
        }
#line 116
        return;
      }
    }
  }
  {
#line 118
  delete_var(name, stack);
  }
#line 119
  if (i != -1) {
    {
#line 120
    delete_var((char *)aliases[i ^ 1], stack);
    }
  }
#line 121
  return;
}
}
#line 125 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/var.c"
extern void starassign(char *dollarzero , char **a , bool stack ) 
{ 
  List *s___0 ;
  List *var ;
  void *tmp ;
  void *tmp___0 ;
  char **tmp___1 ;
  List *tmp___2 ;
  void *tmp___3 ;

  {
  {
#line 127
  tmp = nalloc(sizeof(List ));
#line 127
  var = (List *)tmp;
#line 128
  var->w = dollarzero;
  }
#line 129
  if ((unsigned long )*a == (unsigned long )((void *)0)) {
    {
#line 130
    var->n = (List *)((void *)0);
#line 131
    varassign((char *)"*", var, stack);
    }
#line 132
    return;
  }
  {
#line 134
  tmp___0 = nalloc(sizeof(List ));
#line 134
  s___0 = (List *)tmp___0;
#line 134
  var->n = s___0;
  }
  {
#line 135
  while (1) {
    while_continue: /* CIL Label */ ;
#line 136
    tmp___1 = a;
#line 136
    a ++;
#line 136
    s___0->w = *tmp___1;
#line 137
    if ((unsigned long )*a == (unsigned long )((void *)0)) {
#line 138
      s___0->n = (List *)((void *)0);
#line 139
      goto while_break;
    } else {
      {
#line 141
      tmp___3 = nalloc(sizeof(List ));
#line 141
      tmp___2 = (List *)tmp___3;
#line 141
      s___0->n = tmp___2;
#line 141
      s___0 = tmp___2;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 143
  varassign((char *)"*", var, stack);
  }
#line 144
  return;
}
}
#line 148 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/var.c"
static void colonassign(char *name , List *def , bool stack ) 
{ 
  List dud ;

  {
#line 150
  if ((unsigned long )def == (unsigned long )((void *)0)) {
    {
#line 151
    varassign(name, (List *)((void *)0), stack);
    }
#line 152
    return;
  }
  {
#line 154
  dud.w = nprint("%-L", def, ":");
#line 155
  dud.n = (List *)((void *)0);
#line 156
  varassign(name, & dud, stack);
  }
#line 157
  return;
}
}
#line 161 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/var.c"
static void listassign(char *name , List *def , bool stack ) 
{ 
  List *val ;
  List *r ;
  char *v ;
  char *w___0 ;
  void *tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  List *tmp___2 ;
  void *tmp___3 ;
  size_t tmp___4 ;
  void *tmp___5 ;

  {
#line 164
  if ((unsigned long )def == (unsigned long )((void *)0)) {
    {
#line 165
    varassign(name, (List *)((void *)0), stack);
    }
#line 166
    return;
  }
  {
#line 168
  v = def->w;
#line 169
  tmp = nalloc(sizeof(List ));
#line 169
  val = (List *)tmp;
#line 169
  r = val;
  }
  {
#line 170
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 170
    w___0 = strchr((char const   *)v, ':');
    }
#line 170
    if (! ((unsigned long )w___0 != (unsigned long )((void *)0))) {
#line 170
      goto while_break;
    }
    {
#line 171
    *w___0 = (char )'\000';
#line 172
    tmp___0 = strlen((char const   *)v);
#line 172
    tmp___1 = nalloc(tmp___0 + 1UL);
#line 172
    r->w = strcpy((char */* __restrict  */)((char *)tmp___1), (char const   */* __restrict  */)v);
#line 173
    *w___0 = (char )':';
#line 174
    v = w___0 + 1;
#line 175
    tmp___3 = nalloc(sizeof(List ));
#line 175
    tmp___2 = (List *)tmp___3;
#line 175
    r->n = tmp___2;
#line 175
    r = tmp___2;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 177
  tmp___4 = strlen((char const   *)v);
#line 177
  tmp___5 = nalloc(tmp___4 + 1UL);
#line 177
  r->w = strcpy((char */* __restrict  */)((char *)tmp___5), (char const   */* __restrict  */)v);
#line 178
  r->n = (List *)((void *)0);
#line 179
  varassign(name, val, stack);
  }
#line 180
  return;
}
}
#line 184 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/var.c"
static int hasalias(char *name ) 
{ 
  int i ;
  int tmp ;

  {
#line 186
  i = 0;
  {
#line 186
  while (1) {
    while_continue: /* CIL Label */ ;
#line 186
    if (! (i < (int )(sizeof(aliases) / sizeof(aliases[0])))) {
#line 186
      goto while_break;
    }
#line 187
    if ((int )*name == (int )*(aliases[i])) {
      {
#line 187
      tmp = strcmp((char const   *)name, (char const   *)aliases[i]);
      }
#line 187
      if (tmp == 0) {
#line 188
        return (i);
      }
    }
#line 186
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 189
  return (-1);
}
}
#line 195 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/var.c"
static void (*vectors[6])(char * , List * , bool  )  = {      & varassign,      & varassign,      & colonassign,      & listassign, 
        & colonassign,      & listassign};
#line 194 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/var.c"
extern void alias(char *name , List *s___0 , bool stack ) 
{ 
  int i ;
  int tmp ;

  {
  {
#line 198
  tmp = hasalias(name);
#line 198
  i = tmp;
  }
#line 199
  if (i != -1) {
    {
#line 200
    (*(vectors[i]))((char *)aliases[i ^ 1], s___0, stack);
    }
  }
#line 201
  return;
}
}
#line 205 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/var.c"
static char const   * const  keywords[8]  = 
#line 205
  {      (char const   */* const  */)"if",      (char const   */* const  */)"in",      (char const   */* const  */)"fn",      (char const   */* const  */)"for", 
        (char const   */* const  */)"else",      (char const   */* const  */)"switch",      (char const   */* const  */)"while",      (char const   */* const  */)"case"};
#line 203 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/var.c"
extern void prettyprint_var(int fd , char *name , List *s___0 ) 
{ 
  int i ;
  int tmp ;
  int tmp___0 ;
  char const   *tmp___1 ;

  {
#line 208
  if ((unsigned long )s___0 == (unsigned long )((void *)0)) {
    {
#line 209
    fprint(fd, "%S=()\n", name);
    }
#line 210
    return;
  }
#line 212
  if ((int )*name == (int )*"*") {
    {
#line 212
    tmp = strcmp((char const   *)name, "*");
    }
#line 212
    if (tmp == 0) {
#line 213
      s___0 = s___0->n;
#line 214
      if ((unsigned long )s___0 == (unsigned long )((void *)0)) {
#line 215
        return;
      }
    }
  }
#line 217
  i = 0;
  {
#line 217
  while (1) {
    while_continue: /* CIL Label */ ;
#line 217
    if (! (i < (int )(sizeof(keywords) / sizeof(keywords[0])))) {
#line 217
      goto while_break;
    }
#line 218
    if ((int const   )*(keywords[i]) == (int const   )*name) {
      {
#line 218
      tmp___0 = strcmp((char const   *)keywords[i], (char const   *)name);
      }
#line 218
      if (tmp___0 == 0) {
        {
#line 219
        fprint(fd, "%#S=", name);
        }
#line 220
        goto value;
      }
    }
#line 217
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 222
  fprint(fd, "%S=", name);
  }
  value: 
#line 224
  if ((unsigned long )s___0->n == (unsigned long )((void *)0)) {
#line 224
    tmp___1 = "%L\n";
  } else {
#line 224
    tmp___1 = "(%L)\n";
  }
  {
#line 224
  fprint(fd, tmp___1, s___0, " ");
  }
#line 225
  return;
}
}
#line 4 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/sigmsgs.h"
Sigmsgs signals[65] ;
#line 3 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/sigmsgs.c"
Sigmsgs signals[65]  = 
#line 3 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/sigmsgs.c"
  {      {(char *)"", (char *)""}, 
        {(char *)"sighup", (char *)"hangup"}, 
        {(char *)"sigint", (char *)""}, 
        {(char *)"sigquit", (char *)"quit"}, 
        {(char *)"sigill", (char *)"illegal instruction"}, 
        {(char *)"sigtrap", (char *)"trace trap"}, 
        {(char *)"sigabrt", (char *)"abort"}, 
        {(char *)"sigbus", (char *)"bus error"}, 
        {(char *)"sigfpe", (char *)"floating point error"}, 
        {(char *)"sigkill", (char *)"killed"}, 
        {(char *)"sigusr1", (char *)"user defined signal 1"}, 
        {(char *)"sigsegv", (char *)"segmentation violation"}, 
        {(char *)"sigusr2", (char *)"user defined signal 2"}, 
        {(char *)"sigpipe", (char *)""}, 
        {(char *)"sigalrm", (char *)"alarm clock"}, 
        {(char *)"sigterm", (char *)"terminated"}, 
        {(char *)"sigstkflt", (char *)"stack fault"}, 
        {(char *)"sigchld", (char *)"child stop or exit"}, 
        {(char *)"sigcont", (char *)"continue"}, 
        {(char *)"sigstop", (char *)"stopped by program"}, 
        {(char *)"sigtstp", (char *)"stopped"}, 
        {(char *)"sigttin", (char *)"background tty read"}, 
        {(char *)"sigttou", (char *)"background tty write"}, 
        {(char *)"sigurg", (char *)"urgent condition on i/o channel"}, 
        {(char *)"sigxcpu", (char *)"exceeded cpu time limit"}, 
        {(char *)"sigxfsz", (char *)"exceeded file size limit"}, 
        {(char *)"sigvtalrm", (char *)"virtual timer alarm"}, 
        {(char *)"sigprof", (char *)"profiling timer alarm"}, 
        {(char *)"sigwinch", (char *)"window size change"}, 
        {(char *)"sigio", (char *)"socket i/o possible"}, 
        {(char *)"sigpwr", (char *)"power-fail restart"}, 
        {(char *)"sigsys", (char *)"invalid argument to system call"}, 
        {(char *)"sigunknown32", (char *)"unknown signal 32"}, 
        {(char *)"sigunknown33", (char *)"unknown signal 33"}, 
        {(char *)"sigunknown34", (char *)"unknown signal 34"}, 
        {(char *)"sigunknown35", (char *)"unknown signal 35"}, 
        {(char *)"sigunknown36", (char *)"unknown signal 36"}, 
        {(char *)"sigunknown37", (char *)"unknown signal 37"}, 
        {(char *)"sigunknown38", (char *)"unknown signal 38"}, 
        {(char *)"sigunknown39", (char *)"unknown signal 39"}, 
        {(char *)"sigunknown40", (char *)"unknown signal 40"}, 
        {(char *)"sigunknown41", (char *)"unknown signal 41"}, 
        {(char *)"sigunknown42", (char *)"unknown signal 42"}, 
        {(char *)"sigunknown43", (char *)"unknown signal 43"}, 
        {(char *)"sigunknown44", (char *)"unknown signal 44"}, 
        {(char *)"sigunknown45", (char *)"unknown signal 45"}, 
        {(char *)"sigunknown46", (char *)"unknown signal 46"}, 
        {(char *)"sigunknown47", (char *)"unknown signal 47"}, 
        {(char *)"sigunknown48", (char *)"unknown signal 48"}, 
        {(char *)"sigunknown49", (char *)"unknown signal 49"}, 
        {(char *)"sigunknown50", (char *)"unknown signal 50"}, 
        {(char *)"sigunknown51", (char *)"unknown signal 51"}, 
        {(char *)"sigunknown52", (char *)"unknown signal 52"}, 
        {(char *)"sigunknown53", (char *)"unknown signal 53"}, 
        {(char *)"sigunknown54", (char *)"unknown signal 54"}, 
        {(char *)"sigunknown55", (char *)"unknown signal 55"}, 
        {(char *)"sigunknown56", (char *)"unknown signal 56"}, 
        {(char *)"sigunknown57", (char *)"unknown signal 57"}, 
        {(char *)"sigunknown58", (char *)"unknown signal 58"}, 
        {(char *)"sigunknown59", (char *)"unknown signal 59"}, 
        {(char *)"sigunknown60", (char *)"unknown signal 60"}, 
        {(char *)"sigunknown61", (char *)"unknown signal 61"}, 
        {(char *)"sigunknown62", (char *)"unknown signal 62"}, 
        {(char *)"sigunknown63", (char *)"unknown signal 63"}, 
        {(char *)"sigunknown64", (char *)"unknown signal 64"}};
#line 137 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcat)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 678 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __uid_t ( __attribute__((__leaf__)) geteuid)(void) ;
#line 684
extern  __attribute__((__nothrow__)) __gid_t ( __attribute__((__leaf__)) getegid)(void) ;
#line 689
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getgroups)(int __size ,
                                                                                __gid_t *__list ) ;
#line 183 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/rc.h"
extern char *which(char *name , bool verbose ) ;
#line 211
extern void rc_exit(int stat___0 ) ;
#line 426
extern bool isabsolute(char *path ) ;
#line 209 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) stat)(char const   * __restrict  __file ,
                                                                                             struct stat * __restrict  __buf ) ;
#line 23 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/which.c"
static bool initialized  =    (bool )0;
#line 24 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/which.c"
static uid_t uid  ;
#line 25 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/which.c"
static gid_t gid  ;
#line 28 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/which.c"
static int ngroups  ;
#line 29 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/which.c"
static gid_t *gidset  ;
#line 33 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/which.c"
static int ingidset(gid_t g ) 
{ 
  int i ;

  {
#line 35
  i = 0;
  {
#line 35
  while (1) {
    while_continue: /* CIL Label */ ;
#line 35
    if (! (i < ngroups)) {
#line 35
      goto while_break;
    }
#line 36
    if (g == *(gidset + i)) {
#line 37
      return (1);
    }
#line 35
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 38
  return (0);
}
}
#line 49 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/which.c"
static bool rc_access(char *path , bool verbose ) 
{ 
  struct stat st ;
  int mask ;
  int tmp ;
  int tmp___0 ;
  int *tmp___1 ;

  {
  {
#line 52
  tmp = stat((char const   */* __restrict  */)path, (struct stat */* __restrict  */)(& st));
  }
#line 52
  if (tmp != 0) {
#line 53
    if (verbose) {
      {
#line 54
      uerror(path);
      }
    }
#line 55
    return ((bool )0);
  }
#line 57
  if (uid == 0U) {
#line 58
    mask = 73;
  } else
#line 59
  if (uid == st.st_uid) {
#line 60
    mask = 64;
  } else
#line 61
  if (gid == st.st_gid) {
#line 62
    mask = 8;
  } else {
    {
#line 61
    tmp___0 = ingidset(st.st_gid);
    }
#line 61
    if (tmp___0) {
#line 62
      mask = 8;
    } else {
#line 64
      mask = 1;
    }
  }
#line 65
  if ((st.st_mode & 61440U) == 32768U) {
#line 65
    if (st.st_mode & (unsigned int )mask) {
#line 66
      return ((bool )1);
    }
  }
  {
#line 67
  tmp___1 = __errno_location();
#line 67
  *tmp___1 = 13;
  }
#line 68
  if (verbose) {
    {
#line 69
    uerror(path);
    }
  }
#line 70
  return ((bool )0);
}
}
#line 76 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/which.c"
static char *test  =    (char *)((void *)0);
#line 77 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/which.c"
static size_t testlen  =    (size_t )0;
#line 75 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/which.c"
extern char *which(char *name , bool verbose ) 
{ 
  List *path ;
  int len ;
  void *tmp ;
  char *tmp___1 ;
  bool tmp___2 ;
  bool tmp___3 ;
  size_t tmp___4 ;
  size_t need ;
  size_t tmp___5 ;
  void *tmp___6 ;
  int tmp___7 ;
  bool tmp___8 ;

  {
#line 80
  if ((unsigned long )name == (unsigned long )((void *)0)) {
#line 81
    return ((char *)((void *)0));
  }
#line 82
  if (! initialized) {
    {
#line 83
    initialized = (bool )1;
#line 84
    uid = geteuid();
#line 85
    gid = getegid();
#line 88
    ngroups = getgroups(0, (gid_t *)0);
    }
#line 89
    if (ngroups < 0) {
      {
#line 90
      uerror((char *)"getgroups");
#line 91
      rc_exit(1);
      }
    }
#line 96
    if (ngroups) {
      {
#line 97
      tmp = ealloc((unsigned long )ngroups * sizeof(gid_t ));
#line 97
      gidset = (gid_t *)tmp;
#line 98
      ngroups = getgroups(ngroups, gidset);
      }
#line 99
      if (ngroups < 0) {
        {
#line 100
        uerror((char *)"getgroups");
#line 101
        rc_exit(1);
        }
      }
    }
  }
  {
#line 106
  tmp___3 = isabsolute(name);
  }
#line 106
  if (tmp___3) {
    {
#line 107
    tmp___2 = rc_access(name, verbose);
    }
#line 107
    if (tmp___2) {
#line 107
      tmp___1 = name;
    } else {
#line 107
      tmp___1 = (char *)((void *)0);
    }
#line 107
    return (tmp___1);
  }
  {
#line 108
  tmp___4 = strlen((char const   *)name);
#line 108
  len = (int )tmp___4;
#line 109
  path = varlookup((char *)"path");
  }
  {
#line 109
  while (1) {
    while_continue: /* CIL Label */ ;
#line 109
    if (! ((unsigned long )path != (unsigned long )((void *)0))) {
#line 109
      goto while_break;
    }
    {
#line 110
    tmp___5 = strlen((char const   *)path->w);
#line 110
    need = (tmp___5 + (size_t )len) + 2UL;
    }
#line 111
    if (testlen < need) {
      {
#line 112
      efree((void *)test);
#line 113
      testlen = need;
#line 113
      tmp___6 = ealloc(testlen);
#line 113
      test = (char *)tmp___6;
      }
    }
#line 115
    if ((int )*(path->w) == 0) {
      {
#line 116
      strcpy((char */* __restrict  */)test, (char const   */* __restrict  */)name);
      }
    } else {
      {
#line 118
      strcpy((char */* __restrict  */)test, (char const   */* __restrict  */)path->w);
      }
#line 119
      if ((int )*test == (int )*"/") {
        {
#line 119
        tmp___7 = strcmp((char const   *)test, "/");
        }
#line 119
        if (! (tmp___7 == 0)) {
          {
#line 120
          strcat((char */* __restrict  */)test, (char const   */* __restrict  */)"/");
          }
        }
      } else {
        {
#line 120
        strcat((char */* __restrict  */)test, (char const   */* __restrict  */)"/");
        }
      }
      {
#line 121
      strcat((char */* __restrict  */)test, (char const   */* __restrict  */)name);
      }
    }
    {
#line 123
    tmp___8 = rc_access(test, (bool )0);
    }
#line 123
    if (tmp___8) {
#line 124
      return (test);
    }
#line 109
    path = path->n;
  }
  while_break: /* CIL Label */ ;
  }
#line 126
  if (verbose) {
    {
#line 127
    fprint(2, "%s not found\n", name);
    }
  }
#line 128
  return ((char *)((void *)0));
}
}
#line 360 "/usr/include/unistd.h"
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 175 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/rc.h"
bool dashvee ;
#line 175
bool dashex ;
#line 175
bool dashell ;
#line 175
bool dashen ;
#line 182
extern void funcall(char **av ) ;
#line 182
extern void b_dot(char **av ) ;
#line 189
extern void rc_raise(ecodes e ) ;
#line 190
extern void except(ecodes e , Edata data , Estack *ex ) ;
#line 191
extern void unexcept(void) ;
#line 229
extern List *concat(List *s1 , List *s2 ) ;
#line 231
extern List *word(char *w___0 , char *m ) ;
#line 238
extern Node *fnlookup(char *name ) ;
#line 270
extern void initinput(void) ;
#line 274
extern Node *doit(bool clobberexecit ) ;
#line 277
extern void pushfd(int fd ) ;
#line 278
extern void pushstring(char **a , bool save ) ;
#line 279
extern void popinput(void) ;
#line 280
extern void closefds(void) ;
#line 281 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/rc.h"
int lastchar  ;
#line 282 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/rc.h"
bool rcrc  ;
#line 306
extern Block *newblock(void) ;
#line 313
extern bool makeblocking(int fd ) ;
#line 314
extern bool makesamepgrp(int fd ) ;
#line 342
Node *parsetree ;
#line 343
int yyparse(void) ;
#line 430
extern void pr_error(char *s___0 , int offset ) ;
#line 446
extern bool walk(Node *n , bool parent ) ;
#line 59 "/usr/include/setjmp.h"
extern  __attribute__((__nothrow__)) int __sigsetjmp(struct __jmp_buf_tag *__env ,
                                                     int __savemask ) ;
#line 24 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/input.c"
static char *prompt2  ;
#line 27
static int dead(void) ;
#line 28
static int fdgchar(void) ;
#line 29
static int stringgchar(void) ;
#line 30
static void history(void) ;
#line 31
static void ugdead(int ignore ) ;
#line 32
static void pushcommon(void) ;
#line 34 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/input.c"
static char *inbuf  ;
#line 35 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/input.c"
static size_t istacksize  ;
#line 35 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/input.c"
static size_t chars_out  ;
#line 35 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/input.c"
static size_t chars_in  ;
#line 36 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/input.c"
static bool eofread  =    (bool )0;
#line 36 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/input.c"
static bool save_lineno  =    (bool )1;
#line 37 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/input.c"
static Input *istack  ;
#line 37 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/input.c"
static Input *itop  ;
#line 39 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/input.c"
static int (*realgchar)(void)  ;
#line 40 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/input.c"
static void (*realugchar)(int  )  ;
#line 48 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/input.c"
extern int gchar(void) 
{ 
  int c ;

  {
#line 51
  if (eofread) {
#line 52
    eofread = (bool )0;
#line 53
    lastchar = -1;
#line 53
    return (lastchar);
  }
  {
#line 56
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 56
    c = (*realgchar)();
    }
#line 56
    if (! (c == 0)) {
#line 56
      goto while_break;
    }
    {
#line 57
    pr_error((char *)"warning: null character ignored", 0);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 59
  return (c);
}
}
#line 62 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/input.c"
extern void ugchar(int c ) 
{ 


  {
  {
#line 63
  (*realugchar)(c);
  }
#line 64
  return;
}
}
#line 66 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/input.c"
static int dead(void) 
{ 


  {
#line 67
  lastchar = -1;
#line 67
  return (lastchar);
}
}
#line 70 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/input.c"
static void ugdead(int ignore ) 
{ 


  {
#line 71
  return;
}
}
#line 74 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/input.c"
static void ugalive(int c ) 
{ 


  {
#line 75
  if (c == -1) {
#line 76
    eofread = (bool )1;
  } else {
#line 78
    chars_out --;
#line 78
    *(inbuf + chars_out) = (char )c;
  }
#line 79
  return;
}
}
#line 83 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/input.c"
static int stringgchar(void) 
{ 
  size_t tmp ;

  {
#line 84
  if ((int )*(inbuf + chars_out) == 0) {
#line 84
    lastchar = -1;
  } else {
#line 84
    tmp = chars_out;
#line 84
    chars_out ++;
#line 84
    lastchar = (int )*(inbuf + tmp);
  }
#line 84
  return (lastchar);
}
}
#line 93 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/input.c"
static int fdgchar(void) 
{ 
  ssize_t r ;
  int *tmp ;
  bool tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  bool tmp___4 ;
  int *tmp___5 ;
  size_t tmp___6 ;

  {
#line 95
  if (chars_out >= chars_in + 2UL) {
    {
#line 96
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 120
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 121
        r = read(istack->fd, (void *)(inbuf + 2), (size_t )256);
#line 122
        sigchk();
#line 123
        tmp = __errno_location();
        }
        {
#line 124
        if (*tmp == 11) {
#line 124
          goto case_11;
        }
#line 129
        if (*tmp == 5) {
#line 129
          goto case_5;
        }
#line 123
        goto switch_break;
        case_11: /* CIL Label */ 
        {
#line 125
        tmp___0 = makeblocking(istack->fd);
        }
#line 125
        if (! tmp___0) {
          {
#line 126
          panic((char *)"not O_NONBLOCK");
          }
        }
        {
#line 127
        tmp___1 = __errno_location();
#line 127
        *tmp___1 = 4;
        }
#line 128
        goto switch_break;
        case_5: /* CIL Label */ 
        {
#line 130
        tmp___4 = makesamepgrp(istack->fd);
        }
#line 130
        if (tmp___4) {
          {
#line 131
          tmp___2 = __errno_location();
#line 131
          *tmp___2 = 4;
          }
        } else {
          {
#line 133
          tmp___3 = __errno_location();
#line 133
          *tmp___3 = 5;
          }
        }
#line 134
        goto switch_break;
        switch_break: /* CIL Label */ ;
        }
#line 120
        if (r < 0L) {
          {
#line 120
          tmp___5 = __errno_location();
          }
#line 120
          if (! (*tmp___5 == 4)) {
#line 120
            goto while_break___0;
          }
        } else {
#line 120
          goto while_break___0;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
#line 137
      if (r < 0L) {
        {
#line 138
        uerror((char *)"read");
#line 139
        rc_raise((ecodes )0);
        }
      }
#line 141
      chars_in = (size_t )r;
#line 143
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
#line 145
    if (chars_in == 0UL) {
#line 146
      lastchar = -1;
#line 146
      return (lastchar);
    }
#line 147
    chars_out = (size_t )2;
#line 148
    if (dashvee) {
      {
#line 149
      writeall(2, inbuf + 2, chars_in);
      }
    }
    {
#line 150
    history();
    }
  }
#line 152
  tmp___6 = chars_out;
#line 152
  chars_out ++;
#line 152
  lastchar = (int )*(inbuf + tmp___6);
#line 152
  return (lastchar);
}
}
#line 157 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/input.c"
extern void initinput(void) 
{ 
  void *tmp ;

  {
  {
#line 158
  istacksize = 256UL * sizeof(Input );
#line 158
  tmp = ealloc(istacksize);
#line 158
  itop = (Input *)tmp;
#line 158
  istack = itop;
#line 159
  istack->t = (inputtype )0;
#line 160
  istack->fd = -1;
#line 161
  realugchar = & ugalive;
  }
#line 162
  return;
}
}
#line 166 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/input.c"
static void pushcommon(void) 
{ 
  size_t idiff ;
  void *tmp ;

  {
#line 168
  istack->index = (int )chars_out;
#line 169
  istack->read = (int )chars_in;
#line 170
  istack->ibuf = inbuf;
#line 171
  istack->lineno = lineno;
#line 172
  istack->saved = save_lineno;
#line 173
  istack->last = lastchar;
#line 174
  istack->eofread = eofread;
#line 175
  istack ++;
#line 176
  idiff = (size_t )(istack - itop);
#line 177
  if (idiff >= istacksize / sizeof(Input )) {
    {
#line 178
    istacksize *= 2UL;
#line 178
    tmp = erealloc((void *)itop, istacksize);
#line 178
    itop = (Input *)tmp;
#line 179
    istack = itop + idiff;
    }
  }
#line 181
  realugchar = & ugalive;
#line 182
  chars_out = (size_t )2;
#line 183
  chars_in = (size_t )0;
#line 184
  return;
}
}
#line 186 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/input.c"
extern void pushfd(int fd ) 
{ 
  void *tmp ;

  {
  {
#line 187
  pushcommon();
#line 188
  istack->t = (inputtype )0;
#line 189
  save_lineno = (bool )1;
#line 190
  istack->fd = fd;
#line 191
  realgchar = & fdgchar;
#line 192
  tmp = ealloc(258UL);
#line 192
  inbuf = (char *)tmp;
#line 193
  lineno = 1;
  }
#line 194
  return;
}
}
#line 196 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/input.c"
extern void pushstring(char **a , bool save ) 
{ 


  {
  {
#line 197
  pushcommon();
#line 198
  istack->t = (inputtype )1;
#line 199
  save_lineno = save;
#line 200
  inbuf = mprint("..%A", a);
#line 201
  realgchar = & stringgchar;
  }
#line 202
  if (save_lineno) {
#line 203
    lineno = 1;
  } else {
#line 205
    lineno --;
  }
#line 206
  return;
}
}
#line 210 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/input.c"
extern void popinput(void) 
{ 


  {
#line 211
  if ((unsigned int )istack->t == 0U) {
    {
#line 212
    close(istack->fd);
    }
  }
  {
#line 213
  efree((void *)inbuf);
#line 214
  istack --;
  }
#line 215
  if ((unsigned int )istack->t == 1U) {
#line 215
    realgchar = & stringgchar;
  } else {
#line 215
    realgchar = & fdgchar;
  }
#line 216
  if ((unsigned int )istack->t == 0U) {
#line 216
    if (istack->fd == -1) {
#line 217
      realgchar = & dead;
#line 218
      realugchar = & ugdead;
    }
  }
#line 220
  lastchar = istack->last;
#line 221
  eofread = istack->eofread;
#line 222
  inbuf = istack->ibuf;
#line 223
  chars_out = (size_t )istack->index;
#line 224
  chars_in = (size_t )istack->read;
#line 225
  if (save_lineno) {
#line 226
    lineno = istack->lineno;
  } else {
#line 228
    lineno ++;
  }
#line 229
  save_lineno = istack->saved;
#line 230
  return;
}
}
#line 234 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/input.c"
extern void flushu(void) 
{ 
  int c ;

  {
#line 236
  if (lastchar == 10) {
#line 237
    return;
  } else
#line 236
  if (lastchar == -1) {
#line 237
    return;
  }
  {
#line 238
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 238
    c = gchar();
    }
#line 238
    if (c != 10) {
#line 238
      if (! (c != -1)) {
#line 238
        goto while_break;
      }
    } else {
#line 238
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 240
  if (c == -1) {
    {
#line 241
    ugchar(c);
    }
  }
#line 242
  return;
}
}
#line 276 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/input.c"
static bool died  =    (bool )0;
#line 277 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/input.c"
static char *arglist[2]  = {      (char *)"prompt",      (char *)((void *)0)};
#line 246 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/input.c"
extern Node *doit(bool clobberexecit ) 
{ 
  bool eof ;
  bool execit ;
  Jbwrap j ;
  Estack e1 ;
  Edata jerror ;
  Edata block ;
  Estack e2 ;
  char *fname[3] ;
  List *tmp ;
  List *tmp___0 ;
  List *tmp___1 ;
  List *s___0 ;
  Node *tmp___2 ;
  int tmp___3 ;

  {
#line 253
  if (dashen) {
#line 254
    clobberexecit = (bool )0;
  }
  {
#line 255
  execit = clobberexecit;
#line 256
  __sigsetjmp((struct __jmp_buf_tag *)(j.j), 1);
#line 257
  jerror.jb = & j;
#line 258
  except((ecodes )0, jerror, & e1);
#line 259
  eof = (bool )0;
  }
  {
#line 259
  while (1) {
    while_continue: /* CIL Label */ ;
#line 259
    if (! (! eof)) {
#line 259
      goto while_break;
    }
    {
#line 262
    block.b = newblock();
#line 263
    except((ecodes )4, block, & e2);
#line 264
    sigchk();
    }
#line 265
    if (dashell) {
      {
#line 267
      tmp = word((char *)"/.rcrc", (char *)((void *)0));
#line 267
      tmp___0 = varlookup((char *)"home");
#line 267
      tmp___1 = concat(tmp___0, tmp);
#line 267
      fname[1] = tmp___1->w;
#line 268
      fname[2] = (char *)((void *)0);
#line 269
      rcrc = (bool )1;
#line 270
      dashell = (bool )0;
#line 271
      b_dot(fname);
      }
    }
#line 273
    if (interactive) {
#line 275
      if (! dashen) {
        {
#line 275
        tmp___2 = fnlookup((char *)"prompt");
        }
#line 275
        if ((unsigned long )tmp___2 != (unsigned long )((void *)0)) {
#line 279
          if (! died) {
            {
#line 280
            died = (bool )1;
#line 281
            funcall(arglist);
            }
          }
#line 283
          died = (bool )0;
        }
      }
      {
#line 285
      s___0 = varlookup((char *)"prompt");
      }
#line 285
      if ((unsigned long )s___0 != (unsigned long )((void *)0)) {
        {
#line 291
        fprint(2, "%s", s___0->w);
        }
#line 292
        if ((unsigned long )s___0->n == (unsigned long )((void *)0)) {
#line 292
          prompt2 = (char *)"";
        } else {
#line 292
          prompt2 = (s___0->n)->w;
        }
      }
    }
    {
#line 295
    inityy();
#line 296
    tmp___3 = yyparse();
    }
#line 296
    if (tmp___3 == 1) {
#line 296
      if (execit) {
        {
#line 297
        rc_raise((ecodes )0);
        }
      }
    }
#line 298
    eof = (bool )(lastchar == -1);
#line 299
    if ((unsigned long )parsetree != (unsigned long )((void *)0)) {
#line 300
      if (execit) {
        {
#line 301
        walk(parsetree, (bool )1);
        }
      } else
#line 302
      if (dashex) {
#line 302
        if (dashen) {
          {
#line 303
          fprint(2, "%T\n", parsetree);
          }
        }
      }
    }
    {
#line 305
    unexcept();
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 307
  popinput();
#line 308
  unexcept();
  }
#line 309
  return (parsetree);
}
}
#line 314 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/input.c"
extern Node *parseline(char *extdef ) 
{ 
  int i ;
  char *in[2] ;
  Node *fun ;

  {
  {
#line 315
  i = (int )interactive;
#line 318
  in[0] = extdef;
#line 319
  in[1] = (char *)((void *)0);
#line 320
  interactive = (bool )0;
#line 321
  pushstring(in, (bool )1);
#line 322
  fun = doit((bool )0);
#line 323
  interactive = (bool )i;
  }
#line 324
  return (fun);
}
}
#line 329 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/input.c"
static void history(void) 
{ 
  List *hist ;
  size_t a ;
  char c ;
  char *name ;
  int fd ;
  int tmp ;

  {
#line 333
  if (! interactive) {
#line 334
    return;
  } else {
    {
#line 333
    hist = varlookup((char *)"history");
    }
#line 333
    if ((unsigned long )hist == (unsigned long )((void *)0)) {
#line 334
      return;
    }
  }
#line 336
  a = (size_t )0;
  {
#line 336
  while (1) {
    while_continue: /* CIL Label */ ;
#line 336
    if (! (a < chars_in)) {
#line 336
      goto while_break;
    }
#line 337
    c = *(inbuf + (a + 2UL));
#line 340
    if ((int )c == 35) {
#line 341
      goto while_break;
    } else
#line 340
    if ((int )c == 10) {
#line 341
      goto while_break;
    }
#line 344
    if ((int )c != 32) {
#line 344
      if ((int )c != 9) {
        {
#line 345
        name = hist->w;
#line 346
        tmp = rc_open((char const   *)name, (redirtype )2);
#line 346
        fd = tmp;
        }
#line 347
        if (fd < 0) {
          {
#line 348
          uerror(name);
#line 349
          varrm(name, (bool )1);
          }
        } else {
          {
#line 351
          writeall(fd, inbuf + 2, chars_in);
#line 352
          close(fd);
          }
        }
#line 354
        goto while_break;
      }
    }
#line 336
    a ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 357
  return;
}
}
#line 361 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/input.c"
extern void closefds(void) 
{ 
  Input *i ;

  {
#line 363
  i = istack;
  {
#line 363
  while (1) {
    while_continue: /* CIL Label */ ;
#line 363
    if (! ((unsigned long )i != (unsigned long )itop)) {
#line 363
      goto while_break;
    }
#line 364
    if ((unsigned int )i->t == 0U) {
#line 364
      if (i->fd > 2) {
        {
#line 365
        close(i->fd);
#line 366
        i->fd = -1;
        }
      }
    }
#line 363
    i --;
  }
  while_break: /* CIL Label */ ;
  }
#line 368
  return;
}
}
#line 370 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/input.c"
extern void print_prompt2(void) 
{ 


  {
#line 371
  lineno ++;
#line 372
  if (interactive) {
    {
#line 378
    fprint(2, "%s", prompt2);
    }
  }
#line 380
  return;
}
}
#line 628 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) getpid)(void) ;
#line 826
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) unlink)(char const   *__name ) ;
#line 177 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/rc.h"
pid_t rc_pid ;
#line 186
bool nl_on_intr ;
#line 187
extern bool outstanding_cmdarg(void) ;
#line 188
extern void pop_cmdarg(bool remove ) ;
#line 193
extern void sigint(int s___0 ) ;
#line 309
extern void restoreblock(Block *old ) ;
#line 447
bool cond ;
#line 102 "/usr/include/setjmp.h"
extern  __attribute__((__nothrow__, __noreturn__)) void siglongjmp(struct __jmp_buf_tag *__env ,
                                                                   int __val ) ;
#line 13 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/except.c"
bool nl_on_intr  =    (bool )1;
#line 15 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/except.c"
static Estack *estack  ;
#line 19 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/except.c"
extern void except(ecodes e , Edata data , Estack *ex ) 
{ 


  {
#line 20
  ex->prev = estack;
#line 21
  estack = ex;
#line 22
  estack->e = e;
#line 23
  estack->data = data;
#line 24
  if ((unsigned int )e == 0U) {
#line 25
    estack->interactive = interactive;
  } else
#line 24
  if ((unsigned int )e == 1U) {
#line 25
    estack->interactive = interactive;
  } else
#line 24
  if ((unsigned int )e == 2U) {
#line 25
    estack->interactive = interactive;
  }
#line 26
  return;
}
}
#line 30 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/except.c"
extern void unexcept(void) 
{ 


  {
  {
#line 34
  if ((unsigned int )estack->e == 0U) {
#line 34
    goto case_0;
  }
#line 37
  if ((unsigned int )estack->e == 4U) {
#line 37
    goto case_4;
  }
#line 40
  if ((unsigned int )estack->e == 5U) {
#line 40
    goto case_5;
  }
#line 43
  if ((unsigned int )estack->e == 6U) {
#line 43
    goto case_6;
  }
#line 32
  goto switch_default;
  switch_default: /* CIL Label */ 
#line 33
  goto switch_break;
  case_0: /* CIL Label */ 
#line 35
  interactive = estack->interactive;
#line 36
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 38
  restoreblock(estack->data.b);
  }
#line 39
  goto switch_break;
  case_5: /* CIL Label */ 
  {
#line 41
  unlink((char const   *)estack->data.name);
  }
#line 42
  goto switch_break;
  case_6: /* CIL Label */ 
  {
#line 44
  close(estack->data.fd);
  }
#line 45
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 47
  estack = estack->prev;
#line 48
  return;
}
}
#line 63 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/except.c"
extern void rc_raise(ecodes e ) 
{ 
  __pid_t tmp ;
  Jbwrap *j ;

  {
#line 64
  if ((unsigned int )e == 0U) {
    {
#line 64
    tmp = getpid();
    }
#line 64
    if (rc_pid != tmp) {
      {
#line 65
      exit(1);
      }
    }
  }
  {
#line 66
  while (1) {
    while_continue: /* CIL Label */ ;
#line 66
    if (! ((unsigned long )estack != (unsigned long )((void *)0))) {
#line 66
      goto while_break;
    }
#line 67
    if ((unsigned int )estack->e != (unsigned int )e) {
#line 68
      if ((unsigned int )e == 1U) {
#line 68
        if ((unsigned int )estack->e != 4U) {
          {
#line 69
          rc_error((char *)"break outside of loop");
          }
        } else {
#line 68
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 70
      if ((unsigned int )e == 2U) {
#line 70
        if ((unsigned int )estack->e == 0U) {
          {
#line 71
          rc_error((char *)"return outside of function");
          }
        }
      }
      {
#line 75
      if ((unsigned int )estack->e == 3U) {
#line 75
        goto case_3;
      }
#line 78
      if ((unsigned int )estack->e == 4U) {
#line 78
        goto case_4;
      }
#line 81
      if ((unsigned int )estack->e == 5U) {
#line 81
        goto case_5;
      }
#line 84
      if ((unsigned int )estack->e == 6U) {
#line 84
        goto case_6;
      }
#line 73
      goto switch_default;
      switch_default: /* CIL Label */ 
#line 74
      goto switch_break;
      case_3: /* CIL Label */ 
      {
#line 76
      varrm(estack->data.name, (bool )1);
      }
#line 77
      goto switch_break;
      case_4: /* CIL Label */ 
      {
#line 79
      restoreblock(estack->data.b);
      }
#line 80
      goto switch_break;
      case_5: /* CIL Label */ 
      {
#line 82
      unlink((char const   *)estack->data.name);
      }
#line 83
      goto switch_break;
      case_6: /* CIL Label */ 
      {
#line 85
      close(estack->data.fd);
      }
#line 86
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    } else
#line 89
    if ((unsigned int )e == 0U) {
#line 89
      if (! estack->interactive) {
        {
#line 90
        popinput();
        }
      } else {
        {
#line 92
        j = estack->data.jb;
#line 94
        interactive = estack->interactive;
#line 95
        estack = estack->prev;
#line 96
        siglongjmp((struct __jmp_buf_tag *)(j->j), 1);
        }
      }
    } else {
      {
#line 92
      j = estack->data.jb;
#line 94
      interactive = estack->interactive;
#line 95
      estack = estack->prev;
#line 96
      siglongjmp((struct __jmp_buf_tag *)(j->j), 1);
      }
    }
#line 66
    estack = estack->prev;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 99
  rc_exit(1);
  }
#line 100
  return;
}
}
#line 102 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/except.c"
extern bool outstanding_cmdarg(void) 
{ 
  int tmp ;

  {
#line 103
  if ((unsigned int )estack->e == 5U) {
#line 103
    tmp = 1;
  } else
#line 103
  if ((unsigned int )estack->e == 6U) {
#line 103
    tmp = 1;
  } else {
#line 103
    tmp = 0;
  }
#line 103
  return ((bool )tmp);
}
}
#line 106 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/except.c"
extern void pop_cmdarg(bool remove ) 
{ 


  {
  {
#line 107
  while (1) {
    while_continue: /* CIL Label */ ;
#line 107
    if (! ((unsigned long )estack != (unsigned long )((void *)0))) {
#line 107
      goto while_break;
    }
    {
#line 109
    if ((unsigned int )estack->e == 5U) {
#line 109
      goto case_5;
    }
#line 113
    if ((unsigned int )estack->e == 6U) {
#line 113
      goto case_6;
    }
#line 117
    goto switch_default;
    case_5: /* CIL Label */ 
#line 110
    if (remove) {
      {
#line 111
      unlink((char const   *)estack->data.name);
      }
    }
#line 112
    goto switch_break;
    case_6: /* CIL Label */ 
#line 114
    if (remove) {
      {
#line 115
      close(estack->data.fd);
      }
    }
#line 116
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 118
    return;
    switch_break: /* CIL Label */ ;
    }
#line 107
    estack = estack->prev;
  }
  while_break: /* CIL Label */ ;
  }
#line 120
  return;
}
}
#line 124 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/except.c"
extern void rc_error(char *s___0 ) 
{ 


  {
  {
#line 125
  pr_error(s___0, -1);
#line 126
  set((bool )0);
#line 127
  redirq = (Rq *)((void *)0);
#line 128
  cond = (bool )0;
#line 129
  rc_raise((ecodes )0);
  }
#line 130
  return;
}
}
#line 132 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/except.c"
extern void sigint(int s___0 ) 
{ 


  {
#line 133
  if (s___0 != 2) {
    {
#line 134
    panic((char *)"s != SIGINT in sigint catcher");
    }
  }
#line 136
  if (interactive) {
#line 136
    if (nl_on_intr) {
      {
#line 137
      fprint(2, "\n");
      }
    }
  }
  {
#line 138
  nl_on_intr = (bool )1;
#line 139
  redirq = (Rq *)((void *)0);
#line 140
  cond = (bool )0;
#line 141
  rc_raise((ecodes )0);
  }
#line 142
  return;
}
}
#line 551 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) execve)(char const   *__path ,
                                                                                               char * const  *__argv ,
                                                                                               char * const  *__envp ) ;
#line 181 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/rc.h"
extern builtin_t *isbuiltin(char *s___0 ) ;
#line 182
extern void b_exec(char **ignore ) ;
#line 182
extern void b_builtin(char **ignore ) ;
#line 196
extern void exec(List *s___0 , bool parent ) ;
#line 241
extern char **makeenv(void) ;
#line 394
extern int getstatus(void) ;
#line 15 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/exec.c"
extern void exec(List *s___0 , bool parent ) 
{ 
  char **av ;
  char **ev ;
  int stat___0 ;
  pid_t pid ;
  builtin_t *b ;
  char *path ;
  bool didfork ;
  bool returning ;
  bool saw_exec ;
  bool saw_builtin ;
  Node *tmp ;
  bool tmp___0 ;
  bool tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int *tmp___4 ;
  union __anonunion_51 __constr_expr_0 ;

  {
  {
#line 16
  ev = (char **)((void *)0);
#line 20
  path = (char *)((void *)0);
#line 22
  av = list2array(s___0, dashex);
#line 23
  saw_exec = (bool )0;
#line 23
  saw_builtin = saw_exec;
  }
  {
#line 24
  while (1) {
    while_continue: /* CIL Label */ ;
#line 25
    if ((unsigned long )*av == (unsigned long )((void *)0)) {
#line 26
      b = (builtin_t *)((void *)0);
    } else {
      {
#line 25
      tmp___0 = isabsolute(*av);
      }
#line 25
      if (tmp___0) {
#line 26
        b = (builtin_t *)((void *)0);
      } else
#line 27
      if (! saw_builtin) {
        {
#line 27
        tmp = fnlookup(*av);
        }
#line 27
        if ((unsigned long )tmp != (unsigned long )((void *)0)) {
#line 28
          b = & funcall;
        } else {
          {
#line 30
          b = isbuiltin(*av);
          }
        }
      } else {
        {
#line 30
        b = isbuiltin(*av);
        }
      }
    }
#line 36
    saw_builtin = (bool )0;
#line 38
    if ((unsigned long )b == (unsigned long )(& b_exec)) {
#line 39
      av ++;
#line 40
      saw_exec = (bool )1;
#line 41
      parent = (bool )0;
    } else
#line 42
    if ((unsigned long )b == (unsigned long )(& b_builtin)) {
#line 43
      av ++;
#line 44
      saw_builtin = (bool )1;
    }
#line 24
    if (! ((unsigned long )b == (unsigned long )(& b_exec))) {
#line 24
      if (! ((unsigned long )b == (unsigned long )(& b_builtin))) {
#line 24
        goto while_break;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 47
  if ((unsigned long )*av == (unsigned long )((void *)0)) {
#line 47
    if (saw_exec) {
      {
#line 48
      doredirs();
      }
#line 49
      return;
    }
  }
#line 52
  if (saw_exec) {
#line 53
    rc_pid = -1;
  }
#line 54
  if ((unsigned long )b == (unsigned long )((void *)0)) {
    {
#line 55
    path = which(*av, (bool )1);
    }
#line 56
    if ((unsigned long )path == (unsigned long )((void *)0)) {
#line 56
      if ((unsigned long )*av != (unsigned long )((void *)0)) {
        {
#line 57
        set((bool )0);
#line 58
        redirq = (Rq *)((void *)0);
        }
#line 59
        if (parent) {
#line 60
          return;
        }
        {
#line 61
        rc_exit(1);
        }
      }
    }
    {
#line 63
    ev = makeenv();
    }
  }
#line 70
  if (parent) {
#line 70
    if ((unsigned long )b == (unsigned long )((void *)0)) {
      {
#line 71
      pid = rc_fork();
#line 72
      didfork = (bool )1;
      }
    } else
#line 70
    if ((unsigned long )redirq != (unsigned long )((void *)0)) {
      {
#line 71
      pid = rc_fork();
#line 72
      didfork = (bool )1;
      }
    } else {
#line 70
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    {
#line 70
    tmp___1 = outstanding_cmdarg();
    }
#line 70
    if (tmp___1) {
      {
#line 71
      pid = rc_fork();
#line 72
      didfork = (bool )1;
      }
    } else {
#line 74
      pid = 0;
#line 75
      didfork = (bool )0;
    }
  }
#line 77
  if (! didfork) {
#line 77
    if (parent) {
#line 77
      tmp___2 = 1;
    } else {
#line 77
      tmp___2 = 0;
    }
  } else {
#line 77
    tmp___2 = 0;
  }
#line 77
  returning = (bool )tmp___2;
  {
#line 79
  if (pid == -1) {
#line 79
    goto case_neg_1;
  }
#line 83
  if (pid == 0) {
#line 83
    goto case_0;
  }
#line 110
  goto switch_default;
  case_neg_1: /* CIL Label */ 
  {
#line 80
  uerror((char *)"fork");
#line 81
  rc_error((char *)((void *)0));
  }
  case_0: /* CIL Label */ 
#line 84
  if (! returning) {
    {
#line 85
    setsigdefaults((bool )0);
    }
  }
  {
#line 86
  pop_cmdarg((bool )0);
#line 87
  doredirs();
  }
#line 90
  if ((unsigned long )*av == (unsigned long )((void *)0)) {
#line 90
    goto _L___0;
  } else
#line 90
  if ((unsigned long )b != (unsigned long )((void *)0)) {
    _L___0: /* CIL Label */ 
#line 91
    if ((unsigned long )b != (unsigned long )((void *)0)) {
      {
#line 92
      (*b)(av);
      }
    }
#line 93
    if (returning) {
#line 94
      return;
    }
    {
#line 95
    tmp___3 = getstatus();
#line 95
    rc_exit(tmp___3);
    }
  }
  {
#line 97
  execve((char const   *)path, (char * const  *)av, (char * const  *)ev);
#line 100
  tmp___4 = __errno_location();
  }
#line 100
  if (*tmp___4 == 8) {
    {
#line 101
    *av = path;
#line 102
    av --;
#line 102
    *av = (char *)"/bin/sh";
#line 103
    execve((char const   *)*av, (char * const  *)av, (char * const  *)ev);
    }
  }
  {
#line 107
  uerror(*av);
#line 108
  rc_exit(1);
  }
  switch_default: /* CIL Label */ 
  {
#line 111
  redirq = (Rq *)((void *)0);
#line 112
  rc_wait4(pid, & stat___0, (bool )1);
#line 113
  setstatus(-1, stat___0);
#line 125
  __constr_expr_0.__in = stat___0;
  }
#line 125
  if ((__constr_expr_0.__i & 127) == 0) {
#line 126
    nl_on_intr = (bool )0;
  }
  {
#line 127
  sigchk();
#line 128
  nl_on_intr = (bool )1;
#line 129
  pop_cmdarg((bool )1);
  }
  switch_break: /* CIL Label */ ;
  }
#line 131
  return;
}
}
#line 66 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 224 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/rc.h"
extern void assign(List *s1 , List *s2 , bool stack ) ;
#line 225
extern void qredir(Node *n ) ;
#line 226
extern List *append(List *s1 , List *s2 ) ;
#line 230
extern List *varsub(List *var , List *subs ) ;
#line 296
extern size_t listlen(List *s___0 ) ;
#line 399
extern void statprint(pid_t pid , int i ) ;
#line 401
extern char *strstatus(int s___0 ) ;
#line 9 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/glom.c"
static List *backq(Node *ifs , Node *n ) ;
#line 10
static List *bqinput(List *ifs , int fd ) ;
#line 11
static List *count(List *l ) ;
#line 12
static List *mkcmdarg(Node *n ) ;
#line 14 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/glom.c"
Rq *redirq  =    (Rq *)((void *)0);
#line 16 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/glom.c"
extern List *word(char *w___0 , char *m ) 
{ 
  List *s___0 ;
  void *tmp ;

  {
#line 17
  s___0 = (List *)((void *)0);
#line 18
  if ((unsigned long )w___0 != (unsigned long )((void *)0)) {
    {
#line 19
    tmp = nalloc(sizeof(List ));
#line 19
    s___0 = (List *)tmp;
#line 20
    s___0->w = w___0;
#line 21
    s___0->m = m;
#line 22
    s___0->n = (List *)((void *)0);
    }
  }
#line 24
  return (s___0);
}
}
#line 32 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/glom.c"
extern List *append(List *s1 , List *s2 ) 
{ 
  List *r ;
  List *top ;
  void *tmp ;
  List *tmp___0 ;
  void *tmp___1 ;

  {
#line 34
  if ((unsigned long )s1 == (unsigned long )((void *)0)) {
#line 35
    return (s2);
  }
#line 36
  if ((unsigned long )s2 == (unsigned long )((void *)0)) {
#line 37
    return (s1);
  }
  {
#line 38
  tmp = nalloc(sizeof(List ));
#line 38
  top = (List *)tmp;
#line 38
  r = top;
  }
  {
#line 38
  while (1) {
    while_continue: /* CIL Label */ ;
#line 39
    r->w = s1->w;
#line 40
    r->m = s1->m;
#line 41
    s1 = s1->n;
#line 41
    if ((unsigned long )s1 == (unsigned long )((void *)0)) {
#line 42
      goto while_break;
    }
    {
#line 38
    tmp___1 = nalloc(sizeof(List ));
#line 38
    tmp___0 = (List *)tmp___1;
#line 38
    r->n = tmp___0;
#line 38
    r = tmp___0;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 44
  r->n = s2;
#line 45
  return (top);
}
}
#line 48 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/glom.c"
extern List *concat(List *s1 , List *s2 ) 
{ 
  int n1 ;
  int n2 ;
  List *r ;
  List *top ;
  void *tmp ;
  List *tmp___0 ;
  void *tmp___1 ;
  size_t x ;
  size_t tmp___2 ;
  size_t y ;
  size_t tmp___3 ;
  size_t z ;
  void *tmp___4 ;
  void *tmp___5 ;

  {
#line 51
  if ((unsigned long )s1 == (unsigned long )((void *)0)) {
#line 52
    return (s2);
  }
#line 53
  if ((unsigned long )s2 == (unsigned long )((void *)0)) {
#line 54
    return (s1);
  }
  {
#line 55
  n1 = listnel(s1);
#line 55
  n2 = listnel(s2);
  }
#line 55
  if (n1 != n2) {
#line 55
    if (n1 != 1) {
#line 55
      if (n2 != 1) {
        {
#line 56
        rc_error((char *)"bad concatenation");
        }
      }
    }
  }
  {
#line 57
  tmp = nalloc(sizeof(List ));
#line 57
  top = (List *)tmp;
#line 57
  r = top;
  }
  {
#line 57
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 58
    tmp___2 = strlen((char const   *)s1->w);
#line 58
    x = tmp___2;
#line 59
    tmp___3 = strlen((char const   *)s2->w);
#line 59
    y = tmp___3;
#line 60
    z = (x + y) + 1UL;
#line 61
    tmp___4 = nalloc(z);
#line 61
    r->w = (char *)tmp___4;
#line 62
    strcpy((char */* __restrict  */)r->w, (char const   */* __restrict  */)s1->w);
#line 63
    strcat((char */* __restrict  */)r->w, (char const   */* __restrict  */)s2->w);
    }
#line 64
    if ((unsigned long )s1->m == (unsigned long )((void *)0)) {
#line 64
      if ((unsigned long )s2->m == (unsigned long )((void *)0)) {
#line 65
        r->m = (char *)((void *)0);
      } else {
#line 64
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      {
#line 67
      tmp___5 = nalloc(z);
#line 67
      r->m = (char *)tmp___5;
      }
#line 68
      if ((unsigned long )s1->m == (unsigned long )((void *)0)) {
        {
#line 69
        memset((void *)r->m, 0, x);
        }
      } else {
        {
#line 71
        memcpy((void */* __restrict  */)r->m, (void const   */* __restrict  */)s1->m,
               x);
        }
      }
#line 72
      if ((unsigned long )s2->m == (unsigned long )((void *)0)) {
        {
#line 73
        memset((void *)(r->m + x), 0, y);
        }
      } else {
        {
#line 75
        memcpy((void */* __restrict  */)(r->m + x), (void const   */* __restrict  */)s2->m,
               y);
        }
      }
#line 76
      *(r->m + z) = (char)0;
    }
#line 78
    if (n1 > 1) {
#line 79
      s1 = s1->n;
    }
#line 80
    if (n2 > 1) {
#line 81
      s2 = s2->n;
    }
#line 82
    if ((unsigned long )s1 == (unsigned long )((void *)0)) {
#line 83
      goto while_break;
    } else
#line 82
    if ((unsigned long )s2 == (unsigned long )((void *)0)) {
#line 83
      goto while_break;
    } else
#line 82
    if (n1 == 1) {
#line 82
      if (n2 == 1) {
#line 83
        goto while_break;
      }
    }
    {
#line 57
    tmp___1 = nalloc(sizeof(List ));
#line 57
    tmp___0 = (List *)tmp___1;
#line 57
    r->n = tmp___0;
#line 57
    r = tmp___0;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 85
  r->n = (List *)((void *)0);
#line 86
  return (top);
}
}
#line 89 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/glom.c"
extern List *varsub(List *var , List *subs ) 
{ 
  List *r ;
  List *top ;
  int n ;
  int tmp ;
  int i ;
  int tmp___0 ;
  List *sub ;
  void *tmp___1 ;
  List *tmp___2 ;
  void *tmp___3 ;

  {
  {
#line 91
  tmp = listnel(var);
#line 91
  n = tmp;
#line 92
  r = (List *)((void *)0);
#line 92
  top = r;
  }
  {
#line 92
  while (1) {
    while_continue: /* CIL Label */ ;
#line 92
    if (! ((unsigned long )subs != (unsigned long )((void *)0))) {
#line 92
      goto while_break;
    }
    {
#line 93
    tmp___0 = n2u(subs->w, 10U);
#line 93
    i = tmp___0;
    }
#line 94
    if (i < 1) {
      {
#line 95
      rc_error((char *)"bad subscript");
      }
    }
#line 96
    if (i <= n) {
#line 97
      sub = var;
      {
#line 98
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 98
        i --;
#line 98
        if (! i) {
#line 98
          goto while_break___0;
        }
#line 99
        sub = sub->n;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 100
      if ((unsigned long )top == (unsigned long )((void *)0)) {
        {
#line 101
        tmp___1 = nalloc(sizeof(List ));
#line 101
        r = (List *)tmp___1;
#line 101
        top = r;
        }
      } else {
        {
#line 103
        tmp___3 = nalloc(sizeof(List ));
#line 103
        tmp___2 = (List *)tmp___3;
#line 103
        r->n = tmp___2;
#line 103
        r = tmp___2;
        }
      }
#line 104
      r->w = sub->w;
#line 105
      r->m = sub->m;
    }
#line 92
    subs = subs->n;
  }
  while_break: /* CIL Label */ ;
  }
#line 108
  if ((unsigned long )top != (unsigned long )((void *)0)) {
#line 109
    r->n = (List *)((void *)0);
  }
#line 110
  return (top);
}
}
#line 113 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/glom.c"
extern List *flatten(List *s___0 ) 
{ 
  List *r ;
  size_t step ;
  char *f ;
  void *tmp ;
  char *tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;
  size_t tmp___3 ;
  char *tmp___4 ;

  {
#line 117
  if ((unsigned long )s___0 == (unsigned long )((void *)0)) {
#line 118
    return (s___0);
  } else
#line 117
  if ((unsigned long )s___0->n == (unsigned long )((void *)0)) {
#line 118
    return (s___0);
  }
  {
#line 119
  tmp = nalloc(sizeof(List ));
#line 119
  r = (List *)tmp;
#line 120
  tmp___1 = listlen(s___0);
#line 120
  tmp___2 = nalloc(tmp___1 + 1UL);
#line 120
  tmp___0 = (char *)tmp___2;
#line 120
  r->w = tmp___0;
#line 120
  f = tmp___0;
#line 121
  r->m = (char *)((void *)0);
#line 122
  r->n = (List *)((void *)0);
#line 123
  strcpy((char */* __restrict  */)f, (char const   */* __restrict  */)s___0->w);
#line 124
  tmp___3 = strlen((char const   *)s___0->w);
#line 124
  f += tmp___3;
  }
  {
#line 125
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 126
    tmp___4 = f;
#line 126
    f ++;
#line 126
    *tmp___4 = (char )' ';
#line 127
    s___0 = s___0->n;
#line 128
    step = strlen((char const   *)s___0->w);
#line 129
    memcpy((void */* __restrict  */)f, (void const   */* __restrict  */)s___0->w,
           step);
#line 130
    f += step;
    }
#line 125
    if (! ((unsigned long )s___0->n != (unsigned long )((void *)0))) {
#line 125
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 132
  *f = (char )'\000';
#line 133
  return (r);
}
}
#line 136 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/glom.c"
static List *count(List *l ) 
{ 
  List *s___0 ;
  void *tmp ;
  int tmp___0 ;

  {
  {
#line 137
  tmp = nalloc(sizeof(List ));
#line 137
  s___0 = (List *)tmp;
#line 138
  tmp___0 = listnel(l);
#line 138
  s___0->w = nprint("%d", tmp___0);
#line 139
  s___0->n = (List *)((void *)0);
#line 140
  s___0->m = (char *)((void *)0);
  }
#line 141
  return (s___0);
}
}
#line 144 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/glom.c"
extern void assign(List *s1 , List *s2 , bool stack ) 
{ 
  List *val ;
  int tmp ;
  char *tmp___0 ;
  List *tmp___1 ;
  List *tmp___2 ;

  {
#line 145
  val = s2;
#line 146
  if ((unsigned long )s1 == (unsigned long )((void *)0)) {
    {
#line 147
    rc_error((char *)"null variable name");
    }
  }
#line 148
  if ((unsigned long )s1->n != (unsigned long )((void *)0)) {
    {
#line 149
    rc_error((char *)"multi-word variable name");
    }
  }
#line 150
  if ((int )*(s1->w) == 0) {
    {
#line 151
    rc_error((char *)"zero-length variable name");
    }
  }
  {
#line 152
  tmp = n2u(s1->w, 10U);
  }
#line 152
  if (tmp != -1) {
    {
#line 153
    rc_error((char *)"numeric variable name");
    }
  }
  {
#line 154
  tmp___0 = strchr((char const   *)s1->w, '=');
  }
#line 154
  if ((unsigned long )tmp___0 != (unsigned long )((void *)0)) {
    {
#line 155
    rc_error((char *)"\'=\' in variable name");
    }
  }
#line 156
  if ((int )*(s1->w) == 42) {
#line 156
    if ((int )*(s1->w + 1) == 0) {
      {
#line 157
      tmp___1 = varlookup((char *)"0");
#line 157
      val = append(tmp___1, s2);
      }
    }
  }
#line 158
  if ((unsigned long )s2 != (unsigned long )((void *)0)) {
#line 158
    goto _L;
  } else
#line 158
  if (stack) {
    _L: /* CIL Label */ 
#line 159
    if (dashex) {
      {
#line 160
      prettyprint_var(2, s1->w, val);
      }
    }
    {
#line 161
    varassign(s1->w, val, stack);
#line 162
    tmp___2 = varlookup(s1->w);
#line 162
    alias(s1->w, tmp___2, stack);
    }
  } else {
#line 164
    if (dashex) {
      {
#line 165
      prettyprint_var(2, s1->w, (List *)((void *)0));
      }
    }
    {
#line 166
    varrm(s1->w, stack);
    }
  }
#line 168
  return;
}
}
#line 177 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/glom.c"
static List *bqinput(List *ifs , int fd ) 
{ 
  char *end ;
  char *bufend ;
  char *s___0 ;
  List *r ;
  List *top ;
  List *prev ;
  size_t remain ;
  size_t bufsize___0 ;
  char isifs[256] ;
  int n ;
  int state ;
  void *tmp ;
  void *tmp___0 ;
  size_t m ;
  char *buf ;
  void *tmp___1 ;
  int *tmp___2 ;
  ssize_t tmp___3 ;
  List *tmp___4 ;
  void *tmp___5 ;

  {
  {
#line 184
  memset((void *)(isifs), 0, sizeof(isifs));
#line 185
  isifs['\000'] = (char)1;
  }
  {
#line 185
  while (1) {
    while_continue: /* CIL Label */ ;
#line 185
    if (! ((unsigned long )ifs != (unsigned long )((void *)0))) {
#line 185
      goto while_break;
    }
#line 186
    s___0 = ifs->w;
    {
#line 186
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 186
      if (! ((int )*s___0 != 0)) {
#line 186
        goto while_break___0;
      }
#line 187
      isifs[*((unsigned char *)s___0)] = (char)1;
#line 186
      s___0 ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 185
    ifs = ifs->n;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 188
  bufsize___0 = (size_t )1000;
#line 188
  remain = bufsize___0;
#line 189
  tmp = nalloc(sizeof(List ));
#line 189
  r = (List *)tmp;
#line 189
  top = r;
#line 190
  tmp___0 = nalloc(bufsize___0 + 1UL);
#line 190
  end = (char *)tmp___0;
#line 190
  r->w = end;
#line 191
  r->m = (char *)((void *)0);
#line 192
  state = 0;
#line 193
  prev = (List *)((void *)0);
  }
  {
#line 195
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 196
    if (remain == 0UL) {
#line 197
      m = (size_t )(end - r->w);
      {
#line 199
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 199
        if (! (bufsize___0 < m + 1000UL)) {
#line 199
          goto while_break___2;
        }
#line 200
        bufsize___0 *= 2UL;
      }
      while_break___2: /* CIL Label */ ;
      }
      {
#line 201
      tmp___1 = nalloc(bufsize___0 + 1UL);
#line 201
      buf = (char *)tmp___1;
#line 202
      memcpy((void */* __restrict  */)buf, (void const   */* __restrict  */)r->w,
             m);
#line 203
      r->w = buf;
#line 204
      end = buf + m;
#line 205
      remain = bufsize___0 - m;
      }
    }
    {
#line 207
    tmp___3 = read(fd, (void *)end, remain);
#line 207
    n = (int )tmp___3;
    }
#line 207
    if (n <= 0) {
#line 208
      if (n == 0) {
#line 209
        goto while_break___1;
      } else {
        {
#line 210
        tmp___2 = __errno_location();
        }
#line 210
        if (*tmp___2 == 4) {
#line 211
          return ((List *)((void *)0));
        } else {
          {
#line 213
          uerror((char *)"backquote read");
#line 214
          rc_error((char *)((void *)0));
          }
        }
      }
    }
#line 217
    remain -= (size_t )n;
#line 218
    bufend = end + n;
    {
#line 218
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 218
      if (! ((unsigned long )end < (unsigned long )bufend)) {
#line 218
        goto while_break___3;
      }
#line 219
      if (state == 0) {
#line 220
        if (! isifs[*((unsigned char *)end)]) {
#line 221
          state = 1;
#line 222
          r->w = end;
#line 223
          r->m = (char *)((void *)0);
        }
      } else
#line 226
      if (isifs[*((unsigned char *)end)]) {
        {
#line 227
        state = 0;
#line 228
        *end = (char )'\000';
#line 229
        prev = r;
#line 230
        tmp___5 = nalloc(sizeof(List ));
#line 230
        tmp___4 = (List *)tmp___5;
#line 230
        r->n = tmp___4;
#line 230
        r = tmp___4;
#line 231
        r->w = end + 1;
#line 232
        r->m = (char *)((void *)0);
        }
      }
#line 218
      end ++;
    }
    while_break___3: /* CIL Label */ ;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 236
  if (state == 1) {
#line 237
    *end = (char )'\000';
#line 238
    r->n = (List *)((void *)0);
  } else
#line 240
  if ((unsigned long )prev == (unsigned long )((void *)0)) {
#line 241
    top = (List *)((void *)0);
  } else {
#line 243
    prev->n = (List *)((void *)0);
  }
#line 245
  return (top);
}
}
#line 248 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/glom.c"
static List *backq(Node *ifs , Node *n ) 
{ 
  int p[2] ;
  int sp___0 ;
  pid_t pid ;
  List *bq ;
  int tmp ;
  int tmp___0 ;
  List *tmp___1 ;
  char *tmp___2 ;
  List *tmp___3 ;

  {
#line 252
  if ((unsigned long )n == (unsigned long )((void *)0)) {
#line 253
    return ((List *)((void *)0));
  }
  {
#line 254
  tmp = pipe((int *)(p));
  }
#line 254
  if (tmp < 0) {
    {
#line 255
    uerror((char *)"pipe");
#line 256
    rc_error((char *)((void *)0));
    }
  }
  {
#line 258
  pid = rc_fork();
  }
#line 258
  if (pid == 0) {
    {
#line 259
    mvfd(p[1], 1);
#line 260
    close(p[0]);
#line 261
    redirq = (Rq *)((void *)0);
#line 262
    walk(n, (bool )0);
#line 263
    tmp___0 = getstatus();
#line 263
    exit(tmp___0);
    }
  }
  {
#line 265
  close(p[1]);
#line 266
  tmp___1 = glom(ifs);
#line 266
  bq = bqinput(tmp___1, p[0]);
#line 267
  close(p[0]);
#line 268
  rc_wait4(pid, & sp___0, (bool )1);
#line 269
  statprint(-1, sp___0);
#line 270
  tmp___2 = strstatus(sp___0);
#line 270
  tmp___3 = word(tmp___2, (char *)((void *)0));
#line 270
  varassign((char *)"bqstatus", tmp___3, (bool )0);
#line 271
  sigchk();
  }
#line 272
  return (bq);
}
}
#line 275 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/glom.c"
extern void qredir(Node *n ) 
{ 
  Rq *next ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 277
  if ((unsigned long )redirq == (unsigned long )((void *)0)) {
    {
#line 278
    tmp = nalloc(sizeof(Rq ));
#line 278
    redirq = (Rq *)tmp;
#line 278
    next = redirq;
    }
  } else {
#line 280
    next = redirq;
    {
#line 280
    while (1) {
      while_continue: /* CIL Label */ ;
#line 280
      if (! ((unsigned long )next->n != (unsigned long )((void *)0))) {
#line 280
        goto while_break;
      }
#line 280
      next = next->n;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 282
    tmp___0 = nalloc(sizeof(Rq ));
#line 282
    next->n = (Rq *)tmp___0;
#line 283
    next = next->n;
    }
  }
#line 285
  next->r = n;
#line 286
  next->n = (struct Rq *)((void *)0);
#line 287
  return;
}
}
#line 290 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/glom.c"
static List *mkcmdarg(Node *n ) 
{ 
  char *name ;
  List *ret ;
  void *tmp ;
  Estack *e ;
  void *tmp___0 ;
  Edata efd ;
  int p[2] ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  pid_t tmp___4 ;

  {
  {
#line 292
  tmp = nalloc(sizeof(List ));
#line 292
  ret = (List *)tmp;
#line 293
  tmp___0 = nalloc(sizeof(Estack ));
#line 293
  e = (Estack *)tmp___0;
#line 296
  tmp___1 = pipe((int *)(p));
  }
#line 296
  if (tmp___1 < 0) {
    {
#line 297
    uerror((char *)"pipe");
    }
#line 298
    return ((List *)((void *)0));
  }
  {
#line 300
  tmp___4 = rc_fork();
  }
#line 300
  if (tmp___4 == 0) {
    {
#line 301
    setsigdefaults((bool )0);
#line 302
    tmp___2 = mvfd(p[n->u[0].i == 0], n->u[0].i == 0);
    }
#line 302
    if (tmp___2 < 0) {
      {
#line 303
      exit(1);
      }
    }
    {
#line 304
    close(p[n->u[0].i != 0]);
#line 305
    redirq = (Rq *)((void *)0);
#line 306
    walk(n->u[2].p, (bool )0);
#line 307
    tmp___3 = getstatus();
#line 307
    exit(tmp___3);
    }
  }
  {
#line 311
  name = nprint("/dev/fd/%d", p[n->u[0].i != 0]);
#line 316
  efd.fd = p[n->u[0].i != 0];
#line 317
  except((ecodes )6, efd, e);
#line 318
  close(p[n->u[0].i == 0]);
#line 319
  ret->w = name;
#line 320
  ret->m = (char *)((void *)0);
#line 321
  ret->n = (List *)((void *)0);
  }
#line 322
  return (ret);
}
}
#line 376 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/glom.c"
extern List *glom(Node *n ) 
{ 
  List *v ;
  List *head ;
  List *tail ;
  Node *words ;
  List *tmp ;
  List *tmp___0 ;
  List *tmp___1 ;
  List *tmp___2 ;
  List *tmp___3 ;
  List *tmp___4 ;
  List *tmp___5 ;
  List *tmp___6 ;
  List *tmp___7 ;
  List *tmp___8 ;
  List *tmp___9 ;
  List *tmp___10 ;
  List *tmp___11 ;
  List *tmp___12 ;

  {
#line 379
  if ((unsigned long )n == (unsigned long )((void *)0)) {
#line 380
    return ((List *)((void *)0));
  }
  {
#line 383
  if ((unsigned int )n->type == 31U) {
#line 383
    goto case_31;
  }
#line 383
  if ((unsigned int )n->type == 22U) {
#line 383
    goto case_31;
  }
#line 398
  if ((unsigned int )n->type == 2U) {
#line 398
    goto case_2;
  }
#line 400
  if ((unsigned int )n->type == 8U) {
#line 400
    goto case_8;
  }
#line 404
  if ((unsigned int )n->type == 20U) {
#line 404
    goto case_20;
  }
#line 404
  if ((unsigned int )n->type == 12U) {
#line 404
    goto case_20;
  }
#line 407
  if ((unsigned int )n->type == 30U) {
#line 407
    goto case_30;
  }
#line 409
  if ((unsigned int )n->type == 32U) {
#line 409
    goto case_32;
  }
#line 411
  goto switch_default;
  case_31: /* CIL Label */ 
  case_22: /* CIL Label */ 
#line 384
  words = n->u[0].p;
#line 385
  tail = (List *)((void *)0);
  {
#line 386
  while (1) {
    while_continue: /* CIL Label */ ;
#line 386
    if ((unsigned long )words != (unsigned long )((void *)0)) {
#line 386
      if (! ((unsigned int )words->type == 22U)) {
#line 386
        if (! ((unsigned int )words->type == 31U)) {
#line 386
          goto while_break;
        }
      }
    } else {
#line 386
      goto while_break;
    }
#line 387
    if ((unsigned long )words->u[1].p != (unsigned long )((void *)0)) {
#line 387
      if ((unsigned int )(words->u[1].p)->type != 30U) {
#line 388
        goto while_break;
      }
    }
    {
#line 389
    head = glom(words->u[1].p);
    }
#line 390
    if ((unsigned long )head != (unsigned long )((void *)0)) {
#line 391
      head->n = tail;
#line 392
      tail = head;
    }
#line 394
    words = words->u[0].p;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 396
  tmp = glom(words);
#line 396
  v = append(tmp, tail);
#line 397
  tmp___0 = glom(n->u[1].p);
#line 397
  tmp___1 = append(v, tmp___0);
  }
#line 397
  return (tmp___1);
  case_2: /* CIL Label */ 
  {
#line 399
  tmp___2 = backq(n->u[0].p, n->u[1].p);
  }
#line 399
  return (tmp___2);
  case_8: /* CIL Label */ 
  {
#line 401
  head = glom(n->u[0].p);
#line 402
  tmp___3 = glom(n->u[1].p);
#line 402
  tmp___4 = concat(head, tmp___3);
  }
#line 402
  return (tmp___4);
  case_20: /* CIL Label */ 
  case_12: /* CIL Label */ 
  {
#line 405
  qredir(n);
  }
#line 406
  return ((List *)((void *)0));
  case_30: /* CIL Label */ 
  {
#line 408
  tmp___5 = word(n->u[0].s, n->u[1].s);
  }
#line 408
  return (tmp___5);
  case_32: /* CIL Label */ 
  {
#line 410
  tmp___6 = mkcmdarg(n);
  }
#line 410
  return (tmp___6);
  switch_default: /* CIL Label */ 
  {
#line 417
  v = glom(n->u[0].p);
  }
#line 417
  if ((unsigned long )v == (unsigned long )((void *)0)) {
    {
#line 418
    rc_error((char *)"null variable name");
    }
  }
#line 419
  if ((unsigned long )v->n != (unsigned long )((void *)0)) {
    {
#line 420
    rc_error((char *)"multi-word variable name");
    }
  }
#line 421
  if ((int )*(v->w) == 0) {
    {
#line 422
    rc_error((char *)"zero-length variable name");
    }
  }
#line 423
  if ((int )*(v->w) == 42) {
#line 423
    if ((int )*(v->w + 1) == 0) {
      {
#line 423
      tmp___7 = varlookup(v->w);
#line 423
      v = tmp___7->n;
      }
    } else {
      {
#line 423
      tmp___8 = varlookup(v->w);
#line 423
      v = tmp___8;
      }
    }
  } else {
    {
#line 423
    tmp___8 = varlookup(v->w);
#line 423
    v = tmp___8;
    }
  }
  {
#line 429
  if ((unsigned int )n->type == 9U) {
#line 429
    goto case_9;
  }
#line 431
  if ((unsigned int )n->type == 11U) {
#line 431
    goto case_11;
  }
#line 433
  if ((unsigned int )n->type == 27U) {
#line 433
    goto case_27;
  }
#line 435
  if ((unsigned int )n->type == 28U) {
#line 435
    goto case_28;
  }
#line 425
  goto switch_default___0;
  switch_default___0: /* CIL Label */ 
  {
#line 426
  panic((char *)"unexpected node in glom");
#line 427
  exit(1);
  }
  case_9: /* CIL Label */ 
  {
#line 430
  tmp___9 = count(v);
  }
#line 430
  return (tmp___9);
  case_11: /* CIL Label */ 
  {
#line 432
  tmp___10 = flatten(v);
  }
#line 432
  return (tmp___10);
  case_27: /* CIL Label */ 
#line 434
  return (v);
  case_28: /* CIL Label */ 
  {
#line 436
  tmp___11 = glom(n->u[1].p);
#line 436
  tmp___12 = varsub(v, tmp___11);
  }
#line 436
  return (tmp___12);
  switch_break___0: /* CIL Label */ ;
  }
  switch_break: /* CIL Label */ ;
  }
}
}
#line 765 "/usr/include/stdlib.h"
extern void ( __attribute__((__nonnull__(1,4))) qsort)(void *__base , size_t __nmemb ,
                                                       size_t __size , int (*__compar)(void const   * ,
                                                                                       void const   * ) ) ;
#line 289 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1,2), __leaf__)) strspn)(char const   *__s ,
                                                                                                  char const   *__accept )  __attribute__((__pure__)) ;
#line 220 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/rc.h"
extern bool lmatch(List *s___0 , List *p ) ;
#line 300
extern bool match(char *p , char *m , char *s___0 ) ;
#line 429
extern int starstrcmp(void const   *s1 , void const   *s2 ) ;
#line 263 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) lstat)(char const   * __restrict  __file ,
                                                                                              struct stat * __restrict  __buf ) ;
#line 134 "/usr/include/dirent.h"
extern DIR *( __attribute__((__nonnull__(1))) opendir)(char const   *__name ) ;
#line 149
extern int ( __attribute__((__nonnull__(1))) closedir)(DIR *__dirp ) ;
#line 162
extern struct dirent *( __attribute__((__nonnull__(1))) readdir)(DIR *__dirp ) ;
#line 24 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/glob.c"
static List *dmatch(char *d , char *p , char *m ) ;
#line 25
static List *doglob(char *w___0 , char *m ) ;
#line 26
static List *lglob(List *s___0 , char *p , char *m , size_t slashcount ) ;
#line 27
static List *sort(List *s___0 ) ;
#line 35 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/glob.c"
extern bool lmatch(List *s___0 , List *p ) 
{ 
  List *q ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  bool tmp___3 ;

  {
#line 37
  if ((unsigned long )s___0 == (unsigned long )((void *)0)) {
#line 38
    if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 39
      return ((bool )1);
    }
    {
#line 40
    while (1) {
      while_continue: /* CIL Label */ ;
#line 40
      if (! ((unsigned long )p != (unsigned long )((void *)0))) {
#line 40
        goto while_break;
      }
      {
#line 41
      tmp = strspn((char const   *)p->w, "*");
#line 41
      tmp___0 = strlen((char const   *)p->w);
      }
#line 41
      if (tmp == tmp___0) {
#line 41
        if ((unsigned long )p->m != (unsigned long )((void *)0)) {
          {
#line 41
          tmp___1 = strlen((char const   *)p->m);
#line 41
          tmp___2 = strlen((char const   *)p->w);
          }
#line 41
          if (tmp___1 == tmp___2) {
#line 43
            return ((bool )1);
          }
        }
      }
#line 40
      p = p->n;
    }
    while_break: /* CIL Label */ ;
    }
#line 44
    return ((bool )0);
  }
  {
#line 46
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 46
    if (! ((unsigned long )s___0 != (unsigned long )((void *)0))) {
#line 46
      goto while_break___0;
    }
#line 47
    q = p;
    {
#line 47
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 47
      if (! ((unsigned long )q != (unsigned long )((void *)0))) {
#line 47
        goto while_break___1;
      }
      {
#line 48
      tmp___3 = match(q->w, q->m, s___0->w);
      }
#line 48
      if (tmp___3) {
#line 49
        return ((bool )1);
      }
#line 47
      q = q->n;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 46
    s___0 = s___0->n;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 50
  return ((bool )0);
}
}
#line 58 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/glob.c"
extern List *glob(List *s___0 ) 
{ 
  List *top ;
  List *r ;
  bool meta ;
  void *tmp ;
  List *tmp___0 ;
  void *tmp___1 ;
  List *tmp___2 ;
  List *tmp___3 ;

  {
#line 61
  r = s___0;
#line 61
  meta = (bool )0;
  {
#line 61
  while (1) {
    while_continue: /* CIL Label */ ;
#line 61
    if (! ((unsigned long )r != (unsigned long )((void *)0))) {
#line 61
      goto while_break;
    }
#line 62
    if ((unsigned long )r->m != (unsigned long )((void *)0)) {
#line 63
      meta = (bool )1;
    }
#line 61
    r = r->n;
  }
  while_break: /* CIL Label */ ;
  }
#line 64
  if (! meta) {
#line 65
    return (s___0);
  }
#line 66
  r = (List *)((void *)0);
#line 66
  top = r;
  {
#line 66
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 66
    if (! ((unsigned long )s___0 != (unsigned long )((void *)0))) {
#line 66
      goto while_break___0;
    }
#line 67
    if ((unsigned long )s___0->m == (unsigned long )((void *)0)) {
#line 68
      if ((unsigned long )top == (unsigned long )((void *)0)) {
        {
#line 69
        tmp = nalloc(sizeof(List ));
#line 69
        r = (List *)tmp;
#line 69
        top = r;
        }
      } else {
        {
#line 71
        tmp___1 = nalloc(sizeof(List ));
#line 71
        tmp___0 = (List *)tmp___1;
#line 71
        r->n = tmp___0;
#line 71
        r = tmp___0;
        }
      }
#line 72
      r->w = s___0->w;
    } else {
#line 74
      if ((unsigned long )top == (unsigned long )((void *)0)) {
        {
#line 75
        tmp___2 = doglob(s___0->w, s___0->m);
#line 75
        r = sort(tmp___2);
#line 75
        top = r;
        }
      } else {
        {
#line 77
        tmp___3 = doglob(s___0->w, s___0->m);
#line 77
        r->n = sort(tmp___3);
        }
      }
      {
#line 78
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 78
        if (! ((unsigned long )r->n != (unsigned long )((void *)0))) {
#line 78
          goto while_break___1;
        }
#line 79
        r = r->n;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
#line 66
    s___0 = s___0->n;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 82
  r->n = (List *)((void *)0);
#line 83
  return (top);
}
}
#line 91 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/glob.c"
static DIR *dirp  ;
#line 92 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/glob.c"
static struct dirent *dp  ;
#line 93 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/glob.c"
static struct stat s  ;
#line 88 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/glob.c"
static List *dmatch(char *d , char *p , char *m ) 
{ 
  bool matched ;
  List *top ;
  List *r ;
  int i ;
  char *path ;
  char *tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  size_t tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;
  void *tmp___5 ;
  List *tmp___6 ;
  void *tmp___7 ;
  size_t tmp___8 ;
  void *tmp___9 ;
  bool tmp___10 ;

  {
#line 100
  matched = (bool )1;
#line 101
  if ((unsigned long )m != (unsigned long )((void *)0)) {
#line 102
    i = 0;
    {
#line 102
    while (1) {
      while_continue: /* CIL Label */ ;
#line 102
      if (! ((int )*(p + i) != 0)) {
#line 102
        goto while_break;
      }
#line 103
      if (*(m + i)) {
#line 104
        matched = (bool )0;
#line 105
        goto while_break;
      }
#line 102
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 108
  if (matched) {
    {
#line 109
    tmp = nprint("%s/%s", d, p);
#line 109
    path = tmp;
#line 110
    tmp___0 = lstat((char const   */* __restrict  */)path, (struct stat */* __restrict  */)(& s));
    }
#line 110
    if (tmp___0 < 0) {
#line 111
      return ((List *)((void *)0));
    }
    {
#line 112
    tmp___1 = nalloc(sizeof(List ));
#line 112
    r = (List *)tmp___1;
#line 113
    tmp___2 = strlen((char const   *)p);
#line 113
    tmp___3 = nalloc(tmp___2 + 1UL);
#line 113
    r->w = strcpy((char */* __restrict  */)((char *)tmp___3), (char const   */* __restrict  */)p);
#line 114
    r->m = (char *)((void *)0);
#line 115
    r->n = (List *)((void *)0);
    }
#line 116
    return (r);
  }
#line 119
  r = (List *)((void *)0);
#line 119
  top = r;
#line 120
  if ((int )*d == 0) {
#line 120
    d = (char *)"/";
  }
  {
#line 121
  dirp = opendir((char const   *)d);
  }
#line 121
  if ((unsigned long )dirp == (unsigned long )((void *)0)) {
#line 122
    return ((List *)((void *)0));
  }
  {
#line 124
  tmp___4 = stat((char const   */* __restrict  */)d, (struct stat */* __restrict  */)(& s));
  }
#line 124
  if (tmp___4 < 0) {
    {
#line 125
    closedir(dirp);
    }
#line 126
    return ((List *)((void *)0));
  } else
#line 124
  if ((s.st_mode & 61440U) != 16384U) {
    {
#line 125
    closedir(dirp);
    }
#line 126
    return ((List *)((void *)0));
  }
  {
#line 128
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 128
    dp = readdir(dirp);
    }
#line 128
    if (! ((unsigned long )dp != (unsigned long )((void *)0))) {
#line 128
      goto while_break___0;
    }
#line 129
    if ((int )dp->d_name[0] != 46) {
#line 129
      goto _L;
    } else
#line 129
    if ((int )*p == 46) {
      _L: /* CIL Label */ 
      {
#line 129
      tmp___10 = match(p, m, dp->d_name);
      }
#line 129
      if (tmp___10) {
#line 130
        matched = (bool )1;
#line 131
        if ((unsigned long )top == (unsigned long )((void *)0)) {
          {
#line 132
          tmp___5 = nalloc(sizeof(List ));
#line 132
          r = (List *)tmp___5;
#line 132
          top = r;
          }
        } else {
          {
#line 134
          tmp___7 = nalloc(sizeof(List ));
#line 134
          tmp___6 = (List *)tmp___7;
#line 134
          r->n = tmp___6;
#line 134
          r = tmp___6;
          }
        }
        {
#line 135
        tmp___8 = strlen((char const   *)(dp->d_name));
#line 135
        tmp___9 = nalloc(tmp___8 + 1UL);
#line 135
        r->w = strcpy((char */* __restrict  */)((char *)tmp___9), (char const   */* __restrict  */)(dp->d_name));
#line 136
        r->m = (char *)((void *)0);
        }
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 138
  closedir(dirp);
  }
#line 139
  if (! matched) {
#line 140
    return ((List *)((void *)0));
  }
#line 141
  r->n = (List *)((void *)0);
#line 142
  return (top);
}
}
#line 154 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/glob.c"
static struct __anonstruct_slash_52 slash  ;
#line 152 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/glob.c"
static List *lglob(List *s___0 , char *p , char *m , size_t slashcount ) 
{ 
  List *q ;
  List *r ;
  List *top ;
  List foo ;
  void *tmp ;

  {
#line 158
  if (slashcount + 1UL > slash.size) {
    {
#line 159
    slash.size = 2UL * (slashcount + 1UL);
#line 160
    tmp = erealloc((void *)slash.l.w, slash.size);
#line 160
    slash.l.w = (char *)tmp;
    }
  }
#line 162
  *(slash.l.w + slashcount) = (char )'\000';
  {
#line 163
  while (1) {
    while_continue: /* CIL Label */ ;
#line 163
    if (! (slashcount > 0UL)) {
#line 163
      goto while_break;
    }
#line 164
    slashcount --;
#line 164
    *(slash.l.w + slashcount) = (char )'/';
  }
  while_break: /* CIL Label */ ;
  }
#line 165
  r = (List *)((void *)0);
#line 165
  top = r;
  {
#line 165
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 165
    if (! ((unsigned long )s___0 != (unsigned long )((void *)0))) {
#line 165
      goto while_break___0;
    }
    {
#line 166
    q = dmatch(s___0->w, p, m);
    }
#line 167
    if ((unsigned long )q != (unsigned long )((void *)0)) {
#line 168
      foo.w = s___0->w;
#line 169
      foo.m = (char *)((void *)0);
#line 170
      foo.n = (List *)((void *)0);
#line 171
      if ((int )*(s___0->w + 0) == 47) {
#line 171
        if (! ((int )*(s___0->w + 1) == 0)) {
          {
#line 172
          q = concat(& slash.l, q);
          }
        }
      } else {
        {
#line 172
        q = concat(& slash.l, q);
        }
      }
      {
#line 173
      q = concat(& foo, q);
      }
#line 174
      if ((unsigned long )r == (unsigned long )((void *)0)) {
#line 175
        r = q;
#line 175
        top = r;
      } else {
#line 177
        r->n = q;
      }
      {
#line 178
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 178
        if (! ((unsigned long )r->n != (unsigned long )((void *)0))) {
#line 178
          goto while_break___1;
        }
#line 179
        r = r->n;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
#line 165
    s___0 = s___0->n;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 182
  return (top);
}
}
#line 191 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/glob.c"
static char *dir  =    (char *)((void *)0);
#line 191 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/glob.c"
static char *pattern  =    (char *)((void *)0);
#line 191 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/glob.c"
static char *metadir  =    (char *)((void *)0);
#line 191 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/glob.c"
static char *metapattern  =    (char *)((void *)0);
#line 192 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/glob.c"
static size_t dsize  =    (size_t )0;
#line 190 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/glob.c"
static List *doglob(char *w___0 , char *m ) 
{ 
  char *d ;
  char *p ;
  char *md ;
  char *mp ;
  size_t psize ;
  char *s___0 ;
  List firstdir ;
  List *matched ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  size_t tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  size_t slashcount ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  void *tmp___12 ;

  {
  {
#line 195
  s___0 = w___0;
#line 198
  tmp___3 = strlen((char const   *)w___0);
#line 198
  psize = tmp___3 + 1UL;
  }
#line 198
  if (psize > dsize) {
#line 198
    goto _L;
  } else
#line 198
  if ((unsigned long )dir == (unsigned long )((void *)0)) {
    _L: /* CIL Label */ 
    {
#line 199
    efree((void *)dir);
#line 199
    efree((void *)pattern);
#line 199
    efree((void *)metadir);
#line 199
    efree((void *)metapattern);
#line 200
    tmp = ealloc(psize);
#line 200
    dir = (char *)tmp;
#line 201
    tmp___0 = ealloc(psize);
#line 201
    pattern = (char *)tmp___0;
#line 202
    tmp___1 = ealloc(psize);
#line 202
    metadir = (char *)tmp___1;
#line 203
    tmp___2 = ealloc(psize);
#line 203
    metapattern = (char *)tmp___2;
#line 204
    dsize = psize;
    }
  }
#line 206
  d = dir;
#line 207
  p = pattern;
#line 208
  md = metadir;
#line 209
  mp = metapattern;
  {
#line 210
  while (1) {
    while_continue: /* CIL Label */ ;
#line 210
    if ((int )*s___0 != 47) {
#line 210
      if (! ((int )*s___0 != 0)) {
#line 210
        goto while_break;
      }
    } else {
#line 210
      goto while_break;
    }
#line 211
    tmp___4 = d;
#line 211
    d ++;
#line 211
    tmp___5 = s___0;
#line 211
    s___0 ++;
#line 211
    *tmp___4 = *tmp___5;
#line 212
    tmp___6 = md;
#line 212
    md ++;
#line 212
    tmp___7 = m;
#line 212
    m ++;
#line 212
    *tmp___6 = *tmp___7;
  }
  while_break: /* CIL Label */ ;
  }
#line 214
  *d = (char )'\000';
#line 220
  if ((int )*s___0 == 0) {
    {
#line 221
    matched = dmatch((char *)".", dir, metadir);
    }
#line 222
    goto end;
  }
#line 224
  if ((int )*w___0 == 47) {
#line 225
    firstdir.w = dir;
#line 226
    firstdir.m = metadir;
#line 227
    firstdir.n = (List *)((void *)0);
#line 228
    matched = & firstdir;
  } else {
    {
#line 234
    matched = dmatch((char *)".", dir, metadir);
    }
  }
  {
#line 236
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 238
    sigchk();
#line 239
    slashcount = (size_t )0;
    }
    {
#line 239
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 239
      if (! ((int )*s___0 == 47)) {
#line 239
        goto while_break___1;
      }
#line 240
      slashcount ++;
#line 239
      s___0 ++;
#line 239
      m ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 241
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 241
      if ((int )*s___0 != 47) {
#line 241
        if (! ((int )*s___0 != 0)) {
#line 241
          goto while_break___2;
        }
      } else {
#line 241
        goto while_break___2;
      }
#line 242
      tmp___8 = p;
#line 242
      p ++;
#line 242
      tmp___9 = s___0;
#line 242
      s___0 ++;
#line 242
      *tmp___8 = *tmp___9;
#line 242
      tmp___10 = mp;
#line 242
      mp ++;
#line 242
      tmp___11 = m;
#line 242
      m ++;
#line 242
      *tmp___10 = *tmp___11;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 243
    *p = (char )'\000';
#line 244
    matched = lglob(matched, pattern, metapattern, slashcount);
#line 245
    p = pattern;
#line 245
    mp = metapattern;
    }
#line 236
    if (! ((int )*s___0 != 0)) {
#line 236
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  end: 
#line 247
  if ((unsigned long )matched == (unsigned long )((void *)0)) {
    {
#line 248
    tmp___12 = nalloc(sizeof(List ));
#line 248
    matched = (List *)tmp___12;
#line 249
    matched->w = w___0;
#line 250
    matched->m = (char *)((void *)0);
#line 251
    matched->n = (List *)((void *)0);
    }
  }
#line 253
  return (matched);
}
}
#line 256 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/glob.c"
static List *sort(List *s___0 ) 
{ 
  size_t nel ;
  int tmp ;
  char **a ;
  List *t ;
  char **tmp___0 ;

  {
  {
#line 257
  tmp = listnel(s___0);
#line 257
  nel = (size_t )tmp;
  }
#line 258
  if (nel > 1UL) {
    {
#line 261
    a = list2array(s___0, (bool )0);
#line 261
    qsort((void *)a, nel, sizeof(char *), & starstrcmp);
#line 262
    t = s___0;
    }
    {
#line 262
    while (1) {
      while_continue: /* CIL Label */ ;
#line 262
      if (! ((unsigned long )t != (unsigned long )((void *)0))) {
#line 262
        goto while_break;
      }
#line 263
      tmp___0 = a;
#line 263
      a ++;
#line 263
      t->w = *tmp___0;
#line 262
      t = t->n;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 265
  return (s___0);
}
}
#line 413 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
#line 12 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/utils.c"
extern void pr_error(char *s___0 , int offset ) 
{ 


  {
#line 13
  if ((unsigned long )s___0 != (unsigned long )((void *)0)) {
#line 14
    if (interactive) {
      {
#line 15
      fprint(2, "%s\n", s___0);
      }
    } else {
      {
#line 17
      fprint(2, "line %d: %s\n", lineno + offset, s___0);
      }
    }
  }
#line 19
  return;
}
}
#line 23 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/utils.c"
extern void uerror(char *s___0 ) 
{ 
  char *err ;
  int *tmp ;

  {
  {
#line 26
  tmp = __errno_location();
#line 26
  err = strerror(*tmp);
  }
#line 27
  if (! err) {
#line 27
    err = (char *)"unknown error";
  }
#line 29
  if (s___0) {
    {
#line 30
    fprint(2, "%s: %s\n", s___0, err);
    }
  } else {
    {
#line 32
    fprint(2, "%s\n", err);
    }
  }
#line 33
  return;
}
}
#line 39
extern  __attribute__((__noreturn__)) void panic(char *s___0 ) ;
#line 39 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/utils.c"
extern void panic(char *s___0 ) 
{ 
  size_t tmp ;

  {
  {
#line 40
  write(2, (void const   *)"rc panic: ", sizeof("rc panic: ") - 1UL);
#line 41
  tmp = strlen((char const   *)s___0);
#line 41
  write(2, (void const   *)s___0, tmp);
#line 42
  write(2, (void const   *)"!\n", (size_t )2);
#line 43
  exit(1);
  }
}
}
#line 48 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/utils.c"
extern int n2u(char *s___0 , unsigned int base ) 
{ 
  unsigned int i ;
  unsigned int j ;

  {
#line 50
  i = 0U;
  {
#line 50
  while (1) {
    while_continue: /* CIL Label */ ;
#line 50
    if (! ((int )*s___0 != 0)) {
#line 50
      goto while_break;
    }
#line 51
    j = (unsigned int )*s___0 - 48U;
#line 52
    if (j >= base) {
#line 53
      return (-1);
    }
#line 54
    i = i * base + j;
#line 50
    s___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 56
  return ((int )i);
}
}
#line 61 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/utils.c"
extern int starstrcmp(void const   *s1 , void const   *s2 ) 
{ 
  int tmp ;

  {
  {
#line 62
  tmp = strcmp((char const   *)*((char * const  *)s1), (char const   *)*((char * const  *)s2));
  }
#line 62
  return (tmp);
}
}
#line 67 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/utils.c"
extern bool isabsolute(char *path ) 
{ 
  int tmp ;

  {
#line 68
  if ((int )*(path + 0) == 47) {
#line 68
    tmp = 1;
  } else
#line 68
  if ((int )*(path + 0) == 46) {
#line 68
    if ((int )*(path + 1) == 47) {
#line 68
      tmp = 1;
    } else
#line 68
    if ((int )*(path + 1) == 46) {
#line 68
      if ((int )*(path + 2) == 47) {
#line 68
        tmp = 1;
      } else {
#line 68
        tmp = 0;
      }
    } else {
#line 68
      tmp = 0;
    }
  } else {
#line 68
    tmp = 0;
  }
#line 68
  return ((bool )tmp);
}
}
#line 74 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/utils.c"
extern int mvfd(int i , int j ) 
{ 
  int s___0 ;
  int tmp ;

  {
#line 75
  if (i != j) {
    {
#line 76
    tmp = dup2(i, j);
#line 76
    s___0 = tmp;
#line 77
    close(i);
    }
#line 78
    return (s___0);
  }
#line 80
  return (0);
}
}
#line 214 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/rc.h"
extern int rc_getopt(int argc , char **argv , char *opts ) ;
#line 216
int rc_optind ;
#line 216
int rc_opterr ;
#line 216 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/rc.h"
int rc_optopt  ;
#line 217 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/rc.h"
char *rc_optarg  ;
#line 3 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/getopt.c"
int rc_opterr  =    1;
#line 4 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/getopt.c"
int rc_optind  =    1;
#line 11 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/getopt.c"
static int sp  =    1;
#line 10 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/getopt.c"
extern int rc_getopt(int argc , char **argv , char *opts ) 
{ 
  int c ;
  char *cp ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 14
  if (rc_optind == 0) {
#line 15
    sp = 1;
#line 15
    rc_optind = sp;
  }
#line 16
  if (sp == 1) {
#line 17
    if (rc_optind >= argc) {
#line 18
      return (-1);
    } else
#line 17
    if ((int )*(*(argv + rc_optind) + 0) != 45) {
#line 18
      return (-1);
    } else
#line 17
    if ((int )*(*(argv + rc_optind) + 1) == 0) {
#line 18
      return (-1);
    } else {
      {
#line 19
      tmp = strcmp((char const   *)*(argv + rc_optind), "--");
      }
#line 19
      if (tmp == 0) {
#line 20
        rc_optind ++;
#line 21
        return (-1);
      }
    }
  }
#line 24
  c = (int )*(*(argv + rc_optind) + sp);
#line 24
  rc_optopt = c;
#line 25
  if (c == 58) {
#line 25
    goto _L;
  } else {
    {
#line 25
    cp = strchr((char const   *)opts, c);
    }
#line 25
    if ((unsigned long )cp == (unsigned long )((char *)0)) {
      _L: /* CIL Label */ 
      {
#line 26
      fprint(2, "%s: bad option: -%c\n", *(argv + 0), c);
#line 27
      sp ++;
      }
#line 27
      if ((int )*(*(argv + rc_optind) + sp) == 0) {
#line 28
        rc_optind ++;
#line 29
        sp = 1;
      }
#line 31
      return ('?');
    }
  }
#line 33
  cp ++;
#line 33
  if ((int )*cp == 58) {
#line 34
    if ((int )*(*(argv + rc_optind) + (sp + 1)) != 0) {
#line 35
      tmp___0 = rc_optind;
#line 35
      rc_optind ++;
#line 35
      rc_optarg = *(argv + tmp___0) + (sp + 1);
    } else {
#line 36
      rc_optind ++;
#line 36
      if (rc_optind >= argc) {
        {
#line 37
        fprint(2, "%s: option requires an argument -- %c\n", *(argv + 0), c);
#line 38
        sp = 1;
        }
#line 39
        return ('?');
      } else {
#line 41
        tmp___1 = rc_optind;
#line 41
        rc_optind ++;
#line 41
        rc_optarg = *(argv + tmp___1);
      }
    }
#line 42
    sp = 1;
  } else {
#line 44
    sp ++;
#line 44
    if ((int )*(*(argv + rc_optind) + sp) == 0) {
#line 45
      sp = 1;
#line 46
      rc_optind ++;
    }
#line 48
    rc_optarg = (char *)((void *)0);
  }
#line 50
  return (c);
}
}
#line 421 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/rc.h"
extern Node *mk(int t  , ...) ;
#line 422
extern Node *treecpy(Node *s___0 , void *(*alloc)(size_t  ) ) ;
#line 423
extern void treefree(Node *s___0 ) ;
#line 7 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/tree.c"
extern Node *mk(int t  , ...) 
{ 
  va_list ap ;
  Node *n ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  void *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  void *tmp___7 ;
  Node *tmp___8 ;
  void *tmp___9 ;
  Node *tmp___10 ;
  Node *tmp___11 ;
  void *tmp___12 ;
  Node *tmp___13 ;
  Node *tmp___14 ;
  Node *tmp___15 ;
  void *tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  Node *tmp___19 ;
  Node *tmp___20 ;
  void *tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  Node *tmp___24 ;

  {
  {
#line 10
  __builtin_va_start(ap, t);
  }
  {
#line 15
  if (t == 12) {
#line 15
    goto case_12;
  }
#line 21
  if (t == 30) {
#line 21
    goto case_30;
  }
#line 29
  if (t == 24) {
#line 29
    goto case_24;
  }
#line 29
  if (t == 27) {
#line 29
    goto case_24;
  }
#line 29
  if (t == 23) {
#line 29
    goto case_24;
  }
#line 29
  if (t == 21) {
#line 29
    goto case_24;
  }
#line 29
  if (t == 11) {
#line 29
    goto case_24;
  }
#line 29
  if (t == 9) {
#line 29
    goto case_24;
  }
#line 29
  if (t == 6) {
#line 29
    goto case_24;
  }
#line 29
  if (t == 3) {
#line 29
    goto case_24;
  }
#line 36
  if (t == 31) {
#line 36
    goto case_31;
  }
#line 36
  if (t == 29) {
#line 36
    goto case_31;
  }
#line 36
  if (t == 28) {
#line 36
    goto case_31;
  }
#line 36
  if (t == 26) {
#line 36
    goto case_31;
  }
#line 36
  if (t == 25) {
#line 36
    goto case_31;
  }
#line 36
  if (t == 22) {
#line 36
    goto case_31;
  }
#line 36
  if (t == 19) {
#line 36
    goto case_31;
  }
#line 36
  if (t == 17) {
#line 36
    goto case_31;
  }
#line 36
  if (t == 5) {
#line 36
    goto case_31;
  }
#line 36
  if (t == 14) {
#line 36
    goto case_31;
  }
#line 36
  if (t == 16) {
#line 36
    goto case_31;
  }
#line 36
  if (t == 13) {
#line 36
    goto case_31;
  }
#line 36
  if (t == 10) {
#line 36
    goto case_31;
  }
#line 36
  if (t == 8) {
#line 36
    goto case_31;
  }
#line 36
  if (t == 7) {
#line 36
    goto case_31;
  }
#line 36
  if (t == 4) {
#line 36
    goto case_31;
  }
#line 36
  if (t == 2) {
#line 36
    goto case_31;
  }
#line 36
  if (t == 1) {
#line 36
    goto case_31;
  }
#line 36
  if (t == 0) {
#line 36
    goto case_31;
  }
#line 41
  if (t == 15) {
#line 41
    goto case_15;
  }
#line 47
  if (t == 18) {
#line 47
    goto case_18;
  }
#line 55
  if (t == 32) {
#line 55
    goto case_32;
  }
#line 55
  if (t == 20) {
#line 55
    goto case_32;
  }
#line 12
  goto switch_default;
  switch_default: /* CIL Label */ 
  {
#line 13
  panic((char *)"unexpected node in mk");
  }
  case_12: /* CIL Label */ 
  {
#line 16
  tmp = nalloc((size_t )((char *)(& ((Node *)0)->u[3]) - (char *)0));
#line 16
  n = (Node *)tmp;
#line 17
  tmp___0 = __builtin_va_arg(ap, int );
#line 17
  n->u[0].i = tmp___0;
#line 18
  tmp___1 = __builtin_va_arg(ap, int );
#line 18
  n->u[1].i = tmp___1;
#line 19
  tmp___2 = __builtin_va_arg(ap, int );
#line 19
  n->u[2].i = tmp___2;
  }
#line 20
  goto switch_break;
  case_30: /* CIL Label */ 
  {
#line 22
  tmp___3 = nalloc((size_t )((char *)(& ((Node *)0)->u[3]) - (char *)0));
#line 22
  n = (Node *)tmp___3;
#line 23
  tmp___4 = __builtin_va_arg(ap, char *);
#line 23
  n->u[0].s = tmp___4;
#line 24
  tmp___5 = __builtin_va_arg(ap, char *);
#line 24
  n->u[1].s = tmp___5;
#line 25
  tmp___6 = __builtin_va_arg(ap, int );
#line 25
  n->u[2].i = tmp___6;
  }
#line 26
  goto switch_break;
  case_24: /* CIL Label */ 
  case_27: /* CIL Label */ 
  case_23: /* CIL Label */ 
  case_21: /* CIL Label */ 
  case_11: /* CIL Label */ 
  case_9: /* CIL Label */ 
  case_6: /* CIL Label */ 
  case_3: /* CIL Label */ 
  {
#line 30
  tmp___7 = nalloc((size_t )((char *)(& ((Node *)0)->u[1]) - (char *)0));
#line 30
  n = (Node *)tmp___7;
#line 31
  tmp___8 = __builtin_va_arg(ap, Node *);
#line 31
  n->u[0].p = tmp___8;
  }
#line 32
  goto switch_break;
  case_31: /* CIL Label */ 
  case_29: /* CIL Label */ 
  case_28: /* CIL Label */ 
  case_26: /* CIL Label */ 
  case_25: /* CIL Label */ 
  case_22: /* CIL Label */ 
  case_19: /* CIL Label */ 
  case_17: /* CIL Label */ 
  case_5: /* CIL Label */ 
  case_14: /* CIL Label */ 
  case_16: /* CIL Label */ 
  case_13: /* CIL Label */ 
  case_10: /* CIL Label */ 
  case_8: /* CIL Label */ 
  case_7: /* CIL Label */ 
  case_4: /* CIL Label */ 
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
  case_0: /* CIL Label */ 
  {
#line 37
  tmp___9 = nalloc((size_t )((char *)(& ((Node *)0)->u[2]) - (char *)0));
#line 37
  n = (Node *)tmp___9;
#line 38
  tmp___10 = __builtin_va_arg(ap, Node *);
#line 38
  n->u[0].p = tmp___10;
#line 39
  tmp___11 = __builtin_va_arg(ap, Node *);
#line 39
  n->u[1].p = tmp___11;
  }
#line 40
  goto switch_break;
  case_15: /* CIL Label */ 
  {
#line 42
  tmp___12 = nalloc((size_t )((char *)(& ((Node *)0)->u[3]) - (char *)0));
#line 42
  n = (Node *)tmp___12;
#line 43
  tmp___13 = __builtin_va_arg(ap, Node *);
#line 43
  n->u[0].p = tmp___13;
#line 44
  tmp___14 = __builtin_va_arg(ap, Node *);
#line 44
  n->u[1].p = tmp___14;
#line 45
  tmp___15 = __builtin_va_arg(ap, Node *);
#line 45
  n->u[2].p = tmp___15;
  }
#line 46
  goto switch_break;
  case_18: /* CIL Label */ 
  {
#line 48
  tmp___16 = nalloc((size_t )((char *)(& ((Node *)0)->u[4]) - (char *)0));
#line 48
  n = (Node *)tmp___16;
#line 49
  tmp___17 = __builtin_va_arg(ap, int );
#line 49
  n->u[0].i = tmp___17;
#line 50
  tmp___18 = __builtin_va_arg(ap, int );
#line 50
  n->u[1].i = tmp___18;
#line 51
  tmp___19 = __builtin_va_arg(ap, Node *);
#line 51
  n->u[2].p = tmp___19;
#line 52
  tmp___20 = __builtin_va_arg(ap, Node *);
#line 52
  n->u[3].p = tmp___20;
  }
#line 53
  goto switch_break;
  case_32: /* CIL Label */ 
  case_20: /* CIL Label */ 
  {
#line 56
  tmp___21 = nalloc((size_t )((char *)(& ((Node *)0)->u[3]) - (char *)0));
#line 56
  n = (Node *)tmp___21;
#line 57
  tmp___22 = __builtin_va_arg(ap, int );
#line 57
  n->u[0].i = tmp___22;
#line 58
  tmp___23 = __builtin_va_arg(ap, int );
#line 58
  n->u[1].i = tmp___23;
#line 59
  tmp___24 = __builtin_va_arg(ap, Node *);
#line 59
  n->u[2].p = tmp___24;
  }
#line 60
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 62
  n->type = (nodetype )t;
#line 63
  __builtin_va_end(ap);
  }
#line 64
  return (n);
}
}
#line 69 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/tree.c"
extern Node *treecpy(Node *s___0 , void *(*alloc)(size_t  ) ) 
{ 
  Node *n ;
  void *tmp ;
  void *tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;
  size_t i ;
  size_t tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  void *tmp___9 ;

  {
#line 71
  if ((unsigned long )s___0 == (unsigned long )((void *)0)) {
#line 72
    return ((Node *)((void *)0));
  }
  {
#line 77
  if ((unsigned int )s___0->type == 12U) {
#line 77
    goto case_12;
  }
#line 83
  if ((unsigned int )s___0->type == 30U) {
#line 83
    goto case_30;
  }
#line 94
  if ((unsigned int )s___0->type == 27U) {
#line 94
    goto case_27;
  }
#line 94
  if ((unsigned int )s___0->type == 23U) {
#line 94
    goto case_27;
  }
#line 94
  if ((unsigned int )s___0->type == 21U) {
#line 94
    goto case_27;
  }
#line 94
  if ((unsigned int )s___0->type == 11U) {
#line 94
    goto case_27;
  }
#line 94
  if ((unsigned int )s___0->type == 9U) {
#line 94
    goto case_27;
  }
#line 94
  if ((unsigned int )s___0->type == 24U) {
#line 94
    goto case_27;
  }
#line 94
  if ((unsigned int )s___0->type == 6U) {
#line 94
    goto case_27;
  }
#line 94
  if ((unsigned int )s___0->type == 3U) {
#line 94
    goto case_27;
  }
#line 101
  if ((unsigned int )s___0->type == 31U) {
#line 101
    goto case_31;
  }
#line 101
  if ((unsigned int )s___0->type == 29U) {
#line 101
    goto case_31;
  }
#line 101
  if ((unsigned int )s___0->type == 28U) {
#line 101
    goto case_31;
  }
#line 101
  if ((unsigned int )s___0->type == 26U) {
#line 101
    goto case_31;
  }
#line 101
  if ((unsigned int )s___0->type == 25U) {
#line 101
    goto case_31;
  }
#line 101
  if ((unsigned int )s___0->type == 22U) {
#line 101
    goto case_31;
  }
#line 101
  if ((unsigned int )s___0->type == 19U) {
#line 101
    goto case_31;
  }
#line 101
  if ((unsigned int )s___0->type == 17U) {
#line 101
    goto case_31;
  }
#line 101
  if ((unsigned int )s___0->type == 5U) {
#line 101
    goto case_31;
  }
#line 101
  if ((unsigned int )s___0->type == 14U) {
#line 101
    goto case_31;
  }
#line 101
  if ((unsigned int )s___0->type == 16U) {
#line 101
    goto case_31;
  }
#line 101
  if ((unsigned int )s___0->type == 13U) {
#line 101
    goto case_31;
  }
#line 101
  if ((unsigned int )s___0->type == 10U) {
#line 101
    goto case_31;
  }
#line 101
  if ((unsigned int )s___0->type == 8U) {
#line 101
    goto case_31;
  }
#line 101
  if ((unsigned int )s___0->type == 7U) {
#line 101
    goto case_31;
  }
#line 101
  if ((unsigned int )s___0->type == 4U) {
#line 101
    goto case_31;
  }
#line 101
  if ((unsigned int )s___0->type == 2U) {
#line 101
    goto case_31;
  }
#line 101
  if ((unsigned int )s___0->type == 1U) {
#line 101
    goto case_31;
  }
#line 101
  if ((unsigned int )s___0->type == 0U) {
#line 101
    goto case_31;
  }
#line 106
  if ((unsigned int )s___0->type == 15U) {
#line 106
    goto case_15;
  }
#line 112
  if ((unsigned int )s___0->type == 18U) {
#line 112
    goto case_18;
  }
#line 120
  if ((unsigned int )s___0->type == 32U) {
#line 120
    goto case_32;
  }
#line 120
  if ((unsigned int )s___0->type == 20U) {
#line 120
    goto case_32;
  }
#line 74
  goto switch_default;
  switch_default: /* CIL Label */ 
  {
#line 75
  panic((char *)"unexpected node in treecpy");
  }
  case_12: /* CIL Label */ 
  {
#line 78
  tmp = (*alloc)((size_t )((char *)(& ((Node *)0)->u[3]) - (char *)0));
#line 78
  n = (Node *)tmp;
#line 79
  n->u[0].i = s___0->u[0].i;
#line 80
  n->u[1].i = s___0->u[1].i;
#line 81
  n->u[2].i = s___0->u[2].i;
  }
#line 82
  goto switch_break;
  case_30: /* CIL Label */ 
  {
#line 84
  tmp___0 = (*alloc)((size_t )((char *)(& ((Node *)0)->u[2]) - (char *)0));
#line 84
  n = (Node *)tmp___0;
#line 85
  tmp___1 = strlen((char const   *)s___0->u[0].s);
#line 85
  tmp___2 = (*alloc)(tmp___1 + 1UL);
#line 85
  n->u[0].s = strcpy((char */* __restrict  */)((char *)tmp___2), (char const   */* __restrict  */)s___0->u[0].s);
  }
#line 86
  if ((unsigned long )s___0->u[1].s != (unsigned long )((void *)0)) {
    {
#line 87
    tmp___3 = strlen((char const   *)s___0->u[0].s);
#line 87
    i = tmp___3;
#line 88
    tmp___4 = (*alloc)(i);
#line 88
    n->u[1].s = (char *)tmp___4;
#line 89
    memcpy((void */* __restrict  */)n->u[1].s, (void const   */* __restrict  */)s___0->u[1].s,
           i);
    }
  } else {
#line 91
    n->u[1].s = (char *)((void *)0);
  }
#line 92
  goto switch_break;
  case_27: /* CIL Label */ 
  case_23: /* CIL Label */ 
  case_21: /* CIL Label */ 
  case_11: /* CIL Label */ 
  case_9: /* CIL Label */ 
  case_24: /* CIL Label */ 
  case_6: /* CIL Label */ 
  case_3: /* CIL Label */ 
  {
#line 95
  tmp___5 = (*alloc)((size_t )((char *)(& ((Node *)0)->u[1]) - (char *)0));
#line 95
  n = (Node *)tmp___5;
#line 96
  n->u[0].p = treecpy(s___0->u[0].p, alloc);
  }
#line 97
  goto switch_break;
  case_31: /* CIL Label */ 
  case_29: /* CIL Label */ 
  case_28: /* CIL Label */ 
  case_26: /* CIL Label */ 
  case_25: /* CIL Label */ 
  case_22: /* CIL Label */ 
  case_19: /* CIL Label */ 
  case_17: /* CIL Label */ 
  case_5: /* CIL Label */ 
  case_14: /* CIL Label */ 
  case_16: /* CIL Label */ 
  case_13: /* CIL Label */ 
  case_10: /* CIL Label */ 
  case_8: /* CIL Label */ 
  case_7: /* CIL Label */ 
  case_4: /* CIL Label */ 
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
  case_0: /* CIL Label */ 
  {
#line 102
  tmp___6 = (*alloc)((size_t )((char *)(& ((Node *)0)->u[2]) - (char *)0));
#line 102
  n = (Node *)tmp___6;
#line 103
  n->u[0].p = treecpy(s___0->u[0].p, alloc);
#line 104
  n->u[1].p = treecpy(s___0->u[1].p, alloc);
  }
#line 105
  goto switch_break;
  case_15: /* CIL Label */ 
  {
#line 107
  tmp___7 = (*alloc)((size_t )((char *)(& ((Node *)0)->u[3]) - (char *)0));
#line 107
  n = (Node *)tmp___7;
#line 108
  n->u[0].p = treecpy(s___0->u[0].p, alloc);
#line 109
  n->u[1].p = treecpy(s___0->u[1].p, alloc);
#line 110
  n->u[2].p = treecpy(s___0->u[2].p, alloc);
  }
#line 111
  goto switch_break;
  case_18: /* CIL Label */ 
  {
#line 113
  tmp___8 = (*alloc)((size_t )((char *)(& ((Node *)0)->u[4]) - (char *)0));
#line 113
  n = (Node *)tmp___8;
#line 114
  n->u[0].i = s___0->u[0].i;
#line 115
  n->u[1].i = s___0->u[1].i;
#line 116
  n->u[2].p = treecpy(s___0->u[2].p, alloc);
#line 117
  n->u[3].p = treecpy(s___0->u[3].p, alloc);
  }
#line 118
  goto switch_break;
  case_32: /* CIL Label */ 
  case_20: /* CIL Label */ 
  {
#line 121
  tmp___9 = (*alloc)((size_t )((char *)(& ((Node *)0)->u[3]) - (char *)0));
#line 121
  n = (Node *)tmp___9;
#line 122
  n->u[0].i = s___0->u[0].i;
#line 123
  n->u[1].i = s___0->u[1].i;
#line 124
  n->u[2].p = treecpy(s___0->u[2].p, alloc);
  }
#line 125
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 127
  n->type = s___0->type;
#line 128
  return (n);
}
}
#line 133 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/tree.c"
extern void treefree(Node *s___0 ) 
{ 


  {
#line 134
  if ((unsigned long )s___0 == (unsigned long )((void *)0)) {
#line 135
    return;
  }
  {
#line 140
  if ((unsigned int )s___0->type == 12U) {
#line 140
    goto case_12;
  }
#line 142
  if ((unsigned int )s___0->type == 30U) {
#line 142
    goto case_30;
  }
#line 148
  if ((unsigned int )s___0->type == 24U) {
#line 148
    goto case_24;
  }
#line 148
  if ((unsigned int )s___0->type == 27U) {
#line 148
    goto case_24;
  }
#line 148
  if ((unsigned int )s___0->type == 23U) {
#line 148
    goto case_24;
  }
#line 148
  if ((unsigned int )s___0->type == 21U) {
#line 148
    goto case_24;
  }
#line 148
  if ((unsigned int )s___0->type == 11U) {
#line 148
    goto case_24;
  }
#line 148
  if ((unsigned int )s___0->type == 9U) {
#line 148
    goto case_24;
  }
#line 148
  if ((unsigned int )s___0->type == 6U) {
#line 148
    goto case_24;
  }
#line 148
  if ((unsigned int )s___0->type == 3U) {
#line 148
    goto case_24;
  }
#line 155
  if ((unsigned int )s___0->type == 31U) {
#line 155
    goto case_31;
  }
#line 155
  if ((unsigned int )s___0->type == 29U) {
#line 155
    goto case_31;
  }
#line 155
  if ((unsigned int )s___0->type == 28U) {
#line 155
    goto case_31;
  }
#line 155
  if ((unsigned int )s___0->type == 26U) {
#line 155
    goto case_31;
  }
#line 155
  if ((unsigned int )s___0->type == 25U) {
#line 155
    goto case_31;
  }
#line 155
  if ((unsigned int )s___0->type == 5U) {
#line 155
    goto case_31;
  }
#line 155
  if ((unsigned int )s___0->type == 22U) {
#line 155
    goto case_31;
  }
#line 155
  if ((unsigned int )s___0->type == 19U) {
#line 155
    goto case_31;
  }
#line 155
  if ((unsigned int )s___0->type == 17U) {
#line 155
    goto case_31;
  }
#line 155
  if ((unsigned int )s___0->type == 14U) {
#line 155
    goto case_31;
  }
#line 155
  if ((unsigned int )s___0->type == 16U) {
#line 155
    goto case_31;
  }
#line 155
  if ((unsigned int )s___0->type == 13U) {
#line 155
    goto case_31;
  }
#line 155
  if ((unsigned int )s___0->type == 10U) {
#line 155
    goto case_31;
  }
#line 155
  if ((unsigned int )s___0->type == 8U) {
#line 155
    goto case_31;
  }
#line 155
  if ((unsigned int )s___0->type == 7U) {
#line 155
    goto case_31;
  }
#line 155
  if ((unsigned int )s___0->type == 4U) {
#line 155
    goto case_31;
  }
#line 155
  if ((unsigned int )s___0->type == 2U) {
#line 155
    goto case_31;
  }
#line 155
  if ((unsigned int )s___0->type == 1U) {
#line 155
    goto case_31;
  }
#line 155
  if ((unsigned int )s___0->type == 0U) {
#line 155
    goto case_31;
  }
#line 159
  if ((unsigned int )s___0->type == 15U) {
#line 159
    goto case_15;
  }
#line 164
  if ((unsigned int )s___0->type == 18U) {
#line 164
    goto case_18;
  }
#line 169
  if ((unsigned int )s___0->type == 32U) {
#line 169
    goto case_32;
  }
#line 169
  if ((unsigned int )s___0->type == 20U) {
#line 169
    goto case_32;
  }
#line 137
  goto switch_default;
  switch_default: /* CIL Label */ 
  {
#line 138
  panic((char *)"unexpected node in treefree");
  }
  case_12: /* CIL Label */ 
#line 141
  goto switch_break;
  case_30: /* CIL Label */ 
  {
#line 143
  efree((void *)s___0->u[0].s);
#line 144
  efree((void *)s___0->u[1].s);
  }
#line 145
  goto switch_break;
  case_24: /* CIL Label */ 
  case_27: /* CIL Label */ 
  case_23: /* CIL Label */ 
  case_21: /* CIL Label */ 
  case_11: /* CIL Label */ 
  case_9: /* CIL Label */ 
  case_6: /* CIL Label */ 
  case_3: /* CIL Label */ 
  {
#line 149
  treefree(s___0->u[0].p);
  }
#line 150
  goto switch_break;
  case_31: /* CIL Label */ 
  case_29: /* CIL Label */ 
  case_28: /* CIL Label */ 
  case_26: /* CIL Label */ 
  case_25: /* CIL Label */ 
  case_5: /* CIL Label */ 
  case_22: /* CIL Label */ 
  case_19: /* CIL Label */ 
  case_17: /* CIL Label */ 
  case_14: /* CIL Label */ 
  case_16: /* CIL Label */ 
  case_13: /* CIL Label */ 
  case_10: /* CIL Label */ 
  case_8: /* CIL Label */ 
  case_7: /* CIL Label */ 
  case_4: /* CIL Label */ 
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
  case_0: /* CIL Label */ 
  {
#line 156
  treefree(s___0->u[1].p);
#line 157
  treefree(s___0->u[0].p);
  }
#line 158
  goto switch_break;
  case_15: /* CIL Label */ 
  {
#line 160
  treefree(s___0->u[2].p);
#line 161
  treefree(s___0->u[1].p);
#line 162
  treefree(s___0->u[0].p);
  }
#line 163
  goto switch_break;
  case_18: /* CIL Label */ 
  {
#line 165
  treefree(s___0->u[2].p);
#line 166
  treefree(s___0->u[3].p);
  }
#line 167
  goto switch_break;
  case_32: /* CIL Label */ 
  case_20: /* CIL Label */ 
  {
#line 170
  treefree(s___0->u[2].p);
  }
  switch_break: /* CIL Label */ ;
  }
  {
#line 172
  efree((void *)s___0);
  }
#line 173
  return;
}
}
#line 147 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 175 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/rc.h"
bool dashdee ;
#line 234
Htab *fp ;
#line 236
extern rc_Function *get_fn_place(char *s___0 ) ;
#line 242
extern char *fnlookup_string(char *name ) ;
#line 246
extern void delete_fn(char *s___0 ) ;
#line 248
extern void fnassign(char *name , Node *def ) ;
#line 249
extern void fnassign_string(char *extdef ) ;
#line 250
extern void fnrm(char *name ) ;
#line 255
extern void inithandler(void) ;
#line 259
extern void whatare_all_signals(void) ;
#line 261
extern void prettyprint_fn(int fd , char *name , Node *n ) ;
#line 13 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/fn.c"
static void fn_handler(int s___0 ) ;
#line 13
static void dud_handler(int ignore ) ;
#line 15 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/fn.c"
static bool runexit  =    (bool )0;
#line 16 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/fn.c"
static Node *handlers[65]  ;
#line 16 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/fn.c"
static Node null  ;
#line 17 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/fn.c"
static void (*def_sigint)(int  )  =    (void (*)(int  ))0;
#line 18 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/fn.c"
static void (*def_sigquit)(int  )  =    (void (*)(int  ))0;
#line 19 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/fn.c"
static void (*def_sigterm)(int  )  =    (void (*)(int  ))0;
#line 26 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/fn.c"
extern void inithandler(void) 
{ 
  int i ;

  {
#line 28
  null.type = (nodetype )4;
#line 29
  null.u[1].p = (Node *)((void *)0);
#line 29
  null.u[0].p = null.u[1].p;
#line 30
  i = 1;
  {
#line 30
  while (1) {
    while_continue: /* CIL Label */ ;
#line 30
    if (! (i < 65)) {
#line 30
      goto while_break;
    }
#line 32
    if (i != 17) {
#line 34
      if ((unsigned long )sighandlers[i] == (unsigned long )((void (*)(int  ))1)) {
        {
#line 35
        fnassign(signals[i].name, (Node *)((void *)0));
        }
      }
    }
#line 30
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 36
  if (interactive) {
    {
#line 37
    def_sigint = & sigint;
#line 38
    fnrm((char *)"sigint");
    }
  } else
#line 36
  if ((unsigned long )sighandlers[2] != (unsigned long )((void (*)(int  ))1)) {
    {
#line 37
    def_sigint = & sigint;
#line 38
    fnrm((char *)"sigint");
    }
  }
#line 40
  if (! dashdee) {
#line 41
    if (interactive) {
      {
#line 42
      def_sigquit = & dud_handler;
#line 43
      fnrm((char *)"sigquit");
      }
    } else
#line 41
    if ((unsigned long )sighandlers[3] != (unsigned long )((void (*)(int  ))1)) {
      {
#line 42
      def_sigquit = & dud_handler;
#line 43
      fnrm((char *)"sigquit");
      }
    }
#line 45
    if (interactive) {
      {
#line 46
      def_sigterm = & dud_handler;
#line 47
      fnrm((char *)"sigterm");
      }
    }
  }
#line 50
  return;
}
}
#line 54 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/fn.c"
extern void setsigdefaults(bool sysvbackground ) 
{ 
  int i ;

  {
  {
#line 61
  closefds();
#line 71
  i = 1;
  }
  {
#line 71
  while (1) {
    while_continue: /* CIL Label */ ;
#line 71
    if (! (i < 65)) {
#line 71
      goto while_break;
    }
#line 72
    if ((unsigned long )sighandlers[i] != (unsigned long )((void (*)(int  ))1)) {
#line 73
      handlers[i] = (Node *)((void *)0);
      {
#line 75
      if (i == 2) {
#line 75
        goto case_2;
      }
#line 84
      if (i == 3) {
#line 84
        goto case_3;
      }
#line 93
      if (i == 15) {
#line 93
        goto case_15;
      }
#line 97
      goto sigcommon;
      case_2: /* CIL Label */ 
#line 76
      if (sysvbackground) {
        {
#line 77
        def_sigint = (void (*)(int  ))1;
#line 78
        fnassign((char *)"sigint", (Node *)((void *)0));
        }
      } else {
#line 80
        def_sigint = (void (*)(int  ))0;
#line 81
        goto sigcommon;
      }
#line 83
      goto switch_break;
      case_3: /* CIL Label */ 
#line 85
      if (sysvbackground) {
        {
#line 86
        def_sigquit = (void (*)(int  ))1;
#line 87
        fnassign((char *)"sigquit", (Node *)((void *)0));
        }
      } else {
#line 89
        def_sigquit = (void (*)(int  ))0;
#line 90
        goto sigcommon;
      }
#line 92
      goto switch_break;
      case_15: /* CIL Label */ 
#line 94
      def_sigterm = (void (*)(int  ))0;
      sigcommon: 
      switch_default: /* CIL Label */ 
#line 98
      if ((unsigned long )sighandlers[i] != (unsigned long )((void (*)(int  ))0)) {
        {
#line 99
        rc_signal(i, (void (*)(int  ))0);
#line 100
        delete_fn(signals[i].name);
        }
      }
      switch_break: /* CIL Label */ ;
      }
    }
#line 71
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 104
  delete_fn((char *)"sigexit");
#line 105
  runexit = (bool )0;
  }
#line 106
  return;
}
}
#line 110 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/fn.c"
extern void rc_exit(int stat___0 ) 
{ 
  char *sig[2] ;

  {
#line 111
  if (runexit) {
    {
#line 113
    sig[0] = (char *)"sigexit";
#line 114
    sig[1] = (char *)((void *)0);
#line 115
    runexit = (bool )0;
#line 116
    funcall(sig);
#line 117
    stat___0 = getstatus();
    }
  }
  {
#line 119
  exit(stat___0);
  }
}
}
#line 124 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/fn.c"
static void fn_handler(int s___0 ) 
{ 
  char *sig[2] ;
  int olderrno ;
  int *tmp ;
  int *tmp___0 ;

  {
#line 127
  if (s___0 < 1) {
    {
#line 128
    panic((char *)"unknown signal");
    }
  } else
#line 127
  if (s___0 >= 65) {
    {
#line 128
    panic((char *)"unknown signal");
    }
  }
  {
#line 129
  tmp = __errno_location();
#line 129
  olderrno = *tmp;
#line 130
  sig[0] = signals[s___0].name;
#line 131
  sig[1] = (char *)((void *)0);
#line 132
  funcall(sig);
#line 133
  tmp___0 = __errno_location();
#line 133
  *tmp___0 = olderrno;
  }
#line 134
  return;
}
}
#line 138 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/fn.c"
static void dud_handler(int ignore ) 
{ 


  {
#line 139
  return;
}
}
#line 146 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/fn.c"
extern void fnassign(char *name , Node *def ) 
{ 
  Node *newdef ;
  Node *tmp ;
  Node *tmp___0 ;
  rc_Function *new ;
  rc_Function *tmp___1 ;
  int i ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 147
  if ((unsigned long )def == (unsigned long )((void *)0)) {
#line 147
    tmp = & null;
  } else {
#line 147
    tmp = def;
  }
  {
#line 147
  tmp___0 = treecpy(tmp, & ealloc);
#line 147
  newdef = tmp___0;
#line 148
  tmp___1 = get_fn_place(name);
#line 148
  new = tmp___1;
#line 150
  new->def = newdef;
#line 151
  new->extdef = (char *)((void *)0);
#line 152
  tmp___5 = strncmp((char const   *)name, "sig", sizeof("sig") - 1UL);
  }
#line 152
  if (tmp___5 == 0) {
#line 154
    if ((int )*name == (int )*"sigcld") {
      {
#line 154
      tmp___2 = strcmp((char const   *)name, "sigcld");
      }
#line 154
      if (tmp___2 == 0) {
        {
#line 155
        rc_error((char *)"can\'t trap SIGCLD");
        }
      }
    }
#line 157
    if ((int )*name == (int )*"sigexit") {
      {
#line 157
      tmp___3 = strcmp((char const   *)name, "sigexit");
      }
#line 157
      if (tmp___3 == 0) {
#line 158
        runexit = (bool )1;
      }
    }
#line 159
    i = 1;
    {
#line 159
    while (1) {
      while_continue: /* CIL Label */ ;
#line 159
      if (! (i < 65)) {
#line 159
        goto while_break;
      }
#line 160
      if ((int )*(signals[i].name) == (int )*name) {
        {
#line 160
        tmp___4 = strcmp((char const   *)signals[i].name, (char const   *)name);
        }
#line 160
        if (tmp___4 == 0) {
#line 161
          handlers[i] = newdef;
#line 162
          if ((unsigned long )def == (unsigned long )((void *)0)) {
            {
#line 163
            rc_signal(i, (void (*)(int  ))1);
            }
          } else {
            {
#line 165
            rc_signal(i, & fn_handler);
            }
          }
#line 166
          goto while_break;
        }
      }
#line 159
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 169
  return;
}
}
#line 173 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/fn.c"
extern void fnassign_string(char *extdef ) 
{ 
  char *name ;
  char *tmp ;
  rc_Function *new ;
  size_t tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 174
  tmp = get_name(extdef + 3);
#line 174
  name = tmp;
  }
#line 176
  if ((unsigned long )name == (unsigned long )((void *)0)) {
#line 177
    return;
  }
  {
#line 178
  new = get_fn_place(name);
#line 179
  new->def = (Node *)((void *)0);
#line 180
  tmp___0 = strlen((char const   *)extdef);
#line 180
  tmp___1 = ealloc(tmp___0 + 1UL);
#line 180
  new->extdef = strcpy((char */* __restrict  */)((char *)tmp___1), (char const   */* __restrict  */)extdef);
  }
#line 181
  return;
}
}
#line 185 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/fn.c"
extern Node *fnlookup(char *name ) 
{ 
  rc_Function *look ;
  void *tmp ;
  Node *ret ;
  Node *tmp___0 ;

  {
  {
#line 186
  tmp = lookup(name, fp);
#line 186
  look = (rc_Function *)tmp;
  }
#line 188
  if ((unsigned long )look == (unsigned long )((void *)0)) {
#line 189
    return ((Node *)((void *)0));
  }
#line 190
  if ((unsigned long )look->def != (unsigned long )((void *)0)) {
#line 191
    return (look->def);
  }
#line 192
  if ((unsigned long )look->extdef == (unsigned long )((void *)0)) {
#line 193
    return (& null);
  }
  {
#line 194
  ret = parse_fn(look->extdef);
  }
#line 195
  if ((unsigned long )ret == (unsigned long )((void *)0)) {
    {
#line 196
    efree((void *)look->extdef);
#line 197
    look->extdef = (char *)((void *)0);
    }
#line 198
    return (& null);
  } else {
    {
#line 200
    tmp___0 = treecpy(ret, & ealloc);
#line 200
    look->def = tmp___0;
    }
#line 200
    return (tmp___0);
  }
}
}
#line 206 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/fn.c"
extern char *fnlookup_string(char *name ) 
{ 
  rc_Function *look ;
  void *tmp ;
  char *tmp___0 ;

  {
  {
#line 207
  tmp = lookup(name, fp);
#line 207
  look = (rc_Function *)tmp;
  }
#line 209
  if ((unsigned long )look == (unsigned long )((void *)0)) {
#line 210
    return ((char *)((void *)0));
  }
#line 211
  if ((unsigned long )look->extdef != (unsigned long )((void *)0)) {
#line 212
    return (look->extdef);
  }
  {
#line 213
  tmp___0 = mprint("fn_%F={%T}", name, look->def);
#line 213
  look->extdef = tmp___0;
  }
#line 213
  return (tmp___0);
}
}
#line 221 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/fn.c"
extern void fnrm(char *name ) 
{ 
  int i ;
  int tmp ;
  int tmp___0 ;

  {
#line 223
  i = 1;
  {
#line 223
  while (1) {
    while_continue: /* CIL Label */ ;
#line 223
    if (! (i < 65)) {
#line 223
      goto while_break;
    }
#line 224
    if ((int )*(signals[i].name) == (int )*name) {
      {
#line 224
      tmp = strcmp((char const   *)signals[i].name, (char const   *)name);
      }
#line 224
      if (tmp == 0) {
#line 225
        handlers[i] = (Node *)((void *)0);
        {
#line 227
        if (i == 2) {
#line 227
          goto case_2;
        }
#line 230
        if (i == 3) {
#line 230
          goto case_3;
        }
#line 233
        if (i == 15) {
#line 233
          goto case_15;
        }
#line 236
        goto switch_default;
        case_2: /* CIL Label */ 
        {
#line 228
        rc_signal(i, def_sigint);
        }
#line 229
        goto switch_break;
        case_3: /* CIL Label */ 
        {
#line 231
        rc_signal(i, def_sigquit);
        }
#line 232
        goto switch_break;
        case_15: /* CIL Label */ 
        {
#line 234
        rc_signal(i, def_sigterm);
        }
#line 235
        goto switch_break;
        switch_default: /* CIL Label */ 
        {
#line 237
        rc_signal(i, (void (*)(int  ))0);
        }
        switch_break: /* CIL Label */ ;
        }
      }
    }
#line 223
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 240
  if ((int )*name == (int )*"sigexit") {
    {
#line 240
    tmp___0 = strcmp((char const   *)name, "sigexit");
    }
#line 240
    if (tmp___0 == 0) {
#line 241
      runexit = (bool )0;
    }
  }
  {
#line 242
  delete_fn(name);
  }
#line 243
  return;
}
}
#line 245 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/fn.c"
extern void whatare_all_signals(void) 
{ 
  int i ;

  {
#line 247
  i = 1;
  {
#line 247
  while (1) {
    while_continue: /* CIL Label */ ;
#line 247
    if (! (i < 65)) {
#line 247
      goto while_break;
    }
#line 248
    if ((int )*(signals[i].name) != 0) {
#line 249
      if ((unsigned long )sighandlers[i] == (unsigned long )((void (*)(int  ))1)) {
        {
#line 250
        fprint(1, "fn %s {}\n", signals[i].name);
        }
      } else
#line 251
      if ((unsigned long )sighandlers[i] == (unsigned long )(& fn_handler)) {
        {
#line 252
        fprint(1, "fn %S {%T}\n", signals[i].name, handlers[i]);
        }
      } else {
        {
#line 254
        fprint(1, "fn %s\n", signals[i].name);
        }
      }
    }
#line 247
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 256
  return;
}
}
#line 258 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/fn.c"
extern void prettyprint_fn(int fd , char *name , Node *n ) 
{ 


  {
  {
#line 259
  fprint(fd, "fn %S {%T}\n", name, n);
  }
#line 260
  return;
}
}
#line 646 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setpgid)(__pid_t __pid ,
                                                                              __pid_t __pgid ) ;
#line 393 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/rc.h"
extern int istrue(void) ;
#line 398
extern void setpipestatus(int *stats , int num ) ;
#line 14 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/walk.c"
bool cond  =    (bool )0;
#line 16
static bool haspreredir(Node *n ) ;
#line 17
static bool isallpre(Node *n ) ;
#line 18
static bool dofork(bool parent ) ;
#line 19
static void dopipe(Node *n ) ;
#line 27 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/walk.c"
extern bool walk(Node *n , bool parent ) 
{ 
  List *tmp ;
  List *tmp___0 ;
  int pid ;
  __pid_t tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;
  List *tmp___5 ;
  bool oldcond ;
  bool tmp___6 ;
  bool oldcond___0 ;
  bool tmp___7 ;
  bool tmp___8 ;
  int tmp___9 ;
  bool oldcond___1 ;
  Node *true_cmd ;
  Node *false_cmd ;
  bool tmp___10 ;
  Jbwrap j ;
  Edata jbreak ;
  Estack e1 ;
  Estack e2 ;
  bool testtrue ;
  bool oldcond___2 ;
  bool tmp___11 ;
  int tmp___12 ;
  Edata block ;
  List *l ;
  List *var ;
  List *tmp___13 ;
  Jbwrap j___0 ;
  Estack e1___0 ;
  Estack e2___0 ;
  Edata jbreak___0 ;
  int tmp___14 ;
  List *tmp___15 ;
  List *tmp___16 ;
  Edata block___0 ;
  List *tmp___17 ;
  int tmp___18 ;
  bool tmp___19 ;
  List *tmp___20 ;
  List *tmp___21 ;
  List *tmp___22 ;
  List *l___0 ;
  List *tmp___23 ;
  List *l___1 ;
  List *tmp___24 ;
  List *a ;
  List *tmp___25 ;
  List *tmp___26 ;
  List *b ;
  List *tmp___27 ;
  char const   *tmp___28 ;
  bool tmp___29 ;
  List *v ;
  List *tmp___30 ;
  int tmp___31 ;
  List *tmp___32 ;
  bool tmp___33 ;
  List *v___0 ;
  bool tmp___34 ;
  bool tmp___35 ;
  int tmp___36 ;
  Estack e ;
  Edata var___0 ;
  List *tmp___37 ;
  List *tmp___38 ;
  bool tmp___39 ;
  int tmp___40 ;
  bool tmp___41 ;
  int tmp___42 ;

  {
  top: 
  {
#line 28
  sigchk();
  }
#line 29
  if ((unsigned long )n == (unsigned long )((void *)0)) {
#line 30
    if (! parent) {
      {
#line 31
      exit(0);
      }
    }
    {
#line 32
    set((bool )1);
    }
#line 33
    return ((bool )1);
  }
  {
#line 38
  if ((unsigned int )n->type == 30U) {
#line 38
    goto case_30;
  }
#line 38
  if ((unsigned int )n->type == 28U) {
#line 38
    goto case_30;
  }
#line 38
  if ((unsigned int )n->type == 27U) {
#line 38
    goto case_30;
  }
#line 38
  if ((unsigned int )n->type == 20U) {
#line 38
    goto case_30;
  }
#line 38
  if ((unsigned int )n->type == 31U) {
#line 38
    goto case_30;
  }
#line 38
  if ((unsigned int )n->type == 11U) {
#line 38
    goto case_30;
  }
#line 38
  if ((unsigned int )n->type == 9U) {
#line 38
    goto case_30;
  }
#line 38
  if ((unsigned int )n->type == 8U) {
#line 38
    goto case_30;
  }
#line 38
  if ((unsigned int )n->type == 2U) {
#line 38
    goto case_30;
  }
#line 38
  if ((unsigned int )n->type == 22U) {
#line 38
    goto case_30;
  }
#line 41
  if ((unsigned int )n->type == 4U) {
#line 41
    goto case_4;
  }
#line 45
  if ((unsigned int )n->type == 6U) {
#line 45
    goto case_6;
  }
#line 67
  if ((unsigned int )n->type == 0U) {
#line 67
    goto case_0;
  }
#line 77
  if ((unsigned int )n->type == 17U) {
#line 77
    goto case_17;
  }
#line 87
  if ((unsigned int )n->type == 3U) {
#line 87
    goto case_3;
  }
#line 90
  if ((unsigned int )n->type == 16U) {
#line 90
    goto case_16;
  }
#line 103
  if ((unsigned int )n->type == 29U) {
#line 103
    goto case_29;
  }
#line 131
  if ((unsigned int )n->type == 15U) {
#line 131
    goto case_15;
  }
#line 151
  if ((unsigned int )n->type == 23U) {
#line 151
    goto case_23;
  }
#line 158
  if ((unsigned int )n->type == 1U) {
#line 158
    goto case_1;
  }
#line 164
  if ((unsigned int )n->type == 18U) {
#line 164
    goto case_18;
  }
#line 167
  if ((unsigned int )n->type == 14U) {
#line 167
    goto case_14;
  }
#line 180
  if ((unsigned int )n->type == 21U) {
#line 180
    goto case_21;
  }
#line 191
  if ((unsigned int )n->type == 12U) {
#line 191
    goto case_12;
  }
#line 194
  if ((unsigned int )n->type == 26U) {
#line 194
    goto case_26;
  }
#line 201
  if ((unsigned int )n->type == 25U) {
#line 201
    goto case_25;
  }
#line 217
  if ((unsigned int )n->type == 19U) {
#line 217
    goto case_19;
  }
#line 248
  if ((unsigned int )n->type == 7U) {
#line 248
    goto case_7;
  }
#line 260
  if ((unsigned int )n->type == 13U) {
#line 260
    goto case_13;
  }
#line 268
  if ((unsigned int )n->type == 32U) {
#line 268
    goto case_32;
  }
#line 271
  goto switch_default;
  case_30: /* CIL Label */ 
  case_28: /* CIL Label */ 
  case_27: /* CIL Label */ 
  case_20: /* CIL Label */ 
  case_31: /* CIL Label */ 
  case_11: /* CIL Label */ 
  case_9: /* CIL Label */ 
  case_8: /* CIL Label */ 
  case_2: /* CIL Label */ 
  case_22: /* CIL Label */ 
  {
#line 39
  tmp = glom(n);
#line 39
  tmp___0 = glob(tmp);
#line 39
  exec(tmp___0, parent);
  }
#line 40
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 42
  walk(n->u[0].p, (bool )1);
#line 43
  n = n->u[1].p;
#line 43
  parent = parent;
  }
#line 43
  goto top;
  case_6: /* CIL Label */ 
  {
#line 47
  pid = rc_fork();
  }
#line 47
  if (pid == 0) {
    {
#line 49
    setsigdefaults((bool )0);
#line 50
    rc_signal(22, (void (*)(int  ))1);
#line 51
    rc_signal(21, (void (*)(int  ))1);
#line 52
    rc_signal(20, (void (*)(int  ))1);
#line 53
    tmp___1 = getpid();
#line 53
    setpgid(0, tmp___1);
#line 57
    tmp___2 = rc_open("/dev/null", (redirtype )0);
#line 57
    mvfd(tmp___2, 0);
#line 58
    walk(n->u[0].p, (bool )0);
#line 59
    tmp___3 = getstatus();
#line 59
    exit(tmp___3);
    }
  }
#line 61
  if (interactive) {
    {
#line 62
    fprint(2, "%d\n", pid);
    }
  }
  {
#line 63
  tmp___4 = nprint("%d", pid);
#line 63
  tmp___5 = word(tmp___4, (char *)((void *)0));
#line 63
  varassign((char *)"apid", tmp___5, (bool )0);
#line 64
  redirq = (Rq *)((void *)0);
  }
#line 65
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 68
  oldcond = cond;
#line 69
  cond = (bool )1;
#line 70
  tmp___6 = walk(n->u[0].p, (bool )1);
  }
#line 70
  if (tmp___6) {
#line 71
    cond = oldcond;
#line 72
    n = n->u[1].p;
#line 72
    parent = parent;
#line 72
    goto top;
  } else {
#line 74
    cond = oldcond;
  }
#line 75
  goto switch_break;
  case_17: /* CIL Label */ 
  {
#line 78
  oldcond___0 = cond;
#line 79
  cond = (bool )1;
#line 80
  tmp___7 = walk(n->u[0].p, (bool )1);
  }
#line 80
  if (tmp___7) {
#line 84
    cond = oldcond___0;
  } else {
#line 81
    cond = oldcond___0;
#line 82
    n = n->u[1].p;
#line 82
    parent = parent;
#line 82
    goto top;
  }
#line 85
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 88
  tmp___8 = walk(n->u[0].p, (bool )1);
  }
#line 88
  if (tmp___8) {
#line 88
    tmp___9 = 0;
  } else {
#line 88
    tmp___9 = 1;
  }
  {
#line 88
  set((bool )tmp___9);
  }
#line 89
  goto switch_break;
  case_16: /* CIL Label */ 
#line 91
  oldcond___1 = cond;
#line 92
  true_cmd = n->u[1].p;
#line 92
  false_cmd = (Node *)((void *)0);
#line 93
  if ((unsigned long )true_cmd != (unsigned long )((void *)0)) {
#line 93
    if ((unsigned int )true_cmd->type == 10U) {
#line 94
      false_cmd = true_cmd->u[1].p;
#line 95
      true_cmd = true_cmd->u[0].p;
    }
  }
  {
#line 97
  cond = (bool )1;
#line 98
  tmp___10 = walk(n->u[0].p, (bool )1);
  }
#line 98
  if (! tmp___10) {
#line 99
    true_cmd = false_cmd;
  }
#line 100
  cond = oldcond___1;
#line 101
  n = true_cmd;
#line 101
  parent = parent;
#line 101
  goto top;
  case_29: /* CIL Label */ 
  {
#line 107
  oldcond___2 = cond;
#line 108
  cond = (bool )1;
#line 109
  tmp___11 = walk(n->u[0].p, (bool )1);
  }
#line 109
  if (! tmp___11) {
#line 110
    cond = oldcond___2;
#line 111
    goto switch_break;
  }
  {
#line 113
  tmp___12 = __sigsetjmp((struct __jmp_buf_tag *)(j.j), 1);
  }
#line 113
  if (tmp___12) {
#line 114
    goto switch_break;
  }
  {
#line 115
  jbreak.jb = & j;
#line 116
  except((ecodes )1, jbreak, & e1);
  }
  {
#line 117
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 119
    block.b = newblock();
#line 120
    cond = oldcond___2;
#line 121
    except((ecodes )4, block, & e2);
#line 122
    walk(n->u[1].p, (bool )1);
#line 123
    testtrue = walk(n->u[0].p, (bool )1);
#line 124
    unexcept();
#line 125
    cond = (bool )1;
    }
#line 117
    if (! testtrue) {
#line 117
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 127
  cond = oldcond___2;
#line 128
  unexcept();
  }
#line 129
  goto switch_break;
  case_15: /* CIL Label */ 
  {
#line 132
  tmp___13 = glom(n->u[0].p);
#line 132
  var = tmp___13;
#line 136
  tmp___14 = __sigsetjmp((struct __jmp_buf_tag *)(j___0.j), 1);
  }
#line 136
  if (tmp___14) {
#line 137
    goto switch_break;
  }
  {
#line 138
  jbreak___0.jb = & j___0;
#line 139
  except((ecodes )1, jbreak___0, & e1___0);
#line 140
  tmp___15 = glom(n->u[1].p);
#line 140
  tmp___16 = glob(tmp___15);
#line 140
  l = listcpy(tmp___16, & nalloc);
  }
  {
#line 140
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 140
    if (! ((unsigned long )l != (unsigned long )((void *)0))) {
#line 140
      goto while_break___0;
    }
    {
#line 142
    tmp___17 = word(l->w, (char *)((void *)0));
#line 142
    assign(var, tmp___17, (bool )0);
#line 143
    block___0.b = newblock();
#line 144
    except((ecodes )4, block___0, & e2___0);
#line 145
    walk(n->u[2].p, (bool )1);
#line 146
    unexcept();
#line 140
    l = l->n;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 148
  unexcept();
  }
#line 149
  goto switch_break;
  case_23: /* CIL Label */ 
  {
#line 152
  tmp___19 = dofork((bool )1);
  }
#line 152
  if (tmp___19) {
    {
#line 153
    setsigdefaults((bool )0);
#line 154
    walk(n->u[0].p, (bool )0);
#line 155
    tmp___18 = getstatus();
#line 155
    rc_exit(tmp___18);
    }
  }
#line 157
  goto switch_break;
  case_1: /* CIL Label */ 
#line 159
  if ((unsigned long )n->u[0].p == (unsigned long )((void *)0)) {
    {
#line 160
    rc_error((char *)"null variable name");
    }
  }
  {
#line 161
  tmp___20 = glom(n->u[1].p);
#line 161
  tmp___21 = glob(tmp___20);
#line 161
  tmp___22 = glom(n->u[0].p);
#line 161
  assign(tmp___22, tmp___21, (bool )0);
#line 162
  set((bool )1);
  }
#line 163
  goto switch_break;
  case_18: /* CIL Label */ 
  {
#line 165
  dopipe(n);
  }
#line 166
  goto switch_break;
  case_14: /* CIL Label */ 
  {
#line 168
  tmp___23 = glom(n->u[0].p);
#line 168
  l___0 = tmp___23;
  }
#line 169
  if ((unsigned long )l___0 == (unsigned long )((void *)0)) {
    {
#line 170
    rc_error((char *)"null function name");
    }
  }
  {
#line 171
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 171
    if (! ((unsigned long )l___0 != (unsigned long )((void *)0))) {
#line 171
      goto while_break___1;
    }
#line 172
    if (dashex) {
      {
#line 173
      prettyprint_fn(2, l___0->w, n->u[1].p);
      }
    }
    {
#line 174
    fnassign(l___0->w, n->u[1].p);
#line 175
    l___0 = l___0->n;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 177
  set((bool )1);
  }
#line 178
  goto switch_break;
  case_21: /* CIL Label */ 
  {
#line 181
  tmp___24 = glom(n->u[0].p);
#line 181
  l___1 = tmp___24;
  }
  {
#line 182
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 182
    if (! ((unsigned long )l___1 != (unsigned long )((void *)0))) {
#line 182
      goto while_break___2;
    }
#line 183
    if (dashex) {
      {
#line 184
      fprint(2, "fn %S\n", l___1->w);
      }
    }
    {
#line 185
    fnrm(l___1->w);
#line 186
    l___1 = l___1->n;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 188
  set((bool )1);
  }
#line 189
  goto switch_break;
  case_12: /* CIL Label */ 
#line 192
  redirq = (Rq *)((void *)0);
#line 193
  goto switch_break;
  case_26: /* CIL Label */ 
  {
#line 195
  tmp___25 = glom(n->u[0].p);
#line 195
  tmp___26 = glob(tmp___25);
#line 195
  a = tmp___26;
#line 195
  tmp___27 = glom(n->u[1].p);
#line 195
  b = tmp___27;
  }
#line 196
  if (dashex) {
#line 197
    if ((unsigned long )a != (unsigned long )((void *)0)) {
#line 197
      if ((unsigned long )a->n != (unsigned long )((void *)0)) {
#line 197
        tmp___28 = "~ (%L) %L\n";
      } else {
#line 197
        tmp___28 = "~ %L %L\n";
      }
    } else {
#line 197
      tmp___28 = "~ %L %L\n";
    }
    {
#line 197
    fprint(2, tmp___28, a, " ", b, " ");
    }
  }
  {
#line 198
  tmp___29 = lmatch(a, b);
#line 198
  set(tmp___29);
  }
#line 199
  goto switch_break;
  case_25: /* CIL Label */ 
  {
#line 202
  tmp___30 = glom(n->u[0].p);
#line 202
  v = tmp___30;
  }
  {
#line 203
  while (1) {
    while_continue___3: /* CIL Label */ ;
    {
#line 204
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 205
      n = n->u[1].p;
#line 206
      if ((unsigned long )n == (unsigned long )((void *)0)) {
        {
#line 207
        tmp___31 = istrue();
        }
#line 207
        return ((bool )tmp___31);
      }
#line 204
      if (! ((unsigned long )n->u[0].p == (unsigned long )((void *)0))) {
#line 204
        if (! ((unsigned int )(n->u[0].p)->type != 24U)) {
#line 204
          goto while_break___4;
        }
      }
    }
    while_break___4: /* CIL Label */ ;
    }
    {
#line 209
    tmp___32 = glom((n->u[0].p)->u[0].p);
#line 209
    tmp___33 = lmatch(v, tmp___32);
    }
#line 209
    if (tmp___33) {
#line 210
      n = n->u[1].p;
      {
#line 210
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 210
        if ((unsigned long )n != (unsigned long )((void *)0)) {
#line 210
          if (! ((unsigned long )n->u[0].p == (unsigned long )((void *)0))) {
#line 210
            if (! ((unsigned int )(n->u[0].p)->type != 24U)) {
#line 210
              goto while_break___5;
            }
          }
        } else {
#line 210
          goto while_break___5;
        }
        {
#line 211
        walk(n->u[0].p, (bool )1);
#line 210
        n = n->u[1].p;
        }
      }
      while_break___5: /* CIL Label */ ;
      }
#line 212
      goto while_break___3;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
#line 215
  goto switch_break;
  case_19: /* CIL Label */ 
#line 219
  if ((unsigned int )(n->u[0].p)->type == 20U) {
#line 219
    goto _L;
  } else
#line 219
  if ((unsigned int )(n->u[0].p)->type == 12U) {
    _L: /* CIL Label */ 
#line 220
    if ((unsigned long )redirq == (unsigned long )((void *)0)) {
      {
#line 220
      tmp___34 = dofork(parent);
      }
#line 220
      if (! tmp___34) {
#line 221
        goto switch_break;
      }
    }
    {
#line 222
    setsigdefaults((bool )0);
#line 223
    qredir(n->u[0].p);
#line 224
    tmp___35 = haspreredir(n->u[1].p);
    }
#line 224
    if (! tmp___35) {
      {
#line 225
      doredirs();
      }
    }
    {
#line 226
    walk(n->u[1].p, (bool )0);
#line 227
    tmp___36 = getstatus();
#line 227
    rc_exit(tmp___36);
    }
  } else
#line 229
  if ((unsigned int )(n->u[0].p)->type == 1U) {
    {
#line 230
    tmp___39 = isallpre(n->u[1].p);
    }
#line 230
    if (tmp___39) {
      {
#line 231
      walk(n->u[0].p, (bool )1);
#line 232
      n = n->u[1].p;
#line 232
      parent = parent;
      }
#line 232
      goto top;
    } else {
      {
#line 236
      v___0 = glom((n->u[0].p)->u[0].p);
#line 237
      tmp___37 = glom((n->u[0].p)->u[1].p);
#line 237
      tmp___38 = glob(tmp___37);
#line 237
      assign(v___0, tmp___38, (bool )1);
#line 238
      var___0.name = v___0->w;
#line 239
      except((ecodes )3, var___0, & e);
#line 240
      walk(n->u[1].p, parent);
#line 241
      varrm(v___0->w, (bool )1);
#line 242
      unexcept();
      }
    }
  } else {
    {
#line 245
    panic((char *)"unexpected node in preredir section of walk");
    }
  }
#line 246
  goto switch_break;
  case_7: /* CIL Label */ 
#line 249
  if ((unsigned long )n->u[1].p == (unsigned long )((void *)0)) {
#line 250
    n = n->u[0].p;
#line 250
    parent = parent;
#line 250
    goto top;
  } else {
    {
#line 251
    tmp___41 = dofork(parent);
    }
#line 251
    if (tmp___41) {
      {
#line 252
      setsigdefaults((bool )0);
#line 253
      walk(n->u[1].p, (bool )1);
#line 254
      redirq = (Rq *)((void *)0);
#line 255
      walk(n->u[0].p, (bool )0);
#line 256
      tmp___40 = getstatus();
#line 256
      rc_exit(tmp___40);
      }
    }
  }
#line 259
  goto switch_break;
  case_13: /* CIL Label */ 
  {
#line 261
  qredir(n->u[0].p);
  }
#line 262
  if ((unsigned long )n->u[1].p != (unsigned long )((void *)0)) {
#line 263
    n = n->u[1].p;
#line 263
    parent = parent;
#line 263
    goto top;
  } else {
    {
#line 265
    doredirs();
    }
  }
#line 267
  goto switch_break;
  case_32: /* CIL Label */ 
  {
#line 269
  rc_error((char *)"named pipes cannot be executed as commands");
  }
  switch_default: /* CIL Label */ 
  {
#line 272
  panic((char *)"unknown node in walk");
  }
  switch_break: /* CIL Label */ ;
  }
  {
#line 275
  tmp___42 = istrue();
  }
#line 275
  return ((bool )tmp___42);
}
}
#line 280 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/walk.c"
static bool haspreredir(Node *n ) 
{ 


  {
  {
#line 281
  while (1) {
    while_continue: /* CIL Label */ ;
#line 281
    if ((unsigned long )n != (unsigned long )((void *)0)) {
#line 281
      if (! ((unsigned int )n->type == 19U)) {
#line 281
        goto while_break;
      }
    } else {
#line 281
      goto while_break;
    }
#line 282
    if ((unsigned int )(n->u[0].p)->type == 12U) {
#line 283
      return ((bool )1);
    } else
#line 282
    if ((unsigned int )(n->u[0].p)->type == 20U) {
#line 283
      return ((bool )1);
    }
#line 284
    n = n->u[1].p;
  }
  while_break: /* CIL Label */ ;
  }
#line 286
  return ((bool )0);
}
}
#line 291 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/walk.c"
static bool isallpre(Node *n ) 
{ 
  int tmp ;

  {
  {
#line 292
  while (1) {
    while_continue: /* CIL Label */ ;
#line 292
    if ((unsigned long )n != (unsigned long )((void *)0)) {
#line 292
      if (! ((unsigned int )n->type == 19U)) {
#line 292
        goto while_break;
      }
    } else {
#line 292
      goto while_break;
    }
#line 293
    n = n->u[1].p;
  }
  while_break: /* CIL Label */ ;
  }
#line 294
  if ((unsigned long )n == (unsigned long )((void *)0)) {
#line 294
    tmp = 1;
  } else
#line 294
  if ((unsigned int )n->type == 20U) {
#line 294
    tmp = 1;
  } else
#line 294
  if ((unsigned int )n->type == 1U) {
#line 294
    tmp = 1;
  } else
#line 294
  if ((unsigned int )n->type == 12U) {
#line 294
    tmp = 1;
  } else {
#line 294
    tmp = 0;
  }
#line 294
  return ((bool )tmp);
}
}
#line 302 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/walk.c"
static bool dofork(bool parent ) 
{ 
  int pid ;
  int sp___0 ;

  {
#line 305
  if (! parent) {
#line 306
    return ((bool )1);
  } else {
    {
#line 305
    pid = rc_fork();
    }
#line 305
    if (pid == 0) {
#line 306
      return ((bool )1);
    }
  }
  {
#line 307
  redirq = (Rq *)((void *)0);
#line 308
  rc_wait4(pid, & sp___0, (bool )1);
#line 309
  setstatus(-1, sp___0);
#line 310
  sigchk();
  }
#line 311
  return ((bool )0);
}
}
#line 314 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/walk.c"
static void dopipe(Node *n ) 
{ 
  int i ;
  int j ;
  int sp___0 ;
  int pid ;
  int fd_prev ;
  int fd_out ;
  int pids[512] ;
  int stats[512] ;
  int p[2] ;
  bool intr ;
  Node *r ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 319
  fd_out = 1;
#line 319
  fd_prev = fd_out;
#line 320
  r = n;
#line 320
  i = 0;
  {
#line 320
  while (1) {
    while_continue: /* CIL Label */ ;
#line 320
    if ((unsigned long )r != (unsigned long )((void *)0)) {
#line 320
      if (! ((unsigned int )r->type == 18U)) {
#line 320
        goto while_break;
      }
    } else {
#line 320
      goto while_break;
    }
#line 321
    if (i > 500) {
      {
#line 322
      rc_error((char *)"pipe too long");
      }
    }
    {
#line 323
    tmp = pipe((int *)(p));
    }
#line 323
    if (tmp < 0) {
      {
#line 324
      uerror((char *)"pipe");
#line 325
      rc_error((char *)((void *)0));
      }
    }
    {
#line 327
    pid = rc_fork();
    }
#line 327
    if (pid == 0) {
      {
#line 328
      setsigdefaults((bool )0);
#line 329
      redirq = (Rq *)((void *)0);
#line 330
      mvfd(p[0], r->u[1].i);
      }
#line 331
      if (fd_prev != 1) {
        {
#line 332
        mvfd(fd_prev, fd_out);
        }
      }
      {
#line 333
      close(p[1]);
#line 334
      walk(r->u[3].p, (bool )0);
#line 335
      tmp___0 = getstatus();
#line 335
      exit(tmp___0);
      }
    }
#line 337
    if (fd_prev != 1) {
      {
#line 338
      close(fd_prev);
      }
    }
    {
#line 339
    pids[i] = pid;
#line 340
    fd_prev = p[1];
#line 341
    fd_out = r->u[0].i;
#line 342
    close(p[0]);
#line 320
    r = r->u[2].p;
#line 320
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 344
  pid = rc_fork();
  }
#line 344
  if (pid == 0) {
    {
#line 345
    setsigdefaults((bool )0);
#line 346
    mvfd(fd_prev, fd_out);
#line 347
    walk(r, (bool )0);
#line 348
    tmp___1 = getstatus();
#line 348
    exit(tmp___1);
    }
  }
  {
#line 351
  redirq = (Rq *)((void *)0);
#line 352
  close(fd_prev);
#line 353
  tmp___2 = i;
#line 353
  i ++;
#line 353
  pids[tmp___2] = pid;
#line 357
  intr = (bool )0;
#line 358
  j = 0;
  }
  {
#line 358
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 358
    if (! (j < i)) {
#line 358
      goto while_break___0;
    }
    {
#line 359
    rc_wait4(pids[j], & sp___0, (bool )1);
#line 360
    stats[j] = sp___0;
#line 361
    intr = (bool )((unsigned int )intr | (unsigned int )(sp___0 == 2));
#line 358
    j ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 363
  setpipestatus(stats, i);
#line 364
  sigchk();
  }
#line 365
  return;
}
}
#line 294 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/rc.h"
extern void listfree(List *p ) ;
#line 14 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/list.c"
extern void listfree(List *p ) 
{ 
  List *n ;

  {
  {
#line 15
  while (1) {
    while_continue: /* CIL Label */ ;
#line 15
    if (! ((unsigned long )p != (unsigned long )((void *)0))) {
#line 15
      goto while_break;
    }
    {
#line 16
    n = p->n;
#line 17
    efree((void *)p->w);
#line 18
    efree((void *)p);
#line 19
    p = n;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 21
  return;
}
}
#line 25 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/list.c"
extern List *listcpy(List *s___0 , void *(*alloc)(size_t  ) ) 
{ 
  List *top ;
  List *r ;
  void *tmp ;
  List *tmp___0 ;
  void *tmp___1 ;
  size_t tmp___2 ;
  void *tmp___3 ;

  {
#line 27
  r = (List *)((void *)0);
#line 27
  top = r;
  {
#line 27
  while (1) {
    while_continue: /* CIL Label */ ;
#line 27
    if (! ((unsigned long )s___0 != (unsigned long )((void *)0))) {
#line 27
      goto while_break;
    }
#line 28
    if ((unsigned long )top == (unsigned long )((void *)0)) {
      {
#line 29
      tmp = (*alloc)(sizeof(List ));
#line 29
      top = (List *)tmp;
#line 29
      r = top;
      }
    } else {
      {
#line 31
      tmp___1 = (*alloc)(sizeof(List ));
#line 31
      tmp___0 = (List *)tmp___1;
#line 31
      r->n = tmp___0;
#line 31
      r = tmp___0;
      }
    }
    {
#line 32
    tmp___2 = strlen((char const   *)s___0->w);
#line 32
    tmp___3 = (*alloc)(tmp___2 + 1UL);
#line 32
    r->w = (char *)tmp___3;
#line 33
    strcpy((char */* __restrict  */)r->w, (char const   */* __restrict  */)s___0->w);
#line 34
    r->m = (char *)((void *)0);
#line 27
    s___0 = s___0->n;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 36
  if ((unsigned long )r != (unsigned long )((void *)0)) {
#line 37
    r->n = (List *)((void *)0);
  }
#line 38
  return (top);
}
}
#line 43 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/list.c"
extern size_t listlen(List *s___0 ) 
{ 
  size_t size ;
  size_t tmp ;

  {
#line 45
  size = (size_t )0;
  {
#line 45
  while (1) {
    while_continue: /* CIL Label */ ;
#line 45
    if (! ((unsigned long )s___0 != (unsigned long )((void *)0))) {
#line 45
      goto while_break;
    }
    {
#line 46
    tmp = strlen((char const   *)s___0->w);
#line 46
    size += tmp + 1UL;
#line 45
    s___0 = s___0->n;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 47
  return (size);
}
}
#line 52 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/list.c"
extern int listnel(List *s___0 ) 
{ 
  int nel ;

  {
#line 54
  nel = 0;
  {
#line 54
  while (1) {
    while_continue: /* CIL Label */ ;
#line 54
    if (! ((unsigned long )s___0 != (unsigned long )((void *)0))) {
#line 54
      goto while_break;
    }
#line 55
    nel ++;
#line 54
    s___0 = s___0->n;
  }
  while_break: /* CIL Label */ ;
  }
#line 56
  return (nel);
}
}
#line 497 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) chdir)(char const   *__path ) ;
#line 842
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tcsetpgrp)(int __fd ,
                                                                                __pid_t __pgrp_id ) ;
#line 175 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/rc.h"
bool dasheye ;
#line 258
extern void whatare_all_vars(bool showfn , bool showvar ) ;
#line 400
extern void ssetstatus(char **av ) ;
#line 312 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) __mode_t ( __attribute__((__leaf__)) umask)(__mode_t __mask ) ;
#line 50 "/usr/include/x86_64-linux-gnu/sys/resource.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getrlimit)(__rlimit_resource_t __resource ,
                                                                                struct rlimit *__rlimits ) ;
#line 69
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setrlimit)(__rlimit_resource_t __resource ,
                                                                                struct rlimit  const  *__rlimits ) ;
#line 22 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/builtins.c"
static void b_break(char **av ) ;
#line 22
static void b_cd(char **av ) ;
#line 22
static void b_eval(char **av ) ;
#line 22
static void b_exit(char **av ) ;
#line 22
static void b_newpgrp(char **av ) ;
#line 22
static void b_return(char **av ) ;
#line 22
static void b_shift(char **av ) ;
#line 22
static void b_umask(char **av ) ;
#line 22
static void b_wait(char **av ) ;
#line 22
static void b_whatis(char **av ) ;
#line 27
static void b_limit(char **av ) ;
#line 31
static void b_echo(char **av ) ;
#line 34 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/builtins.c"
static struct __anonstruct_builtins_66 builtins[15]  = 
#line 34
  {      {& b_break, (char *)"break"}, 
        {& b_builtin, (char *)"builtin"}, 
        {& b_cd, (char *)"cd"}, 
        {& b_echo, (char *)"echo"}, 
        {& b_eval, (char *)"eval"}, 
        {& b_exec, (char *)"exec"}, 
        {& b_exit, (char *)"exit"}, 
        {& b_limit, (char *)"limit"}, 
        {& b_newpgrp, (char *)"newpgrp"}, 
        {& b_return, (char *)"return"}, 
        {& b_shift, (char *)"shift"}, 
        {& b_umask, (char *)"umask"}, 
        {& b_wait, (char *)"wait"}, 
        {& b_whatis, (char *)"whatis"}, 
        {& b_dot, (char *)"."}};
#line 62 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/builtins.c"
extern builtin_t *isbuiltin(char *s___0 ) 
{ 
  int i ;
  int tmp ;

  {
#line 64
  i = 0;
  {
#line 64
  while (1) {
    while_continue: /* CIL Label */ ;
#line 64
    if (! (i < (int )(sizeof(builtins) / sizeof(builtins[0])))) {
#line 64
      goto while_break;
    }
#line 65
    if ((int )*(builtins[i].name) == (int )*s___0) {
      {
#line 65
      tmp = strcmp((char const   *)builtins[i].name, (char const   *)s___0);
      }
#line 65
      if (tmp == 0) {
#line 66
        return (builtins[i].p);
      }
    }
#line 64
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 67
  return ((builtin_t *)((void *)0));
}
}
#line 72 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/builtins.c"
extern void funcall(char **av ) 
{ 
  Jbwrap j ;
  Estack e1 ;
  Estack e2 ;
  Edata jreturn ;
  Edata star___0 ;
  int tmp ;
  Node *tmp___0 ;
  Node *tmp___1 ;

  {
  {
#line 76
  tmp = __sigsetjmp((struct __jmp_buf_tag *)(j.j), 1);
  }
#line 76
  if (tmp) {
#line 77
    return;
  }
  {
#line 78
  starassign(*av, av + 1, (bool )1);
#line 79
  jreturn.jb = & j;
#line 80
  star___0.name = (char *)"*";
#line 81
  except((ecodes )2, jreturn, & e1);
#line 82
  except((ecodes )3, star___0, & e2);
#line 83
  tmp___0 = fnlookup(*av);
#line 83
  tmp___1 = treecpy(tmp___0, & nalloc);
#line 83
  walk(tmp___1, (bool )1);
#line 84
  varrm((char *)"*", (bool )1);
#line 85
  unexcept();
#line 86
  unexcept();
  }
#line 87
  return;
}
}
#line 89 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/builtins.c"
static void arg_count(char *name ) 
{ 


  {
  {
#line 90
  fprint(2, "too many arguments to %s\n", name);
#line 91
  set((bool )0);
  }
#line 92
  return;
}
}
#line 94 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/builtins.c"
static void badnum(char *num ) 
{ 


  {
  {
#line 95
  fprint(2, "%s is a bad number\n", num);
#line 96
  set((bool )0);
  }
#line 97
  return;
}
}
#line 101 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/builtins.c"
extern void b_exec(char **ignore ) 
{ 


  {
#line 102
  return;
}
}
#line 107 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/builtins.c"
static void b_echo(char **av ) 
{ 
  char *format ;
  int tmp ;
  int tmp___0 ;

  {
#line 108
  format = (char *)"%A\n";
#line 109
  av ++;
#line 109
  if ((unsigned long )*av != (unsigned long )((void *)0)) {
#line 110
    if ((int )*(*av) == (int )*"-n") {
      {
#line 110
      tmp___0 = strcmp((char const   *)*av, "-n");
      }
#line 110
      if (tmp___0 == 0) {
#line 111
        format = (char *)"%A";
#line 111
        av ++;
      } else {
#line 110
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 112
    if ((int )*(*av) == (int )*"--") {
      {
#line 112
      tmp = strcmp((char const   *)*av, "--");
      }
#line 112
      if (tmp == 0) {
#line 113
        av ++;
      }
    }
  }
  {
#line 115
  fprint(1, (char const   *)format, av);
#line 116
  set((bool )1);
  }
#line 117
  return;
}
}
#line 122 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/builtins.c"
static void b_cd(char **av ) 
{ 
  List *s___0 ;
  List nil ;
  char *path ;
  size_t t ;
  size_t pathlen ;
  int tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  bool tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;

  {
#line 124
  path = (char *)((void *)0);
#line 125
  pathlen = (size_t )0;
#line 126
  av ++;
#line 126
  if ((unsigned long )*av == (unsigned long )((void *)0)) {
    {
#line 127
    s___0 = varlookup((char *)"home");
    }
#line 128
    if ((unsigned long )s___0 == (unsigned long )((void *)0)) {
#line 128
      *av = (char *)"/";
    } else {
#line 128
      *av = s___0->w;
    }
  } else
#line 129
  if ((unsigned long )*(av + 1) != (unsigned long )((void *)0)) {
    {
#line 130
    arg_count((char *)"cd");
    }
#line 131
    return;
  }
  {
#line 133
  tmp___6 = isabsolute(*av);
  }
#line 133
  if (tmp___6) {
#line 133
    goto _L;
  } else
#line 133
  if ((int )*(*av) == (int )*".") {
    {
#line 133
    tmp___7 = strcmp((char const   *)*av, ".");
    }
#line 133
    if (tmp___7 == 0) {
#line 133
      goto _L;
    } else {
#line 133
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
#line 133
  if ((int )*(*av) == (int )*"..") {
    {
#line 133
    tmp___8 = strcmp((char const   *)*av, "..");
    }
#line 133
    if (tmp___8 == 0) {
      _L: /* CIL Label */ 
      {
#line 134
      tmp = chdir((char const   *)*av);
      }
#line 134
      if (tmp < 0) {
        {
#line 135
        set((bool )0);
#line 136
        uerror(*av);
        }
      } else {
        {
#line 138
        set((bool )1);
        }
      }
    } else {
#line 133
      goto _L___0;
    }
  } else {
    _L___0: /* CIL Label */ 
    {
#line 140
    s___0 = varlookup((char *)"cdpath");
    }
#line 141
    if ((unsigned long )s___0 == (unsigned long )((void *)0)) {
#line 142
      s___0 = & nil;
#line 143
      nil.w = (char *)"";
#line 144
      nil.n = (List *)((void *)0);
    }
    {
#line 146
    while (1) {
      while_continue: /* CIL Label */ ;
#line 147
      if ((unsigned long )s___0 != (unsigned long )(& nil)) {
#line 147
        if ((int )*(s___0->w) != 0) {
          {
#line 148
          tmp___0 = strlen((char const   *)*av);
#line 148
          tmp___1 = strlen((char const   *)s___0->w);
#line 148
          t = (tmp___0 + tmp___1) + 2UL;
          }
#line 149
          if (t > pathlen) {
            {
#line 150
            pathlen = t;
#line 150
            tmp___2 = nalloc(pathlen);
#line 150
            path = (char *)tmp___2;
            }
          }
          {
#line 151
          strcpy((char */* __restrict  */)path, (char const   */* __restrict  */)s___0->w);
          }
#line 152
          if ((int )*(s___0->w) == (int )*"/") {
            {
#line 152
            tmp___3 = strcmp((char const   *)s___0->w, "/");
            }
#line 152
            if (! (tmp___3 == 0)) {
              {
#line 153
              strcat((char */* __restrict  */)path, (char const   */* __restrict  */)"/");
              }
            }
          } else {
            {
#line 153
            strcat((char */* __restrict  */)path, (char const   */* __restrict  */)"/");
            }
          }
          {
#line 154
          strcat((char */* __restrict  */)path, (char const   */* __restrict  */)*av);
          }
        } else {
#line 156
          pathlen = (size_t )0;
#line 157
          path = *av;
        }
      } else {
#line 156
        pathlen = (size_t )0;
#line 157
        path = *av;
      }
      {
#line 159
      tmp___5 = chdir((char const   *)path);
      }
#line 159
      if (tmp___5 >= 0) {
        {
#line 160
        set((bool )1);
        }
#line 161
        if (interactive) {
#line 161
          if ((int )*(s___0->w) != 0) {
#line 161
            if ((int )*(s___0->w) == (int )*".") {
              {
#line 161
              tmp___4 = strcmp((char const   *)s___0->w, ".");
              }
#line 161
              if (! (tmp___4 == 0)) {
                {
#line 162
                fprint(1, "%s\n", path);
                }
              }
            } else {
              {
#line 162
              fprint(1, "%s\n", path);
              }
            }
          }
        }
#line 163
        return;
      }
#line 165
      s___0 = s___0->n;
#line 146
      if (! ((unsigned long )s___0 != (unsigned long )((void *)0))) {
#line 146
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 167
    fprint(2, "couldn\'t cd to %s\n", *av);
#line 168
    set((bool )0);
    }
  }
#line 170
  return;
}
}
#line 172 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/builtins.c"
static void b_umask(char **av ) 
{ 
  int i ;
  __mode_t tmp ;

  {
#line 174
  av ++;
#line 174
  if ((unsigned long )*av == (unsigned long )((void *)0)) {
    {
#line 175
    set((bool )1);
#line 176
    tmp = umask((__mode_t )0);
#line 176
    i = (int )tmp;
#line 177
    umask((__mode_t )i);
#line 178
    fprint(1, "0%o\n", i);
    }
  } else
#line 179
  if ((unsigned long )*(av + 1) == (unsigned long )((void *)0)) {
    {
#line 180
    i = n2u(*av, 8U);
    }
#line 181
    if ((unsigned int )i > 511U) {
      {
#line 182
      fprint(2, "bad umask\n");
#line 183
      set((bool )0);
      }
    } else {
      {
#line 185
      umask((__mode_t )i);
#line 186
      set((bool )1);
      }
    }
  } else {
    {
#line 189
    arg_count((char *)"umask");
    }
#line 190
    return;
  }
#line 192
  return;
}
}
#line 194 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/builtins.c"
static void b_exit(char **av ) 
{ 
  int tmp ;

  {
#line 195
  av ++;
#line 195
  if ((unsigned long )*av != (unsigned long )((void *)0)) {
    {
#line 196
    ssetstatus(av);
    }
  }
  {
#line 197
  tmp = getstatus();
#line 197
  rc_exit(tmp);
  }
#line 198
  return;
}
}
#line 202 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/builtins.c"
static void b_return(char **av ) 
{ 


  {
#line 203
  av ++;
#line 203
  if ((unsigned long )*av != (unsigned long )((void *)0)) {
    {
#line 204
    ssetstatus(av);
    }
  }
  {
#line 205
  rc_raise((ecodes )2);
  }
#line 206
  return;
}
}
#line 210 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/builtins.c"
static void b_break(char **av ) 
{ 


  {
#line 211
  if ((unsigned long )*(av + 1) != (unsigned long )((void *)0)) {
    {
#line 212
    arg_count((char *)"break");
    }
#line 213
    return;
  }
  {
#line 215
  rc_raise((ecodes )1);
  }
#line 216
  return;
}
}
#line 220 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/builtins.c"
static void b_shift(char **av ) 
{ 
  int shift ;
  int tmp ;
  int tmp___0 ;
  List *s___0 ;
  List *dollarzero ;
  List *tmp___1 ;
  List *tmp___2 ;

  {
#line 221
  if ((unsigned long )*(av + 1) == (unsigned long )((void *)0)) {
#line 221
    tmp___0 = 1;
  } else {
    {
#line 221
    tmp = n2u(*(av + 1), 10U);
#line 221
    tmp___0 = tmp;
    }
  }
#line 221
  shift = tmp___0;
#line 223
  if ((unsigned long )*(av + 1) != (unsigned long )((void *)0)) {
#line 223
    if ((unsigned long )*(av + 2) != (unsigned long )((void *)0)) {
      {
#line 224
      arg_count((char *)"shift");
      }
#line 225
      return;
    }
  }
#line 227
  if (shift < 0) {
    {
#line 228
    badnum(*(av + 1));
    }
#line 229
    return;
  }
  {
#line 231
  tmp___1 = varlookup((char *)"*");
#line 231
  s___0 = tmp___1->n;
#line 232
  dollarzero = varlookup((char *)"0");
  }
  {
#line 233
  while (1) {
    while_continue: /* CIL Label */ ;
#line 233
    if ((unsigned long )s___0 != (unsigned long )((void *)0)) {
#line 233
      if (! (shift != 0)) {
#line 233
        goto while_break;
      }
    } else {
#line 233
      goto while_break;
    }
#line 234
    s___0 = s___0->n;
#line 235
    shift --;
  }
  while_break: /* CIL Label */ ;
  }
#line 237
  if ((unsigned long )s___0 == (unsigned long )((void *)0)) {
#line 237
    if (shift != 0) {
      {
#line 238
      fprint(2, "cannot shift\n");
#line 239
      set((bool )0);
      }
    } else {
      {
#line 241
      tmp___2 = append(dollarzero, s___0);
#line 241
      varassign((char *)"*", tmp___2, (bool )0);
#line 242
      set((bool )1);
      }
    }
  } else {
    {
#line 241
    tmp___2 = append(dollarzero, s___0);
#line 241
    varassign((char *)"*", tmp___2, (bool )0);
#line 242
    set((bool )1);
    }
  }
#line 244
  return;
}
}
#line 248 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/builtins.c"
extern void b_builtin(char **ignore ) 
{ 


  {
#line 249
  return;
}
}
#line 253 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/builtins.c"
static void b_wait(char **av ) 
{ 
  int status ;
  pid_t pid ;
  pid_t tmp ;

  {
#line 256
  if ((unsigned long )*(av + 1) == (unsigned long )((void *)0)) {
    {
#line 257
    waitforall();
    }
#line 258
    return;
  }
#line 260
  if ((unsigned long )*(av + 2) != (unsigned long )((void *)0)) {
    {
#line 261
    arg_count((char *)"wait");
    }
#line 262
    return;
  }
  {
#line 264
  pid = n2u(*(av + 1), 10U);
  }
#line 264
  if (pid < 0) {
    {
#line 265
    badnum(*(av + 1));
    }
#line 266
    return;
  }
  {
#line 268
  tmp = rc_wait4(pid, & status, (bool )0);
  }
#line 268
  if (tmp > 0) {
    {
#line 269
    setstatus(pid, status);
    }
  } else {
    {
#line 271
    set((bool )0);
    }
  }
  {
#line 272
  sigchk();
  }
#line 273
  return;
}
}
#line 283 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/builtins.c"
static bool issig(char *s___0 ) 
{ 
  int i ;
  int tmp ;

  {
#line 285
  i = 0;
  {
#line 285
  while (1) {
    while_continue: /* CIL Label */ ;
#line 285
    if (! (i < 65)) {
#line 285
      goto while_break;
    }
#line 286
    if ((int )*s___0 == (int )*(signals[i].name)) {
      {
#line 286
      tmp = strcmp((char const   *)s___0, (char const   *)signals[i].name);
      }
#line 286
      if (tmp == 0) {
#line 287
        return ((bool )1);
      }
    }
#line 285
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 288
  return ((bool )0);
}
}
#line 291 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/builtins.c"
static void b_whatis(char **av ) 
{ 
  bool ess ;
  bool eff ;
  bool vee ;
  bool pee ;
  bool bee ;
  bool f ;
  bool found ;
  int i ;
  int ac ;
  int c ;
  List *s___0 ;
  Node *n ;
  char *e ;
  int *tmp ;
  builtin_t *tmp___0 ;
  bool tmp___1 ;
  int *tmp___2 ;

  {
#line 298
  ac = 0;
#line 298
  rc_optind = ac;
  {
#line 298
  while (1) {
    while_continue: /* CIL Label */ ;
#line 298
    if (! ((unsigned long )*(av + ac) != (unsigned long )((void *)0))) {
#line 298
      goto while_break;
    }
#line 298
    ac ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 300
  bee = (bool )0;
#line 300
  pee = bee;
#line 300
  vee = pee;
#line 300
  eff = vee;
#line 300
  ess = eff;
  {
#line 301
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 301
    c = rc_getopt(ac, av, (char *)"sfvpb");
    }
#line 301
    if (! (c != -1)) {
#line 301
      goto while_break___0;
    }
    {
#line 304
    if (c == 115) {
#line 304
      goto case_115;
    }
#line 305
    if (c == 102) {
#line 305
      goto case_102;
    }
#line 306
    if (c == 118) {
#line 306
      goto case_118;
    }
#line 307
    if (c == 112) {
#line 307
      goto case_112;
    }
#line 308
    if (c == 98) {
#line 308
      goto case_98;
    }
#line 303
    goto switch_default;
    switch_default: /* CIL Label */ 
    {
#line 303
    set((bool )0);
    }
#line 303
    return;
    case_115: /* CIL Label */ 
#line 304
    ess = (bool )1;
#line 304
    goto switch_break;
    case_102: /* CIL Label */ 
#line 305
    eff = (bool )1;
#line 305
    goto switch_break;
    case_118: /* CIL Label */ 
#line 306
    vee = (bool )1;
#line 306
    goto switch_break;
    case_112: /* CIL Label */ 
#line 307
    pee = (bool )1;
#line 307
    goto switch_break;
    case_98: /* CIL Label */ 
#line 308
    bee = (bool )1;
#line 308
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 310
  av += rc_optind;
#line 311
  if ((unsigned long )*av == (unsigned long )((void *)0)) {
#line 312
    if ((unsigned int )vee | (unsigned int )eff) {
      {
#line 313
      whatare_all_vars(eff, vee);
      }
    }
#line 314
    if (ess) {
      {
#line 315
      whatare_all_signals();
      }
    }
#line 316
    if (bee) {
#line 317
      i = 0;
      {
#line 317
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 317
        if (! (i < (int )(sizeof(builtins) / sizeof(builtins[0])))) {
#line 317
          goto while_break___1;
        }
        {
#line 318
        fprint(1, "builtin %s\n", builtins[i].name);
#line 317
        i ++;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
    }
#line 319
    if (pee) {
      {
#line 320
      fprint(2, "whatis -p: must specify argument\n");
      }
    }
#line 321
    if ((((((unsigned int )eff | (unsigned int )vee) | (unsigned int )pee) | (unsigned int )bee) | (unsigned int )ess) ^ 1U) {
      {
#line 322
      whatare_all_vars((bool )1, (bool )1);
      }
    }
    {
#line 323
    set((bool )1);
    }
#line 324
    return;
  }
#line 326
  found = (bool )1;
#line 327
  i = 0;
  {
#line 327
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 327
    if (! ((unsigned long )*(av + i) != (unsigned long )((void *)0))) {
#line 327
      goto while_break___2;
    }
    {
#line 328
    f = (bool )0;
#line 329
    tmp = __errno_location();
#line 329
    *tmp = 2;
    }
#line 330
    if (((((((unsigned int )eff | (unsigned int )vee) | (unsigned int )pee) | (unsigned int )bee) | (unsigned int )ess) ^ 1U) | (unsigned int )vee) {
      {
#line 330
      s___0 = varlookup(*(av + i));
      }
#line 330
      if ((unsigned long )s___0 != (unsigned long )((void *)0)) {
        {
#line 331
        f = (bool )1;
#line 332
        prettyprint_var(1, *(av + i), s___0);
        }
      }
    }
#line 334
    if (((((((unsigned int )eff | (unsigned int )vee) | (unsigned int )pee) | (unsigned int )bee) | (unsigned int )ess) ^ 1U) | (unsigned int )ess) {
      {
#line 334
      tmp___1 = issig(*(av + i));
      }
#line 334
      if (tmp___1) {
#line 334
        goto _L___1;
      } else {
#line 334
        goto _L___2;
      }
    } else
    _L___2: /* CIL Label */ 
#line 334
    if (((((((unsigned int )eff | (unsigned int )vee) | (unsigned int )pee) | (unsigned int )bee) | (unsigned int )ess) ^ 1U) | (unsigned int )eff) {
      _L___1: /* CIL Label */ 
      {
#line 334
      n = fnlookup(*(av + i));
      }
#line 334
      if ((unsigned long )n != (unsigned long )((void *)0)) {
        {
#line 335
        f = (bool )1;
#line 336
        prettyprint_fn(1, *(av + i), n);
        }
      } else {
#line 334
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 337
    if (((((((unsigned int )eff | (unsigned int )vee) | (unsigned int )pee) | (unsigned int )bee) | (unsigned int )ess) ^ 1U) | (unsigned int )bee) {
      {
#line 337
      tmp___0 = isbuiltin(*(av + i));
      }
#line 337
      if ((unsigned long )tmp___0 != (unsigned long )((void *)0)) {
        {
#line 338
        f = (bool )1;
#line 339
        fprint(1, "builtin %s\n", *(av + i));
        }
      } else {
#line 337
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 340
    if (((((((unsigned int )eff | (unsigned int )vee) | (unsigned int )pee) | (unsigned int )bee) | (unsigned int )ess) ^ 1U) | (unsigned int )pee) {
      {
#line 340
      e = which(*(av + i), (bool )0);
      }
#line 340
      if ((unsigned long )e != (unsigned long )((void *)0)) {
        {
#line 341
        f = (bool )1;
#line 342
        fprint(1, "%S\n", e);
        }
      }
    }
#line 344
    if (! f) {
      {
#line 345
      found = (bool )0;
#line 346
      tmp___2 = __errno_location();
      }
#line 346
      if (*tmp___2 != 2) {
        {
#line 347
        uerror(*(av + i));
        }
      } else {
        {
#line 349
        fprint(2, "%s not found\n", *(av + i));
        }
      }
    }
#line 327
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 352
  set(found);
  }
#line 353
  return;
}
}
#line 357 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/builtins.c"
static void b_eval(char **av ) 
{ 
  bool i ;

  {
#line 358
  i = interactive;
#line 359
  if ((unsigned long )*(av + 1) == (unsigned long )((void *)0)) {
#line 360
    return;
  }
  {
#line 361
  interactive = (bool )0;
#line 362
  pushstring(av + 1, i);
#line 363
  doit((bool )1);
#line 364
  interactive = i;
  }
#line 365
  return;
}
}
#line 372 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/builtins.c"
extern void b_dot(char **av ) 
{ 
  int fd ;
  bool old_i ;
  bool i ;
  Estack e ;
  Edata star___0 ;
  int tmp ;

  {
#line 374
  old_i = interactive;
#line 374
  i = (bool )0;
#line 377
  av ++;
#line 378
  if ((unsigned long )*av == (unsigned long )((void *)0)) {
#line 379
    return;
  }
#line 380
  if ((int )*(*av) == (int )*"-i") {
    {
#line 380
    tmp = strcmp((char const   *)*av, "-i");
    }
#line 380
    if (tmp == 0) {
#line 381
      av ++;
#line 382
      i = (bool )1;
    }
  }
#line 384
  if (dasheye) {
#line 385
    dasheye = (bool )0;
#line 386
    i = (bool )1;
  }
#line 388
  if ((unsigned long )*av == (unsigned long )((void *)0)) {
#line 389
    return;
  }
  {
#line 390
  fd = rc_open((char const   *)*av, (redirtype )0);
  }
#line 391
  if (fd < 0) {
#line 392
    if (rcrc) {
#line 393
      rcrc = (bool )0;
    } else {
      {
#line 395
      uerror(*av);
#line 396
      set((bool )0);
      }
    }
#line 398
    return;
  }
  {
#line 400
  rcrc = (bool )0;
#line 401
  starassign(*av, av + 1, (bool )1);
#line 402
  pushfd(fd);
#line 403
  interactive = i;
#line 404
  star___0.name = (char *)"*";
#line 405
  except((ecodes )3, star___0, & e);
#line 406
  doit((bool )1);
#line 407
  varrm((char *)"*", (bool )1);
#line 408
  unexcept();
#line 409
  interactive = old_i;
  }
#line 410
  return;
}
}
#line 414 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/builtins.c"
static void b_newpgrp(char **av ) 
{ 


  {
#line 415
  if ((unsigned long )*(av + 1) != (unsigned long )((void *)0)) {
    {
#line 416
    arg_count((char *)"newpgrp");
    }
#line 417
    return;
  }
  {
#line 419
  setpgid(rc_pid, rc_pid);
#line 420
  tcsetpgrp(2, rc_pid);
  }
#line 421
  return;
}
}
#line 426 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/builtins.c"
static struct Suffix  const  kbsuf  =    {(struct Suffix  const  *)((void *)0), 1024L, (char *)"k"};
#line 426 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/builtins.c"
static struct Suffix  const  mbsuf  =    {& kbsuf, 1048576L, (char *)"m"};
#line 426 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/builtins.c"
static struct Suffix  const  gbsuf  =    {& mbsuf, 1073741824L, (char *)"g"};
#line 426 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/builtins.c"
static struct Suffix  const  stsuf  =    {(struct Suffix  const  *)((void *)0), 1L, (char *)"s"};
#line 426 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/builtins.c"
static struct Suffix  const  mtsuf  =    {& stsuf, 60L, (char *)"m"};
#line 426 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/builtins.c"
static struct Suffix  const  htsuf  =    {& mtsuf, 3600L, (char *)"h"};
#line 437 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/builtins.c"
static struct Limit  const  limits[12]  = 
#line 437
  {      {(char *)"cputime", 0, & htsuf}, 
        {(char *)"filesize", 1, & gbsuf}, 
        {(char *)"datasize", 2, & gbsuf}, 
        {(char *)"stacksize", 3, & gbsuf}, 
        {(char *)"coredumpsize", 4, & gbsuf}, 
        {(char *)"descriptors", 7, (struct Suffix  const  *)((struct Suffix *)((void *)0))}, 
        {(char *)"memoryuse",
      9, & gbsuf}, 
        {(char *)"memoryrss", 5, & gbsuf}, 
        {(char *)"maxproc", 6, (struct Suffix  const  *)((struct Suffix *)((void *)0))}, 
        {(char *)"memorylocked",
      8, & gbsuf}, 
        {(char *)"filelocks", 10, (struct Suffix  const  *)((struct Suffix *)((void *)0))}, 
        {(char *)((void *)0),
      0, (struct Suffix  const  *)((void *)0)}};
#line 467 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/builtins.c"
static void printlimit(struct Limit  const  *limit , bool hard ) 
{ 
  struct rlimit rlim ;
  rlim_t lim ;
  struct Suffix  const  *suf ;
  char const   *tmp ;

  {
  {
#line 470
  getrlimit((__rlimit_resource_t )limit->flag, & rlim);
  }
#line 471
  if (hard) {
#line 472
    lim = rlim.rlim_max;
  } else {
#line 474
    lim = rlim.rlim_cur;
  }
#line 475
  if (lim == 0xffffffffffffffffUL) {
    {
#line 476
    fprint(1, "%s \tunlimited\n", limit->name);
    }
  } else {
#line 479
    suf = (struct Suffix  const  *)limit->suffix;
    {
#line 479
    while (1) {
      while_continue: /* CIL Label */ ;
#line 479
      if (! ((unsigned long )suf != (unsigned long )((void *)0))) {
#line 479
        goto while_break;
      }
#line 480
      if (lim % (unsigned long )suf->amount == 0UL) {
#line 480
        if (lim != 0UL) {
#line 481
          lim /= (rlim_t )suf->amount;
#line 482
          goto while_break;
        } else
#line 480
        if (suf->amount > 1L) {
#line 481
          lim /= (rlim_t )suf->amount;
#line 482
          goto while_break;
        }
      }
#line 479
      suf = (struct Suffix  const  *)suf->next;
    }
    while_break: /* CIL Label */ ;
    }
#line 484
    if ((unsigned long )suf == (unsigned long )((void *)0)) {
#line 484
      tmp = (char const   */* const  */)"";
    } else
#line 484
    if (lim == 0UL) {
#line 484
      tmp = (char const   */* const  */)"";
    } else {
#line 484
      tmp = (char const   */* const  */)suf->name;
    }
    {
#line 484
    fprint(1, "%s \t%ld%s\n", limit->name, (long )lim, tmp);
    }
  }
#line 486
  return;
}
}
#line 488 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/builtins.c"
static bool parselimit(struct Limit  const  *resource , rlim_t *limit , char *s___0 ) 
{ 
  char *t ;
  int len ;
  size_t tmp ;
  struct Suffix  const  *suf ;
  int tmp___0 ;
  int min ;
  int sec ;
  char *tmp___1 ;
  int n ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;

  {
  {
#line 490
  tmp = strlen((char const   *)s___0);
#line 490
  len = (int )tmp;
#line 491
  suf = (struct Suffix  const  *)resource->suffix;
#line 493
  *limit = (rlim_t )1;
  }
#line 494
  if ((int )*s___0 == (int )*"unlimited") {
    {
#line 494
    tmp___0 = strcmp((char const   *)s___0, "unlimited");
    }
#line 494
    if (tmp___0 == 0) {
#line 495
      *limit = (__rlim_t )-1;
#line 496
      return ((bool )1);
    }
  }
#line 498
  if ((unsigned long )suf == (unsigned long )(& htsuf)) {
    {
#line 498
    t = strchr((char const   *)s___0, ':');
    }
#line 498
    if ((unsigned long )t != (unsigned long )((void *)0)) {
      {
#line 500
      tmp___1 = t;
#line 500
      t ++;
#line 500
      *tmp___1 = (char )'\000';
#line 501
      min = n2u(s___0, 10U);
#line 501
      sec = n2u(t, 10U);
      }
#line 502
      if (min == -1) {
#line 502
        return ((bool )0);
      } else
#line 502
      if (sec == -1) {
#line 502
        return ((bool )0);
      }
#line 503
      *limit = (rlim_t )(60 * min + sec);
    } else {
#line 498
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    {
#line 506
    while (1) {
      while_continue: /* CIL Label */ ;
#line 506
      if (! ((unsigned long )suf != (unsigned long )((void *)0))) {
#line 506
        goto while_break;
      }
      {
#line 507
      tmp___3 = strlen((char const   *)suf->name);
      }
#line 507
      if ((int )*(suf->name) == (int )*((s___0 + len) - tmp___3)) {
        {
#line 507
        tmp___4 = strlen((char const   *)suf->name);
#line 507
        tmp___5 = strcmp((char const   *)suf->name, (char const   *)((s___0 + len) - tmp___4));
        }
#line 507
        if (tmp___5 == 0) {
          {
#line 508
          tmp___2 = strlen((char const   *)suf->name);
#line 508
          *(s___0 + ((size_t )len - tmp___2)) = (char )'\000';
#line 509
          *limit *= (rlim_t )suf->amount;
          }
#line 510
          goto while_break;
        }
      }
#line 506
      suf = (struct Suffix  const  *)suf->next;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 512
    n = n2u(s___0, 10U);
    }
#line 513
    if (n == -1) {
#line 513
      return ((bool )0);
    }
#line 514
    *limit *= (rlim_t )n;
  }
#line 516
  return ((bool )1);
}
}
#line 519 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/builtins.c"
static void b_limit(char **av ) 
{ 
  struct Limit  const  *lp ;
  bool hard ;
  int tmp ;
  int tmp___0 ;
  struct rlimit rlim ;
  rlim_t pl ;
  bool tmp___1 ;
  int tmp___2 ;

  {
#line 520
  lp = limits;
#line 521
  hard = (bool )0;
#line 522
  av ++;
#line 522
  if ((unsigned long )*av != (unsigned long )((void *)0)) {
#line 522
    if ((int )*(*av) == (int )*"-h") {
      {
#line 522
      tmp = strcmp((char const   *)*av, "-h");
      }
#line 522
      if (tmp == 0) {
#line 523
        av ++;
#line 524
        hard = (bool )1;
      }
    }
  }
#line 526
  if ((unsigned long )*av == (unsigned long )((void *)0)) {
    {
#line 527
    while (1) {
      while_continue: /* CIL Label */ ;
#line 527
      if (! ((unsigned long )lp->name != (unsigned long )((void *)0))) {
#line 527
        goto while_break;
      }
      {
#line 528
      printlimit(lp, hard);
#line 527
      lp ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 529
    return;
  }
  {
#line 531
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 532
    if ((unsigned long )lp->name == (unsigned long )((void *)0)) {
      {
#line 533
      fprint(2, "no such limit\n");
#line 534
      set((bool )0);
      }
#line 535
      return;
    }
#line 537
    if ((int )*(*av) == (int )*(lp->name)) {
      {
#line 537
      tmp___0 = strcmp((char const   *)*av, (char const   *)lp->name);
      }
#line 537
      if (tmp___0 == 0) {
#line 538
        goto while_break___0;
      }
    }
#line 531
    lp ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 540
  av ++;
#line 540
  if ((unsigned long )*av == (unsigned long )((void *)0)) {
    {
#line 541
    printlimit(lp, hard);
    }
  } else {
    {
#line 545
    getrlimit((__rlimit_resource_t )lp->flag, & rlim);
#line 546
    tmp___1 = parselimit(lp, & pl, *av);
    }
#line 546
    if (! tmp___1) {
      {
#line 547
      fprint(2, "bad limit\n");
#line 548
      set((bool )0);
      }
#line 549
      return;
    }
#line 551
    if (hard) {
#line 552
      rlim.rlim_max = pl;
    } else {
#line 554
      rlim.rlim_cur = pl;
    }
    {
#line 555
    tmp___2 = setrlimit((__rlimit_resource_t )lp->flag, (struct rlimit  const  *)(& rlim));
    }
#line 555
    if (tmp___2 == -1) {
      {
#line 556
      uerror((char *)"setrlimit");
#line 557
      set((bool )0);
      }
    } else {
      {
#line 559
      set((bool )1);
      }
    }
  }
#line 561
  return;
}
}
#line 175 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/rc.h"
bool dashee ;
#line 10 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/status.c"
static int statuses[512]  ;
#line 11 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/status.c"
static int pipelength  =    1;
#line 18 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/status.c"
extern int istrue(void) 
{ 
  int i ;

  {
#line 20
  i = 0;
  {
#line 20
  while (1) {
    while_continue: /* CIL Label */ ;
#line 20
    if (! (i < pipelength)) {
#line 20
      goto while_break;
    }
#line 21
    if (statuses[i] != 0) {
#line 22
      return (0);
    }
#line 20
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 23
  return (1);
}
}
#line 33 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/status.c"
extern int getstatus(void) 
{ 
  int s___0 ;
  int tmp ;
  int tmp___0 ;
  union __anonunion_52 __constr_expr_1 ;
  union __anonunion_53 __constr_expr_2 ;

  {
#line 35
  if (pipelength > 1) {
    {
#line 36
    tmp = istrue();
    }
#line 36
    if (tmp) {
#line 36
      tmp___0 = 0;
    } else {
#line 36
      tmp___0 = 1;
    }
#line 36
    return (tmp___0);
  }
#line 37
  s___0 = statuses[0];
#line 38
  __constr_expr_1.__in = s___0;
#line 38
  if ((int )((signed char )((__constr_expr_1.__i & 127) + 1)) >> 1 > 0) {
#line 39
    return (1);
  }
#line 40
  __constr_expr_2.__in = s___0;
#line 40
  return ((__constr_expr_2.__i & 65280) >> 8);
}
}
#line 43 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/status.c"
extern void set(bool code ) 
{ 
  int tmp ;

  {
#line 44
  if (code) {
#line 44
    tmp = 0;
  } else {
#line 44
    tmp = 256;
  }
  {
#line 44
  setstatus(-1, tmp);
  }
#line 45
  return;
}
}
#line 49 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/status.c"
extern void setpipestatus(int *stats , int num ) 
{ 
  int i ;

  {
#line 51
  i = 0;
  {
#line 51
  while (1) {
    while_continue: /* CIL Label */ ;
#line 51
    pipelength = num;
#line 51
    if (! (i < pipelength)) {
#line 51
      goto while_break;
    }
    {
#line 52
    statprint(-1, *(stats + i));
#line 53
    statuses[i] = *(stats + i);
#line 51
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 55
  return;
}
}
#line 59 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/status.c"
extern void setstatus(pid_t pid , int i ) 
{ 


  {
  {
#line 60
  pipelength = 1;
#line 61
  statuses[0] = i;
#line 62
  statprint(pid, i);
  }
#line 63
  return;
}
}
#line 67 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/status.c"
extern void statprint(pid_t pid , int i ) 
{ 
  int t ;
  union __anonunion_54 __constr_expr_3 ;
  char *msg ;
  union __anonunion_55 __constr_expr_4 ;
  char const   *tmp ;
  union __anonunion_56 __constr_expr_5 ;
  int tmp___0 ;

  {
#line 68
  __constr_expr_5.__in = i;
#line 68
  if ((int )((signed char )((__constr_expr_5.__i & 127) + 1)) >> 1 > 0) {
#line 69
    __constr_expr_3.__in = i;
#line 69
    t = __constr_expr_3.__i & 127;
#line 70
    if (t > 0) {
#line 70
      if (t < 65) {
#line 70
        __constr_expr_4.__in = i;
#line 70
        tmp = (char const   *)signals[__constr_expr_4.__i & 127].msg;
      } else {
#line 70
        tmp = "";
      }
    } else {
#line 70
      tmp = "";
    }
#line 70
    msg = (char *)tmp;
#line 71
    if (pid != -1) {
      {
#line 72
      fprint(2, "%ld: ", (long )pid);
      }
    }
#line 73
    if ((i & 128) != 0) {
#line 74
      if ((int )*msg == 0) {
        {
#line 75
        fprint(2, "core dumped\n");
        }
      } else {
        {
#line 77
        fprint(2, "%s--core dumped\n", msg);
        }
      }
    } else
#line 78
    if ((int )*msg != 0) {
      {
#line 79
      fprint(2, "%s\n", msg);
      }
    }
  }
#line 81
  if (i != 0) {
#line 81
    if (dashee) {
#line 81
      if (! cond) {
        {
#line 82
        tmp___0 = getstatus();
#line 82
        rc_exit(tmp___0);
        }
      }
    }
  }
#line 83
  return;
}
}
#line 87 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/status.c"
extern List *sgetstatus(void) 
{ 
  List *r ;
  int i ;
  List *q ;
  void *tmp ;

  {
#line 88
  r = (List *)((void *)0);
#line 91
  i = 0;
  {
#line 91
  while (1) {
    while_continue: /* CIL Label */ ;
#line 91
    if (! (i < pipelength)) {
#line 91
      goto while_break;
    }
    {
#line 92
    tmp = nalloc(sizeof(List ));
#line 92
    q = (List *)tmp;
#line 93
    q->w = strstatus(statuses[i]);
#line 94
    q->m = (char *)((void *)0);
#line 95
    q->n = r;
#line 96
    r = q;
#line 91
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 99
  return (r);
}
}
#line 104 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/status.c"
extern char *strstatus(int s___0 ) 
{ 
  int t ;
  union __anonunion_57 __constr_expr_6 ;
  char const   *core ;
  char const   *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  union __anonunion_58 __constr_expr_7 ;
  char *tmp___2 ;
  union __anonunion_59 __constr_expr_8 ;

  {
#line 105
  __constr_expr_8.__in = s___0;
#line 105
  if ((int )((signed char )((__constr_expr_8.__i & 127) + 1)) >> 1 > 0) {
#line 106
    __constr_expr_6.__in = s___0;
#line 106
    t = __constr_expr_6.__i & 127;
#line 107
    if ((s___0 & 128) != 0) {
#line 107
      tmp = "+core";
    } else {
#line 107
      tmp = "";
    }
#line 107
    core = tmp;
#line 108
    if (t > 0) {
#line 108
      if (t < 65) {
#line 108
        if ((int )*(signals[t].name) != 0) {
          {
#line 109
          tmp___0 = nprint("%s%s", signals[t].name, core);
          }
#line 109
          return (tmp___0);
        } else {
          {
#line 111
          tmp___1 = nprint("-%d%s", t, core);
          }
#line 111
          return (tmp___1);
        }
      } else {
        {
#line 111
        tmp___1 = nprint("-%d%s", t, core);
        }
#line 111
        return (tmp___1);
      }
    } else {
      {
#line 111
      tmp___1 = nprint("-%d%s", t, core);
      }
#line 111
      return (tmp___1);
    }
  } else {
    {
#line 113
    __constr_expr_7.__in = s___0;
#line 113
    tmp___2 = nprint("%d", (__constr_expr_7.__i & 65280) >> 8);
    }
#line 113
    return (tmp___2);
  }
}
}
#line 116 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/status.c"
extern void ssetstatus(char **av ) 
{ 
  int i ;
  int j ;
  int k ;
  int l ;
  bool found ;
  size_t len ;
  size_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 119
  l = 0;
  {
#line 119
  while (1) {
    while_continue: /* CIL Label */ ;
#line 119
    if (! ((unsigned long )*(av + l) != (unsigned long )((void *)0))) {
#line 119
      goto while_break;
    }
#line 119
    l ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 121
  l --;
#line 122
  i = 0;
  {
#line 122
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 122
    if (! ((unsigned long )*(av + i) != (unsigned long )((void *)0))) {
#line 122
      goto while_break___0;
    }
    {
#line 123
    j = n2u(*(av + i), 10U);
    }
#line 124
    if (j >= 0) {
#line 125
      statuses[l - i] = j << 8;
#line 126
      goto __Cont;
    }
#line 128
    found = (bool )0;
#line 129
    k = 0;
    {
#line 129
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 129
      if (! (k < 65)) {
#line 129
        goto while_break___1;
      }
#line 130
      if ((int )*(signals[k].name) == (int )*(*(av + i))) {
        {
#line 130
        tmp___2 = strcmp((char const   *)signals[k].name, (char const   *)*(av + i));
        }
#line 130
        if (tmp___2 == 0) {
#line 131
          statuses[l - i] = k;
#line 132
          found = (bool )1;
#line 133
          goto while_break___1;
        } else {
#line 130
          goto _L;
        }
      } else {
        _L: /* CIL Label */ 
        {
#line 136
        tmp = strlen((char const   *)signals[k].name);
#line 136
        len = tmp;
#line 137
        tmp___0 = strncmp((char const   *)signals[k].name, (char const   *)*(av + i),
                          len);
        }
#line 137
        if (tmp___0 == 0) {
#line 137
          if ((int )*(*(av + i) + len) == (int )*"+core") {
            {
#line 137
            tmp___1 = strcmp((char const   *)(*(av + i) + len), "+core");
            }
#line 137
            if (tmp___1 == 0) {
#line 138
              statuses[l - i] = k + 128;
#line 139
              found = (bool )1;
#line 140
              goto while_break___1;
            }
          }
        }
      }
#line 129
      k ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 144
    if (! found) {
      {
#line 145
      fprint(2, "bad status\n");
#line 146
      set((bool )0);
      }
#line 147
      return;
    }
    __Cont: /* CIL Label */ 
#line 122
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 150
  pipelength = i;
#line 151
  return;
}
}
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 480
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 308 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/rc.h"
extern void nfree(void) ;
#line 4 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/nalloc.c"
static struct Block *fl  ;
#line 4 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/nalloc.c"
static struct Block *ul  ;
#line 16 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/nalloc.c"
static void getblock(size_t n ) 
{ 
  Block *r ;
  Block *p ;
  void *tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;

  {
#line 18
  r = fl;
#line 18
  p = (Block *)((void *)0);
  {
#line 18
  while (1) {
    while_continue: /* CIL Label */ ;
#line 18
    if (! ((unsigned long )r != (unsigned long )((void *)0))) {
#line 18
      goto while_break;
    }
#line 19
    if (n <= r->size) {
#line 20
      goto while_break;
    }
#line 18
    p = r;
#line 18
    r = r->n;
  }
  while_break: /* CIL Label */ ;
  }
#line 21
  if ((unsigned long )r != (unsigned long )((void *)0)) {
#line 22
    if ((unsigned long )p != (unsigned long )((void *)0)) {
#line 23
      p->n = r->n;
    } else {
#line 25
      fl = r->n;
    }
  } else {
    {
#line 27
    tmp = ealloc(sizeof(Block ));
#line 27
    r = (Block *)tmp;
#line 28
    tmp___0 = ((n + 4096UL) - 1UL) & 0xfffffffffffff000UL;
#line 28
    r->size = tmp___0;
#line 28
    tmp___1 = ealloc(tmp___0);
#line 28
    r->mem = (char *)tmp___1;
    }
  }
#line 30
  r->used = (size_t )0;
#line 31
  r->n = ul;
#line 32
  ul = r;
#line 33
  return;
}
}
#line 44 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/nalloc.c"
extern void *nalloc(size_t n ) 
{ 
  size_t base ;
  Block *ulp ;

  {
#line 47
  n = ((n + sizeof(align_t )) - 1UL) & ~ (sizeof(align_t ) - 1UL);
#line 48
  ulp = ul;
#line 49
  if ((unsigned long )ulp != (unsigned long )((void *)0)) {
#line 49
    base = ulp->used;
#line 49
    if (n + base < ulp->size) {
#line 50
      ulp->used = base + n;
#line 51
      return ((void *)(ulp->mem + base));
    } else {
#line 49
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    {
#line 53
    getblock(n);
    }
#line 54
    if (! (ul->used == 0UL)) {
      {
#line 54
      __assert_fail("ul->used == 0", "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/nalloc.c",
                    54U, "nalloc");
      }
    }
#line 55
    ulp = ul;
#line 55
    ulp->used = n;
#line 56
    return ((void *)(ulp->mem + 0));
  }
}
}
#line 68 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/nalloc.c"
extern void nfree(void) 
{ 
  size_t count___0 ;
  Block *r ;
  Block *tmp ;

  {
#line 71
  if ((unsigned long )ul == (unsigned long )((void *)0)) {
#line 72
    return;
  }
#line 73
  r = ul;
  {
#line 73
  while (1) {
    while_continue: /* CIL Label */ ;
#line 73
    if (! ((unsigned long )r->n != (unsigned long )((void *)0))) {
#line 73
      goto while_break;
    }
#line 73
    r = r->n;
  }
  while_break: /* CIL Label */ ;
  }
#line 75
  r->n = fl;
#line 76
  fl = ul;
#line 77
  ul = (struct Block *)((void *)0);
#line 78
  r = fl;
#line 78
  count___0 = r->size;
  {
#line 78
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 78
    if (! ((unsigned long )r->n != (unsigned long )((void *)0))) {
#line 78
      goto while_break___0;
    }
#line 79
    if (count___0 >= 500000UL) {
#line 80
      tmp = r;
#line 81
      r = r->n;
#line 82
      tmp->n = (Block *)((void *)0);
      {
#line 83
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 83
        if (! ((unsigned long )r != (unsigned long )((void *)0))) {
#line 83
          goto while_break___1;
        }
        {
#line 84
        tmp = r->n;
#line 85
        efree((void *)r->mem);
#line 86
        efree((void *)r);
#line 87
        r = tmp;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 89
      return;
    }
#line 78
    r = r->n;
#line 78
    count___0 += r->size;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 92
  return;
}
}
#line 99 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/nalloc.c"
extern Block *newblock(void) 
{ 
  Block *old ;

  {
#line 100
  old = ul;
#line 101
  ul = (struct Block *)((void *)0);
#line 102
  return (old);
}
}
#line 107 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/nalloc.c"
extern void restoreblock(Block *old ) 
{ 


  {
  {
#line 108
  nfree();
#line 109
  ul = old;
  }
#line 110
  return;
}
}
#line 114 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/nalloc.c"
extern void *ealloc(size_t n ) 
{ 
  void *p ;

  {
#line 117
  if (! n) {
    {
#line 117
    __assert_fail("n", "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/nalloc.c",
                  117U, "ealloc");
    }
  }
  {
#line 118
  p = malloc(n);
  }
#line 119
  if ((unsigned long )p == (unsigned long )((void *)0)) {
    {
#line 120
    uerror((char *)"malloc");
#line 121
    rc_exit(1);
    }
  }
#line 123
  return (p);
}
}
#line 126 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/nalloc.c"
extern void *erealloc(void *p , size_t n ) 
{ 
  void *tmp ;

  {
#line 127
  if ((unsigned long )p == (unsigned long )((void *)0)) {
    {
#line 128
    tmp = ealloc(n);
    }
#line 128
    return (tmp);
  }
  {
#line 129
  p = realloc(p, n);
  }
#line 129
  if ((unsigned long )p == (unsigned long )((void *)0)) {
    {
#line 130
    uerror((char *)"realloc");
#line 131
    rc_exit(1);
    }
  }
#line 133
  return (p);
}
}
#line 136 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/nalloc.c"
extern void efree(void *p ) 
{ 


  {
#line 137
  if ((unsigned long )p != (unsigned long )((void *)0)) {
    {
#line 138
    free(p);
    }
  }
#line 139
  return;
}
}
#line 779 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) isatty)(int __fd ) ;
#line 175 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/rc.h"
bool dashdee  ;
#line 175 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/rc.h"
bool dashee  ;
#line 175 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/rc.h"
bool dashvee  ;
#line 175 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/rc.h"
bool dashex  ;
#line 175 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/rc.h"
bool dashell  ;
#line 175 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/rc.h"
bool dasheye  ;
#line 175 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/rc.h"
bool dashen  ;
#line 175 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/rc.h"
bool dashpee  ;
#line 175 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/rc.h"
bool interactive  ;
#line 177 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/rc.h"
pid_t rc_pid  ;
#line 251
extern void initenv(char **envp ) ;
#line 252
extern void inithash(void) ;
#line 344
void initparse(void) ;
#line 5 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/main.c"
bool dashEYE  ;
#line 5 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/main.c"
bool dashess  ;
#line 9 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/main.c"
static bool dashoh  ;
#line 11
static void assigndefault(char *name  , ...) ;
#line 12
static void checkfd(int fd , enum redirtype r ) ;
#line 108 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/main.c"
static void assigndefault(char *name  , ...) 
{ 
  va_list ap ;
  List *l ;
  char *v ;
  List *tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 112
  __builtin_va_start(ap, name);
#line 113
  l = (List *)((void *)0);
  }
  {
#line 113
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 113
    tmp___0 = __builtin_va_arg(ap, char *);
#line 113
    v = tmp___0;
    }
#line 113
    if (! ((unsigned long )v != (unsigned long )((void *)0))) {
#line 113
      goto while_break;
    }
    {
#line 114
    tmp = word(v, (char *)((void *)0));
#line 114
    l = append(l, tmp);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 115
  varassign(name, l, (bool )0);
#line 116
  set_exportable(name, (bool )0);
  }
#line 117
  if ((int )*name == (int )*"path") {
    {
#line 117
    tmp___1 = strcmp((char const   *)name, "path");
    }
#line 117
    if (tmp___1 == 0) {
      {
#line 118
      alias(name, l, (bool )0);
      }
    }
  }
  {
#line 119
  __builtin_va_end(ap);
  }
#line 120
  return;
}
}
#line 124 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/main.c"
static void checkfd(int fd , enum redirtype r ) 
{ 
  int new ;
  int tmp ;

  {
  {
#line 125
  tmp = rc_open("/dev/null", r);
#line 125
  new = tmp;
  }
#line 126
  if (new != fd) {
#line 126
    if (new != -1) {
      {
#line 127
      close(new);
      }
    }
  }
#line 128
  return;
}
}
#line 264 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/rc.h"
extern int heredoc(int end ) ;
#line 265
extern int qdoc(Node *name , Node *n ) ;
#line 342 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/rc.h"
Node *parsetree  ;
#line 15 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/parse.c"
static int yygrowstack(void) ;
#line 9 "parse.y"
static Node *star  ;
#line 9 "parse.y"
static Node *nolist  ;
#line 56 "y.tab.c"
short const   yylhs[86]  = 
#line 56 "y.tab.c"
  {      (short const   )-1,      (short const   )0,      (short const   )0,      (short const   )22, 
        (short const   )22,      (short const   )8,      (short const   )8,      (short const   )13, 
        (short const   )13,      (short const   )3,      (short const   )3,      (short const   )9, 
        (short const   )9,      (short const   )4,      (short const   )15,      (short const   )2, 
        (short const   )11,      (short const   )11,      (short const   )16,      (short const   )16, 
        (short const   )16,      (short const   )5,      (short const   )5,      (short const   )6, 
        (short const   )6,      (short const   )6,      (short const   )19,      (short const   )19, 
        (short const   )7,      (short const   )7,      (short const   )7,      (short const   )7, 
        (short const   )7,      (short const   )7,      (short const   )7,      (short const   )7, 
        (short const   )7,      (short const   )7,      (short const   )7,      (short const   )7, 
        (short const   )7,      (short const   )7,      (short const   )7,      (short const   )7, 
        (short const   )7,      (short const   )7,      (short const   )24,      (short const   )24, 
        (short const   )18,      (short const   )18,      (short const   )18,      (short const   )12, 
        (short const   )12,      (short const   )17,      (short const   )17,      (short const   )20, 
        (short const   )20,      (short const   )10,      (short const   )10,      (short const   )10, 
        (short const   )10,      (short const   )10,      (short const   )10,      (short const   )10, 
        (short const   )10,      (short const   )10,      (short const   )10,      (short const   )10, 
        (short const   )1,      (short const   )1,      (short const   )1,      (short const   )1, 
        (short const   )1,      (short const   )1,      (short const   )1,      (short const   )1, 
        (short const   )1,      (short const   )1,      (short const   )1,      (short const   )21, 
        (short const   )21,      (short const   )14,      (short const   )14,      (short const   )14, 
        (short const   )23,      (short const   )23};
#line 67 "y.tab.c"
short const   yylen[86]  = 
#line 67
  {      (short const   )2,      (short const   )2,      (short const   )2,      (short const   )1, 
        (short const   )1,      (short const   )2,      (short const   )2,      (short const   )1, 
        (short const   )2,      (short const   )1,      (short const   )2,      (short const   )1, 
        (short const   )2,      (short const   )3,      (short const   )3,      (short const   )3, 
        (short const   )0,      (short const   )2,      (short const   )1,      (short const   )2, 
        (short const   )2,      (short const   )3,      (short const   )3,      (short const   )1, 
        (short const   )2,      (short const   )2,      (short const   )1,      (short const   )4, 
        (short const   )0,      (short const   )1,      (short const   )2,      (short const   )4, 
        (short const   )8,      (short const   )6,      (short const   )4,      (short const   )8, 
        (short const   )4,      (short const   )4,      (short const   )4,      (short const   )4, 
        (short const   )2,      (short const   )2,      (short const   )3,      (short const   )3, 
        (short const   )3,      (short const   )2,      (short const   )0,      (short const   )1, 
        (short const   )1,      (short const   )2,      (short const   )2,      (short const   )1, 
        (short const   )3,      (short const   )1,      (short const   )1,      (short const   )1, 
        (short const   )3,      (short const   )2,      (short const   )5,      (short const   )2, 
        (short const   )2,      (short const   )2,      (short const   )2,      (short const   )3, 
        (short const   )3,      (short const   )3,      (short const   )2,      (short const   )1, 
        (short const   )1,      (short const   )1,      (short const   )1,      (short const   )1, 
        (short const   )1,      (short const   )1,      (short const   )1,      (short const   )1, 
        (short const   )1,      (short const   )1,      (short const   )1,      (short const   )0, 
        (short const   )2,      (short const   )0,      (short const   )2,      (short const   )2, 
        (short const   )0,      (short const   )2};
#line 78 "y.tab.c"
short const   yydefred[153]  = 
#line 78
  {      (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )18,      (short const   )0,      (short const   )79, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )67,      (short const   )0,      (short const   )0,      (short const   )81, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )51,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )3, 
        (short const   )4,      (short const   )2,      (short const   )77,      (short const   )75, 
        (short const   )74,      (short const   )73,      (short const   )68,      (short const   )71, 
        (short const   )69,      (short const   )0,      (short const   )78,      (short const   )72, 
        (short const   )76,      (short const   )70,      (short const   )54,      (short const   )53, 
        (short const   )55,      (short const   )0,      (short const   )47,      (short const   )0, 
        (short const   )59,      (short const   )60,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )84,      (short const   )66,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )84,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )11,      (short const   )0,      (short const   )0,      (short const   )62, 
        (short const   )61,      (short const   )0,      (short const   )0,      (short const   )30, 
        (short const   )0,      (short const   )84,      (short const   )84,      (short const   )84, 
        (short const   )5,      (short const   )6,      (short const   )8,      (short const   )0, 
        (short const   )0,      (short const   )1,      (short const   )0,      (short const   )50, 
        (short const   )0,      (short const   )0,      (short const   )63,      (short const   )64, 
        (short const   )0,      (short const   )44,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )79,      (short const   )13, 
        (short const   )12,      (short const   )10,      (short const   )65,      (short const   )82, 
        (short const   )0,      (short const   )17,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )52,      (short const   )56, 
        (short const   )79,      (short const   )84,      (short const   )14,      (short const   )85, 
        (short const   )0,      (short const   )0,      (short const   )31,      (short const   )84, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )39,      (short const   )0,      (short const   )0, 
        (short const   )84,      (short const   )0,      (short const   )58,      (short const   )84, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )79,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )24,      (short const   )35,      (short const   )25,      (short const   )22, 
        (short const   )21};
#line 96 "y.tab.c"
short const   yydgoto[25]  = 
#line 96
  {      (short const   )21,      (short const   )46,      (short const   )22,      (short const   )66, 
        (short const   )23,      (short const   )142,      (short const   )143,      (short const   )67, 
        (short const   )68,      (short const   )69,      (short const   )47,      (short const   )75, 
        (short const   )27,      (short const   )28,      (short const   )70,      (short const   )57, 
        (short const   )29,      (short const   )48,      (short const   )30,      (short const   )122, 
        (short const   )94,      (short const   )54,      (short const   )33,      (short const   )97, 
        (short const   )51};
#line 101 "y.tab.c"
short const   yysindex[153]  = 
#line 101
  {      (short const   )874,      (short const   )24,      (short const   )1001,      (short const   )-82, 
        (short const   )1001,      (short const   )0,      (short const   )1001,      (short const   )0, 
        (short const   )-27,      (short const   )-26,      (short const   )900,      (short const   )1001, 
        (short const   )-82,      (short const   )-20,      (short const   )-82,      (short const   )-26, 
        (short const   )0,      (short const   )1001,      (short const   )1134,      (short const   )0, 
        (short const   )900,      (short const   )0,      (short const   )1134,      (short const   )-203, 
        (short const   )-30,      (short const   )1134,      (short const   )0,      (short const   )-55, 
        (short const   )24,      (short const   )1134,      (short const   )826,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )-66,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )849,      (short const   )0,      (short const   )1134, 
        (short const   )0,      (short const   )0,      (short const   )900,      (short const   )1001, 
        (short const   )1134,      (short const   )0,      (short const   )0,      (short const   )-52, 
        (short const   )-52,      (short const   )1134,      (short const   )1001,      (short const   )1001, 
        (short const   )0,      (short const   )-212,      (short const   )-58,      (short const   )154, 
        (short const   )0,      (short const   )1134,      (short const   )426,      (short const   )0, 
        (short const   )0,      (short const   )-196,      (short const   )1001,      (short const   )0, 
        (short const   )-203,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )1001, 
        (short const   )1001,      (short const   )0,      (short const   )-196,      (short const   )0, 
        (short const   )-52,      (short const   )1001,      (short const   )0,      (short const   )0, 
        (short const   )-196,      (short const   )0,      (short const   )-52,      (short const   )-38, 
        (short const   )36,      (short const   )502,      (short const   )-196,      (short const   )-36, 
        (short const   )-52,      (short const   )502,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )-52,      (short const   )0,      (short const   )502,      (short const   )502, 
        (short const   )502,      (short const   )-52,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )-97,      (short const   )-234,      (short const   )0,      (short const   )0, 
        (short const   )1001,      (short const   )-234,      (short const   )922,      (short const   )-196, 
        (short const   )-196,      (short const   )0,      (short const   )944,      (short const   )502, 
        (short const   )0,      (short const   )-9,      (short const   )0,      (short const   )0, 
        (short const   )-234,      (short const   )502,      (short const   )967,      (short const   )502, 
        (short const   )-234,      (short const   )0,      (short const   )967,      (short const   )-45, 
        (short const   )154,      (short const   )967,      (short const   )-234,      (short const   )448, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0};
#line 119 "y.tab.c"
short const   yyrindex[153]  = 
#line 119
  {      (short const   )134,      (short const   )0,      (short const   )0,      (short const   )356, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )356,      (short const   )0,      (short const   )1024,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )571,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )487,      (short const   )529, 
        (short const   )54,      (short const   )134,      (short const   )0,      (short const   )62, 
        (short const   )0,      (short const   )487,      (short const   )548,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )487, 
        (short const   )0,      (short const   )0,      (short const   )712,      (short const   )0, 
        (short const   )142,      (short const   )0,      (short const   )0,      (short const   )14, 
        (short const   )38,      (short const   )487,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )-10,      (short const   )0,      (short const   )-32, 
        (short const   )0,      (short const   )744,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )749,      (short const   )0,      (short const   )0, 
        (short const   )529,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )763,      (short const   )0, 
        (short const   )86,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )779,      (short const   )0,      (short const   )110,      (short const   )0, 
        (short const   )0,      (short const   )-34,      (short const   )788,      (short const   )0, 
        (short const   )380,      (short const   )-34,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )470,      (short const   )0,      (short const   )-34,      (short const   )-34, 
        (short const   )-34,      (short const   )404,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )529,      (short const   )6,      (short const   )0,      (short const   )0, 
        (short const   )724,      (short const   )30,      (short const   )0,      (short const   )805, 
        (short const   )813,      (short const   )0,      (short const   )0,      (short const   )-34, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )119,      (short const   )-34,      (short const   )571,      (short const   )-34, 
        (short const   )187,      (short const   )0,      (short const   )571,      (short const   )0, 
        (short const   )-44,      (short const   )571,      (short const   )396,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0};
#line 137 "y.tab.c"
short const   yygindex[25]  = 
#line 137
  {      (short const   )0,      (short const   )0,      (short const   )0,      (short const   )-23, 
        (short const   )12,      (short const   )0,      (short const   )-104,      (short const   )1319, 
        (short const   )2,      (short const   )-127,      (short const   )1307,      (short const   )7, 
        (short const   )0,      (short const   )57,      (short const   )0,      (short const   )70, 
        (short const   )-13,      (short const   )84,      (short const   )0,      (short const   )0, 
        (short const   )420,      (short const   )-81,      (short const   )59,      (short const   )369, 
        (short const   )31};
#line 143 "y.tab.c"
short const   yytable[1465]  = 
#line 143
  {      (short const   )57,      (short const   )119,      (short const   )25,      (short const   )117, 
        (short const   )28,      (short const   )123,      (short const   )83,      (short const   )28, 
        (short const   )81,      (short const   )9,      (short const   )76,      (short const   )145, 
        (short const   )50,      (short const   )55,      (short const   )56,      (short const   )145, 
        (short const   )26,      (short const   )87,      (short const   )145,      (short const   )124, 
        (short const   )62,      (short const   )126,      (short const   )58,      (short const   )77, 
        (short const   )19,      (short const   )28,      (short const   )57,      (short const   )25, 
        (short const   )57,      (short const   )80,      (short const   )57,      (short const   )57, 
        (short const   )71,      (short const   )96,      (short const   )32,      (short const   )130, 
        (short const   )78,      (short const   )79,      (short const   )148,      (short const   )84, 
        (short const   )34,      (short const   )150,      (short const   )89,      (short const   )61, 
        (short const   )26,      (short const   )63,      (short const   )105,      (short const   )26, 
        (short const   )20,      (short const   )57,      (short const   )19,      (short const   )57, 
        (short const   )19,      (short const   )58,      (short const   )19,      (short const   )19, 
        (short const   )89,      (short const   )18,      (short const   )89,      (short const   )5, 
        (short const   )147,      (short const   )90,      (short const   )102,      (short const   )76, 
        (short const   )7,      (short const   )26,      (short const   )93,      (short const   )103, 
        (short const   )34,      (short const   )74,      (short const   )11,      (short const   )34, 
        (short const   )48,      (short const   )19,      (short const   )20,      (short const   )79, 
        (short const   )20,      (short const   )118,      (short const   )20,      (short const   )20, 
        (short const   )149,      (short const   )23,      (short const   )82,      (short const   )109, 
        (short const   )57,      (short const   )64,      (short const   )57,      (short const   )85, 
        (short const   )52,      (short const   )34,      (short const   )53,      (short const   )28, 
        (short const   )0,      (short const   )9,      (short const   )0,      (short const   )0, 
        (short const   )49,      (short const   )20,      (short const   )48,      (short const   )0, 
        (short const   )48,      (short const   )65,      (short const   )48,      (short const   )48, 
        (short const   )72,      (short const   )0,      (short const   )0,      (short const   )76, 
        (short const   )0,      (short const   )120,      (short const   )19,      (short const   )0, 
        (short const   )0,      (short const   )57,      (short const   )138,      (short const   )57, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )80,      (short const   )48,      (short const   )49,      (short const   )0, 
        (short const   )49,      (short const   )0,      (short const   )49,      (short const   )49, 
        (short const   )0,      (short const   )33,      (short const   )0,      (short const   )26, 
        (short const   )0,      (short const   )91,      (short const   )20,      (short const   )0, 
        (short const   )0,      (short const   )19,      (short const   )0,      (short const   )19, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )28,      (short const   )49,      (short const   )80,      (short const   )0, 
        (short const   )80,      (short const   )0,      (short const   )80,      (short const   )80, 
        (short const   )28,      (short const   )0,      (short const   )0,      (short const   )34, 
        (short const   )0,      (short const   )33,      (short const   )48,      (short const   )0, 
        (short const   )33,      (short const   )20,      (short const   )0,      (short const   )20, 
        (short const   )104,      (short const   )5,      (short const   )132,      (short const   )0, 
        (short const   )114,      (short const   )80,      (short const   )0,      (short const   )0, 
        (short const   )28,      (short const   )115,      (short const   )0,      (short const   )74, 
        (short const   )11,      (short const   )0,      (short const   )33,      (short const   )0, 
        (short const   )28,      (short const   )0,      (short const   )49,      (short const   )28, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )48, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )81,      (short const   )28,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )27,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )28,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )80,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )49, 
        (short const   )0,      (short const   )80,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )28, 
        (short const   )0,      (short const   )27,      (short const   )0,      (short const   )77, 
        (short const   )27,      (short const   )0,      (short const   )28,      (short const   )116, 
        (short const   )0,      (short const   )80,      (short const   )0,      (short const   )80, 
        (short const   )28,      (short const   )28,      (short const   )0,      (short const   )0, 
        (short const   )78,      (short const   )79,      (short const   )0,      (short const   )0, 
        (short const   )33,      (short const   )0,      (short const   )27,      (short const   )57, 
        (short const   )57,      (short const   )57,      (short const   )57,      (short const   )57, 
        (short const   )57,      (short const   )57,      (short const   )57,      (short const   )57, 
        (short const   )57,      (short const   )57,      (short const   )57,      (short const   )57, 
        (short const   )57,      (short const   )57,      (short const   )57,      (short const   )57, 
        (short const   )0,      (short const   )57,      (short const   )57,      (short const   )57, 
        (short const   )57,      (short const   )57,      (short const   )26,      (short const   )19, 
        (short const   )19,      (short const   )19,      (short const   )19,      (short const   )19, 
        (short const   )19,      (short const   )19,      (short const   )19,      (short const   )19, 
        (short const   )19,      (short const   )19,      (short const   )19,      (short const   )19, 
        (short const   )19,      (short const   )19,      (short const   )19,      (short const   )19, 
        (short const   )31,      (short const   )19,      (short const   )19,      (short const   )19, 
        (short const   )19,      (short const   )19,      (short const   )34,      (short const   )20, 
        (short const   )20,      (short const   )20,      (short const   )20,      (short const   )20, 
        (short const   )20,      (short const   )20,      (short const   )20,      (short const   )20, 
        (short const   )20,      (short const   )20,      (short const   )20,      (short const   )20, 
        (short const   )20,      (short const   )20,      (short const   )20,      (short const   )20, 
        (short const   )27,      (short const   )20,      (short const   )20,      (short const   )20, 
        (short const   )20,      (short const   )20,      (short const   )7,      (short const   )48, 
        (short const   )48,      (short const   )48,      (short const   )48,      (short const   )48, 
        (short const   )48,      (short const   )48,      (short const   )48,      (short const   )48, 
        (short const   )48,      (short const   )48,      (short const   )48,      (short const   )48, 
        (short const   )48,      (short const   )48,      (short const   )48,      (short const   )48, 
        (short const   )0,      (short const   )48,      (short const   )48,      (short const   )48, 
        (short const   )48,      (short const   )48,      (short const   )0,      (short const   )49, 
        (short const   )49,      (short const   )49,      (short const   )49,      (short const   )49, 
        (short const   )49,      (short const   )49,      (short const   )49,      (short const   )49, 
        (short const   )49,      (short const   )49,      (short const   )49,      (short const   )49, 
        (short const   )49,      (short const   )49,      (short const   )49,      (short const   )49, 
        (short const   )0,      (short const   )49,      (short const   )49,      (short const   )49, 
        (short const   )49,      (short const   )49,      (short const   )46,      (short const   )80, 
        (short const   )80,      (short const   )80,      (short const   )80,      (short const   )80, 
        (short const   )0,      (short const   )80,      (short const   )80,      (short const   )80, 
        (short const   )80,      (short const   )80,      (short const   )80,      (short const   )80, 
        (short const   )80,      (short const   )80,      (short const   )80,      (short const   )33, 
        (short const   )0,      (short const   )80,      (short const   )80,      (short const   )80, 
        (short const   )80,      (short const   )80,      (short const   )79,      (short const   )28, 
        (short const   )46,      (short const   )0,      (short const   )46,      (short const   )0, 
        (short const   )46,      (short const   )46,      (short const   )28,      (short const   )28, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )28,      (short const   )28,      (short const   )32,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )77, 
        (short const   )28,      (short const   )28,      (short const   )15,      (short const   )46, 
        (short const   )79,      (short const   )0,      (short const   )79,      (short const   )0, 
        (short const   )79,      (short const   )79,      (short const   )49,      (short const   )0, 
        (short const   )78,      (short const   )79,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )59,      (short const   )60, 
        (short const   )0,      (short const   )101,      (short const   )32,      (short const   )0, 
        (short const   )107,      (short const   )32,      (short const   )0,      (short const   )79, 
        (short const   )15,      (short const   )0,      (short const   )15,      (short const   )0, 
        (short const   )15,      (short const   )15,      (short const   )110,      (short const   )111, 
        (short const   )112,      (short const   )0,      (short const   )88,      (short const   )27, 
        (short const   )46,      (short const   )0,      (short const   )0,      (short const   )32, 
        (short const   )0,      (short const   )0,      (short const   )151,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )17,      (short const   )15, 
        (short const   )0,      (short const   )0,      (short const   )19,      (short const   )106, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )95, 
        (short const   )79,      (short const   )0,      (short const   )0,      (short const   )46, 
        (short const   )83,      (short const   )46,      (short const   )99,      (short const   )100, 
        (short const   )17,      (short const   )0,      (short const   )131,      (short const   )0, 
        (short const   )19,      (short const   )0,      (short const   )108,      (short const   )0, 
        (short const   )133,      (short const   )0,      (short const   )59,      (short const   )0, 
        (short const   )0,      (short const   )28,      (short const   )0,      (short const   )0, 
        (short const   )15,      (short const   )137,      (short const   )0,      (short const   )113, 
        (short const   )139,      (short const   )79,      (short const   )83,      (short const   )152, 
        (short const   )0,      (short const   )0,      (short const   )83,      (short const   )83, 
        (short const   )119,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )32,      (short const   )20,      (short const   )0, 
        (short const   )0,      (short const   )28,      (short const   )0,      (short const   )15, 
        (short const   )28,      (short const   )15,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )17,      (short const   )16, 
        (short const   )0,      (short const   )0,      (short const   )19,      (short const   )0, 
        (short const   )20,      (short const   )0,      (short const   )28,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )29,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )83,      (short const   )16, 
        (short const   )0,      (short const   )0,      (short const   )16,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )28,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )29,      (short const   )0, 
        (short const   )16,      (short const   )29,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )20,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )29, 
        (short const   )0,      (short const   )28,      (short const   )0,      (short const   )0, 
        (short const   )28,      (short const   )46,      (short const   )46,      (short const   )46, 
        (short const   )0,      (short const   )46,      (short const   )46,      (short const   )0, 
        (short const   )46,      (short const   )46,      (short const   )46,      (short const   )46, 
        (short const   )46,      (short const   )18,      (short const   )46,      (short const   )46, 
        (short const   )46,      (short const   )46,      (short const   )28,      (short const   )46, 
        (short const   )46,      (short const   )46,      (short const   )46,      (short const   )46, 
        (short const   )0,      (short const   )79,      (short const   )79,      (short const   )79, 
        (short const   )79,      (short const   )79,      (short const   )0,      (short const   )79, 
        (short const   )79,      (short const   )79,      (short const   )79,      (short const   )79, 
        (short const   )79,      (short const   )79,      (short const   )79,      (short const   )79, 
        (short const   )79,      (short const   )0,      (short const   )16,      (short const   )79, 
        (short const   )79,      (short const   )79,      (short const   )79,      (short const   )79, 
        (short const   )32,      (short const   )15,      (short const   )15,      (short const   )15, 
        (short const   )0,      (short const   )15,      (short const   )15,      (short const   )0, 
        (short const   )15,      (short const   )15,      (short const   )15,      (short const   )15, 
        (short const   )15,      (short const   )29,      (short const   )15,      (short const   )15, 
        (short const   )15,      (short const   )15,      (short const   )0,      (short const   )15, 
        (short const   )15,      (short const   )15,      (short const   )15,      (short const   )15, 
        (short const   )2,      (short const   )34,      (short const   )35,      (short const   )4, 
        (short const   )0,      (short const   )36,      (short const   )0,      (short const   )6, 
        (short const   )37,      (short const   )38,      (short const   )39,      (short const   )40, 
        (short const   )28,      (short const   )0,      (short const   )41,      (short const   )0, 
        (short const   )0,      (short const   )42,      (short const   )43,      (short const   )44, 
        (short const   )45,      (short const   )16,      (short const   )2,      (short const   )34, 
        (short const   )35,      (short const   )4,      (short const   )0,      (short const   )36, 
        (short const   )0,      (short const   )6,      (short const   )37,      (short const   )38, 
        (short const   )39,      (short const   )40,      (short const   )0,      (short const   )0, 
        (short const   )41,      (short const   )0,      (short const   )45,      (short const   )42, 
        (short const   )43,      (short const   )44,      (short const   )45,      (short const   )16, 
        (short const   )83,      (short const   )83,      (short const   )83,      (short const   )83, 
        (short const   )0,      (short const   )83,      (short const   )36,      (short const   )83, 
        (short const   )83,      (short const   )83,      (short const   )83,      (short const   )83, 
        (short const   )0,      (short const   )0,      (short const   )83,      (short const   )0, 
        (short const   )28,      (short const   )83,      (short const   )83,      (short const   )83, 
        (short const   )83,      (short const   )83,      (short const   )45,      (short const   )28, 
        (short const   )0,      (short const   )45,      (short const   )28,      (short const   )0, 
        (short const   )0,      (short const   )28,      (short const   )28,      (short const   )41, 
        (short const   )2,      (short const   )3,      (short const   )36,      (short const   )4, 
        (short const   )5,      (short const   )36,      (short const   )0,      (short const   )6, 
        (short const   )7,      (short const   )8,      (short const   )9,      (short const   )45, 
        (short const   )0,      (short const   )40,      (short const   )10,      (short const   )11, 
        (short const   )0,      (short const   )12,      (short const   )13,      (short const   )14, 
        (short const   )15,      (short const   )16,      (short const   )28,      (short const   )36, 
        (short const   )0,      (short const   )28,      (short const   )16,      (short const   )41, 
        (short const   )0,      (short const   )42,      (short const   )41,      (short const   )0, 
        (short const   )0,      (short const   )16,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )43,      (short const   )16, 
        (short const   )16,      (short const   )40,      (short const   )0,      (short const   )28, 
        (short const   )40,      (short const   )29,      (short const   )0,      (short const   )0, 
        (short const   )41,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )29,      (short const   )0,      (short const   )0,      (short const   )37, 
        (short const   )0,      (short const   )42,      (short const   )29,      (short const   )29, 
        (short const   )42,      (short const   )0,      (short const   )40,      (short const   )38, 
        (short const   )0,      (short const   )0,      (short const   )43,      (short const   )0, 
        (short const   )28,      (short const   )43,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )45,      (short const   )42,      (short const   )0, 
        (short const   )0,      (short const   )28,      (short const   )28,      (short const   )37, 
        (short const   )0,      (short const   )0,      (short const   )37,      (short const   )43, 
        (short const   )0,      (short const   )36,      (short const   )0,      (short const   )38, 
        (short const   )0,      (short const   )0,      (short const   )38,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )17,      (short const   )0, 
        (short const   )37,      (short const   )0,      (short const   )19,      (short const   )0, 
        (short const   )0,      (short const   )28,      (short const   )0,      (short const   )0, 
        (short const   )38,      (short const   )0,      (short const   )41,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )17,      (short const   )0,      (short const   )0, 
        (short const   )40,      (short const   )19,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )42,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )17,      (short const   )0, 
        (short const   )0,      (short const   )43,      (short const   )19,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )20,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )37,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )17,      (short const   )0,      (short const   )38,      (short const   )0, 
        (short const   )19,      (short const   )0,      (short const   )0,      (short const   )89, 
        (short const   )0,      (short const   )20,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )17,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )19,      (short const   )134, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )45,      (short const   )20,      (short const   )0, 
        (short const   )18,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )45,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )17,      (short const   )36,      (short const   )45,      (short const   )45, 
        (short const   )19,      (short const   )135,      (short const   )0,      (short const   )0, 
        (short const   )36,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )36,      (short const   )36, 
        (short const   )20,      (short const   )18,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )28,      (short const   )0,      (short const   )17, 
        (short const   )0,      (short const   )0,      (short const   )41,      (short const   )19, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )41,      (short const   )28,      (short const   )28, 
        (short const   )0,      (short const   )0,      (short const   )20,      (short const   )41, 
        (short const   )40,      (short const   )0,      (short const   )0,      (short const   )18, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )40, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )40,      (short const   )0,      (short const   )0, 
        (short const   )42,      (short const   )17,      (short const   )0,      (short const   )0, 
        (short const   )20,      (short const   )19,      (short const   )0,      (short const   )42, 
        (short const   )0,      (short const   )43,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )42,      (short const   )0,      (short const   )0, 
        (short const   )43,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )43,      (short const   )0, 
        (short const   )46,      (short const   )0,      (short const   )37,      (short const   )20, 
        (short const   )46,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )37,      (short const   )38,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )37, 
        (short const   )0,      (short const   )38,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )38, 
        (short const   )2,      (short const   )34,      (short const   )35,      (short const   )4, 
        (short const   )5,      (short const   )36,      (short const   )18,      (short const   )6, 
        (short const   )37,      (short const   )38,      (short const   )39,      (short const   )40, 
        (short const   )0,      (short const   )20,      (short const   )10,      (short const   )11, 
        (short const   )0,      (short const   )42,      (short const   )43,      (short const   )44, 
        (short const   )45,      (short const   )16,      (short const   )0,      (short const   )2, 
        (short const   )34,      (short const   )35,      (short const   )4,      (short const   )0, 
        (short const   )36,      (short const   )0,      (short const   )6,      (short const   )37, 
        (short const   )38,      (short const   )39,      (short const   )40,      (short const   )0, 
        (short const   )46,      (short const   )41,      (short const   )0,      (short const   )0, 
        (short const   )42,      (short const   )43,      (short const   )44,      (short const   )45, 
        (short const   )16,      (short const   )0,      (short const   )1,      (short const   )0, 
        (short const   )2,      (short const   )3,      (short const   )0,      (short const   )4, 
        (short const   )5,      (short const   )0,      (short const   )0,      (short const   )6, 
        (short const   )7,      (short const   )8,      (short const   )9,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )10,      (short const   )11, 
        (short const   )0,      (short const   )12,      (short const   )13,      (short const   )14, 
        (short const   )15,      (short const   )16,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )2,      (short const   )34, 
        (short const   )35,      (short const   )4,      (short const   )0,      (short const   )36, 
        (short const   )0,      (short const   )6,      (short const   )37,      (short const   )38, 
        (short const   )39,      (short const   )40,      (short const   )17,      (short const   )0, 
        (short const   )41,      (short const   )0,      (short const   )19,      (short const   )42, 
        (short const   )43,      (short const   )44,      (short const   )45,      (short const   )16, 
        (short const   )2,      (short const   )34,      (short const   )35,      (short const   )4, 
        (short const   )0,      (short const   )36,      (short const   )0,      (short const   )6, 
        (short const   )37,      (short const   )38,      (short const   )39,      (short const   )40, 
        (short const   )0,      (short const   )0,      (short const   )41,      (short const   )0, 
        (short const   )0,      (short const   )42,      (short const   )43,      (short const   )44, 
        (short const   )45,      (short const   )16,      (short const   )2,      (short const   )34, 
        (short const   )35,      (short const   )4,      (short const   )0,      (short const   )36, 
        (short const   )0,      (short const   )6,      (short const   )37,      (short const   )38, 
        (short const   )39,      (short const   )40,      (short const   )0,      (short const   )0, 
        (short const   )41,      (short const   )0,      (short const   )0,      (short const   )42, 
        (short const   )43,      (short const   )44,      (short const   )45,      (short const   )16, 
        (short const   )0,      (short const   )2,      (short const   )3,      (short const   )141, 
        (short const   )4,      (short const   )5,      (short const   )20,      (short const   )0, 
        (short const   )6,      (short const   )7,      (short const   )8,      (short const   )9, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )10, 
        (short const   )11,      (short const   )0,      (short const   )12,      (short const   )13, 
        (short const   )14,      (short const   )15,      (short const   )16,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )18,      (short const   )0,      (short const   )2, 
        (short const   )34,      (short const   )35,      (short const   )4,      (short const   )0, 
        (short const   )36,      (short const   )0,      (short const   )6,      (short const   )37, 
        (short const   )38,      (short const   )39,      (short const   )40,      (short const   )0, 
        (short const   )0,      (short const   )41,      (short const   )0,      (short const   )0, 
        (short const   )42,      (short const   )43,      (short const   )44,      (short const   )45, 
        (short const   )16,      (short const   )0,      (short const   )46,      (short const   )46, 
        (short const   )46,      (short const   )46,      (short const   )0,      (short const   )46, 
        (short const   )0,      (short const   )46,      (short const   )46,      (short const   )46, 
        (short const   )46,      (short const   )46,      (short const   )0,      (short const   )0, 
        (short const   )46,      (short const   )0,      (short const   )0,      (short const   )46, 
        (short const   )46,      (short const   )46,      (short const   )46,      (short const   )46, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )26, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )24, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )26,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )26,      (short const   )0,      (short const   )0, 
        (short const   )26,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )26,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )73,      (short const   )0,      (short const   )0, 
        (short const   )24,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )86,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )26,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )26, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )26,      (short const   )0,      (short const   )92,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )26,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )98,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )2,      (short const   )3,      (short const   )0,      (short const   )4, 
        (short const   )5,      (short const   )0,      (short const   )0,      (short const   )6, 
        (short const   )7,      (short const   )8,      (short const   )9,      (short const   )0, 
        (short const   )26,      (short const   )0,      (short const   )10,      (short const   )11, 
        (short const   )26,      (short const   )12,      (short const   )13,      (short const   )14, 
        (short const   )15,      (short const   )16,      (short const   )0,      (short const   )0, 
        (short const   )121,      (short const   )26,      (short const   )26,      (short const   )26, 
        (short const   )125,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )127,      (short const   )128,      (short const   )129, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )26,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )26,      (short const   )26,      (short const   )26,      (short const   )0, 
        (short const   )0,      (short const   )26,      (short const   )136,      (short const   )0, 
        (short const   )26,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )140,      (short const   )144,      (short const   )146,      (short const   )0, 
        (short const   )0,      (short const   )144,      (short const   )0,      (short const   )0, 
        (short const   )144};
#line 292 "y.tab.c"
short const   yycheck[1465]  = 
#line 292
  {      (short const   )10,      (short const   )10,      (short const   )0,      (short const   )41, 
        (short const   )38,      (short const   )41,      (short const   )61,      (short const   )41, 
        (short const   )38,      (short const   )41,      (short const   )23,      (short const   )138, 
        (short const   )94,      (short const   )40,      (short const   )40,      (short const   )142, 
        (short const   )10,      (short const   )30,      (short const   )145,      (short const   )100, 
        (short const   )40,      (short const   )102,      (short const   )10,      (short const   )257, 
        (short const   )10,      (short const   )59,      (short const   )36,      (short const   )25, 
        (short const   )38,      (short const   )59,      (short const   )40,      (short const   )41, 
        (short const   )20,      (short const   )56,      (short const   )10,      (short const   )116, 
        (short const   )270,      (short const   )271,      (short const   )142,      (short const   )94, 
        (short const   )10,      (short const   )145,      (short const   )94,      (short const   )12, 
        (short const   )38,      (short const   )14,      (short const   )69,      (short const   )41, 
        (short const   )10,      (short const   )59,      (short const   )36,      (short const   )61, 
        (short const   )38,      (short const   )41,      (short const   )40,      (short const   )41, 
        (short const   )94,      (short const   )123,      (short const   )94,      (short const   )262, 
        (short const   )141,      (short const   )49,      (short const   )274,      (short const   )76, 
        (short const   )10,      (short const   )59,      (short const   )54,      (short const   )125, 
        (short const   )38,      (short const   )272,      (short const   )273,      (short const   )41, 
        (short const   )10,      (short const   )59,      (short const   )36,      (short const   )271, 
        (short const   )38,      (short const   )41,      (short const   )40,      (short const   )41, 
        (short const   )125,      (short const   )125,      (short const   )25,      (short const   )76, 
        (short const   )94,      (short const   )15,      (short const   )96,      (short const   )28, 
        (short const   )4,      (short const   )59,      (short const   )6,      (short const   )125, 
        (short const   )-1,      (short const   )125,      (short const   )-1,      (short const   )-1, 
        (short const   )10,      (short const   )59,      (short const   )36,      (short const   )-1, 
        (short const   )38,      (short const   )17,      (short const   )40,      (short const   )41, 
        (short const   )20,      (short const   )-1,      (short const   )-1,      (short const   )120, 
        (short const   )-1,      (short const   )97,      (short const   )96,      (short const   )-1, 
        (short const   )-1,      (short const   )123,      (short const   )123,      (short const   )125, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )10,      (short const   )59,      (short const   )36,      (short const   )-1, 
        (short const   )38,      (short const   )-1,      (short const   )40,      (short const   )41, 
        (short const   )-1,      (short const   )10,      (short const   )-1,      (short const   )125, 
        (short const   )-1,      (short const   )49,      (short const   )96,      (short const   )-1, 
        (short const   )-1,      (short const   )123,      (short const   )-1,      (short const   )125, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )10,      (short const   )59,      (short const   )36,      (short const   )-1, 
        (short const   )38,      (short const   )-1,      (short const   )40,      (short const   )41, 
        (short const   )10,      (short const   )-1,      (short const   )-1,      (short const   )125, 
        (short const   )-1,      (short const   )38,      (short const   )96,      (short const   )-1, 
        (short const   )41,      (short const   )123,      (short const   )-1,      (short const   )125, 
        (short const   )10,      (short const   )262,      (short const   )263,      (short const   )-1, 
        (short const   )84,      (short const   )59,      (short const   )-1,      (short const   )-1, 
        (short const   )38,      (short const   )89,      (short const   )-1,      (short const   )272, 
        (short const   )273,      (short const   )-1,      (short const   )59,      (short const   )-1, 
        (short const   )38,      (short const   )-1,      (short const   )96,      (short const   )41, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )125, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )38,      (short const   )59,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )10,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )59,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )96,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )125, 
        (short const   )-1,      (short const   )59,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )257, 
        (short const   )-1,      (short const   )38,      (short const   )-1,      (short const   )257, 
        (short const   )41,      (short const   )-1,      (short const   )264,      (short const   )269, 
        (short const   )-1,      (short const   )123,      (short const   )-1,      (short const   )125, 
        (short const   )270,      (short const   )271,      (short const   )-1,      (short const   )-1, 
        (short const   )270,      (short const   )271,      (short const   )-1,      (short const   )-1, 
        (short const   )125,      (short const   )-1,      (short const   )59,      (short const   )257, 
        (short const   )258,      (short const   )259,      (short const   )260,      (short const   )261, 
        (short const   )262,      (short const   )263,      (short const   )264,      (short const   )265, 
        (short const   )266,      (short const   )267,      (short const   )268,      (short const   )269, 
        (short const   )270,      (short const   )271,      (short const   )272,      (short const   )273, 
        (short const   )-1,      (short const   )275,      (short const   )276,      (short const   )277, 
        (short const   )278,      (short const   )279,      (short const   )264,      (short const   )257, 
        (short const   )258,      (short const   )259,      (short const   )260,      (short const   )261, 
        (short const   )262,      (short const   )263,      (short const   )264,      (short const   )265, 
        (short const   )266,      (short const   )267,      (short const   )268,      (short const   )269, 
        (short const   )270,      (short const   )271,      (short const   )272,      (short const   )273, 
        (short const   )264,      (short const   )275,      (short const   )276,      (short const   )277, 
        (short const   )278,      (short const   )279,      (short const   )264,      (short const   )257, 
        (short const   )258,      (short const   )259,      (short const   )260,      (short const   )261, 
        (short const   )262,      (short const   )263,      (short const   )264,      (short const   )265, 
        (short const   )266,      (short const   )267,      (short const   )268,      (short const   )269, 
        (short const   )270,      (short const   )271,      (short const   )272,      (short const   )273, 
        (short const   )125,      (short const   )275,      (short const   )276,      (short const   )277, 
        (short const   )278,      (short const   )279,      (short const   )264,      (short const   )257, 
        (short const   )258,      (short const   )259,      (short const   )260,      (short const   )261, 
        (short const   )262,      (short const   )263,      (short const   )264,      (short const   )265, 
        (short const   )266,      (short const   )267,      (short const   )268,      (short const   )269, 
        (short const   )270,      (short const   )271,      (short const   )272,      (short const   )273, 
        (short const   )-1,      (short const   )275,      (short const   )276,      (short const   )277, 
        (short const   )278,      (short const   )279,      (short const   )-1,      (short const   )257, 
        (short const   )258,      (short const   )259,      (short const   )260,      (short const   )261, 
        (short const   )262,      (short const   )263,      (short const   )264,      (short const   )265, 
        (short const   )266,      (short const   )267,      (short const   )268,      (short const   )269, 
        (short const   )270,      (short const   )271,      (short const   )272,      (short const   )273, 
        (short const   )-1,      (short const   )275,      (short const   )276,      (short const   )277, 
        (short const   )278,      (short const   )279,      (short const   )10,      (short const   )257, 
        (short const   )258,      (short const   )259,      (short const   )260,      (short const   )261, 
        (short const   )-1,      (short const   )263,      (short const   )264,      (short const   )265, 
        (short const   )266,      (short const   )267,      (short const   )268,      (short const   )269, 
        (short const   )270,      (short const   )271,      (short const   )272,      (short const   )264, 
        (short const   )-1,      (short const   )275,      (short const   )276,      (short const   )277, 
        (short const   )278,      (short const   )279,      (short const   )10,      (short const   )257, 
        (short const   )36,      (short const   )-1,      (short const   )38,      (short const   )-1, 
        (short const   )40,      (short const   )41,      (short const   )264,      (short const   )257, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )270,      (short const   )271,      (short const   )10,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )257, 
        (short const   )270,      (short const   )271,      (short const   )10,      (short const   )59, 
        (short const   )36,      (short const   )-1,      (short const   )38,      (short const   )-1, 
        (short const   )40,      (short const   )41,      (short const   )2,      (short const   )-1, 
        (short const   )270,      (short const   )271,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )10,      (short const   )11, 
        (short const   )-1,      (short const   )64,      (short const   )38,      (short const   )-1, 
        (short const   )10,      (short const   )41,      (short const   )-1,      (short const   )59, 
        (short const   )36,      (short const   )-1,      (short const   )38,      (short const   )-1, 
        (short const   )40,      (short const   )41,      (short const   )77,      (short const   )78, 
        (short const   )79,      (short const   )-1,      (short const   )30,      (short const   )264, 
        (short const   )96,      (short const   )-1,      (short const   )-1,      (short const   )59, 
        (short const   )-1,      (short const   )-1,      (short const   )10,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )36,      (short const   )59, 
        (short const   )-1,      (short const   )-1,      (short const   )40,      (short const   )41, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )55, 
        (short const   )96,      (short const   )-1,      (short const   )-1,      (short const   )123, 
        (short const   )10,      (short const   )125,      (short const   )62,      (short const   )63, 
        (short const   )36,      (short const   )-1,      (short const   )117,      (short const   )-1, 
        (short const   )40,      (short const   )-1,      (short const   )70,      (short const   )-1, 
        (short const   )123,      (short const   )-1,      (short const   )74,      (short const   )-1, 
        (short const   )-1,      (short const   )10,      (short const   )-1,      (short const   )-1, 
        (short const   )96,      (short const   )132,      (short const   )-1,      (short const   )83, 
        (short const   )135,      (short const   )125,      (short const   )36,      (short const   )59, 
        (short const   )-1,      (short const   )-1,      (short const   )40,      (short const   )41, 
        (short const   )10,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )125,      (short const   )96,      (short const   )-1, 
        (short const   )-1,      (short const   )38,      (short const   )-1,      (short const   )123, 
        (short const   )41,      (short const   )125,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )36,      (short const   )10, 
        (short const   )-1,      (short const   )-1,      (short const   )40,      (short const   )-1, 
        (short const   )96,      (short const   )-1,      (short const   )59,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )10,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )96,      (short const   )38, 
        (short const   )-1,      (short const   )-1,      (short const   )41,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )10,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )38,      (short const   )-1, 
        (short const   )59,      (short const   )41,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )96,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )59, 
        (short const   )-1,      (short const   )38,      (short const   )-1,      (short const   )-1, 
        (short const   )125,      (short const   )257,      (short const   )258,      (short const   )259, 
        (short const   )-1,      (short const   )261,      (short const   )262,      (short const   )-1, 
        (short const   )264,      (short const   )265,      (short const   )266,      (short const   )267, 
        (short const   )268,      (short const   )123,      (short const   )270,      (short const   )271, 
        (short const   )272,      (short const   )273,      (short const   )59,      (short const   )275, 
        (short const   )276,      (short const   )277,      (short const   )278,      (short const   )279, 
        (short const   )-1,      (short const   )257,      (short const   )258,      (short const   )259, 
        (short const   )260,      (short const   )261,      (short const   )-1,      (short const   )263, 
        (short const   )264,      (short const   )265,      (short const   )266,      (short const   )267, 
        (short const   )268,      (short const   )269,      (short const   )270,      (short const   )271, 
        (short const   )272,      (short const   )-1,      (short const   )125,      (short const   )275, 
        (short const   )276,      (short const   )277,      (short const   )278,      (short const   )279, 
        (short const   )264,      (short const   )257,      (short const   )258,      (short const   )259, 
        (short const   )-1,      (short const   )261,      (short const   )262,      (short const   )-1, 
        (short const   )264,      (short const   )265,      (short const   )266,      (short const   )267, 
        (short const   )268,      (short const   )125,      (short const   )270,      (short const   )271, 
        (short const   )272,      (short const   )273,      (short const   )-1,      (short const   )275, 
        (short const   )276,      (short const   )277,      (short const   )278,      (short const   )279, 
        (short const   )258,      (short const   )259,      (short const   )260,      (short const   )261, 
        (short const   )-1,      (short const   )263,      (short const   )-1,      (short const   )265, 
        (short const   )266,      (short const   )267,      (short const   )268,      (short const   )269, 
        (short const   )125,      (short const   )-1,      (short const   )272,      (short const   )-1, 
        (short const   )-1,      (short const   )275,      (short const   )276,      (short const   )277, 
        (short const   )278,      (short const   )279,      (short const   )258,      (short const   )259, 
        (short const   )260,      (short const   )261,      (short const   )-1,      (short const   )263, 
        (short const   )-1,      (short const   )265,      (short const   )266,      (short const   )267, 
        (short const   )268,      (short const   )269,      (short const   )-1,      (short const   )-1, 
        (short const   )272,      (short const   )-1,      (short const   )10,      (short const   )275, 
        (short const   )276,      (short const   )277,      (short const   )278,      (short const   )279, 
        (short const   )258,      (short const   )259,      (short const   )260,      (short const   )261, 
        (short const   )-1,      (short const   )263,      (short const   )10,      (short const   )265, 
        (short const   )266,      (short const   )267,      (short const   )268,      (short const   )269, 
        (short const   )-1,      (short const   )-1,      (short const   )272,      (short const   )-1, 
        (short const   )257,      (short const   )275,      (short const   )276,      (short const   )277, 
        (short const   )278,      (short const   )279,      (short const   )38,      (short const   )264, 
        (short const   )-1,      (short const   )41,      (short const   )10,      (short const   )-1, 
        (short const   )-1,      (short const   )270,      (short const   )271,      (short const   )10, 
        (short const   )258,      (short const   )259,      (short const   )38,      (short const   )261, 
        (short const   )262,      (short const   )41,      (short const   )-1,      (short const   )265, 
        (short const   )266,      (short const   )267,      (short const   )268,      (short const   )59, 
        (short const   )-1,      (short const   )10,      (short const   )272,      (short const   )273, 
        (short const   )-1,      (short const   )275,      (short const   )276,      (short const   )277, 
        (short const   )278,      (short const   )279,      (short const   )38,      (short const   )59, 
        (short const   )-1,      (short const   )41,      (short const   )257,      (short const   )38, 
        (short const   )-1,      (short const   )10,      (short const   )41,      (short const   )-1, 
        (short const   )-1,      (short const   )264,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )10,      (short const   )270, 
        (short const   )271,      (short const   )38,      (short const   )-1,      (short const   )59, 
        (short const   )41,      (short const   )257,      (short const   )-1,      (short const   )-1, 
        (short const   )59,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )264,      (short const   )-1,      (short const   )-1,      (short const   )10, 
        (short const   )-1,      (short const   )38,      (short const   )270,      (short const   )271, 
        (short const   )41,      (short const   )-1,      (short const   )59,      (short const   )10, 
        (short const   )-1,      (short const   )-1,      (short const   )38,      (short const   )-1, 
        (short const   )257,      (short const   )41,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )125,      (short const   )59,      (short const   )-1, 
        (short const   )-1,      (short const   )270,      (short const   )271,      (short const   )38, 
        (short const   )-1,      (short const   )-1,      (short const   )41,      (short const   )59, 
        (short const   )-1,      (short const   )125,      (short const   )-1,      (short const   )38, 
        (short const   )-1,      (short const   )-1,      (short const   )41,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )36,      (short const   )-1, 
        (short const   )59,      (short const   )-1,      (short const   )40,      (short const   )-1, 
        (short const   )-1,      (short const   )125,      (short const   )-1,      (short const   )-1, 
        (short const   )59,      (short const   )-1,      (short const   )125,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )36,      (short const   )-1,      (short const   )-1, 
        (short const   )125,      (short const   )40,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )125,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )36,      (short const   )-1, 
        (short const   )-1,      (short const   )125,      (short const   )40,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )96,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )125,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )36,      (short const   )-1,      (short const   )125,      (short const   )-1, 
        (short const   )40,      (short const   )-1,      (short const   )-1,      (short const   )94, 
        (short const   )-1,      (short const   )96,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )36,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )40,      (short const   )41, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )257,      (short const   )96,      (short const   )-1, 
        (short const   )123,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )264,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )36,      (short const   )257,      (short const   )270,      (short const   )271, 
        (short const   )40,      (short const   )41,      (short const   )-1,      (short const   )-1, 
        (short const   )264,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )270,      (short const   )271, 
        (short const   )96,      (short const   )123,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )257,      (short const   )-1,      (short const   )36, 
        (short const   )-1,      (short const   )-1,      (short const   )257,      (short const   )40, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )264,      (short const   )270,      (short const   )271, 
        (short const   )-1,      (short const   )-1,      (short const   )96,      (short const   )270, 
        (short const   )257,      (short const   )-1,      (short const   )-1,      (short const   )123, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )264, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )270,      (short const   )-1,      (short const   )-1, 
        (short const   )257,      (short const   )36,      (short const   )-1,      (short const   )-1, 
        (short const   )96,      (short const   )40,      (short const   )-1,      (short const   )264, 
        (short const   )-1,      (short const   )257,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )270,      (short const   )-1,      (short const   )-1, 
        (short const   )264,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )270,      (short const   )-1, 
        (short const   )36,      (short const   )-1,      (short const   )257,      (short const   )96, 
        (short const   )40,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )264,      (short const   )257,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )270, 
        (short const   )-1,      (short const   )264,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )270, 
        (short const   )258,      (short const   )259,      (short const   )260,      (short const   )261, 
        (short const   )262,      (short const   )263,      (short const   )123,      (short const   )265, 
        (short const   )266,      (short const   )267,      (short const   )268,      (short const   )269, 
        (short const   )-1,      (short const   )96,      (short const   )272,      (short const   )273, 
        (short const   )-1,      (short const   )275,      (short const   )276,      (short const   )277, 
        (short const   )278,      (short const   )279,      (short const   )-1,      (short const   )258, 
        (short const   )259,      (short const   )260,      (short const   )261,      (short const   )-1, 
        (short const   )263,      (short const   )-1,      (short const   )265,      (short const   )266, 
        (short const   )267,      (short const   )268,      (short const   )269,      (short const   )-1, 
        (short const   )96,      (short const   )272,      (short const   )-1,      (short const   )-1, 
        (short const   )275,      (short const   )276,      (short const   )277,      (short const   )278, 
        (short const   )279,      (short const   )-1,      (short const   )256,      (short const   )-1, 
        (short const   )258,      (short const   )259,      (short const   )-1,      (short const   )261, 
        (short const   )262,      (short const   )-1,      (short const   )-1,      (short const   )265, 
        (short const   )266,      (short const   )267,      (short const   )268,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )272,      (short const   )273, 
        (short const   )-1,      (short const   )275,      (short const   )276,      (short const   )277, 
        (short const   )278,      (short const   )279,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )258,      (short const   )259, 
        (short const   )260,      (short const   )261,      (short const   )-1,      (short const   )263, 
        (short const   )-1,      (short const   )265,      (short const   )266,      (short const   )267, 
        (short const   )268,      (short const   )269,      (short const   )36,      (short const   )-1, 
        (short const   )272,      (short const   )-1,      (short const   )40,      (short const   )275, 
        (short const   )276,      (short const   )277,      (short const   )278,      (short const   )279, 
        (short const   )258,      (short const   )259,      (short const   )260,      (short const   )261, 
        (short const   )-1,      (short const   )263,      (short const   )-1,      (short const   )265, 
        (short const   )266,      (short const   )267,      (short const   )268,      (short const   )269, 
        (short const   )-1,      (short const   )-1,      (short const   )272,      (short const   )-1, 
        (short const   )-1,      (short const   )275,      (short const   )276,      (short const   )277, 
        (short const   )278,      (short const   )279,      (short const   )258,      (short const   )259, 
        (short const   )260,      (short const   )261,      (short const   )-1,      (short const   )263, 
        (short const   )-1,      (short const   )265,      (short const   )266,      (short const   )267, 
        (short const   )268,      (short const   )269,      (short const   )-1,      (short const   )-1, 
        (short const   )272,      (short const   )-1,      (short const   )-1,      (short const   )275, 
        (short const   )276,      (short const   )277,      (short const   )278,      (short const   )279, 
        (short const   )-1,      (short const   )258,      (short const   )259,      (short const   )260, 
        (short const   )261,      (short const   )262,      (short const   )96,      (short const   )-1, 
        (short const   )265,      (short const   )266,      (short const   )267,      (short const   )268, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )272, 
        (short const   )273,      (short const   )-1,      (short const   )275,      (short const   )276, 
        (short const   )277,      (short const   )278,      (short const   )279,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )123,      (short const   )-1,      (short const   )258, 
        (short const   )259,      (short const   )260,      (short const   )261,      (short const   )-1, 
        (short const   )263,      (short const   )-1,      (short const   )265,      (short const   )266, 
        (short const   )267,      (short const   )268,      (short const   )269,      (short const   )-1, 
        (short const   )-1,      (short const   )272,      (short const   )-1,      (short const   )-1, 
        (short const   )275,      (short const   )276,      (short const   )277,      (short const   )278, 
        (short const   )279,      (short const   )-1,      (short const   )258,      (short const   )259, 
        (short const   )260,      (short const   )261,      (short const   )-1,      (short const   )263, 
        (short const   )-1,      (short const   )265,      (short const   )266,      (short const   )267, 
        (short const   )268,      (short const   )269,      (short const   )-1,      (short const   )-1, 
        (short const   )272,      (short const   )-1,      (short const   )-1,      (short const   )275, 
        (short const   )276,      (short const   )277,      (short const   )278,      (short const   )279, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )0, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )0, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )18,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )22,      (short const   )-1,      (short const   )-1, 
        (short const   )25,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )29,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )22,      (short const   )-1,      (short const   )-1, 
        (short const   )25,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )29,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )51,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )56, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )61,      (short const   )-1,      (short const   )51,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )69,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )61,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )258,      (short const   )259,      (short const   )-1,      (short const   )261, 
        (short const   )262,      (short const   )-1,      (short const   )-1,      (short const   )265, 
        (short const   )266,      (short const   )267,      (short const   )268,      (short const   )-1, 
        (short const   )97,      (short const   )-1,      (short const   )272,      (short const   )273, 
        (short const   )101,      (short const   )275,      (short const   )276,      (short const   )277, 
        (short const   )278,      (short const   )279,      (short const   )-1,      (short const   )-1, 
        (short const   )97,      (short const   )110,      (short const   )111,      (short const   )112, 
        (short const   )101,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )110,      (short const   )111,      (short const   )112, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )131,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )137,      (short const   )138,      (short const   )139,      (short const   )-1, 
        (short const   )-1,      (short const   )142,      (short const   )131,      (short const   )-1, 
        (short const   )145,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )137,      (short const   )138,      (short const   )139,      (short const   )-1, 
        (short const   )-1,      (short const   )142,      (short const   )-1,      (short const   )-1, 
        (short const   )145};
#line 563 "y.tab.c"
int yydebug  ;
#line 564 "y.tab.c"
int yynerrs  ;
#line 565 "y.tab.c"
int yyerrflag  ;
#line 566 "y.tab.c"
int yychar  ;
#line 567 "y.tab.c"
short *yyssp  ;
#line 568 "y.tab.c"
YYSTYPE *yyvsp  ;
#line 569 "y.tab.c"
YYSTYPE yyval  ;
#line 570 "y.tab.c"
YYSTYPE yylval  ;
#line 571 "y.tab.c"
short *yyss  ;
#line 572 "y.tab.c"
short *yysslim  ;
#line 573 "y.tab.c"
YYSTYPE *yyvs  ;
#line 574 "y.tab.c"
int yystacksize  ;
#line 168 "parse.y"
void initparse(void) 
{ 
  Node *tmp ;
  Node *tmp___0 ;
  Node *tmp___1 ;
  Node *tmp___2 ;

  {
  {
#line 169
  tmp = mk(30, "*", (void *)0, 0);
#line 169
  tmp___0 = mk(27, tmp);
#line 169
  star = treecpy(tmp___0, & ealloc);
#line 170
  tmp___1 = mk(30, "ifs", (void *)0, 0);
#line 170
  tmp___2 = mk(27, tmp___1);
#line 170
  nolist = treecpy(tmp___2, & ealloc);
  }
#line 171
  return;
}
}
#line 584 "y.tab.c"
static int yygrowstack(void) 
{ 
  int newsize ;
  int i ;
  short *newss ;
  YYSTYPE *newvs ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;

  {
#line 590
  newsize = yystacksize;
#line 590
  if (newsize == 0) {
#line 591
    newsize = 200;
  } else
#line 592
  if (newsize >= 10000) {
#line 593
    return (-1);
  } else {
#line 594
    newsize *= 2;
#line 594
    if (newsize > 10000) {
#line 595
      newsize = 10000;
    }
  }
#line 596
  i = (int )(yyssp - yyss);
#line 597
  if (yyss) {
    {
#line 597
    tmp = realloc((void *)yyss, (unsigned long )newsize * sizeof(*newss));
#line 597
    newss = (short *)tmp;
    }
  } else {
    {
#line 597
    tmp___0 = malloc((unsigned long )newsize * sizeof(*newss));
#line 597
    newss = (short *)tmp___0;
    }
  }
#line 599
  if ((unsigned long )newss == (unsigned long )((void *)0)) {
#line 600
    return (-1);
  }
#line 601
  yyss = newss;
#line 602
  yyssp = newss + i;
#line 603
  if (yyvs) {
    {
#line 603
    tmp___1 = realloc((void *)yyvs, (unsigned long )newsize * sizeof(*newvs));
#line 603
    newvs = (YYSTYPE *)tmp___1;
    }
  } else {
    {
#line 603
    tmp___2 = malloc((unsigned long )newsize * sizeof(*newvs));
#line 603
    newvs = (YYSTYPE *)tmp___2;
    }
  }
#line 605
  if ((unsigned long )newvs == (unsigned long )((void *)0)) {
#line 606
    return (-1);
  }
#line 607
  yyvs = newvs;
#line 608
  yyvsp = newvs + i;
#line 609
  yystacksize = newsize;
#line 610
  yysslim = (yyss + newsize) - 1;
#line 611
  return (0);
}
}
#line 640 "y.tab.c"
int yyparse(void) 
{ 
  register int yym ;
  register int yyn ;
  register int yystate ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  Node *tmp___4 ;
  Node *tmp___5 ;
  Node *tmp___6 ;
  struct Node *tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  Node *tmp___11 ;
  Node *tmp___12 ;
  Node *tmp___13 ;
  Node *tmp___14 ;
  Node *tmp___15 ;
  Node *tmp___16 ;
  Node *tmp___17 ;
  int tmp___18 ;

  {
#line 656
  yynerrs = 0;
#line 657
  yyerrflag = 0;
#line 658
  yychar = -1;
#line 660
  if ((unsigned long )yyss == (unsigned long )((void *)0)) {
    {
#line 660
    tmp = yygrowstack();
    }
#line 660
    if (tmp) {
#line 660
      goto yyoverflow;
    }
  }
#line 661
  yyssp = yyss;
#line 662
  yyvsp = yyvs;
#line 663
  yystate = 0;
#line 663
  *yyssp = (short )yystate;
  yyloop: 
#line 666
  yyn = (int )yydefred[yystate];
#line 666
  if (yyn) {
#line 666
    goto yyreduce;
  }
#line 667
  if (yychar < 0) {
    {
#line 669
    yychar = yylex();
    }
#line 669
    if (yychar < 0) {
#line 669
      yychar = 0;
    }
  }
#line 681
  yyn = (int )yysindex[yystate];
#line 681
  if (yyn) {
#line 681
    yyn += yychar;
#line 681
    if (yyn >= 0) {
#line 681
      if (yyn <= 1464) {
#line 681
        if ((int const   )yycheck[yyn] == (int const   )yychar) {
#line 689
          if ((unsigned long )yyssp >= (unsigned long )yysslim) {
            {
#line 689
            tmp___0 = yygrowstack();
            }
#line 689
            if (tmp___0) {
#line 691
              goto yyoverflow;
            }
          }
#line 693
          yyssp ++;
#line 693
          yystate = (int )yytable[yyn];
#line 693
          *yyssp = (short )yystate;
#line 694
          yyvsp ++;
#line 694
          *yyvsp = yylval;
#line 695
          yychar = -1;
#line 696
          if (yyerrflag > 0) {
#line 696
            yyerrflag --;
          }
#line 697
          goto yyloop;
        }
      }
    }
  }
#line 699
  yyn = (int )yyrindex[yystate];
#line 699
  if (yyn) {
#line 699
    yyn += yychar;
#line 699
    if (yyn >= 0) {
#line 699
      if (yyn <= 1464) {
#line 699
        if ((int const   )yycheck[yyn] == (int const   )yychar) {
#line 702
          yyn = (int )yytable[yyn];
#line 703
          goto yyreduce;
        }
      }
    }
  }
#line 705
  if (yyerrflag) {
#line 705
    goto yyinrecovery;
  }
#line 707
  goto yynewerror;
  yynewerror: 
  {
#line 710
  yyerror("syntax error");
  }
#line 712
  goto yyerrlab;
  yyerrlab: 
#line 715
  yynerrs ++;
  yyinrecovery: 
#line 717
  if (yyerrflag < 3) {
#line 719
    yyerrflag = 3;
    {
#line 720
    while (1) {
      while_continue: /* CIL Label */ ;
#line 722
      yyn = (int )yysindex[*yyssp];
#line 722
      if (yyn) {
#line 722
        yyn += 256;
#line 722
        if (yyn >= 0) {
#line 722
          if (yyn <= 1464) {
#line 722
            if ((int const   )yycheck[yyn] == 256) {
#line 730
              if ((unsigned long )yyssp >= (unsigned long )yysslim) {
                {
#line 730
                tmp___1 = yygrowstack();
                }
#line 730
                if (tmp___1) {
#line 732
                  goto yyoverflow;
                }
              }
#line 734
              yyssp ++;
#line 734
              yystate = (int )yytable[yyn];
#line 734
              *yyssp = (short )yystate;
#line 735
              yyvsp ++;
#line 735
              *yyvsp = yylval;
#line 736
              goto yyloop;
            } else {
#line 722
              goto _L___1;
            }
          } else {
#line 722
            goto _L___1;
          }
        } else {
#line 722
          goto _L___1;
        }
      } else {
        _L___1: /* CIL Label */ 
#line 745
        if ((unsigned long )yyssp <= (unsigned long )yyss) {
#line 745
          goto yyabort;
        }
#line 746
        yyssp --;
#line 747
        yyvsp --;
      }
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 753
    if (yychar == 0) {
#line 753
      goto yyabort;
    }
#line 764
    yychar = -1;
#line 765
    goto yyloop;
  }
  yyreduce: 
#line 773
  yym = (int )yylen[yyn];
#line 774
  yyval = *(yyvsp + (1 - yym));
  {
#line 777
  if (yyn == 1) {
#line 777
    goto case_1;
  }
#line 49
  if (yyn == 2) {
#line 49 "parse.y"
    goto case_2;
  }
#line 50
  if (yyn == 3) {
#line 50
    goto case_3;
  }
#line 53
  if (yyn == 4) {
#line 53
    goto case_4;
  }
#line 54
  if (yyn == 6) {
#line 54
    goto case_6;
  }
#line 58
  if (yyn == 8) {
#line 58
    goto case_8;
  }
#line 62
  if (yyn == 10) {
#line 62
    goto case_10;
  }
#line 66
  if (yyn == 12) {
#line 66
    goto case_12;
  }
#line 69
  if (yyn == 13) {
#line 69
    goto case_13;
  }
#line 71
  if (yyn == 14) {
#line 71
    goto case_14;
  }
#line 73
  if (yyn == 15) {
#line 73
    goto case_15;
  }
#line 75
  if (yyn == 16) {
#line 75
    goto case_16;
  }
#line 77
  if (yyn == 17) {
#line 77
    goto case_17;
  }
#line 78
  if (yyn == 18) {
#line 78
    goto case_18;
  }
#line 81
  if (yyn == 19) {
#line 81
    goto case_19;
  }
#line 84
  if (yyn == 20) {
#line 84
    goto case_20;
  }
#line 87
  if (yyn == 21) {
#line 87
    goto case_21;
  }
#line 89
  if (yyn == 22) {
#line 89
    goto case_22;
  }
#line 90
  if (yyn == 23) {
#line 90
    goto case_23;
  }
#line 92
  if (yyn == 24) {
#line 92
    goto case_24;
  }
#line 93
  if (yyn == 25) {
#line 93
    goto case_25;
  }
#line 94
  if (yyn == 27) {
#line 94
    goto case_27;
  }
#line 97
  if (yyn == 28) {
#line 97
    goto case_28;
  }
#line 99
  if (yyn == 30) {
#line 99
    goto case_30;
  }
#line 101
  if (yyn == 31) {
#line 101
    goto case_31;
  }
#line 102
  if (yyn == 32) {
#line 102
    goto case_32;
  }
#line 103
  if (yyn == 33) {
#line 103
    goto case_33;
  }
#line 104
  if (yyn == 34) {
#line 104
    goto case_34;
  }
#line 105
  if (yyn == 35) {
#line 105
    goto case_35;
  }
#line 106
  if (yyn == 36) {
#line 106
    goto case_36;
  }
#line 107
  if (yyn == 37) {
#line 107
    goto case_37;
  }
#line 108
  if (yyn == 38) {
#line 108
    goto case_38;
  }
#line 109
  if (yyn == 39) {
#line 109
    goto case_39;
  }
#line 110
  if (yyn == 40) {
#line 110
    goto case_40;
  }
#line 111
  if (yyn == 41) {
#line 111
    goto case_41;
  }
#line 112
  if (yyn == 42) {
#line 112
    goto case_42;
  }
#line 113
  if (yyn == 43) {
#line 113
    goto case_43;
  }
#line 114
  if (yyn == 44) {
#line 114
    goto case_44;
  }
#line 115
  if (yyn == 45) {
#line 115
    goto case_45;
  }
#line 116
  if (yyn == 49) {
#line 116
    goto case_49;
  }
#line 122
  if (yyn == 50) {
#line 122
    goto case_50;
  }
#line 123
  if (yyn == 52) {
#line 123
    goto case_52;
  }
#line 126
  if (yyn == 54) {
#line 126
    goto case_54;
  }
#line 129
  if (yyn == 56) {
#line 129
    goto case_56;
  }
#line 132
  if (yyn == 57) {
#line 132
    goto case_57;
  }
#line 134
  if (yyn == 58) {
#line 134
    goto case_58;
  }
#line 135
  if (yyn == 59) {
#line 135
    goto case_59;
  }
#line 136
  if (yyn == 60) {
#line 136
    goto case_60;
  }
#line 137
  if (yyn == 61) {
#line 137
    goto case_61;
  }
#line 138
  if (yyn == 62) {
#line 138
    goto case_62;
  }
#line 139
  if (yyn == 63) {
#line 139
    goto case_63;
  }
#line 140
  if (yyn == 64) {
#line 140
    goto case_64;
  }
#line 141
  if (yyn == 65) {
#line 141
    goto case_65;
  }
#line 142
  if (yyn == 66) {
#line 142
    goto case_66;
  }
#line 143
  if (yyn == 67) {
#line 143
    goto case_67;
  }
#line 144
  if (yyn == 68) {
#line 144
    goto case_68;
  }
#line 146
  if (yyn == 69) {
#line 146
    goto case_69;
  }
#line 147
  if (yyn == 70) {
#line 147
    goto case_70;
  }
#line 148
  if (yyn == 71) {
#line 148
    goto case_71;
  }
#line 149
  if (yyn == 72) {
#line 149
    goto case_72;
  }
#line 150
  if (yyn == 73) {
#line 150
    goto case_73;
  }
#line 151
  if (yyn == 74) {
#line 151
    goto case_74;
  }
#line 152
  if (yyn == 75) {
#line 152
    goto case_75;
  }
#line 153
  if (yyn == 76) {
#line 153
    goto case_76;
  }
#line 154
  if (yyn == 77) {
#line 154
    goto case_77;
  }
#line 155
  if (yyn == 78) {
#line 155
    goto case_78;
  }
#line 156
  if (yyn == 79) {
#line 156
    goto case_79;
  }
#line 158
  if (yyn == 80) {
#line 158
    goto case_80;
  }
#line 159
  if (yyn == 81) {
#line 159
    goto case_81;
  }
#line 161
  if (yyn == 83) {
#line 161
    goto case_83;
  }
#line 775 "y.tab.c"
  goto switch_break;
  case_1: /* CIL Label */ 
#line 47 "parse.y"
  parsetree = (yyvsp + -1)->node;
#line 47
  goto yyaccept;
#line 48
  goto switch_break;
  case_2: /* CIL Label */ 
#line 48
  yyerrflag = 0;
#line 48
  parsetree = (Node *)((void *)0);
#line 48
  goto yyabort;
#line 49
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 51
  tmp___2 = heredoc(1);
  }
#line 51
  if (! tmp___2) {
#line 51
    goto yyabort;
  }
#line 52
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 52
  tmp___3 = heredoc(0);
  }
#line 52
  if (! tmp___3) {
#line 52
    goto yyabort;
  }
#line 53
  goto switch_break;
  case_6: /* CIL Label */ 
#line 56
  if ((unsigned long )(yyvsp + -1)->node != (unsigned long )((void *)0)) {
    {
#line 56
    tmp___4 = mk(6, (yyvsp + -1)->node);
#line 56
    yyval.node = tmp___4;
    }
  } else {
#line 56
    yyval.node = (yyvsp + -1)->node;
  }
#line 57
  goto switch_break;
  case_8: /* CIL Label */ 
#line 60
  if ((unsigned long )(yyvsp + -1)->node != (unsigned long )((void *)0)) {
    {
#line 60
    tmp___5 = mk(4, (yyvsp + -1)->node, (yyvsp + 0)->node);
#line 60
    yyval.node = tmp___5;
    }
  } else {
#line 60
    yyval.node = (yyvsp + 0)->node;
  }
#line 61
  goto switch_break;
  case_10: /* CIL Label */ 
#line 64
  if ((unsigned long )(yyvsp + -1)->node == (unsigned long )((void *)0)) {
#line 64
    yyval.node = (yyvsp + 0)->node;
  } else {
#line 64
    if ((unsigned long )(yyvsp + 0)->node == (unsigned long )((void *)0)) {
#line 64
      tmp___7 = (yyvsp + -1)->node;
    } else {
      {
#line 64
      tmp___6 = mk(4, (yyvsp + -1)->node, (yyvsp + 0)->node);
#line 64
      tmp___7 = tmp___6;
      }
    }
#line 64
    yyval.node = tmp___7;
  }
#line 65
  goto switch_break;
  case_12: /* CIL Label */ 
  {
#line 67
  yyval.node = (yyvsp + -1)->node;
#line 67
  tmp___8 = heredoc(0);
  }
#line 67
  if (! tmp___8) {
#line 67
    goto yyabort;
  }
#line 68
  goto switch_break;
  case_13: /* CIL Label */ 
#line 69
  yyval.node = (yyvsp + -1)->node;
#line 70
  goto switch_break;
  case_14: /* CIL Label */ 
#line 71
  yyval.node = (yyvsp + -1)->node;
#line 72
  goto switch_break;
  case_15: /* CIL Label */ 
  {
#line 73
  yyval.node = mk(1, (yyvsp + -2)->node, (yyvsp + 0)->node);
  }
#line 74
  goto switch_break;
  case_16: /* CIL Label */ 
#line 75
  yyval.node = (struct Node *)((void *)0);
#line 76
  goto switch_break;
  case_17: /* CIL Label */ 
  {
#line 76
  yyval.node = mk(13, (yyvsp + -1)->node, (yyvsp + 0)->node);
  }
#line 77
  goto switch_break;
  case_18: /* CIL Label */ 
  {
#line 79
  yyval.node = mk(12, (unsigned int )(yyvsp + 0)->dup.type, (yyvsp + 0)->dup.left,
                  (yyvsp + 0)->dup.right);
  }
#line 80
  goto switch_break;
  case_19: /* CIL Label */ 
  {
#line 80
  yyval.node = mk(20, (unsigned int )(yyvsp + -1)->redir.type, (yyvsp + -1)->redir.fd,
                  (yyvsp + 0)->node);
  }
#line 81
  if ((unsigned int )(yyvsp + -1)->redir.type == 3U) {
    {
#line 81
    tmp___9 = qdoc((yyvsp + 0)->node, yyval.node);
    }
#line 81
    if (! tmp___9) {
#line 81
      goto yyabort;
    }
  }
#line 83
  goto switch_break;
  case_20: /* CIL Label */ 
  {
#line 83
  yyval.node = mk(20, (unsigned int )(yyvsp + -1)->redir.type, (yyvsp + -1)->redir.fd,
                  (yyvsp + 0)->node);
  }
#line 84
  if ((unsigned int )(yyvsp + -1)->redir.type == 3U) {
    {
#line 84
    tmp___10 = qdoc((yyvsp + 0)->node, yyval.node);
    }
#line 84
    if (! tmp___10) {
#line 84
      goto yyabort;
    }
  }
#line 86
  goto switch_break;
  case_21: /* CIL Label */ 
  {
#line 87
  yyval.node = mk(24, (yyvsp + -1)->node);
  }
#line 88
  goto switch_break;
  case_22: /* CIL Label */ 
  {
#line 88
  yyval.node = mk(24, (yyvsp + -1)->node);
  }
#line 89
  goto switch_break;
  case_23: /* CIL Label */ 
  {
#line 90
  yyval.node = mk(5, (yyvsp + 0)->node, (void *)0);
  }
#line 91
  goto switch_break;
  case_24: /* CIL Label */ 
  {
#line 91
  yyval.node = mk(5, (yyvsp + -1)->node, (yyvsp + 0)->node);
  }
#line 92
  goto switch_break;
  case_25: /* CIL Label */ 
  {
#line 92
  yyval.node = mk(5, (yyvsp + -1)->node, (yyvsp + 0)->node);
  }
#line 93
  goto switch_break;
  case_27: /* CIL Label */ 
  {
#line 95
  yyval.node = mk(10, (yyvsp + -3)->node, (yyvsp + 0)->node);
  }
#line 96
  goto switch_break;
  case_28: /* CIL Label */ 
#line 97
  yyval.node = (struct Node *)((void *)0);
#line 98
  goto switch_break;
  case_30: /* CIL Label */ 
  {
#line 99
  yyval.node = mk(7, (yyvsp + -1)->node, (yyvsp + 0)->node);
  }
#line 100
  goto switch_break;
  case_31: /* CIL Label */ 
  {
#line 100
  yyval.node = mk(16, (yyvsp + -2)->node, (yyvsp + 0)->node);
  }
#line 101
  goto switch_break;
  case_32: /* CIL Label */ 
  {
#line 101
  yyval.node = mk(15, (yyvsp + -5)->node, (yyvsp + -3)->node, (yyvsp + 0)->node);
  }
#line 102
  goto switch_break;
  case_33: /* CIL Label */ 
  {
#line 102
  yyval.node = mk(15, (yyvsp + -3)->node, star, (yyvsp + 0)->node);
  }
#line 103
  goto switch_break;
  case_34: /* CIL Label */ 
  {
#line 103
  yyval.node = mk(29, (yyvsp + -2)->node, (yyvsp + 0)->node);
  }
#line 104
  goto switch_break;
  case_35: /* CIL Label */ 
  {
#line 104
  yyval.node = mk(25, (yyvsp + -5)->node, (yyvsp + -1)->node);
  }
#line 105
  goto switch_break;
  case_36: /* CIL Label */ 
  {
#line 105
  yyval.node = mk(26, (yyvsp + -1)->node, (yyvsp + 0)->node);
  }
#line 106
  goto switch_break;
  case_37: /* CIL Label */ 
  {
#line 106
  yyval.node = mk(0, (yyvsp + -3)->node, (yyvsp + 0)->node);
  }
#line 107
  goto switch_break;
  case_38: /* CIL Label */ 
  {
#line 107
  yyval.node = mk(17, (yyvsp + -3)->node, (yyvsp + 0)->node);
  }
#line 108
  goto switch_break;
  case_39: /* CIL Label */ 
  {
#line 108
  yyval.node = mk(18, (yyvsp + -2)->pipe.left, (yyvsp + -2)->pipe.right, (yyvsp + -3)->node,
                  (yyvsp + 0)->node);
  }
#line 109
  goto switch_break;
  case_40: /* CIL Label */ 
#line 109
  if ((unsigned long )(yyvsp + 0)->node != (unsigned long )((void *)0)) {
    {
#line 109
    tmp___11 = mk(19, (yyvsp + -1)->node, (yyvsp + 0)->node);
#line 109
    yyval.node = tmp___11;
    }
  } else {
#line 109
    yyval.node = (yyvsp + -1)->node;
  }
#line 110
  goto switch_break;
  case_41: /* CIL Label */ 
#line 110
  if ((unsigned long )(yyvsp + 0)->node != (unsigned long )((void *)0)) {
    {
#line 110
    tmp___12 = mk(19, (yyvsp + -1)->node, (yyvsp + 0)->node);
#line 110
    yyval.node = tmp___12;
    }
  } else {
#line 110
    yyval.node = (yyvsp + -1)->node;
  }
#line 111
  goto switch_break;
  case_42: /* CIL Label */ 
  {
#line 111
  yyval.node = mk(3, (yyvsp + 0)->node);
  }
#line 112
  goto switch_break;
  case_43: /* CIL Label */ 
  {
#line 112
  yyval.node = mk(23, (yyvsp + 0)->node);
  }
#line 113
  goto switch_break;
  case_44: /* CIL Label */ 
  {
#line 113
  yyval.node = mk(14, (yyvsp + -1)->node, (yyvsp + 0)->node);
  }
#line 114
  goto switch_break;
  case_45: /* CIL Label */ 
  {
#line 114
  yyval.node = mk(21, (yyvsp + 0)->node);
  }
#line 115
  goto switch_break;
  case_49: /* CIL Label */ 
#line 120
  if ((unsigned long )(yyvsp + 0)->node != (unsigned long )((void *)0)) {
    {
#line 120
    tmp___13 = mk(22, (yyvsp + -1)->node, (yyvsp + 0)->node);
#line 120
    yyval.node = tmp___13;
    }
  } else {
#line 120
    yyval.node = (yyvsp + -1)->node;
  }
#line 121
  goto switch_break;
  case_50: /* CIL Label */ 
  {
#line 121
  yyval.node = mk(22, (yyvsp + -1)->node, (yyvsp + 0)->node);
  }
#line 122
  goto switch_break;
  case_52: /* CIL Label */ 
  {
#line 124
  yyval.node = mk(8, (yyvsp + -2)->node, (yyvsp + 0)->node);
  }
#line 125
  goto switch_break;
  case_54: /* CIL Label */ 
  {
#line 127
  yyval.node = mk(30, (yyvsp + 0)->keyword, (void *)0, 0);
  }
#line 128
  goto switch_break;
  case_56: /* CIL Label */ 
  {
#line 130
  yyval.node = mk(8, (yyvsp + -2)->node, (yyvsp + 0)->node);
  }
#line 131
  goto switch_break;
  case_57: /* CIL Label */ 
  {
#line 132
  yyval.node = mk(27, (yyvsp + 0)->node);
  }
#line 133
  goto switch_break;
  case_58: /* CIL Label */ 
  {
#line 133
  yyval.node = mk(28, (yyvsp + -3)->node, (yyvsp + -1)->node);
  }
#line 134
  goto switch_break;
  case_59: /* CIL Label */ 
  {
#line 134
  yyval.node = mk(9, (yyvsp + 0)->node);
  }
#line 135
  goto switch_break;
  case_60: /* CIL Label */ 
  {
#line 135
  yyval.node = mk(11, (yyvsp + 0)->node);
  }
#line 136
  goto switch_break;
  case_61: /* CIL Label */ 
  {
#line 136
  yyval.node = mk(2, nolist, (yyvsp + 0)->node);
  }
#line 137
  goto switch_break;
  case_62: /* CIL Label */ 
  {
#line 137
  yyval.node = mk(2, nolist, (yyvsp + 0)->node);
  }
#line 138
  goto switch_break;
  case_63: /* CIL Label */ 
  {
#line 138
  yyval.node = mk(2, (yyvsp + -1)->node, (yyvsp + 0)->node);
  }
#line 139
  goto switch_break;
  case_64: /* CIL Label */ 
  {
#line 139
  yyval.node = mk(2, (yyvsp + -1)->node, (yyvsp + 0)->node);
  }
#line 140
  goto switch_break;
  case_65: /* CIL Label */ 
#line 140
  yyval.node = (yyvsp + -1)->node;
#line 141
  goto switch_break;
  case_66: /* CIL Label */ 
  {
#line 141
  yyval.node = mk(32, (unsigned int )(yyvsp + -1)->redir.type, (yyvsp + -1)->redir.fd,
                  (yyvsp + 0)->node);
  }
#line 142
  goto switch_break;
  case_67: /* CIL Label */ 
  {
#line 142
  yyval.node = mk(30, (yyvsp + 0)->word.w, (yyvsp + 0)->word.m, (unsigned int )(yyvsp + 0)->word.q);
  }
#line 143
  goto switch_break;
  case_68: /* CIL Label */ 
#line 144
  yyval.keyword = (char *)"for";
#line 145
  goto switch_break;
  case_69: /* CIL Label */ 
#line 145
  yyval.keyword = (char *)"in";
#line 146
  goto switch_break;
  case_70: /* CIL Label */ 
#line 146
  yyval.keyword = (char *)"while";
#line 147
  goto switch_break;
  case_71: /* CIL Label */ 
#line 147
  yyval.keyword = (char *)"if";
#line 148
  goto switch_break;
  case_72: /* CIL Label */ 
#line 148
  yyval.keyword = (char *)"switch";
#line 149
  goto switch_break;
  case_73: /* CIL Label */ 
#line 149
  yyval.keyword = (char *)"fn";
#line 150
  goto switch_break;
  case_74: /* CIL Label */ 
#line 150
  yyval.keyword = (char *)"else";
#line 151
  goto switch_break;
  case_75: /* CIL Label */ 
#line 151
  yyval.keyword = (char *)"case";
#line 152
  goto switch_break;
  case_76: /* CIL Label */ 
#line 152
  yyval.keyword = (char *)"~";
#line 153
  goto switch_break;
  case_77: /* CIL Label */ 
#line 153
  yyval.keyword = (char *)"!";
#line 154
  goto switch_break;
  case_78: /* CIL Label */ 
#line 154
  yyval.keyword = (char *)"@";
#line 155
  goto switch_break;
  case_79: /* CIL Label */ 
#line 156
  yyval.node = (struct Node *)((void *)0);
#line 157
  goto switch_break;
  case_80: /* CIL Label */ 
#line 157
  if ((unsigned long )(yyvsp + -1)->node != (unsigned long )((void *)0)) {
#line 157
    if ((unsigned long )(yyvsp + 0)->node != (unsigned long )((void *)0)) {
      {
#line 157
      tmp___14 = mk(31, (yyvsp + -1)->node, (yyvsp + 0)->node);
#line 157
      tmp___15 = tmp___14;
      }
    } else {
#line 157
      tmp___15 = (yyvsp + -1)->node;
    }
#line 157
    yyval.node = tmp___15;
  } else {
#line 157
    yyval.node = (yyvsp + 0)->node;
  }
#line 158
  goto switch_break;
  case_81: /* CIL Label */ 
#line 159
  yyval.node = (struct Node *)((void *)0);
#line 160
  goto switch_break;
  case_83: /* CIL Label */ 
#line 161
  if ((unsigned long )(yyvsp + -1)->node != (unsigned long )((void *)0)) {
#line 161
    if ((unsigned long )(yyvsp + 0)->node != (unsigned long )((void *)0)) {
      {
#line 161
      tmp___16 = mk(31, (yyvsp + -1)->node, (yyvsp + 0)->node);
#line 161
      tmp___17 = tmp___16;
      }
    } else {
#line 161
      tmp___17 = (yyvsp + -1)->node;
    }
#line 161
    yyval.node = tmp___17;
  } else {
#line 161
    yyval.node = (yyvsp + 0)->node;
  }
#line 162
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1063 "y.tab.c"
  yyssp -= yym;
#line 1064
  yystate = (int )*yyssp;
#line 1065
  yyvsp -= yym;
#line 1066
  yym = (int )yylhs[yyn];
#line 1067
  if (yystate == 0) {
#line 1067
    if (yym == 0) {
#line 1074
      yystate = 21;
#line 1075
      yyssp ++;
#line 1075
      *yyssp = (short)21;
#line 1076
      yyvsp ++;
#line 1076
      *yyvsp = yyval;
#line 1077
      if (yychar < 0) {
        {
#line 1079
        yychar = yylex();
        }
#line 1079
        if (yychar < 0) {
#line 1079
          yychar = 0;
        }
      }
#line 1091
      if (yychar == 0) {
#line 1091
        goto yyaccept;
      }
#line 1092
      goto yyloop;
    }
  }
#line 1094
  yyn = (int )yygindex[yym];
#line 1094
  if (yyn) {
#line 1094
    yyn += yystate;
#line 1094
    if (yyn >= 0) {
#line 1094
      if (yyn <= 1464) {
#line 1094
        if ((int const   )yycheck[yyn] == (int const   )yystate) {
#line 1096
          yystate = (int )yytable[yyn];
        } else {
#line 1098
          yystate = (int )yydgoto[yym];
        }
      } else {
#line 1098
        yystate = (int )yydgoto[yym];
      }
    } else {
#line 1098
      yystate = (int )yydgoto[yym];
    }
  } else {
#line 1098
    yystate = (int )yydgoto[yym];
  }
#line 1104
  if ((unsigned long )yyssp >= (unsigned long )yysslim) {
    {
#line 1104
    tmp___18 = yygrowstack();
    }
#line 1104
    if (tmp___18) {
#line 1106
      goto yyoverflow;
    }
  }
#line 1108
  yyssp ++;
#line 1108
  *yyssp = (short )yystate;
#line 1109
  yyvsp ++;
#line 1109
  *yyvsp = yyval;
#line 1110
  goto yyloop;
  yyoverflow: 
  {
#line 1112
  yyerror("yacc stack overflow");
  }
  yyabort: 
#line 1114
  return (1);
  yyaccept: 
#line 1116
  return (0);
}
}
#line 5 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/match.c"
static int rangematch(char *p , char c ) ;
#line 11 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/match.c"
extern bool match(char *p , char *m , char *s___0 ) 
{ 
  int i ;
  int j ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  bool tmp___4 ;
  int tmp___5 ;
  char *tmp___6 ;

  {
#line 13
  if ((unsigned long )m == (unsigned long )((void *)0)) {
#line 14
    if ((int )*p == (int )*s___0) {
      {
#line 14
      tmp = strcmp((char const   *)p, (char const   *)s___0);
      }
#line 14
      if (tmp == 0) {
#line 14
        tmp___0 = 1;
      } else {
#line 14
        tmp___0 = 0;
      }
    } else {
#line 14
      tmp___0 = 0;
    }
#line 14
    return ((bool )tmp___0);
  }
#line 15
  i = 0;
  {
#line 16
  while (1) {
    while_continue: /* CIL Label */ ;
#line 17
    if ((int )*(p + i) == 0) {
#line 18
      return ((bool )((int )*s___0 == 0));
    } else
#line 19
    if (*(m + i)) {
#line 20
      tmp___1 = i;
#line 20
      i ++;
      {
#line 21
      if ((int )*(p + tmp___1) == 63) {
#line 21
        goto case_63;
      }
#line 25
      if ((int )*(p + tmp___1) == 42) {
#line 25
        goto case_42;
      }
#line 34
      if ((int )*(p + tmp___1) == 91) {
#line 34
        goto case_91;
      }
#line 49
      goto switch_default___0;
      case_63: /* CIL Label */ 
#line 22
      tmp___2 = s___0;
#line 22
      s___0 ++;
#line 22
      if ((int )*tmp___2 == 0) {
#line 23
        return ((bool )0);
      }
#line 24
      goto switch_break;
      case_42: /* CIL Label */ 
      {
#line 26
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 26
        if ((int )*(p + i) == 42) {
#line 26
          if (! ((int )*(m + i) == 1)) {
#line 26
            goto while_break___0;
          }
        } else {
#line 26
          goto while_break___0;
        }
#line 27
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 28
      if ((int )*(p + i) == 0) {
#line 29
        return ((bool )1);
      }
      {
#line 30
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 30
        if (! ((int )*s___0 != 0)) {
#line 30
          goto while_break___1;
        }
        {
#line 31
        tmp___3 = s___0;
#line 31
        s___0 ++;
#line 31
        tmp___4 = match(p + i, m + i, tmp___3);
        }
#line 31
        if (tmp___4) {
#line 32
          return ((bool )1);
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 33
      return ((bool )0);
      case_91: /* CIL Label */ 
#line 35
      if ((int )*s___0 == 0) {
#line 36
        return ((bool )0);
      }
      {
#line 37
      j = rangematch(p + i, *s___0);
      }
      {
#line 41
      if (j == -1) {
#line 41
        goto case_neg_1;
      }
#line 43
      if (j == -2) {
#line 43
        goto case_neg_2;
      }
#line 38
      goto switch_default;
      switch_default: /* CIL Label */ 
#line 39
      i += j;
#line 40
      goto switch_break___0;
      case_neg_1: /* CIL Label */ 
#line 42
      return ((bool )0);
      case_neg_2: /* CIL Label */ 
#line 44
      if ((int )*s___0 != 91) {
#line 45
        return ((bool )0);
      }
      switch_break___0: /* CIL Label */ ;
      }
#line 47
      s___0 ++;
#line 48
      goto switch_break;
      switch_default___0: /* CIL Label */ 
      {
#line 50
      panic((char *)"bad metacharacter in match");
      }
#line 52
      return ((bool )0);
      switch_break: /* CIL Label */ ;
      }
    } else {
#line 54
      tmp___5 = i;
#line 54
      i ++;
#line 54
      tmp___6 = s___0;
#line 54
      s___0 ++;
#line 54
      if ((int )*(p + tmp___5) != (int )*tmp___6) {
#line 55
        return ((bool )0);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 74 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/match.c"
static int rangematch(char *p , char c ) 
{ 
  char *orig ;
  bool neg ;
  bool matched ;

  {
#line 75
  orig = p;
#line 76
  neg = (bool )((int )*p == 126);
#line 77
  matched = (bool )0;
#line 78
  if (neg) {
#line 79
    p ++;
  }
#line 80
  if ((int )*p == 93) {
#line 81
    p ++;
#line 82
    matched = (bool )((int )c == 93);
  }
  {
#line 84
  while (1) {
    while_continue: /* CIL Label */ ;
#line 84
    if (! ((int )*p != 93)) {
#line 84
      goto while_break;
    }
#line 85
    if ((int )*p == 0) {
#line 86
      return (-2);
    }
#line 87
    if ((int )*(p + 1) == 45) {
#line 87
      if ((int )*(p + 2) != 93) {
#line 88
        if ((int )c >= (int )*p) {
#line 89
          matched = (bool )((unsigned int )matched | (unsigned int )((int )c <= (int )*(p + 2)));
        }
#line 90
        p += 2;
      } else {
#line 92
        matched = (bool )((unsigned int )matched | (unsigned int )((int )*p == (int )c));
      }
    } else {
#line 92
      matched = (bool )((unsigned int )matched | (unsigned int )((int )*p == (int )c));
    }
#line 84
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 95
  if ((unsigned int )matched ^ (unsigned int )neg) {
#line 96
    return ((int )((p - orig) + 1L));
  } else {
#line 98
    return (-1);
  }
}
}
#line 634 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) getpgrp)(void) ;
#line 839
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) tcgetpgrp)(int __fd ) ;
#line 146 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 15 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/open.c"
static int const   mode_masks[3]  = {      (int const   )0,      (int const   )577,      (int const   )1089};
#line 21 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/open.c"
extern int rc_open(char const   *name , redirtype m ) 
{ 
  int tmp ;

  {
#line 22
  if ((unsigned int )m >= (unsigned int )((int )(sizeof(mode_masks) / sizeof(mode_masks[0])))) {
    {
#line 23
    panic((char *)"bad mode passed to rc_open");
    }
  }
  {
#line 24
  tmp = open(name, (int )mode_masks[m], 438);
  }
#line 24
  return (tmp);
}
}
#line 30 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/open.c"
extern bool makeblocking(int fd ) 
{ 
  int flags ;
  int tmp ;

  {
  {
#line 33
  flags = fcntl(fd, 3);
  }
#line 33
  if (flags == -1) {
    {
#line 34
    uerror((char *)"fcntl");
#line 35
    rc_error((char *)((void *)0));
    }
  }
#line 37
  if (! (flags & 2048)) {
#line 38
    return ((bool )0);
  }
  {
#line 39
  flags &= -2049;
#line 40
  tmp = fcntl(fd, 4, (long )flags);
  }
#line 40
  if (tmp == -1) {
    {
#line 41
    uerror((char *)"fcntl");
#line 42
    rc_error((char *)((void *)0));
    }
  }
#line 44
  return ((bool )1);
}
}
#line 50 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/open.c"
extern bool makesamepgrp(int fd ) 
{ 
  pid_t grp ;
  __pid_t tmp ;
  int tmp___0 ;

  {
  {
#line 53
  grp = getpgrp();
#line 55
  tmp = tcgetpgrp(fd);
  }
#line 55
  if (tmp == grp) {
#line 56
    return ((bool )0);
  }
  {
#line 58
  tmp___0 = tcsetpgrp(fd, grp);
  }
#line 58
  if (tmp___0 < 0) {
    {
#line 59
    uerror((char *)"tcsetgrp");
    }
#line 60
    return ((bool )0);
  }
#line 62
  return ((bool )1);
}
}
#line 266 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/rc.h"
struct Hq *hq  ;
#line 12 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/heredoc.c"
static bool dead___0  =    (bool )0;
#line 25 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/heredoc.c"
static char *readheredoc(char *eof ) 
{ 
  int c ;
  char *t ;
  char *buf ;
  char *bufend ;
  unsigned char *s___0 ;
  size_t bufsize___0 ;
  void *tmp ;
  char *tmp___0 ;
  size_t len ;
  char *nbuf ;
  void *tmp___1 ;
  char *nbuf___0 ;
  void *tmp___2 ;
  char *tmp___3 ;

  {
  {
#line 30
  bufsize___0 = (size_t )512;
#line 30
  tmp = nalloc(bufsize___0);
#line 30
  buf = (char *)tmp;
#line 30
  t = buf;
#line 31
  bufend = buf + bufsize___0;
#line 32
  dead___0 = (bool )0;
  }
  {
#line 42
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 43
    print_prompt2();
#line 44
    s___0 = (unsigned char *)eof;
    }
    {
#line 44
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 44
      c = gchar();
      }
#line 44
      if (! (c == (int )*s___0)) {
#line 44
        goto while_break___0;
      }
#line 44
      s___0 ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 46
    if ((int )*s___0 == 0) {
#line 46
      if (c == 10) {
#line 47
        tmp___0 = t;
#line 47
        t ++;
#line 47
        *tmp___0 = (char )'\000';
#line 48
        return (buf);
      } else
#line 46
      if (c == -1) {
#line 47
        tmp___0 = t;
#line 47
        t ++;
#line 47
        *tmp___0 = (char )'\000';
#line 48
        return (buf);
      }
    }
#line 50
    if ((unsigned long )s___0 != (unsigned long )((unsigned char *)eof)) {
#line 51
      len = (size_t )(s___0 - (unsigned char *)eof);
#line 52
      if ((unsigned long )(t + len) >= (unsigned long )bufend) {
        {
#line 53
        bufsize___0 = bufsize___0 * 2UL + len;
#line 53
        tmp___1 = nalloc(bufsize___0);
#line 53
        nbuf = (char *)tmp___1;
#line 53
        memcpy((void */* __restrict  */)nbuf, (void const   */* __restrict  */)buf,
               (size_t )(t - buf));
#line 53
        t = nbuf + (t - buf);
#line 53
        buf = nbuf;
#line 53
        bufend = buf + bufsize___0;
        }
      }
      {
#line 54
      memcpy((void */* __restrict  */)t, (void const   */* __restrict  */)eof, len);
#line 55
      t += len;
      }
    }
    {
#line 57
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 58
      if (c == -1) {
        {
#line 59
        yyerror("heredoc incomplete");
#line 60
        dead___0 = (bool )1;
        }
#line 61
        return ((char *)((void *)0));
      }
#line 63
      if ((unsigned long )(t + 1) >= (unsigned long )bufend) {
        {
#line 64
        bufsize___0 *= 2UL;
#line 64
        tmp___2 = nalloc(bufsize___0);
#line 64
        nbuf___0 = (char *)tmp___2;
#line 64
        memcpy((void */* __restrict  */)nbuf___0, (void const   */* __restrict  */)buf,
               (size_t )(t - buf));
#line 64
        t = nbuf___0 + (t - buf);
#line 64
        buf = nbuf___0;
#line 64
        bufend = buf + bufsize___0;
        }
      }
#line 65
      tmp___3 = t;
#line 65
      t ++;
#line 65
      *tmp___3 = (char )c;
#line 66
      if (c == 10) {
#line 67
        goto while_break___1;
      }
      {
#line 57
      c = gchar();
      }
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 74 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/heredoc.c"
static Node *parseheredoc(char *s___0 ) 
{ 
  int c ;
  Node *result ;
  Node *node ;
  char *begin ;
  char *tmp ;
  char *begin___0 ;
  char *var ;
  char *tmp___0 ;
  size_t len ;
  char *tmp___1 ;
  void *tmp___2 ;
  Node *tmp___3 ;
  Node *tmp___4 ;

  {
#line 75
  c = (int )*s___0;
#line 76
  result = (Node *)((void *)0);
  {
#line 77
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 88
    if (c == 36) {
#line 88
      goto case_36;
    }
#line 110
    if (c == 0) {
#line 110
      goto case_0;
    }
#line 80
    goto switch_default;
    switch_default: /* CIL Label */ 
#line 81
    begin = s___0;
    {
#line 82
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 82
      tmp = s___0;
#line 82
      s___0 ++;
#line 82
      c = (int )*tmp;
#line 82
      if (c != 0) {
#line 82
        if (! (c != 36)) {
#line 82
          goto while_break___0;
        }
      } else {
#line 82
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 84
    s___0 --;
#line 84
    *s___0 = (char )'\000';
#line 85
    node = mk(30, begin, (void *)0);
    }
#line 86
    goto switch_break;
    case_36: /* CIL Label */ 
#line 89
    s___0 ++;
#line 89
    begin___0 = s___0;
#line 90
    tmp___0 = s___0;
#line 90
    s___0 ++;
#line 90
    c = (int )*tmp___0;
#line 91
    if (c == 36) {
      {
#line 92
      node = mk(30, "$", (void *)0);
#line 93
      c = (int )*s___0;
      }
    } else {
#line 95
      len = (size_t )0;
      {
#line 96
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 97
        len ++;
#line 96
        tmp___1 = s___0;
#line 96
        s___0 ++;
#line 96
        c = (int )*((unsigned char *)tmp___1);
#line 96
        if (dnw[c]) {
#line 96
          goto while_break___1;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 99
      if (c == 94) {
#line 100
        c = (int )*s___0;
      } else {
#line 102
        s___0 --;
      }
      {
#line 103
      tmp___2 = nalloc(len + 1UL);
#line 103
      var = (char *)tmp___2;
#line 104
      *(var + len) = (char )'\000';
#line 105
      memcpy((void */* __restrict  */)var, (void const   */* __restrict  */)begin___0,
             len);
#line 106
      tmp___3 = mk(30, var, (void *)0);
#line 106
      node = mk(11, tmp___3);
      }
    }
#line 108
    goto switch_break;
    case_0: /* CIL Label */ 
#line 111
    return (result);
    switch_break: /* CIL Label */ ;
    }
#line 113
    if ((unsigned long )result == (unsigned long )((void *)0)) {
#line 113
      result = node;
    } else {
      {
#line 113
      tmp___4 = mk(8, result, node);
#line 113
      result = tmp___4;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 119 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/heredoc.c"
extern int heredoc(int end ) 
{ 
  Hq *here ;
  Node *n ;
  char *s___0 ;
  char *tmp ;
  Node *tmp___0 ;
  Node *tmp___1 ;

  {
#line 121
  here = hq;
#line 121
  if ((unsigned long )here != (unsigned long )((void *)0)) {
#line 122
    hq = (struct Hq *)((void *)0);
#line 123
    if (end) {
      {
#line 124
      yyerror("heredoc incomplete");
      }
#line 125
      return (0);
    }
    {
#line 127
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 128
      n = here->doc;
#line 129
      tmp = readheredoc(here->name);
#line 129
      s___0 = tmp;
      }
#line 130
      if (dead___0) {
#line 131
        return (0);
      }
#line 132
      if (here->quoted) {
        {
#line 132
        tmp___0 = mk(30, s___0, (void *)0, 0);
#line 132
        n->u[2].p = tmp___0;
        }
      } else {
        {
#line 132
        tmp___1 = parseheredoc(s___0);
#line 132
        n->u[2].p = tmp___1;
        }
      }
#line 133
      n->u[0].i = 4;
#line 127
      here = here->n;
#line 127
      if (! ((unsigned long )here != (unsigned long )((void *)0))) {
#line 127
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 136
  return (1);
}
}
#line 141 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/heredoc.c"
extern int qdoc(Node *name , Node *n ) 
{ 
  Hq *new ;
  Hq **prev ;
  void *tmp ;

  {
#line 143
  if ((unsigned int )name->type != 30U) {
    {
#line 144
    yyerror("eof-marker not a single literal word");
#line 145
    flushu();
    }
#line 146
    return (0);
  }
#line 148
  prev = & hq;
  {
#line 148
  while (1) {
    while_continue: /* CIL Label */ ;
#line 148
    new = *prev;
#line 148
    if (! ((unsigned long )new != (unsigned long )((void *)0))) {
#line 148
      goto while_break;
    }
#line 148
    prev = & new->n;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 150
  tmp = nalloc(sizeof(Hq ));
#line 150
  new = (Hq *)tmp;
#line 150
  *prev = new;
#line 151
  new->name = name->u[0].s;
#line 152
  new->quoted = (bool )name->u[2].i;
#line 153
  new->doc = n;
#line 154
  new->n = (Hq *)((void *)0);
  }
#line 155
  return (1);
}
}
#line 234 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/rc.h"
Htab *fp  ;
#line 234 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/rc.h"
Htab *vp  ;
#line 14 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/hash.c"
static bool var_exportable(char *s___0 ) ;
#line 15
static bool fn_exportable(char *s___0 ) ;
#line 16
static int hash(char *s___0 , int size ) ;
#line 17
static int find(char *s___0 , Htab *ht , int size ) ;
#line 18
static void free_fn(rc_Function *f ) ;
#line 22 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/hash.c"
static int fused  ;
#line 22 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/hash.c"
static int fsize  ;
#line 22 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/hash.c"
static int vused  ;
#line 22 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/hash.c"
static int vsize  ;
#line 23 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/hash.c"
static char **env  ;
#line 24 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/hash.c"
static int bozosize  ;
#line 25 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/hash.c"
static int envsize  ;
#line 26 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/hash.c"
static bool env_dirty  =    (bool )1;
#line 27 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/hash.c"
static char *dead___1  =    (char *)"";
#line 31 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/hash.c"
extern void inithash(void) 
{ 
  Htab *fpp ;
  Htab *vpp ;
  int i ;
  void *tmp ;
  void *tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 34
  tmp = ealloc(sizeof(Htab ) * 64UL);
#line 34
  fp = (Htab *)tmp;
#line 35
  tmp___0 = ealloc(sizeof(Htab ) * 64UL);
#line 35
  vp = (Htab *)tmp___0;
#line 36
  vused = 0;
#line 36
  fused = vused;
#line 37
  vsize = 64;
#line 37
  fsize = vsize;
#line 38
  vpp = vp;
#line 38
  fpp = fp;
#line 38
  i = 0;
  }
  {
#line 38
  while (1) {
    while_continue: /* CIL Label */ ;
#line 38
    if (! (i < 64)) {
#line 38
      goto while_break;
    }
#line 39
    tmp___1 = (char *)((void *)0);
#line 39
    fpp->name = tmp___1;
#line 39
    vpp->name = tmp___1;
#line 38
    i ++;
#line 38
    vpp ++;
#line 38
    fpp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 40
  return;
}
}
#line 46 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/hash.c"
static int hash(char *s___0 , int size ) 
{ 
  int c ;
  int n ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
#line 47
  n = 0;
  {
#line 48
  while (1) {
    while_continue: /* CIL Label */ ;
#line 49
    tmp = s___0;
#line 49
    s___0 ++;
#line 49
    c = (int )*tmp;
#line 49
    if (c == 0) {
#line 49
      goto while_break;
    }
#line 50
    n += (((c << 17) ^ (c << 11)) ^ (c << 5)) ^ (c >> 1);
#line 51
    tmp___0 = s___0;
#line 51
    s___0 ++;
#line 51
    c = (int )*tmp___0;
#line 51
    if (c == 0) {
#line 51
      goto while_break;
    }
#line 52
    n ^= (((c << 14) + (c << 7)) + (c << 4)) + c;
#line 53
    tmp___1 = s___0;
#line 53
    s___0 ++;
#line 53
    c = (int )*tmp___1;
#line 53
    if (c == 0) {
#line 53
      goto while_break;
    }
#line 54
    n ^= (~ c << 11) | ((c << 3) ^ (c >> 1));
#line 55
    tmp___2 = s___0;
#line 55
    s___0 ++;
#line 55
    c = (int )*tmp___2;
#line 55
    if (c == 0) {
#line 55
      goto while_break;
    }
#line 56
    n -= (((c << 16) | (c << 9)) | (c << 2)) | (c & 3);
  }
  while_break: /* CIL Label */ ;
  }
#line 58
  if (n < 0) {
#line 59
    n = ~ n;
  }
#line 60
  return (n & (size - 1));
}
}
#line 63 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/hash.c"
static bool rehash(Htab *ht ) 
{ 
  int i ;
  int j ;
  int size ;
  int newsize ;
  int newused ;
  Htab *newhtab ;
  void *tmp ;

  {
#line 67
  if ((unsigned long )ht == (unsigned long )fp) {
#line 68
    if (fsize > 2 * fused) {
#line 69
      return ((bool )0);
    }
#line 70
    size = fsize;
  } else {
#line 72
    if (vsize > 2 * vused) {
#line 73
      return ((bool )0);
    }
#line 74
    size = vsize;
  }
  {
#line 76
  newsize = 2 * size;
#line 77
  tmp = ealloc((unsigned long )newsize * sizeof(Htab ));
#line 77
  newhtab = (Htab *)tmp;
#line 78
  i = 0;
  }
  {
#line 78
  while (1) {
    while_continue: /* CIL Label */ ;
#line 78
    if (! (i < newsize)) {
#line 78
      goto while_break;
    }
#line 79
    (newhtab + i)->name = (char *)((void *)0);
#line 78
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 80
  newused = 0;
#line 80
  i = newused;
  {
#line 80
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 80
    if (! (i < size)) {
#line 80
      goto while_break___0;
    }
#line 81
    if ((unsigned long )(ht + i)->name != (unsigned long )((void *)0)) {
#line 81
      if ((unsigned long )(ht + i)->name != (unsigned long )dead___1) {
        {
#line 82
        newused ++;
#line 83
        j = hash((ht + i)->name, newsize);
        }
        {
#line 84
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 84
          if (! ((unsigned long )(newhtab + j)->name != (unsigned long )((void *)0))) {
#line 84
            goto while_break___1;
          }
#line 85
          j ++;
#line 86
          j &= newsize - 1;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 88
        (newhtab + j)->name = (ht + i)->name;
#line 89
        (newhtab + j)->p = (ht + i)->p;
      }
    }
#line 80
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 91
  if ((unsigned long )ht == (unsigned long )fp) {
#line 92
    fused = newused;
#line 93
    fp = newhtab;
#line 94
    fsize = newsize;
  } else {
#line 96
    vused = newused;
#line 97
    vp = newhtab;
#line 98
    vsize = newsize;
  }
  {
#line 100
  efree((void *)ht);
  }
#line 101
  return ((bool )1);
}
}
#line 107 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/hash.c"
static int find(char *s___0 , Htab *ht , int size ) 
{ 
  int h ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 108
  tmp = hash(s___0, size);
#line 108
  h = tmp;
  }
  {
#line 109
  while (1) {
    while_continue: /* CIL Label */ ;
#line 109
    if ((unsigned long )(ht + h)->name != (unsigned long )((void *)0)) {
#line 109
      if ((int )*((ht + h)->name) == (int )*s___0) {
        {
#line 109
        tmp___0 = strcmp((char const   *)(ht + h)->name, (char const   *)s___0);
        }
#line 109
        if (tmp___0 == 0) {
#line 109
          goto while_break;
        }
      }
    } else {
#line 109
      goto while_break;
    }
#line 110
    h ++;
#line 111
    h &= size - 1;
  }
  while_break: /* CIL Label */ ;
  }
#line 113
  return (h);
}
}
#line 116 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/hash.c"
extern void *lookup(char *s___0 , Htab *ht ) 
{ 
  int h ;
  int tmp ;
  int tmp___0 ;
  void *tmp___1 ;

  {
#line 117
  if ((unsigned long )ht == (unsigned long )fp) {
#line 117
    tmp = fsize;
  } else {
#line 117
    tmp = vsize;
  }
  {
#line 117
  tmp___0 = find(s___0, ht, tmp);
#line 117
  h = tmp___0;
  }
#line 118
  if ((unsigned long )(ht + h)->name == (unsigned long )((void *)0)) {
#line 118
    tmp___1 = (void *)0;
  } else {
#line 118
    tmp___1 = (ht + h)->p;
  }
#line 118
  return (tmp___1);
}
}
#line 121 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/hash.c"
extern rc_Function *get_fn_place(char *s___0 ) 
{ 
  int h ;
  int tmp ;
  bool tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;

  {
  {
#line 122
  tmp = find(s___0, fp, fsize);
#line 122
  h = tmp;
#line 123
  env_dirty = (bool )1;
  }
#line 124
  if ((unsigned long )(fp + h)->name == (unsigned long )((void *)0)) {
    {
#line 125
    tmp___0 = rehash(fp);
    }
#line 125
    if (tmp___0) {
      {
#line 126
      h = find(s___0, fp, fsize);
      }
    }
    {
#line 127
    fused ++;
#line 128
    tmp___1 = strlen((char const   *)s___0);
#line 128
    tmp___2 = ealloc(tmp___1 + 1UL);
#line 128
    (fp + h)->name = strcpy((char */* __restrict  */)((char *)tmp___2), (char const   */* __restrict  */)s___0);
#line 129
    tmp___3 = ealloc(sizeof(rc_Function ));
#line 129
    (fp + h)->p = (void *)((rc_Function *)tmp___3);
    }
  } else {
    {
#line 131
    free_fn((rc_Function *)(fp + h)->p);
    }
  }
#line 132
  return ((rc_Function *)(fp + h)->p);
}
}
#line 135 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/hash.c"
extern Variable *get_var_place(char *s___0 , bool stack ) 
{ 
  Variable *new ;
  int h ;
  int tmp ;
  bool tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;

  {
  {
#line 137
  tmp = find(s___0, vp, vsize);
#line 137
  h = tmp;
#line 139
  env_dirty = (bool )1;
  }
#line 141
  if ((unsigned long )(vp + h)->name == (unsigned long )((void *)0)) {
    {
#line 142
    tmp___0 = rehash(vp);
    }
#line 142
    if (tmp___0) {
      {
#line 143
      h = find(s___0, vp, vsize);
      }
    }
    {
#line 144
    vused ++;
#line 145
    tmp___1 = strlen((char const   *)s___0);
#line 145
    tmp___2 = ealloc(tmp___1 + 1UL);
#line 145
    (vp + h)->name = strcpy((char */* __restrict  */)((char *)tmp___2), (char const   */* __restrict  */)s___0);
#line 146
    tmp___3 = ealloc(sizeof(Variable ));
#line 146
    (vp + h)->p = (void *)((Variable *)tmp___3);
#line 147
    ((Variable *)(vp + h)->p)->n = (Variable *)((void *)0);
    }
#line 148
    return ((Variable *)(vp + h)->p);
  } else
#line 150
  if (stack) {
    {
#line 151
    tmp___4 = ealloc(sizeof(Variable ));
#line 151
    new = (Variable *)tmp___4;
#line 152
    new->n = (Variable *)(vp + h)->p;
#line 153
    tmp___5 = (void *)new;
#line 153
    (vp + h)->p = tmp___5;
    }
#line 153
    return ((Variable *)tmp___5);
  } else {
    {
#line 155
    new = (Variable *)(vp + h)->p;
#line 156
    efree((void *)new->extdef);
#line 157
    listfree(new->def);
    }
#line 158
    return (new);
  }
}
}
#line 163 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/hash.c"
extern void delete_fn(char *s___0 ) 
{ 
  int h ;
  int tmp ;

  {
  {
#line 164
  tmp = find(s___0, fp, fsize);
#line 164
  h = tmp;
  }
#line 165
  if ((unsigned long )(fp + h)->name == (unsigned long )((void *)0)) {
#line 166
    return;
  }
  {
#line 167
  env_dirty = (bool )1;
#line 168
  free_fn((rc_Function *)(fp + h)->p);
#line 169
  efree((fp + h)->p);
#line 170
  efree((void *)(fp + h)->name);
  }
#line 171
  if ((unsigned long )(fp + ((h + 1) & (fsize - 1)))->name == (unsigned long )((void *)0)) {
#line 172
    fused --;
#line 173
    (fp + h)->name = (char *)((void *)0);
  } else {
#line 175
    (fp + h)->name = dead___1;
  }
#line 177
  return;
}
}
#line 179 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/hash.c"
extern void delete_var(char *s___0 , bool stack ) 
{ 
  int h ;
  int tmp ;
  Variable *v ;

  {
  {
#line 180
  tmp = find(s___0, vp, vsize);
#line 180
  h = tmp;
  }
#line 182
  if ((unsigned long )(vp + h)->name == (unsigned long )((void *)0)) {
#line 183
    return;
  }
  {
#line 184
  env_dirty = (bool )1;
#line 185
  v = (Variable *)(vp + h)->p;
#line 186
  efree((void *)v->extdef);
#line 187
  listfree(v->def);
  }
#line 188
  if ((unsigned long )v->n != (unsigned long )((void *)0)) {
#line 189
    if (stack) {
      {
#line 190
      (vp + h)->p = (void *)v->n;
#line 191
      efree((void *)v);
      }
    } else {
#line 193
      v->extdef = (char *)((void *)0);
#line 194
      v->def = (List *)((void *)0);
    }
  } else {
    {
#line 197
    efree((void *)v);
#line 198
    efree((void *)(vp + h)->name);
    }
#line 199
    if ((unsigned long )(vp + ((h + 1) & (vsize - 1)))->name == (unsigned long )((void *)0)) {
#line 200
      vused --;
#line 201
      (vp + h)->name = (char *)((void *)0);
    } else {
#line 203
      (vp + h)->name = dead___1;
    }
  }
#line 206
  return;
}
}
#line 208 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/hash.c"
static void free_fn(rc_Function *f ) 
{ 


  {
  {
#line 209
  treefree(f->def);
#line 210
  efree((void *)f->extdef);
  }
#line 211
  return;
}
}
#line 213 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/hash.c"
extern void initenv(char **envp ) 
{ 
  int n ;
  void *tmp ;
  int tmp___0 ;
  bool tmp___1 ;
  int tmp___2 ;

  {
#line 215
  n = 0;
  {
#line 215
  while (1) {
    while_continue: /* CIL Label */ ;
#line 215
    if (! ((unsigned long )*(envp + n) != (unsigned long )((void *)0))) {
#line 215
      goto while_break;
    }
#line 215
    n ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 217
  n ++;
#line 218
  if (n < 64) {
#line 219
    n = 64;
  }
  {
#line 220
  envsize = 2 * n;
#line 220
  tmp = ealloc((unsigned long )envsize * sizeof(char *));
#line 220
  env = (char **)tmp;
  }
  {
#line 221
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 221
    if (! ((unsigned long )*envp != (unsigned long )((void *)0))) {
#line 221
      goto while_break___0;
    }
    {
#line 222
    tmp___2 = strncmp((char const   *)*envp, "fn_", sizeof("fn_") - 1UL);
    }
#line 222
    if (tmp___2 == 0) {
#line 223
      if (! dashpee) {
        {
#line 224
        fnassign_string(*envp);
        }
      }
    } else {
      {
#line 226
      tmp___1 = varassign_string(*envp);
      }
#line 226
      if (! tmp___1) {
#line 227
        tmp___0 = bozosize;
#line 227
        bozosize ++;
#line 227
        *(env + tmp___0) = *envp;
      }
    }
#line 221
    envp ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 229
  return;
}
}
#line 231 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/hash.c"
static char *neverexport[10]  = 
#line 231
  {      (char *)"apid",      (char *)"apids",      (char *)"bqstatus",      (char *)"cdpath", 
        (char *)"home",      (char *)"ifs",      (char *)"path",      (char *)"pid", 
        (char *)"status",      (char *)"*"};
#line 243 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/hash.c"
static struct nameflag maybeexport[2]  = {      {(char *)"prompt", (bool )0}, 
        {(char *)"version", (bool )0}};
#line 248 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/hash.c"
void set_exportable(char *s___0 , bool b ) 
{ 
  int i ;
  int tmp ;

  {
#line 250
  i = 0;
  {
#line 250
  while (1) {
    while_continue: /* CIL Label */ ;
#line 250
    if (! (i < (int )(sizeof(maybeexport) / sizeof(maybeexport[0])))) {
#line 250
      goto while_break;
    }
#line 251
    if ((unsigned int )maybeexport[i].flag != (unsigned int )b) {
#line 251
      if ((int )*s___0 == (int )*(maybeexport[i].name)) {
        {
#line 251
        tmp = strcmp((char const   *)s___0, (char const   *)maybeexport[i].name);
        }
#line 251
        if (tmp == 0) {
#line 252
          maybeexport[i].flag = b;
        }
      }
    }
#line 250
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 253
  return;
}
}
#line 255 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/hash.c"
static bool var_exportable(char *s___0 ) 
{ 
  int i ;
  int tmp ;
  int tmp___0 ;

  {
#line 257
  i = 0;
  {
#line 257
  while (1) {
    while_continue: /* CIL Label */ ;
#line 257
    if (! (i < (int )(sizeof(neverexport) / sizeof(neverexport[0])))) {
#line 257
      goto while_break;
    }
#line 258
    if ((int )*s___0 == (int )*(neverexport[i])) {
      {
#line 258
      tmp = strcmp((char const   *)s___0, (char const   *)neverexport[i]);
      }
#line 258
      if (tmp == 0) {
#line 259
        return ((bool )0);
      }
    }
#line 257
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 260
  i = 0;
  {
#line 260
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 260
    if (! (i < (int )(sizeof(maybeexport) / sizeof(maybeexport[0])))) {
#line 260
      goto while_break___0;
    }
#line 261
    if ((unsigned int )maybeexport[i].flag == 0U) {
#line 261
      if ((int )*s___0 == (int )*(maybeexport[i].name)) {
        {
#line 261
        tmp___0 = strcmp((char const   *)s___0, (char const   *)maybeexport[i].name);
        }
#line 261
        if (tmp___0 == 0) {
#line 262
          return ((bool )0);
        }
      }
    }
#line 260
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 263
  return ((bool )1);
}
}
#line 266 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/hash.c"
static bool fn_exportable(char *s___0 ) 
{ 
  int i ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 268
  tmp___1 = strncmp((char const   *)s___0, "sig", sizeof("sig") - 1UL);
  }
#line 268
  if (tmp___1 == 0) {
#line 269
    i = 0;
    {
#line 269
    while (1) {
      while_continue: /* CIL Label */ ;
#line 269
      if (! (i < 65)) {
#line 269
        goto while_break;
      }
#line 270
      if ((int )*s___0 == (int )*(signals[i].name)) {
        {
#line 270
        tmp = strcmp((char const   *)s___0, (char const   *)signals[i].name);
        }
#line 270
        if (tmp == 0) {
#line 271
          return ((bool )0);
        }
      }
#line 269
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 272
    if ((int )*s___0 == (int )*"sigexit") {
      {
#line 272
      tmp___0 = strcmp((char const   *)s___0, "sigexit");
      }
#line 272
      if (tmp___0 == 0) {
#line 273
        return ((bool )0);
      }
    }
  }
#line 275
  return ((bool )1);
}
}
#line 278 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/hash.c"
extern char **makeenv(void) 
{ 
  int ep ;
  int i ;
  char *v ;
  void *tmp ;
  bool tmp___0 ;
  int tmp___1 ;
  bool tmp___2 ;
  int tmp___3 ;

  {
#line 281
  if (! env_dirty) {
#line 282
    return (env);
  }
#line 283
  env_dirty = (bool )0;
#line 284
  ep = bozosize;
#line 285
  if (((vsize + fsize) + 1) + bozosize > envsize) {
    {
#line 286
    envsize = 2 * (((bozosize + vsize) + fsize) + 1);
#line 287
    tmp = erealloc((void *)env, (unsigned long )envsize * sizeof(char *));
#line 287
    env = (char **)tmp;
    }
  }
#line 289
  i = 0;
  {
#line 289
  while (1) {
    while_continue: /* CIL Label */ ;
#line 289
    if (! (i < vsize)) {
#line 289
      goto while_break;
    }
#line 290
    if ((unsigned long )(vp + i)->name == (unsigned long )((void *)0)) {
#line 291
      goto __Cont;
    } else
#line 290
    if ((unsigned long )(vp + i)->name == (unsigned long )dead___1) {
#line 291
      goto __Cont;
    } else {
      {
#line 290
      tmp___0 = var_exportable((vp + i)->name);
      }
#line 290
      if (! tmp___0) {
#line 291
        goto __Cont;
      }
    }
    {
#line 292
    v = varlookup_string((vp + i)->name);
    }
#line 293
    if ((unsigned long )v != (unsigned long )((void *)0)) {
#line 294
      tmp___1 = ep;
#line 294
      ep ++;
#line 294
      *(env + tmp___1) = v;
    }
    __Cont: /* CIL Label */ 
#line 289
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 296
  i = 0;
  {
#line 296
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 296
    if (! (i < fsize)) {
#line 296
      goto while_break___0;
    }
#line 297
    if ((unsigned long )(fp + i)->name == (unsigned long )((void *)0)) {
#line 298
      goto __Cont___0;
    } else
#line 297
    if ((unsigned long )(fp + i)->name == (unsigned long )dead___1) {
#line 298
      goto __Cont___0;
    } else {
      {
#line 297
      tmp___2 = fn_exportable((fp + i)->name);
      }
#line 297
      if (! tmp___2) {
#line 298
        goto __Cont___0;
      }
    }
    {
#line 299
    tmp___3 = ep;
#line 299
    ep ++;
#line 299
    *(env + tmp___3) = fnlookup_string((fp + i)->name);
    }
    __Cont___0: /* CIL Label */ 
#line 296
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 301
  *(env + ep) = (char *)((void *)0);
#line 302
  qsort((void *)env, (size_t )ep, sizeof(char *), & starstrcmp);
  }
#line 303
  return (env);
}
}
#line 306 "/home/june/repo/benchmarks/collector/temp/rc-1.7.1/hash.c"
extern void whatare_all_vars(bool showfn , bool showvar ) 
{ 
  int i ;
  List *s___0 ;
  Node *tmp ;

  {
#line 309
  if (showvar) {
#line 310
    i = 0;
    {
#line 310
    while (1) {
      while_continue: /* CIL Label */ ;
#line 310
      if (! (i < vsize)) {
#line 310
        goto while_break;
      }
#line 311
      if ((unsigned long )(vp + i)->name != (unsigned long )((void *)0)) {
        {
#line 311
        s___0 = varlookup((vp + i)->name);
        }
#line 311
        if ((unsigned long )s___0 != (unsigned long )((void *)0)) {
          {
#line 312
          prettyprint_var(1, (vp + i)->name, s___0);
          }
        }
      }
#line 310
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 313
  if (showfn) {
#line 314
    i = 0;
    {
#line 314
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 314
      if (! (i < fsize)) {
#line 314
        goto while_break___0;
      }
#line 315
      if ((unsigned long )(fp + i)->name != (unsigned long )((void *)0)) {
#line 315
        if ((unsigned long )(fp + i)->name != (unsigned long )dead___1) {
          {
#line 316
          tmp = fnlookup((fp + i)->name);
#line 316
          prettyprint_fn(1, (fp + i)->name, tmp);
          }
        }
      }
#line 314
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 317
  return;
}
}
