/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 79 "/usr/include/stdio.h"
typedef __gnuc_va_list va_list;
#line 124 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 126 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 127 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 130 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 158 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 183 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef char *__caddr_t;
#line 116 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __caddr_t caddr_t;
#line 202 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef unsigned int u_int32_t;
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 85 "/usr/include/signal.h"
typedef void (*__sighandler_t)(int  );
#line 6 "/home/wheatley/newnew/temp/quota-4.01/quota.h"
typedef u_int32_t qid_t;
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 99 "/home/wheatley/newnew/temp/quota-4.01/quotaio.h"
struct util_dqstats {
   u_int32_t lookups ;
   u_int32_t drops ;
   u_int32_t reads ;
   u_int32_t writes ;
   u_int32_t cache_hits ;
   u_int32_t allocated_dquots ;
   u_int32_t free_dquots ;
   u_int32_t syncs ;
   u_int32_t version ;
};
#line 39 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v1.h"
struct v1_dqstats {
   u_int32_t lookups ;
   u_int32_t drops ;
   u_int32_t reads ;
   u_int32_t writes ;
   u_int32_t cache_hits ;
   u_int32_t allocated_dquots ;
   u_int32_t free_dquots ;
   u_int32_t syncs ;
};
#line 83 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v2.h"
struct v2_dqstats {
   u_int32_t lookups ;
   u_int32_t drops ;
   u_int32_t reads ;
   u_int32_t writes ;
   u_int32_t cache_hits ;
   u_int32_t allocated_dquots ;
   u_int32_t free_dquots ;
   u_int32_t syncs ;
   u_int32_t version ;
};
#line 128 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino64_t;
#line 181 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef __off64_t __loff_t;
#line 44 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __loff_t loff_t;
#line 50 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __ino64_t ino_t;
#line 60 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __dev_t dev_t;
#line 75 "/usr/include/time.h"
typedef __time_t time_t;
#line 152 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef unsigned int uint;
#line 197 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef long int64_t;
#line 19 "/usr/include/asm-generic/int-ll64.h"
typedef signed char __s8;
#line 23 "/usr/include/asm-generic/int-ll64.h"
typedef unsigned short __u16;
#line 25 "/usr/include/asm-generic/int-ll64.h"
typedef int __s32;
#line 26 "/usr/include/asm-generic/int-ll64.h"
typedef unsigned int __u32;
#line 30 "/usr/include/asm-generic/int-ll64.h"
typedef unsigned long long __u64;
#line 7 "/home/wheatley/newnew/temp/quota-4.01/quota.h"
typedef int64_t qsize_t;
#line 39 "/home/wheatley/newnew/temp/quota-4.01/quotasys.h"
struct mount_entry {
   char *me_type ;
   char *me_opts ;
   dev_t me_dev ;
   ino_t me_ino ;
   char const   *me_devname ;
   char const   *me__dir ;
   char const   *me_dir ;
   int me_qfmt[2] ;
};
#line 128
struct quota_handle;
#line 55 "/usr/include/stdint.h"
typedef unsigned long uint64_t;
#line 16 "/home/wheatley/newnew/temp/quota-4.01/dqblk_v1.h"
struct quotafile_ops;
#line 24 "/home/wheatley/newnew/temp/quota-4.01/quota_tree.h"
struct dquot;
#line 28 "/home/wheatley/newnew/temp/quota-4.01/quota_tree.h"
struct qtree_fmt_operations {
   void (*mem2disk_dqblk)(void *disk , struct dquot *dquot ) ;
   void (*disk2mem_dqblk)(struct dquot *dquot , void *disk ) ;
   int (*is_id)(void *disk , struct dquot *dquot ) ;
};
#line 35 "/home/wheatley/newnew/temp/quota-4.01/quota_tree.h"
struct qtree_mem_dqinfo {
   unsigned int dqi_blocks ;
   unsigned int dqi_free_blk ;
   unsigned int dqi_free_entry ;
   unsigned int dqi_entry_size ;
   struct qtree_fmt_operations *dqi_ops ;
};
#line 24 "/home/wheatley/newnew/temp/quota-4.01/dqblk_v2.h"
struct v2_mem_dqinfo {
   struct qtree_mem_dqinfo dqi_qtree ;
   uint dqi_flags ;
   uint dqi_used_entries ;
   uint dqi_data_blocks ;
};
#line 31 "/home/wheatley/newnew/temp/quota-4.01/dqblk_v2.h"
struct v2_mem_dqblk {
   loff_t dqb_off ;
};
#line 139 "/home/wheatley/newnew/temp/quota-4.01/quotaio_xfs.h"
struct fs_qfilestat {
   __u64 qfs_ino ;
   __u64 qfs_nblks ;
   __u32 qfs_nextents ;
};
#line 139 "/home/wheatley/newnew/temp/quota-4.01/quotaio_xfs.h"
typedef struct fs_qfilestat fs_qfilestat_t;
#line 145 "/home/wheatley/newnew/temp/quota-4.01/quotaio_xfs.h"
struct fs_quota_stat {
   __s8 qs_version ;
   __u16 qs_flags ;
   __s8 qs_pad ;
   fs_qfilestat_t qs_uquota ;
   fs_qfilestat_t qs_gquota ;
   __u32 qs_incoredqs ;
   __s32 qs_btimelimit ;
   __s32 qs_itimelimit ;
   __s32 qs_rtbtimelimit ;
   __u16 qs_bwarnlimit ;
   __u16 qs_iwarnlimit ;
};
#line 71 "/home/wheatley/newnew/temp/quota-4.01/quotaio.h"
union __anonunion_u_33 {
   struct v2_mem_dqinfo v2_mdqi ;
   struct fs_quota_stat xfs_mdqi ;
};
#line 71 "/home/wheatley/newnew/temp/quota-4.01/quotaio.h"
struct util_dqinfo {
   time_t dqi_bgrace ;
   time_t dqi_igrace ;
   uint64_t dqi_max_b_limit ;
   uint64_t dqi_max_i_limit ;
   uint64_t dqi_max_b_usage ;
   uint64_t dqi_max_i_usage ;
   union __anonunion_u_33 u ;
};
#line 85 "/home/wheatley/newnew/temp/quota-4.01/quotaio.h"
struct quota_handle {
   int qh_fd ;
   int qh_io_flags ;
   char qh_quotadev[4096] ;
   char qh_dir[4096] ;
   char qh_fstype[16] ;
   int qh_type ;
   int qh_fmt ;
   struct stat qh_stat ;
   struct quotafile_ops *qh_ops ;
   struct util_dqinfo qh_info ;
};
#line 112 "/home/wheatley/newnew/temp/quota-4.01/quotaio.h"
union __anonunion_u_34 {
   struct v2_mem_dqblk v2_mdqb ;
};
#line 112 "/home/wheatley/newnew/temp/quota-4.01/quotaio.h"
struct util_dqblk {
   qsize_t dqb_ihardlimit ;
   qsize_t dqb_isoftlimit ;
   qsize_t dqb_curinodes ;
   qsize_t dqb_bhardlimit ;
   qsize_t dqb_bsoftlimit ;
   qsize_t dqb_curspace ;
   time_t dqb_btime ;
   time_t dqb_itime ;
   union __anonunion_u_34 u ;
};
#line 130 "/home/wheatley/newnew/temp/quota-4.01/quotaio.h"
struct dquot {
   struct dquot *dq_next ;
   qid_t dq_id ;
   int dq_flags ;
   struct quota_handle *dq_h ;
   struct util_dqblk dq_dqb ;
};
#line 145 "/home/wheatley/newnew/temp/quota-4.01/quotaio.h"
struct quotafile_ops {
   int (*check_file)(int fd , int type , int fmt ) ;
   int (*init_io)(struct quota_handle *h ) ;
   int (*new_io)(struct quota_handle *h ) ;
   int (*end_io)(struct quota_handle *h ) ;
   int (*write_info)(struct quota_handle *h ) ;
   struct dquot *(*read_dquot)(struct quota_handle *h , qid_t id ) ;
   int (*commit_dquot)(struct dquot *dquot , int flag ) ;
   int (*scan_dquots)(struct quota_handle *h , int (*process_dquot)(struct dquot *dquot ,
                                                                    char *dqname ) ) ;
   int (*report)(struct quota_handle *h , int verbose ) ;
};
#line 201 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef unsigned short u_int16_t;
#line 22 "/usr/include/asm-generic/int-ll64.h"
typedef short __s16;
#line 58 "/home/wheatley/newnew/temp/quota-4.01/quotaio_xfs.h"
struct fs_disk_quota {
   __s8 d_version ;
   __s8 d_flags ;
   __u16 d_fieldmask ;
   __u32 d_id ;
   __u64 d_blk_hardlimit ;
   __u64 d_blk_softlimit ;
   __u64 d_ino_hardlimit ;
   __u64 d_ino_softlimit ;
   __u64 d_bcount ;
   __u64 d_icount ;
   __s32 d_itimer ;
   __s32 d_btimer ;
   __u16 d_iwarns ;
   __u16 d_bwarns ;
   __s32 d_padding2 ;
   __u64 d_rtb_hardlimit ;
   __u64 d_rtb_softlimit ;
   __u64 d_rtbcount ;
   __s32 d_rtbtimer ;
   __u16 d_rtbwarns ;
   __s16 d_padding3 ;
   char d_padding4[8] ;
};
#line 30 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned char __u_char;
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 102 "/usr/include/stdio.h"
typedef __ssize_t ssize_t;
#line 33 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __u_char u_char;
#line 31 "/home/wheatley/newnew/temp/quota-4.01/bylabel.c"
struct uuidCache_s {
   struct uuidCache_s *next ;
   char uuid[16] ;
   char *label ;
   char *device ;
};
#line 39 "/home/wheatley/newnew/temp/quota-4.01/bylabel.c"
struct ext2_super_block {
   u_char s_dummy1[56] ;
   u_char s_magic[2] ;
   u_char s_dummy2[46] ;
   u_char s_uuid[16] ;
   u_char s_volume_name[16] ;
};
#line 51 "/home/wheatley/newnew/temp/quota-4.01/bylabel.c"
struct xfs_super_block {
   u_char s_magic[4] ;
   u_char s_dummy[28] ;
   u_char s_uuid[16] ;
   u_char s_dummy2[60] ;
   u_char s_fsname[12] ;
};
#line 60 "/home/wheatley/newnew/temp/quota-4.01/bylabel.c"
struct reiserfs_super_block {
   u_char s_dummy1[52] ;
   u_char s_magic[10] ;
   u_char s_dummy2[22] ;
   u_char s_uuid[16] ;
   u_char s_volume_name[16] ;
};
#line 16 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v1.h"
struct v1_disk_dqblk {
   u_int32_t dqb_bhardlimit ;
   u_int32_t dqb_bsoftlimit ;
   u_int32_t dqb_curblocks ;
   u_int32_t dqb_ihardlimit ;
   u_int32_t dqb_isoftlimit ;
   u_int32_t dqb_curinodes ;
   time_t dqb_btime ;
   time_t dqb_itime ;
} __attribute__((__packed__)) ;
#line 28 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v1.h"
struct v1_kern_dqblk {
   u_int32_t dqb_bhardlimit ;
   u_int32_t dqb_bsoftlimit ;
   u_int32_t dqb_curblocks ;
   u_int32_t dqb_ihardlimit ;
   u_int32_t dqb_isoftlimit ;
   u_int32_t dqb_curinodes ;
   time_t dqb_btime ;
   time_t dqb_itime ;
};
#line 51 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 37 "/usr/include/rpc/types.h"
typedef int bool_t;
#line 38 "/usr/include/rpc/types.h"
typedef int enum_t;
#line 32 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __u_int;
#line 33 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __u_long;
#line 141 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds_t;
#line 35 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __u_int u_int;
#line 36 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __u_long u_long;
#line 196 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef int int32_t;
#line 30 "/usr/include/x86_64-linux-gnu/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 81 "/usr/include/rpc/xdr.h"
enum xdr_op {
    XDR_ENCODE = 0,
    XDR_DECODE = 1,
    XDR_FREE = 2
} ;
#line 109
struct XDR;
#line 109 "/usr/include/rpc/xdr.h"
typedef struct XDR XDR;
#line 110 "/usr/include/rpc/xdr.h"
struct xdr_ops {
   bool_t (*x_getlong)(XDR *__xdrs , long *__lp ) ;
   bool_t (*x_putlong)(XDR *__xdrs , long const   *__lp ) ;
   bool_t (*x_getbytes)(XDR *__xdrs , caddr_t __addr , u_int __len ) ;
   bool_t (*x_putbytes)(XDR *__xdrs , char const   *__addr , u_int __len ) ;
   u_int (*x_getpostn)(XDR const   *__xdrs ) ;
   bool_t (*x_setpostn)(XDR *__xdrs , u_int __pos ) ;
   int32_t *(*x_inline)(XDR *__xdrs , u_int __len ) ;
   void (*x_destroy)(XDR *__xdrs ) ;
   bool_t (*x_getint32)(XDR *__xdrs , int32_t *__ip ) ;
   bool_t (*x_putint32)(XDR *__xdrs , int32_t const   *__ip ) ;
};
#line 110 "/usr/include/rpc/xdr.h"
struct XDR {
   enum xdr_op x_op ;
   struct xdr_ops *x_ops ;
   caddr_t x_public ;
   caddr_t x_private ;
   caddr_t x_base ;
   u_int x_handy ;
};
#line 52 "/usr/include/rpc/auth.h"
enum auth_stat {
    AUTH_OK = 0,
    AUTH_BADCRED = 1,
    AUTH_REJECTEDCRED = 2,
    AUTH_BADVERF = 3,
    AUTH_REJECTEDVERF = 4,
    AUTH_TOOWEAK = 5,
    AUTH_INVALIDRESP = 6,
    AUTH_FAILED = 7
} ;
#line 69 "/usr/include/rpc/auth.h"
struct __anonstruct_key_60 {
   u_int32_t high ;
   u_int32_t low ;
};
#line 69 "/usr/include/rpc/auth.h"
union des_block {
   struct __anonstruct_key_60 key ;
   char c[8] ;
};
#line 82 "/usr/include/rpc/auth.h"
struct opaque_auth {
   enum_t oa_flavor ;
   caddr_t oa_base ;
   u_int oa_length ;
};
#line 91
struct AUTH;
#line 91 "/usr/include/rpc/auth.h"
typedef struct AUTH AUTH;
#line 92 "/usr/include/rpc/auth.h"
struct auth_ops {
   void (*ah_nextverf)(AUTH * ) ;
   int (*ah_marshal)(AUTH * , XDR * ) ;
   int (*ah_validate)(AUTH * , struct opaque_auth * ) ;
   int (*ah_refresh)(AUTH * ) ;
   void (*ah_destroy)(AUTH * ) ;
};
#line 92 "/usr/include/rpc/auth.h"
struct AUTH {
   struct opaque_auth ah_cred ;
   struct opaque_auth ah_verf ;
   union des_block ah_key ;
   struct auth_ops *ah_ops ;
   caddr_t ah_private ;
};
#line 50 "/usr/include/rpc/clnt.h"
enum clnt_stat {
    RPC_SUCCESS = 0,
    RPC_CANTENCODEARGS = 1,
    RPC_CANTDECODERES = 2,
    RPC_CANTSEND = 3,
    RPC_CANTRECV = 4,
    RPC_TIMEDOUT = 5,
    RPC_VERSMISMATCH = 6,
    RPC_AUTHERROR = 7,
    RPC_PROGUNAVAIL = 8,
    RPC_PROGVERSMISMATCH = 9,
    RPC_PROCUNAVAIL = 10,
    RPC_CANTDECODEARGS = 11,
    RPC_SYSTEMERROR = 12,
    RPC_NOBROADCAST = 21,
    RPC_UNKNOWNHOST = 13,
    RPC_UNKNOWNPROTO = 17,
    RPC_UNKNOWNADDR = 19,
    RPC_RPCBFAILURE = 14,
    RPC_PROGNOTREGISTERED = 15,
    RPC_N2AXLATEFAILURE = 22,
    RPC_FAILED = 16,
    RPC_INTR = 18,
    RPC_TLIERROR = 20,
    RPC_UDERROR = 23,
    RPC_INPROGRESS = 24,
    RPC_STALERACHANDLE = 25
} ;
#line 103 "/usr/include/rpc/clnt.h"
struct __anonstruct_RE_vers_62 {
   u_long low ;
   u_long high ;
};
#line 103 "/usr/include/rpc/clnt.h"
struct __anonstruct_RE_lb_63 {
   long s1 ;
   long s2 ;
};
#line 103 "/usr/include/rpc/clnt.h"
union __anonunion_ru_61 {
   int RE_errno ;
   enum auth_stat RE_why ;
   struct __anonstruct_RE_vers_62 RE_vers ;
   struct __anonstruct_RE_lb_63 RE_lb ;
};
#line 103 "/usr/include/rpc/clnt.h"
struct rpc_err {
   enum clnt_stat re_status ;
   union __anonunion_ru_61 ru ;
};
#line 129
struct CLIENT;
#line 129 "/usr/include/rpc/clnt.h"
typedef struct CLIENT CLIENT;
#line 130 "/usr/include/rpc/clnt.h"
struct clnt_ops {
   enum clnt_stat (*cl_call)(CLIENT * , u_long  , bool_t (*)(XDR * , void *  , ...) ,
                             caddr_t  , bool_t (*)(XDR * , void *  , ...) , caddr_t  ,
                             struct timeval  ) ;
   void (*cl_abort)(void) ;
   void (*cl_geterr)(CLIENT * , struct rpc_err * ) ;
   bool_t (*cl_freeres)(CLIENT * , bool_t (*)(XDR * , void *  , ...) , caddr_t  ) ;
   void (*cl_destroy)(CLIENT * ) ;
   bool_t (*cl_control)(CLIENT * , int  , char * ) ;
};
#line 130 "/usr/include/rpc/clnt.h"
struct CLIENT {
   AUTH *cl_auth ;
   struct clnt_ops *cl_ops ;
   caddr_t cl_private ;
};
#line 30 "/home/wheatley/newnew/temp/quota-4.01/rquota.h"
struct getquota_args {
   char *gqa_pathp ;
   int gqa_uid ;
};
#line 34 "/home/wheatley/newnew/temp/quota-4.01/rquota.h"
typedef struct getquota_args getquota_args;
#line 44 "/home/wheatley/newnew/temp/quota-4.01/rquota.h"
struct ext_getquota_args {
   char *gqa_pathp ;
   int gqa_type ;
   int gqa_id ;
};
#line 49 "/home/wheatley/newnew/temp/quota-4.01/rquota.h"
typedef struct ext_getquota_args ext_getquota_args;
#line 60 "/home/wheatley/newnew/temp/quota-4.01/rquota.h"
struct rquota {
   int rq_bsize ;
   bool_t rq_active ;
   u_int rq_bhardlimit ;
   u_int rq_bsoftlimit ;
   u_int rq_curblocks ;
   u_int rq_fhardlimit ;
   u_int rq_fsoftlimit ;
   u_int rq_curfiles ;
   u_int rq_btimeleft ;
   u_int rq_ftimeleft ;
};
#line 72 "/home/wheatley/newnew/temp/quota-4.01/rquota.h"
typedef struct rquota rquota;
#line 74
enum qr_status {
    Q_OK = 1,
    Q_NOQUOTA = 2,
    Q_EPERM = 3
} ;
#line 79 "/home/wheatley/newnew/temp/quota-4.01/rquota.h"
typedef enum qr_status qr_status;
#line 81 "/home/wheatley/newnew/temp/quota-4.01/rquota.h"
union __anonunion_getquota_rslt_u_73 {
   rquota gqr_rquota ;
};
#line 81 "/home/wheatley/newnew/temp/quota-4.01/rquota.h"
struct getquota_rslt {
   qr_status status ;
   union __anonunion_getquota_rslt_u_73 getquota_rslt_u ;
};
#line 87 "/home/wheatley/newnew/temp/quota-4.01/rquota.h"
typedef struct getquota_rslt getquota_rslt;
#line 143 "/home/wheatley/newnew/temp/quota-4.01/rquota_client.c"
union __anonunion_args_79 {
   getquota_args arg ;
   ext_getquota_args ext_arg ;
};
#line 18 "/home/wheatley/newnew/temp/quota-4.01/rquota.h"
struct sq_dqblk {
   u_int rq_bhardlimit ;
   u_int rq_bsoftlimit ;
   u_int rq_curblocks ;
   u_int rq_fhardlimit ;
   u_int rq_fsoftlimit ;
   u_int rq_curfiles ;
   u_int rq_btimeleft ;
   u_int rq_ftimeleft ;
};
#line 28 "/home/wheatley/newnew/temp/quota-4.01/rquota.h"
typedef struct sq_dqblk sq_dqblk;
#line 36 "/home/wheatley/newnew/temp/quota-4.01/rquota.h"
struct setquota_args {
   int sqa_qcmd ;
   char *sqa_pathp ;
   int sqa_id ;
   sq_dqblk sqa_dqblk ;
};
#line 42 "/home/wheatley/newnew/temp/quota-4.01/rquota.h"
typedef struct setquota_args setquota_args;
#line 51 "/home/wheatley/newnew/temp/quota-4.01/rquota.h"
struct ext_setquota_args {
   int sqa_qcmd ;
   char *sqa_pathp ;
   int sqa_id ;
   int sqa_type ;
   sq_dqblk sqa_dqblk ;
};
#line 58 "/home/wheatley/newnew/temp/quota-4.01/rquota.h"
typedef struct ext_setquota_args ext_setquota_args;
#line 89 "/home/wheatley/newnew/temp/quota-4.01/rquota.h"
union __anonunion_setquota_rslt_u_73 {
   rquota sqr_rquota ;
};
#line 89 "/home/wheatley/newnew/temp/quota-4.01/rquota.h"
struct setquota_rslt {
   qr_status status ;
   union __anonunion_setquota_rslt_u_73 setquota_rslt_u ;
};
#line 95 "/home/wheatley/newnew/temp/quota-4.01/rquota.h"
typedef struct setquota_rslt setquota_rslt;
#line 133 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 134 "/usr/include/x86_64-linux-gnu/bits/types.h"
struct __anonstruct___fsid_t_1 {
   int __val[2] ;
};
#line 134 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef struct __anonstruct___fsid_t_1 __fsid_t;
#line 135 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __clock_t;
#line 163 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __fsblkcnt64_t;
#line 167 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __fsfilcnt64_t;
#line 170 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __fsword_t;
#line 38 "/usr/include/pwd.h"
typedef __gid_t gid_t;
#line 43 "/usr/include/pwd.h"
typedef __uid_t uid_t;
#line 49 "/usr/include/pwd.h"
struct passwd {
   char *pw_name ;
   char *pw_passwd ;
   __uid_t pw_uid ;
   __gid_t pw_gid ;
   char *pw_gecos ;
   char *pw_dir ;
   char *pw_shell ;
};
#line 42 "/usr/include/grp.h"
struct group {
   char *gr_name ;
   char *gr_passwd ;
   __gid_t gr_gid ;
   char **gr_mem ;
};
#line 203 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef unsigned long u_int64_t;
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigset.h"
struct __anonstruct___sigset_t_14 {
   unsigned long __val[1024UL / (8UL * sizeof(unsigned long ))] ;
};
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigset.h"
typedef struct __anonstruct___sigset_t_14 __sigset_t;
#line 37 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef __sigset_t sigset_t;
#line 32 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
union sigval {
   int sival_int ;
   void *sival_ptr ;
};
#line 32 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
typedef union sigval sigval_t;
#line 58 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
typedef __clock_t __sigchld_clock_t;
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__kill_31 {
   __pid_t si_pid ;
   __uid_t si_uid ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__timer_32 {
   int si_tid ;
   int si_overrun ;
   sigval_t si_sigval ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__rt_33 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   sigval_t si_sigval ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigchld_34 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   int si_status ;
   __sigchld_clock_t si_utime ;
   __sigchld_clock_t si_stime ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigfault_35 {
   void *si_addr ;
   short si_addr_lsb ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigpoll_36 {
   long si_band ;
   int si_fd ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigsys_37 {
   void *_call_addr ;
   int _syscall ;
   unsigned int _arch ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
union __anonunion__sifields_30 {
   int _pad[128UL / sizeof(int ) - 4UL] ;
   struct __anonstruct__kill_31 _kill ;
   struct __anonstruct__timer_32 _timer ;
   struct __anonstruct__rt_33 _rt ;
   struct __anonstruct__sigchld_34 _sigchld ;
   struct __anonstruct__sigfault_35 _sigfault ;
   struct __anonstruct__sigpoll_36 _sigpoll ;
   struct __anonstruct__sigsys_37 _sigsys ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct_siginfo_t_29 {
   int si_signo ;
   int si_errno ;
   int si_code ;
   union __anonunion__sifields_30 _sifields ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
typedef struct __anonstruct_siginfo_t_29 siginfo_t;
#line 24 "/usr/include/x86_64-linux-gnu/bits/sigaction.h"
union __anonunion___sigaction_handler_49 {
   void (*sa_handler)(int  ) ;
   void (*sa_sigaction)(int  , siginfo_t * , void * ) ;
};
#line 24 "/usr/include/x86_64-linux-gnu/bits/sigaction.h"
struct sigaction {
   union __anonunion___sigaction_handler_49 __sigaction_handler ;
   __sigset_t sa_mask ;
   int sa_flags ;
   void (*sa_restorer)(void) ;
};
#line 24 "/usr/include/x86_64-linux-gnu/bits/statfs.h"
struct statfs {
   __fsword_t f_type ;
   __fsword_t f_bsize ;
   __fsblkcnt64_t f_blocks ;
   __fsblkcnt64_t f_bfree ;
   __fsblkcnt64_t f_bavail ;
   __fsfilcnt64_t f_files ;
   __fsfilcnt64_t f_ffree ;
   __fsid_t f_fsid ;
   __fsword_t f_namelen ;
   __fsword_t f_frsize ;
   __fsword_t f_flags ;
   __fsword_t f_spare[4] ;
};
#line 53 "/usr/include/mntent.h"
struct mntent {
   char *mnt_fsname ;
   char *mnt_dir ;
   char *mnt_type ;
   char *mnt_opts ;
   int mnt_freq ;
   int mnt_passno ;
};
#line 102 "/home/wheatley/newnew/temp/quota-4.01/quota.h"
struct if_dqinfo {
   u_int64_t dqi_bgrace ;
   u_int64_t dqi_igrace ;
   u_int32_t dqi_flags ;
   u_int32_t dqi_valid ;
};
#line 145 "/home/wheatley/newnew/temp/quota-4.01/quotaio_xfs.h"
typedef struct fs_quota_stat fs_quota_stat_t;
#line 912 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
struct searched_dir {
   int sd_dir ;
   dev_t sd_dev ;
   ino_t sd_ino ;
   char const   *sd_name ;
};
#line 16 "/home/wheatley/newnew/temp/quota-4.01/quota_tree.h"
struct qt_disk_dqdbheader {
   u_int32_t dqdh_next_free ;
   u_int32_t dqdh_prev_free ;
   u_int16_t dqdh_entries ;
   u_int16_t dqdh_pad1 ;
   u_int32_t dqdh_pad2 ;
} __attribute__((__packed__)) ;
#line 24 "/home/wheatley/newnew/temp/quota-4.01/quotaio_tree.c"
typedef char *dqbuf_t;
#line 79 "/home/wheatley/newnew/temp/quota-4.01/quota.h"
struct if_dqblk {
   u_int64_t dqb_bhardlimit ;
   u_int64_t dqb_bsoftlimit ;
   u_int64_t dqb_curspace ;
   u_int64_t dqb_ihardlimit ;
   u_int64_t dqb_isoftlimit ;
   u_int64_t dqb_curinodes ;
   u_int64_t dqb_btime ;
   u_int64_t dqb_itime ;
   u_int32_t dqb_valid ;
};
#line 41 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uint32_t;
#line 44 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __uint64_t;
#line 37 "/home/wheatley/newnew/temp/quota-4.01/quot.h"
struct __anonstruct_idcache_t_55 {
   __uint32_t id ;
   char name[33] ;
};
#line 37 "/home/wheatley/newnew/temp/quota-4.01/quot.h"
typedef struct __anonstruct_idcache_t_55 idcache_t;
#line 42 "/home/wheatley/newnew/temp/quota-4.01/quot.h"
struct du {
   struct du *next ;
   __uint64_t blocks ;
   __uint64_t blocks30 ;
   __uint64_t blocks60 ;
   __uint64_t blocks90 ;
   __uint64_t nfiles ;
   __uint32_t id ;
};
#line 42 "/home/wheatley/newnew/temp/quota-4.01/quot.h"
typedef struct du du_t;
#line 29 "/usr/include/asm-generic/int-ll64.h"
typedef long long __s64;
#line 67 "/home/wheatley/newnew/temp/quota-4.01/quot.h"
struct xfs_bstime {
   time_t tv_sec ;
   __s32 tv_nsec ;
};
#line 67 "/home/wheatley/newnew/temp/quota-4.01/quot.h"
typedef struct xfs_bstime xfs_bstime_t;
#line 72 "/home/wheatley/newnew/temp/quota-4.01/quot.h"
struct xfs_bstat {
   __u64 bs_ino ;
   __u16 bs_mode ;
   __u16 bs_nlink ;
   __u32 bs_uid ;
   __u32 bs_gid ;
   __u32 bs_rdev ;
   __s32 bs_blksize ;
   __s64 bs_size ;
   xfs_bstime_t bs_atime ;
   xfs_bstime_t bs_mtime ;
   xfs_bstime_t bs_ctime ;
   int64_t bs_blocks ;
   __u32 bs_xflags ;
   __s32 bs_extsize ;
   __s32 bs_extents ;
   __u32 bs_gen ;
   __u16 bs_projid ;
   unsigned char bs_pad[14] ;
   __u32 bs_dmevmask ;
   __u16 bs_dmstate ;
   __u16 bs_aextents ;
};
#line 72 "/home/wheatley/newnew/temp/quota-4.01/quot.h"
typedef struct xfs_bstat xfs_bstat_t;
#line 97 "/home/wheatley/newnew/temp/quota-4.01/quot.h"
struct xfs_fsop_bulkreq {
   __u64 *lastip ;
   __s32 icount ;
   void *ubuffer ;
   __s32 *ocount ;
};
#line 97 "/home/wheatley/newnew/temp/quota-4.01/quot.h"
typedef struct xfs_fsop_bulkreq xfs_fsop_bulkreq_t;
#line 31 "/usr/include/linux/types.h"
typedef __u64 __le64;
#line 16 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v2.h"
struct v2_disk_dqheader {
   u_int32_t dqh_magic ;
   u_int32_t dqh_version ;
} __attribute__((__packed__)) ;
#line 25 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v2.h"
struct v2_disk_dqinfo {
   u_int32_t dqi_bgrace ;
   u_int32_t dqi_igrace ;
   u_int32_t dqi_flags ;
   u_int32_t dqi_blocks ;
   u_int32_t dqi_free_blk ;
   u_int32_t dqi_free_entry ;
} __attribute__((__packed__)) ;
#line 35 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v2.h"
struct v2r0_disk_dqblk {
   u_int32_t dqb_id ;
   u_int32_t dqb_ihardlimit ;
   u_int32_t dqb_isoftlimit ;
   u_int32_t dqb_curinodes ;
   u_int32_t dqb_bhardlimit ;
   u_int32_t dqb_bsoftlimit ;
   u_int64_t dqb_curspace ;
   u_int64_t dqb_btime ;
   u_int64_t dqb_itime ;
} __attribute__((__packed__)) ;
#line 47 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v2.h"
struct v2r1_disk_dqblk {
   u_int32_t dqb_id ;
   u_int32_t dqb_pad ;
   u_int64_t dqb_ihardlimit ;
   u_int64_t dqb_isoftlimit ;
   u_int64_t dqb_curinodes ;
   u_int64_t dqb_bhardlimit ;
   u_int64_t dqb_bsoftlimit ;
   u_int64_t dqb_curspace ;
   u_int64_t dqb_btime ;
   u_int64_t dqb_itime ;
} __attribute__((__packed__)) ;
#line 61 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v2.h"
struct v2_kern_dqblk {
   unsigned int dqb_ihardlimit ;
   unsigned int dqb_isoftlimit ;
   unsigned int dqb_curinodes ;
   unsigned int dqb_bhardlimit ;
   unsigned int dqb_bsoftlimit ;
   qsize_t dqb_curspace ;
   time_t dqb_btime ;
   time_t dqb_itime ;
};
#line 73 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v2.h"
struct v2_kern_dqinfo {
   unsigned int dqi_bgrace ;
   unsigned int dqi_igrace ;
   unsigned int dqi_flags ;
   unsigned int dqi_blocks ;
   unsigned int dqi_free_blk ;
   unsigned int dqi_free_entry ;
};
#line 104 "/usr/include/getopt.h"
struct option {
   char const   *name ;
   int has_arg ;
   int *flag ;
   int val ;
};
#line 143 "/home/wheatley/newnew/temp/quota-4.01/rquota_client.c"
union __anonunion_args_79___0 {
   getquota_args arg ;
   ext_getquota_args ext_arg ;
};
#line 98 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __pid_t pid_t;
#line 143 "/home/wheatley/newnew/temp/quota-4.01/rquota_client.c"
union __anonunion_args_79___1 {
   getquota_args arg ;
   ext_getquota_args ext_arg ;
};
#line 66 "/usr/include/x86_64-linux-gnu/bits/waitstatus.h"
struct __anonstruct___wait_terminated_23 {
   unsigned int __w_termsig : 7 ;
   unsigned int __w_coredump : 1 ;
   unsigned int __w_retcode : 8 ;
   unsigned int  : 16 ;
};
#line 66 "/usr/include/x86_64-linux-gnu/bits/waitstatus.h"
struct __anonstruct___wait_stopped_24 {
   unsigned int __w_stopval : 8 ;
   unsigned int __w_stopsig : 8 ;
   unsigned int  : 16 ;
};
#line 66 "/usr/include/x86_64-linux-gnu/bits/waitstatus.h"
union wait {
   int w_status ;
   struct __anonstruct___wait_terminated_23 __wait_terminated ;
   struct __anonstruct___wait_stopped_24 __wait_stopped ;
};
#line 48 "/usr/include/x86_64-linux-gnu/sys/utsname.h"
struct utsname {
   char sysname[65] ;
   char nodename[65] ;
   char release[65] ;
   char version[65] ;
   char machine[65] ;
   char domainname[65] ;
};
#line 88 "/home/wheatley/newnew/temp/quota-4.01/warnquota.c"
struct usage {
   char *devicename ;
   struct util_dqblk dq_dqb ;
   struct usage *next ;
};
#line 98 "/home/wheatley/newnew/temp/quota-4.01/warnquota.c"
struct configparams {
   char mail_cmd[2048] ;
   char from[2048] ;
   char subject[2048] ;
   char cc_to[2048] ;
   char support[2048] ;
   char phone[2048] ;
   char charset[2048] ;
   char *user_message ;
   char *user_signature ;
   char *group_message ;
   char *group_signature ;
   int use_ldap_mail ;
   time_t cc_before ;
};
#line 126 "/home/wheatley/newnew/temp/quota-4.01/warnquota.c"
struct offenderlist {
   int offender_type ;
   int offender_id ;
   char *offender_name ;
   struct usage *usage ;
   struct offenderlist *next ;
};
#line 134 "/home/wheatley/newnew/temp/quota-4.01/warnquota.c"
struct quotatable {
   char *devname ;
   char *devdesc ;
};
#line 134 "/home/wheatley/newnew/temp/quota-4.01/warnquota.c"
typedef struct quotatable quotatable_t;
#line 139 "/home/wheatley/newnew/temp/quota-4.01/warnquota.c"
struct adminstable {
   char *grpname ;
   char *adminname ;
};
#line 576 "/home/wheatley/newnew/temp/quota-4.01/warnquota.c"
union __anonunion_59 {
   int __in ;
   int __i ;
};
#line 576 "/home/wheatley/newnew/temp/quota-4.01/warnquota.c"
union __anonunion_60 {
   int __in ;
   int __i ;
};
#line 143 "/home/wheatley/newnew/temp/quota-4.01/rquota_client.c"
union __anonunion_args_79___2 {
   getquota_args arg ;
   ext_getquota_args ext_arg ;
};
#line 40 "/usr/include/rpc/types.h"
typedef unsigned long rpcprog_t;
#line 41 "/usr/include/rpc/types.h"
typedef unsigned long rpcvers_t;
#line 42 "/usr/include/rpc/types.h"
typedef unsigned long rpcproc_t;
#line 31 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned short __u_short;
#line 34 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __u_short u_short;
#line 49 "/usr/include/stdint.h"
typedef unsigned short uint16_t;
#line 28 "/usr/include/x86_64-linux-gnu/bits/sockaddr.h"
typedef unsigned short sa_family_t;
#line 149 "/usr/include/x86_64-linux-gnu/bits/socket.h"
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14] ;
};
#line 90 "/usr/include/x86_64-linux-gnu/sys/socket.h"
struct sockaddr_in;
#line 30 "/usr/include/netinet/in.h"
typedef uint32_t in_addr_t;
#line 31 "/usr/include/netinet/in.h"
struct in_addr {
   in_addr_t s_addr ;
};
#line 117 "/usr/include/netinet/in.h"
typedef uint16_t in_port_t;
#line 237 "/usr/include/netinet/in.h"
struct sockaddr_in {
   sa_family_t sin_family ;
   in_port_t sin_port ;
   struct in_addr sin_addr ;
   unsigned char sin_zero[((sizeof(struct sockaddr ) - sizeof(unsigned short )) - sizeof(in_port_t )) - sizeof(struct in_addr )] ;
};
#line 54 "/usr/include/rpc/rpc_msg.h"
enum msg_type {
    CALL = 0,
    REPLY = 1
} ;
#line 59
enum reply_stat {
    MSG_ACCEPTED = 0,
    MSG_DENIED = 1
} ;
#line 64
enum accept_stat {
    SUCCESS = 0,
    PROG_UNAVAIL = 1,
    PROG_MISMATCH = 2,
    PROC_UNAVAIL = 3,
    GARBAGE_ARGS = 4,
    SYSTEM_ERR = 5
} ;
#line 73
enum reject_stat {
    RPC_MISMATCH = 0,
    AUTH_ERROR = 1
} ;
#line 87 "/usr/include/rpc/rpc_msg.h"
struct __anonstruct_AR_versions_65 {
   u_long low ;
   u_long high ;
};
#line 87 "/usr/include/rpc/rpc_msg.h"
struct __anonstruct_AR_results_66 {
   caddr_t where ;
   bool_t (*proc)(XDR * , void *  , ...) ;
};
#line 87 "/usr/include/rpc/rpc_msg.h"
union __anonunion_ru_64 {
   struct __anonstruct_AR_versions_65 AR_versions ;
   struct __anonstruct_AR_results_66 AR_results ;
};
#line 87 "/usr/include/rpc/rpc_msg.h"
struct accepted_reply {
   struct opaque_auth ar_verf ;
   enum accept_stat ar_stat ;
   union __anonunion_ru_64 ru ;
};
#line 108 "/usr/include/rpc/rpc_msg.h"
struct __anonstruct_RJ_versions_68 {
   u_long low ;
   u_long high ;
};
#line 108 "/usr/include/rpc/rpc_msg.h"
union __anonunion_ru_67 {
   struct __anonstruct_RJ_versions_68 RJ_versions ;
   enum auth_stat RJ_why ;
};
#line 108 "/usr/include/rpc/rpc_msg.h"
struct rejected_reply {
   enum reject_stat rj_stat ;
   union __anonunion_ru_67 ru ;
};
#line 124 "/usr/include/rpc/rpc_msg.h"
union __anonunion_ru_69 {
   struct accepted_reply RP_ar ;
   struct rejected_reply RP_dr ;
};
#line 124 "/usr/include/rpc/rpc_msg.h"
struct reply_body {
   enum reply_stat rp_stat ;
   union __anonunion_ru_69 ru ;
};
#line 137 "/usr/include/rpc/rpc_msg.h"
struct call_body {
   u_long cb_rpcvers ;
   u_long cb_prog ;
   u_long cb_vers ;
   u_long cb_proc ;
   struct opaque_auth cb_cred ;
   struct opaque_auth cb_verf ;
};
#line 149 "/usr/include/rpc/rpc_msg.h"
union __anonunion_ru_70 {
   struct call_body RM_cmb ;
   struct reply_body RM_rmb ;
};
#line 149 "/usr/include/rpc/rpc_msg.h"
struct rpc_msg {
   u_long rm_xid ;
   enum msg_type rm_direction ;
   union __anonunion_ru_70 ru ;
};
#line 61 "/usr/include/rpc/auth_unix.h"
struct authunix_parms {
   u_long aup_time ;
   char *aup_machname ;
   __uid_t aup_uid ;
   __gid_t aup_gid ;
   u_int aup_len ;
   __gid_t *aup_gids ;
};
#line 81 "/usr/include/rpc/svc.h"
enum xprt_stat {
    XPRT_DIED = 0,
    XPRT_MOREREQS = 1,
    XPRT_IDLE = 2
} ;
#line 90
struct SVCXPRT;
#line 90 "/usr/include/rpc/svc.h"
typedef struct SVCXPRT SVCXPRT;
#line 91 "/usr/include/rpc/svc.h"
struct xp_ops {
   bool_t (*xp_recv)(SVCXPRT *__xprt , struct rpc_msg *__msg ) ;
   enum xprt_stat (*xp_stat)(SVCXPRT *__xprt ) ;
   bool_t (*xp_getargs)(SVCXPRT *__xprt , bool_t (*__xdr_args)(XDR * , void *  , ...) ,
                        caddr_t __args_ptr ) ;
   bool_t (*xp_reply)(SVCXPRT *__xprt , struct rpc_msg *__msg ) ;
   bool_t (*xp_freeargs)(SVCXPRT *__xprt , bool_t (*__xdr_args)(XDR * , void *  , ...) ,
                         caddr_t __args_ptr ) ;
   void (*xp_destroy)(SVCXPRT *__xprt ) ;
};
#line 91 "/usr/include/rpc/svc.h"
struct SVCXPRT {
   int xp_sock ;
   u_short xp_port ;
   struct xp_ops  const  *xp_ops ;
   int xp_addrlen ;
   struct sockaddr_in xp_raddr ;
   struct opaque_auth xp_verf ;
   caddr_t xp_p1 ;
   caddr_t xp_p2 ;
   char xp_pad[256] ;
};
#line 164 "/usr/include/rpc/svc.h"
struct svc_req {
   rpcprog_t rq_prog ;
   rpcvers_t rq_vers ;
   rpcproc_t rq_proc ;
   struct opaque_auth rq_cred ;
   caddr_t rq_clntcred ;
   SVCXPRT *rq_xprt ;
};
#line 237 "/home/wheatley/newnew/temp/quota-4.01/rquota_server.c"
union __anonunion_arguments_78 {
   getquota_args *args ;
   ext_getquota_args *ext_args ;
};
#line 143 "/home/wheatley/newnew/temp/quota-4.01/rquota_client.c"
union __anonunion_args_79___3 {
   getquota_args arg ;
   ext_getquota_args ext_arg ;
};
#line 189 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __socklen_t;
#line 274 "/usr/include/unistd.h"
typedef __socklen_t socklen_t;
#line 46 "/usr/include/rpc/netdb.h"
struct rpcent {
   char *r_name ;
   char **r_aliases ;
   int r_number ;
};
#line 257 "/usr/include/netdb.h"
struct servent {
   char *s_name ;
   char **s_aliases ;
   int s_port ;
   char *s_proto ;
};
#line 43 "/usr/include/rpc/types.h"
typedef unsigned long rpcprot_t;
#line 150 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef unsigned long ulong;
#line 215 "/home/wheatley/newnew/temp/quota-4.01/rquota_svc.c"
union __anonunion_argument_79 {
   getquota_args rquotaproc_getquota_1_arg ;
   setquota_args rquotaproc_setquota_1_arg ;
   getquota_args rquotaproc_getactivequota_1_arg ;
   setquota_args rquotaproc_setactivequota_1_arg ;
};
#line 301 "/home/wheatley/newnew/temp/quota-4.01/rquota_svc.c"
union __anonunion_argument_80 {
   ext_getquota_args rquotaproc_getquota_2_arg ;
   ext_setquota_args rquotaproc_setquota_2_arg ;
   ext_getquota_args rquotaproc_getactivequota_2_arg ;
   ext_setquota_args rquotaproc_setactivequota_2_arg ;
};
#line 143 "/home/wheatley/newnew/temp/quota-4.01/rquota_client.c"
union __anonunion_args_79___4 {
   getquota_args arg ;
   ext_getquota_args ext_arg ;
};
#line 143 "/home/wheatley/newnew/temp/quota-4.01/rquota_client.c"
union __anonunion_args_79___5 {
   getquota_args arg ;
   ext_getquota_args ext_arg ;
};
#line 143 "/home/wheatley/newnew/temp/quota-4.01/rquota_client.c"
union __anonunion_args_79___6 {
   getquota_args arg ;
   ext_getquota_args ext_arg ;
};
#line 92 "/usr/include/stdio.h"
typedef __off64_t off_t;
#line 22 "/usr/include/x86_64-linux-gnu/bits/dirent.h"
struct dirent {
   __ino64_t d_ino ;
   __off64_t d_off ;
   unsigned short d_reclen ;
   unsigned char d_type ;
   char d_name[256] ;
};
#line 127 "/usr/include/dirent.h"
struct __dirstream;
#line 127 "/usr/include/dirent.h"
typedef struct __dirstream DIR;
#line 70 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __mode_t mode_t;
#line 75 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __nlink_t nlink_t;
#line 52 "/home/wheatley/newnew/temp/quota-4.01/quotacheck.c"
struct dlinks {
   ino_t i_num ;
   struct dlinks *next ;
};
#line 57 "/home/wheatley/newnew/temp/quota-4.01/quotacheck.c"
struct dirs {
   char *dir_name ;
   struct dirs *next ;
};
#line 143 "/home/wheatley/newnew/temp/quota-4.01/rquota_client.c"
union __anonunion_args_79___7 {
   getquota_args arg ;
   ext_getquota_args ext_arg ;
};
#line 32 "/usr/include/linux/types.h"
typedef __u64 __be64;
#line 143 "/home/wheatley/newnew/temp/quota-4.01/rquota_client.c"
union __anonunion_args_79___8 {
   getquota_args arg ;
   ext_getquota_args ext_arg ;
};
#line 143 "/home/wheatley/newnew/temp/quota-4.01/rquota_client.c"
union __anonunion_args_79___9 {
   getquota_args arg ;
   ext_getquota_args ext_arg ;
};
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 362
extern int printf(char const   * __restrict  __format  , ...) ;
#line 371
extern int vfprintf(FILE * __restrict  __s , char const   * __restrict  __format ,
                    __gnuc_va_list __arg ) ;
#line 390
extern  __attribute__((__nothrow__)) int ( /* format attribute */  vsnprintf)(char * __restrict  __s ,
                                                                              size_t __maxlen ,
                                                                              char const   * __restrict  __format ,
                                                                              __gnuc_va_list __arg ) ;
#line 689
extern int fputs(char const   * __restrict  __s , FILE * __restrict  __stream ) ;
#line 695
extern int puts(char const   *__s ) ;
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 480
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 132 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 140
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncat)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 176
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 181 "/usr/include/x86_64-linux-gnu/sys/syslog.h"
extern void openlog(char const   *__ident , int __option , int __facility ) ;
#line 190
extern void ( /* format attribute */  syslog)(int __pri , char const   *__fmt  , ...) ;
#line 39 "/usr/include/libintl.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) gettext)(char const   *__msgid )  __attribute__((__format_arg__(1))) ;
#line 19 "/home/wheatley/newnew/temp/quota-4.01/common.h"
char *progname ;
#line 22
 __attribute__((__noreturn__)) void ( /* format attribute */  die)(int ret , char *fmtstr 
                                                                   , ...) ;
#line 25
void ( /* format attribute */  errstr)(char *fmtstr  , ...) ;
#line 29
void use_syslog(void) ;
#line 32
void *smalloc(size_t size ) ;
#line 35
void *srealloc(void *ptr , size_t size ) ;
#line 38
void sstrncpy(char *d , char const   *s , size_t len ) ;
#line 41
void sstrncat(char *d , char const   *s , size_t len ) ;
#line 44
char *sstrdup(char const   *s ) ;
#line 47
void version(void) ;
#line 23 "/home/wheatley/newnew/temp/quota-4.01/common.c"
static int enable_syslog  =    0;
#line 25 "/home/wheatley/newnew/temp/quota-4.01/common.c"
void use_syslog(void) 
{ 


  {
  {
#line 27
  openlog((char const   *)progname, 0, 3 << 3);
#line 28
  enable_syslog = 1;
  }
#line 29
  return;
}
}
#line 31 "/home/wheatley/newnew/temp/quota-4.01/common.c"
static void do_syslog(int level , char const   *format , va_list args ) 
{ 
  char buf[1024] ;
  int i ;
  int j ;
  int tmp ;

  {
  {
#line 36
  vsnprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)format,
            args);
#line 39
  i = 0;
  }
  {
#line 39
  while (1) {
    while_continue: /* CIL Label */ ;
#line 39
    if (! buf[i]) {
#line 39
      goto while_break;
    }
#line 40
    j = i;
    {
#line 40
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 40
      if (buf[j]) {
#line 40
        if (! ((int )buf[j] != 10)) {
#line 40
          goto while_break___0;
        }
      } else {
#line 40
        goto while_break___0;
      }
#line 40
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 41
    if ((int )buf[j] == 10) {
#line 42
      tmp = j;
#line 42
      j ++;
#line 42
      buf[tmp] = (char )'\000';
    }
    {
#line 43
    syslog(level, "%s", buf + i);
#line 39
    i = j;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 45
  return;
}
}
#line 47
 __attribute__((__noreturn__)) void ( /* format attribute */  die)(int ret , char *fmtstr 
                                                                   , ...) ;
#line 47 "/home/wheatley/newnew/temp/quota-4.01/common.c"
void ( /* format attribute */  die)(int ret , char *fmtstr  , ...) 
{ 
  va_list args ;

  {
  {
#line 51
  __builtin_va_start(args, fmtstr);
  }
#line 52
  if (enable_syslog) {
    {
#line 53
    do_syslog(2, (char const   *)fmtstr, args);
#line 54
    syslog(2, "Exiting with status %d", ret);
    }
  } else {
    {
#line 56
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: ",
            progname);
#line 57
    vfprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)fmtstr,
             args);
    }
  }
  {
#line 59
  __builtin_va_end(args);
#line 60
  exit(ret);
  }
}
}
#line 63 "/home/wheatley/newnew/temp/quota-4.01/common.c"
void ( /* format attribute */  errstr)(char *fmtstr  , ...) 
{ 
  va_list args ;

  {
  {
#line 67
  __builtin_va_start(args, fmtstr);
  }
#line 68
  if (enable_syslog) {
    {
#line 69
    do_syslog(3, (char const   *)fmtstr, args);
    }
  } else {
    {
#line 71
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: ",
            progname);
#line 72
    vfprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)fmtstr,
             args);
    }
  }
  {
#line 74
  __builtin_va_end(args);
  }
#line 75
  return;
}
}
#line 77 "/home/wheatley/newnew/temp/quota-4.01/common.c"
void *smalloc(size_t size ) 
{ 
  void *ret ;
  void *tmp ;

  {
  {
#line 79
  tmp = malloc(size);
#line 79
  ret = tmp;
  }
#line 81
  if (! ret) {
    {
#line 82
    fputs((char const   */* __restrict  */)"Not enough memory.\n", (FILE */* __restrict  */)stderr);
#line 83
    exit(3);
    }
  }
#line 85
  return (ret);
}
}
#line 88 "/home/wheatley/newnew/temp/quota-4.01/common.c"
void *srealloc(void *ptr , size_t size ) 
{ 
  void *ret ;
  void *tmp ;

  {
  {
#line 90
  tmp = realloc(ptr, size);
#line 90
  ret = tmp;
  }
#line 92
  if (! ret) {
    {
#line 93
    fputs((char const   */* __restrict  */)"Not enough memory.\n", (FILE */* __restrict  */)stderr);
#line 94
    exit(3);
    }
  }
#line 96
  return (ret);
}
}
#line 99 "/home/wheatley/newnew/temp/quota-4.01/common.c"
void sstrncpy(char *d , char const   *s , size_t len ) 
{ 


  {
  {
#line 101
  strncpy((char */* __restrict  */)d, (char const   */* __restrict  */)s, len);
#line 102
  *(d + (len - 1UL)) = (char)0;
  }
#line 103
  return;
}
}
#line 105 "/home/wheatley/newnew/temp/quota-4.01/common.c"
void sstrncat(char *d , char const   *s , size_t len ) 
{ 


  {
  {
#line 107
  strncat((char */* __restrict  */)d, (char const   */* __restrict  */)s, len);
#line 108
  *(d + (len - 1UL)) = (char)0;
  }
#line 109
  return;
}
}
#line 111 "/home/wheatley/newnew/temp/quota-4.01/common.c"
char *sstrdup(char const   *s ) 
{ 
  char *r ;
  char *tmp ;

  {
  {
#line 113
  tmp = strdup(s);
#line 113
  r = tmp;
  }
#line 115
  if (! r) {
    {
#line 116
    puts("Not enough memory.");
#line 117
    exit(3);
    }
  }
#line 119
  return (r);
}
}
#line 122 "/home/wheatley/newnew/temp/quota-4.01/common.c"
void version(void) 
{ 
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 124
  tmp = gettext("Quota utilities version %s.\n");
#line 124
  printf((char const   */* __restrict  */)tmp, "4.01");
#line 125
  tmp___0 = gettext("Compiled with:%s\n");
#line 125
  printf((char const   */* __restrict  */)tmp___0, " RPC BSD_BEHAVIOUR");
#line 126
  tmp___1 = gettext("Bugs to %s\n");
#line 126
  printf((char const   */* __restrict  */)tmp___1, "jack@suse.cz");
  }
#line 127
  return;
}
}
#line 237 "/usr/include/stdio.h"
extern int fclose(FILE *__stream ) ;
#line 283
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes )  __asm__("fopen64")  ;
#line 425
extern int fscanf(FILE * __restrict  __stream , char const   * __restrict  __format 
                  , ...) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 413
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
#line 604
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) basename)(char const   *__filename ) ;
#line 102 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) __sighandler_t ( __attribute__((__leaf__)) signal)(int __sig ,
                                                                                        void (*__handler)(int  ) ) ;
#line 16 "/home/wheatley/newnew/temp/quota-4.01/pot.h"
void gettexton(void) ;
#line 19 "/home/wheatley/newnew/temp/quota-4.01/common.h"
char *progname  ;
#line 166 "/home/wheatley/newnew/temp/quota-4.01/quota.h"
extern long quotactl(int  , char const   * , qid_t  , caddr_t  ) ;
#line 217 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) stat)(char const   * __restrict  __file ,
                                                                                             struct stat * __restrict  __buf )  __asm__("stat64")  ;
#line 40 "/home/wheatley/newnew/temp/quota-4.01/quotastats.c"
static int get_proc_num(char *name ) 
{ 
  int ret ;
  char namebuf[4096] ;
  unsigned int tmp ;
  FILE *f ;
  int *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
#line 43
  namebuf[0] = (char )'/';
#line 43
  namebuf[1] = (char )'p';
#line 43
  namebuf[2] = (char )'r';
#line 43
  namebuf[3] = (char )'o';
#line 43
  namebuf[4] = (char )'c';
#line 43
  namebuf[5] = (char )'/';
#line 43
  namebuf[6] = (char )'s';
#line 43
  namebuf[7] = (char )'y';
#line 43
  namebuf[8] = (char )'s';
#line 43
  namebuf[9] = (char )'/';
#line 43
  namebuf[10] = (char )'f';
#line 43
  namebuf[11] = (char )'s';
#line 43
  namebuf[12] = (char )'/';
#line 43
  namebuf[13] = (char )'q';
#line 43
  namebuf[14] = (char )'u';
#line 43
  namebuf[15] = (char )'o';
#line 43
  namebuf[16] = (char )'t';
#line 43
  namebuf[17] = (char )'a';
#line 43
  namebuf[18] = (char )'/';
#line 43
  namebuf[19] = (char )'\000';
#line 43
  tmp = 20U;
  {
#line 43
  while (1) {
    while_continue: /* CIL Label */ ;
#line 43
    if (tmp >= 4096U) {
#line 43
      goto while_break;
    }
#line 43
    namebuf[tmp] = (char)0;
#line 43
    tmp ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 46
  sstrncat(namebuf, (char const   *)name, (size_t )4096);
#line 47
  f = fopen((char const   */* __restrict  */)(namebuf), (char const   */* __restrict  */)"r");
  }
#line 47
  if (! f) {
    {
#line 48
    tmp___0 = __errno_location();
#line 48
    tmp___1 = strerror(*tmp___0);
#line 48
    tmp___2 = gettext("Cannot read stat file %s: %s\n");
#line 48
    errstr(tmp___2, namebuf, tmp___1);
    }
#line 49
    return (-1);
  }
  {
#line 51
  fscanf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"%d", & ret);
#line 52
  fclose(f);
  }
#line 53
  return (ret);
}
}
#line 56 "/home/wheatley/newnew/temp/quota-4.01/quotastats.c"
static int get_stats(struct util_dqstats *dqstats ) 
{ 
  struct v1_dqstats old_dqstats ;
  struct v2_dqstats v0_dqstats ;
  int ret ;
  struct stat st ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  int *tmp___10 ;
  int *tmp___11 ;
  int *tmp___12 ;
  int *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  long tmp___16 ;
  long tmp___17 ;
  int tmp___18 ;

  {
  {
#line 60
  ret = -1;
#line 63
  signal(11, (void (*)(int  ))1);
#line 64
  tmp___18 = stat((char const   */* __restrict  */)"/proc/sys/fs/quota", (struct stat */* __restrict  */)(& st));
  }
#line 64
  if (tmp___18) {
    {
#line 75
    tmp___17 = quotactl(2048 << 8, (char const   *)((void *)0), (qid_t )0, (caddr_t )(& old_dqstats));
    }
#line 75
    if (tmp___17 >= 0L) {
      {
#line 77
      memcpy((void */* __restrict  */)dqstats, (void const   */* __restrict  */)(& old_dqstats),
             sizeof(old_dqstats));
#line 78
      dqstats->version = (u_int32_t )0;
      }
    } else {
      {
#line 82
      tmp___10 = __errno_location();
      }
#line 82
      if (*tmp___10 != 22) {
        {
#line 82
        tmp___11 = __errno_location();
        }
#line 82
        if (*tmp___11 != 1) {
          {
#line 82
          tmp___12 = __errno_location();
          }
#line 82
          if (*tmp___12 != 14) {
            {
#line 83
            tmp___7 = __errno_location();
#line 83
            tmp___8 = strerror(*tmp___7);
#line 83
            tmp___9 = gettext("Error while getting quota statistics from kernel: %s\n");
#line 83
            errstr(tmp___9, tmp___8);
            }
#line 84
            goto out;
          }
        }
      }
      {
#line 86
      tmp___16 = quotactl(4352 << 8, (char const   *)((void *)0), (qid_t )0, (caddr_t )(& v0_dqstats));
      }
#line 86
      if (tmp___16 < 0L) {
        {
#line 87
        tmp___13 = __errno_location();
#line 87
        tmp___14 = strerror(*tmp___13);
#line 87
        tmp___15 = gettext("Error while getting old quota statistics from kernel: %s\n");
#line 87
        errstr(tmp___15, tmp___14);
        }
#line 88
        goto out;
      }
      {
#line 90
      memcpy((void */* __restrict  */)dqstats, (void const   */* __restrict  */)(& v0_dqstats),
             sizeof(v0_dqstats));
      }
    }
  } else {
    {
#line 65
    dqstats->version = (u_int32_t )60501;
#line 66
    tmp = get_proc_num((char *)"lookups");
#line 66
    dqstats->lookups = (u_int32_t )tmp;
#line 67
    tmp___0 = get_proc_num((char *)"drops");
#line 67
    dqstats->drops = (u_int32_t )tmp___0;
#line 68
    tmp___1 = get_proc_num((char *)"reads");
#line 68
    dqstats->reads = (u_int32_t )tmp___1;
#line 69
    tmp___2 = get_proc_num((char *)"writes");
#line 69
    dqstats->writes = (u_int32_t )tmp___2;
#line 70
    tmp___3 = get_proc_num((char *)"cache_hits");
#line 70
    dqstats->cache_hits = (u_int32_t )tmp___3;
#line 71
    tmp___4 = get_proc_num((char *)"allocated_dquots");
#line 71
    dqstats->allocated_dquots = (u_int32_t )tmp___4;
#line 72
    tmp___5 = get_proc_num((char *)"free_dquots");
#line 72
    dqstats->free_dquots = (u_int32_t )tmp___5;
#line 73
    tmp___6 = get_proc_num((char *)"syncs");
#line 73
    dqstats->syncs = (u_int32_t )tmp___6;
    }
  }
#line 92
  ret = 0;
  out: 
  {
#line 94
  signal(11, (void (*)(int  ))0);
  }
#line 95
  return (ret);
}
}
#line 98 "/home/wheatley/newnew/temp/quota-4.01/quotastats.c"
__inline static int print_stats(struct util_dqstats *dqstats ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;

  {
#line 100
  if (! dqstats->version) {
    {
#line 101
    tmp = gettext("Kernel quota version: old\n");
#line 101
    printf((char const   */* __restrict  */)tmp);
    }
  } else {
    {
#line 103
    tmp___0 = gettext("Kernel quota version: %u.%u.%u\n");
#line 103
    printf((char const   */* __restrict  */)tmp___0, dqstats->version / 10000U, (dqstats->version / 100U) % 100U,
           dqstats->version % 100U);
    }
  }
  {
#line 104
  tmp___1 = gettext("Number of dquot lookups: %ld\n");
#line 104
  printf((char const   */* __restrict  */)tmp___1, (long )dqstats->lookups);
#line 105
  tmp___2 = gettext("Number of dquot drops: %ld\n");
#line 105
  printf((char const   */* __restrict  */)tmp___2, (long )dqstats->drops);
#line 106
  tmp___3 = gettext("Number of dquot reads: %ld\n");
#line 106
  printf((char const   */* __restrict  */)tmp___3, (long )dqstats->reads);
#line 107
  tmp___4 = gettext("Number of dquot writes: %ld\n");
#line 107
  printf((char const   */* __restrict  */)tmp___4, (long )dqstats->writes);
#line 108
  tmp___5 = gettext("Number of quotafile syncs: %ld\n");
#line 108
  printf((char const   */* __restrict  */)tmp___5, (long )dqstats->syncs);
#line 109
  tmp___6 = gettext("Number of dquot cache hits: %ld\n");
#line 109
  printf((char const   */* __restrict  */)tmp___6, (long )dqstats->cache_hits);
#line 110
  tmp___7 = gettext("Number of allocated dquots: %ld\n");
#line 110
  printf((char const   */* __restrict  */)tmp___7, (long )dqstats->allocated_dquots);
#line 111
  tmp___8 = gettext("Number of free dquots: %ld\n");
#line 111
  printf((char const   */* __restrict  */)tmp___8, (long )dqstats->free_dquots);
#line 112
  tmp___9 = gettext("Number of in use dquot entries (user/group): %ld\n");
#line 112
  printf((char const   */* __restrict  */)tmp___9, (long )(dqstats->allocated_dquots - dqstats->free_dquots));
  }
#line 114
  return (0);
}
}
#line 117 "/home/wheatley/newnew/temp/quota-4.01/quotastats.c"
int main(int argc , char **argv ) 
{ 
  struct util_dqstats dqstats ;
  int tmp ;

  {
  {
#line 121
  gettexton();
#line 122
  progname = basename((char const   *)*(argv + 0));
#line 124
  tmp = get_stats(& dqstats);
  }
#line 124
  if (! tmp) {
    {
#line 125
    print_stats(& dqstats);
    }
  }
#line 126
  return (0);
}
}
#line 82 "/usr/include/libintl.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) textdomain)(char const   *__domainname ) ;
#line 86
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) bindtextdomain)(char const   *__domainname ,
                                                                                       char const   *__dirname ) ;
#line 124 "/usr/include/locale.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) setlocale)(int __category ,
                                                                                  char const   *__locale ) ;
#line 9 "/home/wheatley/newnew/temp/quota-4.01/pot.c"
void gettexton(void) 
{ 


  {
  {
#line 12
  setlocale(6, "");
#line 13
  bindtextdomain("quota", "/usr/share/locale");
#line 14
  textdomain("quota");
  }
#line 16
  return;
}
}
#line 66 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 144
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 353 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 483 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 149 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...)  __asm__("open64")  ;
#line 50 "/usr/include/x86_64-linux-gnu/sys/file.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) flock)(int __fd ,
                                                                            int __operation ) ;
#line 37 "/home/wheatley/newnew/temp/quota-4.01/quotasys.h"
int kernel_iface ;
#line 54
int nfs_fstype(char *type ) ;
#line 56
int meta_qf_fstype(char *type ) ;
#line 89
char *fmt2name(int fmt___7 ) ;
#line 113 "/home/wheatley/newnew/temp/quota-4.01/quotasys.h"
__inline static int me_hasquota(struct mount_entry *mnt___2 , int type ) 
{ 


  {
#line 115
  return (mnt___2->me_qfmt[type] >= 0);
}
}
#line 122
int get_qf_name(struct mount_entry *mnt___2 , int type , int fmt___7 , int flags___7 ,
                char **filename ) ;
#line 143
int kern_quota_on(struct mount_entry *mnt___2 , int type , int fmt___7 ) ;
#line 146
int kern_qfmt_supp(int fmt___7 ) ;
#line 19 "/home/wheatley/newnew/temp/quota-4.01/dqblk_v1.h"
struct quotafile_ops quotafile_ops_1 ;
#line 38 "/home/wheatley/newnew/temp/quota-4.01/dqblk_v2.h"
struct quotafile_ops quotafile_ops_2 ;
#line 18 "/home/wheatley/newnew/temp/quota-4.01/dqblk_rpc.h"
struct quotafile_ops quotafile_ops_rpc ;
#line 23 "/home/wheatley/newnew/temp/quota-4.01/dqblk_xfs.h"
struct quotafile_ops quotafile_ops_xfs ;
#line 45 "/home/wheatley/newnew/temp/quota-4.01/quotaio.h"
__inline static int is_tree_qfmt(int fmt___7 ) 
{ 
  int tmp ;

  {
#line 47
  if (fmt___7 == 1) {
#line 47
    tmp = 1;
  } else
#line 47
  if (fmt___7 == 2) {
#line 47
    tmp = 1;
  } else {
#line 47
    tmp = 0;
  }
#line 47
  return (tmp);
}
}
#line 158
struct quotafile_ops quotafile_ops_meta ;
#line 171
struct quota_handle *init_io(struct mount_entry *mnt___2 , int type , int fmt___7 ,
                             int flags___7 ) ;
#line 174
struct quota_handle *new_io(struct mount_entry *mnt___2 , int type , int fmt___7 ) ;
#line 177
int end_io(struct quota_handle *h ) ;
#line 180
struct dquot *get_empty_dquot(void) ;
#line 183
int check_dquot_range(struct dquot *dquot ) ;
#line 40 "/home/wheatley/newnew/temp/quota-4.01/quotaio.c"
struct quota_handle *init_io(struct mount_entry *mnt___2 , int type , int fmt___7 ,
                             int flags___7 ) 
{ 
  char *qfname ;
  int fd ;
  int kernfmt ;
  struct quota_handle *h ;
  void *tmp ;
  int nameflag ;
  int tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  char *tmp___10 ;
  int tmp___11 ;
  char *tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  char *tmp___16 ;
  int tmp___17 ;
  unsigned int cmd ;
  int tmp___18 ;
  int *tmp___19 ;
  char *tmp___20 ;
  char *tmp___21 ;
  long tmp___22 ;
  int *tmp___23 ;
  char *tmp___24 ;
  char *tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  int *tmp___29 ;
  char *tmp___30 ;
  char *tmp___31 ;
  int tmp___32 ;

  {
  {
#line 42
  qfname = (char *)((void *)0);
#line 43
  fd = -1;
#line 44
  tmp = smalloc(sizeof(struct quota_handle ));
#line 44
  h = (struct quota_handle *)tmp;
#line 47
  tmp___0 = me_hasquota(mnt___2, type);
  }
#line 47
  if (! tmp___0) {
#line 48
    goto out_handle;
  }
  {
#line 49
  tmp___1 = stat((char const   */* __restrict  */)mnt___2->me_devname, (struct stat */* __restrict  */)(& h->qh_stat));
  }
#line 49
  if (tmp___1 < 0) {
    {
#line 50
    memset((void *)(& h->qh_stat), 0, sizeof(struct stat ));
    }
  }
#line 51
  h->qh_io_flags = 0;
#line 52
  if (flags___7 & 1) {
#line 53
    h->qh_io_flags |= 4;
  }
#line 54
  if (flags___7 & 4) {
#line 55
    h->qh_io_flags |= 8;
  }
  {
#line 56
  h->qh_type = type;
#line 57
  sstrncpy(h->qh_quotadev, mnt___2->me_devname, sizeof(h->qh_quotadev));
#line 58
  sstrncpy(h->qh_fstype, (char const   *)mnt___2->me_type, (size_t )16);
#line 59
  sstrncpy(h->qh_dir, mnt___2->me_dir, (size_t )4096);
#line 60
  tmp___4 = nfs_fstype(mnt___2->me_type);
  }
#line 60
  if (tmp___4) {
#line 61
    if (fmt___7 != -1) {
#line 61
      if (fmt___7 != 3) {
        {
#line 62
        tmp___2 = gettext("Only RPC quota format is allowed on NFS filesystem.\n");
#line 62
        errstr(tmp___2);
        }
#line 63
        goto out_handle;
      }
    }
    {
#line 66
    h->qh_fd = -1;
#line 67
    h->qh_fmt = 3;
#line 68
    h->qh_ops = & quotafile_ops_rpc;
#line 69
    memset((void *)(& h->qh_info), 0, sizeof(h->qh_info));
#line 70
    (*((h->qh_ops)->init_io))(h);
    }
#line 71
    return (h);
  } else
#line 76
  if (fmt___7 == 3) {
    {
#line 77
    tmp___3 = gettext("RPC quota format specified for non-NFS filesystem.\n");
#line 77
    errstr(tmp___3);
    }
#line 78
    goto out_handle;
  }
  {
#line 81
  tmp___7 = strcmp((char const   *)mnt___2->me_type, "xfs");
  }
#line 81
  if (tmp___7) {
    {
#line 81
    tmp___8 = strcmp((char const   *)mnt___2->me_type, "gfs2");
    }
#line 81
    if (tmp___8) {
#line 94
      if (fmt___7 == 4) {
        {
#line 95
        tmp___6 = gettext("XFS quota allowed only on XFS filesystem.\n");
#line 95
        errstr(tmp___6);
        }
#line 96
        goto out_handle;
      }
    } else {
      _L: /* CIL Label */ 
#line 83
      if (fmt___7 != -1) {
#line 83
        if (fmt___7 != 4) {
          {
#line 84
          tmp___5 = gettext("Only XFS quota format is allowed on XFS filesystem.\n");
#line 84
          errstr(tmp___5);
          }
#line 85
          goto out_handle;
        }
      }
      {
#line 87
      h->qh_fd = -1;
#line 88
      h->qh_fmt = 4;
#line 89
      h->qh_ops = & quotafile_ops_xfs;
#line 90
      memset((void *)(& h->qh_info), 0, sizeof(h->qh_info));
#line 91
      (*((h->qh_ops)->init_io))(h);
      }
#line 92
      return (h);
    }
  } else {
#line 81
    goto _L;
  }
  {
#line 98
  tmp___9 = kern_qfmt_supp(fmt___7);
  }
#line 98
  if (tmp___9) {
    {
#line 100
    kernfmt = kern_quota_on(mnt___2, type, fmt___7);
    }
#line 101
    if (kernfmt >= 0) {
#line 102
      h->qh_io_flags |= 1;
#line 103
      fmt___7 = kernfmt;
    }
  }
  {
#line 107
  tmp___11 = meta_qf_fstype(mnt___2->me_type);
  }
#line 107
  if (tmp___11) {
#line 107
    goto _L___0;
  } else
#line 107
  if (mnt___2->me_qfmt[type] == 5) {
    _L___0: /* CIL Label */ 
#line 108
    if (! (h->qh_io_flags & 1)) {
      {
#line 109
      tmp___10 = gettext("Quota not supported by the filesystem.\n");
#line 109
      errstr(tmp___10);
      }
#line 110
      goto out_handle;
    }
#line 112
    h->qh_fd = -1;
#line 113
    h->qh_fmt = fmt___7;
#line 114
    goto set_ops;
  }
#line 117
  if (! (h->qh_io_flags & 1)) {
#line 117
    nameflag = 2;
  } else
#line 117
  if (flags___7 & 2) {
#line 117
    nameflag = 2;
  } else {
#line 117
    nameflag = 0;
  }
#line 118
  if (fmt___7 == -1) {
    {
#line 120
    tmp___15 = get_qf_name(mnt___2, type, 1, nameflag, & qfname);
    }
#line 120
    if (tmp___15 >= 0) {
#line 121
      fmt___7 = 1;
    } else {
      {
#line 123
      tmp___14 = get_qf_name(mnt___2, type, 2, nameflag, & qfname);
      }
#line 123
      if (tmp___14 >= 0) {
#line 124
        fmt___7 = 2;
      } else {
        {
#line 126
        tmp___13 = get_qf_name(mnt___2, type, 0, nameflag, & qfname);
        }
#line 126
        if (tmp___13 >= 0) {
#line 127
          fmt___7 = 0;
        } else {
          {
#line 129
          tmp___12 = gettext("Cannot find any quota file to work on.\n");
#line 129
          errstr(tmp___12);
          }
#line 130
          goto out_handle;
        }
      }
    }
  } else {
    {
#line 133
    tmp___17 = get_qf_name(mnt___2, type, fmt___7, nameflag, & qfname);
    }
#line 133
    if (tmp___17 < 0) {
      {
#line 134
      tmp___16 = gettext("Quota file not found or has wrong format.\n");
#line 134
      errstr(tmp___16);
      }
#line 135
      goto out_handle;
    }
  }
#line 138
  if (! (h->qh_io_flags & 1)) {
#line 138
    goto _L___1;
  } else
#line 138
  if (flags___7 & 2) {
    _L___1: /* CIL Label */ 
#line 139
    if (h->qh_io_flags & 1) {
#line 140
      if (kernel_iface == 3) {
#line 140
        tmp___18 = 8388609;
      } else {
#line 140
        tmp___18 = 1536;
      }
      {
#line 140
      cmd = (unsigned int )tmp___18;
#line 142
      tmp___22 = quotactl((int )((cmd << 8) | (unsigned int )(h->qh_type & 255)),
                          (char const   *)(h->qh_quotadev), (qid_t )0, (caddr_t )((void *)0));
      }
#line 142
      if (tmp___22 < 0L) {
        {
#line 144
        tmp___19 = __errno_location();
#line 144
        tmp___20 = strerror(*tmp___19);
#line 144
        tmp___21 = gettext("Cannot sync quotas on device %s: %s\n");
#line 144
        die(4, tmp___21, h->qh_quotadev, tmp___20);
        }
      }
    }
#line 149
    if (h->qh_io_flags & 4) {
#line 149
      tmp___26 = 0;
    } else {
#line 149
      tmp___26 = 2;
    }
    {
#line 149
    fd = open((char const   *)qfname, tmp___26);
    }
#line 149
    if (fd < 0) {
      {
#line 150
      tmp___23 = __errno_location();
#line 150
      tmp___24 = strerror(*tmp___23);
#line 150
      tmp___25 = gettext("Cannot open quotafile %s: %s\n");
#line 150
      errstr(tmp___25, qfname, tmp___24);
      }
#line 152
      goto out_handle;
    }
#line 154
    if (h->qh_io_flags & 4) {
#line 154
      tmp___27 = 1;
    } else {
#line 154
      tmp___27 = 2;
    }
    {
#line 154
    flock(fd, tmp___27);
#line 156
    h->qh_fd = fd;
#line 157
    h->qh_fmt = fmt___7;
    }
  } else {
#line 159
    h->qh_fd = -1;
#line 160
    h->qh_fmt = fmt___7;
  }
  {
#line 162
  free((void *)qfname);
#line 163
  qfname = (char *)((void *)0);
  }
  set_ops: 
#line 166
  if (fmt___7 == 0) {
#line 167
    h->qh_ops = & quotafile_ops_1;
  } else {
    {
#line 168
    tmp___28 = is_tree_qfmt(fmt___7);
    }
#line 168
    if (tmp___28) {
#line 169
      h->qh_ops = & quotafile_ops_2;
    } else
#line 170
    if (fmt___7 == 5) {
#line 171
      h->qh_ops = & quotafile_ops_meta;
    }
  }
  {
#line 172
  memset((void *)(& h->qh_info), 0, sizeof(h->qh_info));
  }
#line 174
  if ((h->qh_ops)->init_io) {
    {
#line 174
    tmp___32 = (*((h->qh_ops)->init_io))(h);
    }
#line 174
    if (tmp___32 < 0) {
      {
#line 175
      tmp___29 = __errno_location();
#line 175
      tmp___30 = strerror(*tmp___29);
#line 175
      tmp___31 = gettext("Cannot initialize quota on %s: %s\n");
#line 175
      errstr(tmp___31, h->qh_quotadev, tmp___30);
      }
#line 176
      goto out_lock;
    }
  }
#line 178
  return (h);
  out_lock: 
#line 180
  if (fd != -1) {
    {
#line 181
    flock(fd, 8);
    }
  }
  out_handle: 
#line 183
  if (qfname) {
    {
#line 184
    free((void *)qfname);
    }
  }
  {
#line 185
  free((void *)h);
  }
#line 186
  return ((struct quota_handle *)((void *)0));
}
}
#line 192 "/home/wheatley/newnew/temp/quota-4.01/quotaio.c"
struct quota_handle *new_io(struct mount_entry *mnt___2 , int type , int fmt___7 ) 
{ 
  char *qfname ;
  int fd ;
  struct quota_handle *h ;
  char namebuf[4096] ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  void *tmp___7 ;
  int tmp___8 ;

  {
#line 199
  if (fmt___7 == -1) {
#line 200
    fmt___7 = 1;
  } else
#line 201
  if (fmt___7 == 3) {
    {
#line 202
    tmp = fmt2name(fmt___7);
#line 202
    tmp___0 = gettext("Creation of %s quota format is not supported.\n");
#line 202
    errstr(tmp___0, tmp);
    }
#line 204
    return ((struct quota_handle *)((void *)0));
  } else
#line 201
  if (fmt___7 == 4) {
    {
#line 202
    tmp = fmt2name(fmt___7);
#line 202
    tmp___0 = gettext("Creation of %s quota format is not supported.\n");
#line 202
    errstr(tmp___0, tmp);
    }
#line 204
    return ((struct quota_handle *)((void *)0));
  }
  {
#line 211
  tmp___2 = meta_qf_fstype(mnt___2->me_type);
  }
#line 211
  if (tmp___2) {
    {
#line 212
    tmp___1 = gettext("Quota on %s is stored in system files and must be manipulated by fs tools.\n");
#line 212
    errstr(tmp___1, mnt___2->me_dir);
    }
#line 214
    return ((struct quota_handle *)((void *)0));
  } else
#line 211
  if (mnt___2->me_qfmt[type] == 5) {
    {
#line 212
    tmp___1 = gettext("Quota on %s is stored in system files and must be manipulated by fs tools.\n");
#line 212
    errstr(tmp___1, mnt___2->me_dir);
    }
#line 214
    return ((struct quota_handle *)((void *)0));
  }
  {
#line 216
  tmp___3 = get_qf_name(mnt___2, type, fmt___7, 0, & qfname);
  }
#line 216
  if (tmp___3 < 0) {
#line 217
    return ((struct quota_handle *)((void *)0));
  }
  {
#line 218
  sstrncpy(namebuf, (char const   *)qfname, (size_t )4096);
#line 219
  sstrncat(namebuf, ".new", (size_t )4096);
#line 220
  free((void *)qfname);
#line 221
  fd = open((char const   *)(namebuf), 194, 384);
  }
#line 221
  if (fd < 0) {
    {
#line 222
    tmp___4 = __errno_location();
#line 222
    tmp___5 = strerror(*tmp___4);
#line 222
    tmp___6 = gettext("Cannot create new quotafile %s: %s\n");
#line 222
    errstr(tmp___6, namebuf, tmp___5);
    }
#line 224
    return ((struct quota_handle *)((void *)0));
  }
  {
#line 226
  tmp___7 = smalloc(sizeof(struct quota_handle ));
#line 226
  h = (struct quota_handle *)tmp___7;
#line 228
  h->qh_fd = fd;
#line 229
  h->qh_io_flags = 0;
#line 230
  sstrncpy(h->qh_quotadev, mnt___2->me_devname, sizeof(h->qh_quotadev));
#line 231
  sstrncpy(h->qh_fstype, (char const   *)mnt___2->me_type, (size_t )16);
#line 232
  sstrncpy(h->qh_dir, mnt___2->me_dir, (size_t )4096);
#line 233
  h->qh_type = type;
#line 234
  h->qh_fmt = fmt___7;
#line 235
  memset((void *)(& h->qh_info), 0, sizeof(h->qh_info));
  }
#line 236
  if (fmt___7 == 0) {
#line 237
    h->qh_ops = & quotafile_ops_1;
  } else {
#line 239
    h->qh_ops = & quotafile_ops_2;
  }
  {
#line 241
  flock(fd, 2);
  }
#line 242
  if ((h->qh_ops)->new_io) {
    {
#line 242
    tmp___8 = (*((h->qh_ops)->new_io))(h);
    }
#line 242
    if (tmp___8 < 0) {
      {
#line 243
      flock(fd, 8);
#line 244
      free((void *)h);
      }
#line 245
      goto out_fd;
    }
  }
#line 247
  return (h);
  out_fd: 
  {
#line 249
  close(fd);
  }
#line 250
  return ((struct quota_handle *)((void *)0));
}
}
#line 256 "/home/wheatley/newnew/temp/quota-4.01/quotaio.c"
int end_io(struct quota_handle *h ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 258
  if (h->qh_io_flags & 2) {
#line 259
    if ((h->qh_ops)->write_info) {
      {
#line 259
      tmp = (*((h->qh_ops)->write_info))(h);
      }
#line 259
      if (tmp < 0) {
#line 260
        return (-1);
      }
    }
#line 261
    h->qh_io_flags &= -3;
  }
#line 263
  if ((h->qh_ops)->end_io) {
    {
#line 263
    tmp___0 = (*((h->qh_ops)->end_io))(h);
    }
#line 263
    if (tmp___0 < 0) {
#line 264
      return (-1);
    }
  }
#line 265
  if (h->qh_fd != -1) {
    {
#line 266
    flock(h->qh_fd, 8);
#line 267
    close(h->qh_fd);
    }
  }
  {
#line 269
  free((void *)h);
  }
#line 270
  return (0);
}
}
#line 276 "/home/wheatley/newnew/temp/quota-4.01/quotaio.c"
struct dquot *get_empty_dquot(void) 
{ 
  struct dquot *dquot ;
  void *tmp ;

  {
  {
#line 278
  tmp = smalloc(sizeof(struct dquot ));
#line 278
  dquot = (struct dquot *)tmp;
#line 280
  memset((void *)dquot, 0, sizeof(*dquot));
#line 281
  dquot->dq_id = (qid_t )-1;
  }
#line 282
  return (dquot);
}
}
#line 288 "/home/wheatley/newnew/temp/quota-4.01/quotaio.c"
int check_dquot_range(struct dquot *dquot ) 
{ 
  struct util_dqinfo *info ;
  char *tmp ;
  char *tmp___0 ;

  {
#line 290
  info = & (dquot->dq_h)->qh_info;
#line 292
  if ((uint64_t )dquot->dq_dqb.dqb_bhardlimit > info->dqi_max_b_limit) {
    {
#line 296
    tmp = gettext("Trying to set quota limits out of range supported by quota format on %s.\n");
#line 296
    errstr(tmp, (dquot->dq_h)->qh_quotadev);
    }
#line 298
    return (-1);
  } else
#line 292
  if ((uint64_t )dquot->dq_dqb.dqb_bsoftlimit > info->dqi_max_b_limit) {
    {
#line 296
    tmp = gettext("Trying to set quota limits out of range supported by quota format on %s.\n");
#line 296
    errstr(tmp, (dquot->dq_h)->qh_quotadev);
    }
#line 298
    return (-1);
  } else
#line 292
  if ((uint64_t )dquot->dq_dqb.dqb_ihardlimit > info->dqi_max_i_limit) {
    {
#line 296
    tmp = gettext("Trying to set quota limits out of range supported by quota format on %s.\n");
#line 296
    errstr(tmp, (dquot->dq_h)->qh_quotadev);
    }
#line 298
    return (-1);
  } else
#line 292
  if ((uint64_t )dquot->dq_dqb.dqb_isoftlimit > info->dqi_max_i_limit) {
    {
#line 296
    tmp = gettext("Trying to set quota limits out of range supported by quota format on %s.\n");
#line 296
    errstr(tmp, (dquot->dq_h)->qh_quotadev);
    }
#line 298
    return (-1);
  }
#line 300
  if ((uint64_t )dquot->dq_dqb.dqb_curinodes > info->dqi_max_i_usage) {
    {
#line 302
    tmp___0 = gettext("Trying to set quota usage out of range supported by quota format on %s.\n");
#line 302
    errstr(tmp___0, (dquot->dq_h)->qh_quotadev);
    }
#line 304
    return (-1);
  } else
#line 300
  if ((uint64_t )dquot->dq_dqb.dqb_curspace > info->dqi_max_b_usage) {
    {
#line 302
    tmp___0 = gettext("Trying to set quota usage out of range supported by quota format on %s.\n");
#line 302
    errstr(tmp___0, (dquot->dq_h)->qh_quotadev);
    }
#line 304
    return (-1);
  }
#line 306
  return (0);
}
}
#line 13 "/home/wheatley/newnew/temp/quota-4.01/quotaio_generic.h"
int vfs_get_info(struct quota_handle *h ) ;
#line 16
int vfs_set_info(struct quota_handle *h , int flags___7 ) ;
#line 19
int vfs_get_dquot(struct dquot *dquot ) ;
#line 22
int vfs_set_dquot(struct dquot *dquot , int flags___7 ) ;
#line 26
int generic_scan_dquots(struct quota_handle *h , int (*process_dquot)(struct dquot *dquot ,
                                                                      char *dqname ) ,
                        int (*get_dquot)(struct dquot *dquot ) ) ;
#line 19 "/home/wheatley/newnew/temp/quota-4.01/quotaio_meta.c"
static int meta_init_io(struct quota_handle *h ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
#line 21
  if (! (h->qh_io_flags & 1)) {
    {
#line 22
    tmp = gettext("Metadata init_io called when kernel support is not enabled.\n");
#line 22
    errstr(tmp);
    }
#line 23
    return (-1);
  }
#line 25
  if (kernel_iface != 3) {
    {
#line 26
    tmp___0 = gettext("Metadata init_io called when kernel does not support generic quota interface!\n");
#line 26
    errstr(tmp___0);
    }
#line 27
    return (-1);
  }
  {
#line 29
  tmp___1 = vfs_get_info(h);
  }
#line 29
  return (tmp___1);
}
}
#line 32 "/home/wheatley/newnew/temp/quota-4.01/quotaio_meta.c"
static int meta_write_info(struct quota_handle *h ) 
{ 
  int tmp ;

  {
  {
#line 34
  tmp = vfs_set_info(h, 3);
  }
#line 34
  return (tmp);
}
}
#line 37 "/home/wheatley/newnew/temp/quota-4.01/quotaio_meta.c"
static struct dquot *meta_read_dquot(struct quota_handle *h , qid_t id___0 ) 
{ 
  struct dquot *dquot ;
  struct dquot *tmp ;
  int tmp___0 ;

  {
  {
#line 39
  tmp = get_empty_dquot();
#line 39
  dquot = tmp;
#line 41
  dquot->dq_id = id___0;
#line 42
  dquot->dq_h = h;
#line 43
  memset((void *)(& dquot->dq_dqb), 0, sizeof(struct util_dqblk ));
#line 44
  tmp___0 = vfs_get_dquot(dquot);
  }
#line 44
  if (tmp___0 < 0) {
    {
#line 45
    free((void *)dquot);
    }
#line 46
    return ((struct dquot *)((void *)0));
  }
#line 48
  return (dquot);
}
}
#line 51 "/home/wheatley/newnew/temp/quota-4.01/quotaio_meta.c"
static int meta_commit_dquot(struct dquot *dquot , int flags___7 ) 
{ 
  int tmp ;

  {
  {
#line 53
  tmp = vfs_set_dquot(dquot, flags___7);
  }
#line 53
  return (tmp);
}
}
#line 56 "/home/wheatley/newnew/temp/quota-4.01/quotaio_meta.c"
static int meta_scan_dquots(struct quota_handle *h , int (*process_dquot)(struct dquot *dquot ,
                                                                          char *dqname ) ) 
{ 
  int tmp ;

  {
  {
#line 58
  tmp = generic_scan_dquots(h, process_dquot, & vfs_get_dquot);
  }
#line 58
  return (tmp);
}
}
#line 61 "/home/wheatley/newnew/temp/quota-4.01/quotaio_meta.c"
struct quotafile_ops quotafile_ops_meta  = 
#line 61
     {(int (*)(int fd , int type , int fmt ))0, & meta_init_io, (int (*)(struct quota_handle *h ))0,
    (int (*)(struct quota_handle *h ))0, & meta_write_info, & meta_read_dquot, & meta_commit_dquot,
    & meta_scan_dquots, (int (*)(struct quota_handle *h , int verbose ))0};
#line 59 "/home/wheatley/newnew/temp/quota-4.01/quotasys.h"
char *type2name(int type ) ;
#line 27 "/home/wheatley/newnew/temp/quota-4.01/quotaio_xfs.c"
static int xfs_init_io(struct quota_handle *h ) ;
#line 28
static int xfs_write_info(struct quota_handle *h ) ;
#line 29
static struct dquot *xfs_read_dquot(struct quota_handle *h , qid_t id___0 ) ;
#line 30
static int xfs_commit_dquot(struct dquot *dquot , int flags___7 ) ;
#line 31
static int xfs_scan_dquots(struct quota_handle *h , int (*process_dquot)(struct dquot *dquot ,
                                                                         char *dqname ) ) ;
#line 32
static int xfs_report(struct quota_handle *h , int verbose ) ;
#line 34 "/home/wheatley/newnew/temp/quota-4.01/quotaio_xfs.c"
struct quotafile_ops quotafile_ops_xfs  = 
#line 34
     {(int (*)(int fd , int type , int fmt ))0, & xfs_init_io, (int (*)(struct quota_handle *h ))0,
    (int (*)(struct quota_handle *h ))0, & xfs_write_info, & xfs_read_dquot, & xfs_commit_dquot,
    & xfs_scan_dquots, & xfs_report};
#line 46 "/home/wheatley/newnew/temp/quota-4.01/quotaio_xfs.c"
__inline static void xfs_kern2utildqblk(struct util_dqblk *u , struct fs_disk_quota *k ) 
{ 


  {
#line 48
  u->dqb_ihardlimit = (qsize_t )k->d_ino_hardlimit;
#line 49
  u->dqb_isoftlimit = (qsize_t )k->d_ino_softlimit;
#line 50
  u->dqb_bhardlimit = (qsize_t )(k->d_blk_hardlimit >> 1);
#line 51
  u->dqb_bsoftlimit = (qsize_t )(k->d_blk_softlimit >> 1);
#line 52
  u->dqb_curinodes = (qsize_t )k->d_icount;
#line 53
  u->dqb_curspace = (qsize_t )k->d_bcount << 9;
#line 54
  u->dqb_itime = (time_t )k->d_itimer;
#line 55
  u->dqb_btime = (time_t )k->d_btimer;
#line 56
  return;
}
}
#line 61 "/home/wheatley/newnew/temp/quota-4.01/quotaio_xfs.c"
__inline static void xfs_util2kerndqblk(struct fs_disk_quota *k , struct util_dqblk *u ) 
{ 


  {
  {
#line 63
  memset((void *)k, 0, sizeof(struct fs_disk_quota ));
#line 64
  k->d_ino_hardlimit = (__u64 )u->dqb_ihardlimit;
#line 65
  k->d_ino_softlimit = (__u64 )u->dqb_isoftlimit;
#line 66
  k->d_blk_hardlimit = (__u64 )(u->dqb_bhardlimit << 1);
#line 67
  k->d_blk_softlimit = (__u64 )(u->dqb_bsoftlimit << 1);
#line 68
  k->d_icount = (__u64 )u->dqb_curinodes;
#line 69
  k->d_bcount = (__u64 )(u->dqb_curspace >> 9);
#line 70
  k->d_itimer = (__s32 )u->dqb_itime;
#line 71
  k->d_btimer = (__s32 )u->dqb_btime;
  }
#line 72
  return;
}
}
#line 77 "/home/wheatley/newnew/temp/quota-4.01/quotaio_xfs.c"
static int xfs_init_io(struct quota_handle *h ) 
{ 
  struct fs_quota_stat info ;
  int qcmd ;
  long tmp ;

  {
  {
#line 82
  qcmd = ((88 << 8) + 5) << 8;
#line 83
  memset((void *)(& info), 0, sizeof(struct fs_quota_stat ));
#line 84
  tmp = quotactl(qcmd, (char const   *)(h->qh_quotadev), (qid_t )0, (caddr_t )((void *)(& info)));
  }
#line 84
  if (tmp < 0L) {
#line 85
    return (-1);
  }
#line 86
  h->qh_info.dqi_bgrace = (time_t )info.qs_btimelimit;
#line 87
  h->qh_info.dqi_igrace = (time_t )info.qs_itimelimit;
#line 88
  h->qh_info.u.xfs_mdqi = info;
#line 89
  return (0);
}
}
#line 95 "/home/wheatley/newnew/temp/quota-4.01/quotaio_xfs.c"
static int xfs_write_info(struct quota_handle *h ) 
{ 
  struct fs_disk_quota xdqblk ;
  int qcmd ;
  long tmp ;

  {
#line 100
  if (h->qh_type == 0) {
#line 100
    if (! ((int )h->qh_info.u.xfs_mdqi.qs_flags & 1)) {
#line 100
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 100
  if (h->qh_type == 1) {
#line 100
    if (! ((int )h->qh_info.u.xfs_mdqi.qs_flags & (1 << 2))) {
#line 101
      return (0);
    }
  } else {
#line 101
    return (0);
  }
  {
#line 103
  memset((void *)(& xdqblk), 0, sizeof(struct fs_disk_quota ));
#line 105
  xdqblk.d_btimer = (__s32 )h->qh_info.dqi_bgrace;
#line 106
  xdqblk.d_itimer = (__s32 )h->qh_info.dqi_igrace;
#line 107
  xdqblk.d_fieldmask = (__u16 )((int )xdqblk.d_fieldmask | (((1 << 6) | (1 << 7)) | (1 << 8)));
#line 108
  qcmd = (((88 << 8) + 4) << 8) | (h->qh_type & 255);
#line 109
  tmp = quotactl(qcmd, (char const   *)(h->qh_quotadev), (qid_t )0, (caddr_t )((void *)(& xdqblk)));
  }
#line 109
  if (tmp < 0L) {
#line 110
    return (-1);
  }
#line 111
  return (0);
}
}
#line 117 "/home/wheatley/newnew/temp/quota-4.01/quotaio_xfs.c"
static struct dquot *xfs_read_dquot(struct quota_handle *h , qid_t id___0 ) 
{ 
  struct dquot *dquot ;
  struct dquot *tmp ;
  struct fs_disk_quota xdqblk ;
  int qcmd ;
  long tmp___0 ;

  {
  {
#line 119
  tmp = get_empty_dquot();
#line 119
  dquot = tmp;
#line 123
  dquot->dq_id = id___0;
#line 124
  dquot->dq_h = h;
  }
#line 126
  if (h->qh_type == 0) {
#line 126
    if (! ((int )h->qh_info.u.xfs_mdqi.qs_flags & 1)) {
#line 126
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 126
  if (h->qh_type == 1) {
#line 126
    if (! ((int )h->qh_info.u.xfs_mdqi.qs_flags & (1 << 2))) {
#line 127
      return (dquot);
    }
  } else {
#line 127
    return (dquot);
  }
  {
#line 129
  qcmd = (((88 << 8) + 3) << 8) | (h->qh_type & 255);
#line 130
  tmp___0 = quotactl(qcmd, (char const   *)(h->qh_quotadev), id___0, (caddr_t )((void *)(& xdqblk)));
  }
#line 130
  if (! (tmp___0 < 0L)) {
    {
#line 134
    xfs_kern2utildqblk(& dquot->dq_dqb, & xdqblk);
    }
  }
#line 136
  return (dquot);
}
}
#line 142 "/home/wheatley/newnew/temp/quota-4.01/quotaio_xfs.c"
static int xfs_commit_dquot(struct dquot *dquot , int flags___7 ) 
{ 
  struct quota_handle *h ;
  struct fs_disk_quota xdqblk ;
  qid_t id___0 ;
  int qcmd ;
  int tmp ;
  int tmp___0 ;
  long tmp___1 ;

  {
#line 144
  h = dquot->dq_h;
#line 146
  id___0 = dquot->dq_id;
#line 149
  if (h->qh_type == 0) {
#line 149
    if (! ((int )h->qh_info.u.xfs_mdqi.qs_flags & 1)) {
#line 149
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 149
  if (h->qh_type == 1) {
#line 149
    if (! ((int )h->qh_info.u.xfs_mdqi.qs_flags & (1 << 2))) {
#line 150
      return (0);
    }
  } else {
#line 150
    return (0);
  }
  {
#line 152
  xfs_util2kerndqblk(& xdqblk, & dquot->dq_dqb);
  }
#line 153
  if (h->qh_type == 0) {
#line 153
    if ((int )h->qh_info.u.xfs_mdqi.qs_flags & 1) {
#line 153
      tmp = 1;
    } else {
#line 153
      tmp = 1 << 2;
    }
  } else {
#line 153
    tmp = 1 << 2;
  }
  {
#line 153
  xdqblk.d_flags = (__s8 )((int )xdqblk.d_flags | tmp);
#line 154
  xdqblk.d_id = id___0;
#line 155
  tmp___0 = strcmp((char const   *)(h->qh_fstype), "gfs2");
  }
#line 155
  if (tmp___0 == 0) {
#line 156
    if (flags___7 & 5) {
#line 157
      xdqblk.d_fieldmask = (__u16 )((int )xdqblk.d_fieldmask | ((1 << 2) | (1 << 3)));
    }
#line 158
    if (flags___7 & 10) {
#line 159
      xdqblk.d_fieldmask = (__u16 )((int )xdqblk.d_fieldmask | (1 << 12));
    }
  } else {
#line 161
    xdqblk.d_fieldmask = (__u16 )((int )xdqblk.d_fieldmask | (((((1 | (1 << 1)) | (1 << 2)) | (1 << 3)) | (1 << 4)) | (1 << 5)));
  }
  {
#line 164
  qcmd = (((88 << 8) + 4) << 8) | (h->qh_type & 255);
#line 165
  tmp___1 = quotactl(qcmd, (char const   *)(h->qh_quotadev), id___0, (caddr_t )((void *)(& xdqblk)));
  }
#line 165
  if (! (tmp___1 < 0L)) {
#line 169
    return (0);
  }
#line 171
  return (-1);
}
}
#line 177 "/home/wheatley/newnew/temp/quota-4.01/quotaio_xfs.c"
static int xfs_get_dquot(struct dquot *dq ) 
{ 
  struct fs_disk_quota d ;
  int qcmd ;
  int ret ;
  long tmp ;
  int *tmp___0 ;

  {
  {
#line 180
  qcmd = (((88 << 8) + 3) << 8) | ((dq->dq_h)->qh_type & 255);
#line 183
  memset((void *)(& d), 0, sizeof(d));
#line 184
  tmp = quotactl(qcmd, (char const   *)((dq->dq_h)->qh_quotadev), dq->dq_id, (caddr_t )((void *)(& d)));
#line 184
  ret = (int )tmp;
  }
#line 185
  if (ret < 0) {
    {
#line 186
    tmp___0 = __errno_location();
    }
#line 186
    if (*tmp___0 == 2) {
#line 187
      return (0);
    }
#line 188
    return (-1);
  }
  {
#line 190
  xfs_kern2utildqblk(& dq->dq_dqb, & d);
  }
#line 191
  return (0);
}
}
#line 197 "/home/wheatley/newnew/temp/quota-4.01/quotaio_xfs.c"
static int xfs_scan_dquots(struct quota_handle *h , int (*process_dquot)(struct dquot *dquot ,
                                                                         char *dqname ) ) 
{ 
  int tmp ;

  {
#line 199
  if (h->qh_type == 0) {
#line 199
    if (! ((int )h->qh_info.u.xfs_mdqi.qs_flags & 1)) {
#line 199
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 199
  if (h->qh_type == 1) {
#line 199
    if (! ((int )h->qh_info.u.xfs_mdqi.qs_flags & (1 << 2))) {
#line 200
      return (0);
    }
  } else {
#line 200
    return (0);
  }
  {
#line 202
  tmp = generic_scan_dquots(h, process_dquot, & xfs_get_dquot);
  }
#line 202
  return (tmp);
}
}
#line 208 "/home/wheatley/newnew/temp/quota-4.01/quotaio_xfs.c"
static int xfs_report(struct quota_handle *h , int verbose ) 
{ 
  u_int16_t sbflags ;
  struct fs_quota_stat *info ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;
  char *tmp___18 ;
  char *tmp___19 ;
  char *tmp___20 ;
  char *tmp___21 ;
  char *tmp___22 ;
  char *tmp___23 ;
  char *tmp___24 ;
  char *tmp___25 ;
  char *tmp___26 ;
  char *tmp___27 ;
  char *tmp___28 ;
  char *tmp___29 ;
  char *tmp___30 ;
  char *tmp___31 ;
  char *tmp___32 ;

  {
#line 211
  info = & h->qh_info.u.xfs_mdqi;
#line 213
  if (! verbose) {
#line 214
    return (0);
  }
  {
#line 217
  tmp = type2name(h->qh_type);
#line 217
  tmp___0 = gettext("*** Status for %s quotas on device %s\n");
#line 217
  printf((char const   */* __restrict  */)tmp___0, tmp, h->qh_quotadev);
  }
#line 220
  if (h->qh_type == 0) {
#line 221
    if ((int )info->qs_flags & (1 << 1)) {
      {
#line 221
      tmp___1 = gettext("ON");
#line 221
      tmp___3 = tmp___1;
      }
    } else {
      {
#line 221
      tmp___2 = gettext("OFF");
#line 221
      tmp___3 = tmp___2;
      }
    }
#line 221
    if ((int )info->qs_flags & 1) {
      {
#line 221
      tmp___4 = gettext("ON");
#line 221
      tmp___6 = tmp___4;
      }
    } else {
      {
#line 221
      tmp___5 = gettext("OFF");
#line 221
      tmp___6 = tmp___5;
      }
    }
    {
#line 221
    tmp___7 = gettext("Accounting: %s; Enforcement: %s\n");
#line 221
    printf((char const   */* __restrict  */)tmp___7, tmp___6, tmp___3);
    }
  } else {
#line 225
    if ((int )info->qs_flags & (1 << 3)) {
      {
#line 225
      tmp___8 = gettext("ON");
#line 225
      tmp___10 = tmp___8;
      }
    } else {
      {
#line 225
      tmp___9 = gettext("OFF");
#line 225
      tmp___10 = tmp___9;
      }
    }
#line 225
    if ((int )info->qs_flags & (1 << 2)) {
      {
#line 225
      tmp___11 = gettext("ON");
#line 225
      tmp___13 = tmp___11;
      }
    } else {
      {
#line 225
      tmp___12 = gettext("OFF");
#line 225
      tmp___13 = tmp___12;
      }
    }
    {
#line 225
    tmp___14 = gettext("Accounting: %s; Enforcement: %s\n");
#line 225
    printf((char const   */* __restrict  */)tmp___14, tmp___13, tmp___10);
    }
  }
#line 235
  sbflags = (u_int16_t )(((int )info->qs_flags & 65280) >> 8);
#line 235
  if ((int )sbflags != 0) {
#line 236
    if (h->qh_type == 0) {
#line 237
      if ((int )sbflags & (1 << 1)) {
        {
#line 237
        tmp___15 = gettext("ON");
#line 237
        tmp___17 = tmp___15;
        }
      } else {
        {
#line 237
        tmp___16 = gettext("OFF");
#line 237
        tmp___17 = tmp___16;
        }
      }
#line 237
      if ((int )sbflags & 1) {
        {
#line 237
        tmp___18 = gettext("ON");
#line 237
        tmp___20 = tmp___18;
        }
      } else {
        {
#line 237
        tmp___19 = gettext("OFF");
#line 237
        tmp___20 = tmp___19;
        }
      }
      {
#line 237
      tmp___21 = gettext("Accounting [ondisk]: %s; Enforcement [ondisk]: %s\n");
#line 237
      printf((char const   */* __restrict  */)tmp___21, tmp___20, tmp___17);
      }
    } else {
#line 241
      if ((int )sbflags & (1 << 3)) {
        {
#line 241
        tmp___22 = gettext("ON");
#line 241
        tmp___24 = tmp___22;
        }
      } else {
        {
#line 241
        tmp___23 = gettext("OFF");
#line 241
        tmp___24 = tmp___23;
        }
      }
#line 241
      if ((int )sbflags & (1 << 2)) {
        {
#line 241
        tmp___25 = gettext("ON");
#line 241
        tmp___27 = tmp___25;
        }
      } else {
        {
#line 241
        tmp___26 = gettext("OFF");
#line 241
        tmp___27 = tmp___26;
        }
      }
      {
#line 241
      tmp___28 = gettext("Accounting [ondisk]: %s; Enforcement [ondisk]: %s\n");
#line 241
      printf((char const   */* __restrict  */)tmp___28, tmp___27, tmp___24);
      }
    }
  }
#line 248
  if (h->qh_type == 0) {
#line 249
    if (info->qs_uquota.qfs_ino == 0xffffffffffffffffULL) {
      {
#line 250
      tmp___29 = gettext("Inode: none\n");
#line 250
      printf((char const   */* __restrict  */)tmp___29);
      }
    } else
#line 249
    if (info->qs_uquota.qfs_ino == 0ULL) {
      {
#line 250
      tmp___29 = gettext("Inode: none\n");
#line 250
      printf((char const   */* __restrict  */)tmp___29);
      }
    } else {
      {
#line 252
      tmp___30 = gettext("Inode: #%llu (%llu blocks, %u extents)\n");
#line 252
      printf((char const   */* __restrict  */)tmp___30, info->qs_uquota.qfs_ino, info->qs_uquota.qfs_nblks,
             info->qs_uquota.qfs_nextents);
      }
    }
  } else
#line 258
  if (info->qs_gquota.qfs_ino == 0xffffffffffffffffULL) {
    {
#line 259
    tmp___31 = gettext("Inode: none\n");
#line 259
    printf((char const   */* __restrict  */)tmp___31);
    }
  } else {
    {
#line 261
    tmp___32 = gettext("Inode: #%llu (%llu blocks, %u extents)\n");
#line 261
    printf((char const   */* __restrict  */)tmp___32, info->qs_gquota.qfs_ino, info->qs_gquota.qfs_nblks,
           info->qs_gquota.qfs_nextents);
    }
  }
#line 266
  return (0);
}
}
#line 386 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 433
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sscanf)(char const   * __restrict  __s ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 622
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 749
extern int fseek(FILE *__stream , long __off , int __whence ) ;
#line 69 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) memcmp)(void const   *__s1 ,
                                                                                               void const   *__s2 ,
                                                                                               size_t __n )  __attribute__((__pure__)) ;
#line 147
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 337 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __off64_t ( __attribute__((__leaf__)) lseek)(int __fd ,
                                                                                  __off64_t __offset ,
                                                                                  int __whence )  __asm__("lseek64")  ;
#line 360
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 3 "/home/wheatley/newnew/temp/quota-4.01/bylabel.h"
char const   *get_device_name(char const   *item ) ;
#line 31 "/home/wheatley/newnew/temp/quota-4.01/bylabel.c"
static struct uuidCache_s *uuidCache  =    (struct uuidCache_s *)((void *)0);
#line 74 "/home/wheatley/newnew/temp/quota-4.01/bylabel.c"
static int get_label_uuid(char const   *device , char **label , char *uuid ) 
{ 
  int fd ;
  int rv ;
  size_t namesize ;
  struct ext2_super_block e2sb ;
  struct xfs_super_block xfsb ;
  struct reiserfs_super_block reisersb ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  __off64_t tmp___2 ;
  ssize_t tmp___3 ;
  int tmp___4 ;
  __off64_t tmp___5 ;
  ssize_t tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  __off64_t tmp___9 ;
  ssize_t tmp___10 ;

  {
  {
#line 79
  rv = 1;
#line 85
  fd = open(device, 0);
  }
#line 86
  if (fd < 0) {
#line 87
    return (rv);
  }
  {
#line 89
  tmp___9 = lseek(fd, (__off64_t )1024, 0);
  }
#line 89
  if (tmp___9 == 1024L) {
    {
#line 89
    tmp___10 = read(fd, (void *)((char *)(& e2sb)), sizeof(e2sb));
    }
#line 89
    if ((unsigned long )tmp___10 == sizeof(e2sb)) {
#line 89
      if ((uint )e2sb.s_magic[0] + ((uint )e2sb.s_magic[1] << 8) == 61267U) {
        {
#line 92
        memcpy((void */* __restrict  */)uuid, (void const   */* __restrict  */)(e2sb.s_uuid),
               sizeof(e2sb.s_uuid));
#line 93
        namesize = sizeof(e2sb.s_volume_name);
#line 94
        tmp = smalloc(namesize + 1UL);
#line 94
        *label = (char *)tmp;
#line 95
        sstrncpy(*label, (char const   *)((char *)(e2sb.s_volume_name)), namesize);
#line 96
        rv = 0;
        }
      } else {
#line 89
        goto _L___3;
      }
    } else {
#line 89
      goto _L___3;
    }
  } else {
    _L___3: /* CIL Label */ 
    {
#line 98
    tmp___5 = lseek(fd, (__off64_t )0, 0);
    }
#line 98
    if (tmp___5 == 0L) {
      {
#line 98
      tmp___6 = read(fd, (void *)((char *)(& xfsb)), sizeof(xfsb));
      }
#line 98
      if ((unsigned long )tmp___6 == sizeof(xfsb)) {
        {
#line 98
        tmp___7 = strncmp((char const   *)((char *)(& xfsb.s_magic)), "XFSB", (size_t )4);
        }
#line 98
        if (tmp___7 == 0) {
#line 98
          goto _L___0;
        } else {
          {
#line 98
          tmp___8 = strncmp((char const   *)((char *)(& xfsb.s_magic)), "BSFX", (size_t )4);
          }
#line 98
          if (tmp___8 == 0) {
            _L___0: /* CIL Label */ 
            {
#line 102
            memcpy((void */* __restrict  */)uuid, (void const   */* __restrict  */)(xfsb.s_uuid),
                   sizeof(xfsb.s_uuid));
#line 103
            namesize = sizeof(xfsb.s_fsname);
#line 104
            tmp___0 = smalloc(namesize + 1UL);
#line 104
            *label = (char *)tmp___0;
#line 105
            sstrncpy(*label, (char const   *)((char *)(xfsb.s_fsname)), namesize);
#line 106
            rv = 0;
            }
          } else {
#line 98
            goto _L___1;
          }
        }
      } else {
#line 98
        goto _L___1;
      }
    } else {
      _L___1: /* CIL Label */ 
      {
#line 108
      tmp___2 = lseek(fd, (__off64_t )65536, 0);
      }
#line 108
      if (tmp___2 == 65536L) {
        {
#line 108
        tmp___3 = read(fd, (void *)((char *)(& reisersb)), sizeof(reisersb));
        }
#line 108
        if ((unsigned long )tmp___3 == sizeof(reisersb)) {
          {
#line 108
          tmp___4 = strncmp((char const   *)((char *)(& reisersb.s_magic)), "ReIsEr2Fs",
                            (size_t )9);
          }
#line 108
          if (! tmp___4) {
            {
#line 111
            memcpy((void */* __restrict  */)uuid, (void const   */* __restrict  */)(reisersb.s_uuid),
                   sizeof(reisersb.s_uuid));
#line 112
            namesize = sizeof(reisersb.s_volume_name);
#line 113
            tmp___1 = smalloc(namesize + 1UL);
#line 113
            *label = (char *)tmp___1;
#line 114
            sstrncpy(*label, (char const   *)((char *)(reisersb.s_volume_name)), namesize);
#line 115
            rv = 0;
            }
          }
        }
      }
    }
  }
  {
#line 117
  close(fd);
  }
#line 118
  return (rv);
}
}
#line 121 "/home/wheatley/newnew/temp/quota-4.01/bylabel.c"
static void uuidcache_addentry(char *device , char *label , char *uuid ) 
{ 
  struct uuidCache_s *last ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 125
  if (! uuidCache) {
    {
#line 126
    tmp = smalloc(sizeof(*uuidCache));
#line 126
    uuidCache = (struct uuidCache_s *)tmp;
#line 126
    last = uuidCache;
    }
  } else {
#line 129
    last = uuidCache;
    {
#line 129
    while (1) {
      while_continue: /* CIL Label */ ;
#line 129
      if (! last->next) {
#line 129
        goto while_break;
      }
#line 129
      last = last->next;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 130
    tmp___0 = smalloc(sizeof(*uuidCache));
#line 130
    last->next = (struct uuidCache_s *)tmp___0;
#line 131
    last = last->next;
    }
  }
  {
#line 133
  last->next = (struct uuidCache_s *)((void *)0);
#line 134
  last->device = device;
#line 135
  last->label = label;
#line 136
  memcpy((void */* __restrict  */)(last->uuid), (void const   */* __restrict  */)uuid,
         sizeof(last->uuid));
  }
#line 137
  return;
}
}
#line 144 "/home/wheatley/newnew/temp/quota-4.01/bylabel.c"
static char ptname[100]  ;
#line 139 "/home/wheatley/newnew/temp/quota-4.01/bylabel.c"
static void uuidcache_init(void) 
{ 
  char line___0[100] ;
  char *s ;
  int ma ;
  int mi ;
  int sz ;
  FILE *procpt ;
  char uuid[16] ;
  char *label ;
  char device[110] ;
  int firstPass ;
  int handleOnFirst ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  unsigned short const   **tmp___4 ;
  char *tmp___5 ;

  {
#line 151
  if (uuidCache) {
#line 152
    return;
  }
  {
#line 154
  procpt = fopen((char const   */* __restrict  */)"/proc/partitions", (char const   */* __restrict  */)"r");
  }
#line 155
  if (! procpt) {
#line 156
    return;
  }
#line 158
  firstPass = 1;
  {
#line 158
  while (1) {
    while_continue: /* CIL Label */ ;
#line 158
    if (! (firstPass >= 0)) {
#line 158
      goto while_break;
    }
    {
#line 159
    fseek(procpt, 0L, 0);
    }
    {
#line 161
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 161
      tmp___5 = fgets((char */* __restrict  */)(line___0), (int )sizeof(line___0),
                      (FILE */* __restrict  */)procpt);
      }
#line 161
      if (! tmp___5) {
#line 161
        goto while_break___0;
      }
      {
#line 162
      tmp = sscanf((char const   */* __restrict  */)(line___0), (char const   */* __restrict  */)" %d %d %d %[^\n ]",
                   & ma, & mi, & sz, ptname);
      }
#line 162
      if (tmp != 4) {
#line 163
        goto while_continue___0;
      }
#line 166
      if (sz == 1) {
#line 167
        goto while_continue___0;
      }
      {
#line 170
      tmp___0 = strncmp((char const   *)(ptname), "md", (size_t )2);
      }
#line 170
      if (tmp___0) {
#line 170
        tmp___1 = 0;
      } else {
#line 170
        tmp___1 = 1;
      }
#line 170
      handleOnFirst = tmp___1;
#line 171
      if (firstPass != handleOnFirst) {
#line 172
        goto while_continue___0;
      }
#line 178
      s = ptname;
      {
#line 178
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 178
        if (! *s) {
#line 178
          goto while_break___1;
        }
#line 178
        s ++;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 179
      tmp___4 = __ctype_b_loc();
      }
#line 179
      if ((int const   )*(*tmp___4 + (int )*(s + -1)) & 2048) {
        {
#line 189
        snprintf((char */* __restrict  */)(device), sizeof(device), (char const   */* __restrict  */)"%s/%s",
                 "/dev", ptname);
#line 190
        tmp___3 = get_label_uuid((char const   *)(device), & label, uuid);
        }
#line 190
        if (! tmp___3) {
          {
#line 191
          tmp___2 = sstrdup((char const   *)(device));
#line 191
          uuidcache_addentry(tmp___2, label, uuid);
          }
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 158
    firstPass --;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 196
  fclose(procpt);
  }
#line 197
  return;
}
}
#line 202 "/home/wheatley/newnew/temp/quota-4.01/bylabel.c"
static char *get_spec_by_x(int n , char const   *t ) 
{ 
  struct uuidCache_s *uc ;
  char *tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 206
  uuidcache_init();
#line 207
  uc = uuidCache;
  }
  {
#line 209
  while (1) {
    while_continue: /* CIL Label */ ;
#line 209
    if (! uc) {
#line 209
      goto while_break;
    }
    {
#line 211
    if (n == 1) {
#line 211
      goto case_1;
    }
#line 215
    if (n == 2) {
#line 215
      goto case_2;
    }
#line 210
    goto switch_break;
    case_1: /* CIL Label */ 
    {
#line 212
    tmp___0 = memcmp((void const   *)t, (void const   *)(uc->uuid), sizeof(uc->uuid));
    }
#line 212
    if (! tmp___0) {
      {
#line 213
      tmp = sstrdup((char const   *)uc->device);
      }
#line 213
      return (tmp);
    }
#line 214
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 216
    tmp___2 = strcmp(t, (char const   *)uc->label);
    }
#line 216
    if (! tmp___2) {
      {
#line 217
      tmp___1 = sstrdup((char const   *)uc->device);
      }
#line 217
      return (tmp___1);
    }
#line 218
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 220
    uc = uc->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 222
  return ((char *)((void *)0));
}
}
#line 225 "/home/wheatley/newnew/temp/quota-4.01/bylabel.c"
static u_char fromhex(char c ) 
{ 
  unsigned short const   **tmp ;
  unsigned short const   **tmp___0 ;

  {
  {
#line 227
  tmp___0 = __ctype_b_loc();
  }
#line 227
  if ((int const   )*(*tmp___0 + (int )c) & 2048) {
#line 228
    return ((u_char )((int )c - 48));
  } else {
    {
#line 229
    tmp = __ctype_b_loc();
    }
#line 229
    if ((int const   )*(*tmp + (int )c) & 512) {
#line 230
      return ((u_char )(((int )c - 97) + 10));
    } else {
#line 232
      return ((u_char )(((int )c - 65) + 10));
    }
  }
}
}
#line 235 "/home/wheatley/newnew/temp/quota-4.01/bylabel.c"
static char *get_spec_by_uuid(char const   *s ) 
{ 
  u_char uuid[16] ;
  int i ;
  size_t tmp ;
  unsigned short const   **tmp___0 ;
  unsigned short const   **tmp___1 ;
  u_char tmp___2 ;
  u_char tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;

  {
  {
#line 240
  tmp = strlen(s);
  }
#line 240
  if (tmp != 36UL) {
#line 241
    goto bad_uuid;
  } else
#line 240
  if ((int const   )*(s + 8) != 45) {
#line 241
    goto bad_uuid;
  } else
#line 240
  if ((int const   )*(s + 13) != 45) {
#line 241
    goto bad_uuid;
  } else
#line 240
  if ((int const   )*(s + 18) != 45) {
#line 241
    goto bad_uuid;
  } else
#line 240
  if ((int const   )*(s + 23) != 45) {
#line 241
    goto bad_uuid;
  }
#line 242
  i = 0;
  {
#line 242
  while (1) {
    while_continue: /* CIL Label */ ;
#line 242
    if (! (i < 16)) {
#line 242
      goto while_break;
    }
#line 243
    if ((int const   )*s == 45) {
#line 244
      s ++;
    }
    {
#line 245
    tmp___0 = __ctype_b_loc();
    }
#line 245
    if ((int const   )*(*tmp___0 + (int )*(s + 0)) & 4096) {
      {
#line 245
      tmp___1 = __ctype_b_loc();
      }
#line 245
      if (! ((int const   )*(*tmp___1 + (int )*(s + 1)) & 4096)) {
#line 246
        goto bad_uuid;
      }
    } else {
#line 246
      goto bad_uuid;
    }
    {
#line 247
    tmp___2 = fromhex((char )*(s + 0));
#line 247
    tmp___3 = fromhex((char )*(s + 1));
#line 247
    uuid[i] = (u_char )(((int )tmp___2 << 4) | (int )tmp___3);
#line 248
    s += 2;
#line 242
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 250
  tmp___4 = get_spec_by_x(1, (char const   *)((char *)(uuid)));
  }
#line 250
  return (tmp___4);
  bad_uuid: 
  {
#line 253
  tmp___5 = gettext("Found an invalid UUID: %s\n");
#line 253
  errstr(tmp___5, s);
  }
#line 254
  return ((char *)((void *)0));
}
}
#line 257 "/home/wheatley/newnew/temp/quota-4.01/bylabel.c"
static char *get_spec_by_volume_label(char const   *s ) 
{ 
  char *tmp ;

  {
  {
#line 259
  tmp = get_spec_by_x(2, s);
  }
#line 259
  return (tmp);
}
}
#line 262 "/home/wheatley/newnew/temp/quota-4.01/bylabel.c"
char const   *get_device_name(char const   *item ) 
{ 
  char const   *rc ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;

  {
  {
#line 266
  tmp___3 = strncmp(item, "UUID=", (size_t )5);
  }
#line 266
  if (tmp___3) {
    {
#line 268
    tmp___2 = strncmp(item, "LABEL=", (size_t )6);
    }
#line 268
    if (tmp___2) {
      {
#line 271
      tmp___1 = sstrdup(item);
#line 271
      rc = (char const   *)tmp___1;
      }
    } else {
      {
#line 269
      tmp___0 = get_spec_by_volume_label(item + 6);
#line 269
      rc = (char const   *)tmp___0;
      }
    }
  } else {
    {
#line 267
    tmp = get_spec_by_uuid(item + 5);
#line 267
    rc = (char const   *)tmp;
    }
  }
#line 272
  if (! rc) {
    {
#line 273
    tmp___4 = gettext("Error checking device name: %s\n");
#line 273
    errstr(tmp___4, item);
    }
  }
#line 274
  return (rc);
}
}
#line 366 "/usr/include/unistd.h"
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 220 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2), __leaf__)) fstat)(int __fd ,
                                                                                            struct stat *__buf )  __asm__("fstat64")  ;
#line 50 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v1.c"
static int v1_check_file(int fd , int type , int fmt___7 ) ;
#line 51
static int v1_init_io(struct quota_handle *h ) ;
#line 52
static int v1_new_io(struct quota_handle *h ) ;
#line 53
static int v1_write_info(struct quota_handle *h ) ;
#line 54
static struct dquot *v1_read_dquot(struct quota_handle *h , qid_t id___0 ) ;
#line 55
static int v1_commit_dquot(struct dquot *dquot , int flags___7 ) ;
#line 56
static int v1_scan_dquots(struct quota_handle *h , int (*process_dquot)(struct dquot *dquot ,
                                                                        char *dqname ) ) ;
#line 58 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v1.c"
struct quotafile_ops quotafile_ops_1  = 
#line 58
     {& v1_check_file, & v1_init_io, & v1_new_io, (int (*)(struct quota_handle *h ))0,
    & v1_write_info, & v1_read_dquot, & v1_commit_dquot, & v1_scan_dquots, (int (*)(struct quota_handle *h ,
                                                                                    int verbose ))0};
#line 71 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v1.c"
__inline static void v1_disk2memdqblk(struct util_dqblk *m , struct v1_disk_dqblk *d ) 
{ 


  {
#line 73
  m->dqb_ihardlimit = (qsize_t )d->dqb_ihardlimit;
#line 74
  m->dqb_isoftlimit = (qsize_t )d->dqb_isoftlimit;
#line 75
  m->dqb_bhardlimit = (qsize_t )d->dqb_bhardlimit;
#line 76
  m->dqb_bsoftlimit = (qsize_t )d->dqb_bsoftlimit;
#line 77
  m->dqb_curinodes = (qsize_t )d->dqb_curinodes;
#line 78
  m->dqb_curspace = (qsize_t )d->dqb_curblocks * (qsize_t )(1 << 10);
#line 79
  m->dqb_itime = d->dqb_itime;
#line 80
  m->dqb_btime = d->dqb_btime;
#line 81
  return;
}
}
#line 86 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v1.c"
__inline static void v1_mem2diskdqblk(struct v1_disk_dqblk *d , struct util_dqblk *m ) 
{ 


  {
#line 88
  d->dqb_ihardlimit = (u_int32_t )m->dqb_ihardlimit;
#line 89
  d->dqb_isoftlimit = (u_int32_t )m->dqb_isoftlimit;
#line 90
  d->dqb_bhardlimit = (u_int32_t )m->dqb_bhardlimit;
#line 91
  d->dqb_bsoftlimit = (u_int32_t )m->dqb_bsoftlimit;
#line 92
  d->dqb_curinodes = (u_int32_t )m->dqb_curinodes;
#line 93
  d->dqb_curblocks = (u_int32_t )(m->dqb_curspace >> 10);
#line 94
  d->dqb_itime = m->dqb_itime;
#line 95
  d->dqb_btime = m->dqb_btime;
#line 96
  return;
}
}
#line 99 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v1.c"
__inline static void v1_kern2utildqblk(struct util_dqblk *u , struct v1_kern_dqblk *k ) 
{ 


  {
#line 101
  u->dqb_ihardlimit = (qsize_t )k->dqb_ihardlimit;
#line 102
  u->dqb_isoftlimit = (qsize_t )k->dqb_isoftlimit;
#line 103
  u->dqb_bhardlimit = (qsize_t )k->dqb_bhardlimit;
#line 104
  u->dqb_bsoftlimit = (qsize_t )k->dqb_bsoftlimit;
#line 105
  u->dqb_curinodes = (qsize_t )k->dqb_curinodes;
#line 106
  u->dqb_curspace = (qsize_t )k->dqb_curblocks << 10;
#line 107
  u->dqb_itime = k->dqb_itime;
#line 108
  u->dqb_btime = k->dqb_btime;
#line 109
  return;
}
}
#line 112 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v1.c"
__inline static void v1_util2kerndqblk(struct v1_kern_dqblk *k , struct util_dqblk *u ) 
{ 


  {
#line 114
  k->dqb_ihardlimit = (u_int32_t )u->dqb_ihardlimit;
#line 115
  k->dqb_isoftlimit = (u_int32_t )u->dqb_isoftlimit;
#line 116
  k->dqb_bhardlimit = (u_int32_t )u->dqb_bhardlimit;
#line 117
  k->dqb_bsoftlimit = (u_int32_t )u->dqb_bsoftlimit;
#line 118
  k->dqb_curinodes = (u_int32_t )u->dqb_curinodes;
#line 119
  k->dqb_curblocks = (u_int32_t )(((u->dqb_curspace + (qsize_t )(1 << 10)) - 1L) >> 10);
#line 120
  k->dqb_itime = u->dqb_itime;
#line 121
  k->dqb_btime = u->dqb_btime;
#line 122
  return;
}
}
#line 127 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v1.c"
static int v1_check_file(int fd , int type , int fmt___7 ) 
{ 
  struct stat st ;
  int tmp ;

  {
  {
#line 131
  tmp = fstat(fd, & st);
  }
#line 131
  if (tmp < 0) {
#line 132
    return (0);
  }
#line 133
  if (! st.st_size) {
#line 134
    return (0);
  } else
#line 133
  if ((unsigned long )st.st_size % sizeof(struct v1_disk_dqblk )) {
#line 134
    return (0);
  }
#line 135
  return (1);
}
}
#line 141 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v1.c"
static int v1_init_io(struct quota_handle *h ) 
{ 
  int tmp ;
  struct v1_kern_dqblk kdqblk ;
  time_t tmp___0 ;
  int *tmp___1 ;
  long tmp___2 ;
  struct v1_disk_dqblk ddqblk ;
  ssize_t tmp___3 ;

  {
#line 143
  if (h->qh_io_flags & 1) {
#line 144
    if (kernel_iface == 3) {
      {
#line 145
      tmp = vfs_get_info(h);
      }
#line 145
      if (tmp < 0) {
#line 146
        return (-1);
      }
    } else {
      {
#line 151
      tmp___2 = quotactl((768 << 8) | (h->qh_type & 255), (char const   *)(h->qh_quotadev),
                         (qid_t )0, (caddr_t )((void *)(& kdqblk)));
      }
#line 151
      if (tmp___2 < 0L) {
        {
#line 152
        tmp___1 = __errno_location();
        }
#line 152
        if (*tmp___1 == 1) {
#line 153
          tmp___0 = (time_t )0;
#line 153
          h->qh_info.dqi_igrace = tmp___0;
#line 153
          h->qh_info.dqi_bgrace = tmp___0;
        } else {
#line 156
          return (-1);
        }
      } else {
#line 159
        h->qh_info.dqi_bgrace = kdqblk.dqb_btime;
#line 160
        h->qh_info.dqi_igrace = kdqblk.dqb_itime;
      }
    }
  } else {
    {
#line 167
    lseek(h->qh_fd, (__off64_t )0, 0);
#line 168
    tmp___3 = read(h->qh_fd, (void *)(& ddqblk), sizeof(ddqblk));
    }
#line 168
    if ((unsigned long )tmp___3 != sizeof(ddqblk)) {
#line 169
      return (-1);
    }
#line 170
    h->qh_info.dqi_bgrace = ddqblk.dqb_btime;
#line 171
    h->qh_info.dqi_igrace = ddqblk.dqb_itime;
  }
#line 173
  if (! h->qh_info.dqi_bgrace) {
#line 174
    h->qh_info.dqi_bgrace = (time_t )604800;
  }
#line 175
  if (! h->qh_info.dqi_igrace) {
#line 176
    h->qh_info.dqi_igrace = (time_t )604800;
  }
#line 177
  h->qh_info.dqi_max_b_limit = (uint64_t )(~ ((uint32_t )0));
#line 178
  h->qh_info.dqi_max_i_limit = (uint64_t )(~ ((uint32_t )0));
#line 179
  h->qh_info.dqi_max_b_usage = 4294967295UL << 10;
#line 180
  h->qh_info.dqi_max_i_usage = (uint64_t )(~ ((uint32_t )0));
#line 182
  return (0);
}
}
#line 188 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v1.c"
static int v1_new_io(struct quota_handle *h ) 
{ 
  struct v1_disk_dqblk ddqblk ;
  ssize_t tmp ;

  {
  {
#line 193
  memset((void *)(& ddqblk), 0, sizeof(ddqblk));
#line 194
  ddqblk.dqb_btime = (time_t )604800;
#line 195
  ddqblk.dqb_itime = (time_t )604800;
#line 196
  h->qh_info.dqi_bgrace = (time_t )604800;
#line 197
  h->qh_info.dqi_igrace = (time_t )604800;
#line 198
  h->qh_info.dqi_max_b_limit = (uint64_t )(~ ((uint32_t )0));
#line 199
  h->qh_info.dqi_max_i_limit = (uint64_t )(~ ((uint32_t )0));
#line 200
  h->qh_info.dqi_max_b_usage = 4294967295UL << 10;
#line 201
  h->qh_info.dqi_max_i_usage = (uint64_t )(~ ((uint32_t )0));
#line 202
  lseek(h->qh_fd, (__off64_t )0, 0);
#line 203
  tmp = write(h->qh_fd, (void const   *)(& ddqblk), sizeof(ddqblk));
  }
#line 203
  if ((unsigned long )tmp != sizeof(ddqblk)) {
#line 204
    return (-1);
  }
#line 205
  return (0);
}
}
#line 211 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v1.c"
static int v1_write_info(struct quota_handle *h ) 
{ 
  char *tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  struct v1_kern_dqblk kdqblk ;
  long tmp___2 ;
  long tmp___3 ;
  struct v1_disk_dqblk ddqblk ;
  ssize_t tmp___4 ;
  ssize_t tmp___5 ;

  {
#line 213
  if (h->qh_io_flags & 4) {
    {
#line 214
    tmp = gettext("Trying to write info to readonly quotafile on %s.\n");
#line 214
    errstr(tmp, h->qh_quotadev);
#line 215
    tmp___0 = __errno_location();
#line 215
    *tmp___0 = 1;
    }
#line 216
    return (-1);
  }
#line 218
  if (h->qh_io_flags & 1) {
#line 219
    if (kernel_iface == 3) {
      {
#line 220
      tmp___1 = vfs_set_info(h, 3);
      }
#line 220
      if (tmp___1 < 0) {
#line 221
        return (-1);
      }
    } else {
      {
#line 226
      tmp___2 = quotactl((768 << 8) | (h->qh_type & 255), (char const   *)(h->qh_quotadev),
                         (qid_t )0, (caddr_t )((void *)(& kdqblk)));
      }
#line 226
      if (tmp___2 < 0L) {
#line 227
        return (-1);
      }
      {
#line 228
      kdqblk.dqb_btime = h->qh_info.dqi_bgrace;
#line 229
      kdqblk.dqb_itime = h->qh_info.dqi_igrace;
#line 230
      tmp___3 = quotactl((1024 << 8) | (h->qh_type & 255), (char const   *)(h->qh_quotadev),
                         (qid_t )0, (caddr_t )((void *)(& kdqblk)));
      }
#line 230
      if (tmp___3 < 0L) {
#line 231
        return (-1);
      }
    }
  } else {
    {
#line 237
    lseek(h->qh_fd, (__off64_t )0, 0);
#line 238
    tmp___4 = read(h->qh_fd, (void *)(& ddqblk), sizeof(ddqblk));
    }
#line 238
    if ((unsigned long )tmp___4 != sizeof(ddqblk)) {
#line 239
      return (-1);
    }
    {
#line 240
    ddqblk.dqb_btime = h->qh_info.dqi_bgrace;
#line 241
    ddqblk.dqb_itime = h->qh_info.dqi_igrace;
#line 242
    lseek(h->qh_fd, (__off64_t )0, 0);
#line 243
    tmp___5 = write(h->qh_fd, (void const   *)(& ddqblk), sizeof(ddqblk));
    }
#line 243
    if ((unsigned long )tmp___5 != sizeof(ddqblk)) {
#line 244
      return (-1);
    }
  }
#line 246
  return (0);
}
}
#line 253 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v1.c"
static struct dquot *v1_read_dquot(struct quota_handle *h , qid_t id___0 ) 
{ 
  struct v1_disk_dqblk ddqblk ;
  struct dquot *dquot ;
  struct dquot *tmp ;
  int tmp___0 ;
  struct v1_kern_dqblk kdqblk ;
  long tmp___1 ;
  ssize_t tmp___2 ;

  {
  {
#line 256
  tmp = get_empty_dquot();
#line 256
  dquot = tmp;
#line 258
  dquot->dq_id = id___0;
#line 259
  dquot->dq_h = h;
  }
#line 260
  if (h->qh_io_flags & 1) {
#line 261
    if (kernel_iface == 3) {
      {
#line 262
      tmp___0 = vfs_get_dquot(dquot);
      }
#line 262
      if (tmp___0 < 0) {
        {
#line 263
        free((void *)dquot);
        }
#line 264
        return ((struct dquot *)((void *)0));
      }
    } else {
      {
#line 270
      tmp___1 = quotactl((768 << 8) | (h->qh_type & 255), (char const   *)(h->qh_quotadev),
                         id___0, (caddr_t )((void *)(& kdqblk)));
      }
#line 270
      if (tmp___1 < 0L) {
        {
#line 271
        free((void *)dquot);
        }
#line 272
        return ((struct dquot *)((void *)0));
      }
      {
#line 274
      v1_kern2utildqblk(& dquot->dq_dqb, & kdqblk);
      }
    }
  } else {
    {
#line 278
    lseek(h->qh_fd, (loff_t )((unsigned long )id___0 * sizeof(struct v1_disk_dqblk )),
          0);
#line 279
    tmp___2 = read(h->qh_fd, (void *)(& ddqblk), sizeof(ddqblk));
    }
    {
#line 280
    if (tmp___2 == 0L) {
#line 280
      goto case_0;
    }
#line 287
    if (tmp___2 == (ssize_t )sizeof(struct v1_disk_dqblk )) {
#line 287
      goto case_exp;
    }
#line 290
    goto switch_default;
    case_0: /* CIL Label */ 
    {
#line 285
    memset((void *)(& dquot->dq_dqb), 0, sizeof(struct util_dqblk ));
    }
#line 286
    goto switch_break;
    case_exp: /* CIL Label */ 
    {
#line 288
    v1_disk2memdqblk(& dquot->dq_dqb, & ddqblk);
    }
#line 289
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 291
    free((void *)dquot);
    }
#line 292
    return ((struct dquot *)((void *)0));
    switch_break: /* CIL Label */ ;
    }
  }
#line 295
  return (dquot);
}
}
#line 302 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v1.c"
static int v1_commit_dquot(struct dquot *dquot , int flags___7 ) 
{ 
  struct v1_disk_dqblk ddqblk ;
  struct quota_handle *h ;
  char *tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  struct v1_kern_dqblk kdqblk ;
  int cmd ;
  int *tmp___2 ;
  long tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;
  ssize_t tmp___6 ;

  {
#line 305
  h = dquot->dq_h;
#line 307
  if (h->qh_io_flags & 4) {
    {
#line 308
    tmp = gettext("Trying to write quota to readonly quotafile on %s\n");
#line 308
    errstr(tmp, h->qh_quotadev);
#line 309
    tmp___0 = __errno_location();
#line 309
    *tmp___0 = 1;
    }
#line 310
    return (-1);
  }
#line 312
  if (h->qh_io_flags & 1) {
#line 313
    if (kernel_iface == 3) {
      {
#line 314
      tmp___1 = vfs_set_dquot(dquot, flags___7);
      }
#line 314
      if (tmp___1 < 0) {
#line 315
        return (-1);
      }
    } else {
#line 321
      if (flags___7 == 10) {
#line 322
        cmd = 1280;
      } else
#line 323
      if (flags___7 == 5) {
#line 324
        cmd = 1792;
      } else
#line 325
      if (flags___7 & 48) {
        {
#line 326
        tmp___2 = __errno_location();
#line 326
        *tmp___2 = 22;
        }
#line 327
        return (-1);
      } else {
#line 330
        cmd = 1024;
      }
      {
#line 331
      v1_util2kerndqblk(& kdqblk, & dquot->dq_dqb);
#line 332
      tmp___3 = quotactl((cmd << 8) | (h->qh_type & 255), (char const   *)(h->qh_quotadev),
                         dquot->dq_id, (caddr_t )((void *)(& kdqblk)));
      }
#line 332
      if (tmp___3 < 0L) {
#line 334
        return (-1);
      }
    }
  } else {
    {
#line 338
    tmp___5 = check_dquot_range(dquot);
    }
#line 338
    if (tmp___5 < 0) {
      {
#line 339
      tmp___4 = __errno_location();
#line 339
      *tmp___4 = 34;
      }
#line 340
      return (-1);
    }
    {
#line 342
    v1_mem2diskdqblk(& ddqblk, & dquot->dq_dqb);
#line 343
    lseek(h->qh_fd, (loff_t )((unsigned long )dquot->dq_id * sizeof(struct v1_disk_dqblk )),
          0);
#line 344
    tmp___6 = write(h->qh_fd, (void const   *)(& ddqblk), sizeof(ddqblk));
    }
#line 344
    if ((unsigned long )tmp___6 != sizeof(ddqblk)) {
#line 345
      return (-1);
    }
  }
#line 347
  return (0);
}
}
#line 355 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v1.c"
static int v1_scan_dquots(struct quota_handle *h , int (*process_dquot)(struct dquot *dquot ,
                                                                        char *dqname ) ) 
{ 
  int rd ;
  int scanbufpos ;
  int scanbufsize ;
  char scanbuf[sizeof(struct v1_disk_dqblk ) * 256UL] ;
  struct v1_disk_dqblk *ddqblk ;
  struct dquot *dquot ;
  struct dquot *tmp ;
  qid_t id___0 ;
  ssize_t tmp___0 ;

  {
  {
#line 357
  scanbufpos = 0;
#line 357
  scanbufsize = 0;
#line 360
  tmp = get_empty_dquot();
#line 360
  dquot = tmp;
#line 361
  id___0 = (qid_t )0;
#line 363
  memset((void *)dquot, 0, sizeof(*dquot));
#line 364
  dquot->dq_h = h;
#line 365
  lseek(h->qh_fd, (__off64_t )0, 0);
#line 366
  id___0 = (qid_t )0;
  }
  {
#line 366
  while (1) {
    while_continue: /* CIL Label */ ;
#line 367
    if (scanbufpos >= scanbufsize) {
      {
#line 368
      tmp___0 = read(h->qh_fd, (void *)(scanbuf), sizeof(scanbuf));
#line 368
      rd = (int )tmp___0;
      }
#line 369
      if (rd < 0) {
#line 370
        goto out_err;
      } else
#line 369
      if ((unsigned long )rd % sizeof(struct v1_disk_dqblk )) {
#line 370
        goto out_err;
      }
#line 371
      if (! rd) {
#line 372
        goto while_break;
      }
#line 373
      scanbufpos = 0;
#line 374
      scanbufsize = (int )((unsigned long )rd / sizeof(struct v1_disk_dqblk ));
    }
#line 376
    ddqblk = (struct v1_disk_dqblk *)(scanbuf) + scanbufpos;
#line 377
    if ((((long )(((((ddqblk->dqb_ihardlimit | ddqblk->dqb_isoftlimit) | ddqblk->dqb_bhardlimit) | ddqblk->dqb_bsoftlimit) | ddqblk->dqb_curblocks) | ddqblk->dqb_curinodes) | ddqblk->dqb_itime) | ddqblk->dqb_btime) == 0L) {
#line 381
      goto __Cont;
    }
    {
#line 382
    v1_disk2memdqblk(& dquot->dq_dqb, ddqblk);
#line 383
    dquot->dq_id = id___0;
#line 384
    rd = (*process_dquot)(dquot, (char *)((void *)0));
    }
#line 384
    if (rd < 0) {
      {
#line 385
      free((void *)dquot);
      }
#line 386
      return (rd);
    }
    __Cont: /* CIL Label */ 
#line 366
    id___0 ++;
#line 366
    scanbufpos ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 389
  if (! rd) {
    {
#line 390
    free((void *)dquot);
    }
#line 391
    return (0);
  }
  out_err: 
  {
#line 394
  free((void *)dquot);
  }
#line 395
  return (-1);
}
}
#line 160 "/usr/include/rpc/auth.h"
extern AUTH *authunix_create_default(void) ;
#line 129 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 236
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 291 "/usr/include/rpc/clnt.h"
extern  __attribute__((__nothrow__)) CLIENT *( __attribute__((__leaf__)) clnt_create)(char const   *__host ,
                                                                                      u_long const   __prog ,
                                                                                      u_long const   __vers ,
                                                                                      char const   *__prot ) ;
#line 192 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t ( __attribute__((__leaf__)) time)(time_t *__timer ) ;
#line 102 "/home/wheatley/newnew/temp/quota-4.01/rquota.h"
getquota_rslt *rquotaproc_getquota_1(getquota_args *argp , CLIENT *clnt ) ;
#line 133
getquota_rslt *rquotaproc_getquota_2(ext_getquota_args *argp , CLIENT *clnt ) ;
#line 44 "/home/wheatley/newnew/temp/quota-4.01/rquota_client.c"
__inline static void clinet2utildqblk(struct util_dqblk *u , struct rquota *n ) 
{ 
  time_t now___0 ;

  {
  {
#line 49
  u->dqb_bhardlimit = (((qsize_t )n->rq_bhardlimit * (qsize_t )n->rq_bsize + (qsize_t )(1 << 10)) - 1L) >> 10;
#line 50
  u->dqb_bsoftlimit = (((qsize_t )n->rq_bsoftlimit * (qsize_t )n->rq_bsize + (qsize_t )(1 << 10)) - 1L) >> 10;
#line 51
  u->dqb_ihardlimit = (qsize_t )n->rq_fhardlimit;
#line 52
  u->dqb_isoftlimit = (qsize_t )n->rq_fsoftlimit;
#line 53
  u->dqb_curinodes = (qsize_t )n->rq_curfiles;
#line 54
  u->dqb_curspace = (qsize_t )n->rq_curblocks * (qsize_t )n->rq_bsize;
#line 55
  time(& now___0);
  }
#line 56
  if (n->rq_btimeleft) {
#line 57
    u->dqb_btime = (time_t )n->rq_btimeleft + now___0;
  } else {
#line 59
    u->dqb_btime = (time_t )0;
  }
#line 60
  if (n->rq_ftimeleft) {
#line 61
    u->dqb_itime = (time_t )n->rq_ftimeleft + now___0;
  } else {
#line 63
    u->dqb_itime = (time_t )0;
  }
#line 64
  return;
}
}
#line 89 "/home/wheatley/newnew/temp/quota-4.01/rquota_client.c"
static int rquota_err(int stat___0 ) 
{ 


  {
  {
#line 92
  if (stat___0 == -1) {
#line 92
    goto case_neg_1;
  }
#line 94
  if (stat___0 == 0) {
#line 94
    goto case_0;
  }
#line 96
  if (stat___0 == 2) {
#line 96
    goto case_2;
  }
#line 98
  if (stat___0 == 1) {
#line 98
    goto case_1;
  }
#line 100
  if (stat___0 == 3) {
#line 100
    goto case_3;
  }
#line 102
  goto switch_default;
  case_neg_1: /* CIL Label */ 
#line 93
  return (-111);
  case_0: /* CIL Label */ 
#line 95
  return (-38);
  case_2: /* CIL Label */ 
#line 97
  return (-2);
  case_1: /* CIL Label */ 
#line 99
  return (0);
  case_3: /* CIL Label */ 
#line 101
  return (-1);
  switch_default: /* CIL Label */ 
#line 103
  return (-22);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 107 "/home/wheatley/newnew/temp/quota-4.01/rquota_client.c"
static int split_nfs_mount(char *devname , char **host , char **path ) 
{ 
  char *pathname ;

  {
#line 112
  if ((int )*devname == 91) {
    {
#line 113
    *host = devname + 1;
#line 114
    pathname = strchr((char const   *)devname, ']');
    }
#line 115
    if (! pathname) {
#line 116
      return (0);
    } else
#line 115
    if ((int )*(pathname + 1) != 58) {
#line 116
      return (0);
    }
#line 118
    if ((int )*(pathname + 2) == 40) {
#line 119
      return (0);
    }
#line 120
    *pathname = (char)0;
#line 121
    *path = pathname + 2;
#line 122
    return (1);
  }
  {
#line 124
  *host = devname;
#line 125
  pathname = strchr((char const   *)devname, ':');
  }
#line 126
  if (! pathname) {
#line 127
    return (0);
  }
#line 129
  if ((int )*(pathname + 1) == 40) {
#line 130
    return (0);
  }
#line 131
  *pathname = (char)0;
#line 132
  *path = pathname + 1;
#line 133
  return (1);
}
}
#line 139 "/home/wheatley/newnew/temp/quota-4.01/rquota_client.c"
int rpc_rquota_get(struct dquot *dquot ) 
{ 
  CLIENT *clnt ;
  getquota_rslt *result___1 ;
  union __anonunion_args_79 args ;
  char *fsname_tmp ;
  char *host ;
  char *pathname ;
  struct timeval timeout ;
  size_t tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  unsigned int tmp___3 ;
  int tmp___4 ;

  {
  {
#line 148
  timeout.tv_sec = (__time_t )2;
#line 148
  timeout.tv_usec = (__suseconds_t )0;
#line 153
  memset((void *)(& dquot->dq_dqb), 0, sizeof(dquot->dq_dqb));
#line 158
  tmp = strlen((char const   *)((dquot->dq_h)->qh_quotadev));
#line 158
  tmp___0 = smalloc(tmp + 1UL);
#line 158
  fsname_tmp = (char *)tmp___0;
#line 159
  strcpy((char */* __restrict  */)fsname_tmp, (char const   */* __restrict  */)((dquot->dq_h)->qh_quotadev));
#line 160
  tmp___1 = split_nfs_mount(fsname_tmp, & host, & pathname);
  }
#line 160
  if (! tmp___1) {
    {
#line 161
    free((void *)fsname_tmp);
    }
#line 162
    return (-2);
  }
#line 167
  if ((dquot->dq_h)->qh_io_flags & 8) {
    {
#line 167
    tmp___2 = strcmp((char const   *)((dquot->dq_h)->qh_fstype), "nfs4");
    }
#line 167
    if (! tmp___2) {
      {
#line 169
      while (1) {
        while_continue: /* CIL Label */ ;
#line 169
        if (! ((int )*pathname == 47)) {
#line 169
          goto while_break;
        }
#line 170
        pathname ++;
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
  {
#line 176
  args.ext_arg.gqa_pathp = pathname;
#line 177
  args.ext_arg.gqa_id = (int )dquot->dq_id;
#line 178
  args.ext_arg.gqa_type = (dquot->dq_h)->qh_type;
#line 183
  clnt = clnt_create((char const   *)host, (u_long const   )100011, (u_long const   )2,
                     "udp");
  }
#line 183
  if ((unsigned long )clnt != (unsigned long )((void *)0)) {
    {
#line 187
    clnt->cl_auth = authunix_create_default();
#line 192
    (*((clnt->cl_ops)->cl_control))(clnt, 1, (caddr_t )(& timeout));
#line 197
    result___1 = rquotaproc_getquota_2(& args.ext_arg, clnt);
    }
#line 198
    if ((unsigned long )result___1 != (unsigned long )((void *)0)) {
#line 198
      if ((unsigned int )result___1->status == 1U) {
        {
#line 199
        clinet2utildqblk(& dquot->dq_dqb, & result___1->getquota_rslt_u.gqr_rquota);
        }
      }
    }
    {
#line 204
    (*(((clnt->cl_auth)->ah_ops)->ah_destroy))(clnt->cl_auth);
#line 205
    (*((clnt->cl_ops)->cl_destroy))(clnt);
    }
  } else {
#line 208
    result___1 = (getquota_rslt *)((void *)0);
  }
#line 210
  if ((unsigned long )result___1 == (unsigned long )((void *)0)) {
#line 210
    goto _L;
  } else
#line 210
  if (! result___1->status) {
    _L: /* CIL Label */ 
#line 211
    if ((dquot->dq_h)->qh_type == 0) {
      {
#line 215
      args.arg.gqa_pathp = pathname;
#line 216
      args.arg.gqa_uid = (int )dquot->dq_id;
#line 221
      clnt = clnt_create((char const   *)host, (u_long const   )100011, (u_long const   )1,
                         "udp");
      }
#line 221
      if ((unsigned long )clnt != (unsigned long )((void *)0)) {
        {
#line 225
        clnt->cl_auth = authunix_create_default();
#line 230
        (*((clnt->cl_ops)->cl_control))(clnt, 1, (caddr_t )(& timeout));
#line 235
        result___1 = rquotaproc_getquota_1(& args.arg, clnt);
        }
#line 236
        if ((unsigned long )result___1 != (unsigned long )((void *)0)) {
#line 236
          if ((unsigned int )result___1->status == 1U) {
            {
#line 237
            clinet2utildqblk(& dquot->dq_dqb, & result___1->getquota_rslt_u.gqr_rquota);
            }
          }
        }
        {
#line 243
        (*(((clnt->cl_auth)->ah_ops)->ah_destroy))(clnt->cl_auth);
#line 244
        (*((clnt->cl_ops)->cl_destroy))(clnt);
        }
      }
    }
  }
  {
#line 248
  free((void *)fsname_tmp);
  }
#line 249
  if (result___1) {
#line 249
    tmp___3 = (unsigned int )result___1->status;
  } else {
#line 249
    tmp___3 = 4294967295U;
  }
  {
#line 249
  tmp___4 = rquota_err((int )tmp___3);
  }
#line 249
  return (tmp___4);
}
}
#line 255 "/home/wheatley/newnew/temp/quota-4.01/rquota_client.c"
int rpc_rquota_set(int qcmd , struct dquot *dquot ) 
{ 


  {
#line 368
  return (-1);
}
}
#line 374 "/usr/include/netinet/in.h"
extern  __attribute__((__nothrow__)) uint32_t ( __attribute__((__leaf__)) ntohl)(uint32_t __netlong )  __attribute__((__const__)) ;
#line 377
extern  __attribute__((__nothrow__)) uint32_t ( __attribute__((__leaf__)) htonl)(uint32_t __hostlong )  __attribute__((__const__)) ;
#line 288 "/usr/include/rpc/xdr.h"
extern  __attribute__((__nothrow__)) bool_t ( __attribute__((__leaf__)) xdr_int)(XDR *__xdrs ,
                                                                                 int *__ip ) ;
#line 289
extern  __attribute__((__nothrow__)) bool_t ( __attribute__((__leaf__)) xdr_u_int)(XDR *__xdrs ,
                                                                                   u_int *__up ) ;
#line 306
extern  __attribute__((__nothrow__)) bool_t ( __attribute__((__leaf__)) xdr_bool)(XDR *__xdrs ,
                                                                                  bool_t *__bp ) ;
#line 307
extern  __attribute__((__nothrow__)) bool_t ( __attribute__((__leaf__)) xdr_enum)(XDR *__xdrs ,
                                                                                  enum_t *__ep ) ;
#line 314
extern  __attribute__((__nothrow__)) bool_t ( __attribute__((__leaf__)) xdr_string)(XDR *__xdrs ,
                                                                                    char **__cpp ,
                                                                                    u_int __maxsize ) ;
#line 158 "/home/wheatley/newnew/temp/quota-4.01/rquota.h"
bool_t xdr_sq_dqblk(XDR *xdrs , sq_dqblk *objp ) ;
#line 159
bool_t xdr_getquota_args(XDR *xdrs , getquota_args *objp ) ;
#line 160
bool_t xdr_setquota_args(XDR *xdrs , setquota_args *objp ) ;
#line 161
bool_t xdr_ext_getquota_args(XDR *xdrs , ext_getquota_args *objp ) ;
#line 162
bool_t xdr_ext_setquota_args(XDR *xdrs , ext_setquota_args *objp ) ;
#line 163
bool_t xdr_rquota(XDR *xdrs , rquota *objp ) ;
#line 164
bool_t xdr_qr_status(XDR *xdrs , qr_status *objp ) ;
#line 165
bool_t xdr_getquota_rslt(XDR *xdrs , getquota_rslt *objp ) ;
#line 166
bool_t xdr_setquota_rslt(XDR *xdrs , setquota_rslt *objp ) ;
#line 8 "/home/wheatley/newnew/temp/quota-4.01/rquota_xdr.c"
bool_t xdr_sq_dqblk(XDR *xdrs , sq_dqblk *objp ) 
{ 
  register int32_t *buf ;
  bool_t tmp ;
  bool_t tmp___0 ;
  bool_t tmp___1 ;
  bool_t tmp___2 ;
  bool_t tmp___3 ;
  bool_t tmp___4 ;
  bool_t tmp___5 ;
  bool_t tmp___6 ;
  int32_t *tmp___7 ;
  uint32_t tmp___8 ;
  int32_t *tmp___9 ;
  uint32_t tmp___10 ;
  int32_t *tmp___11 ;
  uint32_t tmp___12 ;
  int32_t *tmp___13 ;
  uint32_t tmp___14 ;
  int32_t *tmp___15 ;
  uint32_t tmp___16 ;
  int32_t *tmp___17 ;
  uint32_t tmp___18 ;
  int32_t *tmp___19 ;
  uint32_t tmp___20 ;
  int32_t *tmp___21 ;
  uint32_t tmp___22 ;
  bool_t tmp___23 ;
  bool_t tmp___24 ;
  bool_t tmp___25 ;
  bool_t tmp___26 ;
  bool_t tmp___27 ;
  bool_t tmp___28 ;
  bool_t tmp___29 ;
  bool_t tmp___30 ;
  int32_t *tmp___31 ;
  uint32_t tmp___32 ;
  int32_t *tmp___33 ;
  uint32_t tmp___34 ;
  int32_t *tmp___35 ;
  uint32_t tmp___36 ;
  int32_t *tmp___37 ;
  uint32_t tmp___38 ;
  int32_t *tmp___39 ;
  uint32_t tmp___40 ;
  int32_t *tmp___41 ;
  uint32_t tmp___42 ;
  int32_t *tmp___43 ;
  uint32_t tmp___44 ;
  int32_t *tmp___45 ;
  uint32_t tmp___46 ;
  bool_t tmp___47 ;
  bool_t tmp___48 ;
  bool_t tmp___49 ;
  bool_t tmp___50 ;
  bool_t tmp___51 ;
  bool_t tmp___52 ;
  bool_t tmp___53 ;
  bool_t tmp___54 ;

  {
#line 14
  if ((unsigned int )xdrs->x_op == 0U) {
    {
#line 15
    buf = (*((xdrs->x_ops)->x_inline))(xdrs, (u_int )32);
    }
#line 16
    if ((unsigned long )buf == (unsigned long )((void *)0)) {
      {
#line 17
      tmp = xdr_u_int(xdrs, & objp->rq_bhardlimit);
      }
#line 17
      if (! tmp) {
#line 18
        return (0);
      }
      {
#line 19
      tmp___0 = xdr_u_int(xdrs, & objp->rq_bsoftlimit);
      }
#line 19
      if (! tmp___0) {
#line 20
        return (0);
      }
      {
#line 21
      tmp___1 = xdr_u_int(xdrs, & objp->rq_curblocks);
      }
#line 21
      if (! tmp___1) {
#line 22
        return (0);
      }
      {
#line 23
      tmp___2 = xdr_u_int(xdrs, & objp->rq_fhardlimit);
      }
#line 23
      if (! tmp___2) {
#line 24
        return (0);
      }
      {
#line 25
      tmp___3 = xdr_u_int(xdrs, & objp->rq_fsoftlimit);
      }
#line 25
      if (! tmp___3) {
#line 26
        return (0);
      }
      {
#line 27
      tmp___4 = xdr_u_int(xdrs, & objp->rq_curfiles);
      }
#line 27
      if (! tmp___4) {
#line 28
        return (0);
      }
      {
#line 29
      tmp___5 = xdr_u_int(xdrs, & objp->rq_btimeleft);
      }
#line 29
      if (! tmp___5) {
#line 30
        return (0);
      }
      {
#line 31
      tmp___6 = xdr_u_int(xdrs, & objp->rq_ftimeleft);
      }
#line 31
      if (! tmp___6) {
#line 32
        return (0);
      }
    } else {
      {
#line 34
      tmp___7 = buf;
#line 34
      buf ++;
#line 34
      tmp___8 = htonl((uint32_t )((long )objp->rq_bhardlimit));
#line 34
      *tmp___7 = (int32_t )tmp___8;
#line 35
      tmp___9 = buf;
#line 35
      buf ++;
#line 35
      tmp___10 = htonl((uint32_t )((long )objp->rq_bsoftlimit));
#line 35
      *tmp___9 = (int32_t )tmp___10;
#line 36
      tmp___11 = buf;
#line 36
      buf ++;
#line 36
      tmp___12 = htonl((uint32_t )((long )objp->rq_curblocks));
#line 36
      *tmp___11 = (int32_t )tmp___12;
#line 37
      tmp___13 = buf;
#line 37
      buf ++;
#line 37
      tmp___14 = htonl((uint32_t )((long )objp->rq_fhardlimit));
#line 37
      *tmp___13 = (int32_t )tmp___14;
#line 38
      tmp___15 = buf;
#line 38
      buf ++;
#line 38
      tmp___16 = htonl((uint32_t )((long )objp->rq_fsoftlimit));
#line 38
      *tmp___15 = (int32_t )tmp___16;
#line 39
      tmp___17 = buf;
#line 39
      buf ++;
#line 39
      tmp___18 = htonl((uint32_t )((long )objp->rq_curfiles));
#line 39
      *tmp___17 = (int32_t )tmp___18;
#line 40
      tmp___19 = buf;
#line 40
      buf ++;
#line 40
      tmp___20 = htonl((uint32_t )((long )objp->rq_btimeleft));
#line 40
      *tmp___19 = (int32_t )tmp___20;
#line 41
      tmp___21 = buf;
#line 41
      buf ++;
#line 41
      tmp___22 = htonl((uint32_t )((long )objp->rq_ftimeleft));
#line 41
      *tmp___21 = (int32_t )tmp___22;
      }
    }
#line 43
    return (1);
  } else
#line 44
  if ((unsigned int )xdrs->x_op == 1U) {
    {
#line 45
    buf = (*((xdrs->x_ops)->x_inline))(xdrs, (u_int )32);
    }
#line 46
    if ((unsigned long )buf == (unsigned long )((void *)0)) {
      {
#line 47
      tmp___23 = xdr_u_int(xdrs, & objp->rq_bhardlimit);
      }
#line 47
      if (! tmp___23) {
#line 48
        return (0);
      }
      {
#line 49
      tmp___24 = xdr_u_int(xdrs, & objp->rq_bsoftlimit);
      }
#line 49
      if (! tmp___24) {
#line 50
        return (0);
      }
      {
#line 51
      tmp___25 = xdr_u_int(xdrs, & objp->rq_curblocks);
      }
#line 51
      if (! tmp___25) {
#line 52
        return (0);
      }
      {
#line 53
      tmp___26 = xdr_u_int(xdrs, & objp->rq_fhardlimit);
      }
#line 53
      if (! tmp___26) {
#line 54
        return (0);
      }
      {
#line 55
      tmp___27 = xdr_u_int(xdrs, & objp->rq_fsoftlimit);
      }
#line 55
      if (! tmp___27) {
#line 56
        return (0);
      }
      {
#line 57
      tmp___28 = xdr_u_int(xdrs, & objp->rq_curfiles);
      }
#line 57
      if (! tmp___28) {
#line 58
        return (0);
      }
      {
#line 59
      tmp___29 = xdr_u_int(xdrs, & objp->rq_btimeleft);
      }
#line 59
      if (! tmp___29) {
#line 60
        return (0);
      }
      {
#line 61
      tmp___30 = xdr_u_int(xdrs, & objp->rq_ftimeleft);
      }
#line 61
      if (! tmp___30) {
#line 62
        return (0);
      }
    } else {
      {
#line 64
      tmp___31 = buf;
#line 64
      buf ++;
#line 64
      tmp___32 = ntohl((uint32_t )*tmp___31);
#line 64
      objp->rq_bhardlimit = (u_int )((u_long )((long )((uint32_t )((int32_t )tmp___32))));
#line 65
      tmp___33 = buf;
#line 65
      buf ++;
#line 65
      tmp___34 = ntohl((uint32_t )*tmp___33);
#line 65
      objp->rq_bsoftlimit = (u_int )((u_long )((long )((uint32_t )((int32_t )tmp___34))));
#line 66
      tmp___35 = buf;
#line 66
      buf ++;
#line 66
      tmp___36 = ntohl((uint32_t )*tmp___35);
#line 66
      objp->rq_curblocks = (u_int )((u_long )((long )((uint32_t )((int32_t )tmp___36))));
#line 67
      tmp___37 = buf;
#line 67
      buf ++;
#line 67
      tmp___38 = ntohl((uint32_t )*tmp___37);
#line 67
      objp->rq_fhardlimit = (u_int )((u_long )((long )((uint32_t )((int32_t )tmp___38))));
#line 68
      tmp___39 = buf;
#line 68
      buf ++;
#line 68
      tmp___40 = ntohl((uint32_t )*tmp___39);
#line 68
      objp->rq_fsoftlimit = (u_int )((u_long )((long )((uint32_t )((int32_t )tmp___40))));
#line 69
      tmp___41 = buf;
#line 69
      buf ++;
#line 69
      tmp___42 = ntohl((uint32_t )*tmp___41);
#line 69
      objp->rq_curfiles = (u_int )((u_long )((long )((uint32_t )((int32_t )tmp___42))));
#line 70
      tmp___43 = buf;
#line 70
      buf ++;
#line 70
      tmp___44 = ntohl((uint32_t )*tmp___43);
#line 70
      objp->rq_btimeleft = (u_int )((u_long )((long )((uint32_t )((int32_t )tmp___44))));
#line 71
      tmp___45 = buf;
#line 71
      buf ++;
#line 71
      tmp___46 = ntohl((uint32_t )*tmp___45);
#line 71
      objp->rq_ftimeleft = (u_int )((u_long )((long )((uint32_t )((int32_t )tmp___46))));
      }
    }
#line 73
    return (1);
  }
  {
#line 76
  tmp___47 = xdr_u_int(xdrs, & objp->rq_bhardlimit);
  }
#line 76
  if (! tmp___47) {
#line 77
    return (0);
  }
  {
#line 78
  tmp___48 = xdr_u_int(xdrs, & objp->rq_bsoftlimit);
  }
#line 78
  if (! tmp___48) {
#line 79
    return (0);
  }
  {
#line 80
  tmp___49 = xdr_u_int(xdrs, & objp->rq_curblocks);
  }
#line 80
  if (! tmp___49) {
#line 81
    return (0);
  }
  {
#line 82
  tmp___50 = xdr_u_int(xdrs, & objp->rq_fhardlimit);
  }
#line 82
  if (! tmp___50) {
#line 83
    return (0);
  }
  {
#line 84
  tmp___51 = xdr_u_int(xdrs, & objp->rq_fsoftlimit);
  }
#line 84
  if (! tmp___51) {
#line 85
    return (0);
  }
  {
#line 86
  tmp___52 = xdr_u_int(xdrs, & objp->rq_curfiles);
  }
#line 86
  if (! tmp___52) {
#line 87
    return (0);
  }
  {
#line 88
  tmp___53 = xdr_u_int(xdrs, & objp->rq_btimeleft);
  }
#line 88
  if (! tmp___53) {
#line 89
    return (0);
  }
  {
#line 90
  tmp___54 = xdr_u_int(xdrs, & objp->rq_ftimeleft);
  }
#line 90
  if (! tmp___54) {
#line 91
    return (0);
  }
#line 92
  return (1);
}
}
#line 95 "/home/wheatley/newnew/temp/quota-4.01/rquota_xdr.c"
bool_t xdr_getquota_args(XDR *xdrs , getquota_args *objp ) 
{ 
  bool_t tmp ;
  bool_t tmp___0 ;

  {
  {
#line 100
  tmp = xdr_string(xdrs, & objp->gqa_pathp, (u_int )1024);
  }
#line 100
  if (! tmp) {
#line 101
    return (0);
  }
  {
#line 102
  tmp___0 = xdr_int(xdrs, & objp->gqa_uid);
  }
#line 102
  if (! tmp___0) {
#line 103
    return (0);
  }
#line 104
  return (1);
}
}
#line 107 "/home/wheatley/newnew/temp/quota-4.01/rquota_xdr.c"
bool_t xdr_setquota_args(XDR *xdrs , setquota_args *objp ) 
{ 
  bool_t tmp ;
  bool_t tmp___0 ;
  bool_t tmp___1 ;
  bool_t tmp___2 ;

  {
  {
#line 112
  tmp = xdr_int(xdrs, & objp->sqa_qcmd);
  }
#line 112
  if (! tmp) {
#line 113
    return (0);
  }
  {
#line 114
  tmp___0 = xdr_string(xdrs, & objp->sqa_pathp, (u_int )1024);
  }
#line 114
  if (! tmp___0) {
#line 115
    return (0);
  }
  {
#line 116
  tmp___1 = xdr_int(xdrs, & objp->sqa_id);
  }
#line 116
  if (! tmp___1) {
#line 117
    return (0);
  }
  {
#line 118
  tmp___2 = xdr_sq_dqblk(xdrs, & objp->sqa_dqblk);
  }
#line 118
  if (! tmp___2) {
#line 119
    return (0);
  }
#line 120
  return (1);
}
}
#line 123 "/home/wheatley/newnew/temp/quota-4.01/rquota_xdr.c"
bool_t xdr_ext_getquota_args(XDR *xdrs , ext_getquota_args *objp ) 
{ 
  bool_t tmp ;
  bool_t tmp___0 ;
  bool_t tmp___1 ;

  {
  {
#line 128
  tmp = xdr_string(xdrs, & objp->gqa_pathp, (u_int )1024);
  }
#line 128
  if (! tmp) {
#line 129
    return (0);
  }
  {
#line 130
  tmp___0 = xdr_int(xdrs, & objp->gqa_type);
  }
#line 130
  if (! tmp___0) {
#line 131
    return (0);
  }
  {
#line 132
  tmp___1 = xdr_int(xdrs, & objp->gqa_id);
  }
#line 132
  if (! tmp___1) {
#line 133
    return (0);
  }
#line 134
  return (1);
}
}
#line 137 "/home/wheatley/newnew/temp/quota-4.01/rquota_xdr.c"
bool_t xdr_ext_setquota_args(XDR *xdrs , ext_setquota_args *objp ) 
{ 
  bool_t tmp ;
  bool_t tmp___0 ;
  bool_t tmp___1 ;
  bool_t tmp___2 ;
  bool_t tmp___3 ;

  {
  {
#line 142
  tmp = xdr_int(xdrs, & objp->sqa_qcmd);
  }
#line 142
  if (! tmp) {
#line 143
    return (0);
  }
  {
#line 144
  tmp___0 = xdr_string(xdrs, & objp->sqa_pathp, (u_int )1024);
  }
#line 144
  if (! tmp___0) {
#line 145
    return (0);
  }
  {
#line 146
  tmp___1 = xdr_int(xdrs, & objp->sqa_id);
  }
#line 146
  if (! tmp___1) {
#line 147
    return (0);
  }
  {
#line 148
  tmp___2 = xdr_int(xdrs, & objp->sqa_type);
  }
#line 148
  if (! tmp___2) {
#line 149
    return (0);
  }
  {
#line 150
  tmp___3 = xdr_sq_dqblk(xdrs, & objp->sqa_dqblk);
  }
#line 150
  if (! tmp___3) {
#line 151
    return (0);
  }
#line 152
  return (1);
}
}
#line 155 "/home/wheatley/newnew/temp/quota-4.01/rquota_xdr.c"
bool_t xdr_rquota(XDR *xdrs , rquota *objp ) 
{ 
  register int32_t *buf ;
  bool_t tmp ;
  bool_t tmp___0 ;
  bool_t tmp___1 ;
  bool_t tmp___2 ;
  bool_t tmp___3 ;
  bool_t tmp___4 ;
  bool_t tmp___5 ;
  bool_t tmp___6 ;
  bool_t tmp___7 ;
  bool_t tmp___8 ;
  int32_t *tmp___9 ;
  uint32_t tmp___10 ;
  int32_t *tmp___11 ;
  uint32_t tmp___12 ;
  int32_t *tmp___13 ;
  uint32_t tmp___14 ;
  int32_t *tmp___15 ;
  uint32_t tmp___16 ;
  int32_t *tmp___17 ;
  uint32_t tmp___18 ;
  int32_t *tmp___19 ;
  uint32_t tmp___20 ;
  int32_t *tmp___21 ;
  uint32_t tmp___22 ;
  int32_t *tmp___23 ;
  uint32_t tmp___24 ;
  int32_t *tmp___25 ;
  uint32_t tmp___26 ;
  int32_t *tmp___27 ;
  uint32_t tmp___28 ;
  bool_t tmp___29 ;
  bool_t tmp___30 ;
  bool_t tmp___31 ;
  bool_t tmp___32 ;
  bool_t tmp___33 ;
  bool_t tmp___34 ;
  bool_t tmp___35 ;
  bool_t tmp___36 ;
  bool_t tmp___37 ;
  bool_t tmp___38 ;
  int32_t *tmp___39 ;
  uint32_t tmp___40 ;
  int32_t *tmp___41 ;
  uint32_t tmp___42 ;
  int32_t *tmp___43 ;
  uint32_t tmp___44 ;
  int32_t *tmp___45 ;
  uint32_t tmp___46 ;
  int32_t *tmp___47 ;
  uint32_t tmp___48 ;
  int32_t *tmp___49 ;
  uint32_t tmp___50 ;
  int32_t *tmp___51 ;
  uint32_t tmp___52 ;
  int32_t *tmp___53 ;
  uint32_t tmp___54 ;
  int32_t *tmp___55 ;
  uint32_t tmp___56 ;
  int32_t *tmp___57 ;
  uint32_t tmp___58 ;
  bool_t tmp___59 ;
  bool_t tmp___60 ;
  bool_t tmp___61 ;
  bool_t tmp___62 ;
  bool_t tmp___63 ;
  bool_t tmp___64 ;
  bool_t tmp___65 ;
  bool_t tmp___66 ;
  bool_t tmp___67 ;
  bool_t tmp___68 ;

  {
#line 161
  if ((unsigned int )xdrs->x_op == 0U) {
    {
#line 162
    buf = (*((xdrs->x_ops)->x_inline))(xdrs, (u_int )40);
    }
#line 163
    if ((unsigned long )buf == (unsigned long )((void *)0)) {
      {
#line 164
      tmp = xdr_int(xdrs, & objp->rq_bsize);
      }
#line 164
      if (! tmp) {
#line 165
        return (0);
      }
      {
#line 166
      tmp___0 = xdr_bool(xdrs, & objp->rq_active);
      }
#line 166
      if (! tmp___0) {
#line 167
        return (0);
      }
      {
#line 168
      tmp___1 = xdr_u_int(xdrs, & objp->rq_bhardlimit);
      }
#line 168
      if (! tmp___1) {
#line 169
        return (0);
      }
      {
#line 170
      tmp___2 = xdr_u_int(xdrs, & objp->rq_bsoftlimit);
      }
#line 170
      if (! tmp___2) {
#line 171
        return (0);
      }
      {
#line 172
      tmp___3 = xdr_u_int(xdrs, & objp->rq_curblocks);
      }
#line 172
      if (! tmp___3) {
#line 173
        return (0);
      }
      {
#line 174
      tmp___4 = xdr_u_int(xdrs, & objp->rq_fhardlimit);
      }
#line 174
      if (! tmp___4) {
#line 175
        return (0);
      }
      {
#line 176
      tmp___5 = xdr_u_int(xdrs, & objp->rq_fsoftlimit);
      }
#line 176
      if (! tmp___5) {
#line 177
        return (0);
      }
      {
#line 178
      tmp___6 = xdr_u_int(xdrs, & objp->rq_curfiles);
      }
#line 178
      if (! tmp___6) {
#line 179
        return (0);
      }
      {
#line 180
      tmp___7 = xdr_u_int(xdrs, & objp->rq_btimeleft);
      }
#line 180
      if (! tmp___7) {
#line 181
        return (0);
      }
      {
#line 182
      tmp___8 = xdr_u_int(xdrs, & objp->rq_ftimeleft);
      }
#line 182
      if (! tmp___8) {
#line 183
        return (0);
      }
    } else {
      {
#line 185
      tmp___9 = buf;
#line 185
      buf ++;
#line 185
      tmp___10 = htonl((uint32_t )((long )objp->rq_bsize));
#line 185
      *tmp___9 = (int32_t )tmp___10;
#line 186
      tmp___11 = buf;
#line 186
      buf ++;
#line 186
      tmp___12 = htonl((uint32_t )((long )objp->rq_active));
#line 186
      *tmp___11 = (int32_t )tmp___12;
#line 187
      tmp___13 = buf;
#line 187
      buf ++;
#line 187
      tmp___14 = htonl((uint32_t )((long )objp->rq_bhardlimit));
#line 187
      *tmp___13 = (int32_t )tmp___14;
#line 188
      tmp___15 = buf;
#line 188
      buf ++;
#line 188
      tmp___16 = htonl((uint32_t )((long )objp->rq_bsoftlimit));
#line 188
      *tmp___15 = (int32_t )tmp___16;
#line 189
      tmp___17 = buf;
#line 189
      buf ++;
#line 189
      tmp___18 = htonl((uint32_t )((long )objp->rq_curblocks));
#line 189
      *tmp___17 = (int32_t )tmp___18;
#line 190
      tmp___19 = buf;
#line 190
      buf ++;
#line 190
      tmp___20 = htonl((uint32_t )((long )objp->rq_fhardlimit));
#line 190
      *tmp___19 = (int32_t )tmp___20;
#line 191
      tmp___21 = buf;
#line 191
      buf ++;
#line 191
      tmp___22 = htonl((uint32_t )((long )objp->rq_fsoftlimit));
#line 191
      *tmp___21 = (int32_t )tmp___22;
#line 192
      tmp___23 = buf;
#line 192
      buf ++;
#line 192
      tmp___24 = htonl((uint32_t )((long )objp->rq_curfiles));
#line 192
      *tmp___23 = (int32_t )tmp___24;
#line 193
      tmp___25 = buf;
#line 193
      buf ++;
#line 193
      tmp___26 = htonl((uint32_t )((long )objp->rq_btimeleft));
#line 193
      *tmp___25 = (int32_t )tmp___26;
#line 194
      tmp___27 = buf;
#line 194
      buf ++;
#line 194
      tmp___28 = htonl((uint32_t )((long )objp->rq_ftimeleft));
#line 194
      *tmp___27 = (int32_t )tmp___28;
      }
    }
#line 196
    return (1);
  } else
#line 197
  if ((unsigned int )xdrs->x_op == 1U) {
    {
#line 198
    buf = (*((xdrs->x_ops)->x_inline))(xdrs, (u_int )40);
    }
#line 199
    if ((unsigned long )buf == (unsigned long )((void *)0)) {
      {
#line 200
      tmp___29 = xdr_int(xdrs, & objp->rq_bsize);
      }
#line 200
      if (! tmp___29) {
#line 201
        return (0);
      }
      {
#line 202
      tmp___30 = xdr_bool(xdrs, & objp->rq_active);
      }
#line 202
      if (! tmp___30) {
#line 203
        return (0);
      }
      {
#line 204
      tmp___31 = xdr_u_int(xdrs, & objp->rq_bhardlimit);
      }
#line 204
      if (! tmp___31) {
#line 205
        return (0);
      }
      {
#line 206
      tmp___32 = xdr_u_int(xdrs, & objp->rq_bsoftlimit);
      }
#line 206
      if (! tmp___32) {
#line 207
        return (0);
      }
      {
#line 208
      tmp___33 = xdr_u_int(xdrs, & objp->rq_curblocks);
      }
#line 208
      if (! tmp___33) {
#line 209
        return (0);
      }
      {
#line 210
      tmp___34 = xdr_u_int(xdrs, & objp->rq_fhardlimit);
      }
#line 210
      if (! tmp___34) {
#line 211
        return (0);
      }
      {
#line 212
      tmp___35 = xdr_u_int(xdrs, & objp->rq_fsoftlimit);
      }
#line 212
      if (! tmp___35) {
#line 213
        return (0);
      }
      {
#line 214
      tmp___36 = xdr_u_int(xdrs, & objp->rq_curfiles);
      }
#line 214
      if (! tmp___36) {
#line 215
        return (0);
      }
      {
#line 216
      tmp___37 = xdr_u_int(xdrs, & objp->rq_btimeleft);
      }
#line 216
      if (! tmp___37) {
#line 217
        return (0);
      }
      {
#line 218
      tmp___38 = xdr_u_int(xdrs, & objp->rq_ftimeleft);
      }
#line 218
      if (! tmp___38) {
#line 219
        return (0);
      }
    } else {
      {
#line 221
      tmp___39 = buf;
#line 221
      buf ++;
#line 221
      tmp___40 = ntohl((uint32_t )*tmp___39);
#line 221
      objp->rq_bsize = (int )((long )((uint32_t )((int32_t )tmp___40)));
#line 222
      tmp___41 = buf;
#line 222
      buf ++;
#line 222
      tmp___42 = ntohl((uint32_t )*tmp___41);
#line 222
      objp->rq_active = (bool_t )((long )((uint32_t )((int32_t )tmp___42)));
#line 223
      tmp___43 = buf;
#line 223
      buf ++;
#line 223
      tmp___44 = ntohl((uint32_t )*tmp___43);
#line 223
      objp->rq_bhardlimit = (u_int )((u_long )((long )((uint32_t )((int32_t )tmp___44))));
#line 224
      tmp___45 = buf;
#line 224
      buf ++;
#line 224
      tmp___46 = ntohl((uint32_t )*tmp___45);
#line 224
      objp->rq_bsoftlimit = (u_int )((u_long )((long )((uint32_t )((int32_t )tmp___46))));
#line 225
      tmp___47 = buf;
#line 225
      buf ++;
#line 225
      tmp___48 = ntohl((uint32_t )*tmp___47);
#line 225
      objp->rq_curblocks = (u_int )((u_long )((long )((uint32_t )((int32_t )tmp___48))));
#line 226
      tmp___49 = buf;
#line 226
      buf ++;
#line 226
      tmp___50 = ntohl((uint32_t )*tmp___49);
#line 226
      objp->rq_fhardlimit = (u_int )((u_long )((long )((uint32_t )((int32_t )tmp___50))));
#line 227
      tmp___51 = buf;
#line 227
      buf ++;
#line 227
      tmp___52 = ntohl((uint32_t )*tmp___51);
#line 227
      objp->rq_fsoftlimit = (u_int )((u_long )((long )((uint32_t )((int32_t )tmp___52))));
#line 228
      tmp___53 = buf;
#line 228
      buf ++;
#line 228
      tmp___54 = ntohl((uint32_t )*tmp___53);
#line 228
      objp->rq_curfiles = (u_int )((u_long )((long )((uint32_t )((int32_t )tmp___54))));
#line 229
      tmp___55 = buf;
#line 229
      buf ++;
#line 229
      tmp___56 = ntohl((uint32_t )*tmp___55);
#line 229
      objp->rq_btimeleft = (u_int )((u_long )((long )((uint32_t )((int32_t )tmp___56))));
#line 230
      tmp___57 = buf;
#line 230
      buf ++;
#line 230
      tmp___58 = ntohl((uint32_t )*tmp___57);
#line 230
      objp->rq_ftimeleft = (u_int )((u_long )((long )((uint32_t )((int32_t )tmp___58))));
      }
    }
#line 232
    return (1);
  }
  {
#line 235
  tmp___59 = xdr_int(xdrs, & objp->rq_bsize);
  }
#line 235
  if (! tmp___59) {
#line 236
    return (0);
  }
  {
#line 237
  tmp___60 = xdr_bool(xdrs, & objp->rq_active);
  }
#line 237
  if (! tmp___60) {
#line 238
    return (0);
  }
  {
#line 239
  tmp___61 = xdr_u_int(xdrs, & objp->rq_bhardlimit);
  }
#line 239
  if (! tmp___61) {
#line 240
    return (0);
  }
  {
#line 241
  tmp___62 = xdr_u_int(xdrs, & objp->rq_bsoftlimit);
  }
#line 241
  if (! tmp___62) {
#line 242
    return (0);
  }
  {
#line 243
  tmp___63 = xdr_u_int(xdrs, & objp->rq_curblocks);
  }
#line 243
  if (! tmp___63) {
#line 244
    return (0);
  }
  {
#line 245
  tmp___64 = xdr_u_int(xdrs, & objp->rq_fhardlimit);
  }
#line 245
  if (! tmp___64) {
#line 246
    return (0);
  }
  {
#line 247
  tmp___65 = xdr_u_int(xdrs, & objp->rq_fsoftlimit);
  }
#line 247
  if (! tmp___65) {
#line 248
    return (0);
  }
  {
#line 249
  tmp___66 = xdr_u_int(xdrs, & objp->rq_curfiles);
  }
#line 249
  if (! tmp___66) {
#line 250
    return (0);
  }
  {
#line 251
  tmp___67 = xdr_u_int(xdrs, & objp->rq_btimeleft);
  }
#line 251
  if (! tmp___67) {
#line 252
    return (0);
  }
  {
#line 253
  tmp___68 = xdr_u_int(xdrs, & objp->rq_ftimeleft);
  }
#line 253
  if (! tmp___68) {
#line 254
    return (0);
  }
#line 255
  return (1);
}
}
#line 258 "/home/wheatley/newnew/temp/quota-4.01/rquota_xdr.c"
bool_t xdr_qr_status(XDR *xdrs , qr_status *objp ) 
{ 
  bool_t tmp ;

  {
  {
#line 263
  tmp = xdr_enum(xdrs, (enum_t *)objp);
  }
#line 263
  if (! tmp) {
#line 264
    return (0);
  }
#line 265
  return (1);
}
}
#line 268 "/home/wheatley/newnew/temp/quota-4.01/rquota_xdr.c"
bool_t xdr_getquota_rslt(XDR *xdrs , getquota_rslt *objp ) 
{ 
  bool_t tmp ;
  bool_t tmp___0 ;

  {
  {
#line 273
  tmp = xdr_qr_status(xdrs, & objp->status);
  }
#line 273
  if (! tmp) {
#line 274
    return (0);
  }
  {
#line 276
  if ((unsigned int )objp->status == 1U) {
#line 276
    goto case_1;
  }
#line 280
  if ((unsigned int )objp->status == 2U) {
#line 280
    goto case_2;
  }
#line 282
  if ((unsigned int )objp->status == 3U) {
#line 282
    goto case_3;
  }
#line 284
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 277
  tmp___0 = xdr_rquota(xdrs, & objp->getquota_rslt_u.gqr_rquota);
  }
#line 277
  if (! tmp___0) {
#line 278
    return (0);
  }
#line 279
  goto switch_break;
  case_2: /* CIL Label */ 
#line 281
  goto switch_break;
  case_3: /* CIL Label */ 
#line 283
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 285
  return (0);
  switch_break: /* CIL Label */ ;
  }
#line 287
  return (1);
}
}
#line 290 "/home/wheatley/newnew/temp/quota-4.01/rquota_xdr.c"
bool_t xdr_setquota_rslt(XDR *xdrs , setquota_rslt *objp ) 
{ 
  bool_t tmp ;
  bool_t tmp___0 ;

  {
  {
#line 295
  tmp = xdr_qr_status(xdrs, & objp->status);
  }
#line 295
  if (! tmp) {
#line 296
    return (0);
  }
  {
#line 298
  if ((unsigned int )objp->status == 1U) {
#line 298
    goto case_1;
  }
#line 302
  if ((unsigned int )objp->status == 2U) {
#line 302
    goto case_2;
  }
#line 304
  if ((unsigned int )objp->status == 3U) {
#line 304
    goto case_3;
  }
#line 306
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 299
  tmp___0 = xdr_rquota(xdrs, & objp->setquota_rslt_u.sqr_rquota);
  }
#line 299
  if (! tmp___0) {
#line 300
    return (0);
  }
#line 301
  goto switch_break;
  case_2: /* CIL Label */ 
#line 303
  goto switch_break;
  case_3: /* CIL Label */ 
#line 305
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 307
  return (0);
  switch_break: /* CIL Label */ ;
  }
#line 309
  return (1);
}
}
#line 364 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 137 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcat)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 110 "/usr/include/pwd.h"
extern struct passwd *getpwuid(__uid_t __uid ) ;
#line 116
extern struct passwd *getpwnam(char const   *__name ) ;
#line 105 "/usr/include/grp.h"
extern struct group *getgrgid(__gid_t __gid ) ;
#line 111
extern struct group *getgrnam(char const   *__name ) ;
#line 187 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) unsigned long ( __attribute__((__nonnull__(1),
__leaf__)) strtoul)(char const   * __restrict  __nptr , char ** __restrict  __endptr ,
                    int __base ) ;
#line 734
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) realpath)(char const   * __restrict  __name ,
                                                                                 char * __restrict  __resolved ) ;
#line 675 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __uid_t ( __attribute__((__leaf__)) getuid)(void) ;
#line 681
extern  __attribute__((__nothrow__)) __gid_t ( __attribute__((__leaf__)) getgid)(void) ;
#line 215 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) sigemptyset)(sigset_t *__set ) ;
#line 259
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sigaction)(int __sig ,
                                                                                struct sigaction  const  * __restrict  __act ,
                                                                                struct sigaction * __restrict  __oact ) ;
#line 35 "/usr/include/x86_64-linux-gnu/sys/statfs.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) statfs)(char const   *__file ,
                                                                                               struct statfs *__buf )  __asm__("statfs64")  ;
#line 66 "/usr/include/mntent.h"
extern  __attribute__((__nothrow__)) FILE *( __attribute__((__leaf__)) setmntent)(char const   *__file ,
                                                                                  char const   *__mode ) ;
#line 71
extern  __attribute__((__nothrow__)) struct mntent *( __attribute__((__leaf__)) getmntent)(FILE *__stream ) ;
#line 87
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) endmntent)(FILE *__stream ) ;
#line 91
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) hasmntopt)(struct mntent  const  *__mnt ,
                                                                                  char const   *__opt ) ;
#line 37 "/home/wheatley/newnew/temp/quota-4.01/quotasys.h"
int kernel_iface  ;
#line 62
uid_t user2uid(char *name , int flag , int *err ) ;
#line 65
gid_t group2gid(char *name , int flag , int *err ) ;
#line 68
int name2id(char *name , int qtype , int flag , int *err ) ;
#line 71
int uid2user(uid_t id___0 , char *buf ) ;
#line 74
int gid2group(gid_t id___0 , char *buf ) ;
#line 77
int id2name(int id___0 , int qtype , char *buf ) ;
#line 83
int passwd_handling(void) ;
#line 86
int name2fmt(char *str ) ;
#line 92
int util2kernfmt(int fmt___7 ) ;
#line 95
void difftime2str(time_t seconds , char *buf ) ;
#line 98
void time2str(time_t seconds , char *buf , int flags___7 ) ;
#line 101
int str2timeunits(time_t num , char *unit , time_t *res ) ;
#line 104
void space2str(qsize_t space , char *buf , int format ) ;
#line 107
void number2str(unsigned long long num , char *buf , int format ) ;
#line 110
char *str_hasmntopt(char const   *optstring , char const   *opt ) ;
#line 128
struct quota_handle **create_handle_list(int count , char **mntpoints___0 , int type ,
                                         int fmt___7 , int ioflags , int mntflags ) ;
#line 131
int dispose_handle_list(struct quota_handle **hlist___10 ) ;
#line 134
int devcmp_handle(char const   *dev , struct quota_handle *h ) ;
#line 137
int devcmp_handles(struct quota_handle *a , struct quota_handle *b ) ;
#line 140
void init_kernel_interface(void) ;
#line 157
int init_mounts_scan(int dcnt , char **dirs , int flags___7 ) ;
#line 160
struct mount_entry *get_next_mount(void) ;
#line 163
void end_mounts_scan(void) ;
#line 41 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static char extensions[4][20]  = { {        (char )'u',        (char )'s',        (char )'e',        (char )'r', 
            (char )'\000'}, 
   {        (char )'g',        (char )'r',        (char )'o',        (char )'u', 
            (char )'p',        (char )'\000'}, 
   {        (char )'u',        (char )'n',        (char )'d',        (char )'e', 
            (char )'f',        (char )'i',        (char )'n',        (char )'e', 
            (char )'d',        (char )'\000'}};
#line 42 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static char *basenames[6]  = {      (char *)"quota",      (char *)"aquota",      (char *)"aquota",      (char *)"", 
        (char *)"",      (char *)""};
#line 43 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static char *fmtnames[5]  = {      (char *)"vfsold",      (char *)"vfsv0",      (char *)"vfsv1",      (char *)"rpc", 
        (char *)"xfs"};
#line 53 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
int nfs_fstype(char *type ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 55
  tmp = strcmp((char const   *)type, "nfs");
  }
#line 55
  if (tmp) {
    {
#line 55
    tmp___0 = strcmp((char const   *)type, "nfs4");
    }
#line 55
    if (tmp___0) {
      {
#line 55
      tmp___1 = strcmp((char const   *)type, "mpfs");
      }
#line 55
      if (tmp___1) {
#line 55
        tmp___2 = 0;
      } else {
#line 55
        tmp___2 = 1;
      }
    } else {
#line 55
      tmp___2 = 1;
    }
  } else {
#line 55
    tmp___2 = 1;
  }
#line 55
  return (tmp___2);
}
}
#line 63 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
int meta_qf_fstype(char *type ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
#line 65
  tmp = strcmp((char const   *)type, "ocfs2");
  }
#line 65
  if (tmp) {
#line 65
    tmp___0 = 0;
  } else {
#line 65
    tmp___0 = 1;
  }
#line 65
  return (tmp___0);
}
}
#line 71 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
char *type2name(int type ) 
{ 


  {
#line 73
  return (extensions[type]);
}
}
#line 79 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
uid_t user2uid(char *name , int flag , int *err ) 
{ 
  struct passwd *entry ;
  uid_t ret ;
  char *errch ;
  unsigned long tmp ;
  char *tmp___0 ;

  {
#line 85
  if (err) {
#line 86
    *err = 0;
  }
#line 87
  if (! flag) {
    {
#line 88
    tmp = strtoul((char const   */* __restrict  */)name, (char **/* __restrict  */)(& errch),
                  0);
#line 88
    ret = (uid_t )tmp;
    }
#line 89
    if (! *errch) {
#line 90
      return (ret);
    }
  }
  {
#line 92
  entry = getpwnam((char const   *)name);
  }
#line 92
  if (! entry) {
#line 93
    if (! err) {
      {
#line 94
      tmp___0 = gettext("user %s does not exist.\n");
#line 94
      errstr(tmp___0, name);
#line 95
      exit(1);
      }
    } else {
#line 98
      *err = -1;
#line 99
      return ((uid_t )0);
    }
  }
#line 102
  return (entry->pw_uid);
}
}
#line 108 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
gid_t group2gid(char *name , int flag , int *err ) 
{ 
  struct group *entry ;
  gid_t ret ;
  char *errch ;
  unsigned long tmp ;
  char *tmp___0 ;

  {
#line 114
  if (err) {
#line 115
    *err = 0;
  }
#line 116
  if (! flag) {
    {
#line 117
    tmp = strtoul((char const   */* __restrict  */)name, (char **/* __restrict  */)(& errch),
                  0);
#line 117
    ret = (gid_t )tmp;
    }
#line 118
    if (! *errch) {
#line 119
      return (ret);
    }
  }
  {
#line 121
  entry = getgrnam((char const   *)name);
  }
#line 121
  if (! entry) {
#line 122
    if (! err) {
      {
#line 123
      tmp___0 = gettext("group %s does not exist.\n");
#line 123
      errstr(tmp___0, name);
#line 124
      exit(1);
      }
    } else {
#line 127
      *err = -1;
#line 128
      return ((gid_t )0);
    }
  }
#line 131
  return (entry->gr_gid);
}
}
#line 137 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
int name2id(char *name , int qtype , int flag , int *err ) 
{ 
  uid_t tmp ;
  gid_t tmp___0 ;

  {
#line 139
  if (qtype == 0) {
    {
#line 140
    tmp = user2uid(name, flag, err);
    }
#line 140
    return ((int )tmp);
  } else {
    {
#line 142
    tmp___0 = group2gid(name, flag, err);
    }
#line 142
    return ((int )tmp___0);
  }
}
}
#line 148 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
int uid2user(uid_t id___0 , char *buf ) 
{ 
  struct passwd *entry ;

  {
  {
#line 152
  entry = getpwuid(id___0);
  }
#line 152
  if (entry) {
    {
#line 157
    sstrncpy(buf, (char const   *)entry->pw_name, (size_t )64);
    }
  } else {
    {
#line 153
    snprintf((char */* __restrict  */)buf, (size_t )64, (char const   */* __restrict  */)"#%u",
             id___0);
    }
#line 154
    return (1);
  }
#line 158
  return (0);
}
}
#line 164 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
int gid2group(gid_t id___0 , char *buf ) 
{ 
  struct group *entry ;

  {
  {
#line 168
  entry = getgrgid(id___0);
  }
#line 168
  if (entry) {
    {
#line 173
    sstrncpy(buf, (char const   *)entry->gr_name, (size_t )64);
    }
  } else {
    {
#line 169
    snprintf((char */* __restrict  */)buf, (size_t )64, (char const   */* __restrict  */)"#%u",
             id___0);
    }
#line 170
    return (1);
  }
#line 174
  return (0);
}
}
#line 180 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
int id2name(int id___0 , int qtype , char *buf ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 182
  if (qtype == 0) {
    {
#line 183
    tmp = uid2user((uid_t )id___0, buf);
    }
#line 183
    return (tmp);
  } else {
    {
#line 185
    tmp___0 = gid2group((gid_t )id___0, buf);
    }
#line 185
    return (tmp___0);
  }
}
}
#line 191 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
int passwd_handling(void) 
{ 
  FILE *f ;
  char buf[1024] ;
  char *colpos ;
  char *spcpos ;
  int ret ;
  int tmp ;
  unsigned short const   **tmp___0 ;
  unsigned short const   **tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  char *tmp___5 ;

  {
  {
#line 195
  ret = 0;
#line 197
  f = fopen((char const   */* __restrict  */)"/etc/nsswitch.conf", (char const   */* __restrict  */)"r");
  }
#line 197
  if (! f) {
#line 198
    return (0);
  }
  {
#line 199
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 199
    tmp___5 = fgets((char */* __restrict  */)(buf), (int )sizeof(buf), (FILE */* __restrict  */)f);
    }
#line 199
    if (! tmp___5) {
#line 199
      goto while_break;
    }
    {
#line 200
    tmp = strncmp((char const   *)(buf), "passwd:", (size_t )7);
    }
#line 200
    if (tmp) {
#line 201
      goto while_continue;
    }
#line 202
    colpos = buf + 7;
    {
#line 202
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 202
      tmp___0 = __ctype_b_loc();
      }
#line 202
      if (! ((int const   )*(*tmp___0 + (int )*colpos) & 8192)) {
#line 202
        goto while_break___0;
      }
#line 202
      colpos ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 203
    if (! *colpos) {
#line 204
      goto while_break;
    }
#line 205
    spcpos = colpos;
    {
#line 205
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 205
      tmp___1 = __ctype_b_loc();
      }
#line 205
      if ((int const   )*(*tmp___1 + (int )*spcpos) & 8192) {
#line 205
        goto while_break___1;
      } else
#line 205
      if (! *spcpos) {
#line 205
        goto while_break___1;
      }
#line 205
      spcpos ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 206
    *spcpos = (char)0;
#line 207
    tmp___2 = strcmp((char const   *)colpos, "db");
    }
#line 207
    if (tmp___2) {
      {
#line 207
      tmp___3 = strcmp((char const   *)colpos, "nis");
      }
#line 207
      if (tmp___3) {
        {
#line 207
        tmp___4 = strcmp((char const   *)colpos, "nis+");
        }
#line 207
        if (! tmp___4) {
#line 208
          ret = 1;
        }
      } else {
#line 208
        ret = 1;
      }
    } else {
#line 208
      ret = 1;
    }
#line 209
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 211
  fclose(f);
  }
#line 212
  return (ret);
}
}
#line 218 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
int name2fmt(char *str ) 
{ 
  int fmt___7 ;
  int tmp ;
  char *tmp___0 ;

  {
#line 222
  fmt___7 = 0;
  {
#line 222
  while (1) {
    while_continue: /* CIL Label */ ;
#line 222
    if (! (fmt___7 < 5)) {
#line 222
      goto while_break;
    }
    {
#line 223
    tmp = strcmp((char const   *)str, (char const   *)fmtnames[fmt___7]);
    }
#line 223
    if (! tmp) {
#line 224
      return (fmt___7);
    }
#line 222
    fmt___7 ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 225
  tmp___0 = gettext("Unknown quota format: %s\nSupported formats are:\n  vfsold - original quota format\n  vfsv0 - standard quota format\n  vfsv1 - quota format with 64-bit limits\n  rpc - use RPC calls\n  xfs - XFS quota format\n");
#line 225
  errstr(tmp___0, str);
  }
#line 231
  return (-1);
}
}
#line 237 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
char *fmt2name(int fmt___7 ) 
{ 


  {
#line 239
  return (fmtnames[fmt___7]);
}
}
#line 245 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static int kern2utilfmt(int kernfmt ) 
{ 


  {
  {
#line 248
  if (kernfmt == 1) {
#line 248
    goto case_1;
  }
#line 250
  if (kernfmt == 2) {
#line 250
    goto case_2;
  }
#line 252
  if (kernfmt == 4) {
#line 252
    goto case_4;
  }
#line 254
  if (kernfmt == 3) {
#line 254
    goto case_3;
  }
#line 247
  goto switch_break;
  case_1: /* CIL Label */ 
#line 249
  return (0);
  case_2: /* CIL Label */ 
#line 251
  return (1);
  case_4: /* CIL Label */ 
#line 253
  return (2);
  case_3: /* CIL Label */ 
#line 255
  return (5);
  switch_break: /* CIL Label */ ;
  }
#line 257
  return (-1);
}
}
#line 263 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
int util2kernfmt(int fmt___7 ) 
{ 


  {
  {
#line 266
  if (fmt___7 == 0) {
#line 266
    goto case_0;
  }
#line 268
  if (fmt___7 == 1) {
#line 268
    goto case_1;
  }
#line 270
  if (fmt___7 == 2) {
#line 270
    goto case_2;
  }
#line 265
  goto switch_break;
  case_0: /* CIL Label */ 
#line 267
  return (1);
  case_1: /* CIL Label */ 
#line 269
  return (2);
  case_2: /* CIL Label */ 
#line 271
  return (4);
  switch_break: /* CIL Label */ ;
  }
#line 273
  return (-1);
}
}
#line 279 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
void difftime2str(time_t seconds , char *buf ) 
{ 
  time_t now___0 ;
  char *tmp ;

  {
#line 283
  *(buf + 0) = (char)0;
#line 284
  if (! seconds) {
#line 285
    return;
  }
  {
#line 286
  time(& now___0);
  }
#line 287
  if (seconds <= now___0) {
    {
#line 288
    tmp = gettext("none");
#line 288
    strcpy((char */* __restrict  */)buf, (char const   */* __restrict  */)tmp);
    }
#line 289
    return;
  }
  {
#line 291
  time2str(seconds - now___0, buf, 1);
  }
#line 292
  return;
}
}
#line 297 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
void time2str(time_t seconds , char *buf , int flags___7 ) 
{ 
  uint minutes ;
  uint hours ;
  uint days ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;

  {
#line 301
  if (flags___7 & 1) {
#line 302
    minutes = (uint )((seconds + 30L) / 60L);
#line 303
    hours = minutes / 60U;
#line 304
    minutes %= 60U;
#line 305
    days = hours / 24U;
#line 306
    hours %= 24U;
#line 307
    if (days >= 2U) {
      {
#line 308
      tmp = gettext("%ddays");
#line 308
      snprintf((char */* __restrict  */)buf, (size_t )40, (char const   */* __restrict  */)tmp,
               days);
      }
    } else {
      {
#line 310
      tmp___0 = gettext("%02d:%02d");
#line 310
      snprintf((char */* __restrict  */)buf, (size_t )40, (char const   */* __restrict  */)tmp___0,
               hours + days * 24U, minutes);
      }
    }
  } else {
#line 313
    minutes = (uint )(seconds / 60L);
#line 314
    seconds %= 60L;
#line 315
    hours = minutes / 60U;
#line 316
    minutes %= 60U;
#line 317
    days = hours / 24U;
#line 318
    hours %= 24U;
#line 319
    if (seconds) {
      {
#line 320
      tmp___1 = gettext("%useconds");
#line 320
      snprintf((char */* __restrict  */)buf, (size_t )40, (char const   */* __restrict  */)tmp___1,
               (uint )(((seconds + (time_t )(minutes * 60U)) + (time_t )(hours * 3600U)) + (time_t )((days * 3600U) * 24U)));
      }
    } else
#line 319
    if (! minutes) {
#line 319
      if (! hours) {
#line 319
        if (! days) {
          {
#line 320
          tmp___1 = gettext("%useconds");
#line 320
          snprintf((char */* __restrict  */)buf, (size_t )40, (char const   */* __restrict  */)tmp___1,
                   (uint )(((seconds + (time_t )(minutes * 60U)) + (time_t )(hours * 3600U)) + (time_t )((days * 3600U) * 24U)));
          }
        } else {
#line 319
          goto _L___0;
        }
      } else {
#line 319
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 321
    if (minutes) {
      {
#line 322
      tmp___2 = gettext("%uminutes");
#line 322
      snprintf((char */* __restrict  */)buf, (size_t )40, (char const   */* __restrict  */)tmp___2,
               (minutes + hours * 60U) + (days * 60U) * 24U);
      }
    } else
#line 323
    if (hours) {
      {
#line 324
      tmp___3 = gettext("%uhours");
#line 324
      snprintf((char */* __restrict  */)buf, (size_t )40, (char const   */* __restrict  */)tmp___3,
               hours + days * 24U);
      }
    } else {
      {
#line 326
      tmp___4 = gettext("%udays");
#line 326
      snprintf((char */* __restrict  */)buf, (size_t )40, (char const   */* __restrict  */)tmp___4,
               days);
      }
    }
  }
#line 328
  return;
}
}
#line 333 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
int str2timeunits(time_t num , char *unit , time_t *res ) 
{ 
  char *tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;
  char *tmp___9 ;
  int tmp___10 ;
  char *tmp___11 ;
  int tmp___12 ;
  char *tmp___13 ;
  int tmp___14 ;

  {
  {
#line 335
  tmp___11 = gettext("second");
#line 335
  tmp___12 = strcmp((char const   *)unit, (char const   *)tmp___11);
  }
#line 335
  if (tmp___12) {
    {
#line 335
    tmp___13 = gettext("seconds");
#line 335
    tmp___14 = strcmp((char const   *)unit, (char const   *)tmp___13);
    }
#line 335
    if (tmp___14) {
      {
#line 337
      tmp___7 = gettext("minute");
#line 337
      tmp___8 = strcmp((char const   *)unit, (char const   *)tmp___7);
      }
#line 337
      if (tmp___8) {
        {
#line 337
        tmp___9 = gettext("minutes");
#line 337
        tmp___10 = strcmp((char const   *)unit, (char const   *)tmp___9);
        }
#line 337
        if (tmp___10) {
          {
#line 339
          tmp___3 = gettext("hour");
#line 339
          tmp___4 = strcmp((char const   *)unit, (char const   *)tmp___3);
          }
#line 339
          if (tmp___4) {
            {
#line 339
            tmp___5 = gettext("hours");
#line 339
            tmp___6 = strcmp((char const   *)unit, (char const   *)tmp___5);
            }
#line 339
            if (tmp___6) {
              {
#line 341
              tmp = gettext("day");
#line 341
              tmp___0 = strcmp((char const   *)unit, (char const   *)tmp);
              }
#line 341
              if (tmp___0) {
                {
#line 341
                tmp___1 = gettext("days");
#line 341
                tmp___2 = strcmp((char const   *)unit, (char const   *)tmp___1);
                }
#line 341
                if (tmp___2) {
#line 344
                  return (-1);
                } else {
#line 342
                  *res = ((num * 24L) * 60L) * 60L;
                }
              } else {
#line 342
                *res = ((num * 24L) * 60L) * 60L;
              }
            } else {
#line 340
              *res = (num * 60L) * 60L;
            }
          } else {
#line 340
            *res = (num * 60L) * 60L;
          }
        } else {
#line 338
          *res = num * 60L;
        }
      } else {
#line 338
        *res = num * 60L;
      }
    } else {
#line 336
      *res = num;
    }
  } else {
#line 336
    *res = num;
  }
#line 345
  return (0);
}
}
#line 351 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
void space2str(qsize_t space , char *buf , int format ) 
{ 
  int i ;
  char suffix[8] ;
  unsigned int tmp ;

  {
#line 354
  suffix[0] = (char )' ';
#line 354
  suffix[1] = (char )'M';
#line 354
  suffix[2] = (char )'G';
#line 354
  suffix[3] = (char )'T';
#line 354
  suffix[4] = (char )'\000';
#line 354
  tmp = 5U;
  {
#line 354
  while (1) {
    while_continue: /* CIL Label */ ;
#line 354
    if (tmp >= 8U) {
#line 354
      goto while_break;
    }
#line 354
    suffix[tmp] = (char)0;
#line 354
    tmp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 356
  space = space;
#line 357
  if (format) {
#line 358
    i = 3;
    {
#line 358
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 358
      if (! (i > 0)) {
#line 358
        goto while_break___0;
      }
#line 359
      if ((long long )space >= (1LL << 10 * i) * 100LL) {
        {
#line 360
        sprintf((char */* __restrict  */)buf, (char const   */* __restrict  */)"%llu%c",
                (unsigned long long )((space + (qsize_t )(1 << 10 * i)) - 1L) >> 10 * i,
                (int )suffix[i]);
        }
#line 361
        return;
      }
#line 358
      i --;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 363
    sprintf((char */* __restrict  */)buf, (char const   */* __restrict  */)"%lluK",
            (unsigned long long )space);
    }
#line 364
    return;
  }
  {
#line 366
  sprintf((char */* __restrict  */)buf, (char const   */* __restrict  */)"%llu", (unsigned long long )space);
  }
#line 367
  return;
}
}
#line 372 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
void number2str(unsigned long long num , char *buf , int format ) 
{ 
  int i ;
  unsigned long long div___0 ;
  char suffix[8] ;
  unsigned int tmp ;

  {
#line 376
  suffix[0] = (char )' ';
#line 376
  suffix[1] = (char )'k';
#line 376
  suffix[2] = (char )'m';
#line 376
  suffix[3] = (char )'g';
#line 376
  suffix[4] = (char )'t';
#line 376
  suffix[5] = (char )'\000';
#line 376
  tmp = 6U;
  {
#line 376
  while (1) {
    while_continue: /* CIL Label */ ;
#line 376
    if (tmp >= 8U) {
#line 376
      goto while_break;
    }
#line 376
    suffix[tmp] = (char)0;
#line 376
    tmp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 378
  if (format) {
#line 379
    i = 4;
#line 379
    div___0 = 1000000000000ULL;
    {
#line 379
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 379
      if (! (i > 0)) {
#line 379
        goto while_break___0;
      }
#line 380
      if (num >= 100ULL * div___0) {
        {
#line 381
        sprintf((char */* __restrict  */)buf, (char const   */* __restrict  */)"%llu%c",
                ((num + div___0) - 1ULL) / div___0, (int )suffix[i]);
        }
#line 382
        return;
      }
#line 379
      i --;
#line 379
      div___0 /= 1000ULL;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  {
#line 384
  sprintf((char */* __restrict  */)buf, (char const   */* __restrict  */)"%llu", num);
  }
#line 385
  return;
}
}
#line 394 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static int hasxfsquota(char const   *dev , struct mntent *mnt___2 , int type , int flags___7 ) 
{ 
  u_int16_t sbflags ;
  struct fs_quota_stat info ;
  long tmp ;

  {
#line 399
  if (flags___7 & 16) {
#line 400
    return (4);
  }
  {
#line 402
  memset((void *)(& info), 0, sizeof(struct fs_quota_stat ));
#line 403
  tmp = quotactl((((88 << 8) + 5) << 8) | (type & 255), dev, (qid_t )0, (caddr_t )((void *)(& info)));
  }
#line 403
  if (! tmp) {
#line 404
    sbflags = (u_int16_t )(((int )info.qs_flags & 65280) >> 8);
#line 405
    if (type == 0) {
#line 405
      if ((int )info.qs_flags & 1) {
#line 406
        return (4);
      } else {
#line 405
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 407
    if (type == 1) {
#line 407
      if ((int )info.qs_flags & (1 << 2)) {
#line 408
        return (4);
      }
    }
  }
#line 424
  return (-1);
}
}
#line 427 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static int hasvfsmetaquota(char const   *dev , struct mntent *mnt___2 , int type ,
                           int flags___7 ) 
{ 
  uint32_t fmt___7 ;
  long tmp ;

  {
  {
#line 431
  tmp = quotactl((8388612 << 8) | (type & 255), dev, (qid_t )0, (caddr_t )((void *)(& fmt___7)));
  }
#line 431
  if (! tmp) {
#line 432
    return (5);
  }
#line 433
  return (-1);
}
}
#line 437 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
char *str_hasmntopt(char const   *optstring , char const   *opt ) 
{ 
  char const   *p ;
  char const   *s ;
  int len ;
  size_t tmp ;
  int tmp___0 ;

  {
  {
#line 439
  p = optstring;
#line 441
  tmp = strlen(opt);
#line 441
  len = (int )tmp;
  }
  {
#line 443
  while (1) {
    while_continue: /* CIL Label */ ;
#line 444
    s = p;
    {
#line 445
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 445
      if (*p) {
#line 445
        if ((int const   )*p != 44) {
#line 445
          if (! ((int const   )*p != 61)) {
#line 445
            goto while_break___0;
          }
        } else {
#line 445
          goto while_break___0;
        }
      } else {
#line 445
        goto while_break___0;
      }
#line 446
      p ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 448
    if (p - s == (long )len) {
      {
#line 448
      tmp___0 = strncmp(s, opt, (size_t )len);
      }
#line 448
      if (! tmp___0) {
#line 449
        return ((char *)s);
      }
    }
#line 451
    if ((int const   )*p == 61) {
#line 452
      p ++;
      {
#line 453
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 453
        if (*p) {
#line 453
          if (! ((int const   )*p != 44)) {
#line 453
            goto while_break___1;
          }
        } else {
#line 453
          goto while_break___1;
        }
#line 454
        p ++;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
#line 457
    if (*p) {
#line 458
      p ++;
    }
#line 443
    if (! *p) {
#line 443
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 461
  return ((char *)((void *)0));
}
}
#line 465 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static char *hasmntoptarg(char const   *optstring , char const   *opt ) 
{ 
  char *p ;
  char *tmp ;
  size_t tmp___0 ;

  {
  {
#line 467
  tmp = str_hasmntopt(optstring, opt);
#line 467
  p = tmp;
  }
#line 469
  if (! p) {
#line 470
    return ((char *)((void *)0));
  }
  {
#line 471
  tmp___0 = strlen(opt);
#line 471
  p += tmp___0;
  }
#line 472
  if ((int )*p == 61) {
#line 472
    if ((int )*(p + 1) != 44) {
#line 473
      return (p + 1);
    }
  }
#line 474
  return ((char *)((void *)0));
}
}
#line 478 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static void copy_mntoptarg(char *buf , char const   *optarg___0 , int buflen ) 
{ 
  char *sep ;
  char *tmp ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  long tmp___4 ;

  {
  {
#line 480
  tmp = strchr(optarg___0, ',');
#line 480
  sep = tmp;
  }
#line 482
  if (! sep) {
    {
#line 483
    tmp___3 = strlen(optarg___0);
    }
#line 483
    if ((size_t )buflen < tmp___3 + 1UL) {
#line 483
      tmp___2 = (size_t )buflen;
    } else {
      {
#line 483
      tmp___1 = strlen(optarg___0);
#line 483
      tmp___2 = tmp___1 + 1UL;
      }
    }
    {
#line 483
    sstrncpy(buf, optarg___0, tmp___2);
    }
  } else {
#line 485
    if ((long )buflen < (sep - (char *)optarg___0) + 1L) {
#line 485
      tmp___4 = (long )buflen;
    } else {
#line 485
      tmp___4 = (sep - (char *)optarg___0) + 1L;
    }
    {
#line 485
    sstrncpy(buf, optarg___0, (size_t )tmp___4);
    }
  }
#line 486
  return;
}
}
#line 491 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static int hasquota(char const   *dev , struct mntent *mnt___2 , int type , int flags___7 ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  struct if_dqinfo kinfo ;
  long tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;

  {
  {
#line 493
  tmp___0 = strcmp((char const   *)mnt___2->mnt_type, "gfs2");
  }
#line 493
  if (tmp___0) {
    {
#line 493
    tmp___1 = strcmp((char const   *)mnt___2->mnt_type, "xfs");
    }
#line 493
    if (! tmp___1) {
      {
#line 495
      tmp = hasxfsquota(dev, mnt___2, type, flags___7);
      }
#line 495
      return (tmp);
    }
  } else {
    {
#line 495
    tmp = hasxfsquota(dev, mnt___2, type, flags___7);
    }
#line 495
    return (tmp);
  }
  {
#line 496
  tmp___3 = strcmp((char const   *)mnt___2->mnt_type, "ocfs2");
  }
#line 496
  if (! tmp___3) {
    {
#line 497
    tmp___2 = hasvfsmetaquota(dev, mnt___2, type, flags___7);
    }
#line 497
    return (tmp___2);
  }
  {
#line 504
  tmp___5 = strcmp((char const   *)mnt___2->mnt_type, "ext4");
  }
#line 504
  if (! tmp___5) {
    {
#line 507
    tmp___4 = quotactl((8388613 << 8) | (type & 255), dev, (qid_t )0, (caddr_t )((void *)(& kinfo)));
    }
#line 507
    if (tmp___4 == 0L) {
#line 508
      if (kinfo.dqi_flags & 65536U) {
#line 509
        return (5);
      }
    }
  }
  {
#line 513
  tmp___6 = nfs_fstype(mnt___2->mnt_type);
  }
#line 513
  if (tmp___6) {
#line 514
    return (3);
  }
#line 516
  if (type == 0) {
    {
#line 516
    tmp___7 = hasmntopt((struct mntent  const  *)mnt___2, "usrquota");
    }
#line 516
    if (tmp___7) {
#line 517
      return (6);
    } else {
      {
#line 516
      tmp___8 = hasmntoptarg((char const   *)mnt___2->mnt_opts, "usrjquota");
      }
#line 516
      if (tmp___8) {
#line 517
        return (6);
      }
    }
  }
#line 518
  if (type == 1) {
    {
#line 518
    tmp___9 = hasmntopt((struct mntent  const  *)mnt___2, "grpquota");
    }
#line 518
    if (tmp___9) {
#line 519
      return (6);
    } else {
      {
#line 518
      tmp___10 = hasmntoptarg((char const   *)mnt___2->mnt_opts, "grpjquota");
      }
#line 518
      if (tmp___10) {
#line 519
        return (6);
      }
    }
  }
#line 520
  if (type == 0) {
    {
#line 520
    tmp___11 = hasmntopt((struct mntent  const  *)mnt___2, "quota");
    }
#line 520
    if (tmp___11) {
#line 521
      return (6);
    }
  }
#line 522
  return (-1);
}
}
#line 526 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static int check_fmtfile_ok(char *name , int type , int fmt___7 , int flags___7 ) 
{ 
  struct stat st ;
  int *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;
  int fd ;
  int ret ;
  int tmp___4 ;
  int *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  int *tmp___8 ;
  int *tmp___9 ;

  {
#line 528
  if (! flags___7) {
#line 529
    return (1);
  }
#line 530
  if (flags___7 & 1) {
    {
#line 533
    tmp___3 = stat((char const   */* __restrict  */)name, (struct stat */* __restrict  */)(& st));
    }
#line 533
    if (tmp___3 < 0) {
      {
#line 534
      tmp___2 = __errno_location();
      }
#line 534
      if (*tmp___2 != 2) {
        {
#line 535
        tmp = __errno_location();
#line 535
        tmp___0 = strerror(*tmp);
#line 535
        tmp___1 = gettext("Cannot stat quota file %s: %s\n");
#line 535
        errstr(tmp___1, name, tmp___0);
        }
      }
#line 536
      return (0);
    }
  }
#line 539
  if (flags___7 & 2) {
    {
#line 540
    ret = 0;
#line 542
    fd = open((char const   *)name, 0);
    }
#line 542
    if (fd >= 0) {
      {
#line 543
      tmp___4 = is_tree_qfmt(fmt___7);
      }
#line 543
      if (tmp___4) {
        {
#line 544
        ret = (*(quotafile_ops_2.check_file))(fd, type, fmt___7);
        }
      } else {
        {
#line 546
        ret = (*(quotafile_ops_1.check_file))(fd, type, fmt___7);
        }
      }
      {
#line 547
      close(fd);
      }
#line 548
      if (ret <= 0) {
#line 549
        return (0);
      }
    } else {
      {
#line 551
      tmp___8 = __errno_location();
      }
#line 551
      if (*tmp___8 != 2) {
        {
#line 551
        tmp___9 = __errno_location();
        }
#line 551
        if (*tmp___9 != 1) {
          {
#line 552
          tmp___5 = __errno_location();
#line 552
          tmp___6 = strerror(*tmp___5);
#line 552
          tmp___7 = gettext("Cannot open quotafile %s: %s\n");
#line 552
          errstr(tmp___7, name, tmp___6);
          }
#line 553
          return (0);
        }
      }
    }
  }
#line 556
  return (1);
}
}
#line 564 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
int get_qf_name(struct mount_entry *mnt___2 , int type , int fmt___7 , int flags___7 ,
                char **filename ) 
{ 
  char *option ;
  char *pathname ;
  char has_quota_file_definition ;
  char qfullname[4096] ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  int len ;
  size_t tmp___2 ;
  int tmp___3 ;

  {
#line 566
  has_quota_file_definition = (char)0;
#line 569
  qfullname[0] = (char)0;
#line 570
  if (type == 0) {
    {
#line 570
    option = str_hasmntopt((char const   *)mnt___2->me_opts, "usrquota");
    }
#line 570
    if (option) {
      {
#line 571
      tmp = strlen("usrquota");
#line 571
      pathname = option + tmp;
      }
#line 571
      if ((int )*pathname == 61) {
#line 572
        has_quota_file_definition = (char)1;
      }
    } else {
#line 570
      goto _L___2;
    }
  } else
  _L___2: /* CIL Label */ 
#line 574
  if (type == 0) {
    {
#line 574
    option = hasmntoptarg((char const   *)mnt___2->me_opts, "usrjquota");
    }
#line 574
    if (option) {
      {
#line 575
      pathname = option;
#line 576
      has_quota_file_definition = (char)1;
#line 577
      sstrncpy(qfullname, mnt___2->me_dir, sizeof(qfullname));
#line 578
      sstrncat(qfullname, "/", sizeof(qfullname));
      }
    } else {
#line 574
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
#line 580
  if (type == 1) {
    {
#line 580
    option = str_hasmntopt((char const   *)mnt___2->me_opts, "grpquota");
    }
#line 580
    if (option) {
      {
#line 581
      tmp___0 = strlen("grpquota");
#line 581
      pathname = option + tmp___0;
      }
#line 582
      if ((int )*pathname == 61) {
#line 583
        has_quota_file_definition = (char)1;
#line 584
        pathname ++;
      }
    } else {
#line 580
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 587
  if (type == 1) {
    {
#line 587
    option = hasmntoptarg((char const   *)mnt___2->me_opts, "grpjquota");
    }
#line 587
    if (option) {
      {
#line 588
      pathname = option;
#line 589
      has_quota_file_definition = (char)1;
#line 590
      sstrncpy(qfullname, mnt___2->me_dir, sizeof(qfullname));
#line 591
      sstrncat(qfullname, "/", sizeof(qfullname));
      }
    } else {
#line 587
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 593
  if (type == 0) {
    {
#line 593
    option = str_hasmntopt((char const   *)mnt___2->me_opts, "quota");
    }
#line 593
    if (option) {
      {
#line 594
      tmp___1 = strlen("quota");
#line 594
      pathname = option + tmp___1;
      }
#line 595
      if ((int )*pathname == 61) {
#line 596
        has_quota_file_definition = (char)1;
#line 597
        pathname ++;
      }
    } else {
#line 601
      return (-1);
    }
  } else {
#line 601
    return (-1);
  }
#line 603
  if (has_quota_file_definition) {
    {
#line 604
    tmp___2 = strlen((char const   *)(qfullname));
#line 604
    len = (int )tmp___2;
#line 606
    copy_mntoptarg(qfullname + len, (char const   *)pathname, (int )(sizeof(qfullname) - (unsigned long )len));
    }
  } else {
    {
#line 608
    snprintf((char */* __restrict  */)(qfullname), (size_t )4096, (char const   */* __restrict  */)"%s/%s.%s",
             mnt___2->me_dir, basenames[fmt___7], extensions[type]);
    }
  }
  {
#line 611
  tmp___3 = check_fmtfile_ok(qfullname, type, fmt___7, flags___7);
  }
#line 611
  if (tmp___3) {
    {
#line 612
    *filename = sstrdup((char const   *)(qfullname));
    }
#line 613
    return (0);
  }
#line 615
  return (-1);
}
}
#line 629 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static int hlist_allocated  =    0;
#line 630 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static struct quota_handle **hlist  =    (struct quota_handle **)((void *)0);
#line 624 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
struct quota_handle **create_handle_list(int count , char **mntpoints___0 , int type ,
                                         int fmt___7 , int ioflags , int mntflags ) 
{ 
  struct mount_entry *mnt___2 ;
  int gotmnt ;
  void *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  struct quota_handle *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  char *tmp___10 ;

  {
#line 628
  gotmnt = 0;
#line 632
  if (! hlist_allocated) {
    {
#line 633
    tmp = smalloc(256UL * sizeof(struct quota_handle *));
#line 633
    hlist = (struct quota_handle **)tmp;
#line 634
    hlist_allocated = 256;
    }
  }
#line 638
  if (count) {
#line 638
    if (! (mntflags & 8)) {
#line 639
      mntflags |= 32;
    }
  }
  {
#line 641
  tmp___1 = init_mounts_scan(count, mntpoints___0, mntflags);
  }
#line 641
  if (tmp___1 < 0) {
    {
#line 642
    tmp___0 = gettext("Cannot initialize mountpoint scan.\n");
#line 642
    die(2, tmp___0);
    }
  }
  {
#line 643
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 643
    mnt___2 = get_next_mount();
    }
#line 643
    if (! mnt___2) {
#line 643
      goto while_break;
    }
#line 648
    if (fmt___7 == -1) {
#line 648
      goto add_entry;
    } else
#line 648
    if (count) {
      add_entry: 
#line 650
      if (gotmnt + 1 >= hlist_allocated) {
        {
#line 651
        hlist_allocated += 256;
#line 652
        tmp___2 = srealloc((void *)hlist, (unsigned long )hlist_allocated * sizeof(struct quota_handle *));
#line 652
        hlist = (struct quota_handle **)tmp___2;
        }
      }
      {
#line 654
      tmp___3 = init_io(mnt___2, type, fmt___7, ioflags);
#line 654
      *(hlist + gotmnt) = tmp___3;
      }
#line 654
      if (! tmp___3) {
#line 655
        goto while_continue;
      }
#line 656
      gotmnt ++;
    } else {
      {
#line 660
      if (fmt___7 == 3) {
#line 660
        goto case_3;
      }
#line 664
      if (fmt___7 == 4) {
#line 664
        goto case_4;
      }
#line 669
      goto switch_default;
      case_3: /* CIL Label */ 
      {
#line 661
      tmp___4 = nfs_fstype(mnt___2->me_type);
      }
#line 661
      if (tmp___4) {
#line 662
        goto add_entry;
      }
#line 663
      goto switch_break;
      case_4: /* CIL Label */ 
      {
#line 665
      tmp___5 = strcmp((char const   *)mnt___2->me_type, "xfs");
      }
#line 665
      if (tmp___5) {
        {
#line 665
        tmp___6 = strcmp((char const   *)mnt___2->me_type, "gfs2");
        }
#line 665
        if (! tmp___6) {
#line 667
          goto add_entry;
        }
      } else {
#line 667
        goto add_entry;
      }
#line 668
      goto switch_break;
      switch_default: /* CIL Label */ 
      {
#line 670
      tmp___7 = strcmp((char const   *)mnt___2->me_type, "xfs");
      }
#line 670
      if (tmp___7) {
        {
#line 670
        tmp___8 = strcmp((char const   *)mnt___2->me_type, "gfs2");
        }
#line 670
        if (tmp___8) {
          {
#line 670
          tmp___9 = nfs_fstype(mnt___2->me_type);
          }
#line 670
          if (! tmp___9) {
#line 673
            goto add_entry;
          }
        }
      }
#line 674
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 678
  end_mounts_scan();
#line 679
  *(hlist + gotmnt) = (struct quota_handle *)((void *)0);
  }
#line 680
  if (count) {
#line 680
    if (gotmnt != count) {
      {
#line 681
      tmp___10 = gettext("Not all specified mountpoints are using quota.\n");
#line 681
      die(1, tmp___10);
      }
    }
  }
#line 682
  return (hlist);
}
}
#line 688 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
int dispose_handle_list(struct quota_handle **hlist___10 ) 
{ 
  int i ;
  int ret ;
  char *tmp ;
  int tmp___0 ;

  {
#line 691
  ret = 0;
#line 693
  i = 0;
  {
#line 693
  while (1) {
    while_continue: /* CIL Label */ ;
#line 693
    if (! *(hlist___10 + i)) {
#line 693
      goto while_break;
    }
    {
#line 694
    tmp___0 = end_io(*(hlist___10 + i));
    }
#line 694
    if (tmp___0 < 0) {
      {
#line 695
      tmp = gettext("Error while releasing file on %s\n");
#line 695
      errstr(tmp, (*(hlist___10 + i))->qh_quotadev);
#line 697
      ret = -1;
      }
    }
#line 693
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 699
  return (ret);
}
}
#line 705 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
int devcmp_handle(char const   *dev , struct quota_handle *h ) 
{ 
  struct stat sbuf ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 709
  tmp___0 = stat((char const   */* __restrict  */)dev, (struct stat */* __restrict  */)(& sbuf));
  }
#line 709
  if (tmp___0 < 0) {
    {
#line 710
    tmp = strcmp(dev, (char const   *)(h->qh_quotadev));
    }
#line 710
    return (tmp == 0);
  }
#line 711
  if (! ((sbuf.st_mode & 61440U) == 24576U)) {
    {
#line 712
    tmp___1 = strcmp(dev, (char const   *)(h->qh_quotadev));
    }
#line 712
    return (tmp___1 == 0);
  }
#line 713
  if (sbuf.st_rdev != h->qh_stat.st_rdev) {
#line 714
    return (0);
  }
#line 715
  return (1);
}
}
#line 721 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
int devcmp_handles(struct quota_handle *a , struct quota_handle *b ) 
{ 
  int tmp ;

  {
#line 723
  if (! ((a->qh_stat.st_mode & 61440U) == 24576U)) {
    {
#line 724
    tmp = strcmp((char const   *)(a->qh_quotadev), (char const   *)(b->qh_quotadev));
    }
#line 724
    return (tmp == 0);
  } else
#line 723
  if (! ((b->qh_stat.st_mode & 61440U) == 24576U)) {
    {
#line 724
    tmp = strcmp((char const   *)(a->qh_quotadev), (char const   *)(b->qh_quotadev));
    }
#line 724
    return (tmp == 0);
  }
#line 725
  if (a->qh_stat.st_rdev != b->qh_stat.st_rdev) {
#line 726
    return (0);
  }
#line 727
  return (1);
}
}
#line 735 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static int kernel_qfmt_num  ;
#line 736 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static int kernel_qfmt[6]  ;
#line 745 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
void init_kernel_interface(void) 
{ 
  struct stat st ;
  struct sigaction sig ;
  struct sigaction oldsig ;
  int *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  fs_quota_stat_t dummy ;
  int tmp___8 ;
  long tmp___9 ;
  int *tmp___10 ;
  int *tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  struct v2_dqstats v2_stats ;
  int tmp___17 ;
  int err_stat ;
  int err_quota ;
  char tmp___18[1024] ;
  int *tmp___19 ;
  long tmp___20 ;
  int *tmp___21 ;
  long tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int *tmp___25 ;
  int *tmp___26 ;
  long tmp___27 ;
  int tmp___28 ;
  int *tmp___29 ;
  int *tmp___30 ;
  char *tmp___31 ;
  char *tmp___32 ;
  int tmp___33 ;

  {
  {
#line 751
  sig.__sigaction_handler.sa_handler = (void (*)(int  ))1;
#line 752
  sig.__sigaction_handler.sa_sigaction = (void (*)(int  , siginfo_t * , void * ))((void *)0);
#line 753
  tmp___2 = sigemptyset(& sig.sa_mask);
  }
#line 753
  if (tmp___2 < 0) {
    {
#line 754
    tmp = __errno_location();
#line 754
    tmp___0 = strerror(*tmp);
#line 754
    tmp___1 = gettext("Cannot create set for sigaction(): %s\n");
#line 754
    die(2, tmp___1, tmp___0);
    }
  }
  {
#line 755
  sig.sa_flags = 0;
#line 756
  tmp___6 = sigaction(11, (struct sigaction  const  */* __restrict  */)(& sig), (struct sigaction */* __restrict  */)(& oldsig));
  }
#line 756
  if (tmp___6 < 0) {
    {
#line 757
    tmp___3 = __errno_location();
#line 757
    tmp___4 = strerror(*tmp___3);
#line 757
    tmp___5 = gettext("Cannot set signal handler: %s\n");
#line 757
    die(2, tmp___5, tmp___4);
    }
  }
  {
#line 759
  kernel_qfmt_num = 0;
#line 760
  tmp___12 = stat((char const   */* __restrict  */)"/proc/fs/xfs/stat", (struct stat */* __restrict  */)(& st));
  }
#line 760
  if (tmp___12) {
    {
#line 765
    tmp___9 = quotactl(((88 << 8) + 5) << 8, "/dev/root", (qid_t )0, (caddr_t )((void *)(& dummy)));
    }
#line 765
    if (tmp___9) {
      {
#line 765
      tmp___10 = __errno_location();
      }
#line 765
      if (*tmp___10 != 22) {
        {
#line 765
        tmp___11 = __errno_location();
        }
#line 765
        if (*tmp___11 != 38) {
#line 766
          tmp___8 = kernel_qfmt_num;
#line 766
          kernel_qfmt_num ++;
#line 766
          kernel_qfmt[tmp___8] = 4;
        }
      }
    } else {
#line 766
      tmp___8 = kernel_qfmt_num;
#line 766
      kernel_qfmt_num ++;
#line 766
      kernel_qfmt[tmp___8] = 4;
    }
  } else {
#line 761
    tmp___7 = kernel_qfmt_num;
#line 761
    kernel_qfmt_num ++;
#line 761
    kernel_qfmt[tmp___7] = 4;
  }
  {
#line 769
  tmp___28 = stat((char const   */* __restrict  */)"/proc/sys/fs/quota", (struct stat */* __restrict  */)(& st));
  }
#line 769
  if (tmp___28) {
    {
#line 769
    tmp___29 = __errno_location();
    }
#line 769
    if (*tmp___29 != 2) {
      _L: /* CIL Label */ 
#line 770
      kernel_iface = 3;
#line 771
      tmp___13 = kernel_qfmt_num;
#line 771
      kernel_qfmt_num ++;
#line 771
      kernel_qfmt[tmp___13] = 5;
#line 772
      tmp___14 = kernel_qfmt_num;
#line 772
      kernel_qfmt_num ++;
#line 772
      kernel_qfmt[tmp___14] = 0;
#line 773
      tmp___15 = kernel_qfmt_num;
#line 773
      kernel_qfmt_num ++;
#line 773
      kernel_qfmt[tmp___15] = 1;
#line 774
      tmp___16 = kernel_qfmt_num;
#line 774
      kernel_qfmt_num ++;
#line 774
      kernel_qfmt[tmp___16] = 2;
    } else {
      {
#line 779
      tmp___27 = quotactl(4352 << 8, (char const   *)((void *)0), (qid_t )0, (caddr_t )((void *)(& v2_stats)));
      }
#line 779
      if (tmp___27 >= 0L) {
#line 780
        tmp___17 = kernel_qfmt_num;
#line 780
        kernel_qfmt_num ++;
#line 780
        kernel_qfmt[tmp___17] = 1;
#line 781
        kernel_iface = 2;
      } else {
        {
#line 783
        tmp___25 = __errno_location();
        }
#line 783
        if (*tmp___25 != 38) {
          {
#line 783
          tmp___26 = __errno_location();
          }
#line 783
          if (*tmp___26 != 95) {
            {
#line 787
            err_stat = 0;
#line 788
            err_quota = 0;
#line 791
            tmp___20 = quotactl(2048 << 8, (char const   *)((void *)0), (qid_t )0,
                                tmp___18);
            }
#line 791
            if (tmp___20) {
              {
#line 792
              tmp___19 = __errno_location();
#line 792
              err_stat = *tmp___19;
              }
            }
            {
#line 793
            tmp___22 = quotactl(768 << 8, "/dev/null", (qid_t )0, tmp___18);
            }
#line 793
            if (tmp___22) {
              {
#line 794
              tmp___21 = __errno_location();
#line 794
              err_quota = *tmp___21;
              }
            }
#line 799
            if (err_stat == 0) {
#line 799
              if (err_quota == 22) {
#line 800
                tmp___23 = kernel_qfmt_num;
#line 800
                kernel_qfmt_num ++;
#line 800
                kernel_qfmt[tmp___23] = 1;
#line 801
                kernel_iface = 2;
              } else {
#line 804
                tmp___24 = kernel_qfmt_num;
#line 804
                kernel_qfmt_num ++;
#line 804
                kernel_qfmt[tmp___24] = 0;
#line 805
                kernel_iface = 1;
              }
            } else {
#line 804
              tmp___24 = kernel_qfmt_num;
#line 804
              kernel_qfmt_num ++;
#line 804
              kernel_qfmt[tmp___24] = 0;
#line 805
              kernel_iface = 1;
            }
          }
        }
      }
    }
  } else {
#line 769
    goto _L;
  }
  {
#line 809
  tmp___33 = sigaction(11, (struct sigaction  const  */* __restrict  */)(& oldsig),
                       (struct sigaction */* __restrict  */)((void *)0));
  }
#line 809
  if (tmp___33 < 0) {
    {
#line 810
    tmp___30 = __errno_location();
#line 810
    tmp___31 = strerror(*tmp___30);
#line 810
    tmp___32 = gettext("Cannot reset signal handler: %s\n");
#line 810
    die(2, tmp___32, tmp___31);
    }
  }
#line 811
  return;
}
}
#line 814 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
int kern_qfmt_supp(int fmt___7 ) 
{ 
  int i ;

  {
#line 818
  if (fmt___7 == -1) {
#line 819
    return (kernel_qfmt_num > 0);
  }
#line 821
  i = 0;
  {
#line 821
  while (1) {
    while_continue: /* CIL Label */ ;
#line 821
    if (! (i < kernel_qfmt_num)) {
#line 821
      goto while_break;
    }
#line 822
    if (fmt___7 == kernel_qfmt[i]) {
#line 823
      return (1);
    }
#line 821
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 824
  return (0);
}
}
#line 828 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static int v1_kern_quota_on(char const   *dev , int type ) 
{ 
  char tmp[1024] ;
  qid_t id___0 ;
  __uid_t tmp___0 ;
  __gid_t tmp___1 ;
  __uid_t tmp___2 ;
  long tmp___3 ;

  {
#line 831
  if (type == 0) {
    {
#line 831
    tmp___0 = getuid();
#line 831
    tmp___2 = tmp___0;
    }
  } else {
    {
#line 831
    tmp___1 = getgid();
#line 831
    tmp___2 = tmp___1;
    }
  }
  {
#line 831
  id___0 = tmp___2;
#line 833
  tmp___3 = quotactl((768 << 8) | (type & 255), dev, id___0, tmp);
  }
#line 833
  if (! tmp___3) {
#line 834
    return (1);
  }
#line 835
  return (0);
}
}
#line 839 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static int v2_kern_quota_on(char const   *dev , int type ) 
{ 
  char tmp[1024] ;
  qid_t id___0 ;
  __uid_t tmp___0 ;
  __gid_t tmp___1 ;
  __uid_t tmp___2 ;
  long tmp___3 ;

  {
#line 842
  if (type == 0) {
    {
#line 842
    tmp___0 = getuid();
#line 842
    tmp___2 = tmp___0;
    }
  } else {
    {
#line 842
    tmp___1 = getgid();
#line 842
    tmp___2 = tmp___1;
    }
  }
  {
#line 842
  id___0 = tmp___2;
#line 844
  tmp___3 = quotactl((3328 << 8) | (type & 255), dev, id___0, tmp);
  }
#line 844
  if (! tmp___3) {
#line 845
    return (1);
  }
#line 846
  return (0);
}
}
#line 850 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static int xfs_kern_quota_on(char const   *dev , int type ) 
{ 
  struct fs_quota_stat info ;
  long tmp ;

  {
  {
#line 854
  tmp = quotactl((((88 << 8) + 5) << 8) | (type & 255), dev, (qid_t )0, (caddr_t )((void *)(& info)));
  }
#line 854
  if (! tmp) {
#line 855
    if (type == 0) {
#line 855
      if ((int )info.qs_flags & 1) {
#line 856
        return (1);
      }
    }
#line 857
    if (type == 1) {
#line 857
      if ((int )info.qs_flags & (1 << 2)) {
#line 858
        return (1);
      }
    }
  }
#line 860
  return (0);
}
}
#line 866 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
int kern_quota_on(struct mount_entry *mnt___2 , int type , int fmt___7 ) 
{ 
  int tmp ;
  int actfmt ;
  long tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 868
  if (mnt___2->me_qfmt[type] < 0) {
#line 869
    return (-1);
  }
#line 870
  if (fmt___7 == 3) {
#line 871
    return (-1);
  }
#line 872
  if (mnt___2->me_qfmt[type] == 4) {
#line 873
    if (fmt___7 == -1) {
#line 873
      goto _L;
    } else
#line 873
    if (fmt___7 == 4) {
      _L: /* CIL Label */ 
      {
#line 873
      tmp = xfs_kern_quota_on(mnt___2->me_devname, type);
      }
#line 873
      if (tmp) {
#line 875
        return (4);
      }
    }
#line 876
    return (-1);
  }
#line 879
  if (fmt___7 == 4) {
#line 880
    return (-1);
  }
#line 882
  if (mnt___2->me_qfmt[type] == 5) {
#line 883
    return (5);
  }
#line 886
  if (kernel_iface == 3) {
    {
#line 889
    tmp___0 = quotactl((8388612 << 8) | (type & 255), mnt___2->me_devname, (qid_t )0,
                       (caddr_t )((void *)(& actfmt)));
    }
#line 889
    if (tmp___0 >= 0L) {
      {
#line 891
      actfmt = kern2utilfmt(actfmt);
      }
#line 892
      if (actfmt >= 0) {
#line 893
        return (actfmt);
      }
    }
  } else {
#line 896
    if (fmt___7 == -1) {
#line 896
      goto _L___0;
    } else
#line 896
    if (fmt___7 == 1) {
      _L___0: /* CIL Label */ 
      {
#line 896
      tmp___1 = v2_kern_quota_on(mnt___2->me_devname, type);
      }
#line 896
      if (tmp___1) {
#line 898
        return (1);
      }
    }
#line 899
    if (fmt___7 == -1) {
#line 899
      goto _L___1;
    } else
#line 899
    if (fmt___7 == 0) {
      _L___1: /* CIL Label */ 
      {
#line 899
      tmp___2 = v1_kern_quota_on(mnt___2->me_devname, type);
      }
#line 899
      if (tmp___2) {
#line 901
        return (0);
      }
    }
  }
#line 903
  return (-1);
}
}
#line 921 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static int mnt_entries_cnt  ;
#line 922 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static struct mount_entry *mnt_entries  ;
#line 923 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static int check_dirs_cnt  ;
#line 923 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static int act_checked  ;
#line 924 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static struct searched_dir *check_dirs  ;
#line 927 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static int cache_mnt_table(int flags___7 ) 
{ 
  FILE *mntf ;
  struct mntent *mnt___2 ;
  struct stat st ;
  struct statfs fsstat ;
  int allocated ;
  int i ;
  dev_t dev ;
  char mntpointbuf[4096] ;
  int autofsdircnt ;
  int autofsdir_allocated ;
  char **autofsdir ;
  char *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  char const   *devname ;
  char *opt ;
  int qfmt[2] ;
  char *tmp___2 ;
  int slen ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  void *tmp___6 ;
  size_t tmp___7 ;
  void *tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char loopdev[4096] ;
  char *tmp___13 ;
  int *tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;
  int *tmp___18 ;
  char *tmp___19 ;
  char *tmp___20 ;
  int tmp___21 ;
  int *tmp___22 ;
  char *tmp___23 ;
  char *tmp___24 ;
  int tmp___25 ;
  char *tmp___26 ;
  int tmp___27 ;
  int *tmp___28 ;
  char *tmp___29 ;
  char *tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;
  void *tmp___34 ;
  char *tmp___35 ;

  {
  {
#line 933
  allocated = 0;
#line 933
  i = 0;
#line 934
  dev = (dev_t )0;
#line 940
  mntf = setmntent("/proc/mounts", "r");
  }
#line 941
  if (mntf) {
#line 942
    goto alloc;
  }
  {
#line 944
  mntf = setmntent("/etc/mtab", "r");
  }
#line 945
  if (mntf) {
#line 946
    goto alloc;
  }
  {
#line 948
  mntf = setmntent("/etc/fstab", "r");
  }
#line 948
  if (! mntf) {
    {
#line 949
    tmp = gettext("Cannot open any file with mount points.\n");
#line 949
    errstr(tmp);
    }
#line 950
    return (-1);
  }
  alloc: 
  {
#line 954
  tmp___0 = smalloc(sizeof(struct mount_entry ) * 16UL);
#line 954
  mnt_entries = (struct mount_entry *)tmp___0;
#line 955
  mnt_entries_cnt = 0;
#line 956
  allocated += 16;
#line 958
  tmp___1 = smalloc(sizeof(char *) * 16UL);
#line 958
  autofsdir = (char **)tmp___1;
#line 959
  autofsdircnt = 0;
#line 960
  autofsdir_allocated = 16;
  }
  {
#line 961
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 961
    mnt___2 = getmntent(mntf);
    }
#line 961
    if (! mnt___2) {
#line 961
      goto while_break;
    }
    {
#line 966
    devname = get_device_name((char const   *)mnt___2->mnt_fsname);
    }
#line 966
    if (! devname) {
      {
#line 967
      tmp___2 = gettext("Cannot get device name for %s\n");
#line 967
      errstr(tmp___2, mnt___2->mnt_fsname);
      }
#line 968
      goto while_continue;
    }
#line 972
    i = 0;
    {
#line 972
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 972
      if (! (i < autofsdircnt)) {
#line 972
        goto while_break___0;
      }
      {
#line 973
      tmp___3 = strlen((char const   *)*(autofsdir + i));
#line 973
      slen = (int )tmp___3;
#line 975
      tmp___4 = strlen((char const   *)mnt___2->mnt_dir);
      }
#line 975
      if ((size_t )slen <= tmp___4) {
        {
#line 975
        tmp___5 = strncmp((char const   *)*(autofsdir + i), (char const   *)mnt___2->mnt_dir,
                          (size_t )slen);
        }
#line 975
        if (! tmp___5) {
#line 976
          goto while_break___0;
        }
      }
#line 972
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 978
    if (i < autofsdircnt) {
      {
#line 979
      free((void *)((char *)devname));
      }
#line 980
      goto while_continue;
    }
#line 983
    if (flags___7 & 2) {
      {
#line 983
      tmp___9 = strcmp((char const   *)mnt___2->mnt_type, "autofs");
      }
#line 983
      if (! tmp___9) {
#line 984
        if (autofsdircnt == autofsdir_allocated) {
          {
#line 985
          autofsdir_allocated += 16;
#line 986
          tmp___6 = srealloc((void *)autofsdir, (unsigned long )autofsdir_allocated * sizeof(char *));
#line 986
          autofsdir = (char **)tmp___6;
          }
        }
        {
#line 988
        tmp___7 = strlen((char const   *)mnt___2->mnt_dir);
#line 988
        tmp___8 = smalloc(tmp___7 + 2UL);
#line 988
        *(autofsdir + autofsdircnt) = (char *)tmp___8;
#line 989
        strcpy((char */* __restrict  */)*(autofsdir + autofsdircnt), (char const   */* __restrict  */)mnt___2->mnt_dir);
#line 990
        strcat((char */* __restrict  */)*(autofsdir + autofsdircnt), (char const   */* __restrict  */)"/");
#line 991
        autofsdircnt ++;
#line 992
        free((void *)((char *)devname));
        }
#line 993
        goto while_continue;
      }
    }
#line 996
    if (flags___7 & 8) {
      {
#line 996
      tmp___10 = nfs_fstype(mnt___2->mnt_type);
      }
#line 996
      if (tmp___10) {
        {
#line 997
        free((void *)((char *)devname));
        }
#line 998
        goto while_continue;
      }
    }
    {
#line 1000
    tmp___11 = hasmntopt((struct mntent  const  *)mnt___2, "noquota");
    }
#line 1000
    if (tmp___11) {
      {
#line 1001
      free((void *)((char *)devname));
      }
#line 1002
      goto while_continue;
    }
    {
#line 1004
    tmp___12 = hasmntopt((struct mntent  const  *)mnt___2, "bind");
    }
#line 1004
    if (tmp___12) {
      {
#line 1005
      free((void *)((char *)devname));
      }
#line 1006
      goto while_continue;
    }
    {
#line 1008
    opt = hasmntoptarg((char const   *)mnt___2->mnt_opts, "loop");
    }
#line 1008
    if (opt) {
      {
#line 1011
      copy_mntoptarg(opt, (char const   *)(loopdev), 4096);
#line 1012
      free((void *)((char *)devname));
#line 1013
      tmp___13 = sstrdup((char const   *)(loopdev));
#line 1013
      devname = (char const   *)tmp___13;
      }
    }
    {
#line 1018
    qfmt[0] = hasquota(devname, mnt___2, 0, flags___7);
#line 1019
    qfmt[1] = hasquota(devname, mnt___2, 1, flags___7);
    }
#line 1020
    if (qfmt[0] < 0) {
#line 1020
      if (qfmt[1] < 0) {
        {
#line 1021
        free((void *)((char *)devname));
        }
#line 1022
        goto while_continue;
      }
    }
    {
#line 1025
    tmp___17 = realpath((char const   */* __restrict  */)mnt___2->mnt_dir, (char */* __restrict  */)(mntpointbuf));
    }
#line 1025
    if (! tmp___17) {
      {
#line 1026
      tmp___14 = __errno_location();
#line 1026
      tmp___15 = strerror(*tmp___14);
#line 1026
      tmp___16 = gettext("Cannot resolve mountpoint path %s: %s\n");
#line 1026
      errstr(tmp___16, mnt___2->mnt_dir, tmp___15);
#line 1027
      free((void *)((char *)devname));
      }
#line 1028
      goto while_continue;
    }
    {
#line 1031
    tmp___21 = statfs((char const   *)(mntpointbuf), & fsstat);
    }
#line 1031
    if (tmp___21 != 0) {
      {
#line 1032
      tmp___18 = __errno_location();
#line 1032
      tmp___19 = strerror(*tmp___18);
#line 1032
      tmp___20 = gettext("Cannot statfs() %s: %s\n");
#line 1032
      errstr(tmp___20, mntpointbuf, tmp___19);
#line 1033
      free((void *)((char *)devname));
      }
#line 1034
      goto while_continue;
    }
#line 1037
    if (fsstat.f_blocks == 0UL) {
#line 1037
      if (fsstat.f_bfree == 0UL) {
#line 1037
        if (fsstat.f_bavail == 0UL) {
          {
#line 1038
          free((void *)((char *)devname));
          }
#line 1039
          goto while_continue;
        }
      }
    }
    {
#line 1042
    tmp___27 = nfs_fstype(mnt___2->mnt_type);
    }
#line 1042
    if (! tmp___27) {
      {
#line 1043
      tmp___25 = stat((char const   */* __restrict  */)devname, (struct stat */* __restrict  */)(& st));
      }
#line 1043
      if (tmp___25 < 0) {
        {
#line 1044
        tmp___22 = __errno_location();
#line 1044
        tmp___23 = strerror(*tmp___22);
#line 1044
        tmp___24 = gettext("Cannot stat() mounted device %s: %s\n");
#line 1044
        errstr(tmp___24, devname, tmp___23);
#line 1045
        free((void *)((char *)devname));
        }
#line 1046
        goto while_continue;
      }
#line 1048
      if (! ((st.st_mode & 61440U) == 24576U)) {
#line 1048
        if (! ((st.st_mode & 61440U) == 8192U)) {
          {
#line 1049
          tmp___26 = gettext("Device (%s) filesystem is mounted on unsupported device type. Skipping.\n");
#line 1049
          errstr(tmp___26, devname);
#line 1050
          free((void *)((char *)devname));
          }
#line 1051
          goto while_continue;
        }
      }
#line 1053
      dev = st.st_rdev;
#line 1054
      i = 0;
      {
#line 1054
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1054
        if (i < mnt_entries_cnt) {
#line 1054
          if (! ((mnt_entries + i)->me_dev != dev)) {
#line 1054
            goto while_break___1;
          }
        } else {
#line 1054
          goto while_break___1;
        }
#line 1054
        i ++;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
    {
#line 1057
    tmp___33 = nfs_fstype(mnt___2->mnt_type);
    }
#line 1057
    if (tmp___33) {
#line 1057
      goto _L;
    } else
#line 1057
    if (i == mnt_entries_cnt) {
      _L: /* CIL Label */ 
      {
#line 1058
      tmp___31 = stat((char const   */* __restrict  */)mnt___2->mnt_dir, (struct stat */* __restrict  */)(& st));
      }
#line 1058
      if (tmp___31 < 0) {
        {
#line 1059
        tmp___28 = __errno_location();
#line 1059
        tmp___29 = strerror(*tmp___28);
#line 1059
        tmp___30 = gettext("Cannot stat() mountpoint %s: %s\n");
#line 1059
        errstr(tmp___30, mnt___2->mnt_dir, tmp___29);
#line 1060
        free((void *)((char *)devname));
        }
#line 1061
        goto while_continue;
      }
      {
#line 1063
      tmp___32 = nfs_fstype(mnt___2->mnt_type);
      }
#line 1063
      if (tmp___32) {
#line 1065
        dev = st.st_dev;
#line 1066
        if (! (flags___7 & 32)) {
#line 1067
          i = 0;
          {
#line 1067
          while (1) {
            while_continue___2: /* CIL Label */ ;
#line 1067
            if (i < mnt_entries_cnt) {
#line 1067
              if (! ((mnt_entries + i)->me_dev != dev)) {
#line 1067
                goto while_break___2;
              }
            } else {
#line 1067
              goto while_break___2;
            }
#line 1067
            i ++;
          }
          while_break___2: /* CIL Label */ ;
          }
        } else {
#line 1070
          i = mnt_entries_cnt;
        }
      }
    }
#line 1073
    if (i == mnt_entries_cnt) {
#line 1074
      if (allocated == mnt_entries_cnt) {
        {
#line 1075
        allocated += 16;
#line 1076
        tmp___34 = srealloc((void *)mnt_entries, (unsigned long )allocated * sizeof(struct mount_entry ));
#line 1076
        mnt_entries = (struct mount_entry *)tmp___34;
        }
      }
      {
#line 1078
      (mnt_entries + i)->me_type = sstrdup((char const   *)mnt___2->mnt_type);
#line 1079
      (mnt_entries + i)->me_opts = sstrdup((char const   *)mnt___2->mnt_opts);
#line 1080
      (mnt_entries + i)->me_dev = dev;
#line 1081
      (mnt_entries + i)->me_ino = st.st_ino;
#line 1082
      (mnt_entries + i)->me_devname = devname;
#line 1083
      tmp___35 = sstrdup((char const   *)(mntpointbuf));
#line 1083
      (mnt_entries + i)->me__dir = (char const   *)tmp___35;
#line 1084
      (mnt_entries + i)->me_dir = (char const   *)((void *)0);
#line 1085
      memcpy((void */* __restrict  */)(& (mnt_entries + i)->me_qfmt), (void const   */* __restrict  */)(qfmt),
             sizeof(qfmt));
#line 1086
      mnt_entries_cnt ++;
      }
    } else {
      {
#line 1089
      free((void *)((char *)devname));
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1091
  endmntent(mntf);
#line 1093
  i = 0;
  }
  {
#line 1093
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 1093
    if (! (i < autofsdircnt)) {
#line 1093
      goto while_break___3;
    }
    {
#line 1094
    free((void *)*(autofsdir + i));
#line 1093
    i ++;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 1095
  free((void *)autofsdir);
  }
#line 1096
  return (0);
}
}
#line 1100 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static char const   *find_dir_mntpoint(struct stat *st ) 
{ 
  int i ;

  {
#line 1104
  i = 0;
  {
#line 1104
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1104
    if (! (i < mnt_entries_cnt)) {
#line 1104
      goto while_break;
    }
#line 1105
    if ((mnt_entries + i)->me_dev == st->st_dev) {
#line 1106
      st->st_ino = (mnt_entries + i)->me_ino;
#line 1107
      return ((mnt_entries + i)->me__dir);
    }
#line 1104
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1109
  return ((char const   *)((void *)0));
}
}
#line 1113 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static int process_dirs(int dcnt , char **dirs , int flags___7 ) 
{ 
  struct stat st ;
  int i ;
  char mntpointbuf[4096] ;
  void *tmp ;
  char *devname ;
  char const   *tmp___0 ;
  char *tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  int *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  char const   *realmnt ;
  char *tmp___12 ;
  int *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  int mentry ;
  char *tmp___17 ;
  char *tmp___18 ;
  char *tmp___19 ;
  char *tmp___20 ;

  {
#line 1119
  check_dirs_cnt = 0;
#line 1120
  act_checked = -1;
#line 1121
  if (dcnt) {
    {
#line 1122
    tmp = smalloc(sizeof(struct searched_dir ) * (unsigned long )dcnt);
#line 1122
    check_dirs = (struct searched_dir *)tmp;
#line 1123
    i = 0;
    }
    {
#line 1123
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1123
      if (! (i < dcnt)) {
#line 1123
        goto while_break;
      }
      {
#line 1124
      tmp___10 = strncmp((char const   *)*(dirs + i), "UUID=", (size_t )5);
      }
#line 1124
      if (tmp___10) {
        {
#line 1124
        tmp___11 = strncmp((char const   *)*(dirs + i), "LABEL=", (size_t )6);
        }
#line 1124
        if (tmp___11) {
          {
#line 1139
          tmp___9 = stat((char const   */* __restrict  */)*(dirs + i), (struct stat */* __restrict  */)(& st));
          }
#line 1139
          if (tmp___9 < 0) {
            {
#line 1140
            tmp___6 = __errno_location();
#line 1140
            tmp___7 = strerror(*tmp___6);
#line 1140
            tmp___8 = gettext("Cannot stat() given mountpoint %s: %s\nSkipping...\n");
#line 1140
            errstr(tmp___8, *(dirs + i), tmp___7);
            }
#line 1141
            goto __Cont;
          }
        } else {
          _L: /* CIL Label */ 
          {
#line 1125
          tmp___0 = get_device_name((char const   *)*(dirs + i));
#line 1125
          devname = (char *)tmp___0;
          }
#line 1127
          if (! devname) {
            {
#line 1128
            tmp___1 = gettext("Cannot find a device with %s.\nSkipping...\n");
#line 1128
            errstr(tmp___1, *(dirs + i));
            }
#line 1129
            goto __Cont;
          }
          {
#line 1131
          tmp___5 = stat((char const   */* __restrict  */)devname, (struct stat */* __restrict  */)(& st));
          }
#line 1131
          if (tmp___5 < 0) {
            {
#line 1132
            tmp___2 = __errno_location();
#line 1132
            tmp___3 = strerror(*tmp___2);
#line 1132
            tmp___4 = gettext("Cannot stat() a mountpoint with %s: %s\nSkipping...\n");
#line 1132
            errstr(tmp___4, *(dirs + i), tmp___3);
#line 1133
            free((void *)devname);
            }
#line 1134
            goto __Cont;
          }
          {
#line 1136
          free((void *)devname);
          }
        }
      } else {
#line 1124
        goto _L;
      }
#line 1143
      (check_dirs + check_dirs_cnt)->sd_dir = (st.st_mode & 61440U) == 16384U;
#line 1144
      if ((st.st_mode & 61440U) == 16384U) {
#line 1145
        realmnt = (char const   *)*(dirs + i);
#line 1148
        if (flags___7 & 1) {
          {
#line 1148
          realmnt = find_dir_mntpoint(& st);
          }
#line 1148
          if (! realmnt) {
#line 1149
            if (! (flags___7 & 4)) {
              {
#line 1150
              tmp___12 = gettext("Cannot find a filesystem mountpoint for directory %s\n");
#line 1150
              errstr(tmp___12, *(dirs + i));
              }
            }
#line 1151
            goto __Cont;
          }
        }
        {
#line 1153
        (check_dirs + check_dirs_cnt)->sd_dev = st.st_dev;
#line 1154
        (check_dirs + check_dirs_cnt)->sd_ino = st.st_ino;
#line 1155
        tmp___16 = realpath((char const   */* __restrict  */)realmnt, (char */* __restrict  */)(mntpointbuf));
        }
#line 1155
        if (! tmp___16) {
          {
#line 1156
          tmp___13 = __errno_location();
#line 1156
          tmp___14 = strerror(*tmp___13);
#line 1156
          tmp___15 = gettext("Cannot resolve path %s: %s\n");
#line 1156
          errstr(tmp___15, realmnt, tmp___14);
          }
#line 1157
          goto __Cont;
        }
      } else
#line 1160
      if ((st.st_mode & 61440U) == 24576U) {
#line 1160
        goto _L___0;
      } else
#line 1160
      if ((st.st_mode & 61440U) == 8192U) {
        _L___0: /* CIL Label */ 
#line 1163
        (check_dirs + check_dirs_cnt)->sd_dev = st.st_rdev;
#line 1164
        mentry = 0;
        {
#line 1164
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 1164
          if (mentry < mnt_entries_cnt) {
#line 1164
            if (! ((mnt_entries + mentry)->me_dev != st.st_rdev)) {
#line 1164
              goto while_break___0;
            }
          } else {
#line 1164
            goto while_break___0;
          }
#line 1164
          mentry ++;
        }
        while_break___0: /* CIL Label */ ;
        }
#line 1165
        if (mentry == mnt_entries_cnt) {
#line 1166
          if (! (flags___7 & 4)) {
            {
#line 1167
            tmp___17 = gettext("Cannot find mountpoint for device %s\n");
#line 1167
            errstr(tmp___17, *(dirs + i));
            }
          }
#line 1168
          goto __Cont;
        }
        {
#line 1170
        sstrncpy(mntpointbuf, (mnt_entries + mentry)->me__dir, (size_t )4095);
        }
      } else {
        {
#line 1173
        tmp___18 = gettext("Specified path %s is not directory nor device.\n");
#line 1173
        errstr(tmp___18, *(dirs + i));
        }
#line 1174
        goto __Cont;
      }
      {
#line 1176
      tmp___19 = sstrdup((char const   *)(mntpointbuf));
#line 1176
      (check_dirs + check_dirs_cnt)->sd_name = (char const   *)tmp___19;
#line 1177
      check_dirs_cnt ++;
      }
      __Cont: /* CIL Label */ 
#line 1123
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 1179
    if (! check_dirs_cnt) {
#line 1180
      if (! (flags___7 & 4)) {
        {
#line 1181
        tmp___20 = gettext("No correct mountpoint specified.\n");
#line 1181
        errstr(tmp___20);
        }
      }
      {
#line 1182
      free((void *)check_dirs);
      }
#line 1183
      return (-1);
    }
  }
#line 1186
  return (0);
}
}
#line 1192 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
int init_mounts_scan(int dcnt , char **dirs , int flags___7 ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
#line 1194
  tmp = cache_mnt_table(flags___7);
  }
#line 1194
  if (tmp < 0) {
#line 1195
    return (-1);
  }
  {
#line 1196
  tmp___0 = process_dirs(dcnt, dirs, flags___7);
  }
#line 1196
  if (tmp___0 < 0) {
    {
#line 1197
    end_mounts_scan();
    }
#line 1198
    return (-1);
  }
#line 1200
  return (0);
}
}
#line 1204 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static int find_next_entry_all(int *pos ) 
{ 
  char *tmp ;

  {
  {
#line 1206
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1206
    act_checked ++;
#line 1206
    if (! (act_checked < mnt_entries_cnt)) {
#line 1206
      goto while_break;
    }
    {
#line 1207
    tmp = str_hasmntopt((char const   *)(mnt_entries + act_checked)->me_opts, "noauto");
    }
#line 1207
    if (! tmp) {
#line 1208
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1210
  if (act_checked >= mnt_entries_cnt) {
#line 1211
    return (0);
  }
#line 1212
  *pos = act_checked;
#line 1213
  return (1);
}
}
#line 1217 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static int find_next_entry_sel(int *pos ) 
{ 
  int i ;
  struct searched_dir *sd ;
  char *tmp ;

  {
  restart: 
#line 1223
  act_checked ++;
#line 1223
  if (act_checked == check_dirs_cnt) {
#line 1224
    return (0);
  }
#line 1225
  sd = check_dirs + act_checked;
#line 1226
  i = 0;
  {
#line 1226
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1226
    if (! (i < mnt_entries_cnt)) {
#line 1226
      goto while_break;
    }
#line 1227
    if (sd->sd_dir) {
#line 1228
      if (sd->sd_dev == (mnt_entries + i)->me_dev) {
#line 1228
        if (sd->sd_ino == (mnt_entries + i)->me_ino) {
#line 1229
          goto while_break;
        }
      }
    } else
#line 1232
    if (sd->sd_dev == (mnt_entries + i)->me_dev) {
#line 1233
      goto while_break;
    }
#line 1226
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1235
  if (i == mnt_entries_cnt) {
    {
#line 1236
    tmp = gettext("Mountpoint (or device) %s not found or has no quota enabled.\n");
#line 1236
    errstr(tmp, sd->sd_name);
    }
#line 1237
    goto restart;
  }
#line 1239
  *pos = i;
#line 1240
  return (1);
}
}
#line 1246 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
struct mount_entry *get_next_mount(void) 
{ 
  int mntpos ;
  int tmp ;
  int tmp___0 ;

  {
#line 1250
  if (! check_dirs_cnt) {
    {
#line 1251
    tmp = find_next_entry_all(& mntpos);
    }
#line 1251
    if (! tmp) {
#line 1252
      return ((struct mount_entry *)((void *)0));
    }
#line 1253
    (mnt_entries + mntpos)->me_dir = (mnt_entries + mntpos)->me__dir;
  } else {
    {
#line 1256
    tmp___0 = find_next_entry_sel(& mntpos);
    }
#line 1256
    if (! tmp___0) {
#line 1257
      return ((struct mount_entry *)((void *)0));
    }
#line 1258
    (mnt_entries + mntpos)->me_dir = (check_dirs + act_checked)->sd_name;
  }
#line 1260
  return (mnt_entries + mntpos);
}
}
#line 1266 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
void end_mounts_scan(void) 
{ 
  int i ;

  {
#line 1270
  i = 0;
  {
#line 1270
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1270
    if (! (i < mnt_entries_cnt)) {
#line 1270
      goto while_break;
    }
    {
#line 1271
    free((void *)(mnt_entries + i)->me_type);
#line 1272
    free((void *)(mnt_entries + i)->me_opts);
#line 1273
    free((void *)((char *)(mnt_entries + i)->me_devname));
#line 1274
    free((void *)((char *)(mnt_entries + i)->me__dir));
#line 1270
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1276
  free((void *)mnt_entries);
#line 1277
  mnt_entries = (struct mount_entry *)((void *)0);
#line 1278
  mnt_entries_cnt = 0;
  }
#line 1279
  if (check_dirs_cnt) {
#line 1280
    i = 0;
    {
#line 1280
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1280
      if (! (i < check_dirs_cnt)) {
#line 1280
        goto while_break___0;
      }
      {
#line 1281
      free((void *)((char *)(check_dirs + i)->sd_name));
#line 1280
      i ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 1282
    free((void *)check_dirs);
    }
  }
#line 1284
  check_dirs = (struct searched_dir *)((void *)0);
#line 1285
  check_dirs_cnt = 0;
#line 1286
  return;
}
}
#line 43 "/home/wheatley/newnew/temp/quota-4.01/quota_tree.h"
void qtree_write_dquot(struct dquot *dquot ) ;
#line 44
struct dquot *qtree_read_dquot(struct quota_handle *h , qid_t id___0 ) ;
#line 45
void qtree_delete_dquot(struct dquot *dquot ) ;
#line 46
int qtree_entry_unused(struct qtree_mem_dqinfo *info , char *disk ) ;
#line 47
int qtree_scan_dquots(struct quota_handle *h , int (*process_dquot)(struct dquot * ,
                                                                    char * ) ) ;
#line 49
int qtree_dqstr_in_blk(struct qtree_mem_dqinfo *info ) ;
#line 160 "/home/wheatley/newnew/temp/quota-4.01/quotaio.h"
__inline static void mark_quotafile_info_dirty(struct quota_handle *h ) 
{ 


  {
#line 162
  h->qh_io_flags |= 2;
#line 163
  return;
}
}
#line 30 "/home/wheatley/newnew/temp/quota-4.01/quotaio_tree.c"
int qtree_entry_unused(struct qtree_mem_dqinfo *info , char *disk ) 
{ 
  int i ;

  {
#line 34
  i = 0;
  {
#line 34
  while (1) {
    while_continue: /* CIL Label */ ;
#line 34
    if (! ((unsigned int )i < info->dqi_entry_size)) {
#line 34
      goto while_break;
    }
#line 35
    if (*(disk + i)) {
#line 36
      return (0);
    }
#line 34
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 37
  return (1);
}
}
#line 40 "/home/wheatley/newnew/temp/quota-4.01/quotaio_tree.c"
int qtree_dqstr_in_blk(struct qtree_mem_dqinfo *info ) 
{ 


  {
#line 42
  return ((int )(((unsigned long )(1 << 10) - sizeof(struct qt_disk_dqdbheader )) / (unsigned long )info->dqi_entry_size));
}
}
#line 45 "/home/wheatley/newnew/temp/quota-4.01/quotaio_tree.c"
static int get_index(qid_t id___0 , int depth ) 
{ 


  {
#line 47
  return ((int )((id___0 >> ((4 - depth) - 1) * 8) & 255U));
}
}
#line 51 "/home/wheatley/newnew/temp/quota-4.01/quotaio_tree.c"
static void read_blk(struct quota_handle *h , uint blk , dqbuf_t buf ) 
{ 
  int err ;
  ssize_t tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 55
  lseek(h->qh_fd, (__off64_t )(blk << 10), 0);
#line 56
  tmp = read(h->qh_fd, (void *)buf, (size_t )(1 << 10));
#line 56
  err = (int )tmp;
  }
#line 57
  if (err < 0) {
    {
#line 58
    tmp___0 = __errno_location();
#line 58
    tmp___1 = strerror(*tmp___0);
#line 58
    tmp___2 = gettext("Cannot read block %u: %s\n");
#line 58
    die(2, tmp___2, blk, tmp___1);
    }
  } else
#line 59
  if (err != 1 << 10) {
    {
#line 60
    memset((void *)(buf + err), 0, (size_t )((1 << 10) - err));
    }
  }
#line 61
  return;
}
}
#line 64 "/home/wheatley/newnew/temp/quota-4.01/quotaio_tree.c"
static int write_blk(struct quota_handle *h , uint blk , dqbuf_t buf ) 
{ 
  int err ;
  ssize_t tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  int *tmp___3 ;

  {
  {
#line 68
  lseek(h->qh_fd, (__off64_t )(blk << 10), 0);
#line 69
  tmp = write(h->qh_fd, (void const   *)buf, (size_t )(1 << 10));
#line 69
  err = (int )tmp;
  }
#line 70
  if (err < 0) {
    {
#line 70
    tmp___3 = __errno_location();
    }
#line 70
    if (*tmp___3 != 28) {
      {
#line 71
      tmp___0 = __errno_location();
#line 71
      tmp___1 = strerror(*tmp___0);
#line 71
      tmp___2 = gettext("Cannot write block (%u): %s\n");
#line 71
      die(2, tmp___2, blk, tmp___1);
      }
    }
  }
#line 72
  if (err != 1 << 10) {
#line 73
    return (-28);
  }
#line 74
  return (0);
}
}
#line 78 "/home/wheatley/newnew/temp/quota-4.01/quotaio_tree.c"
static int get_free_dqblk(struct quota_handle *h ) 
{ 
  dqbuf_t buf ;
  void *tmp ;
  struct qt_disk_dqdbheader *dh ;
  struct qtree_mem_dqinfo *info ;
  int blk ;
  char *tmp___0 ;
  int tmp___1 ;
  unsigned int tmp___2 ;

  {
  {
#line 80
  tmp = smalloc((size_t )(1 << 10));
#line 80
  buf = (dqbuf_t )tmp;
#line 81
  dh = (struct qt_disk_dqdbheader *)buf;
#line 82
  info = & h->qh_info.u.v2_mdqi.dqi_qtree;
  }
#line 85
  if (info->dqi_free_blk) {
    {
#line 86
    blk = (int )info->dqi_free_blk;
#line 87
    read_blk(h, (uint )blk, buf);
#line 88
    info->dqi_free_blk = dh->dqdh_next_free;
    }
  } else {
    {
#line 91
    memset((void *)buf, 0, (size_t )(1 << 10));
#line 92
    tmp___1 = write_blk(h, info->dqi_blocks, buf);
    }
#line 92
    if (tmp___1 < 0) {
      {
#line 93
      free((void *)buf);
#line 94
      tmp___0 = gettext("Cannot allocate new quota block (out of disk space).\n");
#line 94
      errstr(tmp___0);
      }
#line 95
      return (-28);
    }
#line 97
    tmp___2 = info->dqi_blocks;
#line 97
    (info->dqi_blocks) ++;
#line 97
    blk = (int )tmp___2;
  }
  {
#line 99
  mark_quotafile_info_dirty(h);
#line 100
  free((void *)buf);
  }
#line 101
  return (blk);
}
}
#line 105 "/home/wheatley/newnew/temp/quota-4.01/quotaio_tree.c"
static void put_free_dqblk(struct quota_handle *h , dqbuf_t buf , uint blk ) 
{ 
  struct qt_disk_dqdbheader *dh ;
  struct qtree_mem_dqinfo *info ;

  {
  {
#line 107
  dh = (struct qt_disk_dqdbheader *)buf;
#line 108
  info = & h->qh_info.u.v2_mdqi.dqi_qtree;
#line 110
  dh->dqdh_next_free = info->dqi_free_blk;
#line 111
  dh->dqdh_prev_free = (__u32 )0;
#line 112
  dh->dqdh_entries = (__u16 )0;
#line 113
  info->dqi_free_blk = blk;
#line 114
  mark_quotafile_info_dirty(h);
#line 115
  write_blk(h, blk, buf);
  }
#line 116
  return;
}
}
#line 119 "/home/wheatley/newnew/temp/quota-4.01/quotaio_tree.c"
static void remove_free_dqentry(struct quota_handle *h , dqbuf_t buf , uint blk ) 
{ 
  dqbuf_t tmpbuf ;
  void *tmp ;
  struct qt_disk_dqdbheader *dh ;
  uint nextblk ;
  uint prevblk ;
  u_int32_t tmp___0 ;

  {
  {
#line 121
  tmp = smalloc((size_t )(1 << 10));
#line 121
  tmpbuf = (dqbuf_t )tmp;
#line 122
  dh = (struct qt_disk_dqdbheader *)buf;
#line 123
  nextblk = dh->dqdh_next_free;
#line 123
  prevblk = dh->dqdh_prev_free;
  }
#line 127
  if (nextblk) {
    {
#line 128
    read_blk(h, nextblk, tmpbuf);
#line 129
    ((struct qt_disk_dqdbheader *)tmpbuf)->dqdh_prev_free = dh->dqdh_prev_free;
#line 130
    write_blk(h, nextblk, tmpbuf);
    }
  }
#line 132
  if (prevblk) {
    {
#line 133
    read_blk(h, prevblk, tmpbuf);
#line 134
    ((struct qt_disk_dqdbheader *)tmpbuf)->dqdh_next_free = dh->dqdh_next_free;
#line 135
    write_blk(h, prevblk, tmpbuf);
    }
  } else {
    {
#line 138
    h->qh_info.u.v2_mdqi.dqi_qtree.dqi_free_entry = nextblk;
#line 139
    mark_quotafile_info_dirty(h);
    }
  }
  {
#line 141
  free((void *)tmpbuf);
#line 142
  tmp___0 = (__u32 )0;
#line 142
  dh->dqdh_prev_free = tmp___0;
#line 142
  dh->dqdh_next_free = tmp___0;
#line 143
  write_blk(h, blk, buf);
  }
#line 144
  return;
}
}
#line 147 "/home/wheatley/newnew/temp/quota-4.01/quotaio_tree.c"
static void insert_free_dqentry(struct quota_handle *h , dqbuf_t buf , uint blk ) 
{ 
  dqbuf_t tmpbuf ;
  void *tmp ;
  struct qt_disk_dqdbheader *dh ;
  struct qtree_mem_dqinfo *info ;

  {
  {
#line 149
  tmp = smalloc((size_t )(1 << 10));
#line 149
  tmpbuf = (dqbuf_t )tmp;
#line 150
  dh = (struct qt_disk_dqdbheader *)buf;
#line 151
  info = & h->qh_info.u.v2_mdqi.dqi_qtree;
#line 153
  dh->dqdh_next_free = info->dqi_free_entry;
#line 154
  dh->dqdh_prev_free = (__u32 )0;
#line 155
  write_blk(h, blk, buf);
  }
#line 156
  if (info->dqi_free_entry) {
    {
#line 157
    read_blk(h, info->dqi_free_entry, tmpbuf);
#line 158
    ((struct qt_disk_dqdbheader *)tmpbuf)->dqdh_prev_free = blk;
#line 159
    write_blk(h, info->dqi_free_entry, tmpbuf);
    }
  }
  {
#line 161
  free((void *)tmpbuf);
#line 162
  info->dqi_free_entry = blk;
#line 163
  mark_quotafile_info_dirty(h);
  }
#line 164
  return;
}
}
#line 167 "/home/wheatley/newnew/temp/quota-4.01/quotaio_tree.c"
static uint find_free_dqentry(struct quota_handle *h , struct dquot *dquot , int *err ) 
{ 
  int blk ;
  int i ;
  struct qt_disk_dqdbheader *dh ;
  struct qtree_mem_dqinfo *info ;
  char *ddquot ;
  dqbuf_t buf ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;

  {
  {
#line 171
  info = & h->qh_info.u.v2_mdqi.dqi_qtree;
#line 175
  *err = 0;
#line 176
  tmp = smalloc((size_t )(1 << 10));
#line 176
  buf = (dqbuf_t )tmp;
#line 177
  dh = (struct qt_disk_dqdbheader *)buf;
  }
#line 178
  if (info->dqi_free_entry) {
    {
#line 179
    blk = (int )info->dqi_free_entry;
#line 180
    read_blk(h, (uint )blk, buf);
    }
  } else {
    {
#line 183
    blk = get_free_dqblk(h);
    }
#line 184
    if (blk < 0) {
      {
#line 185
      free((void *)buf);
#line 186
      *err = blk;
      }
#line 187
      return ((uint )0);
    }
    {
#line 189
    memset((void *)buf, 0, (size_t )(1 << 10));
#line 190
    info->dqi_free_entry = (unsigned int )blk;
#line 191
    mark_quotafile_info_dirty(h);
    }
  }
  {
#line 193
  tmp___0 = qtree_dqstr_in_blk(info);
  }
#line 193
  if ((int )dh->dqdh_entries + 1 >= tmp___0) {
    {
#line 194
    remove_free_dqentry(h, buf, (uint )blk);
    }
  }
#line 195
  dh->dqdh_entries = (__u16 )((int )dh->dqdh_entries + 1);
#line 197
  ddquot = buf + sizeof(struct qt_disk_dqdbheader );
#line 198
  i = 0;
  {
#line 198
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 198
    tmp___1 = qtree_dqstr_in_blk(info);
    }
#line 198
    if (i < tmp___1) {
      {
#line 198
      tmp___2 = qtree_entry_unused(info, ddquot);
      }
#line 198
      if (tmp___2) {
#line 198
        goto while_break;
      }
    } else {
#line 198
      goto while_break;
    }
#line 198
    i ++;
#line 198
    ddquot += info->dqi_entry_size;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 201
  tmp___4 = qtree_dqstr_in_blk(info);
  }
#line 201
  if (i == tmp___4) {
    {
#line 202
    tmp___3 = gettext("find_free_dqentry(): Data block full but it shouldn\'t.\n");
#line 202
    die(2, tmp___3);
    }
  }
  {
#line 203
  write_blk(h, (uint )blk, buf);
#line 204
  dquot->dq_dqb.u.v2_mdqb.dqb_off = (loff_t )(((unsigned long )(blk << 10) + sizeof(struct qt_disk_dqdbheader )) + (unsigned long )((unsigned int )i * info->dqi_entry_size));
#line 207
  free((void *)buf);
  }
#line 208
  return ((uint )blk);
}
}
#line 212 "/home/wheatley/newnew/temp/quota-4.01/quotaio_tree.c"
static int do_insert_tree(struct quota_handle *h , struct dquot *dquot , uint *treeblk ,
                          int depth ) 
{ 
  dqbuf_t buf ;
  int newson ;
  int newact ;
  u_int32_t *ref ;
  uint newblk ;
  int ret ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;

  {
  {
#line 215
  newson = 0;
#line 215
  newact = 0;
#line 218
  ret = 0;
#line 220
  tmp = smalloc((size_t )(1 << 10));
#line 220
  buf = (dqbuf_t )tmp;
  }
#line 221
  if (! *treeblk) {
    {
#line 222
    ret = get_free_dqblk(h);
    }
#line 223
    if (ret < 0) {
#line 224
      goto out_buf;
    }
    {
#line 225
    *treeblk = (uint )ret;
#line 226
    memset((void *)buf, 0, (size_t )(1 << 10));
#line 227
    newact = 1;
    }
  } else {
    {
#line 230
    read_blk(h, *treeblk, buf);
    }
  }
  {
#line 231
  ref = (u_int32_t *)buf;
#line 232
  tmp___0 = get_index(dquot->dq_id, depth);
#line 232
  newblk = *(ref + tmp___0);
  }
#line 233
  if (! newblk) {
#line 234
    newson = 1;
  }
#line 235
  if (depth == 3) {
#line 236
    if (newblk) {
      {
#line 237
      tmp___1 = get_index(dquot->dq_id, depth);
#line 237
      tmp___2 = gettext("Inserting already present quota entry (block %u).\n");
#line 237
      die(2, tmp___2, *(ref + tmp___1));
      }
    }
    {
#line 239
    newblk = find_free_dqentry(h, dquot, & ret);
    }
  } else {
    {
#line 242
    ret = do_insert_tree(h, dquot, & newblk, depth + 1);
    }
  }
#line 243
  if (newson) {
#line 243
    if (ret >= 0) {
      {
#line 244
      tmp___3 = get_index(dquot->dq_id, depth);
#line 244
      *(ref + tmp___3) = newblk;
#line 245
      write_blk(h, *treeblk, buf);
      }
    } else {
#line 243
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 247
  if (newact) {
#line 247
    if (ret < 0) {
      {
#line 248
      put_free_dqblk(h, buf, *treeblk);
      }
    }
  }
  out_buf: 
  {
#line 250
  free((void *)buf);
  }
#line 251
  return (ret);
}
}
#line 255 "/home/wheatley/newnew/temp/quota-4.01/quotaio_tree.c"
static void dq_insert_tree(struct quota_handle *h , struct dquot *dquot ) 
{ 
  uint tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;

  {
  {
#line 257
  tmp = (uint )1;
#line 259
  tmp___3 = do_insert_tree(h, dquot, & tmp, 0);
  }
#line 259
  if (tmp___3 < 0) {
    {
#line 260
    tmp___0 = __errno_location();
#line 260
    tmp___1 = strerror(*tmp___0);
#line 260
    tmp___2 = gettext("Cannot write quota (id %u): %s\n");
#line 260
    die(2, tmp___2, dquot->dq_id, tmp___1);
    }
  }
#line 261
  return;
}
}
#line 264 "/home/wheatley/newnew/temp/quota-4.01/quotaio_tree.c"
void qtree_write_dquot(struct dquot *dquot ) 
{ 
  ssize_t ret ;
  struct qtree_mem_dqinfo *info ;
  char *ddquot ;
  void *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;

  {
  {
#line 267
  info = & (dquot->dq_h)->qh_info.u.v2_mdqi.dqi_qtree;
#line 268
  tmp = smalloc((size_t )info->dqi_entry_size);
#line 268
  ddquot = (char *)tmp;
  }
#line 270
  if (! dquot->dq_dqb.u.v2_mdqb.dqb_off) {
    {
#line 271
    dq_insert_tree(dquot->dq_h, dquot);
    }
  }
  {
#line 272
  lseek((dquot->dq_h)->qh_fd, dquot->dq_dqb.u.v2_mdqb.dqb_off, 0);
#line 273
  (*((info->dqi_ops)->mem2disk_dqblk))((void *)ddquot, dquot);
#line 274
  ret = write((dquot->dq_h)->qh_fd, (void const   *)ddquot, (size_t )info->dqi_entry_size);
#line 275
  free((void *)ddquot);
  }
#line 276
  if (ret != (ssize_t )info->dqi_entry_size) {
#line 277
    if (ret > 0L) {
      {
#line 278
      tmp___0 = __errno_location();
#line 278
      *tmp___0 = 28;
      }
    }
    {
#line 279
    tmp___1 = __errno_location();
#line 279
    tmp___2 = strerror(*tmp___1);
#line 279
    tmp___3 = gettext("Quota write failed (id %u): %s\n");
#line 279
    die(2, tmp___3, dquot->dq_id, tmp___2);
    }
  }
#line 281
  return;
}
}
#line 284 "/home/wheatley/newnew/temp/quota-4.01/quotaio_tree.c"
static void free_dqentry(struct quota_handle *h , struct dquot *dquot , uint blk ) 
{ 
  struct qt_disk_dqdbheader *dh ;
  struct qtree_mem_dqinfo *info ;
  dqbuf_t buf ;
  void *tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 287
  info = & h->qh_info.u.v2_mdqi.dqi_qtree;
#line 288
  tmp = smalloc((size_t )(1 << 10));
#line 288
  buf = (dqbuf_t )tmp;
  }
#line 290
  if (dquot->dq_dqb.u.v2_mdqb.dqb_off >> 10 != (loff_t )blk) {
    {
#line 291
    tmp___0 = gettext("Quota structure has offset to other block (%u) than it should (%u).\n");
#line 291
    die(2, tmp___0, blk, (uint )(dquot->dq_dqb.u.v2_mdqb.dqb_off >> 10));
    }
  }
  {
#line 293
  read_blk(h, blk, buf);
#line 294
  dh = (struct qt_disk_dqdbheader *)buf;
#line 295
  dh->dqdh_entries = (__u16 )((int )dh->dqdh_entries - 1);
  }
#line 296
  if (! dh->dqdh_entries) {
    {
#line 297
    remove_free_dqentry(h, buf, blk);
#line 298
    put_free_dqblk(h, buf, blk);
    }
  } else {
    {
#line 301
    memset((void *)(buf + (dquot->dq_dqb.u.v2_mdqb.dqb_off & (long )((1 << 10) - 1))),
           0, (size_t )info->dqi_entry_size);
#line 304
    tmp___1 = qtree_dqstr_in_blk(info);
    }
#line 304
    if ((int )dh->dqdh_entries == tmp___1 - 1) {
      {
#line 305
      insert_free_dqentry(h, buf, blk);
      }
    } else {
      {
#line 307
      write_blk(h, blk, buf);
      }
    }
  }
  {
#line 309
  dquot->dq_dqb.u.v2_mdqb.dqb_off = (loff_t )0;
#line 310
  free((void *)buf);
  }
#line 311
  return;
}
}
#line 314 "/home/wheatley/newnew/temp/quota-4.01/quotaio_tree.c"
static void remove_tree(struct quota_handle *h , struct dquot *dquot , uint *blk ,
                        int depth ) 
{ 
  dqbuf_t buf ;
  void *tmp ;
  uint newblk ;
  u_int32_t *ref ;
  int tmp___0 ;
  int i ;
  int tmp___1 ;

  {
  {
#line 316
  tmp = smalloc((size_t )(1 << 10));
#line 316
  buf = (dqbuf_t )tmp;
#line 318
  ref = (u_int32_t *)buf;
#line 320
  read_blk(h, *blk, buf);
#line 321
  tmp___0 = get_index(dquot->dq_id, depth);
#line 321
  newblk = *(ref + tmp___0);
  }
#line 322
  if (depth == 3) {
    {
#line 323
    free_dqentry(h, dquot, newblk);
#line 324
    newblk = (uint )0;
    }
  } else {
    {
#line 327
    remove_tree(h, dquot, & newblk, depth + 1);
    }
  }
#line 328
  if (! newblk) {
    {
#line 331
    tmp___1 = get_index(dquot->dq_id, depth);
#line 331
    *(ref + tmp___1) = (__u32 )0;
#line 332
    i = 0;
    }
    {
#line 332
    while (1) {
      while_continue: /* CIL Label */ ;
#line 332
      if (i < 1 << 10) {
#line 332
        if (! (! *(buf + i))) {
#line 332
          goto while_break;
        }
      } else {
#line 332
        goto while_break;
      }
#line 332
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 334
    if (i == 1 << 10) {
#line 334
      if (*blk != 1U) {
        {
#line 335
        put_free_dqblk(h, buf, *blk);
#line 336
        *blk = (uint )0;
        }
      } else {
        {
#line 339
        write_blk(h, *blk, buf);
        }
      }
    } else {
      {
#line 339
      write_blk(h, *blk, buf);
      }
    }
  }
  {
#line 341
  free((void *)buf);
  }
#line 342
  return;
}
}
#line 345 "/home/wheatley/newnew/temp/quota-4.01/quotaio_tree.c"
void qtree_delete_dquot(struct dquot *dquot ) 
{ 
  uint tmp ;

  {
#line 347
  tmp = (uint )1;
#line 349
  if (! dquot->dq_dqb.u.v2_mdqb.dqb_off) {
#line 350
    return;
  }
  {
#line 351
  remove_tree(dquot->dq_h, dquot, & tmp, 0);
  }
#line 352
  return;
}
}
#line 355 "/home/wheatley/newnew/temp/quota-4.01/quotaio_tree.c"
static loff_t find_block_dqentry(struct quota_handle *h , struct dquot *dquot , uint blk ) 
{ 
  struct qtree_mem_dqinfo *info ;
  dqbuf_t buf ;
  void *tmp ;
  int i ;
  char *ddquot ;
  int tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;

  {
  {
#line 357
  info = & h->qh_info.u.v2_mdqi.dqi_qtree;
#line 358
  tmp = smalloc((size_t )(1 << 10));
#line 358
  buf = (dqbuf_t )tmp;
#line 360
  ddquot = buf + sizeof(struct qt_disk_dqdbheader );
#line 362
  read_blk(h, blk, buf);
#line 363
  i = 0;
  }
  {
#line 363
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 363
    tmp___0 = qtree_dqstr_in_blk(info);
    }
#line 363
    if (i < tmp___0) {
      {
#line 363
      tmp___1 = (*((info->dqi_ops)->is_id))((void *)ddquot, dquot);
      }
#line 363
      if (tmp___1) {
#line 363
        goto while_break;
      }
    } else {
#line 363
      goto while_break;
    }
#line 363
    i ++;
#line 363
    ddquot += info->dqi_entry_size;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 366
  tmp___3 = qtree_dqstr_in_blk(info);
  }
#line 366
  if (i == tmp___3) {
    {
#line 367
    tmp___2 = gettext("Quota for id %u referenced but not present.\n");
#line 367
    die(2, tmp___2, dquot->dq_id);
    }
  }
  {
#line 368
  free((void *)buf);
  }
#line 369
  return ((loff_t )(((unsigned long )(blk << 10) + sizeof(struct qt_disk_dqdbheader )) + (unsigned long )((unsigned int )i * info->dqi_entry_size)));
}
}
#line 374 "/home/wheatley/newnew/temp/quota-4.01/quotaio_tree.c"
static loff_t find_tree_dqentry(struct quota_handle *h , struct dquot *dquot , uint blk ,
                                int depth ) 
{ 
  dqbuf_t buf ;
  void *tmp ;
  loff_t ret ;
  u_int32_t *ref ;
  int tmp___0 ;

  {
  {
#line 376
  tmp = smalloc((size_t )(1 << 10));
#line 376
  buf = (dqbuf_t )tmp;
#line 377
  ret = (loff_t )0;
#line 378
  ref = (u_int32_t *)buf;
#line 380
  read_blk(h, blk, buf);
#line 381
  ret = (loff_t )0;
#line 382
  tmp___0 = get_index(dquot->dq_id, depth);
#line 382
  blk = *(ref + tmp___0);
  }
#line 383
  if (! blk) {
#line 384
    goto out_buf;
  }
#line 385
  if (depth < 3) {
    {
#line 386
    ret = find_tree_dqentry(h, dquot, blk, depth + 1);
    }
  } else {
    {
#line 388
    ret = find_block_dqentry(h, dquot, blk);
    }
  }
  out_buf: 
  {
#line 390
  free((void *)buf);
  }
#line 391
  return (ret);
}
}
#line 395 "/home/wheatley/newnew/temp/quota-4.01/quotaio_tree.c"
__inline static loff_t find_dqentry(struct quota_handle *h , struct dquot *dquot ) 
{ 
  loff_t tmp ;

  {
  {
#line 397
  tmp = find_tree_dqentry(h, dquot, (uint )1, 0);
  }
#line 397
  return (tmp);
}
}
#line 404 "/home/wheatley/newnew/temp/quota-4.01/quotaio_tree.c"
struct dquot *qtree_read_dquot(struct quota_handle *h , qid_t id___0 ) 
{ 
  struct qtree_mem_dqinfo *info ;
  loff_t offset ;
  ssize_t ret ;
  char *ddquot ;
  void *tmp ;
  struct dquot *dquot ;
  struct dquot *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;

  {
  {
#line 406
  info = & h->qh_info.u.v2_mdqi.dqi_qtree;
#line 409
  tmp = smalloc((size_t )info->dqi_entry_size);
#line 409
  ddquot = (char *)tmp;
#line 410
  tmp___0 = get_empty_dquot();
#line 410
  dquot = tmp___0;
#line 412
  dquot->dq_id = id___0;
#line 413
  dquot->dq_h = h;
#line 414
  dquot->dq_dqb.u.v2_mdqb.dqb_off = (loff_t )0;
#line 415
  memset((void *)(& dquot->dq_dqb), 0, sizeof(struct util_dqblk ));
#line 417
  offset = find_dqentry(h, dquot);
  }
#line 418
  if (offset > 0L) {
    {
#line 419
    dquot->dq_dqb.u.v2_mdqb.dqb_off = offset;
#line 420
    lseek(h->qh_fd, offset, 0);
#line 421
    ret = read(h->qh_fd, (void *)ddquot, (size_t )info->dqi_entry_size);
    }
#line 422
    if (ret != (ssize_t )info->dqi_entry_size) {
#line 423
      if (ret > 0L) {
        {
#line 424
        tmp___1 = __errno_location();
#line 424
        *tmp___1 = 5;
        }
      }
      {
#line 425
      free((void *)ddquot);
#line 426
      tmp___2 = __errno_location();
#line 426
      tmp___3 = strerror(*tmp___2);
#line 426
      tmp___4 = gettext("Cannot read quota structure for id %u: %s\n");
#line 426
      die(2, tmp___4, dquot->dq_id, tmp___3);
      }
    }
    {
#line 429
    (*((info->dqi_ops)->disk2mem_dqblk))(dquot, (void *)ddquot);
    }
  }
  {
#line 431
  free((void *)ddquot);
  }
#line 432
  return (dquot);
}
}
#line 441 "/home/wheatley/newnew/temp/quota-4.01/quotaio_tree.c"
static int report_block(struct dquot *dquot , uint blk , char *bitmap , int (*process_dquot)(struct dquot * ,
                                                                                             char * ) ) 
{ 
  struct qtree_mem_dqinfo *info ;
  dqbuf_t buf ;
  void *tmp ;
  struct qt_disk_dqdbheader *dh ;
  char *ddata ;
  int entries ;
  int i ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 444
  info = & (dquot->dq_h)->qh_info.u.v2_mdqi.dqi_qtree;
#line 445
  tmp = smalloc((size_t )(1 << 10));
#line 445
  buf = (dqbuf_t )tmp;
#line 450
  *(bitmap + (blk >> 3)) = (char )((int )*(bitmap + (blk >> 3)) | (1 << (blk & 7U)));
#line 451
  read_blk(dquot->dq_h, blk, buf);
#line 452
  dh = (struct qt_disk_dqdbheader *)buf;
#line 453
  ddata = buf + sizeof(struct qt_disk_dqdbheader );
#line 454
  entries = (int )dh->dqdh_entries;
#line 455
  i = 0;
  }
  {
#line 455
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 455
    tmp___2 = qtree_dqstr_in_blk(info);
    }
#line 455
    if (! (i < tmp___2)) {
#line 455
      goto while_break;
    }
    {
#line 456
    tmp___1 = qtree_entry_unused(info, ddata);
    }
#line 456
    if (! tmp___1) {
      {
#line 457
      (*((info->dqi_ops)->disk2mem_dqblk))(dquot, (void *)ddata);
#line 458
      tmp___0 = (*process_dquot)(dquot, (char *)((void *)0));
      }
#line 458
      if (tmp___0 < 0) {
#line 459
        goto while_break;
      }
    }
#line 455
    i ++;
#line 455
    ddata += info->dqi_entry_size;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 461
  free((void *)buf);
  }
#line 462
  return (entries);
}
}
#line 465 "/home/wheatley/newnew/temp/quota-4.01/quotaio_tree.c"
static void check_reference(struct quota_handle *h , uint blk ) 
{ 
  char *tmp ;
  char *tmp___0 ;

  {
#line 467
  if (blk >= h->qh_info.u.v2_mdqi.dqi_qtree.dqi_blocks) {
    {
#line 468
    tmp = type2name(h->qh_type);
#line 468
    tmp___0 = gettext("Illegal reference (%u >= %u) in %s quota file on %s. Quota file is probably corrupted.\nPlease run quotacheck(8) and try again.\n");
#line 468
    die(2, tmp___0, blk, h->qh_info.u.v2_mdqi.dqi_qtree.dqi_blocks, tmp, h->qh_quotadev);
    }
  }
#line 469
  return;
}
}
#line 471 "/home/wheatley/newnew/temp/quota-4.01/quotaio_tree.c"
static int report_tree(struct dquot *dquot , uint blk , int depth , char *bitmap ,
                       int (*process_dquot)(struct dquot * , char * ) ) 
{ 
  int entries ;
  int i ;
  dqbuf_t buf ;
  void *tmp ;
  u_int32_t *ref ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 474
  entries = 0;
#line 475
  tmp = smalloc((size_t )(1 << 10));
#line 475
  buf = (dqbuf_t )tmp;
#line 476
  ref = (u_int32_t *)buf;
#line 478
  read_blk(dquot->dq_h, blk, buf);
  }
#line 479
  if (depth == 3) {
#line 480
    i = 0;
    {
#line 480
    while (1) {
      while_continue: /* CIL Label */ ;
#line 480
      if (! (i < (1 << 10) >> 2)) {
#line 480
        goto while_break;
      }
      {
#line 481
      blk = *(ref + i);
#line 482
      check_reference(dquot->dq_h, blk);
      }
#line 483
      if (blk) {
#line 483
        if (! ((int )*(bitmap + (blk >> 3)) & (1 << (blk & 7U)))) {
          {
#line 484
          tmp___0 = report_block(dquot, blk, bitmap, process_dquot);
#line 484
          entries += tmp___0;
          }
        }
      }
#line 480
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 488
    i = 0;
    {
#line 488
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 488
      if (! (i < (1 << 10) >> 2)) {
#line 488
        goto while_break___0;
      }
#line 489
      blk = *(ref + i);
#line 489
      if (blk) {
        {
#line 490
        check_reference(dquot->dq_h, blk);
#line 491
        tmp___1 = report_tree(dquot, blk, depth + 1, bitmap, process_dquot);
#line 491
        entries += tmp___1;
        }
      }
#line 488
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  {
#line 495
  free((void *)buf);
  }
#line 496
  return (entries);
}
}
#line 499 "/home/wheatley/newnew/temp/quota-4.01/quotaio_tree.c"
static uint find_set_bits(char *bmp , int blocks ) 
{ 
  uint i ;
  uint used ;

  {
#line 501
  used = (uint )0;
#line 503
  i = (uint )0;
  {
#line 503
  while (1) {
    while_continue: /* CIL Label */ ;
#line 503
    if (! (i < (uint )blocks)) {
#line 503
      goto while_break;
    }
#line 504
    if ((int )*(bmp + (i >> 3)) & (1 << (i & 7U))) {
#line 505
      used ++;
    }
#line 503
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 506
  return (used);
}
}
#line 509 "/home/wheatley/newnew/temp/quota-4.01/quotaio_tree.c"
int qtree_scan_dquots(struct quota_handle *h , int (*process_dquot)(struct dquot * ,
                                                                    char * ) ) 
{ 
  char *bitmap ;
  struct v2_mem_dqinfo *v2info ;
  struct qtree_mem_dqinfo *info ;
  struct dquot *dquot ;
  struct dquot *tmp ;
  void *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 512
  v2info = & h->qh_info.u.v2_mdqi;
#line 513
  info = & v2info->dqi_qtree;
#line 514
  tmp = get_empty_dquot();
#line 514
  dquot = tmp;
#line 516
  dquot->dq_h = h;
#line 517
  tmp___0 = smalloc((size_t )((info->dqi_blocks + 7U) >> 3));
#line 517
  bitmap = (char *)tmp___0;
#line 518
  memset((void *)bitmap, 0, (size_t )((info->dqi_blocks + 7U) >> 3));
#line 519
  tmp___1 = report_tree(dquot, (uint )1, 0, bitmap, process_dquot);
#line 519
  v2info->dqi_used_entries = (uint )tmp___1;
#line 520
  v2info->dqi_data_blocks = find_set_bits(bitmap, (int )info->dqi_blocks);
#line 521
  free((void *)bitmap);
#line 522
  free((void *)dquot);
  }
#line 523
  return (0);
}
}
#line 72 "/usr/include/pwd.h"
extern void setpwent(void) ;
#line 78
extern void endpwent(void) ;
#line 84
extern struct passwd *getpwent(void) ;
#line 62 "/usr/include/grp.h"
extern void setgrent(void) ;
#line 71
extern void endgrent(void) ;
#line 77
extern struct group *getgrent(void) ;
#line 23 "/home/wheatley/newnew/temp/quota-4.01/quotaio_generic.c"
__inline static void generic_kern2utildqblk(struct util_dqblk *u , struct if_dqblk *k ) 
{ 


  {
#line 25
  u->dqb_ihardlimit = (qsize_t )k->dqb_ihardlimit;
#line 26
  u->dqb_isoftlimit = (qsize_t )k->dqb_isoftlimit;
#line 27
  u->dqb_bhardlimit = (qsize_t )k->dqb_bhardlimit;
#line 28
  u->dqb_bsoftlimit = (qsize_t )k->dqb_bsoftlimit;
#line 29
  u->dqb_curinodes = (qsize_t )k->dqb_curinodes;
#line 30
  u->dqb_curspace = (qsize_t )k->dqb_curspace;
#line 31
  u->dqb_itime = (time_t )k->dqb_itime;
#line 32
  u->dqb_btime = (time_t )k->dqb_btime;
#line 33
  return;
}
}
#line 36 "/home/wheatley/newnew/temp/quota-4.01/quotaio_generic.c"
__inline static void generic_util2kerndqblk(struct if_dqblk *k , struct util_dqblk *u ) 
{ 


  {
#line 38
  k->dqb_ihardlimit = (u_int64_t )u->dqb_ihardlimit;
#line 39
  k->dqb_isoftlimit = (u_int64_t )u->dqb_isoftlimit;
#line 40
  k->dqb_bhardlimit = (u_int64_t )u->dqb_bhardlimit;
#line 41
  k->dqb_bsoftlimit = (u_int64_t )u->dqb_bsoftlimit;
#line 42
  k->dqb_curinodes = (u_int64_t )u->dqb_curinodes;
#line 43
  k->dqb_curspace = (u_int64_t )u->dqb_curspace;
#line 44
  k->dqb_itime = (u_int64_t )u->dqb_itime;
#line 45
  k->dqb_btime = (u_int64_t )u->dqb_btime;
#line 46
  return;
}
}
#line 49 "/home/wheatley/newnew/temp/quota-4.01/quotaio_generic.c"
int vfs_get_info(struct quota_handle *h ) 
{ 
  struct if_dqinfo kinfo ;
  int *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  long tmp___3 ;

  {
  {
#line 53
  tmp___3 = quotactl((8388613 << 8) | (h->qh_type & 255), (char const   *)(h->qh_quotadev),
                     (qid_t )0, (caddr_t )((void *)(& kinfo)));
  }
#line 53
  if (tmp___3 < 0L) {
    {
#line 54
    tmp = __errno_location();
#line 54
    tmp___0 = strerror(*tmp);
#line 54
    tmp___1 = type2name(h->qh_type);
#line 54
    tmp___2 = gettext("Cannot get info for %s quota file from kernel on %s: %s\n");
#line 54
    errstr(tmp___2, tmp___1, h->qh_quotadev, tmp___0);
    }
#line 55
    return (-1);
  }
#line 57
  h->qh_info.dqi_bgrace = (time_t )kinfo.dqi_bgrace;
#line 58
  h->qh_info.dqi_igrace = (time_t )kinfo.dqi_igrace;
#line 59
  return (0);
}
}
#line 63 "/home/wheatley/newnew/temp/quota-4.01/quotaio_generic.c"
int vfs_set_info(struct quota_handle *h , int flags___7 ) 
{ 
  struct if_dqinfo kinfo ;
  int *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  long tmp___3 ;

  {
  {
#line 67
  kinfo.dqi_bgrace = (u_int64_t )h->qh_info.dqi_bgrace;
#line 68
  kinfo.dqi_igrace = (u_int64_t )h->qh_info.dqi_igrace;
#line 69
  kinfo.dqi_valid = (u_int32_t )flags___7;
#line 71
  tmp___3 = quotactl((8388614 << 8) | (h->qh_type & 255), (char const   *)(h->qh_quotadev),
                     (qid_t )0, (caddr_t )((void *)(& kinfo)));
  }
#line 71
  if (tmp___3 < 0L) {
    {
#line 72
    tmp = __errno_location();
#line 72
    tmp___0 = strerror(*tmp);
#line 72
    tmp___1 = type2name(h->qh_type);
#line 72
    tmp___2 = gettext("Cannot set info for %s quota file from kernel on %s: %s\n");
#line 72
    errstr(tmp___2, tmp___1, h->qh_quotadev, tmp___0);
    }
#line 73
    return (-1);
  }
#line 75
  return (0);
}
}
#line 79 "/home/wheatley/newnew/temp/quota-4.01/quotaio_generic.c"
int vfs_get_dquot(struct dquot *dquot ) 
{ 
  struct if_dqblk kdqblk ;
  int *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  long tmp___3 ;

  {
  {
#line 83
  tmp___3 = quotactl((8388615 << 8) | ((dquot->dq_h)->qh_type & 255), (char const   *)((dquot->dq_h)->qh_quotadev),
                     dquot->dq_id, (caddr_t )((void *)(& kdqblk)));
  }
#line 83
  if (tmp___3 < 0L) {
    {
#line 84
    tmp = __errno_location();
#line 84
    tmp___0 = strerror(*tmp);
#line 84
    tmp___1 = type2name((dquot->dq_h)->qh_type);
#line 84
    tmp___2 = gettext("Cannot get quota for %s %d from kernel on %s: %s\n");
#line 84
    errstr(tmp___2, tmp___1, dquot->dq_id, (dquot->dq_h)->qh_quotadev, tmp___0);
    }
#line 85
    return (-1);
  }
  {
#line 87
  generic_kern2utildqblk(& dquot->dq_dqb, & kdqblk);
  }
#line 88
  return (0);
}
}
#line 92 "/home/wheatley/newnew/temp/quota-4.01/quotaio_generic.c"
int vfs_set_dquot(struct dquot *dquot , int flags___7 ) 
{ 
  struct if_dqblk kdqblk ;
  int *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  long tmp___3 ;

  {
  {
#line 96
  generic_util2kerndqblk(& kdqblk, & dquot->dq_dqb);
#line 97
  kdqblk.dqb_valid = (u_int32_t )flags___7;
#line 98
  tmp___3 = quotactl((8388616 << 8) | ((dquot->dq_h)->qh_type & 255), (char const   *)((dquot->dq_h)->qh_quotadev),
                     dquot->dq_id, (caddr_t )((void *)(& kdqblk)));
  }
#line 98
  if (tmp___3 < 0L) {
    {
#line 99
    tmp = __errno_location();
#line 99
    tmp___0 = strerror(*tmp);
#line 99
    tmp___1 = type2name((dquot->dq_h)->qh_type);
#line 99
    tmp___2 = gettext("Cannot set quota for %s %d from kernel on %s: %s\n");
#line 99
    errstr(tmp___2, tmp___1, dquot->dq_id, (dquot->dq_h)->qh_quotadev, tmp___0);
    }
#line 100
    return (-1);
  }
#line 102
  return (0);
}
}
#line 105 "/home/wheatley/newnew/temp/quota-4.01/quotaio_generic.c"
static int scan_one_dquot(struct dquot *dquot , int (*get_dquot)(struct dquot * ) ) 
{ 
  int ret ;
  struct util_dqblk *dqb ;

  {
  {
#line 108
  dqb = & dquot->dq_dqb;
#line 110
  memset((void *)dqb, 0, sizeof(struct util_dqblk ));
#line 111
  ret = (*get_dquot)(dquot);
  }
#line 112
  if (ret < 0) {
#line 113
    return (ret);
  }
#line 114
  if (! dqb->dqb_bhardlimit) {
#line 114
    if (! dqb->dqb_bsoftlimit) {
#line 114
      if (! dqb->dqb_ihardlimit) {
#line 114
        if (! dqb->dqb_isoftlimit) {
#line 114
          if (! dqb->dqb_curinodes) {
#line 114
            if (! dqb->dqb_curspace) {
#line 115
              return (1);
            }
          }
        }
      }
    }
  }
#line 116
  return (0);
}
}
#line 120 "/home/wheatley/newnew/temp/quota-4.01/quotaio_generic.c"
int generic_scan_dquots(struct quota_handle *h , int (*process_dquot)(struct dquot *dquot ,
                                                                      char *dqname ) ,
                        int (*get_dquot)(struct dquot *dquot ) ) 
{ 
  struct dquot *dquot ;
  struct dquot *tmp ;
  int ret ;
  struct passwd *usr ;
  struct group *grp ;

  {
  {
#line 124
  tmp = get_empty_dquot();
#line 124
  dquot = tmp;
#line 125
  ret = 0;
#line 127
  dquot->dq_h = h;
  }
#line 128
  if (h->qh_type == 0) {
    {
#line 131
    setpwent();
    }
    {
#line 132
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 132
      usr = getpwent();
      }
#line 132
      if (! ((unsigned long )usr != (unsigned long )((void *)0))) {
#line 132
        goto while_break;
      }
      {
#line 133
      dquot->dq_id = usr->pw_uid;
#line 134
      ret = scan_one_dquot(dquot, get_dquot);
      }
#line 135
      if (ret < 0) {
#line 136
        goto while_break;
      }
#line 137
      if (ret > 0) {
#line 138
        goto while_continue;
      }
      {
#line 139
      ret = (*process_dquot)(dquot, usr->pw_name);
      }
#line 140
      if (ret < 0) {
#line 141
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 143
    endpwent();
    }
  } else
#line 144
  if (h->qh_type == 1) {
    {
#line 147
    setgrent();
    }
    {
#line 148
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 148
      grp = getgrent();
      }
#line 148
      if (! ((unsigned long )grp != (unsigned long )((void *)0))) {
#line 148
        goto while_break___0;
      }
      {
#line 149
      dquot->dq_id = grp->gr_gid;
#line 150
      ret = scan_one_dquot(dquot, get_dquot);
      }
#line 151
      if (ret < 0) {
#line 152
        goto while_break___0;
      }
#line 153
      if (ret > 0) {
#line 154
        goto while_continue___0;
      }
      {
#line 155
      ret = (*process_dquot)(dquot, grp->gr_name);
      }
#line 156
      if (ret < 0) {
#line 157
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 159
    endgrent();
    }
  }
  {
#line 161
  free((void *)dquot);
  }
#line 162
  return (ret);
}
}
#line 18 "/home/wheatley/newnew/temp/quota-4.01/quotaio_rpc.c"
static int rpc_init_io(struct quota_handle *h ) ;
#line 19
static struct dquot *rpc_read_dquot(struct quota_handle *h , qid_t id___0 ) ;
#line 20
static int rpc_commit_dquot(struct dquot *dquot , int flags___7 ) ;
#line 22 "/home/wheatley/newnew/temp/quota-4.01/quotaio_rpc.c"
struct quotafile_ops quotafile_ops_rpc  = 
#line 22
     {(int (*)(int fd , int type , int fmt ))0, & rpc_init_io, (int (*)(struct quota_handle *h ))0,
    (int (*)(struct quota_handle *h ))0, (int (*)(struct quota_handle *h ))0, & rpc_read_dquot,
    & rpc_commit_dquot, (int (*)(struct quota_handle *h , int (*process_dquot)(struct dquot *dquot ,
                                                                               char *dqname ) ))0,
    (int (*)(struct quota_handle *h , int verbose ))0};
#line 31 "/home/wheatley/newnew/temp/quota-4.01/quotaio_rpc.c"
static int rpc_init_io(struct quota_handle *h ) 
{ 


  {
#line 34
  h->qh_info.dqi_max_b_limit = (uint64_t )(~ ((uint32_t )0));
#line 35
  h->qh_info.dqi_max_i_limit = (uint64_t )(~ ((uint32_t )0));
#line 36
  h->qh_info.dqi_max_b_usage = (uint64_t )(4294967295U << 10);
#line 37
  h->qh_info.dqi_max_i_usage = (uint64_t )(~ ((uint32_t )0));
#line 38
  return (0);
}
}
#line 47 "/home/wheatley/newnew/temp/quota-4.01/quotaio_rpc.c"
static struct dquot *rpc_read_dquot(struct quota_handle *h , qid_t id___0 ) 
{ 
  struct dquot *dquot ;
  struct dquot *tmp ;
  int ret ;
  int *tmp___0 ;

  {
  {
#line 50
  tmp = get_empty_dquot();
#line 50
  dquot = tmp;
#line 53
  dquot->dq_id = id___0;
#line 54
  dquot->dq_h = h;
#line 55
  ret = rpc_rquota_get(dquot);
  }
#line 55
  if (ret < 0) {
    {
#line 56
    tmp___0 = __errno_location();
#line 56
    *tmp___0 = - ret;
#line 57
    free((void *)dquot);
    }
#line 58
    return ((struct dquot *)((void *)0));
  }
#line 60
  return (dquot);
}
}
#line 70 "/home/wheatley/newnew/temp/quota-4.01/quotaio_rpc.c"
static int rpc_commit_dquot(struct dquot *dquot , int flags___7 ) 
{ 
  int ret ;
  char *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;

  {
#line 75
  if ((dquot->dq_h)->qh_io_flags & 4) {
    {
#line 76
    tmp = gettext("Trying to write quota to readonly quotafile on %s\n");
#line 76
    errstr(tmp, (dquot->dq_h)->qh_quotadev);
#line 77
    tmp___0 = __errno_location();
#line 77
    *tmp___0 = 1;
    }
#line 78
    return (-1);
  }
  {
#line 80
  ret = rpc_rquota_set((1024 << 8) | ((dquot->dq_h)->qh_type & 255), dquot);
  }
#line 80
  if (ret < 0) {
    {
#line 81
    tmp___1 = __errno_location();
#line 81
    *tmp___1 = - ret;
    }
#line 82
    return (-1);
  }
#line 84
  return (0);
}
}
#line 41 "/usr/include/x86_64-linux-gnu/sys/ioctl.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ioctl)(int __fd ,
                                                                            unsigned long __request 
                                                                            , ...) ;
#line 580 "/usr/include/stdio.h"
extern int putchar(int __c ) ;
#line 765 "/usr/include/stdlib.h"
extern void ( __attribute__((__nonnull__(1,4))) qsort)(void *__base , size_t __nmemb ,
                                                       size_t __size , int (*__compar)(void const   * ,
                                                                                       void const   * ) ) ;
#line 71 "/usr/include/getopt.h"
extern int optind ;
#line 150
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getopt)(int ___argc ,
                                                                             char * const  *___argv ,
                                                                             char const   *__shortopts ) ;
#line 972 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) sync)(void) ;
#line 54 "/home/wheatley/newnew/temp/quota-4.01/quot.h"
static du_t du[2][60000]  ;
#line 55 "/home/wheatley/newnew/temp/quota-4.01/quot.h"
static du_t *duhash[2][8209]  ;
#line 56 "/home/wheatley/newnew/temp/quota-4.01/quot.h"
static int ndu[2]  ;
#line 109
static void checkXFS(char const   *file , char const   *fsdir ) ;
#line 59 "/home/wheatley/newnew/temp/quota-4.01/quot.c"
static __uint64_t sizes[500]  ;
#line 60 "/home/wheatley/newnew/temp/quota-4.01/quot.c"
static __uint64_t overflow  ;
#line 62 "/home/wheatley/newnew/temp/quota-4.01/quot.c"
static int aflag  ;
#line 63 "/home/wheatley/newnew/temp/quota-4.01/quot.c"
static int cflag  ;
#line 64 "/home/wheatley/newnew/temp/quota-4.01/quot.c"
static int fflag  ;
#line 65 "/home/wheatley/newnew/temp/quota-4.01/quot.c"
static int gflag  ;
#line 66 "/home/wheatley/newnew/temp/quota-4.01/quot.c"
static int uflag  ;
#line 67 "/home/wheatley/newnew/temp/quota-4.01/quot.c"
static int vflag  ;
#line 68 "/home/wheatley/newnew/temp/quota-4.01/quot.c"
static int iflag  ;
#line 69 "/home/wheatley/newnew/temp/quota-4.01/quot.c"
static int qflag  ;
#line 70 "/home/wheatley/newnew/temp/quota-4.01/quot.c"
static int Tflag  ;
#line 71 "/home/wheatley/newnew/temp/quota-4.01/quot.c"
static time_t now  ;
#line 74
static void mounttable(void) ;
#line 75
static char *idname(__uint32_t id___0 , int type ) ;
#line 76
static void report(char const   *file , char const   *fsdir , int type ) ;
#line 77
static void creport(char const   *file , char const   *fsdir ) ;
#line 79 "/home/wheatley/newnew/temp/quota-4.01/quot.c"
static void usage(void) 
{ 
  char *tmp ;

  {
  {
#line 81
  tmp = gettext("Usage: %s [-acfugvViTq] [filesystem...]\n");
#line 81
  errstr(tmp, progname);
#line 82
  exit(1);
  }
}
}
#line 139 "/home/wheatley/newnew/temp/quota-4.01/quot.c"
static void mounttable(void) 
{ 
  int doit ;
  struct mount_entry *mntp ;
  int tmp ;

  {
#line 141
  doit = 0;
  {
#line 144
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 144
    mntp = get_next_mount();
    }
#line 144
    if (! mntp) {
#line 144
      goto while_break;
    }
    {
#line 146
    tmp = strcmp((char const   *)mntp->me_type, "xfs");
    }
#line 146
    if (tmp == 0) {
      {
#line 147
      checkXFS(mntp->me_devname, mntp->me_dir);
#line 148
      doit = 1;
      }
    }
#line 152
    if (doit) {
#line 153
      if (cflag) {
        {
#line 153
        creport(mntp->me_devname, mntp->me_dir);
        }
      }
#line 154
      if (! cflag) {
#line 154
        if (uflag) {
          {
#line 154
          report(mntp->me_devname, mntp->me_dir, 0);
          }
        }
      }
#line 155
      if (! cflag) {
#line 155
        if (gflag) {
          {
#line 155
          report(mntp->me_devname, mntp->me_dir, 1);
          }
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 158
  return;
}
}
#line 160 "/home/wheatley/newnew/temp/quota-4.01/quot.c"
static int qcmp(du_t *p1 , du_t *p2 ) 
{ 


  {
#line 162
  if (p1->blocks > p2->blocks) {
#line 163
    return (-1);
  }
#line 164
  if (p1->blocks < p2->blocks) {
#line 165
    return (1);
  }
#line 166
  if (p1->id > p2->id) {
#line 167
    return (1);
  } else
#line 168
  if (p1->id < p2->id) {
#line 169
    return (-1);
  }
#line 170
  return (0);
}
}
#line 173 "/home/wheatley/newnew/temp/quota-4.01/quot.c"
static void creport(char const   *file , char const   *fsdir ) 
{ 
  int i ;
  __uint64_t t ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 176
  t = (__uint64_t )0;
#line 178
  tmp = gettext("%s (%s):\n");
#line 178
  printf((char const   */* __restrict  */)tmp, file, fsdir);
#line 179
  i = 0;
  }
  {
#line 179
  while (1) {
    while_continue: /* CIL Label */ ;
#line 179
    if (! (i < 499)) {
#line 179
      goto while_break;
    }
#line 180
    if (sizes[i] > 0UL) {
      {
#line 181
      t += sizes[i] * (__uint64_t )i;
#line 182
      tmp___0 = gettext("%d\t%llu\t%llu\n");
#line 182
      printf((char const   */* __restrict  */)tmp___0, i, (unsigned long long )sizes[i],
             (unsigned long long )t);
      }
    }
#line 179
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 186
  tmp___1 = gettext("%d\t%llu\t%llu\n");
#line 186
  printf((char const   */* __restrict  */)tmp___1, 499, (unsigned long long )sizes[499],
         (unsigned long long )(overflow + t));
  }
#line 189
  return;
}
}
#line 191 "/home/wheatley/newnew/temp/quota-4.01/quot.c"
static void report(char const   *file , char const   *fsdir , int type ) 
{ 
  du_t *dp ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *cp ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;

  {
  {
#line 195
  tmp = type2name(type);
#line 195
  tmp___0 = gettext((char const   *)tmp);
#line 195
  tmp___1 = gettext("%s (%s) %ss:\n");
#line 195
  printf((char const   */* __restrict  */)tmp___1, file, fsdir, tmp___0);
  }
#line 196
  if (! qflag) {
    {
#line 197
    qsort((void *)(du[type]), (size_t )ndu[type], sizeof(du[type][0]), (int (*)(void const   * ,
                                                                                void const   * ))(& qcmp));
    }
  }
#line 198
  dp = du[type];
  {
#line 198
  while (1) {
    while_continue: /* CIL Label */ ;
#line 198
    if (! ((unsigned long )dp < (unsigned long )(& du[type][ndu[type]]))) {
#line 198
      goto while_break;
    }
#line 201
    if (dp->blocks == 0UL) {
#line 202
      return;
    }
    {
#line 203
    tmp___2 = gettext("%8llu    ");
#line 203
    printf((char const   */* __restrict  */)tmp___2, (unsigned long long )dp->blocks);
    }
#line 204
    if (fflag) {
      {
#line 205
      tmp___3 = gettext("%8llu    ");
#line 205
      printf((char const   */* __restrict  */)tmp___3, (unsigned long long )dp->nfiles);
      }
    }
    {
#line 206
    cp = idname(dp->id, type);
    }
#line 206
    if ((unsigned long )cp != (unsigned long )((void *)0)) {
#line 207
      if (Tflag) {
        {
#line 208
        tmp___4 = gettext("%s");
#line 208
        printf((char const   */* __restrict  */)tmp___4, cp);
        }
      } else {
        {
#line 210
        tmp___5 = gettext("%-8.8s");
#line 210
        printf((char const   */* __restrict  */)tmp___5, cp);
        }
      }
    } else {
      {
#line 212
      tmp___6 = gettext("#%-7d");
#line 212
      printf((char const   */* __restrict  */)tmp___6, dp->id);
      }
    }
#line 213
    if (vflag) {
      {
#line 214
      tmp___7 = gettext("    %8llu    %8llu    %8llu");
#line 214
      printf((char const   */* __restrict  */)tmp___7, (unsigned long long )dp->blocks30,
             (unsigned long long )dp->blocks60, (unsigned long long )dp->blocks90);
      }
    }
    {
#line 218
    putchar('\n');
#line 198
    dp ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 220
  return;
}
}
#line 226 "/home/wheatley/newnew/temp/quota-4.01/quot.c"
static idcache_t idc  ;
#line 222 "/home/wheatley/newnew/temp/quota-4.01/quot.c"
static idcache_t *getnextent(int type , __uint32_t id___0 , int byid ) 
{ 
  struct passwd *pw ;
  struct group *gr ;
  struct group *tmp ;
  struct group *tmp___0 ;
  struct passwd *tmp___1 ;
  struct passwd *tmp___2 ;

  {
#line 228
  if (type) {
#line 229
    if (byid) {
      {
#line 229
      tmp = getgrgid(id___0);
#line 229
      gr = tmp;
      }
    } else {
      {
#line 229
      tmp___0 = getgrent();
#line 229
      gr = tmp___0;
      }
    }
#line 229
    if ((unsigned long )gr == (unsigned long )((void *)0)) {
#line 230
      return ((idcache_t *)((void *)0));
    }
    {
#line 231
    idc.id = gr->gr_gid;
#line 232
    strncpy((char */* __restrict  */)(idc.name), (char const   */* __restrict  */)gr->gr_name,
            (size_t )32);
    }
#line 233
    return (& idc);
  }
#line 236
  if (byid) {
    {
#line 236
    tmp___1 = getpwuid(id___0);
#line 236
    pw = tmp___1;
    }
  } else {
    {
#line 236
    tmp___2 = getpwent();
#line 236
    pw = tmp___2;
    }
  }
#line 236
  if ((unsigned long )pw == (unsigned long )((void *)0)) {
#line 237
    return ((idcache_t *)((void *)0));
  }
  {
#line 238
  idc.id = pw->pw_uid;
#line 239
  strncpy((char */* __restrict  */)(idc.name), (char const   */* __restrict  */)pw->pw_name,
          (size_t )32);
  }
#line 240
  return (& idc);
}
}
#line 246 "/home/wheatley/newnew/temp/quota-4.01/quot.c"
static idcache_t nc[2][256]  ;
#line 247 "/home/wheatley/newnew/temp/quota-4.01/quot.c"
static int entriesleft[2]  = {      256,      256};
#line 243 "/home/wheatley/newnew/temp/quota-4.01/quot.c"
static char *idname(__uint32_t id___0 , int type ) 
{ 
  idcache_t *ncp ;
  idcache_t *idp ;

  {
#line 250
  ncp = & nc[type][id___0 & 255U];
#line 251
  if (ncp->id == id___0) {
#line 251
    if (ncp->name[0]) {
#line 252
      return (ncp->name);
    }
  }
#line 253
  if (entriesleft[type]) {
#line 259
    if (entriesleft[type] == 256) {
#line 260
      if (type) {
        {
#line 260
        setgrent();
        }
      } else {
        {
#line 260
        setpwent();
        }
      }
    }
    {
#line 261
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 261
      idp = getnextent(type, id___0, 0);
      }
#line 261
      if ((unsigned long )idp != (unsigned long )((void *)0)) {
#line 261
        if (! entriesleft[type]) {
#line 261
          goto while_break;
        }
      } else {
#line 261
        goto while_break;
      }
#line 262
      (entriesleft[type]) --;
#line 263
      ncp = & nc[type][idp->id & 255U];
#line 264
      if ((int )ncp->name[0] == 0) {
        {
#line 265
        memcpy((void */* __restrict  */)ncp, (void const   */* __restrict  */)idp,
               sizeof(idcache_t ));
        }
      } else
#line 264
      if (idp->id == id___0) {
        {
#line 265
        memcpy((void */* __restrict  */)ncp, (void const   */* __restrict  */)idp,
               sizeof(idcache_t ));
        }
      }
#line 266
      if (idp->id == id___0) {
#line 267
        return (ncp->name);
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 269
    if (type) {
      {
#line 269
      endgrent();
      }
    } else {
      {
#line 269
      endpwent();
      }
    }
#line 270
    entriesleft[type] = 0;
#line 271
    ncp = & nc[type][id___0 & 255U];
  }
  {
#line 275
  idp = getnextent(type, id___0, 1);
  }
#line 275
  if ((unsigned long )idp == (unsigned long )((void *)0)) {
#line 276
    return ((char *)((void *)0));
  }
  {
#line 277
  memcpy((void */* __restrict  */)ncp, (void const   */* __restrict  */)idp, sizeof(idcache_t ));
  }
#line 278
  return (ncp->name);
}
}
#line 285 "/home/wheatley/newnew/temp/quota-4.01/quot.c"
static void acctXFS(xfs_bstat_t *p ) 
{ 
  register du_t *dp ;
  du_t **hp ;
  __uint64_t size ;
  __uint32_t i ;
  __uint32_t id___0 ;
  int tmp ;

  {
#line 292
  if (((int )p->bs_mode & 61440) == 0) {
#line 293
    return;
  }
#line 294
  size = (__uint64_t )(((unsigned long long )(p->bs_blocks * (int64_t )p->bs_blksize) + 1023ULL) / 1024ULL);
#line 296
  if (cflag) {
#line 297
    if (! (((int )p->bs_mode & 61440) == 16384)) {
#line 297
      if (! (((int )p->bs_mode & 61440) == 32768)) {
#line 298
        return;
      }
    }
#line 299
    if (size >= 500UL) {
#line 300
      overflow += size;
#line 301
      size = (__uint64_t )499;
    }
#line 303
    (sizes[(int )size]) ++;
#line 304
    return;
  }
#line 306
  i = (__uint32_t )0;
  {
#line 306
  while (1) {
    while_continue: /* CIL Label */ ;
#line 306
    if (! (i < 2U)) {
#line 306
      goto while_break;
    }
#line 307
    if (i == 0U) {
#line 307
      id___0 = p->bs_uid;
    } else {
#line 307
      id___0 = p->bs_gid;
    }
#line 308
    hp = & duhash[i][id___0 % 8209U];
#line 309
    dp = *hp;
    {
#line 309
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 309
      if (! dp) {
#line 309
        goto while_break___0;
      }
#line 310
      if (dp->id == id___0) {
#line 311
        goto while_break___0;
      }
#line 309
      dp = dp->next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 312
    if ((unsigned long )dp == (unsigned long )((du_t *)0)) {
#line 313
      if (ndu[i] >= 60000) {
#line 314
        return;
      }
#line 315
      tmp = ndu[i];
#line 315
      (ndu[i]) ++;
#line 315
      dp = & du[i][tmp];
#line 316
      dp->next = *hp;
#line 317
      *hp = dp;
#line 318
      dp->id = id___0;
#line 319
      dp->nfiles = (__uint64_t )0;
#line 320
      dp->blocks = (__uint64_t )0;
#line 321
      dp->blocks30 = (__uint64_t )0;
#line 322
      dp->blocks60 = (__uint64_t )0;
#line 323
      dp->blocks90 = (__uint64_t )0;
    }
#line 325
    dp->blocks += size;
#line 327
    if (now - p->bs_atime.tv_sec > 2592000L) {
#line 328
      dp->blocks30 += size;
    }
#line 329
    if (now - p->bs_atime.tv_sec > 5184000L) {
#line 330
      dp->blocks60 += size;
    }
#line 331
    if (now - p->bs_atime.tv_sec > 7776000L) {
#line 332
      dp->blocks90 += size;
    }
#line 333
    (dp->nfiles) ++;
#line 306
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 335
  return;
}
}
#line 337 "/home/wheatley/newnew/temp/quota-4.01/quot.c"
static void checkXFS(char const   *file , char const   *fsdir ) 
{ 
  xfs_fsop_bulkreq_t bulkreq ;
  __u64 last ;
  __s32 count ;
  int i ;
  int sts ;
  int fsfd ;
  du_t **dp ;
  xfs_bstat_t *buf ;
  int *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  void *tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;

  {
#line 340
  last = (__u64 )0;
#line 352
  sts = 0;
  {
#line 352
  while (1) {
    while_continue: /* CIL Label */ ;
#line 352
    if (! (sts < 500)) {
#line 352
      goto while_break;
    }
#line 353
    sizes[sts] = (__uint64_t )0;
#line 352
    sts ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 354
  overflow = (__uint64_t )0;
#line 355
  i = 0;
  {
#line 355
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 355
    if (! (i < 2)) {
#line 355
      goto while_break___0;
    }
#line 356
    dp = duhash[i];
    {
#line 356
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 356
      if (! ((unsigned long )dp < (unsigned long )(& duhash[i][8209]))) {
#line 356
        goto while_break___1;
      }
#line 357
      *dp = (du_t *)0;
#line 356
      dp ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 355
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 358
  ndu[1] = 0;
#line 358
  ndu[0] = ndu[1];
#line 360
  fsfd = open(fsdir, 0);
  }
#line 361
  if (fsfd < 0) {
    {
#line 362
    tmp = __errno_location();
#line 362
    tmp___0 = strerror(*tmp);
#line 362
    tmp___1 = gettext("cannot open %s: %s\n");
#line 362
    errstr(tmp___1, fsdir, tmp___0);
#line 363
    exit(1);
    }
  }
  {
#line 365
  sync();
#line 367
  tmp___2 = smalloc(4069UL * sizeof(xfs_bstat_t ));
#line 367
  buf = (xfs_bstat_t *)tmp___2;
#line 368
  memset((void *)buf, 0, 4069UL * sizeof(xfs_bstat_t ));
#line 370
  bulkreq.lastip = & last;
#line 371
  bulkreq.icount = 4069;
#line 372
  bulkreq.ubuffer = (void *)buf;
#line 373
  bulkreq.ocount = & count;
  }
  {
#line 375
  while (1) {
    while_continue___2: /* CIL Label */ ;
    {
#line 375
    sts = ioctl(fsfd, (unsigned long )(((3U << 30) | (unsigned int )(88 << 8)) | 101U) | (sizeof(struct xfs_fsop_bulkreq ) << 16),
                & bulkreq);
    }
#line 375
    if (! (sts == 0)) {
#line 375
      goto while_break___2;
    }
#line 376
    if (count == 0) {
#line 377
      goto while_break___2;
    }
#line 378
    i = 0;
    {
#line 378
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 378
      if (! (i < count)) {
#line 378
        goto while_break___3;
      }
      {
#line 379
      acctXFS(buf + i);
#line 378
      i ++;
      }
    }
    while_break___3: /* CIL Label */ ;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 381
  if (sts < 0) {
    {
#line 382
    tmp___3 = __errno_location();
#line 382
    tmp___4 = strerror(*tmp___3);
#line 382
    tmp___5 = gettext("XFS_IOC_FSBULKSTAT ioctl failed: %s\n");
#line 382
    errstr(tmp___5, tmp___4);
#line 384
    exit(1);
    }
  }
  {
#line 386
  free((void *)buf);
#line 387
  close(fsfd);
  }
#line 388
  return;
}
}
#line 105 "/home/wheatley/newnew/temp/quota-4.01/rquota.h"
getquota_rslt *rquotaproc_getactivequota_1(getquota_args *argp , CLIENT *clnt ) ;
#line 108
setquota_rslt *rquotaproc_setquota_1(setquota_args *argp , CLIENT *clnt ) ;
#line 111
setquota_rslt *rquotaproc_setactivequota_1(setquota_args *argp , CLIENT *clnt ) ;
#line 135
getquota_rslt *rquotaproc_getactivequota_2(ext_getquota_args *argp , CLIENT *clnt ) ;
#line 137
setquota_rslt *rquotaproc_setquota_2(ext_setquota_args *argp , CLIENT *clnt ) ;
#line 139
setquota_rslt *rquotaproc_setactivequota_2(ext_setquota_args *argp , CLIENT *clnt ) ;
#line 10 "/home/wheatley/newnew/temp/quota-4.01/rquota_clnt.c"
static struct timeval TIMEOUT  =    {(__time_t )25, (__suseconds_t )0};
#line 15 "/home/wheatley/newnew/temp/quota-4.01/rquota_clnt.c"
static getquota_rslt clnt_res  ;
#line 12 "/home/wheatley/newnew/temp/quota-4.01/rquota_clnt.c"
getquota_rslt *rquotaproc_getquota_1(getquota_args *argp , CLIENT *clnt ) 
{ 
  enum clnt_stat tmp ;

  {
  {
#line 17
  memset((void *)((char *)(& clnt_res)), 0, sizeof(clnt_res));
#line 18
  tmp = (*((clnt->cl_ops)->cl_call))(clnt, (u_long )1, (bool_t (*)(XDR * , void * 
                                                                   , ...))(& xdr_getquota_args),
                                     (caddr_t )argp, (bool_t (*)(XDR * , void *  , ...))(& xdr_getquota_rslt),
                                     (caddr_t )(& clnt_res), TIMEOUT);
  }
#line 18
  if ((unsigned int )tmp != 0U) {
#line 22
    return ((getquota_rslt *)((void *)0));
  }
#line 24
  return (& clnt_res);
}
}
#line 30 "/home/wheatley/newnew/temp/quota-4.01/rquota_clnt.c"
static getquota_rslt clnt_res___0  ;
#line 27 "/home/wheatley/newnew/temp/quota-4.01/rquota_clnt.c"
getquota_rslt *rquotaproc_getactivequota_1(getquota_args *argp , CLIENT *clnt ) 
{ 
  enum clnt_stat tmp ;

  {
  {
#line 32
  memset((void *)((char *)(& clnt_res___0)), 0, sizeof(clnt_res___0));
#line 33
  tmp = (*((clnt->cl_ops)->cl_call))(clnt, (u_long )2, (bool_t (*)(XDR * , void * 
                                                                   , ...))(& xdr_getquota_args),
                                     (caddr_t )argp, (bool_t (*)(XDR * , void *  , ...))(& xdr_getquota_rslt),
                                     (caddr_t )(& clnt_res___0), TIMEOUT);
  }
#line 33
  if ((unsigned int )tmp != 0U) {
#line 37
    return ((getquota_rslt *)((void *)0));
  }
#line 39
  return (& clnt_res___0);
}
}
#line 45 "/home/wheatley/newnew/temp/quota-4.01/rquota_clnt.c"
static setquota_rslt clnt_res___1  ;
#line 42 "/home/wheatley/newnew/temp/quota-4.01/rquota_clnt.c"
setquota_rslt *rquotaproc_setquota_1(setquota_args *argp , CLIENT *clnt ) 
{ 
  enum clnt_stat tmp ;

  {
  {
#line 47
  memset((void *)((char *)(& clnt_res___1)), 0, sizeof(clnt_res___1));
#line 48
  tmp = (*((clnt->cl_ops)->cl_call))(clnt, (u_long )3, (bool_t (*)(XDR * , void * 
                                                                   , ...))(& xdr_setquota_args),
                                     (caddr_t )argp, (bool_t (*)(XDR * , void *  , ...))(& xdr_setquota_rslt),
                                     (caddr_t )(& clnt_res___1), TIMEOUT);
  }
#line 48
  if ((unsigned int )tmp != 0U) {
#line 52
    return ((setquota_rslt *)((void *)0));
  }
#line 54
  return (& clnt_res___1);
}
}
#line 60 "/home/wheatley/newnew/temp/quota-4.01/rquota_clnt.c"
static setquota_rslt clnt_res___2  ;
#line 57 "/home/wheatley/newnew/temp/quota-4.01/rquota_clnt.c"
setquota_rslt *rquotaproc_setactivequota_1(setquota_args *argp , CLIENT *clnt ) 
{ 
  enum clnt_stat tmp ;

  {
  {
#line 62
  memset((void *)((char *)(& clnt_res___2)), 0, sizeof(clnt_res___2));
#line 63
  tmp = (*((clnt->cl_ops)->cl_call))(clnt, (u_long )4, (bool_t (*)(XDR * , void * 
                                                                   , ...))(& xdr_setquota_args),
                                     (caddr_t )argp, (bool_t (*)(XDR * , void *  , ...))(& xdr_setquota_rslt),
                                     (caddr_t )(& clnt_res___2), TIMEOUT);
  }
#line 63
  if ((unsigned int )tmp != 0U) {
#line 67
    return ((setquota_rslt *)((void *)0));
  }
#line 69
  return (& clnt_res___2);
}
}
#line 75 "/home/wheatley/newnew/temp/quota-4.01/rquota_clnt.c"
static getquota_rslt clnt_res___3  ;
#line 72 "/home/wheatley/newnew/temp/quota-4.01/rquota_clnt.c"
getquota_rslt *rquotaproc_getquota_2(ext_getquota_args *argp , CLIENT *clnt ) 
{ 
  enum clnt_stat tmp ;

  {
  {
#line 77
  memset((void *)((char *)(& clnt_res___3)), 0, sizeof(clnt_res___3));
#line 78
  tmp = (*((clnt->cl_ops)->cl_call))(clnt, (u_long )1, (bool_t (*)(XDR * , void * 
                                                                   , ...))(& xdr_ext_getquota_args),
                                     (caddr_t )argp, (bool_t (*)(XDR * , void *  , ...))(& xdr_getquota_rslt),
                                     (caddr_t )(& clnt_res___3), TIMEOUT);
  }
#line 78
  if ((unsigned int )tmp != 0U) {
#line 82
    return ((getquota_rslt *)((void *)0));
  }
#line 84
  return (& clnt_res___3);
}
}
#line 90 "/home/wheatley/newnew/temp/quota-4.01/rquota_clnt.c"
static getquota_rslt clnt_res___4  ;
#line 87 "/home/wheatley/newnew/temp/quota-4.01/rquota_clnt.c"
getquota_rslt *rquotaproc_getactivequota_2(ext_getquota_args *argp , CLIENT *clnt ) 
{ 
  enum clnt_stat tmp ;

  {
  {
#line 92
  memset((void *)((char *)(& clnt_res___4)), 0, sizeof(clnt_res___4));
#line 93
  tmp = (*((clnt->cl_ops)->cl_call))(clnt, (u_long )2, (bool_t (*)(XDR * , void * 
                                                                   , ...))(& xdr_ext_getquota_args),
                                     (caddr_t )argp, (bool_t (*)(XDR * , void *  , ...))(& xdr_getquota_rslt),
                                     (caddr_t )(& clnt_res___4), TIMEOUT);
  }
#line 93
  if ((unsigned int )tmp != 0U) {
#line 97
    return ((getquota_rslt *)((void *)0));
  }
#line 99
  return (& clnt_res___4);
}
}
#line 105 "/home/wheatley/newnew/temp/quota-4.01/rquota_clnt.c"
static setquota_rslt clnt_res___5  ;
#line 102 "/home/wheatley/newnew/temp/quota-4.01/rquota_clnt.c"
setquota_rslt *rquotaproc_setquota_2(ext_setquota_args *argp , CLIENT *clnt ) 
{ 
  enum clnt_stat tmp ;

  {
  {
#line 107
  memset((void *)((char *)(& clnt_res___5)), 0, sizeof(clnt_res___5));
#line 108
  tmp = (*((clnt->cl_ops)->cl_call))(clnt, (u_long )3, (bool_t (*)(XDR * , void * 
                                                                   , ...))(& xdr_ext_setquota_args),
                                     (caddr_t )argp, (bool_t (*)(XDR * , void *  , ...))(& xdr_setquota_rslt),
                                     (caddr_t )(& clnt_res___5), TIMEOUT);
  }
#line 108
  if ((unsigned int )tmp != 0U) {
#line 112
    return ((setquota_rslt *)((void *)0));
  }
#line 114
  return (& clnt_res___5);
}
}
#line 120 "/home/wheatley/newnew/temp/quota-4.01/rquota_clnt.c"
static setquota_rslt clnt_res___6  ;
#line 117 "/home/wheatley/newnew/temp/quota-4.01/rquota_clnt.c"
setquota_rslt *rquotaproc_setactivequota_2(ext_setquota_args *argp , CLIENT *clnt ) 
{ 
  enum clnt_stat tmp ;

  {
  {
#line 122
  memset((void *)((char *)(& clnt_res___6)), 0, sizeof(clnt_res___6));
#line 123
  tmp = (*((clnt->cl_ops)->cl_call))(clnt, (u_long )4, (bool_t (*)(XDR * , void * 
                                                                   , ...))(& xdr_ext_setquota_args),
                                     (caddr_t )argp, (bool_t (*)(XDR * , void *  , ...))(& xdr_setquota_rslt),
                                     (caddr_t )(& clnt_res___6), TIMEOUT);
  }
#line 123
  if ((unsigned int )tmp != 0U) {
#line 127
    return ((setquota_rslt *)((void *)0));
  }
#line 129
  return (& clnt_res___6);
}
}
#line 7 "/usr/include/x86_64-linux-gnu/asm/swab.h"
__inline static __u32 __arch_swab32(__u32 val ) 
{ 


  {
#line 9
  __asm__  ("bswapl %0": "=r" (val): "0" (val));
#line 10
  return (val);
}
}
#line 57 "/usr/include/linux/swab.h"
__inline static __u32 __fswab32(__u32 val ) 
{ 
  __u32 tmp ;

  {
  {
#line 62
  tmp = __arch_swab32(val);
  }
#line 62
  return (tmp);
}
}
#line 27 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v2.c"
static int v2_check_file(int fd , int type , int fmt___7 ) ;
#line 28
static int v2_init_io(struct quota_handle *h ) ;
#line 29
static int v2_new_io(struct quota_handle *h ) ;
#line 30
static int v2_write_info(struct quota_handle *h ) ;
#line 31
static struct dquot *v2_read_dquot(struct quota_handle *h , qid_t id___0 ) ;
#line 32
static int v2_commit_dquot(struct dquot *dquot , int flags___7 ) ;
#line 33
static int v2_scan_dquots(struct quota_handle *h , int (*process_dquot)(struct dquot *dquot ,
                                                                        char *dqname ) ) ;
#line 34
static int v2_report(struct quota_handle *h , int verbose ) ;
#line 36 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v2.c"
struct quotafile_ops quotafile_ops_2  = 
#line 36
     {& v2_check_file, & v2_init_io, & v2_new_io, (int (*)(struct quota_handle *h ))0,
    & v2_write_info, & v2_read_dquot, & v2_commit_dquot, & v2_scan_dquots, & v2_report};
#line 53 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v2.c"
static void v2r0_disk2memdqblk(struct dquot *dquot , void *dp ) 
{ 
  struct util_dqblk *m ;
  struct v2r0_disk_dqblk *d ;
  struct v2r0_disk_dqblk empty ;
  int tmp ;

  {
  {
#line 55
  m = & dquot->dq_dqb;
#line 56
  d = (struct v2r0_disk_dqblk *)dp;
#line 58
  dquot->dq_id = d->dqb_id;
#line 59
  m->dqb_ihardlimit = (qsize_t )d->dqb_ihardlimit;
#line 60
  m->dqb_isoftlimit = (qsize_t )d->dqb_isoftlimit;
#line 61
  m->dqb_bhardlimit = (qsize_t )d->dqb_bhardlimit;
#line 62
  m->dqb_bsoftlimit = (qsize_t )d->dqb_bsoftlimit;
#line 63
  m->dqb_curinodes = (qsize_t )d->dqb_curinodes;
#line 64
  m->dqb_curspace = (qsize_t )((__le64 )d->dqb_curspace);
#line 65
  m->dqb_itime = (time_t )((__le64 )d->dqb_itime);
#line 66
  m->dqb_btime = (time_t )((__le64 )d->dqb_btime);
#line 68
  memset((void *)(& empty), 0, sizeof(struct v2r0_disk_dqblk ));
#line 69
  empty.dqb_itime = (u_int64_t )((__u64 )1);
#line 70
  tmp = memcmp((void const   *)(& empty), (void const   *)dp, sizeof(struct v2r0_disk_dqblk ));
  }
#line 70
  if (! tmp) {
#line 71
    m->dqb_itime = (time_t )0;
  }
#line 72
  return;
}
}
#line 77 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v2.c"
static void v2r0_mem2diskdqblk(void *dp , struct dquot *dquot ) 
{ 
  struct util_dqblk *m ;
  struct v2r0_disk_dqblk *d ;
  struct qtree_mem_dqinfo *info ;
  int tmp ;

  {
  {
#line 79
  m = & dquot->dq_dqb;
#line 80
  d = (struct v2r0_disk_dqblk *)dp;
#line 81
  info = & (dquot->dq_h)->qh_info.u.v2_mdqi.dqi_qtree;
#line 83
  d->dqb_ihardlimit = (__u32 )m->dqb_ihardlimit;
#line 84
  d->dqb_isoftlimit = (__u32 )m->dqb_isoftlimit;
#line 85
  d->dqb_bhardlimit = (__u32 )m->dqb_bhardlimit;
#line 86
  d->dqb_bsoftlimit = (__u32 )m->dqb_bsoftlimit;
#line 87
  d->dqb_curinodes = (__u32 )m->dqb_curinodes;
#line 88
  d->dqb_curspace = (u_int64_t )((__u64 )m->dqb_curspace);
#line 89
  d->dqb_itime = (u_int64_t )((__u64 )m->dqb_itime);
#line 90
  d->dqb_btime = (u_int64_t )((__u64 )m->dqb_btime);
#line 91
  d->dqb_id = dquot->dq_id;
#line 92
  tmp = qtree_entry_unused(info, (char *)dp);
  }
#line 92
  if (tmp) {
#line 93
    d->dqb_itime = (u_int64_t )((__u64 )1);
  }
#line 94
  return;
}
}
#line 96 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v2.c"
static int v2r0_is_id(void *dp , struct dquot *dquot ) 
{ 
  struct v2r0_disk_dqblk *d ;
  struct qtree_mem_dqinfo *info ;
  int tmp ;

  {
  {
#line 98
  d = (struct v2r0_disk_dqblk *)dp;
#line 99
  info = & (dquot->dq_h)->qh_info.u.v2_mdqi.dqi_qtree;
#line 101
  tmp = qtree_entry_unused(info, (char *)dp);
  }
#line 101
  if (tmp) {
#line 102
    return (0);
  }
#line 103
  return (d->dqb_id == dquot->dq_id);
}
}
#line 109 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v2.c"
static void v2r1_disk2memdqblk(struct dquot *dquot , void *dp ) 
{ 
  struct util_dqblk *m ;
  struct v2r1_disk_dqblk *d ;
  struct v2r1_disk_dqblk empty ;
  int tmp ;

  {
  {
#line 111
  m = & dquot->dq_dqb;
#line 112
  d = (struct v2r1_disk_dqblk *)dp;
#line 114
  dquot->dq_id = d->dqb_id;
#line 115
  m->dqb_ihardlimit = (qsize_t )((__le64 )d->dqb_ihardlimit);
#line 116
  m->dqb_isoftlimit = (qsize_t )((__le64 )d->dqb_isoftlimit);
#line 117
  m->dqb_bhardlimit = (qsize_t )((__le64 )d->dqb_bhardlimit);
#line 118
  m->dqb_bsoftlimit = (qsize_t )((__le64 )d->dqb_bsoftlimit);
#line 119
  m->dqb_curinodes = (qsize_t )((__le64 )d->dqb_curinodes);
#line 120
  m->dqb_curspace = (qsize_t )((__le64 )d->dqb_curspace);
#line 121
  m->dqb_itime = (time_t )((__le64 )d->dqb_itime);
#line 122
  m->dqb_btime = (time_t )((__le64 )d->dqb_btime);
#line 124
  memset((void *)(& empty), 0, sizeof(struct v2r1_disk_dqblk ));
#line 125
  empty.dqb_itime = (u_int64_t )((__u64 )1);
#line 126
  tmp = memcmp((void const   *)(& empty), (void const   *)dp, sizeof(struct v2r1_disk_dqblk ));
  }
#line 126
  if (! tmp) {
#line 127
    m->dqb_itime = (time_t )0;
  }
#line 128
  return;
}
}
#line 133 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v2.c"
static void v2r1_mem2diskdqblk(void *dp , struct dquot *dquot ) 
{ 
  struct util_dqblk *m ;
  struct v2r1_disk_dqblk *d ;
  int tmp ;

  {
  {
#line 135
  m = & dquot->dq_dqb;
#line 136
  d = (struct v2r1_disk_dqblk *)dp;
#line 138
  d->dqb_ihardlimit = (u_int64_t )((__u64 )m->dqb_ihardlimit);
#line 139
  d->dqb_isoftlimit = (u_int64_t )((__u64 )m->dqb_isoftlimit);
#line 140
  d->dqb_bhardlimit = (u_int64_t )((__u64 )m->dqb_bhardlimit);
#line 141
  d->dqb_bsoftlimit = (u_int64_t )((__u64 )m->dqb_bsoftlimit);
#line 142
  d->dqb_curinodes = (u_int64_t )((__u64 )m->dqb_curinodes);
#line 143
  d->dqb_curspace = (u_int64_t )((__u64 )m->dqb_curspace);
#line 144
  d->dqb_itime = (u_int64_t )((__u64 )m->dqb_itime);
#line 145
  d->dqb_btime = (u_int64_t )((__u64 )m->dqb_btime);
#line 146
  d->dqb_id = dquot->dq_id;
#line 147
  d->dqb_pad = (u_int32_t )0;
#line 148
  tmp = qtree_entry_unused(& (dquot->dq_h)->qh_info.u.v2_mdqi.dqi_qtree, (char *)dp);
  }
#line 148
  if (tmp) {
#line 149
    d->dqb_itime = (u_int64_t )((__u64 )1);
  }
#line 150
  return;
}
}
#line 152 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v2.c"
static int v2r1_is_id(void *dp , struct dquot *dquot ) 
{ 
  struct v2r1_disk_dqblk *d ;
  struct qtree_mem_dqinfo *info ;
  int tmp ;

  {
  {
#line 154
  d = (struct v2r1_disk_dqblk *)dp;
#line 155
  info = & (dquot->dq_h)->qh_info.u.v2_mdqi.dqi_qtree;
#line 157
  tmp = qtree_entry_unused(info, (char *)dp);
  }
#line 157
  if (tmp) {
#line 158
    return (0);
  }
#line 159
  return (d->dqb_id == dquot->dq_id);
}
}
#line 162 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v2.c"
static struct qtree_fmt_operations v2r0_fmt_ops  =    {& v2r0_mem2diskdqblk, & v2r0_disk2memdqblk, & v2r0_is_id};
#line 168 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v2.c"
static struct qtree_fmt_operations v2r1_fmt_ops  =    {& v2r1_mem2diskdqblk, & v2r1_disk2memdqblk, & v2r1_is_id};
#line 177 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v2.c"
__inline static void v2_disk2memdqinfo(struct util_dqinfo *m , struct v2_disk_dqinfo *d ) 
{ 


  {
#line 179
  m->dqi_bgrace = (time_t )d->dqi_bgrace;
#line 180
  m->dqi_igrace = (time_t )d->dqi_igrace;
#line 181
  m->u.v2_mdqi.dqi_flags = 0U;
#line 182
  m->u.v2_mdqi.dqi_qtree.dqi_blocks = d->dqi_blocks;
#line 183
  m->u.v2_mdqi.dqi_qtree.dqi_free_blk = d->dqi_free_blk;
#line 184
  m->u.v2_mdqi.dqi_qtree.dqi_free_entry = d->dqi_free_entry;
#line 185
  return;
}
}
#line 190 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v2.c"
__inline static void v2_mem2diskdqinfo(struct v2_disk_dqinfo *d , struct util_dqinfo *m ) 
{ 


  {
#line 192
  d->dqi_bgrace = (__u32 )m->dqi_bgrace;
#line 193
  d->dqi_igrace = (__u32 )m->dqi_igrace;
#line 194
  d->dqi_flags = 0U;
#line 195
  d->dqi_blocks = m->u.v2_mdqi.dqi_qtree.dqi_blocks;
#line 196
  d->dqi_free_blk = m->u.v2_mdqi.dqi_qtree.dqi_free_blk;
#line 197
  d->dqi_free_entry = m->u.v2_mdqi.dqi_qtree.dqi_free_entry;
#line 198
  return;
}
}
#line 201 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v2.c"
__inline static void v2_kern2utildqblk(struct util_dqblk *u , struct v2_kern_dqblk *k ) 
{ 


  {
#line 203
  u->dqb_ihardlimit = (qsize_t )k->dqb_ihardlimit;
#line 204
  u->dqb_isoftlimit = (qsize_t )k->dqb_isoftlimit;
#line 205
  u->dqb_bhardlimit = (qsize_t )k->dqb_bhardlimit;
#line 206
  u->dqb_bsoftlimit = (qsize_t )k->dqb_bsoftlimit;
#line 207
  u->dqb_curinodes = (qsize_t )k->dqb_curinodes;
#line 208
  u->dqb_curspace = k->dqb_curspace;
#line 209
  u->dqb_itime = k->dqb_itime;
#line 210
  u->dqb_btime = k->dqb_btime;
#line 211
  return;
}
}
#line 214 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v2.c"
__inline static void v2_util2kerndqblk(struct v2_kern_dqblk *k , struct util_dqblk *u ) 
{ 


  {
#line 216
  k->dqb_ihardlimit = (unsigned int )u->dqb_ihardlimit;
#line 217
  k->dqb_isoftlimit = (unsigned int )u->dqb_isoftlimit;
#line 218
  k->dqb_bhardlimit = (unsigned int )u->dqb_bhardlimit;
#line 219
  k->dqb_bsoftlimit = (unsigned int )u->dqb_bsoftlimit;
#line 220
  k->dqb_curinodes = (unsigned int )u->dqb_curinodes;
#line 221
  k->dqb_curspace = u->dqb_curspace;
#line 222
  k->dqb_itime = u->dqb_itime;
#line 223
  k->dqb_btime = u->dqb_btime;
#line 224
  return;
}
}
#line 226 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v2.c"
static int v2_read_header(int fd , struct v2_disk_dqheader *h ) 
{ 
  ssize_t tmp ;

  {
  {
#line 228
  lseek(fd, (__off64_t )0, 0);
#line 229
  tmp = read(fd, (void *)h, sizeof(struct v2_disk_dqheader ));
  }
#line 229
  if ((unsigned long )tmp != sizeof(struct v2_disk_dqheader )) {
#line 230
    return (0);
  }
#line 231
  return (1);
}
}
#line 237 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v2.c"
static int v2_check_file(int fd , int type , int fmt___7 ) 
{ 
  struct v2_disk_dqheader h ;
  int file_magics[2] ;
  int known_versions___0[2] ;
  int version___0 ;
  int tmp ;
  char *tmp___0 ;
  __u32 tmp___1 ;

  {
  {
#line 240
  file_magics[0] = -641720559;
#line 240
  file_magics[1] = -641722073;
#line 241
  known_versions___0[0] = 1;
#line 241
  known_versions___0[1] = 1;
#line 244
  tmp = v2_read_header(fd, & h);
  }
#line 244
  if (! tmp) {
#line 245
    return (0);
  }
#line 246
  if (fmt___7 == 1) {
#line 247
    version___0 = 0;
  } else
#line 248
  if (fmt___7 == 2) {
#line 249
    version___0 = 1;
  } else {
#line 251
    return (0);
  }
#line 253
  if (h.dqh_magic != (__u32 )file_magics[type]) {
    {
#line 254
    tmp___1 = __fswab32(h.dqh_magic);
    }
#line 254
    if (tmp___1 == (__u32 )file_magics[type]) {
      {
#line 255
      tmp___0 = gettext("Your quota file is stored in wrong endianity. Please use convertquota(8) to convert it.\n");
#line 255
      die(3, tmp___0);
      }
    }
#line 256
    return (0);
  }
#line 258
  if (h.dqh_version > (__u32 )known_versions___0[type]) {
#line 259
    return (0);
  }
#line 260
  if ((__u32 )version___0 != h.dqh_version) {
#line 261
    return (0);
  }
#line 262
  return (1);
}
}
#line 268 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v2.c"
static int v2_init_io(struct quota_handle *h ) 
{ 
  int tmp ;
  struct v2_kern_dqinfo kdqinfo ;
  int *tmp___0 ;
  long tmp___1 ;
  struct v2_disk_dqinfo ddqinfo ;
  struct v2_disk_dqheader header ;
  int tmp___2 ;
  ssize_t tmp___3 ;

  {
#line 270
  if (h->qh_io_flags & 1) {
#line 271
    if (kernel_iface == 3) {
      {
#line 272
      tmp = vfs_get_info(h);
      }
#line 272
      if (tmp < 0) {
#line 273
        return (-1);
      }
    } else {
      {
#line 278
      tmp___1 = quotactl((2304 << 8) | (h->qh_type & 255), (char const   *)(h->qh_quotadev),
                         (qid_t )0, (caddr_t )((void *)(& kdqinfo)));
      }
#line 278
      if (tmp___1 < 0L) {
        {
#line 280
        tmp___0 = __errno_location();
        }
#line 280
        if (*tmp___0 == 1) {
#line 281
          return (0);
        }
#line 282
        return (-1);
      }
#line 284
      h->qh_info.dqi_bgrace = (time_t )kdqinfo.dqi_bgrace;
#line 285
      h->qh_info.dqi_igrace = (time_t )kdqinfo.dqi_igrace;
#line 286
      h->qh_info.u.v2_mdqi.dqi_flags = kdqinfo.dqi_flags;
#line 287
      h->qh_info.u.v2_mdqi.dqi_qtree.dqi_blocks = kdqinfo.dqi_blocks;
#line 288
      h->qh_info.u.v2_mdqi.dqi_qtree.dqi_free_blk = kdqinfo.dqi_free_blk;
#line 289
      h->qh_info.u.v2_mdqi.dqi_qtree.dqi_free_entry = kdqinfo.dqi_free_entry;
    }
  }
#line 292
  if (h->qh_fd != -1) {
    {
#line 296
    tmp___2 = v2_read_header(h->qh_fd, & header);
    }
#line 296
    if (! tmp___2) {
#line 297
      return (-1);
    }
    {
#line 299
    lseek(h->qh_fd, (__off64_t )sizeof(struct v2_disk_dqheader ), 0);
#line 300
    tmp___3 = read(h->qh_fd, (void *)(& ddqinfo), sizeof(ddqinfo));
    }
#line 300
    if ((unsigned long )tmp___3 != sizeof(ddqinfo)) {
#line 301
      return (-1);
    }
#line 303
    if (! (h->qh_io_flags & 1)) {
      {
#line 304
      v2_disk2memdqinfo(& h->qh_info, & ddqinfo);
      }
    } else {
#line 306
      h->qh_info.u.v2_mdqi.dqi_qtree.dqi_blocks = ddqinfo.dqi_blocks;
    }
#line 308
    if (header.dqh_version == 0U) {
#line 309
      h->qh_info.u.v2_mdqi.dqi_qtree.dqi_entry_size = (unsigned int )sizeof(struct v2r0_disk_dqblk );
#line 310
      h->qh_info.u.v2_mdqi.dqi_qtree.dqi_ops = & v2r0_fmt_ops;
#line 311
      h->qh_info.dqi_max_b_limit = (uint64_t )(~ ((uint32_t )0));
#line 312
      h->qh_info.dqi_max_i_limit = (uint64_t )(~ ((uint32_t )0));
#line 313
      h->qh_info.dqi_max_b_usage = ~ ((uint64_t )0);
#line 314
      h->qh_info.dqi_max_i_usage = (uint64_t )(~ ((uint32_t )0));
    } else {
#line 316
      h->qh_info.u.v2_mdqi.dqi_qtree.dqi_entry_size = (unsigned int )sizeof(struct v2r1_disk_dqblk );
#line 317
      h->qh_info.u.v2_mdqi.dqi_qtree.dqi_ops = & v2r1_fmt_ops;
#line 318
      h->qh_info.dqi_max_b_limit = ~ ((uint64_t )0);
#line 319
      h->qh_info.dqi_max_i_limit = ~ ((uint64_t )0);
#line 320
      h->qh_info.dqi_max_b_usage = ~ ((uint64_t )0);
#line 321
      h->qh_info.dqi_max_i_usage = ~ ((uint64_t )0);
    }
  } else {
#line 325
    h->qh_info.u.v2_mdqi.dqi_qtree.dqi_ops = (struct qtree_fmt_operations *)((void *)0);
  }
#line 327
  return (0);
}
}
#line 333 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v2.c"
static int v2_new_io(struct quota_handle *h ) 
{ 
  int file_magics[2] ;
  struct v2_disk_dqheader ddqheader ;
  struct v2_disk_dqinfo ddqinfo ;
  int version___0 ;
  ssize_t tmp ;
  ssize_t tmp___0 ;

  {
#line 335
  file_magics[0] = -641720559;
#line 335
  file_magics[1] = -641722073;
#line 340
  if (h->qh_fmt == 1) {
#line 341
    version___0 = 0;
  } else
#line 342
  if (h->qh_fmt == 2) {
#line 343
    version___0 = 1;
  } else {
#line 345
    return (-1);
  }
  {
#line 348
  ddqheader.dqh_magic = (__u32 )file_magics[h->qh_type];
#line 349
  ddqheader.dqh_version = (__u32 )version___0;
#line 350
  lseek(h->qh_fd, (__off64_t )0, 0);
#line 351
  tmp = write(h->qh_fd, (void const   *)(& ddqheader), sizeof(ddqheader));
  }
#line 351
  if ((unsigned long )tmp != sizeof(ddqheader)) {
#line 352
    return (-1);
  }
#line 354
  h->qh_info.dqi_bgrace = (time_t )604800;
#line 355
  h->qh_info.dqi_igrace = (time_t )604800;
#line 356
  h->qh_info.u.v2_mdqi.dqi_flags = (uint )0;
#line 357
  h->qh_info.u.v2_mdqi.dqi_qtree.dqi_blocks = 2U;
#line 358
  h->qh_info.u.v2_mdqi.dqi_qtree.dqi_free_blk = 0U;
#line 359
  h->qh_info.u.v2_mdqi.dqi_qtree.dqi_free_entry = 0U;
#line 360
  if (version___0 == 0) {
#line 361
    h->qh_info.u.v2_mdqi.dqi_qtree.dqi_entry_size = (unsigned int )sizeof(struct v2r0_disk_dqblk );
#line 362
    h->qh_info.u.v2_mdqi.dqi_qtree.dqi_ops = & v2r0_fmt_ops;
#line 363
    h->qh_info.dqi_max_b_limit = (uint64_t )(~ ((uint32_t )0));
#line 364
    h->qh_info.dqi_max_i_limit = (uint64_t )(~ ((uint32_t )0));
#line 365
    h->qh_info.dqi_max_b_usage = ~ ((uint64_t )0);
#line 366
    h->qh_info.dqi_max_i_usage = (uint64_t )(~ ((uint32_t )0));
  } else
#line 367
  if (version___0 == 1) {
#line 368
    h->qh_info.u.v2_mdqi.dqi_qtree.dqi_entry_size = (unsigned int )sizeof(struct v2r1_disk_dqblk );
#line 369
    h->qh_info.u.v2_mdqi.dqi_qtree.dqi_ops = & v2r1_fmt_ops;
#line 370
    h->qh_info.dqi_max_b_limit = ~ ((uint64_t )0);
#line 371
    h->qh_info.dqi_max_i_limit = ~ ((uint64_t )0);
#line 372
    h->qh_info.dqi_max_b_usage = ~ ((uint64_t )0);
#line 373
    h->qh_info.dqi_max_i_usage = ~ ((uint64_t )0);
  }
  {
#line 375
  v2_mem2diskdqinfo(& ddqinfo, & h->qh_info);
#line 376
  lseek(h->qh_fd, (__off64_t )sizeof(struct v2_disk_dqheader ), 0);
#line 377
  tmp___0 = write(h->qh_fd, (void const   *)(& ddqinfo), sizeof(ddqinfo));
  }
#line 377
  if ((unsigned long )tmp___0 != sizeof(ddqinfo)) {
#line 378
    return (-1);
  }
#line 379
  return (0);
}
}
#line 385 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v2.c"
static int v2_write_info(struct quota_handle *h ) 
{ 
  char *tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  struct v2_kern_dqinfo kdqinfo ;
  long tmp___2 ;
  long tmp___3 ;
  struct v2_disk_dqinfo ddqinfo ;
  ssize_t tmp___4 ;

  {
#line 387
  if (h->qh_io_flags & 4) {
    {
#line 388
    tmp = gettext("Trying to write info to readonly quotafile on %s\n");
#line 388
    errstr(tmp, h->qh_quotadev);
#line 389
    tmp___0 = __errno_location();
#line 389
    *tmp___0 = 1;
    }
#line 390
    return (-1);
  }
#line 392
  if (h->qh_io_flags & 1) {
#line 393
    if (kernel_iface == 3) {
      {
#line 394
      tmp___1 = vfs_set_info(h, 3);
      }
#line 394
      if (tmp___1) {
#line 395
        return (-1);
      }
    } else {
      {
#line 400
      kdqinfo.dqi_bgrace = (unsigned int )h->qh_info.dqi_bgrace;
#line 401
      kdqinfo.dqi_igrace = (unsigned int )h->qh_info.dqi_igrace;
#line 402
      kdqinfo.dqi_flags = h->qh_info.u.v2_mdqi.dqi_flags;
#line 403
      kdqinfo.dqi_blocks = h->qh_info.u.v2_mdqi.dqi_qtree.dqi_blocks;
#line 404
      kdqinfo.dqi_free_blk = h->qh_info.u.v2_mdqi.dqi_qtree.dqi_free_blk;
#line 405
      kdqinfo.dqi_free_entry = h->qh_info.u.v2_mdqi.dqi_qtree.dqi_free_entry;
#line 406
      tmp___2 = quotactl((2816 << 8) | (h->qh_type & 255), (char const   *)(h->qh_quotadev),
                         (qid_t )0, (caddr_t )((void *)(& kdqinfo)));
      }
#line 406
      if (tmp___2 < 0L) {
#line 408
        return (-1);
      } else {
        {
#line 406
        tmp___3 = quotactl((3072 << 8) | (h->qh_type & 255), (char const   *)(h->qh_quotadev),
                           (qid_t )0, (caddr_t )((void *)(& kdqinfo)));
        }
#line 406
        if (tmp___3 < 0L) {
#line 408
          return (-1);
        }
      }
    }
  } else {
    {
#line 414
    v2_mem2diskdqinfo(& ddqinfo, & h->qh_info);
#line 415
    lseek(h->qh_fd, (__off64_t )sizeof(struct v2_disk_dqheader ), 0);
#line 416
    tmp___4 = write(h->qh_fd, (void const   *)(& ddqinfo), sizeof(ddqinfo));
    }
#line 416
    if ((unsigned long )tmp___4 != sizeof(ddqinfo)) {
#line 417
      return (-1);
    }
  }
#line 419
  return (0);
}
}
#line 426 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v2.c"
static struct dquot *v2_read_dquot(struct quota_handle *h , qid_t id___0 ) 
{ 
  struct dquot *dquot ;
  struct dquot *tmp ;
  int tmp___0 ;
  struct v2_kern_dqblk kdqblk ;
  long tmp___1 ;
  struct dquot *tmp___2 ;

  {
#line 428
  if (h->qh_io_flags & 1) {
    {
#line 429
    tmp = get_empty_dquot();
#line 429
    dquot = tmp;
#line 431
    dquot->dq_id = id___0;
#line 432
    dquot->dq_h = h;
#line 433
    dquot->dq_dqb.u.v2_mdqb.dqb_off = (loff_t )0;
#line 434
    memset((void *)(& dquot->dq_dqb), 0, sizeof(struct util_dqblk ));
    }
#line 435
    if (kernel_iface == 3) {
      {
#line 436
      tmp___0 = vfs_get_dquot(dquot);
      }
#line 436
      if (tmp___0 < 0) {
        {
#line 437
        free((void *)dquot);
        }
#line 438
        return ((struct dquot *)((void *)0));
      }
    } else {
      {
#line 444
      tmp___1 = quotactl((3328 << 8) | (h->qh_type & 255), (char const   *)(h->qh_quotadev),
                         id___0, (caddr_t )((void *)(& kdqblk)));
      }
#line 444
      if (tmp___1 < 0L) {
        {
#line 445
        free((void *)dquot);
        }
#line 446
        return ((struct dquot *)((void *)0));
      }
      {
#line 448
      v2_kern2utildqblk(& dquot->dq_dqb, & kdqblk);
      }
    }
#line 450
    return (dquot);
  }
  {
#line 452
  tmp___2 = qtree_read_dquot(h, id___0);
  }
#line 452
  return (tmp___2);
}
}
#line 459 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v2.c"
static int v2_commit_dquot(struct dquot *dquot , int flags___7 ) 
{ 
  struct util_dqblk *b ;
  char *tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  struct v2_kern_dqblk kdqblk ;
  int cmd ;
  int *tmp___2 ;
  long tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;

  {
#line 461
  b = & dquot->dq_dqb;
#line 463
  if ((dquot->dq_h)->qh_io_flags & 4) {
    {
#line 464
    tmp = gettext("Trying to write quota to readonly quotafile on %s\n");
#line 464
    errstr(tmp, (dquot->dq_h)->qh_quotadev);
#line 465
    tmp___0 = __errno_location();
#line 465
    *tmp___0 = 1;
    }
#line 466
    return (-1);
  }
#line 468
  if ((dquot->dq_h)->qh_io_flags & 1) {
#line 469
    if (kernel_iface == 3) {
      {
#line 470
      tmp___1 = vfs_set_dquot(dquot, flags___7);
      }
#line 470
      if (tmp___1 < 0) {
#line 471
        return (-1);
      }
    } else {
#line 477
      if (flags___7 == 10) {
#line 478
        cmd = 3840;
      } else
#line 479
      if (flags___7 == 5) {
#line 480
        cmd = 1792;
      } else
#line 481
      if (flags___7 & 48) {
        {
#line 482
        tmp___2 = __errno_location();
#line 482
        *tmp___2 = 22;
        }
#line 483
        return (-1);
      } else {
#line 486
        cmd = 3584;
      }
      {
#line 487
      v2_util2kerndqblk(& kdqblk, & dquot->dq_dqb);
#line 488
      tmp___3 = quotactl((cmd << 8) | ((dquot->dq_h)->qh_type & 255), (char const   *)((dquot->dq_h)->qh_quotadev),
                         dquot->dq_id, (caddr_t )((void *)(& kdqblk)));
      }
#line 488
      if (tmp___3 < 0L) {
#line 490
        return (-1);
      }
    }
#line 492
    return (0);
  }
#line 494
  if (! b->dqb_curspace) {
#line 494
    if (! b->dqb_curinodes) {
#line 494
      if (! b->dqb_bsoftlimit) {
#line 494
        if (! b->dqb_isoftlimit) {
#line 494
          if (! b->dqb_bhardlimit) {
#line 494
            if (! b->dqb_ihardlimit) {
              {
#line 496
              qtree_delete_dquot(dquot);
              }
            } else {
#line 494
              goto _L___3;
            }
          } else {
#line 494
            goto _L___3;
          }
        } else {
#line 494
          goto _L___3;
        }
      } else {
#line 494
        goto _L___3;
      }
    } else {
#line 494
      goto _L___3;
    }
  } else {
    _L___3: /* CIL Label */ 
    {
#line 498
    tmp___5 = check_dquot_range(dquot);
    }
#line 498
    if (tmp___5 < 0) {
      {
#line 499
      tmp___4 = __errno_location();
#line 499
      *tmp___4 = 34;
      }
#line 500
      return (-1);
    }
    {
#line 502
    qtree_write_dquot(dquot);
    }
  }
#line 504
  return (0);
}
}
#line 507 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v2.c"
static int v2_scan_dquots(struct quota_handle *h , int (*process_dquot)(struct dquot *dquot ,
                                                                        char *dqname ) ) 
{ 
  int tmp ;

  {
  {
#line 509
  tmp = qtree_scan_dquots(h, process_dquot);
  }
#line 509
  return (tmp);
}
}
#line 513 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v2.c"
static int v2_report(struct quota_handle *h , int verbose ) 
{ 
  struct v2_mem_dqinfo *info ;
  char *tmp ;

  {
#line 515
  if (verbose) {
    {
#line 516
    info = & h->qh_info.u.v2_mdqi;
#line 518
    tmp = gettext("Statistics:\nTotal blocks: %u\nData blocks: %u\nEntries: %u\nUsed average: %f\n");
#line 518
    printf((char const   */* __restrict  */)tmp, info->dqi_qtree.dqi_blocks, info->dqi_data_blocks,
           info->dqi_used_entries, (double )((float )info->dqi_used_entries / (float )info->dqi_data_blocks));
    }
  }
#line 522
  return (0);
}
}
#line 23 "/home/wheatley/newnew/temp/quota-4.01/common.c"
static int enable_syslog___0  =    0;
#line 31 "/home/wheatley/newnew/temp/quota-4.01/common.c"
static void do_syslog___0(int level , char const   *format , va_list args ) 
{ 
  char buf[1024] ;
  int i ;
  int j ;
  int tmp ;

  {
  {
#line 36
  vsnprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)format,
            args);
#line 39
  i = 0;
  }
  {
#line 39
  while (1) {
    while_continue: /* CIL Label */ ;
#line 39
    if (! buf[i]) {
#line 39
      goto while_break;
    }
#line 40
    j = i;
    {
#line 40
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 40
      if (buf[j]) {
#line 40
        if (! ((int )buf[j] != 10)) {
#line 40
          goto while_break___0;
        }
      } else {
#line 40
        goto while_break___0;
      }
#line 40
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 41
    if ((int )buf[j] == 10) {
#line 42
      tmp = j;
#line 42
      j ++;
#line 42
      buf[tmp] = (char )'\000';
    }
    {
#line 43
    syslog(level, "%s", buf + i);
#line 39
    i = j;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 45
  return;
}
}
#line 27 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v2.c"
static int v2_check_file___0(int fd , int type , int fmt___7 ) ;
#line 28
static int v2_init_io___0(struct quota_handle *h ) ;
#line 29
static int v2_new_io___0(struct quota_handle *h ) ;
#line 30
static int v2_write_info___0(struct quota_handle *h ) ;
#line 31
static struct dquot *v2_read_dquot___0(struct quota_handle *h , qid_t id___0 ) ;
#line 32
static int v2_commit_dquot___0(struct dquot *dquot , int flags___7 ) ;
#line 33
static int v2_scan_dquots___0(struct quota_handle *h , int (*process_dquot)(struct dquot *dquot ,
                                                                            char *dqname ) ) ;
#line 34
static int v2_report___0(struct quota_handle *h , int verbose ) ;
#line 53 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v2.c"
static void v2r0_disk2memdqblk___0(struct dquot *dquot , void *dp ) 
{ 
  struct util_dqblk *m ;
  struct v2r0_disk_dqblk *d ;
  struct v2r0_disk_dqblk empty ;
  int tmp ;

  {
  {
#line 55
  m = & dquot->dq_dqb;
#line 56
  d = (struct v2r0_disk_dqblk *)dp;
#line 58
  dquot->dq_id = d->dqb_id;
#line 59
  m->dqb_ihardlimit = (qsize_t )d->dqb_ihardlimit;
#line 60
  m->dqb_isoftlimit = (qsize_t )d->dqb_isoftlimit;
#line 61
  m->dqb_bhardlimit = (qsize_t )d->dqb_bhardlimit;
#line 62
  m->dqb_bsoftlimit = (qsize_t )d->dqb_bsoftlimit;
#line 63
  m->dqb_curinodes = (qsize_t )d->dqb_curinodes;
#line 64
  m->dqb_curspace = (qsize_t )((__le64 )d->dqb_curspace);
#line 65
  m->dqb_itime = (time_t )((__le64 )d->dqb_itime);
#line 66
  m->dqb_btime = (time_t )((__le64 )d->dqb_btime);
#line 68
  memset((void *)(& empty), 0, sizeof(struct v2r0_disk_dqblk ));
#line 69
  empty.dqb_itime = (u_int64_t )((__u64 )1);
#line 70
  tmp = memcmp((void const   *)(& empty), (void const   *)dp, sizeof(struct v2r0_disk_dqblk ));
  }
#line 70
  if (! tmp) {
#line 71
    m->dqb_itime = (time_t )0;
  }
#line 72
  return;
}
}
#line 77 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v2.c"
static void v2r0_mem2diskdqblk___0(void *dp , struct dquot *dquot ) 
{ 
  struct util_dqblk *m ;
  struct v2r0_disk_dqblk *d ;
  struct qtree_mem_dqinfo *info ;
  int tmp ;

  {
  {
#line 79
  m = & dquot->dq_dqb;
#line 80
  d = (struct v2r0_disk_dqblk *)dp;
#line 81
  info = & (dquot->dq_h)->qh_info.u.v2_mdqi.dqi_qtree;
#line 83
  d->dqb_ihardlimit = (__u32 )m->dqb_ihardlimit;
#line 84
  d->dqb_isoftlimit = (__u32 )m->dqb_isoftlimit;
#line 85
  d->dqb_bhardlimit = (__u32 )m->dqb_bhardlimit;
#line 86
  d->dqb_bsoftlimit = (__u32 )m->dqb_bsoftlimit;
#line 87
  d->dqb_curinodes = (__u32 )m->dqb_curinodes;
#line 88
  d->dqb_curspace = (u_int64_t )((__u64 )m->dqb_curspace);
#line 89
  d->dqb_itime = (u_int64_t )((__u64 )m->dqb_itime);
#line 90
  d->dqb_btime = (u_int64_t )((__u64 )m->dqb_btime);
#line 91
  d->dqb_id = dquot->dq_id;
#line 92
  tmp = qtree_entry_unused(info, (char *)dp);
  }
#line 92
  if (tmp) {
#line 93
    d->dqb_itime = (u_int64_t )((__u64 )1);
  }
#line 94
  return;
}
}
#line 96 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v2.c"
static int v2r0_is_id___0(void *dp , struct dquot *dquot ) 
{ 
  struct v2r0_disk_dqblk *d ;
  struct qtree_mem_dqinfo *info ;
  int tmp ;

  {
  {
#line 98
  d = (struct v2r0_disk_dqblk *)dp;
#line 99
  info = & (dquot->dq_h)->qh_info.u.v2_mdqi.dqi_qtree;
#line 101
  tmp = qtree_entry_unused(info, (char *)dp);
  }
#line 101
  if (tmp) {
#line 102
    return (0);
  }
#line 103
  return (d->dqb_id == dquot->dq_id);
}
}
#line 109 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v2.c"
static void v2r1_disk2memdqblk___0(struct dquot *dquot , void *dp ) 
{ 
  struct util_dqblk *m ;
  struct v2r1_disk_dqblk *d ;
  struct v2r1_disk_dqblk empty ;
  int tmp ;

  {
  {
#line 111
  m = & dquot->dq_dqb;
#line 112
  d = (struct v2r1_disk_dqblk *)dp;
#line 114
  dquot->dq_id = d->dqb_id;
#line 115
  m->dqb_ihardlimit = (qsize_t )((__le64 )d->dqb_ihardlimit);
#line 116
  m->dqb_isoftlimit = (qsize_t )((__le64 )d->dqb_isoftlimit);
#line 117
  m->dqb_bhardlimit = (qsize_t )((__le64 )d->dqb_bhardlimit);
#line 118
  m->dqb_bsoftlimit = (qsize_t )((__le64 )d->dqb_bsoftlimit);
#line 119
  m->dqb_curinodes = (qsize_t )((__le64 )d->dqb_curinodes);
#line 120
  m->dqb_curspace = (qsize_t )((__le64 )d->dqb_curspace);
#line 121
  m->dqb_itime = (time_t )((__le64 )d->dqb_itime);
#line 122
  m->dqb_btime = (time_t )((__le64 )d->dqb_btime);
#line 124
  memset((void *)(& empty), 0, sizeof(struct v2r1_disk_dqblk ));
#line 125
  empty.dqb_itime = (u_int64_t )((__u64 )1);
#line 126
  tmp = memcmp((void const   *)(& empty), (void const   *)dp, sizeof(struct v2r1_disk_dqblk ));
  }
#line 126
  if (! tmp) {
#line 127
    m->dqb_itime = (time_t )0;
  }
#line 128
  return;
}
}
#line 133 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v2.c"
static void v2r1_mem2diskdqblk___0(void *dp , struct dquot *dquot ) 
{ 
  struct util_dqblk *m ;
  struct v2r1_disk_dqblk *d ;
  int tmp ;

  {
  {
#line 135
  m = & dquot->dq_dqb;
#line 136
  d = (struct v2r1_disk_dqblk *)dp;
#line 138
  d->dqb_ihardlimit = (u_int64_t )((__u64 )m->dqb_ihardlimit);
#line 139
  d->dqb_isoftlimit = (u_int64_t )((__u64 )m->dqb_isoftlimit);
#line 140
  d->dqb_bhardlimit = (u_int64_t )((__u64 )m->dqb_bhardlimit);
#line 141
  d->dqb_bsoftlimit = (u_int64_t )((__u64 )m->dqb_bsoftlimit);
#line 142
  d->dqb_curinodes = (u_int64_t )((__u64 )m->dqb_curinodes);
#line 143
  d->dqb_curspace = (u_int64_t )((__u64 )m->dqb_curspace);
#line 144
  d->dqb_itime = (u_int64_t )((__u64 )m->dqb_itime);
#line 145
  d->dqb_btime = (u_int64_t )((__u64 )m->dqb_btime);
#line 146
  d->dqb_id = dquot->dq_id;
#line 147
  d->dqb_pad = (u_int32_t )0;
#line 148
  tmp = qtree_entry_unused(& (dquot->dq_h)->qh_info.u.v2_mdqi.dqi_qtree, (char *)dp);
  }
#line 148
  if (tmp) {
#line 149
    d->dqb_itime = (u_int64_t )((__u64 )1);
  }
#line 150
  return;
}
}
#line 152 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v2.c"
static int v2r1_is_id___0(void *dp , struct dquot *dquot ) 
{ 
  struct v2r1_disk_dqblk *d ;
  struct qtree_mem_dqinfo *info ;
  int tmp ;

  {
  {
#line 154
  d = (struct v2r1_disk_dqblk *)dp;
#line 155
  info = & (dquot->dq_h)->qh_info.u.v2_mdqi.dqi_qtree;
#line 157
  tmp = qtree_entry_unused(info, (char *)dp);
  }
#line 157
  if (tmp) {
#line 158
    return (0);
  }
#line 159
  return (d->dqb_id == dquot->dq_id);
}
}
#line 162 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v2.c"
static struct qtree_fmt_operations v2r0_fmt_ops___0  =    {& v2r0_mem2diskdqblk___0, & v2r0_disk2memdqblk___0, & v2r0_is_id___0};
#line 168 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v2.c"
static struct qtree_fmt_operations v2r1_fmt_ops___0  =    {& v2r1_mem2diskdqblk___0, & v2r1_disk2memdqblk___0, & v2r1_is_id___0};
#line 226 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v2.c"
static int v2_read_header___0(int fd , struct v2_disk_dqheader *h ) 
{ 
  ssize_t tmp ;

  {
  {
#line 228
  lseek(fd, (__off64_t )0, 0);
#line 229
  tmp = read(fd, (void *)h, sizeof(struct v2_disk_dqheader ));
  }
#line 229
  if ((unsigned long )tmp != sizeof(struct v2_disk_dqheader )) {
#line 230
    return (0);
  }
#line 231
  return (1);
}
}
#line 237 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v2.c"
static int v2_check_file___0(int fd , int type , int fmt___7 ) 
{ 
  struct v2_disk_dqheader h ;
  int file_magics[2] ;
  int known_versions___0[2] ;
  int version___0 ;
  int tmp ;
  char *tmp___0 ;
  __u32 tmp___1 ;

  {
  {
#line 240
  file_magics[0] = -641720559;
#line 240
  file_magics[1] = -641722073;
#line 241
  known_versions___0[0] = 1;
#line 241
  known_versions___0[1] = 1;
#line 244
  tmp = v2_read_header___0(fd, & h);
  }
#line 244
  if (! tmp) {
#line 245
    return (0);
  }
#line 246
  if (fmt___7 == 1) {
#line 247
    version___0 = 0;
  } else
#line 248
  if (fmt___7 == 2) {
#line 249
    version___0 = 1;
  } else {
#line 251
    return (0);
  }
#line 253
  if (h.dqh_magic != (__u32 )file_magics[type]) {
    {
#line 254
    tmp___1 = __fswab32(h.dqh_magic);
    }
#line 254
    if (tmp___1 == (__u32 )file_magics[type]) {
      {
#line 255
      tmp___0 = gettext("Your quota file is stored in wrong endianity. Please use convertquota(8) to convert it.\n");
#line 255
      die(3, tmp___0);
      }
    }
#line 256
    return (0);
  }
#line 258
  if (h.dqh_version > (__u32 )known_versions___0[type]) {
#line 259
    return (0);
  }
#line 260
  if ((__u32 )version___0 != h.dqh_version) {
#line 261
    return (0);
  }
#line 262
  return (1);
}
}
#line 268 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v2.c"
static int v2_init_io___0(struct quota_handle *h ) 
{ 
  int tmp ;
  struct v2_kern_dqinfo kdqinfo ;
  int *tmp___0 ;
  long tmp___1 ;
  struct v2_disk_dqinfo ddqinfo ;
  struct v2_disk_dqheader header ;
  int tmp___2 ;
  ssize_t tmp___3 ;

  {
#line 270
  if (h->qh_io_flags & 1) {
#line 271
    if (kernel_iface == 3) {
      {
#line 272
      tmp = vfs_get_info(h);
      }
#line 272
      if (tmp < 0) {
#line 273
        return (-1);
      }
    } else {
      {
#line 278
      tmp___1 = quotactl((2304 << 8) | (h->qh_type & 255), (char const   *)(h->qh_quotadev),
                         (qid_t )0, (caddr_t )((void *)(& kdqinfo)));
      }
#line 278
      if (tmp___1 < 0L) {
        {
#line 280
        tmp___0 = __errno_location();
        }
#line 280
        if (*tmp___0 == 1) {
#line 281
          return (0);
        }
#line 282
        return (-1);
      }
#line 284
      h->qh_info.dqi_bgrace = (time_t )kdqinfo.dqi_bgrace;
#line 285
      h->qh_info.dqi_igrace = (time_t )kdqinfo.dqi_igrace;
#line 286
      h->qh_info.u.v2_mdqi.dqi_flags = kdqinfo.dqi_flags;
#line 287
      h->qh_info.u.v2_mdqi.dqi_qtree.dqi_blocks = kdqinfo.dqi_blocks;
#line 288
      h->qh_info.u.v2_mdqi.dqi_qtree.dqi_free_blk = kdqinfo.dqi_free_blk;
#line 289
      h->qh_info.u.v2_mdqi.dqi_qtree.dqi_free_entry = kdqinfo.dqi_free_entry;
    }
  }
#line 292
  if (h->qh_fd != -1) {
    {
#line 296
    tmp___2 = v2_read_header___0(h->qh_fd, & header);
    }
#line 296
    if (! tmp___2) {
#line 297
      return (-1);
    }
    {
#line 299
    lseek(h->qh_fd, (__off64_t )sizeof(struct v2_disk_dqheader ), 0);
#line 300
    tmp___3 = read(h->qh_fd, (void *)(& ddqinfo), sizeof(ddqinfo));
    }
#line 300
    if ((unsigned long )tmp___3 != sizeof(ddqinfo)) {
#line 301
      return (-1);
    }
#line 303
    if (! (h->qh_io_flags & 1)) {
      {
#line 304
      v2_disk2memdqinfo(& h->qh_info, & ddqinfo);
      }
    } else {
#line 306
      h->qh_info.u.v2_mdqi.dqi_qtree.dqi_blocks = ddqinfo.dqi_blocks;
    }
#line 308
    if (header.dqh_version == 0U) {
#line 309
      h->qh_info.u.v2_mdqi.dqi_qtree.dqi_entry_size = (unsigned int )sizeof(struct v2r0_disk_dqblk );
#line 310
      h->qh_info.u.v2_mdqi.dqi_qtree.dqi_ops = & v2r0_fmt_ops___0;
#line 311
      h->qh_info.dqi_max_b_limit = (uint64_t )(~ ((uint32_t )0));
#line 312
      h->qh_info.dqi_max_i_limit = (uint64_t )(~ ((uint32_t )0));
#line 313
      h->qh_info.dqi_max_b_usage = ~ ((uint64_t )0);
#line 314
      h->qh_info.dqi_max_i_usage = (uint64_t )(~ ((uint32_t )0));
    } else {
#line 316
      h->qh_info.u.v2_mdqi.dqi_qtree.dqi_entry_size = (unsigned int )sizeof(struct v2r1_disk_dqblk );
#line 317
      h->qh_info.u.v2_mdqi.dqi_qtree.dqi_ops = & v2r1_fmt_ops___0;
#line 318
      h->qh_info.dqi_max_b_limit = ~ ((uint64_t )0);
#line 319
      h->qh_info.dqi_max_i_limit = ~ ((uint64_t )0);
#line 320
      h->qh_info.dqi_max_b_usage = ~ ((uint64_t )0);
#line 321
      h->qh_info.dqi_max_i_usage = ~ ((uint64_t )0);
    }
  } else {
#line 325
    h->qh_info.u.v2_mdqi.dqi_qtree.dqi_ops = (struct qtree_fmt_operations *)((void *)0);
  }
#line 327
  return (0);
}
}
#line 333 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v2.c"
static int v2_new_io___0(struct quota_handle *h ) 
{ 
  int file_magics[2] ;
  struct v2_disk_dqheader ddqheader ;
  struct v2_disk_dqinfo ddqinfo ;
  int version___0 ;
  ssize_t tmp ;
  ssize_t tmp___0 ;

  {
#line 335
  file_magics[0] = -641720559;
#line 335
  file_magics[1] = -641722073;
#line 340
  if (h->qh_fmt == 1) {
#line 341
    version___0 = 0;
  } else
#line 342
  if (h->qh_fmt == 2) {
#line 343
    version___0 = 1;
  } else {
#line 345
    return (-1);
  }
  {
#line 348
  ddqheader.dqh_magic = (__u32 )file_magics[h->qh_type];
#line 349
  ddqheader.dqh_version = (__u32 )version___0;
#line 350
  lseek(h->qh_fd, (__off64_t )0, 0);
#line 351
  tmp = write(h->qh_fd, (void const   *)(& ddqheader), sizeof(ddqheader));
  }
#line 351
  if ((unsigned long )tmp != sizeof(ddqheader)) {
#line 352
    return (-1);
  }
#line 354
  h->qh_info.dqi_bgrace = (time_t )604800;
#line 355
  h->qh_info.dqi_igrace = (time_t )604800;
#line 356
  h->qh_info.u.v2_mdqi.dqi_flags = (uint )0;
#line 357
  h->qh_info.u.v2_mdqi.dqi_qtree.dqi_blocks = 2U;
#line 358
  h->qh_info.u.v2_mdqi.dqi_qtree.dqi_free_blk = 0U;
#line 359
  h->qh_info.u.v2_mdqi.dqi_qtree.dqi_free_entry = 0U;
#line 360
  if (version___0 == 0) {
#line 361
    h->qh_info.u.v2_mdqi.dqi_qtree.dqi_entry_size = (unsigned int )sizeof(struct v2r0_disk_dqblk );
#line 362
    h->qh_info.u.v2_mdqi.dqi_qtree.dqi_ops = & v2r0_fmt_ops___0;
#line 363
    h->qh_info.dqi_max_b_limit = (uint64_t )(~ ((uint32_t )0));
#line 364
    h->qh_info.dqi_max_i_limit = (uint64_t )(~ ((uint32_t )0));
#line 365
    h->qh_info.dqi_max_b_usage = ~ ((uint64_t )0);
#line 366
    h->qh_info.dqi_max_i_usage = (uint64_t )(~ ((uint32_t )0));
  } else
#line 367
  if (version___0 == 1) {
#line 368
    h->qh_info.u.v2_mdqi.dqi_qtree.dqi_entry_size = (unsigned int )sizeof(struct v2r1_disk_dqblk );
#line 369
    h->qh_info.u.v2_mdqi.dqi_qtree.dqi_ops = & v2r1_fmt_ops___0;
#line 370
    h->qh_info.dqi_max_b_limit = ~ ((uint64_t )0);
#line 371
    h->qh_info.dqi_max_i_limit = ~ ((uint64_t )0);
#line 372
    h->qh_info.dqi_max_b_usage = ~ ((uint64_t )0);
#line 373
    h->qh_info.dqi_max_i_usage = ~ ((uint64_t )0);
  }
  {
#line 375
  v2_mem2diskdqinfo(& ddqinfo, & h->qh_info);
#line 376
  lseek(h->qh_fd, (__off64_t )sizeof(struct v2_disk_dqheader ), 0);
#line 377
  tmp___0 = write(h->qh_fd, (void const   *)(& ddqinfo), sizeof(ddqinfo));
  }
#line 377
  if ((unsigned long )tmp___0 != sizeof(ddqinfo)) {
#line 378
    return (-1);
  }
#line 379
  return (0);
}
}
#line 385 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v2.c"
static int v2_write_info___0(struct quota_handle *h ) 
{ 
  char *tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  struct v2_kern_dqinfo kdqinfo ;
  long tmp___2 ;
  long tmp___3 ;
  struct v2_disk_dqinfo ddqinfo ;
  ssize_t tmp___4 ;

  {
#line 387
  if (h->qh_io_flags & 4) {
    {
#line 388
    tmp = gettext("Trying to write info to readonly quotafile on %s\n");
#line 388
    errstr(tmp, h->qh_quotadev);
#line 389
    tmp___0 = __errno_location();
#line 389
    *tmp___0 = 1;
    }
#line 390
    return (-1);
  }
#line 392
  if (h->qh_io_flags & 1) {
#line 393
    if (kernel_iface == 3) {
      {
#line 394
      tmp___1 = vfs_set_info(h, 3);
      }
#line 394
      if (tmp___1) {
#line 395
        return (-1);
      }
    } else {
      {
#line 400
      kdqinfo.dqi_bgrace = (unsigned int )h->qh_info.dqi_bgrace;
#line 401
      kdqinfo.dqi_igrace = (unsigned int )h->qh_info.dqi_igrace;
#line 402
      kdqinfo.dqi_flags = h->qh_info.u.v2_mdqi.dqi_flags;
#line 403
      kdqinfo.dqi_blocks = h->qh_info.u.v2_mdqi.dqi_qtree.dqi_blocks;
#line 404
      kdqinfo.dqi_free_blk = h->qh_info.u.v2_mdqi.dqi_qtree.dqi_free_blk;
#line 405
      kdqinfo.dqi_free_entry = h->qh_info.u.v2_mdqi.dqi_qtree.dqi_free_entry;
#line 406
      tmp___2 = quotactl((2816 << 8) | (h->qh_type & 255), (char const   *)(h->qh_quotadev),
                         (qid_t )0, (caddr_t )((void *)(& kdqinfo)));
      }
#line 406
      if (tmp___2 < 0L) {
#line 408
        return (-1);
      } else {
        {
#line 406
        tmp___3 = quotactl((3072 << 8) | (h->qh_type & 255), (char const   *)(h->qh_quotadev),
                           (qid_t )0, (caddr_t )((void *)(& kdqinfo)));
        }
#line 406
        if (tmp___3 < 0L) {
#line 408
          return (-1);
        }
      }
    }
  } else {
    {
#line 414
    v2_mem2diskdqinfo(& ddqinfo, & h->qh_info);
#line 415
    lseek(h->qh_fd, (__off64_t )sizeof(struct v2_disk_dqheader ), 0);
#line 416
    tmp___4 = write(h->qh_fd, (void const   *)(& ddqinfo), sizeof(ddqinfo));
    }
#line 416
    if ((unsigned long )tmp___4 != sizeof(ddqinfo)) {
#line 417
      return (-1);
    }
  }
#line 419
  return (0);
}
}
#line 426 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v2.c"
static struct dquot *v2_read_dquot___0(struct quota_handle *h , qid_t id___0 ) 
{ 
  struct dquot *dquot ;
  struct dquot *tmp ;
  int tmp___0 ;
  struct v2_kern_dqblk kdqblk ;
  long tmp___1 ;
  struct dquot *tmp___2 ;

  {
#line 428
  if (h->qh_io_flags & 1) {
    {
#line 429
    tmp = get_empty_dquot();
#line 429
    dquot = tmp;
#line 431
    dquot->dq_id = id___0;
#line 432
    dquot->dq_h = h;
#line 433
    dquot->dq_dqb.u.v2_mdqb.dqb_off = (loff_t )0;
#line 434
    memset((void *)(& dquot->dq_dqb), 0, sizeof(struct util_dqblk ));
    }
#line 435
    if (kernel_iface == 3) {
      {
#line 436
      tmp___0 = vfs_get_dquot(dquot);
      }
#line 436
      if (tmp___0 < 0) {
        {
#line 437
        free((void *)dquot);
        }
#line 438
        return ((struct dquot *)((void *)0));
      }
    } else {
      {
#line 444
      tmp___1 = quotactl((3328 << 8) | (h->qh_type & 255), (char const   *)(h->qh_quotadev),
                         id___0, (caddr_t )((void *)(& kdqblk)));
      }
#line 444
      if (tmp___1 < 0L) {
        {
#line 445
        free((void *)dquot);
        }
#line 446
        return ((struct dquot *)((void *)0));
      }
      {
#line 448
      v2_kern2utildqblk(& dquot->dq_dqb, & kdqblk);
      }
    }
#line 450
    return (dquot);
  }
  {
#line 452
  tmp___2 = qtree_read_dquot(h, id___0);
  }
#line 452
  return (tmp___2);
}
}
#line 459 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v2.c"
static int v2_commit_dquot___0(struct dquot *dquot , int flags___7 ) 
{ 
  struct util_dqblk *b ;
  char *tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  struct v2_kern_dqblk kdqblk ;
  int cmd ;
  int *tmp___2 ;
  long tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;

  {
#line 461
  b = & dquot->dq_dqb;
#line 463
  if ((dquot->dq_h)->qh_io_flags & 4) {
    {
#line 464
    tmp = gettext("Trying to write quota to readonly quotafile on %s\n");
#line 464
    errstr(tmp, (dquot->dq_h)->qh_quotadev);
#line 465
    tmp___0 = __errno_location();
#line 465
    *tmp___0 = 1;
    }
#line 466
    return (-1);
  }
#line 468
  if ((dquot->dq_h)->qh_io_flags & 1) {
#line 469
    if (kernel_iface == 3) {
      {
#line 470
      tmp___1 = vfs_set_dquot(dquot, flags___7);
      }
#line 470
      if (tmp___1 < 0) {
#line 471
        return (-1);
      }
    } else {
#line 477
      if (flags___7 == 10) {
#line 478
        cmd = 3840;
      } else
#line 479
      if (flags___7 == 5) {
#line 480
        cmd = 1792;
      } else
#line 481
      if (flags___7 & 48) {
        {
#line 482
        tmp___2 = __errno_location();
#line 482
        *tmp___2 = 22;
        }
#line 483
        return (-1);
      } else {
#line 486
        cmd = 3584;
      }
      {
#line 487
      v2_util2kerndqblk(& kdqblk, & dquot->dq_dqb);
#line 488
      tmp___3 = quotactl((cmd << 8) | ((dquot->dq_h)->qh_type & 255), (char const   *)((dquot->dq_h)->qh_quotadev),
                         dquot->dq_id, (caddr_t )((void *)(& kdqblk)));
      }
#line 488
      if (tmp___3 < 0L) {
#line 490
        return (-1);
      }
    }
#line 492
    return (0);
  }
#line 494
  if (! b->dqb_curspace) {
#line 494
    if (! b->dqb_curinodes) {
#line 494
      if (! b->dqb_bsoftlimit) {
#line 494
        if (! b->dqb_isoftlimit) {
#line 494
          if (! b->dqb_bhardlimit) {
#line 494
            if (! b->dqb_ihardlimit) {
              {
#line 496
              qtree_delete_dquot(dquot);
              }
            } else {
#line 494
              goto _L___3;
            }
          } else {
#line 494
            goto _L___3;
          }
        } else {
#line 494
          goto _L___3;
        }
      } else {
#line 494
        goto _L___3;
      }
    } else {
#line 494
      goto _L___3;
    }
  } else {
    _L___3: /* CIL Label */ 
    {
#line 498
    tmp___5 = check_dquot_range(dquot);
    }
#line 498
    if (tmp___5 < 0) {
      {
#line 499
      tmp___4 = __errno_location();
#line 499
      *tmp___4 = 34;
      }
#line 500
      return (-1);
    }
    {
#line 502
    qtree_write_dquot(dquot);
    }
  }
#line 504
  return (0);
}
}
#line 507 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v2.c"
static int v2_scan_dquots___0(struct quota_handle *h , int (*process_dquot)(struct dquot *dquot ,
                                                                            char *dqname ) ) 
{ 
  int tmp ;

  {
  {
#line 509
  tmp = qtree_scan_dquots(h, process_dquot);
  }
#line 509
  return (tmp);
}
}
#line 513 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v2.c"
static int v2_report___0(struct quota_handle *h , int verbose ) 
{ 
  struct v2_mem_dqinfo *info ;
  char *tmp ;

  {
#line 515
  if (verbose) {
    {
#line 516
    info = & h->qh_info.u.v2_mdqi;
#line 518
    tmp = gettext("Statistics:\nTotal blocks: %u\nData blocks: %u\nEntries: %u\nUsed average: %f\n");
#line 518
    printf((char const   */* __restrict  */)tmp, info->dqi_qtree.dqi_blocks, info->dqi_data_blocks,
           info->dqi_used_entries, (double )((float )info->dqi_used_entries / (float )info->dqi_data_blocks));
    }
  }
#line 522
  return (0);
}
}
#line 31 "/home/wheatley/newnew/temp/quota-4.01/bylabel.c"
static struct uuidCache_s *uuidCache___0  =    (struct uuidCache_s *)((void *)0);
#line 74 "/home/wheatley/newnew/temp/quota-4.01/bylabel.c"
static int get_label_uuid___0(char const   *device , char **label , char *uuid ) 
{ 
  int fd ;
  int rv ;
  size_t namesize ;
  struct ext2_super_block e2sb ;
  struct xfs_super_block xfsb ;
  struct reiserfs_super_block reisersb ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  __off64_t tmp___2 ;
  ssize_t tmp___3 ;
  int tmp___4 ;
  __off64_t tmp___5 ;
  ssize_t tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  __off64_t tmp___9 ;
  ssize_t tmp___10 ;

  {
  {
#line 79
  rv = 1;
#line 85
  fd = open(device, 0);
  }
#line 86
  if (fd < 0) {
#line 87
    return (rv);
  }
  {
#line 89
  tmp___9 = lseek(fd, (__off64_t )1024, 0);
  }
#line 89
  if (tmp___9 == 1024L) {
    {
#line 89
    tmp___10 = read(fd, (void *)((char *)(& e2sb)), sizeof(e2sb));
    }
#line 89
    if ((unsigned long )tmp___10 == sizeof(e2sb)) {
#line 89
      if ((uint )e2sb.s_magic[0] + ((uint )e2sb.s_magic[1] << 8) == 61267U) {
        {
#line 92
        memcpy((void */* __restrict  */)uuid, (void const   */* __restrict  */)(e2sb.s_uuid),
               sizeof(e2sb.s_uuid));
#line 93
        namesize = sizeof(e2sb.s_volume_name);
#line 94
        tmp = smalloc(namesize + 1UL);
#line 94
        *label = (char *)tmp;
#line 95
        sstrncpy(*label, (char const   *)((char *)(e2sb.s_volume_name)), namesize);
#line 96
        rv = 0;
        }
      } else {
#line 89
        goto _L___3;
      }
    } else {
#line 89
      goto _L___3;
    }
  } else {
    _L___3: /* CIL Label */ 
    {
#line 98
    tmp___5 = lseek(fd, (__off64_t )0, 0);
    }
#line 98
    if (tmp___5 == 0L) {
      {
#line 98
      tmp___6 = read(fd, (void *)((char *)(& xfsb)), sizeof(xfsb));
      }
#line 98
      if ((unsigned long )tmp___6 == sizeof(xfsb)) {
        {
#line 98
        tmp___7 = strncmp((char const   *)((char *)(& xfsb.s_magic)), "XFSB", (size_t )4);
        }
#line 98
        if (tmp___7 == 0) {
#line 98
          goto _L___0;
        } else {
          {
#line 98
          tmp___8 = strncmp((char const   *)((char *)(& xfsb.s_magic)), "BSFX", (size_t )4);
          }
#line 98
          if (tmp___8 == 0) {
            _L___0: /* CIL Label */ 
            {
#line 102
            memcpy((void */* __restrict  */)uuid, (void const   */* __restrict  */)(xfsb.s_uuid),
                   sizeof(xfsb.s_uuid));
#line 103
            namesize = sizeof(xfsb.s_fsname);
#line 104
            tmp___0 = smalloc(namesize + 1UL);
#line 104
            *label = (char *)tmp___0;
#line 105
            sstrncpy(*label, (char const   *)((char *)(xfsb.s_fsname)), namesize);
#line 106
            rv = 0;
            }
          } else {
#line 98
            goto _L___1;
          }
        }
      } else {
#line 98
        goto _L___1;
      }
    } else {
      _L___1: /* CIL Label */ 
      {
#line 108
      tmp___2 = lseek(fd, (__off64_t )65536, 0);
      }
#line 108
      if (tmp___2 == 65536L) {
        {
#line 108
        tmp___3 = read(fd, (void *)((char *)(& reisersb)), sizeof(reisersb));
        }
#line 108
        if ((unsigned long )tmp___3 == sizeof(reisersb)) {
          {
#line 108
          tmp___4 = strncmp((char const   *)((char *)(& reisersb.s_magic)), "ReIsEr2Fs",
                            (size_t )9);
          }
#line 108
          if (! tmp___4) {
            {
#line 111
            memcpy((void */* __restrict  */)uuid, (void const   */* __restrict  */)(reisersb.s_uuid),
                   sizeof(reisersb.s_uuid));
#line 112
            namesize = sizeof(reisersb.s_volume_name);
#line 113
            tmp___1 = smalloc(namesize + 1UL);
#line 113
            *label = (char *)tmp___1;
#line 114
            sstrncpy(*label, (char const   *)((char *)(reisersb.s_volume_name)), namesize);
#line 115
            rv = 0;
            }
          }
        }
      }
    }
  }
  {
#line 117
  close(fd);
  }
#line 118
  return (rv);
}
}
#line 121 "/home/wheatley/newnew/temp/quota-4.01/bylabel.c"
static void uuidcache_addentry___0(char *device , char *label , char *uuid ) 
{ 
  struct uuidCache_s *last ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 125
  if (! uuidCache___0) {
    {
#line 126
    tmp = smalloc(sizeof(*uuidCache___0));
#line 126
    uuidCache___0 = (struct uuidCache_s *)tmp;
#line 126
    last = uuidCache___0;
    }
  } else {
#line 129
    last = uuidCache___0;
    {
#line 129
    while (1) {
      while_continue: /* CIL Label */ ;
#line 129
      if (! last->next) {
#line 129
        goto while_break;
      }
#line 129
      last = last->next;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 130
    tmp___0 = smalloc(sizeof(*uuidCache___0));
#line 130
    last->next = (struct uuidCache_s *)tmp___0;
#line 131
    last = last->next;
    }
  }
  {
#line 133
  last->next = (struct uuidCache_s *)((void *)0);
#line 134
  last->device = device;
#line 135
  last->label = label;
#line 136
  memcpy((void */* __restrict  */)(last->uuid), (void const   */* __restrict  */)uuid,
         sizeof(last->uuid));
  }
#line 137
  return;
}
}
#line 144 "/home/wheatley/newnew/temp/quota-4.01/bylabel.c"
static char ptname___0[100]  ;
#line 139 "/home/wheatley/newnew/temp/quota-4.01/bylabel.c"
static void uuidcache_init___0(void) 
{ 
  char line___0[100] ;
  char *s ;
  int ma ;
  int mi ;
  int sz ;
  FILE *procpt ;
  char uuid[16] ;
  char *label ;
  char device[110] ;
  int firstPass ;
  int handleOnFirst ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  unsigned short const   **tmp___4 ;
  char *tmp___5 ;

  {
#line 151
  if (uuidCache___0) {
#line 152
    return;
  }
  {
#line 154
  procpt = fopen((char const   */* __restrict  */)"/proc/partitions", (char const   */* __restrict  */)"r");
  }
#line 155
  if (! procpt) {
#line 156
    return;
  }
#line 158
  firstPass = 1;
  {
#line 158
  while (1) {
    while_continue: /* CIL Label */ ;
#line 158
    if (! (firstPass >= 0)) {
#line 158
      goto while_break;
    }
    {
#line 159
    fseek(procpt, 0L, 0);
    }
    {
#line 161
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 161
      tmp___5 = fgets((char */* __restrict  */)(line___0), (int )sizeof(line___0),
                      (FILE */* __restrict  */)procpt);
      }
#line 161
      if (! tmp___5) {
#line 161
        goto while_break___0;
      }
      {
#line 162
      tmp = sscanf((char const   */* __restrict  */)(line___0), (char const   */* __restrict  */)" %d %d %d %[^\n ]",
                   & ma, & mi, & sz, ptname___0);
      }
#line 162
      if (tmp != 4) {
#line 163
        goto while_continue___0;
      }
#line 166
      if (sz == 1) {
#line 167
        goto while_continue___0;
      }
      {
#line 170
      tmp___0 = strncmp((char const   *)(ptname___0), "md", (size_t )2);
      }
#line 170
      if (tmp___0) {
#line 170
        tmp___1 = 0;
      } else {
#line 170
        tmp___1 = 1;
      }
#line 170
      handleOnFirst = tmp___1;
#line 171
      if (firstPass != handleOnFirst) {
#line 172
        goto while_continue___0;
      }
#line 178
      s = ptname___0;
      {
#line 178
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 178
        if (! *s) {
#line 178
          goto while_break___1;
        }
#line 178
        s ++;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 179
      tmp___4 = __ctype_b_loc();
      }
#line 179
      if ((int const   )*(*tmp___4 + (int )*(s + -1)) & 2048) {
        {
#line 189
        snprintf((char */* __restrict  */)(device), sizeof(device), (char const   */* __restrict  */)"%s/%s",
                 "/dev", ptname___0);
#line 190
        tmp___3 = get_label_uuid___0((char const   *)(device), & label, uuid);
        }
#line 190
        if (! tmp___3) {
          {
#line 191
          tmp___2 = sstrdup((char const   *)(device));
#line 191
          uuidcache_addentry___0(tmp___2, label, uuid);
          }
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 158
    firstPass --;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 196
  fclose(procpt);
  }
#line 197
  return;
}
}
#line 202 "/home/wheatley/newnew/temp/quota-4.01/bylabel.c"
static char *get_spec_by_x___0(int n , char const   *t ) 
{ 
  struct uuidCache_s *uc ;
  char *tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 206
  uuidcache_init___0();
#line 207
  uc = uuidCache___0;
  }
  {
#line 209
  while (1) {
    while_continue: /* CIL Label */ ;
#line 209
    if (! uc) {
#line 209
      goto while_break;
    }
    {
#line 211
    if (n == 1) {
#line 211
      goto case_1;
    }
#line 215
    if (n == 2) {
#line 215
      goto case_2;
    }
#line 210
    goto switch_break;
    case_1: /* CIL Label */ 
    {
#line 212
    tmp___0 = memcmp((void const   *)t, (void const   *)(uc->uuid), sizeof(uc->uuid));
    }
#line 212
    if (! tmp___0) {
      {
#line 213
      tmp = sstrdup((char const   *)uc->device);
      }
#line 213
      return (tmp);
    }
#line 214
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 216
    tmp___2 = strcmp(t, (char const   *)uc->label);
    }
#line 216
    if (! tmp___2) {
      {
#line 217
      tmp___1 = sstrdup((char const   *)uc->device);
      }
#line 217
      return (tmp___1);
    }
#line 218
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 220
    uc = uc->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 222
  return ((char *)((void *)0));
}
}
#line 225 "/home/wheatley/newnew/temp/quota-4.01/bylabel.c"
static u_char fromhex___0(char c ) 
{ 
  unsigned short const   **tmp ;
  unsigned short const   **tmp___0 ;

  {
  {
#line 227
  tmp___0 = __ctype_b_loc();
  }
#line 227
  if ((int const   )*(*tmp___0 + (int )c) & 2048) {
#line 228
    return ((u_char )((int )c - 48));
  } else {
    {
#line 229
    tmp = __ctype_b_loc();
    }
#line 229
    if ((int const   )*(*tmp + (int )c) & 512) {
#line 230
      return ((u_char )(((int )c - 97) + 10));
    } else {
#line 232
      return ((u_char )(((int )c - 65) + 10));
    }
  }
}
}
#line 235 "/home/wheatley/newnew/temp/quota-4.01/bylabel.c"
static char *get_spec_by_uuid___0(char const   *s ) 
{ 
  u_char uuid[16] ;
  int i ;
  size_t tmp ;
  unsigned short const   **tmp___0 ;
  unsigned short const   **tmp___1 ;
  u_char tmp___2 ;
  u_char tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;

  {
  {
#line 240
  tmp = strlen(s);
  }
#line 240
  if (tmp != 36UL) {
#line 241
    goto bad_uuid;
  } else
#line 240
  if ((int const   )*(s + 8) != 45) {
#line 241
    goto bad_uuid;
  } else
#line 240
  if ((int const   )*(s + 13) != 45) {
#line 241
    goto bad_uuid;
  } else
#line 240
  if ((int const   )*(s + 18) != 45) {
#line 241
    goto bad_uuid;
  } else
#line 240
  if ((int const   )*(s + 23) != 45) {
#line 241
    goto bad_uuid;
  }
#line 242
  i = 0;
  {
#line 242
  while (1) {
    while_continue: /* CIL Label */ ;
#line 242
    if (! (i < 16)) {
#line 242
      goto while_break;
    }
#line 243
    if ((int const   )*s == 45) {
#line 244
      s ++;
    }
    {
#line 245
    tmp___0 = __ctype_b_loc();
    }
#line 245
    if ((int const   )*(*tmp___0 + (int )*(s + 0)) & 4096) {
      {
#line 245
      tmp___1 = __ctype_b_loc();
      }
#line 245
      if (! ((int const   )*(*tmp___1 + (int )*(s + 1)) & 4096)) {
#line 246
        goto bad_uuid;
      }
    } else {
#line 246
      goto bad_uuid;
    }
    {
#line 247
    tmp___2 = fromhex___0((char )*(s + 0));
#line 247
    tmp___3 = fromhex___0((char )*(s + 1));
#line 247
    uuid[i] = (u_char )(((int )tmp___2 << 4) | (int )tmp___3);
#line 248
    s += 2;
#line 242
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 250
  tmp___4 = get_spec_by_x___0(1, (char const   *)((char *)(uuid)));
  }
#line 250
  return (tmp___4);
  bad_uuid: 
  {
#line 253
  tmp___5 = gettext("Found an invalid UUID: %s\n");
#line 253
  errstr(tmp___5, s);
  }
#line 254
  return ((char *)((void *)0));
}
}
#line 257 "/home/wheatley/newnew/temp/quota-4.01/bylabel.c"
static char *get_spec_by_volume_label___0(char const   *s ) 
{ 
  char *tmp ;

  {
  {
#line 259
  tmp = get_spec_by_x___0(2, s);
  }
#line 259
  return (tmp);
}
}
#line 105 "/home/wheatley/newnew/temp/quota-4.01/quotaio_generic.c"
static int scan_one_dquot___0(struct dquot *dquot , int (*get_dquot)(struct dquot * ) ) 
{ 
  int ret ;
  struct util_dqblk *dqb ;

  {
  {
#line 108
  dqb = & dquot->dq_dqb;
#line 110
  memset((void *)dqb, 0, sizeof(struct util_dqblk ));
#line 111
  ret = (*get_dquot)(dquot);
  }
#line 112
  if (ret < 0) {
#line 113
    return (ret);
  }
#line 114
  if (! dqb->dqb_bhardlimit) {
#line 114
    if (! dqb->dqb_bsoftlimit) {
#line 114
      if (! dqb->dqb_ihardlimit) {
#line 114
        if (! dqb->dqb_isoftlimit) {
#line 114
          if (! dqb->dqb_curinodes) {
#line 114
            if (! dqb->dqb_curspace) {
#line 115
              return (1);
            }
          }
        }
      }
    }
  }
#line 116
  return (0);
}
}
#line 312 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) __mode_t ( __attribute__((__leaf__)) umask)(__mode_t __mask ) ;
#line 478 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) fchown)(int __fd ,
                                                                             __uid_t __owner ,
                                                                             __gid_t __group ) ;
#line 678
extern  __attribute__((__nothrow__)) __uid_t ( __attribute__((__leaf__)) geteuid)(void) ;
#line 684
extern  __attribute__((__nothrow__)) __gid_t ( __attribute__((__leaf__)) getegid)(void) ;
#line 826
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) unlink)(char const   *__name ) ;
#line 57 "/usr/include/getopt.h"
extern char *optarg ;
#line 564 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) getenv)(char const   *__name ) ;
#line 623
extern int ( __attribute__((__nonnull__(1))) mkstemp)(char *__template )  __asm__("mkstemp64")  ;
#line 173 "/usr/include/getopt.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getopt_long)(int ___argc ,
                                                                                  char * const  *___argv ,
                                                                                  char const   *__shortopts ,
                                                                                  struct option  const  *__longopts ,
                                                                                  int *__longind ) ;
#line 6 "/home/wheatley/newnew/temp/quota-4.01/quotaops.h"
struct dquot *getprivs(qid_t id___0 , struct quota_handle **handles , int quiet ) ;
#line 7
int putprivs(struct dquot *qlist , int flags___7 ) ;
#line 8
int editprivs(char *tmpfile___0 ) ;
#line 9
int writeprivs(struct dquot *qlist , int outfd , char *name , int quotatype___0 ) ;
#line 10
int readprivs(struct dquot *qlist , int infd ) ;
#line 11
int writeindividualtimes(struct dquot *qlist , int outfd , char *name , int quotatype___0 ) ;
#line 12
int readindividualtimes(struct dquot *qlist , int infd ) ;
#line 13
int writetimes(struct quota_handle **handles , int outfd ) ;
#line 14
int readtimes(struct quota_handle **handles , int infd ) ;
#line 15
void freeprivs(struct dquot *qlist ) ;
#line 16
void update_grace_times(struct dquot *q ) ;
#line 69 "/home/wheatley/newnew/temp/quota-4.01/edquota.c"
static int flags___0  ;
#line 69 "/home/wheatley/newnew/temp/quota-4.01/edquota.c"
static int quotatype  ;
#line 70 "/home/wheatley/newnew/temp/quota-4.01/edquota.c"
static int fmt___0  =    -1;
#line 71 "/home/wheatley/newnew/temp/quota-4.01/edquota.c"
static char *protoname  ;
#line 72 "/home/wheatley/newnew/temp/quota-4.01/edquota.c"
static char *dirname  ;
#line 74 "/home/wheatley/newnew/temp/quota-4.01/edquota.c"
static void usage___0(void) 
{ 
  char *rpcflag ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 79
  rpcflag = (char *)"";
#line 81
  tmp = gettext("Usage:\n\tedquota %1$s[-u] [-F formatname] [-p username] [-f filesystem] username ...\n\tedquota %1$s-g [-F formatname] [-p groupname] [-f filesystem] groupname ...\n\tedquota [-u|g] [-F formatname] [-f filesystem] -t\n\tedquota [-u|g] [-F formatname] [-f filesystem] -T username|groupname ...\n");
#line 81
  errstr(tmp, rpcflag);
#line 85
  tmp___0 = gettext("\n-u, --user                    edit user data\n-g, --group                   edit group data\n");
#line 85
  fputs((char const   */* __restrict  */)tmp___0, (FILE */* __restrict  */)stderr);
#line 92
  tmp___1 = gettext("-F, --format=formatname       edit quotas of a specific format\n-p, --prototype=name          copy data from a prototype user/group\n    --always-resolve          always try to resolve name, even if it is\n                              composed only of digits\n-f, --filesystem=filesystem   edit data only on a specific filesystem\n-t, --edit-period             edit grace period\n-T, --edit-times              edit grace time of a user/group\n-h, --help                    display this help text and exit\n-V, --version                 display version information and exit\n\n");
#line 92
  fputs((char const   */* __restrict  */)tmp___1, (FILE */* __restrict  */)stderr);
#line 101
  tmp___2 = gettext("Bugs to: %s\n");
#line 101
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___2,
          "jack@suse.cz");
#line 102
  exit(1);
  }
}
}
#line 105 "/home/wheatley/newnew/temp/quota-4.01/edquota.c"
static int parse_options(int argc , char **argv ) 
{ 
  int ret ;
  struct option long_opts[11] ;
  char *tmp ;
  char *tmp___0 ;

  {
#line 108
  long_opts[0].name = "help";
#line 108
  long_opts[0].has_arg = 0;
#line 108
  long_opts[0].flag = (int *)((void *)0);
#line 108
  long_opts[0].val = 'h';
#line 108
  long_opts[1].name = "version";
#line 108
  long_opts[1].has_arg = 0;
#line 108
  long_opts[1].flag = (int *)((void *)0);
#line 108
  long_opts[1].val = 'V';
#line 108
  long_opts[2].name = "prototype";
#line 108
  long_opts[2].has_arg = 1;
#line 108
  long_opts[2].flag = (int *)((void *)0);
#line 108
  long_opts[2].val = 'p';
#line 108
  long_opts[3].name = "user";
#line 108
  long_opts[3].has_arg = 0;
#line 108
  long_opts[3].flag = (int *)((void *)0);
#line 108
  long_opts[3].val = 'u';
#line 108
  long_opts[4].name = "group";
#line 108
  long_opts[4].has_arg = 0;
#line 108
  long_opts[4].flag = (int *)((void *)0);
#line 108
  long_opts[4].val = 'g';
#line 108
  long_opts[5].name = "format";
#line 108
  long_opts[5].has_arg = 1;
#line 108
  long_opts[5].flag = (int *)((void *)0);
#line 108
  long_opts[5].val = 'F';
#line 108
  long_opts[6].name = "filesystem";
#line 108
  long_opts[6].has_arg = 1;
#line 108
  long_opts[6].flag = (int *)((void *)0);
#line 108
  long_opts[6].val = 'f';
#line 108
  long_opts[7].name = "always-resolve";
#line 108
  long_opts[7].has_arg = 0;
#line 108
  long_opts[7].flag = (int *)((void *)0);
#line 108
  long_opts[7].val = 256;
#line 108
  long_opts[8].name = "edit-period";
#line 108
  long_opts[8].has_arg = 0;
#line 108
  long_opts[8].flag = (int *)((void *)0);
#line 108
  long_opts[8].val = 't';
#line 108
  long_opts[9].name = "edit-times";
#line 108
  long_opts[9].has_arg = 0;
#line 108
  long_opts[9].flag = (int *)((void *)0);
#line 108
  long_opts[9].val = 'T';
#line 108
  long_opts[10].name = (char const   *)((void *)0);
#line 108
  long_opts[10].has_arg = 0;
#line 108
  long_opts[10].flag = (int *)((void *)0);
#line 108
  long_opts[10].val = 0;
#line 126
  if (argc < 2) {
    {
#line 127
    usage___0();
    }
  }
#line 129
  quotatype = 0;
  {
#line 133
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 133
    ret = getopt_long(argc, (char * const  *)argv, "ughtTVp:F:f:", (struct option  const  *)(long_opts),
                      (int *)((void *)0));
    }
#line 133
    if (! (ret != -1)) {
#line 133
      goto while_break;
    }
    {
#line 136
    if (ret == 112) {
#line 136
      goto case_112;
    }
#line 139
    if (ret == 103) {
#line 139
      goto case_103;
    }
#line 151
    if (ret == 117) {
#line 151
      goto case_117;
    }
#line 154
    if (ret == 116) {
#line 154
      goto case_116;
    }
#line 157
    if (ret == 84) {
#line 157
      goto case_84;
    }
#line 160
    if (ret == 70) {
#line 160
      goto case_70;
    }
#line 164
    if (ret == 102) {
#line 164
      goto case_102;
    }
#line 167
    if (ret == 256) {
#line 167
      goto case_256;
    }
#line 170
    if (ret == 86) {
#line 170
      goto case_86;
    }
#line 174
    goto switch_default;
    case_112: /* CIL Label */ 
#line 137
    protoname = optarg;
#line 138
    goto switch_break;
    case_103: /* CIL Label */ 
#line 140
    quotatype = 1;
#line 141
    goto switch_break;
    case_117: /* CIL Label */ 
#line 152
    quotatype = 0;
#line 153
    goto switch_break;
    case_116: /* CIL Label */ 
#line 155
    flags___0 |= 1;
#line 156
    goto switch_break;
    case_84: /* CIL Label */ 
#line 158
    flags___0 |= 2;
#line 159
    goto switch_break;
    case_70: /* CIL Label */ 
    {
#line 161
    fmt___0 = name2fmt(optarg);
    }
#line 161
    if (fmt___0 == -1) {
      {
#line 162
      exit(1);
      }
    }
#line 163
    goto switch_break;
    case_102: /* CIL Label */ 
#line 165
    dirname = optarg;
#line 166
    goto switch_break;
    case_256: /* CIL Label */ 
#line 168
    flags___0 |= 8;
#line 169
    goto switch_break;
    case_86: /* CIL Label */ 
    {
#line 171
    version();
#line 172
    exit(0);
    }
    switch_default: /* CIL Label */ 
    {
#line 175
    usage___0();
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 178
  argc -= optind;
#line 180
  if (flags___0 & 1) {
#line 180
    if (argc != 0) {
      {
#line 181
      usage___0();
      }
    } else {
#line 180
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 180
  if (flags___0 & 2) {
#line 180
    if (argc < 1) {
      {
#line 181
      usage___0();
      }
    }
  }
#line 182
  if (flags___0 & 3) {
#line 182
    if (protoname) {
      {
#line 183
      tmp = gettext("Prototype name does not make sense when editing grace period or times.\n");
#line 183
      errstr(tmp);
#line 184
      usage___0();
      }
    }
  }
#line 186
  if (flags___0 & 4) {
#line 186
    if (flags___0 & 3) {
      {
#line 187
      tmp___0 = gettext("Cannot change grace times over RPC protocol.\n");
#line 187
      errstr(tmp___0);
#line 188
      usage___0();
      }
    }
  }
#line 190
  return (optind);
}
}
#line 193 "/home/wheatley/newnew/temp/quota-4.01/edquota.c"
static void copy_prototype(int argc , char **argv , struct quota_handle **handles ) 
{ 
  int ret ;
  int protoid___0 ;
  int id___0 ;
  struct dquot *protoprivs ;
  struct dquot *curprivs ;
  struct dquot *pprivs ;
  struct dquot *cprivs ;
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  {
#line 198
  ret = 0;
#line 199
  protoid___0 = name2id(protoname, quotatype, ! (! (flags___0 & 8)), (int *)((void *)0));
#line 200
  protoprivs = getprivs((qid_t )protoid___0, handles, 0);
  }
  {
#line 201
  while (1) {
    while_continue: /* CIL Label */ ;
#line 201
    tmp___3 = argc;
#line 201
    argc --;
#line 201
    if (! (tmp___3 > 0)) {
#line 201
      goto while_break;
    }
    {
#line 202
    id___0 = name2id(*argv, quotatype, ! (! (flags___0 & 8)), (int *)((void *)0));
#line 203
    curprivs = getprivs((qid_t )id___0, handles, 0);
    }
#line 204
    if (! curprivs) {
      {
#line 205
      tmp = gettext("Cannot get quota information for user %s\n");
#line 205
      die(1, tmp, *argv);
      }
    }
#line 206
    argv ++;
#line 208
    pprivs = protoprivs;
#line 208
    cprivs = curprivs;
    {
#line 208
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 208
      if (pprivs) {
#line 208
        if (! cprivs) {
#line 208
          goto while_break___0;
        }
      } else {
#line 208
        goto while_break___0;
      }
      {
#line 210
      tmp___1 = devcmp_handles(pprivs->dq_h, cprivs->dq_h);
      }
#line 210
      if (! tmp___1) {
        {
#line 211
        tmp___0 = gettext("fsname mismatch\n");
#line 211
        errstr(tmp___0);
        }
#line 212
        goto __Cont;
      }
      {
#line 214
      cprivs->dq_dqb.dqb_bsoftlimit = pprivs->dq_dqb.dqb_bsoftlimit;
#line 216
      cprivs->dq_dqb.dqb_bhardlimit = pprivs->dq_dqb.dqb_bhardlimit;
#line 218
      cprivs->dq_dqb.dqb_isoftlimit = pprivs->dq_dqb.dqb_isoftlimit;
#line 220
      cprivs->dq_dqb.dqb_ihardlimit = pprivs->dq_dqb.dqb_ihardlimit;
#line 222
      update_grace_times(cprivs);
      }
      __Cont: /* CIL Label */ 
#line 208
      pprivs = pprivs->dq_next;
#line 208
      cprivs = cprivs->dq_next;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 224
    tmp___2 = putprivs(curprivs, 5);
    }
#line 224
    if (tmp___2 == -1) {
#line 225
      ret = -1;
    }
    {
#line 226
    freeprivs(curprivs);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 228
  tmp___4 = dispose_handle_list(handles);
  }
#line 228
  if (tmp___4 == -1) {
#line 229
    ret = -1;
  }
  {
#line 230
  freeprivs(protoprivs);
  }
#line 231
  if (ret) {
#line 231
    tmp___5 = 1;
  } else {
#line 231
    tmp___5 = 0;
  }
  {
#line 231
  exit(tmp___5);
  }
}
}
#line 50 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v1.c"
static int v1_check_file___0(int fd , int type , int fmt___7 ) ;
#line 51
static int v1_init_io___0(struct quota_handle *h ) ;
#line 52
static int v1_new_io___0(struct quota_handle *h ) ;
#line 53
static int v1_write_info___0(struct quota_handle *h ) ;
#line 54
static struct dquot *v1_read_dquot___0(struct quota_handle *h , qid_t id___0 ) ;
#line 55
static int v1_commit_dquot___0(struct dquot *dquot , int flags___7 ) ;
#line 56
static int v1_scan_dquots___0(struct quota_handle *h , int (*process_dquot)(struct dquot *dquot ,
                                                                            char *dqname ) ) ;
#line 127 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v1.c"
static int v1_check_file___0(int fd , int type , int fmt___7 ) 
{ 
  struct stat st ;
  int tmp ;

  {
  {
#line 131
  tmp = fstat(fd, & st);
  }
#line 131
  if (tmp < 0) {
#line 132
    return (0);
  }
#line 133
  if (! st.st_size) {
#line 134
    return (0);
  } else
#line 133
  if ((unsigned long )st.st_size % sizeof(struct v1_disk_dqblk )) {
#line 134
    return (0);
  }
#line 135
  return (1);
}
}
#line 141 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v1.c"
static int v1_init_io___0(struct quota_handle *h ) 
{ 
  int tmp ;
  struct v1_kern_dqblk kdqblk ;
  time_t tmp___0 ;
  int *tmp___1 ;
  long tmp___2 ;
  struct v1_disk_dqblk ddqblk ;
  ssize_t tmp___3 ;

  {
#line 143
  if (h->qh_io_flags & 1) {
#line 144
    if (kernel_iface == 3) {
      {
#line 145
      tmp = vfs_get_info(h);
      }
#line 145
      if (tmp < 0) {
#line 146
        return (-1);
      }
    } else {
      {
#line 151
      tmp___2 = quotactl((768 << 8) | (h->qh_type & 255), (char const   *)(h->qh_quotadev),
                         (qid_t )0, (caddr_t )((void *)(& kdqblk)));
      }
#line 151
      if (tmp___2 < 0L) {
        {
#line 152
        tmp___1 = __errno_location();
        }
#line 152
        if (*tmp___1 == 1) {
#line 153
          tmp___0 = (time_t )0;
#line 153
          h->qh_info.dqi_igrace = tmp___0;
#line 153
          h->qh_info.dqi_bgrace = tmp___0;
        } else {
#line 156
          return (-1);
        }
      } else {
#line 159
        h->qh_info.dqi_bgrace = kdqblk.dqb_btime;
#line 160
        h->qh_info.dqi_igrace = kdqblk.dqb_itime;
      }
    }
  } else {
    {
#line 167
    lseek(h->qh_fd, (__off64_t )0, 0);
#line 168
    tmp___3 = read(h->qh_fd, (void *)(& ddqblk), sizeof(ddqblk));
    }
#line 168
    if ((unsigned long )tmp___3 != sizeof(ddqblk)) {
#line 169
      return (-1);
    }
#line 170
    h->qh_info.dqi_bgrace = ddqblk.dqb_btime;
#line 171
    h->qh_info.dqi_igrace = ddqblk.dqb_itime;
  }
#line 173
  if (! h->qh_info.dqi_bgrace) {
#line 174
    h->qh_info.dqi_bgrace = (time_t )604800;
  }
#line 175
  if (! h->qh_info.dqi_igrace) {
#line 176
    h->qh_info.dqi_igrace = (time_t )604800;
  }
#line 177
  h->qh_info.dqi_max_b_limit = (uint64_t )(~ ((uint32_t )0));
#line 178
  h->qh_info.dqi_max_i_limit = (uint64_t )(~ ((uint32_t )0));
#line 179
  h->qh_info.dqi_max_b_usage = 4294967295UL << 10;
#line 180
  h->qh_info.dqi_max_i_usage = (uint64_t )(~ ((uint32_t )0));
#line 182
  return (0);
}
}
#line 188 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v1.c"
static int v1_new_io___0(struct quota_handle *h ) 
{ 
  struct v1_disk_dqblk ddqblk ;
  ssize_t tmp ;

  {
  {
#line 193
  memset((void *)(& ddqblk), 0, sizeof(ddqblk));
#line 194
  ddqblk.dqb_btime = (time_t )604800;
#line 195
  ddqblk.dqb_itime = (time_t )604800;
#line 196
  h->qh_info.dqi_bgrace = (time_t )604800;
#line 197
  h->qh_info.dqi_igrace = (time_t )604800;
#line 198
  h->qh_info.dqi_max_b_limit = (uint64_t )(~ ((uint32_t )0));
#line 199
  h->qh_info.dqi_max_i_limit = (uint64_t )(~ ((uint32_t )0));
#line 200
  h->qh_info.dqi_max_b_usage = 4294967295UL << 10;
#line 201
  h->qh_info.dqi_max_i_usage = (uint64_t )(~ ((uint32_t )0));
#line 202
  lseek(h->qh_fd, (__off64_t )0, 0);
#line 203
  tmp = write(h->qh_fd, (void const   *)(& ddqblk), sizeof(ddqblk));
  }
#line 203
  if ((unsigned long )tmp != sizeof(ddqblk)) {
#line 204
    return (-1);
  }
#line 205
  return (0);
}
}
#line 211 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v1.c"
static int v1_write_info___0(struct quota_handle *h ) 
{ 
  char *tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  struct v1_kern_dqblk kdqblk ;
  long tmp___2 ;
  long tmp___3 ;
  struct v1_disk_dqblk ddqblk ;
  ssize_t tmp___4 ;
  ssize_t tmp___5 ;

  {
#line 213
  if (h->qh_io_flags & 4) {
    {
#line 214
    tmp = gettext("Trying to write info to readonly quotafile on %s.\n");
#line 214
    errstr(tmp, h->qh_quotadev);
#line 215
    tmp___0 = __errno_location();
#line 215
    *tmp___0 = 1;
    }
#line 216
    return (-1);
  }
#line 218
  if (h->qh_io_flags & 1) {
#line 219
    if (kernel_iface == 3) {
      {
#line 220
      tmp___1 = vfs_set_info(h, 3);
      }
#line 220
      if (tmp___1 < 0) {
#line 221
        return (-1);
      }
    } else {
      {
#line 226
      tmp___2 = quotactl((768 << 8) | (h->qh_type & 255), (char const   *)(h->qh_quotadev),
                         (qid_t )0, (caddr_t )((void *)(& kdqblk)));
      }
#line 226
      if (tmp___2 < 0L) {
#line 227
        return (-1);
      }
      {
#line 228
      kdqblk.dqb_btime = h->qh_info.dqi_bgrace;
#line 229
      kdqblk.dqb_itime = h->qh_info.dqi_igrace;
#line 230
      tmp___3 = quotactl((1024 << 8) | (h->qh_type & 255), (char const   *)(h->qh_quotadev),
                         (qid_t )0, (caddr_t )((void *)(& kdqblk)));
      }
#line 230
      if (tmp___3 < 0L) {
#line 231
        return (-1);
      }
    }
  } else {
    {
#line 237
    lseek(h->qh_fd, (__off64_t )0, 0);
#line 238
    tmp___4 = read(h->qh_fd, (void *)(& ddqblk), sizeof(ddqblk));
    }
#line 238
    if ((unsigned long )tmp___4 != sizeof(ddqblk)) {
#line 239
      return (-1);
    }
    {
#line 240
    ddqblk.dqb_btime = h->qh_info.dqi_bgrace;
#line 241
    ddqblk.dqb_itime = h->qh_info.dqi_igrace;
#line 242
    lseek(h->qh_fd, (__off64_t )0, 0);
#line 243
    tmp___5 = write(h->qh_fd, (void const   *)(& ddqblk), sizeof(ddqblk));
    }
#line 243
    if ((unsigned long )tmp___5 != sizeof(ddqblk)) {
#line 244
      return (-1);
    }
  }
#line 246
  return (0);
}
}
#line 253 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v1.c"
static struct dquot *v1_read_dquot___0(struct quota_handle *h , qid_t id___0 ) 
{ 
  struct v1_disk_dqblk ddqblk ;
  struct dquot *dquot ;
  struct dquot *tmp ;
  int tmp___0 ;
  struct v1_kern_dqblk kdqblk ;
  long tmp___1 ;
  ssize_t tmp___2 ;

  {
  {
#line 256
  tmp = get_empty_dquot();
#line 256
  dquot = tmp;
#line 258
  dquot->dq_id = id___0;
#line 259
  dquot->dq_h = h;
  }
#line 260
  if (h->qh_io_flags & 1) {
#line 261
    if (kernel_iface == 3) {
      {
#line 262
      tmp___0 = vfs_get_dquot(dquot);
      }
#line 262
      if (tmp___0 < 0) {
        {
#line 263
        free((void *)dquot);
        }
#line 264
        return ((struct dquot *)((void *)0));
      }
    } else {
      {
#line 270
      tmp___1 = quotactl((768 << 8) | (h->qh_type & 255), (char const   *)(h->qh_quotadev),
                         id___0, (caddr_t )((void *)(& kdqblk)));
      }
#line 270
      if (tmp___1 < 0L) {
        {
#line 271
        free((void *)dquot);
        }
#line 272
        return ((struct dquot *)((void *)0));
      }
      {
#line 274
      v1_kern2utildqblk(& dquot->dq_dqb, & kdqblk);
      }
    }
  } else {
    {
#line 278
    lseek(h->qh_fd, (loff_t )((unsigned long )id___0 * sizeof(struct v1_disk_dqblk )),
          0);
#line 279
    tmp___2 = read(h->qh_fd, (void *)(& ddqblk), sizeof(ddqblk));
    }
    {
#line 280
    if (tmp___2 == 0L) {
#line 280
      goto case_0;
    }
#line 287
    if (tmp___2 == (ssize_t )sizeof(struct v1_disk_dqblk )) {
#line 287
      goto case_exp;
    }
#line 290
    goto switch_default;
    case_0: /* CIL Label */ 
    {
#line 285
    memset((void *)(& dquot->dq_dqb), 0, sizeof(struct util_dqblk ));
    }
#line 286
    goto switch_break;
    case_exp: /* CIL Label */ 
    {
#line 288
    v1_disk2memdqblk(& dquot->dq_dqb, & ddqblk);
    }
#line 289
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 291
    free((void *)dquot);
    }
#line 292
    return ((struct dquot *)((void *)0));
    switch_break: /* CIL Label */ ;
    }
  }
#line 295
  return (dquot);
}
}
#line 302 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v1.c"
static int v1_commit_dquot___0(struct dquot *dquot , int flags___7 ) 
{ 
  struct v1_disk_dqblk ddqblk ;
  struct quota_handle *h ;
  char *tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  struct v1_kern_dqblk kdqblk ;
  int cmd ;
  int *tmp___2 ;
  long tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;
  ssize_t tmp___6 ;

  {
#line 305
  h = dquot->dq_h;
#line 307
  if (h->qh_io_flags & 4) {
    {
#line 308
    tmp = gettext("Trying to write quota to readonly quotafile on %s\n");
#line 308
    errstr(tmp, h->qh_quotadev);
#line 309
    tmp___0 = __errno_location();
#line 309
    *tmp___0 = 1;
    }
#line 310
    return (-1);
  }
#line 312
  if (h->qh_io_flags & 1) {
#line 313
    if (kernel_iface == 3) {
      {
#line 314
      tmp___1 = vfs_set_dquot(dquot, flags___7);
      }
#line 314
      if (tmp___1 < 0) {
#line 315
        return (-1);
      }
    } else {
#line 321
      if (flags___7 == 10) {
#line 322
        cmd = 1280;
      } else
#line 323
      if (flags___7 == 5) {
#line 324
        cmd = 1792;
      } else
#line 325
      if (flags___7 & 48) {
        {
#line 326
        tmp___2 = __errno_location();
#line 326
        *tmp___2 = 22;
        }
#line 327
        return (-1);
      } else {
#line 330
        cmd = 1024;
      }
      {
#line 331
      v1_util2kerndqblk(& kdqblk, & dquot->dq_dqb);
#line 332
      tmp___3 = quotactl((cmd << 8) | (h->qh_type & 255), (char const   *)(h->qh_quotadev),
                         dquot->dq_id, (caddr_t )((void *)(& kdqblk)));
      }
#line 332
      if (tmp___3 < 0L) {
#line 334
        return (-1);
      }
    }
  } else {
    {
#line 338
    tmp___5 = check_dquot_range(dquot);
    }
#line 338
    if (tmp___5 < 0) {
      {
#line 339
      tmp___4 = __errno_location();
#line 339
      *tmp___4 = 34;
      }
#line 340
      return (-1);
    }
    {
#line 342
    v1_mem2diskdqblk(& ddqblk, & dquot->dq_dqb);
#line 343
    lseek(h->qh_fd, (loff_t )((unsigned long )dquot->dq_id * sizeof(struct v1_disk_dqblk )),
          0);
#line 344
    tmp___6 = write(h->qh_fd, (void const   *)(& ddqblk), sizeof(ddqblk));
    }
#line 344
    if ((unsigned long )tmp___6 != sizeof(ddqblk)) {
#line 345
      return (-1);
    }
  }
#line 347
  return (0);
}
}
#line 355 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v1.c"
static int v1_scan_dquots___0(struct quota_handle *h , int (*process_dquot)(struct dquot *dquot ,
                                                                            char *dqname ) ) 
{ 
  int rd ;
  int scanbufpos ;
  int scanbufsize ;
  char scanbuf[sizeof(struct v1_disk_dqblk ) * 256UL] ;
  struct v1_disk_dqblk *ddqblk ;
  struct dquot *dquot ;
  struct dquot *tmp ;
  qid_t id___0 ;
  ssize_t tmp___0 ;

  {
  {
#line 357
  scanbufpos = 0;
#line 357
  scanbufsize = 0;
#line 360
  tmp = get_empty_dquot();
#line 360
  dquot = tmp;
#line 361
  id___0 = (qid_t )0;
#line 363
  memset((void *)dquot, 0, sizeof(*dquot));
#line 364
  dquot->dq_h = h;
#line 365
  lseek(h->qh_fd, (__off64_t )0, 0);
#line 366
  id___0 = (qid_t )0;
  }
  {
#line 366
  while (1) {
    while_continue: /* CIL Label */ ;
#line 367
    if (scanbufpos >= scanbufsize) {
      {
#line 368
      tmp___0 = read(h->qh_fd, (void *)(scanbuf), sizeof(scanbuf));
#line 368
      rd = (int )tmp___0;
      }
#line 369
      if (rd < 0) {
#line 370
        goto out_err;
      } else
#line 369
      if ((unsigned long )rd % sizeof(struct v1_disk_dqblk )) {
#line 370
        goto out_err;
      }
#line 371
      if (! rd) {
#line 372
        goto while_break;
      }
#line 373
      scanbufpos = 0;
#line 374
      scanbufsize = (int )((unsigned long )rd / sizeof(struct v1_disk_dqblk ));
    }
#line 376
    ddqblk = (struct v1_disk_dqblk *)(scanbuf) + scanbufpos;
#line 377
    if ((((long )(((((ddqblk->dqb_ihardlimit | ddqblk->dqb_isoftlimit) | ddqblk->dqb_bhardlimit) | ddqblk->dqb_bsoftlimit) | ddqblk->dqb_curblocks) | ddqblk->dqb_curinodes) | ddqblk->dqb_itime) | ddqblk->dqb_btime) == 0L) {
#line 381
      goto __Cont;
    }
    {
#line 382
    v1_disk2memdqblk(& dquot->dq_dqb, ddqblk);
#line 383
    dquot->dq_id = id___0;
#line 384
    rd = (*process_dquot)(dquot, (char *)((void *)0));
    }
#line 384
    if (rd < 0) {
      {
#line 385
      free((void *)dquot);
      }
#line 386
      return (rd);
    }
    __Cont: /* CIL Label */ 
#line 366
    id___0 ++;
#line 366
    scanbufpos ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 389
  if (! rd) {
    {
#line 390
    free((void *)dquot);
    }
#line 391
    return (0);
  }
  out_err: 
  {
#line 394
  free((void *)dquot);
  }
#line 395
  return (-1);
}
}
#line 27 "/home/wheatley/newnew/temp/quota-4.01/quotaio_xfs.c"
static int xfs_init_io___0(struct quota_handle *h ) ;
#line 28
static int xfs_write_info___0(struct quota_handle *h ) ;
#line 29
static struct dquot *xfs_read_dquot___0(struct quota_handle *h , qid_t id___0 ) ;
#line 30
static int xfs_commit_dquot___0(struct dquot *dquot , int flags___7 ) ;
#line 31
static int xfs_scan_dquots___0(struct quota_handle *h , int (*process_dquot)(struct dquot *dquot ,
                                                                             char *dqname ) ) ;
#line 32
static int xfs_report___0(struct quota_handle *h , int verbose ) ;
#line 77 "/home/wheatley/newnew/temp/quota-4.01/quotaio_xfs.c"
static int xfs_init_io___0(struct quota_handle *h ) 
{ 
  struct fs_quota_stat info ;
  int qcmd ;
  long tmp ;

  {
  {
#line 82
  qcmd = ((88 << 8) + 5) << 8;
#line 83
  memset((void *)(& info), 0, sizeof(struct fs_quota_stat ));
#line 84
  tmp = quotactl(qcmd, (char const   *)(h->qh_quotadev), (qid_t )0, (caddr_t )((void *)(& info)));
  }
#line 84
  if (tmp < 0L) {
#line 85
    return (-1);
  }
#line 86
  h->qh_info.dqi_bgrace = (time_t )info.qs_btimelimit;
#line 87
  h->qh_info.dqi_igrace = (time_t )info.qs_itimelimit;
#line 88
  h->qh_info.u.xfs_mdqi = info;
#line 89
  return (0);
}
}
#line 95 "/home/wheatley/newnew/temp/quota-4.01/quotaio_xfs.c"
static int xfs_write_info___0(struct quota_handle *h ) 
{ 
  struct fs_disk_quota xdqblk ;
  int qcmd ;
  long tmp ;

  {
#line 100
  if (h->qh_type == 0) {
#line 100
    if (! ((int )h->qh_info.u.xfs_mdqi.qs_flags & 1)) {
#line 100
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 100
  if (h->qh_type == 1) {
#line 100
    if (! ((int )h->qh_info.u.xfs_mdqi.qs_flags & (1 << 2))) {
#line 101
      return (0);
    }
  } else {
#line 101
    return (0);
  }
  {
#line 103
  memset((void *)(& xdqblk), 0, sizeof(struct fs_disk_quota ));
#line 105
  xdqblk.d_btimer = (__s32 )h->qh_info.dqi_bgrace;
#line 106
  xdqblk.d_itimer = (__s32 )h->qh_info.dqi_igrace;
#line 107
  xdqblk.d_fieldmask = (__u16 )((int )xdqblk.d_fieldmask | (((1 << 6) | (1 << 7)) | (1 << 8)));
#line 108
  qcmd = (((88 << 8) + 4) << 8) | (h->qh_type & 255);
#line 109
  tmp = quotactl(qcmd, (char const   *)(h->qh_quotadev), (qid_t )0, (caddr_t )((void *)(& xdqblk)));
  }
#line 109
  if (tmp < 0L) {
#line 110
    return (-1);
  }
#line 111
  return (0);
}
}
#line 117 "/home/wheatley/newnew/temp/quota-4.01/quotaio_xfs.c"
static struct dquot *xfs_read_dquot___0(struct quota_handle *h , qid_t id___0 ) 
{ 
  struct dquot *dquot ;
  struct dquot *tmp ;
  struct fs_disk_quota xdqblk ;
  int qcmd ;
  long tmp___0 ;

  {
  {
#line 119
  tmp = get_empty_dquot();
#line 119
  dquot = tmp;
#line 123
  dquot->dq_id = id___0;
#line 124
  dquot->dq_h = h;
  }
#line 126
  if (h->qh_type == 0) {
#line 126
    if (! ((int )h->qh_info.u.xfs_mdqi.qs_flags & 1)) {
#line 126
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 126
  if (h->qh_type == 1) {
#line 126
    if (! ((int )h->qh_info.u.xfs_mdqi.qs_flags & (1 << 2))) {
#line 127
      return (dquot);
    }
  } else {
#line 127
    return (dquot);
  }
  {
#line 129
  qcmd = (((88 << 8) + 3) << 8) | (h->qh_type & 255);
#line 130
  tmp___0 = quotactl(qcmd, (char const   *)(h->qh_quotadev), id___0, (caddr_t )((void *)(& xdqblk)));
  }
#line 130
  if (! (tmp___0 < 0L)) {
    {
#line 134
    xfs_kern2utildqblk(& dquot->dq_dqb, & xdqblk);
    }
  }
#line 136
  return (dquot);
}
}
#line 142 "/home/wheatley/newnew/temp/quota-4.01/quotaio_xfs.c"
static int xfs_commit_dquot___0(struct dquot *dquot , int flags___7 ) 
{ 
  struct quota_handle *h ;
  struct fs_disk_quota xdqblk ;
  qid_t id___0 ;
  int qcmd ;
  int tmp ;
  int tmp___0 ;
  long tmp___1 ;

  {
#line 144
  h = dquot->dq_h;
#line 146
  id___0 = dquot->dq_id;
#line 149
  if (h->qh_type == 0) {
#line 149
    if (! ((int )h->qh_info.u.xfs_mdqi.qs_flags & 1)) {
#line 149
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 149
  if (h->qh_type == 1) {
#line 149
    if (! ((int )h->qh_info.u.xfs_mdqi.qs_flags & (1 << 2))) {
#line 150
      return (0);
    }
  } else {
#line 150
    return (0);
  }
  {
#line 152
  xfs_util2kerndqblk(& xdqblk, & dquot->dq_dqb);
  }
#line 153
  if (h->qh_type == 0) {
#line 153
    if ((int )h->qh_info.u.xfs_mdqi.qs_flags & 1) {
#line 153
      tmp = 1;
    } else {
#line 153
      tmp = 1 << 2;
    }
  } else {
#line 153
    tmp = 1 << 2;
  }
  {
#line 153
  xdqblk.d_flags = (__s8 )((int )xdqblk.d_flags | tmp);
#line 154
  xdqblk.d_id = id___0;
#line 155
  tmp___0 = strcmp((char const   *)(h->qh_fstype), "gfs2");
  }
#line 155
  if (tmp___0 == 0) {
#line 156
    if (flags___7 & 5) {
#line 157
      xdqblk.d_fieldmask = (__u16 )((int )xdqblk.d_fieldmask | ((1 << 2) | (1 << 3)));
    }
#line 158
    if (flags___7 & 10) {
#line 159
      xdqblk.d_fieldmask = (__u16 )((int )xdqblk.d_fieldmask | (1 << 12));
    }
  } else {
#line 161
    xdqblk.d_fieldmask = (__u16 )((int )xdqblk.d_fieldmask | (((((1 | (1 << 1)) | (1 << 2)) | (1 << 3)) | (1 << 4)) | (1 << 5)));
  }
  {
#line 164
  qcmd = (((88 << 8) + 4) << 8) | (h->qh_type & 255);
#line 165
  tmp___1 = quotactl(qcmd, (char const   *)(h->qh_quotadev), id___0, (caddr_t )((void *)(& xdqblk)));
  }
#line 165
  if (! (tmp___1 < 0L)) {
#line 169
    return (0);
  }
#line 171
  return (-1);
}
}
#line 177 "/home/wheatley/newnew/temp/quota-4.01/quotaio_xfs.c"
static int xfs_get_dquot___0(struct dquot *dq ) 
{ 
  struct fs_disk_quota d ;
  int qcmd ;
  int ret ;
  long tmp ;
  int *tmp___0 ;

  {
  {
#line 180
  qcmd = (((88 << 8) + 3) << 8) | ((dq->dq_h)->qh_type & 255);
#line 183
  memset((void *)(& d), 0, sizeof(d));
#line 184
  tmp = quotactl(qcmd, (char const   *)((dq->dq_h)->qh_quotadev), dq->dq_id, (caddr_t )((void *)(& d)));
#line 184
  ret = (int )tmp;
  }
#line 185
  if (ret < 0) {
    {
#line 186
    tmp___0 = __errno_location();
    }
#line 186
    if (*tmp___0 == 2) {
#line 187
      return (0);
    }
#line 188
    return (-1);
  }
  {
#line 190
  xfs_kern2utildqblk(& dq->dq_dqb, & d);
  }
#line 191
  return (0);
}
}
#line 197 "/home/wheatley/newnew/temp/quota-4.01/quotaio_xfs.c"
static int xfs_scan_dquots___0(struct quota_handle *h , int (*process_dquot)(struct dquot *dquot ,
                                                                             char *dqname ) ) 
{ 
  int tmp ;

  {
#line 199
  if (h->qh_type == 0) {
#line 199
    if (! ((int )h->qh_info.u.xfs_mdqi.qs_flags & 1)) {
#line 199
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 199
  if (h->qh_type == 1) {
#line 199
    if (! ((int )h->qh_info.u.xfs_mdqi.qs_flags & (1 << 2))) {
#line 200
      return (0);
    }
  } else {
#line 200
    return (0);
  }
  {
#line 202
  tmp = generic_scan_dquots(h, process_dquot, & xfs_get_dquot___0);
  }
#line 202
  return (tmp);
}
}
#line 208 "/home/wheatley/newnew/temp/quota-4.01/quotaio_xfs.c"
static int xfs_report___0(struct quota_handle *h , int verbose ) 
{ 
  u_int16_t sbflags ;
  struct fs_quota_stat *info ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;
  char *tmp___18 ;
  char *tmp___19 ;
  char *tmp___20 ;
  char *tmp___21 ;
  char *tmp___22 ;
  char *tmp___23 ;
  char *tmp___24 ;
  char *tmp___25 ;
  char *tmp___26 ;
  char *tmp___27 ;
  char *tmp___28 ;
  char *tmp___29 ;
  char *tmp___30 ;
  char *tmp___31 ;
  char *tmp___32 ;

  {
#line 211
  info = & h->qh_info.u.xfs_mdqi;
#line 213
  if (! verbose) {
#line 214
    return (0);
  }
  {
#line 217
  tmp = type2name(h->qh_type);
#line 217
  tmp___0 = gettext("*** Status for %s quotas on device %s\n");
#line 217
  printf((char const   */* __restrict  */)tmp___0, tmp, h->qh_quotadev);
  }
#line 220
  if (h->qh_type == 0) {
#line 221
    if ((int )info->qs_flags & (1 << 1)) {
      {
#line 221
      tmp___1 = gettext("ON");
#line 221
      tmp___3 = tmp___1;
      }
    } else {
      {
#line 221
      tmp___2 = gettext("OFF");
#line 221
      tmp___3 = tmp___2;
      }
    }
#line 221
    if ((int )info->qs_flags & 1) {
      {
#line 221
      tmp___4 = gettext("ON");
#line 221
      tmp___6 = tmp___4;
      }
    } else {
      {
#line 221
      tmp___5 = gettext("OFF");
#line 221
      tmp___6 = tmp___5;
      }
    }
    {
#line 221
    tmp___7 = gettext("Accounting: %s; Enforcement: %s\n");
#line 221
    printf((char const   */* __restrict  */)tmp___7, tmp___6, tmp___3);
    }
  } else {
#line 225
    if ((int )info->qs_flags & (1 << 3)) {
      {
#line 225
      tmp___8 = gettext("ON");
#line 225
      tmp___10 = tmp___8;
      }
    } else {
      {
#line 225
      tmp___9 = gettext("OFF");
#line 225
      tmp___10 = tmp___9;
      }
    }
#line 225
    if ((int )info->qs_flags & (1 << 2)) {
      {
#line 225
      tmp___11 = gettext("ON");
#line 225
      tmp___13 = tmp___11;
      }
    } else {
      {
#line 225
      tmp___12 = gettext("OFF");
#line 225
      tmp___13 = tmp___12;
      }
    }
    {
#line 225
    tmp___14 = gettext("Accounting: %s; Enforcement: %s\n");
#line 225
    printf((char const   */* __restrict  */)tmp___14, tmp___13, tmp___10);
    }
  }
#line 235
  sbflags = (u_int16_t )(((int )info->qs_flags & 65280) >> 8);
#line 235
  if ((int )sbflags != 0) {
#line 236
    if (h->qh_type == 0) {
#line 237
      if ((int )sbflags & (1 << 1)) {
        {
#line 237
        tmp___15 = gettext("ON");
#line 237
        tmp___17 = tmp___15;
        }
      } else {
        {
#line 237
        tmp___16 = gettext("OFF");
#line 237
        tmp___17 = tmp___16;
        }
      }
#line 237
      if ((int )sbflags & 1) {
        {
#line 237
        tmp___18 = gettext("ON");
#line 237
        tmp___20 = tmp___18;
        }
      } else {
        {
#line 237
        tmp___19 = gettext("OFF");
#line 237
        tmp___20 = tmp___19;
        }
      }
      {
#line 237
      tmp___21 = gettext("Accounting [ondisk]: %s; Enforcement [ondisk]: %s\n");
#line 237
      printf((char const   */* __restrict  */)tmp___21, tmp___20, tmp___17);
      }
    } else {
#line 241
      if ((int )sbflags & (1 << 3)) {
        {
#line 241
        tmp___22 = gettext("ON");
#line 241
        tmp___24 = tmp___22;
        }
      } else {
        {
#line 241
        tmp___23 = gettext("OFF");
#line 241
        tmp___24 = tmp___23;
        }
      }
#line 241
      if ((int )sbflags & (1 << 2)) {
        {
#line 241
        tmp___25 = gettext("ON");
#line 241
        tmp___27 = tmp___25;
        }
      } else {
        {
#line 241
        tmp___26 = gettext("OFF");
#line 241
        tmp___27 = tmp___26;
        }
      }
      {
#line 241
      tmp___28 = gettext("Accounting [ondisk]: %s; Enforcement [ondisk]: %s\n");
#line 241
      printf((char const   */* __restrict  */)tmp___28, tmp___27, tmp___24);
      }
    }
  }
#line 248
  if (h->qh_type == 0) {
#line 249
    if (info->qs_uquota.qfs_ino == 0xffffffffffffffffULL) {
      {
#line 250
      tmp___29 = gettext("Inode: none\n");
#line 250
      printf((char const   */* __restrict  */)tmp___29);
      }
    } else
#line 249
    if (info->qs_uquota.qfs_ino == 0ULL) {
      {
#line 250
      tmp___29 = gettext("Inode: none\n");
#line 250
      printf((char const   */* __restrict  */)tmp___29);
      }
    } else {
      {
#line 252
      tmp___30 = gettext("Inode: #%llu (%llu blocks, %u extents)\n");
#line 252
      printf((char const   */* __restrict  */)tmp___30, info->qs_uquota.qfs_ino, info->qs_uquota.qfs_nblks,
             info->qs_uquota.qfs_nextents);
      }
    }
  } else
#line 258
  if (info->qs_gquota.qfs_ino == 0xffffffffffffffffULL) {
    {
#line 259
    tmp___31 = gettext("Inode: none\n");
#line 259
    printf((char const   */* __restrict  */)tmp___31);
    }
  } else {
    {
#line 261
    tmp___32 = gettext("Inode: #%llu (%llu blocks, %u extents)\n");
#line 261
    printf((char const   */* __restrict  */)tmp___32, info->qs_gquota.qfs_ino, info->qs_gquota.qfs_nblks,
           info->qs_gquota.qfs_nextents);
    }
  }
#line 266
  return (0);
}
}
#line 89 "/home/wheatley/newnew/temp/quota-4.01/rquota_client.c"
static int rquota_err___0(int stat___0 ) 
{ 


  {
  {
#line 92
  if (stat___0 == -1) {
#line 92
    goto case_neg_1;
  }
#line 94
  if (stat___0 == 0) {
#line 94
    goto case_0;
  }
#line 96
  if (stat___0 == 2) {
#line 96
    goto case_2;
  }
#line 98
  if (stat___0 == 1) {
#line 98
    goto case_1;
  }
#line 100
  if (stat___0 == 3) {
#line 100
    goto case_3;
  }
#line 102
  goto switch_default;
  case_neg_1: /* CIL Label */ 
#line 93
  return (-111);
  case_0: /* CIL Label */ 
#line 95
  return (-38);
  case_2: /* CIL Label */ 
#line 97
  return (-2);
  case_1: /* CIL Label */ 
#line 99
  return (0);
  case_3: /* CIL Label */ 
#line 101
  return (-1);
  switch_default: /* CIL Label */ 
#line 103
  return (-22);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 107 "/home/wheatley/newnew/temp/quota-4.01/rquota_client.c"
static int split_nfs_mount___0(char *devname , char **host , char **path ) 
{ 
  char *pathname ;

  {
#line 112
  if ((int )*devname == 91) {
    {
#line 113
    *host = devname + 1;
#line 114
    pathname = strchr((char const   *)devname, ']');
    }
#line 115
    if (! pathname) {
#line 116
      return (0);
    } else
#line 115
    if ((int )*(pathname + 1) != 58) {
#line 116
      return (0);
    }
#line 118
    if ((int )*(pathname + 2) == 40) {
#line 119
      return (0);
    }
#line 120
    *pathname = (char)0;
#line 121
    *path = pathname + 2;
#line 122
    return (1);
  }
  {
#line 124
  *host = devname;
#line 125
  pathname = strchr((char const   *)devname, ':');
  }
#line 126
  if (! pathname) {
#line 127
    return (0);
  }
#line 129
  if ((int )*(pathname + 1) == 40) {
#line 130
    return (0);
  }
#line 131
  *pathname = (char)0;
#line 132
  *path = pathname + 1;
#line 133
  return (1);
}
}
#line 19 "/home/wheatley/newnew/temp/quota-4.01/quotaio_meta.c"
static int meta_init_io___0(struct quota_handle *h ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
#line 21
  if (! (h->qh_io_flags & 1)) {
    {
#line 22
    tmp = gettext("Metadata init_io called when kernel support is not enabled.\n");
#line 22
    errstr(tmp);
    }
#line 23
    return (-1);
  }
#line 25
  if (kernel_iface != 3) {
    {
#line 26
    tmp___0 = gettext("Metadata init_io called when kernel does not support generic quota interface!\n");
#line 26
    errstr(tmp___0);
    }
#line 27
    return (-1);
  }
  {
#line 29
  tmp___1 = vfs_get_info(h);
  }
#line 29
  return (tmp___1);
}
}
#line 32 "/home/wheatley/newnew/temp/quota-4.01/quotaio_meta.c"
static int meta_write_info___0(struct quota_handle *h ) 
{ 
  int tmp ;

  {
  {
#line 34
  tmp = vfs_set_info(h, 3);
  }
#line 34
  return (tmp);
}
}
#line 37 "/home/wheatley/newnew/temp/quota-4.01/quotaio_meta.c"
static struct dquot *meta_read_dquot___0(struct quota_handle *h , qid_t id___0 ) 
{ 
  struct dquot *dquot ;
  struct dquot *tmp ;
  int tmp___0 ;

  {
  {
#line 39
  tmp = get_empty_dquot();
#line 39
  dquot = tmp;
#line 41
  dquot->dq_id = id___0;
#line 42
  dquot->dq_h = h;
#line 43
  memset((void *)(& dquot->dq_dqb), 0, sizeof(struct util_dqblk ));
#line 44
  tmp___0 = vfs_get_dquot(dquot);
  }
#line 44
  if (tmp___0 < 0) {
    {
#line 45
    free((void *)dquot);
    }
#line 46
    return ((struct dquot *)((void *)0));
  }
#line 48
  return (dquot);
}
}
#line 51 "/home/wheatley/newnew/temp/quota-4.01/quotaio_meta.c"
static int meta_commit_dquot___0(struct dquot *dquot , int flags___7 ) 
{ 
  int tmp ;

  {
  {
#line 53
  tmp = vfs_set_dquot(dquot, flags___7);
  }
#line 53
  return (tmp);
}
}
#line 56 "/home/wheatley/newnew/temp/quota-4.01/quotaio_meta.c"
static int meta_scan_dquots___0(struct quota_handle *h , int (*process_dquot)(struct dquot *dquot ,
                                                                              char *dqname ) ) 
{ 
  int tmp ;

  {
  {
#line 58
  tmp = generic_scan_dquots(h, process_dquot, & vfs_get_dquot);
  }
#line 58
  return (tmp);
}
}
#line 41 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static char extensions___0[4][20]  = { {        (char )'u',        (char )'s',        (char )'e',        (char )'r', 
            (char )'\000'}, 
   {        (char )'g',        (char )'r',        (char )'o',        (char )'u', 
            (char )'p',        (char )'\000'}, 
   {        (char )'u',        (char )'n',        (char )'d',        (char )'e', 
            (char )'f',        (char )'i',        (char )'n',        (char )'e', 
            (char )'d',        (char )'\000'}};
#line 42 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static char *basenames___0[6]  = {      (char *)"quota",      (char *)"aquota",      (char *)"aquota",      (char *)"", 
        (char *)"",      (char *)""};
#line 43 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static char *fmtnames___0[5]  = {      (char *)"vfsold",      (char *)"vfsv0",      (char *)"vfsv1",      (char *)"rpc", 
        (char *)"xfs"};
#line 245 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static int kern2utilfmt___0(int kernfmt ) 
{ 


  {
  {
#line 248
  if (kernfmt == 1) {
#line 248
    goto case_1;
  }
#line 250
  if (kernfmt == 2) {
#line 250
    goto case_2;
  }
#line 252
  if (kernfmt == 4) {
#line 252
    goto case_4;
  }
#line 254
  if (kernfmt == 3) {
#line 254
    goto case_3;
  }
#line 247
  goto switch_break;
  case_1: /* CIL Label */ 
#line 249
  return (0);
  case_2: /* CIL Label */ 
#line 251
  return (1);
  case_4: /* CIL Label */ 
#line 253
  return (2);
  case_3: /* CIL Label */ 
#line 255
  return (5);
  switch_break: /* CIL Label */ ;
  }
#line 257
  return (-1);
}
}
#line 394 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static int hasxfsquota___0(char const   *dev , struct mntent *mnt___2 , int type ,
                           int flags___7 ) 
{ 
  u_int16_t sbflags ;
  struct fs_quota_stat info ;
  long tmp ;

  {
#line 399
  if (flags___7 & 16) {
#line 400
    return (4);
  }
  {
#line 402
  memset((void *)(& info), 0, sizeof(struct fs_quota_stat ));
#line 403
  tmp = quotactl((((88 << 8) + 5) << 8) | (type & 255), dev, (qid_t )0, (caddr_t )((void *)(& info)));
  }
#line 403
  if (! tmp) {
#line 404
    sbflags = (u_int16_t )(((int )info.qs_flags & 65280) >> 8);
#line 405
    if (type == 0) {
#line 405
      if ((int )info.qs_flags & 1) {
#line 406
        return (4);
      } else {
#line 405
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 407
    if (type == 1) {
#line 407
      if ((int )info.qs_flags & (1 << 2)) {
#line 408
        return (4);
      }
    }
  }
#line 424
  return (-1);
}
}
#line 427 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static int hasvfsmetaquota___0(char const   *dev , struct mntent *mnt___2 , int type ,
                               int flags___7 ) 
{ 
  uint32_t fmt___7 ;
  long tmp ;

  {
  {
#line 431
  tmp = quotactl((8388612 << 8) | (type & 255), dev, (qid_t )0, (caddr_t )((void *)(& fmt___7)));
  }
#line 431
  if (! tmp) {
#line 432
    return (5);
  }
#line 433
  return (-1);
}
}
#line 465 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static char *hasmntoptarg___0(char const   *optstring , char const   *opt ) 
{ 
  char *p ;
  char *tmp ;
  size_t tmp___0 ;

  {
  {
#line 467
  tmp = str_hasmntopt(optstring, opt);
#line 467
  p = tmp;
  }
#line 469
  if (! p) {
#line 470
    return ((char *)((void *)0));
  }
  {
#line 471
  tmp___0 = strlen(opt);
#line 471
  p += tmp___0;
  }
#line 472
  if ((int )*p == 61) {
#line 472
    if ((int )*(p + 1) != 44) {
#line 473
      return (p + 1);
    }
  }
#line 474
  return ((char *)((void *)0));
}
}
#line 478 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static void copy_mntoptarg___0(char *buf , char const   *optarg___0 , int buflen ) 
{ 
  char *sep ;
  char *tmp ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  long tmp___4 ;

  {
  {
#line 480
  tmp = strchr(optarg___0, ',');
#line 480
  sep = tmp;
  }
#line 482
  if (! sep) {
    {
#line 483
    tmp___3 = strlen(optarg___0);
    }
#line 483
    if ((size_t )buflen < tmp___3 + 1UL) {
#line 483
      tmp___2 = (size_t )buflen;
    } else {
      {
#line 483
      tmp___1 = strlen(optarg___0);
#line 483
      tmp___2 = tmp___1 + 1UL;
      }
    }
    {
#line 483
    sstrncpy(buf, optarg___0, tmp___2);
    }
  } else {
#line 485
    if ((long )buflen < (sep - (char *)optarg___0) + 1L) {
#line 485
      tmp___4 = (long )buflen;
    } else {
#line 485
      tmp___4 = (sep - (char *)optarg___0) + 1L;
    }
    {
#line 485
    sstrncpy(buf, optarg___0, (size_t )tmp___4);
    }
  }
#line 486
  return;
}
}
#line 491 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static int hasquota___0(char const   *dev , struct mntent *mnt___2 , int type , int flags___7 ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  struct if_dqinfo kinfo ;
  long tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;

  {
  {
#line 493
  tmp___0 = strcmp((char const   *)mnt___2->mnt_type, "gfs2");
  }
#line 493
  if (tmp___0) {
    {
#line 493
    tmp___1 = strcmp((char const   *)mnt___2->mnt_type, "xfs");
    }
#line 493
    if (! tmp___1) {
      {
#line 495
      tmp = hasxfsquota___0(dev, mnt___2, type, flags___7);
      }
#line 495
      return (tmp);
    }
  } else {
    {
#line 495
    tmp = hasxfsquota___0(dev, mnt___2, type, flags___7);
    }
#line 495
    return (tmp);
  }
  {
#line 496
  tmp___3 = strcmp((char const   *)mnt___2->mnt_type, "ocfs2");
  }
#line 496
  if (! tmp___3) {
    {
#line 497
    tmp___2 = hasvfsmetaquota___0(dev, mnt___2, type, flags___7);
    }
#line 497
    return (tmp___2);
  }
  {
#line 504
  tmp___5 = strcmp((char const   *)mnt___2->mnt_type, "ext4");
  }
#line 504
  if (! tmp___5) {
    {
#line 507
    tmp___4 = quotactl((8388613 << 8) | (type & 255), dev, (qid_t )0, (caddr_t )((void *)(& kinfo)));
    }
#line 507
    if (tmp___4 == 0L) {
#line 508
      if (kinfo.dqi_flags & 65536U) {
#line 509
        return (5);
      }
    }
  }
  {
#line 513
  tmp___6 = nfs_fstype(mnt___2->mnt_type);
  }
#line 513
  if (tmp___6) {
#line 514
    return (3);
  }
#line 516
  if (type == 0) {
    {
#line 516
    tmp___7 = hasmntopt((struct mntent  const  *)mnt___2, "usrquota");
    }
#line 516
    if (tmp___7) {
#line 517
      return (6);
    } else {
      {
#line 516
      tmp___8 = hasmntoptarg___0((char const   *)mnt___2->mnt_opts, "usrjquota");
      }
#line 516
      if (tmp___8) {
#line 517
        return (6);
      }
    }
  }
#line 518
  if (type == 1) {
    {
#line 518
    tmp___9 = hasmntopt((struct mntent  const  *)mnt___2, "grpquota");
    }
#line 518
    if (tmp___9) {
#line 519
      return (6);
    } else {
      {
#line 518
      tmp___10 = hasmntoptarg___0((char const   *)mnt___2->mnt_opts, "grpjquota");
      }
#line 518
      if (tmp___10) {
#line 519
        return (6);
      }
    }
  }
#line 520
  if (type == 0) {
    {
#line 520
    tmp___11 = hasmntopt((struct mntent  const  *)mnt___2, "quota");
    }
#line 520
    if (tmp___11) {
#line 521
      return (6);
    }
  }
#line 522
  return (-1);
}
}
#line 526 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static int check_fmtfile_ok___0(char *name , int type , int fmt___7 , int flags___7 ) 
{ 
  struct stat st ;
  int *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;
  int fd ;
  int ret ;
  int tmp___4 ;
  int *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  int *tmp___8 ;
  int *tmp___9 ;

  {
#line 528
  if (! flags___7) {
#line 529
    return (1);
  }
#line 530
  if (flags___7 & 1) {
    {
#line 533
    tmp___3 = stat((char const   */* __restrict  */)name, (struct stat */* __restrict  */)(& st));
    }
#line 533
    if (tmp___3 < 0) {
      {
#line 534
      tmp___2 = __errno_location();
      }
#line 534
      if (*tmp___2 != 2) {
        {
#line 535
        tmp = __errno_location();
#line 535
        tmp___0 = strerror(*tmp);
#line 535
        tmp___1 = gettext("Cannot stat quota file %s: %s\n");
#line 535
        errstr(tmp___1, name, tmp___0);
        }
      }
#line 536
      return (0);
    }
  }
#line 539
  if (flags___7 & 2) {
    {
#line 540
    ret = 0;
#line 542
    fd = open((char const   *)name, 0);
    }
#line 542
    if (fd >= 0) {
      {
#line 543
      tmp___4 = is_tree_qfmt(fmt___7);
      }
#line 543
      if (tmp___4) {
        {
#line 544
        ret = (*(quotafile_ops_2.check_file))(fd, type, fmt___7);
        }
      } else {
        {
#line 546
        ret = (*(quotafile_ops_1.check_file))(fd, type, fmt___7);
        }
      }
      {
#line 547
      close(fd);
      }
#line 548
      if (ret <= 0) {
#line 549
        return (0);
      }
    } else {
      {
#line 551
      tmp___8 = __errno_location();
      }
#line 551
      if (*tmp___8 != 2) {
        {
#line 551
        tmp___9 = __errno_location();
        }
#line 551
        if (*tmp___9 != 1) {
          {
#line 552
          tmp___5 = __errno_location();
#line 552
          tmp___6 = strerror(*tmp___5);
#line 552
          tmp___7 = gettext("Cannot open quotafile %s: %s\n");
#line 552
          errstr(tmp___7, name, tmp___6);
          }
#line 553
          return (0);
        }
      }
    }
  }
#line 556
  return (1);
}
}
#line 629 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static int hlist_allocated___0  =    0;
#line 630 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static struct quota_handle **hlist___0  =    (struct quota_handle **)((void *)0);
#line 735 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static int kernel_qfmt_num___0  ;
#line 736 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static int kernel_qfmt___0[6]  ;
#line 828 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static int v1_kern_quota_on___0(char const   *dev , int type ) 
{ 
  char tmp[1024] ;
  qid_t id___0 ;
  __uid_t tmp___0 ;
  __gid_t tmp___1 ;
  __uid_t tmp___2 ;
  long tmp___3 ;

  {
#line 831
  if (type == 0) {
    {
#line 831
    tmp___0 = getuid();
#line 831
    tmp___2 = tmp___0;
    }
  } else {
    {
#line 831
    tmp___1 = getgid();
#line 831
    tmp___2 = tmp___1;
    }
  }
  {
#line 831
  id___0 = tmp___2;
#line 833
  tmp___3 = quotactl((768 << 8) | (type & 255), dev, id___0, tmp);
  }
#line 833
  if (! tmp___3) {
#line 834
    return (1);
  }
#line 835
  return (0);
}
}
#line 839 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static int v2_kern_quota_on___0(char const   *dev , int type ) 
{ 
  char tmp[1024] ;
  qid_t id___0 ;
  __uid_t tmp___0 ;
  __gid_t tmp___1 ;
  __uid_t tmp___2 ;
  long tmp___3 ;

  {
#line 842
  if (type == 0) {
    {
#line 842
    tmp___0 = getuid();
#line 842
    tmp___2 = tmp___0;
    }
  } else {
    {
#line 842
    tmp___1 = getgid();
#line 842
    tmp___2 = tmp___1;
    }
  }
  {
#line 842
  id___0 = tmp___2;
#line 844
  tmp___3 = quotactl((3328 << 8) | (type & 255), dev, id___0, tmp);
  }
#line 844
  if (! tmp___3) {
#line 845
    return (1);
  }
#line 846
  return (0);
}
}
#line 850 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static int xfs_kern_quota_on___0(char const   *dev , int type ) 
{ 
  struct fs_quota_stat info ;
  long tmp ;

  {
  {
#line 854
  tmp = quotactl((((88 << 8) + 5) << 8) | (type & 255), dev, (qid_t )0, (caddr_t )((void *)(& info)));
  }
#line 854
  if (! tmp) {
#line 855
    if (type == 0) {
#line 855
      if ((int )info.qs_flags & 1) {
#line 856
        return (1);
      }
    }
#line 857
    if (type == 1) {
#line 857
      if ((int )info.qs_flags & (1 << 2)) {
#line 858
        return (1);
      }
    }
  }
#line 860
  return (0);
}
}
#line 921 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static int mnt_entries_cnt___0  ;
#line 922 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static struct mount_entry *mnt_entries___0  ;
#line 923 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static int check_dirs_cnt___0  ;
#line 923 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static int act_checked___0  ;
#line 924 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static struct searched_dir *check_dirs___0  ;
#line 927 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static int cache_mnt_table___0(int flags___7 ) 
{ 
  FILE *mntf ;
  struct mntent *mnt___2 ;
  struct stat st ;
  struct statfs fsstat ;
  int allocated ;
  int i ;
  dev_t dev ;
  char mntpointbuf[4096] ;
  int autofsdircnt ;
  int autofsdir_allocated ;
  char **autofsdir ;
  char *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  char const   *devname ;
  char *opt ;
  int qfmt[2] ;
  char *tmp___2 ;
  int slen ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  void *tmp___6 ;
  size_t tmp___7 ;
  void *tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char loopdev[4096] ;
  char *tmp___13 ;
  int *tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;
  int *tmp___18 ;
  char *tmp___19 ;
  char *tmp___20 ;
  int tmp___21 ;
  int *tmp___22 ;
  char *tmp___23 ;
  char *tmp___24 ;
  int tmp___25 ;
  char *tmp___26 ;
  int tmp___27 ;
  int *tmp___28 ;
  char *tmp___29 ;
  char *tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;
  void *tmp___34 ;
  char *tmp___35 ;

  {
  {
#line 933
  allocated = 0;
#line 933
  i = 0;
#line 934
  dev = (dev_t )0;
#line 940
  mntf = setmntent("/proc/mounts", "r");
  }
#line 941
  if (mntf) {
#line 942
    goto alloc;
  }
  {
#line 944
  mntf = setmntent("/etc/mtab", "r");
  }
#line 945
  if (mntf) {
#line 946
    goto alloc;
  }
  {
#line 948
  mntf = setmntent("/etc/fstab", "r");
  }
#line 948
  if (! mntf) {
    {
#line 949
    tmp = gettext("Cannot open any file with mount points.\n");
#line 949
    errstr(tmp);
    }
#line 950
    return (-1);
  }
  alloc: 
  {
#line 954
  tmp___0 = smalloc(sizeof(struct mount_entry ) * 16UL);
#line 954
  mnt_entries___0 = (struct mount_entry *)tmp___0;
#line 955
  mnt_entries_cnt___0 = 0;
#line 956
  allocated += 16;
#line 958
  tmp___1 = smalloc(sizeof(char *) * 16UL);
#line 958
  autofsdir = (char **)tmp___1;
#line 959
  autofsdircnt = 0;
#line 960
  autofsdir_allocated = 16;
  }
  {
#line 961
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 961
    mnt___2 = getmntent(mntf);
    }
#line 961
    if (! mnt___2) {
#line 961
      goto while_break;
    }
    {
#line 966
    devname = get_device_name((char const   *)mnt___2->mnt_fsname);
    }
#line 966
    if (! devname) {
      {
#line 967
      tmp___2 = gettext("Cannot get device name for %s\n");
#line 967
      errstr(tmp___2, mnt___2->mnt_fsname);
      }
#line 968
      goto while_continue;
    }
#line 972
    i = 0;
    {
#line 972
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 972
      if (! (i < autofsdircnt)) {
#line 972
        goto while_break___0;
      }
      {
#line 973
      tmp___3 = strlen((char const   *)*(autofsdir + i));
#line 973
      slen = (int )tmp___3;
#line 975
      tmp___4 = strlen((char const   *)mnt___2->mnt_dir);
      }
#line 975
      if ((size_t )slen <= tmp___4) {
        {
#line 975
        tmp___5 = strncmp((char const   *)*(autofsdir + i), (char const   *)mnt___2->mnt_dir,
                          (size_t )slen);
        }
#line 975
        if (! tmp___5) {
#line 976
          goto while_break___0;
        }
      }
#line 972
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 978
    if (i < autofsdircnt) {
      {
#line 979
      free((void *)((char *)devname));
      }
#line 980
      goto while_continue;
    }
#line 983
    if (flags___7 & 2) {
      {
#line 983
      tmp___9 = strcmp((char const   *)mnt___2->mnt_type, "autofs");
      }
#line 983
      if (! tmp___9) {
#line 984
        if (autofsdircnt == autofsdir_allocated) {
          {
#line 985
          autofsdir_allocated += 16;
#line 986
          tmp___6 = srealloc((void *)autofsdir, (unsigned long )autofsdir_allocated * sizeof(char *));
#line 986
          autofsdir = (char **)tmp___6;
          }
        }
        {
#line 988
        tmp___7 = strlen((char const   *)mnt___2->mnt_dir);
#line 988
        tmp___8 = smalloc(tmp___7 + 2UL);
#line 988
        *(autofsdir + autofsdircnt) = (char *)tmp___8;
#line 989
        strcpy((char */* __restrict  */)*(autofsdir + autofsdircnt), (char const   */* __restrict  */)mnt___2->mnt_dir);
#line 990
        strcat((char */* __restrict  */)*(autofsdir + autofsdircnt), (char const   */* __restrict  */)"/");
#line 991
        autofsdircnt ++;
#line 992
        free((void *)((char *)devname));
        }
#line 993
        goto while_continue;
      }
    }
#line 996
    if (flags___7 & 8) {
      {
#line 996
      tmp___10 = nfs_fstype(mnt___2->mnt_type);
      }
#line 996
      if (tmp___10) {
        {
#line 997
        free((void *)((char *)devname));
        }
#line 998
        goto while_continue;
      }
    }
    {
#line 1000
    tmp___11 = hasmntopt((struct mntent  const  *)mnt___2, "noquota");
    }
#line 1000
    if (tmp___11) {
      {
#line 1001
      free((void *)((char *)devname));
      }
#line 1002
      goto while_continue;
    }
    {
#line 1004
    tmp___12 = hasmntopt((struct mntent  const  *)mnt___2, "bind");
    }
#line 1004
    if (tmp___12) {
      {
#line 1005
      free((void *)((char *)devname));
      }
#line 1006
      goto while_continue;
    }
    {
#line 1008
    opt = hasmntoptarg___0((char const   *)mnt___2->mnt_opts, "loop");
    }
#line 1008
    if (opt) {
      {
#line 1011
      copy_mntoptarg___0(opt, (char const   *)(loopdev), 4096);
#line 1012
      free((void *)((char *)devname));
#line 1013
      tmp___13 = sstrdup((char const   *)(loopdev));
#line 1013
      devname = (char const   *)tmp___13;
      }
    }
    {
#line 1018
    qfmt[0] = hasquota___0(devname, mnt___2, 0, flags___7);
#line 1019
    qfmt[1] = hasquota___0(devname, mnt___2, 1, flags___7);
    }
#line 1020
    if (qfmt[0] < 0) {
#line 1020
      if (qfmt[1] < 0) {
        {
#line 1021
        free((void *)((char *)devname));
        }
#line 1022
        goto while_continue;
      }
    }
    {
#line 1025
    tmp___17 = realpath((char const   */* __restrict  */)mnt___2->mnt_dir, (char */* __restrict  */)(mntpointbuf));
    }
#line 1025
    if (! tmp___17) {
      {
#line 1026
      tmp___14 = __errno_location();
#line 1026
      tmp___15 = strerror(*tmp___14);
#line 1026
      tmp___16 = gettext("Cannot resolve mountpoint path %s: %s\n");
#line 1026
      errstr(tmp___16, mnt___2->mnt_dir, tmp___15);
#line 1027
      free((void *)((char *)devname));
      }
#line 1028
      goto while_continue;
    }
    {
#line 1031
    tmp___21 = statfs((char const   *)(mntpointbuf), & fsstat);
    }
#line 1031
    if (tmp___21 != 0) {
      {
#line 1032
      tmp___18 = __errno_location();
#line 1032
      tmp___19 = strerror(*tmp___18);
#line 1032
      tmp___20 = gettext("Cannot statfs() %s: %s\n");
#line 1032
      errstr(tmp___20, mntpointbuf, tmp___19);
#line 1033
      free((void *)((char *)devname));
      }
#line 1034
      goto while_continue;
    }
#line 1037
    if (fsstat.f_blocks == 0UL) {
#line 1037
      if (fsstat.f_bfree == 0UL) {
#line 1037
        if (fsstat.f_bavail == 0UL) {
          {
#line 1038
          free((void *)((char *)devname));
          }
#line 1039
          goto while_continue;
        }
      }
    }
    {
#line 1042
    tmp___27 = nfs_fstype(mnt___2->mnt_type);
    }
#line 1042
    if (! tmp___27) {
      {
#line 1043
      tmp___25 = stat((char const   */* __restrict  */)devname, (struct stat */* __restrict  */)(& st));
      }
#line 1043
      if (tmp___25 < 0) {
        {
#line 1044
        tmp___22 = __errno_location();
#line 1044
        tmp___23 = strerror(*tmp___22);
#line 1044
        tmp___24 = gettext("Cannot stat() mounted device %s: %s\n");
#line 1044
        errstr(tmp___24, devname, tmp___23);
#line 1045
        free((void *)((char *)devname));
        }
#line 1046
        goto while_continue;
      }
#line 1048
      if (! ((st.st_mode & 61440U) == 24576U)) {
#line 1048
        if (! ((st.st_mode & 61440U) == 8192U)) {
          {
#line 1049
          tmp___26 = gettext("Device (%s) filesystem is mounted on unsupported device type. Skipping.\n");
#line 1049
          errstr(tmp___26, devname);
#line 1050
          free((void *)((char *)devname));
          }
#line 1051
          goto while_continue;
        }
      }
#line 1053
      dev = st.st_rdev;
#line 1054
      i = 0;
      {
#line 1054
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1054
        if (i < mnt_entries_cnt___0) {
#line 1054
          if (! ((mnt_entries___0 + i)->me_dev != dev)) {
#line 1054
            goto while_break___1;
          }
        } else {
#line 1054
          goto while_break___1;
        }
#line 1054
        i ++;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
    {
#line 1057
    tmp___33 = nfs_fstype(mnt___2->mnt_type);
    }
#line 1057
    if (tmp___33) {
#line 1057
      goto _L;
    } else
#line 1057
    if (i == mnt_entries_cnt___0) {
      _L: /* CIL Label */ 
      {
#line 1058
      tmp___31 = stat((char const   */* __restrict  */)mnt___2->mnt_dir, (struct stat */* __restrict  */)(& st));
      }
#line 1058
      if (tmp___31 < 0) {
        {
#line 1059
        tmp___28 = __errno_location();
#line 1059
        tmp___29 = strerror(*tmp___28);
#line 1059
        tmp___30 = gettext("Cannot stat() mountpoint %s: %s\n");
#line 1059
        errstr(tmp___30, mnt___2->mnt_dir, tmp___29);
#line 1060
        free((void *)((char *)devname));
        }
#line 1061
        goto while_continue;
      }
      {
#line 1063
      tmp___32 = nfs_fstype(mnt___2->mnt_type);
      }
#line 1063
      if (tmp___32) {
#line 1065
        dev = st.st_dev;
#line 1066
        if (! (flags___7 & 32)) {
#line 1067
          i = 0;
          {
#line 1067
          while (1) {
            while_continue___2: /* CIL Label */ ;
#line 1067
            if (i < mnt_entries_cnt___0) {
#line 1067
              if (! ((mnt_entries___0 + i)->me_dev != dev)) {
#line 1067
                goto while_break___2;
              }
            } else {
#line 1067
              goto while_break___2;
            }
#line 1067
            i ++;
          }
          while_break___2: /* CIL Label */ ;
          }
        } else {
#line 1070
          i = mnt_entries_cnt___0;
        }
      }
    }
#line 1073
    if (i == mnt_entries_cnt___0) {
#line 1074
      if (allocated == mnt_entries_cnt___0) {
        {
#line 1075
        allocated += 16;
#line 1076
        tmp___34 = srealloc((void *)mnt_entries___0, (unsigned long )allocated * sizeof(struct mount_entry ));
#line 1076
        mnt_entries___0 = (struct mount_entry *)tmp___34;
        }
      }
      {
#line 1078
      (mnt_entries___0 + i)->me_type = sstrdup((char const   *)mnt___2->mnt_type);
#line 1079
      (mnt_entries___0 + i)->me_opts = sstrdup((char const   *)mnt___2->mnt_opts);
#line 1080
      (mnt_entries___0 + i)->me_dev = dev;
#line 1081
      (mnt_entries___0 + i)->me_ino = st.st_ino;
#line 1082
      (mnt_entries___0 + i)->me_devname = devname;
#line 1083
      tmp___35 = sstrdup((char const   *)(mntpointbuf));
#line 1083
      (mnt_entries___0 + i)->me__dir = (char const   *)tmp___35;
#line 1084
      (mnt_entries___0 + i)->me_dir = (char const   *)((void *)0);
#line 1085
      memcpy((void */* __restrict  */)(& (mnt_entries___0 + i)->me_qfmt), (void const   */* __restrict  */)(qfmt),
             sizeof(qfmt));
#line 1086
      mnt_entries_cnt___0 ++;
      }
    } else {
      {
#line 1089
      free((void *)((char *)devname));
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1091
  endmntent(mntf);
#line 1093
  i = 0;
  }
  {
#line 1093
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 1093
    if (! (i < autofsdircnt)) {
#line 1093
      goto while_break___3;
    }
    {
#line 1094
    free((void *)*(autofsdir + i));
#line 1093
    i ++;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 1095
  free((void *)autofsdir);
  }
#line 1096
  return (0);
}
}
#line 1100 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static char const   *find_dir_mntpoint___0(struct stat *st ) 
{ 
  int i ;

  {
#line 1104
  i = 0;
  {
#line 1104
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1104
    if (! (i < mnt_entries_cnt___0)) {
#line 1104
      goto while_break;
    }
#line 1105
    if ((mnt_entries___0 + i)->me_dev == st->st_dev) {
#line 1106
      st->st_ino = (mnt_entries___0 + i)->me_ino;
#line 1107
      return ((mnt_entries___0 + i)->me__dir);
    }
#line 1104
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1109
  return ((char const   *)((void *)0));
}
}
#line 1113 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static int process_dirs___0(int dcnt , char **dirs , int flags___7 ) 
{ 
  struct stat st ;
  int i ;
  char mntpointbuf[4096] ;
  void *tmp ;
  char *devname ;
  char const   *tmp___0 ;
  char *tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  int *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  char const   *realmnt ;
  char *tmp___12 ;
  int *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  int mentry ;
  char *tmp___17 ;
  char *tmp___18 ;
  char *tmp___19 ;
  char *tmp___20 ;

  {
#line 1119
  check_dirs_cnt___0 = 0;
#line 1120
  act_checked___0 = -1;
#line 1121
  if (dcnt) {
    {
#line 1122
    tmp = smalloc(sizeof(struct searched_dir ) * (unsigned long )dcnt);
#line 1122
    check_dirs___0 = (struct searched_dir *)tmp;
#line 1123
    i = 0;
    }
    {
#line 1123
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1123
      if (! (i < dcnt)) {
#line 1123
        goto while_break;
      }
      {
#line 1124
      tmp___10 = strncmp((char const   *)*(dirs + i), "UUID=", (size_t )5);
      }
#line 1124
      if (tmp___10) {
        {
#line 1124
        tmp___11 = strncmp((char const   *)*(dirs + i), "LABEL=", (size_t )6);
        }
#line 1124
        if (tmp___11) {
          {
#line 1139
          tmp___9 = stat((char const   */* __restrict  */)*(dirs + i), (struct stat */* __restrict  */)(& st));
          }
#line 1139
          if (tmp___9 < 0) {
            {
#line 1140
            tmp___6 = __errno_location();
#line 1140
            tmp___7 = strerror(*tmp___6);
#line 1140
            tmp___8 = gettext("Cannot stat() given mountpoint %s: %s\nSkipping...\n");
#line 1140
            errstr(tmp___8, *(dirs + i), tmp___7);
            }
#line 1141
            goto __Cont;
          }
        } else {
          _L: /* CIL Label */ 
          {
#line 1125
          tmp___0 = get_device_name((char const   *)*(dirs + i));
#line 1125
          devname = (char *)tmp___0;
          }
#line 1127
          if (! devname) {
            {
#line 1128
            tmp___1 = gettext("Cannot find a device with %s.\nSkipping...\n");
#line 1128
            errstr(tmp___1, *(dirs + i));
            }
#line 1129
            goto __Cont;
          }
          {
#line 1131
          tmp___5 = stat((char const   */* __restrict  */)devname, (struct stat */* __restrict  */)(& st));
          }
#line 1131
          if (tmp___5 < 0) {
            {
#line 1132
            tmp___2 = __errno_location();
#line 1132
            tmp___3 = strerror(*tmp___2);
#line 1132
            tmp___4 = gettext("Cannot stat() a mountpoint with %s: %s\nSkipping...\n");
#line 1132
            errstr(tmp___4, *(dirs + i), tmp___3);
#line 1133
            free((void *)devname);
            }
#line 1134
            goto __Cont;
          }
          {
#line 1136
          free((void *)devname);
          }
        }
      } else {
#line 1124
        goto _L;
      }
#line 1143
      (check_dirs___0 + check_dirs_cnt___0)->sd_dir = (st.st_mode & 61440U) == 16384U;
#line 1144
      if ((st.st_mode & 61440U) == 16384U) {
#line 1145
        realmnt = (char const   *)*(dirs + i);
#line 1148
        if (flags___7 & 1) {
          {
#line 1148
          realmnt = find_dir_mntpoint___0(& st);
          }
#line 1148
          if (! realmnt) {
#line 1149
            if (! (flags___7 & 4)) {
              {
#line 1150
              tmp___12 = gettext("Cannot find a filesystem mountpoint for directory %s\n");
#line 1150
              errstr(tmp___12, *(dirs + i));
              }
            }
#line 1151
            goto __Cont;
          }
        }
        {
#line 1153
        (check_dirs___0 + check_dirs_cnt___0)->sd_dev = st.st_dev;
#line 1154
        (check_dirs___0 + check_dirs_cnt___0)->sd_ino = st.st_ino;
#line 1155
        tmp___16 = realpath((char const   */* __restrict  */)realmnt, (char */* __restrict  */)(mntpointbuf));
        }
#line 1155
        if (! tmp___16) {
          {
#line 1156
          tmp___13 = __errno_location();
#line 1156
          tmp___14 = strerror(*tmp___13);
#line 1156
          tmp___15 = gettext("Cannot resolve path %s: %s\n");
#line 1156
          errstr(tmp___15, realmnt, tmp___14);
          }
#line 1157
          goto __Cont;
        }
      } else
#line 1160
      if ((st.st_mode & 61440U) == 24576U) {
#line 1160
        goto _L___0;
      } else
#line 1160
      if ((st.st_mode & 61440U) == 8192U) {
        _L___0: /* CIL Label */ 
#line 1163
        (check_dirs___0 + check_dirs_cnt___0)->sd_dev = st.st_rdev;
#line 1164
        mentry = 0;
        {
#line 1164
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 1164
          if (mentry < mnt_entries_cnt___0) {
#line 1164
            if (! ((mnt_entries___0 + mentry)->me_dev != st.st_rdev)) {
#line 1164
              goto while_break___0;
            }
          } else {
#line 1164
            goto while_break___0;
          }
#line 1164
          mentry ++;
        }
        while_break___0: /* CIL Label */ ;
        }
#line 1165
        if (mentry == mnt_entries_cnt___0) {
#line 1166
          if (! (flags___7 & 4)) {
            {
#line 1167
            tmp___17 = gettext("Cannot find mountpoint for device %s\n");
#line 1167
            errstr(tmp___17, *(dirs + i));
            }
          }
#line 1168
          goto __Cont;
        }
        {
#line 1170
        sstrncpy(mntpointbuf, (mnt_entries___0 + mentry)->me__dir, (size_t )4095);
        }
      } else {
        {
#line 1173
        tmp___18 = gettext("Specified path %s is not directory nor device.\n");
#line 1173
        errstr(tmp___18, *(dirs + i));
        }
#line 1174
        goto __Cont;
      }
      {
#line 1176
      tmp___19 = sstrdup((char const   *)(mntpointbuf));
#line 1176
      (check_dirs___0 + check_dirs_cnt___0)->sd_name = (char const   *)tmp___19;
#line 1177
      check_dirs_cnt___0 ++;
      }
      __Cont: /* CIL Label */ 
#line 1123
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 1179
    if (! check_dirs_cnt___0) {
#line 1180
      if (! (flags___7 & 4)) {
        {
#line 1181
        tmp___20 = gettext("No correct mountpoint specified.\n");
#line 1181
        errstr(tmp___20);
        }
      }
      {
#line 1182
      free((void *)check_dirs___0);
      }
#line 1183
      return (-1);
    }
  }
#line 1186
  return (0);
}
}
#line 1204 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static int find_next_entry_all___0(int *pos ) 
{ 
  char *tmp ;

  {
  {
#line 1206
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1206
    act_checked___0 ++;
#line 1206
    if (! (act_checked___0 < mnt_entries_cnt___0)) {
#line 1206
      goto while_break;
    }
    {
#line 1207
    tmp = str_hasmntopt((char const   *)(mnt_entries___0 + act_checked___0)->me_opts,
                        "noauto");
    }
#line 1207
    if (! tmp) {
#line 1208
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1210
  if (act_checked___0 >= mnt_entries_cnt___0) {
#line 1211
    return (0);
  }
#line 1212
  *pos = act_checked___0;
#line 1213
  return (1);
}
}
#line 1217 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static int find_next_entry_sel___0(int *pos ) 
{ 
  int i ;
  struct searched_dir *sd ;
  char *tmp ;

  {
  restart: 
#line 1223
  act_checked___0 ++;
#line 1223
  if (act_checked___0 == check_dirs_cnt___0) {
#line 1224
    return (0);
  }
#line 1225
  sd = check_dirs___0 + act_checked___0;
#line 1226
  i = 0;
  {
#line 1226
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1226
    if (! (i < mnt_entries_cnt___0)) {
#line 1226
      goto while_break;
    }
#line 1227
    if (sd->sd_dir) {
#line 1228
      if (sd->sd_dev == (mnt_entries___0 + i)->me_dev) {
#line 1228
        if (sd->sd_ino == (mnt_entries___0 + i)->me_ino) {
#line 1229
          goto while_break;
        }
      }
    } else
#line 1232
    if (sd->sd_dev == (mnt_entries___0 + i)->me_dev) {
#line 1233
      goto while_break;
    }
#line 1226
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1235
  if (i == mnt_entries_cnt___0) {
    {
#line 1236
    tmp = gettext("Mountpoint (or device) %s not found or has no quota enabled.\n");
#line 1236
    errstr(tmp, sd->sd_name);
    }
#line 1237
    goto restart;
  }
#line 1239
  *pos = i;
#line 1240
  return (1);
}
}
#line 23 "/home/wheatley/newnew/temp/quota-4.01/common.c"
static int enable_syslog___1  =    0;
#line 31 "/home/wheatley/newnew/temp/quota-4.01/common.c"
static void do_syslog___1(int level , char const   *format , va_list args ) 
{ 
  char buf[1024] ;
  int i ;
  int j ;
  int tmp ;

  {
  {
#line 36
  vsnprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)format,
            args);
#line 39
  i = 0;
  }
  {
#line 39
  while (1) {
    while_continue: /* CIL Label */ ;
#line 39
    if (! buf[i]) {
#line 39
      goto while_break;
    }
#line 40
    j = i;
    {
#line 40
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 40
      if (buf[j]) {
#line 40
        if (! ((int )buf[j] != 10)) {
#line 40
          goto while_break___0;
        }
      } else {
#line 40
        goto while_break___0;
      }
#line 40
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 41
    if ((int )buf[j] == 10) {
#line 42
      tmp = j;
#line 42
      j ++;
#line 42
      buf[tmp] = (char )'\000';
    }
    {
#line 43
    syslog(level, "%s", buf + i);
#line 39
    i = j;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 45
  return;
}
}
#line 18 "/home/wheatley/newnew/temp/quota-4.01/quotaio_rpc.c"
static int rpc_init_io___0(struct quota_handle *h ) ;
#line 19
static struct dquot *rpc_read_dquot___0(struct quota_handle *h , qid_t id___0 ) ;
#line 20
static int rpc_commit_dquot___0(struct dquot *dquot , int flags___7 ) ;
#line 31 "/home/wheatley/newnew/temp/quota-4.01/quotaio_rpc.c"
static int rpc_init_io___0(struct quota_handle *h ) 
{ 


  {
#line 34
  h->qh_info.dqi_max_b_limit = (uint64_t )(~ ((uint32_t )0));
#line 35
  h->qh_info.dqi_max_i_limit = (uint64_t )(~ ((uint32_t )0));
#line 36
  h->qh_info.dqi_max_b_usage = (uint64_t )(4294967295U << 10);
#line 37
  h->qh_info.dqi_max_i_usage = (uint64_t )(~ ((uint32_t )0));
#line 38
  return (0);
}
}
#line 47 "/home/wheatley/newnew/temp/quota-4.01/quotaio_rpc.c"
static struct dquot *rpc_read_dquot___0(struct quota_handle *h , qid_t id___0 ) 
{ 
  struct dquot *dquot ;
  struct dquot *tmp ;
  int ret ;
  int *tmp___0 ;

  {
  {
#line 50
  tmp = get_empty_dquot();
#line 50
  dquot = tmp;
#line 53
  dquot->dq_id = id___0;
#line 54
  dquot->dq_h = h;
#line 55
  ret = rpc_rquota_get(dquot);
  }
#line 55
  if (ret < 0) {
    {
#line 56
    tmp___0 = __errno_location();
#line 56
    *tmp___0 = - ret;
#line 57
    free((void *)dquot);
    }
#line 58
    return ((struct dquot *)((void *)0));
  }
#line 60
  return (dquot);
}
}
#line 70 "/home/wheatley/newnew/temp/quota-4.01/quotaio_rpc.c"
static int rpc_commit_dquot___0(struct dquot *dquot , int flags___7 ) 
{ 
  int ret ;
  char *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;

  {
#line 75
  if ((dquot->dq_h)->qh_io_flags & 4) {
    {
#line 76
    tmp = gettext("Trying to write quota to readonly quotafile on %s\n");
#line 76
    errstr(tmp, (dquot->dq_h)->qh_quotadev);
#line 77
    tmp___0 = __errno_location();
#line 77
    *tmp___0 = 1;
    }
#line 78
    return (-1);
  }
  {
#line 80
  ret = rpc_rquota_set((1024 << 8) | ((dquot->dq_h)->qh_type & 255), dquot);
  }
#line 80
  if (ret < 0) {
    {
#line 81
    tmp___1 = __errno_location();
#line 81
    *tmp___1 = - ret;
    }
#line 82
    return (-1);
  }
#line 84
  return (0);
}
}
#line 45 "/home/wheatley/newnew/temp/quota-4.01/quotaio_tree.c"
static int get_index___0(qid_t id___0 , int depth ) 
{ 


  {
#line 47
  return ((int )((id___0 >> ((4 - depth) - 1) * 8) & 255U));
}
}
#line 51 "/home/wheatley/newnew/temp/quota-4.01/quotaio_tree.c"
static void read_blk___0(struct quota_handle *h , uint blk , dqbuf_t buf ) 
{ 
  int err ;
  ssize_t tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 55
  lseek(h->qh_fd, (__off64_t )(blk << 10), 0);
#line 56
  tmp = read(h->qh_fd, (void *)buf, (size_t )(1 << 10));
#line 56
  err = (int )tmp;
  }
#line 57
  if (err < 0) {
    {
#line 58
    tmp___0 = __errno_location();
#line 58
    tmp___1 = strerror(*tmp___0);
#line 58
    tmp___2 = gettext("Cannot read block %u: %s\n");
#line 58
    die(2, tmp___2, blk, tmp___1);
    }
  } else
#line 59
  if (err != 1 << 10) {
    {
#line 60
    memset((void *)(buf + err), 0, (size_t )((1 << 10) - err));
    }
  }
#line 61
  return;
}
}
#line 64 "/home/wheatley/newnew/temp/quota-4.01/quotaio_tree.c"
static int write_blk___0(struct quota_handle *h , uint blk , dqbuf_t buf ) 
{ 
  int err ;
  ssize_t tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  int *tmp___3 ;

  {
  {
#line 68
  lseek(h->qh_fd, (__off64_t )(blk << 10), 0);
#line 69
  tmp = write(h->qh_fd, (void const   *)buf, (size_t )(1 << 10));
#line 69
  err = (int )tmp;
  }
#line 70
  if (err < 0) {
    {
#line 70
    tmp___3 = __errno_location();
    }
#line 70
    if (*tmp___3 != 28) {
      {
#line 71
      tmp___0 = __errno_location();
#line 71
      tmp___1 = strerror(*tmp___0);
#line 71
      tmp___2 = gettext("Cannot write block (%u): %s\n");
#line 71
      die(2, tmp___2, blk, tmp___1);
      }
    }
  }
#line 72
  if (err != 1 << 10) {
#line 73
    return (-28);
  }
#line 74
  return (0);
}
}
#line 78 "/home/wheatley/newnew/temp/quota-4.01/quotaio_tree.c"
static int get_free_dqblk___0(struct quota_handle *h ) 
{ 
  dqbuf_t buf ;
  void *tmp ;
  struct qt_disk_dqdbheader *dh ;
  struct qtree_mem_dqinfo *info ;
  int blk ;
  char *tmp___0 ;
  int tmp___1 ;
  unsigned int tmp___2 ;

  {
  {
#line 80
  tmp = smalloc((size_t )(1 << 10));
#line 80
  buf = (dqbuf_t )tmp;
#line 81
  dh = (struct qt_disk_dqdbheader *)buf;
#line 82
  info = & h->qh_info.u.v2_mdqi.dqi_qtree;
  }
#line 85
  if (info->dqi_free_blk) {
    {
#line 86
    blk = (int )info->dqi_free_blk;
#line 87
    read_blk___0(h, (uint )blk, buf);
#line 88
    info->dqi_free_blk = dh->dqdh_next_free;
    }
  } else {
    {
#line 91
    memset((void *)buf, 0, (size_t )(1 << 10));
#line 92
    tmp___1 = write_blk___0(h, info->dqi_blocks, buf);
    }
#line 92
    if (tmp___1 < 0) {
      {
#line 93
      free((void *)buf);
#line 94
      tmp___0 = gettext("Cannot allocate new quota block (out of disk space).\n");
#line 94
      errstr(tmp___0);
      }
#line 95
      return (-28);
    }
#line 97
    tmp___2 = info->dqi_blocks;
#line 97
    (info->dqi_blocks) ++;
#line 97
    blk = (int )tmp___2;
  }
  {
#line 99
  mark_quotafile_info_dirty(h);
#line 100
  free((void *)buf);
  }
#line 101
  return (blk);
}
}
#line 105 "/home/wheatley/newnew/temp/quota-4.01/quotaio_tree.c"
static void put_free_dqblk___0(struct quota_handle *h , dqbuf_t buf , uint blk ) 
{ 
  struct qt_disk_dqdbheader *dh ;
  struct qtree_mem_dqinfo *info ;

  {
  {
#line 107
  dh = (struct qt_disk_dqdbheader *)buf;
#line 108
  info = & h->qh_info.u.v2_mdqi.dqi_qtree;
#line 110
  dh->dqdh_next_free = info->dqi_free_blk;
#line 111
  dh->dqdh_prev_free = (__u32 )0;
#line 112
  dh->dqdh_entries = (__u16 )0;
#line 113
  info->dqi_free_blk = blk;
#line 114
  mark_quotafile_info_dirty(h);
#line 115
  write_blk___0(h, blk, buf);
  }
#line 116
  return;
}
}
#line 119 "/home/wheatley/newnew/temp/quota-4.01/quotaio_tree.c"
static void remove_free_dqentry___0(struct quota_handle *h , dqbuf_t buf , uint blk ) 
{ 
  dqbuf_t tmpbuf ;
  void *tmp ;
  struct qt_disk_dqdbheader *dh ;
  uint nextblk ;
  uint prevblk ;
  u_int32_t tmp___0 ;

  {
  {
#line 121
  tmp = smalloc((size_t )(1 << 10));
#line 121
  tmpbuf = (dqbuf_t )tmp;
#line 122
  dh = (struct qt_disk_dqdbheader *)buf;
#line 123
  nextblk = dh->dqdh_next_free;
#line 123
  prevblk = dh->dqdh_prev_free;
  }
#line 127
  if (nextblk) {
    {
#line 128
    read_blk___0(h, nextblk, tmpbuf);
#line 129
    ((struct qt_disk_dqdbheader *)tmpbuf)->dqdh_prev_free = dh->dqdh_prev_free;
#line 130
    write_blk___0(h, nextblk, tmpbuf);
    }
  }
#line 132
  if (prevblk) {
    {
#line 133
    read_blk___0(h, prevblk, tmpbuf);
#line 134
    ((struct qt_disk_dqdbheader *)tmpbuf)->dqdh_next_free = dh->dqdh_next_free;
#line 135
    write_blk___0(h, prevblk, tmpbuf);
    }
  } else {
    {
#line 138
    h->qh_info.u.v2_mdqi.dqi_qtree.dqi_free_entry = nextblk;
#line 139
    mark_quotafile_info_dirty(h);
    }
  }
  {
#line 141
  free((void *)tmpbuf);
#line 142
  tmp___0 = (__u32 )0;
#line 142
  dh->dqdh_prev_free = tmp___0;
#line 142
  dh->dqdh_next_free = tmp___0;
#line 143
  write_blk___0(h, blk, buf);
  }
#line 144
  return;
}
}
#line 147 "/home/wheatley/newnew/temp/quota-4.01/quotaio_tree.c"
static void insert_free_dqentry___0(struct quota_handle *h , dqbuf_t buf , uint blk ) 
{ 
  dqbuf_t tmpbuf ;
  void *tmp ;
  struct qt_disk_dqdbheader *dh ;
  struct qtree_mem_dqinfo *info ;

  {
  {
#line 149
  tmp = smalloc((size_t )(1 << 10));
#line 149
  tmpbuf = (dqbuf_t )tmp;
#line 150
  dh = (struct qt_disk_dqdbheader *)buf;
#line 151
  info = & h->qh_info.u.v2_mdqi.dqi_qtree;
#line 153
  dh->dqdh_next_free = info->dqi_free_entry;
#line 154
  dh->dqdh_prev_free = (__u32 )0;
#line 155
  write_blk___0(h, blk, buf);
  }
#line 156
  if (info->dqi_free_entry) {
    {
#line 157
    read_blk___0(h, info->dqi_free_entry, tmpbuf);
#line 158
    ((struct qt_disk_dqdbheader *)tmpbuf)->dqdh_prev_free = blk;
#line 159
    write_blk___0(h, info->dqi_free_entry, tmpbuf);
    }
  }
  {
#line 161
  free((void *)tmpbuf);
#line 162
  info->dqi_free_entry = blk;
#line 163
  mark_quotafile_info_dirty(h);
  }
#line 164
  return;
}
}
#line 167 "/home/wheatley/newnew/temp/quota-4.01/quotaio_tree.c"
static uint find_free_dqentry___0(struct quota_handle *h , struct dquot *dquot , int *err ) 
{ 
  int blk ;
  int i ;
  struct qt_disk_dqdbheader *dh ;
  struct qtree_mem_dqinfo *info ;
  char *ddquot ;
  dqbuf_t buf ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;

  {
  {
#line 171
  info = & h->qh_info.u.v2_mdqi.dqi_qtree;
#line 175
  *err = 0;
#line 176
  tmp = smalloc((size_t )(1 << 10));
#line 176
  buf = (dqbuf_t )tmp;
#line 177
  dh = (struct qt_disk_dqdbheader *)buf;
  }
#line 178
  if (info->dqi_free_entry) {
    {
#line 179
    blk = (int )info->dqi_free_entry;
#line 180
    read_blk___0(h, (uint )blk, buf);
    }
  } else {
    {
#line 183
    blk = get_free_dqblk___0(h);
    }
#line 184
    if (blk < 0) {
      {
#line 185
      free((void *)buf);
#line 186
      *err = blk;
      }
#line 187
      return ((uint )0);
    }
    {
#line 189
    memset((void *)buf, 0, (size_t )(1 << 10));
#line 190
    info->dqi_free_entry = (unsigned int )blk;
#line 191
    mark_quotafile_info_dirty(h);
    }
  }
  {
#line 193
  tmp___0 = qtree_dqstr_in_blk(info);
  }
#line 193
  if ((int )dh->dqdh_entries + 1 >= tmp___0) {
    {
#line 194
    remove_free_dqentry___0(h, buf, (uint )blk);
    }
  }
#line 195
  dh->dqdh_entries = (__u16 )((int )dh->dqdh_entries + 1);
#line 197
  ddquot = buf + sizeof(struct qt_disk_dqdbheader );
#line 198
  i = 0;
  {
#line 198
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 198
    tmp___1 = qtree_dqstr_in_blk(info);
    }
#line 198
    if (i < tmp___1) {
      {
#line 198
      tmp___2 = qtree_entry_unused(info, ddquot);
      }
#line 198
      if (tmp___2) {
#line 198
        goto while_break;
      }
    } else {
#line 198
      goto while_break;
    }
#line 198
    i ++;
#line 198
    ddquot += info->dqi_entry_size;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 201
  tmp___4 = qtree_dqstr_in_blk(info);
  }
#line 201
  if (i == tmp___4) {
    {
#line 202
    tmp___3 = gettext("find_free_dqentry(): Data block full but it shouldn\'t.\n");
#line 202
    die(2, tmp___3);
    }
  }
  {
#line 203
  write_blk___0(h, (uint )blk, buf);
#line 204
  dquot->dq_dqb.u.v2_mdqb.dqb_off = (loff_t )(((unsigned long )(blk << 10) + sizeof(struct qt_disk_dqdbheader )) + (unsigned long )((unsigned int )i * info->dqi_entry_size));
#line 207
  free((void *)buf);
  }
#line 208
  return ((uint )blk);
}
}
#line 212 "/home/wheatley/newnew/temp/quota-4.01/quotaio_tree.c"
static int do_insert_tree___0(struct quota_handle *h , struct dquot *dquot , uint *treeblk ,
                              int depth ) 
{ 
  dqbuf_t buf ;
  int newson ;
  int newact ;
  u_int32_t *ref ;
  uint newblk ;
  int ret ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;

  {
  {
#line 215
  newson = 0;
#line 215
  newact = 0;
#line 218
  ret = 0;
#line 220
  tmp = smalloc((size_t )(1 << 10));
#line 220
  buf = (dqbuf_t )tmp;
  }
#line 221
  if (! *treeblk) {
    {
#line 222
    ret = get_free_dqblk___0(h);
    }
#line 223
    if (ret < 0) {
#line 224
      goto out_buf;
    }
    {
#line 225
    *treeblk = (uint )ret;
#line 226
    memset((void *)buf, 0, (size_t )(1 << 10));
#line 227
    newact = 1;
    }
  } else {
    {
#line 230
    read_blk___0(h, *treeblk, buf);
    }
  }
  {
#line 231
  ref = (u_int32_t *)buf;
#line 232
  tmp___0 = get_index___0(dquot->dq_id, depth);
#line 232
  newblk = *(ref + tmp___0);
  }
#line 233
  if (! newblk) {
#line 234
    newson = 1;
  }
#line 235
  if (depth == 3) {
#line 236
    if (newblk) {
      {
#line 237
      tmp___1 = get_index___0(dquot->dq_id, depth);
#line 237
      tmp___2 = gettext("Inserting already present quota entry (block %u).\n");
#line 237
      die(2, tmp___2, *(ref + tmp___1));
      }
    }
    {
#line 239
    newblk = find_free_dqentry___0(h, dquot, & ret);
    }
  } else {
    {
#line 242
    ret = do_insert_tree___0(h, dquot, & newblk, depth + 1);
    }
  }
#line 243
  if (newson) {
#line 243
    if (ret >= 0) {
      {
#line 244
      tmp___3 = get_index___0(dquot->dq_id, depth);
#line 244
      *(ref + tmp___3) = newblk;
#line 245
      write_blk___0(h, *treeblk, buf);
      }
    } else {
#line 243
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 247
  if (newact) {
#line 247
    if (ret < 0) {
      {
#line 248
      put_free_dqblk___0(h, buf, *treeblk);
      }
    }
  }
  out_buf: 
  {
#line 250
  free((void *)buf);
  }
#line 251
  return (ret);
}
}
#line 255 "/home/wheatley/newnew/temp/quota-4.01/quotaio_tree.c"
static void dq_insert_tree___0(struct quota_handle *h , struct dquot *dquot ) 
{ 
  uint tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;

  {
  {
#line 257
  tmp = (uint )1;
#line 259
  tmp___3 = do_insert_tree___0(h, dquot, & tmp, 0);
  }
#line 259
  if (tmp___3 < 0) {
    {
#line 260
    tmp___0 = __errno_location();
#line 260
    tmp___1 = strerror(*tmp___0);
#line 260
    tmp___2 = gettext("Cannot write quota (id %u): %s\n");
#line 260
    die(2, tmp___2, dquot->dq_id, tmp___1);
    }
  }
#line 261
  return;
}
}
#line 284 "/home/wheatley/newnew/temp/quota-4.01/quotaio_tree.c"
static void free_dqentry___0(struct quota_handle *h , struct dquot *dquot , uint blk ) 
{ 
  struct qt_disk_dqdbheader *dh ;
  struct qtree_mem_dqinfo *info ;
  dqbuf_t buf ;
  void *tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 287
  info = & h->qh_info.u.v2_mdqi.dqi_qtree;
#line 288
  tmp = smalloc((size_t )(1 << 10));
#line 288
  buf = (dqbuf_t )tmp;
  }
#line 290
  if (dquot->dq_dqb.u.v2_mdqb.dqb_off >> 10 != (loff_t )blk) {
    {
#line 291
    tmp___0 = gettext("Quota structure has offset to other block (%u) than it should (%u).\n");
#line 291
    die(2, tmp___0, blk, (uint )(dquot->dq_dqb.u.v2_mdqb.dqb_off >> 10));
    }
  }
  {
#line 293
  read_blk___0(h, blk, buf);
#line 294
  dh = (struct qt_disk_dqdbheader *)buf;
#line 295
  dh->dqdh_entries = (__u16 )((int )dh->dqdh_entries - 1);
  }
#line 296
  if (! dh->dqdh_entries) {
    {
#line 297
    remove_free_dqentry___0(h, buf, blk);
#line 298
    put_free_dqblk___0(h, buf, blk);
    }
  } else {
    {
#line 301
    memset((void *)(buf + (dquot->dq_dqb.u.v2_mdqb.dqb_off & (long )((1 << 10) - 1))),
           0, (size_t )info->dqi_entry_size);
#line 304
    tmp___1 = qtree_dqstr_in_blk(info);
    }
#line 304
    if ((int )dh->dqdh_entries == tmp___1 - 1) {
      {
#line 305
      insert_free_dqentry___0(h, buf, blk);
      }
    } else {
      {
#line 307
      write_blk___0(h, blk, buf);
      }
    }
  }
  {
#line 309
  dquot->dq_dqb.u.v2_mdqb.dqb_off = (loff_t )0;
#line 310
  free((void *)buf);
  }
#line 311
  return;
}
}
#line 314 "/home/wheatley/newnew/temp/quota-4.01/quotaio_tree.c"
static void remove_tree___0(struct quota_handle *h , struct dquot *dquot , uint *blk ,
                            int depth ) 
{ 
  dqbuf_t buf ;
  void *tmp ;
  uint newblk ;
  u_int32_t *ref ;
  int tmp___0 ;
  int i ;
  int tmp___1 ;

  {
  {
#line 316
  tmp = smalloc((size_t )(1 << 10));
#line 316
  buf = (dqbuf_t )tmp;
#line 318
  ref = (u_int32_t *)buf;
#line 320
  read_blk___0(h, *blk, buf);
#line 321
  tmp___0 = get_index___0(dquot->dq_id, depth);
#line 321
  newblk = *(ref + tmp___0);
  }
#line 322
  if (depth == 3) {
    {
#line 323
    free_dqentry___0(h, dquot, newblk);
#line 324
    newblk = (uint )0;
    }
  } else {
    {
#line 327
    remove_tree___0(h, dquot, & newblk, depth + 1);
    }
  }
#line 328
  if (! newblk) {
    {
#line 331
    tmp___1 = get_index___0(dquot->dq_id, depth);
#line 331
    *(ref + tmp___1) = (__u32 )0;
#line 332
    i = 0;
    }
    {
#line 332
    while (1) {
      while_continue: /* CIL Label */ ;
#line 332
      if (i < 1 << 10) {
#line 332
        if (! (! *(buf + i))) {
#line 332
          goto while_break;
        }
      } else {
#line 332
        goto while_break;
      }
#line 332
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 334
    if (i == 1 << 10) {
#line 334
      if (*blk != 1U) {
        {
#line 335
        put_free_dqblk___0(h, buf, *blk);
#line 336
        *blk = (uint )0;
        }
      } else {
        {
#line 339
        write_blk___0(h, *blk, buf);
        }
      }
    } else {
      {
#line 339
      write_blk___0(h, *blk, buf);
      }
    }
  }
  {
#line 341
  free((void *)buf);
  }
#line 342
  return;
}
}
#line 355 "/home/wheatley/newnew/temp/quota-4.01/quotaio_tree.c"
static loff_t find_block_dqentry___0(struct quota_handle *h , struct dquot *dquot ,
                                     uint blk ) 
{ 
  struct qtree_mem_dqinfo *info ;
  dqbuf_t buf ;
  void *tmp ;
  int i ;
  char *ddquot ;
  int tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;

  {
  {
#line 357
  info = & h->qh_info.u.v2_mdqi.dqi_qtree;
#line 358
  tmp = smalloc((size_t )(1 << 10));
#line 358
  buf = (dqbuf_t )tmp;
#line 360
  ddquot = buf + sizeof(struct qt_disk_dqdbheader );
#line 362
  read_blk___0(h, blk, buf);
#line 363
  i = 0;
  }
  {
#line 363
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 363
    tmp___0 = qtree_dqstr_in_blk(info);
    }
#line 363
    if (i < tmp___0) {
      {
#line 363
      tmp___1 = (*((info->dqi_ops)->is_id))((void *)ddquot, dquot);
      }
#line 363
      if (tmp___1) {
#line 363
        goto while_break;
      }
    } else {
#line 363
      goto while_break;
    }
#line 363
    i ++;
#line 363
    ddquot += info->dqi_entry_size;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 366
  tmp___3 = qtree_dqstr_in_blk(info);
  }
#line 366
  if (i == tmp___3) {
    {
#line 367
    tmp___2 = gettext("Quota for id %u referenced but not present.\n");
#line 367
    die(2, tmp___2, dquot->dq_id);
    }
  }
  {
#line 368
  free((void *)buf);
  }
#line 369
  return ((loff_t )(((unsigned long )(blk << 10) + sizeof(struct qt_disk_dqdbheader )) + (unsigned long )((unsigned int )i * info->dqi_entry_size)));
}
}
#line 374 "/home/wheatley/newnew/temp/quota-4.01/quotaio_tree.c"
static loff_t find_tree_dqentry___0(struct quota_handle *h , struct dquot *dquot ,
                                    uint blk , int depth ) 
{ 
  dqbuf_t buf ;
  void *tmp ;
  loff_t ret ;
  u_int32_t *ref ;
  int tmp___0 ;

  {
  {
#line 376
  tmp = smalloc((size_t )(1 << 10));
#line 376
  buf = (dqbuf_t )tmp;
#line 377
  ret = (loff_t )0;
#line 378
  ref = (u_int32_t *)buf;
#line 380
  read_blk___0(h, blk, buf);
#line 381
  ret = (loff_t )0;
#line 382
  tmp___0 = get_index___0(dquot->dq_id, depth);
#line 382
  blk = *(ref + tmp___0);
  }
#line 383
  if (! blk) {
#line 384
    goto out_buf;
  }
#line 385
  if (depth < 3) {
    {
#line 386
    ret = find_tree_dqentry___0(h, dquot, blk, depth + 1);
    }
  } else {
    {
#line 388
    ret = find_block_dqentry___0(h, dquot, blk);
    }
  }
  out_buf: 
  {
#line 390
  free((void *)buf);
  }
#line 391
  return (ret);
}
}
#line 395 "/home/wheatley/newnew/temp/quota-4.01/quotaio_tree.c"
__inline static loff_t find_dqentry___0(struct quota_handle *h , struct dquot *dquot ) 
{ 
  loff_t tmp ;

  {
  {
#line 397
  tmp = find_tree_dqentry___0(h, dquot, (uint )1, 0);
  }
#line 397
  return (tmp);
}
}
#line 441 "/home/wheatley/newnew/temp/quota-4.01/quotaio_tree.c"
static int report_block___0(struct dquot *dquot , uint blk , char *bitmap , int (*process_dquot)(struct dquot * ,
                                                                                                 char * ) ) 
{ 
  struct qtree_mem_dqinfo *info ;
  dqbuf_t buf ;
  void *tmp ;
  struct qt_disk_dqdbheader *dh ;
  char *ddata ;
  int entries ;
  int i ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 444
  info = & (dquot->dq_h)->qh_info.u.v2_mdqi.dqi_qtree;
#line 445
  tmp = smalloc((size_t )(1 << 10));
#line 445
  buf = (dqbuf_t )tmp;
#line 450
  *(bitmap + (blk >> 3)) = (char )((int )*(bitmap + (blk >> 3)) | (1 << (blk & 7U)));
#line 451
  read_blk___0(dquot->dq_h, blk, buf);
#line 452
  dh = (struct qt_disk_dqdbheader *)buf;
#line 453
  ddata = buf + sizeof(struct qt_disk_dqdbheader );
#line 454
  entries = (int )dh->dqdh_entries;
#line 455
  i = 0;
  }
  {
#line 455
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 455
    tmp___2 = qtree_dqstr_in_blk(info);
    }
#line 455
    if (! (i < tmp___2)) {
#line 455
      goto while_break;
    }
    {
#line 456
    tmp___1 = qtree_entry_unused(info, ddata);
    }
#line 456
    if (! tmp___1) {
      {
#line 457
      (*((info->dqi_ops)->disk2mem_dqblk))(dquot, (void *)ddata);
#line 458
      tmp___0 = (*process_dquot)(dquot, (char *)((void *)0));
      }
#line 458
      if (tmp___0 < 0) {
#line 459
        goto while_break;
      }
    }
#line 455
    i ++;
#line 455
    ddata += info->dqi_entry_size;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 461
  free((void *)buf);
  }
#line 462
  return (entries);
}
}
#line 465 "/home/wheatley/newnew/temp/quota-4.01/quotaio_tree.c"
static void check_reference___0(struct quota_handle *h , uint blk ) 
{ 
  char *tmp ;
  char *tmp___0 ;

  {
#line 467
  if (blk >= h->qh_info.u.v2_mdqi.dqi_qtree.dqi_blocks) {
    {
#line 468
    tmp = type2name(h->qh_type);
#line 468
    tmp___0 = gettext("Illegal reference (%u >= %u) in %s quota file on %s. Quota file is probably corrupted.\nPlease run quotacheck(8) and try again.\n");
#line 468
    die(2, tmp___0, blk, h->qh_info.u.v2_mdqi.dqi_qtree.dqi_blocks, tmp, h->qh_quotadev);
    }
  }
#line 469
  return;
}
}
#line 471 "/home/wheatley/newnew/temp/quota-4.01/quotaio_tree.c"
static int report_tree___0(struct dquot *dquot , uint blk , int depth , char *bitmap ,
                           int (*process_dquot)(struct dquot * , char * ) ) 
{ 
  int entries ;
  int i ;
  dqbuf_t buf ;
  void *tmp ;
  u_int32_t *ref ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 474
  entries = 0;
#line 475
  tmp = smalloc((size_t )(1 << 10));
#line 475
  buf = (dqbuf_t )tmp;
#line 476
  ref = (u_int32_t *)buf;
#line 478
  read_blk___0(dquot->dq_h, blk, buf);
  }
#line 479
  if (depth == 3) {
#line 480
    i = 0;
    {
#line 480
    while (1) {
      while_continue: /* CIL Label */ ;
#line 480
      if (! (i < (1 << 10) >> 2)) {
#line 480
        goto while_break;
      }
      {
#line 481
      blk = *(ref + i);
#line 482
      check_reference___0(dquot->dq_h, blk);
      }
#line 483
      if (blk) {
#line 483
        if (! ((int )*(bitmap + (blk >> 3)) & (1 << (blk & 7U)))) {
          {
#line 484
          tmp___0 = report_block___0(dquot, blk, bitmap, process_dquot);
#line 484
          entries += tmp___0;
          }
        }
      }
#line 480
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 488
    i = 0;
    {
#line 488
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 488
      if (! (i < (1 << 10) >> 2)) {
#line 488
        goto while_break___0;
      }
#line 489
      blk = *(ref + i);
#line 489
      if (blk) {
        {
#line 490
        check_reference___0(dquot->dq_h, blk);
#line 491
        tmp___1 = report_tree___0(dquot, blk, depth + 1, bitmap, process_dquot);
#line 491
        entries += tmp___1;
        }
      }
#line 488
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  {
#line 495
  free((void *)buf);
  }
#line 496
  return (entries);
}
}
#line 499 "/home/wheatley/newnew/temp/quota-4.01/quotaio_tree.c"
static uint find_set_bits___0(char *bmp , int blocks ) 
{ 
  uint i ;
  uint used ;

  {
#line 501
  used = (uint )0;
#line 503
  i = (uint )0;
  {
#line 503
  while (1) {
    while_continue: /* CIL Label */ ;
#line 503
    if (! (i < (uint )blocks)) {
#line 503
      goto while_break;
    }
#line 504
    if ((int )*(bmp + (i >> 3)) & (1 << (i & 7U))) {
#line 505
      used ++;
    }
#line 503
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 506
  return (used);
}
}
#line 221 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) sigaddset)(sigset_t *__set ,
                                                                                                int __signo ) ;
#line 248
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sigprocmask)(int __how ,
                                                                                  sigset_t const   * __restrict  __set ,
                                                                                  sigset_t * __restrict  __oset ) ;
#line 306 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) FILE *( __attribute__((__leaf__)) fdopen)(int __fd ,
                                                                               char const   *__modes ) ;
#line 125 "/usr/include/x86_64-linux-gnu/sys/wait.h"
extern __pid_t waitpid(__pid_t __pid , int *__stat_loc , int __options ) ;
#line 531 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) dup)(int __fd ) ;
#line 578
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) execvp)(char const   *__file ,
                                                                                               char * const  *__argv ) ;
#line 619
extern  __attribute__((__nothrow__)) long ( __attribute__((__leaf__)) sysconf)(int __name ) ;
#line 689
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getgroups)(int __size ,
                                                                                __gid_t *__list ) ;
#line 700
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setuid)(__uid_t __uid ) ;
#line 717
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setgid)(__gid_t __gid ) ;
#line 756
extern  __attribute__((__nothrow__)) __pid_t fork(void) ;
#line 1019
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ftruncate)(int __fd ,
                                                                                __off64_t __length )  __asm__("ftruncate64")  ;
#line 68 "/home/wheatley/newnew/temp/quota-4.01/quotaops.c"
void update_grace_times(struct dquot *q ) 
{ 
  time_t now___0 ;

  {
  {
#line 72
  time(& now___0);
  }
#line 73
  if (q->dq_dqb.dqb_bsoftlimit) {
#line 73
    if (((q->dq_dqb.dqb_curspace + (qsize_t )(1 << 10)) - 1L) >> 10 > q->dq_dqb.dqb_bsoftlimit) {
#line 74
      if (! q->dq_dqb.dqb_btime) {
#line 75
        q->dq_dqb.dqb_btime = now___0 + (q->dq_h)->qh_info.dqi_bgrace;
      }
    } else {
#line 78
      q->dq_dqb.dqb_btime = (time_t )0;
    }
  } else {
#line 78
    q->dq_dqb.dqb_btime = (time_t )0;
  }
#line 79
  if (q->dq_dqb.dqb_isoftlimit) {
#line 79
    if (q->dq_dqb.dqb_curinodes > q->dq_dqb.dqb_isoftlimit) {
#line 80
      if (! q->dq_dqb.dqb_itime) {
#line 81
        q->dq_dqb.dqb_itime = now___0 + (q->dq_h)->qh_info.dqi_igrace;
      }
    } else {
#line 84
      q->dq_dqb.dqb_itime = (time_t )0;
    }
  } else {
#line 84
    q->dq_dqb.dqb_itime = (time_t )0;
  }
#line 85
  return;
}
}
#line 90 "/home/wheatley/newnew/temp/quota-4.01/quotaops.c"
struct dquot *getprivs(qid_t id___0 , struct quota_handle **handles , int quiet ) 
{ 
  struct dquot *q ;
  struct dquot *qtail ;
  struct dquot *qhead ;
  int i ;
  char name[64] ;
  int j ;
  int ngroups ;
  uid_t euid ;
  gid_t gidset[65536] ;
  gid_t *gidsetp ;
  char *tmp ;
  __uid_t tmp___0 ;
  long tmp___1 ;
  void *tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  int *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  int olderrno ;
  int *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  int *tmp___13 ;
  int *tmp___14 ;

  {
#line 92
  qtail = (struct dquot *)((void *)0);
#line 92
  qhead = (struct dquot *)((void *)0);
#line 101
  i = 0;
  {
#line 101
  while (1) {
    while_continue: /* CIL Label */ ;
#line 101
    if (! *(handles + i)) {
#line 101
      goto while_break;
    }
    {
#line 104
    if ((*(handles + i))->qh_type == 0) {
#line 104
      goto case_0;
    }
#line 112
    if ((*(handles + i))->qh_type == 1) {
#line 112
      goto case_1;
    }
#line 147
    goto switch_default;
    case_0: /* CIL Label */ 
    {
#line 105
    euid = geteuid();
    }
#line 106
    if (euid != id___0) {
#line 106
      if (euid != 0U) {
        {
#line 107
        uid2user(id___0, name);
#line 108
        tmp = gettext("%s (uid %d): Permission denied\n");
#line 108
        errstr(tmp, name, id___0);
        }
#line 109
        return ((struct dquot *)((void *)0));
      }
    }
#line 111
    goto switch_break;
    case_1: /* CIL Label */ 
    {
#line 113
    tmp___0 = geteuid();
    }
#line 113
    if (tmp___0 == 0U) {
#line 114
      goto switch_break;
    }
    {
#line 115
    tmp___1 = sysconf(3);
#line 115
    ngroups = (int )tmp___1;
    }
#line 116
    if (ngroups > 65536) {
      {
#line 117
      tmp___2 = malloc((unsigned long )ngroups * sizeof(gid_t ));
#line 117
      gidsetp = (gid_t *)tmp___2;
      }
#line 118
      if (! gidsetp) {
        {
#line 119
        gid2group(id___0, name);
#line 120
        tmp___3 = __errno_location();
#line 120
        tmp___4 = strerror(*tmp___3);
#line 120
        tmp___5 = gettext("%s (gid %d): gid set allocation (%d): %s\n");
#line 120
        errstr(tmp___5, name, id___0, ngroups, tmp___4);
        }
#line 121
        return ((struct dquot *)((void *)0));
      }
    } else {
#line 125
      gidsetp = & gidset[0];
    }
    {
#line 126
    ngroups = getgroups(ngroups, gidsetp);
    }
#line 127
    if (ngroups < 0) {
#line 128
      if ((unsigned long )gidsetp != (unsigned long )(gidset)) {
        {
#line 129
        free((void *)gidsetp);
        }
      }
      {
#line 130
      gid2group(id___0, name);
#line 131
      tmp___6 = __errno_location();
#line 131
      tmp___7 = strerror(*tmp___6);
#line 131
      tmp___8 = gettext("%s (gid %d): error while trying getgroups(): %s\n");
#line 131
      errstr(tmp___8, name, id___0, tmp___7);
      }
#line 132
      return ((struct dquot *)((void *)0));
    }
#line 135
    j = 0;
    {
#line 135
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 135
      if (! (j < ngroups)) {
#line 135
        goto while_break___0;
      }
#line 136
      if (id___0 == *(gidsetp + j)) {
#line 137
        goto while_break___0;
      }
#line 135
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 138
    if ((unsigned long )gidsetp != (unsigned long )(gidset)) {
      {
#line 139
      free((void *)gidsetp);
      }
    }
#line 140
    if (j >= ngroups) {
      {
#line 141
      gid2group(id___0, name);
#line 142
      tmp___9 = gettext("%s (gid %d): Permission denied\n");
#line 142
      errstr(tmp___9, name, id___0);
      }
#line 144
      return ((struct dquot *)((void *)0));
    }
#line 146
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 148
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
    {
#line 152
    q = (*(((*(handles + i))->qh_ops)->read_dquot))(*(handles + i), id___0);
    }
#line 152
    if (! q) {
      {
#line 154
      tmp___13 = __errno_location();
      }
#line 154
      if (*tmp___13 != 2) {
        {
#line 154
        tmp___14 = __errno_location();
        }
#line 154
        if (*tmp___14 != 111) {
#line 154
          goto _L;
        } else
#line 154
        if (! quiet) {
          _L: /* CIL Label */ 
          {
#line 155
          tmp___10 = __errno_location();
#line 155
          olderrno = *tmp___10;
#line 157
          id2name((int )id___0, (*(handles + i))->qh_type, name);
#line 158
          tmp___11 = strerror(olderrno);
#line 158
          tmp___12 = gettext("error while getting quota from %s for %s (id %u): %s\n");
#line 158
          errstr(tmp___12, (*(handles + i))->qh_quotadev, name, id___0, tmp___11);
          }
        }
      }
#line 161
      goto __Cont;
    }
#line 163
    if ((unsigned long )qhead == (unsigned long )((void *)0)) {
#line 164
      qhead = q;
    } else {
#line 166
      qtail->dq_next = q;
    }
#line 167
    qtail = q;
#line 168
    q->dq_next = (struct dquot *)((void *)0);
    __Cont: /* CIL Label */ 
#line 101
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 170
  return (qhead);
}
}
#line 176 "/home/wheatley/newnew/temp/quota-4.01/quotaops.c"
int putprivs(struct dquot *qlist , int flags___7 ) 
{ 
  struct dquot *q ;
  int ret ;
  int *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;

  {
#line 179
  ret = 0;
#line 181
  q = qlist;
  {
#line 181
  while (1) {
    while_continue: /* CIL Label */ ;
#line 181
    if (! q) {
#line 181
      goto while_break;
    }
    {
#line 182
    tmp___2 = (*(((q->dq_h)->qh_ops)->commit_dquot))(q, flags___7);
    }
#line 182
    if (tmp___2 == -1) {
      {
#line 183
      tmp = __errno_location();
#line 183
      tmp___0 = strerror(*tmp);
#line 183
      tmp___1 = gettext("Cannot write quota for %u on %s: %s\n");
#line 183
      errstr(tmp___1, q->dq_id, (q->dq_h)->qh_quotadev, tmp___0);
#line 185
      ret = -1;
      }
#line 186
      goto __Cont;
    }
    __Cont: /* CIL Label */ 
#line 181
    q = q->dq_next;
  }
  while_break: /* CIL Label */ ;
  }
#line 189
  return (ret);
}
}
#line 196 "/home/wheatley/newnew/temp/quota-4.01/quotaops.c"
int editprivs(char *tmpfile___0 ) 
{ 
  sigset_t omask ;
  sigset_t nmask ;
  pid_t pid ;
  int stat___0 ;
  int *tmp ;
  char *tmp___0 ;
  char *ed ;
  char *actp ;
  char *nextp ;
  char *edpars[128] ;
  int i ;
  __gid_t tmp___1 ;
  __uid_t tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  char *tmp___6 ;

  {
  {
#line 202
  sigemptyset(& nmask);
#line 203
  sigaddset(& nmask, 2);
#line 204
  sigaddset(& nmask, 3);
#line 205
  sigaddset(& nmask, 1);
#line 206
  sigprocmask(2, (sigset_t const   */* __restrict  */)(& nmask), (sigset_t */* __restrict  */)(& omask));
#line 207
  pid = fork();
  }
#line 207
  if (pid < 0) {
    {
#line 208
    tmp = __errno_location();
#line 208
    tmp___0 = strerror(*tmp);
#line 208
    errstr((char *)"Cannot fork(): %s\n", tmp___0);
    }
#line 209
    return (-1);
  }
#line 211
  if (pid == 0) {
    {
#line 216
    sigprocmask(2, (sigset_t const   */* __restrict  */)(& omask), (sigset_t */* __restrict  */)((void *)0));
#line 217
    tmp___1 = getgid();
#line 217
    setgid(tmp___1);
#line 218
    tmp___2 = getuid();
#line 218
    setuid(tmp___2);
#line 219
    ed = getenv("VISUAL");
    }
#line 219
    if (! ed) {
      {
#line 220
      ed = getenv("EDITOR");
      }
#line 220
      if (! ed) {
#line 221
        ed = (char *)"/usr/bin/vi";
      }
    }
    {
#line 222
    i = 0;
#line 223
    actp = sstrdup((char const   *)ed);
#line 223
    ed = actp;
    }
    {
#line 224
    while (1) {
      while_continue: /* CIL Label */ ;
#line 224
      if (! actp) {
#line 224
        goto while_break;
      }
      {
#line 225
      nextp = strchr((char const   *)actp, ' ');
      }
#line 226
      if (nextp) {
#line 227
        *nextp = (char)0;
#line 228
        nextp ++;
      }
#line 230
      tmp___3 = i;
#line 230
      i ++;
#line 230
      edpars[tmp___3] = actp;
#line 231
      if (i == 126) {
        {
#line 232
        tmp___4 = gettext("Too many parameters to editor.\n");
#line 232
        errstr(tmp___4);
        }
#line 233
        goto while_break;
      }
#line 235
      actp = nextp;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 237
    tmp___5 = i;
#line 237
    i ++;
#line 237
    edpars[tmp___5] = tmpfile___0;
#line 238
    edpars[i] = (char *)((void *)0);
#line 239
    execvp((char const   *)edpars[0], (char * const  *)(edpars));
#line 240
    tmp___6 = gettext("Cannot exec %s\n");
#line 240
    die(1, tmp___6, ed);
    }
  }
  {
#line 242
  waitpid(pid, & stat___0, 0);
#line 243
  sigprocmask(2, (sigset_t const   */* __restrict  */)(& omask), (sigset_t */* __restrict  */)((void *)0));
  }
#line 245
  return (0);
}
}
#line 251 "/home/wheatley/newnew/temp/quota-4.01/quotaops.c"
int writeprivs(struct dquot *qlist , int outfd , char *name , int quotatype___0 ) 
{ 
  struct dquot *q ;
  FILE *fd ;
  int *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;

  {
  {
#line 256
  ftruncate(outfd, (__off64_t )0);
#line 257
  lseek(outfd, (__off64_t )0, 0);
#line 258
  tmp___2 = dup(outfd);
#line 258
  fd = fdopen(tmp___2, "w");
  }
#line 258
  if (! fd) {
    {
#line 259
    tmp = __errno_location();
#line 259
    tmp___0 = strerror(*tmp);
#line 259
    tmp___1 = gettext("Cannot duplicate descriptor of file to write to: %s\n");
#line 259
    die(1, tmp___1, tmp___0);
    }
  }
  {
#line 261
  tmp___3 = type2name(quotatype___0);
#line 261
  tmp___4 = type2name(quotatype___0);
#line 261
  tmp___5 = gettext((char const   *)tmp___4);
#line 261
  tmp___6 = gettext("Disk quotas for %s %s (%cid %d):\n");
#line 261
  fprintf((FILE */* __restrict  */)fd, (char const   */* __restrict  */)tmp___6, tmp___5,
          name, (int )*tmp___3, qlist->dq_id);
#line 264
  tmp___7 = gettext("  Filesystem                   blocks       soft       hard     inodes     soft     hard\n");
#line 264
  fprintf((FILE */* __restrict  */)fd, (char const   */* __restrict  */)tmp___7);
#line 267
  q = qlist;
  }
  {
#line 267
  while (1) {
    while_continue: /* CIL Label */ ;
#line 267
    if (! q) {
#line 267
      goto while_break;
    }
    {
#line 268
    fprintf((FILE */* __restrict  */)fd, (char const   */* __restrict  */)"  %-24s %10llu %10llu %10llu %10llu %8llu %8llu\n",
            (q->dq_h)->qh_quotadev, (long long )(((q->dq_dqb.dqb_curspace + (qsize_t )(1 << 10)) - 1L) >> 10),
            (long long )q->dq_dqb.dqb_bsoftlimit, (long long )q->dq_dqb.dqb_bhardlimit,
            (long long )q->dq_dqb.dqb_curinodes, (long long )q->dq_dqb.dqb_isoftlimit,
            (long long )q->dq_dqb.dqb_ihardlimit);
#line 267
    q = q->dq_next;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 276
  fclose(fd);
  }
#line 277
  return (0);
}
}
#line 281 "/home/wheatley/newnew/temp/quota-4.01/quotaops.c"
static void merge_limits_to_list(struct dquot *qlist , char *dev , u_int64_t blocks ,
                                 u_int64_t bsoft , u_int64_t bhard , u_int64_t inodes ,
                                 u_int64_t isoft , u_int64_t ihard ) 
{ 
  struct dquot *q ;
  int tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
#line 286
  q = qlist;
  {
#line 286
  while (1) {
    while_continue: /* CIL Label */ ;
#line 286
    if (! q) {
#line 286
      goto while_break;
    }
    {
#line 287
    tmp = devcmp_handle((char const   *)dev, q->dq_h);
    }
#line 287
    if (! tmp) {
#line 288
      goto __Cont;
    }
    {
#line 290
    q->dq_dqb.dqb_bsoftlimit = (qsize_t )bsoft;
#line 291
    q->dq_dqb.dqb_bhardlimit = (qsize_t )bhard;
#line 292
    q->dq_dqb.dqb_isoftlimit = (qsize_t )isoft;
#line 293
    q->dq_dqb.dqb_ihardlimit = (qsize_t )ihard;
#line 294
    q->dq_flags |= 1;
#line 295
    update_grace_times(q);
    }
#line 297
    if (blocks != (u_int64_t )(((q->dq_dqb.dqb_curspace + (qsize_t )(1 << 10)) - 1L) >> 10)) {
      {
#line 298
      tmp___0 = gettext("WARNING - %s: cannot change current block allocation\n");
#line 298
      errstr(tmp___0, (q->dq_h)->qh_quotadev);
      }
    }
#line 300
    if (inodes != (u_int64_t )q->dq_dqb.dqb_curinodes) {
      {
#line 301
      tmp___1 = gettext("WARNING - %s: cannot change current inode allocation\n");
#line 301
      errstr(tmp___1, (q->dq_h)->qh_quotadev);
      }
    }
    __Cont: /* CIL Label */ 
#line 286
    q = q->dq_next;
  }
  while_break: /* CIL Label */ ;
  }
#line 304
  return;
}
}
#line 309 "/home/wheatley/newnew/temp/quota-4.01/quotaops.c"
int readprivs(struct dquot *qlist , int infd ) 
{ 
  FILE *fd ;
  int cnt ;
  long long blocks ;
  long long bsoft ;
  long long bhard ;
  long long inodes ;
  long long isoft ;
  long long ihard ;
  struct dquot *q ;
  char fsp[8192] ;
  char line___0[8192] ;
  int *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;

  {
  {
#line 317
  lseek(infd, (__off64_t )0, 0);
#line 318
  tmp___2 = dup(infd);
#line 318
  fd = fdopen(tmp___2, "r");
  }
#line 318
  if (! fd) {
    {
#line 319
    tmp = __errno_location();
#line 319
    tmp___0 = strerror(*tmp);
#line 319
    tmp___1 = gettext("Cannot duplicate descriptor of temp file: %s\n");
#line 319
    die(1, tmp___1, tmp___0);
    }
  }
  {
#line 324
  fgets((char */* __restrict  */)(line___0), (int )sizeof(line___0), (FILE */* __restrict  */)fd);
#line 325
  fgets((char */* __restrict  */)(line___0), (int )sizeof(line___0), (FILE */* __restrict  */)fd);
  }
  {
#line 327
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 327
    tmp___4 = fgets((char */* __restrict  */)(line___0), (int )sizeof(line___0), (FILE */* __restrict  */)fd);
    }
#line 327
    if (! tmp___4) {
#line 327
      goto while_break;
    }
    {
#line 328
    cnt = sscanf((char const   */* __restrict  */)(line___0), (char const   */* __restrict  */)"%s %llu %llu %llu %llu %llu %llu",
                 fsp, & blocks, & bsoft, & bhard, & inodes, & isoft, & ihard);
    }
#line 331
    if (cnt != 7) {
      {
#line 332
      tmp___3 = gettext("Bad format:\n%s\n");
#line 332
      errstr(tmp___3, line___0);
      }
#line 333
      return (-1);
    }
    {
#line 336
    merge_limits_to_list(qlist, fsp, (u_int64_t )blocks, (u_int64_t )bsoft, (u_int64_t )bhard,
                         (u_int64_t )inodes, (u_int64_t )isoft, (u_int64_t )ihard);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 338
  fclose(fd);
#line 343
  q = qlist;
  }
  {
#line 343
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 343
    if (! q) {
#line 343
      goto while_break___0;
    }
#line 344
    if (q->dq_flags & 1) {
#line 345
      q->dq_flags &= -2;
#line 346
      goto __Cont;
    }
#line 348
    q->dq_dqb.dqb_bsoftlimit = (qsize_t )0;
#line 349
    q->dq_dqb.dqb_bhardlimit = (qsize_t )0;
#line 350
    q->dq_dqb.dqb_isoftlimit = (qsize_t )0;
#line 351
    q->dq_dqb.dqb_ihardlimit = (qsize_t )0;
    __Cont: /* CIL Label */ 
#line 343
    q = q->dq_next;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 353
  return (0);
}
}
#line 357 "/home/wheatley/newnew/temp/quota-4.01/quotaops.c"
static void merge_times_to_list(struct dquot *qlist , char *dev , time_t btime , time_t itime ) 
{ 
  struct dquot *q ;
  int tmp ;

  {
#line 361
  q = qlist;
  {
#line 361
  while (1) {
    while_continue: /* CIL Label */ ;
#line 361
    if (! q) {
#line 361
      goto while_break;
    }
    {
#line 362
    tmp = devcmp_handle((char const   *)dev, q->dq_h);
    }
#line 362
    if (! tmp) {
#line 363
      goto __Cont;
    }
#line 365
    q->dq_dqb.dqb_btime = btime;
#line 366
    q->dq_dqb.dqb_itime = itime;
#line 367
    q->dq_flags |= 1;
    __Cont: /* CIL Label */ 
#line 361
    q = q->dq_next;
  }
  while_break: /* CIL Label */ ;
  }
#line 369
  return;
}
}
#line 374 "/home/wheatley/newnew/temp/quota-4.01/quotaops.c"
int writeindividualtimes(struct dquot *qlist , int outfd , char *name , int quotatype___0 ) 
{ 
  struct dquot *q ;
  FILE *fd ;
  time_t now___0 ;
  char btimestr[40] ;
  char itimestr[40] ;
  int *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;

  {
  {
#line 381
  ftruncate(outfd, (__off64_t )0);
#line 382
  lseek(outfd, (__off64_t )0, 0);
#line 383
  tmp___2 = dup(outfd);
#line 383
  fd = fdopen(tmp___2, "w");
  }
#line 383
  if (! fd) {
    {
#line 384
    tmp = __errno_location();
#line 384
    tmp___0 = strerror(*tmp);
#line 384
    tmp___1 = gettext("Cannot duplicate descriptor of file to write to: %s\n");
#line 384
    die(1, tmp___1, tmp___0);
    }
  }
  {
#line 386
  tmp___3 = type2name(quotatype___0);
#line 386
  tmp___4 = type2name(quotatype___0);
#line 386
  tmp___5 = gettext((char const   *)tmp___4);
#line 386
  tmp___6 = gettext("Times to enforce softlimit for %s %s (%cid %d):\n");
#line 386
  fprintf((FILE */* __restrict  */)fd, (char const   */* __restrict  */)tmp___6, tmp___5,
          name, (int )*tmp___3, qlist->dq_id);
#line 388
  tmp___7 = gettext("Time units may be: days, hours, minutes, or seconds\n");
#line 388
  fprintf((FILE */* __restrict  */)fd, (char const   */* __restrict  */)tmp___7);
#line 389
  tmp___8 = gettext("  Filesystem                         block grace               inode grace\n");
#line 389
  fprintf((FILE */* __restrict  */)fd, (char const   */* __restrict  */)tmp___8);
#line 392
  time(& now___0);
#line 393
  q = qlist;
  }
  {
#line 393
  while (1) {
    while_continue: /* CIL Label */ ;
#line 393
    if (! q) {
#line 393
      goto while_break;
    }
#line 394
    if (! q->dq_dqb.dqb_btime) {
      {
#line 395
      tmp___9 = gettext("unset");
#line 395
      strcpy((char */* __restrict  */)(btimestr), (char const   */* __restrict  */)tmp___9);
      }
    } else
#line 396
    if (q->dq_dqb.dqb_btime <= now___0) {
      {
#line 397
      tmp___10 = gettext("0seconds");
#line 397
      strcpy((char */* __restrict  */)(btimestr), (char const   */* __restrict  */)tmp___10);
      }
    } else {
      {
#line 399
      tmp___11 = gettext("%useconds");
#line 399
      sprintf((char */* __restrict  */)(btimestr), (char const   */* __restrict  */)tmp___11,
              (unsigned int )(q->dq_dqb.dqb_btime - now___0));
      }
    }
#line 400
    if (! q->dq_dqb.dqb_itime) {
      {
#line 401
      tmp___12 = gettext("unset");
#line 401
      strcpy((char */* __restrict  */)(itimestr), (char const   */* __restrict  */)tmp___12);
      }
    } else
#line 402
    if (q->dq_dqb.dqb_itime <= now___0) {
      {
#line 403
      tmp___13 = gettext("0seconds");
#line 403
      strcpy((char */* __restrict  */)(itimestr), (char const   */* __restrict  */)tmp___13);
      }
    } else {
      {
#line 405
      tmp___14 = gettext("%useconds");
#line 405
      sprintf((char */* __restrict  */)(itimestr), (char const   */* __restrict  */)tmp___14,
              (unsigned int )(q->dq_dqb.dqb_itime - now___0));
      }
    }
    {
#line 407
    fprintf((FILE */* __restrict  */)fd, (char const   */* __restrict  */)"  %-24s %22s %22s\n",
            (q->dq_h)->qh_quotadev, btimestr, itimestr);
#line 393
    q = q->dq_next;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 409
  fclose(fd);
  }
#line 410
  return (0);
}
}
#line 416 "/home/wheatley/newnew/temp/quota-4.01/quotaops.c"
int readindividualtimes(struct dquot *qlist , int infd ) 
{ 
  FILE *fd ;
  int cnt ;
  int btime ;
  int itime ;
  char line___0[8192] ;
  char fsp[8192] ;
  char btimestr[8192] ;
  char itimestr[8192] ;
  char iunits[8192] ;
  char bunits[8192] ;
  time_t now___0 ;
  time_t bseconds ;
  time_t iseconds ;
  int *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  char *tmp___11 ;
  int tmp___12 ;
  char *tmp___13 ;

  {
  {
#line 424
  lseek(infd, (__off64_t )0, 0);
#line 425
  tmp___2 = dup(infd);
#line 425
  fd = fdopen(tmp___2, "r");
  }
#line 425
  if (! fd) {
    {
#line 426
    tmp = __errno_location();
#line 426
    tmp___0 = strerror(*tmp);
#line 426
    tmp___1 = gettext("Cannot duplicate descriptor of temp file: %s\n");
#line 426
    die(1, tmp___1, tmp___0);
    }
  }
  {
#line 431
  fgets((char */* __restrict  */)(line___0), (int )sizeof(line___0), (FILE */* __restrict  */)fd);
#line 432
  fgets((char */* __restrict  */)(line___0), (int )sizeof(line___0), (FILE */* __restrict  */)fd);
#line 433
  fgets((char */* __restrict  */)(line___0), (int )sizeof(line___0), (FILE */* __restrict  */)fd);
#line 435
  time(& now___0);
  }
  {
#line 436
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 436
    tmp___13 = fgets((char */* __restrict  */)(line___0), (int )sizeof(line___0),
                     (FILE */* __restrict  */)fd);
    }
#line 436
    if (! tmp___13) {
#line 436
      goto while_break;
    }
    {
#line 437
    cnt = sscanf((char const   */* __restrict  */)(line___0), (char const   */* __restrict  */)"%s %s %s",
                 fsp, btimestr, itimestr);
    }
#line 438
    if (cnt != 3) {
      format_err: 
      {
#line 440
      tmp___3 = gettext("bad format:\n%s\n");
#line 440
      errstr(tmp___3, line___0);
      }
#line 441
      return (-1);
    }
    {
#line 443
    tmp___7 = gettext("unset");
#line 443
    tmp___8 = strcmp((char const   *)(btimestr), (char const   *)tmp___7);
    }
#line 443
    if (tmp___8) {
      {
#line 446
      tmp___4 = sscanf((char const   */* __restrict  */)(btimestr), (char const   */* __restrict  */)"%d%s",
                       & btime, bunits);
      }
#line 446
      if (tmp___4 != 2) {
#line 447
        goto format_err;
      }
      {
#line 448
      tmp___6 = str2timeunits((time_t )btime, bunits, & bseconds);
      }
#line 448
      if (tmp___6 < 0) {
        units_err: 
        {
#line 450
        tmp___5 = gettext("Bad time units. Units are \'second\', \'minute\', \'hour\', and \'day\'.\n");
#line 450
        errstr(tmp___5);
        }
#line 451
        return (-1);
      }
#line 453
      bseconds += now___0;
    } else {
#line 444
      bseconds = (time_t )0;
    }
    {
#line 455
    tmp___11 = gettext("unset");
#line 455
    tmp___12 = strcmp((char const   *)(itimestr), (char const   *)tmp___11);
    }
#line 455
    if (tmp___12) {
      {
#line 458
      tmp___9 = sscanf((char const   */* __restrict  */)(itimestr), (char const   */* __restrict  */)"%d%s",
                       & itime, iunits);
      }
#line 458
      if (tmp___9 != 2) {
#line 459
        goto format_err;
      }
      {
#line 460
      tmp___10 = str2timeunits((time_t )itime, iunits, & iseconds);
      }
#line 460
      if (tmp___10 < 0) {
#line 461
        goto units_err;
      }
#line 462
      iseconds += now___0;
    } else {
#line 456
      iseconds = (time_t )0;
    }
    {
#line 464
    merge_times_to_list(qlist, fsp, bseconds, iseconds);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 466
  fclose(fd);
  }
#line 468
  return (0);
}
}
#line 474 "/home/wheatley/newnew/temp/quota-4.01/quotaops.c"
int writetimes(struct quota_handle **handles , int outfd ) 
{ 
  FILE *fd ;
  char itimebuf[40] ;
  char btimebuf[40] ;
  int i ;
  int *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;

  {
#line 480
  if (! *(handles + 0)) {
#line 481
    return (0);
  }
  {
#line 483
  ftruncate(outfd, (__off64_t )0);
#line 484
  lseek(outfd, (__off64_t )0, 0);
#line 485
  tmp___2 = dup(outfd);
#line 485
  fd = fdopen(tmp___2, "w");
  }
#line 485
  if ((unsigned long )fd == (unsigned long )((void *)0)) {
    {
#line 486
    tmp = __errno_location();
#line 486
    tmp___0 = strerror(*tmp);
#line 486
    tmp___1 = gettext("Cannot duplicate descriptor of file to edit: %s\n");
#line 486
    die(1, tmp___1, tmp___0);
    }
  }
  {
#line 488
  tmp___3 = type2name((*(handles + 0))->qh_type);
#line 488
  tmp___4 = gettext((char const   *)tmp___3);
#line 488
  tmp___5 = gettext("Grace period before enforcing soft limits for %ss:\n");
#line 488
  fprintf((FILE */* __restrict  */)fd, (char const   */* __restrict  */)tmp___5, tmp___4);
#line 490
  tmp___6 = gettext("Time units may be: days, hours, minutes, or seconds\n");
#line 490
  fprintf((FILE */* __restrict  */)fd, (char const   */* __restrict  */)tmp___6);
#line 491
  tmp___7 = gettext("  Filesystem             Block grace period     Inode grace period\n");
#line 491
  fprintf((FILE */* __restrict  */)fd, (char const   */* __restrict  */)tmp___7);
#line 493
  i = 0;
  }
  {
#line 493
  while (1) {
    while_continue: /* CIL Label */ ;
#line 493
    if (! *(handles + i)) {
#line 493
      goto while_break;
    }
    {
#line 494
    time2str((*(handles + i))->qh_info.dqi_bgrace, btimebuf, 0);
#line 495
    time2str((*(handles + i))->qh_info.dqi_igrace, itimebuf, 0);
#line 496
    fprintf((FILE */* __restrict  */)fd, (char const   */* __restrict  */)"  %-12s %22s %22s\n",
            (*(handles + i))->qh_quotadev, btimebuf, itimebuf);
#line 493
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 499
  fclose(fd);
  }
#line 500
  return (0);
}
}
#line 506 "/home/wheatley/newnew/temp/quota-4.01/quotaops.c"
int readtimes(struct quota_handle **handles , int infd ) 
{ 
  FILE *fd ;
  int itime ;
  int btime ;
  int i ;
  int cnt ;
  time_t iseconds ;
  time_t bseconds ;
  char fsp[8192] ;
  char bunits[10] ;
  char iunits[10] ;
  char line___0[8192] ;
  int *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  char *tmp___8 ;

  {
#line 513
  if (! *(handles + 0)) {
#line 514
    return (0);
  }
  {
#line 515
  lseek(infd, (__off64_t )0, 0);
#line 516
  tmp___2 = dup(infd);
#line 516
  fd = fdopen(tmp___2, "r");
  }
#line 516
  if (! fd) {
    {
#line 517
    tmp = __errno_location();
#line 517
    tmp___0 = strerror(*tmp);
#line 517
    tmp___1 = gettext("Cannot reopen temp file: %s\n");
#line 517
    errstr(tmp___1, tmp___0);
    }
#line 519
    return (-1);
  }
#line 523
  i = 0;
  {
#line 523
  while (1) {
    while_continue: /* CIL Label */ ;
#line 523
    if (! *(handles + i)) {
#line 523
      goto while_break;
    }
    {
#line 524
    (*(handles + i))->qh_info.dqi_bgrace = (time_t )604800;
#line 525
    (*(handles + i))->qh_info.dqi_igrace = (time_t )604800;
#line 526
    mark_quotafile_info_dirty(*(handles + i));
#line 523
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 531
  fgets((char */* __restrict  */)(line___0), (int )sizeof(line___0), (FILE */* __restrict  */)fd);
#line 532
  fgets((char */* __restrict  */)(line___0), (int )sizeof(line___0), (FILE */* __restrict  */)fd);
#line 533
  fgets((char */* __restrict  */)(line___0), (int )sizeof(line___0), (FILE */* __restrict  */)fd);
  }
  {
#line 535
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 535
    tmp___8 = fgets((char */* __restrict  */)(line___0), (int )sizeof(line___0), (FILE */* __restrict  */)fd);
    }
#line 535
    if (! tmp___8) {
#line 535
      goto while_break___0;
    }
    {
#line 536
    cnt = sscanf((char const   */* __restrict  */)(line___0), (char const   */* __restrict  */)"%s %d %s %d %s",
                 fsp, & btime, bunits, & itime, iunits);
    }
#line 537
    if (cnt != 5) {
      {
#line 538
      tmp___3 = gettext("bad format:\n%s\n");
#line 538
      errstr(tmp___3, line___0);
      }
#line 539
      return (-1);
    }
    {
#line 541
    tmp___5 = str2timeunits((time_t )btime, bunits, & bseconds);
    }
#line 541
    if (tmp___5 < 0) {
      {
#line 543
      tmp___4 = gettext("Bad time units. Units are \'second\', \'minute\', \'hour\', and \'day\'.\n");
#line 543
      errstr(tmp___4);
      }
#line 544
      return (-1);
    } else {
      {
#line 541
      tmp___6 = str2timeunits((time_t )itime, iunits, & iseconds);
      }
#line 541
      if (tmp___6 < 0) {
        {
#line 543
        tmp___4 = gettext("Bad time units. Units are \'second\', \'minute\', \'hour\', and \'day\'.\n");
#line 543
        errstr(tmp___4);
        }
#line 544
        return (-1);
      }
    }
#line 546
    i = 0;
    {
#line 546
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 546
      if (! *(handles + i)) {
#line 546
        goto while_break___1;
      }
      {
#line 547
      tmp___7 = devcmp_handle((char const   *)(fsp), *(handles + i));
      }
#line 547
      if (! tmp___7) {
#line 548
        goto __Cont;
      }
      {
#line 549
      (*(handles + i))->qh_info.dqi_bgrace = bseconds;
#line 550
      (*(handles + i))->qh_info.dqi_igrace = iseconds;
#line 551
      mark_quotafile_info_dirty(*(handles + i));
      }
#line 552
      goto while_break___1;
      __Cont: /* CIL Label */ 
#line 546
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 555
  fclose(fd);
  }
#line 557
  return (0);
}
}
#line 563 "/home/wheatley/newnew/temp/quota-4.01/quotaops.c"
void freeprivs(struct dquot *qlist ) 
{ 
  struct dquot *q ;
  struct dquot *nextq ;

  {
#line 567
  q = qlist;
  {
#line 567
  while (1) {
    while_continue: /* CIL Label */ ;
#line 567
    if (! q) {
#line 567
      goto while_break;
    }
    {
#line 568
    nextq = q->dq_next;
#line 569
    free((void *)q);
#line 567
    q = nextq;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 571
  return;
}
}
#line 10 "/home/wheatley/newnew/temp/quota-4.01/rquota_clnt.c"
static struct timeval TIMEOUT___0  =    {(__time_t )25, (__suseconds_t )0};
#line 15 "/home/wheatley/newnew/temp/quota-4.01/rquota_clnt.c"
static getquota_rslt clnt_res___7  ;
#line 30 "/home/wheatley/newnew/temp/quota-4.01/rquota_clnt.c"
static getquota_rslt clnt_res___8  ;
#line 45 "/home/wheatley/newnew/temp/quota-4.01/rquota_clnt.c"
static setquota_rslt clnt_res___9  ;
#line 60 "/home/wheatley/newnew/temp/quota-4.01/rquota_clnt.c"
static setquota_rslt clnt_res___10  ;
#line 75 "/home/wheatley/newnew/temp/quota-4.01/rquota_clnt.c"
static getquota_rslt clnt_res___11  ;
#line 90 "/home/wheatley/newnew/temp/quota-4.01/rquota_clnt.c"
static getquota_rslt clnt_res___12  ;
#line 105 "/home/wheatley/newnew/temp/quota-4.01/rquota_clnt.c"
static setquota_rslt clnt_res___13  ;
#line 120 "/home/wheatley/newnew/temp/quota-4.01/rquota_clnt.c"
static setquota_rslt clnt_res___14  ;
#line 27 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v2.c"
static int v2_check_file___1(int fd , int type , int fmt___7 ) ;
#line 28
static int v2_init_io___1(struct quota_handle *h ) ;
#line 29
static int v2_new_io___1(struct quota_handle *h ) ;
#line 30
static int v2_write_info___1(struct quota_handle *h ) ;
#line 31
static struct dquot *v2_read_dquot___1(struct quota_handle *h , qid_t id___0 ) ;
#line 32
static int v2_commit_dquot___1(struct dquot *dquot , int flags___7 ) ;
#line 33
static int v2_scan_dquots___1(struct quota_handle *h , int (*process_dquot)(struct dquot *dquot ,
                                                                            char *dqname ) ) ;
#line 34
static int v2_report___1(struct quota_handle *h , int verbose ) ;
#line 53 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v2.c"
static void v2r0_disk2memdqblk___1(struct dquot *dquot , void *dp ) 
{ 
  struct util_dqblk *m ;
  struct v2r0_disk_dqblk *d ;
  struct v2r0_disk_dqblk empty ;
  int tmp ;

  {
  {
#line 55
  m = & dquot->dq_dqb;
#line 56
  d = (struct v2r0_disk_dqblk *)dp;
#line 58
  dquot->dq_id = d->dqb_id;
#line 59
  m->dqb_ihardlimit = (qsize_t )d->dqb_ihardlimit;
#line 60
  m->dqb_isoftlimit = (qsize_t )d->dqb_isoftlimit;
#line 61
  m->dqb_bhardlimit = (qsize_t )d->dqb_bhardlimit;
#line 62
  m->dqb_bsoftlimit = (qsize_t )d->dqb_bsoftlimit;
#line 63
  m->dqb_curinodes = (qsize_t )d->dqb_curinodes;
#line 64
  m->dqb_curspace = (qsize_t )((__le64 )d->dqb_curspace);
#line 65
  m->dqb_itime = (time_t )((__le64 )d->dqb_itime);
#line 66
  m->dqb_btime = (time_t )((__le64 )d->dqb_btime);
#line 68
  memset((void *)(& empty), 0, sizeof(struct v2r0_disk_dqblk ));
#line 69
  empty.dqb_itime = (u_int64_t )((__u64 )1);
#line 70
  tmp = memcmp((void const   *)(& empty), (void const   *)dp, sizeof(struct v2r0_disk_dqblk ));
  }
#line 70
  if (! tmp) {
#line 71
    m->dqb_itime = (time_t )0;
  }
#line 72
  return;
}
}
#line 77 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v2.c"
static void v2r0_mem2diskdqblk___1(void *dp , struct dquot *dquot ) 
{ 
  struct util_dqblk *m ;
  struct v2r0_disk_dqblk *d ;
  struct qtree_mem_dqinfo *info ;
  int tmp ;

  {
  {
#line 79
  m = & dquot->dq_dqb;
#line 80
  d = (struct v2r0_disk_dqblk *)dp;
#line 81
  info = & (dquot->dq_h)->qh_info.u.v2_mdqi.dqi_qtree;
#line 83
  d->dqb_ihardlimit = (__u32 )m->dqb_ihardlimit;
#line 84
  d->dqb_isoftlimit = (__u32 )m->dqb_isoftlimit;
#line 85
  d->dqb_bhardlimit = (__u32 )m->dqb_bhardlimit;
#line 86
  d->dqb_bsoftlimit = (__u32 )m->dqb_bsoftlimit;
#line 87
  d->dqb_curinodes = (__u32 )m->dqb_curinodes;
#line 88
  d->dqb_curspace = (u_int64_t )((__u64 )m->dqb_curspace);
#line 89
  d->dqb_itime = (u_int64_t )((__u64 )m->dqb_itime);
#line 90
  d->dqb_btime = (u_int64_t )((__u64 )m->dqb_btime);
#line 91
  d->dqb_id = dquot->dq_id;
#line 92
  tmp = qtree_entry_unused(info, (char *)dp);
  }
#line 92
  if (tmp) {
#line 93
    d->dqb_itime = (u_int64_t )((__u64 )1);
  }
#line 94
  return;
}
}
#line 96 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v2.c"
static int v2r0_is_id___1(void *dp , struct dquot *dquot ) 
{ 
  struct v2r0_disk_dqblk *d ;
  struct qtree_mem_dqinfo *info ;
  int tmp ;

  {
  {
#line 98
  d = (struct v2r0_disk_dqblk *)dp;
#line 99
  info = & (dquot->dq_h)->qh_info.u.v2_mdqi.dqi_qtree;
#line 101
  tmp = qtree_entry_unused(info, (char *)dp);
  }
#line 101
  if (tmp) {
#line 102
    return (0);
  }
#line 103
  return (d->dqb_id == dquot->dq_id);
}
}
#line 109 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v2.c"
static void v2r1_disk2memdqblk___1(struct dquot *dquot , void *dp ) 
{ 
  struct util_dqblk *m ;
  struct v2r1_disk_dqblk *d ;
  struct v2r1_disk_dqblk empty ;
  int tmp ;

  {
  {
#line 111
  m = & dquot->dq_dqb;
#line 112
  d = (struct v2r1_disk_dqblk *)dp;
#line 114
  dquot->dq_id = d->dqb_id;
#line 115
  m->dqb_ihardlimit = (qsize_t )((__le64 )d->dqb_ihardlimit);
#line 116
  m->dqb_isoftlimit = (qsize_t )((__le64 )d->dqb_isoftlimit);
#line 117
  m->dqb_bhardlimit = (qsize_t )((__le64 )d->dqb_bhardlimit);
#line 118
  m->dqb_bsoftlimit = (qsize_t )((__le64 )d->dqb_bsoftlimit);
#line 119
  m->dqb_curinodes = (qsize_t )((__le64 )d->dqb_curinodes);
#line 120
  m->dqb_curspace = (qsize_t )((__le64 )d->dqb_curspace);
#line 121
  m->dqb_itime = (time_t )((__le64 )d->dqb_itime);
#line 122
  m->dqb_btime = (time_t )((__le64 )d->dqb_btime);
#line 124
  memset((void *)(& empty), 0, sizeof(struct v2r1_disk_dqblk ));
#line 125
  empty.dqb_itime = (u_int64_t )((__u64 )1);
#line 126
  tmp = memcmp((void const   *)(& empty), (void const   *)dp, sizeof(struct v2r1_disk_dqblk ));
  }
#line 126
  if (! tmp) {
#line 127
    m->dqb_itime = (time_t )0;
  }
#line 128
  return;
}
}
#line 133 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v2.c"
static void v2r1_mem2diskdqblk___1(void *dp , struct dquot *dquot ) 
{ 
  struct util_dqblk *m ;
  struct v2r1_disk_dqblk *d ;
  int tmp ;

  {
  {
#line 135
  m = & dquot->dq_dqb;
#line 136
  d = (struct v2r1_disk_dqblk *)dp;
#line 138
  d->dqb_ihardlimit = (u_int64_t )((__u64 )m->dqb_ihardlimit);
#line 139
  d->dqb_isoftlimit = (u_int64_t )((__u64 )m->dqb_isoftlimit);
#line 140
  d->dqb_bhardlimit = (u_int64_t )((__u64 )m->dqb_bhardlimit);
#line 141
  d->dqb_bsoftlimit = (u_int64_t )((__u64 )m->dqb_bsoftlimit);
#line 142
  d->dqb_curinodes = (u_int64_t )((__u64 )m->dqb_curinodes);
#line 143
  d->dqb_curspace = (u_int64_t )((__u64 )m->dqb_curspace);
#line 144
  d->dqb_itime = (u_int64_t )((__u64 )m->dqb_itime);
#line 145
  d->dqb_btime = (u_int64_t )((__u64 )m->dqb_btime);
#line 146
  d->dqb_id = dquot->dq_id;
#line 147
  d->dqb_pad = (u_int32_t )0;
#line 148
  tmp = qtree_entry_unused(& (dquot->dq_h)->qh_info.u.v2_mdqi.dqi_qtree, (char *)dp);
  }
#line 148
  if (tmp) {
#line 149
    d->dqb_itime = (u_int64_t )((__u64 )1);
  }
#line 150
  return;
}
}
#line 152 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v2.c"
static int v2r1_is_id___1(void *dp , struct dquot *dquot ) 
{ 
  struct v2r1_disk_dqblk *d ;
  struct qtree_mem_dqinfo *info ;
  int tmp ;

  {
  {
#line 154
  d = (struct v2r1_disk_dqblk *)dp;
#line 155
  info = & (dquot->dq_h)->qh_info.u.v2_mdqi.dqi_qtree;
#line 157
  tmp = qtree_entry_unused(info, (char *)dp);
  }
#line 157
  if (tmp) {
#line 158
    return (0);
  }
#line 159
  return (d->dqb_id == dquot->dq_id);
}
}
#line 162 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v2.c"
static struct qtree_fmt_operations v2r0_fmt_ops___1  =    {& v2r0_mem2diskdqblk___1, & v2r0_disk2memdqblk___1, & v2r0_is_id___1};
#line 168 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v2.c"
static struct qtree_fmt_operations v2r1_fmt_ops___1  =    {& v2r1_mem2diskdqblk___1, & v2r1_disk2memdqblk___1, & v2r1_is_id___1};
#line 226 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v2.c"
static int v2_read_header___1(int fd , struct v2_disk_dqheader *h ) 
{ 
  ssize_t tmp ;

  {
  {
#line 228
  lseek(fd, (__off64_t )0, 0);
#line 229
  tmp = read(fd, (void *)h, sizeof(struct v2_disk_dqheader ));
  }
#line 229
  if ((unsigned long )tmp != sizeof(struct v2_disk_dqheader )) {
#line 230
    return (0);
  }
#line 231
  return (1);
}
}
#line 237 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v2.c"
static int v2_check_file___1(int fd , int type , int fmt___7 ) 
{ 
  struct v2_disk_dqheader h ;
  int file_magics[2] ;
  int known_versions___0[2] ;
  int version___0 ;
  int tmp ;
  char *tmp___0 ;
  __u32 tmp___1 ;

  {
  {
#line 240
  file_magics[0] = -641720559;
#line 240
  file_magics[1] = -641722073;
#line 241
  known_versions___0[0] = 1;
#line 241
  known_versions___0[1] = 1;
#line 244
  tmp = v2_read_header___1(fd, & h);
  }
#line 244
  if (! tmp) {
#line 245
    return (0);
  }
#line 246
  if (fmt___7 == 1) {
#line 247
    version___0 = 0;
  } else
#line 248
  if (fmt___7 == 2) {
#line 249
    version___0 = 1;
  } else {
#line 251
    return (0);
  }
#line 253
  if (h.dqh_magic != (__u32 )file_magics[type]) {
    {
#line 254
    tmp___1 = __fswab32(h.dqh_magic);
    }
#line 254
    if (tmp___1 == (__u32 )file_magics[type]) {
      {
#line 255
      tmp___0 = gettext("Your quota file is stored in wrong endianity. Please use convertquota(8) to convert it.\n");
#line 255
      die(3, tmp___0);
      }
    }
#line 256
    return (0);
  }
#line 258
  if (h.dqh_version > (__u32 )known_versions___0[type]) {
#line 259
    return (0);
  }
#line 260
  if ((__u32 )version___0 != h.dqh_version) {
#line 261
    return (0);
  }
#line 262
  return (1);
}
}
#line 268 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v2.c"
static int v2_init_io___1(struct quota_handle *h ) 
{ 
  int tmp ;
  struct v2_kern_dqinfo kdqinfo ;
  int *tmp___0 ;
  long tmp___1 ;
  struct v2_disk_dqinfo ddqinfo ;
  struct v2_disk_dqheader header ;
  int tmp___2 ;
  ssize_t tmp___3 ;

  {
#line 270
  if (h->qh_io_flags & 1) {
#line 271
    if (kernel_iface == 3) {
      {
#line 272
      tmp = vfs_get_info(h);
      }
#line 272
      if (tmp < 0) {
#line 273
        return (-1);
      }
    } else {
      {
#line 278
      tmp___1 = quotactl((2304 << 8) | (h->qh_type & 255), (char const   *)(h->qh_quotadev),
                         (qid_t )0, (caddr_t )((void *)(& kdqinfo)));
      }
#line 278
      if (tmp___1 < 0L) {
        {
#line 280
        tmp___0 = __errno_location();
        }
#line 280
        if (*tmp___0 == 1) {
#line 281
          return (0);
        }
#line 282
        return (-1);
      }
#line 284
      h->qh_info.dqi_bgrace = (time_t )kdqinfo.dqi_bgrace;
#line 285
      h->qh_info.dqi_igrace = (time_t )kdqinfo.dqi_igrace;
#line 286
      h->qh_info.u.v2_mdqi.dqi_flags = kdqinfo.dqi_flags;
#line 287
      h->qh_info.u.v2_mdqi.dqi_qtree.dqi_blocks = kdqinfo.dqi_blocks;
#line 288
      h->qh_info.u.v2_mdqi.dqi_qtree.dqi_free_blk = kdqinfo.dqi_free_blk;
#line 289
      h->qh_info.u.v2_mdqi.dqi_qtree.dqi_free_entry = kdqinfo.dqi_free_entry;
    }
  }
#line 292
  if (h->qh_fd != -1) {
    {
#line 296
    tmp___2 = v2_read_header___1(h->qh_fd, & header);
    }
#line 296
    if (! tmp___2) {
#line 297
      return (-1);
    }
    {
#line 299
    lseek(h->qh_fd, (__off64_t )sizeof(struct v2_disk_dqheader ), 0);
#line 300
    tmp___3 = read(h->qh_fd, (void *)(& ddqinfo), sizeof(ddqinfo));
    }
#line 300
    if ((unsigned long )tmp___3 != sizeof(ddqinfo)) {
#line 301
      return (-1);
    }
#line 303
    if (! (h->qh_io_flags & 1)) {
      {
#line 304
      v2_disk2memdqinfo(& h->qh_info, & ddqinfo);
      }
    } else {
#line 306
      h->qh_info.u.v2_mdqi.dqi_qtree.dqi_blocks = ddqinfo.dqi_blocks;
    }
#line 308
    if (header.dqh_version == 0U) {
#line 309
      h->qh_info.u.v2_mdqi.dqi_qtree.dqi_entry_size = (unsigned int )sizeof(struct v2r0_disk_dqblk );
#line 310
      h->qh_info.u.v2_mdqi.dqi_qtree.dqi_ops = & v2r0_fmt_ops___1;
#line 311
      h->qh_info.dqi_max_b_limit = (uint64_t )(~ ((uint32_t )0));
#line 312
      h->qh_info.dqi_max_i_limit = (uint64_t )(~ ((uint32_t )0));
#line 313
      h->qh_info.dqi_max_b_usage = ~ ((uint64_t )0);
#line 314
      h->qh_info.dqi_max_i_usage = (uint64_t )(~ ((uint32_t )0));
    } else {
#line 316
      h->qh_info.u.v2_mdqi.dqi_qtree.dqi_entry_size = (unsigned int )sizeof(struct v2r1_disk_dqblk );
#line 317
      h->qh_info.u.v2_mdqi.dqi_qtree.dqi_ops = & v2r1_fmt_ops___1;
#line 318
      h->qh_info.dqi_max_b_limit = ~ ((uint64_t )0);
#line 319
      h->qh_info.dqi_max_i_limit = ~ ((uint64_t )0);
#line 320
      h->qh_info.dqi_max_b_usage = ~ ((uint64_t )0);
#line 321
      h->qh_info.dqi_max_i_usage = ~ ((uint64_t )0);
    }
  } else {
#line 325
    h->qh_info.u.v2_mdqi.dqi_qtree.dqi_ops = (struct qtree_fmt_operations *)((void *)0);
  }
#line 327
  return (0);
}
}
#line 333 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v2.c"
static int v2_new_io___1(struct quota_handle *h ) 
{ 
  int file_magics[2] ;
  struct v2_disk_dqheader ddqheader ;
  struct v2_disk_dqinfo ddqinfo ;
  int version___0 ;
  ssize_t tmp ;
  ssize_t tmp___0 ;

  {
#line 335
  file_magics[0] = -641720559;
#line 335
  file_magics[1] = -641722073;
#line 340
  if (h->qh_fmt == 1) {
#line 341
    version___0 = 0;
  } else
#line 342
  if (h->qh_fmt == 2) {
#line 343
    version___0 = 1;
  } else {
#line 345
    return (-1);
  }
  {
#line 348
  ddqheader.dqh_magic = (__u32 )file_magics[h->qh_type];
#line 349
  ddqheader.dqh_version = (__u32 )version___0;
#line 350
  lseek(h->qh_fd, (__off64_t )0, 0);
#line 351
  tmp = write(h->qh_fd, (void const   *)(& ddqheader), sizeof(ddqheader));
  }
#line 351
  if ((unsigned long )tmp != sizeof(ddqheader)) {
#line 352
    return (-1);
  }
#line 354
  h->qh_info.dqi_bgrace = (time_t )604800;
#line 355
  h->qh_info.dqi_igrace = (time_t )604800;
#line 356
  h->qh_info.u.v2_mdqi.dqi_flags = (uint )0;
#line 357
  h->qh_info.u.v2_mdqi.dqi_qtree.dqi_blocks = 2U;
#line 358
  h->qh_info.u.v2_mdqi.dqi_qtree.dqi_free_blk = 0U;
#line 359
  h->qh_info.u.v2_mdqi.dqi_qtree.dqi_free_entry = 0U;
#line 360
  if (version___0 == 0) {
#line 361
    h->qh_info.u.v2_mdqi.dqi_qtree.dqi_entry_size = (unsigned int )sizeof(struct v2r0_disk_dqblk );
#line 362
    h->qh_info.u.v2_mdqi.dqi_qtree.dqi_ops = & v2r0_fmt_ops___1;
#line 363
    h->qh_info.dqi_max_b_limit = (uint64_t )(~ ((uint32_t )0));
#line 364
    h->qh_info.dqi_max_i_limit = (uint64_t )(~ ((uint32_t )0));
#line 365
    h->qh_info.dqi_max_b_usage = ~ ((uint64_t )0);
#line 366
    h->qh_info.dqi_max_i_usage = (uint64_t )(~ ((uint32_t )0));
  } else
#line 367
  if (version___0 == 1) {
#line 368
    h->qh_info.u.v2_mdqi.dqi_qtree.dqi_entry_size = (unsigned int )sizeof(struct v2r1_disk_dqblk );
#line 369
    h->qh_info.u.v2_mdqi.dqi_qtree.dqi_ops = & v2r1_fmt_ops___1;
#line 370
    h->qh_info.dqi_max_b_limit = ~ ((uint64_t )0);
#line 371
    h->qh_info.dqi_max_i_limit = ~ ((uint64_t )0);
#line 372
    h->qh_info.dqi_max_b_usage = ~ ((uint64_t )0);
#line 373
    h->qh_info.dqi_max_i_usage = ~ ((uint64_t )0);
  }
  {
#line 375
  v2_mem2diskdqinfo(& ddqinfo, & h->qh_info);
#line 376
  lseek(h->qh_fd, (__off64_t )sizeof(struct v2_disk_dqheader ), 0);
#line 377
  tmp___0 = write(h->qh_fd, (void const   *)(& ddqinfo), sizeof(ddqinfo));
  }
#line 377
  if ((unsigned long )tmp___0 != sizeof(ddqinfo)) {
#line 378
    return (-1);
  }
#line 379
  return (0);
}
}
#line 385 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v2.c"
static int v2_write_info___1(struct quota_handle *h ) 
{ 
  char *tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  struct v2_kern_dqinfo kdqinfo ;
  long tmp___2 ;
  long tmp___3 ;
  struct v2_disk_dqinfo ddqinfo ;
  ssize_t tmp___4 ;

  {
#line 387
  if (h->qh_io_flags & 4) {
    {
#line 388
    tmp = gettext("Trying to write info to readonly quotafile on %s\n");
#line 388
    errstr(tmp, h->qh_quotadev);
#line 389
    tmp___0 = __errno_location();
#line 389
    *tmp___0 = 1;
    }
#line 390
    return (-1);
  }
#line 392
  if (h->qh_io_flags & 1) {
#line 393
    if (kernel_iface == 3) {
      {
#line 394
      tmp___1 = vfs_set_info(h, 3);
      }
#line 394
      if (tmp___1) {
#line 395
        return (-1);
      }
    } else {
      {
#line 400
      kdqinfo.dqi_bgrace = (unsigned int )h->qh_info.dqi_bgrace;
#line 401
      kdqinfo.dqi_igrace = (unsigned int )h->qh_info.dqi_igrace;
#line 402
      kdqinfo.dqi_flags = h->qh_info.u.v2_mdqi.dqi_flags;
#line 403
      kdqinfo.dqi_blocks = h->qh_info.u.v2_mdqi.dqi_qtree.dqi_blocks;
#line 404
      kdqinfo.dqi_free_blk = h->qh_info.u.v2_mdqi.dqi_qtree.dqi_free_blk;
#line 405
      kdqinfo.dqi_free_entry = h->qh_info.u.v2_mdqi.dqi_qtree.dqi_free_entry;
#line 406
      tmp___2 = quotactl((2816 << 8) | (h->qh_type & 255), (char const   *)(h->qh_quotadev),
                         (qid_t )0, (caddr_t )((void *)(& kdqinfo)));
      }
#line 406
      if (tmp___2 < 0L) {
#line 408
        return (-1);
      } else {
        {
#line 406
        tmp___3 = quotactl((3072 << 8) | (h->qh_type & 255), (char const   *)(h->qh_quotadev),
                           (qid_t )0, (caddr_t )((void *)(& kdqinfo)));
        }
#line 406
        if (tmp___3 < 0L) {
#line 408
          return (-1);
        }
      }
    }
  } else {
    {
#line 414
    v2_mem2diskdqinfo(& ddqinfo, & h->qh_info);
#line 415
    lseek(h->qh_fd, (__off64_t )sizeof(struct v2_disk_dqheader ), 0);
#line 416
    tmp___4 = write(h->qh_fd, (void const   *)(& ddqinfo), sizeof(ddqinfo));
    }
#line 416
    if ((unsigned long )tmp___4 != sizeof(ddqinfo)) {
#line 417
      return (-1);
    }
  }
#line 419
  return (0);
}
}
#line 426 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v2.c"
static struct dquot *v2_read_dquot___1(struct quota_handle *h , qid_t id___0 ) 
{ 
  struct dquot *dquot ;
  struct dquot *tmp ;
  int tmp___0 ;
  struct v2_kern_dqblk kdqblk ;
  long tmp___1 ;
  struct dquot *tmp___2 ;

  {
#line 428
  if (h->qh_io_flags & 1) {
    {
#line 429
    tmp = get_empty_dquot();
#line 429
    dquot = tmp;
#line 431
    dquot->dq_id = id___0;
#line 432
    dquot->dq_h = h;
#line 433
    dquot->dq_dqb.u.v2_mdqb.dqb_off = (loff_t )0;
#line 434
    memset((void *)(& dquot->dq_dqb), 0, sizeof(struct util_dqblk ));
    }
#line 435
    if (kernel_iface == 3) {
      {
#line 436
      tmp___0 = vfs_get_dquot(dquot);
      }
#line 436
      if (tmp___0 < 0) {
        {
#line 437
        free((void *)dquot);
        }
#line 438
        return ((struct dquot *)((void *)0));
      }
    } else {
      {
#line 444
      tmp___1 = quotactl((3328 << 8) | (h->qh_type & 255), (char const   *)(h->qh_quotadev),
                         id___0, (caddr_t )((void *)(& kdqblk)));
      }
#line 444
      if (tmp___1 < 0L) {
        {
#line 445
        free((void *)dquot);
        }
#line 446
        return ((struct dquot *)((void *)0));
      }
      {
#line 448
      v2_kern2utildqblk(& dquot->dq_dqb, & kdqblk);
      }
    }
#line 450
    return (dquot);
  }
  {
#line 452
  tmp___2 = qtree_read_dquot(h, id___0);
  }
#line 452
  return (tmp___2);
}
}
#line 459 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v2.c"
static int v2_commit_dquot___1(struct dquot *dquot , int flags___7 ) 
{ 
  struct util_dqblk *b ;
  char *tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  struct v2_kern_dqblk kdqblk ;
  int cmd ;
  int *tmp___2 ;
  long tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;

  {
#line 461
  b = & dquot->dq_dqb;
#line 463
  if ((dquot->dq_h)->qh_io_flags & 4) {
    {
#line 464
    tmp = gettext("Trying to write quota to readonly quotafile on %s\n");
#line 464
    errstr(tmp, (dquot->dq_h)->qh_quotadev);
#line 465
    tmp___0 = __errno_location();
#line 465
    *tmp___0 = 1;
    }
#line 466
    return (-1);
  }
#line 468
  if ((dquot->dq_h)->qh_io_flags & 1) {
#line 469
    if (kernel_iface == 3) {
      {
#line 470
      tmp___1 = vfs_set_dquot(dquot, flags___7);
      }
#line 470
      if (tmp___1 < 0) {
#line 471
        return (-1);
      }
    } else {
#line 477
      if (flags___7 == 10) {
#line 478
        cmd = 3840;
      } else
#line 479
      if (flags___7 == 5) {
#line 480
        cmd = 1792;
      } else
#line 481
      if (flags___7 & 48) {
        {
#line 482
        tmp___2 = __errno_location();
#line 482
        *tmp___2 = 22;
        }
#line 483
        return (-1);
      } else {
#line 486
        cmd = 3584;
      }
      {
#line 487
      v2_util2kerndqblk(& kdqblk, & dquot->dq_dqb);
#line 488
      tmp___3 = quotactl((cmd << 8) | ((dquot->dq_h)->qh_type & 255), (char const   *)((dquot->dq_h)->qh_quotadev),
                         dquot->dq_id, (caddr_t )((void *)(& kdqblk)));
      }
#line 488
      if (tmp___3 < 0L) {
#line 490
        return (-1);
      }
    }
#line 492
    return (0);
  }
#line 494
  if (! b->dqb_curspace) {
#line 494
    if (! b->dqb_curinodes) {
#line 494
      if (! b->dqb_bsoftlimit) {
#line 494
        if (! b->dqb_isoftlimit) {
#line 494
          if (! b->dqb_bhardlimit) {
#line 494
            if (! b->dqb_ihardlimit) {
              {
#line 496
              qtree_delete_dquot(dquot);
              }
            } else {
#line 494
              goto _L___3;
            }
          } else {
#line 494
            goto _L___3;
          }
        } else {
#line 494
          goto _L___3;
        }
      } else {
#line 494
        goto _L___3;
      }
    } else {
#line 494
      goto _L___3;
    }
  } else {
    _L___3: /* CIL Label */ 
    {
#line 498
    tmp___5 = check_dquot_range(dquot);
    }
#line 498
    if (tmp___5 < 0) {
      {
#line 499
      tmp___4 = __errno_location();
#line 499
      *tmp___4 = 34;
      }
#line 500
      return (-1);
    }
    {
#line 502
    qtree_write_dquot(dquot);
    }
  }
#line 504
  return (0);
}
}
#line 507 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v2.c"
static int v2_scan_dquots___1(struct quota_handle *h , int (*process_dquot)(struct dquot *dquot ,
                                                                            char *dqname ) ) 
{ 
  int tmp ;

  {
  {
#line 509
  tmp = qtree_scan_dquots(h, process_dquot);
  }
#line 509
  return (tmp);
}
}
#line 513 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v2.c"
static int v2_report___1(struct quota_handle *h , int verbose ) 
{ 
  struct v2_mem_dqinfo *info ;
  char *tmp ;

  {
#line 515
  if (verbose) {
    {
#line 516
    info = & h->qh_info.u.v2_mdqi;
#line 518
    tmp = gettext("Statistics:\nTotal blocks: %u\nData blocks: %u\nEntries: %u\nUsed average: %f\n");
#line 518
    printf((char const   */* __restrict  */)tmp, info->dqi_qtree.dqi_blocks, info->dqi_data_blocks,
           info->dqi_used_entries, (double )((float )info->dqi_used_entries / (float )info->dqi_data_blocks));
    }
  }
#line 522
  return (0);
}
}
#line 31 "/home/wheatley/newnew/temp/quota-4.01/bylabel.c"
static struct uuidCache_s *uuidCache___1  =    (struct uuidCache_s *)((void *)0);
#line 74 "/home/wheatley/newnew/temp/quota-4.01/bylabel.c"
static int get_label_uuid___1(char const   *device , char **label , char *uuid ) 
{ 
  int fd ;
  int rv ;
  size_t namesize ;
  struct ext2_super_block e2sb ;
  struct xfs_super_block xfsb ;
  struct reiserfs_super_block reisersb ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  __off64_t tmp___2 ;
  ssize_t tmp___3 ;
  int tmp___4 ;
  __off64_t tmp___5 ;
  ssize_t tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  __off64_t tmp___9 ;
  ssize_t tmp___10 ;

  {
  {
#line 79
  rv = 1;
#line 85
  fd = open(device, 0);
  }
#line 86
  if (fd < 0) {
#line 87
    return (rv);
  }
  {
#line 89
  tmp___9 = lseek(fd, (__off64_t )1024, 0);
  }
#line 89
  if (tmp___9 == 1024L) {
    {
#line 89
    tmp___10 = read(fd, (void *)((char *)(& e2sb)), sizeof(e2sb));
    }
#line 89
    if ((unsigned long )tmp___10 == sizeof(e2sb)) {
#line 89
      if ((uint )e2sb.s_magic[0] + ((uint )e2sb.s_magic[1] << 8) == 61267U) {
        {
#line 92
        memcpy((void */* __restrict  */)uuid, (void const   */* __restrict  */)(e2sb.s_uuid),
               sizeof(e2sb.s_uuid));
#line 93
        namesize = sizeof(e2sb.s_volume_name);
#line 94
        tmp = smalloc(namesize + 1UL);
#line 94
        *label = (char *)tmp;
#line 95
        sstrncpy(*label, (char const   *)((char *)(e2sb.s_volume_name)), namesize);
#line 96
        rv = 0;
        }
      } else {
#line 89
        goto _L___3;
      }
    } else {
#line 89
      goto _L___3;
    }
  } else {
    _L___3: /* CIL Label */ 
    {
#line 98
    tmp___5 = lseek(fd, (__off64_t )0, 0);
    }
#line 98
    if (tmp___5 == 0L) {
      {
#line 98
      tmp___6 = read(fd, (void *)((char *)(& xfsb)), sizeof(xfsb));
      }
#line 98
      if ((unsigned long )tmp___6 == sizeof(xfsb)) {
        {
#line 98
        tmp___7 = strncmp((char const   *)((char *)(& xfsb.s_magic)), "XFSB", (size_t )4);
        }
#line 98
        if (tmp___7 == 0) {
#line 98
          goto _L___0;
        } else {
          {
#line 98
          tmp___8 = strncmp((char const   *)((char *)(& xfsb.s_magic)), "BSFX", (size_t )4);
          }
#line 98
          if (tmp___8 == 0) {
            _L___0: /* CIL Label */ 
            {
#line 102
            memcpy((void */* __restrict  */)uuid, (void const   */* __restrict  */)(xfsb.s_uuid),
                   sizeof(xfsb.s_uuid));
#line 103
            namesize = sizeof(xfsb.s_fsname);
#line 104
            tmp___0 = smalloc(namesize + 1UL);
#line 104
            *label = (char *)tmp___0;
#line 105
            sstrncpy(*label, (char const   *)((char *)(xfsb.s_fsname)), namesize);
#line 106
            rv = 0;
            }
          } else {
#line 98
            goto _L___1;
          }
        }
      } else {
#line 98
        goto _L___1;
      }
    } else {
      _L___1: /* CIL Label */ 
      {
#line 108
      tmp___2 = lseek(fd, (__off64_t )65536, 0);
      }
#line 108
      if (tmp___2 == 65536L) {
        {
#line 108
        tmp___3 = read(fd, (void *)((char *)(& reisersb)), sizeof(reisersb));
        }
#line 108
        if ((unsigned long )tmp___3 == sizeof(reisersb)) {
          {
#line 108
          tmp___4 = strncmp((char const   *)((char *)(& reisersb.s_magic)), "ReIsEr2Fs",
                            (size_t )9);
          }
#line 108
          if (! tmp___4) {
            {
#line 111
            memcpy((void */* __restrict  */)uuid, (void const   */* __restrict  */)(reisersb.s_uuid),
                   sizeof(reisersb.s_uuid));
#line 112
            namesize = sizeof(reisersb.s_volume_name);
#line 113
            tmp___1 = smalloc(namesize + 1UL);
#line 113
            *label = (char *)tmp___1;
#line 114
            sstrncpy(*label, (char const   *)((char *)(reisersb.s_volume_name)), namesize);
#line 115
            rv = 0;
            }
          }
        }
      }
    }
  }
  {
#line 117
  close(fd);
  }
#line 118
  return (rv);
}
}
#line 121 "/home/wheatley/newnew/temp/quota-4.01/bylabel.c"
static void uuidcache_addentry___1(char *device , char *label , char *uuid ) 
{ 
  struct uuidCache_s *last ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 125
  if (! uuidCache___1) {
    {
#line 126
    tmp = smalloc(sizeof(*uuidCache___1));
#line 126
    uuidCache___1 = (struct uuidCache_s *)tmp;
#line 126
    last = uuidCache___1;
    }
  } else {
#line 129
    last = uuidCache___1;
    {
#line 129
    while (1) {
      while_continue: /* CIL Label */ ;
#line 129
      if (! last->next) {
#line 129
        goto while_break;
      }
#line 129
      last = last->next;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 130
    tmp___0 = smalloc(sizeof(*uuidCache___1));
#line 130
    last->next = (struct uuidCache_s *)tmp___0;
#line 131
    last = last->next;
    }
  }
  {
#line 133
  last->next = (struct uuidCache_s *)((void *)0);
#line 134
  last->device = device;
#line 135
  last->label = label;
#line 136
  memcpy((void */* __restrict  */)(last->uuid), (void const   */* __restrict  */)uuid,
         sizeof(last->uuid));
  }
#line 137
  return;
}
}
#line 144 "/home/wheatley/newnew/temp/quota-4.01/bylabel.c"
static char ptname___1[100]  ;
#line 139 "/home/wheatley/newnew/temp/quota-4.01/bylabel.c"
static void uuidcache_init___1(void) 
{ 
  char line___0[100] ;
  char *s ;
  int ma ;
  int mi ;
  int sz ;
  FILE *procpt ;
  char uuid[16] ;
  char *label ;
  char device[110] ;
  int firstPass ;
  int handleOnFirst ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  unsigned short const   **tmp___4 ;
  char *tmp___5 ;

  {
#line 151
  if (uuidCache___1) {
#line 152
    return;
  }
  {
#line 154
  procpt = fopen((char const   */* __restrict  */)"/proc/partitions", (char const   */* __restrict  */)"r");
  }
#line 155
  if (! procpt) {
#line 156
    return;
  }
#line 158
  firstPass = 1;
  {
#line 158
  while (1) {
    while_continue: /* CIL Label */ ;
#line 158
    if (! (firstPass >= 0)) {
#line 158
      goto while_break;
    }
    {
#line 159
    fseek(procpt, 0L, 0);
    }
    {
#line 161
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 161
      tmp___5 = fgets((char */* __restrict  */)(line___0), (int )sizeof(line___0),
                      (FILE */* __restrict  */)procpt);
      }
#line 161
      if (! tmp___5) {
#line 161
        goto while_break___0;
      }
      {
#line 162
      tmp = sscanf((char const   */* __restrict  */)(line___0), (char const   */* __restrict  */)" %d %d %d %[^\n ]",
                   & ma, & mi, & sz, ptname___1);
      }
#line 162
      if (tmp != 4) {
#line 163
        goto while_continue___0;
      }
#line 166
      if (sz == 1) {
#line 167
        goto while_continue___0;
      }
      {
#line 170
      tmp___0 = strncmp((char const   *)(ptname___1), "md", (size_t )2);
      }
#line 170
      if (tmp___0) {
#line 170
        tmp___1 = 0;
      } else {
#line 170
        tmp___1 = 1;
      }
#line 170
      handleOnFirst = tmp___1;
#line 171
      if (firstPass != handleOnFirst) {
#line 172
        goto while_continue___0;
      }
#line 178
      s = ptname___1;
      {
#line 178
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 178
        if (! *s) {
#line 178
          goto while_break___1;
        }
#line 178
        s ++;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 179
      tmp___4 = __ctype_b_loc();
      }
#line 179
      if ((int const   )*(*tmp___4 + (int )*(s + -1)) & 2048) {
        {
#line 189
        snprintf((char */* __restrict  */)(device), sizeof(device), (char const   */* __restrict  */)"%s/%s",
                 "/dev", ptname___1);
#line 190
        tmp___3 = get_label_uuid___1((char const   *)(device), & label, uuid);
        }
#line 190
        if (! tmp___3) {
          {
#line 191
          tmp___2 = sstrdup((char const   *)(device));
#line 191
          uuidcache_addentry___1(tmp___2, label, uuid);
          }
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 158
    firstPass --;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 196
  fclose(procpt);
  }
#line 197
  return;
}
}
#line 202 "/home/wheatley/newnew/temp/quota-4.01/bylabel.c"
static char *get_spec_by_x___1(int n , char const   *t ) 
{ 
  struct uuidCache_s *uc ;
  char *tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 206
  uuidcache_init___1();
#line 207
  uc = uuidCache___1;
  }
  {
#line 209
  while (1) {
    while_continue: /* CIL Label */ ;
#line 209
    if (! uc) {
#line 209
      goto while_break;
    }
    {
#line 211
    if (n == 1) {
#line 211
      goto case_1;
    }
#line 215
    if (n == 2) {
#line 215
      goto case_2;
    }
#line 210
    goto switch_break;
    case_1: /* CIL Label */ 
    {
#line 212
    tmp___0 = memcmp((void const   *)t, (void const   *)(uc->uuid), sizeof(uc->uuid));
    }
#line 212
    if (! tmp___0) {
      {
#line 213
      tmp = sstrdup((char const   *)uc->device);
      }
#line 213
      return (tmp);
    }
#line 214
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 216
    tmp___2 = strcmp(t, (char const   *)uc->label);
    }
#line 216
    if (! tmp___2) {
      {
#line 217
      tmp___1 = sstrdup((char const   *)uc->device);
      }
#line 217
      return (tmp___1);
    }
#line 218
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 220
    uc = uc->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 222
  return ((char *)((void *)0));
}
}
#line 225 "/home/wheatley/newnew/temp/quota-4.01/bylabel.c"
static u_char fromhex___1(char c ) 
{ 
  unsigned short const   **tmp ;
  unsigned short const   **tmp___0 ;

  {
  {
#line 227
  tmp___0 = __ctype_b_loc();
  }
#line 227
  if ((int const   )*(*tmp___0 + (int )c) & 2048) {
#line 228
    return ((u_char )((int )c - 48));
  } else {
    {
#line 229
    tmp = __ctype_b_loc();
    }
#line 229
    if ((int const   )*(*tmp + (int )c) & 512) {
#line 230
      return ((u_char )(((int )c - 97) + 10));
    } else {
#line 232
      return ((u_char )(((int )c - 65) + 10));
    }
  }
}
}
#line 235 "/home/wheatley/newnew/temp/quota-4.01/bylabel.c"
static char *get_spec_by_uuid___1(char const   *s ) 
{ 
  u_char uuid[16] ;
  int i ;
  size_t tmp ;
  unsigned short const   **tmp___0 ;
  unsigned short const   **tmp___1 ;
  u_char tmp___2 ;
  u_char tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;

  {
  {
#line 240
  tmp = strlen(s);
  }
#line 240
  if (tmp != 36UL) {
#line 241
    goto bad_uuid;
  } else
#line 240
  if ((int const   )*(s + 8) != 45) {
#line 241
    goto bad_uuid;
  } else
#line 240
  if ((int const   )*(s + 13) != 45) {
#line 241
    goto bad_uuid;
  } else
#line 240
  if ((int const   )*(s + 18) != 45) {
#line 241
    goto bad_uuid;
  } else
#line 240
  if ((int const   )*(s + 23) != 45) {
#line 241
    goto bad_uuid;
  }
#line 242
  i = 0;
  {
#line 242
  while (1) {
    while_continue: /* CIL Label */ ;
#line 242
    if (! (i < 16)) {
#line 242
      goto while_break;
    }
#line 243
    if ((int const   )*s == 45) {
#line 244
      s ++;
    }
    {
#line 245
    tmp___0 = __ctype_b_loc();
    }
#line 245
    if ((int const   )*(*tmp___0 + (int )*(s + 0)) & 4096) {
      {
#line 245
      tmp___1 = __ctype_b_loc();
      }
#line 245
      if (! ((int const   )*(*tmp___1 + (int )*(s + 1)) & 4096)) {
#line 246
        goto bad_uuid;
      }
    } else {
#line 246
      goto bad_uuid;
    }
    {
#line 247
    tmp___2 = fromhex___1((char )*(s + 0));
#line 247
    tmp___3 = fromhex___1((char )*(s + 1));
#line 247
    uuid[i] = (u_char )(((int )tmp___2 << 4) | (int )tmp___3);
#line 248
    s += 2;
#line 242
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 250
  tmp___4 = get_spec_by_x___1(1, (char const   *)((char *)(uuid)));
  }
#line 250
  return (tmp___4);
  bad_uuid: 
  {
#line 253
  tmp___5 = gettext("Found an invalid UUID: %s\n");
#line 253
  errstr(tmp___5, s);
  }
#line 254
  return ((char *)((void *)0));
}
}
#line 257 "/home/wheatley/newnew/temp/quota-4.01/bylabel.c"
static char *get_spec_by_volume_label___1(char const   *s ) 
{ 
  char *tmp ;

  {
  {
#line 259
  tmp = get_spec_by_x___1(2, s);
  }
#line 259
  return (tmp);
}
}
#line 105 "/home/wheatley/newnew/temp/quota-4.01/quotaio_generic.c"
static int scan_one_dquot___1(struct dquot *dquot , int (*get_dquot)(struct dquot * ) ) 
{ 
  int ret ;
  struct util_dqblk *dqb ;

  {
  {
#line 108
  dqb = & dquot->dq_dqb;
#line 110
  memset((void *)dqb, 0, sizeof(struct util_dqblk ));
#line 111
  ret = (*get_dquot)(dquot);
  }
#line 112
  if (ret < 0) {
#line 113
    return (ret);
  }
#line 114
  if (! dqb->dqb_bhardlimit) {
#line 114
    if (! dqb->dqb_bsoftlimit) {
#line 114
      if (! dqb->dqb_ihardlimit) {
#line 114
        if (! dqb->dqb_isoftlimit) {
#line 114
          if (! dqb->dqb_curinodes) {
#line 114
            if (! dqb->dqb_curspace) {
#line 115
              return (1);
            }
          }
        }
      }
    }
  }
#line 116
  return (0);
}
}
#line 18 "/home/wheatley/newnew/temp/quota-4.01/quotaon.h"
int xfs_newstate(struct mount_entry *mnt___2 , int type , char *xarg___0 , int flags___7 ) ;
#line 19
int pinfo(char *fmt___7  , ...) ;
#line 25 "/home/wheatley/newnew/temp/quota-4.01/quotaon_xfs.c"
static int xfs_state_check(int qcmd , int type , int flags___7 , char const   *dev ,
                           int roothack , int xopts ) 
{ 
  struct fs_quota_stat info ;
  int state ;
  char *acctstr ;
  int *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  long tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;
  char *tmp___18 ;
  char *tmp___19 ;
  char *tmp___20 ;
  char *tmp___21 ;
  char *tmp___22 ;
  char *tmp___23 ;
  char *tmp___24 ;
  char *tmp___25 ;
  char *tmp___26 ;
  char *tmp___27 ;
  char *tmp___28 ;
  char *tmp___29 ;
  char *tmp___30 ;
  char *tmp___31 ;
  char *tmp___32 ;
  char *tmp___33 ;
  char *tmp___34 ;
  char *tmp___35 ;
  char *tmp___36 ;
  char *tmp___37 ;
  char *tmp___38 ;
  char *tmp___39 ;

  {
#line 29
  acctstr = (char *)"";
#line 32
  if (flags___7 & 4) {
#line 33
    return (0);
  }
  {
#line 35
  tmp___2 = quotactl(((88 << 8) + 5) << 8, dev, (qid_t )0, (caddr_t )((void *)(& info)));
  }
#line 35
  if (tmp___2 < 0L) {
    {
#line 36
    tmp = __errno_location();
#line 36
    tmp___0 = strerror(*tmp);
#line 36
    tmp___1 = gettext("quotactl() on %s: %s\n");
#line 36
    errstr(tmp___1, dev, tmp___0);
    }
#line 37
    return (-1);
  }
#line 41
  state = 1;
#line 42
  if (type == 0) {
#line 43
    if ((int )info.qs_flags & 1) {
#line 44
      state = 2;
    }
#line 45
    if ((int )info.qs_flags & (1 << 1)) {
#line 46
      state = 3;
    }
  } else {
#line 49
    if ((int )info.qs_flags & (1 << 2)) {
#line 50
      state = 2;
    }
#line 51
    if ((int )info.qs_flags & (1 << 3)) {
#line 52
      state = 3;
    }
  }
  {
#line 56
  if (state == 1) {
#line 56
    goto case_1;
  }
#line 73
  if (state == 2) {
#line 73
    goto case_2;
  }
#line 105
  if (state == 3) {
#line 105
    goto case_3;
  }
#line 55
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 58
  if (qcmd == (88 << 8) + 6) {
#line 58
    goto case_exp;
  }
#line 60
  if (qcmd == (88 << 8) + 1) {
#line 60
    goto case_exp___0;
  }
#line 69
  if (qcmd == (88 << 8) + 2) {
#line 69
    goto case_exp___1;
  }
#line 57
  goto switch_break___0;
  case_exp: /* CIL Label */ 
#line 59
  return (1);
  case_exp___0: /* CIL Label */ 
#line 61
  if (roothack) {
    {
#line 62
    tmp___3 = type2name(type);
#line 62
    tmp___4 = gettext((char const   *)tmp___3);
#line 62
    tmp___5 = gettext("Enabling %s quota on root filesystem (reboot to take effect)\n");
#line 62
    pinfo(tmp___5, tmp___4);
    }
#line 64
    return (1);
  }
  {
#line 66
  tmp___6 = type2name(type);
#line 66
  tmp___7 = gettext((char const   *)tmp___6);
#line 66
  tmp___8 = gettext("Enable XFS %s quota accounting during mount\n");
#line 66
  errstr(tmp___8, tmp___7);
  }
#line 68
  return (-1);
  case_exp___1: /* CIL Label */ 
#line 70
  return (0);
  switch_break___0: /* CIL Label */ ;
  }
#line 72
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 75
  if (qcmd == (88 << 8) + 6) {
#line 75
    goto case_exp___2;
  }
#line 80
  if (qcmd == (88 << 8) + 1) {
#line 80
    goto case_exp___3;
  }
#line 93
  if (qcmd == (88 << 8) + 2) {
#line 93
    goto case_exp___4;
  }
#line 74
  goto switch_break___1;
  case_exp___2: /* CIL Label */ 
  {
#line 76
  tmp___9 = type2name(type);
#line 76
  tmp___10 = gettext((char const   *)tmp___9);
#line 76
  tmp___11 = gettext("Cannot delete %s quota on %s - switch quota accounting off first\n");
#line 76
  errstr(tmp___11, tmp___10, dev);
  }
#line 79
  return (-1);
  case_exp___3: /* CIL Label */ 
#line 81
  if (roothack) {
    {
#line 82
    tmp___12 = type2name(type);
#line 82
    tmp___13 = gettext((char const   *)tmp___12);
#line 82
    tmp___14 = gettext("Enabling %s quota on root filesystem (reboot to take effect)\n");
#line 82
    pinfo(tmp___14, tmp___13);
    }
#line 84
    return (1);
  }
#line 86
  if (xopts & (1 << 1)) {
    {
#line 87
    tmp___15 = type2name(type);
#line 87
    tmp___16 = gettext((char const   *)tmp___15);
#line 87
    tmp___17 = gettext("Enabling %s quota enforcement on %s\n");
#line 87
    pinfo(tmp___17, tmp___16, dev);
    }
#line 88
    return (1);
  } else
#line 86
  if (xopts & (1 << 3)) {
    {
#line 87
    tmp___15 = type2name(type);
#line 87
    tmp___16 = gettext((char const   *)tmp___15);
#line 87
    tmp___17 = gettext("Enabling %s quota enforcement on %s\n");
#line 87
    pinfo(tmp___17, tmp___16, dev);
    }
#line 88
    return (1);
  }
  {
#line 90
  tmp___18 = type2name(type);
#line 90
  tmp___19 = gettext((char const   *)tmp___18);
#line 90
  tmp___20 = gettext("Already accounting %s quota on %s\n");
#line 90
  errstr(tmp___20, tmp___19, dev);
  }
#line 92
  return (-1);
  case_exp___4: /* CIL Label */ 
#line 94
  if (xopts & 1) {
    {
#line 95
    tmp___21 = type2name(type);
#line 95
    tmp___22 = gettext((char const   *)tmp___21);
#line 95
    tmp___23 = gettext("Disabling %s quota accounting on %s\n");
#line 95
    pinfo(tmp___23, tmp___22, dev);
    }
#line 97
    return (1);
  } else
#line 94
  if (xopts & (1 << 2)) {
    {
#line 95
    tmp___21 = type2name(type);
#line 95
    tmp___22 = gettext((char const   *)tmp___21);
#line 95
    tmp___23 = gettext("Disabling %s quota accounting on %s\n");
#line 95
    pinfo(tmp___23, tmp___22, dev);
    }
#line 97
    return (1);
  }
  {
#line 99
  tmp___24 = type2name(type);
#line 99
  tmp___25 = gettext((char const   *)tmp___24);
#line 99
  tmp___26 = gettext("Quota enforcement already disabled for %s on %s\n");
#line 99
  errstr(tmp___26, tmp___25, dev);
  }
#line 101
  return (-1);
  switch_break___1: /* CIL Label */ ;
  }
#line 103
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 107
  if (qcmd == (88 << 8) + 6) {
#line 107
    goto case_exp___5;
  }
#line 112
  if (qcmd == (88 << 8) + 1) {
#line 112
    goto case_exp___6;
  }
#line 116
  if (qcmd == (88 << 8) + 2) {
#line 116
    goto case_exp___7;
  }
#line 106
  goto switch_break___2;
  case_exp___5: /* CIL Label */ 
  {
#line 108
  tmp___27 = type2name(type);
#line 108
  tmp___28 = gettext((char const   *)tmp___27);
#line 108
  tmp___29 = gettext("Cannot delete %s quota on %s - switch quota enforcement and accounting off first\n");
#line 108
  errstr(tmp___29, tmp___28, dev);
  }
#line 111
  return (-1);
  case_exp___6: /* CIL Label */ 
  {
#line 113
  tmp___30 = type2name(type);
#line 113
  tmp___31 = gettext((char const   *)tmp___30);
#line 113
  tmp___32 = gettext("Enforcing %s quota already on %s\n");
#line 113
  errstr(tmp___32, tmp___31, dev);
  }
#line 115
  return (-1);
  case_exp___7: /* CIL Label */ 
#line 117
  if (xopts == 1) {
    {
#line 118
    tmp___33 = type2name(type);
#line 118
    tmp___34 = gettext((char const   *)tmp___33);
#line 118
    tmp___35 = gettext("Cannot switch off %s quota accounting on %s when enforcement is on\n");
#line 118
    errstr(tmp___35, tmp___34, dev);
    }
#line 121
    return (-1);
  } else
#line 117
  if (xopts == 1 << 2) {
    {
#line 118
    tmp___33 = type2name(type);
#line 118
    tmp___34 = gettext((char const   *)tmp___33);
#line 118
    tmp___35 = gettext("Cannot switch off %s quota accounting on %s when enforcement is on\n");
#line 118
    errstr(tmp___35, tmp___34, dev);
    }
#line 121
    return (-1);
  }
#line 123
  if (xopts & 1) {
    {
#line 124
    acctstr = gettext("and accounting ");
    }
  } else
#line 123
  if (xopts & (1 << 2)) {
    {
#line 124
    acctstr = gettext("and accounting ");
    }
  }
  {
#line 125
  tmp___36 = type2name(type);
#line 125
  tmp___37 = gettext((char const   *)tmp___36);
#line 125
  tmp___38 = gettext("Disabling %s quota enforcement %son %s\n");
#line 125
  pinfo(tmp___38, tmp___37, acctstr, dev);
  }
#line 127
  return (1);
  switch_break___2: /* CIL Label */ ;
  }
#line 129
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 131
  tmp___39 = gettext("Unexpected XFS quota state sought on %s\n");
#line 131
  errstr(tmp___39, dev);
  }
#line 132
  return (-1);
}
}
#line 135 "/home/wheatley/newnew/temp/quota-4.01/quotaon_xfs.c"
static int xfs_onoff(char const   *dev , int type , int flags___7 , int roothack ,
                     int xopts ) 
{ 
  int qoff ;
  int qcmd ;
  int check ;
  int *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  long tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;

  {
#line 139
  qoff = flags___7 & 2;
#line 140
  if (qoff) {
#line 140
    qcmd = (88 << 8) + 2;
  } else {
#line 140
    qcmd = (88 << 8) + 1;
  }
  {
#line 141
  check = xfs_state_check(qcmd, type, flags___7, dev, roothack, xopts);
  }
#line 142
  if (check != 1) {
#line 143
    return (check < 0);
  }
  {
#line 145
  tmp___2 = quotactl((qcmd << 8) | (type & 255), dev, (qid_t )0, (caddr_t )((void *)(& xopts)));
  }
#line 145
  if (tmp___2 < 0L) {
    {
#line 146
    tmp = __errno_location();
#line 146
    tmp___0 = strerror(*tmp);
#line 146
    tmp___1 = gettext("quotactl on %s: %s\n");
#line 146
    errstr(tmp___1, dev, tmp___0);
    }
#line 147
    return (1);
  }
#line 149
  if (qoff) {
    {
#line 150
    tmp___3 = type2name(type);
#line 150
    tmp___4 = gettext((char const   *)tmp___3);
#line 150
    tmp___5 = gettext("%s: %s quotas turned off\n");
#line 150
    pinfo(tmp___5, dev, tmp___4);
    }
  } else {
    {
#line 152
    tmp___6 = type2name(type);
#line 152
    tmp___7 = gettext((char const   *)tmp___6);
#line 152
    tmp___8 = gettext("%s: %s quotas turned on\n");
#line 152
    pinfo(tmp___8, dev, tmp___7);
    }
  }
#line 153
  return (0);
}
}
#line 156 "/home/wheatley/newnew/temp/quota-4.01/quotaon_xfs.c"
static int xfs_delete(char const   *dev , int type , int flags___7 , int roothack ,
                      int xopts ) 
{ 
  int qcmd ;
  int check ;
  int *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  long tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;

  {
  {
#line 160
  qcmd = (88 << 8) + 6;
#line 161
  check = xfs_state_check(qcmd, type, flags___7, dev, roothack, xopts);
  }
#line 162
  if (check != 1) {
#line 163
    return (check < 0);
  }
  {
#line 165
  tmp___2 = quotactl((qcmd << 8) | (type & 255), dev, (qid_t )0, (caddr_t )((void *)(& xopts)));
  }
#line 165
  if (tmp___2 < 0L) {
    {
#line 166
    tmp = __errno_location();
#line 166
    tmp___0 = strerror(*tmp);
#line 166
    tmp___1 = gettext("Failed to delete quota: %s\n");
#line 166
    errstr(tmp___1, tmp___0);
    }
#line 168
    return (1);
  }
  {
#line 171
  tmp___3 = type2name(type);
#line 171
  tmp___4 = gettext((char const   *)tmp___3);
#line 171
  tmp___5 = gettext("%s: deleted %s quota blocks\n");
#line 171
  pinfo(tmp___5, dev, tmp___4);
  }
#line 172
  return (0);
}
}
#line 181 "/home/wheatley/newnew/temp/quota-4.01/quotaon_xfs.c"
int xfs_newstate(struct mount_entry *mnt___2 , int type , char *xarg___0 , int flags___7 ) 
{ 
  int err ;
  int xopts ;
  int roothack ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 183
  err = 1;
#line 184
  xopts = 0;
#line 185
  roothack = 0;
#line 206
  if ((unsigned long )xarg___0 == (unsigned long )((void *)0)) {
#line 207
    if (type == 0) {
#line 207
      tmp = 1 << 1;
    } else {
#line 207
      tmp = 1 << 3;
    }
    {
#line 207
    xopts |= tmp;
#line 209
    err = xfs_onoff(mnt___2->me_devname, type, flags___7, roothack, xopts);
    }
  } else {
    {
#line 211
    tmp___6 = strcmp((char const   *)xarg___0, "account");
    }
#line 211
    if (tmp___6 == 0) {
#line 212
      if (type == 0) {
#line 212
        tmp___0 = 1;
      } else {
#line 212
        tmp___0 = 1 << 2;
      }
      {
#line 212
      xopts |= tmp___0;
#line 213
      err = xfs_onoff(mnt___2->me_devname, type, flags___7, roothack, xopts);
      }
    } else {
      {
#line 215
      tmp___5 = strcmp((char const   *)xarg___0, "enforce");
      }
#line 215
      if (tmp___5 == 0) {
#line 216
        if (type == 0) {
#line 216
          tmp___1 = 1 << 1;
        } else {
#line 216
          tmp___1 = 1 << 3;
        }
        {
#line 216
        xopts |= tmp___1;
#line 217
        err = xfs_onoff(mnt___2->me_devname, type, flags___7, roothack, xopts);
        }
      } else {
        {
#line 219
        tmp___4 = strcmp((char const   *)xarg___0, "delete");
        }
#line 219
        if (tmp___4 == 0) {
#line 220
          if (type == 0) {
#line 220
            tmp___2 = 1;
          } else {
#line 220
            tmp___2 = 1 << 2;
          }
          {
#line 220
          xopts |= tmp___2;
#line 221
          err = xfs_delete(mnt___2->me_devname, type, flags___7, roothack, xopts);
          }
        } else {
          {
#line 224
          tmp___3 = gettext("Invalid argument \"%s\"\n");
#line 224
          die(1, tmp___3, xarg___0);
          }
        }
      }
    }
  }
#line 225
  return (err);
}
}
#line 50 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v1.c"
static int v1_check_file___1(int fd , int type , int fmt___7 ) ;
#line 51
static int v1_init_io___1(struct quota_handle *h ) ;
#line 52
static int v1_new_io___1(struct quota_handle *h ) ;
#line 53
static int v1_write_info___1(struct quota_handle *h ) ;
#line 54
static struct dquot *v1_read_dquot___1(struct quota_handle *h , qid_t id___0 ) ;
#line 55
static int v1_commit_dquot___1(struct dquot *dquot , int flags___7 ) ;
#line 56
static int v1_scan_dquots___1(struct quota_handle *h , int (*process_dquot)(struct dquot *dquot ,
                                                                            char *dqname ) ) ;
#line 127 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v1.c"
static int v1_check_file___1(int fd , int type , int fmt___7 ) 
{ 
  struct stat st ;
  int tmp ;

  {
  {
#line 131
  tmp = fstat(fd, & st);
  }
#line 131
  if (tmp < 0) {
#line 132
    return (0);
  }
#line 133
  if (! st.st_size) {
#line 134
    return (0);
  } else
#line 133
  if ((unsigned long )st.st_size % sizeof(struct v1_disk_dqblk )) {
#line 134
    return (0);
  }
#line 135
  return (1);
}
}
#line 141 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v1.c"
static int v1_init_io___1(struct quota_handle *h ) 
{ 
  int tmp ;
  struct v1_kern_dqblk kdqblk ;
  time_t tmp___0 ;
  int *tmp___1 ;
  long tmp___2 ;
  struct v1_disk_dqblk ddqblk ;
  ssize_t tmp___3 ;

  {
#line 143
  if (h->qh_io_flags & 1) {
#line 144
    if (kernel_iface == 3) {
      {
#line 145
      tmp = vfs_get_info(h);
      }
#line 145
      if (tmp < 0) {
#line 146
        return (-1);
      }
    } else {
      {
#line 151
      tmp___2 = quotactl((768 << 8) | (h->qh_type & 255), (char const   *)(h->qh_quotadev),
                         (qid_t )0, (caddr_t )((void *)(& kdqblk)));
      }
#line 151
      if (tmp___2 < 0L) {
        {
#line 152
        tmp___1 = __errno_location();
        }
#line 152
        if (*tmp___1 == 1) {
#line 153
          tmp___0 = (time_t )0;
#line 153
          h->qh_info.dqi_igrace = tmp___0;
#line 153
          h->qh_info.dqi_bgrace = tmp___0;
        } else {
#line 156
          return (-1);
        }
      } else {
#line 159
        h->qh_info.dqi_bgrace = kdqblk.dqb_btime;
#line 160
        h->qh_info.dqi_igrace = kdqblk.dqb_itime;
      }
    }
  } else {
    {
#line 167
    lseek(h->qh_fd, (__off64_t )0, 0);
#line 168
    tmp___3 = read(h->qh_fd, (void *)(& ddqblk), sizeof(ddqblk));
    }
#line 168
    if ((unsigned long )tmp___3 != sizeof(ddqblk)) {
#line 169
      return (-1);
    }
#line 170
    h->qh_info.dqi_bgrace = ddqblk.dqb_btime;
#line 171
    h->qh_info.dqi_igrace = ddqblk.dqb_itime;
  }
#line 173
  if (! h->qh_info.dqi_bgrace) {
#line 174
    h->qh_info.dqi_bgrace = (time_t )604800;
  }
#line 175
  if (! h->qh_info.dqi_igrace) {
#line 176
    h->qh_info.dqi_igrace = (time_t )604800;
  }
#line 177
  h->qh_info.dqi_max_b_limit = (uint64_t )(~ ((uint32_t )0));
#line 178
  h->qh_info.dqi_max_i_limit = (uint64_t )(~ ((uint32_t )0));
#line 179
  h->qh_info.dqi_max_b_usage = 4294967295UL << 10;
#line 180
  h->qh_info.dqi_max_i_usage = (uint64_t )(~ ((uint32_t )0));
#line 182
  return (0);
}
}
#line 188 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v1.c"
static int v1_new_io___1(struct quota_handle *h ) 
{ 
  struct v1_disk_dqblk ddqblk ;
  ssize_t tmp ;

  {
  {
#line 193
  memset((void *)(& ddqblk), 0, sizeof(ddqblk));
#line 194
  ddqblk.dqb_btime = (time_t )604800;
#line 195
  ddqblk.dqb_itime = (time_t )604800;
#line 196
  h->qh_info.dqi_bgrace = (time_t )604800;
#line 197
  h->qh_info.dqi_igrace = (time_t )604800;
#line 198
  h->qh_info.dqi_max_b_limit = (uint64_t )(~ ((uint32_t )0));
#line 199
  h->qh_info.dqi_max_i_limit = (uint64_t )(~ ((uint32_t )0));
#line 200
  h->qh_info.dqi_max_b_usage = 4294967295UL << 10;
#line 201
  h->qh_info.dqi_max_i_usage = (uint64_t )(~ ((uint32_t )0));
#line 202
  lseek(h->qh_fd, (__off64_t )0, 0);
#line 203
  tmp = write(h->qh_fd, (void const   *)(& ddqblk), sizeof(ddqblk));
  }
#line 203
  if ((unsigned long )tmp != sizeof(ddqblk)) {
#line 204
    return (-1);
  }
#line 205
  return (0);
}
}
#line 211 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v1.c"
static int v1_write_info___1(struct quota_handle *h ) 
{ 
  char *tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  struct v1_kern_dqblk kdqblk ;
  long tmp___2 ;
  long tmp___3 ;
  struct v1_disk_dqblk ddqblk ;
  ssize_t tmp___4 ;
  ssize_t tmp___5 ;

  {
#line 213
  if (h->qh_io_flags & 4) {
    {
#line 214
    tmp = gettext("Trying to write info to readonly quotafile on %s.\n");
#line 214
    errstr(tmp, h->qh_quotadev);
#line 215
    tmp___0 = __errno_location();
#line 215
    *tmp___0 = 1;
    }
#line 216
    return (-1);
  }
#line 218
  if (h->qh_io_flags & 1) {
#line 219
    if (kernel_iface == 3) {
      {
#line 220
      tmp___1 = vfs_set_info(h, 3);
      }
#line 220
      if (tmp___1 < 0) {
#line 221
        return (-1);
      }
    } else {
      {
#line 226
      tmp___2 = quotactl((768 << 8) | (h->qh_type & 255), (char const   *)(h->qh_quotadev),
                         (qid_t )0, (caddr_t )((void *)(& kdqblk)));
      }
#line 226
      if (tmp___2 < 0L) {
#line 227
        return (-1);
      }
      {
#line 228
      kdqblk.dqb_btime = h->qh_info.dqi_bgrace;
#line 229
      kdqblk.dqb_itime = h->qh_info.dqi_igrace;
#line 230
      tmp___3 = quotactl((1024 << 8) | (h->qh_type & 255), (char const   *)(h->qh_quotadev),
                         (qid_t )0, (caddr_t )((void *)(& kdqblk)));
      }
#line 230
      if (tmp___3 < 0L) {
#line 231
        return (-1);
      }
    }
  } else {
    {
#line 237
    lseek(h->qh_fd, (__off64_t )0, 0);
#line 238
    tmp___4 = read(h->qh_fd, (void *)(& ddqblk), sizeof(ddqblk));
    }
#line 238
    if ((unsigned long )tmp___4 != sizeof(ddqblk)) {
#line 239
      return (-1);
    }
    {
#line 240
    ddqblk.dqb_btime = h->qh_info.dqi_bgrace;
#line 241
    ddqblk.dqb_itime = h->qh_info.dqi_igrace;
#line 242
    lseek(h->qh_fd, (__off64_t )0, 0);
#line 243
    tmp___5 = write(h->qh_fd, (void const   *)(& ddqblk), sizeof(ddqblk));
    }
#line 243
    if ((unsigned long )tmp___5 != sizeof(ddqblk)) {
#line 244
      return (-1);
    }
  }
#line 246
  return (0);
}
}
#line 253 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v1.c"
static struct dquot *v1_read_dquot___1(struct quota_handle *h , qid_t id___0 ) 
{ 
  struct v1_disk_dqblk ddqblk ;
  struct dquot *dquot ;
  struct dquot *tmp ;
  int tmp___0 ;
  struct v1_kern_dqblk kdqblk ;
  long tmp___1 ;
  ssize_t tmp___2 ;

  {
  {
#line 256
  tmp = get_empty_dquot();
#line 256
  dquot = tmp;
#line 258
  dquot->dq_id = id___0;
#line 259
  dquot->dq_h = h;
  }
#line 260
  if (h->qh_io_flags & 1) {
#line 261
    if (kernel_iface == 3) {
      {
#line 262
      tmp___0 = vfs_get_dquot(dquot);
      }
#line 262
      if (tmp___0 < 0) {
        {
#line 263
        free((void *)dquot);
        }
#line 264
        return ((struct dquot *)((void *)0));
      }
    } else {
      {
#line 270
      tmp___1 = quotactl((768 << 8) | (h->qh_type & 255), (char const   *)(h->qh_quotadev),
                         id___0, (caddr_t )((void *)(& kdqblk)));
      }
#line 270
      if (tmp___1 < 0L) {
        {
#line 271
        free((void *)dquot);
        }
#line 272
        return ((struct dquot *)((void *)0));
      }
      {
#line 274
      v1_kern2utildqblk(& dquot->dq_dqb, & kdqblk);
      }
    }
  } else {
    {
#line 278
    lseek(h->qh_fd, (loff_t )((unsigned long )id___0 * sizeof(struct v1_disk_dqblk )),
          0);
#line 279
    tmp___2 = read(h->qh_fd, (void *)(& ddqblk), sizeof(ddqblk));
    }
    {
#line 280
    if (tmp___2 == 0L) {
#line 280
      goto case_0;
    }
#line 287
    if (tmp___2 == (ssize_t )sizeof(struct v1_disk_dqblk )) {
#line 287
      goto case_exp;
    }
#line 290
    goto switch_default;
    case_0: /* CIL Label */ 
    {
#line 285
    memset((void *)(& dquot->dq_dqb), 0, sizeof(struct util_dqblk ));
    }
#line 286
    goto switch_break;
    case_exp: /* CIL Label */ 
    {
#line 288
    v1_disk2memdqblk(& dquot->dq_dqb, & ddqblk);
    }
#line 289
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 291
    free((void *)dquot);
    }
#line 292
    return ((struct dquot *)((void *)0));
    switch_break: /* CIL Label */ ;
    }
  }
#line 295
  return (dquot);
}
}
#line 302 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v1.c"
static int v1_commit_dquot___1(struct dquot *dquot , int flags___7 ) 
{ 
  struct v1_disk_dqblk ddqblk ;
  struct quota_handle *h ;
  char *tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  struct v1_kern_dqblk kdqblk ;
  int cmd ;
  int *tmp___2 ;
  long tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;
  ssize_t tmp___6 ;

  {
#line 305
  h = dquot->dq_h;
#line 307
  if (h->qh_io_flags & 4) {
    {
#line 308
    tmp = gettext("Trying to write quota to readonly quotafile on %s\n");
#line 308
    errstr(tmp, h->qh_quotadev);
#line 309
    tmp___0 = __errno_location();
#line 309
    *tmp___0 = 1;
    }
#line 310
    return (-1);
  }
#line 312
  if (h->qh_io_flags & 1) {
#line 313
    if (kernel_iface == 3) {
      {
#line 314
      tmp___1 = vfs_set_dquot(dquot, flags___7);
      }
#line 314
      if (tmp___1 < 0) {
#line 315
        return (-1);
      }
    } else {
#line 321
      if (flags___7 == 10) {
#line 322
        cmd = 1280;
      } else
#line 323
      if (flags___7 == 5) {
#line 324
        cmd = 1792;
      } else
#line 325
      if (flags___7 & 48) {
        {
#line 326
        tmp___2 = __errno_location();
#line 326
        *tmp___2 = 22;
        }
#line 327
        return (-1);
      } else {
#line 330
        cmd = 1024;
      }
      {
#line 331
      v1_util2kerndqblk(& kdqblk, & dquot->dq_dqb);
#line 332
      tmp___3 = quotactl((cmd << 8) | (h->qh_type & 255), (char const   *)(h->qh_quotadev),
                         dquot->dq_id, (caddr_t )((void *)(& kdqblk)));
      }
#line 332
      if (tmp___3 < 0L) {
#line 334
        return (-1);
      }
    }
  } else {
    {
#line 338
    tmp___5 = check_dquot_range(dquot);
    }
#line 338
    if (tmp___5 < 0) {
      {
#line 339
      tmp___4 = __errno_location();
#line 339
      *tmp___4 = 34;
      }
#line 340
      return (-1);
    }
    {
#line 342
    v1_mem2diskdqblk(& ddqblk, & dquot->dq_dqb);
#line 343
    lseek(h->qh_fd, (loff_t )((unsigned long )dquot->dq_id * sizeof(struct v1_disk_dqblk )),
          0);
#line 344
    tmp___6 = write(h->qh_fd, (void const   *)(& ddqblk), sizeof(ddqblk));
    }
#line 344
    if ((unsigned long )tmp___6 != sizeof(ddqblk)) {
#line 345
      return (-1);
    }
  }
#line 347
  return (0);
}
}
#line 355 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v1.c"
static int v1_scan_dquots___1(struct quota_handle *h , int (*process_dquot)(struct dquot *dquot ,
                                                                            char *dqname ) ) 
{ 
  int rd ;
  int scanbufpos ;
  int scanbufsize ;
  char scanbuf[sizeof(struct v1_disk_dqblk ) * 256UL] ;
  struct v1_disk_dqblk *ddqblk ;
  struct dquot *dquot ;
  struct dquot *tmp ;
  qid_t id___0 ;
  ssize_t tmp___0 ;

  {
  {
#line 357
  scanbufpos = 0;
#line 357
  scanbufsize = 0;
#line 360
  tmp = get_empty_dquot();
#line 360
  dquot = tmp;
#line 361
  id___0 = (qid_t )0;
#line 363
  memset((void *)dquot, 0, sizeof(*dquot));
#line 364
  dquot->dq_h = h;
#line 365
  lseek(h->qh_fd, (__off64_t )0, 0);
#line 366
  id___0 = (qid_t )0;
  }
  {
#line 366
  while (1) {
    while_continue: /* CIL Label */ ;
#line 367
    if (scanbufpos >= scanbufsize) {
      {
#line 368
      tmp___0 = read(h->qh_fd, (void *)(scanbuf), sizeof(scanbuf));
#line 368
      rd = (int )tmp___0;
      }
#line 369
      if (rd < 0) {
#line 370
        goto out_err;
      } else
#line 369
      if ((unsigned long )rd % sizeof(struct v1_disk_dqblk )) {
#line 370
        goto out_err;
      }
#line 371
      if (! rd) {
#line 372
        goto while_break;
      }
#line 373
      scanbufpos = 0;
#line 374
      scanbufsize = (int )((unsigned long )rd / sizeof(struct v1_disk_dqblk ));
    }
#line 376
    ddqblk = (struct v1_disk_dqblk *)(scanbuf) + scanbufpos;
#line 377
    if ((((long )(((((ddqblk->dqb_ihardlimit | ddqblk->dqb_isoftlimit) | ddqblk->dqb_bhardlimit) | ddqblk->dqb_bsoftlimit) | ddqblk->dqb_curblocks) | ddqblk->dqb_curinodes) | ddqblk->dqb_itime) | ddqblk->dqb_btime) == 0L) {
#line 381
      goto __Cont;
    }
    {
#line 382
    v1_disk2memdqblk(& dquot->dq_dqb, ddqblk);
#line 383
    dquot->dq_id = id___0;
#line 384
    rd = (*process_dquot)(dquot, (char *)((void *)0));
    }
#line 384
    if (rd < 0) {
      {
#line 385
      free((void *)dquot);
      }
#line 386
      return (rd);
    }
    __Cont: /* CIL Label */ 
#line 366
    id___0 ++;
#line 366
    scanbufpos ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 389
  if (! rd) {
    {
#line 390
    free((void *)dquot);
    }
#line 391
    return (0);
  }
  out_err: 
  {
#line 394
  free((void *)dquot);
  }
#line 395
  return (-1);
}
}
#line 27 "/home/wheatley/newnew/temp/quota-4.01/quotaio_xfs.c"
static int xfs_init_io___1(struct quota_handle *h ) ;
#line 28
static int xfs_write_info___1(struct quota_handle *h ) ;
#line 29
static struct dquot *xfs_read_dquot___1(struct quota_handle *h , qid_t id___0 ) ;
#line 30
static int xfs_commit_dquot___1(struct dquot *dquot , int flags___7 ) ;
#line 31
static int xfs_scan_dquots___1(struct quota_handle *h , int (*process_dquot)(struct dquot *dquot ,
                                                                             char *dqname ) ) ;
#line 32
static int xfs_report___1(struct quota_handle *h , int verbose ) ;
#line 77 "/home/wheatley/newnew/temp/quota-4.01/quotaio_xfs.c"
static int xfs_init_io___1(struct quota_handle *h ) 
{ 
  struct fs_quota_stat info ;
  int qcmd ;
  long tmp ;

  {
  {
#line 82
  qcmd = ((88 << 8) + 5) << 8;
#line 83
  memset((void *)(& info), 0, sizeof(struct fs_quota_stat ));
#line 84
  tmp = quotactl(qcmd, (char const   *)(h->qh_quotadev), (qid_t )0, (caddr_t )((void *)(& info)));
  }
#line 84
  if (tmp < 0L) {
#line 85
    return (-1);
  }
#line 86
  h->qh_info.dqi_bgrace = (time_t )info.qs_btimelimit;
#line 87
  h->qh_info.dqi_igrace = (time_t )info.qs_itimelimit;
#line 88
  h->qh_info.u.xfs_mdqi = info;
#line 89
  return (0);
}
}
#line 95 "/home/wheatley/newnew/temp/quota-4.01/quotaio_xfs.c"
static int xfs_write_info___1(struct quota_handle *h ) 
{ 
  struct fs_disk_quota xdqblk ;
  int qcmd ;
  long tmp ;

  {
#line 100
  if (h->qh_type == 0) {
#line 100
    if (! ((int )h->qh_info.u.xfs_mdqi.qs_flags & 1)) {
#line 100
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 100
  if (h->qh_type == 1) {
#line 100
    if (! ((int )h->qh_info.u.xfs_mdqi.qs_flags & (1 << 2))) {
#line 101
      return (0);
    }
  } else {
#line 101
    return (0);
  }
  {
#line 103
  memset((void *)(& xdqblk), 0, sizeof(struct fs_disk_quota ));
#line 105
  xdqblk.d_btimer = (__s32 )h->qh_info.dqi_bgrace;
#line 106
  xdqblk.d_itimer = (__s32 )h->qh_info.dqi_igrace;
#line 107
  xdqblk.d_fieldmask = (__u16 )((int )xdqblk.d_fieldmask | (((1 << 6) | (1 << 7)) | (1 << 8)));
#line 108
  qcmd = (((88 << 8) + 4) << 8) | (h->qh_type & 255);
#line 109
  tmp = quotactl(qcmd, (char const   *)(h->qh_quotadev), (qid_t )0, (caddr_t )((void *)(& xdqblk)));
  }
#line 109
  if (tmp < 0L) {
#line 110
    return (-1);
  }
#line 111
  return (0);
}
}
#line 117 "/home/wheatley/newnew/temp/quota-4.01/quotaio_xfs.c"
static struct dquot *xfs_read_dquot___1(struct quota_handle *h , qid_t id___0 ) 
{ 
  struct dquot *dquot ;
  struct dquot *tmp ;
  struct fs_disk_quota xdqblk ;
  int qcmd ;
  long tmp___0 ;

  {
  {
#line 119
  tmp = get_empty_dquot();
#line 119
  dquot = tmp;
#line 123
  dquot->dq_id = id___0;
#line 124
  dquot->dq_h = h;
  }
#line 126
  if (h->qh_type == 0) {
#line 126
    if (! ((int )h->qh_info.u.xfs_mdqi.qs_flags & 1)) {
#line 126
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 126
  if (h->qh_type == 1) {
#line 126
    if (! ((int )h->qh_info.u.xfs_mdqi.qs_flags & (1 << 2))) {
#line 127
      return (dquot);
    }
  } else {
#line 127
    return (dquot);
  }
  {
#line 129
  qcmd = (((88 << 8) + 3) << 8) | (h->qh_type & 255);
#line 130
  tmp___0 = quotactl(qcmd, (char const   *)(h->qh_quotadev), id___0, (caddr_t )((void *)(& xdqblk)));
  }
#line 130
  if (! (tmp___0 < 0L)) {
    {
#line 134
    xfs_kern2utildqblk(& dquot->dq_dqb, & xdqblk);
    }
  }
#line 136
  return (dquot);
}
}
#line 142 "/home/wheatley/newnew/temp/quota-4.01/quotaio_xfs.c"
static int xfs_commit_dquot___1(struct dquot *dquot , int flags___7 ) 
{ 
  struct quota_handle *h ;
  struct fs_disk_quota xdqblk ;
  qid_t id___0 ;
  int qcmd ;
  int tmp ;
  int tmp___0 ;
  long tmp___1 ;

  {
#line 144
  h = dquot->dq_h;
#line 146
  id___0 = dquot->dq_id;
#line 149
  if (h->qh_type == 0) {
#line 149
    if (! ((int )h->qh_info.u.xfs_mdqi.qs_flags & 1)) {
#line 149
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 149
  if (h->qh_type == 1) {
#line 149
    if (! ((int )h->qh_info.u.xfs_mdqi.qs_flags & (1 << 2))) {
#line 150
      return (0);
    }
  } else {
#line 150
    return (0);
  }
  {
#line 152
  xfs_util2kerndqblk(& xdqblk, & dquot->dq_dqb);
  }
#line 153
  if (h->qh_type == 0) {
#line 153
    if ((int )h->qh_info.u.xfs_mdqi.qs_flags & 1) {
#line 153
      tmp = 1;
    } else {
#line 153
      tmp = 1 << 2;
    }
  } else {
#line 153
    tmp = 1 << 2;
  }
  {
#line 153
  xdqblk.d_flags = (__s8 )((int )xdqblk.d_flags | tmp);
#line 154
  xdqblk.d_id = id___0;
#line 155
  tmp___0 = strcmp((char const   *)(h->qh_fstype), "gfs2");
  }
#line 155
  if (tmp___0 == 0) {
#line 156
    if (flags___7 & 5) {
#line 157
      xdqblk.d_fieldmask = (__u16 )((int )xdqblk.d_fieldmask | ((1 << 2) | (1 << 3)));
    }
#line 158
    if (flags___7 & 10) {
#line 159
      xdqblk.d_fieldmask = (__u16 )((int )xdqblk.d_fieldmask | (1 << 12));
    }
  } else {
#line 161
    xdqblk.d_fieldmask = (__u16 )((int )xdqblk.d_fieldmask | (((((1 | (1 << 1)) | (1 << 2)) | (1 << 3)) | (1 << 4)) | (1 << 5)));
  }
  {
#line 164
  qcmd = (((88 << 8) + 4) << 8) | (h->qh_type & 255);
#line 165
  tmp___1 = quotactl(qcmd, (char const   *)(h->qh_quotadev), id___0, (caddr_t )((void *)(& xdqblk)));
  }
#line 165
  if (! (tmp___1 < 0L)) {
#line 169
    return (0);
  }
#line 171
  return (-1);
}
}
#line 177 "/home/wheatley/newnew/temp/quota-4.01/quotaio_xfs.c"
static int xfs_get_dquot___1(struct dquot *dq ) 
{ 
  struct fs_disk_quota d ;
  int qcmd ;
  int ret ;
  long tmp ;
  int *tmp___0 ;

  {
  {
#line 180
  qcmd = (((88 << 8) + 3) << 8) | ((dq->dq_h)->qh_type & 255);
#line 183
  memset((void *)(& d), 0, sizeof(d));
#line 184
  tmp = quotactl(qcmd, (char const   *)((dq->dq_h)->qh_quotadev), dq->dq_id, (caddr_t )((void *)(& d)));
#line 184
  ret = (int )tmp;
  }
#line 185
  if (ret < 0) {
    {
#line 186
    tmp___0 = __errno_location();
    }
#line 186
    if (*tmp___0 == 2) {
#line 187
      return (0);
    }
#line 188
    return (-1);
  }
  {
#line 190
  xfs_kern2utildqblk(& dq->dq_dqb, & d);
  }
#line 191
  return (0);
}
}
#line 197 "/home/wheatley/newnew/temp/quota-4.01/quotaio_xfs.c"
static int xfs_scan_dquots___1(struct quota_handle *h , int (*process_dquot)(struct dquot *dquot ,
                                                                             char *dqname ) ) 
{ 
  int tmp ;

  {
#line 199
  if (h->qh_type == 0) {
#line 199
    if (! ((int )h->qh_info.u.xfs_mdqi.qs_flags & 1)) {
#line 199
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 199
  if (h->qh_type == 1) {
#line 199
    if (! ((int )h->qh_info.u.xfs_mdqi.qs_flags & (1 << 2))) {
#line 200
      return (0);
    }
  } else {
#line 200
    return (0);
  }
  {
#line 202
  tmp = generic_scan_dquots(h, process_dquot, & xfs_get_dquot___1);
  }
#line 202
  return (tmp);
}
}
#line 208 "/home/wheatley/newnew/temp/quota-4.01/quotaio_xfs.c"
static int xfs_report___1(struct quota_handle *h , int verbose ) 
{ 
  u_int16_t sbflags ;
  struct fs_quota_stat *info ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;
  char *tmp___18 ;
  char *tmp___19 ;
  char *tmp___20 ;
  char *tmp___21 ;
  char *tmp___22 ;
  char *tmp___23 ;
  char *tmp___24 ;
  char *tmp___25 ;
  char *tmp___26 ;
  char *tmp___27 ;
  char *tmp___28 ;
  char *tmp___29 ;
  char *tmp___30 ;
  char *tmp___31 ;
  char *tmp___32 ;

  {
#line 211
  info = & h->qh_info.u.xfs_mdqi;
#line 213
  if (! verbose) {
#line 214
    return (0);
  }
  {
#line 217
  tmp = type2name(h->qh_type);
#line 217
  tmp___0 = gettext("*** Status for %s quotas on device %s\n");
#line 217
  printf((char const   */* __restrict  */)tmp___0, tmp, h->qh_quotadev);
  }
#line 220
  if (h->qh_type == 0) {
#line 221
    if ((int )info->qs_flags & (1 << 1)) {
      {
#line 221
      tmp___1 = gettext("ON");
#line 221
      tmp___3 = tmp___1;
      }
    } else {
      {
#line 221
      tmp___2 = gettext("OFF");
#line 221
      tmp___3 = tmp___2;
      }
    }
#line 221
    if ((int )info->qs_flags & 1) {
      {
#line 221
      tmp___4 = gettext("ON");
#line 221
      tmp___6 = tmp___4;
      }
    } else {
      {
#line 221
      tmp___5 = gettext("OFF");
#line 221
      tmp___6 = tmp___5;
      }
    }
    {
#line 221
    tmp___7 = gettext("Accounting: %s; Enforcement: %s\n");
#line 221
    printf((char const   */* __restrict  */)tmp___7, tmp___6, tmp___3);
    }
  } else {
#line 225
    if ((int )info->qs_flags & (1 << 3)) {
      {
#line 225
      tmp___8 = gettext("ON");
#line 225
      tmp___10 = tmp___8;
      }
    } else {
      {
#line 225
      tmp___9 = gettext("OFF");
#line 225
      tmp___10 = tmp___9;
      }
    }
#line 225
    if ((int )info->qs_flags & (1 << 2)) {
      {
#line 225
      tmp___11 = gettext("ON");
#line 225
      tmp___13 = tmp___11;
      }
    } else {
      {
#line 225
      tmp___12 = gettext("OFF");
#line 225
      tmp___13 = tmp___12;
      }
    }
    {
#line 225
    tmp___14 = gettext("Accounting: %s; Enforcement: %s\n");
#line 225
    printf((char const   */* __restrict  */)tmp___14, tmp___13, tmp___10);
    }
  }
#line 235
  sbflags = (u_int16_t )(((int )info->qs_flags & 65280) >> 8);
#line 235
  if ((int )sbflags != 0) {
#line 236
    if (h->qh_type == 0) {
#line 237
      if ((int )sbflags & (1 << 1)) {
        {
#line 237
        tmp___15 = gettext("ON");
#line 237
        tmp___17 = tmp___15;
        }
      } else {
        {
#line 237
        tmp___16 = gettext("OFF");
#line 237
        tmp___17 = tmp___16;
        }
      }
#line 237
      if ((int )sbflags & 1) {
        {
#line 237
        tmp___18 = gettext("ON");
#line 237
        tmp___20 = tmp___18;
        }
      } else {
        {
#line 237
        tmp___19 = gettext("OFF");
#line 237
        tmp___20 = tmp___19;
        }
      }
      {
#line 237
      tmp___21 = gettext("Accounting [ondisk]: %s; Enforcement [ondisk]: %s\n");
#line 237
      printf((char const   */* __restrict  */)tmp___21, tmp___20, tmp___17);
      }
    } else {
#line 241
      if ((int )sbflags & (1 << 3)) {
        {
#line 241
        tmp___22 = gettext("ON");
#line 241
        tmp___24 = tmp___22;
        }
      } else {
        {
#line 241
        tmp___23 = gettext("OFF");
#line 241
        tmp___24 = tmp___23;
        }
      }
#line 241
      if ((int )sbflags & (1 << 2)) {
        {
#line 241
        tmp___25 = gettext("ON");
#line 241
        tmp___27 = tmp___25;
        }
      } else {
        {
#line 241
        tmp___26 = gettext("OFF");
#line 241
        tmp___27 = tmp___26;
        }
      }
      {
#line 241
      tmp___28 = gettext("Accounting [ondisk]: %s; Enforcement [ondisk]: %s\n");
#line 241
      printf((char const   */* __restrict  */)tmp___28, tmp___27, tmp___24);
      }
    }
  }
#line 248
  if (h->qh_type == 0) {
#line 249
    if (info->qs_uquota.qfs_ino == 0xffffffffffffffffULL) {
      {
#line 250
      tmp___29 = gettext("Inode: none\n");
#line 250
      printf((char const   */* __restrict  */)tmp___29);
      }
    } else
#line 249
    if (info->qs_uquota.qfs_ino == 0ULL) {
      {
#line 250
      tmp___29 = gettext("Inode: none\n");
#line 250
      printf((char const   */* __restrict  */)tmp___29);
      }
    } else {
      {
#line 252
      tmp___30 = gettext("Inode: #%llu (%llu blocks, %u extents)\n");
#line 252
      printf((char const   */* __restrict  */)tmp___30, info->qs_uquota.qfs_ino, info->qs_uquota.qfs_nblks,
             info->qs_uquota.qfs_nextents);
      }
    }
  } else
#line 258
  if (info->qs_gquota.qfs_ino == 0xffffffffffffffffULL) {
    {
#line 259
    tmp___31 = gettext("Inode: none\n");
#line 259
    printf((char const   */* __restrict  */)tmp___31);
    }
  } else {
    {
#line 261
    tmp___32 = gettext("Inode: #%llu (%llu blocks, %u extents)\n");
#line 261
    printf((char const   */* __restrict  */)tmp___32, info->qs_gquota.qfs_ino, info->qs_gquota.qfs_nblks,
           info->qs_gquota.qfs_nextents);
    }
  }
#line 266
  return (0);
}
}
#line 89 "/home/wheatley/newnew/temp/quota-4.01/rquota_client.c"
static int rquota_err___1(int stat___0 ) 
{ 


  {
  {
#line 92
  if (stat___0 == -1) {
#line 92
    goto case_neg_1;
  }
#line 94
  if (stat___0 == 0) {
#line 94
    goto case_0;
  }
#line 96
  if (stat___0 == 2) {
#line 96
    goto case_2;
  }
#line 98
  if (stat___0 == 1) {
#line 98
    goto case_1;
  }
#line 100
  if (stat___0 == 3) {
#line 100
    goto case_3;
  }
#line 102
  goto switch_default;
  case_neg_1: /* CIL Label */ 
#line 93
  return (-111);
  case_0: /* CIL Label */ 
#line 95
  return (-38);
  case_2: /* CIL Label */ 
#line 97
  return (-2);
  case_1: /* CIL Label */ 
#line 99
  return (0);
  case_3: /* CIL Label */ 
#line 101
  return (-1);
  switch_default: /* CIL Label */ 
#line 103
  return (-22);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 107 "/home/wheatley/newnew/temp/quota-4.01/rquota_client.c"
static int split_nfs_mount___1(char *devname , char **host , char **path ) 
{ 
  char *pathname ;

  {
#line 112
  if ((int )*devname == 91) {
    {
#line 113
    *host = devname + 1;
#line 114
    pathname = strchr((char const   *)devname, ']');
    }
#line 115
    if (! pathname) {
#line 116
      return (0);
    } else
#line 115
    if ((int )*(pathname + 1) != 58) {
#line 116
      return (0);
    }
#line 118
    if ((int )*(pathname + 2) == 40) {
#line 119
      return (0);
    }
#line 120
    *pathname = (char)0;
#line 121
    *path = pathname + 2;
#line 122
    return (1);
  }
  {
#line 124
  *host = devname;
#line 125
  pathname = strchr((char const   *)devname, ':');
  }
#line 126
  if (! pathname) {
#line 127
    return (0);
  }
#line 129
  if ((int )*(pathname + 1) == 40) {
#line 130
    return (0);
  }
#line 131
  *pathname = (char)0;
#line 132
  *path = pathname + 1;
#line 133
  return (1);
}
}
#line 377 "/usr/include/stdio.h"
extern int vprintf(char const   * __restrict  __format , __gnuc_va_list __arg ) ;
#line 58 "/home/wheatley/newnew/temp/quota-4.01/quotaon.c"
static int flags___1  ;
#line 58 "/home/wheatley/newnew/temp/quota-4.01/quotaon.c"
static int fmt___1  =    -1;
#line 60 "/home/wheatley/newnew/temp/quota-4.01/quotaon.c"
static char **mntpoints  ;
#line 61 "/home/wheatley/newnew/temp/quota-4.01/quotaon.c"
static int mntcnt  ;
#line 62 "/home/wheatley/newnew/temp/quota-4.01/quotaon.c"
static char *xarg  =    (char *)((void *)0);
#line 64 "/home/wheatley/newnew/temp/quota-4.01/quotaon.c"
static void usage___1(void) 
{ 
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;

  {
  {
#line 66
  tmp___3 = strcmp((char const   *)progname, "quotaon");
  }
#line 66
  if (tmp___3) {
    {
#line 66
    tmp___0 = gettext("turn quotas off for all filesystems");
#line 66
    tmp___2 = tmp___0;
    }
  } else {
    {
#line 66
    tmp___1 = gettext("turn quotas on for all filesystems");
#line 66
    tmp___2 = tmp___1;
    }
  }
  {
#line 66
  tmp___4 = gettext("Usage:\n\t%s [-guvp] [-F quotaformat] [-x state] -a\n\t%s [-guvp] [-F quotaformat] [-x state] filesys ...\n\n-a, --all                %s\n-f, --off                turn quotas off\n-u, --user               operate on user quotas\n-g, --group              operate on group quotas\n-p, --print-state        print whether quotas are on or off\n-x, --xfs-command=cmd    perform XFS quota command\n-F, --format=formatname  operate on specific quota format\n-v, --verbose            print more messages\n-h, --help               display this help text and exit\n-V, --version            display version information and exit\n");
#line 66
  errstr(tmp___4, progname, progname, tmp___2);
#line 81
  exit(1);
  }
}
}
#line 84 "/home/wheatley/newnew/temp/quota-4.01/quotaon.c"
static void parse_options___0(int argcnt , char **argstr ) 
{ 
  int c ;
  struct option long_opts[11] ;
  char *tmp ;
  char *tmp___0 ;

  {
#line 87
  long_opts[0].name = "all";
#line 87
  long_opts[0].has_arg = 0;
#line 87
  long_opts[0].flag = (int *)((void *)0);
#line 87
  long_opts[0].val = 'a';
#line 87
  long_opts[1].name = "off";
#line 87
  long_opts[1].has_arg = 0;
#line 87
  long_opts[1].flag = (int *)((void *)0);
#line 87
  long_opts[1].val = 'f';
#line 87
  long_opts[2].name = "verbose";
#line 87
  long_opts[2].has_arg = 0;
#line 87
  long_opts[2].flag = (int *)((void *)0);
#line 87
  long_opts[2].val = 'v';
#line 87
  long_opts[3].name = "user";
#line 87
  long_opts[3].has_arg = 0;
#line 87
  long_opts[3].flag = (int *)((void *)0);
#line 87
  long_opts[3].val = 'u';
#line 87
  long_opts[4].name = "group";
#line 87
  long_opts[4].has_arg = 0;
#line 87
  long_opts[4].flag = (int *)((void *)0);
#line 87
  long_opts[4].val = 'g';
#line 87
  long_opts[5].name = "print-state";
#line 87
  long_opts[5].has_arg = 0;
#line 87
  long_opts[5].flag = (int *)((void *)0);
#line 87
  long_opts[5].val = 'p';
#line 87
  long_opts[6].name = "xfs-command";
#line 87
  long_opts[6].has_arg = 1;
#line 87
  long_opts[6].flag = (int *)((void *)0);
#line 87
  long_opts[6].val = 'x';
#line 87
  long_opts[7].name = "format";
#line 87
  long_opts[7].has_arg = 1;
#line 87
  long_opts[7].flag = (int *)((void *)0);
#line 87
  long_opts[7].val = 'F';
#line 87
  long_opts[8].name = "version";
#line 87
  long_opts[8].has_arg = 0;
#line 87
  long_opts[8].flag = (int *)((void *)0);
#line 87
  long_opts[8].val = 'V';
#line 87
  long_opts[9].name = "help";
#line 87
  long_opts[9].has_arg = 0;
#line 87
  long_opts[9].flag = (int *)((void *)0);
#line 87
  long_opts[9].val = 'h';
#line 87
  long_opts[10].name = (char const   *)((void *)0);
#line 87
  long_opts[10].has_arg = 0;
#line 87
  long_opts[10].flag = (int *)((void *)0);
#line 87
  long_opts[10].val = 0;
  {
#line 101
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 101
    c = getopt_long(argcnt, (char * const  *)argstr, "afvugpx:VF:h", (struct option  const  *)(long_opts),
                    (int *)((void *)0));
    }
#line 101
    if (! (c != -1)) {
#line 101
      goto while_break;
    }
    {
#line 103
    if (c == 97) {
#line 103
      goto case_97;
    }
#line 106
    if (c == 102) {
#line 106
      goto case_102;
    }
#line 109
    if (c == 103) {
#line 109
      goto case_103;
    }
#line 112
    if (c == 117) {
#line 112
      goto case_117;
    }
#line 115
    if (c == 118) {
#line 115
      goto case_118;
    }
#line 118
    if (c == 120) {
#line 118
      goto case_120;
    }
#line 121
    if (c == 112) {
#line 121
      goto case_112;
    }
#line 124
    if (c == 70) {
#line 124
      goto case_70;
    }
#line 128
    if (c == 86) {
#line 128
      goto case_86;
    }
#line 132
    goto switch_default;
    case_97: /* CIL Label */ 
#line 104
    flags___1 |= 8;
#line 105
    goto switch_break;
    case_102: /* CIL Label */ 
#line 107
    flags___1 |= 32;
#line 108
    goto switch_break;
    case_103: /* CIL Label */ 
#line 110
    flags___1 |= 2;
#line 111
    goto switch_break;
    case_117: /* CIL Label */ 
#line 113
    flags___1 |= 1;
#line 114
    goto switch_break;
    case_118: /* CIL Label */ 
#line 116
    flags___1 |= 4;
#line 117
    goto switch_break;
    case_120: /* CIL Label */ 
#line 119
    xarg = optarg;
#line 120
    goto switch_break;
    case_112: /* CIL Label */ 
#line 122
    flags___1 |= 16;
#line 123
    goto switch_break;
    case_70: /* CIL Label */ 
    {
#line 125
    fmt___1 = name2fmt(optarg);
    }
#line 125
    if (fmt___1 == -1) {
      {
#line 126
      exit(1);
      }
    }
#line 127
    goto switch_break;
    case_86: /* CIL Label */ 
    {
#line 129
    version();
#line 130
    exit(0);
    }
    switch_default: /* CIL Label */ 
    {
#line 133
    usage___1();
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 136
  if (flags___1 & 8) {
#line 136
    if (optind != argcnt) {
      {
#line 137
      tmp = gettext("Bad number of arguments.\n");
#line 137
      fputs((char const   */* __restrict  */)tmp, (FILE */* __restrict  */)stderr);
#line 138
      usage___1();
      }
    } else {
#line 136
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 136
  if (! (flags___1 & 8)) {
#line 136
    if (optind == argcnt) {
      {
#line 137
      tmp = gettext("Bad number of arguments.\n");
#line 137
      fputs((char const   */* __restrict  */)tmp, (FILE */* __restrict  */)stderr);
#line 138
      usage___1();
      }
    }
  }
#line 140
  if (fmt___1 == 3) {
    {
#line 141
    tmp___0 = gettext("Cannot turn on/off quotas via RPC.\n");
#line 141
    fputs((char const   */* __restrict  */)tmp___0, (FILE */* __restrict  */)stderr);
#line 142
    exit(1);
    }
  }
#line 144
  if (! (flags___1 & 3)) {
#line 145
    flags___1 |= 3;
  }
#line 146
  if (! (flags___1 & 8)) {
#line 147
    mntpoints = argstr + optind;
#line 148
    mntcnt = argcnt - optind;
  }
#line 150
  return;
}
}
#line 152 "/home/wheatley/newnew/temp/quota-4.01/quotaon.c"
int pinfo(char *fmt___7  , ...) 
{ 
  va_list arg ;
  int ret ;

  {
#line 157
  if (! (flags___1 & 4)) {
#line 158
    return (0);
  }
  {
#line 159
  __builtin_va_start(arg, fmt___7);
#line 160
  ret = vprintf((char const   */* __restrict  */)fmt___7, arg);
#line 161
  __builtin_va_end(arg);
  }
#line 162
  return (ret);
}
}
#line 168 "/home/wheatley/newnew/temp/quota-4.01/quotaon.c"
static int quotarsquashonoff(char const   *quotadev , int type , int flags___7 ) 
{ 
  int ret ;
  int qcmd ;
  struct if_dqinfo info ;
  long tmp ;
  int mode ;
  int tmp___0 ;
  int qcmd___0 ;
  long tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;

  {
#line 173
  if (kernel_iface == 3) {
    {
#line 174
    qcmd = (8388614 << 8) | (type & 255);
#line 177
    info.dqi_flags = (u_int32_t )1;
#line 178
    info.dqi_valid = (u_int32_t )4;
#line 179
    tmp = quotactl(qcmd, quotadev, (qid_t )0, (caddr_t )((void *)(& info)));
#line 179
    ret = (int )tmp;
    }
  } else {
#line 182
    if (flags___7 & 2) {
#line 182
      tmp___0 = 0;
    } else {
#line 182
      tmp___0 = 1;
    }
    {
#line 182
    mode = tmp___0;
#line 183
    qcmd___0 = (4096 << 8) | (type & 255);
#line 185
    tmp___1 = quotactl(qcmd___0, quotadev, (qid_t )0, (caddr_t )((void *)(& mode)));
#line 185
    ret = (int )tmp___1;
    }
  }
#line 187
  if (ret < 0) {
    {
#line 188
    tmp___2 = __errno_location();
#line 188
    tmp___3 = strerror(*tmp___2);
#line 188
    tmp___4 = gettext("set root_squash on %s: %s\n");
#line 188
    errstr(tmp___4, quotadev, tmp___3);
    }
#line 189
    return (1);
  }
#line 191
  if (flags___7 & 2) {
    {
#line 192
    tmp___5 = type2name(type);
#line 192
    tmp___6 = gettext("%s: %s root_squash turned off\n");
#line 192
    pinfo(tmp___6, quotadev, tmp___5);
    }
  } else
#line 193
  if (flags___7 & 1) {
    {
#line 194
    tmp___7 = type2name(type);
#line 194
    tmp___8 = gettext("%s: %s root_squash turned on\n");
#line 194
    pinfo(tmp___8, quotadev, tmp___7);
    }
  }
#line 196
  return (0);
}
}
#line 202 "/home/wheatley/newnew/temp/quota-4.01/quotaon.c"
static int quotaonoff(char const   *quotadev , char const   *quotadir , char *quotafile ,
                      int type , int fmt___7 , int flags___7 ) 
{ 
  int qcmd ;
  int kqf ;
  int *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  long tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  int *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  int *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  int *tmp___13 ;
  int *tmp___14 ;
  long tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;
  char *tmp___18 ;

  {
#line 206
  if (flags___7 & 2) {
#line 207
    if (kernel_iface == 3) {
#line 208
      qcmd = (8388611 << 8) | (type & 255);
    } else {
#line 210
      qcmd = (512 << 8) | (type & 255);
    }
    {
#line 211
    tmp___2 = quotactl(qcmd, quotadev, (qid_t )0, (caddr_t )((void *)0));
    }
#line 211
    if (tmp___2 < 0L) {
      {
#line 212
      tmp = __errno_location();
#line 212
      tmp___0 = strerror(*tmp);
#line 212
      tmp___1 = gettext("quotactl on %s [%s]: %s\n");
#line 212
      errstr(tmp___1, quotadev, quotadir, tmp___0);
      }
#line 213
      return (1);
    }
    {
#line 215
    tmp___3 = type2name(type);
#line 215
    tmp___4 = gettext((char const   *)tmp___3);
#line 215
    tmp___5 = gettext("%s [%s]: %s quotas turned off\n");
#line 215
    pinfo(tmp___5, quotadev, quotadir, tmp___4);
    }
#line 216
    return (0);
  }
#line 218
  if (kernel_iface == 3) {
    {
#line 219
    qcmd = (8388610 << 8) | (type & 255);
#line 220
    kqf = util2kernfmt(fmt___7);
    }
  } else {
#line 223
    qcmd = (256 << 8) | (type & 255);
#line 224
    kqf = 0;
  }
  {
#line 226
  tmp___15 = quotactl(qcmd, quotadev, (qid_t )kqf, (caddr_t )((void *)quotafile));
  }
#line 226
  if (tmp___15 < 0L) {
    {
#line 227
    tmp___10 = __errno_location();
    }
#line 227
    if (*tmp___10 == 2) {
      {
#line 228
      tmp___6 = gettext("cannot find %s on %s [%s]\n");
#line 228
      errstr(tmp___6, quotafile, quotadev, quotadir);
      }
    } else {
      {
#line 230
      tmp___7 = __errno_location();
#line 230
      tmp___8 = strerror(*tmp___7);
#line 230
      tmp___9 = gettext("using %s on %s [%s]: %s\n");
#line 230
      errstr(tmp___9, quotafile, quotadev, quotadir, tmp___8);
      }
    }
    {
#line 231
    tmp___14 = __errno_location();
    }
#line 231
    if (*tmp___14 == 22) {
      {
#line 232
      tmp___11 = gettext("Maybe create new quota files with quotacheck(8)?\n");
#line 232
      errstr(tmp___11);
      }
    } else {
      {
#line 233
      tmp___13 = __errno_location();
      }
#line 233
      if (*tmp___13 == 3) {
        {
#line 234
        tmp___12 = gettext("Quota format not supported in kernel.\n");
#line 234
        errstr(tmp___12);
        }
      }
    }
#line 235
    return (1);
  }
  {
#line 237
  tmp___16 = type2name(type);
#line 237
  tmp___17 = gettext((char const   *)tmp___16);
#line 237
  tmp___18 = gettext("%s [%s]: %s quotas turned on\n");
#line 237
  pinfo(tmp___18, quotadev, quotadir, tmp___17);
  }
#line 238
  return (0);
}
}
#line 244 "/home/wheatley/newnew/temp/quota-4.01/quotaon.c"
static int v1_newstate(struct mount_entry *mnt___2 , int type , char *file , int flags___7 ,
                       int fmt___7 ) 
{ 
  int errs ;
  int tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;

  {
#line 246
  errs = 0;
#line 248
  if (flags___7 & 2) {
    {
#line 248
    tmp___0 = str_hasmntopt((char const   *)mnt___2->me_opts, "rsquash");
    }
#line 248
    if (tmp___0) {
      {
#line 249
      tmp = quotarsquashonoff(mnt___2->me_devname, type, flags___7);
#line 249
      errs += tmp;
      }
    }
  }
  {
#line 250
  tmp___1 = quotaonoff(mnt___2->me_devname, mnt___2->me_dir, file, type, 0, flags___7);
#line 250
  errs += tmp___1;
  }
#line 251
  if (flags___7 & 1) {
    {
#line 251
    tmp___3 = str_hasmntopt((char const   *)mnt___2->me_opts, "rsquash");
    }
#line 251
    if (tmp___3) {
      {
#line 252
      tmp___2 = quotarsquashonoff(mnt___2->me_devname, type, flags___7);
#line 252
      errs += tmp___2;
      }
    }
  }
#line 253
  return (errs);
}
}
#line 259 "/home/wheatley/newnew/temp/quota-4.01/quotaon.c"
static int v2_newstate(struct mount_entry *mnt___2 , int type , char *file , int flags___7 ,
                       int fmt___7 ) 
{ 
  int tmp ;

  {
  {
#line 261
  tmp = quotaonoff(mnt___2->me_devname, mnt___2->me_dir, file, type, fmt___7, flags___7);
  }
#line 261
  return (tmp);
}
}
#line 268 "/home/wheatley/newnew/temp/quota-4.01/quotaon.c"
static int newstate(struct mount_entry *mnt___2 , int type , char *extra ) 
{ 
  int sflags ;
  int ret ;
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int usefmt ;
  int tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;

  {
#line 270
  ret = 0;
#line 272
  if (flags___1 & 32) {
#line 272
    sflags = 2;
  } else {
#line 272
    sflags = 1;
  }
#line 273
  if (flags___1 & 8) {
#line 274
    sflags |= 4;
  }
  {
#line 276
  tmp___11 = strcmp((char const   *)mnt___2->me_type, "gfs2");
  }
#line 276
  if (tmp___11) {
    {
#line 279
    tmp___10 = strcmp((char const   *)mnt___2->me_type, "xfs");
    }
#line 279
    if (tmp___10) {
#line 286
      if (mnt___2->me_qfmt[type] == 5) {
        {
#line 288
        ret = v2_newstate(mnt___2, type, (char *)".", sflags, 1);
        }
      } else {
        {
#line 293
        tmp___2 = me_hasquota(mnt___2, type);
        }
#line 293
        if (! tmp___2) {
#line 294
          return (0);
        }
#line 295
        if (fmt___1 == -1) {
          {
#line 296
          tmp___6 = get_qf_name(mnt___2, type, 1, 2, & extra);
          }
#line 296
          if (tmp___6 >= 0) {
#line 298
            usefmt = 1;
          } else {
            {
#line 299
            tmp___5 = get_qf_name(mnt___2, type, 2, 2, & extra);
            }
#line 299
            if (tmp___5 >= 0) {
#line 301
              usefmt = 2;
            } else {
              {
#line 302
              tmp___4 = get_qf_name(mnt___2, type, 0, 2, & extra);
              }
#line 302
              if (tmp___4 >= 0) {
#line 304
                usefmt = 0;
              } else {
                {
#line 306
                tmp___3 = gettext("Cannot find quota file on %s [%s] to turn quotas on/off.\n");
#line 306
                errstr(tmp___3, mnt___2->me_dir, mnt___2->me_devname);
                }
#line 307
                return (1);
              }
            }
          }
        } else {
          {
#line 310
          tmp___8 = get_qf_name(mnt___2, type, fmt___1, 2, & extra);
          }
#line 310
          if (tmp___8 < 0) {
            {
#line 311
            tmp___7 = gettext("Quota file on %s [%s] does not exist or has wrong format.\n");
#line 311
            errstr(tmp___7, mnt___2->me_dir, mnt___2->me_devname);
            }
#line 312
            return (1);
          }
#line 314
          usefmt = fmt___1;
        }
        {
#line 316
        tmp___9 = is_tree_qfmt(usefmt);
        }
#line 316
        if (tmp___9) {
          {
#line 317
          ret = v2_newstate(mnt___2, type, extra, sflags, usefmt);
          }
        } else {
          {
#line 319
          ret = v1_newstate(mnt___2, type, extra, sflags, 0);
          }
        }
        {
#line 320
        free((void *)extra);
        }
      }
    } else {
      {
#line 280
      tmp___1 = kern_qfmt_supp(4);
      }
#line 280
      if (! tmp___1) {
        {
#line 281
        tmp___0 = gettext("Cannot change state of XFS quota. It\'s not compiled in kernel.\n");
#line 281
        errstr(tmp___0);
        }
#line 282
        return (1);
      }
      {
#line 284
      ret = xfs_newstate(mnt___2, type, extra, sflags);
      }
    }
  } else {
    {
#line 277
    tmp = gettext("Cannot change state of GFS2 quota.\n");
#line 277
    errstr(tmp);
    }
#line 278
    return (1);
  }
#line 322
  return (ret);
}
}
#line 326 "/home/wheatley/newnew/temp/quota-4.01/quotaon.c"
static int print_state(struct mount_entry *mnt___2 , int type ) 
{ 
  int on ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;

  {
  {
#line 328
  on = 0;
#line 330
  tmp___6 = strcmp((char const   *)mnt___2->me_type, "xfs");
  }
#line 330
  if (tmp___6) {
    {
#line 330
    tmp___7 = strcmp((char const   *)mnt___2->me_type, "gfs2");
    }
#line 330
    if (tmp___7) {
#line 335
      if (kernel_iface == 3) {
        {
#line 336
        tmp___1 = kern_quota_on(mnt___2, type, -1);
#line 336
        on = tmp___1 != -1;
        }
      } else {
        {
#line 337
        tmp___5 = kern_qfmt_supp(1);
        }
#line 337
        if (tmp___5) {
          {
#line 338
          tmp___2 = kern_quota_on(mnt___2, type, 1);
#line 338
          on = tmp___2 != -1;
          }
        } else {
          {
#line 339
          tmp___4 = kern_qfmt_supp(0);
          }
#line 339
          if (tmp___4) {
            {
#line 340
            tmp___3 = kern_quota_on(mnt___2, type, 0);
#line 340
            on = tmp___3 != -1;
            }
          }
        }
      }
    } else {
      _L: /* CIL Label */ 
      {
#line 332
      tmp___0 = kern_qfmt_supp(4);
      }
#line 332
      if (tmp___0) {
        {
#line 333
        tmp = kern_quota_on(mnt___2, type, 4);
#line 333
        on = tmp != -1;
        }
      }
    }
  } else {
#line 330
    goto _L;
  }
#line 342
  if (on) {
    {
#line 342
    tmp___8 = gettext("on");
#line 342
    tmp___10 = tmp___8;
    }
  } else {
    {
#line 342
    tmp___9 = gettext("off");
#line 342
    tmp___10 = tmp___9;
    }
  }
  {
#line 342
  tmp___11 = type2name(type);
#line 342
  tmp___12 = gettext((char const   *)tmp___11);
#line 342
  tmp___13 = gettext("%s quota on %s (%s) is %s\n");
#line 342
  printf((char const   */* __restrict  */)tmp___13, tmp___12, mnt___2->me_dir, mnt___2->me_devname,
         tmp___10);
  }
#line 345
  return (on);
}
}
#line 19 "/home/wheatley/newnew/temp/quota-4.01/quotaio_meta.c"
static int meta_init_io___1(struct quota_handle *h ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
#line 21
  if (! (h->qh_io_flags & 1)) {
    {
#line 22
    tmp = gettext("Metadata init_io called when kernel support is not enabled.\n");
#line 22
    errstr(tmp);
    }
#line 23
    return (-1);
  }
#line 25
  if (kernel_iface != 3) {
    {
#line 26
    tmp___0 = gettext("Metadata init_io called when kernel does not support generic quota interface!\n");
#line 26
    errstr(tmp___0);
    }
#line 27
    return (-1);
  }
  {
#line 29
  tmp___1 = vfs_get_info(h);
  }
#line 29
  return (tmp___1);
}
}
#line 32 "/home/wheatley/newnew/temp/quota-4.01/quotaio_meta.c"
static int meta_write_info___1(struct quota_handle *h ) 
{ 
  int tmp ;

  {
  {
#line 34
  tmp = vfs_set_info(h, 3);
  }
#line 34
  return (tmp);
}
}
#line 37 "/home/wheatley/newnew/temp/quota-4.01/quotaio_meta.c"
static struct dquot *meta_read_dquot___1(struct quota_handle *h , qid_t id___0 ) 
{ 
  struct dquot *dquot ;
  struct dquot *tmp ;
  int tmp___0 ;

  {
  {
#line 39
  tmp = get_empty_dquot();
#line 39
  dquot = tmp;
#line 41
  dquot->dq_id = id___0;
#line 42
  dquot->dq_h = h;
#line 43
  memset((void *)(& dquot->dq_dqb), 0, sizeof(struct util_dqblk ));
#line 44
  tmp___0 = vfs_get_dquot(dquot);
  }
#line 44
  if (tmp___0 < 0) {
    {
#line 45
    free((void *)dquot);
    }
#line 46
    return ((struct dquot *)((void *)0));
  }
#line 48
  return (dquot);
}
}
#line 51 "/home/wheatley/newnew/temp/quota-4.01/quotaio_meta.c"
static int meta_commit_dquot___1(struct dquot *dquot , int flags___7 ) 
{ 
  int tmp ;

  {
  {
#line 53
  tmp = vfs_set_dquot(dquot, flags___7);
  }
#line 53
  return (tmp);
}
}
#line 56 "/home/wheatley/newnew/temp/quota-4.01/quotaio_meta.c"
static int meta_scan_dquots___1(struct quota_handle *h , int (*process_dquot)(struct dquot *dquot ,
                                                                              char *dqname ) ) 
{ 
  int tmp ;

  {
  {
#line 58
  tmp = generic_scan_dquots(h, process_dquot, & vfs_get_dquot);
  }
#line 58
  return (tmp);
}
}
#line 41 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static char extensions___1[4][20]  = { {        (char )'u',        (char )'s',        (char )'e',        (char )'r', 
            (char )'\000'}, 
   {        (char )'g',        (char )'r',        (char )'o',        (char )'u', 
            (char )'p',        (char )'\000'}, 
   {        (char )'u',        (char )'n',        (char )'d',        (char )'e', 
            (char )'f',        (char )'i',        (char )'n',        (char )'e', 
            (char )'d',        (char )'\000'}};
#line 42 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static char *basenames___1[6]  = {      (char *)"quota",      (char *)"aquota",      (char *)"aquota",      (char *)"", 
        (char *)"",      (char *)""};
#line 43 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static char *fmtnames___1[5]  = {      (char *)"vfsold",      (char *)"vfsv0",      (char *)"vfsv1",      (char *)"rpc", 
        (char *)"xfs"};
#line 245 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static int kern2utilfmt___1(int kernfmt ) 
{ 


  {
  {
#line 248
  if (kernfmt == 1) {
#line 248
    goto case_1;
  }
#line 250
  if (kernfmt == 2) {
#line 250
    goto case_2;
  }
#line 252
  if (kernfmt == 4) {
#line 252
    goto case_4;
  }
#line 254
  if (kernfmt == 3) {
#line 254
    goto case_3;
  }
#line 247
  goto switch_break;
  case_1: /* CIL Label */ 
#line 249
  return (0);
  case_2: /* CIL Label */ 
#line 251
  return (1);
  case_4: /* CIL Label */ 
#line 253
  return (2);
  case_3: /* CIL Label */ 
#line 255
  return (5);
  switch_break: /* CIL Label */ ;
  }
#line 257
  return (-1);
}
}
#line 394 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static int hasxfsquota___1(char const   *dev , struct mntent *mnt___2 , int type ,
                           int flags___7 ) 
{ 
  u_int16_t sbflags ;
  struct fs_quota_stat info ;
  long tmp ;

  {
#line 399
  if (flags___7 & 16) {
#line 400
    return (4);
  }
  {
#line 402
  memset((void *)(& info), 0, sizeof(struct fs_quota_stat ));
#line 403
  tmp = quotactl((((88 << 8) + 5) << 8) | (type & 255), dev, (qid_t )0, (caddr_t )((void *)(& info)));
  }
#line 403
  if (! tmp) {
#line 404
    sbflags = (u_int16_t )(((int )info.qs_flags & 65280) >> 8);
#line 405
    if (type == 0) {
#line 405
      if ((int )info.qs_flags & 1) {
#line 406
        return (4);
      } else {
#line 405
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 407
    if (type == 1) {
#line 407
      if ((int )info.qs_flags & (1 << 2)) {
#line 408
        return (4);
      }
    }
  }
#line 424
  return (-1);
}
}
#line 427 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static int hasvfsmetaquota___1(char const   *dev , struct mntent *mnt___2 , int type ,
                               int flags___7 ) 
{ 
  uint32_t fmt___7 ;
  long tmp ;

  {
  {
#line 431
  tmp = quotactl((8388612 << 8) | (type & 255), dev, (qid_t )0, (caddr_t )((void *)(& fmt___7)));
  }
#line 431
  if (! tmp) {
#line 432
    return (5);
  }
#line 433
  return (-1);
}
}
#line 465 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static char *hasmntoptarg___1(char const   *optstring , char const   *opt ) 
{ 
  char *p ;
  char *tmp ;
  size_t tmp___0 ;

  {
  {
#line 467
  tmp = str_hasmntopt(optstring, opt);
#line 467
  p = tmp;
  }
#line 469
  if (! p) {
#line 470
    return ((char *)((void *)0));
  }
  {
#line 471
  tmp___0 = strlen(opt);
#line 471
  p += tmp___0;
  }
#line 472
  if ((int )*p == 61) {
#line 472
    if ((int )*(p + 1) != 44) {
#line 473
      return (p + 1);
    }
  }
#line 474
  return ((char *)((void *)0));
}
}
#line 478 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static void copy_mntoptarg___1(char *buf , char const   *optarg___0 , int buflen ) 
{ 
  char *sep ;
  char *tmp ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  long tmp___4 ;

  {
  {
#line 480
  tmp = strchr(optarg___0, ',');
#line 480
  sep = tmp;
  }
#line 482
  if (! sep) {
    {
#line 483
    tmp___3 = strlen(optarg___0);
    }
#line 483
    if ((size_t )buflen < tmp___3 + 1UL) {
#line 483
      tmp___2 = (size_t )buflen;
    } else {
      {
#line 483
      tmp___1 = strlen(optarg___0);
#line 483
      tmp___2 = tmp___1 + 1UL;
      }
    }
    {
#line 483
    sstrncpy(buf, optarg___0, tmp___2);
    }
  } else {
#line 485
    if ((long )buflen < (sep - (char *)optarg___0) + 1L) {
#line 485
      tmp___4 = (long )buflen;
    } else {
#line 485
      tmp___4 = (sep - (char *)optarg___0) + 1L;
    }
    {
#line 485
    sstrncpy(buf, optarg___0, (size_t )tmp___4);
    }
  }
#line 486
  return;
}
}
#line 491 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static int hasquota___1(char const   *dev , struct mntent *mnt___2 , int type , int flags___7 ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  struct if_dqinfo kinfo ;
  long tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;

  {
  {
#line 493
  tmp___0 = strcmp((char const   *)mnt___2->mnt_type, "gfs2");
  }
#line 493
  if (tmp___0) {
    {
#line 493
    tmp___1 = strcmp((char const   *)mnt___2->mnt_type, "xfs");
    }
#line 493
    if (! tmp___1) {
      {
#line 495
      tmp = hasxfsquota___1(dev, mnt___2, type, flags___7);
      }
#line 495
      return (tmp);
    }
  } else {
    {
#line 495
    tmp = hasxfsquota___1(dev, mnt___2, type, flags___7);
    }
#line 495
    return (tmp);
  }
  {
#line 496
  tmp___3 = strcmp((char const   *)mnt___2->mnt_type, "ocfs2");
  }
#line 496
  if (! tmp___3) {
    {
#line 497
    tmp___2 = hasvfsmetaquota___1(dev, mnt___2, type, flags___7);
    }
#line 497
    return (tmp___2);
  }
  {
#line 504
  tmp___5 = strcmp((char const   *)mnt___2->mnt_type, "ext4");
  }
#line 504
  if (! tmp___5) {
    {
#line 507
    tmp___4 = quotactl((8388613 << 8) | (type & 255), dev, (qid_t )0, (caddr_t )((void *)(& kinfo)));
    }
#line 507
    if (tmp___4 == 0L) {
#line 508
      if (kinfo.dqi_flags & 65536U) {
#line 509
        return (5);
      }
    }
  }
  {
#line 513
  tmp___6 = nfs_fstype(mnt___2->mnt_type);
  }
#line 513
  if (tmp___6) {
#line 514
    return (3);
  }
#line 516
  if (type == 0) {
    {
#line 516
    tmp___7 = hasmntopt((struct mntent  const  *)mnt___2, "usrquota");
    }
#line 516
    if (tmp___7) {
#line 517
      return (6);
    } else {
      {
#line 516
      tmp___8 = hasmntoptarg___1((char const   *)mnt___2->mnt_opts, "usrjquota");
      }
#line 516
      if (tmp___8) {
#line 517
        return (6);
      }
    }
  }
#line 518
  if (type == 1) {
    {
#line 518
    tmp___9 = hasmntopt((struct mntent  const  *)mnt___2, "grpquota");
    }
#line 518
    if (tmp___9) {
#line 519
      return (6);
    } else {
      {
#line 518
      tmp___10 = hasmntoptarg___1((char const   *)mnt___2->mnt_opts, "grpjquota");
      }
#line 518
      if (tmp___10) {
#line 519
        return (6);
      }
    }
  }
#line 520
  if (type == 0) {
    {
#line 520
    tmp___11 = hasmntopt((struct mntent  const  *)mnt___2, "quota");
    }
#line 520
    if (tmp___11) {
#line 521
      return (6);
    }
  }
#line 522
  return (-1);
}
}
#line 526 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static int check_fmtfile_ok___1(char *name , int type , int fmt___7 , int flags___7 ) 
{ 
  struct stat st ;
  int *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;
  int fd ;
  int ret ;
  int tmp___4 ;
  int *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  int *tmp___8 ;
  int *tmp___9 ;

  {
#line 528
  if (! flags___7) {
#line 529
    return (1);
  }
#line 530
  if (flags___7 & 1) {
    {
#line 533
    tmp___3 = stat((char const   */* __restrict  */)name, (struct stat */* __restrict  */)(& st));
    }
#line 533
    if (tmp___3 < 0) {
      {
#line 534
      tmp___2 = __errno_location();
      }
#line 534
      if (*tmp___2 != 2) {
        {
#line 535
        tmp = __errno_location();
#line 535
        tmp___0 = strerror(*tmp);
#line 535
        tmp___1 = gettext("Cannot stat quota file %s: %s\n");
#line 535
        errstr(tmp___1, name, tmp___0);
        }
      }
#line 536
      return (0);
    }
  }
#line 539
  if (flags___7 & 2) {
    {
#line 540
    ret = 0;
#line 542
    fd = open((char const   *)name, 0);
    }
#line 542
    if (fd >= 0) {
      {
#line 543
      tmp___4 = is_tree_qfmt(fmt___7);
      }
#line 543
      if (tmp___4) {
        {
#line 544
        ret = (*(quotafile_ops_2.check_file))(fd, type, fmt___7);
        }
      } else {
        {
#line 546
        ret = (*(quotafile_ops_1.check_file))(fd, type, fmt___7);
        }
      }
      {
#line 547
      close(fd);
      }
#line 548
      if (ret <= 0) {
#line 549
        return (0);
      }
    } else {
      {
#line 551
      tmp___8 = __errno_location();
      }
#line 551
      if (*tmp___8 != 2) {
        {
#line 551
        tmp___9 = __errno_location();
        }
#line 551
        if (*tmp___9 != 1) {
          {
#line 552
          tmp___5 = __errno_location();
#line 552
          tmp___6 = strerror(*tmp___5);
#line 552
          tmp___7 = gettext("Cannot open quotafile %s: %s\n");
#line 552
          errstr(tmp___7, name, tmp___6);
          }
#line 553
          return (0);
        }
      }
    }
  }
#line 556
  return (1);
}
}
#line 629 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static int hlist_allocated___1  =    0;
#line 630 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static struct quota_handle **hlist___1  =    (struct quota_handle **)((void *)0);
#line 735 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static int kernel_qfmt_num___1  ;
#line 736 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static int kernel_qfmt___1[6]  ;
#line 828 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static int v1_kern_quota_on___1(char const   *dev , int type ) 
{ 
  char tmp[1024] ;
  qid_t id___0 ;
  __uid_t tmp___0 ;
  __gid_t tmp___1 ;
  __uid_t tmp___2 ;
  long tmp___3 ;

  {
#line 831
  if (type == 0) {
    {
#line 831
    tmp___0 = getuid();
#line 831
    tmp___2 = tmp___0;
    }
  } else {
    {
#line 831
    tmp___1 = getgid();
#line 831
    tmp___2 = tmp___1;
    }
  }
  {
#line 831
  id___0 = tmp___2;
#line 833
  tmp___3 = quotactl((768 << 8) | (type & 255), dev, id___0, tmp);
  }
#line 833
  if (! tmp___3) {
#line 834
    return (1);
  }
#line 835
  return (0);
}
}
#line 839 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static int v2_kern_quota_on___1(char const   *dev , int type ) 
{ 
  char tmp[1024] ;
  qid_t id___0 ;
  __uid_t tmp___0 ;
  __gid_t tmp___1 ;
  __uid_t tmp___2 ;
  long tmp___3 ;

  {
#line 842
  if (type == 0) {
    {
#line 842
    tmp___0 = getuid();
#line 842
    tmp___2 = tmp___0;
    }
  } else {
    {
#line 842
    tmp___1 = getgid();
#line 842
    tmp___2 = tmp___1;
    }
  }
  {
#line 842
  id___0 = tmp___2;
#line 844
  tmp___3 = quotactl((3328 << 8) | (type & 255), dev, id___0, tmp);
  }
#line 844
  if (! tmp___3) {
#line 845
    return (1);
  }
#line 846
  return (0);
}
}
#line 850 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static int xfs_kern_quota_on___1(char const   *dev , int type ) 
{ 
  struct fs_quota_stat info ;
  long tmp ;

  {
  {
#line 854
  tmp = quotactl((((88 << 8) + 5) << 8) | (type & 255), dev, (qid_t )0, (caddr_t )((void *)(& info)));
  }
#line 854
  if (! tmp) {
#line 855
    if (type == 0) {
#line 855
      if ((int )info.qs_flags & 1) {
#line 856
        return (1);
      }
    }
#line 857
    if (type == 1) {
#line 857
      if ((int )info.qs_flags & (1 << 2)) {
#line 858
        return (1);
      }
    }
  }
#line 860
  return (0);
}
}
#line 921 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static int mnt_entries_cnt___1  ;
#line 922 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static struct mount_entry *mnt_entries___1  ;
#line 923 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static int check_dirs_cnt___1  ;
#line 923 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static int act_checked___1  ;
#line 924 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static struct searched_dir *check_dirs___1  ;
#line 927 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static int cache_mnt_table___1(int flags___7 ) 
{ 
  FILE *mntf ;
  struct mntent *mnt___2 ;
  struct stat st ;
  struct statfs fsstat ;
  int allocated ;
  int i ;
  dev_t dev ;
  char mntpointbuf[4096] ;
  int autofsdircnt ;
  int autofsdir_allocated ;
  char **autofsdir ;
  char *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  char const   *devname ;
  char *opt ;
  int qfmt[2] ;
  char *tmp___2 ;
  int slen ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  void *tmp___6 ;
  size_t tmp___7 ;
  void *tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char loopdev[4096] ;
  char *tmp___13 ;
  int *tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;
  int *tmp___18 ;
  char *tmp___19 ;
  char *tmp___20 ;
  int tmp___21 ;
  int *tmp___22 ;
  char *tmp___23 ;
  char *tmp___24 ;
  int tmp___25 ;
  char *tmp___26 ;
  int tmp___27 ;
  int *tmp___28 ;
  char *tmp___29 ;
  char *tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;
  void *tmp___34 ;
  char *tmp___35 ;

  {
  {
#line 933
  allocated = 0;
#line 933
  i = 0;
#line 934
  dev = (dev_t )0;
#line 940
  mntf = setmntent("/proc/mounts", "r");
  }
#line 941
  if (mntf) {
#line 942
    goto alloc;
  }
  {
#line 944
  mntf = setmntent("/etc/mtab", "r");
  }
#line 945
  if (mntf) {
#line 946
    goto alloc;
  }
  {
#line 948
  mntf = setmntent("/etc/fstab", "r");
  }
#line 948
  if (! mntf) {
    {
#line 949
    tmp = gettext("Cannot open any file with mount points.\n");
#line 949
    errstr(tmp);
    }
#line 950
    return (-1);
  }
  alloc: 
  {
#line 954
  tmp___0 = smalloc(sizeof(struct mount_entry ) * 16UL);
#line 954
  mnt_entries___1 = (struct mount_entry *)tmp___0;
#line 955
  mnt_entries_cnt___1 = 0;
#line 956
  allocated += 16;
#line 958
  tmp___1 = smalloc(sizeof(char *) * 16UL);
#line 958
  autofsdir = (char **)tmp___1;
#line 959
  autofsdircnt = 0;
#line 960
  autofsdir_allocated = 16;
  }
  {
#line 961
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 961
    mnt___2 = getmntent(mntf);
    }
#line 961
    if (! mnt___2) {
#line 961
      goto while_break;
    }
    {
#line 966
    devname = get_device_name((char const   *)mnt___2->mnt_fsname);
    }
#line 966
    if (! devname) {
      {
#line 967
      tmp___2 = gettext("Cannot get device name for %s\n");
#line 967
      errstr(tmp___2, mnt___2->mnt_fsname);
      }
#line 968
      goto while_continue;
    }
#line 972
    i = 0;
    {
#line 972
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 972
      if (! (i < autofsdircnt)) {
#line 972
        goto while_break___0;
      }
      {
#line 973
      tmp___3 = strlen((char const   *)*(autofsdir + i));
#line 973
      slen = (int )tmp___3;
#line 975
      tmp___4 = strlen((char const   *)mnt___2->mnt_dir);
      }
#line 975
      if ((size_t )slen <= tmp___4) {
        {
#line 975
        tmp___5 = strncmp((char const   *)*(autofsdir + i), (char const   *)mnt___2->mnt_dir,
                          (size_t )slen);
        }
#line 975
        if (! tmp___5) {
#line 976
          goto while_break___0;
        }
      }
#line 972
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 978
    if (i < autofsdircnt) {
      {
#line 979
      free((void *)((char *)devname));
      }
#line 980
      goto while_continue;
    }
#line 983
    if (flags___7 & 2) {
      {
#line 983
      tmp___9 = strcmp((char const   *)mnt___2->mnt_type, "autofs");
      }
#line 983
      if (! tmp___9) {
#line 984
        if (autofsdircnt == autofsdir_allocated) {
          {
#line 985
          autofsdir_allocated += 16;
#line 986
          tmp___6 = srealloc((void *)autofsdir, (unsigned long )autofsdir_allocated * sizeof(char *));
#line 986
          autofsdir = (char **)tmp___6;
          }
        }
        {
#line 988
        tmp___7 = strlen((char const   *)mnt___2->mnt_dir);
#line 988
        tmp___8 = smalloc(tmp___7 + 2UL);
#line 988
        *(autofsdir + autofsdircnt) = (char *)tmp___8;
#line 989
        strcpy((char */* __restrict  */)*(autofsdir + autofsdircnt), (char const   */* __restrict  */)mnt___2->mnt_dir);
#line 990
        strcat((char */* __restrict  */)*(autofsdir + autofsdircnt), (char const   */* __restrict  */)"/");
#line 991
        autofsdircnt ++;
#line 992
        free((void *)((char *)devname));
        }
#line 993
        goto while_continue;
      }
    }
#line 996
    if (flags___7 & 8) {
      {
#line 996
      tmp___10 = nfs_fstype(mnt___2->mnt_type);
      }
#line 996
      if (tmp___10) {
        {
#line 997
        free((void *)((char *)devname));
        }
#line 998
        goto while_continue;
      }
    }
    {
#line 1000
    tmp___11 = hasmntopt((struct mntent  const  *)mnt___2, "noquota");
    }
#line 1000
    if (tmp___11) {
      {
#line 1001
      free((void *)((char *)devname));
      }
#line 1002
      goto while_continue;
    }
    {
#line 1004
    tmp___12 = hasmntopt((struct mntent  const  *)mnt___2, "bind");
    }
#line 1004
    if (tmp___12) {
      {
#line 1005
      free((void *)((char *)devname));
      }
#line 1006
      goto while_continue;
    }
    {
#line 1008
    opt = hasmntoptarg___1((char const   *)mnt___2->mnt_opts, "loop");
    }
#line 1008
    if (opt) {
      {
#line 1011
      copy_mntoptarg___1(opt, (char const   *)(loopdev), 4096);
#line 1012
      free((void *)((char *)devname));
#line 1013
      tmp___13 = sstrdup((char const   *)(loopdev));
#line 1013
      devname = (char const   *)tmp___13;
      }
    }
    {
#line 1018
    qfmt[0] = hasquota___1(devname, mnt___2, 0, flags___7);
#line 1019
    qfmt[1] = hasquota___1(devname, mnt___2, 1, flags___7);
    }
#line 1020
    if (qfmt[0] < 0) {
#line 1020
      if (qfmt[1] < 0) {
        {
#line 1021
        free((void *)((char *)devname));
        }
#line 1022
        goto while_continue;
      }
    }
    {
#line 1025
    tmp___17 = realpath((char const   */* __restrict  */)mnt___2->mnt_dir, (char */* __restrict  */)(mntpointbuf));
    }
#line 1025
    if (! tmp___17) {
      {
#line 1026
      tmp___14 = __errno_location();
#line 1026
      tmp___15 = strerror(*tmp___14);
#line 1026
      tmp___16 = gettext("Cannot resolve mountpoint path %s: %s\n");
#line 1026
      errstr(tmp___16, mnt___2->mnt_dir, tmp___15);
#line 1027
      free((void *)((char *)devname));
      }
#line 1028
      goto while_continue;
    }
    {
#line 1031
    tmp___21 = statfs((char const   *)(mntpointbuf), & fsstat);
    }
#line 1031
    if (tmp___21 != 0) {
      {
#line 1032
      tmp___18 = __errno_location();
#line 1032
      tmp___19 = strerror(*tmp___18);
#line 1032
      tmp___20 = gettext("Cannot statfs() %s: %s\n");
#line 1032
      errstr(tmp___20, mntpointbuf, tmp___19);
#line 1033
      free((void *)((char *)devname));
      }
#line 1034
      goto while_continue;
    }
#line 1037
    if (fsstat.f_blocks == 0UL) {
#line 1037
      if (fsstat.f_bfree == 0UL) {
#line 1037
        if (fsstat.f_bavail == 0UL) {
          {
#line 1038
          free((void *)((char *)devname));
          }
#line 1039
          goto while_continue;
        }
      }
    }
    {
#line 1042
    tmp___27 = nfs_fstype(mnt___2->mnt_type);
    }
#line 1042
    if (! tmp___27) {
      {
#line 1043
      tmp___25 = stat((char const   */* __restrict  */)devname, (struct stat */* __restrict  */)(& st));
      }
#line 1043
      if (tmp___25 < 0) {
        {
#line 1044
        tmp___22 = __errno_location();
#line 1044
        tmp___23 = strerror(*tmp___22);
#line 1044
        tmp___24 = gettext("Cannot stat() mounted device %s: %s\n");
#line 1044
        errstr(tmp___24, devname, tmp___23);
#line 1045
        free((void *)((char *)devname));
        }
#line 1046
        goto while_continue;
      }
#line 1048
      if (! ((st.st_mode & 61440U) == 24576U)) {
#line 1048
        if (! ((st.st_mode & 61440U) == 8192U)) {
          {
#line 1049
          tmp___26 = gettext("Device (%s) filesystem is mounted on unsupported device type. Skipping.\n");
#line 1049
          errstr(tmp___26, devname);
#line 1050
          free((void *)((char *)devname));
          }
#line 1051
          goto while_continue;
        }
      }
#line 1053
      dev = st.st_rdev;
#line 1054
      i = 0;
      {
#line 1054
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1054
        if (i < mnt_entries_cnt___1) {
#line 1054
          if (! ((mnt_entries___1 + i)->me_dev != dev)) {
#line 1054
            goto while_break___1;
          }
        } else {
#line 1054
          goto while_break___1;
        }
#line 1054
        i ++;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
    {
#line 1057
    tmp___33 = nfs_fstype(mnt___2->mnt_type);
    }
#line 1057
    if (tmp___33) {
#line 1057
      goto _L;
    } else
#line 1057
    if (i == mnt_entries_cnt___1) {
      _L: /* CIL Label */ 
      {
#line 1058
      tmp___31 = stat((char const   */* __restrict  */)mnt___2->mnt_dir, (struct stat */* __restrict  */)(& st));
      }
#line 1058
      if (tmp___31 < 0) {
        {
#line 1059
        tmp___28 = __errno_location();
#line 1059
        tmp___29 = strerror(*tmp___28);
#line 1059
        tmp___30 = gettext("Cannot stat() mountpoint %s: %s\n");
#line 1059
        errstr(tmp___30, mnt___2->mnt_dir, tmp___29);
#line 1060
        free((void *)((char *)devname));
        }
#line 1061
        goto while_continue;
      }
      {
#line 1063
      tmp___32 = nfs_fstype(mnt___2->mnt_type);
      }
#line 1063
      if (tmp___32) {
#line 1065
        dev = st.st_dev;
#line 1066
        if (! (flags___7 & 32)) {
#line 1067
          i = 0;
          {
#line 1067
          while (1) {
            while_continue___2: /* CIL Label */ ;
#line 1067
            if (i < mnt_entries_cnt___1) {
#line 1067
              if (! ((mnt_entries___1 + i)->me_dev != dev)) {
#line 1067
                goto while_break___2;
              }
            } else {
#line 1067
              goto while_break___2;
            }
#line 1067
            i ++;
          }
          while_break___2: /* CIL Label */ ;
          }
        } else {
#line 1070
          i = mnt_entries_cnt___1;
        }
      }
    }
#line 1073
    if (i == mnt_entries_cnt___1) {
#line 1074
      if (allocated == mnt_entries_cnt___1) {
        {
#line 1075
        allocated += 16;
#line 1076
        tmp___34 = srealloc((void *)mnt_entries___1, (unsigned long )allocated * sizeof(struct mount_entry ));
#line 1076
        mnt_entries___1 = (struct mount_entry *)tmp___34;
        }
      }
      {
#line 1078
      (mnt_entries___1 + i)->me_type = sstrdup((char const   *)mnt___2->mnt_type);
#line 1079
      (mnt_entries___1 + i)->me_opts = sstrdup((char const   *)mnt___2->mnt_opts);
#line 1080
      (mnt_entries___1 + i)->me_dev = dev;
#line 1081
      (mnt_entries___1 + i)->me_ino = st.st_ino;
#line 1082
      (mnt_entries___1 + i)->me_devname = devname;
#line 1083
      tmp___35 = sstrdup((char const   *)(mntpointbuf));
#line 1083
      (mnt_entries___1 + i)->me__dir = (char const   *)tmp___35;
#line 1084
      (mnt_entries___1 + i)->me_dir = (char const   *)((void *)0);
#line 1085
      memcpy((void */* __restrict  */)(& (mnt_entries___1 + i)->me_qfmt), (void const   */* __restrict  */)(qfmt),
             sizeof(qfmt));
#line 1086
      mnt_entries_cnt___1 ++;
      }
    } else {
      {
#line 1089
      free((void *)((char *)devname));
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1091
  endmntent(mntf);
#line 1093
  i = 0;
  }
  {
#line 1093
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 1093
    if (! (i < autofsdircnt)) {
#line 1093
      goto while_break___3;
    }
    {
#line 1094
    free((void *)*(autofsdir + i));
#line 1093
    i ++;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 1095
  free((void *)autofsdir);
  }
#line 1096
  return (0);
}
}
#line 1100 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static char const   *find_dir_mntpoint___1(struct stat *st ) 
{ 
  int i ;

  {
#line 1104
  i = 0;
  {
#line 1104
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1104
    if (! (i < mnt_entries_cnt___1)) {
#line 1104
      goto while_break;
    }
#line 1105
    if ((mnt_entries___1 + i)->me_dev == st->st_dev) {
#line 1106
      st->st_ino = (mnt_entries___1 + i)->me_ino;
#line 1107
      return ((mnt_entries___1 + i)->me__dir);
    }
#line 1104
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1109
  return ((char const   *)((void *)0));
}
}
#line 1113 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static int process_dirs___1(int dcnt , char **dirs , int flags___7 ) 
{ 
  struct stat st ;
  int i ;
  char mntpointbuf[4096] ;
  void *tmp ;
  char *devname ;
  char const   *tmp___0 ;
  char *tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  int *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  char const   *realmnt ;
  char *tmp___12 ;
  int *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  int mentry ;
  char *tmp___17 ;
  char *tmp___18 ;
  char *tmp___19 ;
  char *tmp___20 ;

  {
#line 1119
  check_dirs_cnt___1 = 0;
#line 1120
  act_checked___1 = -1;
#line 1121
  if (dcnt) {
    {
#line 1122
    tmp = smalloc(sizeof(struct searched_dir ) * (unsigned long )dcnt);
#line 1122
    check_dirs___1 = (struct searched_dir *)tmp;
#line 1123
    i = 0;
    }
    {
#line 1123
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1123
      if (! (i < dcnt)) {
#line 1123
        goto while_break;
      }
      {
#line 1124
      tmp___10 = strncmp((char const   *)*(dirs + i), "UUID=", (size_t )5);
      }
#line 1124
      if (tmp___10) {
        {
#line 1124
        tmp___11 = strncmp((char const   *)*(dirs + i), "LABEL=", (size_t )6);
        }
#line 1124
        if (tmp___11) {
          {
#line 1139
          tmp___9 = stat((char const   */* __restrict  */)*(dirs + i), (struct stat */* __restrict  */)(& st));
          }
#line 1139
          if (tmp___9 < 0) {
            {
#line 1140
            tmp___6 = __errno_location();
#line 1140
            tmp___7 = strerror(*tmp___6);
#line 1140
            tmp___8 = gettext("Cannot stat() given mountpoint %s: %s\nSkipping...\n");
#line 1140
            errstr(tmp___8, *(dirs + i), tmp___7);
            }
#line 1141
            goto __Cont;
          }
        } else {
          _L: /* CIL Label */ 
          {
#line 1125
          tmp___0 = get_device_name((char const   *)*(dirs + i));
#line 1125
          devname = (char *)tmp___0;
          }
#line 1127
          if (! devname) {
            {
#line 1128
            tmp___1 = gettext("Cannot find a device with %s.\nSkipping...\n");
#line 1128
            errstr(tmp___1, *(dirs + i));
            }
#line 1129
            goto __Cont;
          }
          {
#line 1131
          tmp___5 = stat((char const   */* __restrict  */)devname, (struct stat */* __restrict  */)(& st));
          }
#line 1131
          if (tmp___5 < 0) {
            {
#line 1132
            tmp___2 = __errno_location();
#line 1132
            tmp___3 = strerror(*tmp___2);
#line 1132
            tmp___4 = gettext("Cannot stat() a mountpoint with %s: %s\nSkipping...\n");
#line 1132
            errstr(tmp___4, *(dirs + i), tmp___3);
#line 1133
            free((void *)devname);
            }
#line 1134
            goto __Cont;
          }
          {
#line 1136
          free((void *)devname);
          }
        }
      } else {
#line 1124
        goto _L;
      }
#line 1143
      (check_dirs___1 + check_dirs_cnt___1)->sd_dir = (st.st_mode & 61440U) == 16384U;
#line 1144
      if ((st.st_mode & 61440U) == 16384U) {
#line 1145
        realmnt = (char const   *)*(dirs + i);
#line 1148
        if (flags___7 & 1) {
          {
#line 1148
          realmnt = find_dir_mntpoint___1(& st);
          }
#line 1148
          if (! realmnt) {
#line 1149
            if (! (flags___7 & 4)) {
              {
#line 1150
              tmp___12 = gettext("Cannot find a filesystem mountpoint for directory %s\n");
#line 1150
              errstr(tmp___12, *(dirs + i));
              }
            }
#line 1151
            goto __Cont;
          }
        }
        {
#line 1153
        (check_dirs___1 + check_dirs_cnt___1)->sd_dev = st.st_dev;
#line 1154
        (check_dirs___1 + check_dirs_cnt___1)->sd_ino = st.st_ino;
#line 1155
        tmp___16 = realpath((char const   */* __restrict  */)realmnt, (char */* __restrict  */)(mntpointbuf));
        }
#line 1155
        if (! tmp___16) {
          {
#line 1156
          tmp___13 = __errno_location();
#line 1156
          tmp___14 = strerror(*tmp___13);
#line 1156
          tmp___15 = gettext("Cannot resolve path %s: %s\n");
#line 1156
          errstr(tmp___15, realmnt, tmp___14);
          }
#line 1157
          goto __Cont;
        }
      } else
#line 1160
      if ((st.st_mode & 61440U) == 24576U) {
#line 1160
        goto _L___0;
      } else
#line 1160
      if ((st.st_mode & 61440U) == 8192U) {
        _L___0: /* CIL Label */ 
#line 1163
        (check_dirs___1 + check_dirs_cnt___1)->sd_dev = st.st_rdev;
#line 1164
        mentry = 0;
        {
#line 1164
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 1164
          if (mentry < mnt_entries_cnt___1) {
#line 1164
            if (! ((mnt_entries___1 + mentry)->me_dev != st.st_rdev)) {
#line 1164
              goto while_break___0;
            }
          } else {
#line 1164
            goto while_break___0;
          }
#line 1164
          mentry ++;
        }
        while_break___0: /* CIL Label */ ;
        }
#line 1165
        if (mentry == mnt_entries_cnt___1) {
#line 1166
          if (! (flags___7 & 4)) {
            {
#line 1167
            tmp___17 = gettext("Cannot find mountpoint for device %s\n");
#line 1167
            errstr(tmp___17, *(dirs + i));
            }
          }
#line 1168
          goto __Cont;
        }
        {
#line 1170
        sstrncpy(mntpointbuf, (mnt_entries___1 + mentry)->me__dir, (size_t )4095);
        }
      } else {
        {
#line 1173
        tmp___18 = gettext("Specified path %s is not directory nor device.\n");
#line 1173
        errstr(tmp___18, *(dirs + i));
        }
#line 1174
        goto __Cont;
      }
      {
#line 1176
      tmp___19 = sstrdup((char const   *)(mntpointbuf));
#line 1176
      (check_dirs___1 + check_dirs_cnt___1)->sd_name = (char const   *)tmp___19;
#line 1177
      check_dirs_cnt___1 ++;
      }
      __Cont: /* CIL Label */ 
#line 1123
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 1179
    if (! check_dirs_cnt___1) {
#line 1180
      if (! (flags___7 & 4)) {
        {
#line 1181
        tmp___20 = gettext("No correct mountpoint specified.\n");
#line 1181
        errstr(tmp___20);
        }
      }
      {
#line 1182
      free((void *)check_dirs___1);
      }
#line 1183
      return (-1);
    }
  }
#line 1186
  return (0);
}
}
#line 1204 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static int find_next_entry_all___1(int *pos ) 
{ 
  char *tmp ;

  {
  {
#line 1206
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1206
    act_checked___1 ++;
#line 1206
    if (! (act_checked___1 < mnt_entries_cnt___1)) {
#line 1206
      goto while_break;
    }
    {
#line 1207
    tmp = str_hasmntopt((char const   *)(mnt_entries___1 + act_checked___1)->me_opts,
                        "noauto");
    }
#line 1207
    if (! tmp) {
#line 1208
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1210
  if (act_checked___1 >= mnt_entries_cnt___1) {
#line 1211
    return (0);
  }
#line 1212
  *pos = act_checked___1;
#line 1213
  return (1);
}
}
#line 1217 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static int find_next_entry_sel___1(int *pos ) 
{ 
  int i ;
  struct searched_dir *sd ;
  char *tmp ;

  {
  restart: 
#line 1223
  act_checked___1 ++;
#line 1223
  if (act_checked___1 == check_dirs_cnt___1) {
#line 1224
    return (0);
  }
#line 1225
  sd = check_dirs___1 + act_checked___1;
#line 1226
  i = 0;
  {
#line 1226
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1226
    if (! (i < mnt_entries_cnt___1)) {
#line 1226
      goto while_break;
    }
#line 1227
    if (sd->sd_dir) {
#line 1228
      if (sd->sd_dev == (mnt_entries___1 + i)->me_dev) {
#line 1228
        if (sd->sd_ino == (mnt_entries___1 + i)->me_ino) {
#line 1229
          goto while_break;
        }
      }
    } else
#line 1232
    if (sd->sd_dev == (mnt_entries___1 + i)->me_dev) {
#line 1233
      goto while_break;
    }
#line 1226
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1235
  if (i == mnt_entries_cnt___1) {
    {
#line 1236
    tmp = gettext("Mountpoint (or device) %s not found or has no quota enabled.\n");
#line 1236
    errstr(tmp, sd->sd_name);
    }
#line 1237
    goto restart;
  }
#line 1239
  *pos = i;
#line 1240
  return (1);
}
}
#line 23 "/home/wheatley/newnew/temp/quota-4.01/common.c"
static int enable_syslog___2  =    0;
#line 31 "/home/wheatley/newnew/temp/quota-4.01/common.c"
static void do_syslog___2(int level , char const   *format , va_list args ) 
{ 
  char buf[1024] ;
  int i ;
  int j ;
  int tmp ;

  {
  {
#line 36
  vsnprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)format,
            args);
#line 39
  i = 0;
  }
  {
#line 39
  while (1) {
    while_continue: /* CIL Label */ ;
#line 39
    if (! buf[i]) {
#line 39
      goto while_break;
    }
#line 40
    j = i;
    {
#line 40
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 40
      if (buf[j]) {
#line 40
        if (! ((int )buf[j] != 10)) {
#line 40
          goto while_break___0;
        }
      } else {
#line 40
        goto while_break___0;
      }
#line 40
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 41
    if ((int )buf[j] == 10) {
#line 42
      tmp = j;
#line 42
      j ++;
#line 42
      buf[tmp] = (char )'\000';
    }
    {
#line 43
    syslog(level, "%s", buf + i);
#line 39
    i = j;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 45
  return;
}
}
#line 18 "/home/wheatley/newnew/temp/quota-4.01/quotaio_rpc.c"
static int rpc_init_io___1(struct quota_handle *h ) ;
#line 19
static struct dquot *rpc_read_dquot___1(struct quota_handle *h , qid_t id___0 ) ;
#line 20
static int rpc_commit_dquot___1(struct dquot *dquot , int flags___7 ) ;
#line 31 "/home/wheatley/newnew/temp/quota-4.01/quotaio_rpc.c"
static int rpc_init_io___1(struct quota_handle *h ) 
{ 


  {
#line 34
  h->qh_info.dqi_max_b_limit = (uint64_t )(~ ((uint32_t )0));
#line 35
  h->qh_info.dqi_max_i_limit = (uint64_t )(~ ((uint32_t )0));
#line 36
  h->qh_info.dqi_max_b_usage = (uint64_t )(4294967295U << 10);
#line 37
  h->qh_info.dqi_max_i_usage = (uint64_t )(~ ((uint32_t )0));
#line 38
  return (0);
}
}
#line 47 "/home/wheatley/newnew/temp/quota-4.01/quotaio_rpc.c"
static struct dquot *rpc_read_dquot___1(struct quota_handle *h , qid_t id___0 ) 
{ 
  struct dquot *dquot ;
  struct dquot *tmp ;
  int ret ;
  int *tmp___0 ;

  {
  {
#line 50
  tmp = get_empty_dquot();
#line 50
  dquot = tmp;
#line 53
  dquot->dq_id = id___0;
#line 54
  dquot->dq_h = h;
#line 55
  ret = rpc_rquota_get(dquot);
  }
#line 55
  if (ret < 0) {
    {
#line 56
    tmp___0 = __errno_location();
#line 56
    *tmp___0 = - ret;
#line 57
    free((void *)dquot);
    }
#line 58
    return ((struct dquot *)((void *)0));
  }
#line 60
  return (dquot);
}
}
#line 70 "/home/wheatley/newnew/temp/quota-4.01/quotaio_rpc.c"
static int rpc_commit_dquot___1(struct dquot *dquot , int flags___7 ) 
{ 
  int ret ;
  char *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;

  {
#line 75
  if ((dquot->dq_h)->qh_io_flags & 4) {
    {
#line 76
    tmp = gettext("Trying to write quota to readonly quotafile on %s\n");
#line 76
    errstr(tmp, (dquot->dq_h)->qh_quotadev);
#line 77
    tmp___0 = __errno_location();
#line 77
    *tmp___0 = 1;
    }
#line 78
    return (-1);
  }
  {
#line 80
  ret = rpc_rquota_set((1024 << 8) | ((dquot->dq_h)->qh_type & 255), dquot);
  }
#line 80
  if (ret < 0) {
    {
#line 81
    tmp___1 = __errno_location();
#line 81
    *tmp___1 = - ret;
    }
#line 82
    return (-1);
  }
#line 84
  return (0);
}
}
#line 45 "/home/wheatley/newnew/temp/quota-4.01/quotaio_tree.c"
static int get_index___1(qid_t id___0 , int depth ) 
{ 


  {
#line 47
  return ((int )((id___0 >> ((4 - depth) - 1) * 8) & 255U));
}
}
#line 51 "/home/wheatley/newnew/temp/quota-4.01/quotaio_tree.c"
static void read_blk___1(struct quota_handle *h , uint blk , dqbuf_t buf ) 
{ 
  int err ;
  ssize_t tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 55
  lseek(h->qh_fd, (__off64_t )(blk << 10), 0);
#line 56
  tmp = read(h->qh_fd, (void *)buf, (size_t )(1 << 10));
#line 56
  err = (int )tmp;
  }
#line 57
  if (err < 0) {
    {
#line 58
    tmp___0 = __errno_location();
#line 58
    tmp___1 = strerror(*tmp___0);
#line 58
    tmp___2 = gettext("Cannot read block %u: %s\n");
#line 58
    die(2, tmp___2, blk, tmp___1);
    }
  } else
#line 59
  if (err != 1 << 10) {
    {
#line 60
    memset((void *)(buf + err), 0, (size_t )((1 << 10) - err));
    }
  }
#line 61
  return;
}
}
#line 64 "/home/wheatley/newnew/temp/quota-4.01/quotaio_tree.c"
static int write_blk___1(struct quota_handle *h , uint blk , dqbuf_t buf ) 
{ 
  int err ;
  ssize_t tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  int *tmp___3 ;

  {
  {
#line 68
  lseek(h->qh_fd, (__off64_t )(blk << 10), 0);
#line 69
  tmp = write(h->qh_fd, (void const   *)buf, (size_t )(1 << 10));
#line 69
  err = (int )tmp;
  }
#line 70
  if (err < 0) {
    {
#line 70
    tmp___3 = __errno_location();
    }
#line 70
    if (*tmp___3 != 28) {
      {
#line 71
      tmp___0 = __errno_location();
#line 71
      tmp___1 = strerror(*tmp___0);
#line 71
      tmp___2 = gettext("Cannot write block (%u): %s\n");
#line 71
      die(2, tmp___2, blk, tmp___1);
      }
    }
  }
#line 72
  if (err != 1 << 10) {
#line 73
    return (-28);
  }
#line 74
  return (0);
}
}
#line 78 "/home/wheatley/newnew/temp/quota-4.01/quotaio_tree.c"
static int get_free_dqblk___1(struct quota_handle *h ) 
{ 
  dqbuf_t buf ;
  void *tmp ;
  struct qt_disk_dqdbheader *dh ;
  struct qtree_mem_dqinfo *info ;
  int blk ;
  char *tmp___0 ;
  int tmp___1 ;
  unsigned int tmp___2 ;

  {
  {
#line 80
  tmp = smalloc((size_t )(1 << 10));
#line 80
  buf = (dqbuf_t )tmp;
#line 81
  dh = (struct qt_disk_dqdbheader *)buf;
#line 82
  info = & h->qh_info.u.v2_mdqi.dqi_qtree;
  }
#line 85
  if (info->dqi_free_blk) {
    {
#line 86
    blk = (int )info->dqi_free_blk;
#line 87
    read_blk___1(h, (uint )blk, buf);
#line 88
    info->dqi_free_blk = dh->dqdh_next_free;
    }
  } else {
    {
#line 91
    memset((void *)buf, 0, (size_t )(1 << 10));
#line 92
    tmp___1 = write_blk___1(h, info->dqi_blocks, buf);
    }
#line 92
    if (tmp___1 < 0) {
      {
#line 93
      free((void *)buf);
#line 94
      tmp___0 = gettext("Cannot allocate new quota block (out of disk space).\n");
#line 94
      errstr(tmp___0);
      }
#line 95
      return (-28);
    }
#line 97
    tmp___2 = info->dqi_blocks;
#line 97
    (info->dqi_blocks) ++;
#line 97
    blk = (int )tmp___2;
  }
  {
#line 99
  mark_quotafile_info_dirty(h);
#line 100
  free((void *)buf);
  }
#line 101
  return (blk);
}
}
#line 105 "/home/wheatley/newnew/temp/quota-4.01/quotaio_tree.c"
static void put_free_dqblk___1(struct quota_handle *h , dqbuf_t buf , uint blk ) 
{ 
  struct qt_disk_dqdbheader *dh ;
  struct qtree_mem_dqinfo *info ;

  {
  {
#line 107
  dh = (struct qt_disk_dqdbheader *)buf;
#line 108
  info = & h->qh_info.u.v2_mdqi.dqi_qtree;
#line 110
  dh->dqdh_next_free = info->dqi_free_blk;
#line 111
  dh->dqdh_prev_free = (__u32 )0;
#line 112
  dh->dqdh_entries = (__u16 )0;
#line 113
  info->dqi_free_blk = blk;
#line 114
  mark_quotafile_info_dirty(h);
#line 115
  write_blk___1(h, blk, buf);
  }
#line 116
  return;
}
}
#line 119 "/home/wheatley/newnew/temp/quota-4.01/quotaio_tree.c"
static void remove_free_dqentry___1(struct quota_handle *h , dqbuf_t buf , uint blk ) 
{ 
  dqbuf_t tmpbuf ;
  void *tmp ;
  struct qt_disk_dqdbheader *dh ;
  uint nextblk ;
  uint prevblk ;
  u_int32_t tmp___0 ;

  {
  {
#line 121
  tmp = smalloc((size_t )(1 << 10));
#line 121
  tmpbuf = (dqbuf_t )tmp;
#line 122
  dh = (struct qt_disk_dqdbheader *)buf;
#line 123
  nextblk = dh->dqdh_next_free;
#line 123
  prevblk = dh->dqdh_prev_free;
  }
#line 127
  if (nextblk) {
    {
#line 128
    read_blk___1(h, nextblk, tmpbuf);
#line 129
    ((struct qt_disk_dqdbheader *)tmpbuf)->dqdh_prev_free = dh->dqdh_prev_free;
#line 130
    write_blk___1(h, nextblk, tmpbuf);
    }
  }
#line 132
  if (prevblk) {
    {
#line 133
    read_blk___1(h, prevblk, tmpbuf);
#line 134
    ((struct qt_disk_dqdbheader *)tmpbuf)->dqdh_next_free = dh->dqdh_next_free;
#line 135
    write_blk___1(h, prevblk, tmpbuf);
    }
  } else {
    {
#line 138
    h->qh_info.u.v2_mdqi.dqi_qtree.dqi_free_entry = nextblk;
#line 139
    mark_quotafile_info_dirty(h);
    }
  }
  {
#line 141
  free((void *)tmpbuf);
#line 142
  tmp___0 = (__u32 )0;
#line 142
  dh->dqdh_prev_free = tmp___0;
#line 142
  dh->dqdh_next_free = tmp___0;
#line 143
  write_blk___1(h, blk, buf);
  }
#line 144
  return;
}
}
#line 147 "/home/wheatley/newnew/temp/quota-4.01/quotaio_tree.c"
static void insert_free_dqentry___1(struct quota_handle *h , dqbuf_t buf , uint blk ) 
{ 
  dqbuf_t tmpbuf ;
  void *tmp ;
  struct qt_disk_dqdbheader *dh ;
  struct qtree_mem_dqinfo *info ;

  {
  {
#line 149
  tmp = smalloc((size_t )(1 << 10));
#line 149
  tmpbuf = (dqbuf_t )tmp;
#line 150
  dh = (struct qt_disk_dqdbheader *)buf;
#line 151
  info = & h->qh_info.u.v2_mdqi.dqi_qtree;
#line 153
  dh->dqdh_next_free = info->dqi_free_entry;
#line 154
  dh->dqdh_prev_free = (__u32 )0;
#line 155
  write_blk___1(h, blk, buf);
  }
#line 156
  if (info->dqi_free_entry) {
    {
#line 157
    read_blk___1(h, info->dqi_free_entry, tmpbuf);
#line 158
    ((struct qt_disk_dqdbheader *)tmpbuf)->dqdh_prev_free = blk;
#line 159
    write_blk___1(h, info->dqi_free_entry, tmpbuf);
    }
  }
  {
#line 161
  free((void *)tmpbuf);
#line 162
  info->dqi_free_entry = blk;
#line 163
  mark_quotafile_info_dirty(h);
  }
#line 164
  return;
}
}
#line 167 "/home/wheatley/newnew/temp/quota-4.01/quotaio_tree.c"
static uint find_free_dqentry___1(struct quota_handle *h , struct dquot *dquot , int *err ) 
{ 
  int blk ;
  int i ;
  struct qt_disk_dqdbheader *dh ;
  struct qtree_mem_dqinfo *info ;
  char *ddquot ;
  dqbuf_t buf ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;

  {
  {
#line 171
  info = & h->qh_info.u.v2_mdqi.dqi_qtree;
#line 175
  *err = 0;
#line 176
  tmp = smalloc((size_t )(1 << 10));
#line 176
  buf = (dqbuf_t )tmp;
#line 177
  dh = (struct qt_disk_dqdbheader *)buf;
  }
#line 178
  if (info->dqi_free_entry) {
    {
#line 179
    blk = (int )info->dqi_free_entry;
#line 180
    read_blk___1(h, (uint )blk, buf);
    }
  } else {
    {
#line 183
    blk = get_free_dqblk___1(h);
    }
#line 184
    if (blk < 0) {
      {
#line 185
      free((void *)buf);
#line 186
      *err = blk;
      }
#line 187
      return ((uint )0);
    }
    {
#line 189
    memset((void *)buf, 0, (size_t )(1 << 10));
#line 190
    info->dqi_free_entry = (unsigned int )blk;
#line 191
    mark_quotafile_info_dirty(h);
    }
  }
  {
#line 193
  tmp___0 = qtree_dqstr_in_blk(info);
  }
#line 193
  if ((int )dh->dqdh_entries + 1 >= tmp___0) {
    {
#line 194
    remove_free_dqentry___1(h, buf, (uint )blk);
    }
  }
#line 195
  dh->dqdh_entries = (__u16 )((int )dh->dqdh_entries + 1);
#line 197
  ddquot = buf + sizeof(struct qt_disk_dqdbheader );
#line 198
  i = 0;
  {
#line 198
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 198
    tmp___1 = qtree_dqstr_in_blk(info);
    }
#line 198
    if (i < tmp___1) {
      {
#line 198
      tmp___2 = qtree_entry_unused(info, ddquot);
      }
#line 198
      if (tmp___2) {
#line 198
        goto while_break;
      }
    } else {
#line 198
      goto while_break;
    }
#line 198
    i ++;
#line 198
    ddquot += info->dqi_entry_size;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 201
  tmp___4 = qtree_dqstr_in_blk(info);
  }
#line 201
  if (i == tmp___4) {
    {
#line 202
    tmp___3 = gettext("find_free_dqentry(): Data block full but it shouldn\'t.\n");
#line 202
    die(2, tmp___3);
    }
  }
  {
#line 203
  write_blk___1(h, (uint )blk, buf);
#line 204
  dquot->dq_dqb.u.v2_mdqb.dqb_off = (loff_t )(((unsigned long )(blk << 10) + sizeof(struct qt_disk_dqdbheader )) + (unsigned long )((unsigned int )i * info->dqi_entry_size));
#line 207
  free((void *)buf);
  }
#line 208
  return ((uint )blk);
}
}
#line 212 "/home/wheatley/newnew/temp/quota-4.01/quotaio_tree.c"
static int do_insert_tree___1(struct quota_handle *h , struct dquot *dquot , uint *treeblk ,
                              int depth ) 
{ 
  dqbuf_t buf ;
  int newson ;
  int newact ;
  u_int32_t *ref ;
  uint newblk ;
  int ret ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;

  {
  {
#line 215
  newson = 0;
#line 215
  newact = 0;
#line 218
  ret = 0;
#line 220
  tmp = smalloc((size_t )(1 << 10));
#line 220
  buf = (dqbuf_t )tmp;
  }
#line 221
  if (! *treeblk) {
    {
#line 222
    ret = get_free_dqblk___1(h);
    }
#line 223
    if (ret < 0) {
#line 224
      goto out_buf;
    }
    {
#line 225
    *treeblk = (uint )ret;
#line 226
    memset((void *)buf, 0, (size_t )(1 << 10));
#line 227
    newact = 1;
    }
  } else {
    {
#line 230
    read_blk___1(h, *treeblk, buf);
    }
  }
  {
#line 231
  ref = (u_int32_t *)buf;
#line 232
  tmp___0 = get_index___1(dquot->dq_id, depth);
#line 232
  newblk = *(ref + tmp___0);
  }
#line 233
  if (! newblk) {
#line 234
    newson = 1;
  }
#line 235
  if (depth == 3) {
#line 236
    if (newblk) {
      {
#line 237
      tmp___1 = get_index___1(dquot->dq_id, depth);
#line 237
      tmp___2 = gettext("Inserting already present quota entry (block %u).\n");
#line 237
      die(2, tmp___2, *(ref + tmp___1));
      }
    }
    {
#line 239
    newblk = find_free_dqentry___1(h, dquot, & ret);
    }
  } else {
    {
#line 242
    ret = do_insert_tree___1(h, dquot, & newblk, depth + 1);
    }
  }
#line 243
  if (newson) {
#line 243
    if (ret >= 0) {
      {
#line 244
      tmp___3 = get_index___1(dquot->dq_id, depth);
#line 244
      *(ref + tmp___3) = newblk;
#line 245
      write_blk___1(h, *treeblk, buf);
      }
    } else {
#line 243
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 247
  if (newact) {
#line 247
    if (ret < 0) {
      {
#line 248
      put_free_dqblk___1(h, buf, *treeblk);
      }
    }
  }
  out_buf: 
  {
#line 250
  free((void *)buf);
  }
#line 251
  return (ret);
}
}
#line 255 "/home/wheatley/newnew/temp/quota-4.01/quotaio_tree.c"
static void dq_insert_tree___1(struct quota_handle *h , struct dquot *dquot ) 
{ 
  uint tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;

  {
  {
#line 257
  tmp = (uint )1;
#line 259
  tmp___3 = do_insert_tree___1(h, dquot, & tmp, 0);
  }
#line 259
  if (tmp___3 < 0) {
    {
#line 260
    tmp___0 = __errno_location();
#line 260
    tmp___1 = strerror(*tmp___0);
#line 260
    tmp___2 = gettext("Cannot write quota (id %u): %s\n");
#line 260
    die(2, tmp___2, dquot->dq_id, tmp___1);
    }
  }
#line 261
  return;
}
}
#line 284 "/home/wheatley/newnew/temp/quota-4.01/quotaio_tree.c"
static void free_dqentry___1(struct quota_handle *h , struct dquot *dquot , uint blk ) 
{ 
  struct qt_disk_dqdbheader *dh ;
  struct qtree_mem_dqinfo *info ;
  dqbuf_t buf ;
  void *tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 287
  info = & h->qh_info.u.v2_mdqi.dqi_qtree;
#line 288
  tmp = smalloc((size_t )(1 << 10));
#line 288
  buf = (dqbuf_t )tmp;
  }
#line 290
  if (dquot->dq_dqb.u.v2_mdqb.dqb_off >> 10 != (loff_t )blk) {
    {
#line 291
    tmp___0 = gettext("Quota structure has offset to other block (%u) than it should (%u).\n");
#line 291
    die(2, tmp___0, blk, (uint )(dquot->dq_dqb.u.v2_mdqb.dqb_off >> 10));
    }
  }
  {
#line 293
  read_blk___1(h, blk, buf);
#line 294
  dh = (struct qt_disk_dqdbheader *)buf;
#line 295
  dh->dqdh_entries = (__u16 )((int )dh->dqdh_entries - 1);
  }
#line 296
  if (! dh->dqdh_entries) {
    {
#line 297
    remove_free_dqentry___1(h, buf, blk);
#line 298
    put_free_dqblk___1(h, buf, blk);
    }
  } else {
    {
#line 301
    memset((void *)(buf + (dquot->dq_dqb.u.v2_mdqb.dqb_off & (long )((1 << 10) - 1))),
           0, (size_t )info->dqi_entry_size);
#line 304
    tmp___1 = qtree_dqstr_in_blk(info);
    }
#line 304
    if ((int )dh->dqdh_entries == tmp___1 - 1) {
      {
#line 305
      insert_free_dqentry___1(h, buf, blk);
      }
    } else {
      {
#line 307
      write_blk___1(h, blk, buf);
      }
    }
  }
  {
#line 309
  dquot->dq_dqb.u.v2_mdqb.dqb_off = (loff_t )0;
#line 310
  free((void *)buf);
  }
#line 311
  return;
}
}
#line 314 "/home/wheatley/newnew/temp/quota-4.01/quotaio_tree.c"
static void remove_tree___1(struct quota_handle *h , struct dquot *dquot , uint *blk ,
                            int depth ) 
{ 
  dqbuf_t buf ;
  void *tmp ;
  uint newblk ;
  u_int32_t *ref ;
  int tmp___0 ;
  int i ;
  int tmp___1 ;

  {
  {
#line 316
  tmp = smalloc((size_t )(1 << 10));
#line 316
  buf = (dqbuf_t )tmp;
#line 318
  ref = (u_int32_t *)buf;
#line 320
  read_blk___1(h, *blk, buf);
#line 321
  tmp___0 = get_index___1(dquot->dq_id, depth);
#line 321
  newblk = *(ref + tmp___0);
  }
#line 322
  if (depth == 3) {
    {
#line 323
    free_dqentry___1(h, dquot, newblk);
#line 324
    newblk = (uint )0;
    }
  } else {
    {
#line 327
    remove_tree___1(h, dquot, & newblk, depth + 1);
    }
  }
#line 328
  if (! newblk) {
    {
#line 331
    tmp___1 = get_index___1(dquot->dq_id, depth);
#line 331
    *(ref + tmp___1) = (__u32 )0;
#line 332
    i = 0;
    }
    {
#line 332
    while (1) {
      while_continue: /* CIL Label */ ;
#line 332
      if (i < 1 << 10) {
#line 332
        if (! (! *(buf + i))) {
#line 332
          goto while_break;
        }
      } else {
#line 332
        goto while_break;
      }
#line 332
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 334
    if (i == 1 << 10) {
#line 334
      if (*blk != 1U) {
        {
#line 335
        put_free_dqblk___1(h, buf, *blk);
#line 336
        *blk = (uint )0;
        }
      } else {
        {
#line 339
        write_blk___1(h, *blk, buf);
        }
      }
    } else {
      {
#line 339
      write_blk___1(h, *blk, buf);
      }
    }
  }
  {
#line 341
  free((void *)buf);
  }
#line 342
  return;
}
}
#line 355 "/home/wheatley/newnew/temp/quota-4.01/quotaio_tree.c"
static loff_t find_block_dqentry___1(struct quota_handle *h , struct dquot *dquot ,
                                     uint blk ) 
{ 
  struct qtree_mem_dqinfo *info ;
  dqbuf_t buf ;
  void *tmp ;
  int i ;
  char *ddquot ;
  int tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;

  {
  {
#line 357
  info = & h->qh_info.u.v2_mdqi.dqi_qtree;
#line 358
  tmp = smalloc((size_t )(1 << 10));
#line 358
  buf = (dqbuf_t )tmp;
#line 360
  ddquot = buf + sizeof(struct qt_disk_dqdbheader );
#line 362
  read_blk___1(h, blk, buf);
#line 363
  i = 0;
  }
  {
#line 363
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 363
    tmp___0 = qtree_dqstr_in_blk(info);
    }
#line 363
    if (i < tmp___0) {
      {
#line 363
      tmp___1 = (*((info->dqi_ops)->is_id))((void *)ddquot, dquot);
      }
#line 363
      if (tmp___1) {
#line 363
        goto while_break;
      }
    } else {
#line 363
      goto while_break;
    }
#line 363
    i ++;
#line 363
    ddquot += info->dqi_entry_size;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 366
  tmp___3 = qtree_dqstr_in_blk(info);
  }
#line 366
  if (i == tmp___3) {
    {
#line 367
    tmp___2 = gettext("Quota for id %u referenced but not present.\n");
#line 367
    die(2, tmp___2, dquot->dq_id);
    }
  }
  {
#line 368
  free((void *)buf);
  }
#line 369
  return ((loff_t )(((unsigned long )(blk << 10) + sizeof(struct qt_disk_dqdbheader )) + (unsigned long )((unsigned int )i * info->dqi_entry_size)));
}
}
#line 374 "/home/wheatley/newnew/temp/quota-4.01/quotaio_tree.c"
static loff_t find_tree_dqentry___1(struct quota_handle *h , struct dquot *dquot ,
                                    uint blk , int depth ) 
{ 
  dqbuf_t buf ;
  void *tmp ;
  loff_t ret ;
  u_int32_t *ref ;
  int tmp___0 ;

  {
  {
#line 376
  tmp = smalloc((size_t )(1 << 10));
#line 376
  buf = (dqbuf_t )tmp;
#line 377
  ret = (loff_t )0;
#line 378
  ref = (u_int32_t *)buf;
#line 380
  read_blk___1(h, blk, buf);
#line 381
  ret = (loff_t )0;
#line 382
  tmp___0 = get_index___1(dquot->dq_id, depth);
#line 382
  blk = *(ref + tmp___0);
  }
#line 383
  if (! blk) {
#line 384
    goto out_buf;
  }
#line 385
  if (depth < 3) {
    {
#line 386
    ret = find_tree_dqentry___1(h, dquot, blk, depth + 1);
    }
  } else {
    {
#line 388
    ret = find_block_dqentry___1(h, dquot, blk);
    }
  }
  out_buf: 
  {
#line 390
  free((void *)buf);
  }
#line 391
  return (ret);
}
}
#line 395 "/home/wheatley/newnew/temp/quota-4.01/quotaio_tree.c"
__inline static loff_t find_dqentry___1(struct quota_handle *h , struct dquot *dquot ) 
{ 
  loff_t tmp ;

  {
  {
#line 397
  tmp = find_tree_dqentry___1(h, dquot, (uint )1, 0);
  }
#line 397
  return (tmp);
}
}
#line 441 "/home/wheatley/newnew/temp/quota-4.01/quotaio_tree.c"
static int report_block___1(struct dquot *dquot , uint blk , char *bitmap , int (*process_dquot)(struct dquot * ,
                                                                                                 char * ) ) 
{ 
  struct qtree_mem_dqinfo *info ;
  dqbuf_t buf ;
  void *tmp ;
  struct qt_disk_dqdbheader *dh ;
  char *ddata ;
  int entries ;
  int i ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 444
  info = & (dquot->dq_h)->qh_info.u.v2_mdqi.dqi_qtree;
#line 445
  tmp = smalloc((size_t )(1 << 10));
#line 445
  buf = (dqbuf_t )tmp;
#line 450
  *(bitmap + (blk >> 3)) = (char )((int )*(bitmap + (blk >> 3)) | (1 << (blk & 7U)));
#line 451
  read_blk___1(dquot->dq_h, blk, buf);
#line 452
  dh = (struct qt_disk_dqdbheader *)buf;
#line 453
  ddata = buf + sizeof(struct qt_disk_dqdbheader );
#line 454
  entries = (int )dh->dqdh_entries;
#line 455
  i = 0;
  }
  {
#line 455
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 455
    tmp___2 = qtree_dqstr_in_blk(info);
    }
#line 455
    if (! (i < tmp___2)) {
#line 455
      goto while_break;
    }
    {
#line 456
    tmp___1 = qtree_entry_unused(info, ddata);
    }
#line 456
    if (! tmp___1) {
      {
#line 457
      (*((info->dqi_ops)->disk2mem_dqblk))(dquot, (void *)ddata);
#line 458
      tmp___0 = (*process_dquot)(dquot, (char *)((void *)0));
      }
#line 458
      if (tmp___0 < 0) {
#line 459
        goto while_break;
      }
    }
#line 455
    i ++;
#line 455
    ddata += info->dqi_entry_size;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 461
  free((void *)buf);
  }
#line 462
  return (entries);
}
}
#line 465 "/home/wheatley/newnew/temp/quota-4.01/quotaio_tree.c"
static void check_reference___1(struct quota_handle *h , uint blk ) 
{ 
  char *tmp ;
  char *tmp___0 ;

  {
#line 467
  if (blk >= h->qh_info.u.v2_mdqi.dqi_qtree.dqi_blocks) {
    {
#line 468
    tmp = type2name(h->qh_type);
#line 468
    tmp___0 = gettext("Illegal reference (%u >= %u) in %s quota file on %s. Quota file is probably corrupted.\nPlease run quotacheck(8) and try again.\n");
#line 468
    die(2, tmp___0, blk, h->qh_info.u.v2_mdqi.dqi_qtree.dqi_blocks, tmp, h->qh_quotadev);
    }
  }
#line 469
  return;
}
}
#line 471 "/home/wheatley/newnew/temp/quota-4.01/quotaio_tree.c"
static int report_tree___1(struct dquot *dquot , uint blk , int depth , char *bitmap ,
                           int (*process_dquot)(struct dquot * , char * ) ) 
{ 
  int entries ;
  int i ;
  dqbuf_t buf ;
  void *tmp ;
  u_int32_t *ref ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 474
  entries = 0;
#line 475
  tmp = smalloc((size_t )(1 << 10));
#line 475
  buf = (dqbuf_t )tmp;
#line 476
  ref = (u_int32_t *)buf;
#line 478
  read_blk___1(dquot->dq_h, blk, buf);
  }
#line 479
  if (depth == 3) {
#line 480
    i = 0;
    {
#line 480
    while (1) {
      while_continue: /* CIL Label */ ;
#line 480
      if (! (i < (1 << 10) >> 2)) {
#line 480
        goto while_break;
      }
      {
#line 481
      blk = *(ref + i);
#line 482
      check_reference___1(dquot->dq_h, blk);
      }
#line 483
      if (blk) {
#line 483
        if (! ((int )*(bitmap + (blk >> 3)) & (1 << (blk & 7U)))) {
          {
#line 484
          tmp___0 = report_block___1(dquot, blk, bitmap, process_dquot);
#line 484
          entries += tmp___0;
          }
        }
      }
#line 480
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 488
    i = 0;
    {
#line 488
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 488
      if (! (i < (1 << 10) >> 2)) {
#line 488
        goto while_break___0;
      }
#line 489
      blk = *(ref + i);
#line 489
      if (blk) {
        {
#line 490
        check_reference___1(dquot->dq_h, blk);
#line 491
        tmp___1 = report_tree___1(dquot, blk, depth + 1, bitmap, process_dquot);
#line 491
        entries += tmp___1;
        }
      }
#line 488
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  {
#line 495
  free((void *)buf);
  }
#line 496
  return (entries);
}
}
#line 499 "/home/wheatley/newnew/temp/quota-4.01/quotaio_tree.c"
static uint find_set_bits___1(char *bmp , int blocks ) 
{ 
  uint i ;
  uint used ;

  {
#line 501
  used = (uint )0;
#line 503
  i = (uint )0;
  {
#line 503
  while (1) {
    while_continue: /* CIL Label */ ;
#line 503
    if (! (i < (uint )blocks)) {
#line 503
      goto while_break;
    }
#line 504
    if ((int )*(bmp + (i >> 3)) & (1 << (i & 7U))) {
#line 505
      used ++;
    }
#line 503
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 506
  return (used);
}
}
#line 10 "/home/wheatley/newnew/temp/quota-4.01/rquota_clnt.c"
static struct timeval TIMEOUT___1  =    {(__time_t )25, (__suseconds_t )0};
#line 15 "/home/wheatley/newnew/temp/quota-4.01/rquota_clnt.c"
static getquota_rslt clnt_res___15  ;
#line 30 "/home/wheatley/newnew/temp/quota-4.01/rquota_clnt.c"
static getquota_rslt clnt_res___16  ;
#line 45 "/home/wheatley/newnew/temp/quota-4.01/rquota_clnt.c"
static setquota_rslt clnt_res___17  ;
#line 60 "/home/wheatley/newnew/temp/quota-4.01/rquota_clnt.c"
static setquota_rslt clnt_res___18  ;
#line 75 "/home/wheatley/newnew/temp/quota-4.01/rquota_clnt.c"
static getquota_rslt clnt_res___19  ;
#line 90 "/home/wheatley/newnew/temp/quota-4.01/rquota_clnt.c"
static getquota_rslt clnt_res___20  ;
#line 105 "/home/wheatley/newnew/temp/quota-4.01/rquota_clnt.c"
static setquota_rslt clnt_res___21  ;
#line 120 "/home/wheatley/newnew/temp/quota-4.01/rquota_clnt.c"
static setquota_rslt clnt_res___22  ;
#line 573 "/usr/include/stdio.h"
extern int fputc(int __c , FILE *__stream ) ;
#line 417 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) pipe)(int *__pipedes ) ;
#line 534
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) dup2)(int __fd ,
                                                                           int __fd2 ) ;
#line 573
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) execl)(char const   *__path ,
                                                                                              char const   *__arg 
                                                                                              , ...) ;
#line 755 "/usr/include/stdlib.h"
extern void *( __attribute__((__nonnull__(1,2,5))) bsearch)(void const   *__key ,
                                                            void const   *__base ,
                                                            size_t __nmemb , size_t __size ,
                                                            int (*__compar)(void const   * ,
                                                                            void const   * ) ) ;
#line 534 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcasecmp)(char const   *__s1 ,
                                                                                                   char const   *__s2 )  __attribute__((__pure__)) ;
#line 102 "/usr/include/x86_64-linux-gnu/sys/wait.h"
extern __pid_t wait(union wait *__stat_loc ) ;
#line 81 "/usr/include/x86_64-linux-gnu/sys/utsname.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) uname)(struct utsname *__name ) ;
#line 144 "/home/wheatley/newnew/temp/quota-4.01/warnquota.c"
static int qtab_i  =    0;
#line 144 "/home/wheatley/newnew/temp/quota-4.01/warnquota.c"
static int fmt___2  =    -1;
#line 144 "/home/wheatley/newnew/temp/quota-4.01/warnquota.c"
static int flags___2  ;
#line 145 "/home/wheatley/newnew/temp/quota-4.01/warnquota.c"
static char maildev[2048]  ;
#line 146 "/home/wheatley/newnew/temp/quota-4.01/warnquota.c"
static struct quota_handle *maildev_handle  ;
#line 147 "/home/wheatley/newnew/temp/quota-4.01/warnquota.c"
static char *configfile  =    (char *)"/etc/warnquota.conf";
#line 147 "/home/wheatley/newnew/temp/quota-4.01/warnquota.c"
static char *quotatabfile  =    (char *)"/etc/quotatab";
#line 147 "/home/wheatley/newnew/temp/quota-4.01/warnquota.c"
static char *adminsfile  =    (char *)"/etc/quotagrpadmins";
#line 149 "/home/wheatley/newnew/temp/quota-4.01/warnquota.c"
static char *hostname  ;
#line 149 "/home/wheatley/newnew/temp/quota-4.01/warnquota.c"
static char *domainname  ;
#line 150 "/home/wheatley/newnew/temp/quota-4.01/warnquota.c"
static quotatable_t *quotatable  ;
#line 151 "/home/wheatley/newnew/temp/quota-4.01/warnquota.c"
static int adminscnt  ;
#line 151 "/home/wheatley/newnew/temp/quota-4.01/warnquota.c"
static int adminsalloc  ;
#line 152 "/home/wheatley/newnew/temp/quota-4.01/warnquota.c"
static struct adminstable *adminstable  ;
#line 157 "/home/wheatley/newnew/temp/quota-4.01/warnquota.c"
static struct offenderlist *offenders  =    (struct offenderlist *)0;
#line 162 "/home/wheatley/newnew/temp/quota-4.01/warnquota.c"
static void wc_exit(int ex_stat ) 
{ 


  {
  {
#line 172
  exit(ex_stat);
  }
}
}
#line 219 "/home/wheatley/newnew/temp/quota-4.01/warnquota.c"
static struct offenderlist *add_offender(int type , int id___0 , char *name ) 
{ 
  struct offenderlist *offender ;
  char namebuf[64] ;
  char *tmp ;
  int tmp___0 ;
  void *tmp___1 ;

  {
#line 224
  if (! name) {
    {
#line 225
    tmp___0 = id2name(id___0, type, namebuf);
    }
#line 225
    if (tmp___0) {
      {
#line 226
      tmp = gettext("Cannot get name for uid/gid %u.\n");
#line 226
      errstr(tmp, id___0);
      }
#line 227
      return ((struct offenderlist *)((void *)0));
    }
#line 229
    name = namebuf;
  }
  {
#line 231
  tmp___1 = smalloc(sizeof(struct offenderlist ));
#line 231
  offender = (struct offenderlist *)tmp___1;
#line 232
  offender->offender_type = type;
#line 233
  offender->offender_id = id___0;
#line 234
  offender->offender_name = sstrdup((char const   *)name);
#line 235
  offender->usage = (struct usage *)((void *)0);
#line 236
  offender->next = offenders;
#line 237
  offenders = offender;
  }
#line 238
  return (offender);
}
}
#line 241 "/home/wheatley/newnew/temp/quota-4.01/warnquota.c"
static void add_offence(struct dquot *dquot , char *name ) 
{ 
  struct offenderlist *lptr ;
  struct usage *usage___9 ;
  void *tmp ;

  {
#line 246
  lptr = offenders;
  {
#line 246
  while (1) {
    while_continue: /* CIL Label */ ;
#line 246
    if (! lptr) {
#line 246
      goto while_break;
    }
#line 247
    if ((dquot->dq_h)->qh_type == lptr->offender_type) {
#line 247
      if ((qid_t )lptr->offender_id == dquot->dq_id) {
#line 248
        goto while_break;
      }
    }
#line 246
    lptr = lptr->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 250
  if (! lptr) {
    {
#line 251
    lptr = add_offender((dquot->dq_h)->qh_type, (int )dquot->dq_id, name);
    }
#line 251
    if (! lptr) {
#line 252
      return;
    }
  }
  {
#line 254
  tmp = smalloc(sizeof(struct usage ));
#line 254
  usage___9 = (struct usage *)tmp;
#line 255
  memcpy((void */* __restrict  */)(& usage___9->dq_dqb), (void const   */* __restrict  */)(& dquot->dq_dqb),
         sizeof(struct util_dqblk ));
#line 257
  usage___9->devicename = sstrdup((char const   *)((dquot->dq_h)->qh_quotadev));
#line 261
  usage___9->next = lptr->usage;
#line 262
  lptr->usage = usage___9;
  }
#line 263
  return;
}
}
#line 265 "/home/wheatley/newnew/temp/quota-4.01/warnquota.c"
static int deliverable(struct dquot *dquot ) 
{ 
  time_t now___0 ;
  struct dquot *mdquot ;
  int tmp ;

  {
#line 270
  if (! maildev[0]) {
#line 271
    return (1);
  }
  {
#line 273
  time(& now___0);
#line 275
  tmp = strcasecmp((char const   *)(maildev), "any");
  }
#line 275
  if (! tmp) {
#line 275
    if (dquot->dq_dqb.dqb_bhardlimit) {
#line 275
      if (((dquot->dq_dqb.dqb_curspace + (qsize_t )(1 << 10)) - 1L) >> 10 >= dquot->dq_dqb.dqb_bhardlimit) {
#line 279
        return (0);
      } else {
#line 275
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 275
    if (dquot->dq_dqb.dqb_bsoftlimit) {
#line 275
      if (((dquot->dq_dqb.dqb_curspace + (qsize_t )(1 << 10)) - 1L) >> 10 >= dquot->dq_dqb.dqb_bsoftlimit) {
#line 275
        if (dquot->dq_dqb.dqb_btime) {
#line 275
          if (dquot->dq_dqb.dqb_btime <= now___0) {
#line 279
            return (0);
          }
        }
      }
    }
  }
#line 280
  if (! maildev_handle) {
#line 281
    return (1);
  }
  {
#line 282
  mdquot = (*((maildev_handle->qh_ops)->read_dquot))(maildev_handle, dquot->dq_id);
  }
#line 283
  if (mdquot) {
#line 283
    if (mdquot->dq_dqb.dqb_bhardlimit) {
#line 283
      if (((mdquot->dq_dqb.dqb_curspace + (qsize_t )(1 << 10)) - 1L) >> 10 >= mdquot->dq_dqb.dqb_bhardlimit) {
        {
#line 287
        free((void *)mdquot);
        }
#line 288
        return (0);
      } else {
#line 283
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 283
    if (mdquot->dq_dqb.dqb_bsoftlimit) {
#line 283
      if (((mdquot->dq_dqb.dqb_curspace + (qsize_t )(1 << 10)) - 1L) >> 10 >= mdquot->dq_dqb.dqb_bsoftlimit) {
#line 283
        if (mdquot->dq_dqb.dqb_btime) {
#line 283
          if (mdquot->dq_dqb.dqb_btime <= now___0) {
            {
#line 287
            free((void *)mdquot);
            }
#line 288
            return (0);
          }
        }
      }
    }
  }
  {
#line 290
  free((void *)mdquot);
  }
#line 291
  return (1);
}
}
#line 294 "/home/wheatley/newnew/temp/quota-4.01/warnquota.c"
static int check_offence(struct dquot *dquot , char *name ) 
{ 
  int tmp ;

  {
#line 296
  if (dquot->dq_dqb.dqb_bsoftlimit) {
#line 296
    if (((dquot->dq_dqb.dqb_curspace + (qsize_t )(1 << 10)) - 1L) >> 10 >= dquot->dq_dqb.dqb_bsoftlimit) {
#line 296
      goto _L;
    } else {
#line 296
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 296
  if (dquot->dq_dqb.dqb_isoftlimit) {
#line 296
    if (dquot->dq_dqb.dqb_curinodes >= dquot->dq_dqb.dqb_isoftlimit) {
      _L: /* CIL Label */ 
      {
#line 298
      tmp = deliverable(dquot);
      }
#line 298
      if (tmp) {
        {
#line 299
        add_offence(dquot, name);
        }
      }
    }
  }
#line 301
  return (0);
}
}
#line 304 "/home/wheatley/newnew/temp/quota-4.01/warnquota.c"
static FILE *run_mailer(char *command ) 
{ 
  int pipefd[2] ;
  FILE *f ;
  int *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  __pid_t tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  int *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  int tmp___10 ;
  int *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  int *tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;

  {
  {
#line 309
  tmp___2 = pipe((int *)(pipefd));
  }
#line 309
  if (tmp___2 < 0) {
    {
#line 310
    tmp = __errno_location();
#line 310
    tmp___0 = strerror(*tmp);
#line 310
    tmp___1 = gettext("Cannot create pipe: %s\n");
#line 310
    errstr(tmp___1, tmp___0);
    }
#line 311
    return ((FILE *)((void *)0));
  }
  {
#line 313
  signal(13, (void (*)(int  ))1);
#line 314
  tmp___3 = fork();
  }
  {
#line 315
  if (tmp___3 == -1) {
#line 315
    goto case_neg_1;
  }
#line 318
  if (tmp___3 == 0) {
#line 318
    goto case_0;
  }
#line 327
  goto switch_default;
  case_neg_1: /* CIL Label */ 
  {
#line 316
  tmp___4 = __errno_location();
#line 316
  tmp___5 = strerror(*tmp___4);
#line 316
  tmp___6 = gettext("Cannot fork: %s\n");
#line 316
  errstr(tmp___6, tmp___5);
  }
#line 317
  return ((FILE *)((void *)0));
  case_0: /* CIL Label */ 
  {
#line 319
  close(pipefd[1]);
#line 320
  tmp___10 = dup2(pipefd[0], 0);
  }
#line 320
  if (tmp___10 < 0) {
    {
#line 321
    tmp___7 = __errno_location();
#line 321
    tmp___8 = strerror(*tmp___7);
#line 321
    tmp___9 = gettext("Cannot duplicate descriptor: %s\n");
#line 321
    errstr(tmp___9, tmp___8);
#line 322
    wc_exit(1);
    }
  }
  {
#line 324
  execl("/bin/sh", "/bin/sh", "-c", command, (void *)0);
#line 325
  tmp___11 = __errno_location();
#line 325
  tmp___12 = strerror(*tmp___11);
#line 325
  tmp___13 = gettext("Cannot execute \'%s\': %s\n");
#line 325
  errstr(tmp___13, command, tmp___12);
#line 326
  wc_exit(1);
  }
  switch_default: /* CIL Label */ 
  {
#line 328
  close(pipefd[0]);
#line 329
  f = fdopen(pipefd[1], "w");
  }
#line 329
  if (! f) {
    {
#line 330
    tmp___14 = __errno_location();
#line 330
    tmp___15 = strerror(*tmp___14);
#line 330
    tmp___16 = gettext("Cannot open pipe: %s\n");
#line 330
    errstr(tmp___16, tmp___15);
    }
  }
#line 331
  return (f);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 335 "/home/wheatley/newnew/temp/quota-4.01/warnquota.c"
static int admin_name_cmp(void const   *key , void const   *mem ) 
{ 
  int tmp ;

  {
  {
#line 337
  tmp = strcmp((char const   *)key, (char const   *)((struct adminstable *)mem)->grpname);
  }
#line 337
  return (tmp);
}
}
#line 340 "/home/wheatley/newnew/temp/quota-4.01/warnquota.c"
static int should_cc(struct offenderlist *offender , struct configparams *config ) 
{ 
  struct usage *lptr ;
  struct util_dqblk *dqb ;
  time_t atime ;

  {
#line 346
  if (config->cc_before == -1L) {
#line 347
    return (1);
  }
  {
#line 348
  time(& atime);
#line 349
  lptr = offender->usage;
  }
  {
#line 349
  while (1) {
    while_continue: /* CIL Label */ ;
#line 349
    if (! lptr) {
#line 349
      goto while_break;
    }
#line 350
    dqb = & lptr->dq_dqb;
#line 351
    if (dqb->dqb_bsoftlimit) {
#line 351
      if (dqb->dqb_bsoftlimit <= ((dqb->dqb_curspace + (qsize_t )(1 << 10)) - 1L) >> 10) {
#line 351
        if (dqb->dqb_btime - config->cc_before <= atime) {
#line 352
          return (1);
        }
      }
    }
#line 353
    if (dqb->dqb_isoftlimit) {
#line 353
      if (dqb->dqb_isoftlimit <= dqb->dqb_curinodes) {
#line 353
        if (dqb->dqb_itime - config->cc_before <= atime) {
#line 354
          return (1);
        }
      }
    }
#line 349
    lptr = lptr->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 356
  return (0);
}
}
#line 360 "/home/wheatley/newnew/temp/quota-4.01/warnquota.c"
static void format_print(FILE *fp , char *fmt___7 , char *name ) 
{ 
  char *ch ;
  char *lastch ;

  {
  {
#line 362
  lastch = fmt___7;
#line 364
  ch = strchr((char const   *)fmt___7, '%');
  }
  {
#line 364
  while (1) {
    while_continue: /* CIL Label */ ;
#line 364
    if (! ch) {
#line 364
      goto while_break;
    }
    {
#line 365
    *ch = (char)0;
#line 366
    fputs((char const   */* __restrict  */)lastch, (FILE */* __restrict  */)fp);
#line 367
    *ch = (char )'%';
    }
    {
#line 370
    if ((int )*(ch + 1) == 105) {
#line 370
      goto case_105;
    }
#line 370
    if ((int )*(ch + 1) == 115) {
#line 370
      goto case_105;
    }
#line 373
    if ((int )*(ch + 1) == 104) {
#line 373
      goto case_104;
    }
#line 376
    if ((int )*(ch + 1) == 100) {
#line 376
      goto case_100;
    }
#line 379
    if ((int )*(ch + 1) == 37) {
#line 379
      goto case_37;
    }
#line 368
    goto switch_break;
    case_105: /* CIL Label */ 
    case_115: /* CIL Label */ 
    {
#line 371
    fputs((char const   */* __restrict  */)name, (FILE */* __restrict  */)fp);
    }
#line 372
    goto switch_break;
    case_104: /* CIL Label */ 
    {
#line 374
    fputs((char const   */* __restrict  */)hostname, (FILE */* __restrict  */)fp);
    }
#line 375
    goto switch_break;
    case_100: /* CIL Label */ 
    {
#line 377
    fputs((char const   */* __restrict  */)domainname, (FILE */* __restrict  */)fp);
    }
#line 378
    goto switch_break;
    case_37: /* CIL Label */ 
    {
#line 380
    fputc('%', fp);
    }
#line 381
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
    {
#line 364
    lastch = ch + 2;
#line 364
    ch = strchr((char const   *)(ch + 2), '%');
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 384
  fputs((char const   */* __restrict  */)lastch, (FILE */* __restrict  */)fp);
  }
#line 385
  return;
}
}
#line 387 "/home/wheatley/newnew/temp/quota-4.01/warnquota.c"
static int mail_user(struct offenderlist *offender , struct configparams *config ) 
{ 
  struct usage *lptr ;
  FILE *fp ;
  int cnt ;
  int status ;
  char timebuf[40] ;
  char numbuf[3][32] ;
  struct util_dqblk *dqb ;
  char *to ;
  struct adminstable *admin ;
  char *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  size_t tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  int *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  union __anonunion_59 __constr_expr_0 ;
  union __anonunion_60 __constr_expr_1 ;
  __pid_t tmp___16 ;

  {
#line 395
  to = (char *)((void *)0);
#line 405
  if (offender->offender_type == 0) {
    {
#line 483
    to = sstrdup((char const   *)offender->offender_name);
    }
  } else {
    {
#line 488
    tmp___0 = bsearch((void const   *)offender->offender_name, (void const   *)adminstable,
                      (size_t )adminscnt, sizeof(struct adminstable ), & admin_name_cmp);
#line 488
    admin = (struct adminstable *)tmp___0;
    }
#line 488
    if (! admin) {
      {
#line 489
      tmp = gettext("Administrator for a group %s not found. Cancelling mail.\n");
#line 489
      errstr(tmp, offender->offender_name);
      }
#line 490
      return (-1);
    }
    {
#line 492
    to = sstrdup((char const   *)admin->adminname);
    }
  }
  {
#line 494
  fp = run_mailer(config->mail_cmd);
  }
#line 494
  if (! fp) {
#line 495
    if (to) {
      {
#line 496
      free((void *)to);
      }
    }
#line 497
    return (-1);
  }
  {
#line 499
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"From: %s\n",
          config->from);
#line 500
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"Reply-To: %s\n",
          config->support);
#line 501
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"Subject: %s\n",
          config->subject);
#line 502
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"To: %s\n",
          to);
#line 503
  tmp___1 = should_cc(offender, config);
  }
#line 503
  if (tmp___1) {
    {
#line 504
    fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"Cc: %s\n",
            config->cc_to);
    }
  }
#line 505
  if ((int )config->charset[0] != 0) {
    {
#line 506
    fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"Content-Type: text/plain; charset=%s\n",
            config->charset);
#line 507
    fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"Content-Disposition: inline\n");
#line 508
    fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"Content-Transfer-Encoding: 8bit\n");
    }
  }
  {
#line 510
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"\n");
#line 511
  free((void *)to);
  }
#line 513
  if (offender->offender_type == 0) {
#line 514
    if (config->user_message) {
      {
#line 515
      format_print(fp, config->user_message, offender->offender_name);
      }
    } else {
      {
#line 517
      tmp___2 = gettext("Hi,\n\nWe noticed that you are in violation with the quotasystem\nused on this system. We have found the following violations:\n\n");
#line 517
      fputs((char const   */* __restrict  */)tmp___2, (FILE */* __restrict  */)fp);
      }
    }
  } else
#line 519
  if (config->group_message) {
    {
#line 520
    format_print(fp, config->group_message, offender->offender_name);
    }
  } else {
    {
#line 522
    tmp___3 = gettext("Hi,\n\nWe noticed that the group %s you are member of violates the quotasystem\nused on this system. We have found the following violations:\n\n");
#line 522
    fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)tmp___3,
            offender->offender_name);
    }
  }
#line 524
  if (! (flags___2 & 16)) {
#line 525
    lptr = offender->usage;
    {
#line 525
    while (1) {
      while_continue: /* CIL Label */ ;
#line 525
      if (! lptr) {
#line 525
        goto while_break;
      }
#line 526
      dqb = & lptr->dq_dqb;
#line 527
      cnt = 0;
      {
#line 527
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 527
        if (! (cnt < qtab_i)) {
#line 527
          goto while_break___0;
        }
        {
#line 528
        tmp___4 = strcmp((char const   *)(quotatable + cnt)->devname, (char const   *)lptr->devicename);
        }
#line 528
        if (! tmp___4) {
          {
#line 529
          fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"\n%s (%s)\n",
                  (quotatable + cnt)->devdesc, (quotatable + cnt)->devname);
          }
#line 530
          goto while_break___0;
        }
#line 527
        cnt ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 532
      if (cnt == qtab_i) {
        {
#line 533
        fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"\n%s\n",
                lptr->devicename);
        }
      }
      {
#line 534
      tmp___5 = gettext("\n                        Block limits               File limits\n");
#line 534
      fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)tmp___5);
#line 535
      tmp___6 = gettext("Filesystem           used    soft    hard  grace    used  soft  hard  grace\n");
#line 535
      fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)tmp___6);
#line 536
      tmp___7 = strlen((char const   *)lptr->devicename);
      }
#line 536
      if (tmp___7 > 15UL) {
        {
#line 537
        fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%s\n%15s",
                lptr->devicename, "");
        }
      } else {
        {
#line 539
        fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%-15s",
                lptr->devicename);
        }
      }
#line 540
      if (dqb->dqb_bsoftlimit) {
#line 540
        if (dqb->dqb_bsoftlimit <= ((dqb->dqb_curspace + (qsize_t )(1 << 10)) - 1L) >> 10) {
          {
#line 541
          difftime2str(dqb->dqb_btime, timebuf);
          }
        } else {
#line 543
          timebuf[0] = (char )'\000';
        }
      } else {
#line 543
        timebuf[0] = (char )'\000';
      }
      {
#line 544
      space2str(((dqb->dqb_curspace + (qsize_t )(1 << 10)) - 1L) >> 10, numbuf[0],
                flags___2 & 8);
#line 545
      space2str(dqb->dqb_bsoftlimit, numbuf[1], flags___2 & 8);
#line 546
      space2str(dqb->dqb_bhardlimit, numbuf[2], flags___2 & 8);
      }
#line 547
      if (dqb->dqb_isoftlimit) {
#line 547
        if (dqb->dqb_curinodes >= dqb->dqb_isoftlimit) {
#line 547
          tmp___8 = '+';
        } else {
#line 547
          tmp___8 = '-';
        }
      } else {
#line 547
        tmp___8 = '-';
      }
#line 547
      if (dqb->dqb_bsoftlimit) {
#line 547
        if (((dqb->dqb_curspace + (qsize_t )(1 << 10)) - 1L) >> 10 >= dqb->dqb_bsoftlimit) {
#line 547
          tmp___9 = '+';
        } else {
#line 547
          tmp___9 = '-';
        }
      } else {
#line 547
        tmp___9 = '-';
      }
      {
#line 547
      fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%c%c %7s %7s %7s %6s",
              tmp___9, tmp___8, numbuf[0], numbuf[1], numbuf[2], timebuf);
      }
#line 551
      if (dqb->dqb_isoftlimit) {
#line 551
        if (dqb->dqb_isoftlimit <= dqb->dqb_curinodes) {
          {
#line 552
          difftime2str(dqb->dqb_itime, timebuf);
          }
        } else {
#line 554
          timebuf[0] = (char )'\000';
        }
      } else {
#line 554
        timebuf[0] = (char )'\000';
      }
      {
#line 555
      number2str((unsigned long long )dqb->dqb_curinodes, numbuf[0], flags___2 & 8);
#line 556
      number2str((unsigned long long )dqb->dqb_isoftlimit, numbuf[1], flags___2 & 8);
#line 557
      number2str((unsigned long long )dqb->dqb_ihardlimit, numbuf[2], flags___2 & 8);
#line 558
      fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" %7s %5s %5s %6s\n\n",
              numbuf[0], numbuf[1], numbuf[2], timebuf);
#line 525
      lptr = lptr->next;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 563
  if (offender->offender_type == 0) {
#line 564
    if (config->user_signature) {
      {
#line 565
      format_print(fp, config->user_signature, offender->offender_name);
      }
    } else {
      {
#line 567
      tmp___10 = gettext("\nWe hope that you will cleanup before your grace period expires.\n\nBasically, this means that the system thinks you are using more disk space\non the above partition(s) than you are allowed.  If you do not delete files\nand get below your quota before the grace period expires, the system will\nprevent you from creating new files.\n\nFor additional assistance, please contact us at %s\nor via phone at %s.\n");
#line 567
      fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)tmp___10,
              config->support, config->phone);
      }
    }
  } else
#line 569
  if (config->group_signature) {
    {
#line 570
    format_print(fp, config->group_signature, offender->offender_name);
    }
  } else {
    {
#line 572
    tmp___11 = gettext("\nPlease cleanup the group data before the grace period expires.\n\nBasically, this means that the system thinks group is using more disk space\non the above partition(s) than it is allowed.  If you do not delete files\nand get below group quota before the grace period expires, the system will\nprevent you and other members of the group from creating new files owned by\nthe group.\n\nFor additional assistance, please contact us at %s\nor via phone at %s.\n");
#line 572
    fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)tmp___11,
            config->support, config->phone);
    }
  }
  {
#line 573
  fclose(fp);
#line 574
  tmp___16 = wait((union wait *)(& status));
  }
#line 574
  if (tmp___16 < 0) {
    {
#line 575
    tmp___12 = __errno_location();
#line 575
    tmp___13 = strerror(*tmp___12);
#line 575
    tmp___14 = gettext("Cannot wait for mailer: %s\n");
#line 575
    errstr(tmp___14, tmp___13);
    }
  } else {
#line 576
    __constr_expr_0.__in = status;
#line 576
    if ((__constr_expr_0.__i & 127) == 0) {
#line 576
      __constr_expr_1.__in = status;
#line 576
      if ((__constr_expr_1.__i & 65280) >> 8 != 0) {
        {
#line 577
        tmp___15 = gettext("Warning: Mailer exitted abnormally.\n");
#line 577
        errstr(tmp___15);
        }
      }
    } else {
      {
#line 577
      tmp___15 = gettext("Warning: Mailer exitted abnormally.\n");
#line 577
      errstr(tmp___15);
      }
    }
  }
#line 579
  return (0);
}
}
#line 582 "/home/wheatley/newnew/temp/quota-4.01/warnquota.c"
static int mail_to_offenders(struct configparams *config ) 
{ 
  struct offenderlist *lptr ;
  int ret ;
  int tmp ;

  {
#line 585
  ret = 0;
#line 590
  lptr = offenders;
  {
#line 590
  while (1) {
    while_continue: /* CIL Label */ ;
#line 590
    if (! lptr) {
#line 590
      goto while_break;
    }
    {
#line 591
    tmp = mail_user(lptr, config);
#line 591
    ret |= tmp;
#line 590
    lptr = lptr->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 592
  return (ret);
}
}
#line 598 "/home/wheatley/newnew/temp/quota-4.01/warnquota.c"
static void stripstring(char **buff ) 
{ 
  int i ;
  size_t tmp ;
  unsigned short const   **tmp___0 ;
  unsigned short const   **tmp___1 ;

  {
  {
#line 603
  tmp = strlen((char const   *)*buff);
#line 603
  i = (int )(tmp - 1UL);
  }
  {
#line 603
  while (1) {
    while_continue: /* CIL Label */ ;
#line 603
    if (i >= 0) {
      {
#line 603
      tmp___0 = __ctype_b_loc();
      }
#line 603
      if (! ((int const   )*(*tmp___0 + (int )*(*buff + i)) & 8192)) {
#line 603
        if (! ((int )*(*buff + i) == 34)) {
#line 603
          if (! ((int )*(*buff + i) == 39)) {
#line 603
            goto while_break;
          }
        }
      }
    } else {
#line 603
      goto while_break;
    }
#line 603
    i --;
  }
  while_break: /* CIL Label */ ;
  }
#line 605
  *(*buff + (i + 1)) = (char)0;
#line 608
  i = 0;
  {
#line 608
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 608
    if (*(*buff + i)) {
      {
#line 608
      tmp___1 = __ctype_b_loc();
      }
#line 608
      if (! ((int const   )*(*tmp___1 + (int )*(*buff + i)) & 8192)) {
#line 608
        if (! ((int )*(*buff + i) == 34)) {
#line 608
          if (! ((int )*(*buff + i) == 39)) {
#line 608
            goto while_break___0;
          }
        }
      }
    } else {
#line 608
      goto while_break___0;
    }
#line 608
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 609
  *buff += i;
#line 610
  return;
}
}
#line 615 "/home/wheatley/newnew/temp/quota-4.01/warnquota.c"
static void create_eoln(char *buf ) 
{ 
  char *colpos ;

  {
#line 617
  colpos = buf;
  {
#line 619
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 619
    colpos = strchr((char const   *)colpos, '|');
    }
#line 619
    if (! colpos) {
#line 619
      goto while_break;
    }
#line 620
    *colpos = (char )'\n';
  }
  while_break: /* CIL Label */ ;
  }
#line 621
  return;
}
}
#line 626 "/home/wheatley/newnew/temp/quota-4.01/warnquota.c"
static int get_quotatable(void) 
{ 
  FILE *fp ;
  char buffer[16384] ;
  char *colpos ;
  char *devname ;
  char *devdesc ;
  int line___0 ;
  struct stat st ;
  int *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  unsigned short const   **tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  void *tmp___6 ;
  char *tmp___7 ;

  {
  {
#line 633
  fp = fopen((char const   */* __restrict  */)quotatabfile, (char const   */* __restrict  */)"r");
  }
#line 633
  if (! fp) {
    {
#line 634
    tmp = __errno_location();
#line 634
    tmp___0 = strerror(*tmp);
#line 634
    tmp___1 = gettext("Cannot open %s: %s\nWill use device names.\n");
#line 634
    errstr(tmp___1, quotatabfile, tmp___0);
#line 635
    qtab_i = 0;
    }
#line 636
    return (0);
  }
#line 639
  line___0 = 0;
#line 640
  qtab_i = 0;
  {
#line 640
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 640
    tmp___6 = srealloc((void *)quotatable, sizeof(quotatable_t ) * (unsigned long )(qtab_i + 1));
#line 640
    quotatable = (quotatable_t *)tmp___6;
#line 640
    tmp___7 = fgets((char */* __restrict  */)(buffer), (int )sizeof(buffer), (FILE */* __restrict  */)fp);
    }
#line 640
    if (! tmp___7) {
#line 640
      goto while_break;
    }
#line 642
    line___0 ++;
#line 643
    (quotatable + qtab_i)->devname = (char *)((void *)0);
#line 644
    (quotatable + qtab_i)->devdesc = (char *)((void *)0);
#line 645
    if ((int )buffer[0] == 35) {
#line 646
      qtab_i --;
#line 647
      goto __Cont;
    } else
#line 645
    if ((int )buffer[0] == 59) {
#line 646
      qtab_i --;
#line 647
      goto __Cont;
    }
#line 650
    colpos = buffer;
    {
#line 650
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 650
      tmp___2 = __ctype_b_loc();
      }
#line 650
      if (! ((int const   )*(*tmp___2 + (int )*colpos) & 8192)) {
#line 650
        goto while_break___0;
      }
#line 650
      colpos ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 651
    if (! *colpos) {
#line 652
      qtab_i --;
#line 653
      goto __Cont;
    }
    {
#line 656
    colpos = strchr((char const   *)(buffer), ':');
    }
#line 656
    if (! colpos) {
      {
#line 657
      tmp___3 = gettext("Cannot parse line %d in quotatab (missing \':\')\n");
#line 657
      errstr(tmp___3, line___0);
#line 658
      qtab_i --;
      }
#line 659
      goto __Cont;
    }
    {
#line 661
    *colpos = (char)0;
#line 662
    devname = buffer;
#line 663
    devdesc = colpos + 1;
#line 664
    stripstring(& devname);
#line 665
    stripstring(& devdesc);
#line 666
    (quotatable + qtab_i)->devname = sstrdup((char const   *)devname);
#line 667
    (quotatable + qtab_i)->devdesc = sstrdup((char const   *)devdesc);
#line 668
    create_eoln((quotatable + qtab_i)->devdesc);
#line 670
    tmp___5 = stat((char const   */* __restrict  */)(quotatable + qtab_i)->devname,
                   (struct stat */* __restrict  */)(& st));
    }
#line 670
    if (tmp___5 < 0) {
      {
#line 671
      tmp___4 = gettext("Cannot stat device %s (maybe typo in quotatab)\n");
#line 671
      errstr(tmp___4, (quotatable + qtab_i)->devname);
      }
    }
    __Cont: /* CIL Label */ 
#line 640
    qtab_i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 673
  fclose(fp);
  }
#line 674
  return (0);
}
}
#line 678 "/home/wheatley/newnew/temp/quota-4.01/warnquota.c"
static void verify_format(char *fmt___7 , char *varname ) 
{ 
  char *ch ;
  char *tmp ;

  {
  {
#line 682
  ch = strchr((char const   *)fmt___7, '%');
  }
  {
#line 682
  while (1) {
    while_continue: /* CIL Label */ ;
#line 682
    if (! ch) {
#line 682
      goto while_break;
    }
    {
#line 688
    if ((int )*(ch + 1) == 37) {
#line 688
      goto case_37;
    }
#line 688
    if ((int )*(ch + 1) == 100) {
#line 688
      goto case_37;
    }
#line 688
    if ((int )*(ch + 1) == 104) {
#line 688
      goto case_37;
    }
#line 688
    if ((int )*(ch + 1) == 105) {
#line 688
      goto case_37;
    }
#line 688
    if ((int )*(ch + 1) == 115) {
#line 688
      goto case_37;
    }
#line 690
    goto switch_default;
    case_37: /* CIL Label */ 
    case_100: /* CIL Label */ 
    case_104: /* CIL Label */ 
    case_105: /* CIL Label */ 
    case_115: /* CIL Label */ 
#line 689
    goto __Cont;
    switch_default: /* CIL Label */ 
    {
#line 691
    tmp = gettext("Incorrect format string for variable %s.\nUnrecognized expression %%%c.\n");
#line 691
    die(1, tmp, varname, (int )*(ch + 1));
    }
    switch_break: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
    {
#line 682
    ch = strchr((char const   *)(ch + 2), '%');
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 695
  return;
}
}
#line 701 "/home/wheatley/newnew/temp/quota-4.01/warnquota.c"
static int readconfigfile(char const   *filename , struct configparams *config ) 
{ 
  FILE *fp ;
  char buff[16384] ;
  char *var ;
  char *value ;
  char *pos ;
  int line___0 ;
  int len ;
  int bufpos ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  unsigned short const   **tmp___5 ;
  size_t tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;
  int num ;
  char unit[10] ;
  int tmp___9 ;
  char *tmp___10 ;
  int tmp___11 ;
  char *tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  char *tmp___27 ;
  char *tmp___28 ;
  char *tmp___29 ;

  {
  {
#line 711
  sstrncpy(config->mail_cmd, "/usr/lib/sendmail -t", (size_t )2048);
#line 712
  sstrncpy(config->from, "support@localhost", (size_t )2048);
#line 713
  sstrncpy(config->subject, "Disk Quota usage on system", (size_t )2048);
#line 714
  sstrncpy(config->cc_to, "root", (size_t )2048);
#line 715
  sstrncpy(config->support, "support@localhost", (size_t )2048);
#line 716
  sstrncpy(config->phone, "(xxx) xxx-xxxx or (yyy) yyy-yyyy", (size_t )2048);
#line 717
  config->charset[0] = (char )'\000';
#line 718
  maildev[0] = (char)0;
#line 719
  tmp___1 = (char *)((void *)0);
#line 719
  config->group_message = tmp___1;
#line 719
  tmp___0 = tmp___1;
#line 719
  config->group_signature = tmp___0;
#line 719
  tmp = tmp___0;
#line 719
  config->user_message = tmp;
#line 719
  config->user_signature = tmp;
#line 720
  config->use_ldap_mail = 0;
#line 721
  config->cc_before = (time_t )-1;
#line 729
  fp = fopen((char const   */* __restrict  */)filename, (char const   */* __restrict  */)"r");
  }
#line 729
  if (! fp) {
    {
#line 730
    tmp___2 = __errno_location();
#line 730
    tmp___3 = strerror(*tmp___2);
#line 730
    tmp___4 = gettext("Cannot open %s: %s\n");
#line 730
    errstr(tmp___4, filename, tmp___3);
    }
#line 731
    return (-1);
  }
#line 734
  line___0 = 0;
#line 735
  bufpos = 0;
  {
#line 736
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 736
    tmp___28 = fgets((char */* __restrict  */)(buff + bufpos), (int )(sizeof(buff) - (unsigned long )bufpos),
                     (FILE */* __restrict  */)fp);
    }
#line 736
    if (! tmp___28) {
#line 736
      goto while_break;
    }
#line 737
    line___0 ++;
#line 739
    if (! bufpos) {
#line 741
      if ((int )buff[0] == 35) {
#line 742
        goto while_continue;
      } else
#line 741
      if ((int )buff[0] == 59) {
#line 742
        goto while_continue;
      }
#line 744
      pos = buff;
      {
#line 744
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 744
        tmp___5 = __ctype_b_loc();
        }
#line 744
        if (! ((int const   )*(*tmp___5 + (int )*pos) & 8192)) {
#line 744
          goto while_break___0;
        }
#line 744
        pos ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 745
      if (! *pos) {
#line 746
        goto while_continue;
      }
    }
    {
#line 748
    tmp___6 = strlen((char const   *)(buff + bufpos));
#line 748
    len = (int )((size_t )bufpos + tmp___6);
    }
#line 749
    if ((int )buff[len - 1] != 10) {
      {
#line 750
      tmp___7 = gettext("Line %d too long. Truncating.\n");
#line 750
      errstr(tmp___7, line___0);
      }
    } else {
#line 752
      len --;
#line 753
      if ((int )buff[len - 1] == 92) {
#line 754
        bufpos = len - 1;
#line 755
        goto while_continue;
      }
    }
    {
#line 758
    buff[len] = (char)0;
#line 759
    bufpos = 0;
#line 762
    pos = strchr((char const   *)(buff), '=');
    }
#line 762
    if (pos) {
      {
#line 763
      *pos = (char)0;
#line 764
      var = buff;
#line 765
      value = pos + 1;
#line 767
      stripstring(& var);
#line 768
      stripstring(& value);
#line 771
      tmp___26 = strcmp((char const   *)var, "MAIL_CMD");
      }
#line 771
      if (tmp___26) {
        {
#line 773
        tmp___25 = strcmp((char const   *)var, "FROM");
        }
#line 773
        if (tmp___25) {
          {
#line 775
          tmp___24 = strcmp((char const   *)var, "SUBJECT");
          }
#line 775
          if (tmp___24) {
            {
#line 777
            tmp___23 = strcmp((char const   *)var, "CC_TO");
            }
#line 777
            if (tmp___23) {
              {
#line 779
              tmp___22 = strcmp((char const   *)var, "SUPPORT");
              }
#line 779
              if (tmp___22) {
                {
#line 781
                tmp___21 = strcmp((char const   *)var, "PHONE");
                }
#line 781
                if (tmp___21) {
                  {
#line 783
                  tmp___20 = strcmp((char const   *)var, "CHARSET");
                  }
#line 783
                  if (tmp___20) {
                    {
#line 785
                    tmp___19 = strcmp((char const   *)var, "MAILDEV");
                    }
#line 785
                    if (tmp___19) {
                      {
#line 788
                      tmp___18 = strcmp((char const   *)var, "MESSAGE");
                      }
#line 788
                      if (tmp___18) {
                        {
#line 793
                        tmp___17 = strcmp((char const   *)var, "SIGNATURE");
                        }
#line 793
                        if (tmp___17) {
                          {
#line 798
                          tmp___16 = strcmp((char const   *)var, "GROUP_MESSAGE");
                          }
#line 798
                          if (tmp___16) {
                            {
#line 803
                            tmp___15 = strcmp((char const   *)var, "GROUP_SIGNATURE");
                            }
#line 803
                            if (tmp___15) {
                              {
#line 808
                              tmp___14 = strcmp((char const   *)var, "LDAP_MAIL");
                              }
#line 808
                              if (tmp___14) {
                                {
#line 814
                                tmp___13 = strcmp((char const   *)var, "CC_BEFORE");
                                }
#line 814
                                if (tmp___13) {
                                  {
#line 846
                                  tmp___12 = gettext("Error in config file (line %d), ignoring\n");
#line 846
                                  errstr(tmp___12, line___0);
                                  }
                                } else {
                                  {
#line 818
                                  tmp___9 = sscanf((char const   */* __restrict  */)value,
                                                   (char const   */* __restrict  */)"%d%s",
                                                   & num, unit);
                                  }
#line 818
                                  if (tmp___9 != 2) {
#line 819
                                    goto cc_parse_err;
                                  }
                                  {
#line 820
                                  tmp___11 = str2timeunits((time_t )num, unit, & config->cc_before);
                                  }
#line 820
                                  if (tmp___11 < 0) {
                                    cc_parse_err: 
                                    {
#line 822
                                    tmp___10 = gettext("Cannot parse time at CC_BEFORE variable (line %d).\n");
#line 822
                                    die(1, tmp___10, line___0);
                                    }
                                  }
                                }
                              } else {
                                {
#line 809
                                tmp___8 = strcasecmp((char const   *)value, "true");
                                }
#line 809
                                if (tmp___8 == 0) {
#line 810
                                  config->use_ldap_mail = 1;
                                } else {
#line 812
                                  config->use_ldap_mail = 0;
                                }
                              }
                            } else {
                              {
#line 804
                              config->group_signature = sstrdup((char const   *)value);
#line 805
                              create_eoln(config->group_signature);
#line 806
                              verify_format(config->group_signature, (char *)"GROUP_SIGNATURE");
                              }
                            }
                          } else {
                            {
#line 799
                            config->group_message = sstrdup((char const   *)value);
#line 800
                            create_eoln(config->group_message);
#line 801
                            verify_format(config->group_message, (char *)"GROUP_MESSAGE");
                            }
                          }
                        } else {
                          {
#line 794
                          config->user_signature = sstrdup((char const   *)value);
#line 795
                          create_eoln(config->user_signature);
#line 796
                          verify_format(config->user_signature, (char *)"SIGNATURE");
                          }
                        }
                      } else {
                        {
#line 789
                        config->user_message = sstrdup((char const   *)value);
#line 790
                        create_eoln(config->user_message);
#line 791
                        verify_format(config->user_message, (char *)"MESSAGE");
                        }
                      }
                    } else {
                      {
#line 787
                      sstrncpy(maildev, (char const   *)value, (size_t )2048);
                      }
                    }
                  } else {
                    {
#line 784
                    sstrncpy(config->charset, (char const   *)value, (size_t )2048);
                    }
                  }
                } else {
                  {
#line 782
                  sstrncpy(config->phone, (char const   *)value, (size_t )2048);
                  }
                }
              } else {
                {
#line 780
                sstrncpy(config->support, (char const   *)value, (size_t )2048);
                }
              }
            } else {
              {
#line 778
              sstrncpy(config->cc_to, (char const   *)value, (size_t )2048);
              }
            }
          } else {
            {
#line 776
            sstrncpy(config->subject, (char const   *)value, (size_t )2048);
            }
          }
        } else {
          {
#line 774
          sstrncpy(config->from, (char const   *)value, (size_t )2048);
          }
        }
      } else {
        {
#line 772
        sstrncpy(config->mail_cmd, (char const   *)value, (size_t )2048);
        }
      }
    } else {
      {
#line 849
      tmp___27 = gettext("Possible error in config file (line %d), ignoring\n");
#line 849
      errstr(tmp___27, line___0);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 851
  if (bufpos) {
    {
#line 852
    tmp___29 = gettext("Unterminated last line, ignoring\n");
#line 852
    errstr(tmp___29);
    }
  }
  {
#line 867
  fclose(fp);
  }
#line 869
  return (0);
}
}
#line 872 "/home/wheatley/newnew/temp/quota-4.01/warnquota.c"
static int admin_cmp(void const   *a1 , void const   *a2 ) 
{ 
  int tmp ;

  {
  {
#line 874
  tmp = strcmp((char const   *)((struct adminstable *)a1)->grpname, (char const   *)((struct adminstable *)a2)->grpname);
  }
#line 874
  return (tmp);
}
}
#line 878 "/home/wheatley/newnew/temp/quota-4.01/warnquota.c"
static int get_groupadmins(void) 
{ 
  FILE *f ;
  int line___0 ;
  char buffer[16384] ;
  char *colpos ;
  char *grouppos ;
  char *endname ;
  char *adminpos ;
  int *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  unsigned short const   **tmp___2 ;
  char *tmp___3 ;
  unsigned short const   **tmp___4 ;
  unsigned short const   **tmp___5 ;
  char *tmp___6 ;
  unsigned short const   **tmp___7 ;
  unsigned short const   **tmp___8 ;
  char *tmp___9 ;
  void *tmp___10 ;
  int tmp___11 ;
  char *tmp___12 ;

  {
  {
#line 881
  line___0 = 0;
#line 884
  f = fopen((char const   */* __restrict  */)adminsfile, (char const   */* __restrict  */)"r");
  }
#line 884
  if (! f) {
    {
#line 885
    tmp = __errno_location();
#line 885
    tmp___0 = strerror(*tmp);
#line 885
    tmp___1 = gettext("Cannot open file with group administrators: %s\n");
#line 885
    errstr(tmp___1, tmp___0);
    }
#line 886
    return (-1);
  }
  {
#line 889
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 889
    tmp___12 = fgets((char */* __restrict  */)(buffer), 16384, (FILE */* __restrict  */)f);
    }
#line 889
    if (! tmp___12) {
#line 889
      goto while_break;
    }
#line 890
    line___0 ++;
#line 891
    if ((int )buffer[0] == 59) {
#line 892
      goto while_continue;
    } else
#line 891
    if ((int )buffer[0] == 35) {
#line 892
      goto while_continue;
    }
#line 894
    colpos = buffer;
    {
#line 894
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 894
      tmp___2 = __ctype_b_loc();
      }
#line 894
      if (! ((int const   )*(*tmp___2 + (int )*colpos) & 8192)) {
#line 894
        goto while_break___0;
      }
#line 894
      colpos ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 895
    if (! *colpos) {
#line 896
      goto while_continue;
    }
#line 898
    grouppos = colpos;
    {
#line 898
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 898
      if (*colpos) {
#line 898
        if (! ((int )*colpos != 58)) {
#line 898
          goto while_break___1;
        }
      } else {
#line 898
        goto while_break___1;
      }
#line 898
      colpos ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 899
    if (! *colpos) {
      {
#line 900
      tmp___3 = gettext("Parse error at line %d. Cannot find end of group name.\n");
#line 900
      errstr(tmp___3, line___0);
      }
#line 901
      goto while_continue;
    } else
#line 899
    if ((unsigned long )grouppos == (unsigned long )colpos) {
      {
#line 900
      tmp___3 = gettext("Parse error at line %d. Cannot find end of group name.\n");
#line 900
      errstr(tmp___3, line___0);
      }
#line 901
      goto while_continue;
    }
#line 904
    endname = colpos - 1;
    {
#line 904
    while (1) {
      while_continue___2: /* CIL Label */ ;
      {
#line 904
      tmp___4 = __ctype_b_loc();
      }
#line 904
      if (! ((int const   )*(*tmp___4 + (int )*endname) & 8192)) {
#line 904
        goto while_break___2;
      }
#line 904
      endname --;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 905
    endname ++;
#line 905
    *endname = (char)0;
#line 907
    colpos ++;
    {
#line 907
    while (1) {
      while_continue___3: /* CIL Label */ ;
      {
#line 907
      tmp___5 = __ctype_b_loc();
      }
#line 907
      if (! ((int const   )*(*tmp___5 + (int )*colpos) & 8192)) {
#line 907
        goto while_break___3;
      }
#line 907
      colpos ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 908
    if (! *colpos) {
      {
#line 909
      tmp___6 = gettext("Parse error at line %d. Cannot find administrators name.\n");
#line 909
      errstr(tmp___6, line___0);
      }
#line 910
      goto while_continue;
    }
#line 913
    adminpos = colpos;
    {
#line 913
    while (1) {
      while_continue___4: /* CIL Label */ ;
      {
#line 913
      tmp___7 = __ctype_b_loc();
      }
#line 913
      if ((int const   )*(*tmp___7 + (int )*colpos) & 8192) {
#line 913
        goto while_break___4;
      }
#line 913
      colpos ++;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 914
    if (*colpos) {
#line 915
      *colpos = (char)0;
#line 917
      colpos ++;
      {
#line 917
      while (1) {
        while_continue___5: /* CIL Label */ ;
        {
#line 917
        tmp___8 = __ctype_b_loc();
        }
#line 917
        if (! ((int const   )*(*tmp___8 + (int )*colpos) & 8192)) {
#line 917
          goto while_break___5;
        }
#line 917
        colpos ++;
      }
      while_break___5: /* CIL Label */ ;
      }
#line 918
      if (*colpos) {
        {
#line 919
        tmp___9 = gettext("Parse error at line %d. Trailing characters after administrators name.\n");
#line 919
        errstr(tmp___9, line___0);
        }
#line 920
        goto while_continue;
      }
    }
#line 923
    if (adminscnt >= adminsalloc) {
      {
#line 924
      adminsalloc += 256;
#line 924
      tmp___10 = srealloc((void *)adminstable, sizeof(struct adminstable ) * (unsigned long )adminsalloc);
#line 924
      adminstable = (struct adminstable *)tmp___10;
      }
    }
    {
#line 925
    (adminstable + adminscnt)->grpname = sstrdup((char const   *)grouppos);
#line 926
    tmp___11 = adminscnt;
#line 926
    adminscnt ++;
#line 926
    (adminstable + tmp___11)->adminname = sstrdup((char const   *)adminpos);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 929
  fclose(f);
#line 930
  qsort((void *)adminstable, (size_t )adminscnt, sizeof(struct adminstable ), & admin_cmp);
  }
#line 931
  return (0);
}
}
#line 934 "/home/wheatley/newnew/temp/quota-4.01/warnquota.c"
static struct quota_handle *find_handle_dev(char *dev , struct quota_handle **handles ) 
{ 
  int i ;
  int tmp ;

  {
#line 938
  i = 0;
  {
#line 938
  while (1) {
    while_continue: /* CIL Label */ ;
#line 938
    if (*(handles + i)) {
      {
#line 938
      tmp = strcmp((char const   *)dev, (char const   *)((*(handles + i))->qh_quotadev));
      }
#line 938
      if (! tmp) {
#line 938
        goto while_break;
      }
    } else {
#line 938
      goto while_break;
    }
#line 938
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 939
  return (*(handles + i));
}
}
#line 942 "/home/wheatley/newnew/temp/quota-4.01/warnquota.c"
static void warn_quota(int fs_count , char **fs ) 
{ 
  struct quota_handle **handles ;
  struct configparams config ;
  int i ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
  {
#line 948
  tmp = readconfigfile((char const   *)configfile, & config);
  }
#line 948
  if (tmp < 0) {
    {
#line 949
    wc_exit(1);
    }
  }
  {
#line 950
  tmp___0 = get_quotatable();
  }
#line 950
  if (tmp___0 < 0) {
    {
#line 951
    wc_exit(1);
    }
  }
#line 953
  if (flags___2 & 1) {
#line 954
    if (flags___2 & 4) {
#line 954
      tmp___1 = 2;
    } else {
#line 954
      tmp___1 = 0;
    }
    {
#line 954
    handles = create_handle_list(fs_count, fs, 0, -1, 3, 8 | tmp___1);
    }
#line 955
    if (! maildev[0]) {
#line 956
      maildev_handle = (struct quota_handle *)((void *)0);
    } else {
      {
#line 955
      tmp___2 = strcasecmp((char const   *)(maildev), "any");
      }
#line 955
      if (tmp___2) {
        {
#line 958
        maildev_handle = find_handle_dev(maildev, handles);
        }
      } else {
#line 956
        maildev_handle = (struct quota_handle *)((void *)0);
      }
    }
#line 959
    i = 0;
    {
#line 959
    while (1) {
      while_continue: /* CIL Label */ ;
#line 959
      if (! *(handles + i)) {
#line 959
        goto while_break;
      }
      {
#line 960
      (*(((*(handles + i))->qh_ops)->scan_dquots))(*(handles + i), & check_offence);
#line 959
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 961
    dispose_handle_list(handles);
    }
  }
#line 963
  if (flags___2 & 2) {
    {
#line 964
    tmp___3 = get_groupadmins();
    }
#line 964
    if (tmp___3 < 0) {
      {
#line 965
      wc_exit(1);
      }
    }
#line 966
    if (flags___2 & 4) {
#line 966
      tmp___4 = 2;
    } else {
#line 966
      tmp___4 = 0;
    }
    {
#line 966
    handles = create_handle_list(fs_count, fs, 1, -1, 3, 8 | tmp___4);
    }
#line 967
    if (! maildev[0]) {
#line 968
      maildev_handle = (struct quota_handle *)((void *)0);
    } else {
      {
#line 967
      tmp___5 = strcasecmp((char const   *)(maildev), "any");
      }
#line 967
      if (tmp___5) {
        {
#line 970
        maildev_handle = find_handle_dev(maildev, handles);
        }
      } else {
#line 968
        maildev_handle = (struct quota_handle *)((void *)0);
      }
    }
#line 971
    i = 0;
    {
#line 971
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 971
      if (! *(handles + i)) {
#line 971
        goto while_break___0;
      }
      {
#line 972
      (*(((*(handles + i))->qh_ops)->scan_dquots))(*(handles + i), & check_offence);
#line 971
      i ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 973
    dispose_handle_list(handles);
    }
  }
  {
#line 975
  tmp___6 = mail_to_offenders(& config);
  }
#line 975
  if (tmp___6 < 0) {
    {
#line 976
    wc_exit(1);
    }
  }
#line 977
  return;
}
}
#line 980 "/home/wheatley/newnew/temp/quota-4.01/warnquota.c"
static void usage___2(void) 
{ 
  char *tmp ;
  char *tmp___0 ;

  {
  {
#line 982
  tmp = gettext("Usage:\n  warnquota [-ugsid] [-F quotaformat] [-c configfile] [-q quotatabfile] [-a adminsfile] [filesystem...]\n\n-u, --user                      warn users\n-g, --group                     warn groups\n-s, --human-readable            send information in more human friendly units\n-i, --no-autofs                 avoid autofs mountpoints\n-d, --no-details                do not send quota information itself\n-F, --format=formatname         use quotafiles of specific format\n-c, --config=config-file        non-default config file\n-q, --quota-tab=quotatab-file   non-default quotatab\n-a, --admins-file=admins-file   non-default admins file\n-h, --help                      display this help message and exit\n-v, --version                   display version information and exit\n\n");
#line 982
  errstr(tmp);
#line 994
  tmp___0 = gettext("Bugs to %s\n");
#line 994
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___0,
          "jack@suse.cz");
#line 995
  wc_exit(1);
  }
#line 996
  return;
}
}
#line 998 "/home/wheatley/newnew/temp/quota-4.01/warnquota.c"
static void parse_options___1(int argcnt , char **argstr ) 
{ 
  int ret ;
  struct option long_opts[12] ;

  {
#line 1001
  long_opts[0].name = "user";
#line 1001
  long_opts[0].has_arg = 0;
#line 1001
  long_opts[0].flag = (int *)((void *)0);
#line 1001
  long_opts[0].val = 'u';
#line 1001
  long_opts[1].name = "group";
#line 1001
  long_opts[1].has_arg = 0;
#line 1001
  long_opts[1].flag = (int *)((void *)0);
#line 1001
  long_opts[1].val = 'g';
#line 1001
  long_opts[2].name = "version";
#line 1001
  long_opts[2].has_arg = 0;
#line 1001
  long_opts[2].flag = (int *)((void *)0);
#line 1001
  long_opts[2].val = 'V';
#line 1001
  long_opts[3].name = "help";
#line 1001
  long_opts[3].has_arg = 0;
#line 1001
  long_opts[3].flag = (int *)((void *)0);
#line 1001
  long_opts[3].val = 'h';
#line 1001
  long_opts[4].name = "format";
#line 1001
  long_opts[4].has_arg = 1;
#line 1001
  long_opts[4].flag = (int *)((void *)0);
#line 1001
  long_opts[4].val = 'F';
#line 1001
  long_opts[5].name = "config";
#line 1001
  long_opts[5].has_arg = 1;
#line 1001
  long_opts[5].flag = (int *)((void *)0);
#line 1001
  long_opts[5].val = 'c';
#line 1001
  long_opts[6].name = "quota-tab";
#line 1001
  long_opts[6].has_arg = 1;
#line 1001
  long_opts[6].flag = (int *)((void *)0);
#line 1001
  long_opts[6].val = 'q';
#line 1001
  long_opts[7].name = "admins-file";
#line 1001
  long_opts[7].has_arg = 1;
#line 1001
  long_opts[7].flag = (int *)((void *)0);
#line 1001
  long_opts[7].val = 'a';
#line 1001
  long_opts[8].name = "no-autofs";
#line 1001
  long_opts[8].has_arg = 0;
#line 1001
  long_opts[8].flag = (int *)((void *)0);
#line 1001
  long_opts[8].val = 'i';
#line 1001
  long_opts[9].name = "human-readable";
#line 1001
  long_opts[9].has_arg = 0;
#line 1001
  long_opts[9].flag = (int *)((void *)0);
#line 1001
  long_opts[9].val = 's';
#line 1001
  long_opts[10].name = "no-details";
#line 1001
  long_opts[10].has_arg = 0;
#line 1001
  long_opts[10].flag = (int *)((void *)0);
#line 1001
  long_opts[10].val = 'd';
#line 1001
  long_opts[11].name = (char const   *)((void *)0);
#line 1001
  long_opts[11].has_arg = 0;
#line 1001
  long_opts[11].flag = (int *)((void *)0);
#line 1001
  long_opts[11].val = 0;
  {
#line 1016
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1016
    ret = getopt_long(argcnt, (char * const  *)argstr, "ugVF:hc:q:a:isd", (struct option  const  *)(long_opts),
                      (int *)((void *)0));
    }
#line 1016
    if (! (ret != -1)) {
#line 1016
      goto while_break;
    }
    {
#line 1019
    if (ret == 104) {
#line 1019
      goto case_104;
    }
#line 1019
    if (ret == 63) {
#line 1019
      goto case_104;
    }
#line 1021
    if (ret == 86) {
#line 1021
      goto case_86;
    }
#line 1024
    if (ret == 70) {
#line 1024
      goto case_70;
    }
#line 1028
    if (ret == 99) {
#line 1028
      goto case_99;
    }
#line 1031
    if (ret == 113) {
#line 1031
      goto case_113;
    }
#line 1034
    if (ret == 97) {
#line 1034
      goto case_97;
    }
#line 1037
    if (ret == 117) {
#line 1037
      goto case_117;
    }
#line 1040
    if (ret == 103) {
#line 1040
      goto case_103;
    }
#line 1043
    if (ret == 105) {
#line 1043
      goto case_105;
    }
#line 1046
    if (ret == 115) {
#line 1046
      goto case_115;
    }
#line 1049
    if (ret == 100) {
#line 1049
      goto case_100;
    }
#line 1017
    goto switch_break;
    case_104: /* CIL Label */ 
    case_63: /* CIL Label */ 
    {
#line 1020
    usage___2();
    }
    case_86: /* CIL Label */ 
    {
#line 1022
    version();
#line 1023
    exit(0);
    }
    case_70: /* CIL Label */ 
    {
#line 1025
    fmt___2 = name2fmt(optarg);
    }
#line 1025
    if (fmt___2 == -1) {
      {
#line 1026
      wc_exit(1);
      }
    }
#line 1027
    goto switch_break;
    case_99: /* CIL Label */ 
#line 1029
    configfile = optarg;
#line 1030
    goto switch_break;
    case_113: /* CIL Label */ 
#line 1032
    quotatabfile = optarg;
#line 1033
    goto switch_break;
    case_97: /* CIL Label */ 
#line 1035
    adminsfile = optarg;
#line 1036
    goto switch_break;
    case_117: /* CIL Label */ 
#line 1038
    flags___2 |= 1;
#line 1039
    goto switch_break;
    case_103: /* CIL Label */ 
#line 1041
    flags___2 |= 2;
#line 1042
    goto switch_break;
    case_105: /* CIL Label */ 
#line 1044
    flags___2 |= 4;
#line 1045
    goto switch_break;
    case_115: /* CIL Label */ 
#line 1047
    flags___2 |= 8;
#line 1048
    goto switch_break;
    case_100: /* CIL Label */ 
#line 1050
    flags___2 |= 16;
#line 1051
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1054
  if (! (flags___2 & 1)) {
#line 1054
    if (! (flags___2 & 2)) {
#line 1055
      flags___2 |= 1;
    }
  }
#line 1056
  return;
}
}
#line 1058 "/home/wheatley/newnew/temp/quota-4.01/warnquota.c"
static void get_host_name(void) 
{ 
  struct utsname uts ;
  int *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 1062
  tmp___2 = uname(& uts);
  }
#line 1062
  if (tmp___2) {
    {
#line 1063
    tmp = __errno_location();
#line 1063
    tmp___0 = strerror(*tmp);
#line 1063
    tmp___1 = gettext("Cannot get host name: %s\n");
#line 1063
    die(1, tmp___1, tmp___0);
    }
  }
  {
#line 1064
  hostname = sstrdup((char const   *)(uts.nodename));
#line 1065
  domainname = sstrdup((char const   *)(uts.domainname));
  }
#line 1066
  return;
}
}
#line 19 "/home/wheatley/newnew/temp/quota-4.01/quotaio_meta.c"
static int meta_init_io___2(struct quota_handle *h ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
#line 21
  if (! (h->qh_io_flags & 1)) {
    {
#line 22
    tmp = gettext("Metadata init_io called when kernel support is not enabled.\n");
#line 22
    errstr(tmp);
    }
#line 23
    return (-1);
  }
#line 25
  if (kernel_iface != 3) {
    {
#line 26
    tmp___0 = gettext("Metadata init_io called when kernel does not support generic quota interface!\n");
#line 26
    errstr(tmp___0);
    }
#line 27
    return (-1);
  }
  {
#line 29
  tmp___1 = vfs_get_info(h);
  }
#line 29
  return (tmp___1);
}
}
#line 32 "/home/wheatley/newnew/temp/quota-4.01/quotaio_meta.c"
static int meta_write_info___2(struct quota_handle *h ) 
{ 
  int tmp ;

  {
  {
#line 34
  tmp = vfs_set_info(h, 3);
  }
#line 34
  return (tmp);
}
}
#line 37 "/home/wheatley/newnew/temp/quota-4.01/quotaio_meta.c"
static struct dquot *meta_read_dquot___2(struct quota_handle *h , qid_t id___0 ) 
{ 
  struct dquot *dquot ;
  struct dquot *tmp ;
  int tmp___0 ;

  {
  {
#line 39
  tmp = get_empty_dquot();
#line 39
  dquot = tmp;
#line 41
  dquot->dq_id = id___0;
#line 42
  dquot->dq_h = h;
#line 43
  memset((void *)(& dquot->dq_dqb), 0, sizeof(struct util_dqblk ));
#line 44
  tmp___0 = vfs_get_dquot(dquot);
  }
#line 44
  if (tmp___0 < 0) {
    {
#line 45
    free((void *)dquot);
    }
#line 46
    return ((struct dquot *)((void *)0));
  }
#line 48
  return (dquot);
}
}
#line 51 "/home/wheatley/newnew/temp/quota-4.01/quotaio_meta.c"
static int meta_commit_dquot___2(struct dquot *dquot , int flags___7 ) 
{ 
  int tmp ;

  {
  {
#line 53
  tmp = vfs_set_dquot(dquot, flags___7);
  }
#line 53
  return (tmp);
}
}
#line 56 "/home/wheatley/newnew/temp/quota-4.01/quotaio_meta.c"
static int meta_scan_dquots___2(struct quota_handle *h , int (*process_dquot)(struct dquot *dquot ,
                                                                              char *dqname ) ) 
{ 
  int tmp ;

  {
  {
#line 58
  tmp = generic_scan_dquots(h, process_dquot, & vfs_get_dquot);
  }
#line 58
  return (tmp);
}
}
#line 27 "/home/wheatley/newnew/temp/quota-4.01/quotaio_xfs.c"
static int xfs_init_io___2(struct quota_handle *h ) ;
#line 28
static int xfs_write_info___2(struct quota_handle *h ) ;
#line 29
static struct dquot *xfs_read_dquot___2(struct quota_handle *h , qid_t id___0 ) ;
#line 30
static int xfs_commit_dquot___2(struct dquot *dquot , int flags___7 ) ;
#line 31
static int xfs_scan_dquots___2(struct quota_handle *h , int (*process_dquot)(struct dquot *dquot ,
                                                                             char *dqname ) ) ;
#line 32
static int xfs_report___2(struct quota_handle *h , int verbose ) ;
#line 77 "/home/wheatley/newnew/temp/quota-4.01/quotaio_xfs.c"
static int xfs_init_io___2(struct quota_handle *h ) 
{ 
  struct fs_quota_stat info ;
  int qcmd ;
  long tmp ;

  {
  {
#line 82
  qcmd = ((88 << 8) + 5) << 8;
#line 83
  memset((void *)(& info), 0, sizeof(struct fs_quota_stat ));
#line 84
  tmp = quotactl(qcmd, (char const   *)(h->qh_quotadev), (qid_t )0, (caddr_t )((void *)(& info)));
  }
#line 84
  if (tmp < 0L) {
#line 85
    return (-1);
  }
#line 86
  h->qh_info.dqi_bgrace = (time_t )info.qs_btimelimit;
#line 87
  h->qh_info.dqi_igrace = (time_t )info.qs_itimelimit;
#line 88
  h->qh_info.u.xfs_mdqi = info;
#line 89
  return (0);
}
}
#line 95 "/home/wheatley/newnew/temp/quota-4.01/quotaio_xfs.c"
static int xfs_write_info___2(struct quota_handle *h ) 
{ 
  struct fs_disk_quota xdqblk ;
  int qcmd ;
  long tmp ;

  {
#line 100
  if (h->qh_type == 0) {
#line 100
    if (! ((int )h->qh_info.u.xfs_mdqi.qs_flags & 1)) {
#line 100
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 100
  if (h->qh_type == 1) {
#line 100
    if (! ((int )h->qh_info.u.xfs_mdqi.qs_flags & (1 << 2))) {
#line 101
      return (0);
    }
  } else {
#line 101
    return (0);
  }
  {
#line 103
  memset((void *)(& xdqblk), 0, sizeof(struct fs_disk_quota ));
#line 105
  xdqblk.d_btimer = (__s32 )h->qh_info.dqi_bgrace;
#line 106
  xdqblk.d_itimer = (__s32 )h->qh_info.dqi_igrace;
#line 107
  xdqblk.d_fieldmask = (__u16 )((int )xdqblk.d_fieldmask | (((1 << 6) | (1 << 7)) | (1 << 8)));
#line 108
  qcmd = (((88 << 8) + 4) << 8) | (h->qh_type & 255);
#line 109
  tmp = quotactl(qcmd, (char const   *)(h->qh_quotadev), (qid_t )0, (caddr_t )((void *)(& xdqblk)));
  }
#line 109
  if (tmp < 0L) {
#line 110
    return (-1);
  }
#line 111
  return (0);
}
}
#line 117 "/home/wheatley/newnew/temp/quota-4.01/quotaio_xfs.c"
static struct dquot *xfs_read_dquot___2(struct quota_handle *h , qid_t id___0 ) 
{ 
  struct dquot *dquot ;
  struct dquot *tmp ;
  struct fs_disk_quota xdqblk ;
  int qcmd ;
  long tmp___0 ;

  {
  {
#line 119
  tmp = get_empty_dquot();
#line 119
  dquot = tmp;
#line 123
  dquot->dq_id = id___0;
#line 124
  dquot->dq_h = h;
  }
#line 126
  if (h->qh_type == 0) {
#line 126
    if (! ((int )h->qh_info.u.xfs_mdqi.qs_flags & 1)) {
#line 126
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 126
  if (h->qh_type == 1) {
#line 126
    if (! ((int )h->qh_info.u.xfs_mdqi.qs_flags & (1 << 2))) {
#line 127
      return (dquot);
    }
  } else {
#line 127
    return (dquot);
  }
  {
#line 129
  qcmd = (((88 << 8) + 3) << 8) | (h->qh_type & 255);
#line 130
  tmp___0 = quotactl(qcmd, (char const   *)(h->qh_quotadev), id___0, (caddr_t )((void *)(& xdqblk)));
  }
#line 130
  if (! (tmp___0 < 0L)) {
    {
#line 134
    xfs_kern2utildqblk(& dquot->dq_dqb, & xdqblk);
    }
  }
#line 136
  return (dquot);
}
}
#line 142 "/home/wheatley/newnew/temp/quota-4.01/quotaio_xfs.c"
static int xfs_commit_dquot___2(struct dquot *dquot , int flags___7 ) 
{ 
  struct quota_handle *h ;
  struct fs_disk_quota xdqblk ;
  qid_t id___0 ;
  int qcmd ;
  int tmp ;
  int tmp___0 ;
  long tmp___1 ;

  {
#line 144
  h = dquot->dq_h;
#line 146
  id___0 = dquot->dq_id;
#line 149
  if (h->qh_type == 0) {
#line 149
    if (! ((int )h->qh_info.u.xfs_mdqi.qs_flags & 1)) {
#line 149
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 149
  if (h->qh_type == 1) {
#line 149
    if (! ((int )h->qh_info.u.xfs_mdqi.qs_flags & (1 << 2))) {
#line 150
      return (0);
    }
  } else {
#line 150
    return (0);
  }
  {
#line 152
  xfs_util2kerndqblk(& xdqblk, & dquot->dq_dqb);
  }
#line 153
  if (h->qh_type == 0) {
#line 153
    if ((int )h->qh_info.u.xfs_mdqi.qs_flags & 1) {
#line 153
      tmp = 1;
    } else {
#line 153
      tmp = 1 << 2;
    }
  } else {
#line 153
    tmp = 1 << 2;
  }
  {
#line 153
  xdqblk.d_flags = (__s8 )((int )xdqblk.d_flags | tmp);
#line 154
  xdqblk.d_id = id___0;
#line 155
  tmp___0 = strcmp((char const   *)(h->qh_fstype), "gfs2");
  }
#line 155
  if (tmp___0 == 0) {
#line 156
    if (flags___7 & 5) {
#line 157
      xdqblk.d_fieldmask = (__u16 )((int )xdqblk.d_fieldmask | ((1 << 2) | (1 << 3)));
    }
#line 158
    if (flags___7 & 10) {
#line 159
      xdqblk.d_fieldmask = (__u16 )((int )xdqblk.d_fieldmask | (1 << 12));
    }
  } else {
#line 161
    xdqblk.d_fieldmask = (__u16 )((int )xdqblk.d_fieldmask | (((((1 | (1 << 1)) | (1 << 2)) | (1 << 3)) | (1 << 4)) | (1 << 5)));
  }
  {
#line 164
  qcmd = (((88 << 8) + 4) << 8) | (h->qh_type & 255);
#line 165
  tmp___1 = quotactl(qcmd, (char const   *)(h->qh_quotadev), id___0, (caddr_t )((void *)(& xdqblk)));
  }
#line 165
  if (! (tmp___1 < 0L)) {
#line 169
    return (0);
  }
#line 171
  return (-1);
}
}
#line 177 "/home/wheatley/newnew/temp/quota-4.01/quotaio_xfs.c"
static int xfs_get_dquot___2(struct dquot *dq ) 
{ 
  struct fs_disk_quota d ;
  int qcmd ;
  int ret ;
  long tmp ;
  int *tmp___0 ;

  {
  {
#line 180
  qcmd = (((88 << 8) + 3) << 8) | ((dq->dq_h)->qh_type & 255);
#line 183
  memset((void *)(& d), 0, sizeof(d));
#line 184
  tmp = quotactl(qcmd, (char const   *)((dq->dq_h)->qh_quotadev), dq->dq_id, (caddr_t )((void *)(& d)));
#line 184
  ret = (int )tmp;
  }
#line 185
  if (ret < 0) {
    {
#line 186
    tmp___0 = __errno_location();
    }
#line 186
    if (*tmp___0 == 2) {
#line 187
      return (0);
    }
#line 188
    return (-1);
  }
  {
#line 190
  xfs_kern2utildqblk(& dq->dq_dqb, & d);
  }
#line 191
  return (0);
}
}
#line 197 "/home/wheatley/newnew/temp/quota-4.01/quotaio_xfs.c"
static int xfs_scan_dquots___2(struct quota_handle *h , int (*process_dquot)(struct dquot *dquot ,
                                                                             char *dqname ) ) 
{ 
  int tmp ;

  {
#line 199
  if (h->qh_type == 0) {
#line 199
    if (! ((int )h->qh_info.u.xfs_mdqi.qs_flags & 1)) {
#line 199
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 199
  if (h->qh_type == 1) {
#line 199
    if (! ((int )h->qh_info.u.xfs_mdqi.qs_flags & (1 << 2))) {
#line 200
      return (0);
    }
  } else {
#line 200
    return (0);
  }
  {
#line 202
  tmp = generic_scan_dquots(h, process_dquot, & xfs_get_dquot___2);
  }
#line 202
  return (tmp);
}
}
#line 208 "/home/wheatley/newnew/temp/quota-4.01/quotaio_xfs.c"
static int xfs_report___2(struct quota_handle *h , int verbose ) 
{ 
  u_int16_t sbflags ;
  struct fs_quota_stat *info ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;
  char *tmp___18 ;
  char *tmp___19 ;
  char *tmp___20 ;
  char *tmp___21 ;
  char *tmp___22 ;
  char *tmp___23 ;
  char *tmp___24 ;
  char *tmp___25 ;
  char *tmp___26 ;
  char *tmp___27 ;
  char *tmp___28 ;
  char *tmp___29 ;
  char *tmp___30 ;
  char *tmp___31 ;
  char *tmp___32 ;

  {
#line 211
  info = & h->qh_info.u.xfs_mdqi;
#line 213
  if (! verbose) {
#line 214
    return (0);
  }
  {
#line 217
  tmp = type2name(h->qh_type);
#line 217
  tmp___0 = gettext("*** Status for %s quotas on device %s\n");
#line 217
  printf((char const   */* __restrict  */)tmp___0, tmp, h->qh_quotadev);
  }
#line 220
  if (h->qh_type == 0) {
#line 221
    if ((int )info->qs_flags & (1 << 1)) {
      {
#line 221
      tmp___1 = gettext("ON");
#line 221
      tmp___3 = tmp___1;
      }
    } else {
      {
#line 221
      tmp___2 = gettext("OFF");
#line 221
      tmp___3 = tmp___2;
      }
    }
#line 221
    if ((int )info->qs_flags & 1) {
      {
#line 221
      tmp___4 = gettext("ON");
#line 221
      tmp___6 = tmp___4;
      }
    } else {
      {
#line 221
      tmp___5 = gettext("OFF");
#line 221
      tmp___6 = tmp___5;
      }
    }
    {
#line 221
    tmp___7 = gettext("Accounting: %s; Enforcement: %s\n");
#line 221
    printf((char const   */* __restrict  */)tmp___7, tmp___6, tmp___3);
    }
  } else {
#line 225
    if ((int )info->qs_flags & (1 << 3)) {
      {
#line 225
      tmp___8 = gettext("ON");
#line 225
      tmp___10 = tmp___8;
      }
    } else {
      {
#line 225
      tmp___9 = gettext("OFF");
#line 225
      tmp___10 = tmp___9;
      }
    }
#line 225
    if ((int )info->qs_flags & (1 << 2)) {
      {
#line 225
      tmp___11 = gettext("ON");
#line 225
      tmp___13 = tmp___11;
      }
    } else {
      {
#line 225
      tmp___12 = gettext("OFF");
#line 225
      tmp___13 = tmp___12;
      }
    }
    {
#line 225
    tmp___14 = gettext("Accounting: %s; Enforcement: %s\n");
#line 225
    printf((char const   */* __restrict  */)tmp___14, tmp___13, tmp___10);
    }
  }
#line 235
  sbflags = (u_int16_t )(((int )info->qs_flags & 65280) >> 8);
#line 235
  if ((int )sbflags != 0) {
#line 236
    if (h->qh_type == 0) {
#line 237
      if ((int )sbflags & (1 << 1)) {
        {
#line 237
        tmp___15 = gettext("ON");
#line 237
        tmp___17 = tmp___15;
        }
      } else {
        {
#line 237
        tmp___16 = gettext("OFF");
#line 237
        tmp___17 = tmp___16;
        }
      }
#line 237
      if ((int )sbflags & 1) {
        {
#line 237
        tmp___18 = gettext("ON");
#line 237
        tmp___20 = tmp___18;
        }
      } else {
        {
#line 237
        tmp___19 = gettext("OFF");
#line 237
        tmp___20 = tmp___19;
        }
      }
      {
#line 237
      tmp___21 = gettext("Accounting [ondisk]: %s; Enforcement [ondisk]: %s\n");
#line 237
      printf((char const   */* __restrict  */)tmp___21, tmp___20, tmp___17);
      }
    } else {
#line 241
      if ((int )sbflags & (1 << 3)) {
        {
#line 241
        tmp___22 = gettext("ON");
#line 241
        tmp___24 = tmp___22;
        }
      } else {
        {
#line 241
        tmp___23 = gettext("OFF");
#line 241
        tmp___24 = tmp___23;
        }
      }
#line 241
      if ((int )sbflags & (1 << 2)) {
        {
#line 241
        tmp___25 = gettext("ON");
#line 241
        tmp___27 = tmp___25;
        }
      } else {
        {
#line 241
        tmp___26 = gettext("OFF");
#line 241
        tmp___27 = tmp___26;
        }
      }
      {
#line 241
      tmp___28 = gettext("Accounting [ondisk]: %s; Enforcement [ondisk]: %s\n");
#line 241
      printf((char const   */* __restrict  */)tmp___28, tmp___27, tmp___24);
      }
    }
  }
#line 248
  if (h->qh_type == 0) {
#line 249
    if (info->qs_uquota.qfs_ino == 0xffffffffffffffffULL) {
      {
#line 250
      tmp___29 = gettext("Inode: none\n");
#line 250
      printf((char const   */* __restrict  */)tmp___29);
      }
    } else
#line 249
    if (info->qs_uquota.qfs_ino == 0ULL) {
      {
#line 250
      tmp___29 = gettext("Inode: none\n");
#line 250
      printf((char const   */* __restrict  */)tmp___29);
      }
    } else {
      {
#line 252
      tmp___30 = gettext("Inode: #%llu (%llu blocks, %u extents)\n");
#line 252
      printf((char const   */* __restrict  */)tmp___30, info->qs_uquota.qfs_ino, info->qs_uquota.qfs_nblks,
             info->qs_uquota.qfs_nextents);
      }
    }
  } else
#line 258
  if (info->qs_gquota.qfs_ino == 0xffffffffffffffffULL) {
    {
#line 259
    tmp___31 = gettext("Inode: none\n");
#line 259
    printf((char const   */* __restrict  */)tmp___31);
    }
  } else {
    {
#line 261
    tmp___32 = gettext("Inode: #%llu (%llu blocks, %u extents)\n");
#line 261
    printf((char const   */* __restrict  */)tmp___32, info->qs_gquota.qfs_ino, info->qs_gquota.qfs_nblks,
           info->qs_gquota.qfs_nextents);
    }
  }
#line 266
  return (0);
}
}
#line 31 "/home/wheatley/newnew/temp/quota-4.01/bylabel.c"
static struct uuidCache_s *uuidCache___2  =    (struct uuidCache_s *)((void *)0);
#line 74 "/home/wheatley/newnew/temp/quota-4.01/bylabel.c"
static int get_label_uuid___2(char const   *device , char **label , char *uuid ) 
{ 
  int fd ;
  int rv ;
  size_t namesize ;
  struct ext2_super_block e2sb ;
  struct xfs_super_block xfsb ;
  struct reiserfs_super_block reisersb ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  __off64_t tmp___2 ;
  ssize_t tmp___3 ;
  int tmp___4 ;
  __off64_t tmp___5 ;
  ssize_t tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  __off64_t tmp___9 ;
  ssize_t tmp___10 ;

  {
  {
#line 79
  rv = 1;
#line 85
  fd = open(device, 0);
  }
#line 86
  if (fd < 0) {
#line 87
    return (rv);
  }
  {
#line 89
  tmp___9 = lseek(fd, (__off64_t )1024, 0);
  }
#line 89
  if (tmp___9 == 1024L) {
    {
#line 89
    tmp___10 = read(fd, (void *)((char *)(& e2sb)), sizeof(e2sb));
    }
#line 89
    if ((unsigned long )tmp___10 == sizeof(e2sb)) {
#line 89
      if ((uint )e2sb.s_magic[0] + ((uint )e2sb.s_magic[1] << 8) == 61267U) {
        {
#line 92
        memcpy((void */* __restrict  */)uuid, (void const   */* __restrict  */)(e2sb.s_uuid),
               sizeof(e2sb.s_uuid));
#line 93
        namesize = sizeof(e2sb.s_volume_name);
#line 94
        tmp = smalloc(namesize + 1UL);
#line 94
        *label = (char *)tmp;
#line 95
        sstrncpy(*label, (char const   *)((char *)(e2sb.s_volume_name)), namesize);
#line 96
        rv = 0;
        }
      } else {
#line 89
        goto _L___3;
      }
    } else {
#line 89
      goto _L___3;
    }
  } else {
    _L___3: /* CIL Label */ 
    {
#line 98
    tmp___5 = lseek(fd, (__off64_t )0, 0);
    }
#line 98
    if (tmp___5 == 0L) {
      {
#line 98
      tmp___6 = read(fd, (void *)((char *)(& xfsb)), sizeof(xfsb));
      }
#line 98
      if ((unsigned long )tmp___6 == sizeof(xfsb)) {
        {
#line 98
        tmp___7 = strncmp((char const   *)((char *)(& xfsb.s_magic)), "XFSB", (size_t )4);
        }
#line 98
        if (tmp___7 == 0) {
#line 98
          goto _L___0;
        } else {
          {
#line 98
          tmp___8 = strncmp((char const   *)((char *)(& xfsb.s_magic)), "BSFX", (size_t )4);
          }
#line 98
          if (tmp___8 == 0) {
            _L___0: /* CIL Label */ 
            {
#line 102
            memcpy((void */* __restrict  */)uuid, (void const   */* __restrict  */)(xfsb.s_uuid),
                   sizeof(xfsb.s_uuid));
#line 103
            namesize = sizeof(xfsb.s_fsname);
#line 104
            tmp___0 = smalloc(namesize + 1UL);
#line 104
            *label = (char *)tmp___0;
#line 105
            sstrncpy(*label, (char const   *)((char *)(xfsb.s_fsname)), namesize);
#line 106
            rv = 0;
            }
          } else {
#line 98
            goto _L___1;
          }
        }
      } else {
#line 98
        goto _L___1;
      }
    } else {
      _L___1: /* CIL Label */ 
      {
#line 108
      tmp___2 = lseek(fd, (__off64_t )65536, 0);
      }
#line 108
      if (tmp___2 == 65536L) {
        {
#line 108
        tmp___3 = read(fd, (void *)((char *)(& reisersb)), sizeof(reisersb));
        }
#line 108
        if ((unsigned long )tmp___3 == sizeof(reisersb)) {
          {
#line 108
          tmp___4 = strncmp((char const   *)((char *)(& reisersb.s_magic)), "ReIsEr2Fs",
                            (size_t )9);
          }
#line 108
          if (! tmp___4) {
            {
#line 111
            memcpy((void */* __restrict  */)uuid, (void const   */* __restrict  */)(reisersb.s_uuid),
                   sizeof(reisersb.s_uuid));
#line 112
            namesize = sizeof(reisersb.s_volume_name);
#line 113
            tmp___1 = smalloc(namesize + 1UL);
#line 113
            *label = (char *)tmp___1;
#line 114
            sstrncpy(*label, (char const   *)((char *)(reisersb.s_volume_name)), namesize);
#line 115
            rv = 0;
            }
          }
        }
      }
    }
  }
  {
#line 117
  close(fd);
  }
#line 118
  return (rv);
}
}
#line 121 "/home/wheatley/newnew/temp/quota-4.01/bylabel.c"
static void uuidcache_addentry___2(char *device , char *label , char *uuid ) 
{ 
  struct uuidCache_s *last ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 125
  if (! uuidCache___2) {
    {
#line 126
    tmp = smalloc(sizeof(*uuidCache___2));
#line 126
    uuidCache___2 = (struct uuidCache_s *)tmp;
#line 126
    last = uuidCache___2;
    }
  } else {
#line 129
    last = uuidCache___2;
    {
#line 129
    while (1) {
      while_continue: /* CIL Label */ ;
#line 129
      if (! last->next) {
#line 129
        goto while_break;
      }
#line 129
      last = last->next;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 130
    tmp___0 = smalloc(sizeof(*uuidCache___2));
#line 130
    last->next = (struct uuidCache_s *)tmp___0;
#line 131
    last = last->next;
    }
  }
  {
#line 133
  last->next = (struct uuidCache_s *)((void *)0);
#line 134
  last->device = device;
#line 135
  last->label = label;
#line 136
  memcpy((void */* __restrict  */)(last->uuid), (void const   */* __restrict  */)uuid,
         sizeof(last->uuid));
  }
#line 137
  return;
}
}
#line 144 "/home/wheatley/newnew/temp/quota-4.01/bylabel.c"
static char ptname___2[100]  ;
#line 139 "/home/wheatley/newnew/temp/quota-4.01/bylabel.c"
static void uuidcache_init___2(void) 
{ 
  char line___0[100] ;
  char *s ;
  int ma ;
  int mi ;
  int sz ;
  FILE *procpt ;
  char uuid[16] ;
  char *label ;
  char device[110] ;
  int firstPass ;
  int handleOnFirst ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  unsigned short const   **tmp___4 ;
  char *tmp___5 ;

  {
#line 151
  if (uuidCache___2) {
#line 152
    return;
  }
  {
#line 154
  procpt = fopen((char const   */* __restrict  */)"/proc/partitions", (char const   */* __restrict  */)"r");
  }
#line 155
  if (! procpt) {
#line 156
    return;
  }
#line 158
  firstPass = 1;
  {
#line 158
  while (1) {
    while_continue: /* CIL Label */ ;
#line 158
    if (! (firstPass >= 0)) {
#line 158
      goto while_break;
    }
    {
#line 159
    fseek(procpt, 0L, 0);
    }
    {
#line 161
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 161
      tmp___5 = fgets((char */* __restrict  */)(line___0), (int )sizeof(line___0),
                      (FILE */* __restrict  */)procpt);
      }
#line 161
      if (! tmp___5) {
#line 161
        goto while_break___0;
      }
      {
#line 162
      tmp = sscanf((char const   */* __restrict  */)(line___0), (char const   */* __restrict  */)" %d %d %d %[^\n ]",
                   & ma, & mi, & sz, ptname___2);
      }
#line 162
      if (tmp != 4) {
#line 163
        goto while_continue___0;
      }
#line 166
      if (sz == 1) {
#line 167
        goto while_continue___0;
      }
      {
#line 170
      tmp___0 = strncmp((char const   *)(ptname___2), "md", (size_t )2);
      }
#line 170
      if (tmp___0) {
#line 170
        tmp___1 = 0;
      } else {
#line 170
        tmp___1 = 1;
      }
#line 170
      handleOnFirst = tmp___1;
#line 171
      if (firstPass != handleOnFirst) {
#line 172
        goto while_continue___0;
      }
#line 178
      s = ptname___2;
      {
#line 178
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 178
        if (! *s) {
#line 178
          goto while_break___1;
        }
#line 178
        s ++;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 179
      tmp___4 = __ctype_b_loc();
      }
#line 179
      if ((int const   )*(*tmp___4 + (int )*(s + -1)) & 2048) {
        {
#line 189
        snprintf((char */* __restrict  */)(device), sizeof(device), (char const   */* __restrict  */)"%s/%s",
                 "/dev", ptname___2);
#line 190
        tmp___3 = get_label_uuid___2((char const   *)(device), & label, uuid);
        }
#line 190
        if (! tmp___3) {
          {
#line 191
          tmp___2 = sstrdup((char const   *)(device));
#line 191
          uuidcache_addentry___2(tmp___2, label, uuid);
          }
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 158
    firstPass --;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 196
  fclose(procpt);
  }
#line 197
  return;
}
}
#line 202 "/home/wheatley/newnew/temp/quota-4.01/bylabel.c"
static char *get_spec_by_x___2(int n , char const   *t ) 
{ 
  struct uuidCache_s *uc ;
  char *tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 206
  uuidcache_init___2();
#line 207
  uc = uuidCache___2;
  }
  {
#line 209
  while (1) {
    while_continue: /* CIL Label */ ;
#line 209
    if (! uc) {
#line 209
      goto while_break;
    }
    {
#line 211
    if (n == 1) {
#line 211
      goto case_1;
    }
#line 215
    if (n == 2) {
#line 215
      goto case_2;
    }
#line 210
    goto switch_break;
    case_1: /* CIL Label */ 
    {
#line 212
    tmp___0 = memcmp((void const   *)t, (void const   *)(uc->uuid), sizeof(uc->uuid));
    }
#line 212
    if (! tmp___0) {
      {
#line 213
      tmp = sstrdup((char const   *)uc->device);
      }
#line 213
      return (tmp);
    }
#line 214
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 216
    tmp___2 = strcmp(t, (char const   *)uc->label);
    }
#line 216
    if (! tmp___2) {
      {
#line 217
      tmp___1 = sstrdup((char const   *)uc->device);
      }
#line 217
      return (tmp___1);
    }
#line 218
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 220
    uc = uc->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 222
  return ((char *)((void *)0));
}
}
#line 225 "/home/wheatley/newnew/temp/quota-4.01/bylabel.c"
static u_char fromhex___2(char c ) 
{ 
  unsigned short const   **tmp ;
  unsigned short const   **tmp___0 ;

  {
  {
#line 227
  tmp___0 = __ctype_b_loc();
  }
#line 227
  if ((int const   )*(*tmp___0 + (int )c) & 2048) {
#line 228
    return ((u_char )((int )c - 48));
  } else {
    {
#line 229
    tmp = __ctype_b_loc();
    }
#line 229
    if ((int const   )*(*tmp + (int )c) & 512) {
#line 230
      return ((u_char )(((int )c - 97) + 10));
    } else {
#line 232
      return ((u_char )(((int )c - 65) + 10));
    }
  }
}
}
#line 235 "/home/wheatley/newnew/temp/quota-4.01/bylabel.c"
static char *get_spec_by_uuid___2(char const   *s ) 
{ 
  u_char uuid[16] ;
  int i ;
  size_t tmp ;
  unsigned short const   **tmp___0 ;
  unsigned short const   **tmp___1 ;
  u_char tmp___2 ;
  u_char tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;

  {
  {
#line 240
  tmp = strlen(s);
  }
#line 240
  if (tmp != 36UL) {
#line 241
    goto bad_uuid;
  } else
#line 240
  if ((int const   )*(s + 8) != 45) {
#line 241
    goto bad_uuid;
  } else
#line 240
  if ((int const   )*(s + 13) != 45) {
#line 241
    goto bad_uuid;
  } else
#line 240
  if ((int const   )*(s + 18) != 45) {
#line 241
    goto bad_uuid;
  } else
#line 240
  if ((int const   )*(s + 23) != 45) {
#line 241
    goto bad_uuid;
  }
#line 242
  i = 0;
  {
#line 242
  while (1) {
    while_continue: /* CIL Label */ ;
#line 242
    if (! (i < 16)) {
#line 242
      goto while_break;
    }
#line 243
    if ((int const   )*s == 45) {
#line 244
      s ++;
    }
    {
#line 245
    tmp___0 = __ctype_b_loc();
    }
#line 245
    if ((int const   )*(*tmp___0 + (int )*(s + 0)) & 4096) {
      {
#line 245
      tmp___1 = __ctype_b_loc();
      }
#line 245
      if (! ((int const   )*(*tmp___1 + (int )*(s + 1)) & 4096)) {
#line 246
        goto bad_uuid;
      }
    } else {
#line 246
      goto bad_uuid;
    }
    {
#line 247
    tmp___2 = fromhex___2((char )*(s + 0));
#line 247
    tmp___3 = fromhex___2((char )*(s + 1));
#line 247
    uuid[i] = (u_char )(((int )tmp___2 << 4) | (int )tmp___3);
#line 248
    s += 2;
#line 242
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 250
  tmp___4 = get_spec_by_x___2(1, (char const   *)((char *)(uuid)));
  }
#line 250
  return (tmp___4);
  bad_uuid: 
  {
#line 253
  tmp___5 = gettext("Found an invalid UUID: %s\n");
#line 253
  errstr(tmp___5, s);
  }
#line 254
  return ((char *)((void *)0));
}
}
#line 257 "/home/wheatley/newnew/temp/quota-4.01/bylabel.c"
static char *get_spec_by_volume_label___2(char const   *s ) 
{ 
  char *tmp ;

  {
  {
#line 259
  tmp = get_spec_by_x___2(2, s);
  }
#line 259
  return (tmp);
}
}
#line 50 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v1.c"
static int v1_check_file___2(int fd , int type , int fmt___7 ) ;
#line 51
static int v1_init_io___2(struct quota_handle *h ) ;
#line 52
static int v1_new_io___2(struct quota_handle *h ) ;
#line 53
static int v1_write_info___2(struct quota_handle *h ) ;
#line 54
static struct dquot *v1_read_dquot___2(struct quota_handle *h , qid_t id___0 ) ;
#line 55
static int v1_commit_dquot___2(struct dquot *dquot , int flags___7 ) ;
#line 56
static int v1_scan_dquots___2(struct quota_handle *h , int (*process_dquot)(struct dquot *dquot ,
                                                                            char *dqname ) ) ;
#line 127 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v1.c"
static int v1_check_file___2(int fd , int type , int fmt___7 ) 
{ 
  struct stat st ;
  int tmp ;

  {
  {
#line 131
  tmp = fstat(fd, & st);
  }
#line 131
  if (tmp < 0) {
#line 132
    return (0);
  }
#line 133
  if (! st.st_size) {
#line 134
    return (0);
  } else
#line 133
  if ((unsigned long )st.st_size % sizeof(struct v1_disk_dqblk )) {
#line 134
    return (0);
  }
#line 135
  return (1);
}
}
#line 141 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v1.c"
static int v1_init_io___2(struct quota_handle *h ) 
{ 
  int tmp ;
  struct v1_kern_dqblk kdqblk ;
  time_t tmp___0 ;
  int *tmp___1 ;
  long tmp___2 ;
  struct v1_disk_dqblk ddqblk ;
  ssize_t tmp___3 ;

  {
#line 143
  if (h->qh_io_flags & 1) {
#line 144
    if (kernel_iface == 3) {
      {
#line 145
      tmp = vfs_get_info(h);
      }
#line 145
      if (tmp < 0) {
#line 146
        return (-1);
      }
    } else {
      {
#line 151
      tmp___2 = quotactl((768 << 8) | (h->qh_type & 255), (char const   *)(h->qh_quotadev),
                         (qid_t )0, (caddr_t )((void *)(& kdqblk)));
      }
#line 151
      if (tmp___2 < 0L) {
        {
#line 152
        tmp___1 = __errno_location();
        }
#line 152
        if (*tmp___1 == 1) {
#line 153
          tmp___0 = (time_t )0;
#line 153
          h->qh_info.dqi_igrace = tmp___0;
#line 153
          h->qh_info.dqi_bgrace = tmp___0;
        } else {
#line 156
          return (-1);
        }
      } else {
#line 159
        h->qh_info.dqi_bgrace = kdqblk.dqb_btime;
#line 160
        h->qh_info.dqi_igrace = kdqblk.dqb_itime;
      }
    }
  } else {
    {
#line 167
    lseek(h->qh_fd, (__off64_t )0, 0);
#line 168
    tmp___3 = read(h->qh_fd, (void *)(& ddqblk), sizeof(ddqblk));
    }
#line 168
    if ((unsigned long )tmp___3 != sizeof(ddqblk)) {
#line 169
      return (-1);
    }
#line 170
    h->qh_info.dqi_bgrace = ddqblk.dqb_btime;
#line 171
    h->qh_info.dqi_igrace = ddqblk.dqb_itime;
  }
#line 173
  if (! h->qh_info.dqi_bgrace) {
#line 174
    h->qh_info.dqi_bgrace = (time_t )604800;
  }
#line 175
  if (! h->qh_info.dqi_igrace) {
#line 176
    h->qh_info.dqi_igrace = (time_t )604800;
  }
#line 177
  h->qh_info.dqi_max_b_limit = (uint64_t )(~ ((uint32_t )0));
#line 178
  h->qh_info.dqi_max_i_limit = (uint64_t )(~ ((uint32_t )0));
#line 179
  h->qh_info.dqi_max_b_usage = 4294967295UL << 10;
#line 180
  h->qh_info.dqi_max_i_usage = (uint64_t )(~ ((uint32_t )0));
#line 182
  return (0);
}
}
#line 188 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v1.c"
static int v1_new_io___2(struct quota_handle *h ) 
{ 
  struct v1_disk_dqblk ddqblk ;
  ssize_t tmp ;

  {
  {
#line 193
  memset((void *)(& ddqblk), 0, sizeof(ddqblk));
#line 194
  ddqblk.dqb_btime = (time_t )604800;
#line 195
  ddqblk.dqb_itime = (time_t )604800;
#line 196
  h->qh_info.dqi_bgrace = (time_t )604800;
#line 197
  h->qh_info.dqi_igrace = (time_t )604800;
#line 198
  h->qh_info.dqi_max_b_limit = (uint64_t )(~ ((uint32_t )0));
#line 199
  h->qh_info.dqi_max_i_limit = (uint64_t )(~ ((uint32_t )0));
#line 200
  h->qh_info.dqi_max_b_usage = 4294967295UL << 10;
#line 201
  h->qh_info.dqi_max_i_usage = (uint64_t )(~ ((uint32_t )0));
#line 202
  lseek(h->qh_fd, (__off64_t )0, 0);
#line 203
  tmp = write(h->qh_fd, (void const   *)(& ddqblk), sizeof(ddqblk));
  }
#line 203
  if ((unsigned long )tmp != sizeof(ddqblk)) {
#line 204
    return (-1);
  }
#line 205
  return (0);
}
}
#line 211 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v1.c"
static int v1_write_info___2(struct quota_handle *h ) 
{ 
  char *tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  struct v1_kern_dqblk kdqblk ;
  long tmp___2 ;
  long tmp___3 ;
  struct v1_disk_dqblk ddqblk ;
  ssize_t tmp___4 ;
  ssize_t tmp___5 ;

  {
#line 213
  if (h->qh_io_flags & 4) {
    {
#line 214
    tmp = gettext("Trying to write info to readonly quotafile on %s.\n");
#line 214
    errstr(tmp, h->qh_quotadev);
#line 215
    tmp___0 = __errno_location();
#line 215
    *tmp___0 = 1;
    }
#line 216
    return (-1);
  }
#line 218
  if (h->qh_io_flags & 1) {
#line 219
    if (kernel_iface == 3) {
      {
#line 220
      tmp___1 = vfs_set_info(h, 3);
      }
#line 220
      if (tmp___1 < 0) {
#line 221
        return (-1);
      }
    } else {
      {
#line 226
      tmp___2 = quotactl((768 << 8) | (h->qh_type & 255), (char const   *)(h->qh_quotadev),
                         (qid_t )0, (caddr_t )((void *)(& kdqblk)));
      }
#line 226
      if (tmp___2 < 0L) {
#line 227
        return (-1);
      }
      {
#line 228
      kdqblk.dqb_btime = h->qh_info.dqi_bgrace;
#line 229
      kdqblk.dqb_itime = h->qh_info.dqi_igrace;
#line 230
      tmp___3 = quotactl((1024 << 8) | (h->qh_type & 255), (char const   *)(h->qh_quotadev),
                         (qid_t )0, (caddr_t )((void *)(& kdqblk)));
      }
#line 230
      if (tmp___3 < 0L) {
#line 231
        return (-1);
      }
    }
  } else {
    {
#line 237
    lseek(h->qh_fd, (__off64_t )0, 0);
#line 238
    tmp___4 = read(h->qh_fd, (void *)(& ddqblk), sizeof(ddqblk));
    }
#line 238
    if ((unsigned long )tmp___4 != sizeof(ddqblk)) {
#line 239
      return (-1);
    }
    {
#line 240
    ddqblk.dqb_btime = h->qh_info.dqi_bgrace;
#line 241
    ddqblk.dqb_itime = h->qh_info.dqi_igrace;
#line 242
    lseek(h->qh_fd, (__off64_t )0, 0);
#line 243
    tmp___5 = write(h->qh_fd, (void const   *)(& ddqblk), sizeof(ddqblk));
    }
#line 243
    if ((unsigned long )tmp___5 != sizeof(ddqblk)) {
#line 244
      return (-1);
    }
  }
#line 246
  return (0);
}
}
#line 253 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v1.c"
static struct dquot *v1_read_dquot___2(struct quota_handle *h , qid_t id___0 ) 
{ 
  struct v1_disk_dqblk ddqblk ;
  struct dquot *dquot ;
  struct dquot *tmp ;
  int tmp___0 ;
  struct v1_kern_dqblk kdqblk ;
  long tmp___1 ;
  ssize_t tmp___2 ;

  {
  {
#line 256
  tmp = get_empty_dquot();
#line 256
  dquot = tmp;
#line 258
  dquot->dq_id = id___0;
#line 259
  dquot->dq_h = h;
  }
#line 260
  if (h->qh_io_flags & 1) {
#line 261
    if (kernel_iface == 3) {
      {
#line 262
      tmp___0 = vfs_get_dquot(dquot);
      }
#line 262
      if (tmp___0 < 0) {
        {
#line 263
        free((void *)dquot);
        }
#line 264
        return ((struct dquot *)((void *)0));
      }
    } else {
      {
#line 270
      tmp___1 = quotactl((768 << 8) | (h->qh_type & 255), (char const   *)(h->qh_quotadev),
                         id___0, (caddr_t )((void *)(& kdqblk)));
      }
#line 270
      if (tmp___1 < 0L) {
        {
#line 271
        free((void *)dquot);
        }
#line 272
        return ((struct dquot *)((void *)0));
      }
      {
#line 274
      v1_kern2utildqblk(& dquot->dq_dqb, & kdqblk);
      }
    }
  } else {
    {
#line 278
    lseek(h->qh_fd, (loff_t )((unsigned long )id___0 * sizeof(struct v1_disk_dqblk )),
          0);
#line 279
    tmp___2 = read(h->qh_fd, (void *)(& ddqblk), sizeof(ddqblk));
    }
    {
#line 280
    if (tmp___2 == 0L) {
#line 280
      goto case_0;
    }
#line 287
    if (tmp___2 == (ssize_t )sizeof(struct v1_disk_dqblk )) {
#line 287
      goto case_exp;
    }
#line 290
    goto switch_default;
    case_0: /* CIL Label */ 
    {
#line 285
    memset((void *)(& dquot->dq_dqb), 0, sizeof(struct util_dqblk ));
    }
#line 286
    goto switch_break;
    case_exp: /* CIL Label */ 
    {
#line 288
    v1_disk2memdqblk(& dquot->dq_dqb, & ddqblk);
    }
#line 289
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 291
    free((void *)dquot);
    }
#line 292
    return ((struct dquot *)((void *)0));
    switch_break: /* CIL Label */ ;
    }
  }
#line 295
  return (dquot);
}
}
#line 302 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v1.c"
static int v1_commit_dquot___2(struct dquot *dquot , int flags___7 ) 
{ 
  struct v1_disk_dqblk ddqblk ;
  struct quota_handle *h ;
  char *tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  struct v1_kern_dqblk kdqblk ;
  int cmd ;
  int *tmp___2 ;
  long tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;
  ssize_t tmp___6 ;

  {
#line 305
  h = dquot->dq_h;
#line 307
  if (h->qh_io_flags & 4) {
    {
#line 308
    tmp = gettext("Trying to write quota to readonly quotafile on %s\n");
#line 308
    errstr(tmp, h->qh_quotadev);
#line 309
    tmp___0 = __errno_location();
#line 309
    *tmp___0 = 1;
    }
#line 310
    return (-1);
  }
#line 312
  if (h->qh_io_flags & 1) {
#line 313
    if (kernel_iface == 3) {
      {
#line 314
      tmp___1 = vfs_set_dquot(dquot, flags___7);
      }
#line 314
      if (tmp___1 < 0) {
#line 315
        return (-1);
      }
    } else {
#line 321
      if (flags___7 == 10) {
#line 322
        cmd = 1280;
      } else
#line 323
      if (flags___7 == 5) {
#line 324
        cmd = 1792;
      } else
#line 325
      if (flags___7 & 48) {
        {
#line 326
        tmp___2 = __errno_location();
#line 326
        *tmp___2 = 22;
        }
#line 327
        return (-1);
      } else {
#line 330
        cmd = 1024;
      }
      {
#line 331
      v1_util2kerndqblk(& kdqblk, & dquot->dq_dqb);
#line 332
      tmp___3 = quotactl((cmd << 8) | (h->qh_type & 255), (char const   *)(h->qh_quotadev),
                         dquot->dq_id, (caddr_t )((void *)(& kdqblk)));
      }
#line 332
      if (tmp___3 < 0L) {
#line 334
        return (-1);
      }
    }
  } else {
    {
#line 338
    tmp___5 = check_dquot_range(dquot);
    }
#line 338
    if (tmp___5 < 0) {
      {
#line 339
      tmp___4 = __errno_location();
#line 339
      *tmp___4 = 34;
      }
#line 340
      return (-1);
    }
    {
#line 342
    v1_mem2diskdqblk(& ddqblk, & dquot->dq_dqb);
#line 343
    lseek(h->qh_fd, (loff_t )((unsigned long )dquot->dq_id * sizeof(struct v1_disk_dqblk )),
          0);
#line 344
    tmp___6 = write(h->qh_fd, (void const   *)(& ddqblk), sizeof(ddqblk));
    }
#line 344
    if ((unsigned long )tmp___6 != sizeof(ddqblk)) {
#line 345
      return (-1);
    }
  }
#line 347
  return (0);
}
}
#line 355 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v1.c"
static int v1_scan_dquots___2(struct quota_handle *h , int (*process_dquot)(struct dquot *dquot ,
                                                                            char *dqname ) ) 
{ 
  int rd ;
  int scanbufpos ;
  int scanbufsize ;
  char scanbuf[sizeof(struct v1_disk_dqblk ) * 256UL] ;
  struct v1_disk_dqblk *ddqblk ;
  struct dquot *dquot ;
  struct dquot *tmp ;
  qid_t id___0 ;
  ssize_t tmp___0 ;

  {
  {
#line 357
  scanbufpos = 0;
#line 357
  scanbufsize = 0;
#line 360
  tmp = get_empty_dquot();
#line 360
  dquot = tmp;
#line 361
  id___0 = (qid_t )0;
#line 363
  memset((void *)dquot, 0, sizeof(*dquot));
#line 364
  dquot->dq_h = h;
#line 365
  lseek(h->qh_fd, (__off64_t )0, 0);
#line 366
  id___0 = (qid_t )0;
  }
  {
#line 366
  while (1) {
    while_continue: /* CIL Label */ ;
#line 367
    if (scanbufpos >= scanbufsize) {
      {
#line 368
      tmp___0 = read(h->qh_fd, (void *)(scanbuf), sizeof(scanbuf));
#line 368
      rd = (int )tmp___0;
      }
#line 369
      if (rd < 0) {
#line 370
        goto out_err;
      } else
#line 369
      if ((unsigned long )rd % sizeof(struct v1_disk_dqblk )) {
#line 370
        goto out_err;
      }
#line 371
      if (! rd) {
#line 372
        goto while_break;
      }
#line 373
      scanbufpos = 0;
#line 374
      scanbufsize = (int )((unsigned long )rd / sizeof(struct v1_disk_dqblk ));
    }
#line 376
    ddqblk = (struct v1_disk_dqblk *)(scanbuf) + scanbufpos;
#line 377
    if ((((long )(((((ddqblk->dqb_ihardlimit | ddqblk->dqb_isoftlimit) | ddqblk->dqb_bhardlimit) | ddqblk->dqb_bsoftlimit) | ddqblk->dqb_curblocks) | ddqblk->dqb_curinodes) | ddqblk->dqb_itime) | ddqblk->dqb_btime) == 0L) {
#line 381
      goto __Cont;
    }
    {
#line 382
    v1_disk2memdqblk(& dquot->dq_dqb, ddqblk);
#line 383
    dquot->dq_id = id___0;
#line 384
    rd = (*process_dquot)(dquot, (char *)((void *)0));
    }
#line 384
    if (rd < 0) {
      {
#line 385
      free((void *)dquot);
      }
#line 386
      return (rd);
    }
    __Cont: /* CIL Label */ 
#line 366
    id___0 ++;
#line 366
    scanbufpos ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 389
  if (! rd) {
    {
#line 390
    free((void *)dquot);
    }
#line 391
    return (0);
  }
  out_err: 
  {
#line 394
  free((void *)dquot);
  }
#line 395
  return (-1);
}
}
#line 89 "/home/wheatley/newnew/temp/quota-4.01/rquota_client.c"
static int rquota_err___2(int stat___0 ) 
{ 


  {
  {
#line 92
  if (stat___0 == -1) {
#line 92
    goto case_neg_1;
  }
#line 94
  if (stat___0 == 0) {
#line 94
    goto case_0;
  }
#line 96
  if (stat___0 == 2) {
#line 96
    goto case_2;
  }
#line 98
  if (stat___0 == 1) {
#line 98
    goto case_1;
  }
#line 100
  if (stat___0 == 3) {
#line 100
    goto case_3;
  }
#line 102
  goto switch_default;
  case_neg_1: /* CIL Label */ 
#line 93
  return (-111);
  case_0: /* CIL Label */ 
#line 95
  return (-38);
  case_2: /* CIL Label */ 
#line 97
  return (-2);
  case_1: /* CIL Label */ 
#line 99
  return (0);
  case_3: /* CIL Label */ 
#line 101
  return (-1);
  switch_default: /* CIL Label */ 
#line 103
  return (-22);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 107 "/home/wheatley/newnew/temp/quota-4.01/rquota_client.c"
static int split_nfs_mount___2(char *devname , char **host , char **path ) 
{ 
  char *pathname ;

  {
#line 112
  if ((int )*devname == 91) {
    {
#line 113
    *host = devname + 1;
#line 114
    pathname = strchr((char const   *)devname, ']');
    }
#line 115
    if (! pathname) {
#line 116
      return (0);
    } else
#line 115
    if ((int )*(pathname + 1) != 58) {
#line 116
      return (0);
    }
#line 118
    if ((int )*(pathname + 2) == 40) {
#line 119
      return (0);
    }
#line 120
    *pathname = (char)0;
#line 121
    *path = pathname + 2;
#line 122
    return (1);
  }
  {
#line 124
  *host = devname;
#line 125
  pathname = strchr((char const   *)devname, ':');
  }
#line 126
  if (! pathname) {
#line 127
    return (0);
  }
#line 129
  if ((int )*(pathname + 1) == 40) {
#line 130
    return (0);
  }
#line 131
  *pathname = (char)0;
#line 132
  *path = pathname + 1;
#line 133
  return (1);
}
}
#line 41 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static char extensions___2[4][20]  = { {        (char )'u',        (char )'s',        (char )'e',        (char )'r', 
            (char )'\000'}, 
   {        (char )'g',        (char )'r',        (char )'o',        (char )'u', 
            (char )'p',        (char )'\000'}, 
   {        (char )'u',        (char )'n',        (char )'d',        (char )'e', 
            (char )'f',        (char )'i',        (char )'n',        (char )'e', 
            (char )'d',        (char )'\000'}};
#line 42 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static char *basenames___2[6]  = {      (char *)"quota",      (char *)"aquota",      (char *)"aquota",      (char *)"", 
        (char *)"",      (char *)""};
#line 43 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static char *fmtnames___2[5]  = {      (char *)"vfsold",      (char *)"vfsv0",      (char *)"vfsv1",      (char *)"rpc", 
        (char *)"xfs"};
#line 245 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static int kern2utilfmt___2(int kernfmt ) 
{ 


  {
  {
#line 248
  if (kernfmt == 1) {
#line 248
    goto case_1;
  }
#line 250
  if (kernfmt == 2) {
#line 250
    goto case_2;
  }
#line 252
  if (kernfmt == 4) {
#line 252
    goto case_4;
  }
#line 254
  if (kernfmt == 3) {
#line 254
    goto case_3;
  }
#line 247
  goto switch_break;
  case_1: /* CIL Label */ 
#line 249
  return (0);
  case_2: /* CIL Label */ 
#line 251
  return (1);
  case_4: /* CIL Label */ 
#line 253
  return (2);
  case_3: /* CIL Label */ 
#line 255
  return (5);
  switch_break: /* CIL Label */ ;
  }
#line 257
  return (-1);
}
}
#line 394 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static int hasxfsquota___2(char const   *dev , struct mntent *mnt___2 , int type ,
                           int flags___7 ) 
{ 
  u_int16_t sbflags ;
  struct fs_quota_stat info ;
  long tmp ;

  {
#line 399
  if (flags___7 & 16) {
#line 400
    return (4);
  }
  {
#line 402
  memset((void *)(& info), 0, sizeof(struct fs_quota_stat ));
#line 403
  tmp = quotactl((((88 << 8) + 5) << 8) | (type & 255), dev, (qid_t )0, (caddr_t )((void *)(& info)));
  }
#line 403
  if (! tmp) {
#line 404
    sbflags = (u_int16_t )(((int )info.qs_flags & 65280) >> 8);
#line 405
    if (type == 0) {
#line 405
      if ((int )info.qs_flags & 1) {
#line 406
        return (4);
      } else {
#line 405
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 407
    if (type == 1) {
#line 407
      if ((int )info.qs_flags & (1 << 2)) {
#line 408
        return (4);
      }
    }
  }
#line 424
  return (-1);
}
}
#line 427 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static int hasvfsmetaquota___2(char const   *dev , struct mntent *mnt___2 , int type ,
                               int flags___7 ) 
{ 
  uint32_t fmt___7 ;
  long tmp ;

  {
  {
#line 431
  tmp = quotactl((8388612 << 8) | (type & 255), dev, (qid_t )0, (caddr_t )((void *)(& fmt___7)));
  }
#line 431
  if (! tmp) {
#line 432
    return (5);
  }
#line 433
  return (-1);
}
}
#line 465 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static char *hasmntoptarg___2(char const   *optstring , char const   *opt ) 
{ 
  char *p ;
  char *tmp ;
  size_t tmp___0 ;

  {
  {
#line 467
  tmp = str_hasmntopt(optstring, opt);
#line 467
  p = tmp;
  }
#line 469
  if (! p) {
#line 470
    return ((char *)((void *)0));
  }
  {
#line 471
  tmp___0 = strlen(opt);
#line 471
  p += tmp___0;
  }
#line 472
  if ((int )*p == 61) {
#line 472
    if ((int )*(p + 1) != 44) {
#line 473
      return (p + 1);
    }
  }
#line 474
  return ((char *)((void *)0));
}
}
#line 478 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static void copy_mntoptarg___2(char *buf , char const   *optarg___0 , int buflen ) 
{ 
  char *sep ;
  char *tmp ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  long tmp___4 ;

  {
  {
#line 480
  tmp = strchr(optarg___0, ',');
#line 480
  sep = tmp;
  }
#line 482
  if (! sep) {
    {
#line 483
    tmp___3 = strlen(optarg___0);
    }
#line 483
    if ((size_t )buflen < tmp___3 + 1UL) {
#line 483
      tmp___2 = (size_t )buflen;
    } else {
      {
#line 483
      tmp___1 = strlen(optarg___0);
#line 483
      tmp___2 = tmp___1 + 1UL;
      }
    }
    {
#line 483
    sstrncpy(buf, optarg___0, tmp___2);
    }
  } else {
#line 485
    if ((long )buflen < (sep - (char *)optarg___0) + 1L) {
#line 485
      tmp___4 = (long )buflen;
    } else {
#line 485
      tmp___4 = (sep - (char *)optarg___0) + 1L;
    }
    {
#line 485
    sstrncpy(buf, optarg___0, (size_t )tmp___4);
    }
  }
#line 486
  return;
}
}
#line 491 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static int hasquota___2(char const   *dev , struct mntent *mnt___2 , int type , int flags___7 ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  struct if_dqinfo kinfo ;
  long tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;

  {
  {
#line 493
  tmp___0 = strcmp((char const   *)mnt___2->mnt_type, "gfs2");
  }
#line 493
  if (tmp___0) {
    {
#line 493
    tmp___1 = strcmp((char const   *)mnt___2->mnt_type, "xfs");
    }
#line 493
    if (! tmp___1) {
      {
#line 495
      tmp = hasxfsquota___2(dev, mnt___2, type, flags___7);
      }
#line 495
      return (tmp);
    }
  } else {
    {
#line 495
    tmp = hasxfsquota___2(dev, mnt___2, type, flags___7);
    }
#line 495
    return (tmp);
  }
  {
#line 496
  tmp___3 = strcmp((char const   *)mnt___2->mnt_type, "ocfs2");
  }
#line 496
  if (! tmp___3) {
    {
#line 497
    tmp___2 = hasvfsmetaquota___2(dev, mnt___2, type, flags___7);
    }
#line 497
    return (tmp___2);
  }
  {
#line 504
  tmp___5 = strcmp((char const   *)mnt___2->mnt_type, "ext4");
  }
#line 504
  if (! tmp___5) {
    {
#line 507
    tmp___4 = quotactl((8388613 << 8) | (type & 255), dev, (qid_t )0, (caddr_t )((void *)(& kinfo)));
    }
#line 507
    if (tmp___4 == 0L) {
#line 508
      if (kinfo.dqi_flags & 65536U) {
#line 509
        return (5);
      }
    }
  }
  {
#line 513
  tmp___6 = nfs_fstype(mnt___2->mnt_type);
  }
#line 513
  if (tmp___6) {
#line 514
    return (3);
  }
#line 516
  if (type == 0) {
    {
#line 516
    tmp___7 = hasmntopt((struct mntent  const  *)mnt___2, "usrquota");
    }
#line 516
    if (tmp___7) {
#line 517
      return (6);
    } else {
      {
#line 516
      tmp___8 = hasmntoptarg___2((char const   *)mnt___2->mnt_opts, "usrjquota");
      }
#line 516
      if (tmp___8) {
#line 517
        return (6);
      }
    }
  }
#line 518
  if (type == 1) {
    {
#line 518
    tmp___9 = hasmntopt((struct mntent  const  *)mnt___2, "grpquota");
    }
#line 518
    if (tmp___9) {
#line 519
      return (6);
    } else {
      {
#line 518
      tmp___10 = hasmntoptarg___2((char const   *)mnt___2->mnt_opts, "grpjquota");
      }
#line 518
      if (tmp___10) {
#line 519
        return (6);
      }
    }
  }
#line 520
  if (type == 0) {
    {
#line 520
    tmp___11 = hasmntopt((struct mntent  const  *)mnt___2, "quota");
    }
#line 520
    if (tmp___11) {
#line 521
      return (6);
    }
  }
#line 522
  return (-1);
}
}
#line 526 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static int check_fmtfile_ok___2(char *name , int type , int fmt___7 , int flags___7 ) 
{ 
  struct stat st ;
  int *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;
  int fd ;
  int ret ;
  int tmp___4 ;
  int *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  int *tmp___8 ;
  int *tmp___9 ;

  {
#line 528
  if (! flags___7) {
#line 529
    return (1);
  }
#line 530
  if (flags___7 & 1) {
    {
#line 533
    tmp___3 = stat((char const   */* __restrict  */)name, (struct stat */* __restrict  */)(& st));
    }
#line 533
    if (tmp___3 < 0) {
      {
#line 534
      tmp___2 = __errno_location();
      }
#line 534
      if (*tmp___2 != 2) {
        {
#line 535
        tmp = __errno_location();
#line 535
        tmp___0 = strerror(*tmp);
#line 535
        tmp___1 = gettext("Cannot stat quota file %s: %s\n");
#line 535
        errstr(tmp___1, name, tmp___0);
        }
      }
#line 536
      return (0);
    }
  }
#line 539
  if (flags___7 & 2) {
    {
#line 540
    ret = 0;
#line 542
    fd = open((char const   *)name, 0);
    }
#line 542
    if (fd >= 0) {
      {
#line 543
      tmp___4 = is_tree_qfmt(fmt___7);
      }
#line 543
      if (tmp___4) {
        {
#line 544
        ret = (*(quotafile_ops_2.check_file))(fd, type, fmt___7);
        }
      } else {
        {
#line 546
        ret = (*(quotafile_ops_1.check_file))(fd, type, fmt___7);
        }
      }
      {
#line 547
      close(fd);
      }
#line 548
      if (ret <= 0) {
#line 549
        return (0);
      }
    } else {
      {
#line 551
      tmp___8 = __errno_location();
      }
#line 551
      if (*tmp___8 != 2) {
        {
#line 551
        tmp___9 = __errno_location();
        }
#line 551
        if (*tmp___9 != 1) {
          {
#line 552
          tmp___5 = __errno_location();
#line 552
          tmp___6 = strerror(*tmp___5);
#line 552
          tmp___7 = gettext("Cannot open quotafile %s: %s\n");
#line 552
          errstr(tmp___7, name, tmp___6);
          }
#line 553
          return (0);
        }
      }
    }
  }
#line 556
  return (1);
}
}
#line 629 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static int hlist_allocated___2  =    0;
#line 630 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static struct quota_handle **hlist___2  =    (struct quota_handle **)((void *)0);
#line 735 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static int kernel_qfmt_num___2  ;
#line 736 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static int kernel_qfmt___2[6]  ;
#line 828 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static int v1_kern_quota_on___2(char const   *dev , int type ) 
{ 
  char tmp[1024] ;
  qid_t id___0 ;
  __uid_t tmp___0 ;
  __gid_t tmp___1 ;
  __uid_t tmp___2 ;
  long tmp___3 ;

  {
#line 831
  if (type == 0) {
    {
#line 831
    tmp___0 = getuid();
#line 831
    tmp___2 = tmp___0;
    }
  } else {
    {
#line 831
    tmp___1 = getgid();
#line 831
    tmp___2 = tmp___1;
    }
  }
  {
#line 831
  id___0 = tmp___2;
#line 833
  tmp___3 = quotactl((768 << 8) | (type & 255), dev, id___0, tmp);
  }
#line 833
  if (! tmp___3) {
#line 834
    return (1);
  }
#line 835
  return (0);
}
}
#line 839 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static int v2_kern_quota_on___2(char const   *dev , int type ) 
{ 
  char tmp[1024] ;
  qid_t id___0 ;
  __uid_t tmp___0 ;
  __gid_t tmp___1 ;
  __uid_t tmp___2 ;
  long tmp___3 ;

  {
#line 842
  if (type == 0) {
    {
#line 842
    tmp___0 = getuid();
#line 842
    tmp___2 = tmp___0;
    }
  } else {
    {
#line 842
    tmp___1 = getgid();
#line 842
    tmp___2 = tmp___1;
    }
  }
  {
#line 842
  id___0 = tmp___2;
#line 844
  tmp___3 = quotactl((3328 << 8) | (type & 255), dev, id___0, tmp);
  }
#line 844
  if (! tmp___3) {
#line 845
    return (1);
  }
#line 846
  return (0);
}
}
#line 850 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static int xfs_kern_quota_on___2(char const   *dev , int type ) 
{ 
  struct fs_quota_stat info ;
  long tmp ;

  {
  {
#line 854
  tmp = quotactl((((88 << 8) + 5) << 8) | (type & 255), dev, (qid_t )0, (caddr_t )((void *)(& info)));
  }
#line 854
  if (! tmp) {
#line 855
    if (type == 0) {
#line 855
      if ((int )info.qs_flags & 1) {
#line 856
        return (1);
      }
    }
#line 857
    if (type == 1) {
#line 857
      if ((int )info.qs_flags & (1 << 2)) {
#line 858
        return (1);
      }
    }
  }
#line 860
  return (0);
}
}
#line 921 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static int mnt_entries_cnt___2  ;
#line 922 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static struct mount_entry *mnt_entries___2  ;
#line 923 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static int check_dirs_cnt___2  ;
#line 923 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static int act_checked___2  ;
#line 924 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static struct searched_dir *check_dirs___2  ;
#line 927 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static int cache_mnt_table___2(int flags___7 ) 
{ 
  FILE *mntf ;
  struct mntent *mnt___2 ;
  struct stat st ;
  struct statfs fsstat ;
  int allocated ;
  int i ;
  dev_t dev ;
  char mntpointbuf[4096] ;
  int autofsdircnt ;
  int autofsdir_allocated ;
  char **autofsdir ;
  char *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  char const   *devname ;
  char *opt ;
  int qfmt[2] ;
  char *tmp___2 ;
  int slen ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  void *tmp___6 ;
  size_t tmp___7 ;
  void *tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char loopdev[4096] ;
  char *tmp___13 ;
  int *tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;
  int *tmp___18 ;
  char *tmp___19 ;
  char *tmp___20 ;
  int tmp___21 ;
  int *tmp___22 ;
  char *tmp___23 ;
  char *tmp___24 ;
  int tmp___25 ;
  char *tmp___26 ;
  int tmp___27 ;
  int *tmp___28 ;
  char *tmp___29 ;
  char *tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;
  void *tmp___34 ;
  char *tmp___35 ;

  {
  {
#line 933
  allocated = 0;
#line 933
  i = 0;
#line 934
  dev = (dev_t )0;
#line 940
  mntf = setmntent("/proc/mounts", "r");
  }
#line 941
  if (mntf) {
#line 942
    goto alloc;
  }
  {
#line 944
  mntf = setmntent("/etc/mtab", "r");
  }
#line 945
  if (mntf) {
#line 946
    goto alloc;
  }
  {
#line 948
  mntf = setmntent("/etc/fstab", "r");
  }
#line 948
  if (! mntf) {
    {
#line 949
    tmp = gettext("Cannot open any file with mount points.\n");
#line 949
    errstr(tmp);
    }
#line 950
    return (-1);
  }
  alloc: 
  {
#line 954
  tmp___0 = smalloc(sizeof(struct mount_entry ) * 16UL);
#line 954
  mnt_entries___2 = (struct mount_entry *)tmp___0;
#line 955
  mnt_entries_cnt___2 = 0;
#line 956
  allocated += 16;
#line 958
  tmp___1 = smalloc(sizeof(char *) * 16UL);
#line 958
  autofsdir = (char **)tmp___1;
#line 959
  autofsdircnt = 0;
#line 960
  autofsdir_allocated = 16;
  }
  {
#line 961
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 961
    mnt___2 = getmntent(mntf);
    }
#line 961
    if (! mnt___2) {
#line 961
      goto while_break;
    }
    {
#line 966
    devname = get_device_name((char const   *)mnt___2->mnt_fsname);
    }
#line 966
    if (! devname) {
      {
#line 967
      tmp___2 = gettext("Cannot get device name for %s\n");
#line 967
      errstr(tmp___2, mnt___2->mnt_fsname);
      }
#line 968
      goto while_continue;
    }
#line 972
    i = 0;
    {
#line 972
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 972
      if (! (i < autofsdircnt)) {
#line 972
        goto while_break___0;
      }
      {
#line 973
      tmp___3 = strlen((char const   *)*(autofsdir + i));
#line 973
      slen = (int )tmp___3;
#line 975
      tmp___4 = strlen((char const   *)mnt___2->mnt_dir);
      }
#line 975
      if ((size_t )slen <= tmp___4) {
        {
#line 975
        tmp___5 = strncmp((char const   *)*(autofsdir + i), (char const   *)mnt___2->mnt_dir,
                          (size_t )slen);
        }
#line 975
        if (! tmp___5) {
#line 976
          goto while_break___0;
        }
      }
#line 972
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 978
    if (i < autofsdircnt) {
      {
#line 979
      free((void *)((char *)devname));
      }
#line 980
      goto while_continue;
    }
#line 983
    if (flags___7 & 2) {
      {
#line 983
      tmp___9 = strcmp((char const   *)mnt___2->mnt_type, "autofs");
      }
#line 983
      if (! tmp___9) {
#line 984
        if (autofsdircnt == autofsdir_allocated) {
          {
#line 985
          autofsdir_allocated += 16;
#line 986
          tmp___6 = srealloc((void *)autofsdir, (unsigned long )autofsdir_allocated * sizeof(char *));
#line 986
          autofsdir = (char **)tmp___6;
          }
        }
        {
#line 988
        tmp___7 = strlen((char const   *)mnt___2->mnt_dir);
#line 988
        tmp___8 = smalloc(tmp___7 + 2UL);
#line 988
        *(autofsdir + autofsdircnt) = (char *)tmp___8;
#line 989
        strcpy((char */* __restrict  */)*(autofsdir + autofsdircnt), (char const   */* __restrict  */)mnt___2->mnt_dir);
#line 990
        strcat((char */* __restrict  */)*(autofsdir + autofsdircnt), (char const   */* __restrict  */)"/");
#line 991
        autofsdircnt ++;
#line 992
        free((void *)((char *)devname));
        }
#line 993
        goto while_continue;
      }
    }
#line 996
    if (flags___7 & 8) {
      {
#line 996
      tmp___10 = nfs_fstype(mnt___2->mnt_type);
      }
#line 996
      if (tmp___10) {
        {
#line 997
        free((void *)((char *)devname));
        }
#line 998
        goto while_continue;
      }
    }
    {
#line 1000
    tmp___11 = hasmntopt((struct mntent  const  *)mnt___2, "noquota");
    }
#line 1000
    if (tmp___11) {
      {
#line 1001
      free((void *)((char *)devname));
      }
#line 1002
      goto while_continue;
    }
    {
#line 1004
    tmp___12 = hasmntopt((struct mntent  const  *)mnt___2, "bind");
    }
#line 1004
    if (tmp___12) {
      {
#line 1005
      free((void *)((char *)devname));
      }
#line 1006
      goto while_continue;
    }
    {
#line 1008
    opt = hasmntoptarg___2((char const   *)mnt___2->mnt_opts, "loop");
    }
#line 1008
    if (opt) {
      {
#line 1011
      copy_mntoptarg___2(opt, (char const   *)(loopdev), 4096);
#line 1012
      free((void *)((char *)devname));
#line 1013
      tmp___13 = sstrdup((char const   *)(loopdev));
#line 1013
      devname = (char const   *)tmp___13;
      }
    }
    {
#line 1018
    qfmt[0] = hasquota___2(devname, mnt___2, 0, flags___7);
#line 1019
    qfmt[1] = hasquota___2(devname, mnt___2, 1, flags___7);
    }
#line 1020
    if (qfmt[0] < 0) {
#line 1020
      if (qfmt[1] < 0) {
        {
#line 1021
        free((void *)((char *)devname));
        }
#line 1022
        goto while_continue;
      }
    }
    {
#line 1025
    tmp___17 = realpath((char const   */* __restrict  */)mnt___2->mnt_dir, (char */* __restrict  */)(mntpointbuf));
    }
#line 1025
    if (! tmp___17) {
      {
#line 1026
      tmp___14 = __errno_location();
#line 1026
      tmp___15 = strerror(*tmp___14);
#line 1026
      tmp___16 = gettext("Cannot resolve mountpoint path %s: %s\n");
#line 1026
      errstr(tmp___16, mnt___2->mnt_dir, tmp___15);
#line 1027
      free((void *)((char *)devname));
      }
#line 1028
      goto while_continue;
    }
    {
#line 1031
    tmp___21 = statfs((char const   *)(mntpointbuf), & fsstat);
    }
#line 1031
    if (tmp___21 != 0) {
      {
#line 1032
      tmp___18 = __errno_location();
#line 1032
      tmp___19 = strerror(*tmp___18);
#line 1032
      tmp___20 = gettext("Cannot statfs() %s: %s\n");
#line 1032
      errstr(tmp___20, mntpointbuf, tmp___19);
#line 1033
      free((void *)((char *)devname));
      }
#line 1034
      goto while_continue;
    }
#line 1037
    if (fsstat.f_blocks == 0UL) {
#line 1037
      if (fsstat.f_bfree == 0UL) {
#line 1037
        if (fsstat.f_bavail == 0UL) {
          {
#line 1038
          free((void *)((char *)devname));
          }
#line 1039
          goto while_continue;
        }
      }
    }
    {
#line 1042
    tmp___27 = nfs_fstype(mnt___2->mnt_type);
    }
#line 1042
    if (! tmp___27) {
      {
#line 1043
      tmp___25 = stat((char const   */* __restrict  */)devname, (struct stat */* __restrict  */)(& st));
      }
#line 1043
      if (tmp___25 < 0) {
        {
#line 1044
        tmp___22 = __errno_location();
#line 1044
        tmp___23 = strerror(*tmp___22);
#line 1044
        tmp___24 = gettext("Cannot stat() mounted device %s: %s\n");
#line 1044
        errstr(tmp___24, devname, tmp___23);
#line 1045
        free((void *)((char *)devname));
        }
#line 1046
        goto while_continue;
      }
#line 1048
      if (! ((st.st_mode & 61440U) == 24576U)) {
#line 1048
        if (! ((st.st_mode & 61440U) == 8192U)) {
          {
#line 1049
          tmp___26 = gettext("Device (%s) filesystem is mounted on unsupported device type. Skipping.\n");
#line 1049
          errstr(tmp___26, devname);
#line 1050
          free((void *)((char *)devname));
          }
#line 1051
          goto while_continue;
        }
      }
#line 1053
      dev = st.st_rdev;
#line 1054
      i = 0;
      {
#line 1054
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1054
        if (i < mnt_entries_cnt___2) {
#line 1054
          if (! ((mnt_entries___2 + i)->me_dev != dev)) {
#line 1054
            goto while_break___1;
          }
        } else {
#line 1054
          goto while_break___1;
        }
#line 1054
        i ++;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
    {
#line 1057
    tmp___33 = nfs_fstype(mnt___2->mnt_type);
    }
#line 1057
    if (tmp___33) {
#line 1057
      goto _L;
    } else
#line 1057
    if (i == mnt_entries_cnt___2) {
      _L: /* CIL Label */ 
      {
#line 1058
      tmp___31 = stat((char const   */* __restrict  */)mnt___2->mnt_dir, (struct stat */* __restrict  */)(& st));
      }
#line 1058
      if (tmp___31 < 0) {
        {
#line 1059
        tmp___28 = __errno_location();
#line 1059
        tmp___29 = strerror(*tmp___28);
#line 1059
        tmp___30 = gettext("Cannot stat() mountpoint %s: %s\n");
#line 1059
        errstr(tmp___30, mnt___2->mnt_dir, tmp___29);
#line 1060
        free((void *)((char *)devname));
        }
#line 1061
        goto while_continue;
      }
      {
#line 1063
      tmp___32 = nfs_fstype(mnt___2->mnt_type);
      }
#line 1063
      if (tmp___32) {
#line 1065
        dev = st.st_dev;
#line 1066
        if (! (flags___7 & 32)) {
#line 1067
          i = 0;
          {
#line 1067
          while (1) {
            while_continue___2: /* CIL Label */ ;
#line 1067
            if (i < mnt_entries_cnt___2) {
#line 1067
              if (! ((mnt_entries___2 + i)->me_dev != dev)) {
#line 1067
                goto while_break___2;
              }
            } else {
#line 1067
              goto while_break___2;
            }
#line 1067
            i ++;
          }
          while_break___2: /* CIL Label */ ;
          }
        } else {
#line 1070
          i = mnt_entries_cnt___2;
        }
      }
    }
#line 1073
    if (i == mnt_entries_cnt___2) {
#line 1074
      if (allocated == mnt_entries_cnt___2) {
        {
#line 1075
        allocated += 16;
#line 1076
        tmp___34 = srealloc((void *)mnt_entries___2, (unsigned long )allocated * sizeof(struct mount_entry ));
#line 1076
        mnt_entries___2 = (struct mount_entry *)tmp___34;
        }
      }
      {
#line 1078
      (mnt_entries___2 + i)->me_type = sstrdup((char const   *)mnt___2->mnt_type);
#line 1079
      (mnt_entries___2 + i)->me_opts = sstrdup((char const   *)mnt___2->mnt_opts);
#line 1080
      (mnt_entries___2 + i)->me_dev = dev;
#line 1081
      (mnt_entries___2 + i)->me_ino = st.st_ino;
#line 1082
      (mnt_entries___2 + i)->me_devname = devname;
#line 1083
      tmp___35 = sstrdup((char const   *)(mntpointbuf));
#line 1083
      (mnt_entries___2 + i)->me__dir = (char const   *)tmp___35;
#line 1084
      (mnt_entries___2 + i)->me_dir = (char const   *)((void *)0);
#line 1085
      memcpy((void */* __restrict  */)(& (mnt_entries___2 + i)->me_qfmt), (void const   */* __restrict  */)(qfmt),
             sizeof(qfmt));
#line 1086
      mnt_entries_cnt___2 ++;
      }
    } else {
      {
#line 1089
      free((void *)((char *)devname));
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1091
  endmntent(mntf);
#line 1093
  i = 0;
  }
  {
#line 1093
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 1093
    if (! (i < autofsdircnt)) {
#line 1093
      goto while_break___3;
    }
    {
#line 1094
    free((void *)*(autofsdir + i));
#line 1093
    i ++;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 1095
  free((void *)autofsdir);
  }
#line 1096
  return (0);
}
}
#line 1100 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static char const   *find_dir_mntpoint___2(struct stat *st ) 
{ 
  int i ;

  {
#line 1104
  i = 0;
  {
#line 1104
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1104
    if (! (i < mnt_entries_cnt___2)) {
#line 1104
      goto while_break;
    }
#line 1105
    if ((mnt_entries___2 + i)->me_dev == st->st_dev) {
#line 1106
      st->st_ino = (mnt_entries___2 + i)->me_ino;
#line 1107
      return ((mnt_entries___2 + i)->me__dir);
    }
#line 1104
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1109
  return ((char const   *)((void *)0));
}
}
#line 1113 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static int process_dirs___2(int dcnt , char **dirs , int flags___7 ) 
{ 
  struct stat st ;
  int i ;
  char mntpointbuf[4096] ;
  void *tmp ;
  char *devname ;
  char const   *tmp___0 ;
  char *tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  int *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  char const   *realmnt ;
  char *tmp___12 ;
  int *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  int mentry ;
  char *tmp___17 ;
  char *tmp___18 ;
  char *tmp___19 ;
  char *tmp___20 ;

  {
#line 1119
  check_dirs_cnt___2 = 0;
#line 1120
  act_checked___2 = -1;
#line 1121
  if (dcnt) {
    {
#line 1122
    tmp = smalloc(sizeof(struct searched_dir ) * (unsigned long )dcnt);
#line 1122
    check_dirs___2 = (struct searched_dir *)tmp;
#line 1123
    i = 0;
    }
    {
#line 1123
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1123
      if (! (i < dcnt)) {
#line 1123
        goto while_break;
      }
      {
#line 1124
      tmp___10 = strncmp((char const   *)*(dirs + i), "UUID=", (size_t )5);
      }
#line 1124
      if (tmp___10) {
        {
#line 1124
        tmp___11 = strncmp((char const   *)*(dirs + i), "LABEL=", (size_t )6);
        }
#line 1124
        if (tmp___11) {
          {
#line 1139
          tmp___9 = stat((char const   */* __restrict  */)*(dirs + i), (struct stat */* __restrict  */)(& st));
          }
#line 1139
          if (tmp___9 < 0) {
            {
#line 1140
            tmp___6 = __errno_location();
#line 1140
            tmp___7 = strerror(*tmp___6);
#line 1140
            tmp___8 = gettext("Cannot stat() given mountpoint %s: %s\nSkipping...\n");
#line 1140
            errstr(tmp___8, *(dirs + i), tmp___7);
            }
#line 1141
            goto __Cont;
          }
        } else {
          _L: /* CIL Label */ 
          {
#line 1125
          tmp___0 = get_device_name((char const   *)*(dirs + i));
#line 1125
          devname = (char *)tmp___0;
          }
#line 1127
          if (! devname) {
            {
#line 1128
            tmp___1 = gettext("Cannot find a device with %s.\nSkipping...\n");
#line 1128
            errstr(tmp___1, *(dirs + i));
            }
#line 1129
            goto __Cont;
          }
          {
#line 1131
          tmp___5 = stat((char const   */* __restrict  */)devname, (struct stat */* __restrict  */)(& st));
          }
#line 1131
          if (tmp___5 < 0) {
            {
#line 1132
            tmp___2 = __errno_location();
#line 1132
            tmp___3 = strerror(*tmp___2);
#line 1132
            tmp___4 = gettext("Cannot stat() a mountpoint with %s: %s\nSkipping...\n");
#line 1132
            errstr(tmp___4, *(dirs + i), tmp___3);
#line 1133
            free((void *)devname);
            }
#line 1134
            goto __Cont;
          }
          {
#line 1136
          free((void *)devname);
          }
        }
      } else {
#line 1124
        goto _L;
      }
#line 1143
      (check_dirs___2 + check_dirs_cnt___2)->sd_dir = (st.st_mode & 61440U) == 16384U;
#line 1144
      if ((st.st_mode & 61440U) == 16384U) {
#line 1145
        realmnt = (char const   *)*(dirs + i);
#line 1148
        if (flags___7 & 1) {
          {
#line 1148
          realmnt = find_dir_mntpoint___2(& st);
          }
#line 1148
          if (! realmnt) {
#line 1149
            if (! (flags___7 & 4)) {
              {
#line 1150
              tmp___12 = gettext("Cannot find a filesystem mountpoint for directory %s\n");
#line 1150
              errstr(tmp___12, *(dirs + i));
              }
            }
#line 1151
            goto __Cont;
          }
        }
        {
#line 1153
        (check_dirs___2 + check_dirs_cnt___2)->sd_dev = st.st_dev;
#line 1154
        (check_dirs___2 + check_dirs_cnt___2)->sd_ino = st.st_ino;
#line 1155
        tmp___16 = realpath((char const   */* __restrict  */)realmnt, (char */* __restrict  */)(mntpointbuf));
        }
#line 1155
        if (! tmp___16) {
          {
#line 1156
          tmp___13 = __errno_location();
#line 1156
          tmp___14 = strerror(*tmp___13);
#line 1156
          tmp___15 = gettext("Cannot resolve path %s: %s\n");
#line 1156
          errstr(tmp___15, realmnt, tmp___14);
          }
#line 1157
          goto __Cont;
        }
      } else
#line 1160
      if ((st.st_mode & 61440U) == 24576U) {
#line 1160
        goto _L___0;
      } else
#line 1160
      if ((st.st_mode & 61440U) == 8192U) {
        _L___0: /* CIL Label */ 
#line 1163
        (check_dirs___2 + check_dirs_cnt___2)->sd_dev = st.st_rdev;
#line 1164
        mentry = 0;
        {
#line 1164
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 1164
          if (mentry < mnt_entries_cnt___2) {
#line 1164
            if (! ((mnt_entries___2 + mentry)->me_dev != st.st_rdev)) {
#line 1164
              goto while_break___0;
            }
          } else {
#line 1164
            goto while_break___0;
          }
#line 1164
          mentry ++;
        }
        while_break___0: /* CIL Label */ ;
        }
#line 1165
        if (mentry == mnt_entries_cnt___2) {
#line 1166
          if (! (flags___7 & 4)) {
            {
#line 1167
            tmp___17 = gettext("Cannot find mountpoint for device %s\n");
#line 1167
            errstr(tmp___17, *(dirs + i));
            }
          }
#line 1168
          goto __Cont;
        }
        {
#line 1170
        sstrncpy(mntpointbuf, (mnt_entries___2 + mentry)->me__dir, (size_t )4095);
        }
      } else {
        {
#line 1173
        tmp___18 = gettext("Specified path %s is not directory nor device.\n");
#line 1173
        errstr(tmp___18, *(dirs + i));
        }
#line 1174
        goto __Cont;
      }
      {
#line 1176
      tmp___19 = sstrdup((char const   *)(mntpointbuf));
#line 1176
      (check_dirs___2 + check_dirs_cnt___2)->sd_name = (char const   *)tmp___19;
#line 1177
      check_dirs_cnt___2 ++;
      }
      __Cont: /* CIL Label */ 
#line 1123
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 1179
    if (! check_dirs_cnt___2) {
#line 1180
      if (! (flags___7 & 4)) {
        {
#line 1181
        tmp___20 = gettext("No correct mountpoint specified.\n");
#line 1181
        errstr(tmp___20);
        }
      }
      {
#line 1182
      free((void *)check_dirs___2);
      }
#line 1183
      return (-1);
    }
  }
#line 1186
  return (0);
}
}
#line 1204 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static int find_next_entry_all___2(int *pos ) 
{ 
  char *tmp ;

  {
  {
#line 1206
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1206
    act_checked___2 ++;
#line 1206
    if (! (act_checked___2 < mnt_entries_cnt___2)) {
#line 1206
      goto while_break;
    }
    {
#line 1207
    tmp = str_hasmntopt((char const   *)(mnt_entries___2 + act_checked___2)->me_opts,
                        "noauto");
    }
#line 1207
    if (! tmp) {
#line 1208
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1210
  if (act_checked___2 >= mnt_entries_cnt___2) {
#line 1211
    return (0);
  }
#line 1212
  *pos = act_checked___2;
#line 1213
  return (1);
}
}
#line 1217 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static int find_next_entry_sel___2(int *pos ) 
{ 
  int i ;
  struct searched_dir *sd ;
  char *tmp ;

  {
  restart: 
#line 1223
  act_checked___2 ++;
#line 1223
  if (act_checked___2 == check_dirs_cnt___2) {
#line 1224
    return (0);
  }
#line 1225
  sd = check_dirs___2 + act_checked___2;
#line 1226
  i = 0;
  {
#line 1226
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1226
    if (! (i < mnt_entries_cnt___2)) {
#line 1226
      goto while_break;
    }
#line 1227
    if (sd->sd_dir) {
#line 1228
      if (sd->sd_dev == (mnt_entries___2 + i)->me_dev) {
#line 1228
        if (sd->sd_ino == (mnt_entries___2 + i)->me_ino) {
#line 1229
          goto while_break;
        }
      }
    } else
#line 1232
    if (sd->sd_dev == (mnt_entries___2 + i)->me_dev) {
#line 1233
      goto while_break;
    }
#line 1226
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1235
  if (i == mnt_entries_cnt___2) {
    {
#line 1236
    tmp = gettext("Mountpoint (or device) %s not found or has no quota enabled.\n");
#line 1236
    errstr(tmp, sd->sd_name);
    }
#line 1237
    goto restart;
  }
#line 1239
  *pos = i;
#line 1240
  return (1);
}
}
#line 45 "/home/wheatley/newnew/temp/quota-4.01/quotaio_tree.c"
static int get_index___2(qid_t id___0 , int depth ) 
{ 


  {
#line 47
  return ((int )((id___0 >> ((4 - depth) - 1) * 8) & 255U));
}
}
#line 51 "/home/wheatley/newnew/temp/quota-4.01/quotaio_tree.c"
static void read_blk___2(struct quota_handle *h , uint blk , dqbuf_t buf ) 
{ 
  int err ;
  ssize_t tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 55
  lseek(h->qh_fd, (__off64_t )(blk << 10), 0);
#line 56
  tmp = read(h->qh_fd, (void *)buf, (size_t )(1 << 10));
#line 56
  err = (int )tmp;
  }
#line 57
  if (err < 0) {
    {
#line 58
    tmp___0 = __errno_location();
#line 58
    tmp___1 = strerror(*tmp___0);
#line 58
    tmp___2 = gettext("Cannot read block %u: %s\n");
#line 58
    die(2, tmp___2, blk, tmp___1);
    }
  } else
#line 59
  if (err != 1 << 10) {
    {
#line 60
    memset((void *)(buf + err), 0, (size_t )((1 << 10) - err));
    }
  }
#line 61
  return;
}
}
#line 64 "/home/wheatley/newnew/temp/quota-4.01/quotaio_tree.c"
static int write_blk___2(struct quota_handle *h , uint blk , dqbuf_t buf ) 
{ 
  int err ;
  ssize_t tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  int *tmp___3 ;

  {
  {
#line 68
  lseek(h->qh_fd, (__off64_t )(blk << 10), 0);
#line 69
  tmp = write(h->qh_fd, (void const   *)buf, (size_t )(1 << 10));
#line 69
  err = (int )tmp;
  }
#line 70
  if (err < 0) {
    {
#line 70
    tmp___3 = __errno_location();
    }
#line 70
    if (*tmp___3 != 28) {
      {
#line 71
      tmp___0 = __errno_location();
#line 71
      tmp___1 = strerror(*tmp___0);
#line 71
      tmp___2 = gettext("Cannot write block (%u): %s\n");
#line 71
      die(2, tmp___2, blk, tmp___1);
      }
    }
  }
#line 72
  if (err != 1 << 10) {
#line 73
    return (-28);
  }
#line 74
  return (0);
}
}
#line 78 "/home/wheatley/newnew/temp/quota-4.01/quotaio_tree.c"
static int get_free_dqblk___2(struct quota_handle *h ) 
{ 
  dqbuf_t buf ;
  void *tmp ;
  struct qt_disk_dqdbheader *dh ;
  struct qtree_mem_dqinfo *info ;
  int blk ;
  char *tmp___0 ;
  int tmp___1 ;
  unsigned int tmp___2 ;

  {
  {
#line 80
  tmp = smalloc((size_t )(1 << 10));
#line 80
  buf = (dqbuf_t )tmp;
#line 81
  dh = (struct qt_disk_dqdbheader *)buf;
#line 82
  info = & h->qh_info.u.v2_mdqi.dqi_qtree;
  }
#line 85
  if (info->dqi_free_blk) {
    {
#line 86
    blk = (int )info->dqi_free_blk;
#line 87
    read_blk___2(h, (uint )blk, buf);
#line 88
    info->dqi_free_blk = dh->dqdh_next_free;
    }
  } else {
    {
#line 91
    memset((void *)buf, 0, (size_t )(1 << 10));
#line 92
    tmp___1 = write_blk___2(h, info->dqi_blocks, buf);
    }
#line 92
    if (tmp___1 < 0) {
      {
#line 93
      free((void *)buf);
#line 94
      tmp___0 = gettext("Cannot allocate new quota block (out of disk space).\n");
#line 94
      errstr(tmp___0);
      }
#line 95
      return (-28);
    }
#line 97
    tmp___2 = info->dqi_blocks;
#line 97
    (info->dqi_blocks) ++;
#line 97
    blk = (int )tmp___2;
  }
  {
#line 99
  mark_quotafile_info_dirty(h);
#line 100
  free((void *)buf);
  }
#line 101
  return (blk);
}
}
#line 105 "/home/wheatley/newnew/temp/quota-4.01/quotaio_tree.c"
static void put_free_dqblk___2(struct quota_handle *h , dqbuf_t buf , uint blk ) 
{ 
  struct qt_disk_dqdbheader *dh ;
  struct qtree_mem_dqinfo *info ;

  {
  {
#line 107
  dh = (struct qt_disk_dqdbheader *)buf;
#line 108
  info = & h->qh_info.u.v2_mdqi.dqi_qtree;
#line 110
  dh->dqdh_next_free = info->dqi_free_blk;
#line 111
  dh->dqdh_prev_free = (__u32 )0;
#line 112
  dh->dqdh_entries = (__u16 )0;
#line 113
  info->dqi_free_blk = blk;
#line 114
  mark_quotafile_info_dirty(h);
#line 115
  write_blk___2(h, blk, buf);
  }
#line 116
  return;
}
}
#line 119 "/home/wheatley/newnew/temp/quota-4.01/quotaio_tree.c"
static void remove_free_dqentry___2(struct quota_handle *h , dqbuf_t buf , uint blk ) 
{ 
  dqbuf_t tmpbuf ;
  void *tmp ;
  struct qt_disk_dqdbheader *dh ;
  uint nextblk ;
  uint prevblk ;
  u_int32_t tmp___0 ;

  {
  {
#line 121
  tmp = smalloc((size_t )(1 << 10));
#line 121
  tmpbuf = (dqbuf_t )tmp;
#line 122
  dh = (struct qt_disk_dqdbheader *)buf;
#line 123
  nextblk = dh->dqdh_next_free;
#line 123
  prevblk = dh->dqdh_prev_free;
  }
#line 127
  if (nextblk) {
    {
#line 128
    read_blk___2(h, nextblk, tmpbuf);
#line 129
    ((struct qt_disk_dqdbheader *)tmpbuf)->dqdh_prev_free = dh->dqdh_prev_free;
#line 130
    write_blk___2(h, nextblk, tmpbuf);
    }
  }
#line 132
  if (prevblk) {
    {
#line 133
    read_blk___2(h, prevblk, tmpbuf);
#line 134
    ((struct qt_disk_dqdbheader *)tmpbuf)->dqdh_next_free = dh->dqdh_next_free;
#line 135
    write_blk___2(h, prevblk, tmpbuf);
    }
  } else {
    {
#line 138
    h->qh_info.u.v2_mdqi.dqi_qtree.dqi_free_entry = nextblk;
#line 139
    mark_quotafile_info_dirty(h);
    }
  }
  {
#line 141
  free((void *)tmpbuf);
#line 142
  tmp___0 = (__u32 )0;
#line 142
  dh->dqdh_prev_free = tmp___0;
#line 142
  dh->dqdh_next_free = tmp___0;
#line 143
  write_blk___2(h, blk, buf);
  }
#line 144
  return;
}
}
#line 147 "/home/wheatley/newnew/temp/quota-4.01/quotaio_tree.c"
static void insert_free_dqentry___2(struct quota_handle *h , dqbuf_t buf , uint blk ) 
{ 
  dqbuf_t tmpbuf ;
  void *tmp ;
  struct qt_disk_dqdbheader *dh ;
  struct qtree_mem_dqinfo *info ;

  {
  {
#line 149
  tmp = smalloc((size_t )(1 << 10));
#line 149
  tmpbuf = (dqbuf_t )tmp;
#line 150
  dh = (struct qt_disk_dqdbheader *)buf;
#line 151
  info = & h->qh_info.u.v2_mdqi.dqi_qtree;
#line 153
  dh->dqdh_next_free = info->dqi_free_entry;
#line 154
  dh->dqdh_prev_free = (__u32 )0;
#line 155
  write_blk___2(h, blk, buf);
  }
#line 156
  if (info->dqi_free_entry) {
    {
#line 157
    read_blk___2(h, info->dqi_free_entry, tmpbuf);
#line 158
    ((struct qt_disk_dqdbheader *)tmpbuf)->dqdh_prev_free = blk;
#line 159
    write_blk___2(h, info->dqi_free_entry, tmpbuf);
    }
  }
  {
#line 161
  free((void *)tmpbuf);
#line 162
  info->dqi_free_entry = blk;
#line 163
  mark_quotafile_info_dirty(h);
  }
#line 164
  return;
}
}
#line 167 "/home/wheatley/newnew/temp/quota-4.01/quotaio_tree.c"
static uint find_free_dqentry___2(struct quota_handle *h , struct dquot *dquot , int *err ) 
{ 
  int blk ;
  int i ;
  struct qt_disk_dqdbheader *dh ;
  struct qtree_mem_dqinfo *info ;
  char *ddquot ;
  dqbuf_t buf ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;

  {
  {
#line 171
  info = & h->qh_info.u.v2_mdqi.dqi_qtree;
#line 175
  *err = 0;
#line 176
  tmp = smalloc((size_t )(1 << 10));
#line 176
  buf = (dqbuf_t )tmp;
#line 177
  dh = (struct qt_disk_dqdbheader *)buf;
  }
#line 178
  if (info->dqi_free_entry) {
    {
#line 179
    blk = (int )info->dqi_free_entry;
#line 180
    read_blk___2(h, (uint )blk, buf);
    }
  } else {
    {
#line 183
    blk = get_free_dqblk___2(h);
    }
#line 184
    if (blk < 0) {
      {
#line 185
      free((void *)buf);
#line 186
      *err = blk;
      }
#line 187
      return ((uint )0);
    }
    {
#line 189
    memset((void *)buf, 0, (size_t )(1 << 10));
#line 190
    info->dqi_free_entry = (unsigned int )blk;
#line 191
    mark_quotafile_info_dirty(h);
    }
  }
  {
#line 193
  tmp___0 = qtree_dqstr_in_blk(info);
  }
#line 193
  if ((int )dh->dqdh_entries + 1 >= tmp___0) {
    {
#line 194
    remove_free_dqentry___2(h, buf, (uint )blk);
    }
  }
#line 195
  dh->dqdh_entries = (__u16 )((int )dh->dqdh_entries + 1);
#line 197
  ddquot = buf + sizeof(struct qt_disk_dqdbheader );
#line 198
  i = 0;
  {
#line 198
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 198
    tmp___1 = qtree_dqstr_in_blk(info);
    }
#line 198
    if (i < tmp___1) {
      {
#line 198
      tmp___2 = qtree_entry_unused(info, ddquot);
      }
#line 198
      if (tmp___2) {
#line 198
        goto while_break;
      }
    } else {
#line 198
      goto while_break;
    }
#line 198
    i ++;
#line 198
    ddquot += info->dqi_entry_size;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 201
  tmp___4 = qtree_dqstr_in_blk(info);
  }
#line 201
  if (i == tmp___4) {
    {
#line 202
    tmp___3 = gettext("find_free_dqentry(): Data block full but it shouldn\'t.\n");
#line 202
    die(2, tmp___3);
    }
  }
  {
#line 203
  write_blk___2(h, (uint )blk, buf);
#line 204
  dquot->dq_dqb.u.v2_mdqb.dqb_off = (loff_t )(((unsigned long )(blk << 10) + sizeof(struct qt_disk_dqdbheader )) + (unsigned long )((unsigned int )i * info->dqi_entry_size));
#line 207
  free((void *)buf);
  }
#line 208
  return ((uint )blk);
}
}
#line 212 "/home/wheatley/newnew/temp/quota-4.01/quotaio_tree.c"
static int do_insert_tree___2(struct quota_handle *h , struct dquot *dquot , uint *treeblk ,
                              int depth ) 
{ 
  dqbuf_t buf ;
  int newson ;
  int newact ;
  u_int32_t *ref ;
  uint newblk ;
  int ret ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;

  {
  {
#line 215
  newson = 0;
#line 215
  newact = 0;
#line 218
  ret = 0;
#line 220
  tmp = smalloc((size_t )(1 << 10));
#line 220
  buf = (dqbuf_t )tmp;
  }
#line 221
  if (! *treeblk) {
    {
#line 222
    ret = get_free_dqblk___2(h);
    }
#line 223
    if (ret < 0) {
#line 224
      goto out_buf;
    }
    {
#line 225
    *treeblk = (uint )ret;
#line 226
    memset((void *)buf, 0, (size_t )(1 << 10));
#line 227
    newact = 1;
    }
  } else {
    {
#line 230
    read_blk___2(h, *treeblk, buf);
    }
  }
  {
#line 231
  ref = (u_int32_t *)buf;
#line 232
  tmp___0 = get_index___2(dquot->dq_id, depth);
#line 232
  newblk = *(ref + tmp___0);
  }
#line 233
  if (! newblk) {
#line 234
    newson = 1;
  }
#line 235
  if (depth == 3) {
#line 236
    if (newblk) {
      {
#line 237
      tmp___1 = get_index___2(dquot->dq_id, depth);
#line 237
      tmp___2 = gettext("Inserting already present quota entry (block %u).\n");
#line 237
      die(2, tmp___2, *(ref + tmp___1));
      }
    }
    {
#line 239
    newblk = find_free_dqentry___2(h, dquot, & ret);
    }
  } else {
    {
#line 242
    ret = do_insert_tree___2(h, dquot, & newblk, depth + 1);
    }
  }
#line 243
  if (newson) {
#line 243
    if (ret >= 0) {
      {
#line 244
      tmp___3 = get_index___2(dquot->dq_id, depth);
#line 244
      *(ref + tmp___3) = newblk;
#line 245
      write_blk___2(h, *treeblk, buf);
      }
    } else {
#line 243
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 247
  if (newact) {
#line 247
    if (ret < 0) {
      {
#line 248
      put_free_dqblk___2(h, buf, *treeblk);
      }
    }
  }
  out_buf: 
  {
#line 250
  free((void *)buf);
  }
#line 251
  return (ret);
}
}
#line 255 "/home/wheatley/newnew/temp/quota-4.01/quotaio_tree.c"
static void dq_insert_tree___2(struct quota_handle *h , struct dquot *dquot ) 
{ 
  uint tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;

  {
  {
#line 257
  tmp = (uint )1;
#line 259
  tmp___3 = do_insert_tree___2(h, dquot, & tmp, 0);
  }
#line 259
  if (tmp___3 < 0) {
    {
#line 260
    tmp___0 = __errno_location();
#line 260
    tmp___1 = strerror(*tmp___0);
#line 260
    tmp___2 = gettext("Cannot write quota (id %u): %s\n");
#line 260
    die(2, tmp___2, dquot->dq_id, tmp___1);
    }
  }
#line 261
  return;
}
}
#line 284 "/home/wheatley/newnew/temp/quota-4.01/quotaio_tree.c"
static void free_dqentry___2(struct quota_handle *h , struct dquot *dquot , uint blk ) 
{ 
  struct qt_disk_dqdbheader *dh ;
  struct qtree_mem_dqinfo *info ;
  dqbuf_t buf ;
  void *tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 287
  info = & h->qh_info.u.v2_mdqi.dqi_qtree;
#line 288
  tmp = smalloc((size_t )(1 << 10));
#line 288
  buf = (dqbuf_t )tmp;
  }
#line 290
  if (dquot->dq_dqb.u.v2_mdqb.dqb_off >> 10 != (loff_t )blk) {
    {
#line 291
    tmp___0 = gettext("Quota structure has offset to other block (%u) than it should (%u).\n");
#line 291
    die(2, tmp___0, blk, (uint )(dquot->dq_dqb.u.v2_mdqb.dqb_off >> 10));
    }
  }
  {
#line 293
  read_blk___2(h, blk, buf);
#line 294
  dh = (struct qt_disk_dqdbheader *)buf;
#line 295
  dh->dqdh_entries = (__u16 )((int )dh->dqdh_entries - 1);
  }
#line 296
  if (! dh->dqdh_entries) {
    {
#line 297
    remove_free_dqentry___2(h, buf, blk);
#line 298
    put_free_dqblk___2(h, buf, blk);
    }
  } else {
    {
#line 301
    memset((void *)(buf + (dquot->dq_dqb.u.v2_mdqb.dqb_off & (long )((1 << 10) - 1))),
           0, (size_t )info->dqi_entry_size);
#line 304
    tmp___1 = qtree_dqstr_in_blk(info);
    }
#line 304
    if ((int )dh->dqdh_entries == tmp___1 - 1) {
      {
#line 305
      insert_free_dqentry___2(h, buf, blk);
      }
    } else {
      {
#line 307
      write_blk___2(h, blk, buf);
      }
    }
  }
  {
#line 309
  dquot->dq_dqb.u.v2_mdqb.dqb_off = (loff_t )0;
#line 310
  free((void *)buf);
  }
#line 311
  return;
}
}
#line 314 "/home/wheatley/newnew/temp/quota-4.01/quotaio_tree.c"
static void remove_tree___2(struct quota_handle *h , struct dquot *dquot , uint *blk ,
                            int depth ) 
{ 
  dqbuf_t buf ;
  void *tmp ;
  uint newblk ;
  u_int32_t *ref ;
  int tmp___0 ;
  int i ;
  int tmp___1 ;

  {
  {
#line 316
  tmp = smalloc((size_t )(1 << 10));
#line 316
  buf = (dqbuf_t )tmp;
#line 318
  ref = (u_int32_t *)buf;
#line 320
  read_blk___2(h, *blk, buf);
#line 321
  tmp___0 = get_index___2(dquot->dq_id, depth);
#line 321
  newblk = *(ref + tmp___0);
  }
#line 322
  if (depth == 3) {
    {
#line 323
    free_dqentry___2(h, dquot, newblk);
#line 324
    newblk = (uint )0;
    }
  } else {
    {
#line 327
    remove_tree___2(h, dquot, & newblk, depth + 1);
    }
  }
#line 328
  if (! newblk) {
    {
#line 331
    tmp___1 = get_index___2(dquot->dq_id, depth);
#line 331
    *(ref + tmp___1) = (__u32 )0;
#line 332
    i = 0;
    }
    {
#line 332
    while (1) {
      while_continue: /* CIL Label */ ;
#line 332
      if (i < 1 << 10) {
#line 332
        if (! (! *(buf + i))) {
#line 332
          goto while_break;
        }
      } else {
#line 332
        goto while_break;
      }
#line 332
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 334
    if (i == 1 << 10) {
#line 334
      if (*blk != 1U) {
        {
#line 335
        put_free_dqblk___2(h, buf, *blk);
#line 336
        *blk = (uint )0;
        }
      } else {
        {
#line 339
        write_blk___2(h, *blk, buf);
        }
      }
    } else {
      {
#line 339
      write_blk___2(h, *blk, buf);
      }
    }
  }
  {
#line 341
  free((void *)buf);
  }
#line 342
  return;
}
}
#line 355 "/home/wheatley/newnew/temp/quota-4.01/quotaio_tree.c"
static loff_t find_block_dqentry___2(struct quota_handle *h , struct dquot *dquot ,
                                     uint blk ) 
{ 
  struct qtree_mem_dqinfo *info ;
  dqbuf_t buf ;
  void *tmp ;
  int i ;
  char *ddquot ;
  int tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;

  {
  {
#line 357
  info = & h->qh_info.u.v2_mdqi.dqi_qtree;
#line 358
  tmp = smalloc((size_t )(1 << 10));
#line 358
  buf = (dqbuf_t )tmp;
#line 360
  ddquot = buf + sizeof(struct qt_disk_dqdbheader );
#line 362
  read_blk___2(h, blk, buf);
#line 363
  i = 0;
  }
  {
#line 363
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 363
    tmp___0 = qtree_dqstr_in_blk(info);
    }
#line 363
    if (i < tmp___0) {
      {
#line 363
      tmp___1 = (*((info->dqi_ops)->is_id))((void *)ddquot, dquot);
      }
#line 363
      if (tmp___1) {
#line 363
        goto while_break;
      }
    } else {
#line 363
      goto while_break;
    }
#line 363
    i ++;
#line 363
    ddquot += info->dqi_entry_size;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 366
  tmp___3 = qtree_dqstr_in_blk(info);
  }
#line 366
  if (i == tmp___3) {
    {
#line 367
    tmp___2 = gettext("Quota for id %u referenced but not present.\n");
#line 367
    die(2, tmp___2, dquot->dq_id);
    }
  }
  {
#line 368
  free((void *)buf);
  }
#line 369
  return ((loff_t )(((unsigned long )(blk << 10) + sizeof(struct qt_disk_dqdbheader )) + (unsigned long )((unsigned int )i * info->dqi_entry_size)));
}
}
#line 374 "/home/wheatley/newnew/temp/quota-4.01/quotaio_tree.c"
static loff_t find_tree_dqentry___2(struct quota_handle *h , struct dquot *dquot ,
                                    uint blk , int depth ) 
{ 
  dqbuf_t buf ;
  void *tmp ;
  loff_t ret ;
  u_int32_t *ref ;
  int tmp___0 ;

  {
  {
#line 376
  tmp = smalloc((size_t )(1 << 10));
#line 376
  buf = (dqbuf_t )tmp;
#line 377
  ret = (loff_t )0;
#line 378
  ref = (u_int32_t *)buf;
#line 380
  read_blk___2(h, blk, buf);
#line 381
  ret = (loff_t )0;
#line 382
  tmp___0 = get_index___2(dquot->dq_id, depth);
#line 382
  blk = *(ref + tmp___0);
  }
#line 383
  if (! blk) {
#line 384
    goto out_buf;
  }
#line 385
  if (depth < 3) {
    {
#line 386
    ret = find_tree_dqentry___2(h, dquot, blk, depth + 1);
    }
  } else {
    {
#line 388
    ret = find_block_dqentry___2(h, dquot, blk);
    }
  }
  out_buf: 
  {
#line 390
  free((void *)buf);
  }
#line 391
  return (ret);
}
}
#line 395 "/home/wheatley/newnew/temp/quota-4.01/quotaio_tree.c"
__inline static loff_t find_dqentry___2(struct quota_handle *h , struct dquot *dquot ) 
{ 
  loff_t tmp ;

  {
  {
#line 397
  tmp = find_tree_dqentry___2(h, dquot, (uint )1, 0);
  }
#line 397
  return (tmp);
}
}
#line 441 "/home/wheatley/newnew/temp/quota-4.01/quotaio_tree.c"
static int report_block___2(struct dquot *dquot , uint blk , char *bitmap , int (*process_dquot)(struct dquot * ,
                                                                                                 char * ) ) 
{ 
  struct qtree_mem_dqinfo *info ;
  dqbuf_t buf ;
  void *tmp ;
  struct qt_disk_dqdbheader *dh ;
  char *ddata ;
  int entries ;
  int i ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 444
  info = & (dquot->dq_h)->qh_info.u.v2_mdqi.dqi_qtree;
#line 445
  tmp = smalloc((size_t )(1 << 10));
#line 445
  buf = (dqbuf_t )tmp;
#line 450
  *(bitmap + (blk >> 3)) = (char )((int )*(bitmap + (blk >> 3)) | (1 << (blk & 7U)));
#line 451
  read_blk___2(dquot->dq_h, blk, buf);
#line 452
  dh = (struct qt_disk_dqdbheader *)buf;
#line 453
  ddata = buf + sizeof(struct qt_disk_dqdbheader );
#line 454
  entries = (int )dh->dqdh_entries;
#line 455
  i = 0;
  }
  {
#line 455
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 455
    tmp___2 = qtree_dqstr_in_blk(info);
    }
#line 455
    if (! (i < tmp___2)) {
#line 455
      goto while_break;
    }
    {
#line 456
    tmp___1 = qtree_entry_unused(info, ddata);
    }
#line 456
    if (! tmp___1) {
      {
#line 457
      (*((info->dqi_ops)->disk2mem_dqblk))(dquot, (void *)ddata);
#line 458
      tmp___0 = (*process_dquot)(dquot, (char *)((void *)0));
      }
#line 458
      if (tmp___0 < 0) {
#line 459
        goto while_break;
      }
    }
#line 455
    i ++;
#line 455
    ddata += info->dqi_entry_size;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 461
  free((void *)buf);
  }
#line 462
  return (entries);
}
}
#line 465 "/home/wheatley/newnew/temp/quota-4.01/quotaio_tree.c"
static void check_reference___2(struct quota_handle *h , uint blk ) 
{ 
  char *tmp ;
  char *tmp___0 ;

  {
#line 467
  if (blk >= h->qh_info.u.v2_mdqi.dqi_qtree.dqi_blocks) {
    {
#line 468
    tmp = type2name(h->qh_type);
#line 468
    tmp___0 = gettext("Illegal reference (%u >= %u) in %s quota file on %s. Quota file is probably corrupted.\nPlease run quotacheck(8) and try again.\n");
#line 468
    die(2, tmp___0, blk, h->qh_info.u.v2_mdqi.dqi_qtree.dqi_blocks, tmp, h->qh_quotadev);
    }
  }
#line 469
  return;
}
}
#line 471 "/home/wheatley/newnew/temp/quota-4.01/quotaio_tree.c"
static int report_tree___2(struct dquot *dquot , uint blk , int depth , char *bitmap ,
                           int (*process_dquot)(struct dquot * , char * ) ) 
{ 
  int entries ;
  int i ;
  dqbuf_t buf ;
  void *tmp ;
  u_int32_t *ref ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 474
  entries = 0;
#line 475
  tmp = smalloc((size_t )(1 << 10));
#line 475
  buf = (dqbuf_t )tmp;
#line 476
  ref = (u_int32_t *)buf;
#line 478
  read_blk___2(dquot->dq_h, blk, buf);
  }
#line 479
  if (depth == 3) {
#line 480
    i = 0;
    {
#line 480
    while (1) {
      while_continue: /* CIL Label */ ;
#line 480
      if (! (i < (1 << 10) >> 2)) {
#line 480
        goto while_break;
      }
      {
#line 481
      blk = *(ref + i);
#line 482
      check_reference___2(dquot->dq_h, blk);
      }
#line 483
      if (blk) {
#line 483
        if (! ((int )*(bitmap + (blk >> 3)) & (1 << (blk & 7U)))) {
          {
#line 484
          tmp___0 = report_block___2(dquot, blk, bitmap, process_dquot);
#line 484
          entries += tmp___0;
          }
        }
      }
#line 480
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 488
    i = 0;
    {
#line 488
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 488
      if (! (i < (1 << 10) >> 2)) {
#line 488
        goto while_break___0;
      }
#line 489
      blk = *(ref + i);
#line 489
      if (blk) {
        {
#line 490
        check_reference___2(dquot->dq_h, blk);
#line 491
        tmp___1 = report_tree___2(dquot, blk, depth + 1, bitmap, process_dquot);
#line 491
        entries += tmp___1;
        }
      }
#line 488
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  {
#line 495
  free((void *)buf);
  }
#line 496
  return (entries);
}
}
#line 499 "/home/wheatley/newnew/temp/quota-4.01/quotaio_tree.c"
static uint find_set_bits___2(char *bmp , int blocks ) 
{ 
  uint i ;
  uint used ;

  {
#line 501
  used = (uint )0;
#line 503
  i = (uint )0;
  {
#line 503
  while (1) {
    while_continue: /* CIL Label */ ;
#line 503
    if (! (i < (uint )blocks)) {
#line 503
      goto while_break;
    }
#line 504
    if ((int )*(bmp + (i >> 3)) & (1 << (i & 7U))) {
#line 505
      used ++;
    }
#line 503
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 506
  return (used);
}
}
#line 105 "/home/wheatley/newnew/temp/quota-4.01/quotaio_generic.c"
static int scan_one_dquot___2(struct dquot *dquot , int (*get_dquot)(struct dquot * ) ) 
{ 
  int ret ;
  struct util_dqblk *dqb ;

  {
  {
#line 108
  dqb = & dquot->dq_dqb;
#line 110
  memset((void *)dqb, 0, sizeof(struct util_dqblk ));
#line 111
  ret = (*get_dquot)(dquot);
  }
#line 112
  if (ret < 0) {
#line 113
    return (ret);
  }
#line 114
  if (! dqb->dqb_bhardlimit) {
#line 114
    if (! dqb->dqb_bsoftlimit) {
#line 114
      if (! dqb->dqb_ihardlimit) {
#line 114
        if (! dqb->dqb_isoftlimit) {
#line 114
          if (! dqb->dqb_curinodes) {
#line 114
            if (! dqb->dqb_curspace) {
#line 115
              return (1);
            }
          }
        }
      }
    }
  }
#line 116
  return (0);
}
}
#line 18 "/home/wheatley/newnew/temp/quota-4.01/quotaio_rpc.c"
static int rpc_init_io___2(struct quota_handle *h ) ;
#line 19
static struct dquot *rpc_read_dquot___2(struct quota_handle *h , qid_t id___0 ) ;
#line 20
static int rpc_commit_dquot___2(struct dquot *dquot , int flags___7 ) ;
#line 31 "/home/wheatley/newnew/temp/quota-4.01/quotaio_rpc.c"
static int rpc_init_io___2(struct quota_handle *h ) 
{ 


  {
#line 34
  h->qh_info.dqi_max_b_limit = (uint64_t )(~ ((uint32_t )0));
#line 35
  h->qh_info.dqi_max_i_limit = (uint64_t )(~ ((uint32_t )0));
#line 36
  h->qh_info.dqi_max_b_usage = (uint64_t )(4294967295U << 10);
#line 37
  h->qh_info.dqi_max_i_usage = (uint64_t )(~ ((uint32_t )0));
#line 38
  return (0);
}
}
#line 47 "/home/wheatley/newnew/temp/quota-4.01/quotaio_rpc.c"
static struct dquot *rpc_read_dquot___2(struct quota_handle *h , qid_t id___0 ) 
{ 
  struct dquot *dquot ;
  struct dquot *tmp ;
  int ret ;
  int *tmp___0 ;

  {
  {
#line 50
  tmp = get_empty_dquot();
#line 50
  dquot = tmp;
#line 53
  dquot->dq_id = id___0;
#line 54
  dquot->dq_h = h;
#line 55
  ret = rpc_rquota_get(dquot);
  }
#line 55
  if (ret < 0) {
    {
#line 56
    tmp___0 = __errno_location();
#line 56
    *tmp___0 = - ret;
#line 57
    free((void *)dquot);
    }
#line 58
    return ((struct dquot *)((void *)0));
  }
#line 60
  return (dquot);
}
}
#line 70 "/home/wheatley/newnew/temp/quota-4.01/quotaio_rpc.c"
static int rpc_commit_dquot___2(struct dquot *dquot , int flags___7 ) 
{ 
  int ret ;
  char *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;

  {
#line 75
  if ((dquot->dq_h)->qh_io_flags & 4) {
    {
#line 76
    tmp = gettext("Trying to write quota to readonly quotafile on %s\n");
#line 76
    errstr(tmp, (dquot->dq_h)->qh_quotadev);
#line 77
    tmp___0 = __errno_location();
#line 77
    *tmp___0 = 1;
    }
#line 78
    return (-1);
  }
  {
#line 80
  ret = rpc_rquota_set((1024 << 8) | ((dquot->dq_h)->qh_type & 255), dquot);
  }
#line 80
  if (ret < 0) {
    {
#line 81
    tmp___1 = __errno_location();
#line 81
    *tmp___1 = - ret;
    }
#line 82
    return (-1);
  }
#line 84
  return (0);
}
}
#line 10 "/home/wheatley/newnew/temp/quota-4.01/rquota_clnt.c"
static struct timeval TIMEOUT___2  =    {(__time_t )25, (__suseconds_t )0};
#line 15 "/home/wheatley/newnew/temp/quota-4.01/rquota_clnt.c"
static getquota_rslt clnt_res___23  ;
#line 30 "/home/wheatley/newnew/temp/quota-4.01/rquota_clnt.c"
static getquota_rslt clnt_res___24  ;
#line 45 "/home/wheatley/newnew/temp/quota-4.01/rquota_clnt.c"
static setquota_rslt clnt_res___25  ;
#line 60 "/home/wheatley/newnew/temp/quota-4.01/rquota_clnt.c"
static setquota_rslt clnt_res___26  ;
#line 75 "/home/wheatley/newnew/temp/quota-4.01/rquota_clnt.c"
static getquota_rslt clnt_res___27  ;
#line 90 "/home/wheatley/newnew/temp/quota-4.01/rquota_clnt.c"
static getquota_rslt clnt_res___28  ;
#line 105 "/home/wheatley/newnew/temp/quota-4.01/rquota_clnt.c"
static setquota_rslt clnt_res___29  ;
#line 120 "/home/wheatley/newnew/temp/quota-4.01/rquota_clnt.c"
static setquota_rslt clnt_res___30  ;
#line 27 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v2.c"
static int v2_check_file___2(int fd , int type , int fmt___7 ) ;
#line 28
static int v2_init_io___2(struct quota_handle *h ) ;
#line 29
static int v2_new_io___2(struct quota_handle *h ) ;
#line 30
static int v2_write_info___2(struct quota_handle *h ) ;
#line 31
static struct dquot *v2_read_dquot___2(struct quota_handle *h , qid_t id___0 ) ;
#line 32
static int v2_commit_dquot___2(struct dquot *dquot , int flags___7 ) ;
#line 33
static int v2_scan_dquots___2(struct quota_handle *h , int (*process_dquot)(struct dquot *dquot ,
                                                                            char *dqname ) ) ;
#line 34
static int v2_report___2(struct quota_handle *h , int verbose ) ;
#line 53 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v2.c"
static void v2r0_disk2memdqblk___2(struct dquot *dquot , void *dp ) 
{ 
  struct util_dqblk *m ;
  struct v2r0_disk_dqblk *d ;
  struct v2r0_disk_dqblk empty ;
  int tmp ;

  {
  {
#line 55
  m = & dquot->dq_dqb;
#line 56
  d = (struct v2r0_disk_dqblk *)dp;
#line 58
  dquot->dq_id = d->dqb_id;
#line 59
  m->dqb_ihardlimit = (qsize_t )d->dqb_ihardlimit;
#line 60
  m->dqb_isoftlimit = (qsize_t )d->dqb_isoftlimit;
#line 61
  m->dqb_bhardlimit = (qsize_t )d->dqb_bhardlimit;
#line 62
  m->dqb_bsoftlimit = (qsize_t )d->dqb_bsoftlimit;
#line 63
  m->dqb_curinodes = (qsize_t )d->dqb_curinodes;
#line 64
  m->dqb_curspace = (qsize_t )((__le64 )d->dqb_curspace);
#line 65
  m->dqb_itime = (time_t )((__le64 )d->dqb_itime);
#line 66
  m->dqb_btime = (time_t )((__le64 )d->dqb_btime);
#line 68
  memset((void *)(& empty), 0, sizeof(struct v2r0_disk_dqblk ));
#line 69
  empty.dqb_itime = (u_int64_t )((__u64 )1);
#line 70
  tmp = memcmp((void const   *)(& empty), (void const   *)dp, sizeof(struct v2r0_disk_dqblk ));
  }
#line 70
  if (! tmp) {
#line 71
    m->dqb_itime = (time_t )0;
  }
#line 72
  return;
}
}
#line 77 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v2.c"
static void v2r0_mem2diskdqblk___2(void *dp , struct dquot *dquot ) 
{ 
  struct util_dqblk *m ;
  struct v2r0_disk_dqblk *d ;
  struct qtree_mem_dqinfo *info ;
  int tmp ;

  {
  {
#line 79
  m = & dquot->dq_dqb;
#line 80
  d = (struct v2r0_disk_dqblk *)dp;
#line 81
  info = & (dquot->dq_h)->qh_info.u.v2_mdqi.dqi_qtree;
#line 83
  d->dqb_ihardlimit = (__u32 )m->dqb_ihardlimit;
#line 84
  d->dqb_isoftlimit = (__u32 )m->dqb_isoftlimit;
#line 85
  d->dqb_bhardlimit = (__u32 )m->dqb_bhardlimit;
#line 86
  d->dqb_bsoftlimit = (__u32 )m->dqb_bsoftlimit;
#line 87
  d->dqb_curinodes = (__u32 )m->dqb_curinodes;
#line 88
  d->dqb_curspace = (u_int64_t )((__u64 )m->dqb_curspace);
#line 89
  d->dqb_itime = (u_int64_t )((__u64 )m->dqb_itime);
#line 90
  d->dqb_btime = (u_int64_t )((__u64 )m->dqb_btime);
#line 91
  d->dqb_id = dquot->dq_id;
#line 92
  tmp = qtree_entry_unused(info, (char *)dp);
  }
#line 92
  if (tmp) {
#line 93
    d->dqb_itime = (u_int64_t )((__u64 )1);
  }
#line 94
  return;
}
}
#line 96 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v2.c"
static int v2r0_is_id___2(void *dp , struct dquot *dquot ) 
{ 
  struct v2r0_disk_dqblk *d ;
  struct qtree_mem_dqinfo *info ;
  int tmp ;

  {
  {
#line 98
  d = (struct v2r0_disk_dqblk *)dp;
#line 99
  info = & (dquot->dq_h)->qh_info.u.v2_mdqi.dqi_qtree;
#line 101
  tmp = qtree_entry_unused(info, (char *)dp);
  }
#line 101
  if (tmp) {
#line 102
    return (0);
  }
#line 103
  return (d->dqb_id == dquot->dq_id);
}
}
#line 109 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v2.c"
static void v2r1_disk2memdqblk___2(struct dquot *dquot , void *dp ) 
{ 
  struct util_dqblk *m ;
  struct v2r1_disk_dqblk *d ;
  struct v2r1_disk_dqblk empty ;
  int tmp ;

  {
  {
#line 111
  m = & dquot->dq_dqb;
#line 112
  d = (struct v2r1_disk_dqblk *)dp;
#line 114
  dquot->dq_id = d->dqb_id;
#line 115
  m->dqb_ihardlimit = (qsize_t )((__le64 )d->dqb_ihardlimit);
#line 116
  m->dqb_isoftlimit = (qsize_t )((__le64 )d->dqb_isoftlimit);
#line 117
  m->dqb_bhardlimit = (qsize_t )((__le64 )d->dqb_bhardlimit);
#line 118
  m->dqb_bsoftlimit = (qsize_t )((__le64 )d->dqb_bsoftlimit);
#line 119
  m->dqb_curinodes = (qsize_t )((__le64 )d->dqb_curinodes);
#line 120
  m->dqb_curspace = (qsize_t )((__le64 )d->dqb_curspace);
#line 121
  m->dqb_itime = (time_t )((__le64 )d->dqb_itime);
#line 122
  m->dqb_btime = (time_t )((__le64 )d->dqb_btime);
#line 124
  memset((void *)(& empty), 0, sizeof(struct v2r1_disk_dqblk ));
#line 125
  empty.dqb_itime = (u_int64_t )((__u64 )1);
#line 126
  tmp = memcmp((void const   *)(& empty), (void const   *)dp, sizeof(struct v2r1_disk_dqblk ));
  }
#line 126
  if (! tmp) {
#line 127
    m->dqb_itime = (time_t )0;
  }
#line 128
  return;
}
}
#line 133 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v2.c"
static void v2r1_mem2diskdqblk___2(void *dp , struct dquot *dquot ) 
{ 
  struct util_dqblk *m ;
  struct v2r1_disk_dqblk *d ;
  int tmp ;

  {
  {
#line 135
  m = & dquot->dq_dqb;
#line 136
  d = (struct v2r1_disk_dqblk *)dp;
#line 138
  d->dqb_ihardlimit = (u_int64_t )((__u64 )m->dqb_ihardlimit);
#line 139
  d->dqb_isoftlimit = (u_int64_t )((__u64 )m->dqb_isoftlimit);
#line 140
  d->dqb_bhardlimit = (u_int64_t )((__u64 )m->dqb_bhardlimit);
#line 141
  d->dqb_bsoftlimit = (u_int64_t )((__u64 )m->dqb_bsoftlimit);
#line 142
  d->dqb_curinodes = (u_int64_t )((__u64 )m->dqb_curinodes);
#line 143
  d->dqb_curspace = (u_int64_t )((__u64 )m->dqb_curspace);
#line 144
  d->dqb_itime = (u_int64_t )((__u64 )m->dqb_itime);
#line 145
  d->dqb_btime = (u_int64_t )((__u64 )m->dqb_btime);
#line 146
  d->dqb_id = dquot->dq_id;
#line 147
  d->dqb_pad = (u_int32_t )0;
#line 148
  tmp = qtree_entry_unused(& (dquot->dq_h)->qh_info.u.v2_mdqi.dqi_qtree, (char *)dp);
  }
#line 148
  if (tmp) {
#line 149
    d->dqb_itime = (u_int64_t )((__u64 )1);
  }
#line 150
  return;
}
}
#line 152 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v2.c"
static int v2r1_is_id___2(void *dp , struct dquot *dquot ) 
{ 
  struct v2r1_disk_dqblk *d ;
  struct qtree_mem_dqinfo *info ;
  int tmp ;

  {
  {
#line 154
  d = (struct v2r1_disk_dqblk *)dp;
#line 155
  info = & (dquot->dq_h)->qh_info.u.v2_mdqi.dqi_qtree;
#line 157
  tmp = qtree_entry_unused(info, (char *)dp);
  }
#line 157
  if (tmp) {
#line 158
    return (0);
  }
#line 159
  return (d->dqb_id == dquot->dq_id);
}
}
#line 162 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v2.c"
static struct qtree_fmt_operations v2r0_fmt_ops___2  =    {& v2r0_mem2diskdqblk___2, & v2r0_disk2memdqblk___2, & v2r0_is_id___2};
#line 168 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v2.c"
static struct qtree_fmt_operations v2r1_fmt_ops___2  =    {& v2r1_mem2diskdqblk___2, & v2r1_disk2memdqblk___2, & v2r1_is_id___2};
#line 226 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v2.c"
static int v2_read_header___2(int fd , struct v2_disk_dqheader *h ) 
{ 
  ssize_t tmp ;

  {
  {
#line 228
  lseek(fd, (__off64_t )0, 0);
#line 229
  tmp = read(fd, (void *)h, sizeof(struct v2_disk_dqheader ));
  }
#line 229
  if ((unsigned long )tmp != sizeof(struct v2_disk_dqheader )) {
#line 230
    return (0);
  }
#line 231
  return (1);
}
}
#line 237 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v2.c"
static int v2_check_file___2(int fd , int type , int fmt___7 ) 
{ 
  struct v2_disk_dqheader h ;
  int file_magics[2] ;
  int known_versions___0[2] ;
  int version___0 ;
  int tmp ;
  char *tmp___0 ;
  __u32 tmp___1 ;

  {
  {
#line 240
  file_magics[0] = -641720559;
#line 240
  file_magics[1] = -641722073;
#line 241
  known_versions___0[0] = 1;
#line 241
  known_versions___0[1] = 1;
#line 244
  tmp = v2_read_header___2(fd, & h);
  }
#line 244
  if (! tmp) {
#line 245
    return (0);
  }
#line 246
  if (fmt___7 == 1) {
#line 247
    version___0 = 0;
  } else
#line 248
  if (fmt___7 == 2) {
#line 249
    version___0 = 1;
  } else {
#line 251
    return (0);
  }
#line 253
  if (h.dqh_magic != (__u32 )file_magics[type]) {
    {
#line 254
    tmp___1 = __fswab32(h.dqh_magic);
    }
#line 254
    if (tmp___1 == (__u32 )file_magics[type]) {
      {
#line 255
      tmp___0 = gettext("Your quota file is stored in wrong endianity. Please use convertquota(8) to convert it.\n");
#line 255
      die(3, tmp___0);
      }
    }
#line 256
    return (0);
  }
#line 258
  if (h.dqh_version > (__u32 )known_versions___0[type]) {
#line 259
    return (0);
  }
#line 260
  if ((__u32 )version___0 != h.dqh_version) {
#line 261
    return (0);
  }
#line 262
  return (1);
}
}
#line 268 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v2.c"
static int v2_init_io___2(struct quota_handle *h ) 
{ 
  int tmp ;
  struct v2_kern_dqinfo kdqinfo ;
  int *tmp___0 ;
  long tmp___1 ;
  struct v2_disk_dqinfo ddqinfo ;
  struct v2_disk_dqheader header ;
  int tmp___2 ;
  ssize_t tmp___3 ;

  {
#line 270
  if (h->qh_io_flags & 1) {
#line 271
    if (kernel_iface == 3) {
      {
#line 272
      tmp = vfs_get_info(h);
      }
#line 272
      if (tmp < 0) {
#line 273
        return (-1);
      }
    } else {
      {
#line 278
      tmp___1 = quotactl((2304 << 8) | (h->qh_type & 255), (char const   *)(h->qh_quotadev),
                         (qid_t )0, (caddr_t )((void *)(& kdqinfo)));
      }
#line 278
      if (tmp___1 < 0L) {
        {
#line 280
        tmp___0 = __errno_location();
        }
#line 280
        if (*tmp___0 == 1) {
#line 281
          return (0);
        }
#line 282
        return (-1);
      }
#line 284
      h->qh_info.dqi_bgrace = (time_t )kdqinfo.dqi_bgrace;
#line 285
      h->qh_info.dqi_igrace = (time_t )kdqinfo.dqi_igrace;
#line 286
      h->qh_info.u.v2_mdqi.dqi_flags = kdqinfo.dqi_flags;
#line 287
      h->qh_info.u.v2_mdqi.dqi_qtree.dqi_blocks = kdqinfo.dqi_blocks;
#line 288
      h->qh_info.u.v2_mdqi.dqi_qtree.dqi_free_blk = kdqinfo.dqi_free_blk;
#line 289
      h->qh_info.u.v2_mdqi.dqi_qtree.dqi_free_entry = kdqinfo.dqi_free_entry;
    }
  }
#line 292
  if (h->qh_fd != -1) {
    {
#line 296
    tmp___2 = v2_read_header___2(h->qh_fd, & header);
    }
#line 296
    if (! tmp___2) {
#line 297
      return (-1);
    }
    {
#line 299
    lseek(h->qh_fd, (__off64_t )sizeof(struct v2_disk_dqheader ), 0);
#line 300
    tmp___3 = read(h->qh_fd, (void *)(& ddqinfo), sizeof(ddqinfo));
    }
#line 300
    if ((unsigned long )tmp___3 != sizeof(ddqinfo)) {
#line 301
      return (-1);
    }
#line 303
    if (! (h->qh_io_flags & 1)) {
      {
#line 304
      v2_disk2memdqinfo(& h->qh_info, & ddqinfo);
      }
    } else {
#line 306
      h->qh_info.u.v2_mdqi.dqi_qtree.dqi_blocks = ddqinfo.dqi_blocks;
    }
#line 308
    if (header.dqh_version == 0U) {
#line 309
      h->qh_info.u.v2_mdqi.dqi_qtree.dqi_entry_size = (unsigned int )sizeof(struct v2r0_disk_dqblk );
#line 310
      h->qh_info.u.v2_mdqi.dqi_qtree.dqi_ops = & v2r0_fmt_ops___2;
#line 311
      h->qh_info.dqi_max_b_limit = (uint64_t )(~ ((uint32_t )0));
#line 312
      h->qh_info.dqi_max_i_limit = (uint64_t )(~ ((uint32_t )0));
#line 313
      h->qh_info.dqi_max_b_usage = ~ ((uint64_t )0);
#line 314
      h->qh_info.dqi_max_i_usage = (uint64_t )(~ ((uint32_t )0));
    } else {
#line 316
      h->qh_info.u.v2_mdqi.dqi_qtree.dqi_entry_size = (unsigned int )sizeof(struct v2r1_disk_dqblk );
#line 317
      h->qh_info.u.v2_mdqi.dqi_qtree.dqi_ops = & v2r1_fmt_ops___2;
#line 318
      h->qh_info.dqi_max_b_limit = ~ ((uint64_t )0);
#line 319
      h->qh_info.dqi_max_i_limit = ~ ((uint64_t )0);
#line 320
      h->qh_info.dqi_max_b_usage = ~ ((uint64_t )0);
#line 321
      h->qh_info.dqi_max_i_usage = ~ ((uint64_t )0);
    }
  } else {
#line 325
    h->qh_info.u.v2_mdqi.dqi_qtree.dqi_ops = (struct qtree_fmt_operations *)((void *)0);
  }
#line 327
  return (0);
}
}
#line 333 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v2.c"
static int v2_new_io___2(struct quota_handle *h ) 
{ 
  int file_magics[2] ;
  struct v2_disk_dqheader ddqheader ;
  struct v2_disk_dqinfo ddqinfo ;
  int version___0 ;
  ssize_t tmp ;
  ssize_t tmp___0 ;

  {
#line 335
  file_magics[0] = -641720559;
#line 335
  file_magics[1] = -641722073;
#line 340
  if (h->qh_fmt == 1) {
#line 341
    version___0 = 0;
  } else
#line 342
  if (h->qh_fmt == 2) {
#line 343
    version___0 = 1;
  } else {
#line 345
    return (-1);
  }
  {
#line 348
  ddqheader.dqh_magic = (__u32 )file_magics[h->qh_type];
#line 349
  ddqheader.dqh_version = (__u32 )version___0;
#line 350
  lseek(h->qh_fd, (__off64_t )0, 0);
#line 351
  tmp = write(h->qh_fd, (void const   *)(& ddqheader), sizeof(ddqheader));
  }
#line 351
  if ((unsigned long )tmp != sizeof(ddqheader)) {
#line 352
    return (-1);
  }
#line 354
  h->qh_info.dqi_bgrace = (time_t )604800;
#line 355
  h->qh_info.dqi_igrace = (time_t )604800;
#line 356
  h->qh_info.u.v2_mdqi.dqi_flags = (uint )0;
#line 357
  h->qh_info.u.v2_mdqi.dqi_qtree.dqi_blocks = 2U;
#line 358
  h->qh_info.u.v2_mdqi.dqi_qtree.dqi_free_blk = 0U;
#line 359
  h->qh_info.u.v2_mdqi.dqi_qtree.dqi_free_entry = 0U;
#line 360
  if (version___0 == 0) {
#line 361
    h->qh_info.u.v2_mdqi.dqi_qtree.dqi_entry_size = (unsigned int )sizeof(struct v2r0_disk_dqblk );
#line 362
    h->qh_info.u.v2_mdqi.dqi_qtree.dqi_ops = & v2r0_fmt_ops___2;
#line 363
    h->qh_info.dqi_max_b_limit = (uint64_t )(~ ((uint32_t )0));
#line 364
    h->qh_info.dqi_max_i_limit = (uint64_t )(~ ((uint32_t )0));
#line 365
    h->qh_info.dqi_max_b_usage = ~ ((uint64_t )0);
#line 366
    h->qh_info.dqi_max_i_usage = (uint64_t )(~ ((uint32_t )0));
  } else
#line 367
  if (version___0 == 1) {
#line 368
    h->qh_info.u.v2_mdqi.dqi_qtree.dqi_entry_size = (unsigned int )sizeof(struct v2r1_disk_dqblk );
#line 369
    h->qh_info.u.v2_mdqi.dqi_qtree.dqi_ops = & v2r1_fmt_ops___2;
#line 370
    h->qh_info.dqi_max_b_limit = ~ ((uint64_t )0);
#line 371
    h->qh_info.dqi_max_i_limit = ~ ((uint64_t )0);
#line 372
    h->qh_info.dqi_max_b_usage = ~ ((uint64_t )0);
#line 373
    h->qh_info.dqi_max_i_usage = ~ ((uint64_t )0);
  }
  {
#line 375
  v2_mem2diskdqinfo(& ddqinfo, & h->qh_info);
#line 376
  lseek(h->qh_fd, (__off64_t )sizeof(struct v2_disk_dqheader ), 0);
#line 377
  tmp___0 = write(h->qh_fd, (void const   *)(& ddqinfo), sizeof(ddqinfo));
  }
#line 377
  if ((unsigned long )tmp___0 != sizeof(ddqinfo)) {
#line 378
    return (-1);
  }
#line 379
  return (0);
}
}
#line 385 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v2.c"
static int v2_write_info___2(struct quota_handle *h ) 
{ 
  char *tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  struct v2_kern_dqinfo kdqinfo ;
  long tmp___2 ;
  long tmp___3 ;
  struct v2_disk_dqinfo ddqinfo ;
  ssize_t tmp___4 ;

  {
#line 387
  if (h->qh_io_flags & 4) {
    {
#line 388
    tmp = gettext("Trying to write info to readonly quotafile on %s\n");
#line 388
    errstr(tmp, h->qh_quotadev);
#line 389
    tmp___0 = __errno_location();
#line 389
    *tmp___0 = 1;
    }
#line 390
    return (-1);
  }
#line 392
  if (h->qh_io_flags & 1) {
#line 393
    if (kernel_iface == 3) {
      {
#line 394
      tmp___1 = vfs_set_info(h, 3);
      }
#line 394
      if (tmp___1) {
#line 395
        return (-1);
      }
    } else {
      {
#line 400
      kdqinfo.dqi_bgrace = (unsigned int )h->qh_info.dqi_bgrace;
#line 401
      kdqinfo.dqi_igrace = (unsigned int )h->qh_info.dqi_igrace;
#line 402
      kdqinfo.dqi_flags = h->qh_info.u.v2_mdqi.dqi_flags;
#line 403
      kdqinfo.dqi_blocks = h->qh_info.u.v2_mdqi.dqi_qtree.dqi_blocks;
#line 404
      kdqinfo.dqi_free_blk = h->qh_info.u.v2_mdqi.dqi_qtree.dqi_free_blk;
#line 405
      kdqinfo.dqi_free_entry = h->qh_info.u.v2_mdqi.dqi_qtree.dqi_free_entry;
#line 406
      tmp___2 = quotactl((2816 << 8) | (h->qh_type & 255), (char const   *)(h->qh_quotadev),
                         (qid_t )0, (caddr_t )((void *)(& kdqinfo)));
      }
#line 406
      if (tmp___2 < 0L) {
#line 408
        return (-1);
      } else {
        {
#line 406
        tmp___3 = quotactl((3072 << 8) | (h->qh_type & 255), (char const   *)(h->qh_quotadev),
                           (qid_t )0, (caddr_t )((void *)(& kdqinfo)));
        }
#line 406
        if (tmp___3 < 0L) {
#line 408
          return (-1);
        }
      }
    }
  } else {
    {
#line 414
    v2_mem2diskdqinfo(& ddqinfo, & h->qh_info);
#line 415
    lseek(h->qh_fd, (__off64_t )sizeof(struct v2_disk_dqheader ), 0);
#line 416
    tmp___4 = write(h->qh_fd, (void const   *)(& ddqinfo), sizeof(ddqinfo));
    }
#line 416
    if ((unsigned long )tmp___4 != sizeof(ddqinfo)) {
#line 417
      return (-1);
    }
  }
#line 419
  return (0);
}
}
#line 426 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v2.c"
static struct dquot *v2_read_dquot___2(struct quota_handle *h , qid_t id___0 ) 
{ 
  struct dquot *dquot ;
  struct dquot *tmp ;
  int tmp___0 ;
  struct v2_kern_dqblk kdqblk ;
  long tmp___1 ;
  struct dquot *tmp___2 ;

  {
#line 428
  if (h->qh_io_flags & 1) {
    {
#line 429
    tmp = get_empty_dquot();
#line 429
    dquot = tmp;
#line 431
    dquot->dq_id = id___0;
#line 432
    dquot->dq_h = h;
#line 433
    dquot->dq_dqb.u.v2_mdqb.dqb_off = (loff_t )0;
#line 434
    memset((void *)(& dquot->dq_dqb), 0, sizeof(struct util_dqblk ));
    }
#line 435
    if (kernel_iface == 3) {
      {
#line 436
      tmp___0 = vfs_get_dquot(dquot);
      }
#line 436
      if (tmp___0 < 0) {
        {
#line 437
        free((void *)dquot);
        }
#line 438
        return ((struct dquot *)((void *)0));
      }
    } else {
      {
#line 444
      tmp___1 = quotactl((3328 << 8) | (h->qh_type & 255), (char const   *)(h->qh_quotadev),
                         id___0, (caddr_t )((void *)(& kdqblk)));
      }
#line 444
      if (tmp___1 < 0L) {
        {
#line 445
        free((void *)dquot);
        }
#line 446
        return ((struct dquot *)((void *)0));
      }
      {
#line 448
      v2_kern2utildqblk(& dquot->dq_dqb, & kdqblk);
      }
    }
#line 450
    return (dquot);
  }
  {
#line 452
  tmp___2 = qtree_read_dquot(h, id___0);
  }
#line 452
  return (tmp___2);
}
}
#line 459 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v2.c"
static int v2_commit_dquot___2(struct dquot *dquot , int flags___7 ) 
{ 
  struct util_dqblk *b ;
  char *tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  struct v2_kern_dqblk kdqblk ;
  int cmd ;
  int *tmp___2 ;
  long tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;

  {
#line 461
  b = & dquot->dq_dqb;
#line 463
  if ((dquot->dq_h)->qh_io_flags & 4) {
    {
#line 464
    tmp = gettext("Trying to write quota to readonly quotafile on %s\n");
#line 464
    errstr(tmp, (dquot->dq_h)->qh_quotadev);
#line 465
    tmp___0 = __errno_location();
#line 465
    *tmp___0 = 1;
    }
#line 466
    return (-1);
  }
#line 468
  if ((dquot->dq_h)->qh_io_flags & 1) {
#line 469
    if (kernel_iface == 3) {
      {
#line 470
      tmp___1 = vfs_set_dquot(dquot, flags___7);
      }
#line 470
      if (tmp___1 < 0) {
#line 471
        return (-1);
      }
    } else {
#line 477
      if (flags___7 == 10) {
#line 478
        cmd = 3840;
      } else
#line 479
      if (flags___7 == 5) {
#line 480
        cmd = 1792;
      } else
#line 481
      if (flags___7 & 48) {
        {
#line 482
        tmp___2 = __errno_location();
#line 482
        *tmp___2 = 22;
        }
#line 483
        return (-1);
      } else {
#line 486
        cmd = 3584;
      }
      {
#line 487
      v2_util2kerndqblk(& kdqblk, & dquot->dq_dqb);
#line 488
      tmp___3 = quotactl((cmd << 8) | ((dquot->dq_h)->qh_type & 255), (char const   *)((dquot->dq_h)->qh_quotadev),
                         dquot->dq_id, (caddr_t )((void *)(& kdqblk)));
      }
#line 488
      if (tmp___3 < 0L) {
#line 490
        return (-1);
      }
    }
#line 492
    return (0);
  }
#line 494
  if (! b->dqb_curspace) {
#line 494
    if (! b->dqb_curinodes) {
#line 494
      if (! b->dqb_bsoftlimit) {
#line 494
        if (! b->dqb_isoftlimit) {
#line 494
          if (! b->dqb_bhardlimit) {
#line 494
            if (! b->dqb_ihardlimit) {
              {
#line 496
              qtree_delete_dquot(dquot);
              }
            } else {
#line 494
              goto _L___3;
            }
          } else {
#line 494
            goto _L___3;
          }
        } else {
#line 494
          goto _L___3;
        }
      } else {
#line 494
        goto _L___3;
      }
    } else {
#line 494
      goto _L___3;
    }
  } else {
    _L___3: /* CIL Label */ 
    {
#line 498
    tmp___5 = check_dquot_range(dquot);
    }
#line 498
    if (tmp___5 < 0) {
      {
#line 499
      tmp___4 = __errno_location();
#line 499
      *tmp___4 = 34;
      }
#line 500
      return (-1);
    }
    {
#line 502
    qtree_write_dquot(dquot);
    }
  }
#line 504
  return (0);
}
}
#line 507 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v2.c"
static int v2_scan_dquots___2(struct quota_handle *h , int (*process_dquot)(struct dquot *dquot ,
                                                                            char *dqname ) ) 
{ 
  int tmp ;

  {
  {
#line 509
  tmp = qtree_scan_dquots(h, process_dquot);
  }
#line 509
  return (tmp);
}
}
#line 513 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v2.c"
static int v2_report___2(struct quota_handle *h , int verbose ) 
{ 
  struct v2_mem_dqinfo *info ;
  char *tmp ;

  {
#line 515
  if (verbose) {
    {
#line 516
    info = & h->qh_info.u.v2_mdqi;
#line 518
    tmp = gettext("Statistics:\nTotal blocks: %u\nData blocks: %u\nEntries: %u\nUsed average: %f\n");
#line 518
    printf((char const   */* __restrict  */)tmp, info->dqi_qtree.dqi_blocks, info->dqi_data_blocks,
           info->dqi_used_entries, (double )((float )info->dqi_used_entries / (float )info->dqi_data_blocks));
    }
  }
#line 522
  return (0);
}
}
#line 23 "/home/wheatley/newnew/temp/quota-4.01/common.c"
static int enable_syslog___3  =    0;
#line 31 "/home/wheatley/newnew/temp/quota-4.01/common.c"
static void do_syslog___3(int level , char const   *format , va_list args ) 
{ 
  char buf[1024] ;
  int i ;
  int j ;
  int tmp ;

  {
  {
#line 36
  vsnprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)format,
            args);
#line 39
  i = 0;
  }
  {
#line 39
  while (1) {
    while_continue: /* CIL Label */ ;
#line 39
    if (! buf[i]) {
#line 39
      goto while_break;
    }
#line 40
    j = i;
    {
#line 40
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 40
      if (buf[j]) {
#line 40
        if (! ((int )buf[j] != 10)) {
#line 40
          goto while_break___0;
        }
      } else {
#line 40
        goto while_break___0;
      }
#line 40
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 41
    if ((int )buf[j] == 10) {
#line 42
      tmp = j;
#line 42
      j ++;
#line 42
      buf[tmp] = (char )'\000';
    }
    {
#line 43
    syslog(level, "%s", buf + i);
#line 39
    i = j;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 45
  return;
}
}
#line 103 "/home/wheatley/newnew/temp/quota-4.01/rquota.h"
getquota_rslt *rquotaproc_getquota_1_svc(getquota_args *argp , struct svc_req *rqstp ) ;
#line 106
getquota_rslt *rquotaproc_getactivequota_1_svc(getquota_args *argp , struct svc_req *rqstp ) ;
#line 109
setquota_rslt *rquotaproc_setquota_1_svc(setquota_args *argp , struct svc_req *rqstp ) ;
#line 112
setquota_rslt *rquotaproc_setactivequota_1_svc(setquota_args *argp , struct svc_req *rqstp ) ;
#line 134
getquota_rslt *rquotaproc_getquota_2_svc(ext_getquota_args *argp , struct svc_req *rqstp ) ;
#line 136
getquota_rslt *rquotaproc_getactivequota_2_svc(ext_getquota_args *argp , struct svc_req *rqstp ) ;
#line 138
setquota_rslt *rquotaproc_setquota_2_svc(ext_setquota_args *argp , struct svc_req *rqstp ) ;
#line 140
setquota_rslt *rquotaproc_setactivequota_2_svc(ext_setquota_args *argp , struct svc_req *rqstp ) ;
#line 53 "/home/wheatley/newnew/temp/quota-4.01/rquota_server.c"
int flags ;
#line 55
char nfs_pseudoroot[4096] ;
#line 60
struct authunix_parms *unix_cred ;
#line 62 "/home/wheatley/newnew/temp/quota-4.01/rquota_server.c"
int in_group(gid_t *gids , u_int len , gid_t gid ) 
{ 
  gid_t *gidsp ;

  {
#line 64
  gidsp = gids + len;
  {
#line 66
  while (1) {
    while_continue: /* CIL Label */ ;
#line 66
    if (! ((unsigned long )gidsp > (unsigned long )gids)) {
#line 66
      goto while_break;
    }
#line 67
    gids --;
#line 67
    if (*gids == gid) {
#line 68
      return (1);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 70
  return (0);
}
}
#line 97 "/home/wheatley/newnew/temp/quota-4.01/rquota_server.c"
static int find_block_shift(qsize_t hard , qsize_t soft , qsize_t cur ) 
{ 
  int shift ;
  qsize_t value ;

  {
#line 100
  value = hard;
#line 102
  if (value < soft) {
#line 103
    value = soft;
  }
#line 104
  if (value < cur) {
#line 105
    value = cur;
  }
#line 106
  value >>= 32;
#line 107
  shift = 10;
  {
#line 107
  while (1) {
    while_continue: /* CIL Label */ ;
#line 107
    if (! value) {
#line 107
      goto while_break;
    }
#line 108
    value >>= 1;
#line 107
    shift ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 110
  return (shift);
}
}
#line 113 "/home/wheatley/newnew/temp/quota-4.01/rquota_server.c"
__inline static void servutil2netdqblk(struct rquota *n , struct util_dqblk *u ) 
{ 
  time_t now___0 ;
  int shift ;

  {
  {
#line 118
  shift = find_block_shift(u->dqb_bhardlimit, u->dqb_bsoftlimit, ((u->dqb_curspace + (qsize_t )(1 << 10)) - 1L) >> 10);
#line 120
  n->rq_bsize = 1 << shift;
#line 121
  n->rq_bhardlimit = (u_int )(u->dqb_bhardlimit >> (shift - 10));
#line 122
  n->rq_bsoftlimit = (u_int )(u->dqb_bsoftlimit >> (shift - 10));
#line 123
  n->rq_fhardlimit = (u_int )u->dqb_ihardlimit;
#line 124
  n->rq_fsoftlimit = (u_int )u->dqb_isoftlimit;
#line 125
  n->rq_curblocks = (u_int )((((u->dqb_curspace + (qsize_t )(1 << 10)) - 1L) >> 10) >> (shift - 10));
#line 126
  n->rq_curfiles = (u_int )u->dqb_curinodes;
#line 128
  time(& now___0);
  }
#line 129
  if (u->dqb_btime) {
#line 130
    n->rq_btimeleft = (u_int )(u->dqb_btime - now___0);
  } else {
#line 132
    n->rq_btimeleft = (u_int )0;
  }
#line 133
  if (u->dqb_itime) {
#line 134
    n->rq_ftimeleft = (u_int )(u->dqb_itime - now___0);
  } else {
#line 136
    n->rq_ftimeleft = (u_int )0;
  }
#line 137
  return;
}
}
#line 141 "/home/wheatley/newnew/temp/quota-4.01/rquota_server.c"
static setquota_rslt result  ;
#line 139 "/home/wheatley/newnew/temp/quota-4.01/rquota_server.c"
setquota_rslt *setquotainfo(int lflags , caddr_t *argp , struct svc_req *rqstp ) 
{ 


  {
#line 229
  result.status = (qr_status )3;
#line 231
  return (& result);
}
}
#line 236 "/home/wheatley/newnew/temp/quota-4.01/rquota_server.c"
static getquota_rslt result___0  ;
#line 234 "/home/wheatley/newnew/temp/quota-4.01/rquota_server.c"
getquota_rslt *getquotainfo(int lflags , caddr_t *argp , struct svc_req *rqstp ) 
{ 
  union __anonunion_arguments_78 arguments ;
  struct dquot *dquot ;
  struct mount_entry *mnt___2 ;
  char pathname[4096] ;
  unsigned int tmp ;
  char *pathp ;
  int id___0 ;
  int type ;
  struct quota_handle *handles[2] ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 241
  dquot = (struct dquot *)((void *)0);
#line 243
  pathname[0] = (char)0;
#line 243
  tmp = 1U;
  {
#line 243
  while (1) {
    while_continue: /* CIL Label */ ;
#line 243
    if (tmp >= 4096U) {
#line 243
      goto while_break;
    }
#line 243
    pathname[tmp] = (char)0;
#line 243
    tmp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 244
  pathp = pathname;
#line 246
  handles[0] = (struct quota_handle *)((void *)0);
#line 246
  handles[1] = (struct quota_handle *)((void *)0);
#line 251
  if (lflags & 1) {
#line 252
    arguments.ext_args = (ext_getquota_args *)argp;
#line 253
    id___0 = (arguments.ext_args)->gqa_id;
#line 254
    type = (arguments.ext_args)->gqa_type;
#line 255
    if ((int )*((arguments.ext_args)->gqa_pathp + 0) != 47) {
      {
#line 256
      sstrncpy(pathname, (char const   *)(nfs_pseudoroot), (size_t )4096);
      }
    }
    {
#line 257
    sstrncat(pathname, (char const   *)(arguments.ext_args)->gqa_pathp, (size_t )4096);
    }
#line 259
    if (type == 0) {
#line 259
      if (unix_cred->aup_uid) {
#line 259
        if (unix_cred->aup_uid != (__uid_t )id___0) {
#line 260
          result___0.status = (qr_status )3;
#line 261
          return (& result___0);
        }
      }
    }
#line 264
    if (type == 1) {
#line 264
      if (unix_cred->aup_uid) {
#line 264
        if (unix_cred->aup_gid != (__gid_t )id___0) {
          {
#line 264
          tmp___0 = in_group(unix_cred->aup_gids, unix_cred->aup_len, (gid_t )id___0);
          }
#line 264
          if (! tmp___0) {
#line 266
            result___0.status = (qr_status )3;
#line 267
            return (& result___0);
          }
        }
      }
    }
  } else {
#line 271
    arguments.args = (getquota_args *)argp;
#line 272
    id___0 = (arguments.args)->gqa_uid;
#line 273
    type = 0;
#line 274
    if ((int )*((arguments.ext_args)->gqa_pathp + 0) != 47) {
      {
#line 275
      sstrncpy(pathname, (char const   *)(nfs_pseudoroot), (size_t )4096);
      }
    }
    {
#line 276
    sstrncat(pathname, (char const   *)(arguments.args)->gqa_pathp, (size_t )4096);
    }
#line 278
    if (unix_cred->aup_uid) {
#line 278
      if (unix_cred->aup_uid != (__uid_t )id___0) {
#line 279
        result___0.status = (qr_status )3;
#line 280
        return (& result___0);
      }
    }
  }
#line 284
  result___0.status = (qr_status )2;
#line 286
  if (flags & 4) {
#line 286
    tmp___1 = 0;
  } else {
#line 286
    tmp___1 = 2;
  }
  {
#line 286
  tmp___2 = init_mounts_scan(1, & pathp, 37 | tmp___1);
  }
#line 286
  if (tmp___2 < 0) {
#line 287
    goto out;
  }
  {
#line 288
  mnt___2 = get_next_mount();
  }
#line 288
  if (! mnt___2) {
    {
#line 289
    end_mounts_scan();
    }
#line 290
    goto out;
  }
  {
#line 292
  handles[0] = init_io(mnt___2, type, -1, 1);
  }
#line 292
  if (! handles[0]) {
    {
#line 293
    end_mounts_scan();
    }
#line 294
    goto out;
  }
  {
#line 296
  end_mounts_scan();
  }
#line 297
  if (! (lflags & 2)) {
    {
#line 298
    dquot = (*(((handles[0])->qh_ops)->read_dquot))(handles[0], (qid_t )id___0);
    }
  } else
#line 297
  if ((handles[0])->qh_io_flags & 1) {
    {
#line 298
    dquot = (*(((handles[0])->qh_ops)->read_dquot))(handles[0], (qid_t )id___0);
    }
  }
#line 299
  if (dquot) {
#line 300
    result___0.status = (qr_status )1;
#line 301
    if ((handles[0])->qh_io_flags & 1) {
#line 301
      result___0.getquota_rslt_u.gqr_rquota.rq_active = 1;
    } else {
#line 301
      result___0.getquota_rslt_u.gqr_rquota.rq_active = 0;
    }
    {
#line 303
    servutil2netdqblk(& result___0.getquota_rslt_u.gqr_rquota, & dquot->dq_dqb);
#line 304
    free((void *)dquot);
    }
  }
  out: 
  {
#line 307
  dispose_handle_list(handles);
  }
#line 308
  return (& result___0);
}
}
#line 314 "/home/wheatley/newnew/temp/quota-4.01/rquota_server.c"
getquota_rslt *rquotaproc_getquota_1_svc(getquota_args *argp , struct svc_req *rqstp ) 
{ 
  getquota_rslt *tmp ;

  {
  {
#line 316
  tmp = getquotainfo(0, (caddr_t *)argp, rqstp);
  }
#line 316
  return (tmp);
}
}
#line 319 "/home/wheatley/newnew/temp/quota-4.01/rquota_server.c"
getquota_rslt *rquotaproc_getactivequota_1_svc(getquota_args *argp , struct svc_req *rqstp ) 
{ 
  getquota_rslt *tmp ;

  {
  {
#line 321
  tmp = getquotainfo(2, (caddr_t *)argp, rqstp);
  }
#line 321
  return (tmp);
}
}
#line 324 "/home/wheatley/newnew/temp/quota-4.01/rquota_server.c"
getquota_rslt *rquotaproc_getquota_2_svc(ext_getquota_args *argp , struct svc_req *rqstp ) 
{ 
  getquota_rslt *tmp ;

  {
  {
#line 326
  tmp = getquotainfo(1, (caddr_t *)argp, rqstp);
  }
#line 326
  return (tmp);
}
}
#line 329 "/home/wheatley/newnew/temp/quota-4.01/rquota_server.c"
getquota_rslt *rquotaproc_getactivequota_2_svc(ext_getquota_args *argp , struct svc_req *rqstp ) 
{ 
  getquota_rslt *tmp ;

  {
  {
#line 331
  tmp = getquotainfo(3, (caddr_t *)argp, rqstp);
  }
#line 331
  return (tmp);
}
}
#line 334 "/home/wheatley/newnew/temp/quota-4.01/rquota_server.c"
setquota_rslt *rquotaproc_setquota_1_svc(setquota_args *argp , struct svc_req *rqstp ) 
{ 
  setquota_rslt *tmp ;

  {
  {
#line 336
  tmp = setquotainfo(0, (caddr_t *)argp, rqstp);
  }
#line 336
  return (tmp);
}
}
#line 339 "/home/wheatley/newnew/temp/quota-4.01/rquota_server.c"
setquota_rslt *rquotaproc_setactivequota_1_svc(setquota_args *argp , struct svc_req *rqstp ) 
{ 
  setquota_rslt *tmp ;

  {
  {
#line 341
  tmp = setquotainfo(2, (caddr_t *)argp, rqstp);
  }
#line 341
  return (tmp);
}
}
#line 344 "/home/wheatley/newnew/temp/quota-4.01/rquota_server.c"
setquota_rslt *rquotaproc_setquota_2_svc(ext_setquota_args *argp , struct svc_req *rqstp ) 
{ 
  setquota_rslt *tmp ;

  {
  {
#line 346
  tmp = setquotainfo(1, (caddr_t *)argp, rqstp);
  }
#line 346
  return (tmp);
}
}
#line 349 "/home/wheatley/newnew/temp/quota-4.01/rquota_server.c"
setquota_rslt *rquotaproc_setactivequota_2_svc(ext_setquota_args *argp , struct svc_req *rqstp ) 
{ 
  setquota_rslt *tmp ;

  {
  {
#line 351
  tmp = setquotainfo(3, (caddr_t *)argp, rqstp);
  }
#line 351
  return (tmp);
}
}
#line 27 "/home/wheatley/newnew/temp/quota-4.01/quotaio_xfs.c"
static int xfs_init_io___3(struct quota_handle *h ) ;
#line 28
static int xfs_write_info___3(struct quota_handle *h ) ;
#line 29
static struct dquot *xfs_read_dquot___3(struct quota_handle *h , qid_t id___0 ) ;
#line 30
static int xfs_commit_dquot___3(struct dquot *dquot , int flags___7 ) ;
#line 31
static int xfs_scan_dquots___3(struct quota_handle *h , int (*process_dquot)(struct dquot *dquot ,
                                                                             char *dqname ) ) ;
#line 32
static int xfs_report___3(struct quota_handle *h , int verbose ) ;
#line 77 "/home/wheatley/newnew/temp/quota-4.01/quotaio_xfs.c"
static int xfs_init_io___3(struct quota_handle *h ) 
{ 
  struct fs_quota_stat info ;
  int qcmd ;
  long tmp ;

  {
  {
#line 82
  qcmd = ((88 << 8) + 5) << 8;
#line 83
  memset((void *)(& info), 0, sizeof(struct fs_quota_stat ));
#line 84
  tmp = quotactl(qcmd, (char const   *)(h->qh_quotadev), (qid_t )0, (caddr_t )((void *)(& info)));
  }
#line 84
  if (tmp < 0L) {
#line 85
    return (-1);
  }
#line 86
  h->qh_info.dqi_bgrace = (time_t )info.qs_btimelimit;
#line 87
  h->qh_info.dqi_igrace = (time_t )info.qs_itimelimit;
#line 88
  h->qh_info.u.xfs_mdqi = info;
#line 89
  return (0);
}
}
#line 95 "/home/wheatley/newnew/temp/quota-4.01/quotaio_xfs.c"
static int xfs_write_info___3(struct quota_handle *h ) 
{ 
  struct fs_disk_quota xdqblk ;
  int qcmd ;
  long tmp ;

  {
#line 100
  if (h->qh_type == 0) {
#line 100
    if (! ((int )h->qh_info.u.xfs_mdqi.qs_flags & 1)) {
#line 100
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 100
  if (h->qh_type == 1) {
#line 100
    if (! ((int )h->qh_info.u.xfs_mdqi.qs_flags & (1 << 2))) {
#line 101
      return (0);
    }
  } else {
#line 101
    return (0);
  }
  {
#line 103
  memset((void *)(& xdqblk), 0, sizeof(struct fs_disk_quota ));
#line 105
  xdqblk.d_btimer = (__s32 )h->qh_info.dqi_bgrace;
#line 106
  xdqblk.d_itimer = (__s32 )h->qh_info.dqi_igrace;
#line 107
  xdqblk.d_fieldmask = (__u16 )((int )xdqblk.d_fieldmask | (((1 << 6) | (1 << 7)) | (1 << 8)));
#line 108
  qcmd = (((88 << 8) + 4) << 8) | (h->qh_type & 255);
#line 109
  tmp = quotactl(qcmd, (char const   *)(h->qh_quotadev), (qid_t )0, (caddr_t )((void *)(& xdqblk)));
  }
#line 109
  if (tmp < 0L) {
#line 110
    return (-1);
  }
#line 111
  return (0);
}
}
#line 117 "/home/wheatley/newnew/temp/quota-4.01/quotaio_xfs.c"
static struct dquot *xfs_read_dquot___3(struct quota_handle *h , qid_t id___0 ) 
{ 
  struct dquot *dquot ;
  struct dquot *tmp ;
  struct fs_disk_quota xdqblk ;
  int qcmd ;
  long tmp___0 ;

  {
  {
#line 119
  tmp = get_empty_dquot();
#line 119
  dquot = tmp;
#line 123
  dquot->dq_id = id___0;
#line 124
  dquot->dq_h = h;
  }
#line 126
  if (h->qh_type == 0) {
#line 126
    if (! ((int )h->qh_info.u.xfs_mdqi.qs_flags & 1)) {
#line 126
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 126
  if (h->qh_type == 1) {
#line 126
    if (! ((int )h->qh_info.u.xfs_mdqi.qs_flags & (1 << 2))) {
#line 127
      return (dquot);
    }
  } else {
#line 127
    return (dquot);
  }
  {
#line 129
  qcmd = (((88 << 8) + 3) << 8) | (h->qh_type & 255);
#line 130
  tmp___0 = quotactl(qcmd, (char const   *)(h->qh_quotadev), id___0, (caddr_t )((void *)(& xdqblk)));
  }
#line 130
  if (! (tmp___0 < 0L)) {
    {
#line 134
    xfs_kern2utildqblk(& dquot->dq_dqb, & xdqblk);
    }
  }
#line 136
  return (dquot);
}
}
#line 142 "/home/wheatley/newnew/temp/quota-4.01/quotaio_xfs.c"
static int xfs_commit_dquot___3(struct dquot *dquot , int flags___7 ) 
{ 
  struct quota_handle *h ;
  struct fs_disk_quota xdqblk ;
  qid_t id___0 ;
  int qcmd ;
  int tmp ;
  int tmp___0 ;
  long tmp___1 ;

  {
#line 144
  h = dquot->dq_h;
#line 146
  id___0 = dquot->dq_id;
#line 149
  if (h->qh_type == 0) {
#line 149
    if (! ((int )h->qh_info.u.xfs_mdqi.qs_flags & 1)) {
#line 149
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 149
  if (h->qh_type == 1) {
#line 149
    if (! ((int )h->qh_info.u.xfs_mdqi.qs_flags & (1 << 2))) {
#line 150
      return (0);
    }
  } else {
#line 150
    return (0);
  }
  {
#line 152
  xfs_util2kerndqblk(& xdqblk, & dquot->dq_dqb);
  }
#line 153
  if (h->qh_type == 0) {
#line 153
    if ((int )h->qh_info.u.xfs_mdqi.qs_flags & 1) {
#line 153
      tmp = 1;
    } else {
#line 153
      tmp = 1 << 2;
    }
  } else {
#line 153
    tmp = 1 << 2;
  }
  {
#line 153
  xdqblk.d_flags = (__s8 )((int )xdqblk.d_flags | tmp);
#line 154
  xdqblk.d_id = id___0;
#line 155
  tmp___0 = strcmp((char const   *)(h->qh_fstype), "gfs2");
  }
#line 155
  if (tmp___0 == 0) {
#line 156
    if (flags___7 & 5) {
#line 157
      xdqblk.d_fieldmask = (__u16 )((int )xdqblk.d_fieldmask | ((1 << 2) | (1 << 3)));
    }
#line 158
    if (flags___7 & 10) {
#line 159
      xdqblk.d_fieldmask = (__u16 )((int )xdqblk.d_fieldmask | (1 << 12));
    }
  } else {
#line 161
    xdqblk.d_fieldmask = (__u16 )((int )xdqblk.d_fieldmask | (((((1 | (1 << 1)) | (1 << 2)) | (1 << 3)) | (1 << 4)) | (1 << 5)));
  }
  {
#line 164
  qcmd = (((88 << 8) + 4) << 8) | (h->qh_type & 255);
#line 165
  tmp___1 = quotactl(qcmd, (char const   *)(h->qh_quotadev), id___0, (caddr_t )((void *)(& xdqblk)));
  }
#line 165
  if (! (tmp___1 < 0L)) {
#line 169
    return (0);
  }
#line 171
  return (-1);
}
}
#line 177 "/home/wheatley/newnew/temp/quota-4.01/quotaio_xfs.c"
static int xfs_get_dquot___3(struct dquot *dq ) 
{ 
  struct fs_disk_quota d ;
  int qcmd ;
  int ret ;
  long tmp ;
  int *tmp___0 ;

  {
  {
#line 180
  qcmd = (((88 << 8) + 3) << 8) | ((dq->dq_h)->qh_type & 255);
#line 183
  memset((void *)(& d), 0, sizeof(d));
#line 184
  tmp = quotactl(qcmd, (char const   *)((dq->dq_h)->qh_quotadev), dq->dq_id, (caddr_t )((void *)(& d)));
#line 184
  ret = (int )tmp;
  }
#line 185
  if (ret < 0) {
    {
#line 186
    tmp___0 = __errno_location();
    }
#line 186
    if (*tmp___0 == 2) {
#line 187
      return (0);
    }
#line 188
    return (-1);
  }
  {
#line 190
  xfs_kern2utildqblk(& dq->dq_dqb, & d);
  }
#line 191
  return (0);
}
}
#line 197 "/home/wheatley/newnew/temp/quota-4.01/quotaio_xfs.c"
static int xfs_scan_dquots___3(struct quota_handle *h , int (*process_dquot)(struct dquot *dquot ,
                                                                             char *dqname ) ) 
{ 
  int tmp ;

  {
#line 199
  if (h->qh_type == 0) {
#line 199
    if (! ((int )h->qh_info.u.xfs_mdqi.qs_flags & 1)) {
#line 199
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 199
  if (h->qh_type == 1) {
#line 199
    if (! ((int )h->qh_info.u.xfs_mdqi.qs_flags & (1 << 2))) {
#line 200
      return (0);
    }
  } else {
#line 200
    return (0);
  }
  {
#line 202
  tmp = generic_scan_dquots(h, process_dquot, & xfs_get_dquot___3);
  }
#line 202
  return (tmp);
}
}
#line 208 "/home/wheatley/newnew/temp/quota-4.01/quotaio_xfs.c"
static int xfs_report___3(struct quota_handle *h , int verbose ) 
{ 
  u_int16_t sbflags ;
  struct fs_quota_stat *info ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;
  char *tmp___18 ;
  char *tmp___19 ;
  char *tmp___20 ;
  char *tmp___21 ;
  char *tmp___22 ;
  char *tmp___23 ;
  char *tmp___24 ;
  char *tmp___25 ;
  char *tmp___26 ;
  char *tmp___27 ;
  char *tmp___28 ;
  char *tmp___29 ;
  char *tmp___30 ;
  char *tmp___31 ;
  char *tmp___32 ;

  {
#line 211
  info = & h->qh_info.u.xfs_mdqi;
#line 213
  if (! verbose) {
#line 214
    return (0);
  }
  {
#line 217
  tmp = type2name(h->qh_type);
#line 217
  tmp___0 = gettext("*** Status for %s quotas on device %s\n");
#line 217
  printf((char const   */* __restrict  */)tmp___0, tmp, h->qh_quotadev);
  }
#line 220
  if (h->qh_type == 0) {
#line 221
    if ((int )info->qs_flags & (1 << 1)) {
      {
#line 221
      tmp___1 = gettext("ON");
#line 221
      tmp___3 = tmp___1;
      }
    } else {
      {
#line 221
      tmp___2 = gettext("OFF");
#line 221
      tmp___3 = tmp___2;
      }
    }
#line 221
    if ((int )info->qs_flags & 1) {
      {
#line 221
      tmp___4 = gettext("ON");
#line 221
      tmp___6 = tmp___4;
      }
    } else {
      {
#line 221
      tmp___5 = gettext("OFF");
#line 221
      tmp___6 = tmp___5;
      }
    }
    {
#line 221
    tmp___7 = gettext("Accounting: %s; Enforcement: %s\n");
#line 221
    printf((char const   */* __restrict  */)tmp___7, tmp___6, tmp___3);
    }
  } else {
#line 225
    if ((int )info->qs_flags & (1 << 3)) {
      {
#line 225
      tmp___8 = gettext("ON");
#line 225
      tmp___10 = tmp___8;
      }
    } else {
      {
#line 225
      tmp___9 = gettext("OFF");
#line 225
      tmp___10 = tmp___9;
      }
    }
#line 225
    if ((int )info->qs_flags & (1 << 2)) {
      {
#line 225
      tmp___11 = gettext("ON");
#line 225
      tmp___13 = tmp___11;
      }
    } else {
      {
#line 225
      tmp___12 = gettext("OFF");
#line 225
      tmp___13 = tmp___12;
      }
    }
    {
#line 225
    tmp___14 = gettext("Accounting: %s; Enforcement: %s\n");
#line 225
    printf((char const   */* __restrict  */)tmp___14, tmp___13, tmp___10);
    }
  }
#line 235
  sbflags = (u_int16_t )(((int )info->qs_flags & 65280) >> 8);
#line 235
  if ((int )sbflags != 0) {
#line 236
    if (h->qh_type == 0) {
#line 237
      if ((int )sbflags & (1 << 1)) {
        {
#line 237
        tmp___15 = gettext("ON");
#line 237
        tmp___17 = tmp___15;
        }
      } else {
        {
#line 237
        tmp___16 = gettext("OFF");
#line 237
        tmp___17 = tmp___16;
        }
      }
#line 237
      if ((int )sbflags & 1) {
        {
#line 237
        tmp___18 = gettext("ON");
#line 237
        tmp___20 = tmp___18;
        }
      } else {
        {
#line 237
        tmp___19 = gettext("OFF");
#line 237
        tmp___20 = tmp___19;
        }
      }
      {
#line 237
      tmp___21 = gettext("Accounting [ondisk]: %s; Enforcement [ondisk]: %s\n");
#line 237
      printf((char const   */* __restrict  */)tmp___21, tmp___20, tmp___17);
      }
    } else {
#line 241
      if ((int )sbflags & (1 << 3)) {
        {
#line 241
        tmp___22 = gettext("ON");
#line 241
        tmp___24 = tmp___22;
        }
      } else {
        {
#line 241
        tmp___23 = gettext("OFF");
#line 241
        tmp___24 = tmp___23;
        }
      }
#line 241
      if ((int )sbflags & (1 << 2)) {
        {
#line 241
        tmp___25 = gettext("ON");
#line 241
        tmp___27 = tmp___25;
        }
      } else {
        {
#line 241
        tmp___26 = gettext("OFF");
#line 241
        tmp___27 = tmp___26;
        }
      }
      {
#line 241
      tmp___28 = gettext("Accounting [ondisk]: %s; Enforcement [ondisk]: %s\n");
#line 241
      printf((char const   */* __restrict  */)tmp___28, tmp___27, tmp___24);
      }
    }
  }
#line 248
  if (h->qh_type == 0) {
#line 249
    if (info->qs_uquota.qfs_ino == 0xffffffffffffffffULL) {
      {
#line 250
      tmp___29 = gettext("Inode: none\n");
#line 250
      printf((char const   */* __restrict  */)tmp___29);
      }
    } else
#line 249
    if (info->qs_uquota.qfs_ino == 0ULL) {
      {
#line 250
      tmp___29 = gettext("Inode: none\n");
#line 250
      printf((char const   */* __restrict  */)tmp___29);
      }
    } else {
      {
#line 252
      tmp___30 = gettext("Inode: #%llu (%llu blocks, %u extents)\n");
#line 252
      printf((char const   */* __restrict  */)tmp___30, info->qs_uquota.qfs_ino, info->qs_uquota.qfs_nblks,
             info->qs_uquota.qfs_nextents);
      }
    }
  } else
#line 258
  if (info->qs_gquota.qfs_ino == 0xffffffffffffffffULL) {
    {
#line 259
    tmp___31 = gettext("Inode: none\n");
#line 259
    printf((char const   */* __restrict  */)tmp___31);
    }
  } else {
    {
#line 261
    tmp___32 = gettext("Inode: #%llu (%llu blocks, %u extents)\n");
#line 261
    printf((char const   */* __restrict  */)tmp___32, info->qs_gquota.qfs_ino, info->qs_gquota.qfs_nblks,
           info->qs_gquota.qfs_nextents);
    }
  }
#line 266
  return (0);
}
}
#line 18 "/home/wheatley/newnew/temp/quota-4.01/quotaio_rpc.c"
static int rpc_init_io___3(struct quota_handle *h ) ;
#line 19
static struct dquot *rpc_read_dquot___3(struct quota_handle *h , qid_t id___0 ) ;
#line 20
static int rpc_commit_dquot___3(struct dquot *dquot , int flags___7 ) ;
#line 31 "/home/wheatley/newnew/temp/quota-4.01/quotaio_rpc.c"
static int rpc_init_io___3(struct quota_handle *h ) 
{ 


  {
#line 34
  h->qh_info.dqi_max_b_limit = (uint64_t )(~ ((uint32_t )0));
#line 35
  h->qh_info.dqi_max_i_limit = (uint64_t )(~ ((uint32_t )0));
#line 36
  h->qh_info.dqi_max_b_usage = (uint64_t )(4294967295U << 10);
#line 37
  h->qh_info.dqi_max_i_usage = (uint64_t )(~ ((uint32_t )0));
#line 38
  return (0);
}
}
#line 47 "/home/wheatley/newnew/temp/quota-4.01/quotaio_rpc.c"
static struct dquot *rpc_read_dquot___3(struct quota_handle *h , qid_t id___0 ) 
{ 
  struct dquot *dquot ;
  struct dquot *tmp ;
  int ret ;
  int *tmp___0 ;

  {
  {
#line 50
  tmp = get_empty_dquot();
#line 50
  dquot = tmp;
#line 53
  dquot->dq_id = id___0;
#line 54
  dquot->dq_h = h;
#line 55
  ret = rpc_rquota_get(dquot);
  }
#line 55
  if (ret < 0) {
    {
#line 56
    tmp___0 = __errno_location();
#line 56
    *tmp___0 = - ret;
#line 57
    free((void *)dquot);
    }
#line 58
    return ((struct dquot *)((void *)0));
  }
#line 60
  return (dquot);
}
}
#line 70 "/home/wheatley/newnew/temp/quota-4.01/quotaio_rpc.c"
static int rpc_commit_dquot___3(struct dquot *dquot , int flags___7 ) 
{ 
  int ret ;
  char *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;

  {
#line 75
  if ((dquot->dq_h)->qh_io_flags & 4) {
    {
#line 76
    tmp = gettext("Trying to write quota to readonly quotafile on %s\n");
#line 76
    errstr(tmp, (dquot->dq_h)->qh_quotadev);
#line 77
    tmp___0 = __errno_location();
#line 77
    *tmp___0 = 1;
    }
#line 78
    return (-1);
  }
  {
#line 80
  ret = rpc_rquota_set((1024 << 8) | ((dquot->dq_h)->qh_type & 255), dquot);
  }
#line 80
  if (ret < 0) {
    {
#line 81
    tmp___1 = __errno_location();
#line 81
    *tmp___1 = - ret;
    }
#line 82
    return (-1);
  }
#line 84
  return (0);
}
}
#line 89 "/home/wheatley/newnew/temp/quota-4.01/rquota_client.c"
static int rquota_err___3(int stat___0 ) 
{ 


  {
  {
#line 92
  if (stat___0 == -1) {
#line 92
    goto case_neg_1;
  }
#line 94
  if (stat___0 == 0) {
#line 94
    goto case_0;
  }
#line 96
  if (stat___0 == 2) {
#line 96
    goto case_2;
  }
#line 98
  if (stat___0 == 1) {
#line 98
    goto case_1;
  }
#line 100
  if (stat___0 == 3) {
#line 100
    goto case_3;
  }
#line 102
  goto switch_default;
  case_neg_1: /* CIL Label */ 
#line 93
  return (-111);
  case_0: /* CIL Label */ 
#line 95
  return (-38);
  case_2: /* CIL Label */ 
#line 97
  return (-2);
  case_1: /* CIL Label */ 
#line 99
  return (0);
  case_3: /* CIL Label */ 
#line 101
  return (-1);
  switch_default: /* CIL Label */ 
#line 103
  return (-22);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 107 "/home/wheatley/newnew/temp/quota-4.01/rquota_client.c"
static int split_nfs_mount___3(char *devname , char **host , char **path ) 
{ 
  char *pathname ;

  {
#line 112
  if ((int )*devname == 91) {
    {
#line 113
    *host = devname + 1;
#line 114
    pathname = strchr((char const   *)devname, ']');
    }
#line 115
    if (! pathname) {
#line 116
      return (0);
    } else
#line 115
    if ((int )*(pathname + 1) != 58) {
#line 116
      return (0);
    }
#line 118
    if ((int )*(pathname + 2) == 40) {
#line 119
      return (0);
    }
#line 120
    *pathname = (char)0;
#line 121
    *path = pathname + 2;
#line 122
    return (1);
  }
  {
#line 124
  *host = devname;
#line 125
  pathname = strchr((char const   *)devname, ':');
  }
#line 126
  if (! pathname) {
#line 127
    return (0);
  }
#line 129
  if ((int )*(pathname + 1) == 40) {
#line 130
    return (0);
  }
#line 131
  *pathname = (char)0;
#line 132
  *path = pathname + 1;
#line 133
  return (1);
}
}
#line 31 "/home/wheatley/newnew/temp/quota-4.01/bylabel.c"
static struct uuidCache_s *uuidCache___3  =    (struct uuidCache_s *)((void *)0);
#line 74 "/home/wheatley/newnew/temp/quota-4.01/bylabel.c"
static int get_label_uuid___3(char const   *device , char **label , char *uuid ) 
{ 
  int fd ;
  int rv ;
  size_t namesize ;
  struct ext2_super_block e2sb ;
  struct xfs_super_block xfsb ;
  struct reiserfs_super_block reisersb ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  __off64_t tmp___2 ;
  ssize_t tmp___3 ;
  int tmp___4 ;
  __off64_t tmp___5 ;
  ssize_t tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  __off64_t tmp___9 ;
  ssize_t tmp___10 ;

  {
  {
#line 79
  rv = 1;
#line 85
  fd = open(device, 0);
  }
#line 86
  if (fd < 0) {
#line 87
    return (rv);
  }
  {
#line 89
  tmp___9 = lseek(fd, (__off64_t )1024, 0);
  }
#line 89
  if (tmp___9 == 1024L) {
    {
#line 89
    tmp___10 = read(fd, (void *)((char *)(& e2sb)), sizeof(e2sb));
    }
#line 89
    if ((unsigned long )tmp___10 == sizeof(e2sb)) {
#line 89
      if ((uint )e2sb.s_magic[0] + ((uint )e2sb.s_magic[1] << 8) == 61267U) {
        {
#line 92
        memcpy((void */* __restrict  */)uuid, (void const   */* __restrict  */)(e2sb.s_uuid),
               sizeof(e2sb.s_uuid));
#line 93
        namesize = sizeof(e2sb.s_volume_name);
#line 94
        tmp = smalloc(namesize + 1UL);
#line 94
        *label = (char *)tmp;
#line 95
        sstrncpy(*label, (char const   *)((char *)(e2sb.s_volume_name)), namesize);
#line 96
        rv = 0;
        }
      } else {
#line 89
        goto _L___3;
      }
    } else {
#line 89
      goto _L___3;
    }
  } else {
    _L___3: /* CIL Label */ 
    {
#line 98
    tmp___5 = lseek(fd, (__off64_t )0, 0);
    }
#line 98
    if (tmp___5 == 0L) {
      {
#line 98
      tmp___6 = read(fd, (void *)((char *)(& xfsb)), sizeof(xfsb));
      }
#line 98
      if ((unsigned long )tmp___6 == sizeof(xfsb)) {
        {
#line 98
        tmp___7 = strncmp((char const   *)((char *)(& xfsb.s_magic)), "XFSB", (size_t )4);
        }
#line 98
        if (tmp___7 == 0) {
#line 98
          goto _L___0;
        } else {
          {
#line 98
          tmp___8 = strncmp((char const   *)((char *)(& xfsb.s_magic)), "BSFX", (size_t )4);
          }
#line 98
          if (tmp___8 == 0) {
            _L___0: /* CIL Label */ 
            {
#line 102
            memcpy((void */* __restrict  */)uuid, (void const   */* __restrict  */)(xfsb.s_uuid),
                   sizeof(xfsb.s_uuid));
#line 103
            namesize = sizeof(xfsb.s_fsname);
#line 104
            tmp___0 = smalloc(namesize + 1UL);
#line 104
            *label = (char *)tmp___0;
#line 105
            sstrncpy(*label, (char const   *)((char *)(xfsb.s_fsname)), namesize);
#line 106
            rv = 0;
            }
          } else {
#line 98
            goto _L___1;
          }
        }
      } else {
#line 98
        goto _L___1;
      }
    } else {
      _L___1: /* CIL Label */ 
      {
#line 108
      tmp___2 = lseek(fd, (__off64_t )65536, 0);
      }
#line 108
      if (tmp___2 == 65536L) {
        {
#line 108
        tmp___3 = read(fd, (void *)((char *)(& reisersb)), sizeof(reisersb));
        }
#line 108
        if ((unsigned long )tmp___3 == sizeof(reisersb)) {
          {
#line 108
          tmp___4 = strncmp((char const   *)((char *)(& reisersb.s_magic)), "ReIsEr2Fs",
                            (size_t )9);
          }
#line 108
          if (! tmp___4) {
            {
#line 111
            memcpy((void */* __restrict  */)uuid, (void const   */* __restrict  */)(reisersb.s_uuid),
                   sizeof(reisersb.s_uuid));
#line 112
            namesize = sizeof(reisersb.s_volume_name);
#line 113
            tmp___1 = smalloc(namesize + 1UL);
#line 113
            *label = (char *)tmp___1;
#line 114
            sstrncpy(*label, (char const   *)((char *)(reisersb.s_volume_name)), namesize);
#line 115
            rv = 0;
            }
          }
        }
      }
    }
  }
  {
#line 117
  close(fd);
  }
#line 118
  return (rv);
}
}
#line 121 "/home/wheatley/newnew/temp/quota-4.01/bylabel.c"
static void uuidcache_addentry___3(char *device , char *label , char *uuid ) 
{ 
  struct uuidCache_s *last ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 125
  if (! uuidCache___3) {
    {
#line 126
    tmp = smalloc(sizeof(*uuidCache___3));
#line 126
    uuidCache___3 = (struct uuidCache_s *)tmp;
#line 126
    last = uuidCache___3;
    }
  } else {
#line 129
    last = uuidCache___3;
    {
#line 129
    while (1) {
      while_continue: /* CIL Label */ ;
#line 129
      if (! last->next) {
#line 129
        goto while_break;
      }
#line 129
      last = last->next;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 130
    tmp___0 = smalloc(sizeof(*uuidCache___3));
#line 130
    last->next = (struct uuidCache_s *)tmp___0;
#line 131
    last = last->next;
    }
  }
  {
#line 133
  last->next = (struct uuidCache_s *)((void *)0);
#line 134
  last->device = device;
#line 135
  last->label = label;
#line 136
  memcpy((void */* __restrict  */)(last->uuid), (void const   */* __restrict  */)uuid,
         sizeof(last->uuid));
  }
#line 137
  return;
}
}
#line 144 "/home/wheatley/newnew/temp/quota-4.01/bylabel.c"
static char ptname___3[100]  ;
#line 139 "/home/wheatley/newnew/temp/quota-4.01/bylabel.c"
static void uuidcache_init___3(void) 
{ 
  char line___0[100] ;
  char *s ;
  int ma ;
  int mi ;
  int sz ;
  FILE *procpt ;
  char uuid[16] ;
  char *label ;
  char device[110] ;
  int firstPass ;
  int handleOnFirst ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  unsigned short const   **tmp___4 ;
  char *tmp___5 ;

  {
#line 151
  if (uuidCache___3) {
#line 152
    return;
  }
  {
#line 154
  procpt = fopen((char const   */* __restrict  */)"/proc/partitions", (char const   */* __restrict  */)"r");
  }
#line 155
  if (! procpt) {
#line 156
    return;
  }
#line 158
  firstPass = 1;
  {
#line 158
  while (1) {
    while_continue: /* CIL Label */ ;
#line 158
    if (! (firstPass >= 0)) {
#line 158
      goto while_break;
    }
    {
#line 159
    fseek(procpt, 0L, 0);
    }
    {
#line 161
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 161
      tmp___5 = fgets((char */* __restrict  */)(line___0), (int )sizeof(line___0),
                      (FILE */* __restrict  */)procpt);
      }
#line 161
      if (! tmp___5) {
#line 161
        goto while_break___0;
      }
      {
#line 162
      tmp = sscanf((char const   */* __restrict  */)(line___0), (char const   */* __restrict  */)" %d %d %d %[^\n ]",
                   & ma, & mi, & sz, ptname___3);
      }
#line 162
      if (tmp != 4) {
#line 163
        goto while_continue___0;
      }
#line 166
      if (sz == 1) {
#line 167
        goto while_continue___0;
      }
      {
#line 170
      tmp___0 = strncmp((char const   *)(ptname___3), "md", (size_t )2);
      }
#line 170
      if (tmp___0) {
#line 170
        tmp___1 = 0;
      } else {
#line 170
        tmp___1 = 1;
      }
#line 170
      handleOnFirst = tmp___1;
#line 171
      if (firstPass != handleOnFirst) {
#line 172
        goto while_continue___0;
      }
#line 178
      s = ptname___3;
      {
#line 178
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 178
        if (! *s) {
#line 178
          goto while_break___1;
        }
#line 178
        s ++;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 179
      tmp___4 = __ctype_b_loc();
      }
#line 179
      if ((int const   )*(*tmp___4 + (int )*(s + -1)) & 2048) {
        {
#line 189
        snprintf((char */* __restrict  */)(device), sizeof(device), (char const   */* __restrict  */)"%s/%s",
                 "/dev", ptname___3);
#line 190
        tmp___3 = get_label_uuid___3((char const   *)(device), & label, uuid);
        }
#line 190
        if (! tmp___3) {
          {
#line 191
          tmp___2 = sstrdup((char const   *)(device));
#line 191
          uuidcache_addentry___3(tmp___2, label, uuid);
          }
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 158
    firstPass --;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 196
  fclose(procpt);
  }
#line 197
  return;
}
}
#line 202 "/home/wheatley/newnew/temp/quota-4.01/bylabel.c"
static char *get_spec_by_x___3(int n , char const   *t ) 
{ 
  struct uuidCache_s *uc ;
  char *tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 206
  uuidcache_init___3();
#line 207
  uc = uuidCache___3;
  }
  {
#line 209
  while (1) {
    while_continue: /* CIL Label */ ;
#line 209
    if (! uc) {
#line 209
      goto while_break;
    }
    {
#line 211
    if (n == 1) {
#line 211
      goto case_1;
    }
#line 215
    if (n == 2) {
#line 215
      goto case_2;
    }
#line 210
    goto switch_break;
    case_1: /* CIL Label */ 
    {
#line 212
    tmp___0 = memcmp((void const   *)t, (void const   *)(uc->uuid), sizeof(uc->uuid));
    }
#line 212
    if (! tmp___0) {
      {
#line 213
      tmp = sstrdup((char const   *)uc->device);
      }
#line 213
      return (tmp);
    }
#line 214
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 216
    tmp___2 = strcmp(t, (char const   *)uc->label);
    }
#line 216
    if (! tmp___2) {
      {
#line 217
      tmp___1 = sstrdup((char const   *)uc->device);
      }
#line 217
      return (tmp___1);
    }
#line 218
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 220
    uc = uc->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 222
  return ((char *)((void *)0));
}
}
#line 225 "/home/wheatley/newnew/temp/quota-4.01/bylabel.c"
static u_char fromhex___3(char c ) 
{ 
  unsigned short const   **tmp ;
  unsigned short const   **tmp___0 ;

  {
  {
#line 227
  tmp___0 = __ctype_b_loc();
  }
#line 227
  if ((int const   )*(*tmp___0 + (int )c) & 2048) {
#line 228
    return ((u_char )((int )c - 48));
  } else {
    {
#line 229
    tmp = __ctype_b_loc();
    }
#line 229
    if ((int const   )*(*tmp + (int )c) & 512) {
#line 230
      return ((u_char )(((int )c - 97) + 10));
    } else {
#line 232
      return ((u_char )(((int )c - 65) + 10));
    }
  }
}
}
#line 235 "/home/wheatley/newnew/temp/quota-4.01/bylabel.c"
static char *get_spec_by_uuid___3(char const   *s ) 
{ 
  u_char uuid[16] ;
  int i ;
  size_t tmp ;
  unsigned short const   **tmp___0 ;
  unsigned short const   **tmp___1 ;
  u_char tmp___2 ;
  u_char tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;

  {
  {
#line 240
  tmp = strlen(s);
  }
#line 240
  if (tmp != 36UL) {
#line 241
    goto bad_uuid;
  } else
#line 240
  if ((int const   )*(s + 8) != 45) {
#line 241
    goto bad_uuid;
  } else
#line 240
  if ((int const   )*(s + 13) != 45) {
#line 241
    goto bad_uuid;
  } else
#line 240
  if ((int const   )*(s + 18) != 45) {
#line 241
    goto bad_uuid;
  } else
#line 240
  if ((int const   )*(s + 23) != 45) {
#line 241
    goto bad_uuid;
  }
#line 242
  i = 0;
  {
#line 242
  while (1) {
    while_continue: /* CIL Label */ ;
#line 242
    if (! (i < 16)) {
#line 242
      goto while_break;
    }
#line 243
    if ((int const   )*s == 45) {
#line 244
      s ++;
    }
    {
#line 245
    tmp___0 = __ctype_b_loc();
    }
#line 245
    if ((int const   )*(*tmp___0 + (int )*(s + 0)) & 4096) {
      {
#line 245
      tmp___1 = __ctype_b_loc();
      }
#line 245
      if (! ((int const   )*(*tmp___1 + (int )*(s + 1)) & 4096)) {
#line 246
        goto bad_uuid;
      }
    } else {
#line 246
      goto bad_uuid;
    }
    {
#line 247
    tmp___2 = fromhex___3((char )*(s + 0));
#line 247
    tmp___3 = fromhex___3((char )*(s + 1));
#line 247
    uuid[i] = (u_char )(((int )tmp___2 << 4) | (int )tmp___3);
#line 248
    s += 2;
#line 242
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 250
  tmp___4 = get_spec_by_x___3(1, (char const   *)((char *)(uuid)));
  }
#line 250
  return (tmp___4);
  bad_uuid: 
  {
#line 253
  tmp___5 = gettext("Found an invalid UUID: %s\n");
#line 253
  errstr(tmp___5, s);
  }
#line 254
  return ((char *)((void *)0));
}
}
#line 257 "/home/wheatley/newnew/temp/quota-4.01/bylabel.c"
static char *get_spec_by_volume_label___3(char const   *s ) 
{ 
  char *tmp ;

  {
  {
#line 259
  tmp = get_spec_by_x___3(2, s);
  }
#line 259
  return (tmp);
}
}
#line 113 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) socket)(int __domain ,
                                                                             int __type ,
                                                                             int __protocol ) ;
#line 123
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) bind)(int __fd ,
                                                                           struct sockaddr  const  * __restrict  __addr ,
                                                                           socklen_t __len ) ;
#line 226
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setsockopt)(int __fd ,
                                                                                 int __level ,
                                                                                 int __optname ,
                                                                                 void const   *__optval ,
                                                                                 socklen_t __optlen ) ;
#line 379 "/usr/include/netinet/in.h"
extern  __attribute__((__nothrow__)) uint16_t ( __attribute__((__leaf__)) htons)(uint16_t __hostshort )  __attribute__((__const__)) ;
#line 64 "/usr/include/rpc/netdb.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getrpcbynumber_r)(int __number ,
                                                                                       struct rpcent *__result_buf ,
                                                                                       char *__buffer ,
                                                                                       size_t __buflen ,
                                                                                       struct rpcent **__result ) ;
#line 312 "/usr/include/netdb.h"
extern int getservbyname_r(char const   * __restrict  __name , char const   * __restrict  __proto ,
                           struct servent * __restrict  __result_buf , char * __restrict  __buf ,
                           size_t __buflen , struct servent ** __restrict  __result ) ;
#line 32 "/home/wheatley/newnew/temp/quota-4.01/svc_socket.c"
static int svc_socket(u_long number , int type , int protocol , int port___0 , int reuse ) 
{ 
  struct sockaddr_in addr ;
  char rpcdata[1024] ;
  char servdata[1024] ;
  struct rpcent rpcbuf ;
  struct rpcent *rpcp ;
  struct servent servbuf ;
  struct servent *servp ;
  int sock ;
  int ret ;
  char const   *proto ;
  char const   *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  char const   **a ;
  uint16_t tmp___7 ;
  int *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  int tmp___11 ;

  {
#line 36
  rpcp = (struct rpcent *)((void *)0);
#line 37
  servp = (struct servent *)((void *)0);
#line 39
  if (protocol == 6) {
#line 39
    tmp = "tcp";
  } else {
#line 39
    tmp = "udp";
  }
  {
#line 39
  proto = tmp;
#line 41
  sock = socket(2, type, protocol);
  }
#line 41
  if (sock < 0) {
    {
#line 42
    tmp___0 = __errno_location();
#line 42
    tmp___1 = strerror(*tmp___0);
#line 42
    tmp___2 = gettext("Cannot create socket: %s\n");
#line 42
    errstr(tmp___2, tmp___1);
    }
#line 43
    return (-1);
  }
#line 46
  if (reuse) {
    {
#line 47
    ret = 1;
#line 48
    tmp___6 = setsockopt(sock, 1, 2, (void const   *)(& ret), (socklen_t )sizeof(ret));
    }
#line 48
    if (tmp___6 < 0) {
      {
#line 49
      tmp___3 = __errno_location();
#line 49
      tmp___4 = strerror(*tmp___3);
#line 49
      tmp___5 = gettext("Cannot set socket options: %s\n");
#line 49
      errstr(tmp___5, tmp___4);
      }
#line 50
      return (-1);
    }
  }
  {
#line 54
  memset((void *)(& addr), 0, sizeof(addr));
#line 55
  addr.sin_family = (sa_family_t )2;
  }
#line 57
  if (! port___0) {
    {
#line 58
    ret = getrpcbynumber_r((int )number, & rpcbuf, rpcdata, sizeof(rpcdata), & rpcp);
    }
#line 59
    if (ret == 0) {
#line 59
      if ((unsigned long )rpcp != (unsigned long )((void *)0)) {
        {
#line 61
        ret = getservbyname_r((char const   */* __restrict  */)rpcp->r_name, (char const   */* __restrict  */)proto,
                              (struct servent */* __restrict  */)(& servbuf), (char */* __restrict  */)(servdata),
                              sizeof(servdata), (struct servent **/* __restrict  */)(& servp));
        }
#line 63
        if (ret != 0) {
#line 63
          goto _L;
        } else
#line 63
        if ((unsigned long )servp == (unsigned long )((void *)0)) {
          _L: /* CIL Label */ 
#line 63
          if (rpcp->r_aliases) {
#line 67
            a = (char const   **)rpcp->r_aliases;
            {
#line 67
            while (1) {
              while_continue: /* CIL Label */ ;
#line 67
              if (! ((unsigned long )*a != (unsigned long )((void *)0))) {
#line 67
                goto while_break;
              }
              {
#line 68
              ret = getservbyname_r((char const   */* __restrict  */)*a, (char const   */* __restrict  */)proto,
                                    (struct servent */* __restrict  */)(& servbuf),
                                    (char */* __restrict  */)(servdata), sizeof(servdata),
                                    (struct servent **/* __restrict  */)(& servp));
              }
#line 70
              if (ret == 0) {
#line 70
                if ((unsigned long )servp != (unsigned long )((void *)0)) {
#line 71
                  goto while_break;
                }
              }
#line 67
              a ++;
            }
            while_break: /* CIL Label */ ;
            }
          }
        }
#line 74
        if (ret == 0) {
#line 74
          if ((unsigned long )servp != (unsigned long )((void *)0)) {
#line 75
            port___0 = servp->s_port;
          }
        }
      }
    }
  } else {
    {
#line 79
    tmp___7 = htons((uint16_t )port___0);
#line 79
    port___0 = (int )tmp___7;
    }
  }
#line 81
  if (port___0) {
    {
#line 82
    addr.sin_port = (in_port_t )port___0;
#line 83
    tmp___11 = bind(sock, (struct sockaddr  const  */* __restrict  */)((struct sockaddr *)(& addr)),
                    (socklen_t )sizeof(struct sockaddr_in ));
    }
#line 83
    if (tmp___11 < 0) {
      {
#line 84
      tmp___8 = __errno_location();
#line 84
      tmp___9 = strerror(*tmp___8);
#line 84
      tmp___10 = gettext("Cannot bind to given address: %s\n");
#line 84
      errstr(tmp___10, tmp___9);
#line 85
      close(sock);
      }
#line 86
      return (-1);
    }
  } else {
    {
#line 91
    close(sock);
    }
#line 92
    return (-1);
  }
#line 95
  return (sock);
}
}
#line 101 "/home/wheatley/newnew/temp/quota-4.01/svc_socket.c"
int svctcp_socket(u_long number , int port___0 , int reuse ) 
{ 
  int tmp ;

  {
  {
#line 103
  tmp = svc_socket(number, 1, 6, port___0, reuse);
  }
#line 103
  return (tmp);
}
}
#line 109 "/home/wheatley/newnew/temp/quota-4.01/svc_socket.c"
int svcudp_socket(u_long number , int port___0 , int reuse ) 
{ 
  int tmp ;

  {
  {
#line 111
  tmp = svc_socket(number, 2, 17, port___0, reuse);
  }
#line 111
  return (tmp);
}
}
#line 27 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v2.c"
static int v2_check_file___3(int fd , int type , int fmt___7 ) ;
#line 28
static int v2_init_io___3(struct quota_handle *h ) ;
#line 29
static int v2_new_io___3(struct quota_handle *h ) ;
#line 30
static int v2_write_info___3(struct quota_handle *h ) ;
#line 31
static struct dquot *v2_read_dquot___3(struct quota_handle *h , qid_t id___0 ) ;
#line 32
static int v2_commit_dquot___3(struct dquot *dquot , int flags___7 ) ;
#line 33
static int v2_scan_dquots___3(struct quota_handle *h , int (*process_dquot)(struct dquot *dquot ,
                                                                            char *dqname ) ) ;
#line 34
static int v2_report___3(struct quota_handle *h , int verbose ) ;
#line 53 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v2.c"
static void v2r0_disk2memdqblk___3(struct dquot *dquot , void *dp ) 
{ 
  struct util_dqblk *m ;
  struct v2r0_disk_dqblk *d ;
  struct v2r0_disk_dqblk empty ;
  int tmp ;

  {
  {
#line 55
  m = & dquot->dq_dqb;
#line 56
  d = (struct v2r0_disk_dqblk *)dp;
#line 58
  dquot->dq_id = d->dqb_id;
#line 59
  m->dqb_ihardlimit = (qsize_t )d->dqb_ihardlimit;
#line 60
  m->dqb_isoftlimit = (qsize_t )d->dqb_isoftlimit;
#line 61
  m->dqb_bhardlimit = (qsize_t )d->dqb_bhardlimit;
#line 62
  m->dqb_bsoftlimit = (qsize_t )d->dqb_bsoftlimit;
#line 63
  m->dqb_curinodes = (qsize_t )d->dqb_curinodes;
#line 64
  m->dqb_curspace = (qsize_t )((__le64 )d->dqb_curspace);
#line 65
  m->dqb_itime = (time_t )((__le64 )d->dqb_itime);
#line 66
  m->dqb_btime = (time_t )((__le64 )d->dqb_btime);
#line 68
  memset((void *)(& empty), 0, sizeof(struct v2r0_disk_dqblk ));
#line 69
  empty.dqb_itime = (u_int64_t )((__u64 )1);
#line 70
  tmp = memcmp((void const   *)(& empty), (void const   *)dp, sizeof(struct v2r0_disk_dqblk ));
  }
#line 70
  if (! tmp) {
#line 71
    m->dqb_itime = (time_t )0;
  }
#line 72
  return;
}
}
#line 77 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v2.c"
static void v2r0_mem2diskdqblk___3(void *dp , struct dquot *dquot ) 
{ 
  struct util_dqblk *m ;
  struct v2r0_disk_dqblk *d ;
  struct qtree_mem_dqinfo *info ;
  int tmp ;

  {
  {
#line 79
  m = & dquot->dq_dqb;
#line 80
  d = (struct v2r0_disk_dqblk *)dp;
#line 81
  info = & (dquot->dq_h)->qh_info.u.v2_mdqi.dqi_qtree;
#line 83
  d->dqb_ihardlimit = (__u32 )m->dqb_ihardlimit;
#line 84
  d->dqb_isoftlimit = (__u32 )m->dqb_isoftlimit;
#line 85
  d->dqb_bhardlimit = (__u32 )m->dqb_bhardlimit;
#line 86
  d->dqb_bsoftlimit = (__u32 )m->dqb_bsoftlimit;
#line 87
  d->dqb_curinodes = (__u32 )m->dqb_curinodes;
#line 88
  d->dqb_curspace = (u_int64_t )((__u64 )m->dqb_curspace);
#line 89
  d->dqb_itime = (u_int64_t )((__u64 )m->dqb_itime);
#line 90
  d->dqb_btime = (u_int64_t )((__u64 )m->dqb_btime);
#line 91
  d->dqb_id = dquot->dq_id;
#line 92
  tmp = qtree_entry_unused(info, (char *)dp);
  }
#line 92
  if (tmp) {
#line 93
    d->dqb_itime = (u_int64_t )((__u64 )1);
  }
#line 94
  return;
}
}
#line 96 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v2.c"
static int v2r0_is_id___3(void *dp , struct dquot *dquot ) 
{ 
  struct v2r0_disk_dqblk *d ;
  struct qtree_mem_dqinfo *info ;
  int tmp ;

  {
  {
#line 98
  d = (struct v2r0_disk_dqblk *)dp;
#line 99
  info = & (dquot->dq_h)->qh_info.u.v2_mdqi.dqi_qtree;
#line 101
  tmp = qtree_entry_unused(info, (char *)dp);
  }
#line 101
  if (tmp) {
#line 102
    return (0);
  }
#line 103
  return (d->dqb_id == dquot->dq_id);
}
}
#line 109 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v2.c"
static void v2r1_disk2memdqblk___3(struct dquot *dquot , void *dp ) 
{ 
  struct util_dqblk *m ;
  struct v2r1_disk_dqblk *d ;
  struct v2r1_disk_dqblk empty ;
  int tmp ;

  {
  {
#line 111
  m = & dquot->dq_dqb;
#line 112
  d = (struct v2r1_disk_dqblk *)dp;
#line 114
  dquot->dq_id = d->dqb_id;
#line 115
  m->dqb_ihardlimit = (qsize_t )((__le64 )d->dqb_ihardlimit);
#line 116
  m->dqb_isoftlimit = (qsize_t )((__le64 )d->dqb_isoftlimit);
#line 117
  m->dqb_bhardlimit = (qsize_t )((__le64 )d->dqb_bhardlimit);
#line 118
  m->dqb_bsoftlimit = (qsize_t )((__le64 )d->dqb_bsoftlimit);
#line 119
  m->dqb_curinodes = (qsize_t )((__le64 )d->dqb_curinodes);
#line 120
  m->dqb_curspace = (qsize_t )((__le64 )d->dqb_curspace);
#line 121
  m->dqb_itime = (time_t )((__le64 )d->dqb_itime);
#line 122
  m->dqb_btime = (time_t )((__le64 )d->dqb_btime);
#line 124
  memset((void *)(& empty), 0, sizeof(struct v2r1_disk_dqblk ));
#line 125
  empty.dqb_itime = (u_int64_t )((__u64 )1);
#line 126
  tmp = memcmp((void const   *)(& empty), (void const   *)dp, sizeof(struct v2r1_disk_dqblk ));
  }
#line 126
  if (! tmp) {
#line 127
    m->dqb_itime = (time_t )0;
  }
#line 128
  return;
}
}
#line 133 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v2.c"
static void v2r1_mem2diskdqblk___3(void *dp , struct dquot *dquot ) 
{ 
  struct util_dqblk *m ;
  struct v2r1_disk_dqblk *d ;
  int tmp ;

  {
  {
#line 135
  m = & dquot->dq_dqb;
#line 136
  d = (struct v2r1_disk_dqblk *)dp;
#line 138
  d->dqb_ihardlimit = (u_int64_t )((__u64 )m->dqb_ihardlimit);
#line 139
  d->dqb_isoftlimit = (u_int64_t )((__u64 )m->dqb_isoftlimit);
#line 140
  d->dqb_bhardlimit = (u_int64_t )((__u64 )m->dqb_bhardlimit);
#line 141
  d->dqb_bsoftlimit = (u_int64_t )((__u64 )m->dqb_bsoftlimit);
#line 142
  d->dqb_curinodes = (u_int64_t )((__u64 )m->dqb_curinodes);
#line 143
  d->dqb_curspace = (u_int64_t )((__u64 )m->dqb_curspace);
#line 144
  d->dqb_itime = (u_int64_t )((__u64 )m->dqb_itime);
#line 145
  d->dqb_btime = (u_int64_t )((__u64 )m->dqb_btime);
#line 146
  d->dqb_id = dquot->dq_id;
#line 147
  d->dqb_pad = (u_int32_t )0;
#line 148
  tmp = qtree_entry_unused(& (dquot->dq_h)->qh_info.u.v2_mdqi.dqi_qtree, (char *)dp);
  }
#line 148
  if (tmp) {
#line 149
    d->dqb_itime = (u_int64_t )((__u64 )1);
  }
#line 150
  return;
}
}
#line 152 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v2.c"
static int v2r1_is_id___3(void *dp , struct dquot *dquot ) 
{ 
  struct v2r1_disk_dqblk *d ;
  struct qtree_mem_dqinfo *info ;
  int tmp ;

  {
  {
#line 154
  d = (struct v2r1_disk_dqblk *)dp;
#line 155
  info = & (dquot->dq_h)->qh_info.u.v2_mdqi.dqi_qtree;
#line 157
  tmp = qtree_entry_unused(info, (char *)dp);
  }
#line 157
  if (tmp) {
#line 158
    return (0);
  }
#line 159
  return (d->dqb_id == dquot->dq_id);
}
}
#line 162 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v2.c"
static struct qtree_fmt_operations v2r0_fmt_ops___3  =    {& v2r0_mem2diskdqblk___3, & v2r0_disk2memdqblk___3, & v2r0_is_id___3};
#line 168 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v2.c"
static struct qtree_fmt_operations v2r1_fmt_ops___3  =    {& v2r1_mem2diskdqblk___3, & v2r1_disk2memdqblk___3, & v2r1_is_id___3};
#line 226 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v2.c"
static int v2_read_header___3(int fd , struct v2_disk_dqheader *h ) 
{ 
  ssize_t tmp ;

  {
  {
#line 228
  lseek(fd, (__off64_t )0, 0);
#line 229
  tmp = read(fd, (void *)h, sizeof(struct v2_disk_dqheader ));
  }
#line 229
  if ((unsigned long )tmp != sizeof(struct v2_disk_dqheader )) {
#line 230
    return (0);
  }
#line 231
  return (1);
}
}
#line 237 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v2.c"
static int v2_check_file___3(int fd , int type , int fmt___7 ) 
{ 
  struct v2_disk_dqheader h ;
  int file_magics[2] ;
  int known_versions___0[2] ;
  int version___0 ;
  int tmp ;
  char *tmp___0 ;
  __u32 tmp___1 ;

  {
  {
#line 240
  file_magics[0] = -641720559;
#line 240
  file_magics[1] = -641722073;
#line 241
  known_versions___0[0] = 1;
#line 241
  known_versions___0[1] = 1;
#line 244
  tmp = v2_read_header___3(fd, & h);
  }
#line 244
  if (! tmp) {
#line 245
    return (0);
  }
#line 246
  if (fmt___7 == 1) {
#line 247
    version___0 = 0;
  } else
#line 248
  if (fmt___7 == 2) {
#line 249
    version___0 = 1;
  } else {
#line 251
    return (0);
  }
#line 253
  if (h.dqh_magic != (__u32 )file_magics[type]) {
    {
#line 254
    tmp___1 = __fswab32(h.dqh_magic);
    }
#line 254
    if (tmp___1 == (__u32 )file_magics[type]) {
      {
#line 255
      tmp___0 = gettext("Your quota file is stored in wrong endianity. Please use convertquota(8) to convert it.\n");
#line 255
      die(3, tmp___0);
      }
    }
#line 256
    return (0);
  }
#line 258
  if (h.dqh_version > (__u32 )known_versions___0[type]) {
#line 259
    return (0);
  }
#line 260
  if ((__u32 )version___0 != h.dqh_version) {
#line 261
    return (0);
  }
#line 262
  return (1);
}
}
#line 268 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v2.c"
static int v2_init_io___3(struct quota_handle *h ) 
{ 
  int tmp ;
  struct v2_kern_dqinfo kdqinfo ;
  int *tmp___0 ;
  long tmp___1 ;
  struct v2_disk_dqinfo ddqinfo ;
  struct v2_disk_dqheader header ;
  int tmp___2 ;
  ssize_t tmp___3 ;

  {
#line 270
  if (h->qh_io_flags & 1) {
#line 271
    if (kernel_iface == 3) {
      {
#line 272
      tmp = vfs_get_info(h);
      }
#line 272
      if (tmp < 0) {
#line 273
        return (-1);
      }
    } else {
      {
#line 278
      tmp___1 = quotactl((2304 << 8) | (h->qh_type & 255), (char const   *)(h->qh_quotadev),
                         (qid_t )0, (caddr_t )((void *)(& kdqinfo)));
      }
#line 278
      if (tmp___1 < 0L) {
        {
#line 280
        tmp___0 = __errno_location();
        }
#line 280
        if (*tmp___0 == 1) {
#line 281
          return (0);
        }
#line 282
        return (-1);
      }
#line 284
      h->qh_info.dqi_bgrace = (time_t )kdqinfo.dqi_bgrace;
#line 285
      h->qh_info.dqi_igrace = (time_t )kdqinfo.dqi_igrace;
#line 286
      h->qh_info.u.v2_mdqi.dqi_flags = kdqinfo.dqi_flags;
#line 287
      h->qh_info.u.v2_mdqi.dqi_qtree.dqi_blocks = kdqinfo.dqi_blocks;
#line 288
      h->qh_info.u.v2_mdqi.dqi_qtree.dqi_free_blk = kdqinfo.dqi_free_blk;
#line 289
      h->qh_info.u.v2_mdqi.dqi_qtree.dqi_free_entry = kdqinfo.dqi_free_entry;
    }
  }
#line 292
  if (h->qh_fd != -1) {
    {
#line 296
    tmp___2 = v2_read_header___3(h->qh_fd, & header);
    }
#line 296
    if (! tmp___2) {
#line 297
      return (-1);
    }
    {
#line 299
    lseek(h->qh_fd, (__off64_t )sizeof(struct v2_disk_dqheader ), 0);
#line 300
    tmp___3 = read(h->qh_fd, (void *)(& ddqinfo), sizeof(ddqinfo));
    }
#line 300
    if ((unsigned long )tmp___3 != sizeof(ddqinfo)) {
#line 301
      return (-1);
    }
#line 303
    if (! (h->qh_io_flags & 1)) {
      {
#line 304
      v2_disk2memdqinfo(& h->qh_info, & ddqinfo);
      }
    } else {
#line 306
      h->qh_info.u.v2_mdqi.dqi_qtree.dqi_blocks = ddqinfo.dqi_blocks;
    }
#line 308
    if (header.dqh_version == 0U) {
#line 309
      h->qh_info.u.v2_mdqi.dqi_qtree.dqi_entry_size = (unsigned int )sizeof(struct v2r0_disk_dqblk );
#line 310
      h->qh_info.u.v2_mdqi.dqi_qtree.dqi_ops = & v2r0_fmt_ops___3;
#line 311
      h->qh_info.dqi_max_b_limit = (uint64_t )(~ ((uint32_t )0));
#line 312
      h->qh_info.dqi_max_i_limit = (uint64_t )(~ ((uint32_t )0));
#line 313
      h->qh_info.dqi_max_b_usage = ~ ((uint64_t )0);
#line 314
      h->qh_info.dqi_max_i_usage = (uint64_t )(~ ((uint32_t )0));
    } else {
#line 316
      h->qh_info.u.v2_mdqi.dqi_qtree.dqi_entry_size = (unsigned int )sizeof(struct v2r1_disk_dqblk );
#line 317
      h->qh_info.u.v2_mdqi.dqi_qtree.dqi_ops = & v2r1_fmt_ops___3;
#line 318
      h->qh_info.dqi_max_b_limit = ~ ((uint64_t )0);
#line 319
      h->qh_info.dqi_max_i_limit = ~ ((uint64_t )0);
#line 320
      h->qh_info.dqi_max_b_usage = ~ ((uint64_t )0);
#line 321
      h->qh_info.dqi_max_i_usage = ~ ((uint64_t )0);
    }
  } else {
#line 325
    h->qh_info.u.v2_mdqi.dqi_qtree.dqi_ops = (struct qtree_fmt_operations *)((void *)0);
  }
#line 327
  return (0);
}
}
#line 333 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v2.c"
static int v2_new_io___3(struct quota_handle *h ) 
{ 
  int file_magics[2] ;
  struct v2_disk_dqheader ddqheader ;
  struct v2_disk_dqinfo ddqinfo ;
  int version___0 ;
  ssize_t tmp ;
  ssize_t tmp___0 ;

  {
#line 335
  file_magics[0] = -641720559;
#line 335
  file_magics[1] = -641722073;
#line 340
  if (h->qh_fmt == 1) {
#line 341
    version___0 = 0;
  } else
#line 342
  if (h->qh_fmt == 2) {
#line 343
    version___0 = 1;
  } else {
#line 345
    return (-1);
  }
  {
#line 348
  ddqheader.dqh_magic = (__u32 )file_magics[h->qh_type];
#line 349
  ddqheader.dqh_version = (__u32 )version___0;
#line 350
  lseek(h->qh_fd, (__off64_t )0, 0);
#line 351
  tmp = write(h->qh_fd, (void const   *)(& ddqheader), sizeof(ddqheader));
  }
#line 351
  if ((unsigned long )tmp != sizeof(ddqheader)) {
#line 352
    return (-1);
  }
#line 354
  h->qh_info.dqi_bgrace = (time_t )604800;
#line 355
  h->qh_info.dqi_igrace = (time_t )604800;
#line 356
  h->qh_info.u.v2_mdqi.dqi_flags = (uint )0;
#line 357
  h->qh_info.u.v2_mdqi.dqi_qtree.dqi_blocks = 2U;
#line 358
  h->qh_info.u.v2_mdqi.dqi_qtree.dqi_free_blk = 0U;
#line 359
  h->qh_info.u.v2_mdqi.dqi_qtree.dqi_free_entry = 0U;
#line 360
  if (version___0 == 0) {
#line 361
    h->qh_info.u.v2_mdqi.dqi_qtree.dqi_entry_size = (unsigned int )sizeof(struct v2r0_disk_dqblk );
#line 362
    h->qh_info.u.v2_mdqi.dqi_qtree.dqi_ops = & v2r0_fmt_ops___3;
#line 363
    h->qh_info.dqi_max_b_limit = (uint64_t )(~ ((uint32_t )0));
#line 364
    h->qh_info.dqi_max_i_limit = (uint64_t )(~ ((uint32_t )0));
#line 365
    h->qh_info.dqi_max_b_usage = ~ ((uint64_t )0);
#line 366
    h->qh_info.dqi_max_i_usage = (uint64_t )(~ ((uint32_t )0));
  } else
#line 367
  if (version___0 == 1) {
#line 368
    h->qh_info.u.v2_mdqi.dqi_qtree.dqi_entry_size = (unsigned int )sizeof(struct v2r1_disk_dqblk );
#line 369
    h->qh_info.u.v2_mdqi.dqi_qtree.dqi_ops = & v2r1_fmt_ops___3;
#line 370
    h->qh_info.dqi_max_b_limit = ~ ((uint64_t )0);
#line 371
    h->qh_info.dqi_max_i_limit = ~ ((uint64_t )0);
#line 372
    h->qh_info.dqi_max_b_usage = ~ ((uint64_t )0);
#line 373
    h->qh_info.dqi_max_i_usage = ~ ((uint64_t )0);
  }
  {
#line 375
  v2_mem2diskdqinfo(& ddqinfo, & h->qh_info);
#line 376
  lseek(h->qh_fd, (__off64_t )sizeof(struct v2_disk_dqheader ), 0);
#line 377
  tmp___0 = write(h->qh_fd, (void const   *)(& ddqinfo), sizeof(ddqinfo));
  }
#line 377
  if ((unsigned long )tmp___0 != sizeof(ddqinfo)) {
#line 378
    return (-1);
  }
#line 379
  return (0);
}
}
#line 385 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v2.c"
static int v2_write_info___3(struct quota_handle *h ) 
{ 
  char *tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  struct v2_kern_dqinfo kdqinfo ;
  long tmp___2 ;
  long tmp___3 ;
  struct v2_disk_dqinfo ddqinfo ;
  ssize_t tmp___4 ;

  {
#line 387
  if (h->qh_io_flags & 4) {
    {
#line 388
    tmp = gettext("Trying to write info to readonly quotafile on %s\n");
#line 388
    errstr(tmp, h->qh_quotadev);
#line 389
    tmp___0 = __errno_location();
#line 389
    *tmp___0 = 1;
    }
#line 390
    return (-1);
  }
#line 392
  if (h->qh_io_flags & 1) {
#line 393
    if (kernel_iface == 3) {
      {
#line 394
      tmp___1 = vfs_set_info(h, 3);
      }
#line 394
      if (tmp___1) {
#line 395
        return (-1);
      }
    } else {
      {
#line 400
      kdqinfo.dqi_bgrace = (unsigned int )h->qh_info.dqi_bgrace;
#line 401
      kdqinfo.dqi_igrace = (unsigned int )h->qh_info.dqi_igrace;
#line 402
      kdqinfo.dqi_flags = h->qh_info.u.v2_mdqi.dqi_flags;
#line 403
      kdqinfo.dqi_blocks = h->qh_info.u.v2_mdqi.dqi_qtree.dqi_blocks;
#line 404
      kdqinfo.dqi_free_blk = h->qh_info.u.v2_mdqi.dqi_qtree.dqi_free_blk;
#line 405
      kdqinfo.dqi_free_entry = h->qh_info.u.v2_mdqi.dqi_qtree.dqi_free_entry;
#line 406
      tmp___2 = quotactl((2816 << 8) | (h->qh_type & 255), (char const   *)(h->qh_quotadev),
                         (qid_t )0, (caddr_t )((void *)(& kdqinfo)));
      }
#line 406
      if (tmp___2 < 0L) {
#line 408
        return (-1);
      } else {
        {
#line 406
        tmp___3 = quotactl((3072 << 8) | (h->qh_type & 255), (char const   *)(h->qh_quotadev),
                           (qid_t )0, (caddr_t )((void *)(& kdqinfo)));
        }
#line 406
        if (tmp___3 < 0L) {
#line 408
          return (-1);
        }
      }
    }
  } else {
    {
#line 414
    v2_mem2diskdqinfo(& ddqinfo, & h->qh_info);
#line 415
    lseek(h->qh_fd, (__off64_t )sizeof(struct v2_disk_dqheader ), 0);
#line 416
    tmp___4 = write(h->qh_fd, (void const   *)(& ddqinfo), sizeof(ddqinfo));
    }
#line 416
    if ((unsigned long )tmp___4 != sizeof(ddqinfo)) {
#line 417
      return (-1);
    }
  }
#line 419
  return (0);
}
}
#line 426 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v2.c"
static struct dquot *v2_read_dquot___3(struct quota_handle *h , qid_t id___0 ) 
{ 
  struct dquot *dquot ;
  struct dquot *tmp ;
  int tmp___0 ;
  struct v2_kern_dqblk kdqblk ;
  long tmp___1 ;
  struct dquot *tmp___2 ;

  {
#line 428
  if (h->qh_io_flags & 1) {
    {
#line 429
    tmp = get_empty_dquot();
#line 429
    dquot = tmp;
#line 431
    dquot->dq_id = id___0;
#line 432
    dquot->dq_h = h;
#line 433
    dquot->dq_dqb.u.v2_mdqb.dqb_off = (loff_t )0;
#line 434
    memset((void *)(& dquot->dq_dqb), 0, sizeof(struct util_dqblk ));
    }
#line 435
    if (kernel_iface == 3) {
      {
#line 436
      tmp___0 = vfs_get_dquot(dquot);
      }
#line 436
      if (tmp___0 < 0) {
        {
#line 437
        free((void *)dquot);
        }
#line 438
        return ((struct dquot *)((void *)0));
      }
    } else {
      {
#line 444
      tmp___1 = quotactl((3328 << 8) | (h->qh_type & 255), (char const   *)(h->qh_quotadev),
                         id___0, (caddr_t )((void *)(& kdqblk)));
      }
#line 444
      if (tmp___1 < 0L) {
        {
#line 445
        free((void *)dquot);
        }
#line 446
        return ((struct dquot *)((void *)0));
      }
      {
#line 448
      v2_kern2utildqblk(& dquot->dq_dqb, & kdqblk);
      }
    }
#line 450
    return (dquot);
  }
  {
#line 452
  tmp___2 = qtree_read_dquot(h, id___0);
  }
#line 452
  return (tmp___2);
}
}
#line 459 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v2.c"
static int v2_commit_dquot___3(struct dquot *dquot , int flags___7 ) 
{ 
  struct util_dqblk *b ;
  char *tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  struct v2_kern_dqblk kdqblk ;
  int cmd ;
  int *tmp___2 ;
  long tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;

  {
#line 461
  b = & dquot->dq_dqb;
#line 463
  if ((dquot->dq_h)->qh_io_flags & 4) {
    {
#line 464
    tmp = gettext("Trying to write quota to readonly quotafile on %s\n");
#line 464
    errstr(tmp, (dquot->dq_h)->qh_quotadev);
#line 465
    tmp___0 = __errno_location();
#line 465
    *tmp___0 = 1;
    }
#line 466
    return (-1);
  }
#line 468
  if ((dquot->dq_h)->qh_io_flags & 1) {
#line 469
    if (kernel_iface == 3) {
      {
#line 470
      tmp___1 = vfs_set_dquot(dquot, flags___7);
      }
#line 470
      if (tmp___1 < 0) {
#line 471
        return (-1);
      }
    } else {
#line 477
      if (flags___7 == 10) {
#line 478
        cmd = 3840;
      } else
#line 479
      if (flags___7 == 5) {
#line 480
        cmd = 1792;
      } else
#line 481
      if (flags___7 & 48) {
        {
#line 482
        tmp___2 = __errno_location();
#line 482
        *tmp___2 = 22;
        }
#line 483
        return (-1);
      } else {
#line 486
        cmd = 3584;
      }
      {
#line 487
      v2_util2kerndqblk(& kdqblk, & dquot->dq_dqb);
#line 488
      tmp___3 = quotactl((cmd << 8) | ((dquot->dq_h)->qh_type & 255), (char const   *)((dquot->dq_h)->qh_quotadev),
                         dquot->dq_id, (caddr_t )((void *)(& kdqblk)));
      }
#line 488
      if (tmp___3 < 0L) {
#line 490
        return (-1);
      }
    }
#line 492
    return (0);
  }
#line 494
  if (! b->dqb_curspace) {
#line 494
    if (! b->dqb_curinodes) {
#line 494
      if (! b->dqb_bsoftlimit) {
#line 494
        if (! b->dqb_isoftlimit) {
#line 494
          if (! b->dqb_bhardlimit) {
#line 494
            if (! b->dqb_ihardlimit) {
              {
#line 496
              qtree_delete_dquot(dquot);
              }
            } else {
#line 494
              goto _L___3;
            }
          } else {
#line 494
            goto _L___3;
          }
        } else {
#line 494
          goto _L___3;
        }
      } else {
#line 494
        goto _L___3;
      }
    } else {
#line 494
      goto _L___3;
    }
  } else {
    _L___3: /* CIL Label */ 
    {
#line 498
    tmp___5 = check_dquot_range(dquot);
    }
#line 498
    if (tmp___5 < 0) {
      {
#line 499
      tmp___4 = __errno_location();
#line 499
      *tmp___4 = 34;
      }
#line 500
      return (-1);
    }
    {
#line 502
    qtree_write_dquot(dquot);
    }
  }
#line 504
  return (0);
}
}
#line 507 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v2.c"
static int v2_scan_dquots___3(struct quota_handle *h , int (*process_dquot)(struct dquot *dquot ,
                                                                            char *dqname ) ) 
{ 
  int tmp ;

  {
  {
#line 509
  tmp = qtree_scan_dquots(h, process_dquot);
  }
#line 509
  return (tmp);
}
}
#line 513 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v2.c"
static int v2_report___3(struct quota_handle *h , int verbose ) 
{ 
  struct v2_mem_dqinfo *info ;
  char *tmp ;

  {
#line 515
  if (verbose) {
    {
#line 516
    info = & h->qh_info.u.v2_mdqi;
#line 518
    tmp = gettext("Statistics:\nTotal blocks: %u\nData blocks: %u\nEntries: %u\nUsed average: %f\n");
#line 518
    printf((char const   */* __restrict  */)tmp, info->dqi_qtree.dqi_blocks, info->dqi_data_blocks,
           info->dqi_used_entries, (double )((float )info->dqi_used_entries / (float )info->dqi_data_blocks));
    }
  }
#line 522
  return (0);
}
}
#line 50 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v1.c"
static int v1_check_file___3(int fd , int type , int fmt___7 ) ;
#line 51
static int v1_init_io___3(struct quota_handle *h ) ;
#line 52
static int v1_new_io___3(struct quota_handle *h ) ;
#line 53
static int v1_write_info___3(struct quota_handle *h ) ;
#line 54
static struct dquot *v1_read_dquot___3(struct quota_handle *h , qid_t id___0 ) ;
#line 55
static int v1_commit_dquot___3(struct dquot *dquot , int flags___7 ) ;
#line 56
static int v1_scan_dquots___3(struct quota_handle *h , int (*process_dquot)(struct dquot *dquot ,
                                                                            char *dqname ) ) ;
#line 127 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v1.c"
static int v1_check_file___3(int fd , int type , int fmt___7 ) 
{ 
  struct stat st ;
  int tmp ;

  {
  {
#line 131
  tmp = fstat(fd, & st);
  }
#line 131
  if (tmp < 0) {
#line 132
    return (0);
  }
#line 133
  if (! st.st_size) {
#line 134
    return (0);
  } else
#line 133
  if ((unsigned long )st.st_size % sizeof(struct v1_disk_dqblk )) {
#line 134
    return (0);
  }
#line 135
  return (1);
}
}
#line 141 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v1.c"
static int v1_init_io___3(struct quota_handle *h ) 
{ 
  int tmp ;
  struct v1_kern_dqblk kdqblk ;
  time_t tmp___0 ;
  int *tmp___1 ;
  long tmp___2 ;
  struct v1_disk_dqblk ddqblk ;
  ssize_t tmp___3 ;

  {
#line 143
  if (h->qh_io_flags & 1) {
#line 144
    if (kernel_iface == 3) {
      {
#line 145
      tmp = vfs_get_info(h);
      }
#line 145
      if (tmp < 0) {
#line 146
        return (-1);
      }
    } else {
      {
#line 151
      tmp___2 = quotactl((768 << 8) | (h->qh_type & 255), (char const   *)(h->qh_quotadev),
                         (qid_t )0, (caddr_t )((void *)(& kdqblk)));
      }
#line 151
      if (tmp___2 < 0L) {
        {
#line 152
        tmp___1 = __errno_location();
        }
#line 152
        if (*tmp___1 == 1) {
#line 153
          tmp___0 = (time_t )0;
#line 153
          h->qh_info.dqi_igrace = tmp___0;
#line 153
          h->qh_info.dqi_bgrace = tmp___0;
        } else {
#line 156
          return (-1);
        }
      } else {
#line 159
        h->qh_info.dqi_bgrace = kdqblk.dqb_btime;
#line 160
        h->qh_info.dqi_igrace = kdqblk.dqb_itime;
      }
    }
  } else {
    {
#line 167
    lseek(h->qh_fd, (__off64_t )0, 0);
#line 168
    tmp___3 = read(h->qh_fd, (void *)(& ddqblk), sizeof(ddqblk));
    }
#line 168
    if ((unsigned long )tmp___3 != sizeof(ddqblk)) {
#line 169
      return (-1);
    }
#line 170
    h->qh_info.dqi_bgrace = ddqblk.dqb_btime;
#line 171
    h->qh_info.dqi_igrace = ddqblk.dqb_itime;
  }
#line 173
  if (! h->qh_info.dqi_bgrace) {
#line 174
    h->qh_info.dqi_bgrace = (time_t )604800;
  }
#line 175
  if (! h->qh_info.dqi_igrace) {
#line 176
    h->qh_info.dqi_igrace = (time_t )604800;
  }
#line 177
  h->qh_info.dqi_max_b_limit = (uint64_t )(~ ((uint32_t )0));
#line 178
  h->qh_info.dqi_max_i_limit = (uint64_t )(~ ((uint32_t )0));
#line 179
  h->qh_info.dqi_max_b_usage = 4294967295UL << 10;
#line 180
  h->qh_info.dqi_max_i_usage = (uint64_t )(~ ((uint32_t )0));
#line 182
  return (0);
}
}
#line 188 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v1.c"
static int v1_new_io___3(struct quota_handle *h ) 
{ 
  struct v1_disk_dqblk ddqblk ;
  ssize_t tmp ;

  {
  {
#line 193
  memset((void *)(& ddqblk), 0, sizeof(ddqblk));
#line 194
  ddqblk.dqb_btime = (time_t )604800;
#line 195
  ddqblk.dqb_itime = (time_t )604800;
#line 196
  h->qh_info.dqi_bgrace = (time_t )604800;
#line 197
  h->qh_info.dqi_igrace = (time_t )604800;
#line 198
  h->qh_info.dqi_max_b_limit = (uint64_t )(~ ((uint32_t )0));
#line 199
  h->qh_info.dqi_max_i_limit = (uint64_t )(~ ((uint32_t )0));
#line 200
  h->qh_info.dqi_max_b_usage = 4294967295UL << 10;
#line 201
  h->qh_info.dqi_max_i_usage = (uint64_t )(~ ((uint32_t )0));
#line 202
  lseek(h->qh_fd, (__off64_t )0, 0);
#line 203
  tmp = write(h->qh_fd, (void const   *)(& ddqblk), sizeof(ddqblk));
  }
#line 203
  if ((unsigned long )tmp != sizeof(ddqblk)) {
#line 204
    return (-1);
  }
#line 205
  return (0);
}
}
#line 211 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v1.c"
static int v1_write_info___3(struct quota_handle *h ) 
{ 
  char *tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  struct v1_kern_dqblk kdqblk ;
  long tmp___2 ;
  long tmp___3 ;
  struct v1_disk_dqblk ddqblk ;
  ssize_t tmp___4 ;
  ssize_t tmp___5 ;

  {
#line 213
  if (h->qh_io_flags & 4) {
    {
#line 214
    tmp = gettext("Trying to write info to readonly quotafile on %s.\n");
#line 214
    errstr(tmp, h->qh_quotadev);
#line 215
    tmp___0 = __errno_location();
#line 215
    *tmp___0 = 1;
    }
#line 216
    return (-1);
  }
#line 218
  if (h->qh_io_flags & 1) {
#line 219
    if (kernel_iface == 3) {
      {
#line 220
      tmp___1 = vfs_set_info(h, 3);
      }
#line 220
      if (tmp___1 < 0) {
#line 221
        return (-1);
      }
    } else {
      {
#line 226
      tmp___2 = quotactl((768 << 8) | (h->qh_type & 255), (char const   *)(h->qh_quotadev),
                         (qid_t )0, (caddr_t )((void *)(& kdqblk)));
      }
#line 226
      if (tmp___2 < 0L) {
#line 227
        return (-1);
      }
      {
#line 228
      kdqblk.dqb_btime = h->qh_info.dqi_bgrace;
#line 229
      kdqblk.dqb_itime = h->qh_info.dqi_igrace;
#line 230
      tmp___3 = quotactl((1024 << 8) | (h->qh_type & 255), (char const   *)(h->qh_quotadev),
                         (qid_t )0, (caddr_t )((void *)(& kdqblk)));
      }
#line 230
      if (tmp___3 < 0L) {
#line 231
        return (-1);
      }
    }
  } else {
    {
#line 237
    lseek(h->qh_fd, (__off64_t )0, 0);
#line 238
    tmp___4 = read(h->qh_fd, (void *)(& ddqblk), sizeof(ddqblk));
    }
#line 238
    if ((unsigned long )tmp___4 != sizeof(ddqblk)) {
#line 239
      return (-1);
    }
    {
#line 240
    ddqblk.dqb_btime = h->qh_info.dqi_bgrace;
#line 241
    ddqblk.dqb_itime = h->qh_info.dqi_igrace;
#line 242
    lseek(h->qh_fd, (__off64_t )0, 0);
#line 243
    tmp___5 = write(h->qh_fd, (void const   *)(& ddqblk), sizeof(ddqblk));
    }
#line 243
    if ((unsigned long )tmp___5 != sizeof(ddqblk)) {
#line 244
      return (-1);
    }
  }
#line 246
  return (0);
}
}
#line 253 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v1.c"
static struct dquot *v1_read_dquot___3(struct quota_handle *h , qid_t id___0 ) 
{ 
  struct v1_disk_dqblk ddqblk ;
  struct dquot *dquot ;
  struct dquot *tmp ;
  int tmp___0 ;
  struct v1_kern_dqblk kdqblk ;
  long tmp___1 ;
  ssize_t tmp___2 ;

  {
  {
#line 256
  tmp = get_empty_dquot();
#line 256
  dquot = tmp;
#line 258
  dquot->dq_id = id___0;
#line 259
  dquot->dq_h = h;
  }
#line 260
  if (h->qh_io_flags & 1) {
#line 261
    if (kernel_iface == 3) {
      {
#line 262
      tmp___0 = vfs_get_dquot(dquot);
      }
#line 262
      if (tmp___0 < 0) {
        {
#line 263
        free((void *)dquot);
        }
#line 264
        return ((struct dquot *)((void *)0));
      }
    } else {
      {
#line 270
      tmp___1 = quotactl((768 << 8) | (h->qh_type & 255), (char const   *)(h->qh_quotadev),
                         id___0, (caddr_t )((void *)(& kdqblk)));
      }
#line 270
      if (tmp___1 < 0L) {
        {
#line 271
        free((void *)dquot);
        }
#line 272
        return ((struct dquot *)((void *)0));
      }
      {
#line 274
      v1_kern2utildqblk(& dquot->dq_dqb, & kdqblk);
      }
    }
  } else {
    {
#line 278
    lseek(h->qh_fd, (loff_t )((unsigned long )id___0 * sizeof(struct v1_disk_dqblk )),
          0);
#line 279
    tmp___2 = read(h->qh_fd, (void *)(& ddqblk), sizeof(ddqblk));
    }
    {
#line 280
    if (tmp___2 == 0L) {
#line 280
      goto case_0;
    }
#line 287
    if (tmp___2 == (ssize_t )sizeof(struct v1_disk_dqblk )) {
#line 287
      goto case_exp;
    }
#line 290
    goto switch_default;
    case_0: /* CIL Label */ 
    {
#line 285
    memset((void *)(& dquot->dq_dqb), 0, sizeof(struct util_dqblk ));
    }
#line 286
    goto switch_break;
    case_exp: /* CIL Label */ 
    {
#line 288
    v1_disk2memdqblk(& dquot->dq_dqb, & ddqblk);
    }
#line 289
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 291
    free((void *)dquot);
    }
#line 292
    return ((struct dquot *)((void *)0));
    switch_break: /* CIL Label */ ;
    }
  }
#line 295
  return (dquot);
}
}
#line 302 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v1.c"
static int v1_commit_dquot___3(struct dquot *dquot , int flags___7 ) 
{ 
  struct v1_disk_dqblk ddqblk ;
  struct quota_handle *h ;
  char *tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  struct v1_kern_dqblk kdqblk ;
  int cmd ;
  int *tmp___2 ;
  long tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;
  ssize_t tmp___6 ;

  {
#line 305
  h = dquot->dq_h;
#line 307
  if (h->qh_io_flags & 4) {
    {
#line 308
    tmp = gettext("Trying to write quota to readonly quotafile on %s\n");
#line 308
    errstr(tmp, h->qh_quotadev);
#line 309
    tmp___0 = __errno_location();
#line 309
    *tmp___0 = 1;
    }
#line 310
    return (-1);
  }
#line 312
  if (h->qh_io_flags & 1) {
#line 313
    if (kernel_iface == 3) {
      {
#line 314
      tmp___1 = vfs_set_dquot(dquot, flags___7);
      }
#line 314
      if (tmp___1 < 0) {
#line 315
        return (-1);
      }
    } else {
#line 321
      if (flags___7 == 10) {
#line 322
        cmd = 1280;
      } else
#line 323
      if (flags___7 == 5) {
#line 324
        cmd = 1792;
      } else
#line 325
      if (flags___7 & 48) {
        {
#line 326
        tmp___2 = __errno_location();
#line 326
        *tmp___2 = 22;
        }
#line 327
        return (-1);
      } else {
#line 330
        cmd = 1024;
      }
      {
#line 331
      v1_util2kerndqblk(& kdqblk, & dquot->dq_dqb);
#line 332
      tmp___3 = quotactl((cmd << 8) | (h->qh_type & 255), (char const   *)(h->qh_quotadev),
                         dquot->dq_id, (caddr_t )((void *)(& kdqblk)));
      }
#line 332
      if (tmp___3 < 0L) {
#line 334
        return (-1);
      }
    }
  } else {
    {
#line 338
    tmp___5 = check_dquot_range(dquot);
    }
#line 338
    if (tmp___5 < 0) {
      {
#line 339
      tmp___4 = __errno_location();
#line 339
      *tmp___4 = 34;
      }
#line 340
      return (-1);
    }
    {
#line 342
    v1_mem2diskdqblk(& ddqblk, & dquot->dq_dqb);
#line 343
    lseek(h->qh_fd, (loff_t )((unsigned long )dquot->dq_id * sizeof(struct v1_disk_dqblk )),
          0);
#line 344
    tmp___6 = write(h->qh_fd, (void const   *)(& ddqblk), sizeof(ddqblk));
    }
#line 344
    if ((unsigned long )tmp___6 != sizeof(ddqblk)) {
#line 345
      return (-1);
    }
  }
#line 347
  return (0);
}
}
#line 355 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v1.c"
static int v1_scan_dquots___3(struct quota_handle *h , int (*process_dquot)(struct dquot *dquot ,
                                                                            char *dqname ) ) 
{ 
  int rd ;
  int scanbufpos ;
  int scanbufsize ;
  char scanbuf[sizeof(struct v1_disk_dqblk ) * 256UL] ;
  struct v1_disk_dqblk *ddqblk ;
  struct dquot *dquot ;
  struct dquot *tmp ;
  qid_t id___0 ;
  ssize_t tmp___0 ;

  {
  {
#line 357
  scanbufpos = 0;
#line 357
  scanbufsize = 0;
#line 360
  tmp = get_empty_dquot();
#line 360
  dquot = tmp;
#line 361
  id___0 = (qid_t )0;
#line 363
  memset((void *)dquot, 0, sizeof(*dquot));
#line 364
  dquot->dq_h = h;
#line 365
  lseek(h->qh_fd, (__off64_t )0, 0);
#line 366
  id___0 = (qid_t )0;
  }
  {
#line 366
  while (1) {
    while_continue: /* CIL Label */ ;
#line 367
    if (scanbufpos >= scanbufsize) {
      {
#line 368
      tmp___0 = read(h->qh_fd, (void *)(scanbuf), sizeof(scanbuf));
#line 368
      rd = (int )tmp___0;
      }
#line 369
      if (rd < 0) {
#line 370
        goto out_err;
      } else
#line 369
      if ((unsigned long )rd % sizeof(struct v1_disk_dqblk )) {
#line 370
        goto out_err;
      }
#line 371
      if (! rd) {
#line 372
        goto while_break;
      }
#line 373
      scanbufpos = 0;
#line 374
      scanbufsize = (int )((unsigned long )rd / sizeof(struct v1_disk_dqblk ));
    }
#line 376
    ddqblk = (struct v1_disk_dqblk *)(scanbuf) + scanbufpos;
#line 377
    if ((((long )(((((ddqblk->dqb_ihardlimit | ddqblk->dqb_isoftlimit) | ddqblk->dqb_bhardlimit) | ddqblk->dqb_bsoftlimit) | ddqblk->dqb_curblocks) | ddqblk->dqb_curinodes) | ddqblk->dqb_itime) | ddqblk->dqb_btime) == 0L) {
#line 381
      goto __Cont;
    }
    {
#line 382
    v1_disk2memdqblk(& dquot->dq_dqb, ddqblk);
#line 383
    dquot->dq_id = id___0;
#line 384
    rd = (*process_dquot)(dquot, (char *)((void *)0));
    }
#line 384
    if (rd < 0) {
      {
#line 385
      free((void *)dquot);
      }
#line 386
      return (rd);
    }
    __Cont: /* CIL Label */ 
#line 366
    id___0 ++;
#line 366
    scanbufpos ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 389
  if (! rd) {
    {
#line 390
    free((void *)dquot);
    }
#line 391
    return (0);
  }
  out_err: 
  {
#line 394
  free((void *)dquot);
  }
#line 395
  return (-1);
}
}
#line 45 "/home/wheatley/newnew/temp/quota-4.01/quotaio_tree.c"
static int get_index___3(qid_t id___0 , int depth ) 
{ 


  {
#line 47
  return ((int )((id___0 >> ((4 - depth) - 1) * 8) & 255U));
}
}
#line 51 "/home/wheatley/newnew/temp/quota-4.01/quotaio_tree.c"
static void read_blk___3(struct quota_handle *h , uint blk , dqbuf_t buf ) 
{ 
  int err ;
  ssize_t tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 55
  lseek(h->qh_fd, (__off64_t )(blk << 10), 0);
#line 56
  tmp = read(h->qh_fd, (void *)buf, (size_t )(1 << 10));
#line 56
  err = (int )tmp;
  }
#line 57
  if (err < 0) {
    {
#line 58
    tmp___0 = __errno_location();
#line 58
    tmp___1 = strerror(*tmp___0);
#line 58
    tmp___2 = gettext("Cannot read block %u: %s\n");
#line 58
    die(2, tmp___2, blk, tmp___1);
    }
  } else
#line 59
  if (err != 1 << 10) {
    {
#line 60
    memset((void *)(buf + err), 0, (size_t )((1 << 10) - err));
    }
  }
#line 61
  return;
}
}
#line 64 "/home/wheatley/newnew/temp/quota-4.01/quotaio_tree.c"
static int write_blk___3(struct quota_handle *h , uint blk , dqbuf_t buf ) 
{ 
  int err ;
  ssize_t tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  int *tmp___3 ;

  {
  {
#line 68
  lseek(h->qh_fd, (__off64_t )(blk << 10), 0);
#line 69
  tmp = write(h->qh_fd, (void const   *)buf, (size_t )(1 << 10));
#line 69
  err = (int )tmp;
  }
#line 70
  if (err < 0) {
    {
#line 70
    tmp___3 = __errno_location();
    }
#line 70
    if (*tmp___3 != 28) {
      {
#line 71
      tmp___0 = __errno_location();
#line 71
      tmp___1 = strerror(*tmp___0);
#line 71
      tmp___2 = gettext("Cannot write block (%u): %s\n");
#line 71
      die(2, tmp___2, blk, tmp___1);
      }
    }
  }
#line 72
  if (err != 1 << 10) {
#line 73
    return (-28);
  }
#line 74
  return (0);
}
}
#line 78 "/home/wheatley/newnew/temp/quota-4.01/quotaio_tree.c"
static int get_free_dqblk___3(struct quota_handle *h ) 
{ 
  dqbuf_t buf ;
  void *tmp ;
  struct qt_disk_dqdbheader *dh ;
  struct qtree_mem_dqinfo *info ;
  int blk ;
  char *tmp___0 ;
  int tmp___1 ;
  unsigned int tmp___2 ;

  {
  {
#line 80
  tmp = smalloc((size_t )(1 << 10));
#line 80
  buf = (dqbuf_t )tmp;
#line 81
  dh = (struct qt_disk_dqdbheader *)buf;
#line 82
  info = & h->qh_info.u.v2_mdqi.dqi_qtree;
  }
#line 85
  if (info->dqi_free_blk) {
    {
#line 86
    blk = (int )info->dqi_free_blk;
#line 87
    read_blk___3(h, (uint )blk, buf);
#line 88
    info->dqi_free_blk = dh->dqdh_next_free;
    }
  } else {
    {
#line 91
    memset((void *)buf, 0, (size_t )(1 << 10));
#line 92
    tmp___1 = write_blk___3(h, info->dqi_blocks, buf);
    }
#line 92
    if (tmp___1 < 0) {
      {
#line 93
      free((void *)buf);
#line 94
      tmp___0 = gettext("Cannot allocate new quota block (out of disk space).\n");
#line 94
      errstr(tmp___0);
      }
#line 95
      return (-28);
    }
#line 97
    tmp___2 = info->dqi_blocks;
#line 97
    (info->dqi_blocks) ++;
#line 97
    blk = (int )tmp___2;
  }
  {
#line 99
  mark_quotafile_info_dirty(h);
#line 100
  free((void *)buf);
  }
#line 101
  return (blk);
}
}
#line 105 "/home/wheatley/newnew/temp/quota-4.01/quotaio_tree.c"
static void put_free_dqblk___3(struct quota_handle *h , dqbuf_t buf , uint blk ) 
{ 
  struct qt_disk_dqdbheader *dh ;
  struct qtree_mem_dqinfo *info ;

  {
  {
#line 107
  dh = (struct qt_disk_dqdbheader *)buf;
#line 108
  info = & h->qh_info.u.v2_mdqi.dqi_qtree;
#line 110
  dh->dqdh_next_free = info->dqi_free_blk;
#line 111
  dh->dqdh_prev_free = (__u32 )0;
#line 112
  dh->dqdh_entries = (__u16 )0;
#line 113
  info->dqi_free_blk = blk;
#line 114
  mark_quotafile_info_dirty(h);
#line 115
  write_blk___3(h, blk, buf);
  }
#line 116
  return;
}
}
#line 119 "/home/wheatley/newnew/temp/quota-4.01/quotaio_tree.c"
static void remove_free_dqentry___3(struct quota_handle *h , dqbuf_t buf , uint blk ) 
{ 
  dqbuf_t tmpbuf ;
  void *tmp ;
  struct qt_disk_dqdbheader *dh ;
  uint nextblk ;
  uint prevblk ;
  u_int32_t tmp___0 ;

  {
  {
#line 121
  tmp = smalloc((size_t )(1 << 10));
#line 121
  tmpbuf = (dqbuf_t )tmp;
#line 122
  dh = (struct qt_disk_dqdbheader *)buf;
#line 123
  nextblk = dh->dqdh_next_free;
#line 123
  prevblk = dh->dqdh_prev_free;
  }
#line 127
  if (nextblk) {
    {
#line 128
    read_blk___3(h, nextblk, tmpbuf);
#line 129
    ((struct qt_disk_dqdbheader *)tmpbuf)->dqdh_prev_free = dh->dqdh_prev_free;
#line 130
    write_blk___3(h, nextblk, tmpbuf);
    }
  }
#line 132
  if (prevblk) {
    {
#line 133
    read_blk___3(h, prevblk, tmpbuf);
#line 134
    ((struct qt_disk_dqdbheader *)tmpbuf)->dqdh_next_free = dh->dqdh_next_free;
#line 135
    write_blk___3(h, prevblk, tmpbuf);
    }
  } else {
    {
#line 138
    h->qh_info.u.v2_mdqi.dqi_qtree.dqi_free_entry = nextblk;
#line 139
    mark_quotafile_info_dirty(h);
    }
  }
  {
#line 141
  free((void *)tmpbuf);
#line 142
  tmp___0 = (__u32 )0;
#line 142
  dh->dqdh_prev_free = tmp___0;
#line 142
  dh->dqdh_next_free = tmp___0;
#line 143
  write_blk___3(h, blk, buf);
  }
#line 144
  return;
}
}
#line 147 "/home/wheatley/newnew/temp/quota-4.01/quotaio_tree.c"
static void insert_free_dqentry___3(struct quota_handle *h , dqbuf_t buf , uint blk ) 
{ 
  dqbuf_t tmpbuf ;
  void *tmp ;
  struct qt_disk_dqdbheader *dh ;
  struct qtree_mem_dqinfo *info ;

  {
  {
#line 149
  tmp = smalloc((size_t )(1 << 10));
#line 149
  tmpbuf = (dqbuf_t )tmp;
#line 150
  dh = (struct qt_disk_dqdbheader *)buf;
#line 151
  info = & h->qh_info.u.v2_mdqi.dqi_qtree;
#line 153
  dh->dqdh_next_free = info->dqi_free_entry;
#line 154
  dh->dqdh_prev_free = (__u32 )0;
#line 155
  write_blk___3(h, blk, buf);
  }
#line 156
  if (info->dqi_free_entry) {
    {
#line 157
    read_blk___3(h, info->dqi_free_entry, tmpbuf);
#line 158
    ((struct qt_disk_dqdbheader *)tmpbuf)->dqdh_prev_free = blk;
#line 159
    write_blk___3(h, info->dqi_free_entry, tmpbuf);
    }
  }
  {
#line 161
  free((void *)tmpbuf);
#line 162
  info->dqi_free_entry = blk;
#line 163
  mark_quotafile_info_dirty(h);
  }
#line 164
  return;
}
}
#line 167 "/home/wheatley/newnew/temp/quota-4.01/quotaio_tree.c"
static uint find_free_dqentry___3(struct quota_handle *h , struct dquot *dquot , int *err ) 
{ 
  int blk ;
  int i ;
  struct qt_disk_dqdbheader *dh ;
  struct qtree_mem_dqinfo *info ;
  char *ddquot ;
  dqbuf_t buf ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;

  {
  {
#line 171
  info = & h->qh_info.u.v2_mdqi.dqi_qtree;
#line 175
  *err = 0;
#line 176
  tmp = smalloc((size_t )(1 << 10));
#line 176
  buf = (dqbuf_t )tmp;
#line 177
  dh = (struct qt_disk_dqdbheader *)buf;
  }
#line 178
  if (info->dqi_free_entry) {
    {
#line 179
    blk = (int )info->dqi_free_entry;
#line 180
    read_blk___3(h, (uint )blk, buf);
    }
  } else {
    {
#line 183
    blk = get_free_dqblk___3(h);
    }
#line 184
    if (blk < 0) {
      {
#line 185
      free((void *)buf);
#line 186
      *err = blk;
      }
#line 187
      return ((uint )0);
    }
    {
#line 189
    memset((void *)buf, 0, (size_t )(1 << 10));
#line 190
    info->dqi_free_entry = (unsigned int )blk;
#line 191
    mark_quotafile_info_dirty(h);
    }
  }
  {
#line 193
  tmp___0 = qtree_dqstr_in_blk(info);
  }
#line 193
  if ((int )dh->dqdh_entries + 1 >= tmp___0) {
    {
#line 194
    remove_free_dqentry___3(h, buf, (uint )blk);
    }
  }
#line 195
  dh->dqdh_entries = (__u16 )((int )dh->dqdh_entries + 1);
#line 197
  ddquot = buf + sizeof(struct qt_disk_dqdbheader );
#line 198
  i = 0;
  {
#line 198
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 198
    tmp___1 = qtree_dqstr_in_blk(info);
    }
#line 198
    if (i < tmp___1) {
      {
#line 198
      tmp___2 = qtree_entry_unused(info, ddquot);
      }
#line 198
      if (tmp___2) {
#line 198
        goto while_break;
      }
    } else {
#line 198
      goto while_break;
    }
#line 198
    i ++;
#line 198
    ddquot += info->dqi_entry_size;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 201
  tmp___4 = qtree_dqstr_in_blk(info);
  }
#line 201
  if (i == tmp___4) {
    {
#line 202
    tmp___3 = gettext("find_free_dqentry(): Data block full but it shouldn\'t.\n");
#line 202
    die(2, tmp___3);
    }
  }
  {
#line 203
  write_blk___3(h, (uint )blk, buf);
#line 204
  dquot->dq_dqb.u.v2_mdqb.dqb_off = (loff_t )(((unsigned long )(blk << 10) + sizeof(struct qt_disk_dqdbheader )) + (unsigned long )((unsigned int )i * info->dqi_entry_size));
#line 207
  free((void *)buf);
  }
#line 208
  return ((uint )blk);
}
}
#line 212 "/home/wheatley/newnew/temp/quota-4.01/quotaio_tree.c"
static int do_insert_tree___3(struct quota_handle *h , struct dquot *dquot , uint *treeblk ,
                              int depth ) 
{ 
  dqbuf_t buf ;
  int newson ;
  int newact ;
  u_int32_t *ref ;
  uint newblk ;
  int ret ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;

  {
  {
#line 215
  newson = 0;
#line 215
  newact = 0;
#line 218
  ret = 0;
#line 220
  tmp = smalloc((size_t )(1 << 10));
#line 220
  buf = (dqbuf_t )tmp;
  }
#line 221
  if (! *treeblk) {
    {
#line 222
    ret = get_free_dqblk___3(h);
    }
#line 223
    if (ret < 0) {
#line 224
      goto out_buf;
    }
    {
#line 225
    *treeblk = (uint )ret;
#line 226
    memset((void *)buf, 0, (size_t )(1 << 10));
#line 227
    newact = 1;
    }
  } else {
    {
#line 230
    read_blk___3(h, *treeblk, buf);
    }
  }
  {
#line 231
  ref = (u_int32_t *)buf;
#line 232
  tmp___0 = get_index___3(dquot->dq_id, depth);
#line 232
  newblk = *(ref + tmp___0);
  }
#line 233
  if (! newblk) {
#line 234
    newson = 1;
  }
#line 235
  if (depth == 3) {
#line 236
    if (newblk) {
      {
#line 237
      tmp___1 = get_index___3(dquot->dq_id, depth);
#line 237
      tmp___2 = gettext("Inserting already present quota entry (block %u).\n");
#line 237
      die(2, tmp___2, *(ref + tmp___1));
      }
    }
    {
#line 239
    newblk = find_free_dqentry___3(h, dquot, & ret);
    }
  } else {
    {
#line 242
    ret = do_insert_tree___3(h, dquot, & newblk, depth + 1);
    }
  }
#line 243
  if (newson) {
#line 243
    if (ret >= 0) {
      {
#line 244
      tmp___3 = get_index___3(dquot->dq_id, depth);
#line 244
      *(ref + tmp___3) = newblk;
#line 245
      write_blk___3(h, *treeblk, buf);
      }
    } else {
#line 243
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 247
  if (newact) {
#line 247
    if (ret < 0) {
      {
#line 248
      put_free_dqblk___3(h, buf, *treeblk);
      }
    }
  }
  out_buf: 
  {
#line 250
  free((void *)buf);
  }
#line 251
  return (ret);
}
}
#line 255 "/home/wheatley/newnew/temp/quota-4.01/quotaio_tree.c"
static void dq_insert_tree___3(struct quota_handle *h , struct dquot *dquot ) 
{ 
  uint tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;

  {
  {
#line 257
  tmp = (uint )1;
#line 259
  tmp___3 = do_insert_tree___3(h, dquot, & tmp, 0);
  }
#line 259
  if (tmp___3 < 0) {
    {
#line 260
    tmp___0 = __errno_location();
#line 260
    tmp___1 = strerror(*tmp___0);
#line 260
    tmp___2 = gettext("Cannot write quota (id %u): %s\n");
#line 260
    die(2, tmp___2, dquot->dq_id, tmp___1);
    }
  }
#line 261
  return;
}
}
#line 284 "/home/wheatley/newnew/temp/quota-4.01/quotaio_tree.c"
static void free_dqentry___3(struct quota_handle *h , struct dquot *dquot , uint blk ) 
{ 
  struct qt_disk_dqdbheader *dh ;
  struct qtree_mem_dqinfo *info ;
  dqbuf_t buf ;
  void *tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 287
  info = & h->qh_info.u.v2_mdqi.dqi_qtree;
#line 288
  tmp = smalloc((size_t )(1 << 10));
#line 288
  buf = (dqbuf_t )tmp;
  }
#line 290
  if (dquot->dq_dqb.u.v2_mdqb.dqb_off >> 10 != (loff_t )blk) {
    {
#line 291
    tmp___0 = gettext("Quota structure has offset to other block (%u) than it should (%u).\n");
#line 291
    die(2, tmp___0, blk, (uint )(dquot->dq_dqb.u.v2_mdqb.dqb_off >> 10));
    }
  }
  {
#line 293
  read_blk___3(h, blk, buf);
#line 294
  dh = (struct qt_disk_dqdbheader *)buf;
#line 295
  dh->dqdh_entries = (__u16 )((int )dh->dqdh_entries - 1);
  }
#line 296
  if (! dh->dqdh_entries) {
    {
#line 297
    remove_free_dqentry___3(h, buf, blk);
#line 298
    put_free_dqblk___3(h, buf, blk);
    }
  } else {
    {
#line 301
    memset((void *)(buf + (dquot->dq_dqb.u.v2_mdqb.dqb_off & (long )((1 << 10) - 1))),
           0, (size_t )info->dqi_entry_size);
#line 304
    tmp___1 = qtree_dqstr_in_blk(info);
    }
#line 304
    if ((int )dh->dqdh_entries == tmp___1 - 1) {
      {
#line 305
      insert_free_dqentry___3(h, buf, blk);
      }
    } else {
      {
#line 307
      write_blk___3(h, blk, buf);
      }
    }
  }
  {
#line 309
  dquot->dq_dqb.u.v2_mdqb.dqb_off = (loff_t )0;
#line 310
  free((void *)buf);
  }
#line 311
  return;
}
}
#line 314 "/home/wheatley/newnew/temp/quota-4.01/quotaio_tree.c"
static void remove_tree___3(struct quota_handle *h , struct dquot *dquot , uint *blk ,
                            int depth ) 
{ 
  dqbuf_t buf ;
  void *tmp ;
  uint newblk ;
  u_int32_t *ref ;
  int tmp___0 ;
  int i ;
  int tmp___1 ;

  {
  {
#line 316
  tmp = smalloc((size_t )(1 << 10));
#line 316
  buf = (dqbuf_t )tmp;
#line 318
  ref = (u_int32_t *)buf;
#line 320
  read_blk___3(h, *blk, buf);
#line 321
  tmp___0 = get_index___3(dquot->dq_id, depth);
#line 321
  newblk = *(ref + tmp___0);
  }
#line 322
  if (depth == 3) {
    {
#line 323
    free_dqentry___3(h, dquot, newblk);
#line 324
    newblk = (uint )0;
    }
  } else {
    {
#line 327
    remove_tree___3(h, dquot, & newblk, depth + 1);
    }
  }
#line 328
  if (! newblk) {
    {
#line 331
    tmp___1 = get_index___3(dquot->dq_id, depth);
#line 331
    *(ref + tmp___1) = (__u32 )0;
#line 332
    i = 0;
    }
    {
#line 332
    while (1) {
      while_continue: /* CIL Label */ ;
#line 332
      if (i < 1 << 10) {
#line 332
        if (! (! *(buf + i))) {
#line 332
          goto while_break;
        }
      } else {
#line 332
        goto while_break;
      }
#line 332
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 334
    if (i == 1 << 10) {
#line 334
      if (*blk != 1U) {
        {
#line 335
        put_free_dqblk___3(h, buf, *blk);
#line 336
        *blk = (uint )0;
        }
      } else {
        {
#line 339
        write_blk___3(h, *blk, buf);
        }
      }
    } else {
      {
#line 339
      write_blk___3(h, *blk, buf);
      }
    }
  }
  {
#line 341
  free((void *)buf);
  }
#line 342
  return;
}
}
#line 355 "/home/wheatley/newnew/temp/quota-4.01/quotaio_tree.c"
static loff_t find_block_dqentry___3(struct quota_handle *h , struct dquot *dquot ,
                                     uint blk ) 
{ 
  struct qtree_mem_dqinfo *info ;
  dqbuf_t buf ;
  void *tmp ;
  int i ;
  char *ddquot ;
  int tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;

  {
  {
#line 357
  info = & h->qh_info.u.v2_mdqi.dqi_qtree;
#line 358
  tmp = smalloc((size_t )(1 << 10));
#line 358
  buf = (dqbuf_t )tmp;
#line 360
  ddquot = buf + sizeof(struct qt_disk_dqdbheader );
#line 362
  read_blk___3(h, blk, buf);
#line 363
  i = 0;
  }
  {
#line 363
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 363
    tmp___0 = qtree_dqstr_in_blk(info);
    }
#line 363
    if (i < tmp___0) {
      {
#line 363
      tmp___1 = (*((info->dqi_ops)->is_id))((void *)ddquot, dquot);
      }
#line 363
      if (tmp___1) {
#line 363
        goto while_break;
      }
    } else {
#line 363
      goto while_break;
    }
#line 363
    i ++;
#line 363
    ddquot += info->dqi_entry_size;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 366
  tmp___3 = qtree_dqstr_in_blk(info);
  }
#line 366
  if (i == tmp___3) {
    {
#line 367
    tmp___2 = gettext("Quota for id %u referenced but not present.\n");
#line 367
    die(2, tmp___2, dquot->dq_id);
    }
  }
  {
#line 368
  free((void *)buf);
  }
#line 369
  return ((loff_t )(((unsigned long )(blk << 10) + sizeof(struct qt_disk_dqdbheader )) + (unsigned long )((unsigned int )i * info->dqi_entry_size)));
}
}
#line 374 "/home/wheatley/newnew/temp/quota-4.01/quotaio_tree.c"
static loff_t find_tree_dqentry___3(struct quota_handle *h , struct dquot *dquot ,
                                    uint blk , int depth ) 
{ 
  dqbuf_t buf ;
  void *tmp ;
  loff_t ret ;
  u_int32_t *ref ;
  int tmp___0 ;

  {
  {
#line 376
  tmp = smalloc((size_t )(1 << 10));
#line 376
  buf = (dqbuf_t )tmp;
#line 377
  ret = (loff_t )0;
#line 378
  ref = (u_int32_t *)buf;
#line 380
  read_blk___3(h, blk, buf);
#line 381
  ret = (loff_t )0;
#line 382
  tmp___0 = get_index___3(dquot->dq_id, depth);
#line 382
  blk = *(ref + tmp___0);
  }
#line 383
  if (! blk) {
#line 384
    goto out_buf;
  }
#line 385
  if (depth < 3) {
    {
#line 386
    ret = find_tree_dqentry___3(h, dquot, blk, depth + 1);
    }
  } else {
    {
#line 388
    ret = find_block_dqentry___3(h, dquot, blk);
    }
  }
  out_buf: 
  {
#line 390
  free((void *)buf);
  }
#line 391
  return (ret);
}
}
#line 395 "/home/wheatley/newnew/temp/quota-4.01/quotaio_tree.c"
__inline static loff_t find_dqentry___3(struct quota_handle *h , struct dquot *dquot ) 
{ 
  loff_t tmp ;

  {
  {
#line 397
  tmp = find_tree_dqentry___3(h, dquot, (uint )1, 0);
  }
#line 397
  return (tmp);
}
}
#line 441 "/home/wheatley/newnew/temp/quota-4.01/quotaio_tree.c"
static int report_block___3(struct dquot *dquot , uint blk , char *bitmap , int (*process_dquot)(struct dquot * ,
                                                                                                 char * ) ) 
{ 
  struct qtree_mem_dqinfo *info ;
  dqbuf_t buf ;
  void *tmp ;
  struct qt_disk_dqdbheader *dh ;
  char *ddata ;
  int entries ;
  int i ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 444
  info = & (dquot->dq_h)->qh_info.u.v2_mdqi.dqi_qtree;
#line 445
  tmp = smalloc((size_t )(1 << 10));
#line 445
  buf = (dqbuf_t )tmp;
#line 450
  *(bitmap + (blk >> 3)) = (char )((int )*(bitmap + (blk >> 3)) | (1 << (blk & 7U)));
#line 451
  read_blk___3(dquot->dq_h, blk, buf);
#line 452
  dh = (struct qt_disk_dqdbheader *)buf;
#line 453
  ddata = buf + sizeof(struct qt_disk_dqdbheader );
#line 454
  entries = (int )dh->dqdh_entries;
#line 455
  i = 0;
  }
  {
#line 455
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 455
    tmp___2 = qtree_dqstr_in_blk(info);
    }
#line 455
    if (! (i < tmp___2)) {
#line 455
      goto while_break;
    }
    {
#line 456
    tmp___1 = qtree_entry_unused(info, ddata);
    }
#line 456
    if (! tmp___1) {
      {
#line 457
      (*((info->dqi_ops)->disk2mem_dqblk))(dquot, (void *)ddata);
#line 458
      tmp___0 = (*process_dquot)(dquot, (char *)((void *)0));
      }
#line 458
      if (tmp___0 < 0) {
#line 459
        goto while_break;
      }
    }
#line 455
    i ++;
#line 455
    ddata += info->dqi_entry_size;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 461
  free((void *)buf);
  }
#line 462
  return (entries);
}
}
#line 465 "/home/wheatley/newnew/temp/quota-4.01/quotaio_tree.c"
static void check_reference___3(struct quota_handle *h , uint blk ) 
{ 
  char *tmp ;
  char *tmp___0 ;

  {
#line 467
  if (blk >= h->qh_info.u.v2_mdqi.dqi_qtree.dqi_blocks) {
    {
#line 468
    tmp = type2name(h->qh_type);
#line 468
    tmp___0 = gettext("Illegal reference (%u >= %u) in %s quota file on %s. Quota file is probably corrupted.\nPlease run quotacheck(8) and try again.\n");
#line 468
    die(2, tmp___0, blk, h->qh_info.u.v2_mdqi.dqi_qtree.dqi_blocks, tmp, h->qh_quotadev);
    }
  }
#line 469
  return;
}
}
#line 471 "/home/wheatley/newnew/temp/quota-4.01/quotaio_tree.c"
static int report_tree___3(struct dquot *dquot , uint blk , int depth , char *bitmap ,
                           int (*process_dquot)(struct dquot * , char * ) ) 
{ 
  int entries ;
  int i ;
  dqbuf_t buf ;
  void *tmp ;
  u_int32_t *ref ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 474
  entries = 0;
#line 475
  tmp = smalloc((size_t )(1 << 10));
#line 475
  buf = (dqbuf_t )tmp;
#line 476
  ref = (u_int32_t *)buf;
#line 478
  read_blk___3(dquot->dq_h, blk, buf);
  }
#line 479
  if (depth == 3) {
#line 480
    i = 0;
    {
#line 480
    while (1) {
      while_continue: /* CIL Label */ ;
#line 480
      if (! (i < (1 << 10) >> 2)) {
#line 480
        goto while_break;
      }
      {
#line 481
      blk = *(ref + i);
#line 482
      check_reference___3(dquot->dq_h, blk);
      }
#line 483
      if (blk) {
#line 483
        if (! ((int )*(bitmap + (blk >> 3)) & (1 << (blk & 7U)))) {
          {
#line 484
          tmp___0 = report_block___3(dquot, blk, bitmap, process_dquot);
#line 484
          entries += tmp___0;
          }
        }
      }
#line 480
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 488
    i = 0;
    {
#line 488
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 488
      if (! (i < (1 << 10) >> 2)) {
#line 488
        goto while_break___0;
      }
#line 489
      blk = *(ref + i);
#line 489
      if (blk) {
        {
#line 490
        check_reference___3(dquot->dq_h, blk);
#line 491
        tmp___1 = report_tree___3(dquot, blk, depth + 1, bitmap, process_dquot);
#line 491
        entries += tmp___1;
        }
      }
#line 488
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  {
#line 495
  free((void *)buf);
  }
#line 496
  return (entries);
}
}
#line 499 "/home/wheatley/newnew/temp/quota-4.01/quotaio_tree.c"
static uint find_set_bits___3(char *bmp , int blocks ) 
{ 
  uint i ;
  uint used ;

  {
#line 501
  used = (uint )0;
#line 503
  i = (uint )0;
  {
#line 503
  while (1) {
    while_continue: /* CIL Label */ ;
#line 503
    if (! (i < (uint )blocks)) {
#line 503
      goto while_break;
    }
#line 504
    if ((int )*(bmp + (i >> 3)) & (1 << (i & 7U))) {
#line 505
      used ++;
    }
#line 503
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 506
  return (used);
}
}
#line 19 "/home/wheatley/newnew/temp/quota-4.01/quotaio_meta.c"
static int meta_init_io___3(struct quota_handle *h ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
#line 21
  if (! (h->qh_io_flags & 1)) {
    {
#line 22
    tmp = gettext("Metadata init_io called when kernel support is not enabled.\n");
#line 22
    errstr(tmp);
    }
#line 23
    return (-1);
  }
#line 25
  if (kernel_iface != 3) {
    {
#line 26
    tmp___0 = gettext("Metadata init_io called when kernel does not support generic quota interface!\n");
#line 26
    errstr(tmp___0);
    }
#line 27
    return (-1);
  }
  {
#line 29
  tmp___1 = vfs_get_info(h);
  }
#line 29
  return (tmp___1);
}
}
#line 32 "/home/wheatley/newnew/temp/quota-4.01/quotaio_meta.c"
static int meta_write_info___3(struct quota_handle *h ) 
{ 
  int tmp ;

  {
  {
#line 34
  tmp = vfs_set_info(h, 3);
  }
#line 34
  return (tmp);
}
}
#line 37 "/home/wheatley/newnew/temp/quota-4.01/quotaio_meta.c"
static struct dquot *meta_read_dquot___3(struct quota_handle *h , qid_t id___0 ) 
{ 
  struct dquot *dquot ;
  struct dquot *tmp ;
  int tmp___0 ;

  {
  {
#line 39
  tmp = get_empty_dquot();
#line 39
  dquot = tmp;
#line 41
  dquot->dq_id = id___0;
#line 42
  dquot->dq_h = h;
#line 43
  memset((void *)(& dquot->dq_dqb), 0, sizeof(struct util_dqblk ));
#line 44
  tmp___0 = vfs_get_dquot(dquot);
  }
#line 44
  if (tmp___0 < 0) {
    {
#line 45
    free((void *)dquot);
    }
#line 46
    return ((struct dquot *)((void *)0));
  }
#line 48
  return (dquot);
}
}
#line 51 "/home/wheatley/newnew/temp/quota-4.01/quotaio_meta.c"
static int meta_commit_dquot___3(struct dquot *dquot , int flags___7 ) 
{ 
  int tmp ;

  {
  {
#line 53
  tmp = vfs_set_dquot(dquot, flags___7);
  }
#line 53
  return (tmp);
}
}
#line 56 "/home/wheatley/newnew/temp/quota-4.01/quotaio_meta.c"
static int meta_scan_dquots___3(struct quota_handle *h , int (*process_dquot)(struct dquot *dquot ,
                                                                              char *dqname ) ) 
{ 
  int tmp ;

  {
  {
#line 58
  tmp = generic_scan_dquots(h, process_dquot, & vfs_get_dquot);
  }
#line 58
  return (tmp);
}
}
#line 10 "/home/wheatley/newnew/temp/quota-4.01/rquota_clnt.c"
static struct timeval TIMEOUT___3  =    {(__time_t )25, (__suseconds_t )0};
#line 15 "/home/wheatley/newnew/temp/quota-4.01/rquota_clnt.c"
static getquota_rslt clnt_res___31  ;
#line 30 "/home/wheatley/newnew/temp/quota-4.01/rquota_clnt.c"
static getquota_rslt clnt_res___32  ;
#line 45 "/home/wheatley/newnew/temp/quota-4.01/rquota_clnt.c"
static setquota_rslt clnt_res___33  ;
#line 60 "/home/wheatley/newnew/temp/quota-4.01/rquota_clnt.c"
static setquota_rslt clnt_res___34  ;
#line 75 "/home/wheatley/newnew/temp/quota-4.01/rquota_clnt.c"
static getquota_rslt clnt_res___35  ;
#line 90 "/home/wheatley/newnew/temp/quota-4.01/rquota_clnt.c"
static getquota_rslt clnt_res___36  ;
#line 105 "/home/wheatley/newnew/temp/quota-4.01/rquota_clnt.c"
static setquota_rslt clnt_res___37  ;
#line 120 "/home/wheatley/newnew/temp/quota-4.01/rquota_clnt.c"
static setquota_rslt clnt_res___38  ;
#line 183 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1), __leaf__)) strtol)(char const   * __restrict  __nptr ,
                                                                                              char ** __restrict  __endptr ,
                                                                                              int __base ) ;
#line 375 "/usr/include/netinet/in.h"
extern  __attribute__((__nothrow__)) uint16_t ( __attribute__((__leaf__)) ntohs)(uint16_t __netshort )  __attribute__((__const__)) ;
#line 285 "/usr/include/rpc/xdr.h"
extern  __attribute__((__nothrow__)) bool_t ( __attribute__((__leaf__)) xdr_void)(void) ;
#line 342 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strstr)(char const   *__haystack ,
                                                                                                 char const   *__needle )  __attribute__((__pure__)) ;
#line 188 "/usr/include/rpc/svc.h"
extern  __attribute__((__nothrow__)) bool_t ( __attribute__((__leaf__)) svc_register)(SVCXPRT *__xprt ,
                                                                                      rpcprog_t __prog ,
                                                                                      rpcvers_t __vers ,
                                                                                      void (*__dispatch)(struct svc_req * ,
                                                                                                         SVCXPRT * ) ,
                                                                                      rpcprot_t __protocol ) ;
#line 244
extern  __attribute__((__nothrow__)) bool_t ( __attribute__((__leaf__)) svc_sendreply)(SVCXPRT *__xprt ,
                                                                                       bool_t (*__xdr_results)(XDR * ,
                                                                                                               void * 
                                                                                                               , ...) ,
                                                                                       caddr_t __xdr_location ) ;
#line 247
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) svcerr_decode)(SVCXPRT *__xprt ) ;
#line 249
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) svcerr_weakauth)(SVCXPRT *__xprt ) ;
#line 251
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) svcerr_noproc)(SVCXPRT *__xprt ) ;
#line 256
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) svcerr_auth)(SVCXPRT *__xprt ,
                                                                                   enum auth_stat __why ) ;
#line 260
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) svcerr_systemerr)(SVCXPRT *__xprt ) ;
#line 292
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) svc_run)(void) ;
#line 311
extern  __attribute__((__nothrow__)) SVCXPRT *( __attribute__((__leaf__)) svcudp_create)(int __sock ) ;
#line 318
extern  __attribute__((__nothrow__)) SVCXPRT *( __attribute__((__leaf__)) svctcp_create)(int __sock ,
                                                                                         u_int __sendsize ,
                                                                                         u_int __recvsize ) ;
#line 53 "/usr/include/arpa/inet.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) inet_ntoa)(struct in_addr __in ) ;
#line 71 "/usr/include/rpc/pmap_clnt.h"
extern  __attribute__((__nothrow__)) bool_t ( __attribute__((__leaf__)) pmap_unset)(u_long const   __program ,
                                                                                    u_long const   __vers ) ;
#line 287 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) access)(char const   *__name ,
                                                                                             int __type ) ;
#line 937
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) daemon)(int __nochdir ,
                                                                             int __noclose ) ;
#line 60 "/home/wheatley/newnew/temp/quota-4.01/rquota_svc.c"
struct authunix_parms *unix_cred  ;
#line 66 "/home/wheatley/newnew/temp/quota-4.01/rquota_svc.c"
int flags  ;
#line 67 "/home/wheatley/newnew/temp/quota-4.01/rquota_svc.c"
static int port  ;
#line 68 "/home/wheatley/newnew/temp/quota-4.01/rquota_svc.c"
static char xtab_path[4096]  ;
#line 69 "/home/wheatley/newnew/temp/quota-4.01/rquota_svc.c"
char nfs_pseudoroot[4096]  ;
#line 71 "/home/wheatley/newnew/temp/quota-4.01/rquota_svc.c"
static struct option options[7]  = {      {"version", 0, (int *)((void *)0), 'V'}, 
        {"help", 0, (int *)((void *)0), 'h'}, 
        {"foreground", 0, (int *)((void *)0), 'F'}, 
        {"autofs", 0, (int *)((void *)0), 'I'}, 
        {"port", 1, (int *)((void *)0), 'p'}, 
        {"xtab", 1, (int *)((void *)0), 'x'}, 
        {(char const   *)((void *)0), 0, (int *)((void *)0), 0}};
#line 85 "/home/wheatley/newnew/temp/quota-4.01/rquota_svc.c"
static void show_help(void) 
{ 
  char *tmp ;

  {
  {
#line 99
  tmp = gettext("Usage: %s [options]\nOptions are:\n -h --help             shows this text\n -V --version          shows version information\n -F --foreground       starts the quota service in foreground\n -I --autofs           do not ignore mountpoints mounted by automounter\n -p --port <port>      listen on given port\n -x --xtab <path>      set an alternative file with NFSD export table\n");
#line 99
  errstr(tmp, progname);
  }
#line 107
  return;
}
}
#line 109 "/home/wheatley/newnew/temp/quota-4.01/rquota_svc.c"
static void parse_options___2(int argc , char **argv ) 
{ 
  char ostr[128] ;
  unsigned int tmp ;
  char *endptr ;
  int i ;
  int opt ;
  int j ;
  int tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;
  char *tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  char *tmp___8 ;

  {
#line 111
  ostr[0] = (char )'\000';
#line 111
  tmp = 1U;
  {
#line 111
  while (1) {
    while_continue: /* CIL Label */ ;
#line 111
    if (tmp >= 128U) {
#line 111
      goto while_break;
    }
#line 111
    ostr[tmp] = (char)0;
#line 111
    tmp ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 113
  j = 0;
#line 115
  sstrncpy(xtab_path, "/var/lib/nfs/etab", (size_t )4096);
#line 116
  i = 0;
  }
  {
#line 116
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 116
    if (! options[i].name) {
#line 116
      goto while_break___0;
    }
#line 117
    tmp___0 = j;
#line 117
    j ++;
#line 117
    ostr[tmp___0] = (char )options[i].val;
#line 118
    if (options[i].has_arg) {
#line 119
      tmp___1 = j;
#line 119
      j ++;
#line 119
      ostr[tmp___1] = (char )':';
    }
#line 116
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 121
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 121
    opt = getopt_long(argc, (char * const  *)argv, (char const   *)(ostr), (struct option  const  *)(options),
                      (int *)((void *)0));
    }
#line 121
    if (! (opt >= 0)) {
#line 121
      goto while_break___1;
    }
    {
#line 123
    if (opt == 86) {
#line 123
      goto case_86;
    }
#line 126
    if (opt == 104) {
#line 126
      goto case_104;
    }
#line 129
    if (opt == 70) {
#line 129
      goto case_70;
    }
#line 140
    if (opt == 73) {
#line 140
      goto case_73;
    }
#line 143
    if (opt == 112) {
#line 143
      goto case_112;
    }
#line 151
    if (opt == 120) {
#line 151
      goto case_120;
    }
#line 159
    goto switch_default;
    case_86: /* CIL Label */ 
    {
#line 124
    version();
#line 125
    exit(0);
    }
    case_104: /* CIL Label */ 
    {
#line 127
    show_help();
#line 128
    exit(0);
    }
    case_70: /* CIL Label */ 
#line 130
    flags |= 2;
#line 131
    goto switch_break;
    case_73: /* CIL Label */ 
#line 141
    flags |= 4;
#line 142
    goto switch_break;
    case_112: /* CIL Label */ 
    {
#line 144
    tmp___2 = strtol((char const   */* __restrict  */)optarg, (char **/* __restrict  */)(& endptr),
                     0);
#line 144
    port = (int )tmp___2;
    }
#line 145
    if (*endptr) {
      {
#line 146
      tmp___3 = gettext("Illegal port number: %s\n");
#line 146
      errstr(tmp___3, optarg);
#line 147
      show_help();
#line 148
      exit(1);
      }
    } else
#line 145
    if (port <= 0) {
      {
#line 146
      tmp___3 = gettext("Illegal port number: %s\n");
#line 146
      errstr(tmp___3, optarg);
#line 147
      show_help();
#line 148
      exit(1);
      }
    }
#line 150
    goto switch_break;
    case_120: /* CIL Label */ 
    {
#line 152
    tmp___7 = access((char const   *)optarg, 4);
    }
#line 152
    if (tmp___7 < 0) {
      {
#line 153
      tmp___4 = __errno_location();
#line 153
      tmp___5 = strerror(*tmp___4);
#line 153
      tmp___6 = gettext("Cannot access the specified xtab file %s: %s\n");
#line 153
      errstr(tmp___6, optarg, tmp___5);
#line 154
      show_help();
#line 155
      exit(1);
      }
    }
    {
#line 157
    sstrncpy(xtab_path, (char const   *)optarg, (size_t )4096);
    }
#line 158
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 160
    tmp___8 = gettext("Unknown option \'%c\'.\n");
#line 160
    errstr(tmp___8, opt);
#line 161
    show_help();
#line 162
    exit(1);
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 165
  return;
}
}
#line 172 "/home/wheatley/newnew/temp/quota-4.01/rquota_svc.c"
static int good_client(struct sockaddr_in *addr , ulong rq_proc ) 
{ 
  char *remote ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  uint16_t tmp___2 ;

  {
  {
#line 177
  tmp = inet_ntoa(addr->sin_addr);
#line 177
  remote = tmp;
  }
#line 179
  if (rq_proc == 3UL) {
#line 179
    goto _L;
  } else
#line 179
  if (rq_proc == 4UL) {
    _L: /* CIL Label */ 
#line 182
    if (! (flags & 1)) {
      {
#line 183
      tmp___0 = gettext("host %s attempted to call setquota when disabled\n");
#line 183
      errstr(tmp___0, remote);
      }
#line 186
      return (0);
    }
    {
#line 189
    tmp___2 = ntohs(addr->sin_port);
    }
#line 189
    if ((int )tmp___2 >= 1024) {
      {
#line 190
      tmp___1 = gettext("host %s attempted to call setquota from port >= 1024\n");
#line 190
      errstr(tmp___1, remote);
      }
#line 192
      return (0);
    }
  }
#line 209
  return (1);
}
}
#line 213 "/home/wheatley/newnew/temp/quota-4.01/rquota_svc.c"
static void rquotaprog_1(struct svc_req *rqstp , SVCXPRT *transp ) 
{ 
  union __anonunion_argument_79 argument ;
  char *result___1 ;
  bool_t (*xdr_argument)(XDR * , void *  , ...) ;
  bool_t (*xdr_result)(XDR * , void *  , ...) ;
  char *(*local)(char * , struct svc_req * ) ;
  int tmp ;
  bool_t tmp___0 ;
  bool_t tmp___1 ;
  char *tmp___2 ;
  bool_t tmp___3 ;

  {
  {
#line 228
  tmp = good_client(& (rqstp->rq_xprt)->xp_raddr, rqstp->rq_proc);
  }
#line 228
  if (! tmp) {
    {
#line 229
    svcerr_auth(transp, (enum auth_stat )7);
    }
#line 230
    return;
  }
#line 236
  if (rqstp->rq_proc == 0UL) {
    {
#line 237
    svc_sendreply(transp, (bool_t (*)(XDR * , void *  , ...))(& xdr_void), (char *)((void *)0));
    }
#line 238
    return;
  }
  {
#line 245
  if (rqstp->rq_cred.oa_flavor == 1) {
#line 245
    goto case_1;
  }
#line 249
  goto switch_default;
  case_1: /* CIL Label */ 
#line 246
  unix_cred = (struct authunix_parms *)rqstp->rq_clntcred;
#line 247
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 250
  svcerr_weakauth(transp);
  }
#line 251
  return;
  switch_break: /* CIL Label */ ;
  }
  {
#line 255
  if (rqstp->rq_proc == 1UL) {
#line 255
    goto case_1___0;
  }
#line 261
  if (rqstp->rq_proc == 3UL) {
#line 261
    goto case_3;
  }
#line 267
  if (rqstp->rq_proc == 2UL) {
#line 267
    goto case_2;
  }
#line 273
  if (rqstp->rq_proc == 4UL) {
#line 273
    goto case_4;
  }
#line 279
  goto switch_default___0;
  case_1___0: /* CIL Label */ 
#line 256
  xdr_argument = (bool_t (*)(XDR * , void *  , ...))(& xdr_getquota_args);
#line 257
  xdr_result = (bool_t (*)(XDR * , void *  , ...))(& xdr_getquota_rslt);
#line 258
  local = (char *(*)(char * , struct svc_req * ))(& rquotaproc_getquota_1_svc);
#line 259
  goto switch_break___0;
  case_3: /* CIL Label */ 
#line 262
  xdr_argument = (bool_t (*)(XDR * , void *  , ...))(& xdr_setquota_args);
#line 263
  xdr_result = (bool_t (*)(XDR * , void *  , ...))(& xdr_setquota_rslt);
#line 264
  local = (char *(*)(char * , struct svc_req * ))(& rquotaproc_setquota_1_svc);
#line 265
  goto switch_break___0;
  case_2: /* CIL Label */ 
#line 268
  xdr_argument = (bool_t (*)(XDR * , void *  , ...))(& xdr_getquota_args);
#line 269
  xdr_result = (bool_t (*)(XDR * , void *  , ...))(& xdr_getquota_rslt);
#line 270
  local = (char *(*)(char * , struct svc_req * ))(& rquotaproc_getactivequota_1_svc);
#line 271
  goto switch_break___0;
  case_4: /* CIL Label */ 
#line 274
  xdr_argument = (bool_t (*)(XDR * , void *  , ...))(& xdr_setquota_args);
#line 275
  xdr_result = (bool_t (*)(XDR * , void *  , ...))(& xdr_setquota_rslt);
#line 276
  local = (char *(*)(char * , struct svc_req * ))(& rquotaproc_setactivequota_1_svc);
#line 277
  goto switch_break___0;
  switch_default___0: /* CIL Label */ 
  {
#line 280
  svcerr_noproc(transp);
  }
#line 281
  return;
  switch_break___0: /* CIL Label */ ;
  }
  {
#line 283
  memset((void *)(& argument), 0, sizeof(argument));
#line 284
  tmp___0 = (*((transp->xp_ops)->xp_getargs))(transp, xdr_argument, (caddr_t )(& argument));
  }
#line 284
  if (! tmp___0) {
    {
#line 285
    svcerr_decode(transp);
    }
#line 286
    return;
  }
  {
#line 288
  result___1 = (*local)((char *)(& argument), rqstp);
  }
#line 289
  if ((unsigned long )result___1 != (unsigned long )((void *)0)) {
    {
#line 289
    tmp___1 = svc_sendreply(transp, xdr_result, result___1);
    }
#line 289
    if (! tmp___1) {
      {
#line 290
      svcerr_systemerr(transp);
      }
    }
  }
  {
#line 292
  tmp___3 = (*((transp->xp_ops)->xp_freeargs))(transp, xdr_argument, (caddr_t )(& argument));
  }
#line 292
  if (! tmp___3) {
    {
#line 293
    tmp___2 = gettext("unable to free arguments\n");
#line 293
    errstr(tmp___2);
#line 294
    exit(1);
    }
  }
#line 296
  return;
}
}
#line 299 "/home/wheatley/newnew/temp/quota-4.01/rquota_svc.c"
static void rquotaprog_2(struct svc_req *rqstp , SVCXPRT *transp ) 
{ 
  union __anonunion_argument_80 argument ;
  char *result___1 ;
  bool_t (*xdr_argument)(XDR * , void *  , ...) ;
  bool_t (*xdr_result)(XDR * , void *  , ...) ;
  char *(*local)(char * , struct svc_req * ) ;
  int tmp ;
  bool_t tmp___0 ;
  bool_t tmp___1 ;
  char *tmp___2 ;
  bool_t tmp___3 ;

  {
  {
#line 314
  tmp = good_client(& (rqstp->rq_xprt)->xp_raddr, rqstp->rq_proc);
  }
#line 314
  if (! tmp) {
    {
#line 315
    svcerr_auth(transp, (enum auth_stat )7);
    }
#line 316
    return;
  }
#line 322
  if (rqstp->rq_proc == 0UL) {
    {
#line 323
    svc_sendreply(transp, (bool_t (*)(XDR * , void *  , ...))(& xdr_void), (char *)((void *)0));
    }
#line 324
    return;
  }
  {
#line 331
  if (rqstp->rq_cred.oa_flavor == 1) {
#line 331
    goto case_1;
  }
#line 335
  goto switch_default;
  case_1: /* CIL Label */ 
#line 332
  unix_cred = (struct authunix_parms *)rqstp->rq_clntcred;
#line 333
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 336
  svcerr_weakauth(transp);
  }
#line 337
  return;
  switch_break: /* CIL Label */ ;
  }
  {
#line 341
  if (rqstp->rq_proc == 1UL) {
#line 341
    goto case_1___0;
  }
#line 347
  if (rqstp->rq_proc == 3UL) {
#line 347
    goto case_3;
  }
#line 353
  if (rqstp->rq_proc == 2UL) {
#line 353
    goto case_2;
  }
#line 359
  if (rqstp->rq_proc == 4UL) {
#line 359
    goto case_4;
  }
#line 365
  goto switch_default___0;
  case_1___0: /* CIL Label */ 
#line 342
  xdr_argument = (bool_t (*)(XDR * , void *  , ...))(& xdr_ext_getquota_args);
#line 343
  xdr_result = (bool_t (*)(XDR * , void *  , ...))(& xdr_getquota_rslt);
#line 344
  local = (char *(*)(char * , struct svc_req * ))(& rquotaproc_getquota_2_svc);
#line 345
  goto switch_break___0;
  case_3: /* CIL Label */ 
#line 348
  xdr_argument = (bool_t (*)(XDR * , void *  , ...))(& xdr_ext_setquota_args);
#line 349
  xdr_result = (bool_t (*)(XDR * , void *  , ...))(& xdr_setquota_rslt);
#line 350
  local = (char *(*)(char * , struct svc_req * ))(& rquotaproc_setquota_2_svc);
#line 351
  goto switch_break___0;
  case_2: /* CIL Label */ 
#line 354
  xdr_argument = (bool_t (*)(XDR * , void *  , ...))(& xdr_ext_getquota_args);
#line 355
  xdr_result = (bool_t (*)(XDR * , void *  , ...))(& xdr_getquota_rslt);
#line 356
  local = (char *(*)(char * , struct svc_req * ))(& rquotaproc_getactivequota_2_svc);
#line 357
  goto switch_break___0;
  case_4: /* CIL Label */ 
#line 360
  xdr_argument = (bool_t (*)(XDR * , void *  , ...))(& xdr_ext_setquota_args);
#line 361
  xdr_result = (bool_t (*)(XDR * , void *  , ...))(& xdr_setquota_rslt);
#line 362
  local = (char *(*)(char * , struct svc_req * ))(& rquotaproc_setactivequota_2_svc);
#line 363
  goto switch_break___0;
  switch_default___0: /* CIL Label */ 
  {
#line 366
  svcerr_noproc(transp);
  }
#line 367
  return;
  switch_break___0: /* CIL Label */ ;
  }
  {
#line 369
  memset((void *)(& argument), 0, sizeof(argument));
#line 370
  tmp___0 = (*((transp->xp_ops)->xp_getargs))(transp, xdr_argument, (caddr_t )(& argument));
  }
#line 370
  if (! tmp___0) {
    {
#line 371
    svcerr_decode(transp);
    }
#line 372
    return;
  }
  {
#line 374
  result___1 = (*local)((char *)(& argument), rqstp);
  }
#line 375
  if ((unsigned long )result___1 != (unsigned long )((void *)0)) {
    {
#line 375
    tmp___1 = svc_sendreply(transp, xdr_result, result___1);
    }
#line 375
    if (! tmp___1) {
      {
#line 376
      svcerr_systemerr(transp);
      }
    }
  }
  {
#line 378
  tmp___3 = (*((transp->xp_ops)->xp_freeargs))(transp, xdr_argument, (caddr_t )(& argument));
  }
#line 378
  if (! tmp___3) {
    {
#line 379
    tmp___2 = gettext("unable to free arguments\n");
#line 379
    errstr(tmp___2);
#line 380
    exit(1);
    }
  }
#line 382
  return;
}
}
#line 385 "/home/wheatley/newnew/temp/quota-4.01/rquota_svc.c"
static void unregister(int sig ) 
{ 


  {
  {
#line 388
  pmap_unset((u_long const   )100011, (u_long const   )1);
#line 389
  pmap_unset((u_long const   )100011, (u_long const   )2);
#line 390
  exit(0);
  }
}
}
#line 394 "/home/wheatley/newnew/temp/quota-4.01/rquota_svc.c"
static void get_pseudoroot(void) 
{ 
  FILE *f ;
  char exp_line[1024] ;
  char *c ;
  int *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 400
  strcpy((char */* __restrict  */)(nfs_pseudoroot), (char const   */* __restrict  */)"/");
#line 401
  f = fopen((char const   */* __restrict  */)(xtab_path), (char const   */* __restrict  */)"r");
  }
#line 401
  if (! f) {
    {
#line 402
    tmp = __errno_location();
#line 402
    tmp___0 = strerror(*tmp);
#line 402
    tmp___1 = gettext("Warning: Cannot open export table %s: %s\nUsing \'/\' as a pseudofilesystem root.\n");
#line 402
    errstr(tmp___1, xtab_path, tmp___0);
    }
#line 403
    return;
  }
  {
#line 405
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 405
    tmp___2 = fgets((char */* __restrict  */)(exp_line), (int )sizeof(exp_line), (FILE */* __restrict  */)f);
    }
#line 405
    if (! tmp___2) {
#line 405
      goto while_break;
    }
#line 406
    if ((int )exp_line[0] == 35) {
#line 407
      goto while_continue;
    } else
#line 406
    if ((int )exp_line[0] == 10) {
#line 407
      goto while_continue;
    }
    {
#line 408
    c = strchr((char const   *)(exp_line), '\t');
    }
#line 409
    if (! c) {
#line 410
      goto while_continue;
    }
    {
#line 411
    *c = (char)0;
#line 413
    c = strchr((char const   *)(c + 1), '(');
    }
#line 414
    if (! c) {
#line 415
      goto while_continue;
    }
    {
#line 416
    c = strstr((char const   *)c, "fsid=0");
    }
#line 417
    if (c) {
      {
#line 418
      sstrncpy(nfs_pseudoroot, (char const   *)(exp_line), (size_t )4096);
#line 419
      sstrncat(nfs_pseudoroot, "/", (size_t )4096);
      }
#line 420
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 423
  fclose(f);
  }
#line 424
  return;
}
}
#line 105 "/home/wheatley/newnew/temp/quota-4.01/quotaio_generic.c"
static int scan_one_dquot___3(struct dquot *dquot , int (*get_dquot)(struct dquot * ) ) 
{ 
  int ret ;
  struct util_dqblk *dqb ;

  {
  {
#line 108
  dqb = & dquot->dq_dqb;
#line 110
  memset((void *)dqb, 0, sizeof(struct util_dqblk ));
#line 111
  ret = (*get_dquot)(dquot);
  }
#line 112
  if (ret < 0) {
#line 113
    return (ret);
  }
#line 114
  if (! dqb->dqb_bhardlimit) {
#line 114
    if (! dqb->dqb_bsoftlimit) {
#line 114
      if (! dqb->dqb_ihardlimit) {
#line 114
        if (! dqb->dqb_isoftlimit) {
#line 114
          if (! dqb->dqb_curinodes) {
#line 114
            if (! dqb->dqb_curspace) {
#line 115
              return (1);
            }
          }
        }
      }
    }
  }
#line 116
  return (0);
}
}
#line 41 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static char extensions___3[4][20]  = { {        (char )'u',        (char )'s',        (char )'e',        (char )'r', 
            (char )'\000'}, 
   {        (char )'g',        (char )'r',        (char )'o',        (char )'u', 
            (char )'p',        (char )'\000'}, 
   {        (char )'u',        (char )'n',        (char )'d',        (char )'e', 
            (char )'f',        (char )'i',        (char )'n',        (char )'e', 
            (char )'d',        (char )'\000'}};
#line 42 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static char *basenames___3[6]  = {      (char *)"quota",      (char *)"aquota",      (char *)"aquota",      (char *)"", 
        (char *)"",      (char *)""};
#line 43 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static char *fmtnames___3[5]  = {      (char *)"vfsold",      (char *)"vfsv0",      (char *)"vfsv1",      (char *)"rpc", 
        (char *)"xfs"};
#line 245 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static int kern2utilfmt___3(int kernfmt ) 
{ 


  {
  {
#line 248
  if (kernfmt == 1) {
#line 248
    goto case_1;
  }
#line 250
  if (kernfmt == 2) {
#line 250
    goto case_2;
  }
#line 252
  if (kernfmt == 4) {
#line 252
    goto case_4;
  }
#line 254
  if (kernfmt == 3) {
#line 254
    goto case_3;
  }
#line 247
  goto switch_break;
  case_1: /* CIL Label */ 
#line 249
  return (0);
  case_2: /* CIL Label */ 
#line 251
  return (1);
  case_4: /* CIL Label */ 
#line 253
  return (2);
  case_3: /* CIL Label */ 
#line 255
  return (5);
  switch_break: /* CIL Label */ ;
  }
#line 257
  return (-1);
}
}
#line 394 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static int hasxfsquota___3(char const   *dev , struct mntent *mnt___2 , int type ,
                           int flags___7 ) 
{ 
  u_int16_t sbflags ;
  struct fs_quota_stat info ;
  long tmp ;

  {
#line 399
  if (flags___7 & 16) {
#line 400
    return (4);
  }
  {
#line 402
  memset((void *)(& info), 0, sizeof(struct fs_quota_stat ));
#line 403
  tmp = quotactl((((88 << 8) + 5) << 8) | (type & 255), dev, (qid_t )0, (caddr_t )((void *)(& info)));
  }
#line 403
  if (! tmp) {
#line 404
    sbflags = (u_int16_t )(((int )info.qs_flags & 65280) >> 8);
#line 405
    if (type == 0) {
#line 405
      if ((int )info.qs_flags & 1) {
#line 406
        return (4);
      } else {
#line 405
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 407
    if (type == 1) {
#line 407
      if ((int )info.qs_flags & (1 << 2)) {
#line 408
        return (4);
      }
    }
  }
#line 424
  return (-1);
}
}
#line 427 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static int hasvfsmetaquota___3(char const   *dev , struct mntent *mnt___2 , int type ,
                               int flags___7 ) 
{ 
  uint32_t fmt___7 ;
  long tmp ;

  {
  {
#line 431
  tmp = quotactl((8388612 << 8) | (type & 255), dev, (qid_t )0, (caddr_t )((void *)(& fmt___7)));
  }
#line 431
  if (! tmp) {
#line 432
    return (5);
  }
#line 433
  return (-1);
}
}
#line 465 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static char *hasmntoptarg___3(char const   *optstring , char const   *opt ) 
{ 
  char *p ;
  char *tmp ;
  size_t tmp___0 ;

  {
  {
#line 467
  tmp = str_hasmntopt(optstring, opt);
#line 467
  p = tmp;
  }
#line 469
  if (! p) {
#line 470
    return ((char *)((void *)0));
  }
  {
#line 471
  tmp___0 = strlen(opt);
#line 471
  p += tmp___0;
  }
#line 472
  if ((int )*p == 61) {
#line 472
    if ((int )*(p + 1) != 44) {
#line 473
      return (p + 1);
    }
  }
#line 474
  return ((char *)((void *)0));
}
}
#line 478 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static void copy_mntoptarg___3(char *buf , char const   *optarg___0 , int buflen ) 
{ 
  char *sep ;
  char *tmp ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  long tmp___4 ;

  {
  {
#line 480
  tmp = strchr(optarg___0, ',');
#line 480
  sep = tmp;
  }
#line 482
  if (! sep) {
    {
#line 483
    tmp___3 = strlen(optarg___0);
    }
#line 483
    if ((size_t )buflen < tmp___3 + 1UL) {
#line 483
      tmp___2 = (size_t )buflen;
    } else {
      {
#line 483
      tmp___1 = strlen(optarg___0);
#line 483
      tmp___2 = tmp___1 + 1UL;
      }
    }
    {
#line 483
    sstrncpy(buf, optarg___0, tmp___2);
    }
  } else {
#line 485
    if ((long )buflen < (sep - (char *)optarg___0) + 1L) {
#line 485
      tmp___4 = (long )buflen;
    } else {
#line 485
      tmp___4 = (sep - (char *)optarg___0) + 1L;
    }
    {
#line 485
    sstrncpy(buf, optarg___0, (size_t )tmp___4);
    }
  }
#line 486
  return;
}
}
#line 491 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static int hasquota___3(char const   *dev , struct mntent *mnt___2 , int type , int flags___7 ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  struct if_dqinfo kinfo ;
  long tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;

  {
  {
#line 493
  tmp___0 = strcmp((char const   *)mnt___2->mnt_type, "gfs2");
  }
#line 493
  if (tmp___0) {
    {
#line 493
    tmp___1 = strcmp((char const   *)mnt___2->mnt_type, "xfs");
    }
#line 493
    if (! tmp___1) {
      {
#line 495
      tmp = hasxfsquota___3(dev, mnt___2, type, flags___7);
      }
#line 495
      return (tmp);
    }
  } else {
    {
#line 495
    tmp = hasxfsquota___3(dev, mnt___2, type, flags___7);
    }
#line 495
    return (tmp);
  }
  {
#line 496
  tmp___3 = strcmp((char const   *)mnt___2->mnt_type, "ocfs2");
  }
#line 496
  if (! tmp___3) {
    {
#line 497
    tmp___2 = hasvfsmetaquota___3(dev, mnt___2, type, flags___7);
    }
#line 497
    return (tmp___2);
  }
  {
#line 504
  tmp___5 = strcmp((char const   *)mnt___2->mnt_type, "ext4");
  }
#line 504
  if (! tmp___5) {
    {
#line 507
    tmp___4 = quotactl((8388613 << 8) | (type & 255), dev, (qid_t )0, (caddr_t )((void *)(& kinfo)));
    }
#line 507
    if (tmp___4 == 0L) {
#line 508
      if (kinfo.dqi_flags & 65536U) {
#line 509
        return (5);
      }
    }
  }
  {
#line 513
  tmp___6 = nfs_fstype(mnt___2->mnt_type);
  }
#line 513
  if (tmp___6) {
#line 514
    return (3);
  }
#line 516
  if (type == 0) {
    {
#line 516
    tmp___7 = hasmntopt((struct mntent  const  *)mnt___2, "usrquota");
    }
#line 516
    if (tmp___7) {
#line 517
      return (6);
    } else {
      {
#line 516
      tmp___8 = hasmntoptarg___3((char const   *)mnt___2->mnt_opts, "usrjquota");
      }
#line 516
      if (tmp___8) {
#line 517
        return (6);
      }
    }
  }
#line 518
  if (type == 1) {
    {
#line 518
    tmp___9 = hasmntopt((struct mntent  const  *)mnt___2, "grpquota");
    }
#line 518
    if (tmp___9) {
#line 519
      return (6);
    } else {
      {
#line 518
      tmp___10 = hasmntoptarg___3((char const   *)mnt___2->mnt_opts, "grpjquota");
      }
#line 518
      if (tmp___10) {
#line 519
        return (6);
      }
    }
  }
#line 520
  if (type == 0) {
    {
#line 520
    tmp___11 = hasmntopt((struct mntent  const  *)mnt___2, "quota");
    }
#line 520
    if (tmp___11) {
#line 521
      return (6);
    }
  }
#line 522
  return (-1);
}
}
#line 526 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static int check_fmtfile_ok___3(char *name , int type , int fmt___7 , int flags___7 ) 
{ 
  struct stat st ;
  int *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;
  int fd ;
  int ret ;
  int tmp___4 ;
  int *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  int *tmp___8 ;
  int *tmp___9 ;

  {
#line 528
  if (! flags___7) {
#line 529
    return (1);
  }
#line 530
  if (flags___7 & 1) {
    {
#line 533
    tmp___3 = stat((char const   */* __restrict  */)name, (struct stat */* __restrict  */)(& st));
    }
#line 533
    if (tmp___3 < 0) {
      {
#line 534
      tmp___2 = __errno_location();
      }
#line 534
      if (*tmp___2 != 2) {
        {
#line 535
        tmp = __errno_location();
#line 535
        tmp___0 = strerror(*tmp);
#line 535
        tmp___1 = gettext("Cannot stat quota file %s: %s\n");
#line 535
        errstr(tmp___1, name, tmp___0);
        }
      }
#line 536
      return (0);
    }
  }
#line 539
  if (flags___7 & 2) {
    {
#line 540
    ret = 0;
#line 542
    fd = open((char const   *)name, 0);
    }
#line 542
    if (fd >= 0) {
      {
#line 543
      tmp___4 = is_tree_qfmt(fmt___7);
      }
#line 543
      if (tmp___4) {
        {
#line 544
        ret = (*(quotafile_ops_2.check_file))(fd, type, fmt___7);
        }
      } else {
        {
#line 546
        ret = (*(quotafile_ops_1.check_file))(fd, type, fmt___7);
        }
      }
      {
#line 547
      close(fd);
      }
#line 548
      if (ret <= 0) {
#line 549
        return (0);
      }
    } else {
      {
#line 551
      tmp___8 = __errno_location();
      }
#line 551
      if (*tmp___8 != 2) {
        {
#line 551
        tmp___9 = __errno_location();
        }
#line 551
        if (*tmp___9 != 1) {
          {
#line 552
          tmp___5 = __errno_location();
#line 552
          tmp___6 = strerror(*tmp___5);
#line 552
          tmp___7 = gettext("Cannot open quotafile %s: %s\n");
#line 552
          errstr(tmp___7, name, tmp___6);
          }
#line 553
          return (0);
        }
      }
    }
  }
#line 556
  return (1);
}
}
#line 629 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static int hlist_allocated___3  =    0;
#line 630 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static struct quota_handle **hlist___3  =    (struct quota_handle **)((void *)0);
#line 735 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static int kernel_qfmt_num___3  ;
#line 736 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static int kernel_qfmt___3[6]  ;
#line 828 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static int v1_kern_quota_on___3(char const   *dev , int type ) 
{ 
  char tmp[1024] ;
  qid_t id___0 ;
  __uid_t tmp___0 ;
  __gid_t tmp___1 ;
  __uid_t tmp___2 ;
  long tmp___3 ;

  {
#line 831
  if (type == 0) {
    {
#line 831
    tmp___0 = getuid();
#line 831
    tmp___2 = tmp___0;
    }
  } else {
    {
#line 831
    tmp___1 = getgid();
#line 831
    tmp___2 = tmp___1;
    }
  }
  {
#line 831
  id___0 = tmp___2;
#line 833
  tmp___3 = quotactl((768 << 8) | (type & 255), dev, id___0, tmp);
  }
#line 833
  if (! tmp___3) {
#line 834
    return (1);
  }
#line 835
  return (0);
}
}
#line 839 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static int v2_kern_quota_on___3(char const   *dev , int type ) 
{ 
  char tmp[1024] ;
  qid_t id___0 ;
  __uid_t tmp___0 ;
  __gid_t tmp___1 ;
  __uid_t tmp___2 ;
  long tmp___3 ;

  {
#line 842
  if (type == 0) {
    {
#line 842
    tmp___0 = getuid();
#line 842
    tmp___2 = tmp___0;
    }
  } else {
    {
#line 842
    tmp___1 = getgid();
#line 842
    tmp___2 = tmp___1;
    }
  }
  {
#line 842
  id___0 = tmp___2;
#line 844
  tmp___3 = quotactl((3328 << 8) | (type & 255), dev, id___0, tmp);
  }
#line 844
  if (! tmp___3) {
#line 845
    return (1);
  }
#line 846
  return (0);
}
}
#line 850 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static int xfs_kern_quota_on___3(char const   *dev , int type ) 
{ 
  struct fs_quota_stat info ;
  long tmp ;

  {
  {
#line 854
  tmp = quotactl((((88 << 8) + 5) << 8) | (type & 255), dev, (qid_t )0, (caddr_t )((void *)(& info)));
  }
#line 854
  if (! tmp) {
#line 855
    if (type == 0) {
#line 855
      if ((int )info.qs_flags & 1) {
#line 856
        return (1);
      }
    }
#line 857
    if (type == 1) {
#line 857
      if ((int )info.qs_flags & (1 << 2)) {
#line 858
        return (1);
      }
    }
  }
#line 860
  return (0);
}
}
#line 921 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static int mnt_entries_cnt___3  ;
#line 922 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static struct mount_entry *mnt_entries___3  ;
#line 923 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static int check_dirs_cnt___3  ;
#line 923 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static int act_checked___3  ;
#line 924 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static struct searched_dir *check_dirs___3  ;
#line 927 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static int cache_mnt_table___3(int flags___7 ) 
{ 
  FILE *mntf ;
  struct mntent *mnt___2 ;
  struct stat st ;
  struct statfs fsstat ;
  int allocated ;
  int i ;
  dev_t dev ;
  char mntpointbuf[4096] ;
  int autofsdircnt ;
  int autofsdir_allocated ;
  char **autofsdir ;
  char *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  char const   *devname ;
  char *opt ;
  int qfmt[2] ;
  char *tmp___2 ;
  int slen ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  void *tmp___6 ;
  size_t tmp___7 ;
  void *tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char loopdev[4096] ;
  char *tmp___13 ;
  int *tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;
  int *tmp___18 ;
  char *tmp___19 ;
  char *tmp___20 ;
  int tmp___21 ;
  int *tmp___22 ;
  char *tmp___23 ;
  char *tmp___24 ;
  int tmp___25 ;
  char *tmp___26 ;
  int tmp___27 ;
  int *tmp___28 ;
  char *tmp___29 ;
  char *tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;
  void *tmp___34 ;
  char *tmp___35 ;

  {
  {
#line 933
  allocated = 0;
#line 933
  i = 0;
#line 934
  dev = (dev_t )0;
#line 940
  mntf = setmntent("/proc/mounts", "r");
  }
#line 941
  if (mntf) {
#line 942
    goto alloc;
  }
  {
#line 944
  mntf = setmntent("/etc/mtab", "r");
  }
#line 945
  if (mntf) {
#line 946
    goto alloc;
  }
  {
#line 948
  mntf = setmntent("/etc/fstab", "r");
  }
#line 948
  if (! mntf) {
    {
#line 949
    tmp = gettext("Cannot open any file with mount points.\n");
#line 949
    errstr(tmp);
    }
#line 950
    return (-1);
  }
  alloc: 
  {
#line 954
  tmp___0 = smalloc(sizeof(struct mount_entry ) * 16UL);
#line 954
  mnt_entries___3 = (struct mount_entry *)tmp___0;
#line 955
  mnt_entries_cnt___3 = 0;
#line 956
  allocated += 16;
#line 958
  tmp___1 = smalloc(sizeof(char *) * 16UL);
#line 958
  autofsdir = (char **)tmp___1;
#line 959
  autofsdircnt = 0;
#line 960
  autofsdir_allocated = 16;
  }
  {
#line 961
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 961
    mnt___2 = getmntent(mntf);
    }
#line 961
    if (! mnt___2) {
#line 961
      goto while_break;
    }
    {
#line 966
    devname = get_device_name((char const   *)mnt___2->mnt_fsname);
    }
#line 966
    if (! devname) {
      {
#line 967
      tmp___2 = gettext("Cannot get device name for %s\n");
#line 967
      errstr(tmp___2, mnt___2->mnt_fsname);
      }
#line 968
      goto while_continue;
    }
#line 972
    i = 0;
    {
#line 972
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 972
      if (! (i < autofsdircnt)) {
#line 972
        goto while_break___0;
      }
      {
#line 973
      tmp___3 = strlen((char const   *)*(autofsdir + i));
#line 973
      slen = (int )tmp___3;
#line 975
      tmp___4 = strlen((char const   *)mnt___2->mnt_dir);
      }
#line 975
      if ((size_t )slen <= tmp___4) {
        {
#line 975
        tmp___5 = strncmp((char const   *)*(autofsdir + i), (char const   *)mnt___2->mnt_dir,
                          (size_t )slen);
        }
#line 975
        if (! tmp___5) {
#line 976
          goto while_break___0;
        }
      }
#line 972
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 978
    if (i < autofsdircnt) {
      {
#line 979
      free((void *)((char *)devname));
      }
#line 980
      goto while_continue;
    }
#line 983
    if (flags___7 & 2) {
      {
#line 983
      tmp___9 = strcmp((char const   *)mnt___2->mnt_type, "autofs");
      }
#line 983
      if (! tmp___9) {
#line 984
        if (autofsdircnt == autofsdir_allocated) {
          {
#line 985
          autofsdir_allocated += 16;
#line 986
          tmp___6 = srealloc((void *)autofsdir, (unsigned long )autofsdir_allocated * sizeof(char *));
#line 986
          autofsdir = (char **)tmp___6;
          }
        }
        {
#line 988
        tmp___7 = strlen((char const   *)mnt___2->mnt_dir);
#line 988
        tmp___8 = smalloc(tmp___7 + 2UL);
#line 988
        *(autofsdir + autofsdircnt) = (char *)tmp___8;
#line 989
        strcpy((char */* __restrict  */)*(autofsdir + autofsdircnt), (char const   */* __restrict  */)mnt___2->mnt_dir);
#line 990
        strcat((char */* __restrict  */)*(autofsdir + autofsdircnt), (char const   */* __restrict  */)"/");
#line 991
        autofsdircnt ++;
#line 992
        free((void *)((char *)devname));
        }
#line 993
        goto while_continue;
      }
    }
#line 996
    if (flags___7 & 8) {
      {
#line 996
      tmp___10 = nfs_fstype(mnt___2->mnt_type);
      }
#line 996
      if (tmp___10) {
        {
#line 997
        free((void *)((char *)devname));
        }
#line 998
        goto while_continue;
      }
    }
    {
#line 1000
    tmp___11 = hasmntopt((struct mntent  const  *)mnt___2, "noquota");
    }
#line 1000
    if (tmp___11) {
      {
#line 1001
      free((void *)((char *)devname));
      }
#line 1002
      goto while_continue;
    }
    {
#line 1004
    tmp___12 = hasmntopt((struct mntent  const  *)mnt___2, "bind");
    }
#line 1004
    if (tmp___12) {
      {
#line 1005
      free((void *)((char *)devname));
      }
#line 1006
      goto while_continue;
    }
    {
#line 1008
    opt = hasmntoptarg___3((char const   *)mnt___2->mnt_opts, "loop");
    }
#line 1008
    if (opt) {
      {
#line 1011
      copy_mntoptarg___3(opt, (char const   *)(loopdev), 4096);
#line 1012
      free((void *)((char *)devname));
#line 1013
      tmp___13 = sstrdup((char const   *)(loopdev));
#line 1013
      devname = (char const   *)tmp___13;
      }
    }
    {
#line 1018
    qfmt[0] = hasquota___3(devname, mnt___2, 0, flags___7);
#line 1019
    qfmt[1] = hasquota___3(devname, mnt___2, 1, flags___7);
    }
#line 1020
    if (qfmt[0] < 0) {
#line 1020
      if (qfmt[1] < 0) {
        {
#line 1021
        free((void *)((char *)devname));
        }
#line 1022
        goto while_continue;
      }
    }
    {
#line 1025
    tmp___17 = realpath((char const   */* __restrict  */)mnt___2->mnt_dir, (char */* __restrict  */)(mntpointbuf));
    }
#line 1025
    if (! tmp___17) {
      {
#line 1026
      tmp___14 = __errno_location();
#line 1026
      tmp___15 = strerror(*tmp___14);
#line 1026
      tmp___16 = gettext("Cannot resolve mountpoint path %s: %s\n");
#line 1026
      errstr(tmp___16, mnt___2->mnt_dir, tmp___15);
#line 1027
      free((void *)((char *)devname));
      }
#line 1028
      goto while_continue;
    }
    {
#line 1031
    tmp___21 = statfs((char const   *)(mntpointbuf), & fsstat);
    }
#line 1031
    if (tmp___21 != 0) {
      {
#line 1032
      tmp___18 = __errno_location();
#line 1032
      tmp___19 = strerror(*tmp___18);
#line 1032
      tmp___20 = gettext("Cannot statfs() %s: %s\n");
#line 1032
      errstr(tmp___20, mntpointbuf, tmp___19);
#line 1033
      free((void *)((char *)devname));
      }
#line 1034
      goto while_continue;
    }
#line 1037
    if (fsstat.f_blocks == 0UL) {
#line 1037
      if (fsstat.f_bfree == 0UL) {
#line 1037
        if (fsstat.f_bavail == 0UL) {
          {
#line 1038
          free((void *)((char *)devname));
          }
#line 1039
          goto while_continue;
        }
      }
    }
    {
#line 1042
    tmp___27 = nfs_fstype(mnt___2->mnt_type);
    }
#line 1042
    if (! tmp___27) {
      {
#line 1043
      tmp___25 = stat((char const   */* __restrict  */)devname, (struct stat */* __restrict  */)(& st));
      }
#line 1043
      if (tmp___25 < 0) {
        {
#line 1044
        tmp___22 = __errno_location();
#line 1044
        tmp___23 = strerror(*tmp___22);
#line 1044
        tmp___24 = gettext("Cannot stat() mounted device %s: %s\n");
#line 1044
        errstr(tmp___24, devname, tmp___23);
#line 1045
        free((void *)((char *)devname));
        }
#line 1046
        goto while_continue;
      }
#line 1048
      if (! ((st.st_mode & 61440U) == 24576U)) {
#line 1048
        if (! ((st.st_mode & 61440U) == 8192U)) {
          {
#line 1049
          tmp___26 = gettext("Device (%s) filesystem is mounted on unsupported device type. Skipping.\n");
#line 1049
          errstr(tmp___26, devname);
#line 1050
          free((void *)((char *)devname));
          }
#line 1051
          goto while_continue;
        }
      }
#line 1053
      dev = st.st_rdev;
#line 1054
      i = 0;
      {
#line 1054
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1054
        if (i < mnt_entries_cnt___3) {
#line 1054
          if (! ((mnt_entries___3 + i)->me_dev != dev)) {
#line 1054
            goto while_break___1;
          }
        } else {
#line 1054
          goto while_break___1;
        }
#line 1054
        i ++;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
    {
#line 1057
    tmp___33 = nfs_fstype(mnt___2->mnt_type);
    }
#line 1057
    if (tmp___33) {
#line 1057
      goto _L;
    } else
#line 1057
    if (i == mnt_entries_cnt___3) {
      _L: /* CIL Label */ 
      {
#line 1058
      tmp___31 = stat((char const   */* __restrict  */)mnt___2->mnt_dir, (struct stat */* __restrict  */)(& st));
      }
#line 1058
      if (tmp___31 < 0) {
        {
#line 1059
        tmp___28 = __errno_location();
#line 1059
        tmp___29 = strerror(*tmp___28);
#line 1059
        tmp___30 = gettext("Cannot stat() mountpoint %s: %s\n");
#line 1059
        errstr(tmp___30, mnt___2->mnt_dir, tmp___29);
#line 1060
        free((void *)((char *)devname));
        }
#line 1061
        goto while_continue;
      }
      {
#line 1063
      tmp___32 = nfs_fstype(mnt___2->mnt_type);
      }
#line 1063
      if (tmp___32) {
#line 1065
        dev = st.st_dev;
#line 1066
        if (! (flags___7 & 32)) {
#line 1067
          i = 0;
          {
#line 1067
          while (1) {
            while_continue___2: /* CIL Label */ ;
#line 1067
            if (i < mnt_entries_cnt___3) {
#line 1067
              if (! ((mnt_entries___3 + i)->me_dev != dev)) {
#line 1067
                goto while_break___2;
              }
            } else {
#line 1067
              goto while_break___2;
            }
#line 1067
            i ++;
          }
          while_break___2: /* CIL Label */ ;
          }
        } else {
#line 1070
          i = mnt_entries_cnt___3;
        }
      }
    }
#line 1073
    if (i == mnt_entries_cnt___3) {
#line 1074
      if (allocated == mnt_entries_cnt___3) {
        {
#line 1075
        allocated += 16;
#line 1076
        tmp___34 = srealloc((void *)mnt_entries___3, (unsigned long )allocated * sizeof(struct mount_entry ));
#line 1076
        mnt_entries___3 = (struct mount_entry *)tmp___34;
        }
      }
      {
#line 1078
      (mnt_entries___3 + i)->me_type = sstrdup((char const   *)mnt___2->mnt_type);
#line 1079
      (mnt_entries___3 + i)->me_opts = sstrdup((char const   *)mnt___2->mnt_opts);
#line 1080
      (mnt_entries___3 + i)->me_dev = dev;
#line 1081
      (mnt_entries___3 + i)->me_ino = st.st_ino;
#line 1082
      (mnt_entries___3 + i)->me_devname = devname;
#line 1083
      tmp___35 = sstrdup((char const   *)(mntpointbuf));
#line 1083
      (mnt_entries___3 + i)->me__dir = (char const   *)tmp___35;
#line 1084
      (mnt_entries___3 + i)->me_dir = (char const   *)((void *)0);
#line 1085
      memcpy((void */* __restrict  */)(& (mnt_entries___3 + i)->me_qfmt), (void const   */* __restrict  */)(qfmt),
             sizeof(qfmt));
#line 1086
      mnt_entries_cnt___3 ++;
      }
    } else {
      {
#line 1089
      free((void *)((char *)devname));
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1091
  endmntent(mntf);
#line 1093
  i = 0;
  }
  {
#line 1093
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 1093
    if (! (i < autofsdircnt)) {
#line 1093
      goto while_break___3;
    }
    {
#line 1094
    free((void *)*(autofsdir + i));
#line 1093
    i ++;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 1095
  free((void *)autofsdir);
  }
#line 1096
  return (0);
}
}
#line 1100 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static char const   *find_dir_mntpoint___3(struct stat *st ) 
{ 
  int i ;

  {
#line 1104
  i = 0;
  {
#line 1104
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1104
    if (! (i < mnt_entries_cnt___3)) {
#line 1104
      goto while_break;
    }
#line 1105
    if ((mnt_entries___3 + i)->me_dev == st->st_dev) {
#line 1106
      st->st_ino = (mnt_entries___3 + i)->me_ino;
#line 1107
      return ((mnt_entries___3 + i)->me__dir);
    }
#line 1104
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1109
  return ((char const   *)((void *)0));
}
}
#line 1113 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static int process_dirs___3(int dcnt , char **dirs , int flags___7 ) 
{ 
  struct stat st ;
  int i ;
  char mntpointbuf[4096] ;
  void *tmp ;
  char *devname ;
  char const   *tmp___0 ;
  char *tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  int *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  char const   *realmnt ;
  char *tmp___12 ;
  int *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  int mentry ;
  char *tmp___17 ;
  char *tmp___18 ;
  char *tmp___19 ;
  char *tmp___20 ;

  {
#line 1119
  check_dirs_cnt___3 = 0;
#line 1120
  act_checked___3 = -1;
#line 1121
  if (dcnt) {
    {
#line 1122
    tmp = smalloc(sizeof(struct searched_dir ) * (unsigned long )dcnt);
#line 1122
    check_dirs___3 = (struct searched_dir *)tmp;
#line 1123
    i = 0;
    }
    {
#line 1123
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1123
      if (! (i < dcnt)) {
#line 1123
        goto while_break;
      }
      {
#line 1124
      tmp___10 = strncmp((char const   *)*(dirs + i), "UUID=", (size_t )5);
      }
#line 1124
      if (tmp___10) {
        {
#line 1124
        tmp___11 = strncmp((char const   *)*(dirs + i), "LABEL=", (size_t )6);
        }
#line 1124
        if (tmp___11) {
          {
#line 1139
          tmp___9 = stat((char const   */* __restrict  */)*(dirs + i), (struct stat */* __restrict  */)(& st));
          }
#line 1139
          if (tmp___9 < 0) {
            {
#line 1140
            tmp___6 = __errno_location();
#line 1140
            tmp___7 = strerror(*tmp___6);
#line 1140
            tmp___8 = gettext("Cannot stat() given mountpoint %s: %s\nSkipping...\n");
#line 1140
            errstr(tmp___8, *(dirs + i), tmp___7);
            }
#line 1141
            goto __Cont;
          }
        } else {
          _L: /* CIL Label */ 
          {
#line 1125
          tmp___0 = get_device_name((char const   *)*(dirs + i));
#line 1125
          devname = (char *)tmp___0;
          }
#line 1127
          if (! devname) {
            {
#line 1128
            tmp___1 = gettext("Cannot find a device with %s.\nSkipping...\n");
#line 1128
            errstr(tmp___1, *(dirs + i));
            }
#line 1129
            goto __Cont;
          }
          {
#line 1131
          tmp___5 = stat((char const   */* __restrict  */)devname, (struct stat */* __restrict  */)(& st));
          }
#line 1131
          if (tmp___5 < 0) {
            {
#line 1132
            tmp___2 = __errno_location();
#line 1132
            tmp___3 = strerror(*tmp___2);
#line 1132
            tmp___4 = gettext("Cannot stat() a mountpoint with %s: %s\nSkipping...\n");
#line 1132
            errstr(tmp___4, *(dirs + i), tmp___3);
#line 1133
            free((void *)devname);
            }
#line 1134
            goto __Cont;
          }
          {
#line 1136
          free((void *)devname);
          }
        }
      } else {
#line 1124
        goto _L;
      }
#line 1143
      (check_dirs___3 + check_dirs_cnt___3)->sd_dir = (st.st_mode & 61440U) == 16384U;
#line 1144
      if ((st.st_mode & 61440U) == 16384U) {
#line 1145
        realmnt = (char const   *)*(dirs + i);
#line 1148
        if (flags___7 & 1) {
          {
#line 1148
          realmnt = find_dir_mntpoint___3(& st);
          }
#line 1148
          if (! realmnt) {
#line 1149
            if (! (flags___7 & 4)) {
              {
#line 1150
              tmp___12 = gettext("Cannot find a filesystem mountpoint for directory %s\n");
#line 1150
              errstr(tmp___12, *(dirs + i));
              }
            }
#line 1151
            goto __Cont;
          }
        }
        {
#line 1153
        (check_dirs___3 + check_dirs_cnt___3)->sd_dev = st.st_dev;
#line 1154
        (check_dirs___3 + check_dirs_cnt___3)->sd_ino = st.st_ino;
#line 1155
        tmp___16 = realpath((char const   */* __restrict  */)realmnt, (char */* __restrict  */)(mntpointbuf));
        }
#line 1155
        if (! tmp___16) {
          {
#line 1156
          tmp___13 = __errno_location();
#line 1156
          tmp___14 = strerror(*tmp___13);
#line 1156
          tmp___15 = gettext("Cannot resolve path %s: %s\n");
#line 1156
          errstr(tmp___15, realmnt, tmp___14);
          }
#line 1157
          goto __Cont;
        }
      } else
#line 1160
      if ((st.st_mode & 61440U) == 24576U) {
#line 1160
        goto _L___0;
      } else
#line 1160
      if ((st.st_mode & 61440U) == 8192U) {
        _L___0: /* CIL Label */ 
#line 1163
        (check_dirs___3 + check_dirs_cnt___3)->sd_dev = st.st_rdev;
#line 1164
        mentry = 0;
        {
#line 1164
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 1164
          if (mentry < mnt_entries_cnt___3) {
#line 1164
            if (! ((mnt_entries___3 + mentry)->me_dev != st.st_rdev)) {
#line 1164
              goto while_break___0;
            }
          } else {
#line 1164
            goto while_break___0;
          }
#line 1164
          mentry ++;
        }
        while_break___0: /* CIL Label */ ;
        }
#line 1165
        if (mentry == mnt_entries_cnt___3) {
#line 1166
          if (! (flags___7 & 4)) {
            {
#line 1167
            tmp___17 = gettext("Cannot find mountpoint for device %s\n");
#line 1167
            errstr(tmp___17, *(dirs + i));
            }
          }
#line 1168
          goto __Cont;
        }
        {
#line 1170
        sstrncpy(mntpointbuf, (mnt_entries___3 + mentry)->me__dir, (size_t )4095);
        }
      } else {
        {
#line 1173
        tmp___18 = gettext("Specified path %s is not directory nor device.\n");
#line 1173
        errstr(tmp___18, *(dirs + i));
        }
#line 1174
        goto __Cont;
      }
      {
#line 1176
      tmp___19 = sstrdup((char const   *)(mntpointbuf));
#line 1176
      (check_dirs___3 + check_dirs_cnt___3)->sd_name = (char const   *)tmp___19;
#line 1177
      check_dirs_cnt___3 ++;
      }
      __Cont: /* CIL Label */ 
#line 1123
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 1179
    if (! check_dirs_cnt___3) {
#line 1180
      if (! (flags___7 & 4)) {
        {
#line 1181
        tmp___20 = gettext("No correct mountpoint specified.\n");
#line 1181
        errstr(tmp___20);
        }
      }
      {
#line 1182
      free((void *)check_dirs___3);
      }
#line 1183
      return (-1);
    }
  }
#line 1186
  return (0);
}
}
#line 1204 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static int find_next_entry_all___3(int *pos ) 
{ 
  char *tmp ;

  {
  {
#line 1206
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1206
    act_checked___3 ++;
#line 1206
    if (! (act_checked___3 < mnt_entries_cnt___3)) {
#line 1206
      goto while_break;
    }
    {
#line 1207
    tmp = str_hasmntopt((char const   *)(mnt_entries___3 + act_checked___3)->me_opts,
                        "noauto");
    }
#line 1207
    if (! tmp) {
#line 1208
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1210
  if (act_checked___3 >= mnt_entries_cnt___3) {
#line 1211
    return (0);
  }
#line 1212
  *pos = act_checked___3;
#line 1213
  return (1);
}
}
#line 1217 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static int find_next_entry_sel___3(int *pos ) 
{ 
  int i ;
  struct searched_dir *sd ;
  char *tmp ;

  {
  restart: 
#line 1223
  act_checked___3 ++;
#line 1223
  if (act_checked___3 == check_dirs_cnt___3) {
#line 1224
    return (0);
  }
#line 1225
  sd = check_dirs___3 + act_checked___3;
#line 1226
  i = 0;
  {
#line 1226
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1226
    if (! (i < mnt_entries_cnt___3)) {
#line 1226
      goto while_break;
    }
#line 1227
    if (sd->sd_dir) {
#line 1228
      if (sd->sd_dev == (mnt_entries___3 + i)->me_dev) {
#line 1228
        if (sd->sd_ino == (mnt_entries___3 + i)->me_ino) {
#line 1229
          goto while_break;
        }
      }
    } else
#line 1232
    if (sd->sd_dev == (mnt_entries___3 + i)->me_dev) {
#line 1233
      goto while_break;
    }
#line 1226
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1235
  if (i == mnt_entries_cnt___3) {
    {
#line 1236
    tmp = gettext("Mountpoint (or device) %s not found or has no quota enabled.\n");
#line 1236
    errstr(tmp, sd->sd_name);
    }
#line 1237
    goto restart;
  }
#line 1239
  *pos = i;
#line 1240
  return (1);
}
}
#line 23 "/home/wheatley/newnew/temp/quota-4.01/common.c"
static int enable_syslog___4  =    0;
#line 31 "/home/wheatley/newnew/temp/quota-4.01/common.c"
static void do_syslog___4(int level , char const   *format , va_list args ) 
{ 
  char buf[1024] ;
  int i ;
  int j ;
  int tmp ;

  {
  {
#line 36
  vsnprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)format,
            args);
#line 39
  i = 0;
  }
  {
#line 39
  while (1) {
    while_continue: /* CIL Label */ ;
#line 39
    if (! buf[i]) {
#line 39
      goto while_break;
    }
#line 40
    j = i;
    {
#line 40
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 40
      if (buf[j]) {
#line 40
        if (! ((int )buf[j] != 10)) {
#line 40
          goto while_break___0;
        }
      } else {
#line 40
        goto while_break___0;
      }
#line 40
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 41
    if ((int )buf[j] == 10) {
#line 42
      tmp = j;
#line 42
      j ++;
#line 42
      buf[tmp] = (char )'\000';
    }
    {
#line 43
    syslog(level, "%s", buf + i);
#line 39
    i = j;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 45
  return;
}
}
#line 27 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v2.c"
static int v2_check_file___4(int fd , int type , int fmt___7 ) ;
#line 28
static int v2_init_io___4(struct quota_handle *h ) ;
#line 29
static int v2_new_io___4(struct quota_handle *h ) ;
#line 30
static int v2_write_info___4(struct quota_handle *h ) ;
#line 31
static struct dquot *v2_read_dquot___4(struct quota_handle *h , qid_t id___0 ) ;
#line 32
static int v2_commit_dquot___4(struct dquot *dquot , int flags___7 ) ;
#line 33
static int v2_scan_dquots___4(struct quota_handle *h , int (*process_dquot)(struct dquot *dquot ,
                                                                            char *dqname ) ) ;
#line 34
static int v2_report___4(struct quota_handle *h , int verbose ) ;
#line 53 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v2.c"
static void v2r0_disk2memdqblk___4(struct dquot *dquot , void *dp ) 
{ 
  struct util_dqblk *m ;
  struct v2r0_disk_dqblk *d ;
  struct v2r0_disk_dqblk empty ;
  int tmp ;

  {
  {
#line 55
  m = & dquot->dq_dqb;
#line 56
  d = (struct v2r0_disk_dqblk *)dp;
#line 58
  dquot->dq_id = d->dqb_id;
#line 59
  m->dqb_ihardlimit = (qsize_t )d->dqb_ihardlimit;
#line 60
  m->dqb_isoftlimit = (qsize_t )d->dqb_isoftlimit;
#line 61
  m->dqb_bhardlimit = (qsize_t )d->dqb_bhardlimit;
#line 62
  m->dqb_bsoftlimit = (qsize_t )d->dqb_bsoftlimit;
#line 63
  m->dqb_curinodes = (qsize_t )d->dqb_curinodes;
#line 64
  m->dqb_curspace = (qsize_t )((__le64 )d->dqb_curspace);
#line 65
  m->dqb_itime = (time_t )((__le64 )d->dqb_itime);
#line 66
  m->dqb_btime = (time_t )((__le64 )d->dqb_btime);
#line 68
  memset((void *)(& empty), 0, sizeof(struct v2r0_disk_dqblk ));
#line 69
  empty.dqb_itime = (u_int64_t )((__u64 )1);
#line 70
  tmp = memcmp((void const   *)(& empty), (void const   *)dp, sizeof(struct v2r0_disk_dqblk ));
  }
#line 70
  if (! tmp) {
#line 71
    m->dqb_itime = (time_t )0;
  }
#line 72
  return;
}
}
#line 77 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v2.c"
static void v2r0_mem2diskdqblk___4(void *dp , struct dquot *dquot ) 
{ 
  struct util_dqblk *m ;
  struct v2r0_disk_dqblk *d ;
  struct qtree_mem_dqinfo *info ;
  int tmp ;

  {
  {
#line 79
  m = & dquot->dq_dqb;
#line 80
  d = (struct v2r0_disk_dqblk *)dp;
#line 81
  info = & (dquot->dq_h)->qh_info.u.v2_mdqi.dqi_qtree;
#line 83
  d->dqb_ihardlimit = (__u32 )m->dqb_ihardlimit;
#line 84
  d->dqb_isoftlimit = (__u32 )m->dqb_isoftlimit;
#line 85
  d->dqb_bhardlimit = (__u32 )m->dqb_bhardlimit;
#line 86
  d->dqb_bsoftlimit = (__u32 )m->dqb_bsoftlimit;
#line 87
  d->dqb_curinodes = (__u32 )m->dqb_curinodes;
#line 88
  d->dqb_curspace = (u_int64_t )((__u64 )m->dqb_curspace);
#line 89
  d->dqb_itime = (u_int64_t )((__u64 )m->dqb_itime);
#line 90
  d->dqb_btime = (u_int64_t )((__u64 )m->dqb_btime);
#line 91
  d->dqb_id = dquot->dq_id;
#line 92
  tmp = qtree_entry_unused(info, (char *)dp);
  }
#line 92
  if (tmp) {
#line 93
    d->dqb_itime = (u_int64_t )((__u64 )1);
  }
#line 94
  return;
}
}
#line 96 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v2.c"
static int v2r0_is_id___4(void *dp , struct dquot *dquot ) 
{ 
  struct v2r0_disk_dqblk *d ;
  struct qtree_mem_dqinfo *info ;
  int tmp ;

  {
  {
#line 98
  d = (struct v2r0_disk_dqblk *)dp;
#line 99
  info = & (dquot->dq_h)->qh_info.u.v2_mdqi.dqi_qtree;
#line 101
  tmp = qtree_entry_unused(info, (char *)dp);
  }
#line 101
  if (tmp) {
#line 102
    return (0);
  }
#line 103
  return (d->dqb_id == dquot->dq_id);
}
}
#line 109 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v2.c"
static void v2r1_disk2memdqblk___4(struct dquot *dquot , void *dp ) 
{ 
  struct util_dqblk *m ;
  struct v2r1_disk_dqblk *d ;
  struct v2r1_disk_dqblk empty ;
  int tmp ;

  {
  {
#line 111
  m = & dquot->dq_dqb;
#line 112
  d = (struct v2r1_disk_dqblk *)dp;
#line 114
  dquot->dq_id = d->dqb_id;
#line 115
  m->dqb_ihardlimit = (qsize_t )((__le64 )d->dqb_ihardlimit);
#line 116
  m->dqb_isoftlimit = (qsize_t )((__le64 )d->dqb_isoftlimit);
#line 117
  m->dqb_bhardlimit = (qsize_t )((__le64 )d->dqb_bhardlimit);
#line 118
  m->dqb_bsoftlimit = (qsize_t )((__le64 )d->dqb_bsoftlimit);
#line 119
  m->dqb_curinodes = (qsize_t )((__le64 )d->dqb_curinodes);
#line 120
  m->dqb_curspace = (qsize_t )((__le64 )d->dqb_curspace);
#line 121
  m->dqb_itime = (time_t )((__le64 )d->dqb_itime);
#line 122
  m->dqb_btime = (time_t )((__le64 )d->dqb_btime);
#line 124
  memset((void *)(& empty), 0, sizeof(struct v2r1_disk_dqblk ));
#line 125
  empty.dqb_itime = (u_int64_t )((__u64 )1);
#line 126
  tmp = memcmp((void const   *)(& empty), (void const   *)dp, sizeof(struct v2r1_disk_dqblk ));
  }
#line 126
  if (! tmp) {
#line 127
    m->dqb_itime = (time_t )0;
  }
#line 128
  return;
}
}
#line 133 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v2.c"
static void v2r1_mem2diskdqblk___4(void *dp , struct dquot *dquot ) 
{ 
  struct util_dqblk *m ;
  struct v2r1_disk_dqblk *d ;
  int tmp ;

  {
  {
#line 135
  m = & dquot->dq_dqb;
#line 136
  d = (struct v2r1_disk_dqblk *)dp;
#line 138
  d->dqb_ihardlimit = (u_int64_t )((__u64 )m->dqb_ihardlimit);
#line 139
  d->dqb_isoftlimit = (u_int64_t )((__u64 )m->dqb_isoftlimit);
#line 140
  d->dqb_bhardlimit = (u_int64_t )((__u64 )m->dqb_bhardlimit);
#line 141
  d->dqb_bsoftlimit = (u_int64_t )((__u64 )m->dqb_bsoftlimit);
#line 142
  d->dqb_curinodes = (u_int64_t )((__u64 )m->dqb_curinodes);
#line 143
  d->dqb_curspace = (u_int64_t )((__u64 )m->dqb_curspace);
#line 144
  d->dqb_itime = (u_int64_t )((__u64 )m->dqb_itime);
#line 145
  d->dqb_btime = (u_int64_t )((__u64 )m->dqb_btime);
#line 146
  d->dqb_id = dquot->dq_id;
#line 147
  d->dqb_pad = (u_int32_t )0;
#line 148
  tmp = qtree_entry_unused(& (dquot->dq_h)->qh_info.u.v2_mdqi.dqi_qtree, (char *)dp);
  }
#line 148
  if (tmp) {
#line 149
    d->dqb_itime = (u_int64_t )((__u64 )1);
  }
#line 150
  return;
}
}
#line 152 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v2.c"
static int v2r1_is_id___4(void *dp , struct dquot *dquot ) 
{ 
  struct v2r1_disk_dqblk *d ;
  struct qtree_mem_dqinfo *info ;
  int tmp ;

  {
  {
#line 154
  d = (struct v2r1_disk_dqblk *)dp;
#line 155
  info = & (dquot->dq_h)->qh_info.u.v2_mdqi.dqi_qtree;
#line 157
  tmp = qtree_entry_unused(info, (char *)dp);
  }
#line 157
  if (tmp) {
#line 158
    return (0);
  }
#line 159
  return (d->dqb_id == dquot->dq_id);
}
}
#line 162 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v2.c"
static struct qtree_fmt_operations v2r0_fmt_ops___4  =    {& v2r0_mem2diskdqblk___4, & v2r0_disk2memdqblk___4, & v2r0_is_id___4};
#line 168 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v2.c"
static struct qtree_fmt_operations v2r1_fmt_ops___4  =    {& v2r1_mem2diskdqblk___4, & v2r1_disk2memdqblk___4, & v2r1_is_id___4};
#line 226 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v2.c"
static int v2_read_header___4(int fd , struct v2_disk_dqheader *h ) 
{ 
  ssize_t tmp ;

  {
  {
#line 228
  lseek(fd, (__off64_t )0, 0);
#line 229
  tmp = read(fd, (void *)h, sizeof(struct v2_disk_dqheader ));
  }
#line 229
  if ((unsigned long )tmp != sizeof(struct v2_disk_dqheader )) {
#line 230
    return (0);
  }
#line 231
  return (1);
}
}
#line 237 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v2.c"
static int v2_check_file___4(int fd , int type , int fmt___7 ) 
{ 
  struct v2_disk_dqheader h ;
  int file_magics[2] ;
  int known_versions___0[2] ;
  int version___0 ;
  int tmp ;
  char *tmp___0 ;
  __u32 tmp___1 ;

  {
  {
#line 240
  file_magics[0] = -641720559;
#line 240
  file_magics[1] = -641722073;
#line 241
  known_versions___0[0] = 1;
#line 241
  known_versions___0[1] = 1;
#line 244
  tmp = v2_read_header___4(fd, & h);
  }
#line 244
  if (! tmp) {
#line 245
    return (0);
  }
#line 246
  if (fmt___7 == 1) {
#line 247
    version___0 = 0;
  } else
#line 248
  if (fmt___7 == 2) {
#line 249
    version___0 = 1;
  } else {
#line 251
    return (0);
  }
#line 253
  if (h.dqh_magic != (__u32 )file_magics[type]) {
    {
#line 254
    tmp___1 = __fswab32(h.dqh_magic);
    }
#line 254
    if (tmp___1 == (__u32 )file_magics[type]) {
      {
#line 255
      tmp___0 = gettext("Your quota file is stored in wrong endianity. Please use convertquota(8) to convert it.\n");
#line 255
      die(3, tmp___0);
      }
    }
#line 256
    return (0);
  }
#line 258
  if (h.dqh_version > (__u32 )known_versions___0[type]) {
#line 259
    return (0);
  }
#line 260
  if ((__u32 )version___0 != h.dqh_version) {
#line 261
    return (0);
  }
#line 262
  return (1);
}
}
#line 268 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v2.c"
static int v2_init_io___4(struct quota_handle *h ) 
{ 
  int tmp ;
  struct v2_kern_dqinfo kdqinfo ;
  int *tmp___0 ;
  long tmp___1 ;
  struct v2_disk_dqinfo ddqinfo ;
  struct v2_disk_dqheader header ;
  int tmp___2 ;
  ssize_t tmp___3 ;

  {
#line 270
  if (h->qh_io_flags & 1) {
#line 271
    if (kernel_iface == 3) {
      {
#line 272
      tmp = vfs_get_info(h);
      }
#line 272
      if (tmp < 0) {
#line 273
        return (-1);
      }
    } else {
      {
#line 278
      tmp___1 = quotactl((2304 << 8) | (h->qh_type & 255), (char const   *)(h->qh_quotadev),
                         (qid_t )0, (caddr_t )((void *)(& kdqinfo)));
      }
#line 278
      if (tmp___1 < 0L) {
        {
#line 280
        tmp___0 = __errno_location();
        }
#line 280
        if (*tmp___0 == 1) {
#line 281
          return (0);
        }
#line 282
        return (-1);
      }
#line 284
      h->qh_info.dqi_bgrace = (time_t )kdqinfo.dqi_bgrace;
#line 285
      h->qh_info.dqi_igrace = (time_t )kdqinfo.dqi_igrace;
#line 286
      h->qh_info.u.v2_mdqi.dqi_flags = kdqinfo.dqi_flags;
#line 287
      h->qh_info.u.v2_mdqi.dqi_qtree.dqi_blocks = kdqinfo.dqi_blocks;
#line 288
      h->qh_info.u.v2_mdqi.dqi_qtree.dqi_free_blk = kdqinfo.dqi_free_blk;
#line 289
      h->qh_info.u.v2_mdqi.dqi_qtree.dqi_free_entry = kdqinfo.dqi_free_entry;
    }
  }
#line 292
  if (h->qh_fd != -1) {
    {
#line 296
    tmp___2 = v2_read_header___4(h->qh_fd, & header);
    }
#line 296
    if (! tmp___2) {
#line 297
      return (-1);
    }
    {
#line 299
    lseek(h->qh_fd, (__off64_t )sizeof(struct v2_disk_dqheader ), 0);
#line 300
    tmp___3 = read(h->qh_fd, (void *)(& ddqinfo), sizeof(ddqinfo));
    }
#line 300
    if ((unsigned long )tmp___3 != sizeof(ddqinfo)) {
#line 301
      return (-1);
    }
#line 303
    if (! (h->qh_io_flags & 1)) {
      {
#line 304
      v2_disk2memdqinfo(& h->qh_info, & ddqinfo);
      }
    } else {
#line 306
      h->qh_info.u.v2_mdqi.dqi_qtree.dqi_blocks = ddqinfo.dqi_blocks;
    }
#line 308
    if (header.dqh_version == 0U) {
#line 309
      h->qh_info.u.v2_mdqi.dqi_qtree.dqi_entry_size = (unsigned int )sizeof(struct v2r0_disk_dqblk );
#line 310
      h->qh_info.u.v2_mdqi.dqi_qtree.dqi_ops = & v2r0_fmt_ops___4;
#line 311
      h->qh_info.dqi_max_b_limit = (uint64_t )(~ ((uint32_t )0));
#line 312
      h->qh_info.dqi_max_i_limit = (uint64_t )(~ ((uint32_t )0));
#line 313
      h->qh_info.dqi_max_b_usage = ~ ((uint64_t )0);
#line 314
      h->qh_info.dqi_max_i_usage = (uint64_t )(~ ((uint32_t )0));
    } else {
#line 316
      h->qh_info.u.v2_mdqi.dqi_qtree.dqi_entry_size = (unsigned int )sizeof(struct v2r1_disk_dqblk );
#line 317
      h->qh_info.u.v2_mdqi.dqi_qtree.dqi_ops = & v2r1_fmt_ops___4;
#line 318
      h->qh_info.dqi_max_b_limit = ~ ((uint64_t )0);
#line 319
      h->qh_info.dqi_max_i_limit = ~ ((uint64_t )0);
#line 320
      h->qh_info.dqi_max_b_usage = ~ ((uint64_t )0);
#line 321
      h->qh_info.dqi_max_i_usage = ~ ((uint64_t )0);
    }
  } else {
#line 325
    h->qh_info.u.v2_mdqi.dqi_qtree.dqi_ops = (struct qtree_fmt_operations *)((void *)0);
  }
#line 327
  return (0);
}
}
#line 333 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v2.c"
static int v2_new_io___4(struct quota_handle *h ) 
{ 
  int file_magics[2] ;
  struct v2_disk_dqheader ddqheader ;
  struct v2_disk_dqinfo ddqinfo ;
  int version___0 ;
  ssize_t tmp ;
  ssize_t tmp___0 ;

  {
#line 335
  file_magics[0] = -641720559;
#line 335
  file_magics[1] = -641722073;
#line 340
  if (h->qh_fmt == 1) {
#line 341
    version___0 = 0;
  } else
#line 342
  if (h->qh_fmt == 2) {
#line 343
    version___0 = 1;
  } else {
#line 345
    return (-1);
  }
  {
#line 348
  ddqheader.dqh_magic = (__u32 )file_magics[h->qh_type];
#line 349
  ddqheader.dqh_version = (__u32 )version___0;
#line 350
  lseek(h->qh_fd, (__off64_t )0, 0);
#line 351
  tmp = write(h->qh_fd, (void const   *)(& ddqheader), sizeof(ddqheader));
  }
#line 351
  if ((unsigned long )tmp != sizeof(ddqheader)) {
#line 352
    return (-1);
  }
#line 354
  h->qh_info.dqi_bgrace = (time_t )604800;
#line 355
  h->qh_info.dqi_igrace = (time_t )604800;
#line 356
  h->qh_info.u.v2_mdqi.dqi_flags = (uint )0;
#line 357
  h->qh_info.u.v2_mdqi.dqi_qtree.dqi_blocks = 2U;
#line 358
  h->qh_info.u.v2_mdqi.dqi_qtree.dqi_free_blk = 0U;
#line 359
  h->qh_info.u.v2_mdqi.dqi_qtree.dqi_free_entry = 0U;
#line 360
  if (version___0 == 0) {
#line 361
    h->qh_info.u.v2_mdqi.dqi_qtree.dqi_entry_size = (unsigned int )sizeof(struct v2r0_disk_dqblk );
#line 362
    h->qh_info.u.v2_mdqi.dqi_qtree.dqi_ops = & v2r0_fmt_ops___4;
#line 363
    h->qh_info.dqi_max_b_limit = (uint64_t )(~ ((uint32_t )0));
#line 364
    h->qh_info.dqi_max_i_limit = (uint64_t )(~ ((uint32_t )0));
#line 365
    h->qh_info.dqi_max_b_usage = ~ ((uint64_t )0);
#line 366
    h->qh_info.dqi_max_i_usage = (uint64_t )(~ ((uint32_t )0));
  } else
#line 367
  if (version___0 == 1) {
#line 368
    h->qh_info.u.v2_mdqi.dqi_qtree.dqi_entry_size = (unsigned int )sizeof(struct v2r1_disk_dqblk );
#line 369
    h->qh_info.u.v2_mdqi.dqi_qtree.dqi_ops = & v2r1_fmt_ops___4;
#line 370
    h->qh_info.dqi_max_b_limit = ~ ((uint64_t )0);
#line 371
    h->qh_info.dqi_max_i_limit = ~ ((uint64_t )0);
#line 372
    h->qh_info.dqi_max_b_usage = ~ ((uint64_t )0);
#line 373
    h->qh_info.dqi_max_i_usage = ~ ((uint64_t )0);
  }
  {
#line 375
  v2_mem2diskdqinfo(& ddqinfo, & h->qh_info);
#line 376
  lseek(h->qh_fd, (__off64_t )sizeof(struct v2_disk_dqheader ), 0);
#line 377
  tmp___0 = write(h->qh_fd, (void const   *)(& ddqinfo), sizeof(ddqinfo));
  }
#line 377
  if ((unsigned long )tmp___0 != sizeof(ddqinfo)) {
#line 378
    return (-1);
  }
#line 379
  return (0);
}
}
#line 385 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v2.c"
static int v2_write_info___4(struct quota_handle *h ) 
{ 
  char *tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  struct v2_kern_dqinfo kdqinfo ;
  long tmp___2 ;
  long tmp___3 ;
  struct v2_disk_dqinfo ddqinfo ;
  ssize_t tmp___4 ;

  {
#line 387
  if (h->qh_io_flags & 4) {
    {
#line 388
    tmp = gettext("Trying to write info to readonly quotafile on %s\n");
#line 388
    errstr(tmp, h->qh_quotadev);
#line 389
    tmp___0 = __errno_location();
#line 389
    *tmp___0 = 1;
    }
#line 390
    return (-1);
  }
#line 392
  if (h->qh_io_flags & 1) {
#line 393
    if (kernel_iface == 3) {
      {
#line 394
      tmp___1 = vfs_set_info(h, 3);
      }
#line 394
      if (tmp___1) {
#line 395
        return (-1);
      }
    } else {
      {
#line 400
      kdqinfo.dqi_bgrace = (unsigned int )h->qh_info.dqi_bgrace;
#line 401
      kdqinfo.dqi_igrace = (unsigned int )h->qh_info.dqi_igrace;
#line 402
      kdqinfo.dqi_flags = h->qh_info.u.v2_mdqi.dqi_flags;
#line 403
      kdqinfo.dqi_blocks = h->qh_info.u.v2_mdqi.dqi_qtree.dqi_blocks;
#line 404
      kdqinfo.dqi_free_blk = h->qh_info.u.v2_mdqi.dqi_qtree.dqi_free_blk;
#line 405
      kdqinfo.dqi_free_entry = h->qh_info.u.v2_mdqi.dqi_qtree.dqi_free_entry;
#line 406
      tmp___2 = quotactl((2816 << 8) | (h->qh_type & 255), (char const   *)(h->qh_quotadev),
                         (qid_t )0, (caddr_t )((void *)(& kdqinfo)));
      }
#line 406
      if (tmp___2 < 0L) {
#line 408
        return (-1);
      } else {
        {
#line 406
        tmp___3 = quotactl((3072 << 8) | (h->qh_type & 255), (char const   *)(h->qh_quotadev),
                           (qid_t )0, (caddr_t )((void *)(& kdqinfo)));
        }
#line 406
        if (tmp___3 < 0L) {
#line 408
          return (-1);
        }
      }
    }
  } else {
    {
#line 414
    v2_mem2diskdqinfo(& ddqinfo, & h->qh_info);
#line 415
    lseek(h->qh_fd, (__off64_t )sizeof(struct v2_disk_dqheader ), 0);
#line 416
    tmp___4 = write(h->qh_fd, (void const   *)(& ddqinfo), sizeof(ddqinfo));
    }
#line 416
    if ((unsigned long )tmp___4 != sizeof(ddqinfo)) {
#line 417
      return (-1);
    }
  }
#line 419
  return (0);
}
}
#line 426 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v2.c"
static struct dquot *v2_read_dquot___4(struct quota_handle *h , qid_t id___0 ) 
{ 
  struct dquot *dquot ;
  struct dquot *tmp ;
  int tmp___0 ;
  struct v2_kern_dqblk kdqblk ;
  long tmp___1 ;
  struct dquot *tmp___2 ;

  {
#line 428
  if (h->qh_io_flags & 1) {
    {
#line 429
    tmp = get_empty_dquot();
#line 429
    dquot = tmp;
#line 431
    dquot->dq_id = id___0;
#line 432
    dquot->dq_h = h;
#line 433
    dquot->dq_dqb.u.v2_mdqb.dqb_off = (loff_t )0;
#line 434
    memset((void *)(& dquot->dq_dqb), 0, sizeof(struct util_dqblk ));
    }
#line 435
    if (kernel_iface == 3) {
      {
#line 436
      tmp___0 = vfs_get_dquot(dquot);
      }
#line 436
      if (tmp___0 < 0) {
        {
#line 437
        free((void *)dquot);
        }
#line 438
        return ((struct dquot *)((void *)0));
      }
    } else {
      {
#line 444
      tmp___1 = quotactl((3328 << 8) | (h->qh_type & 255), (char const   *)(h->qh_quotadev),
                         id___0, (caddr_t )((void *)(& kdqblk)));
      }
#line 444
      if (tmp___1 < 0L) {
        {
#line 445
        free((void *)dquot);
        }
#line 446
        return ((struct dquot *)((void *)0));
      }
      {
#line 448
      v2_kern2utildqblk(& dquot->dq_dqb, & kdqblk);
      }
    }
#line 450
    return (dquot);
  }
  {
#line 452
  tmp___2 = qtree_read_dquot(h, id___0);
  }
#line 452
  return (tmp___2);
}
}
#line 459 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v2.c"
static int v2_commit_dquot___4(struct dquot *dquot , int flags___7 ) 
{ 
  struct util_dqblk *b ;
  char *tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  struct v2_kern_dqblk kdqblk ;
  int cmd ;
  int *tmp___2 ;
  long tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;

  {
#line 461
  b = & dquot->dq_dqb;
#line 463
  if ((dquot->dq_h)->qh_io_flags & 4) {
    {
#line 464
    tmp = gettext("Trying to write quota to readonly quotafile on %s\n");
#line 464
    errstr(tmp, (dquot->dq_h)->qh_quotadev);
#line 465
    tmp___0 = __errno_location();
#line 465
    *tmp___0 = 1;
    }
#line 466
    return (-1);
  }
#line 468
  if ((dquot->dq_h)->qh_io_flags & 1) {
#line 469
    if (kernel_iface == 3) {
      {
#line 470
      tmp___1 = vfs_set_dquot(dquot, flags___7);
      }
#line 470
      if (tmp___1 < 0) {
#line 471
        return (-1);
      }
    } else {
#line 477
      if (flags___7 == 10) {
#line 478
        cmd = 3840;
      } else
#line 479
      if (flags___7 == 5) {
#line 480
        cmd = 1792;
      } else
#line 481
      if (flags___7 & 48) {
        {
#line 482
        tmp___2 = __errno_location();
#line 482
        *tmp___2 = 22;
        }
#line 483
        return (-1);
      } else {
#line 486
        cmd = 3584;
      }
      {
#line 487
      v2_util2kerndqblk(& kdqblk, & dquot->dq_dqb);
#line 488
      tmp___3 = quotactl((cmd << 8) | ((dquot->dq_h)->qh_type & 255), (char const   *)((dquot->dq_h)->qh_quotadev),
                         dquot->dq_id, (caddr_t )((void *)(& kdqblk)));
      }
#line 488
      if (tmp___3 < 0L) {
#line 490
        return (-1);
      }
    }
#line 492
    return (0);
  }
#line 494
  if (! b->dqb_curspace) {
#line 494
    if (! b->dqb_curinodes) {
#line 494
      if (! b->dqb_bsoftlimit) {
#line 494
        if (! b->dqb_isoftlimit) {
#line 494
          if (! b->dqb_bhardlimit) {
#line 494
            if (! b->dqb_ihardlimit) {
              {
#line 496
              qtree_delete_dquot(dquot);
              }
            } else {
#line 494
              goto _L___3;
            }
          } else {
#line 494
            goto _L___3;
          }
        } else {
#line 494
          goto _L___3;
        }
      } else {
#line 494
        goto _L___3;
      }
    } else {
#line 494
      goto _L___3;
    }
  } else {
    _L___3: /* CIL Label */ 
    {
#line 498
    tmp___5 = check_dquot_range(dquot);
    }
#line 498
    if (tmp___5 < 0) {
      {
#line 499
      tmp___4 = __errno_location();
#line 499
      *tmp___4 = 34;
      }
#line 500
      return (-1);
    }
    {
#line 502
    qtree_write_dquot(dquot);
    }
  }
#line 504
  return (0);
}
}
#line 507 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v2.c"
static int v2_scan_dquots___4(struct quota_handle *h , int (*process_dquot)(struct dquot *dquot ,
                                                                            char *dqname ) ) 
{ 
  int tmp ;

  {
  {
#line 509
  tmp = qtree_scan_dquots(h, process_dquot);
  }
#line 509
  return (tmp);
}
}
#line 513 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v2.c"
static int v2_report___4(struct quota_handle *h , int verbose ) 
{ 
  struct v2_mem_dqinfo *info ;
  char *tmp ;

  {
#line 515
  if (verbose) {
    {
#line 516
    info = & h->qh_info.u.v2_mdqi;
#line 518
    tmp = gettext("Statistics:\nTotal blocks: %u\nData blocks: %u\nEntries: %u\nUsed average: %f\n");
#line 518
    printf((char const   */* __restrict  */)tmp, info->dqi_qtree.dqi_blocks, info->dqi_data_blocks,
           info->dqi_used_entries, (double )((float )info->dqi_used_entries / (float )info->dqi_data_blocks));
    }
  }
#line 522
  return (0);
}
}
#line 31 "/home/wheatley/newnew/temp/quota-4.01/bylabel.c"
static struct uuidCache_s *uuidCache___4  =    (struct uuidCache_s *)((void *)0);
#line 74 "/home/wheatley/newnew/temp/quota-4.01/bylabel.c"
static int get_label_uuid___4(char const   *device , char **label , char *uuid ) 
{ 
  int fd ;
  int rv ;
  size_t namesize ;
  struct ext2_super_block e2sb ;
  struct xfs_super_block xfsb ;
  struct reiserfs_super_block reisersb ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  __off64_t tmp___2 ;
  ssize_t tmp___3 ;
  int tmp___4 ;
  __off64_t tmp___5 ;
  ssize_t tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  __off64_t tmp___9 ;
  ssize_t tmp___10 ;

  {
  {
#line 79
  rv = 1;
#line 85
  fd = open(device, 0);
  }
#line 86
  if (fd < 0) {
#line 87
    return (rv);
  }
  {
#line 89
  tmp___9 = lseek(fd, (__off64_t )1024, 0);
  }
#line 89
  if (tmp___9 == 1024L) {
    {
#line 89
    tmp___10 = read(fd, (void *)((char *)(& e2sb)), sizeof(e2sb));
    }
#line 89
    if ((unsigned long )tmp___10 == sizeof(e2sb)) {
#line 89
      if ((uint )e2sb.s_magic[0] + ((uint )e2sb.s_magic[1] << 8) == 61267U) {
        {
#line 92
        memcpy((void */* __restrict  */)uuid, (void const   */* __restrict  */)(e2sb.s_uuid),
               sizeof(e2sb.s_uuid));
#line 93
        namesize = sizeof(e2sb.s_volume_name);
#line 94
        tmp = smalloc(namesize + 1UL);
#line 94
        *label = (char *)tmp;
#line 95
        sstrncpy(*label, (char const   *)((char *)(e2sb.s_volume_name)), namesize);
#line 96
        rv = 0;
        }
      } else {
#line 89
        goto _L___3;
      }
    } else {
#line 89
      goto _L___3;
    }
  } else {
    _L___3: /* CIL Label */ 
    {
#line 98
    tmp___5 = lseek(fd, (__off64_t )0, 0);
    }
#line 98
    if (tmp___5 == 0L) {
      {
#line 98
      tmp___6 = read(fd, (void *)((char *)(& xfsb)), sizeof(xfsb));
      }
#line 98
      if ((unsigned long )tmp___6 == sizeof(xfsb)) {
        {
#line 98
        tmp___7 = strncmp((char const   *)((char *)(& xfsb.s_magic)), "XFSB", (size_t )4);
        }
#line 98
        if (tmp___7 == 0) {
#line 98
          goto _L___0;
        } else {
          {
#line 98
          tmp___8 = strncmp((char const   *)((char *)(& xfsb.s_magic)), "BSFX", (size_t )4);
          }
#line 98
          if (tmp___8 == 0) {
            _L___0: /* CIL Label */ 
            {
#line 102
            memcpy((void */* __restrict  */)uuid, (void const   */* __restrict  */)(xfsb.s_uuid),
                   sizeof(xfsb.s_uuid));
#line 103
            namesize = sizeof(xfsb.s_fsname);
#line 104
            tmp___0 = smalloc(namesize + 1UL);
#line 104
            *label = (char *)tmp___0;
#line 105
            sstrncpy(*label, (char const   *)((char *)(xfsb.s_fsname)), namesize);
#line 106
            rv = 0;
            }
          } else {
#line 98
            goto _L___1;
          }
        }
      } else {
#line 98
        goto _L___1;
      }
    } else {
      _L___1: /* CIL Label */ 
      {
#line 108
      tmp___2 = lseek(fd, (__off64_t )65536, 0);
      }
#line 108
      if (tmp___2 == 65536L) {
        {
#line 108
        tmp___3 = read(fd, (void *)((char *)(& reisersb)), sizeof(reisersb));
        }
#line 108
        if ((unsigned long )tmp___3 == sizeof(reisersb)) {
          {
#line 108
          tmp___4 = strncmp((char const   *)((char *)(& reisersb.s_magic)), "ReIsEr2Fs",
                            (size_t )9);
          }
#line 108
          if (! tmp___4) {
            {
#line 111
            memcpy((void */* __restrict  */)uuid, (void const   */* __restrict  */)(reisersb.s_uuid),
                   sizeof(reisersb.s_uuid));
#line 112
            namesize = sizeof(reisersb.s_volume_name);
#line 113
            tmp___1 = smalloc(namesize + 1UL);
#line 113
            *label = (char *)tmp___1;
#line 114
            sstrncpy(*label, (char const   *)((char *)(reisersb.s_volume_name)), namesize);
#line 115
            rv = 0;
            }
          }
        }
      }
    }
  }
  {
#line 117
  close(fd);
  }
#line 118
  return (rv);
}
}
#line 121 "/home/wheatley/newnew/temp/quota-4.01/bylabel.c"
static void uuidcache_addentry___4(char *device , char *label , char *uuid ) 
{ 
  struct uuidCache_s *last ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 125
  if (! uuidCache___4) {
    {
#line 126
    tmp = smalloc(sizeof(*uuidCache___4));
#line 126
    uuidCache___4 = (struct uuidCache_s *)tmp;
#line 126
    last = uuidCache___4;
    }
  } else {
#line 129
    last = uuidCache___4;
    {
#line 129
    while (1) {
      while_continue: /* CIL Label */ ;
#line 129
      if (! last->next) {
#line 129
        goto while_break;
      }
#line 129
      last = last->next;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 130
    tmp___0 = smalloc(sizeof(*uuidCache___4));
#line 130
    last->next = (struct uuidCache_s *)tmp___0;
#line 131
    last = last->next;
    }
  }
  {
#line 133
  last->next = (struct uuidCache_s *)((void *)0);
#line 134
  last->device = device;
#line 135
  last->label = label;
#line 136
  memcpy((void */* __restrict  */)(last->uuid), (void const   */* __restrict  */)uuid,
         sizeof(last->uuid));
  }
#line 137
  return;
}
}
#line 144 "/home/wheatley/newnew/temp/quota-4.01/bylabel.c"
static char ptname___4[100]  ;
#line 139 "/home/wheatley/newnew/temp/quota-4.01/bylabel.c"
static void uuidcache_init___4(void) 
{ 
  char line___0[100] ;
  char *s ;
  int ma ;
  int mi ;
  int sz ;
  FILE *procpt ;
  char uuid[16] ;
  char *label ;
  char device[110] ;
  int firstPass ;
  int handleOnFirst ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  unsigned short const   **tmp___4 ;
  char *tmp___5 ;

  {
#line 151
  if (uuidCache___4) {
#line 152
    return;
  }
  {
#line 154
  procpt = fopen((char const   */* __restrict  */)"/proc/partitions", (char const   */* __restrict  */)"r");
  }
#line 155
  if (! procpt) {
#line 156
    return;
  }
#line 158
  firstPass = 1;
  {
#line 158
  while (1) {
    while_continue: /* CIL Label */ ;
#line 158
    if (! (firstPass >= 0)) {
#line 158
      goto while_break;
    }
    {
#line 159
    fseek(procpt, 0L, 0);
    }
    {
#line 161
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 161
      tmp___5 = fgets((char */* __restrict  */)(line___0), (int )sizeof(line___0),
                      (FILE */* __restrict  */)procpt);
      }
#line 161
      if (! tmp___5) {
#line 161
        goto while_break___0;
      }
      {
#line 162
      tmp = sscanf((char const   */* __restrict  */)(line___0), (char const   */* __restrict  */)" %d %d %d %[^\n ]",
                   & ma, & mi, & sz, ptname___4);
      }
#line 162
      if (tmp != 4) {
#line 163
        goto while_continue___0;
      }
#line 166
      if (sz == 1) {
#line 167
        goto while_continue___0;
      }
      {
#line 170
      tmp___0 = strncmp((char const   *)(ptname___4), "md", (size_t )2);
      }
#line 170
      if (tmp___0) {
#line 170
        tmp___1 = 0;
      } else {
#line 170
        tmp___1 = 1;
      }
#line 170
      handleOnFirst = tmp___1;
#line 171
      if (firstPass != handleOnFirst) {
#line 172
        goto while_continue___0;
      }
#line 178
      s = ptname___4;
      {
#line 178
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 178
        if (! *s) {
#line 178
          goto while_break___1;
        }
#line 178
        s ++;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 179
      tmp___4 = __ctype_b_loc();
      }
#line 179
      if ((int const   )*(*tmp___4 + (int )*(s + -1)) & 2048) {
        {
#line 189
        snprintf((char */* __restrict  */)(device), sizeof(device), (char const   */* __restrict  */)"%s/%s",
                 "/dev", ptname___4);
#line 190
        tmp___3 = get_label_uuid___4((char const   *)(device), & label, uuid);
        }
#line 190
        if (! tmp___3) {
          {
#line 191
          tmp___2 = sstrdup((char const   *)(device));
#line 191
          uuidcache_addentry___4(tmp___2, label, uuid);
          }
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 158
    firstPass --;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 196
  fclose(procpt);
  }
#line 197
  return;
}
}
#line 202 "/home/wheatley/newnew/temp/quota-4.01/bylabel.c"
static char *get_spec_by_x___4(int n , char const   *t ) 
{ 
  struct uuidCache_s *uc ;
  char *tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 206
  uuidcache_init___4();
#line 207
  uc = uuidCache___4;
  }
  {
#line 209
  while (1) {
    while_continue: /* CIL Label */ ;
#line 209
    if (! uc) {
#line 209
      goto while_break;
    }
    {
#line 211
    if (n == 1) {
#line 211
      goto case_1;
    }
#line 215
    if (n == 2) {
#line 215
      goto case_2;
    }
#line 210
    goto switch_break;
    case_1: /* CIL Label */ 
    {
#line 212
    tmp___0 = memcmp((void const   *)t, (void const   *)(uc->uuid), sizeof(uc->uuid));
    }
#line 212
    if (! tmp___0) {
      {
#line 213
      tmp = sstrdup((char const   *)uc->device);
      }
#line 213
      return (tmp);
    }
#line 214
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 216
    tmp___2 = strcmp(t, (char const   *)uc->label);
    }
#line 216
    if (! tmp___2) {
      {
#line 217
      tmp___1 = sstrdup((char const   *)uc->device);
      }
#line 217
      return (tmp___1);
    }
#line 218
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 220
    uc = uc->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 222
  return ((char *)((void *)0));
}
}
#line 225 "/home/wheatley/newnew/temp/quota-4.01/bylabel.c"
static u_char fromhex___4(char c ) 
{ 
  unsigned short const   **tmp ;
  unsigned short const   **tmp___0 ;

  {
  {
#line 227
  tmp___0 = __ctype_b_loc();
  }
#line 227
  if ((int const   )*(*tmp___0 + (int )c) & 2048) {
#line 228
    return ((u_char )((int )c - 48));
  } else {
    {
#line 229
    tmp = __ctype_b_loc();
    }
#line 229
    if ((int const   )*(*tmp + (int )c) & 512) {
#line 230
      return ((u_char )(((int )c - 97) + 10));
    } else {
#line 232
      return ((u_char )(((int )c - 65) + 10));
    }
  }
}
}
#line 235 "/home/wheatley/newnew/temp/quota-4.01/bylabel.c"
static char *get_spec_by_uuid___4(char const   *s ) 
{ 
  u_char uuid[16] ;
  int i ;
  size_t tmp ;
  unsigned short const   **tmp___0 ;
  unsigned short const   **tmp___1 ;
  u_char tmp___2 ;
  u_char tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;

  {
  {
#line 240
  tmp = strlen(s);
  }
#line 240
  if (tmp != 36UL) {
#line 241
    goto bad_uuid;
  } else
#line 240
  if ((int const   )*(s + 8) != 45) {
#line 241
    goto bad_uuid;
  } else
#line 240
  if ((int const   )*(s + 13) != 45) {
#line 241
    goto bad_uuid;
  } else
#line 240
  if ((int const   )*(s + 18) != 45) {
#line 241
    goto bad_uuid;
  } else
#line 240
  if ((int const   )*(s + 23) != 45) {
#line 241
    goto bad_uuid;
  }
#line 242
  i = 0;
  {
#line 242
  while (1) {
    while_continue: /* CIL Label */ ;
#line 242
    if (! (i < 16)) {
#line 242
      goto while_break;
    }
#line 243
    if ((int const   )*s == 45) {
#line 244
      s ++;
    }
    {
#line 245
    tmp___0 = __ctype_b_loc();
    }
#line 245
    if ((int const   )*(*tmp___0 + (int )*(s + 0)) & 4096) {
      {
#line 245
      tmp___1 = __ctype_b_loc();
      }
#line 245
      if (! ((int const   )*(*tmp___1 + (int )*(s + 1)) & 4096)) {
#line 246
        goto bad_uuid;
      }
    } else {
#line 246
      goto bad_uuid;
    }
    {
#line 247
    tmp___2 = fromhex___4((char )*(s + 0));
#line 247
    tmp___3 = fromhex___4((char )*(s + 1));
#line 247
    uuid[i] = (u_char )(((int )tmp___2 << 4) | (int )tmp___3);
#line 248
    s += 2;
#line 242
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 250
  tmp___4 = get_spec_by_x___4(1, (char const   *)((char *)(uuid)));
  }
#line 250
  return (tmp___4);
  bad_uuid: 
  {
#line 253
  tmp___5 = gettext("Found an invalid UUID: %s\n");
#line 253
  errstr(tmp___5, s);
  }
#line 254
  return ((char *)((void *)0));
}
}
#line 257 "/home/wheatley/newnew/temp/quota-4.01/bylabel.c"
static char *get_spec_by_volume_label___4(char const   *s ) 
{ 
  char *tmp ;

  {
  {
#line 259
  tmp = get_spec_by_x___4(2, s);
  }
#line 259
  return (tmp);
}
}
#line 105 "/home/wheatley/newnew/temp/quota-4.01/quotaio_generic.c"
static int scan_one_dquot___4(struct dquot *dquot , int (*get_dquot)(struct dquot * ) ) 
{ 
  int ret ;
  struct util_dqblk *dqb ;

  {
  {
#line 108
  dqb = & dquot->dq_dqb;
#line 110
  memset((void *)dqb, 0, sizeof(struct util_dqblk ));
#line 111
  ret = (*get_dquot)(dquot);
  }
#line 112
  if (ret < 0) {
#line 113
    return (ret);
  }
#line 114
  if (! dqb->dqb_bhardlimit) {
#line 114
    if (! dqb->dqb_bsoftlimit) {
#line 114
      if (! dqb->dqb_ihardlimit) {
#line 114
        if (! dqb->dqb_isoftlimit) {
#line 114
          if (! dqb->dqb_curinodes) {
#line 114
            if (! dqb->dqb_curspace) {
#line 115
              return (1);
            }
          }
        }
      }
    }
  }
#line 116
  return (0);
}
}
#line 79 "/home/wheatley/newnew/temp/quota-4.01/quota.c"
static int flags___3  ;
#line 79 "/home/wheatley/newnew/temp/quota-4.01/quota.c"
static int fmt___3  =    -1;
#line 82 "/home/wheatley/newnew/temp/quota-4.01/quota.c"
static void usage___3(void) 
{ 
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;

  {
  {
#line 84
  tmp = gettext("\n-u, --user                display quota for user\n-g, --group               display quota for group\n-q, --quiet               print more terse message\n-v, --verbose             print more verbose message\n-s, --human-readable      display numbers in human friendly units (MB, GB...)\n    --always-resolve      always try to translate name to id, even if it is\n\t\t\t  composed of only digits\n-w, --no-wrap             do not wrap long lines\n-p, --raw-grace           print grace time in seconds since epoch\n-l, --local-only          do not query NFS filesystems\n-Q, --quiet-refuse        do not print error message when NFS server does\n                          not respond\n-i, --no-autofs           do not query autofs mountpoints\n-F, --format=formatname   display quota of a specific format\n-f, --filesystem-list     display quota information only for given filesystems\n-A, --nfs-all             display quota for all NFS mountpoints\n-m, --no-mixed-pathnames  trim leading slashes from NFSv4 mountpoints\n    --show-mntpoint       show mount point of the file system in output\n    --hide-device         do not show file system device in output\n-h, --help                display this help message and exit\n-V, --version             display version information and exit\n\n");
#line 84
  tmp___0 = gettext("\tquota [-qvswugQm] [-F quotaformat] -f filesystem ...\n");
#line 84
  tmp___1 = gettext("\tquota [-qvswim] [-l | [-Q | -A]] [-F quotaformat] -g groupname ...\n");
#line 84
  tmp___2 = gettext("\tquota [-qvswim] [-l | [-Q | -A]] [-F quotaformat] -u username ...\n");
#line 84
  tmp___3 = gettext("Usage: quota [-guqvswim] [-l | [-Q | -A]] [-F quotaformat]\n");
#line 84
  errstr((char *)"%s%s%s%s%s", tmp___3, tmp___2, tmp___1, tmp___0, tmp);
#line 111
  tmp___4 = gettext("Bugs to: %s\n");
#line 111
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___4,
          "jack@suse.cz");
#line 112
  exit(1);
  }
}
}
#line 115 "/home/wheatley/newnew/temp/quota-4.01/quota.c"
static void heading(int type , qid_t id___0 , char *name , char *tag ) 
{ 
  char *spacehdr ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;

  {
#line 119
  if (flags___3 & 16) {
    {
#line 120
    spacehdr = gettext("space");
    }
  } else {
    {
#line 122
    spacehdr = gettext("blocks");
    }
  }
  {
#line 124
  tmp = type2name(type);
#line 124
  tmp___0 = type2name(type);
#line 124
  tmp___1 = gettext((char const   *)tmp___0);
#line 124
  tmp___2 = gettext("Disk quotas for %s %s (%cid %u): %s\n");
#line 124
  printf((char const   */* __restrict  */)tmp___2, tmp___1, name, (int )*tmp, id___0,
         tag);
  }
#line 126
  if (! (flags___3 & 1)) {
#line 126
    if (! *(tag + 0)) {
      {
#line 127
      tmp___3 = gettext("grace");
#line 127
      tmp___4 = gettext("limit");
#line 127
      tmp___5 = gettext("quota");
#line 127
      tmp___6 = gettext("files");
#line 127
      tmp___7 = gettext("grace");
#line 127
      tmp___8 = gettext("limit");
#line 127
      tmp___9 = gettext("quota");
#line 127
      tmp___10 = gettext("Filesystem");
#line 127
      printf((char const   */* __restrict  */)"%15s%8s %7s%8s%8s%8s %7s%8s%8s\n",
             tmp___10, spacehdr, tmp___9, tmp___8, tmp___7, tmp___6, tmp___5, tmp___4,
             tmp___3);
      }
    }
  }
#line 131
  return;
}
}
#line 133 "/home/wheatley/newnew/temp/quota-4.01/quota.c"
static void print_fs_location(struct dquot *q ) 
{ 
  struct quota_handle *h ;
  int wrap ;
  size_t tmp ;
  size_t tmp___0 ;

  {
#line 135
  h = q->dq_h;
#line 137
  if (flags___3 & 1) {
#line 138
    if (flags___3 & 32768) {
      {
#line 139
      printf((char const   */* __restrict  */)" %s", h->qh_quotadev);
      }
    }
#line 140
    if (flags___3 & 16384) {
      {
#line 141
      printf((char const   */* __restrict  */)" %s", h->qh_dir);
      }
    }
    {
#line 142
    putchar('\n');
    }
  } else {
#line 144
    wrap = 0;
#line 146
    if (flags___3 & 32768) {
#line 146
      if (flags___3 & 16384) {
#line 146
        if (! (flags___3 & 256)) {
#line 148
          wrap = 1;
        } else {
#line 146
          goto _L___2;
        }
      } else {
#line 146
        goto _L___2;
      }
    } else
    _L___2: /* CIL Label */ 
#line 149
    if (flags___3 & 32768) {
      {
#line 149
      tmp___0 = strlen((char const   *)(h->qh_quotadev));
      }
#line 149
      if (tmp___0 > 15UL) {
#line 149
        if (! (flags___3 & 256)) {
#line 151
          wrap = 1;
        } else {
#line 149
          goto _L___0;
        }
      } else {
#line 149
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 152
    if (flags___3 & 16384) {
      {
#line 152
      tmp = strlen((char const   *)(h->qh_dir));
      }
#line 152
      if (tmp > 15UL) {
#line 152
        if (! (flags___3 & 256)) {
#line 154
          wrap = 1;
        }
      }
    }
#line 156
    if (flags___3 & 32768) {
#line 157
      if (wrap) {
        {
#line 158
        printf((char const   */* __restrict  */)"%s", h->qh_quotadev);
        }
      } else
#line 157
      if (flags___3 & 16384) {
        {
#line 158
        printf((char const   */* __restrict  */)"%s", h->qh_quotadev);
        }
      } else {
        {
#line 160
        printf((char const   */* __restrict  */)"%15s", h->qh_quotadev);
        }
      }
    }
#line 162
    if (flags___3 & 16384) {
#line 163
      if (flags___3 & 32768) {
        {
#line 164
        putchar(' ');
        }
      }
#line 165
      if (wrap) {
        {
#line 166
        printf((char const   */* __restrict  */)"%s", h->qh_dir);
        }
      } else
#line 165
      if (flags___3 & 32768) {
        {
#line 166
        printf((char const   */* __restrict  */)"%s", h->qh_dir);
        }
      } else {
        {
#line 168
        printf((char const   */* __restrict  */)"%15s", h->qh_dir);
        }
      }
    }
#line 170
    if (wrap) {
      {
#line 171
      printf((char const   */* __restrict  */)"\n%15s", "");
      }
    }
  }
#line 173
  return;
}
}
#line 175 "/home/wheatley/newnew/temp/quota-4.01/quota.c"
static int showquotas(int type , qid_t id___0 , int mntcnt___3 , char **mnt___2 ) 
{ 
  struct dquot *qlist ;
  struct dquot *q ;
  char *msgi ;
  char *msgb ;
  char timebuf[40] ;
  char name[64] ;
  struct quota_handle **handles ;
  int lines ;
  int bover ;
  int iover ;
  int over ;
  time_t now___0 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char numbuf[3][32] ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;

  {
  {
#line 182
  lines = 0;
#line 185
  time(& now___0);
#line 186
  id2name((int )id___0, type, name);
  }
#line 187
  if (flags___3 & 128) {
#line 187
    tmp = 2;
  } else {
#line 187
    tmp = 0;
  }
#line 187
  if (flags___3 & 32) {
#line 187
    tmp___0 = 8;
  } else {
#line 187
    tmp___0 = 0;
  }
#line 187
  if (flags___3 & 2048) {
#line 187
    tmp___1 = 32;
  } else {
#line 187
    tmp___1 = 0;
  }
#line 187
  if (flags___3 & 8192) {
#line 187
    tmp___2 = 0;
  } else {
#line 187
    tmp___2 = 4;
  }
  {
#line 187
  handles = create_handle_list(mntcnt___3, mnt___2, type, fmt___3, 1 | tmp___2, (tmp | tmp___0) | tmp___1);
#line 192
  qlist = getprivs(id___0, handles, ! (! (flags___3 & 64)));
#line 193
  over = 0;
#line 194
  q = qlist;
  }
  {
#line 194
  while (1) {
    while_continue: /* CIL Label */ ;
#line 194
    if (! q) {
#line 194
      goto while_break;
    }
#line 195
    iover = 0;
#line 195
    bover = iover;
#line 196
    if (! (flags___3 & 2)) {
#line 196
      if (! q->dq_dqb.dqb_isoftlimit) {
#line 196
        if (! q->dq_dqb.dqb_ihardlimit) {
#line 196
          if (! q->dq_dqb.dqb_bsoftlimit) {
#line 196
            if (! q->dq_dqb.dqb_bhardlimit) {
#line 198
              goto __Cont;
            }
          }
        }
      }
    }
#line 199
    msgi = (char *)((void *)0);
#line 200
    if (q->dq_dqb.dqb_ihardlimit) {
#line 200
      if (q->dq_dqb.dqb_curinodes >= q->dq_dqb.dqb_ihardlimit) {
        {
#line 201
        msgi = gettext("File limit reached on");
#line 202
        iover = 1;
        }
      } else {
#line 200
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 204
    if (q->dq_dqb.dqb_isoftlimit) {
#line 204
      if (q->dq_dqb.dqb_curinodes > q->dq_dqb.dqb_isoftlimit) {
#line 206
        if (q->dq_dqb.dqb_itime > now___0) {
          {
#line 207
          msgi = gettext("In file grace period on");
#line 208
          iover = 2;
          }
        } else {
          {
#line 211
          msgi = gettext("Over file quota on");
#line 212
          iover = 3;
          }
        }
      }
    }
#line 215
    msgb = (char *)((void *)0);
#line 216
    if (q->dq_dqb.dqb_bhardlimit) {
#line 216
      if (((q->dq_dqb.dqb_curspace + (qsize_t )(1 << 10)) - 1L) >> 10 >= q->dq_dqb.dqb_bhardlimit) {
        {
#line 217
        msgb = gettext("Block limit reached on");
#line 218
        bover = 1;
        }
      } else {
#line 216
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 220
    if (q->dq_dqb.dqb_bsoftlimit) {
#line 220
      if (((q->dq_dqb.dqb_curspace + (qsize_t )(1 << 10)) - 1L) >> 10 > q->dq_dqb.dqb_bsoftlimit) {
#line 222
        if (q->dq_dqb.dqb_btime > now___0) {
          {
#line 223
          msgb = gettext("In block grace period on");
#line 224
          bover = 2;
          }
        } else {
          {
#line 227
          msgb = gettext("Over block quota on");
#line 228
          bover = 3;
          }
        }
      }
    }
#line 231
    over |= bover | iover;
#line 232
    if (flags___3 & 1) {
#line 233
      if (msgi) {
#line 233
        goto _L___1;
      } else
#line 233
      if (msgb) {
        _L___1: /* CIL Label */ 
#line 233
        tmp___3 = lines;
#line 233
        lines ++;
#line 233
        if (! tmp___3) {
          {
#line 234
          heading(type, id___0, name, (char *)"");
          }
        }
      }
#line 235
      if (msgi) {
        {
#line 236
        printf((char const   */* __restrict  */)"\t%s", msgi);
#line 237
        print_fs_location(q);
        }
      }
#line 239
      if (msgb) {
        {
#line 240
        printf((char const   */* __restrict  */)"\t%s", msgb);
#line 241
        print_fs_location(q);
        }
      }
#line 243
      goto __Cont;
    }
#line 245
    if (flags___3 & 2) {
#line 245
      goto _L___2;
    } else
#line 245
    if (q->dq_dqb.dqb_curspace) {
#line 245
      goto _L___2;
    } else
#line 245
    if (q->dq_dqb.dqb_curinodes) {
      _L___2: /* CIL Label */ 
#line 248
      tmp___4 = lines;
#line 248
      lines ++;
#line 248
      if (! tmp___4) {
        {
#line 249
        heading(type, id___0, name, (char *)"");
        }
      }
      {
#line 250
      print_fs_location(q);
      }
#line 251
      if (! (flags___3 & 4096)) {
#line 252
        if (bover) {
          {
#line 253
          difftime2str(q->dq_dqb.dqb_btime, timebuf);
          }
        } else {
#line 255
          timebuf[0] = (char)0;
        }
      } else
#line 258
      if (bover) {
        {
#line 259
        sprintf((char */* __restrict  */)(timebuf), (char const   */* __restrict  */)"%llu",
                (unsigned long long )q->dq_dqb.dqb_btime);
        }
      } else {
        {
#line 261
        strcpy((char */* __restrict  */)(timebuf), (char const   */* __restrict  */)"0");
        }
      }
      {
#line 263
      space2str(((q->dq_dqb.dqb_curspace + (qsize_t )(1 << 10)) - 1L) >> 10, numbuf[0],
                ! (! (flags___3 & 16)));
#line 264
      space2str(q->dq_dqb.dqb_bsoftlimit, numbuf[1], ! (! (flags___3 & 16)));
#line 265
      space2str(q->dq_dqb.dqb_bhardlimit, numbuf[2], ! (! (flags___3 & 16)));
      }
#line 266
      if (bover) {
#line 266
        tmp___5 = '*';
      } else {
#line 266
        tmp___5 = ' ';
      }
      {
#line 266
      printf((char const   */* __restrict  */)" %7s%c %6s %7s %7s", numbuf[0], tmp___5,
             numbuf[1], numbuf[2], timebuf);
      }
#line 269
      if (! (flags___3 & 4096)) {
#line 270
        if (iover) {
          {
#line 271
          difftime2str(q->dq_dqb.dqb_itime, timebuf);
          }
        } else {
#line 273
          timebuf[0] = (char)0;
        }
      } else
#line 276
      if (iover) {
        {
#line 277
        sprintf((char */* __restrict  */)(timebuf), (char const   */* __restrict  */)"%llu",
                (unsigned long long )q->dq_dqb.dqb_itime);
        }
      } else {
        {
#line 279
        strcpy((char */* __restrict  */)(timebuf), (char const   */* __restrict  */)"0");
        }
      }
      {
#line 281
      number2str((unsigned long long )q->dq_dqb.dqb_curinodes, numbuf[0], ! (! (flags___3 & 16)));
#line 282
      number2str((unsigned long long )q->dq_dqb.dqb_isoftlimit, numbuf[1], ! (! (flags___3 & 16)));
#line 283
      number2str((unsigned long long )q->dq_dqb.dqb_ihardlimit, numbuf[2], ! (! (flags___3 & 16)));
      }
#line 284
      if (iover) {
#line 284
        tmp___6 = '*';
      } else {
#line 284
        tmp___6 = ' ';
      }
      {
#line 284
      printf((char const   */* __restrict  */)" %7s%c %6s %7s %7s\n", numbuf[0], tmp___6,
             numbuf[1], numbuf[2], timebuf);
      }
#line 286
      goto __Cont;
    }
    __Cont: /* CIL Label */ 
#line 194
    q = q->dq_next;
  }
  while_break: /* CIL Label */ ;
  }
#line 289
  if (! (flags___3 & 1)) {
#line 289
    if (! lines) {
#line 289
      if (qlist) {
        {
#line 290
        tmp___7 = gettext("none");
#line 290
        heading(type, id___0, name, tmp___7);
        }
      }
    }
  }
  {
#line 291
  freeprivs(qlist);
#line 292
  dispose_handle_list(handles);
  }
#line 293
  if (over > 0) {
#line 293
    tmp___8 = 1;
  } else {
#line 293
    tmp___8 = 0;
  }
#line 293
  return (tmp___8);
}
}
#line 50 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v1.c"
static int v1_check_file___4(int fd , int type , int fmt___7 ) ;
#line 51
static int v1_init_io___4(struct quota_handle *h ) ;
#line 52
static int v1_new_io___4(struct quota_handle *h ) ;
#line 53
static int v1_write_info___4(struct quota_handle *h ) ;
#line 54
static struct dquot *v1_read_dquot___4(struct quota_handle *h , qid_t id___0 ) ;
#line 55
static int v1_commit_dquot___4(struct dquot *dquot , int flags___7 ) ;
#line 56
static int v1_scan_dquots___4(struct quota_handle *h , int (*process_dquot)(struct dquot *dquot ,
                                                                            char *dqname ) ) ;
#line 127 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v1.c"
static int v1_check_file___4(int fd , int type , int fmt___7 ) 
{ 
  struct stat st ;
  int tmp ;

  {
  {
#line 131
  tmp = fstat(fd, & st);
  }
#line 131
  if (tmp < 0) {
#line 132
    return (0);
  }
#line 133
  if (! st.st_size) {
#line 134
    return (0);
  } else
#line 133
  if ((unsigned long )st.st_size % sizeof(struct v1_disk_dqblk )) {
#line 134
    return (0);
  }
#line 135
  return (1);
}
}
#line 141 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v1.c"
static int v1_init_io___4(struct quota_handle *h ) 
{ 
  int tmp ;
  struct v1_kern_dqblk kdqblk ;
  time_t tmp___0 ;
  int *tmp___1 ;
  long tmp___2 ;
  struct v1_disk_dqblk ddqblk ;
  ssize_t tmp___3 ;

  {
#line 143
  if (h->qh_io_flags & 1) {
#line 144
    if (kernel_iface == 3) {
      {
#line 145
      tmp = vfs_get_info(h);
      }
#line 145
      if (tmp < 0) {
#line 146
        return (-1);
      }
    } else {
      {
#line 151
      tmp___2 = quotactl((768 << 8) | (h->qh_type & 255), (char const   *)(h->qh_quotadev),
                         (qid_t )0, (caddr_t )((void *)(& kdqblk)));
      }
#line 151
      if (tmp___2 < 0L) {
        {
#line 152
        tmp___1 = __errno_location();
        }
#line 152
        if (*tmp___1 == 1) {
#line 153
          tmp___0 = (time_t )0;
#line 153
          h->qh_info.dqi_igrace = tmp___0;
#line 153
          h->qh_info.dqi_bgrace = tmp___0;
        } else {
#line 156
          return (-1);
        }
      } else {
#line 159
        h->qh_info.dqi_bgrace = kdqblk.dqb_btime;
#line 160
        h->qh_info.dqi_igrace = kdqblk.dqb_itime;
      }
    }
  } else {
    {
#line 167
    lseek(h->qh_fd, (__off64_t )0, 0);
#line 168
    tmp___3 = read(h->qh_fd, (void *)(& ddqblk), sizeof(ddqblk));
    }
#line 168
    if ((unsigned long )tmp___3 != sizeof(ddqblk)) {
#line 169
      return (-1);
    }
#line 170
    h->qh_info.dqi_bgrace = ddqblk.dqb_btime;
#line 171
    h->qh_info.dqi_igrace = ddqblk.dqb_itime;
  }
#line 173
  if (! h->qh_info.dqi_bgrace) {
#line 174
    h->qh_info.dqi_bgrace = (time_t )604800;
  }
#line 175
  if (! h->qh_info.dqi_igrace) {
#line 176
    h->qh_info.dqi_igrace = (time_t )604800;
  }
#line 177
  h->qh_info.dqi_max_b_limit = (uint64_t )(~ ((uint32_t )0));
#line 178
  h->qh_info.dqi_max_i_limit = (uint64_t )(~ ((uint32_t )0));
#line 179
  h->qh_info.dqi_max_b_usage = 4294967295UL << 10;
#line 180
  h->qh_info.dqi_max_i_usage = (uint64_t )(~ ((uint32_t )0));
#line 182
  return (0);
}
}
#line 188 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v1.c"
static int v1_new_io___4(struct quota_handle *h ) 
{ 
  struct v1_disk_dqblk ddqblk ;
  ssize_t tmp ;

  {
  {
#line 193
  memset((void *)(& ddqblk), 0, sizeof(ddqblk));
#line 194
  ddqblk.dqb_btime = (time_t )604800;
#line 195
  ddqblk.dqb_itime = (time_t )604800;
#line 196
  h->qh_info.dqi_bgrace = (time_t )604800;
#line 197
  h->qh_info.dqi_igrace = (time_t )604800;
#line 198
  h->qh_info.dqi_max_b_limit = (uint64_t )(~ ((uint32_t )0));
#line 199
  h->qh_info.dqi_max_i_limit = (uint64_t )(~ ((uint32_t )0));
#line 200
  h->qh_info.dqi_max_b_usage = 4294967295UL << 10;
#line 201
  h->qh_info.dqi_max_i_usage = (uint64_t )(~ ((uint32_t )0));
#line 202
  lseek(h->qh_fd, (__off64_t )0, 0);
#line 203
  tmp = write(h->qh_fd, (void const   *)(& ddqblk), sizeof(ddqblk));
  }
#line 203
  if ((unsigned long )tmp != sizeof(ddqblk)) {
#line 204
    return (-1);
  }
#line 205
  return (0);
}
}
#line 211 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v1.c"
static int v1_write_info___4(struct quota_handle *h ) 
{ 
  char *tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  struct v1_kern_dqblk kdqblk ;
  long tmp___2 ;
  long tmp___3 ;
  struct v1_disk_dqblk ddqblk ;
  ssize_t tmp___4 ;
  ssize_t tmp___5 ;

  {
#line 213
  if (h->qh_io_flags & 4) {
    {
#line 214
    tmp = gettext("Trying to write info to readonly quotafile on %s.\n");
#line 214
    errstr(tmp, h->qh_quotadev);
#line 215
    tmp___0 = __errno_location();
#line 215
    *tmp___0 = 1;
    }
#line 216
    return (-1);
  }
#line 218
  if (h->qh_io_flags & 1) {
#line 219
    if (kernel_iface == 3) {
      {
#line 220
      tmp___1 = vfs_set_info(h, 3);
      }
#line 220
      if (tmp___1 < 0) {
#line 221
        return (-1);
      }
    } else {
      {
#line 226
      tmp___2 = quotactl((768 << 8) | (h->qh_type & 255), (char const   *)(h->qh_quotadev),
                         (qid_t )0, (caddr_t )((void *)(& kdqblk)));
      }
#line 226
      if (tmp___2 < 0L) {
#line 227
        return (-1);
      }
      {
#line 228
      kdqblk.dqb_btime = h->qh_info.dqi_bgrace;
#line 229
      kdqblk.dqb_itime = h->qh_info.dqi_igrace;
#line 230
      tmp___3 = quotactl((1024 << 8) | (h->qh_type & 255), (char const   *)(h->qh_quotadev),
                         (qid_t )0, (caddr_t )((void *)(& kdqblk)));
      }
#line 230
      if (tmp___3 < 0L) {
#line 231
        return (-1);
      }
    }
  } else {
    {
#line 237
    lseek(h->qh_fd, (__off64_t )0, 0);
#line 238
    tmp___4 = read(h->qh_fd, (void *)(& ddqblk), sizeof(ddqblk));
    }
#line 238
    if ((unsigned long )tmp___4 != sizeof(ddqblk)) {
#line 239
      return (-1);
    }
    {
#line 240
    ddqblk.dqb_btime = h->qh_info.dqi_bgrace;
#line 241
    ddqblk.dqb_itime = h->qh_info.dqi_igrace;
#line 242
    lseek(h->qh_fd, (__off64_t )0, 0);
#line 243
    tmp___5 = write(h->qh_fd, (void const   *)(& ddqblk), sizeof(ddqblk));
    }
#line 243
    if ((unsigned long )tmp___5 != sizeof(ddqblk)) {
#line 244
      return (-1);
    }
  }
#line 246
  return (0);
}
}
#line 253 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v1.c"
static struct dquot *v1_read_dquot___4(struct quota_handle *h , qid_t id___0 ) 
{ 
  struct v1_disk_dqblk ddqblk ;
  struct dquot *dquot ;
  struct dquot *tmp ;
  int tmp___0 ;
  struct v1_kern_dqblk kdqblk ;
  long tmp___1 ;
  ssize_t tmp___2 ;

  {
  {
#line 256
  tmp = get_empty_dquot();
#line 256
  dquot = tmp;
#line 258
  dquot->dq_id = id___0;
#line 259
  dquot->dq_h = h;
  }
#line 260
  if (h->qh_io_flags & 1) {
#line 261
    if (kernel_iface == 3) {
      {
#line 262
      tmp___0 = vfs_get_dquot(dquot);
      }
#line 262
      if (tmp___0 < 0) {
        {
#line 263
        free((void *)dquot);
        }
#line 264
        return ((struct dquot *)((void *)0));
      }
    } else {
      {
#line 270
      tmp___1 = quotactl((768 << 8) | (h->qh_type & 255), (char const   *)(h->qh_quotadev),
                         id___0, (caddr_t )((void *)(& kdqblk)));
      }
#line 270
      if (tmp___1 < 0L) {
        {
#line 271
        free((void *)dquot);
        }
#line 272
        return ((struct dquot *)((void *)0));
      }
      {
#line 274
      v1_kern2utildqblk(& dquot->dq_dqb, & kdqblk);
      }
    }
  } else {
    {
#line 278
    lseek(h->qh_fd, (loff_t )((unsigned long )id___0 * sizeof(struct v1_disk_dqblk )),
          0);
#line 279
    tmp___2 = read(h->qh_fd, (void *)(& ddqblk), sizeof(ddqblk));
    }
    {
#line 280
    if (tmp___2 == 0L) {
#line 280
      goto case_0;
    }
#line 287
    if (tmp___2 == (ssize_t )sizeof(struct v1_disk_dqblk )) {
#line 287
      goto case_exp;
    }
#line 290
    goto switch_default;
    case_0: /* CIL Label */ 
    {
#line 285
    memset((void *)(& dquot->dq_dqb), 0, sizeof(struct util_dqblk ));
    }
#line 286
    goto switch_break;
    case_exp: /* CIL Label */ 
    {
#line 288
    v1_disk2memdqblk(& dquot->dq_dqb, & ddqblk);
    }
#line 289
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 291
    free((void *)dquot);
    }
#line 292
    return ((struct dquot *)((void *)0));
    switch_break: /* CIL Label */ ;
    }
  }
#line 295
  return (dquot);
}
}
#line 302 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v1.c"
static int v1_commit_dquot___4(struct dquot *dquot , int flags___7 ) 
{ 
  struct v1_disk_dqblk ddqblk ;
  struct quota_handle *h ;
  char *tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  struct v1_kern_dqblk kdqblk ;
  int cmd ;
  int *tmp___2 ;
  long tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;
  ssize_t tmp___6 ;

  {
#line 305
  h = dquot->dq_h;
#line 307
  if (h->qh_io_flags & 4) {
    {
#line 308
    tmp = gettext("Trying to write quota to readonly quotafile on %s\n");
#line 308
    errstr(tmp, h->qh_quotadev);
#line 309
    tmp___0 = __errno_location();
#line 309
    *tmp___0 = 1;
    }
#line 310
    return (-1);
  }
#line 312
  if (h->qh_io_flags & 1) {
#line 313
    if (kernel_iface == 3) {
      {
#line 314
      tmp___1 = vfs_set_dquot(dquot, flags___7);
      }
#line 314
      if (tmp___1 < 0) {
#line 315
        return (-1);
      }
    } else {
#line 321
      if (flags___7 == 10) {
#line 322
        cmd = 1280;
      } else
#line 323
      if (flags___7 == 5) {
#line 324
        cmd = 1792;
      } else
#line 325
      if (flags___7 & 48) {
        {
#line 326
        tmp___2 = __errno_location();
#line 326
        *tmp___2 = 22;
        }
#line 327
        return (-1);
      } else {
#line 330
        cmd = 1024;
      }
      {
#line 331
      v1_util2kerndqblk(& kdqblk, & dquot->dq_dqb);
#line 332
      tmp___3 = quotactl((cmd << 8) | (h->qh_type & 255), (char const   *)(h->qh_quotadev),
                         dquot->dq_id, (caddr_t )((void *)(& kdqblk)));
      }
#line 332
      if (tmp___3 < 0L) {
#line 334
        return (-1);
      }
    }
  } else {
    {
#line 338
    tmp___5 = check_dquot_range(dquot);
    }
#line 338
    if (tmp___5 < 0) {
      {
#line 339
      tmp___4 = __errno_location();
#line 339
      *tmp___4 = 34;
      }
#line 340
      return (-1);
    }
    {
#line 342
    v1_mem2diskdqblk(& ddqblk, & dquot->dq_dqb);
#line 343
    lseek(h->qh_fd, (loff_t )((unsigned long )dquot->dq_id * sizeof(struct v1_disk_dqblk )),
          0);
#line 344
    tmp___6 = write(h->qh_fd, (void const   *)(& ddqblk), sizeof(ddqblk));
    }
#line 344
    if ((unsigned long )tmp___6 != sizeof(ddqblk)) {
#line 345
      return (-1);
    }
  }
#line 347
  return (0);
}
}
#line 355 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v1.c"
static int v1_scan_dquots___4(struct quota_handle *h , int (*process_dquot)(struct dquot *dquot ,
                                                                            char *dqname ) ) 
{ 
  int rd ;
  int scanbufpos ;
  int scanbufsize ;
  char scanbuf[sizeof(struct v1_disk_dqblk ) * 256UL] ;
  struct v1_disk_dqblk *ddqblk ;
  struct dquot *dquot ;
  struct dquot *tmp ;
  qid_t id___0 ;
  ssize_t tmp___0 ;

  {
  {
#line 357
  scanbufpos = 0;
#line 357
  scanbufsize = 0;
#line 360
  tmp = get_empty_dquot();
#line 360
  dquot = tmp;
#line 361
  id___0 = (qid_t )0;
#line 363
  memset((void *)dquot, 0, sizeof(*dquot));
#line 364
  dquot->dq_h = h;
#line 365
  lseek(h->qh_fd, (__off64_t )0, 0);
#line 366
  id___0 = (qid_t )0;
  }
  {
#line 366
  while (1) {
    while_continue: /* CIL Label */ ;
#line 367
    if (scanbufpos >= scanbufsize) {
      {
#line 368
      tmp___0 = read(h->qh_fd, (void *)(scanbuf), sizeof(scanbuf));
#line 368
      rd = (int )tmp___0;
      }
#line 369
      if (rd < 0) {
#line 370
        goto out_err;
      } else
#line 369
      if ((unsigned long )rd % sizeof(struct v1_disk_dqblk )) {
#line 370
        goto out_err;
      }
#line 371
      if (! rd) {
#line 372
        goto while_break;
      }
#line 373
      scanbufpos = 0;
#line 374
      scanbufsize = (int )((unsigned long )rd / sizeof(struct v1_disk_dqblk ));
    }
#line 376
    ddqblk = (struct v1_disk_dqblk *)(scanbuf) + scanbufpos;
#line 377
    if ((((long )(((((ddqblk->dqb_ihardlimit | ddqblk->dqb_isoftlimit) | ddqblk->dqb_bhardlimit) | ddqblk->dqb_bsoftlimit) | ddqblk->dqb_curblocks) | ddqblk->dqb_curinodes) | ddqblk->dqb_itime) | ddqblk->dqb_btime) == 0L) {
#line 381
      goto __Cont;
    }
    {
#line 382
    v1_disk2memdqblk(& dquot->dq_dqb, ddqblk);
#line 383
    dquot->dq_id = id___0;
#line 384
    rd = (*process_dquot)(dquot, (char *)((void *)0));
    }
#line 384
    if (rd < 0) {
      {
#line 385
      free((void *)dquot);
      }
#line 386
      return (rd);
    }
    __Cont: /* CIL Label */ 
#line 366
    id___0 ++;
#line 366
    scanbufpos ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 389
  if (! rd) {
    {
#line 390
    free((void *)dquot);
    }
#line 391
    return (0);
  }
  out_err: 
  {
#line 394
  free((void *)dquot);
  }
#line 395
  return (-1);
}
}
#line 27 "/home/wheatley/newnew/temp/quota-4.01/quotaio_xfs.c"
static int xfs_init_io___4(struct quota_handle *h ) ;
#line 28
static int xfs_write_info___4(struct quota_handle *h ) ;
#line 29
static struct dquot *xfs_read_dquot___4(struct quota_handle *h , qid_t id___0 ) ;
#line 30
static int xfs_commit_dquot___4(struct dquot *dquot , int flags___7 ) ;
#line 31
static int xfs_scan_dquots___4(struct quota_handle *h , int (*process_dquot)(struct dquot *dquot ,
                                                                             char *dqname ) ) ;
#line 32
static int xfs_report___4(struct quota_handle *h , int verbose ) ;
#line 77 "/home/wheatley/newnew/temp/quota-4.01/quotaio_xfs.c"
static int xfs_init_io___4(struct quota_handle *h ) 
{ 
  struct fs_quota_stat info ;
  int qcmd ;
  long tmp ;

  {
  {
#line 82
  qcmd = ((88 << 8) + 5) << 8;
#line 83
  memset((void *)(& info), 0, sizeof(struct fs_quota_stat ));
#line 84
  tmp = quotactl(qcmd, (char const   *)(h->qh_quotadev), (qid_t )0, (caddr_t )((void *)(& info)));
  }
#line 84
  if (tmp < 0L) {
#line 85
    return (-1);
  }
#line 86
  h->qh_info.dqi_bgrace = (time_t )info.qs_btimelimit;
#line 87
  h->qh_info.dqi_igrace = (time_t )info.qs_itimelimit;
#line 88
  h->qh_info.u.xfs_mdqi = info;
#line 89
  return (0);
}
}
#line 95 "/home/wheatley/newnew/temp/quota-4.01/quotaio_xfs.c"
static int xfs_write_info___4(struct quota_handle *h ) 
{ 
  struct fs_disk_quota xdqblk ;
  int qcmd ;
  long tmp ;

  {
#line 100
  if (h->qh_type == 0) {
#line 100
    if (! ((int )h->qh_info.u.xfs_mdqi.qs_flags & 1)) {
#line 100
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 100
  if (h->qh_type == 1) {
#line 100
    if (! ((int )h->qh_info.u.xfs_mdqi.qs_flags & (1 << 2))) {
#line 101
      return (0);
    }
  } else {
#line 101
    return (0);
  }
  {
#line 103
  memset((void *)(& xdqblk), 0, sizeof(struct fs_disk_quota ));
#line 105
  xdqblk.d_btimer = (__s32 )h->qh_info.dqi_bgrace;
#line 106
  xdqblk.d_itimer = (__s32 )h->qh_info.dqi_igrace;
#line 107
  xdqblk.d_fieldmask = (__u16 )((int )xdqblk.d_fieldmask | (((1 << 6) | (1 << 7)) | (1 << 8)));
#line 108
  qcmd = (((88 << 8) + 4) << 8) | (h->qh_type & 255);
#line 109
  tmp = quotactl(qcmd, (char const   *)(h->qh_quotadev), (qid_t )0, (caddr_t )((void *)(& xdqblk)));
  }
#line 109
  if (tmp < 0L) {
#line 110
    return (-1);
  }
#line 111
  return (0);
}
}
#line 117 "/home/wheatley/newnew/temp/quota-4.01/quotaio_xfs.c"
static struct dquot *xfs_read_dquot___4(struct quota_handle *h , qid_t id___0 ) 
{ 
  struct dquot *dquot ;
  struct dquot *tmp ;
  struct fs_disk_quota xdqblk ;
  int qcmd ;
  long tmp___0 ;

  {
  {
#line 119
  tmp = get_empty_dquot();
#line 119
  dquot = tmp;
#line 123
  dquot->dq_id = id___0;
#line 124
  dquot->dq_h = h;
  }
#line 126
  if (h->qh_type == 0) {
#line 126
    if (! ((int )h->qh_info.u.xfs_mdqi.qs_flags & 1)) {
#line 126
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 126
  if (h->qh_type == 1) {
#line 126
    if (! ((int )h->qh_info.u.xfs_mdqi.qs_flags & (1 << 2))) {
#line 127
      return (dquot);
    }
  } else {
#line 127
    return (dquot);
  }
  {
#line 129
  qcmd = (((88 << 8) + 3) << 8) | (h->qh_type & 255);
#line 130
  tmp___0 = quotactl(qcmd, (char const   *)(h->qh_quotadev), id___0, (caddr_t )((void *)(& xdqblk)));
  }
#line 130
  if (! (tmp___0 < 0L)) {
    {
#line 134
    xfs_kern2utildqblk(& dquot->dq_dqb, & xdqblk);
    }
  }
#line 136
  return (dquot);
}
}
#line 142 "/home/wheatley/newnew/temp/quota-4.01/quotaio_xfs.c"
static int xfs_commit_dquot___4(struct dquot *dquot , int flags___7 ) 
{ 
  struct quota_handle *h ;
  struct fs_disk_quota xdqblk ;
  qid_t id___0 ;
  int qcmd ;
  int tmp ;
  int tmp___0 ;
  long tmp___1 ;

  {
#line 144
  h = dquot->dq_h;
#line 146
  id___0 = dquot->dq_id;
#line 149
  if (h->qh_type == 0) {
#line 149
    if (! ((int )h->qh_info.u.xfs_mdqi.qs_flags & 1)) {
#line 149
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 149
  if (h->qh_type == 1) {
#line 149
    if (! ((int )h->qh_info.u.xfs_mdqi.qs_flags & (1 << 2))) {
#line 150
      return (0);
    }
  } else {
#line 150
    return (0);
  }
  {
#line 152
  xfs_util2kerndqblk(& xdqblk, & dquot->dq_dqb);
  }
#line 153
  if (h->qh_type == 0) {
#line 153
    if ((int )h->qh_info.u.xfs_mdqi.qs_flags & 1) {
#line 153
      tmp = 1;
    } else {
#line 153
      tmp = 1 << 2;
    }
  } else {
#line 153
    tmp = 1 << 2;
  }
  {
#line 153
  xdqblk.d_flags = (__s8 )((int )xdqblk.d_flags | tmp);
#line 154
  xdqblk.d_id = id___0;
#line 155
  tmp___0 = strcmp((char const   *)(h->qh_fstype), "gfs2");
  }
#line 155
  if (tmp___0 == 0) {
#line 156
    if (flags___7 & 5) {
#line 157
      xdqblk.d_fieldmask = (__u16 )((int )xdqblk.d_fieldmask | ((1 << 2) | (1 << 3)));
    }
#line 158
    if (flags___7 & 10) {
#line 159
      xdqblk.d_fieldmask = (__u16 )((int )xdqblk.d_fieldmask | (1 << 12));
    }
  } else {
#line 161
    xdqblk.d_fieldmask = (__u16 )((int )xdqblk.d_fieldmask | (((((1 | (1 << 1)) | (1 << 2)) | (1 << 3)) | (1 << 4)) | (1 << 5)));
  }
  {
#line 164
  qcmd = (((88 << 8) + 4) << 8) | (h->qh_type & 255);
#line 165
  tmp___1 = quotactl(qcmd, (char const   *)(h->qh_quotadev), id___0, (caddr_t )((void *)(& xdqblk)));
  }
#line 165
  if (! (tmp___1 < 0L)) {
#line 169
    return (0);
  }
#line 171
  return (-1);
}
}
#line 177 "/home/wheatley/newnew/temp/quota-4.01/quotaio_xfs.c"
static int xfs_get_dquot___4(struct dquot *dq ) 
{ 
  struct fs_disk_quota d ;
  int qcmd ;
  int ret ;
  long tmp ;
  int *tmp___0 ;

  {
  {
#line 180
  qcmd = (((88 << 8) + 3) << 8) | ((dq->dq_h)->qh_type & 255);
#line 183
  memset((void *)(& d), 0, sizeof(d));
#line 184
  tmp = quotactl(qcmd, (char const   *)((dq->dq_h)->qh_quotadev), dq->dq_id, (caddr_t )((void *)(& d)));
#line 184
  ret = (int )tmp;
  }
#line 185
  if (ret < 0) {
    {
#line 186
    tmp___0 = __errno_location();
    }
#line 186
    if (*tmp___0 == 2) {
#line 187
      return (0);
    }
#line 188
    return (-1);
  }
  {
#line 190
  xfs_kern2utildqblk(& dq->dq_dqb, & d);
  }
#line 191
  return (0);
}
}
#line 197 "/home/wheatley/newnew/temp/quota-4.01/quotaio_xfs.c"
static int xfs_scan_dquots___4(struct quota_handle *h , int (*process_dquot)(struct dquot *dquot ,
                                                                             char *dqname ) ) 
{ 
  int tmp ;

  {
#line 199
  if (h->qh_type == 0) {
#line 199
    if (! ((int )h->qh_info.u.xfs_mdqi.qs_flags & 1)) {
#line 199
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 199
  if (h->qh_type == 1) {
#line 199
    if (! ((int )h->qh_info.u.xfs_mdqi.qs_flags & (1 << 2))) {
#line 200
      return (0);
    }
  } else {
#line 200
    return (0);
  }
  {
#line 202
  tmp = generic_scan_dquots(h, process_dquot, & xfs_get_dquot___4);
  }
#line 202
  return (tmp);
}
}
#line 208 "/home/wheatley/newnew/temp/quota-4.01/quotaio_xfs.c"
static int xfs_report___4(struct quota_handle *h , int verbose ) 
{ 
  u_int16_t sbflags ;
  struct fs_quota_stat *info ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;
  char *tmp___18 ;
  char *tmp___19 ;
  char *tmp___20 ;
  char *tmp___21 ;
  char *tmp___22 ;
  char *tmp___23 ;
  char *tmp___24 ;
  char *tmp___25 ;
  char *tmp___26 ;
  char *tmp___27 ;
  char *tmp___28 ;
  char *tmp___29 ;
  char *tmp___30 ;
  char *tmp___31 ;
  char *tmp___32 ;

  {
#line 211
  info = & h->qh_info.u.xfs_mdqi;
#line 213
  if (! verbose) {
#line 214
    return (0);
  }
  {
#line 217
  tmp = type2name(h->qh_type);
#line 217
  tmp___0 = gettext("*** Status for %s quotas on device %s\n");
#line 217
  printf((char const   */* __restrict  */)tmp___0, tmp, h->qh_quotadev);
  }
#line 220
  if (h->qh_type == 0) {
#line 221
    if ((int )info->qs_flags & (1 << 1)) {
      {
#line 221
      tmp___1 = gettext("ON");
#line 221
      tmp___3 = tmp___1;
      }
    } else {
      {
#line 221
      tmp___2 = gettext("OFF");
#line 221
      tmp___3 = tmp___2;
      }
    }
#line 221
    if ((int )info->qs_flags & 1) {
      {
#line 221
      tmp___4 = gettext("ON");
#line 221
      tmp___6 = tmp___4;
      }
    } else {
      {
#line 221
      tmp___5 = gettext("OFF");
#line 221
      tmp___6 = tmp___5;
      }
    }
    {
#line 221
    tmp___7 = gettext("Accounting: %s; Enforcement: %s\n");
#line 221
    printf((char const   */* __restrict  */)tmp___7, tmp___6, tmp___3);
    }
  } else {
#line 225
    if ((int )info->qs_flags & (1 << 3)) {
      {
#line 225
      tmp___8 = gettext("ON");
#line 225
      tmp___10 = tmp___8;
      }
    } else {
      {
#line 225
      tmp___9 = gettext("OFF");
#line 225
      tmp___10 = tmp___9;
      }
    }
#line 225
    if ((int )info->qs_flags & (1 << 2)) {
      {
#line 225
      tmp___11 = gettext("ON");
#line 225
      tmp___13 = tmp___11;
      }
    } else {
      {
#line 225
      tmp___12 = gettext("OFF");
#line 225
      tmp___13 = tmp___12;
      }
    }
    {
#line 225
    tmp___14 = gettext("Accounting: %s; Enforcement: %s\n");
#line 225
    printf((char const   */* __restrict  */)tmp___14, tmp___13, tmp___10);
    }
  }
#line 235
  sbflags = (u_int16_t )(((int )info->qs_flags & 65280) >> 8);
#line 235
  if ((int )sbflags != 0) {
#line 236
    if (h->qh_type == 0) {
#line 237
      if ((int )sbflags & (1 << 1)) {
        {
#line 237
        tmp___15 = gettext("ON");
#line 237
        tmp___17 = tmp___15;
        }
      } else {
        {
#line 237
        tmp___16 = gettext("OFF");
#line 237
        tmp___17 = tmp___16;
        }
      }
#line 237
      if ((int )sbflags & 1) {
        {
#line 237
        tmp___18 = gettext("ON");
#line 237
        tmp___20 = tmp___18;
        }
      } else {
        {
#line 237
        tmp___19 = gettext("OFF");
#line 237
        tmp___20 = tmp___19;
        }
      }
      {
#line 237
      tmp___21 = gettext("Accounting [ondisk]: %s; Enforcement [ondisk]: %s\n");
#line 237
      printf((char const   */* __restrict  */)tmp___21, tmp___20, tmp___17);
      }
    } else {
#line 241
      if ((int )sbflags & (1 << 3)) {
        {
#line 241
        tmp___22 = gettext("ON");
#line 241
        tmp___24 = tmp___22;
        }
      } else {
        {
#line 241
        tmp___23 = gettext("OFF");
#line 241
        tmp___24 = tmp___23;
        }
      }
#line 241
      if ((int )sbflags & (1 << 2)) {
        {
#line 241
        tmp___25 = gettext("ON");
#line 241
        tmp___27 = tmp___25;
        }
      } else {
        {
#line 241
        tmp___26 = gettext("OFF");
#line 241
        tmp___27 = tmp___26;
        }
      }
      {
#line 241
      tmp___28 = gettext("Accounting [ondisk]: %s; Enforcement [ondisk]: %s\n");
#line 241
      printf((char const   */* __restrict  */)tmp___28, tmp___27, tmp___24);
      }
    }
  }
#line 248
  if (h->qh_type == 0) {
#line 249
    if (info->qs_uquota.qfs_ino == 0xffffffffffffffffULL) {
      {
#line 250
      tmp___29 = gettext("Inode: none\n");
#line 250
      printf((char const   */* __restrict  */)tmp___29);
      }
    } else
#line 249
    if (info->qs_uquota.qfs_ino == 0ULL) {
      {
#line 250
      tmp___29 = gettext("Inode: none\n");
#line 250
      printf((char const   */* __restrict  */)tmp___29);
      }
    } else {
      {
#line 252
      tmp___30 = gettext("Inode: #%llu (%llu blocks, %u extents)\n");
#line 252
      printf((char const   */* __restrict  */)tmp___30, info->qs_uquota.qfs_ino, info->qs_uquota.qfs_nblks,
             info->qs_uquota.qfs_nextents);
      }
    }
  } else
#line 258
  if (info->qs_gquota.qfs_ino == 0xffffffffffffffffULL) {
    {
#line 259
    tmp___31 = gettext("Inode: none\n");
#line 259
    printf((char const   */* __restrict  */)tmp___31);
    }
  } else {
    {
#line 261
    tmp___32 = gettext("Inode: #%llu (%llu blocks, %u extents)\n");
#line 261
    printf((char const   */* __restrict  */)tmp___32, info->qs_gquota.qfs_ino, info->qs_gquota.qfs_nblks,
           info->qs_gquota.qfs_nextents);
    }
  }
#line 266
  return (0);
}
}
#line 89 "/home/wheatley/newnew/temp/quota-4.01/rquota_client.c"
static int rquota_err___4(int stat___0 ) 
{ 


  {
  {
#line 92
  if (stat___0 == -1) {
#line 92
    goto case_neg_1;
  }
#line 94
  if (stat___0 == 0) {
#line 94
    goto case_0;
  }
#line 96
  if (stat___0 == 2) {
#line 96
    goto case_2;
  }
#line 98
  if (stat___0 == 1) {
#line 98
    goto case_1;
  }
#line 100
  if (stat___0 == 3) {
#line 100
    goto case_3;
  }
#line 102
  goto switch_default;
  case_neg_1: /* CIL Label */ 
#line 93
  return (-111);
  case_0: /* CIL Label */ 
#line 95
  return (-38);
  case_2: /* CIL Label */ 
#line 97
  return (-2);
  case_1: /* CIL Label */ 
#line 99
  return (0);
  case_3: /* CIL Label */ 
#line 101
  return (-1);
  switch_default: /* CIL Label */ 
#line 103
  return (-22);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 107 "/home/wheatley/newnew/temp/quota-4.01/rquota_client.c"
static int split_nfs_mount___4(char *devname , char **host , char **path ) 
{ 
  char *pathname ;

  {
#line 112
  if ((int )*devname == 91) {
    {
#line 113
    *host = devname + 1;
#line 114
    pathname = strchr((char const   *)devname, ']');
    }
#line 115
    if (! pathname) {
#line 116
      return (0);
    } else
#line 115
    if ((int )*(pathname + 1) != 58) {
#line 116
      return (0);
    }
#line 118
    if ((int )*(pathname + 2) == 40) {
#line 119
      return (0);
    }
#line 120
    *pathname = (char)0;
#line 121
    *path = pathname + 2;
#line 122
    return (1);
  }
  {
#line 124
  *host = devname;
#line 125
  pathname = strchr((char const   *)devname, ':');
  }
#line 126
  if (! pathname) {
#line 127
    return (0);
  }
#line 129
  if ((int )*(pathname + 1) == 40) {
#line 130
    return (0);
  }
#line 131
  *pathname = (char)0;
#line 132
  *path = pathname + 1;
#line 133
  return (1);
}
}
#line 19 "/home/wheatley/newnew/temp/quota-4.01/quotaio_meta.c"
static int meta_init_io___4(struct quota_handle *h ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
#line 21
  if (! (h->qh_io_flags & 1)) {
    {
#line 22
    tmp = gettext("Metadata init_io called when kernel support is not enabled.\n");
#line 22
    errstr(tmp);
    }
#line 23
    return (-1);
  }
#line 25
  if (kernel_iface != 3) {
    {
#line 26
    tmp___0 = gettext("Metadata init_io called when kernel does not support generic quota interface!\n");
#line 26
    errstr(tmp___0);
    }
#line 27
    return (-1);
  }
  {
#line 29
  tmp___1 = vfs_get_info(h);
  }
#line 29
  return (tmp___1);
}
}
#line 32 "/home/wheatley/newnew/temp/quota-4.01/quotaio_meta.c"
static int meta_write_info___4(struct quota_handle *h ) 
{ 
  int tmp ;

  {
  {
#line 34
  tmp = vfs_set_info(h, 3);
  }
#line 34
  return (tmp);
}
}
#line 37 "/home/wheatley/newnew/temp/quota-4.01/quotaio_meta.c"
static struct dquot *meta_read_dquot___4(struct quota_handle *h , qid_t id___0 ) 
{ 
  struct dquot *dquot ;
  struct dquot *tmp ;
  int tmp___0 ;

  {
  {
#line 39
  tmp = get_empty_dquot();
#line 39
  dquot = tmp;
#line 41
  dquot->dq_id = id___0;
#line 42
  dquot->dq_h = h;
#line 43
  memset((void *)(& dquot->dq_dqb), 0, sizeof(struct util_dqblk ));
#line 44
  tmp___0 = vfs_get_dquot(dquot);
  }
#line 44
  if (tmp___0 < 0) {
    {
#line 45
    free((void *)dquot);
    }
#line 46
    return ((struct dquot *)((void *)0));
  }
#line 48
  return (dquot);
}
}
#line 51 "/home/wheatley/newnew/temp/quota-4.01/quotaio_meta.c"
static int meta_commit_dquot___4(struct dquot *dquot , int flags___7 ) 
{ 
  int tmp ;

  {
  {
#line 53
  tmp = vfs_set_dquot(dquot, flags___7);
  }
#line 53
  return (tmp);
}
}
#line 56 "/home/wheatley/newnew/temp/quota-4.01/quotaio_meta.c"
static int meta_scan_dquots___4(struct quota_handle *h , int (*process_dquot)(struct dquot *dquot ,
                                                                              char *dqname ) ) 
{ 
  int tmp ;

  {
  {
#line 58
  tmp = generic_scan_dquots(h, process_dquot, & vfs_get_dquot);
  }
#line 58
  return (tmp);
}
}
#line 41 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static char extensions___4[4][20]  = { {        (char )'u',        (char )'s',        (char )'e',        (char )'r', 
            (char )'\000'}, 
   {        (char )'g',        (char )'r',        (char )'o',        (char )'u', 
            (char )'p',        (char )'\000'}, 
   {        (char )'u',        (char )'n',        (char )'d',        (char )'e', 
            (char )'f',        (char )'i',        (char )'n',        (char )'e', 
            (char )'d',        (char )'\000'}};
#line 42 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static char *basenames___4[6]  = {      (char *)"quota",      (char *)"aquota",      (char *)"aquota",      (char *)"", 
        (char *)"",      (char *)""};
#line 43 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static char *fmtnames___4[5]  = {      (char *)"vfsold",      (char *)"vfsv0",      (char *)"vfsv1",      (char *)"rpc", 
        (char *)"xfs"};
#line 245 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static int kern2utilfmt___4(int kernfmt ) 
{ 


  {
  {
#line 248
  if (kernfmt == 1) {
#line 248
    goto case_1;
  }
#line 250
  if (kernfmt == 2) {
#line 250
    goto case_2;
  }
#line 252
  if (kernfmt == 4) {
#line 252
    goto case_4;
  }
#line 254
  if (kernfmt == 3) {
#line 254
    goto case_3;
  }
#line 247
  goto switch_break;
  case_1: /* CIL Label */ 
#line 249
  return (0);
  case_2: /* CIL Label */ 
#line 251
  return (1);
  case_4: /* CIL Label */ 
#line 253
  return (2);
  case_3: /* CIL Label */ 
#line 255
  return (5);
  switch_break: /* CIL Label */ ;
  }
#line 257
  return (-1);
}
}
#line 394 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static int hasxfsquota___4(char const   *dev , struct mntent *mnt___2 , int type ,
                           int flags___7 ) 
{ 
  u_int16_t sbflags ;
  struct fs_quota_stat info ;
  long tmp ;

  {
#line 399
  if (flags___7 & 16) {
#line 400
    return (4);
  }
  {
#line 402
  memset((void *)(& info), 0, sizeof(struct fs_quota_stat ));
#line 403
  tmp = quotactl((((88 << 8) + 5) << 8) | (type & 255), dev, (qid_t )0, (caddr_t )((void *)(& info)));
  }
#line 403
  if (! tmp) {
#line 404
    sbflags = (u_int16_t )(((int )info.qs_flags & 65280) >> 8);
#line 405
    if (type == 0) {
#line 405
      if ((int )info.qs_flags & 1) {
#line 406
        return (4);
      } else {
#line 405
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 407
    if (type == 1) {
#line 407
      if ((int )info.qs_flags & (1 << 2)) {
#line 408
        return (4);
      }
    }
  }
#line 424
  return (-1);
}
}
#line 427 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static int hasvfsmetaquota___4(char const   *dev , struct mntent *mnt___2 , int type ,
                               int flags___7 ) 
{ 
  uint32_t fmt___7 ;
  long tmp ;

  {
  {
#line 431
  tmp = quotactl((8388612 << 8) | (type & 255), dev, (qid_t )0, (caddr_t )((void *)(& fmt___7)));
  }
#line 431
  if (! tmp) {
#line 432
    return (5);
  }
#line 433
  return (-1);
}
}
#line 465 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static char *hasmntoptarg___4(char const   *optstring , char const   *opt ) 
{ 
  char *p ;
  char *tmp ;
  size_t tmp___0 ;

  {
  {
#line 467
  tmp = str_hasmntopt(optstring, opt);
#line 467
  p = tmp;
  }
#line 469
  if (! p) {
#line 470
    return ((char *)((void *)0));
  }
  {
#line 471
  tmp___0 = strlen(opt);
#line 471
  p += tmp___0;
  }
#line 472
  if ((int )*p == 61) {
#line 472
    if ((int )*(p + 1) != 44) {
#line 473
      return (p + 1);
    }
  }
#line 474
  return ((char *)((void *)0));
}
}
#line 478 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static void copy_mntoptarg___4(char *buf , char const   *optarg___0 , int buflen ) 
{ 
  char *sep ;
  char *tmp ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  long tmp___4 ;

  {
  {
#line 480
  tmp = strchr(optarg___0, ',');
#line 480
  sep = tmp;
  }
#line 482
  if (! sep) {
    {
#line 483
    tmp___3 = strlen(optarg___0);
    }
#line 483
    if ((size_t )buflen < tmp___3 + 1UL) {
#line 483
      tmp___2 = (size_t )buflen;
    } else {
      {
#line 483
      tmp___1 = strlen(optarg___0);
#line 483
      tmp___2 = tmp___1 + 1UL;
      }
    }
    {
#line 483
    sstrncpy(buf, optarg___0, tmp___2);
    }
  } else {
#line 485
    if ((long )buflen < (sep - (char *)optarg___0) + 1L) {
#line 485
      tmp___4 = (long )buflen;
    } else {
#line 485
      tmp___4 = (sep - (char *)optarg___0) + 1L;
    }
    {
#line 485
    sstrncpy(buf, optarg___0, (size_t )tmp___4);
    }
  }
#line 486
  return;
}
}
#line 491 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static int hasquota___4(char const   *dev , struct mntent *mnt___2 , int type , int flags___7 ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  struct if_dqinfo kinfo ;
  long tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;

  {
  {
#line 493
  tmp___0 = strcmp((char const   *)mnt___2->mnt_type, "gfs2");
  }
#line 493
  if (tmp___0) {
    {
#line 493
    tmp___1 = strcmp((char const   *)mnt___2->mnt_type, "xfs");
    }
#line 493
    if (! tmp___1) {
      {
#line 495
      tmp = hasxfsquota___4(dev, mnt___2, type, flags___7);
      }
#line 495
      return (tmp);
    }
  } else {
    {
#line 495
    tmp = hasxfsquota___4(dev, mnt___2, type, flags___7);
    }
#line 495
    return (tmp);
  }
  {
#line 496
  tmp___3 = strcmp((char const   *)mnt___2->mnt_type, "ocfs2");
  }
#line 496
  if (! tmp___3) {
    {
#line 497
    tmp___2 = hasvfsmetaquota___4(dev, mnt___2, type, flags___7);
    }
#line 497
    return (tmp___2);
  }
  {
#line 504
  tmp___5 = strcmp((char const   *)mnt___2->mnt_type, "ext4");
  }
#line 504
  if (! tmp___5) {
    {
#line 507
    tmp___4 = quotactl((8388613 << 8) | (type & 255), dev, (qid_t )0, (caddr_t )((void *)(& kinfo)));
    }
#line 507
    if (tmp___4 == 0L) {
#line 508
      if (kinfo.dqi_flags & 65536U) {
#line 509
        return (5);
      }
    }
  }
  {
#line 513
  tmp___6 = nfs_fstype(mnt___2->mnt_type);
  }
#line 513
  if (tmp___6) {
#line 514
    return (3);
  }
#line 516
  if (type == 0) {
    {
#line 516
    tmp___7 = hasmntopt((struct mntent  const  *)mnt___2, "usrquota");
    }
#line 516
    if (tmp___7) {
#line 517
      return (6);
    } else {
      {
#line 516
      tmp___8 = hasmntoptarg___4((char const   *)mnt___2->mnt_opts, "usrjquota");
      }
#line 516
      if (tmp___8) {
#line 517
        return (6);
      }
    }
  }
#line 518
  if (type == 1) {
    {
#line 518
    tmp___9 = hasmntopt((struct mntent  const  *)mnt___2, "grpquota");
    }
#line 518
    if (tmp___9) {
#line 519
      return (6);
    } else {
      {
#line 518
      tmp___10 = hasmntoptarg___4((char const   *)mnt___2->mnt_opts, "grpjquota");
      }
#line 518
      if (tmp___10) {
#line 519
        return (6);
      }
    }
  }
#line 520
  if (type == 0) {
    {
#line 520
    tmp___11 = hasmntopt((struct mntent  const  *)mnt___2, "quota");
    }
#line 520
    if (tmp___11) {
#line 521
      return (6);
    }
  }
#line 522
  return (-1);
}
}
#line 526 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static int check_fmtfile_ok___4(char *name , int type , int fmt___7 , int flags___7 ) 
{ 
  struct stat st ;
  int *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;
  int fd ;
  int ret ;
  int tmp___4 ;
  int *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  int *tmp___8 ;
  int *tmp___9 ;

  {
#line 528
  if (! flags___7) {
#line 529
    return (1);
  }
#line 530
  if (flags___7 & 1) {
    {
#line 533
    tmp___3 = stat((char const   */* __restrict  */)name, (struct stat */* __restrict  */)(& st));
    }
#line 533
    if (tmp___3 < 0) {
      {
#line 534
      tmp___2 = __errno_location();
      }
#line 534
      if (*tmp___2 != 2) {
        {
#line 535
        tmp = __errno_location();
#line 535
        tmp___0 = strerror(*tmp);
#line 535
        tmp___1 = gettext("Cannot stat quota file %s: %s\n");
#line 535
        errstr(tmp___1, name, tmp___0);
        }
      }
#line 536
      return (0);
    }
  }
#line 539
  if (flags___7 & 2) {
    {
#line 540
    ret = 0;
#line 542
    fd = open((char const   *)name, 0);
    }
#line 542
    if (fd >= 0) {
      {
#line 543
      tmp___4 = is_tree_qfmt(fmt___7);
      }
#line 543
      if (tmp___4) {
        {
#line 544
        ret = (*(quotafile_ops_2.check_file))(fd, type, fmt___7);
        }
      } else {
        {
#line 546
        ret = (*(quotafile_ops_1.check_file))(fd, type, fmt___7);
        }
      }
      {
#line 547
      close(fd);
      }
#line 548
      if (ret <= 0) {
#line 549
        return (0);
      }
    } else {
      {
#line 551
      tmp___8 = __errno_location();
      }
#line 551
      if (*tmp___8 != 2) {
        {
#line 551
        tmp___9 = __errno_location();
        }
#line 551
        if (*tmp___9 != 1) {
          {
#line 552
          tmp___5 = __errno_location();
#line 552
          tmp___6 = strerror(*tmp___5);
#line 552
          tmp___7 = gettext("Cannot open quotafile %s: %s\n");
#line 552
          errstr(tmp___7, name, tmp___6);
          }
#line 553
          return (0);
        }
      }
    }
  }
#line 556
  return (1);
}
}
#line 629 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static int hlist_allocated___4  =    0;
#line 630 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static struct quota_handle **hlist___4  =    (struct quota_handle **)((void *)0);
#line 735 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static int kernel_qfmt_num___4  ;
#line 736 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static int kernel_qfmt___4[6]  ;
#line 828 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static int v1_kern_quota_on___4(char const   *dev , int type ) 
{ 
  char tmp[1024] ;
  qid_t id___0 ;
  __uid_t tmp___0 ;
  __gid_t tmp___1 ;
  __uid_t tmp___2 ;
  long tmp___3 ;

  {
#line 831
  if (type == 0) {
    {
#line 831
    tmp___0 = getuid();
#line 831
    tmp___2 = tmp___0;
    }
  } else {
    {
#line 831
    tmp___1 = getgid();
#line 831
    tmp___2 = tmp___1;
    }
  }
  {
#line 831
  id___0 = tmp___2;
#line 833
  tmp___3 = quotactl((768 << 8) | (type & 255), dev, id___0, tmp);
  }
#line 833
  if (! tmp___3) {
#line 834
    return (1);
  }
#line 835
  return (0);
}
}
#line 839 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static int v2_kern_quota_on___4(char const   *dev , int type ) 
{ 
  char tmp[1024] ;
  qid_t id___0 ;
  __uid_t tmp___0 ;
  __gid_t tmp___1 ;
  __uid_t tmp___2 ;
  long tmp___3 ;

  {
#line 842
  if (type == 0) {
    {
#line 842
    tmp___0 = getuid();
#line 842
    tmp___2 = tmp___0;
    }
  } else {
    {
#line 842
    tmp___1 = getgid();
#line 842
    tmp___2 = tmp___1;
    }
  }
  {
#line 842
  id___0 = tmp___2;
#line 844
  tmp___3 = quotactl((3328 << 8) | (type & 255), dev, id___0, tmp);
  }
#line 844
  if (! tmp___3) {
#line 845
    return (1);
  }
#line 846
  return (0);
}
}
#line 850 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static int xfs_kern_quota_on___4(char const   *dev , int type ) 
{ 
  struct fs_quota_stat info ;
  long tmp ;

  {
  {
#line 854
  tmp = quotactl((((88 << 8) + 5) << 8) | (type & 255), dev, (qid_t )0, (caddr_t )((void *)(& info)));
  }
#line 854
  if (! tmp) {
#line 855
    if (type == 0) {
#line 855
      if ((int )info.qs_flags & 1) {
#line 856
        return (1);
      }
    }
#line 857
    if (type == 1) {
#line 857
      if ((int )info.qs_flags & (1 << 2)) {
#line 858
        return (1);
      }
    }
  }
#line 860
  return (0);
}
}
#line 921 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static int mnt_entries_cnt___4  ;
#line 922 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static struct mount_entry *mnt_entries___4  ;
#line 923 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static int check_dirs_cnt___4  ;
#line 923 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static int act_checked___4  ;
#line 924 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static struct searched_dir *check_dirs___4  ;
#line 927 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static int cache_mnt_table___4(int flags___7 ) 
{ 
  FILE *mntf ;
  struct mntent *mnt___2 ;
  struct stat st ;
  struct statfs fsstat ;
  int allocated ;
  int i ;
  dev_t dev ;
  char mntpointbuf[4096] ;
  int autofsdircnt ;
  int autofsdir_allocated ;
  char **autofsdir ;
  char *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  char const   *devname ;
  char *opt ;
  int qfmt[2] ;
  char *tmp___2 ;
  int slen ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  void *tmp___6 ;
  size_t tmp___7 ;
  void *tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char loopdev[4096] ;
  char *tmp___13 ;
  int *tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;
  int *tmp___18 ;
  char *tmp___19 ;
  char *tmp___20 ;
  int tmp___21 ;
  int *tmp___22 ;
  char *tmp___23 ;
  char *tmp___24 ;
  int tmp___25 ;
  char *tmp___26 ;
  int tmp___27 ;
  int *tmp___28 ;
  char *tmp___29 ;
  char *tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;
  void *tmp___34 ;
  char *tmp___35 ;

  {
  {
#line 933
  allocated = 0;
#line 933
  i = 0;
#line 934
  dev = (dev_t )0;
#line 940
  mntf = setmntent("/proc/mounts", "r");
  }
#line 941
  if (mntf) {
#line 942
    goto alloc;
  }
  {
#line 944
  mntf = setmntent("/etc/mtab", "r");
  }
#line 945
  if (mntf) {
#line 946
    goto alloc;
  }
  {
#line 948
  mntf = setmntent("/etc/fstab", "r");
  }
#line 948
  if (! mntf) {
    {
#line 949
    tmp = gettext("Cannot open any file with mount points.\n");
#line 949
    errstr(tmp);
    }
#line 950
    return (-1);
  }
  alloc: 
  {
#line 954
  tmp___0 = smalloc(sizeof(struct mount_entry ) * 16UL);
#line 954
  mnt_entries___4 = (struct mount_entry *)tmp___0;
#line 955
  mnt_entries_cnt___4 = 0;
#line 956
  allocated += 16;
#line 958
  tmp___1 = smalloc(sizeof(char *) * 16UL);
#line 958
  autofsdir = (char **)tmp___1;
#line 959
  autofsdircnt = 0;
#line 960
  autofsdir_allocated = 16;
  }
  {
#line 961
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 961
    mnt___2 = getmntent(mntf);
    }
#line 961
    if (! mnt___2) {
#line 961
      goto while_break;
    }
    {
#line 966
    devname = get_device_name((char const   *)mnt___2->mnt_fsname);
    }
#line 966
    if (! devname) {
      {
#line 967
      tmp___2 = gettext("Cannot get device name for %s\n");
#line 967
      errstr(tmp___2, mnt___2->mnt_fsname);
      }
#line 968
      goto while_continue;
    }
#line 972
    i = 0;
    {
#line 972
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 972
      if (! (i < autofsdircnt)) {
#line 972
        goto while_break___0;
      }
      {
#line 973
      tmp___3 = strlen((char const   *)*(autofsdir + i));
#line 973
      slen = (int )tmp___3;
#line 975
      tmp___4 = strlen((char const   *)mnt___2->mnt_dir);
      }
#line 975
      if ((size_t )slen <= tmp___4) {
        {
#line 975
        tmp___5 = strncmp((char const   *)*(autofsdir + i), (char const   *)mnt___2->mnt_dir,
                          (size_t )slen);
        }
#line 975
        if (! tmp___5) {
#line 976
          goto while_break___0;
        }
      }
#line 972
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 978
    if (i < autofsdircnt) {
      {
#line 979
      free((void *)((char *)devname));
      }
#line 980
      goto while_continue;
    }
#line 983
    if (flags___7 & 2) {
      {
#line 983
      tmp___9 = strcmp((char const   *)mnt___2->mnt_type, "autofs");
      }
#line 983
      if (! tmp___9) {
#line 984
        if (autofsdircnt == autofsdir_allocated) {
          {
#line 985
          autofsdir_allocated += 16;
#line 986
          tmp___6 = srealloc((void *)autofsdir, (unsigned long )autofsdir_allocated * sizeof(char *));
#line 986
          autofsdir = (char **)tmp___6;
          }
        }
        {
#line 988
        tmp___7 = strlen((char const   *)mnt___2->mnt_dir);
#line 988
        tmp___8 = smalloc(tmp___7 + 2UL);
#line 988
        *(autofsdir + autofsdircnt) = (char *)tmp___8;
#line 989
        strcpy((char */* __restrict  */)*(autofsdir + autofsdircnt), (char const   */* __restrict  */)mnt___2->mnt_dir);
#line 990
        strcat((char */* __restrict  */)*(autofsdir + autofsdircnt), (char const   */* __restrict  */)"/");
#line 991
        autofsdircnt ++;
#line 992
        free((void *)((char *)devname));
        }
#line 993
        goto while_continue;
      }
    }
#line 996
    if (flags___7 & 8) {
      {
#line 996
      tmp___10 = nfs_fstype(mnt___2->mnt_type);
      }
#line 996
      if (tmp___10) {
        {
#line 997
        free((void *)((char *)devname));
        }
#line 998
        goto while_continue;
      }
    }
    {
#line 1000
    tmp___11 = hasmntopt((struct mntent  const  *)mnt___2, "noquota");
    }
#line 1000
    if (tmp___11) {
      {
#line 1001
      free((void *)((char *)devname));
      }
#line 1002
      goto while_continue;
    }
    {
#line 1004
    tmp___12 = hasmntopt((struct mntent  const  *)mnt___2, "bind");
    }
#line 1004
    if (tmp___12) {
      {
#line 1005
      free((void *)((char *)devname));
      }
#line 1006
      goto while_continue;
    }
    {
#line 1008
    opt = hasmntoptarg___4((char const   *)mnt___2->mnt_opts, "loop");
    }
#line 1008
    if (opt) {
      {
#line 1011
      copy_mntoptarg___4(opt, (char const   *)(loopdev), 4096);
#line 1012
      free((void *)((char *)devname));
#line 1013
      tmp___13 = sstrdup((char const   *)(loopdev));
#line 1013
      devname = (char const   *)tmp___13;
      }
    }
    {
#line 1018
    qfmt[0] = hasquota___4(devname, mnt___2, 0, flags___7);
#line 1019
    qfmt[1] = hasquota___4(devname, mnt___2, 1, flags___7);
    }
#line 1020
    if (qfmt[0] < 0) {
#line 1020
      if (qfmt[1] < 0) {
        {
#line 1021
        free((void *)((char *)devname));
        }
#line 1022
        goto while_continue;
      }
    }
    {
#line 1025
    tmp___17 = realpath((char const   */* __restrict  */)mnt___2->mnt_dir, (char */* __restrict  */)(mntpointbuf));
    }
#line 1025
    if (! tmp___17) {
      {
#line 1026
      tmp___14 = __errno_location();
#line 1026
      tmp___15 = strerror(*tmp___14);
#line 1026
      tmp___16 = gettext("Cannot resolve mountpoint path %s: %s\n");
#line 1026
      errstr(tmp___16, mnt___2->mnt_dir, tmp___15);
#line 1027
      free((void *)((char *)devname));
      }
#line 1028
      goto while_continue;
    }
    {
#line 1031
    tmp___21 = statfs((char const   *)(mntpointbuf), & fsstat);
    }
#line 1031
    if (tmp___21 != 0) {
      {
#line 1032
      tmp___18 = __errno_location();
#line 1032
      tmp___19 = strerror(*tmp___18);
#line 1032
      tmp___20 = gettext("Cannot statfs() %s: %s\n");
#line 1032
      errstr(tmp___20, mntpointbuf, tmp___19);
#line 1033
      free((void *)((char *)devname));
      }
#line 1034
      goto while_continue;
    }
#line 1037
    if (fsstat.f_blocks == 0UL) {
#line 1037
      if (fsstat.f_bfree == 0UL) {
#line 1037
        if (fsstat.f_bavail == 0UL) {
          {
#line 1038
          free((void *)((char *)devname));
          }
#line 1039
          goto while_continue;
        }
      }
    }
    {
#line 1042
    tmp___27 = nfs_fstype(mnt___2->mnt_type);
    }
#line 1042
    if (! tmp___27) {
      {
#line 1043
      tmp___25 = stat((char const   */* __restrict  */)devname, (struct stat */* __restrict  */)(& st));
      }
#line 1043
      if (tmp___25 < 0) {
        {
#line 1044
        tmp___22 = __errno_location();
#line 1044
        tmp___23 = strerror(*tmp___22);
#line 1044
        tmp___24 = gettext("Cannot stat() mounted device %s: %s\n");
#line 1044
        errstr(tmp___24, devname, tmp___23);
#line 1045
        free((void *)((char *)devname));
        }
#line 1046
        goto while_continue;
      }
#line 1048
      if (! ((st.st_mode & 61440U) == 24576U)) {
#line 1048
        if (! ((st.st_mode & 61440U) == 8192U)) {
          {
#line 1049
          tmp___26 = gettext("Device (%s) filesystem is mounted on unsupported device type. Skipping.\n");
#line 1049
          errstr(tmp___26, devname);
#line 1050
          free((void *)((char *)devname));
          }
#line 1051
          goto while_continue;
        }
      }
#line 1053
      dev = st.st_rdev;
#line 1054
      i = 0;
      {
#line 1054
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1054
        if (i < mnt_entries_cnt___4) {
#line 1054
          if (! ((mnt_entries___4 + i)->me_dev != dev)) {
#line 1054
            goto while_break___1;
          }
        } else {
#line 1054
          goto while_break___1;
        }
#line 1054
        i ++;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
    {
#line 1057
    tmp___33 = nfs_fstype(mnt___2->mnt_type);
    }
#line 1057
    if (tmp___33) {
#line 1057
      goto _L;
    } else
#line 1057
    if (i == mnt_entries_cnt___4) {
      _L: /* CIL Label */ 
      {
#line 1058
      tmp___31 = stat((char const   */* __restrict  */)mnt___2->mnt_dir, (struct stat */* __restrict  */)(& st));
      }
#line 1058
      if (tmp___31 < 0) {
        {
#line 1059
        tmp___28 = __errno_location();
#line 1059
        tmp___29 = strerror(*tmp___28);
#line 1059
        tmp___30 = gettext("Cannot stat() mountpoint %s: %s\n");
#line 1059
        errstr(tmp___30, mnt___2->mnt_dir, tmp___29);
#line 1060
        free((void *)((char *)devname));
        }
#line 1061
        goto while_continue;
      }
      {
#line 1063
      tmp___32 = nfs_fstype(mnt___2->mnt_type);
      }
#line 1063
      if (tmp___32) {
#line 1065
        dev = st.st_dev;
#line 1066
        if (! (flags___7 & 32)) {
#line 1067
          i = 0;
          {
#line 1067
          while (1) {
            while_continue___2: /* CIL Label */ ;
#line 1067
            if (i < mnt_entries_cnt___4) {
#line 1067
              if (! ((mnt_entries___4 + i)->me_dev != dev)) {
#line 1067
                goto while_break___2;
              }
            } else {
#line 1067
              goto while_break___2;
            }
#line 1067
            i ++;
          }
          while_break___2: /* CIL Label */ ;
          }
        } else {
#line 1070
          i = mnt_entries_cnt___4;
        }
      }
    }
#line 1073
    if (i == mnt_entries_cnt___4) {
#line 1074
      if (allocated == mnt_entries_cnt___4) {
        {
#line 1075
        allocated += 16;
#line 1076
        tmp___34 = srealloc((void *)mnt_entries___4, (unsigned long )allocated * sizeof(struct mount_entry ));
#line 1076
        mnt_entries___4 = (struct mount_entry *)tmp___34;
        }
      }
      {
#line 1078
      (mnt_entries___4 + i)->me_type = sstrdup((char const   *)mnt___2->mnt_type);
#line 1079
      (mnt_entries___4 + i)->me_opts = sstrdup((char const   *)mnt___2->mnt_opts);
#line 1080
      (mnt_entries___4 + i)->me_dev = dev;
#line 1081
      (mnt_entries___4 + i)->me_ino = st.st_ino;
#line 1082
      (mnt_entries___4 + i)->me_devname = devname;
#line 1083
      tmp___35 = sstrdup((char const   *)(mntpointbuf));
#line 1083
      (mnt_entries___4 + i)->me__dir = (char const   *)tmp___35;
#line 1084
      (mnt_entries___4 + i)->me_dir = (char const   *)((void *)0);
#line 1085
      memcpy((void */* __restrict  */)(& (mnt_entries___4 + i)->me_qfmt), (void const   */* __restrict  */)(qfmt),
             sizeof(qfmt));
#line 1086
      mnt_entries_cnt___4 ++;
      }
    } else {
      {
#line 1089
      free((void *)((char *)devname));
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1091
  endmntent(mntf);
#line 1093
  i = 0;
  }
  {
#line 1093
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 1093
    if (! (i < autofsdircnt)) {
#line 1093
      goto while_break___3;
    }
    {
#line 1094
    free((void *)*(autofsdir + i));
#line 1093
    i ++;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 1095
  free((void *)autofsdir);
  }
#line 1096
  return (0);
}
}
#line 1100 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static char const   *find_dir_mntpoint___4(struct stat *st ) 
{ 
  int i ;

  {
#line 1104
  i = 0;
  {
#line 1104
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1104
    if (! (i < mnt_entries_cnt___4)) {
#line 1104
      goto while_break;
    }
#line 1105
    if ((mnt_entries___4 + i)->me_dev == st->st_dev) {
#line 1106
      st->st_ino = (mnt_entries___4 + i)->me_ino;
#line 1107
      return ((mnt_entries___4 + i)->me__dir);
    }
#line 1104
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1109
  return ((char const   *)((void *)0));
}
}
#line 1113 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static int process_dirs___4(int dcnt , char **dirs , int flags___7 ) 
{ 
  struct stat st ;
  int i ;
  char mntpointbuf[4096] ;
  void *tmp ;
  char *devname ;
  char const   *tmp___0 ;
  char *tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  int *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  char const   *realmnt ;
  char *tmp___12 ;
  int *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  int mentry ;
  char *tmp___17 ;
  char *tmp___18 ;
  char *tmp___19 ;
  char *tmp___20 ;

  {
#line 1119
  check_dirs_cnt___4 = 0;
#line 1120
  act_checked___4 = -1;
#line 1121
  if (dcnt) {
    {
#line 1122
    tmp = smalloc(sizeof(struct searched_dir ) * (unsigned long )dcnt);
#line 1122
    check_dirs___4 = (struct searched_dir *)tmp;
#line 1123
    i = 0;
    }
    {
#line 1123
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1123
      if (! (i < dcnt)) {
#line 1123
        goto while_break;
      }
      {
#line 1124
      tmp___10 = strncmp((char const   *)*(dirs + i), "UUID=", (size_t )5);
      }
#line 1124
      if (tmp___10) {
        {
#line 1124
        tmp___11 = strncmp((char const   *)*(dirs + i), "LABEL=", (size_t )6);
        }
#line 1124
        if (tmp___11) {
          {
#line 1139
          tmp___9 = stat((char const   */* __restrict  */)*(dirs + i), (struct stat */* __restrict  */)(& st));
          }
#line 1139
          if (tmp___9 < 0) {
            {
#line 1140
            tmp___6 = __errno_location();
#line 1140
            tmp___7 = strerror(*tmp___6);
#line 1140
            tmp___8 = gettext("Cannot stat() given mountpoint %s: %s\nSkipping...\n");
#line 1140
            errstr(tmp___8, *(dirs + i), tmp___7);
            }
#line 1141
            goto __Cont;
          }
        } else {
          _L: /* CIL Label */ 
          {
#line 1125
          tmp___0 = get_device_name((char const   *)*(dirs + i));
#line 1125
          devname = (char *)tmp___0;
          }
#line 1127
          if (! devname) {
            {
#line 1128
            tmp___1 = gettext("Cannot find a device with %s.\nSkipping...\n");
#line 1128
            errstr(tmp___1, *(dirs + i));
            }
#line 1129
            goto __Cont;
          }
          {
#line 1131
          tmp___5 = stat((char const   */* __restrict  */)devname, (struct stat */* __restrict  */)(& st));
          }
#line 1131
          if (tmp___5 < 0) {
            {
#line 1132
            tmp___2 = __errno_location();
#line 1132
            tmp___3 = strerror(*tmp___2);
#line 1132
            tmp___4 = gettext("Cannot stat() a mountpoint with %s: %s\nSkipping...\n");
#line 1132
            errstr(tmp___4, *(dirs + i), tmp___3);
#line 1133
            free((void *)devname);
            }
#line 1134
            goto __Cont;
          }
          {
#line 1136
          free((void *)devname);
          }
        }
      } else {
#line 1124
        goto _L;
      }
#line 1143
      (check_dirs___4 + check_dirs_cnt___4)->sd_dir = (st.st_mode & 61440U) == 16384U;
#line 1144
      if ((st.st_mode & 61440U) == 16384U) {
#line 1145
        realmnt = (char const   *)*(dirs + i);
#line 1148
        if (flags___7 & 1) {
          {
#line 1148
          realmnt = find_dir_mntpoint___4(& st);
          }
#line 1148
          if (! realmnt) {
#line 1149
            if (! (flags___7 & 4)) {
              {
#line 1150
              tmp___12 = gettext("Cannot find a filesystem mountpoint for directory %s\n");
#line 1150
              errstr(tmp___12, *(dirs + i));
              }
            }
#line 1151
            goto __Cont;
          }
        }
        {
#line 1153
        (check_dirs___4 + check_dirs_cnt___4)->sd_dev = st.st_dev;
#line 1154
        (check_dirs___4 + check_dirs_cnt___4)->sd_ino = st.st_ino;
#line 1155
        tmp___16 = realpath((char const   */* __restrict  */)realmnt, (char */* __restrict  */)(mntpointbuf));
        }
#line 1155
        if (! tmp___16) {
          {
#line 1156
          tmp___13 = __errno_location();
#line 1156
          tmp___14 = strerror(*tmp___13);
#line 1156
          tmp___15 = gettext("Cannot resolve path %s: %s\n");
#line 1156
          errstr(tmp___15, realmnt, tmp___14);
          }
#line 1157
          goto __Cont;
        }
      } else
#line 1160
      if ((st.st_mode & 61440U) == 24576U) {
#line 1160
        goto _L___0;
      } else
#line 1160
      if ((st.st_mode & 61440U) == 8192U) {
        _L___0: /* CIL Label */ 
#line 1163
        (check_dirs___4 + check_dirs_cnt___4)->sd_dev = st.st_rdev;
#line 1164
        mentry = 0;
        {
#line 1164
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 1164
          if (mentry < mnt_entries_cnt___4) {
#line 1164
            if (! ((mnt_entries___4 + mentry)->me_dev != st.st_rdev)) {
#line 1164
              goto while_break___0;
            }
          } else {
#line 1164
            goto while_break___0;
          }
#line 1164
          mentry ++;
        }
        while_break___0: /* CIL Label */ ;
        }
#line 1165
        if (mentry == mnt_entries_cnt___4) {
#line 1166
          if (! (flags___7 & 4)) {
            {
#line 1167
            tmp___17 = gettext("Cannot find mountpoint for device %s\n");
#line 1167
            errstr(tmp___17, *(dirs + i));
            }
          }
#line 1168
          goto __Cont;
        }
        {
#line 1170
        sstrncpy(mntpointbuf, (mnt_entries___4 + mentry)->me__dir, (size_t )4095);
        }
      } else {
        {
#line 1173
        tmp___18 = gettext("Specified path %s is not directory nor device.\n");
#line 1173
        errstr(tmp___18, *(dirs + i));
        }
#line 1174
        goto __Cont;
      }
      {
#line 1176
      tmp___19 = sstrdup((char const   *)(mntpointbuf));
#line 1176
      (check_dirs___4 + check_dirs_cnt___4)->sd_name = (char const   *)tmp___19;
#line 1177
      check_dirs_cnt___4 ++;
      }
      __Cont: /* CIL Label */ 
#line 1123
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 1179
    if (! check_dirs_cnt___4) {
#line 1180
      if (! (flags___7 & 4)) {
        {
#line 1181
        tmp___20 = gettext("No correct mountpoint specified.\n");
#line 1181
        errstr(tmp___20);
        }
      }
      {
#line 1182
      free((void *)check_dirs___4);
      }
#line 1183
      return (-1);
    }
  }
#line 1186
  return (0);
}
}
#line 1204 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static int find_next_entry_all___4(int *pos ) 
{ 
  char *tmp ;

  {
  {
#line 1206
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1206
    act_checked___4 ++;
#line 1206
    if (! (act_checked___4 < mnt_entries_cnt___4)) {
#line 1206
      goto while_break;
    }
    {
#line 1207
    tmp = str_hasmntopt((char const   *)(mnt_entries___4 + act_checked___4)->me_opts,
                        "noauto");
    }
#line 1207
    if (! tmp) {
#line 1208
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1210
  if (act_checked___4 >= mnt_entries_cnt___4) {
#line 1211
    return (0);
  }
#line 1212
  *pos = act_checked___4;
#line 1213
  return (1);
}
}
#line 1217 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static int find_next_entry_sel___4(int *pos ) 
{ 
  int i ;
  struct searched_dir *sd ;
  char *tmp ;

  {
  restart: 
#line 1223
  act_checked___4 ++;
#line 1223
  if (act_checked___4 == check_dirs_cnt___4) {
#line 1224
    return (0);
  }
#line 1225
  sd = check_dirs___4 + act_checked___4;
#line 1226
  i = 0;
  {
#line 1226
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1226
    if (! (i < mnt_entries_cnt___4)) {
#line 1226
      goto while_break;
    }
#line 1227
    if (sd->sd_dir) {
#line 1228
      if (sd->sd_dev == (mnt_entries___4 + i)->me_dev) {
#line 1228
        if (sd->sd_ino == (mnt_entries___4 + i)->me_ino) {
#line 1229
          goto while_break;
        }
      }
    } else
#line 1232
    if (sd->sd_dev == (mnt_entries___4 + i)->me_dev) {
#line 1233
      goto while_break;
    }
#line 1226
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1235
  if (i == mnt_entries_cnt___4) {
    {
#line 1236
    tmp = gettext("Mountpoint (or device) %s not found or has no quota enabled.\n");
#line 1236
    errstr(tmp, sd->sd_name);
    }
#line 1237
    goto restart;
  }
#line 1239
  *pos = i;
#line 1240
  return (1);
}
}
#line 23 "/home/wheatley/newnew/temp/quota-4.01/common.c"
static int enable_syslog___5  =    0;
#line 31 "/home/wheatley/newnew/temp/quota-4.01/common.c"
static void do_syslog___5(int level , char const   *format , va_list args ) 
{ 
  char buf[1024] ;
  int i ;
  int j ;
  int tmp ;

  {
  {
#line 36
  vsnprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)format,
            args);
#line 39
  i = 0;
  }
  {
#line 39
  while (1) {
    while_continue: /* CIL Label */ ;
#line 39
    if (! buf[i]) {
#line 39
      goto while_break;
    }
#line 40
    j = i;
    {
#line 40
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 40
      if (buf[j]) {
#line 40
        if (! ((int )buf[j] != 10)) {
#line 40
          goto while_break___0;
        }
      } else {
#line 40
        goto while_break___0;
      }
#line 40
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 41
    if ((int )buf[j] == 10) {
#line 42
      tmp = j;
#line 42
      j ++;
#line 42
      buf[tmp] = (char )'\000';
    }
    {
#line 43
    syslog(level, "%s", buf + i);
#line 39
    i = j;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 45
  return;
}
}
#line 18 "/home/wheatley/newnew/temp/quota-4.01/quotaio_rpc.c"
static int rpc_init_io___4(struct quota_handle *h ) ;
#line 19
static struct dquot *rpc_read_dquot___4(struct quota_handle *h , qid_t id___0 ) ;
#line 20
static int rpc_commit_dquot___4(struct dquot *dquot , int flags___7 ) ;
#line 31 "/home/wheatley/newnew/temp/quota-4.01/quotaio_rpc.c"
static int rpc_init_io___4(struct quota_handle *h ) 
{ 


  {
#line 34
  h->qh_info.dqi_max_b_limit = (uint64_t )(~ ((uint32_t )0));
#line 35
  h->qh_info.dqi_max_i_limit = (uint64_t )(~ ((uint32_t )0));
#line 36
  h->qh_info.dqi_max_b_usage = (uint64_t )(4294967295U << 10);
#line 37
  h->qh_info.dqi_max_i_usage = (uint64_t )(~ ((uint32_t )0));
#line 38
  return (0);
}
}
#line 47 "/home/wheatley/newnew/temp/quota-4.01/quotaio_rpc.c"
static struct dquot *rpc_read_dquot___4(struct quota_handle *h , qid_t id___0 ) 
{ 
  struct dquot *dquot ;
  struct dquot *tmp ;
  int ret ;
  int *tmp___0 ;

  {
  {
#line 50
  tmp = get_empty_dquot();
#line 50
  dquot = tmp;
#line 53
  dquot->dq_id = id___0;
#line 54
  dquot->dq_h = h;
#line 55
  ret = rpc_rquota_get(dquot);
  }
#line 55
  if (ret < 0) {
    {
#line 56
    tmp___0 = __errno_location();
#line 56
    *tmp___0 = - ret;
#line 57
    free((void *)dquot);
    }
#line 58
    return ((struct dquot *)((void *)0));
  }
#line 60
  return (dquot);
}
}
#line 70 "/home/wheatley/newnew/temp/quota-4.01/quotaio_rpc.c"
static int rpc_commit_dquot___4(struct dquot *dquot , int flags___7 ) 
{ 
  int ret ;
  char *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;

  {
#line 75
  if ((dquot->dq_h)->qh_io_flags & 4) {
    {
#line 76
    tmp = gettext("Trying to write quota to readonly quotafile on %s\n");
#line 76
    errstr(tmp, (dquot->dq_h)->qh_quotadev);
#line 77
    tmp___0 = __errno_location();
#line 77
    *tmp___0 = 1;
    }
#line 78
    return (-1);
  }
  {
#line 80
  ret = rpc_rquota_set((1024 << 8) | ((dquot->dq_h)->qh_type & 255), dquot);
  }
#line 80
  if (ret < 0) {
    {
#line 81
    tmp___1 = __errno_location();
#line 81
    *tmp___1 = - ret;
    }
#line 82
    return (-1);
  }
#line 84
  return (0);
}
}
#line 45 "/home/wheatley/newnew/temp/quota-4.01/quotaio_tree.c"
static int get_index___4(qid_t id___0 , int depth ) 
{ 


  {
#line 47
  return ((int )((id___0 >> ((4 - depth) - 1) * 8) & 255U));
}
}
#line 51 "/home/wheatley/newnew/temp/quota-4.01/quotaio_tree.c"
static void read_blk___4(struct quota_handle *h , uint blk , dqbuf_t buf ) 
{ 
  int err ;
  ssize_t tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 55
  lseek(h->qh_fd, (__off64_t )(blk << 10), 0);
#line 56
  tmp = read(h->qh_fd, (void *)buf, (size_t )(1 << 10));
#line 56
  err = (int )tmp;
  }
#line 57
  if (err < 0) {
    {
#line 58
    tmp___0 = __errno_location();
#line 58
    tmp___1 = strerror(*tmp___0);
#line 58
    tmp___2 = gettext("Cannot read block %u: %s\n");
#line 58
    die(2, tmp___2, blk, tmp___1);
    }
  } else
#line 59
  if (err != 1 << 10) {
    {
#line 60
    memset((void *)(buf + err), 0, (size_t )((1 << 10) - err));
    }
  }
#line 61
  return;
}
}
#line 64 "/home/wheatley/newnew/temp/quota-4.01/quotaio_tree.c"
static int write_blk___4(struct quota_handle *h , uint blk , dqbuf_t buf ) 
{ 
  int err ;
  ssize_t tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  int *tmp___3 ;

  {
  {
#line 68
  lseek(h->qh_fd, (__off64_t )(blk << 10), 0);
#line 69
  tmp = write(h->qh_fd, (void const   *)buf, (size_t )(1 << 10));
#line 69
  err = (int )tmp;
  }
#line 70
  if (err < 0) {
    {
#line 70
    tmp___3 = __errno_location();
    }
#line 70
    if (*tmp___3 != 28) {
      {
#line 71
      tmp___0 = __errno_location();
#line 71
      tmp___1 = strerror(*tmp___0);
#line 71
      tmp___2 = gettext("Cannot write block (%u): %s\n");
#line 71
      die(2, tmp___2, blk, tmp___1);
      }
    }
  }
#line 72
  if (err != 1 << 10) {
#line 73
    return (-28);
  }
#line 74
  return (0);
}
}
#line 78 "/home/wheatley/newnew/temp/quota-4.01/quotaio_tree.c"
static int get_free_dqblk___4(struct quota_handle *h ) 
{ 
  dqbuf_t buf ;
  void *tmp ;
  struct qt_disk_dqdbheader *dh ;
  struct qtree_mem_dqinfo *info ;
  int blk ;
  char *tmp___0 ;
  int tmp___1 ;
  unsigned int tmp___2 ;

  {
  {
#line 80
  tmp = smalloc((size_t )(1 << 10));
#line 80
  buf = (dqbuf_t )tmp;
#line 81
  dh = (struct qt_disk_dqdbheader *)buf;
#line 82
  info = & h->qh_info.u.v2_mdqi.dqi_qtree;
  }
#line 85
  if (info->dqi_free_blk) {
    {
#line 86
    blk = (int )info->dqi_free_blk;
#line 87
    read_blk___4(h, (uint )blk, buf);
#line 88
    info->dqi_free_blk = dh->dqdh_next_free;
    }
  } else {
    {
#line 91
    memset((void *)buf, 0, (size_t )(1 << 10));
#line 92
    tmp___1 = write_blk___4(h, info->dqi_blocks, buf);
    }
#line 92
    if (tmp___1 < 0) {
      {
#line 93
      free((void *)buf);
#line 94
      tmp___0 = gettext("Cannot allocate new quota block (out of disk space).\n");
#line 94
      errstr(tmp___0);
      }
#line 95
      return (-28);
    }
#line 97
    tmp___2 = info->dqi_blocks;
#line 97
    (info->dqi_blocks) ++;
#line 97
    blk = (int )tmp___2;
  }
  {
#line 99
  mark_quotafile_info_dirty(h);
#line 100
  free((void *)buf);
  }
#line 101
  return (blk);
}
}
#line 105 "/home/wheatley/newnew/temp/quota-4.01/quotaio_tree.c"
static void put_free_dqblk___4(struct quota_handle *h , dqbuf_t buf , uint blk ) 
{ 
  struct qt_disk_dqdbheader *dh ;
  struct qtree_mem_dqinfo *info ;

  {
  {
#line 107
  dh = (struct qt_disk_dqdbheader *)buf;
#line 108
  info = & h->qh_info.u.v2_mdqi.dqi_qtree;
#line 110
  dh->dqdh_next_free = info->dqi_free_blk;
#line 111
  dh->dqdh_prev_free = (__u32 )0;
#line 112
  dh->dqdh_entries = (__u16 )0;
#line 113
  info->dqi_free_blk = blk;
#line 114
  mark_quotafile_info_dirty(h);
#line 115
  write_blk___4(h, blk, buf);
  }
#line 116
  return;
}
}
#line 119 "/home/wheatley/newnew/temp/quota-4.01/quotaio_tree.c"
static void remove_free_dqentry___4(struct quota_handle *h , dqbuf_t buf , uint blk ) 
{ 
  dqbuf_t tmpbuf ;
  void *tmp ;
  struct qt_disk_dqdbheader *dh ;
  uint nextblk ;
  uint prevblk ;
  u_int32_t tmp___0 ;

  {
  {
#line 121
  tmp = smalloc((size_t )(1 << 10));
#line 121
  tmpbuf = (dqbuf_t )tmp;
#line 122
  dh = (struct qt_disk_dqdbheader *)buf;
#line 123
  nextblk = dh->dqdh_next_free;
#line 123
  prevblk = dh->dqdh_prev_free;
  }
#line 127
  if (nextblk) {
    {
#line 128
    read_blk___4(h, nextblk, tmpbuf);
#line 129
    ((struct qt_disk_dqdbheader *)tmpbuf)->dqdh_prev_free = dh->dqdh_prev_free;
#line 130
    write_blk___4(h, nextblk, tmpbuf);
    }
  }
#line 132
  if (prevblk) {
    {
#line 133
    read_blk___4(h, prevblk, tmpbuf);
#line 134
    ((struct qt_disk_dqdbheader *)tmpbuf)->dqdh_next_free = dh->dqdh_next_free;
#line 135
    write_blk___4(h, prevblk, tmpbuf);
    }
  } else {
    {
#line 138
    h->qh_info.u.v2_mdqi.dqi_qtree.dqi_free_entry = nextblk;
#line 139
    mark_quotafile_info_dirty(h);
    }
  }
  {
#line 141
  free((void *)tmpbuf);
#line 142
  tmp___0 = (__u32 )0;
#line 142
  dh->dqdh_prev_free = tmp___0;
#line 142
  dh->dqdh_next_free = tmp___0;
#line 143
  write_blk___4(h, blk, buf);
  }
#line 144
  return;
}
}
#line 147 "/home/wheatley/newnew/temp/quota-4.01/quotaio_tree.c"
static void insert_free_dqentry___4(struct quota_handle *h , dqbuf_t buf , uint blk ) 
{ 
  dqbuf_t tmpbuf ;
  void *tmp ;
  struct qt_disk_dqdbheader *dh ;
  struct qtree_mem_dqinfo *info ;

  {
  {
#line 149
  tmp = smalloc((size_t )(1 << 10));
#line 149
  tmpbuf = (dqbuf_t )tmp;
#line 150
  dh = (struct qt_disk_dqdbheader *)buf;
#line 151
  info = & h->qh_info.u.v2_mdqi.dqi_qtree;
#line 153
  dh->dqdh_next_free = info->dqi_free_entry;
#line 154
  dh->dqdh_prev_free = (__u32 )0;
#line 155
  write_blk___4(h, blk, buf);
  }
#line 156
  if (info->dqi_free_entry) {
    {
#line 157
    read_blk___4(h, info->dqi_free_entry, tmpbuf);
#line 158
    ((struct qt_disk_dqdbheader *)tmpbuf)->dqdh_prev_free = blk;
#line 159
    write_blk___4(h, info->dqi_free_entry, tmpbuf);
    }
  }
  {
#line 161
  free((void *)tmpbuf);
#line 162
  info->dqi_free_entry = blk;
#line 163
  mark_quotafile_info_dirty(h);
  }
#line 164
  return;
}
}
#line 167 "/home/wheatley/newnew/temp/quota-4.01/quotaio_tree.c"
static uint find_free_dqentry___4(struct quota_handle *h , struct dquot *dquot , int *err ) 
{ 
  int blk ;
  int i ;
  struct qt_disk_dqdbheader *dh ;
  struct qtree_mem_dqinfo *info ;
  char *ddquot ;
  dqbuf_t buf ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;

  {
  {
#line 171
  info = & h->qh_info.u.v2_mdqi.dqi_qtree;
#line 175
  *err = 0;
#line 176
  tmp = smalloc((size_t )(1 << 10));
#line 176
  buf = (dqbuf_t )tmp;
#line 177
  dh = (struct qt_disk_dqdbheader *)buf;
  }
#line 178
  if (info->dqi_free_entry) {
    {
#line 179
    blk = (int )info->dqi_free_entry;
#line 180
    read_blk___4(h, (uint )blk, buf);
    }
  } else {
    {
#line 183
    blk = get_free_dqblk___4(h);
    }
#line 184
    if (blk < 0) {
      {
#line 185
      free((void *)buf);
#line 186
      *err = blk;
      }
#line 187
      return ((uint )0);
    }
    {
#line 189
    memset((void *)buf, 0, (size_t )(1 << 10));
#line 190
    info->dqi_free_entry = (unsigned int )blk;
#line 191
    mark_quotafile_info_dirty(h);
    }
  }
  {
#line 193
  tmp___0 = qtree_dqstr_in_blk(info);
  }
#line 193
  if ((int )dh->dqdh_entries + 1 >= tmp___0) {
    {
#line 194
    remove_free_dqentry___4(h, buf, (uint )blk);
    }
  }
#line 195
  dh->dqdh_entries = (__u16 )((int )dh->dqdh_entries + 1);
#line 197
  ddquot = buf + sizeof(struct qt_disk_dqdbheader );
#line 198
  i = 0;
  {
#line 198
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 198
    tmp___1 = qtree_dqstr_in_blk(info);
    }
#line 198
    if (i < tmp___1) {
      {
#line 198
      tmp___2 = qtree_entry_unused(info, ddquot);
      }
#line 198
      if (tmp___2) {
#line 198
        goto while_break;
      }
    } else {
#line 198
      goto while_break;
    }
#line 198
    i ++;
#line 198
    ddquot += info->dqi_entry_size;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 201
  tmp___4 = qtree_dqstr_in_blk(info);
  }
#line 201
  if (i == tmp___4) {
    {
#line 202
    tmp___3 = gettext("find_free_dqentry(): Data block full but it shouldn\'t.\n");
#line 202
    die(2, tmp___3);
    }
  }
  {
#line 203
  write_blk___4(h, (uint )blk, buf);
#line 204
  dquot->dq_dqb.u.v2_mdqb.dqb_off = (loff_t )(((unsigned long )(blk << 10) + sizeof(struct qt_disk_dqdbheader )) + (unsigned long )((unsigned int )i * info->dqi_entry_size));
#line 207
  free((void *)buf);
  }
#line 208
  return ((uint )blk);
}
}
#line 212 "/home/wheatley/newnew/temp/quota-4.01/quotaio_tree.c"
static int do_insert_tree___4(struct quota_handle *h , struct dquot *dquot , uint *treeblk ,
                              int depth ) 
{ 
  dqbuf_t buf ;
  int newson ;
  int newact ;
  u_int32_t *ref ;
  uint newblk ;
  int ret ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;

  {
  {
#line 215
  newson = 0;
#line 215
  newact = 0;
#line 218
  ret = 0;
#line 220
  tmp = smalloc((size_t )(1 << 10));
#line 220
  buf = (dqbuf_t )tmp;
  }
#line 221
  if (! *treeblk) {
    {
#line 222
    ret = get_free_dqblk___4(h);
    }
#line 223
    if (ret < 0) {
#line 224
      goto out_buf;
    }
    {
#line 225
    *treeblk = (uint )ret;
#line 226
    memset((void *)buf, 0, (size_t )(1 << 10));
#line 227
    newact = 1;
    }
  } else {
    {
#line 230
    read_blk___4(h, *treeblk, buf);
    }
  }
  {
#line 231
  ref = (u_int32_t *)buf;
#line 232
  tmp___0 = get_index___4(dquot->dq_id, depth);
#line 232
  newblk = *(ref + tmp___0);
  }
#line 233
  if (! newblk) {
#line 234
    newson = 1;
  }
#line 235
  if (depth == 3) {
#line 236
    if (newblk) {
      {
#line 237
      tmp___1 = get_index___4(dquot->dq_id, depth);
#line 237
      tmp___2 = gettext("Inserting already present quota entry (block %u).\n");
#line 237
      die(2, tmp___2, *(ref + tmp___1));
      }
    }
    {
#line 239
    newblk = find_free_dqentry___4(h, dquot, & ret);
    }
  } else {
    {
#line 242
    ret = do_insert_tree___4(h, dquot, & newblk, depth + 1);
    }
  }
#line 243
  if (newson) {
#line 243
    if (ret >= 0) {
      {
#line 244
      tmp___3 = get_index___4(dquot->dq_id, depth);
#line 244
      *(ref + tmp___3) = newblk;
#line 245
      write_blk___4(h, *treeblk, buf);
      }
    } else {
#line 243
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 247
  if (newact) {
#line 247
    if (ret < 0) {
      {
#line 248
      put_free_dqblk___4(h, buf, *treeblk);
      }
    }
  }
  out_buf: 
  {
#line 250
  free((void *)buf);
  }
#line 251
  return (ret);
}
}
#line 255 "/home/wheatley/newnew/temp/quota-4.01/quotaio_tree.c"
static void dq_insert_tree___4(struct quota_handle *h , struct dquot *dquot ) 
{ 
  uint tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;

  {
  {
#line 257
  tmp = (uint )1;
#line 259
  tmp___3 = do_insert_tree___4(h, dquot, & tmp, 0);
  }
#line 259
  if (tmp___3 < 0) {
    {
#line 260
    tmp___0 = __errno_location();
#line 260
    tmp___1 = strerror(*tmp___0);
#line 260
    tmp___2 = gettext("Cannot write quota (id %u): %s\n");
#line 260
    die(2, tmp___2, dquot->dq_id, tmp___1);
    }
  }
#line 261
  return;
}
}
#line 284 "/home/wheatley/newnew/temp/quota-4.01/quotaio_tree.c"
static void free_dqentry___4(struct quota_handle *h , struct dquot *dquot , uint blk ) 
{ 
  struct qt_disk_dqdbheader *dh ;
  struct qtree_mem_dqinfo *info ;
  dqbuf_t buf ;
  void *tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 287
  info = & h->qh_info.u.v2_mdqi.dqi_qtree;
#line 288
  tmp = smalloc((size_t )(1 << 10));
#line 288
  buf = (dqbuf_t )tmp;
  }
#line 290
  if (dquot->dq_dqb.u.v2_mdqb.dqb_off >> 10 != (loff_t )blk) {
    {
#line 291
    tmp___0 = gettext("Quota structure has offset to other block (%u) than it should (%u).\n");
#line 291
    die(2, tmp___0, blk, (uint )(dquot->dq_dqb.u.v2_mdqb.dqb_off >> 10));
    }
  }
  {
#line 293
  read_blk___4(h, blk, buf);
#line 294
  dh = (struct qt_disk_dqdbheader *)buf;
#line 295
  dh->dqdh_entries = (__u16 )((int )dh->dqdh_entries - 1);
  }
#line 296
  if (! dh->dqdh_entries) {
    {
#line 297
    remove_free_dqentry___4(h, buf, blk);
#line 298
    put_free_dqblk___4(h, buf, blk);
    }
  } else {
    {
#line 301
    memset((void *)(buf + (dquot->dq_dqb.u.v2_mdqb.dqb_off & (long )((1 << 10) - 1))),
           0, (size_t )info->dqi_entry_size);
#line 304
    tmp___1 = qtree_dqstr_in_blk(info);
    }
#line 304
    if ((int )dh->dqdh_entries == tmp___1 - 1) {
      {
#line 305
      insert_free_dqentry___4(h, buf, blk);
      }
    } else {
      {
#line 307
      write_blk___4(h, blk, buf);
      }
    }
  }
  {
#line 309
  dquot->dq_dqb.u.v2_mdqb.dqb_off = (loff_t )0;
#line 310
  free((void *)buf);
  }
#line 311
  return;
}
}
#line 314 "/home/wheatley/newnew/temp/quota-4.01/quotaio_tree.c"
static void remove_tree___4(struct quota_handle *h , struct dquot *dquot , uint *blk ,
                            int depth ) 
{ 
  dqbuf_t buf ;
  void *tmp ;
  uint newblk ;
  u_int32_t *ref ;
  int tmp___0 ;
  int i ;
  int tmp___1 ;

  {
  {
#line 316
  tmp = smalloc((size_t )(1 << 10));
#line 316
  buf = (dqbuf_t )tmp;
#line 318
  ref = (u_int32_t *)buf;
#line 320
  read_blk___4(h, *blk, buf);
#line 321
  tmp___0 = get_index___4(dquot->dq_id, depth);
#line 321
  newblk = *(ref + tmp___0);
  }
#line 322
  if (depth == 3) {
    {
#line 323
    free_dqentry___4(h, dquot, newblk);
#line 324
    newblk = (uint )0;
    }
  } else {
    {
#line 327
    remove_tree___4(h, dquot, & newblk, depth + 1);
    }
  }
#line 328
  if (! newblk) {
    {
#line 331
    tmp___1 = get_index___4(dquot->dq_id, depth);
#line 331
    *(ref + tmp___1) = (__u32 )0;
#line 332
    i = 0;
    }
    {
#line 332
    while (1) {
      while_continue: /* CIL Label */ ;
#line 332
      if (i < 1 << 10) {
#line 332
        if (! (! *(buf + i))) {
#line 332
          goto while_break;
        }
      } else {
#line 332
        goto while_break;
      }
#line 332
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 334
    if (i == 1 << 10) {
#line 334
      if (*blk != 1U) {
        {
#line 335
        put_free_dqblk___4(h, buf, *blk);
#line 336
        *blk = (uint )0;
        }
      } else {
        {
#line 339
        write_blk___4(h, *blk, buf);
        }
      }
    } else {
      {
#line 339
      write_blk___4(h, *blk, buf);
      }
    }
  }
  {
#line 341
  free((void *)buf);
  }
#line 342
  return;
}
}
#line 355 "/home/wheatley/newnew/temp/quota-4.01/quotaio_tree.c"
static loff_t find_block_dqentry___4(struct quota_handle *h , struct dquot *dquot ,
                                     uint blk ) 
{ 
  struct qtree_mem_dqinfo *info ;
  dqbuf_t buf ;
  void *tmp ;
  int i ;
  char *ddquot ;
  int tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;

  {
  {
#line 357
  info = & h->qh_info.u.v2_mdqi.dqi_qtree;
#line 358
  tmp = smalloc((size_t )(1 << 10));
#line 358
  buf = (dqbuf_t )tmp;
#line 360
  ddquot = buf + sizeof(struct qt_disk_dqdbheader );
#line 362
  read_blk___4(h, blk, buf);
#line 363
  i = 0;
  }
  {
#line 363
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 363
    tmp___0 = qtree_dqstr_in_blk(info);
    }
#line 363
    if (i < tmp___0) {
      {
#line 363
      tmp___1 = (*((info->dqi_ops)->is_id))((void *)ddquot, dquot);
      }
#line 363
      if (tmp___1) {
#line 363
        goto while_break;
      }
    } else {
#line 363
      goto while_break;
    }
#line 363
    i ++;
#line 363
    ddquot += info->dqi_entry_size;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 366
  tmp___3 = qtree_dqstr_in_blk(info);
  }
#line 366
  if (i == tmp___3) {
    {
#line 367
    tmp___2 = gettext("Quota for id %u referenced but not present.\n");
#line 367
    die(2, tmp___2, dquot->dq_id);
    }
  }
  {
#line 368
  free((void *)buf);
  }
#line 369
  return ((loff_t )(((unsigned long )(blk << 10) + sizeof(struct qt_disk_dqdbheader )) + (unsigned long )((unsigned int )i * info->dqi_entry_size)));
}
}
#line 374 "/home/wheatley/newnew/temp/quota-4.01/quotaio_tree.c"
static loff_t find_tree_dqentry___4(struct quota_handle *h , struct dquot *dquot ,
                                    uint blk , int depth ) 
{ 
  dqbuf_t buf ;
  void *tmp ;
  loff_t ret ;
  u_int32_t *ref ;
  int tmp___0 ;

  {
  {
#line 376
  tmp = smalloc((size_t )(1 << 10));
#line 376
  buf = (dqbuf_t )tmp;
#line 377
  ret = (loff_t )0;
#line 378
  ref = (u_int32_t *)buf;
#line 380
  read_blk___4(h, blk, buf);
#line 381
  ret = (loff_t )0;
#line 382
  tmp___0 = get_index___4(dquot->dq_id, depth);
#line 382
  blk = *(ref + tmp___0);
  }
#line 383
  if (! blk) {
#line 384
    goto out_buf;
  }
#line 385
  if (depth < 3) {
    {
#line 386
    ret = find_tree_dqentry___4(h, dquot, blk, depth + 1);
    }
  } else {
    {
#line 388
    ret = find_block_dqentry___4(h, dquot, blk);
    }
  }
  out_buf: 
  {
#line 390
  free((void *)buf);
  }
#line 391
  return (ret);
}
}
#line 395 "/home/wheatley/newnew/temp/quota-4.01/quotaio_tree.c"
__inline static loff_t find_dqentry___4(struct quota_handle *h , struct dquot *dquot ) 
{ 
  loff_t tmp ;

  {
  {
#line 397
  tmp = find_tree_dqentry___4(h, dquot, (uint )1, 0);
  }
#line 397
  return (tmp);
}
}
#line 441 "/home/wheatley/newnew/temp/quota-4.01/quotaio_tree.c"
static int report_block___4(struct dquot *dquot , uint blk , char *bitmap , int (*process_dquot)(struct dquot * ,
                                                                                                 char * ) ) 
{ 
  struct qtree_mem_dqinfo *info ;
  dqbuf_t buf ;
  void *tmp ;
  struct qt_disk_dqdbheader *dh ;
  char *ddata ;
  int entries ;
  int i ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 444
  info = & (dquot->dq_h)->qh_info.u.v2_mdqi.dqi_qtree;
#line 445
  tmp = smalloc((size_t )(1 << 10));
#line 445
  buf = (dqbuf_t )tmp;
#line 450
  *(bitmap + (blk >> 3)) = (char )((int )*(bitmap + (blk >> 3)) | (1 << (blk & 7U)));
#line 451
  read_blk___4(dquot->dq_h, blk, buf);
#line 452
  dh = (struct qt_disk_dqdbheader *)buf;
#line 453
  ddata = buf + sizeof(struct qt_disk_dqdbheader );
#line 454
  entries = (int )dh->dqdh_entries;
#line 455
  i = 0;
  }
  {
#line 455
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 455
    tmp___2 = qtree_dqstr_in_blk(info);
    }
#line 455
    if (! (i < tmp___2)) {
#line 455
      goto while_break;
    }
    {
#line 456
    tmp___1 = qtree_entry_unused(info, ddata);
    }
#line 456
    if (! tmp___1) {
      {
#line 457
      (*((info->dqi_ops)->disk2mem_dqblk))(dquot, (void *)ddata);
#line 458
      tmp___0 = (*process_dquot)(dquot, (char *)((void *)0));
      }
#line 458
      if (tmp___0 < 0) {
#line 459
        goto while_break;
      }
    }
#line 455
    i ++;
#line 455
    ddata += info->dqi_entry_size;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 461
  free((void *)buf);
  }
#line 462
  return (entries);
}
}
#line 465 "/home/wheatley/newnew/temp/quota-4.01/quotaio_tree.c"
static void check_reference___4(struct quota_handle *h , uint blk ) 
{ 
  char *tmp ;
  char *tmp___0 ;

  {
#line 467
  if (blk >= h->qh_info.u.v2_mdqi.dqi_qtree.dqi_blocks) {
    {
#line 468
    tmp = type2name(h->qh_type);
#line 468
    tmp___0 = gettext("Illegal reference (%u >= %u) in %s quota file on %s. Quota file is probably corrupted.\nPlease run quotacheck(8) and try again.\n");
#line 468
    die(2, tmp___0, blk, h->qh_info.u.v2_mdqi.dqi_qtree.dqi_blocks, tmp, h->qh_quotadev);
    }
  }
#line 469
  return;
}
}
#line 471 "/home/wheatley/newnew/temp/quota-4.01/quotaio_tree.c"
static int report_tree___4(struct dquot *dquot , uint blk , int depth , char *bitmap ,
                           int (*process_dquot)(struct dquot * , char * ) ) 
{ 
  int entries ;
  int i ;
  dqbuf_t buf ;
  void *tmp ;
  u_int32_t *ref ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 474
  entries = 0;
#line 475
  tmp = smalloc((size_t )(1 << 10));
#line 475
  buf = (dqbuf_t )tmp;
#line 476
  ref = (u_int32_t *)buf;
#line 478
  read_blk___4(dquot->dq_h, blk, buf);
  }
#line 479
  if (depth == 3) {
#line 480
    i = 0;
    {
#line 480
    while (1) {
      while_continue: /* CIL Label */ ;
#line 480
      if (! (i < (1 << 10) >> 2)) {
#line 480
        goto while_break;
      }
      {
#line 481
      blk = *(ref + i);
#line 482
      check_reference___4(dquot->dq_h, blk);
      }
#line 483
      if (blk) {
#line 483
        if (! ((int )*(bitmap + (blk >> 3)) & (1 << (blk & 7U)))) {
          {
#line 484
          tmp___0 = report_block___4(dquot, blk, bitmap, process_dquot);
#line 484
          entries += tmp___0;
          }
        }
      }
#line 480
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 488
    i = 0;
    {
#line 488
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 488
      if (! (i < (1 << 10) >> 2)) {
#line 488
        goto while_break___0;
      }
#line 489
      blk = *(ref + i);
#line 489
      if (blk) {
        {
#line 490
        check_reference___4(dquot->dq_h, blk);
#line 491
        tmp___1 = report_tree___4(dquot, blk, depth + 1, bitmap, process_dquot);
#line 491
        entries += tmp___1;
        }
      }
#line 488
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  {
#line 495
  free((void *)buf);
  }
#line 496
  return (entries);
}
}
#line 499 "/home/wheatley/newnew/temp/quota-4.01/quotaio_tree.c"
static uint find_set_bits___4(char *bmp , int blocks ) 
{ 
  uint i ;
  uint used ;

  {
#line 501
  used = (uint )0;
#line 503
  i = (uint )0;
  {
#line 503
  while (1) {
    while_continue: /* CIL Label */ ;
#line 503
    if (! (i < (uint )blocks)) {
#line 503
      goto while_break;
    }
#line 504
    if ((int )*(bmp + (i >> 3)) & (1 << (i & 7U))) {
#line 505
      used ++;
    }
#line 503
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 506
  return (used);
}
}
#line 281 "/home/wheatley/newnew/temp/quota-4.01/quotaops.c"
static void merge_limits_to_list___0(struct dquot *qlist , char *dev , u_int64_t blocks ,
                                     u_int64_t bsoft , u_int64_t bhard , u_int64_t inodes ,
                                     u_int64_t isoft , u_int64_t ihard ) 
{ 
  struct dquot *q ;
  int tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
#line 286
  q = qlist;
  {
#line 286
  while (1) {
    while_continue: /* CIL Label */ ;
#line 286
    if (! q) {
#line 286
      goto while_break;
    }
    {
#line 287
    tmp = devcmp_handle((char const   *)dev, q->dq_h);
    }
#line 287
    if (! tmp) {
#line 288
      goto __Cont;
    }
    {
#line 290
    q->dq_dqb.dqb_bsoftlimit = (qsize_t )bsoft;
#line 291
    q->dq_dqb.dqb_bhardlimit = (qsize_t )bhard;
#line 292
    q->dq_dqb.dqb_isoftlimit = (qsize_t )isoft;
#line 293
    q->dq_dqb.dqb_ihardlimit = (qsize_t )ihard;
#line 294
    q->dq_flags |= 1;
#line 295
    update_grace_times(q);
    }
#line 297
    if (blocks != (u_int64_t )(((q->dq_dqb.dqb_curspace + (qsize_t )(1 << 10)) - 1L) >> 10)) {
      {
#line 298
      tmp___0 = gettext("WARNING - %s: cannot change current block allocation\n");
#line 298
      errstr(tmp___0, (q->dq_h)->qh_quotadev);
      }
    }
#line 300
    if (inodes != (u_int64_t )q->dq_dqb.dqb_curinodes) {
      {
#line 301
      tmp___1 = gettext("WARNING - %s: cannot change current inode allocation\n");
#line 301
      errstr(tmp___1, (q->dq_h)->qh_quotadev);
      }
    }
    __Cont: /* CIL Label */ 
#line 286
    q = q->dq_next;
  }
  while_break: /* CIL Label */ ;
  }
#line 304
  return;
}
}
#line 357 "/home/wheatley/newnew/temp/quota-4.01/quotaops.c"
static void merge_times_to_list___0(struct dquot *qlist , char *dev , time_t btime ,
                                    time_t itime ) 
{ 
  struct dquot *q ;
  int tmp ;

  {
#line 361
  q = qlist;
  {
#line 361
  while (1) {
    while_continue: /* CIL Label */ ;
#line 361
    if (! q) {
#line 361
      goto while_break;
    }
    {
#line 362
    tmp = devcmp_handle((char const   *)dev, q->dq_h);
    }
#line 362
    if (! tmp) {
#line 363
      goto __Cont;
    }
#line 365
    q->dq_dqb.dqb_btime = btime;
#line 366
    q->dq_dqb.dqb_itime = itime;
#line 367
    q->dq_flags |= 1;
    __Cont: /* CIL Label */ 
#line 361
    q = q->dq_next;
  }
  while_break: /* CIL Label */ ;
  }
#line 369
  return;
}
}
#line 10 "/home/wheatley/newnew/temp/quota-4.01/rquota_clnt.c"
static struct timeval TIMEOUT___4  =    {(__time_t )25, (__suseconds_t )0};
#line 15 "/home/wheatley/newnew/temp/quota-4.01/rquota_clnt.c"
static getquota_rslt clnt_res___39  ;
#line 30 "/home/wheatley/newnew/temp/quota-4.01/rquota_clnt.c"
static getquota_rslt clnt_res___40  ;
#line 45 "/home/wheatley/newnew/temp/quota-4.01/rquota_clnt.c"
static setquota_rslt clnt_res___41  ;
#line 60 "/home/wheatley/newnew/temp/quota-4.01/rquota_clnt.c"
static setquota_rslt clnt_res___42  ;
#line 75 "/home/wheatley/newnew/temp/quota-4.01/rquota_clnt.c"
static getquota_rslt clnt_res___43  ;
#line 90 "/home/wheatley/newnew/temp/quota-4.01/rquota_clnt.c"
static getquota_rslt clnt_res___44  ;
#line 105 "/home/wheatley/newnew/temp/quota-4.01/rquota_clnt.c"
static setquota_rslt clnt_res___45  ;
#line 120 "/home/wheatley/newnew/temp/quota-4.01/rquota_clnt.c"
static setquota_rslt clnt_res___46  ;
#line 19 "/home/wheatley/newnew/temp/quota-4.01/quotaio_meta.c"
static int meta_init_io___5(struct quota_handle *h ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
#line 21
  if (! (h->qh_io_flags & 1)) {
    {
#line 22
    tmp = gettext("Metadata init_io called when kernel support is not enabled.\n");
#line 22
    errstr(tmp);
    }
#line 23
    return (-1);
  }
#line 25
  if (kernel_iface != 3) {
    {
#line 26
    tmp___0 = gettext("Metadata init_io called when kernel does not support generic quota interface!\n");
#line 26
    errstr(tmp___0);
    }
#line 27
    return (-1);
  }
  {
#line 29
  tmp___1 = vfs_get_info(h);
  }
#line 29
  return (tmp___1);
}
}
#line 32 "/home/wheatley/newnew/temp/quota-4.01/quotaio_meta.c"
static int meta_write_info___5(struct quota_handle *h ) 
{ 
  int tmp ;

  {
  {
#line 34
  tmp = vfs_set_info(h, 3);
  }
#line 34
  return (tmp);
}
}
#line 37 "/home/wheatley/newnew/temp/quota-4.01/quotaio_meta.c"
static struct dquot *meta_read_dquot___5(struct quota_handle *h , qid_t id___0 ) 
{ 
  struct dquot *dquot ;
  struct dquot *tmp ;
  int tmp___0 ;

  {
  {
#line 39
  tmp = get_empty_dquot();
#line 39
  dquot = tmp;
#line 41
  dquot->dq_id = id___0;
#line 42
  dquot->dq_h = h;
#line 43
  memset((void *)(& dquot->dq_dqb), 0, sizeof(struct util_dqblk ));
#line 44
  tmp___0 = vfs_get_dquot(dquot);
  }
#line 44
  if (tmp___0 < 0) {
    {
#line 45
    free((void *)dquot);
    }
#line 46
    return ((struct dquot *)((void *)0));
  }
#line 48
  return (dquot);
}
}
#line 51 "/home/wheatley/newnew/temp/quota-4.01/quotaio_meta.c"
static int meta_commit_dquot___5(struct dquot *dquot , int flags___7 ) 
{ 
  int tmp ;

  {
  {
#line 53
  tmp = vfs_set_dquot(dquot, flags___7);
  }
#line 53
  return (tmp);
}
}
#line 56 "/home/wheatley/newnew/temp/quota-4.01/quotaio_meta.c"
static int meta_scan_dquots___5(struct quota_handle *h , int (*process_dquot)(struct dquot *dquot ,
                                                                              char *dqname ) ) 
{ 
  int tmp ;

  {
  {
#line 58
  tmp = generic_scan_dquots(h, process_dquot, & vfs_get_dquot);
  }
#line 58
  return (tmp);
}
}
#line 27 "/home/wheatley/newnew/temp/quota-4.01/quotaio_xfs.c"
static int xfs_init_io___5(struct quota_handle *h ) ;
#line 28
static int xfs_write_info___5(struct quota_handle *h ) ;
#line 29
static struct dquot *xfs_read_dquot___5(struct quota_handle *h , qid_t id___0 ) ;
#line 30
static int xfs_commit_dquot___5(struct dquot *dquot , int flags___7 ) ;
#line 31
static int xfs_scan_dquots___5(struct quota_handle *h , int (*process_dquot)(struct dquot *dquot ,
                                                                             char *dqname ) ) ;
#line 32
static int xfs_report___5(struct quota_handle *h , int verbose ) ;
#line 77 "/home/wheatley/newnew/temp/quota-4.01/quotaio_xfs.c"
static int xfs_init_io___5(struct quota_handle *h ) 
{ 
  struct fs_quota_stat info ;
  int qcmd ;
  long tmp ;

  {
  {
#line 82
  qcmd = ((88 << 8) + 5) << 8;
#line 83
  memset((void *)(& info), 0, sizeof(struct fs_quota_stat ));
#line 84
  tmp = quotactl(qcmd, (char const   *)(h->qh_quotadev), (qid_t )0, (caddr_t )((void *)(& info)));
  }
#line 84
  if (tmp < 0L) {
#line 85
    return (-1);
  }
#line 86
  h->qh_info.dqi_bgrace = (time_t )info.qs_btimelimit;
#line 87
  h->qh_info.dqi_igrace = (time_t )info.qs_itimelimit;
#line 88
  h->qh_info.u.xfs_mdqi = info;
#line 89
  return (0);
}
}
#line 95 "/home/wheatley/newnew/temp/quota-4.01/quotaio_xfs.c"
static int xfs_write_info___5(struct quota_handle *h ) 
{ 
  struct fs_disk_quota xdqblk ;
  int qcmd ;
  long tmp ;

  {
#line 100
  if (h->qh_type == 0) {
#line 100
    if (! ((int )h->qh_info.u.xfs_mdqi.qs_flags & 1)) {
#line 100
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 100
  if (h->qh_type == 1) {
#line 100
    if (! ((int )h->qh_info.u.xfs_mdqi.qs_flags & (1 << 2))) {
#line 101
      return (0);
    }
  } else {
#line 101
    return (0);
  }
  {
#line 103
  memset((void *)(& xdqblk), 0, sizeof(struct fs_disk_quota ));
#line 105
  xdqblk.d_btimer = (__s32 )h->qh_info.dqi_bgrace;
#line 106
  xdqblk.d_itimer = (__s32 )h->qh_info.dqi_igrace;
#line 107
  xdqblk.d_fieldmask = (__u16 )((int )xdqblk.d_fieldmask | (((1 << 6) | (1 << 7)) | (1 << 8)));
#line 108
  qcmd = (((88 << 8) + 4) << 8) | (h->qh_type & 255);
#line 109
  tmp = quotactl(qcmd, (char const   *)(h->qh_quotadev), (qid_t )0, (caddr_t )((void *)(& xdqblk)));
  }
#line 109
  if (tmp < 0L) {
#line 110
    return (-1);
  }
#line 111
  return (0);
}
}
#line 117 "/home/wheatley/newnew/temp/quota-4.01/quotaio_xfs.c"
static struct dquot *xfs_read_dquot___5(struct quota_handle *h , qid_t id___0 ) 
{ 
  struct dquot *dquot ;
  struct dquot *tmp ;
  struct fs_disk_quota xdqblk ;
  int qcmd ;
  long tmp___0 ;

  {
  {
#line 119
  tmp = get_empty_dquot();
#line 119
  dquot = tmp;
#line 123
  dquot->dq_id = id___0;
#line 124
  dquot->dq_h = h;
  }
#line 126
  if (h->qh_type == 0) {
#line 126
    if (! ((int )h->qh_info.u.xfs_mdqi.qs_flags & 1)) {
#line 126
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 126
  if (h->qh_type == 1) {
#line 126
    if (! ((int )h->qh_info.u.xfs_mdqi.qs_flags & (1 << 2))) {
#line 127
      return (dquot);
    }
  } else {
#line 127
    return (dquot);
  }
  {
#line 129
  qcmd = (((88 << 8) + 3) << 8) | (h->qh_type & 255);
#line 130
  tmp___0 = quotactl(qcmd, (char const   *)(h->qh_quotadev), id___0, (caddr_t )((void *)(& xdqblk)));
  }
#line 130
  if (! (tmp___0 < 0L)) {
    {
#line 134
    xfs_kern2utildqblk(& dquot->dq_dqb, & xdqblk);
    }
  }
#line 136
  return (dquot);
}
}
#line 142 "/home/wheatley/newnew/temp/quota-4.01/quotaio_xfs.c"
static int xfs_commit_dquot___5(struct dquot *dquot , int flags___7 ) 
{ 
  struct quota_handle *h ;
  struct fs_disk_quota xdqblk ;
  qid_t id___0 ;
  int qcmd ;
  int tmp ;
  int tmp___0 ;
  long tmp___1 ;

  {
#line 144
  h = dquot->dq_h;
#line 146
  id___0 = dquot->dq_id;
#line 149
  if (h->qh_type == 0) {
#line 149
    if (! ((int )h->qh_info.u.xfs_mdqi.qs_flags & 1)) {
#line 149
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 149
  if (h->qh_type == 1) {
#line 149
    if (! ((int )h->qh_info.u.xfs_mdqi.qs_flags & (1 << 2))) {
#line 150
      return (0);
    }
  } else {
#line 150
    return (0);
  }
  {
#line 152
  xfs_util2kerndqblk(& xdqblk, & dquot->dq_dqb);
  }
#line 153
  if (h->qh_type == 0) {
#line 153
    if ((int )h->qh_info.u.xfs_mdqi.qs_flags & 1) {
#line 153
      tmp = 1;
    } else {
#line 153
      tmp = 1 << 2;
    }
  } else {
#line 153
    tmp = 1 << 2;
  }
  {
#line 153
  xdqblk.d_flags = (__s8 )((int )xdqblk.d_flags | tmp);
#line 154
  xdqblk.d_id = id___0;
#line 155
  tmp___0 = strcmp((char const   *)(h->qh_fstype), "gfs2");
  }
#line 155
  if (tmp___0 == 0) {
#line 156
    if (flags___7 & 5) {
#line 157
      xdqblk.d_fieldmask = (__u16 )((int )xdqblk.d_fieldmask | ((1 << 2) | (1 << 3)));
    }
#line 158
    if (flags___7 & 10) {
#line 159
      xdqblk.d_fieldmask = (__u16 )((int )xdqblk.d_fieldmask | (1 << 12));
    }
  } else {
#line 161
    xdqblk.d_fieldmask = (__u16 )((int )xdqblk.d_fieldmask | (((((1 | (1 << 1)) | (1 << 2)) | (1 << 3)) | (1 << 4)) | (1 << 5)));
  }
  {
#line 164
  qcmd = (((88 << 8) + 4) << 8) | (h->qh_type & 255);
#line 165
  tmp___1 = quotactl(qcmd, (char const   *)(h->qh_quotadev), id___0, (caddr_t )((void *)(& xdqblk)));
  }
#line 165
  if (! (tmp___1 < 0L)) {
#line 169
    return (0);
  }
#line 171
  return (-1);
}
}
#line 177 "/home/wheatley/newnew/temp/quota-4.01/quotaio_xfs.c"
static int xfs_get_dquot___5(struct dquot *dq ) 
{ 
  struct fs_disk_quota d ;
  int qcmd ;
  int ret ;
  long tmp ;
  int *tmp___0 ;

  {
  {
#line 180
  qcmd = (((88 << 8) + 3) << 8) | ((dq->dq_h)->qh_type & 255);
#line 183
  memset((void *)(& d), 0, sizeof(d));
#line 184
  tmp = quotactl(qcmd, (char const   *)((dq->dq_h)->qh_quotadev), dq->dq_id, (caddr_t )((void *)(& d)));
#line 184
  ret = (int )tmp;
  }
#line 185
  if (ret < 0) {
    {
#line 186
    tmp___0 = __errno_location();
    }
#line 186
    if (*tmp___0 == 2) {
#line 187
      return (0);
    }
#line 188
    return (-1);
  }
  {
#line 190
  xfs_kern2utildqblk(& dq->dq_dqb, & d);
  }
#line 191
  return (0);
}
}
#line 197 "/home/wheatley/newnew/temp/quota-4.01/quotaio_xfs.c"
static int xfs_scan_dquots___5(struct quota_handle *h , int (*process_dquot)(struct dquot *dquot ,
                                                                             char *dqname ) ) 
{ 
  int tmp ;

  {
#line 199
  if (h->qh_type == 0) {
#line 199
    if (! ((int )h->qh_info.u.xfs_mdqi.qs_flags & 1)) {
#line 199
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 199
  if (h->qh_type == 1) {
#line 199
    if (! ((int )h->qh_info.u.xfs_mdqi.qs_flags & (1 << 2))) {
#line 200
      return (0);
    }
  } else {
#line 200
    return (0);
  }
  {
#line 202
  tmp = generic_scan_dquots(h, process_dquot, & xfs_get_dquot___5);
  }
#line 202
  return (tmp);
}
}
#line 208 "/home/wheatley/newnew/temp/quota-4.01/quotaio_xfs.c"
static int xfs_report___5(struct quota_handle *h , int verbose ) 
{ 
  u_int16_t sbflags ;
  struct fs_quota_stat *info ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;
  char *tmp___18 ;
  char *tmp___19 ;
  char *tmp___20 ;
  char *tmp___21 ;
  char *tmp___22 ;
  char *tmp___23 ;
  char *tmp___24 ;
  char *tmp___25 ;
  char *tmp___26 ;
  char *tmp___27 ;
  char *tmp___28 ;
  char *tmp___29 ;
  char *tmp___30 ;
  char *tmp___31 ;
  char *tmp___32 ;

  {
#line 211
  info = & h->qh_info.u.xfs_mdqi;
#line 213
  if (! verbose) {
#line 214
    return (0);
  }
  {
#line 217
  tmp = type2name(h->qh_type);
#line 217
  tmp___0 = gettext("*** Status for %s quotas on device %s\n");
#line 217
  printf((char const   */* __restrict  */)tmp___0, tmp, h->qh_quotadev);
  }
#line 220
  if (h->qh_type == 0) {
#line 221
    if ((int )info->qs_flags & (1 << 1)) {
      {
#line 221
      tmp___1 = gettext("ON");
#line 221
      tmp___3 = tmp___1;
      }
    } else {
      {
#line 221
      tmp___2 = gettext("OFF");
#line 221
      tmp___3 = tmp___2;
      }
    }
#line 221
    if ((int )info->qs_flags & 1) {
      {
#line 221
      tmp___4 = gettext("ON");
#line 221
      tmp___6 = tmp___4;
      }
    } else {
      {
#line 221
      tmp___5 = gettext("OFF");
#line 221
      tmp___6 = tmp___5;
      }
    }
    {
#line 221
    tmp___7 = gettext("Accounting: %s; Enforcement: %s\n");
#line 221
    printf((char const   */* __restrict  */)tmp___7, tmp___6, tmp___3);
    }
  } else {
#line 225
    if ((int )info->qs_flags & (1 << 3)) {
      {
#line 225
      tmp___8 = gettext("ON");
#line 225
      tmp___10 = tmp___8;
      }
    } else {
      {
#line 225
      tmp___9 = gettext("OFF");
#line 225
      tmp___10 = tmp___9;
      }
    }
#line 225
    if ((int )info->qs_flags & (1 << 2)) {
      {
#line 225
      tmp___11 = gettext("ON");
#line 225
      tmp___13 = tmp___11;
      }
    } else {
      {
#line 225
      tmp___12 = gettext("OFF");
#line 225
      tmp___13 = tmp___12;
      }
    }
    {
#line 225
    tmp___14 = gettext("Accounting: %s; Enforcement: %s\n");
#line 225
    printf((char const   */* __restrict  */)tmp___14, tmp___13, tmp___10);
    }
  }
#line 235
  sbflags = (u_int16_t )(((int )info->qs_flags & 65280) >> 8);
#line 235
  if ((int )sbflags != 0) {
#line 236
    if (h->qh_type == 0) {
#line 237
      if ((int )sbflags & (1 << 1)) {
        {
#line 237
        tmp___15 = gettext("ON");
#line 237
        tmp___17 = tmp___15;
        }
      } else {
        {
#line 237
        tmp___16 = gettext("OFF");
#line 237
        tmp___17 = tmp___16;
        }
      }
#line 237
      if ((int )sbflags & 1) {
        {
#line 237
        tmp___18 = gettext("ON");
#line 237
        tmp___20 = tmp___18;
        }
      } else {
        {
#line 237
        tmp___19 = gettext("OFF");
#line 237
        tmp___20 = tmp___19;
        }
      }
      {
#line 237
      tmp___21 = gettext("Accounting [ondisk]: %s; Enforcement [ondisk]: %s\n");
#line 237
      printf((char const   */* __restrict  */)tmp___21, tmp___20, tmp___17);
      }
    } else {
#line 241
      if ((int )sbflags & (1 << 3)) {
        {
#line 241
        tmp___22 = gettext("ON");
#line 241
        tmp___24 = tmp___22;
        }
      } else {
        {
#line 241
        tmp___23 = gettext("OFF");
#line 241
        tmp___24 = tmp___23;
        }
      }
#line 241
      if ((int )sbflags & (1 << 2)) {
        {
#line 241
        tmp___25 = gettext("ON");
#line 241
        tmp___27 = tmp___25;
        }
      } else {
        {
#line 241
        tmp___26 = gettext("OFF");
#line 241
        tmp___27 = tmp___26;
        }
      }
      {
#line 241
      tmp___28 = gettext("Accounting [ondisk]: %s; Enforcement [ondisk]: %s\n");
#line 241
      printf((char const   */* __restrict  */)tmp___28, tmp___27, tmp___24);
      }
    }
  }
#line 248
  if (h->qh_type == 0) {
#line 249
    if (info->qs_uquota.qfs_ino == 0xffffffffffffffffULL) {
      {
#line 250
      tmp___29 = gettext("Inode: none\n");
#line 250
      printf((char const   */* __restrict  */)tmp___29);
      }
    } else
#line 249
    if (info->qs_uquota.qfs_ino == 0ULL) {
      {
#line 250
      tmp___29 = gettext("Inode: none\n");
#line 250
      printf((char const   */* __restrict  */)tmp___29);
      }
    } else {
      {
#line 252
      tmp___30 = gettext("Inode: #%llu (%llu blocks, %u extents)\n");
#line 252
      printf((char const   */* __restrict  */)tmp___30, info->qs_uquota.qfs_ino, info->qs_uquota.qfs_nblks,
             info->qs_uquota.qfs_nextents);
      }
    }
  } else
#line 258
  if (info->qs_gquota.qfs_ino == 0xffffffffffffffffULL) {
    {
#line 259
    tmp___31 = gettext("Inode: none\n");
#line 259
    printf((char const   */* __restrict  */)tmp___31);
    }
  } else {
    {
#line 261
    tmp___32 = gettext("Inode: #%llu (%llu blocks, %u extents)\n");
#line 261
    printf((char const   */* __restrict  */)tmp___32, info->qs_gquota.qfs_ino, info->qs_gquota.qfs_nblks,
           info->qs_gquota.qfs_nextents);
    }
  }
#line 266
  return (0);
}
}
#line 31 "/home/wheatley/newnew/temp/quota-4.01/bylabel.c"
static struct uuidCache_s *uuidCache___5  =    (struct uuidCache_s *)((void *)0);
#line 74 "/home/wheatley/newnew/temp/quota-4.01/bylabel.c"
static int get_label_uuid___5(char const   *device , char **label , char *uuid ) 
{ 
  int fd ;
  int rv ;
  size_t namesize ;
  struct ext2_super_block e2sb ;
  struct xfs_super_block xfsb ;
  struct reiserfs_super_block reisersb ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  __off64_t tmp___2 ;
  ssize_t tmp___3 ;
  int tmp___4 ;
  __off64_t tmp___5 ;
  ssize_t tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  __off64_t tmp___9 ;
  ssize_t tmp___10 ;

  {
  {
#line 79
  rv = 1;
#line 85
  fd = open(device, 0);
  }
#line 86
  if (fd < 0) {
#line 87
    return (rv);
  }
  {
#line 89
  tmp___9 = lseek(fd, (__off64_t )1024, 0);
  }
#line 89
  if (tmp___9 == 1024L) {
    {
#line 89
    tmp___10 = read(fd, (void *)((char *)(& e2sb)), sizeof(e2sb));
    }
#line 89
    if ((unsigned long )tmp___10 == sizeof(e2sb)) {
#line 89
      if ((uint )e2sb.s_magic[0] + ((uint )e2sb.s_magic[1] << 8) == 61267U) {
        {
#line 92
        memcpy((void */* __restrict  */)uuid, (void const   */* __restrict  */)(e2sb.s_uuid),
               sizeof(e2sb.s_uuid));
#line 93
        namesize = sizeof(e2sb.s_volume_name);
#line 94
        tmp = smalloc(namesize + 1UL);
#line 94
        *label = (char *)tmp;
#line 95
        sstrncpy(*label, (char const   *)((char *)(e2sb.s_volume_name)), namesize);
#line 96
        rv = 0;
        }
      } else {
#line 89
        goto _L___3;
      }
    } else {
#line 89
      goto _L___3;
    }
  } else {
    _L___3: /* CIL Label */ 
    {
#line 98
    tmp___5 = lseek(fd, (__off64_t )0, 0);
    }
#line 98
    if (tmp___5 == 0L) {
      {
#line 98
      tmp___6 = read(fd, (void *)((char *)(& xfsb)), sizeof(xfsb));
      }
#line 98
      if ((unsigned long )tmp___6 == sizeof(xfsb)) {
        {
#line 98
        tmp___7 = strncmp((char const   *)((char *)(& xfsb.s_magic)), "XFSB", (size_t )4);
        }
#line 98
        if (tmp___7 == 0) {
#line 98
          goto _L___0;
        } else {
          {
#line 98
          tmp___8 = strncmp((char const   *)((char *)(& xfsb.s_magic)), "BSFX", (size_t )4);
          }
#line 98
          if (tmp___8 == 0) {
            _L___0: /* CIL Label */ 
            {
#line 102
            memcpy((void */* __restrict  */)uuid, (void const   */* __restrict  */)(xfsb.s_uuid),
                   sizeof(xfsb.s_uuid));
#line 103
            namesize = sizeof(xfsb.s_fsname);
#line 104
            tmp___0 = smalloc(namesize + 1UL);
#line 104
            *label = (char *)tmp___0;
#line 105
            sstrncpy(*label, (char const   *)((char *)(xfsb.s_fsname)), namesize);
#line 106
            rv = 0;
            }
          } else {
#line 98
            goto _L___1;
          }
        }
      } else {
#line 98
        goto _L___1;
      }
    } else {
      _L___1: /* CIL Label */ 
      {
#line 108
      tmp___2 = lseek(fd, (__off64_t )65536, 0);
      }
#line 108
      if (tmp___2 == 65536L) {
        {
#line 108
        tmp___3 = read(fd, (void *)((char *)(& reisersb)), sizeof(reisersb));
        }
#line 108
        if ((unsigned long )tmp___3 == sizeof(reisersb)) {
          {
#line 108
          tmp___4 = strncmp((char const   *)((char *)(& reisersb.s_magic)), "ReIsEr2Fs",
                            (size_t )9);
          }
#line 108
          if (! tmp___4) {
            {
#line 111
            memcpy((void */* __restrict  */)uuid, (void const   */* __restrict  */)(reisersb.s_uuid),
                   sizeof(reisersb.s_uuid));
#line 112
            namesize = sizeof(reisersb.s_volume_name);
#line 113
            tmp___1 = smalloc(namesize + 1UL);
#line 113
            *label = (char *)tmp___1;
#line 114
            sstrncpy(*label, (char const   *)((char *)(reisersb.s_volume_name)), namesize);
#line 115
            rv = 0;
            }
          }
        }
      }
    }
  }
  {
#line 117
  close(fd);
  }
#line 118
  return (rv);
}
}
#line 121 "/home/wheatley/newnew/temp/quota-4.01/bylabel.c"
static void uuidcache_addentry___5(char *device , char *label , char *uuid ) 
{ 
  struct uuidCache_s *last ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 125
  if (! uuidCache___5) {
    {
#line 126
    tmp = smalloc(sizeof(*uuidCache___5));
#line 126
    uuidCache___5 = (struct uuidCache_s *)tmp;
#line 126
    last = uuidCache___5;
    }
  } else {
#line 129
    last = uuidCache___5;
    {
#line 129
    while (1) {
      while_continue: /* CIL Label */ ;
#line 129
      if (! last->next) {
#line 129
        goto while_break;
      }
#line 129
      last = last->next;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 130
    tmp___0 = smalloc(sizeof(*uuidCache___5));
#line 130
    last->next = (struct uuidCache_s *)tmp___0;
#line 131
    last = last->next;
    }
  }
  {
#line 133
  last->next = (struct uuidCache_s *)((void *)0);
#line 134
  last->device = device;
#line 135
  last->label = label;
#line 136
  memcpy((void */* __restrict  */)(last->uuid), (void const   */* __restrict  */)uuid,
         sizeof(last->uuid));
  }
#line 137
  return;
}
}
#line 144 "/home/wheatley/newnew/temp/quota-4.01/bylabel.c"
static char ptname___5[100]  ;
#line 139 "/home/wheatley/newnew/temp/quota-4.01/bylabel.c"
static void uuidcache_init___5(void) 
{ 
  char line___0[100] ;
  char *s ;
  int ma ;
  int mi ;
  int sz ;
  FILE *procpt ;
  char uuid[16] ;
  char *label ;
  char device[110] ;
  int firstPass ;
  int handleOnFirst ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  unsigned short const   **tmp___4 ;
  char *tmp___5 ;

  {
#line 151
  if (uuidCache___5) {
#line 152
    return;
  }
  {
#line 154
  procpt = fopen((char const   */* __restrict  */)"/proc/partitions", (char const   */* __restrict  */)"r");
  }
#line 155
  if (! procpt) {
#line 156
    return;
  }
#line 158
  firstPass = 1;
  {
#line 158
  while (1) {
    while_continue: /* CIL Label */ ;
#line 158
    if (! (firstPass >= 0)) {
#line 158
      goto while_break;
    }
    {
#line 159
    fseek(procpt, 0L, 0);
    }
    {
#line 161
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 161
      tmp___5 = fgets((char */* __restrict  */)(line___0), (int )sizeof(line___0),
                      (FILE */* __restrict  */)procpt);
      }
#line 161
      if (! tmp___5) {
#line 161
        goto while_break___0;
      }
      {
#line 162
      tmp = sscanf((char const   */* __restrict  */)(line___0), (char const   */* __restrict  */)" %d %d %d %[^\n ]",
                   & ma, & mi, & sz, ptname___5);
      }
#line 162
      if (tmp != 4) {
#line 163
        goto while_continue___0;
      }
#line 166
      if (sz == 1) {
#line 167
        goto while_continue___0;
      }
      {
#line 170
      tmp___0 = strncmp((char const   *)(ptname___5), "md", (size_t )2);
      }
#line 170
      if (tmp___0) {
#line 170
        tmp___1 = 0;
      } else {
#line 170
        tmp___1 = 1;
      }
#line 170
      handleOnFirst = tmp___1;
#line 171
      if (firstPass != handleOnFirst) {
#line 172
        goto while_continue___0;
      }
#line 178
      s = ptname___5;
      {
#line 178
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 178
        if (! *s) {
#line 178
          goto while_break___1;
        }
#line 178
        s ++;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 179
      tmp___4 = __ctype_b_loc();
      }
#line 179
      if ((int const   )*(*tmp___4 + (int )*(s + -1)) & 2048) {
        {
#line 189
        snprintf((char */* __restrict  */)(device), sizeof(device), (char const   */* __restrict  */)"%s/%s",
                 "/dev", ptname___5);
#line 190
        tmp___3 = get_label_uuid___5((char const   *)(device), & label, uuid);
        }
#line 190
        if (! tmp___3) {
          {
#line 191
          tmp___2 = sstrdup((char const   *)(device));
#line 191
          uuidcache_addentry___5(tmp___2, label, uuid);
          }
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 158
    firstPass --;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 196
  fclose(procpt);
  }
#line 197
  return;
}
}
#line 202 "/home/wheatley/newnew/temp/quota-4.01/bylabel.c"
static char *get_spec_by_x___5(int n , char const   *t ) 
{ 
  struct uuidCache_s *uc ;
  char *tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 206
  uuidcache_init___5();
#line 207
  uc = uuidCache___5;
  }
  {
#line 209
  while (1) {
    while_continue: /* CIL Label */ ;
#line 209
    if (! uc) {
#line 209
      goto while_break;
    }
    {
#line 211
    if (n == 1) {
#line 211
      goto case_1;
    }
#line 215
    if (n == 2) {
#line 215
      goto case_2;
    }
#line 210
    goto switch_break;
    case_1: /* CIL Label */ 
    {
#line 212
    tmp___0 = memcmp((void const   *)t, (void const   *)(uc->uuid), sizeof(uc->uuid));
    }
#line 212
    if (! tmp___0) {
      {
#line 213
      tmp = sstrdup((char const   *)uc->device);
      }
#line 213
      return (tmp);
    }
#line 214
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 216
    tmp___2 = strcmp(t, (char const   *)uc->label);
    }
#line 216
    if (! tmp___2) {
      {
#line 217
      tmp___1 = sstrdup((char const   *)uc->device);
      }
#line 217
      return (tmp___1);
    }
#line 218
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 220
    uc = uc->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 222
  return ((char *)((void *)0));
}
}
#line 225 "/home/wheatley/newnew/temp/quota-4.01/bylabel.c"
static u_char fromhex___5(char c ) 
{ 
  unsigned short const   **tmp ;
  unsigned short const   **tmp___0 ;

  {
  {
#line 227
  tmp___0 = __ctype_b_loc();
  }
#line 227
  if ((int const   )*(*tmp___0 + (int )c) & 2048) {
#line 228
    return ((u_char )((int )c - 48));
  } else {
    {
#line 229
    tmp = __ctype_b_loc();
    }
#line 229
    if ((int const   )*(*tmp + (int )c) & 512) {
#line 230
      return ((u_char )(((int )c - 97) + 10));
    } else {
#line 232
      return ((u_char )(((int )c - 65) + 10));
    }
  }
}
}
#line 235 "/home/wheatley/newnew/temp/quota-4.01/bylabel.c"
static char *get_spec_by_uuid___5(char const   *s ) 
{ 
  u_char uuid[16] ;
  int i ;
  size_t tmp ;
  unsigned short const   **tmp___0 ;
  unsigned short const   **tmp___1 ;
  u_char tmp___2 ;
  u_char tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;

  {
  {
#line 240
  tmp = strlen(s);
  }
#line 240
  if (tmp != 36UL) {
#line 241
    goto bad_uuid;
  } else
#line 240
  if ((int const   )*(s + 8) != 45) {
#line 241
    goto bad_uuid;
  } else
#line 240
  if ((int const   )*(s + 13) != 45) {
#line 241
    goto bad_uuid;
  } else
#line 240
  if ((int const   )*(s + 18) != 45) {
#line 241
    goto bad_uuid;
  } else
#line 240
  if ((int const   )*(s + 23) != 45) {
#line 241
    goto bad_uuid;
  }
#line 242
  i = 0;
  {
#line 242
  while (1) {
    while_continue: /* CIL Label */ ;
#line 242
    if (! (i < 16)) {
#line 242
      goto while_break;
    }
#line 243
    if ((int const   )*s == 45) {
#line 244
      s ++;
    }
    {
#line 245
    tmp___0 = __ctype_b_loc();
    }
#line 245
    if ((int const   )*(*tmp___0 + (int )*(s + 0)) & 4096) {
      {
#line 245
      tmp___1 = __ctype_b_loc();
      }
#line 245
      if (! ((int const   )*(*tmp___1 + (int )*(s + 1)) & 4096)) {
#line 246
        goto bad_uuid;
      }
    } else {
#line 246
      goto bad_uuid;
    }
    {
#line 247
    tmp___2 = fromhex___5((char )*(s + 0));
#line 247
    tmp___3 = fromhex___5((char )*(s + 1));
#line 247
    uuid[i] = (u_char )(((int )tmp___2 << 4) | (int )tmp___3);
#line 248
    s += 2;
#line 242
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 250
  tmp___4 = get_spec_by_x___5(1, (char const   *)((char *)(uuid)));
  }
#line 250
  return (tmp___4);
  bad_uuid: 
  {
#line 253
  tmp___5 = gettext("Found an invalid UUID: %s\n");
#line 253
  errstr(tmp___5, s);
  }
#line 254
  return ((char *)((void *)0));
}
}
#line 257 "/home/wheatley/newnew/temp/quota-4.01/bylabel.c"
static char *get_spec_by_volume_label___5(char const   *s ) 
{ 
  char *tmp ;

  {
  {
#line 259
  tmp = get_spec_by_x___5(2, s);
  }
#line 259
  return (tmp);
}
}
#line 50 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v1.c"
static int v1_check_file___5(int fd , int type , int fmt___7 ) ;
#line 51
static int v1_init_io___5(struct quota_handle *h ) ;
#line 52
static int v1_new_io___5(struct quota_handle *h ) ;
#line 53
static int v1_write_info___5(struct quota_handle *h ) ;
#line 54
static struct dquot *v1_read_dquot___5(struct quota_handle *h , qid_t id___0 ) ;
#line 55
static int v1_commit_dquot___5(struct dquot *dquot , int flags___7 ) ;
#line 56
static int v1_scan_dquots___5(struct quota_handle *h , int (*process_dquot)(struct dquot *dquot ,
                                                                            char *dqname ) ) ;
#line 127 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v1.c"
static int v1_check_file___5(int fd , int type , int fmt___7 ) 
{ 
  struct stat st ;
  int tmp ;

  {
  {
#line 131
  tmp = fstat(fd, & st);
  }
#line 131
  if (tmp < 0) {
#line 132
    return (0);
  }
#line 133
  if (! st.st_size) {
#line 134
    return (0);
  } else
#line 133
  if ((unsigned long )st.st_size % sizeof(struct v1_disk_dqblk )) {
#line 134
    return (0);
  }
#line 135
  return (1);
}
}
#line 141 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v1.c"
static int v1_init_io___5(struct quota_handle *h ) 
{ 
  int tmp ;
  struct v1_kern_dqblk kdqblk ;
  time_t tmp___0 ;
  int *tmp___1 ;
  long tmp___2 ;
  struct v1_disk_dqblk ddqblk ;
  ssize_t tmp___3 ;

  {
#line 143
  if (h->qh_io_flags & 1) {
#line 144
    if (kernel_iface == 3) {
      {
#line 145
      tmp = vfs_get_info(h);
      }
#line 145
      if (tmp < 0) {
#line 146
        return (-1);
      }
    } else {
      {
#line 151
      tmp___2 = quotactl((768 << 8) | (h->qh_type & 255), (char const   *)(h->qh_quotadev),
                         (qid_t )0, (caddr_t )((void *)(& kdqblk)));
      }
#line 151
      if (tmp___2 < 0L) {
        {
#line 152
        tmp___1 = __errno_location();
        }
#line 152
        if (*tmp___1 == 1) {
#line 153
          tmp___0 = (time_t )0;
#line 153
          h->qh_info.dqi_igrace = tmp___0;
#line 153
          h->qh_info.dqi_bgrace = tmp___0;
        } else {
#line 156
          return (-1);
        }
      } else {
#line 159
        h->qh_info.dqi_bgrace = kdqblk.dqb_btime;
#line 160
        h->qh_info.dqi_igrace = kdqblk.dqb_itime;
      }
    }
  } else {
    {
#line 167
    lseek(h->qh_fd, (__off64_t )0, 0);
#line 168
    tmp___3 = read(h->qh_fd, (void *)(& ddqblk), sizeof(ddqblk));
    }
#line 168
    if ((unsigned long )tmp___3 != sizeof(ddqblk)) {
#line 169
      return (-1);
    }
#line 170
    h->qh_info.dqi_bgrace = ddqblk.dqb_btime;
#line 171
    h->qh_info.dqi_igrace = ddqblk.dqb_itime;
  }
#line 173
  if (! h->qh_info.dqi_bgrace) {
#line 174
    h->qh_info.dqi_bgrace = (time_t )604800;
  }
#line 175
  if (! h->qh_info.dqi_igrace) {
#line 176
    h->qh_info.dqi_igrace = (time_t )604800;
  }
#line 177
  h->qh_info.dqi_max_b_limit = (uint64_t )(~ ((uint32_t )0));
#line 178
  h->qh_info.dqi_max_i_limit = (uint64_t )(~ ((uint32_t )0));
#line 179
  h->qh_info.dqi_max_b_usage = 4294967295UL << 10;
#line 180
  h->qh_info.dqi_max_i_usage = (uint64_t )(~ ((uint32_t )0));
#line 182
  return (0);
}
}
#line 188 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v1.c"
static int v1_new_io___5(struct quota_handle *h ) 
{ 
  struct v1_disk_dqblk ddqblk ;
  ssize_t tmp ;

  {
  {
#line 193
  memset((void *)(& ddqblk), 0, sizeof(ddqblk));
#line 194
  ddqblk.dqb_btime = (time_t )604800;
#line 195
  ddqblk.dqb_itime = (time_t )604800;
#line 196
  h->qh_info.dqi_bgrace = (time_t )604800;
#line 197
  h->qh_info.dqi_igrace = (time_t )604800;
#line 198
  h->qh_info.dqi_max_b_limit = (uint64_t )(~ ((uint32_t )0));
#line 199
  h->qh_info.dqi_max_i_limit = (uint64_t )(~ ((uint32_t )0));
#line 200
  h->qh_info.dqi_max_b_usage = 4294967295UL << 10;
#line 201
  h->qh_info.dqi_max_i_usage = (uint64_t )(~ ((uint32_t )0));
#line 202
  lseek(h->qh_fd, (__off64_t )0, 0);
#line 203
  tmp = write(h->qh_fd, (void const   *)(& ddqblk), sizeof(ddqblk));
  }
#line 203
  if ((unsigned long )tmp != sizeof(ddqblk)) {
#line 204
    return (-1);
  }
#line 205
  return (0);
}
}
#line 211 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v1.c"
static int v1_write_info___5(struct quota_handle *h ) 
{ 
  char *tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  struct v1_kern_dqblk kdqblk ;
  long tmp___2 ;
  long tmp___3 ;
  struct v1_disk_dqblk ddqblk ;
  ssize_t tmp___4 ;
  ssize_t tmp___5 ;

  {
#line 213
  if (h->qh_io_flags & 4) {
    {
#line 214
    tmp = gettext("Trying to write info to readonly quotafile on %s.\n");
#line 214
    errstr(tmp, h->qh_quotadev);
#line 215
    tmp___0 = __errno_location();
#line 215
    *tmp___0 = 1;
    }
#line 216
    return (-1);
  }
#line 218
  if (h->qh_io_flags & 1) {
#line 219
    if (kernel_iface == 3) {
      {
#line 220
      tmp___1 = vfs_set_info(h, 3);
      }
#line 220
      if (tmp___1 < 0) {
#line 221
        return (-1);
      }
    } else {
      {
#line 226
      tmp___2 = quotactl((768 << 8) | (h->qh_type & 255), (char const   *)(h->qh_quotadev),
                         (qid_t )0, (caddr_t )((void *)(& kdqblk)));
      }
#line 226
      if (tmp___2 < 0L) {
#line 227
        return (-1);
      }
      {
#line 228
      kdqblk.dqb_btime = h->qh_info.dqi_bgrace;
#line 229
      kdqblk.dqb_itime = h->qh_info.dqi_igrace;
#line 230
      tmp___3 = quotactl((1024 << 8) | (h->qh_type & 255), (char const   *)(h->qh_quotadev),
                         (qid_t )0, (caddr_t )((void *)(& kdqblk)));
      }
#line 230
      if (tmp___3 < 0L) {
#line 231
        return (-1);
      }
    }
  } else {
    {
#line 237
    lseek(h->qh_fd, (__off64_t )0, 0);
#line 238
    tmp___4 = read(h->qh_fd, (void *)(& ddqblk), sizeof(ddqblk));
    }
#line 238
    if ((unsigned long )tmp___4 != sizeof(ddqblk)) {
#line 239
      return (-1);
    }
    {
#line 240
    ddqblk.dqb_btime = h->qh_info.dqi_bgrace;
#line 241
    ddqblk.dqb_itime = h->qh_info.dqi_igrace;
#line 242
    lseek(h->qh_fd, (__off64_t )0, 0);
#line 243
    tmp___5 = write(h->qh_fd, (void const   *)(& ddqblk), sizeof(ddqblk));
    }
#line 243
    if ((unsigned long )tmp___5 != sizeof(ddqblk)) {
#line 244
      return (-1);
    }
  }
#line 246
  return (0);
}
}
#line 253 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v1.c"
static struct dquot *v1_read_dquot___5(struct quota_handle *h , qid_t id___0 ) 
{ 
  struct v1_disk_dqblk ddqblk ;
  struct dquot *dquot ;
  struct dquot *tmp ;
  int tmp___0 ;
  struct v1_kern_dqblk kdqblk ;
  long tmp___1 ;
  ssize_t tmp___2 ;

  {
  {
#line 256
  tmp = get_empty_dquot();
#line 256
  dquot = tmp;
#line 258
  dquot->dq_id = id___0;
#line 259
  dquot->dq_h = h;
  }
#line 260
  if (h->qh_io_flags & 1) {
#line 261
    if (kernel_iface == 3) {
      {
#line 262
      tmp___0 = vfs_get_dquot(dquot);
      }
#line 262
      if (tmp___0 < 0) {
        {
#line 263
        free((void *)dquot);
        }
#line 264
        return ((struct dquot *)((void *)0));
      }
    } else {
      {
#line 270
      tmp___1 = quotactl((768 << 8) | (h->qh_type & 255), (char const   *)(h->qh_quotadev),
                         id___0, (caddr_t )((void *)(& kdqblk)));
      }
#line 270
      if (tmp___1 < 0L) {
        {
#line 271
        free((void *)dquot);
        }
#line 272
        return ((struct dquot *)((void *)0));
      }
      {
#line 274
      v1_kern2utildqblk(& dquot->dq_dqb, & kdqblk);
      }
    }
  } else {
    {
#line 278
    lseek(h->qh_fd, (loff_t )((unsigned long )id___0 * sizeof(struct v1_disk_dqblk )),
          0);
#line 279
    tmp___2 = read(h->qh_fd, (void *)(& ddqblk), sizeof(ddqblk));
    }
    {
#line 280
    if (tmp___2 == 0L) {
#line 280
      goto case_0;
    }
#line 287
    if (tmp___2 == (ssize_t )sizeof(struct v1_disk_dqblk )) {
#line 287
      goto case_exp;
    }
#line 290
    goto switch_default;
    case_0: /* CIL Label */ 
    {
#line 285
    memset((void *)(& dquot->dq_dqb), 0, sizeof(struct util_dqblk ));
    }
#line 286
    goto switch_break;
    case_exp: /* CIL Label */ 
    {
#line 288
    v1_disk2memdqblk(& dquot->dq_dqb, & ddqblk);
    }
#line 289
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 291
    free((void *)dquot);
    }
#line 292
    return ((struct dquot *)((void *)0));
    switch_break: /* CIL Label */ ;
    }
  }
#line 295
  return (dquot);
}
}
#line 302 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v1.c"
static int v1_commit_dquot___5(struct dquot *dquot , int flags___7 ) 
{ 
  struct v1_disk_dqblk ddqblk ;
  struct quota_handle *h ;
  char *tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  struct v1_kern_dqblk kdqblk ;
  int cmd ;
  int *tmp___2 ;
  long tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;
  ssize_t tmp___6 ;

  {
#line 305
  h = dquot->dq_h;
#line 307
  if (h->qh_io_flags & 4) {
    {
#line 308
    tmp = gettext("Trying to write quota to readonly quotafile on %s\n");
#line 308
    errstr(tmp, h->qh_quotadev);
#line 309
    tmp___0 = __errno_location();
#line 309
    *tmp___0 = 1;
    }
#line 310
    return (-1);
  }
#line 312
  if (h->qh_io_flags & 1) {
#line 313
    if (kernel_iface == 3) {
      {
#line 314
      tmp___1 = vfs_set_dquot(dquot, flags___7);
      }
#line 314
      if (tmp___1 < 0) {
#line 315
        return (-1);
      }
    } else {
#line 321
      if (flags___7 == 10) {
#line 322
        cmd = 1280;
      } else
#line 323
      if (flags___7 == 5) {
#line 324
        cmd = 1792;
      } else
#line 325
      if (flags___7 & 48) {
        {
#line 326
        tmp___2 = __errno_location();
#line 326
        *tmp___2 = 22;
        }
#line 327
        return (-1);
      } else {
#line 330
        cmd = 1024;
      }
      {
#line 331
      v1_util2kerndqblk(& kdqblk, & dquot->dq_dqb);
#line 332
      tmp___3 = quotactl((cmd << 8) | (h->qh_type & 255), (char const   *)(h->qh_quotadev),
                         dquot->dq_id, (caddr_t )((void *)(& kdqblk)));
      }
#line 332
      if (tmp___3 < 0L) {
#line 334
        return (-1);
      }
    }
  } else {
    {
#line 338
    tmp___5 = check_dquot_range(dquot);
    }
#line 338
    if (tmp___5 < 0) {
      {
#line 339
      tmp___4 = __errno_location();
#line 339
      *tmp___4 = 34;
      }
#line 340
      return (-1);
    }
    {
#line 342
    v1_mem2diskdqblk(& ddqblk, & dquot->dq_dqb);
#line 343
    lseek(h->qh_fd, (loff_t )((unsigned long )dquot->dq_id * sizeof(struct v1_disk_dqblk )),
          0);
#line 344
    tmp___6 = write(h->qh_fd, (void const   *)(& ddqblk), sizeof(ddqblk));
    }
#line 344
    if ((unsigned long )tmp___6 != sizeof(ddqblk)) {
#line 345
      return (-1);
    }
  }
#line 347
  return (0);
}
}
#line 355 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v1.c"
static int v1_scan_dquots___5(struct quota_handle *h , int (*process_dquot)(struct dquot *dquot ,
                                                                            char *dqname ) ) 
{ 
  int rd ;
  int scanbufpos ;
  int scanbufsize ;
  char scanbuf[sizeof(struct v1_disk_dqblk ) * 256UL] ;
  struct v1_disk_dqblk *ddqblk ;
  struct dquot *dquot ;
  struct dquot *tmp ;
  qid_t id___0 ;
  ssize_t tmp___0 ;

  {
  {
#line 357
  scanbufpos = 0;
#line 357
  scanbufsize = 0;
#line 360
  tmp = get_empty_dquot();
#line 360
  dquot = tmp;
#line 361
  id___0 = (qid_t )0;
#line 363
  memset((void *)dquot, 0, sizeof(*dquot));
#line 364
  dquot->dq_h = h;
#line 365
  lseek(h->qh_fd, (__off64_t )0, 0);
#line 366
  id___0 = (qid_t )0;
  }
  {
#line 366
  while (1) {
    while_continue: /* CIL Label */ ;
#line 367
    if (scanbufpos >= scanbufsize) {
      {
#line 368
      tmp___0 = read(h->qh_fd, (void *)(scanbuf), sizeof(scanbuf));
#line 368
      rd = (int )tmp___0;
      }
#line 369
      if (rd < 0) {
#line 370
        goto out_err;
      } else
#line 369
      if ((unsigned long )rd % sizeof(struct v1_disk_dqblk )) {
#line 370
        goto out_err;
      }
#line 371
      if (! rd) {
#line 372
        goto while_break;
      }
#line 373
      scanbufpos = 0;
#line 374
      scanbufsize = (int )((unsigned long )rd / sizeof(struct v1_disk_dqblk ));
    }
#line 376
    ddqblk = (struct v1_disk_dqblk *)(scanbuf) + scanbufpos;
#line 377
    if ((((long )(((((ddqblk->dqb_ihardlimit | ddqblk->dqb_isoftlimit) | ddqblk->dqb_bhardlimit) | ddqblk->dqb_bsoftlimit) | ddqblk->dqb_curblocks) | ddqblk->dqb_curinodes) | ddqblk->dqb_itime) | ddqblk->dqb_btime) == 0L) {
#line 381
      goto __Cont;
    }
    {
#line 382
    v1_disk2memdqblk(& dquot->dq_dqb, ddqblk);
#line 383
    dquot->dq_id = id___0;
#line 384
    rd = (*process_dquot)(dquot, (char *)((void *)0));
    }
#line 384
    if (rd < 0) {
      {
#line 385
      free((void *)dquot);
      }
#line 386
      return (rd);
    }
    __Cont: /* CIL Label */ 
#line 366
    id___0 ++;
#line 366
    scanbufpos ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 389
  if (! rd) {
    {
#line 390
    free((void *)dquot);
    }
#line 391
    return (0);
  }
  out_err: 
  {
#line 394
  free((void *)dquot);
  }
#line 395
  return (-1);
}
}
#line 89 "/home/wheatley/newnew/temp/quota-4.01/rquota_client.c"
static int rquota_err___5(int stat___0 ) 
{ 


  {
  {
#line 92
  if (stat___0 == -1) {
#line 92
    goto case_neg_1;
  }
#line 94
  if (stat___0 == 0) {
#line 94
    goto case_0;
  }
#line 96
  if (stat___0 == 2) {
#line 96
    goto case_2;
  }
#line 98
  if (stat___0 == 1) {
#line 98
    goto case_1;
  }
#line 100
  if (stat___0 == 3) {
#line 100
    goto case_3;
  }
#line 102
  goto switch_default;
  case_neg_1: /* CIL Label */ 
#line 93
  return (-111);
  case_0: /* CIL Label */ 
#line 95
  return (-38);
  case_2: /* CIL Label */ 
#line 97
  return (-2);
  case_1: /* CIL Label */ 
#line 99
  return (0);
  case_3: /* CIL Label */ 
#line 101
  return (-1);
  switch_default: /* CIL Label */ 
#line 103
  return (-22);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 107 "/home/wheatley/newnew/temp/quota-4.01/rquota_client.c"
static int split_nfs_mount___5(char *devname , char **host , char **path ) 
{ 
  char *pathname ;

  {
#line 112
  if ((int )*devname == 91) {
    {
#line 113
    *host = devname + 1;
#line 114
    pathname = strchr((char const   *)devname, ']');
    }
#line 115
    if (! pathname) {
#line 116
      return (0);
    } else
#line 115
    if ((int )*(pathname + 1) != 58) {
#line 116
      return (0);
    }
#line 118
    if ((int )*(pathname + 2) == 40) {
#line 119
      return (0);
    }
#line 120
    *pathname = (char)0;
#line 121
    *path = pathname + 2;
#line 122
    return (1);
  }
  {
#line 124
  *host = devname;
#line 125
  pathname = strchr((char const   *)devname, ':');
  }
#line 126
  if (! pathname) {
#line 127
    return (0);
  }
#line 129
  if ((int )*(pathname + 1) == 40) {
#line 130
    return (0);
  }
#line 131
  *pathname = (char)0;
#line 132
  *path = pathname + 1;
#line 133
  return (1);
}
}
#line 41 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static char extensions___5[4][20]  = { {        (char )'u',        (char )'s',        (char )'e',        (char )'r', 
            (char )'\000'}, 
   {        (char )'g',        (char )'r',        (char )'o',        (char )'u', 
            (char )'p',        (char )'\000'}, 
   {        (char )'u',        (char )'n',        (char )'d',        (char )'e', 
            (char )'f',        (char )'i',        (char )'n',        (char )'e', 
            (char )'d',        (char )'\000'}};
#line 42 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static char *basenames___5[6]  = {      (char *)"quota",      (char *)"aquota",      (char *)"aquota",      (char *)"", 
        (char *)"",      (char *)""};
#line 43 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static char *fmtnames___5[5]  = {      (char *)"vfsold",      (char *)"vfsv0",      (char *)"vfsv1",      (char *)"rpc", 
        (char *)"xfs"};
#line 245 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static int kern2utilfmt___5(int kernfmt ) 
{ 


  {
  {
#line 248
  if (kernfmt == 1) {
#line 248
    goto case_1;
  }
#line 250
  if (kernfmt == 2) {
#line 250
    goto case_2;
  }
#line 252
  if (kernfmt == 4) {
#line 252
    goto case_4;
  }
#line 254
  if (kernfmt == 3) {
#line 254
    goto case_3;
  }
#line 247
  goto switch_break;
  case_1: /* CIL Label */ 
#line 249
  return (0);
  case_2: /* CIL Label */ 
#line 251
  return (1);
  case_4: /* CIL Label */ 
#line 253
  return (2);
  case_3: /* CIL Label */ 
#line 255
  return (5);
  switch_break: /* CIL Label */ ;
  }
#line 257
  return (-1);
}
}
#line 394 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static int hasxfsquota___5(char const   *dev , struct mntent *mnt___2 , int type ,
                           int flags___7 ) 
{ 
  u_int16_t sbflags ;
  struct fs_quota_stat info ;
  long tmp ;

  {
#line 399
  if (flags___7 & 16) {
#line 400
    return (4);
  }
  {
#line 402
  memset((void *)(& info), 0, sizeof(struct fs_quota_stat ));
#line 403
  tmp = quotactl((((88 << 8) + 5) << 8) | (type & 255), dev, (qid_t )0, (caddr_t )((void *)(& info)));
  }
#line 403
  if (! tmp) {
#line 404
    sbflags = (u_int16_t )(((int )info.qs_flags & 65280) >> 8);
#line 405
    if (type == 0) {
#line 405
      if ((int )info.qs_flags & 1) {
#line 406
        return (4);
      } else {
#line 405
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 407
    if (type == 1) {
#line 407
      if ((int )info.qs_flags & (1 << 2)) {
#line 408
        return (4);
      }
    }
  }
#line 424
  return (-1);
}
}
#line 427 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static int hasvfsmetaquota___5(char const   *dev , struct mntent *mnt___2 , int type ,
                               int flags___7 ) 
{ 
  uint32_t fmt___7 ;
  long tmp ;

  {
  {
#line 431
  tmp = quotactl((8388612 << 8) | (type & 255), dev, (qid_t )0, (caddr_t )((void *)(& fmt___7)));
  }
#line 431
  if (! tmp) {
#line 432
    return (5);
  }
#line 433
  return (-1);
}
}
#line 465 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static char *hasmntoptarg___5(char const   *optstring , char const   *opt ) 
{ 
  char *p ;
  char *tmp ;
  size_t tmp___0 ;

  {
  {
#line 467
  tmp = str_hasmntopt(optstring, opt);
#line 467
  p = tmp;
  }
#line 469
  if (! p) {
#line 470
    return ((char *)((void *)0));
  }
  {
#line 471
  tmp___0 = strlen(opt);
#line 471
  p += tmp___0;
  }
#line 472
  if ((int )*p == 61) {
#line 472
    if ((int )*(p + 1) != 44) {
#line 473
      return (p + 1);
    }
  }
#line 474
  return ((char *)((void *)0));
}
}
#line 478 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static void copy_mntoptarg___5(char *buf , char const   *optarg___0 , int buflen ) 
{ 
  char *sep ;
  char *tmp ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  long tmp___4 ;

  {
  {
#line 480
  tmp = strchr(optarg___0, ',');
#line 480
  sep = tmp;
  }
#line 482
  if (! sep) {
    {
#line 483
    tmp___3 = strlen(optarg___0);
    }
#line 483
    if ((size_t )buflen < tmp___3 + 1UL) {
#line 483
      tmp___2 = (size_t )buflen;
    } else {
      {
#line 483
      tmp___1 = strlen(optarg___0);
#line 483
      tmp___2 = tmp___1 + 1UL;
      }
    }
    {
#line 483
    sstrncpy(buf, optarg___0, tmp___2);
    }
  } else {
#line 485
    if ((long )buflen < (sep - (char *)optarg___0) + 1L) {
#line 485
      tmp___4 = (long )buflen;
    } else {
#line 485
      tmp___4 = (sep - (char *)optarg___0) + 1L;
    }
    {
#line 485
    sstrncpy(buf, optarg___0, (size_t )tmp___4);
    }
  }
#line 486
  return;
}
}
#line 491 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static int hasquota___5(char const   *dev , struct mntent *mnt___2 , int type , int flags___7 ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  struct if_dqinfo kinfo ;
  long tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;

  {
  {
#line 493
  tmp___0 = strcmp((char const   *)mnt___2->mnt_type, "gfs2");
  }
#line 493
  if (tmp___0) {
    {
#line 493
    tmp___1 = strcmp((char const   *)mnt___2->mnt_type, "xfs");
    }
#line 493
    if (! tmp___1) {
      {
#line 495
      tmp = hasxfsquota___5(dev, mnt___2, type, flags___7);
      }
#line 495
      return (tmp);
    }
  } else {
    {
#line 495
    tmp = hasxfsquota___5(dev, mnt___2, type, flags___7);
    }
#line 495
    return (tmp);
  }
  {
#line 496
  tmp___3 = strcmp((char const   *)mnt___2->mnt_type, "ocfs2");
  }
#line 496
  if (! tmp___3) {
    {
#line 497
    tmp___2 = hasvfsmetaquota___5(dev, mnt___2, type, flags___7);
    }
#line 497
    return (tmp___2);
  }
  {
#line 504
  tmp___5 = strcmp((char const   *)mnt___2->mnt_type, "ext4");
  }
#line 504
  if (! tmp___5) {
    {
#line 507
    tmp___4 = quotactl((8388613 << 8) | (type & 255), dev, (qid_t )0, (caddr_t )((void *)(& kinfo)));
    }
#line 507
    if (tmp___4 == 0L) {
#line 508
      if (kinfo.dqi_flags & 65536U) {
#line 509
        return (5);
      }
    }
  }
  {
#line 513
  tmp___6 = nfs_fstype(mnt___2->mnt_type);
  }
#line 513
  if (tmp___6) {
#line 514
    return (3);
  }
#line 516
  if (type == 0) {
    {
#line 516
    tmp___7 = hasmntopt((struct mntent  const  *)mnt___2, "usrquota");
    }
#line 516
    if (tmp___7) {
#line 517
      return (6);
    } else {
      {
#line 516
      tmp___8 = hasmntoptarg___5((char const   *)mnt___2->mnt_opts, "usrjquota");
      }
#line 516
      if (tmp___8) {
#line 517
        return (6);
      }
    }
  }
#line 518
  if (type == 1) {
    {
#line 518
    tmp___9 = hasmntopt((struct mntent  const  *)mnt___2, "grpquota");
    }
#line 518
    if (tmp___9) {
#line 519
      return (6);
    } else {
      {
#line 518
      tmp___10 = hasmntoptarg___5((char const   *)mnt___2->mnt_opts, "grpjquota");
      }
#line 518
      if (tmp___10) {
#line 519
        return (6);
      }
    }
  }
#line 520
  if (type == 0) {
    {
#line 520
    tmp___11 = hasmntopt((struct mntent  const  *)mnt___2, "quota");
    }
#line 520
    if (tmp___11) {
#line 521
      return (6);
    }
  }
#line 522
  return (-1);
}
}
#line 526 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static int check_fmtfile_ok___5(char *name , int type , int fmt___7 , int flags___7 ) 
{ 
  struct stat st ;
  int *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;
  int fd ;
  int ret ;
  int tmp___4 ;
  int *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  int *tmp___8 ;
  int *tmp___9 ;

  {
#line 528
  if (! flags___7) {
#line 529
    return (1);
  }
#line 530
  if (flags___7 & 1) {
    {
#line 533
    tmp___3 = stat((char const   */* __restrict  */)name, (struct stat */* __restrict  */)(& st));
    }
#line 533
    if (tmp___3 < 0) {
      {
#line 534
      tmp___2 = __errno_location();
      }
#line 534
      if (*tmp___2 != 2) {
        {
#line 535
        tmp = __errno_location();
#line 535
        tmp___0 = strerror(*tmp);
#line 535
        tmp___1 = gettext("Cannot stat quota file %s: %s\n");
#line 535
        errstr(tmp___1, name, tmp___0);
        }
      }
#line 536
      return (0);
    }
  }
#line 539
  if (flags___7 & 2) {
    {
#line 540
    ret = 0;
#line 542
    fd = open((char const   *)name, 0);
    }
#line 542
    if (fd >= 0) {
      {
#line 543
      tmp___4 = is_tree_qfmt(fmt___7);
      }
#line 543
      if (tmp___4) {
        {
#line 544
        ret = (*(quotafile_ops_2.check_file))(fd, type, fmt___7);
        }
      } else {
        {
#line 546
        ret = (*(quotafile_ops_1.check_file))(fd, type, fmt___7);
        }
      }
      {
#line 547
      close(fd);
      }
#line 548
      if (ret <= 0) {
#line 549
        return (0);
      }
    } else {
      {
#line 551
      tmp___8 = __errno_location();
      }
#line 551
      if (*tmp___8 != 2) {
        {
#line 551
        tmp___9 = __errno_location();
        }
#line 551
        if (*tmp___9 != 1) {
          {
#line 552
          tmp___5 = __errno_location();
#line 552
          tmp___6 = strerror(*tmp___5);
#line 552
          tmp___7 = gettext("Cannot open quotafile %s: %s\n");
#line 552
          errstr(tmp___7, name, tmp___6);
          }
#line 553
          return (0);
        }
      }
    }
  }
#line 556
  return (1);
}
}
#line 629 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static int hlist_allocated___5  =    0;
#line 630 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static struct quota_handle **hlist___5  =    (struct quota_handle **)((void *)0);
#line 735 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static int kernel_qfmt_num___5  ;
#line 736 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static int kernel_qfmt___5[6]  ;
#line 828 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static int v1_kern_quota_on___5(char const   *dev , int type ) 
{ 
  char tmp[1024] ;
  qid_t id___0 ;
  __uid_t tmp___0 ;
  __gid_t tmp___1 ;
  __uid_t tmp___2 ;
  long tmp___3 ;

  {
#line 831
  if (type == 0) {
    {
#line 831
    tmp___0 = getuid();
#line 831
    tmp___2 = tmp___0;
    }
  } else {
    {
#line 831
    tmp___1 = getgid();
#line 831
    tmp___2 = tmp___1;
    }
  }
  {
#line 831
  id___0 = tmp___2;
#line 833
  tmp___3 = quotactl((768 << 8) | (type & 255), dev, id___0, tmp);
  }
#line 833
  if (! tmp___3) {
#line 834
    return (1);
  }
#line 835
  return (0);
}
}
#line 839 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static int v2_kern_quota_on___5(char const   *dev , int type ) 
{ 
  char tmp[1024] ;
  qid_t id___0 ;
  __uid_t tmp___0 ;
  __gid_t tmp___1 ;
  __uid_t tmp___2 ;
  long tmp___3 ;

  {
#line 842
  if (type == 0) {
    {
#line 842
    tmp___0 = getuid();
#line 842
    tmp___2 = tmp___0;
    }
  } else {
    {
#line 842
    tmp___1 = getgid();
#line 842
    tmp___2 = tmp___1;
    }
  }
  {
#line 842
  id___0 = tmp___2;
#line 844
  tmp___3 = quotactl((3328 << 8) | (type & 255), dev, id___0, tmp);
  }
#line 844
  if (! tmp___3) {
#line 845
    return (1);
  }
#line 846
  return (0);
}
}
#line 850 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static int xfs_kern_quota_on___5(char const   *dev , int type ) 
{ 
  struct fs_quota_stat info ;
  long tmp ;

  {
  {
#line 854
  tmp = quotactl((((88 << 8) + 5) << 8) | (type & 255), dev, (qid_t )0, (caddr_t )((void *)(& info)));
  }
#line 854
  if (! tmp) {
#line 855
    if (type == 0) {
#line 855
      if ((int )info.qs_flags & 1) {
#line 856
        return (1);
      }
    }
#line 857
    if (type == 1) {
#line 857
      if ((int )info.qs_flags & (1 << 2)) {
#line 858
        return (1);
      }
    }
  }
#line 860
  return (0);
}
}
#line 921 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static int mnt_entries_cnt___5  ;
#line 922 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static struct mount_entry *mnt_entries___5  ;
#line 923 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static int check_dirs_cnt___5  ;
#line 923 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static int act_checked___5  ;
#line 924 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static struct searched_dir *check_dirs___5  ;
#line 927 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static int cache_mnt_table___5(int flags___7 ) 
{ 
  FILE *mntf ;
  struct mntent *mnt___2 ;
  struct stat st ;
  struct statfs fsstat ;
  int allocated ;
  int i ;
  dev_t dev ;
  char mntpointbuf[4096] ;
  int autofsdircnt ;
  int autofsdir_allocated ;
  char **autofsdir ;
  char *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  char const   *devname ;
  char *opt ;
  int qfmt[2] ;
  char *tmp___2 ;
  int slen ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  void *tmp___6 ;
  size_t tmp___7 ;
  void *tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char loopdev[4096] ;
  char *tmp___13 ;
  int *tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;
  int *tmp___18 ;
  char *tmp___19 ;
  char *tmp___20 ;
  int tmp___21 ;
  int *tmp___22 ;
  char *tmp___23 ;
  char *tmp___24 ;
  int tmp___25 ;
  char *tmp___26 ;
  int tmp___27 ;
  int *tmp___28 ;
  char *tmp___29 ;
  char *tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;
  void *tmp___34 ;
  char *tmp___35 ;

  {
  {
#line 933
  allocated = 0;
#line 933
  i = 0;
#line 934
  dev = (dev_t )0;
#line 940
  mntf = setmntent("/proc/mounts", "r");
  }
#line 941
  if (mntf) {
#line 942
    goto alloc;
  }
  {
#line 944
  mntf = setmntent("/etc/mtab", "r");
  }
#line 945
  if (mntf) {
#line 946
    goto alloc;
  }
  {
#line 948
  mntf = setmntent("/etc/fstab", "r");
  }
#line 948
  if (! mntf) {
    {
#line 949
    tmp = gettext("Cannot open any file with mount points.\n");
#line 949
    errstr(tmp);
    }
#line 950
    return (-1);
  }
  alloc: 
  {
#line 954
  tmp___0 = smalloc(sizeof(struct mount_entry ) * 16UL);
#line 954
  mnt_entries___5 = (struct mount_entry *)tmp___0;
#line 955
  mnt_entries_cnt___5 = 0;
#line 956
  allocated += 16;
#line 958
  tmp___1 = smalloc(sizeof(char *) * 16UL);
#line 958
  autofsdir = (char **)tmp___1;
#line 959
  autofsdircnt = 0;
#line 960
  autofsdir_allocated = 16;
  }
  {
#line 961
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 961
    mnt___2 = getmntent(mntf);
    }
#line 961
    if (! mnt___2) {
#line 961
      goto while_break;
    }
    {
#line 966
    devname = get_device_name((char const   *)mnt___2->mnt_fsname);
    }
#line 966
    if (! devname) {
      {
#line 967
      tmp___2 = gettext("Cannot get device name for %s\n");
#line 967
      errstr(tmp___2, mnt___2->mnt_fsname);
      }
#line 968
      goto while_continue;
    }
#line 972
    i = 0;
    {
#line 972
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 972
      if (! (i < autofsdircnt)) {
#line 972
        goto while_break___0;
      }
      {
#line 973
      tmp___3 = strlen((char const   *)*(autofsdir + i));
#line 973
      slen = (int )tmp___3;
#line 975
      tmp___4 = strlen((char const   *)mnt___2->mnt_dir);
      }
#line 975
      if ((size_t )slen <= tmp___4) {
        {
#line 975
        tmp___5 = strncmp((char const   *)*(autofsdir + i), (char const   *)mnt___2->mnt_dir,
                          (size_t )slen);
        }
#line 975
        if (! tmp___5) {
#line 976
          goto while_break___0;
        }
      }
#line 972
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 978
    if (i < autofsdircnt) {
      {
#line 979
      free((void *)((char *)devname));
      }
#line 980
      goto while_continue;
    }
#line 983
    if (flags___7 & 2) {
      {
#line 983
      tmp___9 = strcmp((char const   *)mnt___2->mnt_type, "autofs");
      }
#line 983
      if (! tmp___9) {
#line 984
        if (autofsdircnt == autofsdir_allocated) {
          {
#line 985
          autofsdir_allocated += 16;
#line 986
          tmp___6 = srealloc((void *)autofsdir, (unsigned long )autofsdir_allocated * sizeof(char *));
#line 986
          autofsdir = (char **)tmp___6;
          }
        }
        {
#line 988
        tmp___7 = strlen((char const   *)mnt___2->mnt_dir);
#line 988
        tmp___8 = smalloc(tmp___7 + 2UL);
#line 988
        *(autofsdir + autofsdircnt) = (char *)tmp___8;
#line 989
        strcpy((char */* __restrict  */)*(autofsdir + autofsdircnt), (char const   */* __restrict  */)mnt___2->mnt_dir);
#line 990
        strcat((char */* __restrict  */)*(autofsdir + autofsdircnt), (char const   */* __restrict  */)"/");
#line 991
        autofsdircnt ++;
#line 992
        free((void *)((char *)devname));
        }
#line 993
        goto while_continue;
      }
    }
#line 996
    if (flags___7 & 8) {
      {
#line 996
      tmp___10 = nfs_fstype(mnt___2->mnt_type);
      }
#line 996
      if (tmp___10) {
        {
#line 997
        free((void *)((char *)devname));
        }
#line 998
        goto while_continue;
      }
    }
    {
#line 1000
    tmp___11 = hasmntopt((struct mntent  const  *)mnt___2, "noquota");
    }
#line 1000
    if (tmp___11) {
      {
#line 1001
      free((void *)((char *)devname));
      }
#line 1002
      goto while_continue;
    }
    {
#line 1004
    tmp___12 = hasmntopt((struct mntent  const  *)mnt___2, "bind");
    }
#line 1004
    if (tmp___12) {
      {
#line 1005
      free((void *)((char *)devname));
      }
#line 1006
      goto while_continue;
    }
    {
#line 1008
    opt = hasmntoptarg___5((char const   *)mnt___2->mnt_opts, "loop");
    }
#line 1008
    if (opt) {
      {
#line 1011
      copy_mntoptarg___5(opt, (char const   *)(loopdev), 4096);
#line 1012
      free((void *)((char *)devname));
#line 1013
      tmp___13 = sstrdup((char const   *)(loopdev));
#line 1013
      devname = (char const   *)tmp___13;
      }
    }
    {
#line 1018
    qfmt[0] = hasquota___5(devname, mnt___2, 0, flags___7);
#line 1019
    qfmt[1] = hasquota___5(devname, mnt___2, 1, flags___7);
    }
#line 1020
    if (qfmt[0] < 0) {
#line 1020
      if (qfmt[1] < 0) {
        {
#line 1021
        free((void *)((char *)devname));
        }
#line 1022
        goto while_continue;
      }
    }
    {
#line 1025
    tmp___17 = realpath((char const   */* __restrict  */)mnt___2->mnt_dir, (char */* __restrict  */)(mntpointbuf));
    }
#line 1025
    if (! tmp___17) {
      {
#line 1026
      tmp___14 = __errno_location();
#line 1026
      tmp___15 = strerror(*tmp___14);
#line 1026
      tmp___16 = gettext("Cannot resolve mountpoint path %s: %s\n");
#line 1026
      errstr(tmp___16, mnt___2->mnt_dir, tmp___15);
#line 1027
      free((void *)((char *)devname));
      }
#line 1028
      goto while_continue;
    }
    {
#line 1031
    tmp___21 = statfs((char const   *)(mntpointbuf), & fsstat);
    }
#line 1031
    if (tmp___21 != 0) {
      {
#line 1032
      tmp___18 = __errno_location();
#line 1032
      tmp___19 = strerror(*tmp___18);
#line 1032
      tmp___20 = gettext("Cannot statfs() %s: %s\n");
#line 1032
      errstr(tmp___20, mntpointbuf, tmp___19);
#line 1033
      free((void *)((char *)devname));
      }
#line 1034
      goto while_continue;
    }
#line 1037
    if (fsstat.f_blocks == 0UL) {
#line 1037
      if (fsstat.f_bfree == 0UL) {
#line 1037
        if (fsstat.f_bavail == 0UL) {
          {
#line 1038
          free((void *)((char *)devname));
          }
#line 1039
          goto while_continue;
        }
      }
    }
    {
#line 1042
    tmp___27 = nfs_fstype(mnt___2->mnt_type);
    }
#line 1042
    if (! tmp___27) {
      {
#line 1043
      tmp___25 = stat((char const   */* __restrict  */)devname, (struct stat */* __restrict  */)(& st));
      }
#line 1043
      if (tmp___25 < 0) {
        {
#line 1044
        tmp___22 = __errno_location();
#line 1044
        tmp___23 = strerror(*tmp___22);
#line 1044
        tmp___24 = gettext("Cannot stat() mounted device %s: %s\n");
#line 1044
        errstr(tmp___24, devname, tmp___23);
#line 1045
        free((void *)((char *)devname));
        }
#line 1046
        goto while_continue;
      }
#line 1048
      if (! ((st.st_mode & 61440U) == 24576U)) {
#line 1048
        if (! ((st.st_mode & 61440U) == 8192U)) {
          {
#line 1049
          tmp___26 = gettext("Device (%s) filesystem is mounted on unsupported device type. Skipping.\n");
#line 1049
          errstr(tmp___26, devname);
#line 1050
          free((void *)((char *)devname));
          }
#line 1051
          goto while_continue;
        }
      }
#line 1053
      dev = st.st_rdev;
#line 1054
      i = 0;
      {
#line 1054
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1054
        if (i < mnt_entries_cnt___5) {
#line 1054
          if (! ((mnt_entries___5 + i)->me_dev != dev)) {
#line 1054
            goto while_break___1;
          }
        } else {
#line 1054
          goto while_break___1;
        }
#line 1054
        i ++;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
    {
#line 1057
    tmp___33 = nfs_fstype(mnt___2->mnt_type);
    }
#line 1057
    if (tmp___33) {
#line 1057
      goto _L;
    } else
#line 1057
    if (i == mnt_entries_cnt___5) {
      _L: /* CIL Label */ 
      {
#line 1058
      tmp___31 = stat((char const   */* __restrict  */)mnt___2->mnt_dir, (struct stat */* __restrict  */)(& st));
      }
#line 1058
      if (tmp___31 < 0) {
        {
#line 1059
        tmp___28 = __errno_location();
#line 1059
        tmp___29 = strerror(*tmp___28);
#line 1059
        tmp___30 = gettext("Cannot stat() mountpoint %s: %s\n");
#line 1059
        errstr(tmp___30, mnt___2->mnt_dir, tmp___29);
#line 1060
        free((void *)((char *)devname));
        }
#line 1061
        goto while_continue;
      }
      {
#line 1063
      tmp___32 = nfs_fstype(mnt___2->mnt_type);
      }
#line 1063
      if (tmp___32) {
#line 1065
        dev = st.st_dev;
#line 1066
        if (! (flags___7 & 32)) {
#line 1067
          i = 0;
          {
#line 1067
          while (1) {
            while_continue___2: /* CIL Label */ ;
#line 1067
            if (i < mnt_entries_cnt___5) {
#line 1067
              if (! ((mnt_entries___5 + i)->me_dev != dev)) {
#line 1067
                goto while_break___2;
              }
            } else {
#line 1067
              goto while_break___2;
            }
#line 1067
            i ++;
          }
          while_break___2: /* CIL Label */ ;
          }
        } else {
#line 1070
          i = mnt_entries_cnt___5;
        }
      }
    }
#line 1073
    if (i == mnt_entries_cnt___5) {
#line 1074
      if (allocated == mnt_entries_cnt___5) {
        {
#line 1075
        allocated += 16;
#line 1076
        tmp___34 = srealloc((void *)mnt_entries___5, (unsigned long )allocated * sizeof(struct mount_entry ));
#line 1076
        mnt_entries___5 = (struct mount_entry *)tmp___34;
        }
      }
      {
#line 1078
      (mnt_entries___5 + i)->me_type = sstrdup((char const   *)mnt___2->mnt_type);
#line 1079
      (mnt_entries___5 + i)->me_opts = sstrdup((char const   *)mnt___2->mnt_opts);
#line 1080
      (mnt_entries___5 + i)->me_dev = dev;
#line 1081
      (mnt_entries___5 + i)->me_ino = st.st_ino;
#line 1082
      (mnt_entries___5 + i)->me_devname = devname;
#line 1083
      tmp___35 = sstrdup((char const   *)(mntpointbuf));
#line 1083
      (mnt_entries___5 + i)->me__dir = (char const   *)tmp___35;
#line 1084
      (mnt_entries___5 + i)->me_dir = (char const   *)((void *)0);
#line 1085
      memcpy((void */* __restrict  */)(& (mnt_entries___5 + i)->me_qfmt), (void const   */* __restrict  */)(qfmt),
             sizeof(qfmt));
#line 1086
      mnt_entries_cnt___5 ++;
      }
    } else {
      {
#line 1089
      free((void *)((char *)devname));
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1091
  endmntent(mntf);
#line 1093
  i = 0;
  }
  {
#line 1093
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 1093
    if (! (i < autofsdircnt)) {
#line 1093
      goto while_break___3;
    }
    {
#line 1094
    free((void *)*(autofsdir + i));
#line 1093
    i ++;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 1095
  free((void *)autofsdir);
  }
#line 1096
  return (0);
}
}
#line 1100 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static char const   *find_dir_mntpoint___5(struct stat *st ) 
{ 
  int i ;

  {
#line 1104
  i = 0;
  {
#line 1104
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1104
    if (! (i < mnt_entries_cnt___5)) {
#line 1104
      goto while_break;
    }
#line 1105
    if ((mnt_entries___5 + i)->me_dev == st->st_dev) {
#line 1106
      st->st_ino = (mnt_entries___5 + i)->me_ino;
#line 1107
      return ((mnt_entries___5 + i)->me__dir);
    }
#line 1104
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1109
  return ((char const   *)((void *)0));
}
}
#line 1113 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static int process_dirs___5(int dcnt , char **dirs , int flags___7 ) 
{ 
  struct stat st ;
  int i ;
  char mntpointbuf[4096] ;
  void *tmp ;
  char *devname ;
  char const   *tmp___0 ;
  char *tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  int *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  char const   *realmnt ;
  char *tmp___12 ;
  int *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  int mentry ;
  char *tmp___17 ;
  char *tmp___18 ;
  char *tmp___19 ;
  char *tmp___20 ;

  {
#line 1119
  check_dirs_cnt___5 = 0;
#line 1120
  act_checked___5 = -1;
#line 1121
  if (dcnt) {
    {
#line 1122
    tmp = smalloc(sizeof(struct searched_dir ) * (unsigned long )dcnt);
#line 1122
    check_dirs___5 = (struct searched_dir *)tmp;
#line 1123
    i = 0;
    }
    {
#line 1123
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1123
      if (! (i < dcnt)) {
#line 1123
        goto while_break;
      }
      {
#line 1124
      tmp___10 = strncmp((char const   *)*(dirs + i), "UUID=", (size_t )5);
      }
#line 1124
      if (tmp___10) {
        {
#line 1124
        tmp___11 = strncmp((char const   *)*(dirs + i), "LABEL=", (size_t )6);
        }
#line 1124
        if (tmp___11) {
          {
#line 1139
          tmp___9 = stat((char const   */* __restrict  */)*(dirs + i), (struct stat */* __restrict  */)(& st));
          }
#line 1139
          if (tmp___9 < 0) {
            {
#line 1140
            tmp___6 = __errno_location();
#line 1140
            tmp___7 = strerror(*tmp___6);
#line 1140
            tmp___8 = gettext("Cannot stat() given mountpoint %s: %s\nSkipping...\n");
#line 1140
            errstr(tmp___8, *(dirs + i), tmp___7);
            }
#line 1141
            goto __Cont;
          }
        } else {
          _L: /* CIL Label */ 
          {
#line 1125
          tmp___0 = get_device_name((char const   *)*(dirs + i));
#line 1125
          devname = (char *)tmp___0;
          }
#line 1127
          if (! devname) {
            {
#line 1128
            tmp___1 = gettext("Cannot find a device with %s.\nSkipping...\n");
#line 1128
            errstr(tmp___1, *(dirs + i));
            }
#line 1129
            goto __Cont;
          }
          {
#line 1131
          tmp___5 = stat((char const   */* __restrict  */)devname, (struct stat */* __restrict  */)(& st));
          }
#line 1131
          if (tmp___5 < 0) {
            {
#line 1132
            tmp___2 = __errno_location();
#line 1132
            tmp___3 = strerror(*tmp___2);
#line 1132
            tmp___4 = gettext("Cannot stat() a mountpoint with %s: %s\nSkipping...\n");
#line 1132
            errstr(tmp___4, *(dirs + i), tmp___3);
#line 1133
            free((void *)devname);
            }
#line 1134
            goto __Cont;
          }
          {
#line 1136
          free((void *)devname);
          }
        }
      } else {
#line 1124
        goto _L;
      }
#line 1143
      (check_dirs___5 + check_dirs_cnt___5)->sd_dir = (st.st_mode & 61440U) == 16384U;
#line 1144
      if ((st.st_mode & 61440U) == 16384U) {
#line 1145
        realmnt = (char const   *)*(dirs + i);
#line 1148
        if (flags___7 & 1) {
          {
#line 1148
          realmnt = find_dir_mntpoint___5(& st);
          }
#line 1148
          if (! realmnt) {
#line 1149
            if (! (flags___7 & 4)) {
              {
#line 1150
              tmp___12 = gettext("Cannot find a filesystem mountpoint for directory %s\n");
#line 1150
              errstr(tmp___12, *(dirs + i));
              }
            }
#line 1151
            goto __Cont;
          }
        }
        {
#line 1153
        (check_dirs___5 + check_dirs_cnt___5)->sd_dev = st.st_dev;
#line 1154
        (check_dirs___5 + check_dirs_cnt___5)->sd_ino = st.st_ino;
#line 1155
        tmp___16 = realpath((char const   */* __restrict  */)realmnt, (char */* __restrict  */)(mntpointbuf));
        }
#line 1155
        if (! tmp___16) {
          {
#line 1156
          tmp___13 = __errno_location();
#line 1156
          tmp___14 = strerror(*tmp___13);
#line 1156
          tmp___15 = gettext("Cannot resolve path %s: %s\n");
#line 1156
          errstr(tmp___15, realmnt, tmp___14);
          }
#line 1157
          goto __Cont;
        }
      } else
#line 1160
      if ((st.st_mode & 61440U) == 24576U) {
#line 1160
        goto _L___0;
      } else
#line 1160
      if ((st.st_mode & 61440U) == 8192U) {
        _L___0: /* CIL Label */ 
#line 1163
        (check_dirs___5 + check_dirs_cnt___5)->sd_dev = st.st_rdev;
#line 1164
        mentry = 0;
        {
#line 1164
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 1164
          if (mentry < mnt_entries_cnt___5) {
#line 1164
            if (! ((mnt_entries___5 + mentry)->me_dev != st.st_rdev)) {
#line 1164
              goto while_break___0;
            }
          } else {
#line 1164
            goto while_break___0;
          }
#line 1164
          mentry ++;
        }
        while_break___0: /* CIL Label */ ;
        }
#line 1165
        if (mentry == mnt_entries_cnt___5) {
#line 1166
          if (! (flags___7 & 4)) {
            {
#line 1167
            tmp___17 = gettext("Cannot find mountpoint for device %s\n");
#line 1167
            errstr(tmp___17, *(dirs + i));
            }
          }
#line 1168
          goto __Cont;
        }
        {
#line 1170
        sstrncpy(mntpointbuf, (mnt_entries___5 + mentry)->me__dir, (size_t )4095);
        }
      } else {
        {
#line 1173
        tmp___18 = gettext("Specified path %s is not directory nor device.\n");
#line 1173
        errstr(tmp___18, *(dirs + i));
        }
#line 1174
        goto __Cont;
      }
      {
#line 1176
      tmp___19 = sstrdup((char const   *)(mntpointbuf));
#line 1176
      (check_dirs___5 + check_dirs_cnt___5)->sd_name = (char const   *)tmp___19;
#line 1177
      check_dirs_cnt___5 ++;
      }
      __Cont: /* CIL Label */ 
#line 1123
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 1179
    if (! check_dirs_cnt___5) {
#line 1180
      if (! (flags___7 & 4)) {
        {
#line 1181
        tmp___20 = gettext("No correct mountpoint specified.\n");
#line 1181
        errstr(tmp___20);
        }
      }
      {
#line 1182
      free((void *)check_dirs___5);
      }
#line 1183
      return (-1);
    }
  }
#line 1186
  return (0);
}
}
#line 1204 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static int find_next_entry_all___5(int *pos ) 
{ 
  char *tmp ;

  {
  {
#line 1206
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1206
    act_checked___5 ++;
#line 1206
    if (! (act_checked___5 < mnt_entries_cnt___5)) {
#line 1206
      goto while_break;
    }
    {
#line 1207
    tmp = str_hasmntopt((char const   *)(mnt_entries___5 + act_checked___5)->me_opts,
                        "noauto");
    }
#line 1207
    if (! tmp) {
#line 1208
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1210
  if (act_checked___5 >= mnt_entries_cnt___5) {
#line 1211
    return (0);
  }
#line 1212
  *pos = act_checked___5;
#line 1213
  return (1);
}
}
#line 1217 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static int find_next_entry_sel___5(int *pos ) 
{ 
  int i ;
  struct searched_dir *sd ;
  char *tmp ;

  {
  restart: 
#line 1223
  act_checked___5 ++;
#line 1223
  if (act_checked___5 == check_dirs_cnt___5) {
#line 1224
    return (0);
  }
#line 1225
  sd = check_dirs___5 + act_checked___5;
#line 1226
  i = 0;
  {
#line 1226
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1226
    if (! (i < mnt_entries_cnt___5)) {
#line 1226
      goto while_break;
    }
#line 1227
    if (sd->sd_dir) {
#line 1228
      if (sd->sd_dev == (mnt_entries___5 + i)->me_dev) {
#line 1228
        if (sd->sd_ino == (mnt_entries___5 + i)->me_ino) {
#line 1229
          goto while_break;
        }
      }
    } else
#line 1232
    if (sd->sd_dev == (mnt_entries___5 + i)->me_dev) {
#line 1233
      goto while_break;
    }
#line 1226
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1235
  if (i == mnt_entries_cnt___5) {
    {
#line 1236
    tmp = gettext("Mountpoint (or device) %s not found or has no quota enabled.\n");
#line 1236
    errstr(tmp, sd->sd_name);
    }
#line 1237
    goto restart;
  }
#line 1239
  *pos = i;
#line 1240
  return (1);
}
}
#line 45 "/home/wheatley/newnew/temp/quota-4.01/quotaio_tree.c"
static int get_index___5(qid_t id___0 , int depth ) 
{ 


  {
#line 47
  return ((int )((id___0 >> ((4 - depth) - 1) * 8) & 255U));
}
}
#line 51 "/home/wheatley/newnew/temp/quota-4.01/quotaio_tree.c"
static void read_blk___5(struct quota_handle *h , uint blk , dqbuf_t buf ) 
{ 
  int err ;
  ssize_t tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 55
  lseek(h->qh_fd, (__off64_t )(blk << 10), 0);
#line 56
  tmp = read(h->qh_fd, (void *)buf, (size_t )(1 << 10));
#line 56
  err = (int )tmp;
  }
#line 57
  if (err < 0) {
    {
#line 58
    tmp___0 = __errno_location();
#line 58
    tmp___1 = strerror(*tmp___0);
#line 58
    tmp___2 = gettext("Cannot read block %u: %s\n");
#line 58
    die(2, tmp___2, blk, tmp___1);
    }
  } else
#line 59
  if (err != 1 << 10) {
    {
#line 60
    memset((void *)(buf + err), 0, (size_t )((1 << 10) - err));
    }
  }
#line 61
  return;
}
}
#line 64 "/home/wheatley/newnew/temp/quota-4.01/quotaio_tree.c"
static int write_blk___5(struct quota_handle *h , uint blk , dqbuf_t buf ) 
{ 
  int err ;
  ssize_t tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  int *tmp___3 ;

  {
  {
#line 68
  lseek(h->qh_fd, (__off64_t )(blk << 10), 0);
#line 69
  tmp = write(h->qh_fd, (void const   *)buf, (size_t )(1 << 10));
#line 69
  err = (int )tmp;
  }
#line 70
  if (err < 0) {
    {
#line 70
    tmp___3 = __errno_location();
    }
#line 70
    if (*tmp___3 != 28) {
      {
#line 71
      tmp___0 = __errno_location();
#line 71
      tmp___1 = strerror(*tmp___0);
#line 71
      tmp___2 = gettext("Cannot write block (%u): %s\n");
#line 71
      die(2, tmp___2, blk, tmp___1);
      }
    }
  }
#line 72
  if (err != 1 << 10) {
#line 73
    return (-28);
  }
#line 74
  return (0);
}
}
#line 78 "/home/wheatley/newnew/temp/quota-4.01/quotaio_tree.c"
static int get_free_dqblk___5(struct quota_handle *h ) 
{ 
  dqbuf_t buf ;
  void *tmp ;
  struct qt_disk_dqdbheader *dh ;
  struct qtree_mem_dqinfo *info ;
  int blk ;
  char *tmp___0 ;
  int tmp___1 ;
  unsigned int tmp___2 ;

  {
  {
#line 80
  tmp = smalloc((size_t )(1 << 10));
#line 80
  buf = (dqbuf_t )tmp;
#line 81
  dh = (struct qt_disk_dqdbheader *)buf;
#line 82
  info = & h->qh_info.u.v2_mdqi.dqi_qtree;
  }
#line 85
  if (info->dqi_free_blk) {
    {
#line 86
    blk = (int )info->dqi_free_blk;
#line 87
    read_blk___5(h, (uint )blk, buf);
#line 88
    info->dqi_free_blk = dh->dqdh_next_free;
    }
  } else {
    {
#line 91
    memset((void *)buf, 0, (size_t )(1 << 10));
#line 92
    tmp___1 = write_blk___5(h, info->dqi_blocks, buf);
    }
#line 92
    if (tmp___1 < 0) {
      {
#line 93
      free((void *)buf);
#line 94
      tmp___0 = gettext("Cannot allocate new quota block (out of disk space).\n");
#line 94
      errstr(tmp___0);
      }
#line 95
      return (-28);
    }
#line 97
    tmp___2 = info->dqi_blocks;
#line 97
    (info->dqi_blocks) ++;
#line 97
    blk = (int )tmp___2;
  }
  {
#line 99
  mark_quotafile_info_dirty(h);
#line 100
  free((void *)buf);
  }
#line 101
  return (blk);
}
}
#line 105 "/home/wheatley/newnew/temp/quota-4.01/quotaio_tree.c"
static void put_free_dqblk___5(struct quota_handle *h , dqbuf_t buf , uint blk ) 
{ 
  struct qt_disk_dqdbheader *dh ;
  struct qtree_mem_dqinfo *info ;

  {
  {
#line 107
  dh = (struct qt_disk_dqdbheader *)buf;
#line 108
  info = & h->qh_info.u.v2_mdqi.dqi_qtree;
#line 110
  dh->dqdh_next_free = info->dqi_free_blk;
#line 111
  dh->dqdh_prev_free = (__u32 )0;
#line 112
  dh->dqdh_entries = (__u16 )0;
#line 113
  info->dqi_free_blk = blk;
#line 114
  mark_quotafile_info_dirty(h);
#line 115
  write_blk___5(h, blk, buf);
  }
#line 116
  return;
}
}
#line 119 "/home/wheatley/newnew/temp/quota-4.01/quotaio_tree.c"
static void remove_free_dqentry___5(struct quota_handle *h , dqbuf_t buf , uint blk ) 
{ 
  dqbuf_t tmpbuf ;
  void *tmp ;
  struct qt_disk_dqdbheader *dh ;
  uint nextblk ;
  uint prevblk ;
  u_int32_t tmp___0 ;

  {
  {
#line 121
  tmp = smalloc((size_t )(1 << 10));
#line 121
  tmpbuf = (dqbuf_t )tmp;
#line 122
  dh = (struct qt_disk_dqdbheader *)buf;
#line 123
  nextblk = dh->dqdh_next_free;
#line 123
  prevblk = dh->dqdh_prev_free;
  }
#line 127
  if (nextblk) {
    {
#line 128
    read_blk___5(h, nextblk, tmpbuf);
#line 129
    ((struct qt_disk_dqdbheader *)tmpbuf)->dqdh_prev_free = dh->dqdh_prev_free;
#line 130
    write_blk___5(h, nextblk, tmpbuf);
    }
  }
#line 132
  if (prevblk) {
    {
#line 133
    read_blk___5(h, prevblk, tmpbuf);
#line 134
    ((struct qt_disk_dqdbheader *)tmpbuf)->dqdh_next_free = dh->dqdh_next_free;
#line 135
    write_blk___5(h, prevblk, tmpbuf);
    }
  } else {
    {
#line 138
    h->qh_info.u.v2_mdqi.dqi_qtree.dqi_free_entry = nextblk;
#line 139
    mark_quotafile_info_dirty(h);
    }
  }
  {
#line 141
  free((void *)tmpbuf);
#line 142
  tmp___0 = (__u32 )0;
#line 142
  dh->dqdh_prev_free = tmp___0;
#line 142
  dh->dqdh_next_free = tmp___0;
#line 143
  write_blk___5(h, blk, buf);
  }
#line 144
  return;
}
}
#line 147 "/home/wheatley/newnew/temp/quota-4.01/quotaio_tree.c"
static void insert_free_dqentry___5(struct quota_handle *h , dqbuf_t buf , uint blk ) 
{ 
  dqbuf_t tmpbuf ;
  void *tmp ;
  struct qt_disk_dqdbheader *dh ;
  struct qtree_mem_dqinfo *info ;

  {
  {
#line 149
  tmp = smalloc((size_t )(1 << 10));
#line 149
  tmpbuf = (dqbuf_t )tmp;
#line 150
  dh = (struct qt_disk_dqdbheader *)buf;
#line 151
  info = & h->qh_info.u.v2_mdqi.dqi_qtree;
#line 153
  dh->dqdh_next_free = info->dqi_free_entry;
#line 154
  dh->dqdh_prev_free = (__u32 )0;
#line 155
  write_blk___5(h, blk, buf);
  }
#line 156
  if (info->dqi_free_entry) {
    {
#line 157
    read_blk___5(h, info->dqi_free_entry, tmpbuf);
#line 158
    ((struct qt_disk_dqdbheader *)tmpbuf)->dqdh_prev_free = blk;
#line 159
    write_blk___5(h, info->dqi_free_entry, tmpbuf);
    }
  }
  {
#line 161
  free((void *)tmpbuf);
#line 162
  info->dqi_free_entry = blk;
#line 163
  mark_quotafile_info_dirty(h);
  }
#line 164
  return;
}
}
#line 167 "/home/wheatley/newnew/temp/quota-4.01/quotaio_tree.c"
static uint find_free_dqentry___5(struct quota_handle *h , struct dquot *dquot , int *err ) 
{ 
  int blk ;
  int i ;
  struct qt_disk_dqdbheader *dh ;
  struct qtree_mem_dqinfo *info ;
  char *ddquot ;
  dqbuf_t buf ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;

  {
  {
#line 171
  info = & h->qh_info.u.v2_mdqi.dqi_qtree;
#line 175
  *err = 0;
#line 176
  tmp = smalloc((size_t )(1 << 10));
#line 176
  buf = (dqbuf_t )tmp;
#line 177
  dh = (struct qt_disk_dqdbheader *)buf;
  }
#line 178
  if (info->dqi_free_entry) {
    {
#line 179
    blk = (int )info->dqi_free_entry;
#line 180
    read_blk___5(h, (uint )blk, buf);
    }
  } else {
    {
#line 183
    blk = get_free_dqblk___5(h);
    }
#line 184
    if (blk < 0) {
      {
#line 185
      free((void *)buf);
#line 186
      *err = blk;
      }
#line 187
      return ((uint )0);
    }
    {
#line 189
    memset((void *)buf, 0, (size_t )(1 << 10));
#line 190
    info->dqi_free_entry = (unsigned int )blk;
#line 191
    mark_quotafile_info_dirty(h);
    }
  }
  {
#line 193
  tmp___0 = qtree_dqstr_in_blk(info);
  }
#line 193
  if ((int )dh->dqdh_entries + 1 >= tmp___0) {
    {
#line 194
    remove_free_dqentry___5(h, buf, (uint )blk);
    }
  }
#line 195
  dh->dqdh_entries = (__u16 )((int )dh->dqdh_entries + 1);
#line 197
  ddquot = buf + sizeof(struct qt_disk_dqdbheader );
#line 198
  i = 0;
  {
#line 198
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 198
    tmp___1 = qtree_dqstr_in_blk(info);
    }
#line 198
    if (i < tmp___1) {
      {
#line 198
      tmp___2 = qtree_entry_unused(info, ddquot);
      }
#line 198
      if (tmp___2) {
#line 198
        goto while_break;
      }
    } else {
#line 198
      goto while_break;
    }
#line 198
    i ++;
#line 198
    ddquot += info->dqi_entry_size;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 201
  tmp___4 = qtree_dqstr_in_blk(info);
  }
#line 201
  if (i == tmp___4) {
    {
#line 202
    tmp___3 = gettext("find_free_dqentry(): Data block full but it shouldn\'t.\n");
#line 202
    die(2, tmp___3);
    }
  }
  {
#line 203
  write_blk___5(h, (uint )blk, buf);
#line 204
  dquot->dq_dqb.u.v2_mdqb.dqb_off = (loff_t )(((unsigned long )(blk << 10) + sizeof(struct qt_disk_dqdbheader )) + (unsigned long )((unsigned int )i * info->dqi_entry_size));
#line 207
  free((void *)buf);
  }
#line 208
  return ((uint )blk);
}
}
#line 212 "/home/wheatley/newnew/temp/quota-4.01/quotaio_tree.c"
static int do_insert_tree___5(struct quota_handle *h , struct dquot *dquot , uint *treeblk ,
                              int depth ) 
{ 
  dqbuf_t buf ;
  int newson ;
  int newact ;
  u_int32_t *ref ;
  uint newblk ;
  int ret ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;

  {
  {
#line 215
  newson = 0;
#line 215
  newact = 0;
#line 218
  ret = 0;
#line 220
  tmp = smalloc((size_t )(1 << 10));
#line 220
  buf = (dqbuf_t )tmp;
  }
#line 221
  if (! *treeblk) {
    {
#line 222
    ret = get_free_dqblk___5(h);
    }
#line 223
    if (ret < 0) {
#line 224
      goto out_buf;
    }
    {
#line 225
    *treeblk = (uint )ret;
#line 226
    memset((void *)buf, 0, (size_t )(1 << 10));
#line 227
    newact = 1;
    }
  } else {
    {
#line 230
    read_blk___5(h, *treeblk, buf);
    }
  }
  {
#line 231
  ref = (u_int32_t *)buf;
#line 232
  tmp___0 = get_index___5(dquot->dq_id, depth);
#line 232
  newblk = *(ref + tmp___0);
  }
#line 233
  if (! newblk) {
#line 234
    newson = 1;
  }
#line 235
  if (depth == 3) {
#line 236
    if (newblk) {
      {
#line 237
      tmp___1 = get_index___5(dquot->dq_id, depth);
#line 237
      tmp___2 = gettext("Inserting already present quota entry (block %u).\n");
#line 237
      die(2, tmp___2, *(ref + tmp___1));
      }
    }
    {
#line 239
    newblk = find_free_dqentry___5(h, dquot, & ret);
    }
  } else {
    {
#line 242
    ret = do_insert_tree___5(h, dquot, & newblk, depth + 1);
    }
  }
#line 243
  if (newson) {
#line 243
    if (ret >= 0) {
      {
#line 244
      tmp___3 = get_index___5(dquot->dq_id, depth);
#line 244
      *(ref + tmp___3) = newblk;
#line 245
      write_blk___5(h, *treeblk, buf);
      }
    } else {
#line 243
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 247
  if (newact) {
#line 247
    if (ret < 0) {
      {
#line 248
      put_free_dqblk___5(h, buf, *treeblk);
      }
    }
  }
  out_buf: 
  {
#line 250
  free((void *)buf);
  }
#line 251
  return (ret);
}
}
#line 255 "/home/wheatley/newnew/temp/quota-4.01/quotaio_tree.c"
static void dq_insert_tree___5(struct quota_handle *h , struct dquot *dquot ) 
{ 
  uint tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;

  {
  {
#line 257
  tmp = (uint )1;
#line 259
  tmp___3 = do_insert_tree___5(h, dquot, & tmp, 0);
  }
#line 259
  if (tmp___3 < 0) {
    {
#line 260
    tmp___0 = __errno_location();
#line 260
    tmp___1 = strerror(*tmp___0);
#line 260
    tmp___2 = gettext("Cannot write quota (id %u): %s\n");
#line 260
    die(2, tmp___2, dquot->dq_id, tmp___1);
    }
  }
#line 261
  return;
}
}
#line 284 "/home/wheatley/newnew/temp/quota-4.01/quotaio_tree.c"
static void free_dqentry___5(struct quota_handle *h , struct dquot *dquot , uint blk ) 
{ 
  struct qt_disk_dqdbheader *dh ;
  struct qtree_mem_dqinfo *info ;
  dqbuf_t buf ;
  void *tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 287
  info = & h->qh_info.u.v2_mdqi.dqi_qtree;
#line 288
  tmp = smalloc((size_t )(1 << 10));
#line 288
  buf = (dqbuf_t )tmp;
  }
#line 290
  if (dquot->dq_dqb.u.v2_mdqb.dqb_off >> 10 != (loff_t )blk) {
    {
#line 291
    tmp___0 = gettext("Quota structure has offset to other block (%u) than it should (%u).\n");
#line 291
    die(2, tmp___0, blk, (uint )(dquot->dq_dqb.u.v2_mdqb.dqb_off >> 10));
    }
  }
  {
#line 293
  read_blk___5(h, blk, buf);
#line 294
  dh = (struct qt_disk_dqdbheader *)buf;
#line 295
  dh->dqdh_entries = (__u16 )((int )dh->dqdh_entries - 1);
  }
#line 296
  if (! dh->dqdh_entries) {
    {
#line 297
    remove_free_dqentry___5(h, buf, blk);
#line 298
    put_free_dqblk___5(h, buf, blk);
    }
  } else {
    {
#line 301
    memset((void *)(buf + (dquot->dq_dqb.u.v2_mdqb.dqb_off & (long )((1 << 10) - 1))),
           0, (size_t )info->dqi_entry_size);
#line 304
    tmp___1 = qtree_dqstr_in_blk(info);
    }
#line 304
    if ((int )dh->dqdh_entries == tmp___1 - 1) {
      {
#line 305
      insert_free_dqentry___5(h, buf, blk);
      }
    } else {
      {
#line 307
      write_blk___5(h, blk, buf);
      }
    }
  }
  {
#line 309
  dquot->dq_dqb.u.v2_mdqb.dqb_off = (loff_t )0;
#line 310
  free((void *)buf);
  }
#line 311
  return;
}
}
#line 314 "/home/wheatley/newnew/temp/quota-4.01/quotaio_tree.c"
static void remove_tree___5(struct quota_handle *h , struct dquot *dquot , uint *blk ,
                            int depth ) 
{ 
  dqbuf_t buf ;
  void *tmp ;
  uint newblk ;
  u_int32_t *ref ;
  int tmp___0 ;
  int i ;
  int tmp___1 ;

  {
  {
#line 316
  tmp = smalloc((size_t )(1 << 10));
#line 316
  buf = (dqbuf_t )tmp;
#line 318
  ref = (u_int32_t *)buf;
#line 320
  read_blk___5(h, *blk, buf);
#line 321
  tmp___0 = get_index___5(dquot->dq_id, depth);
#line 321
  newblk = *(ref + tmp___0);
  }
#line 322
  if (depth == 3) {
    {
#line 323
    free_dqentry___5(h, dquot, newblk);
#line 324
    newblk = (uint )0;
    }
  } else {
    {
#line 327
    remove_tree___5(h, dquot, & newblk, depth + 1);
    }
  }
#line 328
  if (! newblk) {
    {
#line 331
    tmp___1 = get_index___5(dquot->dq_id, depth);
#line 331
    *(ref + tmp___1) = (__u32 )0;
#line 332
    i = 0;
    }
    {
#line 332
    while (1) {
      while_continue: /* CIL Label */ ;
#line 332
      if (i < 1 << 10) {
#line 332
        if (! (! *(buf + i))) {
#line 332
          goto while_break;
        }
      } else {
#line 332
        goto while_break;
      }
#line 332
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 334
    if (i == 1 << 10) {
#line 334
      if (*blk != 1U) {
        {
#line 335
        put_free_dqblk___5(h, buf, *blk);
#line 336
        *blk = (uint )0;
        }
      } else {
        {
#line 339
        write_blk___5(h, *blk, buf);
        }
      }
    } else {
      {
#line 339
      write_blk___5(h, *blk, buf);
      }
    }
  }
  {
#line 341
  free((void *)buf);
  }
#line 342
  return;
}
}
#line 355 "/home/wheatley/newnew/temp/quota-4.01/quotaio_tree.c"
static loff_t find_block_dqentry___5(struct quota_handle *h , struct dquot *dquot ,
                                     uint blk ) 
{ 
  struct qtree_mem_dqinfo *info ;
  dqbuf_t buf ;
  void *tmp ;
  int i ;
  char *ddquot ;
  int tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;

  {
  {
#line 357
  info = & h->qh_info.u.v2_mdqi.dqi_qtree;
#line 358
  tmp = smalloc((size_t )(1 << 10));
#line 358
  buf = (dqbuf_t )tmp;
#line 360
  ddquot = buf + sizeof(struct qt_disk_dqdbheader );
#line 362
  read_blk___5(h, blk, buf);
#line 363
  i = 0;
  }
  {
#line 363
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 363
    tmp___0 = qtree_dqstr_in_blk(info);
    }
#line 363
    if (i < tmp___0) {
      {
#line 363
      tmp___1 = (*((info->dqi_ops)->is_id))((void *)ddquot, dquot);
      }
#line 363
      if (tmp___1) {
#line 363
        goto while_break;
      }
    } else {
#line 363
      goto while_break;
    }
#line 363
    i ++;
#line 363
    ddquot += info->dqi_entry_size;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 366
  tmp___3 = qtree_dqstr_in_blk(info);
  }
#line 366
  if (i == tmp___3) {
    {
#line 367
    tmp___2 = gettext("Quota for id %u referenced but not present.\n");
#line 367
    die(2, tmp___2, dquot->dq_id);
    }
  }
  {
#line 368
  free((void *)buf);
  }
#line 369
  return ((loff_t )(((unsigned long )(blk << 10) + sizeof(struct qt_disk_dqdbheader )) + (unsigned long )((unsigned int )i * info->dqi_entry_size)));
}
}
#line 374 "/home/wheatley/newnew/temp/quota-4.01/quotaio_tree.c"
static loff_t find_tree_dqentry___5(struct quota_handle *h , struct dquot *dquot ,
                                    uint blk , int depth ) 
{ 
  dqbuf_t buf ;
  void *tmp ;
  loff_t ret ;
  u_int32_t *ref ;
  int tmp___0 ;

  {
  {
#line 376
  tmp = smalloc((size_t )(1 << 10));
#line 376
  buf = (dqbuf_t )tmp;
#line 377
  ret = (loff_t )0;
#line 378
  ref = (u_int32_t *)buf;
#line 380
  read_blk___5(h, blk, buf);
#line 381
  ret = (loff_t )0;
#line 382
  tmp___0 = get_index___5(dquot->dq_id, depth);
#line 382
  blk = *(ref + tmp___0);
  }
#line 383
  if (! blk) {
#line 384
    goto out_buf;
  }
#line 385
  if (depth < 3) {
    {
#line 386
    ret = find_tree_dqentry___5(h, dquot, blk, depth + 1);
    }
  } else {
    {
#line 388
    ret = find_block_dqentry___5(h, dquot, blk);
    }
  }
  out_buf: 
  {
#line 390
  free((void *)buf);
  }
#line 391
  return (ret);
}
}
#line 395 "/home/wheatley/newnew/temp/quota-4.01/quotaio_tree.c"
__inline static loff_t find_dqentry___5(struct quota_handle *h , struct dquot *dquot ) 
{ 
  loff_t tmp ;

  {
  {
#line 397
  tmp = find_tree_dqentry___5(h, dquot, (uint )1, 0);
  }
#line 397
  return (tmp);
}
}
#line 441 "/home/wheatley/newnew/temp/quota-4.01/quotaio_tree.c"
static int report_block___5(struct dquot *dquot , uint blk , char *bitmap , int (*process_dquot)(struct dquot * ,
                                                                                                 char * ) ) 
{ 
  struct qtree_mem_dqinfo *info ;
  dqbuf_t buf ;
  void *tmp ;
  struct qt_disk_dqdbheader *dh ;
  char *ddata ;
  int entries ;
  int i ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 444
  info = & (dquot->dq_h)->qh_info.u.v2_mdqi.dqi_qtree;
#line 445
  tmp = smalloc((size_t )(1 << 10));
#line 445
  buf = (dqbuf_t )tmp;
#line 450
  *(bitmap + (blk >> 3)) = (char )((int )*(bitmap + (blk >> 3)) | (1 << (blk & 7U)));
#line 451
  read_blk___5(dquot->dq_h, blk, buf);
#line 452
  dh = (struct qt_disk_dqdbheader *)buf;
#line 453
  ddata = buf + sizeof(struct qt_disk_dqdbheader );
#line 454
  entries = (int )dh->dqdh_entries;
#line 455
  i = 0;
  }
  {
#line 455
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 455
    tmp___2 = qtree_dqstr_in_blk(info);
    }
#line 455
    if (! (i < tmp___2)) {
#line 455
      goto while_break;
    }
    {
#line 456
    tmp___1 = qtree_entry_unused(info, ddata);
    }
#line 456
    if (! tmp___1) {
      {
#line 457
      (*((info->dqi_ops)->disk2mem_dqblk))(dquot, (void *)ddata);
#line 458
      tmp___0 = (*process_dquot)(dquot, (char *)((void *)0));
      }
#line 458
      if (tmp___0 < 0) {
#line 459
        goto while_break;
      }
    }
#line 455
    i ++;
#line 455
    ddata += info->dqi_entry_size;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 461
  free((void *)buf);
  }
#line 462
  return (entries);
}
}
#line 465 "/home/wheatley/newnew/temp/quota-4.01/quotaio_tree.c"
static void check_reference___5(struct quota_handle *h , uint blk ) 
{ 
  char *tmp ;
  char *tmp___0 ;

  {
#line 467
  if (blk >= h->qh_info.u.v2_mdqi.dqi_qtree.dqi_blocks) {
    {
#line 468
    tmp = type2name(h->qh_type);
#line 468
    tmp___0 = gettext("Illegal reference (%u >= %u) in %s quota file on %s. Quota file is probably corrupted.\nPlease run quotacheck(8) and try again.\n");
#line 468
    die(2, tmp___0, blk, h->qh_info.u.v2_mdqi.dqi_qtree.dqi_blocks, tmp, h->qh_quotadev);
    }
  }
#line 469
  return;
}
}
#line 471 "/home/wheatley/newnew/temp/quota-4.01/quotaio_tree.c"
static int report_tree___5(struct dquot *dquot , uint blk , int depth , char *bitmap ,
                           int (*process_dquot)(struct dquot * , char * ) ) 
{ 
  int entries ;
  int i ;
  dqbuf_t buf ;
  void *tmp ;
  u_int32_t *ref ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 474
  entries = 0;
#line 475
  tmp = smalloc((size_t )(1 << 10));
#line 475
  buf = (dqbuf_t )tmp;
#line 476
  ref = (u_int32_t *)buf;
#line 478
  read_blk___5(dquot->dq_h, blk, buf);
  }
#line 479
  if (depth == 3) {
#line 480
    i = 0;
    {
#line 480
    while (1) {
      while_continue: /* CIL Label */ ;
#line 480
      if (! (i < (1 << 10) >> 2)) {
#line 480
        goto while_break;
      }
      {
#line 481
      blk = *(ref + i);
#line 482
      check_reference___5(dquot->dq_h, blk);
      }
#line 483
      if (blk) {
#line 483
        if (! ((int )*(bitmap + (blk >> 3)) & (1 << (blk & 7U)))) {
          {
#line 484
          tmp___0 = report_block___5(dquot, blk, bitmap, process_dquot);
#line 484
          entries += tmp___0;
          }
        }
      }
#line 480
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 488
    i = 0;
    {
#line 488
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 488
      if (! (i < (1 << 10) >> 2)) {
#line 488
        goto while_break___0;
      }
#line 489
      blk = *(ref + i);
#line 489
      if (blk) {
        {
#line 490
        check_reference___5(dquot->dq_h, blk);
#line 491
        tmp___1 = report_tree___5(dquot, blk, depth + 1, bitmap, process_dquot);
#line 491
        entries += tmp___1;
        }
      }
#line 488
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  {
#line 495
  free((void *)buf);
  }
#line 496
  return (entries);
}
}
#line 499 "/home/wheatley/newnew/temp/quota-4.01/quotaio_tree.c"
static uint find_set_bits___5(char *bmp , int blocks ) 
{ 
  uint i ;
  uint used ;

  {
#line 501
  used = (uint )0;
#line 503
  i = (uint )0;
  {
#line 503
  while (1) {
    while_continue: /* CIL Label */ ;
#line 503
    if (! (i < (uint )blocks)) {
#line 503
      goto while_break;
    }
#line 504
    if ((int )*(bmp + (i >> 3)) & (1 << (i & 7U))) {
#line 505
      used ++;
    }
#line 503
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 506
  return (used);
}
}
#line 105 "/home/wheatley/newnew/temp/quota-4.01/quotaio_generic.c"
static int scan_one_dquot___5(struct dquot *dquot , int (*get_dquot)(struct dquot * ) ) 
{ 
  int ret ;
  struct util_dqblk *dqb ;

  {
  {
#line 108
  dqb = & dquot->dq_dqb;
#line 110
  memset((void *)dqb, 0, sizeof(struct util_dqblk ));
#line 111
  ret = (*get_dquot)(dquot);
  }
#line 112
  if (ret < 0) {
#line 113
    return (ret);
  }
#line 114
  if (! dqb->dqb_bhardlimit) {
#line 114
    if (! dqb->dqb_bsoftlimit) {
#line 114
      if (! dqb->dqb_ihardlimit) {
#line 114
        if (! dqb->dqb_isoftlimit) {
#line 114
          if (! dqb->dqb_curinodes) {
#line 114
            if (! dqb->dqb_curspace) {
#line 115
              return (1);
            }
          }
        }
      }
    }
  }
#line 116
  return (0);
}
}
#line 18 "/home/wheatley/newnew/temp/quota-4.01/quotasync.c"
static int flags___4  ;
#line 18 "/home/wheatley/newnew/temp/quota-4.01/quotasync.c"
static int fmt___4  =    -1;
#line 19 "/home/wheatley/newnew/temp/quota-4.01/quotasync.c"
static char **mnt  ;
#line 20 "/home/wheatley/newnew/temp/quota-4.01/quotasync.c"
static int mntcnt___0  ;
#line 23 "/home/wheatley/newnew/temp/quota-4.01/quotasync.c"
static void usage___4(void) 
{ 


  {
  {
#line 25
  errstr((char *)"Utility for syncing quotas.\nUsage:\n%s [-ug] -a | mntpoint...\n\n",
         progname);
#line 26
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Bugs to %s\n",
          "jack@suse.cz");
#line 27
  exit(1);
  }
}
}
#line 30 "/home/wheatley/newnew/temp/quota-4.01/quotasync.c"
static void parse_options___3(int argcnt , char **argstr ) 
{ 
  int ret ;
  struct option long_opts[6] ;

  {
#line 33
  long_opts[0].name = "user";
#line 33
  long_opts[0].has_arg = 0;
#line 33
  long_opts[0].flag = (int *)((void *)0);
#line 33
  long_opts[0].val = 'u';
#line 33
  long_opts[1].name = "group";
#line 33
  long_opts[1].has_arg = 0;
#line 33
  long_opts[1].flag = (int *)((void *)0);
#line 33
  long_opts[1].val = 'g';
#line 33
  long_opts[2].name = "all";
#line 33
  long_opts[2].has_arg = 0;
#line 33
  long_opts[2].flag = (int *)((void *)0);
#line 33
  long_opts[2].val = 'a';
#line 33
  long_opts[3].name = "version";
#line 33
  long_opts[3].has_arg = 0;
#line 33
  long_opts[3].flag = (int *)((void *)0);
#line 33
  long_opts[3].val = 'V';
#line 33
  long_opts[4].name = "help";
#line 33
  long_opts[4].has_arg = 0;
#line 33
  long_opts[4].flag = (int *)((void *)0);
#line 33
  long_opts[4].val = 'h';
#line 33
  long_opts[5].name = (char const   *)((void *)0);
#line 33
  long_opts[5].has_arg = 0;
#line 33
  long_opts[5].flag = (int *)((void *)0);
#line 33
  long_opts[5].val = 0;
  {
#line 42
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 42
    ret = getopt_long(argcnt, (char * const  *)argstr, "ahugV", (struct option  const  *)(long_opts),
                      (int *)((void *)0));
    }
#line 42
    if (! (ret != -1)) {
#line 42
      goto while_break;
    }
    {
#line 45
    if (ret == 104) {
#line 45
      goto case_104;
    }
#line 45
    if (ret == 63) {
#line 45
      goto case_104;
    }
#line 47
    if (ret == 86) {
#line 47
      goto case_86;
    }
#line 50
    if (ret == 117) {
#line 50
      goto case_117;
    }
#line 53
    if (ret == 103) {
#line 53
      goto case_103;
    }
#line 56
    if (ret == 97) {
#line 56
      goto case_97;
    }
#line 43
    goto switch_break;
    case_104: /* CIL Label */ 
    case_63: /* CIL Label */ 
    {
#line 46
    usage___4();
    }
    case_86: /* CIL Label */ 
    {
#line 48
    version();
#line 49
    exit(0);
    }
    case_117: /* CIL Label */ 
#line 51
    flags___4 |= 1;
#line 52
    goto switch_break;
    case_103: /* CIL Label */ 
#line 54
    flags___4 |= 2;
#line 55
    goto switch_break;
    case_97: /* CIL Label */ 
#line 57
    flags___4 |= 4;
#line 58
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 62
  if (flags___4 & 4) {
#line 62
    if (optind != argcnt) {
      {
#line 64
      fputs((char const   */* __restrict  */)"Bad number of arguments.\n", (FILE */* __restrict  */)stderr);
#line 65
      usage___4();
      }
    } else {
#line 62
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 62
  if (! (flags___4 & 4)) {
#line 62
    if (optind == argcnt) {
      {
#line 64
      fputs((char const   */* __restrict  */)"Bad number of arguments.\n", (FILE */* __restrict  */)stderr);
#line 65
      usage___4();
      }
    }
  }
#line 67
  if (! (flags___4 & 4)) {
#line 68
    mnt = argstr + optind;
#line 69
    mntcnt___0 = argcnt - optind;
  }
#line 71
  if (! (flags___4 & 3)) {
#line 72
    flags___4 |= 1;
  }
#line 73
  return;
}
}
#line 75 "/home/wheatley/newnew/temp/quota-4.01/quotasync.c"
static int sync_one(int type , char *dev ) 
{ 
  int qcmd ;
  long tmp ;

  {
  {
#line 77
  qcmd = (8388609 << 8) | (type & 255);
#line 79
  tmp = quotactl(qcmd, (char const   *)dev, (qid_t )0, (caddr_t )((void *)0));
  }
#line 79
  return ((int )tmp);
}
}
#line 82 "/home/wheatley/newnew/temp/quota-4.01/quotasync.c"
static int syncquotas(int type ) 
{ 
  struct quota_handle **handles ;
  struct quota_handle *h ;
  int i ;
  int ret ;
  int *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;

  {
#line 85
  ret = 0;
#line 87
  if (flags___4 & 4) {
    {
#line 88
    tmp___2 = sync_one(type, (char *)((void *)0));
    }
#line 88
    if (tmp___2 < 0) {
      {
#line 89
      tmp = __errno_location();
#line 89
      tmp___0 = strerror(*tmp);
#line 89
      tmp___1 = type2name(type);
#line 89
      errstr((char *)"%s quota sync failed: %s\n", tmp___1, tmp___0);
      }
    }
#line 91
    return (-1);
  }
  {
#line 94
  handles = create_handle_list(mntcnt___0, mnt, type, fmt___4, 1, 10);
#line 97
  i = 0;
  }
  {
#line 97
  while (1) {
    while_continue: /* CIL Label */ ;
#line 97
    if (! *(handles + i)) {
#line 97
      goto while_break;
    }
    {
#line 98
    h = *(handles + i);
#line 99
    tmp___6 = sync_one(type, h->qh_quotadev);
    }
#line 99
    if (tmp___6) {
      {
#line 100
      tmp___3 = __errno_location();
#line 100
      tmp___4 = strerror(*tmp___3);
#line 100
      tmp___5 = type2name(type);
#line 100
      errstr((char *)"%s quota sync failed for %s: %s\n", tmp___5, h->qh_quotadev,
             tmp___4);
#line 102
      ret = -1;
      }
    }
#line 97
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 105
  dispose_handle_list(handles);
  }
#line 107
  return (ret);
}
}
#line 18 "/home/wheatley/newnew/temp/quota-4.01/quotaio_rpc.c"
static int rpc_init_io___5(struct quota_handle *h ) ;
#line 19
static struct dquot *rpc_read_dquot___5(struct quota_handle *h , qid_t id___0 ) ;
#line 20
static int rpc_commit_dquot___5(struct dquot *dquot , int flags___7 ) ;
#line 31 "/home/wheatley/newnew/temp/quota-4.01/quotaio_rpc.c"
static int rpc_init_io___5(struct quota_handle *h ) 
{ 


  {
#line 34
  h->qh_info.dqi_max_b_limit = (uint64_t )(~ ((uint32_t )0));
#line 35
  h->qh_info.dqi_max_i_limit = (uint64_t )(~ ((uint32_t )0));
#line 36
  h->qh_info.dqi_max_b_usage = (uint64_t )(4294967295U << 10);
#line 37
  h->qh_info.dqi_max_i_usage = (uint64_t )(~ ((uint32_t )0));
#line 38
  return (0);
}
}
#line 47 "/home/wheatley/newnew/temp/quota-4.01/quotaio_rpc.c"
static struct dquot *rpc_read_dquot___5(struct quota_handle *h , qid_t id___0 ) 
{ 
  struct dquot *dquot ;
  struct dquot *tmp ;
  int ret ;
  int *tmp___0 ;

  {
  {
#line 50
  tmp = get_empty_dquot();
#line 50
  dquot = tmp;
#line 53
  dquot->dq_id = id___0;
#line 54
  dquot->dq_h = h;
#line 55
  ret = rpc_rquota_get(dquot);
  }
#line 55
  if (ret < 0) {
    {
#line 56
    tmp___0 = __errno_location();
#line 56
    *tmp___0 = - ret;
#line 57
    free((void *)dquot);
    }
#line 58
    return ((struct dquot *)((void *)0));
  }
#line 60
  return (dquot);
}
}
#line 70 "/home/wheatley/newnew/temp/quota-4.01/quotaio_rpc.c"
static int rpc_commit_dquot___5(struct dquot *dquot , int flags___7 ) 
{ 
  int ret ;
  char *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;

  {
#line 75
  if ((dquot->dq_h)->qh_io_flags & 4) {
    {
#line 76
    tmp = gettext("Trying to write quota to readonly quotafile on %s\n");
#line 76
    errstr(tmp, (dquot->dq_h)->qh_quotadev);
#line 77
    tmp___0 = __errno_location();
#line 77
    *tmp___0 = 1;
    }
#line 78
    return (-1);
  }
  {
#line 80
  ret = rpc_rquota_set((1024 << 8) | ((dquot->dq_h)->qh_type & 255), dquot);
  }
#line 80
  if (ret < 0) {
    {
#line 81
    tmp___1 = __errno_location();
#line 81
    *tmp___1 = - ret;
    }
#line 82
    return (-1);
  }
#line 84
  return (0);
}
}
#line 10 "/home/wheatley/newnew/temp/quota-4.01/rquota_clnt.c"
static struct timeval TIMEOUT___5  =    {(__time_t )25, (__suseconds_t )0};
#line 15 "/home/wheatley/newnew/temp/quota-4.01/rquota_clnt.c"
static getquota_rslt clnt_res___47  ;
#line 30 "/home/wheatley/newnew/temp/quota-4.01/rquota_clnt.c"
static getquota_rslt clnt_res___48  ;
#line 45 "/home/wheatley/newnew/temp/quota-4.01/rquota_clnt.c"
static setquota_rslt clnt_res___49  ;
#line 60 "/home/wheatley/newnew/temp/quota-4.01/rquota_clnt.c"
static setquota_rslt clnt_res___50  ;
#line 75 "/home/wheatley/newnew/temp/quota-4.01/rquota_clnt.c"
static getquota_rslt clnt_res___51  ;
#line 90 "/home/wheatley/newnew/temp/quota-4.01/rquota_clnt.c"
static getquota_rslt clnt_res___52  ;
#line 105 "/home/wheatley/newnew/temp/quota-4.01/rquota_clnt.c"
static setquota_rslt clnt_res___53  ;
#line 120 "/home/wheatley/newnew/temp/quota-4.01/rquota_clnt.c"
static setquota_rslt clnt_res___54  ;
#line 27 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v2.c"
static int v2_check_file___5(int fd , int type , int fmt___7 ) ;
#line 28
static int v2_init_io___5(struct quota_handle *h ) ;
#line 29
static int v2_new_io___5(struct quota_handle *h ) ;
#line 30
static int v2_write_info___5(struct quota_handle *h ) ;
#line 31
static struct dquot *v2_read_dquot___5(struct quota_handle *h , qid_t id___0 ) ;
#line 32
static int v2_commit_dquot___5(struct dquot *dquot , int flags___7 ) ;
#line 33
static int v2_scan_dquots___5(struct quota_handle *h , int (*process_dquot)(struct dquot *dquot ,
                                                                            char *dqname ) ) ;
#line 34
static int v2_report___5(struct quota_handle *h , int verbose ) ;
#line 53 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v2.c"
static void v2r0_disk2memdqblk___5(struct dquot *dquot , void *dp ) 
{ 
  struct util_dqblk *m ;
  struct v2r0_disk_dqblk *d ;
  struct v2r0_disk_dqblk empty ;
  int tmp ;

  {
  {
#line 55
  m = & dquot->dq_dqb;
#line 56
  d = (struct v2r0_disk_dqblk *)dp;
#line 58
  dquot->dq_id = d->dqb_id;
#line 59
  m->dqb_ihardlimit = (qsize_t )d->dqb_ihardlimit;
#line 60
  m->dqb_isoftlimit = (qsize_t )d->dqb_isoftlimit;
#line 61
  m->dqb_bhardlimit = (qsize_t )d->dqb_bhardlimit;
#line 62
  m->dqb_bsoftlimit = (qsize_t )d->dqb_bsoftlimit;
#line 63
  m->dqb_curinodes = (qsize_t )d->dqb_curinodes;
#line 64
  m->dqb_curspace = (qsize_t )((__le64 )d->dqb_curspace);
#line 65
  m->dqb_itime = (time_t )((__le64 )d->dqb_itime);
#line 66
  m->dqb_btime = (time_t )((__le64 )d->dqb_btime);
#line 68
  memset((void *)(& empty), 0, sizeof(struct v2r0_disk_dqblk ));
#line 69
  empty.dqb_itime = (u_int64_t )((__u64 )1);
#line 70
  tmp = memcmp((void const   *)(& empty), (void const   *)dp, sizeof(struct v2r0_disk_dqblk ));
  }
#line 70
  if (! tmp) {
#line 71
    m->dqb_itime = (time_t )0;
  }
#line 72
  return;
}
}
#line 77 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v2.c"
static void v2r0_mem2diskdqblk___5(void *dp , struct dquot *dquot ) 
{ 
  struct util_dqblk *m ;
  struct v2r0_disk_dqblk *d ;
  struct qtree_mem_dqinfo *info ;
  int tmp ;

  {
  {
#line 79
  m = & dquot->dq_dqb;
#line 80
  d = (struct v2r0_disk_dqblk *)dp;
#line 81
  info = & (dquot->dq_h)->qh_info.u.v2_mdqi.dqi_qtree;
#line 83
  d->dqb_ihardlimit = (__u32 )m->dqb_ihardlimit;
#line 84
  d->dqb_isoftlimit = (__u32 )m->dqb_isoftlimit;
#line 85
  d->dqb_bhardlimit = (__u32 )m->dqb_bhardlimit;
#line 86
  d->dqb_bsoftlimit = (__u32 )m->dqb_bsoftlimit;
#line 87
  d->dqb_curinodes = (__u32 )m->dqb_curinodes;
#line 88
  d->dqb_curspace = (u_int64_t )((__u64 )m->dqb_curspace);
#line 89
  d->dqb_itime = (u_int64_t )((__u64 )m->dqb_itime);
#line 90
  d->dqb_btime = (u_int64_t )((__u64 )m->dqb_btime);
#line 91
  d->dqb_id = dquot->dq_id;
#line 92
  tmp = qtree_entry_unused(info, (char *)dp);
  }
#line 92
  if (tmp) {
#line 93
    d->dqb_itime = (u_int64_t )((__u64 )1);
  }
#line 94
  return;
}
}
#line 96 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v2.c"
static int v2r0_is_id___5(void *dp , struct dquot *dquot ) 
{ 
  struct v2r0_disk_dqblk *d ;
  struct qtree_mem_dqinfo *info ;
  int tmp ;

  {
  {
#line 98
  d = (struct v2r0_disk_dqblk *)dp;
#line 99
  info = & (dquot->dq_h)->qh_info.u.v2_mdqi.dqi_qtree;
#line 101
  tmp = qtree_entry_unused(info, (char *)dp);
  }
#line 101
  if (tmp) {
#line 102
    return (0);
  }
#line 103
  return (d->dqb_id == dquot->dq_id);
}
}
#line 109 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v2.c"
static void v2r1_disk2memdqblk___5(struct dquot *dquot , void *dp ) 
{ 
  struct util_dqblk *m ;
  struct v2r1_disk_dqblk *d ;
  struct v2r1_disk_dqblk empty ;
  int tmp ;

  {
  {
#line 111
  m = & dquot->dq_dqb;
#line 112
  d = (struct v2r1_disk_dqblk *)dp;
#line 114
  dquot->dq_id = d->dqb_id;
#line 115
  m->dqb_ihardlimit = (qsize_t )((__le64 )d->dqb_ihardlimit);
#line 116
  m->dqb_isoftlimit = (qsize_t )((__le64 )d->dqb_isoftlimit);
#line 117
  m->dqb_bhardlimit = (qsize_t )((__le64 )d->dqb_bhardlimit);
#line 118
  m->dqb_bsoftlimit = (qsize_t )((__le64 )d->dqb_bsoftlimit);
#line 119
  m->dqb_curinodes = (qsize_t )((__le64 )d->dqb_curinodes);
#line 120
  m->dqb_curspace = (qsize_t )((__le64 )d->dqb_curspace);
#line 121
  m->dqb_itime = (time_t )((__le64 )d->dqb_itime);
#line 122
  m->dqb_btime = (time_t )((__le64 )d->dqb_btime);
#line 124
  memset((void *)(& empty), 0, sizeof(struct v2r1_disk_dqblk ));
#line 125
  empty.dqb_itime = (u_int64_t )((__u64 )1);
#line 126
  tmp = memcmp((void const   *)(& empty), (void const   *)dp, sizeof(struct v2r1_disk_dqblk ));
  }
#line 126
  if (! tmp) {
#line 127
    m->dqb_itime = (time_t )0;
  }
#line 128
  return;
}
}
#line 133 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v2.c"
static void v2r1_mem2diskdqblk___5(void *dp , struct dquot *dquot ) 
{ 
  struct util_dqblk *m ;
  struct v2r1_disk_dqblk *d ;
  int tmp ;

  {
  {
#line 135
  m = & dquot->dq_dqb;
#line 136
  d = (struct v2r1_disk_dqblk *)dp;
#line 138
  d->dqb_ihardlimit = (u_int64_t )((__u64 )m->dqb_ihardlimit);
#line 139
  d->dqb_isoftlimit = (u_int64_t )((__u64 )m->dqb_isoftlimit);
#line 140
  d->dqb_bhardlimit = (u_int64_t )((__u64 )m->dqb_bhardlimit);
#line 141
  d->dqb_bsoftlimit = (u_int64_t )((__u64 )m->dqb_bsoftlimit);
#line 142
  d->dqb_curinodes = (u_int64_t )((__u64 )m->dqb_curinodes);
#line 143
  d->dqb_curspace = (u_int64_t )((__u64 )m->dqb_curspace);
#line 144
  d->dqb_itime = (u_int64_t )((__u64 )m->dqb_itime);
#line 145
  d->dqb_btime = (u_int64_t )((__u64 )m->dqb_btime);
#line 146
  d->dqb_id = dquot->dq_id;
#line 147
  d->dqb_pad = (u_int32_t )0;
#line 148
  tmp = qtree_entry_unused(& (dquot->dq_h)->qh_info.u.v2_mdqi.dqi_qtree, (char *)dp);
  }
#line 148
  if (tmp) {
#line 149
    d->dqb_itime = (u_int64_t )((__u64 )1);
  }
#line 150
  return;
}
}
#line 152 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v2.c"
static int v2r1_is_id___5(void *dp , struct dquot *dquot ) 
{ 
  struct v2r1_disk_dqblk *d ;
  struct qtree_mem_dqinfo *info ;
  int tmp ;

  {
  {
#line 154
  d = (struct v2r1_disk_dqblk *)dp;
#line 155
  info = & (dquot->dq_h)->qh_info.u.v2_mdqi.dqi_qtree;
#line 157
  tmp = qtree_entry_unused(info, (char *)dp);
  }
#line 157
  if (tmp) {
#line 158
    return (0);
  }
#line 159
  return (d->dqb_id == dquot->dq_id);
}
}
#line 162 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v2.c"
static struct qtree_fmt_operations v2r0_fmt_ops___5  =    {& v2r0_mem2diskdqblk___5, & v2r0_disk2memdqblk___5, & v2r0_is_id___5};
#line 168 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v2.c"
static struct qtree_fmt_operations v2r1_fmt_ops___5  =    {& v2r1_mem2diskdqblk___5, & v2r1_disk2memdqblk___5, & v2r1_is_id___5};
#line 226 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v2.c"
static int v2_read_header___5(int fd , struct v2_disk_dqheader *h ) 
{ 
  ssize_t tmp ;

  {
  {
#line 228
  lseek(fd, (__off64_t )0, 0);
#line 229
  tmp = read(fd, (void *)h, sizeof(struct v2_disk_dqheader ));
  }
#line 229
  if ((unsigned long )tmp != sizeof(struct v2_disk_dqheader )) {
#line 230
    return (0);
  }
#line 231
  return (1);
}
}
#line 237 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v2.c"
static int v2_check_file___5(int fd , int type , int fmt___7 ) 
{ 
  struct v2_disk_dqheader h ;
  int file_magics[2] ;
  int known_versions___0[2] ;
  int version___0 ;
  int tmp ;
  char *tmp___0 ;
  __u32 tmp___1 ;

  {
  {
#line 240
  file_magics[0] = -641720559;
#line 240
  file_magics[1] = -641722073;
#line 241
  known_versions___0[0] = 1;
#line 241
  known_versions___0[1] = 1;
#line 244
  tmp = v2_read_header___5(fd, & h);
  }
#line 244
  if (! tmp) {
#line 245
    return (0);
  }
#line 246
  if (fmt___7 == 1) {
#line 247
    version___0 = 0;
  } else
#line 248
  if (fmt___7 == 2) {
#line 249
    version___0 = 1;
  } else {
#line 251
    return (0);
  }
#line 253
  if (h.dqh_magic != (__u32 )file_magics[type]) {
    {
#line 254
    tmp___1 = __fswab32(h.dqh_magic);
    }
#line 254
    if (tmp___1 == (__u32 )file_magics[type]) {
      {
#line 255
      tmp___0 = gettext("Your quota file is stored in wrong endianity. Please use convertquota(8) to convert it.\n");
#line 255
      die(3, tmp___0);
      }
    }
#line 256
    return (0);
  }
#line 258
  if (h.dqh_version > (__u32 )known_versions___0[type]) {
#line 259
    return (0);
  }
#line 260
  if ((__u32 )version___0 != h.dqh_version) {
#line 261
    return (0);
  }
#line 262
  return (1);
}
}
#line 268 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v2.c"
static int v2_init_io___5(struct quota_handle *h ) 
{ 
  int tmp ;
  struct v2_kern_dqinfo kdqinfo ;
  int *tmp___0 ;
  long tmp___1 ;
  struct v2_disk_dqinfo ddqinfo ;
  struct v2_disk_dqheader header ;
  int tmp___2 ;
  ssize_t tmp___3 ;

  {
#line 270
  if (h->qh_io_flags & 1) {
#line 271
    if (kernel_iface == 3) {
      {
#line 272
      tmp = vfs_get_info(h);
      }
#line 272
      if (tmp < 0) {
#line 273
        return (-1);
      }
    } else {
      {
#line 278
      tmp___1 = quotactl((2304 << 8) | (h->qh_type & 255), (char const   *)(h->qh_quotadev),
                         (qid_t )0, (caddr_t )((void *)(& kdqinfo)));
      }
#line 278
      if (tmp___1 < 0L) {
        {
#line 280
        tmp___0 = __errno_location();
        }
#line 280
        if (*tmp___0 == 1) {
#line 281
          return (0);
        }
#line 282
        return (-1);
      }
#line 284
      h->qh_info.dqi_bgrace = (time_t )kdqinfo.dqi_bgrace;
#line 285
      h->qh_info.dqi_igrace = (time_t )kdqinfo.dqi_igrace;
#line 286
      h->qh_info.u.v2_mdqi.dqi_flags = kdqinfo.dqi_flags;
#line 287
      h->qh_info.u.v2_mdqi.dqi_qtree.dqi_blocks = kdqinfo.dqi_blocks;
#line 288
      h->qh_info.u.v2_mdqi.dqi_qtree.dqi_free_blk = kdqinfo.dqi_free_blk;
#line 289
      h->qh_info.u.v2_mdqi.dqi_qtree.dqi_free_entry = kdqinfo.dqi_free_entry;
    }
  }
#line 292
  if (h->qh_fd != -1) {
    {
#line 296
    tmp___2 = v2_read_header___5(h->qh_fd, & header);
    }
#line 296
    if (! tmp___2) {
#line 297
      return (-1);
    }
    {
#line 299
    lseek(h->qh_fd, (__off64_t )sizeof(struct v2_disk_dqheader ), 0);
#line 300
    tmp___3 = read(h->qh_fd, (void *)(& ddqinfo), sizeof(ddqinfo));
    }
#line 300
    if ((unsigned long )tmp___3 != sizeof(ddqinfo)) {
#line 301
      return (-1);
    }
#line 303
    if (! (h->qh_io_flags & 1)) {
      {
#line 304
      v2_disk2memdqinfo(& h->qh_info, & ddqinfo);
      }
    } else {
#line 306
      h->qh_info.u.v2_mdqi.dqi_qtree.dqi_blocks = ddqinfo.dqi_blocks;
    }
#line 308
    if (header.dqh_version == 0U) {
#line 309
      h->qh_info.u.v2_mdqi.dqi_qtree.dqi_entry_size = (unsigned int )sizeof(struct v2r0_disk_dqblk );
#line 310
      h->qh_info.u.v2_mdqi.dqi_qtree.dqi_ops = & v2r0_fmt_ops___5;
#line 311
      h->qh_info.dqi_max_b_limit = (uint64_t )(~ ((uint32_t )0));
#line 312
      h->qh_info.dqi_max_i_limit = (uint64_t )(~ ((uint32_t )0));
#line 313
      h->qh_info.dqi_max_b_usage = ~ ((uint64_t )0);
#line 314
      h->qh_info.dqi_max_i_usage = (uint64_t )(~ ((uint32_t )0));
    } else {
#line 316
      h->qh_info.u.v2_mdqi.dqi_qtree.dqi_entry_size = (unsigned int )sizeof(struct v2r1_disk_dqblk );
#line 317
      h->qh_info.u.v2_mdqi.dqi_qtree.dqi_ops = & v2r1_fmt_ops___5;
#line 318
      h->qh_info.dqi_max_b_limit = ~ ((uint64_t )0);
#line 319
      h->qh_info.dqi_max_i_limit = ~ ((uint64_t )0);
#line 320
      h->qh_info.dqi_max_b_usage = ~ ((uint64_t )0);
#line 321
      h->qh_info.dqi_max_i_usage = ~ ((uint64_t )0);
    }
  } else {
#line 325
    h->qh_info.u.v2_mdqi.dqi_qtree.dqi_ops = (struct qtree_fmt_operations *)((void *)0);
  }
#line 327
  return (0);
}
}
#line 333 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v2.c"
static int v2_new_io___5(struct quota_handle *h ) 
{ 
  int file_magics[2] ;
  struct v2_disk_dqheader ddqheader ;
  struct v2_disk_dqinfo ddqinfo ;
  int version___0 ;
  ssize_t tmp ;
  ssize_t tmp___0 ;

  {
#line 335
  file_magics[0] = -641720559;
#line 335
  file_magics[1] = -641722073;
#line 340
  if (h->qh_fmt == 1) {
#line 341
    version___0 = 0;
  } else
#line 342
  if (h->qh_fmt == 2) {
#line 343
    version___0 = 1;
  } else {
#line 345
    return (-1);
  }
  {
#line 348
  ddqheader.dqh_magic = (__u32 )file_magics[h->qh_type];
#line 349
  ddqheader.dqh_version = (__u32 )version___0;
#line 350
  lseek(h->qh_fd, (__off64_t )0, 0);
#line 351
  tmp = write(h->qh_fd, (void const   *)(& ddqheader), sizeof(ddqheader));
  }
#line 351
  if ((unsigned long )tmp != sizeof(ddqheader)) {
#line 352
    return (-1);
  }
#line 354
  h->qh_info.dqi_bgrace = (time_t )604800;
#line 355
  h->qh_info.dqi_igrace = (time_t )604800;
#line 356
  h->qh_info.u.v2_mdqi.dqi_flags = (uint )0;
#line 357
  h->qh_info.u.v2_mdqi.dqi_qtree.dqi_blocks = 2U;
#line 358
  h->qh_info.u.v2_mdqi.dqi_qtree.dqi_free_blk = 0U;
#line 359
  h->qh_info.u.v2_mdqi.dqi_qtree.dqi_free_entry = 0U;
#line 360
  if (version___0 == 0) {
#line 361
    h->qh_info.u.v2_mdqi.dqi_qtree.dqi_entry_size = (unsigned int )sizeof(struct v2r0_disk_dqblk );
#line 362
    h->qh_info.u.v2_mdqi.dqi_qtree.dqi_ops = & v2r0_fmt_ops___5;
#line 363
    h->qh_info.dqi_max_b_limit = (uint64_t )(~ ((uint32_t )0));
#line 364
    h->qh_info.dqi_max_i_limit = (uint64_t )(~ ((uint32_t )0));
#line 365
    h->qh_info.dqi_max_b_usage = ~ ((uint64_t )0);
#line 366
    h->qh_info.dqi_max_i_usage = (uint64_t )(~ ((uint32_t )0));
  } else
#line 367
  if (version___0 == 1) {
#line 368
    h->qh_info.u.v2_mdqi.dqi_qtree.dqi_entry_size = (unsigned int )sizeof(struct v2r1_disk_dqblk );
#line 369
    h->qh_info.u.v2_mdqi.dqi_qtree.dqi_ops = & v2r1_fmt_ops___5;
#line 370
    h->qh_info.dqi_max_b_limit = ~ ((uint64_t )0);
#line 371
    h->qh_info.dqi_max_i_limit = ~ ((uint64_t )0);
#line 372
    h->qh_info.dqi_max_b_usage = ~ ((uint64_t )0);
#line 373
    h->qh_info.dqi_max_i_usage = ~ ((uint64_t )0);
  }
  {
#line 375
  v2_mem2diskdqinfo(& ddqinfo, & h->qh_info);
#line 376
  lseek(h->qh_fd, (__off64_t )sizeof(struct v2_disk_dqheader ), 0);
#line 377
  tmp___0 = write(h->qh_fd, (void const   *)(& ddqinfo), sizeof(ddqinfo));
  }
#line 377
  if ((unsigned long )tmp___0 != sizeof(ddqinfo)) {
#line 378
    return (-1);
  }
#line 379
  return (0);
}
}
#line 385 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v2.c"
static int v2_write_info___5(struct quota_handle *h ) 
{ 
  char *tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  struct v2_kern_dqinfo kdqinfo ;
  long tmp___2 ;
  long tmp___3 ;
  struct v2_disk_dqinfo ddqinfo ;
  ssize_t tmp___4 ;

  {
#line 387
  if (h->qh_io_flags & 4) {
    {
#line 388
    tmp = gettext("Trying to write info to readonly quotafile on %s\n");
#line 388
    errstr(tmp, h->qh_quotadev);
#line 389
    tmp___0 = __errno_location();
#line 389
    *tmp___0 = 1;
    }
#line 390
    return (-1);
  }
#line 392
  if (h->qh_io_flags & 1) {
#line 393
    if (kernel_iface == 3) {
      {
#line 394
      tmp___1 = vfs_set_info(h, 3);
      }
#line 394
      if (tmp___1) {
#line 395
        return (-1);
      }
    } else {
      {
#line 400
      kdqinfo.dqi_bgrace = (unsigned int )h->qh_info.dqi_bgrace;
#line 401
      kdqinfo.dqi_igrace = (unsigned int )h->qh_info.dqi_igrace;
#line 402
      kdqinfo.dqi_flags = h->qh_info.u.v2_mdqi.dqi_flags;
#line 403
      kdqinfo.dqi_blocks = h->qh_info.u.v2_mdqi.dqi_qtree.dqi_blocks;
#line 404
      kdqinfo.dqi_free_blk = h->qh_info.u.v2_mdqi.dqi_qtree.dqi_free_blk;
#line 405
      kdqinfo.dqi_free_entry = h->qh_info.u.v2_mdqi.dqi_qtree.dqi_free_entry;
#line 406
      tmp___2 = quotactl((2816 << 8) | (h->qh_type & 255), (char const   *)(h->qh_quotadev),
                         (qid_t )0, (caddr_t )((void *)(& kdqinfo)));
      }
#line 406
      if (tmp___2 < 0L) {
#line 408
        return (-1);
      } else {
        {
#line 406
        tmp___3 = quotactl((3072 << 8) | (h->qh_type & 255), (char const   *)(h->qh_quotadev),
                           (qid_t )0, (caddr_t )((void *)(& kdqinfo)));
        }
#line 406
        if (tmp___3 < 0L) {
#line 408
          return (-1);
        }
      }
    }
  } else {
    {
#line 414
    v2_mem2diskdqinfo(& ddqinfo, & h->qh_info);
#line 415
    lseek(h->qh_fd, (__off64_t )sizeof(struct v2_disk_dqheader ), 0);
#line 416
    tmp___4 = write(h->qh_fd, (void const   *)(& ddqinfo), sizeof(ddqinfo));
    }
#line 416
    if ((unsigned long )tmp___4 != sizeof(ddqinfo)) {
#line 417
      return (-1);
    }
  }
#line 419
  return (0);
}
}
#line 426 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v2.c"
static struct dquot *v2_read_dquot___5(struct quota_handle *h , qid_t id___0 ) 
{ 
  struct dquot *dquot ;
  struct dquot *tmp ;
  int tmp___0 ;
  struct v2_kern_dqblk kdqblk ;
  long tmp___1 ;
  struct dquot *tmp___2 ;

  {
#line 428
  if (h->qh_io_flags & 1) {
    {
#line 429
    tmp = get_empty_dquot();
#line 429
    dquot = tmp;
#line 431
    dquot->dq_id = id___0;
#line 432
    dquot->dq_h = h;
#line 433
    dquot->dq_dqb.u.v2_mdqb.dqb_off = (loff_t )0;
#line 434
    memset((void *)(& dquot->dq_dqb), 0, sizeof(struct util_dqblk ));
    }
#line 435
    if (kernel_iface == 3) {
      {
#line 436
      tmp___0 = vfs_get_dquot(dquot);
      }
#line 436
      if (tmp___0 < 0) {
        {
#line 437
        free((void *)dquot);
        }
#line 438
        return ((struct dquot *)((void *)0));
      }
    } else {
      {
#line 444
      tmp___1 = quotactl((3328 << 8) | (h->qh_type & 255), (char const   *)(h->qh_quotadev),
                         id___0, (caddr_t )((void *)(& kdqblk)));
      }
#line 444
      if (tmp___1 < 0L) {
        {
#line 445
        free((void *)dquot);
        }
#line 446
        return ((struct dquot *)((void *)0));
      }
      {
#line 448
      v2_kern2utildqblk(& dquot->dq_dqb, & kdqblk);
      }
    }
#line 450
    return (dquot);
  }
  {
#line 452
  tmp___2 = qtree_read_dquot(h, id___0);
  }
#line 452
  return (tmp___2);
}
}
#line 459 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v2.c"
static int v2_commit_dquot___5(struct dquot *dquot , int flags___7 ) 
{ 
  struct util_dqblk *b ;
  char *tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  struct v2_kern_dqblk kdqblk ;
  int cmd ;
  int *tmp___2 ;
  long tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;

  {
#line 461
  b = & dquot->dq_dqb;
#line 463
  if ((dquot->dq_h)->qh_io_flags & 4) {
    {
#line 464
    tmp = gettext("Trying to write quota to readonly quotafile on %s\n");
#line 464
    errstr(tmp, (dquot->dq_h)->qh_quotadev);
#line 465
    tmp___0 = __errno_location();
#line 465
    *tmp___0 = 1;
    }
#line 466
    return (-1);
  }
#line 468
  if ((dquot->dq_h)->qh_io_flags & 1) {
#line 469
    if (kernel_iface == 3) {
      {
#line 470
      tmp___1 = vfs_set_dquot(dquot, flags___7);
      }
#line 470
      if (tmp___1 < 0) {
#line 471
        return (-1);
      }
    } else {
#line 477
      if (flags___7 == 10) {
#line 478
        cmd = 3840;
      } else
#line 479
      if (flags___7 == 5) {
#line 480
        cmd = 1792;
      } else
#line 481
      if (flags___7 & 48) {
        {
#line 482
        tmp___2 = __errno_location();
#line 482
        *tmp___2 = 22;
        }
#line 483
        return (-1);
      } else {
#line 486
        cmd = 3584;
      }
      {
#line 487
      v2_util2kerndqblk(& kdqblk, & dquot->dq_dqb);
#line 488
      tmp___3 = quotactl((cmd << 8) | ((dquot->dq_h)->qh_type & 255), (char const   *)((dquot->dq_h)->qh_quotadev),
                         dquot->dq_id, (caddr_t )((void *)(& kdqblk)));
      }
#line 488
      if (tmp___3 < 0L) {
#line 490
        return (-1);
      }
    }
#line 492
    return (0);
  }
#line 494
  if (! b->dqb_curspace) {
#line 494
    if (! b->dqb_curinodes) {
#line 494
      if (! b->dqb_bsoftlimit) {
#line 494
        if (! b->dqb_isoftlimit) {
#line 494
          if (! b->dqb_bhardlimit) {
#line 494
            if (! b->dqb_ihardlimit) {
              {
#line 496
              qtree_delete_dquot(dquot);
              }
            } else {
#line 494
              goto _L___3;
            }
          } else {
#line 494
            goto _L___3;
          }
        } else {
#line 494
          goto _L___3;
        }
      } else {
#line 494
        goto _L___3;
      }
    } else {
#line 494
      goto _L___3;
    }
  } else {
    _L___3: /* CIL Label */ 
    {
#line 498
    tmp___5 = check_dquot_range(dquot);
    }
#line 498
    if (tmp___5 < 0) {
      {
#line 499
      tmp___4 = __errno_location();
#line 499
      *tmp___4 = 34;
      }
#line 500
      return (-1);
    }
    {
#line 502
    qtree_write_dquot(dquot);
    }
  }
#line 504
  return (0);
}
}
#line 507 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v2.c"
static int v2_scan_dquots___5(struct quota_handle *h , int (*process_dquot)(struct dquot *dquot ,
                                                                            char *dqname ) ) 
{ 
  int tmp ;

  {
  {
#line 509
  tmp = qtree_scan_dquots(h, process_dquot);
  }
#line 509
  return (tmp);
}
}
#line 513 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v2.c"
static int v2_report___5(struct quota_handle *h , int verbose ) 
{ 
  struct v2_mem_dqinfo *info ;
  char *tmp ;

  {
#line 515
  if (verbose) {
    {
#line 516
    info = & h->qh_info.u.v2_mdqi;
#line 518
    tmp = gettext("Statistics:\nTotal blocks: %u\nData blocks: %u\nEntries: %u\nUsed average: %f\n");
#line 518
    printf((char const   */* __restrict  */)tmp, info->dqi_qtree.dqi_blocks, info->dqi_data_blocks,
           info->dqi_used_entries, (double )((float )info->dqi_used_entries / (float )info->dqi_data_blocks));
    }
  }
#line 522
  return (0);
}
}
#line 23 "/home/wheatley/newnew/temp/quota-4.01/common.c"
static int enable_syslog___6  =    0;
#line 31 "/home/wheatley/newnew/temp/quota-4.01/common.c"
static void do_syslog___6(int level , char const   *format , va_list args ) 
{ 
  char buf[1024] ;
  int i ;
  int j ;
  int tmp ;

  {
  {
#line 36
  vsnprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)format,
            args);
#line 39
  i = 0;
  }
  {
#line 39
  while (1) {
    while_continue: /* CIL Label */ ;
#line 39
    if (! buf[i]) {
#line 39
      goto while_break;
    }
#line 40
    j = i;
    {
#line 40
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 40
      if (buf[j]) {
#line 40
        if (! ((int )buf[j] != 10)) {
#line 40
          goto while_break___0;
        }
      } else {
#line 40
        goto while_break___0;
      }
#line 40
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 41
    if ((int )buf[j] == 10) {
#line 42
      tmp = j;
#line 42
      j ++;
#line 42
      buf[tmp] = (char )'\000';
    }
    {
#line 43
    syslog(level, "%s", buf + i);
#line 39
    i = j;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 45
  return;
}
}
#line 31 "/home/wheatley/newnew/temp/quota-4.01/bylabel.c"
static struct uuidCache_s *uuidCache___6  =    (struct uuidCache_s *)((void *)0);
#line 74 "/home/wheatley/newnew/temp/quota-4.01/bylabel.c"
static int get_label_uuid___6(char const   *device , char **label , char *uuid ) 
{ 
  int fd ;
  int rv ;
  size_t namesize ;
  struct ext2_super_block e2sb ;
  struct xfs_super_block xfsb ;
  struct reiserfs_super_block reisersb ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  __off64_t tmp___2 ;
  ssize_t tmp___3 ;
  int tmp___4 ;
  __off64_t tmp___5 ;
  ssize_t tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  __off64_t tmp___9 ;
  ssize_t tmp___10 ;

  {
  {
#line 79
  rv = 1;
#line 85
  fd = open(device, 0);
  }
#line 86
  if (fd < 0) {
#line 87
    return (rv);
  }
  {
#line 89
  tmp___9 = lseek(fd, (__off64_t )1024, 0);
  }
#line 89
  if (tmp___9 == 1024L) {
    {
#line 89
    tmp___10 = read(fd, (void *)((char *)(& e2sb)), sizeof(e2sb));
    }
#line 89
    if ((unsigned long )tmp___10 == sizeof(e2sb)) {
#line 89
      if ((uint )e2sb.s_magic[0] + ((uint )e2sb.s_magic[1] << 8) == 61267U) {
        {
#line 92
        memcpy((void */* __restrict  */)uuid, (void const   */* __restrict  */)(e2sb.s_uuid),
               sizeof(e2sb.s_uuid));
#line 93
        namesize = sizeof(e2sb.s_volume_name);
#line 94
        tmp = smalloc(namesize + 1UL);
#line 94
        *label = (char *)tmp;
#line 95
        sstrncpy(*label, (char const   *)((char *)(e2sb.s_volume_name)), namesize);
#line 96
        rv = 0;
        }
      } else {
#line 89
        goto _L___3;
      }
    } else {
#line 89
      goto _L___3;
    }
  } else {
    _L___3: /* CIL Label */ 
    {
#line 98
    tmp___5 = lseek(fd, (__off64_t )0, 0);
    }
#line 98
    if (tmp___5 == 0L) {
      {
#line 98
      tmp___6 = read(fd, (void *)((char *)(& xfsb)), sizeof(xfsb));
      }
#line 98
      if ((unsigned long )tmp___6 == sizeof(xfsb)) {
        {
#line 98
        tmp___7 = strncmp((char const   *)((char *)(& xfsb.s_magic)), "XFSB", (size_t )4);
        }
#line 98
        if (tmp___7 == 0) {
#line 98
          goto _L___0;
        } else {
          {
#line 98
          tmp___8 = strncmp((char const   *)((char *)(& xfsb.s_magic)), "BSFX", (size_t )4);
          }
#line 98
          if (tmp___8 == 0) {
            _L___0: /* CIL Label */ 
            {
#line 102
            memcpy((void */* __restrict  */)uuid, (void const   */* __restrict  */)(xfsb.s_uuid),
                   sizeof(xfsb.s_uuid));
#line 103
            namesize = sizeof(xfsb.s_fsname);
#line 104
            tmp___0 = smalloc(namesize + 1UL);
#line 104
            *label = (char *)tmp___0;
#line 105
            sstrncpy(*label, (char const   *)((char *)(xfsb.s_fsname)), namesize);
#line 106
            rv = 0;
            }
          } else {
#line 98
            goto _L___1;
          }
        }
      } else {
#line 98
        goto _L___1;
      }
    } else {
      _L___1: /* CIL Label */ 
      {
#line 108
      tmp___2 = lseek(fd, (__off64_t )65536, 0);
      }
#line 108
      if (tmp___2 == 65536L) {
        {
#line 108
        tmp___3 = read(fd, (void *)((char *)(& reisersb)), sizeof(reisersb));
        }
#line 108
        if ((unsigned long )tmp___3 == sizeof(reisersb)) {
          {
#line 108
          tmp___4 = strncmp((char const   *)((char *)(& reisersb.s_magic)), "ReIsEr2Fs",
                            (size_t )9);
          }
#line 108
          if (! tmp___4) {
            {
#line 111
            memcpy((void */* __restrict  */)uuid, (void const   */* __restrict  */)(reisersb.s_uuid),
                   sizeof(reisersb.s_uuid));
#line 112
            namesize = sizeof(reisersb.s_volume_name);
#line 113
            tmp___1 = smalloc(namesize + 1UL);
#line 113
            *label = (char *)tmp___1;
#line 114
            sstrncpy(*label, (char const   *)((char *)(reisersb.s_volume_name)), namesize);
#line 115
            rv = 0;
            }
          }
        }
      }
    }
  }
  {
#line 117
  close(fd);
  }
#line 118
  return (rv);
}
}
#line 121 "/home/wheatley/newnew/temp/quota-4.01/bylabel.c"
static void uuidcache_addentry___6(char *device , char *label , char *uuid ) 
{ 
  struct uuidCache_s *last ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 125
  if (! uuidCache___6) {
    {
#line 126
    tmp = smalloc(sizeof(*uuidCache___6));
#line 126
    uuidCache___6 = (struct uuidCache_s *)tmp;
#line 126
    last = uuidCache___6;
    }
  } else {
#line 129
    last = uuidCache___6;
    {
#line 129
    while (1) {
      while_continue: /* CIL Label */ ;
#line 129
      if (! last->next) {
#line 129
        goto while_break;
      }
#line 129
      last = last->next;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 130
    tmp___0 = smalloc(sizeof(*uuidCache___6));
#line 130
    last->next = (struct uuidCache_s *)tmp___0;
#line 131
    last = last->next;
    }
  }
  {
#line 133
  last->next = (struct uuidCache_s *)((void *)0);
#line 134
  last->device = device;
#line 135
  last->label = label;
#line 136
  memcpy((void */* __restrict  */)(last->uuid), (void const   */* __restrict  */)uuid,
         sizeof(last->uuid));
  }
#line 137
  return;
}
}
#line 144 "/home/wheatley/newnew/temp/quota-4.01/bylabel.c"
static char ptname___6[100]  ;
#line 139 "/home/wheatley/newnew/temp/quota-4.01/bylabel.c"
static void uuidcache_init___6(void) 
{ 
  char line___0[100] ;
  char *s ;
  int ma ;
  int mi ;
  int sz ;
  FILE *procpt ;
  char uuid[16] ;
  char *label ;
  char device[110] ;
  int firstPass ;
  int handleOnFirst ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  unsigned short const   **tmp___4 ;
  char *tmp___5 ;

  {
#line 151
  if (uuidCache___6) {
#line 152
    return;
  }
  {
#line 154
  procpt = fopen((char const   */* __restrict  */)"/proc/partitions", (char const   */* __restrict  */)"r");
  }
#line 155
  if (! procpt) {
#line 156
    return;
  }
#line 158
  firstPass = 1;
  {
#line 158
  while (1) {
    while_continue: /* CIL Label */ ;
#line 158
    if (! (firstPass >= 0)) {
#line 158
      goto while_break;
    }
    {
#line 159
    fseek(procpt, 0L, 0);
    }
    {
#line 161
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 161
      tmp___5 = fgets((char */* __restrict  */)(line___0), (int )sizeof(line___0),
                      (FILE */* __restrict  */)procpt);
      }
#line 161
      if (! tmp___5) {
#line 161
        goto while_break___0;
      }
      {
#line 162
      tmp = sscanf((char const   */* __restrict  */)(line___0), (char const   */* __restrict  */)" %d %d %d %[^\n ]",
                   & ma, & mi, & sz, ptname___6);
      }
#line 162
      if (tmp != 4) {
#line 163
        goto while_continue___0;
      }
#line 166
      if (sz == 1) {
#line 167
        goto while_continue___0;
      }
      {
#line 170
      tmp___0 = strncmp((char const   *)(ptname___6), "md", (size_t )2);
      }
#line 170
      if (tmp___0) {
#line 170
        tmp___1 = 0;
      } else {
#line 170
        tmp___1 = 1;
      }
#line 170
      handleOnFirst = tmp___1;
#line 171
      if (firstPass != handleOnFirst) {
#line 172
        goto while_continue___0;
      }
#line 178
      s = ptname___6;
      {
#line 178
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 178
        if (! *s) {
#line 178
          goto while_break___1;
        }
#line 178
        s ++;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 179
      tmp___4 = __ctype_b_loc();
      }
#line 179
      if ((int const   )*(*tmp___4 + (int )*(s + -1)) & 2048) {
        {
#line 189
        snprintf((char */* __restrict  */)(device), sizeof(device), (char const   */* __restrict  */)"%s/%s",
                 "/dev", ptname___6);
#line 190
        tmp___3 = get_label_uuid___6((char const   *)(device), & label, uuid);
        }
#line 190
        if (! tmp___3) {
          {
#line 191
          tmp___2 = sstrdup((char const   *)(device));
#line 191
          uuidcache_addentry___6(tmp___2, label, uuid);
          }
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 158
    firstPass --;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 196
  fclose(procpt);
  }
#line 197
  return;
}
}
#line 202 "/home/wheatley/newnew/temp/quota-4.01/bylabel.c"
static char *get_spec_by_x___6(int n , char const   *t ) 
{ 
  struct uuidCache_s *uc ;
  char *tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 206
  uuidcache_init___6();
#line 207
  uc = uuidCache___6;
  }
  {
#line 209
  while (1) {
    while_continue: /* CIL Label */ ;
#line 209
    if (! uc) {
#line 209
      goto while_break;
    }
    {
#line 211
    if (n == 1) {
#line 211
      goto case_1;
    }
#line 215
    if (n == 2) {
#line 215
      goto case_2;
    }
#line 210
    goto switch_break;
    case_1: /* CIL Label */ 
    {
#line 212
    tmp___0 = memcmp((void const   *)t, (void const   *)(uc->uuid), sizeof(uc->uuid));
    }
#line 212
    if (! tmp___0) {
      {
#line 213
      tmp = sstrdup((char const   *)uc->device);
      }
#line 213
      return (tmp);
    }
#line 214
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 216
    tmp___2 = strcmp(t, (char const   *)uc->label);
    }
#line 216
    if (! tmp___2) {
      {
#line 217
      tmp___1 = sstrdup((char const   *)uc->device);
      }
#line 217
      return (tmp___1);
    }
#line 218
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 220
    uc = uc->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 222
  return ((char *)((void *)0));
}
}
#line 225 "/home/wheatley/newnew/temp/quota-4.01/bylabel.c"
static u_char fromhex___6(char c ) 
{ 
  unsigned short const   **tmp ;
  unsigned short const   **tmp___0 ;

  {
  {
#line 227
  tmp___0 = __ctype_b_loc();
  }
#line 227
  if ((int const   )*(*tmp___0 + (int )c) & 2048) {
#line 228
    return ((u_char )((int )c - 48));
  } else {
    {
#line 229
    tmp = __ctype_b_loc();
    }
#line 229
    if ((int const   )*(*tmp + (int )c) & 512) {
#line 230
      return ((u_char )(((int )c - 97) + 10));
    } else {
#line 232
      return ((u_char )(((int )c - 65) + 10));
    }
  }
}
}
#line 235 "/home/wheatley/newnew/temp/quota-4.01/bylabel.c"
static char *get_spec_by_uuid___6(char const   *s ) 
{ 
  u_char uuid[16] ;
  int i ;
  size_t tmp ;
  unsigned short const   **tmp___0 ;
  unsigned short const   **tmp___1 ;
  u_char tmp___2 ;
  u_char tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;

  {
  {
#line 240
  tmp = strlen(s);
  }
#line 240
  if (tmp != 36UL) {
#line 241
    goto bad_uuid;
  } else
#line 240
  if ((int const   )*(s + 8) != 45) {
#line 241
    goto bad_uuid;
  } else
#line 240
  if ((int const   )*(s + 13) != 45) {
#line 241
    goto bad_uuid;
  } else
#line 240
  if ((int const   )*(s + 18) != 45) {
#line 241
    goto bad_uuid;
  } else
#line 240
  if ((int const   )*(s + 23) != 45) {
#line 241
    goto bad_uuid;
  }
#line 242
  i = 0;
  {
#line 242
  while (1) {
    while_continue: /* CIL Label */ ;
#line 242
    if (! (i < 16)) {
#line 242
      goto while_break;
    }
#line 243
    if ((int const   )*s == 45) {
#line 244
      s ++;
    }
    {
#line 245
    tmp___0 = __ctype_b_loc();
    }
#line 245
    if ((int const   )*(*tmp___0 + (int )*(s + 0)) & 4096) {
      {
#line 245
      tmp___1 = __ctype_b_loc();
      }
#line 245
      if (! ((int const   )*(*tmp___1 + (int )*(s + 1)) & 4096)) {
#line 246
        goto bad_uuid;
      }
    } else {
#line 246
      goto bad_uuid;
    }
    {
#line 247
    tmp___2 = fromhex___6((char )*(s + 0));
#line 247
    tmp___3 = fromhex___6((char )*(s + 1));
#line 247
    uuid[i] = (u_char )(((int )tmp___2 << 4) | (int )tmp___3);
#line 248
    s += 2;
#line 242
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 250
  tmp___4 = get_spec_by_x___6(1, (char const   *)((char *)(uuid)));
  }
#line 250
  return (tmp___4);
  bad_uuid: 
  {
#line 253
  tmp___5 = gettext("Found an invalid UUID: %s\n");
#line 253
  errstr(tmp___5, s);
  }
#line 254
  return ((char *)((void *)0));
}
}
#line 257 "/home/wheatley/newnew/temp/quota-4.01/bylabel.c"
static char *get_spec_by_volume_label___6(char const   *s ) 
{ 
  char *tmp ;

  {
  {
#line 259
  tmp = get_spec_by_x___6(2, s);
  }
#line 259
  return (tmp);
}
}
#line 105 "/home/wheatley/newnew/temp/quota-4.01/quotaio_generic.c"
static int scan_one_dquot___6(struct dquot *dquot , int (*get_dquot)(struct dquot * ) ) 
{ 
  int ret ;
  struct util_dqblk *dqb ;

  {
  {
#line 108
  dqb = & dquot->dq_dqb;
#line 110
  memset((void *)dqb, 0, sizeof(struct util_dqblk ));
#line 111
  ret = (*get_dquot)(dquot);
  }
#line 112
  if (ret < 0) {
#line 113
    return (ret);
  }
#line 114
  if (! dqb->dqb_bhardlimit) {
#line 114
    if (! dqb->dqb_bsoftlimit) {
#line 114
      if (! dqb->dqb_ihardlimit) {
#line 114
        if (! dqb->dqb_isoftlimit) {
#line 114
          if (! dqb->dqb_curinodes) {
#line 114
            if (! dqb->dqb_curspace) {
#line 115
              return (1);
            }
          }
        }
      }
    }
  }
#line 116
  return (0);
}
}
#line 27 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v2.c"
static int v2_check_file___6(int fd , int type , int fmt___7 ) ;
#line 28
static int v2_init_io___6(struct quota_handle *h ) ;
#line 29
static int v2_new_io___6(struct quota_handle *h ) ;
#line 30
static int v2_write_info___6(struct quota_handle *h ) ;
#line 31
static struct dquot *v2_read_dquot___6(struct quota_handle *h , qid_t id___0 ) ;
#line 32
static int v2_commit_dquot___6(struct dquot *dquot , int flags___7 ) ;
#line 33
static int v2_scan_dquots___6(struct quota_handle *h , int (*process_dquot)(struct dquot *dquot ,
                                                                            char *dqname ) ) ;
#line 34
static int v2_report___6(struct quota_handle *h , int verbose ) ;
#line 53 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v2.c"
static void v2r0_disk2memdqblk___6(struct dquot *dquot , void *dp ) 
{ 
  struct util_dqblk *m ;
  struct v2r0_disk_dqblk *d ;
  struct v2r0_disk_dqblk empty ;
  int tmp ;

  {
  {
#line 55
  m = & dquot->dq_dqb;
#line 56
  d = (struct v2r0_disk_dqblk *)dp;
#line 58
  dquot->dq_id = d->dqb_id;
#line 59
  m->dqb_ihardlimit = (qsize_t )d->dqb_ihardlimit;
#line 60
  m->dqb_isoftlimit = (qsize_t )d->dqb_isoftlimit;
#line 61
  m->dqb_bhardlimit = (qsize_t )d->dqb_bhardlimit;
#line 62
  m->dqb_bsoftlimit = (qsize_t )d->dqb_bsoftlimit;
#line 63
  m->dqb_curinodes = (qsize_t )d->dqb_curinodes;
#line 64
  m->dqb_curspace = (qsize_t )((__le64 )d->dqb_curspace);
#line 65
  m->dqb_itime = (time_t )((__le64 )d->dqb_itime);
#line 66
  m->dqb_btime = (time_t )((__le64 )d->dqb_btime);
#line 68
  memset((void *)(& empty), 0, sizeof(struct v2r0_disk_dqblk ));
#line 69
  empty.dqb_itime = (u_int64_t )((__u64 )1);
#line 70
  tmp = memcmp((void const   *)(& empty), (void const   *)dp, sizeof(struct v2r0_disk_dqblk ));
  }
#line 70
  if (! tmp) {
#line 71
    m->dqb_itime = (time_t )0;
  }
#line 72
  return;
}
}
#line 77 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v2.c"
static void v2r0_mem2diskdqblk___6(void *dp , struct dquot *dquot ) 
{ 
  struct util_dqblk *m ;
  struct v2r0_disk_dqblk *d ;
  struct qtree_mem_dqinfo *info ;
  int tmp ;

  {
  {
#line 79
  m = & dquot->dq_dqb;
#line 80
  d = (struct v2r0_disk_dqblk *)dp;
#line 81
  info = & (dquot->dq_h)->qh_info.u.v2_mdqi.dqi_qtree;
#line 83
  d->dqb_ihardlimit = (__u32 )m->dqb_ihardlimit;
#line 84
  d->dqb_isoftlimit = (__u32 )m->dqb_isoftlimit;
#line 85
  d->dqb_bhardlimit = (__u32 )m->dqb_bhardlimit;
#line 86
  d->dqb_bsoftlimit = (__u32 )m->dqb_bsoftlimit;
#line 87
  d->dqb_curinodes = (__u32 )m->dqb_curinodes;
#line 88
  d->dqb_curspace = (u_int64_t )((__u64 )m->dqb_curspace);
#line 89
  d->dqb_itime = (u_int64_t )((__u64 )m->dqb_itime);
#line 90
  d->dqb_btime = (u_int64_t )((__u64 )m->dqb_btime);
#line 91
  d->dqb_id = dquot->dq_id;
#line 92
  tmp = qtree_entry_unused(info, (char *)dp);
  }
#line 92
  if (tmp) {
#line 93
    d->dqb_itime = (u_int64_t )((__u64 )1);
  }
#line 94
  return;
}
}
#line 96 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v2.c"
static int v2r0_is_id___6(void *dp , struct dquot *dquot ) 
{ 
  struct v2r0_disk_dqblk *d ;
  struct qtree_mem_dqinfo *info ;
  int tmp ;

  {
  {
#line 98
  d = (struct v2r0_disk_dqblk *)dp;
#line 99
  info = & (dquot->dq_h)->qh_info.u.v2_mdqi.dqi_qtree;
#line 101
  tmp = qtree_entry_unused(info, (char *)dp);
  }
#line 101
  if (tmp) {
#line 102
    return (0);
  }
#line 103
  return (d->dqb_id == dquot->dq_id);
}
}
#line 109 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v2.c"
static void v2r1_disk2memdqblk___6(struct dquot *dquot , void *dp ) 
{ 
  struct util_dqblk *m ;
  struct v2r1_disk_dqblk *d ;
  struct v2r1_disk_dqblk empty ;
  int tmp ;

  {
  {
#line 111
  m = & dquot->dq_dqb;
#line 112
  d = (struct v2r1_disk_dqblk *)dp;
#line 114
  dquot->dq_id = d->dqb_id;
#line 115
  m->dqb_ihardlimit = (qsize_t )((__le64 )d->dqb_ihardlimit);
#line 116
  m->dqb_isoftlimit = (qsize_t )((__le64 )d->dqb_isoftlimit);
#line 117
  m->dqb_bhardlimit = (qsize_t )((__le64 )d->dqb_bhardlimit);
#line 118
  m->dqb_bsoftlimit = (qsize_t )((__le64 )d->dqb_bsoftlimit);
#line 119
  m->dqb_curinodes = (qsize_t )((__le64 )d->dqb_curinodes);
#line 120
  m->dqb_curspace = (qsize_t )((__le64 )d->dqb_curspace);
#line 121
  m->dqb_itime = (time_t )((__le64 )d->dqb_itime);
#line 122
  m->dqb_btime = (time_t )((__le64 )d->dqb_btime);
#line 124
  memset((void *)(& empty), 0, sizeof(struct v2r1_disk_dqblk ));
#line 125
  empty.dqb_itime = (u_int64_t )((__u64 )1);
#line 126
  tmp = memcmp((void const   *)(& empty), (void const   *)dp, sizeof(struct v2r1_disk_dqblk ));
  }
#line 126
  if (! tmp) {
#line 127
    m->dqb_itime = (time_t )0;
  }
#line 128
  return;
}
}
#line 133 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v2.c"
static void v2r1_mem2diskdqblk___6(void *dp , struct dquot *dquot ) 
{ 
  struct util_dqblk *m ;
  struct v2r1_disk_dqblk *d ;
  int tmp ;

  {
  {
#line 135
  m = & dquot->dq_dqb;
#line 136
  d = (struct v2r1_disk_dqblk *)dp;
#line 138
  d->dqb_ihardlimit = (u_int64_t )((__u64 )m->dqb_ihardlimit);
#line 139
  d->dqb_isoftlimit = (u_int64_t )((__u64 )m->dqb_isoftlimit);
#line 140
  d->dqb_bhardlimit = (u_int64_t )((__u64 )m->dqb_bhardlimit);
#line 141
  d->dqb_bsoftlimit = (u_int64_t )((__u64 )m->dqb_bsoftlimit);
#line 142
  d->dqb_curinodes = (u_int64_t )((__u64 )m->dqb_curinodes);
#line 143
  d->dqb_curspace = (u_int64_t )((__u64 )m->dqb_curspace);
#line 144
  d->dqb_itime = (u_int64_t )((__u64 )m->dqb_itime);
#line 145
  d->dqb_btime = (u_int64_t )((__u64 )m->dqb_btime);
#line 146
  d->dqb_id = dquot->dq_id;
#line 147
  d->dqb_pad = (u_int32_t )0;
#line 148
  tmp = qtree_entry_unused(& (dquot->dq_h)->qh_info.u.v2_mdqi.dqi_qtree, (char *)dp);
  }
#line 148
  if (tmp) {
#line 149
    d->dqb_itime = (u_int64_t )((__u64 )1);
  }
#line 150
  return;
}
}
#line 152 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v2.c"
static int v2r1_is_id___6(void *dp , struct dquot *dquot ) 
{ 
  struct v2r1_disk_dqblk *d ;
  struct qtree_mem_dqinfo *info ;
  int tmp ;

  {
  {
#line 154
  d = (struct v2r1_disk_dqblk *)dp;
#line 155
  info = & (dquot->dq_h)->qh_info.u.v2_mdqi.dqi_qtree;
#line 157
  tmp = qtree_entry_unused(info, (char *)dp);
  }
#line 157
  if (tmp) {
#line 158
    return (0);
  }
#line 159
  return (d->dqb_id == dquot->dq_id);
}
}
#line 162 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v2.c"
static struct qtree_fmt_operations v2r0_fmt_ops___6  =    {& v2r0_mem2diskdqblk___6, & v2r0_disk2memdqblk___6, & v2r0_is_id___6};
#line 168 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v2.c"
static struct qtree_fmt_operations v2r1_fmt_ops___6  =    {& v2r1_mem2diskdqblk___6, & v2r1_disk2memdqblk___6, & v2r1_is_id___6};
#line 226 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v2.c"
static int v2_read_header___6(int fd , struct v2_disk_dqheader *h ) 
{ 
  ssize_t tmp ;

  {
  {
#line 228
  lseek(fd, (__off64_t )0, 0);
#line 229
  tmp = read(fd, (void *)h, sizeof(struct v2_disk_dqheader ));
  }
#line 229
  if ((unsigned long )tmp != sizeof(struct v2_disk_dqheader )) {
#line 230
    return (0);
  }
#line 231
  return (1);
}
}
#line 237 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v2.c"
static int v2_check_file___6(int fd , int type , int fmt___7 ) 
{ 
  struct v2_disk_dqheader h ;
  int file_magics[2] ;
  int known_versions___0[2] ;
  int version___0 ;
  int tmp ;
  char *tmp___0 ;
  __u32 tmp___1 ;

  {
  {
#line 240
  file_magics[0] = -641720559;
#line 240
  file_magics[1] = -641722073;
#line 241
  known_versions___0[0] = 1;
#line 241
  known_versions___0[1] = 1;
#line 244
  tmp = v2_read_header___6(fd, & h);
  }
#line 244
  if (! tmp) {
#line 245
    return (0);
  }
#line 246
  if (fmt___7 == 1) {
#line 247
    version___0 = 0;
  } else
#line 248
  if (fmt___7 == 2) {
#line 249
    version___0 = 1;
  } else {
#line 251
    return (0);
  }
#line 253
  if (h.dqh_magic != (__u32 )file_magics[type]) {
    {
#line 254
    tmp___1 = __fswab32(h.dqh_magic);
    }
#line 254
    if (tmp___1 == (__u32 )file_magics[type]) {
      {
#line 255
      tmp___0 = gettext("Your quota file is stored in wrong endianity. Please use convertquota(8) to convert it.\n");
#line 255
      die(3, tmp___0);
      }
    }
#line 256
    return (0);
  }
#line 258
  if (h.dqh_version > (__u32 )known_versions___0[type]) {
#line 259
    return (0);
  }
#line 260
  if ((__u32 )version___0 != h.dqh_version) {
#line 261
    return (0);
  }
#line 262
  return (1);
}
}
#line 268 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v2.c"
static int v2_init_io___6(struct quota_handle *h ) 
{ 
  int tmp ;
  struct v2_kern_dqinfo kdqinfo ;
  int *tmp___0 ;
  long tmp___1 ;
  struct v2_disk_dqinfo ddqinfo ;
  struct v2_disk_dqheader header ;
  int tmp___2 ;
  ssize_t tmp___3 ;

  {
#line 270
  if (h->qh_io_flags & 1) {
#line 271
    if (kernel_iface == 3) {
      {
#line 272
      tmp = vfs_get_info(h);
      }
#line 272
      if (tmp < 0) {
#line 273
        return (-1);
      }
    } else {
      {
#line 278
      tmp___1 = quotactl((2304 << 8) | (h->qh_type & 255), (char const   *)(h->qh_quotadev),
                         (qid_t )0, (caddr_t )((void *)(& kdqinfo)));
      }
#line 278
      if (tmp___1 < 0L) {
        {
#line 280
        tmp___0 = __errno_location();
        }
#line 280
        if (*tmp___0 == 1) {
#line 281
          return (0);
        }
#line 282
        return (-1);
      }
#line 284
      h->qh_info.dqi_bgrace = (time_t )kdqinfo.dqi_bgrace;
#line 285
      h->qh_info.dqi_igrace = (time_t )kdqinfo.dqi_igrace;
#line 286
      h->qh_info.u.v2_mdqi.dqi_flags = kdqinfo.dqi_flags;
#line 287
      h->qh_info.u.v2_mdqi.dqi_qtree.dqi_blocks = kdqinfo.dqi_blocks;
#line 288
      h->qh_info.u.v2_mdqi.dqi_qtree.dqi_free_blk = kdqinfo.dqi_free_blk;
#line 289
      h->qh_info.u.v2_mdqi.dqi_qtree.dqi_free_entry = kdqinfo.dqi_free_entry;
    }
  }
#line 292
  if (h->qh_fd != -1) {
    {
#line 296
    tmp___2 = v2_read_header___6(h->qh_fd, & header);
    }
#line 296
    if (! tmp___2) {
#line 297
      return (-1);
    }
    {
#line 299
    lseek(h->qh_fd, (__off64_t )sizeof(struct v2_disk_dqheader ), 0);
#line 300
    tmp___3 = read(h->qh_fd, (void *)(& ddqinfo), sizeof(ddqinfo));
    }
#line 300
    if ((unsigned long )tmp___3 != sizeof(ddqinfo)) {
#line 301
      return (-1);
    }
#line 303
    if (! (h->qh_io_flags & 1)) {
      {
#line 304
      v2_disk2memdqinfo(& h->qh_info, & ddqinfo);
      }
    } else {
#line 306
      h->qh_info.u.v2_mdqi.dqi_qtree.dqi_blocks = ddqinfo.dqi_blocks;
    }
#line 308
    if (header.dqh_version == 0U) {
#line 309
      h->qh_info.u.v2_mdqi.dqi_qtree.dqi_entry_size = (unsigned int )sizeof(struct v2r0_disk_dqblk );
#line 310
      h->qh_info.u.v2_mdqi.dqi_qtree.dqi_ops = & v2r0_fmt_ops___6;
#line 311
      h->qh_info.dqi_max_b_limit = (uint64_t )(~ ((uint32_t )0));
#line 312
      h->qh_info.dqi_max_i_limit = (uint64_t )(~ ((uint32_t )0));
#line 313
      h->qh_info.dqi_max_b_usage = ~ ((uint64_t )0);
#line 314
      h->qh_info.dqi_max_i_usage = (uint64_t )(~ ((uint32_t )0));
    } else {
#line 316
      h->qh_info.u.v2_mdqi.dqi_qtree.dqi_entry_size = (unsigned int )sizeof(struct v2r1_disk_dqblk );
#line 317
      h->qh_info.u.v2_mdqi.dqi_qtree.dqi_ops = & v2r1_fmt_ops___6;
#line 318
      h->qh_info.dqi_max_b_limit = ~ ((uint64_t )0);
#line 319
      h->qh_info.dqi_max_i_limit = ~ ((uint64_t )0);
#line 320
      h->qh_info.dqi_max_b_usage = ~ ((uint64_t )0);
#line 321
      h->qh_info.dqi_max_i_usage = ~ ((uint64_t )0);
    }
  } else {
#line 325
    h->qh_info.u.v2_mdqi.dqi_qtree.dqi_ops = (struct qtree_fmt_operations *)((void *)0);
  }
#line 327
  return (0);
}
}
#line 333 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v2.c"
static int v2_new_io___6(struct quota_handle *h ) 
{ 
  int file_magics[2] ;
  struct v2_disk_dqheader ddqheader ;
  struct v2_disk_dqinfo ddqinfo ;
  int version___0 ;
  ssize_t tmp ;
  ssize_t tmp___0 ;

  {
#line 335
  file_magics[0] = -641720559;
#line 335
  file_magics[1] = -641722073;
#line 340
  if (h->qh_fmt == 1) {
#line 341
    version___0 = 0;
  } else
#line 342
  if (h->qh_fmt == 2) {
#line 343
    version___0 = 1;
  } else {
#line 345
    return (-1);
  }
  {
#line 348
  ddqheader.dqh_magic = (__u32 )file_magics[h->qh_type];
#line 349
  ddqheader.dqh_version = (__u32 )version___0;
#line 350
  lseek(h->qh_fd, (__off64_t )0, 0);
#line 351
  tmp = write(h->qh_fd, (void const   *)(& ddqheader), sizeof(ddqheader));
  }
#line 351
  if ((unsigned long )tmp != sizeof(ddqheader)) {
#line 352
    return (-1);
  }
#line 354
  h->qh_info.dqi_bgrace = (time_t )604800;
#line 355
  h->qh_info.dqi_igrace = (time_t )604800;
#line 356
  h->qh_info.u.v2_mdqi.dqi_flags = (uint )0;
#line 357
  h->qh_info.u.v2_mdqi.dqi_qtree.dqi_blocks = 2U;
#line 358
  h->qh_info.u.v2_mdqi.dqi_qtree.dqi_free_blk = 0U;
#line 359
  h->qh_info.u.v2_mdqi.dqi_qtree.dqi_free_entry = 0U;
#line 360
  if (version___0 == 0) {
#line 361
    h->qh_info.u.v2_mdqi.dqi_qtree.dqi_entry_size = (unsigned int )sizeof(struct v2r0_disk_dqblk );
#line 362
    h->qh_info.u.v2_mdqi.dqi_qtree.dqi_ops = & v2r0_fmt_ops___6;
#line 363
    h->qh_info.dqi_max_b_limit = (uint64_t )(~ ((uint32_t )0));
#line 364
    h->qh_info.dqi_max_i_limit = (uint64_t )(~ ((uint32_t )0));
#line 365
    h->qh_info.dqi_max_b_usage = ~ ((uint64_t )0);
#line 366
    h->qh_info.dqi_max_i_usage = (uint64_t )(~ ((uint32_t )0));
  } else
#line 367
  if (version___0 == 1) {
#line 368
    h->qh_info.u.v2_mdqi.dqi_qtree.dqi_entry_size = (unsigned int )sizeof(struct v2r1_disk_dqblk );
#line 369
    h->qh_info.u.v2_mdqi.dqi_qtree.dqi_ops = & v2r1_fmt_ops___6;
#line 370
    h->qh_info.dqi_max_b_limit = ~ ((uint64_t )0);
#line 371
    h->qh_info.dqi_max_i_limit = ~ ((uint64_t )0);
#line 372
    h->qh_info.dqi_max_b_usage = ~ ((uint64_t )0);
#line 373
    h->qh_info.dqi_max_i_usage = ~ ((uint64_t )0);
  }
  {
#line 375
  v2_mem2diskdqinfo(& ddqinfo, & h->qh_info);
#line 376
  lseek(h->qh_fd, (__off64_t )sizeof(struct v2_disk_dqheader ), 0);
#line 377
  tmp___0 = write(h->qh_fd, (void const   *)(& ddqinfo), sizeof(ddqinfo));
  }
#line 377
  if ((unsigned long )tmp___0 != sizeof(ddqinfo)) {
#line 378
    return (-1);
  }
#line 379
  return (0);
}
}
#line 385 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v2.c"
static int v2_write_info___6(struct quota_handle *h ) 
{ 
  char *tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  struct v2_kern_dqinfo kdqinfo ;
  long tmp___2 ;
  long tmp___3 ;
  struct v2_disk_dqinfo ddqinfo ;
  ssize_t tmp___4 ;

  {
#line 387
  if (h->qh_io_flags & 4) {
    {
#line 388
    tmp = gettext("Trying to write info to readonly quotafile on %s\n");
#line 388
    errstr(tmp, h->qh_quotadev);
#line 389
    tmp___0 = __errno_location();
#line 389
    *tmp___0 = 1;
    }
#line 390
    return (-1);
  }
#line 392
  if (h->qh_io_flags & 1) {
#line 393
    if (kernel_iface == 3) {
      {
#line 394
      tmp___1 = vfs_set_info(h, 3);
      }
#line 394
      if (tmp___1) {
#line 395
        return (-1);
      }
    } else {
      {
#line 400
      kdqinfo.dqi_bgrace = (unsigned int )h->qh_info.dqi_bgrace;
#line 401
      kdqinfo.dqi_igrace = (unsigned int )h->qh_info.dqi_igrace;
#line 402
      kdqinfo.dqi_flags = h->qh_info.u.v2_mdqi.dqi_flags;
#line 403
      kdqinfo.dqi_blocks = h->qh_info.u.v2_mdqi.dqi_qtree.dqi_blocks;
#line 404
      kdqinfo.dqi_free_blk = h->qh_info.u.v2_mdqi.dqi_qtree.dqi_free_blk;
#line 405
      kdqinfo.dqi_free_entry = h->qh_info.u.v2_mdqi.dqi_qtree.dqi_free_entry;
#line 406
      tmp___2 = quotactl((2816 << 8) | (h->qh_type & 255), (char const   *)(h->qh_quotadev),
                         (qid_t )0, (caddr_t )((void *)(& kdqinfo)));
      }
#line 406
      if (tmp___2 < 0L) {
#line 408
        return (-1);
      } else {
        {
#line 406
        tmp___3 = quotactl((3072 << 8) | (h->qh_type & 255), (char const   *)(h->qh_quotadev),
                           (qid_t )0, (caddr_t )((void *)(& kdqinfo)));
        }
#line 406
        if (tmp___3 < 0L) {
#line 408
          return (-1);
        }
      }
    }
  } else {
    {
#line 414
    v2_mem2diskdqinfo(& ddqinfo, & h->qh_info);
#line 415
    lseek(h->qh_fd, (__off64_t )sizeof(struct v2_disk_dqheader ), 0);
#line 416
    tmp___4 = write(h->qh_fd, (void const   *)(& ddqinfo), sizeof(ddqinfo));
    }
#line 416
    if ((unsigned long )tmp___4 != sizeof(ddqinfo)) {
#line 417
      return (-1);
    }
  }
#line 419
  return (0);
}
}
#line 426 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v2.c"
static struct dquot *v2_read_dquot___6(struct quota_handle *h , qid_t id___0 ) 
{ 
  struct dquot *dquot ;
  struct dquot *tmp ;
  int tmp___0 ;
  struct v2_kern_dqblk kdqblk ;
  long tmp___1 ;
  struct dquot *tmp___2 ;

  {
#line 428
  if (h->qh_io_flags & 1) {
    {
#line 429
    tmp = get_empty_dquot();
#line 429
    dquot = tmp;
#line 431
    dquot->dq_id = id___0;
#line 432
    dquot->dq_h = h;
#line 433
    dquot->dq_dqb.u.v2_mdqb.dqb_off = (loff_t )0;
#line 434
    memset((void *)(& dquot->dq_dqb), 0, sizeof(struct util_dqblk ));
    }
#line 435
    if (kernel_iface == 3) {
      {
#line 436
      tmp___0 = vfs_get_dquot(dquot);
      }
#line 436
      if (tmp___0 < 0) {
        {
#line 437
        free((void *)dquot);
        }
#line 438
        return ((struct dquot *)((void *)0));
      }
    } else {
      {
#line 444
      tmp___1 = quotactl((3328 << 8) | (h->qh_type & 255), (char const   *)(h->qh_quotadev),
                         id___0, (caddr_t )((void *)(& kdqblk)));
      }
#line 444
      if (tmp___1 < 0L) {
        {
#line 445
        free((void *)dquot);
        }
#line 446
        return ((struct dquot *)((void *)0));
      }
      {
#line 448
      v2_kern2utildqblk(& dquot->dq_dqb, & kdqblk);
      }
    }
#line 450
    return (dquot);
  }
  {
#line 452
  tmp___2 = qtree_read_dquot(h, id___0);
  }
#line 452
  return (tmp___2);
}
}
#line 459 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v2.c"
static int v2_commit_dquot___6(struct dquot *dquot , int flags___7 ) 
{ 
  struct util_dqblk *b ;
  char *tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  struct v2_kern_dqblk kdqblk ;
  int cmd ;
  int *tmp___2 ;
  long tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;

  {
#line 461
  b = & dquot->dq_dqb;
#line 463
  if ((dquot->dq_h)->qh_io_flags & 4) {
    {
#line 464
    tmp = gettext("Trying to write quota to readonly quotafile on %s\n");
#line 464
    errstr(tmp, (dquot->dq_h)->qh_quotadev);
#line 465
    tmp___0 = __errno_location();
#line 465
    *tmp___0 = 1;
    }
#line 466
    return (-1);
  }
#line 468
  if ((dquot->dq_h)->qh_io_flags & 1) {
#line 469
    if (kernel_iface == 3) {
      {
#line 470
      tmp___1 = vfs_set_dquot(dquot, flags___7);
      }
#line 470
      if (tmp___1 < 0) {
#line 471
        return (-1);
      }
    } else {
#line 477
      if (flags___7 == 10) {
#line 478
        cmd = 3840;
      } else
#line 479
      if (flags___7 == 5) {
#line 480
        cmd = 1792;
      } else
#line 481
      if (flags___7 & 48) {
        {
#line 482
        tmp___2 = __errno_location();
#line 482
        *tmp___2 = 22;
        }
#line 483
        return (-1);
      } else {
#line 486
        cmd = 3584;
      }
      {
#line 487
      v2_util2kerndqblk(& kdqblk, & dquot->dq_dqb);
#line 488
      tmp___3 = quotactl((cmd << 8) | ((dquot->dq_h)->qh_type & 255), (char const   *)((dquot->dq_h)->qh_quotadev),
                         dquot->dq_id, (caddr_t )((void *)(& kdqblk)));
      }
#line 488
      if (tmp___3 < 0L) {
#line 490
        return (-1);
      }
    }
#line 492
    return (0);
  }
#line 494
  if (! b->dqb_curspace) {
#line 494
    if (! b->dqb_curinodes) {
#line 494
      if (! b->dqb_bsoftlimit) {
#line 494
        if (! b->dqb_isoftlimit) {
#line 494
          if (! b->dqb_bhardlimit) {
#line 494
            if (! b->dqb_ihardlimit) {
              {
#line 496
              qtree_delete_dquot(dquot);
              }
            } else {
#line 494
              goto _L___3;
            }
          } else {
#line 494
            goto _L___3;
          }
        } else {
#line 494
          goto _L___3;
        }
      } else {
#line 494
        goto _L___3;
      }
    } else {
#line 494
      goto _L___3;
    }
  } else {
    _L___3: /* CIL Label */ 
    {
#line 498
    tmp___5 = check_dquot_range(dquot);
    }
#line 498
    if (tmp___5 < 0) {
      {
#line 499
      tmp___4 = __errno_location();
#line 499
      *tmp___4 = 34;
      }
#line 500
      return (-1);
    }
    {
#line 502
    qtree_write_dquot(dquot);
    }
  }
#line 504
  return (0);
}
}
#line 507 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v2.c"
static int v2_scan_dquots___6(struct quota_handle *h , int (*process_dquot)(struct dquot *dquot ,
                                                                            char *dqname ) ) 
{ 
  int tmp ;

  {
  {
#line 509
  tmp = qtree_scan_dquots(h, process_dquot);
  }
#line 509
  return (tmp);
}
}
#line 513 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v2.c"
static int v2_report___6(struct quota_handle *h , int verbose ) 
{ 
  struct v2_mem_dqinfo *info ;
  char *tmp ;

  {
#line 515
  if (verbose) {
    {
#line 516
    info = & h->qh_info.u.v2_mdqi;
#line 518
    tmp = gettext("Statistics:\nTotal blocks: %u\nData blocks: %u\nEntries: %u\nUsed average: %f\n");
#line 518
    printf((char const   */* __restrict  */)tmp, info->dqi_qtree.dqi_blocks, info->dqi_data_blocks,
           info->dqi_used_entries, (double )((float )info->dqi_used_entries / (float )info->dqi_data_blocks));
    }
  }
#line 522
  return (0);
}
}
#line 31 "/home/wheatley/newnew/temp/quota-4.01/quotacheck.h"
struct util_dqinfo old_info[2] ;
#line 39
void ( /* format attribute */  debug)(int df , char *fmtstr  , ...) ;
#line 42
struct dquot *add_dquot(qid_t id___0 , int type ) ;
#line 45
int v1_buffer_file(char *filename , int fd , int type ) ;
#line 21 "/home/wheatley/newnew/temp/quota-4.01/quotacheck_v1.c"
static void load_dquots(char *filename , int fd , int type ) 
{ 
  struct v1_disk_dqblk ddqblk ;
  struct util_dqblk *udq ;
  struct dquot *dquot ;
  int err ;
  qid_t id___0 ;
  int *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  ssize_t tmp___3 ;

  {
  {
#line 27
  id___0 = (qid_t )0;
#line 29
  lseek(fd, (__off64_t )0, 0);
  }
  {
#line 30
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 30
    tmp___3 = read(fd, (void *)(& ddqblk), sizeof(ddqblk));
#line 30
    err = (int )tmp___3;
    }
#line 30
    if (! err) {
#line 30
      goto while_break;
    }
#line 31
    if (err < 0) {
      {
#line 32
      tmp = __errno_location();
#line 32
      tmp___0 = strerror(*tmp);
#line 32
      tmp___1 = gettext("Cannot read entry for id %u from quotafile %s: %s\n");
#line 32
      die(1, tmp___1, id___0, filename, tmp___0);
      }
    }
#line 34
    if ((unsigned long )err != sizeof(ddqblk)) {
      {
#line 35
      tmp___2 = gettext("Entry for id %u is truncated.\n");
#line 35
      errstr(tmp___2, id___0);
      }
#line 37
      goto while_break;
    }
#line 39
    if (ddqblk.dqb_bhardlimit == 0U) {
#line 39
      if (ddqblk.dqb_bsoftlimit == 0U) {
#line 39
        if (ddqblk.dqb_ihardlimit == 0U) {
#line 39
          if (ddqblk.dqb_isoftlimit == 0U) {
#line 43
            id___0 ++;
#line 44
            goto while_continue;
          }
        }
      }
    }
    {
#line 46
    dquot = add_dquot(id___0, type);
#line 47
    udq = & dquot->dq_dqb;
#line 48
    udq->dqb_bhardlimit = (qsize_t )ddqblk.dqb_bhardlimit;
#line 49
    udq->dqb_bsoftlimit = (qsize_t )ddqblk.dqb_bsoftlimit;
#line 50
    udq->dqb_ihardlimit = (qsize_t )ddqblk.dqb_ihardlimit;
#line 51
    udq->dqb_isoftlimit = (qsize_t )ddqblk.dqb_isoftlimit;
#line 52
    udq->dqb_btime = ddqblk.dqb_btime;
#line 53
    udq->dqb_itime = ddqblk.dqb_itime;
#line 54
    id___0 ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 56
  return;
}
}
#line 59 "/home/wheatley/newnew/temp/quota-4.01/quotacheck_v1.c"
static int check_info(char *filename , int fd , int type ) 
{ 
  struct v1_disk_dqblk ddqblk ;
  int err ;
  char *tmp ;
  ssize_t tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;

  {
  {
#line 64
  tmp = gettext("Loading first quota entry with grace times.\n");
#line 64
  debug(4, tmp);
#line 65
  lseek(fd, (__off64_t )0, 0);
#line 66
  tmp___0 = read(fd, (void *)(& ddqblk), sizeof(ddqblk));
#line 66
  err = (int )tmp___0;
  }
#line 67
  if (err < 0) {
    {
#line 68
    tmp___1 = __errno_location();
#line 68
    tmp___2 = strerror(*tmp___1);
#line 68
    tmp___3 = gettext("Cannot read first entry from quotafile %s: %s\n");
#line 68
    die(1, tmp___3, filename, tmp___2);
    }
  }
#line 70
  if ((unsigned long )err != sizeof(ddqblk)) {
    {
#line 71
    tmp___4 = gettext("WARNING - Quotafile %s was probably truncated. Cannot save quota settings...\n");
#line 71
    errstr(tmp___4, filename);
    }
#line 74
    return (-1);
  }
  {
#line 76
  old_info[type].dqi_bgrace = ddqblk.dqb_btime;
#line 77
  old_info[type].dqi_igrace = ddqblk.dqb_itime;
#line 78
  tmp___5 = gettext("First entry loaded.\n");
#line 78
  debug(4, tmp___5);
  }
#line 79
  return (0);
}
}
#line 82 "/home/wheatley/newnew/temp/quota-4.01/quotacheck_v1.c"
int v1_buffer_file(char *filename , int fd , int type ) 
{ 
  int tmp ;

  {
#line 84
  old_info[type].dqi_bgrace = (time_t )604800;
#line 85
  old_info[type].dqi_igrace = (time_t )604800;
#line 86
  if (flags & 32) {
#line 87
    return (0);
  }
  {
#line 88
  tmp = check_info(filename, fd, type);
  }
#line 88
  if (tmp < 0) {
#line 89
    return (0);
  }
  {
#line 90
  load_dquots(filename, fd, type);
  }
#line 91
  return (0);
}
}
#line 50 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v1.c"
static int v1_check_file___6(int fd , int type , int fmt___7 ) ;
#line 51
static int v1_init_io___6(struct quota_handle *h ) ;
#line 52
static int v1_new_io___6(struct quota_handle *h ) ;
#line 53
static int v1_write_info___6(struct quota_handle *h ) ;
#line 54
static struct dquot *v1_read_dquot___6(struct quota_handle *h , qid_t id___0 ) ;
#line 55
static int v1_commit_dquot___6(struct dquot *dquot , int flags___7 ) ;
#line 56
static int v1_scan_dquots___6(struct quota_handle *h , int (*process_dquot)(struct dquot *dquot ,
                                                                            char *dqname ) ) ;
#line 127 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v1.c"
static int v1_check_file___6(int fd , int type , int fmt___7 ) 
{ 
  struct stat st ;
  int tmp ;

  {
  {
#line 131
  tmp = fstat(fd, & st);
  }
#line 131
  if (tmp < 0) {
#line 132
    return (0);
  }
#line 133
  if (! st.st_size) {
#line 134
    return (0);
  } else
#line 133
  if ((unsigned long )st.st_size % sizeof(struct v1_disk_dqblk )) {
#line 134
    return (0);
  }
#line 135
  return (1);
}
}
#line 141 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v1.c"
static int v1_init_io___6(struct quota_handle *h ) 
{ 
  int tmp ;
  struct v1_kern_dqblk kdqblk ;
  time_t tmp___0 ;
  int *tmp___1 ;
  long tmp___2 ;
  struct v1_disk_dqblk ddqblk ;
  ssize_t tmp___3 ;

  {
#line 143
  if (h->qh_io_flags & 1) {
#line 144
    if (kernel_iface == 3) {
      {
#line 145
      tmp = vfs_get_info(h);
      }
#line 145
      if (tmp < 0) {
#line 146
        return (-1);
      }
    } else {
      {
#line 151
      tmp___2 = quotactl((768 << 8) | (h->qh_type & 255), (char const   *)(h->qh_quotadev),
                         (qid_t )0, (caddr_t )((void *)(& kdqblk)));
      }
#line 151
      if (tmp___2 < 0L) {
        {
#line 152
        tmp___1 = __errno_location();
        }
#line 152
        if (*tmp___1 == 1) {
#line 153
          tmp___0 = (time_t )0;
#line 153
          h->qh_info.dqi_igrace = tmp___0;
#line 153
          h->qh_info.dqi_bgrace = tmp___0;
        } else {
#line 156
          return (-1);
        }
      } else {
#line 159
        h->qh_info.dqi_bgrace = kdqblk.dqb_btime;
#line 160
        h->qh_info.dqi_igrace = kdqblk.dqb_itime;
      }
    }
  } else {
    {
#line 167
    lseek(h->qh_fd, (__off64_t )0, 0);
#line 168
    tmp___3 = read(h->qh_fd, (void *)(& ddqblk), sizeof(ddqblk));
    }
#line 168
    if ((unsigned long )tmp___3 != sizeof(ddqblk)) {
#line 169
      return (-1);
    }
#line 170
    h->qh_info.dqi_bgrace = ddqblk.dqb_btime;
#line 171
    h->qh_info.dqi_igrace = ddqblk.dqb_itime;
  }
#line 173
  if (! h->qh_info.dqi_bgrace) {
#line 174
    h->qh_info.dqi_bgrace = (time_t )604800;
  }
#line 175
  if (! h->qh_info.dqi_igrace) {
#line 176
    h->qh_info.dqi_igrace = (time_t )604800;
  }
#line 177
  h->qh_info.dqi_max_b_limit = (uint64_t )(~ ((uint32_t )0));
#line 178
  h->qh_info.dqi_max_i_limit = (uint64_t )(~ ((uint32_t )0));
#line 179
  h->qh_info.dqi_max_b_usage = 4294967295UL << 10;
#line 180
  h->qh_info.dqi_max_i_usage = (uint64_t )(~ ((uint32_t )0));
#line 182
  return (0);
}
}
#line 188 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v1.c"
static int v1_new_io___6(struct quota_handle *h ) 
{ 
  struct v1_disk_dqblk ddqblk ;
  ssize_t tmp ;

  {
  {
#line 193
  memset((void *)(& ddqblk), 0, sizeof(ddqblk));
#line 194
  ddqblk.dqb_btime = (time_t )604800;
#line 195
  ddqblk.dqb_itime = (time_t )604800;
#line 196
  h->qh_info.dqi_bgrace = (time_t )604800;
#line 197
  h->qh_info.dqi_igrace = (time_t )604800;
#line 198
  h->qh_info.dqi_max_b_limit = (uint64_t )(~ ((uint32_t )0));
#line 199
  h->qh_info.dqi_max_i_limit = (uint64_t )(~ ((uint32_t )0));
#line 200
  h->qh_info.dqi_max_b_usage = 4294967295UL << 10;
#line 201
  h->qh_info.dqi_max_i_usage = (uint64_t )(~ ((uint32_t )0));
#line 202
  lseek(h->qh_fd, (__off64_t )0, 0);
#line 203
  tmp = write(h->qh_fd, (void const   *)(& ddqblk), sizeof(ddqblk));
  }
#line 203
  if ((unsigned long )tmp != sizeof(ddqblk)) {
#line 204
    return (-1);
  }
#line 205
  return (0);
}
}
#line 211 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v1.c"
static int v1_write_info___6(struct quota_handle *h ) 
{ 
  char *tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  struct v1_kern_dqblk kdqblk ;
  long tmp___2 ;
  long tmp___3 ;
  struct v1_disk_dqblk ddqblk ;
  ssize_t tmp___4 ;
  ssize_t tmp___5 ;

  {
#line 213
  if (h->qh_io_flags & 4) {
    {
#line 214
    tmp = gettext("Trying to write info to readonly quotafile on %s.\n");
#line 214
    errstr(tmp, h->qh_quotadev);
#line 215
    tmp___0 = __errno_location();
#line 215
    *tmp___0 = 1;
    }
#line 216
    return (-1);
  }
#line 218
  if (h->qh_io_flags & 1) {
#line 219
    if (kernel_iface == 3) {
      {
#line 220
      tmp___1 = vfs_set_info(h, 3);
      }
#line 220
      if (tmp___1 < 0) {
#line 221
        return (-1);
      }
    } else {
      {
#line 226
      tmp___2 = quotactl((768 << 8) | (h->qh_type & 255), (char const   *)(h->qh_quotadev),
                         (qid_t )0, (caddr_t )((void *)(& kdqblk)));
      }
#line 226
      if (tmp___2 < 0L) {
#line 227
        return (-1);
      }
      {
#line 228
      kdqblk.dqb_btime = h->qh_info.dqi_bgrace;
#line 229
      kdqblk.dqb_itime = h->qh_info.dqi_igrace;
#line 230
      tmp___3 = quotactl((1024 << 8) | (h->qh_type & 255), (char const   *)(h->qh_quotadev),
                         (qid_t )0, (caddr_t )((void *)(& kdqblk)));
      }
#line 230
      if (tmp___3 < 0L) {
#line 231
        return (-1);
      }
    }
  } else {
    {
#line 237
    lseek(h->qh_fd, (__off64_t )0, 0);
#line 238
    tmp___4 = read(h->qh_fd, (void *)(& ddqblk), sizeof(ddqblk));
    }
#line 238
    if ((unsigned long )tmp___4 != sizeof(ddqblk)) {
#line 239
      return (-1);
    }
    {
#line 240
    ddqblk.dqb_btime = h->qh_info.dqi_bgrace;
#line 241
    ddqblk.dqb_itime = h->qh_info.dqi_igrace;
#line 242
    lseek(h->qh_fd, (__off64_t )0, 0);
#line 243
    tmp___5 = write(h->qh_fd, (void const   *)(& ddqblk), sizeof(ddqblk));
    }
#line 243
    if ((unsigned long )tmp___5 != sizeof(ddqblk)) {
#line 244
      return (-1);
    }
  }
#line 246
  return (0);
}
}
#line 253 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v1.c"
static struct dquot *v1_read_dquot___6(struct quota_handle *h , qid_t id___0 ) 
{ 
  struct v1_disk_dqblk ddqblk ;
  struct dquot *dquot ;
  struct dquot *tmp ;
  int tmp___0 ;
  struct v1_kern_dqblk kdqblk ;
  long tmp___1 ;
  ssize_t tmp___2 ;

  {
  {
#line 256
  tmp = get_empty_dquot();
#line 256
  dquot = tmp;
#line 258
  dquot->dq_id = id___0;
#line 259
  dquot->dq_h = h;
  }
#line 260
  if (h->qh_io_flags & 1) {
#line 261
    if (kernel_iface == 3) {
      {
#line 262
      tmp___0 = vfs_get_dquot(dquot);
      }
#line 262
      if (tmp___0 < 0) {
        {
#line 263
        free((void *)dquot);
        }
#line 264
        return ((struct dquot *)((void *)0));
      }
    } else {
      {
#line 270
      tmp___1 = quotactl((768 << 8) | (h->qh_type & 255), (char const   *)(h->qh_quotadev),
                         id___0, (caddr_t )((void *)(& kdqblk)));
      }
#line 270
      if (tmp___1 < 0L) {
        {
#line 271
        free((void *)dquot);
        }
#line 272
        return ((struct dquot *)((void *)0));
      }
      {
#line 274
      v1_kern2utildqblk(& dquot->dq_dqb, & kdqblk);
      }
    }
  } else {
    {
#line 278
    lseek(h->qh_fd, (loff_t )((unsigned long )id___0 * sizeof(struct v1_disk_dqblk )),
          0);
#line 279
    tmp___2 = read(h->qh_fd, (void *)(& ddqblk), sizeof(ddqblk));
    }
    {
#line 280
    if (tmp___2 == 0L) {
#line 280
      goto case_0;
    }
#line 287
    if (tmp___2 == (ssize_t )sizeof(struct v1_disk_dqblk )) {
#line 287
      goto case_exp;
    }
#line 290
    goto switch_default;
    case_0: /* CIL Label */ 
    {
#line 285
    memset((void *)(& dquot->dq_dqb), 0, sizeof(struct util_dqblk ));
    }
#line 286
    goto switch_break;
    case_exp: /* CIL Label */ 
    {
#line 288
    v1_disk2memdqblk(& dquot->dq_dqb, & ddqblk);
    }
#line 289
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 291
    free((void *)dquot);
    }
#line 292
    return ((struct dquot *)((void *)0));
    switch_break: /* CIL Label */ ;
    }
  }
#line 295
  return (dquot);
}
}
#line 302 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v1.c"
static int v1_commit_dquot___6(struct dquot *dquot , int flags___7 ) 
{ 
  struct v1_disk_dqblk ddqblk ;
  struct quota_handle *h ;
  char *tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  struct v1_kern_dqblk kdqblk ;
  int cmd ;
  int *tmp___2 ;
  long tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;
  ssize_t tmp___6 ;

  {
#line 305
  h = dquot->dq_h;
#line 307
  if (h->qh_io_flags & 4) {
    {
#line 308
    tmp = gettext("Trying to write quota to readonly quotafile on %s\n");
#line 308
    errstr(tmp, h->qh_quotadev);
#line 309
    tmp___0 = __errno_location();
#line 309
    *tmp___0 = 1;
    }
#line 310
    return (-1);
  }
#line 312
  if (h->qh_io_flags & 1) {
#line 313
    if (kernel_iface == 3) {
      {
#line 314
      tmp___1 = vfs_set_dquot(dquot, flags___7);
      }
#line 314
      if (tmp___1 < 0) {
#line 315
        return (-1);
      }
    } else {
#line 321
      if (flags___7 == 10) {
#line 322
        cmd = 1280;
      } else
#line 323
      if (flags___7 == 5) {
#line 324
        cmd = 1792;
      } else
#line 325
      if (flags___7 & 48) {
        {
#line 326
        tmp___2 = __errno_location();
#line 326
        *tmp___2 = 22;
        }
#line 327
        return (-1);
      } else {
#line 330
        cmd = 1024;
      }
      {
#line 331
      v1_util2kerndqblk(& kdqblk, & dquot->dq_dqb);
#line 332
      tmp___3 = quotactl((cmd << 8) | (h->qh_type & 255), (char const   *)(h->qh_quotadev),
                         dquot->dq_id, (caddr_t )((void *)(& kdqblk)));
      }
#line 332
      if (tmp___3 < 0L) {
#line 334
        return (-1);
      }
    }
  } else {
    {
#line 338
    tmp___5 = check_dquot_range(dquot);
    }
#line 338
    if (tmp___5 < 0) {
      {
#line 339
      tmp___4 = __errno_location();
#line 339
      *tmp___4 = 34;
      }
#line 340
      return (-1);
    }
    {
#line 342
    v1_mem2diskdqblk(& ddqblk, & dquot->dq_dqb);
#line 343
    lseek(h->qh_fd, (loff_t )((unsigned long )dquot->dq_id * sizeof(struct v1_disk_dqblk )),
          0);
#line 344
    tmp___6 = write(h->qh_fd, (void const   *)(& ddqblk), sizeof(ddqblk));
    }
#line 344
    if ((unsigned long )tmp___6 != sizeof(ddqblk)) {
#line 345
      return (-1);
    }
  }
#line 347
  return (0);
}
}
#line 355 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v1.c"
static int v1_scan_dquots___6(struct quota_handle *h , int (*process_dquot)(struct dquot *dquot ,
                                                                            char *dqname ) ) 
{ 
  int rd ;
  int scanbufpos ;
  int scanbufsize ;
  char scanbuf[sizeof(struct v1_disk_dqblk ) * 256UL] ;
  struct v1_disk_dqblk *ddqblk ;
  struct dquot *dquot ;
  struct dquot *tmp ;
  qid_t id___0 ;
  ssize_t tmp___0 ;

  {
  {
#line 357
  scanbufpos = 0;
#line 357
  scanbufsize = 0;
#line 360
  tmp = get_empty_dquot();
#line 360
  dquot = tmp;
#line 361
  id___0 = (qid_t )0;
#line 363
  memset((void *)dquot, 0, sizeof(*dquot));
#line 364
  dquot->dq_h = h;
#line 365
  lseek(h->qh_fd, (__off64_t )0, 0);
#line 366
  id___0 = (qid_t )0;
  }
  {
#line 366
  while (1) {
    while_continue: /* CIL Label */ ;
#line 367
    if (scanbufpos >= scanbufsize) {
      {
#line 368
      tmp___0 = read(h->qh_fd, (void *)(scanbuf), sizeof(scanbuf));
#line 368
      rd = (int )tmp___0;
      }
#line 369
      if (rd < 0) {
#line 370
        goto out_err;
      } else
#line 369
      if ((unsigned long )rd % sizeof(struct v1_disk_dqblk )) {
#line 370
        goto out_err;
      }
#line 371
      if (! rd) {
#line 372
        goto while_break;
      }
#line 373
      scanbufpos = 0;
#line 374
      scanbufsize = (int )((unsigned long )rd / sizeof(struct v1_disk_dqblk ));
    }
#line 376
    ddqblk = (struct v1_disk_dqblk *)(scanbuf) + scanbufpos;
#line 377
    if ((((long )(((((ddqblk->dqb_ihardlimit | ddqblk->dqb_isoftlimit) | ddqblk->dqb_bhardlimit) | ddqblk->dqb_bsoftlimit) | ddqblk->dqb_curblocks) | ddqblk->dqb_curinodes) | ddqblk->dqb_itime) | ddqblk->dqb_btime) == 0L) {
#line 381
      goto __Cont;
    }
    {
#line 382
    v1_disk2memdqblk(& dquot->dq_dqb, ddqblk);
#line 383
    dquot->dq_id = id___0;
#line 384
    rd = (*process_dquot)(dquot, (char *)((void *)0));
    }
#line 384
    if (rd < 0) {
      {
#line 385
      free((void *)dquot);
      }
#line 386
      return (rd);
    }
    __Cont: /* CIL Label */ 
#line 366
    id___0 ++;
#line 366
    scanbufpos ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 389
  if (! rd) {
    {
#line 390
    free((void *)dquot);
    }
#line 391
    return (0);
  }
  out_err: 
  {
#line 394
  free((void *)dquot);
  }
#line 395
  return (-1);
}
}
#line 10 "/home/wheatley/newnew/temp/quota-4.01/rquota_clnt.c"
static struct timeval TIMEOUT___6  =    {(__time_t )25, (__suseconds_t )0};
#line 15 "/home/wheatley/newnew/temp/quota-4.01/rquota_clnt.c"
static getquota_rslt clnt_res___55  ;
#line 30 "/home/wheatley/newnew/temp/quota-4.01/rquota_clnt.c"
static getquota_rslt clnt_res___56  ;
#line 45 "/home/wheatley/newnew/temp/quota-4.01/rquota_clnt.c"
static setquota_rslt clnt_res___57  ;
#line 60 "/home/wheatley/newnew/temp/quota-4.01/rquota_clnt.c"
static setquota_rslt clnt_res___58  ;
#line 75 "/home/wheatley/newnew/temp/quota-4.01/rquota_clnt.c"
static getquota_rslt clnt_res___59  ;
#line 90 "/home/wheatley/newnew/temp/quota-4.01/rquota_clnt.c"
static getquota_rslt clnt_res___60  ;
#line 105 "/home/wheatley/newnew/temp/quota-4.01/rquota_clnt.c"
static setquota_rslt clnt_res___61  ;
#line 120 "/home/wheatley/newnew/temp/quota-4.01/rquota_clnt.c"
static setquota_rslt clnt_res___62  ;
#line 18 "/home/wheatley/newnew/temp/quota-4.01/quotaio_rpc.c"
static int rpc_init_io___6(struct quota_handle *h ) ;
#line 19
static struct dquot *rpc_read_dquot___6(struct quota_handle *h , qid_t id___0 ) ;
#line 20
static int rpc_commit_dquot___6(struct dquot *dquot , int flags___7 ) ;
#line 31 "/home/wheatley/newnew/temp/quota-4.01/quotaio_rpc.c"
static int rpc_init_io___6(struct quota_handle *h ) 
{ 


  {
#line 34
  h->qh_info.dqi_max_b_limit = (uint64_t )(~ ((uint32_t )0));
#line 35
  h->qh_info.dqi_max_i_limit = (uint64_t )(~ ((uint32_t )0));
#line 36
  h->qh_info.dqi_max_b_usage = (uint64_t )(4294967295U << 10);
#line 37
  h->qh_info.dqi_max_i_usage = (uint64_t )(~ ((uint32_t )0));
#line 38
  return (0);
}
}
#line 47 "/home/wheatley/newnew/temp/quota-4.01/quotaio_rpc.c"
static struct dquot *rpc_read_dquot___6(struct quota_handle *h , qid_t id___0 ) 
{ 
  struct dquot *dquot ;
  struct dquot *tmp ;
  int ret ;
  int *tmp___0 ;

  {
  {
#line 50
  tmp = get_empty_dquot();
#line 50
  dquot = tmp;
#line 53
  dquot->dq_id = id___0;
#line 54
  dquot->dq_h = h;
#line 55
  ret = rpc_rquota_get(dquot);
  }
#line 55
  if (ret < 0) {
    {
#line 56
    tmp___0 = __errno_location();
#line 56
    *tmp___0 = - ret;
#line 57
    free((void *)dquot);
    }
#line 58
    return ((struct dquot *)((void *)0));
  }
#line 60
  return (dquot);
}
}
#line 70 "/home/wheatley/newnew/temp/quota-4.01/quotaio_rpc.c"
static int rpc_commit_dquot___6(struct dquot *dquot , int flags___7 ) 
{ 
  int ret ;
  char *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;

  {
#line 75
  if ((dquot->dq_h)->qh_io_flags & 4) {
    {
#line 76
    tmp = gettext("Trying to write quota to readonly quotafile on %s\n");
#line 76
    errstr(tmp, (dquot->dq_h)->qh_quotadev);
#line 77
    tmp___0 = __errno_location();
#line 77
    *tmp___0 = 1;
    }
#line 78
    return (-1);
  }
  {
#line 80
  ret = rpc_rquota_set((1024 << 8) | ((dquot->dq_h)->qh_type & 255), dquot);
  }
#line 80
  if (ret < 0) {
    {
#line 81
    tmp___1 = __errno_location();
#line 81
    *tmp___1 = - ret;
    }
#line 82
    return (-1);
  }
#line 84
  return (0);
}
}
#line 89 "/home/wheatley/newnew/temp/quota-4.01/rquota_client.c"
static int rquota_err___6(int stat___0 ) 
{ 


  {
  {
#line 92
  if (stat___0 == -1) {
#line 92
    goto case_neg_1;
  }
#line 94
  if (stat___0 == 0) {
#line 94
    goto case_0;
  }
#line 96
  if (stat___0 == 2) {
#line 96
    goto case_2;
  }
#line 98
  if (stat___0 == 1) {
#line 98
    goto case_1;
  }
#line 100
  if (stat___0 == 3) {
#line 100
    goto case_3;
  }
#line 102
  goto switch_default;
  case_neg_1: /* CIL Label */ 
#line 93
  return (-111);
  case_0: /* CIL Label */ 
#line 95
  return (-38);
  case_2: /* CIL Label */ 
#line 97
  return (-2);
  case_1: /* CIL Label */ 
#line 99
  return (0);
  case_3: /* CIL Label */ 
#line 101
  return (-1);
  switch_default: /* CIL Label */ 
#line 103
  return (-22);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 107 "/home/wheatley/newnew/temp/quota-4.01/rquota_client.c"
static int split_nfs_mount___6(char *devname , char **host , char **path ) 
{ 
  char *pathname ;

  {
#line 112
  if ((int )*devname == 91) {
    {
#line 113
    *host = devname + 1;
#line 114
    pathname = strchr((char const   *)devname, ']');
    }
#line 115
    if (! pathname) {
#line 116
      return (0);
    } else
#line 115
    if ((int )*(pathname + 1) != 58) {
#line 116
      return (0);
    }
#line 118
    if ((int )*(pathname + 2) == 40) {
#line 119
      return (0);
    }
#line 120
    *pathname = (char)0;
#line 121
    *path = pathname + 2;
#line 122
    return (1);
  }
  {
#line 124
  *host = devname;
#line 125
  pathname = strchr((char const   *)devname, ':');
  }
#line 126
  if (! pathname) {
#line 127
    return (0);
  }
#line 129
  if ((int )*(pathname + 1) == 40) {
#line 130
    return (0);
  }
#line 131
  *pathname = (char)0;
#line 132
  *path = pathname + 1;
#line 133
  return (1);
}
}
#line 242 "/usr/include/stdio.h"
extern int fflush(FILE *__stream ) ;
#line 38 "/home/wheatley/newnew/temp/quota-4.01/quotacheck.h"
void *xmalloc(size_t size ) ;
#line 40
int ask_yn(char *q , int def ) ;
#line 41
struct dquot *lookup_dquot(qid_t id___0 , int type ) ;
#line 43
int v2_detect_version(char *filename , int fd , int type ) ;
#line 44
int v2_buffer_file(char *filename , int fd , int type , int fmt___7 ) ;
#line 46
void v2_merge_info(struct util_dqinfo *new , struct util_dqinfo *old ) ;
#line 33 "/home/wheatley/newnew/temp/quota-4.01/quotacheck_v2.c"
static int const   magics[2]  = {      (int const   )3653246737U,      (int const   )3653245223U};
#line 34 "/home/wheatley/newnew/temp/quota-4.01/quotacheck_v2.c"
static int const   known_versions[2]  = {      (int const   )1,      (int const   )1};
#line 35 "/home/wheatley/newnew/temp/quota-4.01/quotacheck_v2.c"
static char *blkbmp  ;
#line 36 "/home/wheatley/newnew/temp/quota-4.01/quotacheck_v2.c"
static int detected_versions[2]  ;
#line 38 "/home/wheatley/newnew/temp/quota-4.01/quotacheck_v2.c"
static int check_blkref(uint blk , uint blocks ) 
{ 


  {
#line 40
  if (blk >= blocks) {
#line 41
    return (-1);
  }
#line 42
  if (blk) {
#line 42
    if (blk < 1U) {
#line 43
      return (-1);
    }
  }
#line 44
  return (0);
}
}
#line 48 "/home/wheatley/newnew/temp/quota-4.01/quotacheck_v2.c"
static int check_info___0(char *filename , int fd , int type ) 
{ 
  struct v2_disk_dqinfo dinfo ;
  uint blocks ;
  uint dflags ;
  uint freeblk ;
  uint freeent ;
  off_t filesize ;
  int err ;
  char *tmp ;
  ssize_t tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  char *tmp___10 ;

  {
  {
#line 55
  tmp = gettext("Checking quotafile info...\n");
#line 55
  debug(4, tmp);
#line 56
  lseek(fd, (__off64_t )sizeof(struct v2_disk_dqheader ), 0);
#line 57
  tmp___0 = read(fd, (void *)(& dinfo), sizeof(struct v2_disk_dqinfo ));
#line 57
  err = (int )tmp___0;
  }
#line 59
  if (err < 0) {
    {
#line 60
    tmp___1 = __errno_location();
#line 60
    tmp___2 = strerror(*tmp___1);
#line 60
    tmp___3 = gettext("Cannot read info from quota file %s: %s\n");
#line 60
    errstr(tmp___3, filename, tmp___2);
    }
#line 62
    return (-1);
  }
#line 64
  if ((unsigned long )err != sizeof(struct v2_disk_dqinfo )) {
    {
#line 65
    tmp___4 = gettext("WARNING - Quota file %s was probably truncated. Cannot save quota settings...\n");
#line 65
    errstr(tmp___4, filename);
    }
#line 67
    return (-1);
  }
  {
#line 70
  blocks = dinfo.dqi_blocks;
#line 71
  freeblk = dinfo.dqi_free_blk;
#line 72
  freeent = dinfo.dqi_free_entry;
#line 73
  dflags = dinfo.dqi_flags;
#line 74
  filesize = lseek(fd, (__off64_t )0, 2);
#line 75
  tmp___8 = check_blkref(freeblk, blocks);
  }
#line 75
  if (tmp___8 < 0) {
#line 75
    goto _L;
  } else
#line 75
  if (dflags & 4294967295U) {
#line 75
    goto _L;
  } else {
    {
#line 75
    tmp___9 = check_blkref(freeent, blocks);
    }
#line 75
    if (tmp___9 < 0) {
#line 75
      goto _L;
    } else
#line 75
    if (((filesize + (off_t )(1 << 10)) - 1L) >> 10 != (off_t )blocks) {
      _L: /* CIL Label */ 
      {
#line 77
      tmp___5 = gettext("WARNING - Quota file info was corrupted.\n");
#line 77
      errstr(tmp___5);
#line 78
      tmp___6 = gettext("Size of file: %lu\nBlocks: %u Free block: %u Block with free entry: %u Flags: %x\n");
#line 78
      debug(4, tmp___6, (unsigned long )filesize, blocks, freeblk, freeent, dflags);
#line 80
      old_info[type].dqi_bgrace = (time_t )604800;
#line 81
      old_info[type].dqi_igrace = (time_t )604800;
#line 82
      old_info[type].u.v2_mdqi.dqi_qtree.dqi_blocks = (unsigned int )(((filesize + (off_t )(1 << 10)) - 1L) >> 10);
#line 84
      old_info[type].u.v2_mdqi.dqi_flags = (uint )0;
#line 85
      tmp___7 = gettext("Setting grace times and other flags to default values.\nAssuming number of blocks is %u.\n");
#line 85
      printf((char const   */* __restrict  */)tmp___7, old_info[type].u.v2_mdqi.dqi_qtree.dqi_blocks);
      }
    } else {
#line 89
      old_info[type].dqi_bgrace = (time_t )dinfo.dqi_bgrace;
#line 90
      old_info[type].dqi_igrace = (time_t )dinfo.dqi_igrace;
#line 91
      old_info[type].u.v2_mdqi.dqi_qtree.dqi_blocks = blocks;
#line 92
      old_info[type].u.v2_mdqi.dqi_flags = dflags;
    }
  }
#line 94
  if (detected_versions[type] == 0) {
#line 95
    old_info[type].u.v2_mdqi.dqi_qtree.dqi_entry_size = (unsigned int )sizeof(struct v2r0_disk_dqblk );
  } else
#line 96
  if (detected_versions[type] == 1) {
#line 97
    old_info[type].u.v2_mdqi.dqi_qtree.dqi_entry_size = (unsigned int )sizeof(struct v2r1_disk_dqblk );
  }
  {
#line 99
  old_info[type].u.v2_mdqi.dqi_qtree.dqi_free_blk = 0U;
#line 100
  old_info[type].u.v2_mdqi.dqi_qtree.dqi_free_entry = 0U;
#line 102
  tmp___10 = gettext("File info done.\n");
#line 102
  debug(4, tmp___10);
  }
#line 103
  return (0);
}
}
#line 107 "/home/wheatley/newnew/temp/quota-4.01/quotacheck_v2.c"
static void blk_corrupted(int *corrupted , uint *lblk , uint blk , char *fmtstr  , ...) 
{ 
  va_list args ;
  char *tmp ;
  char *tmp___0 ;

  {
#line 111
  if (! *corrupted) {
#line 112
    if (! (flags & 6)) {
      {
#line 113
      tmp = gettext("Corrupted blocks: ");
#line 113
      errstr(tmp);
      }
    }
  }
#line 115
  if (flags & 6) {
    {
#line 116
    __builtin_va_start(args, fmtstr);
#line 117
    tmp___0 = gettext("Block %u: ");
#line 117
    errstr(tmp___0, blk);
#line 118
    vfprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)fmtstr,
             args);
#line 119
    fputc('\n', stderr);
#line 120
    __builtin_va_end(args);
    }
  } else
#line 122
  if (*lblk != blk) {
#line 123
    if (! *corrupted) {
      {
#line 124
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%u",
              blk);
      }
    } else {
      {
#line 126
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)", %u",
              blk);
      }
    }
  }
  {
#line 128
  *corrupted = 1;
#line 129
  *lblk = blk;
#line 130
  fflush(stderr);
  }
#line 131
  return;
}
}
#line 134 "/home/wheatley/newnew/temp/quota-4.01/quotacheck_v2.c"
static void v2r0_disk2utildqblk(struct util_dqblk *u , struct v2r0_disk_dqblk *d ) 
{ 


  {
#line 136
  u->dqb_ihardlimit = (qsize_t )d->dqb_ihardlimit;
#line 137
  u->dqb_isoftlimit = (qsize_t )d->dqb_isoftlimit;
#line 138
  u->dqb_bhardlimit = (qsize_t )d->dqb_bhardlimit;
#line 139
  u->dqb_bsoftlimit = (qsize_t )d->dqb_bsoftlimit;
#line 140
  u->dqb_itime = (time_t )((__le64 )d->dqb_itime);
#line 141
  u->dqb_btime = (time_t )((__le64 )d->dqb_btime);
#line 142
  return;
}
}
#line 145 "/home/wheatley/newnew/temp/quota-4.01/quotacheck_v2.c"
static void v2r1_disk2utildqblk(struct util_dqblk *u , struct v2r1_disk_dqblk *d ) 
{ 


  {
#line 147
  u->dqb_ihardlimit = (qsize_t )((__le64 )d->dqb_ihardlimit);
#line 148
  u->dqb_isoftlimit = (qsize_t )((__le64 )d->dqb_isoftlimit);
#line 149
  u->dqb_bhardlimit = (qsize_t )((__le64 )d->dqb_bhardlimit);
#line 150
  u->dqb_bsoftlimit = (qsize_t )((__le64 )d->dqb_bsoftlimit);
#line 151
  u->dqb_itime = (time_t )((__le64 )d->dqb_itime);
#line 152
  u->dqb_btime = (time_t )((__le64 )d->dqb_btime);
#line 153
  return;
}
}
#line 156 "/home/wheatley/newnew/temp/quota-4.01/quotacheck_v2.c"
static int buffer_entry(dqbuf_t buf , uint blk , int *corrupted , uint *lblk , int cnt ,
                        int type ) 
{ 
  struct util_dqblk *fdq ;
  struct util_dqblk mdq ;
  qid_t id___0 ;
  struct dquot *cd ;
  struct qtree_mem_dqinfo *info ;
  char *ddq ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;

  {
#line 161
  info = & old_info[type].u.v2_mdqi.dqi_qtree;
#line 162
  ddq = (buf + sizeof(struct qt_disk_dqdbheader )) + (unsigned int )cnt * info->dqi_entry_size;
#line 164
  if (detected_versions[type] == 0) {
    {
#line 165
    v2r0_disk2utildqblk(& mdq, (struct v2r0_disk_dqblk *)ddq);
#line 166
    id___0 = ((struct v2r0_disk_dqblk *)ddq)->dqb_id;
    }
  } else {
    {
#line 168
    v2r1_disk2utildqblk(& mdq, (struct v2r1_disk_dqblk *)ddq);
#line 169
    id___0 = ((struct v2r1_disk_dqblk *)ddq)->dqb_id;
    }
  }
  {
#line 172
  cd = lookup_dquot(id___0, type);
  }
#line 173
  if ((unsigned long )cd != (unsigned long )((struct dquot *)((void *)0))) {
#line 174
    fdq = & cd->dq_dqb;
#line 175
    if (mdq.dqb_bhardlimit != fdq->dqb_bhardlimit) {
#line 175
      goto _L___0;
    } else
#line 175
    if (mdq.dqb_bsoftlimit != fdq->dqb_bsoftlimit) {
#line 175
      goto _L___0;
    } else
#line 175
    if (mdq.dqb_ihardlimit != fdq->dqb_ihardlimit) {
#line 175
      goto _L___0;
    } else
#line 175
    if (mdq.dqb_isoftlimit != fdq->dqb_isoftlimit) {
      _L___0: /* CIL Label */ 
      {
#line 179
      tmp = gettext("Duplicated entries.");
#line 179
      blk_corrupted(corrupted, lblk, blk, tmp);
      }
#line 180
      if (flags & 16) {
#line 181
        if (! (flags & 6)) {
          {
#line 182
          fputc('\n', stderr);
          }
        }
        {
#line 183
        tmp___0 = gettext("Found more structures for ID %u. Using values: BHARD: %lld BSOFT: %lld IHARD: %lld ISOFT: %lld\n");
#line 183
        errstr(tmp___0, id___0, (long long )fdq->dqb_bhardlimit, (long long )fdq->dqb_bsoftlimit,
               (long long )fdq->dqb_ihardlimit, (long long )fdq->dqb_isoftlimit);
        }
#line 186
        return (0);
      } else
#line 188
      if (flags & 8) {
#line 189
        if (! (flags & 6)) {
          {
#line 190
          fputc('\n', stderr);
          }
        }
        {
#line 191
        tmp___1 = gettext("Found more structures for ID %u. Values: BHARD: %lld/%lld BSOFT: %lld/%lld IHARD: %lld/%lld ISOFT: %lld/%lld\n");
#line 191
        errstr(tmp___1, id___0, (long long )fdq->dqb_bhardlimit, (long long )mdq.dqb_bhardlimit,
               (long long )fdq->dqb_bsoftlimit, (long long )mdq.dqb_bsoftlimit, (long long )fdq->dqb_ihardlimit,
               (long long )mdq.dqb_ihardlimit, (long long )fdq->dqb_isoftlimit, (long long )mdq.dqb_isoftlimit);
#line 196
        tmp___2 = gettext("Should I use new values?");
#line 196
        tmp___3 = ask_yn(tmp___2, 0);
        }
#line 196
        if (tmp___3) {
#line 197
          fdq->dqb_bhardlimit = mdq.dqb_bhardlimit;
#line 198
          fdq->dqb_bsoftlimit = mdq.dqb_bsoftlimit;
#line 199
          fdq->dqb_ihardlimit = mdq.dqb_ihardlimit;
#line 200
          fdq->dqb_isoftlimit = mdq.dqb_isoftlimit;
#line 201
          fdq->dqb_btime = mdq.dqb_btime;
#line 202
          fdq->dqb_itime = mdq.dqb_itime;
        }
      } else {
        {
#line 206
        tmp___4 = gettext("ID %u has more structures. User intervention needed (use -i for interactive mode or -n for automatic answer).\n");
#line 206
        errstr(tmp___4, id___0);
        }
#line 208
        return (-1);
      }
    } else
#line 211
    if (mdq.dqb_itime != fdq->dqb_itime) {
#line 211
      goto _L;
    } else
#line 211
    if (mdq.dqb_btime != fdq->dqb_btime) {
      _L: /* CIL Label */ 
#line 212
      if (fdq->dqb_btime < mdq.dqb_btime) {
#line 213
        fdq->dqb_btime = mdq.dqb_btime;
      }
#line 214
      if (fdq->dqb_itime < mdq.dqb_itime) {
#line 215
        fdq->dqb_itime = mdq.dqb_itime;
      }
    }
  } else {
    {
#line 219
    cd = add_dquot(id___0, type);
#line 220
    fdq = & cd->dq_dqb;
#line 221
    fdq->dqb_bhardlimit = mdq.dqb_bhardlimit;
#line 222
    fdq->dqb_bsoftlimit = mdq.dqb_bsoftlimit;
#line 223
    fdq->dqb_ihardlimit = mdq.dqb_ihardlimit;
#line 224
    fdq->dqb_isoftlimit = mdq.dqb_isoftlimit;
    }
#line 226
    if (mdq.dqb_bsoftlimit) {
#line 227
      fdq->dqb_btime = mdq.dqb_btime;
    }
#line 228
    if (mdq.dqb_isoftlimit) {
#line 229
      fdq->dqb_itime = mdq.dqb_itime;
    }
  }
#line 231
  return (0);
}
}
#line 234 "/home/wheatley/newnew/temp/quota-4.01/quotacheck_v2.c"
static void check_read_blk(int fd , uint blk , dqbuf_t buf ) 
{ 
  size_t rd ;
  ssize_t tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;

  {
  {
#line 238
  lseek(fd, (__off64_t )(blk << 10), 0);
#line 239
  tmp = read(fd, (void *)buf, (size_t )(1 << 10));
#line 239
  rd = (size_t )tmp;
  }
#line 240
  if (rd < 0UL) {
    {
#line 241
    tmp___0 = __errno_location();
#line 241
    tmp___1 = strerror(*tmp___0);
#line 241
    tmp___2 = gettext("Cannot read block %u: %s\n");
#line 241
    die(2, tmp___2, blk, tmp___1);
    }
  }
#line 242
  if (rd != (size_t )(1 << 10)) {
    {
#line 243
    tmp___3 = gettext("Block %u is truncated.\n");
#line 243
    debug(6, tmp___3, blk);
#line 244
    memset((void *)(buf + rd), 0, (size_t )(1 << 10) - rd);
    }
  }
#line 246
  return;
}
}
#line 248 "/home/wheatley/newnew/temp/quota-4.01/quotacheck_v2.c"
static int check_tree_ref(uint blk , uint ref , uint blocks , int check_use , int *corrupted ,
                          uint *lblk ) 
{ 
  char *tmp ;
  int tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 251
  tmp___0 = check_blkref(ref, blocks);
  }
#line 251
  if (tmp___0 < 0) {
    {
#line 252
    tmp = gettext("Reference to illegal block %u");
#line 252
    blk_corrupted(corrupted, lblk, blk, tmp, ref);
    }
#line 253
    return (-1);
  }
#line 255
  if (! ref) {
#line 256
    return (0);
  }
#line 257
  if (! check_use) {
#line 258
    return (0);
  } else
#line 257
  if (! ((int )*(blkbmp + (ref >> 3)) & (1 << (ref & 7U)))) {
#line 258
    return (0);
  }
  {
#line 259
  tmp___1 = gettext("Block %u in tree referenced twice");
#line 259
  blk_corrupted(corrupted, lblk, blk, tmp___1, ref);
  }
#line 260
  return (-1);
}
}
#line 264 "/home/wheatley/newnew/temp/quota-4.01/quotacheck_v2.c"
static int check_data_blk(int fd , uint blk , int type , uint blocks , int *corrupted ,
                          uint *lblk ) 
{ 
  dqbuf_t buf ;
  void *tmp ;
  struct qt_disk_dqdbheader *head ;
  int i ;
  char *dd ;
  struct qtree_mem_dqinfo *info ;
  char *tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
  {
#line 266
  tmp = smalloc((size_t )(1 << 10));
#line 266
  buf = (dqbuf_t )tmp;
#line 267
  head = (struct qt_disk_dqdbheader *)buf;
#line 269
  dd = (char *)(head + 1);
#line 270
  info = & old_info[type].u.v2_mdqi.dqi_qtree;
#line 272
  *(blkbmp + (blk >> 3)) = (char )((int )*(blkbmp + (blk >> 3)) | (1 << (blk & 7U)));
#line 273
  check_read_blk(fd, blk, buf);
#line 274
  tmp___1 = check_blkref(head->dqdh_next_free, blocks);
  }
#line 274
  if (tmp___1 < 0) {
    {
#line 275
    tmp___0 = gettext("Illegal free block reference to block %u");
#line 275
    blk_corrupted(corrupted, lblk, blk, tmp___0, head->dqdh_next_free);
    }
  }
  {
#line 277
  tmp___3 = qtree_dqstr_in_blk(info);
  }
#line 277
  if ((int )head->dqdh_entries > tmp___3) {
    {
#line 278
    tmp___2 = gettext("Corrupted number of used entries (%u)");
#line 278
    blk_corrupted(corrupted, lblk, blk, tmp___2, (uint )head->dqdh_entries);
    }
  }
#line 280
  i = 0;
  {
#line 280
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 280
    tmp___6 = qtree_dqstr_in_blk(info);
    }
#line 280
    if (! (i < tmp___6)) {
#line 280
      goto while_break;
    }
    {
#line 281
    tmp___5 = qtree_entry_unused(info, dd + (unsigned int )i * info->dqi_entry_size);
    }
#line 281
    if (! tmp___5) {
      {
#line 282
      tmp___4 = buffer_entry(buf, blk, corrupted, lblk, i, type);
      }
#line 282
      if (tmp___4 < 0) {
        {
#line 283
        free((void *)buf);
        }
#line 284
        return (-1);
      }
    }
#line 280
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 286
  free((void *)buf);
  }
#line 287
  return (0);
}
}
#line 291 "/home/wheatley/newnew/temp/quota-4.01/quotacheck_v2.c"
static int check_tree_blk(int fd , uint blk , int depth , int type , uint blocks ,
                          int *corrupted , uint *lblk ) 
{ 
  dqbuf_t buf ;
  void *tmp ;
  u_int32_t *r ;
  int i ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 294
  tmp = smalloc((size_t )(1 << 10));
#line 294
  buf = (dqbuf_t )tmp;
#line 295
  r = (u_int32_t *)buf;
#line 298
  *(blkbmp + (blk >> 3)) = (char )((int )*(blkbmp + (blk >> 3)) | (1 << (blk & 7U)));
#line 299
  check_read_blk(fd, blk, buf);
#line 300
  i = 0;
  }
  {
#line 300
  while (1) {
    while_continue: /* CIL Label */ ;
#line 300
    if (! (i < (1 << 10) >> 2)) {
#line 300
      goto while_break;
    }
#line 301
    if (depth < 3) {
      {
#line 302
      tmp___1 = check_tree_ref(blk, *(r + i), blocks, 1, corrupted, lblk);
      }
#line 302
      if (tmp___1 >= 0) {
#line 302
        if (*(r + i)) {
          {
#line 304
          tmp___0 = check_tree_blk(fd, *(r + i), depth + 1, type, blocks, corrupted,
                                   lblk);
          }
#line 304
          if (tmp___0 < 0) {
            {
#line 305
            free((void *)buf);
            }
#line 306
            return (-1);
          }
        }
      }
    } else {
      {
#line 309
      tmp___3 = check_tree_ref(blk, *(r + i), blocks, 0, corrupted, lblk);
      }
#line 309
      if (tmp___3 >= 0) {
#line 309
        if (*(r + i)) {
#line 310
          if (! ((int )*(blkbmp + (*(r + i) >> 3)) & (1 << (*(r + i) & 7U)))) {
            {
#line 310
            tmp___2 = check_data_blk(fd, *(r + i), type, blocks, corrupted, lblk);
            }
#line 310
            if (tmp___2 < 0) {
              {
#line 311
              free((void *)buf);
              }
#line 312
              return (-1);
            }
          }
        }
      }
    }
#line 300
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 314
  free((void *)buf);
  }
#line 315
  return (0);
}
}
#line 318 "/home/wheatley/newnew/temp/quota-4.01/quotacheck_v2.c"
int v2_detect_version(char *filename , int fd , int type ) 
{ 
  struct v2_disk_dqheader head ;
  int err ;
  int ver ;
  ssize_t tmp ;
  char *tmp___0 ;

  {
  {
#line 324
  lseek(fd, (__off64_t )0, 0);
#line 325
  tmp = read(fd, (void *)(& head), sizeof(head));
#line 325
  err = (int )tmp;
  }
#line 326
  if (err < 0) {
#line 327
    return (-1);
  } else
#line 326
  if ((unsigned long )err != sizeof(head)) {
#line 327
    return (-1);
  }
#line 328
  if (head.dqh_magic != (__u32 )magics[type]) {
    {
#line 330
    tmp___0 = gettext("Quota file %s has corrupted headers. You have to specify quota format on command line.\n");
#line 330
    errstr(tmp___0, filename);
    }
#line 332
    return (-1);
  } else
#line 328
  if (head.dqh_version > (__u32 )known_versions[type]) {
    {
#line 330
    tmp___0 = gettext("Quota file %s has corrupted headers. You have to specify quota format on command line.\n");
#line 330
    errstr(tmp___0, filename);
    }
#line 332
    return (-1);
  }
#line 334
  ver = (int )head.dqh_version;
#line 335
  if (ver == 0) {
#line 336
    return (1);
  }
#line 337
  return (2);
}
}
#line 341 "/home/wheatley/newnew/temp/quota-4.01/quotacheck_v2.c"
static int check_header(char *filename , int fd , int type , int version___0 ) 
{ 
  int err ;
  struct v2_disk_dqheader head ;
  char *tmp ;
  ssize_t tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;
  char *tmp___9 ;

  {
  {
#line 346
  tmp = gettext("Checking quotafile headers...\n");
#line 346
  debug(4, tmp);
#line 347
  lseek(fd, (__off64_t )0, 0);
#line 348
  tmp___0 = read(fd, (void *)(& head), sizeof(head));
#line 348
  err = (int )tmp___0;
  }
#line 349
  if (err < 0) {
    {
#line 350
    tmp___1 = __errno_location();
#line 350
    tmp___2 = strerror(*tmp___1);
#line 350
    tmp___3 = gettext("Cannot read header from quotafile %s: %s\n");
#line 350
    die(1, tmp___3, filename, tmp___2);
    }
  }
#line 351
  if ((unsigned long )err != sizeof(head)) {
    {
#line 352
    tmp___4 = gettext("WARNING -  Quotafile %s was probably truncated. Cannot save quota settings...\n");
#line 352
    errstr(tmp___4, filename);
    }
#line 354
    return (-1);
  }
#line 356
  if (head.dqh_magic != (__u32 )magics[type]) {
    {
#line 358
    tmp___5 = gettext("WARNING - Quota file %s has corrupted headers\n");
#line 358
    errstr(tmp___5, filename);
    }
  } else
#line 356
  if (head.dqh_version > (__u32 )known_versions[type]) {
    {
#line 358
    tmp___5 = gettext("WARNING - Quota file %s has corrupted headers\n");
#line 358
    errstr(tmp___5, filename);
    }
  }
#line 361
  if (head.dqh_version != (__u32 )version___0) {
    {
#line 362
    tmp___6 = gettext("Quota file format version %d does not match the one specified on command line (%d). Quota file header may be corrupted.\n");
#line 362
    errstr(tmp___6, head.dqh_version, version___0);
#line 366
    tmp___7 = gettext("Continue checking assuming version from command line?");
#line 366
    tmp___8 = ask_yn(tmp___7, 1);
    }
#line 366
    if (! tmp___8) {
#line 367
      return (-1);
    }
#line 368
    detected_versions[type] = version___0;
  } else {
#line 370
    detected_versions[type] = (int )head.dqh_version;
  }
  {
#line 372
  tmp___9 = gettext("Headers checked.\n");
#line 372
  debug(4, tmp___9);
  }
#line 373
  return (0);
}
}
#line 377 "/home/wheatley/newnew/temp/quota-4.01/quotacheck_v2.c"
int v2_buffer_file(char *filename , int fd , int type , int fmt___7 ) 
{ 
  uint blocks ;
  uint lastblk ;
  int corrupted ;
  int ret ;
  int version___0 ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  void *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;

  {
#line 379
  lastblk = (uint )0;
#line 380
  corrupted = 0;
#line 380
  ret = 0;
#line 383
  if (fmt___7 == 1) {
#line 384
    version___0 = 0;
  } else
#line 385
  if (fmt___7 == 2) {
#line 386
    version___0 = 1;
  } else {
    {
#line 388
    tmp = gettext("Do not know how to buffer format %d\n");
#line 388
    die(3, tmp, fmt___7);
    }
  }
#line 390
  old_info[type].dqi_bgrace = (time_t )604800;
#line 391
  old_info[type].dqi_igrace = (time_t )604800;
#line 392
  if (flags & 32) {
#line 393
    return (0);
  }
  {
#line 394
  tmp___0 = check_header(filename, fd, type, version___0);
  }
#line 394
  if (tmp___0 < 0) {
#line 395
    return (-1);
  }
  {
#line 396
  tmp___1 = check_info___0(filename, fd, type);
  }
#line 396
  if (tmp___1 < 0) {
#line 397
    return (-1);
  }
  {
#line 398
  tmp___2 = gettext("Headers of file %s checked. Going to load data...\n");
#line 398
  debug(4, tmp___2, filename);
#line 400
  blocks = old_info[type].u.v2_mdqi.dqi_qtree.dqi_blocks;
#line 401
  tmp___3 = xmalloc((size_t )((blocks + 7U) >> 3));
#line 401
  blkbmp = (char *)tmp___3;
#line 402
  memset((void *)blkbmp, 0, (size_t )((blocks + 7U) >> 3));
#line 403
  tmp___5 = check_tree_ref((uint )0, (uint )1, blocks, 1, & corrupted, & lastblk);
  }
#line 403
  if (tmp___5 >= 0) {
    {
#line 404
    ret = check_tree_blk(fd, (uint )1, 0, type, blocks, & corrupted, & lastblk);
    }
  } else {
    {
#line 406
    tmp___4 = gettext("Cannot gather quota data. Tree root node corrupted.\n");
#line 406
    errstr(tmp___4);
    }
  }
  {
#line 410
  free((void *)blkbmp);
  }
#line 411
  if (corrupted) {
#line 412
    if (! (flags & 6)) {
      {
#line 413
      fputc('\n', stderr);
      }
    }
    {
#line 414
    tmp___6 = gettext("WARNING - Some data might be changed due to corruption.\n");
#line 414
    errstr(tmp___6);
    }
  } else {
    {
#line 417
    tmp___7 = gettext("Not found any corrupted blocks. Congratulations.\n");
#line 417
    debug(4, tmp___7);
    }
  }
#line 418
  return (ret);
}
}
#line 422 "/home/wheatley/newnew/temp/quota-4.01/quotacheck_v2.c"
void v2_merge_info(struct util_dqinfo *new , struct util_dqinfo *old ) 
{ 


  {
#line 424
  new->u.v2_mdqi.dqi_flags = old->u.v2_mdqi.dqi_flags;
#line 425
  return;
}
}
#line 41 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static char extensions___6[4][20]  = { {        (char )'u',        (char )'s',        (char )'e',        (char )'r', 
            (char )'\000'}, 
   {        (char )'g',        (char )'r',        (char )'o',        (char )'u', 
            (char )'p',        (char )'\000'}, 
   {        (char )'u',        (char )'n',        (char )'d',        (char )'e', 
            (char )'f',        (char )'i',        (char )'n',        (char )'e', 
            (char )'d',        (char )'\000'}};
#line 42 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static char *basenames___6[6]  = {      (char *)"quota",      (char *)"aquota",      (char *)"aquota",      (char *)"", 
        (char *)"",      (char *)""};
#line 43 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static char *fmtnames___6[5]  = {      (char *)"vfsold",      (char *)"vfsv0",      (char *)"vfsv1",      (char *)"rpc", 
        (char *)"xfs"};
#line 245 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static int kern2utilfmt___6(int kernfmt ) 
{ 


  {
  {
#line 248
  if (kernfmt == 1) {
#line 248
    goto case_1;
  }
#line 250
  if (kernfmt == 2) {
#line 250
    goto case_2;
  }
#line 252
  if (kernfmt == 4) {
#line 252
    goto case_4;
  }
#line 254
  if (kernfmt == 3) {
#line 254
    goto case_3;
  }
#line 247
  goto switch_break;
  case_1: /* CIL Label */ 
#line 249
  return (0);
  case_2: /* CIL Label */ 
#line 251
  return (1);
  case_4: /* CIL Label */ 
#line 253
  return (2);
  case_3: /* CIL Label */ 
#line 255
  return (5);
  switch_break: /* CIL Label */ ;
  }
#line 257
  return (-1);
}
}
#line 394 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static int hasxfsquota___6(char const   *dev , struct mntent *mnt___2 , int type ,
                           int flags___7 ) 
{ 
  u_int16_t sbflags ;
  struct fs_quota_stat info ;
  long tmp ;

  {
#line 399
  if (flags___7 & 16) {
#line 400
    return (4);
  }
  {
#line 402
  memset((void *)(& info), 0, sizeof(struct fs_quota_stat ));
#line 403
  tmp = quotactl((((88 << 8) + 5) << 8) | (type & 255), dev, (qid_t )0, (caddr_t )((void *)(& info)));
  }
#line 403
  if (! tmp) {
#line 404
    sbflags = (u_int16_t )(((int )info.qs_flags & 65280) >> 8);
#line 405
    if (type == 0) {
#line 405
      if ((int )info.qs_flags & 1) {
#line 406
        return (4);
      } else {
#line 405
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 407
    if (type == 1) {
#line 407
      if ((int )info.qs_flags & (1 << 2)) {
#line 408
        return (4);
      }
    }
  }
#line 424
  return (-1);
}
}
#line 427 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static int hasvfsmetaquota___6(char const   *dev , struct mntent *mnt___2 , int type ,
                               int flags___7 ) 
{ 
  uint32_t fmt___7 ;
  long tmp ;

  {
  {
#line 431
  tmp = quotactl((8388612 << 8) | (type & 255), dev, (qid_t )0, (caddr_t )((void *)(& fmt___7)));
  }
#line 431
  if (! tmp) {
#line 432
    return (5);
  }
#line 433
  return (-1);
}
}
#line 465 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static char *hasmntoptarg___6(char const   *optstring , char const   *opt ) 
{ 
  char *p ;
  char *tmp ;
  size_t tmp___0 ;

  {
  {
#line 467
  tmp = str_hasmntopt(optstring, opt);
#line 467
  p = tmp;
  }
#line 469
  if (! p) {
#line 470
    return ((char *)((void *)0));
  }
  {
#line 471
  tmp___0 = strlen(opt);
#line 471
  p += tmp___0;
  }
#line 472
  if ((int )*p == 61) {
#line 472
    if ((int )*(p + 1) != 44) {
#line 473
      return (p + 1);
    }
  }
#line 474
  return ((char *)((void *)0));
}
}
#line 478 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static void copy_mntoptarg___6(char *buf , char const   *optarg___0 , int buflen ) 
{ 
  char *sep ;
  char *tmp ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  long tmp___4 ;

  {
  {
#line 480
  tmp = strchr(optarg___0, ',');
#line 480
  sep = tmp;
  }
#line 482
  if (! sep) {
    {
#line 483
    tmp___3 = strlen(optarg___0);
    }
#line 483
    if ((size_t )buflen < tmp___3 + 1UL) {
#line 483
      tmp___2 = (size_t )buflen;
    } else {
      {
#line 483
      tmp___1 = strlen(optarg___0);
#line 483
      tmp___2 = tmp___1 + 1UL;
      }
    }
    {
#line 483
    sstrncpy(buf, optarg___0, tmp___2);
    }
  } else {
#line 485
    if ((long )buflen < (sep - (char *)optarg___0) + 1L) {
#line 485
      tmp___4 = (long )buflen;
    } else {
#line 485
      tmp___4 = (sep - (char *)optarg___0) + 1L;
    }
    {
#line 485
    sstrncpy(buf, optarg___0, (size_t )tmp___4);
    }
  }
#line 486
  return;
}
}
#line 491 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static int hasquota___6(char const   *dev , struct mntent *mnt___2 , int type , int flags___7 ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  struct if_dqinfo kinfo ;
  long tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;

  {
  {
#line 493
  tmp___0 = strcmp((char const   *)mnt___2->mnt_type, "gfs2");
  }
#line 493
  if (tmp___0) {
    {
#line 493
    tmp___1 = strcmp((char const   *)mnt___2->mnt_type, "xfs");
    }
#line 493
    if (! tmp___1) {
      {
#line 495
      tmp = hasxfsquota___6(dev, mnt___2, type, flags___7);
      }
#line 495
      return (tmp);
    }
  } else {
    {
#line 495
    tmp = hasxfsquota___6(dev, mnt___2, type, flags___7);
    }
#line 495
    return (tmp);
  }
  {
#line 496
  tmp___3 = strcmp((char const   *)mnt___2->mnt_type, "ocfs2");
  }
#line 496
  if (! tmp___3) {
    {
#line 497
    tmp___2 = hasvfsmetaquota___6(dev, mnt___2, type, flags___7);
    }
#line 497
    return (tmp___2);
  }
  {
#line 504
  tmp___5 = strcmp((char const   *)mnt___2->mnt_type, "ext4");
  }
#line 504
  if (! tmp___5) {
    {
#line 507
    tmp___4 = quotactl((8388613 << 8) | (type & 255), dev, (qid_t )0, (caddr_t )((void *)(& kinfo)));
    }
#line 507
    if (tmp___4 == 0L) {
#line 508
      if (kinfo.dqi_flags & 65536U) {
#line 509
        return (5);
      }
    }
  }
  {
#line 513
  tmp___6 = nfs_fstype(mnt___2->mnt_type);
  }
#line 513
  if (tmp___6) {
#line 514
    return (3);
  }
#line 516
  if (type == 0) {
    {
#line 516
    tmp___7 = hasmntopt((struct mntent  const  *)mnt___2, "usrquota");
    }
#line 516
    if (tmp___7) {
#line 517
      return (6);
    } else {
      {
#line 516
      tmp___8 = hasmntoptarg___6((char const   *)mnt___2->mnt_opts, "usrjquota");
      }
#line 516
      if (tmp___8) {
#line 517
        return (6);
      }
    }
  }
#line 518
  if (type == 1) {
    {
#line 518
    tmp___9 = hasmntopt((struct mntent  const  *)mnt___2, "grpquota");
    }
#line 518
    if (tmp___9) {
#line 519
      return (6);
    } else {
      {
#line 518
      tmp___10 = hasmntoptarg___6((char const   *)mnt___2->mnt_opts, "grpjquota");
      }
#line 518
      if (tmp___10) {
#line 519
        return (6);
      }
    }
  }
#line 520
  if (type == 0) {
    {
#line 520
    tmp___11 = hasmntopt((struct mntent  const  *)mnt___2, "quota");
    }
#line 520
    if (tmp___11) {
#line 521
      return (6);
    }
  }
#line 522
  return (-1);
}
}
#line 526 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static int check_fmtfile_ok___6(char *name , int type , int fmt___7 , int flags___7 ) 
{ 
  struct stat st ;
  int *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;
  int fd ;
  int ret ;
  int tmp___4 ;
  int *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  int *tmp___8 ;
  int *tmp___9 ;

  {
#line 528
  if (! flags___7) {
#line 529
    return (1);
  }
#line 530
  if (flags___7 & 1) {
    {
#line 533
    tmp___3 = stat((char const   */* __restrict  */)name, (struct stat */* __restrict  */)(& st));
    }
#line 533
    if (tmp___3 < 0) {
      {
#line 534
      tmp___2 = __errno_location();
      }
#line 534
      if (*tmp___2 != 2) {
        {
#line 535
        tmp = __errno_location();
#line 535
        tmp___0 = strerror(*tmp);
#line 535
        tmp___1 = gettext("Cannot stat quota file %s: %s\n");
#line 535
        errstr(tmp___1, name, tmp___0);
        }
      }
#line 536
      return (0);
    }
  }
#line 539
  if (flags___7 & 2) {
    {
#line 540
    ret = 0;
#line 542
    fd = open((char const   *)name, 0);
    }
#line 542
    if (fd >= 0) {
      {
#line 543
      tmp___4 = is_tree_qfmt(fmt___7);
      }
#line 543
      if (tmp___4) {
        {
#line 544
        ret = (*(quotafile_ops_2.check_file))(fd, type, fmt___7);
        }
      } else {
        {
#line 546
        ret = (*(quotafile_ops_1.check_file))(fd, type, fmt___7);
        }
      }
      {
#line 547
      close(fd);
      }
#line 548
      if (ret <= 0) {
#line 549
        return (0);
      }
    } else {
      {
#line 551
      tmp___8 = __errno_location();
      }
#line 551
      if (*tmp___8 != 2) {
        {
#line 551
        tmp___9 = __errno_location();
        }
#line 551
        if (*tmp___9 != 1) {
          {
#line 552
          tmp___5 = __errno_location();
#line 552
          tmp___6 = strerror(*tmp___5);
#line 552
          tmp___7 = gettext("Cannot open quotafile %s: %s\n");
#line 552
          errstr(tmp___7, name, tmp___6);
          }
#line 553
          return (0);
        }
      }
    }
  }
#line 556
  return (1);
}
}
#line 629 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static int hlist_allocated___6  =    0;
#line 630 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static struct quota_handle **hlist___6  =    (struct quota_handle **)((void *)0);
#line 735 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static int kernel_qfmt_num___6  ;
#line 736 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static int kernel_qfmt___6[6]  ;
#line 828 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static int v1_kern_quota_on___6(char const   *dev , int type ) 
{ 
  char tmp[1024] ;
  qid_t id___0 ;
  __uid_t tmp___0 ;
  __gid_t tmp___1 ;
  __uid_t tmp___2 ;
  long tmp___3 ;

  {
#line 831
  if (type == 0) {
    {
#line 831
    tmp___0 = getuid();
#line 831
    tmp___2 = tmp___0;
    }
  } else {
    {
#line 831
    tmp___1 = getgid();
#line 831
    tmp___2 = tmp___1;
    }
  }
  {
#line 831
  id___0 = tmp___2;
#line 833
  tmp___3 = quotactl((768 << 8) | (type & 255), dev, id___0, tmp);
  }
#line 833
  if (! tmp___3) {
#line 834
    return (1);
  }
#line 835
  return (0);
}
}
#line 839 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static int v2_kern_quota_on___6(char const   *dev , int type ) 
{ 
  char tmp[1024] ;
  qid_t id___0 ;
  __uid_t tmp___0 ;
  __gid_t tmp___1 ;
  __uid_t tmp___2 ;
  long tmp___3 ;

  {
#line 842
  if (type == 0) {
    {
#line 842
    tmp___0 = getuid();
#line 842
    tmp___2 = tmp___0;
    }
  } else {
    {
#line 842
    tmp___1 = getgid();
#line 842
    tmp___2 = tmp___1;
    }
  }
  {
#line 842
  id___0 = tmp___2;
#line 844
  tmp___3 = quotactl((3328 << 8) | (type & 255), dev, id___0, tmp);
  }
#line 844
  if (! tmp___3) {
#line 845
    return (1);
  }
#line 846
  return (0);
}
}
#line 850 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static int xfs_kern_quota_on___6(char const   *dev , int type ) 
{ 
  struct fs_quota_stat info ;
  long tmp ;

  {
  {
#line 854
  tmp = quotactl((((88 << 8) + 5) << 8) | (type & 255), dev, (qid_t )0, (caddr_t )((void *)(& info)));
  }
#line 854
  if (! tmp) {
#line 855
    if (type == 0) {
#line 855
      if ((int )info.qs_flags & 1) {
#line 856
        return (1);
      }
    }
#line 857
    if (type == 1) {
#line 857
      if ((int )info.qs_flags & (1 << 2)) {
#line 858
        return (1);
      }
    }
  }
#line 860
  return (0);
}
}
#line 921 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static int mnt_entries_cnt___6  ;
#line 922 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static struct mount_entry *mnt_entries___6  ;
#line 923 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static int check_dirs_cnt___6  ;
#line 923 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static int act_checked___6  ;
#line 924 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static struct searched_dir *check_dirs___6  ;
#line 927 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static int cache_mnt_table___6(int flags___7 ) 
{ 
  FILE *mntf ;
  struct mntent *mnt___2 ;
  struct stat st ;
  struct statfs fsstat ;
  int allocated ;
  int i ;
  dev_t dev ;
  char mntpointbuf[4096] ;
  int autofsdircnt ;
  int autofsdir_allocated ;
  char **autofsdir ;
  char *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  char const   *devname ;
  char *opt ;
  int qfmt[2] ;
  char *tmp___2 ;
  int slen ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  void *tmp___6 ;
  size_t tmp___7 ;
  void *tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char loopdev[4096] ;
  char *tmp___13 ;
  int *tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;
  int *tmp___18 ;
  char *tmp___19 ;
  char *tmp___20 ;
  int tmp___21 ;
  int *tmp___22 ;
  char *tmp___23 ;
  char *tmp___24 ;
  int tmp___25 ;
  char *tmp___26 ;
  int tmp___27 ;
  int *tmp___28 ;
  char *tmp___29 ;
  char *tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;
  void *tmp___34 ;
  char *tmp___35 ;

  {
  {
#line 933
  allocated = 0;
#line 933
  i = 0;
#line 934
  dev = (dev_t )0;
#line 940
  mntf = setmntent("/proc/mounts", "r");
  }
#line 941
  if (mntf) {
#line 942
    goto alloc;
  }
  {
#line 944
  mntf = setmntent("/etc/mtab", "r");
  }
#line 945
  if (mntf) {
#line 946
    goto alloc;
  }
  {
#line 948
  mntf = setmntent("/etc/fstab", "r");
  }
#line 948
  if (! mntf) {
    {
#line 949
    tmp = gettext("Cannot open any file with mount points.\n");
#line 949
    errstr(tmp);
    }
#line 950
    return (-1);
  }
  alloc: 
  {
#line 954
  tmp___0 = smalloc(sizeof(struct mount_entry ) * 16UL);
#line 954
  mnt_entries___6 = (struct mount_entry *)tmp___0;
#line 955
  mnt_entries_cnt___6 = 0;
#line 956
  allocated += 16;
#line 958
  tmp___1 = smalloc(sizeof(char *) * 16UL);
#line 958
  autofsdir = (char **)tmp___1;
#line 959
  autofsdircnt = 0;
#line 960
  autofsdir_allocated = 16;
  }
  {
#line 961
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 961
    mnt___2 = getmntent(mntf);
    }
#line 961
    if (! mnt___2) {
#line 961
      goto while_break;
    }
    {
#line 966
    devname = get_device_name((char const   *)mnt___2->mnt_fsname);
    }
#line 966
    if (! devname) {
      {
#line 967
      tmp___2 = gettext("Cannot get device name for %s\n");
#line 967
      errstr(tmp___2, mnt___2->mnt_fsname);
      }
#line 968
      goto while_continue;
    }
#line 972
    i = 0;
    {
#line 972
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 972
      if (! (i < autofsdircnt)) {
#line 972
        goto while_break___0;
      }
      {
#line 973
      tmp___3 = strlen((char const   *)*(autofsdir + i));
#line 973
      slen = (int )tmp___3;
#line 975
      tmp___4 = strlen((char const   *)mnt___2->mnt_dir);
      }
#line 975
      if ((size_t )slen <= tmp___4) {
        {
#line 975
        tmp___5 = strncmp((char const   *)*(autofsdir + i), (char const   *)mnt___2->mnt_dir,
                          (size_t )slen);
        }
#line 975
        if (! tmp___5) {
#line 976
          goto while_break___0;
        }
      }
#line 972
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 978
    if (i < autofsdircnt) {
      {
#line 979
      free((void *)((char *)devname));
      }
#line 980
      goto while_continue;
    }
#line 983
    if (flags___7 & 2) {
      {
#line 983
      tmp___9 = strcmp((char const   *)mnt___2->mnt_type, "autofs");
      }
#line 983
      if (! tmp___9) {
#line 984
        if (autofsdircnt == autofsdir_allocated) {
          {
#line 985
          autofsdir_allocated += 16;
#line 986
          tmp___6 = srealloc((void *)autofsdir, (unsigned long )autofsdir_allocated * sizeof(char *));
#line 986
          autofsdir = (char **)tmp___6;
          }
        }
        {
#line 988
        tmp___7 = strlen((char const   *)mnt___2->mnt_dir);
#line 988
        tmp___8 = smalloc(tmp___7 + 2UL);
#line 988
        *(autofsdir + autofsdircnt) = (char *)tmp___8;
#line 989
        strcpy((char */* __restrict  */)*(autofsdir + autofsdircnt), (char const   */* __restrict  */)mnt___2->mnt_dir);
#line 990
        strcat((char */* __restrict  */)*(autofsdir + autofsdircnt), (char const   */* __restrict  */)"/");
#line 991
        autofsdircnt ++;
#line 992
        free((void *)((char *)devname));
        }
#line 993
        goto while_continue;
      }
    }
#line 996
    if (flags___7 & 8) {
      {
#line 996
      tmp___10 = nfs_fstype(mnt___2->mnt_type);
      }
#line 996
      if (tmp___10) {
        {
#line 997
        free((void *)((char *)devname));
        }
#line 998
        goto while_continue;
      }
    }
    {
#line 1000
    tmp___11 = hasmntopt((struct mntent  const  *)mnt___2, "noquota");
    }
#line 1000
    if (tmp___11) {
      {
#line 1001
      free((void *)((char *)devname));
      }
#line 1002
      goto while_continue;
    }
    {
#line 1004
    tmp___12 = hasmntopt((struct mntent  const  *)mnt___2, "bind");
    }
#line 1004
    if (tmp___12) {
      {
#line 1005
      free((void *)((char *)devname));
      }
#line 1006
      goto while_continue;
    }
    {
#line 1008
    opt = hasmntoptarg___6((char const   *)mnt___2->mnt_opts, "loop");
    }
#line 1008
    if (opt) {
      {
#line 1011
      copy_mntoptarg___6(opt, (char const   *)(loopdev), 4096);
#line 1012
      free((void *)((char *)devname));
#line 1013
      tmp___13 = sstrdup((char const   *)(loopdev));
#line 1013
      devname = (char const   *)tmp___13;
      }
    }
    {
#line 1018
    qfmt[0] = hasquota___6(devname, mnt___2, 0, flags___7);
#line 1019
    qfmt[1] = hasquota___6(devname, mnt___2, 1, flags___7);
    }
#line 1020
    if (qfmt[0] < 0) {
#line 1020
      if (qfmt[1] < 0) {
        {
#line 1021
        free((void *)((char *)devname));
        }
#line 1022
        goto while_continue;
      }
    }
    {
#line 1025
    tmp___17 = realpath((char const   */* __restrict  */)mnt___2->mnt_dir, (char */* __restrict  */)(mntpointbuf));
    }
#line 1025
    if (! tmp___17) {
      {
#line 1026
      tmp___14 = __errno_location();
#line 1026
      tmp___15 = strerror(*tmp___14);
#line 1026
      tmp___16 = gettext("Cannot resolve mountpoint path %s: %s\n");
#line 1026
      errstr(tmp___16, mnt___2->mnt_dir, tmp___15);
#line 1027
      free((void *)((char *)devname));
      }
#line 1028
      goto while_continue;
    }
    {
#line 1031
    tmp___21 = statfs((char const   *)(mntpointbuf), & fsstat);
    }
#line 1031
    if (tmp___21 != 0) {
      {
#line 1032
      tmp___18 = __errno_location();
#line 1032
      tmp___19 = strerror(*tmp___18);
#line 1032
      tmp___20 = gettext("Cannot statfs() %s: %s\n");
#line 1032
      errstr(tmp___20, mntpointbuf, tmp___19);
#line 1033
      free((void *)((char *)devname));
      }
#line 1034
      goto while_continue;
    }
#line 1037
    if (fsstat.f_blocks == 0UL) {
#line 1037
      if (fsstat.f_bfree == 0UL) {
#line 1037
        if (fsstat.f_bavail == 0UL) {
          {
#line 1038
          free((void *)((char *)devname));
          }
#line 1039
          goto while_continue;
        }
      }
    }
    {
#line 1042
    tmp___27 = nfs_fstype(mnt___2->mnt_type);
    }
#line 1042
    if (! tmp___27) {
      {
#line 1043
      tmp___25 = stat((char const   */* __restrict  */)devname, (struct stat */* __restrict  */)(& st));
      }
#line 1043
      if (tmp___25 < 0) {
        {
#line 1044
        tmp___22 = __errno_location();
#line 1044
        tmp___23 = strerror(*tmp___22);
#line 1044
        tmp___24 = gettext("Cannot stat() mounted device %s: %s\n");
#line 1044
        errstr(tmp___24, devname, tmp___23);
#line 1045
        free((void *)((char *)devname));
        }
#line 1046
        goto while_continue;
      }
#line 1048
      if (! ((st.st_mode & 61440U) == 24576U)) {
#line 1048
        if (! ((st.st_mode & 61440U) == 8192U)) {
          {
#line 1049
          tmp___26 = gettext("Device (%s) filesystem is mounted on unsupported device type. Skipping.\n");
#line 1049
          errstr(tmp___26, devname);
#line 1050
          free((void *)((char *)devname));
          }
#line 1051
          goto while_continue;
        }
      }
#line 1053
      dev = st.st_rdev;
#line 1054
      i = 0;
      {
#line 1054
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1054
        if (i < mnt_entries_cnt___6) {
#line 1054
          if (! ((mnt_entries___6 + i)->me_dev != dev)) {
#line 1054
            goto while_break___1;
          }
        } else {
#line 1054
          goto while_break___1;
        }
#line 1054
        i ++;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
    {
#line 1057
    tmp___33 = nfs_fstype(mnt___2->mnt_type);
    }
#line 1057
    if (tmp___33) {
#line 1057
      goto _L;
    } else
#line 1057
    if (i == mnt_entries_cnt___6) {
      _L: /* CIL Label */ 
      {
#line 1058
      tmp___31 = stat((char const   */* __restrict  */)mnt___2->mnt_dir, (struct stat */* __restrict  */)(& st));
      }
#line 1058
      if (tmp___31 < 0) {
        {
#line 1059
        tmp___28 = __errno_location();
#line 1059
        tmp___29 = strerror(*tmp___28);
#line 1059
        tmp___30 = gettext("Cannot stat() mountpoint %s: %s\n");
#line 1059
        errstr(tmp___30, mnt___2->mnt_dir, tmp___29);
#line 1060
        free((void *)((char *)devname));
        }
#line 1061
        goto while_continue;
      }
      {
#line 1063
      tmp___32 = nfs_fstype(mnt___2->mnt_type);
      }
#line 1063
      if (tmp___32) {
#line 1065
        dev = st.st_dev;
#line 1066
        if (! (flags___7 & 32)) {
#line 1067
          i = 0;
          {
#line 1067
          while (1) {
            while_continue___2: /* CIL Label */ ;
#line 1067
            if (i < mnt_entries_cnt___6) {
#line 1067
              if (! ((mnt_entries___6 + i)->me_dev != dev)) {
#line 1067
                goto while_break___2;
              }
            } else {
#line 1067
              goto while_break___2;
            }
#line 1067
            i ++;
          }
          while_break___2: /* CIL Label */ ;
          }
        } else {
#line 1070
          i = mnt_entries_cnt___6;
        }
      }
    }
#line 1073
    if (i == mnt_entries_cnt___6) {
#line 1074
      if (allocated == mnt_entries_cnt___6) {
        {
#line 1075
        allocated += 16;
#line 1076
        tmp___34 = srealloc((void *)mnt_entries___6, (unsigned long )allocated * sizeof(struct mount_entry ));
#line 1076
        mnt_entries___6 = (struct mount_entry *)tmp___34;
        }
      }
      {
#line 1078
      (mnt_entries___6 + i)->me_type = sstrdup((char const   *)mnt___2->mnt_type);
#line 1079
      (mnt_entries___6 + i)->me_opts = sstrdup((char const   *)mnt___2->mnt_opts);
#line 1080
      (mnt_entries___6 + i)->me_dev = dev;
#line 1081
      (mnt_entries___6 + i)->me_ino = st.st_ino;
#line 1082
      (mnt_entries___6 + i)->me_devname = devname;
#line 1083
      tmp___35 = sstrdup((char const   *)(mntpointbuf));
#line 1083
      (mnt_entries___6 + i)->me__dir = (char const   *)tmp___35;
#line 1084
      (mnt_entries___6 + i)->me_dir = (char const   *)((void *)0);
#line 1085
      memcpy((void */* __restrict  */)(& (mnt_entries___6 + i)->me_qfmt), (void const   */* __restrict  */)(qfmt),
             sizeof(qfmt));
#line 1086
      mnt_entries_cnt___6 ++;
      }
    } else {
      {
#line 1089
      free((void *)((char *)devname));
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1091
  endmntent(mntf);
#line 1093
  i = 0;
  }
  {
#line 1093
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 1093
    if (! (i < autofsdircnt)) {
#line 1093
      goto while_break___3;
    }
    {
#line 1094
    free((void *)*(autofsdir + i));
#line 1093
    i ++;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 1095
  free((void *)autofsdir);
  }
#line 1096
  return (0);
}
}
#line 1100 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static char const   *find_dir_mntpoint___6(struct stat *st ) 
{ 
  int i ;

  {
#line 1104
  i = 0;
  {
#line 1104
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1104
    if (! (i < mnt_entries_cnt___6)) {
#line 1104
      goto while_break;
    }
#line 1105
    if ((mnt_entries___6 + i)->me_dev == st->st_dev) {
#line 1106
      st->st_ino = (mnt_entries___6 + i)->me_ino;
#line 1107
      return ((mnt_entries___6 + i)->me__dir);
    }
#line 1104
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1109
  return ((char const   *)((void *)0));
}
}
#line 1113 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static int process_dirs___6(int dcnt , char **dirs , int flags___7 ) 
{ 
  struct stat st ;
  int i ;
  char mntpointbuf[4096] ;
  void *tmp ;
  char *devname ;
  char const   *tmp___0 ;
  char *tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  int *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  char const   *realmnt ;
  char *tmp___12 ;
  int *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  int mentry ;
  char *tmp___17 ;
  char *tmp___18 ;
  char *tmp___19 ;
  char *tmp___20 ;

  {
#line 1119
  check_dirs_cnt___6 = 0;
#line 1120
  act_checked___6 = -1;
#line 1121
  if (dcnt) {
    {
#line 1122
    tmp = smalloc(sizeof(struct searched_dir ) * (unsigned long )dcnt);
#line 1122
    check_dirs___6 = (struct searched_dir *)tmp;
#line 1123
    i = 0;
    }
    {
#line 1123
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1123
      if (! (i < dcnt)) {
#line 1123
        goto while_break;
      }
      {
#line 1124
      tmp___10 = strncmp((char const   *)*(dirs + i), "UUID=", (size_t )5);
      }
#line 1124
      if (tmp___10) {
        {
#line 1124
        tmp___11 = strncmp((char const   *)*(dirs + i), "LABEL=", (size_t )6);
        }
#line 1124
        if (tmp___11) {
          {
#line 1139
          tmp___9 = stat((char const   */* __restrict  */)*(dirs + i), (struct stat */* __restrict  */)(& st));
          }
#line 1139
          if (tmp___9 < 0) {
            {
#line 1140
            tmp___6 = __errno_location();
#line 1140
            tmp___7 = strerror(*tmp___6);
#line 1140
            tmp___8 = gettext("Cannot stat() given mountpoint %s: %s\nSkipping...\n");
#line 1140
            errstr(tmp___8, *(dirs + i), tmp___7);
            }
#line 1141
            goto __Cont;
          }
        } else {
          _L: /* CIL Label */ 
          {
#line 1125
          tmp___0 = get_device_name((char const   *)*(dirs + i));
#line 1125
          devname = (char *)tmp___0;
          }
#line 1127
          if (! devname) {
            {
#line 1128
            tmp___1 = gettext("Cannot find a device with %s.\nSkipping...\n");
#line 1128
            errstr(tmp___1, *(dirs + i));
            }
#line 1129
            goto __Cont;
          }
          {
#line 1131
          tmp___5 = stat((char const   */* __restrict  */)devname, (struct stat */* __restrict  */)(& st));
          }
#line 1131
          if (tmp___5 < 0) {
            {
#line 1132
            tmp___2 = __errno_location();
#line 1132
            tmp___3 = strerror(*tmp___2);
#line 1132
            tmp___4 = gettext("Cannot stat() a mountpoint with %s: %s\nSkipping...\n");
#line 1132
            errstr(tmp___4, *(dirs + i), tmp___3);
#line 1133
            free((void *)devname);
            }
#line 1134
            goto __Cont;
          }
          {
#line 1136
          free((void *)devname);
          }
        }
      } else {
#line 1124
        goto _L;
      }
#line 1143
      (check_dirs___6 + check_dirs_cnt___6)->sd_dir = (st.st_mode & 61440U) == 16384U;
#line 1144
      if ((st.st_mode & 61440U) == 16384U) {
#line 1145
        realmnt = (char const   *)*(dirs + i);
#line 1148
        if (flags___7 & 1) {
          {
#line 1148
          realmnt = find_dir_mntpoint___6(& st);
          }
#line 1148
          if (! realmnt) {
#line 1149
            if (! (flags___7 & 4)) {
              {
#line 1150
              tmp___12 = gettext("Cannot find a filesystem mountpoint for directory %s\n");
#line 1150
              errstr(tmp___12, *(dirs + i));
              }
            }
#line 1151
            goto __Cont;
          }
        }
        {
#line 1153
        (check_dirs___6 + check_dirs_cnt___6)->sd_dev = st.st_dev;
#line 1154
        (check_dirs___6 + check_dirs_cnt___6)->sd_ino = st.st_ino;
#line 1155
        tmp___16 = realpath((char const   */* __restrict  */)realmnt, (char */* __restrict  */)(mntpointbuf));
        }
#line 1155
        if (! tmp___16) {
          {
#line 1156
          tmp___13 = __errno_location();
#line 1156
          tmp___14 = strerror(*tmp___13);
#line 1156
          tmp___15 = gettext("Cannot resolve path %s: %s\n");
#line 1156
          errstr(tmp___15, realmnt, tmp___14);
          }
#line 1157
          goto __Cont;
        }
      } else
#line 1160
      if ((st.st_mode & 61440U) == 24576U) {
#line 1160
        goto _L___0;
      } else
#line 1160
      if ((st.st_mode & 61440U) == 8192U) {
        _L___0: /* CIL Label */ 
#line 1163
        (check_dirs___6 + check_dirs_cnt___6)->sd_dev = st.st_rdev;
#line 1164
        mentry = 0;
        {
#line 1164
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 1164
          if (mentry < mnt_entries_cnt___6) {
#line 1164
            if (! ((mnt_entries___6 + mentry)->me_dev != st.st_rdev)) {
#line 1164
              goto while_break___0;
            }
          } else {
#line 1164
            goto while_break___0;
          }
#line 1164
          mentry ++;
        }
        while_break___0: /* CIL Label */ ;
        }
#line 1165
        if (mentry == mnt_entries_cnt___6) {
#line 1166
          if (! (flags___7 & 4)) {
            {
#line 1167
            tmp___17 = gettext("Cannot find mountpoint for device %s\n");
#line 1167
            errstr(tmp___17, *(dirs + i));
            }
          }
#line 1168
          goto __Cont;
        }
        {
#line 1170
        sstrncpy(mntpointbuf, (mnt_entries___6 + mentry)->me__dir, (size_t )4095);
        }
      } else {
        {
#line 1173
        tmp___18 = gettext("Specified path %s is not directory nor device.\n");
#line 1173
        errstr(tmp___18, *(dirs + i));
        }
#line 1174
        goto __Cont;
      }
      {
#line 1176
      tmp___19 = sstrdup((char const   *)(mntpointbuf));
#line 1176
      (check_dirs___6 + check_dirs_cnt___6)->sd_name = (char const   *)tmp___19;
#line 1177
      check_dirs_cnt___6 ++;
      }
      __Cont: /* CIL Label */ 
#line 1123
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 1179
    if (! check_dirs_cnt___6) {
#line 1180
      if (! (flags___7 & 4)) {
        {
#line 1181
        tmp___20 = gettext("No correct mountpoint specified.\n");
#line 1181
        errstr(tmp___20);
        }
      }
      {
#line 1182
      free((void *)check_dirs___6);
      }
#line 1183
      return (-1);
    }
  }
#line 1186
  return (0);
}
}
#line 1204 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static int find_next_entry_all___6(int *pos ) 
{ 
  char *tmp ;

  {
  {
#line 1206
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1206
    act_checked___6 ++;
#line 1206
    if (! (act_checked___6 < mnt_entries_cnt___6)) {
#line 1206
      goto while_break;
    }
    {
#line 1207
    tmp = str_hasmntopt((char const   *)(mnt_entries___6 + act_checked___6)->me_opts,
                        "noauto");
    }
#line 1207
    if (! tmp) {
#line 1208
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1210
  if (act_checked___6 >= mnt_entries_cnt___6) {
#line 1211
    return (0);
  }
#line 1212
  *pos = act_checked___6;
#line 1213
  return (1);
}
}
#line 1217 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static int find_next_entry_sel___6(int *pos ) 
{ 
  int i ;
  struct searched_dir *sd ;
  char *tmp ;

  {
  restart: 
#line 1223
  act_checked___6 ++;
#line 1223
  if (act_checked___6 == check_dirs_cnt___6) {
#line 1224
    return (0);
  }
#line 1225
  sd = check_dirs___6 + act_checked___6;
#line 1226
  i = 0;
  {
#line 1226
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1226
    if (! (i < mnt_entries_cnt___6)) {
#line 1226
      goto while_break;
    }
#line 1227
    if (sd->sd_dir) {
#line 1228
      if (sd->sd_dev == (mnt_entries___6 + i)->me_dev) {
#line 1228
        if (sd->sd_ino == (mnt_entries___6 + i)->me_ino) {
#line 1229
          goto while_break;
        }
      }
    } else
#line 1232
    if (sd->sd_dev == (mnt_entries___6 + i)->me_dev) {
#line 1233
      goto while_break;
    }
#line 1226
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1235
  if (i == mnt_entries_cnt___6) {
    {
#line 1236
    tmp = gettext("Mountpoint (or device) %s not found or has no quota enabled.\n");
#line 1236
    errstr(tmp, sd->sd_name);
    }
#line 1237
    goto restart;
  }
#line 1239
  *pos = i;
#line 1240
  return (1);
}
}
#line 19 "/home/wheatley/newnew/temp/quota-4.01/quotaio_meta.c"
static int meta_init_io___6(struct quota_handle *h ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
#line 21
  if (! (h->qh_io_flags & 1)) {
    {
#line 22
    tmp = gettext("Metadata init_io called when kernel support is not enabled.\n");
#line 22
    errstr(tmp);
    }
#line 23
    return (-1);
  }
#line 25
  if (kernel_iface != 3) {
    {
#line 26
    tmp___0 = gettext("Metadata init_io called when kernel does not support generic quota interface!\n");
#line 26
    errstr(tmp___0);
    }
#line 27
    return (-1);
  }
  {
#line 29
  tmp___1 = vfs_get_info(h);
  }
#line 29
  return (tmp___1);
}
}
#line 32 "/home/wheatley/newnew/temp/quota-4.01/quotaio_meta.c"
static int meta_write_info___6(struct quota_handle *h ) 
{ 
  int tmp ;

  {
  {
#line 34
  tmp = vfs_set_info(h, 3);
  }
#line 34
  return (tmp);
}
}
#line 37 "/home/wheatley/newnew/temp/quota-4.01/quotaio_meta.c"
static struct dquot *meta_read_dquot___6(struct quota_handle *h , qid_t id___0 ) 
{ 
  struct dquot *dquot ;
  struct dquot *tmp ;
  int tmp___0 ;

  {
  {
#line 39
  tmp = get_empty_dquot();
#line 39
  dquot = tmp;
#line 41
  dquot->dq_id = id___0;
#line 42
  dquot->dq_h = h;
#line 43
  memset((void *)(& dquot->dq_dqb), 0, sizeof(struct util_dqblk ));
#line 44
  tmp___0 = vfs_get_dquot(dquot);
  }
#line 44
  if (tmp___0 < 0) {
    {
#line 45
    free((void *)dquot);
    }
#line 46
    return ((struct dquot *)((void *)0));
  }
#line 48
  return (dquot);
}
}
#line 51 "/home/wheatley/newnew/temp/quota-4.01/quotaio_meta.c"
static int meta_commit_dquot___6(struct dquot *dquot , int flags___7 ) 
{ 
  int tmp ;

  {
  {
#line 53
  tmp = vfs_set_dquot(dquot, flags___7);
  }
#line 53
  return (tmp);
}
}
#line 56 "/home/wheatley/newnew/temp/quota-4.01/quotaio_meta.c"
static int meta_scan_dquots___6(struct quota_handle *h , int (*process_dquot)(struct dquot *dquot ,
                                                                              char *dqname ) ) 
{ 
  int tmp ;

  {
  {
#line 58
  tmp = generic_scan_dquots(h, process_dquot, & vfs_get_dquot);
  }
#line 58
  return (tmp);
}
}
#line 281 "/home/wheatley/newnew/temp/quota-4.01/quotaops.c"
static void merge_limits_to_list___1(struct dquot *qlist , char *dev , u_int64_t blocks ,
                                     u_int64_t bsoft , u_int64_t bhard , u_int64_t inodes ,
                                     u_int64_t isoft , u_int64_t ihard ) 
{ 
  struct dquot *q ;
  int tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
#line 286
  q = qlist;
  {
#line 286
  while (1) {
    while_continue: /* CIL Label */ ;
#line 286
    if (! q) {
#line 286
      goto while_break;
    }
    {
#line 287
    tmp = devcmp_handle((char const   *)dev, q->dq_h);
    }
#line 287
    if (! tmp) {
#line 288
      goto __Cont;
    }
    {
#line 290
    q->dq_dqb.dqb_bsoftlimit = (qsize_t )bsoft;
#line 291
    q->dq_dqb.dqb_bhardlimit = (qsize_t )bhard;
#line 292
    q->dq_dqb.dqb_isoftlimit = (qsize_t )isoft;
#line 293
    q->dq_dqb.dqb_ihardlimit = (qsize_t )ihard;
#line 294
    q->dq_flags |= 1;
#line 295
    update_grace_times(q);
    }
#line 297
    if (blocks != (u_int64_t )(((q->dq_dqb.dqb_curspace + (qsize_t )(1 << 10)) - 1L) >> 10)) {
      {
#line 298
      tmp___0 = gettext("WARNING - %s: cannot change current block allocation\n");
#line 298
      errstr(tmp___0, (q->dq_h)->qh_quotadev);
      }
    }
#line 300
    if (inodes != (u_int64_t )q->dq_dqb.dqb_curinodes) {
      {
#line 301
      tmp___1 = gettext("WARNING - %s: cannot change current inode allocation\n");
#line 301
      errstr(tmp___1, (q->dq_h)->qh_quotadev);
      }
    }
    __Cont: /* CIL Label */ 
#line 286
    q = q->dq_next;
  }
  while_break: /* CIL Label */ ;
  }
#line 304
  return;
}
}
#line 357 "/home/wheatley/newnew/temp/quota-4.01/quotaops.c"
static void merge_times_to_list___1(struct dquot *qlist , char *dev , time_t btime ,
                                    time_t itime ) 
{ 
  struct dquot *q ;
  int tmp ;

  {
#line 361
  q = qlist;
  {
#line 361
  while (1) {
    while_continue: /* CIL Label */ ;
#line 361
    if (! q) {
#line 361
      goto while_break;
    }
    {
#line 362
    tmp = devcmp_handle((char const   *)dev, q->dq_h);
    }
#line 362
    if (! tmp) {
#line 363
      goto __Cont;
    }
#line 365
    q->dq_dqb.dqb_btime = btime;
#line 366
    q->dq_dqb.dqb_itime = itime;
#line 367
    q->dq_flags |= 1;
    __Cont: /* CIL Label */ 
#line 361
    q = q->dq_next;
  }
  while_break: /* CIL Label */ ;
  }
#line 369
  return;
}
}
#line 27 "/home/wheatley/newnew/temp/quota-4.01/quotaio_xfs.c"
static int xfs_init_io___6(struct quota_handle *h ) ;
#line 28
static int xfs_write_info___6(struct quota_handle *h ) ;
#line 29
static struct dquot *xfs_read_dquot___6(struct quota_handle *h , qid_t id___0 ) ;
#line 30
static int xfs_commit_dquot___6(struct dquot *dquot , int flags___7 ) ;
#line 31
static int xfs_scan_dquots___6(struct quota_handle *h , int (*process_dquot)(struct dquot *dquot ,
                                                                             char *dqname ) ) ;
#line 32
static int xfs_report___6(struct quota_handle *h , int verbose ) ;
#line 77 "/home/wheatley/newnew/temp/quota-4.01/quotaio_xfs.c"
static int xfs_init_io___6(struct quota_handle *h ) 
{ 
  struct fs_quota_stat info ;
  int qcmd ;
  long tmp ;

  {
  {
#line 82
  qcmd = ((88 << 8) + 5) << 8;
#line 83
  memset((void *)(& info), 0, sizeof(struct fs_quota_stat ));
#line 84
  tmp = quotactl(qcmd, (char const   *)(h->qh_quotadev), (qid_t )0, (caddr_t )((void *)(& info)));
  }
#line 84
  if (tmp < 0L) {
#line 85
    return (-1);
  }
#line 86
  h->qh_info.dqi_bgrace = (time_t )info.qs_btimelimit;
#line 87
  h->qh_info.dqi_igrace = (time_t )info.qs_itimelimit;
#line 88
  h->qh_info.u.xfs_mdqi = info;
#line 89
  return (0);
}
}
#line 95 "/home/wheatley/newnew/temp/quota-4.01/quotaio_xfs.c"
static int xfs_write_info___6(struct quota_handle *h ) 
{ 
  struct fs_disk_quota xdqblk ;
  int qcmd ;
  long tmp ;

  {
#line 100
  if (h->qh_type == 0) {
#line 100
    if (! ((int )h->qh_info.u.xfs_mdqi.qs_flags & 1)) {
#line 100
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 100
  if (h->qh_type == 1) {
#line 100
    if (! ((int )h->qh_info.u.xfs_mdqi.qs_flags & (1 << 2))) {
#line 101
      return (0);
    }
  } else {
#line 101
    return (0);
  }
  {
#line 103
  memset((void *)(& xdqblk), 0, sizeof(struct fs_disk_quota ));
#line 105
  xdqblk.d_btimer = (__s32 )h->qh_info.dqi_bgrace;
#line 106
  xdqblk.d_itimer = (__s32 )h->qh_info.dqi_igrace;
#line 107
  xdqblk.d_fieldmask = (__u16 )((int )xdqblk.d_fieldmask | (((1 << 6) | (1 << 7)) | (1 << 8)));
#line 108
  qcmd = (((88 << 8) + 4) << 8) | (h->qh_type & 255);
#line 109
  tmp = quotactl(qcmd, (char const   *)(h->qh_quotadev), (qid_t )0, (caddr_t )((void *)(& xdqblk)));
  }
#line 109
  if (tmp < 0L) {
#line 110
    return (-1);
  }
#line 111
  return (0);
}
}
#line 117 "/home/wheatley/newnew/temp/quota-4.01/quotaio_xfs.c"
static struct dquot *xfs_read_dquot___6(struct quota_handle *h , qid_t id___0 ) 
{ 
  struct dquot *dquot ;
  struct dquot *tmp ;
  struct fs_disk_quota xdqblk ;
  int qcmd ;
  long tmp___0 ;

  {
  {
#line 119
  tmp = get_empty_dquot();
#line 119
  dquot = tmp;
#line 123
  dquot->dq_id = id___0;
#line 124
  dquot->dq_h = h;
  }
#line 126
  if (h->qh_type == 0) {
#line 126
    if (! ((int )h->qh_info.u.xfs_mdqi.qs_flags & 1)) {
#line 126
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 126
  if (h->qh_type == 1) {
#line 126
    if (! ((int )h->qh_info.u.xfs_mdqi.qs_flags & (1 << 2))) {
#line 127
      return (dquot);
    }
  } else {
#line 127
    return (dquot);
  }
  {
#line 129
  qcmd = (((88 << 8) + 3) << 8) | (h->qh_type & 255);
#line 130
  tmp___0 = quotactl(qcmd, (char const   *)(h->qh_quotadev), id___0, (caddr_t )((void *)(& xdqblk)));
  }
#line 130
  if (! (tmp___0 < 0L)) {
    {
#line 134
    xfs_kern2utildqblk(& dquot->dq_dqb, & xdqblk);
    }
  }
#line 136
  return (dquot);
}
}
#line 142 "/home/wheatley/newnew/temp/quota-4.01/quotaio_xfs.c"
static int xfs_commit_dquot___6(struct dquot *dquot , int flags___7 ) 
{ 
  struct quota_handle *h ;
  struct fs_disk_quota xdqblk ;
  qid_t id___0 ;
  int qcmd ;
  int tmp ;
  int tmp___0 ;
  long tmp___1 ;

  {
#line 144
  h = dquot->dq_h;
#line 146
  id___0 = dquot->dq_id;
#line 149
  if (h->qh_type == 0) {
#line 149
    if (! ((int )h->qh_info.u.xfs_mdqi.qs_flags & 1)) {
#line 149
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 149
  if (h->qh_type == 1) {
#line 149
    if (! ((int )h->qh_info.u.xfs_mdqi.qs_flags & (1 << 2))) {
#line 150
      return (0);
    }
  } else {
#line 150
    return (0);
  }
  {
#line 152
  xfs_util2kerndqblk(& xdqblk, & dquot->dq_dqb);
  }
#line 153
  if (h->qh_type == 0) {
#line 153
    if ((int )h->qh_info.u.xfs_mdqi.qs_flags & 1) {
#line 153
      tmp = 1;
    } else {
#line 153
      tmp = 1 << 2;
    }
  } else {
#line 153
    tmp = 1 << 2;
  }
  {
#line 153
  xdqblk.d_flags = (__s8 )((int )xdqblk.d_flags | tmp);
#line 154
  xdqblk.d_id = id___0;
#line 155
  tmp___0 = strcmp((char const   *)(h->qh_fstype), "gfs2");
  }
#line 155
  if (tmp___0 == 0) {
#line 156
    if (flags___7 & 5) {
#line 157
      xdqblk.d_fieldmask = (__u16 )((int )xdqblk.d_fieldmask | ((1 << 2) | (1 << 3)));
    }
#line 158
    if (flags___7 & 10) {
#line 159
      xdqblk.d_fieldmask = (__u16 )((int )xdqblk.d_fieldmask | (1 << 12));
    }
  } else {
#line 161
    xdqblk.d_fieldmask = (__u16 )((int )xdqblk.d_fieldmask | (((((1 | (1 << 1)) | (1 << 2)) | (1 << 3)) | (1 << 4)) | (1 << 5)));
  }
  {
#line 164
  qcmd = (((88 << 8) + 4) << 8) | (h->qh_type & 255);
#line 165
  tmp___1 = quotactl(qcmd, (char const   *)(h->qh_quotadev), id___0, (caddr_t )((void *)(& xdqblk)));
  }
#line 165
  if (! (tmp___1 < 0L)) {
#line 169
    return (0);
  }
#line 171
  return (-1);
}
}
#line 177 "/home/wheatley/newnew/temp/quota-4.01/quotaio_xfs.c"
static int xfs_get_dquot___6(struct dquot *dq ) 
{ 
  struct fs_disk_quota d ;
  int qcmd ;
  int ret ;
  long tmp ;
  int *tmp___0 ;

  {
  {
#line 180
  qcmd = (((88 << 8) + 3) << 8) | ((dq->dq_h)->qh_type & 255);
#line 183
  memset((void *)(& d), 0, sizeof(d));
#line 184
  tmp = quotactl(qcmd, (char const   *)((dq->dq_h)->qh_quotadev), dq->dq_id, (caddr_t )((void *)(& d)));
#line 184
  ret = (int )tmp;
  }
#line 185
  if (ret < 0) {
    {
#line 186
    tmp___0 = __errno_location();
    }
#line 186
    if (*tmp___0 == 2) {
#line 187
      return (0);
    }
#line 188
    return (-1);
  }
  {
#line 190
  xfs_kern2utildqblk(& dq->dq_dqb, & d);
  }
#line 191
  return (0);
}
}
#line 197 "/home/wheatley/newnew/temp/quota-4.01/quotaio_xfs.c"
static int xfs_scan_dquots___6(struct quota_handle *h , int (*process_dquot)(struct dquot *dquot ,
                                                                             char *dqname ) ) 
{ 
  int tmp ;

  {
#line 199
  if (h->qh_type == 0) {
#line 199
    if (! ((int )h->qh_info.u.xfs_mdqi.qs_flags & 1)) {
#line 199
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 199
  if (h->qh_type == 1) {
#line 199
    if (! ((int )h->qh_info.u.xfs_mdqi.qs_flags & (1 << 2))) {
#line 200
      return (0);
    }
  } else {
#line 200
    return (0);
  }
  {
#line 202
  tmp = generic_scan_dquots(h, process_dquot, & xfs_get_dquot___6);
  }
#line 202
  return (tmp);
}
}
#line 208 "/home/wheatley/newnew/temp/quota-4.01/quotaio_xfs.c"
static int xfs_report___6(struct quota_handle *h , int verbose ) 
{ 
  u_int16_t sbflags ;
  struct fs_quota_stat *info ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;
  char *tmp___18 ;
  char *tmp___19 ;
  char *tmp___20 ;
  char *tmp___21 ;
  char *tmp___22 ;
  char *tmp___23 ;
  char *tmp___24 ;
  char *tmp___25 ;
  char *tmp___26 ;
  char *tmp___27 ;
  char *tmp___28 ;
  char *tmp___29 ;
  char *tmp___30 ;
  char *tmp___31 ;
  char *tmp___32 ;

  {
#line 211
  info = & h->qh_info.u.xfs_mdqi;
#line 213
  if (! verbose) {
#line 214
    return (0);
  }
  {
#line 217
  tmp = type2name(h->qh_type);
#line 217
  tmp___0 = gettext("*** Status for %s quotas on device %s\n");
#line 217
  printf((char const   */* __restrict  */)tmp___0, tmp, h->qh_quotadev);
  }
#line 220
  if (h->qh_type == 0) {
#line 221
    if ((int )info->qs_flags & (1 << 1)) {
      {
#line 221
      tmp___1 = gettext("ON");
#line 221
      tmp___3 = tmp___1;
      }
    } else {
      {
#line 221
      tmp___2 = gettext("OFF");
#line 221
      tmp___3 = tmp___2;
      }
    }
#line 221
    if ((int )info->qs_flags & 1) {
      {
#line 221
      tmp___4 = gettext("ON");
#line 221
      tmp___6 = tmp___4;
      }
    } else {
      {
#line 221
      tmp___5 = gettext("OFF");
#line 221
      tmp___6 = tmp___5;
      }
    }
    {
#line 221
    tmp___7 = gettext("Accounting: %s; Enforcement: %s\n");
#line 221
    printf((char const   */* __restrict  */)tmp___7, tmp___6, tmp___3);
    }
  } else {
#line 225
    if ((int )info->qs_flags & (1 << 3)) {
      {
#line 225
      tmp___8 = gettext("ON");
#line 225
      tmp___10 = tmp___8;
      }
    } else {
      {
#line 225
      tmp___9 = gettext("OFF");
#line 225
      tmp___10 = tmp___9;
      }
    }
#line 225
    if ((int )info->qs_flags & (1 << 2)) {
      {
#line 225
      tmp___11 = gettext("ON");
#line 225
      tmp___13 = tmp___11;
      }
    } else {
      {
#line 225
      tmp___12 = gettext("OFF");
#line 225
      tmp___13 = tmp___12;
      }
    }
    {
#line 225
    tmp___14 = gettext("Accounting: %s; Enforcement: %s\n");
#line 225
    printf((char const   */* __restrict  */)tmp___14, tmp___13, tmp___10);
    }
  }
#line 235
  sbflags = (u_int16_t )(((int )info->qs_flags & 65280) >> 8);
#line 235
  if ((int )sbflags != 0) {
#line 236
    if (h->qh_type == 0) {
#line 237
      if ((int )sbflags & (1 << 1)) {
        {
#line 237
        tmp___15 = gettext("ON");
#line 237
        tmp___17 = tmp___15;
        }
      } else {
        {
#line 237
        tmp___16 = gettext("OFF");
#line 237
        tmp___17 = tmp___16;
        }
      }
#line 237
      if ((int )sbflags & 1) {
        {
#line 237
        tmp___18 = gettext("ON");
#line 237
        tmp___20 = tmp___18;
        }
      } else {
        {
#line 237
        tmp___19 = gettext("OFF");
#line 237
        tmp___20 = tmp___19;
        }
      }
      {
#line 237
      tmp___21 = gettext("Accounting [ondisk]: %s; Enforcement [ondisk]: %s\n");
#line 237
      printf((char const   */* __restrict  */)tmp___21, tmp___20, tmp___17);
      }
    } else {
#line 241
      if ((int )sbflags & (1 << 3)) {
        {
#line 241
        tmp___22 = gettext("ON");
#line 241
        tmp___24 = tmp___22;
        }
      } else {
        {
#line 241
        tmp___23 = gettext("OFF");
#line 241
        tmp___24 = tmp___23;
        }
      }
#line 241
      if ((int )sbflags & (1 << 2)) {
        {
#line 241
        tmp___25 = gettext("ON");
#line 241
        tmp___27 = tmp___25;
        }
      } else {
        {
#line 241
        tmp___26 = gettext("OFF");
#line 241
        tmp___27 = tmp___26;
        }
      }
      {
#line 241
      tmp___28 = gettext("Accounting [ondisk]: %s; Enforcement [ondisk]: %s\n");
#line 241
      printf((char const   */* __restrict  */)tmp___28, tmp___27, tmp___24);
      }
    }
  }
#line 248
  if (h->qh_type == 0) {
#line 249
    if (info->qs_uquota.qfs_ino == 0xffffffffffffffffULL) {
      {
#line 250
      tmp___29 = gettext("Inode: none\n");
#line 250
      printf((char const   */* __restrict  */)tmp___29);
      }
    } else
#line 249
    if (info->qs_uquota.qfs_ino == 0ULL) {
      {
#line 250
      tmp___29 = gettext("Inode: none\n");
#line 250
      printf((char const   */* __restrict  */)tmp___29);
      }
    } else {
      {
#line 252
      tmp___30 = gettext("Inode: #%llu (%llu blocks, %u extents)\n");
#line 252
      printf((char const   */* __restrict  */)tmp___30, info->qs_uquota.qfs_ino, info->qs_uquota.qfs_nblks,
             info->qs_uquota.qfs_nextents);
      }
    }
  } else
#line 258
  if (info->qs_gquota.qfs_ino == 0xffffffffffffffffULL) {
    {
#line 259
    tmp___31 = gettext("Inode: none\n");
#line 259
    printf((char const   */* __restrict  */)tmp___31);
    }
  } else {
    {
#line 261
    tmp___32 = gettext("Inode: #%llu (%llu blocks, %u extents)\n");
#line 261
    printf((char const   */* __restrict  */)tmp___32, info->qs_gquota.qfs_ino, info->qs_gquota.qfs_nblks,
           info->qs_gquota.qfs_nextents);
    }
  }
#line 266
  return (0);
}
}
#line 134 "/usr/include/dirent.h"
extern DIR *( __attribute__((__nonnull__(1))) opendir)(char const   *__name ) ;
#line 149
extern int ( __attribute__((__nonnull__(1))) closedir)(DIR *__dirp ) ;
#line 165
extern struct dirent *( __attribute__((__nonnull__(1))) readdir)(DIR *__dirp )  __asm__("readdir64")  ;
#line 168 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 169
extern struct _IO_FILE *stdout ;
#line 180
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) rename)(char const   *__old ,
                                                                             char const   *__new ) ;
#line 347
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) setlinebuf)(FILE *__stream ) ;
#line 497 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) chdir)(char const   *__path ) ;
#line 267 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) lstat)(char const   * __restrict  __file ,
                                                                                              struct stat * __restrict  __buf )  __asm__("lstat64")  ;
#line 284
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) chmod)(char const   *__file ,
                                                                                            __mode_t __mode ) ;
#line 135 "/usr/include/x86_64-linux-gnu/sys/mount.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) mount)(char const   *__special_file ,
                                                                            char const   *__dir ,
                                                                            char const   *__fstype ,
                                                                            unsigned long __rwflag ,
                                                                            void const   *__data ) ;
#line 31 "/home/wheatley/newnew/temp/quota-4.01/quotacheck.h"
struct util_dqinfo old_info[2]  ;
#line 65 "/home/wheatley/newnew/temp/quota-4.01/quotacheck.c"
static dev_t cur_dev  ;
#line 66 "/home/wheatley/newnew/temp/quota-4.01/quotacheck.c"
static int files_done  ;
#line 66 "/home/wheatley/newnew/temp/quota-4.01/quotacheck.c"
static int dirs_done  ;
#line 67 "/home/wheatley/newnew/temp/quota-4.01/quotacheck.c"
int fmt  =    -1;
#line 67 "/home/wheatley/newnew/temp/quota-4.01/quotacheck.c"
int cfmt  ;
#line 68 "/home/wheatley/newnew/temp/quota-4.01/quotacheck.c"
static int uwant  ;
#line 68 "/home/wheatley/newnew/temp/quota-4.01/quotacheck.c"
static int gwant  ;
#line 68 "/home/wheatley/newnew/temp/quota-4.01/quotacheck.c"
static int ucheck  ;
#line 68 "/home/wheatley/newnew/temp/quota-4.01/quotacheck.c"
static int gcheck  ;
#line 69 "/home/wheatley/newnew/temp/quota-4.01/quotacheck.c"
static char *mntpoint  ;
#line 73 "/home/wheatley/newnew/temp/quota-4.01/quotacheck.c"
static char extensions___7[4][20]  = { {        (char )'u',        (char )'s',        (char )'e',        (char )'r', 
            (char )'\000'}, 
   {        (char )'g',        (char )'r',        (char )'o',        (char )'u', 
            (char )'p',        (char )'\000'}, 
   {        (char )'u',        (char )'n',        (char )'d',        (char )'e', 
            (char )'f',        (char )'i',        (char )'n',        (char )'e', 
            (char )'d',        (char )'\000'}};
#line 74 "/home/wheatley/newnew/temp/quota-4.01/quotacheck.c"
static char *basenames___7[6]  = {      (char *)"quota",      (char *)"aquota",      (char *)"aquota",      (char *)"", 
        (char *)"",      (char *)""};
#line 81 "/home/wheatley/newnew/temp/quota-4.01/quotacheck.c"
static struct dquot *dquot_hash[2][32768]  ;
#line 82 "/home/wheatley/newnew/temp/quota-4.01/quotacheck.c"
static struct dlinks *links_hash[2][32768]  ;
#line 87 "/home/wheatley/newnew/temp/quota-4.01/quotacheck.c"
void *xmalloc(size_t size ) 
{ 
  void *ptr ;
  char *tmp ;

  {
  {
#line 94
  ptr = malloc(size);
  }
#line 95
  if (! ptr) {
    {
#line 96
    tmp = gettext("Not enough memory.\n");
#line 96
    die(3, tmp);
    }
  }
  {
#line 97
  memset(ptr, 0, size);
  }
#line 98
  return (ptr);
}
}
#line 101 "/home/wheatley/newnew/temp/quota-4.01/quotacheck.c"
void ( /* format attribute */  debug)(int df , char *fmtstr  , ...) 
{ 
  va_list args ;

  {
#line 105
  if (! (flags & df)) {
#line 106
    return;
  }
  {
#line 108
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: ",
          progname);
#line 109
  __builtin_va_start(args, fmtstr);
#line 110
  vfprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)fmtstr,
           args);
#line 111
  __builtin_va_end(args);
  }
#line 112
  return;
}
}
#line 115 "/home/wheatley/newnew/temp/quota-4.01/quotacheck.c"
__inline static uint hash_ino(uint i_num ) 
{ 


  {
#line 117
  return ((i_num ^ (i_num << 16)) * 997U & 16383U);
}
}
#line 123 "/home/wheatley/newnew/temp/quota-4.01/quotacheck.c"
static int store_dlinks(int type , ino_t i_num ) 
{ 
  struct dlinks *lptr ;
  uint hash ;
  uint tmp ;
  char *tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 126
  tmp = hash_ino((uint )i_num);
#line 126
  hash = tmp;
#line 128
  tmp___0 = gettext("Adding hardlink for inode %llu\n");
#line 128
  debug(4, tmp___0, (unsigned long long )i_num);
#line 130
  lptr = links_hash[type][hash];
  }
  {
#line 130
  while (1) {
    while_continue: /* CIL Label */ ;
#line 130
    if (! lptr) {
#line 130
      goto while_break;
    }
#line 131
    if (lptr->i_num == i_num) {
#line 132
      return (1);
    }
#line 130
    lptr = lptr->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 134
  tmp___1 = xmalloc(sizeof(struct dlinks ));
#line 134
  lptr = (struct dlinks *)tmp___1;
#line 136
  lptr->i_num = i_num;
#line 137
  lptr->next = links_hash[type][hash];
#line 138
  links_hash[type][hash] = lptr;
  }
#line 139
  return (0);
}
}
#line 143 "/home/wheatley/newnew/temp/quota-4.01/quotacheck.c"
__inline static uint hash_dquot(uint id___0 ) 
{ 


  {
#line 145
  return ((id___0 ^ (id___0 << 16)) * 997U & 32767U);
}
}
#line 152 "/home/wheatley/newnew/temp/quota-4.01/quotacheck.c"
struct dquot *lookup_dquot(qid_t id___0 , int type ) 
{ 
  struct dquot *lptr ;
  uint hash ;
  uint tmp ;

  {
  {
#line 155
  tmp = hash_dquot(id___0);
#line 155
  hash = tmp;
#line 157
  lptr = dquot_hash[type][hash];
  }
  {
#line 157
  while (1) {
    while_continue: /* CIL Label */ ;
#line 157
    if (! ((unsigned long )lptr != (unsigned long )((struct dquot *)((void *)0)))) {
#line 157
      goto while_break;
    }
#line 158
    if (lptr->dq_id == id___0) {
#line 159
      return (lptr);
    }
#line 157
    lptr = lptr->dq_next;
  }
  while_break: /* CIL Label */ ;
  }
#line 160
  return ((struct dquot *)((void *)0));
}
}
#line 166 "/home/wheatley/newnew/temp/quota-4.01/quotacheck.c"
struct dquot *add_dquot(qid_t id___0 , int type ) 
{ 
  struct dquot *lptr ;
  uint hash ;
  uint tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  void *tmp___2 ;
  time_t tmp___3 ;

  {
  {
#line 169
  tmp = hash_dquot(id___0);
#line 169
  hash = tmp;
#line 171
  tmp___0 = type2name(type);
#line 171
  tmp___1 = gettext("Adding dquot structure type %s for %d\n");
#line 171
  debug(4, tmp___1, tmp___0, (int )id___0);
#line 173
  tmp___2 = xmalloc(sizeof(struct dquot ));
#line 173
  lptr = (struct dquot *)tmp___2;
#line 175
  lptr->dq_id = id___0;
#line 176
  lptr->dq_next = dquot_hash[type][hash];
#line 177
  dquot_hash[type][hash] = lptr;
#line 178
  tmp___3 = (time_t )0;
#line 178
  lptr->dq_dqb.dqb_itime = tmp___3;
#line 178
  lptr->dq_dqb.dqb_btime = tmp___3;
  }
#line 180
  return (lptr);
}
}
#line 186 "/home/wheatley/newnew/temp/quota-4.01/quotacheck.c"
static void add_to_quota(int type , ino_t i_num , uid_t i_uid , gid_t i_gid , mode_t i_mode ,
                         nlink_t i_nlink , loff_t i_space , int need_remember ) 
{ 
  qid_t wanted ;
  struct dquot *lptr ;
  int tmp ;

  {
#line 192
  if (type == 0) {
#line 193
    wanted = i_uid;
  } else {
#line 195
    wanted = i_gid;
  }
  {
#line 197
  lptr = lookup_dquot(wanted, type);
  }
#line 197
  if ((unsigned long )lptr == (unsigned long )((struct dquot *)((void *)0))) {
    {
#line 198
    lptr = add_dquot(wanted, type);
    }
  }
#line 200
  if (i_nlink != 1UL) {
#line 200
    if (need_remember) {
      {
#line 201
      tmp = store_dlinks(type, i_num);
      }
#line 201
      if (tmp) {
#line 202
        return;
      }
    }
  }
#line 203
  (lptr->dq_dqb.dqb_curinodes) ++;
#line 204
  lptr->dq_dqb.dqb_curspace += i_space;
#line 205
  return;
}
}
#line 210 "/home/wheatley/newnew/temp/quota-4.01/quotacheck.c"
static void remove_list(void) 
{ 
  int cnt ;
  uint i ;
  struct dquot *dquot ;
  struct dquot *dquot_free ;
  struct dlinks *dlink ;
  struct dlinks *dlink_free ;

  {
#line 217
  cnt = 0;
  {
#line 217
  while (1) {
    while_continue: /* CIL Label */ ;
#line 217
    if (! (cnt < 2)) {
#line 217
      goto while_break;
    }
#line 218
    i = (uint )0;
    {
#line 218
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 218
      if (! (i < 32768U)) {
#line 218
        goto while_break___0;
      }
#line 219
      dquot = dquot_hash[cnt][i];
      {
#line 220
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 220
        if (! ((unsigned long )dquot != (unsigned long )((struct dquot *)((void *)0)))) {
#line 220
          goto while_break___1;
        }
        {
#line 221
        dquot_free = dquot;
#line 222
        dquot = dquot->dq_next;
#line 226
        free((void *)dquot_free);
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 228
      dquot_hash[cnt][i] = (struct dquot *)((void *)0);
#line 218
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 230
    i = (uint )0;
    {
#line 230
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 230
      if (! (i < 16384U)) {
#line 230
        goto while_break___2;
      }
#line 231
      dlink = links_hash[cnt][i];
      {
#line 232
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 232
        if (! dlink) {
#line 232
          goto while_break___3;
        }
        {
#line 233
        dlink_free = dlink;
#line 234
        dlink = dlink->next;
#line 238
        free((void *)dlink_free);
        }
      }
      while_break___3: /* CIL Label */ ;
      }
#line 240
      links_hash[cnt][i] = (struct dlinks *)((void *)0);
#line 230
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 217
    cnt ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 243
  return;
}
}
#line 248 "/home/wheatley/newnew/temp/quota-4.01/quotacheck.c"
static char ioctl_fail_warn  ;
#line 246 "/home/wheatley/newnew/temp/quota-4.01/quotacheck.c"
static loff_t getqsize(char const   *fname , struct stat *st ) 
{ 
  int fd ;
  loff_t size ;
  int *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;

  {
#line 252
  if ((st->st_mode & 61440U) == 40960U) {
#line 253
    return (st->st_blocks << 9);
  }
#line 254
  if (! ((st->st_mode & 61440U) == 16384U)) {
#line 254
    if (! ((st->st_mode & 61440U) == 32768U)) {
#line 255
      return (st->st_blocks << 9);
    }
  }
  {
#line 256
  fd = open(fname, 0);
  }
#line 256
  if (fd == -1) {
    {
#line 257
    tmp = __errno_location();
#line 257
    tmp___0 = strerror(*tmp);
#line 257
    tmp___1 = gettext("Cannot open file %s: %s\n");
#line 257
    die(2, tmp___1, fname, tmp___0);
    }
  }
  {
#line 258
  tmp___3 = ioctl(fd, 21600UL, & size);
  }
#line 258
  if (tmp___3 == -1) {
#line 259
    size = st->st_blocks << 9;
#line 260
    if (! ioctl_fail_warn) {
      {
#line 261
      ioctl_fail_warn = (char)1;
#line 262
      tmp___2 = gettext("Cannot get exact used space... Results might be inaccurate.\n");
#line 262
      fputs((char const   */* __restrict  */)tmp___2, (FILE */* __restrict  */)stderr);
      }
    }
  }
  {
#line 265
  close(fd);
  }
#line 266
  return (size);
}
}
#line 274
__inline static void blit(char const   *msg ) ;
#line 274 "/home/wheatley/newnew/temp/quota-4.01/quotacheck.c"
static int bitc  =    0;
#line 275 "/home/wheatley/newnew/temp/quota-4.01/quotacheck.c"
static char const   bits[5]  = {      (char const   )'|',      (char const   )'/',      (char const   )'-',      (char const   )'\\', 
        (char const   )'\000'};
#line 276 "/home/wheatley/newnew/temp/quota-4.01/quotacheck.c"
static int slow_down  ;
#line 272 "/home/wheatley/newnew/temp/quota-4.01/quotacheck.c"
__inline static void blit(char const   *msg ) 
{ 
  int len ;
  size_t tmp ;

  {
#line 278
  if (flags & 2048) {
#line 278
    if (msg) {
      {
#line 279
      tmp = strlen(msg);
#line 279
      len = (int )tmp;
#line 281
      putchar('\r');
#line 282
      printf((char const   */* __restrict  */)"%.70s", msg);
      }
#line 283
      if (len > 70) {
        {
#line 284
        fputs((char const   */* __restrict  */)"...", (FILE */* __restrict  */)stdout);
        }
      } else {
        {
#line 286
        printf((char const   */* __restrict  */)"%*s", 73 - len, "");
        }
      }
    }
  }
#line 288
  if (flags & 2048) {
#line 288
    goto _L;
  } else {
#line 288
    slow_down ++;
#line 288
    if (slow_down >= 10) {
      _L: /* CIL Label */ 
      {
#line 289
      putchar((int )bits[bitc]);
#line 290
      putchar('\b');
#line 291
      fflush(stdout);
#line 292
      bitc ++;
#line 293
      bitc %= 4;
#line 294
      slow_down = 0;
      }
    }
  }
#line 296
  return;
}
}
#line 298 "/home/wheatley/newnew/temp/quota-4.01/quotacheck.c"
static void usage___5(void) 
{ 
  char *tmp ;
  char *tmp___0 ;

  {
  {
#line 300
  tmp = gettext("Utility for checking and repairing quota files.\n%s [-gucbfinvdmMR] [-F <quota-format>] filesystem|-a\n\n-u, --user                check user files\n-g, --group               check group files\n-c, --create-files        create new quota files\n-b, --backup              create backups of old quota files\n-f, --force               force check even if quotas are enabled\n-i, --interactive         interactive mode\n-n, --use-first-dquot     use the first copy of duplicated structure\n-v, --verbose             print more information\n-d, --debug               print even more messages\n-m, --no-remount          do not remount filesystem read-only\n-M, --try-remount         try remounting filesystem read-only,\n                          continue even if it fails\n-R, --exclude-root        exclude root when checking all filesystems\n-F, --format=formatname   check quota files of specific format\n-a, --all                 check all filesystems\n-h, --help                display this message and exit\n-V, --version             display version information and exit\n\n");
#line 300
  printf((char const   */* __restrict  */)tmp, progname);
#line 318
  tmp___0 = gettext("Bugs to %s\n");
#line 318
  printf((char const   */* __restrict  */)tmp___0, "jack@suse.cz");
#line 319
  exit(1);
  }
}
}
#line 322 "/home/wheatley/newnew/temp/quota-4.01/quotacheck.c"
static void parse_options___4(int argcnt , char **argstr ) 
{ 
  int ret ;
  struct option long_opts[17] ;
  char *tmp ;

  {
#line 325
  long_opts[0].name = "version";
#line 325
  long_opts[0].has_arg = 0;
#line 325
  long_opts[0].flag = (int *)((void *)0);
#line 325
  long_opts[0].val = 'V';
#line 325
  long_opts[1].name = "help";
#line 325
  long_opts[1].has_arg = 0;
#line 325
  long_opts[1].flag = (int *)((void *)0);
#line 325
  long_opts[1].val = 'h';
#line 325
  long_opts[2].name = "backup";
#line 325
  long_opts[2].has_arg = 0;
#line 325
  long_opts[2].flag = (int *)((void *)0);
#line 325
  long_opts[2].val = 'b';
#line 325
  long_opts[3].name = "create-files";
#line 325
  long_opts[3].has_arg = 0;
#line 325
  long_opts[3].flag = (int *)((void *)0);
#line 325
  long_opts[3].val = 'c';
#line 325
  long_opts[4].name = "verbose";
#line 325
  long_opts[4].has_arg = 0;
#line 325
  long_opts[4].flag = (int *)((void *)0);
#line 325
  long_opts[4].val = 'v';
#line 325
  long_opts[5].name = "debug";
#line 325
  long_opts[5].has_arg = 0;
#line 325
  long_opts[5].flag = (int *)((void *)0);
#line 325
  long_opts[5].val = 'd';
#line 325
  long_opts[6].name = "user";
#line 325
  long_opts[6].has_arg = 0;
#line 325
  long_opts[6].flag = (int *)((void *)0);
#line 325
  long_opts[6].val = 'u';
#line 325
  long_opts[7].name = "group";
#line 325
  long_opts[7].has_arg = 0;
#line 325
  long_opts[7].flag = (int *)((void *)0);
#line 325
  long_opts[7].val = 'g';
#line 325
  long_opts[8].name = "interactive";
#line 325
  long_opts[8].has_arg = 0;
#line 325
  long_opts[8].flag = (int *)((void *)0);
#line 325
  long_opts[8].val = 'i';
#line 325
  long_opts[9].name = "use-first-dquot";
#line 325
  long_opts[9].has_arg = 0;
#line 325
  long_opts[9].flag = (int *)((void *)0);
#line 325
  long_opts[9].val = 'n';
#line 325
  long_opts[10].name = "force";
#line 325
  long_opts[10].has_arg = 0;
#line 325
  long_opts[10].flag = (int *)((void *)0);
#line 325
  long_opts[10].val = 'f';
#line 325
  long_opts[11].name = "format";
#line 325
  long_opts[11].has_arg = 1;
#line 325
  long_opts[11].flag = (int *)((void *)0);
#line 325
  long_opts[11].val = 'F';
#line 325
  long_opts[12].name = "no-remount";
#line 325
  long_opts[12].has_arg = 0;
#line 325
  long_opts[12].flag = (int *)((void *)0);
#line 325
  long_opts[12].val = 'm';
#line 325
  long_opts[13].name = "try-remount";
#line 325
  long_opts[13].has_arg = 0;
#line 325
  long_opts[13].flag = (int *)((void *)0);
#line 325
  long_opts[13].val = 'M';
#line 325
  long_opts[14].name = "exclude-root";
#line 325
  long_opts[14].has_arg = 0;
#line 325
  long_opts[14].flag = (int *)((void *)0);
#line 325
  long_opts[14].val = 'R';
#line 325
  long_opts[15].name = "all";
#line 325
  long_opts[15].has_arg = 0;
#line 325
  long_opts[15].flag = (int *)((void *)0);
#line 325
  long_opts[15].val = 'a';
#line 325
  long_opts[16].name = (char const   *)((void *)0);
#line 325
  long_opts[16].has_arg = 0;
#line 325
  long_opts[16].flag = (int *)((void *)0);
#line 325
  long_opts[16].val = 0;
  {
#line 345
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 345
    ret = getopt_long(argcnt, (char * const  *)argstr, "VhbcvugidnfF:mMRa", (struct option  const  *)(long_opts),
                      (int *)((void *)0));
    }
#line 345
    if (! (ret != -1)) {
#line 345
      goto while_break;
    }
    {
#line 347
    if (ret == 98) {
#line 347
      goto case_98;
    }
#line 350
    if (ret == 103) {
#line 350
      goto case_103;
    }
#line 353
    if (ret == 117) {
#line 353
      goto case_117;
    }
#line 356
    if (ret == 100) {
#line 356
      goto case_100;
    }
#line 360
    if (ret == 118) {
#line 360
      goto case_118;
    }
#line 366
    if (ret == 102) {
#line 366
      goto case_102;
    }
#line 369
    if (ret == 105) {
#line 369
      goto case_105;
    }
#line 372
    if (ret == 110) {
#line 372
      goto case_110;
    }
#line 375
    if (ret == 99) {
#line 375
      goto case_99;
    }
#line 378
    if (ret == 86) {
#line 378
      goto case_86;
    }
#line 381
    if (ret == 77) {
#line 381
      goto case_77;
    }
#line 384
    if (ret == 109) {
#line 384
      goto case_109;
    }
#line 387
    if (ret == 97) {
#line 387
      goto case_97;
    }
#line 390
    if (ret == 82) {
#line 390
      goto case_82;
    }
#line 393
    if (ret == 70) {
#line 393
      goto case_70;
    }
#line 397
    goto switch_default;
    case_98: /* CIL Label */ 
#line 348
    flags |= 1024;
#line 349
    goto switch_break;
    case_103: /* CIL Label */ 
#line 351
    gwant = 1;
#line 352
    goto switch_break;
    case_117: /* CIL Label */ 
#line 354
    uwant = 1;
#line 355
    goto switch_break;
    case_100: /* CIL Label */ 
    {
#line 357
    flags |= 4;
#line 358
    setlinebuf(stderr);
    }
#line 359
    goto switch_break;
    case_118: /* CIL Label */ 
#line 361
    if (flags & 2) {
#line 362
      flags |= 2048;
    } else {
#line 364
      flags |= 2;
    }
#line 365
    goto switch_break;
    case_102: /* CIL Label */ 
#line 367
    flags |= 1;
#line 368
    goto switch_break;
    case_105: /* CIL Label */ 
#line 370
    flags |= 8;
#line 371
    goto switch_break;
    case_110: /* CIL Label */ 
#line 373
    flags |= 16;
#line 374
    goto switch_break;
    case_99: /* CIL Label */ 
#line 376
    flags |= 32;
#line 377
    goto switch_break;
    case_86: /* CIL Label */ 
    {
#line 379
    version();
#line 380
    exit(0);
    }
    case_77: /* CIL Label */ 
#line 382
    flags |= 64;
#line 383
    goto switch_break;
    case_109: /* CIL Label */ 
#line 385
    flags |= 128;
#line 386
    goto switch_break;
    case_97: /* CIL Label */ 
#line 388
    flags |= 256;
#line 389
    goto switch_break;
    case_82: /* CIL Label */ 
#line 391
    flags |= 512;
#line 392
    goto switch_break;
    case_70: /* CIL Label */ 
    {
#line 394
    fmt = name2fmt(optarg);
    }
#line 394
    if (fmt == -1) {
      {
#line 395
      exit(1);
      }
    }
#line 396
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 398
    usage___5();
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 401
  if (! (uwant | gwant)) {
#line 402
    uwant = 1;
  }
#line 403
  if (argcnt == optind) {
#line 403
    if (! (flags & 256)) {
      {
#line 404
      tmp = gettext("Bad number of arguments.\n");
#line 404
      fputs((char const   */* __restrict  */)tmp, (FILE */* __restrict  */)stderr);
#line 405
      usage___5();
      }
    } else {
#line 403
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 403
  if (argcnt > optind) {
#line 403
    if (flags & 256) {
      {
#line 404
      tmp = gettext("Bad number of arguments.\n");
#line 404
      fputs((char const   */* __restrict  */)tmp, (FILE */* __restrict  */)stderr);
#line 405
      usage___5();
      }
    }
  }
#line 407
  if (flags & 2) {
#line 407
    if (flags & 4) {
#line 408
      flags &= -3;
    }
  }
#line 409
  if (! (flags & 256)) {
#line 410
    mntpoint = *(argstr + optind);
  } else {
#line 412
    mntpoint = (char *)((void *)0);
  }
#line 413
  return;
}
}
#line 493 "/home/wheatley/newnew/temp/quota-4.01/quotacheck.c"
static int scan_dir(char const   *pathname ) 
{ 
  struct dirs *dir_stack ;
  struct dirs *new_dir ;
  struct dirent *de ;
  struct stat st ;
  loff_t qspace ;
  DIR *dp ;
  int ret ;
  int *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  int tmp___11 ;
  char *tmp___12 ;
  void *tmp___13 ;
  size_t tmp___14 ;
  size_t tmp___15 ;
  void *tmp___16 ;
  char *tmp___17 ;
  char *tmp___18 ;
  char *tmp___19 ;
  char *tmp___20 ;

  {
  {
#line 495
  dir_stack = (struct dirs *)((void *)0);
#line 503
  tmp___2 = lstat((char const   */* __restrict  */)pathname, (struct stat */* __restrict  */)(& st));
  }
#line 503
  if (tmp___2 == -1) {
    {
#line 504
    tmp = __errno_location();
#line 504
    tmp___0 = strerror(*tmp);
#line 504
    tmp___1 = gettext("Cannot stat directory %s: %s\n");
#line 504
    errstr(tmp___1, pathname, tmp___0);
    }
#line 505
    goto out;
  }
  {
#line 507
  qspace = getqsize(pathname, & st);
  }
#line 508
  if (ucheck) {
    {
#line 509
    add_to_quota(0, st.st_ino, st.st_uid, st.st_gid, st.st_mode, st.st_nlink, qspace,
                 0);
    }
  }
#line 511
  if (gcheck) {
    {
#line 512
    add_to_quota(1, st.st_ino, st.st_uid, st.st_gid, st.st_mode, st.st_nlink, qspace,
                 0);
    }
  }
  {
#line 515
  dp = opendir(pathname);
  }
#line 515
  if ((unsigned long )dp == (unsigned long )((DIR *)((void *)0))) {
    {
#line 516
    tmp___3 = __errno_location();
#line 516
    tmp___4 = strerror(*tmp___3);
#line 516
    tmp___5 = gettext("\nCan open directory %s: %s\n");
#line 516
    die(2, tmp___5, pathname, tmp___4);
    }
  }
  {
#line 518
  chdir(pathname);
  }
#line 519
  if (flags & 2048) {
    {
#line 520
    blit(pathname);
    }
  }
  {
#line 521
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 521
    de = readdir(dp);
    }
#line 521
    if (! ((unsigned long )de != (unsigned long )((struct dirent *)((void *)0)))) {
#line 521
      goto while_break;
    }
    {
#line 522
    tmp___6 = strcmp((char const   *)(de->d_name), ".");
    }
#line 522
    if (tmp___6) {
      {
#line 522
      tmp___7 = strcmp((char const   *)(de->d_name), "..");
      }
#line 522
      if (! tmp___7) {
#line 523
        goto while_continue;
      }
    } else {
#line 523
      goto while_continue;
    }
#line 524
    if (flags & 2) {
      {
#line 525
      blit((char const   *)((void *)0));
      }
    }
    {
#line 527
    tmp___11 = lstat((char const   */* __restrict  */)(de->d_name), (struct stat */* __restrict  */)(& st));
    }
#line 527
    if (tmp___11 == -1) {
      {
#line 528
      tmp___8 = __errno_location();
#line 528
      tmp___9 = strerror(*tmp___8);
#line 528
      tmp___10 = gettext("lstat: Cannot stat `%s/%s\': %s\nGuess you\'d better run fsck first !\nexiting...\n");
#line 528
      errstr(tmp___10, pathname, de->d_name, tmp___9);
      }
#line 530
      goto out;
    }
#line 533
    if ((st.st_mode & 61440U) == 16384U) {
#line 534
      if (st.st_dev != cur_dev) {
#line 535
        goto while_continue;
      }
      {
#line 539
      tmp___12 = gettext("pushd %s/%s\n");
#line 539
      debug(4, tmp___12, pathname, de->d_name);
#line 540
      tmp___13 = xmalloc(sizeof(struct dirs ));
#line 540
      new_dir = (struct dirs *)tmp___13;
#line 542
      tmp___14 = strlen(pathname);
#line 542
      tmp___15 = strlen((char const   *)(de->d_name));
#line 542
      tmp___16 = xmalloc((tmp___14 + tmp___15) + 2UL);
#line 542
      new_dir->dir_name = (char *)tmp___16;
#line 543
      sprintf((char */* __restrict  */)new_dir->dir_name, (char const   */* __restrict  */)"%s/%s",
              pathname, de->d_name);
#line 544
      new_dir->next = dir_stack;
#line 545
      dir_stack = new_dir;
      }
    } else {
      {
#line 548
      qspace = getqsize((char const   *)(de->d_name), & st);
      }
#line 549
      if (ucheck) {
        {
#line 550
        add_to_quota(0, st.st_ino, st.st_uid, st.st_gid, st.st_mode, st.st_nlink,
                     qspace, 1);
        }
      }
#line 552
      if (gcheck) {
        {
#line 553
        add_to_quota(1, st.st_ino, st.st_uid, st.st_gid, st.st_mode, st.st_nlink,
                     qspace, 1);
        }
      }
      {
#line 555
      tmp___17 = gettext("\tAdding %s size %lld ino %d links %d uid %u gid %u\n");
#line 555
      debug(4, tmp___17, de->d_name, (long long )st.st_size, (int )st.st_ino, (int )st.st_nlink,
            (int )st.st_uid, (int )st.st_gid);
#line 557
      files_done ++;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 560
  closedir(dp);
#line 565
  tmp___18 = gettext("Scanning stored directories from directory stack\n");
#line 565
  debug(4, tmp___18);
  }
  {
#line 566
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 566
    if (! ((unsigned long )dir_stack != (unsigned long )((struct dirs *)((void *)0)))) {
#line 566
      goto while_break___0;
    }
    {
#line 567
    new_dir = dir_stack;
#line 568
    dir_stack = dir_stack->next;
#line 569
    tmp___19 = gettext("popd %s\nEntering directory %s\n");
#line 569
    debug(4, tmp___19, new_dir->dir_name, new_dir->dir_name);
#line 571
    ret = scan_dir((char const   *)new_dir->dir_name);
#line 572
    dirs_done ++;
#line 576
    free((void *)new_dir->dir_name);
#line 577
    free((void *)new_dir);
    }
#line 578
    if (ret < 0) {
#line 579
      goto out;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 581
  tmp___20 = gettext("Leaving %s\n");
#line 581
  debug(4, tmp___20, pathname);
  }
#line 582
  return (0);
  out: 
#line 584
  new_dir = dir_stack;
  {
#line 584
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 584
    if (! new_dir) {
#line 584
      goto while_break___1;
    }
    {
#line 585
    dir_stack = dir_stack->next;
#line 589
    free((void *)new_dir->dir_name);
#line 590
    free((void *)new_dir);
#line 584
    new_dir = dir_stack;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 592
  return (-1);
}
}
#line 596 "/home/wheatley/newnew/temp/quota-4.01/quotacheck.c"
int ask_yn(char *q , int def ) 
{ 
  char a[10] ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 600
  if (def) {
#line 600
    tmp = 'y';
  } else {
#line 600
    tmp = 'n';
  }
  {
#line 600
  printf((char const   */* __restrict  */)"%s [%c]: ", q, tmp);
#line 601
  fflush(stdout);
  }
  {
#line 602
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 603
    fgets((char */* __restrict  */)(a), (int )(sizeof(a) - 1UL), (FILE */* __restrict  */)stdin);
    }
#line 604
    if ((int )a[0] == 10) {
#line 605
      return (def);
    }
    {
#line 606
    tmp___0 = strcasecmp((char const   *)(a), "y\n");
    }
#line 606
    if (! tmp___0) {
#line 607
      return (1);
    }
    {
#line 608
    tmp___1 = strcasecmp((char const   *)(a), "n\n");
    }
#line 608
    if (! tmp___1) {
#line 609
      return (0);
    }
    {
#line 610
    printf((char const   */* __restrict  */)"Illegal answer. Please answer y/n: ");
#line 611
    fflush(stdout);
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 616 "/home/wheatley/newnew/temp/quota-4.01/quotacheck.c"
static int process_file(struct mount_entry *mnt___2 , int type ) 
{ 
  char *qfname ;
  int fd ;
  int ret ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  int *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  int tmp___13 ;
  long tmp___14 ;
  int tmp___15 ;
  char *tmp___16 ;
  int tmp___17 ;
  int *tmp___18 ;
  char *tmp___19 ;
  char *tmp___20 ;
  int *tmp___21 ;
  int tmp___22 ;

  {
  {
#line 618
  qfname = (char *)((void *)0);
#line 619
  fd = -1;
#line 621
  tmp = type2name(type);
#line 621
  tmp___0 = gettext((char const   *)tmp);
#line 621
  tmp___1 = gettext("Going to check %s quota file of %s\n");
#line 621
  debug(4, tmp___1, tmp___0, mnt___2->me_dir);
#line 624
  tmp___15 = kern_quota_on(mnt___2, type, cfmt);
  }
#line 624
  if (tmp___15 >= 0) {
#line 625
    if (! (flags & 1)) {
#line 626
      if (flags & 8) {
        {
#line 627
        tmp___2 = type2name(type);
#line 627
        tmp___3 = gettext((char const   *)tmp___2);
#line 627
        tmp___4 = gettext("Quota for %ss is enabled on mountpoint %s so quotacheck might damage the file.\n");
#line 627
        printf((char const   */* __restrict  */)tmp___4, tmp___3, mnt___2->me_dir);
#line 628
        tmp___6 = gettext("Should I continue?");
#line 628
        tmp___7 = ask_yn(tmp___6, 0);
        }
#line 628
        if (! tmp___7) {
          {
#line 629
          tmp___5 = gettext("As you wish... Canceling check of this file.\n");
#line 629
          printf((char const   */* __restrict  */)tmp___5);
          }
#line 630
          return (-1);
        }
      } else {
        {
#line 634
        tmp___8 = type2name(type);
#line 634
        tmp___9 = gettext("Quota for %ss is enabled on mountpoint %s so quotacheck might damage the file.\nPlease turn quotas off or use -f to force checking.\n");
#line 634
        die(6, tmp___9, tmp___8, mnt___2->me_dir);
        }
      }
    }
#line 639
    if (kernel_iface == 3) {
#line 639
      tmp___13 = 8388609;
    } else {
#line 639
      tmp___13 = 1536;
    }
    {
#line 639
    tmp___14 = quotactl((tmp___13 << 8) | (type & 255), mnt___2->me_devname, (qid_t )0,
                        (caddr_t )((void *)0));
    }
#line 639
    if (tmp___14 < 0L) {
      {
#line 641
      tmp___10 = __errno_location();
#line 641
      tmp___11 = strerror(*tmp___10);
#line 641
      tmp___12 = gettext("Error while syncing quotas on %s: %s\n");
#line 641
      die(4, tmp___12, mnt___2->me_devname, tmp___11);
      }
    }
  }
#line 644
  if (! (flags & 32)) {
    {
#line 645
    tmp___17 = get_qf_name(mnt___2, type, cfmt, 0, & qfname);
    }
#line 645
    if (tmp___17 < 0) {
      {
#line 646
      tmp___16 = gettext("Cannot get quotafile name for %s\n");
#line 646
      errstr(tmp___16, mnt___2->me_devname);
      }
#line 647
      return (-1);
    }
    {
#line 649
    fd = open((char const   *)qfname, 0);
    }
#line 649
    if (fd < 0) {
      {
#line 650
      tmp___21 = __errno_location();
      }
#line 650
      if (*tmp___21 != 2) {
        {
#line 651
        tmp___18 = __errno_location();
#line 651
        tmp___19 = strerror(*tmp___18);
#line 651
        tmp___20 = gettext("Cannot open quotafile %s: %s\n");
#line 651
        errstr(tmp___20, qfname, tmp___19);
#line 653
        free((void *)qfname);
        }
#line 654
        return (-1);
      }
      {
#line 657
      flags |= 32;
#line 658
      free((void *)qfname);
#line 659
      qfname = (char *)((void *)0);
      }
    }
  }
  {
#line 663
  ret = 0;
#line 664
  memset((void *)(old_info + type), 0, sizeof(old_info[type]));
#line 665
  tmp___22 = is_tree_qfmt(cfmt);
  }
#line 665
  if (tmp___22) {
    {
#line 666
    ret = v2_buffer_file(qfname, fd, type, cfmt);
    }
  } else {
    {
#line 668
    ret = v1_buffer_file(qfname, fd, type);
    }
  }
#line 670
  if (! (flags & 32)) {
    {
#line 671
    free((void *)qfname);
#line 672
    close(fd);
    }
  }
#line 674
  return (ret);
}
}
#line 678 "/home/wheatley/newnew/temp/quota-4.01/quotacheck.c"
static int rename_files(struct mount_entry *mnt___2 , int type ) 
{ 
  char *filename ;
  char newfilename[4096] ;
  struct stat st ;
  mode_t mode ;
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  size_t tmp___10 ;
  int *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  int tmp___14 ;
  char *tmp___15 ;
  int *tmp___16 ;
  char *tmp___17 ;
  char *tmp___18 ;
  int tmp___19 ;
  int *tmp___20 ;
  char *tmp___21 ;
  char *tmp___22 ;
  int tmp___23 ;

  {
#line 682
  mode = (mode_t )384;
#line 688
  if (cfmt == 4) {
#line 689
    return (0);
  }
  {
#line 691
  tmp = gettext("Renaming new files to proper names.\n");
#line 691
  debug(4, tmp);
#line 692
  tmp___1 = get_qf_name(mnt___2, type, cfmt, 0, & filename);
  }
#line 692
  if (tmp___1 < 0) {
    {
#line 693
    tmp___0 = gettext("Cannot get name of old quotafile on %s.\n");
#line 693
    die(2, tmp___0, mnt___2->me_dir);
    }
  }
  {
#line 694
  tmp___7 = stat((char const   */* __restrict  */)filename, (struct stat */* __restrict  */)(& st));
  }
#line 694
  if (tmp___7 < 0) {
    {
#line 695
    tmp___3 = __errno_location();
    }
#line 695
    if (*tmp___3 == 2) {
      {
#line 696
      tmp___2 = gettext("Old file not found.\n");
#line 696
      debug(6, tmp___2);
      }
#line 697
      goto rename_new;
    }
    {
#line 699
    tmp___4 = __errno_location();
#line 699
    tmp___5 = strerror(*tmp___4);
#line 699
    tmp___6 = gettext("Error while searching for old quota file %s: %s\n");
#line 699
    errstr(tmp___6, filename, tmp___5);
#line 701
    free((void *)filename);
    }
#line 702
    return (-1);
  }
#line 704
  mode = st.st_mode & (unsigned int )((448 | (448 >> 3)) | ((448 >> 3) >> 3));
#line 732
  if (flags & 1024) {
    {
#line 733
    tmp___8 = gettext("Renaming old quotafile to %s~\n");
#line 733
    debug(4, tmp___8, filename);
#line 735
    strcpy((char */* __restrict  */)(newfilename), (char const   */* __restrict  */)filename);
#line 737
    sstrncat(newfilename, "~", (size_t )4096);
#line 738
    tmp___10 = strlen((char const   *)(newfilename));
    }
#line 738
    if ((int )newfilename[tmp___10 - 1UL] != 126) {
      {
#line 739
      tmp___9 = gettext("Name of quota file too long. Contact %s.\n");
#line 739
      die(8, tmp___9, "jack@suse.cz");
      }
    }
    {
#line 740
    tmp___14 = rename((char const   *)filename, (char const   *)(newfilename));
    }
#line 740
    if (tmp___14 < 0) {
      {
#line 741
      tmp___11 = __errno_location();
#line 741
      tmp___12 = strerror(*tmp___11);
#line 741
      tmp___13 = gettext("Cannot rename old quotafile %s to %s: %s\n");
#line 741
      errstr(tmp___13, filename, newfilename, tmp___12);
#line 743
      free((void *)filename);
      }
#line 744
      return (-1);
    }
  }
  {
#line 747
  tmp___15 = gettext("Renaming new quotafile\n");
#line 747
  debug(4, tmp___15);
  }
  rename_new: 
  {
#line 750
  strcpy((char */* __restrict  */)(newfilename), (char const   */* __restrict  */)filename);
#line 751
  sstrncat(newfilename, ".new", (size_t )4096);
#line 752
  tmp___19 = rename((char const   *)(newfilename), (char const   *)filename);
  }
#line 752
  if (tmp___19 < 0) {
    {
#line 753
    tmp___16 = __errno_location();
#line 753
    tmp___17 = strerror(*tmp___16);
#line 753
    tmp___18 = gettext("Cannot rename new quotafile %s to name %s: %s\n");
#line 753
    errstr(tmp___18, newfilename, filename, tmp___17);
#line 755
    free((void *)filename);
    }
#line 756
    return (-1);
  }
  {
#line 758
  tmp___23 = chmod((char const   *)filename, mode);
  }
#line 758
  if (tmp___23 < 0) {
    {
#line 759
    tmp___20 = __errno_location();
#line 759
    tmp___21 = strerror(*tmp___20);
#line 759
    tmp___22 = gettext("Cannot change permission of %s: %s\n");
#line 759
    errstr(tmp___22, filename, tmp___21);
#line 760
    free((void *)filename);
    }
#line 761
    return (-1);
  }
  {
#line 775
  free((void *)filename);
  }
#line 776
  return (0);
}
}
#line 784 "/home/wheatley/newnew/temp/quota-4.01/quotacheck.c"
static int dump_to_file(struct mount_entry *mnt___2 , int type ) 
{ 
  struct dquot *dquot ;
  uint i ;
  struct quota_handle *h ;
  unsigned int commit ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  int *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;
  int *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  int tmp___12 ;
  char *tmp___13 ;
  char *filename ;
  char *tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  int *tmp___17 ;
  char *tmp___18 ;
  char *tmp___19 ;
  char *tmp___20 ;
  char *tmp___21 ;
  int ret ;
  int tmp___22 ;
  long tmp___23 ;
  long tmp___24 ;
  int *tmp___25 ;
  char *tmp___26 ;
  char *tmp___27 ;
  char *tmp___28 ;
  char *tmp___29 ;
  int tmp___30 ;
  long tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;

  {
  {
#line 789
  commit = 0U;
#line 791
  tmp = type2name(type);
#line 791
  tmp___0 = gettext((char const   *)tmp);
#line 791
  tmp___1 = gettext("Dumping gathered data for %ss.\n");
#line 791
  debug(4, tmp___1, tmp___0);
  }
#line 792
  if (cfmt == 4) {
    {
#line 793
    h = init_io(mnt___2, type, cfmt, 1);
    }
#line 793
    if (! h) {
      {
#line 794
      tmp___2 = __errno_location();
#line 794
      tmp___3 = strerror(*tmp___2);
#line 794
      tmp___4 = gettext("Cannot initialize IO on xfs/gfs2 quotafile: %s\n");
#line 794
      errstr(tmp___4, tmp___3);
      }
#line 796
      return (-1);
    }
  } else {
    {
#line 799
    h = new_io(mnt___2, type, cfmt);
    }
#line 799
    if (! h) {
      {
#line 800
      tmp___5 = __errno_location();
#line 800
      tmp___6 = strerror(*tmp___5);
#line 800
      tmp___7 = gettext("Cannot initialize IO on new quotafile: %s\n");
#line 800
      errstr(tmp___7, tmp___6);
      }
#line 802
      return (-1);
    }
#line 804
    if (! (flags & 32)) {
      {
#line 805
      h->qh_info.dqi_bgrace = old_info[type].dqi_bgrace;
#line 806
      h->qh_info.dqi_igrace = old_info[type].dqi_igrace;
#line 807
      tmp___8 = is_tree_qfmt(cfmt);
      }
#line 807
      if (tmp___8) {
        {
#line 808
        v2_merge_info(& h->qh_info, old_info + type);
        }
      }
      {
#line 809
      mark_quotafile_info_dirty(h);
      }
    }
  }
#line 812
  i = (uint )0;
  {
#line 812
  while (1) {
    while_continue: /* CIL Label */ ;
#line 812
    if (! (i < 32768U)) {
#line 812
      goto while_break;
    }
#line 813
    dquot = dquot_hash[type][i];
    {
#line 813
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 813
      if (! dquot) {
#line 813
        goto while_break___0;
      }
#line 814
      dquot->dq_h = h;
#line 822
      if (cfmt == 4) {
#line 822
        commit = 10U;
      } else {
#line 822
        commit = 63U;
      }
      {
#line 823
      update_grace_times(dquot);
#line 824
      (*((h->qh_ops)->commit_dquot))(dquot, (int )commit);
#line 813
      dquot = dquot->dq_next;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 812
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 826
  tmp___12 = end_io(h);
  }
#line 826
  if (tmp___12 < 0) {
    {
#line 827
    tmp___9 = __errno_location();
#line 827
    tmp___10 = strerror(*tmp___9);
#line 827
    tmp___11 = gettext("Cannot finish IO on new quotafile: %s\n");
#line 827
    errstr(tmp___11, tmp___10);
    }
#line 828
    return (-1);
  }
  {
#line 830
  tmp___13 = gettext("Data dumped.\n");
#line 830
  debug(4, tmp___13);
#line 831
  tmp___34 = kern_quota_on(mnt___2, type, cfmt);
  }
#line 831
  if (tmp___34 >= 0) {
    {
#line 834
    tmp___32 = get_qf_name(mnt___2, type, cfmt, 2, & filename);
    }
#line 834
    if (tmp___32 < 0) {
      {
#line 835
      tmp___14 = type2name(type);
#line 835
      tmp___15 = gettext((char const   *)tmp___14);
#line 835
      tmp___16 = gettext("Cannot find checked quota file for %ss on %s!\n");
#line 835
      errstr(tmp___16, tmp___15, mnt___2->me_devname);
      }
    } else {
#line 837
      if (kernel_iface == 3) {
#line 837
        tmp___30 = 8388611;
      } else {
#line 837
        tmp___30 = 512;
      }
      {
#line 837
      tmp___31 = quotactl((tmp___30 << 8) | (type & 255), mnt___2->me_devname, (qid_t )0,
                          (caddr_t )((void *)0));
      }
#line 837
      if (tmp___31 < 0L) {
        {
#line 839
        tmp___17 = __errno_location();
#line 839
        tmp___18 = strerror(*tmp___17);
#line 839
        tmp___19 = type2name(type);
#line 839
        tmp___20 = gettext((char const   *)tmp___19);
#line 839
        tmp___21 = gettext("Cannot turn %s quotas off on %s: %s\nKernel won\'t know about changes quotacheck did.\n");
#line 839
        errstr(tmp___21, tmp___20, mnt___2->me_devname, tmp___18);
        }
      } else {
        {
#line 845
        rename_files(mnt___2, type);
        }
#line 847
        if (kernel_iface == 3) {
          {
#line 848
          tmp___22 = util2kernfmt(cfmt);
#line 848
          tmp___23 = quotactl((8388610 << 8) | (type & 255), mnt___2->me_devname,
                              (qid_t )tmp___22, filename);
#line 848
          ret = (int )tmp___23;
          }
        } else {
          {
#line 850
          tmp___24 = quotactl((256 << 8) | (type & 255), mnt___2->me_devname, (qid_t )0,
                              filename);
#line 850
          ret = (int )tmp___24;
          }
        }
#line 851
        if (ret < 0) {
          {
#line 852
          tmp___25 = __errno_location();
#line 852
          tmp___26 = strerror(*tmp___25);
#line 852
          tmp___27 = type2name(type);
#line 852
          tmp___28 = gettext((char const   *)tmp___27);
#line 852
          tmp___29 = gettext("Cannot turn %s quotas on on %s: %s\nKernel won\'t know about changes quotacheck did.\n");
#line 852
          errstr(tmp___29, tmp___28, mnt___2->me_devname, tmp___26);
          }
        }
      }
      {
#line 855
      free((void *)filename);
      }
    }
  } else {
    {
#line 859
    tmp___33 = rename_files(mnt___2, type);
    }
#line 859
    if (tmp___33 < 0) {
#line 860
      return (-1);
    }
  }
#line 861
  return (0);
}
}
#line 866 "/home/wheatley/newnew/temp/quota-4.01/quotacheck.c"
static int sub_quota_file(struct mount_entry *mnt___2 , int qtype , int ftype ) 
{ 
  char *filename ;
  struct stat st ;
  loff_t qspace ;
  struct dquot *d ;
  qid_t id___0 ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  int *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  int tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;

  {
  {
#line 874
  tmp = type2name(ftype);
#line 874
  tmp___0 = gettext((char const   *)tmp);
#line 874
  tmp___1 = gettext("Substracting space used by old %s quota file.\n");
#line 874
  debug(4, tmp___1, tmp___0);
#line 875
  tmp___5 = get_qf_name(mnt___2, ftype, cfmt, 0, & filename);
  }
#line 875
  if (tmp___5 < 0) {
    {
#line 876
    tmp___2 = type2name(ftype);
#line 876
    tmp___3 = gettext((char const   *)tmp___2);
#line 876
    tmp___4 = gettext("Old %s file name could not been determined. Usage will not be subtracted.\n");
#line 876
    debug(2, tmp___4, tmp___3);
    }
#line 877
    return (0);
  }
  {
#line 880
  tmp___11 = stat((char const   */* __restrict  */)filename, (struct stat */* __restrict  */)(& st));
  }
#line 880
  if (tmp___11 < 0) {
    {
#line 881
    tmp___6 = __errno_location();
#line 881
    tmp___7 = strerror(*tmp___6);
#line 881
    tmp___8 = type2name(ftype);
#line 881
    tmp___9 = gettext((char const   *)tmp___8);
#line 881
    tmp___10 = gettext("Cannot stat old %s quota file %s: %s. Usage will not be subtracted.\n");
#line 881
    debug(2, tmp___10, tmp___9, filename, tmp___7);
#line 882
    free((void *)filename);
    }
#line 883
    return (0);
  }
  {
#line 885
  qspace = getqsize((char const   *)filename, & st);
#line 886
  free((void *)filename);
  }
#line 888
  if (qtype == 0) {
#line 889
    id___0 = st.st_uid;
  } else {
#line 891
    id___0 = st.st_gid;
  }
  {
#line 892
  d = lookup_dquot(id___0, qtype);
  }
#line 892
  if ((unsigned long )d == (unsigned long )((struct dquot *)((void *)0))) {
    {
#line 893
    tmp___12 = type2name(qtype);
#line 893
    tmp___13 = gettext((char const   *)tmp___12);
#line 893
    tmp___14 = gettext("Quota structure for %s owning quota file not present! Something is really wrong...\n");
#line 893
    errstr(tmp___14, tmp___13);
    }
#line 894
    return (-1);
  }
  {
#line 896
  (d->dq_dqb.dqb_curinodes) --;
#line 897
  d->dq_dqb.dqb_curspace -= qspace;
#line 898
  tmp___15 = gettext("Substracted %lu bytes.\n");
#line 898
  debug(4, tmp___15, (unsigned long )qspace);
  }
#line 899
  return (0);
}
}
#line 904 "/home/wheatley/newnew/temp/quota-4.01/quotacheck.c"
static int check_dir(struct mount_entry *mnt___2 ) 
{ 
  struct stat st ;
  int remounted ;
  int failed ;
  int *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  int tmp___9 ;
  char *tmp___10 ;
  int tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  char *tmp___19 ;
  char *tmp___20 ;
  int tmp___21 ;
  char *tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;

  {
  {
#line 907
  remounted = 0;
#line 908
  failed = 0;
#line 910
  tmp___2 = lstat((char const   */* __restrict  */)mnt___2->me_dir, (struct stat */* __restrict  */)(& st));
  }
#line 910
  if (tmp___2 < 0) {
    {
#line 911
    tmp = __errno_location();
#line 911
    tmp___0 = strerror(*tmp);
#line 911
    tmp___1 = gettext("Cannot stat mountpoint %s: %s\n");
#line 911
    die(2, tmp___1, mnt___2->me_dir, tmp___0);
    }
  }
#line 912
  if (! ((st.st_mode & 61440U) == 16384U)) {
    {
#line 913
    tmp___3 = gettext("Mountpoint %s is not a directory?!\n");
#line 913
    die(2, tmp___3, mnt___2->me_dir);
    }
  }
#line 914
  cur_dev = st.st_dev;
#line 915
  dirs_done = 0;
#line 915
  files_done = dirs_done;
#line 922
  if (cfmt == 4) {
#line 923
    goto start_scan;
  }
#line 924
  if (ucheck) {
    {
#line 925
    tmp___4 = process_file(mnt___2, 0);
    }
#line 925
    if (tmp___4 < 0) {
#line 926
      ucheck = 0;
    }
  }
#line 927
  if (gcheck) {
    {
#line 928
    tmp___5 = process_file(mnt___2, 1);
    }
#line 928
    if (tmp___5 < 0) {
#line 929
      gcheck = 0;
    }
  }
#line 930
  if (! ucheck) {
#line 930
    if (! gcheck) {
#line 931
      return (0);
    }
  }
#line 932
  if (! (flags & 128)) {
    {
#line 934
    tmp___11 = mount((char const   *)((void *)0), mnt___2->me_dir, (char const   *)mnt___2->me_type,
                     3236757537UL, (void const   *)((void *)0));
    }
#line 934
    if (tmp___11 < 0) {
#line 934
      if (! (flags & 64)) {
#line 937
        if (flags & 8) {
          {
#line 938
          tmp___6 = gettext("Cannot remount filesystem mounted on %s read-only. Counted values might not be right.\n");
#line 938
          printf((char const   */* __restrict  */)tmp___6, mnt___2->me_dir);
#line 939
          tmp___8 = gettext("Should I continue?");
#line 939
          tmp___9 = ask_yn(tmp___8, 0);
          }
#line 939
          if (! tmp___9) {
            {
#line 940
            tmp___7 = gettext("As you wish... Canceling check of this file.\n");
#line 940
            printf((char const   */* __restrict  */)tmp___7);
#line 941
            failed = -1;
            }
#line 942
            goto out;
          }
        } else {
          {
#line 946
          tmp___10 = gettext("Cannot remount filesystem mounted on %s read-only so counted values might not be right.\nPlease stop all programs writing to filesystem or use -m flag to force checking.\n");
#line 946
          errstr(tmp___10, mnt___2->me_dir);
#line 948
          failed = -1;
          }
#line 949
          goto out;
        }
      } else {
#line 953
        remounted = 1;
      }
    } else {
#line 953
      remounted = 1;
    }
    {
#line 954
    tmp___12 = gettext("Filesystem remounted read-only\n");
#line 954
    debug(4, tmp___12);
    }
  }
  start_scan: 
  {
#line 957
  tmp___13 = gettext("Scanning %s [%s] ");
#line 957
  debug(2, tmp___13, mnt___2->me_devname, mnt___2->me_dir);
  }
#line 965
  if (mnt___2->me_dir) {
#line 967
    if (flags & 2048) {
      {
#line 968
      putchar('\n');
      }
    }
    {
#line 969
    failed = scan_dir(mnt___2->me_dir);
    }
#line 969
    if (failed < 0) {
#line 970
      goto out;
    }
  }
#line 972
  dirs_done ++;
#line 973
  if (flags & 2) {
    {
#line 974
    tmp___14 = gettext("done\n");
#line 974
    fputs((char const   */* __restrict  */)tmp___14, (FILE */* __restrict  */)stdout);
    }
  } else
#line 973
  if (flags & 2048) {
    {
#line 974
    tmp___14 = gettext("done\n");
#line 974
    fputs((char const   */* __restrict  */)tmp___14, (FILE */* __restrict  */)stdout);
    }
  }
#line 975
  if (ucheck) {
    {
#line 976
    tmp___15 = sub_quota_file(mnt___2, 0, 0);
#line 976
    failed |= tmp___15;
#line 977
    tmp___16 = sub_quota_file(mnt___2, 0, 1);
#line 977
    failed |= tmp___16;
    }
  }
#line 979
  if (gcheck) {
    {
#line 980
    tmp___17 = sub_quota_file(mnt___2, 1, 0);
#line 980
    failed |= tmp___17;
#line 981
    tmp___18 = sub_quota_file(mnt___2, 1, 1);
#line 981
    failed |= tmp___18;
    }
  }
  {
#line 983
  tmp___19 = gettext("Checked %d directories and %d files\n");
#line 983
  debug(6, tmp___19, dirs_done, files_done);
  }
#line 985
  if (remounted) {
    {
#line 986
    tmp___21 = mount((char const   *)((void *)0), mnt___2->me_dir, (char const   *)mnt___2->me_type,
                     3236757536UL, (void const   *)((void *)0));
    }
#line 986
    if (tmp___21 < 0) {
      {
#line 987
      tmp___20 = gettext("Cannot remount filesystem %s read-write. cannot write new quota files.\n");
#line 987
      die(4, tmp___20, mnt___2->me_dir);
      }
    }
    {
#line 988
    tmp___22 = gettext("Filesystem remounted RW.\n");
#line 988
    debug(4, tmp___22);
    }
  }
#line 990
  if (ucheck) {
    {
#line 991
    tmp___23 = dump_to_file(mnt___2, 0);
#line 991
    failed |= tmp___23;
    }
  }
#line 992
  if (gcheck) {
    {
#line 993
    tmp___24 = dump_to_file(mnt___2, 1);
#line 993
    failed |= tmp___24;
    }
  }
  out: 
  {
#line 995
  remove_list();
  }
#line 996
  return (failed);
}
}
#line 1000 "/home/wheatley/newnew/temp/quota-4.01/quotacheck.c"
static int detect_filename_format(struct mount_entry *mnt___2 , int type ) 
{ 
  char *option ;
  struct stat statbuf ;
  char namebuf[4096] ;
  int journal ;
  int fmt___7 ;
  int tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  char *tmp___6 ;
  char fmtbuf[64] ;
  char *space ;
  char *tmp___7 ;
  size_t tmp___8 ;
  size_t tmp___9 ;
  int fd ;
  int tmp___10 ;
  int tmp___11 ;
  int *tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;

  {
  {
#line 1005
  journal = 0;
#line 1008
  tmp = strcmp((char const   *)mnt___2->me_type, "xfs");
  }
#line 1008
  if (tmp == 0) {
#line 1010
    return (4);
  } else {
    {
#line 1008
    tmp___0 = strcmp((char const   *)mnt___2->me_type, "gfs2");
    }
#line 1008
    if (tmp___0 == 0) {
#line 1010
      return (4);
    }
  }
#line 1012
  if (type == 0) {
    {
#line 1013
    option = str_hasmntopt((char const   *)mnt___2->me_opts, "usrquota");
    }
#line 1013
    if (option) {
      {
#line 1014
      tmp___1 = strlen("usrquota");
#line 1014
      option += tmp___1;
      }
    } else {
      {
#line 1015
      option = str_hasmntopt((char const   *)mnt___2->me_opts, "usrjquota");
      }
#line 1015
      if (option) {
        {
#line 1016
        journal = 1;
#line 1017
        tmp___2 = strlen("usrjquota");
#line 1017
        option += tmp___2;
        }
      } else {
        {
#line 1019
        option = str_hasmntopt((char const   *)mnt___2->me_opts, "quota");
        }
#line 1019
        if (option) {
          {
#line 1020
          tmp___3 = strlen("quota");
#line 1020
          option += tmp___3;
          }
        }
      }
    }
  } else {
    {
#line 1023
    option = str_hasmntopt((char const   *)mnt___2->me_opts, "grpquota");
    }
#line 1023
    if (option) {
      {
#line 1024
      tmp___4 = strlen("grpquota");
#line 1024
      option += tmp___4;
      }
    } else {
      {
#line 1025
      option = str_hasmntopt((char const   *)mnt___2->me_opts, "grpjquota");
      }
#line 1025
      if (option) {
        {
#line 1026
        journal = 1;
#line 1027
        tmp___5 = strlen("grpjquota");
#line 1027
        option += tmp___5;
        }
      }
    }
  }
#line 1030
  if (! option) {
    {
#line 1031
    tmp___6 = gettext("Cannot find quota option on filesystem %s with quotas!\n");
#line 1031
    die(2, tmp___6, mnt___2->me_dir);
    }
  }
#line 1032
  if (journal) {
    {
#line 1035
    option = str_hasmntopt((char const   *)mnt___2->me_opts, "jqfmt");
    }
#line 1035
    if (! option) {
      jquota_err: 
      {
#line 1037
      tmp___7 = gettext("Cannot detect quota format for journalled quota on %s\n");
#line 1037
      errstr(tmp___7, mnt___2->me_dir);
      }
#line 1038
      return (-1);
    }
    {
#line 1040
    tmp___8 = strlen("jqfmt");
#line 1040
    option += tmp___8;
    }
#line 1041
    if ((int )*option != 61) {
#line 1042
      goto jquota_err;
    }
    {
#line 1043
    space = strchr((char const   *)option, ',');
    }
#line 1044
    if (! space) {
      {
#line 1045
      tmp___9 = strlen((char const   *)option);
#line 1045
      space = option + tmp___9;
      }
    }
#line 1046
    if ((unsigned long )(space - option) > sizeof(fmtbuf)) {
#line 1047
      goto jquota_err;
    }
    {
#line 1048
    sstrncpy(fmtbuf, (char const   *)(option + 1), (size_t )(space - option));
#line 1049
    fmt___7 = name2fmt(fmtbuf);
    }
#line 1050
    if (fmt___7 == -1) {
#line 1051
      goto jquota_err;
    }
#line 1052
    return (fmt___7);
  } else
#line 1054
  if ((int )*option == 61) {
#line 1055
    return (-1);
  }
  {
#line 1056
  snprintf((char */* __restrict  */)(namebuf), (size_t )4096, (char const   */* __restrict  */)"%s/%s.%s",
           mnt___2->me_dir, basenames___7[1], extensions___7[type]);
#line 1057
  tmp___11 = stat((char const   */* __restrict  */)(namebuf), (struct stat */* __restrict  */)(& statbuf));
  }
#line 1057
  if (! tmp___11) {
    {
#line 1058
    tmp___10 = open((char const   *)(namebuf), 0);
#line 1058
    fd = tmp___10;
    }
#line 1059
    if (fd < 0) {
#line 1060
      return (-1);
    }
    {
#line 1061
    fmt___7 = v2_detect_version(namebuf, fd, type);
#line 1062
    close(fd);
    }
#line 1063
    return (fmt___7);
  }
  {
#line 1066
  tmp___12 = __errno_location();
  }
#line 1066
  if (*tmp___12 != 2) {
#line 1067
    return (-1);
  }
  {
#line 1068
  snprintf((char */* __restrict  */)(namebuf), (size_t )4096, (char const   */* __restrict  */)"%s/%s.%s",
           mnt___2->me_dir, basenames___7[0], extensions___7[type]);
#line 1069
  tmp___13 = stat((char const   */* __restrict  */)(namebuf), (struct stat */* __restrict  */)(& statbuf));
  }
#line 1069
  if (! tmp___13) {
#line 1070
    return (0);
  }
  {
#line 1072
  tmp___14 = kern_qfmt_supp(1);
  }
#line 1072
  if (tmp___14) {
#line 1073
    return (1);
  }
  {
#line 1074
  tmp___15 = kern_qfmt_supp(0);
  }
#line 1074
  if (tmp___15) {
#line 1075
    return (0);
  }
#line 1076
  return (-1);
}
}
#line 1079 "/home/wheatley/newnew/temp/quota-4.01/quotacheck.c"
static int compatible_fs_qfmt(char *fstype , int fmt___7 ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  {
#line 1082
  tmp = strcmp((char const   *)fstype, "xfs");
  }
#line 1082
  if (tmp) {
    {
#line 1082
    tmp___0 = nfs_fstype(fstype);
    }
#line 1082
    if (tmp___0) {
#line 1084
      return (0);
    } else {
      {
#line 1082
      tmp___1 = meta_qf_fstype(fstype);
      }
#line 1082
      if (tmp___1) {
#line 1084
        return (0);
      }
    }
  } else {
#line 1084
    return (0);
  }
#line 1086
  if (fmt___7 == -1) {
#line 1087
    return (1);
  }
#line 1089
  if (fmt___7 == 4) {
    {
#line 1090
    tmp___2 = strcmp((char const   *)fstype, "gfs2");
    }
#line 1090
    if (tmp___2) {
#line 1090
      tmp___3 = 0;
    } else {
#line 1090
      tmp___3 = 1;
    }
#line 1090
    return (tmp___3);
  }
  {
#line 1092
  tmp___4 = strcmp((char const   *)fstype, "gfs2");
  }
#line 1092
  if (tmp___4) {
#line 1092
    tmp___5 = 1;
  } else {
#line 1092
    tmp___5 = 0;
  }
#line 1092
  return (tmp___5);
}
}
#line 1096 "/home/wheatley/newnew/temp/quota-4.01/quotacheck.c"
static void warn_if_jquota_supported(void) 
{ 
  struct utsname stats ;
  int v ;
  char *errch ;
  int *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  long tmp___4 ;
  long tmp___5 ;
  long tmp___6 ;
  char *tmp___7 ;

  {
  {
#line 1102
  tmp___2 = uname(& stats);
  }
#line 1102
  if (tmp___2 < 0) {
    {
#line 1103
    tmp = __errno_location();
#line 1103
    tmp___0 = strerror(*tmp);
#line 1103
    tmp___1 = gettext("Cannot get system info: %s\n");
#line 1103
    errstr(tmp___1, tmp___0);
    }
#line 1104
    return;
  }
  {
#line 1106
  tmp___3 = strcmp((char const   *)(stats.sysname), "Linux");
  }
#line 1106
  if (tmp___3) {
#line 1107
    return;
  }
  {
#line 1109
  tmp___4 = strtol((char const   */* __restrict  */)(stats.release), (char **/* __restrict  */)(& errch),
                   10);
#line 1109
  v = (int )tmp___4;
  }
#line 1110
  if (v < 2) {
#line 1111
    return;
  }
#line 1112
  if (v >= 3) {
#line 1113
    goto warn;
  }
#line 1114
  if ((int )*errch != 46) {
#line 1115
    return;
  }
  {
#line 1116
  tmp___5 = strtol((char const   */* __restrict  */)(errch + 1), (char **/* __restrict  */)(& errch),
                   10);
#line 1116
  v = (int )tmp___5;
  }
#line 1117
  if ((int )*errch != 46) {
#line 1118
    return;
  } else
#line 1117
  if (v < 6) {
#line 1118
    return;
  }
  {
#line 1119
  tmp___6 = strtol((char const   */* __restrict  */)(errch + 1), (char **/* __restrict  */)(& errch),
                   10);
#line 1119
  v = (int )tmp___6;
  }
#line 1120
  if (v < 11) {
#line 1121
    return;
  }
  warn: 
  {
#line 1123
  tmp___7 = gettext("Your kernel probably supports journaled quota but you are not using it. Consider switching to journaled quota to avoid running quotacheck after an unclean shutdown.\n");
#line 1123
  errstr(tmp___7);
  }
#line 1126
  return;
}
}
#line 1133 "/home/wheatley/newnew/temp/quota-4.01/quotacheck.c"
static int warned  ;
#line 1129 "/home/wheatley/newnew/temp/quota-4.01/quotacheck.c"
static int check_all(void) 
{ 
  struct mount_entry *mnt___2 ;
  int checked ;
  int failed ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  char *tmp___19 ;

  {
#line 1132
  checked = 0;
#line 1134
  failed = 0;
#line 1136
  if (flags & 256) {
#line 1136
    tmp___0 = 0;
  } else {
#line 1136
    tmp___0 = 1;
  }
  {
#line 1136
  tmp___1 = init_mounts_scan(tmp___0, & mntpoint, 0);
  }
#line 1136
  if (tmp___1 < 0) {
    {
#line 1137
    tmp = gettext("Cannot initialize mountpoint scan.\n");
#line 1137
    die(2, tmp);
    }
  }
  {
#line 1138
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1138
    mnt___2 = get_next_mount();
    }
#line 1138
    if (! mnt___2) {
#line 1138
      goto while_break;
    }
#line 1139
    if (flags & 256) {
#line 1139
      if (flags & 512) {
        {
#line 1139
        tmp___2 = strcmp(mnt___2->me_dir, "/");
        }
#line 1139
        if (! tmp___2) {
#line 1140
          goto while_continue;
        }
      }
    }
    {
#line 1141
    tmp___4 = compatible_fs_qfmt(mnt___2->me_type, fmt);
    }
#line 1141
    if (! tmp___4) {
      {
#line 1142
      tmp___3 = gettext("Skipping %s [%s]\n");
#line 1142
      debug(6, tmp___3, mnt___2->me_devname, mnt___2->me_dir);
      }
#line 1143
      goto while_continue;
    }
#line 1145
    cfmt = fmt;
#line 1146
    if (uwant) {
      {
#line 1146
      tmp___5 = me_hasquota(mnt___2, 0);
      }
#line 1146
      if (tmp___5) {
#line 1147
        ucheck = 1;
      } else {
#line 1149
        ucheck = 0;
      }
    } else {
#line 1149
      ucheck = 0;
    }
#line 1150
    if (gwant) {
      {
#line 1150
      tmp___6 = me_hasquota(mnt___2, 1);
      }
#line 1150
      if (tmp___6) {
#line 1151
        gcheck = 1;
      } else {
#line 1153
        gcheck = 0;
      }
    } else {
#line 1153
      gcheck = 0;
    }
#line 1154
    if (! ucheck) {
#line 1154
      if (! gcheck) {
#line 1155
        goto while_continue;
      }
    }
#line 1156
    if (cfmt == -1) {
#line 1157
      if (ucheck) {
#line 1157
        tmp___7 = 0;
      } else {
#line 1157
        tmp___7 = 1;
      }
      {
#line 1157
      cfmt = detect_filename_format(mnt___2, tmp___7);
      }
#line 1158
      if (cfmt == -1) {
        {
#line 1159
        tmp___8 = gettext("Cannot guess format from filename on %s. Please specify format on commandline.\n");
#line 1159
        errstr(tmp___8, mnt___2->me_devname);
#line 1161
        failed = -1;
        }
#line 1162
        goto while_continue;
      }
      {
#line 1164
      tmp___9 = fmt2name(cfmt);
#line 1164
      tmp___10 = gettext("Detected quota format %s\n");
#line 1164
      debug(4, tmp___10, tmp___9);
      }
    }
#line 1167
    if (flags & 2) {
      {
#line 1167
      tmp___11 = str_hasmntopt((char const   *)mnt___2->me_opts, "usrjquota");
      }
#line 1167
      if (! tmp___11) {
        {
#line 1167
        tmp___12 = str_hasmntopt((char const   *)mnt___2->me_opts, "grpjquota");
        }
#line 1167
        if (! tmp___12) {
#line 1167
          if (! warned) {
            {
#line 1167
            tmp___13 = strcmp((char const   *)mnt___2->me_type, "ext3");
            }
#line 1167
            if (tmp___13) {
              {
#line 1167
              tmp___14 = strcmp((char const   *)mnt___2->me_type, "ext4");
              }
#line 1167
              if (tmp___14) {
                {
#line 1167
                tmp___15 = strcmp((char const   *)mnt___2->me_type, "next3");
                }
#line 1167
                if (tmp___15) {
                  {
#line 1167
                  tmp___16 = strcmp((char const   *)mnt___2->me_type, "ext4dev");
                  }
#line 1167
                  if (tmp___16) {
                    {
#line 1167
                    tmp___17 = strcmp((char const   *)mnt___2->me_type, "reiserfs");
                    }
#line 1167
                    if (! tmp___17) {
                      {
#line 1176
                      warned = 1;
#line 1177
                      warn_if_jquota_supported();
                      }
                    }
                  } else {
                    {
#line 1176
                    warned = 1;
#line 1177
                    warn_if_jquota_supported();
                    }
                  }
                } else {
                  {
#line 1176
                  warned = 1;
#line 1177
                  warn_if_jquota_supported();
                  }
                }
              } else {
                {
#line 1176
                warned = 1;
#line 1177
                warn_if_jquota_supported();
                }
              }
            } else {
              {
#line 1176
              warned = 1;
#line 1177
              warn_if_jquota_supported();
              }
            }
          }
        }
      }
    }
    {
#line 1180
    checked ++;
#line 1181
    tmp___18 = check_dir(mnt___2);
#line 1181
    failed |= tmp___18;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1183
  end_mounts_scan();
  }
#line 1184
  if (! checked) {
#line 1184
    if (! (flags & 256)) {
      {
#line 1185
      tmp___19 = gettext("Cannot find filesystem to check or filesystem not mounted with quota option.\n");
#line 1185
      errstr(tmp___19);
#line 1186
      failed = -1;
      }
    } else
#line 1184
    if (flags & 6) {
      {
#line 1185
      tmp___19 = gettext("Cannot find filesystem to check or filesystem not mounted with quota option.\n");
#line 1185
      errstr(tmp___19);
#line 1186
      failed = -1;
      }
    }
  }
#line 1188
  return (failed);
}
}
#line 45 "/home/wheatley/newnew/temp/quota-4.01/quotaio_tree.c"
static int get_index___6(qid_t id___0 , int depth ) 
{ 


  {
#line 47
  return ((int )((id___0 >> ((4 - depth) - 1) * 8) & 255U));
}
}
#line 51 "/home/wheatley/newnew/temp/quota-4.01/quotaio_tree.c"
static void read_blk___6(struct quota_handle *h , uint blk , dqbuf_t buf ) 
{ 
  int err ;
  ssize_t tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 55
  lseek(h->qh_fd, (__off64_t )(blk << 10), 0);
#line 56
  tmp = read(h->qh_fd, (void *)buf, (size_t )(1 << 10));
#line 56
  err = (int )tmp;
  }
#line 57
  if (err < 0) {
    {
#line 58
    tmp___0 = __errno_location();
#line 58
    tmp___1 = strerror(*tmp___0);
#line 58
    tmp___2 = gettext("Cannot read block %u: %s\n");
#line 58
    die(2, tmp___2, blk, tmp___1);
    }
  } else
#line 59
  if (err != 1 << 10) {
    {
#line 60
    memset((void *)(buf + err), 0, (size_t )((1 << 10) - err));
    }
  }
#line 61
  return;
}
}
#line 64 "/home/wheatley/newnew/temp/quota-4.01/quotaio_tree.c"
static int write_blk___6(struct quota_handle *h , uint blk , dqbuf_t buf ) 
{ 
  int err ;
  ssize_t tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  int *tmp___3 ;

  {
  {
#line 68
  lseek(h->qh_fd, (__off64_t )(blk << 10), 0);
#line 69
  tmp = write(h->qh_fd, (void const   *)buf, (size_t )(1 << 10));
#line 69
  err = (int )tmp;
  }
#line 70
  if (err < 0) {
    {
#line 70
    tmp___3 = __errno_location();
    }
#line 70
    if (*tmp___3 != 28) {
      {
#line 71
      tmp___0 = __errno_location();
#line 71
      tmp___1 = strerror(*tmp___0);
#line 71
      tmp___2 = gettext("Cannot write block (%u): %s\n");
#line 71
      die(2, tmp___2, blk, tmp___1);
      }
    }
  }
#line 72
  if (err != 1 << 10) {
#line 73
    return (-28);
  }
#line 74
  return (0);
}
}
#line 78 "/home/wheatley/newnew/temp/quota-4.01/quotaio_tree.c"
static int get_free_dqblk___6(struct quota_handle *h ) 
{ 
  dqbuf_t buf ;
  void *tmp ;
  struct qt_disk_dqdbheader *dh ;
  struct qtree_mem_dqinfo *info ;
  int blk ;
  char *tmp___0 ;
  int tmp___1 ;
  unsigned int tmp___2 ;

  {
  {
#line 80
  tmp = smalloc((size_t )(1 << 10));
#line 80
  buf = (dqbuf_t )tmp;
#line 81
  dh = (struct qt_disk_dqdbheader *)buf;
#line 82
  info = & h->qh_info.u.v2_mdqi.dqi_qtree;
  }
#line 85
  if (info->dqi_free_blk) {
    {
#line 86
    blk = (int )info->dqi_free_blk;
#line 87
    read_blk___6(h, (uint )blk, buf);
#line 88
    info->dqi_free_blk = dh->dqdh_next_free;
    }
  } else {
    {
#line 91
    memset((void *)buf, 0, (size_t )(1 << 10));
#line 92
    tmp___1 = write_blk___6(h, info->dqi_blocks, buf);
    }
#line 92
    if (tmp___1 < 0) {
      {
#line 93
      free((void *)buf);
#line 94
      tmp___0 = gettext("Cannot allocate new quota block (out of disk space).\n");
#line 94
      errstr(tmp___0);
      }
#line 95
      return (-28);
    }
#line 97
    tmp___2 = info->dqi_blocks;
#line 97
    (info->dqi_blocks) ++;
#line 97
    blk = (int )tmp___2;
  }
  {
#line 99
  mark_quotafile_info_dirty(h);
#line 100
  free((void *)buf);
  }
#line 101
  return (blk);
}
}
#line 105 "/home/wheatley/newnew/temp/quota-4.01/quotaio_tree.c"
static void put_free_dqblk___6(struct quota_handle *h , dqbuf_t buf , uint blk ) 
{ 
  struct qt_disk_dqdbheader *dh ;
  struct qtree_mem_dqinfo *info ;

  {
  {
#line 107
  dh = (struct qt_disk_dqdbheader *)buf;
#line 108
  info = & h->qh_info.u.v2_mdqi.dqi_qtree;
#line 110
  dh->dqdh_next_free = info->dqi_free_blk;
#line 111
  dh->dqdh_prev_free = (__u32 )0;
#line 112
  dh->dqdh_entries = (__u16 )0;
#line 113
  info->dqi_free_blk = blk;
#line 114
  mark_quotafile_info_dirty(h);
#line 115
  write_blk___6(h, blk, buf);
  }
#line 116
  return;
}
}
#line 119 "/home/wheatley/newnew/temp/quota-4.01/quotaio_tree.c"
static void remove_free_dqentry___6(struct quota_handle *h , dqbuf_t buf , uint blk ) 
{ 
  dqbuf_t tmpbuf ;
  void *tmp ;
  struct qt_disk_dqdbheader *dh ;
  uint nextblk ;
  uint prevblk ;
  u_int32_t tmp___0 ;

  {
  {
#line 121
  tmp = smalloc((size_t )(1 << 10));
#line 121
  tmpbuf = (dqbuf_t )tmp;
#line 122
  dh = (struct qt_disk_dqdbheader *)buf;
#line 123
  nextblk = dh->dqdh_next_free;
#line 123
  prevblk = dh->dqdh_prev_free;
  }
#line 127
  if (nextblk) {
    {
#line 128
    read_blk___6(h, nextblk, tmpbuf);
#line 129
    ((struct qt_disk_dqdbheader *)tmpbuf)->dqdh_prev_free = dh->dqdh_prev_free;
#line 130
    write_blk___6(h, nextblk, tmpbuf);
    }
  }
#line 132
  if (prevblk) {
    {
#line 133
    read_blk___6(h, prevblk, tmpbuf);
#line 134
    ((struct qt_disk_dqdbheader *)tmpbuf)->dqdh_next_free = dh->dqdh_next_free;
#line 135
    write_blk___6(h, prevblk, tmpbuf);
    }
  } else {
    {
#line 138
    h->qh_info.u.v2_mdqi.dqi_qtree.dqi_free_entry = nextblk;
#line 139
    mark_quotafile_info_dirty(h);
    }
  }
  {
#line 141
  free((void *)tmpbuf);
#line 142
  tmp___0 = (__u32 )0;
#line 142
  dh->dqdh_prev_free = tmp___0;
#line 142
  dh->dqdh_next_free = tmp___0;
#line 143
  write_blk___6(h, blk, buf);
  }
#line 144
  return;
}
}
#line 147 "/home/wheatley/newnew/temp/quota-4.01/quotaio_tree.c"
static void insert_free_dqentry___6(struct quota_handle *h , dqbuf_t buf , uint blk ) 
{ 
  dqbuf_t tmpbuf ;
  void *tmp ;
  struct qt_disk_dqdbheader *dh ;
  struct qtree_mem_dqinfo *info ;

  {
  {
#line 149
  tmp = smalloc((size_t )(1 << 10));
#line 149
  tmpbuf = (dqbuf_t )tmp;
#line 150
  dh = (struct qt_disk_dqdbheader *)buf;
#line 151
  info = & h->qh_info.u.v2_mdqi.dqi_qtree;
#line 153
  dh->dqdh_next_free = info->dqi_free_entry;
#line 154
  dh->dqdh_prev_free = (__u32 )0;
#line 155
  write_blk___6(h, blk, buf);
  }
#line 156
  if (info->dqi_free_entry) {
    {
#line 157
    read_blk___6(h, info->dqi_free_entry, tmpbuf);
#line 158
    ((struct qt_disk_dqdbheader *)tmpbuf)->dqdh_prev_free = blk;
#line 159
    write_blk___6(h, info->dqi_free_entry, tmpbuf);
    }
  }
  {
#line 161
  free((void *)tmpbuf);
#line 162
  info->dqi_free_entry = blk;
#line 163
  mark_quotafile_info_dirty(h);
  }
#line 164
  return;
}
}
#line 167 "/home/wheatley/newnew/temp/quota-4.01/quotaio_tree.c"
static uint find_free_dqentry___6(struct quota_handle *h , struct dquot *dquot , int *err ) 
{ 
  int blk ;
  int i ;
  struct qt_disk_dqdbheader *dh ;
  struct qtree_mem_dqinfo *info ;
  char *ddquot ;
  dqbuf_t buf ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;

  {
  {
#line 171
  info = & h->qh_info.u.v2_mdqi.dqi_qtree;
#line 175
  *err = 0;
#line 176
  tmp = smalloc((size_t )(1 << 10));
#line 176
  buf = (dqbuf_t )tmp;
#line 177
  dh = (struct qt_disk_dqdbheader *)buf;
  }
#line 178
  if (info->dqi_free_entry) {
    {
#line 179
    blk = (int )info->dqi_free_entry;
#line 180
    read_blk___6(h, (uint )blk, buf);
    }
  } else {
    {
#line 183
    blk = get_free_dqblk___6(h);
    }
#line 184
    if (blk < 0) {
      {
#line 185
      free((void *)buf);
#line 186
      *err = blk;
      }
#line 187
      return ((uint )0);
    }
    {
#line 189
    memset((void *)buf, 0, (size_t )(1 << 10));
#line 190
    info->dqi_free_entry = (unsigned int )blk;
#line 191
    mark_quotafile_info_dirty(h);
    }
  }
  {
#line 193
  tmp___0 = qtree_dqstr_in_blk(info);
  }
#line 193
  if ((int )dh->dqdh_entries + 1 >= tmp___0) {
    {
#line 194
    remove_free_dqentry___6(h, buf, (uint )blk);
    }
  }
#line 195
  dh->dqdh_entries = (__u16 )((int )dh->dqdh_entries + 1);
#line 197
  ddquot = buf + sizeof(struct qt_disk_dqdbheader );
#line 198
  i = 0;
  {
#line 198
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 198
    tmp___1 = qtree_dqstr_in_blk(info);
    }
#line 198
    if (i < tmp___1) {
      {
#line 198
      tmp___2 = qtree_entry_unused(info, ddquot);
      }
#line 198
      if (tmp___2) {
#line 198
        goto while_break;
      }
    } else {
#line 198
      goto while_break;
    }
#line 198
    i ++;
#line 198
    ddquot += info->dqi_entry_size;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 201
  tmp___4 = qtree_dqstr_in_blk(info);
  }
#line 201
  if (i == tmp___4) {
    {
#line 202
    tmp___3 = gettext("find_free_dqentry(): Data block full but it shouldn\'t.\n");
#line 202
    die(2, tmp___3);
    }
  }
  {
#line 203
  write_blk___6(h, (uint )blk, buf);
#line 204
  dquot->dq_dqb.u.v2_mdqb.dqb_off = (loff_t )(((unsigned long )(blk << 10) + sizeof(struct qt_disk_dqdbheader )) + (unsigned long )((unsigned int )i * info->dqi_entry_size));
#line 207
  free((void *)buf);
  }
#line 208
  return ((uint )blk);
}
}
#line 212 "/home/wheatley/newnew/temp/quota-4.01/quotaio_tree.c"
static int do_insert_tree___6(struct quota_handle *h , struct dquot *dquot , uint *treeblk ,
                              int depth ) 
{ 
  dqbuf_t buf ;
  int newson ;
  int newact ;
  u_int32_t *ref ;
  uint newblk ;
  int ret ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;

  {
  {
#line 215
  newson = 0;
#line 215
  newact = 0;
#line 218
  ret = 0;
#line 220
  tmp = smalloc((size_t )(1 << 10));
#line 220
  buf = (dqbuf_t )tmp;
  }
#line 221
  if (! *treeblk) {
    {
#line 222
    ret = get_free_dqblk___6(h);
    }
#line 223
    if (ret < 0) {
#line 224
      goto out_buf;
    }
    {
#line 225
    *treeblk = (uint )ret;
#line 226
    memset((void *)buf, 0, (size_t )(1 << 10));
#line 227
    newact = 1;
    }
  } else {
    {
#line 230
    read_blk___6(h, *treeblk, buf);
    }
  }
  {
#line 231
  ref = (u_int32_t *)buf;
#line 232
  tmp___0 = get_index___6(dquot->dq_id, depth);
#line 232
  newblk = *(ref + tmp___0);
  }
#line 233
  if (! newblk) {
#line 234
    newson = 1;
  }
#line 235
  if (depth == 3) {
#line 236
    if (newblk) {
      {
#line 237
      tmp___1 = get_index___6(dquot->dq_id, depth);
#line 237
      tmp___2 = gettext("Inserting already present quota entry (block %u).\n");
#line 237
      die(2, tmp___2, *(ref + tmp___1));
      }
    }
    {
#line 239
    newblk = find_free_dqentry___6(h, dquot, & ret);
    }
  } else {
    {
#line 242
    ret = do_insert_tree___6(h, dquot, & newblk, depth + 1);
    }
  }
#line 243
  if (newson) {
#line 243
    if (ret >= 0) {
      {
#line 244
      tmp___3 = get_index___6(dquot->dq_id, depth);
#line 244
      *(ref + tmp___3) = newblk;
#line 245
      write_blk___6(h, *treeblk, buf);
      }
    } else {
#line 243
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 247
  if (newact) {
#line 247
    if (ret < 0) {
      {
#line 248
      put_free_dqblk___6(h, buf, *treeblk);
      }
    }
  }
  out_buf: 
  {
#line 250
  free((void *)buf);
  }
#line 251
  return (ret);
}
}
#line 255 "/home/wheatley/newnew/temp/quota-4.01/quotaio_tree.c"
static void dq_insert_tree___6(struct quota_handle *h , struct dquot *dquot ) 
{ 
  uint tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;

  {
  {
#line 257
  tmp = (uint )1;
#line 259
  tmp___3 = do_insert_tree___6(h, dquot, & tmp, 0);
  }
#line 259
  if (tmp___3 < 0) {
    {
#line 260
    tmp___0 = __errno_location();
#line 260
    tmp___1 = strerror(*tmp___0);
#line 260
    tmp___2 = gettext("Cannot write quota (id %u): %s\n");
#line 260
    die(2, tmp___2, dquot->dq_id, tmp___1);
    }
  }
#line 261
  return;
}
}
#line 284 "/home/wheatley/newnew/temp/quota-4.01/quotaio_tree.c"
static void free_dqentry___6(struct quota_handle *h , struct dquot *dquot , uint blk ) 
{ 
  struct qt_disk_dqdbheader *dh ;
  struct qtree_mem_dqinfo *info ;
  dqbuf_t buf ;
  void *tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 287
  info = & h->qh_info.u.v2_mdqi.dqi_qtree;
#line 288
  tmp = smalloc((size_t )(1 << 10));
#line 288
  buf = (dqbuf_t )tmp;
  }
#line 290
  if (dquot->dq_dqb.u.v2_mdqb.dqb_off >> 10 != (loff_t )blk) {
    {
#line 291
    tmp___0 = gettext("Quota structure has offset to other block (%u) than it should (%u).\n");
#line 291
    die(2, tmp___0, blk, (uint )(dquot->dq_dqb.u.v2_mdqb.dqb_off >> 10));
    }
  }
  {
#line 293
  read_blk___6(h, blk, buf);
#line 294
  dh = (struct qt_disk_dqdbheader *)buf;
#line 295
  dh->dqdh_entries = (__u16 )((int )dh->dqdh_entries - 1);
  }
#line 296
  if (! dh->dqdh_entries) {
    {
#line 297
    remove_free_dqentry___6(h, buf, blk);
#line 298
    put_free_dqblk___6(h, buf, blk);
    }
  } else {
    {
#line 301
    memset((void *)(buf + (dquot->dq_dqb.u.v2_mdqb.dqb_off & (long )((1 << 10) - 1))),
           0, (size_t )info->dqi_entry_size);
#line 304
    tmp___1 = qtree_dqstr_in_blk(info);
    }
#line 304
    if ((int )dh->dqdh_entries == tmp___1 - 1) {
      {
#line 305
      insert_free_dqentry___6(h, buf, blk);
      }
    } else {
      {
#line 307
      write_blk___6(h, blk, buf);
      }
    }
  }
  {
#line 309
  dquot->dq_dqb.u.v2_mdqb.dqb_off = (loff_t )0;
#line 310
  free((void *)buf);
  }
#line 311
  return;
}
}
#line 314 "/home/wheatley/newnew/temp/quota-4.01/quotaio_tree.c"
static void remove_tree___6(struct quota_handle *h , struct dquot *dquot , uint *blk ,
                            int depth ) 
{ 
  dqbuf_t buf ;
  void *tmp ;
  uint newblk ;
  u_int32_t *ref ;
  int tmp___0 ;
  int i ;
  int tmp___1 ;

  {
  {
#line 316
  tmp = smalloc((size_t )(1 << 10));
#line 316
  buf = (dqbuf_t )tmp;
#line 318
  ref = (u_int32_t *)buf;
#line 320
  read_blk___6(h, *blk, buf);
#line 321
  tmp___0 = get_index___6(dquot->dq_id, depth);
#line 321
  newblk = *(ref + tmp___0);
  }
#line 322
  if (depth == 3) {
    {
#line 323
    free_dqentry___6(h, dquot, newblk);
#line 324
    newblk = (uint )0;
    }
  } else {
    {
#line 327
    remove_tree___6(h, dquot, & newblk, depth + 1);
    }
  }
#line 328
  if (! newblk) {
    {
#line 331
    tmp___1 = get_index___6(dquot->dq_id, depth);
#line 331
    *(ref + tmp___1) = (__u32 )0;
#line 332
    i = 0;
    }
    {
#line 332
    while (1) {
      while_continue: /* CIL Label */ ;
#line 332
      if (i < 1 << 10) {
#line 332
        if (! (! *(buf + i))) {
#line 332
          goto while_break;
        }
      } else {
#line 332
        goto while_break;
      }
#line 332
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 334
    if (i == 1 << 10) {
#line 334
      if (*blk != 1U) {
        {
#line 335
        put_free_dqblk___6(h, buf, *blk);
#line 336
        *blk = (uint )0;
        }
      } else {
        {
#line 339
        write_blk___6(h, *blk, buf);
        }
      }
    } else {
      {
#line 339
      write_blk___6(h, *blk, buf);
      }
    }
  }
  {
#line 341
  free((void *)buf);
  }
#line 342
  return;
}
}
#line 355 "/home/wheatley/newnew/temp/quota-4.01/quotaio_tree.c"
static loff_t find_block_dqentry___6(struct quota_handle *h , struct dquot *dquot ,
                                     uint blk ) 
{ 
  struct qtree_mem_dqinfo *info ;
  dqbuf_t buf ;
  void *tmp ;
  int i ;
  char *ddquot ;
  int tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;

  {
  {
#line 357
  info = & h->qh_info.u.v2_mdqi.dqi_qtree;
#line 358
  tmp = smalloc((size_t )(1 << 10));
#line 358
  buf = (dqbuf_t )tmp;
#line 360
  ddquot = buf + sizeof(struct qt_disk_dqdbheader );
#line 362
  read_blk___6(h, blk, buf);
#line 363
  i = 0;
  }
  {
#line 363
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 363
    tmp___0 = qtree_dqstr_in_blk(info);
    }
#line 363
    if (i < tmp___0) {
      {
#line 363
      tmp___1 = (*((info->dqi_ops)->is_id))((void *)ddquot, dquot);
      }
#line 363
      if (tmp___1) {
#line 363
        goto while_break;
      }
    } else {
#line 363
      goto while_break;
    }
#line 363
    i ++;
#line 363
    ddquot += info->dqi_entry_size;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 366
  tmp___3 = qtree_dqstr_in_blk(info);
  }
#line 366
  if (i == tmp___3) {
    {
#line 367
    tmp___2 = gettext("Quota for id %u referenced but not present.\n");
#line 367
    die(2, tmp___2, dquot->dq_id);
    }
  }
  {
#line 368
  free((void *)buf);
  }
#line 369
  return ((loff_t )(((unsigned long )(blk << 10) + sizeof(struct qt_disk_dqdbheader )) + (unsigned long )((unsigned int )i * info->dqi_entry_size)));
}
}
#line 374 "/home/wheatley/newnew/temp/quota-4.01/quotaio_tree.c"
static loff_t find_tree_dqentry___6(struct quota_handle *h , struct dquot *dquot ,
                                    uint blk , int depth ) 
{ 
  dqbuf_t buf ;
  void *tmp ;
  loff_t ret ;
  u_int32_t *ref ;
  int tmp___0 ;

  {
  {
#line 376
  tmp = smalloc((size_t )(1 << 10));
#line 376
  buf = (dqbuf_t )tmp;
#line 377
  ret = (loff_t )0;
#line 378
  ref = (u_int32_t *)buf;
#line 380
  read_blk___6(h, blk, buf);
#line 381
  ret = (loff_t )0;
#line 382
  tmp___0 = get_index___6(dquot->dq_id, depth);
#line 382
  blk = *(ref + tmp___0);
  }
#line 383
  if (! blk) {
#line 384
    goto out_buf;
  }
#line 385
  if (depth < 3) {
    {
#line 386
    ret = find_tree_dqentry___6(h, dquot, blk, depth + 1);
    }
  } else {
    {
#line 388
    ret = find_block_dqentry___6(h, dquot, blk);
    }
  }
  out_buf: 
  {
#line 390
  free((void *)buf);
  }
#line 391
  return (ret);
}
}
#line 395 "/home/wheatley/newnew/temp/quota-4.01/quotaio_tree.c"
__inline static loff_t find_dqentry___6(struct quota_handle *h , struct dquot *dquot ) 
{ 
  loff_t tmp ;

  {
  {
#line 397
  tmp = find_tree_dqentry___6(h, dquot, (uint )1, 0);
  }
#line 397
  return (tmp);
}
}
#line 441 "/home/wheatley/newnew/temp/quota-4.01/quotaio_tree.c"
static int report_block___6(struct dquot *dquot , uint blk , char *bitmap , int (*process_dquot)(struct dquot * ,
                                                                                                 char * ) ) 
{ 
  struct qtree_mem_dqinfo *info ;
  dqbuf_t buf ;
  void *tmp ;
  struct qt_disk_dqdbheader *dh ;
  char *ddata ;
  int entries ;
  int i ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 444
  info = & (dquot->dq_h)->qh_info.u.v2_mdqi.dqi_qtree;
#line 445
  tmp = smalloc((size_t )(1 << 10));
#line 445
  buf = (dqbuf_t )tmp;
#line 450
  *(bitmap + (blk >> 3)) = (char )((int )*(bitmap + (blk >> 3)) | (1 << (blk & 7U)));
#line 451
  read_blk___6(dquot->dq_h, blk, buf);
#line 452
  dh = (struct qt_disk_dqdbheader *)buf;
#line 453
  ddata = buf + sizeof(struct qt_disk_dqdbheader );
#line 454
  entries = (int )dh->dqdh_entries;
#line 455
  i = 0;
  }
  {
#line 455
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 455
    tmp___2 = qtree_dqstr_in_blk(info);
    }
#line 455
    if (! (i < tmp___2)) {
#line 455
      goto while_break;
    }
    {
#line 456
    tmp___1 = qtree_entry_unused(info, ddata);
    }
#line 456
    if (! tmp___1) {
      {
#line 457
      (*((info->dqi_ops)->disk2mem_dqblk))(dquot, (void *)ddata);
#line 458
      tmp___0 = (*process_dquot)(dquot, (char *)((void *)0));
      }
#line 458
      if (tmp___0 < 0) {
#line 459
        goto while_break;
      }
    }
#line 455
    i ++;
#line 455
    ddata += info->dqi_entry_size;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 461
  free((void *)buf);
  }
#line 462
  return (entries);
}
}
#line 465 "/home/wheatley/newnew/temp/quota-4.01/quotaio_tree.c"
static void check_reference___6(struct quota_handle *h , uint blk ) 
{ 
  char *tmp ;
  char *tmp___0 ;

  {
#line 467
  if (blk >= h->qh_info.u.v2_mdqi.dqi_qtree.dqi_blocks) {
    {
#line 468
    tmp = type2name(h->qh_type);
#line 468
    tmp___0 = gettext("Illegal reference (%u >= %u) in %s quota file on %s. Quota file is probably corrupted.\nPlease run quotacheck(8) and try again.\n");
#line 468
    die(2, tmp___0, blk, h->qh_info.u.v2_mdqi.dqi_qtree.dqi_blocks, tmp, h->qh_quotadev);
    }
  }
#line 469
  return;
}
}
#line 471 "/home/wheatley/newnew/temp/quota-4.01/quotaio_tree.c"
static int report_tree___6(struct dquot *dquot , uint blk , int depth , char *bitmap ,
                           int (*process_dquot)(struct dquot * , char * ) ) 
{ 
  int entries ;
  int i ;
  dqbuf_t buf ;
  void *tmp ;
  u_int32_t *ref ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 474
  entries = 0;
#line 475
  tmp = smalloc((size_t )(1 << 10));
#line 475
  buf = (dqbuf_t )tmp;
#line 476
  ref = (u_int32_t *)buf;
#line 478
  read_blk___6(dquot->dq_h, blk, buf);
  }
#line 479
  if (depth == 3) {
#line 480
    i = 0;
    {
#line 480
    while (1) {
      while_continue: /* CIL Label */ ;
#line 480
      if (! (i < (1 << 10) >> 2)) {
#line 480
        goto while_break;
      }
      {
#line 481
      blk = *(ref + i);
#line 482
      check_reference___6(dquot->dq_h, blk);
      }
#line 483
      if (blk) {
#line 483
        if (! ((int )*(bitmap + (blk >> 3)) & (1 << (blk & 7U)))) {
          {
#line 484
          tmp___0 = report_block___6(dquot, blk, bitmap, process_dquot);
#line 484
          entries += tmp___0;
          }
        }
      }
#line 480
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 488
    i = 0;
    {
#line 488
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 488
      if (! (i < (1 << 10) >> 2)) {
#line 488
        goto while_break___0;
      }
#line 489
      blk = *(ref + i);
#line 489
      if (blk) {
        {
#line 490
        check_reference___6(dquot->dq_h, blk);
#line 491
        tmp___1 = report_tree___6(dquot, blk, depth + 1, bitmap, process_dquot);
#line 491
        entries += tmp___1;
        }
      }
#line 488
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  {
#line 495
  free((void *)buf);
  }
#line 496
  return (entries);
}
}
#line 499 "/home/wheatley/newnew/temp/quota-4.01/quotaio_tree.c"
static uint find_set_bits___6(char *bmp , int blocks ) 
{ 
  uint i ;
  uint used ;

  {
#line 501
  used = (uint )0;
#line 503
  i = (uint )0;
  {
#line 503
  while (1) {
    while_continue: /* CIL Label */ ;
#line 503
    if (! (i < (uint )blocks)) {
#line 503
      goto while_break;
    }
#line 504
    if ((int )*(bmp + (i >> 3)) & (1 << (i & 7U))) {
#line 505
      used ++;
    }
#line 503
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 506
  return (used);
}
}
#line 23 "/home/wheatley/newnew/temp/quota-4.01/common.c"
static int enable_syslog___7  =    0;
#line 31 "/home/wheatley/newnew/temp/quota-4.01/common.c"
static void do_syslog___7(int level , char const   *format , va_list args ) 
{ 
  char buf[1024] ;
  int i ;
  int j ;
  int tmp ;

  {
  {
#line 36
  vsnprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)format,
            args);
#line 39
  i = 0;
  }
  {
#line 39
  while (1) {
    while_continue: /* CIL Label */ ;
#line 39
    if (! buf[i]) {
#line 39
      goto while_break;
    }
#line 40
    j = i;
    {
#line 40
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 40
      if (buf[j]) {
#line 40
        if (! ((int )buf[j] != 10)) {
#line 40
          goto while_break___0;
        }
      } else {
#line 40
        goto while_break___0;
      }
#line 40
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 41
    if ((int )buf[j] == 10) {
#line 42
      tmp = j;
#line 42
      j ++;
#line 42
      buf[tmp] = (char )'\000';
    }
    {
#line 43
    syslog(level, "%s", buf + i);
#line 39
    i = j;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 45
  return;
}
}
#line 23 "/home/wheatley/newnew/temp/quota-4.01/common.c"
static int enable_syslog___8  =    0;
#line 31 "/home/wheatley/newnew/temp/quota-4.01/common.c"
static void do_syslog___8(int level , char const   *format , va_list args ) 
{ 
  char buf[1024] ;
  int i ;
  int j ;
  int tmp ;

  {
  {
#line 36
  vsnprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)format,
            args);
#line 39
  i = 0;
  }
  {
#line 39
  while (1) {
    while_continue: /* CIL Label */ ;
#line 39
    if (! buf[i]) {
#line 39
      goto while_break;
    }
#line 40
    j = i;
    {
#line 40
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 40
      if (buf[j]) {
#line 40
        if (! ((int )buf[j] != 10)) {
#line 40
          goto while_break___0;
        }
      } else {
#line 40
        goto while_break___0;
      }
#line 40
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 41
    if ((int )buf[j] == 10) {
#line 42
      tmp = j;
#line 42
      j ++;
#line 42
      buf[tmp] = (char )'\000';
    }
    {
#line 43
    syslog(level, "%s", buf + i);
#line 39
    i = j;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 45
  return;
}
}
#line 828 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) feof)(FILE *__stream ) ;
#line 19 "/home/wheatley/newnew/temp/quota-4.01/quotaio_meta.c"
static int meta_init_io___7(struct quota_handle *h ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
#line 21
  if (! (h->qh_io_flags & 1)) {
    {
#line 22
    tmp = gettext("Metadata init_io called when kernel support is not enabled.\n");
#line 22
    errstr(tmp);
    }
#line 23
    return (-1);
  }
#line 25
  if (kernel_iface != 3) {
    {
#line 26
    tmp___0 = gettext("Metadata init_io called when kernel does not support generic quota interface!\n");
#line 26
    errstr(tmp___0);
    }
#line 27
    return (-1);
  }
  {
#line 29
  tmp___1 = vfs_get_info(h);
  }
#line 29
  return (tmp___1);
}
}
#line 32 "/home/wheatley/newnew/temp/quota-4.01/quotaio_meta.c"
static int meta_write_info___7(struct quota_handle *h ) 
{ 
  int tmp ;

  {
  {
#line 34
  tmp = vfs_set_info(h, 3);
  }
#line 34
  return (tmp);
}
}
#line 37 "/home/wheatley/newnew/temp/quota-4.01/quotaio_meta.c"
static struct dquot *meta_read_dquot___7(struct quota_handle *h , qid_t id___0 ) 
{ 
  struct dquot *dquot ;
  struct dquot *tmp ;
  int tmp___0 ;

  {
  {
#line 39
  tmp = get_empty_dquot();
#line 39
  dquot = tmp;
#line 41
  dquot->dq_id = id___0;
#line 42
  dquot->dq_h = h;
#line 43
  memset((void *)(& dquot->dq_dqb), 0, sizeof(struct util_dqblk ));
#line 44
  tmp___0 = vfs_get_dquot(dquot);
  }
#line 44
  if (tmp___0 < 0) {
    {
#line 45
    free((void *)dquot);
    }
#line 46
    return ((struct dquot *)((void *)0));
  }
#line 48
  return (dquot);
}
}
#line 51 "/home/wheatley/newnew/temp/quota-4.01/quotaio_meta.c"
static int meta_commit_dquot___7(struct dquot *dquot , int flags___7 ) 
{ 
  int tmp ;

  {
  {
#line 53
  tmp = vfs_set_dquot(dquot, flags___7);
  }
#line 53
  return (tmp);
}
}
#line 56 "/home/wheatley/newnew/temp/quota-4.01/quotaio_meta.c"
static int meta_scan_dquots___7(struct quota_handle *h , int (*process_dquot)(struct dquot *dquot ,
                                                                              char *dqname ) ) 
{ 
  int tmp ;

  {
  {
#line 58
  tmp = generic_scan_dquots(h, process_dquot, & vfs_get_dquot);
  }
#line 58
  return (tmp);
}
}
#line 27 "/home/wheatley/newnew/temp/quota-4.01/quotaio_xfs.c"
static int xfs_init_io___7(struct quota_handle *h ) ;
#line 28
static int xfs_write_info___7(struct quota_handle *h ) ;
#line 29
static struct dquot *xfs_read_dquot___7(struct quota_handle *h , qid_t id___0 ) ;
#line 30
static int xfs_commit_dquot___7(struct dquot *dquot , int flags___7 ) ;
#line 31
static int xfs_scan_dquots___7(struct quota_handle *h , int (*process_dquot)(struct dquot *dquot ,
                                                                             char *dqname ) ) ;
#line 32
static int xfs_report___7(struct quota_handle *h , int verbose ) ;
#line 77 "/home/wheatley/newnew/temp/quota-4.01/quotaio_xfs.c"
static int xfs_init_io___7(struct quota_handle *h ) 
{ 
  struct fs_quota_stat info ;
  int qcmd ;
  long tmp ;

  {
  {
#line 82
  qcmd = ((88 << 8) + 5) << 8;
#line 83
  memset((void *)(& info), 0, sizeof(struct fs_quota_stat ));
#line 84
  tmp = quotactl(qcmd, (char const   *)(h->qh_quotadev), (qid_t )0, (caddr_t )((void *)(& info)));
  }
#line 84
  if (tmp < 0L) {
#line 85
    return (-1);
  }
#line 86
  h->qh_info.dqi_bgrace = (time_t )info.qs_btimelimit;
#line 87
  h->qh_info.dqi_igrace = (time_t )info.qs_itimelimit;
#line 88
  h->qh_info.u.xfs_mdqi = info;
#line 89
  return (0);
}
}
#line 95 "/home/wheatley/newnew/temp/quota-4.01/quotaio_xfs.c"
static int xfs_write_info___7(struct quota_handle *h ) 
{ 
  struct fs_disk_quota xdqblk ;
  int qcmd ;
  long tmp ;

  {
#line 100
  if (h->qh_type == 0) {
#line 100
    if (! ((int )h->qh_info.u.xfs_mdqi.qs_flags & 1)) {
#line 100
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 100
  if (h->qh_type == 1) {
#line 100
    if (! ((int )h->qh_info.u.xfs_mdqi.qs_flags & (1 << 2))) {
#line 101
      return (0);
    }
  } else {
#line 101
    return (0);
  }
  {
#line 103
  memset((void *)(& xdqblk), 0, sizeof(struct fs_disk_quota ));
#line 105
  xdqblk.d_btimer = (__s32 )h->qh_info.dqi_bgrace;
#line 106
  xdqblk.d_itimer = (__s32 )h->qh_info.dqi_igrace;
#line 107
  xdqblk.d_fieldmask = (__u16 )((int )xdqblk.d_fieldmask | (((1 << 6) | (1 << 7)) | (1 << 8)));
#line 108
  qcmd = (((88 << 8) + 4) << 8) | (h->qh_type & 255);
#line 109
  tmp = quotactl(qcmd, (char const   *)(h->qh_quotadev), (qid_t )0, (caddr_t )((void *)(& xdqblk)));
  }
#line 109
  if (tmp < 0L) {
#line 110
    return (-1);
  }
#line 111
  return (0);
}
}
#line 117 "/home/wheatley/newnew/temp/quota-4.01/quotaio_xfs.c"
static struct dquot *xfs_read_dquot___7(struct quota_handle *h , qid_t id___0 ) 
{ 
  struct dquot *dquot ;
  struct dquot *tmp ;
  struct fs_disk_quota xdqblk ;
  int qcmd ;
  long tmp___0 ;

  {
  {
#line 119
  tmp = get_empty_dquot();
#line 119
  dquot = tmp;
#line 123
  dquot->dq_id = id___0;
#line 124
  dquot->dq_h = h;
  }
#line 126
  if (h->qh_type == 0) {
#line 126
    if (! ((int )h->qh_info.u.xfs_mdqi.qs_flags & 1)) {
#line 126
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 126
  if (h->qh_type == 1) {
#line 126
    if (! ((int )h->qh_info.u.xfs_mdqi.qs_flags & (1 << 2))) {
#line 127
      return (dquot);
    }
  } else {
#line 127
    return (dquot);
  }
  {
#line 129
  qcmd = (((88 << 8) + 3) << 8) | (h->qh_type & 255);
#line 130
  tmp___0 = quotactl(qcmd, (char const   *)(h->qh_quotadev), id___0, (caddr_t )((void *)(& xdqblk)));
  }
#line 130
  if (! (tmp___0 < 0L)) {
    {
#line 134
    xfs_kern2utildqblk(& dquot->dq_dqb, & xdqblk);
    }
  }
#line 136
  return (dquot);
}
}
#line 142 "/home/wheatley/newnew/temp/quota-4.01/quotaio_xfs.c"
static int xfs_commit_dquot___7(struct dquot *dquot , int flags___7 ) 
{ 
  struct quota_handle *h ;
  struct fs_disk_quota xdqblk ;
  qid_t id___0 ;
  int qcmd ;
  int tmp ;
  int tmp___0 ;
  long tmp___1 ;

  {
#line 144
  h = dquot->dq_h;
#line 146
  id___0 = dquot->dq_id;
#line 149
  if (h->qh_type == 0) {
#line 149
    if (! ((int )h->qh_info.u.xfs_mdqi.qs_flags & 1)) {
#line 149
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 149
  if (h->qh_type == 1) {
#line 149
    if (! ((int )h->qh_info.u.xfs_mdqi.qs_flags & (1 << 2))) {
#line 150
      return (0);
    }
  } else {
#line 150
    return (0);
  }
  {
#line 152
  xfs_util2kerndqblk(& xdqblk, & dquot->dq_dqb);
  }
#line 153
  if (h->qh_type == 0) {
#line 153
    if ((int )h->qh_info.u.xfs_mdqi.qs_flags & 1) {
#line 153
      tmp = 1;
    } else {
#line 153
      tmp = 1 << 2;
    }
  } else {
#line 153
    tmp = 1 << 2;
  }
  {
#line 153
  xdqblk.d_flags = (__s8 )((int )xdqblk.d_flags | tmp);
#line 154
  xdqblk.d_id = id___0;
#line 155
  tmp___0 = strcmp((char const   *)(h->qh_fstype), "gfs2");
  }
#line 155
  if (tmp___0 == 0) {
#line 156
    if (flags___7 & 5) {
#line 157
      xdqblk.d_fieldmask = (__u16 )((int )xdqblk.d_fieldmask | ((1 << 2) | (1 << 3)));
    }
#line 158
    if (flags___7 & 10) {
#line 159
      xdqblk.d_fieldmask = (__u16 )((int )xdqblk.d_fieldmask | (1 << 12));
    }
  } else {
#line 161
    xdqblk.d_fieldmask = (__u16 )((int )xdqblk.d_fieldmask | (((((1 | (1 << 1)) | (1 << 2)) | (1 << 3)) | (1 << 4)) | (1 << 5)));
  }
  {
#line 164
  qcmd = (((88 << 8) + 4) << 8) | (h->qh_type & 255);
#line 165
  tmp___1 = quotactl(qcmd, (char const   *)(h->qh_quotadev), id___0, (caddr_t )((void *)(& xdqblk)));
  }
#line 165
  if (! (tmp___1 < 0L)) {
#line 169
    return (0);
  }
#line 171
  return (-1);
}
}
#line 177 "/home/wheatley/newnew/temp/quota-4.01/quotaio_xfs.c"
static int xfs_get_dquot___7(struct dquot *dq ) 
{ 
  struct fs_disk_quota d ;
  int qcmd ;
  int ret ;
  long tmp ;
  int *tmp___0 ;

  {
  {
#line 180
  qcmd = (((88 << 8) + 3) << 8) | ((dq->dq_h)->qh_type & 255);
#line 183
  memset((void *)(& d), 0, sizeof(d));
#line 184
  tmp = quotactl(qcmd, (char const   *)((dq->dq_h)->qh_quotadev), dq->dq_id, (caddr_t )((void *)(& d)));
#line 184
  ret = (int )tmp;
  }
#line 185
  if (ret < 0) {
    {
#line 186
    tmp___0 = __errno_location();
    }
#line 186
    if (*tmp___0 == 2) {
#line 187
      return (0);
    }
#line 188
    return (-1);
  }
  {
#line 190
  xfs_kern2utildqblk(& dq->dq_dqb, & d);
  }
#line 191
  return (0);
}
}
#line 197 "/home/wheatley/newnew/temp/quota-4.01/quotaio_xfs.c"
static int xfs_scan_dquots___7(struct quota_handle *h , int (*process_dquot)(struct dquot *dquot ,
                                                                             char *dqname ) ) 
{ 
  int tmp ;

  {
#line 199
  if (h->qh_type == 0) {
#line 199
    if (! ((int )h->qh_info.u.xfs_mdqi.qs_flags & 1)) {
#line 199
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 199
  if (h->qh_type == 1) {
#line 199
    if (! ((int )h->qh_info.u.xfs_mdqi.qs_flags & (1 << 2))) {
#line 200
      return (0);
    }
  } else {
#line 200
    return (0);
  }
  {
#line 202
  tmp = generic_scan_dquots(h, process_dquot, & xfs_get_dquot___7);
  }
#line 202
  return (tmp);
}
}
#line 208 "/home/wheatley/newnew/temp/quota-4.01/quotaio_xfs.c"
static int xfs_report___7(struct quota_handle *h , int verbose ) 
{ 
  u_int16_t sbflags ;
  struct fs_quota_stat *info ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;
  char *tmp___18 ;
  char *tmp___19 ;
  char *tmp___20 ;
  char *tmp___21 ;
  char *tmp___22 ;
  char *tmp___23 ;
  char *tmp___24 ;
  char *tmp___25 ;
  char *tmp___26 ;
  char *tmp___27 ;
  char *tmp___28 ;
  char *tmp___29 ;
  char *tmp___30 ;
  char *tmp___31 ;
  char *tmp___32 ;

  {
#line 211
  info = & h->qh_info.u.xfs_mdqi;
#line 213
  if (! verbose) {
#line 214
    return (0);
  }
  {
#line 217
  tmp = type2name(h->qh_type);
#line 217
  tmp___0 = gettext("*** Status for %s quotas on device %s\n");
#line 217
  printf((char const   */* __restrict  */)tmp___0, tmp, h->qh_quotadev);
  }
#line 220
  if (h->qh_type == 0) {
#line 221
    if ((int )info->qs_flags & (1 << 1)) {
      {
#line 221
      tmp___1 = gettext("ON");
#line 221
      tmp___3 = tmp___1;
      }
    } else {
      {
#line 221
      tmp___2 = gettext("OFF");
#line 221
      tmp___3 = tmp___2;
      }
    }
#line 221
    if ((int )info->qs_flags & 1) {
      {
#line 221
      tmp___4 = gettext("ON");
#line 221
      tmp___6 = tmp___4;
      }
    } else {
      {
#line 221
      tmp___5 = gettext("OFF");
#line 221
      tmp___6 = tmp___5;
      }
    }
    {
#line 221
    tmp___7 = gettext("Accounting: %s; Enforcement: %s\n");
#line 221
    printf((char const   */* __restrict  */)tmp___7, tmp___6, tmp___3);
    }
  } else {
#line 225
    if ((int )info->qs_flags & (1 << 3)) {
      {
#line 225
      tmp___8 = gettext("ON");
#line 225
      tmp___10 = tmp___8;
      }
    } else {
      {
#line 225
      tmp___9 = gettext("OFF");
#line 225
      tmp___10 = tmp___9;
      }
    }
#line 225
    if ((int )info->qs_flags & (1 << 2)) {
      {
#line 225
      tmp___11 = gettext("ON");
#line 225
      tmp___13 = tmp___11;
      }
    } else {
      {
#line 225
      tmp___12 = gettext("OFF");
#line 225
      tmp___13 = tmp___12;
      }
    }
    {
#line 225
    tmp___14 = gettext("Accounting: %s; Enforcement: %s\n");
#line 225
    printf((char const   */* __restrict  */)tmp___14, tmp___13, tmp___10);
    }
  }
#line 235
  sbflags = (u_int16_t )(((int )info->qs_flags & 65280) >> 8);
#line 235
  if ((int )sbflags != 0) {
#line 236
    if (h->qh_type == 0) {
#line 237
      if ((int )sbflags & (1 << 1)) {
        {
#line 237
        tmp___15 = gettext("ON");
#line 237
        tmp___17 = tmp___15;
        }
      } else {
        {
#line 237
        tmp___16 = gettext("OFF");
#line 237
        tmp___17 = tmp___16;
        }
      }
#line 237
      if ((int )sbflags & 1) {
        {
#line 237
        tmp___18 = gettext("ON");
#line 237
        tmp___20 = tmp___18;
        }
      } else {
        {
#line 237
        tmp___19 = gettext("OFF");
#line 237
        tmp___20 = tmp___19;
        }
      }
      {
#line 237
      tmp___21 = gettext("Accounting [ondisk]: %s; Enforcement [ondisk]: %s\n");
#line 237
      printf((char const   */* __restrict  */)tmp___21, tmp___20, tmp___17);
      }
    } else {
#line 241
      if ((int )sbflags & (1 << 3)) {
        {
#line 241
        tmp___22 = gettext("ON");
#line 241
        tmp___24 = tmp___22;
        }
      } else {
        {
#line 241
        tmp___23 = gettext("OFF");
#line 241
        tmp___24 = tmp___23;
        }
      }
#line 241
      if ((int )sbflags & (1 << 2)) {
        {
#line 241
        tmp___25 = gettext("ON");
#line 241
        tmp___27 = tmp___25;
        }
      } else {
        {
#line 241
        tmp___26 = gettext("OFF");
#line 241
        tmp___27 = tmp___26;
        }
      }
      {
#line 241
      tmp___28 = gettext("Accounting [ondisk]: %s; Enforcement [ondisk]: %s\n");
#line 241
      printf((char const   */* __restrict  */)tmp___28, tmp___27, tmp___24);
      }
    }
  }
#line 248
  if (h->qh_type == 0) {
#line 249
    if (info->qs_uquota.qfs_ino == 0xffffffffffffffffULL) {
      {
#line 250
      tmp___29 = gettext("Inode: none\n");
#line 250
      printf((char const   */* __restrict  */)tmp___29);
      }
    } else
#line 249
    if (info->qs_uquota.qfs_ino == 0ULL) {
      {
#line 250
      tmp___29 = gettext("Inode: none\n");
#line 250
      printf((char const   */* __restrict  */)tmp___29);
      }
    } else {
      {
#line 252
      tmp___30 = gettext("Inode: #%llu (%llu blocks, %u extents)\n");
#line 252
      printf((char const   */* __restrict  */)tmp___30, info->qs_uquota.qfs_ino, info->qs_uquota.qfs_nblks,
             info->qs_uquota.qfs_nextents);
      }
    }
  } else
#line 258
  if (info->qs_gquota.qfs_ino == 0xffffffffffffffffULL) {
    {
#line 259
    tmp___31 = gettext("Inode: none\n");
#line 259
    printf((char const   */* __restrict  */)tmp___31);
    }
  } else {
    {
#line 261
    tmp___32 = gettext("Inode: #%llu (%llu blocks, %u extents)\n");
#line 261
    printf((char const   */* __restrict  */)tmp___32, info->qs_gquota.qfs_ino, info->qs_gquota.qfs_nblks,
           info->qs_gquota.qfs_nextents);
    }
  }
#line 266
  return (0);
}
}
#line 31 "/home/wheatley/newnew/temp/quota-4.01/bylabel.c"
static struct uuidCache_s *uuidCache___7  =    (struct uuidCache_s *)((void *)0);
#line 74 "/home/wheatley/newnew/temp/quota-4.01/bylabel.c"
static int get_label_uuid___7(char const   *device , char **label , char *uuid ) 
{ 
  int fd ;
  int rv ;
  size_t namesize ;
  struct ext2_super_block e2sb ;
  struct xfs_super_block xfsb ;
  struct reiserfs_super_block reisersb ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  __off64_t tmp___2 ;
  ssize_t tmp___3 ;
  int tmp___4 ;
  __off64_t tmp___5 ;
  ssize_t tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  __off64_t tmp___9 ;
  ssize_t tmp___10 ;

  {
  {
#line 79
  rv = 1;
#line 85
  fd = open(device, 0);
  }
#line 86
  if (fd < 0) {
#line 87
    return (rv);
  }
  {
#line 89
  tmp___9 = lseek(fd, (__off64_t )1024, 0);
  }
#line 89
  if (tmp___9 == 1024L) {
    {
#line 89
    tmp___10 = read(fd, (void *)((char *)(& e2sb)), sizeof(e2sb));
    }
#line 89
    if ((unsigned long )tmp___10 == sizeof(e2sb)) {
#line 89
      if ((uint )e2sb.s_magic[0] + ((uint )e2sb.s_magic[1] << 8) == 61267U) {
        {
#line 92
        memcpy((void */* __restrict  */)uuid, (void const   */* __restrict  */)(e2sb.s_uuid),
               sizeof(e2sb.s_uuid));
#line 93
        namesize = sizeof(e2sb.s_volume_name);
#line 94
        tmp = smalloc(namesize + 1UL);
#line 94
        *label = (char *)tmp;
#line 95
        sstrncpy(*label, (char const   *)((char *)(e2sb.s_volume_name)), namesize);
#line 96
        rv = 0;
        }
      } else {
#line 89
        goto _L___3;
      }
    } else {
#line 89
      goto _L___3;
    }
  } else {
    _L___3: /* CIL Label */ 
    {
#line 98
    tmp___5 = lseek(fd, (__off64_t )0, 0);
    }
#line 98
    if (tmp___5 == 0L) {
      {
#line 98
      tmp___6 = read(fd, (void *)((char *)(& xfsb)), sizeof(xfsb));
      }
#line 98
      if ((unsigned long )tmp___6 == sizeof(xfsb)) {
        {
#line 98
        tmp___7 = strncmp((char const   *)((char *)(& xfsb.s_magic)), "XFSB", (size_t )4);
        }
#line 98
        if (tmp___7 == 0) {
#line 98
          goto _L___0;
        } else {
          {
#line 98
          tmp___8 = strncmp((char const   *)((char *)(& xfsb.s_magic)), "BSFX", (size_t )4);
          }
#line 98
          if (tmp___8 == 0) {
            _L___0: /* CIL Label */ 
            {
#line 102
            memcpy((void */* __restrict  */)uuid, (void const   */* __restrict  */)(xfsb.s_uuid),
                   sizeof(xfsb.s_uuid));
#line 103
            namesize = sizeof(xfsb.s_fsname);
#line 104
            tmp___0 = smalloc(namesize + 1UL);
#line 104
            *label = (char *)tmp___0;
#line 105
            sstrncpy(*label, (char const   *)((char *)(xfsb.s_fsname)), namesize);
#line 106
            rv = 0;
            }
          } else {
#line 98
            goto _L___1;
          }
        }
      } else {
#line 98
        goto _L___1;
      }
    } else {
      _L___1: /* CIL Label */ 
      {
#line 108
      tmp___2 = lseek(fd, (__off64_t )65536, 0);
      }
#line 108
      if (tmp___2 == 65536L) {
        {
#line 108
        tmp___3 = read(fd, (void *)((char *)(& reisersb)), sizeof(reisersb));
        }
#line 108
        if ((unsigned long )tmp___3 == sizeof(reisersb)) {
          {
#line 108
          tmp___4 = strncmp((char const   *)((char *)(& reisersb.s_magic)), "ReIsEr2Fs",
                            (size_t )9);
          }
#line 108
          if (! tmp___4) {
            {
#line 111
            memcpy((void */* __restrict  */)uuid, (void const   */* __restrict  */)(reisersb.s_uuid),
                   sizeof(reisersb.s_uuid));
#line 112
            namesize = sizeof(reisersb.s_volume_name);
#line 113
            tmp___1 = smalloc(namesize + 1UL);
#line 113
            *label = (char *)tmp___1;
#line 114
            sstrncpy(*label, (char const   *)((char *)(reisersb.s_volume_name)), namesize);
#line 115
            rv = 0;
            }
          }
        }
      }
    }
  }
  {
#line 117
  close(fd);
  }
#line 118
  return (rv);
}
}
#line 121 "/home/wheatley/newnew/temp/quota-4.01/bylabel.c"
static void uuidcache_addentry___7(char *device , char *label , char *uuid ) 
{ 
  struct uuidCache_s *last ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 125
  if (! uuidCache___7) {
    {
#line 126
    tmp = smalloc(sizeof(*uuidCache___7));
#line 126
    uuidCache___7 = (struct uuidCache_s *)tmp;
#line 126
    last = uuidCache___7;
    }
  } else {
#line 129
    last = uuidCache___7;
    {
#line 129
    while (1) {
      while_continue: /* CIL Label */ ;
#line 129
      if (! last->next) {
#line 129
        goto while_break;
      }
#line 129
      last = last->next;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 130
    tmp___0 = smalloc(sizeof(*uuidCache___7));
#line 130
    last->next = (struct uuidCache_s *)tmp___0;
#line 131
    last = last->next;
    }
  }
  {
#line 133
  last->next = (struct uuidCache_s *)((void *)0);
#line 134
  last->device = device;
#line 135
  last->label = label;
#line 136
  memcpy((void */* __restrict  */)(last->uuid), (void const   */* __restrict  */)uuid,
         sizeof(last->uuid));
  }
#line 137
  return;
}
}
#line 144 "/home/wheatley/newnew/temp/quota-4.01/bylabel.c"
static char ptname___7[100]  ;
#line 139 "/home/wheatley/newnew/temp/quota-4.01/bylabel.c"
static void uuidcache_init___7(void) 
{ 
  char line___0[100] ;
  char *s ;
  int ma ;
  int mi ;
  int sz ;
  FILE *procpt ;
  char uuid[16] ;
  char *label ;
  char device[110] ;
  int firstPass ;
  int handleOnFirst ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  unsigned short const   **tmp___4 ;
  char *tmp___5 ;

  {
#line 151
  if (uuidCache___7) {
#line 152
    return;
  }
  {
#line 154
  procpt = fopen((char const   */* __restrict  */)"/proc/partitions", (char const   */* __restrict  */)"r");
  }
#line 155
  if (! procpt) {
#line 156
    return;
  }
#line 158
  firstPass = 1;
  {
#line 158
  while (1) {
    while_continue: /* CIL Label */ ;
#line 158
    if (! (firstPass >= 0)) {
#line 158
      goto while_break;
    }
    {
#line 159
    fseek(procpt, 0L, 0);
    }
    {
#line 161
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 161
      tmp___5 = fgets((char */* __restrict  */)(line___0), (int )sizeof(line___0),
                      (FILE */* __restrict  */)procpt);
      }
#line 161
      if (! tmp___5) {
#line 161
        goto while_break___0;
      }
      {
#line 162
      tmp = sscanf((char const   */* __restrict  */)(line___0), (char const   */* __restrict  */)" %d %d %d %[^\n ]",
                   & ma, & mi, & sz, ptname___7);
      }
#line 162
      if (tmp != 4) {
#line 163
        goto while_continue___0;
      }
#line 166
      if (sz == 1) {
#line 167
        goto while_continue___0;
      }
      {
#line 170
      tmp___0 = strncmp((char const   *)(ptname___7), "md", (size_t )2);
      }
#line 170
      if (tmp___0) {
#line 170
        tmp___1 = 0;
      } else {
#line 170
        tmp___1 = 1;
      }
#line 170
      handleOnFirst = tmp___1;
#line 171
      if (firstPass != handleOnFirst) {
#line 172
        goto while_continue___0;
      }
#line 178
      s = ptname___7;
      {
#line 178
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 178
        if (! *s) {
#line 178
          goto while_break___1;
        }
#line 178
        s ++;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 179
      tmp___4 = __ctype_b_loc();
      }
#line 179
      if ((int const   )*(*tmp___4 + (int )*(s + -1)) & 2048) {
        {
#line 189
        snprintf((char */* __restrict  */)(device), sizeof(device), (char const   */* __restrict  */)"%s/%s",
                 "/dev", ptname___7);
#line 190
        tmp___3 = get_label_uuid___7((char const   *)(device), & label, uuid);
        }
#line 190
        if (! tmp___3) {
          {
#line 191
          tmp___2 = sstrdup((char const   *)(device));
#line 191
          uuidcache_addentry___7(tmp___2, label, uuid);
          }
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 158
    firstPass --;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 196
  fclose(procpt);
  }
#line 197
  return;
}
}
#line 202 "/home/wheatley/newnew/temp/quota-4.01/bylabel.c"
static char *get_spec_by_x___7(int n , char const   *t ) 
{ 
  struct uuidCache_s *uc ;
  char *tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 206
  uuidcache_init___7();
#line 207
  uc = uuidCache___7;
  }
  {
#line 209
  while (1) {
    while_continue: /* CIL Label */ ;
#line 209
    if (! uc) {
#line 209
      goto while_break;
    }
    {
#line 211
    if (n == 1) {
#line 211
      goto case_1;
    }
#line 215
    if (n == 2) {
#line 215
      goto case_2;
    }
#line 210
    goto switch_break;
    case_1: /* CIL Label */ 
    {
#line 212
    tmp___0 = memcmp((void const   *)t, (void const   *)(uc->uuid), sizeof(uc->uuid));
    }
#line 212
    if (! tmp___0) {
      {
#line 213
      tmp = sstrdup((char const   *)uc->device);
      }
#line 213
      return (tmp);
    }
#line 214
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 216
    tmp___2 = strcmp(t, (char const   *)uc->label);
    }
#line 216
    if (! tmp___2) {
      {
#line 217
      tmp___1 = sstrdup((char const   *)uc->device);
      }
#line 217
      return (tmp___1);
    }
#line 218
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 220
    uc = uc->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 222
  return ((char *)((void *)0));
}
}
#line 225 "/home/wheatley/newnew/temp/quota-4.01/bylabel.c"
static u_char fromhex___7(char c ) 
{ 
  unsigned short const   **tmp ;
  unsigned short const   **tmp___0 ;

  {
  {
#line 227
  tmp___0 = __ctype_b_loc();
  }
#line 227
  if ((int const   )*(*tmp___0 + (int )c) & 2048) {
#line 228
    return ((u_char )((int )c - 48));
  } else {
    {
#line 229
    tmp = __ctype_b_loc();
    }
#line 229
    if ((int const   )*(*tmp + (int )c) & 512) {
#line 230
      return ((u_char )(((int )c - 97) + 10));
    } else {
#line 232
      return ((u_char )(((int )c - 65) + 10));
    }
  }
}
}
#line 235 "/home/wheatley/newnew/temp/quota-4.01/bylabel.c"
static char *get_spec_by_uuid___7(char const   *s ) 
{ 
  u_char uuid[16] ;
  int i ;
  size_t tmp ;
  unsigned short const   **tmp___0 ;
  unsigned short const   **tmp___1 ;
  u_char tmp___2 ;
  u_char tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;

  {
  {
#line 240
  tmp = strlen(s);
  }
#line 240
  if (tmp != 36UL) {
#line 241
    goto bad_uuid;
  } else
#line 240
  if ((int const   )*(s + 8) != 45) {
#line 241
    goto bad_uuid;
  } else
#line 240
  if ((int const   )*(s + 13) != 45) {
#line 241
    goto bad_uuid;
  } else
#line 240
  if ((int const   )*(s + 18) != 45) {
#line 241
    goto bad_uuid;
  } else
#line 240
  if ((int const   )*(s + 23) != 45) {
#line 241
    goto bad_uuid;
  }
#line 242
  i = 0;
  {
#line 242
  while (1) {
    while_continue: /* CIL Label */ ;
#line 242
    if (! (i < 16)) {
#line 242
      goto while_break;
    }
#line 243
    if ((int const   )*s == 45) {
#line 244
      s ++;
    }
    {
#line 245
    tmp___0 = __ctype_b_loc();
    }
#line 245
    if ((int const   )*(*tmp___0 + (int )*(s + 0)) & 4096) {
      {
#line 245
      tmp___1 = __ctype_b_loc();
      }
#line 245
      if (! ((int const   )*(*tmp___1 + (int )*(s + 1)) & 4096)) {
#line 246
        goto bad_uuid;
      }
    } else {
#line 246
      goto bad_uuid;
    }
    {
#line 247
    tmp___2 = fromhex___7((char )*(s + 0));
#line 247
    tmp___3 = fromhex___7((char )*(s + 1));
#line 247
    uuid[i] = (u_char )(((int )tmp___2 << 4) | (int )tmp___3);
#line 248
    s += 2;
#line 242
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 250
  tmp___4 = get_spec_by_x___7(1, (char const   *)((char *)(uuid)));
  }
#line 250
  return (tmp___4);
  bad_uuid: 
  {
#line 253
  tmp___5 = gettext("Found an invalid UUID: %s\n");
#line 253
  errstr(tmp___5, s);
  }
#line 254
  return ((char *)((void *)0));
}
}
#line 257 "/home/wheatley/newnew/temp/quota-4.01/bylabel.c"
static char *get_spec_by_volume_label___7(char const   *s ) 
{ 
  char *tmp ;

  {
  {
#line 259
  tmp = get_spec_by_x___7(2, s);
  }
#line 259
  return (tmp);
}
}
#line 50 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v1.c"
static int v1_check_file___7(int fd , int type , int fmt___7 ) ;
#line 51
static int v1_init_io___7(struct quota_handle *h ) ;
#line 52
static int v1_new_io___7(struct quota_handle *h ) ;
#line 53
static int v1_write_info___7(struct quota_handle *h ) ;
#line 54
static struct dquot *v1_read_dquot___7(struct quota_handle *h , qid_t id___0 ) ;
#line 55
static int v1_commit_dquot___7(struct dquot *dquot , int flags___7 ) ;
#line 56
static int v1_scan_dquots___7(struct quota_handle *h , int (*process_dquot)(struct dquot *dquot ,
                                                                            char *dqname ) ) ;
#line 127 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v1.c"
static int v1_check_file___7(int fd , int type , int fmt___7 ) 
{ 
  struct stat st ;
  int tmp ;

  {
  {
#line 131
  tmp = fstat(fd, & st);
  }
#line 131
  if (tmp < 0) {
#line 132
    return (0);
  }
#line 133
  if (! st.st_size) {
#line 134
    return (0);
  } else
#line 133
  if ((unsigned long )st.st_size % sizeof(struct v1_disk_dqblk )) {
#line 134
    return (0);
  }
#line 135
  return (1);
}
}
#line 141 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v1.c"
static int v1_init_io___7(struct quota_handle *h ) 
{ 
  int tmp ;
  struct v1_kern_dqblk kdqblk ;
  time_t tmp___0 ;
  int *tmp___1 ;
  long tmp___2 ;
  struct v1_disk_dqblk ddqblk ;
  ssize_t tmp___3 ;

  {
#line 143
  if (h->qh_io_flags & 1) {
#line 144
    if (kernel_iface == 3) {
      {
#line 145
      tmp = vfs_get_info(h);
      }
#line 145
      if (tmp < 0) {
#line 146
        return (-1);
      }
    } else {
      {
#line 151
      tmp___2 = quotactl((768 << 8) | (h->qh_type & 255), (char const   *)(h->qh_quotadev),
                         (qid_t )0, (caddr_t )((void *)(& kdqblk)));
      }
#line 151
      if (tmp___2 < 0L) {
        {
#line 152
        tmp___1 = __errno_location();
        }
#line 152
        if (*tmp___1 == 1) {
#line 153
          tmp___0 = (time_t )0;
#line 153
          h->qh_info.dqi_igrace = tmp___0;
#line 153
          h->qh_info.dqi_bgrace = tmp___0;
        } else {
#line 156
          return (-1);
        }
      } else {
#line 159
        h->qh_info.dqi_bgrace = kdqblk.dqb_btime;
#line 160
        h->qh_info.dqi_igrace = kdqblk.dqb_itime;
      }
    }
  } else {
    {
#line 167
    lseek(h->qh_fd, (__off64_t )0, 0);
#line 168
    tmp___3 = read(h->qh_fd, (void *)(& ddqblk), sizeof(ddqblk));
    }
#line 168
    if ((unsigned long )tmp___3 != sizeof(ddqblk)) {
#line 169
      return (-1);
    }
#line 170
    h->qh_info.dqi_bgrace = ddqblk.dqb_btime;
#line 171
    h->qh_info.dqi_igrace = ddqblk.dqb_itime;
  }
#line 173
  if (! h->qh_info.dqi_bgrace) {
#line 174
    h->qh_info.dqi_bgrace = (time_t )604800;
  }
#line 175
  if (! h->qh_info.dqi_igrace) {
#line 176
    h->qh_info.dqi_igrace = (time_t )604800;
  }
#line 177
  h->qh_info.dqi_max_b_limit = (uint64_t )(~ ((uint32_t )0));
#line 178
  h->qh_info.dqi_max_i_limit = (uint64_t )(~ ((uint32_t )0));
#line 179
  h->qh_info.dqi_max_b_usage = 4294967295UL << 10;
#line 180
  h->qh_info.dqi_max_i_usage = (uint64_t )(~ ((uint32_t )0));
#line 182
  return (0);
}
}
#line 188 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v1.c"
static int v1_new_io___7(struct quota_handle *h ) 
{ 
  struct v1_disk_dqblk ddqblk ;
  ssize_t tmp ;

  {
  {
#line 193
  memset((void *)(& ddqblk), 0, sizeof(ddqblk));
#line 194
  ddqblk.dqb_btime = (time_t )604800;
#line 195
  ddqblk.dqb_itime = (time_t )604800;
#line 196
  h->qh_info.dqi_bgrace = (time_t )604800;
#line 197
  h->qh_info.dqi_igrace = (time_t )604800;
#line 198
  h->qh_info.dqi_max_b_limit = (uint64_t )(~ ((uint32_t )0));
#line 199
  h->qh_info.dqi_max_i_limit = (uint64_t )(~ ((uint32_t )0));
#line 200
  h->qh_info.dqi_max_b_usage = 4294967295UL << 10;
#line 201
  h->qh_info.dqi_max_i_usage = (uint64_t )(~ ((uint32_t )0));
#line 202
  lseek(h->qh_fd, (__off64_t )0, 0);
#line 203
  tmp = write(h->qh_fd, (void const   *)(& ddqblk), sizeof(ddqblk));
  }
#line 203
  if ((unsigned long )tmp != sizeof(ddqblk)) {
#line 204
    return (-1);
  }
#line 205
  return (0);
}
}
#line 211 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v1.c"
static int v1_write_info___7(struct quota_handle *h ) 
{ 
  char *tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  struct v1_kern_dqblk kdqblk ;
  long tmp___2 ;
  long tmp___3 ;
  struct v1_disk_dqblk ddqblk ;
  ssize_t tmp___4 ;
  ssize_t tmp___5 ;

  {
#line 213
  if (h->qh_io_flags & 4) {
    {
#line 214
    tmp = gettext("Trying to write info to readonly quotafile on %s.\n");
#line 214
    errstr(tmp, h->qh_quotadev);
#line 215
    tmp___0 = __errno_location();
#line 215
    *tmp___0 = 1;
    }
#line 216
    return (-1);
  }
#line 218
  if (h->qh_io_flags & 1) {
#line 219
    if (kernel_iface == 3) {
      {
#line 220
      tmp___1 = vfs_set_info(h, 3);
      }
#line 220
      if (tmp___1 < 0) {
#line 221
        return (-1);
      }
    } else {
      {
#line 226
      tmp___2 = quotactl((768 << 8) | (h->qh_type & 255), (char const   *)(h->qh_quotadev),
                         (qid_t )0, (caddr_t )((void *)(& kdqblk)));
      }
#line 226
      if (tmp___2 < 0L) {
#line 227
        return (-1);
      }
      {
#line 228
      kdqblk.dqb_btime = h->qh_info.dqi_bgrace;
#line 229
      kdqblk.dqb_itime = h->qh_info.dqi_igrace;
#line 230
      tmp___3 = quotactl((1024 << 8) | (h->qh_type & 255), (char const   *)(h->qh_quotadev),
                         (qid_t )0, (caddr_t )((void *)(& kdqblk)));
      }
#line 230
      if (tmp___3 < 0L) {
#line 231
        return (-1);
      }
    }
  } else {
    {
#line 237
    lseek(h->qh_fd, (__off64_t )0, 0);
#line 238
    tmp___4 = read(h->qh_fd, (void *)(& ddqblk), sizeof(ddqblk));
    }
#line 238
    if ((unsigned long )tmp___4 != sizeof(ddqblk)) {
#line 239
      return (-1);
    }
    {
#line 240
    ddqblk.dqb_btime = h->qh_info.dqi_bgrace;
#line 241
    ddqblk.dqb_itime = h->qh_info.dqi_igrace;
#line 242
    lseek(h->qh_fd, (__off64_t )0, 0);
#line 243
    tmp___5 = write(h->qh_fd, (void const   *)(& ddqblk), sizeof(ddqblk));
    }
#line 243
    if ((unsigned long )tmp___5 != sizeof(ddqblk)) {
#line 244
      return (-1);
    }
  }
#line 246
  return (0);
}
}
#line 253 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v1.c"
static struct dquot *v1_read_dquot___7(struct quota_handle *h , qid_t id___0 ) 
{ 
  struct v1_disk_dqblk ddqblk ;
  struct dquot *dquot ;
  struct dquot *tmp ;
  int tmp___0 ;
  struct v1_kern_dqblk kdqblk ;
  long tmp___1 ;
  ssize_t tmp___2 ;

  {
  {
#line 256
  tmp = get_empty_dquot();
#line 256
  dquot = tmp;
#line 258
  dquot->dq_id = id___0;
#line 259
  dquot->dq_h = h;
  }
#line 260
  if (h->qh_io_flags & 1) {
#line 261
    if (kernel_iface == 3) {
      {
#line 262
      tmp___0 = vfs_get_dquot(dquot);
      }
#line 262
      if (tmp___0 < 0) {
        {
#line 263
        free((void *)dquot);
        }
#line 264
        return ((struct dquot *)((void *)0));
      }
    } else {
      {
#line 270
      tmp___1 = quotactl((768 << 8) | (h->qh_type & 255), (char const   *)(h->qh_quotadev),
                         id___0, (caddr_t )((void *)(& kdqblk)));
      }
#line 270
      if (tmp___1 < 0L) {
        {
#line 271
        free((void *)dquot);
        }
#line 272
        return ((struct dquot *)((void *)0));
      }
      {
#line 274
      v1_kern2utildqblk(& dquot->dq_dqb, & kdqblk);
      }
    }
  } else {
    {
#line 278
    lseek(h->qh_fd, (loff_t )((unsigned long )id___0 * sizeof(struct v1_disk_dqblk )),
          0);
#line 279
    tmp___2 = read(h->qh_fd, (void *)(& ddqblk), sizeof(ddqblk));
    }
    {
#line 280
    if (tmp___2 == 0L) {
#line 280
      goto case_0;
    }
#line 287
    if (tmp___2 == (ssize_t )sizeof(struct v1_disk_dqblk )) {
#line 287
      goto case_exp;
    }
#line 290
    goto switch_default;
    case_0: /* CIL Label */ 
    {
#line 285
    memset((void *)(& dquot->dq_dqb), 0, sizeof(struct util_dqblk ));
    }
#line 286
    goto switch_break;
    case_exp: /* CIL Label */ 
    {
#line 288
    v1_disk2memdqblk(& dquot->dq_dqb, & ddqblk);
    }
#line 289
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 291
    free((void *)dquot);
    }
#line 292
    return ((struct dquot *)((void *)0));
    switch_break: /* CIL Label */ ;
    }
  }
#line 295
  return (dquot);
}
}
#line 302 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v1.c"
static int v1_commit_dquot___7(struct dquot *dquot , int flags___7 ) 
{ 
  struct v1_disk_dqblk ddqblk ;
  struct quota_handle *h ;
  char *tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  struct v1_kern_dqblk kdqblk ;
  int cmd ;
  int *tmp___2 ;
  long tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;
  ssize_t tmp___6 ;

  {
#line 305
  h = dquot->dq_h;
#line 307
  if (h->qh_io_flags & 4) {
    {
#line 308
    tmp = gettext("Trying to write quota to readonly quotafile on %s\n");
#line 308
    errstr(tmp, h->qh_quotadev);
#line 309
    tmp___0 = __errno_location();
#line 309
    *tmp___0 = 1;
    }
#line 310
    return (-1);
  }
#line 312
  if (h->qh_io_flags & 1) {
#line 313
    if (kernel_iface == 3) {
      {
#line 314
      tmp___1 = vfs_set_dquot(dquot, flags___7);
      }
#line 314
      if (tmp___1 < 0) {
#line 315
        return (-1);
      }
    } else {
#line 321
      if (flags___7 == 10) {
#line 322
        cmd = 1280;
      } else
#line 323
      if (flags___7 == 5) {
#line 324
        cmd = 1792;
      } else
#line 325
      if (flags___7 & 48) {
        {
#line 326
        tmp___2 = __errno_location();
#line 326
        *tmp___2 = 22;
        }
#line 327
        return (-1);
      } else {
#line 330
        cmd = 1024;
      }
      {
#line 331
      v1_util2kerndqblk(& kdqblk, & dquot->dq_dqb);
#line 332
      tmp___3 = quotactl((cmd << 8) | (h->qh_type & 255), (char const   *)(h->qh_quotadev),
                         dquot->dq_id, (caddr_t )((void *)(& kdqblk)));
      }
#line 332
      if (tmp___3 < 0L) {
#line 334
        return (-1);
      }
    }
  } else {
    {
#line 338
    tmp___5 = check_dquot_range(dquot);
    }
#line 338
    if (tmp___5 < 0) {
      {
#line 339
      tmp___4 = __errno_location();
#line 339
      *tmp___4 = 34;
      }
#line 340
      return (-1);
    }
    {
#line 342
    v1_mem2diskdqblk(& ddqblk, & dquot->dq_dqb);
#line 343
    lseek(h->qh_fd, (loff_t )((unsigned long )dquot->dq_id * sizeof(struct v1_disk_dqblk )),
          0);
#line 344
    tmp___6 = write(h->qh_fd, (void const   *)(& ddqblk), sizeof(ddqblk));
    }
#line 344
    if ((unsigned long )tmp___6 != sizeof(ddqblk)) {
#line 345
      return (-1);
    }
  }
#line 347
  return (0);
}
}
#line 355 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v1.c"
static int v1_scan_dquots___7(struct quota_handle *h , int (*process_dquot)(struct dquot *dquot ,
                                                                            char *dqname ) ) 
{ 
  int rd ;
  int scanbufpos ;
  int scanbufsize ;
  char scanbuf[sizeof(struct v1_disk_dqblk ) * 256UL] ;
  struct v1_disk_dqblk *ddqblk ;
  struct dquot *dquot ;
  struct dquot *tmp ;
  qid_t id___0 ;
  ssize_t tmp___0 ;

  {
  {
#line 357
  scanbufpos = 0;
#line 357
  scanbufsize = 0;
#line 360
  tmp = get_empty_dquot();
#line 360
  dquot = tmp;
#line 361
  id___0 = (qid_t )0;
#line 363
  memset((void *)dquot, 0, sizeof(*dquot));
#line 364
  dquot->dq_h = h;
#line 365
  lseek(h->qh_fd, (__off64_t )0, 0);
#line 366
  id___0 = (qid_t )0;
  }
  {
#line 366
  while (1) {
    while_continue: /* CIL Label */ ;
#line 367
    if (scanbufpos >= scanbufsize) {
      {
#line 368
      tmp___0 = read(h->qh_fd, (void *)(scanbuf), sizeof(scanbuf));
#line 368
      rd = (int )tmp___0;
      }
#line 369
      if (rd < 0) {
#line 370
        goto out_err;
      } else
#line 369
      if ((unsigned long )rd % sizeof(struct v1_disk_dqblk )) {
#line 370
        goto out_err;
      }
#line 371
      if (! rd) {
#line 372
        goto while_break;
      }
#line 373
      scanbufpos = 0;
#line 374
      scanbufsize = (int )((unsigned long )rd / sizeof(struct v1_disk_dqblk ));
    }
#line 376
    ddqblk = (struct v1_disk_dqblk *)(scanbuf) + scanbufpos;
#line 377
    if ((((long )(((((ddqblk->dqb_ihardlimit | ddqblk->dqb_isoftlimit) | ddqblk->dqb_bhardlimit) | ddqblk->dqb_bsoftlimit) | ddqblk->dqb_curblocks) | ddqblk->dqb_curinodes) | ddqblk->dqb_itime) | ddqblk->dqb_btime) == 0L) {
#line 381
      goto __Cont;
    }
    {
#line 382
    v1_disk2memdqblk(& dquot->dq_dqb, ddqblk);
#line 383
    dquot->dq_id = id___0;
#line 384
    rd = (*process_dquot)(dquot, (char *)((void *)0));
    }
#line 384
    if (rd < 0) {
      {
#line 385
      free((void *)dquot);
      }
#line 386
      return (rd);
    }
    __Cont: /* CIL Label */ 
#line 366
    id___0 ++;
#line 366
    scanbufpos ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 389
  if (! rd) {
    {
#line 390
    free((void *)dquot);
    }
#line 391
    return (0);
  }
  out_err: 
  {
#line 394
  free((void *)dquot);
  }
#line 395
  return (-1);
}
}
#line 89 "/home/wheatley/newnew/temp/quota-4.01/rquota_client.c"
static int rquota_err___7(int stat___0 ) 
{ 


  {
  {
#line 92
  if (stat___0 == -1) {
#line 92
    goto case_neg_1;
  }
#line 94
  if (stat___0 == 0) {
#line 94
    goto case_0;
  }
#line 96
  if (stat___0 == 2) {
#line 96
    goto case_2;
  }
#line 98
  if (stat___0 == 1) {
#line 98
    goto case_1;
  }
#line 100
  if (stat___0 == 3) {
#line 100
    goto case_3;
  }
#line 102
  goto switch_default;
  case_neg_1: /* CIL Label */ 
#line 93
  return (-111);
  case_0: /* CIL Label */ 
#line 95
  return (-38);
  case_2: /* CIL Label */ 
#line 97
  return (-2);
  case_1: /* CIL Label */ 
#line 99
  return (0);
  case_3: /* CIL Label */ 
#line 101
  return (-1);
  switch_default: /* CIL Label */ 
#line 103
  return (-22);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 107 "/home/wheatley/newnew/temp/quota-4.01/rquota_client.c"
static int split_nfs_mount___7(char *devname , char **host , char **path ) 
{ 
  char *pathname ;

  {
#line 112
  if ((int )*devname == 91) {
    {
#line 113
    *host = devname + 1;
#line 114
    pathname = strchr((char const   *)devname, ']');
    }
#line 115
    if (! pathname) {
#line 116
      return (0);
    } else
#line 115
    if ((int )*(pathname + 1) != 58) {
#line 116
      return (0);
    }
#line 118
    if ((int )*(pathname + 2) == 40) {
#line 119
      return (0);
    }
#line 120
    *pathname = (char)0;
#line 121
    *path = pathname + 2;
#line 122
    return (1);
  }
  {
#line 124
  *host = devname;
#line 125
  pathname = strchr((char const   *)devname, ':');
  }
#line 126
  if (! pathname) {
#line 127
    return (0);
  }
#line 129
  if ((int )*(pathname + 1) == 40) {
#line 130
    return (0);
  }
#line 131
  *pathname = (char)0;
#line 132
  *path = pathname + 1;
#line 133
  return (1);
}
}
#line 41 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static char extensions___8[4][20]  = { {        (char )'u',        (char )'s',        (char )'e',        (char )'r', 
            (char )'\000'}, 
   {        (char )'g',        (char )'r',        (char )'o',        (char )'u', 
            (char )'p',        (char )'\000'}, 
   {        (char )'u',        (char )'n',        (char )'d',        (char )'e', 
            (char )'f',        (char )'i',        (char )'n',        (char )'e', 
            (char )'d',        (char )'\000'}};
#line 42 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static char *basenames___8[6]  = {      (char *)"quota",      (char *)"aquota",      (char *)"aquota",      (char *)"", 
        (char *)"",      (char *)""};
#line 43 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static char *fmtnames___7[5]  = {      (char *)"vfsold",      (char *)"vfsv0",      (char *)"vfsv1",      (char *)"rpc", 
        (char *)"xfs"};
#line 245 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static int kern2utilfmt___7(int kernfmt ) 
{ 


  {
  {
#line 248
  if (kernfmt == 1) {
#line 248
    goto case_1;
  }
#line 250
  if (kernfmt == 2) {
#line 250
    goto case_2;
  }
#line 252
  if (kernfmt == 4) {
#line 252
    goto case_4;
  }
#line 254
  if (kernfmt == 3) {
#line 254
    goto case_3;
  }
#line 247
  goto switch_break;
  case_1: /* CIL Label */ 
#line 249
  return (0);
  case_2: /* CIL Label */ 
#line 251
  return (1);
  case_4: /* CIL Label */ 
#line 253
  return (2);
  case_3: /* CIL Label */ 
#line 255
  return (5);
  switch_break: /* CIL Label */ ;
  }
#line 257
  return (-1);
}
}
#line 394 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static int hasxfsquota___7(char const   *dev , struct mntent *mnt___2 , int type ,
                           int flags___7 ) 
{ 
  u_int16_t sbflags ;
  struct fs_quota_stat info ;
  long tmp ;

  {
#line 399
  if (flags___7 & 16) {
#line 400
    return (4);
  }
  {
#line 402
  memset((void *)(& info), 0, sizeof(struct fs_quota_stat ));
#line 403
  tmp = quotactl((((88 << 8) + 5) << 8) | (type & 255), dev, (qid_t )0, (caddr_t )((void *)(& info)));
  }
#line 403
  if (! tmp) {
#line 404
    sbflags = (u_int16_t )(((int )info.qs_flags & 65280) >> 8);
#line 405
    if (type == 0) {
#line 405
      if ((int )info.qs_flags & 1) {
#line 406
        return (4);
      } else {
#line 405
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 407
    if (type == 1) {
#line 407
      if ((int )info.qs_flags & (1 << 2)) {
#line 408
        return (4);
      }
    }
  }
#line 424
  return (-1);
}
}
#line 427 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static int hasvfsmetaquota___7(char const   *dev , struct mntent *mnt___2 , int type ,
                               int flags___7 ) 
{ 
  uint32_t fmt___7 ;
  long tmp ;

  {
  {
#line 431
  tmp = quotactl((8388612 << 8) | (type & 255), dev, (qid_t )0, (caddr_t )((void *)(& fmt___7)));
  }
#line 431
  if (! tmp) {
#line 432
    return (5);
  }
#line 433
  return (-1);
}
}
#line 465 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static char *hasmntoptarg___7(char const   *optstring , char const   *opt ) 
{ 
  char *p ;
  char *tmp ;
  size_t tmp___0 ;

  {
  {
#line 467
  tmp = str_hasmntopt(optstring, opt);
#line 467
  p = tmp;
  }
#line 469
  if (! p) {
#line 470
    return ((char *)((void *)0));
  }
  {
#line 471
  tmp___0 = strlen(opt);
#line 471
  p += tmp___0;
  }
#line 472
  if ((int )*p == 61) {
#line 472
    if ((int )*(p + 1) != 44) {
#line 473
      return (p + 1);
    }
  }
#line 474
  return ((char *)((void *)0));
}
}
#line 478 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static void copy_mntoptarg___7(char *buf , char const   *optarg___0 , int buflen ) 
{ 
  char *sep ;
  char *tmp ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  long tmp___4 ;

  {
  {
#line 480
  tmp = strchr(optarg___0, ',');
#line 480
  sep = tmp;
  }
#line 482
  if (! sep) {
    {
#line 483
    tmp___3 = strlen(optarg___0);
    }
#line 483
    if ((size_t )buflen < tmp___3 + 1UL) {
#line 483
      tmp___2 = (size_t )buflen;
    } else {
      {
#line 483
      tmp___1 = strlen(optarg___0);
#line 483
      tmp___2 = tmp___1 + 1UL;
      }
    }
    {
#line 483
    sstrncpy(buf, optarg___0, tmp___2);
    }
  } else {
#line 485
    if ((long )buflen < (sep - (char *)optarg___0) + 1L) {
#line 485
      tmp___4 = (long )buflen;
    } else {
#line 485
      tmp___4 = (sep - (char *)optarg___0) + 1L;
    }
    {
#line 485
    sstrncpy(buf, optarg___0, (size_t )tmp___4);
    }
  }
#line 486
  return;
}
}
#line 491 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static int hasquota___7(char const   *dev , struct mntent *mnt___2 , int type , int flags___7 ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  struct if_dqinfo kinfo ;
  long tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;

  {
  {
#line 493
  tmp___0 = strcmp((char const   *)mnt___2->mnt_type, "gfs2");
  }
#line 493
  if (tmp___0) {
    {
#line 493
    tmp___1 = strcmp((char const   *)mnt___2->mnt_type, "xfs");
    }
#line 493
    if (! tmp___1) {
      {
#line 495
      tmp = hasxfsquota___7(dev, mnt___2, type, flags___7);
      }
#line 495
      return (tmp);
    }
  } else {
    {
#line 495
    tmp = hasxfsquota___7(dev, mnt___2, type, flags___7);
    }
#line 495
    return (tmp);
  }
  {
#line 496
  tmp___3 = strcmp((char const   *)mnt___2->mnt_type, "ocfs2");
  }
#line 496
  if (! tmp___3) {
    {
#line 497
    tmp___2 = hasvfsmetaquota___7(dev, mnt___2, type, flags___7);
    }
#line 497
    return (tmp___2);
  }
  {
#line 504
  tmp___5 = strcmp((char const   *)mnt___2->mnt_type, "ext4");
  }
#line 504
  if (! tmp___5) {
    {
#line 507
    tmp___4 = quotactl((8388613 << 8) | (type & 255), dev, (qid_t )0, (caddr_t )((void *)(& kinfo)));
    }
#line 507
    if (tmp___4 == 0L) {
#line 508
      if (kinfo.dqi_flags & 65536U) {
#line 509
        return (5);
      }
    }
  }
  {
#line 513
  tmp___6 = nfs_fstype(mnt___2->mnt_type);
  }
#line 513
  if (tmp___6) {
#line 514
    return (3);
  }
#line 516
  if (type == 0) {
    {
#line 516
    tmp___7 = hasmntopt((struct mntent  const  *)mnt___2, "usrquota");
    }
#line 516
    if (tmp___7) {
#line 517
      return (6);
    } else {
      {
#line 516
      tmp___8 = hasmntoptarg___7((char const   *)mnt___2->mnt_opts, "usrjquota");
      }
#line 516
      if (tmp___8) {
#line 517
        return (6);
      }
    }
  }
#line 518
  if (type == 1) {
    {
#line 518
    tmp___9 = hasmntopt((struct mntent  const  *)mnt___2, "grpquota");
    }
#line 518
    if (tmp___9) {
#line 519
      return (6);
    } else {
      {
#line 518
      tmp___10 = hasmntoptarg___7((char const   *)mnt___2->mnt_opts, "grpjquota");
      }
#line 518
      if (tmp___10) {
#line 519
        return (6);
      }
    }
  }
#line 520
  if (type == 0) {
    {
#line 520
    tmp___11 = hasmntopt((struct mntent  const  *)mnt___2, "quota");
    }
#line 520
    if (tmp___11) {
#line 521
      return (6);
    }
  }
#line 522
  return (-1);
}
}
#line 526 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static int check_fmtfile_ok___7(char *name , int type , int fmt___7 , int flags___7 ) 
{ 
  struct stat st ;
  int *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;
  int fd ;
  int ret ;
  int tmp___4 ;
  int *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  int *tmp___8 ;
  int *tmp___9 ;

  {
#line 528
  if (! flags___7) {
#line 529
    return (1);
  }
#line 530
  if (flags___7 & 1) {
    {
#line 533
    tmp___3 = stat((char const   */* __restrict  */)name, (struct stat */* __restrict  */)(& st));
    }
#line 533
    if (tmp___3 < 0) {
      {
#line 534
      tmp___2 = __errno_location();
      }
#line 534
      if (*tmp___2 != 2) {
        {
#line 535
        tmp = __errno_location();
#line 535
        tmp___0 = strerror(*tmp);
#line 535
        tmp___1 = gettext("Cannot stat quota file %s: %s\n");
#line 535
        errstr(tmp___1, name, tmp___0);
        }
      }
#line 536
      return (0);
    }
  }
#line 539
  if (flags___7 & 2) {
    {
#line 540
    ret = 0;
#line 542
    fd = open((char const   *)name, 0);
    }
#line 542
    if (fd >= 0) {
      {
#line 543
      tmp___4 = is_tree_qfmt(fmt___7);
      }
#line 543
      if (tmp___4) {
        {
#line 544
        ret = (*(quotafile_ops_2.check_file))(fd, type, fmt___7);
        }
      } else {
        {
#line 546
        ret = (*(quotafile_ops_1.check_file))(fd, type, fmt___7);
        }
      }
      {
#line 547
      close(fd);
      }
#line 548
      if (ret <= 0) {
#line 549
        return (0);
      }
    } else {
      {
#line 551
      tmp___8 = __errno_location();
      }
#line 551
      if (*tmp___8 != 2) {
        {
#line 551
        tmp___9 = __errno_location();
        }
#line 551
        if (*tmp___9 != 1) {
          {
#line 552
          tmp___5 = __errno_location();
#line 552
          tmp___6 = strerror(*tmp___5);
#line 552
          tmp___7 = gettext("Cannot open quotafile %s: %s\n");
#line 552
          errstr(tmp___7, name, tmp___6);
          }
#line 553
          return (0);
        }
      }
    }
  }
#line 556
  return (1);
}
}
#line 629 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static int hlist_allocated___7  =    0;
#line 630 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static struct quota_handle **hlist___7  =    (struct quota_handle **)((void *)0);
#line 735 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static int kernel_qfmt_num___7  ;
#line 736 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static int kernel_qfmt___7[6]  ;
#line 828 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static int v1_kern_quota_on___7(char const   *dev , int type ) 
{ 
  char tmp[1024] ;
  qid_t id___0 ;
  __uid_t tmp___0 ;
  __gid_t tmp___1 ;
  __uid_t tmp___2 ;
  long tmp___3 ;

  {
#line 831
  if (type == 0) {
    {
#line 831
    tmp___0 = getuid();
#line 831
    tmp___2 = tmp___0;
    }
  } else {
    {
#line 831
    tmp___1 = getgid();
#line 831
    tmp___2 = tmp___1;
    }
  }
  {
#line 831
  id___0 = tmp___2;
#line 833
  tmp___3 = quotactl((768 << 8) | (type & 255), dev, id___0, tmp);
  }
#line 833
  if (! tmp___3) {
#line 834
    return (1);
  }
#line 835
  return (0);
}
}
#line 839 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static int v2_kern_quota_on___7(char const   *dev , int type ) 
{ 
  char tmp[1024] ;
  qid_t id___0 ;
  __uid_t tmp___0 ;
  __gid_t tmp___1 ;
  __uid_t tmp___2 ;
  long tmp___3 ;

  {
#line 842
  if (type == 0) {
    {
#line 842
    tmp___0 = getuid();
#line 842
    tmp___2 = tmp___0;
    }
  } else {
    {
#line 842
    tmp___1 = getgid();
#line 842
    tmp___2 = tmp___1;
    }
  }
  {
#line 842
  id___0 = tmp___2;
#line 844
  tmp___3 = quotactl((3328 << 8) | (type & 255), dev, id___0, tmp);
  }
#line 844
  if (! tmp___3) {
#line 845
    return (1);
  }
#line 846
  return (0);
}
}
#line 850 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static int xfs_kern_quota_on___7(char const   *dev , int type ) 
{ 
  struct fs_quota_stat info ;
  long tmp ;

  {
  {
#line 854
  tmp = quotactl((((88 << 8) + 5) << 8) | (type & 255), dev, (qid_t )0, (caddr_t )((void *)(& info)));
  }
#line 854
  if (! tmp) {
#line 855
    if (type == 0) {
#line 855
      if ((int )info.qs_flags & 1) {
#line 856
        return (1);
      }
    }
#line 857
    if (type == 1) {
#line 857
      if ((int )info.qs_flags & (1 << 2)) {
#line 858
        return (1);
      }
    }
  }
#line 860
  return (0);
}
}
#line 921 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static int mnt_entries_cnt___7  ;
#line 922 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static struct mount_entry *mnt_entries___7  ;
#line 923 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static int check_dirs_cnt___7  ;
#line 923 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static int act_checked___7  ;
#line 924 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static struct searched_dir *check_dirs___7  ;
#line 927 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static int cache_mnt_table___7(int flags___7 ) 
{ 
  FILE *mntf ;
  struct mntent *mnt___2 ;
  struct stat st ;
  struct statfs fsstat ;
  int allocated ;
  int i ;
  dev_t dev ;
  char mntpointbuf[4096] ;
  int autofsdircnt ;
  int autofsdir_allocated ;
  char **autofsdir ;
  char *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  char const   *devname ;
  char *opt ;
  int qfmt[2] ;
  char *tmp___2 ;
  int slen ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  void *tmp___6 ;
  size_t tmp___7 ;
  void *tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char loopdev[4096] ;
  char *tmp___13 ;
  int *tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;
  int *tmp___18 ;
  char *tmp___19 ;
  char *tmp___20 ;
  int tmp___21 ;
  int *tmp___22 ;
  char *tmp___23 ;
  char *tmp___24 ;
  int tmp___25 ;
  char *tmp___26 ;
  int tmp___27 ;
  int *tmp___28 ;
  char *tmp___29 ;
  char *tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;
  void *tmp___34 ;
  char *tmp___35 ;

  {
  {
#line 933
  allocated = 0;
#line 933
  i = 0;
#line 934
  dev = (dev_t )0;
#line 940
  mntf = setmntent("/proc/mounts", "r");
  }
#line 941
  if (mntf) {
#line 942
    goto alloc;
  }
  {
#line 944
  mntf = setmntent("/etc/mtab", "r");
  }
#line 945
  if (mntf) {
#line 946
    goto alloc;
  }
  {
#line 948
  mntf = setmntent("/etc/fstab", "r");
  }
#line 948
  if (! mntf) {
    {
#line 949
    tmp = gettext("Cannot open any file with mount points.\n");
#line 949
    errstr(tmp);
    }
#line 950
    return (-1);
  }
  alloc: 
  {
#line 954
  tmp___0 = smalloc(sizeof(struct mount_entry ) * 16UL);
#line 954
  mnt_entries___7 = (struct mount_entry *)tmp___0;
#line 955
  mnt_entries_cnt___7 = 0;
#line 956
  allocated += 16;
#line 958
  tmp___1 = smalloc(sizeof(char *) * 16UL);
#line 958
  autofsdir = (char **)tmp___1;
#line 959
  autofsdircnt = 0;
#line 960
  autofsdir_allocated = 16;
  }
  {
#line 961
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 961
    mnt___2 = getmntent(mntf);
    }
#line 961
    if (! mnt___2) {
#line 961
      goto while_break;
    }
    {
#line 966
    devname = get_device_name((char const   *)mnt___2->mnt_fsname);
    }
#line 966
    if (! devname) {
      {
#line 967
      tmp___2 = gettext("Cannot get device name for %s\n");
#line 967
      errstr(tmp___2, mnt___2->mnt_fsname);
      }
#line 968
      goto while_continue;
    }
#line 972
    i = 0;
    {
#line 972
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 972
      if (! (i < autofsdircnt)) {
#line 972
        goto while_break___0;
      }
      {
#line 973
      tmp___3 = strlen((char const   *)*(autofsdir + i));
#line 973
      slen = (int )tmp___3;
#line 975
      tmp___4 = strlen((char const   *)mnt___2->mnt_dir);
      }
#line 975
      if ((size_t )slen <= tmp___4) {
        {
#line 975
        tmp___5 = strncmp((char const   *)*(autofsdir + i), (char const   *)mnt___2->mnt_dir,
                          (size_t )slen);
        }
#line 975
        if (! tmp___5) {
#line 976
          goto while_break___0;
        }
      }
#line 972
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 978
    if (i < autofsdircnt) {
      {
#line 979
      free((void *)((char *)devname));
      }
#line 980
      goto while_continue;
    }
#line 983
    if (flags___7 & 2) {
      {
#line 983
      tmp___9 = strcmp((char const   *)mnt___2->mnt_type, "autofs");
      }
#line 983
      if (! tmp___9) {
#line 984
        if (autofsdircnt == autofsdir_allocated) {
          {
#line 985
          autofsdir_allocated += 16;
#line 986
          tmp___6 = srealloc((void *)autofsdir, (unsigned long )autofsdir_allocated * sizeof(char *));
#line 986
          autofsdir = (char **)tmp___6;
          }
        }
        {
#line 988
        tmp___7 = strlen((char const   *)mnt___2->mnt_dir);
#line 988
        tmp___8 = smalloc(tmp___7 + 2UL);
#line 988
        *(autofsdir + autofsdircnt) = (char *)tmp___8;
#line 989
        strcpy((char */* __restrict  */)*(autofsdir + autofsdircnt), (char const   */* __restrict  */)mnt___2->mnt_dir);
#line 990
        strcat((char */* __restrict  */)*(autofsdir + autofsdircnt), (char const   */* __restrict  */)"/");
#line 991
        autofsdircnt ++;
#line 992
        free((void *)((char *)devname));
        }
#line 993
        goto while_continue;
      }
    }
#line 996
    if (flags___7 & 8) {
      {
#line 996
      tmp___10 = nfs_fstype(mnt___2->mnt_type);
      }
#line 996
      if (tmp___10) {
        {
#line 997
        free((void *)((char *)devname));
        }
#line 998
        goto while_continue;
      }
    }
    {
#line 1000
    tmp___11 = hasmntopt((struct mntent  const  *)mnt___2, "noquota");
    }
#line 1000
    if (tmp___11) {
      {
#line 1001
      free((void *)((char *)devname));
      }
#line 1002
      goto while_continue;
    }
    {
#line 1004
    tmp___12 = hasmntopt((struct mntent  const  *)mnt___2, "bind");
    }
#line 1004
    if (tmp___12) {
      {
#line 1005
      free((void *)((char *)devname));
      }
#line 1006
      goto while_continue;
    }
    {
#line 1008
    opt = hasmntoptarg___7((char const   *)mnt___2->mnt_opts, "loop");
    }
#line 1008
    if (opt) {
      {
#line 1011
      copy_mntoptarg___7(opt, (char const   *)(loopdev), 4096);
#line 1012
      free((void *)((char *)devname));
#line 1013
      tmp___13 = sstrdup((char const   *)(loopdev));
#line 1013
      devname = (char const   *)tmp___13;
      }
    }
    {
#line 1018
    qfmt[0] = hasquota___7(devname, mnt___2, 0, flags___7);
#line 1019
    qfmt[1] = hasquota___7(devname, mnt___2, 1, flags___7);
    }
#line 1020
    if (qfmt[0] < 0) {
#line 1020
      if (qfmt[1] < 0) {
        {
#line 1021
        free((void *)((char *)devname));
        }
#line 1022
        goto while_continue;
      }
    }
    {
#line 1025
    tmp___17 = realpath((char const   */* __restrict  */)mnt___2->mnt_dir, (char */* __restrict  */)(mntpointbuf));
    }
#line 1025
    if (! tmp___17) {
      {
#line 1026
      tmp___14 = __errno_location();
#line 1026
      tmp___15 = strerror(*tmp___14);
#line 1026
      tmp___16 = gettext("Cannot resolve mountpoint path %s: %s\n");
#line 1026
      errstr(tmp___16, mnt___2->mnt_dir, tmp___15);
#line 1027
      free((void *)((char *)devname));
      }
#line 1028
      goto while_continue;
    }
    {
#line 1031
    tmp___21 = statfs((char const   *)(mntpointbuf), & fsstat);
    }
#line 1031
    if (tmp___21 != 0) {
      {
#line 1032
      tmp___18 = __errno_location();
#line 1032
      tmp___19 = strerror(*tmp___18);
#line 1032
      tmp___20 = gettext("Cannot statfs() %s: %s\n");
#line 1032
      errstr(tmp___20, mntpointbuf, tmp___19);
#line 1033
      free((void *)((char *)devname));
      }
#line 1034
      goto while_continue;
    }
#line 1037
    if (fsstat.f_blocks == 0UL) {
#line 1037
      if (fsstat.f_bfree == 0UL) {
#line 1037
        if (fsstat.f_bavail == 0UL) {
          {
#line 1038
          free((void *)((char *)devname));
          }
#line 1039
          goto while_continue;
        }
      }
    }
    {
#line 1042
    tmp___27 = nfs_fstype(mnt___2->mnt_type);
    }
#line 1042
    if (! tmp___27) {
      {
#line 1043
      tmp___25 = stat((char const   */* __restrict  */)devname, (struct stat */* __restrict  */)(& st));
      }
#line 1043
      if (tmp___25 < 0) {
        {
#line 1044
        tmp___22 = __errno_location();
#line 1044
        tmp___23 = strerror(*tmp___22);
#line 1044
        tmp___24 = gettext("Cannot stat() mounted device %s: %s\n");
#line 1044
        errstr(tmp___24, devname, tmp___23);
#line 1045
        free((void *)((char *)devname));
        }
#line 1046
        goto while_continue;
      }
#line 1048
      if (! ((st.st_mode & 61440U) == 24576U)) {
#line 1048
        if (! ((st.st_mode & 61440U) == 8192U)) {
          {
#line 1049
          tmp___26 = gettext("Device (%s) filesystem is mounted on unsupported device type. Skipping.\n");
#line 1049
          errstr(tmp___26, devname);
#line 1050
          free((void *)((char *)devname));
          }
#line 1051
          goto while_continue;
        }
      }
#line 1053
      dev = st.st_rdev;
#line 1054
      i = 0;
      {
#line 1054
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1054
        if (i < mnt_entries_cnt___7) {
#line 1054
          if (! ((mnt_entries___7 + i)->me_dev != dev)) {
#line 1054
            goto while_break___1;
          }
        } else {
#line 1054
          goto while_break___1;
        }
#line 1054
        i ++;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
    {
#line 1057
    tmp___33 = nfs_fstype(mnt___2->mnt_type);
    }
#line 1057
    if (tmp___33) {
#line 1057
      goto _L;
    } else
#line 1057
    if (i == mnt_entries_cnt___7) {
      _L: /* CIL Label */ 
      {
#line 1058
      tmp___31 = stat((char const   */* __restrict  */)mnt___2->mnt_dir, (struct stat */* __restrict  */)(& st));
      }
#line 1058
      if (tmp___31 < 0) {
        {
#line 1059
        tmp___28 = __errno_location();
#line 1059
        tmp___29 = strerror(*tmp___28);
#line 1059
        tmp___30 = gettext("Cannot stat() mountpoint %s: %s\n");
#line 1059
        errstr(tmp___30, mnt___2->mnt_dir, tmp___29);
#line 1060
        free((void *)((char *)devname));
        }
#line 1061
        goto while_continue;
      }
      {
#line 1063
      tmp___32 = nfs_fstype(mnt___2->mnt_type);
      }
#line 1063
      if (tmp___32) {
#line 1065
        dev = st.st_dev;
#line 1066
        if (! (flags___7 & 32)) {
#line 1067
          i = 0;
          {
#line 1067
          while (1) {
            while_continue___2: /* CIL Label */ ;
#line 1067
            if (i < mnt_entries_cnt___7) {
#line 1067
              if (! ((mnt_entries___7 + i)->me_dev != dev)) {
#line 1067
                goto while_break___2;
              }
            } else {
#line 1067
              goto while_break___2;
            }
#line 1067
            i ++;
          }
          while_break___2: /* CIL Label */ ;
          }
        } else {
#line 1070
          i = mnt_entries_cnt___7;
        }
      }
    }
#line 1073
    if (i == mnt_entries_cnt___7) {
#line 1074
      if (allocated == mnt_entries_cnt___7) {
        {
#line 1075
        allocated += 16;
#line 1076
        tmp___34 = srealloc((void *)mnt_entries___7, (unsigned long )allocated * sizeof(struct mount_entry ));
#line 1076
        mnt_entries___7 = (struct mount_entry *)tmp___34;
        }
      }
      {
#line 1078
      (mnt_entries___7 + i)->me_type = sstrdup((char const   *)mnt___2->mnt_type);
#line 1079
      (mnt_entries___7 + i)->me_opts = sstrdup((char const   *)mnt___2->mnt_opts);
#line 1080
      (mnt_entries___7 + i)->me_dev = dev;
#line 1081
      (mnt_entries___7 + i)->me_ino = st.st_ino;
#line 1082
      (mnt_entries___7 + i)->me_devname = devname;
#line 1083
      tmp___35 = sstrdup((char const   *)(mntpointbuf));
#line 1083
      (mnt_entries___7 + i)->me__dir = (char const   *)tmp___35;
#line 1084
      (mnt_entries___7 + i)->me_dir = (char const   *)((void *)0);
#line 1085
      memcpy((void */* __restrict  */)(& (mnt_entries___7 + i)->me_qfmt), (void const   */* __restrict  */)(qfmt),
             sizeof(qfmt));
#line 1086
      mnt_entries_cnt___7 ++;
      }
    } else {
      {
#line 1089
      free((void *)((char *)devname));
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1091
  endmntent(mntf);
#line 1093
  i = 0;
  }
  {
#line 1093
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 1093
    if (! (i < autofsdircnt)) {
#line 1093
      goto while_break___3;
    }
    {
#line 1094
    free((void *)*(autofsdir + i));
#line 1093
    i ++;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 1095
  free((void *)autofsdir);
  }
#line 1096
  return (0);
}
}
#line 1100 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static char const   *find_dir_mntpoint___7(struct stat *st ) 
{ 
  int i ;

  {
#line 1104
  i = 0;
  {
#line 1104
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1104
    if (! (i < mnt_entries_cnt___7)) {
#line 1104
      goto while_break;
    }
#line 1105
    if ((mnt_entries___7 + i)->me_dev == st->st_dev) {
#line 1106
      st->st_ino = (mnt_entries___7 + i)->me_ino;
#line 1107
      return ((mnt_entries___7 + i)->me__dir);
    }
#line 1104
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1109
  return ((char const   *)((void *)0));
}
}
#line 1113 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static int process_dirs___7(int dcnt , char **dirs , int flags___7 ) 
{ 
  struct stat st ;
  int i ;
  char mntpointbuf[4096] ;
  void *tmp ;
  char *devname ;
  char const   *tmp___0 ;
  char *tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  int *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  char const   *realmnt ;
  char *tmp___12 ;
  int *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  int mentry ;
  char *tmp___17 ;
  char *tmp___18 ;
  char *tmp___19 ;
  char *tmp___20 ;

  {
#line 1119
  check_dirs_cnt___7 = 0;
#line 1120
  act_checked___7 = -1;
#line 1121
  if (dcnt) {
    {
#line 1122
    tmp = smalloc(sizeof(struct searched_dir ) * (unsigned long )dcnt);
#line 1122
    check_dirs___7 = (struct searched_dir *)tmp;
#line 1123
    i = 0;
    }
    {
#line 1123
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1123
      if (! (i < dcnt)) {
#line 1123
        goto while_break;
      }
      {
#line 1124
      tmp___10 = strncmp((char const   *)*(dirs + i), "UUID=", (size_t )5);
      }
#line 1124
      if (tmp___10) {
        {
#line 1124
        tmp___11 = strncmp((char const   *)*(dirs + i), "LABEL=", (size_t )6);
        }
#line 1124
        if (tmp___11) {
          {
#line 1139
          tmp___9 = stat((char const   */* __restrict  */)*(dirs + i), (struct stat */* __restrict  */)(& st));
          }
#line 1139
          if (tmp___9 < 0) {
            {
#line 1140
            tmp___6 = __errno_location();
#line 1140
            tmp___7 = strerror(*tmp___6);
#line 1140
            tmp___8 = gettext("Cannot stat() given mountpoint %s: %s\nSkipping...\n");
#line 1140
            errstr(tmp___8, *(dirs + i), tmp___7);
            }
#line 1141
            goto __Cont;
          }
        } else {
          _L: /* CIL Label */ 
          {
#line 1125
          tmp___0 = get_device_name((char const   *)*(dirs + i));
#line 1125
          devname = (char *)tmp___0;
          }
#line 1127
          if (! devname) {
            {
#line 1128
            tmp___1 = gettext("Cannot find a device with %s.\nSkipping...\n");
#line 1128
            errstr(tmp___1, *(dirs + i));
            }
#line 1129
            goto __Cont;
          }
          {
#line 1131
          tmp___5 = stat((char const   */* __restrict  */)devname, (struct stat */* __restrict  */)(& st));
          }
#line 1131
          if (tmp___5 < 0) {
            {
#line 1132
            tmp___2 = __errno_location();
#line 1132
            tmp___3 = strerror(*tmp___2);
#line 1132
            tmp___4 = gettext("Cannot stat() a mountpoint with %s: %s\nSkipping...\n");
#line 1132
            errstr(tmp___4, *(dirs + i), tmp___3);
#line 1133
            free((void *)devname);
            }
#line 1134
            goto __Cont;
          }
          {
#line 1136
          free((void *)devname);
          }
        }
      } else {
#line 1124
        goto _L;
      }
#line 1143
      (check_dirs___7 + check_dirs_cnt___7)->sd_dir = (st.st_mode & 61440U) == 16384U;
#line 1144
      if ((st.st_mode & 61440U) == 16384U) {
#line 1145
        realmnt = (char const   *)*(dirs + i);
#line 1148
        if (flags___7 & 1) {
          {
#line 1148
          realmnt = find_dir_mntpoint___7(& st);
          }
#line 1148
          if (! realmnt) {
#line 1149
            if (! (flags___7 & 4)) {
              {
#line 1150
              tmp___12 = gettext("Cannot find a filesystem mountpoint for directory %s\n");
#line 1150
              errstr(tmp___12, *(dirs + i));
              }
            }
#line 1151
            goto __Cont;
          }
        }
        {
#line 1153
        (check_dirs___7 + check_dirs_cnt___7)->sd_dev = st.st_dev;
#line 1154
        (check_dirs___7 + check_dirs_cnt___7)->sd_ino = st.st_ino;
#line 1155
        tmp___16 = realpath((char const   */* __restrict  */)realmnt, (char */* __restrict  */)(mntpointbuf));
        }
#line 1155
        if (! tmp___16) {
          {
#line 1156
          tmp___13 = __errno_location();
#line 1156
          tmp___14 = strerror(*tmp___13);
#line 1156
          tmp___15 = gettext("Cannot resolve path %s: %s\n");
#line 1156
          errstr(tmp___15, realmnt, tmp___14);
          }
#line 1157
          goto __Cont;
        }
      } else
#line 1160
      if ((st.st_mode & 61440U) == 24576U) {
#line 1160
        goto _L___0;
      } else
#line 1160
      if ((st.st_mode & 61440U) == 8192U) {
        _L___0: /* CIL Label */ 
#line 1163
        (check_dirs___7 + check_dirs_cnt___7)->sd_dev = st.st_rdev;
#line 1164
        mentry = 0;
        {
#line 1164
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 1164
          if (mentry < mnt_entries_cnt___7) {
#line 1164
            if (! ((mnt_entries___7 + mentry)->me_dev != st.st_rdev)) {
#line 1164
              goto while_break___0;
            }
          } else {
#line 1164
            goto while_break___0;
          }
#line 1164
          mentry ++;
        }
        while_break___0: /* CIL Label */ ;
        }
#line 1165
        if (mentry == mnt_entries_cnt___7) {
#line 1166
          if (! (flags___7 & 4)) {
            {
#line 1167
            tmp___17 = gettext("Cannot find mountpoint for device %s\n");
#line 1167
            errstr(tmp___17, *(dirs + i));
            }
          }
#line 1168
          goto __Cont;
        }
        {
#line 1170
        sstrncpy(mntpointbuf, (mnt_entries___7 + mentry)->me__dir, (size_t )4095);
        }
      } else {
        {
#line 1173
        tmp___18 = gettext("Specified path %s is not directory nor device.\n");
#line 1173
        errstr(tmp___18, *(dirs + i));
        }
#line 1174
        goto __Cont;
      }
      {
#line 1176
      tmp___19 = sstrdup((char const   *)(mntpointbuf));
#line 1176
      (check_dirs___7 + check_dirs_cnt___7)->sd_name = (char const   *)tmp___19;
#line 1177
      check_dirs_cnt___7 ++;
      }
      __Cont: /* CIL Label */ 
#line 1123
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 1179
    if (! check_dirs_cnt___7) {
#line 1180
      if (! (flags___7 & 4)) {
        {
#line 1181
        tmp___20 = gettext("No correct mountpoint specified.\n");
#line 1181
        errstr(tmp___20);
        }
      }
      {
#line 1182
      free((void *)check_dirs___7);
      }
#line 1183
      return (-1);
    }
  }
#line 1186
  return (0);
}
}
#line 1204 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static int find_next_entry_all___7(int *pos ) 
{ 
  char *tmp ;

  {
  {
#line 1206
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1206
    act_checked___7 ++;
#line 1206
    if (! (act_checked___7 < mnt_entries_cnt___7)) {
#line 1206
      goto while_break;
    }
    {
#line 1207
    tmp = str_hasmntopt((char const   *)(mnt_entries___7 + act_checked___7)->me_opts,
                        "noauto");
    }
#line 1207
    if (! tmp) {
#line 1208
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1210
  if (act_checked___7 >= mnt_entries_cnt___7) {
#line 1211
    return (0);
  }
#line 1212
  *pos = act_checked___7;
#line 1213
  return (1);
}
}
#line 1217 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static int find_next_entry_sel___7(int *pos ) 
{ 
  int i ;
  struct searched_dir *sd ;
  char *tmp ;

  {
  restart: 
#line 1223
  act_checked___7 ++;
#line 1223
  if (act_checked___7 == check_dirs_cnt___7) {
#line 1224
    return (0);
  }
#line 1225
  sd = check_dirs___7 + act_checked___7;
#line 1226
  i = 0;
  {
#line 1226
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1226
    if (! (i < mnt_entries_cnt___7)) {
#line 1226
      goto while_break;
    }
#line 1227
    if (sd->sd_dir) {
#line 1228
      if (sd->sd_dev == (mnt_entries___7 + i)->me_dev) {
#line 1228
        if (sd->sd_ino == (mnt_entries___7 + i)->me_ino) {
#line 1229
          goto while_break;
        }
      }
    } else
#line 1232
    if (sd->sd_dev == (mnt_entries___7 + i)->me_dev) {
#line 1233
      goto while_break;
    }
#line 1226
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1235
  if (i == mnt_entries_cnt___7) {
    {
#line 1236
    tmp = gettext("Mountpoint (or device) %s not found or has no quota enabled.\n");
#line 1236
    errstr(tmp, sd->sd_name);
    }
#line 1237
    goto restart;
  }
#line 1239
  *pos = i;
#line 1240
  return (1);
}
}
#line 45 "/home/wheatley/newnew/temp/quota-4.01/quotaio_tree.c"
static int get_index___7(qid_t id___0 , int depth ) 
{ 


  {
#line 47
  return ((int )((id___0 >> ((4 - depth) - 1) * 8) & 255U));
}
}
#line 51 "/home/wheatley/newnew/temp/quota-4.01/quotaio_tree.c"
static void read_blk___7(struct quota_handle *h , uint blk , dqbuf_t buf ) 
{ 
  int err ;
  ssize_t tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 55
  lseek(h->qh_fd, (__off64_t )(blk << 10), 0);
#line 56
  tmp = read(h->qh_fd, (void *)buf, (size_t )(1 << 10));
#line 56
  err = (int )tmp;
  }
#line 57
  if (err < 0) {
    {
#line 58
    tmp___0 = __errno_location();
#line 58
    tmp___1 = strerror(*tmp___0);
#line 58
    tmp___2 = gettext("Cannot read block %u: %s\n");
#line 58
    die(2, tmp___2, blk, tmp___1);
    }
  } else
#line 59
  if (err != 1 << 10) {
    {
#line 60
    memset((void *)(buf + err), 0, (size_t )((1 << 10) - err));
    }
  }
#line 61
  return;
}
}
#line 64 "/home/wheatley/newnew/temp/quota-4.01/quotaio_tree.c"
static int write_blk___7(struct quota_handle *h , uint blk , dqbuf_t buf ) 
{ 
  int err ;
  ssize_t tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  int *tmp___3 ;

  {
  {
#line 68
  lseek(h->qh_fd, (__off64_t )(blk << 10), 0);
#line 69
  tmp = write(h->qh_fd, (void const   *)buf, (size_t )(1 << 10));
#line 69
  err = (int )tmp;
  }
#line 70
  if (err < 0) {
    {
#line 70
    tmp___3 = __errno_location();
    }
#line 70
    if (*tmp___3 != 28) {
      {
#line 71
      tmp___0 = __errno_location();
#line 71
      tmp___1 = strerror(*tmp___0);
#line 71
      tmp___2 = gettext("Cannot write block (%u): %s\n");
#line 71
      die(2, tmp___2, blk, tmp___1);
      }
    }
  }
#line 72
  if (err != 1 << 10) {
#line 73
    return (-28);
  }
#line 74
  return (0);
}
}
#line 78 "/home/wheatley/newnew/temp/quota-4.01/quotaio_tree.c"
static int get_free_dqblk___7(struct quota_handle *h ) 
{ 
  dqbuf_t buf ;
  void *tmp ;
  struct qt_disk_dqdbheader *dh ;
  struct qtree_mem_dqinfo *info ;
  int blk ;
  char *tmp___0 ;
  int tmp___1 ;
  unsigned int tmp___2 ;

  {
  {
#line 80
  tmp = smalloc((size_t )(1 << 10));
#line 80
  buf = (dqbuf_t )tmp;
#line 81
  dh = (struct qt_disk_dqdbheader *)buf;
#line 82
  info = & h->qh_info.u.v2_mdqi.dqi_qtree;
  }
#line 85
  if (info->dqi_free_blk) {
    {
#line 86
    blk = (int )info->dqi_free_blk;
#line 87
    read_blk___7(h, (uint )blk, buf);
#line 88
    info->dqi_free_blk = dh->dqdh_next_free;
    }
  } else {
    {
#line 91
    memset((void *)buf, 0, (size_t )(1 << 10));
#line 92
    tmp___1 = write_blk___7(h, info->dqi_blocks, buf);
    }
#line 92
    if (tmp___1 < 0) {
      {
#line 93
      free((void *)buf);
#line 94
      tmp___0 = gettext("Cannot allocate new quota block (out of disk space).\n");
#line 94
      errstr(tmp___0);
      }
#line 95
      return (-28);
    }
#line 97
    tmp___2 = info->dqi_blocks;
#line 97
    (info->dqi_blocks) ++;
#line 97
    blk = (int )tmp___2;
  }
  {
#line 99
  mark_quotafile_info_dirty(h);
#line 100
  free((void *)buf);
  }
#line 101
  return (blk);
}
}
#line 105 "/home/wheatley/newnew/temp/quota-4.01/quotaio_tree.c"
static void put_free_dqblk___7(struct quota_handle *h , dqbuf_t buf , uint blk ) 
{ 
  struct qt_disk_dqdbheader *dh ;
  struct qtree_mem_dqinfo *info ;

  {
  {
#line 107
  dh = (struct qt_disk_dqdbheader *)buf;
#line 108
  info = & h->qh_info.u.v2_mdqi.dqi_qtree;
#line 110
  dh->dqdh_next_free = info->dqi_free_blk;
#line 111
  dh->dqdh_prev_free = (__u32 )0;
#line 112
  dh->dqdh_entries = (__u16 )0;
#line 113
  info->dqi_free_blk = blk;
#line 114
  mark_quotafile_info_dirty(h);
#line 115
  write_blk___7(h, blk, buf);
  }
#line 116
  return;
}
}
#line 119 "/home/wheatley/newnew/temp/quota-4.01/quotaio_tree.c"
static void remove_free_dqentry___7(struct quota_handle *h , dqbuf_t buf , uint blk ) 
{ 
  dqbuf_t tmpbuf ;
  void *tmp ;
  struct qt_disk_dqdbheader *dh ;
  uint nextblk ;
  uint prevblk ;
  u_int32_t tmp___0 ;

  {
  {
#line 121
  tmp = smalloc((size_t )(1 << 10));
#line 121
  tmpbuf = (dqbuf_t )tmp;
#line 122
  dh = (struct qt_disk_dqdbheader *)buf;
#line 123
  nextblk = dh->dqdh_next_free;
#line 123
  prevblk = dh->dqdh_prev_free;
  }
#line 127
  if (nextblk) {
    {
#line 128
    read_blk___7(h, nextblk, tmpbuf);
#line 129
    ((struct qt_disk_dqdbheader *)tmpbuf)->dqdh_prev_free = dh->dqdh_prev_free;
#line 130
    write_blk___7(h, nextblk, tmpbuf);
    }
  }
#line 132
  if (prevblk) {
    {
#line 133
    read_blk___7(h, prevblk, tmpbuf);
#line 134
    ((struct qt_disk_dqdbheader *)tmpbuf)->dqdh_next_free = dh->dqdh_next_free;
#line 135
    write_blk___7(h, prevblk, tmpbuf);
    }
  } else {
    {
#line 138
    h->qh_info.u.v2_mdqi.dqi_qtree.dqi_free_entry = nextblk;
#line 139
    mark_quotafile_info_dirty(h);
    }
  }
  {
#line 141
  free((void *)tmpbuf);
#line 142
  tmp___0 = (__u32 )0;
#line 142
  dh->dqdh_prev_free = tmp___0;
#line 142
  dh->dqdh_next_free = tmp___0;
#line 143
  write_blk___7(h, blk, buf);
  }
#line 144
  return;
}
}
#line 147 "/home/wheatley/newnew/temp/quota-4.01/quotaio_tree.c"
static void insert_free_dqentry___7(struct quota_handle *h , dqbuf_t buf , uint blk ) 
{ 
  dqbuf_t tmpbuf ;
  void *tmp ;
  struct qt_disk_dqdbheader *dh ;
  struct qtree_mem_dqinfo *info ;

  {
  {
#line 149
  tmp = smalloc((size_t )(1 << 10));
#line 149
  tmpbuf = (dqbuf_t )tmp;
#line 150
  dh = (struct qt_disk_dqdbheader *)buf;
#line 151
  info = & h->qh_info.u.v2_mdqi.dqi_qtree;
#line 153
  dh->dqdh_next_free = info->dqi_free_entry;
#line 154
  dh->dqdh_prev_free = (__u32 )0;
#line 155
  write_blk___7(h, blk, buf);
  }
#line 156
  if (info->dqi_free_entry) {
    {
#line 157
    read_blk___7(h, info->dqi_free_entry, tmpbuf);
#line 158
    ((struct qt_disk_dqdbheader *)tmpbuf)->dqdh_prev_free = blk;
#line 159
    write_blk___7(h, info->dqi_free_entry, tmpbuf);
    }
  }
  {
#line 161
  free((void *)tmpbuf);
#line 162
  info->dqi_free_entry = blk;
#line 163
  mark_quotafile_info_dirty(h);
  }
#line 164
  return;
}
}
#line 167 "/home/wheatley/newnew/temp/quota-4.01/quotaio_tree.c"
static uint find_free_dqentry___7(struct quota_handle *h , struct dquot *dquot , int *err ) 
{ 
  int blk ;
  int i ;
  struct qt_disk_dqdbheader *dh ;
  struct qtree_mem_dqinfo *info ;
  char *ddquot ;
  dqbuf_t buf ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;

  {
  {
#line 171
  info = & h->qh_info.u.v2_mdqi.dqi_qtree;
#line 175
  *err = 0;
#line 176
  tmp = smalloc((size_t )(1 << 10));
#line 176
  buf = (dqbuf_t )tmp;
#line 177
  dh = (struct qt_disk_dqdbheader *)buf;
  }
#line 178
  if (info->dqi_free_entry) {
    {
#line 179
    blk = (int )info->dqi_free_entry;
#line 180
    read_blk___7(h, (uint )blk, buf);
    }
  } else {
    {
#line 183
    blk = get_free_dqblk___7(h);
    }
#line 184
    if (blk < 0) {
      {
#line 185
      free((void *)buf);
#line 186
      *err = blk;
      }
#line 187
      return ((uint )0);
    }
    {
#line 189
    memset((void *)buf, 0, (size_t )(1 << 10));
#line 190
    info->dqi_free_entry = (unsigned int )blk;
#line 191
    mark_quotafile_info_dirty(h);
    }
  }
  {
#line 193
  tmp___0 = qtree_dqstr_in_blk(info);
  }
#line 193
  if ((int )dh->dqdh_entries + 1 >= tmp___0) {
    {
#line 194
    remove_free_dqentry___7(h, buf, (uint )blk);
    }
  }
#line 195
  dh->dqdh_entries = (__u16 )((int )dh->dqdh_entries + 1);
#line 197
  ddquot = buf + sizeof(struct qt_disk_dqdbheader );
#line 198
  i = 0;
  {
#line 198
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 198
    tmp___1 = qtree_dqstr_in_blk(info);
    }
#line 198
    if (i < tmp___1) {
      {
#line 198
      tmp___2 = qtree_entry_unused(info, ddquot);
      }
#line 198
      if (tmp___2) {
#line 198
        goto while_break;
      }
    } else {
#line 198
      goto while_break;
    }
#line 198
    i ++;
#line 198
    ddquot += info->dqi_entry_size;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 201
  tmp___4 = qtree_dqstr_in_blk(info);
  }
#line 201
  if (i == tmp___4) {
    {
#line 202
    tmp___3 = gettext("find_free_dqentry(): Data block full but it shouldn\'t.\n");
#line 202
    die(2, tmp___3);
    }
  }
  {
#line 203
  write_blk___7(h, (uint )blk, buf);
#line 204
  dquot->dq_dqb.u.v2_mdqb.dqb_off = (loff_t )(((unsigned long )(blk << 10) + sizeof(struct qt_disk_dqdbheader )) + (unsigned long )((unsigned int )i * info->dqi_entry_size));
#line 207
  free((void *)buf);
  }
#line 208
  return ((uint )blk);
}
}
#line 212 "/home/wheatley/newnew/temp/quota-4.01/quotaio_tree.c"
static int do_insert_tree___7(struct quota_handle *h , struct dquot *dquot , uint *treeblk ,
                              int depth ) 
{ 
  dqbuf_t buf ;
  int newson ;
  int newact ;
  u_int32_t *ref ;
  uint newblk ;
  int ret ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;

  {
  {
#line 215
  newson = 0;
#line 215
  newact = 0;
#line 218
  ret = 0;
#line 220
  tmp = smalloc((size_t )(1 << 10));
#line 220
  buf = (dqbuf_t )tmp;
  }
#line 221
  if (! *treeblk) {
    {
#line 222
    ret = get_free_dqblk___7(h);
    }
#line 223
    if (ret < 0) {
#line 224
      goto out_buf;
    }
    {
#line 225
    *treeblk = (uint )ret;
#line 226
    memset((void *)buf, 0, (size_t )(1 << 10));
#line 227
    newact = 1;
    }
  } else {
    {
#line 230
    read_blk___7(h, *treeblk, buf);
    }
  }
  {
#line 231
  ref = (u_int32_t *)buf;
#line 232
  tmp___0 = get_index___7(dquot->dq_id, depth);
#line 232
  newblk = *(ref + tmp___0);
  }
#line 233
  if (! newblk) {
#line 234
    newson = 1;
  }
#line 235
  if (depth == 3) {
#line 236
    if (newblk) {
      {
#line 237
      tmp___1 = get_index___7(dquot->dq_id, depth);
#line 237
      tmp___2 = gettext("Inserting already present quota entry (block %u).\n");
#line 237
      die(2, tmp___2, *(ref + tmp___1));
      }
    }
    {
#line 239
    newblk = find_free_dqentry___7(h, dquot, & ret);
    }
  } else {
    {
#line 242
    ret = do_insert_tree___7(h, dquot, & newblk, depth + 1);
    }
  }
#line 243
  if (newson) {
#line 243
    if (ret >= 0) {
      {
#line 244
      tmp___3 = get_index___7(dquot->dq_id, depth);
#line 244
      *(ref + tmp___3) = newblk;
#line 245
      write_blk___7(h, *treeblk, buf);
      }
    } else {
#line 243
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 247
  if (newact) {
#line 247
    if (ret < 0) {
      {
#line 248
      put_free_dqblk___7(h, buf, *treeblk);
      }
    }
  }
  out_buf: 
  {
#line 250
  free((void *)buf);
  }
#line 251
  return (ret);
}
}
#line 255 "/home/wheatley/newnew/temp/quota-4.01/quotaio_tree.c"
static void dq_insert_tree___7(struct quota_handle *h , struct dquot *dquot ) 
{ 
  uint tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;

  {
  {
#line 257
  tmp = (uint )1;
#line 259
  tmp___3 = do_insert_tree___7(h, dquot, & tmp, 0);
  }
#line 259
  if (tmp___3 < 0) {
    {
#line 260
    tmp___0 = __errno_location();
#line 260
    tmp___1 = strerror(*tmp___0);
#line 260
    tmp___2 = gettext("Cannot write quota (id %u): %s\n");
#line 260
    die(2, tmp___2, dquot->dq_id, tmp___1);
    }
  }
#line 261
  return;
}
}
#line 284 "/home/wheatley/newnew/temp/quota-4.01/quotaio_tree.c"
static void free_dqentry___7(struct quota_handle *h , struct dquot *dquot , uint blk ) 
{ 
  struct qt_disk_dqdbheader *dh ;
  struct qtree_mem_dqinfo *info ;
  dqbuf_t buf ;
  void *tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 287
  info = & h->qh_info.u.v2_mdqi.dqi_qtree;
#line 288
  tmp = smalloc((size_t )(1 << 10));
#line 288
  buf = (dqbuf_t )tmp;
  }
#line 290
  if (dquot->dq_dqb.u.v2_mdqb.dqb_off >> 10 != (loff_t )blk) {
    {
#line 291
    tmp___0 = gettext("Quota structure has offset to other block (%u) than it should (%u).\n");
#line 291
    die(2, tmp___0, blk, (uint )(dquot->dq_dqb.u.v2_mdqb.dqb_off >> 10));
    }
  }
  {
#line 293
  read_blk___7(h, blk, buf);
#line 294
  dh = (struct qt_disk_dqdbheader *)buf;
#line 295
  dh->dqdh_entries = (__u16 )((int )dh->dqdh_entries - 1);
  }
#line 296
  if (! dh->dqdh_entries) {
    {
#line 297
    remove_free_dqentry___7(h, buf, blk);
#line 298
    put_free_dqblk___7(h, buf, blk);
    }
  } else {
    {
#line 301
    memset((void *)(buf + (dquot->dq_dqb.u.v2_mdqb.dqb_off & (long )((1 << 10) - 1))),
           0, (size_t )info->dqi_entry_size);
#line 304
    tmp___1 = qtree_dqstr_in_blk(info);
    }
#line 304
    if ((int )dh->dqdh_entries == tmp___1 - 1) {
      {
#line 305
      insert_free_dqentry___7(h, buf, blk);
      }
    } else {
      {
#line 307
      write_blk___7(h, blk, buf);
      }
    }
  }
  {
#line 309
  dquot->dq_dqb.u.v2_mdqb.dqb_off = (loff_t )0;
#line 310
  free((void *)buf);
  }
#line 311
  return;
}
}
#line 314 "/home/wheatley/newnew/temp/quota-4.01/quotaio_tree.c"
static void remove_tree___7(struct quota_handle *h , struct dquot *dquot , uint *blk ,
                            int depth ) 
{ 
  dqbuf_t buf ;
  void *tmp ;
  uint newblk ;
  u_int32_t *ref ;
  int tmp___0 ;
  int i ;
  int tmp___1 ;

  {
  {
#line 316
  tmp = smalloc((size_t )(1 << 10));
#line 316
  buf = (dqbuf_t )tmp;
#line 318
  ref = (u_int32_t *)buf;
#line 320
  read_blk___7(h, *blk, buf);
#line 321
  tmp___0 = get_index___7(dquot->dq_id, depth);
#line 321
  newblk = *(ref + tmp___0);
  }
#line 322
  if (depth == 3) {
    {
#line 323
    free_dqentry___7(h, dquot, newblk);
#line 324
    newblk = (uint )0;
    }
  } else {
    {
#line 327
    remove_tree___7(h, dquot, & newblk, depth + 1);
    }
  }
#line 328
  if (! newblk) {
    {
#line 331
    tmp___1 = get_index___7(dquot->dq_id, depth);
#line 331
    *(ref + tmp___1) = (__u32 )0;
#line 332
    i = 0;
    }
    {
#line 332
    while (1) {
      while_continue: /* CIL Label */ ;
#line 332
      if (i < 1 << 10) {
#line 332
        if (! (! *(buf + i))) {
#line 332
          goto while_break;
        }
      } else {
#line 332
        goto while_break;
      }
#line 332
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 334
    if (i == 1 << 10) {
#line 334
      if (*blk != 1U) {
        {
#line 335
        put_free_dqblk___7(h, buf, *blk);
#line 336
        *blk = (uint )0;
        }
      } else {
        {
#line 339
        write_blk___7(h, *blk, buf);
        }
      }
    } else {
      {
#line 339
      write_blk___7(h, *blk, buf);
      }
    }
  }
  {
#line 341
  free((void *)buf);
  }
#line 342
  return;
}
}
#line 355 "/home/wheatley/newnew/temp/quota-4.01/quotaio_tree.c"
static loff_t find_block_dqentry___7(struct quota_handle *h , struct dquot *dquot ,
                                     uint blk ) 
{ 
  struct qtree_mem_dqinfo *info ;
  dqbuf_t buf ;
  void *tmp ;
  int i ;
  char *ddquot ;
  int tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;

  {
  {
#line 357
  info = & h->qh_info.u.v2_mdqi.dqi_qtree;
#line 358
  tmp = smalloc((size_t )(1 << 10));
#line 358
  buf = (dqbuf_t )tmp;
#line 360
  ddquot = buf + sizeof(struct qt_disk_dqdbheader );
#line 362
  read_blk___7(h, blk, buf);
#line 363
  i = 0;
  }
  {
#line 363
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 363
    tmp___0 = qtree_dqstr_in_blk(info);
    }
#line 363
    if (i < tmp___0) {
      {
#line 363
      tmp___1 = (*((info->dqi_ops)->is_id))((void *)ddquot, dquot);
      }
#line 363
      if (tmp___1) {
#line 363
        goto while_break;
      }
    } else {
#line 363
      goto while_break;
    }
#line 363
    i ++;
#line 363
    ddquot += info->dqi_entry_size;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 366
  tmp___3 = qtree_dqstr_in_blk(info);
  }
#line 366
  if (i == tmp___3) {
    {
#line 367
    tmp___2 = gettext("Quota for id %u referenced but not present.\n");
#line 367
    die(2, tmp___2, dquot->dq_id);
    }
  }
  {
#line 368
  free((void *)buf);
  }
#line 369
  return ((loff_t )(((unsigned long )(blk << 10) + sizeof(struct qt_disk_dqdbheader )) + (unsigned long )((unsigned int )i * info->dqi_entry_size)));
}
}
#line 374 "/home/wheatley/newnew/temp/quota-4.01/quotaio_tree.c"
static loff_t find_tree_dqentry___7(struct quota_handle *h , struct dquot *dquot ,
                                    uint blk , int depth ) 
{ 
  dqbuf_t buf ;
  void *tmp ;
  loff_t ret ;
  u_int32_t *ref ;
  int tmp___0 ;

  {
  {
#line 376
  tmp = smalloc((size_t )(1 << 10));
#line 376
  buf = (dqbuf_t )tmp;
#line 377
  ret = (loff_t )0;
#line 378
  ref = (u_int32_t *)buf;
#line 380
  read_blk___7(h, blk, buf);
#line 381
  ret = (loff_t )0;
#line 382
  tmp___0 = get_index___7(dquot->dq_id, depth);
#line 382
  blk = *(ref + tmp___0);
  }
#line 383
  if (! blk) {
#line 384
    goto out_buf;
  }
#line 385
  if (depth < 3) {
    {
#line 386
    ret = find_tree_dqentry___7(h, dquot, blk, depth + 1);
    }
  } else {
    {
#line 388
    ret = find_block_dqentry___7(h, dquot, blk);
    }
  }
  out_buf: 
  {
#line 390
  free((void *)buf);
  }
#line 391
  return (ret);
}
}
#line 395 "/home/wheatley/newnew/temp/quota-4.01/quotaio_tree.c"
__inline static loff_t find_dqentry___7(struct quota_handle *h , struct dquot *dquot ) 
{ 
  loff_t tmp ;

  {
  {
#line 397
  tmp = find_tree_dqentry___7(h, dquot, (uint )1, 0);
  }
#line 397
  return (tmp);
}
}
#line 441 "/home/wheatley/newnew/temp/quota-4.01/quotaio_tree.c"
static int report_block___7(struct dquot *dquot , uint blk , char *bitmap , int (*process_dquot)(struct dquot * ,
                                                                                                 char * ) ) 
{ 
  struct qtree_mem_dqinfo *info ;
  dqbuf_t buf ;
  void *tmp ;
  struct qt_disk_dqdbheader *dh ;
  char *ddata ;
  int entries ;
  int i ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 444
  info = & (dquot->dq_h)->qh_info.u.v2_mdqi.dqi_qtree;
#line 445
  tmp = smalloc((size_t )(1 << 10));
#line 445
  buf = (dqbuf_t )tmp;
#line 450
  *(bitmap + (blk >> 3)) = (char )((int )*(bitmap + (blk >> 3)) | (1 << (blk & 7U)));
#line 451
  read_blk___7(dquot->dq_h, blk, buf);
#line 452
  dh = (struct qt_disk_dqdbheader *)buf;
#line 453
  ddata = buf + sizeof(struct qt_disk_dqdbheader );
#line 454
  entries = (int )dh->dqdh_entries;
#line 455
  i = 0;
  }
  {
#line 455
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 455
    tmp___2 = qtree_dqstr_in_blk(info);
    }
#line 455
    if (! (i < tmp___2)) {
#line 455
      goto while_break;
    }
    {
#line 456
    tmp___1 = qtree_entry_unused(info, ddata);
    }
#line 456
    if (! tmp___1) {
      {
#line 457
      (*((info->dqi_ops)->disk2mem_dqblk))(dquot, (void *)ddata);
#line 458
      tmp___0 = (*process_dquot)(dquot, (char *)((void *)0));
      }
#line 458
      if (tmp___0 < 0) {
#line 459
        goto while_break;
      }
    }
#line 455
    i ++;
#line 455
    ddata += info->dqi_entry_size;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 461
  free((void *)buf);
  }
#line 462
  return (entries);
}
}
#line 465 "/home/wheatley/newnew/temp/quota-4.01/quotaio_tree.c"
static void check_reference___7(struct quota_handle *h , uint blk ) 
{ 
  char *tmp ;
  char *tmp___0 ;

  {
#line 467
  if (blk >= h->qh_info.u.v2_mdqi.dqi_qtree.dqi_blocks) {
    {
#line 468
    tmp = type2name(h->qh_type);
#line 468
    tmp___0 = gettext("Illegal reference (%u >= %u) in %s quota file on %s. Quota file is probably corrupted.\nPlease run quotacheck(8) and try again.\n");
#line 468
    die(2, tmp___0, blk, h->qh_info.u.v2_mdqi.dqi_qtree.dqi_blocks, tmp, h->qh_quotadev);
    }
  }
#line 469
  return;
}
}
#line 471 "/home/wheatley/newnew/temp/quota-4.01/quotaio_tree.c"
static int report_tree___7(struct dquot *dquot , uint blk , int depth , char *bitmap ,
                           int (*process_dquot)(struct dquot * , char * ) ) 
{ 
  int entries ;
  int i ;
  dqbuf_t buf ;
  void *tmp ;
  u_int32_t *ref ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 474
  entries = 0;
#line 475
  tmp = smalloc((size_t )(1 << 10));
#line 475
  buf = (dqbuf_t )tmp;
#line 476
  ref = (u_int32_t *)buf;
#line 478
  read_blk___7(dquot->dq_h, blk, buf);
  }
#line 479
  if (depth == 3) {
#line 480
    i = 0;
    {
#line 480
    while (1) {
      while_continue: /* CIL Label */ ;
#line 480
      if (! (i < (1 << 10) >> 2)) {
#line 480
        goto while_break;
      }
      {
#line 481
      blk = *(ref + i);
#line 482
      check_reference___7(dquot->dq_h, blk);
      }
#line 483
      if (blk) {
#line 483
        if (! ((int )*(bitmap + (blk >> 3)) & (1 << (blk & 7U)))) {
          {
#line 484
          tmp___0 = report_block___7(dquot, blk, bitmap, process_dquot);
#line 484
          entries += tmp___0;
          }
        }
      }
#line 480
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 488
    i = 0;
    {
#line 488
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 488
      if (! (i < (1 << 10) >> 2)) {
#line 488
        goto while_break___0;
      }
#line 489
      blk = *(ref + i);
#line 489
      if (blk) {
        {
#line 490
        check_reference___7(dquot->dq_h, blk);
#line 491
        tmp___1 = report_tree___7(dquot, blk, depth + 1, bitmap, process_dquot);
#line 491
        entries += tmp___1;
        }
      }
#line 488
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  {
#line 495
  free((void *)buf);
  }
#line 496
  return (entries);
}
}
#line 499 "/home/wheatley/newnew/temp/quota-4.01/quotaio_tree.c"
static uint find_set_bits___7(char *bmp , int blocks ) 
{ 
  uint i ;
  uint used ;

  {
#line 501
  used = (uint )0;
#line 503
  i = (uint )0;
  {
#line 503
  while (1) {
    while_continue: /* CIL Label */ ;
#line 503
    if (! (i < (uint )blocks)) {
#line 503
      goto while_break;
    }
#line 504
    if ((int )*(bmp + (i >> 3)) & (1 << (i & 7U))) {
#line 505
      used ++;
    }
#line 503
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 506
  return (used);
}
}
#line 105 "/home/wheatley/newnew/temp/quota-4.01/quotaio_generic.c"
static int scan_one_dquot___7(struct dquot *dquot , int (*get_dquot)(struct dquot * ) ) 
{ 
  int ret ;
  struct util_dqblk *dqb ;

  {
  {
#line 108
  dqb = & dquot->dq_dqb;
#line 110
  memset((void *)dqb, 0, sizeof(struct util_dqblk ));
#line 111
  ret = (*get_dquot)(dquot);
  }
#line 112
  if (ret < 0) {
#line 113
    return (ret);
  }
#line 114
  if (! dqb->dqb_bhardlimit) {
#line 114
    if (! dqb->dqb_bsoftlimit) {
#line 114
      if (! dqb->dqb_ihardlimit) {
#line 114
        if (! dqb->dqb_isoftlimit) {
#line 114
          if (! dqb->dqb_curinodes) {
#line 114
            if (! dqb->dqb_curspace) {
#line 115
              return (1);
            }
          }
        }
      }
    }
  }
#line 116
  return (0);
}
}
#line 18 "/home/wheatley/newnew/temp/quota-4.01/quotaio_rpc.c"
static int rpc_init_io___7(struct quota_handle *h ) ;
#line 19
static struct dquot *rpc_read_dquot___7(struct quota_handle *h , qid_t id___0 ) ;
#line 20
static int rpc_commit_dquot___7(struct dquot *dquot , int flags___7 ) ;
#line 31 "/home/wheatley/newnew/temp/quota-4.01/quotaio_rpc.c"
static int rpc_init_io___7(struct quota_handle *h ) 
{ 


  {
#line 34
  h->qh_info.dqi_max_b_limit = (uint64_t )(~ ((uint32_t )0));
#line 35
  h->qh_info.dqi_max_i_limit = (uint64_t )(~ ((uint32_t )0));
#line 36
  h->qh_info.dqi_max_b_usage = (uint64_t )(4294967295U << 10);
#line 37
  h->qh_info.dqi_max_i_usage = (uint64_t )(~ ((uint32_t )0));
#line 38
  return (0);
}
}
#line 47 "/home/wheatley/newnew/temp/quota-4.01/quotaio_rpc.c"
static struct dquot *rpc_read_dquot___7(struct quota_handle *h , qid_t id___0 ) 
{ 
  struct dquot *dquot ;
  struct dquot *tmp ;
  int ret ;
  int *tmp___0 ;

  {
  {
#line 50
  tmp = get_empty_dquot();
#line 50
  dquot = tmp;
#line 53
  dquot->dq_id = id___0;
#line 54
  dquot->dq_h = h;
#line 55
  ret = rpc_rquota_get(dquot);
  }
#line 55
  if (ret < 0) {
    {
#line 56
    tmp___0 = __errno_location();
#line 56
    *tmp___0 = - ret;
#line 57
    free((void *)dquot);
    }
#line 58
    return ((struct dquot *)((void *)0));
  }
#line 60
  return (dquot);
}
}
#line 70 "/home/wheatley/newnew/temp/quota-4.01/quotaio_rpc.c"
static int rpc_commit_dquot___7(struct dquot *dquot , int flags___7 ) 
{ 
  int ret ;
  char *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;

  {
#line 75
  if ((dquot->dq_h)->qh_io_flags & 4) {
    {
#line 76
    tmp = gettext("Trying to write quota to readonly quotafile on %s\n");
#line 76
    errstr(tmp, (dquot->dq_h)->qh_quotadev);
#line 77
    tmp___0 = __errno_location();
#line 77
    *tmp___0 = 1;
    }
#line 78
    return (-1);
  }
  {
#line 80
  ret = rpc_rquota_set((1024 << 8) | ((dquot->dq_h)->qh_type & 255), dquot);
  }
#line 80
  if (ret < 0) {
    {
#line 81
    tmp___1 = __errno_location();
#line 81
    *tmp___1 = - ret;
    }
#line 82
    return (-1);
  }
#line 84
  return (0);
}
}
#line 10 "/home/wheatley/newnew/temp/quota-4.01/rquota_clnt.c"
static struct timeval TIMEOUT___7  =    {(__time_t )25, (__suseconds_t )0};
#line 15 "/home/wheatley/newnew/temp/quota-4.01/rquota_clnt.c"
static getquota_rslt clnt_res___63  ;
#line 30 "/home/wheatley/newnew/temp/quota-4.01/rquota_clnt.c"
static getquota_rslt clnt_res___64  ;
#line 45 "/home/wheatley/newnew/temp/quota-4.01/rquota_clnt.c"
static setquota_rslt clnt_res___65  ;
#line 60 "/home/wheatley/newnew/temp/quota-4.01/rquota_clnt.c"
static setquota_rslt clnt_res___66  ;
#line 75 "/home/wheatley/newnew/temp/quota-4.01/rquota_clnt.c"
static getquota_rslt clnt_res___67  ;
#line 90 "/home/wheatley/newnew/temp/quota-4.01/rquota_clnt.c"
static getquota_rslt clnt_res___68  ;
#line 105 "/home/wheatley/newnew/temp/quota-4.01/rquota_clnt.c"
static setquota_rslt clnt_res___69  ;
#line 120 "/home/wheatley/newnew/temp/quota-4.01/rquota_clnt.c"
static setquota_rslt clnt_res___70  ;
#line 14 "/usr/include/x86_64-linux-gnu/asm/swab.h"
__inline static __u64 __arch_swab64(__u64 val ) 
{ 


  {
#line 30
  __asm__  ("bswapq %0": "=r" (val): "0" (val));
#line 31
  return (val);
}
}
#line 68 "/usr/include/linux/swab.h"
__inline static __u64 __fswab64(__u64 val ) 
{ 
  __u64 tmp ;

  {
  {
#line 73
  tmp = __arch_swab64(val);
  }
#line 73
  return (tmp);
}
}
#line 32 "/home/wheatley/newnew/temp/quota-4.01/convertquota.c"
static char *mntpoint___0  ;
#line 34 "/home/wheatley/newnew/temp/quota-4.01/convertquota.c"
static int ucv  ;
#line 34 "/home/wheatley/newnew/temp/quota-4.01/convertquota.c"
static int gcv  ;
#line 35 "/home/wheatley/newnew/temp/quota-4.01/convertquota.c"
static struct quota_handle *qn  ;
#line 36 "/home/wheatley/newnew/temp/quota-4.01/convertquota.c"
static int action  ;
#line 37 "/home/wheatley/newnew/temp/quota-4.01/convertquota.c"
static int infmt  ;
#line 37 "/home/wheatley/newnew/temp/quota-4.01/convertquota.c"
static int outfmt  ;
#line 39 "/home/wheatley/newnew/temp/quota-4.01/convertquota.c"
static void usage___6(void) 
{ 
  char *tmp ;
  char *tmp___0 ;

  {
  {
#line 41
  tmp = gettext("Utility for converting quota files.\nUsage:\n\t%s [options] mountpoint\n\n-u, --user                          convert user quota file\n-g, --group                         convert group quota file\n-e, --convert-endian                convert quota file to correct endianity\n-f, --convert-format oldfmt,newfmt  convert from old to VFSv0 quota format\n-h, --help                          show this help text and exit\n-V, --version                       output version information and exit\n\n");
#line 41
  errstr(tmp, progname);
#line 48
  tmp___0 = gettext("Bugs to %s\n");
#line 48
  errstr(tmp___0, "jack@suse.cz");
#line 49
  exit(1);
  }
}
}
#line 52 "/home/wheatley/newnew/temp/quota-4.01/convertquota.c"
__inline static unsigned int min(unsigned int a , unsigned int b ) 
{ 


  {
#line 54
  if (a < b) {
#line 55
    return (a);
  }
#line 56
  return (b);
}
}
#line 61 "/home/wheatley/newnew/temp/quota-4.01/convertquota.c"
static void parse_options___5(int argcnt , char **argstr ) 
{ 
  int ret ;
  struct option long_opts[7] ;
  char *comma ;
  char fmtbuf[32] ;
  char *tmp ;
  unsigned int tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
#line 64
  long_opts[0].name = "help";
#line 64
  long_opts[0].has_arg = 0;
#line 64
  long_opts[0].flag = (int *)((void *)0);
#line 64
  long_opts[0].val = 'h';
#line 64
  long_opts[1].name = "version";
#line 64
  long_opts[1].has_arg = 0;
#line 64
  long_opts[1].flag = (int *)((void *)0);
#line 64
  long_opts[1].val = 'V';
#line 64
  long_opts[2].name = "user";
#line 64
  long_opts[2].has_arg = 0;
#line 64
  long_opts[2].flag = (int *)((void *)0);
#line 64
  long_opts[2].val = 'u';
#line 64
  long_opts[3].name = "group";
#line 64
  long_opts[3].has_arg = 0;
#line 64
  long_opts[3].flag = (int *)((void *)0);
#line 64
  long_opts[3].val = 'g';
#line 64
  long_opts[4].name = "convert-endian";
#line 64
  long_opts[4].has_arg = 0;
#line 64
  long_opts[4].flag = (int *)((void *)0);
#line 64
  long_opts[4].val = 'e';
#line 64
  long_opts[5].name = "convert-format";
#line 64
  long_opts[5].has_arg = 1;
#line 64
  long_opts[5].flag = (int *)((void *)0);
#line 64
  long_opts[5].val = 'f';
#line 64
  long_opts[6].name = (char const   *)((void *)0);
#line 64
  long_opts[6].has_arg = 0;
#line 64
  long_opts[6].flag = (int *)((void *)0);
#line 64
  long_opts[6].val = 0;
  {
#line 76
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 76
    ret = getopt_long(argcnt, (char * const  *)argstr, "Vugef:h", (struct option  const  *)(long_opts),
                      (int *)((void *)0));
    }
#line 76
    if (! (ret != -1)) {
#line 76
      goto while_break;
    }
    {
#line 79
    if (ret == 104) {
#line 79
      goto case_104;
    }
#line 79
    if (ret == 63) {
#line 79
      goto case_104;
    }
#line 81
    if (ret == 86) {
#line 81
      goto case_86;
    }
#line 84
    if (ret == 117) {
#line 84
      goto case_117;
    }
#line 87
    if (ret == 103) {
#line 87
      goto case_103;
    }
#line 90
    if (ret == 101) {
#line 90
      goto case_101;
    }
#line 93
    if (ret == 102) {
#line 93
      goto case_102;
    }
#line 77
    goto switch_break;
    case_104: /* CIL Label */ 
    case_63: /* CIL Label */ 
    {
#line 80
    usage___6();
    }
    case_86: /* CIL Label */ 
    {
#line 82
    version();
#line 83
    exit(0);
    }
    case_117: /* CIL Label */ 
#line 85
    ucv = 1;
#line 86
    goto switch_break;
    case_103: /* CIL Label */ 
#line 88
    gcv = 1;
#line 89
    goto switch_break;
    case_101: /* CIL Label */ 
#line 91
    action = 2;
#line 92
    goto switch_break;
    case_102: /* CIL Label */ 
    {
#line 94
    action = 1;
#line 95
    comma = strchr((char const   *)optarg, ',');
    }
#line 96
    if (! comma) {
      {
#line 97
      tmp = gettext("You have to specify source and target format of conversion.\n");
#line 97
      errstr(tmp);
#line 98
      usage___6();
      }
    }
    {
#line 100
    tmp___0 = min((unsigned int )((comma - optarg) + 1L), 32U);
#line 100
    sstrncpy(fmtbuf, (char const   *)optarg, (size_t )tmp___0);
#line 101
    infmt = name2fmt(fmtbuf);
    }
#line 102
    if (infmt == -1) {
      {
#line 103
      usage___6();
      }
    }
    {
#line 104
    outfmt = name2fmt(comma + 1);
    }
#line 105
    if (outfmt == -1) {
      {
#line 106
      usage___6();
      }
    }
#line 107
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 111
  if (optind + 1 != argcnt) {
    {
#line 112
    tmp___1 = gettext("Bad number of arguments.\n");
#line 112
    errstr(tmp___1);
#line 113
    usage___6();
    }
  }
#line 116
  if (! (ucv | gcv)) {
#line 117
    ucv = 1;
  }
#line 118
  if (! action) {
    {
#line 119
    tmp___2 = gettext("You have to specify action to perform.\n");
#line 119
    errstr(tmp___2);
#line 120
    usage___6();
    }
  }
#line 123
  mntpoint___0 = *(argstr + optind);
#line 124
  return;
}
}
#line 138 "/home/wheatley/newnew/temp/quota-4.01/convertquota.c"
__inline static void endian_disk2memdqblk(struct util_dqblk *m , struct v2r0_disk_dqblk *d ) 
{ 
  __u32 tmp ;
  __u32 tmp___0 ;
  __u32 tmp___1 ;
  __u32 tmp___2 ;
  __u32 tmp___3 ;
  __u64 tmp___4 ;
  __u64 tmp___5 ;
  __u64 tmp___6 ;

  {
  {
#line 140
  tmp = __fswab32(d->dqb_ihardlimit);
#line 140
  m->dqb_ihardlimit = (qsize_t )tmp;
#line 141
  tmp___0 = __fswab32(d->dqb_isoftlimit);
#line 141
  m->dqb_isoftlimit = (qsize_t )tmp___0;
#line 142
  tmp___1 = __fswab32(d->dqb_bhardlimit);
#line 142
  m->dqb_bhardlimit = (qsize_t )tmp___1;
#line 143
  tmp___2 = __fswab32(d->dqb_bsoftlimit);
#line 143
  m->dqb_bsoftlimit = (qsize_t )tmp___2;
#line 144
  tmp___3 = __fswab32(d->dqb_curinodes);
#line 144
  m->dqb_curinodes = (qsize_t )tmp___3;
#line 145
  tmp___4 = __fswab64((__be64 )d->dqb_curspace);
#line 145
  m->dqb_curspace = (qsize_t )tmp___4;
#line 146
  tmp___5 = __fswab64((__be64 )d->dqb_itime);
#line 146
  m->dqb_itime = (time_t )tmp___5;
#line 147
  tmp___6 = __fswab64((__be64 )d->dqb_btime);
#line 147
  m->dqb_btime = (time_t )tmp___6;
  }
#line 148
  return;
}
}
#line 153 "/home/wheatley/newnew/temp/quota-4.01/convertquota.c"
static struct v2r0_disk_dqblk fakedquot  ;
#line 151 "/home/wheatley/newnew/temp/quota-4.01/convertquota.c"
static int endian_empty_dquot(struct v2r0_disk_dqblk *d ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
#line 155
  tmp = memcmp((void const   *)d, (void const   *)(& fakedquot), sizeof(fakedquot));
  }
#line 155
  if (tmp) {
#line 155
    tmp___0 = 0;
  } else {
#line 155
    tmp___0 = 1;
  }
#line 155
  return (tmp___0);
}
}
#line 159 "/home/wheatley/newnew/temp/quota-4.01/convertquota.c"
static void read_blk___8(int fd , uint blk , dqbuf_t buf ) 
{ 
  int err ;
  ssize_t tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 163
  lseek(fd, (__off64_t )(blk << 10), 0);
#line 164
  tmp = read(fd, (void *)buf, (size_t )(1 << 10));
#line 164
  err = (int )tmp;
  }
#line 165
  if (err < 0) {
    {
#line 166
    tmp___0 = __errno_location();
#line 166
    tmp___1 = strerror(*tmp___0);
#line 166
    tmp___2 = gettext("Cannot read block %u: %s\n");
#line 166
    die(2, tmp___2, blk, tmp___1);
    }
  } else
#line 167
  if (err != 1 << 10) {
    {
#line 168
    memset((void *)(buf + err), 0, (size_t )((1 << 10) - err));
    }
  }
#line 169
  return;
}
}
#line 171 "/home/wheatley/newnew/temp/quota-4.01/convertquota.c"
static void endian_report_block(int fd , uint blk , char *bitmap ) 
{ 
  dqbuf_t buf ;
  void *tmp ;
  struct qt_disk_dqdbheader *dh ;
  struct v2r0_disk_dqblk *ddata ;
  struct dquot dquot ;
  struct qtree_mem_dqinfo *info ;
  int i ;
  __u32 tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
  {
#line 173
  tmp = smalloc((size_t )(1 << 10));
#line 173
  buf = (dqbuf_t )tmp;
#line 177
  info = & qn->qh_info.u.v2_mdqi.dqi_qtree;
#line 180
  *(bitmap + (blk >> 3)) = (char )((int )*(bitmap + (blk >> 3)) | (1 << (blk & 7U)));
#line 181
  read_blk___8(fd, blk, buf);
#line 182
  dh = (struct qt_disk_dqdbheader *)buf;
#line 183
  ddata = (struct v2r0_disk_dqblk *)(dh + 1);
#line 184
  i = 0;
  }
  {
#line 184
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 184
    tmp___6 = qtree_dqstr_in_blk(info);
    }
#line 184
    if (! (i < tmp___6)) {
#line 184
      goto while_break;
    }
    {
#line 185
    tmp___5 = endian_empty_dquot(ddata + i);
    }
#line 185
    if (! tmp___5) {
      {
#line 186
      memset((void *)(& dquot), 0, sizeof(dquot));
#line 187
      dquot.dq_h = qn;
#line 188
      endian_disk2memdqblk(& dquot.dq_dqb, ddata + i);
#line 189
      tmp___0 = __fswab32((ddata + i)->dqb_id);
#line 189
      dquot.dq_id = tmp___0;
#line 190
      tmp___4 = (*((qn->qh_ops)->commit_dquot))(& dquot, 63);
      }
#line 190
      if (tmp___4 < 0) {
        {
#line 191
        tmp___1 = __errno_location();
#line 191
        tmp___2 = strerror(*tmp___1);
#line 191
        tmp___3 = gettext("Cannot commit dquot for id %u: %s\n");
#line 191
        errstr(tmp___3, dquot.dq_id, tmp___2);
        }
      }
    }
#line 184
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 194
  free((void *)buf);
  }
#line 195
  return;
}
}
#line 197 "/home/wheatley/newnew/temp/quota-4.01/convertquota.c"
static void endian_report_tree(int fd , uint blk , int depth , char *bitmap ) 
{ 
  int i ;
  dqbuf_t buf ;
  void *tmp ;
  u_int32_t *ref ;
  __u32 tmp___0 ;
  __u32 tmp___1 ;

  {
  {
#line 200
  tmp = smalloc((size_t )(1 << 10));
#line 200
  buf = (dqbuf_t )tmp;
#line 201
  ref = (u_int32_t *)buf;
#line 203
  read_blk___8(fd, blk, buf);
  }
#line 204
  if (depth == 3) {
#line 205
    i = 0;
    {
#line 205
    while (1) {
      while_continue: /* CIL Label */ ;
#line 205
      if (! (i < (1 << 10) >> 2)) {
#line 205
        goto while_break;
      }
      {
#line 206
      tmp___0 = __fswab32(*(ref + i));
#line 206
      blk = tmp___0;
      }
#line 207
      if (blk) {
#line 207
        if (! ((int )*(bitmap + (blk >> 3)) & (1 << (blk & 7U)))) {
          {
#line 208
          endian_report_block(fd, blk, bitmap);
          }
        }
      }
#line 205
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 212
    i = 0;
    {
#line 212
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 212
      if (! (i < (1 << 10) >> 2)) {
#line 212
        goto while_break___0;
      }
      {
#line 213
      tmp___1 = __fswab32(*(ref + i));
#line 213
      blk = tmp___1;
      }
#line 213
      if (blk) {
        {
#line 214
        endian_report_tree(fd, blk, depth + 1, bitmap);
        }
      }
#line 212
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  {
#line 216
  free((void *)buf);
  }
#line 217
  return;
}
}
#line 219 "/home/wheatley/newnew/temp/quota-4.01/convertquota.c"
static int endian_scan_structures(int fd , int type ) 
{ 
  char *bitmap ;
  loff_t blocks ;
  __off64_t tmp ;
  void *tmp___0 ;

  {
  {
#line 222
  tmp = lseek(fd, (__off64_t )0, 2);
#line 222
  blocks = ((tmp + (__off64_t )(1 << 10)) - 1L) >> 10;
#line 224
  tmp___0 = smalloc((size_t )((blocks + 7L) >> 3));
#line 224
  bitmap = (char *)tmp___0;
#line 225
  memset((void *)bitmap, 0, (size_t )((blocks + 7L) >> 3));
#line 226
  endian_report_tree(fd, (uint )1, 0, bitmap);
#line 227
  free((void *)bitmap);
  }
#line 228
  return (0);
}
}
#line 231 "/home/wheatley/newnew/temp/quota-4.01/convertquota.c"
static int endian_check_header(int fd , int type ) 
{ 
  struct v2_disk_dqheader head ;
  u_int32_t file_magics[2] ;
  u_int32_t known_versions___0[2] ;
  char *tmp ;
  ssize_t tmp___0 ;
  char *tmp___1 ;
  __u32 tmp___2 ;
  __u32 tmp___3 ;

  {
  {
#line 234
  file_magics[0] = 3653246737U;
#line 234
  file_magics[1] = 3653245223U;
#line 235
  known_versions___0[0] = (u_int32_t )1;
#line 235
  known_versions___0[1] = (u_int32_t )1;
#line 237
  lseek(fd, (__off64_t )0, 0);
#line 238
  tmp___0 = read(fd, (void *)(& head), sizeof(head));
  }
#line 238
  if ((unsigned long )tmp___0 != sizeof(head)) {
    {
#line 239
    tmp = gettext("Cannot read header of old quotafile.\n");
#line 239
    errstr(tmp);
    }
#line 240
    return (-1);
  }
  {
#line 242
  tmp___2 = __fswab32(head.dqh_magic);
  }
#line 242
  if (tmp___2 != file_magics[type]) {
    {
#line 243
    tmp___1 = gettext("Bad file magic or version (probably not quotafile with bad endianity).\n");
#line 243
    errstr(tmp___1);
    }
#line 244
    return (-1);
  } else {
    {
#line 242
    tmp___3 = __fswab32(head.dqh_version);
    }
#line 242
    if (tmp___3 > known_versions___0[type]) {
      {
#line 243
      tmp___1 = gettext("Bad file magic or version (probably not quotafile with bad endianity).\n");
#line 243
      errstr(tmp___1);
      }
#line 244
      return (-1);
    }
  }
#line 246
  return (0);
}
}
#line 249 "/home/wheatley/newnew/temp/quota-4.01/convertquota.c"
static int endian_load_info(int fd , int type ) 
{ 
  struct v2_disk_dqinfo dinfo ;
  char *tmp ;
  ssize_t tmp___0 ;
  __u32 tmp___1 ;
  __u32 tmp___2 ;
  __u32 tmp___3 ;

  {
  {
#line 253
  tmp___0 = read(fd, (void *)(& dinfo), sizeof(dinfo));
  }
#line 253
  if ((unsigned long )tmp___0 != sizeof(dinfo)) {
    {
#line 254
    tmp = gettext("Cannot read information about old quotafile.\n");
#line 254
    errstr(tmp);
    }
#line 255
    return (-1);
  }
  {
#line 257
  tmp___1 = __fswab32(dinfo.dqi_flags);
#line 257
  qn->qh_info.u.v2_mdqi.dqi_flags = tmp___1;
#line 258
  tmp___2 = __fswab32(dinfo.dqi_bgrace);
#line 258
  qn->qh_info.dqi_bgrace = (time_t )tmp___2;
#line 259
  tmp___3 = __fswab32(dinfo.dqi_igrace);
#line 259
  qn->qh_info.dqi_igrace = (time_t )tmp___3;
  }
#line 260
  return (0);
}
}
#line 267 "/home/wheatley/newnew/temp/quota-4.01/convertquota.c"
static int convert_dquot(struct dquot *dquot , char *name ) 
{ 
  struct dquot newdquot ;
  int *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 271
  memset((void *)(& newdquot), 0, sizeof(newdquot));
#line 272
  newdquot.dq_id = dquot->dq_id;
#line 273
  newdquot.dq_h = qn;
#line 274
  newdquot.dq_dqb.dqb_ihardlimit = dquot->dq_dqb.dqb_ihardlimit;
#line 275
  newdquot.dq_dqb.dqb_isoftlimit = dquot->dq_dqb.dqb_isoftlimit;
#line 276
  newdquot.dq_dqb.dqb_curinodes = dquot->dq_dqb.dqb_curinodes;
#line 277
  newdquot.dq_dqb.dqb_bhardlimit = dquot->dq_dqb.dqb_bhardlimit;
#line 278
  newdquot.dq_dqb.dqb_bsoftlimit = dquot->dq_dqb.dqb_bsoftlimit;
#line 279
  newdquot.dq_dqb.dqb_curspace = dquot->dq_dqb.dqb_curspace;
#line 280
  newdquot.dq_dqb.dqb_btime = dquot->dq_dqb.dqb_btime;
#line 281
  newdquot.dq_dqb.dqb_itime = dquot->dq_dqb.dqb_itime;
#line 282
  tmp___2 = (*((qn->qh_ops)->commit_dquot))(& newdquot, 63);
  }
#line 282
  if (tmp___2 < 0) {
    {
#line 283
    tmp = __errno_location();
#line 283
    tmp___0 = strerror(*tmp);
#line 283
    tmp___1 = gettext("Cannot commit dquot for id %u: %s\n");
#line 283
    errstr(tmp___1, dquot->dq_id, tmp___0);
    }
#line 285
    return (-1);
  }
#line 287
  return (0);
}
}
#line 290 "/home/wheatley/newnew/temp/quota-4.01/convertquota.c"
static int rename_file(int type , int fmt___7 , struct mount_entry *mnt___2 ) 
{ 
  char *qfname ;
  char namebuf[4096] ;
  int ret ;
  char *tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;

  {
  {
#line 293
  ret = 0;
#line 295
  tmp___0 = get_qf_name(mnt___2, type, fmt___7, 0, & qfname);
  }
#line 295
  if (tmp___0 < 0) {
    {
#line 296
    tmp = gettext("Cannot get name of new quotafile.\n");
#line 296
    errstr(tmp);
    }
#line 297
    return (-1);
  }
  {
#line 299
  strcpy((char */* __restrict  */)(namebuf), (char const   */* __restrict  */)qfname);
#line 300
  sstrncat(namebuf, ".new", sizeof(namebuf));
#line 301
  tmp___4 = rename((char const   *)(namebuf), (char const   *)qfname);
  }
#line 301
  if (tmp___4 < 0) {
    {
#line 302
    tmp___1 = __errno_location();
#line 302
    tmp___2 = strerror(*tmp___1);
#line 302
    tmp___3 = gettext("Cannot rename new quotafile %s to name %s: %s\n");
#line 302
    errstr(tmp___3, namebuf, qfname, tmp___2);
#line 304
    ret = -1;
    }
  }
  {
#line 306
  free((void *)qfname);
  }
#line 307
  return (ret);
}
}
#line 310 "/home/wheatley/newnew/temp/quota-4.01/convertquota.c"
static int convert_format(int type , struct mount_entry *mnt___2 ) 
{ 
  struct quota_handle *qo ;
  int ret ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;

  {
  {
#line 313
  ret = 0;
#line 315
  qo = init_io(mnt___2, type, infmt, 2);
  }
#line 315
  if (! qo) {
    {
#line 316
    tmp = type2name(type);
#line 316
    tmp___0 = gettext((char const   *)tmp);
#line 316
    tmp___1 = gettext("Cannot open old format file for %ss on %s\n");
#line 316
    errstr(tmp___1, tmp___0, mnt___2->me_dir);
    }
#line 318
    return (-1);
  }
  {
#line 320
  qn = new_io(mnt___2, type, outfmt);
  }
#line 320
  if (! qn) {
    {
#line 321
    tmp___2 = __errno_location();
#line 321
    tmp___3 = strerror(*tmp___2);
#line 321
    tmp___4 = type2name(type);
#line 321
    tmp___5 = gettext((char const   *)tmp___4);
#line 321
    tmp___6 = gettext("Cannot create file for %ss for new format on %s: %s\n");
#line 321
    errstr(tmp___6, tmp___5, mnt___2->me_dir, tmp___3);
#line 323
    end_io(qo);
    }
#line 324
    return (-1);
  }
  {
#line 326
  tmp___7 = (*((qo->qh_ops)->scan_dquots))(qo, & convert_dquot);
  }
#line 326
  if (tmp___7 >= 0) {
    {
#line 327
    ret = rename_file(type, outfmt, mnt___2);
    }
  } else {
#line 329
    ret = -1;
  }
  {
#line 330
  end_io(qo);
#line 331
  end_io(qn);
  }
#line 332
  return (ret);
}
}
#line 335 "/home/wheatley/newnew/temp/quota-4.01/convertquota.c"
static int convert_endian(int type , struct mount_entry *mnt___2 ) 
{ 
  int ret ;
  int ofd ;
  char *qfname ;
  int tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;

  {
  {
#line 337
  ret = 0;
#line 341
  tmp = get_qf_name(mnt___2, type, 1, 1, & qfname);
  }
#line 341
  if (tmp < 0) {
#line 342
    return (-1);
  }
  {
#line 343
  ofd = open((char const   *)qfname, 0);
  }
#line 343
  if (ofd < 0) {
    {
#line 344
    tmp___0 = __errno_location();
#line 344
    tmp___1 = strerror(*tmp___0);
#line 344
    tmp___2 = gettext("Cannot open old quota file on %s: %s\n");
#line 344
    errstr(tmp___2, mnt___2->me_dir, tmp___1);
#line 345
    free((void *)qfname);
    }
#line 346
    return (-1);
  }
  {
#line 348
  free((void *)qfname);
#line 349
  tmp___3 = endian_check_header(ofd, type);
  }
#line 349
  if (tmp___3 < 0) {
    {
#line 350
    close(ofd);
    }
#line 351
    return (-1);
  }
  {
#line 353
  qn = new_io(mnt___2, type, 1);
  }
#line 353
  if (! qn) {
    {
#line 354
    tmp___4 = __errno_location();
#line 354
    tmp___5 = strerror(*tmp___4);
#line 354
    tmp___6 = type2name(type);
#line 354
    tmp___7 = gettext("Cannot create file for %ss for new format on %s: %s\n");
#line 354
    errstr(tmp___7, tmp___6, mnt___2->me_dir, tmp___5);
#line 356
    close(ofd);
    }
#line 357
    return (-1);
  }
  {
#line 359
  tmp___8 = endian_load_info(ofd, type);
  }
#line 359
  if (tmp___8 < 0) {
    {
#line 360
    end_io(qn);
#line 361
    close(ofd);
    }
#line 362
    return (-1);
  }
  {
#line 364
  ret = endian_scan_structures(ofd, type);
#line 365
  end_io(qn);
  }
#line 366
  if (ret < 0) {
#line 367
    return (ret);
  }
  {
#line 369
  tmp___9 = rename_file(type, 1, mnt___2);
  }
#line 369
  return (tmp___9);
}
}
#line 372 "/home/wheatley/newnew/temp/quota-4.01/convertquota.c"
static int convert_file(int type , struct mount_entry *mnt___2 ) 
{ 
  int tmp ;
  int tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 375
  if (action == 1) {
#line 375
    goto case_1;
  }
#line 377
  if (action == 2) {
#line 377
    goto case_2;
  }
#line 374
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 376
  tmp = convert_format(type, mnt___2);
  }
#line 376
  return (tmp);
  case_2: /* CIL Label */ 
  {
#line 378
  tmp___0 = convert_endian(type, mnt___2);
  }
#line 378
  return (tmp___0);
  switch_break: /* CIL Label */ ;
  }
  {
#line 380
  tmp___1 = gettext("Unknown action should be performed.\n");
#line 380
  errstr(tmp___1);
  }
#line 381
  return (-1);
}
}
#line 27 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v2.c"
static int v2_check_file___7(int fd , int type , int fmt___7 ) ;
#line 28
static int v2_init_io___7(struct quota_handle *h ) ;
#line 29
static int v2_new_io___7(struct quota_handle *h ) ;
#line 30
static int v2_write_info___7(struct quota_handle *h ) ;
#line 31
static struct dquot *v2_read_dquot___7(struct quota_handle *h , qid_t id___0 ) ;
#line 32
static int v2_commit_dquot___7(struct dquot *dquot , int flags___7 ) ;
#line 33
static int v2_scan_dquots___7(struct quota_handle *h , int (*process_dquot)(struct dquot *dquot ,
                                                                            char *dqname ) ) ;
#line 34
static int v2_report___7(struct quota_handle *h , int verbose ) ;
#line 53 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v2.c"
static void v2r0_disk2memdqblk___7(struct dquot *dquot , void *dp ) 
{ 
  struct util_dqblk *m ;
  struct v2r0_disk_dqblk *d ;
  struct v2r0_disk_dqblk empty ;
  int tmp ;

  {
  {
#line 55
  m = & dquot->dq_dqb;
#line 56
  d = (struct v2r0_disk_dqblk *)dp;
#line 58
  dquot->dq_id = d->dqb_id;
#line 59
  m->dqb_ihardlimit = (qsize_t )d->dqb_ihardlimit;
#line 60
  m->dqb_isoftlimit = (qsize_t )d->dqb_isoftlimit;
#line 61
  m->dqb_bhardlimit = (qsize_t )d->dqb_bhardlimit;
#line 62
  m->dqb_bsoftlimit = (qsize_t )d->dqb_bsoftlimit;
#line 63
  m->dqb_curinodes = (qsize_t )d->dqb_curinodes;
#line 64
  m->dqb_curspace = (qsize_t )((__le64 )d->dqb_curspace);
#line 65
  m->dqb_itime = (time_t )((__le64 )d->dqb_itime);
#line 66
  m->dqb_btime = (time_t )((__le64 )d->dqb_btime);
#line 68
  memset((void *)(& empty), 0, sizeof(struct v2r0_disk_dqblk ));
#line 69
  empty.dqb_itime = (u_int64_t )((__u64 )1);
#line 70
  tmp = memcmp((void const   *)(& empty), (void const   *)dp, sizeof(struct v2r0_disk_dqblk ));
  }
#line 70
  if (! tmp) {
#line 71
    m->dqb_itime = (time_t )0;
  }
#line 72
  return;
}
}
#line 77 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v2.c"
static void v2r0_mem2diskdqblk___7(void *dp , struct dquot *dquot ) 
{ 
  struct util_dqblk *m ;
  struct v2r0_disk_dqblk *d ;
  struct qtree_mem_dqinfo *info ;
  int tmp ;

  {
  {
#line 79
  m = & dquot->dq_dqb;
#line 80
  d = (struct v2r0_disk_dqblk *)dp;
#line 81
  info = & (dquot->dq_h)->qh_info.u.v2_mdqi.dqi_qtree;
#line 83
  d->dqb_ihardlimit = (__u32 )m->dqb_ihardlimit;
#line 84
  d->dqb_isoftlimit = (__u32 )m->dqb_isoftlimit;
#line 85
  d->dqb_bhardlimit = (__u32 )m->dqb_bhardlimit;
#line 86
  d->dqb_bsoftlimit = (__u32 )m->dqb_bsoftlimit;
#line 87
  d->dqb_curinodes = (__u32 )m->dqb_curinodes;
#line 88
  d->dqb_curspace = (u_int64_t )((__u64 )m->dqb_curspace);
#line 89
  d->dqb_itime = (u_int64_t )((__u64 )m->dqb_itime);
#line 90
  d->dqb_btime = (u_int64_t )((__u64 )m->dqb_btime);
#line 91
  d->dqb_id = dquot->dq_id;
#line 92
  tmp = qtree_entry_unused(info, (char *)dp);
  }
#line 92
  if (tmp) {
#line 93
    d->dqb_itime = (u_int64_t )((__u64 )1);
  }
#line 94
  return;
}
}
#line 96 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v2.c"
static int v2r0_is_id___7(void *dp , struct dquot *dquot ) 
{ 
  struct v2r0_disk_dqblk *d ;
  struct qtree_mem_dqinfo *info ;
  int tmp ;

  {
  {
#line 98
  d = (struct v2r0_disk_dqblk *)dp;
#line 99
  info = & (dquot->dq_h)->qh_info.u.v2_mdqi.dqi_qtree;
#line 101
  tmp = qtree_entry_unused(info, (char *)dp);
  }
#line 101
  if (tmp) {
#line 102
    return (0);
  }
#line 103
  return (d->dqb_id == dquot->dq_id);
}
}
#line 109 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v2.c"
static void v2r1_disk2memdqblk___7(struct dquot *dquot , void *dp ) 
{ 
  struct util_dqblk *m ;
  struct v2r1_disk_dqblk *d ;
  struct v2r1_disk_dqblk empty ;
  int tmp ;

  {
  {
#line 111
  m = & dquot->dq_dqb;
#line 112
  d = (struct v2r1_disk_dqblk *)dp;
#line 114
  dquot->dq_id = d->dqb_id;
#line 115
  m->dqb_ihardlimit = (qsize_t )((__le64 )d->dqb_ihardlimit);
#line 116
  m->dqb_isoftlimit = (qsize_t )((__le64 )d->dqb_isoftlimit);
#line 117
  m->dqb_bhardlimit = (qsize_t )((__le64 )d->dqb_bhardlimit);
#line 118
  m->dqb_bsoftlimit = (qsize_t )((__le64 )d->dqb_bsoftlimit);
#line 119
  m->dqb_curinodes = (qsize_t )((__le64 )d->dqb_curinodes);
#line 120
  m->dqb_curspace = (qsize_t )((__le64 )d->dqb_curspace);
#line 121
  m->dqb_itime = (time_t )((__le64 )d->dqb_itime);
#line 122
  m->dqb_btime = (time_t )((__le64 )d->dqb_btime);
#line 124
  memset((void *)(& empty), 0, sizeof(struct v2r1_disk_dqblk ));
#line 125
  empty.dqb_itime = (u_int64_t )((__u64 )1);
#line 126
  tmp = memcmp((void const   *)(& empty), (void const   *)dp, sizeof(struct v2r1_disk_dqblk ));
  }
#line 126
  if (! tmp) {
#line 127
    m->dqb_itime = (time_t )0;
  }
#line 128
  return;
}
}
#line 133 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v2.c"
static void v2r1_mem2diskdqblk___7(void *dp , struct dquot *dquot ) 
{ 
  struct util_dqblk *m ;
  struct v2r1_disk_dqblk *d ;
  int tmp ;

  {
  {
#line 135
  m = & dquot->dq_dqb;
#line 136
  d = (struct v2r1_disk_dqblk *)dp;
#line 138
  d->dqb_ihardlimit = (u_int64_t )((__u64 )m->dqb_ihardlimit);
#line 139
  d->dqb_isoftlimit = (u_int64_t )((__u64 )m->dqb_isoftlimit);
#line 140
  d->dqb_bhardlimit = (u_int64_t )((__u64 )m->dqb_bhardlimit);
#line 141
  d->dqb_bsoftlimit = (u_int64_t )((__u64 )m->dqb_bsoftlimit);
#line 142
  d->dqb_curinodes = (u_int64_t )((__u64 )m->dqb_curinodes);
#line 143
  d->dqb_curspace = (u_int64_t )((__u64 )m->dqb_curspace);
#line 144
  d->dqb_itime = (u_int64_t )((__u64 )m->dqb_itime);
#line 145
  d->dqb_btime = (u_int64_t )((__u64 )m->dqb_btime);
#line 146
  d->dqb_id = dquot->dq_id;
#line 147
  d->dqb_pad = (u_int32_t )0;
#line 148
  tmp = qtree_entry_unused(& (dquot->dq_h)->qh_info.u.v2_mdqi.dqi_qtree, (char *)dp);
  }
#line 148
  if (tmp) {
#line 149
    d->dqb_itime = (u_int64_t )((__u64 )1);
  }
#line 150
  return;
}
}
#line 152 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v2.c"
static int v2r1_is_id___7(void *dp , struct dquot *dquot ) 
{ 
  struct v2r1_disk_dqblk *d ;
  struct qtree_mem_dqinfo *info ;
  int tmp ;

  {
  {
#line 154
  d = (struct v2r1_disk_dqblk *)dp;
#line 155
  info = & (dquot->dq_h)->qh_info.u.v2_mdqi.dqi_qtree;
#line 157
  tmp = qtree_entry_unused(info, (char *)dp);
  }
#line 157
  if (tmp) {
#line 158
    return (0);
  }
#line 159
  return (d->dqb_id == dquot->dq_id);
}
}
#line 162 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v2.c"
static struct qtree_fmt_operations v2r0_fmt_ops___7  =    {& v2r0_mem2diskdqblk___7, & v2r0_disk2memdqblk___7, & v2r0_is_id___7};
#line 168 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v2.c"
static struct qtree_fmt_operations v2r1_fmt_ops___7  =    {& v2r1_mem2diskdqblk___7, & v2r1_disk2memdqblk___7, & v2r1_is_id___7};
#line 226 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v2.c"
static int v2_read_header___7(int fd , struct v2_disk_dqheader *h ) 
{ 
  ssize_t tmp ;

  {
  {
#line 228
  lseek(fd, (__off64_t )0, 0);
#line 229
  tmp = read(fd, (void *)h, sizeof(struct v2_disk_dqheader ));
  }
#line 229
  if ((unsigned long )tmp != sizeof(struct v2_disk_dqheader )) {
#line 230
    return (0);
  }
#line 231
  return (1);
}
}
#line 237 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v2.c"
static int v2_check_file___7(int fd , int type , int fmt___7 ) 
{ 
  struct v2_disk_dqheader h ;
  int file_magics[2] ;
  int known_versions___0[2] ;
  int version___0 ;
  int tmp ;
  char *tmp___0 ;
  __u32 tmp___1 ;

  {
  {
#line 240
  file_magics[0] = -641720559;
#line 240
  file_magics[1] = -641722073;
#line 241
  known_versions___0[0] = 1;
#line 241
  known_versions___0[1] = 1;
#line 244
  tmp = v2_read_header___7(fd, & h);
  }
#line 244
  if (! tmp) {
#line 245
    return (0);
  }
#line 246
  if (fmt___7 == 1) {
#line 247
    version___0 = 0;
  } else
#line 248
  if (fmt___7 == 2) {
#line 249
    version___0 = 1;
  } else {
#line 251
    return (0);
  }
#line 253
  if (h.dqh_magic != (__u32 )file_magics[type]) {
    {
#line 254
    tmp___1 = __fswab32(h.dqh_magic);
    }
#line 254
    if (tmp___1 == (__u32 )file_magics[type]) {
      {
#line 255
      tmp___0 = gettext("Your quota file is stored in wrong endianity. Please use convertquota(8) to convert it.\n");
#line 255
      die(3, tmp___0);
      }
    }
#line 256
    return (0);
  }
#line 258
  if (h.dqh_version > (__u32 )known_versions___0[type]) {
#line 259
    return (0);
  }
#line 260
  if ((__u32 )version___0 != h.dqh_version) {
#line 261
    return (0);
  }
#line 262
  return (1);
}
}
#line 268 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v2.c"
static int v2_init_io___7(struct quota_handle *h ) 
{ 
  int tmp ;
  struct v2_kern_dqinfo kdqinfo ;
  int *tmp___0 ;
  long tmp___1 ;
  struct v2_disk_dqinfo ddqinfo ;
  struct v2_disk_dqheader header ;
  int tmp___2 ;
  ssize_t tmp___3 ;

  {
#line 270
  if (h->qh_io_flags & 1) {
#line 271
    if (kernel_iface == 3) {
      {
#line 272
      tmp = vfs_get_info(h);
      }
#line 272
      if (tmp < 0) {
#line 273
        return (-1);
      }
    } else {
      {
#line 278
      tmp___1 = quotactl((2304 << 8) | (h->qh_type & 255), (char const   *)(h->qh_quotadev),
                         (qid_t )0, (caddr_t )((void *)(& kdqinfo)));
      }
#line 278
      if (tmp___1 < 0L) {
        {
#line 280
        tmp___0 = __errno_location();
        }
#line 280
        if (*tmp___0 == 1) {
#line 281
          return (0);
        }
#line 282
        return (-1);
      }
#line 284
      h->qh_info.dqi_bgrace = (time_t )kdqinfo.dqi_bgrace;
#line 285
      h->qh_info.dqi_igrace = (time_t )kdqinfo.dqi_igrace;
#line 286
      h->qh_info.u.v2_mdqi.dqi_flags = kdqinfo.dqi_flags;
#line 287
      h->qh_info.u.v2_mdqi.dqi_qtree.dqi_blocks = kdqinfo.dqi_blocks;
#line 288
      h->qh_info.u.v2_mdqi.dqi_qtree.dqi_free_blk = kdqinfo.dqi_free_blk;
#line 289
      h->qh_info.u.v2_mdqi.dqi_qtree.dqi_free_entry = kdqinfo.dqi_free_entry;
    }
  }
#line 292
  if (h->qh_fd != -1) {
    {
#line 296
    tmp___2 = v2_read_header___7(h->qh_fd, & header);
    }
#line 296
    if (! tmp___2) {
#line 297
      return (-1);
    }
    {
#line 299
    lseek(h->qh_fd, (__off64_t )sizeof(struct v2_disk_dqheader ), 0);
#line 300
    tmp___3 = read(h->qh_fd, (void *)(& ddqinfo), sizeof(ddqinfo));
    }
#line 300
    if ((unsigned long )tmp___3 != sizeof(ddqinfo)) {
#line 301
      return (-1);
    }
#line 303
    if (! (h->qh_io_flags & 1)) {
      {
#line 304
      v2_disk2memdqinfo(& h->qh_info, & ddqinfo);
      }
    } else {
#line 306
      h->qh_info.u.v2_mdqi.dqi_qtree.dqi_blocks = ddqinfo.dqi_blocks;
    }
#line 308
    if (header.dqh_version == 0U) {
#line 309
      h->qh_info.u.v2_mdqi.dqi_qtree.dqi_entry_size = (unsigned int )sizeof(struct v2r0_disk_dqblk );
#line 310
      h->qh_info.u.v2_mdqi.dqi_qtree.dqi_ops = & v2r0_fmt_ops___7;
#line 311
      h->qh_info.dqi_max_b_limit = (uint64_t )(~ ((uint32_t )0));
#line 312
      h->qh_info.dqi_max_i_limit = (uint64_t )(~ ((uint32_t )0));
#line 313
      h->qh_info.dqi_max_b_usage = ~ ((uint64_t )0);
#line 314
      h->qh_info.dqi_max_i_usage = (uint64_t )(~ ((uint32_t )0));
    } else {
#line 316
      h->qh_info.u.v2_mdqi.dqi_qtree.dqi_entry_size = (unsigned int )sizeof(struct v2r1_disk_dqblk );
#line 317
      h->qh_info.u.v2_mdqi.dqi_qtree.dqi_ops = & v2r1_fmt_ops___7;
#line 318
      h->qh_info.dqi_max_b_limit = ~ ((uint64_t )0);
#line 319
      h->qh_info.dqi_max_i_limit = ~ ((uint64_t )0);
#line 320
      h->qh_info.dqi_max_b_usage = ~ ((uint64_t )0);
#line 321
      h->qh_info.dqi_max_i_usage = ~ ((uint64_t )0);
    }
  } else {
#line 325
    h->qh_info.u.v2_mdqi.dqi_qtree.dqi_ops = (struct qtree_fmt_operations *)((void *)0);
  }
#line 327
  return (0);
}
}
#line 333 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v2.c"
static int v2_new_io___7(struct quota_handle *h ) 
{ 
  int file_magics[2] ;
  struct v2_disk_dqheader ddqheader ;
  struct v2_disk_dqinfo ddqinfo ;
  int version___0 ;
  ssize_t tmp ;
  ssize_t tmp___0 ;

  {
#line 335
  file_magics[0] = -641720559;
#line 335
  file_magics[1] = -641722073;
#line 340
  if (h->qh_fmt == 1) {
#line 341
    version___0 = 0;
  } else
#line 342
  if (h->qh_fmt == 2) {
#line 343
    version___0 = 1;
  } else {
#line 345
    return (-1);
  }
  {
#line 348
  ddqheader.dqh_magic = (__u32 )file_magics[h->qh_type];
#line 349
  ddqheader.dqh_version = (__u32 )version___0;
#line 350
  lseek(h->qh_fd, (__off64_t )0, 0);
#line 351
  tmp = write(h->qh_fd, (void const   *)(& ddqheader), sizeof(ddqheader));
  }
#line 351
  if ((unsigned long )tmp != sizeof(ddqheader)) {
#line 352
    return (-1);
  }
#line 354
  h->qh_info.dqi_bgrace = (time_t )604800;
#line 355
  h->qh_info.dqi_igrace = (time_t )604800;
#line 356
  h->qh_info.u.v2_mdqi.dqi_flags = (uint )0;
#line 357
  h->qh_info.u.v2_mdqi.dqi_qtree.dqi_blocks = 2U;
#line 358
  h->qh_info.u.v2_mdqi.dqi_qtree.dqi_free_blk = 0U;
#line 359
  h->qh_info.u.v2_mdqi.dqi_qtree.dqi_free_entry = 0U;
#line 360
  if (version___0 == 0) {
#line 361
    h->qh_info.u.v2_mdqi.dqi_qtree.dqi_entry_size = (unsigned int )sizeof(struct v2r0_disk_dqblk );
#line 362
    h->qh_info.u.v2_mdqi.dqi_qtree.dqi_ops = & v2r0_fmt_ops___7;
#line 363
    h->qh_info.dqi_max_b_limit = (uint64_t )(~ ((uint32_t )0));
#line 364
    h->qh_info.dqi_max_i_limit = (uint64_t )(~ ((uint32_t )0));
#line 365
    h->qh_info.dqi_max_b_usage = ~ ((uint64_t )0);
#line 366
    h->qh_info.dqi_max_i_usage = (uint64_t )(~ ((uint32_t )0));
  } else
#line 367
  if (version___0 == 1) {
#line 368
    h->qh_info.u.v2_mdqi.dqi_qtree.dqi_entry_size = (unsigned int )sizeof(struct v2r1_disk_dqblk );
#line 369
    h->qh_info.u.v2_mdqi.dqi_qtree.dqi_ops = & v2r1_fmt_ops___7;
#line 370
    h->qh_info.dqi_max_b_limit = ~ ((uint64_t )0);
#line 371
    h->qh_info.dqi_max_i_limit = ~ ((uint64_t )0);
#line 372
    h->qh_info.dqi_max_b_usage = ~ ((uint64_t )0);
#line 373
    h->qh_info.dqi_max_i_usage = ~ ((uint64_t )0);
  }
  {
#line 375
  v2_mem2diskdqinfo(& ddqinfo, & h->qh_info);
#line 376
  lseek(h->qh_fd, (__off64_t )sizeof(struct v2_disk_dqheader ), 0);
#line 377
  tmp___0 = write(h->qh_fd, (void const   *)(& ddqinfo), sizeof(ddqinfo));
  }
#line 377
  if ((unsigned long )tmp___0 != sizeof(ddqinfo)) {
#line 378
    return (-1);
  }
#line 379
  return (0);
}
}
#line 385 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v2.c"
static int v2_write_info___7(struct quota_handle *h ) 
{ 
  char *tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  struct v2_kern_dqinfo kdqinfo ;
  long tmp___2 ;
  long tmp___3 ;
  struct v2_disk_dqinfo ddqinfo ;
  ssize_t tmp___4 ;

  {
#line 387
  if (h->qh_io_flags & 4) {
    {
#line 388
    tmp = gettext("Trying to write info to readonly quotafile on %s\n");
#line 388
    errstr(tmp, h->qh_quotadev);
#line 389
    tmp___0 = __errno_location();
#line 389
    *tmp___0 = 1;
    }
#line 390
    return (-1);
  }
#line 392
  if (h->qh_io_flags & 1) {
#line 393
    if (kernel_iface == 3) {
      {
#line 394
      tmp___1 = vfs_set_info(h, 3);
      }
#line 394
      if (tmp___1) {
#line 395
        return (-1);
      }
    } else {
      {
#line 400
      kdqinfo.dqi_bgrace = (unsigned int )h->qh_info.dqi_bgrace;
#line 401
      kdqinfo.dqi_igrace = (unsigned int )h->qh_info.dqi_igrace;
#line 402
      kdqinfo.dqi_flags = h->qh_info.u.v2_mdqi.dqi_flags;
#line 403
      kdqinfo.dqi_blocks = h->qh_info.u.v2_mdqi.dqi_qtree.dqi_blocks;
#line 404
      kdqinfo.dqi_free_blk = h->qh_info.u.v2_mdqi.dqi_qtree.dqi_free_blk;
#line 405
      kdqinfo.dqi_free_entry = h->qh_info.u.v2_mdqi.dqi_qtree.dqi_free_entry;
#line 406
      tmp___2 = quotactl((2816 << 8) | (h->qh_type & 255), (char const   *)(h->qh_quotadev),
                         (qid_t )0, (caddr_t )((void *)(& kdqinfo)));
      }
#line 406
      if (tmp___2 < 0L) {
#line 408
        return (-1);
      } else {
        {
#line 406
        tmp___3 = quotactl((3072 << 8) | (h->qh_type & 255), (char const   *)(h->qh_quotadev),
                           (qid_t )0, (caddr_t )((void *)(& kdqinfo)));
        }
#line 406
        if (tmp___3 < 0L) {
#line 408
          return (-1);
        }
      }
    }
  } else {
    {
#line 414
    v2_mem2diskdqinfo(& ddqinfo, & h->qh_info);
#line 415
    lseek(h->qh_fd, (__off64_t )sizeof(struct v2_disk_dqheader ), 0);
#line 416
    tmp___4 = write(h->qh_fd, (void const   *)(& ddqinfo), sizeof(ddqinfo));
    }
#line 416
    if ((unsigned long )tmp___4 != sizeof(ddqinfo)) {
#line 417
      return (-1);
    }
  }
#line 419
  return (0);
}
}
#line 426 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v2.c"
static struct dquot *v2_read_dquot___7(struct quota_handle *h , qid_t id___0 ) 
{ 
  struct dquot *dquot ;
  struct dquot *tmp ;
  int tmp___0 ;
  struct v2_kern_dqblk kdqblk ;
  long tmp___1 ;
  struct dquot *tmp___2 ;

  {
#line 428
  if (h->qh_io_flags & 1) {
    {
#line 429
    tmp = get_empty_dquot();
#line 429
    dquot = tmp;
#line 431
    dquot->dq_id = id___0;
#line 432
    dquot->dq_h = h;
#line 433
    dquot->dq_dqb.u.v2_mdqb.dqb_off = (loff_t )0;
#line 434
    memset((void *)(& dquot->dq_dqb), 0, sizeof(struct util_dqblk ));
    }
#line 435
    if (kernel_iface == 3) {
      {
#line 436
      tmp___0 = vfs_get_dquot(dquot);
      }
#line 436
      if (tmp___0 < 0) {
        {
#line 437
        free((void *)dquot);
        }
#line 438
        return ((struct dquot *)((void *)0));
      }
    } else {
      {
#line 444
      tmp___1 = quotactl((3328 << 8) | (h->qh_type & 255), (char const   *)(h->qh_quotadev),
                         id___0, (caddr_t )((void *)(& kdqblk)));
      }
#line 444
      if (tmp___1 < 0L) {
        {
#line 445
        free((void *)dquot);
        }
#line 446
        return ((struct dquot *)((void *)0));
      }
      {
#line 448
      v2_kern2utildqblk(& dquot->dq_dqb, & kdqblk);
      }
    }
#line 450
    return (dquot);
  }
  {
#line 452
  tmp___2 = qtree_read_dquot(h, id___0);
  }
#line 452
  return (tmp___2);
}
}
#line 459 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v2.c"
static int v2_commit_dquot___7(struct dquot *dquot , int flags___7 ) 
{ 
  struct util_dqblk *b ;
  char *tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  struct v2_kern_dqblk kdqblk ;
  int cmd ;
  int *tmp___2 ;
  long tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;

  {
#line 461
  b = & dquot->dq_dqb;
#line 463
  if ((dquot->dq_h)->qh_io_flags & 4) {
    {
#line 464
    tmp = gettext("Trying to write quota to readonly quotafile on %s\n");
#line 464
    errstr(tmp, (dquot->dq_h)->qh_quotadev);
#line 465
    tmp___0 = __errno_location();
#line 465
    *tmp___0 = 1;
    }
#line 466
    return (-1);
  }
#line 468
  if ((dquot->dq_h)->qh_io_flags & 1) {
#line 469
    if (kernel_iface == 3) {
      {
#line 470
      tmp___1 = vfs_set_dquot(dquot, flags___7);
      }
#line 470
      if (tmp___1 < 0) {
#line 471
        return (-1);
      }
    } else {
#line 477
      if (flags___7 == 10) {
#line 478
        cmd = 3840;
      } else
#line 479
      if (flags___7 == 5) {
#line 480
        cmd = 1792;
      } else
#line 481
      if (flags___7 & 48) {
        {
#line 482
        tmp___2 = __errno_location();
#line 482
        *tmp___2 = 22;
        }
#line 483
        return (-1);
      } else {
#line 486
        cmd = 3584;
      }
      {
#line 487
      v2_util2kerndqblk(& kdqblk, & dquot->dq_dqb);
#line 488
      tmp___3 = quotactl((cmd << 8) | ((dquot->dq_h)->qh_type & 255), (char const   *)((dquot->dq_h)->qh_quotadev),
                         dquot->dq_id, (caddr_t )((void *)(& kdqblk)));
      }
#line 488
      if (tmp___3 < 0L) {
#line 490
        return (-1);
      }
    }
#line 492
    return (0);
  }
#line 494
  if (! b->dqb_curspace) {
#line 494
    if (! b->dqb_curinodes) {
#line 494
      if (! b->dqb_bsoftlimit) {
#line 494
        if (! b->dqb_isoftlimit) {
#line 494
          if (! b->dqb_bhardlimit) {
#line 494
            if (! b->dqb_ihardlimit) {
              {
#line 496
              qtree_delete_dquot(dquot);
              }
            } else {
#line 494
              goto _L___3;
            }
          } else {
#line 494
            goto _L___3;
          }
        } else {
#line 494
          goto _L___3;
        }
      } else {
#line 494
        goto _L___3;
      }
    } else {
#line 494
      goto _L___3;
    }
  } else {
    _L___3: /* CIL Label */ 
    {
#line 498
    tmp___5 = check_dquot_range(dquot);
    }
#line 498
    if (tmp___5 < 0) {
      {
#line 499
      tmp___4 = __errno_location();
#line 499
      *tmp___4 = 34;
      }
#line 500
      return (-1);
    }
    {
#line 502
    qtree_write_dquot(dquot);
    }
  }
#line 504
  return (0);
}
}
#line 507 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v2.c"
static int v2_scan_dquots___7(struct quota_handle *h , int (*process_dquot)(struct dquot *dquot ,
                                                                            char *dqname ) ) 
{ 
  int tmp ;

  {
  {
#line 509
  tmp = qtree_scan_dquots(h, process_dquot);
  }
#line 509
  return (tmp);
}
}
#line 513 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v2.c"
static int v2_report___7(struct quota_handle *h , int verbose ) 
{ 
  struct v2_mem_dqinfo *info ;
  char *tmp ;

  {
#line 515
  if (verbose) {
    {
#line 516
    info = & h->qh_info.u.v2_mdqi;
#line 518
    tmp = gettext("Statistics:\nTotal blocks: %u\nData blocks: %u\nEntries: %u\nUsed average: %f\n");
#line 518
    printf((char const   */* __restrict  */)tmp, info->dqi_qtree.dqi_blocks, info->dqi_data_blocks,
           info->dqi_used_entries, (double )((float )info->dqi_used_entries / (float )info->dqi_data_blocks));
    }
  }
#line 522
  return (0);
}
}
#line 23 "/home/wheatley/newnew/temp/quota-4.01/common.c"
static int enable_syslog___9  =    0;
#line 31 "/home/wheatley/newnew/temp/quota-4.01/common.c"
static void do_syslog___9(int level , char const   *format , va_list args ) 
{ 
  char buf[1024] ;
  int i ;
  int j ;
  int tmp ;

  {
  {
#line 36
  vsnprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)format,
            args);
#line 39
  i = 0;
  }
  {
#line 39
  while (1) {
    while_continue: /* CIL Label */ ;
#line 39
    if (! buf[i]) {
#line 39
      goto while_break;
    }
#line 40
    j = i;
    {
#line 40
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 40
      if (buf[j]) {
#line 40
        if (! ((int )buf[j] != 10)) {
#line 40
          goto while_break___0;
        }
      } else {
#line 40
        goto while_break___0;
      }
#line 40
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 41
    if ((int )buf[j] == 10) {
#line 42
      tmp = j;
#line 42
      j ++;
#line 42
      buf[tmp] = (char )'\000';
    }
    {
#line 43
    syslog(level, "%s", buf + i);
#line 39
    i = j;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 45
  return;
}
}
#line 27 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v2.c"
static int v2_check_file___8(int fd , int type , int fmt___7 ) ;
#line 28
static int v2_init_io___8(struct quota_handle *h ) ;
#line 29
static int v2_new_io___8(struct quota_handle *h ) ;
#line 30
static int v2_write_info___8(struct quota_handle *h ) ;
#line 31
static struct dquot *v2_read_dquot___8(struct quota_handle *h , qid_t id___0 ) ;
#line 32
static int v2_commit_dquot___8(struct dquot *dquot , int flags___7 ) ;
#line 33
static int v2_scan_dquots___8(struct quota_handle *h , int (*process_dquot)(struct dquot *dquot ,
                                                                            char *dqname ) ) ;
#line 34
static int v2_report___8(struct quota_handle *h , int verbose ) ;
#line 53 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v2.c"
static void v2r0_disk2memdqblk___8(struct dquot *dquot , void *dp ) 
{ 
  struct util_dqblk *m ;
  struct v2r0_disk_dqblk *d ;
  struct v2r0_disk_dqblk empty ;
  int tmp ;

  {
  {
#line 55
  m = & dquot->dq_dqb;
#line 56
  d = (struct v2r0_disk_dqblk *)dp;
#line 58
  dquot->dq_id = d->dqb_id;
#line 59
  m->dqb_ihardlimit = (qsize_t )d->dqb_ihardlimit;
#line 60
  m->dqb_isoftlimit = (qsize_t )d->dqb_isoftlimit;
#line 61
  m->dqb_bhardlimit = (qsize_t )d->dqb_bhardlimit;
#line 62
  m->dqb_bsoftlimit = (qsize_t )d->dqb_bsoftlimit;
#line 63
  m->dqb_curinodes = (qsize_t )d->dqb_curinodes;
#line 64
  m->dqb_curspace = (qsize_t )((__le64 )d->dqb_curspace);
#line 65
  m->dqb_itime = (time_t )((__le64 )d->dqb_itime);
#line 66
  m->dqb_btime = (time_t )((__le64 )d->dqb_btime);
#line 68
  memset((void *)(& empty), 0, sizeof(struct v2r0_disk_dqblk ));
#line 69
  empty.dqb_itime = (u_int64_t )((__u64 )1);
#line 70
  tmp = memcmp((void const   *)(& empty), (void const   *)dp, sizeof(struct v2r0_disk_dqblk ));
  }
#line 70
  if (! tmp) {
#line 71
    m->dqb_itime = (time_t )0;
  }
#line 72
  return;
}
}
#line 77 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v2.c"
static void v2r0_mem2diskdqblk___8(void *dp , struct dquot *dquot ) 
{ 
  struct util_dqblk *m ;
  struct v2r0_disk_dqblk *d ;
  struct qtree_mem_dqinfo *info ;
  int tmp ;

  {
  {
#line 79
  m = & dquot->dq_dqb;
#line 80
  d = (struct v2r0_disk_dqblk *)dp;
#line 81
  info = & (dquot->dq_h)->qh_info.u.v2_mdqi.dqi_qtree;
#line 83
  d->dqb_ihardlimit = (__u32 )m->dqb_ihardlimit;
#line 84
  d->dqb_isoftlimit = (__u32 )m->dqb_isoftlimit;
#line 85
  d->dqb_bhardlimit = (__u32 )m->dqb_bhardlimit;
#line 86
  d->dqb_bsoftlimit = (__u32 )m->dqb_bsoftlimit;
#line 87
  d->dqb_curinodes = (__u32 )m->dqb_curinodes;
#line 88
  d->dqb_curspace = (u_int64_t )((__u64 )m->dqb_curspace);
#line 89
  d->dqb_itime = (u_int64_t )((__u64 )m->dqb_itime);
#line 90
  d->dqb_btime = (u_int64_t )((__u64 )m->dqb_btime);
#line 91
  d->dqb_id = dquot->dq_id;
#line 92
  tmp = qtree_entry_unused(info, (char *)dp);
  }
#line 92
  if (tmp) {
#line 93
    d->dqb_itime = (u_int64_t )((__u64 )1);
  }
#line 94
  return;
}
}
#line 96 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v2.c"
static int v2r0_is_id___8(void *dp , struct dquot *dquot ) 
{ 
  struct v2r0_disk_dqblk *d ;
  struct qtree_mem_dqinfo *info ;
  int tmp ;

  {
  {
#line 98
  d = (struct v2r0_disk_dqblk *)dp;
#line 99
  info = & (dquot->dq_h)->qh_info.u.v2_mdqi.dqi_qtree;
#line 101
  tmp = qtree_entry_unused(info, (char *)dp);
  }
#line 101
  if (tmp) {
#line 102
    return (0);
  }
#line 103
  return (d->dqb_id == dquot->dq_id);
}
}
#line 109 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v2.c"
static void v2r1_disk2memdqblk___8(struct dquot *dquot , void *dp ) 
{ 
  struct util_dqblk *m ;
  struct v2r1_disk_dqblk *d ;
  struct v2r1_disk_dqblk empty ;
  int tmp ;

  {
  {
#line 111
  m = & dquot->dq_dqb;
#line 112
  d = (struct v2r1_disk_dqblk *)dp;
#line 114
  dquot->dq_id = d->dqb_id;
#line 115
  m->dqb_ihardlimit = (qsize_t )((__le64 )d->dqb_ihardlimit);
#line 116
  m->dqb_isoftlimit = (qsize_t )((__le64 )d->dqb_isoftlimit);
#line 117
  m->dqb_bhardlimit = (qsize_t )((__le64 )d->dqb_bhardlimit);
#line 118
  m->dqb_bsoftlimit = (qsize_t )((__le64 )d->dqb_bsoftlimit);
#line 119
  m->dqb_curinodes = (qsize_t )((__le64 )d->dqb_curinodes);
#line 120
  m->dqb_curspace = (qsize_t )((__le64 )d->dqb_curspace);
#line 121
  m->dqb_itime = (time_t )((__le64 )d->dqb_itime);
#line 122
  m->dqb_btime = (time_t )((__le64 )d->dqb_btime);
#line 124
  memset((void *)(& empty), 0, sizeof(struct v2r1_disk_dqblk ));
#line 125
  empty.dqb_itime = (u_int64_t )((__u64 )1);
#line 126
  tmp = memcmp((void const   *)(& empty), (void const   *)dp, sizeof(struct v2r1_disk_dqblk ));
  }
#line 126
  if (! tmp) {
#line 127
    m->dqb_itime = (time_t )0;
  }
#line 128
  return;
}
}
#line 133 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v2.c"
static void v2r1_mem2diskdqblk___8(void *dp , struct dquot *dquot ) 
{ 
  struct util_dqblk *m ;
  struct v2r1_disk_dqblk *d ;
  int tmp ;

  {
  {
#line 135
  m = & dquot->dq_dqb;
#line 136
  d = (struct v2r1_disk_dqblk *)dp;
#line 138
  d->dqb_ihardlimit = (u_int64_t )((__u64 )m->dqb_ihardlimit);
#line 139
  d->dqb_isoftlimit = (u_int64_t )((__u64 )m->dqb_isoftlimit);
#line 140
  d->dqb_bhardlimit = (u_int64_t )((__u64 )m->dqb_bhardlimit);
#line 141
  d->dqb_bsoftlimit = (u_int64_t )((__u64 )m->dqb_bsoftlimit);
#line 142
  d->dqb_curinodes = (u_int64_t )((__u64 )m->dqb_curinodes);
#line 143
  d->dqb_curspace = (u_int64_t )((__u64 )m->dqb_curspace);
#line 144
  d->dqb_itime = (u_int64_t )((__u64 )m->dqb_itime);
#line 145
  d->dqb_btime = (u_int64_t )((__u64 )m->dqb_btime);
#line 146
  d->dqb_id = dquot->dq_id;
#line 147
  d->dqb_pad = (u_int32_t )0;
#line 148
  tmp = qtree_entry_unused(& (dquot->dq_h)->qh_info.u.v2_mdqi.dqi_qtree, (char *)dp);
  }
#line 148
  if (tmp) {
#line 149
    d->dqb_itime = (u_int64_t )((__u64 )1);
  }
#line 150
  return;
}
}
#line 152 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v2.c"
static int v2r1_is_id___8(void *dp , struct dquot *dquot ) 
{ 
  struct v2r1_disk_dqblk *d ;
  struct qtree_mem_dqinfo *info ;
  int tmp ;

  {
  {
#line 154
  d = (struct v2r1_disk_dqblk *)dp;
#line 155
  info = & (dquot->dq_h)->qh_info.u.v2_mdqi.dqi_qtree;
#line 157
  tmp = qtree_entry_unused(info, (char *)dp);
  }
#line 157
  if (tmp) {
#line 158
    return (0);
  }
#line 159
  return (d->dqb_id == dquot->dq_id);
}
}
#line 162 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v2.c"
static struct qtree_fmt_operations v2r0_fmt_ops___8  =    {& v2r0_mem2diskdqblk___8, & v2r0_disk2memdqblk___8, & v2r0_is_id___8};
#line 168 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v2.c"
static struct qtree_fmt_operations v2r1_fmt_ops___8  =    {& v2r1_mem2diskdqblk___8, & v2r1_disk2memdqblk___8, & v2r1_is_id___8};
#line 226 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v2.c"
static int v2_read_header___8(int fd , struct v2_disk_dqheader *h ) 
{ 
  ssize_t tmp ;

  {
  {
#line 228
  lseek(fd, (__off64_t )0, 0);
#line 229
  tmp = read(fd, (void *)h, sizeof(struct v2_disk_dqheader ));
  }
#line 229
  if ((unsigned long )tmp != sizeof(struct v2_disk_dqheader )) {
#line 230
    return (0);
  }
#line 231
  return (1);
}
}
#line 237 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v2.c"
static int v2_check_file___8(int fd , int type , int fmt___7 ) 
{ 
  struct v2_disk_dqheader h ;
  int file_magics[2] ;
  int known_versions___0[2] ;
  int version___0 ;
  int tmp ;
  char *tmp___0 ;
  __u32 tmp___1 ;

  {
  {
#line 240
  file_magics[0] = -641720559;
#line 240
  file_magics[1] = -641722073;
#line 241
  known_versions___0[0] = 1;
#line 241
  known_versions___0[1] = 1;
#line 244
  tmp = v2_read_header___8(fd, & h);
  }
#line 244
  if (! tmp) {
#line 245
    return (0);
  }
#line 246
  if (fmt___7 == 1) {
#line 247
    version___0 = 0;
  } else
#line 248
  if (fmt___7 == 2) {
#line 249
    version___0 = 1;
  } else {
#line 251
    return (0);
  }
#line 253
  if (h.dqh_magic != (__u32 )file_magics[type]) {
    {
#line 254
    tmp___1 = __fswab32(h.dqh_magic);
    }
#line 254
    if (tmp___1 == (__u32 )file_magics[type]) {
      {
#line 255
      tmp___0 = gettext("Your quota file is stored in wrong endianity. Please use convertquota(8) to convert it.\n");
#line 255
      die(3, tmp___0);
      }
    }
#line 256
    return (0);
  }
#line 258
  if (h.dqh_version > (__u32 )known_versions___0[type]) {
#line 259
    return (0);
  }
#line 260
  if ((__u32 )version___0 != h.dqh_version) {
#line 261
    return (0);
  }
#line 262
  return (1);
}
}
#line 268 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v2.c"
static int v2_init_io___8(struct quota_handle *h ) 
{ 
  int tmp ;
  struct v2_kern_dqinfo kdqinfo ;
  int *tmp___0 ;
  long tmp___1 ;
  struct v2_disk_dqinfo ddqinfo ;
  struct v2_disk_dqheader header ;
  int tmp___2 ;
  ssize_t tmp___3 ;

  {
#line 270
  if (h->qh_io_flags & 1) {
#line 271
    if (kernel_iface == 3) {
      {
#line 272
      tmp = vfs_get_info(h);
      }
#line 272
      if (tmp < 0) {
#line 273
        return (-1);
      }
    } else {
      {
#line 278
      tmp___1 = quotactl((2304 << 8) | (h->qh_type & 255), (char const   *)(h->qh_quotadev),
                         (qid_t )0, (caddr_t )((void *)(& kdqinfo)));
      }
#line 278
      if (tmp___1 < 0L) {
        {
#line 280
        tmp___0 = __errno_location();
        }
#line 280
        if (*tmp___0 == 1) {
#line 281
          return (0);
        }
#line 282
        return (-1);
      }
#line 284
      h->qh_info.dqi_bgrace = (time_t )kdqinfo.dqi_bgrace;
#line 285
      h->qh_info.dqi_igrace = (time_t )kdqinfo.dqi_igrace;
#line 286
      h->qh_info.u.v2_mdqi.dqi_flags = kdqinfo.dqi_flags;
#line 287
      h->qh_info.u.v2_mdqi.dqi_qtree.dqi_blocks = kdqinfo.dqi_blocks;
#line 288
      h->qh_info.u.v2_mdqi.dqi_qtree.dqi_free_blk = kdqinfo.dqi_free_blk;
#line 289
      h->qh_info.u.v2_mdqi.dqi_qtree.dqi_free_entry = kdqinfo.dqi_free_entry;
    }
  }
#line 292
  if (h->qh_fd != -1) {
    {
#line 296
    tmp___2 = v2_read_header___8(h->qh_fd, & header);
    }
#line 296
    if (! tmp___2) {
#line 297
      return (-1);
    }
    {
#line 299
    lseek(h->qh_fd, (__off64_t )sizeof(struct v2_disk_dqheader ), 0);
#line 300
    tmp___3 = read(h->qh_fd, (void *)(& ddqinfo), sizeof(ddqinfo));
    }
#line 300
    if ((unsigned long )tmp___3 != sizeof(ddqinfo)) {
#line 301
      return (-1);
    }
#line 303
    if (! (h->qh_io_flags & 1)) {
      {
#line 304
      v2_disk2memdqinfo(& h->qh_info, & ddqinfo);
      }
    } else {
#line 306
      h->qh_info.u.v2_mdqi.dqi_qtree.dqi_blocks = ddqinfo.dqi_blocks;
    }
#line 308
    if (header.dqh_version == 0U) {
#line 309
      h->qh_info.u.v2_mdqi.dqi_qtree.dqi_entry_size = (unsigned int )sizeof(struct v2r0_disk_dqblk );
#line 310
      h->qh_info.u.v2_mdqi.dqi_qtree.dqi_ops = & v2r0_fmt_ops___8;
#line 311
      h->qh_info.dqi_max_b_limit = (uint64_t )(~ ((uint32_t )0));
#line 312
      h->qh_info.dqi_max_i_limit = (uint64_t )(~ ((uint32_t )0));
#line 313
      h->qh_info.dqi_max_b_usage = ~ ((uint64_t )0);
#line 314
      h->qh_info.dqi_max_i_usage = (uint64_t )(~ ((uint32_t )0));
    } else {
#line 316
      h->qh_info.u.v2_mdqi.dqi_qtree.dqi_entry_size = (unsigned int )sizeof(struct v2r1_disk_dqblk );
#line 317
      h->qh_info.u.v2_mdqi.dqi_qtree.dqi_ops = & v2r1_fmt_ops___8;
#line 318
      h->qh_info.dqi_max_b_limit = ~ ((uint64_t )0);
#line 319
      h->qh_info.dqi_max_i_limit = ~ ((uint64_t )0);
#line 320
      h->qh_info.dqi_max_b_usage = ~ ((uint64_t )0);
#line 321
      h->qh_info.dqi_max_i_usage = ~ ((uint64_t )0);
    }
  } else {
#line 325
    h->qh_info.u.v2_mdqi.dqi_qtree.dqi_ops = (struct qtree_fmt_operations *)((void *)0);
  }
#line 327
  return (0);
}
}
#line 333 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v2.c"
static int v2_new_io___8(struct quota_handle *h ) 
{ 
  int file_magics[2] ;
  struct v2_disk_dqheader ddqheader ;
  struct v2_disk_dqinfo ddqinfo ;
  int version___0 ;
  ssize_t tmp ;
  ssize_t tmp___0 ;

  {
#line 335
  file_magics[0] = -641720559;
#line 335
  file_magics[1] = -641722073;
#line 340
  if (h->qh_fmt == 1) {
#line 341
    version___0 = 0;
  } else
#line 342
  if (h->qh_fmt == 2) {
#line 343
    version___0 = 1;
  } else {
#line 345
    return (-1);
  }
  {
#line 348
  ddqheader.dqh_magic = (__u32 )file_magics[h->qh_type];
#line 349
  ddqheader.dqh_version = (__u32 )version___0;
#line 350
  lseek(h->qh_fd, (__off64_t )0, 0);
#line 351
  tmp = write(h->qh_fd, (void const   *)(& ddqheader), sizeof(ddqheader));
  }
#line 351
  if ((unsigned long )tmp != sizeof(ddqheader)) {
#line 352
    return (-1);
  }
#line 354
  h->qh_info.dqi_bgrace = (time_t )604800;
#line 355
  h->qh_info.dqi_igrace = (time_t )604800;
#line 356
  h->qh_info.u.v2_mdqi.dqi_flags = (uint )0;
#line 357
  h->qh_info.u.v2_mdqi.dqi_qtree.dqi_blocks = 2U;
#line 358
  h->qh_info.u.v2_mdqi.dqi_qtree.dqi_free_blk = 0U;
#line 359
  h->qh_info.u.v2_mdqi.dqi_qtree.dqi_free_entry = 0U;
#line 360
  if (version___0 == 0) {
#line 361
    h->qh_info.u.v2_mdqi.dqi_qtree.dqi_entry_size = (unsigned int )sizeof(struct v2r0_disk_dqblk );
#line 362
    h->qh_info.u.v2_mdqi.dqi_qtree.dqi_ops = & v2r0_fmt_ops___8;
#line 363
    h->qh_info.dqi_max_b_limit = (uint64_t )(~ ((uint32_t )0));
#line 364
    h->qh_info.dqi_max_i_limit = (uint64_t )(~ ((uint32_t )0));
#line 365
    h->qh_info.dqi_max_b_usage = ~ ((uint64_t )0);
#line 366
    h->qh_info.dqi_max_i_usage = (uint64_t )(~ ((uint32_t )0));
  } else
#line 367
  if (version___0 == 1) {
#line 368
    h->qh_info.u.v2_mdqi.dqi_qtree.dqi_entry_size = (unsigned int )sizeof(struct v2r1_disk_dqblk );
#line 369
    h->qh_info.u.v2_mdqi.dqi_qtree.dqi_ops = & v2r1_fmt_ops___8;
#line 370
    h->qh_info.dqi_max_b_limit = ~ ((uint64_t )0);
#line 371
    h->qh_info.dqi_max_i_limit = ~ ((uint64_t )0);
#line 372
    h->qh_info.dqi_max_b_usage = ~ ((uint64_t )0);
#line 373
    h->qh_info.dqi_max_i_usage = ~ ((uint64_t )0);
  }
  {
#line 375
  v2_mem2diskdqinfo(& ddqinfo, & h->qh_info);
#line 376
  lseek(h->qh_fd, (__off64_t )sizeof(struct v2_disk_dqheader ), 0);
#line 377
  tmp___0 = write(h->qh_fd, (void const   *)(& ddqinfo), sizeof(ddqinfo));
  }
#line 377
  if ((unsigned long )tmp___0 != sizeof(ddqinfo)) {
#line 378
    return (-1);
  }
#line 379
  return (0);
}
}
#line 385 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v2.c"
static int v2_write_info___8(struct quota_handle *h ) 
{ 
  char *tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  struct v2_kern_dqinfo kdqinfo ;
  long tmp___2 ;
  long tmp___3 ;
  struct v2_disk_dqinfo ddqinfo ;
  ssize_t tmp___4 ;

  {
#line 387
  if (h->qh_io_flags & 4) {
    {
#line 388
    tmp = gettext("Trying to write info to readonly quotafile on %s\n");
#line 388
    errstr(tmp, h->qh_quotadev);
#line 389
    tmp___0 = __errno_location();
#line 389
    *tmp___0 = 1;
    }
#line 390
    return (-1);
  }
#line 392
  if (h->qh_io_flags & 1) {
#line 393
    if (kernel_iface == 3) {
      {
#line 394
      tmp___1 = vfs_set_info(h, 3);
      }
#line 394
      if (tmp___1) {
#line 395
        return (-1);
      }
    } else {
      {
#line 400
      kdqinfo.dqi_bgrace = (unsigned int )h->qh_info.dqi_bgrace;
#line 401
      kdqinfo.dqi_igrace = (unsigned int )h->qh_info.dqi_igrace;
#line 402
      kdqinfo.dqi_flags = h->qh_info.u.v2_mdqi.dqi_flags;
#line 403
      kdqinfo.dqi_blocks = h->qh_info.u.v2_mdqi.dqi_qtree.dqi_blocks;
#line 404
      kdqinfo.dqi_free_blk = h->qh_info.u.v2_mdqi.dqi_qtree.dqi_free_blk;
#line 405
      kdqinfo.dqi_free_entry = h->qh_info.u.v2_mdqi.dqi_qtree.dqi_free_entry;
#line 406
      tmp___2 = quotactl((2816 << 8) | (h->qh_type & 255), (char const   *)(h->qh_quotadev),
                         (qid_t )0, (caddr_t )((void *)(& kdqinfo)));
      }
#line 406
      if (tmp___2 < 0L) {
#line 408
        return (-1);
      } else {
        {
#line 406
        tmp___3 = quotactl((3072 << 8) | (h->qh_type & 255), (char const   *)(h->qh_quotadev),
                           (qid_t )0, (caddr_t )((void *)(& kdqinfo)));
        }
#line 406
        if (tmp___3 < 0L) {
#line 408
          return (-1);
        }
      }
    }
  } else {
    {
#line 414
    v2_mem2diskdqinfo(& ddqinfo, & h->qh_info);
#line 415
    lseek(h->qh_fd, (__off64_t )sizeof(struct v2_disk_dqheader ), 0);
#line 416
    tmp___4 = write(h->qh_fd, (void const   *)(& ddqinfo), sizeof(ddqinfo));
    }
#line 416
    if ((unsigned long )tmp___4 != sizeof(ddqinfo)) {
#line 417
      return (-1);
    }
  }
#line 419
  return (0);
}
}
#line 426 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v2.c"
static struct dquot *v2_read_dquot___8(struct quota_handle *h , qid_t id___0 ) 
{ 
  struct dquot *dquot ;
  struct dquot *tmp ;
  int tmp___0 ;
  struct v2_kern_dqblk kdqblk ;
  long tmp___1 ;
  struct dquot *tmp___2 ;

  {
#line 428
  if (h->qh_io_flags & 1) {
    {
#line 429
    tmp = get_empty_dquot();
#line 429
    dquot = tmp;
#line 431
    dquot->dq_id = id___0;
#line 432
    dquot->dq_h = h;
#line 433
    dquot->dq_dqb.u.v2_mdqb.dqb_off = (loff_t )0;
#line 434
    memset((void *)(& dquot->dq_dqb), 0, sizeof(struct util_dqblk ));
    }
#line 435
    if (kernel_iface == 3) {
      {
#line 436
      tmp___0 = vfs_get_dquot(dquot);
      }
#line 436
      if (tmp___0 < 0) {
        {
#line 437
        free((void *)dquot);
        }
#line 438
        return ((struct dquot *)((void *)0));
      }
    } else {
      {
#line 444
      tmp___1 = quotactl((3328 << 8) | (h->qh_type & 255), (char const   *)(h->qh_quotadev),
                         id___0, (caddr_t )((void *)(& kdqblk)));
      }
#line 444
      if (tmp___1 < 0L) {
        {
#line 445
        free((void *)dquot);
        }
#line 446
        return ((struct dquot *)((void *)0));
      }
      {
#line 448
      v2_kern2utildqblk(& dquot->dq_dqb, & kdqblk);
      }
    }
#line 450
    return (dquot);
  }
  {
#line 452
  tmp___2 = qtree_read_dquot(h, id___0);
  }
#line 452
  return (tmp___2);
}
}
#line 459 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v2.c"
static int v2_commit_dquot___8(struct dquot *dquot , int flags___7 ) 
{ 
  struct util_dqblk *b ;
  char *tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  struct v2_kern_dqblk kdqblk ;
  int cmd ;
  int *tmp___2 ;
  long tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;

  {
#line 461
  b = & dquot->dq_dqb;
#line 463
  if ((dquot->dq_h)->qh_io_flags & 4) {
    {
#line 464
    tmp = gettext("Trying to write quota to readonly quotafile on %s\n");
#line 464
    errstr(tmp, (dquot->dq_h)->qh_quotadev);
#line 465
    tmp___0 = __errno_location();
#line 465
    *tmp___0 = 1;
    }
#line 466
    return (-1);
  }
#line 468
  if ((dquot->dq_h)->qh_io_flags & 1) {
#line 469
    if (kernel_iface == 3) {
      {
#line 470
      tmp___1 = vfs_set_dquot(dquot, flags___7);
      }
#line 470
      if (tmp___1 < 0) {
#line 471
        return (-1);
      }
    } else {
#line 477
      if (flags___7 == 10) {
#line 478
        cmd = 3840;
      } else
#line 479
      if (flags___7 == 5) {
#line 480
        cmd = 1792;
      } else
#line 481
      if (flags___7 & 48) {
        {
#line 482
        tmp___2 = __errno_location();
#line 482
        *tmp___2 = 22;
        }
#line 483
        return (-1);
      } else {
#line 486
        cmd = 3584;
      }
      {
#line 487
      v2_util2kerndqblk(& kdqblk, & dquot->dq_dqb);
#line 488
      tmp___3 = quotactl((cmd << 8) | ((dquot->dq_h)->qh_type & 255), (char const   *)((dquot->dq_h)->qh_quotadev),
                         dquot->dq_id, (caddr_t )((void *)(& kdqblk)));
      }
#line 488
      if (tmp___3 < 0L) {
#line 490
        return (-1);
      }
    }
#line 492
    return (0);
  }
#line 494
  if (! b->dqb_curspace) {
#line 494
    if (! b->dqb_curinodes) {
#line 494
      if (! b->dqb_bsoftlimit) {
#line 494
        if (! b->dqb_isoftlimit) {
#line 494
          if (! b->dqb_bhardlimit) {
#line 494
            if (! b->dqb_ihardlimit) {
              {
#line 496
              qtree_delete_dquot(dquot);
              }
            } else {
#line 494
              goto _L___3;
            }
          } else {
#line 494
            goto _L___3;
          }
        } else {
#line 494
          goto _L___3;
        }
      } else {
#line 494
        goto _L___3;
      }
    } else {
#line 494
      goto _L___3;
    }
  } else {
    _L___3: /* CIL Label */ 
    {
#line 498
    tmp___5 = check_dquot_range(dquot);
    }
#line 498
    if (tmp___5 < 0) {
      {
#line 499
      tmp___4 = __errno_location();
#line 499
      *tmp___4 = 34;
      }
#line 500
      return (-1);
    }
    {
#line 502
    qtree_write_dquot(dquot);
    }
  }
#line 504
  return (0);
}
}
#line 507 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v2.c"
static int v2_scan_dquots___8(struct quota_handle *h , int (*process_dquot)(struct dquot *dquot ,
                                                                            char *dqname ) ) 
{ 
  int tmp ;

  {
  {
#line 509
  tmp = qtree_scan_dquots(h, process_dquot);
  }
#line 509
  return (tmp);
}
}
#line 513 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v2.c"
static int v2_report___8(struct quota_handle *h , int verbose ) 
{ 
  struct v2_mem_dqinfo *info ;
  char *tmp ;

  {
#line 515
  if (verbose) {
    {
#line 516
    info = & h->qh_info.u.v2_mdqi;
#line 518
    tmp = gettext("Statistics:\nTotal blocks: %u\nData blocks: %u\nEntries: %u\nUsed average: %f\n");
#line 518
    printf((char const   */* __restrict  */)tmp, info->dqi_qtree.dqi_blocks, info->dqi_data_blocks,
           info->dqi_used_entries, (double )((float )info->dqi_used_entries / (float )info->dqi_data_blocks));
    }
  }
#line 522
  return (0);
}
}
#line 31 "/home/wheatley/newnew/temp/quota-4.01/bylabel.c"
static struct uuidCache_s *uuidCache___8  =    (struct uuidCache_s *)((void *)0);
#line 74 "/home/wheatley/newnew/temp/quota-4.01/bylabel.c"
static int get_label_uuid___8(char const   *device , char **label , char *uuid ) 
{ 
  int fd ;
  int rv ;
  size_t namesize ;
  struct ext2_super_block e2sb ;
  struct xfs_super_block xfsb ;
  struct reiserfs_super_block reisersb ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  __off64_t tmp___2 ;
  ssize_t tmp___3 ;
  int tmp___4 ;
  __off64_t tmp___5 ;
  ssize_t tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  __off64_t tmp___9 ;
  ssize_t tmp___10 ;

  {
  {
#line 79
  rv = 1;
#line 85
  fd = open(device, 0);
  }
#line 86
  if (fd < 0) {
#line 87
    return (rv);
  }
  {
#line 89
  tmp___9 = lseek(fd, (__off64_t )1024, 0);
  }
#line 89
  if (tmp___9 == 1024L) {
    {
#line 89
    tmp___10 = read(fd, (void *)((char *)(& e2sb)), sizeof(e2sb));
    }
#line 89
    if ((unsigned long )tmp___10 == sizeof(e2sb)) {
#line 89
      if ((uint )e2sb.s_magic[0] + ((uint )e2sb.s_magic[1] << 8) == 61267U) {
        {
#line 92
        memcpy((void */* __restrict  */)uuid, (void const   */* __restrict  */)(e2sb.s_uuid),
               sizeof(e2sb.s_uuid));
#line 93
        namesize = sizeof(e2sb.s_volume_name);
#line 94
        tmp = smalloc(namesize + 1UL);
#line 94
        *label = (char *)tmp;
#line 95
        sstrncpy(*label, (char const   *)((char *)(e2sb.s_volume_name)), namesize);
#line 96
        rv = 0;
        }
      } else {
#line 89
        goto _L___3;
      }
    } else {
#line 89
      goto _L___3;
    }
  } else {
    _L___3: /* CIL Label */ 
    {
#line 98
    tmp___5 = lseek(fd, (__off64_t )0, 0);
    }
#line 98
    if (tmp___5 == 0L) {
      {
#line 98
      tmp___6 = read(fd, (void *)((char *)(& xfsb)), sizeof(xfsb));
      }
#line 98
      if ((unsigned long )tmp___6 == sizeof(xfsb)) {
        {
#line 98
        tmp___7 = strncmp((char const   *)((char *)(& xfsb.s_magic)), "XFSB", (size_t )4);
        }
#line 98
        if (tmp___7 == 0) {
#line 98
          goto _L___0;
        } else {
          {
#line 98
          tmp___8 = strncmp((char const   *)((char *)(& xfsb.s_magic)), "BSFX", (size_t )4);
          }
#line 98
          if (tmp___8 == 0) {
            _L___0: /* CIL Label */ 
            {
#line 102
            memcpy((void */* __restrict  */)uuid, (void const   */* __restrict  */)(xfsb.s_uuid),
                   sizeof(xfsb.s_uuid));
#line 103
            namesize = sizeof(xfsb.s_fsname);
#line 104
            tmp___0 = smalloc(namesize + 1UL);
#line 104
            *label = (char *)tmp___0;
#line 105
            sstrncpy(*label, (char const   *)((char *)(xfsb.s_fsname)), namesize);
#line 106
            rv = 0;
            }
          } else {
#line 98
            goto _L___1;
          }
        }
      } else {
#line 98
        goto _L___1;
      }
    } else {
      _L___1: /* CIL Label */ 
      {
#line 108
      tmp___2 = lseek(fd, (__off64_t )65536, 0);
      }
#line 108
      if (tmp___2 == 65536L) {
        {
#line 108
        tmp___3 = read(fd, (void *)((char *)(& reisersb)), sizeof(reisersb));
        }
#line 108
        if ((unsigned long )tmp___3 == sizeof(reisersb)) {
          {
#line 108
          tmp___4 = strncmp((char const   *)((char *)(& reisersb.s_magic)), "ReIsEr2Fs",
                            (size_t )9);
          }
#line 108
          if (! tmp___4) {
            {
#line 111
            memcpy((void */* __restrict  */)uuid, (void const   */* __restrict  */)(reisersb.s_uuid),
                   sizeof(reisersb.s_uuid));
#line 112
            namesize = sizeof(reisersb.s_volume_name);
#line 113
            tmp___1 = smalloc(namesize + 1UL);
#line 113
            *label = (char *)tmp___1;
#line 114
            sstrncpy(*label, (char const   *)((char *)(reisersb.s_volume_name)), namesize);
#line 115
            rv = 0;
            }
          }
        }
      }
    }
  }
  {
#line 117
  close(fd);
  }
#line 118
  return (rv);
}
}
#line 121 "/home/wheatley/newnew/temp/quota-4.01/bylabel.c"
static void uuidcache_addentry___8(char *device , char *label , char *uuid ) 
{ 
  struct uuidCache_s *last ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 125
  if (! uuidCache___8) {
    {
#line 126
    tmp = smalloc(sizeof(*uuidCache___8));
#line 126
    uuidCache___8 = (struct uuidCache_s *)tmp;
#line 126
    last = uuidCache___8;
    }
  } else {
#line 129
    last = uuidCache___8;
    {
#line 129
    while (1) {
      while_continue: /* CIL Label */ ;
#line 129
      if (! last->next) {
#line 129
        goto while_break;
      }
#line 129
      last = last->next;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 130
    tmp___0 = smalloc(sizeof(*uuidCache___8));
#line 130
    last->next = (struct uuidCache_s *)tmp___0;
#line 131
    last = last->next;
    }
  }
  {
#line 133
  last->next = (struct uuidCache_s *)((void *)0);
#line 134
  last->device = device;
#line 135
  last->label = label;
#line 136
  memcpy((void */* __restrict  */)(last->uuid), (void const   */* __restrict  */)uuid,
         sizeof(last->uuid));
  }
#line 137
  return;
}
}
#line 144 "/home/wheatley/newnew/temp/quota-4.01/bylabel.c"
static char ptname___8[100]  ;
#line 139 "/home/wheatley/newnew/temp/quota-4.01/bylabel.c"
static void uuidcache_init___8(void) 
{ 
  char line___0[100] ;
  char *s ;
  int ma ;
  int mi ;
  int sz ;
  FILE *procpt ;
  char uuid[16] ;
  char *label ;
  char device[110] ;
  int firstPass ;
  int handleOnFirst ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  unsigned short const   **tmp___4 ;
  char *tmp___5 ;

  {
#line 151
  if (uuidCache___8) {
#line 152
    return;
  }
  {
#line 154
  procpt = fopen((char const   */* __restrict  */)"/proc/partitions", (char const   */* __restrict  */)"r");
  }
#line 155
  if (! procpt) {
#line 156
    return;
  }
#line 158
  firstPass = 1;
  {
#line 158
  while (1) {
    while_continue: /* CIL Label */ ;
#line 158
    if (! (firstPass >= 0)) {
#line 158
      goto while_break;
    }
    {
#line 159
    fseek(procpt, 0L, 0);
    }
    {
#line 161
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 161
      tmp___5 = fgets((char */* __restrict  */)(line___0), (int )sizeof(line___0),
                      (FILE */* __restrict  */)procpt);
      }
#line 161
      if (! tmp___5) {
#line 161
        goto while_break___0;
      }
      {
#line 162
      tmp = sscanf((char const   */* __restrict  */)(line___0), (char const   */* __restrict  */)" %d %d %d %[^\n ]",
                   & ma, & mi, & sz, ptname___8);
      }
#line 162
      if (tmp != 4) {
#line 163
        goto while_continue___0;
      }
#line 166
      if (sz == 1) {
#line 167
        goto while_continue___0;
      }
      {
#line 170
      tmp___0 = strncmp((char const   *)(ptname___8), "md", (size_t )2);
      }
#line 170
      if (tmp___0) {
#line 170
        tmp___1 = 0;
      } else {
#line 170
        tmp___1 = 1;
      }
#line 170
      handleOnFirst = tmp___1;
#line 171
      if (firstPass != handleOnFirst) {
#line 172
        goto while_continue___0;
      }
#line 178
      s = ptname___8;
      {
#line 178
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 178
        if (! *s) {
#line 178
          goto while_break___1;
        }
#line 178
        s ++;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 179
      tmp___4 = __ctype_b_loc();
      }
#line 179
      if ((int const   )*(*tmp___4 + (int )*(s + -1)) & 2048) {
        {
#line 189
        snprintf((char */* __restrict  */)(device), sizeof(device), (char const   */* __restrict  */)"%s/%s",
                 "/dev", ptname___8);
#line 190
        tmp___3 = get_label_uuid___8((char const   *)(device), & label, uuid);
        }
#line 190
        if (! tmp___3) {
          {
#line 191
          tmp___2 = sstrdup((char const   *)(device));
#line 191
          uuidcache_addentry___8(tmp___2, label, uuid);
          }
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 158
    firstPass --;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 196
  fclose(procpt);
  }
#line 197
  return;
}
}
#line 202 "/home/wheatley/newnew/temp/quota-4.01/bylabel.c"
static char *get_spec_by_x___8(int n , char const   *t ) 
{ 
  struct uuidCache_s *uc ;
  char *tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 206
  uuidcache_init___8();
#line 207
  uc = uuidCache___8;
  }
  {
#line 209
  while (1) {
    while_continue: /* CIL Label */ ;
#line 209
    if (! uc) {
#line 209
      goto while_break;
    }
    {
#line 211
    if (n == 1) {
#line 211
      goto case_1;
    }
#line 215
    if (n == 2) {
#line 215
      goto case_2;
    }
#line 210
    goto switch_break;
    case_1: /* CIL Label */ 
    {
#line 212
    tmp___0 = memcmp((void const   *)t, (void const   *)(uc->uuid), sizeof(uc->uuid));
    }
#line 212
    if (! tmp___0) {
      {
#line 213
      tmp = sstrdup((char const   *)uc->device);
      }
#line 213
      return (tmp);
    }
#line 214
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 216
    tmp___2 = strcmp(t, (char const   *)uc->label);
    }
#line 216
    if (! tmp___2) {
      {
#line 217
      tmp___1 = sstrdup((char const   *)uc->device);
      }
#line 217
      return (tmp___1);
    }
#line 218
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 220
    uc = uc->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 222
  return ((char *)((void *)0));
}
}
#line 225 "/home/wheatley/newnew/temp/quota-4.01/bylabel.c"
static u_char fromhex___8(char c ) 
{ 
  unsigned short const   **tmp ;
  unsigned short const   **tmp___0 ;

  {
  {
#line 227
  tmp___0 = __ctype_b_loc();
  }
#line 227
  if ((int const   )*(*tmp___0 + (int )c) & 2048) {
#line 228
    return ((u_char )((int )c - 48));
  } else {
    {
#line 229
    tmp = __ctype_b_loc();
    }
#line 229
    if ((int const   )*(*tmp + (int )c) & 512) {
#line 230
      return ((u_char )(((int )c - 97) + 10));
    } else {
#line 232
      return ((u_char )(((int )c - 65) + 10));
    }
  }
}
}
#line 235 "/home/wheatley/newnew/temp/quota-4.01/bylabel.c"
static char *get_spec_by_uuid___8(char const   *s ) 
{ 
  u_char uuid[16] ;
  int i ;
  size_t tmp ;
  unsigned short const   **tmp___0 ;
  unsigned short const   **tmp___1 ;
  u_char tmp___2 ;
  u_char tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;

  {
  {
#line 240
  tmp = strlen(s);
  }
#line 240
  if (tmp != 36UL) {
#line 241
    goto bad_uuid;
  } else
#line 240
  if ((int const   )*(s + 8) != 45) {
#line 241
    goto bad_uuid;
  } else
#line 240
  if ((int const   )*(s + 13) != 45) {
#line 241
    goto bad_uuid;
  } else
#line 240
  if ((int const   )*(s + 18) != 45) {
#line 241
    goto bad_uuid;
  } else
#line 240
  if ((int const   )*(s + 23) != 45) {
#line 241
    goto bad_uuid;
  }
#line 242
  i = 0;
  {
#line 242
  while (1) {
    while_continue: /* CIL Label */ ;
#line 242
    if (! (i < 16)) {
#line 242
      goto while_break;
    }
#line 243
    if ((int const   )*s == 45) {
#line 244
      s ++;
    }
    {
#line 245
    tmp___0 = __ctype_b_loc();
    }
#line 245
    if ((int const   )*(*tmp___0 + (int )*(s + 0)) & 4096) {
      {
#line 245
      tmp___1 = __ctype_b_loc();
      }
#line 245
      if (! ((int const   )*(*tmp___1 + (int )*(s + 1)) & 4096)) {
#line 246
        goto bad_uuid;
      }
    } else {
#line 246
      goto bad_uuid;
    }
    {
#line 247
    tmp___2 = fromhex___8((char )*(s + 0));
#line 247
    tmp___3 = fromhex___8((char )*(s + 1));
#line 247
    uuid[i] = (u_char )(((int )tmp___2 << 4) | (int )tmp___3);
#line 248
    s += 2;
#line 242
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 250
  tmp___4 = get_spec_by_x___8(1, (char const   *)((char *)(uuid)));
  }
#line 250
  return (tmp___4);
  bad_uuid: 
  {
#line 253
  tmp___5 = gettext("Found an invalid UUID: %s\n");
#line 253
  errstr(tmp___5, s);
  }
#line 254
  return ((char *)((void *)0));
}
}
#line 257 "/home/wheatley/newnew/temp/quota-4.01/bylabel.c"
static char *get_spec_by_volume_label___8(char const   *s ) 
{ 
  char *tmp ;

  {
  {
#line 259
  tmp = get_spec_by_x___8(2, s);
  }
#line 259
  return (tmp);
}
}
#line 105 "/home/wheatley/newnew/temp/quota-4.01/quotaio_generic.c"
static int scan_one_dquot___8(struct dquot *dquot , int (*get_dquot)(struct dquot * ) ) 
{ 
  int ret ;
  struct util_dqblk *dqb ;

  {
  {
#line 108
  dqb = & dquot->dq_dqb;
#line 110
  memset((void *)dqb, 0, sizeof(struct util_dqblk ));
#line 111
  ret = (*get_dquot)(dquot);
  }
#line 112
  if (ret < 0) {
#line 113
    return (ret);
  }
#line 114
  if (! dqb->dqb_bhardlimit) {
#line 114
    if (! dqb->dqb_bsoftlimit) {
#line 114
      if (! dqb->dqb_ihardlimit) {
#line 114
        if (! dqb->dqb_isoftlimit) {
#line 114
          if (! dqb->dqb_curinodes) {
#line 114
            if (! dqb->dqb_curspace) {
#line 115
              return (1);
            }
          }
        }
      }
    }
  }
#line 116
  return (0);
}
}
#line 214 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) unsigned long long ( __attribute__((__nonnull__(1),
__leaf__)) strtoull)(char const   * __restrict  __nptr , char ** __restrict  __endptr ,
                     int __base ) ;
#line 40 "/home/wheatley/newnew/temp/quota-4.01/setquota.c"
static int flags___5  ;
#line 40 "/home/wheatley/newnew/temp/quota-4.01/setquota.c"
static int fmt___5  =    -1;
#line 41 "/home/wheatley/newnew/temp/quota-4.01/setquota.c"
static char **mnt___0  ;
#line 43 "/home/wheatley/newnew/temp/quota-4.01/setquota.c"
static int mntcnt___1  ;
#line 44 "/home/wheatley/newnew/temp/quota-4.01/setquota.c"
static qid_t protoid  ;
#line 44 "/home/wheatley/newnew/temp/quota-4.01/setquota.c"
static qid_t id  ;
#line 45 "/home/wheatley/newnew/temp/quota-4.01/setquota.c"
static struct util_dqblk toset  ;
#line 48 "/home/wheatley/newnew/temp/quota-4.01/setquota.c"
static void usage___7(void) 
{ 
  char *ropt ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 53
  ropt = (char *)"";
#line 55
  tmp = gettext("Usage:\n  setquota [-u|-g] %1$s[-F quotaformat] <user|group>\n\t<block-softlimit> <block-hardlimit> <inode-softlimit> <inode-hardlimit> -a|<filesystem>...\n  setquota [-u|-g] %1$s[-F quotaformat] <-p protouser|protogroup> <user|group> -a|<filesystem>...\n  setquota [-u|-g] %1$s[-F quotaformat] -b [-c] -a|<filesystem>...\n  setquota [-u|-g] [-F quotaformat] -t <blockgrace> <inodegrace> -a|<filesystem>...\n  setquota [-u|-g] [-F quotaformat] <user|group> -T <blockgrace> <inodegrace> -a|<filesystem>...\n\n-u, --user                 set limits for user\n-g, --group                set limits for group\n-a, --all                  set limits for all filesystems\n    --always-resolve       always try to resolve name, even if is\n                           composed only of digits\n-F, --format=formatname    operate on specific quota format\n-p, --prototype=protoname  copy limits from user/group\n-b, --batch                read limits from standard input\n-c, --continue-batch       continue in input processing in case of an error\n");
#line 55
  errstr(tmp, ropt);
#line 75
  tmp___0 = gettext("-t, --edit-period          edit grace period\n-T, --edit-times           edit grace times for user/group\n-h, --help                 display this help text and exit\n-V, --version              display version information and exit\n\n");
#line 75
  fputs((char const   */* __restrict  */)tmp___0, (FILE */* __restrict  */)stderr);
#line 79
  tmp___1 = gettext("Bugs to: %s\n");
#line 79
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___1,
          "jack@suse.cz");
#line 80
  exit(1);
  }
}
}
#line 84 "/home/wheatley/newnew/temp/quota-4.01/setquota.c"
static qsize_t parse_unum(char *str , char *msg ) 
{ 
  char *errch ;
  qsize_t ret ;
  unsigned long long tmp ;
  char *tmp___0 ;

  {
  {
#line 87
  tmp = strtoull((char const   */* __restrict  */)str, (char **/* __restrict  */)(& errch),
                 0);
#line 87
  ret = (qsize_t )tmp;
  }
#line 89
  if (*errch) {
    {
#line 90
    tmp___0 = gettext("%s: %s\n");
#line 90
    errstr(tmp___0, msg, str);
#line 91
    usage___7();
    }
  }
#line 93
  return (ret);
}
}
#line 97 "/home/wheatley/newnew/temp/quota-4.01/setquota.c"
__inline static int flag2type(int flags___7 ) 
{ 


  {
#line 99
  if (flags___7 & 1) {
#line 100
    return (0);
  }
#line 101
  if (flags___7 & 2) {
#line 102
    return (1);
  }
#line 103
  return (-1);
}
}
#line 107 "/home/wheatley/newnew/temp/quota-4.01/setquota.c"
static void parse_options___6(int argcnt , char **argstr ) 
{ 
  int ret ;
  int otherargs ;
  char *protoname___0 ;
  char *opts ;
  struct option long_opts[13] ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  char *tmp___9 ;
  int tmp___10 ;
  char *tmp___11 ;
  int tmp___12 ;
  char *tmp___13 ;
  int tmp___14 ;
  char *tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  char *tmp___19 ;
  int tmp___20 ;
  char *tmp___21 ;
  int tmp___22 ;
  time_t now___0 ;
  char *tmp___23 ;
  int tmp___24 ;
  qsize_t tmp___25 ;
  char *tmp___26 ;
  int tmp___27 ;
  char *tmp___28 ;
  int tmp___29 ;
  qsize_t tmp___30 ;
  char *tmp___31 ;
  int tmp___32 ;
  char *tmp___33 ;

  {
#line 110
  protoname___0 = (char *)((void *)0);
#line 115
  opts = (char *)"ghp:uVF:taTbc";
#line 117
  long_opts[0].name = "user";
#line 117
  long_opts[0].has_arg = 0;
#line 117
  long_opts[0].flag = (int *)((void *)0);
#line 117
  long_opts[0].val = 'u';
#line 117
  long_opts[1].name = "group";
#line 117
  long_opts[1].has_arg = 0;
#line 117
  long_opts[1].flag = (int *)((void *)0);
#line 117
  long_opts[1].val = 'g';
#line 117
  long_opts[2].name = "prototype";
#line 117
  long_opts[2].has_arg = 1;
#line 117
  long_opts[2].flag = (int *)((void *)0);
#line 117
  long_opts[2].val = 'p';
#line 117
  long_opts[3].name = "all";
#line 117
  long_opts[3].has_arg = 0;
#line 117
  long_opts[3].flag = (int *)((void *)0);
#line 117
  long_opts[3].val = 'a';
#line 117
  long_opts[4].name = "always-resolve";
#line 117
  long_opts[4].has_arg = 0;
#line 117
  long_opts[4].flag = (int *)((void *)0);
#line 117
  long_opts[4].val = 256;
#line 117
  long_opts[5].name = "edit-period";
#line 117
  long_opts[5].has_arg = 0;
#line 117
  long_opts[5].flag = (int *)((void *)0);
#line 117
  long_opts[5].val = 't';
#line 117
  long_opts[6].name = "edit-times";
#line 117
  long_opts[6].has_arg = 0;
#line 117
  long_opts[6].flag = (int *)((void *)0);
#line 117
  long_opts[6].val = 'T';
#line 117
  long_opts[7].name = "batch";
#line 117
  long_opts[7].has_arg = 0;
#line 117
  long_opts[7].flag = (int *)((void *)0);
#line 117
  long_opts[7].val = 'b';
#line 117
  long_opts[8].name = "continue";
#line 117
  long_opts[8].has_arg = 0;
#line 117
  long_opts[8].flag = (int *)((void *)0);
#line 117
  long_opts[8].val = 'c';
#line 117
  long_opts[9].name = "format";
#line 117
  long_opts[9].has_arg = 1;
#line 117
  long_opts[9].flag = (int *)((void *)0);
#line 117
  long_opts[9].val = 'F';
#line 117
  long_opts[10].name = "version";
#line 117
  long_opts[10].has_arg = 0;
#line 117
  long_opts[10].flag = (int *)((void *)0);
#line 117
  long_opts[10].val = 'V';
#line 117
  long_opts[11].name = "help";
#line 117
  long_opts[11].has_arg = 0;
#line 117
  long_opts[11].flag = (int *)((void *)0);
#line 117
  long_opts[11].val = 'h';
#line 117
  long_opts[12].name = (char const   *)((void *)0);
#line 117
  long_opts[12].has_arg = 0;
#line 117
  long_opts[12].flag = (int *)((void *)0);
#line 117
  long_opts[12].val = 0;
  {
#line 137
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 137
    ret = getopt_long(argcnt, (char * const  *)argstr, (char const   *)opts, (struct option  const  *)(long_opts),
                      (int *)((void *)0));
    }
#line 137
    if (! (ret != -1)) {
#line 137
      goto while_break;
    }
    {
#line 140
    if (ret == 104) {
#line 140
      goto case_104;
    }
#line 140
    if (ret == 63) {
#line 140
      goto case_104;
    }
#line 142
    if (ret == 103) {
#line 142
      goto case_103;
    }
#line 145
    if (ret == 117) {
#line 145
      goto case_117;
    }
#line 148
    if (ret == 112) {
#line 148
      goto case_112;
    }
#line 152
    if (ret == 114) {
#line 152
      goto case_114;
    }
#line 155
    if (ret == 109) {
#line 155
      goto case_109;
    }
#line 158
    if (ret == 97) {
#line 158
      goto case_97;
    }
#line 161
    if (ret == 256) {
#line 161
      goto case_256;
    }
#line 164
    if (ret == 116) {
#line 164
      goto case_116;
    }
#line 167
    if (ret == 98) {
#line 167
      goto case_98;
    }
#line 170
    if (ret == 99) {
#line 170
      goto case_99;
    }
#line 173
    if (ret == 84) {
#line 173
      goto case_84;
    }
#line 176
    if (ret == 70) {
#line 176
      goto case_70;
    }
#line 180
    if (ret == 86) {
#line 180
      goto case_86;
    }
#line 138
    goto switch_break;
    case_104: /* CIL Label */ 
    case_63: /* CIL Label */ 
    {
#line 141
    usage___7();
    }
    case_103: /* CIL Label */ 
#line 143
    flags___5 |= 2;
#line 144
    goto switch_break;
    case_117: /* CIL Label */ 
#line 146
    flags___5 |= 1;
#line 147
    goto switch_break;
    case_112: /* CIL Label */ 
#line 149
    flags___5 |= 16;
#line 150
    protoname___0 = optarg;
#line 151
    goto switch_break;
    case_114: /* CIL Label */ 
#line 153
    flags___5 |= 4;
#line 154
    goto switch_break;
    case_109: /* CIL Label */ 
#line 156
    flags___5 |= 512;
#line 157
    goto switch_break;
    case_97: /* CIL Label */ 
#line 159
    flags___5 |= 8;
#line 160
    goto switch_break;
    case_256: /* CIL Label */ 
#line 162
    flags___5 |= 256;
#line 163
    goto switch_break;
    case_116: /* CIL Label */ 
#line 165
    flags___5 |= 32;
#line 166
    goto switch_break;
    case_98: /* CIL Label */ 
#line 168
    flags___5 |= 128;
#line 169
    goto switch_break;
    case_99: /* CIL Label */ 
#line 171
    flags___5 |= 1024;
#line 172
    goto switch_break;
    case_84: /* CIL Label */ 
#line 174
    flags___5 |= 64;
#line 175
    goto switch_break;
    case_70: /* CIL Label */ 
    {
#line 177
    fmt___5 = name2fmt(optarg);
    }
#line 177
    if (fmt___5 == -1) {
      {
#line 178
      exit(1);
      }
    }
#line 179
    goto switch_break;
    case_86: /* CIL Label */ 
    {
#line 181
    version();
#line 182
    exit(0);
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 185
  if (flags___5 & 1) {
#line 185
    if (flags___5 & 2) {
      {
#line 186
      tmp = gettext("Group and user quotas cannot be used together.\n");
#line 186
      errstr(tmp);
#line 187
      usage___7();
      }
    }
  }
#line 189
  if (flags___5 & 16) {
#line 189
    if (flags___5 & 32) {
      {
#line 190
      tmp___0 = gettext("Prototype user has no sense when editing grace times.\n");
#line 190
      errstr(tmp___0);
#line 191
      usage___7();
      }
    }
  }
#line 193
  if (flags___5 & 64) {
#line 193
    if (flags___5 & 32) {
      {
#line 194
      tmp___1 = gettext("Cannot set both individual and global grace time.\n");
#line 194
      errstr(tmp___1);
#line 195
      usage___7();
      }
    }
  }
#line 197
  if (flags___5 & 128) {
#line 197
    if (flags___5 & 96) {
      {
#line 198
      tmp___2 = gettext("Batch mode cannot be used for setting grace times.\n");
#line 198
      errstr(tmp___2);
#line 199
      usage___7();
      }
    }
  }
#line 201
  if (flags___5 & 128) {
#line 201
    if (flags___5 & 16) {
      {
#line 202
      tmp___3 = gettext("Batch mode and prototype user cannot be used together.\n");
#line 202
      errstr(tmp___3);
#line 203
      usage___7();
      }
    }
  }
#line 205
  if (flags___5 & 4) {
#line 205
    if (flags___5 & 96) {
      {
#line 206
      tmp___4 = gettext("Cannot set grace times over RPC protocol.\n");
#line 206
      errstr(tmp___4);
#line 207
      usage___7();
      }
    }
  }
#line 209
  if (flags___5 & 32) {
#line 210
    otherargs = 2;
  } else
#line 211
  if (flags___5 & 64) {
#line 212
    otherargs = 3;
  } else
#line 213
  if (flags___5 & 128) {
#line 214
    otherargs = 0;
  } else {
#line 216
    otherargs = 1;
#line 217
    if (! (flags___5 & 16)) {
#line 218
      otherargs += 4;
    }
  }
#line 220
  if (optind + otherargs > argcnt) {
    {
#line 221
    tmp___5 = gettext("Bad number of arguments.\n");
#line 221
    errstr(tmp___5);
#line 222
    usage___7();
    }
  }
#line 224
  if (! (flags___5 & 3)) {
#line 225
    flags___5 |= 1;
  }
#line 226
  if (! (flags___5 & 160)) {
    {
#line 227
    tmp___6 = flag2type(flags___5);
#line 227
    tmp___7 = optind;
#line 227
    optind ++;
#line 227
    tmp___8 = name2id(*(argstr + tmp___7), tmp___6, ! (! (flags___5 & 256)), (int *)((void *)0));
#line 227
    id = (qid_t )tmp___8;
    }
#line 228
    if (! (flags___5 & 112)) {
      {
#line 229
      tmp___9 = gettext("Bad block softlimit");
#line 229
      tmp___10 = optind;
#line 229
      optind ++;
#line 229
      toset.dqb_bsoftlimit = parse_unum(*(argstr + tmp___10), tmp___9);
#line 230
      tmp___11 = gettext("Bad block hardlimit");
#line 230
      tmp___12 = optind;
#line 230
      optind ++;
#line 230
      toset.dqb_bhardlimit = parse_unum(*(argstr + tmp___12), tmp___11);
#line 231
      tmp___13 = gettext("Bad inode softlimit");
#line 231
      tmp___14 = optind;
#line 231
      optind ++;
#line 231
      toset.dqb_isoftlimit = parse_unum(*(argstr + tmp___14), tmp___13);
#line 232
      tmp___15 = gettext("Bad inode hardlimit");
#line 232
      tmp___16 = optind;
#line 232
      optind ++;
#line 232
      toset.dqb_ihardlimit = parse_unum(*(argstr + tmp___16), tmp___15);
      }
    } else
#line 234
    if (flags___5 & 16) {
      {
#line 235
      tmp___17 = flag2type(flags___5);
#line 235
      tmp___18 = name2id(protoname___0, tmp___17, ! (! (flags___5 & 256)), (int *)((void *)0));
#line 235
      protoid = (qid_t )tmp___18;
      }
    }
  }
#line 237
  if (flags___5 & 32) {
    {
#line 238
    tmp___19 = gettext("Bad block grace time");
#line 238
    tmp___20 = optind;
#line 238
    optind ++;
#line 238
    toset.dqb_btime = parse_unum(*(argstr + tmp___20), tmp___19);
#line 239
    tmp___21 = gettext("Bad inode grace time");
#line 239
    tmp___22 = optind;
#line 239
    optind ++;
#line 239
    toset.dqb_itime = parse_unum(*(argstr + tmp___22), tmp___21);
    }
  } else
#line 241
  if (flags___5 & 64) {
    {
#line 244
    time(& now___0);
#line 245
    tmp___26 = gettext("unset");
#line 245
    tmp___27 = strcmp((char const   *)*(argstr + optind), (char const   *)tmp___26);
    }
#line 245
    if (tmp___27) {
      {
#line 250
      tmp___23 = gettext("Bad block grace time");
#line 250
      tmp___24 = optind;
#line 250
      optind ++;
#line 250
      tmp___25 = parse_unum(*(argstr + tmp___24), tmp___23);
#line 250
      toset.dqb_btime = now___0 + tmp___25;
      }
    } else {
#line 246
      toset.dqb_btime = (time_t )0;
#line 247
      optind ++;
    }
    {
#line 251
    tmp___31 = gettext("unset");
#line 251
    tmp___32 = strcmp((char const   *)*(argstr + optind), (char const   *)tmp___31);
    }
#line 251
    if (tmp___32) {
      {
#line 256
      tmp___28 = gettext("Bad inode grace time");
#line 256
      tmp___29 = optind;
#line 256
      optind ++;
#line 256
      tmp___30 = parse_unum(*(argstr + tmp___29), tmp___28);
#line 256
      toset.dqb_itime = now___0 + tmp___30;
      }
    } else {
#line 252
      toset.dqb_itime = (time_t )0;
#line 253
      optind ++;
    }
  }
#line 258
  if (! (flags___5 & 8)) {
#line 259
    mntcnt___1 = argcnt - optind;
#line 260
    mnt___0 = argstr + optind;
#line 261
    if (! mntcnt___1) {
      {
#line 262
      tmp___33 = gettext("Mountpoint not specified.\n");
#line 262
      errstr(tmp___33);
#line 263
      usage___7();
      }
    }
  }
#line 266
  return;
}
}
#line 269 "/home/wheatley/newnew/temp/quota-4.01/setquota.c"
static int setlimits(struct quota_handle **handles ) 
{ 
  struct dquot *q ;
  struct dquot *protoq ;
  struct dquot *protoprivs ;
  struct dquot *curprivs ;
  int ret ;
  int tmp ;

  {
  {
#line 271
  protoprivs = (struct dquot *)((void *)0);
#line 272
  ret = 0;
#line 274
  curprivs = getprivs(id, handles, 0);
  }
#line 275
  if (flags___5 & 16) {
    {
#line 276
    protoprivs = getprivs(protoid, handles, 0);
#line 277
    q = curprivs;
#line 277
    protoq = protoprivs;
    }
    {
#line 277
    while (1) {
      while_continue: /* CIL Label */ ;
#line 277
      if (q) {
#line 277
        if (! protoq) {
#line 277
          goto while_break;
        }
      } else {
#line 277
        goto while_break;
      }
      {
#line 278
      q->dq_dqb.dqb_bsoftlimit = protoq->dq_dqb.dqb_bsoftlimit;
#line 279
      q->dq_dqb.dqb_bhardlimit = protoq->dq_dqb.dqb_bhardlimit;
#line 280
      q->dq_dqb.dqb_isoftlimit = protoq->dq_dqb.dqb_isoftlimit;
#line 281
      q->dq_dqb.dqb_ihardlimit = protoq->dq_dqb.dqb_ihardlimit;
#line 282
      update_grace_times(q);
#line 277
      q = q->dq_next;
#line 277
      protoq = protoq->dq_next;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 284
    freeprivs(protoprivs);
    }
  } else {
#line 287
    q = curprivs;
    {
#line 287
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 287
      if (! q) {
#line 287
        goto while_break___0;
      }
      {
#line 288
      q->dq_dqb.dqb_bsoftlimit = toset.dqb_bsoftlimit;
#line 289
      q->dq_dqb.dqb_bhardlimit = toset.dqb_bhardlimit;
#line 290
      q->dq_dqb.dqb_isoftlimit = toset.dqb_isoftlimit;
#line 291
      q->dq_dqb.dqb_ihardlimit = toset.dqb_ihardlimit;
#line 292
      update_grace_times(q);
#line 287
      q = q->dq_next;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  {
#line 295
  tmp = putprivs(curprivs, 5);
  }
#line 295
  if (tmp == -1) {
#line 296
    ret = -1;
  }
  {
#line 297
  freeprivs(curprivs);
  }
#line 298
  return (ret);
}
}
#line 306
static int read_entry(qid_t *id___0 , qsize_t *isoftlimit , qsize_t *ihardlimit ,
                      qsize_t *bsoftlimit , qsize_t *bhardlimit ) ;
#line 306 "/home/wheatley/newnew/temp/quota-4.01/setquota.c"
static int line  =    0;
#line 304 "/home/wheatley/newnew/temp/quota-4.01/setquota.c"
static int read_entry(qid_t *id___0 , qsize_t *isoftlimit , qsize_t *ihardlimit ,
                      qsize_t *bsoftlimit , qsize_t *bhardlimit ) 
{ 
  char name[65] ;
  char linebuf[65536] ;
  char *chptr ;
  unsigned long is ;
  unsigned long ih ;
  unsigned long bs ;
  unsigned long bh ;
  int ret ;
  char *tmp ;
  char *tmp___0 ;
  size_t tmp___1 ;
  unsigned short const   **tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;

  {
  {
#line 312
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 313
    line ++;
#line 314
    tmp = fgets((char */* __restrict  */)(linebuf), (int )sizeof(linebuf), (FILE */* __restrict  */)stdin);
    }
#line 314
    if (! tmp) {
#line 315
      return (-1);
    }
    {
#line 316
    tmp___1 = strlen((char const   *)(linebuf));
    }
#line 316
    if ((int )linebuf[tmp___1 - 1UL] != 10) {
      {
#line 317
      tmp___0 = gettext("Line %d too long.\n");
#line 317
      die(1, tmp___0, line);
      }
    }
#line 319
    if ((int )linebuf[0] == 35) {
#line 320
      goto while_continue;
    }
#line 322
    chptr = linebuf;
    {
#line 323
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 323
      tmp___2 = __ctype_b_loc();
      }
#line 323
      if (! ((int const   )*(*tmp___2 + (int )*chptr) & 1)) {
#line 323
        goto while_break___0;
      }
#line 324
      chptr ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 325
    if ((int )*chptr == 10) {
#line 326
      goto while_continue;
    }
    {
#line 327
    ret = sscanf((char const   */* __restrict  */)chptr, (char const   */* __restrict  */)"%s %lu %lu %lu %lu",
                 name, & bs, & bh, & is, & ih);
    }
#line 328
    if (ret != 5) {
      {
#line 329
      tmp___3 = gettext("Cannot parse input line %d.\n");
#line 329
      errstr(tmp___3, line);
      }
#line 330
      if (! (flags___5 & 1024)) {
        {
#line 331
        tmp___4 = gettext("Exitting.\n");
#line 331
        die(1, tmp___4);
        }
      }
      {
#line 332
      tmp___5 = gettext("Skipping line.\n");
#line 332
      errstr(tmp___5);
      }
#line 333
      goto while_continue;
    }
    {
#line 335
    tmp___6 = flag2type(flags___5);
#line 335
    tmp___7 = name2id(name, tmp___6, ! (! (flags___5 & 256)), & ret);
#line 335
    *id___0 = (qid_t )tmp___7;
    }
#line 336
    if (ret) {
      {
#line 337
      tmp___8 = gettext("Unable to resolve name \'%s\' on line %d.\n");
#line 337
      errstr(tmp___8, name, line);
      }
#line 338
      if (! (flags___5 & 1024)) {
        {
#line 339
        tmp___9 = gettext("Exitting.\n");
#line 339
        die(1, tmp___9);
        }
      }
      {
#line 340
      tmp___10 = gettext("Skipping line.\n");
#line 340
      errstr(tmp___10);
      }
#line 341
      goto while_continue;
    }
#line 343
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 345
  *isoftlimit = (qsize_t )is;
#line 346
  *ihardlimit = (qsize_t )ih;
#line 347
  *bsoftlimit = (qsize_t )bs;
#line 348
  *bhardlimit = (qsize_t )bh;
#line 349
  return (0);
}
}
#line 353 "/home/wheatley/newnew/temp/quota-4.01/setquota.c"
static int batch_setlimits(struct quota_handle **handles ) 
{ 
  struct dquot *curprivs ;
  struct dquot *q ;
  qsize_t bhardlimit ;
  qsize_t bsoftlimit ;
  qsize_t ihardlimit ;
  qsize_t isoftlimit ;
  qid_t id___0 ;
  int ret ;
  int tmp ;
  int tmp___0 ;

  {
#line 358
  ret = 0;
  {
#line 360
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 360
    tmp___0 = read_entry(& id___0, & isoftlimit, & ihardlimit, & bsoftlimit, & bhardlimit);
    }
#line 360
    if (tmp___0) {
#line 360
      goto while_break;
    }
    {
#line 361
    curprivs = getprivs(id___0, handles, 0);
#line 362
    q = curprivs;
    }
    {
#line 362
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 362
      if (! q) {
#line 362
        goto while_break___0;
      }
      {
#line 363
      q->dq_dqb.dqb_bsoftlimit = bsoftlimit;
#line 364
      q->dq_dqb.dqb_bhardlimit = bhardlimit;
#line 365
      q->dq_dqb.dqb_isoftlimit = isoftlimit;
#line 366
      q->dq_dqb.dqb_ihardlimit = ihardlimit;
#line 367
      update_grace_times(q);
#line 362
      q = q->dq_next;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 369
    tmp = putprivs(curprivs, 5);
    }
#line 369
    if (tmp == -1) {
#line 370
      ret = -1;
    }
    {
#line 371
    freeprivs(curprivs);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 373
  return (ret);
}
}
#line 377 "/home/wheatley/newnew/temp/quota-4.01/setquota.c"
static int setgraces(struct quota_handle **handles ) 
{ 
  int i ;
  int ret ;
  char *tmp ;

  {
#line 379
  ret = 0;
#line 381
  i = 0;
  {
#line 381
  while (1) {
    while_continue: /* CIL Label */ ;
#line 381
    if (! *(handles + i)) {
#line 381
      goto while_break;
    }
#line 382
    if (! ((*(handles + i))->qh_ops)->write_info) {
      {
#line 383
      tmp = gettext("Setting grace period on %s is not supported.\n");
#line 383
      errstr(tmp, (*(handles + i))->qh_quotadev);
#line 384
      ret = -1;
      }
#line 385
      goto __Cont;
    }
    {
#line 387
    (*(handles + i))->qh_info.dqi_bgrace = toset.dqb_btime;
#line 388
    (*(handles + i))->qh_info.dqi_igrace = toset.dqb_itime;
#line 389
    mark_quotafile_info_dirty(*(handles + i));
    }
    __Cont: /* CIL Label */ 
#line 381
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 391
  return (ret);
}
}
#line 395 "/home/wheatley/newnew/temp/quota-4.01/setquota.c"
static int setindivgraces(struct quota_handle **handles ) 
{ 
  int ret ;
  struct dquot *q ;
  struct dquot *curprivs ;
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;

  {
  {
#line 397
  ret = 0;
#line 400
  curprivs = getprivs(id, handles, 0);
#line 401
  q = curprivs;
  }
  {
#line 401
  while (1) {
    while_continue: /* CIL Label */ ;
#line 401
    if (! q) {
#line 401
      goto while_break;
    }
#line 402
    if (q->dq_dqb.dqb_bsoftlimit) {
#line 402
      if (((q->dq_dqb.dqb_curspace + (qsize_t )(1 << 10)) - 1L) >> 10 > q->dq_dqb.dqb_bsoftlimit) {
#line 403
        q->dq_dqb.dqb_btime = toset.dqb_btime;
      } else {
        {
#line 405
        tmp = gettext("Not setting block grace time on %s because softlimit is not exceeded.\n");
#line 405
        errstr(tmp, (q->dq_h)->qh_quotadev);
        }
      }
    } else {
      {
#line 405
      tmp = gettext("Not setting block grace time on %s because softlimit is not exceeded.\n");
#line 405
      errstr(tmp, (q->dq_h)->qh_quotadev);
      }
    }
#line 406
    if (q->dq_dqb.dqb_isoftlimit) {
#line 406
      if (q->dq_dqb.dqb_curinodes > q->dq_dqb.dqb_isoftlimit) {
#line 407
        q->dq_dqb.dqb_itime = toset.dqb_itime;
      } else {
        {
#line 409
        tmp___0 = gettext("Not setting inode grace time on %s because softlimit is not exceeded.\n");
#line 409
        errstr(tmp___0, (q->dq_h)->qh_quotadev);
        }
      }
    } else {
      {
#line 409
      tmp___0 = gettext("Not setting inode grace time on %s because softlimit is not exceeded.\n");
#line 409
      errstr(tmp___0, (q->dq_h)->qh_quotadev);
      }
    }
#line 401
    q = q->dq_next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 411
  tmp___5 = putprivs(curprivs, 48);
  }
#line 411
  if (tmp___5 == -1) {
#line 412
    if (flags___5 & 1) {
#line 412
      tmp___1 = 0;
    } else {
#line 412
      tmp___1 = 1;
    }
    {
#line 412
    tmp___2 = type2name(tmp___1);
#line 412
    tmp___3 = gettext((char const   *)tmp___2);
#line 412
    tmp___4 = gettext("cannot write times for %s. Maybe kernel does not support such operation?\n");
#line 412
    errstr(tmp___4, tmp___3);
#line 413
    ret = -1;
    }
  }
  {
#line 415
  freeprivs(curprivs);
  }
#line 416
  return (ret);
}
}
#line 50 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v1.c"
static int v1_check_file___8(int fd , int type , int fmt___7 ) ;
#line 51
static int v1_init_io___8(struct quota_handle *h ) ;
#line 52
static int v1_new_io___8(struct quota_handle *h ) ;
#line 53
static int v1_write_info___8(struct quota_handle *h ) ;
#line 54
static struct dquot *v1_read_dquot___8(struct quota_handle *h , qid_t id___0 ) ;
#line 55
static int v1_commit_dquot___8(struct dquot *dquot , int flags___7 ) ;
#line 56
static int v1_scan_dquots___8(struct quota_handle *h , int (*process_dquot)(struct dquot *dquot ,
                                                                            char *dqname ) ) ;
#line 127 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v1.c"
static int v1_check_file___8(int fd , int type , int fmt___7 ) 
{ 
  struct stat st ;
  int tmp ;

  {
  {
#line 131
  tmp = fstat(fd, & st);
  }
#line 131
  if (tmp < 0) {
#line 132
    return (0);
  }
#line 133
  if (! st.st_size) {
#line 134
    return (0);
  } else
#line 133
  if ((unsigned long )st.st_size % sizeof(struct v1_disk_dqblk )) {
#line 134
    return (0);
  }
#line 135
  return (1);
}
}
#line 141 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v1.c"
static int v1_init_io___8(struct quota_handle *h ) 
{ 
  int tmp ;
  struct v1_kern_dqblk kdqblk ;
  time_t tmp___0 ;
  int *tmp___1 ;
  long tmp___2 ;
  struct v1_disk_dqblk ddqblk ;
  ssize_t tmp___3 ;

  {
#line 143
  if (h->qh_io_flags & 1) {
#line 144
    if (kernel_iface == 3) {
      {
#line 145
      tmp = vfs_get_info(h);
      }
#line 145
      if (tmp < 0) {
#line 146
        return (-1);
      }
    } else {
      {
#line 151
      tmp___2 = quotactl((768 << 8) | (h->qh_type & 255), (char const   *)(h->qh_quotadev),
                         (qid_t )0, (caddr_t )((void *)(& kdqblk)));
      }
#line 151
      if (tmp___2 < 0L) {
        {
#line 152
        tmp___1 = __errno_location();
        }
#line 152
        if (*tmp___1 == 1) {
#line 153
          tmp___0 = (time_t )0;
#line 153
          h->qh_info.dqi_igrace = tmp___0;
#line 153
          h->qh_info.dqi_bgrace = tmp___0;
        } else {
#line 156
          return (-1);
        }
      } else {
#line 159
        h->qh_info.dqi_bgrace = kdqblk.dqb_btime;
#line 160
        h->qh_info.dqi_igrace = kdqblk.dqb_itime;
      }
    }
  } else {
    {
#line 167
    lseek(h->qh_fd, (__off64_t )0, 0);
#line 168
    tmp___3 = read(h->qh_fd, (void *)(& ddqblk), sizeof(ddqblk));
    }
#line 168
    if ((unsigned long )tmp___3 != sizeof(ddqblk)) {
#line 169
      return (-1);
    }
#line 170
    h->qh_info.dqi_bgrace = ddqblk.dqb_btime;
#line 171
    h->qh_info.dqi_igrace = ddqblk.dqb_itime;
  }
#line 173
  if (! h->qh_info.dqi_bgrace) {
#line 174
    h->qh_info.dqi_bgrace = (time_t )604800;
  }
#line 175
  if (! h->qh_info.dqi_igrace) {
#line 176
    h->qh_info.dqi_igrace = (time_t )604800;
  }
#line 177
  h->qh_info.dqi_max_b_limit = (uint64_t )(~ ((uint32_t )0));
#line 178
  h->qh_info.dqi_max_i_limit = (uint64_t )(~ ((uint32_t )0));
#line 179
  h->qh_info.dqi_max_b_usage = 4294967295UL << 10;
#line 180
  h->qh_info.dqi_max_i_usage = (uint64_t )(~ ((uint32_t )0));
#line 182
  return (0);
}
}
#line 188 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v1.c"
static int v1_new_io___8(struct quota_handle *h ) 
{ 
  struct v1_disk_dqblk ddqblk ;
  ssize_t tmp ;

  {
  {
#line 193
  memset((void *)(& ddqblk), 0, sizeof(ddqblk));
#line 194
  ddqblk.dqb_btime = (time_t )604800;
#line 195
  ddqblk.dqb_itime = (time_t )604800;
#line 196
  h->qh_info.dqi_bgrace = (time_t )604800;
#line 197
  h->qh_info.dqi_igrace = (time_t )604800;
#line 198
  h->qh_info.dqi_max_b_limit = (uint64_t )(~ ((uint32_t )0));
#line 199
  h->qh_info.dqi_max_i_limit = (uint64_t )(~ ((uint32_t )0));
#line 200
  h->qh_info.dqi_max_b_usage = 4294967295UL << 10;
#line 201
  h->qh_info.dqi_max_i_usage = (uint64_t )(~ ((uint32_t )0));
#line 202
  lseek(h->qh_fd, (__off64_t )0, 0);
#line 203
  tmp = write(h->qh_fd, (void const   *)(& ddqblk), sizeof(ddqblk));
  }
#line 203
  if ((unsigned long )tmp != sizeof(ddqblk)) {
#line 204
    return (-1);
  }
#line 205
  return (0);
}
}
#line 211 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v1.c"
static int v1_write_info___8(struct quota_handle *h ) 
{ 
  char *tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  struct v1_kern_dqblk kdqblk ;
  long tmp___2 ;
  long tmp___3 ;
  struct v1_disk_dqblk ddqblk ;
  ssize_t tmp___4 ;
  ssize_t tmp___5 ;

  {
#line 213
  if (h->qh_io_flags & 4) {
    {
#line 214
    tmp = gettext("Trying to write info to readonly quotafile on %s.\n");
#line 214
    errstr(tmp, h->qh_quotadev);
#line 215
    tmp___0 = __errno_location();
#line 215
    *tmp___0 = 1;
    }
#line 216
    return (-1);
  }
#line 218
  if (h->qh_io_flags & 1) {
#line 219
    if (kernel_iface == 3) {
      {
#line 220
      tmp___1 = vfs_set_info(h, 3);
      }
#line 220
      if (tmp___1 < 0) {
#line 221
        return (-1);
      }
    } else {
      {
#line 226
      tmp___2 = quotactl((768 << 8) | (h->qh_type & 255), (char const   *)(h->qh_quotadev),
                         (qid_t )0, (caddr_t )((void *)(& kdqblk)));
      }
#line 226
      if (tmp___2 < 0L) {
#line 227
        return (-1);
      }
      {
#line 228
      kdqblk.dqb_btime = h->qh_info.dqi_bgrace;
#line 229
      kdqblk.dqb_itime = h->qh_info.dqi_igrace;
#line 230
      tmp___3 = quotactl((1024 << 8) | (h->qh_type & 255), (char const   *)(h->qh_quotadev),
                         (qid_t )0, (caddr_t )((void *)(& kdqblk)));
      }
#line 230
      if (tmp___3 < 0L) {
#line 231
        return (-1);
      }
    }
  } else {
    {
#line 237
    lseek(h->qh_fd, (__off64_t )0, 0);
#line 238
    tmp___4 = read(h->qh_fd, (void *)(& ddqblk), sizeof(ddqblk));
    }
#line 238
    if ((unsigned long )tmp___4 != sizeof(ddqblk)) {
#line 239
      return (-1);
    }
    {
#line 240
    ddqblk.dqb_btime = h->qh_info.dqi_bgrace;
#line 241
    ddqblk.dqb_itime = h->qh_info.dqi_igrace;
#line 242
    lseek(h->qh_fd, (__off64_t )0, 0);
#line 243
    tmp___5 = write(h->qh_fd, (void const   *)(& ddqblk), sizeof(ddqblk));
    }
#line 243
    if ((unsigned long )tmp___5 != sizeof(ddqblk)) {
#line 244
      return (-1);
    }
  }
#line 246
  return (0);
}
}
#line 253 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v1.c"
static struct dquot *v1_read_dquot___8(struct quota_handle *h , qid_t id___0 ) 
{ 
  struct v1_disk_dqblk ddqblk ;
  struct dquot *dquot ;
  struct dquot *tmp ;
  int tmp___0 ;
  struct v1_kern_dqblk kdqblk ;
  long tmp___1 ;
  ssize_t tmp___2 ;

  {
  {
#line 256
  tmp = get_empty_dquot();
#line 256
  dquot = tmp;
#line 258
  dquot->dq_id = id___0;
#line 259
  dquot->dq_h = h;
  }
#line 260
  if (h->qh_io_flags & 1) {
#line 261
    if (kernel_iface == 3) {
      {
#line 262
      tmp___0 = vfs_get_dquot(dquot);
      }
#line 262
      if (tmp___0 < 0) {
        {
#line 263
        free((void *)dquot);
        }
#line 264
        return ((struct dquot *)((void *)0));
      }
    } else {
      {
#line 270
      tmp___1 = quotactl((768 << 8) | (h->qh_type & 255), (char const   *)(h->qh_quotadev),
                         id___0, (caddr_t )((void *)(& kdqblk)));
      }
#line 270
      if (tmp___1 < 0L) {
        {
#line 271
        free((void *)dquot);
        }
#line 272
        return ((struct dquot *)((void *)0));
      }
      {
#line 274
      v1_kern2utildqblk(& dquot->dq_dqb, & kdqblk);
      }
    }
  } else {
    {
#line 278
    lseek(h->qh_fd, (loff_t )((unsigned long )id___0 * sizeof(struct v1_disk_dqblk )),
          0);
#line 279
    tmp___2 = read(h->qh_fd, (void *)(& ddqblk), sizeof(ddqblk));
    }
    {
#line 280
    if (tmp___2 == 0L) {
#line 280
      goto case_0;
    }
#line 287
    if (tmp___2 == (ssize_t )sizeof(struct v1_disk_dqblk )) {
#line 287
      goto case_exp;
    }
#line 290
    goto switch_default;
    case_0: /* CIL Label */ 
    {
#line 285
    memset((void *)(& dquot->dq_dqb), 0, sizeof(struct util_dqblk ));
    }
#line 286
    goto switch_break;
    case_exp: /* CIL Label */ 
    {
#line 288
    v1_disk2memdqblk(& dquot->dq_dqb, & ddqblk);
    }
#line 289
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 291
    free((void *)dquot);
    }
#line 292
    return ((struct dquot *)((void *)0));
    switch_break: /* CIL Label */ ;
    }
  }
#line 295
  return (dquot);
}
}
#line 302 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v1.c"
static int v1_commit_dquot___8(struct dquot *dquot , int flags___7 ) 
{ 
  struct v1_disk_dqblk ddqblk ;
  struct quota_handle *h ;
  char *tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  struct v1_kern_dqblk kdqblk ;
  int cmd ;
  int *tmp___2 ;
  long tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;
  ssize_t tmp___6 ;

  {
#line 305
  h = dquot->dq_h;
#line 307
  if (h->qh_io_flags & 4) {
    {
#line 308
    tmp = gettext("Trying to write quota to readonly quotafile on %s\n");
#line 308
    errstr(tmp, h->qh_quotadev);
#line 309
    tmp___0 = __errno_location();
#line 309
    *tmp___0 = 1;
    }
#line 310
    return (-1);
  }
#line 312
  if (h->qh_io_flags & 1) {
#line 313
    if (kernel_iface == 3) {
      {
#line 314
      tmp___1 = vfs_set_dquot(dquot, flags___7);
      }
#line 314
      if (tmp___1 < 0) {
#line 315
        return (-1);
      }
    } else {
#line 321
      if (flags___7 == 10) {
#line 322
        cmd = 1280;
      } else
#line 323
      if (flags___7 == 5) {
#line 324
        cmd = 1792;
      } else
#line 325
      if (flags___7 & 48) {
        {
#line 326
        tmp___2 = __errno_location();
#line 326
        *tmp___2 = 22;
        }
#line 327
        return (-1);
      } else {
#line 330
        cmd = 1024;
      }
      {
#line 331
      v1_util2kerndqblk(& kdqblk, & dquot->dq_dqb);
#line 332
      tmp___3 = quotactl((cmd << 8) | (h->qh_type & 255), (char const   *)(h->qh_quotadev),
                         dquot->dq_id, (caddr_t )((void *)(& kdqblk)));
      }
#line 332
      if (tmp___3 < 0L) {
#line 334
        return (-1);
      }
    }
  } else {
    {
#line 338
    tmp___5 = check_dquot_range(dquot);
    }
#line 338
    if (tmp___5 < 0) {
      {
#line 339
      tmp___4 = __errno_location();
#line 339
      *tmp___4 = 34;
      }
#line 340
      return (-1);
    }
    {
#line 342
    v1_mem2diskdqblk(& ddqblk, & dquot->dq_dqb);
#line 343
    lseek(h->qh_fd, (loff_t )((unsigned long )dquot->dq_id * sizeof(struct v1_disk_dqblk )),
          0);
#line 344
    tmp___6 = write(h->qh_fd, (void const   *)(& ddqblk), sizeof(ddqblk));
    }
#line 344
    if ((unsigned long )tmp___6 != sizeof(ddqblk)) {
#line 345
      return (-1);
    }
  }
#line 347
  return (0);
}
}
#line 355 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v1.c"
static int v1_scan_dquots___8(struct quota_handle *h , int (*process_dquot)(struct dquot *dquot ,
                                                                            char *dqname ) ) 
{ 
  int rd ;
  int scanbufpos ;
  int scanbufsize ;
  char scanbuf[sizeof(struct v1_disk_dqblk ) * 256UL] ;
  struct v1_disk_dqblk *ddqblk ;
  struct dquot *dquot ;
  struct dquot *tmp ;
  qid_t id___0 ;
  ssize_t tmp___0 ;

  {
  {
#line 357
  scanbufpos = 0;
#line 357
  scanbufsize = 0;
#line 360
  tmp = get_empty_dquot();
#line 360
  dquot = tmp;
#line 361
  id___0 = (qid_t )0;
#line 363
  memset((void *)dquot, 0, sizeof(*dquot));
#line 364
  dquot->dq_h = h;
#line 365
  lseek(h->qh_fd, (__off64_t )0, 0);
#line 366
  id___0 = (qid_t )0;
  }
  {
#line 366
  while (1) {
    while_continue: /* CIL Label */ ;
#line 367
    if (scanbufpos >= scanbufsize) {
      {
#line 368
      tmp___0 = read(h->qh_fd, (void *)(scanbuf), sizeof(scanbuf));
#line 368
      rd = (int )tmp___0;
      }
#line 369
      if (rd < 0) {
#line 370
        goto out_err;
      } else
#line 369
      if ((unsigned long )rd % sizeof(struct v1_disk_dqblk )) {
#line 370
        goto out_err;
      }
#line 371
      if (! rd) {
#line 372
        goto while_break;
      }
#line 373
      scanbufpos = 0;
#line 374
      scanbufsize = (int )((unsigned long )rd / sizeof(struct v1_disk_dqblk ));
    }
#line 376
    ddqblk = (struct v1_disk_dqblk *)(scanbuf) + scanbufpos;
#line 377
    if ((((long )(((((ddqblk->dqb_ihardlimit | ddqblk->dqb_isoftlimit) | ddqblk->dqb_bhardlimit) | ddqblk->dqb_bsoftlimit) | ddqblk->dqb_curblocks) | ddqblk->dqb_curinodes) | ddqblk->dqb_itime) | ddqblk->dqb_btime) == 0L) {
#line 381
      goto __Cont;
    }
    {
#line 382
    v1_disk2memdqblk(& dquot->dq_dqb, ddqblk);
#line 383
    dquot->dq_id = id___0;
#line 384
    rd = (*process_dquot)(dquot, (char *)((void *)0));
    }
#line 384
    if (rd < 0) {
      {
#line 385
      free((void *)dquot);
      }
#line 386
      return (rd);
    }
    __Cont: /* CIL Label */ 
#line 366
    id___0 ++;
#line 366
    scanbufpos ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 389
  if (! rd) {
    {
#line 390
    free((void *)dquot);
    }
#line 391
    return (0);
  }
  out_err: 
  {
#line 394
  free((void *)dquot);
  }
#line 395
  return (-1);
}
}
#line 27 "/home/wheatley/newnew/temp/quota-4.01/quotaio_xfs.c"
static int xfs_init_io___8(struct quota_handle *h ) ;
#line 28
static int xfs_write_info___8(struct quota_handle *h ) ;
#line 29
static struct dquot *xfs_read_dquot___8(struct quota_handle *h , qid_t id___0 ) ;
#line 30
static int xfs_commit_dquot___8(struct dquot *dquot , int flags___7 ) ;
#line 31
static int xfs_scan_dquots___8(struct quota_handle *h , int (*process_dquot)(struct dquot *dquot ,
                                                                             char *dqname ) ) ;
#line 32
static int xfs_report___8(struct quota_handle *h , int verbose ) ;
#line 77 "/home/wheatley/newnew/temp/quota-4.01/quotaio_xfs.c"
static int xfs_init_io___8(struct quota_handle *h ) 
{ 
  struct fs_quota_stat info ;
  int qcmd ;
  long tmp ;

  {
  {
#line 82
  qcmd = ((88 << 8) + 5) << 8;
#line 83
  memset((void *)(& info), 0, sizeof(struct fs_quota_stat ));
#line 84
  tmp = quotactl(qcmd, (char const   *)(h->qh_quotadev), (qid_t )0, (caddr_t )((void *)(& info)));
  }
#line 84
  if (tmp < 0L) {
#line 85
    return (-1);
  }
#line 86
  h->qh_info.dqi_bgrace = (time_t )info.qs_btimelimit;
#line 87
  h->qh_info.dqi_igrace = (time_t )info.qs_itimelimit;
#line 88
  h->qh_info.u.xfs_mdqi = info;
#line 89
  return (0);
}
}
#line 95 "/home/wheatley/newnew/temp/quota-4.01/quotaio_xfs.c"
static int xfs_write_info___8(struct quota_handle *h ) 
{ 
  struct fs_disk_quota xdqblk ;
  int qcmd ;
  long tmp ;

  {
#line 100
  if (h->qh_type == 0) {
#line 100
    if (! ((int )h->qh_info.u.xfs_mdqi.qs_flags & 1)) {
#line 100
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 100
  if (h->qh_type == 1) {
#line 100
    if (! ((int )h->qh_info.u.xfs_mdqi.qs_flags & (1 << 2))) {
#line 101
      return (0);
    }
  } else {
#line 101
    return (0);
  }
  {
#line 103
  memset((void *)(& xdqblk), 0, sizeof(struct fs_disk_quota ));
#line 105
  xdqblk.d_btimer = (__s32 )h->qh_info.dqi_bgrace;
#line 106
  xdqblk.d_itimer = (__s32 )h->qh_info.dqi_igrace;
#line 107
  xdqblk.d_fieldmask = (__u16 )((int )xdqblk.d_fieldmask | (((1 << 6) | (1 << 7)) | (1 << 8)));
#line 108
  qcmd = (((88 << 8) + 4) << 8) | (h->qh_type & 255);
#line 109
  tmp = quotactl(qcmd, (char const   *)(h->qh_quotadev), (qid_t )0, (caddr_t )((void *)(& xdqblk)));
  }
#line 109
  if (tmp < 0L) {
#line 110
    return (-1);
  }
#line 111
  return (0);
}
}
#line 117 "/home/wheatley/newnew/temp/quota-4.01/quotaio_xfs.c"
static struct dquot *xfs_read_dquot___8(struct quota_handle *h , qid_t id___0 ) 
{ 
  struct dquot *dquot ;
  struct dquot *tmp ;
  struct fs_disk_quota xdqblk ;
  int qcmd ;
  long tmp___0 ;

  {
  {
#line 119
  tmp = get_empty_dquot();
#line 119
  dquot = tmp;
#line 123
  dquot->dq_id = id___0;
#line 124
  dquot->dq_h = h;
  }
#line 126
  if (h->qh_type == 0) {
#line 126
    if (! ((int )h->qh_info.u.xfs_mdqi.qs_flags & 1)) {
#line 126
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 126
  if (h->qh_type == 1) {
#line 126
    if (! ((int )h->qh_info.u.xfs_mdqi.qs_flags & (1 << 2))) {
#line 127
      return (dquot);
    }
  } else {
#line 127
    return (dquot);
  }
  {
#line 129
  qcmd = (((88 << 8) + 3) << 8) | (h->qh_type & 255);
#line 130
  tmp___0 = quotactl(qcmd, (char const   *)(h->qh_quotadev), id___0, (caddr_t )((void *)(& xdqblk)));
  }
#line 130
  if (! (tmp___0 < 0L)) {
    {
#line 134
    xfs_kern2utildqblk(& dquot->dq_dqb, & xdqblk);
    }
  }
#line 136
  return (dquot);
}
}
#line 142 "/home/wheatley/newnew/temp/quota-4.01/quotaio_xfs.c"
static int xfs_commit_dquot___8(struct dquot *dquot , int flags___7 ) 
{ 
  struct quota_handle *h ;
  struct fs_disk_quota xdqblk ;
  qid_t id___0 ;
  int qcmd ;
  int tmp ;
  int tmp___0 ;
  long tmp___1 ;

  {
#line 144
  h = dquot->dq_h;
#line 146
  id___0 = dquot->dq_id;
#line 149
  if (h->qh_type == 0) {
#line 149
    if (! ((int )h->qh_info.u.xfs_mdqi.qs_flags & 1)) {
#line 149
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 149
  if (h->qh_type == 1) {
#line 149
    if (! ((int )h->qh_info.u.xfs_mdqi.qs_flags & (1 << 2))) {
#line 150
      return (0);
    }
  } else {
#line 150
    return (0);
  }
  {
#line 152
  xfs_util2kerndqblk(& xdqblk, & dquot->dq_dqb);
  }
#line 153
  if (h->qh_type == 0) {
#line 153
    if ((int )h->qh_info.u.xfs_mdqi.qs_flags & 1) {
#line 153
      tmp = 1;
    } else {
#line 153
      tmp = 1 << 2;
    }
  } else {
#line 153
    tmp = 1 << 2;
  }
  {
#line 153
  xdqblk.d_flags = (__s8 )((int )xdqblk.d_flags | tmp);
#line 154
  xdqblk.d_id = id___0;
#line 155
  tmp___0 = strcmp((char const   *)(h->qh_fstype), "gfs2");
  }
#line 155
  if (tmp___0 == 0) {
#line 156
    if (flags___7 & 5) {
#line 157
      xdqblk.d_fieldmask = (__u16 )((int )xdqblk.d_fieldmask | ((1 << 2) | (1 << 3)));
    }
#line 158
    if (flags___7 & 10) {
#line 159
      xdqblk.d_fieldmask = (__u16 )((int )xdqblk.d_fieldmask | (1 << 12));
    }
  } else {
#line 161
    xdqblk.d_fieldmask = (__u16 )((int )xdqblk.d_fieldmask | (((((1 | (1 << 1)) | (1 << 2)) | (1 << 3)) | (1 << 4)) | (1 << 5)));
  }
  {
#line 164
  qcmd = (((88 << 8) + 4) << 8) | (h->qh_type & 255);
#line 165
  tmp___1 = quotactl(qcmd, (char const   *)(h->qh_quotadev), id___0, (caddr_t )((void *)(& xdqblk)));
  }
#line 165
  if (! (tmp___1 < 0L)) {
#line 169
    return (0);
  }
#line 171
  return (-1);
}
}
#line 177 "/home/wheatley/newnew/temp/quota-4.01/quotaio_xfs.c"
static int xfs_get_dquot___8(struct dquot *dq ) 
{ 
  struct fs_disk_quota d ;
  int qcmd ;
  int ret ;
  long tmp ;
  int *tmp___0 ;

  {
  {
#line 180
  qcmd = (((88 << 8) + 3) << 8) | ((dq->dq_h)->qh_type & 255);
#line 183
  memset((void *)(& d), 0, sizeof(d));
#line 184
  tmp = quotactl(qcmd, (char const   *)((dq->dq_h)->qh_quotadev), dq->dq_id, (caddr_t )((void *)(& d)));
#line 184
  ret = (int )tmp;
  }
#line 185
  if (ret < 0) {
    {
#line 186
    tmp___0 = __errno_location();
    }
#line 186
    if (*tmp___0 == 2) {
#line 187
      return (0);
    }
#line 188
    return (-1);
  }
  {
#line 190
  xfs_kern2utildqblk(& dq->dq_dqb, & d);
  }
#line 191
  return (0);
}
}
#line 197 "/home/wheatley/newnew/temp/quota-4.01/quotaio_xfs.c"
static int xfs_scan_dquots___8(struct quota_handle *h , int (*process_dquot)(struct dquot *dquot ,
                                                                             char *dqname ) ) 
{ 
  int tmp ;

  {
#line 199
  if (h->qh_type == 0) {
#line 199
    if (! ((int )h->qh_info.u.xfs_mdqi.qs_flags & 1)) {
#line 199
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 199
  if (h->qh_type == 1) {
#line 199
    if (! ((int )h->qh_info.u.xfs_mdqi.qs_flags & (1 << 2))) {
#line 200
      return (0);
    }
  } else {
#line 200
    return (0);
  }
  {
#line 202
  tmp = generic_scan_dquots(h, process_dquot, & xfs_get_dquot___8);
  }
#line 202
  return (tmp);
}
}
#line 208 "/home/wheatley/newnew/temp/quota-4.01/quotaio_xfs.c"
static int xfs_report___8(struct quota_handle *h , int verbose ) 
{ 
  u_int16_t sbflags ;
  struct fs_quota_stat *info ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;
  char *tmp___18 ;
  char *tmp___19 ;
  char *tmp___20 ;
  char *tmp___21 ;
  char *tmp___22 ;
  char *tmp___23 ;
  char *tmp___24 ;
  char *tmp___25 ;
  char *tmp___26 ;
  char *tmp___27 ;
  char *tmp___28 ;
  char *tmp___29 ;
  char *tmp___30 ;
  char *tmp___31 ;
  char *tmp___32 ;

  {
#line 211
  info = & h->qh_info.u.xfs_mdqi;
#line 213
  if (! verbose) {
#line 214
    return (0);
  }
  {
#line 217
  tmp = type2name(h->qh_type);
#line 217
  tmp___0 = gettext("*** Status for %s quotas on device %s\n");
#line 217
  printf((char const   */* __restrict  */)tmp___0, tmp, h->qh_quotadev);
  }
#line 220
  if (h->qh_type == 0) {
#line 221
    if ((int )info->qs_flags & (1 << 1)) {
      {
#line 221
      tmp___1 = gettext("ON");
#line 221
      tmp___3 = tmp___1;
      }
    } else {
      {
#line 221
      tmp___2 = gettext("OFF");
#line 221
      tmp___3 = tmp___2;
      }
    }
#line 221
    if ((int )info->qs_flags & 1) {
      {
#line 221
      tmp___4 = gettext("ON");
#line 221
      tmp___6 = tmp___4;
      }
    } else {
      {
#line 221
      tmp___5 = gettext("OFF");
#line 221
      tmp___6 = tmp___5;
      }
    }
    {
#line 221
    tmp___7 = gettext("Accounting: %s; Enforcement: %s\n");
#line 221
    printf((char const   */* __restrict  */)tmp___7, tmp___6, tmp___3);
    }
  } else {
#line 225
    if ((int )info->qs_flags & (1 << 3)) {
      {
#line 225
      tmp___8 = gettext("ON");
#line 225
      tmp___10 = tmp___8;
      }
    } else {
      {
#line 225
      tmp___9 = gettext("OFF");
#line 225
      tmp___10 = tmp___9;
      }
    }
#line 225
    if ((int )info->qs_flags & (1 << 2)) {
      {
#line 225
      tmp___11 = gettext("ON");
#line 225
      tmp___13 = tmp___11;
      }
    } else {
      {
#line 225
      tmp___12 = gettext("OFF");
#line 225
      tmp___13 = tmp___12;
      }
    }
    {
#line 225
    tmp___14 = gettext("Accounting: %s; Enforcement: %s\n");
#line 225
    printf((char const   */* __restrict  */)tmp___14, tmp___13, tmp___10);
    }
  }
#line 235
  sbflags = (u_int16_t )(((int )info->qs_flags & 65280) >> 8);
#line 235
  if ((int )sbflags != 0) {
#line 236
    if (h->qh_type == 0) {
#line 237
      if ((int )sbflags & (1 << 1)) {
        {
#line 237
        tmp___15 = gettext("ON");
#line 237
        tmp___17 = tmp___15;
        }
      } else {
        {
#line 237
        tmp___16 = gettext("OFF");
#line 237
        tmp___17 = tmp___16;
        }
      }
#line 237
      if ((int )sbflags & 1) {
        {
#line 237
        tmp___18 = gettext("ON");
#line 237
        tmp___20 = tmp___18;
        }
      } else {
        {
#line 237
        tmp___19 = gettext("OFF");
#line 237
        tmp___20 = tmp___19;
        }
      }
      {
#line 237
      tmp___21 = gettext("Accounting [ondisk]: %s; Enforcement [ondisk]: %s\n");
#line 237
      printf((char const   */* __restrict  */)tmp___21, tmp___20, tmp___17);
      }
    } else {
#line 241
      if ((int )sbflags & (1 << 3)) {
        {
#line 241
        tmp___22 = gettext("ON");
#line 241
        tmp___24 = tmp___22;
        }
      } else {
        {
#line 241
        tmp___23 = gettext("OFF");
#line 241
        tmp___24 = tmp___23;
        }
      }
#line 241
      if ((int )sbflags & (1 << 2)) {
        {
#line 241
        tmp___25 = gettext("ON");
#line 241
        tmp___27 = tmp___25;
        }
      } else {
        {
#line 241
        tmp___26 = gettext("OFF");
#line 241
        tmp___27 = tmp___26;
        }
      }
      {
#line 241
      tmp___28 = gettext("Accounting [ondisk]: %s; Enforcement [ondisk]: %s\n");
#line 241
      printf((char const   */* __restrict  */)tmp___28, tmp___27, tmp___24);
      }
    }
  }
#line 248
  if (h->qh_type == 0) {
#line 249
    if (info->qs_uquota.qfs_ino == 0xffffffffffffffffULL) {
      {
#line 250
      tmp___29 = gettext("Inode: none\n");
#line 250
      printf((char const   */* __restrict  */)tmp___29);
      }
    } else
#line 249
    if (info->qs_uquota.qfs_ino == 0ULL) {
      {
#line 250
      tmp___29 = gettext("Inode: none\n");
#line 250
      printf((char const   */* __restrict  */)tmp___29);
      }
    } else {
      {
#line 252
      tmp___30 = gettext("Inode: #%llu (%llu blocks, %u extents)\n");
#line 252
      printf((char const   */* __restrict  */)tmp___30, info->qs_uquota.qfs_ino, info->qs_uquota.qfs_nblks,
             info->qs_uquota.qfs_nextents);
      }
    }
  } else
#line 258
  if (info->qs_gquota.qfs_ino == 0xffffffffffffffffULL) {
    {
#line 259
    tmp___31 = gettext("Inode: none\n");
#line 259
    printf((char const   */* __restrict  */)tmp___31);
    }
  } else {
    {
#line 261
    tmp___32 = gettext("Inode: #%llu (%llu blocks, %u extents)\n");
#line 261
    printf((char const   */* __restrict  */)tmp___32, info->qs_gquota.qfs_ino, info->qs_gquota.qfs_nblks,
           info->qs_gquota.qfs_nextents);
    }
  }
#line 266
  return (0);
}
}
#line 89 "/home/wheatley/newnew/temp/quota-4.01/rquota_client.c"
static int rquota_err___8(int stat___0 ) 
{ 


  {
  {
#line 92
  if (stat___0 == -1) {
#line 92
    goto case_neg_1;
  }
#line 94
  if (stat___0 == 0) {
#line 94
    goto case_0;
  }
#line 96
  if (stat___0 == 2) {
#line 96
    goto case_2;
  }
#line 98
  if (stat___0 == 1) {
#line 98
    goto case_1;
  }
#line 100
  if (stat___0 == 3) {
#line 100
    goto case_3;
  }
#line 102
  goto switch_default;
  case_neg_1: /* CIL Label */ 
#line 93
  return (-111);
  case_0: /* CIL Label */ 
#line 95
  return (-38);
  case_2: /* CIL Label */ 
#line 97
  return (-2);
  case_1: /* CIL Label */ 
#line 99
  return (0);
  case_3: /* CIL Label */ 
#line 101
  return (-1);
  switch_default: /* CIL Label */ 
#line 103
  return (-22);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 107 "/home/wheatley/newnew/temp/quota-4.01/rquota_client.c"
static int split_nfs_mount___8(char *devname , char **host , char **path ) 
{ 
  char *pathname ;

  {
#line 112
  if ((int )*devname == 91) {
    {
#line 113
    *host = devname + 1;
#line 114
    pathname = strchr((char const   *)devname, ']');
    }
#line 115
    if (! pathname) {
#line 116
      return (0);
    } else
#line 115
    if ((int )*(pathname + 1) != 58) {
#line 116
      return (0);
    }
#line 118
    if ((int )*(pathname + 2) == 40) {
#line 119
      return (0);
    }
#line 120
    *pathname = (char)0;
#line 121
    *path = pathname + 2;
#line 122
    return (1);
  }
  {
#line 124
  *host = devname;
#line 125
  pathname = strchr((char const   *)devname, ':');
  }
#line 126
  if (! pathname) {
#line 127
    return (0);
  }
#line 129
  if ((int )*(pathname + 1) == 40) {
#line 130
    return (0);
  }
#line 131
  *pathname = (char)0;
#line 132
  *path = pathname + 1;
#line 133
  return (1);
}
}
#line 19 "/home/wheatley/newnew/temp/quota-4.01/quotaio_meta.c"
static int meta_init_io___8(struct quota_handle *h ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
#line 21
  if (! (h->qh_io_flags & 1)) {
    {
#line 22
    tmp = gettext("Metadata init_io called when kernel support is not enabled.\n");
#line 22
    errstr(tmp);
    }
#line 23
    return (-1);
  }
#line 25
  if (kernel_iface != 3) {
    {
#line 26
    tmp___0 = gettext("Metadata init_io called when kernel does not support generic quota interface!\n");
#line 26
    errstr(tmp___0);
    }
#line 27
    return (-1);
  }
  {
#line 29
  tmp___1 = vfs_get_info(h);
  }
#line 29
  return (tmp___1);
}
}
#line 32 "/home/wheatley/newnew/temp/quota-4.01/quotaio_meta.c"
static int meta_write_info___8(struct quota_handle *h ) 
{ 
  int tmp ;

  {
  {
#line 34
  tmp = vfs_set_info(h, 3);
  }
#line 34
  return (tmp);
}
}
#line 37 "/home/wheatley/newnew/temp/quota-4.01/quotaio_meta.c"
static struct dquot *meta_read_dquot___8(struct quota_handle *h , qid_t id___0 ) 
{ 
  struct dquot *dquot ;
  struct dquot *tmp ;
  int tmp___0 ;

  {
  {
#line 39
  tmp = get_empty_dquot();
#line 39
  dquot = tmp;
#line 41
  dquot->dq_id = id___0;
#line 42
  dquot->dq_h = h;
#line 43
  memset((void *)(& dquot->dq_dqb), 0, sizeof(struct util_dqblk ));
#line 44
  tmp___0 = vfs_get_dquot(dquot);
  }
#line 44
  if (tmp___0 < 0) {
    {
#line 45
    free((void *)dquot);
    }
#line 46
    return ((struct dquot *)((void *)0));
  }
#line 48
  return (dquot);
}
}
#line 51 "/home/wheatley/newnew/temp/quota-4.01/quotaio_meta.c"
static int meta_commit_dquot___8(struct dquot *dquot , int flags___7 ) 
{ 
  int tmp ;

  {
  {
#line 53
  tmp = vfs_set_dquot(dquot, flags___7);
  }
#line 53
  return (tmp);
}
}
#line 56 "/home/wheatley/newnew/temp/quota-4.01/quotaio_meta.c"
static int meta_scan_dquots___8(struct quota_handle *h , int (*process_dquot)(struct dquot *dquot ,
                                                                              char *dqname ) ) 
{ 
  int tmp ;

  {
  {
#line 58
  tmp = generic_scan_dquots(h, process_dquot, & vfs_get_dquot);
  }
#line 58
  return (tmp);
}
}
#line 41 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static char extensions___9[4][20]  = { {        (char )'u',        (char )'s',        (char )'e',        (char )'r', 
            (char )'\000'}, 
   {        (char )'g',        (char )'r',        (char )'o',        (char )'u', 
            (char )'p',        (char )'\000'}, 
   {        (char )'u',        (char )'n',        (char )'d',        (char )'e', 
            (char )'f',        (char )'i',        (char )'n',        (char )'e', 
            (char )'d',        (char )'\000'}};
#line 42 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static char *basenames___9[6]  = {      (char *)"quota",      (char *)"aquota",      (char *)"aquota",      (char *)"", 
        (char *)"",      (char *)""};
#line 43 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static char *fmtnames___8[5]  = {      (char *)"vfsold",      (char *)"vfsv0",      (char *)"vfsv1",      (char *)"rpc", 
        (char *)"xfs"};
#line 245 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static int kern2utilfmt___8(int kernfmt ) 
{ 


  {
  {
#line 248
  if (kernfmt == 1) {
#line 248
    goto case_1;
  }
#line 250
  if (kernfmt == 2) {
#line 250
    goto case_2;
  }
#line 252
  if (kernfmt == 4) {
#line 252
    goto case_4;
  }
#line 254
  if (kernfmt == 3) {
#line 254
    goto case_3;
  }
#line 247
  goto switch_break;
  case_1: /* CIL Label */ 
#line 249
  return (0);
  case_2: /* CIL Label */ 
#line 251
  return (1);
  case_4: /* CIL Label */ 
#line 253
  return (2);
  case_3: /* CIL Label */ 
#line 255
  return (5);
  switch_break: /* CIL Label */ ;
  }
#line 257
  return (-1);
}
}
#line 394 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static int hasxfsquota___8(char const   *dev , struct mntent *mnt___2 , int type ,
                           int flags___7 ) 
{ 
  u_int16_t sbflags ;
  struct fs_quota_stat info ;
  long tmp ;

  {
#line 399
  if (flags___7 & 16) {
#line 400
    return (4);
  }
  {
#line 402
  memset((void *)(& info), 0, sizeof(struct fs_quota_stat ));
#line 403
  tmp = quotactl((((88 << 8) + 5) << 8) | (type & 255), dev, (qid_t )0, (caddr_t )((void *)(& info)));
  }
#line 403
  if (! tmp) {
#line 404
    sbflags = (u_int16_t )(((int )info.qs_flags & 65280) >> 8);
#line 405
    if (type == 0) {
#line 405
      if ((int )info.qs_flags & 1) {
#line 406
        return (4);
      } else {
#line 405
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 407
    if (type == 1) {
#line 407
      if ((int )info.qs_flags & (1 << 2)) {
#line 408
        return (4);
      }
    }
  }
#line 424
  return (-1);
}
}
#line 427 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static int hasvfsmetaquota___8(char const   *dev , struct mntent *mnt___2 , int type ,
                               int flags___7 ) 
{ 
  uint32_t fmt___7 ;
  long tmp ;

  {
  {
#line 431
  tmp = quotactl((8388612 << 8) | (type & 255), dev, (qid_t )0, (caddr_t )((void *)(& fmt___7)));
  }
#line 431
  if (! tmp) {
#line 432
    return (5);
  }
#line 433
  return (-1);
}
}
#line 465 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static char *hasmntoptarg___8(char const   *optstring , char const   *opt ) 
{ 
  char *p ;
  char *tmp ;
  size_t tmp___0 ;

  {
  {
#line 467
  tmp = str_hasmntopt(optstring, opt);
#line 467
  p = tmp;
  }
#line 469
  if (! p) {
#line 470
    return ((char *)((void *)0));
  }
  {
#line 471
  tmp___0 = strlen(opt);
#line 471
  p += tmp___0;
  }
#line 472
  if ((int )*p == 61) {
#line 472
    if ((int )*(p + 1) != 44) {
#line 473
      return (p + 1);
    }
  }
#line 474
  return ((char *)((void *)0));
}
}
#line 478 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static void copy_mntoptarg___8(char *buf , char const   *optarg___0 , int buflen ) 
{ 
  char *sep ;
  char *tmp ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  long tmp___4 ;

  {
  {
#line 480
  tmp = strchr(optarg___0, ',');
#line 480
  sep = tmp;
  }
#line 482
  if (! sep) {
    {
#line 483
    tmp___3 = strlen(optarg___0);
    }
#line 483
    if ((size_t )buflen < tmp___3 + 1UL) {
#line 483
      tmp___2 = (size_t )buflen;
    } else {
      {
#line 483
      tmp___1 = strlen(optarg___0);
#line 483
      tmp___2 = tmp___1 + 1UL;
      }
    }
    {
#line 483
    sstrncpy(buf, optarg___0, tmp___2);
    }
  } else {
#line 485
    if ((long )buflen < (sep - (char *)optarg___0) + 1L) {
#line 485
      tmp___4 = (long )buflen;
    } else {
#line 485
      tmp___4 = (sep - (char *)optarg___0) + 1L;
    }
    {
#line 485
    sstrncpy(buf, optarg___0, (size_t )tmp___4);
    }
  }
#line 486
  return;
}
}
#line 491 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static int hasquota___8(char const   *dev , struct mntent *mnt___2 , int type , int flags___7 ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  struct if_dqinfo kinfo ;
  long tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;

  {
  {
#line 493
  tmp___0 = strcmp((char const   *)mnt___2->mnt_type, "gfs2");
  }
#line 493
  if (tmp___0) {
    {
#line 493
    tmp___1 = strcmp((char const   *)mnt___2->mnt_type, "xfs");
    }
#line 493
    if (! tmp___1) {
      {
#line 495
      tmp = hasxfsquota___8(dev, mnt___2, type, flags___7);
      }
#line 495
      return (tmp);
    }
  } else {
    {
#line 495
    tmp = hasxfsquota___8(dev, mnt___2, type, flags___7);
    }
#line 495
    return (tmp);
  }
  {
#line 496
  tmp___3 = strcmp((char const   *)mnt___2->mnt_type, "ocfs2");
  }
#line 496
  if (! tmp___3) {
    {
#line 497
    tmp___2 = hasvfsmetaquota___8(dev, mnt___2, type, flags___7);
    }
#line 497
    return (tmp___2);
  }
  {
#line 504
  tmp___5 = strcmp((char const   *)mnt___2->mnt_type, "ext4");
  }
#line 504
  if (! tmp___5) {
    {
#line 507
    tmp___4 = quotactl((8388613 << 8) | (type & 255), dev, (qid_t )0, (caddr_t )((void *)(& kinfo)));
    }
#line 507
    if (tmp___4 == 0L) {
#line 508
      if (kinfo.dqi_flags & 65536U) {
#line 509
        return (5);
      }
    }
  }
  {
#line 513
  tmp___6 = nfs_fstype(mnt___2->mnt_type);
  }
#line 513
  if (tmp___6) {
#line 514
    return (3);
  }
#line 516
  if (type == 0) {
    {
#line 516
    tmp___7 = hasmntopt((struct mntent  const  *)mnt___2, "usrquota");
    }
#line 516
    if (tmp___7) {
#line 517
      return (6);
    } else {
      {
#line 516
      tmp___8 = hasmntoptarg___8((char const   *)mnt___2->mnt_opts, "usrjquota");
      }
#line 516
      if (tmp___8) {
#line 517
        return (6);
      }
    }
  }
#line 518
  if (type == 1) {
    {
#line 518
    tmp___9 = hasmntopt((struct mntent  const  *)mnt___2, "grpquota");
    }
#line 518
    if (tmp___9) {
#line 519
      return (6);
    } else {
      {
#line 518
      tmp___10 = hasmntoptarg___8((char const   *)mnt___2->mnt_opts, "grpjquota");
      }
#line 518
      if (tmp___10) {
#line 519
        return (6);
      }
    }
  }
#line 520
  if (type == 0) {
    {
#line 520
    tmp___11 = hasmntopt((struct mntent  const  *)mnt___2, "quota");
    }
#line 520
    if (tmp___11) {
#line 521
      return (6);
    }
  }
#line 522
  return (-1);
}
}
#line 526 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static int check_fmtfile_ok___8(char *name , int type , int fmt___7 , int flags___7 ) 
{ 
  struct stat st ;
  int *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;
  int fd ;
  int ret ;
  int tmp___4 ;
  int *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  int *tmp___8 ;
  int *tmp___9 ;

  {
#line 528
  if (! flags___7) {
#line 529
    return (1);
  }
#line 530
  if (flags___7 & 1) {
    {
#line 533
    tmp___3 = stat((char const   */* __restrict  */)name, (struct stat */* __restrict  */)(& st));
    }
#line 533
    if (tmp___3 < 0) {
      {
#line 534
      tmp___2 = __errno_location();
      }
#line 534
      if (*tmp___2 != 2) {
        {
#line 535
        tmp = __errno_location();
#line 535
        tmp___0 = strerror(*tmp);
#line 535
        tmp___1 = gettext("Cannot stat quota file %s: %s\n");
#line 535
        errstr(tmp___1, name, tmp___0);
        }
      }
#line 536
      return (0);
    }
  }
#line 539
  if (flags___7 & 2) {
    {
#line 540
    ret = 0;
#line 542
    fd = open((char const   *)name, 0);
    }
#line 542
    if (fd >= 0) {
      {
#line 543
      tmp___4 = is_tree_qfmt(fmt___7);
      }
#line 543
      if (tmp___4) {
        {
#line 544
        ret = (*(quotafile_ops_2.check_file))(fd, type, fmt___7);
        }
      } else {
        {
#line 546
        ret = (*(quotafile_ops_1.check_file))(fd, type, fmt___7);
        }
      }
      {
#line 547
      close(fd);
      }
#line 548
      if (ret <= 0) {
#line 549
        return (0);
      }
    } else {
      {
#line 551
      tmp___8 = __errno_location();
      }
#line 551
      if (*tmp___8 != 2) {
        {
#line 551
        tmp___9 = __errno_location();
        }
#line 551
        if (*tmp___9 != 1) {
          {
#line 552
          tmp___5 = __errno_location();
#line 552
          tmp___6 = strerror(*tmp___5);
#line 552
          tmp___7 = gettext("Cannot open quotafile %s: %s\n");
#line 552
          errstr(tmp___7, name, tmp___6);
          }
#line 553
          return (0);
        }
      }
    }
  }
#line 556
  return (1);
}
}
#line 629 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static int hlist_allocated___8  =    0;
#line 630 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static struct quota_handle **hlist___8  =    (struct quota_handle **)((void *)0);
#line 735 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static int kernel_qfmt_num___8  ;
#line 736 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static int kernel_qfmt___8[6]  ;
#line 828 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static int v1_kern_quota_on___8(char const   *dev , int type ) 
{ 
  char tmp[1024] ;
  qid_t id___0 ;
  __uid_t tmp___0 ;
  __gid_t tmp___1 ;
  __uid_t tmp___2 ;
  long tmp___3 ;

  {
#line 831
  if (type == 0) {
    {
#line 831
    tmp___0 = getuid();
#line 831
    tmp___2 = tmp___0;
    }
  } else {
    {
#line 831
    tmp___1 = getgid();
#line 831
    tmp___2 = tmp___1;
    }
  }
  {
#line 831
  id___0 = tmp___2;
#line 833
  tmp___3 = quotactl((768 << 8) | (type & 255), dev, id___0, tmp);
  }
#line 833
  if (! tmp___3) {
#line 834
    return (1);
  }
#line 835
  return (0);
}
}
#line 839 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static int v2_kern_quota_on___8(char const   *dev , int type ) 
{ 
  char tmp[1024] ;
  qid_t id___0 ;
  __uid_t tmp___0 ;
  __gid_t tmp___1 ;
  __uid_t tmp___2 ;
  long tmp___3 ;

  {
#line 842
  if (type == 0) {
    {
#line 842
    tmp___0 = getuid();
#line 842
    tmp___2 = tmp___0;
    }
  } else {
    {
#line 842
    tmp___1 = getgid();
#line 842
    tmp___2 = tmp___1;
    }
  }
  {
#line 842
  id___0 = tmp___2;
#line 844
  tmp___3 = quotactl((3328 << 8) | (type & 255), dev, id___0, tmp);
  }
#line 844
  if (! tmp___3) {
#line 845
    return (1);
  }
#line 846
  return (0);
}
}
#line 850 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static int xfs_kern_quota_on___8(char const   *dev , int type ) 
{ 
  struct fs_quota_stat info ;
  long tmp ;

  {
  {
#line 854
  tmp = quotactl((((88 << 8) + 5) << 8) | (type & 255), dev, (qid_t )0, (caddr_t )((void *)(& info)));
  }
#line 854
  if (! tmp) {
#line 855
    if (type == 0) {
#line 855
      if ((int )info.qs_flags & 1) {
#line 856
        return (1);
      }
    }
#line 857
    if (type == 1) {
#line 857
      if ((int )info.qs_flags & (1 << 2)) {
#line 858
        return (1);
      }
    }
  }
#line 860
  return (0);
}
}
#line 921 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static int mnt_entries_cnt___8  ;
#line 922 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static struct mount_entry *mnt_entries___8  ;
#line 923 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static int check_dirs_cnt___8  ;
#line 923 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static int act_checked___8  ;
#line 924 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static struct searched_dir *check_dirs___8  ;
#line 927 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static int cache_mnt_table___8(int flags___7 ) 
{ 
  FILE *mntf ;
  struct mntent *mnt___2 ;
  struct stat st ;
  struct statfs fsstat ;
  int allocated ;
  int i ;
  dev_t dev ;
  char mntpointbuf[4096] ;
  int autofsdircnt ;
  int autofsdir_allocated ;
  char **autofsdir ;
  char *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  char const   *devname ;
  char *opt ;
  int qfmt[2] ;
  char *tmp___2 ;
  int slen ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  void *tmp___6 ;
  size_t tmp___7 ;
  void *tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char loopdev[4096] ;
  char *tmp___13 ;
  int *tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;
  int *tmp___18 ;
  char *tmp___19 ;
  char *tmp___20 ;
  int tmp___21 ;
  int *tmp___22 ;
  char *tmp___23 ;
  char *tmp___24 ;
  int tmp___25 ;
  char *tmp___26 ;
  int tmp___27 ;
  int *tmp___28 ;
  char *tmp___29 ;
  char *tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;
  void *tmp___34 ;
  char *tmp___35 ;

  {
  {
#line 933
  allocated = 0;
#line 933
  i = 0;
#line 934
  dev = (dev_t )0;
#line 940
  mntf = setmntent("/proc/mounts", "r");
  }
#line 941
  if (mntf) {
#line 942
    goto alloc;
  }
  {
#line 944
  mntf = setmntent("/etc/mtab", "r");
  }
#line 945
  if (mntf) {
#line 946
    goto alloc;
  }
  {
#line 948
  mntf = setmntent("/etc/fstab", "r");
  }
#line 948
  if (! mntf) {
    {
#line 949
    tmp = gettext("Cannot open any file with mount points.\n");
#line 949
    errstr(tmp);
    }
#line 950
    return (-1);
  }
  alloc: 
  {
#line 954
  tmp___0 = smalloc(sizeof(struct mount_entry ) * 16UL);
#line 954
  mnt_entries___8 = (struct mount_entry *)tmp___0;
#line 955
  mnt_entries_cnt___8 = 0;
#line 956
  allocated += 16;
#line 958
  tmp___1 = smalloc(sizeof(char *) * 16UL);
#line 958
  autofsdir = (char **)tmp___1;
#line 959
  autofsdircnt = 0;
#line 960
  autofsdir_allocated = 16;
  }
  {
#line 961
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 961
    mnt___2 = getmntent(mntf);
    }
#line 961
    if (! mnt___2) {
#line 961
      goto while_break;
    }
    {
#line 966
    devname = get_device_name((char const   *)mnt___2->mnt_fsname);
    }
#line 966
    if (! devname) {
      {
#line 967
      tmp___2 = gettext("Cannot get device name for %s\n");
#line 967
      errstr(tmp___2, mnt___2->mnt_fsname);
      }
#line 968
      goto while_continue;
    }
#line 972
    i = 0;
    {
#line 972
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 972
      if (! (i < autofsdircnt)) {
#line 972
        goto while_break___0;
      }
      {
#line 973
      tmp___3 = strlen((char const   *)*(autofsdir + i));
#line 973
      slen = (int )tmp___3;
#line 975
      tmp___4 = strlen((char const   *)mnt___2->mnt_dir);
      }
#line 975
      if ((size_t )slen <= tmp___4) {
        {
#line 975
        tmp___5 = strncmp((char const   *)*(autofsdir + i), (char const   *)mnt___2->mnt_dir,
                          (size_t )slen);
        }
#line 975
        if (! tmp___5) {
#line 976
          goto while_break___0;
        }
      }
#line 972
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 978
    if (i < autofsdircnt) {
      {
#line 979
      free((void *)((char *)devname));
      }
#line 980
      goto while_continue;
    }
#line 983
    if (flags___7 & 2) {
      {
#line 983
      tmp___9 = strcmp((char const   *)mnt___2->mnt_type, "autofs");
      }
#line 983
      if (! tmp___9) {
#line 984
        if (autofsdircnt == autofsdir_allocated) {
          {
#line 985
          autofsdir_allocated += 16;
#line 986
          tmp___6 = srealloc((void *)autofsdir, (unsigned long )autofsdir_allocated * sizeof(char *));
#line 986
          autofsdir = (char **)tmp___6;
          }
        }
        {
#line 988
        tmp___7 = strlen((char const   *)mnt___2->mnt_dir);
#line 988
        tmp___8 = smalloc(tmp___7 + 2UL);
#line 988
        *(autofsdir + autofsdircnt) = (char *)tmp___8;
#line 989
        strcpy((char */* __restrict  */)*(autofsdir + autofsdircnt), (char const   */* __restrict  */)mnt___2->mnt_dir);
#line 990
        strcat((char */* __restrict  */)*(autofsdir + autofsdircnt), (char const   */* __restrict  */)"/");
#line 991
        autofsdircnt ++;
#line 992
        free((void *)((char *)devname));
        }
#line 993
        goto while_continue;
      }
    }
#line 996
    if (flags___7 & 8) {
      {
#line 996
      tmp___10 = nfs_fstype(mnt___2->mnt_type);
      }
#line 996
      if (tmp___10) {
        {
#line 997
        free((void *)((char *)devname));
        }
#line 998
        goto while_continue;
      }
    }
    {
#line 1000
    tmp___11 = hasmntopt((struct mntent  const  *)mnt___2, "noquota");
    }
#line 1000
    if (tmp___11) {
      {
#line 1001
      free((void *)((char *)devname));
      }
#line 1002
      goto while_continue;
    }
    {
#line 1004
    tmp___12 = hasmntopt((struct mntent  const  *)mnt___2, "bind");
    }
#line 1004
    if (tmp___12) {
      {
#line 1005
      free((void *)((char *)devname));
      }
#line 1006
      goto while_continue;
    }
    {
#line 1008
    opt = hasmntoptarg___8((char const   *)mnt___2->mnt_opts, "loop");
    }
#line 1008
    if (opt) {
      {
#line 1011
      copy_mntoptarg___8(opt, (char const   *)(loopdev), 4096);
#line 1012
      free((void *)((char *)devname));
#line 1013
      tmp___13 = sstrdup((char const   *)(loopdev));
#line 1013
      devname = (char const   *)tmp___13;
      }
    }
    {
#line 1018
    qfmt[0] = hasquota___8(devname, mnt___2, 0, flags___7);
#line 1019
    qfmt[1] = hasquota___8(devname, mnt___2, 1, flags___7);
    }
#line 1020
    if (qfmt[0] < 0) {
#line 1020
      if (qfmt[1] < 0) {
        {
#line 1021
        free((void *)((char *)devname));
        }
#line 1022
        goto while_continue;
      }
    }
    {
#line 1025
    tmp___17 = realpath((char const   */* __restrict  */)mnt___2->mnt_dir, (char */* __restrict  */)(mntpointbuf));
    }
#line 1025
    if (! tmp___17) {
      {
#line 1026
      tmp___14 = __errno_location();
#line 1026
      tmp___15 = strerror(*tmp___14);
#line 1026
      tmp___16 = gettext("Cannot resolve mountpoint path %s: %s\n");
#line 1026
      errstr(tmp___16, mnt___2->mnt_dir, tmp___15);
#line 1027
      free((void *)((char *)devname));
      }
#line 1028
      goto while_continue;
    }
    {
#line 1031
    tmp___21 = statfs((char const   *)(mntpointbuf), & fsstat);
    }
#line 1031
    if (tmp___21 != 0) {
      {
#line 1032
      tmp___18 = __errno_location();
#line 1032
      tmp___19 = strerror(*tmp___18);
#line 1032
      tmp___20 = gettext("Cannot statfs() %s: %s\n");
#line 1032
      errstr(tmp___20, mntpointbuf, tmp___19);
#line 1033
      free((void *)((char *)devname));
      }
#line 1034
      goto while_continue;
    }
#line 1037
    if (fsstat.f_blocks == 0UL) {
#line 1037
      if (fsstat.f_bfree == 0UL) {
#line 1037
        if (fsstat.f_bavail == 0UL) {
          {
#line 1038
          free((void *)((char *)devname));
          }
#line 1039
          goto while_continue;
        }
      }
    }
    {
#line 1042
    tmp___27 = nfs_fstype(mnt___2->mnt_type);
    }
#line 1042
    if (! tmp___27) {
      {
#line 1043
      tmp___25 = stat((char const   */* __restrict  */)devname, (struct stat */* __restrict  */)(& st));
      }
#line 1043
      if (tmp___25 < 0) {
        {
#line 1044
        tmp___22 = __errno_location();
#line 1044
        tmp___23 = strerror(*tmp___22);
#line 1044
        tmp___24 = gettext("Cannot stat() mounted device %s: %s\n");
#line 1044
        errstr(tmp___24, devname, tmp___23);
#line 1045
        free((void *)((char *)devname));
        }
#line 1046
        goto while_continue;
      }
#line 1048
      if (! ((st.st_mode & 61440U) == 24576U)) {
#line 1048
        if (! ((st.st_mode & 61440U) == 8192U)) {
          {
#line 1049
          tmp___26 = gettext("Device (%s) filesystem is mounted on unsupported device type. Skipping.\n");
#line 1049
          errstr(tmp___26, devname);
#line 1050
          free((void *)((char *)devname));
          }
#line 1051
          goto while_continue;
        }
      }
#line 1053
      dev = st.st_rdev;
#line 1054
      i = 0;
      {
#line 1054
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1054
        if (i < mnt_entries_cnt___8) {
#line 1054
          if (! ((mnt_entries___8 + i)->me_dev != dev)) {
#line 1054
            goto while_break___1;
          }
        } else {
#line 1054
          goto while_break___1;
        }
#line 1054
        i ++;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
    {
#line 1057
    tmp___33 = nfs_fstype(mnt___2->mnt_type);
    }
#line 1057
    if (tmp___33) {
#line 1057
      goto _L;
    } else
#line 1057
    if (i == mnt_entries_cnt___8) {
      _L: /* CIL Label */ 
      {
#line 1058
      tmp___31 = stat((char const   */* __restrict  */)mnt___2->mnt_dir, (struct stat */* __restrict  */)(& st));
      }
#line 1058
      if (tmp___31 < 0) {
        {
#line 1059
        tmp___28 = __errno_location();
#line 1059
        tmp___29 = strerror(*tmp___28);
#line 1059
        tmp___30 = gettext("Cannot stat() mountpoint %s: %s\n");
#line 1059
        errstr(tmp___30, mnt___2->mnt_dir, tmp___29);
#line 1060
        free((void *)((char *)devname));
        }
#line 1061
        goto while_continue;
      }
      {
#line 1063
      tmp___32 = nfs_fstype(mnt___2->mnt_type);
      }
#line 1063
      if (tmp___32) {
#line 1065
        dev = st.st_dev;
#line 1066
        if (! (flags___7 & 32)) {
#line 1067
          i = 0;
          {
#line 1067
          while (1) {
            while_continue___2: /* CIL Label */ ;
#line 1067
            if (i < mnt_entries_cnt___8) {
#line 1067
              if (! ((mnt_entries___8 + i)->me_dev != dev)) {
#line 1067
                goto while_break___2;
              }
            } else {
#line 1067
              goto while_break___2;
            }
#line 1067
            i ++;
          }
          while_break___2: /* CIL Label */ ;
          }
        } else {
#line 1070
          i = mnt_entries_cnt___8;
        }
      }
    }
#line 1073
    if (i == mnt_entries_cnt___8) {
#line 1074
      if (allocated == mnt_entries_cnt___8) {
        {
#line 1075
        allocated += 16;
#line 1076
        tmp___34 = srealloc((void *)mnt_entries___8, (unsigned long )allocated * sizeof(struct mount_entry ));
#line 1076
        mnt_entries___8 = (struct mount_entry *)tmp___34;
        }
      }
      {
#line 1078
      (mnt_entries___8 + i)->me_type = sstrdup((char const   *)mnt___2->mnt_type);
#line 1079
      (mnt_entries___8 + i)->me_opts = sstrdup((char const   *)mnt___2->mnt_opts);
#line 1080
      (mnt_entries___8 + i)->me_dev = dev;
#line 1081
      (mnt_entries___8 + i)->me_ino = st.st_ino;
#line 1082
      (mnt_entries___8 + i)->me_devname = devname;
#line 1083
      tmp___35 = sstrdup((char const   *)(mntpointbuf));
#line 1083
      (mnt_entries___8 + i)->me__dir = (char const   *)tmp___35;
#line 1084
      (mnt_entries___8 + i)->me_dir = (char const   *)((void *)0);
#line 1085
      memcpy((void */* __restrict  */)(& (mnt_entries___8 + i)->me_qfmt), (void const   */* __restrict  */)(qfmt),
             sizeof(qfmt));
#line 1086
      mnt_entries_cnt___8 ++;
      }
    } else {
      {
#line 1089
      free((void *)((char *)devname));
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1091
  endmntent(mntf);
#line 1093
  i = 0;
  }
  {
#line 1093
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 1093
    if (! (i < autofsdircnt)) {
#line 1093
      goto while_break___3;
    }
    {
#line 1094
    free((void *)*(autofsdir + i));
#line 1093
    i ++;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 1095
  free((void *)autofsdir);
  }
#line 1096
  return (0);
}
}
#line 1100 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static char const   *find_dir_mntpoint___8(struct stat *st ) 
{ 
  int i ;

  {
#line 1104
  i = 0;
  {
#line 1104
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1104
    if (! (i < mnt_entries_cnt___8)) {
#line 1104
      goto while_break;
    }
#line 1105
    if ((mnt_entries___8 + i)->me_dev == st->st_dev) {
#line 1106
      st->st_ino = (mnt_entries___8 + i)->me_ino;
#line 1107
      return ((mnt_entries___8 + i)->me__dir);
    }
#line 1104
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1109
  return ((char const   *)((void *)0));
}
}
#line 1113 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static int process_dirs___8(int dcnt , char **dirs , int flags___7 ) 
{ 
  struct stat st ;
  int i ;
  char mntpointbuf[4096] ;
  void *tmp ;
  char *devname ;
  char const   *tmp___0 ;
  char *tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  int *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  char const   *realmnt ;
  char *tmp___12 ;
  int *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  int mentry ;
  char *tmp___17 ;
  char *tmp___18 ;
  char *tmp___19 ;
  char *tmp___20 ;

  {
#line 1119
  check_dirs_cnt___8 = 0;
#line 1120
  act_checked___8 = -1;
#line 1121
  if (dcnt) {
    {
#line 1122
    tmp = smalloc(sizeof(struct searched_dir ) * (unsigned long )dcnt);
#line 1122
    check_dirs___8 = (struct searched_dir *)tmp;
#line 1123
    i = 0;
    }
    {
#line 1123
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1123
      if (! (i < dcnt)) {
#line 1123
        goto while_break;
      }
      {
#line 1124
      tmp___10 = strncmp((char const   *)*(dirs + i), "UUID=", (size_t )5);
      }
#line 1124
      if (tmp___10) {
        {
#line 1124
        tmp___11 = strncmp((char const   *)*(dirs + i), "LABEL=", (size_t )6);
        }
#line 1124
        if (tmp___11) {
          {
#line 1139
          tmp___9 = stat((char const   */* __restrict  */)*(dirs + i), (struct stat */* __restrict  */)(& st));
          }
#line 1139
          if (tmp___9 < 0) {
            {
#line 1140
            tmp___6 = __errno_location();
#line 1140
            tmp___7 = strerror(*tmp___6);
#line 1140
            tmp___8 = gettext("Cannot stat() given mountpoint %s: %s\nSkipping...\n");
#line 1140
            errstr(tmp___8, *(dirs + i), tmp___7);
            }
#line 1141
            goto __Cont;
          }
        } else {
          _L: /* CIL Label */ 
          {
#line 1125
          tmp___0 = get_device_name((char const   *)*(dirs + i));
#line 1125
          devname = (char *)tmp___0;
          }
#line 1127
          if (! devname) {
            {
#line 1128
            tmp___1 = gettext("Cannot find a device with %s.\nSkipping...\n");
#line 1128
            errstr(tmp___1, *(dirs + i));
            }
#line 1129
            goto __Cont;
          }
          {
#line 1131
          tmp___5 = stat((char const   */* __restrict  */)devname, (struct stat */* __restrict  */)(& st));
          }
#line 1131
          if (tmp___5 < 0) {
            {
#line 1132
            tmp___2 = __errno_location();
#line 1132
            tmp___3 = strerror(*tmp___2);
#line 1132
            tmp___4 = gettext("Cannot stat() a mountpoint with %s: %s\nSkipping...\n");
#line 1132
            errstr(tmp___4, *(dirs + i), tmp___3);
#line 1133
            free((void *)devname);
            }
#line 1134
            goto __Cont;
          }
          {
#line 1136
          free((void *)devname);
          }
        }
      } else {
#line 1124
        goto _L;
      }
#line 1143
      (check_dirs___8 + check_dirs_cnt___8)->sd_dir = (st.st_mode & 61440U) == 16384U;
#line 1144
      if ((st.st_mode & 61440U) == 16384U) {
#line 1145
        realmnt = (char const   *)*(dirs + i);
#line 1148
        if (flags___7 & 1) {
          {
#line 1148
          realmnt = find_dir_mntpoint___8(& st);
          }
#line 1148
          if (! realmnt) {
#line 1149
            if (! (flags___7 & 4)) {
              {
#line 1150
              tmp___12 = gettext("Cannot find a filesystem mountpoint for directory %s\n");
#line 1150
              errstr(tmp___12, *(dirs + i));
              }
            }
#line 1151
            goto __Cont;
          }
        }
        {
#line 1153
        (check_dirs___8 + check_dirs_cnt___8)->sd_dev = st.st_dev;
#line 1154
        (check_dirs___8 + check_dirs_cnt___8)->sd_ino = st.st_ino;
#line 1155
        tmp___16 = realpath((char const   */* __restrict  */)realmnt, (char */* __restrict  */)(mntpointbuf));
        }
#line 1155
        if (! tmp___16) {
          {
#line 1156
          tmp___13 = __errno_location();
#line 1156
          tmp___14 = strerror(*tmp___13);
#line 1156
          tmp___15 = gettext("Cannot resolve path %s: %s\n");
#line 1156
          errstr(tmp___15, realmnt, tmp___14);
          }
#line 1157
          goto __Cont;
        }
      } else
#line 1160
      if ((st.st_mode & 61440U) == 24576U) {
#line 1160
        goto _L___0;
      } else
#line 1160
      if ((st.st_mode & 61440U) == 8192U) {
        _L___0: /* CIL Label */ 
#line 1163
        (check_dirs___8 + check_dirs_cnt___8)->sd_dev = st.st_rdev;
#line 1164
        mentry = 0;
        {
#line 1164
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 1164
          if (mentry < mnt_entries_cnt___8) {
#line 1164
            if (! ((mnt_entries___8 + mentry)->me_dev != st.st_rdev)) {
#line 1164
              goto while_break___0;
            }
          } else {
#line 1164
            goto while_break___0;
          }
#line 1164
          mentry ++;
        }
        while_break___0: /* CIL Label */ ;
        }
#line 1165
        if (mentry == mnt_entries_cnt___8) {
#line 1166
          if (! (flags___7 & 4)) {
            {
#line 1167
            tmp___17 = gettext("Cannot find mountpoint for device %s\n");
#line 1167
            errstr(tmp___17, *(dirs + i));
            }
          }
#line 1168
          goto __Cont;
        }
        {
#line 1170
        sstrncpy(mntpointbuf, (mnt_entries___8 + mentry)->me__dir, (size_t )4095);
        }
      } else {
        {
#line 1173
        tmp___18 = gettext("Specified path %s is not directory nor device.\n");
#line 1173
        errstr(tmp___18, *(dirs + i));
        }
#line 1174
        goto __Cont;
      }
      {
#line 1176
      tmp___19 = sstrdup((char const   *)(mntpointbuf));
#line 1176
      (check_dirs___8 + check_dirs_cnt___8)->sd_name = (char const   *)tmp___19;
#line 1177
      check_dirs_cnt___8 ++;
      }
      __Cont: /* CIL Label */ 
#line 1123
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 1179
    if (! check_dirs_cnt___8) {
#line 1180
      if (! (flags___7 & 4)) {
        {
#line 1181
        tmp___20 = gettext("No correct mountpoint specified.\n");
#line 1181
        errstr(tmp___20);
        }
      }
      {
#line 1182
      free((void *)check_dirs___8);
      }
#line 1183
      return (-1);
    }
  }
#line 1186
  return (0);
}
}
#line 1204 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static int find_next_entry_all___8(int *pos ) 
{ 
  char *tmp ;

  {
  {
#line 1206
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1206
    act_checked___8 ++;
#line 1206
    if (! (act_checked___8 < mnt_entries_cnt___8)) {
#line 1206
      goto while_break;
    }
    {
#line 1207
    tmp = str_hasmntopt((char const   *)(mnt_entries___8 + act_checked___8)->me_opts,
                        "noauto");
    }
#line 1207
    if (! tmp) {
#line 1208
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1210
  if (act_checked___8 >= mnt_entries_cnt___8) {
#line 1211
    return (0);
  }
#line 1212
  *pos = act_checked___8;
#line 1213
  return (1);
}
}
#line 1217 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static int find_next_entry_sel___8(int *pos ) 
{ 
  int i ;
  struct searched_dir *sd ;
  char *tmp ;

  {
  restart: 
#line 1223
  act_checked___8 ++;
#line 1223
  if (act_checked___8 == check_dirs_cnt___8) {
#line 1224
    return (0);
  }
#line 1225
  sd = check_dirs___8 + act_checked___8;
#line 1226
  i = 0;
  {
#line 1226
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1226
    if (! (i < mnt_entries_cnt___8)) {
#line 1226
      goto while_break;
    }
#line 1227
    if (sd->sd_dir) {
#line 1228
      if (sd->sd_dev == (mnt_entries___8 + i)->me_dev) {
#line 1228
        if (sd->sd_ino == (mnt_entries___8 + i)->me_ino) {
#line 1229
          goto while_break;
        }
      }
    } else
#line 1232
    if (sd->sd_dev == (mnt_entries___8 + i)->me_dev) {
#line 1233
      goto while_break;
    }
#line 1226
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1235
  if (i == mnt_entries_cnt___8) {
    {
#line 1236
    tmp = gettext("Mountpoint (or device) %s not found or has no quota enabled.\n");
#line 1236
    errstr(tmp, sd->sd_name);
    }
#line 1237
    goto restart;
  }
#line 1239
  *pos = i;
#line 1240
  return (1);
}
}
#line 23 "/home/wheatley/newnew/temp/quota-4.01/common.c"
static int enable_syslog___10  =    0;
#line 31 "/home/wheatley/newnew/temp/quota-4.01/common.c"
static void do_syslog___10(int level , char const   *format , va_list args ) 
{ 
  char buf[1024] ;
  int i ;
  int j ;
  int tmp ;

  {
  {
#line 36
  vsnprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)format,
            args);
#line 39
  i = 0;
  }
  {
#line 39
  while (1) {
    while_continue: /* CIL Label */ ;
#line 39
    if (! buf[i]) {
#line 39
      goto while_break;
    }
#line 40
    j = i;
    {
#line 40
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 40
      if (buf[j]) {
#line 40
        if (! ((int )buf[j] != 10)) {
#line 40
          goto while_break___0;
        }
      } else {
#line 40
        goto while_break___0;
      }
#line 40
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 41
    if ((int )buf[j] == 10) {
#line 42
      tmp = j;
#line 42
      j ++;
#line 42
      buf[tmp] = (char )'\000';
    }
    {
#line 43
    syslog(level, "%s", buf + i);
#line 39
    i = j;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 45
  return;
}
}
#line 18 "/home/wheatley/newnew/temp/quota-4.01/quotaio_rpc.c"
static int rpc_init_io___8(struct quota_handle *h ) ;
#line 19
static struct dquot *rpc_read_dquot___8(struct quota_handle *h , qid_t id___0 ) ;
#line 20
static int rpc_commit_dquot___8(struct dquot *dquot , int flags___7 ) ;
#line 31 "/home/wheatley/newnew/temp/quota-4.01/quotaio_rpc.c"
static int rpc_init_io___8(struct quota_handle *h ) 
{ 


  {
#line 34
  h->qh_info.dqi_max_b_limit = (uint64_t )(~ ((uint32_t )0));
#line 35
  h->qh_info.dqi_max_i_limit = (uint64_t )(~ ((uint32_t )0));
#line 36
  h->qh_info.dqi_max_b_usage = (uint64_t )(4294967295U << 10);
#line 37
  h->qh_info.dqi_max_i_usage = (uint64_t )(~ ((uint32_t )0));
#line 38
  return (0);
}
}
#line 47 "/home/wheatley/newnew/temp/quota-4.01/quotaio_rpc.c"
static struct dquot *rpc_read_dquot___8(struct quota_handle *h , qid_t id___0 ) 
{ 
  struct dquot *dquot ;
  struct dquot *tmp ;
  int ret ;
  int *tmp___0 ;

  {
  {
#line 50
  tmp = get_empty_dquot();
#line 50
  dquot = tmp;
#line 53
  dquot->dq_id = id___0;
#line 54
  dquot->dq_h = h;
#line 55
  ret = rpc_rquota_get(dquot);
  }
#line 55
  if (ret < 0) {
    {
#line 56
    tmp___0 = __errno_location();
#line 56
    *tmp___0 = - ret;
#line 57
    free((void *)dquot);
    }
#line 58
    return ((struct dquot *)((void *)0));
  }
#line 60
  return (dquot);
}
}
#line 70 "/home/wheatley/newnew/temp/quota-4.01/quotaio_rpc.c"
static int rpc_commit_dquot___8(struct dquot *dquot , int flags___7 ) 
{ 
  int ret ;
  char *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;

  {
#line 75
  if ((dquot->dq_h)->qh_io_flags & 4) {
    {
#line 76
    tmp = gettext("Trying to write quota to readonly quotafile on %s\n");
#line 76
    errstr(tmp, (dquot->dq_h)->qh_quotadev);
#line 77
    tmp___0 = __errno_location();
#line 77
    *tmp___0 = 1;
    }
#line 78
    return (-1);
  }
  {
#line 80
  ret = rpc_rquota_set((1024 << 8) | ((dquot->dq_h)->qh_type & 255), dquot);
  }
#line 80
  if (ret < 0) {
    {
#line 81
    tmp___1 = __errno_location();
#line 81
    *tmp___1 = - ret;
    }
#line 82
    return (-1);
  }
#line 84
  return (0);
}
}
#line 45 "/home/wheatley/newnew/temp/quota-4.01/quotaio_tree.c"
static int get_index___8(qid_t id___0 , int depth ) 
{ 


  {
#line 47
  return ((int )((id___0 >> ((4 - depth) - 1) * 8) & 255U));
}
}
#line 51 "/home/wheatley/newnew/temp/quota-4.01/quotaio_tree.c"
static void read_blk___9(struct quota_handle *h , uint blk , dqbuf_t buf ) 
{ 
  int err ;
  ssize_t tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 55
  lseek(h->qh_fd, (__off64_t )(blk << 10), 0);
#line 56
  tmp = read(h->qh_fd, (void *)buf, (size_t )(1 << 10));
#line 56
  err = (int )tmp;
  }
#line 57
  if (err < 0) {
    {
#line 58
    tmp___0 = __errno_location();
#line 58
    tmp___1 = strerror(*tmp___0);
#line 58
    tmp___2 = gettext("Cannot read block %u: %s\n");
#line 58
    die(2, tmp___2, blk, tmp___1);
    }
  } else
#line 59
  if (err != 1 << 10) {
    {
#line 60
    memset((void *)(buf + err), 0, (size_t )((1 << 10) - err));
    }
  }
#line 61
  return;
}
}
#line 64 "/home/wheatley/newnew/temp/quota-4.01/quotaio_tree.c"
static int write_blk___8(struct quota_handle *h , uint blk , dqbuf_t buf ) 
{ 
  int err ;
  ssize_t tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  int *tmp___3 ;

  {
  {
#line 68
  lseek(h->qh_fd, (__off64_t )(blk << 10), 0);
#line 69
  tmp = write(h->qh_fd, (void const   *)buf, (size_t )(1 << 10));
#line 69
  err = (int )tmp;
  }
#line 70
  if (err < 0) {
    {
#line 70
    tmp___3 = __errno_location();
    }
#line 70
    if (*tmp___3 != 28) {
      {
#line 71
      tmp___0 = __errno_location();
#line 71
      tmp___1 = strerror(*tmp___0);
#line 71
      tmp___2 = gettext("Cannot write block (%u): %s\n");
#line 71
      die(2, tmp___2, blk, tmp___1);
      }
    }
  }
#line 72
  if (err != 1 << 10) {
#line 73
    return (-28);
  }
#line 74
  return (0);
}
}
#line 78 "/home/wheatley/newnew/temp/quota-4.01/quotaio_tree.c"
static int get_free_dqblk___8(struct quota_handle *h ) 
{ 
  dqbuf_t buf ;
  void *tmp ;
  struct qt_disk_dqdbheader *dh ;
  struct qtree_mem_dqinfo *info ;
  int blk ;
  char *tmp___0 ;
  int tmp___1 ;
  unsigned int tmp___2 ;

  {
  {
#line 80
  tmp = smalloc((size_t )(1 << 10));
#line 80
  buf = (dqbuf_t )tmp;
#line 81
  dh = (struct qt_disk_dqdbheader *)buf;
#line 82
  info = & h->qh_info.u.v2_mdqi.dqi_qtree;
  }
#line 85
  if (info->dqi_free_blk) {
    {
#line 86
    blk = (int )info->dqi_free_blk;
#line 87
    read_blk___9(h, (uint )blk, buf);
#line 88
    info->dqi_free_blk = dh->dqdh_next_free;
    }
  } else {
    {
#line 91
    memset((void *)buf, 0, (size_t )(1 << 10));
#line 92
    tmp___1 = write_blk___8(h, info->dqi_blocks, buf);
    }
#line 92
    if (tmp___1 < 0) {
      {
#line 93
      free((void *)buf);
#line 94
      tmp___0 = gettext("Cannot allocate new quota block (out of disk space).\n");
#line 94
      errstr(tmp___0);
      }
#line 95
      return (-28);
    }
#line 97
    tmp___2 = info->dqi_blocks;
#line 97
    (info->dqi_blocks) ++;
#line 97
    blk = (int )tmp___2;
  }
  {
#line 99
  mark_quotafile_info_dirty(h);
#line 100
  free((void *)buf);
  }
#line 101
  return (blk);
}
}
#line 105 "/home/wheatley/newnew/temp/quota-4.01/quotaio_tree.c"
static void put_free_dqblk___8(struct quota_handle *h , dqbuf_t buf , uint blk ) 
{ 
  struct qt_disk_dqdbheader *dh ;
  struct qtree_mem_dqinfo *info ;

  {
  {
#line 107
  dh = (struct qt_disk_dqdbheader *)buf;
#line 108
  info = & h->qh_info.u.v2_mdqi.dqi_qtree;
#line 110
  dh->dqdh_next_free = info->dqi_free_blk;
#line 111
  dh->dqdh_prev_free = (__u32 )0;
#line 112
  dh->dqdh_entries = (__u16 )0;
#line 113
  info->dqi_free_blk = blk;
#line 114
  mark_quotafile_info_dirty(h);
#line 115
  write_blk___8(h, blk, buf);
  }
#line 116
  return;
}
}
#line 119 "/home/wheatley/newnew/temp/quota-4.01/quotaio_tree.c"
static void remove_free_dqentry___8(struct quota_handle *h , dqbuf_t buf , uint blk ) 
{ 
  dqbuf_t tmpbuf ;
  void *tmp ;
  struct qt_disk_dqdbheader *dh ;
  uint nextblk ;
  uint prevblk ;
  u_int32_t tmp___0 ;

  {
  {
#line 121
  tmp = smalloc((size_t )(1 << 10));
#line 121
  tmpbuf = (dqbuf_t )tmp;
#line 122
  dh = (struct qt_disk_dqdbheader *)buf;
#line 123
  nextblk = dh->dqdh_next_free;
#line 123
  prevblk = dh->dqdh_prev_free;
  }
#line 127
  if (nextblk) {
    {
#line 128
    read_blk___9(h, nextblk, tmpbuf);
#line 129
    ((struct qt_disk_dqdbheader *)tmpbuf)->dqdh_prev_free = dh->dqdh_prev_free;
#line 130
    write_blk___8(h, nextblk, tmpbuf);
    }
  }
#line 132
  if (prevblk) {
    {
#line 133
    read_blk___9(h, prevblk, tmpbuf);
#line 134
    ((struct qt_disk_dqdbheader *)tmpbuf)->dqdh_next_free = dh->dqdh_next_free;
#line 135
    write_blk___8(h, prevblk, tmpbuf);
    }
  } else {
    {
#line 138
    h->qh_info.u.v2_mdqi.dqi_qtree.dqi_free_entry = nextblk;
#line 139
    mark_quotafile_info_dirty(h);
    }
  }
  {
#line 141
  free((void *)tmpbuf);
#line 142
  tmp___0 = (__u32 )0;
#line 142
  dh->dqdh_prev_free = tmp___0;
#line 142
  dh->dqdh_next_free = tmp___0;
#line 143
  write_blk___8(h, blk, buf);
  }
#line 144
  return;
}
}
#line 147 "/home/wheatley/newnew/temp/quota-4.01/quotaio_tree.c"
static void insert_free_dqentry___8(struct quota_handle *h , dqbuf_t buf , uint blk ) 
{ 
  dqbuf_t tmpbuf ;
  void *tmp ;
  struct qt_disk_dqdbheader *dh ;
  struct qtree_mem_dqinfo *info ;

  {
  {
#line 149
  tmp = smalloc((size_t )(1 << 10));
#line 149
  tmpbuf = (dqbuf_t )tmp;
#line 150
  dh = (struct qt_disk_dqdbheader *)buf;
#line 151
  info = & h->qh_info.u.v2_mdqi.dqi_qtree;
#line 153
  dh->dqdh_next_free = info->dqi_free_entry;
#line 154
  dh->dqdh_prev_free = (__u32 )0;
#line 155
  write_blk___8(h, blk, buf);
  }
#line 156
  if (info->dqi_free_entry) {
    {
#line 157
    read_blk___9(h, info->dqi_free_entry, tmpbuf);
#line 158
    ((struct qt_disk_dqdbheader *)tmpbuf)->dqdh_prev_free = blk;
#line 159
    write_blk___8(h, info->dqi_free_entry, tmpbuf);
    }
  }
  {
#line 161
  free((void *)tmpbuf);
#line 162
  info->dqi_free_entry = blk;
#line 163
  mark_quotafile_info_dirty(h);
  }
#line 164
  return;
}
}
#line 167 "/home/wheatley/newnew/temp/quota-4.01/quotaio_tree.c"
static uint find_free_dqentry___8(struct quota_handle *h , struct dquot *dquot , int *err ) 
{ 
  int blk ;
  int i ;
  struct qt_disk_dqdbheader *dh ;
  struct qtree_mem_dqinfo *info ;
  char *ddquot ;
  dqbuf_t buf ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;

  {
  {
#line 171
  info = & h->qh_info.u.v2_mdqi.dqi_qtree;
#line 175
  *err = 0;
#line 176
  tmp = smalloc((size_t )(1 << 10));
#line 176
  buf = (dqbuf_t )tmp;
#line 177
  dh = (struct qt_disk_dqdbheader *)buf;
  }
#line 178
  if (info->dqi_free_entry) {
    {
#line 179
    blk = (int )info->dqi_free_entry;
#line 180
    read_blk___9(h, (uint )blk, buf);
    }
  } else {
    {
#line 183
    blk = get_free_dqblk___8(h);
    }
#line 184
    if (blk < 0) {
      {
#line 185
      free((void *)buf);
#line 186
      *err = blk;
      }
#line 187
      return ((uint )0);
    }
    {
#line 189
    memset((void *)buf, 0, (size_t )(1 << 10));
#line 190
    info->dqi_free_entry = (unsigned int )blk;
#line 191
    mark_quotafile_info_dirty(h);
    }
  }
  {
#line 193
  tmp___0 = qtree_dqstr_in_blk(info);
  }
#line 193
  if ((int )dh->dqdh_entries + 1 >= tmp___0) {
    {
#line 194
    remove_free_dqentry___8(h, buf, (uint )blk);
    }
  }
#line 195
  dh->dqdh_entries = (__u16 )((int )dh->dqdh_entries + 1);
#line 197
  ddquot = buf + sizeof(struct qt_disk_dqdbheader );
#line 198
  i = 0;
  {
#line 198
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 198
    tmp___1 = qtree_dqstr_in_blk(info);
    }
#line 198
    if (i < tmp___1) {
      {
#line 198
      tmp___2 = qtree_entry_unused(info, ddquot);
      }
#line 198
      if (tmp___2) {
#line 198
        goto while_break;
      }
    } else {
#line 198
      goto while_break;
    }
#line 198
    i ++;
#line 198
    ddquot += info->dqi_entry_size;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 201
  tmp___4 = qtree_dqstr_in_blk(info);
  }
#line 201
  if (i == tmp___4) {
    {
#line 202
    tmp___3 = gettext("find_free_dqentry(): Data block full but it shouldn\'t.\n");
#line 202
    die(2, tmp___3);
    }
  }
  {
#line 203
  write_blk___8(h, (uint )blk, buf);
#line 204
  dquot->dq_dqb.u.v2_mdqb.dqb_off = (loff_t )(((unsigned long )(blk << 10) + sizeof(struct qt_disk_dqdbheader )) + (unsigned long )((unsigned int )i * info->dqi_entry_size));
#line 207
  free((void *)buf);
  }
#line 208
  return ((uint )blk);
}
}
#line 212 "/home/wheatley/newnew/temp/quota-4.01/quotaio_tree.c"
static int do_insert_tree___8(struct quota_handle *h , struct dquot *dquot , uint *treeblk ,
                              int depth ) 
{ 
  dqbuf_t buf ;
  int newson ;
  int newact ;
  u_int32_t *ref ;
  uint newblk ;
  int ret ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;

  {
  {
#line 215
  newson = 0;
#line 215
  newact = 0;
#line 218
  ret = 0;
#line 220
  tmp = smalloc((size_t )(1 << 10));
#line 220
  buf = (dqbuf_t )tmp;
  }
#line 221
  if (! *treeblk) {
    {
#line 222
    ret = get_free_dqblk___8(h);
    }
#line 223
    if (ret < 0) {
#line 224
      goto out_buf;
    }
    {
#line 225
    *treeblk = (uint )ret;
#line 226
    memset((void *)buf, 0, (size_t )(1 << 10));
#line 227
    newact = 1;
    }
  } else {
    {
#line 230
    read_blk___9(h, *treeblk, buf);
    }
  }
  {
#line 231
  ref = (u_int32_t *)buf;
#line 232
  tmp___0 = get_index___8(dquot->dq_id, depth);
#line 232
  newblk = *(ref + tmp___0);
  }
#line 233
  if (! newblk) {
#line 234
    newson = 1;
  }
#line 235
  if (depth == 3) {
#line 236
    if (newblk) {
      {
#line 237
      tmp___1 = get_index___8(dquot->dq_id, depth);
#line 237
      tmp___2 = gettext("Inserting already present quota entry (block %u).\n");
#line 237
      die(2, tmp___2, *(ref + tmp___1));
      }
    }
    {
#line 239
    newblk = find_free_dqentry___8(h, dquot, & ret);
    }
  } else {
    {
#line 242
    ret = do_insert_tree___8(h, dquot, & newblk, depth + 1);
    }
  }
#line 243
  if (newson) {
#line 243
    if (ret >= 0) {
      {
#line 244
      tmp___3 = get_index___8(dquot->dq_id, depth);
#line 244
      *(ref + tmp___3) = newblk;
#line 245
      write_blk___8(h, *treeblk, buf);
      }
    } else {
#line 243
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 247
  if (newact) {
#line 247
    if (ret < 0) {
      {
#line 248
      put_free_dqblk___8(h, buf, *treeblk);
      }
    }
  }
  out_buf: 
  {
#line 250
  free((void *)buf);
  }
#line 251
  return (ret);
}
}
#line 255 "/home/wheatley/newnew/temp/quota-4.01/quotaio_tree.c"
static void dq_insert_tree___8(struct quota_handle *h , struct dquot *dquot ) 
{ 
  uint tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;

  {
  {
#line 257
  tmp = (uint )1;
#line 259
  tmp___3 = do_insert_tree___8(h, dquot, & tmp, 0);
  }
#line 259
  if (tmp___3 < 0) {
    {
#line 260
    tmp___0 = __errno_location();
#line 260
    tmp___1 = strerror(*tmp___0);
#line 260
    tmp___2 = gettext("Cannot write quota (id %u): %s\n");
#line 260
    die(2, tmp___2, dquot->dq_id, tmp___1);
    }
  }
#line 261
  return;
}
}
#line 284 "/home/wheatley/newnew/temp/quota-4.01/quotaio_tree.c"
static void free_dqentry___8(struct quota_handle *h , struct dquot *dquot , uint blk ) 
{ 
  struct qt_disk_dqdbheader *dh ;
  struct qtree_mem_dqinfo *info ;
  dqbuf_t buf ;
  void *tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 287
  info = & h->qh_info.u.v2_mdqi.dqi_qtree;
#line 288
  tmp = smalloc((size_t )(1 << 10));
#line 288
  buf = (dqbuf_t )tmp;
  }
#line 290
  if (dquot->dq_dqb.u.v2_mdqb.dqb_off >> 10 != (loff_t )blk) {
    {
#line 291
    tmp___0 = gettext("Quota structure has offset to other block (%u) than it should (%u).\n");
#line 291
    die(2, tmp___0, blk, (uint )(dquot->dq_dqb.u.v2_mdqb.dqb_off >> 10));
    }
  }
  {
#line 293
  read_blk___9(h, blk, buf);
#line 294
  dh = (struct qt_disk_dqdbheader *)buf;
#line 295
  dh->dqdh_entries = (__u16 )((int )dh->dqdh_entries - 1);
  }
#line 296
  if (! dh->dqdh_entries) {
    {
#line 297
    remove_free_dqentry___8(h, buf, blk);
#line 298
    put_free_dqblk___8(h, buf, blk);
    }
  } else {
    {
#line 301
    memset((void *)(buf + (dquot->dq_dqb.u.v2_mdqb.dqb_off & (long )((1 << 10) - 1))),
           0, (size_t )info->dqi_entry_size);
#line 304
    tmp___1 = qtree_dqstr_in_blk(info);
    }
#line 304
    if ((int )dh->dqdh_entries == tmp___1 - 1) {
      {
#line 305
      insert_free_dqentry___8(h, buf, blk);
      }
    } else {
      {
#line 307
      write_blk___8(h, blk, buf);
      }
    }
  }
  {
#line 309
  dquot->dq_dqb.u.v2_mdqb.dqb_off = (loff_t )0;
#line 310
  free((void *)buf);
  }
#line 311
  return;
}
}
#line 314 "/home/wheatley/newnew/temp/quota-4.01/quotaio_tree.c"
static void remove_tree___8(struct quota_handle *h , struct dquot *dquot , uint *blk ,
                            int depth ) 
{ 
  dqbuf_t buf ;
  void *tmp ;
  uint newblk ;
  u_int32_t *ref ;
  int tmp___0 ;
  int i ;
  int tmp___1 ;

  {
  {
#line 316
  tmp = smalloc((size_t )(1 << 10));
#line 316
  buf = (dqbuf_t )tmp;
#line 318
  ref = (u_int32_t *)buf;
#line 320
  read_blk___9(h, *blk, buf);
#line 321
  tmp___0 = get_index___8(dquot->dq_id, depth);
#line 321
  newblk = *(ref + tmp___0);
  }
#line 322
  if (depth == 3) {
    {
#line 323
    free_dqentry___8(h, dquot, newblk);
#line 324
    newblk = (uint )0;
    }
  } else {
    {
#line 327
    remove_tree___8(h, dquot, & newblk, depth + 1);
    }
  }
#line 328
  if (! newblk) {
    {
#line 331
    tmp___1 = get_index___8(dquot->dq_id, depth);
#line 331
    *(ref + tmp___1) = (__u32 )0;
#line 332
    i = 0;
    }
    {
#line 332
    while (1) {
      while_continue: /* CIL Label */ ;
#line 332
      if (i < 1 << 10) {
#line 332
        if (! (! *(buf + i))) {
#line 332
          goto while_break;
        }
      } else {
#line 332
        goto while_break;
      }
#line 332
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 334
    if (i == 1 << 10) {
#line 334
      if (*blk != 1U) {
        {
#line 335
        put_free_dqblk___8(h, buf, *blk);
#line 336
        *blk = (uint )0;
        }
      } else {
        {
#line 339
        write_blk___8(h, *blk, buf);
        }
      }
    } else {
      {
#line 339
      write_blk___8(h, *blk, buf);
      }
    }
  }
  {
#line 341
  free((void *)buf);
  }
#line 342
  return;
}
}
#line 355 "/home/wheatley/newnew/temp/quota-4.01/quotaio_tree.c"
static loff_t find_block_dqentry___8(struct quota_handle *h , struct dquot *dquot ,
                                     uint blk ) 
{ 
  struct qtree_mem_dqinfo *info ;
  dqbuf_t buf ;
  void *tmp ;
  int i ;
  char *ddquot ;
  int tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;

  {
  {
#line 357
  info = & h->qh_info.u.v2_mdqi.dqi_qtree;
#line 358
  tmp = smalloc((size_t )(1 << 10));
#line 358
  buf = (dqbuf_t )tmp;
#line 360
  ddquot = buf + sizeof(struct qt_disk_dqdbheader );
#line 362
  read_blk___9(h, blk, buf);
#line 363
  i = 0;
  }
  {
#line 363
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 363
    tmp___0 = qtree_dqstr_in_blk(info);
    }
#line 363
    if (i < tmp___0) {
      {
#line 363
      tmp___1 = (*((info->dqi_ops)->is_id))((void *)ddquot, dquot);
      }
#line 363
      if (tmp___1) {
#line 363
        goto while_break;
      }
    } else {
#line 363
      goto while_break;
    }
#line 363
    i ++;
#line 363
    ddquot += info->dqi_entry_size;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 366
  tmp___3 = qtree_dqstr_in_blk(info);
  }
#line 366
  if (i == tmp___3) {
    {
#line 367
    tmp___2 = gettext("Quota for id %u referenced but not present.\n");
#line 367
    die(2, tmp___2, dquot->dq_id);
    }
  }
  {
#line 368
  free((void *)buf);
  }
#line 369
  return ((loff_t )(((unsigned long )(blk << 10) + sizeof(struct qt_disk_dqdbheader )) + (unsigned long )((unsigned int )i * info->dqi_entry_size)));
}
}
#line 374 "/home/wheatley/newnew/temp/quota-4.01/quotaio_tree.c"
static loff_t find_tree_dqentry___8(struct quota_handle *h , struct dquot *dquot ,
                                    uint blk , int depth ) 
{ 
  dqbuf_t buf ;
  void *tmp ;
  loff_t ret ;
  u_int32_t *ref ;
  int tmp___0 ;

  {
  {
#line 376
  tmp = smalloc((size_t )(1 << 10));
#line 376
  buf = (dqbuf_t )tmp;
#line 377
  ret = (loff_t )0;
#line 378
  ref = (u_int32_t *)buf;
#line 380
  read_blk___9(h, blk, buf);
#line 381
  ret = (loff_t )0;
#line 382
  tmp___0 = get_index___8(dquot->dq_id, depth);
#line 382
  blk = *(ref + tmp___0);
  }
#line 383
  if (! blk) {
#line 384
    goto out_buf;
  }
#line 385
  if (depth < 3) {
    {
#line 386
    ret = find_tree_dqentry___8(h, dquot, blk, depth + 1);
    }
  } else {
    {
#line 388
    ret = find_block_dqentry___8(h, dquot, blk);
    }
  }
  out_buf: 
  {
#line 390
  free((void *)buf);
  }
#line 391
  return (ret);
}
}
#line 395 "/home/wheatley/newnew/temp/quota-4.01/quotaio_tree.c"
__inline static loff_t find_dqentry___8(struct quota_handle *h , struct dquot *dquot ) 
{ 
  loff_t tmp ;

  {
  {
#line 397
  tmp = find_tree_dqentry___8(h, dquot, (uint )1, 0);
  }
#line 397
  return (tmp);
}
}
#line 441 "/home/wheatley/newnew/temp/quota-4.01/quotaio_tree.c"
static int report_block___8(struct dquot *dquot , uint blk , char *bitmap , int (*process_dquot)(struct dquot * ,
                                                                                                 char * ) ) 
{ 
  struct qtree_mem_dqinfo *info ;
  dqbuf_t buf ;
  void *tmp ;
  struct qt_disk_dqdbheader *dh ;
  char *ddata ;
  int entries ;
  int i ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 444
  info = & (dquot->dq_h)->qh_info.u.v2_mdqi.dqi_qtree;
#line 445
  tmp = smalloc((size_t )(1 << 10));
#line 445
  buf = (dqbuf_t )tmp;
#line 450
  *(bitmap + (blk >> 3)) = (char )((int )*(bitmap + (blk >> 3)) | (1 << (blk & 7U)));
#line 451
  read_blk___9(dquot->dq_h, blk, buf);
#line 452
  dh = (struct qt_disk_dqdbheader *)buf;
#line 453
  ddata = buf + sizeof(struct qt_disk_dqdbheader );
#line 454
  entries = (int )dh->dqdh_entries;
#line 455
  i = 0;
  }
  {
#line 455
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 455
    tmp___2 = qtree_dqstr_in_blk(info);
    }
#line 455
    if (! (i < tmp___2)) {
#line 455
      goto while_break;
    }
    {
#line 456
    tmp___1 = qtree_entry_unused(info, ddata);
    }
#line 456
    if (! tmp___1) {
      {
#line 457
      (*((info->dqi_ops)->disk2mem_dqblk))(dquot, (void *)ddata);
#line 458
      tmp___0 = (*process_dquot)(dquot, (char *)((void *)0));
      }
#line 458
      if (tmp___0 < 0) {
#line 459
        goto while_break;
      }
    }
#line 455
    i ++;
#line 455
    ddata += info->dqi_entry_size;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 461
  free((void *)buf);
  }
#line 462
  return (entries);
}
}
#line 465 "/home/wheatley/newnew/temp/quota-4.01/quotaio_tree.c"
static void check_reference___8(struct quota_handle *h , uint blk ) 
{ 
  char *tmp ;
  char *tmp___0 ;

  {
#line 467
  if (blk >= h->qh_info.u.v2_mdqi.dqi_qtree.dqi_blocks) {
    {
#line 468
    tmp = type2name(h->qh_type);
#line 468
    tmp___0 = gettext("Illegal reference (%u >= %u) in %s quota file on %s. Quota file is probably corrupted.\nPlease run quotacheck(8) and try again.\n");
#line 468
    die(2, tmp___0, blk, h->qh_info.u.v2_mdqi.dqi_qtree.dqi_blocks, tmp, h->qh_quotadev);
    }
  }
#line 469
  return;
}
}
#line 471 "/home/wheatley/newnew/temp/quota-4.01/quotaio_tree.c"
static int report_tree___8(struct dquot *dquot , uint blk , int depth , char *bitmap ,
                           int (*process_dquot)(struct dquot * , char * ) ) 
{ 
  int entries ;
  int i ;
  dqbuf_t buf ;
  void *tmp ;
  u_int32_t *ref ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 474
  entries = 0;
#line 475
  tmp = smalloc((size_t )(1 << 10));
#line 475
  buf = (dqbuf_t )tmp;
#line 476
  ref = (u_int32_t *)buf;
#line 478
  read_blk___9(dquot->dq_h, blk, buf);
  }
#line 479
  if (depth == 3) {
#line 480
    i = 0;
    {
#line 480
    while (1) {
      while_continue: /* CIL Label */ ;
#line 480
      if (! (i < (1 << 10) >> 2)) {
#line 480
        goto while_break;
      }
      {
#line 481
      blk = *(ref + i);
#line 482
      check_reference___8(dquot->dq_h, blk);
      }
#line 483
      if (blk) {
#line 483
        if (! ((int )*(bitmap + (blk >> 3)) & (1 << (blk & 7U)))) {
          {
#line 484
          tmp___0 = report_block___8(dquot, blk, bitmap, process_dquot);
#line 484
          entries += tmp___0;
          }
        }
      }
#line 480
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 488
    i = 0;
    {
#line 488
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 488
      if (! (i < (1 << 10) >> 2)) {
#line 488
        goto while_break___0;
      }
#line 489
      blk = *(ref + i);
#line 489
      if (blk) {
        {
#line 490
        check_reference___8(dquot->dq_h, blk);
#line 491
        tmp___1 = report_tree___8(dquot, blk, depth + 1, bitmap, process_dquot);
#line 491
        entries += tmp___1;
        }
      }
#line 488
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  {
#line 495
  free((void *)buf);
  }
#line 496
  return (entries);
}
}
#line 499 "/home/wheatley/newnew/temp/quota-4.01/quotaio_tree.c"
static uint find_set_bits___8(char *bmp , int blocks ) 
{ 
  uint i ;
  uint used ;

  {
#line 501
  used = (uint )0;
#line 503
  i = (uint )0;
  {
#line 503
  while (1) {
    while_continue: /* CIL Label */ ;
#line 503
    if (! (i < (uint )blocks)) {
#line 503
      goto while_break;
    }
#line 504
    if ((int )*(bmp + (i >> 3)) & (1 << (i & 7U))) {
#line 505
      used ++;
    }
#line 503
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 506
  return (used);
}
}
#line 281 "/home/wheatley/newnew/temp/quota-4.01/quotaops.c"
static void merge_limits_to_list___2(struct dquot *qlist , char *dev , u_int64_t blocks ,
                                     u_int64_t bsoft , u_int64_t bhard , u_int64_t inodes ,
                                     u_int64_t isoft , u_int64_t ihard ) 
{ 
  struct dquot *q ;
  int tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
#line 286
  q = qlist;
  {
#line 286
  while (1) {
    while_continue: /* CIL Label */ ;
#line 286
    if (! q) {
#line 286
      goto while_break;
    }
    {
#line 287
    tmp = devcmp_handle((char const   *)dev, q->dq_h);
    }
#line 287
    if (! tmp) {
#line 288
      goto __Cont;
    }
    {
#line 290
    q->dq_dqb.dqb_bsoftlimit = (qsize_t )bsoft;
#line 291
    q->dq_dqb.dqb_bhardlimit = (qsize_t )bhard;
#line 292
    q->dq_dqb.dqb_isoftlimit = (qsize_t )isoft;
#line 293
    q->dq_dqb.dqb_ihardlimit = (qsize_t )ihard;
#line 294
    q->dq_flags |= 1;
#line 295
    update_grace_times(q);
    }
#line 297
    if (blocks != (u_int64_t )(((q->dq_dqb.dqb_curspace + (qsize_t )(1 << 10)) - 1L) >> 10)) {
      {
#line 298
      tmp___0 = gettext("WARNING - %s: cannot change current block allocation\n");
#line 298
      errstr(tmp___0, (q->dq_h)->qh_quotadev);
      }
    }
#line 300
    if (inodes != (u_int64_t )q->dq_dqb.dqb_curinodes) {
      {
#line 301
      tmp___1 = gettext("WARNING - %s: cannot change current inode allocation\n");
#line 301
      errstr(tmp___1, (q->dq_h)->qh_quotadev);
      }
    }
    __Cont: /* CIL Label */ 
#line 286
    q = q->dq_next;
  }
  while_break: /* CIL Label */ ;
  }
#line 304
  return;
}
}
#line 357 "/home/wheatley/newnew/temp/quota-4.01/quotaops.c"
static void merge_times_to_list___2(struct dquot *qlist , char *dev , time_t btime ,
                                    time_t itime ) 
{ 
  struct dquot *q ;
  int tmp ;

  {
#line 361
  q = qlist;
  {
#line 361
  while (1) {
    while_continue: /* CIL Label */ ;
#line 361
    if (! q) {
#line 361
      goto while_break;
    }
    {
#line 362
    tmp = devcmp_handle((char const   *)dev, q->dq_h);
    }
#line 362
    if (! tmp) {
#line 363
      goto __Cont;
    }
#line 365
    q->dq_dqb.dqb_btime = btime;
#line 366
    q->dq_dqb.dqb_itime = itime;
#line 367
    q->dq_flags |= 1;
    __Cont: /* CIL Label */ 
#line 361
    q = q->dq_next;
  }
  while_break: /* CIL Label */ ;
  }
#line 369
  return;
}
}
#line 10 "/home/wheatley/newnew/temp/quota-4.01/rquota_clnt.c"
static struct timeval TIMEOUT___8  =    {(__time_t )25, (__suseconds_t )0};
#line 15 "/home/wheatley/newnew/temp/quota-4.01/rquota_clnt.c"
static getquota_rslt clnt_res___71  ;
#line 30 "/home/wheatley/newnew/temp/quota-4.01/rquota_clnt.c"
static getquota_rslt clnt_res___72  ;
#line 45 "/home/wheatley/newnew/temp/quota-4.01/rquota_clnt.c"
static setquota_rslt clnt_res___73  ;
#line 60 "/home/wheatley/newnew/temp/quota-4.01/rquota_clnt.c"
static setquota_rslt clnt_res___74  ;
#line 75 "/home/wheatley/newnew/temp/quota-4.01/rquota_clnt.c"
static getquota_rslt clnt_res___75  ;
#line 90 "/home/wheatley/newnew/temp/quota-4.01/rquota_clnt.c"
static getquota_rslt clnt_res___76  ;
#line 105 "/home/wheatley/newnew/temp/quota-4.01/rquota_clnt.c"
static setquota_rslt clnt_res___77  ;
#line 120 "/home/wheatley/newnew/temp/quota-4.01/rquota_clnt.c"
static setquota_rslt clnt_res___78  ;
#line 19 "/home/wheatley/newnew/temp/quota-4.01/quotaio_meta.c"
static int meta_init_io___9(struct quota_handle *h ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
#line 21
  if (! (h->qh_io_flags & 1)) {
    {
#line 22
    tmp = gettext("Metadata init_io called when kernel support is not enabled.\n");
#line 22
    errstr(tmp);
    }
#line 23
    return (-1);
  }
#line 25
  if (kernel_iface != 3) {
    {
#line 26
    tmp___0 = gettext("Metadata init_io called when kernel does not support generic quota interface!\n");
#line 26
    errstr(tmp___0);
    }
#line 27
    return (-1);
  }
  {
#line 29
  tmp___1 = vfs_get_info(h);
  }
#line 29
  return (tmp___1);
}
}
#line 32 "/home/wheatley/newnew/temp/quota-4.01/quotaio_meta.c"
static int meta_write_info___9(struct quota_handle *h ) 
{ 
  int tmp ;

  {
  {
#line 34
  tmp = vfs_set_info(h, 3);
  }
#line 34
  return (tmp);
}
}
#line 37 "/home/wheatley/newnew/temp/quota-4.01/quotaio_meta.c"
static struct dquot *meta_read_dquot___9(struct quota_handle *h , qid_t id___0 ) 
{ 
  struct dquot *dquot ;
  struct dquot *tmp ;
  int tmp___0 ;

  {
  {
#line 39
  tmp = get_empty_dquot();
#line 39
  dquot = tmp;
#line 41
  dquot->dq_id = id___0;
#line 42
  dquot->dq_h = h;
#line 43
  memset((void *)(& dquot->dq_dqb), 0, sizeof(struct util_dqblk ));
#line 44
  tmp___0 = vfs_get_dquot(dquot);
  }
#line 44
  if (tmp___0 < 0) {
    {
#line 45
    free((void *)dquot);
    }
#line 46
    return ((struct dquot *)((void *)0));
  }
#line 48
  return (dquot);
}
}
#line 51 "/home/wheatley/newnew/temp/quota-4.01/quotaio_meta.c"
static int meta_commit_dquot___9(struct dquot *dquot , int flags___7 ) 
{ 
  int tmp ;

  {
  {
#line 53
  tmp = vfs_set_dquot(dquot, flags___7);
  }
#line 53
  return (tmp);
}
}
#line 56 "/home/wheatley/newnew/temp/quota-4.01/quotaio_meta.c"
static int meta_scan_dquots___9(struct quota_handle *h , int (*process_dquot)(struct dquot *dquot ,
                                                                              char *dqname ) ) 
{ 
  int tmp ;

  {
  {
#line 58
  tmp = generic_scan_dquots(h, process_dquot, & vfs_get_dquot);
  }
#line 58
  return (tmp);
}
}
#line 27 "/home/wheatley/newnew/temp/quota-4.01/quotaio_xfs.c"
static int xfs_init_io___9(struct quota_handle *h ) ;
#line 28
static int xfs_write_info___9(struct quota_handle *h ) ;
#line 29
static struct dquot *xfs_read_dquot___9(struct quota_handle *h , qid_t id___0 ) ;
#line 30
static int xfs_commit_dquot___9(struct dquot *dquot , int flags___7 ) ;
#line 31
static int xfs_scan_dquots___9(struct quota_handle *h , int (*process_dquot)(struct dquot *dquot ,
                                                                             char *dqname ) ) ;
#line 32
static int xfs_report___9(struct quota_handle *h , int verbose ) ;
#line 77 "/home/wheatley/newnew/temp/quota-4.01/quotaio_xfs.c"
static int xfs_init_io___9(struct quota_handle *h ) 
{ 
  struct fs_quota_stat info ;
  int qcmd ;
  long tmp ;

  {
  {
#line 82
  qcmd = ((88 << 8) + 5) << 8;
#line 83
  memset((void *)(& info), 0, sizeof(struct fs_quota_stat ));
#line 84
  tmp = quotactl(qcmd, (char const   *)(h->qh_quotadev), (qid_t )0, (caddr_t )((void *)(& info)));
  }
#line 84
  if (tmp < 0L) {
#line 85
    return (-1);
  }
#line 86
  h->qh_info.dqi_bgrace = (time_t )info.qs_btimelimit;
#line 87
  h->qh_info.dqi_igrace = (time_t )info.qs_itimelimit;
#line 88
  h->qh_info.u.xfs_mdqi = info;
#line 89
  return (0);
}
}
#line 95 "/home/wheatley/newnew/temp/quota-4.01/quotaio_xfs.c"
static int xfs_write_info___9(struct quota_handle *h ) 
{ 
  struct fs_disk_quota xdqblk ;
  int qcmd ;
  long tmp ;

  {
#line 100
  if (h->qh_type == 0) {
#line 100
    if (! ((int )h->qh_info.u.xfs_mdqi.qs_flags & 1)) {
#line 100
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 100
  if (h->qh_type == 1) {
#line 100
    if (! ((int )h->qh_info.u.xfs_mdqi.qs_flags & (1 << 2))) {
#line 101
      return (0);
    }
  } else {
#line 101
    return (0);
  }
  {
#line 103
  memset((void *)(& xdqblk), 0, sizeof(struct fs_disk_quota ));
#line 105
  xdqblk.d_btimer = (__s32 )h->qh_info.dqi_bgrace;
#line 106
  xdqblk.d_itimer = (__s32 )h->qh_info.dqi_igrace;
#line 107
  xdqblk.d_fieldmask = (__u16 )((int )xdqblk.d_fieldmask | (((1 << 6) | (1 << 7)) | (1 << 8)));
#line 108
  qcmd = (((88 << 8) + 4) << 8) | (h->qh_type & 255);
#line 109
  tmp = quotactl(qcmd, (char const   *)(h->qh_quotadev), (qid_t )0, (caddr_t )((void *)(& xdqblk)));
  }
#line 109
  if (tmp < 0L) {
#line 110
    return (-1);
  }
#line 111
  return (0);
}
}
#line 117 "/home/wheatley/newnew/temp/quota-4.01/quotaio_xfs.c"
static struct dquot *xfs_read_dquot___9(struct quota_handle *h , qid_t id___0 ) 
{ 
  struct dquot *dquot ;
  struct dquot *tmp ;
  struct fs_disk_quota xdqblk ;
  int qcmd ;
  long tmp___0 ;

  {
  {
#line 119
  tmp = get_empty_dquot();
#line 119
  dquot = tmp;
#line 123
  dquot->dq_id = id___0;
#line 124
  dquot->dq_h = h;
  }
#line 126
  if (h->qh_type == 0) {
#line 126
    if (! ((int )h->qh_info.u.xfs_mdqi.qs_flags & 1)) {
#line 126
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 126
  if (h->qh_type == 1) {
#line 126
    if (! ((int )h->qh_info.u.xfs_mdqi.qs_flags & (1 << 2))) {
#line 127
      return (dquot);
    }
  } else {
#line 127
    return (dquot);
  }
  {
#line 129
  qcmd = (((88 << 8) + 3) << 8) | (h->qh_type & 255);
#line 130
  tmp___0 = quotactl(qcmd, (char const   *)(h->qh_quotadev), id___0, (caddr_t )((void *)(& xdqblk)));
  }
#line 130
  if (! (tmp___0 < 0L)) {
    {
#line 134
    xfs_kern2utildqblk(& dquot->dq_dqb, & xdqblk);
    }
  }
#line 136
  return (dquot);
}
}
#line 142 "/home/wheatley/newnew/temp/quota-4.01/quotaio_xfs.c"
static int xfs_commit_dquot___9(struct dquot *dquot , int flags___7 ) 
{ 
  struct quota_handle *h ;
  struct fs_disk_quota xdqblk ;
  qid_t id___0 ;
  int qcmd ;
  int tmp ;
  int tmp___0 ;
  long tmp___1 ;

  {
#line 144
  h = dquot->dq_h;
#line 146
  id___0 = dquot->dq_id;
#line 149
  if (h->qh_type == 0) {
#line 149
    if (! ((int )h->qh_info.u.xfs_mdqi.qs_flags & 1)) {
#line 149
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 149
  if (h->qh_type == 1) {
#line 149
    if (! ((int )h->qh_info.u.xfs_mdqi.qs_flags & (1 << 2))) {
#line 150
      return (0);
    }
  } else {
#line 150
    return (0);
  }
  {
#line 152
  xfs_util2kerndqblk(& xdqblk, & dquot->dq_dqb);
  }
#line 153
  if (h->qh_type == 0) {
#line 153
    if ((int )h->qh_info.u.xfs_mdqi.qs_flags & 1) {
#line 153
      tmp = 1;
    } else {
#line 153
      tmp = 1 << 2;
    }
  } else {
#line 153
    tmp = 1 << 2;
  }
  {
#line 153
  xdqblk.d_flags = (__s8 )((int )xdqblk.d_flags | tmp);
#line 154
  xdqblk.d_id = id___0;
#line 155
  tmp___0 = strcmp((char const   *)(h->qh_fstype), "gfs2");
  }
#line 155
  if (tmp___0 == 0) {
#line 156
    if (flags___7 & 5) {
#line 157
      xdqblk.d_fieldmask = (__u16 )((int )xdqblk.d_fieldmask | ((1 << 2) | (1 << 3)));
    }
#line 158
    if (flags___7 & 10) {
#line 159
      xdqblk.d_fieldmask = (__u16 )((int )xdqblk.d_fieldmask | (1 << 12));
    }
  } else {
#line 161
    xdqblk.d_fieldmask = (__u16 )((int )xdqblk.d_fieldmask | (((((1 | (1 << 1)) | (1 << 2)) | (1 << 3)) | (1 << 4)) | (1 << 5)));
  }
  {
#line 164
  qcmd = (((88 << 8) + 4) << 8) | (h->qh_type & 255);
#line 165
  tmp___1 = quotactl(qcmd, (char const   *)(h->qh_quotadev), id___0, (caddr_t )((void *)(& xdqblk)));
  }
#line 165
  if (! (tmp___1 < 0L)) {
#line 169
    return (0);
  }
#line 171
  return (-1);
}
}
#line 177 "/home/wheatley/newnew/temp/quota-4.01/quotaio_xfs.c"
static int xfs_get_dquot___9(struct dquot *dq ) 
{ 
  struct fs_disk_quota d ;
  int qcmd ;
  int ret ;
  long tmp ;
  int *tmp___0 ;

  {
  {
#line 180
  qcmd = (((88 << 8) + 3) << 8) | ((dq->dq_h)->qh_type & 255);
#line 183
  memset((void *)(& d), 0, sizeof(d));
#line 184
  tmp = quotactl(qcmd, (char const   *)((dq->dq_h)->qh_quotadev), dq->dq_id, (caddr_t )((void *)(& d)));
#line 184
  ret = (int )tmp;
  }
#line 185
  if (ret < 0) {
    {
#line 186
    tmp___0 = __errno_location();
    }
#line 186
    if (*tmp___0 == 2) {
#line 187
      return (0);
    }
#line 188
    return (-1);
  }
  {
#line 190
  xfs_kern2utildqblk(& dq->dq_dqb, & d);
  }
#line 191
  return (0);
}
}
#line 197 "/home/wheatley/newnew/temp/quota-4.01/quotaio_xfs.c"
static int xfs_scan_dquots___9(struct quota_handle *h , int (*process_dquot)(struct dquot *dquot ,
                                                                             char *dqname ) ) 
{ 
  int tmp ;

  {
#line 199
  if (h->qh_type == 0) {
#line 199
    if (! ((int )h->qh_info.u.xfs_mdqi.qs_flags & 1)) {
#line 199
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 199
  if (h->qh_type == 1) {
#line 199
    if (! ((int )h->qh_info.u.xfs_mdqi.qs_flags & (1 << 2))) {
#line 200
      return (0);
    }
  } else {
#line 200
    return (0);
  }
  {
#line 202
  tmp = generic_scan_dquots(h, process_dquot, & xfs_get_dquot___9);
  }
#line 202
  return (tmp);
}
}
#line 208 "/home/wheatley/newnew/temp/quota-4.01/quotaio_xfs.c"
static int xfs_report___9(struct quota_handle *h , int verbose ) 
{ 
  u_int16_t sbflags ;
  struct fs_quota_stat *info ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;
  char *tmp___18 ;
  char *tmp___19 ;
  char *tmp___20 ;
  char *tmp___21 ;
  char *tmp___22 ;
  char *tmp___23 ;
  char *tmp___24 ;
  char *tmp___25 ;
  char *tmp___26 ;
  char *tmp___27 ;
  char *tmp___28 ;
  char *tmp___29 ;
  char *tmp___30 ;
  char *tmp___31 ;
  char *tmp___32 ;

  {
#line 211
  info = & h->qh_info.u.xfs_mdqi;
#line 213
  if (! verbose) {
#line 214
    return (0);
  }
  {
#line 217
  tmp = type2name(h->qh_type);
#line 217
  tmp___0 = gettext("*** Status for %s quotas on device %s\n");
#line 217
  printf((char const   */* __restrict  */)tmp___0, tmp, h->qh_quotadev);
  }
#line 220
  if (h->qh_type == 0) {
#line 221
    if ((int )info->qs_flags & (1 << 1)) {
      {
#line 221
      tmp___1 = gettext("ON");
#line 221
      tmp___3 = tmp___1;
      }
    } else {
      {
#line 221
      tmp___2 = gettext("OFF");
#line 221
      tmp___3 = tmp___2;
      }
    }
#line 221
    if ((int )info->qs_flags & 1) {
      {
#line 221
      tmp___4 = gettext("ON");
#line 221
      tmp___6 = tmp___4;
      }
    } else {
      {
#line 221
      tmp___5 = gettext("OFF");
#line 221
      tmp___6 = tmp___5;
      }
    }
    {
#line 221
    tmp___7 = gettext("Accounting: %s; Enforcement: %s\n");
#line 221
    printf((char const   */* __restrict  */)tmp___7, tmp___6, tmp___3);
    }
  } else {
#line 225
    if ((int )info->qs_flags & (1 << 3)) {
      {
#line 225
      tmp___8 = gettext("ON");
#line 225
      tmp___10 = tmp___8;
      }
    } else {
      {
#line 225
      tmp___9 = gettext("OFF");
#line 225
      tmp___10 = tmp___9;
      }
    }
#line 225
    if ((int )info->qs_flags & (1 << 2)) {
      {
#line 225
      tmp___11 = gettext("ON");
#line 225
      tmp___13 = tmp___11;
      }
    } else {
      {
#line 225
      tmp___12 = gettext("OFF");
#line 225
      tmp___13 = tmp___12;
      }
    }
    {
#line 225
    tmp___14 = gettext("Accounting: %s; Enforcement: %s\n");
#line 225
    printf((char const   */* __restrict  */)tmp___14, tmp___13, tmp___10);
    }
  }
#line 235
  sbflags = (u_int16_t )(((int )info->qs_flags & 65280) >> 8);
#line 235
  if ((int )sbflags != 0) {
#line 236
    if (h->qh_type == 0) {
#line 237
      if ((int )sbflags & (1 << 1)) {
        {
#line 237
        tmp___15 = gettext("ON");
#line 237
        tmp___17 = tmp___15;
        }
      } else {
        {
#line 237
        tmp___16 = gettext("OFF");
#line 237
        tmp___17 = tmp___16;
        }
      }
#line 237
      if ((int )sbflags & 1) {
        {
#line 237
        tmp___18 = gettext("ON");
#line 237
        tmp___20 = tmp___18;
        }
      } else {
        {
#line 237
        tmp___19 = gettext("OFF");
#line 237
        tmp___20 = tmp___19;
        }
      }
      {
#line 237
      tmp___21 = gettext("Accounting [ondisk]: %s; Enforcement [ondisk]: %s\n");
#line 237
      printf((char const   */* __restrict  */)tmp___21, tmp___20, tmp___17);
      }
    } else {
#line 241
      if ((int )sbflags & (1 << 3)) {
        {
#line 241
        tmp___22 = gettext("ON");
#line 241
        tmp___24 = tmp___22;
        }
      } else {
        {
#line 241
        tmp___23 = gettext("OFF");
#line 241
        tmp___24 = tmp___23;
        }
      }
#line 241
      if ((int )sbflags & (1 << 2)) {
        {
#line 241
        tmp___25 = gettext("ON");
#line 241
        tmp___27 = tmp___25;
        }
      } else {
        {
#line 241
        tmp___26 = gettext("OFF");
#line 241
        tmp___27 = tmp___26;
        }
      }
      {
#line 241
      tmp___28 = gettext("Accounting [ondisk]: %s; Enforcement [ondisk]: %s\n");
#line 241
      printf((char const   */* __restrict  */)tmp___28, tmp___27, tmp___24);
      }
    }
  }
#line 248
  if (h->qh_type == 0) {
#line 249
    if (info->qs_uquota.qfs_ino == 0xffffffffffffffffULL) {
      {
#line 250
      tmp___29 = gettext("Inode: none\n");
#line 250
      printf((char const   */* __restrict  */)tmp___29);
      }
    } else
#line 249
    if (info->qs_uquota.qfs_ino == 0ULL) {
      {
#line 250
      tmp___29 = gettext("Inode: none\n");
#line 250
      printf((char const   */* __restrict  */)tmp___29);
      }
    } else {
      {
#line 252
      tmp___30 = gettext("Inode: #%llu (%llu blocks, %u extents)\n");
#line 252
      printf((char const   */* __restrict  */)tmp___30, info->qs_uquota.qfs_ino, info->qs_uquota.qfs_nblks,
             info->qs_uquota.qfs_nextents);
      }
    }
  } else
#line 258
  if (info->qs_gquota.qfs_ino == 0xffffffffffffffffULL) {
    {
#line 259
    tmp___31 = gettext("Inode: none\n");
#line 259
    printf((char const   */* __restrict  */)tmp___31);
    }
  } else {
    {
#line 261
    tmp___32 = gettext("Inode: #%llu (%llu blocks, %u extents)\n");
#line 261
    printf((char const   */* __restrict  */)tmp___32, info->qs_gquota.qfs_ino, info->qs_gquota.qfs_nblks,
           info->qs_gquota.qfs_nextents);
    }
  }
#line 266
  return (0);
}
}
#line 31 "/home/wheatley/newnew/temp/quota-4.01/bylabel.c"
static struct uuidCache_s *uuidCache___9  =    (struct uuidCache_s *)((void *)0);
#line 74 "/home/wheatley/newnew/temp/quota-4.01/bylabel.c"
static int get_label_uuid___9(char const   *device , char **label , char *uuid ) 
{ 
  int fd ;
  int rv ;
  size_t namesize ;
  struct ext2_super_block e2sb ;
  struct xfs_super_block xfsb ;
  struct reiserfs_super_block reisersb ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  __off64_t tmp___2 ;
  ssize_t tmp___3 ;
  int tmp___4 ;
  __off64_t tmp___5 ;
  ssize_t tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  __off64_t tmp___9 ;
  ssize_t tmp___10 ;

  {
  {
#line 79
  rv = 1;
#line 85
  fd = open(device, 0);
  }
#line 86
  if (fd < 0) {
#line 87
    return (rv);
  }
  {
#line 89
  tmp___9 = lseek(fd, (__off64_t )1024, 0);
  }
#line 89
  if (tmp___9 == 1024L) {
    {
#line 89
    tmp___10 = read(fd, (void *)((char *)(& e2sb)), sizeof(e2sb));
    }
#line 89
    if ((unsigned long )tmp___10 == sizeof(e2sb)) {
#line 89
      if ((uint )e2sb.s_magic[0] + ((uint )e2sb.s_magic[1] << 8) == 61267U) {
        {
#line 92
        memcpy((void */* __restrict  */)uuid, (void const   */* __restrict  */)(e2sb.s_uuid),
               sizeof(e2sb.s_uuid));
#line 93
        namesize = sizeof(e2sb.s_volume_name);
#line 94
        tmp = smalloc(namesize + 1UL);
#line 94
        *label = (char *)tmp;
#line 95
        sstrncpy(*label, (char const   *)((char *)(e2sb.s_volume_name)), namesize);
#line 96
        rv = 0;
        }
      } else {
#line 89
        goto _L___3;
      }
    } else {
#line 89
      goto _L___3;
    }
  } else {
    _L___3: /* CIL Label */ 
    {
#line 98
    tmp___5 = lseek(fd, (__off64_t )0, 0);
    }
#line 98
    if (tmp___5 == 0L) {
      {
#line 98
      tmp___6 = read(fd, (void *)((char *)(& xfsb)), sizeof(xfsb));
      }
#line 98
      if ((unsigned long )tmp___6 == sizeof(xfsb)) {
        {
#line 98
        tmp___7 = strncmp((char const   *)((char *)(& xfsb.s_magic)), "XFSB", (size_t )4);
        }
#line 98
        if (tmp___7 == 0) {
#line 98
          goto _L___0;
        } else {
          {
#line 98
          tmp___8 = strncmp((char const   *)((char *)(& xfsb.s_magic)), "BSFX", (size_t )4);
          }
#line 98
          if (tmp___8 == 0) {
            _L___0: /* CIL Label */ 
            {
#line 102
            memcpy((void */* __restrict  */)uuid, (void const   */* __restrict  */)(xfsb.s_uuid),
                   sizeof(xfsb.s_uuid));
#line 103
            namesize = sizeof(xfsb.s_fsname);
#line 104
            tmp___0 = smalloc(namesize + 1UL);
#line 104
            *label = (char *)tmp___0;
#line 105
            sstrncpy(*label, (char const   *)((char *)(xfsb.s_fsname)), namesize);
#line 106
            rv = 0;
            }
          } else {
#line 98
            goto _L___1;
          }
        }
      } else {
#line 98
        goto _L___1;
      }
    } else {
      _L___1: /* CIL Label */ 
      {
#line 108
      tmp___2 = lseek(fd, (__off64_t )65536, 0);
      }
#line 108
      if (tmp___2 == 65536L) {
        {
#line 108
        tmp___3 = read(fd, (void *)((char *)(& reisersb)), sizeof(reisersb));
        }
#line 108
        if ((unsigned long )tmp___3 == sizeof(reisersb)) {
          {
#line 108
          tmp___4 = strncmp((char const   *)((char *)(& reisersb.s_magic)), "ReIsEr2Fs",
                            (size_t )9);
          }
#line 108
          if (! tmp___4) {
            {
#line 111
            memcpy((void */* __restrict  */)uuid, (void const   */* __restrict  */)(reisersb.s_uuid),
                   sizeof(reisersb.s_uuid));
#line 112
            namesize = sizeof(reisersb.s_volume_name);
#line 113
            tmp___1 = smalloc(namesize + 1UL);
#line 113
            *label = (char *)tmp___1;
#line 114
            sstrncpy(*label, (char const   *)((char *)(reisersb.s_volume_name)), namesize);
#line 115
            rv = 0;
            }
          }
        }
      }
    }
  }
  {
#line 117
  close(fd);
  }
#line 118
  return (rv);
}
}
#line 121 "/home/wheatley/newnew/temp/quota-4.01/bylabel.c"
static void uuidcache_addentry___9(char *device , char *label , char *uuid ) 
{ 
  struct uuidCache_s *last ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 125
  if (! uuidCache___9) {
    {
#line 126
    tmp = smalloc(sizeof(*uuidCache___9));
#line 126
    uuidCache___9 = (struct uuidCache_s *)tmp;
#line 126
    last = uuidCache___9;
    }
  } else {
#line 129
    last = uuidCache___9;
    {
#line 129
    while (1) {
      while_continue: /* CIL Label */ ;
#line 129
      if (! last->next) {
#line 129
        goto while_break;
      }
#line 129
      last = last->next;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 130
    tmp___0 = smalloc(sizeof(*uuidCache___9));
#line 130
    last->next = (struct uuidCache_s *)tmp___0;
#line 131
    last = last->next;
    }
  }
  {
#line 133
  last->next = (struct uuidCache_s *)((void *)0);
#line 134
  last->device = device;
#line 135
  last->label = label;
#line 136
  memcpy((void */* __restrict  */)(last->uuid), (void const   */* __restrict  */)uuid,
         sizeof(last->uuid));
  }
#line 137
  return;
}
}
#line 144 "/home/wheatley/newnew/temp/quota-4.01/bylabel.c"
static char ptname___9[100]  ;
#line 139 "/home/wheatley/newnew/temp/quota-4.01/bylabel.c"
static void uuidcache_init___9(void) 
{ 
  char line___0[100] ;
  char *s ;
  int ma ;
  int mi ;
  int sz ;
  FILE *procpt ;
  char uuid[16] ;
  char *label ;
  char device[110] ;
  int firstPass ;
  int handleOnFirst ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  unsigned short const   **tmp___4 ;
  char *tmp___5 ;

  {
#line 151
  if (uuidCache___9) {
#line 152
    return;
  }
  {
#line 154
  procpt = fopen((char const   */* __restrict  */)"/proc/partitions", (char const   */* __restrict  */)"r");
  }
#line 155
  if (! procpt) {
#line 156
    return;
  }
#line 158
  firstPass = 1;
  {
#line 158
  while (1) {
    while_continue: /* CIL Label */ ;
#line 158
    if (! (firstPass >= 0)) {
#line 158
      goto while_break;
    }
    {
#line 159
    fseek(procpt, 0L, 0);
    }
    {
#line 161
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 161
      tmp___5 = fgets((char */* __restrict  */)(line___0), (int )sizeof(line___0),
                      (FILE */* __restrict  */)procpt);
      }
#line 161
      if (! tmp___5) {
#line 161
        goto while_break___0;
      }
      {
#line 162
      tmp = sscanf((char const   */* __restrict  */)(line___0), (char const   */* __restrict  */)" %d %d %d %[^\n ]",
                   & ma, & mi, & sz, ptname___9);
      }
#line 162
      if (tmp != 4) {
#line 163
        goto while_continue___0;
      }
#line 166
      if (sz == 1) {
#line 167
        goto while_continue___0;
      }
      {
#line 170
      tmp___0 = strncmp((char const   *)(ptname___9), "md", (size_t )2);
      }
#line 170
      if (tmp___0) {
#line 170
        tmp___1 = 0;
      } else {
#line 170
        tmp___1 = 1;
      }
#line 170
      handleOnFirst = tmp___1;
#line 171
      if (firstPass != handleOnFirst) {
#line 172
        goto while_continue___0;
      }
#line 178
      s = ptname___9;
      {
#line 178
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 178
        if (! *s) {
#line 178
          goto while_break___1;
        }
#line 178
        s ++;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 179
      tmp___4 = __ctype_b_loc();
      }
#line 179
      if ((int const   )*(*tmp___4 + (int )*(s + -1)) & 2048) {
        {
#line 189
        snprintf((char */* __restrict  */)(device), sizeof(device), (char const   */* __restrict  */)"%s/%s",
                 "/dev", ptname___9);
#line 190
        tmp___3 = get_label_uuid___9((char const   *)(device), & label, uuid);
        }
#line 190
        if (! tmp___3) {
          {
#line 191
          tmp___2 = sstrdup((char const   *)(device));
#line 191
          uuidcache_addentry___9(tmp___2, label, uuid);
          }
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 158
    firstPass --;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 196
  fclose(procpt);
  }
#line 197
  return;
}
}
#line 202 "/home/wheatley/newnew/temp/quota-4.01/bylabel.c"
static char *get_spec_by_x___9(int n , char const   *t ) 
{ 
  struct uuidCache_s *uc ;
  char *tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 206
  uuidcache_init___9();
#line 207
  uc = uuidCache___9;
  }
  {
#line 209
  while (1) {
    while_continue: /* CIL Label */ ;
#line 209
    if (! uc) {
#line 209
      goto while_break;
    }
    {
#line 211
    if (n == 1) {
#line 211
      goto case_1;
    }
#line 215
    if (n == 2) {
#line 215
      goto case_2;
    }
#line 210
    goto switch_break;
    case_1: /* CIL Label */ 
    {
#line 212
    tmp___0 = memcmp((void const   *)t, (void const   *)(uc->uuid), sizeof(uc->uuid));
    }
#line 212
    if (! tmp___0) {
      {
#line 213
      tmp = sstrdup((char const   *)uc->device);
      }
#line 213
      return (tmp);
    }
#line 214
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 216
    tmp___2 = strcmp(t, (char const   *)uc->label);
    }
#line 216
    if (! tmp___2) {
      {
#line 217
      tmp___1 = sstrdup((char const   *)uc->device);
      }
#line 217
      return (tmp___1);
    }
#line 218
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 220
    uc = uc->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 222
  return ((char *)((void *)0));
}
}
#line 225 "/home/wheatley/newnew/temp/quota-4.01/bylabel.c"
static u_char fromhex___9(char c ) 
{ 
  unsigned short const   **tmp ;
  unsigned short const   **tmp___0 ;

  {
  {
#line 227
  tmp___0 = __ctype_b_loc();
  }
#line 227
  if ((int const   )*(*tmp___0 + (int )c) & 2048) {
#line 228
    return ((u_char )((int )c - 48));
  } else {
    {
#line 229
    tmp = __ctype_b_loc();
    }
#line 229
    if ((int const   )*(*tmp + (int )c) & 512) {
#line 230
      return ((u_char )(((int )c - 97) + 10));
    } else {
#line 232
      return ((u_char )(((int )c - 65) + 10));
    }
  }
}
}
#line 235 "/home/wheatley/newnew/temp/quota-4.01/bylabel.c"
static char *get_spec_by_uuid___9(char const   *s ) 
{ 
  u_char uuid[16] ;
  int i ;
  size_t tmp ;
  unsigned short const   **tmp___0 ;
  unsigned short const   **tmp___1 ;
  u_char tmp___2 ;
  u_char tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;

  {
  {
#line 240
  tmp = strlen(s);
  }
#line 240
  if (tmp != 36UL) {
#line 241
    goto bad_uuid;
  } else
#line 240
  if ((int const   )*(s + 8) != 45) {
#line 241
    goto bad_uuid;
  } else
#line 240
  if ((int const   )*(s + 13) != 45) {
#line 241
    goto bad_uuid;
  } else
#line 240
  if ((int const   )*(s + 18) != 45) {
#line 241
    goto bad_uuid;
  } else
#line 240
  if ((int const   )*(s + 23) != 45) {
#line 241
    goto bad_uuid;
  }
#line 242
  i = 0;
  {
#line 242
  while (1) {
    while_continue: /* CIL Label */ ;
#line 242
    if (! (i < 16)) {
#line 242
      goto while_break;
    }
#line 243
    if ((int const   )*s == 45) {
#line 244
      s ++;
    }
    {
#line 245
    tmp___0 = __ctype_b_loc();
    }
#line 245
    if ((int const   )*(*tmp___0 + (int )*(s + 0)) & 4096) {
      {
#line 245
      tmp___1 = __ctype_b_loc();
      }
#line 245
      if (! ((int const   )*(*tmp___1 + (int )*(s + 1)) & 4096)) {
#line 246
        goto bad_uuid;
      }
    } else {
#line 246
      goto bad_uuid;
    }
    {
#line 247
    tmp___2 = fromhex___9((char )*(s + 0));
#line 247
    tmp___3 = fromhex___9((char )*(s + 1));
#line 247
    uuid[i] = (u_char )(((int )tmp___2 << 4) | (int )tmp___3);
#line 248
    s += 2;
#line 242
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 250
  tmp___4 = get_spec_by_x___9(1, (char const   *)((char *)(uuid)));
  }
#line 250
  return (tmp___4);
  bad_uuid: 
  {
#line 253
  tmp___5 = gettext("Found an invalid UUID: %s\n");
#line 253
  errstr(tmp___5, s);
  }
#line 254
  return ((char *)((void *)0));
}
}
#line 257 "/home/wheatley/newnew/temp/quota-4.01/bylabel.c"
static char *get_spec_by_volume_label___9(char const   *s ) 
{ 
  char *tmp ;

  {
  {
#line 259
  tmp = get_spec_by_x___9(2, s);
  }
#line 259
  return (tmp);
}
}
#line 50 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v1.c"
static int v1_check_file___9(int fd , int type , int fmt___7 ) ;
#line 51
static int v1_init_io___9(struct quota_handle *h ) ;
#line 52
static int v1_new_io___9(struct quota_handle *h ) ;
#line 53
static int v1_write_info___9(struct quota_handle *h ) ;
#line 54
static struct dquot *v1_read_dquot___9(struct quota_handle *h , qid_t id___0 ) ;
#line 55
static int v1_commit_dquot___9(struct dquot *dquot , int flags___7 ) ;
#line 56
static int v1_scan_dquots___9(struct quota_handle *h , int (*process_dquot)(struct dquot *dquot ,
                                                                            char *dqname ) ) ;
#line 127 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v1.c"
static int v1_check_file___9(int fd , int type , int fmt___7 ) 
{ 
  struct stat st ;
  int tmp ;

  {
  {
#line 131
  tmp = fstat(fd, & st);
  }
#line 131
  if (tmp < 0) {
#line 132
    return (0);
  }
#line 133
  if (! st.st_size) {
#line 134
    return (0);
  } else
#line 133
  if ((unsigned long )st.st_size % sizeof(struct v1_disk_dqblk )) {
#line 134
    return (0);
  }
#line 135
  return (1);
}
}
#line 141 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v1.c"
static int v1_init_io___9(struct quota_handle *h ) 
{ 
  int tmp ;
  struct v1_kern_dqblk kdqblk ;
  time_t tmp___0 ;
  int *tmp___1 ;
  long tmp___2 ;
  struct v1_disk_dqblk ddqblk ;
  ssize_t tmp___3 ;

  {
#line 143
  if (h->qh_io_flags & 1) {
#line 144
    if (kernel_iface == 3) {
      {
#line 145
      tmp = vfs_get_info(h);
      }
#line 145
      if (tmp < 0) {
#line 146
        return (-1);
      }
    } else {
      {
#line 151
      tmp___2 = quotactl((768 << 8) | (h->qh_type & 255), (char const   *)(h->qh_quotadev),
                         (qid_t )0, (caddr_t )((void *)(& kdqblk)));
      }
#line 151
      if (tmp___2 < 0L) {
        {
#line 152
        tmp___1 = __errno_location();
        }
#line 152
        if (*tmp___1 == 1) {
#line 153
          tmp___0 = (time_t )0;
#line 153
          h->qh_info.dqi_igrace = tmp___0;
#line 153
          h->qh_info.dqi_bgrace = tmp___0;
        } else {
#line 156
          return (-1);
        }
      } else {
#line 159
        h->qh_info.dqi_bgrace = kdqblk.dqb_btime;
#line 160
        h->qh_info.dqi_igrace = kdqblk.dqb_itime;
      }
    }
  } else {
    {
#line 167
    lseek(h->qh_fd, (__off64_t )0, 0);
#line 168
    tmp___3 = read(h->qh_fd, (void *)(& ddqblk), sizeof(ddqblk));
    }
#line 168
    if ((unsigned long )tmp___3 != sizeof(ddqblk)) {
#line 169
      return (-1);
    }
#line 170
    h->qh_info.dqi_bgrace = ddqblk.dqb_btime;
#line 171
    h->qh_info.dqi_igrace = ddqblk.dqb_itime;
  }
#line 173
  if (! h->qh_info.dqi_bgrace) {
#line 174
    h->qh_info.dqi_bgrace = (time_t )604800;
  }
#line 175
  if (! h->qh_info.dqi_igrace) {
#line 176
    h->qh_info.dqi_igrace = (time_t )604800;
  }
#line 177
  h->qh_info.dqi_max_b_limit = (uint64_t )(~ ((uint32_t )0));
#line 178
  h->qh_info.dqi_max_i_limit = (uint64_t )(~ ((uint32_t )0));
#line 179
  h->qh_info.dqi_max_b_usage = 4294967295UL << 10;
#line 180
  h->qh_info.dqi_max_i_usage = (uint64_t )(~ ((uint32_t )0));
#line 182
  return (0);
}
}
#line 188 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v1.c"
static int v1_new_io___9(struct quota_handle *h ) 
{ 
  struct v1_disk_dqblk ddqblk ;
  ssize_t tmp ;

  {
  {
#line 193
  memset((void *)(& ddqblk), 0, sizeof(ddqblk));
#line 194
  ddqblk.dqb_btime = (time_t )604800;
#line 195
  ddqblk.dqb_itime = (time_t )604800;
#line 196
  h->qh_info.dqi_bgrace = (time_t )604800;
#line 197
  h->qh_info.dqi_igrace = (time_t )604800;
#line 198
  h->qh_info.dqi_max_b_limit = (uint64_t )(~ ((uint32_t )0));
#line 199
  h->qh_info.dqi_max_i_limit = (uint64_t )(~ ((uint32_t )0));
#line 200
  h->qh_info.dqi_max_b_usage = 4294967295UL << 10;
#line 201
  h->qh_info.dqi_max_i_usage = (uint64_t )(~ ((uint32_t )0));
#line 202
  lseek(h->qh_fd, (__off64_t )0, 0);
#line 203
  tmp = write(h->qh_fd, (void const   *)(& ddqblk), sizeof(ddqblk));
  }
#line 203
  if ((unsigned long )tmp != sizeof(ddqblk)) {
#line 204
    return (-1);
  }
#line 205
  return (0);
}
}
#line 211 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v1.c"
static int v1_write_info___9(struct quota_handle *h ) 
{ 
  char *tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  struct v1_kern_dqblk kdqblk ;
  long tmp___2 ;
  long tmp___3 ;
  struct v1_disk_dqblk ddqblk ;
  ssize_t tmp___4 ;
  ssize_t tmp___5 ;

  {
#line 213
  if (h->qh_io_flags & 4) {
    {
#line 214
    tmp = gettext("Trying to write info to readonly quotafile on %s.\n");
#line 214
    errstr(tmp, h->qh_quotadev);
#line 215
    tmp___0 = __errno_location();
#line 215
    *tmp___0 = 1;
    }
#line 216
    return (-1);
  }
#line 218
  if (h->qh_io_flags & 1) {
#line 219
    if (kernel_iface == 3) {
      {
#line 220
      tmp___1 = vfs_set_info(h, 3);
      }
#line 220
      if (tmp___1 < 0) {
#line 221
        return (-1);
      }
    } else {
      {
#line 226
      tmp___2 = quotactl((768 << 8) | (h->qh_type & 255), (char const   *)(h->qh_quotadev),
                         (qid_t )0, (caddr_t )((void *)(& kdqblk)));
      }
#line 226
      if (tmp___2 < 0L) {
#line 227
        return (-1);
      }
      {
#line 228
      kdqblk.dqb_btime = h->qh_info.dqi_bgrace;
#line 229
      kdqblk.dqb_itime = h->qh_info.dqi_igrace;
#line 230
      tmp___3 = quotactl((1024 << 8) | (h->qh_type & 255), (char const   *)(h->qh_quotadev),
                         (qid_t )0, (caddr_t )((void *)(& kdqblk)));
      }
#line 230
      if (tmp___3 < 0L) {
#line 231
        return (-1);
      }
    }
  } else {
    {
#line 237
    lseek(h->qh_fd, (__off64_t )0, 0);
#line 238
    tmp___4 = read(h->qh_fd, (void *)(& ddqblk), sizeof(ddqblk));
    }
#line 238
    if ((unsigned long )tmp___4 != sizeof(ddqblk)) {
#line 239
      return (-1);
    }
    {
#line 240
    ddqblk.dqb_btime = h->qh_info.dqi_bgrace;
#line 241
    ddqblk.dqb_itime = h->qh_info.dqi_igrace;
#line 242
    lseek(h->qh_fd, (__off64_t )0, 0);
#line 243
    tmp___5 = write(h->qh_fd, (void const   *)(& ddqblk), sizeof(ddqblk));
    }
#line 243
    if ((unsigned long )tmp___5 != sizeof(ddqblk)) {
#line 244
      return (-1);
    }
  }
#line 246
  return (0);
}
}
#line 253 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v1.c"
static struct dquot *v1_read_dquot___9(struct quota_handle *h , qid_t id___0 ) 
{ 
  struct v1_disk_dqblk ddqblk ;
  struct dquot *dquot ;
  struct dquot *tmp ;
  int tmp___0 ;
  struct v1_kern_dqblk kdqblk ;
  long tmp___1 ;
  ssize_t tmp___2 ;

  {
  {
#line 256
  tmp = get_empty_dquot();
#line 256
  dquot = tmp;
#line 258
  dquot->dq_id = id___0;
#line 259
  dquot->dq_h = h;
  }
#line 260
  if (h->qh_io_flags & 1) {
#line 261
    if (kernel_iface == 3) {
      {
#line 262
      tmp___0 = vfs_get_dquot(dquot);
      }
#line 262
      if (tmp___0 < 0) {
        {
#line 263
        free((void *)dquot);
        }
#line 264
        return ((struct dquot *)((void *)0));
      }
    } else {
      {
#line 270
      tmp___1 = quotactl((768 << 8) | (h->qh_type & 255), (char const   *)(h->qh_quotadev),
                         id___0, (caddr_t )((void *)(& kdqblk)));
      }
#line 270
      if (tmp___1 < 0L) {
        {
#line 271
        free((void *)dquot);
        }
#line 272
        return ((struct dquot *)((void *)0));
      }
      {
#line 274
      v1_kern2utildqblk(& dquot->dq_dqb, & kdqblk);
      }
    }
  } else {
    {
#line 278
    lseek(h->qh_fd, (loff_t )((unsigned long )id___0 * sizeof(struct v1_disk_dqblk )),
          0);
#line 279
    tmp___2 = read(h->qh_fd, (void *)(& ddqblk), sizeof(ddqblk));
    }
    {
#line 280
    if (tmp___2 == 0L) {
#line 280
      goto case_0;
    }
#line 287
    if (tmp___2 == (ssize_t )sizeof(struct v1_disk_dqblk )) {
#line 287
      goto case_exp;
    }
#line 290
    goto switch_default;
    case_0: /* CIL Label */ 
    {
#line 285
    memset((void *)(& dquot->dq_dqb), 0, sizeof(struct util_dqblk ));
    }
#line 286
    goto switch_break;
    case_exp: /* CIL Label */ 
    {
#line 288
    v1_disk2memdqblk(& dquot->dq_dqb, & ddqblk);
    }
#line 289
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 291
    free((void *)dquot);
    }
#line 292
    return ((struct dquot *)((void *)0));
    switch_break: /* CIL Label */ ;
    }
  }
#line 295
  return (dquot);
}
}
#line 302 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v1.c"
static int v1_commit_dquot___9(struct dquot *dquot , int flags___7 ) 
{ 
  struct v1_disk_dqblk ddqblk ;
  struct quota_handle *h ;
  char *tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  struct v1_kern_dqblk kdqblk ;
  int cmd ;
  int *tmp___2 ;
  long tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;
  ssize_t tmp___6 ;

  {
#line 305
  h = dquot->dq_h;
#line 307
  if (h->qh_io_flags & 4) {
    {
#line 308
    tmp = gettext("Trying to write quota to readonly quotafile on %s\n");
#line 308
    errstr(tmp, h->qh_quotadev);
#line 309
    tmp___0 = __errno_location();
#line 309
    *tmp___0 = 1;
    }
#line 310
    return (-1);
  }
#line 312
  if (h->qh_io_flags & 1) {
#line 313
    if (kernel_iface == 3) {
      {
#line 314
      tmp___1 = vfs_set_dquot(dquot, flags___7);
      }
#line 314
      if (tmp___1 < 0) {
#line 315
        return (-1);
      }
    } else {
#line 321
      if (flags___7 == 10) {
#line 322
        cmd = 1280;
      } else
#line 323
      if (flags___7 == 5) {
#line 324
        cmd = 1792;
      } else
#line 325
      if (flags___7 & 48) {
        {
#line 326
        tmp___2 = __errno_location();
#line 326
        *tmp___2 = 22;
        }
#line 327
        return (-1);
      } else {
#line 330
        cmd = 1024;
      }
      {
#line 331
      v1_util2kerndqblk(& kdqblk, & dquot->dq_dqb);
#line 332
      tmp___3 = quotactl((cmd << 8) | (h->qh_type & 255), (char const   *)(h->qh_quotadev),
                         dquot->dq_id, (caddr_t )((void *)(& kdqblk)));
      }
#line 332
      if (tmp___3 < 0L) {
#line 334
        return (-1);
      }
    }
  } else {
    {
#line 338
    tmp___5 = check_dquot_range(dquot);
    }
#line 338
    if (tmp___5 < 0) {
      {
#line 339
      tmp___4 = __errno_location();
#line 339
      *tmp___4 = 34;
      }
#line 340
      return (-1);
    }
    {
#line 342
    v1_mem2diskdqblk(& ddqblk, & dquot->dq_dqb);
#line 343
    lseek(h->qh_fd, (loff_t )((unsigned long )dquot->dq_id * sizeof(struct v1_disk_dqblk )),
          0);
#line 344
    tmp___6 = write(h->qh_fd, (void const   *)(& ddqblk), sizeof(ddqblk));
    }
#line 344
    if ((unsigned long )tmp___6 != sizeof(ddqblk)) {
#line 345
      return (-1);
    }
  }
#line 347
  return (0);
}
}
#line 355 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v1.c"
static int v1_scan_dquots___9(struct quota_handle *h , int (*process_dquot)(struct dquot *dquot ,
                                                                            char *dqname ) ) 
{ 
  int rd ;
  int scanbufpos ;
  int scanbufsize ;
  char scanbuf[sizeof(struct v1_disk_dqblk ) * 256UL] ;
  struct v1_disk_dqblk *ddqblk ;
  struct dquot *dquot ;
  struct dquot *tmp ;
  qid_t id___0 ;
  ssize_t tmp___0 ;

  {
  {
#line 357
  scanbufpos = 0;
#line 357
  scanbufsize = 0;
#line 360
  tmp = get_empty_dquot();
#line 360
  dquot = tmp;
#line 361
  id___0 = (qid_t )0;
#line 363
  memset((void *)dquot, 0, sizeof(*dquot));
#line 364
  dquot->dq_h = h;
#line 365
  lseek(h->qh_fd, (__off64_t )0, 0);
#line 366
  id___0 = (qid_t )0;
  }
  {
#line 366
  while (1) {
    while_continue: /* CIL Label */ ;
#line 367
    if (scanbufpos >= scanbufsize) {
      {
#line 368
      tmp___0 = read(h->qh_fd, (void *)(scanbuf), sizeof(scanbuf));
#line 368
      rd = (int )tmp___0;
      }
#line 369
      if (rd < 0) {
#line 370
        goto out_err;
      } else
#line 369
      if ((unsigned long )rd % sizeof(struct v1_disk_dqblk )) {
#line 370
        goto out_err;
      }
#line 371
      if (! rd) {
#line 372
        goto while_break;
      }
#line 373
      scanbufpos = 0;
#line 374
      scanbufsize = (int )((unsigned long )rd / sizeof(struct v1_disk_dqblk ));
    }
#line 376
    ddqblk = (struct v1_disk_dqblk *)(scanbuf) + scanbufpos;
#line 377
    if ((((long )(((((ddqblk->dqb_ihardlimit | ddqblk->dqb_isoftlimit) | ddqblk->dqb_bhardlimit) | ddqblk->dqb_bsoftlimit) | ddqblk->dqb_curblocks) | ddqblk->dqb_curinodes) | ddqblk->dqb_itime) | ddqblk->dqb_btime) == 0L) {
#line 381
      goto __Cont;
    }
    {
#line 382
    v1_disk2memdqblk(& dquot->dq_dqb, ddqblk);
#line 383
    dquot->dq_id = id___0;
#line 384
    rd = (*process_dquot)(dquot, (char *)((void *)0));
    }
#line 384
    if (rd < 0) {
      {
#line 385
      free((void *)dquot);
      }
#line 386
      return (rd);
    }
    __Cont: /* CIL Label */ 
#line 366
    id___0 ++;
#line 366
    scanbufpos ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 389
  if (! rd) {
    {
#line 390
    free((void *)dquot);
    }
#line 391
    return (0);
  }
  out_err: 
  {
#line 394
  free((void *)dquot);
  }
#line 395
  return (-1);
}
}
#line 89 "/home/wheatley/newnew/temp/quota-4.01/rquota_client.c"
static int rquota_err___9(int stat___0 ) 
{ 


  {
  {
#line 92
  if (stat___0 == -1) {
#line 92
    goto case_neg_1;
  }
#line 94
  if (stat___0 == 0) {
#line 94
    goto case_0;
  }
#line 96
  if (stat___0 == 2) {
#line 96
    goto case_2;
  }
#line 98
  if (stat___0 == 1) {
#line 98
    goto case_1;
  }
#line 100
  if (stat___0 == 3) {
#line 100
    goto case_3;
  }
#line 102
  goto switch_default;
  case_neg_1: /* CIL Label */ 
#line 93
  return (-111);
  case_0: /* CIL Label */ 
#line 95
  return (-38);
  case_2: /* CIL Label */ 
#line 97
  return (-2);
  case_1: /* CIL Label */ 
#line 99
  return (0);
  case_3: /* CIL Label */ 
#line 101
  return (-1);
  switch_default: /* CIL Label */ 
#line 103
  return (-22);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 107 "/home/wheatley/newnew/temp/quota-4.01/rquota_client.c"
static int split_nfs_mount___9(char *devname , char **host , char **path ) 
{ 
  char *pathname ;

  {
#line 112
  if ((int )*devname == 91) {
    {
#line 113
    *host = devname + 1;
#line 114
    pathname = strchr((char const   *)devname, ']');
    }
#line 115
    if (! pathname) {
#line 116
      return (0);
    } else
#line 115
    if ((int )*(pathname + 1) != 58) {
#line 116
      return (0);
    }
#line 118
    if ((int )*(pathname + 2) == 40) {
#line 119
      return (0);
    }
#line 120
    *pathname = (char)0;
#line 121
    *path = pathname + 2;
#line 122
    return (1);
  }
  {
#line 124
  *host = devname;
#line 125
  pathname = strchr((char const   *)devname, ':');
  }
#line 126
  if (! pathname) {
#line 127
    return (0);
  }
#line 129
  if ((int )*(pathname + 1) == 40) {
#line 130
    return (0);
  }
#line 131
  *pathname = (char)0;
#line 132
  *path = pathname + 1;
#line 133
  return (1);
}
}
#line 41 "/home/wheatley/newnew/temp/quota-4.01/repquota.c"
static int flags___6  ;
#line 41 "/home/wheatley/newnew/temp/quota-4.01/repquota.c"
static int fmt___6  =    -1;
#line 42 "/home/wheatley/newnew/temp/quota-4.01/repquota.c"
static char **mnt___1  ;
#line 43 "/home/wheatley/newnew/temp/quota-4.01/repquota.c"
static int mntcnt___2  ;
#line 44 "/home/wheatley/newnew/temp/quota-4.01/repquota.c"
static int cached_dquots  ;
#line 45 "/home/wheatley/newnew/temp/quota-4.01/repquota.c"
static struct dquot dquot_cache[1024]  ;
#line 48 "/home/wheatley/newnew/temp/quota-4.01/repquota.c"
static void usage___8(void) 
{ 
  char *tmp ;
  char *tmp___0 ;

  {
  {
#line 50
  tmp = gettext("Utility for reporting quotas.\nUsage:\n%s [-vugsi] [-c|C] [-t|n] [-F quotaformat] (-a | mntpoint)\n\n-v, --verbose               display also users/groups without any usage\n-u, --user                  display information about users\n-g, --group                 display information about groups\n-s, --human-readable        show numbers in human friendly units (MB, GB, ...)\n-t, --truncate-names        truncate names to 9 characters\n-p, --raw-grace             print grace time in seconds since epoch\n-n, --no-names              do not translate uid/gid to name\n-i, --no-autofs             avoid autofs mountpoints\n-c, --batch-translation     translate big number of ids at once\n-C, --no-batch-translation  translate ids one by one\n-F, --format=formatname     report information for specific format\n-h, --help                  display this help message and exit\n-V, --version               display version information and exit\n\n");
#line 50
  errstr(tmp, progname);
#line 64
  tmp___0 = gettext("Bugs to %s\n");
#line 64
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___0,
          "jack@suse.cz");
#line 65
  exit(1);
  }
}
}
#line 68 "/home/wheatley/newnew/temp/quota-4.01/repquota.c"
static void parse_options___7(int argcnt , char **argstr ) 
{ 
  int ret ;
  int cache_specified ;
  struct option long_opts[15] ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;

  {
#line 71
  cache_specified = 0;
#line 72
  long_opts[0].name = "version";
#line 72
  long_opts[0].has_arg = 0;
#line 72
  long_opts[0].flag = (int *)((void *)0);
#line 72
  long_opts[0].val = 'V';
#line 72
  long_opts[1].name = "all";
#line 72
  long_opts[1].has_arg = 0;
#line 72
  long_opts[1].flag = (int *)((void *)0);
#line 72
  long_opts[1].val = 'a';
#line 72
  long_opts[2].name = "verbose";
#line 72
  long_opts[2].has_arg = 0;
#line 72
  long_opts[2].flag = (int *)((void *)0);
#line 72
  long_opts[2].val = 'v';
#line 72
  long_opts[3].name = "user";
#line 72
  long_opts[3].has_arg = 0;
#line 72
  long_opts[3].flag = (int *)((void *)0);
#line 72
  long_opts[3].val = 'u';
#line 72
  long_opts[4].name = "group";
#line 72
  long_opts[4].has_arg = 0;
#line 72
  long_opts[4].flag = (int *)((void *)0);
#line 72
  long_opts[4].val = 'g';
#line 72
  long_opts[5].name = "help";
#line 72
  long_opts[5].has_arg = 0;
#line 72
  long_opts[5].flag = (int *)((void *)0);
#line 72
  long_opts[5].val = 'h';
#line 72
  long_opts[6].name = "truncate-names";
#line 72
  long_opts[6].has_arg = 0;
#line 72
  long_opts[6].flag = (int *)((void *)0);
#line 72
  long_opts[6].val = 't';
#line 72
  long_opts[7].name = "raw-grace";
#line 72
  long_opts[7].has_arg = 0;
#line 72
  long_opts[7].flag = (int *)((void *)0);
#line 72
  long_opts[7].val = 'p';
#line 72
  long_opts[8].name = "human-readable";
#line 72
  long_opts[8].has_arg = 0;
#line 72
  long_opts[8].flag = (int *)((void *)0);
#line 72
  long_opts[8].val = 's';
#line 72
  long_opts[9].name = "no-names";
#line 72
  long_opts[9].has_arg = 0;
#line 72
  long_opts[9].flag = (int *)((void *)0);
#line 72
  long_opts[9].val = 'n';
#line 72
  long_opts[10].name = "cache";
#line 72
  long_opts[10].has_arg = 0;
#line 72
  long_opts[10].flag = (int *)((void *)0);
#line 72
  long_opts[10].val = 'c';
#line 72
  long_opts[11].name = "no-cache";
#line 72
  long_opts[11].has_arg = 0;
#line 72
  long_opts[11].flag = (int *)((void *)0);
#line 72
  long_opts[11].val = 'C';
#line 72
  long_opts[12].name = "no-autofs";
#line 72
  long_opts[12].has_arg = 0;
#line 72
  long_opts[12].flag = (int *)((void *)0);
#line 72
  long_opts[12].val = 'i';
#line 72
  long_opts[13].name = "format";
#line 72
  long_opts[13].has_arg = 1;
#line 72
  long_opts[13].flag = (int *)((void *)0);
#line 72
  long_opts[13].val = 'F';
#line 72
  long_opts[14].name = (char const   *)((void *)0);
#line 72
  long_opts[14].has_arg = 0;
#line 72
  long_opts[14].flag = (int *)((void *)0);
#line 72
  long_opts[14].val = 0;
  {
#line 90
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 90
    ret = getopt_long(argcnt, (char * const  *)argstr, "VavughtspncCiF:", (struct option  const  *)(long_opts),
                      (int *)((void *)0));
    }
#line 90
    if (! (ret != -1)) {
#line 90
      goto while_break;
    }
    {
#line 93
    if (ret == 104) {
#line 93
      goto case_104;
    }
#line 93
    if (ret == 63) {
#line 93
      goto case_104;
    }
#line 95
    if (ret == 86) {
#line 95
      goto case_86;
    }
#line 98
    if (ret == 117) {
#line 98
      goto case_117;
    }
#line 101
    if (ret == 103) {
#line 101
      goto case_103;
    }
#line 104
    if (ret == 118) {
#line 104
      goto case_118;
    }
#line 107
    if (ret == 97) {
#line 107
      goto case_97;
    }
#line 110
    if (ret == 116) {
#line 110
      goto case_116;
    }
#line 113
    if (ret == 112) {
#line 113
      goto case_112;
    }
#line 116
    if (ret == 115) {
#line 116
      goto case_115;
    }
#line 119
    if (ret == 67) {
#line 119
      goto case_67;
    }
#line 123
    if (ret == 99) {
#line 123
      goto case_99;
    }
#line 126
    if (ret == 105) {
#line 126
      goto case_105;
    }
#line 129
    if (ret == 70) {
#line 129
      goto case_70;
    }
#line 133
    if (ret == 110) {
#line 133
      goto case_110;
    }
#line 91
    goto switch_break;
    case_104: /* CIL Label */ 
    case_63: /* CIL Label */ 
    {
#line 94
    usage___8();
    }
    case_86: /* CIL Label */ 
    {
#line 96
    version();
#line 97
    exit(0);
    }
    case_117: /* CIL Label */ 
#line 99
    flags___6 |= 1;
#line 100
    goto switch_break;
    case_103: /* CIL Label */ 
#line 102
    flags___6 |= 2;
#line 103
    goto switch_break;
    case_118: /* CIL Label */ 
#line 105
    flags___6 |= 4;
#line 106
    goto switch_break;
    case_97: /* CIL Label */ 
#line 108
    flags___6 |= 8;
#line 109
    goto switch_break;
    case_116: /* CIL Label */ 
#line 111
    flags___6 |= 16;
#line 112
    goto switch_break;
    case_112: /* CIL Label */ 
#line 114
    flags___6 |= 512;
#line 115
    goto switch_break;
    case_115: /* CIL Label */ 
#line 117
    flags___6 |= 32;
#line 118
    goto switch_break;
    case_67: /* CIL Label */ 
#line 120
    flags___6 |= 128;
#line 121
    cache_specified = 1;
#line 122
    goto switch_break;
    case_99: /* CIL Label */ 
#line 124
    cache_specified = 1;
#line 125
    goto switch_break;
    case_105: /* CIL Label */ 
#line 127
    flags___6 |= 256;
#line 128
    goto switch_break;
    case_70: /* CIL Label */ 
    {
#line 130
    fmt___6 = name2fmt(optarg);
    }
#line 130
    if (fmt___6 == -1) {
      {
#line 131
      exit(1);
      }
    }
#line 132
    goto switch_break;
    case_110: /* CIL Label */ 
#line 134
    flags___6 |= 64;
#line 135
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 140
  if (flags___6 & 8) {
#line 140
    if (optind != argcnt) {
      {
#line 141
      tmp = gettext("Bad number of arguments.\n");
#line 141
      fputs((char const   */* __restrict  */)tmp, (FILE */* __restrict  */)stderr);
#line 142
      usage___8();
      }
    } else {
#line 140
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 140
  if (! (flags___6 & 8)) {
#line 140
    if (optind == argcnt) {
      {
#line 141
      tmp = gettext("Bad number of arguments.\n");
#line 141
      fputs((char const   */* __restrict  */)tmp, (FILE */* __restrict  */)stderr);
#line 142
      usage___8();
      }
    }
  }
#line 144
  if (fmt___6 == 3) {
    {
#line 145
    tmp___0 = gettext("Repquota cannot report through RPC calls.\n");
#line 145
    fputs((char const   */* __restrict  */)tmp___0, (FILE */* __restrict  */)stderr);
#line 146
    exit(1);
    }
  }
#line 148
  if (flags___6 & 64) {
#line 148
    if (flags___6 & 16) {
      {
#line 149
      tmp___1 = gettext("Specified both -n and -t but only one of them can be used.\n");
#line 149
      fputs((char const   */* __restrict  */)tmp___1, (FILE */* __restrict  */)stderr);
#line 150
      exit(1);
      }
    }
  }
#line 152
  if (! (flags___6 & 3)) {
#line 153
    flags___6 |= 1;
  }
#line 154
  if (! (flags___6 & 8)) {
#line 155
    mnt___1 = argstr + optind;
#line 156
    mntcnt___2 = argcnt - optind;
  }
#line 158
  if (! cache_specified) {
#line 158
    if (! (flags___6 & 64)) {
      {
#line 158
      tmp___2 = passwd_handling();
      }
#line 158
      if (tmp___2 == 1) {
#line 159
        flags___6 |= 128;
      }
    }
  }
#line 160
  return;
}
}
#line 163 "/home/wheatley/newnew/temp/quota-4.01/repquota.c"
static char overlim(qsize_t usage___9 , qsize_t softlim , qsize_t hardlim ) 
{ 


  {
#line 165
  if (usage___9 > softlim) {
#line 165
    if (softlim) {
#line 166
      return ((char )'+');
    } else {
#line 165
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 165
  if (usage___9 > hardlim) {
#line 165
    if (hardlim) {
#line 166
      return ((char )'+');
    }
  }
#line 167
  return ((char )'-');
}
}
#line 171 "/home/wheatley/newnew/temp/quota-4.01/repquota.c"
static void print(struct dquot *dquot , char *name ) 
{ 
  char pname[64] ;
  char time___0[40] ;
  char numbuf[3][32] ;
  struct util_dqblk *entry ;
  char tmp ;
  char tmp___0 ;

  {
#line 177
  entry = & dquot->dq_dqb;
#line 179
  if (! entry->dqb_curspace) {
#line 179
    if (! entry->dqb_curinodes) {
#line 179
      if (! (flags___6 & 4)) {
#line 180
        return;
      }
    }
  }
  {
#line 181
  sstrncpy(pname, (char const   *)name, sizeof(pname));
  }
#line 182
  if (flags___6 & 16) {
#line 183
    pname[9] = (char)0;
  }
#line 184
  if (entry->dqb_bsoftlimit) {
#line 184
    if (((entry->dqb_curspace + (qsize_t )(1 << 10)) - 1L) >> 10 >= entry->dqb_bsoftlimit) {
#line 185
      if (flags___6 & 512) {
        {
#line 186
        sprintf((char */* __restrict  */)(time___0), (char const   */* __restrict  */)"%llu",
                (unsigned long long )entry->dqb_btime);
        }
      } else {
        {
#line 188
        difftime2str(entry->dqb_btime, time___0);
        }
      }
    } else {
#line 184
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 190
  if (flags___6 & 512) {
    {
#line 191
    strcpy((char */* __restrict  */)(time___0), (char const   */* __restrict  */)"0");
    }
  } else {
#line 193
    time___0[0] = (char)0;
  }
  {
#line 194
  space2str(((entry->dqb_curspace + (qsize_t )(1 << 10)) - 1L) >> 10, numbuf[0], flags___6 & 32);
#line 195
  space2str(entry->dqb_bsoftlimit, numbuf[1], flags___6 & 32);
#line 196
  space2str(entry->dqb_bhardlimit, numbuf[2], flags___6 & 32);
#line 197
  tmp = overlim(entry->dqb_curinodes, entry->dqb_isoftlimit, entry->dqb_ihardlimit);
#line 197
  tmp___0 = overlim(((entry->dqb_curspace + (qsize_t )(1 << 10)) - 1L) >> 10, entry->dqb_bsoftlimit,
                    entry->dqb_bhardlimit);
#line 197
  printf((char const   */* __restrict  */)"%-*s %c%c %7s %7s %7s %6s", 9, pname, (int )tmp___0,
         (int )tmp, numbuf[0], numbuf[1], numbuf[2], time___0);
  }
#line 201
  if (entry->dqb_isoftlimit) {
#line 201
    if (entry->dqb_curinodes >= entry->dqb_isoftlimit) {
#line 202
      if (flags___6 & 512) {
        {
#line 203
        sprintf((char */* __restrict  */)(time___0), (char const   */* __restrict  */)"%llu",
                (unsigned long long )entry->dqb_itime);
        }
      } else {
        {
#line 205
        difftime2str(entry->dqb_itime, time___0);
        }
      }
    } else {
#line 201
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 207
  if (flags___6 & 512) {
    {
#line 208
    strcpy((char */* __restrict  */)(time___0), (char const   */* __restrict  */)"0");
    }
  } else {
#line 210
    time___0[0] = (char)0;
  }
  {
#line 211
  number2str((unsigned long long )entry->dqb_curinodes, numbuf[0], flags___6 & 32);
#line 212
  number2str((unsigned long long )entry->dqb_isoftlimit, numbuf[1], flags___6 & 32);
#line 213
  number2str((unsigned long long )entry->dqb_ihardlimit, numbuf[2], flags___6 & 32);
#line 214
  printf((char const   */* __restrict  */)" %7s %5s %5s %6s\n", numbuf[0], numbuf[1],
         numbuf[2], time___0);
  }
#line 215
  return;
}
}
#line 218 "/home/wheatley/newnew/temp/quota-4.01/repquota.c"
static void dump_cached_dquots(int type ) 
{ 
  int i ;
  char namebuf[64] ;
  struct passwd *pwent ;
  struct group *grent ;

  {
#line 223
  if (! cached_dquots) {
#line 224
    return;
  }
#line 225
  if (type == 0) {
    {
#line 228
    setpwent();
    }
    {
#line 229
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 229
      pwent = getpwent();
      }
#line 229
      if (! pwent) {
#line 229
        goto while_break;
      }
#line 230
      i = 0;
      {
#line 230
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 230
        if (i < cached_dquots) {
#line 230
          if (! (pwent->pw_uid != dquot_cache[i].dq_id)) {
#line 230
            goto while_break___0;
          }
        } else {
#line 230
          goto while_break___0;
        }
#line 230
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 231
      if (i < cached_dquots) {
#line 231
        if (! (dquot_cache[i].dq_flags & 2)) {
          {
#line 232
          print(dquot_cache + i, pwent->pw_name);
#line 233
          dquot_cache[i].dq_flags |= 2;
          }
        }
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 236
    endpwent();
    }
  } else {
    {
#line 241
    setgrent();
    }
    {
#line 242
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 242
      grent = getgrent();
      }
#line 242
      if (! grent) {
#line 242
        goto while_break___1;
      }
#line 243
      i = 0;
      {
#line 243
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 243
        if (i < cached_dquots) {
#line 243
          if (! (grent->gr_gid != dquot_cache[i].dq_id)) {
#line 243
            goto while_break___2;
          }
        } else {
#line 243
          goto while_break___2;
        }
#line 243
        i ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 244
      if (i < cached_dquots) {
#line 244
        if (! (dquot_cache[i].dq_flags & 2)) {
          {
#line 245
          print(dquot_cache + i, grent->gr_name);
#line 246
          dquot_cache[i].dq_flags |= 2;
          }
        }
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 249
    endgrent();
    }
  }
#line 251
  i = 0;
  {
#line 251
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 251
    if (! (i < cached_dquots)) {
#line 251
      goto while_break___3;
    }
#line 252
    if (! (dquot_cache[i].dq_flags & 2)) {
      {
#line 253
      sprintf((char */* __restrict  */)(namebuf), (char const   */* __restrict  */)"#%u",
              dquot_cache[i].dq_id);
#line 254
      print(dquot_cache + i, namebuf);
      }
    }
#line 251
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 256
  cached_dquots = 0;
#line 257
  return;
}
}
#line 260 "/home/wheatley/newnew/temp/quota-4.01/repquota.c"
static int output(struct dquot *dquot , char *name ) 
{ 
  char namebuf[64] ;
  char namebuf___0[64] ;
  int tmp ;

  {
#line 262
  if (flags___6 & 64) {
    {
#line 265
    sprintf((char */* __restrict  */)(namebuf), (char const   */* __restrict  */)"#%u",
            dquot->dq_id);
#line 266
    print(dquot, namebuf);
    }
  } else
#line 268
  if (name) {
#line 268
    goto _L;
  } else
#line 268
  if (flags___6 & 128) {
    _L: /* CIL Label */ 
#line 271
    if (! name) {
      {
#line 272
      id2name((int )dquot->dq_id, (dquot->dq_h)->qh_type, namebuf___0);
#line 273
      name = namebuf___0;
      }
    }
    {
#line 275
    print(dquot, name);
    }
  } else {
    {
#line 278
    tmp = cached_dquots;
#line 278
    cached_dquots ++;
#line 278
    memcpy((void */* __restrict  */)(dquot_cache + tmp), (void const   */* __restrict  */)dquot,
           sizeof(struct dquot ));
    }
#line 279
    if (cached_dquots >= 1024) {
      {
#line 280
      dump_cached_dquots((dquot->dq_h)->qh_type);
      }
    }
  }
#line 282
  return (0);
}
}
#line 286 "/home/wheatley/newnew/temp/quota-4.01/repquota.c"
static void report_it(struct quota_handle *h , int type ) 
{ 
  char bgbuf[40] ;
  char igbuf[40] ;
  char *spacehdr ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;

  {
#line 291
  if (flags___6 & 32) {
    {
#line 292
    spacehdr = gettext("Space");
    }
  } else {
    {
#line 294
    spacehdr = gettext("Block");
    }
  }
  {
#line 296
  tmp = type2name(type);
#line 296
  tmp___0 = gettext((char const   *)tmp);
#line 296
  tmp___1 = gettext("*** Report for %s quotas on device %s\n");
#line 296
  printf((char const   */* __restrict  */)tmp___1, tmp___0, h->qh_quotadev);
#line 297
  time2str(h->qh_info.dqi_bgrace, bgbuf, 1);
#line 298
  time2str(h->qh_info.dqi_igrace, igbuf, 1);
#line 299
  tmp___2 = gettext("Block grace time: %s; Inode grace time: %s\n");
#line 299
  printf((char const   */* __restrict  */)tmp___2, bgbuf, igbuf);
#line 300
  tmp___3 = gettext("                        %s limits                File limits\n");
#line 300
  printf((char const   */* __restrict  */)tmp___3, spacehdr);
  }
#line 301
  if (type == 0) {
    {
#line 301
    tmp___4 = gettext("User");
#line 301
    tmp___6 = tmp___4;
    }
  } else {
    {
#line 301
    tmp___5 = gettext("Group");
#line 301
    tmp___6 = tmp___5;
    }
  }
  {
#line 301
  tmp___7 = gettext("%-9s       used    soft    hard  grace    used  soft  hard  grace\n");
#line 301
  printf((char const   */* __restrict  */)tmp___7, tmp___6);
#line 302
  printf((char const   */* __restrict  */)"----------------------------------------------------------------------\n");
#line 304
  tmp___8 = (*((h->qh_ops)->scan_dquots))(h, & output);
  }
#line 304
  if (tmp___8 < 0) {
#line 305
    return;
  }
  {
#line 306
  dump_cached_dquots(type);
  }
#line 307
  if ((h->qh_ops)->report) {
    {
#line 308
    putchar('\n');
#line 309
    (*((h->qh_ops)->report))(h, flags___6 & 4);
#line 310
    putchar('\n');
    }
  }
#line 312
  return;
}
}
#line 314 "/home/wheatley/newnew/temp/quota-4.01/repquota.c"
static void report___0(int type ) 
{ 
  struct quota_handle **handles ;
  int i ;
  int tmp ;
  int tmp___0 ;

  {
#line 319
  if (flags___6 & 8) {
#line 320
    if (flags___6 & 256) {
#line 320
      tmp = 2;
    } else {
#line 320
      tmp = 0;
    }
    {
#line 320
    handles = create_handle_list(0, (char **)((void *)0), type, fmt___6, 3, 8 | tmp);
    }
  } else {
#line 322
    if (flags___6 & 256) {
#line 322
      tmp___0 = 2;
    } else {
#line 322
      tmp___0 = 0;
    }
    {
#line 322
    handles = create_handle_list(mntcnt___2, mnt___1, type, fmt___6, 3, 8 | tmp___0);
    }
  }
#line 323
  i = 0;
  {
#line 323
  while (1) {
    while_continue: /* CIL Label */ ;
#line 323
    if (! *(handles + i)) {
#line 323
      goto while_break;
    }
    {
#line 324
    report_it(*(handles + i), type);
#line 323
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 325
  dispose_handle_list(handles);
  }
#line 326
  return;
}
}
#line 41 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static char extensions___10[4][20]  = { {        (char )'u',        (char )'s',        (char )'e',        (char )'r', 
            (char )'\000'}, 
   {        (char )'g',        (char )'r',        (char )'o',        (char )'u', 
            (char )'p',        (char )'\000'}, 
   {        (char )'u',        (char )'n',        (char )'d',        (char )'e', 
            (char )'f',        (char )'i',        (char )'n',        (char )'e', 
            (char )'d',        (char )'\000'}};
#line 42 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static char *basenames___10[6]  = {      (char *)"quota",      (char *)"aquota",      (char *)"aquota",      (char *)"", 
        (char *)"",      (char *)""};
#line 43 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static char *fmtnames___9[5]  = {      (char *)"vfsold",      (char *)"vfsv0",      (char *)"vfsv1",      (char *)"rpc", 
        (char *)"xfs"};
#line 245 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static int kern2utilfmt___9(int kernfmt ) 
{ 


  {
  {
#line 248
  if (kernfmt == 1) {
#line 248
    goto case_1;
  }
#line 250
  if (kernfmt == 2) {
#line 250
    goto case_2;
  }
#line 252
  if (kernfmt == 4) {
#line 252
    goto case_4;
  }
#line 254
  if (kernfmt == 3) {
#line 254
    goto case_3;
  }
#line 247
  goto switch_break;
  case_1: /* CIL Label */ 
#line 249
  return (0);
  case_2: /* CIL Label */ 
#line 251
  return (1);
  case_4: /* CIL Label */ 
#line 253
  return (2);
  case_3: /* CIL Label */ 
#line 255
  return (5);
  switch_break: /* CIL Label */ ;
  }
#line 257
  return (-1);
}
}
#line 394 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static int hasxfsquota___9(char const   *dev , struct mntent *mnt___2 , int type ,
                           int flags___7 ) 
{ 
  u_int16_t sbflags ;
  struct fs_quota_stat info ;
  long tmp ;

  {
#line 399
  if (flags___7 & 16) {
#line 400
    return (4);
  }
  {
#line 402
  memset((void *)(& info), 0, sizeof(struct fs_quota_stat ));
#line 403
  tmp = quotactl((((88 << 8) + 5) << 8) | (type & 255), dev, (qid_t )0, (caddr_t )((void *)(& info)));
  }
#line 403
  if (! tmp) {
#line 404
    sbflags = (u_int16_t )(((int )info.qs_flags & 65280) >> 8);
#line 405
    if (type == 0) {
#line 405
      if ((int )info.qs_flags & 1) {
#line 406
        return (4);
      } else {
#line 405
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 407
    if (type == 1) {
#line 407
      if ((int )info.qs_flags & (1 << 2)) {
#line 408
        return (4);
      }
    }
  }
#line 424
  return (-1);
}
}
#line 427 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static int hasvfsmetaquota___9(char const   *dev , struct mntent *mnt___2 , int type ,
                               int flags___7 ) 
{ 
  uint32_t fmt___7 ;
  long tmp ;

  {
  {
#line 431
  tmp = quotactl((8388612 << 8) | (type & 255), dev, (qid_t )0, (caddr_t )((void *)(& fmt___7)));
  }
#line 431
  if (! tmp) {
#line 432
    return (5);
  }
#line 433
  return (-1);
}
}
#line 465 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static char *hasmntoptarg___9(char const   *optstring , char const   *opt ) 
{ 
  char *p ;
  char *tmp ;
  size_t tmp___0 ;

  {
  {
#line 467
  tmp = str_hasmntopt(optstring, opt);
#line 467
  p = tmp;
  }
#line 469
  if (! p) {
#line 470
    return ((char *)((void *)0));
  }
  {
#line 471
  tmp___0 = strlen(opt);
#line 471
  p += tmp___0;
  }
#line 472
  if ((int )*p == 61) {
#line 472
    if ((int )*(p + 1) != 44) {
#line 473
      return (p + 1);
    }
  }
#line 474
  return ((char *)((void *)0));
}
}
#line 478 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static void copy_mntoptarg___9(char *buf , char const   *optarg___0 , int buflen ) 
{ 
  char *sep ;
  char *tmp ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  long tmp___4 ;

  {
  {
#line 480
  tmp = strchr(optarg___0, ',');
#line 480
  sep = tmp;
  }
#line 482
  if (! sep) {
    {
#line 483
    tmp___3 = strlen(optarg___0);
    }
#line 483
    if ((size_t )buflen < tmp___3 + 1UL) {
#line 483
      tmp___2 = (size_t )buflen;
    } else {
      {
#line 483
      tmp___1 = strlen(optarg___0);
#line 483
      tmp___2 = tmp___1 + 1UL;
      }
    }
    {
#line 483
    sstrncpy(buf, optarg___0, tmp___2);
    }
  } else {
#line 485
    if ((long )buflen < (sep - (char *)optarg___0) + 1L) {
#line 485
      tmp___4 = (long )buflen;
    } else {
#line 485
      tmp___4 = (sep - (char *)optarg___0) + 1L;
    }
    {
#line 485
    sstrncpy(buf, optarg___0, (size_t )tmp___4);
    }
  }
#line 486
  return;
}
}
#line 491 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static int hasquota___9(char const   *dev , struct mntent *mnt___2 , int type , int flags___7 ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  struct if_dqinfo kinfo ;
  long tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;

  {
  {
#line 493
  tmp___0 = strcmp((char const   *)mnt___2->mnt_type, "gfs2");
  }
#line 493
  if (tmp___0) {
    {
#line 493
    tmp___1 = strcmp((char const   *)mnt___2->mnt_type, "xfs");
    }
#line 493
    if (! tmp___1) {
      {
#line 495
      tmp = hasxfsquota___9(dev, mnt___2, type, flags___7);
      }
#line 495
      return (tmp);
    }
  } else {
    {
#line 495
    tmp = hasxfsquota___9(dev, mnt___2, type, flags___7);
    }
#line 495
    return (tmp);
  }
  {
#line 496
  tmp___3 = strcmp((char const   *)mnt___2->mnt_type, "ocfs2");
  }
#line 496
  if (! tmp___3) {
    {
#line 497
    tmp___2 = hasvfsmetaquota___9(dev, mnt___2, type, flags___7);
    }
#line 497
    return (tmp___2);
  }
  {
#line 504
  tmp___5 = strcmp((char const   *)mnt___2->mnt_type, "ext4");
  }
#line 504
  if (! tmp___5) {
    {
#line 507
    tmp___4 = quotactl((8388613 << 8) | (type & 255), dev, (qid_t )0, (caddr_t )((void *)(& kinfo)));
    }
#line 507
    if (tmp___4 == 0L) {
#line 508
      if (kinfo.dqi_flags & 65536U) {
#line 509
        return (5);
      }
    }
  }
  {
#line 513
  tmp___6 = nfs_fstype(mnt___2->mnt_type);
  }
#line 513
  if (tmp___6) {
#line 514
    return (3);
  }
#line 516
  if (type == 0) {
    {
#line 516
    tmp___7 = hasmntopt((struct mntent  const  *)mnt___2, "usrquota");
    }
#line 516
    if (tmp___7) {
#line 517
      return (6);
    } else {
      {
#line 516
      tmp___8 = hasmntoptarg___9((char const   *)mnt___2->mnt_opts, "usrjquota");
      }
#line 516
      if (tmp___8) {
#line 517
        return (6);
      }
    }
  }
#line 518
  if (type == 1) {
    {
#line 518
    tmp___9 = hasmntopt((struct mntent  const  *)mnt___2, "grpquota");
    }
#line 518
    if (tmp___9) {
#line 519
      return (6);
    } else {
      {
#line 518
      tmp___10 = hasmntoptarg___9((char const   *)mnt___2->mnt_opts, "grpjquota");
      }
#line 518
      if (tmp___10) {
#line 519
        return (6);
      }
    }
  }
#line 520
  if (type == 0) {
    {
#line 520
    tmp___11 = hasmntopt((struct mntent  const  *)mnt___2, "quota");
    }
#line 520
    if (tmp___11) {
#line 521
      return (6);
    }
  }
#line 522
  return (-1);
}
}
#line 526 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static int check_fmtfile_ok___9(char *name , int type , int fmt___7 , int flags___7 ) 
{ 
  struct stat st ;
  int *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;
  int fd ;
  int ret ;
  int tmp___4 ;
  int *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  int *tmp___8 ;
  int *tmp___9 ;

  {
#line 528
  if (! flags___7) {
#line 529
    return (1);
  }
#line 530
  if (flags___7 & 1) {
    {
#line 533
    tmp___3 = stat((char const   */* __restrict  */)name, (struct stat */* __restrict  */)(& st));
    }
#line 533
    if (tmp___3 < 0) {
      {
#line 534
      tmp___2 = __errno_location();
      }
#line 534
      if (*tmp___2 != 2) {
        {
#line 535
        tmp = __errno_location();
#line 535
        tmp___0 = strerror(*tmp);
#line 535
        tmp___1 = gettext("Cannot stat quota file %s: %s\n");
#line 535
        errstr(tmp___1, name, tmp___0);
        }
      }
#line 536
      return (0);
    }
  }
#line 539
  if (flags___7 & 2) {
    {
#line 540
    ret = 0;
#line 542
    fd = open((char const   *)name, 0);
    }
#line 542
    if (fd >= 0) {
      {
#line 543
      tmp___4 = is_tree_qfmt(fmt___7);
      }
#line 543
      if (tmp___4) {
        {
#line 544
        ret = (*(quotafile_ops_2.check_file))(fd, type, fmt___7);
        }
      } else {
        {
#line 546
        ret = (*(quotafile_ops_1.check_file))(fd, type, fmt___7);
        }
      }
      {
#line 547
      close(fd);
      }
#line 548
      if (ret <= 0) {
#line 549
        return (0);
      }
    } else {
      {
#line 551
      tmp___8 = __errno_location();
      }
#line 551
      if (*tmp___8 != 2) {
        {
#line 551
        tmp___9 = __errno_location();
        }
#line 551
        if (*tmp___9 != 1) {
          {
#line 552
          tmp___5 = __errno_location();
#line 552
          tmp___6 = strerror(*tmp___5);
#line 552
          tmp___7 = gettext("Cannot open quotafile %s: %s\n");
#line 552
          errstr(tmp___7, name, tmp___6);
          }
#line 553
          return (0);
        }
      }
    }
  }
#line 556
  return (1);
}
}
#line 629 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static int hlist_allocated___9  =    0;
#line 630 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static struct quota_handle **hlist___9  =    (struct quota_handle **)((void *)0);
#line 735 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static int kernel_qfmt_num___9  ;
#line 736 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static int kernel_qfmt___9[6]  ;
#line 828 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static int v1_kern_quota_on___9(char const   *dev , int type ) 
{ 
  char tmp[1024] ;
  qid_t id___0 ;
  __uid_t tmp___0 ;
  __gid_t tmp___1 ;
  __uid_t tmp___2 ;
  long tmp___3 ;

  {
#line 831
  if (type == 0) {
    {
#line 831
    tmp___0 = getuid();
#line 831
    tmp___2 = tmp___0;
    }
  } else {
    {
#line 831
    tmp___1 = getgid();
#line 831
    tmp___2 = tmp___1;
    }
  }
  {
#line 831
  id___0 = tmp___2;
#line 833
  tmp___3 = quotactl((768 << 8) | (type & 255), dev, id___0, tmp);
  }
#line 833
  if (! tmp___3) {
#line 834
    return (1);
  }
#line 835
  return (0);
}
}
#line 839 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static int v2_kern_quota_on___9(char const   *dev , int type ) 
{ 
  char tmp[1024] ;
  qid_t id___0 ;
  __uid_t tmp___0 ;
  __gid_t tmp___1 ;
  __uid_t tmp___2 ;
  long tmp___3 ;

  {
#line 842
  if (type == 0) {
    {
#line 842
    tmp___0 = getuid();
#line 842
    tmp___2 = tmp___0;
    }
  } else {
    {
#line 842
    tmp___1 = getgid();
#line 842
    tmp___2 = tmp___1;
    }
  }
  {
#line 842
  id___0 = tmp___2;
#line 844
  tmp___3 = quotactl((3328 << 8) | (type & 255), dev, id___0, tmp);
  }
#line 844
  if (! tmp___3) {
#line 845
    return (1);
  }
#line 846
  return (0);
}
}
#line 850 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static int xfs_kern_quota_on___9(char const   *dev , int type ) 
{ 
  struct fs_quota_stat info ;
  long tmp ;

  {
  {
#line 854
  tmp = quotactl((((88 << 8) + 5) << 8) | (type & 255), dev, (qid_t )0, (caddr_t )((void *)(& info)));
  }
#line 854
  if (! tmp) {
#line 855
    if (type == 0) {
#line 855
      if ((int )info.qs_flags & 1) {
#line 856
        return (1);
      }
    }
#line 857
    if (type == 1) {
#line 857
      if ((int )info.qs_flags & (1 << 2)) {
#line 858
        return (1);
      }
    }
  }
#line 860
  return (0);
}
}
#line 921 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static int mnt_entries_cnt___9  ;
#line 922 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static struct mount_entry *mnt_entries___9  ;
#line 923 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static int check_dirs_cnt___9  ;
#line 923 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static int act_checked___9  ;
#line 924 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static struct searched_dir *check_dirs___9  ;
#line 927 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static int cache_mnt_table___9(int flags___7 ) 
{ 
  FILE *mntf ;
  struct mntent *mnt___2 ;
  struct stat st ;
  struct statfs fsstat ;
  int allocated ;
  int i ;
  dev_t dev ;
  char mntpointbuf[4096] ;
  int autofsdircnt ;
  int autofsdir_allocated ;
  char **autofsdir ;
  char *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  char const   *devname ;
  char *opt ;
  int qfmt[2] ;
  char *tmp___2 ;
  int slen ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  void *tmp___6 ;
  size_t tmp___7 ;
  void *tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char loopdev[4096] ;
  char *tmp___13 ;
  int *tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;
  int *tmp___18 ;
  char *tmp___19 ;
  char *tmp___20 ;
  int tmp___21 ;
  int *tmp___22 ;
  char *tmp___23 ;
  char *tmp___24 ;
  int tmp___25 ;
  char *tmp___26 ;
  int tmp___27 ;
  int *tmp___28 ;
  char *tmp___29 ;
  char *tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;
  void *tmp___34 ;
  char *tmp___35 ;

  {
  {
#line 933
  allocated = 0;
#line 933
  i = 0;
#line 934
  dev = (dev_t )0;
#line 940
  mntf = setmntent("/proc/mounts", "r");
  }
#line 941
  if (mntf) {
#line 942
    goto alloc;
  }
  {
#line 944
  mntf = setmntent("/etc/mtab", "r");
  }
#line 945
  if (mntf) {
#line 946
    goto alloc;
  }
  {
#line 948
  mntf = setmntent("/etc/fstab", "r");
  }
#line 948
  if (! mntf) {
    {
#line 949
    tmp = gettext("Cannot open any file with mount points.\n");
#line 949
    errstr(tmp);
    }
#line 950
    return (-1);
  }
  alloc: 
  {
#line 954
  tmp___0 = smalloc(sizeof(struct mount_entry ) * 16UL);
#line 954
  mnt_entries___9 = (struct mount_entry *)tmp___0;
#line 955
  mnt_entries_cnt___9 = 0;
#line 956
  allocated += 16;
#line 958
  tmp___1 = smalloc(sizeof(char *) * 16UL);
#line 958
  autofsdir = (char **)tmp___1;
#line 959
  autofsdircnt = 0;
#line 960
  autofsdir_allocated = 16;
  }
  {
#line 961
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 961
    mnt___2 = getmntent(mntf);
    }
#line 961
    if (! mnt___2) {
#line 961
      goto while_break;
    }
    {
#line 966
    devname = get_device_name((char const   *)mnt___2->mnt_fsname);
    }
#line 966
    if (! devname) {
      {
#line 967
      tmp___2 = gettext("Cannot get device name for %s\n");
#line 967
      errstr(tmp___2, mnt___2->mnt_fsname);
      }
#line 968
      goto while_continue;
    }
#line 972
    i = 0;
    {
#line 972
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 972
      if (! (i < autofsdircnt)) {
#line 972
        goto while_break___0;
      }
      {
#line 973
      tmp___3 = strlen((char const   *)*(autofsdir + i));
#line 973
      slen = (int )tmp___3;
#line 975
      tmp___4 = strlen((char const   *)mnt___2->mnt_dir);
      }
#line 975
      if ((size_t )slen <= tmp___4) {
        {
#line 975
        tmp___5 = strncmp((char const   *)*(autofsdir + i), (char const   *)mnt___2->mnt_dir,
                          (size_t )slen);
        }
#line 975
        if (! tmp___5) {
#line 976
          goto while_break___0;
        }
      }
#line 972
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 978
    if (i < autofsdircnt) {
      {
#line 979
      free((void *)((char *)devname));
      }
#line 980
      goto while_continue;
    }
#line 983
    if (flags___7 & 2) {
      {
#line 983
      tmp___9 = strcmp((char const   *)mnt___2->mnt_type, "autofs");
      }
#line 983
      if (! tmp___9) {
#line 984
        if (autofsdircnt == autofsdir_allocated) {
          {
#line 985
          autofsdir_allocated += 16;
#line 986
          tmp___6 = srealloc((void *)autofsdir, (unsigned long )autofsdir_allocated * sizeof(char *));
#line 986
          autofsdir = (char **)tmp___6;
          }
        }
        {
#line 988
        tmp___7 = strlen((char const   *)mnt___2->mnt_dir);
#line 988
        tmp___8 = smalloc(tmp___7 + 2UL);
#line 988
        *(autofsdir + autofsdircnt) = (char *)tmp___8;
#line 989
        strcpy((char */* __restrict  */)*(autofsdir + autofsdircnt), (char const   */* __restrict  */)mnt___2->mnt_dir);
#line 990
        strcat((char */* __restrict  */)*(autofsdir + autofsdircnt), (char const   */* __restrict  */)"/");
#line 991
        autofsdircnt ++;
#line 992
        free((void *)((char *)devname));
        }
#line 993
        goto while_continue;
      }
    }
#line 996
    if (flags___7 & 8) {
      {
#line 996
      tmp___10 = nfs_fstype(mnt___2->mnt_type);
      }
#line 996
      if (tmp___10) {
        {
#line 997
        free((void *)((char *)devname));
        }
#line 998
        goto while_continue;
      }
    }
    {
#line 1000
    tmp___11 = hasmntopt((struct mntent  const  *)mnt___2, "noquota");
    }
#line 1000
    if (tmp___11) {
      {
#line 1001
      free((void *)((char *)devname));
      }
#line 1002
      goto while_continue;
    }
    {
#line 1004
    tmp___12 = hasmntopt((struct mntent  const  *)mnt___2, "bind");
    }
#line 1004
    if (tmp___12) {
      {
#line 1005
      free((void *)((char *)devname));
      }
#line 1006
      goto while_continue;
    }
    {
#line 1008
    opt = hasmntoptarg___9((char const   *)mnt___2->mnt_opts, "loop");
    }
#line 1008
    if (opt) {
      {
#line 1011
      copy_mntoptarg___9(opt, (char const   *)(loopdev), 4096);
#line 1012
      free((void *)((char *)devname));
#line 1013
      tmp___13 = sstrdup((char const   *)(loopdev));
#line 1013
      devname = (char const   *)tmp___13;
      }
    }
    {
#line 1018
    qfmt[0] = hasquota___9(devname, mnt___2, 0, flags___7);
#line 1019
    qfmt[1] = hasquota___9(devname, mnt___2, 1, flags___7);
    }
#line 1020
    if (qfmt[0] < 0) {
#line 1020
      if (qfmt[1] < 0) {
        {
#line 1021
        free((void *)((char *)devname));
        }
#line 1022
        goto while_continue;
      }
    }
    {
#line 1025
    tmp___17 = realpath((char const   */* __restrict  */)mnt___2->mnt_dir, (char */* __restrict  */)(mntpointbuf));
    }
#line 1025
    if (! tmp___17) {
      {
#line 1026
      tmp___14 = __errno_location();
#line 1026
      tmp___15 = strerror(*tmp___14);
#line 1026
      tmp___16 = gettext("Cannot resolve mountpoint path %s: %s\n");
#line 1026
      errstr(tmp___16, mnt___2->mnt_dir, tmp___15);
#line 1027
      free((void *)((char *)devname));
      }
#line 1028
      goto while_continue;
    }
    {
#line 1031
    tmp___21 = statfs((char const   *)(mntpointbuf), & fsstat);
    }
#line 1031
    if (tmp___21 != 0) {
      {
#line 1032
      tmp___18 = __errno_location();
#line 1032
      tmp___19 = strerror(*tmp___18);
#line 1032
      tmp___20 = gettext("Cannot statfs() %s: %s\n");
#line 1032
      errstr(tmp___20, mntpointbuf, tmp___19);
#line 1033
      free((void *)((char *)devname));
      }
#line 1034
      goto while_continue;
    }
#line 1037
    if (fsstat.f_blocks == 0UL) {
#line 1037
      if (fsstat.f_bfree == 0UL) {
#line 1037
        if (fsstat.f_bavail == 0UL) {
          {
#line 1038
          free((void *)((char *)devname));
          }
#line 1039
          goto while_continue;
        }
      }
    }
    {
#line 1042
    tmp___27 = nfs_fstype(mnt___2->mnt_type);
    }
#line 1042
    if (! tmp___27) {
      {
#line 1043
      tmp___25 = stat((char const   */* __restrict  */)devname, (struct stat */* __restrict  */)(& st));
      }
#line 1043
      if (tmp___25 < 0) {
        {
#line 1044
        tmp___22 = __errno_location();
#line 1044
        tmp___23 = strerror(*tmp___22);
#line 1044
        tmp___24 = gettext("Cannot stat() mounted device %s: %s\n");
#line 1044
        errstr(tmp___24, devname, tmp___23);
#line 1045
        free((void *)((char *)devname));
        }
#line 1046
        goto while_continue;
      }
#line 1048
      if (! ((st.st_mode & 61440U) == 24576U)) {
#line 1048
        if (! ((st.st_mode & 61440U) == 8192U)) {
          {
#line 1049
          tmp___26 = gettext("Device (%s) filesystem is mounted on unsupported device type. Skipping.\n");
#line 1049
          errstr(tmp___26, devname);
#line 1050
          free((void *)((char *)devname));
          }
#line 1051
          goto while_continue;
        }
      }
#line 1053
      dev = st.st_rdev;
#line 1054
      i = 0;
      {
#line 1054
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1054
        if (i < mnt_entries_cnt___9) {
#line 1054
          if (! ((mnt_entries___9 + i)->me_dev != dev)) {
#line 1054
            goto while_break___1;
          }
        } else {
#line 1054
          goto while_break___1;
        }
#line 1054
        i ++;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
    {
#line 1057
    tmp___33 = nfs_fstype(mnt___2->mnt_type);
    }
#line 1057
    if (tmp___33) {
#line 1057
      goto _L;
    } else
#line 1057
    if (i == mnt_entries_cnt___9) {
      _L: /* CIL Label */ 
      {
#line 1058
      tmp___31 = stat((char const   */* __restrict  */)mnt___2->mnt_dir, (struct stat */* __restrict  */)(& st));
      }
#line 1058
      if (tmp___31 < 0) {
        {
#line 1059
        tmp___28 = __errno_location();
#line 1059
        tmp___29 = strerror(*tmp___28);
#line 1059
        tmp___30 = gettext("Cannot stat() mountpoint %s: %s\n");
#line 1059
        errstr(tmp___30, mnt___2->mnt_dir, tmp___29);
#line 1060
        free((void *)((char *)devname));
        }
#line 1061
        goto while_continue;
      }
      {
#line 1063
      tmp___32 = nfs_fstype(mnt___2->mnt_type);
      }
#line 1063
      if (tmp___32) {
#line 1065
        dev = st.st_dev;
#line 1066
        if (! (flags___7 & 32)) {
#line 1067
          i = 0;
          {
#line 1067
          while (1) {
            while_continue___2: /* CIL Label */ ;
#line 1067
            if (i < mnt_entries_cnt___9) {
#line 1067
              if (! ((mnt_entries___9 + i)->me_dev != dev)) {
#line 1067
                goto while_break___2;
              }
            } else {
#line 1067
              goto while_break___2;
            }
#line 1067
            i ++;
          }
          while_break___2: /* CIL Label */ ;
          }
        } else {
#line 1070
          i = mnt_entries_cnt___9;
        }
      }
    }
#line 1073
    if (i == mnt_entries_cnt___9) {
#line 1074
      if (allocated == mnt_entries_cnt___9) {
        {
#line 1075
        allocated += 16;
#line 1076
        tmp___34 = srealloc((void *)mnt_entries___9, (unsigned long )allocated * sizeof(struct mount_entry ));
#line 1076
        mnt_entries___9 = (struct mount_entry *)tmp___34;
        }
      }
      {
#line 1078
      (mnt_entries___9 + i)->me_type = sstrdup((char const   *)mnt___2->mnt_type);
#line 1079
      (mnt_entries___9 + i)->me_opts = sstrdup((char const   *)mnt___2->mnt_opts);
#line 1080
      (mnt_entries___9 + i)->me_dev = dev;
#line 1081
      (mnt_entries___9 + i)->me_ino = st.st_ino;
#line 1082
      (mnt_entries___9 + i)->me_devname = devname;
#line 1083
      tmp___35 = sstrdup((char const   *)(mntpointbuf));
#line 1083
      (mnt_entries___9 + i)->me__dir = (char const   *)tmp___35;
#line 1084
      (mnt_entries___9 + i)->me_dir = (char const   *)((void *)0);
#line 1085
      memcpy((void */* __restrict  */)(& (mnt_entries___9 + i)->me_qfmt), (void const   */* __restrict  */)(qfmt),
             sizeof(qfmt));
#line 1086
      mnt_entries_cnt___9 ++;
      }
    } else {
      {
#line 1089
      free((void *)((char *)devname));
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1091
  endmntent(mntf);
#line 1093
  i = 0;
  }
  {
#line 1093
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 1093
    if (! (i < autofsdircnt)) {
#line 1093
      goto while_break___3;
    }
    {
#line 1094
    free((void *)*(autofsdir + i));
#line 1093
    i ++;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 1095
  free((void *)autofsdir);
  }
#line 1096
  return (0);
}
}
#line 1100 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static char const   *find_dir_mntpoint___9(struct stat *st ) 
{ 
  int i ;

  {
#line 1104
  i = 0;
  {
#line 1104
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1104
    if (! (i < mnt_entries_cnt___9)) {
#line 1104
      goto while_break;
    }
#line 1105
    if ((mnt_entries___9 + i)->me_dev == st->st_dev) {
#line 1106
      st->st_ino = (mnt_entries___9 + i)->me_ino;
#line 1107
      return ((mnt_entries___9 + i)->me__dir);
    }
#line 1104
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1109
  return ((char const   *)((void *)0));
}
}
#line 1113 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static int process_dirs___9(int dcnt , char **dirs , int flags___7 ) 
{ 
  struct stat st ;
  int i ;
  char mntpointbuf[4096] ;
  void *tmp ;
  char *devname ;
  char const   *tmp___0 ;
  char *tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  int *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  char const   *realmnt ;
  char *tmp___12 ;
  int *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  int mentry ;
  char *tmp___17 ;
  char *tmp___18 ;
  char *tmp___19 ;
  char *tmp___20 ;

  {
#line 1119
  check_dirs_cnt___9 = 0;
#line 1120
  act_checked___9 = -1;
#line 1121
  if (dcnt) {
    {
#line 1122
    tmp = smalloc(sizeof(struct searched_dir ) * (unsigned long )dcnt);
#line 1122
    check_dirs___9 = (struct searched_dir *)tmp;
#line 1123
    i = 0;
    }
    {
#line 1123
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1123
      if (! (i < dcnt)) {
#line 1123
        goto while_break;
      }
      {
#line 1124
      tmp___10 = strncmp((char const   *)*(dirs + i), "UUID=", (size_t )5);
      }
#line 1124
      if (tmp___10) {
        {
#line 1124
        tmp___11 = strncmp((char const   *)*(dirs + i), "LABEL=", (size_t )6);
        }
#line 1124
        if (tmp___11) {
          {
#line 1139
          tmp___9 = stat((char const   */* __restrict  */)*(dirs + i), (struct stat */* __restrict  */)(& st));
          }
#line 1139
          if (tmp___9 < 0) {
            {
#line 1140
            tmp___6 = __errno_location();
#line 1140
            tmp___7 = strerror(*tmp___6);
#line 1140
            tmp___8 = gettext("Cannot stat() given mountpoint %s: %s\nSkipping...\n");
#line 1140
            errstr(tmp___8, *(dirs + i), tmp___7);
            }
#line 1141
            goto __Cont;
          }
        } else {
          _L: /* CIL Label */ 
          {
#line 1125
          tmp___0 = get_device_name((char const   *)*(dirs + i));
#line 1125
          devname = (char *)tmp___0;
          }
#line 1127
          if (! devname) {
            {
#line 1128
            tmp___1 = gettext("Cannot find a device with %s.\nSkipping...\n");
#line 1128
            errstr(tmp___1, *(dirs + i));
            }
#line 1129
            goto __Cont;
          }
          {
#line 1131
          tmp___5 = stat((char const   */* __restrict  */)devname, (struct stat */* __restrict  */)(& st));
          }
#line 1131
          if (tmp___5 < 0) {
            {
#line 1132
            tmp___2 = __errno_location();
#line 1132
            tmp___3 = strerror(*tmp___2);
#line 1132
            tmp___4 = gettext("Cannot stat() a mountpoint with %s: %s\nSkipping...\n");
#line 1132
            errstr(tmp___4, *(dirs + i), tmp___3);
#line 1133
            free((void *)devname);
            }
#line 1134
            goto __Cont;
          }
          {
#line 1136
          free((void *)devname);
          }
        }
      } else {
#line 1124
        goto _L;
      }
#line 1143
      (check_dirs___9 + check_dirs_cnt___9)->sd_dir = (st.st_mode & 61440U) == 16384U;
#line 1144
      if ((st.st_mode & 61440U) == 16384U) {
#line 1145
        realmnt = (char const   *)*(dirs + i);
#line 1148
        if (flags___7 & 1) {
          {
#line 1148
          realmnt = find_dir_mntpoint___9(& st);
          }
#line 1148
          if (! realmnt) {
#line 1149
            if (! (flags___7 & 4)) {
              {
#line 1150
              tmp___12 = gettext("Cannot find a filesystem mountpoint for directory %s\n");
#line 1150
              errstr(tmp___12, *(dirs + i));
              }
            }
#line 1151
            goto __Cont;
          }
        }
        {
#line 1153
        (check_dirs___9 + check_dirs_cnt___9)->sd_dev = st.st_dev;
#line 1154
        (check_dirs___9 + check_dirs_cnt___9)->sd_ino = st.st_ino;
#line 1155
        tmp___16 = realpath((char const   */* __restrict  */)realmnt, (char */* __restrict  */)(mntpointbuf));
        }
#line 1155
        if (! tmp___16) {
          {
#line 1156
          tmp___13 = __errno_location();
#line 1156
          tmp___14 = strerror(*tmp___13);
#line 1156
          tmp___15 = gettext("Cannot resolve path %s: %s\n");
#line 1156
          errstr(tmp___15, realmnt, tmp___14);
          }
#line 1157
          goto __Cont;
        }
      } else
#line 1160
      if ((st.st_mode & 61440U) == 24576U) {
#line 1160
        goto _L___0;
      } else
#line 1160
      if ((st.st_mode & 61440U) == 8192U) {
        _L___0: /* CIL Label */ 
#line 1163
        (check_dirs___9 + check_dirs_cnt___9)->sd_dev = st.st_rdev;
#line 1164
        mentry = 0;
        {
#line 1164
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 1164
          if (mentry < mnt_entries_cnt___9) {
#line 1164
            if (! ((mnt_entries___9 + mentry)->me_dev != st.st_rdev)) {
#line 1164
              goto while_break___0;
            }
          } else {
#line 1164
            goto while_break___0;
          }
#line 1164
          mentry ++;
        }
        while_break___0: /* CIL Label */ ;
        }
#line 1165
        if (mentry == mnt_entries_cnt___9) {
#line 1166
          if (! (flags___7 & 4)) {
            {
#line 1167
            tmp___17 = gettext("Cannot find mountpoint for device %s\n");
#line 1167
            errstr(tmp___17, *(dirs + i));
            }
          }
#line 1168
          goto __Cont;
        }
        {
#line 1170
        sstrncpy(mntpointbuf, (mnt_entries___9 + mentry)->me__dir, (size_t )4095);
        }
      } else {
        {
#line 1173
        tmp___18 = gettext("Specified path %s is not directory nor device.\n");
#line 1173
        errstr(tmp___18, *(dirs + i));
        }
#line 1174
        goto __Cont;
      }
      {
#line 1176
      tmp___19 = sstrdup((char const   *)(mntpointbuf));
#line 1176
      (check_dirs___9 + check_dirs_cnt___9)->sd_name = (char const   *)tmp___19;
#line 1177
      check_dirs_cnt___9 ++;
      }
      __Cont: /* CIL Label */ 
#line 1123
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 1179
    if (! check_dirs_cnt___9) {
#line 1180
      if (! (flags___7 & 4)) {
        {
#line 1181
        tmp___20 = gettext("No correct mountpoint specified.\n");
#line 1181
        errstr(tmp___20);
        }
      }
      {
#line 1182
      free((void *)check_dirs___9);
      }
#line 1183
      return (-1);
    }
  }
#line 1186
  return (0);
}
}
#line 1204 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static int find_next_entry_all___9(int *pos ) 
{ 
  char *tmp ;

  {
  {
#line 1206
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1206
    act_checked___9 ++;
#line 1206
    if (! (act_checked___9 < mnt_entries_cnt___9)) {
#line 1206
      goto while_break;
    }
    {
#line 1207
    tmp = str_hasmntopt((char const   *)(mnt_entries___9 + act_checked___9)->me_opts,
                        "noauto");
    }
#line 1207
    if (! tmp) {
#line 1208
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1210
  if (act_checked___9 >= mnt_entries_cnt___9) {
#line 1211
    return (0);
  }
#line 1212
  *pos = act_checked___9;
#line 1213
  return (1);
}
}
#line 1217 "/home/wheatley/newnew/temp/quota-4.01/quotasys.c"
static int find_next_entry_sel___9(int *pos ) 
{ 
  int i ;
  struct searched_dir *sd ;
  char *tmp ;

  {
  restart: 
#line 1223
  act_checked___9 ++;
#line 1223
  if (act_checked___9 == check_dirs_cnt___9) {
#line 1224
    return (0);
  }
#line 1225
  sd = check_dirs___9 + act_checked___9;
#line 1226
  i = 0;
  {
#line 1226
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1226
    if (! (i < mnt_entries_cnt___9)) {
#line 1226
      goto while_break;
    }
#line 1227
    if (sd->sd_dir) {
#line 1228
      if (sd->sd_dev == (mnt_entries___9 + i)->me_dev) {
#line 1228
        if (sd->sd_ino == (mnt_entries___9 + i)->me_ino) {
#line 1229
          goto while_break;
        }
      }
    } else
#line 1232
    if (sd->sd_dev == (mnt_entries___9 + i)->me_dev) {
#line 1233
      goto while_break;
    }
#line 1226
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1235
  if (i == mnt_entries_cnt___9) {
    {
#line 1236
    tmp = gettext("Mountpoint (or device) %s not found or has no quota enabled.\n");
#line 1236
    errstr(tmp, sd->sd_name);
    }
#line 1237
    goto restart;
  }
#line 1239
  *pos = i;
#line 1240
  return (1);
}
}
#line 45 "/home/wheatley/newnew/temp/quota-4.01/quotaio_tree.c"
static int get_index___9(qid_t id___0 , int depth ) 
{ 


  {
#line 47
  return ((int )((id___0 >> ((4 - depth) - 1) * 8) & 255U));
}
}
#line 51 "/home/wheatley/newnew/temp/quota-4.01/quotaio_tree.c"
static void read_blk___10(struct quota_handle *h , uint blk , dqbuf_t buf ) 
{ 
  int err ;
  ssize_t tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 55
  lseek(h->qh_fd, (__off64_t )(blk << 10), 0);
#line 56
  tmp = read(h->qh_fd, (void *)buf, (size_t )(1 << 10));
#line 56
  err = (int )tmp;
  }
#line 57
  if (err < 0) {
    {
#line 58
    tmp___0 = __errno_location();
#line 58
    tmp___1 = strerror(*tmp___0);
#line 58
    tmp___2 = gettext("Cannot read block %u: %s\n");
#line 58
    die(2, tmp___2, blk, tmp___1);
    }
  } else
#line 59
  if (err != 1 << 10) {
    {
#line 60
    memset((void *)(buf + err), 0, (size_t )((1 << 10) - err));
    }
  }
#line 61
  return;
}
}
#line 64 "/home/wheatley/newnew/temp/quota-4.01/quotaio_tree.c"
static int write_blk___9(struct quota_handle *h , uint blk , dqbuf_t buf ) 
{ 
  int err ;
  ssize_t tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  int *tmp___3 ;

  {
  {
#line 68
  lseek(h->qh_fd, (__off64_t )(blk << 10), 0);
#line 69
  tmp = write(h->qh_fd, (void const   *)buf, (size_t )(1 << 10));
#line 69
  err = (int )tmp;
  }
#line 70
  if (err < 0) {
    {
#line 70
    tmp___3 = __errno_location();
    }
#line 70
    if (*tmp___3 != 28) {
      {
#line 71
      tmp___0 = __errno_location();
#line 71
      tmp___1 = strerror(*tmp___0);
#line 71
      tmp___2 = gettext("Cannot write block (%u): %s\n");
#line 71
      die(2, tmp___2, blk, tmp___1);
      }
    }
  }
#line 72
  if (err != 1 << 10) {
#line 73
    return (-28);
  }
#line 74
  return (0);
}
}
#line 78 "/home/wheatley/newnew/temp/quota-4.01/quotaio_tree.c"
static int get_free_dqblk___9(struct quota_handle *h ) 
{ 
  dqbuf_t buf ;
  void *tmp ;
  struct qt_disk_dqdbheader *dh ;
  struct qtree_mem_dqinfo *info ;
  int blk ;
  char *tmp___0 ;
  int tmp___1 ;
  unsigned int tmp___2 ;

  {
  {
#line 80
  tmp = smalloc((size_t )(1 << 10));
#line 80
  buf = (dqbuf_t )tmp;
#line 81
  dh = (struct qt_disk_dqdbheader *)buf;
#line 82
  info = & h->qh_info.u.v2_mdqi.dqi_qtree;
  }
#line 85
  if (info->dqi_free_blk) {
    {
#line 86
    blk = (int )info->dqi_free_blk;
#line 87
    read_blk___10(h, (uint )blk, buf);
#line 88
    info->dqi_free_blk = dh->dqdh_next_free;
    }
  } else {
    {
#line 91
    memset((void *)buf, 0, (size_t )(1 << 10));
#line 92
    tmp___1 = write_blk___9(h, info->dqi_blocks, buf);
    }
#line 92
    if (tmp___1 < 0) {
      {
#line 93
      free((void *)buf);
#line 94
      tmp___0 = gettext("Cannot allocate new quota block (out of disk space).\n");
#line 94
      errstr(tmp___0);
      }
#line 95
      return (-28);
    }
#line 97
    tmp___2 = info->dqi_blocks;
#line 97
    (info->dqi_blocks) ++;
#line 97
    blk = (int )tmp___2;
  }
  {
#line 99
  mark_quotafile_info_dirty(h);
#line 100
  free((void *)buf);
  }
#line 101
  return (blk);
}
}
#line 105 "/home/wheatley/newnew/temp/quota-4.01/quotaio_tree.c"
static void put_free_dqblk___9(struct quota_handle *h , dqbuf_t buf , uint blk ) 
{ 
  struct qt_disk_dqdbheader *dh ;
  struct qtree_mem_dqinfo *info ;

  {
  {
#line 107
  dh = (struct qt_disk_dqdbheader *)buf;
#line 108
  info = & h->qh_info.u.v2_mdqi.dqi_qtree;
#line 110
  dh->dqdh_next_free = info->dqi_free_blk;
#line 111
  dh->dqdh_prev_free = (__u32 )0;
#line 112
  dh->dqdh_entries = (__u16 )0;
#line 113
  info->dqi_free_blk = blk;
#line 114
  mark_quotafile_info_dirty(h);
#line 115
  write_blk___9(h, blk, buf);
  }
#line 116
  return;
}
}
#line 119 "/home/wheatley/newnew/temp/quota-4.01/quotaio_tree.c"
static void remove_free_dqentry___9(struct quota_handle *h , dqbuf_t buf , uint blk ) 
{ 
  dqbuf_t tmpbuf ;
  void *tmp ;
  struct qt_disk_dqdbheader *dh ;
  uint nextblk ;
  uint prevblk ;
  u_int32_t tmp___0 ;

  {
  {
#line 121
  tmp = smalloc((size_t )(1 << 10));
#line 121
  tmpbuf = (dqbuf_t )tmp;
#line 122
  dh = (struct qt_disk_dqdbheader *)buf;
#line 123
  nextblk = dh->dqdh_next_free;
#line 123
  prevblk = dh->dqdh_prev_free;
  }
#line 127
  if (nextblk) {
    {
#line 128
    read_blk___10(h, nextblk, tmpbuf);
#line 129
    ((struct qt_disk_dqdbheader *)tmpbuf)->dqdh_prev_free = dh->dqdh_prev_free;
#line 130
    write_blk___9(h, nextblk, tmpbuf);
    }
  }
#line 132
  if (prevblk) {
    {
#line 133
    read_blk___10(h, prevblk, tmpbuf);
#line 134
    ((struct qt_disk_dqdbheader *)tmpbuf)->dqdh_next_free = dh->dqdh_next_free;
#line 135
    write_blk___9(h, prevblk, tmpbuf);
    }
  } else {
    {
#line 138
    h->qh_info.u.v2_mdqi.dqi_qtree.dqi_free_entry = nextblk;
#line 139
    mark_quotafile_info_dirty(h);
    }
  }
  {
#line 141
  free((void *)tmpbuf);
#line 142
  tmp___0 = (__u32 )0;
#line 142
  dh->dqdh_prev_free = tmp___0;
#line 142
  dh->dqdh_next_free = tmp___0;
#line 143
  write_blk___9(h, blk, buf);
  }
#line 144
  return;
}
}
#line 147 "/home/wheatley/newnew/temp/quota-4.01/quotaio_tree.c"
static void insert_free_dqentry___9(struct quota_handle *h , dqbuf_t buf , uint blk ) 
{ 
  dqbuf_t tmpbuf ;
  void *tmp ;
  struct qt_disk_dqdbheader *dh ;
  struct qtree_mem_dqinfo *info ;

  {
  {
#line 149
  tmp = smalloc((size_t )(1 << 10));
#line 149
  tmpbuf = (dqbuf_t )tmp;
#line 150
  dh = (struct qt_disk_dqdbheader *)buf;
#line 151
  info = & h->qh_info.u.v2_mdqi.dqi_qtree;
#line 153
  dh->dqdh_next_free = info->dqi_free_entry;
#line 154
  dh->dqdh_prev_free = (__u32 )0;
#line 155
  write_blk___9(h, blk, buf);
  }
#line 156
  if (info->dqi_free_entry) {
    {
#line 157
    read_blk___10(h, info->dqi_free_entry, tmpbuf);
#line 158
    ((struct qt_disk_dqdbheader *)tmpbuf)->dqdh_prev_free = blk;
#line 159
    write_blk___9(h, info->dqi_free_entry, tmpbuf);
    }
  }
  {
#line 161
  free((void *)tmpbuf);
#line 162
  info->dqi_free_entry = blk;
#line 163
  mark_quotafile_info_dirty(h);
  }
#line 164
  return;
}
}
#line 167 "/home/wheatley/newnew/temp/quota-4.01/quotaio_tree.c"
static uint find_free_dqentry___9(struct quota_handle *h , struct dquot *dquot , int *err ) 
{ 
  int blk ;
  int i ;
  struct qt_disk_dqdbheader *dh ;
  struct qtree_mem_dqinfo *info ;
  char *ddquot ;
  dqbuf_t buf ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;

  {
  {
#line 171
  info = & h->qh_info.u.v2_mdqi.dqi_qtree;
#line 175
  *err = 0;
#line 176
  tmp = smalloc((size_t )(1 << 10));
#line 176
  buf = (dqbuf_t )tmp;
#line 177
  dh = (struct qt_disk_dqdbheader *)buf;
  }
#line 178
  if (info->dqi_free_entry) {
    {
#line 179
    blk = (int )info->dqi_free_entry;
#line 180
    read_blk___10(h, (uint )blk, buf);
    }
  } else {
    {
#line 183
    blk = get_free_dqblk___9(h);
    }
#line 184
    if (blk < 0) {
      {
#line 185
      free((void *)buf);
#line 186
      *err = blk;
      }
#line 187
      return ((uint )0);
    }
    {
#line 189
    memset((void *)buf, 0, (size_t )(1 << 10));
#line 190
    info->dqi_free_entry = (unsigned int )blk;
#line 191
    mark_quotafile_info_dirty(h);
    }
  }
  {
#line 193
  tmp___0 = qtree_dqstr_in_blk(info);
  }
#line 193
  if ((int )dh->dqdh_entries + 1 >= tmp___0) {
    {
#line 194
    remove_free_dqentry___9(h, buf, (uint )blk);
    }
  }
#line 195
  dh->dqdh_entries = (__u16 )((int )dh->dqdh_entries + 1);
#line 197
  ddquot = buf + sizeof(struct qt_disk_dqdbheader );
#line 198
  i = 0;
  {
#line 198
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 198
    tmp___1 = qtree_dqstr_in_blk(info);
    }
#line 198
    if (i < tmp___1) {
      {
#line 198
      tmp___2 = qtree_entry_unused(info, ddquot);
      }
#line 198
      if (tmp___2) {
#line 198
        goto while_break;
      }
    } else {
#line 198
      goto while_break;
    }
#line 198
    i ++;
#line 198
    ddquot += info->dqi_entry_size;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 201
  tmp___4 = qtree_dqstr_in_blk(info);
  }
#line 201
  if (i == tmp___4) {
    {
#line 202
    tmp___3 = gettext("find_free_dqentry(): Data block full but it shouldn\'t.\n");
#line 202
    die(2, tmp___3);
    }
  }
  {
#line 203
  write_blk___9(h, (uint )blk, buf);
#line 204
  dquot->dq_dqb.u.v2_mdqb.dqb_off = (loff_t )(((unsigned long )(blk << 10) + sizeof(struct qt_disk_dqdbheader )) + (unsigned long )((unsigned int )i * info->dqi_entry_size));
#line 207
  free((void *)buf);
  }
#line 208
  return ((uint )blk);
}
}
#line 212 "/home/wheatley/newnew/temp/quota-4.01/quotaio_tree.c"
static int do_insert_tree___9(struct quota_handle *h , struct dquot *dquot , uint *treeblk ,
                              int depth ) 
{ 
  dqbuf_t buf ;
  int newson ;
  int newact ;
  u_int32_t *ref ;
  uint newblk ;
  int ret ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;

  {
  {
#line 215
  newson = 0;
#line 215
  newact = 0;
#line 218
  ret = 0;
#line 220
  tmp = smalloc((size_t )(1 << 10));
#line 220
  buf = (dqbuf_t )tmp;
  }
#line 221
  if (! *treeblk) {
    {
#line 222
    ret = get_free_dqblk___9(h);
    }
#line 223
    if (ret < 0) {
#line 224
      goto out_buf;
    }
    {
#line 225
    *treeblk = (uint )ret;
#line 226
    memset((void *)buf, 0, (size_t )(1 << 10));
#line 227
    newact = 1;
    }
  } else {
    {
#line 230
    read_blk___10(h, *treeblk, buf);
    }
  }
  {
#line 231
  ref = (u_int32_t *)buf;
#line 232
  tmp___0 = get_index___9(dquot->dq_id, depth);
#line 232
  newblk = *(ref + tmp___0);
  }
#line 233
  if (! newblk) {
#line 234
    newson = 1;
  }
#line 235
  if (depth == 3) {
#line 236
    if (newblk) {
      {
#line 237
      tmp___1 = get_index___9(dquot->dq_id, depth);
#line 237
      tmp___2 = gettext("Inserting already present quota entry (block %u).\n");
#line 237
      die(2, tmp___2, *(ref + tmp___1));
      }
    }
    {
#line 239
    newblk = find_free_dqentry___9(h, dquot, & ret);
    }
  } else {
    {
#line 242
    ret = do_insert_tree___9(h, dquot, & newblk, depth + 1);
    }
  }
#line 243
  if (newson) {
#line 243
    if (ret >= 0) {
      {
#line 244
      tmp___3 = get_index___9(dquot->dq_id, depth);
#line 244
      *(ref + tmp___3) = newblk;
#line 245
      write_blk___9(h, *treeblk, buf);
      }
    } else {
#line 243
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 247
  if (newact) {
#line 247
    if (ret < 0) {
      {
#line 248
      put_free_dqblk___9(h, buf, *treeblk);
      }
    }
  }
  out_buf: 
  {
#line 250
  free((void *)buf);
  }
#line 251
  return (ret);
}
}
#line 255 "/home/wheatley/newnew/temp/quota-4.01/quotaio_tree.c"
static void dq_insert_tree___9(struct quota_handle *h , struct dquot *dquot ) 
{ 
  uint tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;

  {
  {
#line 257
  tmp = (uint )1;
#line 259
  tmp___3 = do_insert_tree___9(h, dquot, & tmp, 0);
  }
#line 259
  if (tmp___3 < 0) {
    {
#line 260
    tmp___0 = __errno_location();
#line 260
    tmp___1 = strerror(*tmp___0);
#line 260
    tmp___2 = gettext("Cannot write quota (id %u): %s\n");
#line 260
    die(2, tmp___2, dquot->dq_id, tmp___1);
    }
  }
#line 261
  return;
}
}
#line 284 "/home/wheatley/newnew/temp/quota-4.01/quotaio_tree.c"
static void free_dqentry___9(struct quota_handle *h , struct dquot *dquot , uint blk ) 
{ 
  struct qt_disk_dqdbheader *dh ;
  struct qtree_mem_dqinfo *info ;
  dqbuf_t buf ;
  void *tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 287
  info = & h->qh_info.u.v2_mdqi.dqi_qtree;
#line 288
  tmp = smalloc((size_t )(1 << 10));
#line 288
  buf = (dqbuf_t )tmp;
  }
#line 290
  if (dquot->dq_dqb.u.v2_mdqb.dqb_off >> 10 != (loff_t )blk) {
    {
#line 291
    tmp___0 = gettext("Quota structure has offset to other block (%u) than it should (%u).\n");
#line 291
    die(2, tmp___0, blk, (uint )(dquot->dq_dqb.u.v2_mdqb.dqb_off >> 10));
    }
  }
  {
#line 293
  read_blk___10(h, blk, buf);
#line 294
  dh = (struct qt_disk_dqdbheader *)buf;
#line 295
  dh->dqdh_entries = (__u16 )((int )dh->dqdh_entries - 1);
  }
#line 296
  if (! dh->dqdh_entries) {
    {
#line 297
    remove_free_dqentry___9(h, buf, blk);
#line 298
    put_free_dqblk___9(h, buf, blk);
    }
  } else {
    {
#line 301
    memset((void *)(buf + (dquot->dq_dqb.u.v2_mdqb.dqb_off & (long )((1 << 10) - 1))),
           0, (size_t )info->dqi_entry_size);
#line 304
    tmp___1 = qtree_dqstr_in_blk(info);
    }
#line 304
    if ((int )dh->dqdh_entries == tmp___1 - 1) {
      {
#line 305
      insert_free_dqentry___9(h, buf, blk);
      }
    } else {
      {
#line 307
      write_blk___9(h, blk, buf);
      }
    }
  }
  {
#line 309
  dquot->dq_dqb.u.v2_mdqb.dqb_off = (loff_t )0;
#line 310
  free((void *)buf);
  }
#line 311
  return;
}
}
#line 314 "/home/wheatley/newnew/temp/quota-4.01/quotaio_tree.c"
static void remove_tree___9(struct quota_handle *h , struct dquot *dquot , uint *blk ,
                            int depth ) 
{ 
  dqbuf_t buf ;
  void *tmp ;
  uint newblk ;
  u_int32_t *ref ;
  int tmp___0 ;
  int i ;
  int tmp___1 ;

  {
  {
#line 316
  tmp = smalloc((size_t )(1 << 10));
#line 316
  buf = (dqbuf_t )tmp;
#line 318
  ref = (u_int32_t *)buf;
#line 320
  read_blk___10(h, *blk, buf);
#line 321
  tmp___0 = get_index___9(dquot->dq_id, depth);
#line 321
  newblk = *(ref + tmp___0);
  }
#line 322
  if (depth == 3) {
    {
#line 323
    free_dqentry___9(h, dquot, newblk);
#line 324
    newblk = (uint )0;
    }
  } else {
    {
#line 327
    remove_tree___9(h, dquot, & newblk, depth + 1);
    }
  }
#line 328
  if (! newblk) {
    {
#line 331
    tmp___1 = get_index___9(dquot->dq_id, depth);
#line 331
    *(ref + tmp___1) = (__u32 )0;
#line 332
    i = 0;
    }
    {
#line 332
    while (1) {
      while_continue: /* CIL Label */ ;
#line 332
      if (i < 1 << 10) {
#line 332
        if (! (! *(buf + i))) {
#line 332
          goto while_break;
        }
      } else {
#line 332
        goto while_break;
      }
#line 332
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 334
    if (i == 1 << 10) {
#line 334
      if (*blk != 1U) {
        {
#line 335
        put_free_dqblk___9(h, buf, *blk);
#line 336
        *blk = (uint )0;
        }
      } else {
        {
#line 339
        write_blk___9(h, *blk, buf);
        }
      }
    } else {
      {
#line 339
      write_blk___9(h, *blk, buf);
      }
    }
  }
  {
#line 341
  free((void *)buf);
  }
#line 342
  return;
}
}
#line 355 "/home/wheatley/newnew/temp/quota-4.01/quotaio_tree.c"
static loff_t find_block_dqentry___9(struct quota_handle *h , struct dquot *dquot ,
                                     uint blk ) 
{ 
  struct qtree_mem_dqinfo *info ;
  dqbuf_t buf ;
  void *tmp ;
  int i ;
  char *ddquot ;
  int tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;

  {
  {
#line 357
  info = & h->qh_info.u.v2_mdqi.dqi_qtree;
#line 358
  tmp = smalloc((size_t )(1 << 10));
#line 358
  buf = (dqbuf_t )tmp;
#line 360
  ddquot = buf + sizeof(struct qt_disk_dqdbheader );
#line 362
  read_blk___10(h, blk, buf);
#line 363
  i = 0;
  }
  {
#line 363
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 363
    tmp___0 = qtree_dqstr_in_blk(info);
    }
#line 363
    if (i < tmp___0) {
      {
#line 363
      tmp___1 = (*((info->dqi_ops)->is_id))((void *)ddquot, dquot);
      }
#line 363
      if (tmp___1) {
#line 363
        goto while_break;
      }
    } else {
#line 363
      goto while_break;
    }
#line 363
    i ++;
#line 363
    ddquot += info->dqi_entry_size;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 366
  tmp___3 = qtree_dqstr_in_blk(info);
  }
#line 366
  if (i == tmp___3) {
    {
#line 367
    tmp___2 = gettext("Quota for id %u referenced but not present.\n");
#line 367
    die(2, tmp___2, dquot->dq_id);
    }
  }
  {
#line 368
  free((void *)buf);
  }
#line 369
  return ((loff_t )(((unsigned long )(blk << 10) + sizeof(struct qt_disk_dqdbheader )) + (unsigned long )((unsigned int )i * info->dqi_entry_size)));
}
}
#line 374 "/home/wheatley/newnew/temp/quota-4.01/quotaio_tree.c"
static loff_t find_tree_dqentry___9(struct quota_handle *h , struct dquot *dquot ,
                                    uint blk , int depth ) 
{ 
  dqbuf_t buf ;
  void *tmp ;
  loff_t ret ;
  u_int32_t *ref ;
  int tmp___0 ;

  {
  {
#line 376
  tmp = smalloc((size_t )(1 << 10));
#line 376
  buf = (dqbuf_t )tmp;
#line 377
  ret = (loff_t )0;
#line 378
  ref = (u_int32_t *)buf;
#line 380
  read_blk___10(h, blk, buf);
#line 381
  ret = (loff_t )0;
#line 382
  tmp___0 = get_index___9(dquot->dq_id, depth);
#line 382
  blk = *(ref + tmp___0);
  }
#line 383
  if (! blk) {
#line 384
    goto out_buf;
  }
#line 385
  if (depth < 3) {
    {
#line 386
    ret = find_tree_dqentry___9(h, dquot, blk, depth + 1);
    }
  } else {
    {
#line 388
    ret = find_block_dqentry___9(h, dquot, blk);
    }
  }
  out_buf: 
  {
#line 390
  free((void *)buf);
  }
#line 391
  return (ret);
}
}
#line 395 "/home/wheatley/newnew/temp/quota-4.01/quotaio_tree.c"
__inline static loff_t find_dqentry___9(struct quota_handle *h , struct dquot *dquot ) 
{ 
  loff_t tmp ;

  {
  {
#line 397
  tmp = find_tree_dqentry___9(h, dquot, (uint )1, 0);
  }
#line 397
  return (tmp);
}
}
#line 441 "/home/wheatley/newnew/temp/quota-4.01/quotaio_tree.c"
static int report_block___9(struct dquot *dquot , uint blk , char *bitmap , int (*process_dquot)(struct dquot * ,
                                                                                                 char * ) ) 
{ 
  struct qtree_mem_dqinfo *info ;
  dqbuf_t buf ;
  void *tmp ;
  struct qt_disk_dqdbheader *dh ;
  char *ddata ;
  int entries ;
  int i ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 444
  info = & (dquot->dq_h)->qh_info.u.v2_mdqi.dqi_qtree;
#line 445
  tmp = smalloc((size_t )(1 << 10));
#line 445
  buf = (dqbuf_t )tmp;
#line 450
  *(bitmap + (blk >> 3)) = (char )((int )*(bitmap + (blk >> 3)) | (1 << (blk & 7U)));
#line 451
  read_blk___10(dquot->dq_h, blk, buf);
#line 452
  dh = (struct qt_disk_dqdbheader *)buf;
#line 453
  ddata = buf + sizeof(struct qt_disk_dqdbheader );
#line 454
  entries = (int )dh->dqdh_entries;
#line 455
  i = 0;
  }
  {
#line 455
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 455
    tmp___2 = qtree_dqstr_in_blk(info);
    }
#line 455
    if (! (i < tmp___2)) {
#line 455
      goto while_break;
    }
    {
#line 456
    tmp___1 = qtree_entry_unused(info, ddata);
    }
#line 456
    if (! tmp___1) {
      {
#line 457
      (*((info->dqi_ops)->disk2mem_dqblk))(dquot, (void *)ddata);
#line 458
      tmp___0 = (*process_dquot)(dquot, (char *)((void *)0));
      }
#line 458
      if (tmp___0 < 0) {
#line 459
        goto while_break;
      }
    }
#line 455
    i ++;
#line 455
    ddata += info->dqi_entry_size;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 461
  free((void *)buf);
  }
#line 462
  return (entries);
}
}
#line 465 "/home/wheatley/newnew/temp/quota-4.01/quotaio_tree.c"
static void check_reference___9(struct quota_handle *h , uint blk ) 
{ 
  char *tmp ;
  char *tmp___0 ;

  {
#line 467
  if (blk >= h->qh_info.u.v2_mdqi.dqi_qtree.dqi_blocks) {
    {
#line 468
    tmp = type2name(h->qh_type);
#line 468
    tmp___0 = gettext("Illegal reference (%u >= %u) in %s quota file on %s. Quota file is probably corrupted.\nPlease run quotacheck(8) and try again.\n");
#line 468
    die(2, tmp___0, blk, h->qh_info.u.v2_mdqi.dqi_qtree.dqi_blocks, tmp, h->qh_quotadev);
    }
  }
#line 469
  return;
}
}
#line 471 "/home/wheatley/newnew/temp/quota-4.01/quotaio_tree.c"
static int report_tree___9(struct dquot *dquot , uint blk , int depth , char *bitmap ,
                           int (*process_dquot)(struct dquot * , char * ) ) 
{ 
  int entries ;
  int i ;
  dqbuf_t buf ;
  void *tmp ;
  u_int32_t *ref ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 474
  entries = 0;
#line 475
  tmp = smalloc((size_t )(1 << 10));
#line 475
  buf = (dqbuf_t )tmp;
#line 476
  ref = (u_int32_t *)buf;
#line 478
  read_blk___10(dquot->dq_h, blk, buf);
  }
#line 479
  if (depth == 3) {
#line 480
    i = 0;
    {
#line 480
    while (1) {
      while_continue: /* CIL Label */ ;
#line 480
      if (! (i < (1 << 10) >> 2)) {
#line 480
        goto while_break;
      }
      {
#line 481
      blk = *(ref + i);
#line 482
      check_reference___9(dquot->dq_h, blk);
      }
#line 483
      if (blk) {
#line 483
        if (! ((int )*(bitmap + (blk >> 3)) & (1 << (blk & 7U)))) {
          {
#line 484
          tmp___0 = report_block___9(dquot, blk, bitmap, process_dquot);
#line 484
          entries += tmp___0;
          }
        }
      }
#line 480
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 488
    i = 0;
    {
#line 488
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 488
      if (! (i < (1 << 10) >> 2)) {
#line 488
        goto while_break___0;
      }
#line 489
      blk = *(ref + i);
#line 489
      if (blk) {
        {
#line 490
        check_reference___9(dquot->dq_h, blk);
#line 491
        tmp___1 = report_tree___9(dquot, blk, depth + 1, bitmap, process_dquot);
#line 491
        entries += tmp___1;
        }
      }
#line 488
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  {
#line 495
  free((void *)buf);
  }
#line 496
  return (entries);
}
}
#line 499 "/home/wheatley/newnew/temp/quota-4.01/quotaio_tree.c"
static uint find_set_bits___9(char *bmp , int blocks ) 
{ 
  uint i ;
  uint used ;

  {
#line 501
  used = (uint )0;
#line 503
  i = (uint )0;
  {
#line 503
  while (1) {
    while_continue: /* CIL Label */ ;
#line 503
    if (! (i < (uint )blocks)) {
#line 503
      goto while_break;
    }
#line 504
    if ((int )*(bmp + (i >> 3)) & (1 << (i & 7U))) {
#line 505
      used ++;
    }
#line 503
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 506
  return (used);
}
}
#line 105 "/home/wheatley/newnew/temp/quota-4.01/quotaio_generic.c"
static int scan_one_dquot___9(struct dquot *dquot , int (*get_dquot)(struct dquot * ) ) 
{ 
  int ret ;
  struct util_dqblk *dqb ;

  {
  {
#line 108
  dqb = & dquot->dq_dqb;
#line 110
  memset((void *)dqb, 0, sizeof(struct util_dqblk ));
#line 111
  ret = (*get_dquot)(dquot);
  }
#line 112
  if (ret < 0) {
#line 113
    return (ret);
  }
#line 114
  if (! dqb->dqb_bhardlimit) {
#line 114
    if (! dqb->dqb_bsoftlimit) {
#line 114
      if (! dqb->dqb_ihardlimit) {
#line 114
        if (! dqb->dqb_isoftlimit) {
#line 114
          if (! dqb->dqb_curinodes) {
#line 114
            if (! dqb->dqb_curspace) {
#line 115
              return (1);
            }
          }
        }
      }
    }
  }
#line 116
  return (0);
}
}
#line 18 "/home/wheatley/newnew/temp/quota-4.01/quotaio_rpc.c"
static int rpc_init_io___9(struct quota_handle *h ) ;
#line 19
static struct dquot *rpc_read_dquot___9(struct quota_handle *h , qid_t id___0 ) ;
#line 20
static int rpc_commit_dquot___9(struct dquot *dquot , int flags___7 ) ;
#line 31 "/home/wheatley/newnew/temp/quota-4.01/quotaio_rpc.c"
static int rpc_init_io___9(struct quota_handle *h ) 
{ 


  {
#line 34
  h->qh_info.dqi_max_b_limit = (uint64_t )(~ ((uint32_t )0));
#line 35
  h->qh_info.dqi_max_i_limit = (uint64_t )(~ ((uint32_t )0));
#line 36
  h->qh_info.dqi_max_b_usage = (uint64_t )(4294967295U << 10);
#line 37
  h->qh_info.dqi_max_i_usage = (uint64_t )(~ ((uint32_t )0));
#line 38
  return (0);
}
}
#line 47 "/home/wheatley/newnew/temp/quota-4.01/quotaio_rpc.c"
static struct dquot *rpc_read_dquot___9(struct quota_handle *h , qid_t id___0 ) 
{ 
  struct dquot *dquot ;
  struct dquot *tmp ;
  int ret ;
  int *tmp___0 ;

  {
  {
#line 50
  tmp = get_empty_dquot();
#line 50
  dquot = tmp;
#line 53
  dquot->dq_id = id___0;
#line 54
  dquot->dq_h = h;
#line 55
  ret = rpc_rquota_get(dquot);
  }
#line 55
  if (ret < 0) {
    {
#line 56
    tmp___0 = __errno_location();
#line 56
    *tmp___0 = - ret;
#line 57
    free((void *)dquot);
    }
#line 58
    return ((struct dquot *)((void *)0));
  }
#line 60
  return (dquot);
}
}
#line 70 "/home/wheatley/newnew/temp/quota-4.01/quotaio_rpc.c"
static int rpc_commit_dquot___9(struct dquot *dquot , int flags___7 ) 
{ 
  int ret ;
  char *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;

  {
#line 75
  if ((dquot->dq_h)->qh_io_flags & 4) {
    {
#line 76
    tmp = gettext("Trying to write quota to readonly quotafile on %s\n");
#line 76
    errstr(tmp, (dquot->dq_h)->qh_quotadev);
#line 77
    tmp___0 = __errno_location();
#line 77
    *tmp___0 = 1;
    }
#line 78
    return (-1);
  }
  {
#line 80
  ret = rpc_rquota_set((1024 << 8) | ((dquot->dq_h)->qh_type & 255), dquot);
  }
#line 80
  if (ret < 0) {
    {
#line 81
    tmp___1 = __errno_location();
#line 81
    *tmp___1 = - ret;
    }
#line 82
    return (-1);
  }
#line 84
  return (0);
}
}
#line 10 "/home/wheatley/newnew/temp/quota-4.01/rquota_clnt.c"
static struct timeval TIMEOUT___9  =    {(__time_t )25, (__suseconds_t )0};
#line 15 "/home/wheatley/newnew/temp/quota-4.01/rquota_clnt.c"
static getquota_rslt clnt_res___79  ;
#line 30 "/home/wheatley/newnew/temp/quota-4.01/rquota_clnt.c"
static getquota_rslt clnt_res___80  ;
#line 45 "/home/wheatley/newnew/temp/quota-4.01/rquota_clnt.c"
static setquota_rslt clnt_res___81  ;
#line 60 "/home/wheatley/newnew/temp/quota-4.01/rquota_clnt.c"
static setquota_rslt clnt_res___82  ;
#line 75 "/home/wheatley/newnew/temp/quota-4.01/rquota_clnt.c"
static getquota_rslt clnt_res___83  ;
#line 90 "/home/wheatley/newnew/temp/quota-4.01/rquota_clnt.c"
static getquota_rslt clnt_res___84  ;
#line 105 "/home/wheatley/newnew/temp/quota-4.01/rquota_clnt.c"
static setquota_rslt clnt_res___85  ;
#line 120 "/home/wheatley/newnew/temp/quota-4.01/rquota_clnt.c"
static setquota_rslt clnt_res___86  ;
#line 27 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v2.c"
static int v2_check_file___9(int fd , int type , int fmt___7 ) ;
#line 28
static int v2_init_io___9(struct quota_handle *h ) ;
#line 29
static int v2_new_io___9(struct quota_handle *h ) ;
#line 30
static int v2_write_info___9(struct quota_handle *h ) ;
#line 31
static struct dquot *v2_read_dquot___9(struct quota_handle *h , qid_t id___0 ) ;
#line 32
static int v2_commit_dquot___9(struct dquot *dquot , int flags___7 ) ;
#line 33
static int v2_scan_dquots___9(struct quota_handle *h , int (*process_dquot)(struct dquot *dquot ,
                                                                            char *dqname ) ) ;
#line 34
static int v2_report___9(struct quota_handle *h , int verbose ) ;
#line 53 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v2.c"
static void v2r0_disk2memdqblk___9(struct dquot *dquot , void *dp ) 
{ 
  struct util_dqblk *m ;
  struct v2r0_disk_dqblk *d ;
  struct v2r0_disk_dqblk empty ;
  int tmp ;

  {
  {
#line 55
  m = & dquot->dq_dqb;
#line 56
  d = (struct v2r0_disk_dqblk *)dp;
#line 58
  dquot->dq_id = d->dqb_id;
#line 59
  m->dqb_ihardlimit = (qsize_t )d->dqb_ihardlimit;
#line 60
  m->dqb_isoftlimit = (qsize_t )d->dqb_isoftlimit;
#line 61
  m->dqb_bhardlimit = (qsize_t )d->dqb_bhardlimit;
#line 62
  m->dqb_bsoftlimit = (qsize_t )d->dqb_bsoftlimit;
#line 63
  m->dqb_curinodes = (qsize_t )d->dqb_curinodes;
#line 64
  m->dqb_curspace = (qsize_t )((__le64 )d->dqb_curspace);
#line 65
  m->dqb_itime = (time_t )((__le64 )d->dqb_itime);
#line 66
  m->dqb_btime = (time_t )((__le64 )d->dqb_btime);
#line 68
  memset((void *)(& empty), 0, sizeof(struct v2r0_disk_dqblk ));
#line 69
  empty.dqb_itime = (u_int64_t )((__u64 )1);
#line 70
  tmp = memcmp((void const   *)(& empty), (void const   *)dp, sizeof(struct v2r0_disk_dqblk ));
  }
#line 70
  if (! tmp) {
#line 71
    m->dqb_itime = (time_t )0;
  }
#line 72
  return;
}
}
#line 77 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v2.c"
static void v2r0_mem2diskdqblk___9(void *dp , struct dquot *dquot ) 
{ 
  struct util_dqblk *m ;
  struct v2r0_disk_dqblk *d ;
  struct qtree_mem_dqinfo *info ;
  int tmp ;

  {
  {
#line 79
  m = & dquot->dq_dqb;
#line 80
  d = (struct v2r0_disk_dqblk *)dp;
#line 81
  info = & (dquot->dq_h)->qh_info.u.v2_mdqi.dqi_qtree;
#line 83
  d->dqb_ihardlimit = (__u32 )m->dqb_ihardlimit;
#line 84
  d->dqb_isoftlimit = (__u32 )m->dqb_isoftlimit;
#line 85
  d->dqb_bhardlimit = (__u32 )m->dqb_bhardlimit;
#line 86
  d->dqb_bsoftlimit = (__u32 )m->dqb_bsoftlimit;
#line 87
  d->dqb_curinodes = (__u32 )m->dqb_curinodes;
#line 88
  d->dqb_curspace = (u_int64_t )((__u64 )m->dqb_curspace);
#line 89
  d->dqb_itime = (u_int64_t )((__u64 )m->dqb_itime);
#line 90
  d->dqb_btime = (u_int64_t )((__u64 )m->dqb_btime);
#line 91
  d->dqb_id = dquot->dq_id;
#line 92
  tmp = qtree_entry_unused(info, (char *)dp);
  }
#line 92
  if (tmp) {
#line 93
    d->dqb_itime = (u_int64_t )((__u64 )1);
  }
#line 94
  return;
}
}
#line 96 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v2.c"
static int v2r0_is_id___9(void *dp , struct dquot *dquot ) 
{ 
  struct v2r0_disk_dqblk *d ;
  struct qtree_mem_dqinfo *info ;
  int tmp ;

  {
  {
#line 98
  d = (struct v2r0_disk_dqblk *)dp;
#line 99
  info = & (dquot->dq_h)->qh_info.u.v2_mdqi.dqi_qtree;
#line 101
  tmp = qtree_entry_unused(info, (char *)dp);
  }
#line 101
  if (tmp) {
#line 102
    return (0);
  }
#line 103
  return (d->dqb_id == dquot->dq_id);
}
}
#line 109 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v2.c"
static void v2r1_disk2memdqblk___9(struct dquot *dquot , void *dp ) 
{ 
  struct util_dqblk *m ;
  struct v2r1_disk_dqblk *d ;
  struct v2r1_disk_dqblk empty ;
  int tmp ;

  {
  {
#line 111
  m = & dquot->dq_dqb;
#line 112
  d = (struct v2r1_disk_dqblk *)dp;
#line 114
  dquot->dq_id = d->dqb_id;
#line 115
  m->dqb_ihardlimit = (qsize_t )((__le64 )d->dqb_ihardlimit);
#line 116
  m->dqb_isoftlimit = (qsize_t )((__le64 )d->dqb_isoftlimit);
#line 117
  m->dqb_bhardlimit = (qsize_t )((__le64 )d->dqb_bhardlimit);
#line 118
  m->dqb_bsoftlimit = (qsize_t )((__le64 )d->dqb_bsoftlimit);
#line 119
  m->dqb_curinodes = (qsize_t )((__le64 )d->dqb_curinodes);
#line 120
  m->dqb_curspace = (qsize_t )((__le64 )d->dqb_curspace);
#line 121
  m->dqb_itime = (time_t )((__le64 )d->dqb_itime);
#line 122
  m->dqb_btime = (time_t )((__le64 )d->dqb_btime);
#line 124
  memset((void *)(& empty), 0, sizeof(struct v2r1_disk_dqblk ));
#line 125
  empty.dqb_itime = (u_int64_t )((__u64 )1);
#line 126
  tmp = memcmp((void const   *)(& empty), (void const   *)dp, sizeof(struct v2r1_disk_dqblk ));
  }
#line 126
  if (! tmp) {
#line 127
    m->dqb_itime = (time_t )0;
  }
#line 128
  return;
}
}
#line 133 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v2.c"
static void v2r1_mem2diskdqblk___9(void *dp , struct dquot *dquot ) 
{ 
  struct util_dqblk *m ;
  struct v2r1_disk_dqblk *d ;
  int tmp ;

  {
  {
#line 135
  m = & dquot->dq_dqb;
#line 136
  d = (struct v2r1_disk_dqblk *)dp;
#line 138
  d->dqb_ihardlimit = (u_int64_t )((__u64 )m->dqb_ihardlimit);
#line 139
  d->dqb_isoftlimit = (u_int64_t )((__u64 )m->dqb_isoftlimit);
#line 140
  d->dqb_bhardlimit = (u_int64_t )((__u64 )m->dqb_bhardlimit);
#line 141
  d->dqb_bsoftlimit = (u_int64_t )((__u64 )m->dqb_bsoftlimit);
#line 142
  d->dqb_curinodes = (u_int64_t )((__u64 )m->dqb_curinodes);
#line 143
  d->dqb_curspace = (u_int64_t )((__u64 )m->dqb_curspace);
#line 144
  d->dqb_itime = (u_int64_t )((__u64 )m->dqb_itime);
#line 145
  d->dqb_btime = (u_int64_t )((__u64 )m->dqb_btime);
#line 146
  d->dqb_id = dquot->dq_id;
#line 147
  d->dqb_pad = (u_int32_t )0;
#line 148
  tmp = qtree_entry_unused(& (dquot->dq_h)->qh_info.u.v2_mdqi.dqi_qtree, (char *)dp);
  }
#line 148
  if (tmp) {
#line 149
    d->dqb_itime = (u_int64_t )((__u64 )1);
  }
#line 150
  return;
}
}
#line 152 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v2.c"
static int v2r1_is_id___9(void *dp , struct dquot *dquot ) 
{ 
  struct v2r1_disk_dqblk *d ;
  struct qtree_mem_dqinfo *info ;
  int tmp ;

  {
  {
#line 154
  d = (struct v2r1_disk_dqblk *)dp;
#line 155
  info = & (dquot->dq_h)->qh_info.u.v2_mdqi.dqi_qtree;
#line 157
  tmp = qtree_entry_unused(info, (char *)dp);
  }
#line 157
  if (tmp) {
#line 158
    return (0);
  }
#line 159
  return (d->dqb_id == dquot->dq_id);
}
}
#line 162 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v2.c"
static struct qtree_fmt_operations v2r0_fmt_ops___9  =    {& v2r0_mem2diskdqblk___9, & v2r0_disk2memdqblk___9, & v2r0_is_id___9};
#line 168 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v2.c"
static struct qtree_fmt_operations v2r1_fmt_ops___9  =    {& v2r1_mem2diskdqblk___9, & v2r1_disk2memdqblk___9, & v2r1_is_id___9};
#line 226 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v2.c"
static int v2_read_header___9(int fd , struct v2_disk_dqheader *h ) 
{ 
  ssize_t tmp ;

  {
  {
#line 228
  lseek(fd, (__off64_t )0, 0);
#line 229
  tmp = read(fd, (void *)h, sizeof(struct v2_disk_dqheader ));
  }
#line 229
  if ((unsigned long )tmp != sizeof(struct v2_disk_dqheader )) {
#line 230
    return (0);
  }
#line 231
  return (1);
}
}
#line 237 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v2.c"
static int v2_check_file___9(int fd , int type , int fmt___7 ) 
{ 
  struct v2_disk_dqheader h ;
  int file_magics[2] ;
  int known_versions___0[2] ;
  int version___0 ;
  int tmp ;
  char *tmp___0 ;
  __u32 tmp___1 ;

  {
  {
#line 240
  file_magics[0] = -641720559;
#line 240
  file_magics[1] = -641722073;
#line 241
  known_versions___0[0] = 1;
#line 241
  known_versions___0[1] = 1;
#line 244
  tmp = v2_read_header___9(fd, & h);
  }
#line 244
  if (! tmp) {
#line 245
    return (0);
  }
#line 246
  if (fmt___7 == 1) {
#line 247
    version___0 = 0;
  } else
#line 248
  if (fmt___7 == 2) {
#line 249
    version___0 = 1;
  } else {
#line 251
    return (0);
  }
#line 253
  if (h.dqh_magic != (__u32 )file_magics[type]) {
    {
#line 254
    tmp___1 = __fswab32(h.dqh_magic);
    }
#line 254
    if (tmp___1 == (__u32 )file_magics[type]) {
      {
#line 255
      tmp___0 = gettext("Your quota file is stored in wrong endianity. Please use convertquota(8) to convert it.\n");
#line 255
      die(3, tmp___0);
      }
    }
#line 256
    return (0);
  }
#line 258
  if (h.dqh_version > (__u32 )known_versions___0[type]) {
#line 259
    return (0);
  }
#line 260
  if ((__u32 )version___0 != h.dqh_version) {
#line 261
    return (0);
  }
#line 262
  return (1);
}
}
#line 268 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v2.c"
static int v2_init_io___9(struct quota_handle *h ) 
{ 
  int tmp ;
  struct v2_kern_dqinfo kdqinfo ;
  int *tmp___0 ;
  long tmp___1 ;
  struct v2_disk_dqinfo ddqinfo ;
  struct v2_disk_dqheader header ;
  int tmp___2 ;
  ssize_t tmp___3 ;

  {
#line 270
  if (h->qh_io_flags & 1) {
#line 271
    if (kernel_iface == 3) {
      {
#line 272
      tmp = vfs_get_info(h);
      }
#line 272
      if (tmp < 0) {
#line 273
        return (-1);
      }
    } else {
      {
#line 278
      tmp___1 = quotactl((2304 << 8) | (h->qh_type & 255), (char const   *)(h->qh_quotadev),
                         (qid_t )0, (caddr_t )((void *)(& kdqinfo)));
      }
#line 278
      if (tmp___1 < 0L) {
        {
#line 280
        tmp___0 = __errno_location();
        }
#line 280
        if (*tmp___0 == 1) {
#line 281
          return (0);
        }
#line 282
        return (-1);
      }
#line 284
      h->qh_info.dqi_bgrace = (time_t )kdqinfo.dqi_bgrace;
#line 285
      h->qh_info.dqi_igrace = (time_t )kdqinfo.dqi_igrace;
#line 286
      h->qh_info.u.v2_mdqi.dqi_flags = kdqinfo.dqi_flags;
#line 287
      h->qh_info.u.v2_mdqi.dqi_qtree.dqi_blocks = kdqinfo.dqi_blocks;
#line 288
      h->qh_info.u.v2_mdqi.dqi_qtree.dqi_free_blk = kdqinfo.dqi_free_blk;
#line 289
      h->qh_info.u.v2_mdqi.dqi_qtree.dqi_free_entry = kdqinfo.dqi_free_entry;
    }
  }
#line 292
  if (h->qh_fd != -1) {
    {
#line 296
    tmp___2 = v2_read_header___9(h->qh_fd, & header);
    }
#line 296
    if (! tmp___2) {
#line 297
      return (-1);
    }
    {
#line 299
    lseek(h->qh_fd, (__off64_t )sizeof(struct v2_disk_dqheader ), 0);
#line 300
    tmp___3 = read(h->qh_fd, (void *)(& ddqinfo), sizeof(ddqinfo));
    }
#line 300
    if ((unsigned long )tmp___3 != sizeof(ddqinfo)) {
#line 301
      return (-1);
    }
#line 303
    if (! (h->qh_io_flags & 1)) {
      {
#line 304
      v2_disk2memdqinfo(& h->qh_info, & ddqinfo);
      }
    } else {
#line 306
      h->qh_info.u.v2_mdqi.dqi_qtree.dqi_blocks = ddqinfo.dqi_blocks;
    }
#line 308
    if (header.dqh_version == 0U) {
#line 309
      h->qh_info.u.v2_mdqi.dqi_qtree.dqi_entry_size = (unsigned int )sizeof(struct v2r0_disk_dqblk );
#line 310
      h->qh_info.u.v2_mdqi.dqi_qtree.dqi_ops = & v2r0_fmt_ops___9;
#line 311
      h->qh_info.dqi_max_b_limit = (uint64_t )(~ ((uint32_t )0));
#line 312
      h->qh_info.dqi_max_i_limit = (uint64_t )(~ ((uint32_t )0));
#line 313
      h->qh_info.dqi_max_b_usage = ~ ((uint64_t )0);
#line 314
      h->qh_info.dqi_max_i_usage = (uint64_t )(~ ((uint32_t )0));
    } else {
#line 316
      h->qh_info.u.v2_mdqi.dqi_qtree.dqi_entry_size = (unsigned int )sizeof(struct v2r1_disk_dqblk );
#line 317
      h->qh_info.u.v2_mdqi.dqi_qtree.dqi_ops = & v2r1_fmt_ops___9;
#line 318
      h->qh_info.dqi_max_b_limit = ~ ((uint64_t )0);
#line 319
      h->qh_info.dqi_max_i_limit = ~ ((uint64_t )0);
#line 320
      h->qh_info.dqi_max_b_usage = ~ ((uint64_t )0);
#line 321
      h->qh_info.dqi_max_i_usage = ~ ((uint64_t )0);
    }
  } else {
#line 325
    h->qh_info.u.v2_mdqi.dqi_qtree.dqi_ops = (struct qtree_fmt_operations *)((void *)0);
  }
#line 327
  return (0);
}
}
#line 333 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v2.c"
static int v2_new_io___9(struct quota_handle *h ) 
{ 
  int file_magics[2] ;
  struct v2_disk_dqheader ddqheader ;
  struct v2_disk_dqinfo ddqinfo ;
  int version___0 ;
  ssize_t tmp ;
  ssize_t tmp___0 ;

  {
#line 335
  file_magics[0] = -641720559;
#line 335
  file_magics[1] = -641722073;
#line 340
  if (h->qh_fmt == 1) {
#line 341
    version___0 = 0;
  } else
#line 342
  if (h->qh_fmt == 2) {
#line 343
    version___0 = 1;
  } else {
#line 345
    return (-1);
  }
  {
#line 348
  ddqheader.dqh_magic = (__u32 )file_magics[h->qh_type];
#line 349
  ddqheader.dqh_version = (__u32 )version___0;
#line 350
  lseek(h->qh_fd, (__off64_t )0, 0);
#line 351
  tmp = write(h->qh_fd, (void const   *)(& ddqheader), sizeof(ddqheader));
  }
#line 351
  if ((unsigned long )tmp != sizeof(ddqheader)) {
#line 352
    return (-1);
  }
#line 354
  h->qh_info.dqi_bgrace = (time_t )604800;
#line 355
  h->qh_info.dqi_igrace = (time_t )604800;
#line 356
  h->qh_info.u.v2_mdqi.dqi_flags = (uint )0;
#line 357
  h->qh_info.u.v2_mdqi.dqi_qtree.dqi_blocks = 2U;
#line 358
  h->qh_info.u.v2_mdqi.dqi_qtree.dqi_free_blk = 0U;
#line 359
  h->qh_info.u.v2_mdqi.dqi_qtree.dqi_free_entry = 0U;
#line 360
  if (version___0 == 0) {
#line 361
    h->qh_info.u.v2_mdqi.dqi_qtree.dqi_entry_size = (unsigned int )sizeof(struct v2r0_disk_dqblk );
#line 362
    h->qh_info.u.v2_mdqi.dqi_qtree.dqi_ops = & v2r0_fmt_ops___9;
#line 363
    h->qh_info.dqi_max_b_limit = (uint64_t )(~ ((uint32_t )0));
#line 364
    h->qh_info.dqi_max_i_limit = (uint64_t )(~ ((uint32_t )0));
#line 365
    h->qh_info.dqi_max_b_usage = ~ ((uint64_t )0);
#line 366
    h->qh_info.dqi_max_i_usage = (uint64_t )(~ ((uint32_t )0));
  } else
#line 367
  if (version___0 == 1) {
#line 368
    h->qh_info.u.v2_mdqi.dqi_qtree.dqi_entry_size = (unsigned int )sizeof(struct v2r1_disk_dqblk );
#line 369
    h->qh_info.u.v2_mdqi.dqi_qtree.dqi_ops = & v2r1_fmt_ops___9;
#line 370
    h->qh_info.dqi_max_b_limit = ~ ((uint64_t )0);
#line 371
    h->qh_info.dqi_max_i_limit = ~ ((uint64_t )0);
#line 372
    h->qh_info.dqi_max_b_usage = ~ ((uint64_t )0);
#line 373
    h->qh_info.dqi_max_i_usage = ~ ((uint64_t )0);
  }
  {
#line 375
  v2_mem2diskdqinfo(& ddqinfo, & h->qh_info);
#line 376
  lseek(h->qh_fd, (__off64_t )sizeof(struct v2_disk_dqheader ), 0);
#line 377
  tmp___0 = write(h->qh_fd, (void const   *)(& ddqinfo), sizeof(ddqinfo));
  }
#line 377
  if ((unsigned long )tmp___0 != sizeof(ddqinfo)) {
#line 378
    return (-1);
  }
#line 379
  return (0);
}
}
#line 385 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v2.c"
static int v2_write_info___9(struct quota_handle *h ) 
{ 
  char *tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  struct v2_kern_dqinfo kdqinfo ;
  long tmp___2 ;
  long tmp___3 ;
  struct v2_disk_dqinfo ddqinfo ;
  ssize_t tmp___4 ;

  {
#line 387
  if (h->qh_io_flags & 4) {
    {
#line 388
    tmp = gettext("Trying to write info to readonly quotafile on %s\n");
#line 388
    errstr(tmp, h->qh_quotadev);
#line 389
    tmp___0 = __errno_location();
#line 389
    *tmp___0 = 1;
    }
#line 390
    return (-1);
  }
#line 392
  if (h->qh_io_flags & 1) {
#line 393
    if (kernel_iface == 3) {
      {
#line 394
      tmp___1 = vfs_set_info(h, 3);
      }
#line 394
      if (tmp___1) {
#line 395
        return (-1);
      }
    } else {
      {
#line 400
      kdqinfo.dqi_bgrace = (unsigned int )h->qh_info.dqi_bgrace;
#line 401
      kdqinfo.dqi_igrace = (unsigned int )h->qh_info.dqi_igrace;
#line 402
      kdqinfo.dqi_flags = h->qh_info.u.v2_mdqi.dqi_flags;
#line 403
      kdqinfo.dqi_blocks = h->qh_info.u.v2_mdqi.dqi_qtree.dqi_blocks;
#line 404
      kdqinfo.dqi_free_blk = h->qh_info.u.v2_mdqi.dqi_qtree.dqi_free_blk;
#line 405
      kdqinfo.dqi_free_entry = h->qh_info.u.v2_mdqi.dqi_qtree.dqi_free_entry;
#line 406
      tmp___2 = quotactl((2816 << 8) | (h->qh_type & 255), (char const   *)(h->qh_quotadev),
                         (qid_t )0, (caddr_t )((void *)(& kdqinfo)));
      }
#line 406
      if (tmp___2 < 0L) {
#line 408
        return (-1);
      } else {
        {
#line 406
        tmp___3 = quotactl((3072 << 8) | (h->qh_type & 255), (char const   *)(h->qh_quotadev),
                           (qid_t )0, (caddr_t )((void *)(& kdqinfo)));
        }
#line 406
        if (tmp___3 < 0L) {
#line 408
          return (-1);
        }
      }
    }
  } else {
    {
#line 414
    v2_mem2diskdqinfo(& ddqinfo, & h->qh_info);
#line 415
    lseek(h->qh_fd, (__off64_t )sizeof(struct v2_disk_dqheader ), 0);
#line 416
    tmp___4 = write(h->qh_fd, (void const   *)(& ddqinfo), sizeof(ddqinfo));
    }
#line 416
    if ((unsigned long )tmp___4 != sizeof(ddqinfo)) {
#line 417
      return (-1);
    }
  }
#line 419
  return (0);
}
}
#line 426 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v2.c"
static struct dquot *v2_read_dquot___9(struct quota_handle *h , qid_t id___0 ) 
{ 
  struct dquot *dquot ;
  struct dquot *tmp ;
  int tmp___0 ;
  struct v2_kern_dqblk kdqblk ;
  long tmp___1 ;
  struct dquot *tmp___2 ;

  {
#line 428
  if (h->qh_io_flags & 1) {
    {
#line 429
    tmp = get_empty_dquot();
#line 429
    dquot = tmp;
#line 431
    dquot->dq_id = id___0;
#line 432
    dquot->dq_h = h;
#line 433
    dquot->dq_dqb.u.v2_mdqb.dqb_off = (loff_t )0;
#line 434
    memset((void *)(& dquot->dq_dqb), 0, sizeof(struct util_dqblk ));
    }
#line 435
    if (kernel_iface == 3) {
      {
#line 436
      tmp___0 = vfs_get_dquot(dquot);
      }
#line 436
      if (tmp___0 < 0) {
        {
#line 437
        free((void *)dquot);
        }
#line 438
        return ((struct dquot *)((void *)0));
      }
    } else {
      {
#line 444
      tmp___1 = quotactl((3328 << 8) | (h->qh_type & 255), (char const   *)(h->qh_quotadev),
                         id___0, (caddr_t )((void *)(& kdqblk)));
      }
#line 444
      if (tmp___1 < 0L) {
        {
#line 445
        free((void *)dquot);
        }
#line 446
        return ((struct dquot *)((void *)0));
      }
      {
#line 448
      v2_kern2utildqblk(& dquot->dq_dqb, & kdqblk);
      }
    }
#line 450
    return (dquot);
  }
  {
#line 452
  tmp___2 = qtree_read_dquot(h, id___0);
  }
#line 452
  return (tmp___2);
}
}
#line 459 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v2.c"
static int v2_commit_dquot___9(struct dquot *dquot , int flags___7 ) 
{ 
  struct util_dqblk *b ;
  char *tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  struct v2_kern_dqblk kdqblk ;
  int cmd ;
  int *tmp___2 ;
  long tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;

  {
#line 461
  b = & dquot->dq_dqb;
#line 463
  if ((dquot->dq_h)->qh_io_flags & 4) {
    {
#line 464
    tmp = gettext("Trying to write quota to readonly quotafile on %s\n");
#line 464
    errstr(tmp, (dquot->dq_h)->qh_quotadev);
#line 465
    tmp___0 = __errno_location();
#line 465
    *tmp___0 = 1;
    }
#line 466
    return (-1);
  }
#line 468
  if ((dquot->dq_h)->qh_io_flags & 1) {
#line 469
    if (kernel_iface == 3) {
      {
#line 470
      tmp___1 = vfs_set_dquot(dquot, flags___7);
      }
#line 470
      if (tmp___1 < 0) {
#line 471
        return (-1);
      }
    } else {
#line 477
      if (flags___7 == 10) {
#line 478
        cmd = 3840;
      } else
#line 479
      if (flags___7 == 5) {
#line 480
        cmd = 1792;
      } else
#line 481
      if (flags___7 & 48) {
        {
#line 482
        tmp___2 = __errno_location();
#line 482
        *tmp___2 = 22;
        }
#line 483
        return (-1);
      } else {
#line 486
        cmd = 3584;
      }
      {
#line 487
      v2_util2kerndqblk(& kdqblk, & dquot->dq_dqb);
#line 488
      tmp___3 = quotactl((cmd << 8) | ((dquot->dq_h)->qh_type & 255), (char const   *)((dquot->dq_h)->qh_quotadev),
                         dquot->dq_id, (caddr_t )((void *)(& kdqblk)));
      }
#line 488
      if (tmp___3 < 0L) {
#line 490
        return (-1);
      }
    }
#line 492
    return (0);
  }
#line 494
  if (! b->dqb_curspace) {
#line 494
    if (! b->dqb_curinodes) {
#line 494
      if (! b->dqb_bsoftlimit) {
#line 494
        if (! b->dqb_isoftlimit) {
#line 494
          if (! b->dqb_bhardlimit) {
#line 494
            if (! b->dqb_ihardlimit) {
              {
#line 496
              qtree_delete_dquot(dquot);
              }
            } else {
#line 494
              goto _L___3;
            }
          } else {
#line 494
            goto _L___3;
          }
        } else {
#line 494
          goto _L___3;
        }
      } else {
#line 494
        goto _L___3;
      }
    } else {
#line 494
      goto _L___3;
    }
  } else {
    _L___3: /* CIL Label */ 
    {
#line 498
    tmp___5 = check_dquot_range(dquot);
    }
#line 498
    if (tmp___5 < 0) {
      {
#line 499
      tmp___4 = __errno_location();
#line 499
      *tmp___4 = 34;
      }
#line 500
      return (-1);
    }
    {
#line 502
    qtree_write_dquot(dquot);
    }
  }
#line 504
  return (0);
}
}
#line 507 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v2.c"
static int v2_scan_dquots___9(struct quota_handle *h , int (*process_dquot)(struct dquot *dquot ,
                                                                            char *dqname ) ) 
{ 
  int tmp ;

  {
  {
#line 509
  tmp = qtree_scan_dquots(h, process_dquot);
  }
#line 509
  return (tmp);
}
}
#line 513 "/home/wheatley/newnew/temp/quota-4.01/quotaio_v2.c"
static int v2_report___9(struct quota_handle *h , int verbose ) 
{ 
  struct v2_mem_dqinfo *info ;
  char *tmp ;

  {
#line 515
  if (verbose) {
    {
#line 516
    info = & h->qh_info.u.v2_mdqi;
#line 518
    tmp = gettext("Statistics:\nTotal blocks: %u\nData blocks: %u\nEntries: %u\nUsed average: %f\n");
#line 518
    printf((char const   */* __restrict  */)tmp, info->dqi_qtree.dqi_blocks, info->dqi_data_blocks,
           info->dqi_used_entries, (double )((float )info->dqi_used_entries / (float )info->dqi_data_blocks));
    }
  }
#line 522
  return (0);
}
}
#line 23 "/home/wheatley/newnew/temp/quota-4.01/common.c"
static int enable_syslog___11  =    0;
#line 31 "/home/wheatley/newnew/temp/quota-4.01/common.c"
static void do_syslog___11(int level , char const   *format , va_list args ) 
{ 
  char buf[1024] ;
  int i ;
  int j ;
  int tmp ;

  {
  {
#line 36
  vsnprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)format,
            args);
#line 39
  i = 0;
  }
  {
#line 39
  while (1) {
    while_continue: /* CIL Label */ ;
#line 39
    if (! buf[i]) {
#line 39
      goto while_break;
    }
#line 40
    j = i;
    {
#line 40
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 40
      if (buf[j]) {
#line 40
        if (! ((int )buf[j] != 10)) {
#line 40
          goto while_break___0;
        }
      } else {
#line 40
        goto while_break___0;
      }
#line 40
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 41
    if ((int )buf[j] == 10) {
#line 42
      tmp = j;
#line 42
      j ++;
#line 42
      buf[tmp] = (char )'\000';
    }
    {
#line 43
    syslog(level, "%s", buf + i);
#line 39
    i = j;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 45
  return;
}
}
