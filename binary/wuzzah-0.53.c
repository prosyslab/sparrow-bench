/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 22 "/home/june/repo/benchmarks/collector2/temp/wuzzah-0.53/hashtable/hashtable.h"
struct list;
#line 22 "/home/june/repo/benchmarks/collector2/temp/wuzzah-0.53/hashtable/hashtable.h"
struct htable {
   struct list **table ;
   int num_buckets ;
   int size ;
   int (*hashcode)(void *obj ) ;
   int (*compare)(void *obj1 , void *obj2 ) ;
};
#line 22 "/home/june/repo/benchmarks/collector2/temp/wuzzah-0.53/hashtable/hashtable.h"
typedef struct htable htable_t;
#line 30 "/home/june/repo/benchmarks/collector2/temp/wuzzah-0.53/hashtable/hashtable.h"
struct list {
   void *info ;
   struct list *lptr ;
};
#line 30 "/home/june/repo/benchmarks/collector2/temp/wuzzah-0.53/hashtable/hashtable.h"
typedef struct list ht_list_t;
#line 40 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __int32_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 133 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 98 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __pid_t pid_t;
#line 42 "/usr/include/x86_64-linux-gnu/bits/utmpx.h"
struct __exit_status {
   short __e_termination ;
   short __e_exit ;
};
#line 55 "/usr/include/x86_64-linux-gnu/bits/utmpx.h"
struct __anonstruct_ut_tv_52 {
   __int32_t tv_sec ;
   __int32_t tv_usec ;
};
#line 55 "/usr/include/x86_64-linux-gnu/bits/utmpx.h"
struct utmpx {
   short ut_type ;
   __pid_t ut_pid ;
   char ut_line[32] ;
   char ut_id[4] ;
   char ut_user[32] ;
   char ut_host[256] ;
   struct __exit_status ut_exit ;
   __int32_t ut_session ;
   struct __anonstruct_ut_tv_52 ut_tv ;
   __int32_t ut_addr_v6[4] ;
   char __glibc_reserved[20] ;
};
#line 13 "/home/june/repo/benchmarks/collector2/temp/wuzzah-0.53/common.h"
struct wuzzah_config {
   char const   *progname ;
   char *infile ;
   char const   *buddy_msg ;
   char const   *status_msg ;
   short write_users ;
   int sleep_interval ;
   char *whoami ;
   short no_newline ;
   char const   *eventcmd ;
   short run_once ;
   short process_current ;
   short noloadfile ;
   char *extrabuddies ;
   short all_users ;
};
#line 13 "/home/june/repo/benchmarks/collector2/temp/wuzzah-0.53/common.h"
typedef struct wuzzah_config wuzzah_config_t;
#line 14 "/home/june/repo/benchmarks/collector2/temp/wuzzah-0.53/buddies.h"
enum __anonenum_bud_status_e_60 {
    B_LOGGED_OUT = 0,
    B_LOGGED_IN = 1,
    B_UNCHANGED = 2
} ;
#line 14 "/home/june/repo/benchmarks/collector2/temp/wuzzah-0.53/buddies.h"
typedef enum __anonenum_bud_status_e_60 bud_status_e;
#line 16 "/home/june/repo/benchmarks/collector2/temp/wuzzah-0.53/buddies.h"
struct buddy {
   char *name ;
   htable_t *logins ;
   wuzzah_config_t const   *conf ;
};
#line 22 "/home/june/repo/benchmarks/collector2/temp/wuzzah-0.53/buddies.h"
struct bud_utrec {
   struct utmpx *u ;
   bud_status_e verified ;
};
#line 22 "/home/june/repo/benchmarks/collector2/temp/wuzzah-0.53/buddies.h"
typedef struct bud_utrec bud_utrec_t;
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 126 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 102 "/usr/include/stdio.h"
typedef __ssize_t ssize_t;
#line 75 "/usr/include/time.h"
typedef __time_t time_t;
#line 133 "/usr/include/time.h"
struct tm {
   int tm_sec ;
   int tm_min ;
   int tm_hour ;
   int tm_mday ;
   int tm_mon ;
   int tm_year ;
   int tm_wday ;
   int tm_yday ;
   int tm_isdst ;
   long tm_gmtoff ;
   char const   *tm_zone ;
};
#line 49 "/usr/include/pwd.h"
struct passwd {
   char *pw_name ;
   char *pw_passwd ;
   __uid_t pw_uid ;
   __gid_t pw_gid ;
   char *pw_gecos ;
   char *pw_dir ;
   char *pw_shell ;
};
#line 51 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 30 "/usr/include/netinet/in.h"
typedef uint32_t in_addr_t;
#line 31 "/usr/include/netinet/in.h"
struct in_addr {
   in_addr_t s_addr ;
};
#line 100 "/usr/include/netdb.h"
struct hostent {
   char *h_name ;
   char **h_aliases ;
   int h_addrtype ;
   int h_length ;
   char **h_addr_list ;
};
#line 16 "/home/june/repo/benchmarks/collector2/temp/wuzzah-0.53/buddies.h"
typedef struct buddy buddy_t;
#line 104 "/usr/include/getopt.h"
struct option {
   char const   *name ;
   int has_arg ;
   int *flag ;
   int val ;
};
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 66 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 39 "/home/june/repo/benchmarks/collector2/temp/wuzzah-0.53/hashtable/hashtable.h"
htable_t *ht_init(int num_buckets , int (*hashcode)(void *obj ) , int (*compare)(void *obj1 ,
                                                                                 void *obj2 ) ) ;
#line 45
void ht_reset(htable_t *ht ) ;
#line 50
void *ht_find(void *obj , htable_t *ht ) ;
#line 55
void ht_insert(void *obj , htable_t *ht ) ;
#line 60
void ht_remove(void *obj , htable_t *ht ) ;
#line 65
ht_list_t *ht_iter(htable_t *ht ) ;
#line 70
void ht_free_iter(ht_list_t *l ) ;
#line 3 "/home/june/repo/benchmarks/collector2/temp/wuzzah-0.53/hashtable/hashtable.c"
htable_t *ht_init(int num_buckets , int (*hashcode)(void *obj ) , int (*compare)(void *obj1 ,
                                                                                 void *obj2 ) ) 
{ 
  htable_t *ht ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 6
  tmp = malloc(sizeof(htable_t ));
#line 6
  ht = (htable_t *)tmp;
#line 7
  tmp___0 = malloc(sizeof(ht_list_t *) * (unsigned long )num_buckets);
#line 7
  ht->table = (ht_list_t **)tmp___0;
#line 8
  memset((void *)ht->table, 0, sizeof(ht_list_t *) * (unsigned long )num_buckets);
#line 9
  ht->num_buckets = num_buckets;
#line 10
  ht->size = 0;
#line 11
  ht->hashcode = hashcode;
#line 12
  ht->compare = compare;
  }
#line 13
  return (ht);
}
}
#line 16 "/home/june/repo/benchmarks/collector2/temp/wuzzah-0.53/hashtable/hashtable.c"
void ht_reset(htable_t *ht ) 
{ 
  int i ;
  ht_list_t *cur ;
  ht_list_t *next ;
  void *tmp ;

  {
#line 19
  if (ht) {
#line 20
    i = 0;
    {
#line 20
    while (1) {
      while_continue: /* CIL Label */ ;
#line 20
      if (! (i < ht->num_buckets)) {
#line 20
        goto while_break;
      }
#line 21
      cur = *(ht->table + i);
#line 22
      if (cur) {
        {
#line 23
        next = cur->lptr;
#line 24
        free((void *)cur);
#line 25
        cur = next;
        }
      }
#line 20
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 28
    free((void *)ht->table);
    }
  }
  {
#line 30
  tmp = malloc(sizeof(ht_list_t *) * (unsigned long )ht->num_buckets);
#line 30
  ht->table = (ht_list_t **)tmp;
#line 31
  memset((void *)ht->table, 0, sizeof(ht_list_t *) * (unsigned long )ht->num_buckets);
#line 32
  ht->size = 0;
  }
#line 33
  return;
}
}
#line 35 "/home/june/repo/benchmarks/collector2/temp/wuzzah-0.53/hashtable/hashtable.c"
void *ht_find(void *obj , htable_t *ht ) 
{ 
  ht_list_t *chain ;
  int tmp ;
  void *info_to_return ;
  int tmp___0 ;

  {
  {
#line 36
  tmp = (*(ht->hashcode))(obj);
#line 36
  chain = *(ht->table + tmp % ht->num_buckets);
#line 37
  info_to_return = (void *)0;
  }
  {
#line 39
  while (1) {
    while_continue: /* CIL Label */ ;
#line 39
    if (! chain) {
#line 39
      goto while_break;
    }
    {
#line 40
    tmp___0 = (*(ht->compare))(obj, chain->info);
    }
#line 40
    if (tmp___0 == 0) {
#line 41
      info_to_return = chain->info;
#line 42
      goto while_break;
    } else {
#line 43
      chain = chain->lptr;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 45
  return (info_to_return);
}
}
#line 48 "/home/june/repo/benchmarks/collector2/temp/wuzzah-0.53/hashtable/hashtable.c"
void ht_insert(void *obj , htable_t *ht ) 
{ 
  int hc ;
  int tmp ;
  ht_list_t *new_entry ;
  ht_list_t *old_chain ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 49
  tmp = (*(ht->hashcode))(obj);
#line 49
  hc = tmp % ht->num_buckets;
#line 50
  new_entry = (ht_list_t *)((void *)0);
#line 50
  old_chain = *(ht->table + hc);
#line 52
  tmp___1 = ht_find(obj, ht);
  }
#line 52
  if (! tmp___1) {
    {
#line 53
    tmp___0 = malloc(sizeof(ht_list_t ));
#line 53
    new_entry = (ht_list_t *)tmp___0;
#line 54
    new_entry->info = obj;
#line 55
    new_entry->lptr = old_chain;
#line 56
    *(ht->table + hc) = new_entry;
#line 57
    (ht->size) ++;
    }
  }
#line 59
  return;
}
}
#line 62 "/home/june/repo/benchmarks/collector2/temp/wuzzah-0.53/hashtable/hashtable.c"
void ht_remove(void *obj , htable_t *ht ) 
{ 
  int hc ;
  int tmp ;
  ht_list_t *chain ;
  ht_list_t *oldchain ;
  int tmp___0 ;

  {
  {
#line 63
  tmp = (*(ht->hashcode))(obj);
#line 63
  hc = tmp % ht->num_buckets;
#line 64
  chain = *(ht->table + hc);
#line 65
  oldchain = chain;
  }
  {
#line 66
  while (1) {
    while_continue: /* CIL Label */ ;
#line 66
    if (! chain) {
#line 66
      goto while_break;
    }
    {
#line 67
    tmp___0 = (*(ht->compare))(obj, chain->info);
    }
#line 67
    if (tmp___0 == 0) {
#line 68
      if ((unsigned long )oldchain == (unsigned long )chain) {
        {
#line 69
        *(ht->table + hc) = chain->lptr;
#line 70
        free((void *)chain);
        }
      } else {
        {
#line 72
        oldchain->lptr = chain->lptr;
#line 73
        free((void *)chain);
        }
      }
#line 75
      (ht->size) --;
#line 76
      goto while_break;
    }
#line 78
    oldchain = chain;
#line 79
    chain = chain->lptr;
  }
  while_break: /* CIL Label */ ;
  }
#line 81
  return;
}
}
#line 83 "/home/june/repo/benchmarks/collector2/temp/wuzzah-0.53/hashtable/hashtable.c"
ht_list_t *ht_iter(htable_t *ht ) 
{ 
  int i ;
  ht_list_t *prev ;
  ht_list_t *cur ;
  ht_list_t *next ;
  void *tmp ;

  {
#line 85
  prev = (ht_list_t *)((void *)0);
#line 85
  cur = (ht_list_t *)((void *)0);
#line 85
  next = (ht_list_t *)((void *)0);
#line 87
  if (! ht) {
#line 87
    return ((ht_list_t *)((void *)0));
  } else
#line 87
  if (! ht->table) {
#line 87
    return ((ht_list_t *)((void *)0));
  }
#line 88
  i = 0;
  {
#line 88
  while (1) {
    while_continue: /* CIL Label */ ;
#line 88
    if (! (i < ht->num_buckets)) {
#line 88
      goto while_break;
    }
#line 89
    next = *(ht->table + i);
    {
#line 90
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 90
      if (! next) {
#line 90
        goto while_break___0;
      }
      {
#line 91
      tmp = malloc(sizeof(ht_list_t ));
#line 91
      cur = (ht_list_t *)tmp;
#line 92
      cur->info = next->info;
#line 93
      cur->lptr = prev;
#line 94
      prev = cur;
#line 95
      next = next->lptr;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 88
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 98
  return (cur);
}
}
#line 101 "/home/june/repo/benchmarks/collector2/temp/wuzzah-0.53/hashtable/hashtable.c"
void ht_free_iter(ht_list_t *l ) 
{ 
  ht_list_t *next ;

  {
  {
#line 103
  while (1) {
    while_continue: /* CIL Label */ ;
#line 103
    if (! l) {
#line 103
      goto while_break;
    }
    {
#line 104
    next = l->lptr;
#line 105
    free((void *)l);
#line 106
    l = next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 108
  return;
}
}
#line 169 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 170
extern struct _IO_FILE *stderr ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 846
extern void perror(char const   *__s ) ;
#line 543 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 717
extern int system(char const   *__command ) ;
#line 756 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __pid_t fork(void) ;
#line 30 "/home/june/repo/benchmarks/collector2/temp/wuzzah-0.53/common.h"
wuzzah_config_t g_config ;
#line 7 "/home/june/repo/benchmarks/collector2/temp/wuzzah-0.53/write.h"
int wri_do_write(char *user , char *line , char *message ) ;
#line 33 "/home/june/repo/benchmarks/collector2/temp/wuzzah-0.53/buddies.h"
char *bud_expand_fmt(bud_utrec_t const   *bud , char const   *fmt_string ) ;
#line 31 "/home/june/repo/benchmarks/collector2/temp/wuzzah-0.53/event.h"
void event(struct buddy  const  *b , struct bud_utrec  const  *u , short write___0 ) ;
#line 39
pid_t fork_and_exec(char const   *command ) ;
#line 3 "/home/june/repo/benchmarks/collector2/temp/wuzzah-0.53/event.c"
void event(struct buddy  const  *b , struct bud_utrec  const  *u , short write___0 ) 
{ 
  char *status_msg ;
  char *wr_msg ;
  char *extra_cmd ;

  {
#line 4
  status_msg = (char *)((void *)0);
#line 4
  wr_msg = (char *)((void *)0);
#line 4
  extra_cmd = (char *)((void *)0);
#line 6
  if ((unsigned int const   )u->verified == 1U) {
#line 6
    goto _L;
  } else
#line 6
  if ((unsigned int const   )u->verified == 0U) {
    _L: /* CIL Label */ 
#line 7
    if (b->conf) {
      {
#line 8
      status_msg = bud_expand_fmt(u, (char const   *)(b->conf)->status_msg);
      }
#line 9
      if ((b->conf)->write_users) {
#line 9
        if ((int )write___0 != -1) {
          {
#line 10
          wr_msg = bud_expand_fmt(u, (char const   *)(b->conf)->buddy_msg);
          }
        }
      }
      {
#line 11
      extra_cmd = bud_expand_fmt(u, (char const   *)(b->conf)->eventcmd);
      }
    } else {
      {
#line 13
      status_msg = bud_expand_fmt(u, g_config.status_msg);
      }
#line 14
      if ((int )write___0 > 0) {
        {
#line 14
        wr_msg = bud_expand_fmt(u, g_config.buddy_msg);
        }
      }
      {
#line 15
      extra_cmd = bud_expand_fmt(u, g_config.eventcmd);
      }
    }
  }
#line 19
  if (status_msg) {
    {
#line 20
    fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"%s",
            status_msg);
#line 21
    free((void *)status_msg);
    }
  }
#line 23
  if (wr_msg) {
#line 24
    if ((unsigned int const   )u->verified == 1U) {
      {
#line 25
      wri_do_write((u->u)->ut_user, (u->u)->ut_line, wr_msg);
      }
    }
    {
#line 26
    free((void *)wr_msg);
    }
  }
#line 28
  if (extra_cmd) {
#line 29
    if ((unsigned int const   )u->verified == 1U) {
      {
#line 30
      fork_and_exec((char const   *)extra_cmd);
      }
    }
    {
#line 31
    free((void *)extra_cmd);
    }
  }
#line 33
  return;
}
}
#line 35 "/home/june/repo/benchmarks/collector2/temp/wuzzah-0.53/event.c"
pid_t fork_and_exec(char const   *command ) 
{ 
  int cmd_result ;
  pid_t child ;
  __pid_t tmp ;

  {
  {
#line 37
  tmp = fork();
#line 37
  child = tmp;
  }
  {
#line 39
  if (child == 0) {
#line 39
    goto case_0;
  }
#line 48
  if (child == -1) {
#line 48
    goto case_neg_1;
  }
#line 51
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 40
  cmd_result = system(command);
  }
#line 41
  if (cmd_result == -1) {
    {
#line 41
    perror("fork_and_exec");
    }
  }
#line 42
  if (cmd_result != 0) {
    {
#line 43
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"warning: system(%s) returned %d\n",
            command, cmd_result);
    }
  }
  {
#line 46
  exit(cmd_result);
  }
#line 47
  goto switch_break;
  case_neg_1: /* CIL Label */ 
  {
#line 49
  perror("unable to fork in fork_and_exec");
  }
#line 50
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 51
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 53
  return (child);
}
}
#line 168 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 237
extern int fclose(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 306
extern  __attribute__((__nothrow__)) FILE *( __attribute__((__leaf__)) fdopen)(int __fd ,
                                                                               char const   *__modes ) ;
#line 622
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 828
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) feof)(FILE *__stream ) ;
#line 480 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 96
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memchr)(void const   *__s ,
                                                                                               int __c ,
                                                                                               size_t __n )  __attribute__((__pure__)) ;
#line 144
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 147
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 176
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 285
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1,2), __leaf__)) strcspn)(char const   *__s ,
                                                                                                   char const   *__reject )  __attribute__((__pure__)) ;
#line 348
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(2), __leaf__)) strtok)(char * __restrict  __s ,
                                                                                               char const   * __restrict  __delim ) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 413
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
#line 353 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 360
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 417
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) pipe)(int *__pipedes ) ;
#line 53 "/usr/include/utmpx.h"
extern void setutxent(void) ;
#line 59
extern void endutxent(void) ;
#line 65
extern struct utmpx *getutxent(void) ;
#line 192 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t ( __attribute__((__leaf__)) time)(time_t *__timer ) ;
#line 243
extern  __attribute__((__nothrow__)) struct tm *( __attribute__((__leaf__)) localtime)(time_t const   *__timer ) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 72 "/usr/include/pwd.h"
extern void setpwent(void) ;
#line 78
extern void endpwent(void) ;
#line 84
extern struct passwd *getpwent(void) ;
#line 144 "/usr/include/netdb.h"
extern struct hostent *gethostbyname(char const   *__name ) ;
#line 53 "/usr/include/arpa/inet.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) inet_ntoa)(struct in_addr __in ) ;
#line 34 "/home/june/repo/benchmarks/collector2/temp/wuzzah-0.53/common.h"
void process_args(int ac , char **av , wuzzah_config_t *conf ) ;
#line 35
int string_to_argv(char const   *str , char ***av ) ;
#line 36
void bail(char *reason , int exitval ) ;
#line 27 "/home/june/repo/benchmarks/collector2/temp/wuzzah-0.53/buddies.h"
htable_t *bud_init_budtable(void) ;
#line 28
int bud_load(char const   *fn , htable_t *ht ) ;
#line 29
void bud_load_every_user(htable_t *ht ) ;
#line 30
buddy_t *bud_create_buddy(char const   *line ) ;
#line 31
void bud_chk_utmpx(htable_t *buddy_table , short write_users ) ;
#line 35
int argvify(int *cmd_argc , char ***cmd_argv , char const   *cmdline ) ;
#line 5 "/home/june/repo/benchmarks/collector2/temp/wuzzah-0.53/buddies.c"
static int bud_hash_buddy(void *o ) 
{ 
  char *c ;
  int i ;
  int hash ;
  size_t tmp ;

  {
#line 6
  c = ((buddy_t *)o)->name;
#line 7
  hash = 0;
#line 8
  i = 0;
  {
#line 8
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 8
    tmp = strlen((char const   *)c);
    }
#line 8
    if (! ((size_t )i < tmp)) {
#line 8
      goto while_break;
    }
#line 9
    hash <<= 1;
#line 10
    hash += (int )*(c + i);
#line 8
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 12
  return (hash);
}
}
#line 15 "/home/june/repo/benchmarks/collector2/temp/wuzzah-0.53/buddies.c"
static int bud_hash_login(void *o ) 
{ 
  char *c ;
  int i ;
  int hash ;
  size_t tmp ;

  {
#line 16
  c = (((bud_utrec_t *)o)->u)->ut_line;
#line 17
  hash = 0;
#line 19
  i = 0;
  {
#line 19
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 19
    tmp = strlen((char const   *)c);
    }
#line 19
    if (! ((size_t )i < tmp)) {
#line 19
      goto while_break;
    }
#line 20
    hash <<= 1;
#line 21
    hash += (int )*(c + i);
#line 19
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 23
  return (hash);
}
}
#line 26 "/home/june/repo/benchmarks/collector2/temp/wuzzah-0.53/buddies.c"
static int bud_comp_buddy(void *o1 , void *o2 ) 
{ 
  int tmp ;

  {
  {
#line 27
  tmp = strncmp((char const   *)((buddy_t *)o1)->name, (char const   *)((buddy_t *)o2)->name,
                (size_t )32);
  }
#line 27
  return (tmp);
}
}
#line 31 "/home/june/repo/benchmarks/collector2/temp/wuzzah-0.53/buddies.c"
static int bud_comp_login(void *o1 , void *o2 ) 
{ 
  bud_utrec_t *b1 ;
  bud_utrec_t *b2 ;
  int tmp ;

  {
  {
#line 32
  b1 = (bud_utrec_t *)o1;
#line 32
  b2 = (bud_utrec_t *)o2;
#line 33
  tmp = strncmp((char const   *)((b1->u)->ut_line), (char const   *)((b2->u)->ut_line),
                (size_t )32);
  }
#line 33
  return (tmp);
}
}
#line 36 "/home/june/repo/benchmarks/collector2/temp/wuzzah-0.53/buddies.c"
htable_t *bud_init_budtable(void) 
{ 
  htable_t *tmp ;

  {
  {
#line 37
  tmp = ht_init(47, & bud_hash_buddy, & bud_comp_buddy);
  }
#line 37
  return (tmp);
}
}
#line 40 "/home/june/repo/benchmarks/collector2/temp/wuzzah-0.53/buddies.c"
int bud_load(char const   *fn , htable_t *ht ) 
{ 
  char *line_buf ;
  int line_buf_size ;
  int buf_offset ;
  int len ;
  buddy_t *next_buddy ;
  wuzzah_config_t *bconf ;
  FILE *buds ;
  int tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  void *tmp___2 ;
  char *tmp___3 ;
  size_t tmp___4 ;
  void *tmp___5 ;
  size_t tmp___6 ;
  int tmp___7 ;
  void *tmp___8 ;
  int tmp___9 ;

  {
#line 41
  line_buf = (char *)((void *)0);
#line 42
  line_buf_size = 4;
#line 42
  buf_offset = 0;
#line 42
  len = 0;
#line 43
  next_buddy = (buddy_t *)((void *)0);
#line 44
  bconf = (wuzzah_config_t *)((void *)0);
#line 45
  buds = (FILE *)((void *)0);
#line 49
  if (g_config.noloadfile) {
#line 49
    return (0);
  } else {
    {
#line 50
    tmp = strcmp(fn, "-");
    }
#line 50
    if (tmp == 0) {
#line 50
      buds = stdin;
    } else {
      {
#line 51
      buds = fopen((char const   */* __restrict  */)fn, (char const   */* __restrict  */)"r");
      }
    }
  }
#line 53
  if (! buds) {
    {
#line 54
    tmp___0 = __errno_location();
#line 54
    tmp___1 = strerror(*tmp___0);
#line 54
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"unable to open %s! (%s)\n",
            fn, tmp___1);
#line 56
    next_buddy = bud_create_buddy((char const   *)g_config.whoami);
#line 57
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"defaulting to just watching yourself...\n");
#line 58
    ht_insert((void *)next_buddy, ht);
    }
#line 59
    return (0);
  }
  {
#line 62
  tmp___2 = malloc(sizeof(char ) * (unsigned long )line_buf_size);
#line 62
  line_buf = (char *)tmp___2;
  }
  {
#line 63
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 63
    tmp___9 = feof(buds);
    }
#line 63
    if (tmp___9) {
#line 63
      goto while_break;
    }
    {
#line 65
    tmp___3 = fgets((char */* __restrict  */)(line_buf + buf_offset), line_buf_size - len,
                    (FILE */* __restrict  */)buds);
    }
#line 65
    if (! tmp___3) {
#line 65
      goto while_break;
    }
    {
#line 66
    tmp___4 = strlen((char const   *)line_buf);
#line 66
    len = (int )tmp___4;
#line 67
    tmp___6 = strcspn((char const   *)line_buf, "\n");
    }
#line 67
    if (tmp___6 == (size_t )len) {
      {
#line 67
      tmp___7 = feof(buds);
      }
#line 67
      if (! tmp___7) {
        {
#line 68
        buf_offset = len;
#line 69
        line_buf_size *= 2;
#line 70
        tmp___5 = realloc((void *)line_buf, (size_t )line_buf_size);
#line 70
        line_buf = (char *)tmp___5;
        }
#line 71
        goto while_continue;
      }
    }
    {
#line 74
    next_buddy = bud_create_buddy((char const   *)line_buf);
#line 75
    tmp___8 = ht_find((void *)next_buddy, ht);
    }
#line 75
    if (tmp___8) {
      {
#line 76
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: warning: duplicate buddy %s\n",
              g_config.progname, next_buddy->name);
      }
    } else {
      {
#line 79
      ht_insert((void *)next_buddy, ht);
      }
    }
#line 82
    buf_offset = 0;
#line 82
    len = buf_offset;
#line 83
    bconf = (wuzzah_config_t *)((void *)0);
  }
  while_break: /* CIL Label */ ;
  }
#line 86
  return (0);
}
}
#line 89 "/home/june/repo/benchmarks/collector2/temp/wuzzah-0.53/buddies.c"
void bud_load_every_user(htable_t *ht ) 
{ 
  struct passwd *pw ;
  buddy_t *next_buddy ;

  {
  {
#line 90
  pw = (struct passwd *)((void *)0);
#line 91
  next_buddy = (buddy_t *)((void *)0);
#line 93
  setpwent();
#line 94
  pw = getpwent();
  }
  {
#line 95
  while (1) {
    while_continue: /* CIL Label */ ;
#line 95
    if (! pw) {
#line 95
      goto while_break;
    }
    {
#line 96
    next_buddy = bud_create_buddy((char const   *)pw->pw_name);
#line 97
    ht_insert((void *)next_buddy, ht);
#line 98
    pw = getpwent();
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 100
  endpwent();
  }
#line 101
  return;
}
}
#line 125 "/home/june/repo/benchmarks/collector2/temp/wuzzah-0.53/buddies.c"
void bud_chk_utmpx(htable_t *buddy_table , short write_users ) 
{ 
  ht_list_t *budlist_root ;
  ht_list_t *budlist ;
  ht_list_t *utlist_root ;
  ht_list_t *utlist ;
  struct utmpx *u ;
  buddy_t *budptr ;
  buddy_t tmpbud ;
  bud_utrec_t *recptr ;
  bud_utrec_t tmprec ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;

  {
  {
#line 131
  budptr = (buddy_t *)((void *)0);
#line 132
  recptr = (bud_utrec_t *)((void *)0);
#line 134
  budlist_root = ht_iter(buddy_table);
#line 135
  budlist = budlist_root;
  }
  {
#line 136
  while (1) {
    while_continue: /* CIL Label */ ;
#line 136
    if (! budlist) {
#line 136
      goto while_break;
    }
    {
#line 137
    utlist_root = ht_iter(((buddy_t *)budlist->info)->logins);
#line 138
    utlist = utlist_root;
    }
    {
#line 139
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 139
      if (! utlist) {
#line 139
        goto while_break___0;
      }
#line 140
      ((bud_utrec_t *)utlist->info)->verified = (bud_status_e )0;
#line 141
      utlist = utlist->lptr;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 143
    ht_free_iter(utlist_root);
#line 144
    budlist = budlist->lptr;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 146
  ht_free_iter(budlist_root);
#line 148
  setutxent();
#line 149
  u = getutxent();
  }
  {
#line 150
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 150
    if (! u) {
#line 150
      goto while_break___1;
    }
#line 151
    if ((int )u->ut_type == 7) {
      {
#line 152
      tmpbud.name = u->ut_user;
#line 153
      tmp = ht_find((void *)(& tmpbud), buddy_table);
#line 153
      budptr = (buddy_t *)tmp;
      }
#line 154
      if (budptr) {
        {
#line 155
        tmprec.u = u;
#line 156
        recptr = (bud_utrec_t *)((void *)0);
#line 157
        tmp___0 = ht_find((void *)(& tmprec), budptr->logins);
#line 157
        recptr = (bud_utrec_t *)tmp___0;
        }
#line 158
        if (recptr) {
#line 159
          recptr->verified = (bud_status_e )2;
        } else {
          {
#line 161
          tmp___1 = malloc(sizeof(bud_utrec_t ));
#line 161
          recptr = (bud_utrec_t *)tmp___1;
#line 162
          tmp___2 = malloc(sizeof(struct utmpx ));
#line 162
          recptr->u = (struct utmpx *)tmp___2;
#line 163
          memcpy((void */* __restrict  */)recptr->u, (void const   */* __restrict  */)u,
                 sizeof(struct utmpx ));
#line 165
          recptr->verified = (bud_status_e )1;
#line 166
          ht_insert((void *)recptr, budptr->logins);
          }
        }
      }
    }
    {
#line 170
    u = getutxent();
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 172
  endutxent();
#line 174
  budlist_root = ht_iter(buddy_table);
#line 175
  budlist = budlist_root;
  }
  {
#line 176
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 176
    if (! budlist) {
#line 176
      goto while_break___2;
    }
    {
#line 177
    budptr = (buddy_t *)budlist->info;
#line 178
    utlist_root = ht_iter(budptr->logins);
#line 179
    utlist = utlist_root;
    }
    {
#line 180
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 180
      if (! utlist) {
#line 180
        goto while_break___3;
      }
      {
#line 181
      recptr = (bud_utrec_t *)utlist->info;
#line 183
      event((struct buddy  const  *)budptr, (struct bud_utrec  const  *)recptr, write_users);
      }
#line 185
      if ((unsigned int )recptr->verified == 0U) {
        {
#line 186
        ht_remove((void *)recptr, budptr->logins);
        }
      }
#line 188
      utlist = utlist->lptr;
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 190
    ht_free_iter(utlist_root);
#line 191
    budlist = budlist->lptr;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 193
  ht_free_iter(budlist_root);
  }
#line 195
  return;
}
}
#line 198 "/home/june/repo/benchmarks/collector2/temp/wuzzah-0.53/buddies.c"
char *bud_expand_fmt(bud_utrec_t const   *bud , char const   *fmt_string ) 
{ 
  int buf_fd[2] ;
  int buf_size ;
  int amt ;
  int i ;
  int h_len ;
  char *hname ;
  char *out_str ;
  time_t tp ;
  struct tm *tm_p ;
  FILE *buf ;
  struct hostent *hent ;
  struct in_addr in ;
  int tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  size_t tmp___2 ;
  void *tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  int tmp___6 ;
  void *tmp___7 ;
  ssize_t tmp___8 ;
  int tmp___9 ;

  {
#line 199
  buf_size = 0;
#line 199
  amt = 0;
#line 199
  h_len = 0;
#line 200
  hname = (char *)((void *)0);
#line 200
  out_str = (char *)((void *)0);
#line 207
  if (! bud) {
#line 207
    return ((char *)((void *)0));
  } else
#line 207
  if (! fmt_string) {
#line 207
    return ((char *)((void *)0));
  }
  {
#line 208
  tmp = pipe((int *)(buf_fd));
  }
#line 208
  if (tmp != 0) {
    {
#line 209
    perror("unable to alloc pipe in bud_expand_fmt");
    }
#line 210
    return ((char *)((void *)0));
  }
  {
#line 212
  buf = fdopen(buf_fd[1], "w");
  }
#line 213
  if (! buf) {
    {
#line 214
    perror("unable to attach file ptr in bud_expand_fmt");
    }
#line 215
    return ((char *)((void *)0));
  }
  {
#line 218
  tp = time((time_t *)((void *)0));
#line 219
  tm_p = localtime((time_t const   *)(& tp));
#line 221
  i = 0;
  }
  {
#line 221
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 221
    tmp___5 = strlen(fmt_string);
    }
#line 221
    if (! ((size_t )i < tmp___5)) {
#line 221
      goto while_break;
    }
#line 222
    if ((int const   )*(fmt_string + i) != 37) {
      {
#line 222
      amt = fprintf((FILE */* __restrict  */)buf, (char const   */* __restrict  */)"%c",
                    (int const   )*(fmt_string + i));
      }
    } else {
      {
#line 223
      tmp___4 = strlen(fmt_string);
      }
#line 223
      if ((size_t )i < tmp___4 - 1UL) {
#line 224
        i ++;
        {
#line 226
        if ((int const   )*(fmt_string + i) == 97) {
#line 226
          goto case_97;
        }
#line 227
        if ((int const   )*(fmt_string + i) == 98) {
#line 227
          goto case_98;
        }
#line 230
        if ((int const   )*(fmt_string + i) == 100) {
#line 230
          goto case_100;
        }
#line 235
        if ((int const   )*(fmt_string + i) == 104) {
#line 235
          goto case_104;
        }
#line 248
        if ((int const   )*(fmt_string + i) == 72) {
#line 248
          goto case_72;
        }
#line 269
        if ((int const   )*(fmt_string + i) == 108) {
#line 269
          goto case_108;
        }
#line 272
        if ((int const   )*(fmt_string + i) == 109) {
#line 272
          goto case_109;
        }
#line 276
        if ((int const   )*(fmt_string + i) == 110) {
#line 276
          goto case_110;
        }
#line 277
        if ((int const   )*(fmt_string + i) == 111) {
#line 277
          goto case_111;
        }
#line 284
        if ((int const   )*(fmt_string + i) == 117) {
#line 284
          goto case_117;
        }
#line 285
        goto switch_default;
        case_97: /* CIL Label */ 
        {
#line 226
        amt = fprintf((FILE */* __restrict  */)buf, (char const   */* __restrict  */)"\a");
        }
#line 226
        goto switch_break;
        case_98: /* CIL Label */ 
        {
#line 228
        amt = fprintf((FILE */* __restrict  */)buf, (char const   */* __restrict  */)"%s",
                      (bud->u)->ut_user);
        }
#line 229
        goto switch_break;
        case_100: /* CIL Label */ 
        {
#line 231
        amt = fprintf((FILE */* __restrict  */)buf, (char const   */* __restrict  */)"%02d:%02d:%02d",
                      tm_p->tm_hour, tm_p->tm_min, tm_p->tm_sec);
        }
#line 234
        goto switch_break;
        case_104: /* CIL Label */ 
        {
#line 236
        tmp___0 = strlen((char const   *)((bud->u)->ut_host));
#line 236
        h_len = (int )tmp___0;
        }
#line 237
        if (h_len == 0) {
          {
#line 238
          amt = fprintf((FILE */* __restrict  */)buf, (char const   */* __restrict  */)"localhost");
          }
        } else {
          {
#line 240
          tmp___1 = malloc(sizeof(char *) * (unsigned long )(h_len + 1));
#line 240
          hname = (char *)tmp___1;
#line 241
          memcpy((void */* __restrict  */)hname, (void const   */* __restrict  */)((bud->u)->ut_host),
                 (size_t )h_len);
#line 243
          *(hname + h_len) = (char )'\000';
#line 244
          amt = fprintf((FILE */* __restrict  */)buf, (char const   */* __restrict  */)"%s",
                        hname);
#line 245
          free((void *)hname);
          }
        }
#line 247
        goto switch_break;
        case_72: /* CIL Label */ 
        {
#line 249
        tmp___2 = strlen((char const   *)((bud->u)->ut_host));
#line 249
        h_len = (int )tmp___2;
        }
#line 250
        if (h_len == 0) {
          {
#line 251
          amt = fprintf((FILE */* __restrict  */)buf, (char const   */* __restrict  */)"127.0.0.1");
          }
        } else {
          {
#line 253
          tmp___3 = malloc(sizeof(char *) * (unsigned long )(h_len + 1));
#line 253
          hname = (char *)tmp___3;
#line 254
          memcpy((void */* __restrict  */)hname, (void const   */* __restrict  */)((bud->u)->ut_host),
                 (size_t )h_len);
#line 256
          *(hname + h_len) = (char )'\000';
#line 257
          hent = gethostbyname((char const   *)hname);
          }
#line 258
          if (! hent) {
            {
#line 258
            amt = fprintf((FILE */* __restrict  */)buf, (char const   */* __restrict  */)"n/a");
            }
          } else {
            {
#line 260
            memcpy((void */* __restrict  */)(& in), (void const   */* __restrict  */)*(hent->h_addr_list + 0),
                   sizeof(struct in_addr ));
#line 263
            hname = inet_ntoa(in);
#line 264
            amt = fprintf((FILE */* __restrict  */)buf, (char const   */* __restrict  */)"%s",
                          hname);
            }
          }
          {
#line 266
          free((void *)hname);
          }
        }
#line 268
        goto switch_break;
        case_108: /* CIL Label */ 
        {
#line 270
        amt = fprintf((FILE */* __restrict  */)buf, (char const   */* __restrict  */)"%-8s",
                      (bud->u)->ut_line);
        }
#line 271
        goto switch_break;
        case_109: /* CIL Label */ 
#line 273
        if (g_config.write_users) {
          {
#line 273
          amt = fprintf((FILE */* __restrict  */)buf, (char const   */* __restrict  */)"messaging");
          }
        } else {
          {
#line 274
          amt = fprintf((FILE */* __restrict  */)buf, (char const   */* __restrict  */)"not messaging");
          }
        }
#line 275
        goto switch_break;
        case_110: /* CIL Label */ 
        {
#line 276
        amt = fprintf((FILE */* __restrict  */)buf, (char const   */* __restrict  */)"\n");
        }
#line 276
        goto switch_break;
        case_111: /* CIL Label */ 
#line 278
        if ((unsigned int const   )bud->verified == 1U) {
          {
#line 279
          amt = fprintf((FILE */* __restrict  */)buf, (char const   */* __restrict  */)"logged on ");
          }
        } else
#line 280
        if ((unsigned int const   )bud->verified == 0U) {
          {
#line 281
          amt = fprintf((FILE */* __restrict  */)buf, (char const   */* __restrict  */)"logged off");
          }
        } else {
          {
#line 282
          amt = fprintf((FILE */* __restrict  */)buf, (char const   */* __restrict  */)"bummin\'");
          }
        }
#line 283
        goto switch_break;
        case_117: /* CIL Label */ 
        {
#line 284
        amt = fprintf((FILE */* __restrict  */)buf, (char const   */* __restrict  */)"%s",
                      g_config.whoami);
        }
#line 284
        goto switch_break;
        switch_default: /* CIL Label */ 
        {
#line 286
        amt = fprintf((FILE */* __restrict  */)buf, (char const   */* __restrict  */)"%c",
                      (int const   )*(fmt_string + i));
        }
#line 287
        goto switch_break;
        switch_break: /* CIL Label */ ;
        }
      }
    }
#line 290
    if (amt > 0) {
#line 290
      buf_size += amt;
    } else
#line 291
    if (amt == -1) {
      {
#line 291
      perror("error writing to pipe");
      }
    }
#line 221
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 293
  if (! g_config.no_newline) {
    {
#line 294
    amt = fprintf((FILE */* __restrict  */)buf, (char const   */* __restrict  */)"\n");
    }
#line 295
    if (amt > 0) {
#line 295
      buf_size += amt;
    } else
#line 296
    if (amt == -1) {
      {
#line 296
      perror("error writing to pipe");
      }
    }
  }
  {
#line 298
  tmp___6 = fclose(buf);
  }
#line 298
  if (tmp___6 != 0) {
    {
#line 298
    perror("error closing pipe");
    }
  }
  {
#line 300
  tmp___7 = malloc(sizeof(char ) * (unsigned long )(buf_size + 2));
#line 300
  out_str = (char *)tmp___7;
#line 301
  tmp___8 = read(buf_fd[0], (void *)out_str, sizeof(char ) * (unsigned long )buf_size);
#line 301
  amt = (int )tmp___8;
#line 302
  *(out_str + amt) = (char )'\000';
#line 303
  tmp___9 = close(buf_fd[0]);
  }
#line 303
  if (tmp___9 != 0) {
    {
#line 303
    perror("error closing pipe");
    }
  }
#line 304
  return (out_str);
}
}
#line 307 "/home/june/repo/benchmarks/collector2/temp/wuzzah-0.53/buddies.c"
int argvify(int *cmd_argc , char ***cmd_argv , char const   *cmdline ) 
{ 
  int i ;
  int num_args ;
  int cmd_len ;
  size_t tmp ;
  char **argv ;
  char *next_arg ;
  char *cmd_copy ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;

  {
  {
#line 308
  i = 0;
#line 308
  num_args = 1;
#line 308
  tmp = strlen(cmdline);
#line 308
  cmd_len = (int )tmp;
#line 309
  argv = (char **)((void *)0);
#line 309
  next_arg = (char *)((void *)0);
#line 309
  tmp___0 = strdup(cmdline);
#line 309
  cmd_copy = tmp___0;
#line 311
  tmp___1 = strtok((char */* __restrict  */)cmd_copy, (char const   */* __restrict  */)" \t\n");
  }
#line 311
  if (tmp___1) {
#line 311
    num_args ++;
  } else {
    {
#line 313
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"argvify: unable to parse string!\n");
    }
#line 314
    return (-1);
  }
  {
#line 316
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 316
    tmp___2 = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)" \t\n");
    }
#line 316
    if (! tmp___2) {
#line 316
      goto while_break;
    }
#line 316
    num_args ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 318
  tmp___3 = malloc(sizeof(char *) * (unsigned long )(num_args + 1));
#line 318
  argv = (char **)tmp___3;
  }
#line 319
  if (! argv) {
    {
#line 319
    perror("argvify");
    }
#line 319
    return (-1);
  } else {
    {
#line 320
    memset((void *)argv, 0, sizeof(char *) * (unsigned long )(num_args + 1));
    }
  }
  {
#line 322
  *(argv + 0) = strdup(g_config.progname);
#line 323
  next_arg = cmd_copy;
#line 324
  i = 1;
  }
  {
#line 324
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 324
    if (! (i < num_args)) {
#line 324
      goto while_break___0;
    }
    {
#line 325
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 325
      if (! ((int )*(next_arg + 0) == 0)) {
#line 325
        goto while_break___1;
      }
#line 325
      next_arg += sizeof(char );
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 326
    *(argv + i) = strdup((char const   *)next_arg);
#line 327
    tmp___4 = memchr((void const   *)next_arg, '\000', (size_t )((long )cmd_len - (next_arg - cmd_copy)));
#line 327
    next_arg = (char *)tmp___4;
#line 324
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 329
  *(argv + num_args) = (char *)((void *)0);
#line 330
  *cmd_argv = argv;
#line 331
  *cmd_argc = num_args - 1;
#line 332
  free((void *)cmd_copy);
  }
#line 333
  return (0);
}
}
#line 336 "/home/june/repo/benchmarks/collector2/temp/wuzzah-0.53/buddies.c"
buddy_t *bud_create_buddy(char const   *line ) 
{ 
  char *line_buf ;
  char *tmp ;
  buddy_t *next_buddy ;
  void *tmp___0 ;
  short colon ;
  short len ;
  int ac ;
  int i ;
  char **av ;
  wuzzah_config_t *bconf ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  void *tmp___3 ;

  {
  {
#line 337
  tmp = strdup(line);
#line 337
  line_buf = tmp;
#line 338
  tmp___0 = malloc(sizeof(buddy_t ));
#line 338
  next_buddy = (buddy_t *)tmp___0;
#line 339
  colon = (short)0;
#line 339
  len = (short)0;
#line 341
  av = (char **)((void *)0);
#line 342
  bconf = (wuzzah_config_t *)((void *)0);
#line 345
  tmp___1 = strlen((char const   *)line_buf);
#line 345
  len = (short )tmp___1;
#line 346
  tmp___2 = strcspn((char const   *)line_buf, ":");
#line 346
  colon = (short )tmp___2;
  }
#line 347
  if ((int )colon < (int )len - 1) {
    {
#line 348
    *(line_buf + colon) = (char )'\000';
#line 349
    tmp___3 = malloc(sizeof(wuzzah_config_t ));
#line 349
    bconf = (wuzzah_config_t *)tmp___3;
#line 350
    ac = string_to_argv((char const   *)(line_buf + ((int )colon + 1)), & av);
    }
#line 351
    if (ac == -1) {
      {
#line 351
      bail((char *)"error parsing config file\n", 1);
      }
    } else
#line 352
    if (ac) {
      {
#line 353
      process_args(ac, av, bconf);
#line 354
      i = 0;
      }
      {
#line 354
      while (1) {
        while_continue: /* CIL Label */ ;
#line 354
        if (! (i < ac)) {
#line 354
          goto while_break;
        }
        {
#line 355
        free((void *)*(av + i));
#line 354
        i ++;
        }
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 357
      free((void *)av);
      }
    }
  }
#line 362
  if ((int )*(line_buf + ((int )len - 1)) == 10) {
#line 362
    *(line_buf + ((int )len - 1)) = (char )'\000';
  }
  {
#line 363
  next_buddy->name = strdup((char const   *)line_buf);
#line 364
  next_buddy->conf = (wuzzah_config_t const   *)bconf;
#line 365
  next_buddy->logins = ht_init(47, & bud_hash_login, & bud_comp_login);
#line 368
  free((void *)line_buf);
  }
#line 369
  return (next_buddy);
}
}
#line 362 "/usr/include/stdio.h"
extern int printf(char const   * __restrict  __format  , ...) ;
#line 386
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 873
extern FILE *popen(char const   *__command , char const   *__modes ) ;
#line 879
extern int pclose(FILE *__stream ) ;
#line 132 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 140
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncat)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 779 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) isatty)(int __fd ) ;
#line 146 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 3 "/home/june/repo/benchmarks/collector2/temp/wuzzah-0.53/write.c"
static int wri_can_write(char *path ) 
{ 
  int fd ;
  int len ;
  size_t tmp ;
  size_t tmp___0 ;
  char *totalpath ;
  void *tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  int tmp___4 ;

  {
  {
#line 4
  tmp = strlen((char const   *)path);
#line 4
  tmp___0 = strlen("/dev/");
#line 4
  len = (int )((tmp + tmp___0) + 1UL);
#line 5
  tmp___1 = malloc(sizeof(char ) * (unsigned long )len);
#line 5
  totalpath = (char *)tmp___1;
#line 7
  tmp___2 = strlen("/dev/");
#line 7
  strncpy((char */* __restrict  */)totalpath, (char const   */* __restrict  */)"/dev/",
          tmp___2 + 1UL);
#line 8
  tmp___3 = strlen((char const   *)path);
#line 8
  strncat((char */* __restrict  */)totalpath, (char const   */* __restrict  */)path,
          tmp___3 + 1UL);
#line 9
  fd = open((char const   *)totalpath, 1);
  }
#line 10
  if (fd < 0) {
    {
#line 11
    perror((char const   *)totalpath);
    }
#line 12
    return (0);
  } else {
    {
#line 14
    tmp___4 = isatty(fd);
    }
#line 14
    return (tmp___4);
  }
}
}
#line 17 "/home/june/repo/benchmarks/collector2/temp/wuzzah-0.53/write.c"
int wri_do_write(char *user , char *line , char *message ) 
{ 
  int cmdlen ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  char *cmd ;
  void *tmp___2 ;
  FILE *dest ;
  int tmp___3 ;

  {
  {
#line 18
  tmp = strlen("write ");
#line 18
  tmp___0 = strlen((char const   *)user);
#line 18
  tmp___1 = strlen((char const   *)line);
#line 18
  cmdlen = (int )((((tmp + tmp___0) + 1UL) + tmp___1) + 1UL);
#line 19
  tmp___2 = malloc(sizeof(char ) * (unsigned long )cmdlen);
#line 19
  cmd = (char *)tmp___2;
#line 22
  printf((char const   */* __restrict  */)"can i write to %s?", line);
#line 23
  tmp___3 = wri_can_write(line);
  }
#line 23
  if (! tmp___3) {
    {
#line 24
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: warning, not writing to %s on %s\n",
            g_config.progname, user, line);
    }
#line 26
    return (-1);
  }
  {
#line 28
  snprintf((char */* __restrict  */)cmd, (size_t )cmdlen, (char const   */* __restrict  */)"write %s %s",
           user, line);
#line 29
  dest = popen((char const   *)cmd, "w");
#line 30
  fprintf((FILE */* __restrict  */)dest, (char const   */* __restrict  */)"%s", message);
  }
#line 31
  if (! g_config.no_newline) {
    {
#line 31
    fprintf((FILE */* __restrict  */)dest, (char const   */* __restrict  */)"\n");
    }
  }
  {
#line 33
  pclose(dest);
  }
#line 34
  return (0);
}
}
#line 531 "/usr/include/stdio.h"
extern int fgetc(FILE *__stream ) ;
#line 573
extern int fputc(int __c , FILE *__stream ) ;
#line 830
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ferror)(FILE *__stream ) ;
#line 147 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 564
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) getenv)(char const   *__name ) ;
#line 444 "/usr/include/unistd.h"
extern unsigned int sleep(unsigned int __seconds ) ;
#line 675
extern  __attribute__((__nothrow__)) __uid_t ( __attribute__((__leaf__)) getuid)(void) ;
#line 57 "/usr/include/getopt.h"
extern char *optarg ;
#line 71
extern int optind ;
#line 34 "/usr/include/libgen.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) __xpg_basename)(char *__path ) ;
#line 173 "/usr/include/getopt.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getopt_long)(int ___argc ,
                                                                                  char * const  *___argv ,
                                                                                  char const   *__shortopts ,
                                                                                  struct option  const  *__longopts ,
                                                                                  int *__longind ) ;
#line 110 "/usr/include/pwd.h"
extern struct passwd *getpwuid(__uid_t __uid ) ;
#line 30 "/home/june/repo/benchmarks/collector2/temp/wuzzah-0.53/common.h"
wuzzah_config_t g_config  ;
#line 23 "/home/june/repo/benchmarks/collector2/temp/wuzzah-0.53/wuzzah.c"
void usage(void) ;
#line 24
void version(void) ;
#line 25
void wuzzah_whoami(void) ;
#line 26
void wuzzah_add_extrabuddies(char const   *line , htable_t *ht ) ;
#line 41 "/home/june/repo/benchmarks/collector2/temp/wuzzah-0.53/wuzzah.c"
static char const   *g_default_buddy_msg  =    "(wuzzah)  %u says: \"shoutout to my homie %b.\"";
#line 43 "/home/june/repo/benchmarks/collector2/temp/wuzzah-0.53/wuzzah.c"
static char const   *g_default_status_msg  =    "(%d)  %b %o %l from %h";
#line 45 "/home/june/repo/benchmarks/collector2/temp/wuzzah-0.53/wuzzah.c"
static char const   *g_default_infile  =    ".wuzzah";
#line 46 "/home/june/repo/benchmarks/collector2/temp/wuzzah-0.53/wuzzah.c"
static int const   g_default_sleep_interval  =    (int const   )1;
#line 48 "/home/june/repo/benchmarks/collector2/temp/wuzzah-0.53/wuzzah.c"
struct option program_opts[16]  = 
#line 48
  {      {"all-users", 1, (int *)0, 'a'}, 
        {"exec-command", 1, (int *)0, 'c'}, 
        {"help", 0, (int *)0, 'h'}, 
        {"buddyfile", 1, (int *)0, 'f'}, 
        {"no-buddyfile", 0, (int *)0, 'F'}, 
        {"interval", 1, (int *)0, 'i'}, 
        {"message", 1, (int *)0, 'm'}, 
        {"no-newline", 0, (int *)0, 'n'}, 
        {"process-once", 0, (int *)0, 'o'}, 
        {"process-current", 0, (int *)0, 'p'}, 
        {"silent", 0, (int *)0, 'q'}, 
        {"status-message", 1, (int *)0, 's'}, 
        {"users", 1, (int *)0, 'u'}, 
        {"version", 0, (int *)0, 'v'}, 
        {"write-buddies", 0, (int *)0, 'w'}, 
        {(char const   *)((void *)0), 0, (int *)0, 0}};
#line 71 "/home/june/repo/benchmarks/collector2/temp/wuzzah-0.53/wuzzah.c"
int main(int argc , char **argv ) 
{ 
  htable_t *ht ;
  unsigned int tmp ;

  {
  {
#line 72
  ht = (htable_t *)((void *)0);
#line 73
  process_args(argc, argv, & g_config);
#line 75
  ht = bud_init_budtable();
#line 76
  wuzzah_whoami();
  }
#line 77
  if (g_config.all_users) {
    {
#line 78
    bud_load_every_user(ht);
    }
  } else {
#line 80
    if (g_config.extrabuddies) {
      {
#line 81
      wuzzah_add_extrabuddies((char const   *)g_config.extrabuddies, ht);
      }
    }
#line 82
    if (! g_config.noloadfile) {
      {
#line 82
      bud_load((char const   *)g_config.infile, ht);
      }
    }
  }
#line 85
  if (ht->size == 0) {
    {
#line 86
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: no buddies specified\n",
            g_config.progname);
#line 88
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"well, if you don\'t have any friends for\n");
#line 89
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"me to watch, I\'m going away!\n");
#line 90
    exit(1);
    }
  }
#line 95
  if (! g_config.process_current) {
    {
#line 95
    bud_chk_utmpx(ht, (short)-1);
    }
  } else {
    {
#line 96
    bud_chk_utmpx(ht, g_config.write_users);
    }
  }
#line 98
  if (g_config.run_once) {
#line 98
    return (0);
  }
  {
#line 100
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 100
    tmp = sleep((unsigned int )g_config.sleep_interval);
    }
#line 100
    if (tmp) {
#line 100
      goto while_break;
    }
    {
#line 101
    bud_chk_utmpx(ht, g_config.write_users);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 104
  return (0);
}
}
#line 109 "/home/june/repo/benchmarks/collector2/temp/wuzzah-0.53/wuzzah.c"
void process_args(int ac , char **av , wuzzah_config_t *conf ) 
{ 
  int c ;
  int len ;
  char *homedir ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  void *tmp___5 ;
  size_t tmp___6 ;
  size_t tmp___7 ;

  {
  {
#line 113
  optind = 0;
#line 115
  memset((void *)conf, 0, sizeof(wuzzah_config_t ));
#line 116
  tmp = __xpg_basename(*(av + 0));
#line 116
  *(av + 0) = tmp;
#line 116
  conf->progname = (char const   *)tmp;
  }
  {
#line 118
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 119
    c = getopt_long(ac, (char * const  *)av, "ac:f:Fhi:m:nopqs:u:vw", (struct option  const  *)(program_opts),
                    (int *)((void *)0));
    }
    {
#line 122
    if (c == 97) {
#line 122
      goto case_97;
    }
#line 123
    if (c == 99) {
#line 123
      goto case_99;
    }
#line 124
    if (c == 102) {
#line 124
      goto case_102;
    }
#line 125
    if (c == 70) {
#line 125
      goto case_70;
    }
#line 126
    if (c == 104) {
#line 126
      goto case_104;
    }
#line 127
    if (c == 105) {
#line 127
      goto case_105;
    }
#line 128
    if (c == 109) {
#line 128
      goto case_109;
    }
#line 129
    if (c == 110) {
#line 129
      goto case_110;
    }
#line 130
    if (c == 111) {
#line 130
      goto case_111;
    }
#line 131
    if (c == 112) {
#line 131
      goto case_112;
    }
#line 132
    if (c == 113) {
#line 132
      goto case_113;
    }
#line 133
    if (c == 115) {
#line 133
      goto case_115;
    }
#line 134
    if (c == 117) {
#line 134
      goto case_117;
    }
#line 135
    if (c == 118) {
#line 135
      goto case_118;
    }
#line 136
    if (c == 119) {
#line 136
      goto case_119;
    }
#line 121
    goto switch_break;
    case_97: /* CIL Label */ 
#line 122
    conf->all_users = (short)1;
#line 122
    goto switch_break;
    case_99: /* CIL Label */ 
    {
#line 123
    tmp___0 = strdup((char const   *)optarg);
#line 123
    conf->eventcmd = (char const   *)tmp___0;
    }
#line 123
    goto switch_break;
    case_102: /* CIL Label */ 
    {
#line 124
    conf->infile = strdup((char const   *)optarg);
    }
#line 124
    goto switch_break;
    case_70: /* CIL Label */ 
#line 125
    conf->noloadfile = (short)1;
#line 125
    goto switch_break;
    case_104: /* CIL Label */ 
    {
#line 126
    version();
#line 126
    usage();
#line 126
    exit(0);
    }
#line 126
    goto switch_break;
    case_105: /* CIL Label */ 
    {
#line 127
    conf->sleep_interval = atoi((char const   *)optarg);
    }
#line 127
    goto switch_break;
    case_109: /* CIL Label */ 
    {
#line 128
    tmp___1 = strdup((char const   *)optarg);
#line 128
    conf->buddy_msg = (char const   *)tmp___1;
    }
#line 128
    goto switch_break;
    case_110: /* CIL Label */ 
#line 129
    conf->no_newline = (short)1;
#line 129
    goto switch_break;
    case_111: /* CIL Label */ 
#line 130
    conf->run_once = (short)1;
    case_112: /* CIL Label */ 
#line 131
    conf->process_current = (short)1;
#line 131
    goto switch_break;
    case_113: /* CIL Label */ 
#line 132
    conf->write_users = (short)0;
#line 132
    goto switch_break;
    case_115: /* CIL Label */ 
    {
#line 133
    tmp___2 = strdup((char const   *)optarg);
#line 133
    conf->status_msg = (char const   *)tmp___2;
    }
#line 133
    goto switch_break;
    case_117: /* CIL Label */ 
    {
#line 134
    conf->extrabuddies = strdup((char const   *)optarg);
    }
#line 134
    goto switch_break;
    case_118: /* CIL Label */ 
    {
#line 135
    version();
#line 135
    exit(0);
    }
#line 135
    goto switch_break;
    case_119: /* CIL Label */ 
#line 136
    conf->write_users = (short)1;
#line 136
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 138
    if (c == -1) {
#line 138
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 140
  if (! conf->buddy_msg) {
#line 140
    conf->buddy_msg = g_default_buddy_msg;
  }
#line 141
  if (! conf->status_msg) {
#line 141
    conf->status_msg = g_default_status_msg;
  }
#line 144
  if (! conf->infile) {
#line 144
    if (! conf->noloadfile) {
      {
#line 145
      homedir = getenv("HOME");
      }
#line 146
      if ((unsigned long )homedir == (unsigned long )((void *)0)) {
#line 147
        conf->noloadfile = (short)1;
      } else {
        {
#line 149
        tmp___3 = strlen((char const   *)homedir);
#line 149
        tmp___4 = strlen(g_default_infile);
#line 149
        len = (int )((tmp___3 + 1UL) + tmp___4);
#line 150
        tmp___5 = malloc(sizeof(char ) * (unsigned long )(len + 1));
#line 150
        conf->infile = (char *)tmp___5;
#line 151
        tmp___6 = strlen((char const   *)homedir);
#line 151
        strncpy((char */* __restrict  */)conf->infile, (char const   */* __restrict  */)homedir,
                tmp___6 + 1UL);
#line 152
        strncat((char */* __restrict  */)conf->infile, (char const   */* __restrict  */)"/",
                (size_t )1);
#line 153
        tmp___7 = strlen(g_default_infile);
#line 153
        strncat((char */* __restrict  */)conf->infile, (char const   */* __restrict  */)g_default_infile,
                tmp___7);
        }
      }
    }
  }
#line 157
  if (! conf->sleep_interval) {
#line 158
    conf->sleep_interval = (int )g_default_sleep_interval;
  }
#line 159
  return;
}
}
#line 166 "/home/june/repo/benchmarks/collector2/temp/wuzzah-0.53/wuzzah.c"
int string_to_argv(char const   *str , char ***av ) 
{ 
  int c ;
  int i ;
  int j ;
  int num_args ;
  int len ;
  size_t tmp ;
  int procd_str_pipe[2] ;
  int arg_len ;
  int arg_max_len ;
  short parsing_whitespace ;
  char **argv ;
  char *tmp___0 ;
  char *tmp___1 ;
  FILE *p_write ;
  FILE *p_read ;
  int tmp___2 ;
  int tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
  {
#line 167
  c = 0;
#line 167
  i = 0;
#line 167
  j = 0;
#line 167
  num_args = 1;
#line 167
  tmp = strlen(str);
#line 167
  len = (int )tmp;
#line 168
  arg_len = 0;
#line 168
  arg_max_len = 0;
#line 169
  parsing_whitespace = (short)1;
#line 170
  argv = (char **)((void *)0);
#line 170
  tmp___1 = strdup(str);
#line 170
  tmp___0 = tmp___1;
#line 173
  tmp___2 = pipe((int *)(procd_str_pipe));
  }
#line 173
  if (tmp___2) {
    {
#line 173
    perror("opening pipe");
    }
  }
  {
#line 174
  p_read = fdopen(procd_str_pipe[0], "r");
  }
#line 175
  if (! p_read) {
    {
#line 175
    perror("opening read end of pipe");
    }
  }
  {
#line 176
  p_write = fdopen(procd_str_pipe[1], "w");
  }
#line 177
  if (! p_write) {
    {
#line 177
    perror("opening write end of pipe");
    }
  }
#line 179
  i = 0;
  {
#line 179
  while (1) {
    while_continue: /* CIL Label */ ;
#line 179
    if (! (i < len)) {
#line 179
      goto while_break;
    }
    {
#line 181
    if ((int const   )*(str + i) == 92) {
#line 181
      goto case_92;
    }
#line 195
    if ((int const   )*(str + i) == 9) {
#line 195
      goto case_9;
    }
#line 195
    if ((int const   )*(str + i) == 10) {
#line 195
      goto case_9;
    }
#line 195
    if ((int const   )*(str + i) == 32) {
#line 195
      goto case_9;
    }
#line 203
    if ((int const   )*(str + i) == 39) {
#line 203
      goto case_39;
    }
#line 222
    if ((int const   )*(str + i) == 34) {
#line 222
      goto case_34;
    }
#line 241
    goto switch_default;
    case_92: /* CIL Label */ 
#line 182
    if (parsing_whitespace) {
#line 183
      num_args ++;
#line 184
      parsing_whitespace = (short)0;
    }
#line 186
    if (i == len - 1) {
      {
#line 187
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"syntax err: unterminated \\\n");
      }
#line 189
      return (-1);
    }
    {
#line 191
    tmp___3 = i;
#line 191
    i ++;
#line 191
    fputc((int )*(str + tmp___3), p_write);
#line 192
    fputc((int )*(str + i), p_write);
#line 193
    arg_len += 2;
    }
#line 194
    goto switch_break;
    case_9: /* CIL Label */ 
    case_10: /* CIL Label */ 
    case_32: /* CIL Label */ 
#line 196
    if (! parsing_whitespace) {
#line 197
      if (arg_len > arg_max_len) {
#line 197
        arg_max_len = arg_len;
      }
      {
#line 198
      arg_len = 0;
#line 199
      fputc('\000', p_write);
#line 200
      parsing_whitespace = (short)1;
      }
    }
#line 202
    goto switch_break;
    case_39: /* CIL Label */ 
#line 204
    if (parsing_whitespace) {
#line 205
      num_args ++;
#line 206
      parsing_whitespace = (short)0;
    }
    {
#line 208
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 208
      if (! ((int const   )*(str + (i + 1)) != 39)) {
#line 208
        if (! ((int const   )*(str + i) == 92)) {
#line 208
          goto while_break___0;
        }
      }
#line 209
      i ++;
#line 209
      if (i > len) {
        {
#line 210
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"error: unterminated \'\n");
        }
#line 212
        return (-1);
      }
#line 214
      if ((int const   )*(str + (i + 1)) == 39) {
#line 214
        if ((int const   )*(str + i) == 92) {
#line 214
          goto while_continue___0;
        } else {
          {
#line 216
          arg_len ++;
#line 217
          fputc((int )*(str + i), p_write);
          }
        }
      } else {
        {
#line 216
        arg_len ++;
#line 217
        fputc((int )*(str + i), p_write);
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 220
    i ++;
#line 221
    goto switch_break;
    case_34: /* CIL Label */ 
#line 223
    if (parsing_whitespace) {
#line 224
      num_args ++;
#line 225
      parsing_whitespace = (short)0;
    }
    {
#line 227
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 227
      if (! ((int const   )*(str + (i + 1)) != 34)) {
#line 227
        if (! ((int const   )*(str + i) == 92)) {
#line 227
          goto while_break___1;
        }
      }
#line 228
      i ++;
#line 228
      if (i > len) {
        {
#line 229
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"error: unterminated \"\n");
        }
#line 231
        return (-1);
      }
#line 233
      if ((int const   )*(str + (i + 1)) == 34) {
#line 233
        if ((int const   )*(str + i) == 92) {
#line 233
          goto while_continue___1;
        } else {
          {
#line 235
          arg_len ++;
#line 236
          fputc((int )*(str + i), p_write);
          }
        }
      } else {
        {
#line 235
        arg_len ++;
#line 236
        fputc((int )*(str + i), p_write);
        }
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 239
    i ++;
#line 240
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 242
    if (parsing_whitespace) {
#line 243
      num_args ++;
#line 244
      parsing_whitespace = (short)0;
    }
    {
#line 246
    arg_len ++;
#line 247
    fputc((int )*(str + i), p_write);
    }
#line 248
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 179
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 252
  fclose(p_write);
#line 253
  tmp___4 = malloc(sizeof(char *) * (unsigned long )(num_args + 1));
#line 253
  argv = (char **)tmp___4;
#line 254
  memset((void *)argv, 0, sizeof(char ) * (unsigned long )(num_args + 1));
#line 256
  *(argv + 0) = strdup(g_config.progname);
#line 258
  i = 1;
  }
  {
#line 258
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 258
    if (! (i < num_args)) {
#line 258
      goto while_break___2;
    }
    {
#line 259
    tmp___5 = malloc(sizeof(char ) * (unsigned long )(arg_max_len + 1));
#line 259
    *(argv + i) = (char *)tmp___5;
#line 260
    memset((void *)*(argv + i), 0, sizeof(char ) * (unsigned long )(arg_max_len + 1));
#line 261
    c = fgetc(p_read);
#line 262
    j = 0;
    }
    {
#line 262
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 262
      if (c != 0) {
        {
#line 262
        tmp___6 = feof(p_read);
        }
#line 262
        if (tmp___6) {
#line 262
          goto while_break___3;
        } else {
          {
#line 262
          tmp___7 = ferror(p_read);
          }
#line 262
          if (tmp___7) {
#line 262
            goto while_break___3;
          }
        }
      } else {
#line 262
        goto while_break___3;
      }
      {
#line 263
      *(*(argv + i) + j) = (char )c;
#line 264
      c = fgetc(p_read);
#line 262
      j ++;
      }
    }
    while_break___3: /* CIL Label */ ;
    }
#line 266
    *(*(argv + i) + j) = (char )'\000';
#line 258
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 268
  free((void *)tmp___0);
#line 269
  *(argv + num_args) = (char *)((void *)0);
#line 270
  *av = argv;
  }
#line 271
  return (num_args);
}
}
#line 274 "/home/june/repo/benchmarks/collector2/temp/wuzzah-0.53/wuzzah.c"
void wuzzah_whoami(void) 
{ 
  struct passwd *pwd ;
  __uid_t tmp ;
  struct passwd *tmp___0 ;
  __uid_t tmp___1 ;
  void *tmp___2 ;
  size_t tmp___3 ;
  void *tmp___4 ;
  size_t tmp___5 ;

  {
  {
#line 275
  tmp = getuid();
#line 275
  tmp___0 = getpwuid(tmp);
#line 275
  pwd = tmp___0;
  }
#line 277
  if (! pwd) {
    {
#line 278
    tmp___1 = getuid();
#line 278
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"uh, your uid (%d) wasn\'t found..\n",
            (int )tmp___1);
#line 280
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"so I\'m setting your name to \"dumbass\".\n");
#line 281
    tmp___2 = malloc(sizeof(char ) * 8UL);
#line 281
    g_config.whoami = (char *)tmp___2;
#line 282
    strncpy((char */* __restrict  */)g_config.whoami, (char const   */* __restrict  */)"dumbass",
            (size_t )8);
    }
  } else {
    {
#line 284
    tmp___3 = strlen((char const   *)pwd->pw_name);
#line 284
    tmp___4 = malloc(sizeof(char ) * (tmp___3 + 1UL));
#line 284
    g_config.whoami = (char *)tmp___4;
#line 285
    tmp___5 = strlen((char const   *)pwd->pw_name);
#line 285
    strncpy((char */* __restrict  */)g_config.whoami, (char const   */* __restrict  */)pwd->pw_name,
            tmp___5 + 1UL);
    }
  }
#line 287
  return;
}
}
#line 289 "/home/june/repo/benchmarks/collector2/temp/wuzzah-0.53/wuzzah.c"
void wuzzah_add_extrabuddies(char const   *line , htable_t *ht ) 
{ 
  int i ;
  int len ;
  size_t tmp ;
  char const   *head ;
  char *buf ;
  size_t tmp___0 ;
  void *tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  buddy_t *tmp___5 ;

  {
  {
#line 290
  i = 0;
#line 290
  tmp = strlen(line);
#line 290
  len = (int )tmp;
#line 291
  head = line;
#line 292
  buf = (char *)((void *)0);
#line 294
  tmp___0 = strlen(line);
#line 294
  tmp___1 = malloc(sizeof(char ) * (tmp___0 + 1UL));
#line 294
  buf = (char *)tmp___1;
  }
  {
#line 295
  while (1) {
    while_continue: /* CIL Label */ ;
#line 295
    if (! ((int )(head - line) < len)) {
#line 295
      goto while_break;
    }
    {
#line 296
    tmp___2 = strcspn(head, " \t\n,:");
#line 296
    i = (int )tmp___2;
    }
#line 297
    if (i > 0) {
      {
#line 298
      strncpy((char */* __restrict  */)buf, (char const   */* __restrict  */)head,
              (size_t )i);
#line 299
      *(buf + i) = (char )'\000';
      }
    } else {
      {
#line 301
      tmp___3 = strlen(head);
#line 301
      strncpy((char */* __restrict  */)buf, (char const   */* __restrict  */)head,
              tmp___3);
#line 302
      tmp___4 = strlen(head);
#line 302
      *(buf + tmp___4) = (char )'\000';
      }
    }
    {
#line 304
    tmp___5 = bud_create_buddy((char const   *)buf);
#line 304
    ht_insert((void *)tmp___5, ht);
#line 305
    head += i + 1;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 307
  free((void *)buf);
  }
#line 308
  return;
}
}
#line 310 "/home/june/repo/benchmarks/collector2/temp/wuzzah-0.53/wuzzah.c"
void version(void) 
{ 


  {
  {
#line 311
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s v%s\t-\twuuzzzaaah?\n",
          g_config.progname, "0.53");
#line 313
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"copyright 2002 sean finney <seanius@seanius.net>\n");
  }
#line 314
  return;
}
}
#line 316 "/home/june/repo/benchmarks/collector2/temp/wuzzah-0.53/wuzzah.c"
void usage(void) 
{ 


  {
  {
#line 317
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\nusage:\t");
#line 318
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s [OPTIONS] ...\n",
          g_config.progname);
#line 319
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  -h, --help                   this informative usage summary :)\n  -v, --version                the current version and copyright\n\n  -a, --all-users              load and watch for all users\n  -c, --exec-cmd=CMD           evaluate/execute CMD with every login\n  -f, --buddyfile=FILE         use FILE as buddyfile, can be \'-\' for\n                               signifying to use stdin.\n  -F, --no-buddyfile           do not attempt to load the file which\n                               contains the list of buddies to watch\n  -i, --interval=NUM           sleep NUM seconds between each polling\n  -m, --message=STRING         use STRING as a message template to greet\n                               logged-in buddies. RTFM for more information\n  -n, --no-newline             don\'t end the various messages in newlines\n  -o, --process-once           exit after having scanned once through the\n                               records.\n  -p, --process-current        override wuzzah\'s default behavior and\n                               message/write/exec-cmd the users already\n                               logged in.\n  -q, --silent                 don\'t message buddies when they log in\n  -s, --status-message=STRING  use STRING as a template for displaying the\n                               status of people logging in and out\n  -u, --users=LIST             adds LIST to the list of buddies for which\n                               to watch.\n  -w, --write-budies           be obnoxious and write your buddy every time\n                               you see him/her log in.\n");
  }
#line 345
  return;
}
}
#line 347 "/home/june/repo/benchmarks/collector2/temp/wuzzah-0.53/wuzzah.c"
void bail(char *reason , int exitval ) 
{ 


  {
#line 348
  if (reason) {
    {
#line 348
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: bailing: %s\n",
            g_config.progname, reason);
    }
  }
  {
#line 350
  exit(exitval);
  }
}
}
