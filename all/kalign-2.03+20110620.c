/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 53 "/home/june/repo/benchmarks/collector/temp/kalign-2.03+20110620/kalign2.h"
struct feature;
#line 58 "/home/june/repo/benchmarks/collector/temp/kalign-2.03+20110620/kalign2.h"
struct parameters {
   char **infile ;
   char *input ;
   char *outfile ;
   char *format ;
   char *feature_type ;
   char *alignment_type ;
   char *feature_mode ;
   char *distance ;
   char *tree ;
   char *sort ;
   char *sub_matrix ;
   char *print_tree ;
   char *print_svg_tree ;
   float gpo ;
   float gpe ;
   float tgpe ;
   float secret ;
   float zlevel ;
   float same_feature_score ;
   float diff_feature_score ;
   int reformat ;
   int id ;
   int aa ;
   int alter_gaps ;
   int ntree ;
   int help_flag ;
   int quiet ;
   int dna ;
   float alter_range ;
   int alter_weight ;
   float internal_gap_weight ;
   int smooth_window ;
   float gap_inc ;
};
#line 102 "/home/june/repo/benchmarks/collector/temp/kalign-2.03+20110620/kalign2.h"
struct names {
   int *start ;
   int *end ;
   int *len ;
};
#line 120
struct sequence_info;
#line 120 "/home/june/repo/benchmarks/collector/temp/kalign-2.03+20110620/kalign2.h"
struct alignment {
   struct feature **ft ;
   struct sequence_info **si ;
   unsigned int **sip ;
   unsigned int *nsip ;
   unsigned int *sl ;
   unsigned int *lsn ;
   int **s ;
   char **seq ;
   char **sn ;
};
#line 133 "/home/june/repo/benchmarks/collector/temp/kalign-2.03+20110620/kalign2.h"
struct sequence_info {
   struct sequence_info *next ;
   char *name ;
   char *value ;
};
#line 139 "/home/june/repo/benchmarks/collector/temp/kalign-2.03+20110620/kalign2.h"
struct feature {
   struct feature *next ;
   char *type ;
   char *note ;
   int start ;
   int end ;
   int color ;
};
#line 47 "/home/june/repo/benchmarks/collector/temp/kalign-2.03+20110620/kalign2.h"
struct feature_matrix {
   float **m ;
   int mdim ;
   int stride ;
};
#line 175 "/home/june/repo/benchmarks/collector/temp/kalign-2.03+20110620/kalign2.h"
struct aln_tree_node {
   struct aln_tree_node **links ;
   int *internal_lables ;
   int *path ;
   int *profile ;
   int *seq ;
   int len ;
   int done ;
   int num ;
};
#line 193 "/home/june/repo/benchmarks/collector/temp/kalign-2.03+20110620/kalign2.h"
struct ntree_data {
   struct aln_tree_node *realtree ;
   struct alignment *aln ;
   float **profile ;
   int **map ;
   float **submatrix ;
   int *tree ;
   int ntree ;
};
#line 186 "/home/june/repo/benchmarks/collector/temp/kalign-2.03+20110620/kalign2.h"
struct tree_node {
   struct tree_node *left ;
   struct tree_node *right ;
   int label ;
   int edge ;
};
#line 97 "/home/june/repo/benchmarks/collector/temp/kalign-2.03+20110620/kalign2.h"
struct node {
   struct node *next ;
   int pos ;
};
#line 108 "/home/june/repo/benchmarks/collector/temp/kalign-2.03+20110620/kalign2.h"
struct bignode {
   struct bignode *next ;
   unsigned int pos[16] ;
   unsigned int num ;
};
#line 148
struct states;
#line 148 "/home/june/repo/benchmarks/collector/temp/kalign-2.03+20110620/kalign2.h"
struct hirsch_mem {
   struct states *f ;
   struct states *b ;
   int starta ;
   int startb ;
   int enda ;
   int endb ;
   int size ;
   int len_a ;
   int len_b ;
};
#line 168 "/home/june/repo/benchmarks/collector/temp/kalign-2.03+20110620/kalign2.h"
struct states {
   float a ;
   float ga ;
   float gb ;
   float x ;
};
#line 104 "/usr/include/getopt.h"
struct option {
   char const   *name ;
   int has_arg ;
   int *flag ;
   int val ;
};
#line 53 "/home/june/repo/benchmarks/collector/temp/kalign-2.03+20110620/kalign2.h"
struct utype_ufeat {
   struct feature *t ;
   struct feature *f ;
};
#line 315 "/usr/include/libio.h"
typedef struct _IO_FILE _IO_FILE;
#line 160 "/home/june/repo/benchmarks/collector/temp/kalign-2.03+20110620/kalign2.h"
struct dp_matrix {
   struct states *s ;
   void *tb_mem ;
   char **tb ;
   int x ;
   int y ;
};
#line 115 "/home/june/repo/benchmarks/collector/temp/kalign-2.03+20110620/kalign2_mem.c"
struct sequence_information;
#line 169 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 170
extern struct _IO_FILE *stderr ;
#line 237
extern int fclose(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 41 "/home/june/repo/benchmarks/collector/temp/kalign-2.03+20110620/kalign2.h"
unsigned int numseq ;
#line 217
void output(struct alignment *aln , struct parameters *param ) ;
#line 272
int byg_start(char *pattern , char *text ) ;
#line 286
void free_aln(struct alignment *aln ) ;
#line 287
void free_param(struct parameters *param ) ;
#line 404
struct names *names_alloc(struct names *n ) ;
#line 405
void names_free(struct names *n ) ;
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 28 "/home/june/repo/benchmarks/collector/temp/kalign-2.03+20110620/kalign2_output.h"
void aln_output(struct alignment *aln , struct parameters *param ) ;
#line 29
void msf_output(struct alignment *aln , char *outfile ) ;
#line 30
void fasta_output(struct alignment *aln , char *outfile ) ;
#line 31
void clustal_output(struct alignment *aln , char *outfile ) ;
#line 32
void macsim_output(struct alignment *aln , char *outfile , char *infile ) ;
#line 34
struct names *get_meaningful_names(struct alignment *aln , int id ) ;
#line 29 "/home/june/repo/benchmarks/collector/temp/kalign-2.03+20110620/kalign2_output.c"
void output(struct alignment *aln , struct parameters *param ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 31
  if (! param->format) {
    {
#line 32
    fasta_output(aln, param->outfile);
    }
  } else {
    {
#line 34
    tmp___2 = byg_start(param->format, (char *)"alnALNclustalCLUSTALclustalwCLUSTALWclustalWClustalW");
    }
#line 34
    if (tmp___2 != -1) {
      {
#line 35
      aln_output(aln, param);
      }
    } else {
      {
#line 36
      tmp___1 = byg_start(param->format, (char *)"msfMSFgcgGCGpileupPILEUP");
      }
#line 36
      if (tmp___1 != -1) {
        {
#line 37
        msf_output(aln, param->outfile);
        }
      } else {
        {
#line 38
        tmp___0 = byg_start(param->format, (char *)"eclu");
        }
#line 38
        if (tmp___0 != -1) {
          {
#line 39
          clustal_output(aln, param->outfile);
          }
        } else {
          {
#line 40
          tmp = byg_start((char *)"macsim", param->format);
          }
#line 40
          if (tmp != -1) {
            {
#line 41
            macsim_output(aln, param->outfile, *(param->infile + 0));
            }
          } else {
            {
#line 43
            fasta_output(aln, param->outfile);
            }
          }
        }
      }
    }
  }
  {
#line 46
  free_param(param);
  }
#line 47
  return;
}
}
#line 49 "/home/june/repo/benchmarks/collector/temp/kalign-2.03+20110620/kalign2_output.c"
void macsim_output(struct alignment *aln , char *outfile , char *infile ) 
{ 
  int i ;
  int j ;
  int f ;
  int tmp ;
  struct feature *fn ;
  FILE *fout ;
  unsigned short const   **tmp___0 ;

  {
#line 53
  fn = (struct feature *)0;
#line 54
  fout = (FILE *)((void *)0);
#line 55
  if (outfile) {
    {
#line 56
    fout = fopen((char const   */* __restrict  */)outfile, (char const   */* __restrict  */)"w");
    }
#line 56
    if ((unsigned long )fout == (unsigned long )((void *)0)) {
      {
#line 57
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"can\'t open output\n");
#line 58
      exit(0);
      }
    }
  } else {
#line 61
    fout = stdout;
  }
  {
#line 63
  fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"<?xml version=\"1.0\"?>\n<!DOCTYPE macsim SYSTEM \"http://www-bio3d-igbmc.u-strasbg.fr/macsim.dtd\">\n<macsim>\n<alignment>\n<aln-name>");
  }
#line 64
  if (infile) {
    {
#line 65
    fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"%s.kalign",
            infile);
    }
  } else {
    {
#line 67
    fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"kalign alignment");
    }
  }
  {
#line 69
  fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"</aln-name>\n");
#line 71
  i = 0;
  }
  {
#line 71
  while (1) {
    while_continue: /* CIL Label */ ;
#line 71
    if (! ((unsigned int )i < numseq)) {
#line 71
      goto while_break;
    }
    {
#line 73
    f = (int )*(aln->nsip + i);
#line 75
    fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"<sequence seq-type=\"Protein\">\n");
#line 76
    fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"<seq-name>");
#line 77
    j = 0;
    }
    {
#line 77
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 77
      if (! ((unsigned int )j < *(aln->lsn + f))) {
#line 77
        goto while_break___0;
      }
      {
#line 78
      tmp___0 = __ctype_b_loc();
      }
#line 78
      if (! ((int const   )*(*tmp___0 + (int )*(*(aln->sn + f) + j)) & 2)) {
        {
#line 79
        fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"%c",
                (int )*(*(aln->sn + f) + j));
        }
      }
#line 77
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 82
    fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"</seq-name>");
#line 83
    fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"<seq-info>\n");
#line 84
    fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"<accession>1aab_</accession>\n");
#line 85
    fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"<nid>1aab_</nid>\n");
#line 86
    fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"<ec>0.0.0.0</ec>\n");
#line 87
    fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"<group>0</group>\n");
    }
#line 88
    if (aln->ft) {
#line 89
      if (*(aln->ft + f)) {
        {
#line 91
        fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"<ftable>\n");
#line 92
        fn = *(aln->ft + f);
        }
        {
#line 93
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 93
          if (! fn) {
#line 93
            goto while_break___1;
          }
          {
#line 94
          fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"<fitem><ftype>%s</ftype><fstart>%d</fstart><fstop>%d</fstop><fnote>%s</fnote></fitem>\n",
                  fn->type, fn->start, fn->end, fn->note);
#line 95
          fn = fn->next;
          }
        }
        while_break___1: /* CIL Label */ ;
        }
        {
#line 97
        fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"</ftable>\n</seq-info>\n");
        }
      }
    }
    {
#line 100
    fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"<seq-data>\n");
#line 102
    j = 0;
    }
    {
#line 102
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 102
      if (! ((unsigned int )j < *(aln->sl + f))) {
#line 102
        goto while_break___2;
      }
#line 103
      tmp = *(*(aln->s + f) + j);
      {
#line 104
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 104
        if (! tmp) {
#line 104
          goto while_break___3;
        }
        {
#line 105
        fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"-");
#line 106
        tmp --;
        }
      }
      while_break___3: /* CIL Label */ ;
      }
      {
#line 108
      fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"%c",
              (int )*(*(aln->seq + f) + j));
#line 102
      j ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
#line 110
    tmp = *(*(aln->s + f) + *(aln->sl + f));
    {
#line 111
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 111
      if (! tmp) {
#line 111
        goto while_break___4;
      }
      {
#line 112
      fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"-");
#line 113
      tmp --;
      }
    }
    while_break___4: /* CIL Label */ ;
    }
    {
#line 115
    fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"\n");
#line 116
    fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"</seq-data>\n");
#line 117
    fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"</sequence>\n");
#line 71
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 119
  fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"</alignment>\n");
#line 120
  fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"</macsim>\n");
  }
#line 121
  if (outfile) {
    {
#line 122
    fclose(fout);
    }
  }
  {
#line 124
  free_aln(aln);
  }
#line 125
  return;
}
}
#line 128 "/home/june/repo/benchmarks/collector/temp/kalign-2.03+20110620/kalign2_output.c"
void msf_output(struct alignment *aln , char *outfile ) 
{ 
  int i ;
  int j ;
  int c ;
  int f ;
  int g ;
  int max ;
  int aln_len ;
  int tmp ;
  char **linear_seq ;
  FILE *fout ;
  void *tmp___0 ;
  void *tmp___1 ;
  unsigned short const   **tmp___2 ;
  unsigned short const   **tmp___3 ;
  unsigned short const   **tmp___4 ;

  {
  {
#line 131
  max = 0;
#line 132
  aln_len = 0;
#line 134
  linear_seq = (char **)0;
#line 135
  fout = (FILE *)((void *)0);
#line 137
  tmp___0 = malloc(sizeof(char *) * (unsigned long )numseq);
#line 137
  linear_seq = (char **)tmp___0;
#line 139
  aln_len = 0;
#line 140
  j = 0;
  }
  {
#line 140
  while (1) {
    while_continue: /* CIL Label */ ;
#line 140
    if (! ((unsigned int )j <= *(aln->sl + 0))) {
#line 140
      goto while_break;
    }
#line 141
    aln_len += *(*(aln->s + 0) + j);
#line 140
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 143
  aln_len = (int )((unsigned int )aln_len + *(aln->sl + 0));
#line 145
  i = 0;
  {
#line 145
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 145
    if (! ((unsigned int )i < numseq)) {
#line 145
      goto while_break___0;
    }
    {
#line 146
    tmp___1 = malloc(sizeof(char ) * (unsigned long )(aln_len + 1));
#line 146
    *(linear_seq + i) = (char *)tmp___1;
#line 148
    c = 0;
#line 149
    j = 0;
    }
    {
#line 149
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 149
      if (! ((unsigned int )j < *(aln->sl + i))) {
#line 149
        goto while_break___1;
      }
#line 150
      tmp = *(*(aln->s + i) + j);
      {
#line 151
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 151
        if (! tmp) {
#line 151
          goto while_break___2;
        }
#line 152
        *(*(linear_seq + i) + c) = (char )'-';
#line 153
        c ++;
#line 154
        tmp --;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 156
      *(*(linear_seq + i) + c) = *(*(aln->seq + i) + j);
#line 157
      c ++;
#line 149
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 160
    tmp = *(*(aln->s + i) + *(aln->sl + i));
    {
#line 161
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 161
      if (! tmp) {
#line 161
        goto while_break___3;
      }
#line 162
      *(*(linear_seq + i) + c) = (char )'-';
#line 163
      c ++;
#line 164
      tmp --;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 166
    *(*(linear_seq + i) + c) = (char)0;
#line 145
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 169
  if (outfile) {
    {
#line 170
    fout = fopen((char const   */* __restrict  */)outfile, (char const   */* __restrict  */)"w");
    }
#line 170
    if ((unsigned long )fout == (unsigned long )((void *)0)) {
      {
#line 171
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"can\'t open output\n");
#line 172
      exit(0);
      }
    }
  } else {
#line 175
    fout = stdout;
  }
  {
#line 177
  fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"PileUp\n\n\n\n   MSF:   %d  Type: P    Check:  7038   ..\n\n",
          aln_len);
#line 179
  j = 0;
  }
  {
#line 179
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 179
    if (! ((unsigned int )j < numseq)) {
#line 179
      goto while_break___4;
    }
#line 180
    if (*(aln->lsn + j) > (unsigned int )max) {
#line 181
      max = (int )*(aln->lsn + j);
    }
#line 179
    j ++;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 185
  i = 0;
  {
#line 185
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 185
    if (! ((unsigned int )i < numseq)) {
#line 185
      goto while_break___5;
    }
    {
#line 186
    f = (int )*(aln->nsip + i);
#line 187
    fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)" Name: ");
#line 188
    c = 0;
    }
    {
#line 188
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 188
      if (! ((unsigned int )c < *(aln->lsn + f))) {
#line 188
        goto while_break___6;
      }
      {
#line 189
      tmp___2 = __ctype_b_loc();
      }
#line 189
      if (! ((int const   )*(*tmp___2 + (int )*(*(aln->sn + f) + c)) & 2)) {
        {
#line 190
        fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"%c",
                (int )*(*(aln->sn + f) + c));
        }
      }
#line 188
      c ++;
    }
    while_break___6: /* CIL Label */ ;
    }
    {
#line 193
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 193
      if (! (c < max + 3)) {
#line 193
        goto while_break___7;
      }
      {
#line 194
      fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)" ");
#line 195
      c ++;
      }
    }
    while_break___7: /* CIL Label */ ;
    }
    {
#line 197
    fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"Len:   ");
#line 198
    fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"%d",
            aln_len);
#line 199
    fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"  Check:  2349  Weight:  1.00\n");
#line 185
    i ++;
    }
  }
  while_break___5: /* CIL Label */ ;
  }
  {
#line 202
  fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"\n\n//\n\n");
#line 204
  i = 0;
  }
  {
#line 204
  while (1) {
    while_continue___8: /* CIL Label */ ;
#line 204
    if (! (i + 60 < aln_len)) {
#line 204
      goto while_break___8;
    }
#line 205
    j = 0;
    {
#line 205
    while (1) {
      while_continue___9: /* CIL Label */ ;
#line 205
      if (! ((unsigned int )j < numseq)) {
#line 205
        goto while_break___9;
      }
#line 206
      f = (int )*(aln->nsip + j);
#line 207
      c = 0;
      {
#line 207
      while (1) {
        while_continue___10: /* CIL Label */ ;
#line 207
        if (! ((unsigned int )c < *(aln->lsn + f))) {
#line 207
          goto while_break___10;
        }
        {
#line 208
        tmp___3 = __ctype_b_loc();
        }
#line 208
        if (! ((int const   )*(*tmp___3 + (int )*(*(aln->sn + f) + c)) & 2)) {
          {
#line 209
          fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"%c",
                  (int )*(*(aln->sn + f) + c));
          }
        }
#line 207
        c ++;
      }
      while_break___10: /* CIL Label */ ;
      }
      {
#line 212
      while (1) {
        while_continue___11: /* CIL Label */ ;
#line 212
        if (! (c < max + 3)) {
#line 212
          goto while_break___11;
        }
        {
#line 213
        fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)" ");
#line 214
        c ++;
        }
      }
      while_break___11: /* CIL Label */ ;
      }
#line 216
      g = 1;
#line 217
      c = 0;
      {
#line 217
      while (1) {
        while_continue___12: /* CIL Label */ ;
#line 217
        if (! (c < 60)) {
#line 217
          goto while_break___12;
        }
        {
#line 218
        fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"%c",
                (int )*(*(linear_seq + f) + (c + i)));
        }
#line 219
        if (g == 10) {
          {
#line 220
          fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)" ");
#line 221
          g = 0;
          }
        }
#line 223
        g ++;
#line 217
        c ++;
      }
      while_break___12: /* CIL Label */ ;
      }
      {
#line 225
      fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"\n");
#line 205
      j ++;
      }
    }
    while_break___9: /* CIL Label */ ;
    }
    {
#line 228
    fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"\n\n");
#line 204
    i += 60;
    }
  }
  while_break___8: /* CIL Label */ ;
  }
#line 230
  j = 0;
  {
#line 230
  while (1) {
    while_continue___13: /* CIL Label */ ;
#line 230
    if (! ((unsigned int )j < numseq)) {
#line 230
      goto while_break___13;
    }
#line 231
    f = (int )*(aln->nsip + j);
#line 233
    c = 0;
    {
#line 233
    while (1) {
      while_continue___14: /* CIL Label */ ;
#line 233
      if (! ((unsigned int )c < *(aln->lsn + f))) {
#line 233
        goto while_break___14;
      }
      {
#line 234
      tmp___4 = __ctype_b_loc();
      }
#line 234
      if (! ((int const   )*(*tmp___4 + (int )*(*(aln->sn + f) + c)) & 2)) {
        {
#line 235
        fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"%c",
                (int )*(*(aln->sn + f) + c));
        }
      }
#line 233
      c ++;
    }
    while_break___14: /* CIL Label */ ;
    }
    {
#line 239
    while (1) {
      while_continue___15: /* CIL Label */ ;
#line 239
      if (! (c < max + 3)) {
#line 239
        goto while_break___15;
      }
      {
#line 240
      fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)" ");
#line 241
      c ++;
      }
    }
    while_break___15: /* CIL Label */ ;
    }
#line 244
    g = 1;
#line 245
    c = i;
    {
#line 245
    while (1) {
      while_continue___16: /* CIL Label */ ;
#line 245
      if (! (c < aln_len)) {
#line 245
        goto while_break___16;
      }
      {
#line 246
      fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"%c",
              (int )*(*(linear_seq + f) + c));
      }
#line 247
      if (g == 10) {
        {
#line 248
        fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)" ");
#line 249
        g = 0;
        }
      }
#line 251
      g ++;
#line 245
      c ++;
    }
    while_break___16: /* CIL Label */ ;
    }
    {
#line 253
    fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"\n");
#line 230
    j ++;
    }
  }
  while_break___13: /* CIL Label */ ;
  }
  {
#line 256
  fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"\n\n");
  }
#line 257
  if (outfile) {
    {
#line 258
    fclose(fout);
    }
  }
#line 261
  i = 0;
  {
#line 261
  while (1) {
    while_continue___17: /* CIL Label */ ;
#line 261
    if (! ((unsigned int )i < numseq)) {
#line 261
      goto while_break___17;
    }
    {
#line 262
    free((void *)*(linear_seq + i));
#line 261
    i ++;
    }
  }
  while_break___17: /* CIL Label */ ;
  }
  {
#line 265
  free((void *)linear_seq);
#line 266
  free_aln(aln);
  }
#line 267
  return;
}
}
#line 270 "/home/june/repo/benchmarks/collector/temp/kalign-2.03+20110620/kalign2_output.c"
void clustal_output(struct alignment *aln , char *outfile ) 
{ 
  int i ;
  int j ;
  int c ;
  int f ;
  int tmp ;
  int aln_len ;
  char **linear_seq ;
  FILE *fout ;
  void *tmp___0 ;
  void *tmp___1 ;
  unsigned short const   **tmp___2 ;
  unsigned short const   **tmp___3 ;

  {
  {
#line 274
  aln_len = 0;
#line 275
  linear_seq = (char **)0;
#line 277
  fout = (FILE *)((void *)0);
#line 279
  tmp___0 = malloc(sizeof(char *) * (unsigned long )numseq);
#line 279
  linear_seq = (char **)tmp___0;
#line 281
  aln_len = 0;
#line 283
  j = 0;
  }
  {
#line 283
  while (1) {
    while_continue: /* CIL Label */ ;
#line 283
    if (! ((unsigned int )j <= *(aln->sl + 0))) {
#line 283
      goto while_break;
    }
#line 284
    aln_len += *(*(aln->s + 0) + j);
#line 283
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 287
  aln_len = (int )((unsigned int )aln_len + *(aln->sl + 0));
#line 289
  i = 0;
  {
#line 289
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 289
    if (! ((unsigned int )i < numseq)) {
#line 289
      goto while_break___0;
    }
    {
#line 290
    tmp___1 = malloc(sizeof(char ) * (unsigned long )(aln_len + 1));
#line 290
    *(linear_seq + i) = (char *)tmp___1;
#line 292
    c = 0;
#line 293
    j = 0;
    }
    {
#line 293
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 293
      if (! ((unsigned int )j < *(aln->sl + i))) {
#line 293
        goto while_break___1;
      }
#line 294
      tmp = *(*(aln->s + i) + j);
      {
#line 295
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 295
        if (! tmp) {
#line 295
          goto while_break___2;
        }
#line 296
        *(*(linear_seq + i) + c) = (char )'-';
#line 297
        c ++;
#line 298
        tmp --;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 300
      *(*(linear_seq + i) + c) = *(*(aln->seq + i) + j);
#line 301
      c ++;
#line 293
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 304
    tmp = *(*(aln->s + i) + *(aln->sl + i));
    {
#line 305
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 305
      if (! tmp) {
#line 305
        goto while_break___3;
      }
#line 306
      *(*(linear_seq + i) + c) = (char )'-';
#line 307
      c ++;
#line 308
      tmp --;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 310
    *(*(linear_seq + i) + c) = (char)0;
#line 289
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 314
  if (outfile) {
    {
#line 315
    fout = fopen((char const   */* __restrict  */)outfile, (char const   */* __restrict  */)"w");
    }
#line 315
    if ((unsigned long )fout == (unsigned long )((void *)0)) {
      {
#line 316
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"can\'t open output\n");
#line 317
      exit(0);
      }
    }
  } else {
#line 320
    fout = stdout;
  }
  {
#line 323
  fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"Kalign (2.0) alignment in ClustalW format\n\n\n");
#line 326
  i = 0;
  }
  {
#line 326
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 326
    if (! (i + 60 < aln_len)) {
#line 326
      goto while_break___4;
    }
#line 327
    j = 0;
    {
#line 327
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 327
      if (! ((unsigned int )j < numseq)) {
#line 327
        goto while_break___5;
      }
#line 328
      f = (int )*(aln->nsip + j);
#line 329
      c = 0;
      {
#line 329
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 329
        if (! ((unsigned int )c < *(aln->lsn + f))) {
#line 329
          goto while_break___6;
        }
        {
#line 330
        tmp___2 = __ctype_b_loc();
        }
#line 330
        if (! ((int const   )*(*tmp___2 + (int )*(*(aln->sn + f) + c)) & 2)) {
          {
#line 331
          fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"%c",
                  (int )*(*(aln->sn + f) + c));
          }
        }
#line 329
        c ++;
      }
      while_break___6: /* CIL Label */ ;
      }
      {
#line 334
      while (1) {
        while_continue___7: /* CIL Label */ ;
#line 334
        if (! (c < 18)) {
#line 334
          goto while_break___7;
        }
        {
#line 335
        fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)" ");
#line 336
        c ++;
        }
      }
      while_break___7: /* CIL Label */ ;
      }
#line 339
      c = 0;
      {
#line 339
      while (1) {
        while_continue___8: /* CIL Label */ ;
#line 339
        if (! (c < 60)) {
#line 339
          goto while_break___8;
        }
        {
#line 340
        fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"%c",
                (int )*(*(linear_seq + f) + (c + i)));
#line 339
        c ++;
        }
      }
      while_break___8: /* CIL Label */ ;
      }
      {
#line 342
      fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"\n");
#line 327
      j ++;
      }
    }
    while_break___5: /* CIL Label */ ;
    }
    {
#line 344
    fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"\n\n");
#line 326
    i += 60;
    }
  }
  while_break___4: /* CIL Label */ ;
  }
#line 346
  j = 0;
  {
#line 346
  while (1) {
    while_continue___9: /* CIL Label */ ;
#line 346
    if (! ((unsigned int )j < numseq)) {
#line 346
      goto while_break___9;
    }
#line 347
    f = (int )*(aln->nsip + j);
#line 348
    c = 0;
    {
#line 348
    while (1) {
      while_continue___10: /* CIL Label */ ;
#line 348
      if (! ((unsigned int )c < *(aln->lsn + f))) {
#line 348
        goto while_break___10;
      }
      {
#line 349
      tmp___3 = __ctype_b_loc();
      }
#line 349
      if (! ((int const   )*(*tmp___3 + (int )*(*(aln->sn + f) + c)) & 2)) {
        {
#line 350
        fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"%c",
                (int )*(*(aln->sn + f) + c));
        }
      }
#line 348
      c ++;
    }
    while_break___10: /* CIL Label */ ;
    }
    {
#line 353
    while (1) {
      while_continue___11: /* CIL Label */ ;
#line 353
      if (! (c < 18)) {
#line 353
        goto while_break___11;
      }
      {
#line 354
      fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)" ");
#line 355
      c ++;
      }
    }
    while_break___11: /* CIL Label */ ;
    }
#line 358
    c = i;
    {
#line 358
    while (1) {
      while_continue___12: /* CIL Label */ ;
#line 358
      if (! (c < aln_len)) {
#line 358
        goto while_break___12;
      }
      {
#line 359
      fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"%c",
              (int )*(*(linear_seq + f) + c));
#line 358
      c ++;
      }
    }
    while_break___12: /* CIL Label */ ;
    }
    {
#line 361
    fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"\n");
#line 346
    j ++;
    }
  }
  while_break___9: /* CIL Label */ ;
  }
  {
#line 363
  fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"\n\n");
  }
#line 364
  if (outfile) {
    {
#line 365
    fclose(fout);
    }
  }
#line 367
  i = 0;
  {
#line 367
  while (1) {
    while_continue___13: /* CIL Label */ ;
#line 367
    if (! ((unsigned int )i < numseq)) {
#line 367
      goto while_break___13;
    }
    {
#line 368
    free((void *)*(linear_seq + i));
#line 367
    i ++;
    }
  }
  while_break___13: /* CIL Label */ ;
  }
  {
#line 370
  free((void *)linear_seq);
#line 371
  free_aln(aln);
  }
#line 372
  return;
}
}
#line 374 "/home/june/repo/benchmarks/collector/temp/kalign-2.03+20110620/kalign2_output.c"
void aln_output(struct alignment *aln , struct parameters *param ) 
{ 
  char *outfile ;
  int i ;
  int j ;
  int c ;
  int f ;
  int tmp ;
  int aln_len ;
  int max_name_len ;
  int tmp_len ;
  char **linear_seq ;
  struct names *n ;
  FILE *fout ;
  void *tmp___0 ;
  void *tmp___1 ;
  unsigned short const   **tmp___2 ;
  unsigned short const   **tmp___3 ;
  unsigned short const   **tmp___4 ;
  unsigned short const   **tmp___5 ;

  {
  {
#line 376
  outfile = param->outfile;
#line 379
  aln_len = 0;
#line 382
  max_name_len = 20;
#line 383
  tmp_len = 0;
#line 384
  linear_seq = (char **)0;
#line 388
  n = get_meaningful_names(aln, param->id);
#line 392
  c = -1;
#line 393
  i = 0;
  }
  {
#line 393
  while (1) {
    while_continue: /* CIL Label */ ;
#line 393
    if (! ((unsigned int )i < numseq)) {
#line 393
      goto while_break;
    }
#line 394
    if (*(n->len + i) > c) {
#line 395
      c = *(n->len + i);
    }
#line 393
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 410
  if (c < max_name_len) {
#line 411
    max_name_len = c;
  }
  {
#line 414
  fout = (FILE *)((void *)0);
#line 416
  tmp___0 = malloc(sizeof(char *) * (unsigned long )numseq);
#line 416
  linear_seq = (char **)tmp___0;
#line 418
  aln_len = 0;
#line 419
  j = 0;
  }
  {
#line 419
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 419
    if (! ((unsigned int )j <= *(aln->sl + 0))) {
#line 419
      goto while_break___0;
    }
#line 420
    aln_len += *(*(aln->s + 0) + j);
#line 419
    j ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 422
  aln_len = (int )((unsigned int )aln_len + *(aln->sl + 0));
#line 424
  i = 0;
  {
#line 424
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 424
    if (! ((unsigned int )i < numseq)) {
#line 424
      goto while_break___1;
    }
    {
#line 425
    tmp___1 = malloc(sizeof(char ) * (unsigned long )(aln_len + 1));
#line 425
    *(linear_seq + i) = (char *)tmp___1;
#line 427
    c = 0;
#line 428
    j = 0;
    }
    {
#line 428
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 428
      if (! ((unsigned int )j < *(aln->sl + i))) {
#line 428
        goto while_break___2;
      }
#line 429
      tmp = *(*(aln->s + i) + j);
      {
#line 430
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 430
        if (! tmp) {
#line 430
          goto while_break___3;
        }
#line 431
        *(*(linear_seq + i) + c) = (char )'-';
#line 432
        c ++;
#line 433
        tmp --;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 435
      *(*(linear_seq + i) + c) = *(*(aln->seq + i) + j);
#line 436
      c ++;
#line 428
      j ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 439
    tmp = *(*(aln->s + i) + *(aln->sl + i));
    {
#line 440
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 440
      if (! tmp) {
#line 440
        goto while_break___4;
      }
#line 441
      *(*(linear_seq + i) + c) = (char )'-';
#line 442
      c ++;
#line 443
      tmp --;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 445
    *(*(linear_seq + i) + c) = (char)0;
#line 424
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 448
  if (outfile) {
    {
#line 449
    fout = fopen((char const   */* __restrict  */)outfile, (char const   */* __restrict  */)"w");
    }
#line 449
    if ((unsigned long )fout == (unsigned long )((void *)0)) {
      {
#line 450
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"can\'t open output\n");
#line 451
      exit(0);
      }
    }
  } else {
#line 454
    fout = stdout;
  }
  {
#line 457
  fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"Kalign (2.0) alignment in ClustalW format\n\n\n");
#line 459
  i = 0;
  }
  {
#line 459
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 459
    if (! (i + 60 < aln_len)) {
#line 459
      goto while_break___5;
    }
#line 460
    j = 0;
    {
#line 460
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 460
      if (! ((unsigned int )j < numseq)) {
#line 460
        goto while_break___6;
      }
#line 461
      f = (int )*(aln->nsip + j);
#line 462
      if (max_name_len < *(n->len + f)) {
#line 462
        tmp_len = max_name_len;
      } else {
#line 462
        tmp_len = *(n->len + f);
      }
#line 463
      c = 0;
      {
#line 463
      while (1) {
        while_continue___7: /* CIL Label */ ;
#line 463
        if (! (c < tmp_len)) {
#line 463
          goto while_break___7;
        }
        {
#line 464
        tmp___2 = __ctype_b_loc();
        }
#line 464
        if ((int const   )*(*tmp___2 + (int )*(*(aln->sn + f) + (c + *(n->start + f)))) & 8192) {
#line 465
          goto while_break___7;
        }
        {
#line 468
        tmp___3 = __ctype_b_loc();
        }
#line 468
        if (! ((int const   )*(*tmp___3 + (int )*(*(aln->sn + f) + (c + *(n->start + f)))) & 2)) {
          {
#line 469
          fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"%c",
                  (int )*(*(aln->sn + f) + (c + *(n->start + f))));
          }
        }
#line 463
        c ++;
      }
      while_break___7: /* CIL Label */ ;
      }
      {
#line 473
      while (1) {
        while_continue___8: /* CIL Label */ ;
#line 473
        if (! (c < max_name_len + 5)) {
#line 473
          goto while_break___8;
        }
        {
#line 474
        fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)" ");
#line 475
        c ++;
        }
      }
      while_break___8: /* CIL Label */ ;
      }
#line 478
      c = 0;
      {
#line 478
      while (1) {
        while_continue___9: /* CIL Label */ ;
#line 478
        if (! (c < 60)) {
#line 478
          goto while_break___9;
        }
        {
#line 479
        fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"%c",
                (int )*(*(linear_seq + f) + (c + i)));
#line 478
        c ++;
        }
      }
      while_break___9: /* CIL Label */ ;
      }
      {
#line 481
      fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"\n");
#line 460
      j ++;
      }
    }
    while_break___6: /* CIL Label */ ;
    }
    {
#line 483
    fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"\n\n");
#line 459
    i += 60;
    }
  }
  while_break___5: /* CIL Label */ ;
  }
#line 486
  j = 0;
  {
#line 486
  while (1) {
    while_continue___10: /* CIL Label */ ;
#line 486
    if (! ((unsigned int )j < numseq)) {
#line 486
      goto while_break___10;
    }
#line 487
    f = (int )*(aln->nsip + j);
#line 488
    if (max_name_len < *(n->len + f)) {
#line 488
      tmp_len = max_name_len;
    } else {
#line 488
      tmp_len = *(n->len + f);
    }
#line 489
    c = 0;
    {
#line 489
    while (1) {
      while_continue___11: /* CIL Label */ ;
#line 489
      if (! (c < tmp_len)) {
#line 489
        goto while_break___11;
      }
      {
#line 490
      tmp___4 = __ctype_b_loc();
      }
#line 490
      if ((int const   )*(*tmp___4 + (int )*(*(aln->sn + f) + (c + *(n->start + f)))) & 8192) {
#line 491
        goto while_break___11;
      }
      {
#line 494
      tmp___5 = __ctype_b_loc();
      }
#line 494
      if (! ((int const   )*(*tmp___5 + (int )*(*(aln->sn + f) + (c + *(n->start + f)))) & 2)) {
        {
#line 495
        fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"%c",
                (int )*(*(aln->sn + f) + (c + *(n->start + f))));
        }
      }
#line 489
      c ++;
    }
    while_break___11: /* CIL Label */ ;
    }
    {
#line 499
    while (1) {
      while_continue___12: /* CIL Label */ ;
#line 499
      if (! (c < max_name_len + 5)) {
#line 499
        goto while_break___12;
      }
      {
#line 500
      fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)" ");
#line 501
      c ++;
      }
    }
    while_break___12: /* CIL Label */ ;
    }
#line 504
    c = i;
    {
#line 504
    while (1) {
      while_continue___13: /* CIL Label */ ;
#line 504
      if (! (c < aln_len)) {
#line 504
        goto while_break___13;
      }
      {
#line 505
      fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"%c",
              (int )*(*(linear_seq + f) + c));
#line 504
      c ++;
      }
    }
    while_break___13: /* CIL Label */ ;
    }
    {
#line 507
    fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"\n");
#line 486
    j ++;
    }
  }
  while_break___10: /* CIL Label */ ;
  }
  {
#line 509
  fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"\n\n");
  }
#line 510
  if (outfile) {
    {
#line 511
    fclose(fout);
    }
  }
  {
#line 514
  names_free(n);
#line 516
  i = 0;
  }
  {
#line 516
  while (1) {
    while_continue___14: /* CIL Label */ ;
#line 516
    if (! ((unsigned int )i < numseq)) {
#line 516
      goto while_break___14;
    }
    {
#line 517
    free((void *)*(linear_seq + i));
#line 516
    i ++;
    }
  }
  while_break___14: /* CIL Label */ ;
  }
  {
#line 519
  free((void *)linear_seq);
#line 520
  free_aln(aln);
  }
#line 521
  return;
}
}
#line 523 "/home/june/repo/benchmarks/collector/temp/kalign-2.03+20110620/kalign2_output.c"
struct names *get_meaningful_names(struct alignment *aln , int id ) 
{ 
  struct names *n ;
  int i ;
  int j ;
  int c ;
  int min_len ;
  int start ;
  int globalstart ;
  unsigned short const   **tmp ;
  unsigned short const   **tmp___0 ;
  unsigned short const   **tmp___1 ;
  unsigned short const   **tmp___2 ;
  unsigned short const   **tmp___3 ;

  {
  {
#line 526
  n = (struct names *)0;
#line 528
  min_len = 0;
#line 529
  start = 0;
#line 530
  globalstart = 1000000;
#line 532
  n = names_alloc(n);
#line 533
  i = 0;
  }
  {
#line 533
  while (1) {
    while_continue: /* CIL Label */ ;
#line 533
    if (! ((unsigned int )i < numseq)) {
#line 533
      goto while_break;
    }
#line 534
    *(n->end + i) = (int )*(aln->lsn + i);
#line 533
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 538
  if (id == -1) {
#line 539
    i = 0;
    {
#line 539
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 539
      if (! ((unsigned int )i < numseq - 1U)) {
#line 539
        goto while_break___0;
      }
#line 540
      j = i + 1;
      {
#line 540
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 540
        if (! ((unsigned int )j < numseq)) {
#line 540
          goto while_break___1;
        }
#line 541
        if (*(aln->lsn + i) < *(aln->lsn + j)) {
#line 541
          min_len = (int )*(aln->lsn + i);
        } else {
#line 541
          min_len = (int )*(aln->lsn + j);
        }
#line 542
        start = 0;
#line 543
        c = 0;
        {
#line 543
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 543
          if (! (c < min_len)) {
#line 543
            goto while_break___2;
          }
          {
#line 544
          tmp = __ctype_b_loc();
          }
#line 544
          if ((int const   )*(*tmp + (int )*(*(aln->sn + i) + c)) & 8) {
            {
#line 544
            tmp___0 = __ctype_b_loc();
            }
#line 544
            if ((int const   )*(*tmp___0 + (int )*(*(aln->sn + j) + c)) & 8) {
#line 545
              if ((int )*(*(aln->sn + i) + c) != (int )*(*(aln->sn + j) + c)) {
#line 546
                goto while_break___2;
              }
            } else {
#line 544
              goto _L;
            }
          } else
          _L: /* CIL Label */ 
#line 549
          if ((int )*(*(aln->sn + i) + c) == (int )*(*(aln->sn + j) + c)) {
#line 550
            if ((int )*(*(aln->sn + i) + c) != 95) {
#line 550
              if ((int )*(*(aln->sn + i) + c) != 45) {
#line 551
                start = c + 1;
              }
            }
          } else {
#line 554
            goto while_break___2;
          }
#line 543
          c ++;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 561
        if (start < globalstart) {
#line 562
          globalstart = start;
        }
#line 540
        j ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 539
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 566
    i = 0;
    {
#line 566
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 566
      if (! ((unsigned int )i < numseq)) {
#line 566
        goto while_break___3;
      }
#line 567
      *(n->start + i) = globalstart;
#line 568
      j = *(n->start + i);
      {
#line 568
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 568
        if (! ((unsigned int )j < *(aln->lsn + i))) {
#line 568
          goto while_break___4;
        }
        {
#line 569
        tmp___1 = __ctype_b_loc();
        }
#line 569
        if (! ((int const   )*(*tmp___1 + (int )*(*(aln->sn + i) + j)) & 8)) {
#line 569
          if ((int )*(*(aln->sn + i) + j) != 95) {
#line 569
            if ((int )*(*(aln->sn + i) + j) != 45) {
#line 570
              *(n->end + i) = j;
#line 571
              goto while_break___4;
            }
          }
        }
#line 568
        j ++;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 566
      i ++;
    }
    while_break___3: /* CIL Label */ ;
    }
  } else {
#line 577
    i = 0;
    {
#line 577
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 577
      if (! ((unsigned int )i < numseq)) {
#line 577
        goto while_break___5;
      }
#line 578
      start = 0;
#line 579
      min_len = 0;
#line 580
      j = 0;
      {
#line 580
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 580
        if (! ((unsigned int )j < *(aln->lsn + i))) {
#line 580
          goto while_break___6;
        }
        {
#line 581
        tmp___3 = __ctype_b_loc();
        }
#line 581
        if ((int const   )*(*tmp___3 + (int )*(*(aln->sn + i) + j)) & 8) {
#line 581
          goto _L___1;
        } else
#line 581
        if ((int )*(*(aln->sn + i) + j) == 95) {
#line 581
          goto _L___1;
        } else
#line 581
        if ((int )*(*(aln->sn + i) + j) == 45) {
          _L___1: /* CIL Label */ 
#line 581
          if (start == 0) {
#line 582
            *(n->start + i) = j;
#line 583
            min_len ++;
#line 584
            start = 1;
          } else {
#line 581
            goto _L___0;
          }
        } else {
          _L___0: /* CIL Label */ 
          {
#line 585
          tmp___2 = __ctype_b_loc();
          }
#line 585
          if (! ((int const   )*(*tmp___2 + (int )*(*(aln->sn + i) + j)) & 8)) {
#line 585
            if ((int )*(*(aln->sn + i) + j) != 95) {
#line 585
              if ((int )*(*(aln->sn + i) + j) != 45) {
#line 585
                if (start == 1) {
#line 586
                  if (id == min_len) {
#line 587
                    *(n->end + i) = j;
#line 588
                    goto while_break___6;
                  }
#line 590
                  start = 0;
                }
              }
            }
          }
        }
#line 580
        j ++;
      }
      while_break___6: /* CIL Label */ ;
      }
#line 594
      if (id > min_len) {
        {
#line 595
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: sequence %d has no %dth word in the identifier line:\n%s\n",
                i, id, *(aln->sn + i));
#line 596
        *(n->start + i) = 0;
        }
      }
#line 577
      i ++;
    }
    while_break___5: /* CIL Label */ ;
    }
  }
#line 601
  i = 0;
  {
#line 601
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 601
    if (! ((unsigned int )i < numseq)) {
#line 601
      goto while_break___7;
    }
#line 603
    *(n->len + i) = *(n->end + i) - *(n->start + i);
#line 601
    i ++;
  }
  while_break___7: /* CIL Label */ ;
  }
#line 606
  return (n);
}
}
#line 610 "/home/june/repo/benchmarks/collector/temp/kalign-2.03+20110620/kalign2_output.c"
void fasta_output(struct alignment *aln , char *outfile ) 
{ 
  int i ;
  int j ;
  int c ;
  int f ;
  int tmp ;
  FILE *fout ;

  {
#line 614
  fout = (FILE *)((void *)0);
#line 615
  if (outfile) {
    {
#line 616
    fout = fopen((char const   */* __restrict  */)outfile, (char const   */* __restrict  */)"w");
    }
#line 616
    if ((unsigned long )fout == (unsigned long )((void *)0)) {
      {
#line 617
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"can\'t open output\n");
#line 618
      exit(0);
      }
    }
  } else {
#line 621
    fout = stdout;
  }
#line 623
  i = 0;
  {
#line 623
  while (1) {
    while_continue: /* CIL Label */ ;
#line 623
    if (! ((unsigned int )i < numseq)) {
#line 623
      goto while_break;
    }
    {
#line 624
    f = (int )*(aln->nsip + i);
#line 625
    fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)">%s\n",
            *(aln->sn + f));
#line 626
    c = 0;
#line 627
    j = 0;
    }
    {
#line 627
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 627
      if (! ((unsigned int )j < *(aln->sl + f))) {
#line 627
        goto while_break___0;
      }
#line 628
      tmp = *(*(aln->s + f) + j);
      {
#line 629
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 629
        if (! tmp) {
#line 629
          goto while_break___1;
        }
        {
#line 630
        fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"-");
#line 631
        c ++;
        }
#line 632
        if (c == 60) {
#line 632
          if ((unsigned int )j != *(aln->sl + f) - 1U) {
            {
#line 633
            fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"\n");
#line 634
            c = 0;
            }
          }
        }
#line 636
        tmp --;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 638
      fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"%c",
              (int )*(*(aln->seq + f) + j));
#line 639
      c ++;
      }
#line 640
      if (c == 60) {
#line 640
        if ((unsigned int )j != *(aln->sl + f) - 1U) {
          {
#line 641
          fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"\n");
#line 642
          c = 0;
          }
        }
      }
#line 627
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 645
    tmp = *(*(aln->s + f) + *(aln->sl + f));
    {
#line 646
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 646
      if (! tmp) {
#line 646
        goto while_break___2;
      }
      {
#line 647
      fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"-");
#line 648
      c ++;
      }
#line 649
      if (c == 60) {
#line 649
        if ((unsigned int )j != *(aln->sl + f) - 1U) {
          {
#line 650
          fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"\n");
#line 651
          c = 0;
          }
        }
      }
#line 653
      tmp --;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 655
    fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"\n");
#line 623
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 657
  if (outfile) {
    {
#line 658
    fclose(fout);
    }
  }
  {
#line 660
  free_aln(aln);
  }
#line 661
  return;
}
}
#line 42 "/home/june/repo/benchmarks/collector/temp/kalign-2.03+20110620/kalign2.h"
unsigned int numprofiles ;
#line 43
float gpo ;
#line 44
float gpe ;
#line 45
float tgpe ;
#line 203
struct alignment *sort_sequences(struct alignment *aln , int *tree , char *sort ) ;
#line 205
struct aln_tree_node *real_upgma(float **dm , int ntree ) ;
#line 207
int *readtree(struct aln_tree_node *p , int *tree ) ;
#line 209
struct parameters *interface(struct parameters *param , int argc , char **argv ) ;
#line 210
void parameter_message(struct parameters *param ) ;
#line 216
struct alignment *detect_and_read_sequences(struct alignment *aln , struct parameters *param ) ;
#line 224
struct alignment *make_dna(struct alignment *aln ) ;
#line 226
float **read_matrix(float **subm , struct parameters *param ) ;
#line 252
float **protein_pairwise_alignment_distance(struct alignment *aln , float **dm , struct parameters *param ,
                                            float **subm , int nj___0 ) ;
#line 255
float **protein_wu_distance2(struct alignment *aln , float **dm , struct parameters *param ) ;
#line 258
float **protein_wu_distance(struct alignment *si , float **dm , struct parameters *param ,
                            int nj___0 ) ;
#line 263
float **dna_distance(struct alignment *si , float **dm , struct parameters *param ,
                     int nj___0 ) ;
#line 267
int byg_detect(int *text , int n ) ;
#line 299
struct feature_matrix *get_feature_matrix(struct feature_matrix *fm , struct alignment *aln ,
                                          struct parameters *param ) ;
#line 308
int **default_alignment(struct alignment *aln , int *tree , float **submatrix , int **map ) ;
#line 314
struct ntree_data *ntree_alignment(struct ntree_data *ntree_data ) ;
#line 325
void ntreeify(struct aln_tree_node *p , int ntree ) ;
#line 337
struct aln_tree_node *real_nj(float **dm , int ntree ) ;
#line 352
int **hirschberg_alignment(struct alignment *aln , int *tree , float **submatrix ,
                           int **map , int window , float strength ) ;
#line 353
int **hirschberg_alignment_against_a(struct alignment *aln , int *tree , float **submatrix ,
                                     int **map , int window , float strength ) ;
#line 369
int **dna_alignment(struct alignment *aln , int *tree , float **submatrix , int **map ,
                    float strength ) ;
#line 370
int **dna_alignment_against_a(struct alignment *aln , int *tree , float **submatrix ,
                              int **map , float strength ) ;
#line 372
struct alignment *make_seq(struct alignment *aln , int a , int b , int *path ) ;
#line 384
int **advanced_hirschberg_alignment(struct alignment *aln , int *tree , float **submatrix ,
                                    int **map , int window , float strength , float internal_gap_weight ) ;
#line 396
int **feature_hirschberg_alignment(struct alignment *aln , int *tree , float **submatrix ,
                                   int **map , struct feature_matrix *fm ) ;
#line 398
void profile_alignment_main(struct alignment *aln , struct parameters *param , float **submatrix ) ;
#line 408
void print_tree(struct aln_tree_node *p , struct alignment *aln , char *outfile ) ;
#line 31 "/home/june/repo/benchmarks/collector/temp/kalign-2.03+20110620/kalign2_main.c"
unsigned int numseq  =    0U;
#line 32 "/home/june/repo/benchmarks/collector/temp/kalign-2.03+20110620/kalign2_main.c"
unsigned int numprofiles  =    0U;
#line 33 "/home/june/repo/benchmarks/collector/temp/kalign-2.03+20110620/kalign2_main.c"
float gpo  =    (float )0;
#line 34 "/home/june/repo/benchmarks/collector/temp/kalign-2.03+20110620/kalign2_main.c"
float gpe  =    (float )0;
#line 35 "/home/june/repo/benchmarks/collector/temp/kalign-2.03+20110620/kalign2_main.c"
float tgpe  =    (float )0;
#line 37 "/home/june/repo/benchmarks/collector/temp/kalign-2.03+20110620/kalign2_main.c"
int main(int argc , char **argv ) 
{ 
  int i ;
  int *tree ;
  int a ;
  int b ;
  int c ;
  struct alignment *aln ;
  struct parameters *param ;
  struct aln_tree_node *tree2 ;
  void *tmp ;
  int j ;
  float **submatrix ;
  int tmp___0 ;
  float **dm ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  void *tmp___7 ;
  struct feature_matrix *fm ;
  struct ntree_data *ntree_data ;
  int **map ;
  void *tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int *p ;

  {
  {
#line 40
  tree = (int *)0;
#line 43
  aln = (struct alignment *)0;
#line 44
  param = (struct parameters *)0;
#line 45
  tree2 = (struct aln_tree_node *)0;
#line 47
  tmp = malloc(sizeof(struct parameters ));
#line 47
  param = (struct parameters *)tmp;
#line 49
  param = interface(param, argc, argv);
#line 51
  aln = detect_and_read_sequences(aln, param);
  }
#line 53
  if ((unsigned int )param->ntree > numseq) {
#line 54
    param->ntree = (int )numseq;
  }
#line 58
  if (param->dna == -1) {
#line 59
    i = 0;
    {
#line 59
    while (1) {
      while_continue: /* CIL Label */ ;
#line 59
      if (! ((unsigned int )i < numseq)) {
#line 59
        goto while_break;
      }
      {
#line 60
      param->dna = byg_detect(*(aln->s + i), (int )*(aln->sl + i));
      }
#line 61
      if (param->dna) {
#line 62
        goto while_break;
      }
#line 59
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 70
  if (param->dna == 1) {
#line 72
    i = 0;
    {
#line 72
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 72
      if (! ((unsigned int )i < numseq)) {
#line 72
        goto while_break___0;
      }
#line 73
      if (*(aln->sl + i) < 6U) {
        {
#line 74
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Dna/Rna alignments are only supported for sequences longer than 6.");
#line 75
        free((void *)param);
#line 76
        free_aln(aln);
#line 77
        exit(0);
        }
      }
#line 72
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 80
    aln = make_dna(aln);
    }
  }
#line 85
  if (param->reformat) {
#line 86
    i = 0;
    {
#line 86
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 86
      if (! ((unsigned int )i < numseq)) {
#line 86
        goto while_break___1;
      }
#line 87
      *(aln->nsip + i) = (unsigned int )i;
#line 88
      j = 0;
      {
#line 88
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 88
        if (! ((unsigned int )j < *(aln->sl + i))) {
#line 88
          goto while_break___2;
        }
#line 89
        *(*(aln->s + i) + j) = 0;
#line 88
        j ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 86
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 92
    param->format = (char *)"fasta";
#line 93
    output(aln, param);
#line 94
    exit(1);
    }
  }
  {
#line 100
  submatrix = (float **)0;
#line 101
  submatrix = read_matrix(submatrix, param);
  }
#line 103
  if (! param->quiet) {
    {
#line 104
    parameter_message(param);
    }
  }
  {
#line 107
  tmp___0 = byg_start(param->alignment_type, (char *)"profPROFprofilePROFILE");
  }
#line 107
  if (tmp___0 != -1) {
    {
#line 108
    profile_alignment_main(aln, param, submatrix);
    }
  }
#line 111
  dm = (float **)0;
#line 112
  if (param->ntree > 1) {
    {
#line 113
    tmp___5 = byg_start(param->distance, (char *)"pairclustalPAIRCLUSTAL");
    }
#line 113
    if (tmp___5 != -1) {
      {
#line 114
      tmp___1 = byg_start(param->tree, (char *)"njNJ");
      }
#line 114
      if (tmp___1 != -1) {
        {
#line 115
        dm = protein_pairwise_alignment_distance(aln, dm, param, submatrix, 1);
        }
      } else {
        {
#line 117
        dm = protein_pairwise_alignment_distance(aln, dm, param, submatrix, 0);
        }
      }
    } else {
      {
#line 119
      tmp___4 = byg_start((char *)"wu", param->alignment_type);
      }
#line 119
      if (tmp___4 != -1) {
        {
#line 120
        dm = protein_wu_distance2(aln, dm, param);
        }
      } else
#line 122
      if (param->dna == 1) {
        {
#line 123
        tmp___2 = byg_start(param->tree, (char *)"njNJ");
        }
#line 123
        if (tmp___2 != -1) {
          {
#line 124
          dm = dna_distance(aln, dm, param, 1);
          }
        } else {
          {
#line 126
          dm = dna_distance(aln, dm, param, 0);
          }
        }
      } else {
        {
#line 129
        tmp___3 = byg_start(param->tree, (char *)"njNJ");
        }
#line 129
        if (tmp___3 != -1) {
          {
#line 130
          dm = protein_wu_distance(aln, dm, param, 1);
          }
        } else {
          {
#line 132
          dm = protein_wu_distance(aln, dm, param, 0);
          }
        }
      }
    }
    {
#line 143
    tmp___6 = byg_start(param->tree, (char *)"njNJ");
    }
#line 143
    if (tmp___6 != -1) {
      {
#line 144
      tree2 = real_nj(dm, param->ntree);
      }
    } else {
      {
#line 146
      tree2 = real_upgma(dm, param->ntree);
      }
    }
#line 148
    if (param->print_tree) {
      {
#line 149
      print_tree(tree2, aln, param->print_tree);
      }
    }
  }
  {
#line 153
  tmp___7 = malloc(sizeof(int ) * (unsigned long )(numseq * 3U + 1U));
#line 153
  tree = (int *)tmp___7;
#line 154
  i = 1;
  }
  {
#line 154
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 154
    if (! ((unsigned int )i < numseq * 3U + 1U)) {
#line 154
      goto while_break___3;
    }
#line 155
    *(tree + i) = 0;
#line 154
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 157
  *(tree + 0) = 1;
#line 159
  if (param->ntree < 2) {
#line 160
    *(tree + 0) = 0;
#line 161
    *(tree + 1) = 1;
#line 163
    c = (int )numseq;
#line 164
    *(tree + 2) = c;
#line 165
    a = 2;
#line 166
    i = 3;
    {
#line 166
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 166
      if (! ((unsigned int )i < (numseq - 1U) * 3U)) {
#line 166
        goto while_break___4;
      }
#line 167
      *(tree + i) = c;
#line 168
      *(tree + (i + 1)) = a;
#line 169
      c ++;
#line 170
      *(tree + (i + 2)) = c;
#line 171
      a ++;
#line 166
      i += 3;
    }
    while_break___4: /* CIL Label */ ;
    }
  } else
#line 173
  if (param->ntree > 2) {
    {
#line 174
    ntreeify(tree2, param->ntree);
    }
  } else {
    {
#line 176
    tree = readtree(tree2, tree);
#line 177
    i = 0;
    }
    {
#line 177
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 177
      if (! ((unsigned int )i < numseq * 3U)) {
#line 177
        goto while_break___5;
      }
#line 178
      *(tree + i) = *(tree + (i + 1));
#line 177
      i ++;
    }
    while_break___5: /* CIL Label */ ;
    }
    {
#line 180
    free((void *)tree2->links);
#line 181
    free((void *)tree2->internal_lables);
#line 182
    free((void *)tree2);
    }
  }
#line 189
  fm = (struct feature_matrix *)0;
#line 191
  ntree_data = (struct ntree_data *)0;
#line 193
  map = (int **)0;
#line 194
  if (param->ntree > 2) {
    {
#line 195
    tmp___8 = malloc(sizeof(struct ntree_data ));
#line 195
    ntree_data = (struct ntree_data *)tmp___8;
#line 196
    ntree_data->realtree = tree2;
#line 197
    ntree_data->aln = aln;
#line 198
    ntree_data->profile = (float **)0;
#line 199
    ntree_data->map = (int **)0;
#line 200
    ntree_data->ntree = param->ntree;
#line 201
    ntree_data->submatrix = submatrix;
#line 202
    ntree_data->tree = tree;
#line 204
    ntree_data = ntree_alignment(ntree_data);
#line 205
    map = ntree_data->map;
#line 206
    tree = ntree_data->tree;
#line 207
    i = 0;
    }
    {
#line 207
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 207
      if (! ((unsigned int )i < numseq * 3U)) {
#line 207
        goto while_break___6;
      }
#line 208
      *(tree + i) = *(tree + (i + 1));
#line 207
      i ++;
    }
    while_break___6: /* CIL Label */ ;
    }
    {
#line 210
    free((void *)ntree_data);
    }
  } else
#line 211
  if (param->feature_type) {
    {
#line 212
    fm = get_feature_matrix(fm, aln, param);
    }
#line 213
    if (! fm) {
#line 214
      i = 32;
      {
#line 214
      while (1) {
        while_continue___7: /* CIL Label */ ;
#line 214
        tmp___9 = i;
#line 214
        i --;
#line 214
        if (! tmp___9) {
#line 214
          goto while_break___7;
        }
        {
#line 215
        free((void *)*(submatrix + i));
        }
      }
      while_break___7: /* CIL Label */ ;
      }
      {
#line 217
      free((void *)submatrix);
#line 218
      free_param(param);
#line 219
      free((void *)map);
#line 220
      free((void *)tree);
#line 221
      exit(0);
      }
    }
    {
#line 224
    map = feature_hirschberg_alignment(aln, tree, submatrix, map, fm);
    }
  } else {
    {
#line 228
    tmp___12 = byg_start((char *)"pairwise", param->alignment_type);
    }
#line 228
    if (tmp___12 != -1) {
#line 229
      if (param->dna == 1) {
        {
#line 230
        map = dna_alignment_against_a(aln, tree, submatrix, map, param->gap_inc);
        }
      } else {
        {
#line 232
        map = hirschberg_alignment_against_a(aln, tree, submatrix, map, param->smooth_window,
                                             param->gap_inc);
        }
      }
    } else {
      {
#line 235
      tmp___11 = byg_start((char *)"fast", param->alignment_type);
      }
#line 235
      if (tmp___11 != -1) {
        {
#line 236
        map = default_alignment(aln, tree, submatrix, map);
        }
      } else
#line 237
      if (param->dna == 1) {
        {
#line 238
        map = dna_alignment(aln, tree, submatrix, map, param->gap_inc);
        }
      } else {
        {
#line 249
        tmp___10 = byg_start((char *)"advanced", param->alignment_type);
        }
#line 249
        if (tmp___10 != -1) {
          {
#line 250
          map = advanced_hirschberg_alignment(aln, tree, submatrix, map, param->smooth_window,
                                              param->gap_inc, param->internal_gap_weight);
          }
        } else {
          {
#line 252
          map = hirschberg_alignment(aln, tree, submatrix, map, param->smooth_window,
                                     param->gap_inc);
          }
        }
      }
    }
  }
#line 257
  p = (int *)0;
#line 258
  i = 0;
  {
#line 258
  while (1) {
    while_continue___8: /* CIL Label */ ;
#line 258
    if (! ((unsigned int )i < numseq)) {
#line 258
      goto while_break___8;
    }
#line 259
    p = *(aln->s + i);
#line 260
    a = 0;
    {
#line 260
    while (1) {
      while_continue___9: /* CIL Label */ ;
#line 260
      if (! ((unsigned int )a < *(aln->sl + i))) {
#line 260
        goto while_break___9;
      }
#line 261
      *(p + a) = 0;
#line 260
      a ++;
    }
    while_break___9: /* CIL Label */ ;
    }
#line 258
    i ++;
  }
  while_break___8: /* CIL Label */ ;
  }
#line 266
  i = 0;
  {
#line 266
  while (1) {
    while_continue___10: /* CIL Label */ ;
#line 266
    if (! ((unsigned int )i < (numseq - 1U) * 3U)) {
#line 266
      goto while_break___10;
    }
    {
#line 267
    a = *(tree + i);
#line 268
    b = *(tree + (i + 1));
#line 269
    aln = make_seq(aln, a, b, *(map + *(tree + (i + 2))));
#line 266
    i += 3;
    }
  }
  while_break___10: /* CIL Label */ ;
  }
#line 277
  i = 0;
  {
#line 277
  while (1) {
    while_continue___11: /* CIL Label */ ;
#line 277
    if (! ((unsigned int )i < numseq)) {
#line 277
      goto while_break___11;
    }
#line 278
    *(aln->nsip + i) = 0U;
#line 277
    i ++;
  }
  while_break___11: /* CIL Label */ ;
  }
  {
#line 283
  aln = sort_sequences(aln, tree, param->sort);
#line 290
  output(aln, param);
#line 304
  free((void *)map);
#line 305
  free((void *)tree);
  }
#line 306
  return (0);
}
}
#line 362 "/usr/include/stdio.h"
extern int printf(char const   * __restrict  __format  , ...) ;
#line 219 "/home/june/repo/benchmarks/collector/temp/kalign-2.03+20110620/kalign2.h"
int *upgma(float **dm , int *tree ) ;
#line 220
int *nj(float **dm , int *tree ) ;
#line 221
void print_simple_phylip_tree(struct aln_tree_node *p ) ;
#line 315
struct ntree_data *ntree_sub_alignment(struct ntree_data *ntree_data , int *tree ,
                                       int num ) ;
#line 320
void printtree(struct aln_tree_node *p ) ;
#line 322
struct ntree_data *alignntree(struct ntree_data *ntree_data , struct aln_tree_node *p ) ;
#line 327
struct tree_node *simpleinsert(struct tree_node *p , int target , int new_edge , int leaf_label ) ;
#line 328
void printsimpleTree(struct tree_node *p ) ;
#line 329
int *ticker(int *milometer , int elements ) ;
#line 330
int *readsimpletree(struct tree_node *p , int *tree ) ;
#line 331
int add_label_simpletree(struct tree_node *p , int *nodes , int i ) ;
#line 334
struct ntree_data *find_best_topology(struct ntree_data *ntree_data , int *leaves ,
                                      int *nodes ) ;
#line 335
void freesimpletree(struct tree_node *p ) ;
#line 28 "/home/june/repo/benchmarks/collector/temp/kalign-2.03+20110620/kalign2_tree.c"
struct aln_tree_node *real_upgma(float **dm , int ntree ) 
{ 
  int i ;
  int j ;
  int *as ;
  float max ;
  int node_a ;
  int node_b ;
  int cnode ;
  struct aln_tree_node **tree ;
  struct aln_tree_node *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;

  {
  {
#line 31
  as = (int *)0;
#line 33
  node_a = 0;
#line 34
  node_b = 0;
#line 35
  cnode = (int )numseq;
#line 37
  tree = (struct aln_tree_node **)0;
#line 38
  tmp = (struct aln_tree_node *)0;
#line 40
  tmp___0 = malloc(sizeof(int ) * (unsigned long )numseq);
#line 40
  as = (int *)tmp___0;
#line 41
  i = (int )numseq;
  }
  {
#line 41
  while (1) {
    while_continue: /* CIL Label */ ;
#line 41
    tmp___1 = i;
#line 41
    i --;
#line 41
    if (! tmp___1) {
#line 41
      goto while_break;
    }
#line 42
    *(as + i) = i + 1;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 45
  tmp___2 = malloc(sizeof(struct aln_tree_node *) * (unsigned long )numseq);
#line 45
  tree = (struct aln_tree_node **)tmp___2;
#line 46
  i = 0;
  }
  {
#line 46
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 46
    if (! ((unsigned int )i < numseq)) {
#line 46
      goto while_break___0;
    }
    {
#line 47
    tmp___3 = malloc(sizeof(struct aln_tree_node ));
#line 47
    *(tree + i) = (struct aln_tree_node *)tmp___3;
#line 48
    (*(tree + i))->done = 1;
#line 49
    (*(tree + i))->num = i;
#line 50
    (*(tree + i))->path = (int *)0;
#line 51
    (*(tree + i))->profile = (int *)0;
#line 52
    (*(tree + i))->seq = (int *)0;
#line 53
    (*(tree + i))->len = 0;
#line 64
    tmp___4 = malloc(sizeof(int ) * (unsigned long )(ntree + (ntree - 1)));
#line 64
    (*(tree + i))->internal_lables = (int *)tmp___4;
#line 65
    tmp___5 = malloc(sizeof(struct aln_tree_node *) * (unsigned long )(ntree + (ntree - 1)));
#line 65
    (*(tree + i))->links = (struct aln_tree_node **)tmp___5;
#line 67
    j = 0;
    }
    {
#line 67
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 67
      if (! (j < ntree + (ntree - 1))) {
#line 67
        goto while_break___1;
      }
#line 68
      *((*(tree + i))->links + j) = (struct aln_tree_node *)0;
#line 69
      *((*(tree + i))->internal_lables + j) = 0;
#line 67
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 46
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 73
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 73
    if (! ((unsigned int )cnode != numprofiles)) {
#line 73
      goto while_break___2;
    }
#line 74
    max = - 3.40282346638528859812e+38F;
#line 75
    i = 0;
    {
#line 75
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 75
      if (! ((unsigned int )i < numseq - 1U)) {
#line 75
        goto while_break___3;
      }
#line 76
      if (*(as + i)) {
#line 77
        j = i + 1;
        {
#line 77
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 77
          if (! ((unsigned int )j < numseq)) {
#line 77
            goto while_break___4;
          }
#line 78
          if (*(as + j)) {
#line 79
            if (*(*(dm + i) + j) > max) {
#line 80
              max = *(*(dm + i) + j);
#line 81
              node_a = i;
#line 82
              node_b = j;
            }
          }
#line 77
          j ++;
        }
        while_break___4: /* CIL Label */ ;
        }
      }
#line 75
      i ++;
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 88
    tmp___6 = malloc(sizeof(struct aln_tree_node ));
#line 88
    tmp = (struct aln_tree_node *)tmp___6;
#line 89
    tmp->done = 0;
#line 90
    tmp->path = (int *)0;
#line 91
    tmp->profile = (int *)0;
#line 92
    tmp->num = cnode;
#line 93
    tmp->seq = (int *)0;
#line 94
    tmp->len = 0;
#line 96
    tmp___7 = malloc(sizeof(struct aln_tree_node *) * (unsigned long )(ntree + (ntree - 1)));
#line 96
    tmp->links = (struct aln_tree_node **)tmp___7;
#line 97
    tmp___8 = malloc(sizeof(int ) * (unsigned long )(ntree + (ntree - 1)));
#line 97
    tmp->internal_lables = (int *)tmp___8;
#line 98
    *(tmp->links + 0) = *(tree + node_a);
#line 99
    *(tmp->links + 1) = *(tree + node_b);
#line 100
    *(tmp->internal_lables + 0) = cnode;
#line 101
    *(tmp->internal_lables + 1) = 0;
#line 103
    i = 2;
    }
    {
#line 103
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 103
      if (! (i < ntree + (ntree - 1))) {
#line 103
        goto while_break___5;
      }
#line 104
      *(tmp->links + i) = (struct aln_tree_node *)0;
#line 105
      *(tmp->internal_lables + i) = 0;
#line 103
      i ++;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 110
    *(tree + node_a) = tmp;
#line 111
    *(tree + node_b) = (struct aln_tree_node *)0;
#line 114
    *(as + node_a) = cnode + 1;
#line 115
    *(as + node_b) = 0;
#line 116
    cnode ++;
#line 119
    j = (int )numseq;
    {
#line 119
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 119
      tmp___9 = j;
#line 119
      j --;
#line 119
      if (! tmp___9) {
#line 119
        goto while_break___6;
      }
#line 120
      if (j != node_b) {
#line 121
        *(*(dm + node_a) + j) = (float )((double )(*(*(dm + node_a) + j) + *(*(dm + node_b) + j)) * 0.5);
      }
    }
    while_break___6: /* CIL Label */ ;
    }
#line 124
    *(*(dm + node_a) + node_a) = 0.0f;
#line 125
    j = (int )numseq;
    {
#line 125
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 125
      tmp___10 = j;
#line 125
      j --;
#line 125
      if (! tmp___10) {
#line 125
        goto while_break___7;
      }
#line 126
      *(*(dm + j) + node_a) = *(*(dm + node_a) + j);
#line 127
      *(*(dm + j) + node_b) = 0.0f;
#line 128
      *(*(dm + node_b) + j) = 0.0f;
    }
    while_break___7: /* CIL Label */ ;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 131
  tmp = *(tree + node_a);
#line 133
  i = (int )numseq;
  {
#line 133
  while (1) {
    while_continue___8: /* CIL Label */ ;
#line 133
    tmp___11 = i;
#line 133
    i --;
#line 133
    if (! tmp___11) {
#line 133
      goto while_break___8;
    }
    {
#line 134
    free((void *)*(dm + i));
    }
  }
  while_break___8: /* CIL Label */ ;
  }
  {
#line 136
  free((void *)dm);
#line 139
  free((void *)tree);
#line 140
  free((void *)as);
  }
#line 141
  return (tmp);
}
}
#line 144 "/home/june/repo/benchmarks/collector/temp/kalign-2.03+20110620/kalign2_tree.c"
struct aln_tree_node *real_nj(float **dm , int ntree ) 
{ 
  int i ;
  int j ;
  float *r ;
  float *r_div ;
  int *active ;
  int node ;
  float min ;
  int join_a ;
  int join_b ;
  int leaves ;
  struct aln_tree_node **tree ;
  struct aln_tree_node *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  float tmp___7 ;
  float tmp___8 ;
  int tmp___9 ;

  {
  {
#line 148
  r = (float *)0;
#line 149
  r_div = (float *)0;
#line 150
  active = (int *)0;
#line 151
  node = 0;
#line 152
  min = (float )0;
#line 153
  join_a = 0;
#line 154
  join_b = 0;
#line 155
  leaves = 0;
#line 157
  tree = (struct aln_tree_node **)0;
#line 158
  tmp = (struct aln_tree_node *)0;
#line 160
  leaves = (int )numseq;
#line 162
  tmp___0 = malloc((unsigned long )(numseq * 2U - 1U) * sizeof(float ));
#line 162
  r = (float *)tmp___0;
#line 163
  tmp___1 = malloc((unsigned long )(numseq * 2U - 1U) * sizeof(float ));
#line 163
  r_div = (float *)tmp___1;
#line 164
  tmp___2 = malloc((unsigned long )(numseq * 2U - 1U) * sizeof(int ));
#line 164
  active = (int *)tmp___2;
#line 165
  i = 0;
  }
  {
#line 165
  while (1) {
    while_continue: /* CIL Label */ ;
#line 165
    if (! ((unsigned int )i < numseq * 2U - 1U)) {
#line 165
      goto while_break;
    }
#line 166
    *(active + i) = 0;
#line 165
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 168
  i = 0;
  {
#line 168
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 168
    if (! ((unsigned int )i < numseq)) {
#line 168
      goto while_break___0;
    }
#line 169
    *(active + i) = 1;
#line 168
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 173
  tmp___3 = malloc(sizeof(struct aln_tree_node *) * (unsigned long )(numseq * 2U - 1U));
#line 173
  tree = (struct aln_tree_node **)tmp___3;
#line 174
  i = 0;
  }
  {
#line 174
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 174
    if (! ((unsigned int )i < numseq * 2U - 1U)) {
#line 174
      goto while_break___1;
    }
    {
#line 175
    tmp___4 = malloc(sizeof(struct aln_tree_node ));
#line 175
    *(tree + i) = (struct aln_tree_node *)tmp___4;
#line 176
    (*(tree + i))->done = 1;
#line 177
    (*(tree + i))->num = i;
#line 178
    (*(tree + i))->path = (int *)0;
#line 179
    (*(tree + i))->profile = (int *)0;
#line 180
    (*(tree + i))->seq = (int *)0;
#line 181
    (*(tree + i))->len = 0;
#line 182
    tmp___5 = malloc(sizeof(int ) * (unsigned long )(ntree + (ntree - 1)));
#line 182
    (*(tree + i))->internal_lables = (int *)tmp___5;
#line 183
    tmp___6 = malloc(sizeof(struct aln_tree_node *) * (unsigned long )(ntree + (ntree - 1)));
#line 183
    (*(tree + i))->links = (struct aln_tree_node **)tmp___6;
#line 185
    j = 0;
    }
    {
#line 185
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 185
      if (! (j < ntree + (ntree - 1))) {
#line 185
        goto while_break___2;
      }
#line 186
      *((*(tree + i))->links + j) = (struct aln_tree_node *)0;
#line 187
      *((*(tree + i))->internal_lables + j) = 0;
#line 185
      j ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 174
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 191
  node = (int )numseq;
  {
#line 192
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 192
    if (! ((unsigned int )node != numseq * 2U - 1U)) {
#line 192
      goto while_break___3;
    }
#line 193
    i = 0;
    {
#line 193
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 193
      if (! ((unsigned int )i < numseq * 2U - 1U)) {
#line 193
        goto while_break___4;
      }
#line 194
      if (*(active + i)) {
#line 195
        *(r + i) = (float )0;
#line 196
        j = 0;
        {
#line 196
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 196
          if (! ((unsigned int )j < numseq * 2U - 1U)) {
#line 196
            goto while_break___5;
          }
#line 197
          if (*(active + j)) {
#line 198
            if (i < j) {
#line 198
              tmp___7 = *(*(dm + i) + j);
            } else {
#line 198
              tmp___7 = *(*(dm + j) + i);
            }
#line 198
            *(r + i) += tmp___7;
          }
#line 196
          j ++;
        }
        while_break___5: /* CIL Label */ ;
        }
#line 201
        *(r_div + i) = *(r + i) / (float )(leaves - 2);
      }
#line 193
      i ++;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 204
    j = 0;
    {
#line 204
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 204
      if (! ((unsigned int )j < numseq * 2U - 1U)) {
#line 204
        goto while_break___6;
      }
#line 205
      if (*(active + j)) {
#line 206
        i = j + 1;
        {
#line 206
        while (1) {
          while_continue___7: /* CIL Label */ ;
#line 206
          if (! ((unsigned int )i < numseq * 2U - 1U)) {
#line 206
            goto while_break___7;
          }
#line 207
          if (*(active + i)) {
#line 208
            *(*(dm + i) + j) = *(*(dm + j) + i) - (*(r + i) + *(r + j)) / (float )2;
          }
#line 206
          i ++;
        }
        while_break___7: /* CIL Label */ ;
        }
      }
#line 204
      j ++;
    }
    while_break___6: /* CIL Label */ ;
    }
#line 213
    min = - 3.40282346638528859812e+38F;
#line 214
    j = 0;
    {
#line 214
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 214
      if (! ((unsigned int )j < numseq * 2U - 1U)) {
#line 214
        goto while_break___8;
      }
#line 215
      if (*(active + j)) {
#line 216
        i = j + 1;
        {
#line 216
        while (1) {
          while_continue___9: /* CIL Label */ ;
#line 216
          if (! ((unsigned int )i < numseq * 2U - 1U)) {
#line 216
            goto while_break___9;
          }
#line 217
          if (*(active + i)) {
#line 218
            if (*(*(dm + i) + j) > min) {
#line 219
              min = *(*(dm + i) + j);
#line 220
              join_a = j;
#line 221
              join_b = i;
            }
          }
#line 216
          i ++;
        }
        while_break___9: /* CIL Label */ ;
        }
      }
#line 214
      j ++;
    }
    while_break___8: /* CIL Label */ ;
    }
#line 228
    *(*(dm + join_a) + node) = *(*(dm + join_a) + join_b) / (float )2 + (*(r_div + join_a) - *(r_div + join_b)) / (float )2;
#line 229
    *(*(dm + join_b) + node) = *(*(dm + join_a) + join_b) - *(*(dm + join_a) + node);
#line 231
    (*(tree + node))->num = node;
#line 232
    *((*(tree + node))->links + 0) = *(tree + join_a);
#line 233
    *((*(tree + node))->links + 1) = *(tree + join_b);
#line 234
    *((*(tree + node))->internal_lables + 0) = node;
#line 235
    *((*(tree + node))->internal_lables + 1) = 0;
#line 238
    *(active + join_a) = 0;
#line 239
    *(active + join_b) = 0;
#line 241
    i = 0;
    {
#line 241
    while (1) {
      while_continue___10: /* CIL Label */ ;
#line 241
      if (! ((unsigned int )i < numseq * 2U - 1U)) {
#line 241
        goto while_break___10;
      }
#line 242
      if (*(active + i)) {
#line 243
        if (i > join_a) {
#line 243
          *(*(dm + i) + node) = *(*(dm + join_a) + i);
        } else {
#line 243
          *(*(dm + i) + node) = *(*(dm + i) + join_a);
        }
#line 244
        *(*(dm + i) + node) -= *(*(dm + join_a) + node);
#line 245
        if (i > join_b) {
#line 245
          tmp___8 = *(*(dm + join_b) + i);
        } else {
#line 245
          tmp___8 = *(*(dm + i) + join_b);
        }
#line 245
        *(*(dm + i) + node) += tmp___8;
#line 246
        *(*(dm + i) + node) -= *(*(dm + join_b) + node);
#line 247
        *(*(dm + i) + node) /= (float )2;
      }
#line 241
      i ++;
    }
    while_break___10: /* CIL Label */ ;
    }
#line 250
    *(active + node) = 1;
#line 251
    node ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 254
  i = (int )numprofiles;
  {
#line 254
  while (1) {
    while_continue___11: /* CIL Label */ ;
#line 254
    tmp___9 = i;
#line 254
    i --;
#line 254
    if (! tmp___9) {
#line 254
      goto while_break___11;
    }
    {
#line 255
    free((void *)*(dm + i));
    }
  }
  while_break___11: /* CIL Label */ ;
  }
  {
#line 257
  free((void *)dm);
#line 259
  free((void *)r);
#line 260
  free((void *)r_div);
#line 261
  free((void *)active);
#line 262
  tmp = *(tree + (node - 1));
#line 263
  free((void *)tree);
  }
#line 264
  return (tmp);
}
}
#line 267 "/home/june/repo/benchmarks/collector/temp/kalign-2.03+20110620/kalign2_tree.c"
struct ntree_data *alignntree(struct ntree_data *ntree_data , struct aln_tree_node *p ) 
{ 
  int i ;
  int ntree ;
  int *leaves ;
  void *tmp ;

  {
  {
#line 269
  i = 0;
#line 270
  ntree = ntree_data->ntree;
#line 271
  leaves = (int *)0;
#line 273
  tmp = malloc(sizeof(int ) * (unsigned long )(ntree + (ntree - 1)));
#line 273
  leaves = (int *)tmp;
  }
  {
#line 275
  while (1) {
    while_continue: /* CIL Label */ ;
#line 275
    if (! *(p->links + i)) {
#line 275
      goto while_break;
    }
    {
#line 276
    alignntree(ntree_data, *(p->links + i));
#line 277
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 279
  i = 0;
#line 280
  if (*(p->links + i)) {
    {
#line 281
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Aligning subtree: at node:%d\n",
            p->num);
    }
    {
#line 282
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 282
      if (! *(p->links + i)) {
#line 282
        goto while_break___0;
      }
#line 283
      *(leaves + i) = (*(p->links + i))->num;
#line 284
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 286
    *(leaves + i) = -1;
#line 288
    ntree_data = find_best_topology(ntree_data, leaves, p->internal_lables);
    }
  }
  {
#line 291
  free((void *)leaves);
  }
#line 293
  return (ntree_data);
}
}
#line 297 "/home/june/repo/benchmarks/collector/temp/kalign-2.03+20110620/kalign2_tree.c"
void print_simple_phylip_tree(struct aln_tree_node *p ) 
{ 


  {
#line 299
  if (*(p->links + 0)) {
    {
#line 301
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"(");
#line 302
    print_simple_phylip_tree(*(p->links + 0));
    }
  }
#line 304
  if ((unsigned int )p->num < numseq) {
    {
#line 305
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%d",
            p->num);
    }
  } else {
    {
#line 307
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)",");
    }
  }
#line 309
  if (*(p->links + 1)) {
    {
#line 310
    print_simple_phylip_tree(*(p->links + 1));
#line 311
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)")");
    }
  }
#line 313
  return;
}
}
#line 316 "/home/june/repo/benchmarks/collector/temp/kalign-2.03+20110620/kalign2_tree.c"
void printtree(struct aln_tree_node *p ) 
{ 
  int i ;

  {
#line 318
  i = 0;
  {
#line 320
  while (1) {
    while_continue: /* CIL Label */ ;
#line 320
    if (! *(p->links + i)) {
#line 320
      goto while_break;
    }
    {
#line 321
    printtree(*(p->links + i));
#line 322
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 324
  i = 0;
#line 325
  if (*(p->links + i)) {
    {
#line 326
    printf((char const   */* __restrict  */)"Aligning: at node:%d\n", p->num);
    }
    {
#line 327
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 327
      if (! *(p->links + i)) {
#line 327
        goto while_break___0;
      }
      {
#line 328
      printf((char const   */* __restrict  */)"%d\n", (*(p->links + i))->num);
#line 329
      i ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 331
    i = 0;
    {
#line 332
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 332
      if (! *(p->internal_lables + i)) {
#line 332
        goto while_break___1;
      }
      {
#line 333
      printf((char const   */* __restrict  */)"%d ", *(p->internal_lables + i));
#line 334
      i ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 336
    printf((char const   */* __restrict  */)"\n");
    }
  }
#line 338
  return;
}
}
#line 340 "/home/june/repo/benchmarks/collector/temp/kalign-2.03+20110620/kalign2_tree.c"
void ntreeify(struct aln_tree_node *p , int ntree ) 
{ 
  int i ;
  int c ;
  struct aln_tree_node *tmp1 ;
  struct aln_tree_node *tmp2 ;

  {
#line 342
  i = 0;
#line 343
  c = 0;
#line 344
  tmp1 = (struct aln_tree_node *)0;
#line 345
  tmp2 = (struct aln_tree_node *)0;
#line 346
  if (*(p->links + 0)) {
    {
#line 347
    ntreeify(*(p->links + 0), ntree);
    }
  }
#line 349
  if (*(p->links + 1)) {
    {
#line 350
    ntreeify(*(p->links + 1), ntree);
    }
  }
#line 353
  if (! p->done) {
#line 354
    tmp1 = *(p->links + 0);
#line 355
    tmp2 = *(p->links + 1);
#line 357
    p->done = tmp1->done + tmp2->done;
#line 358
    i = 0;
#line 359
    c = 0;
#line 360
    if (tmp1->done != 1) {
      {
#line 362
      while (1) {
        while_continue: /* CIL Label */ ;
#line 362
        if (! *(tmp1->internal_lables + i)) {
#line 362
          goto while_break;
        }
#line 363
        *(p->internal_lables + c) = *(tmp1->internal_lables + i);
#line 364
        i ++;
#line 365
        c ++;
      }
      while_break: /* CIL Label */ ;
      }
#line 367
      if (tmp2->done != 1) {
#line 368
        i = 0;
        {
#line 369
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 369
          if (! *(tmp2->internal_lables + i)) {
#line 369
            goto while_break___0;
          }
#line 370
          *(p->internal_lables + c) = *(tmp2->internal_lables + i);
#line 371
          c ++;
#line 372
          i ++;
        }
        while_break___0: /* CIL Label */ ;
        }
      }
    } else
#line 375
    if (tmp2->done != 1) {
#line 376
      i = 0;
      {
#line 377
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 377
        if (! *(tmp2->internal_lables + i)) {
#line 377
          goto while_break___1;
        }
#line 378
        *(p->internal_lables + c) = *(tmp2->internal_lables + i);
#line 379
        c ++;
#line 380
        i ++;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
#line 383
    *(p->internal_lables + c) = p->num;
#line 392
    if (tmp1->done > 1) {
#line 393
      i = 0;
      {
#line 393
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 393
        if (! (i < tmp1->done)) {
#line 393
          goto while_break___2;
        }
#line 394
        *(p->links + i) = *(tmp1->links + i);
#line 395
        *(tmp1->links + i) = (struct aln_tree_node *)0;
#line 393
        i ++;
      }
      while_break___2: /* CIL Label */ ;
      }
    }
#line 399
    if (tmp2->done > 1) {
#line 400
      i = 0;
      {
#line 400
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 400
        if (! (i < tmp2->done)) {
#line 400
          goto while_break___3;
        }
#line 401
        *(p->links + (tmp1->done + i)) = *(tmp2->links + i);
#line 402
        *(tmp2->links + i) = (struct aln_tree_node *)0;
#line 400
        i ++;
      }
      while_break___3: /* CIL Label */ ;
      }
      {
#line 404
      free((void *)tmp2->internal_lables);
#line 405
      free((void *)tmp2->links);
#line 406
      free((void *)tmp2);
      }
    } else {
#line 408
      *(p->links + tmp1->done) = tmp2;
    }
#line 411
    *(p->links + p->done) = (struct aln_tree_node *)0;
#line 413
    if (tmp1->done > 1) {
      {
#line 414
      free((void *)tmp1->internal_lables);
#line 415
      free((void *)tmp1->links);
#line 416
      free((void *)tmp1);
      }
    }
#line 419
    if (p->done >= ntree) {
#line 420
      p->done = 1;
    }
  }
#line 428
  return;
}
}
#line 430 "/home/june/repo/benchmarks/collector/temp/kalign-2.03+20110620/kalign2_tree.c"
struct ntree_data *find_best_topology(struct ntree_data *ntree_data , int *leaves ,
                                      int *nodes ) 
{ 
  int i ;
  int c ;
  int elements ;
  int *milometer ;
  struct tree_node *tree ;
  struct tree_node *tmp ;
  int newnode ;
  int local_ntree ;
  int *tmp_tree ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  void *tmp___9 ;

  {
#line 433
  elements = 0;
#line 435
  milometer = (int *)0;
#line 436
  tree = (struct tree_node *)0;
#line 437
  tmp = (struct tree_node *)0;
#line 438
  newnode = 0;
#line 439
  local_ntree = 0;
#line 441
  tmp_tree = (int *)0;
  {
#line 443
  while (1) {
    while_continue: /* CIL Label */ ;
#line 443
    if (! (*(leaves + local_ntree) != -1)) {
#line 443
      goto while_break;
    }
#line 444
    local_ntree ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 453
  tmp___0 = malloc((sizeof(int ) * (unsigned long )((local_ntree + local_ntree) - 1)) * 3UL);
#line 453
  tmp_tree = (int *)tmp___0;
#line 454
  c = 0;
  }
  {
#line 454
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 454
    if (! (c < ((local_ntree + local_ntree) - 1) * 3)) {
#line 454
      goto while_break___0;
    }
#line 455
    *(tmp_tree + c) = 0;
#line 454
    c ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 458
  *(tmp_tree + 0) = 1;
#line 461
  if (local_ntree < 3) {
    {
#line 463
    *(tmp_tree + 0) = 1;
#line 465
    tmp___1 = malloc(sizeof(struct tree_node ));
#line 465
    tmp = (struct tree_node *)tmp___1;
#line 466
    tmp->left = (struct tree_node *)0;
#line 467
    tmp->right = (struct tree_node *)0;
#line 468
    tmp->label = -1;
#line 469
    tmp->edge = 0;
#line 471
    tmp___2 = malloc(sizeof(struct tree_node ));
#line 471
    tmp->left = (struct tree_node *)tmp___2;
#line 472
    (tmp->left)->left = (struct tree_node *)0;
#line 473
    (tmp->left)->right = (struct tree_node *)0;
#line 474
    (tmp->left)->edge = 1;
#line 475
    (tmp->left)->label = *(leaves + 0);
#line 476
    tmp___3 = malloc(sizeof(struct tree_node ));
#line 476
    tmp->right = (struct tree_node *)tmp___3;
#line 477
    (tmp->right)->left = (struct tree_node *)0;
#line 478
    (tmp->right)->right = (struct tree_node *)0;
#line 479
    (tmp->right)->edge = 2;
#line 480
    (tmp->right)->label = *(leaves + 1);
#line 481
    tmp___4 = malloc(sizeof(struct tree_node ));
#line 481
    tree = (struct tree_node *)tmp___4;
#line 482
    tree->left = tmp;
#line 483
    tree->right = (struct tree_node *)0;
#line 484
    tree->edge = -1;
#line 485
    tree->label = -1;
#line 487
    c = add_label_simpletree(tree, nodes, 0);
#line 488
    readsimpletree(tree, tmp_tree);
#line 493
    ntree_data = ntree_sub_alignment(ntree_data, tmp_tree, local_ntree);
#line 494
    free((void *)tmp_tree);
    }
  } else {
    {
#line 497
    elements = local_ntree - 2;
#line 498
    tmp___5 = malloc(sizeof(int ) * (unsigned long )elements);
#line 498
    milometer = (int *)tmp___5;
#line 499
    i = 0;
    }
    {
#line 499
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 499
      if (! (i < elements)) {
#line 499
        goto while_break___1;
      }
#line 500
      *(milometer + i) = 0;
#line 499
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 503
    i = 0;
    {
#line 504
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 504
      if (! (*(milometer + 0) != -1)) {
#line 504
        goto while_break___2;
      }
      {
#line 506
      *(tmp_tree + 0) = 1;
#line 508
      tmp___6 = malloc(sizeof(struct tree_node ));
#line 508
      tmp = (struct tree_node *)tmp___6;
#line 509
      tmp->left = (struct tree_node *)0;
#line 510
      tmp->right = (struct tree_node *)0;
#line 511
      tmp->label = -1;
#line 512
      tmp->edge = 0;
#line 514
      tmp___7 = malloc(sizeof(struct tree_node ));
#line 514
      tmp->left = (struct tree_node *)tmp___7;
#line 515
      (tmp->left)->left = (struct tree_node *)0;
#line 516
      (tmp->left)->right = (struct tree_node *)0;
#line 517
      (tmp->left)->edge = 1;
#line 518
      (tmp->left)->label = *(leaves + 0);
#line 519
      tmp___8 = malloc(sizeof(struct tree_node ));
#line 519
      tmp->right = (struct tree_node *)tmp___8;
#line 520
      (tmp->right)->left = (struct tree_node *)0;
#line 521
      (tmp->right)->right = (struct tree_node *)0;
#line 522
      (tmp->right)->edge = 2;
#line 523
      (tmp->right)->label = *(leaves + 1);
#line 524
      tmp___9 = malloc(sizeof(struct tree_node ));
#line 524
      tree = (struct tree_node *)tmp___9;
#line 525
      tree->left = tmp;
#line 526
      tree->right = (struct tree_node *)0;
#line 527
      tree->edge = -1;
#line 528
      tree->label = -1;
#line 534
      newnode = 3;
#line 535
      c = 0;
      }
      {
#line 535
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 535
        if (! (c < elements)) {
#line 535
          goto while_break___3;
        }
        {
#line 537
        tree = simpleinsert(tree, *(milometer + c), newnode, *(leaves + (2 + c)));
#line 538
        newnode += 2;
#line 535
        c ++;
        }
      }
      while_break___3: /* CIL Label */ ;
      }
      {
#line 540
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Topology:%d\t",
              i);
#line 542
      c = add_label_simpletree(tree, nodes, 0);
#line 544
      readsimpletree(tree, tmp_tree);
#line 545
      freesimpletree(tree);
#line 550
      ntree_data = ntree_sub_alignment(ntree_data, tmp_tree, local_ntree);
#line 557
      i ++;
#line 558
      milometer = ticker(milometer, elements);
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 561
    free((void *)milometer);
#line 562
    free((void *)tmp_tree);
    }
  }
#line 564
  return (ntree_data);
}
}
#line 567 "/home/june/repo/benchmarks/collector/temp/kalign-2.03+20110620/kalign2_tree.c"
int add_label_simpletree(struct tree_node *p , int *nodes , int i ) 
{ 


  {
#line 569
  if (p->left) {
    {
#line 570
    i = add_label_simpletree(p->left, nodes, i);
    }
  }
#line 572
  if (p->right) {
    {
#line 573
    i = add_label_simpletree(p->right, nodes, i);
    }
  }
#line 575
  if (p->left) {
#line 576
    if (p->right) {
#line 577
      p->label = *(nodes + i);
#line 578
      i ++;
#line 579
      return (i);
    }
  }
#line 582
  return (i);
}
}
#line 585 "/home/june/repo/benchmarks/collector/temp/kalign-2.03+20110620/kalign2_tree.c"
int *readsimpletree(struct tree_node *p , int *tree ) 
{ 


  {
#line 587
  if (p->left) {
    {
#line 588
    tree = readsimpletree(p->left, tree);
    }
  }
#line 590
  if (p->right) {
    {
#line 591
    tree = readsimpletree(p->right, tree);
    }
  }
#line 593
  if (p->left) {
#line 594
    if (p->right) {
#line 595
      *(tree + *(tree + 0)) = (p->left)->label;
#line 596
      *(tree + (*(tree + 0) + 1)) = (p->right)->label;
#line 597
      *(tree + (*(tree + 0) + 2)) = p->label;
#line 598
      *(tree + 0) += 3;
    }
  }
#line 607
  return (tree);
}
}
#line 610 "/home/june/repo/benchmarks/collector/temp/kalign-2.03+20110620/kalign2_tree.c"
void printsimpleTree(struct tree_node *p ) 
{ 


  {
#line 612
  if (p->left) {
    {
#line 613
    printsimpleTree(p->left);
    }
  }
#line 616
  if (p->right) {
    {
#line 617
    printsimpleTree(p->right);
    }
  }
#line 619
  if (p->left) {
#line 620
    if (p->right) {
      {
#line 621
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%d %d -> %d\n",
              (p->left)->label, (p->right)->label, p->label);
#line 622
      free((void *)p->left);
#line 623
      free((void *)p->right);
      }
    } else {
      {
#line 625
      free((void *)p->left);
      }
    }
  } else {
    {
#line 628
    free((void *)p->right);
    }
  }
#line 632
  return;
}
}
#line 635 "/home/june/repo/benchmarks/collector/temp/kalign-2.03+20110620/kalign2_tree.c"
struct tree_node *simpleinsert(struct tree_node *p , int target , int new_edge , int leaf_label ) 
{ 
  struct tree_node *tmp ;
  struct tree_node *tmp2 ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;

  {
#line 637
  tmp = (struct tree_node *)0;
#line 638
  tmp2 = (struct tree_node *)0;
#line 640
  if (p->left) {
#line 641
    if ((p->left)->edge == target) {
      {
#line 642
      tmp___0 = malloc(sizeof(struct tree_node ));
#line 642
      tmp = (struct tree_node *)tmp___0;
#line 643
      tmp->left = (struct tree_node *)0;
#line 644
      tmp->right = (struct tree_node *)0;
#line 645
      tmp->label = leaf_label;
#line 646
      tmp->edge = new_edge + 1;
#line 648
      tmp___1 = malloc(sizeof(struct tree_node ));
#line 648
      tmp2 = (struct tree_node *)tmp___1;
#line 649
      tmp2->left = tmp;
#line 650
      tmp2->right = p->left;
#line 651
      tmp2->label = -1;
#line 652
      tmp2->edge = (p->left)->edge;
#line 654
      (p->left)->edge = new_edge;
#line 656
      p->left = tmp2;
      }
#line 659
      return (p);
    } else {
      {
#line 661
      p->left = simpleinsert(p->left, target, new_edge, leaf_label);
      }
    }
  }
#line 665
  if (p->right) {
#line 666
    if ((p->right)->edge == target) {
      {
#line 667
      tmp___2 = malloc(sizeof(struct tree_node ));
#line 667
      tmp = (struct tree_node *)tmp___2;
#line 668
      tmp->left = (struct tree_node *)0;
#line 669
      tmp->right = (struct tree_node *)0;
#line 670
      tmp->label = leaf_label;
#line 671
      tmp->edge = new_edge + 1;
#line 673
      tmp___3 = malloc(sizeof(struct tree_node ));
#line 673
      tmp2 = (struct tree_node *)tmp___3;
#line 674
      tmp2->left = tmp;
#line 675
      tmp2->right = p->right;
#line 676
      tmp2->label = -1;
#line 677
      tmp2->edge = (p->right)->edge;
#line 679
      (p->right)->edge = new_edge;
#line 681
      p->right = tmp2;
      }
#line 684
      return (p);
    } else {
      {
#line 686
      p->right = simpleinsert(p->right, target, new_edge, leaf_label);
      }
    }
  }
#line 689
  return (p);
}
}
#line 693 "/home/june/repo/benchmarks/collector/temp/kalign-2.03+20110620/kalign2_tree.c"
int *ticker(int *milometer , int elements ) 
{ 


  {
  {
#line 695
  while (1) {
    while_continue: /* CIL Label */ ;
#line 695
    if (! elements) {
#line 695
      goto while_break;
    }
#line 696
    if (*(milometer + (elements - 1)) < 2 * elements) {
#line 697
      (*(milometer + (elements - 1))) ++;
#line 698
      return (milometer);
    } else {
#line 700
      *(milometer + (elements - 1)) = 0;
#line 701
      elements --;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 704
  *(milometer + 0) = -1;
#line 705
  return (milometer);
}
}
#line 711 "/home/june/repo/benchmarks/collector/temp/kalign-2.03+20110620/kalign2_tree.c"
int *upgma(float **dm , int *tree ) 
{ 
  int i ;
  int j ;
  int t ;
  int *as ;
  float max ;
  int node_a ;
  int node_b ;
  int cnode ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 714
  as = (int *)0;
#line 716
  node_a = 0;
#line 717
  node_b = 0;
#line 718
  cnode = (int )numseq;
#line 720
  tmp = malloc(sizeof(int ) * (unsigned long )numseq);
#line 720
  as = (int *)tmp;
#line 721
  i = (int )numseq;
  }
  {
#line 721
  while (1) {
    while_continue: /* CIL Label */ ;
#line 721
    tmp___0 = i;
#line 721
    i --;
#line 721
    if (! tmp___0) {
#line 721
      goto while_break;
    }
#line 722
    *(as + i) = i + 1;
  }
  while_break: /* CIL Label */ ;
  }
#line 726
  t = 0;
  {
#line 727
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 727
    if (! ((unsigned int )cnode != numprofiles)) {
#line 727
      goto while_break___0;
    }
#line 728
    max = - 3.40282346638528859812e+38F;
#line 729
    i = 0;
    {
#line 729
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 729
      if (! ((unsigned int )i < numseq - 1U)) {
#line 729
        goto while_break___1;
      }
#line 730
      if (*(as + i)) {
#line 731
        j = i + 1;
        {
#line 731
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 731
          if (! ((unsigned int )j < numseq)) {
#line 731
            goto while_break___2;
          }
#line 732
          if (*(as + j)) {
#line 733
            if (*(*(dm + i) + j) > max) {
#line 734
              max = *(*(dm + i) + j);
#line 735
              node_a = i;
#line 736
              node_b = j;
            }
          }
#line 731
          j ++;
        }
        while_break___2: /* CIL Label */ ;
        }
      }
#line 729
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 743
    *(tree + t) = *(as + node_a) - 1;
#line 744
    *(tree + (t + 1)) = *(as + node_b) - 1;
#line 745
    *(tree + (t + 2)) = cnode;
#line 746
    t += 3;
#line 749
    *(as + node_a) = cnode + 1;
#line 750
    *(as + node_b) = 0;
#line 751
    cnode ++;
#line 754
    j = (int )numseq;
    {
#line 754
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 754
      tmp___1 = j;
#line 754
      j --;
#line 754
      if (! tmp___1) {
#line 754
        goto while_break___3;
      }
#line 755
      if (j != node_b) {
#line 756
        *(*(dm + node_a) + j) = (*(*(dm + node_a) + j) + *(*(dm + node_b) + j)) / (float )2;
      }
    }
    while_break___3: /* CIL Label */ ;
    }
#line 759
    *(*(dm + node_a) + node_a) = 0.0f;
#line 760
    j = (int )numseq;
    {
#line 760
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 760
      tmp___2 = j;
#line 760
      j --;
#line 760
      if (! tmp___2) {
#line 760
        goto while_break___4;
      }
#line 761
      *(*(dm + j) + node_a) = *(*(dm + node_a) + j);
#line 762
      *(*(dm + j) + node_b) = 0.0f;
#line 763
      *(*(dm + node_b) + j) = 0.0f;
    }
    while_break___4: /* CIL Label */ ;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 766
  free((void *)as);
  }
#line 767
  return (tree);
}
}
#line 772 "/home/june/repo/benchmarks/collector/temp/kalign-2.03+20110620/kalign2_tree.c"
int *nj(float **dm , int *tree ) 
{ 
  int i ;
  int j ;
  float *r ;
  float *r_div ;
  int *active ;
  int node ;
  float min ;
  int join_a ;
  int join_b ;
  int leaves ;
  int c ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  float tmp___2 ;
  float tmp___3 ;
  int tmp___4 ;

  {
  {
#line 776
  r = (float *)0;
#line 777
  r_div = (float *)0;
#line 778
  active = (int *)0;
#line 779
  node = 0;
#line 780
  min = (float )0;
#line 781
  join_a = 0;
#line 782
  join_b = 0;
#line 783
  leaves = 0;
#line 784
  c = 0;
#line 786
  leaves = (int )numseq;
#line 788
  tmp = malloc((unsigned long )(numseq * 2U - 1U) * sizeof(float ));
#line 788
  r = (float *)tmp;
#line 789
  tmp___0 = malloc((unsigned long )(numseq * 2U - 1U) * sizeof(float ));
#line 789
  r_div = (float *)tmp___0;
#line 790
  tmp___1 = malloc((unsigned long )(numseq * 2U - 1U) * sizeof(int ));
#line 790
  active = (int *)tmp___1;
#line 791
  i = 0;
  }
  {
#line 791
  while (1) {
    while_continue: /* CIL Label */ ;
#line 791
    if (! ((unsigned int )i < numseq * 2U - 1U)) {
#line 791
      goto while_break;
    }
#line 792
    *(active + i) = 0;
#line 791
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 794
  i = 0;
  {
#line 794
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 794
    if (! ((unsigned int )i < numseq)) {
#line 794
      goto while_break___0;
    }
#line 795
    *(active + i) = 1;
#line 794
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 798
  node = (int )numseq;
  {
#line 799
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 799
    if (! ((unsigned int )node != numseq * 2U - 1U)) {
#line 799
      goto while_break___1;
    }
#line 800
    i = 0;
    {
#line 800
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 800
      if (! ((unsigned int )i < numseq * 2U - 1U)) {
#line 800
        goto while_break___2;
      }
#line 801
      if (*(active + i)) {
#line 802
        *(r + i) = (float )0;
#line 803
        j = 0;
        {
#line 803
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 803
          if (! ((unsigned int )j < numseq * 2U - 1U)) {
#line 803
            goto while_break___3;
          }
#line 804
          if (*(active + j)) {
#line 805
            if (i < j) {
#line 805
              tmp___2 = *(*(dm + i) + j);
            } else {
#line 805
              tmp___2 = *(*(dm + j) + i);
            }
#line 805
            *(r + i) += tmp___2;
          }
#line 803
          j ++;
        }
        while_break___3: /* CIL Label */ ;
        }
#line 808
        *(r_div + i) = *(r + i) / (float )(leaves - 2);
      }
#line 800
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 811
    j = 0;
    {
#line 811
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 811
      if (! ((unsigned int )j < numseq * 2U - 1U)) {
#line 811
        goto while_break___4;
      }
#line 812
      if (*(active + j)) {
#line 813
        i = j + 1;
        {
#line 813
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 813
          if (! ((unsigned int )i < numseq * 2U - 1U)) {
#line 813
            goto while_break___5;
          }
#line 814
          if (*(active + i)) {
#line 815
            *(*(dm + i) + j) = *(*(dm + j) + i) - (*(r + i) + *(r + j)) / (float )2;
          }
#line 813
          i ++;
        }
        while_break___5: /* CIL Label */ ;
        }
      }
#line 811
      j ++;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 820
    min = - 3.40282346638528859812e+38F;
#line 821
    j = 0;
    {
#line 821
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 821
      if (! ((unsigned int )j < numseq * 2U - 1U)) {
#line 821
        goto while_break___6;
      }
#line 822
      if (*(active + j)) {
#line 823
        i = j + 1;
        {
#line 823
        while (1) {
          while_continue___7: /* CIL Label */ ;
#line 823
          if (! ((unsigned int )i < numseq * 2U - 1U)) {
#line 823
            goto while_break___7;
          }
#line 824
          if (*(active + i)) {
#line 825
            if (*(*(dm + i) + j) > min) {
#line 826
              min = *(*(dm + i) + j);
#line 827
              join_a = j;
#line 828
              join_b = i;
            }
          }
#line 823
          i ++;
        }
        while_break___7: /* CIL Label */ ;
        }
      }
#line 821
      j ++;
    }
    while_break___6: /* CIL Label */ ;
    }
#line 835
    *(*(dm + join_a) + node) = *(*(dm + join_a) + join_b) / (float )2 + (*(r_div + join_a) - *(r_div + join_b)) / (float )2;
#line 836
    *(*(dm + join_b) + node) = *(*(dm + join_a) + join_b) - *(*(dm + join_a) + node);
#line 838
    *(active + join_a) = 0;
#line 839
    *(active + join_b) = 0;
#line 840
    *(tree + c) = join_a;
#line 841
    *(tree + (c + 1)) = join_b;
#line 842
    *(tree + (c + 2)) = node;
#line 844
    i = 0;
    {
#line 844
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 844
      if (! ((unsigned int )i < numseq * 2U - 1U)) {
#line 844
        goto while_break___8;
      }
#line 845
      if (*(active + i)) {
#line 846
        if (i > join_a) {
#line 846
          *(*(dm + i) + node) = *(*(dm + join_a) + i);
        } else {
#line 846
          *(*(dm + i) + node) = *(*(dm + i) + join_a);
        }
#line 847
        *(*(dm + i) + node) -= *(*(dm + join_a) + node);
#line 848
        if (i > join_b) {
#line 848
          tmp___3 = *(*(dm + join_b) + i);
        } else {
#line 848
          tmp___3 = *(*(dm + i) + join_b);
        }
#line 848
        *(*(dm + i) + node) += tmp___3;
#line 849
        *(*(dm + i) + node) -= *(*(dm + join_b) + node);
#line 850
        *(*(dm + i) + node) /= (float )2;
      }
#line 844
      i ++;
    }
    while_break___8: /* CIL Label */ ;
    }
#line 853
    *(active + node) = 1;
#line 854
    c += 3;
#line 855
    node ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 860
  i = (int )numprofiles;
  {
#line 860
  while (1) {
    while_continue___9: /* CIL Label */ ;
#line 860
    tmp___4 = i;
#line 860
    i --;
#line 860
    if (! tmp___4) {
#line 860
      goto while_break___9;
    }
    {
#line 861
    free((void *)*(dm + i));
    }
  }
  while_break___9: /* CIL Label */ ;
  }
  {
#line 863
  free((void *)dm);
#line 865
  free((void *)r);
#line 866
  free((void *)r_div);
#line 867
  free((void *)active);
  }
#line 869
  return (tree);
}
}
#line 114 "/home/june/repo/benchmarks/collector/temp/kalign-2.03+20110620/kalign2.h"
struct bignode *big_insert_hash(struct bignode *n , unsigned int const   pos ) ;
#line 115
void big_remove_nodes(struct bignode *n ) ;
#line 116
void big_print_nodes(struct bignode *n ) ;
#line 238
int *mirror_path(int *path ) ;
#line 275
struct node *insert(struct node *n , int pos ) ;
#line 276
struct node *insert_hash(struct node *n , int pos ) ;
#line 278
void remove_nodes(struct node *n ) ;
#line 373
void update_gaps(int old_len , int *gis , int new_len , int *newgaps ) ;
#line 376
struct alignment *sort_in_relation(struct alignment *aln , char *sort ) ;
#line 377
void quickSort(struct alignment *aln , int array_size ) ;
#line 378
void q_sort(struct alignment *aln , int left , int right ) ;
#line 409
void print_newick_tree(struct aln_tree_node *p , struct alignment *aln , FILE *fout ) ;
#line 410
void print_phyloxml_tree(struct aln_tree_node *p , struct alignment *aln , FILE *fout ) ;
#line 32 "/home/june/repo/benchmarks/collector/temp/kalign-2.03+20110620/kalign2_misc.c"
void print_tree(struct aln_tree_node *p , struct alignment *aln , char *outfile ) 
{ 
  FILE *fout ;

  {
  {
#line 34
  fout = (FILE *)((void *)0);
#line 35
  fout = fopen((char const   */* __restrict  */)outfile, (char const   */* __restrict  */)"w");
  }
#line 35
  if ((unsigned long )fout == (unsigned long )((void *)0)) {
    {
#line 36
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"can\'t open output\n");
#line 37
    exit(0);
    }
  }
  {
#line 48
  print_newick_tree(p, aln, fout);
#line 49
  fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)";");
#line 51
  fclose(fout);
  }
#line 52
  return;
}
}
#line 56 "/home/june/repo/benchmarks/collector/temp/kalign-2.03+20110620/kalign2_misc.c"
void print_newick_tree(struct aln_tree_node *p , struct alignment *aln , FILE *fout ) 
{ 
  int j ;
  unsigned short const   **tmp ;

  {
#line 60
  if (*(p->links + 0)) {
    {
#line 62
    fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"(");
#line 63
    print_newick_tree(*(p->links + 0), aln, fout);
    }
  }
#line 65
  if ((unsigned int )p->num < numseq) {
#line 67
    j = 0;
    {
#line 67
    while (1) {
      while_continue: /* CIL Label */ ;
#line 67
      if (! ((unsigned int )j < *(aln->lsn + p->num))) {
#line 67
        goto while_break;
      }
      {
#line 68
      tmp = __ctype_b_loc();
      }
#line 68
      if ((int const   )*(*tmp + (int )*(*(aln->sn + p->num) + j)) & 8192) {
        {
#line 69
        fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"_");
        }
      } else {
        {
#line 71
        fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"%c",
                (int )*(*(aln->sn + p->num) + j));
        }
      }
#line 67
      j ++;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
#line 78
    fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)",");
    }
  }
#line 80
  if (*(p->links + 1)) {
    {
#line 81
    print_newick_tree(*(p->links + 1), aln, fout);
#line 82
    fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)")");
    }
  }
#line 84
  return;
}
}
#line 86 "/home/june/repo/benchmarks/collector/temp/kalign-2.03+20110620/kalign2_misc.c"
void print_phyloxml_tree(struct aln_tree_node *p , struct alignment *aln , FILE *fout ) 
{ 
  int j ;

  {
#line 90
  if (*(p->links + 0)) {
    {
#line 92
    fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"<clade>\n");
#line 93
    print_phyloxml_tree(*(p->links + 0), aln, fout);
    }
  }
#line 95
  if ((unsigned int )p->num < numseq) {
    {
#line 97
    fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"<clade>\n<name>");
#line 98
    j = 0;
    }
    {
#line 98
    while (1) {
      while_continue: /* CIL Label */ ;
#line 98
      if (! ((unsigned int )j < *(aln->lsn + p->num))) {
#line 98
        goto while_break;
      }
      {
#line 99
      fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"%c",
              (int )*(*(aln->sn + p->num) + j));
#line 98
      j ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 101
    fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"</name>\n</clade>\n");
    }
  }
#line 108
  if (*(p->links + 1)) {
    {
#line 109
    print_phyloxml_tree(*(p->links + 1), aln, fout);
#line 110
    fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"</clade>\n");
    }
  }
#line 112
  return;
}
}
#line 114 "/home/june/repo/benchmarks/collector/temp/kalign-2.03+20110620/kalign2_misc.c"
struct alignment *sort_sequences(struct alignment *aln , int *tree , char *sort ) 
{ 
  int i ;
  int j ;
  int a ;
  int b ;
  int c ;
  int choice ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 117
  choice = 0;
#line 119
  if (sort) {
    {
#line 120
    tmp___1 = byg_start((char *)"input", sort);
    }
#line 120
    if (tmp___1 != -1) {
#line 121
      choice = 0;
    } else {
      {
#line 122
      tmp___0 = byg_start((char *)"tree", sort);
      }
#line 122
      if (tmp___0 != -1) {
#line 123
        choice = 1;
      } else {
        {
#line 124
        tmp = byg_start((char *)"gaps", sort);
        }
#line 124
        if (tmp != -1) {
#line 125
          choice = 2;
        } else {
#line 127
          choice = 3;
        }
      }
    }
  }
  {
#line 132
  if (choice == 0) {
#line 132
    goto case_0;
  }
#line 137
  if (choice == 1) {
#line 137
    goto case_1;
  }
#line 151
  if (choice == 2) {
#line 151
    goto case_2;
  }
#line 168
  if (choice == 3) {
#line 168
    goto case_3;
  }
#line 171
  goto switch_default;
  case_0: /* CIL Label */ 
#line 133
  i = 0;
  {
#line 133
  while (1) {
    while_continue: /* CIL Label */ ;
#line 133
    if (! ((unsigned int )i < numseq)) {
#line 133
      goto while_break;
    }
#line 134
    *(aln->nsip + i) = (unsigned int )i;
#line 133
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 136
  goto switch_break;
  case_1: /* CIL Label */ 
#line 138
  c = 0;
#line 139
  i = 0;
  {
#line 139
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 139
    if (! ((unsigned int )i < (numseq - 1U) * 3U)) {
#line 139
      goto while_break___0;
    }
#line 141
    if ((unsigned int )*(tree + i) < numseq) {
#line 142
      *(aln->nsip + c) = (unsigned int )*(tree + i);
#line 143
      c ++;
    }
#line 145
    if ((unsigned int )*(tree + (i + 1)) < numseq) {
#line 146
      *(aln->nsip + c) = (unsigned int )*(tree + (i + 1));
#line 147
      c ++;
    }
#line 139
    i += 3;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 150
  goto switch_break;
  case_2: /* CIL Label */ 
#line 152
  i = 0;
  {
#line 152
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 152
    if (! ((unsigned int )i < numseq)) {
#line 152
      goto while_break___1;
    }
#line 153
    a = 1000000;
#line 154
    b = -1;
#line 155
    j = 0;
    {
#line 155
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 155
      if (! ((unsigned int )j < numseq)) {
#line 155
        goto while_break___2;
      }
#line 156
      if (*(aln->nsip + j) < (unsigned int )a) {
#line 157
        a = (int )*(aln->nsip + j);
#line 158
        b = j;
      }
#line 155
      j ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 161
    *(tree + i) = b;
#line 162
    *(aln->nsip + b) = 1000000U;
#line 152
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 164
  i = 0;
  {
#line 164
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 164
    if (! ((unsigned int )i < numseq)) {
#line 164
      goto while_break___3;
    }
#line 165
    *(aln->nsip + i) = (unsigned int )*(tree + i);
#line 164
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 167
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 169
  aln = sort_in_relation(aln, sort);
  }
#line 170
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 172
  i = 0;
  {
#line 172
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 172
    if (! ((unsigned int )i < numseq)) {
#line 172
      goto while_break___4;
    }
#line 173
    *(aln->nsip + i) = (unsigned int )i;
#line 172
    i ++;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 175
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 182
  return (aln);
}
}
#line 185 "/home/june/repo/benchmarks/collector/temp/kalign-2.03+20110620/kalign2_misc.c"
struct alignment *sort_in_relation(struct alignment *aln , char *sort ) 
{ 
  int i ;
  int j ;
  int c ;
  int target ;
  int id ;
  int positions ;
  int posa ;
  int posb ;
  int tmp ;

  {
#line 188
  target = -1;
#line 189
  id = 0;
#line 190
  positions = 0;
#line 191
  posa = 0;
#line 192
  posb = 0;
#line 193
  i = 0;
  {
#line 193
  while (1) {
    while_continue: /* CIL Label */ ;
#line 193
    if (! ((unsigned int )i < numseq)) {
#line 193
      goto while_break;
    }
    {
#line 194
    tmp = byg_start(sort, *(aln->sn + i));
    }
#line 194
    if (tmp != -1) {
#line 195
      target = i;
#line 196
      *(*(aln->sip + i) + 0) = 1000U;
#line 197
      goto while_break;
    }
#line 193
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 200
  if (target == -1) {
#line 201
    target = 0;
#line 202
    *(*(aln->sip + 0) + 0) = 1000U;
  }
#line 204
  i = 0;
  {
#line 204
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 204
    if (! ((unsigned int )i < numseq)) {
#line 204
      goto while_break___0;
    }
#line 205
    if (i != target) {
#line 206
      posa = 0;
#line 207
      posb = 0;
#line 208
      c = 0;
#line 209
      id = 0;
#line 210
      positions = 0;
#line 211
      j = 0;
      {
#line 211
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 211
        if (! ((unsigned int )j < *(aln->sl + i))) {
#line 211
          goto while_break___1;
        }
#line 212
        posa += *(*(aln->s + i) + j) + 1;
        {
#line 213
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 213
          if (! (posa > posb)) {
#line 213
            goto while_break___2;
          }
#line 214
          posb += *(*(aln->s + target) + c) + 1;
#line 215
          c ++;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 217
        if (posa == posb) {
#line 218
          if ((int )*(*(aln->seq + i) + j) == (int )*(*(aln->seq + target) + (c - 1))) {
#line 219
            id += 1000;
          }
#line 221
          positions ++;
        }
#line 211
        j ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 224
      if (positions) {
#line 225
        *(*(aln->sip + i) + 0) = (unsigned int )(id / positions);
      } else {
#line 227
        *(*(aln->sip + i) + 0) = 0U;
      }
    }
#line 204
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 231
  i = 0;
  {
#line 231
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 231
    if (! ((unsigned int )i < numseq)) {
#line 231
      goto while_break___3;
    }
#line 232
    *(aln->nsip + i) = (unsigned int )i;
#line 231
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 234
  quickSort(aln, (int )numseq);
  }
#line 235
  return (aln);
}
}
#line 238 "/home/june/repo/benchmarks/collector/temp/kalign-2.03+20110620/kalign2_misc.c"
void quickSort(struct alignment *aln , int array_size ) 
{ 


  {
  {
#line 240
  q_sort(aln, 0, array_size - 1);
  }
#line 241
  return;
}
}
#line 243 "/home/june/repo/benchmarks/collector/temp/kalign-2.03+20110620/kalign2_misc.c"
void q_sort(struct alignment *aln , int left , int right ) 
{ 
  int pivot ;
  int l_hold ;
  int r_hold ;
  int pivot2 ;

  {
#line 247
  l_hold = left;
#line 248
  r_hold = right;
#line 249
  pivot2 = (int )*(aln->nsip + left);
#line 250
  pivot = (int )*(*(aln->sip + left) + 0);
  {
#line 251
  while (1) {
    while_continue: /* CIL Label */ ;
#line 251
    if (! (left < right)) {
#line 251
      goto while_break;
    }
    {
#line 252
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 252
      if (*(*(aln->sip + right) + 0) <= (unsigned int )pivot) {
#line 252
        if (! (left < right)) {
#line 252
          goto while_break___0;
        }
      } else {
#line 252
        goto while_break___0;
      }
#line 253
      right --;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 255
    if (left != right) {
#line 256
      *(*(aln->sip + left) + 0) = *(*(aln->sip + right) + 0);
#line 257
      *(aln->nsip + left) = *(aln->nsip + right);
#line 258
      left ++;
    }
    {
#line 260
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 260
      if (*(*(aln->sip + left) + 0) >= (unsigned int )pivot) {
#line 260
        if (! (left < right)) {
#line 260
          goto while_break___1;
        }
      } else {
#line 260
        goto while_break___1;
      }
#line 261
      left ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 263
    if (left != right) {
#line 264
      *(*(aln->sip + right) + 0) = *(*(aln->sip + left) + 0);
#line 265
      *(aln->nsip + right) = *(aln->nsip + left);
#line 266
      right --;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 269
  *(*(aln->sip + left) + 0) = (unsigned int )pivot;
#line 270
  *(aln->nsip + left) = (unsigned int )pivot2;
#line 271
  pivot = left;
#line 272
  left = l_hold;
#line 273
  right = r_hold;
#line 274
  if (left < pivot) {
    {
#line 275
    q_sort(aln, left, pivot - 1);
    }
  }
#line 277
  if (right > pivot) {
    {
#line 278
    q_sort(aln, pivot + 1, right);
    }
  }
#line 280
  return;
}
}
#line 282 "/home/june/repo/benchmarks/collector/temp/kalign-2.03+20110620/kalign2_misc.c"
int *readtree(struct aln_tree_node *p , int *tree ) 
{ 


  {
#line 284
  if (*(p->links + 0)) {
    {
#line 285
    tree = readtree(*(p->links + 0), tree);
    }
  }
#line 287
  if (*(p->links + 1)) {
    {
#line 288
    tree = readtree(*(p->links + 1), tree);
    }
  }
#line 291
  if (*(p->links + 0)) {
#line 292
    if (*(p->links + 1)) {
      {
#line 293
      *(tree + *(tree + 0)) = (*(p->links + 0))->num;
#line 294
      *(tree + (*(tree + 0) + 1)) = (*(p->links + 1))->num;
#line 295
      *(tree + (*(tree + 0) + 2)) = p->num;
#line 296
      *(tree + 0) += 3;
#line 297
      free((void *)(*(p->links + 0))->internal_lables);
#line 298
      free((void *)(*(p->links + 0))->links);
#line 299
      free((void *)*(p->links + 0));
#line 300
      free((void *)(*(p->links + 1))->internal_lables);
#line 301
      free((void *)(*(p->links + 1))->links);
#line 302
      free((void *)*(p->links + 1));
      }
    }
  }
#line 305
  return (tree);
}
}
#line 308 "/home/june/repo/benchmarks/collector/temp/kalign-2.03+20110620/kalign2_misc.c"
struct alignment *make_dna(struct alignment *aln ) 
{ 
  int i ;
  int j ;
  int *p ;

  {
#line 315
  i = 0;
  {
#line 315
  while (1) {
    while_continue: /* CIL Label */ ;
#line 315
    if (! ((unsigned int )i < numseq)) {
#line 315
      goto while_break;
    }
#line 316
    p = *(aln->s + i);
#line 317
    j = 0;
    {
#line 317
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 317
      if (! ((unsigned int )j < *(aln->sl + i))) {
#line 317
        goto while_break___0;
      }
      {
#line 319
      if (*(p + j) == 2) {
#line 319
        goto case_2;
      }
#line 322
      if (*(p + j) == 6) {
#line 322
        goto case_6;
      }
#line 325
      if (*(p + j) == 17) {
#line 325
        goto case_17;
      }
#line 328
      if (*(p + j) == 12) {
#line 328
        goto case_12;
      }
#line 331
      if (*(p + j) == 20) {
#line 331
        goto case_20;
      }
#line 334
      if (*(p + j) == 23) {
#line 334
        goto case_23;
      }
#line 318
      goto switch_break;
      case_2: /* CIL Label */ 
#line 320
      *(p + j) = 1;
#line 321
      goto switch_break;
      case_6: /* CIL Label */ 
#line 323
      *(p + j) = 2;
#line 324
      goto switch_break;
      case_17: /* CIL Label */ 
#line 326
      *(p + j) = 3;
#line 327
      goto switch_break;
      case_12: /* CIL Label */ 
#line 329
      *(p + j) = 4;
#line 330
      goto switch_break;
      case_20: /* CIL Label */ 
#line 332
      *(p + j) = 4;
#line 333
      goto switch_break;
      case_23: /* CIL Label */ 
#line 335
      *(p + j) = 4;
#line 336
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
#line 317
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 315
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 341
  return (aln);
}
}
#line 344 "/home/june/repo/benchmarks/collector/temp/kalign-2.03+20110620/kalign2_misc.c"
float **read_matrix(float **subm , struct parameters *param ) 
{ 
  int i ;
  int j ;
  int m_pos ;
  short *matrix_pointer ;
  short blosum50mt[276] ;
  short blosum62mt[276] ;
  short gon250mt[276] ;
  int tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 347
  m_pos = 0;
#line 348
  matrix_pointer = (short *)0;
#line 349
  blosum50mt[0] = (short)5;
#line 349
  blosum50mt[1] = (short)-2;
#line 349
  blosum50mt[2] = (short)5;
#line 349
  blosum50mt[3] = (short)-1;
#line 349
  blosum50mt[4] = (short)-3;
#line 349
  blosum50mt[5] = (short)13;
#line 349
  blosum50mt[6] = (short)-2;
#line 349
  blosum50mt[7] = (short)5;
#line 349
  blosum50mt[8] = (short)-4;
#line 349
  blosum50mt[9] = (short)8;
#line 349
  blosum50mt[10] = (short)-1;
#line 349
  blosum50mt[11] = (short)1;
#line 349
  blosum50mt[12] = (short)-3;
#line 349
  blosum50mt[13] = (short)2;
#line 349
  blosum50mt[14] = (short)6;
#line 349
  blosum50mt[15] = (short)-3;
#line 349
  blosum50mt[16] = (short)-4;
#line 349
  blosum50mt[17] = (short)-2;
#line 349
  blosum50mt[18] = (short)-5;
#line 349
  blosum50mt[19] = (short)-3;
#line 349
  blosum50mt[20] = (short)8;
#line 349
  blosum50mt[21] = (short)0;
#line 349
  blosum50mt[22] = (short)-1;
#line 349
  blosum50mt[23] = (short)-3;
#line 349
  blosum50mt[24] = (short)-1;
#line 349
  blosum50mt[25] = (short)-3;
#line 349
  blosum50mt[26] = (short)-4;
#line 349
  blosum50mt[27] = (short)8;
#line 349
  blosum50mt[28] = (short)-2;
#line 349
  blosum50mt[29] = (short)0;
#line 349
  blosum50mt[30] = (short)-3;
#line 349
  blosum50mt[31] = (short)-1;
#line 349
  blosum50mt[32] = (short)0;
#line 349
  blosum50mt[33] = (short)-1;
#line 349
  blosum50mt[34] = (short)-2;
#line 349
  blosum50mt[35] = (short)10;
#line 349
  blosum50mt[36] = (short)-1;
#line 349
  blosum50mt[37] = (short)-4;
#line 349
  blosum50mt[38] = (short)-2;
#line 349
  blosum50mt[39] = (short)-4;
#line 349
  blosum50mt[40] = (short)-4;
#line 349
  blosum50mt[41] = (short)0;
#line 349
  blosum50mt[42] = (short)-4;
#line 349
  blosum50mt[43] = (short)-4;
#line 349
  blosum50mt[44] = (short)5;
#line 349
  blosum50mt[45] = (short)-1;
#line 349
  blosum50mt[46] = (short)0;
#line 349
  blosum50mt[47] = (short)-3;
#line 349
  blosum50mt[48] = (short)-1;
#line 349
  blosum50mt[49] = (short)1;
#line 349
  blosum50mt[50] = (short)-4;
#line 349
  blosum50mt[51] = (short)-2;
#line 349
  blosum50mt[52] = (short)0;
#line 349
  blosum50mt[53] = (short)-3;
#line 349
  blosum50mt[54] = (short)6;
#line 349
  blosum50mt[55] = (short)-2;
#line 349
  blosum50mt[56] = (short)-4;
#line 349
  blosum50mt[57] = (short)-2;
#line 349
  blosum50mt[58] = (short)-4;
#line 349
  blosum50mt[59] = (short)-3;
#line 349
  blosum50mt[60] = (short)1;
#line 349
  blosum50mt[61] = (short)-4;
#line 349
  blosum50mt[62] = (short)-3;
#line 349
  blosum50mt[63] = (short)2;
#line 349
  blosum50mt[64] = (short)-3;
#line 349
  blosum50mt[65] = (short)5;
#line 349
  blosum50mt[66] = (short)-1;
#line 349
  blosum50mt[67] = (short)-3;
#line 349
  blosum50mt[68] = (short)-2;
#line 349
  blosum50mt[69] = (short)-4;
#line 349
  blosum50mt[70] = (short)-2;
#line 349
  blosum50mt[71] = (short)0;
#line 349
  blosum50mt[72] = (short)-3;
#line 349
  blosum50mt[73] = (short)-1;
#line 349
  blosum50mt[74] = (short)2;
#line 349
  blosum50mt[75] = (short)-2;
#line 349
  blosum50mt[76] = (short)3;
#line 349
  blosum50mt[77] = (short)7;
#line 349
  blosum50mt[78] = (short)-1;
#line 349
  blosum50mt[79] = (short)4;
#line 349
  blosum50mt[80] = (short)-2;
#line 349
  blosum50mt[81] = (short)2;
#line 349
  blosum50mt[82] = (short)0;
#line 349
  blosum50mt[83] = (short)-4;
#line 349
  blosum50mt[84] = (short)0;
#line 349
  blosum50mt[85] = (short)1;
#line 349
  blosum50mt[86] = (short)-3;
#line 349
  blosum50mt[87] = (short)0;
#line 349
  blosum50mt[88] = (short)-4;
#line 349
  blosum50mt[89] = (short)-2;
#line 349
  blosum50mt[90] = (short)7;
#line 349
  blosum50mt[91] = (short)-1;
#line 349
  blosum50mt[92] = (short)-2;
#line 349
  blosum50mt[93] = (short)-4;
#line 349
  blosum50mt[94] = (short)-1;
#line 349
  blosum50mt[95] = (short)-1;
#line 349
  blosum50mt[96] = (short)-4;
#line 349
  blosum50mt[97] = (short)-2;
#line 349
  blosum50mt[98] = (short)-2;
#line 349
  blosum50mt[99] = (short)-3;
#line 349
  blosum50mt[100] = (short)-1;
#line 349
  blosum50mt[101] = (short)-4;
#line 349
  blosum50mt[102] = (short)-3;
#line 349
  blosum50mt[103] = (short)-2;
#line 349
  blosum50mt[104] = (short)10;
#line 349
  blosum50mt[105] = (short)-1;
#line 349
  blosum50mt[106] = (short)0;
#line 349
  blosum50mt[107] = (short)-3;
#line 349
  blosum50mt[108] = (short)0;
#line 349
  blosum50mt[109] = (short)2;
#line 349
  blosum50mt[110] = (short)-4;
#line 349
  blosum50mt[111] = (short)-2;
#line 349
  blosum50mt[112] = (short)1;
#line 349
  blosum50mt[113] = (short)-3;
#line 349
  blosum50mt[114] = (short)2;
#line 349
  blosum50mt[115] = (short)-2;
#line 349
  blosum50mt[116] = (short)0;
#line 349
  blosum50mt[117] = (short)0;
#line 349
  blosum50mt[118] = (short)-1;
#line 349
  blosum50mt[119] = (short)7;
#line 349
  blosum50mt[120] = (short)-2;
#line 349
  blosum50mt[121] = (short)-1;
#line 349
  blosum50mt[122] = (short)-4;
#line 349
  blosum50mt[123] = (short)-2;
#line 349
  blosum50mt[124] = (short)0;
#line 349
  blosum50mt[125] = (short)-3;
#line 349
  blosum50mt[126] = (short)-3;
#line 349
  blosum50mt[127] = (short)0;
#line 349
  blosum50mt[128] = (short)-4;
#line 349
  blosum50mt[129] = (short)3;
#line 349
  blosum50mt[130] = (short)-3;
#line 349
  blosum50mt[131] = (short)-2;
#line 349
  blosum50mt[132] = (short)-1;
#line 349
  blosum50mt[133] = (short)-3;
#line 349
  blosum50mt[134] = (short)1;
#line 349
  blosum50mt[135] = (short)7;
#line 349
  blosum50mt[136] = (short)1;
#line 349
  blosum50mt[137] = (short)0;
#line 349
  blosum50mt[138] = (short)-1;
#line 349
  blosum50mt[139] = (short)0;
#line 349
  blosum50mt[140] = (short)-1;
#line 349
  blosum50mt[141] = (short)-3;
#line 349
  blosum50mt[142] = (short)0;
#line 349
  blosum50mt[143] = (short)-1;
#line 349
  blosum50mt[144] = (short)-3;
#line 349
  blosum50mt[145] = (short)0;
#line 349
  blosum50mt[146] = (short)-3;
#line 349
  blosum50mt[147] = (short)-2;
#line 349
  blosum50mt[148] = (short)1;
#line 349
  blosum50mt[149] = (short)-1;
#line 349
  blosum50mt[150] = (short)0;
#line 349
  blosum50mt[151] = (short)-1;
#line 349
  blosum50mt[152] = (short)5;
#line 349
  blosum50mt[153] = (short)0;
#line 349
  blosum50mt[154] = (short)0;
#line 349
  blosum50mt[155] = (short)-1;
#line 349
  blosum50mt[156] = (short)-1;
#line 349
  blosum50mt[157] = (short)-1;
#line 349
  blosum50mt[158] = (short)-2;
#line 349
  blosum50mt[159] = (short)-2;
#line 349
  blosum50mt[160] = (short)-2;
#line 349
  blosum50mt[161] = (short)-1;
#line 349
  blosum50mt[162] = (short)-1;
#line 349
  blosum50mt[163] = (short)-1;
#line 349
  blosum50mt[164] = (short)-1;
#line 349
  blosum50mt[165] = (short)0;
#line 349
  blosum50mt[166] = (short)-1;
#line 349
  blosum50mt[167] = (short)-1;
#line 349
  blosum50mt[168] = (short)-1;
#line 349
  blosum50mt[169] = (short)2;
#line 349
  blosum50mt[170] = (short)5;
#line 349
  blosum50mt[171] = (short)0;
#line 349
  blosum50mt[172] = (short)-4;
#line 349
  blosum50mt[173] = (short)-1;
#line 349
  blosum50mt[174] = (short)-4;
#line 349
  blosum50mt[175] = (short)-3;
#line 349
  blosum50mt[176] = (short)-1;
#line 349
  blosum50mt[177] = (short)-4;
#line 349
  blosum50mt[178] = (short)-4;
#line 349
  blosum50mt[179] = (short)4;
#line 349
  blosum50mt[180] = (short)-3;
#line 349
  blosum50mt[181] = (short)1;
#line 349
  blosum50mt[182] = (short)1;
#line 349
  blosum50mt[183] = (short)-3;
#line 349
  blosum50mt[184] = (short)-3;
#line 349
  blosum50mt[185] = (short)-3;
#line 349
  blosum50mt[186] = (short)-3;
#line 349
  blosum50mt[187] = (short)-2;
#line 349
  blosum50mt[188] = (short)0;
#line 349
  blosum50mt[189] = (short)5;
#line 349
  blosum50mt[190] = (short)-3;
#line 349
  blosum50mt[191] = (short)-5;
#line 349
  blosum50mt[192] = (short)-5;
#line 349
  blosum50mt[193] = (short)-5;
#line 349
  blosum50mt[194] = (short)-3;
#line 349
  blosum50mt[195] = (short)1;
#line 349
  blosum50mt[196] = (short)-3;
#line 349
  blosum50mt[197] = (short)-3;
#line 349
  blosum50mt[198] = (short)-3;
#line 349
  blosum50mt[199] = (short)-3;
#line 349
  blosum50mt[200] = (short)-2;
#line 349
  blosum50mt[201] = (short)-1;
#line 349
  blosum50mt[202] = (short)-4;
#line 349
  blosum50mt[203] = (short)-4;
#line 349
  blosum50mt[204] = (short)-1;
#line 349
  blosum50mt[205] = (short)-3;
#line 349
  blosum50mt[206] = (short)-4;
#line 349
  blosum50mt[207] = (short)-3;
#line 349
  blosum50mt[208] = (short)-3;
#line 349
  blosum50mt[209] = (short)15;
#line 349
  blosum50mt[210] = (short)-1;
#line 349
  blosum50mt[211] = (short)-1;
#line 349
  blosum50mt[212] = (short)-2;
#line 349
  blosum50mt[213] = (short)-1;
#line 349
  blosum50mt[214] = (short)-1;
#line 349
  blosum50mt[215] = (short)-2;
#line 349
  blosum50mt[216] = (short)-2;
#line 349
  blosum50mt[217] = (short)-1;
#line 349
  blosum50mt[218] = (short)-1;
#line 349
  blosum50mt[219] = (short)-1;
#line 349
  blosum50mt[220] = (short)-1;
#line 349
  blosum50mt[221] = (short)-1;
#line 349
  blosum50mt[222] = (short)-1;
#line 349
  blosum50mt[223] = (short)-2;
#line 349
  blosum50mt[224] = (short)-1;
#line 349
  blosum50mt[225] = (short)-1;
#line 349
  blosum50mt[226] = (short)-1;
#line 349
  blosum50mt[227] = (short)0;
#line 349
  blosum50mt[228] = (short)-1;
#line 349
  blosum50mt[229] = (short)-3;
#line 349
  blosum50mt[230] = (short)-1;
#line 349
  blosum50mt[231] = (short)-2;
#line 349
  blosum50mt[232] = (short)-3;
#line 349
  blosum50mt[233] = (short)-3;
#line 349
  blosum50mt[234] = (short)-3;
#line 349
  blosum50mt[235] = (short)-2;
#line 349
  blosum50mt[236] = (short)4;
#line 349
  blosum50mt[237] = (short)-3;
#line 349
  blosum50mt[238] = (short)2;
#line 349
  blosum50mt[239] = (short)-1;
#line 349
  blosum50mt[240] = (short)-2;
#line 349
  blosum50mt[241] = (short)-1;
#line 349
  blosum50mt[242] = (short)0;
#line 349
  blosum50mt[243] = (short)-2;
#line 349
  blosum50mt[244] = (short)-3;
#line 349
  blosum50mt[245] = (short)-1;
#line 349
  blosum50mt[246] = (short)-1;
#line 349
  blosum50mt[247] = (short)-2;
#line 349
  blosum50mt[248] = (short)-2;
#line 349
  blosum50mt[249] = (short)-1;
#line 349
  blosum50mt[250] = (short)2;
#line 349
  blosum50mt[251] = (short)-1;
#line 349
  blosum50mt[252] = (short)8;
#line 349
  blosum50mt[253] = (short)-1;
#line 349
  blosum50mt[254] = (short)2;
#line 349
  blosum50mt[255] = (short)-3;
#line 349
  blosum50mt[256] = (short)1;
#line 349
  blosum50mt[257] = (short)5;
#line 349
  blosum50mt[258] = (short)-4;
#line 349
  blosum50mt[259] = (short)-2;
#line 349
  blosum50mt[260] = (short)0;
#line 349
  blosum50mt[261] = (short)-3;
#line 349
  blosum50mt[262] = (short)1;
#line 349
  blosum50mt[263] = (short)-3;
#line 349
  blosum50mt[264] = (short)-1;
#line 349
  blosum50mt[265] = (short)0;
#line 349
  blosum50mt[266] = (short)-1;
#line 349
  blosum50mt[267] = (short)4;
#line 349
  blosum50mt[268] = (short)0;
#line 349
  blosum50mt[269] = (short)0;
#line 349
  blosum50mt[270] = (short)-1;
#line 349
  blosum50mt[271] = (short)-3;
#line 349
  blosum50mt[272] = (short)-2;
#line 349
  blosum50mt[273] = (short)-1;
#line 349
  blosum50mt[274] = (short)-2;
#line 349
  blosum50mt[275] = (short)5;
#line 374
  blosum62mt[0] = (short)40;
#line 374
  blosum62mt[1] = (short)-20;
#line 374
  blosum62mt[2] = (short)40;
#line 374
  blosum62mt[3] = (short)0;
#line 374
  blosum62mt[4] = (short)-30;
#line 374
  blosum62mt[5] = (short)90;
#line 374
  blosum62mt[6] = (short)-20;
#line 374
  blosum62mt[7] = (short)40;
#line 374
  blosum62mt[8] = (short)-30;
#line 374
  blosum62mt[9] = (short)60;
#line 374
  blosum62mt[10] = (short)-10;
#line 374
  blosum62mt[11] = (short)10;
#line 374
  blosum62mt[12] = (short)-40;
#line 374
  blosum62mt[13] = (short)20;
#line 374
  blosum62mt[14] = (short)50;
#line 374
  blosum62mt[15] = (short)-20;
#line 374
  blosum62mt[16] = (short)-30;
#line 374
  blosum62mt[17] = (short)-20;
#line 374
  blosum62mt[18] = (short)-30;
#line 374
  blosum62mt[19] = (short)-30;
#line 374
  blosum62mt[20] = (short)60;
#line 374
  blosum62mt[21] = (short)0;
#line 374
  blosum62mt[22] = (short)-10;
#line 374
  blosum62mt[23] = (short)-30;
#line 374
  blosum62mt[24] = (short)-10;
#line 374
  blosum62mt[25] = (short)-20;
#line 374
  blosum62mt[26] = (short)-30;
#line 374
  blosum62mt[27] = (short)60;
#line 374
  blosum62mt[28] = (short)-20;
#line 374
  blosum62mt[29] = (short)0;
#line 374
  blosum62mt[30] = (short)-30;
#line 374
  blosum62mt[31] = (short)-10;
#line 374
  blosum62mt[32] = (short)0;
#line 374
  blosum62mt[33] = (short)-10;
#line 374
  blosum62mt[34] = (short)-20;
#line 374
  blosum62mt[35] = (short)80;
#line 374
  blosum62mt[36] = (short)-10;
#line 374
  blosum62mt[37] = (short)-30;
#line 374
  blosum62mt[38] = (short)-10;
#line 374
  blosum62mt[39] = (short)-30;
#line 374
  blosum62mt[40] = (short)-30;
#line 374
  blosum62mt[41] = (short)0;
#line 374
  blosum62mt[42] = (short)-40;
#line 374
  blosum62mt[43] = (short)-30;
#line 374
  blosum62mt[44] = (short)40;
#line 374
  blosum62mt[45] = (short)-10;
#line 374
  blosum62mt[46] = (short)0;
#line 374
  blosum62mt[47] = (short)-30;
#line 374
  blosum62mt[48] = (short)-10;
#line 374
  blosum62mt[49] = (short)10;
#line 374
  blosum62mt[50] = (short)-30;
#line 374
  blosum62mt[51] = (short)-20;
#line 374
  blosum62mt[52] = (short)-10;
#line 374
  blosum62mt[53] = (short)-30;
#line 374
  blosum62mt[54] = (short)50;
#line 374
  blosum62mt[55] = (short)-10;
#line 374
  blosum62mt[56] = (short)-40;
#line 374
  blosum62mt[57] = (short)-10;
#line 374
  blosum62mt[58] = (short)-40;
#line 374
  blosum62mt[59] = (short)-30;
#line 374
  blosum62mt[60] = (short)0;
#line 374
  blosum62mt[61] = (short)-40;
#line 374
  blosum62mt[62] = (short)-30;
#line 374
  blosum62mt[63] = (short)20;
#line 374
  blosum62mt[64] = (short)-20;
#line 374
  blosum62mt[65] = (short)40;
#line 374
  blosum62mt[66] = (short)-10;
#line 374
  blosum62mt[67] = (short)-30;
#line 374
  blosum62mt[68] = (short)-10;
#line 374
  blosum62mt[69] = (short)-30;
#line 374
  blosum62mt[70] = (short)-20;
#line 374
  blosum62mt[71] = (short)0;
#line 374
  blosum62mt[72] = (short)-30;
#line 374
  blosum62mt[73] = (short)-20;
#line 374
  blosum62mt[74] = (short)10;
#line 374
  blosum62mt[75] = (short)-10;
#line 374
  blosum62mt[76] = (short)20;
#line 374
  blosum62mt[77] = (short)50;
#line 374
  blosum62mt[78] = (short)-20;
#line 374
  blosum62mt[79] = (short)30;
#line 374
  blosum62mt[80] = (short)-30;
#line 374
  blosum62mt[81] = (short)10;
#line 374
  blosum62mt[82] = (short)0;
#line 374
  blosum62mt[83] = (short)-30;
#line 374
  blosum62mt[84] = (short)0;
#line 374
  blosum62mt[85] = (short)10;
#line 374
  blosum62mt[86] = (short)-30;
#line 374
  blosum62mt[87] = (short)0;
#line 374
  blosum62mt[88] = (short)-30;
#line 374
  blosum62mt[89] = (short)-20;
#line 374
  blosum62mt[90] = (short)60;
#line 374
  blosum62mt[91] = (short)-10;
#line 374
  blosum62mt[92] = (short)-20;
#line 374
  blosum62mt[93] = (short)-30;
#line 374
  blosum62mt[94] = (short)-10;
#line 374
  blosum62mt[95] = (short)-10;
#line 374
  blosum62mt[96] = (short)-40;
#line 374
  blosum62mt[97] = (short)-20;
#line 374
  blosum62mt[98] = (short)-20;
#line 374
  blosum62mt[99] = (short)-30;
#line 374
  blosum62mt[100] = (short)-10;
#line 374
  blosum62mt[101] = (short)-30;
#line 374
  blosum62mt[102] = (short)-20;
#line 374
  blosum62mt[103] = (short)-20;
#line 374
  blosum62mt[104] = (short)70;
#line 374
  blosum62mt[105] = (short)-10;
#line 374
  blosum62mt[106] = (short)0;
#line 374
  blosum62mt[107] = (short)-30;
#line 374
  blosum62mt[108] = (short)0;
#line 374
  blosum62mt[109] = (short)20;
#line 374
  blosum62mt[110] = (short)-30;
#line 374
  blosum62mt[111] = (short)-20;
#line 374
  blosum62mt[112] = (short)0;
#line 374
  blosum62mt[113] = (short)-30;
#line 374
  blosum62mt[114] = (short)10;
#line 374
  blosum62mt[115] = (short)-20;
#line 374
  blosum62mt[116] = (short)0;
#line 374
  blosum62mt[117] = (short)0;
#line 374
  blosum62mt[118] = (short)-10;
#line 374
  blosum62mt[119] = (short)50;
#line 374
  blosum62mt[120] = (short)-10;
#line 374
  blosum62mt[121] = (short)-10;
#line 374
  blosum62mt[122] = (short)-30;
#line 374
  blosum62mt[123] = (short)-20;
#line 374
  blosum62mt[124] = (short)0;
#line 374
  blosum62mt[125] = (short)-30;
#line 374
  blosum62mt[126] = (short)-20;
#line 374
  blosum62mt[127] = (short)0;
#line 374
  blosum62mt[128] = (short)-30;
#line 374
  blosum62mt[129] = (short)20;
#line 374
  blosum62mt[130] = (short)-20;
#line 374
  blosum62mt[131] = (short)-10;
#line 374
  blosum62mt[132] = (short)0;
#line 374
  blosum62mt[133] = (short)-20;
#line 374
  blosum62mt[134] = (short)10;
#line 374
  blosum62mt[135] = (short)50;
#line 374
  blosum62mt[136] = (short)10;
#line 374
  blosum62mt[137] = (short)0;
#line 374
  blosum62mt[138] = (short)-10;
#line 374
  blosum62mt[139] = (short)0;
#line 374
  blosum62mt[140] = (short)0;
#line 374
  blosum62mt[141] = (short)-20;
#line 374
  blosum62mt[142] = (short)0;
#line 374
  blosum62mt[143] = (short)-10;
#line 374
  blosum62mt[144] = (short)-20;
#line 374
  blosum62mt[145] = (short)0;
#line 374
  blosum62mt[146] = (short)-20;
#line 374
  blosum62mt[147] = (short)-10;
#line 374
  blosum62mt[148] = (short)10;
#line 374
  blosum62mt[149] = (short)-10;
#line 374
  blosum62mt[150] = (short)0;
#line 374
  blosum62mt[151] = (short)-10;
#line 374
  blosum62mt[152] = (short)40;
#line 374
  blosum62mt[153] = (short)0;
#line 374
  blosum62mt[154] = (short)-10;
#line 374
  blosum62mt[155] = (short)-10;
#line 374
  blosum62mt[156] = (short)-10;
#line 374
  blosum62mt[157] = (short)-10;
#line 374
  blosum62mt[158] = (short)-20;
#line 374
  blosum62mt[159] = (short)-20;
#line 374
  blosum62mt[160] = (short)-20;
#line 374
  blosum62mt[161] = (short)-10;
#line 374
  blosum62mt[162] = (short)-10;
#line 374
  blosum62mt[163] = (short)-10;
#line 374
  blosum62mt[164] = (short)-10;
#line 374
  blosum62mt[165] = (short)0;
#line 374
  blosum62mt[166] = (short)-10;
#line 374
  blosum62mt[167] = (short)-10;
#line 374
  blosum62mt[168] = (short)-10;
#line 374
  blosum62mt[169] = (short)10;
#line 374
  blosum62mt[170] = (short)50;
#line 374
  blosum62mt[171] = (short)0;
#line 374
  blosum62mt[172] = (short)-30;
#line 374
  blosum62mt[173] = (short)-10;
#line 374
  blosum62mt[174] = (short)-30;
#line 374
  blosum62mt[175] = (short)-20;
#line 374
  blosum62mt[176] = (short)-10;
#line 374
  blosum62mt[177] = (short)-30;
#line 374
  blosum62mt[178] = (short)-30;
#line 374
  blosum62mt[179] = (short)30;
#line 374
  blosum62mt[180] = (short)-20;
#line 374
  blosum62mt[181] = (short)10;
#line 374
  blosum62mt[182] = (short)10;
#line 374
  blosum62mt[183] = (short)-30;
#line 374
  blosum62mt[184] = (short)-20;
#line 374
  blosum62mt[185] = (short)-20;
#line 374
  blosum62mt[186] = (short)-30;
#line 374
  blosum62mt[187] = (short)-20;
#line 374
  blosum62mt[188] = (short)0;
#line 374
  blosum62mt[189] = (short)40;
#line 374
  blosum62mt[190] = (short)-30;
#line 374
  blosum62mt[191] = (short)-40;
#line 374
  blosum62mt[192] = (short)-20;
#line 374
  blosum62mt[193] = (short)-40;
#line 374
  blosum62mt[194] = (short)-30;
#line 374
  blosum62mt[195] = (short)10;
#line 374
  blosum62mt[196] = (short)-20;
#line 374
  blosum62mt[197] = (short)-20;
#line 374
  blosum62mt[198] = (short)-30;
#line 374
  blosum62mt[199] = (short)-30;
#line 374
  blosum62mt[200] = (short)-20;
#line 374
  blosum62mt[201] = (short)-10;
#line 374
  blosum62mt[202] = (short)-40;
#line 374
  blosum62mt[203] = (short)-40;
#line 374
  blosum62mt[204] = (short)-20;
#line 374
  blosum62mt[205] = (short)-30;
#line 374
  blosum62mt[206] = (short)-30;
#line 374
  blosum62mt[207] = (short)-20;
#line 374
  blosum62mt[208] = (short)-30;
#line 374
  blosum62mt[209] = (short)110;
#line 374
  blosum62mt[210] = (short)0;
#line 374
  blosum62mt[211] = (short)-10;
#line 374
  blosum62mt[212] = (short)-20;
#line 374
  blosum62mt[213] = (short)-10;
#line 374
  blosum62mt[214] = (short)-10;
#line 374
  blosum62mt[215] = (short)-10;
#line 374
  blosum62mt[216] = (short)-10;
#line 374
  blosum62mt[217] = (short)-10;
#line 374
  blosum62mt[218] = (short)-10;
#line 374
  blosum62mt[219] = (short)-10;
#line 374
  blosum62mt[220] = (short)-10;
#line 374
  blosum62mt[221] = (short)-10;
#line 374
  blosum62mt[222] = (short)-10;
#line 374
  blosum62mt[223] = (short)-20;
#line 374
  blosum62mt[224] = (short)-10;
#line 374
  blosum62mt[225] = (short)-10;
#line 374
  blosum62mt[226] = (short)0;
#line 374
  blosum62mt[227] = (short)0;
#line 374
  blosum62mt[228] = (short)-10;
#line 374
  blosum62mt[229] = (short)-20;
#line 374
  blosum62mt[230] = (short)-10;
#line 374
  blosum62mt[231] = (short)-20;
#line 374
  blosum62mt[232] = (short)-30;
#line 374
  blosum62mt[233] = (short)-20;
#line 374
  blosum62mt[234] = (short)-30;
#line 374
  blosum62mt[235] = (short)-20;
#line 374
  blosum62mt[236] = (short)30;
#line 374
  blosum62mt[237] = (short)-30;
#line 374
  blosum62mt[238] = (short)20;
#line 374
  blosum62mt[239] = (short)-10;
#line 374
  blosum62mt[240] = (short)-20;
#line 374
  blosum62mt[241] = (short)-10;
#line 374
  blosum62mt[242] = (short)-10;
#line 374
  blosum62mt[243] = (short)-20;
#line 374
  blosum62mt[244] = (short)-30;
#line 374
  blosum62mt[245] = (short)-10;
#line 374
  blosum62mt[246] = (short)-20;
#line 374
  blosum62mt[247] = (short)-20;
#line 374
  blosum62mt[248] = (short)-20;
#line 374
  blosum62mt[249] = (short)-10;
#line 374
  blosum62mt[250] = (short)20;
#line 374
  blosum62mt[251] = (short)-10;
#line 374
  blosum62mt[252] = (short)70;
#line 374
  blosum62mt[253] = (short)-10;
#line 374
  blosum62mt[254] = (short)10;
#line 374
  blosum62mt[255] = (short)-30;
#line 374
  blosum62mt[256] = (short)10;
#line 374
  blosum62mt[257] = (short)40;
#line 374
  blosum62mt[258] = (short)-30;
#line 374
  blosum62mt[259] = (short)-20;
#line 374
  blosum62mt[260] = (short)0;
#line 374
  blosum62mt[261] = (short)-30;
#line 374
  blosum62mt[262] = (short)10;
#line 374
  blosum62mt[263] = (short)-30;
#line 374
  blosum62mt[264] = (short)-10;
#line 374
  blosum62mt[265] = (short)0;
#line 374
  blosum62mt[266] = (short)-10;
#line 374
  blosum62mt[267] = (short)30;
#line 374
  blosum62mt[268] = (short)0;
#line 374
  blosum62mt[269] = (short)0;
#line 374
  blosum62mt[270] = (short)-10;
#line 374
  blosum62mt[271] = (short)-20;
#line 374
  blosum62mt[272] = (short)-30;
#line 374
  blosum62mt[273] = (short)-10;
#line 374
  blosum62mt[274] = (short)-20;
#line 374
  blosum62mt[275] = (short)40;
#line 399
  gon250mt[0] = (short)24;
#line 399
  gon250mt[1] = (short)0;
#line 399
  gon250mt[2] = (short)0;
#line 399
  gon250mt[3] = (short)5;
#line 399
  gon250mt[4] = (short)0;
#line 399
  gon250mt[5] = (short)115;
#line 399
  gon250mt[6] = (short)-3;
#line 399
  gon250mt[7] = (short)0;
#line 399
  gon250mt[8] = (short)-32;
#line 399
  gon250mt[9] = (short)47;
#line 399
  gon250mt[10] = (short)0;
#line 399
  gon250mt[11] = (short)0;
#line 399
  gon250mt[12] = (short)-30;
#line 399
  gon250mt[13] = (short)27;
#line 399
  gon250mt[14] = (short)36;
#line 399
  gon250mt[15] = (short)-23;
#line 399
  gon250mt[16] = (short)0;
#line 399
  gon250mt[17] = (short)-8;
#line 399
  gon250mt[18] = (short)-45;
#line 399
  gon250mt[19] = (short)-39;
#line 399
  gon250mt[20] = (short)70;
#line 399
  gon250mt[21] = (short)5;
#line 399
  gon250mt[22] = (short)0;
#line 399
  gon250mt[23] = (short)-20;
#line 399
  gon250mt[24] = (short)1;
#line 399
  gon250mt[25] = (short)-8;
#line 399
  gon250mt[26] = (short)-52;
#line 399
  gon250mt[27] = (short)66;
#line 399
  gon250mt[28] = (short)-8;
#line 399
  gon250mt[29] = (short)0;
#line 399
  gon250mt[30] = (short)-13;
#line 399
  gon250mt[31] = (short)4;
#line 399
  gon250mt[32] = (short)4;
#line 399
  gon250mt[33] = (short)-1;
#line 399
  gon250mt[34] = (short)-14;
#line 399
  gon250mt[35] = (short)60;
#line 399
  gon250mt[36] = (short)-8;
#line 399
  gon250mt[37] = (short)0;
#line 399
  gon250mt[38] = (short)-11;
#line 399
  gon250mt[39] = (short)-38;
#line 399
  gon250mt[40] = (short)-27;
#line 399
  gon250mt[41] = (short)10;
#line 399
  gon250mt[42] = (short)-45;
#line 399
  gon250mt[43] = (short)-22;
#line 399
  gon250mt[44] = (short)40;
#line 399
  gon250mt[45] = (short)-4;
#line 399
  gon250mt[46] = (short)0;
#line 399
  gon250mt[47] = (short)-28;
#line 399
  gon250mt[48] = (short)5;
#line 399
  gon250mt[49] = (short)12;
#line 399
  gon250mt[50] = (short)-33;
#line 399
  gon250mt[51] = (short)-11;
#line 399
  gon250mt[52] = (short)6;
#line 399
  gon250mt[53] = (short)-21;
#line 399
  gon250mt[54] = (short)32;
#line 399
  gon250mt[55] = (short)-12;
#line 399
  gon250mt[56] = (short)0;
#line 399
  gon250mt[57] = (short)-15;
#line 399
  gon250mt[58] = (short)-40;
#line 399
  gon250mt[59] = (short)-28;
#line 399
  gon250mt[60] = (short)20;
#line 399
  gon250mt[61] = (short)-44;
#line 399
  gon250mt[62] = (short)-19;
#line 399
  gon250mt[63] = (short)28;
#line 399
  gon250mt[64] = (short)-21;
#line 399
  gon250mt[65] = (short)40;
#line 399
  gon250mt[66] = (short)-7;
#line 399
  gon250mt[67] = (short)0;
#line 399
  gon250mt[68] = (short)-9;
#line 399
  gon250mt[69] = (short)-30;
#line 399
  gon250mt[70] = (short)-20;
#line 399
  gon250mt[71] = (short)16;
#line 399
  gon250mt[72] = (short)-35;
#line 399
  gon250mt[73] = (short)-13;
#line 399
  gon250mt[74] = (short)25;
#line 399
  gon250mt[75] = (short)-14;
#line 399
  gon250mt[76] = (short)28;
#line 399
  gon250mt[77] = (short)43;
#line 399
  gon250mt[78] = (short)-3;
#line 399
  gon250mt[79] = (short)0;
#line 399
  gon250mt[80] = (short)-18;
#line 399
  gon250mt[81] = (short)22;
#line 399
  gon250mt[82] = (short)9;
#line 399
  gon250mt[83] = (short)-31;
#line 399
  gon250mt[84] = (short)4;
#line 399
  gon250mt[85] = (short)12;
#line 399
  gon250mt[86] = (short)-28;
#line 399
  gon250mt[87] = (short)8;
#line 399
  gon250mt[88] = (short)-30;
#line 399
  gon250mt[89] = (short)-22;
#line 399
  gon250mt[90] = (short)38;
#line 399
  gon250mt[91] = (short)3;
#line 399
  gon250mt[92] = (short)0;
#line 399
  gon250mt[93] = (short)-31;
#line 399
  gon250mt[94] = (short)-7;
#line 399
  gon250mt[95] = (short)-5;
#line 399
  gon250mt[96] = (short)-38;
#line 399
  gon250mt[97] = (short)-16;
#line 399
  gon250mt[98] = (short)-11;
#line 399
  gon250mt[99] = (short)-26;
#line 399
  gon250mt[100] = (short)-6;
#line 399
  gon250mt[101] = (short)-23;
#line 399
  gon250mt[102] = (short)-24;
#line 399
  gon250mt[103] = (short)-9;
#line 399
  gon250mt[104] = (short)76;
#line 399
  gon250mt[105] = (short)-2;
#line 399
  gon250mt[106] = (short)0;
#line 399
  gon250mt[107] = (short)-24;
#line 399
  gon250mt[108] = (short)9;
#line 399
  gon250mt[109] = (short)17;
#line 399
  gon250mt[110] = (short)-26;
#line 399
  gon250mt[111] = (short)-10;
#line 399
  gon250mt[112] = (short)12;
#line 399
  gon250mt[113] = (short)-19;
#line 399
  gon250mt[114] = (short)15;
#line 399
  gon250mt[115] = (short)-16;
#line 399
  gon250mt[116] = (short)-10;
#line 399
  gon250mt[117] = (short)7;
#line 399
  gon250mt[118] = (short)-2;
#line 399
  gon250mt[119] = (short)27;
#line 399
  gon250mt[120] = (short)-6;
#line 399
  gon250mt[121] = (short)0;
#line 399
  gon250mt[122] = (short)-22;
#line 399
  gon250mt[123] = (short)-3;
#line 399
  gon250mt[124] = (short)4;
#line 399
  gon250mt[125] = (short)-32;
#line 399
  gon250mt[126] = (short)-10;
#line 399
  gon250mt[127] = (short)6;
#line 399
  gon250mt[128] = (short)-24;
#line 399
  gon250mt[129] = (short)27;
#line 399
  gon250mt[130] = (short)-22;
#line 399
  gon250mt[131] = (short)-17;
#line 399
  gon250mt[132] = (short)3;
#line 399
  gon250mt[133] = (short)-9;
#line 399
  gon250mt[134] = (short)15;
#line 399
  gon250mt[135] = (short)47;
#line 399
  gon250mt[136] = (short)11;
#line 399
  gon250mt[137] = (short)0;
#line 399
  gon250mt[138] = (short)1;
#line 399
  gon250mt[139] = (short)5;
#line 399
  gon250mt[140] = (short)2;
#line 399
  gon250mt[141] = (short)-28;
#line 399
  gon250mt[142] = (short)4;
#line 399
  gon250mt[143] = (short)-2;
#line 399
  gon250mt[144] = (short)-18;
#line 399
  gon250mt[145] = (short)1;
#line 399
  gon250mt[146] = (short)-21;
#line 399
  gon250mt[147] = (short)-14;
#line 399
  gon250mt[148] = (short)9;
#line 399
  gon250mt[149] = (short)4;
#line 399
  gon250mt[150] = (short)2;
#line 399
  gon250mt[151] = (short)-2;
#line 399
  gon250mt[152] = (short)22;
#line 399
  gon250mt[153] = (short)6;
#line 399
  gon250mt[154] = (short)0;
#line 399
  gon250mt[155] = (short)-5;
#line 399
  gon250mt[156] = (short)0;
#line 399
  gon250mt[157] = (short)-1;
#line 399
  gon250mt[158] = (short)-22;
#line 399
  gon250mt[159] = (short)-11;
#line 399
  gon250mt[160] = (short)-3;
#line 399
  gon250mt[161] = (short)-6;
#line 399
  gon250mt[162] = (short)1;
#line 399
  gon250mt[163] = (short)-13;
#line 399
  gon250mt[164] = (short)-6;
#line 399
  gon250mt[165] = (short)5;
#line 399
  gon250mt[166] = (short)1;
#line 399
  gon250mt[167] = (short)0;
#line 399
  gon250mt[168] = (short)-2;
#line 399
  gon250mt[169] = (short)15;
#line 399
  gon250mt[170] = (short)25;
#line 399
  gon250mt[171] = (short)1;
#line 399
  gon250mt[172] = (short)0;
#line 399
  gon250mt[173] = (short)0;
#line 399
  gon250mt[174] = (short)-29;
#line 399
  gon250mt[175] = (short)-19;
#line 399
  gon250mt[176] = (short)1;
#line 399
  gon250mt[177] = (short)-33;
#line 399
  gon250mt[178] = (short)-20;
#line 399
  gon250mt[179] = (short)31;
#line 399
  gon250mt[180] = (short)-17;
#line 399
  gon250mt[181] = (short)18;
#line 399
  gon250mt[182] = (short)16;
#line 399
  gon250mt[183] = (short)-22;
#line 399
  gon250mt[184] = (short)-18;
#line 399
  gon250mt[185] = (short)-15;
#line 399
  gon250mt[186] = (short)-20;
#line 399
  gon250mt[187] = (short)-10;
#line 399
  gon250mt[188] = (short)0;
#line 399
  gon250mt[189] = (short)34;
#line 399
  gon250mt[190] = (short)-36;
#line 399
  gon250mt[191] = (short)0;
#line 399
  gon250mt[192] = (short)-10;
#line 399
  gon250mt[193] = (short)-52;
#line 399
  gon250mt[194] = (short)-43;
#line 399
  gon250mt[195] = (short)36;
#line 399
  gon250mt[196] = (short)-40;
#line 399
  gon250mt[197] = (short)-8;
#line 399
  gon250mt[198] = (short)-18;
#line 399
  gon250mt[199] = (short)-35;
#line 399
  gon250mt[200] = (short)-7;
#line 399
  gon250mt[201] = (short)-10;
#line 399
  gon250mt[202] = (short)-36;
#line 399
  gon250mt[203] = (short)-50;
#line 399
  gon250mt[204] = (short)-27;
#line 399
  gon250mt[205] = (short)-16;
#line 399
  gon250mt[206] = (short)-33;
#line 399
  gon250mt[207] = (short)-35;
#line 399
  gon250mt[208] = (short)-26;
#line 399
  gon250mt[209] = (short)142;
#line 399
  gon250mt[210] = (short)0;
#line 399
  gon250mt[211] = (short)0;
#line 399
  gon250mt[212] = (short)0;
#line 399
  gon250mt[213] = (short)0;
#line 399
  gon250mt[214] = (short)0;
#line 399
  gon250mt[215] = (short)0;
#line 399
  gon250mt[216] = (short)0;
#line 399
  gon250mt[217] = (short)0;
#line 399
  gon250mt[218] = (short)0;
#line 399
  gon250mt[219] = (short)0;
#line 399
  gon250mt[220] = (short)0;
#line 399
  gon250mt[221] = (short)0;
#line 399
  gon250mt[222] = (short)0;
#line 399
  gon250mt[223] = (short)0;
#line 399
  gon250mt[224] = (short)0;
#line 399
  gon250mt[225] = (short)0;
#line 399
  gon250mt[226] = (short)0;
#line 399
  gon250mt[227] = (short)0;
#line 399
  gon250mt[228] = (short)0;
#line 399
  gon250mt[229] = (short)0;
#line 399
  gon250mt[230] = (short)0;
#line 399
  gon250mt[231] = (short)-22;
#line 399
  gon250mt[232] = (short)0;
#line 399
  gon250mt[233] = (short)-5;
#line 399
  gon250mt[234] = (short)-28;
#line 399
  gon250mt[235] = (short)-27;
#line 399
  gon250mt[236] = (short)51;
#line 399
  gon250mt[237] = (short)-40;
#line 399
  gon250mt[238] = (short)22;
#line 399
  gon250mt[239] = (short)-7;
#line 399
  gon250mt[240] = (short)-21;
#line 399
  gon250mt[241] = (short)0;
#line 399
  gon250mt[242] = (short)-2;
#line 399
  gon250mt[243] = (short)-14;
#line 399
  gon250mt[244] = (short)-31;
#line 399
  gon250mt[245] = (short)-17;
#line 399
  gon250mt[246] = (short)-18;
#line 399
  gon250mt[247] = (short)-19;
#line 399
  gon250mt[248] = (short)-19;
#line 399
  gon250mt[249] = (short)-11;
#line 399
  gon250mt[250] = (short)41;
#line 399
  gon250mt[251] = (short)0;
#line 399
  gon250mt[252] = (short)78;
#line 399
  gon250mt[253] = (short)0;
#line 399
  gon250mt[254] = (short)0;
#line 399
  gon250mt[255] = (short)0;
#line 399
  gon250mt[256] = (short)0;
#line 399
  gon250mt[257] = (short)0;
#line 399
  gon250mt[258] = (short)0;
#line 399
  gon250mt[259] = (short)0;
#line 399
  gon250mt[260] = (short)0;
#line 399
  gon250mt[261] = (short)0;
#line 399
  gon250mt[262] = (short)0;
#line 399
  gon250mt[263] = (short)0;
#line 399
  gon250mt[264] = (short)0;
#line 399
  gon250mt[265] = (short)0;
#line 399
  gon250mt[266] = (short)0;
#line 399
  gon250mt[267] = (short)0;
#line 399
  gon250mt[268] = (short)0;
#line 399
  gon250mt[269] = (short)0;
#line 399
  gon250mt[270] = (short)0;
#line 399
  gon250mt[271] = (short)0;
#line 399
  gon250mt[272] = (short)0;
#line 399
  gon250mt[273] = (short)0;
#line 399
  gon250mt[274] = (short)0;
#line 399
  gon250mt[275] = (short)0;
#line 423
  if (param->sub_matrix) {
    {
#line 424
    tmp = byg_start(param->sub_matrix, (char *)"blosum62BLOSUM62");
    }
#line 424
    if (tmp != -1) {
#line 425
      matrix_pointer = blosum62mt;
#line 433
      gpo = (float )55;
#line 434
      gpe = (float )8;
#line 435
      tgpe = (float )1;
    }
    {
#line 437
    tmp___0 = byg_start(param->sub_matrix, (char *)"blosum50BLOSUM50");
    }
#line 437
    if (tmp___0 != -1) {
#line 438
      matrix_pointer = blosum50mt;
#line 439
      m_pos = 0;
#line 440
      i = 0;
      {
#line 440
      while (1) {
        while_continue: /* CIL Label */ ;
#line 440
        if (! (i < 23)) {
#line 440
          goto while_break;
        }
#line 441
        j = 0;
        {
#line 441
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 441
          if (! (j <= i)) {
#line 441
            goto while_break___0;
          }
#line 442
          *(matrix_pointer + m_pos) = (short )((int )*(matrix_pointer + m_pos) * 10);
#line 443
          m_pos ++;
#line 441
          j ++;
        }
        while_break___0: /* CIL Label */ ;
        }
#line 440
        i ++;
      }
      while_break: /* CIL Label */ ;
      }
#line 446
      gpo = (float )55;
#line 447
      gpe = (float )8;
#line 448
      tgpe = (float )1;
    }
  } else
#line 453
  if (! param->dna) {
#line 455
    gpo = (float )54.94941;
#line 456
    gpe = (float )8.52492;
#line 457
    tgpe = (float )4.42410;
#line 464
    matrix_pointer = gon250mt;
  } else {
#line 475
    gpo = (float )217;
#line 476
    gpe = (float )39.4;
#line 477
    tgpe = (float )292.6;
#line 479
    param->zlevel = (float )61.08;
#line 480
    param->internal_gap_weight = (float )49.14;
  }
#line 484
  if (param->gpo != (float )-1) {
#line 486
    gpo = param->gpo;
  }
#line 488
  if (param->gpe != (float )-1) {
#line 490
    gpe = param->gpe;
  }
#line 492
  if (param->tgpe != (float )-1) {
#line 494
    tgpe = param->tgpe;
  }
#line 500
  if (param->secret == (float )-1) {
#line 501
    if (! param->dna) {
#line 502
      param->secret = (float )0.2;
    } else {
#line 504
      param->secret = (float )283.0;
    }
  }
  {
#line 510
  tmp___1 = malloc(sizeof(float *) * 32UL);
#line 510
  subm = (float **)tmp___1;
#line 511
  i = 32;
  }
  {
#line 511
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 511
    tmp___4 = i;
#line 511
    i --;
#line 511
    if (! tmp___4) {
#line 511
      goto while_break___1;
    }
    {
#line 512
    tmp___2 = malloc(sizeof(float ) * 32UL);
#line 512
    *(subm + i) = (float *)tmp___2;
#line 513
    j = 32;
    }
    {
#line 513
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 513
      tmp___3 = j;
#line 513
      j --;
#line 513
      if (! tmp___3) {
#line 513
        goto while_break___2;
      }
#line 514
      *(*(subm + i) + j) = param->secret;
    }
    while_break___2: /* CIL Label */ ;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 517
  if (param->dna) {
#line 528
    *(*(subm + 0) + 0) += (float )91;
#line 529
    *(*(subm + 0) + 1) += (float )-114;
#line 530
    *(*(subm + 0) + 2) += (float )-31;
#line 531
    *(*(subm + 0) + 3) += (float )-123;
#line 534
    *(*(subm + 1) + 0) += (float )-114;
#line 535
    *(*(subm + 1) + 1) += (float )100;
#line 536
    *(*(subm + 1) + 2) += (float )-125;
#line 537
    *(*(subm + 1) + 3) += (float )-31;
#line 540
    *(*(subm + 2) + 0) += (float )-31;
#line 541
    *(*(subm + 2) + 1) += (float )-125;
#line 542
    *(*(subm + 2) + 2) += (float )100;
#line 543
    *(*(subm + 2) + 3) += (float )-114;
#line 546
    *(*(subm + 3) + 0) += (float )-123;
#line 547
    *(*(subm + 3) + 1) += (float )-31;
#line 548
    *(*(subm + 3) + 2) += (float )-114;
#line 549
    *(*(subm + 3) + 3) += (float )91;
  } else {
#line 567
    m_pos = 0;
#line 568
    i = 0;
    {
#line 568
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 568
      if (! (i < 23)) {
#line 568
        goto while_break___3;
      }
#line 569
      j = 0;
      {
#line 569
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 569
        if (! (j <= i)) {
#line 569
          goto while_break___4;
        }
#line 570
        if (i == j) {
#line 572
          *(*(subm + i) + j) += (float )*(matrix_pointer + m_pos);
        } else {
#line 576
          *(*(subm + i) + j) += (float )*(matrix_pointer + m_pos);
#line 577
          *(*(subm + j) + i) += (float )*(matrix_pointer + m_pos);
        }
#line 579
        m_pos ++;
#line 569
        j ++;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 568
      i ++;
    }
    while_break___3: /* CIL Label */ ;
    }
  }
#line 590
  return (subm);
}
}
#line 593 "/home/june/repo/benchmarks/collector/temp/kalign-2.03+20110620/kalign2_misc.c"
struct alignment *make_seq(struct alignment *aln , int a , int b , int *path ) 
{ 
  int c ;
  int i ;
  int posa ;
  int posb ;
  int *gap_a ;
  int *gap_b ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 597
  posa = 0;
#line 598
  posb = 0;
#line 600
  gap_a = (int *)0;
#line 601
  gap_b = (int *)0;
#line 603
  tmp = malloc((unsigned long )(*(path + 0) + 1) * sizeof(int ));
#line 603
  gap_a = (int *)tmp;
#line 604
  tmp___0 = malloc((unsigned long )(*(path + 0) + 1) * sizeof(int ));
#line 604
  gap_b = (int *)tmp___0;
#line 606
  i = *(path + 0) + 1;
  }
  {
#line 606
  while (1) {
    while_continue: /* CIL Label */ ;
#line 606
    tmp___1 = i;
#line 606
    i --;
#line 606
    if (! tmp___1) {
#line 606
      goto while_break;
    }
#line 607
    *(gap_a + i) = 0;
#line 608
    *(gap_b + i) = 0;
  }
  while_break: /* CIL Label */ ;
  }
#line 610
  c = 1;
  {
#line 611
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 611
    if (! (*(path + c) != 3)) {
#line 611
      goto while_break___0;
    }
#line 612
    if (! *(path + c)) {
#line 613
      posa ++;
#line 614
      posb ++;
    }
#line 616
    if (*(path + c) & 1) {
#line 617
      (*(gap_a + posa)) ++;
#line 618
      posb ++;
    }
#line 620
    if (*(path + c) & 2) {
#line 621
      (*(gap_b + posb)) ++;
#line 622
      posa ++;
    }
#line 624
    c ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 626
  i = (int )*(aln->nsip + a);
  {
#line 626
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 626
    tmp___2 = i;
#line 626
    i --;
#line 626
    if (! tmp___2) {
#line 626
      goto while_break___1;
    }
    {
#line 627
    update_gaps((int )*(aln->sl + *(*(aln->sip + a) + i)), *(aln->s + *(*(aln->sip + a) + i)),
                *(path + 0), gap_a);
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 629
  i = (int )*(aln->nsip + b);
  {
#line 629
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 629
    tmp___3 = i;
#line 629
    i --;
#line 629
    if (! tmp___3) {
#line 629
      goto while_break___2;
    }
    {
#line 630
    update_gaps((int )*(aln->sl + *(*(aln->sip + b) + i)), *(aln->s + *(*(aln->sip + b) + i)),
                *(path + 0), gap_b);
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 632
  free((void *)gap_a);
#line 633
  free((void *)gap_b);
#line 634
  free((void *)path);
  }
#line 635
  return (aln);
}
}
#line 639 "/home/june/repo/benchmarks/collector/temp/kalign-2.03+20110620/kalign2_misc.c"
void update_gaps(int old_len , int *gis , int new_len , int *newgaps ) 
{ 
  unsigned int i ;
  unsigned int j ;
  int add ;
  int rel_pos ;

  {
#line 642
  add = 0;
#line 643
  rel_pos = 0;
#line 644
  i = 0U;
  {
#line 644
  while (1) {
    while_continue: /* CIL Label */ ;
#line 644
    if (! (i <= (unsigned int )old_len)) {
#line 644
      goto while_break;
    }
#line 645
    add = 0;
#line 646
    j = (unsigned int )rel_pos;
    {
#line 646
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 646
      if (! (j <= (unsigned int )(rel_pos + *(gis + i)))) {
#line 646
        goto while_break___0;
      }
#line 647
      if (*(newgaps + j) != 0) {
#line 648
        add += *(newgaps + j);
      }
#line 646
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 651
    rel_pos += *(gis + i) + 1;
#line 652
    *(gis + i) += add;
#line 644
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 654
  return;
}
}
#line 656 "/home/june/repo/benchmarks/collector/temp/kalign-2.03+20110620/kalign2_misc.c"
int *mirror_path(int *path ) 
{ 
  int c ;

  {
#line 658
  c = 1;
  {
#line 659
  while (1) {
    while_continue: /* CIL Label */ ;
#line 659
    if (! (*(path + c) != 3)) {
#line 659
      goto while_break;
    }
#line 660
    if (*(path + c) & 1) {
#line 661
      (*(path + c)) ++;
    } else
#line 662
    if (*(path + c) & 2) {
#line 663
      (*(path + c)) --;
    }
#line 665
    c ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 667
  return (path);
}
}
#line 670 "/home/june/repo/benchmarks/collector/temp/kalign-2.03+20110620/kalign2_misc.c"
struct node *insert(struct node *n , int pos ) 
{ 
  void *tmp ;

  {
#line 672
  if ((unsigned long )n == (unsigned long )((void *)0)) {
    {
#line 673
    tmp = malloc(sizeof(struct node ));
#line 673
    n = (struct node *)tmp;
#line 674
    n->next = (struct node *)0;
#line 675
    n->pos = pos;
    }
  } else {
    {
#line 677
    n->next = insert(n->next, pos);
    }
  }
#line 679
  return (n);
}
}
#line 682 "/home/june/repo/benchmarks/collector/temp/kalign-2.03+20110620/kalign2_misc.c"
struct bignode *big_insert_hash(struct bignode *n , unsigned int const   pos ) 
{ 
  struct bignode *p ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 684
  p = (struct bignode *)0;
#line 685
  if (n) {
#line 686
    if (n->num < 16U) {
#line 687
      n->pos[n->num] = (unsigned int )pos;
#line 688
      (n->num) ++;
#line 689
      return (n);
    } else {
      {
#line 691
      tmp = malloc(sizeof(struct bignode ));
#line 691
      p = (struct bignode *)tmp;
#line 692
      p->pos[0] = (unsigned int )pos;
#line 693
      p->num = 1U;
#line 694
      p->next = n;
      }
    }
  } else {
    {
#line 697
    tmp___0 = malloc(sizeof(struct bignode ));
#line 697
    p = (struct bignode *)tmp___0;
#line 698
    p->pos[0] = (unsigned int )pos;
#line 699
    p->num = 1U;
#line 700
    p->next = n;
    }
  }
#line 702
  return (p);
}
}
#line 705 "/home/june/repo/benchmarks/collector/temp/kalign-2.03+20110620/kalign2_misc.c"
void big_remove_nodes(struct bignode *n ) 
{ 
  struct bignode *p ;

  {
  {
#line 708
  while (1) {
    while_continue: /* CIL Label */ ;
#line 708
    if (! n) {
#line 708
      goto while_break;
    }
    {
#line 709
    p = n;
#line 710
    n = n->next;
#line 711
    free((void *)p);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 713
  return;
}
}
#line 715 "/home/june/repo/benchmarks/collector/temp/kalign-2.03+20110620/kalign2_misc.c"
void big_print_nodes(struct bignode *n ) 
{ 
  int i ;

  {
  {
#line 718
  while (1) {
    while_continue: /* CIL Label */ ;
#line 718
    if (! n) {
#line 718
      goto while_break;
    }
#line 719
    i = 0;
    {
#line 719
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 719
      if (! ((unsigned int )i < n->num)) {
#line 719
        goto while_break___0;
      }
      {
#line 720
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%d ",
              n->pos[i]);
#line 719
      i ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 722
    n = n->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 724
  return;
}
}
#line 726 "/home/june/repo/benchmarks/collector/temp/kalign-2.03+20110620/kalign2_misc.c"
struct node *insert_hash(struct node *n , int pos ) 
{ 
  struct node *p ;
  void *tmp ;

  {
  {
#line 729
  tmp = malloc(sizeof(struct node ));
#line 729
  p = (struct node *)tmp;
#line 730
  p->pos = pos;
#line 731
  p->next = n;
  }
#line 732
  return (p);
}
}
#line 735 "/home/june/repo/benchmarks/collector/temp/kalign-2.03+20110620/kalign2_misc.c"
void remove_nodes(struct node *n ) 
{ 
  struct node *p ;

  {
  {
#line 738
  while (1) {
    while_continue: /* CIL Label */ ;
#line 738
    if (! n) {
#line 738
      goto while_break;
    }
    {
#line 739
    p = n;
#line 740
    n = n->next;
#line 741
    free((void *)p);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 743
  return;
}
}
#line 775 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) abs)(int __x )  __attribute__((__const__)) ;
#line 360 "/home/june/repo/benchmarks/collector/temp/kalign-2.03+20110620/kalign2.h"
struct hirsch_mem *hirsch_mem_alloc(struct hirsch_mem *hm , int x ) ;
#line 361
struct hirsch_mem *hirsch_mem_realloc(struct hirsch_mem *hm , int x ) ;
#line 362
void hirsch_mem_free(struct hirsch_mem *hm ) ;
#line 364
int *mirror_hirsch_path(int *hirsch_path , int len_a , int len_b ) ;
#line 365
int *add_gap_info_to_hirsch_path(int *hirsch_path , int len_a , int len_b ) ;
#line 26 "/home/june/repo/benchmarks/collector/temp/kalign-2.03+20110620/kalign2_advanced_gaps.h"
void advanced_smooth_gaps(float *prof , int len , int window , float strength ) ;
#line 27
float *advanced_make_profile(float *prof , int *seq , int len , float **subm ) ;
#line 28
float *advanced_update(float const   *profa , float const   *profb , float *newp ,
                       int *path , int sipa , int sipb , float internal_gap_weight ) ;
#line 31
int *advanced_hirsch_pp_dyn(float const   *prof1 , float const   *prof2 , struct hirsch_mem *hm ,
                            int *hirsch_path ) ;
#line 32
int *advanced_hirsch_align_two_pp_vector(float const   *prof1 , float const   *prof2 ,
                                         struct hirsch_mem *hm , int *hirsch_path ,
                                         float *input_states , int *old_cor ) ;
#line 33
struct states *advanced_foward_hirsch_pp_dyn(float const   *prof1 , float const   *prof2 ,
                                             struct hirsch_mem *hm ) ;
#line 34
struct states *advanced_backward_hirsch_pp_dyn(float const   *prof1 , float const   *prof2 ,
                                               struct hirsch_mem *hm ) ;
#line 30 "/home/june/repo/benchmarks/collector/temp/kalign-2.03+20110620/kalign2_advanced_gaps.c"
int **advanced_hirschberg_alignment(struct alignment *aln , int *tree , float **submatrix ,
                                    int **map , int window , float strength , float internal_gap_weight ) 
{ 
  struct hirsch_mem *hm ;
  int i ;
  int j ;
  int g ;
  int a ;
  int b ;
  int c ;
  int len_a ;
  int len_b ;
  float **profile ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
  {
#line 32
  hm = (struct hirsch_mem *)0;
#line 36
  profile = (float **)0;
#line 38
  tmp = malloc(sizeof(float *) * (unsigned long )numprofiles);
#line 38
  profile = (float **)tmp;
#line 39
  i = 0;
  }
  {
#line 39
  while (1) {
    while_continue: /* CIL Label */ ;
#line 39
    if (! ((unsigned int )i < numprofiles)) {
#line 39
      goto while_break;
    }
#line 40
    *(profile + i) = (float *)0;
#line 39
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 43
  tmp___0 = malloc(sizeof(int *) * (unsigned long )numprofiles);
#line 43
  map = (int **)tmp___0;
#line 44
  i = 0;
  }
  {
#line 44
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 44
    if (! ((unsigned int )i < numprofiles)) {
#line 44
      goto while_break___0;
    }
#line 45
    *(map + i) = (int *)0;
#line 44
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 48
  hm = hirsch_mem_alloc(hm, 1024);
#line 50
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\nAlignment:\n");
#line 52
  i = 0;
  }
  {
#line 52
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 52
    if (! ((unsigned int )i < numseq - 1U)) {
#line 52
      goto while_break___1;
    }
    {
#line 53
    a = *(tree + i * 3);
#line 54
    b = *(tree + (i * 3 + 1));
#line 55
    c = *(tree + (i * 3 + 2));
#line 56
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\r%8.0f percent done",
            (double )(((float )i / (float )numseq) * (float )100));
#line 58
    len_a = (int )*(aln->sl + a);
#line 59
    len_b = (int )*(aln->sl + b);
    }
#line 62
    if (len_a > len_b) {
#line 62
      g = len_a;
    } else {
#line 62
      g = len_b;
    }
    {
#line 63
    tmp___1 = malloc(sizeof(int ) * (unsigned long )(g + 2));
#line 63
    *(map + c) = (int *)tmp___1;
    }
#line 64
    if (g > hm->size) {
      {
#line 65
      hm = hirsch_mem_realloc(hm, g);
      }
    }
#line 68
    j = 0;
    {
#line 68
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 68
      if (! (j < g + 2)) {
#line 68
        goto while_break___2;
      }
#line 70
      *(*(map + c) + j) = -1;
#line 68
      j ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 76
    if ((unsigned int )a < numseq) {
      {
#line 77
      *(profile + a) = advanced_make_profile(*(profile + a), *(aln->s + a), len_a,
                                             submatrix);
      }
    }
#line 79
    if ((unsigned int )b < numseq) {
      {
#line 80
      *(profile + b) = advanced_make_profile(*(profile + b), *(aln->s + b), len_b,
                                             submatrix);
      }
    }
    {
#line 86
    advanced_smooth_gaps(*(profile + a), len_a, window, strength);
#line 90
    advanced_smooth_gaps(*(profile + b), len_b, window, strength);
#line 92
    hm->starta = 0;
#line 93
    hm->startb = 0;
#line 94
    hm->enda = len_a;
#line 95
    hm->endb = len_b;
#line 96
    hm->len_a = len_a;
#line 97
    hm->len_b = len_b;
#line 99
    (hm->f + 0)->a = (float )0.0;
#line 100
    (hm->f + 0)->ga = - 3.40282346638528859812e+38F;
#line 101
    (hm->f + 0)->gb = - 3.40282346638528859812e+38F;
#line 102
    (hm->b + 0)->a = (float )0.0;
#line 103
    (hm->b + 0)->ga = - 3.40282346638528859812e+38F;
#line 104
    (hm->b + 0)->gb = - 3.40282346638528859812e+38F;
    }
#line 106
    if (len_a < len_b) {
      {
#line 107
      *(map + c) = advanced_hirsch_pp_dyn((float const   *)*(profile + a), (float const   *)*(profile + b),
                                          hm, *(map + c));
      }
    } else {
      {
#line 109
      hm->enda = len_b;
#line 110
      hm->endb = len_a;
#line 111
      hm->len_a = len_b;
#line 112
      hm->len_b = len_a;
#line 113
      *(map + c) = advanced_hirsch_pp_dyn((float const   *)*(profile + b), (float const   *)*(profile + a),
                                          hm, *(map + c));
#line 114
      *(map + c) = mirror_hirsch_path(*(map + c), len_a, len_b);
      }
    }
    {
#line 117
    *(map + c) = add_gap_info_to_hirsch_path(*(map + c), len_a, len_b);
    }
#line 119
    if ((unsigned int )i != numseq - 2U) {
      {
#line 120
      tmp___2 = malloc((sizeof(float ) * 64UL) * (unsigned long )(*(*(map + c) + 0) + 2));
#line 120
      *(profile + c) = (float *)tmp___2;
#line 121
      *(profile + c) = advanced_update((float const   *)*(profile + a), (float const   *)*(profile + b),
                                       *(profile + c), *(map + c), (int )*(aln->nsip + a),
                                       (int )*(aln->nsip + b), internal_gap_weight);
      }
    }
    {
#line 124
    *(aln->sl + c) = (unsigned int )*(*(map + c) + 0);
#line 126
    *(aln->nsip + c) = *(aln->nsip + a) + *(aln->nsip + b);
#line 127
    tmp___3 = malloc(sizeof(int ) * (unsigned long )(*(aln->nsip + a) + *(aln->nsip + b)));
#line 127
    *(aln->sip + c) = (unsigned int *)tmp___3;
#line 128
    g = 0;
#line 129
    j = (int )*(aln->nsip + a);
    }
    {
#line 129
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 129
      tmp___4 = j;
#line 129
      j --;
#line 129
      if (! tmp___4) {
#line 129
        goto while_break___3;
      }
#line 130
      *(*(aln->sip + c) + g) = *(*(aln->sip + a) + j);
#line 131
      g ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 133
    j = (int )*(aln->nsip + b);
    {
#line 133
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 133
      tmp___5 = j;
#line 133
      j --;
#line 133
      if (! tmp___5) {
#line 133
        goto while_break___4;
      }
#line 134
      *(*(aln->sip + c) + g) = *(*(aln->sip + b) + j);
#line 135
      g ++;
    }
    while_break___4: /* CIL Label */ ;
    }
    {
#line 138
    free((void *)*(profile + a));
#line 139
    free((void *)*(profile + b));
#line 52
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 141
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\r%8.0f percent done\n",
          100.0);
#line 142
  free((void *)profile);
#line 143
  hirsch_mem_free(hm);
#line 144
  i = 32;
  }
  {
#line 144
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 144
    tmp___6 = i;
#line 144
    i --;
#line 144
    if (! tmp___6) {
#line 144
      goto while_break___5;
    }
    {
#line 145
    free((void *)*(submatrix + i));
    }
  }
  while_break___5: /* CIL Label */ ;
  }
  {
#line 147
  free((void *)submatrix);
  }
#line 148
  return (map);
}
}
#line 152 "/home/june/repo/benchmarks/collector/temp/kalign-2.03+20110620/kalign2_advanced_gaps.c"
float *advanced_make_profile(float *prof , int *seq , int len , float **subm ) 
{ 
  int i ;
  int j ;
  int c ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 155
  tmp = malloc((sizeof(float ) * (unsigned long )(len + 2)) * 64UL);
#line 155
  prof = (float *)tmp;
#line 156
  prof += 64 * (len + 1);
#line 158
  i = 0;
  }
  {
#line 158
  while (1) {
    while_continue: /* CIL Label */ ;
#line 158
    if (! (i < 64)) {
#line 158
      goto while_break;
    }
#line 159
    *(prof + i) = (float )0;
#line 158
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 161
  *(prof + 55) = - gpo;
#line 162
  *(prof + 56) = - gpe;
#line 163
  *(prof + 57) = - tgpe;
#line 164
  *(prof + 26) = (float )1;
#line 167
  i = len;
  {
#line 168
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 168
    tmp___1 = i;
#line 168
    i --;
#line 168
    if (! tmp___1) {
#line 168
      goto while_break___0;
    }
#line 169
    prof -= 64;
#line 171
    j = 0;
    {
#line 171
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 171
      if (! (j < 64)) {
#line 171
        goto while_break___1;
      }
#line 172
      *(prof + j) = (float )0;
#line 171
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 174
    *(prof + 26) = (float )1;
#line 175
    c = *(seq + i);
#line 177
    *(prof + c) = (float )((double )*(prof + c) + 1.0);
#line 179
    prof += 32;
#line 181
    j = 23;
    {
#line 181
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 181
      tmp___0 = j;
#line 181
      j --;
#line 181
      if (! tmp___0) {
#line 181
        goto while_break___2;
      }
#line 182
      *(prof + j) = *(*(subm + c) + j);
    }
    while_break___2: /* CIL Label */ ;
    }
#line 184
    *(prof + 23) = - gpo;
#line 185
    *(prof + 24) = - gpe;
#line 186
    *(prof + 25) = - tgpe;
#line 188
    prof -= 32;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 190
  prof -= 64;
#line 191
  i = 0;
  {
#line 191
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 191
    if (! (i < 64)) {
#line 191
      goto while_break___3;
    }
#line 192
    *(prof + i) = (float )0;
#line 191
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 195
  *(prof + 55) = - gpo;
#line 196
  *(prof + 56) = - gpe;
#line 197
  *(prof + 57) = - tgpe;
#line 198
  *(prof + 26) = (float )1;
#line 199
  return (prof);
}
}
#line 204 "/home/june/repo/benchmarks/collector/temp/kalign-2.03+20110620/kalign2_advanced_gaps.c"
void advanced_smooth_gaps(float *prof , int len , int window , float strength ) 
{ 
  float tmp_gpo ;
  float tmp_gpe ;
  float tmp_tgpe ;
  int i ;
  int j ;

  {
#line 210
  if (! (window & 1)) {
#line 211
    window --;
  }
#line 213
  i = window / 2;
  {
#line 213
  while (1) {
    while_continue: /* CIL Label */ ;
#line 213
    if (! (i < len - window / 2)) {
#line 213
      goto while_break;
    }
#line 214
    tmp_gpo = (float )0.0;
#line 215
    tmp_gpe = (float )0.0;
#line 216
    tmp_tgpe = (float )0.0;
#line 217
    j = - (window / 2);
    {
#line 217
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 217
      if (! (j < window / 2)) {
#line 217
        goto while_break___0;
      }
#line 218
      tmp_gpo += *(prof + (55 + (i + j) * 64)) * strength;
#line 219
      tmp_gpe += *(prof + (56 + (i + j) * 64)) * strength;
#line 220
      tmp_tgpe += *(prof + (57 + (i + j) * 64)) * strength;
#line 217
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 222
    tmp_gpo /= (float )window;
#line 223
    tmp_gpe /= (float )window;
#line 224
    tmp_tgpe /= (float )window;
#line 225
    *(prof + (27 + i * 64)) = (float )((double )*(prof + (55 + i * 64)) * (1.0 - (double )strength) + (double )tmp_gpo);
#line 226
    *(prof + (28 + i * 64)) = (float )((double )*(prof + (56 + i * 64)) * (1.0 - (double )strength) + (double )tmp_gpe);
#line 227
    *(prof + (29 + i * 64)) = (float )((double )*(prof + (57 + i * 64)) * (1.0 - (double )strength) + (double )tmp_tgpe);
#line 213
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 229
  return;
}
}
#line 233 "/home/june/repo/benchmarks/collector/temp/kalign-2.03+20110620/kalign2_advanced_gaps.c"
float *advanced_update(float const   *profa , float const   *profb , float *newp ,
                       int *path , int sipa , int sipb , float internal_gap_weight ) 
{ 
  int i ;
  int j ;
  int c ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 236
  i = 64;
  {
#line 236
  while (1) {
    while_continue: /* CIL Label */ ;
#line 236
    tmp = i;
#line 236
    i --;
#line 236
    if (! tmp) {
#line 236
      goto while_break;
    }
#line 237
    *(newp + i) = (float )(*(profa + i) + *(profb + i));
  }
  while_break: /* CIL Label */ ;
  }
#line 240
  profa += 64;
#line 241
  profb += 64;
#line 242
  newp += 64;
#line 244
  c = 1;
  {
#line 246
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 246
    if (! (*(path + c) != 3)) {
#line 246
      goto while_break___0;
    }
#line 253
    if (! *(path + c)) {
#line 255
      i = 64;
      {
#line 255
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 255
        tmp___0 = i;
#line 255
        i --;
#line 255
        if (! tmp___0) {
#line 255
          goto while_break___1;
        }
#line 256
        *(newp + i) = (float )(*(profa + i) + *(profb + i));
      }
      while_break___1: /* CIL Label */ ;
      }
#line 260
      profa += 64;
#line 261
      profb += 64;
    }
#line 263
    if (*(path + c) & 1) {
#line 266
      i = 64;
      {
#line 266
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 266
        tmp___1 = i;
#line 266
        i --;
#line 266
        if (! tmp___1) {
#line 266
          goto while_break___2;
        }
#line 267
        *(newp + i) = (float )*(profb + i);
      }
      while_break___2: /* CIL Label */ ;
      }
#line 269
      profb += 64;
#line 270
      if (! (*(path + c) & 20)) {
#line 271
        if (*(path + c) & 32) {
#line 272
          *(newp + 25) += (float )(*(profa + 26) + ((float const   )sipa - *(profa + 26)) * (float const   )internal_gap_weight);
#line 273
          i = (int )(tgpe * (float )(*(profa + 26) + ((float const   )sipa - *(profa + 26)) * (float const   )internal_gap_weight));
        } else {
#line 275
          *(newp + 24) += (float )(*(profa + 26) + ((float const   )sipa - *(profa + 26)) * (float const   )internal_gap_weight);
#line 276
          i = (int )(gpe * (float )(*(profa + 26) + ((float const   )sipa - *(profa + 26)) * (float const   )internal_gap_weight));
        }
#line 279
        j = 32;
        {
#line 279
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 279
          if (! (j < 55)) {
#line 279
            goto while_break___3;
          }
#line 280
          *(newp + j) -= (float )i;
#line 279
          j ++;
        }
        while_break___3: /* CIL Label */ ;
        }
      } else {
#line 283
        if (*(path + c) & 16) {
#line 285
          if (*(path + c) & 32) {
#line 286
            *(newp + 25) += (float )(*(profa + 26) + ((float const   )sipa - *(profa + 26)) * (float const   )internal_gap_weight);
#line 287
            i = (int )(tgpe * (float )(*(profa + 26) + ((float const   )sipa - *(profa + 26)) * (float const   )internal_gap_weight));
#line 288
            *(newp + 23) += (float )(*(profa + 26) + ((float const   )sipa - *(profa + 26)) * (float const   )internal_gap_weight);
#line 289
            i = (int )((float )i + gpo * (float )(*(profa + 26) + ((float const   )sipa - *(profa + 26)) * (float const   )internal_gap_weight));
          } else {
#line 291
            *(newp + 23) += (float )(*(profa + 26) + ((float const   )sipa - *(profa + 26)) * (float const   )internal_gap_weight);
#line 292
            i = (int )(gpo * (float )(*(profa + 26) + ((float const   )sipa - *(profa + 26)) * (float const   )internal_gap_weight));
          }
#line 295
          j = 32;
          {
#line 295
          while (1) {
            while_continue___4: /* CIL Label */ ;
#line 295
            if (! (j < 55)) {
#line 295
              goto while_break___4;
            }
#line 296
            *(newp + j) -= (float )i;
#line 295
            j ++;
          }
          while_break___4: /* CIL Label */ ;
          }
        }
#line 299
        if (*(path + c) & 4) {
#line 301
          if (*(path + c) & 32) {
#line 302
            *(newp + 25) += (float )(*(profa + 26) + ((float const   )sipa - *(profa + 26)) * (float const   )internal_gap_weight);
#line 303
            i = (int )(tgpe * (float )(*(profa + 26) + ((float const   )sipa - *(profa + 26)) * (float const   )internal_gap_weight));
#line 304
            *(newp + 23) += (float )(*(profa + 26) + ((float const   )sipa - *(profa + 26)) * (float const   )internal_gap_weight);
#line 305
            i = (int )((float )i + gpo * (float )(*(profa + 26) + ((float const   )sipa - *(profa + 26)) * (float const   )internal_gap_weight));
          } else {
#line 307
            *(newp + 23) += (float )(*(profa + 26) + ((float const   )sipa - *(profa + 26)) * (float const   )internal_gap_weight);
#line 308
            i = (int )(gpo * (float )(*(profa + 26) + ((float const   )sipa - *(profa + 26)) * (float const   )internal_gap_weight));
          }
#line 310
          j = 32;
          {
#line 310
          while (1) {
            while_continue___5: /* CIL Label */ ;
#line 310
            if (! (j < 55)) {
#line 310
              goto while_break___5;
            }
#line 311
            *(newp + j) -= (float )i;
#line 310
            j ++;
          }
          while_break___5: /* CIL Label */ ;
          }
        }
      }
    }
#line 318
    if (*(path + c) & 2) {
#line 321
      i = 64;
      {
#line 321
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 321
        tmp___2 = i;
#line 321
        i --;
#line 321
        if (! tmp___2) {
#line 321
          goto while_break___6;
        }
#line 322
        *(newp + i) = (float )*(profa + i);
      }
      while_break___6: /* CIL Label */ ;
      }
#line 324
      profa += 64;
#line 325
      if (! (*(path + c) & 20)) {
#line 326
        if (*(path + c) & 32) {
#line 327
          *(newp + 25) += (float )(*(profb + 26) + ((float const   )sipb - *(profb + 26)) * (float const   )internal_gap_weight);
#line 328
          i = (int )(tgpe * (float )(*(profb + 26) + ((float const   )sipb - *(profb + 26)) * (float const   )internal_gap_weight));
        } else {
#line 330
          *(newp + 24) += (float )(*(profb + 26) + ((float const   )sipb - *(profb + 26)) * (float const   )internal_gap_weight);
#line 331
          i = (int )(gpe * (float )(*(profb + 26) + ((float const   )sipb - *(profb + 26)) * (float const   )internal_gap_weight));
        }
#line 333
        j = 32;
        {
#line 333
        while (1) {
          while_continue___7: /* CIL Label */ ;
#line 333
          if (! (j < 55)) {
#line 333
            goto while_break___7;
          }
#line 334
          *(newp + j) -= (float )i;
#line 333
          j ++;
        }
        while_break___7: /* CIL Label */ ;
        }
      } else {
#line 337
        if (*(path + c) & 16) {
#line 339
          if (*(path + c) & 32) {
#line 340
            *(newp + 25) += (float )(*(profb + 26) + ((float const   )sipb - *(profb + 26)) * (float const   )internal_gap_weight);
#line 341
            i = (int )(tgpe * (float )(*(profb + 26) + ((float const   )sipb - *(profb + 26)) * (float const   )internal_gap_weight));
#line 342
            *(newp + 23) += (float )(*(profb + 26) + ((float const   )sipb - *(profb + 26)) * (float const   )internal_gap_weight);
#line 343
            i = (int )((float )i + gpo * (float )(*(profb + 26) + ((float const   )sipb - *(profb + 26)) * (float const   )internal_gap_weight));
          } else {
#line 345
            *(newp + 23) += (float )(*(profb + 26) + ((float const   )sipb - *(profb + 26)) * (float const   )internal_gap_weight);
#line 346
            i = (int )(gpo * (float )(*(profb + 26) + ((float const   )sipb - *(profb + 26)) * (float const   )internal_gap_weight));
          }
#line 348
          j = 32;
          {
#line 348
          while (1) {
            while_continue___8: /* CIL Label */ ;
#line 348
            if (! (j < 55)) {
#line 348
              goto while_break___8;
            }
#line 349
            *(newp + j) -= (float )i;
#line 348
            j ++;
          }
          while_break___8: /* CIL Label */ ;
          }
        }
#line 352
        if (*(path + c) & 4) {
#line 354
          if (*(path + c) & 32) {
#line 355
            *(newp + 25) += (float )(*(profb + 26) + ((float const   )sipb - *(profb + 26)) * (float const   )internal_gap_weight);
#line 356
            i = (int )(tgpe * (float )(*(profb + 26) + ((float const   )sipb - *(profb + 26)) * (float const   )internal_gap_weight));
#line 357
            *(newp + 23) += (float )(*(profb + 26) + ((float const   )sipb - *(profb + 26)) * (float const   )internal_gap_weight);
#line 358
            i = (int )((float )i + gpo * (float )(*(profb + 26) + ((float const   )sipb - *(profb + 26)) * (float const   )internal_gap_weight));
          } else {
#line 360
            *(newp + 23) += (float )(*(profb + 26) + ((float const   )sipb - *(profb + 26)) * (float const   )internal_gap_weight);
#line 361
            i = (int )(gpo * (float )(*(profb + 26) + ((float const   )sipb - *(profb + 26)) * (float const   )internal_gap_weight));
          }
#line 364
          j = 32;
          {
#line 364
          while (1) {
            while_continue___9: /* CIL Label */ ;
#line 364
            if (! (j < 55)) {
#line 364
              goto while_break___9;
            }
#line 365
            *(newp + j) -= (float )i;
#line 364
            j ++;
          }
          while_break___9: /* CIL Label */ ;
          }
        }
      }
    }
#line 371
    newp += 64;
#line 372
    c ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 374
  i = 64;
  {
#line 374
  while (1) {
    while_continue___10: /* CIL Label */ ;
#line 374
    tmp___3 = i;
#line 374
    i --;
#line 374
    if (! tmp___3) {
#line 374
      goto while_break___10;
    }
#line 375
    *(newp + i) = (float )(*(profa + i) + *(profb + i));
  }
  while_break___10: /* CIL Label */ ;
  }
#line 377
  newp -= (*(path + 0) + 1) * 64;
#line 378
  return (newp);
}
}
#line 383 "/home/june/repo/benchmarks/collector/temp/kalign-2.03+20110620/kalign2_advanced_gaps.c"
int *advanced_hirsch_pp_dyn(float const   *prof1 , float const   *prof2 , struct hirsch_mem *hm ,
                            int *hirsch_path ) 
{ 
  int mid ;
  float input_states[6] ;
  int old_cor[5] ;

  {
#line 385
  mid = (hm->enda - hm->starta) / 2 + hm->starta;
#line 386
  input_states[0] = (hm->f + 0)->a;
#line 386
  input_states[1] = (hm->f + 0)->ga;
#line 386
  input_states[2] = (hm->f + 0)->gb;
#line 386
  input_states[3] = (hm->b + 0)->a;
#line 386
  input_states[4] = (hm->b + 0)->ga;
#line 386
  input_states[5] = (hm->b + 0)->gb;
#line 387
  old_cor[0] = hm->starta;
#line 387
  old_cor[1] = hm->enda;
#line 387
  old_cor[2] = hm->startb;
#line 387
  old_cor[3] = hm->endb;
#line 387
  old_cor[4] = mid;
#line 393
  if (hm->starta >= hm->enda) {
#line 394
    return (hirsch_path);
  }
#line 396
  if (hm->startb >= hm->endb) {
#line 397
    return (hirsch_path);
  }
  {
#line 400
  hm->enda = mid;
#line 401
  hm->f = advanced_foward_hirsch_pp_dyn(prof1, prof2, hm);
#line 408
  hm->starta = mid;
#line 409
  hm->enda = old_cor[1];
#line 410
  hm->b = advanced_backward_hirsch_pp_dyn(prof1, prof2, hm);
#line 417
  hirsch_path = advanced_hirsch_align_two_pp_vector(prof1, prof2, hm, hirsch_path,
                                                    input_states, old_cor);
  }
#line 418
  return (hirsch_path);
}
}
#line 423 "/home/june/repo/benchmarks/collector/temp/kalign-2.03+20110620/kalign2_advanced_gaps.c"
int *advanced_hirsch_align_two_pp_vector(float const   *prof1 , float const   *prof2 ,
                                         struct hirsch_mem *hm , int *hirsch_path ,
                                         float *input_states , int *old_cor ) 
{ 
  struct states *f ;
  struct states *b ;
  int i ;
  int j ;
  int c ;
  int transition ;
  float max ;
  float middle ;
  float sub ;
  int tmp ;
  int tmp___0 ;

  {
#line 425
  f = hm->f;
#line 426
  b = hm->b;
#line 428
  transition = -1;
#line 441
  max = - 3.40282346638528859812e+38F;
#line 442
  middle = (float )((hm->endb - hm->startb) / 2 + hm->startb);
#line 443
  sub = (float )0.0;
#line 446
  prof1 += 64 * (*(old_cor + 4) + 1);
#line 447
  prof2 += 64 * hm->startb;
#line 448
  i = hm->startb;
#line 449
  c = -1;
#line 450
  i = hm->startb;
  {
#line 450
  while (1) {
    while_continue: /* CIL Label */ ;
#line 450
    if (! (i < hm->endb)) {
#line 450
      goto while_break;
    }
    {
#line 451
    tmp = abs((int )(middle - (float )i));
#line 451
    sub = (float )tmp;
#line 452
    sub /= (float )1000;
#line 453
    prof2 += 64;
    }
#line 455
    if (((f + i)->a + (b + i)->a) - sub > max) {
#line 456
      max = ((f + i)->a + (b + i)->a) - sub;
#line 458
      transition = 1;
#line 459
      c = i;
    }
#line 461
    if ((((f + i)->a + (b + i)->ga) + (float )(*(prof2 + 27) * *(prof1 + 26))) - sub > max) {
#line 462
      max = (((f + i)->a + (b + i)->ga) + (float )(*(prof2 + 27) * *(prof1 + 26))) - sub;
#line 464
      transition = 2;
#line 465
      c = i;
    }
#line 467
    if ((((f + i)->a + (b + i)->gb) + (float )(*(prof1 + 27) * *(prof2 + 26))) - sub > max) {
#line 468
      max = (((f + i)->a + (b + i)->gb) + (float )(*(prof1 + 27) * *(prof2 + 26))) - sub;
#line 470
      transition = 3;
#line 471
      c = i;
    }
#line 473
    if ((((f + i)->ga + (b + i)->a) + (float )(*(prof2 + 27) * *(prof1 + 26))) - sub > max) {
#line 474
      max = (((f + i)->ga + (b + i)->a) + (float )(*(prof2 + 27) * *(prof1 + 26))) - sub;
#line 476
      transition = 5;
#line 477
      c = i;
    }
#line 481
    if (hm->startb == 0) {
#line 482
      if ((((f + i)->gb + (b + i)->gb) + (float )(*(prof1 + 29) * *(prof2 + 26))) - sub > max) {
#line 483
        max = (((f + i)->gb + (b + i)->gb) + (float )(*(prof1 + 29) * *(prof2 + 26))) - sub;
#line 485
        transition = 6;
#line 486
        c = i;
      }
    } else
#line 489
    if ((((f + i)->gb + (b + i)->gb) + (float )(*(prof1 + 28) * *(prof2 + 26))) - sub > max) {
#line 490
      max = (((f + i)->gb + (b + i)->gb) + (float )(*(prof1 + 28) * *(prof2 + 26))) - sub;
#line 492
      transition = 6;
#line 493
      c = i;
    }
#line 496
    if ((((f + i)->gb + (b + i)->a) + (float )(*(prof1 + 27) * *(prof2 + 26))) - sub > max) {
#line 497
      max = (((f + i)->gb + (b + i)->a) + (float )(*(prof1 + 27) * *(prof2 + 26))) - sub;
#line 499
      transition = 7;
#line 500
      c = i;
    }
#line 450
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 503
  i = hm->endb;
#line 504
  tmp___0 = abs((int )(middle - (float )i));
#line 504
  sub = (float )tmp___0;
#line 505
  sub /= (float )1000;
  }
#line 506
  if ((((f + i)->a + (b + i)->gb) + (float )(*(prof1 + 27) * *(prof2 + 26))) - sub > max) {
#line 507
    max = (((f + i)->a + (b + i)->gb) + (float )(*(prof1 + 27) * *(prof2 + 26))) - sub;
#line 509
    transition = 3;
#line 510
    c = i;
  }
#line 512
  if (hm->endb == hm->len_b) {
#line 513
    if ((((f + i)->gb + (b + i)->gb) + (float )(*(prof1 + 29) * *(prof2 + 26))) - sub > max) {
#line 514
      max = (((f + i)->gb + (b + i)->gb) + (float )(*(prof1 + 29) * *(prof2 + 26))) - sub;
#line 516
      transition = 6;
#line 517
      c = i;
    }
  } else
#line 520
  if ((((f + i)->gb + (b + i)->gb) + (float )(*(prof1 + 28) * *(prof2 + 26))) - sub > max) {
#line 521
    max = (((f + i)->gb + (b + i)->gb) + (float )(*(prof1 + 28) * *(prof2 + 26))) - sub;
#line 523
    transition = 6;
#line 524
    c = i;
  }
#line 530
  prof1 -= 64 * (*(old_cor + 4) + 1);
#line 531
  prof2 -= hm->endb << 6;
#line 538
  j = *(hirsch_path + 0);
  {
#line 540
  if (transition == 1) {
#line 540
    goto case_1;
  }
#line 579
  if (transition == 2) {
#line 579
    goto case_2;
  }
#line 615
  if (transition == 3) {
#line 615
    goto case_3;
  }
#line 650
  if (transition == 5) {
#line 650
    goto case_5;
  }
#line 685
  if (transition == 6) {
#line 685
    goto case_6;
  }
#line 717
  if (transition == 7) {
#line 717
    goto case_7;
  }
#line 539
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 542
  *(hirsch_path + *(old_cor + 4)) = c;
#line 543
  *(hirsch_path + (*(old_cor + 4) + 1)) = c + 1;
#line 548
  (hm->f + 0)->a = *(input_states + 0);
#line 549
  (hm->f + 0)->ga = *(input_states + 1);
#line 550
  (hm->f + 0)->gb = *(input_states + 2);
#line 551
  (hm->b + 0)->a = (float )0.0;
#line 552
  (hm->b + 0)->ga = - 3.40282346638528859812e+38F;
#line 553
  (hm->b + 0)->gb = - 3.40282346638528859812e+38F;
#line 556
  hm->starta = *(old_cor + 0);
#line 557
  hm->enda = *(old_cor + 4) - 1;
#line 559
  hm->startb = *(old_cor + 2);
#line 560
  hm->endb = c - 1;
#line 562
  hirsch_path = advanced_hirsch_pp_dyn(prof1, prof2, hm, hirsch_path);
#line 565
  hm->starta = *(old_cor + 4) + 1;
#line 566
  hm->enda = *(old_cor + 1);
#line 567
  hm->startb = c + 1;
#line 568
  hm->endb = *(old_cor + 3);
#line 569
  (hm->f + 0)->a = (float )0.0;
#line 570
  (hm->f + 0)->ga = - 3.40282346638528859812e+38F;
#line 571
  (hm->f + 0)->gb = - 3.40282346638528859812e+38F;
#line 572
  (hm->b + 0)->a = *(input_states + 3);
#line 573
  (hm->b + 0)->ga = *(input_states + 4);
#line 574
  (hm->b + 0)->gb = *(input_states + 5);
#line 577
  hirsch_path = advanced_hirsch_pp_dyn(prof1, prof2, hm, hirsch_path);
  }
#line 578
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 581
  *(hirsch_path + *(old_cor + 4)) = c;
#line 584
  (hm->f + 0)->a = *(input_states + 0);
#line 585
  (hm->f + 0)->ga = *(input_states + 1);
#line 586
  (hm->f + 0)->gb = *(input_states + 2);
#line 587
  (hm->b + 0)->a = (float )0.0;
#line 588
  (hm->b + 0)->ga = - 3.40282346638528859812e+38F;
#line 589
  (hm->b + 0)->gb = - 3.40282346638528859812e+38F;
#line 592
  hm->starta = *(old_cor + 0);
#line 593
  hm->enda = *(old_cor + 4) - 1;
#line 595
  hm->startb = *(old_cor + 2);
#line 596
  hm->endb = c - 1;
#line 598
  hirsch_path = advanced_hirsch_pp_dyn(prof1, prof2, hm, hirsch_path);
#line 601
  hm->starta = *(old_cor + 4);
#line 602
  hm->enda = *(old_cor + 1);
#line 603
  hm->startb = c + 1;
#line 604
  hm->endb = *(old_cor + 3);
#line 605
  (hm->f + 0)->a = - 3.40282346638528859812e+38F;
#line 606
  (hm->f + 0)->ga = (float )0.0;
#line 607
  (hm->f + 0)->gb = - 3.40282346638528859812e+38F;
#line 608
  (hm->b + 0)->a = *(input_states + 3);
#line 609
  (hm->b + 0)->ga = *(input_states + 4);
#line 610
  (hm->b + 0)->gb = *(input_states + 5);
#line 613
  hirsch_path = advanced_hirsch_pp_dyn(prof1, prof2, hm, hirsch_path);
  }
#line 614
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 617
  *(hirsch_path + *(old_cor + 4)) = c;
#line 620
  (hm->f + 0)->a = *(input_states + 0);
#line 621
  (hm->f + 0)->ga = *(input_states + 1);
#line 622
  (hm->f + 0)->gb = *(input_states + 2);
#line 623
  (hm->b + 0)->a = (float )0.0;
#line 624
  (hm->b + 0)->ga = - 3.40282346638528859812e+38F;
#line 625
  (hm->b + 0)->gb = - 3.40282346638528859812e+38F;
#line 627
  hm->starta = *(old_cor + 0);
#line 628
  hm->enda = *(old_cor + 4) - 1;
#line 630
  hm->startb = *(old_cor + 2);
#line 631
  hm->endb = c - 1;
#line 633
  hirsch_path = advanced_hirsch_pp_dyn(prof1, prof2, hm, hirsch_path);
#line 636
  hm->starta = *(old_cor + 4) + 1;
#line 637
  hm->enda = *(old_cor + 1);
#line 638
  hm->startb = c;
#line 639
  hm->endb = *(old_cor + 3);
#line 640
  (hm->f + 0)->a = - 3.40282346638528859812e+38F;
#line 641
  (hm->f + 0)->ga = - 3.40282346638528859812e+38F;
#line 642
  (hm->f + 0)->gb = (float )0.0;
#line 643
  (hm->b + 0)->a = *(input_states + 3);
#line 644
  (hm->b + 0)->ga = *(input_states + 4);
#line 645
  (hm->b + 0)->gb = *(input_states + 5);
#line 648
  hirsch_path = advanced_hirsch_pp_dyn(prof1, prof2, hm, hirsch_path);
  }
#line 649
  goto switch_break;
  case_5: /* CIL Label */ 
  {
#line 651
  *(hirsch_path + (*(old_cor + 4) + 1)) = c + 1;
#line 655
  (hm->f + 0)->a = *(input_states + 0);
#line 656
  (hm->f + 0)->ga = *(input_states + 1);
#line 657
  (hm->f + 0)->gb = *(input_states + 2);
#line 658
  (hm->b + 0)->a = - 3.40282346638528859812e+38F;
#line 659
  (hm->b + 0)->ga = (float )0.0;
#line 660
  (hm->b + 0)->gb = - 3.40282346638528859812e+38F;
#line 662
  hm->starta = *(old_cor + 0);
#line 663
  hm->enda = *(old_cor + 4);
#line 665
  hm->startb = *(old_cor + 2);
#line 666
  hm->endb = c - 1;
#line 668
  hirsch_path = advanced_hirsch_pp_dyn(prof1, prof2, hm, hirsch_path);
#line 671
  hm->starta = *(old_cor + 4) + 1;
#line 672
  hm->enda = *(old_cor + 1);
#line 673
  hm->startb = c + 1;
#line 674
  hm->endb = *(old_cor + 3);
#line 675
  (hm->f + 0)->a = (float )0.0;
#line 676
  (hm->f + 0)->ga = - 3.40282346638528859812e+38F;
#line 677
  (hm->f + 0)->gb = - 3.40282346638528859812e+38F;
#line 678
  (hm->b + 0)->a = *(input_states + 3);
#line 679
  (hm->b + 0)->ga = *(input_states + 4);
#line 680
  (hm->b + 0)->gb = *(input_states + 5);
#line 683
  hirsch_path = advanced_hirsch_pp_dyn(prof1, prof2, hm, hirsch_path);
  }
#line 684
  goto switch_break;
  case_6: /* CIL Label */ 
  {
#line 688
  (hm->f + 0)->a = *(input_states + 0);
#line 689
  (hm->f + 0)->ga = *(input_states + 1);
#line 690
  (hm->f + 0)->gb = *(input_states + 2);
#line 691
  (hm->b + 0)->a = - 3.40282346638528859812e+38F;
#line 692
  (hm->b + 0)->ga = - 3.40282346638528859812e+38F;
#line 693
  (hm->b + 0)->gb = (float )0.0;
#line 695
  hm->starta = *(old_cor + 0);
#line 696
  hm->enda = *(old_cor + 4) - 1;
#line 697
  hm->startb = *(old_cor + 2);
#line 698
  hm->endb = c;
#line 700
  hirsch_path = advanced_hirsch_pp_dyn(prof1, prof2, hm, hirsch_path);
#line 703
  hm->starta = *(old_cor + 4) + 1;
#line 704
  hm->enda = *(old_cor + 1);
#line 705
  hm->startb = c;
#line 706
  hm->endb = *(old_cor + 3);
#line 707
  (hm->f + 0)->a = - 3.40282346638528859812e+38F;
#line 708
  (hm->f + 0)->ga = - 3.40282346638528859812e+38F;
#line 709
  (hm->f + 0)->gb = (float )0.0;
#line 710
  (hm->b + 0)->a = *(input_states + 3);
#line 711
  (hm->b + 0)->ga = *(input_states + 4);
#line 712
  (hm->b + 0)->gb = *(input_states + 5);
#line 715
  hirsch_path = advanced_hirsch_pp_dyn(prof1, prof2, hm, hirsch_path);
  }
#line 716
  goto switch_break;
  case_7: /* CIL Label */ 
  {
#line 719
  *(hirsch_path + (*(old_cor + 4) + 1)) = c + 1;
#line 722
  (hm->f + 0)->a = *(input_states + 0);
#line 723
  (hm->f + 0)->ga = *(input_states + 1);
#line 724
  (hm->f + 0)->gb = *(input_states + 2);
#line 725
  (hm->b + 0)->a = - 3.40282346638528859812e+38F;
#line 726
  (hm->b + 0)->ga = - 3.40282346638528859812e+38F;
#line 727
  (hm->b + 0)->gb = (float )0.0;
#line 729
  hm->starta = *(old_cor + 0);
#line 730
  hm->enda = *(old_cor + 4) - 1;
#line 731
  hm->startb = *(old_cor + 2);
#line 732
  hm->endb = c;
#line 734
  hirsch_path = advanced_hirsch_pp_dyn(prof1, prof2, hm, hirsch_path);
#line 737
  hm->starta = *(old_cor + 4) + 1;
#line 738
  hm->enda = *(old_cor + 1);
#line 739
  hm->startb = c + 1;
#line 740
  hm->endb = *(old_cor + 3);
#line 741
  (hm->f + 0)->a = (float )0.0;
#line 742
  (hm->f + 0)->ga = - 3.40282346638528859812e+38F;
#line 743
  (hm->f + 0)->gb = - 3.40282346638528859812e+38F;
#line 744
  (hm->b + 0)->a = *(input_states + 3);
#line 745
  (hm->b + 0)->ga = *(input_states + 4);
#line 746
  (hm->b + 0)->gb = *(input_states + 5);
#line 749
  hirsch_path = advanced_hirsch_pp_dyn(prof1, prof2, hm, hirsch_path);
  }
#line 750
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 753
  return (hirsch_path);
}
}
#line 758 "/home/june/repo/benchmarks/collector/temp/kalign-2.03+20110620/kalign2_advanced_gaps.c"
struct states *advanced_foward_hirsch_pp_dyn(float const   *prof1 , float const   *prof2 ,
                                             struct hirsch_mem *hm ) 
{ 
  unsigned int freq[26] ;
  struct states *s ;
  register float pa ;
  register float pga ;
  register float pgb ;
  register float ca ;
  register int i ;
  register int j ;
  register int c ;
  int tmp ;

  {
#line 761
  s = hm->f;
#line 763
  pa = (float )0;
#line 764
  pga = (float )0;
#line 765
  pgb = (float )0;
#line 766
  ca = (float )0;
#line 767
  i = 0;
#line 768
  j = 0;
#line 769
  c = 0;
#line 773
  prof1 += hm->starta << 6;
#line 774
  prof2 += hm->startb << 6;
#line 775
  (s + hm->startb)->a = (s + 0)->a;
#line 776
  (s + hm->startb)->ga = (s + 0)->ga;
#line 777
  (s + hm->startb)->gb = (s + 0)->gb;
#line 778
  if (hm->startb == 0) {
#line 779
    j = hm->startb + 1;
    {
#line 779
    while (1) {
      while_continue: /* CIL Label */ ;
#line 779
      if (! (j < hm->endb)) {
#line 779
        goto while_break;
      }
#line 780
      prof2 += 64;
#line 781
      (s + j)->a = - 3.40282346638528859812e+38F;
#line 783
      (s + j)->ga = (s + (j - 1))->a + (float )(*(prof2 + 29) * *(prof1 + 26));
#line 784
      if ((s + (j - 1))->ga + (float )(*(prof2 + 29) * *(prof1 + 26)) > (s + j)->ga) {
#line 785
        (s + j)->ga = (s + (j - 1))->ga + (float )(*(prof2 + 29) * *(prof1 + 26));
      }
#line 787
      (s + j)->gb = - 3.40282346638528859812e+38F;
#line 779
      j ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 789
    prof2 += 64;
  } else {
#line 792
    j = hm->startb + 1;
    {
#line 792
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 792
      if (! (j < hm->endb)) {
#line 792
        goto while_break___0;
      }
#line 793
      prof2 += 64;
#line 794
      (s + j)->a = - 3.40282346638528859812e+38F;
#line 796
      (s + j)->ga = (s + (j - 1))->a + (float )(*(prof2 + 27) * *(prof1 + 26));
#line 797
      if ((s + (j - 1))->ga + (float )(*(prof2 + 28) * *(prof1 + 26)) > (s + j)->ga) {
#line 798
        (s + j)->ga = (s + (j - 1))->ga + (float )(*(prof2 + 28) * *(prof1 + 26));
      }
#line 800
      (s + j)->gb = - 3.40282346638528859812e+38F;
#line 792
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 803
    prof2 += 64;
  }
#line 806
  prof2 -= (hm->endb - hm->startb) << 6;
#line 808
  (s + hm->endb)->a = - 3.40282346638528859812e+38F;
#line 809
  (s + hm->endb)->ga = - 3.40282346638528859812e+38F;
#line 810
  (s + hm->endb)->gb = - 3.40282346638528859812e+38F;
#line 813
  i = hm->starta;
  {
#line 813
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 813
    if (! (i < hm->enda)) {
#line 813
      goto while_break___1;
    }
#line 814
    prof1 += 64;
#line 815
    c = 1;
#line 816
    j = 26;
    {
#line 816
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 816
      tmp = j;
#line 816
      j --;
#line 816
      if (! tmp) {
#line 816
        goto while_break___2;
      }
#line 817
      if (*(prof1 + j)) {
#line 818
        freq[c] = (unsigned int )j;
#line 819
        c ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
#line 822
    freq[0] = (unsigned int )c;
#line 824
    pa = (s + hm->startb)->a;
#line 825
    pga = (s + hm->startb)->ga;
#line 826
    pgb = (s + hm->startb)->gb;
#line 827
    if (hm->startb == 0) {
#line 828
      (s + hm->startb)->a = - 3.40282346638528859812e+38F;
#line 829
      (s + hm->startb)->ga = - 3.40282346638528859812e+38F;
#line 831
      (s + hm->startb)->gb = pa + (float )(*(prof1 + 29) * *(prof2 + 26));
#line 832
      if (pgb + (float )(*(prof1 + 29) * *(prof2 + 26)) > (s + hm->startb)->gb) {
#line 833
        (s + hm->startb)->gb = pgb + (float )(*(prof1 + 29) * *(prof2 + 26));
      }
    } else {
#line 836
      (s + hm->startb)->a = - 3.40282346638528859812e+38F;
#line 837
      (s + hm->startb)->ga = - 3.40282346638528859812e+38F;
#line 839
      (s + hm->startb)->gb = pa + (float )(*(prof1 + 27) * *(prof2 + 26));
#line 840
      if (pgb + (float )(*(prof1 + 28) * *(prof2 + 26)) > (s + hm->startb)->gb) {
#line 841
        (s + hm->startb)->gb = pgb + (float )(*(prof1 + 28) * *(prof2 + 26));
      }
    }
#line 844
    j = hm->startb + 1;
    {
#line 844
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 844
      if (! (j <= hm->endb)) {
#line 844
        goto while_break___3;
      }
#line 845
      prof2 += 64;
#line 846
      ca = (s + j)->a;
#line 848
      pga += (float )(*(prof2 + -37) * *(prof1 + -38));
#line 848
      if (pga > pa) {
#line 849
        pa = pga;
      }
#line 852
      pgb += (float )(*(prof1 + -37) * *(prof2 + -38));
#line 852
      if (pgb > pa) {
#line 853
        pa = pgb;
      }
#line 856
      prof2 += 32;
#line 857
      c = (int )freq[0];
      {
#line 857
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 857
        c --;
#line 857
        if (! c) {
#line 857
          goto while_break___4;
        }
#line 858
        pa += (float )(*(prof1 + freq[c]) * *(prof2 + freq[c]));
      }
      while_break___4: /* CIL Label */ ;
      }
#line 860
      prof2 -= 32;
#line 862
      (s + j)->a = pa;
#line 864
      pga = (s + j)->ga;
#line 866
      (s + j)->ga = (s + (j - 1))->a + (float )(*(prof2 + 27) * *(prof1 + 26));
#line 867
      if ((s + (j - 1))->ga + (float )(*(prof2 + 28) * *(prof1 + 26)) > (s + j)->ga) {
#line 868
        (s + j)->ga = (s + (j - 1))->ga + (float )(*(prof2 + 28) * *(prof1 + 26));
      }
#line 871
      pgb = (s + j)->gb;
#line 873
      (s + j)->gb = ca + (float )(*(prof1 + 27) * *(prof2 + 26));
#line 874
      if (pgb + (float )(*(prof1 + 28) * *(prof2 + 26)) > (s + j)->gb) {
#line 875
        (s + j)->gb = pgb + (float )(*(prof1 + 28) * *(prof2 + 26));
      }
#line 877
      pa = ca;
#line 844
      j ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 879
    prof2 -= (hm->endb - hm->startb) << 6;
#line 813
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 882
  prof1 -= 64 * hm->enda;
#line 883
  return (s);
}
}
#line 886 "/home/june/repo/benchmarks/collector/temp/kalign-2.03+20110620/kalign2_advanced_gaps.c"
struct states *advanced_backward_hirsch_pp_dyn(float const   *prof1 , float const   *prof2 ,
                                               struct hirsch_mem *hm ) 
{ 
  unsigned int freq[26] ;
  struct states *s ;
  register float pa ;
  register float pga ;
  register float pgb ;
  register float ca ;
  register int i ;
  register int j ;
  register int c ;
  int tmp ;
  int tmp___0 ;

  {
#line 889
  s = hm->b;
#line 891
  pa = (float )0;
#line 892
  pga = (float )0;
#line 893
  pgb = (float )0;
#line 894
  ca = (float )0;
#line 895
  i = 0;
#line 896
  j = 0;
#line 897
  c = 0;
#line 899
  prof1 += (hm->enda + 1) << 6;
#line 900
  prof2 += (hm->endb + 1) << 6;
#line 901
  (s + hm->endb)->a = (s + 0)->a;
#line 902
  (s + hm->endb)->ga = (s + 0)->ga;
#line 903
  (s + hm->endb)->gb = (s + 0)->gb;
#line 908
  if (hm->endb == hm->len_b) {
#line 910
    j = hm->endb - 1;
    {
#line 910
    while (1) {
      while_continue: /* CIL Label */ ;
#line 910
      if (! (j > hm->startb)) {
#line 910
        goto while_break;
      }
#line 911
      prof2 -= 64;
#line 912
      (s + j)->a = - 3.40282346638528859812e+38F;
#line 914
      (s + j)->ga = (s + (j + 1))->a + (float )(*(prof2 + 29) * *(prof1 + 26));
#line 915
      if ((s + (j + 1))->ga + (float )(*(prof2 + 29) * *(prof1 + 26)) > (s + j)->ga) {
#line 916
        (s + j)->ga = (s + (j + 1))->ga + (float )(*(prof2 + 29) * *(prof1 + 26));
      }
#line 918
      (s + j)->gb = - 3.40282346638528859812e+38F;
#line 910
      j --;
    }
    while_break: /* CIL Label */ ;
    }
#line 920
    prof2 -= 64;
  } else {
#line 922
    j = hm->endb - 1;
    {
#line 922
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 922
      if (! (j > hm->startb)) {
#line 922
        goto while_break___0;
      }
#line 923
      prof2 -= 64;
#line 924
      (s + j)->a = - 3.40282346638528859812e+38F;
#line 926
      (s + j)->ga = (s + (j + 1))->a + (float )(*(prof2 + 27) * *(prof1 + 26));
#line 927
      if ((s + (j + 1))->ga + (float )(*(prof2 + 28) * *(prof1 + 26)) > (s + j)->ga) {
#line 928
        (s + j)->ga = (s + (j + 1))->ga + (float )(*(prof2 + 28) * *(prof1 + 26));
      }
#line 930
      (s + j)->gb = - 3.40282346638528859812e+38F;
#line 922
      j --;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 933
    prof2 -= 64;
  }
#line 936
  (s + hm->startb)->a = - 3.40282346638528859812e+38F;
#line 937
  (s + hm->startb)->ga = - 3.40282346638528859812e+38F;
#line 938
  (s + hm->startb)->gb = - 3.40282346638528859812e+38F;
#line 941
  i = hm->enda - hm->starta;
  {
#line 942
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 942
    tmp___0 = i;
#line 942
    i --;
#line 942
    if (! tmp___0) {
#line 942
      goto while_break___1;
    }
#line 943
    prof1 -= 64;
#line 945
    c = 1;
#line 946
    j = 26;
    {
#line 946
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 946
      tmp = j;
#line 946
      j --;
#line 946
      if (! tmp) {
#line 946
        goto while_break___2;
      }
#line 947
      if (*(prof1 + j)) {
#line 948
        freq[c] = (unsigned int )j;
#line 949
        c ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
#line 952
    freq[0] = (unsigned int )c;
#line 954
    pa = (s + hm->endb)->a;
#line 955
    pga = (s + hm->endb)->ga;
#line 956
    pgb = (s + hm->endb)->gb;
#line 957
    (s + hm->endb)->a = - 3.40282346638528859812e+38F;
#line 958
    (s + hm->endb)->ga = - 3.40282346638528859812e+38F;
#line 960
    if (hm->endb == hm->len_b) {
#line 961
      (s + hm->endb)->gb = pa + (float )(*(prof1 + 29) * *(prof2 + 26));
#line 962
      if (pgb + (float )(*(prof1 + 29) * *(prof2 + 26)) > (s + hm->endb)->gb) {
#line 963
        (s + hm->endb)->gb = pgb + (float )(*(prof1 + 29) * *(prof2 + 26));
      }
    } else {
#line 966
      (s + hm->endb)->gb = pa + (float )(*(prof1 + 27) * *(prof2 + 26));
#line 967
      if (pgb + (float )(*(prof1 + 28) * *(prof2 + 26)) > (s + hm->endb)->gb) {
#line 968
        (s + hm->endb)->gb = pgb + (float )(*(prof1 + 28) * *(prof2 + 26));
      }
    }
#line 972
    prof2 += (hm->endb - hm->startb) << 6;
#line 974
    j = hm->endb - 1;
    {
#line 974
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 974
      if (! (j >= hm->startb)) {
#line 974
        goto while_break___3;
      }
#line 975
      prof2 -= 64;
#line 976
      ca = (s + j)->a;
#line 977
      pga += (float )(*(prof2 + 91) * *(prof1 + 26));
#line 977
      if (pga > pa) {
#line 978
        pa = pga;
      }
#line 980
      pgb += (float )(*(prof1 + 91) * *(prof2 + 26));
#line 980
      if (pgb > pa) {
#line 981
        pa = pgb;
      }
#line 984
      prof2 += 32;
#line 985
      c = (int )freq[0];
      {
#line 985
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 985
        c --;
#line 985
        if (! c) {
#line 985
          goto while_break___4;
        }
#line 986
        pa += (float )(*(prof1 + freq[c]) * *(prof2 + freq[c]));
      }
      while_break___4: /* CIL Label */ ;
      }
#line 988
      prof2 -= 32;
#line 990
      (s + j)->a = pa;
#line 992
      pga = (s + j)->ga;
#line 994
      (s + j)->ga = (s + (j + 1))->a + (float )(*(prof2 + 27) * *(prof1 + 26));
#line 995
      if ((s + (j + 1))->ga + (float )(*(prof2 + 28) * *(prof1 + 26)) > (s + j)->ga) {
#line 996
        (s + j)->ga = (s + (j + 1))->ga + (float )(*(prof2 + 28) * *(prof1 + 26));
      }
#line 999
      pgb = (s + j)->gb;
#line 1001
      (s + j)->gb = ca + (float )(*(prof1 + 27) * *(prof2 + 26));
#line 1002
      if (pgb + (float )(*(prof1 + 28) * *(prof2 + 26)) > (s + j)->gb) {
#line 1003
        (s + j)->gb = pgb + (float )(*(prof1 + 28) * *(prof2 + 26));
      }
#line 1005
      pa = ca;
#line 974
      j --;
    }
    while_break___3: /* CIL Label */ ;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1008
  return (s);
}
}
#line 480 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 240 "/home/june/repo/benchmarks/collector/temp/kalign-2.03+20110620/kalign2.h"
float *make_profile(float *prof , int *seq , int len , float **subm ) ;
#line 243
float *update(float const   *profa , float const   *profb , float *newp , int *path ,
              int sipa , int sipb ) ;
#line 244
float *update_only_a(float const   *profa , float const   *profb , float *newp , int *path ,
                     int sipa , int sipb ) ;
#line 249
void set_gap_penalties(float *prof , int len , int nsip , float strength , int nsip_c ) ;
#line 26 "/home/june/repo/benchmarks/collector/temp/kalign-2.03+20110620/kalign2_hirschberg.h"
int *hirsch_pp_dyn(float const   *prof1 , float const   *prof2 , struct hirsch_mem *hm ,
                   int *hirsch_path ) ;
#line 27
struct states *foward_hirsch_pp_dyn(float const   *prof1 , float const   *prof2 ,
                                    struct hirsch_mem *hm ) ;
#line 28
struct states *backward_hirsch_pp_dyn(float const   *prof1 , float const   *prof2 ,
                                      struct hirsch_mem *hm ) ;
#line 29
int *hirsch_align_two_pp_vector(float const   *prof1 , float const   *prof2 , struct hirsch_mem *hm ,
                                int *hirsch_path , float *input_states , int *old_cor ) ;
#line 35
int *hirsch_ps_dyn(float const   *prof1 , int const   *seq2 , struct hirsch_mem *hm ,
                   int *hirsch_path , int sip ) ;
#line 36
struct states *foward_hirsch_ps_dyn(float const   *prof1 , int const   *seq2 , struct hirsch_mem *hm ,
                                    int sip ) ;
#line 37
struct states *backward_hirsch_ps_dyn(float const   *prof1 , int const   *seq2 , struct hirsch_mem *hm ,
                                      int sip ) ;
#line 38
int *hirsch_align_two_ps_vector(float const   *prof1 , int const   *seq2 , struct hirsch_mem *hm ,
                                int *hirsch_path , float *input_states , int *old_cor ,
                                int sip ) ;
#line 41
int *hirsch_ss_dyn(float **subm , int const   *seq1 , int const   *seq2 , struct hirsch_mem *hm ,
                   int *hirsch_path ) ;
#line 42
struct states *foward_hirsch_ss_dyn(float **subm , int const   *seq1 , int const   *seq2 ,
                                    struct hirsch_mem *hm ) ;
#line 43
struct states *backward_hirsch_ss_dyn(float **subm , int const   *seq1 , int const   *seq2 ,
                                      struct hirsch_mem *hm ) ;
#line 44
int *hirsch_align_two_ss_vector(float **subm , int const   *seq1 , int const   *seq2 ,
                                struct hirsch_mem *hm , int *hirsch_path , float *input_states ,
                                int *old_cor ) ;
#line 32 "/home/june/repo/benchmarks/collector/temp/kalign-2.03+20110620/kalign2_hirschberg.c"
int **hirschberg_alignment(struct alignment *aln , int *tree , float **submatrix ,
                           int **map , int window , float strength ) 
{ 
  struct hirsch_mem *hm ;
  int i ;
  int j ;
  int g ;
  int a ;
  int b ;
  int c ;
  int len_a ;
  int len_b ;
  float **profile ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
  {
#line 34
  hm = (struct hirsch_mem *)0;
#line 38
  profile = (float **)0;
#line 40
  tmp = malloc(sizeof(float *) * (unsigned long )numprofiles);
#line 40
  profile = (float **)tmp;
#line 41
  i = 0;
  }
  {
#line 41
  while (1) {
    while_continue: /* CIL Label */ ;
#line 41
    if (! ((unsigned int )i < numprofiles)) {
#line 41
      goto while_break;
    }
#line 42
    *(profile + i) = (float *)0;
#line 41
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 45
  tmp___0 = malloc(sizeof(int *) * (unsigned long )numprofiles);
#line 45
  map = (int **)tmp___0;
#line 46
  i = 0;
  }
  {
#line 46
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 46
    if (! ((unsigned int )i < numprofiles)) {
#line 46
      goto while_break___0;
    }
#line 47
    *(map + i) = (int *)0;
#line 46
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 50
  hm = hirsch_mem_alloc(hm, 1024);
#line 52
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\nAlignment:\n");
#line 54
  i = 0;
  }
  {
#line 54
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 54
    if (! ((unsigned int )i < numseq - 1U)) {
#line 54
      goto while_break___1;
    }
    {
#line 55
    a = *(tree + i * 3);
#line 56
    b = *(tree + (i * 3 + 1));
#line 57
    c = *(tree + (i * 3 + 2));
#line 58
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\r%8.0f percent done",
            (double )(((float )i / (float )numseq) * (float )100));
#line 60
    len_a = (int )*(aln->sl + a);
#line 61
    len_b = (int )*(aln->sl + b);
    }
#line 64
    if (len_a > len_b) {
#line 64
      g = len_a;
    } else {
#line 64
      g = len_b;
    }
    {
#line 65
    tmp___1 = malloc(sizeof(int ) * (unsigned long )(g + 2));
#line 65
    *(map + c) = (int *)tmp___1;
    }
#line 66
    if (g > hm->size) {
      {
#line 67
      hm = hirsch_mem_realloc(hm, g);
      }
    }
#line 70
    j = 0;
    {
#line 70
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 70
      if (! (j < g + 2)) {
#line 70
        goto while_break___2;
      }
#line 71
      *(*(map + c) + j) = -1;
#line 70
      j ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 74
    if ((unsigned int )a < numseq) {
      {
#line 75
      *(profile + a) = make_profile(*(profile + a), *(aln->s + a), len_a, submatrix);
      }
    } else {
      {
#line 77
      set_gap_penalties(*(profile + a), len_a, (int )*(aln->nsip + b), strength, (int )*(aln->nsip + a));
      }
    }
#line 82
    if ((unsigned int )b < numseq) {
      {
#line 83
      *(profile + b) = make_profile(*(profile + b), *(aln->s + b), len_b, submatrix);
      }
    } else {
      {
#line 85
      set_gap_penalties(*(profile + b), len_b, (int )*(aln->nsip + a), strength, (int )*(aln->nsip + b));
      }
    }
#line 90
    hm->starta = 0;
#line 91
    hm->startb = 0;
#line 92
    hm->enda = len_a;
#line 93
    hm->endb = len_b;
#line 94
    hm->len_a = len_a;
#line 95
    hm->len_b = len_b;
#line 97
    (hm->f + 0)->a = (float )0.0;
#line 98
    (hm->f + 0)->ga = - 3.40282346638528859812e+38F;
#line 99
    (hm->f + 0)->gb = - 3.40282346638528859812e+38F;
#line 100
    (hm->b + 0)->a = (float )0.0;
#line 101
    (hm->b + 0)->ga = - 3.40282346638528859812e+38F;
#line 102
    (hm->b + 0)->gb = - 3.40282346638528859812e+38F;
#line 104
    if ((unsigned int )a < numseq) {
#line 105
      if ((unsigned int )b < numseq) {
        {
#line 106
        *(map + c) = hirsch_ss_dyn(submatrix, (int const   *)*(aln->s + a), (int const   *)*(aln->s + b),
                                   hm, *(map + c));
        }
      } else {
        {
#line 108
        hm->enda = len_b;
#line 109
        hm->endb = len_a;
#line 110
        hm->len_a = len_b;
#line 111
        hm->len_b = len_a;
#line 112
        *(map + c) = hirsch_ps_dyn((float const   *)*(profile + b), (int const   *)*(aln->s + a),
                                   hm, *(map + c), (int )*(aln->nsip + b));
#line 113
        *(map + c) = mirror_hirsch_path(*(map + c), len_a, len_b);
        }
      }
    } else
#line 116
    if ((unsigned int )b < numseq) {
      {
#line 117
      *(map + c) = hirsch_ps_dyn((float const   *)*(profile + a), (int const   *)*(aln->s + b),
                                 hm, *(map + c), (int )*(aln->nsip + a));
      }
    } else
#line 119
    if (len_a < len_b) {
      {
#line 120
      *(map + c) = hirsch_pp_dyn((float const   *)*(profile + a), (float const   *)*(profile + b),
                                 hm, *(map + c));
      }
    } else {
      {
#line 122
      hm->enda = len_b;
#line 123
      hm->endb = len_a;
#line 124
      hm->len_a = len_b;
#line 125
      hm->len_b = len_a;
#line 126
      *(map + c) = hirsch_pp_dyn((float const   *)*(profile + b), (float const   *)*(profile + a),
                                 hm, *(map + c));
#line 127
      *(map + c) = mirror_hirsch_path(*(map + c), len_a, len_b);
      }
    }
    {
#line 132
    *(map + c) = add_gap_info_to_hirsch_path(*(map + c), len_a, len_b);
    }
#line 134
    if ((unsigned int )i != numseq - 2U) {
      {
#line 135
      tmp___2 = malloc((sizeof(float ) * 64UL) * (unsigned long )(*(*(map + c) + 0) + 2));
#line 135
      *(profile + c) = (float *)tmp___2;
#line 136
      *(profile + c) = update((float const   *)*(profile + a), (float const   *)*(profile + b),
                              *(profile + c), *(map + c), (int )*(aln->nsip + a),
                              (int )*(aln->nsip + b));
      }
    }
    {
#line 139
    *(aln->sl + c) = (unsigned int )*(*(map + c) + 0);
#line 141
    *(aln->nsip + c) = *(aln->nsip + a) + *(aln->nsip + b);
#line 142
    tmp___3 = malloc(sizeof(int ) * (unsigned long )(*(aln->nsip + a) + *(aln->nsip + b)));
#line 142
    *(aln->sip + c) = (unsigned int *)tmp___3;
#line 143
    g = 0;
#line 144
    j = (int )*(aln->nsip + a);
    }
    {
#line 144
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 144
      tmp___4 = j;
#line 144
      j --;
#line 144
      if (! tmp___4) {
#line 144
        goto while_break___3;
      }
#line 145
      *(*(aln->sip + c) + g) = *(*(aln->sip + a) + j);
#line 146
      g ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 148
    j = (int )*(aln->nsip + b);
    {
#line 148
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 148
      tmp___5 = j;
#line 148
      j --;
#line 148
      if (! tmp___5) {
#line 148
        goto while_break___4;
      }
#line 149
      *(*(aln->sip + c) + g) = *(*(aln->sip + b) + j);
#line 150
      g ++;
    }
    while_break___4: /* CIL Label */ ;
    }
    {
#line 153
    free((void *)*(profile + a));
#line 154
    free((void *)*(profile + b));
#line 54
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 156
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\r%8.0f percent done\n",
          100.0);
#line 157
  free((void *)profile);
#line 158
  hirsch_mem_free(hm);
#line 159
  i = 32;
  }
  {
#line 159
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 159
    tmp___6 = i;
#line 159
    i --;
#line 159
    if (! tmp___6) {
#line 159
      goto while_break___5;
    }
    {
#line 160
    free((void *)*(submatrix + i));
    }
  }
  while_break___5: /* CIL Label */ ;
  }
  {
#line 162
  free((void *)submatrix);
  }
#line 163
  return (map);
}
}
#line 167 "/home/june/repo/benchmarks/collector/temp/kalign-2.03+20110620/kalign2_hirschberg.c"
int **hirschberg_alignment_against_a(struct alignment *aln , int *tree , float **submatrix ,
                                     int **map , int window , float strength ) 
{ 
  struct hirsch_mem *hm ;
  int i ;
  int j ;
  int g ;
  int a ;
  int b ;
  int c ;
  int len_a ;
  int len_b ;
  float **profile ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
  {
#line 169
  hm = (struct hirsch_mem *)0;
#line 173
  profile = (float **)0;
#line 175
  tmp = malloc(sizeof(float *) * (unsigned long )numprofiles);
#line 175
  profile = (float **)tmp;
#line 176
  i = 0;
  }
  {
#line 176
  while (1) {
    while_continue: /* CIL Label */ ;
#line 176
    if (! ((unsigned int )i < numprofiles)) {
#line 176
      goto while_break;
    }
#line 177
    *(profile + i) = (float *)0;
#line 176
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 180
  tmp___0 = malloc(sizeof(int *) * (unsigned long )numprofiles);
#line 180
  map = (int **)tmp___0;
#line 181
  i = 0;
  }
  {
#line 181
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 181
    if (! ((unsigned int )i < numprofiles)) {
#line 181
      goto while_break___0;
    }
#line 182
    *(map + i) = (int *)0;
#line 181
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 185
  hm = hirsch_mem_alloc(hm, 1024);
#line 187
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\nAlignment:\n");
#line 189
  i = 0;
  }
  {
#line 189
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 189
    if (! ((unsigned int )i < numseq - 1U)) {
#line 189
      goto while_break___1;
    }
    {
#line 190
    a = *(tree + i * 3);
#line 191
    b = *(tree + (i * 3 + 1));
#line 192
    c = *(tree + (i * 3 + 2));
#line 193
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\r%8.0f percent done",
            (double )(((float )i / (float )numseq) * (float )100));
#line 195
    len_a = (int )*(aln->sl + a);
#line 196
    len_b = (int )*(aln->sl + b);
    }
#line 199
    if (len_a > len_b) {
#line 199
      g = len_a;
    } else {
#line 199
      g = len_b;
    }
    {
#line 200
    tmp___1 = malloc(sizeof(int ) * (unsigned long )(g + 2));
#line 200
    *(map + c) = (int *)tmp___1;
    }
#line 201
    if (g > hm->size) {
      {
#line 202
      hm = hirsch_mem_realloc(hm, g);
      }
    }
#line 205
    j = 0;
    {
#line 205
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 205
      if (! (j < g + 2)) {
#line 205
        goto while_break___2;
      }
#line 206
      *(*(map + c) + j) = -1;
#line 205
      j ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 209
    if ((unsigned int )a < numseq) {
      {
#line 210
      *(profile + a) = make_profile(*(profile + a), *(aln->s + a), len_a, submatrix);
      }
    } else {
      {
#line 212
      set_gap_penalties(*(profile + a), len_a, (int )*(aln->nsip + b), (float )0,
                        (int )*(aln->nsip + a));
      }
    }
#line 217
    if ((unsigned int )b < numseq) {
      {
#line 218
      *(profile + b) = make_profile(*(profile + b), *(aln->s + b), len_b, submatrix);
      }
    } else {
      {
#line 220
      set_gap_penalties(*(profile + b), len_b, (int )*(aln->nsip + a), (float )0,
                        (int )*(aln->nsip + b));
      }
    }
#line 225
    hm->starta = 0;
#line 226
    hm->startb = 0;
#line 227
    hm->enda = len_a;
#line 228
    hm->endb = len_b;
#line 229
    hm->len_a = len_a;
#line 230
    hm->len_b = len_b;
#line 232
    (hm->f + 0)->a = (float )0.0;
#line 233
    (hm->f + 0)->ga = - 3.40282346638528859812e+38F;
#line 234
    (hm->f + 0)->gb = - 3.40282346638528859812e+38F;
#line 235
    (hm->b + 0)->a = (float )0.0;
#line 236
    (hm->b + 0)->ga = - 3.40282346638528859812e+38F;
#line 237
    (hm->b + 0)->gb = - 3.40282346638528859812e+38F;
#line 239
    if ((unsigned int )a < numseq) {
#line 240
      if ((unsigned int )b < numseq) {
        {
#line 241
        *(map + c) = hirsch_ss_dyn(submatrix, (int const   *)*(aln->s + a), (int const   *)*(aln->s + b),
                                   hm, *(map + c));
        }
      } else {
        {
#line 243
        hm->enda = len_b;
#line 244
        hm->endb = len_a;
#line 245
        hm->len_a = len_b;
#line 246
        hm->len_b = len_a;
#line 247
        *(map + c) = hirsch_ps_dyn((float const   *)*(profile + b), (int const   *)*(aln->s + a),
                                   hm, *(map + c), (int )*(aln->nsip + b));
#line 248
        *(map + c) = mirror_hirsch_path(*(map + c), len_a, len_b);
        }
      }
    } else
#line 251
    if ((unsigned int )b < numseq) {
      {
#line 252
      *(map + c) = hirsch_ps_dyn((float const   *)*(profile + a), (int const   *)*(aln->s + b),
                                 hm, *(map + c), (int )*(aln->nsip + a));
      }
    } else
#line 254
    if (len_a < len_b) {
      {
#line 255
      *(map + c) = hirsch_pp_dyn((float const   *)*(profile + a), (float const   *)*(profile + b),
                                 hm, *(map + c));
      }
    } else {
      {
#line 257
      hm->enda = len_b;
#line 258
      hm->endb = len_a;
#line 259
      hm->len_a = len_b;
#line 260
      hm->len_b = len_a;
#line 261
      *(map + c) = hirsch_pp_dyn((float const   *)*(profile + b), (float const   *)*(profile + a),
                                 hm, *(map + c));
#line 262
      *(map + c) = mirror_hirsch_path(*(map + c), len_a, len_b);
      }
    }
    {
#line 267
    *(map + c) = add_gap_info_to_hirsch_path(*(map + c), len_a, len_b);
    }
#line 269
    if ((unsigned int )i != numseq - 2U) {
      {
#line 270
      tmp___2 = malloc((sizeof(float ) * 64UL) * (unsigned long )(*(*(map + c) + 0) + 2));
#line 270
      *(profile + c) = (float *)tmp___2;
#line 271
      *(profile + c) = update_only_a((float const   *)*(profile + a), (float const   *)*(profile + b),
                                     *(profile + c), *(map + c), (int )*(aln->nsip + a),
                                     (int )*(aln->nsip + b));
      }
    }
    {
#line 274
    *(aln->sl + c) = (unsigned int )*(*(map + c) + 0);
#line 276
    *(aln->nsip + c) = *(aln->nsip + a) + *(aln->nsip + b);
#line 277
    tmp___3 = malloc(sizeof(int ) * (unsigned long )(*(aln->nsip + a) + *(aln->nsip + b)));
#line 277
    *(aln->sip + c) = (unsigned int *)tmp___3;
#line 278
    g = 0;
#line 279
    j = (int )*(aln->nsip + a);
    }
    {
#line 279
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 279
      tmp___4 = j;
#line 279
      j --;
#line 279
      if (! tmp___4) {
#line 279
        goto while_break___3;
      }
#line 280
      *(*(aln->sip + c) + g) = *(*(aln->sip + a) + j);
#line 281
      g ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 283
    j = (int )*(aln->nsip + b);
    {
#line 283
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 283
      tmp___5 = j;
#line 283
      j --;
#line 283
      if (! tmp___5) {
#line 283
        goto while_break___4;
      }
#line 284
      *(*(aln->sip + c) + g) = *(*(aln->sip + b) + j);
#line 285
      g ++;
    }
    while_break___4: /* CIL Label */ ;
    }
    {
#line 288
    free((void *)*(profile + a));
#line 289
    free((void *)*(profile + b));
#line 189
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 291
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\r%8.0f percent done\n",
          100.0);
#line 292
  free((void *)profile);
#line 293
  hirsch_mem_free(hm);
#line 294
  i = 32;
  }
  {
#line 294
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 294
    tmp___6 = i;
#line 294
    i --;
#line 294
    if (! tmp___6) {
#line 294
      goto while_break___5;
    }
    {
#line 295
    free((void *)*(submatrix + i));
    }
  }
  while_break___5: /* CIL Label */ ;
  }
  {
#line 297
  free((void *)submatrix);
  }
#line 298
  return (map);
}
}
#line 302 "/home/june/repo/benchmarks/collector/temp/kalign-2.03+20110620/kalign2_hirschberg.c"
int *hirsch_ss_dyn(float **subm , int const   *seq1 , int const   *seq2 , struct hirsch_mem *hm ,
                   int *hirsch_path ) 
{ 
  int mid ;
  float input_states[6] ;
  int old_cor[5] ;

  {
#line 304
  mid = (hm->enda - hm->starta) / 2 + hm->starta;
#line 305
  input_states[0] = (hm->f + 0)->a;
#line 305
  input_states[1] = (hm->f + 0)->ga;
#line 305
  input_states[2] = (hm->f + 0)->gb;
#line 305
  input_states[3] = (hm->b + 0)->a;
#line 305
  input_states[4] = (hm->b + 0)->ga;
#line 305
  input_states[5] = (hm->b + 0)->gb;
#line 306
  old_cor[0] = hm->starta;
#line 306
  old_cor[1] = hm->enda;
#line 306
  old_cor[2] = hm->startb;
#line 306
  old_cor[3] = hm->endb;
#line 306
  old_cor[4] = mid;
#line 308
  if (hm->starta >= hm->enda) {
#line 309
    return (hirsch_path);
  }
#line 311
  if (hm->startb >= hm->endb) {
#line 312
    return (hirsch_path);
  }
  {
#line 316
  hm->enda = mid;
#line 319
  hm->f = foward_hirsch_ss_dyn(subm, seq1, seq2, hm);
#line 321
  hm->starta = mid;
#line 322
  hm->enda = old_cor[1];
#line 324
  hm->b = backward_hirsch_ss_dyn(subm, seq1, seq2, hm);
#line 327
  hirsch_path = hirsch_align_two_ss_vector(subm, seq1, seq2, hm, hirsch_path, input_states,
                                           old_cor);
  }
#line 328
  return (hirsch_path);
}
}
#line 331 "/home/june/repo/benchmarks/collector/temp/kalign-2.03+20110620/kalign2_hirschberg.c"
int *hirsch_align_two_ss_vector(float **subm , int const   *seq1 , int const   *seq2 ,
                                struct hirsch_mem *hm , int *hirsch_path , float *input_states ,
                                int *old_cor ) 
{ 
  struct states *f ;
  struct states *b ;
  int i ;
  int j ;
  int c ;
  int transition ;
  float max ;
  float middle ;
  float sub ;
  int tmp ;
  int tmp___0 ;

  {
#line 333
  f = hm->f;
#line 334
  b = hm->b;
#line 336
  transition = -1;
#line 349
  max = - 3.40282346638528859812e+38F;
#line 351
  middle = (float )((*(old_cor + 3) - *(old_cor + 2)) / 2 + *(old_cor + 2));
#line 352
  sub = (float )0.0;
#line 355
  i = *(old_cor + 2);
#line 356
  c = -1;
#line 358
  i = *(old_cor + 2);
  {
#line 358
  while (1) {
    while_continue: /* CIL Label */ ;
#line 358
    if (! (i < *(old_cor + 3))) {
#line 358
      goto while_break;
    }
    {
#line 360
    tmp = abs((int )(middle - (float )i));
#line 360
    sub = (float )tmp;
#line 361
    sub /= (float )1000;
    }
#line 363
    if (((f + i)->a + (b + i)->a) - sub > max) {
#line 364
      max = ((f + i)->a + (b + i)->a) - sub;
#line 366
      transition = 1;
#line 367
      c = i;
    }
#line 369
    if ((((f + i)->a + (b + i)->ga) - gpo) - sub > max) {
#line 370
      max = (((f + i)->a + (b + i)->ga) - gpo) - sub;
#line 372
      transition = 2;
#line 373
      c = i;
    }
#line 375
    if ((((f + i)->a + (b + i)->gb) - gpo) - sub > max) {
#line 376
      max = (((f + i)->a + (b + i)->gb) - gpo) - sub;
#line 378
      transition = 3;
#line 379
      c = i;
    }
#line 381
    if ((((f + i)->ga + (b + i)->a) - gpo) - sub > max) {
#line 382
      max = (((f + i)->ga + (b + i)->a) - gpo) - sub;
#line 384
      transition = 5;
#line 385
      c = i;
    }
#line 389
    if (hm->startb == 0) {
#line 390
      if ((((f + i)->gb + (b + i)->gb) - tgpe) - sub > max) {
#line 391
        max = (((f + i)->gb + (b + i)->gb) - tgpe) - sub;
#line 393
        transition = 6;
#line 394
        c = i;
      }
    } else
#line 397
    if ((((f + i)->gb + (b + i)->gb) - gpe) - sub > max) {
#line 398
      max = (((f + i)->gb + (b + i)->gb) - gpe) - sub;
#line 400
      transition = 6;
#line 401
      c = i;
    }
#line 404
    if ((((f + i)->gb + (b + i)->a) - gpo) - sub > max) {
#line 405
      max = (((f + i)->gb + (b + i)->a) - gpo) - sub;
#line 407
      transition = 7;
#line 408
      c = i;
    }
#line 358
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 412
  i = *(old_cor + 3);
#line 413
  tmp___0 = abs((int )(middle - (float )i));
#line 413
  sub = (float )tmp___0;
#line 414
  sub /= (float )1000;
  }
#line 416
  if ((((f + i)->a + (b + i)->gb) - gpo) - sub > max) {
#line 417
    max = (((f + i)->a + (b + i)->gb) - gpo) - sub;
#line 419
    transition = 3;
#line 420
    c = i;
  }
#line 422
  if (hm->endb == hm->len_b) {
#line 423
    if ((((f + i)->gb + (b + i)->gb) - tgpe) - sub > max) {
#line 424
      max = (((f + i)->gb + (b + i)->gb) - tgpe) - sub;
#line 426
      transition = 6;
#line 427
      c = i;
    }
  } else
#line 430
  if ((((f + i)->gb + (b + i)->gb) - gpe) - sub > max) {
#line 431
    max = (((f + i)->gb + (b + i)->gb) - gpe) - sub;
#line 433
    transition = 6;
#line 434
    c = i;
  }
#line 441
  j = *(hirsch_path + 0);
  {
#line 443
  if (transition == 1) {
#line 443
    goto case_1;
  }
#line 482
  if (transition == 2) {
#line 482
    goto case_2;
  }
#line 519
  if (transition == 3) {
#line 519
    goto case_3;
  }
#line 553
  if (transition == 5) {
#line 553
    goto case_5;
  }
#line 588
  if (transition == 6) {
#line 588
    goto case_6;
  }
#line 620
  if (transition == 7) {
#line 620
    goto case_7;
  }
#line 442
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 445
  *(hirsch_path + *(old_cor + 4)) = c;
#line 446
  *(hirsch_path + (*(old_cor + 4) + 1)) = c + 1;
#line 451
  (hm->f + 0)->a = *(input_states + 0);
#line 452
  (hm->f + 0)->ga = *(input_states + 1);
#line 453
  (hm->f + 0)->gb = *(input_states + 2);
#line 454
  (hm->b + 0)->a = (float )0.0;
#line 455
  (hm->b + 0)->ga = - 3.40282346638528859812e+38F;
#line 456
  (hm->b + 0)->gb = - 3.40282346638528859812e+38F;
#line 459
  hm->starta = *(old_cor + 0);
#line 460
  hm->enda = *(old_cor + 4) - 1;
#line 462
  hm->startb = *(old_cor + 2);
#line 463
  hm->endb = c - 1;
#line 465
  hirsch_path = hirsch_ss_dyn(subm, seq1, seq2, hm, hirsch_path);
#line 468
  hm->starta = *(old_cor + 4) + 1;
#line 469
  hm->enda = *(old_cor + 1);
#line 470
  hm->startb = c + 1;
#line 471
  hm->endb = *(old_cor + 3);
#line 472
  (hm->f + 0)->a = (float )0.0;
#line 473
  (hm->f + 0)->ga = - 3.40282346638528859812e+38F;
#line 474
  (hm->f + 0)->gb = - 3.40282346638528859812e+38F;
#line 475
  (hm->b + 0)->a = *(input_states + 3);
#line 476
  (hm->b + 0)->ga = *(input_states + 4);
#line 477
  (hm->b + 0)->gb = *(input_states + 5);
#line 480
  hirsch_path = hirsch_ss_dyn(subm, seq1, seq2, hm, hirsch_path);
  }
#line 481
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 484
  *(hirsch_path + *(old_cor + 4)) = c;
#line 487
  (hm->f + 0)->a = *(input_states + 0);
#line 488
  (hm->f + 0)->ga = *(input_states + 1);
#line 489
  (hm->f + 0)->gb = *(input_states + 2);
#line 490
  (hm->b + 0)->a = (float )0.0;
#line 491
  (hm->b + 0)->ga = - 3.40282346638528859812e+38F;
#line 492
  (hm->b + 0)->gb = - 3.40282346638528859812e+38F;
#line 495
  hm->starta = *(old_cor + 0);
#line 496
  hm->enda = *(old_cor + 4) - 1;
#line 498
  hm->startb = *(old_cor + 2);
#line 499
  hm->endb = c - 1;
#line 501
  hirsch_path = hirsch_ss_dyn(subm, seq1, seq2, hm, hirsch_path);
#line 505
  hm->starta = *(old_cor + 4);
#line 506
  hm->enda = *(old_cor + 1);
#line 507
  hm->startb = c + 1;
#line 508
  hm->endb = *(old_cor + 3);
#line 509
  (hm->f + 0)->a = - 3.40282346638528859812e+38F;
#line 510
  (hm->f + 0)->ga = (float )0.0;
#line 511
  (hm->f + 0)->gb = - 3.40282346638528859812e+38F;
#line 512
  (hm->b + 0)->a = *(input_states + 3);
#line 513
  (hm->b + 0)->ga = *(input_states + 4);
#line 514
  (hm->b + 0)->gb = *(input_states + 5);
#line 517
  hirsch_path = hirsch_ss_dyn(subm, seq1, seq2, hm, hirsch_path);
  }
#line 518
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 521
  *(hirsch_path + *(old_cor + 4)) = c;
#line 524
  (hm->f + 0)->a = *(input_states + 0);
#line 525
  (hm->f + 0)->ga = *(input_states + 1);
#line 526
  (hm->f + 0)->gb = *(input_states + 2);
#line 527
  (hm->b + 0)->a = (float )0.0;
#line 528
  (hm->b + 0)->ga = - 3.40282346638528859812e+38F;
#line 529
  (hm->b + 0)->gb = - 3.40282346638528859812e+38F;
#line 531
  hm->starta = *(old_cor + 0);
#line 532
  hm->enda = *(old_cor + 4) - 1;
#line 534
  hm->startb = *(old_cor + 2);
#line 535
  hm->endb = c - 1;
#line 537
  hirsch_path = hirsch_ss_dyn(subm, seq1, seq2, hm, hirsch_path);
#line 539
  hm->starta = *(old_cor + 4) + 1;
#line 540
  hm->enda = *(old_cor + 1);
#line 541
  hm->startb = c;
#line 542
  hm->endb = *(old_cor + 3);
#line 543
  (hm->f + 0)->a = - 3.40282346638528859812e+38F;
#line 544
  (hm->f + 0)->ga = - 3.40282346638528859812e+38F;
#line 545
  (hm->f + 0)->gb = (float )0.0;
#line 546
  (hm->b + 0)->a = *(input_states + 3);
#line 547
  (hm->b + 0)->ga = *(input_states + 4);
#line 548
  (hm->b + 0)->gb = *(input_states + 5);
#line 551
  hirsch_path = hirsch_ss_dyn(subm, seq1, seq2, hm, hirsch_path);
  }
#line 552
  goto switch_break;
  case_5: /* CIL Label */ 
  {
#line 554
  *(hirsch_path + (*(old_cor + 4) + 1)) = c + 1;
#line 558
  (hm->f + 0)->a = *(input_states + 0);
#line 559
  (hm->f + 0)->ga = *(input_states + 1);
#line 560
  (hm->f + 0)->gb = *(input_states + 2);
#line 561
  (hm->b + 0)->a = - 3.40282346638528859812e+38F;
#line 562
  (hm->b + 0)->ga = (float )0.0;
#line 563
  (hm->b + 0)->gb = - 3.40282346638528859812e+38F;
#line 565
  hm->starta = *(old_cor + 0);
#line 566
  hm->enda = *(old_cor + 4);
#line 568
  hm->startb = *(old_cor + 2);
#line 569
  hm->endb = c - 1;
#line 571
  hirsch_path = hirsch_ss_dyn(subm, seq1, seq2, hm, hirsch_path);
#line 574
  hm->starta = *(old_cor + 4) + 1;
#line 575
  hm->enda = *(old_cor + 1);
#line 576
  hm->startb = c + 1;
#line 577
  hm->endb = *(old_cor + 3);
#line 578
  (hm->f + 0)->a = (float )0.0;
#line 579
  (hm->f + 0)->ga = - 3.40282346638528859812e+38F;
#line 580
  (hm->f + 0)->gb = - 3.40282346638528859812e+38F;
#line 581
  (hm->b + 0)->a = *(input_states + 3);
#line 582
  (hm->b + 0)->ga = *(input_states + 4);
#line 583
  (hm->b + 0)->gb = *(input_states + 5);
#line 586
  hirsch_path = hirsch_ss_dyn(subm, seq1, seq2, hm, hirsch_path);
  }
#line 587
  goto switch_break;
  case_6: /* CIL Label */ 
  {
#line 591
  (hm->f + 0)->a = *(input_states + 0);
#line 592
  (hm->f + 0)->ga = *(input_states + 1);
#line 593
  (hm->f + 0)->gb = *(input_states + 2);
#line 594
  (hm->b + 0)->a = - 3.40282346638528859812e+38F;
#line 595
  (hm->b + 0)->ga = - 3.40282346638528859812e+38F;
#line 596
  (hm->b + 0)->gb = (float )0.0;
#line 598
  hm->starta = *(old_cor + 0);
#line 599
  hm->enda = *(old_cor + 4) - 1;
#line 600
  hm->startb = *(old_cor + 2);
#line 601
  hm->endb = c;
#line 603
  hirsch_path = hirsch_ss_dyn(subm, seq1, seq2, hm, hirsch_path);
#line 606
  hm->starta = *(old_cor + 4) + 1;
#line 607
  hm->enda = *(old_cor + 1);
#line 608
  hm->startb = c;
#line 609
  hm->endb = *(old_cor + 3);
#line 610
  (hm->f + 0)->a = - 3.40282346638528859812e+38F;
#line 611
  (hm->f + 0)->ga = - 3.40282346638528859812e+38F;
#line 612
  (hm->f + 0)->gb = (float )0.0;
#line 613
  (hm->b + 0)->a = *(input_states + 3);
#line 614
  (hm->b + 0)->ga = *(input_states + 4);
#line 615
  (hm->b + 0)->gb = *(input_states + 5);
#line 618
  hirsch_path = hirsch_ss_dyn(subm, seq1, seq2, hm, hirsch_path);
  }
#line 619
  goto switch_break;
  case_7: /* CIL Label */ 
  {
#line 622
  *(hirsch_path + (*(old_cor + 4) + 1)) = c + 1;
#line 625
  (hm->f + 0)->a = *(input_states + 0);
#line 626
  (hm->f + 0)->ga = *(input_states + 1);
#line 627
  (hm->f + 0)->gb = *(input_states + 2);
#line 628
  (hm->b + 0)->a = - 3.40282346638528859812e+38F;
#line 629
  (hm->b + 0)->ga = - 3.40282346638528859812e+38F;
#line 630
  (hm->b + 0)->gb = (float )0.0;
#line 632
  hm->starta = *(old_cor + 0);
#line 633
  hm->enda = *(old_cor + 4) - 1;
#line 634
  hm->startb = *(old_cor + 2);
#line 635
  hm->endb = c;
#line 637
  hirsch_path = hirsch_ss_dyn(subm, seq1, seq2, hm, hirsch_path);
#line 640
  hm->starta = *(old_cor + 4) + 1;
#line 641
  hm->enda = *(old_cor + 1);
#line 642
  hm->startb = c + 1;
#line 643
  hm->endb = *(old_cor + 3);
#line 644
  (hm->f + 0)->a = (float )0.0;
#line 645
  (hm->f + 0)->ga = - 3.40282346638528859812e+38F;
#line 646
  (hm->f + 0)->gb = - 3.40282346638528859812e+38F;
#line 647
  (hm->b + 0)->a = *(input_states + 3);
#line 648
  (hm->b + 0)->ga = *(input_states + 4);
#line 649
  (hm->b + 0)->gb = *(input_states + 5);
#line 652
  hirsch_path = hirsch_ss_dyn(subm, seq1, seq2, hm, hirsch_path);
  }
#line 653
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 656
  return (hirsch_path);
}
}
#line 661 "/home/june/repo/benchmarks/collector/temp/kalign-2.03+20110620/kalign2_hirschberg.c"
struct states *foward_hirsch_ss_dyn(float **subm , int const   *seq1 , int const   *seq2 ,
                                    struct hirsch_mem *hm ) 
{ 
  struct states *s ;
  float *subp ;
  int starta ;
  int enda ;
  int startb ;
  int endb ;
  register float pa ;
  register float pga ;
  register float pgb ;
  register float ca ;
  register float xa ;
  register float xga ;
  register int i ;
  register int j ;
  float tmp ;
  float tmp___0 ;
  float tmp___2 ;
  float tmp___3 ;
  float tmp___5 ;
  float tmp___6 ;
  float tmp___7 ;

  {
#line 663
  s = hm->f;
#line 664
  subp = (float *)0;
#line 665
  starta = hm->starta;
#line 666
  enda = hm->enda;
#line 667
  startb = hm->startb;
#line 668
  endb = hm->endb;
#line 669
  pa = (float )0;
#line 670
  pga = (float )0;
#line 671
  pgb = (float )0;
#line 672
  ca = (float )0;
#line 673
  xa = (float )0;
#line 674
  xga = (float )0;
#line 675
  i = 0;
#line 676
  j = 0;
#line 679
  (s + startb)->a = (s + 0)->a;
#line 680
  (s + startb)->ga = (s + 0)->ga;
#line 681
  (s + startb)->gb = (s + 0)->gb;
#line 682
  if (startb) {
#line 683
    j = startb + 1;
    {
#line 683
    while (1) {
      while_continue: /* CIL Label */ ;
#line 683
      if (! (j < endb)) {
#line 683
        goto while_break;
      }
#line 684
      (s + j)->a = - 3.40282346638528859812e+38F;
#line 685
      if ((s + (j - 1))->ga - gpe > (s + (j - 1))->a - gpo) {
#line 685
        (s + j)->ga = (s + (j - 1))->ga - gpe;
      } else {
#line 685
        (s + j)->ga = (s + (j - 1))->a - gpo;
      }
#line 686
      (s + j)->gb = - 3.40282346638528859812e+38F;
#line 683
      j ++;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 689
    j = startb + 1;
    {
#line 689
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 689
      if (! (j < endb)) {
#line 689
        goto while_break___0;
      }
#line 690
      (s + j)->a = - 3.40282346638528859812e+38F;
#line 691
      if ((s + (j - 1))->ga > (s + (j - 1))->a) {
#line 691
        tmp = (s + (j - 1))->ga;
      } else {
#line 691
        tmp = (s + (j - 1))->a;
      }
#line 691
      (s + j)->ga = tmp - tgpe;
#line 692
      (s + j)->gb = - 3.40282346638528859812e+38F;
#line 689
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 695
  (s + endb)->a = - 3.40282346638528859812e+38F;
#line 696
  (s + endb)->ga = - 3.40282346638528859812e+38F;
#line 697
  (s + endb)->gb = - 3.40282346638528859812e+38F;
#line 699
  seq2 --;
#line 700
  i = starta;
  {
#line 700
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 700
    if (! (i < enda)) {
#line 700
      goto while_break___1;
    }
#line 701
    subp = *(subm + *(seq1 + i));
#line 703
    pa = (s + startb)->a;
#line 704
    pga = (s + startb)->ga;
#line 705
    pgb = (s + startb)->gb;
#line 706
    (s + startb)->a = - 3.40282346638528859812e+38F;
#line 707
    (s + startb)->ga = - 3.40282346638528859812e+38F;
#line 709
    xa = (s + startb)->a;
#line 710
    xga = (s + startb)->ga;
#line 712
    if (startb) {
#line 713
      if (pgb - gpe > pa - gpo) {
#line 713
        (s + startb)->gb = pgb - gpe;
      } else {
#line 713
        (s + startb)->gb = pa - gpo;
      }
    } else {
#line 715
      if (pgb > pa) {
#line 715
        tmp___0 = pgb;
      } else {
#line 715
        tmp___0 = pa;
      }
#line 715
      (s + startb)->gb = tmp___0 - tgpe;
    }
#line 717
    j = startb + 1;
    {
#line 717
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 717
      if (! (j < endb)) {
#line 717
        goto while_break___2;
      }
#line 718
      ca = (s + j)->a;
#line 719
      if (pa > pga - gpo) {
#line 719
        tmp___3 = pa;
      } else {
#line 719
        tmp___3 = pga - gpo;
      }
#line 719
      if (tmp___3 > pgb - gpo) {
#line 719
        if (pa > pga - gpo) {
#line 719
          tmp___2 = pa;
        } else {
#line 719
          tmp___2 = pga - gpo;
        }
#line 719
        pa = tmp___2;
      } else {
#line 719
        pa = pgb - gpo;
      }
#line 720
      pa += *(subp + *(seq2 + j));
#line 722
      (s + j)->a = pa;
#line 724
      pga = (s + j)->ga;
#line 726
      if (xga - gpe > xa - gpo) {
#line 726
        (s + j)->ga = xga - gpe;
      } else {
#line 726
        (s + j)->ga = xa - gpo;
      }
#line 728
      pgb = (s + j)->gb;
#line 729
      if (pgb - gpe > ca - gpo) {
#line 729
        (s + j)->gb = pgb - gpe;
      } else {
#line 729
        (s + j)->gb = ca - gpo;
      }
#line 731
      pa = ca;
#line 733
      xa = (s + j)->a;
#line 734
      xga = (s + j)->ga;
#line 717
      j ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 737
    ca = (s + j)->a;
#line 738
    if (pa > pga - gpo) {
#line 738
      tmp___6 = pa;
    } else {
#line 738
      tmp___6 = pga - gpo;
    }
#line 738
    if (tmp___6 > pgb - gpo) {
#line 738
      if (pa > pga - gpo) {
#line 738
        tmp___5 = pa;
      } else {
#line 738
        tmp___5 = pga - gpo;
      }
#line 738
      pa = tmp___5;
    } else {
#line 738
      pa = pgb - gpo;
    }
#line 739
    pa += *(subp + *(seq2 + j));
#line 741
    (s + j)->a = pa;
#line 743
    (s + j)->ga = - 3.40282346638528859812e+38F;
#line 744
    if (endb != hm->len_b) {
#line 745
      if ((s + j)->gb - gpe > ca - gpo) {
#line 745
        (s + j)->gb -= gpe;
      } else {
#line 745
        (s + j)->gb = ca - gpo;
      }
    } else {
#line 747
      if ((s + j)->gb > ca) {
#line 747
        tmp___7 = (s + j)->gb;
      } else {
#line 747
        tmp___7 = ca;
      }
#line 747
      (s + j)->gb = tmp___7 - tgpe;
    }
#line 700
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 751
  return (s);
}
}
#line 754 "/home/june/repo/benchmarks/collector/temp/kalign-2.03+20110620/kalign2_hirschberg.c"
struct states *backward_hirsch_ss_dyn(float **subm , int const   *seq1 , int const   *seq2 ,
                                      struct hirsch_mem *hm ) 
{ 
  struct states *s ;
  float *subp ;
  int starta ;
  int enda ;
  int startb ;
  int endb ;
  register float pa ;
  register float pga ;
  register float pgb ;
  register float ca ;
  register float xa ;
  register float xga ;
  register int i ;
  register int j ;
  float tmp ;
  float tmp___0 ;
  float tmp___2 ;
  float tmp___3 ;
  float tmp___5 ;
  float tmp___6 ;
  float tmp___7 ;
  int tmp___8 ;

  {
#line 757
  s = hm->b;
#line 758
  subp = (float *)0;
#line 759
  starta = hm->starta;
#line 760
  enda = hm->enda;
#line 761
  startb = hm->startb;
#line 762
  endb = hm->endb;
#line 764
  pa = (float )0;
#line 765
  pga = (float )0;
#line 766
  pgb = (float )0;
#line 767
  ca = (float )0;
#line 769
  xa = (float )0;
#line 770
  xga = (float )0;
#line 772
  i = 0;
#line 773
  j = 0;
#line 775
  (s + endb)->a = (s + 0)->a;
#line 776
  (s + endb)->ga = (s + 0)->ga;
#line 777
  (s + endb)->gb = (s + 0)->gb;
#line 783
  if (endb != hm->len_b) {
#line 784
    j = endb - 1;
    {
#line 784
    while (1) {
      while_continue: /* CIL Label */ ;
#line 784
      if (! (j > startb)) {
#line 784
        goto while_break;
      }
#line 785
      (s + j)->a = - 3.40282346638528859812e+38F;
#line 786
      if ((s + (j + 1))->ga - gpe > (s + (j + 1))->a - gpo) {
#line 786
        (s + j)->ga = (s + (j + 1))->ga - gpe;
      } else {
#line 786
        (s + j)->ga = (s + (j + 1))->a - gpo;
      }
#line 787
      (s + j)->gb = - 3.40282346638528859812e+38F;
#line 784
      j --;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 790
    j = endb - 1;
    {
#line 790
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 790
      if (! (j > startb)) {
#line 790
        goto while_break___0;
      }
#line 791
      (s + j)->a = - 3.40282346638528859812e+38F;
#line 792
      if ((s + (j + 1))->ga > (s + (j + 1))->a) {
#line 792
        tmp = (s + (j + 1))->ga;
      } else {
#line 792
        tmp = (s + (j + 1))->a;
      }
#line 792
      (s + j)->ga = tmp - tgpe;
#line 793
      (s + j)->gb = - 3.40282346638528859812e+38F;
#line 790
      j --;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 798
  (s + startb)->a = - 3.40282346638528859812e+38F;
#line 799
  (s + startb)->ga = - 3.40282346638528859812e+38F;
#line 800
  (s + startb)->gb = - 3.40282346638528859812e+38F;
#line 802
  i = enda - starta;
#line 803
  seq1 += starta;
  {
#line 804
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 804
    tmp___8 = i;
#line 804
    i --;
#line 804
    if (! tmp___8) {
#line 804
      goto while_break___1;
    }
#line 805
    subp = *(subm + *(seq1 + i));
#line 806
    pa = (s + endb)->a;
#line 807
    pga = (s + endb)->ga;
#line 808
    pgb = (s + endb)->gb;
#line 809
    (s + endb)->a = - 3.40282346638528859812e+38F;
#line 810
    (s + endb)->ga = - 3.40282346638528859812e+38F;
#line 812
    xa = (s + endb)->a;
#line 813
    xga = (s + endb)->ga;
#line 815
    if (endb != hm->len_b) {
#line 816
      if (pgb - gpe > pa - gpo) {
#line 816
        (s + endb)->gb = pgb - gpe;
      } else {
#line 816
        (s + endb)->gb = pa - gpo;
      }
    } else {
#line 818
      if (pgb > pa) {
#line 818
        tmp___0 = pgb;
      } else {
#line 818
        tmp___0 = pa;
      }
#line 818
      (s + endb)->gb = tmp___0 - tgpe;
    }
#line 821
    j = endb - 1;
    {
#line 821
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 821
      if (! (j > startb)) {
#line 821
        goto while_break___2;
      }
#line 823
      ca = (s + j)->a;
#line 825
      if (pa > pga - gpo) {
#line 825
        tmp___3 = pa;
      } else {
#line 825
        tmp___3 = pga - gpo;
      }
#line 825
      if (tmp___3 > pgb - gpo) {
#line 825
        if (pa > pga - gpo) {
#line 825
          tmp___2 = pa;
        } else {
#line 825
          tmp___2 = pga - gpo;
        }
#line 825
        pa = tmp___2;
      } else {
#line 825
        pa = pgb - gpo;
      }
#line 827
      pa += *(subp + *(seq2 + j));
#line 829
      (s + j)->a = pa;
#line 831
      pga = (s + j)->ga;
#line 835
      if (xga - gpe > xa - gpo) {
#line 835
        (s + j)->ga = xga - gpe;
      } else {
#line 835
        (s + j)->ga = xa - gpo;
      }
#line 837
      pgb = (s + j)->gb;
#line 838
      if (pgb - gpe > ca - gpo) {
#line 838
        (s + j)->gb = pgb - gpe;
      } else {
#line 838
        (s + j)->gb = ca - gpo;
      }
#line 840
      pa = ca;
#line 841
      xa = (s + j)->a;
#line 842
      xga = (s + j)->ga;
#line 821
      j --;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 844
    ca = (s + j)->a;
#line 846
    if (pa > pga - gpo) {
#line 846
      tmp___6 = pa;
    } else {
#line 846
      tmp___6 = pga - gpo;
    }
#line 846
    if (tmp___6 > pgb - gpo) {
#line 846
      if (pa > pga - gpo) {
#line 846
        tmp___5 = pa;
      } else {
#line 846
        tmp___5 = pga - gpo;
      }
#line 846
      pa = tmp___5;
    } else {
#line 846
      pa = pgb - gpo;
    }
#line 848
    pa += *(subp + *(seq2 + j));
#line 850
    (s + j)->a = pa;
#line 852
    (s + j)->ga = - 3.40282346638528859812e+38F;
#line 854
    if (startb) {
#line 855
      if ((s + j)->gb - gpe > ca - gpo) {
#line 855
        (s + j)->gb -= gpe;
      } else {
#line 855
        (s + j)->gb = ca - gpo;
      }
    } else {
#line 857
      if ((s + j)->gb > ca) {
#line 857
        tmp___7 = (s + j)->gb;
      } else {
#line 857
        tmp___7 = ca;
      }
#line 857
      (s + j)->gb = tmp___7 - tgpe;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 862
  return (s);
}
}
#line 866 "/home/june/repo/benchmarks/collector/temp/kalign-2.03+20110620/kalign2_hirschberg.c"
int *hirsch_ps_dyn(float const   *prof1 , int const   *seq2 , struct hirsch_mem *hm ,
                   int *hirsch_path , int sip ) 
{ 
  int mid ;
  float input_states[6] ;
  int old_cor[5] ;

  {
#line 868
  mid = (hm->enda - hm->starta) / 2 + hm->starta;
#line 869
  input_states[0] = (hm->f + 0)->a;
#line 869
  input_states[1] = (hm->f + 0)->ga;
#line 869
  input_states[2] = (hm->f + 0)->gb;
#line 869
  input_states[3] = (hm->b + 0)->a;
#line 869
  input_states[4] = (hm->b + 0)->ga;
#line 869
  input_states[5] = (hm->b + 0)->gb;
#line 870
  old_cor[0] = hm->starta;
#line 870
  old_cor[1] = hm->enda;
#line 870
  old_cor[2] = hm->startb;
#line 870
  old_cor[3] = hm->endb;
#line 870
  old_cor[4] = mid;
#line 873
  if (hm->starta >= hm->enda) {
#line 874
    return (hirsch_path);
  }
#line 876
  if (hm->startb >= hm->endb) {
#line 877
    return (hirsch_path);
  }
  {
#line 880
  hm->enda = mid;
#line 881
  hm->f = foward_hirsch_ps_dyn(prof1, seq2, hm, sip);
#line 889
  hm->starta = mid;
#line 890
  hm->enda = old_cor[1];
#line 891
  hm->b = backward_hirsch_ps_dyn(prof1, seq2, hm, sip);
#line 898
  hirsch_path = hirsch_align_two_ps_vector(prof1, seq2, hm, hirsch_path, input_states,
                                           old_cor, sip);
  }
#line 899
  return (hirsch_path);
}
}
#line 904 "/home/june/repo/benchmarks/collector/temp/kalign-2.03+20110620/kalign2_hirschberg.c"
int *hirsch_align_two_ps_vector(float const   *prof1 , int const   *seq2 , struct hirsch_mem *hm ,
                                int *hirsch_path , float *input_states , int *old_cor ,
                                int sip ) 
{ 
  struct states *f ;
  struct states *b ;
  int i ;
  int j ;
  int c ;
  int transition ;
  float open ;
  float max ;
  float middle ;
  float sub ;
  int tmp ;
  int tmp___0 ;

  {
#line 906
  f = hm->f;
#line 907
  b = hm->b;
#line 909
  transition = -1;
#line 911
  open = gpo * (float )sip;
#line 924
  max = - 3.40282346638528859812e+38F;
#line 926
  middle = (float )((*(old_cor + 3) - *(old_cor + 2)) / 2 + *(old_cor + 2));
#line 927
  sub = (float )0.0;
#line 930
  prof1 += (*(old_cor + 4) + 1) << 6;
#line 933
  i = *(old_cor + 2);
#line 934
  c = -1;
#line 936
  i = *(old_cor + 2);
  {
#line 936
  while (1) {
    while_continue: /* CIL Label */ ;
#line 936
    if (! (i < *(old_cor + 3))) {
#line 936
      goto while_break;
    }
    {
#line 937
    tmp = abs((int )(middle - (float )i));
#line 937
    sub = (float )tmp;
#line 938
    sub /= (float )1000;
    }
#line 939
    if (((f + i)->a + (b + i)->a) - sub > max) {
#line 940
      max = ((f + i)->a + (b + i)->a) - sub;
#line 942
      transition = 1;
#line 943
      c = i;
    }
#line 945
    if ((((f + i)->a + (b + i)->ga) - open) - sub > max) {
#line 946
      max = (((f + i)->a + (b + i)->ga) - open) - sub;
#line 948
      transition = 2;
#line 949
      c = i;
    }
#line 951
    if ((((f + i)->a + (b + i)->gb) + (float )*(prof1 + 27)) - sub > max) {
#line 952
      max = (((f + i)->a + (b + i)->gb) + (float )*(prof1 + 27)) - sub;
#line 954
      transition = 3;
#line 955
      c = i;
    }
#line 957
    if ((((f + i)->ga + (b + i)->a) - open) - sub > max) {
#line 958
      max = (((f + i)->ga + (b + i)->a) - open) - sub;
#line 960
      transition = 5;
#line 961
      c = i;
    }
#line 965
    if (hm->startb == 0) {
#line 966
      if ((((f + i)->gb + (b + i)->gb) + (float )*(prof1 + 29)) - sub > max) {
#line 967
        max = (((f + i)->gb + (b + i)->gb) + (float )*(prof1 + 29)) - sub;
#line 969
        transition = 6;
#line 970
        c = i;
      }
    } else
#line 973
    if ((((f + i)->gb + (b + i)->gb) + (float )*(prof1 + 28)) - sub > max) {
#line 974
      max = (((f + i)->gb + (b + i)->gb) + (float )*(prof1 + 28)) - sub;
#line 976
      transition = 6;
#line 977
      c = i;
    }
#line 980
    if ((((f + i)->gb + (b + i)->a) + (float )*(prof1 + -37)) - sub > max) {
#line 981
      max = (((f + i)->gb + (b + i)->a) + (float )*(prof1 + -37)) - sub;
#line 983
      transition = 7;
#line 984
      c = i;
    }
#line 936
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 988
  i = *(old_cor + 3);
#line 990
  tmp___0 = abs((int )(middle - (float )i));
#line 990
  sub = (float )tmp___0;
#line 991
  sub /= (float )1000;
  }
#line 992
  if ((((f + i)->a + (b + i)->gb) + (float )*(prof1 + 27)) - sub > max) {
#line 993
    max = (((f + i)->a + (b + i)->gb) + (float )*(prof1 + 27)) - sub;
#line 995
    transition = 3;
#line 996
    c = i;
  }
#line 998
  if (hm->endb == hm->len_b) {
#line 999
    if ((((f + i)->gb + (b + i)->gb) + (float )*(prof1 + 29)) - sub > max) {
#line 1000
      max = (((f + i)->gb + (b + i)->gb) + (float )*(prof1 + 29)) - sub;
#line 1002
      transition = 6;
#line 1003
      c = i;
    }
  } else
#line 1006
  if ((((f + i)->gb + (b + i)->gb) + (float )*(prof1 + 28)) - sub > max) {
#line 1007
    max = (((f + i)->gb + (b + i)->gb) + (float )*(prof1 + 28)) - sub;
#line 1009
    transition = 6;
#line 1010
    c = i;
  }
#line 1016
  prof1 -= (*(old_cor + 4) + 1) << 6;
#line 1020
  j = *(hirsch_path + 0);
  {
#line 1022
  if (transition == 1) {
#line 1022
    goto case_1;
  }
#line 1061
  if (transition == 2) {
#line 1061
    goto case_2;
  }
#line 1097
  if (transition == 3) {
#line 1097
    goto case_3;
  }
#line 1132
  if (transition == 5) {
#line 1132
    goto case_5;
  }
#line 1167
  if (transition == 6) {
#line 1167
    goto case_6;
  }
#line 1200
  if (transition == 7) {
#line 1200
    goto case_7;
  }
#line 1021
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 1024
  *(hirsch_path + *(old_cor + 4)) = c;
#line 1025
  *(hirsch_path + (*(old_cor + 4) + 1)) = c + 1;
#line 1030
  (hm->f + 0)->a = *(input_states + 0);
#line 1031
  (hm->f + 0)->ga = *(input_states + 1);
#line 1032
  (hm->f + 0)->gb = *(input_states + 2);
#line 1033
  (hm->b + 0)->a = (float )0.0;
#line 1034
  (hm->b + 0)->ga = - 3.40282346638528859812e+38F;
#line 1035
  (hm->b + 0)->gb = - 3.40282346638528859812e+38F;
#line 1038
  hm->starta = *(old_cor + 0);
#line 1039
  hm->enda = *(old_cor + 4) - 1;
#line 1041
  hm->startb = *(old_cor + 2);
#line 1042
  hm->endb = c - 1;
#line 1044
  hirsch_path = hirsch_ps_dyn(prof1, seq2, hm, hirsch_path, sip);
#line 1047
  hm->starta = *(old_cor + 4) + 1;
#line 1048
  hm->enda = *(old_cor + 1);
#line 1049
  hm->startb = c + 1;
#line 1050
  hm->endb = *(old_cor + 3);
#line 1051
  (hm->f + 0)->a = (float )0.0;
#line 1052
  (hm->f + 0)->ga = - 3.40282346638528859812e+38F;
#line 1053
  (hm->f + 0)->gb = - 3.40282346638528859812e+38F;
#line 1054
  (hm->b + 0)->a = *(input_states + 3);
#line 1055
  (hm->b + 0)->ga = *(input_states + 4);
#line 1056
  (hm->b + 0)->gb = *(input_states + 5);
#line 1059
  hirsch_path = hirsch_ps_dyn(prof1, seq2, hm, hirsch_path, sip);
  }
#line 1060
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 1063
  *(hirsch_path + *(old_cor + 4)) = c;
#line 1066
  (hm->f + 0)->a = *(input_states + 0);
#line 1067
  (hm->f + 0)->ga = *(input_states + 1);
#line 1068
  (hm->f + 0)->gb = *(input_states + 2);
#line 1069
  (hm->b + 0)->a = (float )0.0;
#line 1070
  (hm->b + 0)->ga = - 3.40282346638528859812e+38F;
#line 1071
  (hm->b + 0)->gb = - 3.40282346638528859812e+38F;
#line 1074
  hm->starta = *(old_cor + 0);
#line 1075
  hm->enda = *(old_cor + 4) - 1;
#line 1077
  hm->startb = *(old_cor + 2);
#line 1078
  hm->endb = c - 1;
#line 1080
  hirsch_path = hirsch_ps_dyn(prof1, seq2, hm, hirsch_path, sip);
#line 1083
  hm->starta = *(old_cor + 4);
#line 1084
  hm->enda = *(old_cor + 1);
#line 1085
  hm->startb = c + 1;
#line 1086
  hm->endb = *(old_cor + 3);
#line 1087
  (hm->f + 0)->a = - 3.40282346638528859812e+38F;
#line 1088
  (hm->f + 0)->ga = (float )0.0;
#line 1089
  (hm->f + 0)->gb = - 3.40282346638528859812e+38F;
#line 1090
  (hm->b + 0)->a = *(input_states + 3);
#line 1091
  (hm->b + 0)->ga = *(input_states + 4);
#line 1092
  (hm->b + 0)->gb = *(input_states + 5);
#line 1095
  hirsch_path = hirsch_ps_dyn(prof1, seq2, hm, hirsch_path, sip);
  }
#line 1096
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 1099
  *(hirsch_path + *(old_cor + 4)) = c;
#line 1102
  (hm->f + 0)->a = *(input_states + 0);
#line 1103
  (hm->f + 0)->ga = *(input_states + 1);
#line 1104
  (hm->f + 0)->gb = *(input_states + 2);
#line 1105
  (hm->b + 0)->a = (float )0.0;
#line 1106
  (hm->b + 0)->ga = - 3.40282346638528859812e+38F;
#line 1107
  (hm->b + 0)->gb = - 3.40282346638528859812e+38F;
#line 1109
  hm->starta = *(old_cor + 0);
#line 1110
  hm->enda = *(old_cor + 4) - 1;
#line 1112
  hm->startb = *(old_cor + 2);
#line 1113
  hm->endb = c - 1;
#line 1115
  hirsch_path = hirsch_ps_dyn(prof1, seq2, hm, hirsch_path, sip);
#line 1118
  hm->starta = *(old_cor + 4) + 1;
#line 1119
  hm->enda = *(old_cor + 1);
#line 1120
  hm->startb = c;
#line 1121
  hm->endb = *(old_cor + 3);
#line 1122
  (hm->f + 0)->a = - 3.40282346638528859812e+38F;
#line 1123
  (hm->f + 0)->ga = - 3.40282346638528859812e+38F;
#line 1124
  (hm->f + 0)->gb = (float )0.0;
#line 1125
  (hm->b + 0)->a = *(input_states + 3);
#line 1126
  (hm->b + 0)->ga = *(input_states + 4);
#line 1127
  (hm->b + 0)->gb = *(input_states + 5);
#line 1130
  hirsch_path = hirsch_ps_dyn(prof1, seq2, hm, hirsch_path, sip);
  }
#line 1131
  goto switch_break;
  case_5: /* CIL Label */ 
  {
#line 1133
  *(hirsch_path + (*(old_cor + 4) + 1)) = c + 1;
#line 1137
  (hm->f + 0)->a = *(input_states + 0);
#line 1138
  (hm->f + 0)->ga = *(input_states + 1);
#line 1139
  (hm->f + 0)->gb = *(input_states + 2);
#line 1140
  (hm->b + 0)->a = - 3.40282346638528859812e+38F;
#line 1141
  (hm->b + 0)->ga = (float )0.0;
#line 1142
  (hm->b + 0)->gb = - 3.40282346638528859812e+38F;
#line 1144
  hm->starta = *(old_cor + 0);
#line 1145
  hm->enda = *(old_cor + 4);
#line 1147
  hm->startb = *(old_cor + 2);
#line 1148
  hm->endb = c - 1;
#line 1150
  hirsch_path = hirsch_ps_dyn(prof1, seq2, hm, hirsch_path, sip);
#line 1153
  hm->starta = *(old_cor + 4) + 1;
#line 1154
  hm->enda = *(old_cor + 1);
#line 1155
  hm->startb = c + 1;
#line 1156
  hm->endb = *(old_cor + 3);
#line 1157
  (hm->f + 0)->a = (float )0.0;
#line 1158
  (hm->f + 0)->ga = - 3.40282346638528859812e+38F;
#line 1159
  (hm->f + 0)->gb = - 3.40282346638528859812e+38F;
#line 1160
  (hm->b + 0)->a = *(input_states + 3);
#line 1161
  (hm->b + 0)->ga = *(input_states + 4);
#line 1162
  (hm->b + 0)->gb = *(input_states + 5);
#line 1165
  hirsch_path = hirsch_ps_dyn(prof1, seq2, hm, hirsch_path, sip);
  }
#line 1166
  goto switch_break;
  case_6: /* CIL Label */ 
  {
#line 1170
  (hm->f + 0)->a = *(input_states + 0);
#line 1171
  (hm->f + 0)->ga = *(input_states + 1);
#line 1172
  (hm->f + 0)->gb = *(input_states + 2);
#line 1173
  (hm->b + 0)->a = - 3.40282346638528859812e+38F;
#line 1174
  (hm->b + 0)->ga = - 3.40282346638528859812e+38F;
#line 1175
  (hm->b + 0)->gb = (float )0.0;
#line 1177
  hm->starta = *(old_cor + 0);
#line 1178
  hm->enda = *(old_cor + 4) - 1;
#line 1179
  hm->startb = *(old_cor + 2);
#line 1180
  hm->endb = c;
#line 1182
  hirsch_path = hirsch_ps_dyn(prof1, seq2, hm, hirsch_path, sip);
#line 1186
  hm->starta = *(old_cor + 4) + 1;
#line 1187
  hm->enda = *(old_cor + 1);
#line 1188
  hm->startb = c;
#line 1189
  hm->endb = *(old_cor + 3);
#line 1190
  (hm->f + 0)->a = - 3.40282346638528859812e+38F;
#line 1191
  (hm->f + 0)->ga = - 3.40282346638528859812e+38F;
#line 1192
  (hm->f + 0)->gb = (float )0.0;
#line 1193
  (hm->b + 0)->a = *(input_states + 3);
#line 1194
  (hm->b + 0)->ga = *(input_states + 4);
#line 1195
  (hm->b + 0)->gb = *(input_states + 5);
#line 1198
  hirsch_path = hirsch_ps_dyn(prof1, seq2, hm, hirsch_path, sip);
  }
#line 1199
  goto switch_break;
  case_7: /* CIL Label */ 
  {
#line 1202
  *(hirsch_path + (*(old_cor + 4) + 1)) = c + 1;
#line 1205
  (hm->f + 0)->a = *(input_states + 0);
#line 1206
  (hm->f + 0)->ga = *(input_states + 1);
#line 1207
  (hm->f + 0)->gb = *(input_states + 2);
#line 1208
  (hm->b + 0)->a = - 3.40282346638528859812e+38F;
#line 1209
  (hm->b + 0)->ga = - 3.40282346638528859812e+38F;
#line 1210
  (hm->b + 0)->gb = (float )0.0;
#line 1212
  hm->starta = *(old_cor + 0);
#line 1213
  hm->enda = *(old_cor + 4) - 1;
#line 1214
  hm->startb = *(old_cor + 2);
#line 1215
  hm->endb = c;
#line 1217
  hirsch_path = hirsch_ps_dyn(prof1, seq2, hm, hirsch_path, sip);
#line 1220
  hm->starta = *(old_cor + 4) + 1;
#line 1221
  hm->enda = *(old_cor + 1);
#line 1222
  hm->startb = c + 1;
#line 1223
  hm->endb = *(old_cor + 3);
#line 1224
  (hm->f + 0)->a = (float )0.0;
#line 1225
  (hm->f + 0)->ga = - 3.40282346638528859812e+38F;
#line 1226
  (hm->f + 0)->gb = - 3.40282346638528859812e+38F;
#line 1227
  (hm->b + 0)->a = *(input_states + 3);
#line 1228
  (hm->b + 0)->ga = *(input_states + 4);
#line 1229
  (hm->b + 0)->gb = *(input_states + 5);
#line 1232
  hirsch_path = hirsch_ps_dyn(prof1, seq2, hm, hirsch_path, sip);
  }
#line 1233
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1236
  return (hirsch_path);
}
}
#line 1239 "/home/june/repo/benchmarks/collector/temp/kalign-2.03+20110620/kalign2_hirschberg.c"
struct states *foward_hirsch_ps_dyn(float const   *prof1 , int const   *seq2 , struct hirsch_mem *hm ,
                                    int sip ) 
{ 
  struct states *s ;
  register float pa ;
  register float pga ;
  register float pgb ;
  register float ca ;
  register float xa ;
  register float xga ;
  register int i ;
  register int j ;
  float open ;
  float ext ;
  float text ;
  float tmp ;
  float tmp___0 ;
  float tmp___2 ;
  float tmp___3 ;
  float tmp___5 ;
  float tmp___6 ;
  float tmp___7 ;

  {
#line 1241
  s = hm->f;
#line 1243
  pa = (float )0;
#line 1244
  pga = (float )0;
#line 1245
  pgb = (float )0;
#line 1246
  ca = (float )0;
#line 1248
  xa = (float )0;
#line 1249
  xga = (float )0;
#line 1251
  i = 0;
#line 1252
  j = 0;
#line 1254
  open = gpo * (float )sip;
#line 1255
  ext = gpe * (float )sip;
#line 1256
  text = tgpe * (float )sip;
#line 1260
  prof1 += hm->starta << 6;
#line 1261
  (s + hm->startb)->a = (s + 0)->a;
#line 1262
  (s + hm->startb)->ga = (s + 0)->ga;
#line 1263
  (s + hm->startb)->gb = (s + 0)->gb;
#line 1264
  if (hm->startb) {
#line 1265
    j = hm->startb + 1;
    {
#line 1265
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1265
      if (! (j < hm->endb)) {
#line 1265
        goto while_break;
      }
#line 1266
      (s + j)->a = - 3.40282346638528859812e+38F;
#line 1267
      if ((s + (j - 1))->ga - ext > (s + (j - 1))->a - open) {
#line 1267
        (s + j)->ga = (s + (j - 1))->ga - ext;
      } else {
#line 1267
        (s + j)->ga = (s + (j - 1))->a - open;
      }
#line 1268
      (s + j)->gb = - 3.40282346638528859812e+38F;
#line 1265
      j ++;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 1271
    j = hm->startb + 1;
    {
#line 1271
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1271
      if (! (j < hm->endb)) {
#line 1271
        goto while_break___0;
      }
#line 1272
      (s + j)->a = - 3.40282346638528859812e+38F;
#line 1273
      if ((s + (j - 1))->ga > (s + (j - 1))->a) {
#line 1273
        tmp = (s + (j - 1))->ga;
      } else {
#line 1273
        tmp = (s + (j - 1))->a;
      }
#line 1273
      (s + j)->ga = tmp - text;
#line 1274
      (s + j)->gb = - 3.40282346638528859812e+38F;
#line 1271
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 1280
  (s + hm->endb)->a = - 3.40282346638528859812e+38F;
#line 1281
  (s + hm->endb)->ga = - 3.40282346638528859812e+38F;
#line 1282
  (s + hm->endb)->gb = - 3.40282346638528859812e+38F;
#line 1283
  seq2 --;
#line 1285
  i = hm->starta;
  {
#line 1285
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1285
    if (! (i < hm->enda)) {
#line 1285
      goto while_break___1;
    }
#line 1286
    prof1 += 64;
#line 1288
    pa = (s + hm->startb)->a;
#line 1289
    pga = (s + hm->startb)->ga;
#line 1290
    pgb = (s + hm->startb)->gb;
#line 1291
    (s + hm->startb)->a = - 3.40282346638528859812e+38F;
#line 1292
    (s + hm->startb)->ga = - 3.40282346638528859812e+38F;
#line 1294
    xa = (s + hm->startb)->a;
#line 1295
    xga = (s + hm->startb)->ga;
#line 1298
    if (hm->startb) {
#line 1299
      if (pgb + (float )*(prof1 + 28) > pa + (float )*(prof1 + 27)) {
#line 1299
        (s + hm->startb)->gb = pgb + (float )*(prof1 + 28);
      } else {
#line 1299
        (s + hm->startb)->gb = pa + (float )*(prof1 + 27);
      }
    } else {
#line 1301
      if (pgb > pa) {
#line 1301
        tmp___0 = pgb;
      } else {
#line 1301
        tmp___0 = pa;
      }
#line 1301
      (s + hm->startb)->gb = tmp___0 + (float )*(prof1 + 29);
    }
#line 1303
    j = hm->startb + 1;
    {
#line 1303
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1303
      if (! (j < hm->endb)) {
#line 1303
        goto while_break___2;
      }
#line 1304
      ca = (s + j)->a;
#line 1306
      if (pa > pga - open) {
#line 1306
        tmp___3 = pa;
      } else {
#line 1306
        tmp___3 = pga - open;
      }
#line 1306
      if (tmp___3 > pgb + (float )*(prof1 + -37)) {
#line 1306
        if (pa > pga - open) {
#line 1306
          tmp___2 = pa;
        } else {
#line 1306
          tmp___2 = pga - open;
        }
#line 1306
        pa = tmp___2;
      } else {
#line 1306
        pa = pgb + (float )*(prof1 + -37);
      }
#line 1308
      pa += (float )*(prof1 + (32 + (int )*(seq2 + j)));
#line 1311
      (s + j)->a = pa;
#line 1313
      pga = (s + j)->ga;
#line 1316
      if (xga - ext > xa - open) {
#line 1316
        (s + j)->ga = xga - ext;
      } else {
#line 1316
        (s + j)->ga = xa - open;
      }
#line 1319
      pgb = (s + j)->gb;
#line 1321
      if (pgb + (float )*(prof1 + 28) > ca + (float )*(prof1 + 27)) {
#line 1321
        (s + j)->gb = pgb + (float )*(prof1 + 28);
      } else {
#line 1321
        (s + j)->gb = ca + (float )*(prof1 + 27);
      }
#line 1323
      pa = ca;
#line 1324
      xa = (s + j)->a;
#line 1325
      xga = (s + j)->ga;
#line 1303
      j ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 1328
    ca = (s + j)->a;
#line 1330
    if (pa > pga - open) {
#line 1330
      tmp___6 = pa;
    } else {
#line 1330
      tmp___6 = pga - open;
    }
#line 1330
    if (tmp___6 > pgb + (float )*(prof1 + -37)) {
#line 1330
      if (pa > pga - open) {
#line 1330
        tmp___5 = pa;
      } else {
#line 1330
        tmp___5 = pga - open;
      }
#line 1330
      pa = tmp___5;
    } else {
#line 1330
      pa = pgb + (float )*(prof1 + -37);
    }
#line 1332
    pa += (float )*(prof1 + (32 + (int )*(seq2 + j)));
#line 1335
    (s + j)->a = pa;
#line 1337
    (s + j)->ga = - 3.40282346638528859812e+38F;
#line 1339
    if (hm->endb != hm->len_b) {
#line 1340
      if ((s + j)->gb + (float )*(prof1 + 28) > ca + (float )*(prof1 + 27)) {
#line 1340
        (s + j)->gb += (float )*(prof1 + 28);
      } else {
#line 1340
        (s + j)->gb = ca + (float )*(prof1 + 27);
      }
    } else {
#line 1342
      if ((s + j)->gb > ca) {
#line 1342
        tmp___7 = (s + j)->gb;
      } else {
#line 1342
        tmp___7 = ca;
      }
#line 1342
      (s + j)->gb = tmp___7 + (float )*(prof1 + 29);
    }
#line 1285
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1346
  prof1 -= hm->enda << 6;
#line 1347
  return (s);
}
}
#line 1350 "/home/june/repo/benchmarks/collector/temp/kalign-2.03+20110620/kalign2_hirschberg.c"
struct states *backward_hirsch_ps_dyn(float const   *prof1 , int const   *seq2 , struct hirsch_mem *hm ,
                                      int sip ) 
{ 
  struct states *s ;
  register float pa ;
  register float pga ;
  register float pgb ;
  register float ca ;
  register float xa ;
  register float xga ;
  register int i ;
  register int j ;
  float open ;
  float ext ;
  float text ;
  float tmp ;
  float tmp___0 ;
  float tmp___2 ;
  float tmp___3 ;
  float tmp___5 ;
  float tmp___6 ;
  float tmp___7 ;
  int tmp___8 ;

  {
#line 1352
  s = hm->b;
#line 1353
  pa = (float )0;
#line 1354
  pga = (float )0;
#line 1355
  pgb = (float )0;
#line 1356
  ca = (float )0;
#line 1358
  xa = (float )0;
#line 1359
  xga = (float )0;
#line 1361
  i = 0;
#line 1362
  j = 0;
#line 1364
  open = gpo * (float )sip;
#line 1365
  ext = gpe * (float )sip;
#line 1366
  text = tgpe * (float )sip;
#line 1369
  prof1 += (hm->enda + 1) << 6;
#line 1371
  (s + hm->endb)->a = (s + 0)->a;
#line 1372
  (s + hm->endb)->ga = (s + 0)->ga;
#line 1373
  (s + hm->endb)->gb = (s + 0)->gb;
#line 1375
  if (hm->endb != hm->len_b) {
#line 1376
    j = hm->endb - 1;
    {
#line 1376
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1376
      if (! (j > hm->startb)) {
#line 1376
        goto while_break;
      }
#line 1377
      (s + j)->a = - 3.40282346638528859812e+38F;
#line 1378
      if ((s + (j + 1))->ga - ext > (s + (j + 1))->a - open) {
#line 1378
        (s + j)->ga = (s + (j + 1))->ga - ext;
      } else {
#line 1378
        (s + j)->ga = (s + (j + 1))->a - open;
      }
#line 1379
      (s + j)->gb = - 3.40282346638528859812e+38F;
#line 1376
      j --;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 1382
    j = hm->endb - 1;
    {
#line 1382
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1382
      if (! (j > hm->startb)) {
#line 1382
        goto while_break___0;
      }
#line 1383
      (s + j)->a = - 3.40282346638528859812e+38F;
#line 1384
      if ((s + (j + 1))->ga > (s + (j + 1))->a) {
#line 1384
        tmp = (s + (j + 1))->ga;
      } else {
#line 1384
        tmp = (s + (j + 1))->a;
      }
#line 1384
      (s + j)->ga = tmp - text;
#line 1385
      (s + j)->gb = - 3.40282346638528859812e+38F;
#line 1382
      j --;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 1389
  (s + hm->startb)->a = - 3.40282346638528859812e+38F;
#line 1390
  (s + hm->startb)->ga = - 3.40282346638528859812e+38F;
#line 1391
  (s + hm->startb)->gb = - 3.40282346638528859812e+38F;
#line 1393
  i = hm->enda - hm->starta;
  {
#line 1394
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1394
    tmp___8 = i;
#line 1394
    i --;
#line 1394
    if (! tmp___8) {
#line 1394
      goto while_break___1;
    }
#line 1395
    prof1 -= 64;
#line 1396
    pa = (s + hm->endb)->a;
#line 1397
    pga = (s + hm->endb)->ga;
#line 1398
    pgb = (s + hm->endb)->gb;
#line 1399
    (s + hm->endb)->a = - 3.40282346638528859812e+38F;
#line 1400
    (s + hm->endb)->ga = - 3.40282346638528859812e+38F;
#line 1402
    xa = (s + hm->endb)->a;
#line 1403
    xga = (s + hm->endb)->ga;
#line 1406
    if (hm->endb != hm->len_b) {
#line 1407
      if (pgb + (float )*(prof1 + 28) > pa + (float )*(prof1 + 27)) {
#line 1407
        (s + hm->endb)->gb = pgb + (float )*(prof1 + 28);
      } else {
#line 1407
        (s + hm->endb)->gb = pa + (float )*(prof1 + 27);
      }
    } else {
#line 1409
      if (pgb > pa) {
#line 1409
        tmp___0 = pgb;
      } else {
#line 1409
        tmp___0 = pa;
      }
#line 1409
      (s + hm->endb)->gb = tmp___0 + (float )*(prof1 + 29);
    }
#line 1412
    j = hm->endb - 1;
    {
#line 1412
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1412
      if (! (j > hm->startb)) {
#line 1412
        goto while_break___2;
      }
#line 1413
      ca = (s + j)->a;
#line 1415
      if (pa > pga - open) {
#line 1415
        tmp___3 = pa;
      } else {
#line 1415
        tmp___3 = pga - open;
      }
#line 1415
      if (tmp___3 > pgb + (float )*(prof1 + 91)) {
#line 1415
        if (pa > pga - open) {
#line 1415
          tmp___2 = pa;
        } else {
#line 1415
          tmp___2 = pga - open;
        }
#line 1415
        pa = tmp___2;
      } else {
#line 1415
        pa = pgb + (float )*(prof1 + 91);
      }
#line 1416
      pa += (float )*(prof1 + (32 + (int )*(seq2 + j)));
#line 1418
      (s + j)->a = pa;
#line 1420
      pga = (s + j)->ga;
#line 1423
      if (xga - ext > xa - open) {
#line 1423
        (s + j)->ga = xga - ext;
      } else {
#line 1423
        (s + j)->ga = xa - open;
      }
#line 1425
      pgb = (s + j)->gb;
#line 1427
      if (pgb + (float )*(prof1 + 28) > ca + (float )*(prof1 + 27)) {
#line 1427
        (s + j)->gb = pgb + (float )*(prof1 + 28);
      } else {
#line 1427
        (s + j)->gb = ca + (float )*(prof1 + 27);
      }
#line 1429
      pa = ca;
#line 1430
      xa = (s + j)->a;
#line 1431
      xga = (s + j)->ga;
#line 1412
      j --;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 1435
    ca = (s + j)->a;
#line 1437
    if (pa > pga - open) {
#line 1437
      tmp___6 = pa;
    } else {
#line 1437
      tmp___6 = pga - open;
    }
#line 1437
    if (tmp___6 > pgb + (float )*(prof1 + 91)) {
#line 1437
      if (pa > pga - open) {
#line 1437
        tmp___5 = pa;
      } else {
#line 1437
        tmp___5 = pga - open;
      }
#line 1437
      pa = tmp___5;
    } else {
#line 1437
      pa = pgb + (float )*(prof1 + 91);
    }
#line 1438
    pa += (float )*(prof1 + (32 + (int )*(seq2 + j)));
#line 1440
    (s + j)->a = pa;
#line 1443
    (s + j)->ga = - 3.40282346638528859812e+38F;
#line 1444
    if (hm->startb) {
#line 1445
      if ((s + j)->gb + (float )*(prof1 + 28) > ca + (float )*(prof1 + 27)) {
#line 1445
        (s + j)->gb += (float )*(prof1 + 28);
      } else {
#line 1445
        (s + j)->gb = ca + (float )*(prof1 + 27);
      }
    } else {
#line 1447
      if ((s + j)->gb > ca) {
#line 1447
        tmp___7 = (s + j)->gb;
      } else {
#line 1447
        tmp___7 = ca;
      }
#line 1447
      (s + j)->gb = tmp___7 + (float )*(prof1 + 29);
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1451
  return (s);
}
}
#line 1457 "/home/june/repo/benchmarks/collector/temp/kalign-2.03+20110620/kalign2_hirschberg.c"
int *hirsch_pp_dyn(float const   *prof1 , float const   *prof2 , struct hirsch_mem *hm ,
                   int *hirsch_path ) 
{ 
  int mid ;
  float input_states[6] ;
  int old_cor[5] ;

  {
#line 1459
  mid = (hm->enda - hm->starta) / 2 + hm->starta;
#line 1460
  input_states[0] = (hm->f + 0)->a;
#line 1460
  input_states[1] = (hm->f + 0)->ga;
#line 1460
  input_states[2] = (hm->f + 0)->gb;
#line 1460
  input_states[3] = (hm->b + 0)->a;
#line 1460
  input_states[4] = (hm->b + 0)->ga;
#line 1460
  input_states[5] = (hm->b + 0)->gb;
#line 1461
  old_cor[0] = hm->starta;
#line 1461
  old_cor[1] = hm->enda;
#line 1461
  old_cor[2] = hm->startb;
#line 1461
  old_cor[3] = hm->endb;
#line 1461
  old_cor[4] = mid;
#line 1467
  if (hm->starta >= hm->enda) {
#line 1468
    return (hirsch_path);
  }
#line 1470
  if (hm->startb >= hm->endb) {
#line 1471
    return (hirsch_path);
  }
  {
#line 1474
  hm->enda = mid;
#line 1475
  hm->f = foward_hirsch_pp_dyn(prof1, prof2, hm);
#line 1482
  hm->starta = mid;
#line 1483
  hm->enda = old_cor[1];
#line 1484
  hm->b = backward_hirsch_pp_dyn(prof1, prof2, hm);
#line 1491
  hirsch_path = hirsch_align_two_pp_vector(prof1, prof2, hm, hirsch_path, input_states,
                                           old_cor);
  }
#line 1492
  return (hirsch_path);
}
}
#line 1497 "/home/june/repo/benchmarks/collector/temp/kalign-2.03+20110620/kalign2_hirschberg.c"
int *hirsch_align_two_pp_vector(float const   *prof1 , float const   *prof2 , struct hirsch_mem *hm ,
                                int *hirsch_path , float *input_states , int *old_cor ) 
{ 
  struct states *f ;
  struct states *b ;
  int i ;
  int j ;
  int c ;
  int transition ;
  float max ;
  float middle ;
  float sub ;
  int tmp ;
  int tmp___0 ;

  {
#line 1499
  f = hm->f;
#line 1500
  b = hm->b;
#line 1502
  transition = -1;
#line 1515
  max = - 3.40282346638528859812e+38F;
#line 1517
  middle = (float )((*(old_cor + 3) - *(old_cor + 2)) / 2 + *(old_cor + 2));
#line 1518
  sub = (float )0.0;
#line 1521
  prof1 += (*(old_cor + 4) + 1) << 6;
#line 1524
  prof2 += *(old_cor + 2) << 6;
#line 1525
  i = *(old_cor + 2);
#line 1526
  c = -1;
#line 1528
  i = *(old_cor + 2);
  {
#line 1528
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1528
    if (! (i < *(old_cor + 3))) {
#line 1528
      goto while_break;
    }
    {
#line 1529
    tmp = abs((int )(middle - (float )i));
#line 1529
    sub = (float )tmp;
#line 1530
    sub /= (float )1000;
#line 1531
    prof2 += 64;
    }
#line 1533
    if (((f + i)->a + (b + i)->a) - sub > max) {
#line 1534
      max = ((f + i)->a + (b + i)->a) - sub;
#line 1536
      transition = 1;
#line 1537
      c = i;
    }
#line 1539
    if ((((f + i)->a + (b + i)->ga) + (float )*(prof2 + 27)) - sub > max) {
#line 1540
      max = (((f + i)->a + (b + i)->ga) + (float )*(prof2 + 27)) - sub;
#line 1542
      transition = 2;
#line 1543
      c = i;
    }
#line 1545
    if ((((f + i)->a + (b + i)->gb) + (float )*(prof1 + 27)) - sub > max) {
#line 1546
      max = (((f + i)->a + (b + i)->gb) + (float )*(prof1 + 27)) - sub;
#line 1548
      transition = 3;
#line 1549
      c = i;
    }
#line 1551
    if ((((f + i)->ga + (b + i)->a) + (float )*(prof2 + -37)) - sub > max) {
#line 1552
      max = (((f + i)->ga + (b + i)->a) + (float )*(prof2 + -37)) - sub;
#line 1554
      transition = 5;
#line 1555
      c = i;
    }
#line 1559
    if (hm->startb == 0) {
#line 1560
      if ((((f + i)->gb + (b + i)->gb) + (float )*(prof1 + 29)) - sub > max) {
#line 1561
        max = (((f + i)->gb + (b + i)->gb) + (float )*(prof1 + 29)) - sub;
#line 1563
        transition = 6;
#line 1564
        c = i;
      }
    } else
#line 1567
    if ((((f + i)->gb + (b + i)->gb) + (float )*(prof1 + 28)) - sub > max) {
#line 1568
      max = (((f + i)->gb + (b + i)->gb) + (float )*(prof1 + 28)) - sub;
#line 1570
      transition = 6;
#line 1571
      c = i;
    }
#line 1574
    if ((((f + i)->gb + (b + i)->a) + (float )*(prof1 + -37)) - sub > max) {
#line 1575
      max = (((f + i)->gb + (b + i)->a) + (float )*(prof1 + -37)) - sub;
#line 1577
      transition = 7;
#line 1578
      c = i;
    }
#line 1528
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1582
  i = *(old_cor + 3);
#line 1583
  tmp___0 = abs((int )(middle - (float )i));
#line 1583
  sub = (float )tmp___0;
#line 1584
  sub /= (float )1000;
  }
#line 1585
  if ((((f + i)->a + (b + i)->gb) + (float )*(prof1 + 27)) - sub > max) {
#line 1586
    max = (((f + i)->a + (b + i)->gb) + (float )*(prof1 + 27)) - sub;
#line 1588
    transition = 3;
#line 1589
    c = i;
  }
#line 1591
  if (hm->endb == hm->len_b) {
#line 1592
    if ((((f + i)->gb + (b + i)->gb) + (float )*(prof1 + 29)) - sub > max) {
#line 1593
      max = (((f + i)->gb + (b + i)->gb) + (float )*(prof1 + 29)) - sub;
#line 1595
      transition = 6;
#line 1596
      c = i;
    }
  } else
#line 1599
  if ((((f + i)->gb + (b + i)->gb) + (float )*(prof1 + 28)) - sub > max) {
#line 1600
    max = (((f + i)->gb + (b + i)->gb) + (float )*(prof1 + 28)) - sub;
#line 1602
    transition = 6;
#line 1603
    c = i;
  }
#line 1609
  prof1 -= (*(old_cor + 4) + 1) << 6;
#line 1611
  prof2 -= *(old_cor + 3) << 6;
#line 1618
  j = *(hirsch_path + 0);
  {
#line 1620
  if (transition == 1) {
#line 1620
    goto case_1;
  }
#line 1659
  if (transition == 2) {
#line 1659
    goto case_2;
  }
#line 1695
  if (transition == 3) {
#line 1695
    goto case_3;
  }
#line 1730
  if (transition == 5) {
#line 1730
    goto case_5;
  }
#line 1765
  if (transition == 6) {
#line 1765
    goto case_6;
  }
#line 1797
  if (transition == 7) {
#line 1797
    goto case_7;
  }
#line 1619
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 1622
  *(hirsch_path + *(old_cor + 4)) = c;
#line 1623
  *(hirsch_path + (*(old_cor + 4) + 1)) = c + 1;
#line 1628
  (hm->f + 0)->a = *(input_states + 0);
#line 1629
  (hm->f + 0)->ga = *(input_states + 1);
#line 1630
  (hm->f + 0)->gb = *(input_states + 2);
#line 1631
  (hm->b + 0)->a = (float )0.0;
#line 1632
  (hm->b + 0)->ga = - 3.40282346638528859812e+38F;
#line 1633
  (hm->b + 0)->gb = - 3.40282346638528859812e+38F;
#line 1636
  hm->starta = *(old_cor + 0);
#line 1637
  hm->enda = *(old_cor + 4) - 1;
#line 1639
  hm->startb = *(old_cor + 2);
#line 1640
  hm->endb = c - 1;
#line 1642
  hirsch_path = hirsch_pp_dyn(prof1, prof2, hm, hirsch_path);
#line 1645
  hm->starta = *(old_cor + 4) + 1;
#line 1646
  hm->enda = *(old_cor + 1);
#line 1647
  hm->startb = c + 1;
#line 1648
  hm->endb = *(old_cor + 3);
#line 1649
  (hm->f + 0)->a = (float )0.0;
#line 1650
  (hm->f + 0)->ga = - 3.40282346638528859812e+38F;
#line 1651
  (hm->f + 0)->gb = - 3.40282346638528859812e+38F;
#line 1652
  (hm->b + 0)->a = *(input_states + 3);
#line 1653
  (hm->b + 0)->ga = *(input_states + 4);
#line 1654
  (hm->b + 0)->gb = *(input_states + 5);
#line 1657
  hirsch_path = hirsch_pp_dyn(prof1, prof2, hm, hirsch_path);
  }
#line 1658
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 1661
  *(hirsch_path + *(old_cor + 4)) = c;
#line 1664
  (hm->f + 0)->a = *(input_states + 0);
#line 1665
  (hm->f + 0)->ga = *(input_states + 1);
#line 1666
  (hm->f + 0)->gb = *(input_states + 2);
#line 1667
  (hm->b + 0)->a = (float )0.0;
#line 1668
  (hm->b + 0)->ga = - 3.40282346638528859812e+38F;
#line 1669
  (hm->b + 0)->gb = - 3.40282346638528859812e+38F;
#line 1672
  hm->starta = *(old_cor + 0);
#line 1673
  hm->enda = *(old_cor + 4) - 1;
#line 1675
  hm->startb = *(old_cor + 2);
#line 1676
  hm->endb = c - 1;
#line 1678
  hirsch_path = hirsch_pp_dyn(prof1, prof2, hm, hirsch_path);
#line 1681
  hm->starta = *(old_cor + 4);
#line 1682
  hm->enda = *(old_cor + 1);
#line 1683
  hm->startb = c + 1;
#line 1684
  hm->endb = *(old_cor + 3);
#line 1685
  (hm->f + 0)->a = - 3.40282346638528859812e+38F;
#line 1686
  (hm->f + 0)->ga = (float )0.0;
#line 1687
  (hm->f + 0)->gb = - 3.40282346638528859812e+38F;
#line 1688
  (hm->b + 0)->a = *(input_states + 3);
#line 1689
  (hm->b + 0)->ga = *(input_states + 4);
#line 1690
  (hm->b + 0)->gb = *(input_states + 5);
#line 1693
  hirsch_path = hirsch_pp_dyn(prof1, prof2, hm, hirsch_path);
  }
#line 1694
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 1697
  *(hirsch_path + *(old_cor + 4)) = c;
#line 1700
  (hm->f + 0)->a = *(input_states + 0);
#line 1701
  (hm->f + 0)->ga = *(input_states + 1);
#line 1702
  (hm->f + 0)->gb = *(input_states + 2);
#line 1703
  (hm->b + 0)->a = (float )0.0;
#line 1704
  (hm->b + 0)->ga = - 3.40282346638528859812e+38F;
#line 1705
  (hm->b + 0)->gb = - 3.40282346638528859812e+38F;
#line 1707
  hm->starta = *(old_cor + 0);
#line 1708
  hm->enda = *(old_cor + 4) - 1;
#line 1710
  hm->startb = *(old_cor + 2);
#line 1711
  hm->endb = c - 1;
#line 1713
  hirsch_path = hirsch_pp_dyn(prof1, prof2, hm, hirsch_path);
#line 1716
  hm->starta = *(old_cor + 4) + 1;
#line 1717
  hm->enda = *(old_cor + 1);
#line 1718
  hm->startb = c;
#line 1719
  hm->endb = *(old_cor + 3);
#line 1720
  (hm->f + 0)->a = - 3.40282346638528859812e+38F;
#line 1721
  (hm->f + 0)->ga = - 3.40282346638528859812e+38F;
#line 1722
  (hm->f + 0)->gb = (float )0.0;
#line 1723
  (hm->b + 0)->a = *(input_states + 3);
#line 1724
  (hm->b + 0)->ga = *(input_states + 4);
#line 1725
  (hm->b + 0)->gb = *(input_states + 5);
#line 1728
  hirsch_path = hirsch_pp_dyn(prof1, prof2, hm, hirsch_path);
  }
#line 1729
  goto switch_break;
  case_5: /* CIL Label */ 
  {
#line 1731
  *(hirsch_path + (*(old_cor + 4) + 1)) = c + 1;
#line 1735
  (hm->f + 0)->a = *(input_states + 0);
#line 1736
  (hm->f + 0)->ga = *(input_states + 1);
#line 1737
  (hm->f + 0)->gb = *(input_states + 2);
#line 1738
  (hm->b + 0)->a = - 3.40282346638528859812e+38F;
#line 1739
  (hm->b + 0)->ga = (float )0.0;
#line 1740
  (hm->b + 0)->gb = - 3.40282346638528859812e+38F;
#line 1742
  hm->starta = *(old_cor + 0);
#line 1743
  hm->enda = *(old_cor + 4);
#line 1745
  hm->startb = *(old_cor + 2);
#line 1746
  hm->endb = c - 1;
#line 1748
  hirsch_path = hirsch_pp_dyn(prof1, prof2, hm, hirsch_path);
#line 1751
  hm->starta = *(old_cor + 4) + 1;
#line 1752
  hm->enda = *(old_cor + 1);
#line 1753
  hm->startb = c + 1;
#line 1754
  hm->endb = *(old_cor + 3);
#line 1755
  (hm->f + 0)->a = (float )0.0;
#line 1756
  (hm->f + 0)->ga = - 3.40282346638528859812e+38F;
#line 1757
  (hm->f + 0)->gb = - 3.40282346638528859812e+38F;
#line 1758
  (hm->b + 0)->a = *(input_states + 3);
#line 1759
  (hm->b + 0)->ga = *(input_states + 4);
#line 1760
  (hm->b + 0)->gb = *(input_states + 5);
#line 1763
  hirsch_path = hirsch_pp_dyn(prof1, prof2, hm, hirsch_path);
  }
#line 1764
  goto switch_break;
  case_6: /* CIL Label */ 
  {
#line 1768
  (hm->f + 0)->a = *(input_states + 0);
#line 1769
  (hm->f + 0)->ga = *(input_states + 1);
#line 1770
  (hm->f + 0)->gb = *(input_states + 2);
#line 1771
  (hm->b + 0)->a = - 3.40282346638528859812e+38F;
#line 1772
  (hm->b + 0)->ga = - 3.40282346638528859812e+38F;
#line 1773
  (hm->b + 0)->gb = (float )0.0;
#line 1775
  hm->starta = *(old_cor + 0);
#line 1776
  hm->enda = *(old_cor + 4) - 1;
#line 1777
  hm->startb = *(old_cor + 2);
#line 1778
  hm->endb = c;
#line 1780
  hirsch_path = hirsch_pp_dyn(prof1, prof2, hm, hirsch_path);
#line 1783
  hm->starta = *(old_cor + 4) + 1;
#line 1784
  hm->enda = *(old_cor + 1);
#line 1785
  hm->startb = c;
#line 1786
  hm->endb = *(old_cor + 3);
#line 1787
  (hm->f + 0)->a = - 3.40282346638528859812e+38F;
#line 1788
  (hm->f + 0)->ga = - 3.40282346638528859812e+38F;
#line 1789
  (hm->f + 0)->gb = (float )0.0;
#line 1790
  (hm->b + 0)->a = *(input_states + 3);
#line 1791
  (hm->b + 0)->ga = *(input_states + 4);
#line 1792
  (hm->b + 0)->gb = *(input_states + 5);
#line 1795
  hirsch_path = hirsch_pp_dyn(prof1, prof2, hm, hirsch_path);
  }
#line 1796
  goto switch_break;
  case_7: /* CIL Label */ 
  {
#line 1799
  *(hirsch_path + (*(old_cor + 4) + 1)) = c + 1;
#line 1802
  (hm->f + 0)->a = *(input_states + 0);
#line 1803
  (hm->f + 0)->ga = *(input_states + 1);
#line 1804
  (hm->f + 0)->gb = *(input_states + 2);
#line 1805
  (hm->b + 0)->a = - 3.40282346638528859812e+38F;
#line 1806
  (hm->b + 0)->ga = - 3.40282346638528859812e+38F;
#line 1807
  (hm->b + 0)->gb = (float )0.0;
#line 1809
  hm->starta = *(old_cor + 0);
#line 1810
  hm->enda = *(old_cor + 4) - 1;
#line 1811
  hm->startb = *(old_cor + 2);
#line 1812
  hm->endb = c;
#line 1814
  hirsch_path = hirsch_pp_dyn(prof1, prof2, hm, hirsch_path);
#line 1817
  hm->starta = *(old_cor + 4) + 1;
#line 1818
  hm->enda = *(old_cor + 1);
#line 1819
  hm->startb = c + 1;
#line 1820
  hm->endb = *(old_cor + 3);
#line 1821
  (hm->f + 0)->a = (float )0.0;
#line 1822
  (hm->f + 0)->ga = - 3.40282346638528859812e+38F;
#line 1823
  (hm->f + 0)->gb = - 3.40282346638528859812e+38F;
#line 1824
  (hm->b + 0)->a = *(input_states + 3);
#line 1825
  (hm->b + 0)->ga = *(input_states + 4);
#line 1826
  (hm->b + 0)->gb = *(input_states + 5);
#line 1829
  hirsch_path = hirsch_pp_dyn(prof1, prof2, hm, hirsch_path);
  }
#line 1830
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1833
  return (hirsch_path);
}
}
#line 1836 "/home/june/repo/benchmarks/collector/temp/kalign-2.03+20110620/kalign2_hirschberg.c"
struct states *foward_hirsch_pp_dyn(float const   *prof1 , float const   *prof2 ,
                                    struct hirsch_mem *hm ) 
{ 
  unsigned int freq[26] ;
  struct states *s ;
  register float pa ;
  register float pga ;
  register float pgb ;
  register float ca ;
  register float xa ;
  register float xga ;
  register int i ;
  register int j ;
  register int c ;
  float tmp ;
  float tmp___0 ;
  float tmp___2 ;
  float tmp___3 ;
  float tmp___5 ;
  float tmp___6 ;
  float tmp___7 ;

  {
#line 1840
  s = hm->f;
#line 1841
  pa = (float )0;
#line 1842
  pga = (float )0;
#line 1843
  pgb = (float )0;
#line 1844
  ca = (float )0;
#line 1846
  xa = (float )0;
#line 1847
  xga = (float )0;
#line 1849
  i = 0;
#line 1850
  j = 0;
#line 1851
  c = 0;
#line 1853
  prof1 += hm->starta << 6;
#line 1854
  prof2 += hm->startb << 6;
#line 1855
  (s + hm->startb)->a = (s + 0)->a;
#line 1856
  (s + hm->startb)->ga = (s + 0)->ga;
#line 1857
  (s + hm->startb)->gb = (s + 0)->gb;
#line 1858
  if (hm->startb) {
#line 1859
    j = hm->startb + 1;
    {
#line 1859
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1859
      if (! (j < hm->endb)) {
#line 1859
        goto while_break;
      }
#line 1860
      prof2 += 64;
#line 1861
      (s + j)->a = - 3.40282346638528859812e+38F;
#line 1862
      if ((s + (j - 1))->ga + (float )*(prof2 + 28) > (s + (j - 1))->a + (float )*(prof2 + 27)) {
#line 1862
        (s + j)->ga = (s + (j - 1))->ga + (float )*(prof2 + 28);
      } else {
#line 1862
        (s + j)->ga = (s + (j - 1))->a + (float )*(prof2 + 27);
      }
#line 1863
      (s + j)->gb = - 3.40282346638528859812e+38F;
#line 1859
      j ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 1865
    prof2 += 64;
  } else {
#line 1867
    j = hm->startb + 1;
    {
#line 1867
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1867
      if (! (j < hm->endb)) {
#line 1867
        goto while_break___0;
      }
#line 1868
      prof2 += 64;
#line 1869
      (s + j)->a = - 3.40282346638528859812e+38F;
#line 1870
      if ((s + (j - 1))->ga > (s + (j - 1))->a) {
#line 1870
        tmp = (s + (j - 1))->ga;
      } else {
#line 1870
        tmp = (s + (j - 1))->a;
      }
#line 1870
      (s + j)->ga = tmp + (float )*(prof2 + 29);
#line 1871
      (s + j)->gb = - 3.40282346638528859812e+38F;
#line 1867
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1873
    prof2 += 64;
  }
#line 1876
  prof2 -= (hm->endb - hm->startb) << 6;
#line 1878
  (s + hm->endb)->a = - 3.40282346638528859812e+38F;
#line 1879
  (s + hm->endb)->ga = - 3.40282346638528859812e+38F;
#line 1880
  (s + hm->endb)->gb = - 3.40282346638528859812e+38F;
#line 1883
  i = hm->starta;
  {
#line 1883
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1883
    if (! (i < hm->enda)) {
#line 1883
      goto while_break___1;
    }
#line 1884
    prof1 += 64;
#line 1885
    c = 1;
#line 1886
    j = 0;
    {
#line 1886
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1886
      if (! (j < 26)) {
#line 1886
        goto while_break___2;
      }
#line 1887
      if (*(prof1 + j)) {
#line 1888
        freq[c] = (unsigned int )j;
#line 1889
        c ++;
      }
#line 1886
      j ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 1892
    freq[0] = (unsigned int )c;
#line 1894
    pa = (s + hm->startb)->a;
#line 1895
    pga = (s + hm->startb)->ga;
#line 1896
    pgb = (s + hm->startb)->gb;
#line 1897
    (s + hm->startb)->a = - 3.40282346638528859812e+38F;
#line 1898
    (s + hm->startb)->ga = - 3.40282346638528859812e+38F;
#line 1900
    xa = (s + hm->startb)->a;
#line 1901
    xga = (s + hm->startb)->ga;
#line 1904
    if (hm->startb) {
#line 1905
      if (pgb + (float )*(prof1 + 28) > pa + (float )*(prof1 + 27)) {
#line 1905
        (s + hm->startb)->gb = pgb + (float )*(prof1 + 28);
      } else {
#line 1905
        (s + hm->startb)->gb = pa + (float )*(prof1 + 27);
      }
    } else {
#line 1907
      if (pgb > pa) {
#line 1907
        tmp___0 = pgb;
      } else {
#line 1907
        tmp___0 = pa;
      }
#line 1907
      (s + hm->startb)->gb = tmp___0 + (float )*(prof1 + 29);
    }
#line 1909
    j = hm->startb + 1;
    {
#line 1909
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 1909
      if (! (j < hm->endb)) {
#line 1909
        goto while_break___3;
      }
#line 1910
      prof2 += 64;
#line 1911
      ca = (s + j)->a;
#line 1913
      if (pa > pga + (float )*(prof2 + -37)) {
#line 1913
        tmp___3 = pa;
      } else {
#line 1913
        tmp___3 = pga + (float )*(prof2 + -37);
      }
#line 1913
      if (tmp___3 > pgb + (float )*(prof1 + -37)) {
#line 1913
        if (pa > pga + (float )*(prof2 + -37)) {
#line 1913
          tmp___2 = pa;
        } else {
#line 1913
          tmp___2 = pga + (float )*(prof2 + -37);
        }
#line 1913
        pa = tmp___2;
      } else {
#line 1913
        pa = pgb + (float )*(prof1 + -37);
      }
#line 1915
      prof2 += 32;
#line 1916
      c = 1;
      {
#line 1916
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 1916
        if (! ((unsigned int )c < freq[0])) {
#line 1916
          goto while_break___4;
        }
#line 1917
        pa += (float )(*(prof1 + freq[c]) * *(prof2 + freq[c]));
#line 1916
        c ++;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 1919
      prof2 -= 32;
#line 1921
      (s + j)->a = pa;
#line 1923
      pga = (s + j)->ga;
#line 1926
      if (xga + (float )*(prof2 + 28) > xa + (float )*(prof2 + 27)) {
#line 1926
        (s + j)->ga = xga + (float )*(prof2 + 28);
      } else {
#line 1926
        (s + j)->ga = xa + (float )*(prof2 + 27);
      }
#line 1928
      pgb = (s + j)->gb;
#line 1930
      if (pgb + (float )*(prof1 + 28) > ca + (float )*(prof1 + 27)) {
#line 1930
        (s + j)->gb = pgb + (float )*(prof1 + 28);
      } else {
#line 1930
        (s + j)->gb = ca + (float )*(prof1 + 27);
      }
#line 1932
      pa = ca;
#line 1935
      xa = (s + j)->a;
#line 1936
      xga = (s + j)->ga;
#line 1909
      j ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 1938
    prof2 += 64;
#line 1939
    ca = (s + j)->a;
#line 1941
    if (pa > pga + (float )*(prof2 + -37)) {
#line 1941
      tmp___6 = pa;
    } else {
#line 1941
      tmp___6 = pga + (float )*(prof2 + -37);
    }
#line 1941
    if (tmp___6 > pgb + (float )*(prof1 + -37)) {
#line 1941
      if (pa > pga + (float )*(prof2 + -37)) {
#line 1941
        tmp___5 = pa;
      } else {
#line 1941
        tmp___5 = pga + (float )*(prof2 + -37);
      }
#line 1941
      pa = tmp___5;
    } else {
#line 1941
      pa = pgb + (float )*(prof1 + -37);
    }
#line 1943
    prof2 += 32;
#line 1944
    c = 1;
    {
#line 1944
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 1944
      if (! ((unsigned int )c < freq[0])) {
#line 1944
        goto while_break___5;
      }
#line 1945
      pa += (float )(*(prof1 + freq[c]) * *(prof2 + freq[c]));
#line 1944
      c ++;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 1947
    prof2 -= 32;
#line 1949
    (s + j)->a = pa;
#line 1951
    (s + j)->ga = - 3.40282346638528859812e+38F;
#line 1953
    if (hm->endb != hm->len_b) {
#line 1954
      if ((s + j)->gb + (float )*(prof1 + 28) > ca + (float )*(prof1 + 27)) {
#line 1954
        (s + j)->gb += (float )*(prof1 + 28);
      } else {
#line 1954
        (s + j)->gb = ca + (float )*(prof1 + 27);
      }
    } else {
#line 1956
      if ((s + j)->gb > ca) {
#line 1956
        tmp___7 = (s + j)->gb;
      } else {
#line 1956
        tmp___7 = ca;
      }
#line 1956
      (s + j)->gb = tmp___7 + (float )*(prof1 + 29);
    }
#line 1958
    prof2 -= (hm->endb - hm->startb) << 6;
#line 1883
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1961
  prof1 -= hm->enda << 6;
#line 1962
  return (s);
}
}
#line 1965 "/home/june/repo/benchmarks/collector/temp/kalign-2.03+20110620/kalign2_hirschberg.c"
struct states *backward_hirsch_pp_dyn(float const   *prof1 , float const   *prof2 ,
                                      struct hirsch_mem *hm ) 
{ 
  unsigned int freq[26] ;
  struct states *s ;
  register float pa ;
  register float pga ;
  register float pgb ;
  register float ca ;
  register float xa ;
  register float xga ;
  register int i ;
  register int j ;
  register int c ;
  float tmp ;
  float tmp___0 ;
  float tmp___2 ;
  float tmp___3 ;
  float tmp___5 ;
  float tmp___6 ;
  float tmp___7 ;
  int tmp___8 ;

  {
#line 1968
  s = hm->b;
#line 1969
  pa = (float )0;
#line 1970
  pga = (float )0;
#line 1971
  pgb = (float )0;
#line 1972
  ca = (float )0;
#line 1974
  xa = (float )0;
#line 1975
  xga = (float )0;
#line 1977
  i = 0;
#line 1978
  j = 0;
#line 1979
  c = 0;
#line 1981
  prof1 += (hm->enda + 1) << 6;
#line 1982
  prof2 += (hm->endb + 1) << 6;
#line 1983
  (s + hm->endb)->a = (s + 0)->a;
#line 1984
  (s + hm->endb)->ga = (s + 0)->ga;
#line 1985
  (s + hm->endb)->gb = (s + 0)->gb;
#line 1986
  if (hm->endb != hm->len_b) {
#line 1987
    j = hm->endb - 1;
    {
#line 1987
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1987
      if (! (j > hm->startb)) {
#line 1987
        goto while_break;
      }
#line 1988
      prof2 -= 64;
#line 1989
      (s + j)->a = - 3.40282346638528859812e+38F;
#line 1990
      if ((s + (j + 1))->ga + (float )*(prof2 + 28) > (s + (j + 1))->a + (float )*(prof2 + 27)) {
#line 1990
        (s + j)->ga = (s + (j + 1))->ga + (float )*(prof2 + 28);
      } else {
#line 1990
        (s + j)->ga = (s + (j + 1))->a + (float )*(prof2 + 27);
      }
#line 1991
      (s + j)->gb = - 3.40282346638528859812e+38F;
#line 1987
      j --;
    }
    while_break: /* CIL Label */ ;
    }
#line 1993
    prof2 -= 64;
  } else {
#line 1995
    j = hm->endb - 1;
    {
#line 1995
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1995
      if (! (j > hm->startb)) {
#line 1995
        goto while_break___0;
      }
#line 1996
      prof2 -= 64;
#line 1997
      (s + j)->a = - 3.40282346638528859812e+38F;
#line 1998
      if ((s + (j + 1))->ga > (s + (j + 1))->a) {
#line 1998
        tmp = (s + (j + 1))->ga;
      } else {
#line 1998
        tmp = (s + (j + 1))->a;
      }
#line 1998
      (s + j)->ga = tmp + (float )*(prof2 + 29);
#line 1999
      (s + j)->gb = - 3.40282346638528859812e+38F;
#line 1995
      j --;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 2001
    prof2 -= 64;
  }
#line 2004
  (s + hm->startb)->a = - 3.40282346638528859812e+38F;
#line 2005
  (s + hm->startb)->ga = - 3.40282346638528859812e+38F;
#line 2006
  (s + hm->startb)->gb = - 3.40282346638528859812e+38F;
#line 2008
  i = hm->enda - hm->starta;
  {
#line 2009
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 2009
    tmp___8 = i;
#line 2009
    i --;
#line 2009
    if (! tmp___8) {
#line 2009
      goto while_break___1;
    }
#line 2010
    prof1 -= 64;
#line 2012
    c = 1;
#line 2013
    j = 0;
    {
#line 2013
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 2013
      if (! (j < 26)) {
#line 2013
        goto while_break___2;
      }
#line 2014
      if (*(prof1 + j)) {
#line 2015
        freq[c] = (unsigned int )j;
#line 2016
        c ++;
      }
#line 2013
      j ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 2019
    freq[0] = (unsigned int )c;
#line 2021
    pa = (s + hm->endb)->a;
#line 2022
    pga = (s + hm->endb)->ga;
#line 2023
    pgb = (s + hm->endb)->gb;
#line 2024
    (s + hm->endb)->a = - 3.40282346638528859812e+38F;
#line 2025
    (s + hm->endb)->ga = - 3.40282346638528859812e+38F;
#line 2027
    xa = (s + hm->endb)->a;
#line 2028
    xga = (s + hm->endb)->ga;
#line 2030
    if (hm->endb != hm->len_b) {
#line 2031
      if (pgb + (float )*(prof1 + 28) > pa + (float )*(prof1 + 27)) {
#line 2031
        (s + hm->endb)->gb = pgb + (float )*(prof1 + 28);
      } else {
#line 2031
        (s + hm->endb)->gb = pa + (float )*(prof1 + 27);
      }
    } else {
#line 2033
      if (pgb > pa) {
#line 2033
        tmp___0 = pgb;
      } else {
#line 2033
        tmp___0 = pa;
      }
#line 2033
      (s + hm->endb)->gb = tmp___0 + (float )*(prof1 + 29);
    }
#line 2036
    prof2 += (hm->endb - hm->startb) << 6;
#line 2037
    j = hm->endb - 1;
    {
#line 2037
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 2037
      if (! (j > hm->startb)) {
#line 2037
        goto while_break___3;
      }
#line 2038
      prof2 -= 64;
#line 2039
      ca = (s + j)->a;
#line 2041
      if (pa > pga + (float )*(prof2 + 91)) {
#line 2041
        tmp___3 = pa;
      } else {
#line 2041
        tmp___3 = pga + (float )*(prof2 + 91);
      }
#line 2041
      if (tmp___3 > pgb + (float )*(prof1 + 91)) {
#line 2041
        if (pa > pga + (float )*(prof2 + 91)) {
#line 2041
          tmp___2 = pa;
        } else {
#line 2041
          tmp___2 = pga + (float )*(prof2 + 91);
        }
#line 2041
        pa = tmp___2;
      } else {
#line 2041
        pa = pgb + (float )*(prof1 + 91);
      }
#line 2043
      prof2 += 32;
#line 2044
      c = 1;
      {
#line 2044
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 2044
        if (! ((unsigned int )c < freq[0])) {
#line 2044
          goto while_break___4;
        }
#line 2045
        pa += (float )(*(prof1 + freq[c]) * *(prof2 + freq[c]));
#line 2044
        c ++;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 2047
      prof2 -= 32;
#line 2049
      (s + j)->a = pa;
#line 2051
      pga = (s + j)->ga;
#line 2054
      if (xga + (float )*(prof2 + 28) > xa + (float )*(prof2 + 27)) {
#line 2054
        (s + j)->ga = xga + (float )*(prof2 + 28);
      } else {
#line 2054
        (s + j)->ga = xa + (float )*(prof2 + 27);
      }
#line 2056
      pgb = (s + j)->gb;
#line 2058
      if (pgb + (float )*(prof1 + 28) > ca + (float )*(prof1 + 27)) {
#line 2058
        (s + j)->gb = pgb + (float )*(prof1 + 28);
      } else {
#line 2058
        (s + j)->gb = ca + (float )*(prof1 + 27);
      }
#line 2060
      pa = ca;
#line 2061
      xa = (s + j)->a;
#line 2062
      xga = (s + j)->ga;
#line 2037
      j --;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 2064
    prof2 -= 64;
#line 2065
    ca = (s + j)->a;
#line 2067
    if (pa > pga + (float )*(prof2 + 91)) {
#line 2067
      tmp___6 = pa;
    } else {
#line 2067
      tmp___6 = pga + (float )*(prof2 + 91);
    }
#line 2067
    if (tmp___6 > pgb + (float )*(prof1 + 91)) {
#line 2067
      if (pa > pga + (float )*(prof2 + 91)) {
#line 2067
        tmp___5 = pa;
      } else {
#line 2067
        tmp___5 = pga + (float )*(prof2 + 91);
      }
#line 2067
      pa = tmp___5;
    } else {
#line 2067
      pa = pgb + (float )*(prof1 + 91);
    }
#line 2068
    prof2 += 32;
#line 2069
    c = 1;
    {
#line 2069
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 2069
      if (! ((unsigned int )c < freq[0])) {
#line 2069
        goto while_break___5;
      }
#line 2070
      pa += (float )(*(prof1 + freq[c]) * *(prof2 + freq[c]));
#line 2069
      c ++;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 2072
    prof2 -= 32;
#line 2073
    (s + j)->a = pa;
#line 2076
    (s + j)->ga = - 3.40282346638528859812e+38F;
#line 2079
    if (hm->startb) {
#line 2080
      if ((s + j)->gb + (float )*(prof1 + 28) > ca + (float )*(prof1 + 27)) {
#line 2080
        (s + j)->gb += (float )*(prof1 + 28);
      } else {
#line 2080
        (s + j)->gb = ca + (float )*(prof1 + 27);
      }
    } else {
#line 2082
      if ((s + j)->gb > ca) {
#line 2082
        tmp___7 = (s + j)->gb;
      } else {
#line 2082
        tmp___7 = ca;
      }
#line 2082
      (s + j)->gb = tmp___7 + (float )*(prof1 + 29);
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 2087
  return (s);
}
}
#line 2091 "/home/june/repo/benchmarks/collector/temp/kalign-2.03+20110620/kalign2_hirschberg.c"
int *mirror_hirsch_path(int *hirsch_path , int len_a , int len_b ) 
{ 
  int *np ;
  int i ;
  void *tmp ;

  {
  {
#line 2093
  np = (int *)0;
#line 2096
  tmp = malloc(sizeof(int ) * (unsigned long )(len_a + 2));
#line 2096
  np = (int *)tmp;
#line 2097
  i = 0;
  }
  {
#line 2097
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2097
    if (! (i < len_a + 2)) {
#line 2097
      goto while_break;
    }
#line 2098
    *(np + i) = -1;
#line 2097
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2101
  i = 1;
  {
#line 2101
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2101
    if (! (i <= len_b)) {
#line 2101
      goto while_break___0;
    }
#line 2102
    if (*(hirsch_path + i) != -1) {
#line 2103
      *(np + *(hirsch_path + i)) = i;
    }
#line 2101
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 2107
  free((void *)hirsch_path);
  }
#line 2108
  return (np);
}
}
#line 2111 "/home/june/repo/benchmarks/collector/temp/kalign-2.03+20110620/kalign2_hirschberg.c"
int *add_gap_info_to_hirsch_path(int *hirsch_path , int len_a , int len_b ) 
{ 
  int i ;
  int j ;
  int a ;
  int b ;
  int *np ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 2114
  a = 0;
#line 2115
  b = 0;
#line 2117
  np = (int *)0;
#line 2118
  tmp = malloc(sizeof(int ) * (unsigned long )((len_a + len_b) + 2));
#line 2118
  np = (int *)tmp;
#line 2119
  i = 0;
  }
  {
#line 2119
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2119
    if (! (i < (len_a + len_b) + 2)) {
#line 2119
      goto while_break;
    }
#line 2120
    *(np + i) = 0;
#line 2119
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2123
  j = 1;
#line 2124
  b = -1;
#line 2125
  if (*(hirsch_path + 1) == -1) {
#line 2126
    *(np + j) = 2;
#line 2127
    j ++;
  } else
#line 2129
  if (*(hirsch_path + 1) != 1) {
#line 2130
    a = 0;
    {
#line 2130
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2130
      if (! (a < *(hirsch_path + 1) - 1)) {
#line 2130
        goto while_break___0;
      }
#line 2131
      *(np + j) = 1;
#line 2132
      j ++;
#line 2130
      a ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 2134
    *(np + j) = 0;
#line 2135
    j ++;
  } else {
#line 2137
    *(np + j) = 0;
#line 2138
    j ++;
  }
#line 2141
  b = *(hirsch_path + 1);
#line 2148
  i = 2;
  {
#line 2148
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 2148
    if (! (i <= len_a)) {
#line 2148
      goto while_break___1;
    }
#line 2150
    if (*(hirsch_path + i) == -1) {
#line 2151
      *(np + j) = 2;
#line 2152
      j ++;
    } else
#line 2154
    if (*(hirsch_path + i) - 1 != b) {
#line 2154
      if (b != -1) {
#line 2155
        a = 0;
        {
#line 2155
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 2155
          if (! (a < (*(hirsch_path + i) - b) - 1)) {
#line 2155
            goto while_break___2;
          }
#line 2156
          *(np + j) = 1;
#line 2157
          j ++;
#line 2155
          a ++;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 2159
        *(np + j) = 0;
#line 2160
        j ++;
      } else {
#line 2162
        *(np + j) = 0;
#line 2163
        j ++;
      }
    } else {
#line 2162
      *(np + j) = 0;
#line 2163
      j ++;
    }
#line 2166
    b = *(hirsch_path + i);
#line 2148
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 2173
  if (*(hirsch_path + len_a) < len_b) {
#line 2173
    if (*(hirsch_path + len_a) != -1) {
#line 2175
      a = 0;
      {
#line 2175
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 2175
        if (! (a < len_b - *(hirsch_path + len_a))) {
#line 2175
          goto while_break___3;
        }
#line 2176
        *(np + j) = 1;
#line 2177
        j ++;
#line 2175
        a ++;
      }
      while_break___3: /* CIL Label */ ;
      }
    }
  }
  {
#line 2180
  *(np + 0) = j - 1;
#line 2181
  *(np + j) = 3;
#line 2182
  tmp___0 = realloc((void *)np, sizeof(int ) * (unsigned long )(*(np + 0) + 2));
#line 2182
  np = (int *)tmp___0;
#line 2188
  free((void *)hirsch_path);
#line 2191
  i = 2;
  }
  {
#line 2192
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 2192
    if (! (*(np + i) != 3)) {
#line 2192
      goto while_break___4;
    }
#line 2193
    if (*(np + (i - 1)) & 3) {
#line 2193
      if (! (*(np + i) & 3)) {
#line 2194
        if (*(np + (i - 1)) & 8) {
#line 2195
          *(np + (i - 1)) += 8;
        } else {
#line 2197
          *(np + (i - 1)) |= 16;
        }
      } else {
#line 2193
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */ 
#line 2199
    if (! (*(np + (i - 1)) & 3)) {
#line 2199
      if (*(np + i) & 3) {
#line 2200
        *(np + i) |= 4;
      } else {
#line 2199
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 2201
    if (*(np + (i - 1)) & 1) {
#line 2201
      if (*(np + i) & 1) {
#line 2202
        *(np + i) |= 8;
      } else {
#line 2201
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 2203
    if (*(np + (i - 1)) & 2) {
#line 2203
      if (*(np + i) & 2) {
#line 2204
        *(np + i) |= 8;
      }
    }
#line 2206
    i ++;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 2209
  i = 1;
  {
#line 2210
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 2210
    if (! (*(np + i) != 0)) {
#line 2210
      goto while_break___5;
    }
#line 2211
    *(np + i) |= 32;
#line 2212
    i ++;
  }
  while_break___5: /* CIL Label */ ;
  }
#line 2214
  j = i;
#line 2215
  i = *(np + 0);
  {
#line 2216
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 2216
    if (! (*(np + i) != 0)) {
#line 2216
      goto while_break___6;
    }
#line 2217
    *(np + i) |= 32;
#line 2218
    i --;
  }
  while_break___6: /* CIL Label */ ;
  }
#line 2224
  return (np);
}
}
#line 57 "/usr/include/getopt.h"
extern char *optarg ;
#line 71
extern int optind ;
#line 177
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getopt_long_only)(int ___argc ,
                                                                                       char * const  *___argv ,
                                                                                       char const   *__shortopts ,
                                                                                       struct option  const  *__longopts ,
                                                                                       int *__longind ) ;
#line 144 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) double ( __attribute__((__nonnull__(1), __leaf__)) atof)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 147
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 515
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) abort)(void) ;
#line 61 "/home/june/repo/benchmarks/collector/temp/kalign-2.03+20110620/kalign2_input.h"
static char usage[2081]  = 
#line 61 "/home/june/repo/benchmarks/collector/temp/kalign-2.03+20110620/kalign2_input.h"
  {      (char )'\n',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )'U',      (char )'s',      (char )'a', 
        (char )'g',      (char )'e',      (char )':',      (char )' ', 
        (char )'k',      (char )'a',      (char )'l',      (char )'i', 
        (char )'g',      (char )'n',      (char )'2',      (char )' ', 
        (char )' ',      (char )' ',      (char )'[',      (char )'I', 
        (char )'N',      (char )'F',      (char )'I',      (char )'L', 
        (char )'E',      (char )']',      (char )' ',      (char )'[', 
        (char )'O',      (char )'U',      (char )'T',      (char )'F', 
        (char )'I',      (char )'L',      (char )'E',      (char )']', 
        (char )' ',      (char )'[',      (char )'O',      (char )'P', 
        (char )'T',      (char )'I',      (char )'O',      (char )'N', 
        (char )'S',      (char )']',      (char )'\n',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )'\n', 
        (char )'\t',      (char )'O',      (char )'p',      (char )'t', 
        (char )'i',      (char )'o',      (char )'n',      (char )'s', 
        (char )':',      (char )'\n',      (char )'\n',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )'-', 
        (char )'s',      (char )',',      (char )'\t',      (char )'-', 
        (char )'g',      (char )'a',      (char )'p',      (char )'o', 
        (char )'p',      (char )'e',      (char )'n',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )'G',      (char )'a',      (char )'p', 
        (char )' ',      (char )'o',      (char )'p',      (char )'e', 
        (char )'n',      (char )' ',      (char )'p',      (char )'e', 
        (char )'n',      (char )'a',      (char )'l',      (char )'t', 
        (char )'y',      (char )'\n',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )'\t',      (char )'-', 
        (char )'g',      (char )'a',      (char )'p',      (char )'_', 
        (char )'o',      (char )'p',      (char )'e',      (char )'n', 
        (char )'\n',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )'\t',      (char )'-',      (char )'g', 
        (char )'p',      (char )'o',      (char )'\n',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )'\t', 
        (char )'\n',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )'-',      (char )'e',      (char )',', 
        (char )'\t',      (char )'-',      (char )'g',      (char )'a', 
        (char )'p',      (char )'e',      (char )'x',      (char )'t', 
        (char )'e',      (char )'n',      (char )'s',      (char )'i', 
        (char )'o',      (char )'n',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )'G', 
        (char )'a',      (char )'p',      (char )' ',      (char )'e', 
        (char )'x',      (char )'t',      (char )'e',      (char )'n', 
        (char )'s',      (char )'i',      (char )'o',      (char )'n', 
        (char )' ',      (char )'p',      (char )'e',      (char )'n', 
        (char )'a',      (char )'l',      (char )'t',      (char )'y', 
        (char )'\n',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )'\t',      (char )'-',      (char )'g', 
        (char )'a',      (char )'p',      (char )'_',      (char )'e', 
        (char )'x',      (char )'t',      (char )'\n',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )'\t', 
        (char )'-',      (char )'g',      (char )'p',      (char )'e', 
        (char )'\n',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )'\t',      (char )'\n',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )'-', 
        (char )'t',      (char )',',      (char )'\t',      (char )'-', 
        (char )'t',      (char )'e',      (char )'r',      (char )'m', 
        (char )'i',      (char )'n',      (char )'a',      (char )'l', 
        (char )'_',      (char )'g',      (char )'a',      (char )'p', 
        (char )'_',      (char )'e',      (char )'x',      (char )'t', 
        (char )'e',      (char )'n',      (char )'s',      (char )'i', 
        (char )'o',      (char )'n',      (char )'_',      (char )'p', 
        (char )'e',      (char )'n',      (char )'a',      (char )'l', 
        (char )'t',      (char )'y',      (char )'\t',      (char )'T', 
        (char )'e',      (char )'r',      (char )'m',      (char )'i', 
        (char )'n',      (char )'a',      (char )'l',      (char )' ', 
        (char )'g',      (char )'a',      (char )'p',      (char )' ', 
        (char )'p',      (char )'e',      (char )'n',      (char )'a', 
        (char )'l',      (char )'t',      (char )'i',      (char )'e', 
        (char )'s',      (char )'\n',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )'\t',      (char )'-', 
        (char )'t',      (char )'g',      (char )'p',      (char )'e', 
        (char )'\n',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )'\t',      (char )'\n',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )'-', 
        (char )'m',      (char )',',      (char )'\t',      (char )'-', 
        (char )'m',      (char )'a',      (char )'t',      (char )'r', 
        (char )'i',      (char )'x',      (char )'_',      (char )'b', 
        (char )'o',      (char )'n',      (char )'u',      (char )'s', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )'A',      (char )' ',      (char )'c', 
        (char )'o',      (char )'n',      (char )'s',      (char )'t', 
        (char )'a',      (char )'n',      (char )'t',      (char )' ', 
        (char )'a',      (char )'d',      (char )'d',      (char )'e', 
        (char )'d',      (char )' ',      (char )'t',      (char )'o', 
        (char )' ',      (char )'t',      (char )'h',      (char )'e', 
        (char )' ',      (char )'s',      (char )'u',      (char )'b', 
        (char )'s',      (char )'t',      (char )'i',      (char )'t', 
        (char )'u',      (char )'t',      (char )'i',      (char )'o', 
        (char )'n',      (char )' ',      (char )'m',      (char )'a', 
        (char )'t',      (char )'r',      (char )'i',      (char )'x', 
        (char )'.',      (char )'\n',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )'\t',      (char )'-', 
        (char )'b',      (char )'o',      (char )'n',      (char )'u', 
        (char )'s',      (char )'\n',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )'\t',      (char )'\n', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )'-',      (char )'c',      (char )',',      (char )'\t', 
        (char )'-',      (char )'s',      (char )'o',      (char )'r', 
        (char )'t',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )'T',      (char )'h',      (char )'e', 
        (char )' ',      (char )'o',      (char )'r',      (char )'d', 
        (char )'e',      (char )'r',      (char )' ',      (char )'i', 
        (char )'n',      (char )' ',      (char )'w',      (char )'h', 
        (char )'i',      (char )'c',      (char )'h',      (char )' ', 
        (char )'t',      (char )'h',      (char )'e',      (char )' ', 
        (char )'s',      (char )'e',      (char )'q',      (char )'u', 
        (char )'e',      (char )'n',      (char )'c',      (char )'e', 
        (char )'s',      (char )' ',      (char )'a',      (char )'p', 
        (char )'p',      (char )'e',      (char )'a',      (char )'r', 
        (char )' ',      (char )'i',      (char )'n',      (char )' ', 
        (char )'t',      (char )'h',      (char )'e',      (char )' ', 
        (char )'o',      (char )'u',      (char )'t',      (char )'p', 
        (char )'u',      (char )'t',      (char )' ',      (char )'a', 
        (char )'l',      (char )'i',      (char )'g',      (char )'n', 
        (char )'m',      (char )'e',      (char )'n',      (char )'t', 
        (char )'.',      (char )'\n',      (char )'\t',      (char )'\t', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )'<', 
        (char )'i',      (char )'n',      (char )'p',      (char )'u', 
        (char )'t',      (char )',',      (char )' ',      (char )'t', 
        (char )'r',      (char )'e',      (char )'e',      (char )',', 
        (char )' ',      (char )'g',      (char )'a',      (char )'p', 
        (char )'s',      (char )'.',      (char )'>',      (char )'\n', 
        (char )'\t',      (char )'\t',      (char )'\n',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )'-', 
        (char )'g',      (char )',',      (char )'\t',      (char )'-', 
        (char )'f',      (char )'e',      (char )'a',      (char )'t', 
        (char )'u',      (char )'r',      (char )'e',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )'S',      (char )'e',      (char )'l', 
        (char )'e',      (char )'c',      (char )'t',      (char )'s', 
        (char )' ',      (char )'f',      (char )'e',      (char )'a', 
        (char )'t',      (char )'u',      (char )'r',      (char )'e', 
        (char )' ',      (char )'m',      (char )'o',      (char )'d', 
        (char )'e',      (char )' ',      (char )'a',      (char )'n', 
        (char )'d',      (char )' ',      (char )'s',      (char )'p', 
        (char )'e',      (char )'c',      (char )'i',      (char )'f', 
        (char )'i',      (char )'e',      (char )'s',      (char )' ', 
        (char )'w',      (char )'h',      (char )'i',      (char )'c', 
        (char )'h',      (char )' ',      (char )'f',      (char )'e', 
        (char )'a',      (char )'t',      (char )'u',      (char )'r', 
        (char )'e',      (char )'s',      (char )' ',      (char )'a', 
        (char )'r',      (char )'e',      (char )' ',      (char )'t', 
        (char )'o',      (char )' ',      (char )'b',      (char )'e', 
        (char )' ',      (char )'u',      (char )'s',      (char )'e', 
        (char )'d',      (char )':',      (char )'\n',      (char )'\t', 
        (char )'\t',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )'e',      (char )'.',      (char )'g',      (char )'.', 
        (char )' ',      (char )'a',      (char )'l',      (char )'l', 
        (char )',',      (char )' ',      (char )'m',      (char )'a', 
        (char )'x',      (char )'p',      (char )'l',      (char )'p', 
        (char )',',      (char )' ',      (char )'S',      (char )'T', 
        (char )'R',      (char )'U',      (char )'C',      (char )'T', 
        (char )',',      (char )' ',      (char )'P',      (char )'F', 
        (char )'A',      (char )'M',      (char )'-',      (char )'A', 
        (char )'.',      (char )'.',      (char )'.',      (char )'.', 
        (char )'\n',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )'\t',      (char )'-',      (char )'s',      (char )'a', 
        (char )'m',      (char )'e',      (char )'_',      (char )'f', 
        (char )'e',      (char )'a',      (char )'t',      (char )'u', 
        (char )'r',      (char )'e',      (char )'_',      (char )'s', 
        (char )'c',      (char )'o',      (char )'r',      (char )'e', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )'S',      (char )'c', 
        (char )'o',      (char )'r',      (char )'e',      (char )' ', 
        (char )'f',      (char )'o',      (char )'r',      (char )' ', 
        (char )'a',      (char )'l',      (char )'i',      (char )'g', 
        (char )'n',      (char )'i',      (char )'n',      (char )'g', 
        (char )' ',      (char )'s',      (char )'a',      (char )'m', 
        (char )'e',      (char )' ',      (char )'f',      (char )'e', 
        (char )'a',      (char )'t',      (char )'u',      (char )'r', 
        (char )'e',      (char )'s',      (char )'\n',      (char )'\t', 
        (char )'\t',      (char )'-',      (char )'d',      (char )'i', 
        (char )'f',      (char )'f',      (char )'_',      (char )'f', 
        (char )'e',      (char )'a',      (char )'t',      (char )'u', 
        (char )'r',      (char )'e',      (char )'_',      (char )'s', 
        (char )'c',      (char )'o',      (char )'r',      (char )'e', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )'P',      (char )'e', 
        (char )'n',      (char )'a',      (char )'l',      (char )'t', 
        (char )'y',      (char )' ',      (char )'f',      (char )'o', 
        (char )'r',      (char )' ',      (char )'a',      (char )'l', 
        (char )'i',      (char )'g',      (char )'n',      (char )'i', 
        (char )'n',      (char )'g',      (char )' ',      (char )'d', 
        (char )'i',      (char )'f',      (char )'f',      (char )'e', 
        (char )'r',      (char )'e',      (char )'n',      (char )'t', 
        (char )' ',      (char )'f',      (char )'e',      (char )'a', 
        (char )'t',      (char )'u',      (char )'r',      (char )'e', 
        (char )'s',      (char )'\n',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )'\t',      (char )'\n', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )'-',      (char )'d',      (char )',',      (char )'\t', 
        (char )'-',      (char )'d',      (char )'i',      (char )'s', 
        (char )'t',      (char )'a',      (char )'n',      (char )'c', 
        (char )'e',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )'D',      (char )'i', 
        (char )'s',      (char )'t',      (char )'a',      (char )'n', 
        (char )'c',      (char )'e',      (char )' ',      (char )'m', 
        (char )'e',      (char )'t',      (char )'h',      (char )'o', 
        (char )'d',      (char )'.',      (char )'\n',      (char )'\t', 
        (char )'\t',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )'<',      (char )'w',      (char )'u',      (char )',', 
        (char )'p',      (char )'a',      (char )'i',      (char )'r', 
        (char )'>',      (char )'\n',      (char )'\t',      (char )'\t', 
        (char )'\n',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )'-',      (char )'b',      (char )',', 
        (char )'\t',      (char )'-',      (char )'g',      (char )'u', 
        (char )'i',      (char )'d',      (char )'e',      (char )'-', 
        (char )'t',      (char )'r',      (char )'e',      (char )'e', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )'G', 
        (char )'u',      (char )'i',      (char )'d',      (char )'e', 
        (char )' ',      (char )'t',      (char )'r',      (char )'e', 
        (char )'e',      (char )' ',      (char )'m',      (char )'e', 
        (char )'t',      (char )'h',      (char )'o',      (char )'d', 
        (char )'.',      (char )'\n',      (char )'\t',      (char )'\t', 
        (char )'-',      (char )'t',      (char )'r',      (char )'e', 
        (char )'e',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )'<',      (char )'n', 
        (char )'j',      (char )',',      (char )'u',      (char )'p', 
        (char )'g',      (char )'m',      (char )'a',      (char )'>', 
        (char )'\n',      (char )'\t',      (char )'\t',      (char )'\n', 
        (char )'\t',      (char )'-',      (char )'z',      (char )',', 
        (char )'\t',      (char )'-',      (char )'z',      (char )'c', 
        (char )'u',      (char )'t',      (char )'o',      (char )'f', 
        (char )'f',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )'P',      (char )'a', 
        (char )'r',      (char )'a',      (char )'m',      (char )'e', 
        (char )'t',      (char )'e',      (char )'r',      (char )' ', 
        (char )'u',      (char )'s',      (char )'e',      (char )'d', 
        (char )' ',      (char )'i',      (char )'n',      (char )' ', 
        (char )'t',      (char )'h',      (char )'e',      (char )' ', 
        (char )'w',      (char )'u',      (char )'-',      (char )'m', 
        (char )'a',      (char )'n',      (char )'b',      (char )'e', 
        (char )'r',      (char )' ',      (char )'b',      (char )'a', 
        (char )'s',      (char )'e',      (char )'d',      (char )' ', 
        (char )'d',      (char )'i',      (char )'s',      (char )'t', 
        (char )'a',      (char )'n',      (char )'c',      (char )'e', 
        (char )' ',      (char )'c',      (char )'a',      (char )'l', 
        (char )'c',      (char )'u',      (char )'l',      (char )'a', 
        (char )'t',      (char )'i',      (char )'o',      (char )'n', 
        (char )'\n',      (char )'\t',      (char )'\t',      (char )'\n', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )'-',      (char )'i',      (char )',',      (char )'\t', 
        (char )'-',      (char )'i',      (char )'n',      (char )'p', 
        (char )'u',      (char )'t',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )'T',      (char )'h', 
        (char )'e',      (char )' ',      (char )'i',      (char )'n', 
        (char )'p',      (char )'u',      (char )'t',      (char )' ', 
        (char )'f',      (char )'i',      (char )'l',      (char )'e', 
        (char )'.',      (char )'\n',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )'\t',      (char )'-', 
        (char )'i',      (char )'n',      (char )'f',      (char )'i', 
        (char )'l',      (char )'e',      (char )'\n',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )'\t', 
        (char )'-',      (char )'i',      (char )'n',      (char )'\n', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )'\t',      (char )'\n',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )'-',      (char )'o', 
        (char )',',      (char )'\t',      (char )'-',      (char )'o', 
        (char )'u',      (char )'t',      (char )'p',      (char )'u', 
        (char )'t',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )'T',      (char )'h',      (char )'e',      (char )' ', 
        (char )'o',      (char )'u',      (char )'t',      (char )'p', 
        (char )'u',      (char )'t',      (char )' ',      (char )'f', 
        (char )'i',      (char )'l',      (char )'e',      (char )'.', 
        (char )'\n',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )'\t',      (char )'-',      (char )'o', 
        (char )'u',      (char )'t',      (char )'f',      (char )'i', 
        (char )'l',      (char )'e',      (char )'\n',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )'\t', 
        (char )'-',      (char )'o',      (char )'u',      (char )'t', 
        (char )'\n',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )'\t',      (char )'\n',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )'-', 
        (char )'a',      (char )',',      (char )'\t',      (char )'-', 
        (char )'g',      (char )'a',      (char )'p',      (char )'_', 
        (char )'i',      (char )'n',      (char )'c',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )'P',      (char )'a', 
        (char )'r',      (char )'a',      (char )'m',      (char )'e', 
        (char )'t',      (char )'e',      (char )'r',      (char )' ', 
        (char )'i',      (char )'n',      (char )'c',      (char )'r', 
        (char )'e',      (char )'a',      (char )'s',      (char )'e', 
        (char )'s',      (char )' ',      (char )'g',      (char )'a', 
        (char )'p',      (char )' ',      (char )'p',      (char )'e', 
        (char )'n',      (char )'a',      (char )'l',      (char )'t', 
        (char )'i',      (char )'e',      (char )'s',      (char )' ', 
        (char )'d',      (char )'e',      (char )'p',      (char )'e', 
        (char )'n',      (char )'d',      (char )'i',      (char )'n', 
        (char )'g',      (char )' ',      (char )'o',      (char )'n', 
        (char )' ',      (char )'t',      (char )'h',      (char )'e', 
        (char )' ',      (char )'n',      (char )'u',      (char )'m', 
        (char )'b',      (char )'e',      (char )'r',      (char )' ', 
        (char )'o',      (char )'f',      (char )' ',      (char )'e', 
        (char )'x',      (char )'i',      (char )'s',      (char )'t', 
        (char )'i',      (char )'n',      (char )'g',      (char )' ', 
        (char )'g',      (char )'a',      (char )'p',      (char )'s', 
        (char )'\n',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )'\t',      (char )'\n',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )'-', 
        (char )'f',      (char )',',      (char )'\t',      (char )'-', 
        (char )'f',      (char )'o',      (char )'r',      (char )'m', 
        (char )'a',      (char )'t',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )'T',      (char )'h',      (char )'e', 
        (char )' ',      (char )'o',      (char )'u',      (char )'t', 
        (char )'p',      (char )'u',      (char )'t',      (char )' ', 
        (char )'f',      (char )'o',      (char )'r',      (char )'m', 
        (char )'a',      (char )'t',      (char )':',      (char )'\n', 
        (char )'\t',      (char )'\t',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )'<',      (char )'f',      (char )'a', 
        (char )'s',      (char )'t',      (char )'a',      (char )',', 
        (char )' ',      (char )'m',      (char )'s',      (char )'f', 
        (char )',',      (char )' ',      (char )'a',      (char )'l', 
        (char )'n',      (char )',',      (char )' ',      (char )'c', 
        (char )'l',      (char )'u',      (char )',',      (char )' ', 
        (char )'m',      (char )'a',      (char )'c',      (char )'s', 
        (char )'i',      (char )'m',      (char )'>',      (char )'\n', 
        (char )'\t',      (char )'\t',      (char )'\n',      (char )'\t', 
        (char )'-',      (char )'q',      (char )',',      (char )'\t', 
        (char )'-',      (char )'q',      (char )'u',      (char )'i', 
        (char )'e',      (char )'t',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )'P',      (char )'r', 
        (char )'i',      (char )'n',      (char )'t',      (char )' ', 
        (char )'n',      (char )'o',      (char )'t',      (char )'h', 
        (char )'i',      (char )'n',      (char )'g',      (char )' ', 
        (char )'t',      (char )'o',      (char )' ',      (char )'S', 
        (char )'T',      (char )'D',      (char )'E',      (char )'R', 
        (char )'R',      (char )'.',      (char )'\n',      (char )'\t', 
        (char )'\t',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )'R', 
        (char )'e',      (char )'a',      (char )'d',      (char )' ', 
        (char )'n',      (char )'o',      (char )'t',      (char )'h', 
        (char )'i',      (char )'n',      (char )'g',      (char )' ', 
        (char )'f',      (char )'r',      (char )'o',      (char )'m', 
        (char )' ',      (char )'S',      (char )'T',      (char )'D', 
        (char )'I',      (char )'N',      (char )'\n',      (char )'\t', 
        (char )'\n',      (char )'\t',      (char )'E',      (char )'x', 
        (char )'a',      (char )'m',      (char )'p',      (char )'l', 
        (char )'e',      (char )'s',      (char )':',      (char )'\n', 
        (char )'\n',      (char )'\t',      (char )'U',      (char )'s', 
        (char )'i',      (char )'n',      (char )'g',      (char )' ', 
        (char )'p',      (char )'i',      (char )'p',      (char )'e', 
        (char )'s',      (char )':',      (char )'\n',      (char )'\t', 
        (char )'\t',      (char )'k',      (char )'a',      (char )'l', 
        (char )'i',      (char )'g',      (char )'n',      (char )'2', 
        (char )' ',      (char )'[',      (char )'O',      (char )'P', 
        (char )'T',      (char )'I',      (char )'O',      (char )'N', 
        (char )'S',      (char )']',      (char )' ',      (char )'<', 
        (char )' ',      (char )'[',      (char )'I',      (char )'N', 
        (char )'F',      (char )'I',      (char )'L',      (char )'E', 
        (char )']',      (char )' ',      (char )' ',      (char )' ', 
        (char )'>',      (char )' ',      (char )'[',      (char )'O', 
        (char )'U',      (char )'T',      (char )'F',      (char )'I', 
        (char )'L',      (char )'E',      (char )']',      (char )'\n', 
        (char )'\t',      (char )'\t',      (char )'m',      (char )'o', 
        (char )'r',      (char )'e',      (char )' ',      (char )'[', 
        (char )'I',      (char )'N',      (char )'F',      (char )'I', 
        (char )'L',      (char )'E',      (char )']',      (char )' ', 
        (char )'|',      (char )' ',      (char )' ',      (char )'k', 
        (char )'a',      (char )'l',      (char )'i',      (char )'g', 
        (char )'n',      (char )'2',      (char )' ',      (char )'[', 
        (char )'O',      (char )'P',      (char )'T',      (char )'I', 
        (char )'O',      (char )'N',      (char )'S',      (char )']', 
        (char )' ',      (char )'>',      (char )' ',      (char )'[', 
        (char )'O',      (char )'U',      (char )'T',      (char )'F', 
        (char )'I',      (char )'L',      (char )'E',      (char )']', 
        (char )'\n',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )'\n',      (char )'\t', 
        (char )'R',      (char )'e',      (char )'l',      (char )'a', 
        (char )'x',      (char )'e',      (char )'d',      (char )' ', 
        (char )'g',      (char )'a',      (char )'p',      (char )' ', 
        (char )'p',      (char )'e',      (char )'n',      (char )'a', 
        (char )'l',      (char )'t',      (char )'i',      (char )'e', 
        (char )'s',      (char )':',      (char )'\n',      (char )'\t', 
        (char )'\t',      (char )'k',      (char )'a',      (char )'l', 
        (char )'i',      (char )'g',      (char )'n',      (char )'2', 
        (char )' ',      (char )'-',      (char )'g',      (char )'p', 
        (char )'o',      (char )' ',      (char )'6',      (char )'0', 
        (char )' ',      (char )'-',      (char )'g',      (char )'p', 
        (char )'e',      (char )' ',      (char )'9',      (char )' ', 
        (char )'-',      (char )'t',      (char )'g',      (char )'p', 
        (char )'e',      (char )' ',      (char )'0',      (char )' ', 
        (char )'-',      (char )'b',      (char )'o',      (char )'n', 
        (char )'u',      (char )'s',      (char )' ',      (char )'0', 
        (char )' ',      (char )'<',      (char )' ',      (char )'[', 
        (char )'I',      (char )'N',      (char )'F',      (char )'I', 
        (char )'L',      (char )'E',      (char )']',      (char )' ', 
        (char )' ',      (char )' ',      (char )'>',      (char )' ', 
        (char )'[',      (char )'O',      (char )'U',      (char )'T', 
        (char )'F',      (char )'I',      (char )'L',      (char )'E', 
        (char )']',      (char )'\n',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )'\n', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )'F',      (char )'e',      (char )'a',      (char )'t', 
        (char )'u',      (char )'r',      (char )'e',      (char )' ', 
        (char )'a',      (char )'l',      (char )'i',      (char )'g', 
        (char )'n',      (char )'m',      (char )'e',      (char )'n', 
        (char )'t',      (char )' ',      (char )'w',      (char )'i', 
        (char )'t',      (char )'h',      (char )' ',      (char )'p', 
        (char )'a',      (char )'i',      (char )'r',      (char )'w', 
        (char )'i',      (char )'s',      (char )'e',      (char )' ', 
        (char )'a',      (char )'l',      (char )'i',      (char )'g', 
        (char )'n',      (char )'m',      (char )'e',      (char )'n', 
        (char )'t',      (char )' ',      (char )'b',      (char )'a', 
        (char )'s',      (char )'e',      (char )'d',      (char )' ', 
        (char )'d',      (char )'i',      (char )'s',      (char )'t', 
        (char )'a',      (char )'n',      (char )'c',      (char )'e', 
        (char )' ',      (char )'m',      (char )'e',      (char )'t', 
        (char )'h',      (char )'o',      (char )'d',      (char )' ', 
        (char )'a',      (char )'n',      (char )'d',      (char )' ', 
        (char )'N',      (char )'J',      (char )' ',      (char )'g', 
        (char )'u',      (char )'i',      (char )'d',      (char )'e', 
        (char )' ',      (char )'t',      (char )'r',      (char )'e', 
        (char )'e',      (char )':',      (char )'\n',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )'\t', 
        (char )'k',      (char )'a',      (char )'l',      (char )'i', 
        (char )'g',      (char )'n',      (char )'2',      (char )' ', 
        (char )'-',      (char )'i',      (char )'n',      (char )' ', 
        (char )'t',      (char )'e',      (char )'s',      (char )'t', 
        (char )'.',      (char )'x',      (char )'m',      (char )'l', 
        (char )' ',      (char )'-',      (char )'d',      (char )'i', 
        (char )'s',      (char )'t',      (char )'a',      (char )'n', 
        (char )'c',      (char )'e',      (char )' ',      (char )'p', 
        (char )'a',      (char )'i',      (char )'r',      (char )' ', 
        (char )'-',      (char )'t',      (char )'r',      (char )'e', 
        (char )'e',      (char )' ',      (char )'n',      (char )'j', 
        (char )' ',      (char )'-',      (char )'s',      (char )'o', 
        (char )'r',      (char )'t',      (char )' ',      (char )'g', 
        (char )'a',      (char )'p',      (char )'s',      (char )' ', 
        (char )'-',      (char )'f',      (char )'e',      (char )'a', 
        (char )'t',      (char )'u',      (char )'r',      (char )'e', 
        (char )' ',      (char )'S',      (char )'T',      (char )'R', 
        (char )'U',      (char )'C',      (char )'T',      (char )' ', 
        (char )'-',      (char )'f',      (char )'o',      (char )'r', 
        (char )'m',      (char )'a',      (char )'t',      (char )' ', 
        (char )'m',      (char )'a',      (char )'c',      (char )'s', 
        (char )'i',      (char )'m',      (char )' ',      (char )'-', 
        (char )'o',      (char )'u',      (char )'t',      (char )' ', 
        (char )'t',      (char )'e',      (char )'s',      (char )'t', 
        (char )'.',      (char )'m',      (char )'a',      (char )'c', 
        (char )'s',      (char )'i',      (char )'m',      (char )'\n', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )'\000'};
#line 34 "/home/june/repo/benchmarks/collector/temp/kalign-2.03+20110620/kalign2_inferface.c"
void parameter_message(struct parameters *param ) 
{ 


  {
#line 36
  if (*(param->infile + 0)) {
#line 37
    if (param->dna) {
      {
#line 38
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Aligning %d RNA/DNA sequences from file %s with these parameters:\n",
              numseq, *(param->infile + 0));
      }
    } else {
      {
#line 40
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Aligning %d protein sequences from file %s with these parameters:\n",
              numseq, *(param->infile + 0));
      }
    }
  } else
#line 43
  if (param->dna) {
    {
#line 44
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Aligning %d RNA/DNA sequences with these parameters:\n",
            numseq);
    }
  } else {
    {
#line 46
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Aligning %d protein sequences with these parameters:\n",
            numseq);
    }
  }
  {
#line 54
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"        %0.8f\tgap open penalty\n",
          (double )gpo);
#line 56
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"        %0.8f\tgap extension\n",
          (double )gpe);
#line 58
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"        %0.8f\tterminal gap penalty\n",
          (double )tgpe);
#line 60
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"        %0.8f\tbonus\n",
          (double )param->secret);
  }
#line 66
  if (param->outfile) {
    {
#line 67
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Alignment will be written to file:\'%s\'.\n\n",
            param->outfile);
    }
  } else {
    {
#line 69
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Alignment will be written to stdout.\n\n");
    }
  }
#line 71
  return;
}
}
#line 118 "/home/june/repo/benchmarks/collector/temp/kalign-2.03+20110620/kalign2_inferface.c"
static char license[256]  = 
#line 118
  {      (char )'\n',      (char )'K',      (char )'a',      (char )'l', 
        (char )'i',      (char )'g',      (char )'n',      (char )' ', 
        (char )'v',      (char )'e',      (char )'r',      (char )'s', 
        (char )'i',      (char )'o',      (char )'n',      (char )' ', 
        (char )'2',      (char )'.',      (char )'0',      (char )'4', 
        (char )',',      (char )' ',      (char )'C',      (char )'o', 
        (char )'p',      (char )'y',      (char )'r',      (char )'i', 
        (char )'g',      (char )'h',      (char )'t',      (char )' ', 
        (char )'(',      (char )'C',      (char )')',      (char )' ', 
        (char )'2',      (char )'0',      (char )'0',      (char )'4', 
        (char )',',      (char )' ',      (char )'2',      (char )'0', 
        (char )'0',      (char )'5',      (char )',',      (char )' ', 
        (char )'2',      (char )'0',      (char )'0',      (char )'6', 
        (char )' ',      (char )'T',      (char )'i',      (char )'m', 
        (char )'o',      (char )' ',      (char )'L',      (char )'a', 
        (char )'s',      (char )'s',      (char )'m',      (char )'a', 
        (char )'n',      (char )'n',      (char )'\n',      (char )'\n', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )'K',      (char )'a',      (char )'l',      (char )'i', 
        (char )'g',      (char )'n',      (char )' ',      (char )'i', 
        (char )'s',      (char )' ',      (char )'f',      (char )'r', 
        (char )'e',      (char )'e',      (char )' ',      (char )'s', 
        (char )'o',      (char )'f',      (char )'t',      (char )'w', 
        (char )'a',      (char )'r',      (char )'e',      (char )'.', 
        (char )' ',      (char )'Y',      (char )'o',      (char )'u', 
        (char )' ',      (char )'c',      (char )'a',      (char )'n', 
        (char )' ',      (char )'r',      (char )'e',      (char )'d', 
        (char )'i',      (char )'s',      (char )'t',      (char )'r', 
        (char )'i',      (char )'b',      (char )'u',      (char )'t', 
        (char )'e',      (char )' ',      (char )'i',      (char )'t', 
        (char )' ',      (char )'a',      (char )'n',      (char )'d', 
        (char )'/',      (char )'o',      (char )'r',      (char )' ', 
        (char )'m',      (char )'o',      (char )'d',      (char )'i', 
        (char )'f',      (char )'y',      (char )'\n',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )'i', 
        (char )'t',      (char )' ',      (char )'u',      (char )'n', 
        (char )'d',      (char )'e',      (char )'r',      (char )' ', 
        (char )'t',      (char )'h',      (char )'e',      (char )' ', 
        (char )'t',      (char )'e',      (char )'r',      (char )'m', 
        (char )'s',      (char )' ',      (char )'o',      (char )'f', 
        (char )' ',      (char )'t',      (char )'h',      (char )'e', 
        (char )' ',      (char )'G',      (char )'N',      (char )'U', 
        (char )' ',      (char )'G',      (char )'e',      (char )'n', 
        (char )'e',      (char )'r',      (char )'a',      (char )'l', 
        (char )' ',      (char )'P',      (char )'u',      (char )'b', 
        (char )'l',      (char )'i',      (char )'c',      (char )' ', 
        (char )'L',      (char )'i',      (char )'c',      (char )'e', 
        (char )'n',      (char )'s',      (char )'e',      (char )' ', 
        (char )'a',      (char )'s',      (char )'\n',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )'p', 
        (char )'u',      (char )'b',      (char )'l',      (char )'i', 
        (char )'s',      (char )'h',      (char )'e',      (char )'d', 
        (char )' ',      (char )'b',      (char )'y',      (char )' ', 
        (char )'t',      (char )'h',      (char )'e',      (char )' ', 
        (char )'F',      (char )'r',      (char )'e',      (char )'e', 
        (char )' ',      (char )'S',      (char )'o',      (char )'f', 
        (char )'t',      (char )'w',      (char )'a',      (char )'r', 
        (char )'e',      (char )' ',      (char )'F',      (char )'o', 
        (char )'u',      (char )'n',      (char )'d',      (char )'a', 
        (char )'t',      (char )'i',      (char )'o',      (char )'n', 
        (char )'.',      (char )'\n',      (char )'\n',      (char )'\000'};
#line 127 "/home/june/repo/benchmarks/collector/temp/kalign-2.03+20110620/kalign2_inferface.c"
static struct option long_options[48]  = 
#line 127
  {      {"gapopen", 1, (int *)0, 's'}, 
        {"gpo", 1, (int *)0, 's'}, 
        {"gapextension", 1, (int *)0, 'e'}, 
        {"gpe", 1, (int *)0, 'e'}, 
        {"secret", 1, (int *)0, 'm'}, 
        {"bonus", 1, (int *)0, 'm'}, 
        {"terminalgapextension", 1, (int *)0, 't'}, 
        {"tgpe", 1, (int *)0, 't'}, 
        {"zcutoff", 1, (int *)0, 0}, 
        {"distance", 1, (int *)0, 'd'}, 
        {"ntree", 1, (int *)0, 0}, 
        {"tree", 1, (int *)0, 0}, 
        {"format", 1, (int *)0, 'f'}, 
        {"reformat", 0, (int *)0, 'r'}, 
        {"sort", 1, (int *)0, 'c'}, 
        {"feature", 1, (int *)0, 0}, 
        {"type", 1, (int *)0, 0}, 
        {"alter_gaps", 1, (int *)0, 0}, 
        {"altergaps", 1, (int *)0, 0}, 
        {"alter_range", 1, (int *)0, 0}, 
        {"alter_weight", 1, (int *)0, 0}, 
        {"internal_gap_weight", 1, (int *)0, 0}, 
        {"smooth_window", 1, (int *)0, 0}, 
        {"gap_inc", 1, (int *)0, 'a'}, 
        {"matrix", 1, (int *)0, 0}, 
        {"mmbonus", 1, (int *)0, 0}, 
        {"nuc", 0, (int *)0, 0}, 
        {"dna", 0, (int *)0, 0}, 
        {"rna", 0, (int *)0, 0}, 
        {"protein", 0, (int *)0, 0}, 
        {"profile", 0, (int *)0, 0}, 
        {"prof", 0, (int *)0, 0}, 
        {"id", 1, (int *)0, 0}, 
        {"printtree", 1, (int *)0, 0}, 
        {"svgtree", 1, (int *)0, 0}, 
        {"svg_tree", 1, (int *)0, 0}, 
        {"pairwise", 0, (int *)0, 0}, 
        {"same_feature_score", 1, (int *)0, 0}, 
        {"diff_feature_score", 1, (int *)0, 0}, 
        {"input", 1, (int *)0, 'i'}, 
        {"infile", 1, (int *)0, 'i'}, 
        {"in", 1, (int *)0, 'i'}, 
        {"output", 1, (int *)0, 'o'}, 
        {"outfile", 1, (int *)0, 'o'}, 
        {"out", 1, (int *)0, 'o'}, 
        {"help", 0, (int *)0, 'h'}, 
        {"quiet", 0, (int *)0, 'q'}, 
        {(char const   *)0, 0, (int *)0, 0}};
#line 73 "/home/june/repo/benchmarks/collector/temp/kalign-2.03+20110620/kalign2_inferface.c"
struct parameters *interface(struct parameters *param , int argc , char **argv ) 
{ 
  int i ;
  int c ;
  void *tmp ;
  int option_index ;
  double tmp___0 ;
  double tmp___1 ;
  double tmp___2 ;
  double tmp___3 ;
  double tmp___4 ;
  double tmp___5 ;
  double tmp___6 ;
  double tmp___7 ;
  double tmp___8 ;
  double tmp___9 ;
  double tmp___10 ;
  double tmp___11 ;
  double tmp___12 ;
  double tmp___13 ;
  double tmp___14 ;
  double tmp___15 ;
  void *tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;

  {
  {
#line 76
  param->gpo = (float )(- 1.0);
#line 77
  param->gpe = (float )(- 1.0);
#line 78
  param->tgpe = (float )(- 1.0);
#line 79
  param->secret = (float )(- 1.0);
#line 80
  param->zlevel = (float )58.8;
#line 81
  param->sub_matrix = (char *)0;
#line 82
  param->aa = 0;
#line 84
  tmp = malloc(sizeof(char *) * 3UL);
#line 84
  param->infile = (char **)tmp;
#line 85
  *(param->infile + 0) = (char *)0;
#line 86
  *(param->infile + 1) = (char *)0;
#line 87
  *(param->infile + 2) = (char *)0;
#line 88
  param->input = (char *)0;
#line 89
  param->outfile = (char *)0;
#line 90
  param->format = (char *)0;
#line 91
  param->help_flag = 0;
#line 92
  param->quiet = 0;
#line 93
  param->id = -1;
#line 94
  param->distance = (char *)"wu";
#line 95
  param->reformat = 0;
#line 96
  param->sort = (char *)0;
#line 98
  param->print_svg_tree = (char *)0;
#line 100
  param->dna = -1;
#line 102
  param->feature_type = (char *)0;
#line 103
  param->alignment_type = (char *)"default";
#line 104
  param->tree = (char *)"upgma";
#line 105
  param->ntree = 2;
#line 106
  param->print_tree = (char *)0;
#line 107
  param->alter_gaps = 0;
#line 108
  param->alter_range = (float )0.5;
#line 109
  param->alter_weight = 100;
#line 111
  param->internal_gap_weight = (float )0;
#line 112
  param->smooth_window = 1;
#line 113
  param->gap_inc = (float )0.0;
#line 114
  param->same_feature_score = (float )75;
#line 115
  param->diff_feature_score = (float )-5;
  }
  {
#line 126
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 181
    option_index = 0;
#line 182
    c = getopt_long_only(argc, (char * const  *)argv, "i:o:hqs:e:m:t:z:c:f:d:b:a:r",
                         (struct option  const  *)(long_options), & option_index);
    }
#line 185
    if (c == -1) {
#line 186
      goto while_break;
    }
    {
#line 189
    if (c == 0) {
#line 189
      goto case_0;
    }
#line 304
    if (c == 115) {
#line 304
      goto case_115;
    }
#line 308
    if (c == 101) {
#line 308
      goto case_101;
    }
#line 311
    if (c == 109) {
#line 311
      goto case_109;
    }
#line 314
    if (c == 116) {
#line 314
      goto case_116;
    }
#line 317
    if (c == 122) {
#line 317
      goto case_122;
    }
#line 321
    if (c == 99) {
#line 321
      goto case_99;
    }
#line 324
    if (c == 102) {
#line 324
      goto case_102;
    }
#line 327
    if (c == 114) {
#line 327
      goto case_114;
    }
#line 331
    if (c == 100) {
#line 331
      goto case_100;
    }
#line 334
    if (c == 98) {
#line 334
      goto case_98;
    }
#line 340
    if (c == 104) {
#line 340
      goto case_104;
    }
#line 343
    if (c == 105) {
#line 343
      goto case_105;
    }
#line 346
    if (c == 111) {
#line 346
      goto case_111;
    }
#line 349
    if (c == 97) {
#line 349
      goto case_97;
    }
#line 352
    if (c == 113) {
#line 352
      goto case_113;
    }
#line 355
    if (c == 63) {
#line 355
      goto case_63;
    }
#line 359
    goto switch_default___0;
    case_0: /* CIL Label */ 
#line 190
    if ((unsigned long )long_options[option_index].flag != (unsigned long )((int *)0)) {
#line 191
      goto switch_break;
    }
    {
#line 195
    if (option_index == 1) {
#line 195
      goto case_1;
    }
#line 195
    if (option_index == 0) {
#line 195
      goto case_1;
    }
#line 200
    if (option_index == 3) {
#line 200
      goto case_3;
    }
#line 200
    if (option_index == 2) {
#line 200
      goto case_3;
    }
#line 204
    if (option_index == 5) {
#line 204
      goto case_5;
    }
#line 204
    if (option_index == 4) {
#line 204
      goto case_5;
    }
#line 208
    if (option_index == 7) {
#line 208
      goto case_7;
    }
#line 208
    if (option_index == 6) {
#line 208
      goto case_7;
    }
#line 211
    if (option_index == 8) {
#line 211
      goto case_8;
    }
#line 214
    if (option_index == 9) {
#line 214
      goto case_9;
    }
#line 217
    if (option_index == 10) {
#line 217
      goto case_10;
    }
#line 220
    if (option_index == 11) {
#line 220
      goto case_11;
    }
#line 223
    if (option_index == 12) {
#line 223
      goto case_12;
    }
#line 226
    if (option_index == 13) {
#line 226
      goto case_13;
    }
#line 229
    if (option_index == 14) {
#line 229
      goto case_14;
    }
#line 232
    if (option_index == 15) {
#line 232
      goto case_15;
    }
#line 235
    if (option_index == 16) {
#line 235
      goto case_16;
    }
#line 239
    if (option_index == 18) {
#line 239
      goto case_18;
    }
#line 239
    if (option_index == 17) {
#line 239
      goto case_18;
    }
#line 242
    if (option_index == 19) {
#line 242
      goto case_19;
    }
#line 245
    if (option_index == 20) {
#line 245
      goto case_20;
    }
#line 248
    if (option_index == 21) {
#line 248
      goto case_21;
    }
#line 251
    if (option_index == 22) {
#line 251
      goto case_22;
    }
#line 254
    if (option_index == 23) {
#line 254
      goto case_23;
    }
#line 257
    if (option_index == 24) {
#line 257
      goto case_24;
    }
#line 260
    if (option_index == 25) {
#line 260
      goto case_25;
    }
#line 265
    if (option_index == 28) {
#line 265
      goto case_28;
    }
#line 265
    if (option_index == 27) {
#line 265
      goto case_28;
    }
#line 265
    if (option_index == 26) {
#line 265
      goto case_28;
    }
#line 268
    if (option_index == 29) {
#line 268
      goto case_29;
    }
#line 272
    if (option_index == 31) {
#line 272
      goto case_31;
    }
#line 272
    if (option_index == 30) {
#line 272
      goto case_31;
    }
#line 275
    if (option_index == 32) {
#line 275
      goto case_32;
    }
#line 278
    if (option_index == 33) {
#line 278
      goto case_33;
    }
#line 282
    if (option_index == 35) {
#line 282
      goto case_35;
    }
#line 282
    if (option_index == 34) {
#line 282
      goto case_35;
    }
#line 285
    if (option_index == 36) {
#line 285
      goto case_36;
    }
#line 288
    if (option_index == 37) {
#line 288
      goto case_37;
    }
#line 291
    if (option_index == 38) {
#line 291
      goto case_38;
    }
#line 296
    goto switch_default;
    case_1: /* CIL Label */ 
    case_0___0: /* CIL Label */ 
    {
#line 196
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"GAGAGA\n");
#line 197
    tmp___0 = atof((char const   *)optarg);
#line 197
    param->gpo = (float )tmp___0;
    }
#line 198
    goto switch_break___0;
    case_3: /* CIL Label */ 
    case_2: /* CIL Label */ 
    {
#line 201
    tmp___1 = atof((char const   *)optarg);
#line 201
    param->gpe = (float )tmp___1;
    }
#line 202
    goto switch_break___0;
    case_5: /* CIL Label */ 
    case_4: /* CIL Label */ 
    {
#line 205
    tmp___2 = atof((char const   *)optarg);
#line 205
    param->secret = (float )tmp___2;
    }
#line 206
    goto switch_break___0;
    case_7: /* CIL Label */ 
    case_6: /* CIL Label */ 
    {
#line 209
    tmp___3 = atof((char const   *)optarg);
#line 209
    param->tgpe = (float )tmp___3;
    }
#line 210
    goto switch_break___0;
    case_8: /* CIL Label */ 
    {
#line 212
    tmp___4 = atof((char const   *)optarg);
#line 212
    param->zlevel = (float )tmp___4;
    }
#line 213
    goto switch_break___0;
    case_9: /* CIL Label */ 
#line 215
    param->distance = optarg;
#line 216
    goto switch_break___0;
    case_10: /* CIL Label */ 
    {
#line 218
    param->ntree = atoi((char const   *)optarg);
    }
#line 219
    goto switch_break___0;
    case_11: /* CIL Label */ 
#line 221
    param->tree = optarg;
#line 222
    goto switch_break___0;
    case_12: /* CIL Label */ 
#line 224
    param->format = optarg;
#line 225
    goto switch_break___0;
    case_13: /* CIL Label */ 
#line 227
    param->reformat = 1;
#line 228
    goto switch_break___0;
    case_14: /* CIL Label */ 
#line 230
    param->sort = optarg;
#line 231
    goto switch_break___0;
    case_15: /* CIL Label */ 
#line 233
    param->feature_type = optarg;
#line 234
    goto switch_break___0;
    case_16: /* CIL Label */ 
#line 236
    param->alignment_type = optarg;
#line 237
    goto switch_break___0;
    case_18: /* CIL Label */ 
    case_17: /* CIL Label */ 
    {
#line 240
    param->alter_gaps = atoi((char const   *)optarg);
    }
#line 241
    goto switch_break___0;
    case_19: /* CIL Label */ 
    {
#line 243
    tmp___5 = atof((char const   *)optarg);
#line 243
    param->alter_range = (float )tmp___5;
    }
#line 244
    goto switch_break___0;
    case_20: /* CIL Label */ 
    {
#line 246
    param->alter_weight = atoi((char const   *)optarg);
    }
#line 247
    goto switch_break___0;
    case_21: /* CIL Label */ 
    {
#line 249
    tmp___6 = atof((char const   *)optarg);
#line 249
    param->internal_gap_weight = (float )tmp___6;
    }
#line 250
    goto switch_break___0;
    case_22: /* CIL Label */ 
    {
#line 252
    param->smooth_window = atoi((char const   *)optarg);
    }
#line 253
    goto switch_break___0;
    case_23: /* CIL Label */ 
    {
#line 255
    tmp___7 = atof((char const   *)optarg);
#line 255
    param->gap_inc = (float )tmp___7;
    }
#line 256
    goto switch_break___0;
    case_24: /* CIL Label */ 
#line 258
    param->sub_matrix = optarg;
#line 259
    goto switch_break___0;
    case_25: /* CIL Label */ 
    {
#line 261
    param->aa = atoi((char const   *)optarg);
    }
#line 262
    goto switch_break___0;
    case_28: /* CIL Label */ 
    case_27: /* CIL Label */ 
    case_26: /* CIL Label */ 
#line 266
    param->dna = 1;
#line 267
    goto switch_break___0;
    case_29: /* CIL Label */ 
#line 269
    param->dna = 0;
#line 270
    goto switch_break___0;
    case_31: /* CIL Label */ 
    case_30: /* CIL Label */ 
#line 273
    param->alignment_type = (char *)"profile";
#line 274
    goto switch_break___0;
    case_32: /* CIL Label */ 
    {
#line 276
    param->id = atoi((char const   *)optarg);
    }
#line 277
    goto switch_break___0;
    case_33: /* CIL Label */ 
#line 279
    param->print_tree = optarg;
#line 280
    goto switch_break___0;
    case_35: /* CIL Label */ 
    case_34: /* CIL Label */ 
#line 283
    param->print_svg_tree = optarg;
#line 284
    goto switch_break___0;
    case_36: /* CIL Label */ 
#line 286
    param->alignment_type = (char *)"pairwise";
#line 287
    goto switch_break___0;
    case_37: /* CIL Label */ 
    {
#line 289
    tmp___8 = atof((char const   *)optarg);
#line 289
    param->same_feature_score = (float )tmp___8;
    }
#line 290
    goto switch_break___0;
    case_38: /* CIL Label */ 
    {
#line 292
    tmp___9 = atof((char const   *)optarg);
#line 292
    param->diff_feature_score = (float )tmp___9;
    }
#line 293
    goto switch_break___0;
    switch_default: /* CIL Label */ 
#line 297
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
#line 303
    goto switch_break;
    case_115: /* CIL Label */ 
    {
#line 305
    tmp___10 = atof((char const   *)optarg);
#line 305
    param->gpo = (float )tmp___10;
    }
#line 307
    goto switch_break;
    case_101: /* CIL Label */ 
    {
#line 309
    tmp___11 = atof((char const   *)optarg);
#line 309
    param->gpe = (float )tmp___11;
    }
#line 310
    goto switch_break;
    case_109: /* CIL Label */ 
    {
#line 312
    tmp___12 = atof((char const   *)optarg);
#line 312
    param->secret = (float )tmp___12;
    }
#line 313
    goto switch_break;
    case_116: /* CIL Label */ 
    {
#line 315
    tmp___13 = atof((char const   *)optarg);
#line 315
    param->tgpe = (float )tmp___13;
    }
#line 316
    goto switch_break;
    case_122: /* CIL Label */ 
    {
#line 318
    tmp___14 = atof((char const   *)optarg);
#line 318
    param->zlevel = (float )tmp___14;
    }
#line 319
    goto switch_break;
    case_99: /* CIL Label */ 
#line 322
    param->sort = optarg;
#line 323
    goto switch_break;
    case_102: /* CIL Label */ 
#line 325
    param->format = optarg;
#line 326
    goto switch_break;
    case_114: /* CIL Label */ 
#line 328
    param->reformat = 1;
#line 329
    goto switch_break;
    case_100: /* CIL Label */ 
#line 332
    param->distance = optarg;
#line 333
    goto switch_break;
    case_98: /* CIL Label */ 
#line 335
    param->tree = optarg;
#line 336
    goto switch_break;
    case_104: /* CIL Label */ 
#line 341
    param->help_flag = 1;
#line 342
    goto switch_break;
    case_105: /* CIL Label */ 
#line 344
    *(param->infile + 1) = optarg;
#line 345
    goto switch_break;
    case_111: /* CIL Label */ 
#line 347
    param->outfile = optarg;
#line 348
    goto switch_break;
    case_97: /* CIL Label */ 
    {
#line 350
    tmp___15 = atof((char const   *)optarg);
#line 350
    param->gap_inc = (float )tmp___15;
    }
#line 351
    goto switch_break;
    case_113: /* CIL Label */ 
#line 353
    param->quiet = 1;
#line 354
    goto switch_break;
    case_63: /* CIL Label */ 
    {
#line 356
    free_param(param);
#line 357
    exit(1);
    }
#line 358
    goto switch_break;
    switch_default___0: /* CIL Label */ 
    {
#line 360
    abort();
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 366
  if (optind < argc) {
#line 367
    c = 0;
#line 370
    if (*(param->infile + 1)) {
#line 371
      i = 3;
    } else {
#line 373
      i = 2;
    }
    {
#line 375
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"EXTRA :%d\n",
            argc - optind);
#line 376
    tmp___16 = realloc((void *)param->infile, sizeof(char *) * (unsigned long )((argc - optind) + i));
#line 376
    param->infile = (char **)tmp___16;
#line 377
    c = i - 1;
    }
    {
#line 377
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 377
      if (! (c < (argc - optind) + i)) {
#line 377
        goto while_break___0;
      }
#line 378
      *(param->infile + c) = (char *)0;
#line 377
      c ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 380
    c = i - 1;
    {
#line 381
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 381
      if (! (optind < argc)) {
#line 381
        goto while_break___1;
      }
#line 394
      tmp___17 = optind;
#line 394
      optind ++;
#line 394
      *(param->infile + c) = *(argv + tmp___17);
#line 395
      c ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  {
#line 400
  tmp___18 = byg_start((char *)"pairwise", param->alignment_type);
  }
#line 400
  if (tmp___18 != -1) {
#line 401
    param->ntree = 1;
#line 402
    if ((double )param->tgpe == - 1.0) {
#line 403
      param->tgpe = 0.0f;
    }
  }
#line 406
  if ((double )param->gap_inc < 0.0) {
    {
#line 407
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s\n",
            usage);
#line 408
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Invalid parameter setting: gap_inc needs to be > 0 \n");
#line 409
    exit(1);
    }
  }
#line 412
  if (param->quiet) {
    {
#line 413
    fclose(stderr);
    }
  }
  {
#line 415
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s",
          license);
  }
#line 416
  if (param->help_flag) {
    {
#line 417
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s\n",
            usage);
#line 418
    exit(1);
    }
  }
#line 427
  return (param);
}
}
/* compiler builtin: 
   void *__builtin_alloca(unsigned long  ) ;  */
#line 269 "/home/june/repo/benchmarks/collector/temp/kalign-2.03+20110620/kalign2.h"
int check_identity(char *n , char *m ) ;
#line 300
void free_utf(struct utype_ufeat *utf ) ;
#line 301
void free_feature_matrix(struct feature_matrix *fm ) ;
#line 303
struct utype_ufeat *get_unique_features(struct alignment *aln , struct utype_ufeat *utf ) ;
#line 304
struct utype_ufeat *traverse_ft(struct utype_ufeat *utf , struct feature *n ) ;
#line 305
struct feature *add_unique_feature(struct feature *n , struct feature *toadd ) ;
#line 306
struct feature *add_unique_type(struct feature *n , struct feature *toadd ) ;
#line 399 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 28 "/home/june/repo/benchmarks/collector/temp/kalign-2.03+20110620/kalign2_feature.h"
float *feature_hirschberg_update(float const   *profa , float const   *profb , float *newp ,
                                 int *path , int sipa , int sipb ) ;
#line 29
float *make_unified_profile(float *prof , struct alignment *aln , int num , float **subm ,
                            struct feature_matrix *fm ) ;
#line 30
void set_unified_gap_penalties(float *prof , int len , int nsip ) ;
#line 32
int *feature_hirsch_pp_dyn(float const   *prof1 , float const   *prof2 , struct hirsch_mem *hm ,
                           int *hirsch_path ) ;
#line 33
int *feature_hirsch_align_two_pp_vector(float const   *prof1 , float const   *prof2 ,
                                        struct hirsch_mem *hm , int *hirsch_path ,
                                        float *input_states , int *old_cor ) ;
#line 34
struct states *feature_foward_hirsch_pp_dyn(float const   *prof1 , float const   *prof2 ,
                                            struct hirsch_mem *hm ) ;
#line 35
struct states *feature_backward_hirsch_pp_dyn(float const   *prof1 , float const   *prof2 ,
                                              struct hirsch_mem *hm ) ;
#line 29 "/home/june/repo/benchmarks/collector/temp/kalign-2.03+20110620/kalign2_feature.c"
static int stride  ;
#line 30 "/home/june/repo/benchmarks/collector/temp/kalign-2.03+20110620/kalign2_feature.c"
static int dim  ;
#line 31 "/home/june/repo/benchmarks/collector/temp/kalign-2.03+20110620/kalign2_feature.c"
static int gpo_pos  ;
#line 32 "/home/june/repo/benchmarks/collector/temp/kalign-2.03+20110620/kalign2_feature.c"
static int gpe_pos  ;
#line 33 "/home/june/repo/benchmarks/collector/temp/kalign-2.03+20110620/kalign2_feature.c"
static int tgpe_pos  ;
#line 35 "/home/june/repo/benchmarks/collector/temp/kalign-2.03+20110620/kalign2_feature.c"
int **feature_hirschberg_alignment(struct alignment *aln , int *tree , float **submatrix ,
                                   int **map , struct feature_matrix *fm ) 
{ 
  struct hirsch_mem *hm ;
  int i ;
  int j ;
  int g ;
  int a ;
  int b ;
  int c ;
  int len_a ;
  int len_b ;
  float **profile ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
  {
#line 37
  hm = (struct hirsch_mem *)0;
#line 41
  profile = (float **)0;
#line 43
  stride = (26 + fm->mdim) * 2 + 3;
#line 44
  dim = 26 + fm->mdim;
#line 45
  gpo_pos = dim << 1;
#line 46
  gpe_pos = (dim << 1) + 1;
#line 47
  tgpe_pos = (dim << 1) + 2;
#line 49
  tmp = malloc(sizeof(float *) * (unsigned long )numprofiles);
#line 49
  profile = (float **)tmp;
#line 50
  i = 0;
  }
  {
#line 50
  while (1) {
    while_continue: /* CIL Label */ ;
#line 50
    if (! ((unsigned int )i < numprofiles)) {
#line 50
      goto while_break;
    }
#line 51
    *(profile + i) = (float *)0;
#line 50
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 54
  tmp___0 = malloc(sizeof(int *) * (unsigned long )numprofiles);
#line 54
  map = (int **)tmp___0;
#line 55
  i = 0;
  }
  {
#line 55
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 55
    if (! ((unsigned int )i < numprofiles)) {
#line 55
      goto while_break___0;
    }
#line 56
    *(map + i) = (int *)0;
#line 55
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 59
  hm = hirsch_mem_alloc(hm, 1024);
#line 61
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\nAlignment:\n");
#line 63
  i = 0;
  }
  {
#line 63
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 63
    if (! ((unsigned int )i < numseq - 1U)) {
#line 63
      goto while_break___1;
    }
    {
#line 64
    a = *(tree + i * 3);
#line 65
    b = *(tree + (i * 3 + 1));
#line 66
    c = *(tree + (i * 3 + 2));
#line 67
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\r%8.0f percent done",
            (double )(((float )i / (float )numseq) * (float )100));
#line 69
    len_a = (int )*(aln->sl + a);
#line 70
    len_b = (int )*(aln->sl + b);
    }
#line 73
    if (len_a > len_b) {
#line 73
      g = len_a;
    } else {
#line 73
      g = len_b;
    }
    {
#line 74
    tmp___1 = malloc(sizeof(int ) * (unsigned long )(g + 2));
#line 74
    *(map + c) = (int *)tmp___1;
    }
#line 75
    if (g > hm->size) {
      {
#line 76
      hm = hirsch_mem_realloc(hm, g);
      }
    }
#line 79
    j = 0;
    {
#line 79
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 79
      if (! (j < g + 2)) {
#line 79
        goto while_break___2;
      }
#line 80
      *(*(map + c) + j) = -1;
#line 79
      j ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 83
    if ((unsigned int )a < numseq) {
      {
#line 84
      *(profile + a) = make_unified_profile(*(profile + a), aln, a, submatrix, fm);
      }
    }
    {
#line 86
    set_unified_gap_penalties(*(profile + a), len_a, (int )*(aln->nsip + b));
    }
#line 88
    if ((unsigned int )b < numseq) {
      {
#line 89
      *(profile + b) = make_unified_profile(*(profile + b), aln, b, submatrix, fm);
      }
    }
    {
#line 91
    set_unified_gap_penalties(*(profile + b), len_b, (int )*(aln->nsip + a));
#line 93
    hm->starta = 0;
#line 94
    hm->startb = 0;
#line 95
    hm->enda = len_a;
#line 96
    hm->endb = len_b;
#line 97
    hm->len_a = len_a;
#line 98
    hm->len_b = len_b;
#line 100
    (hm->f + 0)->a = (float )0.0;
#line 101
    (hm->f + 0)->ga = - 3.40282346638528859812e+38F;
#line 102
    (hm->f + 0)->gb = - 3.40282346638528859812e+38F;
#line 103
    (hm->b + 0)->a = (float )0.0;
#line 104
    (hm->b + 0)->ga = - 3.40282346638528859812e+38F;
#line 105
    (hm->b + 0)->gb = - 3.40282346638528859812e+38F;
    }
#line 108
    if (len_a < len_b) {
      {
#line 110
      *(map + c) = feature_hirsch_pp_dyn((float const   *)*(profile + a), (float const   *)*(profile + b),
                                         hm, *(map + c));
      }
    } else {
      {
#line 113
      hm->enda = len_b;
#line 114
      hm->endb = len_a;
#line 115
      hm->len_a = len_b;
#line 116
      hm->len_b = len_a;
#line 117
      *(map + c) = feature_hirsch_pp_dyn((float const   *)*(profile + b), (float const   *)*(profile + a),
                                         hm, *(map + c));
#line 118
      *(map + c) = mirror_hirsch_path(*(map + c), len_a, len_b);
      }
    }
    {
#line 120
    *(map + c) = add_gap_info_to_hirsch_path(*(map + c), len_a, len_b);
    }
#line 122
    if ((unsigned int )i != numseq - 2U) {
      {
#line 123
      tmp___2 = malloc((sizeof(float ) * (unsigned long )stride) * (unsigned long )(*(*(map + c) + 0) + 2));
#line 123
      *(profile + c) = (float *)tmp___2;
#line 124
      *(profile + c) = feature_hirschberg_update((float const   *)*(profile + a),
                                                 (float const   *)*(profile + b),
                                                 *(profile + c), *(map + c), (int )*(aln->nsip + a),
                                                 (int )*(aln->nsip + b));
      }
    }
    {
#line 126
    *(aln->sl + c) = (unsigned int )*(*(map + c) + 0);
#line 128
    *(aln->nsip + c) = *(aln->nsip + a) + *(aln->nsip + b);
#line 129
    tmp___3 = malloc(sizeof(int ) * (unsigned long )(*(aln->nsip + a) + *(aln->nsip + b)));
#line 129
    *(aln->sip + c) = (unsigned int *)tmp___3;
#line 130
    g = 0;
#line 131
    j = (int )*(aln->nsip + a);
    }
    {
#line 131
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 131
      tmp___4 = j;
#line 131
      j --;
#line 131
      if (! tmp___4) {
#line 131
        goto while_break___3;
      }
#line 132
      *(*(aln->sip + c) + g) = *(*(aln->sip + a) + j);
#line 133
      g ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 135
    j = (int )*(aln->nsip + b);
    {
#line 135
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 135
      tmp___5 = j;
#line 135
      j --;
#line 135
      if (! tmp___5) {
#line 135
        goto while_break___4;
      }
#line 136
      *(*(aln->sip + c) + g) = *(*(aln->sip + b) + j);
#line 137
      g ++;
    }
    while_break___4: /* CIL Label */ ;
    }
    {
#line 140
    free((void *)*(profile + a));
#line 141
    free((void *)*(profile + b));
#line 63
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 143
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\r%8.0f percent done\n",
          100.0);
#line 144
  free((void *)profile);
#line 145
  hirsch_mem_free(hm);
#line 146
  i = 32;
  }
  {
#line 146
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 146
    tmp___6 = i;
#line 146
    i --;
#line 146
    if (! tmp___6) {
#line 146
      goto while_break___5;
    }
    {
#line 147
    free((void *)*(submatrix + i));
    }
  }
  while_break___5: /* CIL Label */ ;
  }
  {
#line 149
  free((void *)submatrix);
#line 150
  free_feature_matrix(fm);
  }
#line 151
  return (map);
}
}
#line 155 "/home/june/repo/benchmarks/collector/temp/kalign-2.03+20110620/kalign2_feature.c"
float *feature_hirschberg_update(float const   *profa , float const   *profb , float *newp ,
                                 int *path , int sipa , int sipb ) 
{ 
  int i ;
  int j ;
  int c ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 158
  i = stride;
  {
#line 158
  while (1) {
    while_continue: /* CIL Label */ ;
#line 158
    tmp = i;
#line 158
    i --;
#line 158
    if (! tmp) {
#line 158
      goto while_break;
    }
#line 159
    *(newp + i) = (float )(*(profa + i) + *(profb + i));
  }
  while_break: /* CIL Label */ ;
  }
#line 162
  profa += stride;
#line 163
  profb += stride;
#line 164
  newp += stride;
#line 166
  c = 1;
  {
#line 168
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 168
    if (! (*(path + c) != 3)) {
#line 168
      goto while_break___0;
    }
#line 175
    if (! *(path + c)) {
#line 177
      i = stride;
      {
#line 177
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 177
        tmp___0 = i;
#line 177
        i --;
#line 177
        if (! tmp___0) {
#line 177
          goto while_break___1;
        }
#line 178
        *(newp + i) = (float )(*(profa + i) + *(profb + i));
      }
      while_break___1: /* CIL Label */ ;
      }
#line 182
      profa += stride;
#line 183
      profb += stride;
    }
#line 186
    if (*(path + c) & 1) {
#line 189
      i = stride;
      {
#line 189
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 189
        tmp___1 = i;
#line 189
        i --;
#line 189
        if (! tmp___1) {
#line 189
          goto while_break___2;
        }
#line 190
        *(newp + i) = (float )*(profb + i);
      }
      while_break___2: /* CIL Label */ ;
      }
#line 192
      profb += stride;
#line 193
      if (! (*(path + c) & 20)) {
#line 194
        if (*(path + c) & 32) {
#line 195
          *(newp + 25) += (float )sipa;
#line 196
          i = (int )(tgpe * (float )sipa);
        } else {
#line 198
          *(newp + 24) += (float )sipa;
#line 199
          i = (int )(gpe * (float )sipa);
        }
#line 202
        j = dim;
        {
#line 202
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 202
          if (! (j < dim + 23)) {
#line 202
            goto while_break___3;
          }
#line 203
          *(newp + j) -= (float )i;
#line 202
          j ++;
        }
        while_break___3: /* CIL Label */ ;
        }
      } else {
#line 206
        if (*(path + c) & 16) {
#line 208
          if (*(path + c) & 32) {
#line 209
            *(newp + 25) += (float )sipa;
#line 210
            i = (int )(tgpe * (float )sipa);
#line 211
            *(newp + 23) += (float )sipa;
#line 212
            i = (int )((float )i + gpo * (float )sipa);
          } else {
#line 214
            *(newp + 23) += (float )sipa;
#line 215
            i = (int )(gpo * (float )sipa);
          }
#line 218
          j = dim;
          {
#line 218
          while (1) {
            while_continue___4: /* CIL Label */ ;
#line 218
            if (! (j < dim + 23)) {
#line 218
              goto while_break___4;
            }
#line 219
            *(newp + j) -= (float )i;
#line 218
            j ++;
          }
          while_break___4: /* CIL Label */ ;
          }
        }
#line 222
        if (*(path + c) & 4) {
#line 224
          if (*(path + c) & 32) {
#line 225
            *(newp + 25) += (float )sipa;
#line 226
            i = (int )(tgpe * (float )sipa);
#line 227
            *(newp + 23) += (float )sipa;
#line 228
            i = (int )((float )i + gpo * (float )sipa);
          } else {
#line 230
            *(newp + 23) += (float )sipa;
#line 231
            i = (int )(gpo * (float )sipa);
          }
#line 233
          j = dim;
          {
#line 233
          while (1) {
            while_continue___5: /* CIL Label */ ;
#line 233
            if (! (j < dim + 23)) {
#line 233
              goto while_break___5;
            }
#line 234
            *(newp + j) -= (float )i;
#line 233
            j ++;
          }
          while_break___5: /* CIL Label */ ;
          }
        }
      }
    }
#line 240
    if (*(path + c) & 2) {
#line 243
      i = stride;
      {
#line 243
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 243
        tmp___2 = i;
#line 243
        i --;
#line 243
        if (! tmp___2) {
#line 243
          goto while_break___6;
        }
#line 244
        *(newp + i) = (float )*(profa + i);
      }
      while_break___6: /* CIL Label */ ;
      }
#line 246
      profa += stride;
#line 247
      if (! (*(path + c) & 20)) {
#line 248
        if (*(path + c) & 32) {
#line 249
          *(newp + 25) += (float )sipb;
#line 250
          i = (int )(tgpe * (float )sipb);
        } else {
#line 252
          *(newp + 24) += (float )sipb;
#line 253
          i = (int )(gpe * (float )sipb);
        }
#line 255
        j = dim;
        {
#line 255
        while (1) {
          while_continue___7: /* CIL Label */ ;
#line 255
          if (! (j < dim + 23)) {
#line 255
            goto while_break___7;
          }
#line 256
          *(newp + j) -= (float )i;
#line 255
          j ++;
        }
        while_break___7: /* CIL Label */ ;
        }
      } else {
#line 259
        if (*(path + c) & 16) {
#line 261
          if (*(path + c) & 32) {
#line 262
            *(newp + 25) += (float )sipb;
#line 263
            i = (int )(tgpe * (float )sipb);
#line 264
            *(newp + 23) += (float )sipb;
#line 265
            i = (int )((float )i + gpo * (float )sipb);
          } else {
#line 267
            *(newp + 23) += (float )sipb;
#line 268
            i = (int )(gpo * (float )sipb);
          }
#line 270
          j = dim;
          {
#line 270
          while (1) {
            while_continue___8: /* CIL Label */ ;
#line 270
            if (! (j < dim + 23)) {
#line 270
              goto while_break___8;
            }
#line 271
            *(newp + j) -= (float )i;
#line 270
            j ++;
          }
          while_break___8: /* CIL Label */ ;
          }
        }
#line 274
        if (*(path + c) & 4) {
#line 276
          if (*(path + c) & 32) {
#line 277
            *(newp + 25) += (float )sipb;
#line 278
            i = (int )(tgpe * (float )sipb);
#line 279
            *(newp + 23) += (float )sipb;
#line 280
            i = (int )((float )i + gpo * (float )sipb);
          } else {
#line 282
            *(newp + 23) += (float )sipb;
#line 283
            i = (int )(gpo * (float )sipb);
          }
#line 286
          j = dim;
          {
#line 286
          while (1) {
            while_continue___9: /* CIL Label */ ;
#line 286
            if (! (j < dim + 23)) {
#line 286
              goto while_break___9;
            }
#line 287
            *(newp + j) -= (float )i;
#line 286
            j ++;
          }
          while_break___9: /* CIL Label */ ;
          }
        }
      }
    }
#line 292
    newp += stride;
#line 293
    c ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 295
  i = stride;
  {
#line 295
  while (1) {
    while_continue___10: /* CIL Label */ ;
#line 295
    tmp___3 = i;
#line 295
    i --;
#line 295
    if (! tmp___3) {
#line 295
      goto while_break___10;
    }
#line 296
    *(newp + i) = (float )(*(profa + i) + *(profb + i));
  }
  while_break___10: /* CIL Label */ ;
  }
#line 298
  newp -= (*(path + 0) + 1) * stride;
#line 299
  return (newp);
}
}
#line 304 "/home/june/repo/benchmarks/collector/temp/kalign-2.03+20110620/kalign2_feature.c"
float *make_unified_profile(float *prof , struct alignment *aln , int num , float **subm ,
                            struct feature_matrix *fm ) 
{ 
  struct feature *f ;
  int i ;
  int j ;
  int c ;
  int *seq ;
  int len ;
  void *tmp ;
  int tmp___0 ;

  {
  {
#line 306
  f = *(aln->ft + num);
#line 308
  seq = *(aln->s + num);
#line 312
  len = (int )*(aln->sl + num);
#line 313
  tmp = malloc((sizeof(float ) * (unsigned long )(len + 2)) * (unsigned long )stride);
#line 313
  prof = (float *)tmp;
#line 314
  prof += stride * (len + 1);
#line 315
  i = 0;
  }
  {
#line 315
  while (1) {
    while_continue: /* CIL Label */ ;
#line 315
    if (! (i < stride)) {
#line 315
      goto while_break;
    }
#line 316
    *(prof + i) = (float )0;
#line 315
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 318
  *(prof + (23 + dim)) = - gpo;
#line 319
  *(prof + (24 + dim)) = - gpe;
#line 320
  *(prof + (25 + dim)) = - tgpe;
#line 323
  i = len;
  {
#line 324
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 324
    tmp___0 = i;
#line 324
    i --;
#line 324
    if (! tmp___0) {
#line 324
      goto while_break___0;
    }
#line 325
    prof -= stride;
#line 327
    j = 0;
    {
#line 327
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 327
      if (! (j < stride)) {
#line 327
        goto while_break___1;
      }
#line 328
      *(prof + j) = (float )0;
#line 327
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 330
    c = *(seq + i);
#line 332
    *(prof + c) += (float )1;
#line 334
    prof += dim;
#line 336
    j = 0;
    {
#line 336
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 336
      if (! (j < 23)) {
#line 336
        goto while_break___2;
      }
#line 337
      *(prof + j) = *(*(subm + c) + j);
#line 336
      j ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 339
    *(prof + 23) = - gpo;
#line 340
    *(prof + 24) = - gpe;
#line 341
    *(prof + 25) = - tgpe;
#line 342
    prof -= dim;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 344
  prof -= stride;
#line 345
  i = 0;
  {
#line 345
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 345
    if (! (i < stride)) {
#line 345
      goto while_break___3;
    }
#line 346
    *(prof + i) = (float )0;
#line 345
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 348
  *(prof + (23 + dim)) = - gpo;
#line 349
  *(prof + (24 + dim)) = - gpe;
#line 350
  *(prof + (25 + dim)) = - tgpe;
  {
#line 352
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 352
    if (! f) {
#line 352
      goto while_break___4;
    }
#line 353
    if (f->color != -1) {
#line 354
      if (f->start < len) {
#line 354
        if (f->end < len) {
#line 355
          i = f->start;
          {
#line 355
          while (1) {
            while_continue___5: /* CIL Label */ ;
#line 355
            if (! (i <= f->end)) {
#line 355
              goto while_break___5;
            }
#line 356
            *(prof + ((i * stride + 26) + f->color)) += (float )1;
#line 359
            j = 0;
            {
#line 359
            while (1) {
              while_continue___6: /* CIL Label */ ;
#line 359
              if (! (j < fm->mdim)) {
#line 359
                goto while_break___6;
              }
#line 360
              *(prof + (((i * stride + dim) + 26) + j)) += *(*(fm->m + f->color) + j);
#line 359
              j ++;
            }
            while_break___6: /* CIL Label */ ;
            }
#line 355
            i ++;
          }
          while_break___5: /* CIL Label */ ;
          }
        }
      }
    }
#line 365
    f = f->next;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 369
  return (prof);
}
}
#line 373 "/home/june/repo/benchmarks/collector/temp/kalign-2.03+20110620/kalign2_feature.c"
void set_unified_gap_penalties(float *prof , int len , int nsip ) 
{ 
  int i ;
  int tmp ;

  {
#line 377
  prof += stride * (len + 1);
#line 378
  *(prof + gpo_pos) = *(prof + (dim + 23)) * (float )nsip;
#line 379
  *(prof + gpe_pos) = *(prof + (dim + 24)) * (float )nsip;
#line 380
  *(prof + tgpe_pos) = *(prof + (dim + 25)) * (float )nsip;
#line 381
  i = len + 1;
  {
#line 382
  while (1) {
    while_continue: /* CIL Label */ ;
#line 382
    tmp = i;
#line 382
    i --;
#line 382
    if (! tmp) {
#line 382
      goto while_break;
    }
#line 383
    prof -= stride;
#line 384
    *(prof + gpo_pos) = *(prof + (dim + 23)) * (float )nsip;
#line 385
    *(prof + gpe_pos) = *(prof + (dim + 24)) * (float )nsip;
#line 386
    *(prof + tgpe_pos) = *(prof + (dim + 25)) * (float )nsip;
  }
  while_break: /* CIL Label */ ;
  }
#line 388
  return;
}
}
#line 392 "/home/june/repo/benchmarks/collector/temp/kalign-2.03+20110620/kalign2_feature.c"
int *feature_hirsch_pp_dyn(float const   *prof1 , float const   *prof2 , struct hirsch_mem *hm ,
                           int *hirsch_path ) 
{ 
  int mid ;
  float input_states[6] ;
  int old_cor[5] ;

  {
#line 394
  mid = (hm->enda - hm->starta) / 2 + hm->starta;
#line 395
  input_states[0] = (hm->f + 0)->a;
#line 395
  input_states[1] = (hm->f + 0)->ga;
#line 395
  input_states[2] = (hm->f + 0)->gb;
#line 395
  input_states[3] = (hm->b + 0)->a;
#line 395
  input_states[4] = (hm->b + 0)->ga;
#line 395
  input_states[5] = (hm->b + 0)->gb;
#line 396
  old_cor[0] = hm->starta;
#line 396
  old_cor[1] = hm->enda;
#line 396
  old_cor[2] = hm->startb;
#line 396
  old_cor[3] = hm->endb;
#line 396
  old_cor[4] = mid;
#line 402
  if (hm->starta >= hm->enda) {
#line 403
    return (hirsch_path);
  }
#line 405
  if (hm->startb >= hm->endb) {
#line 406
    return (hirsch_path);
  }
  {
#line 409
  hm->enda = mid;
#line 410
  hm->f = feature_foward_hirsch_pp_dyn(prof1, prof2, hm);
#line 417
  hm->starta = mid;
#line 418
  hm->enda = old_cor[1];
#line 419
  hm->b = feature_backward_hirsch_pp_dyn(prof1, prof2, hm);
#line 426
  hirsch_path = feature_hirsch_align_two_pp_vector(prof1, prof2, hm, hirsch_path,
                                                   input_states, old_cor);
  }
#line 427
  return (hirsch_path);
}
}
#line 432 "/home/june/repo/benchmarks/collector/temp/kalign-2.03+20110620/kalign2_feature.c"
int *feature_hirsch_align_two_pp_vector(float const   *prof1 , float const   *prof2 ,
                                        struct hirsch_mem *hm , int *hirsch_path ,
                                        float *input_states , int *old_cor ) 
{ 
  struct states *f ;
  struct states *b ;
  int i ;
  int j ;
  int c ;
  int transition ;
  float max ;
  float middle ;
  float sub ;
  int tmp ;
  int tmp___0 ;

  {
#line 434
  f = hm->f;
#line 435
  b = hm->b;
#line 437
  transition = -1;
#line 450
  max = - 3.40282346638528859812e+38F;
#line 452
  middle = (float )((*(old_cor + 3) - *(old_cor + 2)) / 2 + *(old_cor + 2));
#line 453
  sub = (float )0.0;
#line 456
  prof1 += stride * (*(old_cor + 4) + 1);
#line 459
  prof2 += stride * *(old_cor + 2);
#line 460
  i = *(old_cor + 2);
#line 461
  c = -1;
#line 463
  i = *(old_cor + 2);
  {
#line 463
  while (1) {
    while_continue: /* CIL Label */ ;
#line 463
    if (! (i < *(old_cor + 3))) {
#line 463
      goto while_break;
    }
    {
#line 464
    tmp = abs((int )(middle - (float )i));
#line 464
    sub = (float )tmp;
#line 465
    sub /= (float )1000;
#line 466
    prof2 += stride;
    }
#line 468
    if (((f + i)->a + (b + i)->a) - sub > max) {
#line 469
      max = ((f + i)->a + (b + i)->a) - sub;
#line 471
      transition = 1;
#line 472
      c = i;
    }
#line 474
    if ((((f + i)->a + (b + i)->ga) + (float )*(prof2 + gpo_pos)) - sub > max) {
#line 475
      max = (((f + i)->a + (b + i)->ga) + (float )*(prof2 + gpo_pos)) - sub;
#line 477
      transition = 2;
#line 478
      c = i;
    }
#line 480
    if ((((f + i)->a + (b + i)->gb) + (float )*(prof1 + gpo_pos)) - sub > max) {
#line 481
      max = (((f + i)->a + (b + i)->gb) + (float )*(prof1 + gpo_pos)) - sub;
#line 483
      transition = 3;
#line 484
      c = i;
    }
#line 486
    if ((((f + i)->ga + (b + i)->a) + (float )*(prof2 + gpo_pos)) - sub > max) {
#line 487
      max = (((f + i)->ga + (b + i)->a) + (float )*(prof2 + gpo_pos)) - sub;
#line 489
      transition = 5;
#line 490
      c = i;
    }
#line 494
    if (hm->startb == 0) {
#line 495
      if ((((f + i)->gb + (b + i)->gb) + (float )*(prof1 + tgpe_pos)) - sub > max) {
#line 496
        max = (((f + i)->gb + (b + i)->gb) + (float )*(prof1 + tgpe_pos)) - sub;
#line 498
        transition = 6;
#line 499
        c = i;
      }
    } else
#line 502
    if ((((f + i)->gb + (b + i)->gb) + (float )*(prof1 + gpe_pos)) - sub > max) {
#line 503
      max = (((f + i)->gb + (b + i)->gb) + (float )*(prof1 + gpe_pos)) - sub;
#line 505
      transition = 6;
#line 506
      c = i;
    }
#line 509
    if ((((f + i)->gb + (b + i)->a) + (float )*(prof1 + gpo_pos)) - sub > max) {
#line 510
      max = (((f + i)->gb + (b + i)->a) + (float )*(prof1 + gpo_pos)) - sub;
#line 512
      transition = 7;
#line 513
      c = i;
    }
#line 463
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 517
  i = *(old_cor + 3);
#line 518
  tmp___0 = abs((int )(middle - (float )i));
#line 518
  sub = (float )tmp___0;
#line 519
  sub /= (float )1000;
  }
#line 520
  if ((((f + i)->a + (b + i)->gb) + (float )*(prof1 + gpo_pos)) - sub > max) {
#line 521
    max = (((f + i)->a + (b + i)->gb) + (float )*(prof1 + gpo_pos)) - sub;
#line 523
    transition = 3;
#line 524
    c = i;
  }
#line 526
  if (hm->endb == hm->len_b) {
#line 527
    if ((((f + i)->gb + (b + i)->gb) + (float )*(prof1 + tgpe_pos)) - sub > max) {
#line 528
      max = (((f + i)->gb + (b + i)->gb) + (float )*(prof1 + tgpe_pos)) - sub;
#line 530
      transition = 6;
#line 531
      c = i;
    }
  } else
#line 534
  if ((((f + i)->gb + (b + i)->gb) + (float )*(prof1 + gpe_pos)) - sub > max) {
#line 535
    max = (((f + i)->gb + (b + i)->gb) + (float )*(prof1 + gpe_pos)) - sub;
#line 537
    transition = 6;
#line 538
    c = i;
  }
#line 544
  prof1 -= stride * (*(old_cor + 4) + 1);
#line 546
  prof2 -= *(old_cor + 3) * stride;
#line 553
  j = *(hirsch_path + 0);
  {
#line 555
  if (transition == 1) {
#line 555
    goto case_1;
  }
#line 594
  if (transition == 2) {
#line 594
    goto case_2;
  }
#line 630
  if (transition == 3) {
#line 630
    goto case_3;
  }
#line 665
  if (transition == 5) {
#line 665
    goto case_5;
  }
#line 700
  if (transition == 6) {
#line 700
    goto case_6;
  }
#line 732
  if (transition == 7) {
#line 732
    goto case_7;
  }
#line 554
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 557
  *(hirsch_path + *(old_cor + 4)) = c;
#line 558
  *(hirsch_path + (*(old_cor + 4) + 1)) = c + 1;
#line 563
  (hm->f + 0)->a = *(input_states + 0);
#line 564
  (hm->f + 0)->ga = *(input_states + 1);
#line 565
  (hm->f + 0)->gb = *(input_states + 2);
#line 566
  (hm->b + 0)->a = (float )0.0;
#line 567
  (hm->b + 0)->ga = - 3.40282346638528859812e+38F;
#line 568
  (hm->b + 0)->gb = - 3.40282346638528859812e+38F;
#line 571
  hm->starta = *(old_cor + 0);
#line 572
  hm->enda = *(old_cor + 4) - 1;
#line 574
  hm->startb = *(old_cor + 2);
#line 575
  hm->endb = c - 1;
#line 577
  hirsch_path = feature_hirsch_pp_dyn(prof1, prof2, hm, hirsch_path);
#line 580
  hm->starta = *(old_cor + 4) + 1;
#line 581
  hm->enda = *(old_cor + 1);
#line 582
  hm->startb = c + 1;
#line 583
  hm->endb = *(old_cor + 3);
#line 584
  (hm->f + 0)->a = (float )0.0;
#line 585
  (hm->f + 0)->ga = - 3.40282346638528859812e+38F;
#line 586
  (hm->f + 0)->gb = - 3.40282346638528859812e+38F;
#line 587
  (hm->b + 0)->a = *(input_states + 3);
#line 588
  (hm->b + 0)->ga = *(input_states + 4);
#line 589
  (hm->b + 0)->gb = *(input_states + 5);
#line 592
  hirsch_path = feature_hirsch_pp_dyn(prof1, prof2, hm, hirsch_path);
  }
#line 593
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 596
  *(hirsch_path + *(old_cor + 4)) = c;
#line 599
  (hm->f + 0)->a = *(input_states + 0);
#line 600
  (hm->f + 0)->ga = *(input_states + 1);
#line 601
  (hm->f + 0)->gb = *(input_states + 2);
#line 602
  (hm->b + 0)->a = (float )0.0;
#line 603
  (hm->b + 0)->ga = - 3.40282346638528859812e+38F;
#line 604
  (hm->b + 0)->gb = - 3.40282346638528859812e+38F;
#line 607
  hm->starta = *(old_cor + 0);
#line 608
  hm->enda = *(old_cor + 4) - 1;
#line 610
  hm->startb = *(old_cor + 2);
#line 611
  hm->endb = c - 1;
#line 613
  hirsch_path = feature_hirsch_pp_dyn(prof1, prof2, hm, hirsch_path);
#line 616
  hm->starta = *(old_cor + 4);
#line 617
  hm->enda = *(old_cor + 1);
#line 618
  hm->startb = c + 1;
#line 619
  hm->endb = *(old_cor + 3);
#line 620
  (hm->f + 0)->a = - 3.40282346638528859812e+38F;
#line 621
  (hm->f + 0)->ga = (float )0.0;
#line 622
  (hm->f + 0)->gb = - 3.40282346638528859812e+38F;
#line 623
  (hm->b + 0)->a = *(input_states + 3);
#line 624
  (hm->b + 0)->ga = *(input_states + 4);
#line 625
  (hm->b + 0)->gb = *(input_states + 5);
#line 628
  hirsch_path = feature_hirsch_pp_dyn(prof1, prof2, hm, hirsch_path);
  }
#line 629
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 632
  *(hirsch_path + *(old_cor + 4)) = c;
#line 635
  (hm->f + 0)->a = *(input_states + 0);
#line 636
  (hm->f + 0)->ga = *(input_states + 1);
#line 637
  (hm->f + 0)->gb = *(input_states + 2);
#line 638
  (hm->b + 0)->a = (float )0.0;
#line 639
  (hm->b + 0)->ga = - 3.40282346638528859812e+38F;
#line 640
  (hm->b + 0)->gb = - 3.40282346638528859812e+38F;
#line 642
  hm->starta = *(old_cor + 0);
#line 643
  hm->enda = *(old_cor + 4) - 1;
#line 645
  hm->startb = *(old_cor + 2);
#line 646
  hm->endb = c - 1;
#line 648
  hirsch_path = feature_hirsch_pp_dyn(prof1, prof2, hm, hirsch_path);
#line 651
  hm->starta = *(old_cor + 4) + 1;
#line 652
  hm->enda = *(old_cor + 1);
#line 653
  hm->startb = c;
#line 654
  hm->endb = *(old_cor + 3);
#line 655
  (hm->f + 0)->a = - 3.40282346638528859812e+38F;
#line 656
  (hm->f + 0)->ga = - 3.40282346638528859812e+38F;
#line 657
  (hm->f + 0)->gb = (float )0.0;
#line 658
  (hm->b + 0)->a = *(input_states + 3);
#line 659
  (hm->b + 0)->ga = *(input_states + 4);
#line 660
  (hm->b + 0)->gb = *(input_states + 5);
#line 663
  hirsch_path = feature_hirsch_pp_dyn(prof1, prof2, hm, hirsch_path);
  }
#line 664
  goto switch_break;
  case_5: /* CIL Label */ 
  {
#line 666
  *(hirsch_path + (*(old_cor + 4) + 1)) = c + 1;
#line 670
  (hm->f + 0)->a = *(input_states + 0);
#line 671
  (hm->f + 0)->ga = *(input_states + 1);
#line 672
  (hm->f + 0)->gb = *(input_states + 2);
#line 673
  (hm->b + 0)->a = - 3.40282346638528859812e+38F;
#line 674
  (hm->b + 0)->ga = (float )0.0;
#line 675
  (hm->b + 0)->gb = - 3.40282346638528859812e+38F;
#line 677
  hm->starta = *(old_cor + 0);
#line 678
  hm->enda = *(old_cor + 4);
#line 680
  hm->startb = *(old_cor + 2);
#line 681
  hm->endb = c - 1;
#line 683
  hirsch_path = feature_hirsch_pp_dyn(prof1, prof2, hm, hirsch_path);
#line 686
  hm->starta = *(old_cor + 4) + 1;
#line 687
  hm->enda = *(old_cor + 1);
#line 688
  hm->startb = c + 1;
#line 689
  hm->endb = *(old_cor + 3);
#line 690
  (hm->f + 0)->a = (float )0.0;
#line 691
  (hm->f + 0)->ga = - 3.40282346638528859812e+38F;
#line 692
  (hm->f + 0)->gb = - 3.40282346638528859812e+38F;
#line 693
  (hm->b + 0)->a = *(input_states + 3);
#line 694
  (hm->b + 0)->ga = *(input_states + 4);
#line 695
  (hm->b + 0)->gb = *(input_states + 5);
#line 698
  hirsch_path = feature_hirsch_pp_dyn(prof1, prof2, hm, hirsch_path);
  }
#line 699
  goto switch_break;
  case_6: /* CIL Label */ 
  {
#line 703
  (hm->f + 0)->a = *(input_states + 0);
#line 704
  (hm->f + 0)->ga = *(input_states + 1);
#line 705
  (hm->f + 0)->gb = *(input_states + 2);
#line 706
  (hm->b + 0)->a = - 3.40282346638528859812e+38F;
#line 707
  (hm->b + 0)->ga = - 3.40282346638528859812e+38F;
#line 708
  (hm->b + 0)->gb = (float )0.0;
#line 710
  hm->starta = *(old_cor + 0);
#line 711
  hm->enda = *(old_cor + 4) - 1;
#line 712
  hm->startb = *(old_cor + 2);
#line 713
  hm->endb = c;
#line 715
  hirsch_path = feature_hirsch_pp_dyn(prof1, prof2, hm, hirsch_path);
#line 718
  hm->starta = *(old_cor + 4) + 1;
#line 719
  hm->enda = *(old_cor + 1);
#line 720
  hm->startb = c;
#line 721
  hm->endb = *(old_cor + 3);
#line 722
  (hm->f + 0)->a = - 3.40282346638528859812e+38F;
#line 723
  (hm->f + 0)->ga = - 3.40282346638528859812e+38F;
#line 724
  (hm->f + 0)->gb = (float )0.0;
#line 725
  (hm->b + 0)->a = *(input_states + 3);
#line 726
  (hm->b + 0)->ga = *(input_states + 4);
#line 727
  (hm->b + 0)->gb = *(input_states + 5);
#line 730
  hirsch_path = feature_hirsch_pp_dyn(prof1, prof2, hm, hirsch_path);
  }
#line 731
  goto switch_break;
  case_7: /* CIL Label */ 
  {
#line 734
  *(hirsch_path + (*(old_cor + 4) + 1)) = c + 1;
#line 737
  (hm->f + 0)->a = *(input_states + 0);
#line 738
  (hm->f + 0)->ga = *(input_states + 1);
#line 739
  (hm->f + 0)->gb = *(input_states + 2);
#line 740
  (hm->b + 0)->a = - 3.40282346638528859812e+38F;
#line 741
  (hm->b + 0)->ga = - 3.40282346638528859812e+38F;
#line 742
  (hm->b + 0)->gb = (float )0.0;
#line 744
  hm->starta = *(old_cor + 0);
#line 745
  hm->enda = *(old_cor + 4) - 1;
#line 746
  hm->startb = *(old_cor + 2);
#line 747
  hm->endb = c;
#line 749
  hirsch_path = feature_hirsch_pp_dyn(prof1, prof2, hm, hirsch_path);
#line 752
  hm->starta = *(old_cor + 4) + 1;
#line 753
  hm->enda = *(old_cor + 1);
#line 754
  hm->startb = c + 1;
#line 755
  hm->endb = *(old_cor + 3);
#line 756
  (hm->f + 0)->a = (float )0.0;
#line 757
  (hm->f + 0)->ga = - 3.40282346638528859812e+38F;
#line 758
  (hm->f + 0)->gb = - 3.40282346638528859812e+38F;
#line 759
  (hm->b + 0)->a = *(input_states + 3);
#line 760
  (hm->b + 0)->ga = *(input_states + 4);
#line 761
  (hm->b + 0)->gb = *(input_states + 5);
#line 764
  hirsch_path = feature_hirsch_pp_dyn(prof1, prof2, hm, hirsch_path);
  }
#line 765
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 768
  return (hirsch_path);
}
}
#line 771 "/home/june/repo/benchmarks/collector/temp/kalign-2.03+20110620/kalign2_feature.c"
struct states *feature_foward_hirsch_pp_dyn(float const   *prof1 , float const   *prof2 ,
                                            struct hirsch_mem *hm ) 
{ 
  unsigned int *freq ;
  unsigned long __lengthoffreq ;
  void *tmp ;
  struct states *s ;
  register float pa ;
  register float pga ;
  register float pgb ;
  register float ca ;
  register int i ;
  register int j ;
  register int c ;

  {
  {
#line 773
  __lengthoffreq = (unsigned long )dim;
#line 773
  tmp = __builtin_alloca(sizeof(*freq) * __lengthoffreq);
#line 773
  freq = (unsigned int *)tmp;
#line 774
  s = hm->f;
#line 780
  pa = (float )0;
#line 781
  pga = (float )0;
#line 782
  pgb = (float )0;
#line 783
  ca = (float )0;
#line 784
  i = 0;
#line 785
  j = 0;
#line 786
  c = 0;
#line 790
  prof1 += hm->starta * stride;
#line 791
  prof2 += hm->startb * stride;
#line 792
  (s + hm->startb)->a = (s + 0)->a;
#line 793
  (s + hm->startb)->ga = (s + 0)->ga;
#line 794
  (s + hm->startb)->gb = (s + 0)->gb;
  }
#line 795
  if (hm->startb == 0) {
#line 796
    j = hm->startb + 1;
    {
#line 796
    while (1) {
      while_continue: /* CIL Label */ ;
#line 796
      if (! (j < hm->endb)) {
#line 796
        goto while_break;
      }
#line 797
      prof2 += stride;
#line 798
      (s + j)->a = - 3.40282346638528859812e+38F;
#line 804
      if ((s + (j - 1))->ga > (s + (j - 1))->a) {
#line 805
        (s + j)->ga = (s + (j - 1))->ga + (float )*(prof2 + tgpe_pos);
      } else {
#line 807
        (s + j)->ga = (s + (j - 1))->a + (float )*(prof2 + tgpe_pos);
      }
#line 811
      (s + j)->gb = - 3.40282346638528859812e+38F;
#line 796
      j ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 813
    prof2 += stride;
  } else {
#line 816
    j = hm->startb + 1;
    {
#line 816
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 816
      if (! (j < hm->endb)) {
#line 816
        goto while_break___0;
      }
#line 817
      prof2 += stride;
#line 818
      (s + j)->a = - 3.40282346638528859812e+38F;
#line 825
      if ((s + (j - 1))->ga + (float )*(prof2 + gpe_pos) > (s + (j - 1))->a + (float )*(prof2 + gpo_pos)) {
#line 826
        (s + j)->ga = (s + (j - 1))->ga + (float )*(prof2 + gpe_pos);
      } else {
#line 828
        (s + j)->ga = (s + (j - 1))->a + (float )*(prof2 + gpo_pos);
      }
#line 831
      (s + j)->gb = - 3.40282346638528859812e+38F;
#line 816
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 834
    prof2 += stride;
  }
#line 837
  prof2 -= (hm->endb - hm->startb) * stride;
#line 839
  (s + hm->endb)->a = - 3.40282346638528859812e+38F;
#line 840
  (s + hm->endb)->ga = - 3.40282346638528859812e+38F;
#line 841
  (s + hm->endb)->gb = - 3.40282346638528859812e+38F;
#line 844
  i = hm->starta;
  {
#line 844
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 844
    if (! (i < hm->enda)) {
#line 844
      goto while_break___1;
    }
#line 845
    prof1 += stride;
#line 846
    c = 1;
#line 847
    j = 0;
    {
#line 847
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 847
      if (! (j < dim)) {
#line 847
        goto while_break___2;
      }
#line 848
      if (*(prof1 + j)) {
#line 849
        *(freq + c) = (unsigned int )j;
#line 850
        c ++;
      }
#line 847
      j ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 853
    *(freq + 0) = (unsigned int )c;
#line 855
    pa = (s + hm->startb)->a;
#line 856
    pga = (s + hm->startb)->ga;
#line 857
    pgb = (s + hm->startb)->gb;
#line 858
    if (hm->startb == 0) {
#line 859
      (s + hm->startb)->a = - 3.40282346638528859812e+38F;
#line 860
      (s + hm->startb)->ga = - 3.40282346638528859812e+38F;
#line 866
      if (pgb > pa) {
#line 867
        (s + hm->startb)->gb = pgb + (float )*(prof1 + tgpe_pos);
      } else {
#line 869
        (s + hm->startb)->gb = pa + (float )*(prof1 + tgpe_pos);
      }
    } else {
#line 873
      (s + hm->startb)->a = - 3.40282346638528859812e+38F;
#line 874
      (s + hm->startb)->ga = - 3.40282346638528859812e+38F;
#line 880
      if (pgb + (float )*(prof1 + gpe_pos) > pa + (float )*(prof1 + gpo_pos)) {
#line 881
        (s + hm->startb)->gb = pgb + (float )*(prof1 + gpe_pos);
      } else {
#line 883
        (s + hm->startb)->gb = pa + (float )*(prof1 + gpo_pos);
      }
    }
#line 887
    j = hm->startb + 1;
    {
#line 887
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 887
      if (! (j <= hm->endb)) {
#line 887
        goto while_break___3;
      }
#line 888
      prof2 += stride;
#line 889
      ca = (s + j)->a;
#line 898
      pga += (float )*(prof2 + (gpo_pos - stride));
#line 898
      if (pga > pa) {
#line 899
        pa = pga;
      }
#line 902
      pgb += (float )*(prof1 + (gpo_pos - stride));
#line 902
      if (pgb > pa) {
#line 903
        pa = pgb;
      }
#line 906
      prof2 += dim;
#line 907
      c = 1;
      {
#line 907
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 907
        if (! ((unsigned int )c < *(freq + 0))) {
#line 907
          goto while_break___4;
        }
#line 908
        pa += (float )(*(prof1 + *(freq + c)) * *(prof2 + *(freq + c)));
#line 907
        c ++;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 910
      prof2 -= dim;
#line 912
      (s + j)->a = pa;
#line 914
      pga = (s + j)->ga;
#line 920
      if ((s + (j - 1))->ga + (float )*(prof2 + gpe_pos) > (s + (j - 1))->a + (float )*(prof2 + gpo_pos)) {
#line 921
        (s + j)->ga = (s + (j - 1))->ga + (float )*(prof2 + gpe_pos);
      } else {
#line 923
        (s + j)->ga = (s + (j - 1))->a + (float )*(prof2 + gpo_pos);
      }
#line 927
      pgb = (s + j)->gb;
#line 933
      if (pgb + (float )*(prof1 + gpe_pos) > ca + (float )*(prof1 + gpo_pos)) {
#line 934
        (s + j)->gb = pgb + (float )*(prof1 + gpe_pos);
      } else {
#line 936
        (s + j)->gb = ca + (float )*(prof1 + gpo_pos);
      }
#line 939
      pa = ca;
#line 887
      j ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 941
    prof2 -= (hm->endb - hm->startb) * stride;
#line 844
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 944
  prof1 -= stride * hm->enda;
#line 945
  return (s);
}
}
#line 948 "/home/june/repo/benchmarks/collector/temp/kalign-2.03+20110620/kalign2_feature.c"
struct states *feature_backward_hirsch_pp_dyn(float const   *prof1 , float const   *prof2 ,
                                              struct hirsch_mem *hm ) 
{ 
  unsigned int *freq ;
  unsigned long __lengthoffreq ;
  void *tmp ;
  struct states *s ;
  register float pa ;
  register float pga ;
  register float pgb ;
  register float ca ;
  register int i ;
  register int j ;
  register int c ;
  int tmp___0 ;

  {
  {
#line 950
  __lengthoffreq = (unsigned long )dim;
#line 950
  tmp = __builtin_alloca(sizeof(*freq) * __lengthoffreq);
#line 950
  freq = (unsigned int *)tmp;
#line 951
  s = hm->b;
#line 957
  pa = (float )0;
#line 958
  pga = (float )0;
#line 959
  pgb = (float )0;
#line 960
  ca = (float )0;
#line 961
  i = 0;
#line 962
  j = 0;
#line 963
  c = 0;
#line 965
  prof1 += (hm->enda + 1) * stride;
#line 966
  prof2 += (hm->endb + 1) * stride;
#line 967
  (s + hm->endb)->a = (s + 0)->a;
#line 968
  (s + hm->endb)->ga = (s + 0)->ga;
#line 969
  (s + hm->endb)->gb = (s + 0)->gb;
  }
#line 974
  if (hm->endb == hm->len_b) {
#line 976
    j = hm->endb - 1;
    {
#line 976
    while (1) {
      while_continue: /* CIL Label */ ;
#line 976
      if (! (j > hm->startb)) {
#line 976
        goto while_break;
      }
#line 977
      prof2 -= stride;
#line 978
      (s + j)->a = - 3.40282346638528859812e+38F;
#line 984
      if ((s + (j + 1))->ga > (s + (j + 1))->a) {
#line 985
        (s + j)->ga = (s + (j + 1))->ga + (float )*(prof2 + tgpe_pos);
      } else {
#line 987
        (s + j)->ga = (s + (j + 1))->a + (float )*(prof2 + tgpe_pos);
      }
#line 990
      (s + j)->gb = - 3.40282346638528859812e+38F;
#line 976
      j --;
    }
    while_break: /* CIL Label */ ;
    }
#line 992
    prof2 -= stride;
  } else {
#line 994
    j = hm->endb - 1;
    {
#line 994
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 994
      if (! (j > hm->startb)) {
#line 994
        goto while_break___0;
      }
#line 995
      prof2 -= stride;
#line 996
      (s + j)->a = - 3.40282346638528859812e+38F;
#line 1002
      if ((s + (j + 1))->ga + (float )*(prof2 + gpe_pos) > (s + (j + 1))->a + (float )*(prof2 + gpo_pos)) {
#line 1003
        (s + j)->ga = (s + (j + 1))->ga + (float )*(prof2 + gpe_pos);
      } else {
#line 1005
        (s + j)->ga = (s + (j + 1))->a + (float )*(prof2 + gpo_pos);
      }
#line 1007
      (s + j)->gb = - 3.40282346638528859812e+38F;
#line 994
      j --;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1010
    prof2 -= stride;
  }
#line 1013
  (s + hm->startb)->a = - 3.40282346638528859812e+38F;
#line 1014
  (s + hm->startb)->ga = - 3.40282346638528859812e+38F;
#line 1015
  (s + hm->startb)->gb = - 3.40282346638528859812e+38F;
#line 1018
  i = hm->enda - hm->starta;
  {
#line 1019
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1019
    tmp___0 = i;
#line 1019
    i --;
#line 1019
    if (! tmp___0) {
#line 1019
      goto while_break___1;
    }
#line 1020
    prof1 -= stride;
#line 1022
    c = 1;
#line 1023
    j = 0;
    {
#line 1023
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1023
      if (! (j < dim)) {
#line 1023
        goto while_break___2;
      }
#line 1024
      if (*(prof1 + j)) {
#line 1025
        *(freq + c) = (unsigned int )j;
#line 1026
        c ++;
      }
#line 1023
      j ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 1029
    *(freq + 0) = (unsigned int )c;
#line 1031
    pa = (s + hm->endb)->a;
#line 1032
    pga = (s + hm->endb)->ga;
#line 1033
    pgb = (s + hm->endb)->gb;
#line 1034
    (s + hm->endb)->a = - 3.40282346638528859812e+38F;
#line 1035
    (s + hm->endb)->ga = - 3.40282346638528859812e+38F;
#line 1037
    if (hm->endb == hm->len_b) {
#line 1042
      if (pgb > pa) {
#line 1043
        (s + hm->endb)->gb = pgb + (float )*(prof1 + tgpe_pos);
      } else {
#line 1045
        (s + hm->endb)->gb = pa + (float )*(prof1 + tgpe_pos);
      }
    } else
#line 1052
    if (pgb + (float )*(prof1 + gpe_pos) > pa + (float )*(prof1 + gpo_pos)) {
#line 1053
      (s + hm->endb)->gb = pgb + (float )*(prof1 + gpe_pos);
    } else {
#line 1055
      (s + hm->endb)->gb = pa + (float )*(prof1 + gpo_pos);
    }
#line 1059
    prof2 += (hm->endb - hm->startb) * stride;
#line 1061
    j = hm->endb - 1;
    {
#line 1061
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 1061
      if (! (j >= hm->startb)) {
#line 1061
        goto while_break___3;
      }
#line 1062
      prof2 -= stride;
#line 1063
      ca = (s + j)->a;
#line 1064
      pga += (float )*(prof2 + (stride + gpo_pos));
#line 1064
      if (pga > pa) {
#line 1065
        pa = pga;
      }
#line 1067
      pgb += (float )*(prof1 + (stride + gpo_pos));
#line 1067
      if (pgb > pa) {
#line 1068
        pa = pgb;
      }
#line 1071
      prof2 += dim;
#line 1072
      c = 1;
      {
#line 1072
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 1072
        if (! ((unsigned int )c < *(freq + 0))) {
#line 1072
          goto while_break___4;
        }
#line 1073
        pa += (float )(*(prof1 + *(freq + c)) * *(prof2 + *(freq + c)));
#line 1072
        c ++;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 1075
      prof2 -= dim;
#line 1077
      (s + j)->a = pa;
#line 1079
      pga = (s + j)->ga;
#line 1085
      if ((s + (j + 1))->ga + (float )*(prof2 + gpe_pos) > (s + (j + 1))->a + (float )*(prof2 + gpo_pos)) {
#line 1086
        (s + j)->ga = (s + (j + 1))->ga + (float )*(prof2 + gpe_pos);
      } else {
#line 1088
        (s + j)->ga = (s + (j + 1))->a + (float )*(prof2 + gpo_pos);
      }
#line 1091
      pgb = (s + j)->gb;
#line 1097
      if (pgb + (float )*(prof1 + gpe_pos) > ca + (float )*(prof1 + gpo_pos)) {
#line 1098
        (s + j)->gb = pgb + (float )*(prof1 + gpe_pos);
      } else {
#line 1100
        (s + j)->gb = ca + (float )*(prof1 + gpo_pos);
      }
#line 1102
      pa = ca;
#line 1061
      j --;
    }
    while_break___3: /* CIL Label */ ;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1105
  return (s);
}
}
#line 1111 "/home/june/repo/benchmarks/collector/temp/kalign-2.03+20110620/kalign2_feature.c"
struct feature_matrix *get_feature_matrix(struct feature_matrix *fm , struct alignment *aln ,
                                          struct parameters *param ) 
{ 
  struct utype_ufeat *utf ;
  struct feature *n ;
  struct feature *p ;
  int i ;
  int j ;
  char *requested_feature ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  void *tmp___9 ;
  void *tmp___10 ;
  void *tmp___11 ;
  void *tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;

  {
  {
#line 1113
  utf = (struct utype_ufeat *)0;
#line 1114
  n = (struct feature *)0;
#line 1115
  p = (struct feature *)0;
#line 1117
  i = 0;
#line 1118
  j = 0;
#line 1119
  requested_feature = param->feature_type;
#line 1122
  utf = get_unique_features(aln, utf);
#line 1124
  tmp = malloc(sizeof(struct feature_matrix ));
#line 1124
  fm = (struct feature_matrix *)tmp;
#line 1129
  tmp___6 = byg_start(requested_feature, (char *)"allALL");
  }
#line 1129
  if (tmp___6 != -1) {
#line 1130
    n = utf->f;
#line 1131
    i = 0;
    {
#line 1132
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1132
      if (! n) {
#line 1132
        goto while_break;
      }
#line 1133
      n->color = i;
#line 1134
      i ++;
#line 1135
      n = n->next;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
#line 1137
    tmp___5 = byg_start(requested_feature, (char *)"maxplpMAXPLP");
    }
#line 1137
    if (tmp___5 != -1) {
#line 1138
      n = utf->f;
#line 1139
      i = 0;
      {
#line 1140
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1140
        if (! n) {
#line 1140
          goto while_break___0;
        }
        {
#line 1141
        tmp___0 = byg_start((char *)"SIGNAL PEPTIDE", n->note);
        }
#line 1141
        if (tmp___0 != -1) {
#line 1142
          n->color = 0;
        }
        {
#line 1144
        tmp___1 = byg_start((char *)"TRANSMEMBRANE", n->note);
        }
#line 1144
        if (tmp___1 != -1) {
#line 1145
          n->color = 1;
        }
        {
#line 1147
        tmp___2 = byg_start((char *)"TRANSLOCATED LOOP", n->note);
        }
#line 1147
        if (tmp___2 != -1) {
#line 1148
          n->color = 2;
        }
        {
#line 1150
        tmp___3 = byg_start((char *)"CYTOPLASMIC LOOP", n->note);
        }
#line 1150
        if (tmp___3 != -1) {
#line 1151
          n->color = 3;
        }
#line 1153
        n = n->next;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 1155
      i = 4;
    } else {
#line 1157
      n = utf->f;
#line 1158
      i = 0;
      {
#line 1159
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1159
        if (! n) {
#line 1159
          goto while_break___1;
        }
        {
#line 1160
        tmp___4 = check_identity(requested_feature, n->type);
        }
#line 1160
        if (tmp___4 != -1) {
#line 1162
          n->color = i;
#line 1163
          i ++;
        } else {
#line 1165
          n->color = -1;
        }
#line 1167
        n = n->next;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
  }
  {
#line 1187
  tmp___14 = byg_start(requested_feature, (char *)"maxplp");
  }
#line 1187
  if (tmp___14 != -1) {
    {
#line 1188
    fm->mdim = 4;
#line 1189
    fm->stride = fm->mdim << 1;
#line 1190
    tmp___7 = malloc(sizeof(float *) * (unsigned long )fm->mdim);
#line 1190
    fm->m = (float **)tmp___7;
#line 1191
    i = 0;
    }
    {
#line 1191
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1191
      if (! (i < fm->mdim)) {
#line 1191
        goto while_break___2;
      }
      {
#line 1192
      tmp___8 = malloc(sizeof(float ) * (unsigned long )fm->mdim);
#line 1192
      *(fm->m + i) = (float *)tmp___8;
#line 1191
      i ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
#line 1199
    *(*(fm->m + 0) + 0) = (float )60;
#line 1200
    *(*(fm->m + 0) + 1) = (float )20;
#line 1201
    *(*(fm->m + 0) + 2) = (float )15;
#line 1202
    *(*(fm->m + 0) + 3) = (float )5;
#line 1203
    *(*(fm->m + 1) + 0) = (float )20;
#line 1204
    *(*(fm->m + 1) + 1) = (float )60;
#line 1205
    *(*(fm->m + 1) + 2) = (float )10;
#line 1206
    *(*(fm->m + 1) + 3) = (float )10;
#line 1207
    *(*(fm->m + 2) + 0) = (float )15;
#line 1208
    *(*(fm->m + 2) + 1) = (float )10;
#line 1209
    *(*(fm->m + 2) + 2) = (float )50;
#line 1210
    *(*(fm->m + 2) + 3) = (float )25;
#line 1211
    *(*(fm->m + 3) + 0) = (float )5;
#line 1212
    *(*(fm->m + 3) + 1) = (float )10;
#line 1213
    *(*(fm->m + 3) + 2) = (float )25;
#line 1214
    *(*(fm->m + 3) + 3) = (float )60;
  } else {
    {
#line 1216
    tmp___13 = byg_start(requested_feature, (char *)"wumanber");
    }
#line 1216
    if (tmp___13 != -1) {
      {
#line 1217
      fm->mdim = i;
#line 1218
      fm->stride = fm->mdim << 1;
#line 1219
      tmp___9 = malloc(sizeof(float *) * (unsigned long )fm->mdim);
#line 1219
      fm->m = (float **)tmp___9;
#line 1220
      i = 0;
      }
      {
#line 1220
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 1220
        if (! (i < fm->mdim)) {
#line 1220
          goto while_break___3;
        }
        {
#line 1221
        tmp___10 = malloc(sizeof(float ) * (unsigned long )fm->mdim);
#line 1221
        *(fm->m + i) = (float *)tmp___10;
#line 1222
        j = 0;
        }
        {
#line 1222
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 1222
          if (! (j < fm->mdim)) {
#line 1222
            goto while_break___4;
          }
#line 1223
          *(*(fm->m + i) + j) = (float )0;
#line 1222
          j ++;
        }
        while_break___4: /* CIL Label */ ;
        }
#line 1220
        i ++;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 1226
      i = 0;
      {
#line 1226
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 1226
        if (! (i < fm->mdim)) {
#line 1226
          goto while_break___5;
        }
#line 1227
        *(*(fm->m + i) + i) = (float )100;
#line 1226
        i ++;
      }
      while_break___5: /* CIL Label */ ;
      }
    } else {
      {
#line 1231
      fm->mdim = i;
#line 1232
      fm->stride = fm->mdim << 1;
#line 1233
      tmp___11 = malloc(sizeof(float *) * (unsigned long )fm->mdim);
#line 1233
      fm->m = (float **)tmp___11;
#line 1234
      i = 0;
      }
      {
#line 1234
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 1234
        if (! (i < fm->mdim)) {
#line 1234
          goto while_break___6;
        }
        {
#line 1235
        tmp___12 = malloc(sizeof(float ) * (unsigned long )fm->mdim);
#line 1235
        *(fm->m + i) = (float *)tmp___12;
#line 1236
        j = 0;
        }
        {
#line 1236
        while (1) {
          while_continue___7: /* CIL Label */ ;
#line 1236
          if (! (j < fm->mdim)) {
#line 1236
            goto while_break___7;
          }
#line 1237
          *(*(fm->m + i) + j) = param->diff_feature_score;
#line 1236
          j ++;
        }
        while_break___7: /* CIL Label */ ;
        }
#line 1234
        i ++;
      }
      while_break___6: /* CIL Label */ ;
      }
#line 1240
      i = 0;
      {
#line 1240
      while (1) {
        while_continue___8: /* CIL Label */ ;
#line 1240
        if (! (i < fm->mdim)) {
#line 1240
          goto while_break___8;
        }
#line 1241
        *(*(fm->m + i) + i) = param->same_feature_score;
#line 1240
        i ++;
      }
      while_break___8: /* CIL Label */ ;
      }
    }
  }
#line 1252
  i = (int )numseq;
  {
#line 1252
  while (1) {
    while_continue___9: /* CIL Label */ ;
#line 1252
    tmp___17 = i;
#line 1252
    i --;
#line 1252
    if (! tmp___17) {
#line 1252
      goto while_break___9;
    }
#line 1253
    n = *(aln->ft + i);
    {
#line 1255
    while (1) {
      while_continue___10: /* CIL Label */ ;
#line 1255
      if (! n) {
#line 1255
        goto while_break___10;
      }
#line 1256
      p = utf->f;
      {
#line 1257
      while (1) {
        while_continue___11: /* CIL Label */ ;
#line 1257
        if (! p) {
#line 1257
          goto while_break___11;
        }
        {
#line 1258
        tmp___16 = check_identity(requested_feature, n->type);
        }
#line 1258
        if (tmp___16 != -1) {
          {
#line 1259
          tmp___15 = check_identity(n->note, p->note);
          }
#line 1259
          if (tmp___15 != -1) {
#line 1260
            n->color = p->color;
#line 1263
            goto while_break___11;
          }
        }
#line 1266
        p = p->next;
      }
      while_break___11: /* CIL Label */ ;
      }
#line 1268
      n = n->next;
    }
    while_break___10: /* CIL Label */ ;
    }
  }
  while_break___9: /* CIL Label */ ;
  }
  {
#line 1308
  free_utf(utf);
  }
#line 1309
  return (fm);
}
}
#line 1312 "/home/june/repo/benchmarks/collector/temp/kalign-2.03+20110620/kalign2_feature.c"
struct utype_ufeat *get_unique_features(struct alignment *aln , struct utype_ufeat *utf ) 
{ 
  int i ;
  void *tmp ;

  {
  {
#line 1315
  tmp = malloc(sizeof(struct utype_ufeat ));
#line 1315
  utf = (struct utype_ufeat *)tmp;
#line 1316
  utf->t = (struct feature *)0;
#line 1317
  utf->f = (struct feature *)0;
#line 1318
  i = 0;
  }
  {
#line 1318
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1318
    if (! ((unsigned int )i < numseq)) {
#line 1318
      goto while_break;
    }
    {
#line 1319
    utf = traverse_ft(utf, *(aln->ft + i));
#line 1318
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1321
  return (utf);
}
}
#line 1325 "/home/june/repo/benchmarks/collector/temp/kalign-2.03+20110620/kalign2_feature.c"
struct utype_ufeat *traverse_ft(struct utype_ufeat *utf , struct feature *n ) 
{ 


  {
#line 1327
  if ((unsigned long )n != (unsigned long )((void *)0)) {
    {
#line 1328
    utf->t = add_unique_type(utf->t, n);
#line 1329
    utf->f = add_unique_feature(utf->f, n);
#line 1330
    traverse_ft(utf, n->next);
    }
  }
#line 1332
  return (utf);
}
}
#line 1336 "/home/june/repo/benchmarks/collector/temp/kalign-2.03+20110620/kalign2_feature.c"
struct feature *add_unique_feature(struct feature *n , struct feature *toadd ) 
{ 
  int i ;
  void *tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  void *tmp___4 ;
  size_t tmp___5 ;
  int tmp___6 ;

  {
#line 1340
  if ((unsigned long )n == (unsigned long )((void *)0)) {
    {
#line 1341
    tmp = malloc(sizeof(struct feature ));
#line 1341
    n = (struct feature *)tmp;
#line 1342
    tmp___0 = strlen((char const   *)toadd->type);
#line 1342
    tmp___1 = malloc(sizeof(char ) * (tmp___0 + 1UL));
#line 1342
    n->type = (char *)tmp___1;
#line 1343
    i = 0;
    }
    {
#line 1343
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 1343
      tmp___2 = strlen((char const   *)toadd->type);
      }
#line 1343
      if (! ((size_t )i < tmp___2)) {
#line 1343
        goto while_break;
      }
#line 1344
      *(n->type + i) = *(toadd->type + i);
#line 1343
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1346
    *(n->type + i) = (char)0;
#line 1348
    tmp___3 = strlen((char const   *)toadd->note);
#line 1348
    tmp___4 = malloc(sizeof(char ) * (tmp___3 + 1UL));
#line 1348
    n->note = (char *)tmp___4;
#line 1349
    i = 0;
    }
    {
#line 1349
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 1349
      tmp___5 = strlen((char const   *)toadd->note);
      }
#line 1349
      if (! ((size_t )i < tmp___5)) {
#line 1349
        goto while_break___0;
      }
#line 1350
      *(n->note + i) = *(toadd->note + i);
#line 1349
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1352
    *(n->note + i) = (char)0;
#line 1354
    n->start = toadd->end - toadd->start;
#line 1355
    n->end = 0;
#line 1357
    n->next = (struct feature *)0;
  } else {
    {
#line 1360
    tmp___6 = check_identity(toadd->note, n->note);
    }
#line 1360
    if (tmp___6 == -1) {
      {
#line 1361
      n->next = add_unique_feature(n->next, toadd);
      }
    } else {
#line 1363
      n->start += toadd->end - toadd->start;
    }
  }
#line 1366
  return (n);
}
}
#line 1369 "/home/june/repo/benchmarks/collector/temp/kalign-2.03+20110620/kalign2_feature.c"
struct feature *add_unique_type(struct feature *n , struct feature *toadd ) 
{ 
  int i ;
  void *tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  void *tmp___4 ;
  size_t tmp___5 ;
  int tmp___6 ;

  {
#line 1373
  if ((unsigned long )n == (unsigned long )((void *)0)) {
    {
#line 1374
    tmp = malloc(sizeof(struct feature ));
#line 1374
    n = (struct feature *)tmp;
#line 1375
    tmp___0 = strlen((char const   *)toadd->type);
#line 1375
    tmp___1 = malloc(sizeof(char ) * (tmp___0 + 1UL));
#line 1375
    n->type = (char *)tmp___1;
#line 1376
    i = 0;
    }
    {
#line 1376
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 1376
      tmp___2 = strlen((char const   *)toadd->type);
      }
#line 1376
      if (! ((size_t )i < tmp___2)) {
#line 1376
        goto while_break;
      }
#line 1377
      *(n->type + i) = *(toadd->type + i);
#line 1376
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1379
    *(n->type + i) = (char)0;
#line 1381
    tmp___3 = strlen((char const   *)toadd->note);
#line 1381
    tmp___4 = malloc(sizeof(char ) * (tmp___3 + 1UL));
#line 1381
    n->note = (char *)tmp___4;
#line 1382
    i = 0;
    }
    {
#line 1382
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 1382
      tmp___5 = strlen((char const   *)toadd->note);
      }
#line 1382
      if (! ((size_t )i < tmp___5)) {
#line 1382
        goto while_break___0;
      }
#line 1383
      *(n->note + i) = *(toadd->note + i);
#line 1382
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1385
    *(n->note + i) = (char)0;
#line 1387
    n->start = 0;
#line 1388
    n->end = 0;
#line 1390
    n->next = (struct feature *)0;
  } else {
    {
#line 1392
    tmp___6 = check_identity(toadd->type, n->type);
    }
#line 1392
    if (tmp___6 == -1) {
      {
#line 1393
      n->next = add_unique_type(n->next, toadd);
      }
    }
  }
#line 1396
  return (n);
}
}
#line 434 "/usr/include/libio.h"
extern int _IO_getc(_IO_FILE *__fp ) ;
#line 168 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 709
extern size_t fread(void * __restrict  __ptr , size_t __size , size_t __n , FILE * __restrict  __stream ) ;
#line 749
extern int fseek(FILE *__stream , long __off , int __whence ) ;
#line 754
extern long ftell(FILE *__stream ) ;
#line 828
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) feof)(FILE *__stream ) ;
#line 271 "/home/june/repo/benchmarks/collector/temp/kalign-2.03+20110620/kalign2.h"
int byg_count(char *pattern , char *text ) ;
#line 273
int byg_end(char *pattern , char *text ) ;
#line 285
struct alignment *aln_alloc(struct alignment *aln ) ;
#line 779 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) isatty)(int __fd ) ;
#line 127 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) toupper)(int __c ) ;
#line 34 "/home/june/repo/benchmarks/collector/temp/kalign-2.03+20110620/kalign2_input.h"
struct alignment *read_sequences(struct alignment *aln , char *string ) ;
#line 35
struct alignment *read_sequences_from_swissprot(struct alignment *aln , char *string ) ;
#line 36
struct alignment *read_sequences_uniprot_xml(struct alignment *aln , char *string ) ;
#line 37
struct alignment *read_sequences_macsim_xml(struct alignment *aln , char *string ) ;
#line 38
struct feature *read_ft(struct feature *ft , char *p ) ;
#line 39
struct alignment *read_sequences_clustal(struct alignment *aln , char *string ) ;
#line 40
struct alignment *read_sequences_stockholm(struct alignment *aln , char *string ) ;
#line 42
struct alignment *read_alignment(struct alignment *aln , char *string ) ;
#line 43
struct alignment *read_alignment_from_swissprot(struct alignment *aln , char *string ) ;
#line 44
struct alignment *read_alignment_uniprot_xml(struct alignment *aln , char *string ) ;
#line 45
struct alignment *read_alignment_macsim_xml(struct alignment *aln , char *string ) ;
#line 47
struct alignment *read_alignment_clustal(struct alignment *aln , char *string ) ;
#line 48
struct alignment *read_alignment_stockholm(struct alignment *aln , char *string ) ;
#line 50
char *get_input_into_string(char *string , char *infile ) ;
#line 54
int count_sequences_macsim(char *string ) ;
#line 55
int count_sequences_swissprot(char *string ) ;
#line 56
int count_sequences_uniprot(char *string ) ;
#line 57
int count_sequences_stockholm(char *string ) ;
#line 58
int count_sequences_clustalw(char *string ) ;
#line 59
int count_sequences_fasta(char *string ) ;
#line 61 "/home/june/repo/benchmarks/collector/temp/kalign-2.03+20110620/kalign2_input.h"
static char usage___0[2081]  = 
#line 61
  {      (char )'\n',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )'U',      (char )'s',      (char )'a', 
        (char )'g',      (char )'e',      (char )':',      (char )' ', 
        (char )'k',      (char )'a',      (char )'l',      (char )'i', 
        (char )'g',      (char )'n',      (char )'2',      (char )' ', 
        (char )' ',      (char )' ',      (char )'[',      (char )'I', 
        (char )'N',      (char )'F',      (char )'I',      (char )'L', 
        (char )'E',      (char )']',      (char )' ',      (char )'[', 
        (char )'O',      (char )'U',      (char )'T',      (char )'F', 
        (char )'I',      (char )'L',      (char )'E',      (char )']', 
        (char )' ',      (char )'[',      (char )'O',      (char )'P', 
        (char )'T',      (char )'I',      (char )'O',      (char )'N', 
        (char )'S',      (char )']',      (char )'\n',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )'\n', 
        (char )'\t',      (char )'O',      (char )'p',      (char )'t', 
        (char )'i',      (char )'o',      (char )'n',      (char )'s', 
        (char )':',      (char )'\n',      (char )'\n',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )'-', 
        (char )'s',      (char )',',      (char )'\t',      (char )'-', 
        (char )'g',      (char )'a',      (char )'p',      (char )'o', 
        (char )'p',      (char )'e',      (char )'n',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )'G',      (char )'a',      (char )'p', 
        (char )' ',      (char )'o',      (char )'p',      (char )'e', 
        (char )'n',      (char )' ',      (char )'p',      (char )'e', 
        (char )'n',      (char )'a',      (char )'l',      (char )'t', 
        (char )'y',      (char )'\n',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )'\t',      (char )'-', 
        (char )'g',      (char )'a',      (char )'p',      (char )'_', 
        (char )'o',      (char )'p',      (char )'e',      (char )'n', 
        (char )'\n',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )'\t',      (char )'-',      (char )'g', 
        (char )'p',      (char )'o',      (char )'\n',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )'\t', 
        (char )'\n',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )'-',      (char )'e',      (char )',', 
        (char )'\t',      (char )'-',      (char )'g',      (char )'a', 
        (char )'p',      (char )'e',      (char )'x',      (char )'t', 
        (char )'e',      (char )'n',      (char )'s',      (char )'i', 
        (char )'o',      (char )'n',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )'G', 
        (char )'a',      (char )'p',      (char )' ',      (char )'e', 
        (char )'x',      (char )'t',      (char )'e',      (char )'n', 
        (char )'s',      (char )'i',      (char )'o',      (char )'n', 
        (char )' ',      (char )'p',      (char )'e',      (char )'n', 
        (char )'a',      (char )'l',      (char )'t',      (char )'y', 
        (char )'\n',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )'\t',      (char )'-',      (char )'g', 
        (char )'a',      (char )'p',      (char )'_',      (char )'e', 
        (char )'x',      (char )'t',      (char )'\n',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )'\t', 
        (char )'-',      (char )'g',      (char )'p',      (char )'e', 
        (char )'\n',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )'\t',      (char )'\n',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )'-', 
        (char )'t',      (char )',',      (char )'\t',      (char )'-', 
        (char )'t',      (char )'e',      (char )'r',      (char )'m', 
        (char )'i',      (char )'n',      (char )'a',      (char )'l', 
        (char )'_',      (char )'g',      (char )'a',      (char )'p', 
        (char )'_',      (char )'e',      (char )'x',      (char )'t', 
        (char )'e',      (char )'n',      (char )'s',      (char )'i', 
        (char )'o',      (char )'n',      (char )'_',      (char )'p', 
        (char )'e',      (char )'n',      (char )'a',      (char )'l', 
        (char )'t',      (char )'y',      (char )'\t',      (char )'T', 
        (char )'e',      (char )'r',      (char )'m',      (char )'i', 
        (char )'n',      (char )'a',      (char )'l',      (char )' ', 
        (char )'g',      (char )'a',      (char )'p',      (char )' ', 
        (char )'p',      (char )'e',      (char )'n',      (char )'a', 
        (char )'l',      (char )'t',      (char )'i',      (char )'e', 
        (char )'s',      (char )'\n',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )'\t',      (char )'-', 
        (char )'t',      (char )'g',      (char )'p',      (char )'e', 
        (char )'\n',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )'\t',      (char )'\n',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )'-', 
        (char )'m',      (char )',',      (char )'\t',      (char )'-', 
        (char )'m',      (char )'a',      (char )'t',      (char )'r', 
        (char )'i',      (char )'x',      (char )'_',      (char )'b', 
        (char )'o',      (char )'n',      (char )'u',      (char )'s', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )'A',      (char )' ',      (char )'c', 
        (char )'o',      (char )'n',      (char )'s',      (char )'t', 
        (char )'a',      (char )'n',      (char )'t',      (char )' ', 
        (char )'a',      (char )'d',      (char )'d',      (char )'e', 
        (char )'d',      (char )' ',      (char )'t',      (char )'o', 
        (char )' ',      (char )'t',      (char )'h',      (char )'e', 
        (char )' ',      (char )'s',      (char )'u',      (char )'b', 
        (char )'s',      (char )'t',      (char )'i',      (char )'t', 
        (char )'u',      (char )'t',      (char )'i',      (char )'o', 
        (char )'n',      (char )' ',      (char )'m',      (char )'a', 
        (char )'t',      (char )'r',      (char )'i',      (char )'x', 
        (char )'.',      (char )'\n',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )'\t',      (char )'-', 
        (char )'b',      (char )'o',      (char )'n',      (char )'u', 
        (char )'s',      (char )'\n',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )'\t',      (char )'\n', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )'-',      (char )'c',      (char )',',      (char )'\t', 
        (char )'-',      (char )'s',      (char )'o',      (char )'r', 
        (char )'t',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )'T',      (char )'h',      (char )'e', 
        (char )' ',      (char )'o',      (char )'r',      (char )'d', 
        (char )'e',      (char )'r',      (char )' ',      (char )'i', 
        (char )'n',      (char )' ',      (char )'w',      (char )'h', 
        (char )'i',      (char )'c',      (char )'h',      (char )' ', 
        (char )'t',      (char )'h',      (char )'e',      (char )' ', 
        (char )'s',      (char )'e',      (char )'q',      (char )'u', 
        (char )'e',      (char )'n',      (char )'c',      (char )'e', 
        (char )'s',      (char )' ',      (char )'a',      (char )'p', 
        (char )'p',      (char )'e',      (char )'a',      (char )'r', 
        (char )' ',      (char )'i',      (char )'n',      (char )' ', 
        (char )'t',      (char )'h',      (char )'e',      (char )' ', 
        (char )'o',      (char )'u',      (char )'t',      (char )'p', 
        (char )'u',      (char )'t',      (char )' ',      (char )'a', 
        (char )'l',      (char )'i',      (char )'g',      (char )'n', 
        (char )'m',      (char )'e',      (char )'n',      (char )'t', 
        (char )'.',      (char )'\n',      (char )'\t',      (char )'\t', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )'<', 
        (char )'i',      (char )'n',      (char )'p',      (char )'u', 
        (char )'t',      (char )',',      (char )' ',      (char )'t', 
        (char )'r',      (char )'e',      (char )'e',      (char )',', 
        (char )' ',      (char )'g',      (char )'a',      (char )'p', 
        (char )'s',      (char )'.',      (char )'>',      (char )'\n', 
        (char )'\t',      (char )'\t',      (char )'\n',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )'-', 
        (char )'g',      (char )',',      (char )'\t',      (char )'-', 
        (char )'f',      (char )'e',      (char )'a',      (char )'t', 
        (char )'u',      (char )'r',      (char )'e',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )'S',      (char )'e',      (char )'l', 
        (char )'e',      (char )'c',      (char )'t',      (char )'s', 
        (char )' ',      (char )'f',      (char )'e',      (char )'a', 
        (char )'t',      (char )'u',      (char )'r',      (char )'e', 
        (char )' ',      (char )'m',      (char )'o',      (char )'d', 
        (char )'e',      (char )' ',      (char )'a',      (char )'n', 
        (char )'d',      (char )' ',      (char )'s',      (char )'p', 
        (char )'e',      (char )'c',      (char )'i',      (char )'f', 
        (char )'i',      (char )'e',      (char )'s',      (char )' ', 
        (char )'w',      (char )'h',      (char )'i',      (char )'c', 
        (char )'h',      (char )' ',      (char )'f',      (char )'e', 
        (char )'a',      (char )'t',      (char )'u',      (char )'r', 
        (char )'e',      (char )'s',      (char )' ',      (char )'a', 
        (char )'r',      (char )'e',      (char )' ',      (char )'t', 
        (char )'o',      (char )' ',      (char )'b',      (char )'e', 
        (char )' ',      (char )'u',      (char )'s',      (char )'e', 
        (char )'d',      (char )':',      (char )'\n',      (char )'\t', 
        (char )'\t',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )'e',      (char )'.',      (char )'g',      (char )'.', 
        (char )' ',      (char )'a',      (char )'l',      (char )'l', 
        (char )',',      (char )' ',      (char )'m',      (char )'a', 
        (char )'x',      (char )'p',      (char )'l',      (char )'p', 
        (char )',',      (char )' ',      (char )'S',      (char )'T', 
        (char )'R',      (char )'U',      (char )'C',      (char )'T', 
        (char )',',      (char )' ',      (char )'P',      (char )'F', 
        (char )'A',      (char )'M',      (char )'-',      (char )'A', 
        (char )'.',      (char )'.',      (char )'.',      (char )'.', 
        (char )'\n',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )'\t',      (char )'-',      (char )'s',      (char )'a', 
        (char )'m',      (char )'e',      (char )'_',      (char )'f', 
        (char )'e',      (char )'a',      (char )'t',      (char )'u', 
        (char )'r',      (char )'e',      (char )'_',      (char )'s', 
        (char )'c',      (char )'o',      (char )'r',      (char )'e', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )'S',      (char )'c', 
        (char )'o',      (char )'r',      (char )'e',      (char )' ', 
        (char )'f',      (char )'o',      (char )'r',      (char )' ', 
        (char )'a',      (char )'l',      (char )'i',      (char )'g', 
        (char )'n',      (char )'i',      (char )'n',      (char )'g', 
        (char )' ',      (char )'s',      (char )'a',      (char )'m', 
        (char )'e',      (char )' ',      (char )'f',      (char )'e', 
        (char )'a',      (char )'t',      (char )'u',      (char )'r', 
        (char )'e',      (char )'s',      (char )'\n',      (char )'\t', 
        (char )'\t',      (char )'-',      (char )'d',      (char )'i', 
        (char )'f',      (char )'f',      (char )'_',      (char )'f', 
        (char )'e',      (char )'a',      (char )'t',      (char )'u', 
        (char )'r',      (char )'e',      (char )'_',      (char )'s', 
        (char )'c',      (char )'o',      (char )'r',      (char )'e', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )'P',      (char )'e', 
        (char )'n',      (char )'a',      (char )'l',      (char )'t', 
        (char )'y',      (char )' ',      (char )'f',      (char )'o', 
        (char )'r',      (char )' ',      (char )'a',      (char )'l', 
        (char )'i',      (char )'g',      (char )'n',      (char )'i', 
        (char )'n',      (char )'g',      (char )' ',      (char )'d', 
        (char )'i',      (char )'f',      (char )'f',      (char )'e', 
        (char )'r',      (char )'e',      (char )'n',      (char )'t', 
        (char )' ',      (char )'f',      (char )'e',      (char )'a', 
        (char )'t',      (char )'u',      (char )'r',      (char )'e', 
        (char )'s',      (char )'\n',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )'\t',      (char )'\n', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )'-',      (char )'d',      (char )',',      (char )'\t', 
        (char )'-',      (char )'d',      (char )'i',      (char )'s', 
        (char )'t',      (char )'a',      (char )'n',      (char )'c', 
        (char )'e',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )'D',      (char )'i', 
        (char )'s',      (char )'t',      (char )'a',      (char )'n', 
        (char )'c',      (char )'e',      (char )' ',      (char )'m', 
        (char )'e',      (char )'t',      (char )'h',      (char )'o', 
        (char )'d',      (char )'.',      (char )'\n',      (char )'\t', 
        (char )'\t',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )'<',      (char )'w',      (char )'u',      (char )',', 
        (char )'p',      (char )'a',      (char )'i',      (char )'r', 
        (char )'>',      (char )'\n',      (char )'\t',      (char )'\t', 
        (char )'\n',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )'-',      (char )'b',      (char )',', 
        (char )'\t',      (char )'-',      (char )'g',      (char )'u', 
        (char )'i',      (char )'d',      (char )'e',      (char )'-', 
        (char )'t',      (char )'r',      (char )'e',      (char )'e', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )'G', 
        (char )'u',      (char )'i',      (char )'d',      (char )'e', 
        (char )' ',      (char )'t',      (char )'r',      (char )'e', 
        (char )'e',      (char )' ',      (char )'m',      (char )'e', 
        (char )'t',      (char )'h',      (char )'o',      (char )'d', 
        (char )'.',      (char )'\n',      (char )'\t',      (char )'\t', 
        (char )'-',      (char )'t',      (char )'r',      (char )'e', 
        (char )'e',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )'<',      (char )'n', 
        (char )'j',      (char )',',      (char )'u',      (char )'p', 
        (char )'g',      (char )'m',      (char )'a',      (char )'>', 
        (char )'\n',      (char )'\t',      (char )'\t',      (char )'\n', 
        (char )'\t',      (char )'-',      (char )'z',      (char )',', 
        (char )'\t',      (char )'-',      (char )'z',      (char )'c', 
        (char )'u',      (char )'t',      (char )'o',      (char )'f', 
        (char )'f',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )'P',      (char )'a', 
        (char )'r',      (char )'a',      (char )'m',      (char )'e', 
        (char )'t',      (char )'e',      (char )'r',      (char )' ', 
        (char )'u',      (char )'s',      (char )'e',      (char )'d', 
        (char )' ',      (char )'i',      (char )'n',      (char )' ', 
        (char )'t',      (char )'h',      (char )'e',      (char )' ', 
        (char )'w',      (char )'u',      (char )'-',      (char )'m', 
        (char )'a',      (char )'n',      (char )'b',      (char )'e', 
        (char )'r',      (char )' ',      (char )'b',      (char )'a', 
        (char )'s',      (char )'e',      (char )'d',      (char )' ', 
        (char )'d',      (char )'i',      (char )'s',      (char )'t', 
        (char )'a',      (char )'n',      (char )'c',      (char )'e', 
        (char )' ',      (char )'c',      (char )'a',      (char )'l', 
        (char )'c',      (char )'u',      (char )'l',      (char )'a', 
        (char )'t',      (char )'i',      (char )'o',      (char )'n', 
        (char )'\n',      (char )'\t',      (char )'\t',      (char )'\n', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )'-',      (char )'i',      (char )',',      (char )'\t', 
        (char )'-',      (char )'i',      (char )'n',      (char )'p', 
        (char )'u',      (char )'t',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )'T',      (char )'h', 
        (char )'e',      (char )' ',      (char )'i',      (char )'n', 
        (char )'p',      (char )'u',      (char )'t',      (char )' ', 
        (char )'f',      (char )'i',      (char )'l',      (char )'e', 
        (char )'.',      (char )'\n',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )'\t',      (char )'-', 
        (char )'i',      (char )'n',      (char )'f',      (char )'i', 
        (char )'l',      (char )'e',      (char )'\n',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )'\t', 
        (char )'-',      (char )'i',      (char )'n',      (char )'\n', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )'\t',      (char )'\n',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )'-',      (char )'o', 
        (char )',',      (char )'\t',      (char )'-',      (char )'o', 
        (char )'u',      (char )'t',      (char )'p',      (char )'u', 
        (char )'t',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )'T',      (char )'h',      (char )'e',      (char )' ', 
        (char )'o',      (char )'u',      (char )'t',      (char )'p', 
        (char )'u',      (char )'t',      (char )' ',      (char )'f', 
        (char )'i',      (char )'l',      (char )'e',      (char )'.', 
        (char )'\n',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )'\t',      (char )'-',      (char )'o', 
        (char )'u',      (char )'t',      (char )'f',      (char )'i', 
        (char )'l',      (char )'e',      (char )'\n',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )'\t', 
        (char )'-',      (char )'o',      (char )'u',      (char )'t', 
        (char )'\n',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )'\t',      (char )'\n',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )'-', 
        (char )'a',      (char )',',      (char )'\t',      (char )'-', 
        (char )'g',      (char )'a',      (char )'p',      (char )'_', 
        (char )'i',      (char )'n',      (char )'c',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )'P',      (char )'a', 
        (char )'r',      (char )'a',      (char )'m',      (char )'e', 
        (char )'t',      (char )'e',      (char )'r',      (char )' ', 
        (char )'i',      (char )'n',      (char )'c',      (char )'r', 
        (char )'e',      (char )'a',      (char )'s',      (char )'e', 
        (char )'s',      (char )' ',      (char )'g',      (char )'a', 
        (char )'p',      (char )' ',      (char )'p',      (char )'e', 
        (char )'n',      (char )'a',      (char )'l',      (char )'t', 
        (char )'i',      (char )'e',      (char )'s',      (char )' ', 
        (char )'d',      (char )'e',      (char )'p',      (char )'e', 
        (char )'n',      (char )'d',      (char )'i',      (char )'n', 
        (char )'g',      (char )' ',      (char )'o',      (char )'n', 
        (char )' ',      (char )'t',      (char )'h',      (char )'e', 
        (char )' ',      (char )'n',      (char )'u',      (char )'m', 
        (char )'b',      (char )'e',      (char )'r',      (char )' ', 
        (char )'o',      (char )'f',      (char )' ',      (char )'e', 
        (char )'x',      (char )'i',      (char )'s',      (char )'t', 
        (char )'i',      (char )'n',      (char )'g',      (char )' ', 
        (char )'g',      (char )'a',      (char )'p',      (char )'s', 
        (char )'\n',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )'\t',      (char )'\n',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )'-', 
        (char )'f',      (char )',',      (char )'\t',      (char )'-', 
        (char )'f',      (char )'o',      (char )'r',      (char )'m', 
        (char )'a',      (char )'t',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )'T',      (char )'h',      (char )'e', 
        (char )' ',      (char )'o',      (char )'u',      (char )'t', 
        (char )'p',      (char )'u',      (char )'t',      (char )' ', 
        (char )'f',      (char )'o',      (char )'r',      (char )'m', 
        (char )'a',      (char )'t',      (char )':',      (char )'\n', 
        (char )'\t',      (char )'\t',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )'<',      (char )'f',      (char )'a', 
        (char )'s',      (char )'t',      (char )'a',      (char )',', 
        (char )' ',      (char )'m',      (char )'s',      (char )'f', 
        (char )',',      (char )' ',      (char )'a',      (char )'l', 
        (char )'n',      (char )',',      (char )' ',      (char )'c', 
        (char )'l',      (char )'u',      (char )',',      (char )' ', 
        (char )'m',      (char )'a',      (char )'c',      (char )'s', 
        (char )'i',      (char )'m',      (char )'>',      (char )'\n', 
        (char )'\t',      (char )'\t',      (char )'\n',      (char )'\t', 
        (char )'-',      (char )'q',      (char )',',      (char )'\t', 
        (char )'-',      (char )'q',      (char )'u',      (char )'i', 
        (char )'e',      (char )'t',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )'P',      (char )'r', 
        (char )'i',      (char )'n',      (char )'t',      (char )' ', 
        (char )'n',      (char )'o',      (char )'t',      (char )'h', 
        (char )'i',      (char )'n',      (char )'g',      (char )' ', 
        (char )'t',      (char )'o',      (char )' ',      (char )'S', 
        (char )'T',      (char )'D',      (char )'E',      (char )'R', 
        (char )'R',      (char )'.',      (char )'\n',      (char )'\t', 
        (char )'\t',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )'R', 
        (char )'e',      (char )'a',      (char )'d',      (char )' ', 
        (char )'n',      (char )'o',      (char )'t',      (char )'h', 
        (char )'i',      (char )'n',      (char )'g',      (char )' ', 
        (char )'f',      (char )'r',      (char )'o',      (char )'m', 
        (char )' ',      (char )'S',      (char )'T',      (char )'D', 
        (char )'I',      (char )'N',      (char )'\n',      (char )'\t', 
        (char )'\n',      (char )'\t',      (char )'E',      (char )'x', 
        (char )'a',      (char )'m',      (char )'p',      (char )'l', 
        (char )'e',      (char )'s',      (char )':',      (char )'\n', 
        (char )'\n',      (char )'\t',      (char )'U',      (char )'s', 
        (char )'i',      (char )'n',      (char )'g',      (char )' ', 
        (char )'p',      (char )'i',      (char )'p',      (char )'e', 
        (char )'s',      (char )':',      (char )'\n',      (char )'\t', 
        (char )'\t',      (char )'k',      (char )'a',      (char )'l', 
        (char )'i',      (char )'g',      (char )'n',      (char )'2', 
        (char )' ',      (char )'[',      (char )'O',      (char )'P', 
        (char )'T',      (char )'I',      (char )'O',      (char )'N', 
        (char )'S',      (char )']',      (char )' ',      (char )'<', 
        (char )' ',      (char )'[',      (char )'I',      (char )'N', 
        (char )'F',      (char )'I',      (char )'L',      (char )'E', 
        (char )']',      (char )' ',      (char )' ',      (char )' ', 
        (char )'>',      (char )' ',      (char )'[',      (char )'O', 
        (char )'U',      (char )'T',      (char )'F',      (char )'I', 
        (char )'L',      (char )'E',      (char )']',      (char )'\n', 
        (char )'\t',      (char )'\t',      (char )'m',      (char )'o', 
        (char )'r',      (char )'e',      (char )' ',      (char )'[', 
        (char )'I',      (char )'N',      (char )'F',      (char )'I', 
        (char )'L',      (char )'E',      (char )']',      (char )' ', 
        (char )'|',      (char )' ',      (char )' ',      (char )'k', 
        (char )'a',      (char )'l',      (char )'i',      (char )'g', 
        (char )'n',      (char )'2',      (char )' ',      (char )'[', 
        (char )'O',      (char )'P',      (char )'T',      (char )'I', 
        (char )'O',      (char )'N',      (char )'S',      (char )']', 
        (char )' ',      (char )'>',      (char )' ',      (char )'[', 
        (char )'O',      (char )'U',      (char )'T',      (char )'F', 
        (char )'I',      (char )'L',      (char )'E',      (char )']', 
        (char )'\n',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )'\n',      (char )'\t', 
        (char )'R',      (char )'e',      (char )'l',      (char )'a', 
        (char )'x',      (char )'e',      (char )'d',      (char )' ', 
        (char )'g',      (char )'a',      (char )'p',      (char )' ', 
        (char )'p',      (char )'e',      (char )'n',      (char )'a', 
        (char )'l',      (char )'t',      (char )'i',      (char )'e', 
        (char )'s',      (char )':',      (char )'\n',      (char )'\t', 
        (char )'\t',      (char )'k',      (char )'a',      (char )'l', 
        (char )'i',      (char )'g',      (char )'n',      (char )'2', 
        (char )' ',      (char )'-',      (char )'g',      (char )'p', 
        (char )'o',      (char )' ',      (char )'6',      (char )'0', 
        (char )' ',      (char )'-',      (char )'g',      (char )'p', 
        (char )'e',      (char )' ',      (char )'9',      (char )' ', 
        (char )'-',      (char )'t',      (char )'g',      (char )'p', 
        (char )'e',      (char )' ',      (char )'0',      (char )' ', 
        (char )'-',      (char )'b',      (char )'o',      (char )'n', 
        (char )'u',      (char )'s',      (char )' ',      (char )'0', 
        (char )' ',      (char )'<',      (char )' ',      (char )'[', 
        (char )'I',      (char )'N',      (char )'F',      (char )'I', 
        (char )'L',      (char )'E',      (char )']',      (char )' ', 
        (char )' ',      (char )' ',      (char )'>',      (char )' ', 
        (char )'[',      (char )'O',      (char )'U',      (char )'T', 
        (char )'F',      (char )'I',      (char )'L',      (char )'E', 
        (char )']',      (char )'\n',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )'\n', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )'F',      (char )'e',      (char )'a',      (char )'t', 
        (char )'u',      (char )'r',      (char )'e',      (char )' ', 
        (char )'a',      (char )'l',      (char )'i',      (char )'g', 
        (char )'n',      (char )'m',      (char )'e',      (char )'n', 
        (char )'t',      (char )' ',      (char )'w',      (char )'i', 
        (char )'t',      (char )'h',      (char )' ',      (char )'p', 
        (char )'a',      (char )'i',      (char )'r',      (char )'w', 
        (char )'i',      (char )'s',      (char )'e',      (char )' ', 
        (char )'a',      (char )'l',      (char )'i',      (char )'g', 
        (char )'n',      (char )'m',      (char )'e',      (char )'n', 
        (char )'t',      (char )' ',      (char )'b',      (char )'a', 
        (char )'s',      (char )'e',      (char )'d',      (char )' ', 
        (char )'d',      (char )'i',      (char )'s',      (char )'t', 
        (char )'a',      (char )'n',      (char )'c',      (char )'e', 
        (char )' ',      (char )'m',      (char )'e',      (char )'t', 
        (char )'h',      (char )'o',      (char )'d',      (char )' ', 
        (char )'a',      (char )'n',      (char )'d',      (char )' ', 
        (char )'N',      (char )'J',      (char )' ',      (char )'g', 
        (char )'u',      (char )'i',      (char )'d',      (char )'e', 
        (char )' ',      (char )'t',      (char )'r',      (char )'e', 
        (char )'e',      (char )':',      (char )'\n',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )'\t', 
        (char )'k',      (char )'a',      (char )'l',      (char )'i', 
        (char )'g',      (char )'n',      (char )'2',      (char )' ', 
        (char )'-',      (char )'i',      (char )'n',      (char )' ', 
        (char )'t',      (char )'e',      (char )'s',      (char )'t', 
        (char )'.',      (char )'x',      (char )'m',      (char )'l', 
        (char )' ',      (char )'-',      (char )'d',      (char )'i', 
        (char )'s',      (char )'t',      (char )'a',      (char )'n', 
        (char )'c',      (char )'e',      (char )' ',      (char )'p', 
        (char )'a',      (char )'i',      (char )'r',      (char )' ', 
        (char )'-',      (char )'t',      (char )'r',      (char )'e', 
        (char )'e',      (char )' ',      (char )'n',      (char )'j', 
        (char )' ',      (char )'-',      (char )'s',      (char )'o', 
        (char )'r',      (char )'t',      (char )' ',      (char )'g', 
        (char )'a',      (char )'p',      (char )'s',      (char )' ', 
        (char )'-',      (char )'f',      (char )'e',      (char )'a', 
        (char )'t',      (char )'u',      (char )'r',      (char )'e', 
        (char )' ',      (char )'S',      (char )'T',      (char )'R', 
        (char )'U',      (char )'C',      (char )'T',      (char )' ', 
        (char )'-',      (char )'f',      (char )'o',      (char )'r', 
        (char )'m',      (char )'a',      (char )'t',      (char )' ', 
        (char )'m',      (char )'a',      (char )'c',      (char )'s', 
        (char )'i',      (char )'m',      (char )' ',      (char )'-', 
        (char )'o',      (char )'u',      (char )'t',      (char )' ', 
        (char )'t',      (char )'e',      (char )'s',      (char )'t', 
        (char )'.',      (char )'m',      (char )'a',      (char )'c', 
        (char )'s',      (char )'i',      (char )'m',      (char )'\n', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )'\000'};
#line 32 "/home/june/repo/benchmarks/collector/temp/kalign-2.03+20110620/kalign2_input.c"
struct alignment *detect_and_read_sequences(struct alignment *aln , struct parameters *param ) 
{ 
  int feature ;
  char **input ;
  unsigned short *input_type ;
  unsigned short *input_numseq ;
  int num_input ;
  int i ;
  int j ;
  int c ;
  int free_read ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  void *tmp___24 ;
  int a ;
  int b ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;

  {
#line 35
  feature = 0;
#line 36
  input = (char **)0;
#line 37
  input_type = (unsigned short *)0;
#line 38
  input_numseq = (unsigned short *)0;
#line 40
  num_input = 0;
#line 41
  i = 0;
#line 42
  j = 0;
#line 43
  c = 0;
#line 44
  free_read = 1;
  {
#line 45
  while (1) {
    while_continue: /* CIL Label */ ;
#line 45
    if (! (free_read == 1)) {
#line 45
      if (! *(param->infile + i)) {
#line 45
        goto while_break;
      }
    }
#line 46
    num_input ++;
#line 47
    i ++;
#line 48
    free_read = 0;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 50
  numseq = 0U;
#line 53
  tmp = malloc(sizeof(char *) * (unsigned long )num_input);
#line 53
  input = (char **)tmp;
#line 54
  tmp___0 = malloc(sizeof(unsigned short ) * (unsigned long )num_input);
#line 54
  input_type = (unsigned short *)tmp___0;
#line 55
  tmp___1 = malloc(sizeof(unsigned short ) * (unsigned long )num_input);
#line 55
  input_numseq = (unsigned short *)tmp___1;
#line 57
  i = 0;
  }
  {
#line 57
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 57
    if (! (i < num_input)) {
#line 57
      goto while_break___0;
    }
#line 58
    *(input + i) = (char *)0;
#line 59
    *(input_type + i) = (unsigned short)0;
#line 60
    *(input_numseq + i) = (unsigned short)0;
#line 57
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 63
  free_read = 0;
#line 65
  if (param->quiet) {
#line 66
    c = 1;
  } else {
#line 68
    c = 0;
  }
#line 72
  i = c;
  {
#line 72
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 72
    if (! (i < num_input)) {
#line 72
      goto while_break___1;
    }
#line 73
    if (! *(param->infile + i)) {
      {
#line 74
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"reading from STDIN: ");
      }
    } else {
      {
#line 76
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"reading from %s: ",
              *(param->infile + i));
      }
    }
    {
#line 78
    *(input + i) = get_input_into_string(*(input + i), *(param->infile + i));
    }
#line 79
    if (*(input + i)) {
      {
#line 80
      free_read ++;
#line 81
      tmp___18 = byg_start((char *)"<macsim>", *(input + i));
      }
#line 81
      if (tmp___18 != -1) {
        {
#line 82
        tmp___2 = count_sequences_macsim(*(input + i));
#line 82
        *(input_numseq + i) = (unsigned short )tmp___2;
#line 83
        feature = 1;
#line 84
        *(input_type + i) = (unsigned short)1;
        }
      } else {
        {
#line 85
        tmp___17 = byg_start((char *)"<uniprot", *(input + i));
        }
#line 85
        if (tmp___17 != -1) {
          {
#line 86
          tmp___3 = count_sequences_uniprot(*(input + i));
#line 86
          *(input_numseq + i) = (unsigned short )tmp___3;
#line 87
          *(input_type + i) = (unsigned short)2;
          }
        } else {
          {
#line 88
          tmp___16 = byg_start((char *)"This SWISS-PROT", *(input + i));
          }
#line 88
          if (tmp___16 != -1) {
            {
#line 89
            tmp___4 = count_sequences_swissprot(*(input + i));
#line 89
            *(input_numseq + i) = (unsigned short )tmp___4;
#line 90
            *(input_type + i) = (unsigned short)3;
            }
          } else {
            {
#line 91
            tmp___15 = byg_start((char *)"This Swiss-Prot", *(input + i));
            }
#line 91
            if (tmp___15 != -1) {
              {
#line 92
              tmp___5 = count_sequences_swissprot(*(input + i));
#line 92
              *(input_numseq + i) = (unsigned short )tmp___5;
#line 93
              *(input_type + i) = (unsigned short)3;
              }
            } else {
              {
#line 94
              tmp___14 = byg_start((char *)"CLUSTAL W", *(input + i));
              }
#line 94
              if (tmp___14 != -1) {
                {
#line 95
                tmp___6 = count_sequences_clustalw(*(input + i));
#line 95
                *(input_numseq + i) = (unsigned short )tmp___6;
#line 96
                *(input_type + i) = (unsigned short)4;
                }
              } else {
                {
#line 97
                tmp___13 = byg_start((char *)"PileUp", *(input + i));
                }
#line 97
                if (tmp___13 != -1) {
                  {
#line 98
                  tmp___7 = count_sequences_clustalw(*(input + i));
#line 98
                  *(input_numseq + i) = (unsigned short )tmp___7;
#line 99
                  *(input_type + i) = (unsigned short)4;
                  }
                } else {
                  {
#line 100
                  tmp___12 = byg_start((char *)"MSF:", *(input + i));
                  }
#line 100
                  if (tmp___12 != -1) {
                    {
#line 101
                    tmp___8 = count_sequences_clustalw(*(input + i));
#line 101
                    *(input_numseq + i) = (unsigned short )tmp___8;
#line 102
                    *(input_type + i) = (unsigned short)4;
                    }
                  } else {
                    {
#line 103
                    tmp___11 = byg_start((char *)"STOCKHOLM", *(input + i));
                    }
#line 103
                    if (tmp___11 != -1) {
                      {
#line 104
                      tmp___9 = count_sequences_stockholm(*(input + i));
#line 104
                      *(input_numseq + i) = (unsigned short )tmp___9;
#line 105
                      *(input_type + i) = (unsigned short)5;
                      }
                    } else {
                      {
#line 107
                      tmp___10 = count_sequences_fasta(*(input + i));
#line 107
                      *(input_numseq + i) = (unsigned short )tmp___10;
#line 108
                      *(input_type + i) = (unsigned short)0;
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
      {
#line 110
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"found %d sequences\n",
              (int )*(input_numseq + i));
      }
#line 112
      if ((int )*(input_numseq + i) < 1) {
        {
#line 113
        free((void *)*(input + i));
#line 114
        *(input + i) = (char *)0;
        }
      } else {
#line 116
        numseq += (unsigned int )*(input_numseq + i);
      }
    } else {
      {
#line 119
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"found no sequences.\n");
      }
#line 120
      if (! param->outfile) {
#line 120
        if (i) {
          {
#line 121
          param->outfile = *(param->infile + i);
#line 122
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"-> output file, in ");
          }
#line 124
          if (! param->format) {
            {
#line 125
            tmp___22 = byg_start((char *)"msf", param->outfile);
            }
#line 125
            if (tmp___22 != -1) {
#line 126
              param->format = (char *)"msf";
            } else {
              {
#line 127
              tmp___21 = byg_start((char *)"clustal", param->outfile);
              }
#line 127
              if (tmp___21 != -1) {
#line 128
                param->format = (char *)"clustal";
              } else {
                {
#line 129
                tmp___20 = byg_start((char *)"aln", param->outfile);
                }
#line 129
                if (tmp___20 != -1) {
#line 130
                  param->format = (char *)"clustal";
                } else {
                  {
#line 131
                  tmp___19 = byg_start((char *)"macsim", param->outfile);
                  }
#line 131
                  if (tmp___19 != -1) {
#line 132
                    param->format = (char *)"macsim";
                  } else {
#line 134
                    param->format = (char *)"fasta";
                  }
                }
              }
            }
#line 136
            if (param->reformat) {
              {
#line 137
              fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"unaligned fasta format\n");
              }
            } else
#line 138
            if (param->format) {
              {
#line 139
              fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s format\n",
                      param->format);
              }
            } else {
              {
#line 141
              fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"fasta format\n");
              }
            }
          }
        }
      }
      {
#line 145
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
      }
    }
#line 72
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 150
  if (numseq < 2U) {
    {
#line 151
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s\n",
            usage___0);
    }
#line 152
    if (! numseq) {
      {
#line 153
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\nWARNING: No sequences found.\n\n");
      }
    } else {
      {
#line 155
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\nWARNING: Only one sequence found.\n\n");
      }
    }
#line 157
    i = 0;
    {
#line 157
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 157
      if (! (i < num_input)) {
#line 157
        goto while_break___2;
      }
      {
#line 158
      free((void *)*(input + i));
#line 157
      i ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 160
    free((void *)input_numseq);
#line 161
    free((void *)input_type);
#line 162
    free((void *)input);
#line 163
    free_param(param);
#line 164
    exit(0);
    }
  }
  {
#line 167
  tmp___23 = byg_start(param->alignment_type, (char *)"profPROFprofilePROFILE");
  }
#line 167
  if (tmp___23 != -1) {
#line 168
    if (free_read < 2) {
      {
#line 169
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\nWARNING: You are trying to perform a profile - profile alignment but ony one input file was detected.\n\n");
#line 170
      param->alignment_type = (char *)"default";
      }
    }
  }
#line 175
  if (param->feature_type) {
#line 175
    if (! feature) {
      {
#line 176
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\nWARNING: You are trying to perform a feature alignment but the input format(s) do not contain feature information.\n");
#line 177
      i = 0;
      }
      {
#line 177
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 177
        if (! (i < num_input)) {
#line 177
          goto while_break___3;
        }
        {
#line 178
        free((void *)*(input + i));
#line 177
        i ++;
        }
      }
      while_break___3: /* CIL Label */ ;
      }
      {
#line 180
      free((void *)input_numseq);
#line 181
      free((void *)input_type);
#line 182
      free((void *)input);
#line 183
      free_param(param);
#line 184
      exit(0);
      }
    }
  }
  {
#line 187
  numprofiles = (numseq << 1) - 1U;
#line 188
  aln = aln_alloc(aln);
#line 190
  tmp___25 = byg_start(param->alignment_type, (char *)"profPROFprofilePROFILE");
  }
#line 190
  if (tmp___25 != -1) {
#line 191
    j = 0;
#line 192
    i = 0;
    {
#line 192
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 192
      if (! (i < num_input)) {
#line 192
        goto while_break___4;
      }
#line 194
      if (*(input + i)) {
        {
#line 197
        if ((int )*(input_type + i) == 0) {
#line 197
          goto case_0;
        }
#line 200
        if ((int )*(input_type + i) == 1) {
#line 200
          goto case_1;
        }
#line 203
        if ((int )*(input_type + i) == 2) {
#line 203
          goto case_2;
        }
#line 206
        if ((int )*(input_type + i) == 3) {
#line 206
          goto case_3;
        }
#line 210
        if ((int )*(input_type + i) == 4) {
#line 210
          goto case_4;
        }
#line 213
        if ((int )*(input_type + i) == 5) {
#line 213
          goto case_5;
        }
#line 217
        goto switch_default;
        case_0: /* CIL Label */ 
        {
#line 198
        aln = read_alignment(aln, *(input + i));
        }
#line 199
        goto switch_break;
        case_1: /* CIL Label */ 
        {
#line 201
        aln = read_alignment_macsim_xml(aln, *(input + i));
        }
#line 202
        goto switch_break;
        case_2: /* CIL Label */ 
        {
#line 204
        aln = read_alignment_uniprot_xml(aln, *(input + i));
        }
#line 205
        goto switch_break;
        case_3: /* CIL Label */ 
        {
#line 208
        aln = read_alignment_from_swissprot(aln, *(input + i));
        }
#line 209
        goto switch_break;
        case_4: /* CIL Label */ 
        {
#line 211
        aln = read_alignment_clustal(aln, *(input + i));
        }
#line 212
        goto switch_break;
        case_5: /* CIL Label */ 
        {
#line 214
        aln = read_alignment_stockholm(aln, *(input + i));
        }
#line 215
        goto switch_break;
        switch_default: /* CIL Label */ 
        {
#line 218
        aln = read_alignment(aln, *(input + i));
        }
#line 219
        goto switch_break;
        switch_break: /* CIL Label */ ;
        }
        {
#line 221
        *(input + i) = (char *)0;
#line 223
        *(aln->nsip + (numseq + (unsigned int )j)) = (unsigned int )*(input_numseq + i);
#line 224
        tmp___24 = malloc(sizeof(int ) * (unsigned long )*(aln->nsip + (numseq + (unsigned int )j)));
#line 224
        *(aln->sip + (numseq + (unsigned int )j)) = (unsigned int *)tmp___24;
#line 227
        j ++;
        }
      }
#line 192
      i ++;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 230
    num_input = j;
#line 231
    c = 0;
#line 232
    i = 0;
    {
#line 232
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 232
      if (! (i < num_input)) {
#line 232
        goto while_break___5;
      }
#line 234
      j = 0;
      {
#line 234
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 234
        if (! ((unsigned int )j < *(aln->nsip + (numseq + (unsigned int )i)))) {
#line 234
          goto while_break___6;
        }
#line 235
        *(*(aln->sip + (numseq + (unsigned int )i)) + j) = (unsigned int )c;
#line 236
        c ++;
#line 234
        j ++;
      }
      while_break___6: /* CIL Label */ ;
      }
#line 239
      *(aln->sl + (numseq + (unsigned int )i)) = *(aln->sl + *(*(aln->sip + (numseq + (unsigned int )i)) + 0));
#line 232
      i ++;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 246
    i = 0;
    {
#line 246
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 246
      if (! (i < num_input)) {
#line 246
        goto while_break___7;
      }
#line 247
      j = 0;
      {
#line 247
      while (1) {
        while_continue___8: /* CIL Label */ ;
#line 247
        if (! ((unsigned int )j < *(aln->nsip + (numseq + (unsigned int )i)) - 1U)) {
#line 247
          goto while_break___8;
        }
#line 248
        a = (int )*(*(aln->sip + (numseq + (unsigned int )i)) + j);
#line 249
        a = (int )*(aln->sl + a);
#line 250
        c = j + 1;
        {
#line 250
        while (1) {
          while_continue___9: /* CIL Label */ ;
#line 250
          if (! ((unsigned int )j < *(aln->nsip + (numseq + (unsigned int )i)))) {
#line 250
            goto while_break___9;
          }
#line 251
          b = (int )*(*(aln->sip + (numseq + (unsigned int )i)) + c);
#line 252
          b = (int )*(aln->sl + b);
#line 253
          if (a != b) {
            {
#line 254
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unaligned sequences in input %s.\n",
                    *(param->infile + i));
#line 255
            i = 0;
            }
            {
#line 255
            while (1) {
              while_continue___10: /* CIL Label */ ;
#line 255
              if (! (i < num_input)) {
#line 255
                goto while_break___10;
              }
              {
#line 256
              free((void *)*(input + i));
#line 255
              i ++;
              }
            }
            while_break___10: /* CIL Label */ ;
            }
            {
#line 258
            free((void *)input_numseq);
#line 259
            free((void *)input_type);
#line 260
            free((void *)input);
#line 261
            free_aln(aln);
#line 262
            free_param(param);
#line 263
            exit(0);
            }
          }
#line 250
          j ++;
        }
        while_break___9: /* CIL Label */ ;
        }
#line 247
        j ++;
      }
      while_break___8: /* CIL Label */ ;
      }
#line 246
      i ++;
    }
    while_break___7: /* CIL Label */ ;
    }
  } else {
#line 285
    i = 0;
    {
#line 285
    while (1) {
      while_continue___11: /* CIL Label */ ;
#line 285
      if (! (i < num_input)) {
#line 285
        goto while_break___11;
      }
#line 286
      if (*(input + i)) {
        {
#line 288
        if ((int )*(input_type + i) == 0) {
#line 288
          goto case_0___0;
        }
#line 291
        if ((int )*(input_type + i) == 1) {
#line 291
          goto case_1___0;
        }
#line 294
        if ((int )*(input_type + i) == 2) {
#line 294
          goto case_2___0;
        }
#line 297
        if ((int )*(input_type + i) == 3) {
#line 297
          goto case_3___0;
        }
#line 300
        if ((int )*(input_type + i) == 4) {
#line 300
          goto case_4___0;
        }
#line 303
        if ((int )*(input_type + i) == 5) {
#line 303
          goto case_5___0;
        }
#line 307
        goto switch_default___0;
        case_0___0: /* CIL Label */ 
        {
#line 289
        aln = read_sequences(aln, *(input + i));
        }
#line 290
        goto switch_break___0;
        case_1___0: /* CIL Label */ 
        {
#line 292
        aln = read_sequences_macsim_xml(aln, *(input + i));
        }
#line 293
        goto switch_break___0;
        case_2___0: /* CIL Label */ 
        {
#line 295
        aln = read_sequences_uniprot_xml(aln, *(input + i));
        }
#line 296
        goto switch_break___0;
        case_3___0: /* CIL Label */ 
        {
#line 298
        aln = read_sequences_from_swissprot(aln, *(input + i));
        }
#line 299
        goto switch_break___0;
        case_4___0: /* CIL Label */ 
        {
#line 301
        aln = read_sequences_clustal(aln, *(input + i));
        }
#line 302
        goto switch_break___0;
        case_5___0: /* CIL Label */ 
        {
#line 304
        aln = read_sequences_stockholm(aln, *(input + i));
        }
#line 305
        goto switch_break___0;
        switch_default___0: /* CIL Label */ 
        {
#line 308
        aln = read_sequences(aln, *(input + i));
        }
#line 309
        goto switch_break___0;
        switch_break___0: /* CIL Label */ ;
        }
#line 330
        *(input + i) = (char *)0;
      }
#line 285
      i ++;
    }
    while_break___11: /* CIL Label */ ;
    }
  }
#line 334
  if (numseq < 2U) {
    {
#line 335
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\nNo sequences could be read.\n");
#line 336
    free_param(param);
#line 337
    exit(0);
    }
  }
#line 339
  if (! param->format) {
#line 339
    if (param->outfile) {
      {
#line 340
      tmp___29 = byg_start((char *)"msf", param->outfile);
      }
#line 340
      if (tmp___29 != -1) {
#line 341
        param->format = (char *)"msf";
      } else {
        {
#line 342
        tmp___28 = byg_start((char *)"clustal", param->outfile);
        }
#line 342
        if (tmp___28 != -1) {
#line 343
          param->format = (char *)"clustal";
        } else {
          {
#line 344
          tmp___27 = byg_start((char *)"aln", param->outfile);
          }
#line 344
          if (tmp___27 != -1) {
#line 345
            param->format = (char *)"clustal";
          } else {
            {
#line 346
            tmp___26 = byg_start((char *)"macsim", param->outfile);
            }
#line 346
            if (tmp___26 != -1) {
#line 347
              param->format = (char *)"macsim";
            }
          }
        }
      }
      {
#line 349
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Output file: %s, in %s format.\n",
              param->outfile, param->format);
      }
    }
  }
  {
#line 353
  free((void *)input);
#line 354
  free((void *)input_type);
#line 355
  free((void *)input_numseq);
  }
#line 356
  return (aln);
}
}
#line 359 "/home/june/repo/benchmarks/collector/temp/kalign-2.03+20110620/kalign2_input.c"
int count_sequences_macsim(char *string ) 
{ 
  int n ;

  {
  {
#line 361
  n = 0;
#line 362
  n = byg_count((char *)"<seq-name>", string);
  }
#line 363
  if (! n) {
#line 364
    return (-1);
  }
#line 366
  return (n);
}
}
#line 369 "/home/june/repo/benchmarks/collector/temp/kalign-2.03+20110620/kalign2_input.c"
int count_sequences_swissprot(char *string ) 
{ 
  int n ;

  {
  {
#line 371
  n = 0;
#line 372
  n = byg_count((char *)"ID   ", string);
  }
#line 373
  if (! n) {
#line 374
    return (0);
  }
#line 376
  return (n);
}
}
#line 379 "/home/june/repo/benchmarks/collector/temp/kalign-2.03+20110620/kalign2_input.c"
int count_sequences_uniprot(char *string ) 
{ 
  int n ;

  {
  {
#line 381
  n = 0;
#line 382
  n = byg_count((char *)"<entry", string);
  }
#line 383
  if (! n) {
#line 384
    return (0);
  }
#line 386
  return (n);
}
}
#line 389 "/home/june/repo/benchmarks/collector/temp/kalign-2.03+20110620/kalign2_input.c"
int count_sequences_stockholm(char *string ) 
{ 
  char *p1 ;
  int i ;
  int j ;
  int n ;
  int tmp ;

  {
#line 391
  p1 = string;
#line 392
  i = 0;
#line 393
  j = 0;
#line 394
  n = 0;
  {
#line 395
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 395
    i = byg_end((char *)"\n", p1);
    }
#line 395
    if (! (i != -1)) {
#line 395
      goto while_break;
    }
    {
#line 396
    p1 += i;
#line 397
    tmp = byg_start((char *)"//", p1);
    }
#line 397
    if (! tmp) {
#line 398
      goto while_break;
    }
    {
#line 400
    j = byg_end((char *)"#", p1);
    }
#line 401
    if (j != 1) {
#line 402
      n ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 405
  if (! n) {
#line 406
    return (0);
  }
#line 408
  return (n);
}
}
#line 411 "/home/june/repo/benchmarks/collector/temp/kalign-2.03+20110620/kalign2_input.c"
int count_sequences_clustalw(char *string ) 
{ 
  char *p1 ;
  int i ;
  int j ;
  int c ;
  int n ;
  int f ;

  {
#line 413
  p1 = string;
#line 414
  i = 0;
#line 415
  j = 0;
#line 416
  c = 0;
#line 417
  n = 0;
#line 418
  f = 0;
  {
#line 421
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 421
    i = byg_end((char *)"\n", p1);
    }
#line 421
    if (! (i != -1)) {
#line 421
      goto while_break;
    }
    {
#line 422
    p1 += i;
#line 423
    j = byg_end((char *)" ", p1);
#line 424
    f = byg_end((char *)"\n", p1);
    }
#line 425
    if (f > 2) {
#line 425
      if (f > j) {
#line 425
        if (j != 1) {
#line 426
          if (c == 0) {
#line 427
            i = j;
            {
#line 428
            while (1) {
              while_continue___0: /* CIL Label */ ;
#line 428
              if (! ((int )*(p1 + i) != 10)) {
#line 428
                goto while_break___0;
              }
#line 432
              i ++;
            }
            while_break___0: /* CIL Label */ ;
            }
          }
#line 435
          c ++;
        } else {
#line 425
          goto _L___0;
        }
      } else {
#line 425
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 437
    if (c) {
#line 438
      if (c > n) {
#line 439
        n = c;
      }
#line 441
      c = 0;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 445
  if (! n) {
#line 446
    return (0);
  }
#line 448
  return (n);
}
}
#line 451 "/home/june/repo/benchmarks/collector/temp/kalign-2.03+20110620/kalign2_input.c"
int count_sequences_fasta(char *string ) 
{ 
  int nbytes ;
  int i ;
  int n ;
  int stop ;
  size_t tmp ;

  {
  {
#line 455
  n = 0;
#line 456
  stop = 0;
#line 457
  tmp = strlen((char const   *)string);
#line 457
  nbytes = (int )tmp;
#line 458
  i = 0;
  }
  {
#line 458
  while (1) {
    while_continue: /* CIL Label */ ;
#line 458
    if (! (i < nbytes)) {
#line 458
      goto while_break;
    }
#line 459
    if ((int )*(string + i) == 62) {
#line 459
      if (stop == 0) {
#line 460
        stop = 1;
#line 461
        n ++;
      }
    }
#line 463
    if ((int )*(string + i) == 10) {
#line 464
      stop = 0;
    }
#line 458
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 467
  if (! n) {
#line 468
    return (0);
  }
#line 470
  return (n);
}
}
#line 476 "/home/june/repo/benchmarks/collector/temp/kalign-2.03+20110620/kalign2_input.c"
char *get_input_into_string(char *string , char *infile ) 
{ 
  int i ;
  int string_length ;
  char c ;
  FILE *file ;
  int tmp ;
  long tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;
  void *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
#line 478
  i = 0;
#line 479
  string_length = 2;
#line 480
  c = (char)0;
#line 481
  file = (FILE *)0;
#line 482
  if (infile) {
    {
#line 483
    file = fopen((char const   */* __restrict  */)infile, (char const   */* __restrict  */)"r");
    }
#line 483
    if (! file) {
#line 484
      return ((char *)0);
      {
#line 485
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Cannot open file \'%s\'\n",
              infile);
#line 486
      exit(1);
      }
    }
    {
#line 488
    tmp = fseek(file, 0L, 2);
    }
#line 488
    if (tmp != 0) {
      {
#line 489
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"ERROR: fseek failed\n");
#line 490
      exit(1);
      }
    }
    {
#line 492
    tmp___0 = ftell(file);
#line 492
    i = (int )tmp___0;
#line 493
    tmp___1 = fseek(file, 0L, 0);
    }
#line 493
    if (tmp___1 != 0) {
      {
#line 494
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"ERROR: fseek failed\n");
#line 495
      exit(1);
      }
    }
    {
#line 497
    tmp___2 = malloc((unsigned long )(i + 1) * sizeof(char ));
#line 497
    string = (char *)tmp___2;
#line 498
    fread((void */* __restrict  */)string, sizeof(char ), (size_t )i, (FILE */* __restrict  */)file);
#line 499
    *(string + i) = (char)0;
#line 500
    fclose(file);
    }
  } else {
    {
#line 502
    tmp___7 = isatty(0);
    }
#line 502
    if (tmp___7) {
#line 515
      return ((char *)0);
    } else {
      {
#line 503
      tmp___3 = malloc(sizeof(char *) * (unsigned long )string_length);
#line 503
      string = (char *)tmp___3;
      }
      {
#line 504
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 504
        tmp___6 = feof(stdin);
        }
#line 504
        if (tmp___6) {
#line 504
          goto while_break;
        }
        {
#line 505
        tmp___4 = _IO_getc(stdin);
#line 505
        c = (char )tmp___4;
        }
#line 506
        if (i == string_length) {
          {
#line 507
          string_length <<= 1;
#line 508
          tmp___5 = realloc((void *)string, sizeof(char ) * (unsigned long )string_length);
#line 508
          string = (char *)tmp___5;
          }
        }
#line 510
        *(string + i) = c;
#line 511
        i ++;
      }
      while_break: /* CIL Label */ ;
      }
#line 513
      *(string + (i - 1)) = (char)0;
    }
  }
#line 518
  return (string);
}
}
#line 521 "/home/june/repo/benchmarks/collector/temp/kalign-2.03+20110620/kalign2_input.c"
struct alignment *read_sequences_from_swissprot(struct alignment *aln , char *string ) 
{ 
  int aacode[26] ;
  int i ;
  int j ;
  int c ;
  int n ;
  char *p ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  unsigned short const   **tmp___3 ;

  {
#line 524
  aacode[0] = 0;
#line 524
  aacode[1] = 1;
#line 524
  aacode[2] = 2;
#line 524
  aacode[3] = 3;
#line 524
  aacode[4] = 4;
#line 524
  aacode[5] = 5;
#line 524
  aacode[6] = 6;
#line 524
  aacode[7] = 7;
#line 524
  aacode[8] = 8;
#line 524
  aacode[9] = -1;
#line 524
  aacode[10] = 9;
#line 524
  aacode[11] = 10;
#line 524
  aacode[12] = 11;
#line 524
  aacode[13] = 12;
#line 524
  aacode[14] = 23;
#line 524
  aacode[15] = 13;
#line 524
  aacode[16] = 14;
#line 524
  aacode[17] = 15;
#line 524
  aacode[18] = 16;
#line 524
  aacode[19] = 17;
#line 524
  aacode[20] = 17;
#line 524
  aacode[21] = 18;
#line 524
  aacode[22] = 19;
#line 524
  aacode[23] = 20;
#line 524
  aacode[24] = 21;
#line 524
  aacode[25] = 22;
#line 526
  p = (char *)0;
#line 527
  p = string;
#line 554
  c = 0;
  {
#line 555
  while (1) {
    while_continue: /* CIL Label */ ;
#line 555
    if (! *(aln->sl + c)) {
#line 555
      goto while_break;
    }
#line 556
    c ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 560
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 560
    i = byg_end((char *)"ID   ", p);
    }
#line 560
    if (! (i != -1)) {
#line 560
      goto while_break___0;
    }
    {
#line 561
    p += i;
#line 562
    j = byg_start((char *)" ", p);
#line 563
    *(aln->lsn + c) = (unsigned int )j;
#line 564
    tmp = malloc(sizeof(char ) * (unsigned long )(j + 1));
#line 564
    *(aln->sn + c) = (char *)tmp;
#line 565
    i = 0;
    }
    {
#line 565
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 565
      if (! (i < j)) {
#line 565
        goto while_break___1;
      }
#line 566
      *(*(aln->sn + c) + i) = *(p + i);
#line 565
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 568
    *(*(aln->sn + c) + j) = (char)0;
#line 569
    p += j;
#line 570
    j = byg_end((char *)"SQ   ", p);
#line 571
    p += j;
#line 572
    j = byg_end((char *)"\n", p);
#line 573
    p += j;
#line 574
    j = byg_start((char *)"//", p);
#line 576
    tmp___0 = malloc(sizeof(int ) * (unsigned long )(j + 1));
#line 576
    *(aln->s + c) = (int *)tmp___0;
#line 577
    tmp___1 = malloc(sizeof(char ) * (unsigned long )(j + 1));
#line 577
    *(aln->seq + c) = (char *)tmp___1;
#line 578
    n = 0;
#line 579
    i = 0;
    }
    {
#line 579
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 579
      if (! (i < j)) {
#line 579
        goto while_break___2;
      }
      {
#line 580
      tmp___3 = __ctype_b_loc();
      }
#line 580
      if ((int const   )*(*tmp___3 + (int )*(p + i)) & 1024) {
        {
#line 581
        tmp___2 = toupper((int )*(p + i));
#line 581
        *(*(aln->s + c) + n) = aacode[tmp___2 - 65];
#line 582
        *(*(aln->seq + c) + n) = *(p + i);
#line 583
        n ++;
        }
      }
#line 579
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 586
    *(*(aln->s + c) + n) = 0;
#line 587
    *(*(aln->seq + c) + n) = (char)0;
#line 588
    *(aln->sl + c) = (unsigned int )n;
#line 589
    c ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 591
  free((void *)string);
  }
#line 592
  return (aln);
}
}
#line 596 "/home/june/repo/benchmarks/collector/temp/kalign-2.03+20110620/kalign2_input.c"
struct alignment *read_alignment_from_swissprot(struct alignment *aln , char *string ) 
{ 
  int aacode[26] ;
  int i ;
  int j ;
  int c ;
  int n ;
  char *p ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  unsigned short const   **tmp___3 ;

  {
#line 599
  aacode[0] = 0;
#line 599
  aacode[1] = 1;
#line 599
  aacode[2] = 2;
#line 599
  aacode[3] = 3;
#line 599
  aacode[4] = 4;
#line 599
  aacode[5] = 5;
#line 599
  aacode[6] = 6;
#line 599
  aacode[7] = 7;
#line 599
  aacode[8] = 8;
#line 599
  aacode[9] = -1;
#line 599
  aacode[10] = 9;
#line 599
  aacode[11] = 10;
#line 599
  aacode[12] = 11;
#line 599
  aacode[13] = 12;
#line 599
  aacode[14] = 23;
#line 599
  aacode[15] = 13;
#line 599
  aacode[16] = 14;
#line 599
  aacode[17] = 15;
#line 599
  aacode[18] = 16;
#line 599
  aacode[19] = 17;
#line 599
  aacode[20] = 17;
#line 599
  aacode[21] = 18;
#line 599
  aacode[22] = 19;
#line 599
  aacode[23] = 20;
#line 599
  aacode[24] = 21;
#line 599
  aacode[25] = 22;
#line 601
  p = (char *)0;
#line 602
  p = string;
#line 629
  c = 0;
  {
#line 630
  while (1) {
    while_continue: /* CIL Label */ ;
#line 630
    if (! *(aln->sl + c)) {
#line 630
      goto while_break;
    }
#line 631
    c ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 634
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"found sequence:\n");
  }
  {
#line 635
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 635
    i = byg_end((char *)"ID   ", p);
    }
#line 635
    if (! (i != -1)) {
#line 635
      goto while_break___0;
    }
    {
#line 636
    p += i;
#line 637
    j = byg_start((char *)" ", p);
#line 638
    *(aln->lsn + c) = (unsigned int )j;
#line 639
    tmp = malloc(sizeof(char ) * (unsigned long )(j + 1));
#line 639
    *(aln->sn + c) = (char *)tmp;
#line 640
    i = 0;
    }
    {
#line 640
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 640
      if (! (i < j)) {
#line 640
        goto while_break___1;
      }
#line 641
      *(*(aln->sn + c) + i) = *(p + i);
#line 640
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 643
    *(*(aln->sn + c) + j) = (char)0;
#line 644
    p += j;
#line 645
    j = byg_end((char *)"SQ   ", p);
#line 646
    p += j;
#line 647
    j = byg_end((char *)"\n", p);
#line 648
    p += j;
#line 649
    j = byg_start((char *)"//", p);
#line 650
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"found sequence:\n");
#line 651
    tmp___0 = malloc(sizeof(int ) * (unsigned long )(j + 1));
#line 651
    *(aln->s + c) = (int *)tmp___0;
#line 652
    tmp___1 = malloc(sizeof(char ) * (unsigned long )(j + 1));
#line 652
    *(aln->seq + c) = (char *)tmp___1;
#line 653
    n = 0;
#line 654
    i = 0;
    }
    {
#line 654
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 654
      if (! (i < j)) {
#line 654
        goto while_break___2;
      }
#line 655
      if ((int )*(p + i) > 32) {
        {
#line 656
        tmp___3 = __ctype_b_loc();
        }
#line 656
        if ((int const   )*(*tmp___3 + (int )*(p + i)) & 1024) {
          {
#line 657
          tmp___2 = toupper((int )*(p + i));
#line 657
          *(*(aln->s + c) + n) = aacode[tmp___2 - 65];
          }
        } else {
#line 659
          *(*(aln->s + c) + n) = -1;
        }
        {
#line 661
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%c",
                (int )*(p + i));
#line 662
        *(*(aln->seq + c) + n) = *(p + i);
#line 663
        n ++;
        }
      }
#line 654
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 667
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n\n");
#line 668
    *(*(aln->s + c) + n) = 0;
#line 669
    *(*(aln->seq + c) + n) = (char)0;
#line 670
    *(aln->sl + c) = (unsigned int )n;
#line 671
    c ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 673
  free((void *)string);
  }
#line 674
  return (aln);
}
}
#line 677 "/home/june/repo/benchmarks/collector/temp/kalign-2.03+20110620/kalign2_input.c"
struct alignment *read_sequences_macsim_xml(struct alignment *aln , char *string ) 
{ 
  int c ;
  int n ;
  int i ;
  int j ;
  char *p ;
  int max ;
  int aacode[26] ;
  int tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  int tmp___3 ;
  unsigned short const   **tmp___4 ;

  {
  {
#line 679
  c = 0;
#line 680
  n = 0;
#line 681
  i = 0;
#line 682
  j = 0;
#line 683
  p = (char *)0;
#line 684
  max = 0;
#line 686
  aacode[0] = 0;
#line 686
  aacode[1] = 1;
#line 686
  aacode[2] = 2;
#line 686
  aacode[3] = 3;
#line 686
  aacode[4] = 4;
#line 686
  aacode[5] = 5;
#line 686
  aacode[6] = 6;
#line 686
  aacode[7] = 7;
#line 686
  aacode[8] = 8;
#line 686
  aacode[9] = -1;
#line 686
  aacode[10] = 9;
#line 686
  aacode[11] = 10;
#line 686
  aacode[12] = 11;
#line 686
  aacode[13] = 12;
#line 686
  aacode[14] = 23;
#line 686
  aacode[15] = 13;
#line 686
  aacode[16] = 14;
#line 686
  aacode[17] = 15;
#line 686
  aacode[18] = 16;
#line 686
  aacode[19] = 17;
#line 686
  aacode[20] = 17;
#line 686
  aacode[21] = 18;
#line 686
  aacode[22] = 19;
#line 686
  aacode[23] = 20;
#line 686
  aacode[24] = 21;
#line 686
  aacode[25] = 22;
#line 720
  p = string;
#line 722
  tmp = byg_count((char *)"<g>", p);
  }
#line 722
  if (tmp) {
    {
#line 723
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 723
      i = byg_start((char *)"<g>", p);
      }
#line 723
      if (! (i != -1)) {
#line 723
        goto while_break;
      }
      {
#line 724
      p += i;
#line 725
      j = byg_end((char *)"<r>", p);
#line 726
      i = 0;
      }
      {
#line 726
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 726
        if (! (i < j)) {
#line 726
          goto while_break___0;
        }
#line 727
        *(p + i) = (char )' ';
#line 726
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 729
      i = byg_start((char *)"</r>", p);
#line 730
      p += i;
#line 732
      j = byg_end((char *)"</g>", p);
#line 733
      i = 0;
      }
      {
#line 733
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 733
        if (! (i < j)) {
#line 733
          goto while_break___1;
        }
#line 734
        *(p + i) = (char )' ';
#line 733
        i ++;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 739
  p = string;
#line 741
  c = 0;
  {
#line 742
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 742
    if (! *(aln->sl + c)) {
#line 742
      goto while_break___2;
    }
#line 743
    c ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 748
  while (1) {
    while_continue___3: /* CIL Label */ ;
    {
#line 748
    i = byg_end((char *)"<sequence", p);
    }
#line 748
    if (! (i != -1)) {
#line 748
      goto while_break___3;
    }
    {
#line 749
    p += i;
#line 750
    max = byg_end((char *)"</sequence>", p);
#line 752
    i = byg_end((char *)"<seq-name>", p);
    }
#line 753
    if (i < max) {
      {
#line 754
      p += i;
#line 755
      j = byg_start((char *)"</seq-name>", p);
#line 757
      *(aln->lsn + c) = (unsigned int )j;
#line 758
      tmp___0 = malloc(sizeof(char ) * (unsigned long )(j + 1));
#line 758
      *(aln->sn + c) = (char *)tmp___0;
#line 759
      i = 0;
      }
      {
#line 759
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 759
        if (! (i < j)) {
#line 759
          goto while_break___4;
        }
#line 760
        *(*(aln->sn + c) + i) = *(p + i);
#line 759
        i ++;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 762
      *(*(aln->sn + c) + j) = (char)0;
    }
    {
#line 765
    i = byg_end((char *)"<ftable>", p);
    }
#line 766
    if (i < max) {
      {
#line 767
      *(aln->ft + c) = read_ft(*(aln->ft + c), p);
      }
    }
    {
#line 769
    i = byg_end((char *)"<seq-data>", p);
    }
#line 770
    if (i < max) {
      {
#line 771
      p += i;
#line 772
      j = byg_start((char *)"</seq-data>", p);
#line 773
      tmp___1 = malloc(sizeof(int ) * (unsigned long )(j + 1));
#line 773
      *(aln->s + c) = (int *)tmp___1;
#line 774
      tmp___2 = malloc(sizeof(char ) * (unsigned long )(j + 1));
#line 774
      *(aln->seq + c) = (char *)tmp___2;
#line 775
      n = 0;
#line 776
      i = 0;
      }
      {
#line 776
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 776
        if (! (i < j)) {
#line 776
          goto while_break___5;
        }
        {
#line 777
        tmp___4 = __ctype_b_loc();
        }
#line 777
        if ((int const   )*(*tmp___4 + (int )*(p + i)) & 1024) {
          {
#line 778
          tmp___3 = toupper((int )*(p + i));
#line 778
          *(*(aln->s + c) + n) = aacode[tmp___3 - 65];
#line 779
          *(*(aln->seq + c) + n) = *(p + i);
#line 780
          n ++;
          }
        }
#line 776
        i ++;
      }
      while_break___5: /* CIL Label */ ;
      }
#line 783
      *(*(aln->s + c) + n) = 0;
#line 784
      *(*(aln->seq + c) + n) = (char)0;
#line 785
      *(aln->sl + c) = (unsigned int )n;
    }
#line 788
    c ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 790
  free((void *)string);
  }
#line 791
  return (aln);
}
}
#line 795 "/home/june/repo/benchmarks/collector/temp/kalign-2.03+20110620/kalign2_input.c"
struct alignment *read_alignment_macsim_xml(struct alignment *aln , char *string ) 
{ 
  int c ;
  int n ;
  int i ;
  int j ;
  char *p ;
  int max ;
  int aacode[26] ;
  int tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  int tmp___3 ;
  unsigned short const   **tmp___4 ;

  {
  {
#line 797
  c = 0;
#line 798
  n = 0;
#line 799
  i = 0;
#line 800
  j = 0;
#line 801
  p = (char *)0;
#line 802
  max = 0;
#line 804
  aacode[0] = 0;
#line 804
  aacode[1] = 1;
#line 804
  aacode[2] = 2;
#line 804
  aacode[3] = 3;
#line 804
  aacode[4] = 4;
#line 804
  aacode[5] = 5;
#line 804
  aacode[6] = 6;
#line 804
  aacode[7] = 7;
#line 804
  aacode[8] = 8;
#line 804
  aacode[9] = -1;
#line 804
  aacode[10] = 9;
#line 804
  aacode[11] = 10;
#line 804
  aacode[12] = 11;
#line 804
  aacode[13] = 12;
#line 804
  aacode[14] = 23;
#line 804
  aacode[15] = 13;
#line 804
  aacode[16] = 14;
#line 804
  aacode[17] = 15;
#line 804
  aacode[18] = 16;
#line 804
  aacode[19] = 17;
#line 804
  aacode[20] = 17;
#line 804
  aacode[21] = 18;
#line 804
  aacode[22] = 19;
#line 804
  aacode[23] = 20;
#line 804
  aacode[24] = 21;
#line 804
  aacode[25] = 22;
#line 838
  p = string;
#line 840
  tmp = byg_count((char *)"<g>", p);
  }
#line 840
  if (tmp) {
    {
#line 841
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 841
      i = byg_start((char *)"<g>", p);
      }
#line 841
      if (! (i != -1)) {
#line 841
        goto while_break;
      }
      {
#line 842
      p += i;
#line 843
      j = byg_end((char *)"<r>", p);
#line 844
      i = 0;
      }
      {
#line 844
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 844
        if (! (i < j)) {
#line 844
          goto while_break___0;
        }
#line 845
        *(p + i) = (char )' ';
#line 844
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 847
      i = byg_start((char *)"</r>", p);
#line 848
      p += i;
#line 850
      j = byg_end((char *)"</g>", p);
#line 851
      i = 0;
      }
      {
#line 851
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 851
        if (! (i < j)) {
#line 851
          goto while_break___1;
        }
#line 852
        *(p + i) = (char )' ';
#line 851
        i ++;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 857
  p = string;
#line 859
  c = 0;
  {
#line 860
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 860
    if (! *(aln->sl + c)) {
#line 860
      goto while_break___2;
    }
#line 861
    c ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 866
  while (1) {
    while_continue___3: /* CIL Label */ ;
    {
#line 866
    i = byg_end((char *)"<sequence", p);
    }
#line 866
    if (! (i != -1)) {
#line 866
      goto while_break___3;
    }
    {
#line 867
    p += i;
#line 868
    max = byg_end((char *)"</sequence>", p);
#line 870
    i = byg_end((char *)"<seq-name>", p);
    }
#line 871
    if (i < max) {
      {
#line 872
      p += i;
#line 873
      j = byg_start((char *)"</seq-name>", p);
#line 875
      *(aln->lsn + c) = (unsigned int )j;
#line 876
      tmp___0 = malloc(sizeof(char ) * (unsigned long )(j + 1));
#line 876
      *(aln->sn + c) = (char *)tmp___0;
#line 877
      i = 0;
      }
      {
#line 877
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 877
        if (! (i < j)) {
#line 877
          goto while_break___4;
        }
#line 878
        *(*(aln->sn + c) + i) = *(p + i);
#line 877
        i ++;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 880
      *(*(aln->sn + c) + j) = (char)0;
    }
    {
#line 883
    i = byg_end((char *)"<ftable>", p);
    }
#line 884
    if (i < max) {
      {
#line 885
      *(aln->ft + c) = read_ft(*(aln->ft + c), p);
      }
    }
    {
#line 887
    i = byg_end((char *)"<seq-data>", p);
    }
#line 888
    if (i < max) {
      {
#line 889
      p += i;
#line 890
      j = byg_start((char *)"</seq-data>", p);
#line 891
      tmp___1 = malloc(sizeof(int ) * (unsigned long )(j + 1));
#line 891
      *(aln->s + c) = (int *)tmp___1;
#line 892
      tmp___2 = malloc(sizeof(char ) * (unsigned long )(j + 1));
#line 892
      *(aln->seq + c) = (char *)tmp___2;
#line 893
      n = 0;
#line 894
      i = 0;
      }
      {
#line 894
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 894
        if (! (i < j)) {
#line 894
          goto while_break___5;
        }
#line 895
        if ((int )*(p + i) > 32) {
          {
#line 896
          tmp___4 = __ctype_b_loc();
          }
#line 896
          if ((int const   )*(*tmp___4 + (int )*(p + i)) & 1024) {
            {
#line 897
            tmp___3 = toupper((int )*(p + i));
#line 897
            *(*(aln->s + c) + n) = aacode[tmp___3 - 65];
            }
          } else {
#line 899
            *(*(aln->s + c) + n) = -1;
          }
#line 901
          *(*(aln->seq + c) + n) = *(p + i);
#line 902
          n ++;
        }
#line 894
        i ++;
      }
      while_break___5: /* CIL Label */ ;
      }
#line 905
      *(*(aln->s + c) + n) = 0;
#line 906
      *(*(aln->seq + c) + n) = (char)0;
#line 907
      *(aln->sl + c) = (unsigned int )n;
    }
#line 910
    c ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 912
  free((void *)string);
  }
#line 913
  return (aln);
}
}
#line 917 "/home/june/repo/benchmarks/collector/temp/kalign-2.03+20110620/kalign2_input.c"
struct feature *read_ft(struct feature *ft , char *p ) 
{ 
  int i ;
  int j ;
  struct feature *n ;
  struct feature *old_n ;
  char tmp[10] ;
  char *p1 ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;

  {
#line 921
  n = (struct feature *)0;
#line 922
  old_n = (struct feature *)0;
#line 924
  p1 = (char *)0;
#line 925
  p1 = p;
  {
#line 926
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 926
    j = byg_end((char *)"<fitem>", p1);
    }
#line 926
    if (! (j != -1)) {
#line 926
      goto while_break;
    }
    {
#line 927
    i = byg_end((char *)"</seq-info>", p1);
    }
#line 929
    if (j > i) {
#line 930
      goto while_break;
    }
    {
#line 933
    tmp___0 = malloc(sizeof(struct feature ));
#line 933
    n = (struct feature *)tmp___0;
#line 934
    n->next = (struct feature *)0;
#line 935
    n->color = -1;
#line 937
    p1 += j;
#line 938
    i = byg_end((char *)"<ftype>", p1);
#line 939
    p1 += i;
#line 940
    j = byg_start((char *)"</ftype>", p1);
#line 942
    tmp___1 = malloc(sizeof(char *) * (unsigned long )(j + 1));
#line 942
    n->type = (char *)tmp___1;
#line 943
    i = 0;
    }
    {
#line 943
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 943
      if (! (i < j)) {
#line 943
        goto while_break___0;
      }
#line 944
      *(n->type + i) = *(p1 + i);
#line 943
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 946
    *(n->type + j) = (char)0;
#line 948
    i = byg_end((char *)"<fstart>", p1);
#line 949
    p1 += i;
#line 950
    j = byg_start((char *)"</fstart>", p1);
#line 952
    i = 0;
    }
    {
#line 952
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 952
      if (! (i < j)) {
#line 952
        goto while_break___1;
      }
#line 953
      tmp[i] = *(p1 + i);
#line 952
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 955
    tmp[j] = (char)0;
#line 956
    n->start = atoi((char const   *)(tmp));
#line 957
    i = byg_end((char *)"<fstop>", p1);
#line 958
    p1 += i;
#line 959
    j = byg_start((char *)"</fstop>", p1);
#line 960
    i = 0;
    }
    {
#line 960
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 960
      if (! (i < j)) {
#line 960
        goto while_break___2;
      }
#line 961
      tmp[i] = *(p1 + i);
#line 960
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 963
    tmp[j] = (char)0;
#line 964
    n->end = atoi((char const   *)(tmp));
#line 966
    i = byg_end((char *)"<fnote>", p1);
#line 967
    p1 += i;
#line 968
    j = byg_start((char *)"</fnote>", p1);
#line 969
    tmp___2 = malloc(sizeof(char *) * (unsigned long )(j + 1));
#line 969
    n->note = (char *)tmp___2;
#line 970
    i = 0;
    }
    {
#line 970
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 970
      if (! (i < j)) {
#line 970
        goto while_break___3;
      }
#line 971
      *(n->note + i) = *(p1 + i);
#line 970
      i ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 974
    *(n->note + j) = (char)0;
#line 977
    old_n = ft;
#line 977
    if ((unsigned long )old_n != (unsigned long )((struct feature *)0)) {
      {
#line 978
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 978
        if (! ((unsigned long )old_n->next != (unsigned long )((struct feature *)0))) {
#line 978
          goto while_break___4;
        }
#line 979
        old_n = old_n->next;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 981
      old_n->next = n;
    } else {
#line 983
      ft = n;
    }
#line 985
    n = (struct feature *)0;
  }
  while_break: /* CIL Label */ ;
  }
#line 987
  return (ft);
}
}
#line 990 "/home/june/repo/benchmarks/collector/temp/kalign-2.03+20110620/kalign2_input.c"
struct alignment *read_sequences_uniprot_xml(struct alignment *aln , char *string ) 
{ 
  int c ;
  int n ;
  int i ;
  int j ;
  char *p1 ;
  int aacode[26] ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  unsigned short const   **tmp___3 ;

  {
#line 992
  c = 0;
#line 993
  n = 0;
#line 994
  i = 0;
#line 995
  j = 0;
#line 996
  p1 = (char *)0;
#line 998
  aacode[0] = 0;
#line 998
  aacode[1] = 1;
#line 998
  aacode[2] = 2;
#line 998
  aacode[3] = 3;
#line 998
  aacode[4] = 4;
#line 998
  aacode[5] = 5;
#line 998
  aacode[6] = 6;
#line 998
  aacode[7] = 7;
#line 998
  aacode[8] = 8;
#line 998
  aacode[9] = -1;
#line 998
  aacode[10] = 9;
#line 998
  aacode[11] = 10;
#line 998
  aacode[12] = 11;
#line 998
  aacode[13] = 12;
#line 998
  aacode[14] = 23;
#line 998
  aacode[15] = 13;
#line 998
  aacode[16] = 14;
#line 998
  aacode[17] = 15;
#line 998
  aacode[18] = 16;
#line 998
  aacode[19] = 17;
#line 998
  aacode[20] = 17;
#line 998
  aacode[21] = 18;
#line 998
  aacode[22] = 19;
#line 998
  aacode[23] = 20;
#line 998
  aacode[24] = 21;
#line 998
  aacode[25] = 22;
#line 1028
  p1 = string;
#line 1031
  c = 0;
  {
#line 1032
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1032
    if (! *(aln->sl + c)) {
#line 1032
      goto while_break;
    }
#line 1033
    c ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1036
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 1036
    i = byg_end((char *)"<entry", p1);
    }
#line 1036
    if (! (i != -1)) {
#line 1036
      goto while_break___0;
    }
    {
#line 1038
    p1 += i;
#line 1039
    i = byg_end((char *)"<name>", p1);
#line 1040
    p1 += i;
#line 1041
    j = byg_start((char *)"</name>", p1);
#line 1042
    *(aln->lsn + c) = (unsigned int )j;
#line 1043
    tmp = malloc(sizeof(char ) * (unsigned long )(j + 1));
#line 1043
    *(aln->sn + c) = (char *)tmp;
#line 1044
    i = 0;
    }
    {
#line 1044
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1044
      if (! (i < j)) {
#line 1044
        goto while_break___1;
      }
#line 1045
      *(*(aln->sn + c) + i) = *(p1 + i);
#line 1044
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1047
    *(*(aln->sn + c) + j) = (char)0;
    {
#line 1049
    while (1) {
      while_continue___2: /* CIL Label */ ;
      {
#line 1049
      i = byg_end((char *)"<sequence", p1);
      }
#line 1049
      if (! (i != -1)) {
#line 1049
        goto while_break___2;
      }
      {
#line 1050
      i = byg_end((char *)"<sequence", p1);
#line 1051
      p1 += i;
#line 1052
      i = byg_end((char *)">", p1);
#line 1053
      p1 += i;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 1056
    j = byg_start((char *)"</sequence>", p1);
#line 1058
    tmp___0 = malloc(sizeof(int ) * (unsigned long )(j + 1));
#line 1058
    *(aln->s + c) = (int *)tmp___0;
#line 1059
    tmp___1 = malloc(sizeof(char ) * (unsigned long )(j + 1));
#line 1059
    *(aln->seq + c) = (char *)tmp___1;
#line 1060
    n = 0;
#line 1061
    i = 0;
    }
    {
#line 1061
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 1061
      if (! (i < j)) {
#line 1061
        goto while_break___3;
      }
      {
#line 1062
      tmp___3 = __ctype_b_loc();
      }
#line 1062
      if ((int const   )*(*tmp___3 + (int )*(p1 + i)) & 1024) {
        {
#line 1063
        tmp___2 = toupper((int )*(p1 + i));
#line 1063
        *(*(aln->s + c) + n) = aacode[tmp___2 - 65];
#line 1064
        *(*(aln->seq + c) + n) = *(p1 + i);
#line 1065
        n ++;
        }
      }
#line 1061
      i ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 1068
    *(*(aln->s + c) + n) = 0;
#line 1069
    *(*(aln->seq + c) + n) = (char)0;
#line 1070
    *(aln->sl + c) = (unsigned int )n;
#line 1071
    c ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1073
  free((void *)string);
  }
#line 1074
  return (aln);
}
}
#line 1079 "/home/june/repo/benchmarks/collector/temp/kalign-2.03+20110620/kalign2_input.c"
struct alignment *read_alignment_uniprot_xml(struct alignment *aln , char *string ) 
{ 
  int c ;
  int n ;
  int i ;
  int j ;
  char *p1 ;
  int aacode[26] ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  unsigned short const   **tmp___3 ;

  {
#line 1081
  c = 0;
#line 1082
  n = 0;
#line 1083
  i = 0;
#line 1084
  j = 0;
#line 1085
  p1 = (char *)0;
#line 1087
  aacode[0] = 0;
#line 1087
  aacode[1] = 1;
#line 1087
  aacode[2] = 2;
#line 1087
  aacode[3] = 3;
#line 1087
  aacode[4] = 4;
#line 1087
  aacode[5] = 5;
#line 1087
  aacode[6] = 6;
#line 1087
  aacode[7] = 7;
#line 1087
  aacode[8] = 8;
#line 1087
  aacode[9] = -1;
#line 1087
  aacode[10] = 9;
#line 1087
  aacode[11] = 10;
#line 1087
  aacode[12] = 11;
#line 1087
  aacode[13] = 12;
#line 1087
  aacode[14] = 23;
#line 1087
  aacode[15] = 13;
#line 1087
  aacode[16] = 14;
#line 1087
  aacode[17] = 15;
#line 1087
  aacode[18] = 16;
#line 1087
  aacode[19] = 17;
#line 1087
  aacode[20] = 17;
#line 1087
  aacode[21] = 18;
#line 1087
  aacode[22] = 19;
#line 1087
  aacode[23] = 20;
#line 1087
  aacode[24] = 21;
#line 1087
  aacode[25] = 22;
#line 1117
  p1 = string;
#line 1120
  c = 0;
  {
#line 1121
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1121
    if (! *(aln->sl + c)) {
#line 1121
      goto while_break;
    }
#line 1122
    c ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1125
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 1125
    i = byg_end((char *)"<entry", p1);
    }
#line 1125
    if (! (i != -1)) {
#line 1125
      goto while_break___0;
    }
    {
#line 1126
    p1 += i;
#line 1127
    i = byg_end((char *)"<name>", p1);
#line 1128
    p1 += i;
#line 1129
    j = byg_start((char *)"</name>", p1);
#line 1130
    *(aln->lsn + c) = (unsigned int )j;
#line 1131
    tmp = malloc(sizeof(char ) * (unsigned long )(j + 1));
#line 1131
    *(aln->sn + c) = (char *)tmp;
#line 1132
    i = 0;
    }
    {
#line 1132
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1132
      if (! (i < j)) {
#line 1132
        goto while_break___1;
      }
#line 1133
      *(*(aln->sn + c) + i) = *(p1 + i);
#line 1132
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 1135
    *(*(aln->sn + c) + j) = (char)0;
#line 1136
    i = byg_end((char *)"<sequence", p1);
#line 1137
    p1 += i;
#line 1138
    i = byg_end((char *)">", p1);
#line 1139
    p1 += i;
#line 1140
    j = byg_start((char *)"</sequence>", p1);
#line 1141
    tmp___0 = malloc(sizeof(int ) * (unsigned long )(j + 1));
#line 1141
    *(aln->s + c) = (int *)tmp___0;
#line 1142
    tmp___1 = malloc(sizeof(char ) * (unsigned long )(j + 1));
#line 1142
    *(aln->seq + c) = (char *)tmp___1;
#line 1143
    n = 0;
#line 1144
    i = 0;
    }
    {
#line 1144
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1144
      if (! (i < j)) {
#line 1144
        goto while_break___2;
      }
#line 1145
      if ((int )*(p1 + i) > 32) {
        {
#line 1146
        tmp___3 = __ctype_b_loc();
        }
#line 1146
        if ((int const   )*(*tmp___3 + (int )*(p1 + i)) & 1024) {
          {
#line 1147
          tmp___2 = toupper((int )*(p1 + i));
#line 1147
          *(*(aln->s + c) + n) = aacode[tmp___2 - 65];
          }
        } else {
#line 1149
          *(*(aln->s + c) + n) = -1;
        }
#line 1151
        *(*(aln->seq + c) + n) = *(p1 + i);
#line 1152
        n ++;
      }
#line 1144
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 1155
    *(*(aln->s + c) + n) = 0;
#line 1156
    *(*(aln->seq + c) + n) = (char)0;
#line 1157
    *(aln->sl + c) = (unsigned int )n;
#line 1158
    c ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1160
  free((void *)string);
  }
#line 1161
  return (aln);
}
}
#line 1164 "/home/june/repo/benchmarks/collector/temp/kalign-2.03+20110620/kalign2_input.c"
struct alignment *read_sequences_stockholm(struct alignment *aln , char *string ) 
{ 
  int c ;
  int n ;
  int i ;
  int j ;
  char *p1 ;
  int aacode[26] ;
  int tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  int tmp___3 ;
  unsigned short const   **tmp___4 ;

  {
#line 1166
  c = 0;
#line 1167
  n = 0;
#line 1168
  i = 0;
#line 1169
  j = 0;
#line 1170
  p1 = (char *)0;
#line 1172
  aacode[0] = 0;
#line 1172
  aacode[1] = 1;
#line 1172
  aacode[2] = 2;
#line 1172
  aacode[3] = 3;
#line 1172
  aacode[4] = 4;
#line 1172
  aacode[5] = 5;
#line 1172
  aacode[6] = 6;
#line 1172
  aacode[7] = 7;
#line 1172
  aacode[8] = 8;
#line 1172
  aacode[9] = -1;
#line 1172
  aacode[10] = 9;
#line 1172
  aacode[11] = 10;
#line 1172
  aacode[12] = 11;
#line 1172
  aacode[13] = 12;
#line 1172
  aacode[14] = 23;
#line 1172
  aacode[15] = 13;
#line 1172
  aacode[16] = 14;
#line 1172
  aacode[17] = 15;
#line 1172
  aacode[18] = 16;
#line 1172
  aacode[19] = 17;
#line 1172
  aacode[20] = 17;
#line 1172
  aacode[21] = 18;
#line 1172
  aacode[22] = 19;
#line 1172
  aacode[23] = 20;
#line 1172
  aacode[24] = 21;
#line 1172
  aacode[25] = 22;
#line 1209
  c = 0;
  {
#line 1210
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1210
    if (! *(aln->sl + c)) {
#line 1210
      goto while_break;
    }
#line 1211
    c ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1214
  p1 = string;
  {
#line 1215
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 1215
    i = byg_end((char *)"\n", p1);
    }
#line 1215
    if (! (i != -1)) {
#line 1215
      goto while_break___0;
    }
    {
#line 1216
    p1 += i;
#line 1217
    tmp = byg_start((char *)"//", p1);
    }
#line 1217
    if (! tmp) {
#line 1218
      goto while_break___0;
    }
    {
#line 1220
    j = byg_end((char *)"#", p1);
    }
#line 1221
    if (j != 1) {
      {
#line 1222
      j = byg_start((char *)" ", p1);
#line 1223
      *(aln->lsn + c) = (unsigned int )j;
#line 1224
      tmp___0 = malloc(sizeof(char ) * (unsigned long )(j + 1));
#line 1224
      *(aln->sn + c) = (char *)tmp___0;
#line 1225
      i = 0;
      }
      {
#line 1225
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1225
        if (! (i < j)) {
#line 1225
          goto while_break___1;
        }
#line 1226
        *(*(aln->sn + c) + i) = *(p1 + i);
#line 1225
        i ++;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 1228
      *(*(aln->sn + c) + j) = (char)0;
#line 1231
      p1 += j;
#line 1232
      j = byg_start((char *)"\n", p1);
#line 1234
      tmp___1 = malloc(sizeof(int ) * (unsigned long )(j + 1));
#line 1234
      *(aln->s + c) = (int *)tmp___1;
#line 1235
      tmp___2 = malloc(sizeof(char ) * (unsigned long )(j + 1));
#line 1235
      *(aln->seq + c) = (char *)tmp___2;
#line 1236
      n = 0;
#line 1237
      i = 0;
      }
      {
#line 1237
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 1237
        if (! (i < j)) {
#line 1237
          goto while_break___2;
        }
        {
#line 1238
        tmp___4 = __ctype_b_loc();
        }
#line 1238
        if ((int const   )*(*tmp___4 + (int )*(p1 + i)) & 1024) {
          {
#line 1239
          tmp___3 = toupper((int )*(p1 + i));
#line 1239
          *(*(aln->s + c) + n) = aacode[tmp___3 - 65];
#line 1240
          *(*(aln->seq + c) + n) = *(p1 + i);
#line 1241
          n ++;
          }
        }
#line 1237
        i ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 1244
      *(*(aln->s + c) + n) = 0;
#line 1245
      *(*(aln->seq + c) + n) = (char)0;
#line 1246
      *(aln->sl + c) = (unsigned int )n;
#line 1247
      c ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1251
  free((void *)string);
  }
#line 1252
  return (aln);
}
}
#line 1255 "/home/june/repo/benchmarks/collector/temp/kalign-2.03+20110620/kalign2_input.c"
struct alignment *read_alignment_stockholm(struct alignment *aln , char *string ) 
{ 
  int c ;
  int n ;
  int i ;
  int j ;
  char *p1 ;
  int aacode[26] ;
  int tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  int tmp___3 ;
  unsigned short const   **tmp___4 ;

  {
#line 1257
  c = 0;
#line 1258
  n = 0;
#line 1259
  i = 0;
#line 1260
  j = 0;
#line 1261
  p1 = (char *)0;
#line 1263
  aacode[0] = 0;
#line 1263
  aacode[1] = 1;
#line 1263
  aacode[2] = 2;
#line 1263
  aacode[3] = 3;
#line 1263
  aacode[4] = 4;
#line 1263
  aacode[5] = 5;
#line 1263
  aacode[6] = 6;
#line 1263
  aacode[7] = 7;
#line 1263
  aacode[8] = 8;
#line 1263
  aacode[9] = -1;
#line 1263
  aacode[10] = 9;
#line 1263
  aacode[11] = 10;
#line 1263
  aacode[12] = 11;
#line 1263
  aacode[13] = 12;
#line 1263
  aacode[14] = 23;
#line 1263
  aacode[15] = 13;
#line 1263
  aacode[16] = 14;
#line 1263
  aacode[17] = 15;
#line 1263
  aacode[18] = 16;
#line 1263
  aacode[19] = 17;
#line 1263
  aacode[20] = 17;
#line 1263
  aacode[21] = 18;
#line 1263
  aacode[22] = 19;
#line 1263
  aacode[23] = 20;
#line 1263
  aacode[24] = 21;
#line 1263
  aacode[25] = 22;
#line 1300
  c = 0;
  {
#line 1301
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1301
    if (! *(aln->sl + c)) {
#line 1301
      goto while_break;
    }
#line 1302
    c ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1305
  p1 = string;
  {
#line 1306
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 1306
    i = byg_end((char *)"\n", p1);
    }
#line 1306
    if (! (i != -1)) {
#line 1306
      goto while_break___0;
    }
    {
#line 1307
    p1 += i;
#line 1308
    tmp = byg_start((char *)"//", p1);
    }
#line 1308
    if (! tmp) {
#line 1309
      goto while_break___0;
    }
    {
#line 1311
    j = byg_end((char *)"#", p1);
    }
#line 1312
    if (j != 1) {
      {
#line 1313
      j = byg_start((char *)" ", p1);
#line 1314
      *(aln->lsn + c) = (unsigned int )j;
#line 1315
      tmp___0 = malloc(sizeof(char ) * (unsigned long )(j + 1));
#line 1315
      *(aln->sn + c) = (char *)tmp___0;
#line 1316
      i = 0;
      }
      {
#line 1316
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1316
        if (! (i < j)) {
#line 1316
          goto while_break___1;
        }
#line 1317
        *(*(aln->sn + c) + i) = *(p1 + i);
#line 1316
        i ++;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 1319
      *(*(aln->sn + c) + j) = (char)0;
#line 1322
      p1 += j;
#line 1323
      j = byg_start((char *)"\n", p1);
#line 1325
      tmp___1 = malloc(sizeof(int ) * (unsigned long )(j + 1));
#line 1325
      *(aln->s + c) = (int *)tmp___1;
#line 1326
      tmp___2 = malloc(sizeof(char ) * (unsigned long )(j + 1));
#line 1326
      *(aln->seq + c) = (char *)tmp___2;
#line 1327
      n = 0;
#line 1328
      i = 0;
      }
      {
#line 1328
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 1328
        if (! (i < j)) {
#line 1328
          goto while_break___2;
        }
#line 1329
        if ((int )*(p1 + i) > 32) {
          {
#line 1330
          tmp___4 = __ctype_b_loc();
          }
#line 1330
          if ((int const   )*(*tmp___4 + (int )*(p1 + i)) & 1024) {
            {
#line 1331
            tmp___3 = toupper((int )*(p1 + i));
#line 1331
            *(*(aln->s + c) + n) = aacode[tmp___3 - 65];
            }
          } else {
#line 1333
            *(*(aln->s + c) + n) = -1;
          }
#line 1335
          *(*(aln->seq + c) + n) = *(p1 + i);
#line 1336
          n ++;
        }
#line 1328
        i ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 1339
      *(*(aln->s + c) + n) = 0;
#line 1340
      *(*(aln->seq + c) + n) = (char)0;
#line 1341
      *(aln->sl + c) = (unsigned int )n;
#line 1342
      c ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1346
  free((void *)string);
  }
#line 1347
  return (aln);
}
}
#line 1351 "/home/june/repo/benchmarks/collector/temp/kalign-2.03+20110620/kalign2_input.c"
struct alignment *read_sequences_clustal(struct alignment *aln , char *string ) 
{ 
  int c ;
  int n ;
  int len ;
  int i ;
  int j ;
  int start ;
  char *p1 ;
  int local_numseq___0 ;
  int aacode[26] ;
  unsigned short const   **tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  int tmp___3 ;
  unsigned short const   **tmp___4 ;

  {
#line 1353
  c = 0;
#line 1354
  n = 0;
#line 1355
  len = 0;
#line 1356
  i = 0;
#line 1357
  j = 0;
#line 1358
  start = 0;
#line 1359
  p1 = (char *)0;
#line 1360
  local_numseq___0 = 0;
#line 1362
  aacode[0] = 0;
#line 1362
  aacode[1] = 1;
#line 1362
  aacode[2] = 2;
#line 1362
  aacode[3] = 3;
#line 1362
  aacode[4] = 4;
#line 1362
  aacode[5] = 5;
#line 1362
  aacode[6] = 6;
#line 1362
  aacode[7] = 7;
#line 1362
  aacode[8] = 8;
#line 1362
  aacode[9] = -1;
#line 1362
  aacode[10] = 9;
#line 1362
  aacode[11] = 10;
#line 1362
  aacode[12] = 11;
#line 1362
  aacode[13] = 12;
#line 1362
  aacode[14] = 23;
#line 1362
  aacode[15] = 13;
#line 1362
  aacode[16] = 14;
#line 1362
  aacode[17] = 15;
#line 1362
  aacode[18] = 16;
#line 1362
  aacode[19] = 17;
#line 1362
  aacode[20] = 17;
#line 1362
  aacode[21] = 18;
#line 1362
  aacode[22] = 19;
#line 1362
  aacode[23] = 20;
#line 1362
  aacode[24] = 21;
#line 1362
  aacode[25] = 22;
#line 1367
  p1 = string;
  {
#line 1369
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1369
    i = byg_end((char *)"\n", p1);
    }
#line 1369
    if (! (i != -1)) {
#line 1369
      goto while_break;
    }
    {
#line 1370
    p1 += i;
#line 1371
    j = byg_end((char *)" ", p1);
#line 1372
    n = byg_end((char *)"\n", p1);
    }
#line 1373
    if (n > 2) {
#line 1373
      if (n > j) {
#line 1373
        if (j != 1) {
#line 1374
          if (c == 0) {
#line 1375
            i = j;
            {
#line 1376
            while (1) {
              while_continue___0: /* CIL Label */ ;
#line 1376
              if (! ((int )*(p1 + i) != 10)) {
#line 1376
                goto while_break___0;
              }
              {
#line 1377
              tmp = __ctype_b_loc();
              }
#line 1377
              if (! ((int const   )*(*tmp + (int )*(p1 + i)) & 8192)) {
#line 1378
                len ++;
              }
#line 1380
              i ++;
            }
            while_break___0: /* CIL Label */ ;
            }
          }
#line 1383
          c ++;
        } else {
#line 1373
          goto _L___0;
        }
      } else {
#line 1373
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 1385
    if (c) {
#line 1386
      if (c > local_numseq___0) {
#line 1387
        local_numseq___0 = c;
      }
#line 1389
      c = 0;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1416
  start = 0;
  {
#line 1417
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1417
    if (! *(aln->sl + start)) {
#line 1417
      goto while_break___1;
    }
#line 1418
    start ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1421
  i = start;
  {
#line 1421
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 1421
    if (! (i < local_numseq___0 + start)) {
#line 1421
      goto while_break___2;
    }
    {
#line 1422
    tmp___0 = malloc(sizeof(int ) * (unsigned long )(len + 1));
#line 1422
    *(aln->s + i) = (int *)tmp___0;
#line 1423
    tmp___1 = malloc(sizeof(char ) * (unsigned long )(len + 1));
#line 1423
    *(aln->seq + i) = (char *)tmp___1;
#line 1421
    i ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 1426
  p1 = string;
#line 1427
  c = start;
  {
#line 1428
  while (1) {
    while_continue___3: /* CIL Label */ ;
    {
#line 1428
    i = byg_end((char *)"\n", p1);
    }
#line 1428
    if (! (i != -1)) {
#line 1428
      goto while_break___3;
    }
    {
#line 1429
    p1 += i;
#line 1430
    j = byg_end((char *)" ", p1);
#line 1431
    n = byg_end((char *)"\n", p1);
    }
#line 1432
    if (n > 2) {
#line 1432
      if (n > j) {
#line 1432
        if (j != 1) {
#line 1433
          if (*(aln->lsn + c) == 0U) {
            {
#line 1434
            *(aln->lsn + c) = (unsigned int )j;
#line 1435
            tmp___2 = malloc(sizeof(char ) * (unsigned long )(j + 1));
#line 1435
            *(aln->sn + c) = (char *)tmp___2;
#line 1436
            i = 0;
            }
            {
#line 1436
            while (1) {
              while_continue___4: /* CIL Label */ ;
#line 1436
              if (! (i < j)) {
#line 1436
                goto while_break___4;
              }
#line 1437
              *(*(aln->sn + c) + i) = *(p1 + i);
#line 1436
              i ++;
            }
            while_break___4: /* CIL Label */ ;
            }
#line 1439
            *(*(aln->sn + c) + j) = (char)0;
          }
#line 1441
          i = j;
          {
#line 1441
          while (1) {
            while_continue___5: /* CIL Label */ ;
#line 1441
            if (! (i < n)) {
#line 1441
              goto while_break___5;
            }
            {
#line 1442
            tmp___4 = __ctype_b_loc();
            }
#line 1442
            if ((int const   )*(*tmp___4 + (int )*(p1 + i)) & 1024) {
              {
#line 1443
              tmp___3 = toupper((int )*(p1 + i));
#line 1443
              *(*(aln->s + c) + *(aln->sl + c)) = aacode[tmp___3 - 65];
#line 1444
              *(*(aln->seq + c) + *(aln->sl + c)) = *(p1 + i);
#line 1445
              (*(aln->sl + c)) ++;
              }
            }
#line 1441
            i ++;
          }
          while_break___5: /* CIL Label */ ;
          }
#line 1448
          c ++;
        } else {
#line 1432
          goto _L___2;
        }
      } else {
#line 1432
        goto _L___2;
      }
    } else
    _L___2: /* CIL Label */ 
#line 1450
    if (c != start) {
#line 1452
      c = start;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
#line 1456
  i = start;
  {
#line 1456
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 1456
    if (! (i < local_numseq___0 + start)) {
#line 1456
      goto while_break___6;
    }
#line 1457
    *(*(aln->s + i) + *(aln->sl + i)) = 0;
#line 1456
    i ++;
  }
  while_break___6: /* CIL Label */ ;
  }
  {
#line 1459
  free((void *)string);
  }
#line 1460
  return (aln);
}
}
#line 1464 "/home/june/repo/benchmarks/collector/temp/kalign-2.03+20110620/kalign2_input.c"
struct alignment *read_alignment_clustal(struct alignment *aln , char *string ) 
{ 
  int c ;
  int n ;
  int len ;
  int i ;
  int j ;
  int start ;
  char *p1 ;
  int local_numseq___0 ;
  int aacode[26] ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  unsigned short const   **tmp___3 ;

  {
#line 1466
  c = 0;
#line 1467
  n = 0;
#line 1468
  len = 0;
#line 1469
  i = 0;
#line 1470
  j = 0;
#line 1471
  start = 0;
#line 1472
  p1 = (char *)0;
#line 1473
  local_numseq___0 = 0;
#line 1475
  aacode[0] = 0;
#line 1475
  aacode[1] = 1;
#line 1475
  aacode[2] = 2;
#line 1475
  aacode[3] = 3;
#line 1475
  aacode[4] = 4;
#line 1475
  aacode[5] = 5;
#line 1475
  aacode[6] = 6;
#line 1475
  aacode[7] = 7;
#line 1475
  aacode[8] = 8;
#line 1475
  aacode[9] = -1;
#line 1475
  aacode[10] = 9;
#line 1475
  aacode[11] = 10;
#line 1475
  aacode[12] = 11;
#line 1475
  aacode[13] = 12;
#line 1475
  aacode[14] = 23;
#line 1475
  aacode[15] = 13;
#line 1475
  aacode[16] = 14;
#line 1475
  aacode[17] = 15;
#line 1475
  aacode[18] = 16;
#line 1475
  aacode[19] = 17;
#line 1475
  aacode[20] = 17;
#line 1475
  aacode[21] = 18;
#line 1475
  aacode[22] = 19;
#line 1475
  aacode[23] = 20;
#line 1475
  aacode[24] = 21;
#line 1475
  aacode[25] = 22;
#line 1480
  p1 = string;
  {
#line 1482
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1482
    i = byg_end((char *)"\n", p1);
    }
#line 1482
    if (! (i != -1)) {
#line 1482
      goto while_break;
    }
    {
#line 1483
    p1 += i;
#line 1484
    j = byg_end((char *)" ", p1);
#line 1485
    n = byg_end((char *)"\n", p1);
    }
#line 1486
    if (n > 2) {
#line 1486
      if (n > j) {
#line 1486
        if (j != 1) {
#line 1487
          if (c == 0) {
#line 1488
            i = j;
            {
#line 1489
            while (1) {
              while_continue___0: /* CIL Label */ ;
#line 1489
              if (! ((int )*(p1 + i) != 10)) {
#line 1489
                goto while_break___0;
              }
#line 1490
              if ((int )*(p1 + i) > 32) {
#line 1491
                len ++;
              }
#line 1493
              i ++;
            }
            while_break___0: /* CIL Label */ ;
            }
          }
#line 1496
          c ++;
        } else {
#line 1486
          goto _L___0;
        }
      } else {
#line 1486
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 1498
    if (c) {
#line 1499
      if (c > local_numseq___0) {
#line 1500
        local_numseq___0 = c;
      }
#line 1502
      c = 0;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1529
  start = 0;
  {
#line 1530
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1530
    if (! *(aln->sl + start)) {
#line 1530
      goto while_break___1;
    }
#line 1531
    start ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1534
  i = start;
  {
#line 1534
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 1534
    if (! (i < local_numseq___0 + start)) {
#line 1534
      goto while_break___2;
    }
    {
#line 1535
    tmp = malloc(sizeof(int ) * (unsigned long )(len + 1));
#line 1535
    *(aln->s + i) = (int *)tmp;
#line 1536
    tmp___0 = malloc(sizeof(char ) * (unsigned long )(len + 1));
#line 1536
    *(aln->seq + i) = (char *)tmp___0;
#line 1534
    i ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 1539
  p1 = string;
#line 1540
  c = start;
  {
#line 1541
  while (1) {
    while_continue___3: /* CIL Label */ ;
    {
#line 1541
    i = byg_end((char *)"\n", p1);
    }
#line 1541
    if (! (i != -1)) {
#line 1541
      goto while_break___3;
    }
    {
#line 1542
    p1 += i;
#line 1543
    j = byg_end((char *)" ", p1);
#line 1544
    n = byg_end((char *)"\n", p1);
    }
#line 1545
    if (n > 2) {
#line 1545
      if (n > j) {
#line 1545
        if (j != 1) {
#line 1546
          if (*(aln->lsn + c) == 0U) {
            {
#line 1547
            *(aln->lsn + c) = (unsigned int )j;
#line 1548
            tmp___1 = malloc(sizeof(char ) * (unsigned long )(j + 1));
#line 1548
            *(aln->sn + c) = (char *)tmp___1;
#line 1549
            i = 0;
            }
            {
#line 1549
            while (1) {
              while_continue___4: /* CIL Label */ ;
#line 1549
              if (! (i < j)) {
#line 1549
                goto while_break___4;
              }
#line 1550
              *(*(aln->sn + c) + i) = *(p1 + i);
#line 1549
              i ++;
            }
            while_break___4: /* CIL Label */ ;
            }
#line 1552
            *(*(aln->sn + c) + j) = (char)0;
          }
#line 1554
          i = j;
          {
#line 1554
          while (1) {
            while_continue___5: /* CIL Label */ ;
#line 1554
            if (! (i < n)) {
#line 1554
              goto while_break___5;
            }
#line 1555
            if ((int )*(p1 + i) > 32) {
              {
#line 1556
              tmp___3 = __ctype_b_loc();
              }
#line 1556
              if ((int const   )*(*tmp___3 + (int )*(p1 + i)) & 1024) {
                {
#line 1557
                tmp___2 = toupper((int )*(p1 + i));
#line 1557
                *(*(aln->s + c) + *(aln->sl + c)) = aacode[tmp___2 - 65];
                }
              } else {
#line 1559
                *(*(aln->s + c) + *(aln->sl + c)) = -1;
              }
#line 1561
              *(*(aln->seq + c) + *(aln->sl + c)) = *(p1 + i);
#line 1562
              (*(aln->sl + c)) ++;
            }
#line 1554
            i ++;
          }
          while_break___5: /* CIL Label */ ;
          }
#line 1565
          c ++;
        } else {
#line 1545
          goto _L___2;
        }
      } else {
#line 1545
        goto _L___2;
      }
    } else
    _L___2: /* CIL Label */ 
#line 1567
    if (c != start) {
#line 1569
      c = start;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
#line 1573
  i = start;
  {
#line 1573
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 1573
    if (! (i < local_numseq___0 + start)) {
#line 1573
      goto while_break___6;
    }
#line 1574
    *(*(aln->s + i) + *(aln->sl + i)) = 0;
#line 1575
    *(*(aln->seq + i) + *(aln->sl + i)) = (char)0;
#line 1573
    i ++;
  }
  while_break___6: /* CIL Label */ ;
  }
  {
#line 1577
  free((void *)string);
  }
#line 1578
  return (aln);
}
}
#line 1581 "/home/june/repo/benchmarks/collector/temp/kalign-2.03+20110620/kalign2_input.c"
struct alignment *read_sequences(struct alignment *aln , char *string ) 
{ 
  int c ;
  int n ;
  int i ;
  int j ;
  int stop ;
  int start ;
  int nbytes ;
  int local_numseq___0 ;
  int aacode[26] ;
  size_t tmp ;
  unsigned short const   **tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;
  unsigned short const   **tmp___5 ;

  {
  {
#line 1583
  c = 0;
#line 1584
  n = 0;
#line 1585
  i = 0;
#line 1586
  j = 0;
#line 1587
  stop = 0;
#line 1588
  start = 0;
#line 1590
  local_numseq___0 = 0;
#line 1591
  aacode[0] = 0;
#line 1591
  aacode[1] = 1;
#line 1591
  aacode[2] = 2;
#line 1591
  aacode[3] = 3;
#line 1591
  aacode[4] = 4;
#line 1591
  aacode[5] = 5;
#line 1591
  aacode[6] = 6;
#line 1591
  aacode[7] = 7;
#line 1591
  aacode[8] = 8;
#line 1591
  aacode[9] = -1;
#line 1591
  aacode[10] = 9;
#line 1591
  aacode[11] = 10;
#line 1591
  aacode[12] = 11;
#line 1591
  aacode[13] = 12;
#line 1591
  aacode[14] = 23;
#line 1591
  aacode[15] = 13;
#line 1591
  aacode[16] = 14;
#line 1591
  aacode[17] = 15;
#line 1591
  aacode[18] = 16;
#line 1591
  aacode[19] = 17;
#line 1591
  aacode[20] = 17;
#line 1591
  aacode[21] = 18;
#line 1591
  aacode[22] = 19;
#line 1591
  aacode[23] = 20;
#line 1591
  aacode[24] = 21;
#line 1591
  aacode[25] = 22;
#line 1592
  tmp = strlen((char const   *)string);
#line 1592
  nbytes = (int )tmp;
#line 1595
  i = 0;
  }
  {
#line 1595
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1595
    if (! (i < nbytes)) {
#line 1595
      goto while_break;
    }
#line 1596
    if ((int )*(string + i) == 62) {
#line 1596
      if (stop == 0) {
#line 1597
        stop = 1;
#line 1598
        local_numseq___0 ++;
      }
    }
#line 1600
    if ((int )*(string + i) == 10) {
#line 1601
      stop = 0;
    }
#line 1595
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1624
  start = 0;
  {
#line 1625
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1625
    if (! *(aln->sl + start)) {
#line 1625
      goto while_break___0;
    }
#line 1626
    start ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1628
  j = start;
#line 1630
  i = 0;
  {
#line 1630
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1630
    if (! (i < nbytes)) {
#line 1630
      goto while_break___1;
    }
#line 1631
    if ((int )*(string + i) == 62) {
#line 1631
      if (stop == 0) {
#line 1632
        stop = 1;
#line 1633
        *(aln->sl + j) = (unsigned int )c;
#line 1634
        j ++;
#line 1635
        c = 0;
      }
    }
#line 1637
    if ((int )*(string + i) == 10) {
#line 1638
      if (stop == 1) {
#line 1639
        *(aln->lsn + (j - 1)) = (unsigned int )n;
#line 1640
        n = 0;
      }
#line 1642
      stop = 0;
    }
#line 1644
    if (stop == 1) {
#line 1644
      if ((int )*(string + i) != 10) {
#line 1644
        if ((int )*(string + i) != 0) {
#line 1644
          if ((int )*(string + i) != 62) {
#line 1645
            n ++;
          }
        }
      }
    }
#line 1647
    if (stop == 0) {
#line 1647
      if ((int )*(string + i) != 10) {
#line 1647
        if ((int )*(string + i) != 0) {
          {
#line 1648
          tmp___0 = __ctype_b_loc();
          }
#line 1648
          if ((int const   )*(*tmp___0 + (int )*(string + i)) & 1024) {
#line 1649
            c ++;
          }
        }
      }
    }
#line 1630
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1653
  *(aln->sl + j) = (unsigned int )c;
#line 1655
  i = 1 + start;
  {
#line 1655
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 1655
    if (! (i < (local_numseq___0 + 1) + start)) {
#line 1655
      goto while_break___2;
    }
#line 1656
    if (! *(aln->sl + i)) {
      {
#line 1657
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Sequence %d has a length of 0!!\n",
              i - 1);
#line 1658
      exit(1);
      }
    }
#line 1660
    *(aln->sl + (i - 1)) = *(aln->sl + i);
#line 1655
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 1662
  *(aln->sl + (start + local_numseq___0)) = 0U;
#line 1665
  i = start;
  {
#line 1665
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 1665
    if (! (i < local_numseq___0 + start)) {
#line 1665
      goto while_break___3;
    }
    {
#line 1666
    tmp___1 = malloc(sizeof(int ) * (unsigned long )(*(aln->sl + i) + 1U));
#line 1666
    *(aln->s + i) = (int *)tmp___1;
#line 1667
    tmp___2 = malloc(sizeof(char ) * (unsigned long )(*(aln->sl + i) + 1U));
#line 1667
    *(aln->seq + i) = (char *)tmp___2;
#line 1668
    tmp___3 = malloc(sizeof(char ) * (unsigned long )(*(aln->lsn + i) + 1U));
#line 1668
    *(aln->sn + i) = (char *)tmp___3;
#line 1665
    i ++;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
#line 1674
  stop = 0;
#line 1675
  j = start;
#line 1676
  i = 0;
  {
#line 1676
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 1676
    if (! (i < nbytes)) {
#line 1676
      goto while_break___4;
    }
#line 1677
    if ((int )*(string + i) == 62) {
#line 1677
      if (stop == 0) {
#line 1678
        stop = 1;
#line 1679
        j ++;
#line 1680
        c = 0;
      }
    }
#line 1682
    if ((int )*(string + i) == 10) {
#line 1683
      if (stop == 1) {
#line 1684
        n = 0;
      }
#line 1686
      stop = 0;
    }
#line 1688
    if (stop == 1) {
#line 1688
      if ((int )*(string + i) != 10) {
#line 1688
        if ((int )*(string + i) != 0) {
#line 1688
          if ((int )*(string + i) != 62) {
#line 1689
            *(*(aln->sn + (j - 1)) + n) = *(string + i);
#line 1690
            n ++;
          }
        }
      }
    }
#line 1692
    if (stop == 0) {
#line 1692
      if ((int )*(string + i) != 10) {
#line 1692
        if ((int )*(string + i) != 0) {
          {
#line 1693
          tmp___5 = __ctype_b_loc();
          }
#line 1693
          if ((int const   )*(*tmp___5 + (int )*(string + i)) & 1024) {
            {
#line 1694
            tmp___4 = toupper((int )*(string + i));
#line 1694
            *(*(aln->s + (j - 1)) + c) = aacode[tmp___4 - 65];
#line 1695
            *(*(aln->seq + (j - 1)) + c) = *(string + i);
#line 1696
            c ++;
            }
          }
        }
      }
    }
#line 1676
    i ++;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 1701
  i = start;
  {
#line 1701
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 1701
    if (! (i < local_numseq___0 + start)) {
#line 1701
      goto while_break___5;
    }
#line 1702
    *(*(aln->s + i) + *(aln->sl + i)) = 0;
#line 1703
    *(*(aln->seq + i) + *(aln->sl + i)) = (char)0;
#line 1704
    *(*(aln->sn + i) + *(aln->lsn + i)) = (char)0;
#line 1701
    i ++;
  }
  while_break___5: /* CIL Label */ ;
  }
  {
#line 1707
  free((void *)string);
  }
#line 1708
  return (aln);
}
}
#line 1712 "/home/june/repo/benchmarks/collector/temp/kalign-2.03+20110620/kalign2_input.c"
struct alignment *read_alignment(struct alignment *aln , char *string ) 
{ 
  int c ;
  int n ;
  int i ;
  int j ;
  int stop ;
  int start ;
  int nbytes ;
  int local_numseq___0 ;
  int aacode[26] ;
  size_t tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  int tmp___3 ;
  unsigned short const   **tmp___4 ;

  {
  {
#line 1714
  c = 0;
#line 1715
  n = 0;
#line 1716
  i = 0;
#line 1717
  j = 0;
#line 1718
  stop = 0;
#line 1719
  start = 0;
#line 1721
  local_numseq___0 = 0;
#line 1722
  aacode[0] = 0;
#line 1722
  aacode[1] = 1;
#line 1722
  aacode[2] = 2;
#line 1722
  aacode[3] = 3;
#line 1722
  aacode[4] = 4;
#line 1722
  aacode[5] = 5;
#line 1722
  aacode[6] = 6;
#line 1722
  aacode[7] = 7;
#line 1722
  aacode[8] = 8;
#line 1722
  aacode[9] = -1;
#line 1722
  aacode[10] = 9;
#line 1722
  aacode[11] = 10;
#line 1722
  aacode[12] = 11;
#line 1722
  aacode[13] = 12;
#line 1722
  aacode[14] = 23;
#line 1722
  aacode[15] = 13;
#line 1722
  aacode[16] = 14;
#line 1722
  aacode[17] = 15;
#line 1722
  aacode[18] = 16;
#line 1722
  aacode[19] = 17;
#line 1722
  aacode[20] = 17;
#line 1722
  aacode[21] = 18;
#line 1722
  aacode[22] = 19;
#line 1722
  aacode[23] = 20;
#line 1722
  aacode[24] = 21;
#line 1722
  aacode[25] = 22;
#line 1723
  tmp = strlen((char const   *)string);
#line 1723
  nbytes = (int )tmp;
#line 1726
  i = 0;
  }
  {
#line 1726
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1726
    if (! (i < nbytes)) {
#line 1726
      goto while_break;
    }
#line 1727
    if ((int )*(string + i) == 62) {
#line 1727
      if (stop == 0) {
#line 1728
        stop = 1;
#line 1729
        local_numseq___0 ++;
      }
    }
#line 1731
    if ((int )*(string + i) == 10) {
#line 1732
      stop = 0;
    }
#line 1726
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1755
  start = 0;
  {
#line 1756
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1756
    if (! *(aln->sl + start)) {
#line 1756
      goto while_break___0;
    }
#line 1757
    start ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1759
  j = start;
#line 1761
  i = 0;
  {
#line 1761
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1761
    if (! (i < nbytes)) {
#line 1761
      goto while_break___1;
    }
#line 1762
    if ((int )*(string + i) == 62) {
#line 1762
      if (stop == 0) {
#line 1763
        stop = 1;
#line 1764
        *(aln->sl + j) = (unsigned int )c;
#line 1765
        j ++;
#line 1766
        c = 0;
      }
    }
#line 1768
    if ((int )*(string + i) == 10) {
#line 1769
      if (stop == 1) {
#line 1770
        *(aln->lsn + (j - 1)) = (unsigned int )n;
#line 1771
        n = 0;
      }
#line 1773
      stop = 0;
    }
#line 1775
    if (stop == 1) {
#line 1775
      if ((int )*(string + i) != 10) {
#line 1775
        if ((int )*(string + i) != 0) {
#line 1775
          if ((int )*(string + i) != 62) {
#line 1776
            n ++;
          }
        }
      }
    }
#line 1778
    if (stop == 0) {
#line 1778
      if ((int )*(string + i) != 10) {
#line 1778
        if ((int )*(string + i) != 0) {
#line 1779
          if ((int )*(string + i) > 32) {
#line 1780
            c ++;
          }
        }
      }
    }
#line 1761
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1784
  *(aln->sl + j) = (unsigned int )c;
#line 1786
  i = 1 + start;
  {
#line 1786
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 1786
    if (! (i < (local_numseq___0 + 1) + start)) {
#line 1786
      goto while_break___2;
    }
#line 1787
    if (! *(aln->sl + i)) {
      {
#line 1788
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Sequence %d has a length of 0!!\n",
              i - 1);
#line 1789
      exit(1);
      }
    }
#line 1791
    *(aln->sl + (i - 1)) = *(aln->sl + i);
#line 1786
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 1793
  *(aln->sl + (start + local_numseq___0)) = 0U;
#line 1796
  i = start;
  {
#line 1796
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 1796
    if (! (i < local_numseq___0 + start)) {
#line 1796
      goto while_break___3;
    }
    {
#line 1798
    tmp___0 = malloc(sizeof(int ) * (unsigned long )(*(aln->sl + i) + 1U));
#line 1798
    *(aln->s + i) = (int *)tmp___0;
#line 1799
    tmp___1 = malloc(sizeof(char ) * (unsigned long )(*(aln->sl + i) + 1U));
#line 1799
    *(aln->seq + i) = (char *)tmp___1;
#line 1800
    tmp___2 = malloc(sizeof(char ) * (unsigned long )(*(aln->lsn + i) + 1U));
#line 1800
    *(aln->sn + i) = (char *)tmp___2;
#line 1796
    i ++;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
#line 1806
  stop = 0;
#line 1807
  j = start;
#line 1808
  i = 0;
  {
#line 1808
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 1808
    if (! (i < nbytes)) {
#line 1808
      goto while_break___4;
    }
#line 1809
    if ((int )*(string + i) == 62) {
#line 1809
      if (stop == 0) {
#line 1810
        stop = 1;
#line 1811
        j ++;
#line 1812
        c = 0;
      }
    }
#line 1814
    if ((int )*(string + i) == 10) {
#line 1815
      if (stop == 1) {
#line 1816
        n = 0;
      }
#line 1818
      stop = 0;
    }
#line 1820
    if (stop == 1) {
#line 1820
      if ((int )*(string + i) != 10) {
#line 1820
        if ((int )*(string + i) != 0) {
#line 1820
          if ((int )*(string + i) != 62) {
#line 1821
            *(*(aln->sn + (j - 1)) + n) = *(string + i);
#line 1822
            n ++;
          }
        }
      }
    }
#line 1824
    if (stop == 0) {
#line 1824
      if ((int )*(string + i) != 10) {
#line 1824
        if ((int )*(string + i) != 0) {
#line 1825
          if ((int )*(string + i) > 32) {
            {
#line 1826
            tmp___4 = __ctype_b_loc();
            }
#line 1826
            if ((int const   )*(*tmp___4 + (int )*(string + i)) & 1024) {
              {
#line 1827
              tmp___3 = toupper((int )*(string + i));
#line 1827
              *(*(aln->s + (j - 1)) + c) = aacode[tmp___3 - 65];
              }
            } else {
#line 1829
              *(*(aln->s + (j - 1)) + c) = -1;
            }
#line 1831
            *(*(aln->seq + (j - 1)) + c) = *(string + i);
#line 1832
            c ++;
          }
        }
      }
    }
#line 1808
    i ++;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 1837
  i = start;
  {
#line 1837
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 1837
    if (! (i < local_numseq___0 + start)) {
#line 1837
      goto while_break___5;
    }
#line 1838
    *(*(aln->s + i) + *(aln->sl + i)) = 0;
#line 1839
    *(*(aln->seq + i) + *(aln->sl + i)) = (char)0;
#line 1840
    *(*(aln->sn + i) + *(aln->lsn + i)) = (char)0;
#line 1837
    i ++;
  }
  while_break___5: /* CIL Label */ ;
  }
  {
#line 1843
  free((void *)string);
  }
#line 1844
  return (aln);
}
}
#line 212 "/home/june/repo/benchmarks/collector/temp/kalign-2.03+20110620/kalign2.h"
struct dp_matrix *dp_matrix_alloc(struct dp_matrix *dp , int x , int y ) ;
#line 213
struct dp_matrix *dp_matrix_realloc(struct dp_matrix *dp , int x , int y ) ;
#line 214
void dp_matrix_free(struct dp_matrix *dp ) ;
#line 234
int *pp_dyn(int *path , struct dp_matrix *dp , float const   *prof1 , float const   *prof2 ,
            int const   len_a , int const   len_b ) ;
#line 235
int *ps_dyn(int *path , struct dp_matrix *dp , float const   *prof1 , int const   *seq2 ,
            int const   len_a , int const   len_b , int sip ) ;
#line 236
int *ss_dyn(float **subm , int *path , struct dp_matrix *dp , int const   *seq1 ,
            int const   *seq2 , int const   len_a , int const   len_b ) ;
#line 333
void free_real_tree(struct aln_tree_node *p ) ;
#line 28 "/home/june/repo/benchmarks/collector/temp/kalign-2.03+20110620/kalign2_alignment_types.c"
int **default_alignment(struct alignment *aln , int *tree , float **submatrix , int **map ) 
{ 
  struct dp_matrix *dp ;
  int i ;
  int j ;
  int g ;
  int a ;
  int b ;
  int c ;
  int len_a ;
  int len_b ;
  float **profile ;
  float *profa ;
  float *profb ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
  {
#line 30
  dp = (struct dp_matrix *)0;
#line 34
  profile = (float **)0;
#line 35
  profa = (float *)0;
#line 36
  profb = (float *)0;
#line 38
  tmp = malloc(sizeof(float *) * (unsigned long )numprofiles);
#line 38
  profile = (float **)tmp;
#line 39
  i = 0;
  }
  {
#line 39
  while (1) {
    while_continue: /* CIL Label */ ;
#line 39
    if (! ((unsigned int )i < numprofiles)) {
#line 39
      goto while_break;
    }
#line 40
    *(profile + i) = (float *)0;
#line 39
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 43
  tmp___0 = malloc(sizeof(int *) * (unsigned long )numprofiles);
#line 43
  map = (int **)tmp___0;
#line 44
  i = 0;
  }
  {
#line 44
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 44
    if (! ((unsigned int )i < numprofiles)) {
#line 44
      goto while_break___0;
    }
#line 45
    *(map + i) = (int *)0;
#line 44
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 49
  dp = dp_matrix_alloc(dp, 511, 511);
#line 51
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\nAlignment:\n");
#line 54
  i = 0;
  }
  {
#line 54
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 54
    if (! ((unsigned int )i < numseq - 1U)) {
#line 54
      goto while_break___1;
    }
    {
#line 55
    a = *(tree + i * 3);
#line 56
    b = *(tree + (i * 3 + 1));
#line 57
    c = *(tree + (i * 3 + 2));
#line 58
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\r%8.0f percent done",
            (double )(((float )i / (float )numseq) * (float )100));
#line 60
    len_a = (int )*(aln->sl + a);
#line 61
    len_b = (int )*(aln->sl + b);
#line 62
    dp = dp_matrix_realloc(dp, len_a, len_b);
#line 64
    tmp___1 = malloc(sizeof(int ) * (unsigned long )((len_a + len_b) + 2));
#line 64
    *(map + c) = (int *)tmp___1;
#line 65
    j = (len_a + len_b) + 2;
    }
    {
#line 65
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 65
      tmp___2 = j;
#line 65
      j --;
#line 65
      if (! tmp___2) {
#line 65
        goto while_break___2;
      }
#line 66
      *(*(map + c) + j) = 0;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 68
    if ((unsigned int )a < numseq) {
      {
#line 69
      *(profile + a) = make_profile(*(profile + a), *(aln->s + a), len_a, submatrix);
      }
    }
#line 71
    if ((unsigned int )b < numseq) {
      {
#line 72
      *(profile + b) = make_profile(*(profile + b), *(aln->s + b), len_b, submatrix);
      }
    }
    {
#line 74
    profa = *(profile + a) + 64;
#line 75
    profb = *(profile + b) + 64;
#line 77
    set_gap_penalties(*(profile + a), len_a, (int )*(aln->nsip + b), (float )0, (int )*(aln->nsip + a));
#line 78
    set_gap_penalties(*(profile + b), len_b, (int )*(aln->nsip + a), (float )0, (int )*(aln->nsip + b));
    }
#line 79
    if (*(aln->nsip + a) == 1U) {
#line 80
      if (*(aln->nsip + b) == 1U) {
        {
#line 81
        *(map + c) = ss_dyn(submatrix, *(map + c), dp, (int const   *)*(aln->s + a),
                            (int const   *)*(aln->s + b), (int const   )len_a, (int const   )len_b);
        }
      } else {
        {
#line 83
        *(map + c) = ps_dyn(*(map + c), dp, (float const   *)profb, (int const   *)*(aln->s + a),
                            (int const   )len_b, (int const   )len_a, (int )*(aln->nsip + b));
#line 84
        *(map + c) = mirror_path(*(map + c));
        }
      }
    } else
#line 87
    if (*(aln->nsip + b) == 1U) {
      {
#line 88
      *(map + c) = ps_dyn(*(map + c), dp, (float const   *)profa, (int const   *)*(aln->s + b),
                          (int const   )len_a, (int const   )len_b, (int )*(aln->nsip + a));
      }
    } else
#line 90
    if (len_a > len_b) {
      {
#line 91
      *(map + c) = pp_dyn(*(map + c), dp, (float const   *)profa, (float const   *)profb,
                          (int const   )len_a, (int const   )len_b);
      }
    } else {
      {
#line 93
      *(map + c) = pp_dyn(*(map + c), dp, (float const   *)profb, (float const   *)profa,
                          (int const   )len_b, (int const   )len_a);
#line 94
      *(map + c) = mirror_path(*(map + c));
      }
    }
    {
#line 99
    tmp___3 = malloc((sizeof(float ) * 64UL) * (unsigned long )((len_a + len_b) + 2));
#line 99
    *(profile + c) = (float *)tmp___3;
#line 101
    *(profile + c) = update((float const   *)*(profile + a), (float const   *)*(profile + b),
                            *(profile + c), *(map + c), (int )*(aln->nsip + a), (int )*(aln->nsip + b));
#line 104
    *(aln->sl + c) = (unsigned int )*(*(map + c) + 0);
#line 106
    *(aln->nsip + c) = *(aln->nsip + a) + *(aln->nsip + b);
#line 107
    tmp___4 = malloc(sizeof(int ) * (unsigned long )(*(aln->nsip + a) + *(aln->nsip + b)));
#line 107
    *(aln->sip + c) = (unsigned int *)tmp___4;
#line 108
    g = 0;
#line 109
    j = (int )*(aln->nsip + a);
    }
    {
#line 109
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 109
      tmp___5 = j;
#line 109
      j --;
#line 109
      if (! tmp___5) {
#line 109
        goto while_break___3;
      }
#line 110
      *(*(aln->sip + c) + g) = *(*(aln->sip + a) + j);
#line 111
      g ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 113
    j = (int )*(aln->nsip + b);
    {
#line 113
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 113
      tmp___6 = j;
#line 113
      j --;
#line 113
      if (! tmp___6) {
#line 113
        goto while_break___4;
      }
#line 114
      *(*(aln->sip + c) + g) = *(*(aln->sip + b) + j);
#line 115
      g ++;
    }
    while_break___4: /* CIL Label */ ;
    }
    {
#line 117
    free((void *)*(profile + a));
#line 118
    free((void *)*(profile + b));
#line 54
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 120
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\r%8.0f percent done\n",
          100.0);
#line 121
  free((void *)*(profile + (numprofiles - 1U)));
#line 122
  free((void *)profile);
#line 124
  dp_matrix_free(dp);
#line 125
  i = 32;
  }
  {
#line 125
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 125
    tmp___7 = i;
#line 125
    i --;
#line 125
    if (! tmp___7) {
#line 125
      goto while_break___5;
    }
    {
#line 126
    free((void *)*(submatrix + i));
    }
  }
  while_break___5: /* CIL Label */ ;
  }
  {
#line 128
  free((void *)submatrix);
  }
#line 129
  return (map);
}
}
#line 618 "/home/june/repo/benchmarks/collector/temp/kalign-2.03+20110620/kalign2_alignment_types.c"
struct ntree_data *ntree_sub_alignment(struct ntree_data *ntree_data , int *tree ,
                                       int num ) 
{ 
  struct dp_matrix *dp ;
  struct alignment *aln ;
  int i ;
  int j ;
  int g ;
  int a ;
  int b ;
  int c ;
  int len_a ;
  int len_b ;
  float **local_profile ;
  float *profa ;
  float *profb ;
  int **local_map ;
  int *local_sl ;
  int *local_nsip ;
  int **local_sip ;
  int *which_to_alloc ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  int tmp___7 ;
  void *tmp___8 ;
  void *tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  void *tmp___12 ;
  void *tmp___13 ;
  void *tmp___14 ;
  void *tmp___15 ;
  void *tmp___16 ;
  void *tmp___17 ;

  {
  {
#line 620
  dp = (struct dp_matrix *)0;
#line 621
  aln = (struct alignment *)0;
#line 625
  local_profile = (float **)0;
#line 626
  profa = (float *)0;
#line 627
  profb = (float *)0;
#line 629
  local_map = (int **)0;
#line 630
  local_sl = (int *)0;
#line 631
  local_nsip = (int *)0;
#line 632
  local_sip = (int **)0;
#line 634
  which_to_alloc = (int *)0;
#line 636
  aln = ntree_data->aln;
#line 638
  tmp = malloc(sizeof(int *) * (unsigned long )numprofiles);
#line 638
  which_to_alloc = (int *)tmp;
#line 639
  i = 0;
  }
  {
#line 639
  while (1) {
    while_continue: /* CIL Label */ ;
#line 639
    if (! ((unsigned int )i < numprofiles)) {
#line 639
      goto while_break;
    }
#line 640
    *(which_to_alloc + i) = 0;
#line 639
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 643
  tmp___0 = malloc(sizeof(float *) * (unsigned long )numprofiles);
#line 643
  local_profile = (float **)tmp___0;
#line 644
  tmp___1 = malloc(sizeof(int ) * (unsigned long )numprofiles);
#line 644
  local_sl = (int *)tmp___1;
#line 645
  tmp___2 = malloc(sizeof(int ) * (unsigned long )numprofiles);
#line 645
  local_nsip = (int *)tmp___2;
#line 646
  tmp___3 = malloc(sizeof(int *) * (unsigned long )numprofiles);
#line 646
  local_sip = (int **)tmp___3;
#line 649
  i = 0;
  }
  {
#line 649
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 649
    if (! (i < num - 1)) {
#line 649
      goto while_break___0;
    }
#line 650
    a = *(tree + (i * 3 + 1));
#line 651
    if (! *(which_to_alloc + a)) {
#line 652
      *(which_to_alloc + a) = 1;
    }
#line 654
    b = *(tree + (i * 3 + 2));
#line 655
    if (! *(which_to_alloc + b)) {
#line 656
      *(which_to_alloc + b) = 1;
    }
#line 658
    c = *(tree + (i * 3 + 3));
#line 659
    if (! *(which_to_alloc + c)) {
#line 660
      *(which_to_alloc + c) = 2;
    }
#line 649
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 668
  i = 0;
  {
#line 668
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 668
    if (! ((unsigned int )i < numprofiles)) {
#line 668
      goto while_break___1;
    }
#line 669
    if (*(which_to_alloc + i) == 1) {
      {
#line 670
      *(local_profile + i) = *(ntree_data->profile + i);
#line 671
      *(local_sl + i) = (int )*(aln->sl + i);
#line 672
      *(local_nsip + i) = (int )*(aln->nsip + i);
#line 673
      tmp___4 = malloc(sizeof(int *) * (unsigned long )*(aln->nsip + i));
#line 673
      *(local_sip + i) = (int *)tmp___4;
#line 674
      j = 0;
      }
      {
#line 674
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 674
        if (! ((unsigned int )j < *(aln->nsip + i))) {
#line 674
          goto while_break___2;
        }
#line 675
        *(*(local_sip + i) + j) = (int )*(*(aln->sip + i) + j);
#line 674
        j ++;
      }
      while_break___2: /* CIL Label */ ;
      }
    } else {
#line 678
      *(local_profile + i) = (float *)0;
#line 679
      *(local_sl + i) = 0;
#line 680
      *(local_nsip + i) = 0;
#line 681
      *(local_sip + i) = (int *)0;
    }
#line 668
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 700
  tmp___5 = malloc(sizeof(int *) * (unsigned long )numprofiles);
#line 700
  local_map = (int **)tmp___5;
#line 701
  i = 0;
  }
  {
#line 701
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 701
    if (! ((unsigned int )i < numprofiles)) {
#line 701
      goto while_break___3;
    }
#line 702
    *(local_map + i) = (int *)0;
#line 701
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 706
  dp = dp_matrix_alloc(dp, 511, 511);
#line 707
  c = (int )numseq;
#line 708
  i = 0;
  }
  {
#line 708
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 708
    if (! (i < num - 1)) {
#line 708
      goto while_break___4;
    }
    {
#line 709
    a = *(tree + (i * 3 + 1));
#line 710
    b = *(tree + (i * 3 + 2));
#line 711
    c = *(tree + (i * 3 + 3));
#line 713
    len_a = *(local_sl + a);
#line 714
    len_b = *(local_sl + b);
#line 715
    dp = dp_matrix_realloc(dp, len_a, len_b);
#line 717
    tmp___6 = malloc(sizeof(int ) * (unsigned long )((len_a + len_b) + 2));
#line 717
    *(local_map + c) = (int *)tmp___6;
#line 718
    j = (len_a + len_b) + 2;
    }
    {
#line 718
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 718
      tmp___7 = j;
#line 718
      j --;
#line 718
      if (! tmp___7) {
#line 718
        goto while_break___5;
      }
#line 719
      *(*(local_map + c) + j) = 0;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 721
    if ((unsigned int )a < numseq) {
      {
#line 722
      *(local_profile + a) = make_profile(*(local_profile + a), *(aln->s + a), len_a,
                                          ntree_data->submatrix);
      }
    }
#line 724
    if ((unsigned int )b < numseq) {
      {
#line 725
      *(local_profile + b) = make_profile(*(local_profile + b), *(aln->s + b), len_b,
                                          ntree_data->submatrix);
      }
    }
    {
#line 727
    profa = *(local_profile + a);
#line 728
    profb = *(local_profile + b);
#line 730
    set_gap_penalties(profa, len_a, *(local_nsip + b), (float )0, *(local_nsip + a));
#line 731
    set_gap_penalties(profb, len_b, *(local_nsip + a), (float )0, *(local_nsip + b));
    }
#line 733
    if (*(local_nsip + a) == 1) {
#line 734
      if (*(local_nsip + b) == 1) {
        {
#line 735
        *(local_map + c) = ss_dyn(ntree_data->submatrix, *(local_map + c), dp, (int const   *)*(aln->s + a),
                                  (int const   *)*(aln->s + b), (int const   )len_a,
                                  (int const   )len_b);
        }
      } else {
        {
#line 737
        *(local_map + c) = ps_dyn(*(local_map + c), dp, (float const   *)profb, (int const   *)*(aln->s + a),
                                  (int const   )len_b, (int const   )len_a, *(local_nsip + b));
#line 738
        *(local_map + c) = mirror_path(*(local_map + c));
        }
      }
    } else
#line 741
    if (*(local_nsip + b) == 1) {
      {
#line 742
      *(local_map + c) = ps_dyn(*(local_map + c), dp, (float const   *)profa, (int const   *)*(aln->s + b),
                                (int const   )len_a, (int const   )len_b, *(local_nsip + a));
      }
    } else
#line 744
    if (len_a > len_b) {
      {
#line 745
      *(local_map + c) = pp_dyn(*(local_map + c), dp, (float const   *)profa, (float const   *)profb,
                                (int const   )len_a, (int const   )len_b);
      }
    } else {
      {
#line 747
      *(local_map + c) = pp_dyn(*(local_map + c), dp, (float const   *)profb, (float const   *)profa,
                                (int const   )len_b, (int const   )len_a);
#line 748
      *(local_map + c) = mirror_path(*(local_map + c));
      }
    }
    {
#line 753
    tmp___8 = malloc((sizeof(float ) * 64UL) * (unsigned long )((len_a + len_b) + 2));
#line 753
    *(local_profile + c) = (float *)tmp___8;
#line 754
    *(local_profile + c) = update((float const   *)profa, (float const   *)profb,
                                  *(local_profile + c), *(local_map + c), *(local_nsip + a),
                                  *(local_nsip + b));
#line 756
    *(local_sl + c) = *(*(local_map + c) + 0);
#line 758
    *(local_nsip + c) = *(local_nsip + a) + *(local_nsip + b);
#line 759
    tmp___9 = malloc(sizeof(int ) * (unsigned long )(*(local_nsip + a) + *(local_nsip + b)));
#line 759
    *(local_sip + c) = (int *)tmp___9;
#line 760
    g = 0;
#line 761
    j = *(local_nsip + a);
    }
    {
#line 761
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 761
      tmp___10 = j;
#line 761
      j --;
#line 761
      if (! tmp___10) {
#line 761
        goto while_break___6;
      }
#line 762
      *(*(local_sip + c) + g) = *(*(local_sip + a) + j);
#line 763
      g ++;
    }
    while_break___6: /* CIL Label */ ;
    }
#line 765
    j = *(local_nsip + b);
    {
#line 765
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 765
      tmp___11 = j;
#line 765
      j --;
#line 765
      if (! tmp___11) {
#line 765
        goto while_break___7;
      }
#line 766
      *(*(local_sip + c) + g) = *(*(local_sip + b) + j);
#line 767
      g ++;
    }
    while_break___7: /* CIL Label */ ;
    }
#line 708
    i ++;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 773
  if (*(ntree_data->profile + c)) {
#line 774
    if (*(*(ntree_data->map + c) + (*(*(ntree_data->map + c) + 0) + 2)) < *(*(local_map + c) + (*(*(local_map + c) + 0) + 2))) {
      {
#line 775
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%d\n",
              *(*(local_map + c) + (*(*(local_map + c) + 0) + 2)));
#line 777
      i = 0;
      }
      {
#line 777
      while (1) {
        while_continue___8: /* CIL Label */ ;
#line 777
        if (! (i < num - 1)) {
#line 777
          goto while_break___8;
        }
        {
#line 778
        c = *(tree + (i * 3 + 3));
#line 779
        free((void *)*(ntree_data->map + c));
#line 780
        free((void *)*(ntree_data->profile + c));
#line 781
        free((void *)*(aln->sip + c));
#line 782
        tmp___12 = malloc(sizeof(int ) * (unsigned long )(*(*(local_map + c) + 0) + 3));
#line 782
        *(ntree_data->map + c) = (int *)tmp___12;
#line 783
        j = 0;
        }
        {
#line 783
        while (1) {
          while_continue___9: /* CIL Label */ ;
#line 783
          if (! (j < *(*(local_map + c) + 0) + 3)) {
#line 783
            goto while_break___9;
          }
#line 784
          *(*(ntree_data->map + c) + j) = *(*(local_map + c) + j);
#line 783
          j ++;
        }
        while_break___9: /* CIL Label */ ;
        }
        {
#line 786
        tmp___13 = malloc(sizeof(int ) * (unsigned long )*(local_nsip + c));
#line 786
        *(aln->sip + c) = (unsigned int *)tmp___13;
#line 787
        *(aln->nsip + c) = (unsigned int )*(local_nsip + c);
#line 788
        j = 0;
        }
        {
#line 788
        while (1) {
          while_continue___10: /* CIL Label */ ;
#line 788
          if (! (j < *(local_nsip + c))) {
#line 788
            goto while_break___10;
          }
#line 789
          *(*(aln->sip + c) + j) = (unsigned int )*(*(local_sip + c) + j);
#line 788
          j ++;
        }
        while_break___10: /* CIL Label */ ;
        }
#line 791
        *(aln->sl + c) = (unsigned int )*(local_sl + c);
#line 777
        i ++;
      }
      while_break___8: /* CIL Label */ ;
      }
      {
#line 794
      tmp___14 = malloc((sizeof(int ) * 64UL) * (unsigned long )(*(aln->sl + c) + 1U));
#line 794
      *(ntree_data->profile + c) = (float *)tmp___14;
#line 795
      i = 0;
      }
      {
#line 795
      while (1) {
        while_continue___11: /* CIL Label */ ;
#line 795
        if (! ((unsigned int )i < 64U * (*(aln->sl + c) + 1U))) {
#line 795
          goto while_break___11;
        }
#line 796
        *(*(ntree_data->profile + c) + i) = *(*(local_profile + c) + i);
#line 795
        i ++;
      }
      while_break___11: /* CIL Label */ ;
      }
#line 798
      *(ntree_data->tree + 0) -= *(tree + 0) - 1;
#line 799
      j = 1;
      {
#line 799
      while (1) {
        while_continue___12: /* CIL Label */ ;
#line 799
        if (! (j < *(tree + 0))) {
#line 799
          goto while_break___12;
        }
#line 800
        *(ntree_data->tree + ((*(ntree_data->tree + 0) + j) - 1)) = *(tree + j);
#line 799
        j ++;
      }
      while_break___12: /* CIL Label */ ;
      }
#line 802
      *(ntree_data->tree + 0) += *(tree + 0) - 1;
    } else {
      {
#line 805
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"no improvement\n");
      }
    }
  } else {
    {
#line 808
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%d\n",
            *(*(local_map + c) + (*(*(local_map + c) + 0) + 2)));
#line 809
    i = 0;
    }
    {
#line 809
    while (1) {
      while_continue___13: /* CIL Label */ ;
#line 809
      if (! (i < num - 1)) {
#line 809
        goto while_break___13;
      }
      {
#line 810
      c = *(tree + (i * 3 + 3));
#line 811
      tmp___15 = malloc(sizeof(int ) * (unsigned long )(*(*(local_map + c) + 0) + 3));
#line 811
      *(ntree_data->map + c) = (int *)tmp___15;
#line 812
      j = 0;
      }
      {
#line 812
      while (1) {
        while_continue___14: /* CIL Label */ ;
#line 812
        if (! (j < *(*(local_map + c) + 0) + 3)) {
#line 812
          goto while_break___14;
        }
#line 813
        *(*(ntree_data->map + c) + j) = *(*(local_map + c) + j);
#line 812
        j ++;
      }
      while_break___14: /* CIL Label */ ;
      }
      {
#line 816
      tmp___16 = malloc(sizeof(int ) * (unsigned long )*(local_nsip + c));
#line 816
      *(aln->sip + c) = (unsigned int *)tmp___16;
#line 817
      *(aln->nsip + c) = (unsigned int )*(local_nsip + c);
#line 818
      j = 0;
      }
      {
#line 818
      while (1) {
        while_continue___15: /* CIL Label */ ;
#line 818
        if (! (j < *(local_nsip + c))) {
#line 818
          goto while_break___15;
        }
#line 819
        *(*(aln->sip + c) + j) = (unsigned int )*(*(local_sip + c) + j);
#line 818
        j ++;
      }
      while_break___15: /* CIL Label */ ;
      }
#line 821
      *(aln->sl + c) = (unsigned int )*(local_sl + c);
#line 809
      i ++;
    }
    while_break___13: /* CIL Label */ ;
    }
    {
#line 823
    tmp___17 = malloc((sizeof(int ) * 64UL) * (unsigned long )(*(aln->sl + c) + 1U));
#line 823
    *(ntree_data->profile + c) = (float *)tmp___17;
#line 824
    i = 0;
    }
    {
#line 824
    while (1) {
      while_continue___16: /* CIL Label */ ;
#line 824
      if (! ((unsigned int )i < 64U * (*(aln->sl + c) + 1U))) {
#line 824
        goto while_break___16;
      }
#line 825
      *(*(ntree_data->profile + c) + i) = *(*(local_profile + c) + i);
#line 824
      i ++;
    }
    while_break___16: /* CIL Label */ ;
    }
#line 827
    j = 1;
    {
#line 827
    while (1) {
      while_continue___17: /* CIL Label */ ;
#line 827
      if (! (j < *(tree + 0))) {
#line 827
        goto while_break___17;
      }
#line 828
      *(ntree_data->tree + ((*(ntree_data->tree + 0) + j) - 1)) = *(tree + j);
#line 827
      j ++;
    }
    while_break___17: /* CIL Label */ ;
    }
#line 830
    *(ntree_data->tree + 0) += *(tree + 0) - 1;
  }
#line 833
  i = 0;
  {
#line 833
  while (1) {
    while_continue___18: /* CIL Label */ ;
#line 833
    if (! ((unsigned int )i < numprofiles)) {
#line 833
      goto while_break___18;
    }
#line 834
    if (*(which_to_alloc + i) == 1) {
      {
#line 835
      free((void *)*(local_sip + i));
      }
#line 836
      if ((unsigned int )i < numseq) {
        {
#line 837
        free((void *)*(local_profile + i));
        }
      }
    }
#line 840
    if (*(which_to_alloc + i) == 2) {
      {
#line 841
      free((void *)*(local_profile + i));
#line 842
      free((void *)*(local_map + i));
#line 843
      free((void *)*(local_sip + i));
      }
    }
#line 833
    i ++;
  }
  while_break___18: /* CIL Label */ ;
  }
  {
#line 848
  free((void *)which_to_alloc);
#line 849
  free((void *)local_map);
#line 850
  free((void *)local_sip);
#line 851
  free((void *)local_nsip);
#line 852
  free((void *)local_profile);
#line 853
  free((void *)local_sl);
#line 855
  dp_matrix_free(dp);
  }
#line 856
  return (ntree_data);
}
}
#line 859 "/home/june/repo/benchmarks/collector/temp/kalign-2.03+20110620/kalign2_alignment_types.c"
struct ntree_data *ntree_alignment(struct ntree_data *ntree_data ) 
{ 
  int i ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 862
  tmp = malloc(sizeof(float *) * (unsigned long )numprofiles);
#line 862
  ntree_data->profile = (float **)tmp;
#line 863
  i = 0;
  }
  {
#line 863
  while (1) {
    while_continue: /* CIL Label */ ;
#line 863
    if (! ((unsigned int )i < numprofiles)) {
#line 863
      goto while_break;
    }
#line 864
    *(ntree_data->profile + i) = (float *)0;
#line 863
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 867
  tmp___0 = malloc(sizeof(int *) * (unsigned long )numprofiles);
#line 867
  ntree_data->map = (int **)tmp___0;
#line 868
  i = 0;
  }
  {
#line 868
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 868
    if (! ((unsigned int )i < numprofiles)) {
#line 868
      goto while_break___0;
    }
#line 869
    *(ntree_data->map + i) = (int *)0;
#line 868
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 872
  ntree_data = alignntree(ntree_data, ntree_data->realtree);
#line 874
  i = 0;
  }
  {
#line 874
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 874
    if (! ((unsigned int )i < numprofiles)) {
#line 874
      goto while_break___1;
    }
#line 875
    if (*(ntree_data->profile + i)) {
      {
#line 876
      free((void *)*(ntree_data->profile + i));
      }
    }
#line 874
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 879
  free((void *)ntree_data->profile);
#line 881
  i = 32;
  }
  {
#line 881
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 881
    tmp___1 = i;
#line 881
    i --;
#line 881
    if (! tmp___1) {
#line 881
      goto while_break___2;
    }
    {
#line 882
    free((void *)*(ntree_data->submatrix + i));
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 884
  free((void *)ntree_data->submatrix);
#line 885
  free_real_tree(ntree_data->realtree);
  }
#line 886
  return (ntree_data);
}
}
#line 241 "/home/june/repo/benchmarks/collector/temp/kalign-2.03+20110620/kalign2.h"
float *dna_make_profile(float *prof , int *seq , int len , float **subm ) ;
#line 245
float *dna_update(float const   *profa , float const   *profb , float *newp , int *path ,
                  int sipa , int sipb ) ;
#line 246
float *dna_update_only_a(float const   *profa , float const   *profb , float *newp ,
                         int *path , int sipa , int sipb ) ;
#line 250
void dna_set_gap_penalties(float *prof , int len , int nsip , float strength , int nsip_c ) ;
#line 295
float *make_profile2(float *prof , int *seq , int len , float **subm ) ;
#line 296
void set_gap_penalties2(float *prof , int len , int nsip , int window , float strength ) ;
#line 297
float *update2(float const   *profa , float const   *profb , float *newp , int *path ,
               int sipa , int sipb , float internal_gap_weight ) ;
#line 317
float *make_feature_profile(float *prof , struct feature *f , int len , struct feature_matrix *fm ) ;
#line 318
float *feature_update(float const   *profa , float const   *profb , float *newp ,
                      int *path , int stride___0 ) ;
#line 344
float *make_wu_profile(float *prof , float *wu , int len ) ;
#line 380
void smooth_gaps(float *prof , int len , int window , float strength ) ;
#line 401
void increase_gaps(float *prof , int len , int window , float strength ) ;
#line 56 "/home/june/repo/benchmarks/collector/temp/kalign-2.03+20110620/kalign2_profile.c"
float *update2(float const   *profa , float const   *profb , float *newp , int *path ,
               int sipa , int sipb , float internal_gap_weight ) 
{ 
  int i ;
  int c ;
  int *gap_len ;
  int gap_cost ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 59
  gap_len = (int *)0;
#line 60
  gap_cost = 0;
#line 62
  tmp = malloc(sizeof(int ) * (unsigned long )(*(path + 0) + 1));
#line 62
  gap_len = (int *)tmp;
#line 63
  *(gap_len + 0) = 0;
#line 66
  i = 1;
  }
  {
#line 66
  while (1) {
    while_continue: /* CIL Label */ ;
#line 66
    if (! (i <= *(path + 0))) {
#line 66
      goto while_break;
    }
#line 68
    *(gap_len + i) = *(path + i) >> 16;
#line 69
    *(path + i) &= 65535;
#line 66
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 74
  c = 1;
  {
#line 84
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 84
    if (! (*(path + c) != 3)) {
#line 84
      goto while_break___0;
    }
#line 85
    gap_cost = 0;
#line 86
    if (! *(path + c)) {
      {
#line 87
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 87
        if (! *(path + c)) {
#line 87
          if (! (*(path + c) != 3)) {
#line 87
            goto while_break___1;
          }
        } else {
#line 87
          goto while_break___1;
        }
#line 89
        i = 64;
        {
#line 89
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 89
          tmp___0 = i;
#line 89
          i --;
#line 89
          if (! tmp___0) {
#line 89
            goto while_break___2;
          }
#line 90
          *(newp + i) = (float )(*(profa + i) + *(profb + i));
        }
        while_break___2: /* CIL Label */ ;
        }
#line 92
        profa += 64;
#line 93
        profb += 64;
#line 94
        newp += 64;
#line 95
        c ++;
      }
      while_break___1: /* CIL Label */ ;
      }
    } else
#line 97
    if (*(path + c) & 1) {
#line 99
      if (*(path + c) & 128) {
#line 100
        i = 0;
        {
#line 100
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 100
          if (! (i < *(gap_len + c) - 1)) {
#line 100
            goto while_break___3;
          }
#line 101
          gap_cost = (int )((float const   )gap_cost + *(profb + (29 + 64 * i)));
#line 100
          i ++;
        }
        while_break___3: /* CIL Label */ ;
        }
#line 104
        gap_cost = (int )((float const   )gap_cost + *(profb + (27 + 64 * i)));
      } else
#line 106
      if (*(path + c) & 64) {
#line 108
        gap_cost = (int )((float const   )gap_cost + *(profb + 91));
#line 110
        i = 1;
        {
#line 110
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 110
          if (! (i < *(gap_len + c))) {
#line 110
            goto while_break___4;
          }
#line 111
          gap_cost = (int )((float const   )gap_cost + *(profb + (29 + 64 * i)));
#line 110
          i ++;
        }
        while_break___4: /* CIL Label */ ;
        }
      } else {
#line 116
        gap_cost = (int )((float const   )gap_cost + *(profb + 91));
#line 118
        i = 1;
        {
#line 118
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 118
          if (! (i < *(gap_len + c) - 1)) {
#line 118
            goto while_break___5;
          }
#line 119
          gap_cost = (int )((float const   )gap_cost + *(profb + (28 + 64 * i)));
#line 118
          i ++;
        }
        while_break___5: /* CIL Label */ ;
        }
#line 122
        gap_cost = (int )((float const   )gap_cost + *(profb + (27 + 64 * i)));
      }
#line 126
      gap_cost /= *(gap_len + c);
#line 127
      gap_cost = (int )((float )gap_cost * internal_gap_weight);
      {
#line 129
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 129
        if (*(path + c) & 1) {
#line 129
          if (! (*(path + c) != 3)) {
#line 129
            goto while_break___6;
          }
        } else {
#line 129
          goto while_break___6;
        }
#line 131
        i = 64;
        {
#line 131
        while (1) {
          while_continue___7: /* CIL Label */ ;
#line 131
          tmp___1 = i;
#line 131
          i --;
#line 131
          if (! tmp___1) {
#line 131
            goto while_break___7;
          }
#line 132
          *(newp + i) = (float )*(profb + i);
        }
        while_break___7: /* CIL Label */ ;
        }
#line 134
        *(newp + 23) += (float )gap_cost;
#line 135
        i = 32;
        {
#line 135
        while (1) {
          while_continue___8: /* CIL Label */ ;
#line 135
          if (! (i < 55)) {
#line 135
            goto while_break___8;
          }
#line 136
          *(newp + i) += (float )gap_cost;
#line 135
          i ++;
        }
        while_break___8: /* CIL Label */ ;
        }
#line 138
        profb += 64;
#line 139
        newp += 64;
#line 140
        c ++;
      }
      while_break___6: /* CIL Label */ ;
      }
    } else
#line 142
    if (*(path + c) & 2) {
#line 144
      if (*(path + c) & 128) {
#line 145
        i = 0;
        {
#line 145
        while (1) {
          while_continue___9: /* CIL Label */ ;
#line 145
          if (! (i < *(gap_len + c) - 1)) {
#line 145
            goto while_break___9;
          }
#line 146
          gap_cost = (int )((float const   )gap_cost + *(profa + (29 + 64 * i)));
#line 145
          i ++;
        }
        while_break___9: /* CIL Label */ ;
        }
#line 149
        gap_cost = (int )((float const   )gap_cost + *(profa + (27 + 64 * i)));
      } else
#line 151
      if (*(path + c) & 64) {
#line 153
        gap_cost = (int )((float const   )gap_cost + *(profa + 91));
#line 155
        i = 1;
        {
#line 155
        while (1) {
          while_continue___10: /* CIL Label */ ;
#line 155
          if (! (i < *(gap_len + c))) {
#line 155
            goto while_break___10;
          }
#line 156
          gap_cost = (int )((float const   )gap_cost + *(profa + (29 + 64 * i)));
#line 155
          i ++;
        }
        while_break___10: /* CIL Label */ ;
        }
      } else {
#line 161
        gap_cost = (int )((float const   )gap_cost + *(profa + 91));
#line 163
        i = 1;
        {
#line 163
        while (1) {
          while_continue___11: /* CIL Label */ ;
#line 163
          if (! (i < *(gap_len + c) - 1)) {
#line 163
            goto while_break___11;
          }
#line 164
          gap_cost = (int )((float const   )gap_cost + *(profa + (28 + 64 * i)));
#line 163
          i ++;
        }
        while_break___11: /* CIL Label */ ;
        }
#line 167
        gap_cost = (int )((float const   )gap_cost + *(profa + (27 + 64 * i)));
      }
#line 171
      gap_cost /= *(gap_len + c);
#line 173
      gap_cost = (int )((float )gap_cost * internal_gap_weight);
      {
#line 175
      while (1) {
        while_continue___12: /* CIL Label */ ;
#line 175
        if (*(path + c) & 2) {
#line 175
          if (! (*(path + c) != 3)) {
#line 175
            goto while_break___12;
          }
        } else {
#line 175
          goto while_break___12;
        }
#line 177
        i = 64;
        {
#line 177
        while (1) {
          while_continue___13: /* CIL Label */ ;
#line 177
          tmp___2 = i;
#line 177
          i --;
#line 177
          if (! tmp___2) {
#line 177
            goto while_break___13;
          }
#line 178
          *(newp + i) = (float )*(profa + i);
        }
        while_break___13: /* CIL Label */ ;
        }
#line 180
        *(newp + 23) += (float )gap_cost;
#line 181
        i = 32;
        {
#line 181
        while (1) {
          while_continue___14: /* CIL Label */ ;
#line 181
          if (! (i < 55)) {
#line 181
            goto while_break___14;
          }
#line 182
          *(newp + i) += (float )gap_cost;
#line 181
          i ++;
        }
        while_break___14: /* CIL Label */ ;
        }
#line 184
        profa += 64;
#line 185
        newp += 64;
#line 186
        c ++;
      }
      while_break___12: /* CIL Label */ ;
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 190
  i = 64;
  {
#line 190
  while (1) {
    while_continue___15: /* CIL Label */ ;
#line 190
    tmp___3 = i;
#line 190
    i --;
#line 190
    if (! tmp___3) {
#line 190
      goto while_break___15;
    }
#line 191
    *(newp + i) = (float )(*(profa + i) + *(profb + i));
  }
  while_break___15: /* CIL Label */ ;
  }
  {
#line 193
  newp -= *(path + 0) * 64;
#line 195
  free((void *)gap_len);
  }
#line 197
  return (newp);
}
}
#line 201 "/home/june/repo/benchmarks/collector/temp/kalign-2.03+20110620/kalign2_profile.c"
void smooth_gaps(float *prof , int len , int window , float strength ) 
{ 
  float tmp_gpo ;
  float tmp_gpe ;
  float tmp_tgpe ;
  int i ;
  int j ;

  {
#line 207
  if (! (window & 1)) {
#line 208
    window --;
  }
#line 210
  i = window / 2;
  {
#line 210
  while (1) {
    while_continue: /* CIL Label */ ;
#line 210
    if (! (i < len - window / 2)) {
#line 210
      goto while_break;
    }
#line 211
    tmp_gpo = (float )0.0;
#line 212
    tmp_gpe = (float )0.0;
#line 213
    tmp_tgpe = (float )0.0;
#line 214
    j = - (window / 2);
    {
#line 214
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 214
      if (! (j < window / 2)) {
#line 214
        goto while_break___0;
      }
#line 215
      tmp_gpo += *(prof + (27 + (i + j) * 64)) * strength;
#line 216
      tmp_gpe += *(prof + (28 + (i + j) * 64)) * strength;
#line 217
      tmp_tgpe += *(prof + (29 + (i + j) * 64)) * strength;
#line 214
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 219
    tmp_gpo /= (float )window;
#line 220
    tmp_gpe /= (float )window;
#line 221
    tmp_tgpe /= (float )window;
#line 222
    *(prof + (27 + i * 64)) = (float )((double )*(prof + (27 + i * 64)) * (1.0 - (double )strength) + (double )tmp_gpo);
#line 223
    *(prof + (28 + i * 64)) = (float )((double )*(prof + (28 + i * 64)) * (1.0 - (double )strength) + (double )tmp_gpe);
#line 224
    *(prof + (29 + i * 64)) = (float )((double )*(prof + (29 + i * 64)) * (1.0 - (double )strength) + (double )tmp_tgpe);
#line 210
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 226
  return;
}
}
#line 229 "/home/june/repo/benchmarks/collector/temp/kalign-2.03+20110620/kalign2_profile.c"
void increase_gaps(float *prof , int len , int window , float strength ) 
{ 
  float *mod ;
  int i ;
  int j ;
  int c ;
  int start_pos ;
  int end_pos ;
  void *tmp ;
  int tmp___0 ;

  {
  {
#line 231
  mod = (float *)0;
#line 233
  start_pos = 0;
#line 234
  end_pos = 0;
#line 236
  tmp = malloc(sizeof(float ) * (unsigned long )window);
#line 236
  mod = (float *)tmp;
#line 237
  i = 0;
  }
  {
#line 237
  while (1) {
    while_continue: /* CIL Label */ ;
#line 237
    if (! (i < window)) {
#line 237
      goto while_break;
    }
#line 238
    *(mod + i) = (float )((double )(strength - ((float )i * strength) / (float )window) - 0.5 * (double )strength);
#line 237
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 241
  i = 0;
  {
#line 241
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 241
    if (! (i < len)) {
#line 241
      goto while_break___0;
    }
#line 243
    *(prof + 26) = (float )0.0;
#line 244
    prof += 64;
#line 241
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 246
  prof -= len << 6;
#line 250
  i = 0;
  {
#line 250
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 250
    if (! (i < len)) {
#line 250
      goto while_break___1;
    }
#line 252
    if (*(prof + 23) != (float )0) {
#line 254
      start_pos = i - window;
#line 255
      if (start_pos < 0) {
#line 256
        c = start_pos + window;
      } else {
#line 258
        c = window;
      }
#line 261
      j = c;
      {
#line 261
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 261
        tmp___0 = j;
#line 261
        j --;
#line 261
        if (! tmp___0) {
#line 261
          goto while_break___2;
        }
#line 262
        *(prof + (26 - 64 * (j + 1))) += *(mod + j);
      }
      while_break___2: /* CIL Label */ ;
      }
#line 264
      end_pos = i + window;
#line 265
      if (end_pos > len) {
#line 266
        c = len - i;
      } else {
#line 268
        c = window;
      }
#line 271
      j = 0;
      {
#line 271
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 271
        if (! (j < c)) {
#line 271
          goto while_break___3;
        }
#line 272
        *(prof + (26 + 64 * (j + 1))) += *(mod + j);
#line 271
        j ++;
      }
      while_break___3: /* CIL Label */ ;
      }
    }
#line 275
    prof += 64;
#line 250
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 277
  prof -= len << 6;
#line 279
  i = 0;
  {
#line 279
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 279
    if (! (i < len)) {
#line 279
      goto while_break___4;
    }
#line 281
    *(prof + 27) = (float )((double )*(prof + 27) * ((double )*(prof + 26) + 1.0));
#line 282
    *(prof + 28) = (float )((double )*(prof + 28) * ((double )*(prof + 26) + 1.0));
#line 283
    *(prof + 29) = (float )((double )*(prof + 29) * ((double )*(prof + 26) + 1.0));
#line 284
    prof += 64;
#line 279
    i ++;
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 286
  prof -= len << 6;
#line 288
  free((void *)mod);
  }
#line 289
  return;
}
}
#line 292 "/home/june/repo/benchmarks/collector/temp/kalign-2.03+20110620/kalign2_profile.c"
void set_gap_penalties2(float *prof , int len , int nsip , int window , float strength ) 
{ 
  int i ;
  int j ;
  float tmp_gpo ;
  float tmp_gpe ;
  float tmp_tgpe ;
  int tmp ;

  {
#line 299
  prof += 64 * len;
#line 301
  *(prof + 27) = (*(prof + 55) * (float )nsip) * - gpo;
#line 302
  *(prof + 28) = (*(prof + 55) * (float )nsip) * - gpe;
#line 303
  *(prof + 29) = (*(prof + 55) * (float )nsip) * - tgpe;
#line 305
  i = len;
  {
#line 306
  while (1) {
    while_continue: /* CIL Label */ ;
#line 306
    tmp = i;
#line 306
    i --;
#line 306
    if (! tmp) {
#line 306
      goto while_break;
    }
#line 307
    prof -= 64;
#line 308
    *(prof + 27) = (*(prof + 55) * (float )nsip) * - gpo;
#line 309
    *(prof + 28) = (*(prof + 55) * (float )nsip) * - gpe;
#line 311
    *(prof + 29) = (*(prof + 55) * (float )nsip) * - tgpe;
  }
  while_break: /* CIL Label */ ;
  }
#line 313
  if (! (window & 1)) {
#line 314
    window --;
  }
#line 318
  i = window / 2;
  {
#line 318
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 318
    if (! (i < len - window / 2)) {
#line 318
      goto while_break___0;
    }
#line 319
    tmp_gpo = (float )0.0;
#line 320
    tmp_gpe = (float )0.0;
#line 321
    tmp_tgpe = (float )0.0;
#line 322
    j = - (window / 2);
    {
#line 322
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 322
      if (! (j < window / 2)) {
#line 322
        goto while_break___1;
      }
#line 323
      tmp_gpo += *(prof + (27 + (i + j) * 64)) * strength;
#line 324
      tmp_gpe += *(prof + (28 + (i + j) * 64)) * strength;
#line 325
      tmp_tgpe += *(prof + (29 + (i + j) * 64)) * strength;
#line 322
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 327
    tmp_gpo /= (float )window;
#line 328
    tmp_gpe /= (float )window;
#line 329
    tmp_tgpe /= (float )window;
#line 330
    *(prof + (27 + i * 64)) = *(prof + (27 + i * 64)) * ((float )1 - strength) + tmp_gpo;
#line 331
    *(prof + (28 + i * 64)) = *(prof + (28 + i * 64)) * ((float )1 - strength) + tmp_gpe;
#line 332
    *(prof + (29 + i * 64)) = *(prof + (29 + i * 64)) * ((float )1 - strength) + tmp_tgpe;
#line 318
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 345
  return;
}
}
#line 349 "/home/june/repo/benchmarks/collector/temp/kalign-2.03+20110620/kalign2_profile.c"
float *make_profile2(float *prof , int *seq , int len , float **subm ) 
{ 
  int i ;
  int j ;
  int c ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 352
  tmp = malloc((sizeof(float ) * (unsigned long )(len + 1)) * 64UL);
#line 352
  prof = (float *)tmp;
#line 353
  prof += 64 * len;
#line 355
  i = 0;
  }
  {
#line 355
  while (1) {
    while_continue: /* CIL Label */ ;
#line 355
    if (! (i < 64)) {
#line 355
      goto while_break;
    }
#line 356
    *(prof + i) = (float )0;
#line 355
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 358
  *(prof + 55) = (float )1;
#line 360
  i = len;
  {
#line 361
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 361
    tmp___1 = i;
#line 361
    i --;
#line 361
    if (! tmp___1) {
#line 361
      goto while_break___0;
    }
#line 362
    prof -= 64;
#line 364
    j = 0;
    {
#line 364
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 364
      if (! (j < 64)) {
#line 364
        goto while_break___1;
      }
#line 365
      *(prof + j) = (float )0;
#line 364
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 367
    c = *(seq + i);
#line 369
    *(prof + c) += (float )1;
#line 371
    prof += 32;
#line 372
    j = 23;
    {
#line 372
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 372
      tmp___0 = j;
#line 372
      j --;
#line 372
      if (! tmp___0) {
#line 372
        goto while_break___2;
      }
#line 373
      *(prof + j) = *(*(subm + c) + j);
    }
    while_break___2: /* CIL Label */ ;
    }
#line 376
    *(prof + 23) = (float )1;
#line 377
    prof -= 32;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 380
  return (prof);
}
}
#line 384 "/home/june/repo/benchmarks/collector/temp/kalign-2.03+20110620/kalign2_profile.c"
float *feature_update(float const   *profa , float const   *profb , float *newp ,
                      int *path , int stride___0 ) 
{ 
  int i ;
  int c ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 387
  c = 1;
  {
#line 388
  while (1) {
    while_continue: /* CIL Label */ ;
#line 388
    if (! (*(path + c) != 3)) {
#line 388
      goto while_break;
    }
#line 389
    if (! *(path + c)) {
#line 390
      i = stride___0;
      {
#line 390
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 390
        tmp = i;
#line 390
        i --;
#line 390
        if (! tmp) {
#line 390
          goto while_break___0;
        }
#line 391
        *(newp + i) = (float )(*(profa + i) + *(profb + i));
      }
      while_break___0: /* CIL Label */ ;
      }
#line 393
      profa += stride___0;
#line 394
      profb += stride___0;
    }
#line 396
    if (*(path + c) & 1) {
#line 397
      i = stride___0;
      {
#line 397
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 397
        tmp___0 = i;
#line 397
        i --;
#line 397
        if (! tmp___0) {
#line 397
          goto while_break___1;
        }
#line 398
        *(newp + i) = (float )*(profb + i);
      }
      while_break___1: /* CIL Label */ ;
      }
#line 400
      profb += stride___0;
    }
#line 403
    if (*(path + c) & 2) {
#line 404
      i = stride___0;
      {
#line 404
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 404
        tmp___1 = i;
#line 404
        i --;
#line 404
        if (! tmp___1) {
#line 404
          goto while_break___2;
        }
#line 405
        *(newp + i) = (float )*(profa + i);
      }
      while_break___2: /* CIL Label */ ;
      }
#line 407
      profa += stride___0;
    }
#line 409
    newp += stride___0;
#line 410
    c ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 412
  i = stride___0;
  {
#line 412
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 412
    tmp___2 = i;
#line 412
    i --;
#line 412
    if (! tmp___2) {
#line 412
      goto while_break___3;
    }
#line 413
    *(newp + i) = (float )(*(profa + i) + *(profb + i));
  }
  while_break___3: /* CIL Label */ ;
  }
#line 415
  newp -= *(path + 0) * stride___0;
#line 416
  return (newp);
}
}
#line 419 "/home/june/repo/benchmarks/collector/temp/kalign-2.03+20110620/kalign2_profile.c"
float *make_wu_profile(float *prof , float *wu , int len ) 
{ 
  int i ;
  void *tmp ;

  {
  {
#line 424
  tmp = malloc((sizeof(float ) * (unsigned long )(len + 1)) * 2UL);
#line 424
  prof = (float *)tmp;
#line 427
  i = 0;
  }
  {
#line 427
  while (1) {
    while_continue: /* CIL Label */ ;
#line 427
    if (! (i < (len + 1) * 2)) {
#line 427
      goto while_break;
    }
#line 428
    *(prof + i) = (float )0;
#line 427
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 430
  i = 0;
  {
#line 430
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 430
    if (! (i < len)) {
#line 430
      goto while_break___0;
    }
#line 431
    if (! *(wu + i)) {
#line 432
      *(prof + (i << 1)) = (float )1;
#line 433
      *(prof + ((i << 1) + 1)) = (float )1;
    } else {
#line 436
      *(prof + (i << 1)) = *(wu + i) + (float )1;
#line 437
      *(prof + ((i << 1) + 1)) = *(wu + i) + (float )1;
    }
#line 430
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 440
  return (prof);
}
}
#line 444 "/home/june/repo/benchmarks/collector/temp/kalign-2.03+20110620/kalign2_profile.c"
float *make_feature_profile(float *prof , struct feature *f , int len , struct feature_matrix *fm ) 
{ 
  int i ;
  int j ;
  void *tmp ;

  {
  {
#line 449
  tmp = malloc((sizeof(int ) * (unsigned long )(len + 1)) * (unsigned long )fm->stride);
#line 449
  prof = (float *)tmp;
#line 452
  i = 0;
  }
  {
#line 452
  while (1) {
    while_continue: /* CIL Label */ ;
#line 452
    if (! (i < (len + 1) * fm->stride)) {
#line 452
      goto while_break;
    }
#line 453
    *(prof + i) = (float )0;
#line 452
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 456
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 456
    if (! f) {
#line 456
      goto while_break___0;
    }
#line 457
    if (f->color != -1) {
#line 458
      if (f->start < len) {
#line 458
        if (f->end < len) {
#line 459
          i = f->start - 1;
          {
#line 459
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 459
            if (! (i < f->end)) {
#line 459
              goto while_break___1;
            }
#line 460
            *(prof + (i * fm->stride + f->color)) += (float )1;
#line 461
            j = fm->mdim;
            {
#line 461
            while (1) {
              while_continue___2: /* CIL Label */ ;
#line 461
              if (! (j < fm->stride)) {
#line 461
                goto while_break___2;
              }
#line 462
              *(prof + (i * fm->stride + j)) += *(*(fm->m + f->color) + (j - fm->mdim));
#line 461
              j ++;
            }
            while_break___2: /* CIL Label */ ;
            }
#line 459
            i ++;
          }
          while_break___1: /* CIL Label */ ;
          }
        }
      }
    }
#line 467
    f = f->next;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 469
  return (prof);
}
}
#line 474 "/home/june/repo/benchmarks/collector/temp/kalign-2.03+20110620/kalign2_profile.c"
float *make_profile(float *prof , int *seq , int len , float **subm ) 
{ 
  int i ;
  int j ;
  int c ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 477
  tmp = malloc((sizeof(float ) * (unsigned long )(len + 2)) * 64UL);
#line 477
  prof = (float *)tmp;
#line 478
  prof += 64 * (len + 1);
#line 480
  i = 0;
  }
  {
#line 480
  while (1) {
    while_continue: /* CIL Label */ ;
#line 480
    if (! (i < 64)) {
#line 480
      goto while_break;
    }
#line 481
    *(prof + i) = (float )0;
#line 480
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 483
  *(prof + 55) = - gpo;
#line 484
  *(prof + 56) = - gpe;
#line 485
  *(prof + 57) = - tgpe;
#line 488
  i = len;
  {
#line 489
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 489
    tmp___1 = i;
#line 489
    i --;
#line 489
    if (! tmp___1) {
#line 489
      goto while_break___0;
    }
#line 490
    prof -= 64;
#line 492
    j = 0;
    {
#line 492
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 492
      if (! (j < 64)) {
#line 492
        goto while_break___1;
      }
#line 493
      *(prof + j) = (float )0;
#line 492
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 495
    c = *(seq + i);
#line 497
    *(prof + c) += (float )1;
#line 499
    prof += 32;
#line 501
    j = 23;
    {
#line 501
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 501
      tmp___0 = j;
#line 501
      j --;
#line 501
      if (! tmp___0) {
#line 501
        goto while_break___2;
      }
#line 502
      *(prof + j) = *(*(subm + c) + j);
    }
    while_break___2: /* CIL Label */ ;
    }
#line 504
    *(prof + 23) = - gpo;
#line 505
    *(prof + 24) = - gpe;
#line 506
    *(prof + 25) = - tgpe;
#line 508
    prof -= 32;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 510
  prof -= 64;
#line 511
  i = 0;
  {
#line 511
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 511
    if (! (i < 64)) {
#line 511
      goto while_break___3;
    }
#line 512
    *(prof + i) = (float )0;
#line 511
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 514
  *(prof + 55) = - gpo;
#line 515
  *(prof + 56) = - gpe;
#line 516
  *(prof + 57) = - tgpe;
#line 517
  return (prof);
}
}
#line 520 "/home/june/repo/benchmarks/collector/temp/kalign-2.03+20110620/kalign2_profile.c"
float *dna_make_profile(float *prof , int *seq , int len , float **subm ) 
{ 
  int i ;
  int j ;
  int c ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 524
  tmp = malloc((sizeof(float ) * (unsigned long )(len + 2)) * 22UL);
#line 524
  prof = (float *)tmp;
#line 525
  prof += 22 * (len + 1);
#line 528
  i = 0;
  }
  {
#line 528
  while (1) {
    while_continue: /* CIL Label */ ;
#line 528
    if (! (i < 22)) {
#line 528
      goto while_break;
    }
#line 529
    *(prof + i) = (float )0;
#line 528
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 531
  *(prof + 16) = - gpo;
#line 532
  *(prof + 17) = - gpe;
#line 533
  *(prof + 18) = - tgpe;
#line 536
  i = len;
  {
#line 537
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 537
    tmp___1 = i;
#line 537
    i --;
#line 537
    if (! tmp___1) {
#line 537
      goto while_break___0;
    }
#line 538
    prof -= 22;
#line 541
    j = 0;
    {
#line 541
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 541
      if (! (j < 22)) {
#line 541
        goto while_break___1;
      }
#line 542
      *(prof + j) = (float )0;
#line 541
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 544
    c = *(seq + i);
#line 546
    *(prof + c) += (float )1;
#line 551
    prof += 11;
#line 552
    j = 5;
    {
#line 552
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 552
      tmp___0 = j;
#line 552
      j --;
#line 552
      if (! tmp___0) {
#line 552
        goto while_break___2;
      }
#line 553
      *(prof + j) = *(*(subm + c) + j);
    }
    while_break___2: /* CIL Label */ ;
    }
#line 555
    *(prof + 5) = - gpo;
#line 556
    *(prof + 6) = - gpe;
#line 557
    *(prof + 7) = - tgpe;
#line 558
    prof -= 11;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 560
  prof -= 22;
#line 561
  i = 0;
  {
#line 561
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 561
    if (! (i < 22)) {
#line 561
      goto while_break___3;
    }
#line 562
    *(prof + i) = (float )0;
#line 561
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 564
  *(prof + 16) = - gpo;
#line 565
  *(prof + 17) = - gpe;
#line 566
  *(prof + 18) = - tgpe;
#line 568
  return (prof);
}
}
#line 574 "/home/june/repo/benchmarks/collector/temp/kalign-2.03+20110620/kalign2_profile.c"
float *update(float const   *profa , float const   *profb , float *newp , int *path ,
              int sipa , int sipb ) 
{ 
  int i ;
  int j ;
  int c ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 577
  i = 64;
  {
#line 577
  while (1) {
    while_continue: /* CIL Label */ ;
#line 577
    tmp = i;
#line 577
    i --;
#line 577
    if (! tmp) {
#line 577
      goto while_break;
    }
#line 578
    *(newp + i) = (float )(*(profa + i) + *(profb + i));
  }
  while_break: /* CIL Label */ ;
  }
#line 581
  profa += 64;
#line 582
  profb += 64;
#line 583
  newp += 64;
#line 585
  c = 1;
  {
#line 587
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 587
    if (! (*(path + c) != 3)) {
#line 587
      goto while_break___0;
    }
#line 594
    if (! *(path + c)) {
#line 596
      i = 64;
      {
#line 596
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 596
        tmp___0 = i;
#line 596
        i --;
#line 596
        if (! tmp___0) {
#line 596
          goto while_break___1;
        }
#line 597
        *(newp + i) = (float )(*(profa + i) + *(profb + i));
      }
      while_break___1: /* CIL Label */ ;
      }
#line 601
      profa += 64;
#line 602
      profb += 64;
    }
#line 605
    if (*(path + c) & 1) {
#line 608
      i = 64;
      {
#line 608
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 608
        tmp___1 = i;
#line 608
        i --;
#line 608
        if (! tmp___1) {
#line 608
          goto while_break___2;
        }
#line 609
        *(newp + i) = (float )*(profb + i);
      }
      while_break___2: /* CIL Label */ ;
      }
#line 611
      profb += 64;
#line 613
      if (! (*(path + c) & 20)) {
#line 614
        if (*(path + c) & 32) {
#line 615
          *(newp + 25) += (float )sipa;
#line 616
          i = (int )(tgpe * (float )sipa);
        } else {
#line 618
          *(newp + 24) += (float )sipa;
#line 619
          i = (int )(gpe * (float )sipa);
        }
#line 622
        j = 32;
        {
#line 622
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 622
          if (! (j < 55)) {
#line 622
            goto while_break___3;
          }
#line 623
          *(newp + j) -= (float )i;
#line 622
          j ++;
        }
        while_break___3: /* CIL Label */ ;
        }
      } else {
#line 626
        if (*(path + c) & 16) {
#line 628
          if (*(path + c) & 32) {
#line 629
            *(newp + 25) += (float )sipa;
#line 630
            i = (int )(tgpe * (float )sipa);
#line 631
            *(newp + 23) += (float )sipa;
#line 632
            i = (int )((float )i + gpo * (float )sipa);
          } else {
#line 634
            *(newp + 23) += (float )sipa;
#line 635
            i = (int )(gpo * (float )sipa);
          }
#line 638
          j = 32;
          {
#line 638
          while (1) {
            while_continue___4: /* CIL Label */ ;
#line 638
            if (! (j < 55)) {
#line 638
              goto while_break___4;
            }
#line 639
            *(newp + j) -= (float )i;
#line 638
            j ++;
          }
          while_break___4: /* CIL Label */ ;
          }
        }
#line 642
        if (*(path + c) & 4) {
#line 644
          if (*(path + c) & 32) {
#line 645
            *(newp + 25) += (float )sipa;
#line 646
            i = (int )(tgpe * (float )sipa);
#line 647
            *(newp + 23) += (float )sipa;
#line 648
            i = (int )((float )i + gpo * (float )sipa);
          } else {
#line 650
            *(newp + 23) += (float )sipa;
#line 651
            i = (int )(gpo * (float )sipa);
          }
#line 653
          j = 32;
          {
#line 653
          while (1) {
            while_continue___5: /* CIL Label */ ;
#line 653
            if (! (j < 55)) {
#line 653
              goto while_break___5;
            }
#line 654
            *(newp + j) -= (float )i;
#line 653
            j ++;
          }
          while_break___5: /* CIL Label */ ;
          }
        }
      }
    }
#line 662
    if (*(path + c) & 2) {
#line 665
      i = 64;
      {
#line 665
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 665
        tmp___2 = i;
#line 665
        i --;
#line 665
        if (! tmp___2) {
#line 665
          goto while_break___6;
        }
#line 666
        *(newp + i) = (float )*(profa + i);
      }
      while_break___6: /* CIL Label */ ;
      }
#line 668
      profa += 64;
#line 670
      if (! (*(path + c) & 20)) {
#line 671
        if (*(path + c) & 32) {
#line 672
          *(newp + 25) += (float )sipb;
#line 673
          i = (int )(tgpe * (float )sipb);
        } else {
#line 675
          *(newp + 24) += (float )sipb;
#line 676
          i = (int )(gpe * (float )sipb);
        }
#line 678
        j = 32;
        {
#line 678
        while (1) {
          while_continue___7: /* CIL Label */ ;
#line 678
          if (! (j < 55)) {
#line 678
            goto while_break___7;
          }
#line 679
          *(newp + j) -= (float )i;
#line 678
          j ++;
        }
        while_break___7: /* CIL Label */ ;
        }
      } else {
#line 682
        if (*(path + c) & 16) {
#line 684
          if (*(path + c) & 32) {
#line 685
            *(newp + 25) += (float )sipb;
#line 686
            i = (int )(tgpe * (float )sipb);
#line 687
            *(newp + 23) += (float )sipb;
#line 688
            i = (int )((float )i + gpo * (float )sipb);
          } else {
#line 690
            *(newp + 23) += (float )sipb;
#line 691
            i = (int )(gpo * (float )sipb);
          }
#line 693
          j = 32;
          {
#line 693
          while (1) {
            while_continue___8: /* CIL Label */ ;
#line 693
            if (! (j < 55)) {
#line 693
              goto while_break___8;
            }
#line 694
            *(newp + j) -= (float )i;
#line 693
            j ++;
          }
          while_break___8: /* CIL Label */ ;
          }
        }
#line 697
        if (*(path + c) & 4) {
#line 699
          if (*(path + c) & 32) {
#line 700
            *(newp + 25) += (float )sipb;
#line 701
            i = (int )(tgpe * (float )sipb);
#line 702
            *(newp + 23) += (float )sipb;
#line 703
            i = (int )((float )i + gpo * (float )sipb);
          } else {
#line 705
            *(newp + 23) += (float )sipb;
#line 706
            i = (int )(gpo * (float )sipb);
          }
#line 709
          j = 32;
          {
#line 709
          while (1) {
            while_continue___9: /* CIL Label */ ;
#line 709
            if (! (j < 55)) {
#line 709
              goto while_break___9;
            }
#line 710
            *(newp + j) -= (float )i;
#line 709
            j ++;
          }
          while_break___9: /* CIL Label */ ;
          }
        }
      }
    }
#line 717
    newp += 64;
#line 718
    c ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 720
  i = 64;
  {
#line 720
  while (1) {
    while_continue___10: /* CIL Label */ ;
#line 720
    tmp___3 = i;
#line 720
    i --;
#line 720
    if (! tmp___3) {
#line 720
      goto while_break___10;
    }
#line 721
    *(newp + i) = (float )(*(profa + i) + *(profb + i));
  }
  while_break___10: /* CIL Label */ ;
  }
#line 723
  newp -= (*(path + 0) + 1) * 64;
#line 724
  return (newp);
}
}
#line 728 "/home/june/repo/benchmarks/collector/temp/kalign-2.03+20110620/kalign2_profile.c"
float *update_only_a(float const   *profa , float const   *profb , float *newp , int *path ,
                     int sipa , int sipb ) 
{ 
  int i ;
  int c ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 731
  i = 64;
  {
#line 731
  while (1) {
    while_continue: /* CIL Label */ ;
#line 731
    tmp = i;
#line 731
    i --;
#line 731
    if (! tmp) {
#line 731
      goto while_break;
    }
#line 732
    *(newp + i) = (float )*(profa + i);
  }
  while_break: /* CIL Label */ ;
  }
#line 735
  profa += 64;
#line 736
  profb += 64;
#line 737
  newp += 64;
#line 739
  c = 1;
  {
#line 741
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 741
    if (! (*(path + c) != 3)) {
#line 741
      goto while_break___0;
    }
#line 748
    if (! *(path + c)) {
#line 750
      i = 64;
      {
#line 750
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 750
        tmp___0 = i;
#line 750
        i --;
#line 750
        if (! tmp___0) {
#line 750
          goto while_break___1;
        }
#line 751
        *(newp + i) = (float )*(profa + i);
      }
      while_break___1: /* CIL Label */ ;
      }
#line 755
      profa += 64;
#line 756
      profb += 64;
    }
#line 759
    if (*(path + c) & 1) {
#line 762
      i = 64;
      {
#line 762
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 762
        tmp___1 = i;
#line 762
        i --;
#line 762
        if (! tmp___1) {
#line 762
          goto while_break___2;
        }
#line 763
        *(newp + i) = (float )0.0;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 765
      profb += 64;
    }
#line 767
    if (*(path + c) & 2) {
#line 770
      i = 64;
      {
#line 770
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 770
        tmp___2 = i;
#line 770
        i --;
#line 770
        if (! tmp___2) {
#line 770
          goto while_break___3;
        }
#line 771
        *(newp + i) = (float )*(profa + i);
      }
      while_break___3: /* CIL Label */ ;
      }
#line 773
      profa += 64;
    }
#line 776
    newp += 64;
#line 777
    c ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 779
  i = 64;
  {
#line 779
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 779
    tmp___3 = i;
#line 779
    i --;
#line 779
    if (! tmp___3) {
#line 779
      goto while_break___4;
    }
#line 780
    *(newp + i) = (float )*(profa + i);
  }
  while_break___4: /* CIL Label */ ;
  }
#line 782
  newp -= (*(path + 0) + 1) * 64;
#line 783
  return (newp);
}
}
#line 788 "/home/june/repo/benchmarks/collector/temp/kalign-2.03+20110620/kalign2_profile.c"
float *dna_update(float const   *profa , float const   *profb , float *newp , int *path ,
                  int sipa , int sipb ) 
{ 
  int i ;
  int j ;
  int c ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 792
  i = 22;
  {
#line 792
  while (1) {
    while_continue: /* CIL Label */ ;
#line 792
    tmp = i;
#line 792
    i --;
#line 792
    if (! tmp) {
#line 792
      goto while_break;
    }
#line 793
    *(newp + i) = (float )(*(profa + i) + *(profb + i));
  }
  while_break: /* CIL Label */ ;
  }
#line 796
  profa += 22;
#line 797
  profb += 22;
#line 798
  newp += 22;
#line 801
  c = 1;
  {
#line 802
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 802
    if (! (*(path + c) != 3)) {
#line 802
      goto while_break___0;
    }
#line 809
    if (! *(path + c)) {
#line 811
      i = 22;
      {
#line 811
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 811
        tmp___0 = i;
#line 811
        i --;
#line 811
        if (! tmp___0) {
#line 811
          goto while_break___1;
        }
#line 812
        *(newp + i) = (float )(*(profa + i) + *(profb + i));
      }
      while_break___1: /* CIL Label */ ;
      }
#line 816
      profa += 22;
#line 817
      profb += 22;
    }
#line 819
    if (*(path + c) & 1) {
#line 822
      i = 22;
      {
#line 822
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 822
        tmp___1 = i;
#line 822
        i --;
#line 822
        if (! tmp___1) {
#line 822
          goto while_break___2;
        }
#line 823
        *(newp + i) = (float )*(profb + i);
      }
      while_break___2: /* CIL Label */ ;
      }
#line 825
      profb += 22;
#line 826
      if (! (*(path + c) & 20)) {
#line 827
        if (*(path + c) & 32) {
#line 828
          *(newp + 7) += (float )sipa;
#line 829
          i = (int )(tgpe * (float )sipa);
        } else {
#line 831
          *(newp + 6) += (float )sipa;
#line 832
          i = (int )(gpe * (float )sipa);
        }
#line 835
        j = 11;
        {
#line 835
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 835
          if (! (j < 16)) {
#line 835
            goto while_break___3;
          }
#line 836
          *(newp + j) -= (float )i;
#line 835
          j ++;
        }
        while_break___3: /* CIL Label */ ;
        }
      } else {
#line 839
        if (*(path + c) & 16) {
#line 841
          if (*(path + c) & 32) {
#line 842
            *(newp + 7) += (float )sipa;
#line 843
            i = (int )(tgpe * (float )sipa);
#line 844
            *(newp + 5) += (float )sipa;
#line 845
            i = (int )((float )i + gpo * (float )sipa);
          } else {
#line 847
            *(newp + 5) += (float )sipa;
#line 848
            i = (int )(gpo * (float )sipa);
          }
#line 851
          j = 11;
          {
#line 851
          while (1) {
            while_continue___4: /* CIL Label */ ;
#line 851
            if (! (j < 16)) {
#line 851
              goto while_break___4;
            }
#line 852
            *(newp + j) -= (float )i;
#line 851
            j ++;
          }
          while_break___4: /* CIL Label */ ;
          }
        }
#line 855
        if (*(path + c) & 4) {
#line 857
          if (*(path + c) & 32) {
#line 858
            *(newp + 7) += (float )sipa;
#line 859
            i = (int )(tgpe * (float )sipa);
#line 860
            *(newp + 5) += (float )sipa;
#line 861
            i = (int )((float )i + gpo * (float )sipa);
          } else {
#line 863
            *(newp + 5) += (float )sipa;
#line 864
            i = (int )(gpo * (float )sipa);
          }
#line 866
          j = 11;
          {
#line 866
          while (1) {
            while_continue___5: /* CIL Label */ ;
#line 866
            if (! (j < 16)) {
#line 866
              goto while_break___5;
            }
#line 867
            *(newp + j) -= (float )i;
#line 866
            j ++;
          }
          while_break___5: /* CIL Label */ ;
          }
        }
      }
    }
#line 874
    if (*(path + c) & 2) {
#line 877
      i = 22;
      {
#line 877
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 877
        tmp___2 = i;
#line 877
        i --;
#line 877
        if (! tmp___2) {
#line 877
          goto while_break___6;
        }
#line 878
        *(newp + i) = (float )*(profa + i);
      }
      while_break___6: /* CIL Label */ ;
      }
#line 880
      profa += 22;
#line 881
      if (! (*(path + c) & 20)) {
#line 882
        if (*(path + c) & 32) {
#line 883
          *(newp + 7) += (float )sipb;
#line 884
          i = (int )(tgpe * (float )sipb);
        } else {
#line 886
          *(newp + 6) += (float )sipb;
#line 887
          i = (int )(gpe * (float )sipb);
        }
#line 889
        j = 11;
        {
#line 889
        while (1) {
          while_continue___7: /* CIL Label */ ;
#line 889
          if (! (j < 16)) {
#line 889
            goto while_break___7;
          }
#line 890
          *(newp + j) -= (float )i;
#line 889
          j ++;
        }
        while_break___7: /* CIL Label */ ;
        }
      } else {
#line 893
        if (*(path + c) & 16) {
#line 895
          if (*(path + c) & 32) {
#line 896
            *(newp + 7) += (float )sipb;
#line 897
            i = (int )(tgpe * (float )sipb);
#line 898
            *(newp + 5) += (float )sipb;
#line 899
            i = (int )((float )i + gpo * (float )sipb);
          } else {
#line 901
            *(newp + 5) += (float )sipb;
#line 902
            i = (int )(gpo * (float )sipb);
          }
#line 904
          j = 11;
          {
#line 904
          while (1) {
            while_continue___8: /* CIL Label */ ;
#line 904
            if (! (j < 16)) {
#line 904
              goto while_break___8;
            }
#line 905
            *(newp + j) -= (float )i;
#line 904
            j ++;
          }
          while_break___8: /* CIL Label */ ;
          }
        }
#line 908
        if (*(path + c) & 4) {
#line 910
          if (*(path + c) & 32) {
#line 911
            *(newp + 7) += (float )sipb;
#line 912
            i = (int )(tgpe * (float )sipb);
#line 913
            *(newp + 5) += (float )sipb;
#line 914
            i = (int )((float )i + gpo * (float )sipb);
          } else {
#line 916
            *(newp + 5) += (float )sipb;
#line 917
            i = (int )(gpo * (float )sipb);
          }
#line 920
          j = 11;
          {
#line 920
          while (1) {
            while_continue___9: /* CIL Label */ ;
#line 920
            if (! (j < 16)) {
#line 920
              goto while_break___9;
            }
#line 921
            *(newp + j) -= (float )i;
#line 920
            j ++;
          }
          while_break___9: /* CIL Label */ ;
          }
        }
      }
    }
#line 927
    newp += 22;
#line 928
    c ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 930
  i = 22;
  {
#line 930
  while (1) {
    while_continue___10: /* CIL Label */ ;
#line 930
    tmp___3 = i;
#line 930
    i --;
#line 930
    if (! tmp___3) {
#line 930
      goto while_break___10;
    }
#line 931
    *(newp + i) = (float )(*(profa + i) + *(profb + i));
  }
  while_break___10: /* CIL Label */ ;
  }
#line 933
  newp -= (*(path + 0) + 1) * 22;
#line 934
  return (newp);
}
}
#line 938 "/home/june/repo/benchmarks/collector/temp/kalign-2.03+20110620/kalign2_profile.c"
float *dna_update_only_a(float const   *profa , float const   *profb , float *newp ,
                         int *path , int sipa , int sipb ) 
{ 
  int i ;
  int c ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 942
  i = 22;
  {
#line 942
  while (1) {
    while_continue: /* CIL Label */ ;
#line 942
    tmp = i;
#line 942
    i --;
#line 942
    if (! tmp) {
#line 942
      goto while_break;
    }
#line 943
    *(newp + i) = (float )*(profa + i);
  }
  while_break: /* CIL Label */ ;
  }
#line 946
  profa += 22;
#line 947
  profb += 22;
#line 948
  newp += 22;
#line 951
  c = 1;
  {
#line 952
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 952
    if (! (*(path + c) != 3)) {
#line 952
      goto while_break___0;
    }
#line 959
    if (! *(path + c)) {
#line 961
      i = 22;
      {
#line 961
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 961
        tmp___0 = i;
#line 961
        i --;
#line 961
        if (! tmp___0) {
#line 961
          goto while_break___1;
        }
#line 962
        *(newp + i) = (float )*(profa + i);
      }
      while_break___1: /* CIL Label */ ;
      }
#line 966
      profa += 22;
#line 967
      profb += 22;
    }
#line 969
    if (*(path + c) & 1) {
#line 972
      i = 22;
      {
#line 972
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 972
        tmp___1 = i;
#line 972
        i --;
#line 972
        if (! tmp___1) {
#line 972
          goto while_break___2;
        }
#line 973
        *(newp + i) = 0.0f;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 975
      profb += 22;
#line 976
      *(newp + 5) = (float )1000000;
#line 977
      *(newp + 6) = (float )1000000;
#line 978
      *(newp + 7) = (float )1000000;
    }
#line 980
    if (*(path + c) & 2) {
#line 983
      i = 22;
      {
#line 983
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 983
        tmp___2 = i;
#line 983
        i --;
#line 983
        if (! tmp___2) {
#line 983
          goto while_break___3;
        }
#line 984
        *(newp + i) = (float )*(profa + i);
      }
      while_break___3: /* CIL Label */ ;
      }
#line 986
      profa += 22;
    }
#line 988
    newp += 22;
#line 989
    c ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 991
  i = 22;
  {
#line 991
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 991
    tmp___3 = i;
#line 991
    i --;
#line 991
    if (! tmp___3) {
#line 991
      goto while_break___4;
    }
#line 992
    *(newp + i) = (float )*(profa + i);
  }
  while_break___4: /* CIL Label */ ;
  }
#line 994
  newp -= (*(path + 0) + 1) * 22;
#line 995
  return (newp);
}
}
#line 999 "/home/june/repo/benchmarks/collector/temp/kalign-2.03+20110620/kalign2_profile.c"
void dna_set_gap_penalties(float *prof , int len , int nsip , float strength , int nsip_c ) 
{ 
  int i ;
  int j ;
  float res ;
  float local_res ;
  float w ;
  int tmp ;

  {
#line 1003
  res = (float )nsip_c;
#line 1004
  local_res = (float )0;
#line 1005
  w = (float )0.0;
#line 1006
  prof += 22 * (len + 1);
#line 1008
  local_res = (float )0;
#line 1009
  j = 0;
  {
#line 1009
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1009
    if (! (j < 5)) {
#line 1009
      goto while_break;
    }
#line 1010
    local_res += *(prof + j);
#line 1009
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1013
  w = (float )(1.0 + (((double )local_res - 1.0) / (double )res) * (double )strength);
#line 1015
  *(prof + 8) = (*(prof + 16) * (float )nsip) * w;
#line 1016
  *(prof + 9) = (*(prof + 17) * (float )nsip) * w;
#line 1017
  *(prof + 10) = (*(prof + 18) * (float )nsip) * w;
#line 1022
  i = len + 1;
  {
#line 1023
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1023
    tmp = i;
#line 1023
    i --;
#line 1023
    if (! tmp) {
#line 1023
      goto while_break___0;
    }
#line 1024
    prof -= 22;
#line 1025
    local_res = (float )0;
#line 1026
    j = 0;
    {
#line 1026
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1026
      if (! (j < 5)) {
#line 1026
        goto while_break___1;
      }
#line 1027
      local_res += *(prof + j);
#line 1026
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1031
    w = (float )(1.0 + (((double )local_res - 1.0) / (double )res) * (double )strength);
#line 1033
    *(prof + 8) = (*(prof + 16) * (float )nsip) * w;
#line 1034
    *(prof + 9) = (*(prof + 17) * (float )nsip) * w;
#line 1036
    *(prof + 10) = (*(prof + 18) * (float )nsip) * w;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1039
  return;
}
}
#line 1041 "/home/june/repo/benchmarks/collector/temp/kalign-2.03+20110620/kalign2_profile.c"
void set_gap_penalties(float *prof , int len , int nsip , float strength , int nsip_c ) 
{ 
  int i ;
  int j ;
  float res ;
  float local_res ;
  float w ;
  int tmp ;

  {
#line 1045
  res = (float )nsip_c;
#line 1046
  local_res = (float )0;
#line 1047
  w = (float )0.0;
#line 1049
  prof += 64 * (len + 1);
#line 1052
  local_res = (float )0;
#line 1053
  j = 0;
  {
#line 1053
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1053
    if (! (j < 23)) {
#line 1053
      goto while_break;
    }
#line 1054
    local_res += *(prof + j);
#line 1053
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1058
  w = (float )(1.0 + (((double )local_res - 1.0) / (double )res) * (double )strength);
#line 1060
  *(prof + 27) = (*(prof + 55) * (float )nsip) * w;
#line 1061
  *(prof + 28) = (*(prof + 56) * (float )nsip) * w;
#line 1063
  *(prof + 29) = (*(prof + 57) * (float )nsip) * w;
#line 1064
  i = len + 1;
  {
#line 1065
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1065
    tmp = i;
#line 1065
    i --;
#line 1065
    if (! tmp) {
#line 1065
      goto while_break___0;
    }
#line 1066
    prof -= 64;
#line 1068
    local_res = (float )0;
#line 1069
    j = 0;
    {
#line 1069
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1069
      if (! (j < 23)) {
#line 1069
        goto while_break___1;
      }
#line 1070
      local_res += *(prof + j);
#line 1069
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1074
    w = (float )(1.0 + (((double )local_res - 1.0) / (double )res) * (double )strength);
#line 1076
    *(prof + 27) = (*(prof + 55) * (float )nsip) * w;
#line 1077
    *(prof + 28) = (*(prof + 56) * (float )nsip) * w;
#line 1079
    *(prof + 29) = (*(prof + 57) * (float )nsip) * w;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1081
  return;
}
}
#line 288 "/home/june/repo/benchmarks/collector/temp/kalign-2.03+20110620/kalign2.h"
void free_ft(struct feature *n ) ;
#line 28 "/home/june/repo/benchmarks/collector/temp/kalign-2.03+20110620/kalign2_mem.c"
void freesimpletree(struct tree_node *p ) 
{ 


  {
#line 30
  if (p->left) {
    {
#line 31
    freesimpletree(p->left);
    }
  }
#line 33
  if (p->right) {
    {
#line 34
    freesimpletree(p->right);
    }
  }
  {
#line 36
  free((void *)p);
  }
#line 37
  return;
}
}
#line 39 "/home/june/repo/benchmarks/collector/temp/kalign-2.03+20110620/kalign2_mem.c"
void free_real_tree(struct aln_tree_node *p ) 
{ 
  int i ;

  {
#line 41
  i = 0;
  {
#line 42
  while (1) {
    while_continue: /* CIL Label */ ;
#line 42
    if (! *(p->links + i)) {
#line 42
      goto while_break;
    }
    {
#line 43
    free_real_tree(*(p->links + i));
#line 44
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 46
  free((void *)p->internal_lables);
#line 47
  free((void *)p->links);
#line 48
  free((void *)p);
  }
#line 49
  return;
}
}
#line 52 "/home/june/repo/benchmarks/collector/temp/kalign-2.03+20110620/kalign2_mem.c"
void free_feature_matrix(struct feature_matrix *fm ) 
{ 
  int i ;

  {
#line 55
  i = 0;
  {
#line 55
  while (1) {
    while_continue: /* CIL Label */ ;
#line 55
    if (! (i < fm->mdim)) {
#line 55
      goto while_break;
    }
    {
#line 56
    free((void *)*(fm->m + i));
#line 55
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 58
  free((void *)fm->m);
#line 59
  free((void *)fm);
  }
#line 60
  return;
}
}
#line 63 "/home/june/repo/benchmarks/collector/temp/kalign-2.03+20110620/kalign2_mem.c"
void free_utf(struct utype_ufeat *utf ) 
{ 


  {
  {
#line 65
  free_ft(utf->t);
#line 66
  free_ft(utf->f);
#line 67
  free((void *)utf);
  }
#line 68
  return;
}
}
#line 83 "/home/june/repo/benchmarks/collector/temp/kalign-2.03+20110620/kalign2_mem.c"
struct names *names_alloc(struct names *n ) 
{ 
  int i ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;

  {
  {
#line 86
  tmp = malloc(sizeof(struct names ));
#line 86
  n = (struct names *)tmp;
#line 87
  tmp___0 = malloc(sizeof(int ) * (unsigned long )numseq);
#line 87
  n->start = (int *)tmp___0;
#line 88
  tmp___1 = malloc(sizeof(int ) * (unsigned long )numseq);
#line 88
  n->end = (int *)tmp___1;
#line 89
  tmp___2 = malloc(sizeof(int ) * (unsigned long )numseq);
#line 89
  n->len = (int *)tmp___2;
#line 91
  i = 0;
  }
  {
#line 91
  while (1) {
    while_continue: /* CIL Label */ ;
#line 91
    if (! ((unsigned int )i < numseq)) {
#line 91
      goto while_break;
    }
#line 92
    *(n->start + i) = 0;
#line 93
    *(n->end + i) = 0;
#line 94
    *(n->len + i) = 0;
#line 91
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 96
  return (n);
}
}
#line 99 "/home/june/repo/benchmarks/collector/temp/kalign-2.03+20110620/kalign2_mem.c"
void names_free(struct names *n ) 
{ 


  {
  {
#line 101
  free((void *)n->start);
#line 102
  free((void *)n->end);
#line 103
  free((void *)n->len);
#line 104
  free((void *)n);
  }
#line 105
  return;
}
}
#line 108 "/home/june/repo/benchmarks/collector/temp/kalign-2.03+20110620/kalign2_mem.c"
struct alignment *aln_alloc(struct alignment *aln ) 
{ 
  int i ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  void *tmp___9 ;

  {
  {
#line 111
  tmp = malloc(sizeof(struct alignment ));
#line 111
  aln = (struct alignment *)tmp;
#line 112
  tmp___0 = malloc(sizeof(int *) * (unsigned long )numseq);
#line 112
  aln->s = (int **)tmp___0;
#line 113
  tmp___1 = malloc(sizeof(char *) * (unsigned long )numseq);
#line 113
  aln->seq = (char **)tmp___1;
#line 114
  tmp___2 = malloc(sizeof(struct feature *) * (unsigned long )numseq);
#line 114
  aln->ft = (struct feature **)tmp___2;
#line 115
  tmp___3 = malloc(sizeof(struct sequence_information *) * (unsigned long )numseq);
#line 115
  aln->si = (struct sequence_info **)tmp___3;
#line 116
  tmp___4 = malloc(sizeof(unsigned int ) * (unsigned long )numprofiles);
#line 116
  aln->sl = (unsigned int *)tmp___4;
#line 117
  tmp___5 = malloc(sizeof(unsigned int *) * (unsigned long )numprofiles);
#line 117
  aln->sip = (unsigned int **)tmp___5;
#line 119
  tmp___6 = malloc(sizeof(unsigned int ) * (unsigned long )numprofiles);
#line 119
  aln->nsip = (unsigned int *)tmp___6;
#line 120
  tmp___7 = malloc(sizeof(char *) * (unsigned long )numseq);
#line 120
  aln->sn = (char **)tmp___7;
#line 121
  tmp___8 = malloc(sizeof(unsigned int ) * (unsigned long )numseq);
#line 121
  aln->lsn = (unsigned int *)tmp___8;
#line 122
  i = 0;
  }
  {
#line 122
  while (1) {
    while_continue: /* CIL Label */ ;
#line 122
    if (! ((unsigned int )i < numprofiles)) {
#line 122
      goto while_break;
    }
#line 123
    *(aln->sip + i) = (unsigned int *)0;
#line 124
    *(aln->nsip + i) = 0U;
#line 125
    *(aln->sl + i) = 0U;
#line 122
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 128
  i = 0;
  {
#line 128
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 128
    if (! ((unsigned int )i < numseq)) {
#line 128
      goto while_break___0;
    }
    {
#line 129
    *(aln->lsn + i) = 0U;
#line 130
    *(aln->ft + i) = (struct feature *)0;
#line 131
    *(aln->si + i) = (struct sequence_info *)0;
#line 132
    tmp___9 = malloc(sizeof(int ));
#line 132
    *(aln->sip + i) = (unsigned int *)tmp___9;
#line 133
    *(aln->nsip + i) = 1U;
#line 134
    *(*(aln->sip + i) + 0) = (unsigned int )i;
#line 128
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 136
  return (aln);
}
}
#line 140 "/home/june/repo/benchmarks/collector/temp/kalign-2.03+20110620/kalign2_mem.c"
void free_aln(struct alignment *aln ) 
{ 
  int i ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 143
  i = (int )numseq;
  {
#line 143
  while (1) {
    while_continue: /* CIL Label */ ;
#line 143
    tmp = i;
#line 143
    i --;
#line 143
    if (! tmp) {
#line 143
      goto while_break;
    }
    {
#line 144
    free((void *)*(aln->s + i));
#line 145
    free((void *)*(aln->seq + i));
#line 146
    free((void *)*(aln->sn + i));
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 149
  if (aln->ft) {
#line 150
    i = (int )numseq;
    {
#line 150
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 150
      tmp___0 = i;
#line 150
      i --;
#line 150
      if (! tmp___0) {
#line 150
        goto while_break___0;
      }
      {
#line 151
      free_ft(*(aln->ft + i));
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 153
    free((void *)aln->ft);
    }
  }
#line 155
  if (aln->si) {
    {
#line 156
    free((void *)aln->si);
    }
  }
#line 159
  i = (int )numprofiles;
  {
#line 159
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 159
    tmp___1 = i;
#line 159
    i --;
#line 159
    if (! tmp___1) {
#line 159
      goto while_break___1;
    }
#line 160
    if (*(aln->sip + i)) {
      {
#line 161
      free((void *)*(aln->sip + i));
      }
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 164
  free((void *)aln->seq);
#line 165
  free((void *)aln->s);
#line 166
  free((void *)aln->sn);
#line 167
  free((void *)aln->sl);
#line 168
  free((void *)aln->lsn);
#line 169
  free((void *)aln->sip);
#line 170
  free((void *)aln->nsip);
#line 171
  free((void *)aln);
  }
#line 172
  return;
}
}
#line 175 "/home/june/repo/benchmarks/collector/temp/kalign-2.03+20110620/kalign2_mem.c"
void free_param(struct parameters *param ) 
{ 


  {
  {
#line 177
  free((void *)param->infile);
#line 178
  free((void *)param);
  }
#line 179
  return;
}
}
#line 181 "/home/june/repo/benchmarks/collector/temp/kalign-2.03+20110620/kalign2_mem.c"
void free_ft(struct feature *n ) 
{ 
  struct feature *old_n ;

  {
#line 183
  old_n = (struct feature *)0;
#line 184
  if ((unsigned long )n != (unsigned long )((void *)0)) {
    {
#line 185
    old_n = n;
#line 186
    n = n->next;
#line 187
    free((void *)old_n->type);
#line 188
    free((void *)old_n->note);
#line 189
    free((void *)old_n);
#line 190
    free_ft(n);
    }
  }
#line 192
  return;
}
}
#line 194 "/home/june/repo/benchmarks/collector/temp/kalign-2.03+20110620/kalign2_mem.c"
struct hirsch_mem *hirsch_mem_alloc(struct hirsch_mem *hm , int x ) 
{ 
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 198
  tmp = malloc(sizeof(struct hirsch_mem ));
#line 198
  hm = (struct hirsch_mem *)tmp;
#line 199
  hm->starta = 0;
#line 200
  hm->startb = 0;
#line 201
  hm->enda = 0;
#line 202
  hm->endb = 0;
#line 203
  hm->size = x;
#line 204
  hm->len_a = 0;
#line 205
  hm->len_b = 0;
#line 206
  tmp___0 = malloc(sizeof(struct states ) * (unsigned long )(x + 1));
#line 206
  hm->f = (struct states *)tmp___0;
#line 207
  tmp___1 = malloc(sizeof(struct states ) * (unsigned long )(x + 1));
#line 207
  hm->b = (struct states *)tmp___1;
  }
#line 208
  return (hm);
}
}
#line 211 "/home/june/repo/benchmarks/collector/temp/kalign-2.03+20110620/kalign2_mem.c"
struct hirsch_mem *hirsch_mem_realloc(struct hirsch_mem *hm , int x ) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 213
  hm->starta = 0;
#line 214
  hm->startb = 0;
#line 215
  hm->enda = 0;
#line 216
  hm->endb = 0;
#line 217
  hm->len_a = 0;
#line 218
  hm->len_b = 0;
#line 219
  hm->size = x;
#line 220
  tmp = realloc((void *)hm->f, sizeof(struct states ) * (unsigned long )(x + 1));
#line 220
  hm->f = (struct states *)tmp;
#line 221
  tmp___0 = realloc((void *)hm->b, sizeof(struct states ) * (unsigned long )(x + 1));
#line 221
  hm->b = (struct states *)tmp___0;
  }
#line 222
  return (hm);
}
}
#line 225 "/home/june/repo/benchmarks/collector/temp/kalign-2.03+20110620/kalign2_mem.c"
void hirsch_mem_free(struct hirsch_mem *hm ) 
{ 


  {
  {
#line 227
  free((void *)hm->f);
#line 228
  free((void *)hm->b);
#line 229
  free((void *)hm);
  }
#line 230
  return;
}
}
#line 233 "/home/june/repo/benchmarks/collector/temp/kalign-2.03+20110620/kalign2_mem.c"
struct dp_matrix *dp_matrix_realloc(struct dp_matrix *dp , int x , int y ) 
{ 
  int i ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 236
  if (x > y) {
#line 237
    y = x;
  } else {
#line 239
    x = y;
  }
#line 241
  if (x > dp->x) {
#line 241
    goto _L;
  } else
#line 241
  if (y > dp->y) {
    _L: /* CIL Label */ 
#line 243
    i = 1;
    {
#line 244
    while (1) {
      while_continue: /* CIL Label */ ;
#line 244
      if (! (i <= y)) {
#line 244
        goto while_break;
      }
#line 245
      i <<= 1;
    }
    while_break: /* CIL Label */ ;
    }
#line 248
    y = i - 1;
#line 249
    i = 1;
    {
#line 250
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 250
      if (! (i <= x)) {
#line 250
        goto while_break___0;
      }
#line 251
      i <<= 1;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 254
    x = i - 1;
#line 256
    tmp = realloc((void *)dp->s, sizeof(struct states ) * (unsigned long )(y + 1));
#line 256
    dp->s = (struct states *)tmp;
#line 257
    tmp___0 = realloc((void *)dp->tb, sizeof(char *) * (unsigned long )(x + 1));
#line 257
    dp->tb = (char **)tmp___0;
#line 258
    tmp___1 = realloc(dp->tb_mem, (sizeof(char ) * (unsigned long )(x + 1)) * (unsigned long )(y + 1));
#line 258
    dp->tb_mem = tmp___1;
#line 259
    *(dp->tb + 0) = (char *)dp->tb_mem;
#line 260
    i = 1;
    }
    {
#line 260
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 260
      if (! (i <= x)) {
#line 260
        goto while_break___1;
      }
#line 261
      *(dp->tb + i) = *(dp->tb + 0) + i * (y + 1);
#line 260
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 263
    dp->x = x;
#line 264
    dp->y = y;
  }
#line 266
  return (dp);
}
}
#line 269 "/home/june/repo/benchmarks/collector/temp/kalign-2.03+20110620/kalign2_mem.c"
struct dp_matrix *dp_matrix_alloc(struct dp_matrix *dp , int x , int y ) 
{ 
  int i ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;

  {
  {
#line 272
  tmp = malloc(sizeof(struct dp_matrix ));
#line 272
  dp = (struct dp_matrix *)tmp;
#line 273
  dp->x = x;
#line 274
  dp->y = y;
#line 275
  tmp___0 = malloc(sizeof(struct states ) * (unsigned long )(y + 1));
#line 275
  dp->s = (struct states *)tmp___0;
#line 276
  tmp___1 = malloc(sizeof(char *) * (unsigned long )(x + 1));
#line 276
  dp->tb = (char **)tmp___1;
#line 277
  tmp___2 = malloc((sizeof(char ) * (unsigned long )(x + 1)) * (unsigned long )(y + 1));
#line 277
  dp->tb_mem = tmp___2;
#line 278
  *(dp->tb + 0) = (char *)dp->tb_mem;
#line 279
  i = 1;
  }
  {
#line 279
  while (1) {
    while_continue: /* CIL Label */ ;
#line 279
    if (! (i <= x)) {
#line 279
      goto while_break;
    }
#line 280
    *(dp->tb + i) = *(dp->tb + 0) + i * (y + 1);
#line 279
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 282
  return (dp);
}
}
#line 285 "/home/june/repo/benchmarks/collector/temp/kalign-2.03+20110620/kalign2_mem.c"
void dp_matrix_free(struct dp_matrix *dp ) 
{ 


  {
  {
#line 287
  free((void *)dp->s);
#line 288
  free((void *)dp->tb);
#line 289
  free(dp->tb_mem);
#line 290
  free((void *)dp);
  }
#line 291
  return;
}
}
#line 261 "/home/june/repo/benchmarks/collector/temp/kalign-2.03+20110620/kalign2.h"
float protein_wu_distance_calculation(struct bignode **hash , int const   *seq , int const   seqlen ,
                                      int const   diagonals , float const   mode ) ;
#line 264
float dna_distance_calculation(struct bignode **hash , int *p , int seqlen , int diagonals ,
                               float mode ) ;
#line 25 "/home/june/repo/benchmarks/collector/temp/kalign-2.03+20110620/kalign2_profile_alignment.h"
int local_numseq  ;
#line 26 "/home/june/repo/benchmarks/collector/temp/kalign-2.03+20110620/kalign2_profile_alignment.h"
int local_numprofiles  ;
#line 28
int *assign_gap_codes(int *seq , int len ) ;
#line 31
int is_member(struct alignment *aln , int test ) ;
#line 33
float **dna_profile_distance(struct alignment *aln , float **dm , struct parameters *param ,
                             int nj___0 ) ;
#line 34
float **protein_profile_wu_distance(struct alignment *aln , float **dm , struct parameters *param ,
                                    int nj___0 ) ;
#line 37
int **hirschberg_profile_alignment(struct alignment *aln , int *tree , float **submatrix ,
                                   int **map ) ;
#line 38
float *make_profile_from_alignment(float *prof , int num , struct alignment *aln ,
                                   float **subm ) ;
#line 30 "/home/june/repo/benchmarks/collector/temp/kalign-2.03+20110620/kalign2_profile_alignment.c"
void profile_alignment_main(struct alignment *aln , struct parameters *param , float **submatrix ) 
{ 
  float **dm ;
  int *tree ;
  struct aln_tree_node *tree2 ;
  int i ;
  int j ;
  int tmp_numseq ;
  int tmp_numprofiles ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  int **map ;
  int *p ;
  int a ;
  int b ;
  int c ;

  {
#line 32
  dm = (float **)0;
#line 33
  tree = (int *)0;
#line 34
  tree2 = (struct aln_tree_node *)0;
#line 39
  local_numseq = 0;
#line 40
  local_numprofiles = 0;
  {
#line 44
  while (1) {
    while_continue: /* CIL Label */ ;
#line 44
    if (! *(aln->sl + ((unsigned int )local_numseq + numseq))) {
#line 44
      goto while_break;
    }
#line 45
    local_numseq ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 48
  local_numprofiles = (local_numseq << 1) - 1;
#line 51
  i = 0;
  {
#line 51
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 51
    if (! ((unsigned int )i < numseq)) {
#line 51
      goto while_break___0;
    }
    {
#line 53
    *(aln->s + i) = assign_gap_codes(*(aln->s + i), (int )*(aln->sl + i));
#line 51
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 56
  if (param->dna == 1) {
    {
#line 57
    tmp = byg_start(param->tree, (char *)"njNJ");
    }
#line 57
    if (tmp != -1) {
      {
#line 58
      dm = dna_profile_distance(aln, dm, param, 1);
      }
    } else {
      {
#line 60
      dm = dna_profile_distance(aln, dm, param, 0);
      }
    }
  } else {
    {
#line 63
    tmp___0 = byg_start(param->tree, (char *)"njNJ");
    }
#line 63
    if (tmp___0 != -1) {
      {
#line 64
      dm = protein_profile_wu_distance(aln, dm, param, 1);
      }
    } else {
      {
#line 66
      dm = protein_profile_wu_distance(aln, dm, param, 0);
      }
    }
  }
  {
#line 76
  tmp_numseq = (int )numseq;
#line 77
  tmp_numprofiles = (int )numprofiles;
#line 79
  numseq = (unsigned int )local_numseq;
#line 80
  numprofiles = (unsigned int )local_numprofiles;
#line 82
  tmp___1 = byg_start(param->tree, (char *)"njNJ");
  }
#line 82
  if (tmp___1 != -1) {
    {
#line 83
    tree2 = real_nj(dm, param->ntree);
    }
  } else {
    {
#line 85
    tree2 = real_upgma(dm, param->ntree);
    }
  }
  {
#line 93
  tmp___2 = malloc(sizeof(int ) * (unsigned long )(numseq * 3U + 1U));
#line 93
  tree = (int *)tmp___2;
#line 94
  i = 1;
  }
  {
#line 94
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 94
    if (! ((unsigned int )i < numseq * 3U + 1U)) {
#line 94
      goto while_break___1;
    }
#line 95
    *(tree + i) = 0;
#line 94
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 97
  *(tree + 0) = 1;
#line 98
  tree = readtree(tree2, tree);
#line 99
  i = 0;
  }
  {
#line 99
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 99
    if (! ((unsigned int )i < numseq * 3U)) {
#line 99
      goto while_break___2;
    }
#line 100
    *(tree + i) = *(tree + (i + 1)) + tmp_numseq;
#line 99
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 104
  numseq = (unsigned int )tmp_numseq;
#line 105
  numprofiles = (unsigned int )tmp_numprofiles;
#line 107
  map = (int **)0;
#line 109
  map = hirschberg_profile_alignment(aln, tree, submatrix, map);
#line 111
  p = (int *)0;
#line 112
  i = 0;
  }
  {
#line 112
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 112
    if (! ((unsigned int )i < numseq)) {
#line 112
      goto while_break___3;
    }
#line 113
    p = *(aln->s + i);
#line 114
    j = 0;
    {
#line 114
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 114
      if (! ((unsigned int )j < *(aln->sl + i))) {
#line 114
        goto while_break___4;
      }
#line 115
      *(p + j) = 0;
#line 114
      j ++;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 112
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 120
  i = 0;
  {
#line 120
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 120
    if (! (i < (local_numseq - 1) * 3)) {
#line 120
      goto while_break___5;
    }
    {
#line 121
    a = *(tree + i);
#line 122
    b = *(tree + (i + 1));
#line 123
    c = *(tree + (i + 2));
#line 124
    aln = make_seq(aln, a, b, *(map + c));
#line 120
    i += 3;
    }
  }
  while_break___5: /* CIL Label */ ;
  }
#line 127
  i = 0;
  {
#line 127
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 127
    if (! ((unsigned int )i < numseq)) {
#line 127
      goto while_break___6;
    }
#line 128
    *(aln->nsip + i) = 0U;
#line 127
    i ++;
  }
  while_break___6: /* CIL Label */ ;
  }
  {
#line 130
  aln = sort_sequences(aln, tree, param->sort);
#line 137
  output(aln, param);
#line 140
  free((void *)tree2->links);
#line 141
  free((void *)tree2->internal_lables);
#line 142
  free((void *)tree2);
#line 145
  free((void *)map);
#line 146
  free((void *)tree);
#line 147
  exit(0);
  }
}
}
#line 151 "/home/june/repo/benchmarks/collector/temp/kalign-2.03+20110620/kalign2_profile_alignment.c"
int **hirschberg_profile_alignment(struct alignment *aln , int *tree , float **submatrix ,
                                   int **map ) 
{ 
  struct hirsch_mem *hm ;
  int i ;
  int j ;
  int g ;
  int a ;
  int b ;
  int c ;
  int len_a ;
  int len_b ;
  float **profile ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
  {
#line 153
  hm = (struct hirsch_mem *)0;
#line 157
  profile = (float **)0;
#line 159
  tmp = malloc(sizeof(float *) * (unsigned long )numprofiles);
#line 159
  profile = (float **)tmp;
#line 160
  i = 0;
  }
  {
#line 160
  while (1) {
    while_continue: /* CIL Label */ ;
#line 160
    if (! ((unsigned int )i < numprofiles)) {
#line 160
      goto while_break;
    }
#line 161
    *(profile + i) = (float *)0;
#line 160
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 164
  tmp___0 = malloc(sizeof(int *) * (unsigned long )numprofiles);
#line 164
  map = (int **)tmp___0;
#line 165
  i = 0;
  }
  {
#line 165
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 165
    if (! ((unsigned int )i < numprofiles)) {
#line 165
      goto while_break___0;
    }
#line 166
    *(map + i) = (int *)0;
#line 165
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 169
  hm = hirsch_mem_alloc(hm, 1024);
#line 171
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\nAlignment:\n");
#line 173
  i = 0;
  }
  {
#line 173
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 173
    if (! (i < local_numseq - 1)) {
#line 173
      goto while_break___1;
    }
    {
#line 174
    a = *(tree + i * 3);
#line 175
    b = *(tree + (i * 3 + 1));
#line 176
    c = *(tree + (i * 3 + 2));
#line 177
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\r%8.0f percent done",
            (double )(((float )i / (float )local_numseq) * (float )100));
#line 179
    len_a = (int )*(aln->sl + a);
#line 180
    len_b = (int )*(aln->sl + b);
    }
#line 183
    if (len_a > len_b) {
#line 183
      g = len_a;
    } else {
#line 183
      g = len_b;
    }
    {
#line 184
    tmp___1 = malloc(sizeof(int ) * (unsigned long )(g + 2));
#line 184
    *(map + c) = (int *)tmp___1;
    }
#line 185
    if (g > hm->size) {
      {
#line 186
      hm = hirsch_mem_realloc(hm, g);
      }
    }
#line 189
    j = 0;
    {
#line 189
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 189
      if (! (j < g + 2)) {
#line 189
        goto while_break___2;
      }
#line 190
      *(*(map + c) + j) = -1;
#line 189
      j ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 193
    if ((unsigned int )a < numseq + (unsigned int )local_numseq) {
      {
#line 194
      *(profile + a) = make_profile_from_alignment(*(profile + a), a, aln, submatrix);
      }
    }
#line 196
    if ((unsigned int )b < numseq + (unsigned int )local_numseq) {
      {
#line 197
      *(profile + b) = make_profile_from_alignment(*(profile + b), b, aln, submatrix);
      }
    }
    {
#line 201
    set_gap_penalties(*(profile + b), len_b, (int )*(aln->nsip + a), (float )0, (int )*(aln->nsip + b));
#line 202
    set_gap_penalties(*(profile + a), len_a, (int )*(aln->nsip + b), (float )0, (int )*(aln->nsip + a));
#line 204
    hm->starta = 0;
#line 205
    hm->startb = 0;
#line 206
    hm->enda = len_a;
#line 207
    hm->endb = len_b;
#line 208
    hm->len_a = len_a;
#line 209
    hm->len_b = len_b;
#line 211
    (hm->f + 0)->a = (float )0;
#line 212
    (hm->f + 0)->ga = - 3.40282346638528859812e+38F;
#line 213
    (hm->f + 0)->gb = - 3.40282346638528859812e+38F;
#line 214
    (hm->b + 0)->a = (float )0;
#line 215
    (hm->b + 0)->ga = - 3.40282346638528859812e+38F;
#line 216
    (hm->b + 0)->gb = - 3.40282346638528859812e+38F;
    }
#line 218
    if (len_a < len_b) {
      {
#line 219
      *(map + c) = hirsch_pp_dyn((float const   *)*(profile + a), (float const   *)*(profile + b),
                                 hm, *(map + c));
      }
    } else {
      {
#line 221
      hm->enda = len_b;
#line 222
      hm->endb = len_a;
#line 223
      hm->len_a = len_b;
#line 224
      hm->len_b = len_a;
#line 225
      *(map + c) = hirsch_pp_dyn((float const   *)*(profile + b), (float const   *)*(profile + a),
                                 hm, *(map + c));
#line 226
      *(map + c) = mirror_hirsch_path(*(map + c), len_a, len_b);
      }
    }
    {
#line 229
    *(map + c) = add_gap_info_to_hirsch_path(*(map + c), len_a, len_b);
    }
#line 231
    if (i != local_numseq - 2) {
      {
#line 233
      tmp___2 = malloc((sizeof(float ) * 64UL) * (unsigned long )(*(*(map + c) + 0) + 2));
#line 233
      *(profile + c) = (float *)tmp___2;
#line 234
      *(profile + c) = update((float const   *)*(profile + a), (float const   *)*(profile + b),
                              *(profile + c), *(map + c), (int )*(aln->nsip + a),
                              (int )*(aln->nsip + b));
      }
    }
    {
#line 237
    *(aln->sl + c) = (unsigned int )*(*(map + c) + 0);
#line 239
    *(aln->nsip + c) = *(aln->nsip + a) + *(aln->nsip + b);
#line 240
    tmp___3 = malloc(sizeof(int ) * (unsigned long )(*(aln->nsip + a) + *(aln->nsip + b)));
#line 240
    *(aln->sip + c) = (unsigned int *)tmp___3;
#line 241
    g = 0;
#line 242
    j = (int )*(aln->nsip + a);
    }
    {
#line 242
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 242
      tmp___4 = j;
#line 242
      j --;
#line 242
      if (! tmp___4) {
#line 242
        goto while_break___3;
      }
#line 243
      *(*(aln->sip + c) + g) = *(*(aln->sip + a) + j);
#line 244
      g ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 246
    j = (int )*(aln->nsip + b);
    {
#line 246
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 246
      tmp___5 = j;
#line 246
      j --;
#line 246
      if (! tmp___5) {
#line 246
        goto while_break___4;
      }
#line 247
      *(*(aln->sip + c) + g) = *(*(aln->sip + b) + j);
#line 248
      g ++;
    }
    while_break___4: /* CIL Label */ ;
    }
    {
#line 251
    free((void *)*(profile + a));
#line 252
    free((void *)*(profile + b));
#line 173
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 254
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\r%8.0f percent done\n",
          100.0);
#line 255
  free((void *)profile);
#line 256
  hirsch_mem_free(hm);
#line 257
  i = 32;
  }
  {
#line 257
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 257
    tmp___6 = i;
#line 257
    i --;
#line 257
    if (! tmp___6) {
#line 257
      goto while_break___5;
    }
    {
#line 258
    free((void *)*(submatrix + i));
    }
  }
  while_break___5: /* CIL Label */ ;
  }
  {
#line 260
  free((void *)submatrix);
  }
#line 261
  return (map);
}
}
#line 265 "/home/june/repo/benchmarks/collector/temp/kalign-2.03+20110620/kalign2_profile_alignment.c"
int *assign_gap_codes(int *seq , int len ) 
{ 
  int i ;

  {
#line 268
  if (*(seq + 0) < 0) {
#line 268
    if (*(seq + 1) < 0) {
#line 269
      *(seq + 0) = -2;
    }
  }
#line 272
  i = 1;
  {
#line 272
  while (1) {
    while_continue: /* CIL Label */ ;
#line 272
    if (! (i < len)) {
#line 272
      goto while_break;
    }
#line 273
    if (*(seq + (i - 1)) < 0) {
#line 273
      if (*(seq + i) < 0) {
#line 274
        *(seq + i) = -2;
      }
    }
#line 276
    if (*(seq + (i - 1)) < 0) {
#line 276
      if (*(seq + i) >= 0) {
#line 277
        *(seq + (i - 1)) = -1;
      }
    }
#line 272
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 280
  i = 0;
  {
#line 281
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 281
    if (! (*(seq + i) < 0)) {
#line 281
      goto while_break___0;
    }
#line 282
    if (*(seq + i) == -2) {
#line 283
      *(seq + i) = -3;
    }
#line 285
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 287
  i = len - 1;
  {
#line 288
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 288
    if (! (*(seq + i) < 0)) {
#line 288
      goto while_break___1;
    }
#line 289
    if (*(seq + i) == -2) {
#line 290
      *(seq + i) = -3;
    }
#line 292
    i --;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 296
  return (seq);
}
}
#line 301 "/home/june/repo/benchmarks/collector/temp/kalign-2.03+20110620/kalign2_profile_alignment.c"
float *make_profile_from_alignment(float *prof , int num , struct alignment *aln ,
                                   float **subm ) 
{ 
  int i ;
  int j ;
  int c ;
  int a ;
  int len ;
  int *seq ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 305
  len = (int )*(aln->sl + num);
#line 306
  seq = (int *)0;
#line 307
  tmp = malloc((sizeof(float ) * (unsigned long )(len + 2)) * 64UL);
#line 307
  prof = (float *)tmp;
#line 308
  i = 0;
  }
  {
#line 308
  while (1) {
    while_continue: /* CIL Label */ ;
#line 308
    if (! (i < (len + 2) * 64)) {
#line 308
      goto while_break;
    }
#line 309
    *(prof + i) = (float )0;
#line 308
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 312
  a = 0;
  {
#line 312
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 312
    if (! ((unsigned int )a < *(aln->nsip + num))) {
#line 312
      goto while_break___0;
    }
#line 314
    seq = *(aln->s + *(*(aln->sip + num) + a));
#line 315
    prof += 64 * (len + 1);
#line 317
    *(prof + 55) -= gpo;
#line 318
    *(prof + 56) -= gpe;
#line 319
    *(prof + 57) -= tgpe;
#line 322
    i = len;
    {
#line 323
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 323
      tmp___1 = i;
#line 323
      i --;
#line 323
      if (! tmp___1) {
#line 323
        goto while_break___1;
      }
#line 324
      prof -= 64;
#line 326
      c = *(seq + i);
#line 327
      if (c >= 0) {
#line 331
        *(prof + c) += (float )1;
#line 332
        prof += 32;
#line 333
        j = 23;
        {
#line 333
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 333
          tmp___0 = j;
#line 333
          j --;
#line 333
          if (! tmp___0) {
#line 333
            goto while_break___2;
          }
#line 334
          *(prof + j) += *(*(subm + c) + j);
        }
        while_break___2: /* CIL Label */ ;
        }
#line 336
        *(prof + 23) -= gpo;
#line 337
        *(prof + 24) -= gpe;
#line 338
        *(prof + 25) -= tgpe;
#line 339
        prof -= 32;
      } else
#line 340
      if (c == -1) {
#line 341
        *(prof + 23) += (float )1;
#line 342
        j = 32;
        {
#line 342
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 342
          if (! (j < 55)) {
#line 342
            goto while_break___3;
          }
#line 343
          *(prof + j) -= gpo;
#line 342
          j ++;
        }
        while_break___3: /* CIL Label */ ;
        }
      } else
#line 345
      if (c == -2) {
#line 346
        *(prof + 24) += (float )1;
#line 347
        j = 32;
        {
#line 347
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 347
          if (! (j < 55)) {
#line 347
            goto while_break___4;
          }
#line 348
          *(prof + j) -= gpe;
#line 347
          j ++;
        }
        while_break___4: /* CIL Label */ ;
        }
      } else
#line 350
      if (c == -3) {
#line 351
        *(prof + 25) += (float )1;
#line 352
        j = 32;
        {
#line 352
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 352
          if (! (j < 55)) {
#line 352
            goto while_break___5;
          }
#line 353
          *(prof + j) -= tgpe;
#line 352
          j ++;
        }
        while_break___5: /* CIL Label */ ;
        }
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 357
    prof -= 64;
#line 358
    *(prof + 55) -= gpo;
#line 359
    *(prof + 56) -= gpe;
#line 360
    *(prof + 57) -= tgpe;
#line 312
    a ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 362
  return (prof);
}
}
#line 366 "/home/june/repo/benchmarks/collector/temp/kalign-2.03+20110620/kalign2_profile_alignment.c"
float **protein_profile_wu_distance(struct alignment *aln , float **dm , struct parameters *param ,
                                    int nj___0 ) 
{ 
  struct bignode *hash[1024] ;
  int *p ;
  int i ;
  int j ;
  int m ;
  int n ;
  int a ;
  int b ;
  unsigned int hv ;
  int **local_seq ;
  int *local_sl ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  float tmp___11 ;
  int tmp___12 ;

  {
  {
#line 369
  p = (int *)0;
#line 373
  local_seq = (int **)0;
#line 374
  local_sl = (int *)0;
#line 376
  tmp = malloc(sizeof(int *) * (unsigned long )numseq);
#line 376
  local_seq = (int **)tmp;
#line 377
  tmp___0 = malloc(sizeof(int ) * (unsigned long )numseq);
#line 377
  local_sl = (int *)tmp___0;
#line 378
  i = 0;
  }
  {
#line 378
  while (1) {
    while_continue: /* CIL Label */ ;
#line 378
    if (! ((unsigned int )i < numseq)) {
#line 378
      goto while_break;
    }
    {
#line 379
    tmp___1 = malloc(sizeof(int ) * (unsigned long )*(aln->sl + i));
#line 379
    *(local_seq + i) = (int *)tmp___1;
#line 380
    a = 0;
#line 381
    p = *(aln->s + i);
#line 382
    j = 0;
    }
    {
#line 382
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 382
      if (! ((unsigned int )j < *(aln->sl + i))) {
#line 382
        goto while_break___0;
      }
#line 383
      if (*(p + j) >= 0) {
#line 384
        *(*(local_seq + i) + a) = *(p + j);
#line 385
        a ++;
      }
#line 382
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 388
    *(local_sl + i) = a;
#line 378
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 393
  i = 0;
  {
#line 393
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 393
    if (! (i < 1024)) {
#line 393
      goto while_break___1;
    }
#line 394
    hash[i] = (struct bignode *)0;
#line 393
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 397
  if (nj___0) {
    {
#line 398
    tmp___2 = malloc(sizeof(float *) * (unsigned long )local_numprofiles);
#line 398
    dm = (float **)tmp___2;
#line 399
    i = local_numprofiles;
    }
    {
#line 399
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 399
      tmp___5 = i;
#line 399
      i --;
#line 399
      if (! tmp___5) {
#line 399
        goto while_break___2;
      }
      {
#line 400
      tmp___3 = malloc(sizeof(float ) * (unsigned long )local_numprofiles);
#line 400
      *(dm + i) = (float *)tmp___3;
#line 401
      j = local_numprofiles;
      }
      {
#line 401
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 401
        tmp___4 = j;
#line 401
        j --;
#line 401
        if (! tmp___4) {
#line 401
          goto while_break___3;
        }
#line 402
        *(*(dm + i) + j) = 0.0f;
      }
      while_break___3: /* CIL Label */ ;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
  } else {
    {
#line 406
    tmp___6 = malloc(sizeof(float *) * (unsigned long )local_numseq);
#line 406
    dm = (float **)tmp___6;
#line 407
    i = local_numseq;
    }
    {
#line 407
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 407
      tmp___9 = i;
#line 407
      i --;
#line 407
      if (! tmp___9) {
#line 407
        goto while_break___4;
      }
      {
#line 408
      tmp___7 = malloc(sizeof(float ) * (unsigned long )local_numseq);
#line 408
      *(dm + i) = (float *)tmp___7;
#line 409
      j = local_numseq;
      }
      {
#line 409
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 409
        tmp___8 = j;
#line 409
        j --;
#line 409
        if (! tmp___8) {
#line 409
          goto while_break___5;
        }
#line 410
        *(*(dm + i) + j) = 0.0f;
      }
      while_break___5: /* CIL Label */ ;
      }
    }
    while_break___4: /* CIL Label */ ;
    }
  }
  {
#line 414
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Distance Calculation:\n");
#line 415
  b = (int )((numseq * (numseq - 1U)) / 2U);
#line 416
  a = 1;
#line 420
  i = 0;
  }
  {
#line 420
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 420
    if (! ((unsigned int )i < numseq - 1U)) {
#line 420
      goto while_break___6;
    }
    {
#line 421
    m = is_member(aln, i);
#line 422
    p = *(local_seq + i);
#line 425
    j = *(local_sl + i) - 2;
    }
    {
#line 425
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 425
      tmp___10 = j;
#line 425
      j --;
#line 425
      if (! tmp___10) {
#line 425
        goto while_break___7;
      }
      {
#line 428
      hv = (unsigned int )((*(p + j) << 5) + *(p + (j + 1)));
#line 429
      hash[hv] = big_insert_hash(hash[hv], (unsigned int const   )j);
#line 431
      hv = (unsigned int )((*(p + j) << 5) + *(p + (j + 2)));
#line 432
      hash[hv] = big_insert_hash(hash[hv], (unsigned int const   )j);
      }
    }
    while_break___7: /* CIL Label */ ;
    }
#line 436
    j = i + 1;
    {
#line 436
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 436
      if (! ((unsigned int )j < numseq)) {
#line 436
        goto while_break___8;
      }
      {
#line 437
      n = is_member(aln, j);
      }
#line 438
      if (n != m) {
        {
#line 440
        p = *(local_seq + j);
#line 441
        tmp___11 = protein_wu_distance_calculation(hash, (int const   *)p, (int const   )*(local_sl + j),
                                                   (int const   )(*(local_sl + j) + *(local_sl + i)),
                                                   (float const   )param->zlevel);
#line 441
        *(*(dm + m) + n) += tmp___11;
#line 445
        *(*(dm + n) + m) = *(*(dm + m) + n);
        }
      }
      {
#line 448
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\r%8.0f percent done",
              (double )(((float )a / (float )b) * (float )100));
#line 449
      a ++;
#line 436
      j ++;
      }
    }
    while_break___8: /* CIL Label */ ;
    }
#line 454
    j = 1024;
    {
#line 454
    while (1) {
      while_continue___9: /* CIL Label */ ;
#line 454
      tmp___12 = j;
#line 454
      j --;
#line 454
      if (! tmp___12) {
#line 454
        goto while_break___9;
      }
#line 455
      if (hash[j]) {
        {
#line 456
        big_remove_nodes(hash[j]);
#line 457
        hash[j] = (struct bignode *)0;
        }
      }
    }
    while_break___9: /* CIL Label */ ;
    }
#line 420
    i ++;
  }
  while_break___6: /* CIL Label */ ;
  }
#line 462
  i = 0;
  {
#line 462
  while (1) {
    while_continue___10: /* CIL Label */ ;
#line 462
    if (! ((unsigned int )i < numseq)) {
#line 462
      goto while_break___10;
    }
    {
#line 463
    free((void *)*(local_seq + i));
#line 462
    i ++;
    }
  }
  while_break___10: /* CIL Label */ ;
  }
  {
#line 465
  free((void *)local_seq);
#line 466
  free((void *)local_sl);
  }
#line 467
  return (dm);
}
}
#line 470 "/home/june/repo/benchmarks/collector/temp/kalign-2.03+20110620/kalign2_profile_alignment.c"
float **dna_profile_distance(struct alignment *aln , float **dm , struct parameters *param ,
                             int nj___0 ) 
{ 
  struct bignode *hash[1024] ;
  int *p ;
  int i ;
  int j ;
  int a ;
  int b ;
  int m ;
  int n ;
  unsigned int hv ;
  int **local_seq ;
  int *local_sl ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  float tmp___11 ;
  int tmp___12 ;

  {
  {
#line 474
  p = (int *)0;
#line 477
  local_seq = (int **)0;
#line 478
  local_sl = (int *)0;
#line 480
  tmp = malloc(sizeof(int *) * (unsigned long )numseq);
#line 480
  local_seq = (int **)tmp;
#line 481
  tmp___0 = malloc(sizeof(int ) * (unsigned long )numseq);
#line 481
  local_sl = (int *)tmp___0;
#line 482
  i = 0;
  }
  {
#line 482
  while (1) {
    while_continue: /* CIL Label */ ;
#line 482
    if (! ((unsigned int )i < numseq)) {
#line 482
      goto while_break;
    }
    {
#line 483
    tmp___1 = malloc(sizeof(int ) * (unsigned long )*(aln->sl + i));
#line 483
    *(local_seq + i) = (int *)tmp___1;
#line 484
    a = 0;
#line 485
    p = *(aln->s + i);
#line 486
    j = 0;
    }
    {
#line 486
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 486
      if (! ((unsigned int )j < *(aln->sl + i))) {
#line 486
        goto while_break___0;
      }
#line 487
      if (*(p + j) >= 0) {
#line 488
        *(*(local_seq + i) + a) = *(p + j);
#line 489
        a ++;
      }
#line 486
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 492
    *(local_sl + i) = a;
#line 482
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 495
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Distance Calculation:\n");
#line 498
  i = 0;
  }
  {
#line 498
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 498
    if (! (i < 1024)) {
#line 498
      goto while_break___1;
    }
#line 499
    hash[i] = (struct bignode *)0;
#line 498
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 502
  if (nj___0) {
    {
#line 503
    tmp___2 = malloc(sizeof(float *) * (unsigned long )local_numprofiles);
#line 503
    dm = (float **)tmp___2;
#line 504
    i = local_numprofiles;
    }
    {
#line 504
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 504
      tmp___5 = i;
#line 504
      i --;
#line 504
      if (! tmp___5) {
#line 504
        goto while_break___2;
      }
      {
#line 505
      tmp___3 = malloc(sizeof(float ) * (unsigned long )local_numprofiles);
#line 505
      *(dm + i) = (float *)tmp___3;
#line 506
      j = local_numprofiles;
      }
      {
#line 506
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 506
        tmp___4 = j;
#line 506
        j --;
#line 506
        if (! tmp___4) {
#line 506
          goto while_break___3;
        }
#line 507
        *(*(dm + i) + j) = 0.0f;
      }
      while_break___3: /* CIL Label */ ;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
  } else {
    {
#line 511
    tmp___6 = malloc(sizeof(float *) * (unsigned long )local_numseq);
#line 511
    dm = (float **)tmp___6;
#line 512
    i = local_numseq;
    }
    {
#line 512
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 512
      tmp___9 = i;
#line 512
      i --;
#line 512
      if (! tmp___9) {
#line 512
        goto while_break___4;
      }
      {
#line 513
      tmp___7 = malloc(sizeof(float ) * (unsigned long )local_numseq);
#line 513
      *(dm + i) = (float *)tmp___7;
#line 514
      j = local_numseq;
      }
      {
#line 514
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 514
        tmp___8 = j;
#line 514
        j --;
#line 514
        if (! tmp___8) {
#line 514
          goto while_break___5;
        }
#line 515
        *(*(dm + i) + j) = 0.0f;
      }
      while_break___5: /* CIL Label */ ;
      }
    }
    while_break___4: /* CIL Label */ ;
    }
  }
#line 520
  b = (int )((numseq * (numseq - 1U)) / 2U);
#line 521
  a = 1;
#line 523
  i = 0;
  {
#line 523
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 523
    if (! ((unsigned int )i < numseq - 1U)) {
#line 523
      goto while_break___6;
    }
    {
#line 524
    m = is_member(aln, i);
#line 525
    p = *(local_seq + i);
#line 526
    j = *(local_sl + i) - 5;
    }
    {
#line 526
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 526
      tmp___10 = j;
#line 526
      j --;
#line 526
      if (! tmp___10) {
#line 526
        goto while_break___7;
      }
      {
#line 527
      hv = (unsigned int )((((((*(p + j) & 3) << 8) + ((*(p + (j + 1)) & 3) << 6)) + ((*(p + (j + 2)) & 3) << 4)) + ((*(p + (j + 3)) & 3) << 2)) + (*(p + (j + 4)) & 3));
#line 528
      hash[hv] = big_insert_hash(hash[hv], (unsigned int const   )j);
#line 529
      hv = (unsigned int )((((((*(p + j) & 3) << 8) + ((*(p + (j + 1)) & 3) << 6)) + ((*(p + (j + 2)) & 3) << 4)) + ((*(p + (j + 3)) & 3) << 2)) + (*(p + (j + 5)) & 3));
#line 530
      hash[hv] = big_insert_hash(hash[hv], (unsigned int const   )j);
#line 531
      hv = (unsigned int )((((((*(p + j) & 3) << 8) + ((*(p + (j + 1)) & 3) << 6)) + ((*(p + (j + 2)) & 3) << 4)) + ((*(p + (j + 4)) & 3) << 2)) + (*(p + (j + 5)) & 3));
#line 532
      hash[hv] = big_insert_hash(hash[hv], (unsigned int const   )j);
#line 533
      hv = (unsigned int )((((((*(p + j) & 3) << 8) + ((*(p + (j + 1)) & 3) << 6)) + ((*(p + (j + 3)) & 3) << 4)) + ((*(p + (j + 4)) & 3) << 2)) + (*(p + (j + 5)) & 3));
#line 534
      hash[hv] = big_insert_hash(hash[hv], (unsigned int const   )j);
#line 535
      hv = (unsigned int )((((((*(p + j) & 3) << 8) + ((*(p + (j + 2)) & 3) << 6)) + ((*(p + (j + 3)) & 3) << 4)) + ((*(p + (j + 4)) & 3) << 2)) + (*(p + (j + 5)) & 3));
#line 536
      hash[hv] = big_insert_hash(hash[hv], (unsigned int const   )j);
      }
    }
    while_break___7: /* CIL Label */ ;
    }
#line 538
    j = i + 1;
    {
#line 538
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 538
      if (! ((unsigned int )j < numseq)) {
#line 538
        goto while_break___8;
      }
      {
#line 539
      n = is_member(aln, j);
      }
#line 540
      if (n != m) {
        {
#line 541
        p = *(local_seq + j);
#line 543
        tmp___11 = dna_distance_calculation(hash, p, *(local_sl + j), *(local_sl + j) + *(local_sl + i),
                                            param->zlevel);
#line 543
        *(*(dm + m) + n) += tmp___11;
#line 545
        *(*(dm + n) + m) = *(*(dm + m) + n);
        }
      }
      {
#line 547
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\r%8.0f percent done",
              (double )(((float )a / (float )b) * (float )100));
#line 548
      a ++;
#line 538
      j ++;
      }
    }
    while_break___8: /* CIL Label */ ;
    }
#line 551
    j = 1024;
    {
#line 551
    while (1) {
      while_continue___9: /* CIL Label */ ;
#line 551
      tmp___12 = j;
#line 551
      j --;
#line 551
      if (! tmp___12) {
#line 551
        goto while_break___9;
      }
#line 552
      if (hash[j]) {
        {
#line 553
        big_remove_nodes(hash[j]);
#line 554
        hash[j] = (struct bignode *)0;
        }
      }
    }
    while_break___9: /* CIL Label */ ;
    }
#line 523
    i ++;
  }
  while_break___6: /* CIL Label */ ;
  }
#line 559
  i = 0;
  {
#line 559
  while (1) {
    while_continue___10: /* CIL Label */ ;
#line 559
    if (! ((unsigned int )i < numseq)) {
#line 559
      goto while_break___10;
    }
    {
#line 560
    free((void *)*(local_seq + i));
#line 559
    i ++;
    }
  }
  while_break___10: /* CIL Label */ ;
  }
  {
#line 562
  free((void *)local_seq);
#line 563
  free((void *)local_sl);
  }
#line 564
  return (dm);
}
}
#line 567 "/home/june/repo/benchmarks/collector/temp/kalign-2.03+20110620/kalign2_profile_alignment.c"
int is_member(struct alignment *aln , int test ) 
{ 
  int i ;
  int j ;

  {
#line 570
  i = (int )numseq;
  {
#line 570
  while (1) {
    while_continue: /* CIL Label */ ;
#line 570
    if (! ((unsigned int )i < numseq + (unsigned int )local_numseq)) {
#line 570
      goto while_break;
    }
#line 571
    j = 0;
    {
#line 571
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 571
      if (! ((unsigned int )j < *(aln->nsip + i))) {
#line 571
        goto while_break___0;
      }
#line 572
      if (*(*(aln->sip + i) + j) == (unsigned int )test) {
#line 573
        return ((int )((unsigned int )i - numseq));
      }
#line 571
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 570
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 577
  return (-1);
}
}
#line 228 "/home/june/repo/benchmarks/collector/temp/kalign-2.03+20110620/kalign2.h"
int *f_only_pp_dyn(int *path , struct dp_matrix *dp , float const   *fprof1 , float const   *fprof2 ,
                   int const   len_a , int const   len_b , int fdim , int stride___0 ) ;
#line 230
int *fpp_dyn(int *path , struct dp_matrix *dp , float const   *prof1 , float const   *prof2 ,
             float const   *fprof1 , float const   *fprof2 , int const   len_a , int const   len_b ,
             int fdim , int stride___0 ) ;
#line 28 "/home/june/repo/benchmarks/collector/temp/kalign-2.03+20110620/kalign2_dp.c"
int *f_only_pp_dyn(int *path , struct dp_matrix *dp , float const   *fprof1 , float const   *fprof2 ,
                   int const   len_a , int const   len_b , int fdim , int stride___0 ) 
{ 
  struct states *s ;
  char **trace ;
  char *tracep ;
  register float pa ;
  register float pga ;
  register float pgb ;
  register float ca ;
  register int i ;
  register int j ;
  register int c ;
  register int f ;

  {
#line 32
  s = (struct states *)0;
#line 33
  trace = (char **)0;
#line 34
  tracep = (char *)0;
#line 35
  pa = (float )0;
#line 36
  pga = (float )0;
#line 37
  pgb = (float )0;
#line 38
  ca = (float )0;
#line 39
  i = 0;
#line 40
  j = 0;
#line 41
  c = 0;
#line 42
  f = 0;
#line 44
  s = dp->s;
#line 46
  trace = dp->tb;
#line 48
  *(*(trace + len_a) + len_b) = (char)32;
#line 50
  fprof1 += len_a * (int const   )stride___0;
#line 53
  (s + len_b)->a = (float )0.0;
#line 54
  (s + len_b)->ga = - 3.40282346638528859812e+38F;
#line 55
  (s + len_b)->gb = - 3.40282346638528859812e+38F;
#line 57
  tracep = *(trace + len_a);
#line 59
  j = (int )len_b;
  {
#line 60
  while (1) {
    while_continue: /* CIL Label */ ;
#line 60
    j --;
#line 60
    if (! j) {
#line 60
      goto while_break;
    }
#line 61
    (s + j)->a = - 3.40282346638528859812e+38F;
#line 64
    (s + j)->ga = (s + (j + 1))->a;
#line 65
    if ((s + (j + 1))->ga > (s + j)->ga) {
#line 66
      (s + j)->ga = (s + (j + 1))->ga;
    }
#line 68
    (s + j)->gb = - 3.40282346638528859812e+38F;
#line 69
    *(tracep + j) = (char)8;
  }
  while_break: /* CIL Label */ ;
  }
#line 72
  (s + 0)->a = - 3.40282346638528859812e+38F;
#line 73
  (s + 0)->ga = - 3.40282346638528859812e+38F;
#line 74
  (s + 0)->gb = - 3.40282346638528859812e+38F;
#line 75
  i = (int )len_a;
  {
#line 76
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 76
    i --;
#line 76
    if (! i) {
#line 76
      goto while_break___0;
    }
#line 78
    fprof1 -= stride___0;
#line 80
    tracep = *(trace + i);
#line 81
    pa = (s + len_b)->a;
#line 82
    pga = (s + len_b)->ga;
#line 83
    pgb = (s + len_b)->gb;
#line 84
    (s + len_b)->a = - 3.40282346638528859812e+38F;
#line 85
    (s + len_b)->ga = - 3.40282346638528859812e+38F;
#line 88
    (s + len_b)->gb = pa;
#line 89
    if (pgb > (s + len_b)->gb) {
#line 90
      (s + len_b)->gb = pgb;
    }
#line 93
    *(tracep + len_b) = (char)16;
#line 95
    j = (int )len_b;
#line 97
    fprof2 += len_b * (int const   )stride___0;
    {
#line 99
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 99
      j --;
#line 99
      if (! j) {
#line 99
        goto while_break___1;
      }
#line 101
      fprof2 -= stride___0;
#line 102
      ca = (s + j)->a;
#line 104
      c = 1;
#line 105
      if (pga > pa) {
#line 106
        pa = pga;
#line 107
        c = 2;
      }
#line 109
      if (pgb > pa) {
#line 110
        pa = pgb;
#line 111
        c = 4;
      }
#line 114
      f = 0;
      {
#line 114
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 114
        if (! (f < fdim)) {
#line 114
          goto while_break___2;
        }
#line 116
        pa += (float )(*(fprof1 + f) * *(fprof2 + (f + fdim)));
#line 114
        f ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 119
      (s + j)->a = pa;
#line 121
      pga = (s + j)->ga;
#line 123
      (s + j)->ga = (s + (j + 1))->a;
#line 124
      if ((s + (j + 1))->ga > (s + j)->ga) {
#line 125
        (s + j)->ga = (s + (j + 1))->ga;
#line 126
        c |= 8;
      }
#line 129
      pgb = (s + j)->gb;
#line 131
      (s + j)->gb = ca;
#line 132
      if (pgb > (s + j)->gb) {
#line 133
        (s + j)->gb = pgb;
#line 134
        c |= 16;
      }
#line 136
      *(tracep + j) = (char )c;
#line 137
      pa = ca;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 141
    fprof2 -= stride___0;
#line 143
    ca = (s + 0)->a;
#line 145
    c = 1;
#line 146
    if (pga > pa) {
#line 147
      pa = pga;
#line 148
      c = 2;
    }
#line 150
    if (pgb > pa) {
#line 151
      pa = pgb;
#line 152
      c = 4;
    }
#line 155
    f = 0;
    {
#line 155
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 155
      if (! (f < fdim)) {
#line 155
        goto while_break___3;
      }
#line 157
      pa += (float )(*(fprof1 + f) * *(fprof2 + (f + fdim)));
#line 155
      f ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 160
    (s + 0)->a = pa;
#line 162
    (s + 0)->ga = - 3.40282346638528859812e+38F;
#line 164
    pgb = (s + 0)->gb;
#line 165
    (s + 0)->gb = ca;
#line 166
    if (pgb > (s + 0)->gb) {
#line 167
      (s + 0)->gb = pgb;
#line 168
      c |= 16;
    }
#line 170
    *(tracep + 0) = (char )c;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 174
  fprof1 -= stride___0;
#line 176
  tracep = *(trace + 0);
#line 177
  j = (int )len_b;
#line 179
  fprof2 += len_b * (int const   )stride___0;
#line 181
  pa = (s + j)->a;
#line 182
  pga = (s + j)->ga;
#line 183
  pgb = (s + j)->gb;
#line 184
  (s + j)->a = - 3.40282346638528859812e+38F;
#line 185
  (s + j)->ga = - 3.40282346638528859812e+38F;
#line 187
  (s + len_b)->gb = pa;
#line 188
  if (pgb > (s + len_b)->gb) {
#line 189
    (s + len_b)->gb = pgb;
  }
  {
#line 194
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 194
    j --;
#line 194
    if (! j) {
#line 194
      goto while_break___4;
    }
#line 196
    fprof2 -= stride___0;
#line 198
    ca = (s + j)->a;
#line 200
    c = 1;
#line 202
    if (pga > pa) {
#line 203
      pa = pga;
#line 204
      c = 2;
    }
#line 207
    if (pgb > pa) {
#line 208
      pa = pgb;
#line 209
      c = 4;
    }
#line 212
    f = 0;
    {
#line 212
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 212
      if (! (f < fdim)) {
#line 212
        goto while_break___5;
      }
#line 213
      pa += (float )(*(fprof1 + f) * *(fprof2 + (f + fdim)));
#line 212
      f ++;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 218
    (s + j)->a = pa;
#line 219
    pga = (s + j)->ga;
#line 220
    (s + j)->ga = (s + (j + 1))->a;
#line 221
    if ((s + (j + 1))->ga > (s + j)->ga) {
#line 222
      (s + j)->ga = (s + (j + 1))->ga;
#line 223
      c |= 8;
    }
#line 225
    pgb = (s + j)->gb;
#line 226
    (s + j)->gb = - 3.40282346638528859812e+38F;
#line 228
    *(tracep + j) = (char )c;
#line 229
    pa = ca;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 232
  fprof2 -= stride___0;
#line 234
  ca = (s + 0)->a;
#line 236
  c = 1;
#line 238
  if (pga > pa) {
#line 239
    pa = pga;
#line 240
    c = 2;
  }
#line 242
  if (pgb > pa) {
#line 243
    pa = pgb;
#line 244
    c = 4;
  }
#line 247
  f = 0;
  {
#line 247
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 247
    if (! (f < fdim)) {
#line 247
      goto while_break___6;
    }
#line 248
    pa += (float )(*(fprof1 + f) * *(fprof2 + (f + fdim)));
#line 247
    f ++;
  }
  while_break___6: /* CIL Label */ ;
  }
#line 252
  (s + 0)->a = pa;
#line 254
  (s + 0)->ga = (s + 1)->a;
#line 255
  if ((s + 1)->ga > (s + 0)->ga) {
#line 256
    (s + 0)->ga = (s + 1)->ga;
#line 257
    c |= 8;
  }
#line 260
  pgb = (s + 0)->gb;
#line 261
  (s + 0)->gb = ca;
#line 262
  if (pgb > (s + 0)->gb) {
#line 263
    (s + 0)->gb = pgb;
#line 264
    c |= 16;
  }
#line 266
  *(tracep + 0) = (char )c;
#line 268
  pgb = (s + 0)->gb;
#line 269
  c = 2;
#line 270
  if ((s + 0)->ga > pgb) {
#line 271
    pgb = (s + 0)->ga;
#line 272
    c = 1;
  }
#line 274
  if ((s + 0)->a >= pgb) {
#line 275
    pgb = (s + 0)->a;
#line 276
    c = 0;
  }
#line 280
  ca = (float )c;
#line 282
  i = 0;
#line 283
  j = 0;
#line 284
  f = 1;
  {
#line 285
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 285
    if (! ((int )*(*(trace + i) + j) < 32)) {
#line 285
      goto while_break___7;
    }
    {
#line 288
    if (f == 0) {
#line 288
      goto case_0;
    }
#line 311
    if (f == 1) {
#line 311
      goto case_1;
    }
#line 336
    if (f == 2) {
#line 336
      goto case_2;
    }
#line 287
    goto switch_break;
    case_0: /* CIL Label */ 
#line 289
    if ((int )*(*(trace + i) + j) & 2) {
#line 290
      f = 1;
#line 291
      if (i + 1 != (int )len_a) {
#line 292
        *(path + (c + 1)) |= 16;
      } else {
#line 295
        *(path + (c + 1)) |= 48;
      }
    } else
#line 297
    if ((int )*(*(trace + i) + j) & 4) {
#line 298
      f = 2;
#line 299
      if (j + 1 != (int )len_b) {
#line 300
        *(path + (c + 1)) |= 16;
      } else {
#line 303
        *(path + (c + 1)) |= 48;
      }
    }
#line 308
    i ++;
#line 309
    j ++;
#line 310
    goto switch_break;
    case_1: /* CIL Label */ 
#line 312
    if ((int )*(*(trace + i) + j) & 8) {
#line 313
      f = 1;
#line 314
      if (i != 0) {
#line 314
        if (i != (int )len_a) {
#line 316
          if (! (*(path + c) & 16)) {
#line 317
            *(path + c) |= 8;
          }
        } else {
#line 314
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 320
      if (! (*(path + c) & 16)) {
#line 321
        *(path + c) |= 40;
      }
    } else {
#line 325
      f = 0;
#line 326
      if (i != 0) {
#line 326
        if (i != (int )len_a) {
#line 328
          *(path + c) |= 4;
        } else {
#line 330
          *(path + c) |= 36;
        }
      } else {
#line 330
        *(path + c) |= 36;
      }
    }
#line 333
    *(path + c) |= 1;
#line 334
    j ++;
#line 335
    goto switch_break;
    case_2: /* CIL Label */ 
#line 337
    if ((int )*(*(trace + i) + j) & 16) {
#line 338
      f = 2;
#line 339
      if (j != 0) {
#line 339
        if (j != (int )len_b) {
#line 341
          if (! (*(path + c) & 16)) {
#line 342
            *(path + c) |= 8;
          }
        } else {
#line 339
          goto _L___0;
        }
      } else
      _L___0: /* CIL Label */ 
#line 345
      if (! (*(path + c) & 16)) {
#line 346
        *(path + c) |= 40;
      }
    } else {
#line 350
      f = 0;
#line 351
      if (j != 0) {
#line 351
        if (j != (int )len_b) {
#line 353
          *(path + c) |= 4;
        } else {
#line 355
          *(path + c) |= 36;
        }
      } else {
#line 355
        *(path + c) |= 36;
      }
    }
#line 359
    *(path + c) |= 2;
#line 360
    i ++;
#line 361
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 363
    c ++;
  }
  while_break___7: /* CIL Label */ ;
  }
#line 365
  *(path + 0) = c - 1;
#line 366
  *(path + c) = 3;
#line 367
  *(path + (c + 1)) = (int )pgb;
#line 368
  return (path);
}
}
#line 373 "/home/june/repo/benchmarks/collector/temp/kalign-2.03+20110620/kalign2_dp.c"
int *fpp_dyn(int *path , struct dp_matrix *dp , float const   *prof1 , float const   *prof2 ,
             float const   *fprof1 , float const   *fprof2 , int const   len_a , int const   len_b ,
             int fdim , int stride___0 ) 
{ 
  unsigned int freq[26] ;
  struct states *s ;
  char **trace ;
  char *tracep ;
  register float pa ;
  register float pga ;
  register float pgb ;
  register float ca ;
  register int i ;
  register int j ;
  register int c ;
  register int f ;
  int tmp ;
  int tmp___0 ;

  {
#line 377
  s = (struct states *)0;
#line 378
  trace = (char **)0;
#line 379
  tracep = (char *)0;
#line 380
  pa = (float )0;
#line 381
  pga = (float )0;
#line 382
  pgb = (float )0;
#line 383
  ca = (float )0;
#line 384
  i = 0;
#line 385
  j = 0;
#line 386
  c = 0;
#line 387
  f = 0;
#line 390
  s = dp->s;
#line 392
  trace = dp->tb;
#line 394
  *(*(trace + len_a) + len_b) = (char)32;
#line 396
  prof1 += len_a << 6;
#line 398
  fprof1 += len_a * (int const   )stride___0;
#line 401
  (s + len_b)->a = (float )0;
#line 402
  (s + len_b)->ga = - 3.40282346638528859812e+38F;
#line 403
  (s + len_b)->gb = - 3.40282346638528859812e+38F;
#line 405
  tracep = *(trace + len_a);
#line 407
  j = (int )len_b;
  {
#line 408
  while (1) {
    while_continue: /* CIL Label */ ;
#line 408
    j --;
#line 408
    if (! j) {
#line 408
      goto while_break;
    }
#line 409
    (s + j)->a = - 3.40282346638528859812e+38F;
#line 412
    (s + j)->ga = (s + (j + 1))->a + (float )*(prof2 + 29);
#line 413
    if ((s + (j + 1))->ga + (float )*(prof2 + 29) > (s + j)->ga) {
#line 414
      (s + j)->ga = (s + (j + 1))->ga + (float )*(prof2 + 29);
    }
#line 416
    (s + j)->gb = - 3.40282346638528859812e+38F;
#line 417
    *(tracep + j) = (char)8;
  }
  while_break: /* CIL Label */ ;
  }
#line 420
  (s + 0)->a = - 3.40282346638528859812e+38F;
#line 421
  (s + 0)->ga = - 3.40282346638528859812e+38F;
#line 422
  (s + 0)->gb = - 3.40282346638528859812e+38F;
#line 423
  i = (int )len_a;
  {
#line 424
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 424
    i --;
#line 424
    if (! i) {
#line 424
      goto while_break___0;
    }
#line 425
    prof1 -= 64;
#line 427
    fprof1 -= stride___0;
#line 429
    c = 1;
#line 430
    j = 26;
    {
#line 430
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 430
      tmp = j;
#line 430
      j --;
#line 430
      if (! tmp) {
#line 430
        goto while_break___1;
      }
#line 431
      if (*(prof1 + j)) {
#line 432
        freq[c] = (unsigned int )j;
#line 433
        c ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 436
    freq[0] = (unsigned int )c;
#line 438
    tracep = *(trace + i);
#line 439
    pa = (s + len_b)->a;
#line 440
    pga = (s + len_b)->ga;
#line 441
    pgb = (s + len_b)->gb;
#line 442
    (s + len_b)->a = - 3.40282346638528859812e+38F;
#line 443
    (s + len_b)->ga = - 3.40282346638528859812e+38F;
#line 446
    (s + len_b)->gb = pa + (float )*(prof1 + 29);
#line 447
    if (pgb + (float )*(prof1 + 29) > (s + len_b)->gb) {
#line 448
      (s + len_b)->gb = pgb + (float )*(prof1 + 29);
    }
#line 451
    *(tracep + len_b) = (char)16;
#line 453
    j = (int )len_b;
#line 454
    prof2 += len_b << 6;
#line 456
    fprof2 += len_b * (int const   )stride___0;
    {
#line 458
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 458
      j --;
#line 458
      if (! j) {
#line 458
        goto while_break___2;
      }
#line 459
      prof2 -= 64;
#line 461
      fprof2 -= stride___0;
#line 462
      ca = (s + j)->a;
#line 464
      c = 1;
#line 465
      pga += (float )*(prof2 + 91);
#line 465
      if (pga > pa) {
#line 466
        pa = pga;
#line 467
        c = 2;
      }
#line 469
      pgb += (float )*(prof1 + 91);
#line 469
      if (pgb > pa) {
#line 470
        pa = pgb;
#line 471
        c = 4;
      }
#line 474
      prof2 += 32;
#line 475
      f = (int )freq[0];
      {
#line 475
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 475
        f --;
#line 475
        if (! f) {
#line 475
          goto while_break___3;
        }
#line 476
        pa += (float )(*(prof1 + freq[f]) * *(prof2 + freq[f]));
      }
      while_break___3: /* CIL Label */ ;
      }
#line 478
      prof2 -= 32;
#line 480
      f = 0;
      {
#line 480
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 480
        if (! (f < fdim)) {
#line 480
          goto while_break___4;
        }
#line 482
        pa += (float )(*(fprof1 + f) * *(fprof2 + (f + fdim)));
#line 480
        f ++;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 485
      (s + j)->a = pa;
#line 487
      pga = (s + j)->ga;
#line 489
      (s + j)->ga = (s + (j + 1))->a + (float )*(prof2 + 27);
#line 490
      if ((s + (j + 1))->ga + (float )*(prof2 + 28) > (s + j)->ga) {
#line 491
        (s + j)->ga = (s + (j + 1))->ga + (float )*(prof2 + 28);
#line 492
        c |= 8;
      }
#line 495
      pgb = (s + j)->gb;
#line 497
      (s + j)->gb = ca + (float )*(prof1 + 27);
#line 498
      if (pgb + (float )*(prof1 + 28) > (s + j)->gb) {
#line 499
        (s + j)->gb = pgb + (float )*(prof1 + 28);
#line 500
        c |= 16;
      }
#line 502
      *(tracep + j) = (char )c;
#line 503
      pa = ca;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 507
    prof2 -= 64;
#line 509
    fprof2 -= stride___0;
#line 511
    ca = (s + 0)->a;
#line 513
    c = 1;
#line 514
    pga += (float )*(prof2 + 91);
#line 514
    if (pga > pa) {
#line 515
      pa = pga;
#line 516
      c = 2;
    }
#line 518
    pgb += (float )*(prof1 + 91);
#line 518
    if (pgb > pa) {
#line 519
      pa = pgb;
#line 520
      c = 4;
    }
#line 523
    prof2 += 32;
#line 524
    f = (int )freq[0];
    {
#line 524
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 524
      f --;
#line 524
      if (! f) {
#line 524
        goto while_break___5;
      }
#line 525
      pa += (float )(*(prof1 + freq[f]) * *(prof2 + freq[f]));
    }
    while_break___5: /* CIL Label */ ;
    }
#line 527
    prof2 -= 32;
#line 529
    f = 0;
    {
#line 529
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 529
      if (! (f < fdim)) {
#line 529
        goto while_break___6;
      }
#line 531
      pa += (float )(*(fprof1 + f) * *(fprof2 + (f + fdim)));
#line 529
      f ++;
    }
    while_break___6: /* CIL Label */ ;
    }
#line 534
    (s + 0)->a = pa;
#line 536
    (s + 0)->ga = - 3.40282346638528859812e+38F;
#line 538
    pgb = (s + 0)->gb;
#line 539
    (s + 0)->gb = (ca + (float )*(prof1 + 27)) + (float )*(prof1 + 29);
#line 540
    if (pgb + (float )*(prof1 + 29) > (s + 0)->gb) {
#line 541
      (s + 0)->gb = pgb + (float )*(prof1 + 29);
#line 542
      c |= 16;
    }
#line 544
    *(tracep + 0) = (char )c;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 547
  prof1 -= 64;
#line 549
  fprof1 -= stride___0;
#line 551
  c = 1;
#line 552
  j = 26;
  {
#line 552
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 552
    tmp___0 = j;
#line 552
    j --;
#line 552
    if (! tmp___0) {
#line 552
      goto while_break___7;
    }
#line 553
    if (*(prof1 + j)) {
#line 554
      freq[c] = (unsigned int )j;
#line 555
      c ++;
    }
  }
  while_break___7: /* CIL Label */ ;
  }
#line 558
  freq[0] = (unsigned int )c;
#line 560
  tracep = *(trace + 0);
#line 561
  j = (int )len_b;
#line 562
  prof2 += len_b << 6;
#line 564
  fprof2 += len_b * (int const   )stride___0;
#line 566
  pa = (s + j)->a;
#line 567
  pga = (s + j)->ga;
#line 568
  pgb = (s + j)->gb;
#line 569
  (s + j)->a = - 3.40282346638528859812e+38F;
#line 570
  (s + j)->ga = - 3.40282346638528859812e+38F;
#line 572
  (s + len_b)->gb = pa + (float )*(prof1 + 29);
#line 573
  if (pgb + (float )*(prof1 + 29) > (s + len_b)->gb) {
#line 574
    (s + len_b)->gb = pgb + (float )*(prof1 + 29);
  }
  {
#line 579
  while (1) {
    while_continue___8: /* CIL Label */ ;
#line 579
    j --;
#line 579
    if (! j) {
#line 579
      goto while_break___8;
    }
#line 580
    prof2 -= 64;
#line 582
    fprof2 -= stride___0;
#line 584
    ca = (s + j)->a;
#line 586
    c = 1;
#line 588
    pga += (float )*(prof2 + 91);
#line 588
    if (pga > pa) {
#line 589
      pa = pga;
#line 590
      c = 2;
    }
#line 593
    pgb += (float )*(prof1 + 91);
#line 593
    if (pgb > pa) {
#line 594
      pa = pgb;
#line 595
      c = 4;
    }
#line 598
    prof2 += 32;
#line 599
    f = (int )freq[0];
    {
#line 599
    while (1) {
      while_continue___9: /* CIL Label */ ;
#line 599
      f --;
#line 599
      if (! f) {
#line 599
        goto while_break___9;
      }
#line 600
      pa += (float )(*(prof1 + freq[f]) * *(prof2 + freq[f]));
    }
    while_break___9: /* CIL Label */ ;
    }
#line 602
    prof2 -= 32;
#line 605
    f = 0;
    {
#line 605
    while (1) {
      while_continue___10: /* CIL Label */ ;
#line 605
      if (! (f < fdim)) {
#line 605
        goto while_break___10;
      }
#line 606
      pa += (float )(*(fprof1 + f) * *(fprof2 + (f + fdim)));
#line 605
      f ++;
    }
    while_break___10: /* CIL Label */ ;
    }
#line 611
    (s + j)->a = pa;
#line 612
    pga = (s + j)->ga;
#line 613
    (s + j)->ga = ((s + (j + 1))->a + (float )*(prof2 + 27)) + (float )*(prof2 + 29);
#line 614
    if ((s + (j + 1))->ga + (float )*(prof2 + 29) > (s + j)->ga) {
#line 615
      (s + j)->ga = (s + (j + 1))->ga + (float )*(prof2 + 29);
#line 616
      c |= 8;
    }
#line 618
    pgb = (s + j)->gb;
#line 619
    (s + j)->gb = - 3.40282346638528859812e+38F;
#line 621
    *(tracep + j) = (char )c;
#line 622
    pa = ca;
  }
  while_break___8: /* CIL Label */ ;
  }
#line 624
  prof2 -= 64;
#line 626
  fprof2 -= stride___0;
#line 628
  ca = (s + 0)->a;
#line 630
  c = 1;
#line 632
  pga += (float )*(prof2 + 91);
#line 632
  if (pga > pa) {
#line 633
    pa = pga;
#line 634
    c = 2;
  }
#line 636
  pgb += (float )*(prof1 + 91);
#line 636
  if (pgb > pa) {
#line 637
    pa = pgb;
#line 638
    c = 4;
  }
#line 640
  prof2 += 32;
#line 641
  f = (int )freq[0];
  {
#line 641
  while (1) {
    while_continue___11: /* CIL Label */ ;
#line 641
    f --;
#line 641
    if (! f) {
#line 641
      goto while_break___11;
    }
#line 642
    pa += (float )(*(prof1 + freq[f]) * *(prof2 + freq[f]));
  }
  while_break___11: /* CIL Label */ ;
  }
#line 644
  prof2 -= 32;
#line 646
  f = 0;
  {
#line 646
  while (1) {
    while_continue___12: /* CIL Label */ ;
#line 646
    if (! (f < fdim)) {
#line 646
      goto while_break___12;
    }
#line 647
    pa += (float )(*(fprof1 + f) * *(fprof2 + (f + fdim)));
#line 646
    f ++;
  }
  while_break___12: /* CIL Label */ ;
  }
#line 651
  (s + 0)->a = pa;
#line 653
  (s + 0)->ga = ((s + 1)->a + (float )*(prof2 + 27)) + (float )*(prof2 + 29);
#line 654
  if ((s + 1)->ga + (float )*(prof2 + 29) > (s + 0)->ga) {
#line 655
    (s + 0)->ga = (s + 1)->ga + (float )*(prof2 + 29);
#line 656
    c |= 8;
  }
#line 659
  pgb = (s + 0)->gb;
#line 660
  (s + 0)->gb = (ca + (float )*(prof1 + 27)) + (float )*(prof1 + 29);
#line 661
  if (pgb + (float )*(prof1 + 29) > (s + 0)->gb) {
#line 662
    (s + 0)->gb = pgb + (float )*(prof1 + 29);
#line 663
    c |= 16;
  }
#line 665
  *(tracep + 0) = (char )c;
#line 667
  pgb = (s + 0)->gb;
#line 668
  c = 2;
#line 669
  if ((s + 0)->ga > pgb) {
#line 670
    pgb = (s + 0)->ga;
#line 671
    c = 1;
  }
#line 673
  if ((s + 0)->a >= pgb) {
#line 674
    pgb = (s + 0)->a;
#line 675
    c = 0;
  }
#line 679
  f = c;
#line 681
  i = 0;
#line 682
  j = 0;
#line 683
  c = 1;
  {
#line 684
  while (1) {
    while_continue___13: /* CIL Label */ ;
#line 684
    if (! ((int )*(*(trace + i) + j) < 32)) {
#line 684
      goto while_break___13;
    }
    {
#line 687
    if (f == 0) {
#line 687
      goto case_0;
    }
#line 710
    if (f == 1) {
#line 710
      goto case_1;
    }
#line 735
    if (f == 2) {
#line 735
      goto case_2;
    }
#line 686
    goto switch_break;
    case_0: /* CIL Label */ 
#line 688
    if ((int )*(*(trace + i) + j) & 2) {
#line 689
      f = 1;
#line 690
      if (i + 1 != (int )len_a) {
#line 691
        *(path + (c + 1)) |= 16;
      } else {
#line 694
        *(path + (c + 1)) |= 48;
      }
    } else
#line 696
    if ((int )*(*(trace + i) + j) & 4) {
#line 697
      f = 2;
#line 698
      if (j + 1 != (int )len_b) {
#line 699
        *(path + (c + 1)) |= 16;
      } else {
#line 702
        *(path + (c + 1)) |= 48;
      }
    }
#line 707
    i ++;
#line 708
    j ++;
#line 709
    goto switch_break;
    case_1: /* CIL Label */ 
#line 711
    if ((int )*(*(trace + i) + j) & 8) {
#line 712
      f = 1;
#line 713
      if (i != 0) {
#line 713
        if (i != (int )len_a) {
#line 715
          if (! (*(path + c) & 16)) {
#line 716
            *(path + c) |= 8;
          }
        } else {
#line 713
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 719
      if (! (*(path + c) & 16)) {
#line 720
        *(path + c) |= 40;
      }
    } else {
#line 724
      f = 0;
#line 725
      if (i != 0) {
#line 725
        if (i != (int )len_a) {
#line 727
          *(path + c) |= 4;
        } else {
#line 729
          *(path + c) |= 36;
        }
      } else {
#line 729
        *(path + c) |= 36;
      }
    }
#line 732
    *(path + c) |= 1;
#line 733
    j ++;
#line 734
    goto switch_break;
    case_2: /* CIL Label */ 
#line 736
    if ((int )*(*(trace + i) + j) & 16) {
#line 737
      f = 2;
#line 738
      if (j != 0) {
#line 738
        if (j != (int )len_b) {
#line 740
          if (! (*(path + c) & 16)) {
#line 741
            *(path + c) |= 8;
          }
        } else {
#line 738
          goto _L___0;
        }
      } else
      _L___0: /* CIL Label */ 
#line 744
      if (! (*(path + c) & 16)) {
#line 745
        *(path + c) |= 40;
      }
    } else {
#line 749
      f = 0;
#line 750
      if (j != 0) {
#line 750
        if (j != (int )len_b) {
#line 752
          *(path + c) |= 4;
        } else {
#line 754
          *(path + c) |= 36;
        }
      } else {
#line 754
        *(path + c) |= 36;
      }
    }
#line 758
    *(path + c) |= 2;
#line 759
    i ++;
#line 760
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 762
    c ++;
  }
  while_break___13: /* CIL Label */ ;
  }
#line 764
  *(path + 0) = c - 1;
#line 765
  *(path + c) = 3;
#line 766
  *(path + (c + 1)) = (int )pgb;
#line 767
  return (path);
}
}
#line 2366 "/home/june/repo/benchmarks/collector/temp/kalign-2.03+20110620/kalign2_dp.c"
int *pp_dyn(int *path , struct dp_matrix *dp , float const   *prof1 , float const   *prof2 ,
            int const   len_a , int const   len_b ) 
{ 
  unsigned int freq[26] ;
  struct states *s ;
  char **trace ;
  char *tracep ;
  register float pa ;
  register float pga ;
  register float pgb ;
  register float ca ;
  register int i ;
  register int j ;
  register int c ;
  register int f ;
  int tmp ;
  int tmp___0 ;

  {
#line 2370
  s = (struct states *)0;
#line 2371
  trace = (char **)0;
#line 2372
  tracep = (char *)0;
#line 2373
  pa = (float )0;
#line 2374
  pga = (float )0;
#line 2375
  pgb = (float )0;
#line 2376
  ca = (float )0;
#line 2377
  i = 0;
#line 2378
  j = 0;
#line 2379
  c = 0;
#line 2380
  f = 0;
#line 2382
  s = dp->s;
#line 2384
  trace = dp->tb;
#line 2386
  *(*(trace + len_a) + len_b) = (char)32;
#line 2388
  prof1 += len_a << 6;
#line 2390
  (s + len_b)->a = (float )0.0;
#line 2391
  (s + len_b)->ga = - 3.40282346638528859812e+38F;
#line 2392
  (s + len_b)->gb = - 3.40282346638528859812e+38F;
#line 2394
  tracep = *(trace + len_a);
#line 2396
  j = (int )len_b;
  {
#line 2397
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2397
    j --;
#line 2397
    if (! j) {
#line 2397
      goto while_break;
    }
#line 2398
    (s + j)->a = - 3.40282346638528859812e+38F;
#line 2400
    (s + j)->ga = (s + (j + 1))->a + (float )*(prof2 + 29);
#line 2401
    if ((s + (j + 1))->ga + (float )*(prof2 + 29) > (s + j)->ga) {
#line 2402
      (s + j)->ga = (s + (j + 1))->ga + (float )*(prof2 + 29);
    }
#line 2404
    (s + j)->gb = - 3.40282346638528859812e+38F;
#line 2405
    *(tracep + j) = (char)8;
  }
  while_break: /* CIL Label */ ;
  }
#line 2408
  (s + 0)->a = - 3.40282346638528859812e+38F;
#line 2409
  (s + 0)->ga = - 3.40282346638528859812e+38F;
#line 2410
  (s + 0)->gb = - 3.40282346638528859812e+38F;
#line 2411
  i = (int )len_a;
  {
#line 2412
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2412
    i --;
#line 2412
    if (! i) {
#line 2412
      goto while_break___0;
    }
#line 2413
    prof1 -= 64;
#line 2415
    c = 1;
#line 2416
    j = 26;
    {
#line 2416
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 2416
      tmp = j;
#line 2416
      j --;
#line 2416
      if (! tmp) {
#line 2416
        goto while_break___1;
      }
#line 2417
      if (*(prof1 + j)) {
#line 2418
        freq[c] = (unsigned int )j;
#line 2419
        c ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 2422
    freq[0] = (unsigned int )c;
#line 2424
    tracep = *(trace + i);
#line 2425
    pa = (s + len_b)->a;
#line 2426
    pga = (s + len_b)->ga;
#line 2427
    pgb = (s + len_b)->gb;
#line 2428
    (s + len_b)->a = - 3.40282346638528859812e+38F;
#line 2429
    (s + len_b)->ga = - 3.40282346638528859812e+38F;
#line 2431
    (s + len_b)->gb = pa + (float )*(prof1 + 29);
#line 2432
    if (pgb + (float )*(prof1 + 29) > (s + len_b)->gb) {
#line 2433
      (s + len_b)->gb = pgb + (float )*(prof1 + 29);
    }
#line 2436
    *(tracep + len_b) = (char)16;
#line 2438
    j = (int )len_b;
#line 2439
    prof2 += len_b << 6;
    {
#line 2440
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 2440
      j --;
#line 2440
      if (! j) {
#line 2440
        goto while_break___2;
      }
#line 2441
      prof2 -= 64;
#line 2442
      ca = (s + j)->a;
#line 2444
      c = 1;
#line 2445
      pga += (float )*(prof2 + 91);
#line 2445
      if (pga > pa) {
#line 2446
        pa = pga;
#line 2447
        c = 2;
      }
#line 2449
      pgb += (float )*(prof1 + 91);
#line 2449
      if (pgb > pa) {
#line 2450
        pa = pgb;
#line 2451
        c = 4;
      }
#line 2454
      prof2 += 32;
#line 2455
      f = (int )freq[0];
      {
#line 2455
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 2455
        f --;
#line 2455
        if (! f) {
#line 2455
          goto while_break___3;
        }
#line 2456
        pa += (float )(*(prof1 + freq[f]) * *(prof2 + freq[f]));
      }
      while_break___3: /* CIL Label */ ;
      }
#line 2458
      prof2 -= 32;
#line 2460
      (s + j)->a = pa;
#line 2462
      pga = (s + j)->ga;
#line 2464
      (s + j)->ga = (s + (j + 1))->a + (float )*(prof2 + 27);
#line 2465
      if ((s + (j + 1))->ga + (float )*(prof2 + 28) > (s + j)->ga) {
#line 2466
        (s + j)->ga = (s + (j + 1))->ga + (float )*(prof2 + 28);
#line 2467
        c |= 8;
      }
#line 2470
      pgb = (s + j)->gb;
#line 2472
      (s + j)->gb = ca + (float )*(prof1 + 27);
#line 2473
      if (pgb + (float )*(prof1 + 28) > (s + j)->gb) {
#line 2474
        (s + j)->gb = pgb + (float )*(prof1 + 28);
#line 2475
        c |= 16;
      }
#line 2477
      *(tracep + j) = (char )c;
#line 2478
      pa = ca;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 2482
    prof2 -= 64;
#line 2484
    ca = (s + 0)->a;
#line 2486
    c = 1;
#line 2487
    pga += (float )*(prof2 + 91);
#line 2487
    if (pga > pa) {
#line 2488
      pa = pga;
#line 2489
      c = 2;
    }
#line 2491
    pgb += (float )*(prof1 + 91);
#line 2491
    if (pgb > pa) {
#line 2492
      pa = pgb;
#line 2493
      c = 4;
    }
#line 2496
    prof2 += 32;
#line 2497
    f = (int )freq[0];
    {
#line 2497
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 2497
      f --;
#line 2497
      if (! f) {
#line 2497
        goto while_break___4;
      }
#line 2498
      pa += (float )(*(prof1 + freq[f]) * *(prof2 + freq[f]));
    }
    while_break___4: /* CIL Label */ ;
    }
#line 2500
    prof2 -= 32;
#line 2502
    (s + 0)->a = pa;
#line 2504
    (s + 0)->ga = - 3.40282346638528859812e+38F;
#line 2506
    pgb = (s + 0)->gb;
#line 2507
    (s + 0)->gb = (ca + (float )*(prof1 + 27)) + (float )*(prof1 + 29);
#line 2508
    if (pgb + (float )*(prof1 + 29) > (s + 0)->gb) {
#line 2509
      (s + 0)->gb = pgb + (float )*(prof1 + 29);
#line 2510
      c |= 16;
    }
#line 2512
    *(tracep + 0) = (char )c;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2515
  prof1 -= 64;
#line 2517
  c = 1;
#line 2518
  j = 26;
  {
#line 2518
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 2518
    tmp___0 = j;
#line 2518
    j --;
#line 2518
    if (! tmp___0) {
#line 2518
      goto while_break___5;
    }
#line 2519
    if (*(prof1 + j)) {
#line 2520
      freq[c] = (unsigned int )j;
#line 2521
      c ++;
    }
  }
  while_break___5: /* CIL Label */ ;
  }
#line 2524
  freq[0] = (unsigned int )c;
#line 2526
  tracep = *(trace + 0);
#line 2527
  j = (int )len_b;
#line 2528
  prof2 += len_b << 6;
#line 2529
  pa = (s + j)->a;
#line 2530
  pga = (s + j)->ga;
#line 2531
  pgb = (s + j)->gb;
#line 2532
  (s + j)->a = - 3.40282346638528859812e+38F;
#line 2533
  (s + j)->ga = - 3.40282346638528859812e+38F;
#line 2535
  (s + len_b)->gb = pa + (float )*(prof1 + 29);
#line 2536
  if (pgb + (float )*(prof1 + 29) > (s + len_b)->gb) {
#line 2537
    (s + len_b)->gb = pgb + (float )*(prof1 + 29);
  }
  {
#line 2542
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 2542
    j --;
#line 2542
    if (! j) {
#line 2542
      goto while_break___6;
    }
#line 2543
    prof2 -= 64;
#line 2544
    ca = (s + j)->a;
#line 2546
    c = 1;
#line 2548
    pga += (float )*(prof2 + 91);
#line 2548
    if (pga > pa) {
#line 2549
      pa = pga;
#line 2550
      c = 2;
    }
#line 2553
    pgb += (float )*(prof1 + 91);
#line 2553
    if (pgb > pa) {
#line 2554
      pa = pgb;
#line 2555
      c = 4;
    }
#line 2558
    prof2 += 32;
#line 2560
    f = (int )freq[0];
    {
#line 2560
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 2560
      f --;
#line 2560
      if (! f) {
#line 2560
        goto while_break___7;
      }
#line 2561
      pa += (float )(*(prof1 + freq[f]) * *(prof2 + freq[f]));
    }
    while_break___7: /* CIL Label */ ;
    }
#line 2563
    prof2 -= 32;
#line 2565
    (s + j)->a = pa;
#line 2566
    pga = (s + j)->ga;
#line 2567
    (s + j)->ga = ((s + (j + 1))->a + (float )*(prof2 + 27)) + (float )*(prof2 + 29);
#line 2568
    if ((s + (j + 1))->ga + (float )*(prof2 + 29) > (s + j)->ga) {
#line 2569
      (s + j)->ga = (s + (j + 1))->ga + (float )*(prof2 + 29);
#line 2570
      c |= 8;
    }
#line 2572
    pgb = (s + j)->gb;
#line 2573
    (s + j)->gb = - 3.40282346638528859812e+38F;
#line 2575
    *(tracep + j) = (char )c;
#line 2576
    pa = ca;
  }
  while_break___6: /* CIL Label */ ;
  }
#line 2578
  prof2 -= 64;
#line 2580
  ca = (s + 0)->a;
#line 2582
  c = 1;
#line 2584
  pga += (float )*(prof2 + 91);
#line 2584
  if (pga > pa) {
#line 2585
    pa = pga;
#line 2586
    c = 2;
  }
#line 2588
  pgb += (float )*(prof1 + 91);
#line 2588
  if (pgb > pa) {
#line 2589
    pa = pgb;
#line 2590
    c = 4;
  }
#line 2592
  prof2 += 32;
#line 2593
  f = (int )freq[0];
  {
#line 2593
  while (1) {
    while_continue___8: /* CIL Label */ ;
#line 2593
    f --;
#line 2593
    if (! f) {
#line 2593
      goto while_break___8;
    }
#line 2594
    pa += (float )(*(prof1 + freq[f]) * *(prof2 + freq[f]));
  }
  while_break___8: /* CIL Label */ ;
  }
#line 2596
  prof2 -= 32;
#line 2598
  (s + 0)->a = pa;
#line 2600
  (s + 0)->ga = ((s + 1)->a + (float )*(prof2 + 27)) + (float )*(prof2 + 29);
#line 2601
  if ((s + 1)->ga + (float )*(prof2 + 29) > (s + 0)->ga) {
#line 2602
    (s + 0)->ga = (s + 1)->ga + (float )*(prof2 + 29);
#line 2603
    c |= 8;
  }
#line 2606
  pgb = (s + 0)->gb;
#line 2607
  (s + 0)->gb = (ca + (float )*(prof1 + 27)) + (float )*(prof1 + 29);
#line 2608
  if (pgb + (float )*(prof1 + 29) > (s + 0)->gb) {
#line 2609
    (s + 0)->gb = pgb + (float )*(prof1 + 29);
#line 2610
    c |= 16;
  }
#line 2612
  *(tracep + 0) = (char )c;
#line 2614
  pgb = (s + 0)->gb;
#line 2615
  c = 2;
#line 2616
  if ((s + 0)->ga > pgb) {
#line 2617
    pgb = (s + 0)->ga;
#line 2618
    c = 1;
  }
#line 2620
  if ((s + 0)->a >= pgb) {
#line 2621
    pgb = (s + 0)->a;
#line 2622
    c = 0;
  }
#line 2626
  f = c;
#line 2628
  i = 0;
#line 2629
  j = 0;
#line 2630
  c = 1;
  {
#line 2631
  while (1) {
    while_continue___9: /* CIL Label */ ;
#line 2631
    if (! ((int )*(*(trace + i) + j) < 32)) {
#line 2631
      goto while_break___9;
    }
    {
#line 2634
    if (f == 0) {
#line 2634
      goto case_0;
    }
#line 2657
    if (f == 1) {
#line 2657
      goto case_1;
    }
#line 2682
    if (f == 2) {
#line 2682
      goto case_2;
    }
#line 2633
    goto switch_break;
    case_0: /* CIL Label */ 
#line 2635
    if ((int )*(*(trace + i) + j) & 2) {
#line 2636
      f = 1;
#line 2637
      if (i + 1 != (int )len_a) {
#line 2638
        *(path + (c + 1)) |= 16;
      } else {
#line 2641
        *(path + (c + 1)) |= 48;
      }
    } else
#line 2643
    if ((int )*(*(trace + i) + j) & 4) {
#line 2644
      f = 2;
#line 2645
      if (j + 1 != (int )len_b) {
#line 2646
        *(path + (c + 1)) |= 16;
      } else {
#line 2649
        *(path + (c + 1)) |= 48;
      }
    }
#line 2654
    i ++;
#line 2655
    j ++;
#line 2656
    goto switch_break;
    case_1: /* CIL Label */ 
#line 2658
    if ((int )*(*(trace + i) + j) & 8) {
#line 2659
      f = 1;
#line 2660
      if (i != 0) {
#line 2660
        if (i != (int )len_a) {
#line 2662
          if (! (*(path + c) & 16)) {
#line 2663
            *(path + c) |= 8;
          }
        } else {
#line 2660
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 2666
      if (! (*(path + c) & 16)) {
#line 2667
        *(path + c) |= 40;
      }
    } else {
#line 2671
      f = 0;
#line 2672
      if (i != 0) {
#line 2672
        if (i != (int )len_a) {
#line 2674
          *(path + c) |= 4;
        } else {
#line 2676
          *(path + c) |= 36;
        }
      } else {
#line 2676
        *(path + c) |= 36;
      }
    }
#line 2679
    *(path + c) |= 1;
#line 2680
    j ++;
#line 2681
    goto switch_break;
    case_2: /* CIL Label */ 
#line 2683
    if ((int )*(*(trace + i) + j) & 16) {
#line 2684
      f = 2;
#line 2685
      if (j != 0) {
#line 2685
        if (j != (int )len_b) {
#line 2687
          if (! (*(path + c) & 16)) {
#line 2688
            *(path + c) |= 8;
          }
        } else {
#line 2685
          goto _L___0;
        }
      } else
      _L___0: /* CIL Label */ 
#line 2691
      if (! (*(path + c) & 16)) {
#line 2692
        *(path + c) |= 40;
      }
    } else {
#line 2696
      f = 0;
#line 2697
      if (j != 0) {
#line 2697
        if (j != (int )len_b) {
#line 2699
          *(path + c) |= 4;
        } else {
#line 2701
          *(path + c) |= 36;
        }
      } else {
#line 2701
        *(path + c) |= 36;
      }
    }
#line 2705
    *(path + c) |= 2;
#line 2706
    i ++;
#line 2707
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 2709
    c ++;
  }
  while_break___9: /* CIL Label */ ;
  }
#line 2711
  *(path + 0) = c - 1;
#line 2712
  *(path + c) = 3;
#line 2713
  *(path + (c + 1)) = (int )pgb;
#line 2714
  return (path);
}
}
#line 2718 "/home/june/repo/benchmarks/collector/temp/kalign-2.03+20110620/kalign2_dp.c"
int *ps_dyn(int *path , struct dp_matrix *dp , float const   *prof1 , int const   *seq2 ,
            int const   len_a , int const   len_b , int sip ) 
{ 
  struct states *s ;
  char **trace ;
  char *tracep ;
  register float pa ;
  register float pga ;
  register float pgb ;
  register float ca ;
  register int i ;
  register int j ;
  register int c ;
  register int f ;
  float open ;
  float ext ;

  {
#line 2720
  s = (struct states *)0;
#line 2721
  trace = (char **)0;
#line 2722
  tracep = (char *)0;
#line 2723
  pa = (float )0;
#line 2724
  pga = (float )0;
#line 2725
  pgb = (float )0;
#line 2726
  ca = (float )0;
#line 2727
  i = 0;
#line 2728
  j = 0;
#line 2729
  c = 0;
#line 2730
  f = 0;
#line 2732
  open = gpo * (float )sip;
#line 2733
  ext = gpe * (float )sip;
#line 2735
  s = dp->s;
#line 2737
  trace = dp->tb;
#line 2739
  *(*(trace + len_a) + len_b) = (char)32;
#line 2741
  prof1 += len_a << 6;
#line 2743
  (s + len_b)->a = (float )0.0;
#line 2744
  (s + len_b)->ga = - 3.40282346638528859812e+38F;
#line 2745
  (s + len_b)->gb = - 3.40282346638528859812e+38F;
#line 2747
  tracep = *(trace + len_a);
#line 2748
  j = (int )len_b;
  {
#line 2751
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2751
    j --;
#line 2751
    if (! j) {
#line 2751
      goto while_break;
    }
#line 2752
    (s + j)->a = - 3.40282346638528859812e+38F;
#line 2755
    (s + j)->ga = (s + (j + 1))->a - tgpe;
#line 2756
    if ((s + (j + 1))->ga - tgpe > (s + j)->ga) {
#line 2757
      (s + j)->ga = (s + (j + 1))->ga - tgpe;
    }
#line 2760
    (s + j)->gb = - 3.40282346638528859812e+38F;
#line 2761
    *(tracep + j) = (char)8;
  }
  while_break: /* CIL Label */ ;
  }
#line 2764
  (s + 0)->a = - 3.40282346638528859812e+38F;
#line 2765
  (s + 0)->ga = - 3.40282346638528859812e+38F;
#line 2766
  (s + 0)->gb = - 3.40282346638528859812e+38F;
#line 2767
  i = (int )len_a;
  {
#line 2768
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2768
    i --;
#line 2768
    if (! i) {
#line 2768
      goto while_break___0;
    }
#line 2769
    prof1 -= 64;
#line 2771
    tracep = *(trace + i);
#line 2772
    pa = (s + len_b)->a;
#line 2773
    pga = (s + len_b)->ga;
#line 2774
    pgb = (s + len_b)->gb;
#line 2775
    (s + len_b)->a = - 3.40282346638528859812e+38F;
#line 2776
    (s + len_b)->ga = - 3.40282346638528859812e+38F;
#line 2778
    (s + len_b)->gb = pa + (float )*(prof1 + 29);
#line 2779
    if (pgb + (float )*(prof1 + 29) > (s + len_b)->gb) {
#line 2780
      (s + len_b)->gb = pgb + (float )*(prof1 + 29);
    }
#line 2783
    *(tracep + len_b) = (char)16;
#line 2785
    j = (int )len_b;
    {
#line 2787
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 2787
      j --;
#line 2787
      if (! j) {
#line 2787
        goto while_break___1;
      }
#line 2789
      ca = (s + j)->a;
#line 2791
      c = 1;
#line 2792
      pga -= open;
#line 2792
      if (pga > pa) {
#line 2793
        pa = pga;
#line 2794
        c = 2;
      }
#line 2796
      pgb += (float )*(prof1 + 91);
#line 2796
      if (pgb > pa) {
#line 2797
        pa = pgb;
#line 2798
        c = 4;
      }
#line 2801
      pa += (float )*(prof1 + (32 + (int )*(seq2 + j)));
#line 2803
      (s + j)->a = pa;
#line 2805
      pga = (s + j)->ga;
#line 2807
      (s + j)->ga = (s + (j + 1))->a - open;
#line 2808
      if ((s + (j + 1))->ga - ext > (s + j)->ga) {
#line 2809
        (s + j)->ga = (s + (j + 1))->ga - ext;
#line 2810
        c |= 8;
      }
#line 2813
      pgb = (s + j)->gb;
#line 2815
      (s + j)->gb = ca + (float )*(prof1 + 27);
#line 2816
      if (pgb + (float )*(prof1 + 28) > (s + j)->gb) {
#line 2817
        (s + j)->gb = pgb + (float )*(prof1 + 28);
#line 2818
        c |= 16;
      }
#line 2820
      *(tracep + j) = (char )c;
#line 2821
      pa = ca;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 2826
    ca = (s + 0)->a;
#line 2828
    c = 1;
#line 2829
    pga -= open;
#line 2829
    if (pga > pa) {
#line 2830
      pa = pga;
#line 2831
      c = 2;
    }
#line 2833
    pgb += (float )*(prof1 + 91);
#line 2833
    if (pgb > pa) {
#line 2834
      pa = pgb;
#line 2835
      c = 4;
    }
#line 2837
    pa += (float )*(prof1 + (32 + (int )*(seq2 + 0)));
#line 2838
    (s + 0)->a = pa;
#line 2840
    (s + 0)->ga = - 3.40282346638528859812e+38F;
#line 2842
    pgb = (s + 0)->gb;
#line 2843
    (s + 0)->gb = (ca + (float )*(prof1 + 27)) + (float )*(prof1 + 29);
#line 2844
    if (pgb + (float )*(prof1 + 29) > (s + 0)->gb) {
#line 2845
      (s + 0)->gb = pgb + (float )*(prof1 + 29);
#line 2846
      c |= 16;
    }
#line 2848
    *(tracep + 0) = (char )c;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2851
  prof1 -= 64;
#line 2855
  tracep = *(trace + 0);
#line 2856
  j = (int )len_b;
#line 2857
  pa = (s + j)->a;
#line 2858
  pga = (s + j)->ga;
#line 2859
  pgb = (s + j)->gb;
#line 2860
  (s + j)->a = - 3.40282346638528859812e+38F;
#line 2861
  (s + j)->ga = - 3.40282346638528859812e+38F;
#line 2863
  (s + len_b)->gb = pa + (float )*(prof1 + 29);
#line 2864
  if (pgb + (float )*(prof1 + 29) > (s + len_b)->gb) {
#line 2865
    (s + len_b)->gb = pgb + (float )*(prof1 + 29);
  }
  {
#line 2869
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 2869
    j --;
#line 2869
    if (! j) {
#line 2869
      goto while_break___2;
    }
#line 2871
    ca = (s + j)->a;
#line 2873
    c = 1;
#line 2875
    pga -= open;
#line 2875
    if (pga > pa) {
#line 2876
      pa = pga;
#line 2877
      c = 2;
    }
#line 2880
    pgb += (float )*(prof1 + 91);
#line 2880
    if (pgb > pa) {
#line 2881
      pa = pgb;
#line 2882
      c = 4;
    }
#line 2884
    pa += (float )*(prof1 + (32 + (int )*(seq2 + j)));
#line 2885
    (s + j)->a = pa;
#line 2886
    pga = (s + j)->ga;
#line 2887
    (s + j)->ga = (s + (j + 1))->a - (open + tgpe);
#line 2888
    if ((s + (j + 1))->ga - tgpe > (s + j)->ga) {
#line 2889
      (s + j)->ga = (s + (j + 1))->ga - tgpe;
#line 2890
      c |= 8;
    }
#line 2892
    pgb = (s + j)->gb;
#line 2893
    (s + j)->gb = - 3.40282346638528859812e+38F;
#line 2895
    *(tracep + j) = (char )c;
#line 2896
    pa = ca;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 2900
  ca = (s + 0)->a;
#line 2902
  c = 1;
#line 2904
  pga -= open;
#line 2904
  if (pga > pa) {
#line 2905
    pa = pga;
#line 2906
    c = 2;
  }
#line 2908
  pgb += (float )*(prof1 + 91);
#line 2908
  if (pgb > pa) {
#line 2909
    pa = pgb;
#line 2910
    c = 4;
  }
#line 2912
  pa += (float )*(prof1 + (32 + (int )*(seq2 + 0)));
#line 2913
  (s + 0)->a = pa;
#line 2915
  (s + 0)->ga = (s + 1)->a - (open + tgpe);
#line 2916
  if ((s + 1)->ga - tgpe > (s + 0)->ga) {
#line 2917
    (s + 0)->ga = (s + 1)->ga - tgpe;
#line 2918
    c |= 8;
  }
#line 2921
  pgb = (s + 0)->gb;
#line 2922
  (s + 0)->gb = (ca + (float )*(prof1 + 27)) + (float )*(prof1 + 29);
#line 2923
  if (pgb + (float )*(prof1 + 29) > (s + 0)->gb) {
#line 2924
    (s + 0)->gb = pgb + (float )*(prof1 + 29);
#line 2925
    c |= 16;
  }
#line 2927
  *(tracep + 0) = (char )c;
#line 2930
  pgb = (s + 0)->gb;
#line 2931
  c = 2;
#line 2932
  if ((s + 0)->ga > pgb) {
#line 2933
    pgb = (s + 0)->ga;
#line 2934
    c = 1;
  }
#line 2936
  if ((s + 0)->a >= pgb) {
#line 2937
    pgb = (s + 0)->a;
#line 2938
    c = 0;
  }
#line 2942
  f = c;
#line 2944
  i = 0;
#line 2945
  j = 0;
#line 2946
  c = 1;
  {
#line 2947
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 2947
    if (! ((int )*(*(trace + i) + j) < 32)) {
#line 2947
      goto while_break___3;
    }
    {
#line 2950
    if (f == 0) {
#line 2950
      goto case_0;
    }
#line 2973
    if (f == 1) {
#line 2973
      goto case_1;
    }
#line 2998
    if (f == 2) {
#line 2998
      goto case_2;
    }
#line 2949
    goto switch_break;
    case_0: /* CIL Label */ 
#line 2951
    if ((int )*(*(trace + i) + j) & 2) {
#line 2952
      f = 1;
#line 2953
      if (i + 1 != (int )len_a) {
#line 2954
        *(path + (c + 1)) |= 16;
      } else {
#line 2957
        *(path + (c + 1)) |= 48;
      }
    } else
#line 2959
    if ((int )*(*(trace + i) + j) & 4) {
#line 2960
      f = 2;
#line 2961
      if (j + 1 != (int )len_b) {
#line 2962
        *(path + (c + 1)) |= 16;
      } else {
#line 2965
        *(path + (c + 1)) |= 48;
      }
    }
#line 2970
    i ++;
#line 2971
    j ++;
#line 2972
    goto switch_break;
    case_1: /* CIL Label */ 
#line 2974
    if ((int )*(*(trace + i) + j) & 8) {
#line 2975
      f = 1;
#line 2976
      if (i != 0) {
#line 2976
        if (i != (int )len_a) {
#line 2978
          if (! (*(path + c) & 16)) {
#line 2979
            *(path + c) |= 8;
          }
        } else {
#line 2976
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 2982
      if (! (*(path + c) & 16)) {
#line 2983
        *(path + c) |= 40;
      }
    } else {
#line 2987
      f = 0;
#line 2988
      if (i != 0) {
#line 2988
        if (i != (int )len_a) {
#line 2990
          *(path + c) |= 4;
        } else {
#line 2992
          *(path + c) |= 36;
        }
      } else {
#line 2992
        *(path + c) |= 36;
      }
    }
#line 2995
    *(path + c) |= 1;
#line 2996
    j ++;
#line 2997
    goto switch_break;
    case_2: /* CIL Label */ 
#line 2999
    if ((int )*(*(trace + i) + j) & 16) {
#line 3000
      f = 2;
#line 3001
      if (j != 0) {
#line 3001
        if (j != (int )len_b) {
#line 3003
          if (! (*(path + c) & 16)) {
#line 3004
            *(path + c) |= 8;
          }
        } else {
#line 3001
          goto _L___0;
        }
      } else
      _L___0: /* CIL Label */ 
#line 3007
      if (! (*(path + c) & 16)) {
#line 3008
        *(path + c) |= 40;
      }
    } else {
#line 3012
      f = 0;
#line 3013
      if (j != 0) {
#line 3013
        if (j != (int )len_b) {
#line 3015
          *(path + c) |= 4;
        } else {
#line 3017
          *(path + c) |= 36;
        }
      } else {
#line 3017
        *(path + c) |= 36;
      }
    }
#line 3021
    *(path + c) |= 2;
#line 3022
    i ++;
#line 3023
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 3025
    c ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 3027
  *(path + 0) = c - 1;
#line 3028
  *(path + c) = 3;
#line 3029
  *(path + (c + 1)) = (int )pgb;
#line 3030
  return (path);
}
}
#line 3033 "/home/june/repo/benchmarks/collector/temp/kalign-2.03+20110620/kalign2_dp.c"
int *ss_dyn(float **subm , int *path , struct dp_matrix *dp , int const   *seq1 ,
            int const   *seq2 , int const   len_a , int const   len_b ) 
{ 
  struct states *s ;
  float const   *subp ;
  char **trace ;
  char *tracep ;
  register float pa ;
  register float pga ;
  register float pgb ;
  register float ca ;
  register int i ;
  register int j ;
  register int c ;
  register int f ;

  {
#line 3035
  s = (struct states *)0;
#line 3036
  subp = (float const   *)0;
#line 3037
  trace = (char **)0;
#line 3038
  tracep = (char *)0;
#line 3039
  pa = (float )0;
#line 3040
  pga = (float )0;
#line 3041
  pgb = (float )0;
#line 3042
  ca = (float )0;
#line 3043
  i = 0;
#line 3044
  j = 0;
#line 3045
  c = 0;
#line 3046
  f = 0;
#line 3048
  s = dp->s;
#line 3050
  trace = dp->tb;
#line 3052
  *(*(trace + len_a) + len_b) = (char)32;
#line 3054
  (s + len_b)->a = (float )0.0;
#line 3055
  (s + len_b)->ga = - 3.40282346638528859812e+38F;
#line 3056
  (s + len_b)->gb = - 3.40282346638528859812e+38F;
#line 3059
  tracep = *(trace + len_a);
#line 3060
  j = (int )len_b;
  {
#line 3063
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3063
    j --;
#line 3063
    if (! j) {
#line 3063
      goto while_break;
    }
#line 3064
    (s + j)->a = - 3.40282346638528859812e+38F;
#line 3066
    (s + j)->ga = (s + (j + 1))->a - tgpe;
#line 3067
    if ((s + (j + 1))->ga - tgpe > (s + j)->ga) {
#line 3068
      (s + j)->ga = (s + (j + 1))->ga - tgpe;
    }
#line 3073
    (s + j)->gb = - 3.40282346638528859812e+38F;
#line 3074
    *(tracep + j) = (char)8;
  }
  while_break: /* CIL Label */ ;
  }
#line 3077
  (s + 0)->a = - 3.40282346638528859812e+38F;
#line 3078
  (s + 0)->ga = - 3.40282346638528859812e+38F;
#line 3079
  (s + 0)->gb = - 3.40282346638528859812e+38F;
#line 3081
  i = (int )len_a;
  {
#line 3082
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 3082
    i --;
#line 3082
    if (! i) {
#line 3082
      goto while_break___0;
    }
#line 3084
    tracep = *(trace + i);
#line 3085
    pa = (s + len_b)->a;
#line 3086
    pga = (s + len_b)->ga;
#line 3087
    pgb = (s + len_b)->gb;
#line 3089
    (s + len_b)->a = - 3.40282346638528859812e+38F;
#line 3090
    (s + len_b)->ga = - 3.40282346638528859812e+38F;
#line 3093
    (s + len_b)->gb = pa - tgpe;
#line 3094
    if (pgb - tgpe > (s + len_b)->gb) {
#line 3095
      (s + len_b)->gb = pgb - tgpe;
    }
#line 3099
    *(tracep + len_b) = (char)16;
#line 3100
    j = (int )len_b;
#line 3101
    subp = (float const   *)*(subm + *(seq1 + i));
    {
#line 3102
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 3102
      j --;
#line 3102
      if (! j) {
#line 3102
        goto while_break___1;
      }
#line 3103
      ca = (s + j)->a;
#line 3105
      c = 1;
#line 3106
      pga -= gpo;
#line 3106
      if (pga > pa) {
#line 3107
        pa = pga;
#line 3108
        c = 2;
      }
#line 3110
      pgb -= gpo;
#line 3110
      if (pgb > pa) {
#line 3111
        pa = pgb;
#line 3112
        c = 4;
      }
#line 3115
      pa += (float )*(subp + *(seq2 + j));
#line 3117
      (s + j)->a = pa;
#line 3119
      pga = (s + j)->ga;
#line 3121
      (s + j)->ga = (s + (j + 1))->a - gpo;
#line 3122
      if ((s + (j + 1))->ga - gpe > (s + j)->ga) {
#line 3123
        (s + j)->ga = (s + (j + 1))->ga - gpe;
#line 3124
        c |= 8;
      }
#line 3127
      pgb = (s + j)->gb;
#line 3129
      (s + j)->gb = ca - gpo;
#line 3130
      if (pgb - gpe > (s + j)->gb) {
#line 3131
        (s + j)->gb = pgb - gpe;
#line 3132
        c |= 16;
      }
#line 3134
      *(tracep + j) = (char )c;
#line 3135
      pa = ca;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 3140
    ca = (s + 0)->a;
#line 3142
    c = 1;
#line 3143
    pga -= gpo;
#line 3143
    if (pga > pa) {
#line 3144
      pa = pga;
#line 3145
      c = 2;
    }
#line 3147
    pgb -= gpo;
#line 3147
    if (pgb > pa) {
#line 3148
      pa = pgb;
#line 3149
      c = 4;
    }
#line 3152
    pa += (float )*(subp + *(seq2 + 0));
#line 3154
    (s + 0)->a = pa;
#line 3156
    (s + 0)->ga = - 3.40282346638528859812e+38F;
#line 3158
    pgb = (s + 0)->gb;
#line 3159
    (s + 0)->gb = ca - (gpo + tgpe);
#line 3160
    if (pgb - tgpe > (s + 0)->gb) {
#line 3161
      (s + 0)->gb = pgb - tgpe;
#line 3162
      c |= 16;
    }
#line 3164
    *(tracep + 0) = (char )c;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 3167
  subp = (float const   *)*(subm + *(seq1 + 0));
#line 3168
  tracep = *(trace + 0);
#line 3169
  j = (int )len_b;
#line 3170
  pa = (s + j)->a;
#line 3171
  pga = (s + j)->ga;
#line 3172
  pgb = (s + j)->gb;
#line 3173
  (s + j)->a = - 3.40282346638528859812e+38F;
#line 3174
  (s + j)->ga = - 3.40282346638528859812e+38F;
#line 3176
  (s + j)->gb = pa - tgpe;
#line 3177
  if (pgb - tgpe > (s + j)->gb) {
#line 3178
    (s + j)->gb = pgb - tgpe;
  }
  {
#line 3182
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 3182
    j --;
#line 3182
    if (! j) {
#line 3182
      goto while_break___2;
    }
#line 3184
    ca = (s + j)->a;
#line 3186
    c = 1;
#line 3188
    pga -= gpo;
#line 3188
    if (pga > pa) {
#line 3189
      pa = pga;
#line 3190
      c = 2;
    }
#line 3193
    pgb -= gpo;
#line 3193
    if (pgb > pa) {
#line 3194
      pa = pgb;
#line 3195
      c = 4;
    }
#line 3198
    pa += (float )*(subp + *(seq2 + j));
#line 3200
    (s + j)->a = pa;
#line 3202
    pga = (s + j)->ga;
#line 3203
    (s + j)->ga = (s + (j + 1))->a - (gpo + tgpe);
#line 3204
    if ((s + (j + 1))->ga - tgpe > (s + j)->ga) {
#line 3205
      (s + j)->ga = (s + (j + 1))->ga - tgpe;
#line 3206
      c |= 8;
    }
#line 3208
    pgb = (s + j)->gb;
#line 3209
    (s + j)->gb = - 3.40282346638528859812e+38F;
#line 3210
    *(tracep + j) = (char )c;
#line 3211
    pa = ca;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 3214
  ca = (s + 0)->a;
#line 3216
  c = 1;
#line 3218
  pga -= gpo;
#line 3218
  if (pga > pa) {
#line 3219
    pa = pga;
#line 3220
    c = 2;
  }
#line 3222
  pgb -= gpo;
#line 3222
  if (pgb > pa) {
#line 3223
    pa = pgb;
#line 3224
    c = 4;
  }
#line 3227
  pa += (float )*(subp + *(seq2 + 0));
#line 3229
  (s + 0)->a = pa;
#line 3232
  (s + 0)->ga = (s + 1)->a - (gpo + tgpe);
#line 3233
  if ((s + 1)->ga - tgpe > (s + 0)->ga) {
#line 3234
    (s + 0)->ga = (s + 1)->ga - tgpe;
#line 3235
    c |= 8;
  }
#line 3238
  pgb = (s + 0)->gb;
#line 3239
  (s + 0)->gb = ca - (gpo + tgpe);
#line 3240
  if (pgb - tgpe > (s + 0)->gb) {
#line 3241
    (s + 0)->gb = pgb - tgpe;
#line 3242
    c |= 16;
  }
#line 3244
  *(tracep + 0) = (char )c;
#line 3247
  pgb = (s + 0)->gb;
#line 3248
  c = 2;
#line 3249
  if ((s + 0)->ga > pgb) {
#line 3250
    pgb = (s + 0)->ga;
#line 3251
    c = 1;
  }
#line 3253
  if ((s + 0)->a >= pgb) {
#line 3254
    pgb = (s + 0)->a;
#line 3255
    c = 0;
  }
#line 3258
  f = c;
#line 3260
  i = 0;
#line 3261
  j = 0;
#line 3262
  c = 1;
  {
#line 3263
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 3263
    if (! ((int )*(*(trace + i) + j) < 32)) {
#line 3263
      goto while_break___3;
    }
    {
#line 3266
    if (f == 0) {
#line 3266
      goto case_0;
    }
#line 3289
    if (f == 1) {
#line 3289
      goto case_1;
    }
#line 3314
    if (f == 2) {
#line 3314
      goto case_2;
    }
#line 3265
    goto switch_break;
    case_0: /* CIL Label */ 
#line 3267
    if ((int )*(*(trace + i) + j) & 2) {
#line 3268
      f = 1;
#line 3269
      if (i + 1 != (int )len_a) {
#line 3270
        *(path + (c + 1)) |= 16;
      } else {
#line 3273
        *(path + (c + 1)) |= 48;
      }
    } else
#line 3275
    if ((int )*(*(trace + i) + j) & 4) {
#line 3276
      f = 2;
#line 3277
      if (j + 1 != (int )len_b) {
#line 3278
        *(path + (c + 1)) |= 16;
      } else {
#line 3281
        *(path + (c + 1)) |= 48;
      }
    }
#line 3286
    i ++;
#line 3287
    j ++;
#line 3288
    goto switch_break;
    case_1: /* CIL Label */ 
#line 3290
    if ((int )*(*(trace + i) + j) & 8) {
#line 3291
      f = 1;
#line 3292
      if (i != 0) {
#line 3292
        if (i != (int )len_a) {
#line 3294
          if (! (*(path + c) & 16)) {
#line 3295
            *(path + c) |= 8;
          }
        } else {
#line 3292
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 3298
      if (! (*(path + c) & 16)) {
#line 3299
        *(path + c) |= 40;
      }
    } else {
#line 3303
      f = 0;
#line 3304
      if (i != 0) {
#line 3304
        if (i != (int )len_a) {
#line 3306
          *(path + c) |= 4;
        } else {
#line 3308
          *(path + c) |= 36;
        }
      } else {
#line 3308
        *(path + c) |= 36;
      }
    }
#line 3311
    *(path + c) |= 1;
#line 3312
    j ++;
#line 3313
    goto switch_break;
    case_2: /* CIL Label */ 
#line 3315
    if ((int )*(*(trace + i) + j) & 16) {
#line 3316
      f = 2;
#line 3317
      if (j != 0) {
#line 3317
        if (j != (int )len_b) {
#line 3319
          if (! (*(path + c) & 16)) {
#line 3320
            *(path + c) |= 8;
          }
        } else {
#line 3317
          goto _L___0;
        }
      } else
      _L___0: /* CIL Label */ 
#line 3323
      if (! (*(path + c) & 16)) {
#line 3324
        *(path + c) |= 40;
      }
    } else {
#line 3328
      f = 0;
#line 3329
      if (j != 0) {
#line 3329
        if (j != (int )len_b) {
#line 3331
          *(path + c) |= 4;
        } else {
#line 3333
          *(path + c) |= 36;
        }
      } else {
#line 3333
        *(path + c) |= 36;
      }
    }
#line 3337
    *(path + c) |= 2;
#line 3338
    i ++;
#line 3339
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 3341
    c ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 3343
  *(path + 0) = c - 1;
#line 3344
  *(path + c) = 3;
#line 3345
  *(path + (c + 1)) = (int )pgb;
#line 3346
  return (path);
}
}
#line 26 "/home/june/repo/benchmarks/collector/temp/kalign-2.03+20110620/kalign2_hirschberg_dna.h"
int *hirsch_dna_ss_dyn(float **subm , int const   *seq1 , int const   *seq2 , struct hirsch_mem *hm ,
                       int *hirsch_path ) ;
#line 27
int *hirsch_align_two_dna_ss_vector(float **subm , int const   *seq1 , int const   *seq2 ,
                                    struct hirsch_mem *hm , int *hirsch_path , float *input_states ,
                                    int *old_cor ) ;
#line 28
struct states *foward_hirsch_dna_ss_dyn(float **subm , int const   *seq1 , int const   *seq2 ,
                                        struct hirsch_mem *hm ) ;
#line 29
struct states *backward_hirsch_dna_ss_dyn(float **subm , int const   *seq1 , int const   *seq2 ,
                                          struct hirsch_mem *hm ) ;
#line 31
int *hirsch_dna_ps_dyn(float const   *prof1 , int const   *seq2 , struct hirsch_mem *hm ,
                       int *hirsch_path , int sip ) ;
#line 32
int *hirsch_align_two_dna_ps_vector(float const   *prof1 , int const   *seq2 , struct hirsch_mem *hm ,
                                    int *hirsch_path , float *input_states , int *old_cor ,
                                    int sip ) ;
#line 33
struct states *foward_hirsch_dna_ps_dyn(float const   *prof1 , int const   *seq2 ,
                                        struct hirsch_mem *hm , int sip ) ;
#line 34
struct states *backward_hirsch_dna_ps_dyn(float const   *prof1 , int const   *seq2 ,
                                          struct hirsch_mem *hm , int sip ) ;
#line 36
int *hirsch_dna_pp_dyn(float const   *prof1 , float const   *prof2 , struct hirsch_mem *hm ,
                       int *hirsch_path ) ;
#line 37
int *hirsch_align_two_dna_pp_vector(float const   *prof1 , float const   *prof2 ,
                                    struct hirsch_mem *hm , int *hirsch_path , float *input_states ,
                                    int *old_cor ) ;
#line 38
struct states *foward_hirsch_dna_pp_dyn(float const   *prof1 , float const   *prof2 ,
                                        struct hirsch_mem *hm ) ;
#line 39
struct states *backward_hirsch_dna_pp_dyn(float const   *prof1 , float const   *prof2 ,
                                          struct hirsch_mem *hm ) ;
#line 34 "/home/june/repo/benchmarks/collector/temp/kalign-2.03+20110620/kalign2_hirschberg_dna.c"
int **dna_alignment(struct alignment *aln , int *tree , float **submatrix , int **map ,
                    float strength ) 
{ 
  struct hirsch_mem *hm ;
  int i ;
  int j ;
  int g ;
  int a ;
  int b ;
  int c ;
  int len_a ;
  int len_b ;
  float **profile ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
  {
#line 36
  hm = (struct hirsch_mem *)0;
#line 40
  profile = (float **)0;
#line 42
  tmp = malloc(sizeof(float *) * (unsigned long )numprofiles);
#line 42
  profile = (float **)tmp;
#line 43
  i = 0;
  }
  {
#line 43
  while (1) {
    while_continue: /* CIL Label */ ;
#line 43
    if (! ((unsigned int )i < numprofiles)) {
#line 43
      goto while_break;
    }
#line 44
    *(profile + i) = (float *)0;
#line 43
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 47
  tmp___0 = malloc(sizeof(int *) * (unsigned long )numprofiles);
#line 47
  map = (int **)tmp___0;
#line 48
  i = 0;
  }
  {
#line 48
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 48
    if (! ((unsigned int )i < numprofiles)) {
#line 48
      goto while_break___0;
    }
#line 49
    *(map + i) = (int *)0;
#line 48
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 52
  hm = hirsch_mem_alloc(hm, 1024);
#line 53
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\nAlignment:\n");
#line 54
  i = 0;
  }
  {
#line 54
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 54
    if (! ((unsigned int )i < numseq - 1U)) {
#line 54
      goto while_break___1;
    }
    {
#line 55
    a = *(tree + i * 3);
#line 56
    b = *(tree + (i * 3 + 1));
#line 57
    c = *(tree + (i * 3 + 2));
#line 58
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\r%8.0f percent done",
            (double )(((float )i / (float )numseq) * (float )100));
#line 60
    len_a = (int )*(aln->sl + a);
#line 61
    len_b = (int )*(aln->sl + b);
    }
#line 64
    if (len_a > len_b) {
#line 64
      g = len_a;
    } else {
#line 64
      g = len_b;
    }
    {
#line 65
    tmp___1 = malloc(sizeof(int ) * (unsigned long )(g + 2));
#line 65
    *(map + c) = (int *)tmp___1;
    }
#line 66
    if (g > hm->size) {
      {
#line 67
      hm = hirsch_mem_realloc(hm, g);
      }
    }
#line 70
    j = 0;
    {
#line 70
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 70
      if (! (j < g + 2)) {
#line 70
        goto while_break___2;
      }
#line 71
      *(*(map + c) + j) = -1;
#line 70
      j ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 74
    if ((unsigned int )a < numseq) {
      {
#line 75
      *(profile + a) = dna_make_profile(*(profile + a), *(aln->s + a), len_a, submatrix);
      }
    }
#line 77
    if ((unsigned int )b < numseq) {
      {
#line 78
      *(profile + b) = dna_make_profile(*(profile + b), *(aln->s + b), len_b, submatrix);
      }
    }
    {
#line 80
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Saving mem...\n");
#line 82
    dna_set_gap_penalties(*(profile + a), len_a, (int )*(aln->nsip + b), strength,
                          (int )*(aln->nsip + a));
#line 83
    dna_set_gap_penalties(*(profile + b), len_b, (int )*(aln->nsip + a), strength,
                          (int )*(aln->nsip + b));
#line 85
    hm->starta = 0;
#line 86
    hm->startb = 0;
#line 87
    hm->enda = len_a;
#line 88
    hm->endb = len_b;
#line 89
    hm->len_a = len_a;
#line 90
    hm->len_b = len_b;
#line 92
    (hm->f + 0)->a = (float )0.0;
#line 93
    (hm->f + 0)->ga = - 3.40282346638528859812e+38F;
#line 94
    (hm->f + 0)->gb = - 3.40282346638528859812e+38F;
#line 95
    (hm->b + 0)->a = (float )0.0;
#line 96
    (hm->b + 0)->ga = - 3.40282346638528859812e+38F;
#line 97
    (hm->b + 0)->gb = - 3.40282346638528859812e+38F;
    }
#line 99
    if ((unsigned int )a < numseq) {
#line 100
      if ((unsigned int )b < numseq) {
        {
#line 101
        *(map + c) = hirsch_dna_ss_dyn(submatrix, (int const   *)*(aln->s + a), (int const   *)*(aln->s + b),
                                       hm, *(map + c));
        }
      } else {
        {
#line 103
        hm->enda = len_b;
#line 104
        hm->endb = len_a;
#line 105
        hm->len_a = len_b;
#line 106
        hm->len_b = len_a;
#line 107
        *(map + c) = hirsch_dna_ps_dyn((float const   *)*(profile + b), (int const   *)*(aln->s + a),
                                       hm, *(map + c), (int )*(aln->nsip + b));
#line 108
        *(map + c) = mirror_hirsch_path(*(map + c), len_a, len_b);
        }
      }
    } else
#line 111
    if ((unsigned int )b < numseq) {
      {
#line 112
      *(map + c) = hirsch_dna_ps_dyn((float const   *)*(profile + a), (int const   *)*(aln->s + b),
                                     hm, *(map + c), (int )*(aln->nsip + a));
      }
    } else
#line 114
    if (len_a < len_b) {
      {
#line 115
      *(map + c) = hirsch_dna_pp_dyn((float const   *)*(profile + a), (float const   *)*(profile + b),
                                     hm, *(map + c));
      }
    } else {
      {
#line 117
      hm->enda = len_b;
#line 118
      hm->endb = len_a;
#line 119
      hm->len_a = len_b;
#line 120
      hm->len_b = len_a;
#line 121
      *(map + c) = hirsch_dna_pp_dyn((float const   *)*(profile + b), (float const   *)*(profile + a),
                                     hm, *(map + c));
#line 122
      *(map + c) = mirror_hirsch_path(*(map + c), len_a, len_b);
      }
    }
    {
#line 126
    *(map + c) = add_gap_info_to_hirsch_path(*(map + c), len_a, len_b);
    }
#line 128
    if ((unsigned int )i != numseq - 2U) {
      {
#line 129
      tmp___2 = malloc((sizeof(float ) * 22UL) * (unsigned long )(*(*(map + c) + 0) + 2));
#line 129
      *(profile + c) = (float *)tmp___2;
#line 130
      *(profile + c) = dna_update((float const   *)*(profile + a), (float const   *)*(profile + b),
                                  *(profile + c), *(map + c), (int )*(aln->nsip + a),
                                  (int )*(aln->nsip + b));
      }
    }
    {
#line 133
    *(aln->sl + c) = (unsigned int )*(*(map + c) + 0);
#line 135
    *(aln->nsip + c) = *(aln->nsip + a) + *(aln->nsip + b);
#line 136
    tmp___3 = malloc(sizeof(int ) * (unsigned long )(*(aln->nsip + a) + *(aln->nsip + b)));
#line 136
    *(aln->sip + c) = (unsigned int *)tmp___3;
#line 137
    g = 0;
#line 138
    j = (int )*(aln->nsip + a);
    }
    {
#line 138
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 138
      tmp___4 = j;
#line 138
      j --;
#line 138
      if (! tmp___4) {
#line 138
        goto while_break___3;
      }
#line 139
      *(*(aln->sip + c) + g) = *(*(aln->sip + a) + j);
#line 140
      g ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 142
    j = (int )*(aln->nsip + b);
    {
#line 142
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 142
      tmp___5 = j;
#line 142
      j --;
#line 142
      if (! tmp___5) {
#line 142
        goto while_break___4;
      }
#line 143
      *(*(aln->sip + c) + g) = *(*(aln->sip + b) + j);
#line 144
      g ++;
    }
    while_break___4: /* CIL Label */ ;
    }
    {
#line 147
    free((void *)*(profile + a));
#line 148
    free((void *)*(profile + b));
#line 54
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 151
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\r%8.0f percent done\n",
          100.0);
#line 153
  free((void *)profile);
#line 154
  hirsch_mem_free(hm);
#line 155
  i = 32;
  }
  {
#line 155
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 155
    tmp___6 = i;
#line 155
    i --;
#line 155
    if (! tmp___6) {
#line 155
      goto while_break___5;
    }
    {
#line 156
    free((void *)*(submatrix + i));
    }
  }
  while_break___5: /* CIL Label */ ;
  }
  {
#line 158
  free((void *)submatrix);
  }
#line 159
  return (map);
}
}
#line 162 "/home/june/repo/benchmarks/collector/temp/kalign-2.03+20110620/kalign2_hirschberg_dna.c"
int **dna_alignment_against_a(struct alignment *aln , int *tree , float **submatrix ,
                              int **map , float strength ) 
{ 
  struct hirsch_mem *hm ;
  int i ;
  int j ;
  int g ;
  int a ;
  int b ;
  int c ;
  int len_a ;
  int len_b ;
  float **profile ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
  {
#line 164
  hm = (struct hirsch_mem *)0;
#line 168
  profile = (float **)0;
#line 170
  tmp = malloc(sizeof(float *) * (unsigned long )numprofiles);
#line 170
  profile = (float **)tmp;
#line 171
  i = 0;
  }
  {
#line 171
  while (1) {
    while_continue: /* CIL Label */ ;
#line 171
    if (! ((unsigned int )i < numprofiles)) {
#line 171
      goto while_break;
    }
#line 172
    *(profile + i) = (float *)0;
#line 171
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 175
  tmp___0 = malloc(sizeof(int *) * (unsigned long )numprofiles);
#line 175
  map = (int **)tmp___0;
#line 176
  i = 0;
  }
  {
#line 176
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 176
    if (! ((unsigned int )i < numprofiles)) {
#line 176
      goto while_break___0;
    }
#line 177
    *(map + i) = (int *)0;
#line 176
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 180
  hm = hirsch_mem_alloc(hm, 1024);
#line 181
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\nAlignment:\n");
#line 182
  i = 0;
  }
  {
#line 182
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 182
    if (! ((unsigned int )i < numseq - 1U)) {
#line 182
      goto while_break___1;
    }
    {
#line 183
    a = *(tree + i * 3);
#line 184
    b = *(tree + (i * 3 + 1));
#line 185
    c = *(tree + (i * 3 + 2));
#line 186
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\r%8.0f percent done",
            (double )(((float )i / (float )numseq) * (float )100));
#line 188
    len_a = (int )*(aln->sl + a);
#line 189
    len_b = (int )*(aln->sl + b);
    }
#line 192
    if (len_a > len_b) {
#line 192
      g = len_a;
    } else {
#line 192
      g = len_b;
    }
    {
#line 193
    tmp___1 = malloc(sizeof(int ) * (unsigned long )(g + 2));
#line 193
    *(map + c) = (int *)tmp___1;
    }
#line 194
    if (g > hm->size) {
      {
#line 195
      hm = hirsch_mem_realloc(hm, g);
      }
    }
#line 198
    j = 0;
    {
#line 198
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 198
      if (! (j < g + 2)) {
#line 198
        goto while_break___2;
      }
#line 199
      *(*(map + c) + j) = -1;
#line 198
      j ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 202
    if ((unsigned int )a < numseq) {
      {
#line 203
      *(profile + a) = dna_make_profile(*(profile + a), *(aln->s + a), len_a, submatrix);
      }
    }
#line 205
    if ((unsigned int )b < numseq) {
      {
#line 206
      *(profile + b) = dna_make_profile(*(profile + b), *(aln->s + b), len_b, submatrix);
      }
    }
    {
#line 210
    dna_set_gap_penalties(*(profile + a), len_a, 1, strength, 1);
#line 211
    dna_set_gap_penalties(*(profile + b), len_b, 1, strength, 1);
#line 213
    hm->starta = 0;
#line 214
    hm->startb = 0;
#line 215
    hm->enda = len_a;
#line 216
    hm->endb = len_b;
#line 217
    hm->len_a = len_a;
#line 218
    hm->len_b = len_b;
#line 220
    (hm->f + 0)->a = (float )0.0;
#line 221
    (hm->f + 0)->ga = - 3.40282346638528859812e+38F;
#line 222
    (hm->f + 0)->gb = - 3.40282346638528859812e+38F;
#line 223
    (hm->b + 0)->a = (float )0.0;
#line 224
    (hm->b + 0)->ga = - 3.40282346638528859812e+38F;
#line 225
    (hm->b + 0)->gb = - 3.40282346638528859812e+38F;
    }
#line 227
    if ((unsigned int )a < numseq) {
#line 228
      if ((unsigned int )b < numseq) {
        {
#line 229
        *(map + c) = hirsch_dna_ss_dyn(submatrix, (int const   *)*(aln->s + a), (int const   *)*(aln->s + b),
                                       hm, *(map + c));
        }
      } else {
        {
#line 231
        hm->enda = len_b;
#line 232
        hm->endb = len_a;
#line 233
        hm->len_a = len_b;
#line 234
        hm->len_b = len_a;
#line 235
        *(map + c) = hirsch_dna_ps_dyn((float const   *)*(profile + b), (int const   *)*(aln->s + a),
                                       hm, *(map + c), (int )*(aln->nsip + b));
#line 236
        *(map + c) = mirror_hirsch_path(*(map + c), len_a, len_b);
        }
      }
    } else
#line 239
    if ((unsigned int )b < numseq) {
      {
#line 240
      *(map + c) = hirsch_dna_ps_dyn((float const   *)*(profile + a), (int const   *)*(aln->s + b),
                                     hm, *(map + c), 1);
      }
    } else
#line 242
    if (len_a < len_b) {
      {
#line 243
      *(map + c) = hirsch_dna_pp_dyn((float const   *)*(profile + a), (float const   *)*(profile + b),
                                     hm, *(map + c));
      }
    } else {
      {
#line 245
      hm->enda = len_b;
#line 246
      hm->endb = len_a;
#line 247
      hm->len_a = len_b;
#line 248
      hm->len_b = len_a;
#line 249
      *(map + c) = hirsch_dna_pp_dyn((float const   *)*(profile + b), (float const   *)*(profile + a),
                                     hm, *(map + c));
#line 250
      *(map + c) = mirror_hirsch_path(*(map + c), len_a, len_b);
      }
    }
    {
#line 256
    *(map + c) = add_gap_info_to_hirsch_path(*(map + c), len_a, len_b);
    }
#line 258
    if ((unsigned int )i != numseq - 2U) {
      {
#line 259
      tmp___2 = malloc((sizeof(float ) * 22UL) * (unsigned long )(*(*(map + c) + 0) + 2));
#line 259
      *(profile + c) = (float *)tmp___2;
#line 260
      *(profile + c) = dna_update_only_a((float const   *)*(profile + a), (float const   *)*(profile + b),
                                         *(profile + c), *(map + c), (int )*(aln->nsip + a),
                                         (int )*(aln->nsip + b));
      }
    }
    {
#line 263
    *(aln->sl + c) = (unsigned int )*(*(map + c) + 0);
#line 265
    *(aln->nsip + c) = *(aln->nsip + a) + *(aln->nsip + b);
#line 266
    tmp___3 = malloc(sizeof(int ) * (unsigned long )(*(aln->nsip + a) + *(aln->nsip + b)));
#line 266
    *(aln->sip + c) = (unsigned int *)tmp___3;
#line 267
    g = 0;
#line 268
    j = (int )*(aln->nsip + a);
    }
    {
#line 268
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 268
      tmp___4 = j;
#line 268
      j --;
#line 268
      if (! tmp___4) {
#line 268
        goto while_break___3;
      }
#line 269
      *(*(aln->sip + c) + g) = *(*(aln->sip + a) + j);
#line 270
      g ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 272
    j = (int )*(aln->nsip + b);
    {
#line 272
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 272
      tmp___5 = j;
#line 272
      j --;
#line 272
      if (! tmp___5) {
#line 272
        goto while_break___4;
      }
#line 273
      *(*(aln->sip + c) + g) = *(*(aln->sip + b) + j);
#line 274
      g ++;
    }
    while_break___4: /* CIL Label */ ;
    }
    {
#line 277
    free((void *)*(profile + a));
#line 278
    free((void *)*(profile + b));
#line 182
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 281
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\r%8.0f percent done\n",
          100.0);
#line 283
  free((void *)profile);
#line 284
  hirsch_mem_free(hm);
#line 285
  i = 32;
  }
  {
#line 285
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 285
    tmp___6 = i;
#line 285
    i --;
#line 285
    if (! tmp___6) {
#line 285
      goto while_break___5;
    }
    {
#line 286
    free((void *)*(submatrix + i));
    }
  }
  while_break___5: /* CIL Label */ ;
  }
  {
#line 288
  free((void *)submatrix);
  }
#line 289
  return (map);
}
}
#line 294 "/home/june/repo/benchmarks/collector/temp/kalign-2.03+20110620/kalign2_hirschberg_dna.c"
int *hirsch_dna_ss_dyn(float **subm , int const   *seq1 , int const   *seq2 , struct hirsch_mem *hm ,
                       int *hirsch_path ) 
{ 
  int mid ;
  float input_states[6] ;
  int old_cor[5] ;

  {
#line 296
  mid = (hm->enda - hm->starta) / 2 + hm->starta;
#line 297
  input_states[0] = (hm->f + 0)->a;
#line 297
  input_states[1] = (hm->f + 0)->ga;
#line 297
  input_states[2] = (hm->f + 0)->gb;
#line 297
  input_states[3] = (hm->b + 0)->a;
#line 297
  input_states[4] = (hm->b + 0)->ga;
#line 297
  input_states[5] = (hm->b + 0)->gb;
#line 298
  old_cor[0] = hm->starta;
#line 298
  old_cor[1] = hm->enda;
#line 298
  old_cor[2] = hm->startb;
#line 298
  old_cor[3] = hm->endb;
#line 298
  old_cor[4] = mid;
#line 300
  if (hm->starta >= hm->enda) {
#line 301
    return (hirsch_path);
  }
#line 303
  if (hm->startb >= hm->endb) {
#line 304
    return (hirsch_path);
  }
  {
#line 308
  hm->enda = mid;
#line 311
  hm->f = foward_hirsch_dna_ss_dyn(subm, seq1, seq2, hm);
#line 313
  hm->starta = mid;
#line 314
  hm->enda = old_cor[1];
#line 316
  hm->b = backward_hirsch_dna_ss_dyn(subm, seq1, seq2, hm);
#line 319
  hirsch_path = hirsch_align_two_dna_ss_vector(subm, seq1, seq2, hm, hirsch_path,
                                               input_states, old_cor);
  }
#line 320
  return (hirsch_path);
}
}
#line 323 "/home/june/repo/benchmarks/collector/temp/kalign-2.03+20110620/kalign2_hirschberg_dna.c"
int *hirsch_align_two_dna_ss_vector(float **subm , int const   *seq1 , int const   *seq2 ,
                                    struct hirsch_mem *hm , int *hirsch_path , float *input_states ,
                                    int *old_cor ) 
{ 
  struct states *f ;
  struct states *b ;
  int i ;
  int j ;
  int c ;
  int transition ;
  float max ;
  float middle ;
  float sub ;
  int tmp ;
  int tmp___0 ;

  {
#line 325
  f = hm->f;
#line 326
  b = hm->b;
#line 328
  transition = -1;
#line 341
  max = - 3.40282346638528859812e+38F;
#line 342
  middle = (float )((hm->endb - hm->startb) / 2 + hm->startb);
#line 343
  sub = (float )0.0;
#line 345
  i = hm->startb;
#line 346
  c = -1;
#line 347
  i = hm->startb;
  {
#line 347
  while (1) {
    while_continue: /* CIL Label */ ;
#line 347
    if (! (i < hm->endb)) {
#line 347
      goto while_break;
    }
    {
#line 348
    tmp = abs((int )(middle - (float )i));
#line 348
    sub = (float )tmp;
#line 349
    sub /= (float )1000;
    }
#line 351
    if (((f + i)->a + (b + i)->a) - sub > max) {
#line 352
      max = ((f + i)->a + (b + i)->a) - sub;
#line 354
      transition = 1;
#line 355
      c = i;
    }
#line 357
    if ((((f + i)->a + (b + i)->ga) - gpo) - sub > max) {
#line 358
      max = (((f + i)->a + (b + i)->ga) - gpo) - sub;
#line 360
      transition = 2;
#line 361
      c = i;
    }
#line 363
    if ((((f + i)->a + (b + i)->gb) - gpo) - sub > max) {
#line 364
      max = (((f + i)->a + (b + i)->gb) - gpo) - sub;
#line 366
      transition = 3;
#line 367
      c = i;
    }
#line 369
    if ((((f + i)->ga + (b + i)->a) - gpo) - sub > max) {
#line 370
      max = (((f + i)->ga + (b + i)->a) - gpo) - sub;
#line 372
      transition = 5;
#line 373
      c = i;
    }
#line 377
    if (hm->startb == 0) {
#line 378
      if ((((f + i)->gb + (b + i)->gb) - tgpe) - sub > max) {
#line 379
        max = (((f + i)->gb + (b + i)->gb) - tgpe) - sub;
#line 381
        transition = 6;
#line 382
        c = i;
      }
    } else
#line 385
    if ((((f + i)->gb + (b + i)->gb) - gpe) - sub > max) {
#line 386
      max = (((f + i)->gb + (b + i)->gb) - gpe) - sub;
#line 388
      transition = 6;
#line 389
      c = i;
    }
#line 392
    if ((((f + i)->gb + (b + i)->a) - gpo) - sub > max) {
#line 393
      max = (((f + i)->gb + (b + i)->a) - gpo) - sub;
#line 395
      transition = 7;
#line 396
      c = i;
    }
#line 347
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 399
  i = hm->endb;
#line 400
  tmp___0 = abs((int )(middle - (float )i));
#line 400
  sub = (float )tmp___0;
#line 401
  sub /= (float )1000;
  }
#line 403
  if ((((f + i)->a + (b + i)->gb) - gpo) - sub > max) {
#line 404
    max = (((f + i)->a + (b + i)->gb) - gpo) - sub;
#line 406
    transition = 3;
#line 407
    c = i;
  }
#line 409
  if (hm->endb == hm->len_b) {
#line 410
    if ((((f + i)->gb + (b + i)->gb) - tgpe) - sub > max) {
#line 411
      max = (((f + i)->gb + (b + i)->gb) - tgpe) - sub;
#line 413
      transition = 6;
#line 414
      c = i;
    }
  } else
#line 417
  if ((((f + i)->gb + (b + i)->gb) - tgpe) - sub > max) {
#line 418
    max = (((f + i)->gb + (b + i)->gb) - tgpe) - sub;
#line 420
    transition = 6;
#line 421
    c = i;
  }
#line 428
  j = *(hirsch_path + 0);
  {
#line 430
  if (transition == 1) {
#line 430
    goto case_1;
  }
#line 469
  if (transition == 2) {
#line 469
    goto case_2;
  }
#line 506
  if (transition == 3) {
#line 506
    goto case_3;
  }
#line 540
  if (transition == 5) {
#line 540
    goto case_5;
  }
#line 575
  if (transition == 6) {
#line 575
    goto case_6;
  }
#line 607
  if (transition == 7) {
#line 607
    goto case_7;
  }
#line 429
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 432
  *(hirsch_path + *(old_cor + 4)) = c;
#line 433
  *(hirsch_path + (*(old_cor + 4) + 1)) = c + 1;
#line 438
  (hm->f + 0)->a = *(input_states + 0);
#line 439
  (hm->f + 0)->ga = *(input_states + 1);
#line 440
  (hm->f + 0)->gb = *(input_states + 2);
#line 441
  (hm->b + 0)->a = (float )0.0;
#line 442
  (hm->b + 0)->ga = - 3.40282346638528859812e+38F;
#line 443
  (hm->b + 0)->gb = - 3.40282346638528859812e+38F;
#line 446
  hm->starta = *(old_cor + 0);
#line 447
  hm->enda = *(old_cor + 4) - 1;
#line 449
  hm->startb = *(old_cor + 2);
#line 450
  hm->endb = c - 1;
#line 452
  hirsch_path = hirsch_dna_ss_dyn(subm, seq1, seq2, hm, hirsch_path);
#line 455
  hm->starta = *(old_cor + 4) + 1;
#line 456
  hm->enda = *(old_cor + 1);
#line 457
  hm->startb = c + 1;
#line 458
  hm->endb = *(old_cor + 3);
#line 459
  (hm->f + 0)->a = (float )0.0;
#line 460
  (hm->f + 0)->ga = - 3.40282346638528859812e+38F;
#line 461
  (hm->f + 0)->gb = - 3.40282346638528859812e+38F;
#line 462
  (hm->b + 0)->a = *(input_states + 3);
#line 463
  (hm->b + 0)->ga = *(input_states + 4);
#line 464
  (hm->b + 0)->gb = *(input_states + 5);
#line 467
  hirsch_path = hirsch_dna_ss_dyn(subm, seq1, seq2, hm, hirsch_path);
  }
#line 468
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 471
  *(hirsch_path + *(old_cor + 4)) = c;
#line 474
  (hm->f + 0)->a = *(input_states + 0);
#line 475
  (hm->f + 0)->ga = *(input_states + 1);
#line 476
  (hm->f + 0)->gb = *(input_states + 2);
#line 477
  (hm->b + 0)->a = (float )0.0;
#line 478
  (hm->b + 0)->ga = - 3.40282346638528859812e+38F;
#line 479
  (hm->b + 0)->gb = - 3.40282346638528859812e+38F;
#line 482
  hm->starta = *(old_cor + 0);
#line 483
  hm->enda = *(old_cor + 4) - 1;
#line 485
  hm->startb = *(old_cor + 2);
#line 486
  hm->endb = c - 1;
#line 488
  hirsch_path = hirsch_dna_ss_dyn(subm, seq1, seq2, hm, hirsch_path);
#line 492
  hm->starta = *(old_cor + 4);
#line 493
  hm->enda = *(old_cor + 1);
#line 494
  hm->startb = c + 1;
#line 495
  hm->endb = *(old_cor + 3);
#line 496
  (hm->f + 0)->a = - 3.40282346638528859812e+38F;
#line 497
  (hm->f + 0)->ga = (float )0.0;
#line 498
  (hm->f + 0)->gb = - 3.40282346638528859812e+38F;
#line 499
  (hm->b + 0)->a = *(input_states + 3);
#line 500
  (hm->b + 0)->ga = *(input_states + 4);
#line 501
  (hm->b + 0)->gb = *(input_states + 5);
#line 504
  hirsch_path = hirsch_dna_ss_dyn(subm, seq1, seq2, hm, hirsch_path);
  }
#line 505
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 508
  *(hirsch_path + *(old_cor + 4)) = c;
#line 511
  (hm->f + 0)->a = *(input_states + 0);
#line 512
  (hm->f + 0)->ga = *(input_states + 1);
#line 513
  (hm->f + 0)->gb = *(input_states + 2);
#line 514
  (hm->b + 0)->a = (float )0.0;
#line 515
  (hm->b + 0)->ga = - 3.40282346638528859812e+38F;
#line 516
  (hm->b + 0)->gb = - 3.40282346638528859812e+38F;
#line 518
  hm->starta = *(old_cor + 0);
#line 519
  hm->enda = *(old_cor + 4) - 1;
#line 521
  hm->startb = *(old_cor + 2);
#line 522
  hm->endb = c - 1;
#line 524
  hirsch_path = hirsch_dna_ss_dyn(subm, seq1, seq2, hm, hirsch_path);
#line 526
  hm->starta = *(old_cor + 4) + 1;
#line 527
  hm->enda = *(old_cor + 1);
#line 528
  hm->startb = c;
#line 529
  hm->endb = *(old_cor + 3);
#line 530
  (hm->f + 0)->a = - 3.40282346638528859812e+38F;
#line 531
  (hm->f + 0)->ga = - 3.40282346638528859812e+38F;
#line 532
  (hm->f + 0)->gb = (float )0.0;
#line 533
  (hm->b + 0)->a = *(input_states + 3);
#line 534
  (hm->b + 0)->ga = *(input_states + 4);
#line 535
  (hm->b + 0)->gb = *(input_states + 5);
#line 538
  hirsch_path = hirsch_dna_ss_dyn(subm, seq1, seq2, hm, hirsch_path);
  }
#line 539
  goto switch_break;
  case_5: /* CIL Label */ 
  {
#line 541
  *(hirsch_path + (*(old_cor + 4) + 1)) = c + 1;
#line 545
  (hm->f + 0)->a = *(input_states + 0);
#line 546
  (hm->f + 0)->ga = *(input_states + 1);
#line 547
  (hm->f + 0)->gb = *(input_states + 2);
#line 548
  (hm->b + 0)->a = - 3.40282346638528859812e+38F;
#line 549
  (hm->b + 0)->ga = (float )0.0;
#line 550
  (hm->b + 0)->gb = - 3.40282346638528859812e+38F;
#line 552
  hm->starta = *(old_cor + 0);
#line 553
  hm->enda = *(old_cor + 4);
#line 555
  hm->startb = *(old_cor + 2);
#line 556
  hm->endb = c - 1;
#line 558
  hirsch_path = hirsch_dna_ss_dyn(subm, seq1, seq2, hm, hirsch_path);
#line 561
  hm->starta = *(old_cor + 4) + 1;
#line 562
  hm->enda = *(old_cor + 1);
#line 563
  hm->startb = c + 1;
#line 564
  hm->endb = *(old_cor + 3);
#line 565
  (hm->f + 0)->a = (float )0.0;
#line 566
  (hm->f + 0)->ga = - 3.40282346638528859812e+38F;
#line 567
  (hm->f + 0)->gb = - 3.40282346638528859812e+38F;
#line 568
  (hm->b + 0)->a = *(input_states + 3);
#line 569
  (hm->b + 0)->ga = *(input_states + 4);
#line 570
  (hm->b + 0)->gb = *(input_states + 5);
#line 573
  hirsch_path = hirsch_dna_ss_dyn(subm, seq1, seq2, hm, hirsch_path);
  }
#line 574
  goto switch_break;
  case_6: /* CIL Label */ 
  {
#line 578
  (hm->f + 0)->a = *(input_states + 0);
#line 579
  (hm->f + 0)->ga = *(input_states + 1);
#line 580
  (hm->f + 0)->gb = *(input_states + 2);
#line 581
  (hm->b + 0)->a = - 3.40282346638528859812e+38F;
#line 582
  (hm->b + 0)->ga = - 3.40282346638528859812e+38F;
#line 583
  (hm->b + 0)->gb = (float )0.0;
#line 585
  hm->starta = *(old_cor + 0);
#line 586
  hm->enda = *(old_cor + 4) - 1;
#line 587
  hm->startb = *(old_cor + 2);
#line 588
  hm->endb = c;
#line 590
  hirsch_path = hirsch_dna_ss_dyn(subm, seq1, seq2, hm, hirsch_path);
#line 593
  hm->starta = *(old_cor + 4) + 1;
#line 594
  hm->enda = *(old_cor + 1);
#line 595
  hm->startb = c;
#line 596
  hm->endb = *(old_cor + 3);
#line 597
  (hm->f + 0)->a = - 3.40282346638528859812e+38F;
#line 598
  (hm->f + 0)->ga = - 3.40282346638528859812e+38F;
#line 599
  (hm->f + 0)->gb = (float )0.0;
#line 600
  (hm->b + 0)->a = *(input_states + 3);
#line 601
  (hm->b + 0)->ga = *(input_states + 4);
#line 602
  (hm->b + 0)->gb = *(input_states + 5);
#line 605
  hirsch_path = hirsch_dna_ss_dyn(subm, seq1, seq2, hm, hirsch_path);
  }
#line 606
  goto switch_break;
  case_7: /* CIL Label */ 
  {
#line 609
  *(hirsch_path + (*(old_cor + 4) + 1)) = c + 1;
#line 612
  (hm->f + 0)->a = *(input_states + 0);
#line 613
  (hm->f + 0)->ga = *(input_states + 1);
#line 614
  (hm->f + 0)->gb = *(input_states + 2);
#line 615
  (hm->b + 0)->a = - 3.40282346638528859812e+38F;
#line 616
  (hm->b + 0)->ga = - 3.40282346638528859812e+38F;
#line 617
  (hm->b + 0)->gb = (float )0.0;
#line 619
  hm->starta = *(old_cor + 0);
#line 620
  hm->enda = *(old_cor + 4) - 1;
#line 621
  hm->startb = *(old_cor + 2);
#line 622
  hm->endb = c;
#line 624
  hirsch_path = hirsch_dna_ss_dyn(subm, seq1, seq2, hm, hirsch_path);
#line 627
  hm->starta = *(old_cor + 4) + 1;
#line 628
  hm->enda = *(old_cor + 1);
#line 629
  hm->startb = c + 1;
#line 630
  hm->endb = *(old_cor + 3);
#line 631
  (hm->f + 0)->a = (float )0.0;
#line 632
  (hm->f + 0)->ga = - 3.40282346638528859812e+38F;
#line 633
  (hm->f + 0)->gb = - 3.40282346638528859812e+38F;
#line 634
  (hm->b + 0)->a = *(input_states + 3);
#line 635
  (hm->b + 0)->ga = *(input_states + 4);
#line 636
  (hm->b + 0)->gb = *(input_states + 5);
#line 639
  hirsch_path = hirsch_dna_ss_dyn(subm, seq1, seq2, hm, hirsch_path);
  }
#line 640
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 643
  return (hirsch_path);
}
}
#line 648 "/home/june/repo/benchmarks/collector/temp/kalign-2.03+20110620/kalign2_hirschberg_dna.c"
struct states *foward_hirsch_dna_ss_dyn(float **subm , int const   *seq1 , int const   *seq2 ,
                                        struct hirsch_mem *hm ) 
{ 
  struct states *s ;
  float *subp ;
  int starta ;
  int enda ;
  int startb ;
  int endb ;
  register float pa ;
  register float pga ;
  register float pgb ;
  register float ca ;
  register int i ;
  register int j ;
  float tmp ;
  float tmp___0 ;
  float tmp___2 ;
  float tmp___3 ;
  float tmp___5 ;
  float tmp___6 ;
  float tmp___7 ;

  {
#line 650
  s = hm->f;
#line 651
  subp = (float *)0;
#line 652
  starta = hm->starta;
#line 653
  enda = hm->enda;
#line 654
  startb = hm->startb;
#line 655
  endb = hm->endb;
#line 657
  pa = (float )0;
#line 658
  pga = (float )0;
#line 659
  pgb = (float )0;
#line 660
  ca = (float )0;
#line 661
  i = 0;
#line 662
  j = 0;
#line 665
  (s + startb)->a = (s + 0)->a;
#line 666
  (s + startb)->ga = (s + 0)->ga;
#line 667
  (s + startb)->gb = (s + 0)->gb;
#line 668
  if (startb == 0) {
#line 669
    j = startb + 1;
    {
#line 669
    while (1) {
      while_continue: /* CIL Label */ ;
#line 669
      if (! (j < endb)) {
#line 669
        goto while_break;
      }
#line 671
      (s + j)->a = - 3.40282346638528859812e+38F;
#line 672
      if ((s + (j - 1))->ga > (s + (j - 1))->a) {
#line 672
        tmp = (s + (j - 1))->ga;
      } else {
#line 672
        tmp = (s + (j - 1))->a;
      }
#line 672
      (s + j)->ga = tmp - tgpe;
#line 674
      (s + j)->gb = - 3.40282346638528859812e+38F;
#line 669
      j ++;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 678
    j = startb + 1;
    {
#line 678
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 678
      if (! (j < endb)) {
#line 678
        goto while_break___0;
      }
#line 679
      (s + j)->a = - 3.40282346638528859812e+38F;
#line 680
      if ((s + (j - 1))->ga - gpe > (s + (j - 1))->a - gpo) {
#line 680
        (s + j)->ga = (s + (j - 1))->ga - gpe;
      } else {
#line 680
        (s + j)->ga = (s + (j - 1))->a - gpo;
      }
#line 681
      (s + j)->gb = - 3.40282346638528859812e+38F;
#line 678
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 684
  (s + endb)->a = - 3.40282346638528859812e+38F;
#line 685
  (s + endb)->ga = - 3.40282346638528859812e+38F;
#line 686
  (s + endb)->gb = - 3.40282346638528859812e+38F;
#line 687
  seq2 --;
#line 689
  i = starta;
  {
#line 689
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 689
    if (! (i < enda)) {
#line 689
      goto while_break___1;
    }
#line 690
    subp = *(subm + *(seq1 + i));
#line 692
    pa = (s + startb)->a;
#line 693
    pga = (s + startb)->ga;
#line 694
    pgb = (s + startb)->gb;
#line 695
    (s + startb)->a = - 3.40282346638528859812e+38F;
#line 696
    (s + startb)->ga = - 3.40282346638528859812e+38F;
#line 697
    if (startb == 0) {
#line 698
      if (pgb > pa) {
#line 698
        tmp___0 = pgb;
      } else {
#line 698
        tmp___0 = pa;
      }
#line 698
      (s + startb)->gb = tmp___0 - tgpe;
    } else
#line 700
    if (pgb - gpe > pa - gpo) {
#line 700
      (s + startb)->gb = pgb - gpe;
    } else {
#line 700
      (s + startb)->gb = pa - gpo;
    }
#line 702
    j = startb + 1;
    {
#line 702
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 702
      if (! (j < endb)) {
#line 702
        goto while_break___2;
      }
#line 703
      ca = (s + j)->a;
#line 704
      if (pa > pga - gpo) {
#line 704
        tmp___3 = pa;
      } else {
#line 704
        tmp___3 = pga - gpo;
      }
#line 704
      if (tmp___3 > pgb - gpo) {
#line 704
        if (pa > pga - gpo) {
#line 704
          tmp___2 = pa;
        } else {
#line 704
          tmp___2 = pga - gpo;
        }
#line 704
        pa = tmp___2;
      } else {
#line 704
        pa = pgb - gpo;
      }
#line 705
      pa += *(subp + *(seq2 + j));
#line 707
      (s + j)->a = pa;
#line 709
      pga = (s + j)->ga;
#line 711
      if ((s + (j - 1))->ga - gpe > (s + (j - 1))->a - gpo) {
#line 711
        (s + j)->ga = (s + (j - 1))->ga - gpe;
      } else {
#line 711
        (s + j)->ga = (s + (j - 1))->a - gpo;
      }
#line 713
      pgb = (s + j)->gb;
#line 715
      if (pgb - gpe > ca - gpo) {
#line 715
        (s + j)->gb = pgb - gpe;
      } else {
#line 715
        (s + j)->gb = ca - gpo;
      }
#line 717
      pa = ca;
#line 702
      j ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 719
    ca = (s + j)->a;
#line 720
    if (pa > pga - gpo) {
#line 720
      tmp___6 = pa;
    } else {
#line 720
      tmp___6 = pga - gpo;
    }
#line 720
    if (tmp___6 > pgb - gpo) {
#line 720
      if (pa > pga - gpo) {
#line 720
        tmp___5 = pa;
      } else {
#line 720
        tmp___5 = pga - gpo;
      }
#line 720
      pa = tmp___5;
    } else {
#line 720
      pa = pgb - gpo;
    }
#line 721
    pa += *(subp + *(seq2 + j));
#line 723
    (s + j)->a = pa;
#line 725
    (s + j)->ga = - 3.40282346638528859812e+38F;
#line 726
    if (endb != hm->len_b) {
#line 727
      if ((s + j)->gb - gpe > ca - gpo) {
#line 727
        (s + j)->gb -= gpe;
      } else {
#line 727
        (s + j)->gb = ca - gpo;
      }
    } else {
#line 729
      if ((s + j)->gb > ca) {
#line 729
        tmp___7 = (s + j)->gb;
      } else {
#line 729
        tmp___7 = ca;
      }
#line 729
      (s + j)->gb = tmp___7 - tgpe;
    }
#line 689
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 732
  return (s);
}
}
#line 735 "/home/june/repo/benchmarks/collector/temp/kalign-2.03+20110620/kalign2_hirschberg_dna.c"
struct states *backward_hirsch_dna_ss_dyn(float **subm , int const   *seq1 , int const   *seq2 ,
                                          struct hirsch_mem *hm ) 
{ 
  struct states *s ;
  float *subp ;
  int starta ;
  int enda ;
  int startb ;
  int endb ;
  register float pa ;
  register float pga ;
  register float pgb ;
  register float ca ;
  register int i ;
  register int j ;
  float tmp ;
  float tmp___0 ;
  float tmp___2 ;
  float tmp___3 ;
  float tmp___5 ;
  float tmp___6 ;
  float tmp___7 ;
  int tmp___8 ;

  {
#line 738
  s = hm->b;
#line 739
  subp = (float *)0;
#line 740
  starta = hm->starta;
#line 741
  enda = hm->enda;
#line 742
  startb = hm->startb;
#line 743
  endb = hm->endb;
#line 744
  pa = (float )0;
#line 745
  pga = (float )0;
#line 746
  pgb = (float )0;
#line 747
  ca = (float )0;
#line 748
  i = 0;
#line 749
  j = 0;
#line 751
  (s + endb)->a = (s + 0)->a;
#line 752
  (s + endb)->ga = (s + 0)->ga;
#line 753
  (s + endb)->gb = (s + 0)->gb;
#line 759
  if (endb == hm->len_b) {
#line 760
    j = endb - 1;
    {
#line 760
    while (1) {
      while_continue: /* CIL Label */ ;
#line 760
      if (! (j > startb)) {
#line 760
        goto while_break;
      }
#line 761
      (s + j)->a = - 3.40282346638528859812e+38F;
#line 762
      if ((s + (j + 1))->ga > (s + (j + 1))->a) {
#line 762
        tmp = (s + (j + 1))->ga;
      } else {
#line 762
        tmp = (s + (j + 1))->a;
      }
#line 762
      (s + j)->ga = tmp - tgpe;
#line 763
      (s + j)->gb = - 3.40282346638528859812e+38F;
#line 760
      j --;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 766
    j = endb - 1;
    {
#line 766
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 766
      if (! (j > startb)) {
#line 766
        goto while_break___0;
      }
#line 767
      (s + j)->a = - 3.40282346638528859812e+38F;
#line 768
      if ((s + (j + 1))->ga - gpe > (s + (j + 1))->a - gpo) {
#line 768
        (s + j)->ga = (s + (j + 1))->ga - gpe;
      } else {
#line 768
        (s + j)->ga = (s + (j + 1))->a - gpo;
      }
#line 769
      (s + j)->gb = - 3.40282346638528859812e+38F;
#line 766
      j --;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 774
  (s + startb)->a = - 3.40282346638528859812e+38F;
#line 775
  (s + startb)->ga = - 3.40282346638528859812e+38F;
#line 776
  (s + startb)->gb = - 3.40282346638528859812e+38F;
#line 778
  i = enda - starta;
#line 779
  seq1 += starta;
  {
#line 780
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 780
    tmp___8 = i;
#line 780
    i --;
#line 780
    if (! tmp___8) {
#line 780
      goto while_break___1;
    }
#line 781
    subp = *(subm + *(seq1 + i));
#line 782
    pa = (s + endb)->a;
#line 783
    pga = (s + endb)->ga;
#line 784
    pgb = (s + endb)->gb;
#line 785
    (s + endb)->a = - 3.40282346638528859812e+38F;
#line 786
    (s + endb)->ga = - 3.40282346638528859812e+38F;
#line 788
    if (endb == hm->len_b) {
#line 789
      if (pgb > pa) {
#line 789
        tmp___0 = pgb;
      } else {
#line 789
        tmp___0 = pa;
      }
#line 789
      (s + endb)->gb = tmp___0 - tgpe;
    } else
#line 791
    if (pgb - gpe > pa - gpo) {
#line 791
      (s + endb)->gb = pgb - gpe;
    } else {
#line 791
      (s + endb)->gb = pa - gpo;
    }
#line 794
    j = endb - 1;
    {
#line 794
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 794
      if (! (j > startb)) {
#line 794
        goto while_break___2;
      }
#line 796
      ca = (s + j)->a;
#line 797
      if (pa > pga - gpo) {
#line 797
        tmp___3 = pa;
      } else {
#line 797
        tmp___3 = pga - gpo;
      }
#line 797
      if (tmp___3 > pgb - gpo) {
#line 797
        if (pa > pga - gpo) {
#line 797
          tmp___2 = pa;
        } else {
#line 797
          tmp___2 = pga - gpo;
        }
#line 797
        pa = tmp___2;
      } else {
#line 797
        pa = pgb - gpo;
      }
#line 799
      pa += *(subp + *(seq2 + j));
#line 801
      (s + j)->a = pa;
#line 803
      pga = (s + j)->ga;
#line 805
      if ((s + (j + 1))->ga - gpe > (s + (j + 1))->a - gpo) {
#line 805
        (s + j)->ga = (s + (j + 1))->ga - gpe;
      } else {
#line 805
        (s + j)->ga = (s + (j + 1))->a - gpo;
      }
#line 807
      pgb = (s + j)->gb;
#line 809
      if (pgb - gpe > ca - gpo) {
#line 809
        (s + j)->gb = pgb - gpe;
      } else {
#line 809
        (s + j)->gb = ca - gpo;
      }
#line 811
      pa = ca;
#line 794
      j --;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 813
    ca = (s + j)->a;
#line 815
    if (pa > pga - gpo) {
#line 815
      tmp___6 = pa;
    } else {
#line 815
      tmp___6 = pga - gpo;
    }
#line 815
    if (tmp___6 > pgb - gpo) {
#line 815
      if (pa > pga - gpo) {
#line 815
        tmp___5 = pa;
      } else {
#line 815
        tmp___5 = pga - gpo;
      }
#line 815
      pa = tmp___5;
    } else {
#line 815
      pa = pgb - gpo;
    }
#line 817
    pa += *(subp + *(seq2 + j));
#line 819
    (s + j)->a = pa;
#line 821
    (s + j)->ga = - 3.40282346638528859812e+38F;
#line 823
    if (startb) {
#line 824
      if ((s + j)->gb - gpe > ca - gpo) {
#line 824
        (s + j)->gb -= gpe;
      } else {
#line 824
        (s + j)->gb = ca - gpo;
      }
    } else {
#line 826
      if ((s + j)->gb > ca) {
#line 826
        tmp___7 = (s + j)->gb;
      } else {
#line 826
        tmp___7 = ca;
      }
#line 826
      (s + j)->gb = tmp___7 - tgpe;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 829
  return (s);
}
}
#line 833 "/home/june/repo/benchmarks/collector/temp/kalign-2.03+20110620/kalign2_hirschberg_dna.c"
int *hirsch_dna_ps_dyn(float const   *prof1 , int const   *seq2 , struct hirsch_mem *hm ,
                       int *hirsch_path , int sip ) 
{ 
  int mid ;
  float input_states[6] ;
  int old_cor[5] ;

  {
#line 835
  mid = (hm->enda - hm->starta) / 2 + hm->starta;
#line 836
  input_states[0] = (hm->f + 0)->a;
#line 836
  input_states[1] = (hm->f + 0)->ga;
#line 836
  input_states[2] = (hm->f + 0)->gb;
#line 836
  input_states[3] = (hm->b + 0)->a;
#line 836
  input_states[4] = (hm->b + 0)->ga;
#line 836
  input_states[5] = (hm->b + 0)->gb;
#line 837
  old_cor[0] = hm->starta;
#line 837
  old_cor[1] = hm->enda;
#line 837
  old_cor[2] = hm->startb;
#line 837
  old_cor[3] = hm->endb;
#line 837
  old_cor[4] = mid;
#line 840
  if (hm->starta >= hm->enda) {
#line 841
    return (hirsch_path);
  }
#line 843
  if (hm->startb >= hm->endb) {
#line 844
    return (hirsch_path);
  }
  {
#line 847
  hm->enda = mid;
#line 848
  hm->f = foward_hirsch_dna_ps_dyn(prof1, seq2, hm, sip);
#line 856
  hm->starta = mid;
#line 857
  hm->enda = old_cor[1];
#line 858
  hm->b = backward_hirsch_dna_ps_dyn(prof1, seq2, hm, sip);
#line 865
  hirsch_path = hirsch_align_two_dna_ps_vector(prof1, seq2, hm, hirsch_path, input_states,
                                               old_cor, sip);
  }
#line 866
  return (hirsch_path);
}
}
#line 871 "/home/june/repo/benchmarks/collector/temp/kalign-2.03+20110620/kalign2_hirschberg_dna.c"
int *hirsch_align_two_dna_ps_vector(float const   *prof1 , int const   *seq2 , struct hirsch_mem *hm ,
                                    int *hirsch_path , float *input_states , int *old_cor ,
                                    int sip ) 
{ 
  struct states *f ;
  struct states *b ;
  int i ;
  int j ;
  int c ;
  int transition ;
  int open ;
  float max ;
  float middle ;
  float sub ;
  int tmp ;
  int tmp___0 ;

  {
#line 873
  f = hm->f;
#line 874
  b = hm->b;
#line 876
  transition = -1;
#line 878
  open = (int )(gpo * (float )sip);
#line 891
  max = - 3.40282346638528859812e+38F;
#line 892
  middle = (float )((hm->endb - hm->startb) / 2 + hm->startb);
#line 893
  sub = (float )0.0;
#line 896
  prof1 += 22 * (*(old_cor + 4) + 1);
#line 898
  i = hm->startb;
#line 899
  c = -1;
#line 900
  i = hm->startb;
  {
#line 900
  while (1) {
    while_continue: /* CIL Label */ ;
#line 900
    if (! (i < hm->endb)) {
#line 900
      goto while_break;
    }
    {
#line 901
    tmp = abs((int )(middle - (float )i));
#line 901
    sub = (float )tmp;
#line 902
    sub /= (float )1000;
    }
#line 903
    if (((f + i)->a + (b + i)->a) - sub > max) {
#line 904
      max = ((f + i)->a + (b + i)->a) - sub;
#line 906
      transition = 1;
#line 907
      c = i;
    }
#line 909
    if ((((f + i)->a + (b + i)->ga) - (float )open) - sub > max) {
#line 910
      max = (((f + i)->a + (b + i)->ga) - (float )open) - sub;
#line 912
      transition = 2;
#line 913
      c = i;
    }
#line 915
    if ((((f + i)->a + (b + i)->gb) + (float )*(prof1 + 8)) - sub > max) {
#line 916
      max = (((f + i)->a + (b + i)->gb) + (float )*(prof1 + 8)) - sub;
#line 918
      transition = 3;
#line 919
      c = i;
    }
#line 921
    if ((((f + i)->ga + (b + i)->a) - (float )open) - sub > max) {
#line 922
      max = (((f + i)->ga + (b + i)->a) - (float )open) - sub;
#line 924
      transition = 5;
#line 925
      c = i;
    }
#line 929
    if (hm->startb == 0) {
#line 930
      if ((((f + i)->gb + (b + i)->gb) + (float )*(prof1 + 10)) - sub > max) {
#line 931
        max = (((f + i)->gb + (b + i)->gb) + (float )*(prof1 + 10)) - sub;
#line 933
        transition = 6;
#line 934
        c = i;
      }
    } else
#line 937
    if ((((f + i)->gb + (b + i)->gb) + (float )*(prof1 + 9)) - sub > max) {
#line 938
      max = (((f + i)->gb + (b + i)->gb) + (float )*(prof1 + 9)) - sub;
#line 940
      transition = 6;
#line 941
      c = i;
    }
#line 944
    if ((((f + i)->gb + (b + i)->a) + (float )*(prof1 + -14)) - sub > max) {
#line 945
      max = (((f + i)->gb + (b + i)->a) + (float )*(prof1 + -14)) - sub;
#line 947
      transition = 7;
#line 948
      c = i;
    }
#line 900
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 951
  i = hm->endb;
#line 952
  tmp___0 = abs((int )(middle - (float )i));
#line 952
  sub = (float )tmp___0;
#line 953
  sub /= (float )1000;
  }
#line 954
  if ((((f + i)->a + (b + i)->gb) + (float )*(prof1 + 8)) - sub > max) {
#line 955
    max = (((f + i)->a + (b + i)->gb) + (float )*(prof1 + 8)) - sub;
#line 957
    transition = 3;
#line 958
    c = i;
  }
#line 960
  if (hm->endb == hm->len_b) {
#line 961
    if ((((f + i)->gb + (b + i)->gb) + (float )*(prof1 + 10)) - sub > max) {
#line 962
      max = (((f + i)->gb + (b + i)->gb) + (float )*(prof1 + 10)) - sub;
#line 964
      transition = 6;
#line 965
      c = i;
    }
  } else
#line 968
  if ((((f + i)->gb + (b + i)->gb) + (float )*(prof1 + 9)) - sub > max) {
#line 969
    max = (((f + i)->gb + (b + i)->gb) + (float )*(prof1 + 0)) - sub;
#line 971
    transition = 6;
#line 972
    c = i;
  }
#line 978
  prof1 -= 22 * (*(old_cor + 4) + 1);
#line 982
  j = *(hirsch_path + 0);
  {
#line 984
  if (transition == 1) {
#line 984
    goto case_1;
  }
#line 1023
  if (transition == 2) {
#line 1023
    goto case_2;
  }
#line 1059
  if (transition == 3) {
#line 1059
    goto case_3;
  }
#line 1094
  if (transition == 5) {
#line 1094
    goto case_5;
  }
#line 1129
  if (transition == 6) {
#line 1129
    goto case_6;
  }
#line 1162
  if (transition == 7) {
#line 1162
    goto case_7;
  }
#line 983
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 986
  *(hirsch_path + *(old_cor + 4)) = c;
#line 987
  *(hirsch_path + (*(old_cor + 4) + 1)) = c + 1;
#line 992
  (hm->f + 0)->a = *(input_states + 0);
#line 993
  (hm->f + 0)->ga = *(input_states + 1);
#line 994
  (hm->f + 0)->gb = *(input_states + 2);
#line 995
  (hm->b + 0)->a = (float )0.0;
#line 996
  (hm->b + 0)->ga = - 3.40282346638528859812e+38F;
#line 997
  (hm->b + 0)->gb = - 3.40282346638528859812e+38F;
#line 1000
  hm->starta = *(old_cor + 0);
#line 1001
  hm->enda = *(old_cor + 4) - 1;
#line 1003
  hm->startb = *(old_cor + 2);
#line 1004
  hm->endb = c - 1;
#line 1006
  hirsch_path = hirsch_dna_ps_dyn(prof1, seq2, hm, hirsch_path, sip);
#line 1009
  hm->starta = *(old_cor + 4) + 1;
#line 1010
  hm->enda = *(old_cor + 1);
#line 1011
  hm->startb = c + 1;
#line 1012
  hm->endb = *(old_cor + 3);
#line 1013
  (hm->f + 0)->a = (float )0.0;
#line 1014
  (hm->f + 0)->ga = - 3.40282346638528859812e+38F;
#line 1015
  (hm->f + 0)->gb = - 3.40282346638528859812e+38F;
#line 1016
  (hm->b + 0)->a = *(input_states + 3);
#line 1017
  (hm->b + 0)->ga = *(input_states + 4);
#line 1018
  (hm->b + 0)->gb = *(input_states + 5);
#line 1021
  hirsch_path = hirsch_dna_ps_dyn(prof1, seq2, hm, hirsch_path, sip);
  }
#line 1022
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 1025
  *(hirsch_path + *(old_cor + 4)) = c;
#line 1028
  (hm->f + 0)->a = *(input_states + 0);
#line 1029
  (hm->f + 0)->ga = *(input_states + 1);
#line 1030
  (hm->f + 0)->gb = *(input_states + 2);
#line 1031
  (hm->b + 0)->a = (float )0.0;
#line 1032
  (hm->b + 0)->ga = - 3.40282346638528859812e+38F;
#line 1033
  (hm->b + 0)->gb = - 3.40282346638528859812e+38F;
#line 1036
  hm->starta = *(old_cor + 0);
#line 1037
  hm->enda = *(old_cor + 4) - 1;
#line 1039
  hm->startb = *(old_cor + 2);
#line 1040
  hm->endb = c - 1;
#line 1042
  hirsch_path = hirsch_dna_ps_dyn(prof1, seq2, hm, hirsch_path, sip);
#line 1045
  hm->starta = *(old_cor + 4);
#line 1046
  hm->enda = *(old_cor + 1);
#line 1047
  hm->startb = c + 1;
#line 1048
  hm->endb = *(old_cor + 3);
#line 1049
  (hm->f + 0)->a = - 3.40282346638528859812e+38F;
#line 1050
  (hm->f + 0)->ga = (float )0.0;
#line 1051
  (hm->f + 0)->gb = - 3.40282346638528859812e+38F;
#line 1052
  (hm->b + 0)->a = *(input_states + 3);
#line 1053
  (hm->b + 0)->ga = *(input_states + 4);
#line 1054
  (hm->b + 0)->gb = *(input_states + 5);
#line 1057
  hirsch_path = hirsch_dna_ps_dyn(prof1, seq2, hm, hirsch_path, sip);
  }
#line 1058
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 1061
  *(hirsch_path + *(old_cor + 4)) = c;
#line 1064
  (hm->f + 0)->a = *(input_states + 0);
#line 1065
  (hm->f + 0)->ga = *(input_states + 1);
#line 1066
  (hm->f + 0)->gb = *(input_states + 2);
#line 1067
  (hm->b + 0)->a = (float )0.0;
#line 1068
  (hm->b + 0)->ga = - 3.40282346638528859812e+38F;
#line 1069
  (hm->b + 0)->gb = - 3.40282346638528859812e+38F;
#line 1071
  hm->starta = *(old_cor + 0);
#line 1072
  hm->enda = *(old_cor + 4) - 1;
#line 1074
  hm->startb = *(old_cor + 2);
#line 1075
  hm->endb = c - 1;
#line 1077
  hirsch_path = hirsch_dna_ps_dyn(prof1, seq2, hm, hirsch_path, sip);
#line 1080
  hm->starta = *(old_cor + 4) + 1;
#line 1081
  hm->enda = *(old_cor + 1);
#line 1082
  hm->startb = c;
#line 1083
  hm->endb = *(old_cor + 3);
#line 1084
  (hm->f + 0)->a = - 3.40282346638528859812e+38F;
#line 1085
  (hm->f + 0)->ga = - 3.40282346638528859812e+38F;
#line 1086
  (hm->f + 0)->gb = (float )0.0;
#line 1087
  (hm->b + 0)->a = *(input_states + 3);
#line 1088
  (hm->b + 0)->ga = *(input_states + 4);
#line 1089
  (hm->b + 0)->gb = *(input_states + 5);
#line 1092
  hirsch_path = hirsch_dna_ps_dyn(prof1, seq2, hm, hirsch_path, sip);
  }
#line 1093
  goto switch_break;
  case_5: /* CIL Label */ 
  {
#line 1095
  *(hirsch_path + (*(old_cor + 4) + 1)) = c + 1;
#line 1099
  (hm->f + 0)->a = *(input_states + 0);
#line 1100
  (hm->f + 0)->ga = *(input_states + 1);
#line 1101
  (hm->f + 0)->gb = *(input_states + 2);
#line 1102
  (hm->b + 0)->a = - 3.40282346638528859812e+38F;
#line 1103
  (hm->b + 0)->ga = (float )0.0;
#line 1104
  (hm->b + 0)->gb = - 3.40282346638528859812e+38F;
#line 1106
  hm->starta = *(old_cor + 0);
#line 1107
  hm->enda = *(old_cor + 4);
#line 1109
  hm->startb = *(old_cor + 2);
#line 1110
  hm->endb = c - 1;
#line 1112
  hirsch_path = hirsch_dna_ps_dyn(prof1, seq2, hm, hirsch_path, sip);
#line 1115
  hm->starta = *(old_cor + 4) + 1;
#line 1116
  hm->enda = *(old_cor + 1);
#line 1117
  hm->startb = c + 1;
#line 1118
  hm->endb = *(old_cor + 3);
#line 1119
  (hm->f + 0)->a = (float )0.0;
#line 1120
  (hm->f + 0)->ga = - 3.40282346638528859812e+38F;
#line 1121
  (hm->f + 0)->gb = - 3.40282346638528859812e+38F;
#line 1122
  (hm->b + 0)->a = *(input_states + 3);
#line 1123
  (hm->b + 0)->ga = *(input_states + 4);
#line 1124
  (hm->b + 0)->gb = *(input_states + 5);
#line 1127
  hirsch_path = hirsch_dna_ps_dyn(prof1, seq2, hm, hirsch_path, sip);
  }
#line 1128
  goto switch_break;
  case_6: /* CIL Label */ 
  {
#line 1132
  (hm->f + 0)->a = *(input_states + 0);
#line 1133
  (hm->f + 0)->ga = *(input_states + 1);
#line 1134
  (hm->f + 0)->gb = *(input_states + 2);
#line 1135
  (hm->b + 0)->a = - 3.40282346638528859812e+38F;
#line 1136
  (hm->b + 0)->ga = - 3.40282346638528859812e+38F;
#line 1137
  (hm->b + 0)->gb = (float )0.0;
#line 1139
  hm->starta = *(old_cor + 0);
#line 1140
  hm->enda = *(old_cor + 4) - 1;
#line 1141
  hm->startb = *(old_cor + 2);
#line 1142
  hm->endb = c;
#line 1144
  hirsch_path = hirsch_dna_ps_dyn(prof1, seq2, hm, hirsch_path, sip);
#line 1148
  hm->starta = *(old_cor + 4) + 1;
#line 1149
  hm->enda = *(old_cor + 1);
#line 1150
  hm->startb = c;
#line 1151
  hm->endb = *(old_cor + 3);
#line 1152
  (hm->f + 0)->a = - 3.40282346638528859812e+38F;
#line 1153
  (hm->f + 0)->ga = - 3.40282346638528859812e+38F;
#line 1154
  (hm->f + 0)->gb = (float )0.0;
#line 1155
  (hm->b + 0)->a = *(input_states + 3);
#line 1156
  (hm->b + 0)->ga = *(input_states + 4);
#line 1157
  (hm->b + 0)->gb = *(input_states + 5);
#line 1160
  hirsch_path = hirsch_dna_ps_dyn(prof1, seq2, hm, hirsch_path, sip);
  }
#line 1161
  goto switch_break;
  case_7: /* CIL Label */ 
  {
#line 1164
  *(hirsch_path + (*(old_cor + 4) + 1)) = c + 1;
#line 1167
  (hm->f + 0)->a = *(input_states + 0);
#line 1168
  (hm->f + 0)->ga = *(input_states + 1);
#line 1169
  (hm->f + 0)->gb = *(input_states + 2);
#line 1170
  (hm->b + 0)->a = - 3.40282346638528859812e+38F;
#line 1171
  (hm->b + 0)->ga = - 3.40282346638528859812e+38F;
#line 1172
  (hm->b + 0)->gb = (float )0.0;
#line 1174
  hm->starta = *(old_cor + 0);
#line 1175
  hm->enda = *(old_cor + 4) - 1;
#line 1176
  hm->startb = *(old_cor + 2);
#line 1177
  hm->endb = c;
#line 1179
  hirsch_path = hirsch_dna_ps_dyn(prof1, seq2, hm, hirsch_path, sip);
#line 1182
  hm->starta = *(old_cor + 4) + 1;
#line 1183
  hm->enda = *(old_cor + 1);
#line 1184
  hm->startb = c + 1;
#line 1185
  hm->endb = *(old_cor + 3);
#line 1186
  (hm->f + 0)->a = (float )0.0;
#line 1187
  (hm->f + 0)->ga = - 3.40282346638528859812e+38F;
#line 1188
  (hm->f + 0)->gb = - 3.40282346638528859812e+38F;
#line 1189
  (hm->b + 0)->a = *(input_states + 3);
#line 1190
  (hm->b + 0)->ga = *(input_states + 4);
#line 1191
  (hm->b + 0)->gb = *(input_states + 5);
#line 1194
  hirsch_path = hirsch_dna_ps_dyn(prof1, seq2, hm, hirsch_path, sip);
  }
#line 1195
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1198
  return (hirsch_path);
}
}
#line 1201 "/home/june/repo/benchmarks/collector/temp/kalign-2.03+20110620/kalign2_hirschberg_dna.c"
struct states *foward_hirsch_dna_ps_dyn(float const   *prof1 , int const   *seq2 ,
                                        struct hirsch_mem *hm , int sip ) 
{ 
  struct states *s ;
  int starta ;
  int enda ;
  int startb ;
  int endb ;
  register float pa ;
  register float pga ;
  register float pgb ;
  register float ca ;
  register int i ;
  register int j ;
  float open ;
  float ext ;
  float text ;
  float tmp ;
  float tmp___0 ;
  float tmp___2 ;
  float tmp___3 ;
  float tmp___5 ;
  float tmp___6 ;
  float tmp___7 ;

  {
#line 1204
  s = hm->f;
#line 1205
  starta = hm->starta;
#line 1206
  enda = hm->enda;
#line 1207
  startb = hm->startb;
#line 1208
  endb = hm->endb;
#line 1210
  pa = (float )0;
#line 1211
  pga = (float )0;
#line 1212
  pgb = (float )0;
#line 1213
  ca = (float )0;
#line 1214
  i = 0;
#line 1215
  j = 0;
#line 1217
  open = gpo * (float )sip;
#line 1218
  ext = gpe * (float )sip;
#line 1219
  text = tgpe * (float )sip;
#line 1223
  prof1 += starta * 22;
#line 1224
  (s + startb)->a = (s + 0)->a;
#line 1225
  (s + startb)->ga = (s + 0)->ga;
#line 1226
  (s + startb)->gb = (s + 0)->gb;
#line 1227
  if (startb == 0) {
#line 1228
    j = startb + 1;
    {
#line 1228
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1228
      if (! (j < endb)) {
#line 1228
        goto while_break;
      }
#line 1229
      (s + j)->a = - 3.40282346638528859812e+38F;
#line 1230
      if ((s + (j - 1))->ga > (s + (j - 1))->a) {
#line 1230
        tmp = (s + (j - 1))->ga;
      } else {
#line 1230
        tmp = (s + (j - 1))->a;
      }
#line 1230
      (s + j)->ga = tmp - text;
#line 1231
      (s + j)->gb = - 3.40282346638528859812e+38F;
#line 1228
      j ++;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 1234
    j = startb + 1;
    {
#line 1234
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1234
      if (! (j < endb)) {
#line 1234
        goto while_break___0;
      }
#line 1235
      (s + j)->a = - 3.40282346638528859812e+38F;
#line 1236
      if ((s + (j - 1))->ga - ext > (s + (j - 1))->a - open) {
#line 1236
        (s + j)->ga = (s + (j - 1))->ga - ext;
      } else {
#line 1236
        (s + j)->ga = (s + (j - 1))->a - open;
      }
#line 1237
      (s + j)->gb = - 3.40282346638528859812e+38F;
#line 1234
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 1242
  (s + endb)->a = - 3.40282346638528859812e+38F;
#line 1243
  (s + endb)->ga = - 3.40282346638528859812e+38F;
#line 1244
  (s + endb)->gb = - 3.40282346638528859812e+38F;
#line 1245
  seq2 --;
#line 1247
  i = starta;
  {
#line 1247
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1247
    if (! (i < enda)) {
#line 1247
      goto while_break___1;
    }
#line 1248
    prof1 += 22;
#line 1249
    pa = (s + startb)->a;
#line 1250
    pga = (s + startb)->ga;
#line 1251
    pgb = (s + startb)->gb;
#line 1252
    (s + startb)->a = - 3.40282346638528859812e+38F;
#line 1253
    (s + startb)->ga = - 3.40282346638528859812e+38F;
#line 1254
    if (startb == 0) {
#line 1255
      if (pgb > pa) {
#line 1255
        tmp___0 = pgb;
      } else {
#line 1255
        tmp___0 = pa;
      }
#line 1255
      (s + startb)->gb = tmp___0 + (float )*(prof1 + 10);
    } else
#line 1257
    if (pgb + (float )*(prof1 + 9) > pa + (float )*(prof1 + 8)) {
#line 1257
      (s + startb)->gb = pgb + (float )*(prof1 + 9);
    } else {
#line 1257
      (s + startb)->gb = pa + (float )*(prof1 + 8);
    }
#line 1259
    j = startb + 1;
    {
#line 1259
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1259
      if (! (j < endb)) {
#line 1259
        goto while_break___2;
      }
#line 1260
      ca = (s + j)->a;
#line 1261
      if (pa > pga - open) {
#line 1261
        tmp___3 = pa;
      } else {
#line 1261
        tmp___3 = pga - open;
      }
#line 1261
      if (tmp___3 > pgb + (float )*(prof1 + -14)) {
#line 1261
        if (pa > pga - open) {
#line 1261
          tmp___2 = pa;
        } else {
#line 1261
          tmp___2 = pga - open;
        }
#line 1261
        pa = tmp___2;
      } else {
#line 1261
        pa = pgb + (float )*(prof1 + -14);
      }
#line 1262
      pa += (float )*(prof1 + (11 + (int )*(seq2 + j)));
#line 1265
      (s + j)->a = pa;
#line 1267
      pga = (s + j)->ga;
#line 1269
      if ((s + (j - 1))->ga - ext > (s + (j - 1))->a - open) {
#line 1269
        (s + j)->ga = (s + (j - 1))->ga - ext;
      } else {
#line 1269
        (s + j)->ga = (s + (j - 1))->a - open;
      }
#line 1271
      pgb = (s + j)->gb;
#line 1273
      if (pgb + (float )*(prof1 + 9) > ca + (float )*(prof1 + 8)) {
#line 1273
        (s + j)->gb = pgb + (float )*(prof1 + 9);
      } else {
#line 1273
        (s + j)->gb = ca + (float )*(prof1 + 8);
      }
#line 1275
      pa = ca;
#line 1259
      j ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 1277
    ca = (s + j)->a;
#line 1279
    if (pa > pga - open) {
#line 1279
      tmp___6 = pa;
    } else {
#line 1279
      tmp___6 = pga - open;
    }
#line 1279
    if (tmp___6 > pgb + (float )*(prof1 + -14)) {
#line 1279
      if (pa > pga - open) {
#line 1279
        tmp___5 = pa;
      } else {
#line 1279
        tmp___5 = pga - open;
      }
#line 1279
      pa = tmp___5;
    } else {
#line 1279
      pa = pgb + (float )*(prof1 + -14);
    }
#line 1281
    pa += (float )*(prof1 + (11 + (int )*(seq2 + j)));
#line 1284
    (s + j)->a = pa;
#line 1286
    (s + j)->ga = - 3.40282346638528859812e+38F;
#line 1288
    if (hm->endb != hm->len_b) {
#line 1289
      if ((s + j)->gb + (float )*(prof1 + 9) > ca + (float )*(prof1 + 8)) {
#line 1289
        (s + j)->gb += (float )*(prof1 + 9);
      } else {
#line 1289
        (s + j)->gb = ca + (float )*(prof1 + 8);
      }
    } else {
#line 1291
      if ((s + j)->gb > ca) {
#line 1291
        tmp___7 = (s + j)->gb;
      } else {
#line 1291
        tmp___7 = ca;
      }
#line 1291
      (s + j)->gb = tmp___7 + (float )*(prof1 + 10);
    }
#line 1247
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1294
  prof1 -= 22 * enda;
#line 1295
  return (s);
}
}
#line 1298 "/home/june/repo/benchmarks/collector/temp/kalign-2.03+20110620/kalign2_hirschberg_dna.c"
struct states *backward_hirsch_dna_ps_dyn(float const   *prof1 , int const   *seq2 ,
                                          struct hirsch_mem *hm , int sip ) 
{ 
  struct states *s ;
  int starta ;
  int enda ;
  int startb ;
  int endb ;
  register float pa ;
  register float pga ;
  register float pgb ;
  register float ca ;
  register int i ;
  register int j ;
  float open ;
  float ext ;
  float text ;
  float tmp ;
  float tmp___0 ;
  float tmp___2 ;
  float tmp___3 ;
  float tmp___5 ;
  float tmp___6 ;
  float tmp___7 ;
  int tmp___8 ;

  {
#line 1301
  s = hm->b;
#line 1302
  starta = hm->starta;
#line 1303
  enda = hm->enda;
#line 1304
  startb = hm->startb;
#line 1305
  endb = hm->endb;
#line 1307
  pa = (float )0;
#line 1308
  pga = (float )0;
#line 1309
  pgb = (float )0;
#line 1310
  ca = (float )0;
#line 1311
  i = 0;
#line 1312
  j = 0;
#line 1314
  open = gpo * (float )sip;
#line 1315
  ext = gpe * (float )sip;
#line 1316
  text = tgpe * (float )sip;
#line 1319
  prof1 += (enda + 1) * 22;
#line 1321
  (s + endb)->a = (s + 0)->a;
#line 1322
  (s + endb)->ga = (s + 0)->ga;
#line 1323
  (s + endb)->gb = (s + 0)->gb;
#line 1328
  if (endb == hm->len_b) {
#line 1329
    j = endb - 1;
    {
#line 1329
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1329
      if (! (j > startb)) {
#line 1329
        goto while_break;
      }
#line 1330
      (s + j)->a = - 3.40282346638528859812e+38F;
#line 1331
      if ((s + (j + 1))->ga > (s + (j + 1))->a) {
#line 1331
        tmp = (s + (j + 1))->ga;
      } else {
#line 1331
        tmp = (s + (j + 1))->a;
      }
#line 1331
      (s + j)->ga = tmp - text;
#line 1332
      (s + j)->gb = - 3.40282346638528859812e+38F;
#line 1329
      j --;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 1335
    j = endb - 1;
    {
#line 1335
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1335
      if (! (j > startb)) {
#line 1335
        goto while_break___0;
      }
#line 1336
      (s + j)->a = - 3.40282346638528859812e+38F;
#line 1337
      if ((s + (j + 1))->ga - ext > (s + (j + 1))->a - open) {
#line 1337
        (s + j)->ga = (s + (j + 1))->ga - ext;
      } else {
#line 1337
        (s + j)->ga = (s + (j + 1))->a - open;
      }
#line 1338
      (s + j)->gb = - 3.40282346638528859812e+38F;
#line 1335
      j --;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 1342
  (s + startb)->a = - 3.40282346638528859812e+38F;
#line 1343
  (s + startb)->ga = - 3.40282346638528859812e+38F;
#line 1344
  (s + startb)->gb = - 3.40282346638528859812e+38F;
#line 1346
  i = enda - starta;
  {
#line 1347
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1347
    tmp___8 = i;
#line 1347
    i --;
#line 1347
    if (! tmp___8) {
#line 1347
      goto while_break___1;
    }
#line 1348
    prof1 -= 22;
#line 1350
    pa = (s + endb)->a;
#line 1351
    pga = (s + endb)->ga;
#line 1352
    pgb = (s + endb)->gb;
#line 1353
    (s + endb)->a = - 3.40282346638528859812e+38F;
#line 1354
    (s + endb)->ga = - 3.40282346638528859812e+38F;
#line 1356
    if (endb == hm->len_b) {
#line 1357
      if (pgb > pa) {
#line 1357
        tmp___0 = pgb;
      } else {
#line 1357
        tmp___0 = pa;
      }
#line 1357
      (s + endb)->gb = tmp___0 + (float )*(prof1 + 10);
    } else
#line 1359
    if (pgb + (float )*(prof1 + 9) > pa + (float )*(prof1 + 8)) {
#line 1359
      (s + endb)->gb = pgb + (float )*(prof1 + 9);
    } else {
#line 1359
      (s + endb)->gb = pa + (float )*(prof1 + 8);
    }
#line 1362
    j = endb - 1;
    {
#line 1362
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1362
      if (! (j > startb)) {
#line 1362
        goto while_break___2;
      }
#line 1363
      ca = (s + j)->a;
#line 1364
      if (pa > pga - open) {
#line 1364
        tmp___3 = pa;
      } else {
#line 1364
        tmp___3 = pga - open;
      }
#line 1364
      if (tmp___3 > pgb + (float )*(prof1 + 30)) {
#line 1364
        if (pa > pga - open) {
#line 1364
          tmp___2 = pa;
        } else {
#line 1364
          tmp___2 = pga - open;
        }
#line 1364
        pa = tmp___2;
      } else {
#line 1364
        pa = pgb + (float )*(prof1 + 30);
      }
#line 1365
      pa += (float )*(prof1 + (11 + (int )*(seq2 + j)));
#line 1367
      (s + j)->a = pa;
#line 1369
      pga = (s + j)->ga;
#line 1371
      if ((s + (j + 1))->ga - ext > (s + (j + 1))->a - open) {
#line 1371
        (s + j)->ga = (s + (j + 1))->ga - ext;
      } else {
#line 1371
        (s + j)->ga = (s + (j + 1))->a - open;
      }
#line 1373
      pgb = (s + j)->gb;
#line 1375
      if (pgb + (float )*(prof1 + 9) > ca + (float )*(prof1 + 8)) {
#line 1375
        (s + j)->gb = pgb + (float )*(prof1 + 9);
      } else {
#line 1375
        (s + j)->gb = ca + (float )*(prof1 + 8);
      }
#line 1377
      pa = ca;
#line 1362
      j --;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 1379
    ca = (s + j)->a;
#line 1381
    if (pa > pga - open) {
#line 1381
      tmp___6 = pa;
    } else {
#line 1381
      tmp___6 = pga - open;
    }
#line 1381
    if (tmp___6 > pgb + (float )*(prof1 + 30)) {
#line 1381
      if (pa > pga - open) {
#line 1381
        tmp___5 = pa;
      } else {
#line 1381
        tmp___5 = pga - open;
      }
#line 1381
      pa = tmp___5;
    } else {
#line 1381
      pa = pgb + (float )*(prof1 + 30);
    }
#line 1382
    pa += (float )*(prof1 + (11 + (int )*(seq2 + j)));
#line 1384
    (s + j)->a = pa;
#line 1387
    (s + j)->ga = - 3.40282346638528859812e+38F;
#line 1388
    if (hm->startb) {
#line 1389
      if ((s + j)->gb + (float )*(prof1 + 9) > ca + (float )*(prof1 + 8)) {
#line 1389
        (s + j)->gb += (float )*(prof1 + 9);
      } else {
#line 1389
        (s + j)->gb = ca + (float )*(prof1 + 8);
      }
    } else {
#line 1391
      if ((s + j)->gb > ca) {
#line 1391
        tmp___7 = (s + j)->gb;
      } else {
#line 1391
        tmp___7 = ca;
      }
#line 1391
      (s + j)->gb = tmp___7 + (float )*(prof1 + 10);
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1394
  return (s);
}
}
#line 1400 "/home/june/repo/benchmarks/collector/temp/kalign-2.03+20110620/kalign2_hirschberg_dna.c"
int *hirsch_dna_pp_dyn(float const   *prof1 , float const   *prof2 , struct hirsch_mem *hm ,
                       int *hirsch_path ) 
{ 
  int mid ;
  float input_states[6] ;
  int old_cor[5] ;

  {
#line 1402
  mid = (hm->enda - hm->starta) / 2 + hm->starta;
#line 1403
  input_states[0] = (hm->f + 0)->a;
#line 1403
  input_states[1] = (hm->f + 0)->ga;
#line 1403
  input_states[2] = (hm->f + 0)->gb;
#line 1403
  input_states[3] = (hm->b + 0)->a;
#line 1403
  input_states[4] = (hm->b + 0)->ga;
#line 1403
  input_states[5] = (hm->b + 0)->gb;
#line 1404
  old_cor[0] = hm->starta;
#line 1404
  old_cor[1] = hm->enda;
#line 1404
  old_cor[2] = hm->startb;
#line 1404
  old_cor[3] = hm->endb;
#line 1404
  old_cor[4] = mid;
#line 1410
  if (hm->starta >= hm->enda) {
#line 1411
    return (hirsch_path);
  }
#line 1413
  if (hm->startb >= hm->endb) {
#line 1414
    return (hirsch_path);
  }
  {
#line 1417
  hm->enda = mid;
#line 1418
  hm->f = foward_hirsch_dna_pp_dyn(prof1, prof2, hm);
#line 1425
  hm->starta = mid;
#line 1426
  hm->enda = old_cor[1];
#line 1427
  hm->b = backward_hirsch_dna_pp_dyn(prof1, prof2, hm);
#line 1434
  hirsch_path = hirsch_align_two_dna_pp_vector(prof1, prof2, hm, hirsch_path, input_states,
                                               old_cor);
  }
#line 1435
  return (hirsch_path);
}
}
#line 1440 "/home/june/repo/benchmarks/collector/temp/kalign-2.03+20110620/kalign2_hirschberg_dna.c"
int *hirsch_align_two_dna_pp_vector(float const   *prof1 , float const   *prof2 ,
                                    struct hirsch_mem *hm , int *hirsch_path , float *input_states ,
                                    int *old_cor ) 
{ 
  struct states *f ;
  struct states *b ;
  int i ;
  int j ;
  int c ;
  int transition ;
  float max ;
  float middle ;
  float sub ;
  int tmp ;
  int tmp___0 ;

  {
#line 1442
  f = hm->f;
#line 1443
  b = hm->b;
#line 1445
  transition = -1;
#line 1458
  max = - 3.40282346638528859812e+38F;
#line 1459
  middle = (float )((hm->endb - hm->startb) / 2 + hm->startb);
#line 1460
  sub = (float )0.0;
#line 1463
  prof1 += 22 * (*(old_cor + 4) + 1);
#line 1464
  prof2 += 22 * hm->startb;
#line 1466
  i = hm->startb;
#line 1467
  c = -1;
#line 1468
  i = hm->startb;
  {
#line 1468
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1468
    if (! (i < hm->endb)) {
#line 1468
      goto while_break;
    }
    {
#line 1469
    tmp = abs((int )(middle - (float )i));
#line 1469
    sub = (float )tmp;
#line 1470
    sub /= (float )1000;
#line 1471
    prof2 += 22;
    }
#line 1472
    if (((f + i)->a + (b + i)->a) - sub > max) {
#line 1473
      max = ((f + i)->a + (b + i)->a) - sub;
#line 1475
      transition = 1;
#line 1476
      c = i;
    }
#line 1478
    if ((((f + i)->a + (b + i)->ga) + (float )*(prof2 + 8)) - sub > max) {
#line 1479
      max = (((f + i)->a + (b + i)->ga) + (float )*(prof2 + 8)) - sub;
#line 1481
      transition = 2;
#line 1482
      c = i;
    }
#line 1484
    if ((((f + i)->a + (b + i)->gb) + (float )*(prof1 + 8)) - sub > max) {
#line 1485
      max = (((f + i)->a + (b + i)->gb) + (float )*(prof1 + 8)) - sub;
#line 1487
      transition = 3;
#line 1488
      c = i;
    }
#line 1490
    if ((((f + i)->ga + (b + i)->a) + (float )*(prof2 + -14)) - sub > max) {
#line 1491
      max = (((f + i)->ga + (b + i)->a) + (float )*(prof2 + -14)) - sub;
#line 1493
      transition = 5;
#line 1494
      c = i;
    }
#line 1498
    if (hm->startb == 0) {
#line 1499
      if ((((f + i)->gb + (b + i)->gb) + (float )*(prof1 + 10)) - sub > max) {
#line 1500
        max = (((f + i)->gb + (b + i)->gb) + (float )*(prof1 + 10)) - sub;
#line 1502
        transition = 6;
#line 1503
        c = i;
      }
    } else
#line 1506
    if ((((f + i)->gb + (b + i)->gb) + (float )*(prof1 + 9)) - sub > max) {
#line 1507
      max = (((f + i)->gb + (b + i)->gb) + (float )*(prof1 + 9)) - sub;
#line 1509
      transition = 6;
#line 1510
      c = i;
    }
#line 1513
    if ((((f + i)->gb + (b + i)->a) + (float )*(prof1 + -14)) - sub > max) {
#line 1514
      max = (((f + i)->gb + (b + i)->a) + (float )*(prof1 + -14)) - sub;
#line 1516
      transition = 7;
#line 1517
      c = i;
    }
#line 1468
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1520
  i = hm->endb;
#line 1521
  tmp___0 = abs((int )(middle - (float )i));
#line 1521
  sub = (float )tmp___0;
#line 1522
  sub /= (float )1000;
  }
#line 1523
  if ((((f + i)->a + (b + i)->gb) + (float )*(prof1 + 8)) - sub > max) {
#line 1524
    max = (((f + i)->a + (b + i)->gb) + (float )*(prof1 + 8)) - sub;
#line 1526
    transition = 3;
#line 1527
    c = i;
  }
#line 1529
  if (hm->endb == hm->len_b) {
#line 1530
    if ((((f + i)->gb + (b + i)->gb) + (float )*(prof1 + 10)) - sub > max) {
#line 1531
      max = (((f + i)->gb + (b + i)->gb) + (float )*(prof1 + 10)) - sub;
#line 1533
      transition = 6;
#line 1534
      c = i;
    }
  } else
#line 1537
  if ((((f + i)->gb + (b + i)->gb) + (float )*(prof1 + 9)) - sub > max) {
#line 1538
    max = (((f + i)->gb + (b + i)->gb) + (float )*(prof1 + 9)) - sub;
#line 1540
    transition = 6;
#line 1541
    c = i;
  }
#line 1547
  prof1 -= 22 * (*(old_cor + 4) + 1);
#line 1548
  prof2 -= hm->endb * 22;
#line 1552
  j = *(hirsch_path + 0);
  {
#line 1554
  if (transition == 1) {
#line 1554
    goto case_1;
  }
#line 1593
  if (transition == 2) {
#line 1593
    goto case_2;
  }
#line 1629
  if (transition == 3) {
#line 1629
    goto case_3;
  }
#line 1664
  if (transition == 5) {
#line 1664
    goto case_5;
  }
#line 1699
  if (transition == 6) {
#line 1699
    goto case_6;
  }
#line 1731
  if (transition == 7) {
#line 1731
    goto case_7;
  }
#line 1553
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 1556
  *(hirsch_path + *(old_cor + 4)) = c;
#line 1557
  *(hirsch_path + (*(old_cor + 4) + 1)) = c + 1;
#line 1562
  (hm->f + 0)->a = *(input_states + 0);
#line 1563
  (hm->f + 0)->ga = *(input_states + 1);
#line 1564
  (hm->f + 0)->gb = *(input_states + 2);
#line 1565
  (hm->b + 0)->a = (float )0.0;
#line 1566
  (hm->b + 0)->ga = - 3.40282346638528859812e+38F;
#line 1567
  (hm->b + 0)->gb = - 3.40282346638528859812e+38F;
#line 1570
  hm->starta = *(old_cor + 0);
#line 1571
  hm->enda = *(old_cor + 4) - 1;
#line 1573
  hm->startb = *(old_cor + 2);
#line 1574
  hm->endb = c - 1;
#line 1576
  hirsch_path = hirsch_dna_pp_dyn(prof1, prof2, hm, hirsch_path);
#line 1579
  hm->starta = *(old_cor + 4) + 1;
#line 1580
  hm->enda = *(old_cor + 1);
#line 1581
  hm->startb = c + 1;
#line 1582
  hm->endb = *(old_cor + 3);
#line 1583
  (hm->f + 0)->a = (float )0.0;
#line 1584
  (hm->f + 0)->ga = - 3.40282346638528859812e+38F;
#line 1585
  (hm->f + 0)->gb = - 3.40282346638528859812e+38F;
#line 1586
  (hm->b + 0)->a = *(input_states + 3);
#line 1587
  (hm->b + 0)->ga = *(input_states + 4);
#line 1588
  (hm->b + 0)->gb = *(input_states + 5);
#line 1591
  hirsch_path = hirsch_dna_pp_dyn(prof1, prof2, hm, hirsch_path);
  }
#line 1592
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 1595
  *(hirsch_path + *(old_cor + 4)) = c;
#line 1598
  (hm->f + 0)->a = *(input_states + 0);
#line 1599
  (hm->f + 0)->ga = *(input_states + 1);
#line 1600
  (hm->f + 0)->gb = *(input_states + 2);
#line 1601
  (hm->b + 0)->a = (float )0.0;
#line 1602
  (hm->b + 0)->ga = - 3.40282346638528859812e+38F;
#line 1603
  (hm->b + 0)->gb = - 3.40282346638528859812e+38F;
#line 1606
  hm->starta = *(old_cor + 0);
#line 1607
  hm->enda = *(old_cor + 4) - 1;
#line 1609
  hm->startb = *(old_cor + 2);
#line 1610
  hm->endb = c - 1;
#line 1612
  hirsch_path = hirsch_dna_pp_dyn(prof1, prof2, hm, hirsch_path);
#line 1615
  hm->starta = *(old_cor + 4);
#line 1616
  hm->enda = *(old_cor + 1);
#line 1617
  hm->startb = c + 1;
#line 1618
  hm->endb = *(old_cor + 3);
#line 1619
  (hm->f + 0)->a = - 3.40282346638528859812e+38F;
#line 1620
  (hm->f + 0)->ga = (float )0.0;
#line 1621
  (hm->f + 0)->gb = - 3.40282346638528859812e+38F;
#line 1622
  (hm->b + 0)->a = *(input_states + 3);
#line 1623
  (hm->b + 0)->ga = *(input_states + 4);
#line 1624
  (hm->b + 0)->gb = *(input_states + 5);
#line 1627
  hirsch_path = hirsch_dna_pp_dyn(prof1, prof2, hm, hirsch_path);
  }
#line 1628
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 1631
  *(hirsch_path + *(old_cor + 4)) = c;
#line 1634
  (hm->f + 0)->a = *(input_states + 0);
#line 1635
  (hm->f + 0)->ga = *(input_states + 1);
#line 1636
  (hm->f + 0)->gb = *(input_states + 2);
#line 1637
  (hm->b + 0)->a = (float )0.0;
#line 1638
  (hm->b + 0)->ga = - 3.40282346638528859812e+38F;
#line 1639
  (hm->b + 0)->gb = - 3.40282346638528859812e+38F;
#line 1641
  hm->starta = *(old_cor + 0);
#line 1642
  hm->enda = *(old_cor + 4) - 1;
#line 1644
  hm->startb = *(old_cor + 2);
#line 1645
  hm->endb = c - 1;
#line 1647
  hirsch_path = hirsch_dna_pp_dyn(prof1, prof2, hm, hirsch_path);
#line 1650
  hm->starta = *(old_cor + 4) + 1;
#line 1651
  hm->enda = *(old_cor + 1);
#line 1652
  hm->startb = c;
#line 1653
  hm->endb = *(old_cor + 3);
#line 1654
  (hm->f + 0)->a = - 3.40282346638528859812e+38F;
#line 1655
  (hm->f + 0)->ga = - 3.40282346638528859812e+38F;
#line 1656
  (hm->f + 0)->gb = (float )0.0;
#line 1657
  (hm->b + 0)->a = *(input_states + 3);
#line 1658
  (hm->b + 0)->ga = *(input_states + 4);
#line 1659
  (hm->b + 0)->gb = *(input_states + 5);
#line 1662
  hirsch_path = hirsch_dna_pp_dyn(prof1, prof2, hm, hirsch_path);
  }
#line 1663
  goto switch_break;
  case_5: /* CIL Label */ 
  {
#line 1665
  *(hirsch_path + (*(old_cor + 4) + 1)) = c + 1;
#line 1669
  (hm->f + 0)->a = *(input_states + 0);
#line 1670
  (hm->f + 0)->ga = *(input_states + 1);
#line 1671
  (hm->f + 0)->gb = *(input_states + 2);
#line 1672
  (hm->b + 0)->a = - 3.40282346638528859812e+38F;
#line 1673
  (hm->b + 0)->ga = (float )0.0;
#line 1674
  (hm->b + 0)->gb = - 3.40282346638528859812e+38F;
#line 1676
  hm->starta = *(old_cor + 0);
#line 1677
  hm->enda = *(old_cor + 4);
#line 1679
  hm->startb = *(old_cor + 2);
#line 1680
  hm->endb = c - 1;
#line 1682
  hirsch_path = hirsch_dna_pp_dyn(prof1, prof2, hm, hirsch_path);
#line 1685
  hm->starta = *(old_cor + 4) + 1;
#line 1686
  hm->enda = *(old_cor + 1);
#line 1687
  hm->startb = c + 1;
#line 1688
  hm->endb = *(old_cor + 3);
#line 1689
  (hm->f + 0)->a = (float )0.0;
#line 1690
  (hm->f + 0)->ga = - 3.40282346638528859812e+38F;
#line 1691
  (hm->f + 0)->gb = - 3.40282346638528859812e+38F;
#line 1692
  (hm->b + 0)->a = *(input_states + 3);
#line 1693
  (hm->b + 0)->ga = *(input_states + 4);
#line 1694
  (hm->b + 0)->gb = *(input_states + 5);
#line 1697
  hirsch_path = hirsch_dna_pp_dyn(prof1, prof2, hm, hirsch_path);
  }
#line 1698
  goto switch_break;
  case_6: /* CIL Label */ 
  {
#line 1702
  (hm->f + 0)->a = *(input_states + 0);
#line 1703
  (hm->f + 0)->ga = *(input_states + 1);
#line 1704
  (hm->f + 0)->gb = *(input_states + 2);
#line 1705
  (hm->b + 0)->a = - 3.40282346638528859812e+38F;
#line 1706
  (hm->b + 0)->ga = - 3.40282346638528859812e+38F;
#line 1707
  (hm->b + 0)->gb = (float )0.0;
#line 1709
  hm->starta = *(old_cor + 0);
#line 1710
  hm->enda = *(old_cor + 4) - 1;
#line 1711
  hm->startb = *(old_cor + 2);
#line 1712
  hm->endb = c;
#line 1714
  hirsch_path = hirsch_dna_pp_dyn(prof1, prof2, hm, hirsch_path);
#line 1717
  hm->starta = *(old_cor + 4) + 1;
#line 1718
  hm->enda = *(old_cor + 1);
#line 1719
  hm->startb = c;
#line 1720
  hm->endb = *(old_cor + 3);
#line 1721
  (hm->f + 0)->a = - 3.40282346638528859812e+38F;
#line 1722
  (hm->f + 0)->ga = - 3.40282346638528859812e+38F;
#line 1723
  (hm->f + 0)->gb = (float )0.0;
#line 1724
  (hm->b + 0)->a = *(input_states + 3);
#line 1725
  (hm->b + 0)->ga = *(input_states + 4);
#line 1726
  (hm->b + 0)->gb = *(input_states + 5);
#line 1729
  hirsch_path = hirsch_dna_pp_dyn(prof1, prof2, hm, hirsch_path);
  }
#line 1730
  goto switch_break;
  case_7: /* CIL Label */ 
  {
#line 1733
  *(hirsch_path + (*(old_cor + 4) + 1)) = c + 1;
#line 1736
  (hm->f + 0)->a = *(input_states + 0);
#line 1737
  (hm->f + 0)->ga = *(input_states + 1);
#line 1738
  (hm->f + 0)->gb = *(input_states + 2);
#line 1739
  (hm->b + 0)->a = - 3.40282346638528859812e+38F;
#line 1740
  (hm->b + 0)->ga = - 3.40282346638528859812e+38F;
#line 1741
  (hm->b + 0)->gb = (float )0.0;
#line 1743
  hm->starta = *(old_cor + 0);
#line 1744
  hm->enda = *(old_cor + 4) - 1;
#line 1745
  hm->startb = *(old_cor + 2);
#line 1746
  hm->endb = c;
#line 1748
  hirsch_path = hirsch_dna_pp_dyn(prof1, prof2, hm, hirsch_path);
#line 1751
  hm->starta = *(old_cor + 4) + 1;
#line 1752
  hm->enda = *(old_cor + 1);
#line 1753
  hm->startb = c + 1;
#line 1754
  hm->endb = *(old_cor + 3);
#line 1755
  (hm->f + 0)->a = (float )0.0;
#line 1756
  (hm->f + 0)->ga = - 3.40282346638528859812e+38F;
#line 1757
  (hm->f + 0)->gb = - 3.40282346638528859812e+38F;
#line 1758
  (hm->b + 0)->a = *(input_states + 3);
#line 1759
  (hm->b + 0)->ga = *(input_states + 4);
#line 1760
  (hm->b + 0)->gb = *(input_states + 5);
#line 1763
  hirsch_path = hirsch_dna_pp_dyn(prof1, prof2, hm, hirsch_path);
  }
#line 1764
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1767
  return (hirsch_path);
}
}
#line 1770 "/home/june/repo/benchmarks/collector/temp/kalign-2.03+20110620/kalign2_hirschberg_dna.c"
struct states *foward_hirsch_dna_pp_dyn(float const   *prof1 , float const   *prof2 ,
                                        struct hirsch_mem *hm ) 
{ 
  struct states *s ;
  register float pa ;
  register float pga ;
  register float pgb ;
  register float ca ;
  register int i ;
  register int j ;
  float tmp ;
  float tmp___0 ;
  float tmp___2 ;
  float tmp___3 ;
  float tmp___5 ;
  float tmp___6 ;
  float tmp___7 ;

  {
#line 1772
  s = hm->f;
#line 1774
  pa = (float )0;
#line 1775
  pga = (float )0;
#line 1776
  pgb = (float )0;
#line 1777
  ca = (float )0;
#line 1778
  i = 0;
#line 1779
  j = 0;
#line 1783
  prof1 += hm->starta * 22;
#line 1784
  prof2 += hm->startb * 22;
#line 1785
  (s + hm->startb)->a = (s + 0)->a;
#line 1786
  (s + hm->startb)->ga = (s + 0)->ga;
#line 1787
  (s + hm->startb)->gb = (s + 0)->gb;
#line 1788
  if (hm->startb == 0) {
#line 1789
    j = hm->startb + 1;
    {
#line 1789
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1789
      if (! (j < hm->endb)) {
#line 1789
        goto while_break;
      }
#line 1790
      prof2 += 22;
#line 1791
      (s + j)->a = - 3.40282346638528859812e+38F;
#line 1792
      if ((s + (j - 1))->ga > (s + (j - 1))->a) {
#line 1792
        tmp = (s + (j - 1))->ga;
      } else {
#line 1792
        tmp = (s + (j - 1))->a;
      }
#line 1792
      (s + j)->ga = tmp + (float )*(prof2 + 10);
#line 1793
      (s + j)->gb = - 3.40282346638528859812e+38F;
#line 1789
      j ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 1795
    prof2 += 22;
  } else {
#line 1798
    j = hm->startb + 1;
    {
#line 1798
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1798
      if (! (j < hm->endb)) {
#line 1798
        goto while_break___0;
      }
#line 1799
      prof2 += 22;
#line 1800
      (s + j)->a = - 3.40282346638528859812e+38F;
#line 1801
      if ((s + (j - 1))->ga + (float )*(prof2 + 9) > (s + (j - 1))->a + (float )*(prof2 + 8)) {
#line 1801
        (s + j)->ga = (s + (j - 1))->ga + (float )*(prof2 + 9);
      } else {
#line 1801
        (s + j)->ga = (s + (j - 1))->a + (float )*(prof2 + 8);
      }
#line 1802
      (s + j)->gb = - 3.40282346638528859812e+38F;
#line 1798
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1804
    prof2 += 22;
  }
#line 1807
  prof2 -= (hm->endb - hm->startb) * 22;
#line 1809
  (s + hm->endb)->a = - 3.40282346638528859812e+38F;
#line 1810
  (s + hm->endb)->ga = - 3.40282346638528859812e+38F;
#line 1811
  (s + hm->endb)->gb = - 3.40282346638528859812e+38F;
#line 1814
  i = hm->starta;
  {
#line 1814
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1814
    if (! (i < hm->enda)) {
#line 1814
      goto while_break___1;
    }
#line 1815
    prof1 += 22;
#line 1817
    pa = (s + hm->startb)->a;
#line 1818
    pga = (s + hm->startb)->ga;
#line 1819
    pgb = (s + hm->startb)->gb;
#line 1820
    (s + hm->startb)->a = - 3.40282346638528859812e+38F;
#line 1821
    (s + hm->startb)->ga = - 3.40282346638528859812e+38F;
#line 1822
    if (hm->startb == 0) {
#line 1823
      if (pgb > pa) {
#line 1823
        tmp___0 = pgb;
      } else {
#line 1823
        tmp___0 = pa;
      }
#line 1823
      (s + hm->startb)->gb = tmp___0 + (float )*(prof1 + 10);
    } else
#line 1825
    if (pgb + (float )*(prof1 + 9) > pa + (float )*(prof1 + 8)) {
#line 1825
      (s + hm->startb)->gb = pgb + (float )*(prof1 + 9);
    } else {
#line 1825
      (s + hm->startb)->gb = pa + (float )*(prof1 + 8);
    }
#line 1827
    j = hm->startb + 1;
    {
#line 1827
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1827
      if (! (j < hm->endb)) {
#line 1827
        goto while_break___2;
      }
#line 1828
      prof2 += 22;
#line 1829
      ca = (s + j)->a;
#line 1830
      if (pa > pga + (float )*(prof2 + -14)) {
#line 1830
        tmp___3 = pa;
      } else {
#line 1830
        tmp___3 = pga + (float )*(prof2 + -14);
      }
#line 1830
      if (tmp___3 > pgb + (float )*(prof1 + -14)) {
#line 1830
        if (pa > pga + (float )*(prof2 + -14)) {
#line 1830
          tmp___2 = pa;
        } else {
#line 1830
          tmp___2 = pga + (float )*(prof2 + -14);
        }
#line 1830
        pa = tmp___2;
      } else {
#line 1830
        pa = pgb + (float )*(prof1 + -14);
      }
#line 1832
      prof2 += 11;
#line 1834
      pa += (float )(*(prof1 + 0) * *(prof2 + 0));
#line 1835
      pa += (float )(*(prof1 + 1) * *(prof2 + 1));
#line 1836
      pa += (float )(*(prof1 + 2) * *(prof2 + 2));
#line 1837
      pa += (float )(*(prof1 + 3) * *(prof2 + 3));
#line 1838
      pa += (float )(*(prof1 + 4) * *(prof2 + 4));
#line 1839
      pa += (float )(*(prof1 + 5) * *(prof2 + 5));
#line 1840
      pa += (float )(*(prof1 + 6) * *(prof2 + 6));
#line 1841
      pa += (float )(*(prof1 + 7) * *(prof2 + 7));
#line 1844
      prof2 -= 11;
#line 1846
      (s + j)->a = pa;
#line 1848
      pga = (s + j)->ga;
#line 1850
      if ((s + (j - 1))->ga + (float )*(prof2 + 9) > (s + (j - 1))->a + (float )*(prof2 + 8)) {
#line 1850
        (s + j)->ga = (s + (j - 1))->ga + (float )*(prof2 + 9);
      } else {
#line 1850
        (s + j)->ga = (s + (j - 1))->a + (float )*(prof2 + 8);
      }
#line 1852
      pgb = (s + j)->gb;
#line 1854
      if (pgb + (float )*(prof1 + 9) > ca + (float )*(prof1 + 8)) {
#line 1854
        (s + j)->gb = pgb + (float )*(prof1 + 9);
      } else {
#line 1854
        (s + j)->gb = ca + (float )*(prof1 + 8);
      }
#line 1856
      pa = ca;
#line 1827
      j ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 1858
    prof2 += 22;
#line 1859
    ca = (s + j)->a;
#line 1861
    if (pa > pga + (float )*(prof2 + -14)) {
#line 1861
      tmp___6 = pa;
    } else {
#line 1861
      tmp___6 = pga + (float )*(prof2 + -14);
    }
#line 1861
    if (tmp___6 > pgb + (float )*(prof1 + -14)) {
#line 1861
      if (pa > pga + (float )*(prof2 + -14)) {
#line 1861
        tmp___5 = pa;
      } else {
#line 1861
        tmp___5 = pga + (float )*(prof2 + -14);
      }
#line 1861
      pa = tmp___5;
    } else {
#line 1861
      pa = pgb + (float )*(prof1 + -14);
    }
#line 1862
    prof2 += 11;
#line 1864
    pa += (float )(*(prof1 + 0) * *(prof2 + 0));
#line 1865
    pa += (float )(*(prof1 + 1) * *(prof2 + 1));
#line 1866
    pa += (float )(*(prof1 + 2) * *(prof2 + 2));
#line 1867
    pa += (float )(*(prof1 + 3) * *(prof2 + 3));
#line 1868
    pa += (float )(*(prof1 + 4) * *(prof2 + 4));
#line 1869
    pa += (float )(*(prof1 + 5) * *(prof2 + 5));
#line 1870
    pa += (float )(*(prof1 + 6) * *(prof2 + 6));
#line 1871
    pa += (float )(*(prof1 + 7) * *(prof2 + 7));
#line 1873
    prof2 -= 11;
#line 1875
    (s + j)->a = pa;
#line 1877
    (s + j)->ga = - 3.40282346638528859812e+38F;
#line 1879
    if (hm->endb != hm->len_b) {
#line 1880
      if ((s + j)->gb + (float )*(prof1 + 9) > ca + (float )*(prof1 + 8)) {
#line 1880
        (s + j)->gb += (float )*(prof1 + 9);
      } else {
#line 1880
        (s + j)->gb = ca + (float )*(prof1 + 8);
      }
    } else {
#line 1882
      if ((s + j)->gb > ca) {
#line 1882
        tmp___7 = (s + j)->gb;
      } else {
#line 1882
        tmp___7 = ca;
      }
#line 1882
      (s + j)->gb = tmp___7 + (float )*(prof1 + 10);
    }
#line 1886
    prof2 -= (hm->endb - hm->startb) * 22;
#line 1814
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1889
  prof1 -= 22 * hm->enda;
#line 1890
  return (s);
}
}
#line 1893 "/home/june/repo/benchmarks/collector/temp/kalign-2.03+20110620/kalign2_hirschberg_dna.c"
struct states *backward_hirsch_dna_pp_dyn(float const   *prof1 , float const   *prof2 ,
                                          struct hirsch_mem *hm ) 
{ 
  struct states *s ;
  register float pa ;
  register float pga ;
  register float pgb ;
  register float ca ;
  register int i ;
  register int j ;
  float tmp ;
  float tmp___0 ;
  float tmp___2 ;
  float tmp___3 ;
  float tmp___5 ;
  float tmp___6 ;
  float tmp___7 ;
  int tmp___8 ;

  {
#line 1895
  s = hm->b;
#line 1896
  pa = (float )0;
#line 1897
  pga = (float )0;
#line 1898
  pgb = (float )0;
#line 1899
  ca = (float )0;
#line 1900
  i = 0;
#line 1901
  j = 0;
#line 1903
  prof1 += (hm->enda + 1) * 22;
#line 1904
  prof2 += (hm->endb + 1) * 22;
#line 1905
  (s + hm->endb)->a = (s + 0)->a;
#line 1906
  (s + hm->endb)->ga = (s + 0)->ga;
#line 1907
  (s + hm->endb)->gb = (s + 0)->gb;
#line 1912
  if (hm->endb == hm->len_b) {
#line 1914
    j = hm->endb - 1;
    {
#line 1914
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1914
      if (! (j > hm->startb)) {
#line 1914
        goto while_break;
      }
#line 1915
      prof2 -= 22;
#line 1916
      (s + j)->a = - 3.40282346638528859812e+38F;
#line 1917
      if ((s + (j + 1))->ga > (s + (j + 1))->a) {
#line 1917
        tmp = (s + (j + 1))->ga;
      } else {
#line 1917
        tmp = (s + (j + 1))->a;
      }
#line 1917
      (s + j)->ga = tmp + (float )*(prof2 + 10);
#line 1918
      (s + j)->gb = - 3.40282346638528859812e+38F;
#line 1914
      j --;
    }
    while_break: /* CIL Label */ ;
    }
#line 1920
    prof2 -= 22;
  } else {
#line 1922
    j = hm->endb - 1;
    {
#line 1922
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1922
      if (! (j > hm->startb)) {
#line 1922
        goto while_break___0;
      }
#line 1923
      prof2 -= 22;
#line 1924
      (s + j)->a = - 3.40282346638528859812e+38F;
#line 1925
      if ((s + (j + 1))->ga + (float )*(prof2 + 9) > (s + (j + 1))->a + (float )*(prof2 + 8)) {
#line 1925
        (s + j)->ga = (s + (j + 1))->ga + (float )*(prof2 + 9);
      } else {
#line 1925
        (s + j)->ga = (s + (j + 1))->a + (float )*(prof2 + 8);
      }
#line 1926
      (s + j)->gb = - 3.40282346638528859812e+38F;
#line 1922
      j --;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1928
    prof2 -= 22;
  }
#line 1931
  (s + hm->startb)->a = - 3.40282346638528859812e+38F;
#line 1932
  (s + hm->startb)->ga = - 3.40282346638528859812e+38F;
#line 1933
  (s + hm->startb)->gb = - 3.40282346638528859812e+38F;
#line 1935
  i = hm->enda - hm->starta;
  {
#line 1936
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1936
    tmp___8 = i;
#line 1936
    i --;
#line 1936
    if (! tmp___8) {
#line 1936
      goto while_break___1;
    }
#line 1937
    prof1 -= 22;
#line 1939
    pa = (s + hm->endb)->a;
#line 1940
    pga = (s + hm->endb)->ga;
#line 1941
    pgb = (s + hm->endb)->gb;
#line 1942
    (s + hm->endb)->a = - 3.40282346638528859812e+38F;
#line 1943
    (s + hm->endb)->ga = - 3.40282346638528859812e+38F;
#line 1945
    if (hm->endb == hm->len_b) {
#line 1946
      if (pgb > pa) {
#line 1946
        tmp___0 = pgb;
      } else {
#line 1946
        tmp___0 = pa;
      }
#line 1946
      (s + hm->endb)->gb = tmp___0 + (float )*(prof1 + 10);
    } else
#line 1948
    if (pgb + (float )*(prof1 + 9) > pa + (float )*(prof1 + 8)) {
#line 1948
      (s + hm->endb)->gb = pgb + (float )*(prof1 + 9);
    } else {
#line 1948
      (s + hm->endb)->gb = pa + (float )*(prof1 + 8);
    }
#line 1951
    prof2 += (hm->endb - hm->startb) * 22;
#line 1953
    j = hm->endb - 1;
    {
#line 1953
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1953
      if (! (j > hm->startb)) {
#line 1953
        goto while_break___2;
      }
#line 1954
      prof2 -= 22;
#line 1955
      ca = (s + j)->a;
#line 1957
      if (pa > pga + (float )*(prof2 + 30)) {
#line 1957
        tmp___3 = pa;
      } else {
#line 1957
        tmp___3 = pga + (float )*(prof2 + 30);
      }
#line 1957
      if (tmp___3 > pgb + (float )*(prof1 + 30)) {
#line 1957
        if (pa > pga + (float )*(prof2 + 30)) {
#line 1957
          tmp___2 = pa;
        } else {
#line 1957
          tmp___2 = pga + (float )*(prof2 + 30);
        }
#line 1957
        pa = tmp___2;
      } else {
#line 1957
        pa = pgb + (float )*(prof1 + 30);
      }
#line 1959
      prof2 += 11;
#line 1960
      pa += (float )(*(prof1 + 0) * *(prof2 + 0));
#line 1961
      pa += (float )(*(prof1 + 1) * *(prof2 + 1));
#line 1962
      pa += (float )(*(prof1 + 2) * *(prof2 + 2));
#line 1963
      pa += (float )(*(prof1 + 3) * *(prof2 + 3));
#line 1964
      pa += (float )(*(prof1 + 4) * *(prof2 + 4));
#line 1965
      pa += (float )(*(prof1 + 5) * *(prof2 + 5));
#line 1966
      pa += (float )(*(prof1 + 6) * *(prof2 + 6));
#line 1967
      pa += (float )(*(prof1 + 7) * *(prof2 + 7));
#line 1968
      prof2 -= 11;
#line 1970
      (s + j)->a = pa;
#line 1972
      pga = (s + j)->ga;
#line 1974
      if ((s + (j + 1))->ga + (float )*(prof2 + 9) > (s + (j + 1))->a + (float )*(prof2 + 8)) {
#line 1974
        (s + j)->ga = (s + (j + 1))->ga + (float )*(prof2 + 9);
      } else {
#line 1974
        (s + j)->ga = (s + (j + 1))->a + (float )*(prof2 + 8);
      }
#line 1976
      pgb = (s + j)->gb;
#line 1978
      if (pgb + (float )*(prof1 + 9) > ca + (float )*(prof1 + 8)) {
#line 1978
        (s + j)->gb = pgb + (float )*(prof1 + 9);
      } else {
#line 1978
        (s + j)->gb = ca + (float )*(prof1 + 8);
      }
#line 1980
      pa = ca;
#line 1953
      j --;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 1982
    prof2 -= 22;
#line 1983
    ca = (s + j)->a;
#line 1985
    if (pa > pga + (float )*(prof2 + 30)) {
#line 1985
      tmp___6 = pa;
    } else {
#line 1985
      tmp___6 = pga + (float )*(prof2 + 30);
    }
#line 1985
    if (tmp___6 > pgb + (float )*(prof1 + 30)) {
#line 1985
      if (pa > pga + (float )*(prof2 + 30)) {
#line 1985
        tmp___5 = pa;
      } else {
#line 1985
        tmp___5 = pga + (float )*(prof2 + 30);
      }
#line 1985
      pa = tmp___5;
    } else {
#line 1985
      pa = pgb + (float )*(prof1 + 30);
    }
#line 1987
    prof2 += 11;
#line 1988
    pa += (float )(*(prof1 + 0) * *(prof2 + 0));
#line 1989
    pa += (float )(*(prof1 + 1) * *(prof2 + 1));
#line 1990
    pa += (float )(*(prof1 + 2) * *(prof2 + 2));
#line 1991
    pa += (float )(*(prof1 + 3) * *(prof2 + 3));
#line 1992
    pa += (float )(*(prof1 + 4) * *(prof2 + 4));
#line 1993
    pa += (float )(*(prof1 + 5) * *(prof2 + 5));
#line 1994
    pa += (float )(*(prof1 + 6) * *(prof2 + 6));
#line 1995
    pa += (float )(*(prof1 + 7) * *(prof2 + 7));
#line 1996
    prof2 -= 11;
#line 1998
    (s + j)->a = pa;
#line 2001
    (s + j)->ga = - 3.40282346638528859812e+38F;
#line 2004
    if (hm->startb) {
#line 2005
      if ((s + j)->gb + (float )*(prof1 + 9) > ca + (float )*(prof1 + 8)) {
#line 2005
        (s + j)->gb += (float )*(prof1 + 9);
      } else {
#line 2005
        (s + j)->gb = ca + (float )*(prof1 + 8);
      }
    } else {
#line 2007
      if ((s + j)->gb > ca) {
#line 2007
        tmp___7 = (s + j)->gb;
      } else {
#line 2007
        tmp___7 = ca;
      }
#line 2007
      (s + j)->gb = tmp___7 + (float )*(prof1 + 10);
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 2010
  return (s);
}
}
#line 28 "/home/june/repo/benchmarks/collector/temp/kalign-2.03+20110620/kalign2_string_matching.c"
int byg_detect(int *text , int n ) 
{ 
  int Tc ;
  int i ;
  int s ;
  int T[256] ;
  int mb ;
  char *unique_aa ;
  int aacode[26] ;

  {
#line 31
  i = 0;
#line 32
  s = 0;
#line 34
  i = 0;
  {
#line 34
  while (1) {
    while_continue: /* CIL Label */ ;
#line 34
    if (! (i < 256)) {
#line 34
      goto while_break;
    }
#line 35
    T[i] = 0;
#line 34
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 37
  mb = 1;
#line 40
  unique_aa = (char *)"BDEFHIJKLMNOPQRSVWYZ";
#line 41
  aacode[0] = 0;
#line 41
  aacode[1] = 1;
#line 41
  aacode[2] = 2;
#line 41
  aacode[3] = 3;
#line 41
  aacode[4] = 4;
#line 41
  aacode[5] = 5;
#line 41
  aacode[6] = 6;
#line 41
  aacode[7] = 7;
#line 41
  aacode[8] = 8;
#line 41
  aacode[9] = -1;
#line 41
  aacode[10] = 9;
#line 41
  aacode[11] = 10;
#line 41
  aacode[12] = 11;
#line 41
  aacode[13] = 12;
#line 41
  aacode[14] = 23;
#line 41
  aacode[15] = 13;
#line 41
  aacode[16] = 14;
#line 41
  aacode[17] = 15;
#line 41
  aacode[18] = 16;
#line 41
  aacode[19] = 17;
#line 41
  aacode[20] = 17;
#line 41
  aacode[21] = 18;
#line 41
  aacode[22] = 19;
#line 41
  aacode[23] = 20;
#line 41
  aacode[24] = 21;
#line 41
  aacode[25] = 22;
#line 42
  i = 0;
  {
#line 42
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 42
    if (! (i < 20)) {
#line 42
      goto while_break___0;
    }
#line 43
    T[aacode[(int )*(unique_aa + i) - 65]] |= 1;
#line 42
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 45
  i = 0;
  {
#line 45
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 45
    if (! (i < n)) {
#line 45
      goto while_break___1;
    }
#line 47
    if (*(text + i) != -1) {
#line 48
      s <<= 1;
#line 49
      s |= 1;
#line 50
      Tc = T[*(text + i)];
#line 51
      s &= Tc;
#line 52
      if (s & mb) {
#line 53
        return (0);
      }
    }
#line 45
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 57
  return (1);
}
}
#line 60 "/home/june/repo/benchmarks/collector/temp/kalign-2.03+20110620/kalign2_string_matching.c"
int check_identity(char *n , char *m ) 
{ 
  int len_n ;
  int len_m ;
  int i ;
  size_t tmp ;
  size_t tmp___0 ;

  {
  {
#line 66
  tmp = strlen((char const   *)n);
#line 66
  len_n = (int )tmp;
#line 67
  tmp___0 = strlen((char const   *)m);
#line 67
  len_m = (int )tmp___0;
  }
#line 68
  if (len_m != len_n) {
#line 69
    return (-1);
  }
#line 71
  i = 0;
  {
#line 71
  while (1) {
    while_continue: /* CIL Label */ ;
#line 71
    if (! (i < len_n)) {
#line 71
      goto while_break;
    }
#line 72
    if ((int )*(n + i) != (int )*(m + i)) {
#line 73
      return (-1);
    }
#line 71
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 76
  return (1);
}
}
#line 81 "/home/june/repo/benchmarks/collector/temp/kalign-2.03+20110620/kalign2_string_matching.c"
int byg_count(char *pattern , char *text ) 
{ 
  int Tc ;
  int count ;
  int i ;
  int s ;
  int T[256] ;
  int m ;
  size_t tmp ;
  int n ;
  size_t tmp___0 ;
  int mb ;

  {
#line 84
  count = 0;
#line 85
  i = 0;
#line 86
  s = 0;
#line 88
  i = 0;
  {
#line 88
  while (1) {
    while_continue: /* CIL Label */ ;
#line 88
    if (! (i < 256)) {
#line 88
      goto while_break;
    }
#line 89
    T[i] = 0;
#line 88
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 92
  tmp = strlen((char const   *)pattern);
#line 92
  m = (int )tmp;
#line 93
  tmp___0 = strlen((char const   *)text);
#line 93
  n = (int )tmp___0;
#line 94
  mb = 1 << (m - 1);
#line 96
  i = 0;
  }
  {
#line 96
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 96
    if (! (i < m)) {
#line 96
      goto while_break___0;
    }
#line 97
    T[(int )*(pattern + i)] |= 1 << i;
#line 96
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 100
  i = 0;
  {
#line 100
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 100
    if (! (i < n)) {
#line 100
      goto while_break___1;
    }
#line 101
    s <<= 1;
#line 102
    s |= 1;
#line 103
    Tc = T[(int )*(text + i)];
#line 104
    s &= Tc;
#line 105
    if (s & mb) {
#line 106
      count ++;
    }
#line 100
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 109
  return (count);
}
}
#line 112 "/home/june/repo/benchmarks/collector/temp/kalign-2.03+20110620/kalign2_string_matching.c"
int byg_end(char *pattern , char *text ) 
{ 
  int Tc ;
  int i ;
  int s ;
  int T[256] ;
  int m ;
  size_t tmp ;
  int n ;
  size_t tmp___0 ;
  int mb ;

  {
#line 115
  i = 0;
#line 116
  s = 0;
#line 118
  i = 0;
  {
#line 118
  while (1) {
    while_continue: /* CIL Label */ ;
#line 118
    if (! (i < 256)) {
#line 118
      goto while_break;
    }
#line 119
    T[i] = 0;
#line 118
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 122
  tmp = strlen((char const   *)pattern);
#line 122
  m = (int )tmp;
#line 123
  tmp___0 = strlen((char const   *)text);
#line 123
  n = (int )tmp___0;
#line 124
  mb = 1 << (m - 1);
#line 126
  i = 0;
  }
  {
#line 126
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 126
    if (! (i < m)) {
#line 126
      goto while_break___0;
    }
#line 127
    T[(int )*(pattern + i)] |= 1 << i;
#line 126
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 130
  i = 0;
  {
#line 130
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 130
    if (! (i < n)) {
#line 130
      goto while_break___1;
    }
#line 131
    s <<= 1;
#line 132
    s |= 1;
#line 133
    if (! *(text + i)) {
#line 134
      return (-1);
    }
#line 136
    Tc = T[(int )*(text + i)];
#line 137
    s &= Tc;
#line 138
    if (s & mb) {
#line 139
      return (i + 1);
    }
#line 130
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 142
  return (-1);
}
}
#line 145 "/home/june/repo/benchmarks/collector/temp/kalign-2.03+20110620/kalign2_string_matching.c"
int byg_start(char *pattern , char *text ) 
{ 
  int Tc ;
  int i ;
  int s ;
  int T[256] ;
  int m ;
  size_t tmp ;
  int n ;
  size_t tmp___0 ;
  int mb ;

  {
#line 148
  i = 0;
#line 149
  s = 0;
#line 151
  i = 0;
  {
#line 151
  while (1) {
    while_continue: /* CIL Label */ ;
#line 151
    if (! (i < 256)) {
#line 151
      goto while_break;
    }
#line 152
    T[i] = 0;
#line 151
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 155
  tmp = strlen((char const   *)pattern);
#line 155
  m = (int )tmp;
#line 156
  tmp___0 = strlen((char const   *)text);
#line 156
  n = (int )tmp___0;
#line 157
  mb = 1 << (m - 1);
#line 159
  i = 0;
  }
  {
#line 159
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 159
    if (! (i < m)) {
#line 159
      goto while_break___0;
    }
#line 160
    T[(int )*(pattern + i)] |= 1 << i;
#line 159
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 163
  i = 0;
  {
#line 163
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 163
    if (! (i < n)) {
#line 163
      goto while_break___1;
    }
#line 164
    s <<= 1;
#line 165
    s |= 1;
#line 166
    Tc = T[(int )*(text + i)];
#line 167
    s &= Tc;
#line 168
    if (s & mb) {
#line 169
      return ((i - m) + 1);
    }
#line 163
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 172
  return (-1);
}
}
#line 253 "/home/june/repo/benchmarks/collector/temp/kalign-2.03+20110620/kalign2.h"
float get_distance_from_pairwise_alignment(int *path , int *seq1 , int *seq2 ) ;
#line 256
float protein_wu_distance_calculation2(struct node **hash , int *seq , int seqlen ,
                                       int diagonals , int mode ) ;
#line 342
struct alignment *protein_wu_sw(struct node **hash , struct alignment *aln , int a ,
                                int b ) ;
#line 343
float protein_wu_distance_calculation3(struct node **hash , int *seq , int seqlen ,
                                       int diagonals , int mode ) ;
#line 28 "/home/june/repo/benchmarks/collector/temp/kalign-2.03+20110620/kalign2_distance_calculation.c"
float **protein_pairwise_alignment_distance(struct alignment *aln , float **dm , struct parameters *param ,
                                            float **subm , int nj___0 ) 
{ 
  int i ;
  int j ;
  int c ;
  int *path ;
  int len_a ;
  int len_b ;
  struct dp_matrix *dp ;
  int a ;
  int b ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  void *tmp___7 ;
  int tmp___8 ;

  {
  {
#line 31
  path = (int *)0;
#line 32
  len_a = 0;
#line 33
  len_b = 0;
#line 34
  dp = (struct dp_matrix *)0;
#line 38
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Distance Calculation:\n");
#line 40
  b = (int )((numseq * (numseq - 1U)) / 2U);
#line 41
  a = 1;
#line 45
  dp = dp_matrix_alloc(dp, 511, 511);
  }
#line 47
  if (nj___0) {
    {
#line 48
    tmp = malloc(sizeof(float *) * (unsigned long )numprofiles);
#line 48
    dm = (float **)tmp;
#line 49
    i = (int )numprofiles;
    }
    {
#line 49
    while (1) {
      while_continue: /* CIL Label */ ;
#line 49
      tmp___2 = i;
#line 49
      i --;
#line 49
      if (! tmp___2) {
#line 49
        goto while_break;
      }
      {
#line 50
      tmp___0 = malloc(sizeof(float ) * (unsigned long )numprofiles);
#line 50
      *(dm + i) = (float *)tmp___0;
#line 51
      j = (int )numprofiles;
      }
      {
#line 51
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 51
        tmp___1 = j;
#line 51
        j --;
#line 51
        if (! tmp___1) {
#line 51
          goto while_break___0;
        }
#line 52
        *(*(dm + i) + j) = 0.0f;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
#line 56
    tmp___3 = malloc(sizeof(float *) * (unsigned long )numseq);
#line 56
    dm = (float **)tmp___3;
#line 57
    i = (int )numseq;
    }
    {
#line 57
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 57
      tmp___6 = i;
#line 57
      i --;
#line 57
      if (! tmp___6) {
#line 57
        goto while_break___1;
      }
      {
#line 58
      tmp___4 = malloc(sizeof(float ) * (unsigned long )numseq);
#line 58
      *(dm + i) = (float *)tmp___4;
#line 59
      j = (int )numseq;
      }
      {
#line 59
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 59
        tmp___5 = j;
#line 59
        j --;
#line 59
        if (! tmp___5) {
#line 59
          goto while_break___2;
        }
#line 60
        *(*(dm + i) + j) = 0.0f;
      }
      while_break___2: /* CIL Label */ ;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 72
  i = 0;
  {
#line 72
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 72
    if (! ((unsigned int )i < numseq - 1U)) {
#line 72
      goto while_break___3;
    }
#line 73
    len_a = (int )*(aln->sl + i);
#line 74
    j = i + 1;
    {
#line 74
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 74
      if (! ((unsigned int )j < numseq)) {
#line 74
        goto while_break___4;
      }
      {
#line 76
      len_b = (int )*(aln->sl + j);
#line 77
      tmp___7 = malloc(sizeof(int ) * (unsigned long )((len_a + len_b) + 2));
#line 77
      path = (int *)tmp___7;
#line 78
      c = (len_a + len_b) + 2;
      }
      {
#line 78
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 78
        tmp___8 = c;
#line 78
        c --;
#line 78
        if (! tmp___8) {
#line 78
          goto while_break___5;
        }
#line 79
        *(path + c) = 0;
      }
      while_break___5: /* CIL Label */ ;
      }
      {
#line 81
      dp = dp_matrix_realloc(dp, len_a, len_b);
#line 82
      path = ss_dyn(subm, path, dp, (int const   *)*(aln->s + i), (int const   *)*(aln->s + j),
                    (int const   )len_a, (int const   )len_b);
#line 83
      *(*(dm + i) + j) = get_distance_from_pairwise_alignment(path, *(aln->s + i),
                                                              *(aln->s + j));
#line 84
      *(*(dm + j) + i) = *(*(dm + i) + j);
#line 85
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\r%8.0f percent done",
              (double )(((float )a / (float )b) * (float )100));
#line 86
      a ++;
#line 88
      free((void *)path);
#line 74
      j ++;
      }
    }
    while_break___4: /* CIL Label */ ;
    }
#line 72
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 91
  dp_matrix_free(dp);
  }
#line 92
  return (dm);
}
}
#line 95 "/home/june/repo/benchmarks/collector/temp/kalign-2.03+20110620/kalign2_distance_calculation.c"
float get_distance_from_pairwise_alignment(int *path , int *seq1 , int *seq2 ) 
{ 
  float dist ;
  int i ;
  int j ;
  int c ;
  int pairs ;
  int identical ;

  {
#line 97
  dist = (float )0;
#line 99
  pairs = 0;
#line 100
  identical = 0;
#line 101
  i = 0;
#line 102
  j = 0;
#line 103
  c = 1;
  {
#line 104
  while (1) {
    while_continue: /* CIL Label */ ;
#line 104
    if (! (*(path + c) != 3)) {
#line 104
      goto while_break;
    }
#line 105
    if (! *(path + c)) {
#line 106
      if (*(seq1 + i) == *(seq2 + j)) {
#line 107
        identical ++;
      }
#line 109
      pairs ++;
#line 110
      i ++;
#line 111
      j ++;
    }
#line 113
    if (*(path + c) & 1) {
#line 114
      j ++;
    }
#line 116
    if (*(path + c) & 2) {
#line 117
      i ++;
    }
#line 119
    c ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 121
  dist = ((float )identical / (float )pairs) * (float )100;
#line 123
  return (dist);
}
}
#line 127 "/home/june/repo/benchmarks/collector/temp/kalign-2.03+20110620/kalign2_distance_calculation.c"
float **protein_wu_distance2(struct alignment *aln , float **dm , struct parameters *param ) 
{ 
  struct node *hash[1024] ;
  int i ;
  int j ;
  unsigned int hv ;
  int *p ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  unsigned int tmp___5 ;
  int tmp___6 ;

  {
#line 132
  p = (int *)0;
#line 133
  i = 0;
  {
#line 133
  while (1) {
    while_continue: /* CIL Label */ ;
#line 133
    if (! (i < 1024)) {
#line 133
      goto while_break;
    }
#line 134
    hash[i] = (struct node *)0;
#line 133
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 137
  if (! aln->ft) {
    {
#line 138
    tmp = malloc(sizeof(struct feature *) * (unsigned long )numseq);
#line 138
    aln->ft = (struct feature **)tmp;
#line 140
    i = 0;
    }
    {
#line 140
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 140
      if (! ((unsigned int )i < numseq)) {
#line 140
        goto while_break___0;
      }
#line 141
      *(aln->ft + i) = (struct feature *)0;
#line 140
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  {
#line 144
  tmp___0 = malloc(sizeof(float *) * (unsigned long )numprofiles);
#line 144
  dm = (float **)tmp___0;
#line 145
  i = (int )numprofiles;
  }
  {
#line 145
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 145
    tmp___3 = i;
#line 145
    i --;
#line 145
    if (! tmp___3) {
#line 145
      goto while_break___1;
    }
    {
#line 146
    tmp___1 = malloc(sizeof(float ) * (unsigned long )numprofiles);
#line 146
    *(dm + i) = (float *)tmp___1;
#line 147
    j = (int )numprofiles;
    }
    {
#line 147
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 147
      tmp___2 = j;
#line 147
      j --;
#line 147
      if (! tmp___2) {
#line 147
        goto while_break___2;
      }
#line 148
      *(*(dm + i) + j) = 0.0f;
    }
    while_break___2: /* CIL Label */ ;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 153
  i = 0;
  {
#line 153
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 153
    if (! ((unsigned int )i < numseq - 1U)) {
#line 153
      goto while_break___3;
    }
#line 154
    p = *(aln->s + i);
#line 156
    j = (int )(*(aln->sl + i) - 2U);
    {
#line 156
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 156
      tmp___4 = j;
#line 156
      j --;
#line 156
      if (! tmp___4) {
#line 156
        goto while_break___4;
      }
      {
#line 157
      hv = (unsigned int )((*(p + j) << 5) + *(p + (j + 1)));
#line 158
      hash[hv] = insert_hash(hash[hv], j + 1);
#line 160
      hv = (unsigned int )((*(p + j) << 5) + *(p + (j + 2)));
#line 161
      hash[hv] = insert_hash(hash[hv], j + 1);
#line 162
      hv = (unsigned int )((*(p + (j + 1)) << 5) + *(p + (j + 2)));
#line 163
      hash[hv] = insert_hash(hash[hv], j + 1);
      }
    }
    while_break___4: /* CIL Label */ ;
    }
#line 166
    j = i + 1;
    {
#line 166
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 166
      if (! ((unsigned int )j < numseq)) {
#line 166
        goto while_break___5;
      }
      {
#line 167
      *(*(dm + i) + j) = protein_wu_distance_calculation3(hash, *(aln->s + j), (int )*(aln->sl + j),
                                                          (int )(*(aln->sl + j) + *(aln->sl + i)),
                                                          (int )param->zlevel);
      }
#line 169
      if (*(aln->sl + i) > *(aln->sl + j)) {
#line 169
        tmp___5 = *(aln->sl + j);
      } else {
#line 169
        tmp___5 = *(aln->sl + i);
      }
#line 169
      *(*(dm + i) + j) /= (float )tmp___5;
#line 170
      *(*(dm + j) + i) = *(*(dm + i) + j);
#line 166
      j ++;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 173
    j = 1024;
    {
#line 173
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 173
      tmp___6 = j;
#line 173
      j --;
#line 173
      if (! tmp___6) {
#line 173
        goto while_break___6;
      }
#line 174
      if (hash[j]) {
        {
#line 175
        remove_nodes(hash[j]);
#line 176
        hash[j] = (struct node *)0;
        }
      }
    }
    while_break___6: /* CIL Label */ ;
    }
#line 153
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 180
  return (dm);
}
}
#line 184 "/home/june/repo/benchmarks/collector/temp/kalign-2.03+20110620/kalign2_distance_calculation.c"
float protein_wu_distance_calculation2(struct node **hash , int *seq , int seqlen ,
                                       int diagonals , int mode ) 
{ 
  struct node *node_p ;
  int *d ;
  float out ;
  int i ;
  unsigned int hv ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 188
  d = (int *)0;
#line 189
  out = (float )0.0;
#line 193
  tmp = malloc(sizeof(int ) * (unsigned long )diagonals);
#line 193
  d = (int *)tmp;
#line 195
  i = 0;
  }
  {
#line 195
  while (1) {
    while_continue: /* CIL Label */ ;
#line 195
    if (! (i < diagonals)) {
#line 195
      goto while_break;
    }
#line 196
    *(d + i) = 0;
#line 195
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 198
  i = seqlen - 2;
  {
#line 198
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 198
    tmp___0 = i;
#line 198
    i --;
#line 198
    if (! tmp___0) {
#line 198
      goto while_break___0;
    }
#line 200
    hv = (unsigned int )((*(seq + i) << 5) + *(seq + (i + 1)));
#line 202
    if (*(hash + hv)) {
#line 203
      node_p = *(hash + hv);
      {
#line 204
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 204
        if (! node_p) {
#line 204
          goto while_break___1;
        }
#line 205
        (*(d + node_p->pos)) ++;
#line 207
        node_p = node_p->next;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
#line 212
    hv = (unsigned int )((*(seq + i) << 5) + *(seq + (i + 2)));
#line 214
    if (*(hash + hv)) {
#line 215
      node_p = *(hash + hv);
      {
#line 216
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 216
        if (! node_p) {
#line 216
          goto while_break___2;
        }
#line 217
        (*(d + node_p->pos)) ++;
#line 219
        node_p = node_p->next;
      }
      while_break___2: /* CIL Label */ ;
      }
    }
#line 222
    hv = (unsigned int )((*(seq + (i + 1)) << 5) + *(seq + (i + 2)));
#line 223
    if (*(hash + hv)) {
#line 224
      node_p = *(hash + hv);
      {
#line 225
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 225
        if (! node_p) {
#line 225
          goto while_break___3;
        }
#line 226
        (*(d + node_p->pos)) ++;
#line 227
        node_p = node_p->next;
      }
      while_break___3: /* CIL Label */ ;
      }
    }
#line 230
    d ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 234
  d -= seqlen - 2;
#line 236
  i = diagonals;
  {
#line 236
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 236
    tmp___1 = i;
#line 236
    i --;
#line 236
    if (! tmp___1) {
#line 236
      goto while_break___4;
    }
#line 238
    if (*(d + i) > mode) {
#line 239
      out += (float )*(d + i);
    }
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 242
  free((void *)d);
  }
#line 243
  return (out);
}
}
#line 248 "/home/june/repo/benchmarks/collector/temp/kalign-2.03+20110620/kalign2_distance_calculation.c"
struct alignment *protein_wu_sw(struct node **hash , struct alignment *aln , int a ,
                                int b ) 
{ 
  int *seq ;
  int len_a ;
  int len_b ;
  struct node *node_p ;
  int i ;
  int c ;
  unsigned int hv ;
  struct feature *n ;
  int *weight ;
  int *len ;
  int *added ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  int tmp___8 ;
  void *tmp___9 ;
  void *tmp___10 ;
  void *tmp___11 ;
  void *tmp___12 ;
  void *tmp___13 ;
  void *tmp___14 ;

  {
  {
#line 250
  seq = *(aln->s + b);
#line 251
  len_a = (int )*(aln->sl + b);
#line 252
  len_b = (int )*(aln->sl + a);
#line 253
  node_p = (struct node *)0;
#line 260
  n = (struct feature *)0;
#line 265
  weight = (int *)0;
#line 266
  len = (int *)0;
#line 267
  added = (int *)0;
#line 269
  tmp = malloc(sizeof(int *) * (unsigned long )((len_a + len_b) - 1));
#line 269
  weight = (int *)tmp;
#line 270
  tmp___0 = malloc(sizeof(int *) * (unsigned long )((len_a + len_b) - 1));
#line 270
  len = (int *)tmp___0;
#line 271
  tmp___1 = malloc(sizeof(int *) * (unsigned long )((len_a + len_b) - 1));
#line 271
  added = (int *)tmp___1;
#line 272
  i = 0;
  }
  {
#line 272
  while (1) {
    while_continue: /* CIL Label */ ;
#line 272
    if (! (i < (len_a + len_b) - 1)) {
#line 272
      goto while_break;
    }
#line 273
    *(weight + i) = 0;
#line 274
    *(len + i) = 0;
#line 275
    *(added + i) = 0;
#line 272
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 302
  c = 1;
#line 303
  i = len_a - 2;
  {
#line 303
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 303
    tmp___8 = i;
#line 303
    i --;
#line 303
    if (! tmp___8) {
#line 303
      goto while_break___0;
    }
#line 304
    hv = 0U;
    {
#line 304
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 304
      if (! (hv < (unsigned int )((len_a + len_b) - 1))) {
#line 304
        goto while_break___1;
      }
#line 305
      *(added + hv) = 0;
#line 304
      hv ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 308
    hv = (unsigned int )((*(seq + i) << 5) + *(seq + (i + 1)));
#line 310
    if (*(hash + hv)) {
#line 311
      node_p = *(hash + hv);
      {
#line 312
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 312
        if (! node_p) {
#line 312
          goto while_break___2;
        }
#line 313
        *(added + (node_p->pos + c)) = 1;
#line 314
        (*(weight + (node_p->pos + c))) ++;
#line 316
        node_p = node_p->next;
      }
      while_break___2: /* CIL Label */ ;
      }
    }
#line 321
    hv = (unsigned int )((*(seq + i) << 5) + *(seq + (i + 2)));
#line 323
    if (*(hash + hv)) {
#line 324
      node_p = *(hash + hv);
      {
#line 325
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 325
        if (! node_p) {
#line 325
          goto while_break___3;
        }
#line 326
        *(added + (node_p->pos + c)) = 1;
#line 327
        (*(weight + (node_p->pos + c))) ++;
#line 329
        node_p = node_p->next;
      }
      while_break___3: /* CIL Label */ ;
      }
    }
#line 332
    hv = (unsigned int )((*(seq + (i + 1)) << 5) + *(seq + (i + 2)));
#line 334
    if (*(hash + hv)) {
#line 335
      node_p = *(hash + hv);
      {
#line 336
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 336
        if (! node_p) {
#line 336
          goto while_break___4;
        }
#line 337
        *(added + (node_p->pos + c)) = 1;
#line 338
        (*(weight + (node_p->pos + c))) ++;
#line 340
        node_p = node_p->next;
      }
      while_break___4: /* CIL Label */ ;
      }
    }
#line 345
    hv = 0U;
    {
#line 345
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 345
      if (! (hv < (unsigned int )((len_a + len_b) - 1))) {
#line 345
        goto while_break___5;
      }
#line 346
      *(len + hv) += *(added + hv);
#line 347
      if (! *(added + hv)) {
#line 347
        if (*(len + hv)) {
#line 348
          if (*(len + hv) > 10) {
            {
#line 349
            tmp___2 = malloc(sizeof(struct feature ));
#line 349
            n = (struct feature *)tmp___2;
#line 350
            n->next = (struct feature *)0;
#line 351
            n->color = 0;
#line 352
            tmp___3 = malloc(sizeof(char ) * 8UL);
#line 352
            n->type = (char *)tmp___3;
#line 353
            *(n->type + 0) = (char )'w';
#line 354
            *(n->type + 1) = (char )'u';
#line 355
            *(n->type + 2) = (char )'m';
#line 356
            *(n->type + 3) = (char )'a';
#line 357
            *(n->type + 4) = (char )'n';
#line 358
            *(n->type + 5) = (char )'b';
#line 359
            *(n->type + 6) = (char )'e';
#line 360
            *(n->type + 7) = (char )'r';
#line 361
            *(n->type + 8) = (char)0;
#line 363
            n->start = i + 2;
#line 364
            n->end = (*(len + hv) + n->start) - 1;
#line 366
            tmp___4 = malloc(sizeof(char ) * 2UL);
#line 366
            n->note = (char *)tmp___4;
#line 367
            *(n->note + 0) = (char )'w';
#line 368
            *(n->note + 1) = (char)0;
            }
#line 383
            if (! *(aln->ft + b)) {
#line 384
              *(aln->ft + b) = n;
            } else {
#line 386
              n->next = *(aln->ft + b);
#line 387
              *(aln->ft + b) = n;
            }
            {
#line 397
            n = (struct feature *)0;
#line 398
            tmp___5 = malloc(sizeof(struct feature ));
#line 398
            n = (struct feature *)tmp___5;
#line 399
            n->next = (struct feature *)0;
#line 400
            n->color = 0;
#line 402
            tmp___6 = malloc(sizeof(char ) * 8UL);
#line 402
            n->type = (char *)tmp___6;
#line 403
            *(n->type + 0) = (char )'w';
#line 404
            *(n->type + 1) = (char )'u';
#line 405
            *(n->type + 2) = (char )'m';
#line 406
            *(n->type + 3) = (char )'a';
#line 407
            *(n->type + 4) = (char )'n';
#line 408
            *(n->type + 5) = (char )'b';
#line 409
            *(n->type + 6) = (char )'e';
#line 410
            *(n->type + 7) = (char )'r';
#line 411
            *(n->type + 8) = (char)0;
#line 414
            n->start = (int )(((hv - (unsigned int )len_a) + (unsigned int )i) + 3U);
#line 415
            n->end = (*(len + hv) + n->start) - 1;
#line 417
            tmp___7 = malloc(sizeof(char ) * 2UL);
#line 417
            n->note = (char *)tmp___7;
#line 418
            *(n->note + 0) = (char )'w';
#line 419
            *(n->note + 1) = (char)0;
            }
#line 432
            if (! *(aln->ft + a)) {
#line 433
              *(aln->ft + a) = n;
            } else {
#line 435
              n->next = *(aln->ft + a);
#line 436
              *(aln->ft + a) = n;
            }
#line 447
            n = (struct feature *)0;
          }
#line 451
          *(len + hv) = 0;
#line 452
          *(weight + hv) = 0;
        }
      }
#line 345
      hv ++;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 457
    c ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 459
  i ++;
#line 462
  hv = 0U;
  {
#line 462
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 462
    if (! (hv < (unsigned int )((len_a + len_b) - 1))) {
#line 462
      goto while_break___6;
    }
#line 463
    if (*(len + hv)) {
#line 464
      if (*(len + hv) > 10) {
        {
#line 465
        tmp___9 = malloc(sizeof(struct feature ));
#line 465
        n = (struct feature *)tmp___9;
#line 466
        n->next = (struct feature *)0;
#line 467
        n->color = 0;
#line 469
        tmp___10 = malloc(sizeof(char ) * 8UL);
#line 469
        n->type = (char *)tmp___10;
#line 470
        *(n->type + 0) = (char )'w';
#line 471
        *(n->type + 1) = (char )'u';
#line 472
        *(n->type + 2) = (char )'m';
#line 473
        *(n->type + 3) = (char )'a';
#line 474
        *(n->type + 4) = (char )'n';
#line 475
        *(n->type + 5) = (char )'b';
#line 476
        *(n->type + 6) = (char )'e';
#line 477
        *(n->type + 7) = (char )'r';
#line 478
        *(n->type + 8) = (char)0;
#line 480
        n->start = i + 1;
#line 481
        n->end = (*(len + hv) + n->start) - 1;
#line 493
        tmp___11 = malloc(sizeof(char ) * 2UL);
#line 493
        n->note = (char *)tmp___11;
#line 494
        *(n->note + 0) = (char )'w';
#line 495
        *(n->note + 1) = (char)0;
        }
#line 497
        if (! *(aln->ft + b)) {
#line 498
          *(aln->ft + b) = n;
        } else {
#line 500
          n->next = *(aln->ft + b);
#line 501
          *(aln->ft + b) = n;
        }
        {
#line 513
        n = (struct feature *)0;
#line 514
        tmp___12 = malloc(sizeof(struct feature ));
#line 514
        n = (struct feature *)tmp___12;
#line 515
        n->next = (struct feature *)0;
#line 516
        n->color = 0;
#line 518
        tmp___13 = malloc(sizeof(char ) * 8UL);
#line 518
        n->type = (char *)tmp___13;
#line 519
        *(n->type + 0) = (char )'w';
#line 520
        *(n->type + 1) = (char )'u';
#line 521
        *(n->type + 2) = (char )'m';
#line 522
        *(n->type + 3) = (char )'a';
#line 523
        *(n->type + 4) = (char )'n';
#line 524
        *(n->type + 5) = (char )'b';
#line 525
        *(n->type + 6) = (char )'e';
#line 526
        *(n->type + 7) = (char )'r';
#line 527
        *(n->type + 8) = (char)0;
#line 529
        n->start = (int )(((hv - (unsigned int )len_a) + (unsigned int )i) + 2U);
#line 530
        n->end = (*(len + hv) + n->start) - 1;
#line 532
        tmp___14 = malloc(sizeof(char ) * 2UL);
#line 532
        n->note = (char *)tmp___14;
#line 533
        *(n->note + 0) = (char )'w';
#line 534
        *(n->note + 1) = (char)0;
        }
#line 546
        if (! *(aln->ft + a)) {
#line 547
          *(aln->ft + a) = n;
        } else {
#line 549
          n->next = *(aln->ft + a);
#line 550
          *(aln->ft + a) = n;
        }
#line 561
        n = (struct feature *)0;
      }
#line 567
      *(len + hv) = 0;
#line 568
      *(weight + hv) = 0;
    }
#line 462
    hv ++;
  }
  while_break___6: /* CIL Label */ ;
  }
  {
#line 573
  free((void *)weight);
#line 574
  free((void *)len);
#line 575
  free((void *)added);
  }
#line 587
  return (aln);
}
}
#line 592 "/home/june/repo/benchmarks/collector/temp/kalign-2.03+20110620/kalign2_distance_calculation.c"
float protein_wu_distance_calculation3(struct node **hash , int *seq , int seqlen ,
                                       int diagonals , int mode ) 
{ 
  struct node *node_p ;
  int i ;
  int c ;
  unsigned int hv ;
  int dlen ;
  int *weight ;
  int *len ;
  int *added ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 594
  node_p = (struct node *)0;
#line 597
  dlen = 0;
#line 600
  weight = (int *)0;
#line 601
  len = (int *)0;
#line 602
  added = (int *)0;
#line 604
  tmp = malloc(sizeof(int *) * (unsigned long )diagonals);
#line 604
  weight = (int *)tmp;
#line 605
  tmp___0 = malloc(sizeof(int *) * (unsigned long )diagonals);
#line 605
  len = (int *)tmp___0;
#line 606
  tmp___1 = malloc(sizeof(int *) * (unsigned long )diagonals);
#line 606
  added = (int *)tmp___1;
#line 607
  i = 0;
  }
  {
#line 607
  while (1) {
    while_continue: /* CIL Label */ ;
#line 607
    if (! (i < diagonals)) {
#line 607
      goto while_break;
    }
#line 608
    *(weight + i) = 0;
#line 609
    *(len + i) = 0;
#line 610
    *(added + i) = 0;
#line 607
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 613
  c = 1;
#line 614
  i = seqlen - 2;
  {
#line 614
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 614
    tmp___2 = i;
#line 614
    i --;
#line 614
    if (! tmp___2) {
#line 614
      goto while_break___0;
    }
#line 615
    hv = 0U;
    {
#line 615
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 615
      if (! (hv < (unsigned int )diagonals)) {
#line 615
        goto while_break___1;
      }
#line 616
      *(added + hv) = 0;
#line 615
      hv ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 619
    hv = (unsigned int )((*(seq + i) << 5) + *(seq + (i + 1)));
#line 621
    if (*(hash + hv)) {
#line 622
      node_p = *(hash + hv);
      {
#line 623
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 623
        if (! node_p) {
#line 623
          goto while_break___2;
        }
#line 624
        *(added + (node_p->pos + c)) = 1;
#line 625
        (*(weight + (node_p->pos + c))) ++;
#line 627
        node_p = node_p->next;
      }
      while_break___2: /* CIL Label */ ;
      }
    }
#line 632
    hv = (unsigned int )((*(seq + i) << 5) + *(seq + (i + 2)));
#line 634
    if (*(hash + hv)) {
#line 635
      node_p = *(hash + hv);
      {
#line 636
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 636
        if (! node_p) {
#line 636
          goto while_break___3;
        }
#line 637
        *(added + (node_p->pos + c)) = 1;
#line 638
        (*(weight + (node_p->pos + c))) ++;
#line 640
        node_p = node_p->next;
      }
      while_break___3: /* CIL Label */ ;
      }
    }
#line 643
    hv = (unsigned int )((*(seq + (i + 1)) << 5) + *(seq + (i + 2)));
#line 645
    if (*(hash + hv)) {
#line 646
      node_p = *(hash + hv);
      {
#line 647
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 647
        if (! node_p) {
#line 647
          goto while_break___4;
        }
#line 648
        *(added + (node_p->pos + c)) = 1;
#line 649
        (*(weight + (node_p->pos + c))) ++;
#line 651
        node_p = node_p->next;
      }
      while_break___4: /* CIL Label */ ;
      }
    }
#line 656
    hv = 0U;
    {
#line 656
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 656
      if (! (hv < (unsigned int )diagonals)) {
#line 656
        goto while_break___5;
      }
#line 657
      *(len + hv) += *(added + hv);
#line 658
      if (! *(added + hv)) {
#line 658
        if (*(len + hv)) {
#line 659
          if (*(len + hv) > dlen) {
#line 660
            dlen = *(len + hv);
          }
#line 662
          *(len + hv) = 0;
#line 663
          *(weight + hv) = 0;
        }
      }
#line 656
      hv ++;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 668
    c ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 670
  i ++;
#line 673
  hv = 0U;
  {
#line 673
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 673
    if (! (hv < (unsigned int )diagonals)) {
#line 673
      goto while_break___6;
    }
#line 674
    if (*(len + hv)) {
#line 675
      if (*(len + hv) > dlen) {
#line 676
        dlen = *(len + hv);
      }
#line 678
      *(len + hv) = 0;
#line 679
      *(weight + hv) = 0;
    }
#line 673
    hv ++;
  }
  while_break___6: /* CIL Label */ ;
  }
  {
#line 683
  free((void *)weight);
#line 684
  free((void *)len);
#line 685
  free((void *)added);
  }
#line 686
  return ((float )dlen);
}
}
#line 689 "/home/june/repo/benchmarks/collector/temp/kalign-2.03+20110620/kalign2_distance_calculation.c"
float **protein_wu_distance(struct alignment *si , float **dm , struct parameters *param ,
                            int nj___0 ) 
{ 
  struct bignode *hash[1024] ;
  int *p ;
  int i ;
  int j ;
  int a ;
  int b ;
  unsigned int hv ;
  float min ;
  float cutoff ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;

  {
#line 692
  p = (int *)0;
#line 698
  i = 0;
  {
#line 698
  while (1) {
    while_continue: /* CIL Label */ ;
#line 698
    if (! (i < 1024)) {
#line 698
      goto while_break;
    }
#line 699
    hash[i] = (struct bignode *)0;
#line 698
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 702
  if (nj___0) {
    {
#line 703
    tmp = malloc(sizeof(float *) * (unsigned long )numprofiles);
#line 703
    dm = (float **)tmp;
#line 704
    i = (int )numprofiles;
    }
    {
#line 704
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 704
      tmp___2 = i;
#line 704
      i --;
#line 704
      if (! tmp___2) {
#line 704
        goto while_break___0;
      }
      {
#line 705
      tmp___0 = malloc(sizeof(float ) * (unsigned long )numprofiles);
#line 705
      *(dm + i) = (float *)tmp___0;
#line 706
      j = (int )numprofiles;
      }
      {
#line 706
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 706
        tmp___1 = j;
#line 706
        j --;
#line 706
        if (! tmp___1) {
#line 706
          goto while_break___1;
        }
#line 707
        *(*(dm + i) + j) = 0.0f;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  } else {
    {
#line 711
    tmp___3 = malloc(sizeof(float *) * (unsigned long )numseq);
#line 711
    dm = (float **)tmp___3;
#line 712
    i = (int )numseq;
    }
    {
#line 712
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 712
      tmp___6 = i;
#line 712
      i --;
#line 712
      if (! tmp___6) {
#line 712
        goto while_break___2;
      }
      {
#line 713
      tmp___4 = malloc(sizeof(float ) * (unsigned long )numseq);
#line 713
      *(dm + i) = (float *)tmp___4;
#line 714
      j = (int )numseq;
      }
      {
#line 714
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 714
        tmp___5 = j;
#line 714
        j --;
#line 714
        if (! tmp___5) {
#line 714
          goto while_break___3;
        }
#line 715
        *(*(dm + i) + j) = 0.0f;
      }
      while_break___3: /* CIL Label */ ;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
  }
  {
#line 719
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Distance Calculation:\n");
#line 720
  b = (int )((numseq * (numseq - 1U)) / 2U);
#line 721
  a = 1;
#line 723
  i = 0;
  }
  {
#line 723
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 723
    if (! ((unsigned int )i < numseq - 1U)) {
#line 723
      goto while_break___4;
    }
#line 724
    p = *(si->s + i);
#line 726
    j = (int )(*(si->sl + i) - 2U);
    {
#line 726
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 726
      tmp___7 = j;
#line 726
      j --;
#line 726
      if (! tmp___7) {
#line 726
        goto while_break___5;
      }
      {
#line 730
      hv = (unsigned int )((*(p + j) << 5) + *(p + (j + 1)));
#line 731
      hash[hv] = big_insert_hash(hash[hv], (unsigned int const   )j);
#line 732
      hv = (unsigned int )((*(p + j) << 5) + *(p + (j + 2)));
#line 733
      hash[hv] = big_insert_hash(hash[hv], (unsigned int const   )j);
      }
    }
    while_break___5: /* CIL Label */ ;
    }
#line 735
    j = i + 1;
    {
#line 735
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 735
      if (! ((unsigned int )j < numseq)) {
#line 735
        goto while_break___6;
      }
#line 736
      if (*(si->sl + i) > *(si->sl + j)) {
#line 736
        min = (float )*(si->sl + j);
      } else {
#line 736
        min = (float )*(si->sl + i);
      }
      {
#line 737
      cutoff = param->internal_gap_weight * min + param->zlevel;
#line 739
      p = *(si->s + j);
#line 740
      *(*(dm + i) + j) = protein_wu_distance_calculation(hash, (int const   *)p, (int const   )*(si->sl + j),
                                                         (int const   )(*(si->sl + j) + *(si->sl + i)),
                                                         (float const   )cutoff);
#line 745
      *(*(dm + j) + i) = *(*(dm + i) + j);
#line 746
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\r%8.0f percent done",
              (double )(((float )a / (float )b) * (float )100));
#line 747
      a ++;
#line 735
      j ++;
      }
    }
    while_break___6: /* CIL Label */ ;
    }
#line 751
    j = 1024;
    {
#line 751
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 751
      tmp___8 = j;
#line 751
      j --;
#line 751
      if (! tmp___8) {
#line 751
        goto while_break___7;
      }
#line 752
      if (hash[j]) {
        {
#line 753
        big_remove_nodes(hash[j]);
#line 754
        hash[j] = (struct bignode *)0;
        }
      }
    }
    while_break___7: /* CIL Label */ ;
    }
#line 723
    i ++;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 758
  return (dm);
}
}
#line 762 "/home/june/repo/benchmarks/collector/temp/kalign-2.03+20110620/kalign2_distance_calculation.c"
float protein_wu_distance_calculation(struct bignode **hash , int const   *seq , int const   seqlen ,
                                      int const   diagonals , float const   mode ) 
{ 
  struct bignode *node_p ;
  unsigned int *d ;
  unsigned int *tmp ;
  float out ;
  register int i ;
  register int j ;
  register int c ;
  register int num ;
  register unsigned int hv ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 766
  d = (unsigned int *)0;
#line 767
  tmp = (unsigned int *)0;
#line 768
  out = (float )0.0;
#line 774
  tmp___0 = malloc(sizeof(unsigned int ) * (unsigned long )diagonals);
#line 774
  d = (unsigned int *)tmp___0;
#line 776
  i = 0;
  }
  {
#line 776
  while (1) {
    while_continue: /* CIL Label */ ;
#line 776
    if (! (i < (int )diagonals)) {
#line 776
      goto while_break;
    }
#line 777
    *(d + i) = 0U;
#line 776
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 779
  i = (int )(seqlen - 2);
  {
#line 779
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 779
    tmp___1 = i;
#line 779
    i --;
#line 779
    if (! tmp___1) {
#line 779
      goto while_break___0;
    }
#line 791
    hv = (unsigned int )((*(seq + i) << 5) + *(seq + (i + 1)));
#line 793
    node_p = *(hash + hv);
    {
#line 794
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 794
      if (! node_p) {
#line 794
        goto while_break___1;
      }
#line 795
      tmp = node_p->pos;
#line 796
      num = (int )node_p->num;
#line 797
      j = 0;
      {
#line 797
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 797
        if (! (j < num)) {
#line 797
          goto while_break___2;
        }
#line 798
        c = (int )*(tmp + j);
#line 799
        (*(d + c)) ++;
#line 800
        c ++;
#line 801
        (*(d + c)) ++;
#line 797
        j ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 803
      node_p = node_p->next;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 805
    hv = (unsigned int )((*(seq + i) << 5) + *(seq + (i + 2)));
#line 807
    node_p = *(hash + hv);
    {
#line 809
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 809
      if (! node_p) {
#line 809
        goto while_break___3;
      }
#line 810
      tmp = node_p->pos;
#line 811
      num = (int )node_p->num;
#line 812
      j = 0;
      {
#line 812
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 812
        if (! (j < num)) {
#line 812
          goto while_break___4;
        }
#line 813
        c = (int )*(tmp + j);
#line 814
        (*(d + c)) ++;
#line 812
        j ++;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 816
      node_p = node_p->next;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 818
    d ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 821
  d -= seqlen - 2;
#line 823
  i = (int )diagonals;
  {
#line 823
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 823
    tmp___2 = i;
#line 823
    i --;
#line 823
    if (! tmp___2) {
#line 823
      goto while_break___5;
    }
#line 827
    if ((float const   )*(d + i) > mode) {
#line 828
      out += (float )*(d + i);
    }
  }
  while_break___5: /* CIL Label */ ;
  }
  {
#line 832
  free((void *)d);
  }
#line 833
  return (out);
}
}
#line 836 "/home/june/repo/benchmarks/collector/temp/kalign-2.03+20110620/kalign2_distance_calculation.c"
float **dna_distance(struct alignment *si , float **dm , struct parameters *param ,
                     int nj___0 ) 
{ 
  struct bignode *hash[1024] ;
  int *p ;
  int i ;
  int j ;
  int a ;
  int b ;
  unsigned int hv ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  unsigned int tmp___8 ;
  int tmp___9 ;

  {
  {
#line 840
  p = (int *)0;
#line 845
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Distance Calculation:\n");
#line 848
  i = 0;
  }
  {
#line 848
  while (1) {
    while_continue: /* CIL Label */ ;
#line 848
    if (! (i < 1024)) {
#line 848
      goto while_break;
    }
#line 849
    hash[i] = (struct bignode *)0;
#line 848
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 852
  if (nj___0) {
    {
#line 853
    tmp = malloc(sizeof(float *) * (unsigned long )numprofiles);
#line 853
    dm = (float **)tmp;
#line 854
    i = (int )numprofiles;
    }
    {
#line 854
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 854
      tmp___2 = i;
#line 854
      i --;
#line 854
      if (! tmp___2) {
#line 854
        goto while_break___0;
      }
      {
#line 855
      tmp___0 = malloc(sizeof(float ) * (unsigned long )numprofiles);
#line 855
      *(dm + i) = (float *)tmp___0;
#line 856
      j = (int )numprofiles;
      }
      {
#line 856
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 856
        tmp___1 = j;
#line 856
        j --;
#line 856
        if (! tmp___1) {
#line 856
          goto while_break___1;
        }
#line 857
        *(*(dm + i) + j) = 0.0f;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  } else {
    {
#line 861
    tmp___3 = malloc(sizeof(float *) * (unsigned long )numseq);
#line 861
    dm = (float **)tmp___3;
#line 862
    i = (int )numseq;
    }
    {
#line 862
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 862
      tmp___6 = i;
#line 862
      i --;
#line 862
      if (! tmp___6) {
#line 862
        goto while_break___2;
      }
      {
#line 863
      tmp___4 = malloc(sizeof(float ) * (unsigned long )numseq);
#line 863
      *(dm + i) = (float *)tmp___4;
#line 864
      j = (int )numseq;
      }
      {
#line 864
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 864
        tmp___5 = j;
#line 864
        j --;
#line 864
        if (! tmp___5) {
#line 864
          goto while_break___3;
        }
#line 865
        *(*(dm + i) + j) = 0.0f;
      }
      while_break___3: /* CIL Label */ ;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
  }
#line 870
  b = (int )((numseq * (numseq - 1U)) / 2U);
#line 871
  a = 1;
#line 873
  i = 0;
  {
#line 873
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 873
    if (! ((unsigned int )i < numseq - 1U)) {
#line 873
      goto while_break___4;
    }
#line 874
    p = *(si->s + i);
#line 875
    j = (int )(*(si->sl + i) - 5U);
    {
#line 875
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 875
      tmp___7 = j;
#line 875
      j --;
#line 875
      if (! tmp___7) {
#line 875
        goto while_break___5;
      }
      {
#line 876
      hv = (unsigned int )((((((*(p + j) & 3) << 8) + ((*(p + (j + 1)) & 3) << 6)) + ((*(p + (j + 2)) & 3) << 4)) + ((*(p + (j + 3)) & 3) << 2)) + (*(p + (j + 4)) & 3));
#line 877
      hash[hv] = big_insert_hash(hash[hv], (unsigned int const   )j);
#line 878
      hv = (unsigned int )((((((*(p + j) & 3) << 8) + ((*(p + (j + 1)) & 3) << 6)) + ((*(p + (j + 2)) & 3) << 4)) + ((*(p + (j + 3)) & 3) << 2)) + (*(p + (j + 5)) & 3));
#line 879
      hash[hv] = big_insert_hash(hash[hv], (unsigned int const   )j);
#line 880
      hv = (unsigned int )((((((*(p + j) & 3) << 8) + ((*(p + (j + 1)) & 3) << 6)) + ((*(p + (j + 2)) & 3) << 4)) + ((*(p + (j + 4)) & 3) << 2)) + (*(p + (j + 5)) & 3));
#line 881
      hash[hv] = big_insert_hash(hash[hv], (unsigned int const   )j);
#line 882
      hv = (unsigned int )((((((*(p + j) & 3) << 8) + ((*(p + (j + 1)) & 3) << 6)) + ((*(p + (j + 3)) & 3) << 4)) + ((*(p + (j + 4)) & 3) << 2)) + (*(p + (j + 5)) & 3));
#line 883
      hash[hv] = big_insert_hash(hash[hv], (unsigned int const   )j);
#line 884
      hv = (unsigned int )((((((*(p + j) & 3) << 8) + ((*(p + (j + 2)) & 3) << 6)) + ((*(p + (j + 3)) & 3) << 4)) + ((*(p + (j + 4)) & 3) << 2)) + (*(p + (j + 5)) & 3));
#line 885
      hash[hv] = big_insert_hash(hash[hv], (unsigned int const   )j);
      }
    }
    while_break___5: /* CIL Label */ ;
    }
#line 887
    j = i + 1;
    {
#line 887
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 887
      if (! ((unsigned int )j < numseq)) {
#line 887
        goto while_break___6;
      }
      {
#line 891
      *(*(dm + i) + j) = dna_distance_calculation(hash, *(si->s + j), (int )*(si->sl + j),
                                                  (int )(*(si->sl + j) + *(si->sl + i)),
                                                  param->zlevel);
      }
#line 892
      if (*(si->sl + i) > *(si->sl + j)) {
#line 892
        tmp___8 = *(si->sl + j);
      } else {
#line 892
        tmp___8 = *(si->sl + i);
      }
      {
#line 892
      *(*(dm + i) + j) /= (float )tmp___8;
#line 893
      *(*(dm + j) + i) = *(*(dm + i) + j);
#line 894
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\r%8.0f percent done",
              (double )(((float )a / (float )b) * (float )100));
#line 895
      a ++;
#line 887
      j ++;
      }
    }
    while_break___6: /* CIL Label */ ;
    }
#line 898
    j = 1024;
    {
#line 898
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 898
      tmp___9 = j;
#line 898
      j --;
#line 898
      if (! tmp___9) {
#line 898
        goto while_break___7;
      }
#line 899
      if (hash[j]) {
        {
#line 900
        big_remove_nodes(hash[j]);
#line 901
        hash[j] = (struct bignode *)0;
        }
      }
    }
    while_break___7: /* CIL Label */ ;
    }
#line 873
    i ++;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 905
  return (dm);
}
}
#line 908 "/home/june/repo/benchmarks/collector/temp/kalign-2.03+20110620/kalign2_distance_calculation.c"
float dna_distance_calculation(struct bignode **hash , int *p , int seqlen , int diagonals ,
                               float mode ) 
{ 
  struct bignode *node_p ;
  float out ;
  unsigned int *tmp ;
  unsigned int *d ;
  int i ;
  int j ;
  unsigned int hv ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 912
  out = (float )0.0;
#line 913
  tmp = (unsigned int *)0;
#line 914
  d = (unsigned int *)0;
#line 918
  tmp___0 = malloc(sizeof(int ) * (unsigned long )diagonals);
#line 918
  d = (unsigned int *)tmp___0;
#line 919
  i = 0;
  }
  {
#line 919
  while (1) {
    while_continue: /* CIL Label */ ;
#line 919
    if (! (i < diagonals)) {
#line 919
      goto while_break;
    }
#line 920
    *(d + i) = 0U;
#line 919
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 922
  i = seqlen - 5;
  {
#line 922
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 922
    tmp___1 = i;
#line 922
    i --;
#line 922
    if (! tmp___1) {
#line 922
      goto while_break___0;
    }
#line 924
    hv = (unsigned int )((((((*(p + i) & 3) << 8) + ((*(p + (i + 1)) & 3) << 6)) + ((*(p + (i + 2)) & 3) << 4)) + ((*(p + (i + 3)) & 3) << 2)) + (*(p + (i + 4)) & 3));
#line 925
    if (*(hash + hv)) {
#line 926
      node_p = *(hash + hv);
      {
#line 927
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 927
        if (! node_p) {
#line 927
          goto while_break___1;
        }
#line 928
        tmp = node_p->pos;
#line 929
        j = 0;
        {
#line 929
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 929
          if (! ((unsigned int )j < node_p->num)) {
#line 929
            goto while_break___2;
          }
#line 930
          (*(d + *(tmp + j))) ++;
#line 929
          j ++;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 932
        node_p = node_p->next;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
#line 937
    hv = (unsigned int )((((((*(p + i) & 3) << 8) + ((*(p + (i + 1)) & 3) << 6)) + ((*(p + (i + 2)) & 3) << 4)) + ((*(p + (i + 3)) & 3) << 2)) + (*(p + (i + 5)) & 3));
#line 938
    if (*(hash + hv)) {
#line 939
      node_p = *(hash + hv);
      {
#line 940
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 940
        if (! node_p) {
#line 940
          goto while_break___3;
        }
#line 941
        tmp = node_p->pos;
#line 942
        j = 0;
        {
#line 942
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 942
          if (! ((unsigned int )j < node_p->num)) {
#line 942
            goto while_break___4;
          }
#line 943
          (*(d + *(tmp + j))) ++;
#line 942
          j ++;
        }
        while_break___4: /* CIL Label */ ;
        }
#line 945
        node_p = node_p->next;
      }
      while_break___3: /* CIL Label */ ;
      }
    }
#line 948
    hv = (unsigned int )((((((*(p + i) & 3) << 8) + ((*(p + (i + 1)) & 3) << 6)) + ((*(p + (i + 2)) & 3) << 4)) + ((*(p + (i + 4)) & 3) << 2)) + (*(p + (i + 5)) & 3));
#line 949
    if (*(hash + hv)) {
#line 950
      node_p = *(hash + hv);
      {
#line 951
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 951
        if (! node_p) {
#line 951
          goto while_break___5;
        }
#line 952
        tmp = node_p->pos;
#line 953
        j = 0;
        {
#line 953
        while (1) {
          while_continue___6: /* CIL Label */ ;
#line 953
          if (! ((unsigned int )j < node_p->num)) {
#line 953
            goto while_break___6;
          }
#line 954
          (*(d + *(tmp + j))) ++;
#line 953
          j ++;
        }
        while_break___6: /* CIL Label */ ;
        }
#line 956
        node_p = node_p->next;
      }
      while_break___5: /* CIL Label */ ;
      }
    }
#line 959
    hv = (unsigned int )((((((*(p + i) & 3) << 8) + ((*(p + (i + 1)) & 3) << 6)) + ((*(p + (i + 3)) & 3) << 4)) + ((*(p + (i + 4)) & 3) << 2)) + (*(p + (i + 5)) & 3));
#line 960
    if (*(hash + hv)) {
#line 961
      node_p = *(hash + hv);
      {
#line 962
      while (1) {
        while_continue___7: /* CIL Label */ ;
#line 962
        if (! node_p) {
#line 962
          goto while_break___7;
        }
#line 963
        tmp = node_p->pos;
#line 964
        j = 0;
        {
#line 964
        while (1) {
          while_continue___8: /* CIL Label */ ;
#line 964
          if (! ((unsigned int )j < node_p->num)) {
#line 964
            goto while_break___8;
          }
#line 965
          (*(d + *(tmp + j))) ++;
#line 964
          j ++;
        }
        while_break___8: /* CIL Label */ ;
        }
#line 967
        node_p = node_p->next;
      }
      while_break___7: /* CIL Label */ ;
      }
    }
#line 970
    hv = (unsigned int )((((((*(p + i) & 3) << 8) + ((*(p + (i + 2)) & 3) << 6)) + ((*(p + (i + 3)) & 3) << 4)) + ((*(p + (i + 4)) & 3) << 2)) + (*(p + (i + 5)) & 3));
#line 971
    if (*(hash + hv)) {
#line 972
      node_p = *(hash + hv);
      {
#line 973
      while (1) {
        while_continue___9: /* CIL Label */ ;
#line 973
        if (! node_p) {
#line 973
          goto while_break___9;
        }
#line 974
        tmp = node_p->pos;
#line 975
        j = 0;
        {
#line 975
        while (1) {
          while_continue___10: /* CIL Label */ ;
#line 975
          if (! ((unsigned int )j < node_p->num)) {
#line 975
            goto while_break___10;
          }
#line 976
          (*(d + *(tmp + j))) ++;
#line 975
          j ++;
        }
        while_break___10: /* CIL Label */ ;
        }
#line 978
        node_p = node_p->next;
      }
      while_break___9: /* CIL Label */ ;
      }
    }
#line 982
    d ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 985
  d -= seqlen - 5;
#line 987
  i = diagonals;
  {
#line 987
  while (1) {
    while_continue___11: /* CIL Label */ ;
#line 987
    tmp___2 = i;
#line 987
    i --;
#line 987
    if (! tmp___2) {
#line 987
      goto while_break___11;
    }
#line 992
    if ((float )*(d + i) > mode) {
#line 994
      out += (float )*(d + i);
    }
  }
  while_break___11: /* CIL Label */ ;
  }
  {
#line 997
  free((void *)d);
  }
#line 998
  return (out);
}
}
