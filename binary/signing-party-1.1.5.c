/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 70 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __mode_t mode_t;
#line 60 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef unsigned long pthread_t;
#line 63 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union pthread_attr_t {
   char __size[56] ;
   long __align ;
};
#line 69 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union pthread_attr_t pthread_attr_t;
#line 75 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
struct __pthread_internal_list {
   struct __pthread_internal_list *__prev ;
   struct __pthread_internal_list *__next ;
};
#line 75 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef struct __pthread_internal_list __pthread_list_t;
#line 90 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
struct __pthread_mutex_s {
   int __lock ;
   unsigned int __count ;
   int __owner ;
   unsigned int __nusers ;
   int __kind ;
   short __spins ;
   short __elision ;
   __pthread_list_t __list ;
};
#line 90 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_pthread_mutex_t_15 {
   struct __pthread_mutex_s __data ;
   char __size[40] ;
   long __align ;
};
#line 90 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_pthread_mutex_t_15 pthread_mutex_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_pthread_mutexattr_t_16 {
   char __size[4] ;
   int __align ;
};
#line 129 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_pthread_mutexattr_t_16 pthread_mutexattr_t;
#line 32 "/home/june/repo/benchmarks/collector/temp/signing-party-1.1.5/keyanalyze/keyanalyze.c"
struct sig {
   int id ;
   struct sig *next ;
};
#line 36 "/home/june/repo/benchmarks/collector/temp/signing-party-1.1.5/keyanalyze/keyanalyze.c"
typedef struct sig sig;
#line 38 "/home/june/repo/benchmarks/collector/temp/signing-party-1.1.5/keyanalyze/keyanalyze.c"
struct threadparam {
   int threadnum ;
};
#line 41 "/home/june/repo/benchmarks/collector/temp/signing-party-1.1.5/keyanalyze/keyanalyze.c"
typedef struct threadparam threadparam;
#line 43 "/home/june/repo/benchmarks/collector/temp/signing-party-1.1.5/keyanalyze/keyanalyze.c"
struct keydata {
   unsigned int id1 ;
   unsigned int id2 ;
   sig *to ;
   sig *from ;
};
#line 22 "/home/june/repo/benchmarks/collector/temp/signing-party-1.1.5/keyanalyze/process_keys.c"
struct sig___0 {
   struct sig___0 *next ;
   char id[17] ;
};
#line 28 "/home/june/repo/benchmarks/collector/temp/signing-party-1.1.5/keyanalyze/process_keys.c"
struct uid {
   struct uid *next ;
   struct sig___0 *sigs ;
   unsigned int self : 1 ;
};
#line 35 "/home/june/repo/benchmarks/collector/temp/signing-party-1.1.5/keyanalyze/process_keys.c"
struct key {
   char id[17] ;
   struct uid *uids ;
   unsigned int rev : 1 ;
};
#line 124 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 126 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 127 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 130 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 158 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 315 "/usr/include/libio.h"
typedef struct _IO_FILE _IO_FILE;
#line 79 "/usr/include/stdio.h"
typedef __gnuc_va_list va_list;
#line 75 "/usr/include/time.h"
typedef __time_t time_t;
#line 43 "/home/june/repo/benchmarks/collector/temp/signing-party-1.1.5/keyanalyze/pgpring/pgplib.h"
struct pgp_signature {
   struct pgp_signature *next ;
   unsigned char sigtype ;
   unsigned long sid1 ;
   unsigned long sid2 ;
};
#line 43 "/home/june/repo/benchmarks/collector/temp/signing-party-1.1.5/keyanalyze/pgpring/pgplib.h"
typedef struct pgp_signature pgp_sig_t;
#line 52
struct pgp_uid;
#line 52 "/home/june/repo/benchmarks/collector/temp/signing-party-1.1.5/keyanalyze/pgpring/pgplib.h"
struct pgp_keyinfo {
   char *keyid ;
   struct pgp_uid *address ;
   int flags ;
   short keylen ;
   time_t gen_time ;
   int numalg ;
   char const   *algorithm ;
   struct pgp_keyinfo *parent ;
   struct pgp_signature *sigs ;
   struct pgp_keyinfo *next ;
};
#line 52 "/home/june/repo/benchmarks/collector/temp/signing-party-1.1.5/keyanalyze/pgpring/pgplib.h"
typedef struct pgp_keyinfo pgp_key_t;
#line 67 "/home/june/repo/benchmarks/collector/temp/signing-party-1.1.5/keyanalyze/pgpring/pgplib.h"
struct pgp_uid {
   char *addr ;
   short trust ;
   int flags ;
   struct pgp_keyinfo *parent ;
   struct pgp_uid *next ;
   struct pgp_signature *sigs ;
};
#line 67 "/home/june/repo/benchmarks/collector/temp/signing-party-1.1.5/keyanalyze/pgpring/pgplib.h"
typedef struct pgp_uid pgp_uid_t;
#line 133 "/usr/include/time.h"
struct tm {
   int tm_sec ;
   int tm_min ;
   int tm_hour ;
   int tm_mday ;
   int tm_mon ;
   int tm_year ;
   int tm_wday ;
   int tm_yday ;
   int tm_isdst ;
   long tm_gmtoff ;
   char const   *tm_zone ;
};
#line 51 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 31 "/home/june/repo/benchmarks/collector/temp/signing-party-1.1.5/keyanalyze/pgpring/sha1.h"
struct __anonstruct_SHA1_CTX_29 {
   uint32_t state[5] ;
   uint32_t count[2] ;
   unsigned char buffer[64] ;
};
#line 31 "/home/june/repo/benchmarks/collector/temp/signing-party-1.1.5/keyanalyze/pgpring/sha1.h"
typedef struct __anonstruct_SHA1_CTX_29 SHA1_CTX;
#line 51 "/home/june/repo/benchmarks/collector/temp/signing-party-1.1.5/keyanalyze/pgpring/sha1.c"
union __anonunion_CHAR64LONG16_16 {
   unsigned char c[64] ;
   uint32_t l[16] ;
};
#line 51 "/home/june/repo/benchmarks/collector/temp/signing-party-1.1.5/keyanalyze/pgpring/sha1.c"
typedef union __anonunion_CHAR64LONG16_16 CHAR64LONG16;
#line 133 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 102 "/usr/include/stdio.h"
typedef __ssize_t ssize_t;
#line 66 "/usr/include/x86_64-linux-gnu/bits/waitstatus.h"
struct __anonstruct___wait_terminated_7 {
   unsigned int __w_termsig : 7 ;
   unsigned int __w_coredump : 1 ;
   unsigned int __w_retcode : 8 ;
   unsigned int  : 16 ;
};
#line 66 "/usr/include/x86_64-linux-gnu/bits/waitstatus.h"
struct __anonstruct___wait_stopped_8 {
   unsigned int __w_stopval : 8 ;
   unsigned int __w_stopsig : 8 ;
   unsigned int  : 16 ;
};
#line 66 "/usr/include/x86_64-linux-gnu/bits/waitstatus.h"
union wait {
   int w_status ;
   struct __anonstruct___wait_terminated_7 __wait_terminated ;
   struct __anonstruct___wait_stopped_8 __wait_stopped ;
};
#line 85 "/usr/include/signal.h"
typedef void (*__sighandler_t)(int  );
#line 23 "/usr/include/x86_64-linux-gnu/bits/termios.h"
typedef unsigned char cc_t;
#line 24 "/usr/include/x86_64-linux-gnu/bits/termios.h"
typedef unsigned int speed_t;
#line 25 "/usr/include/x86_64-linux-gnu/bits/termios.h"
typedef unsigned int tcflag_t;
#line 28 "/usr/include/x86_64-linux-gnu/bits/termios.h"
struct termios {
   tcflag_t c_iflag ;
   tcflag_t c_oflag ;
   tcflag_t c_cflag ;
   tcflag_t c_lflag ;
   cc_t c_line ;
   cc_t c_cc[32] ;
   speed_t c_ispeed ;
   speed_t c_ospeed ;
};
#line 416 "/home/june/repo/benchmarks/collector/temp/signing-party-1.1.5/gpgwrap/src/gpgwrap.c"
union __anonunion_52 {
   int __in ;
   int __i ;
};
#line 417 "/home/june/repo/benchmarks/collector/temp/signing-party-1.1.5/gpgwrap/src/gpgwrap.c"
union __anonunion_53 {
   int __in ;
   int __i ;
};
#line 14 "/home/june/repo/benchmarks/collector/temp/signing-party-1.1.5/keyanalyze/keyanalyze.c"
static char *infile  =    (char *)"preprocess.keys";
#line 15 "/home/june/repo/benchmarks/collector/temp/signing-party-1.1.5/keyanalyze/keyanalyze.c"
static char *outdir  =    (char *)"output/";
#line 16 "/home/june/repo/benchmarks/collector/temp/signing-party-1.1.5/keyanalyze/keyanalyze.c"
static int outsubdirs  =    1;
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 237
extern int fclose(FILE *__stream ) ;
#line 242
extern int fflush(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 362
extern int printf(char const   * __restrict  __format  , ...) ;
#line 364
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 709
extern size_t fread(void * __restrict  __ptr , size_t __size , size_t __n , FILE * __restrict  __stream ) ;
#line 759
extern void rewind(FILE *__stream ) ;
#line 183 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1), __leaf__)) strtol)(char const   * __restrict  __nptr ,
                                                                                              char ** __restrict  __endptr ,
                                                                                              int __base ) ;
#line 466
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 468
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) calloc)(size_t __nmemb ,
                                                                               size_t __size )  __attribute__((__malloc__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 66
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 137
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcat)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 140
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncat)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 321 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) mkdir)(char const   *__path ,
                                                                                            __mode_t __mode ) ;
#line 57 "/usr/include/getopt.h"
extern char *optarg ;
#line 71
extern int optind ;
#line 150
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getopt)(int ___argc ,
                                                                             char * const  *___argv ,
                                                                             char const   *__shortopts ) ;
#line 244 "/usr/include/pthread.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,3))) pthread_create)(pthread_t * __restrict  __newthread ,
                                                                                             pthread_attr_t const   * __restrict  __attr ,
                                                                                             void *(*__start_routine)(void * ) ,
                                                                                             void * __restrict  __arg ) ;
#line 261
extern int pthread_join(pthread_t __th , void **__thread_return ) ;
#line 760
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) pthread_mutex_init)(pthread_mutex_t *__mutex ,
                                                                                                         pthread_mutexattr_t const   *__mutexattr ) ;
#line 773
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_mutex_lock)(pthread_mutex_t *__mutex ) ;
#line 784
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_mutex_unlock)(pthread_mutex_t *__mutex ) ;
#line 50 "/home/june/repo/benchmarks/collector/temp/signing-party-1.1.5/keyanalyze/keyanalyze.c"
struct keydata keys[160000]  ;
#line 51 "/home/june/repo/benchmarks/collector/temp/signing-party-1.1.5/keyanalyze/keyanalyze.c"
FILE *fpin  ;
#line 51 "/home/june/repo/benchmarks/collector/temp/signing-party-1.1.5/keyanalyze/keyanalyze.c"
FILE *fpout  ;
#line 51 "/home/june/repo/benchmarks/collector/temp/signing-party-1.1.5/keyanalyze/keyanalyze.c"
FILE *fpstat  ;
#line 51 "/home/june/repo/benchmarks/collector/temp/signing-party-1.1.5/keyanalyze/keyanalyze.c"
FILE *fpsets  ;
#line 51 "/home/june/repo/benchmarks/collector/temp/signing-party-1.1.5/keyanalyze/keyanalyze.c"
FILE *fpmsd  ;
#line 52 "/home/june/repo/benchmarks/collector/temp/signing-party-1.1.5/keyanalyze/keyanalyze.c"
int numkeys  =    0;
#line 53 "/home/june/repo/benchmarks/collector/temp/signing-party-1.1.5/keyanalyze/keyanalyze.c"
int numsigs  =    0;
#line 54 "/home/june/repo/benchmarks/collector/temp/signing-party-1.1.5/keyanalyze/keyanalyze.c"
int component[160000]  ;
#line 55 "/home/june/repo/benchmarks/collector/temp/signing-party-1.1.5/keyanalyze/keyanalyze.c"
int max_component  ;
#line 56 "/home/june/repo/benchmarks/collector/temp/signing-party-1.1.5/keyanalyze/keyanalyze.c"
int max_size  ;
#line 57 "/home/june/repo/benchmarks/collector/temp/signing-party-1.1.5/keyanalyze/keyanalyze.c"
int reachable[160000]  ;
#line 58 "/home/june/repo/benchmarks/collector/temp/signing-party-1.1.5/keyanalyze/keyanalyze.c"
int num_reachable  ;
#line 59 "/home/june/repo/benchmarks/collector/temp/signing-party-1.1.5/keyanalyze/keyanalyze.c"
float meantotal  ;
#line 60 "/home/june/repo/benchmarks/collector/temp/signing-party-1.1.5/keyanalyze/keyanalyze.c"
pthread_mutex_t mean_l  ;
#line 63
void AddKey(unsigned char *newid ) ;
#line 64
void AddSig(int src , int dst ) ;
#line 65
void CloseFiles(void) ;
#line 66
int CountSigs(sig *current ) ;
#line 67
unsigned int ConvertFromHex(unsigned char const   *c ) ;
#line 68
int GetKeyById(unsigned char const   *searchid ) ;
#line 69
void MeanCrawler(int *distset , int id , int len ) ;
#line 70
float MeanDistance(int id , int *hops , int *hophigh , sig **farthest ) ;
#line 75 "/home/june/repo/benchmarks/collector/temp/signing-party-1.1.5/keyanalyze/keyanalyze.c"
void AddKey(unsigned char *newid ) 
{ 
  struct keydata *key ;
  int tmp ;

  {
  {
#line 76
  tmp = numkeys;
#line 76
  numkeys ++;
#line 76
  key = & keys[tmp];
#line 79
  key->id1 = ConvertFromHex((unsigned char const   *)newid);
#line 80
  key->id2 = ConvertFromHex((unsigned char const   *)(newid + 8));
  }
#line 81
  return;
}
}
#line 83 "/home/june/repo/benchmarks/collector/temp/signing-party-1.1.5/keyanalyze/keyanalyze.c"
void AddKeyToList(sig **pptr , int id ) 
{ 
  void *tmp ;

  {
  {
#line 85
  while (1) {
    while_continue: /* CIL Label */ ;
#line 85
    if (! *pptr) {
#line 85
      goto while_break;
    }
#line 86
    pptr = & (*pptr)->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 88
  tmp = calloc((size_t )1, sizeof(sig ));
#line 88
  *pptr = (sig *)tmp;
#line 89
  (*pptr)->id = id;
  }
#line 90
  return;
}
}
#line 92 "/home/june/repo/benchmarks/collector/temp/signing-party-1.1.5/keyanalyze/keyanalyze.c"
void AddSig(int src , int dst ) 
{ 


  {
#line 94
  if (src == -1) {
#line 95
    return;
  } else
#line 94
  if (dst == -1) {
#line 95
    return;
  }
  {
#line 97
  AddKeyToList(& keys[dst].to, src);
#line 98
  AddKeyToList(& keys[src].from, dst);
#line 100
  numsigs ++;
  }
#line 101
  return;
}
}
#line 103 "/home/june/repo/benchmarks/collector/temp/signing-party-1.1.5/keyanalyze/keyanalyze.c"
void CloseFiles(void) 
{ 


  {
  {
#line 104
  fclose(fpin);
#line 105
  fclose(fpout);
  }
#line 106
  return;
}
}
#line 108 "/home/june/repo/benchmarks/collector/temp/signing-party-1.1.5/keyanalyze/keyanalyze.c"
int CountSigs(sig *current ) 
{ 
  int ret ;

  {
#line 109
  ret = 0;
  {
#line 111
  while (1) {
    while_continue: /* CIL Label */ ;
#line 111
    if (! current->next) {
#line 111
      goto while_break;
    }
#line 112
    current = current->next;
#line 113
    ret ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 116
  return (ret);
}
}
#line 119 "/home/june/repo/benchmarks/collector/temp/signing-party-1.1.5/keyanalyze/keyanalyze.c"
unsigned int ConvertFromHex(unsigned char const   *c ) 
{ 
  unsigned char buf1[5] ;
  unsigned char buf2[5] ;
  unsigned int ret ;
  long tmp ;
  long tmp___0 ;

  {
  {
#line 124
  buf1[4] = (unsigned char)0;
#line 125
  buf2[4] = (unsigned char)0;
#line 126
  memcpy((void */* __restrict  */)(buf1), (void const   */* __restrict  */)c, (size_t )4);
#line 127
  memcpy((void */* __restrict  */)(buf2), (void const   */* __restrict  */)(c + 4),
         (size_t )4);
#line 128
  tmp = strtol((char const   */* __restrict  */)(buf1), (char **/* __restrict  */)((void *)0),
               16);
#line 128
  tmp___0 = strtol((char const   */* __restrict  */)(buf2), (char **/* __restrict  */)((void *)0),
                   16);
#line 128
  ret = (unsigned int )(tmp * 65536L + tmp___0);
  }
#line 129
  return (ret);
}
}
#line 132 "/home/june/repo/benchmarks/collector/temp/signing-party-1.1.5/keyanalyze/keyanalyze.c"
void DeleteKeyList(sig **pptr ) 
{ 
  sig *current ;

  {
#line 134
  current = *pptr;
  {
#line 136
  while (1) {
    while_continue: /* CIL Label */ ;
#line 136
    if (! *pptr) {
#line 136
      goto while_break;
    }
    {
#line 137
    current = (*pptr)->next;
#line 138
    free((void *)*pptr);
#line 139
    *pptr = current;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 141
  return;
}
}
#line 144 "/home/june/repo/benchmarks/collector/temp/signing-party-1.1.5/keyanalyze/keyanalyze.c"
int DFSMarkConnected(int *markset , int id ) 
{ 
  sig *psig ;
  int num ;
  int tmp ;

  {
#line 146
  num = 1;
#line 149
  *(markset + id) = 1;
#line 150
  psig = keys[id].from;
  {
#line 150
  while (1) {
    while_continue: /* CIL Label */ ;
#line 150
    if (! psig) {
#line 150
      goto while_break;
    }
#line 151
    if (! *(markset + psig->id)) {
      {
#line 152
      tmp = DFSMarkConnected(markset, psig->id);
#line 152
      num += tmp;
      }
    }
#line 150
    psig = psig->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 155
  return (num);
}
}
#line 158 "/home/june/repo/benchmarks/collector/temp/signing-party-1.1.5/keyanalyze/keyanalyze.c"
int GetKeyById(unsigned char const   *searchid ) 
{ 
  int i ;
  unsigned int s1 ;
  unsigned int s2 ;
  struct keydata *key ;

  {
  {
#line 162
  s1 = ConvertFromHex(searchid);
#line 163
  s2 = ConvertFromHex(searchid + 8);
#line 164
  i = 0;
  }
  {
#line 164
  while (1) {
    while_continue: /* CIL Label */ ;
#line 164
    if (! (i < numkeys)) {
#line 164
      goto while_break;
    }
#line 165
    key = & keys[i];
#line 166
    if (s1 == key->id1) {
#line 166
      if (s2 == key->id2) {
#line 167
        return (i);
      }
    }
#line 164
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 170
  return (-1);
}
}
#line 175 "/home/june/repo/benchmarks/collector/temp/signing-party-1.1.5/keyanalyze/keyanalyze.c"
void MeanCrawler(int *distset , int id , int len ) 
{ 
  sig *psig ;
  int queue[160000] ;
  int qhead ;
  int qtail ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 180
  memset((void *)(queue), 0, sizeof(int ) * 160000UL);
#line 181
  queue[0] = id;
#line 182
  *(distset + id) = 0;
#line 183
  qhead = 0;
#line 184
  qtail = 1;
  }
  {
#line 186
  while (1) {
    while_continue: /* CIL Label */ ;
#line 186
    if (! (qtail > qhead)) {
#line 186
      goto while_break;
    }
#line 187
    tmp = qhead;
#line 187
    qhead ++;
#line 187
    id = queue[tmp];
#line 188
    len = *(distset + id);
#line 189
    psig = keys[id].to;
    {
#line 190
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 190
      if (! psig) {
#line 190
        goto while_break___0;
      }
#line 191
      if (len + 1 < *(distset + psig->id)) {
#line 192
        *(distset + psig->id) = len + 1;
#line 193
        tmp___0 = qtail;
#line 193
        qtail ++;
#line 193
        queue[tmp___0] = psig->id;
      }
#line 195
      psig = psig->next;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 198
  return;
}
}
#line 200 "/home/june/repo/benchmarks/collector/temp/signing-party-1.1.5/keyanalyze/keyanalyze.c"
float MeanDistance(int id , int *hops , int *hophigh , sig **farthest ) 
{ 
  int dist[160000] ;
  int i ;
  int totaldist ;

  {
  {
#line 203
  totaldist = 0;
#line 207
  memset((void *)(dist), 100, sizeof(int ) * 160000UL);
#line 209
  MeanCrawler(dist, id, 0);
#line 211
  i = 0;
  }
  {
#line 211
  while (1) {
    while_continue: /* CIL Label */ ;
#line 211
    if (! (i < numkeys)) {
#line 211
      goto while_break;
    }
#line 212
    if (component[i] == max_component) {
#line 213
      totaldist += dist[i];
#line 214
      if (dist[i] < 30) {
#line 214
        (*(hops + dist[i])) ++;
      }
#line 215
      if (dist[i] > *hophigh) {
        {
#line 216
        *hophigh = dist[i];
#line 217
        DeleteKeyList(farthest);
        }
      }
#line 219
      if (dist[i] == *hophigh) {
        {
#line 220
        AddKeyToList(farthest, i);
        }
      }
    }
#line 211
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 225
  if (*hophigh > 30) {
#line 225
    *hophigh = 30;
  }
#line 227
  return ((float )totaldist / (float )max_size);
}
}
#line 230 "/home/june/repo/benchmarks/collector/temp/signing-party-1.1.5/keyanalyze/keyanalyze.c"
FILE *OpenFileById(unsigned int id ) 
{ 
  char buf[255] ;
  char idchr[9] ;
  FILE *tmp ;

  {
  {
#line 234
  sprintf((char */* __restrict  */)(idchr), (char const   */* __restrict  */)"%08X",
          id);
#line 237
  buf[0] = (char )'\000';
#line 238
  strcat((char */* __restrict  */)(buf), (char const   */* __restrict  */)outdir);
  }
#line 239
  if (outsubdirs) {
    {
#line 240
    strncat((char */* __restrict  */)(buf), (char const   */* __restrict  */)(idchr),
            (size_t )2);
#line 241
    mkdir((char const   *)(buf), (mode_t )493);
#line 242
    strcat((char */* __restrict  */)(buf), (char const   */* __restrict  */)"/");
    }
  }
  {
#line 244
  strcat((char */* __restrict  */)(buf), (char const   */* __restrict  */)(idchr));
#line 245
  tmp = fopen((char const   */* __restrict  */)(buf), (char const   */* __restrict  */)"w");
  }
#line 245
  return (tmp);
}
}
#line 251 "/home/june/repo/benchmarks/collector/temp/signing-party-1.1.5/keyanalyze/keyanalyze.c"
int OpenFiles(void) 
{ 
  char buf[255] ;

  {
  {
#line 254
  fpin = fopen((char const   */* __restrict  */)infile, (char const   */* __restrict  */)"r");
  }
#line 255
  if (! fpin) {
#line 255
    return (1);
  }
  {
#line 258
  mkdir((char const   *)outdir, (mode_t )493);
#line 261
  buf[0] = (char )'\000';
#line 262
  strcat((char */* __restrict  */)(buf), (char const   */* __restrict  */)outdir);
#line 263
  strcat((char */* __restrict  */)(buf), (char const   */* __restrict  */)"status.txt");
#line 264
  fpstat = fopen((char const   */* __restrict  */)(buf), (char const   */* __restrict  */)"w");
  }
#line 265
  if (! fpstat) {
#line 265
    return (1);
  }
  {
#line 268
  buf[0] = (char )'\000';
#line 269
  strcat((char */* __restrict  */)(buf), (char const   */* __restrict  */)outdir);
#line 270
  strcat((char */* __restrict  */)(buf), (char const   */* __restrict  */)"msd.txt");
#line 271
  fpmsd = fopen((char const   */* __restrict  */)(buf), (char const   */* __restrict  */)"w");
  }
#line 272
  if (! fpmsd) {
#line 272
    return (1);
  }
  {
#line 275
  buf[0] = (char )'\000';
#line 276
  strcat((char */* __restrict  */)(buf), (char const   */* __restrict  */)outdir);
#line 277
  strcat((char */* __restrict  */)(buf), (char const   */* __restrict  */)"othersets.txt");
#line 278
  fpsets = fopen((char const   */* __restrict  */)(buf), (char const   */* __restrict  */)"w");
  }
#line 279
  if (! fpsets) {
#line 279
    return (1);
  }
  {
#line 282
  buf[0] = (char )'\000';
#line 283
  strcat((char */* __restrict  */)(buf), (char const   */* __restrict  */)outdir);
#line 284
  strcat((char */* __restrict  */)(buf), (char const   */* __restrict  */)"other.txt");
#line 285
  fpout = fopen((char const   */* __restrict  */)(buf), (char const   */* __restrict  */)"w");
  }
#line 286
  if (! fpout) {
#line 286
    return (1);
  }
#line 288
  return (0);
}
}
#line 291 "/home/june/repo/benchmarks/collector/temp/signing-party-1.1.5/keyanalyze/keyanalyze.c"
void ParseArgs(int argc , char **argv ) 
{ 
  int outdirlen ;
  int option ;
  int tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 295
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 296
    tmp = getopt(argc, (char * const  *)argv, "hi:o:1");
#line 296
    option = tmp;
    }
#line 297
    if (option == -1) {
#line 298
      goto while_break;
    }
    {
#line 300
    if (option == 104) {
#line 300
      goto case_104;
    }
#line 304
    if (option == 105) {
#line 304
      goto case_105;
    }
#line 307
    if (option == 111) {
#line 307
      goto case_111;
    }
#line 317
    if (option == 49) {
#line 317
      goto case_49;
    }
#line 299
    goto switch_break;
    case_104: /* CIL Label */ 
    {
#line 301
    printf((char const   */* __restrict  */)"Usage: %s [-h1] [-i infile] [-o outdir]\n",
           *(argv + 0));
#line 302
    exit(0);
    }
#line 303
    goto switch_break;
    case_105: /* CIL Label */ 
#line 305
    infile = optarg;
#line 306
    goto switch_break;
    case_111: /* CIL Label */ 
    {
#line 308
    outdir = optarg;
#line 309
    tmp___0 = strlen((char const   *)outdir);
#line 309
    outdirlen = (int )tmp___0;
    }
#line 310
    if ((int )*(outdir + (outdirlen - 1)) != 47) {
      {
#line 311
      tmp___1 = malloc((size_t )(outdirlen + 2));
#line 311
      outdir = (char *)tmp___1;
#line 312
      memcpy((void */* __restrict  */)outdir, (void const   */* __restrict  */)optarg,
             (size_t )outdirlen);
#line 313
      *(outdir + outdirlen) = (char )'/';
#line 314
      *(outdir + (outdirlen + 1)) = (char )'\000';
      }
    }
#line 316
    goto switch_break;
    case_49: /* CIL Label */ 
#line 318
    outsubdirs = 0;
#line 319
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 323
  if (optind < argc) {
#line 325
    infile = *(argv + optind);
  }
#line 327
  return;
}
}
#line 329 "/home/june/repo/benchmarks/collector/temp/signing-party-1.1.5/keyanalyze/keyanalyze.c"
int PrintKeyList(FILE *f , sig *s ) 
{ 
  int i ;
  struct keydata *key ;

  {
#line 331
  i = 0;
  {
#line 332
  while (1) {
    while_continue: /* CIL Label */ ;
#line 332
    if (! s) {
#line 332
      goto while_break;
    }
    {
#line 333
    key = & keys[s->id];
#line 334
    fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"  %08X %08X\n",
            key->id1, key->id2);
#line 335
    s = s->next;
#line 336
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 338
  return (i);
}
}
#line 341 "/home/june/repo/benchmarks/collector/temp/signing-party-1.1.5/keyanalyze/keyanalyze.c"
void ReadInput(void) 
{ 
  unsigned char buf[20] ;
  int currentkey ;
  size_t tmp ;
  int tmp___0 ;
  size_t tmp___1 ;

  {
  {
#line 343
  currentkey = -1;
#line 345
  fprintf((FILE */* __restrict  */)fpstat, (char const   */* __restrict  */)"Importing pass 1 (keys)...\n");
  }
  {
#line 346
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 346
    tmp = fread((void */* __restrict  */)(buf), (size_t )1, (size_t )18, (FILE */* __restrict  */)fpin);
    }
#line 346
    if (! (tmp == 18UL)) {
#line 346
      goto while_break;
    }
#line 347
    if ((int )buf[17] != 10) {
#line 347
      goto while_continue;
    }
#line 348
    if ((int )buf[0] == 112) {
      {
#line 349
      AddKey(buf + 1);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 352
  fprintf((FILE */* __restrict  */)fpstat, (char const   */* __restrict  */)"done.\n");
#line 353
  fprintf((FILE */* __restrict  */)fpstat, (char const   */* __restrict  */)"%d keys imported\n",
          numkeys);
#line 355
  rewind(fpin);
#line 356
  fprintf((FILE */* __restrict  */)fpstat, (char const   */* __restrict  */)"Importing pass 2 (sigs)...\n");
  }
  {
#line 357
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 357
    tmp___1 = fread((void */* __restrict  */)(buf), (size_t )1, (size_t )18, (FILE */* __restrict  */)fpin);
    }
#line 357
    if (! (tmp___1 == 18UL)) {
#line 357
      goto while_break___0;
    }
#line 358
    if ((int )buf[17] != 10) {
#line 358
      goto while_continue___0;
    }
#line 359
    if ((int )buf[0] == 112) {
      {
#line 360
      currentkey = GetKeyById((unsigned char const   *)(buf + 1));
      }
#line 361
      if (currentkey == -1) {
        {
#line 362
        fprintf((FILE */* __restrict  */)fpstat, (char const   */* __restrict  */)"Error finding key in pass 2.\n");
#line 363
        exit(1);
        }
      }
    }
#line 366
    if ((int )buf[0] == 115) {
      {
#line 367
      tmp___0 = GetKeyById((unsigned char const   *)(buf + 1));
#line 367
      AddSig(tmp___0, currentkey);
      }
#line 368
      if (numsigs % 1000 == 0) {
        {
#line 369
        fprintf((FILE */* __restrict  */)fpstat, (char const   */* __restrict  */)"%d sigs imported...\n",
                numsigs);
#line 370
        fflush(fpstat);
        }
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 374
  fprintf((FILE */* __restrict  */)fpstat, (char const   */* __restrict  */)"done.\n");
#line 375
  fprintf((FILE */* __restrict  */)fpstat, (char const   */* __restrict  */)"%d sigs imported\n",
          numsigs);
  }
#line 376
  return;
}
}
#line 382 "/home/june/repo/benchmarks/collector/temp/signing-party-1.1.5/keyanalyze/keyanalyze.c"
void SaveState(void) 
{ 


  {
#line 385
  return;
}
}
#line 387 "/home/june/repo/benchmarks/collector/temp/signing-party-1.1.5/keyanalyze/keyanalyze.c"
int dfsnum[160000]  ;
#line 388 "/home/june/repo/benchmarks/collector/temp/signing-party-1.1.5/keyanalyze/keyanalyze.c"
int lownum[160000]  ;
#line 389 "/home/june/repo/benchmarks/collector/temp/signing-party-1.1.5/keyanalyze/keyanalyze.c"
int removed[160000]  ;
#line 390 "/home/june/repo/benchmarks/collector/temp/signing-party-1.1.5/keyanalyze/keyanalyze.c"
int stack[160000]  ;
#line 391 "/home/june/repo/benchmarks/collector/temp/signing-party-1.1.5/keyanalyze/keyanalyze.c"
int stackindex  ;
#line 392 "/home/june/repo/benchmarks/collector/temp/signing-party-1.1.5/keyanalyze/keyanalyze.c"
int lastdfsnum  ;
#line 394 "/home/june/repo/benchmarks/collector/temp/signing-party-1.1.5/keyanalyze/keyanalyze.c"
void DFSVisit(int id ) 
{ 
  sig *psig ;
  int tmp ;
  int tmp___0 ;
  int neighbor ;
  int i ;
  int size ;
  struct keydata *key ;

  {
#line 397
  lastdfsnum ++;
#line 397
  tmp = lastdfsnum;
#line 397
  lownum[id] = tmp;
#line 397
  dfsnum[id] = tmp;
#line 398
  tmp___0 = stackindex;
#line 398
  stackindex ++;
#line 398
  stack[tmp___0] = id;
#line 400
  psig = keys[id].to;
  {
#line 400
  while (1) {
    while_continue: /* CIL Label */ ;
#line 400
    if (! psig) {
#line 400
      goto while_break;
    }
#line 401
    neighbor = psig->id;
#line 403
    if (removed[neighbor]) {
#line 404
      goto __Cont;
    }
#line 406
    if (! dfsnum[neighbor]) {
      {
#line 407
      DFSVisit(neighbor);
      }
#line 409
      if (lownum[neighbor] < lownum[id]) {
#line 410
        lownum[id] = lownum[neighbor];
      }
    } else
#line 411
    if (dfsnum[neighbor] < lownum[id]) {
#line 412
      lownum[id] = dfsnum[neighbor];
    }
    __Cont: /* CIL Label */ 
#line 400
    psig = psig->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 415
  if (lownum[id] == dfsnum[id]) {
#line 416
    size = 0;
    {
#line 418
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 420
      stackindex --;
#line 420
      i = stack[stackindex];
#line 421
      key = & keys[i];
#line 422
      component[i] = id;
#line 423
      removed[i] = 1;
#line 424
      size ++;
#line 425
      fprintf((FILE */* __restrict  */)fpsets, (char const   */* __restrict  */)"%08X %08X\n",
              key->id1, key->id2);
      }
#line 418
      if (! (i != id)) {
#line 418
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 428
    fprintf((FILE */* __restrict  */)fpsets, (char const   */* __restrict  */)"*** %d keys in this strongly connected set\n\n",
            size);
    }
#line 431
    if (max_size < size) {
#line 432
      max_size = size;
#line 433
      max_component = id;
    }
  }
#line 436
  return;
}
}
#line 438 "/home/june/repo/benchmarks/collector/temp/signing-party-1.1.5/keyanalyze/keyanalyze.c"
void TestConnectivity(void) 
{ 
  int i ;

  {
#line 441
  i = 0;
  {
#line 441
  while (1) {
    while_continue: /* CIL Label */ ;
#line 441
    if (! (i < numkeys)) {
#line 441
      goto while_break;
    }
#line 442
    if (! dfsnum[i]) {
      {
#line 443
      DFSVisit(i);
      }
    }
#line 441
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 445
  num_reachable = DFSMarkConnected(reachable, max_component);
#line 447
  fprintf((FILE */* __restrict  */)fpstat, (char const   */* __restrict  */)"reachable set is size %d\n",
          num_reachable);
#line 448
  fprintf((FILE */* __restrict  */)fpstat, (char const   */* __restrict  */)"strongly connected set is size %d\n",
          max_size);
  }
#line 449
  return;
}
}
#line 454 "/home/june/repo/benchmarks/collector/temp/signing-party-1.1.5/keyanalyze/keyanalyze.c"
void IndivReport(FILE *fp , int key ) 
{ 
  int totalsigsto ;
  int totalsigsfrom ;

  {
  {
#line 458
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"KeyID %08X %08X\n\n",
          keys[key].id1, keys[key].id2);
#line 460
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"This individual key report was generated as part of the monthly keyanalyze\n");
#line 461
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"report at http://dtype.org/keyanalyze/.\n\n");
#line 463
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"Note: Key signature counts and lists are from a pruned list that only\n");
#line 464
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"includes keys with signatures other than their own.\n\n");
#line 466
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"Signatures to this key:\n");
#line 467
  totalsigsto = PrintKeyList(fp, keys[key].to);
#line 468
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"Total: %d signatures to this id from this set\n\n",
          totalsigsto);
#line 470
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"Signatures from this key:\n");
#line 471
  totalsigsfrom = PrintKeyList(fp, keys[key].from);
#line 472
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"Total: %d signatures from this id to this set\n\n",
          totalsigsfrom);
  }
#line 473
  return;
}
}
#line 478 "/home/june/repo/benchmarks/collector/temp/signing-party-1.1.5/keyanalyze/keyanalyze.c"
void *thread_slave(void *arg ) 
{ 
  int i ;
  int j ;
  float threadmean ;
  sig *distant_sigs ;
  FILE *fpindiv ;
  int hops[30] ;
  int hophigh ;
  threadparam data ;
  struct keydata *key ;
  char const   *tmp ;

  {
#line 481
  distant_sigs = (sig *)((void *)0);
#line 487
  data = *((threadparam *)arg);
#line 489
  i = 0;
  {
#line 489
  while (1) {
    while_continue: /* CIL Label */ ;
#line 489
    if (! (i < numkeys)) {
#line 489
      goto while_break;
    }
#line 490
    key = & keys[i];
#line 492
    if (reachable[i]) {
#line 492
      if (i % 2 == data.threadnum) {
        {
#line 494
        memset((void *)(hops), 0, sizeof(int ) * 30UL);
#line 495
        hophigh = 0;
#line 497
        threadmean = MeanDistance(i, hops, & hophigh, & distant_sigs);
#line 499
        pthread_mutex_lock(& mean_l);
#line 500
        meantotal += threadmean;
#line 501
        fprintf((FILE */* __restrict  */)fpmsd, (char const   */* __restrict  */)"%08X %08X %8.4f\n",
                key->id1, key->id2, (double )threadmean);
#line 503
        fflush(fpmsd);
#line 504
        pthread_mutex_unlock(& mean_l);
#line 507
        fpindiv = OpenFileById(key->id2);
#line 508
        IndivReport(fpindiv, i);
        }
#line 509
        if (component[i] == max_component) {
#line 509
          tmp = "";
        } else {
#line 509
          tmp = "not ";
        }
        {
#line 509
        fprintf((FILE */* __restrict  */)fpindiv, (char const   */* __restrict  */)"This key is %sin the strong set.\n",
                tmp);
#line 511
        fprintf((FILE */* __restrict  */)fpindiv, (char const   */* __restrict  */)"Mean distance to this key from strong set: %8.4f\n\n",
                (double )threadmean);
#line 512
        fprintf((FILE */* __restrict  */)fpindiv, (char const   */* __restrict  */)"Breakout by hop count (only from strong set):\n");
#line 513
        j = 0;
        }
        {
#line 513
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 513
          if (! (j <= hophigh)) {
#line 513
            goto while_break___0;
          }
          {
#line 514
          fprintf((FILE */* __restrict  */)fpindiv, (char const   */* __restrict  */)"%2d hops: %5d\n",
                  j, hops[j]);
#line 513
          j ++;
          }
        }
        while_break___0: /* CIL Label */ ;
        }
#line 516
        if (distant_sigs) {
          {
#line 517
          fprintf((FILE */* __restrict  */)fpindiv, (char const   */* __restrict  */)"\nFarthest keys (%d hops):\n",
                  j - 1);
#line 518
          PrintKeyList(fpindiv, distant_sigs);
#line 519
          DeleteKeyList(& distant_sigs);
          }
        }
        {
#line 521
        fclose(fpindiv);
        }
      }
    }
#line 489
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 524
  return ((void *)0);
}
}
#line 530 "/home/june/repo/benchmarks/collector/temp/signing-party-1.1.5/keyanalyze/keyanalyze.c"
int main(int argc , char **argv ) 
{ 
  pthread_t *slave0 ;
  pthread_t *slave1 ;
  threadparam arg0 ;
  threadparam arg1 ;
  void *retval ;
  int tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 536
  ParseArgs(argc, argv);
#line 537
  tmp = OpenFiles();
  }
#line 537
  if (tmp) {
    {
#line 538
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error opening files.\n");
#line 539
    exit(1);
    }
  }
  {
#line 541
  ReadInput();
#line 542
  TestConnectivity();
#line 544
  pthread_mutex_init(& mean_l, (pthread_mutexattr_t const   *)((void *)0));
#line 545
  tmp___0 = calloc((size_t )1, sizeof(pthread_t ));
#line 545
  slave0 = (pthread_t *)tmp___0;
#line 546
  tmp___1 = calloc((size_t )1, sizeof(pthread_t ));
#line 546
  slave1 = (pthread_t *)tmp___1;
#line 547
  arg0.threadnum = 0;
#line 548
  arg1.threadnum = 1;
#line 550
  tmp___2 = pthread_create((pthread_t */* __restrict  */)slave0, (pthread_attr_t const   */* __restrict  */)((void *)0),
                           & thread_slave, (void */* __restrict  */)(& arg0));
  }
#line 550
  if (tmp___2) {
    {
#line 551
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Cannot create thread 0.");
    }
  }
  {
#line 553
  tmp___3 = pthread_create((pthread_t */* __restrict  */)slave1, (pthread_attr_t const   */* __restrict  */)((void *)0),
                           & thread_slave, (void */* __restrict  */)(& arg1));
  }
#line 553
  if (tmp___3) {
    {
#line 554
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Cannot create thread 1.");
    }
  }
  {
#line 556
  pthread_join(*slave0, & retval);
#line 557
  pthread_join(*slave1, & retval);
#line 559
  fprintf((FILE */* __restrict  */)fpout, (char const   */* __restrict  */)"Average mean is %9.4f\n",
          (double )(meantotal / (float )num_reachable));
#line 561
  CloseFiles();
  }
#line 562
  return (0);
}
}
#line 168 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 622
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 144 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 348
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(2), __leaf__)) strtok)(char * __restrict  __s ,
                                                                                               char const   * __restrict  __delim ) ;
#line 18 "/home/june/repo/benchmarks/collector/temp/signing-party-1.1.5/keyanalyze/process_keys.c"
static int DontRequireSelfSig  =    0;
#line 42 "/home/june/repo/benchmarks/collector/temp/signing-party-1.1.5/keyanalyze/process_keys.c"
static void free_sig(struct sig___0 **sigpp ) 
{ 
  struct sig___0 *sigp ;
  struct sig___0 *q ;

  {
#line 46
  if (! sigpp) {
#line 47
    return;
  } else
#line 46
  if (! *sigpp) {
#line 47
    return;
  }
#line 49
  sigp = *sigpp;
  {
#line 49
  while (1) {
    while_continue: /* CIL Label */ ;
#line 49
    if (! sigp) {
#line 49
      goto while_break;
    }
    {
#line 51
    q = sigp->next;
#line 52
    free((void *)sigp);
#line 49
    sigp = q;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 55
  *sigpp = (struct sig___0 *)((void *)0);
#line 56
  return;
}
}
#line 58 "/home/june/repo/benchmarks/collector/temp/signing-party-1.1.5/keyanalyze/process_keys.c"
static void free_uid(struct uid **uidpp ) 
{ 
  struct uid *uidp ;
  struct uid *q ;

  {
#line 62
  if (! uidpp) {
#line 63
    return;
  } else
#line 62
  if (! *uidpp) {
#line 63
    return;
  }
#line 65
  uidp = *uidpp;
  {
#line 65
  while (1) {
    while_continue: /* CIL Label */ ;
#line 65
    if (! uidp) {
#line 65
      goto while_break;
    }
    {
#line 67
    q = uidp->next;
#line 68
    free((void *)uidp);
#line 65
    uidp = q;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 71
  *uidpp = (struct uid *)((void *)0);
#line 72
  return;
}
}
#line 93 "/home/june/repo/benchmarks/collector/temp/signing-party-1.1.5/keyanalyze/process_keys.c"
static int check_sig_id(struct sig___0 *signatures , char *id ) 
{ 
  struct sig___0 *s ;
  int tmp ;

  {
#line 97
  s = signatures;
  {
#line 97
  while (1) {
    while_continue: /* CIL Label */ ;
#line 97
    if (! s) {
#line 97
      goto while_break;
    }
    {
#line 98
    tmp = strcmp((char const   *)(s->id), (char const   *)id);
    }
#line 98
    if (! tmp) {
#line 99
      return (1);
    }
#line 97
    s = s->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 101
  return (0);
}
}
#line 106 "/home/june/repo/benchmarks/collector/temp/signing-party-1.1.5/keyanalyze/process_keys.c"
static int check_selfsig(struct uid *uid , struct key *key ) 
{ 
  unsigned int tmp ;
  int tmp___0 ;

  {
  {
#line 108
  tmp___0 = check_sig_id(uid->sigs, key->id);
#line 108
  tmp = (unsigned int )tmp___0;
#line 108
  uid->self = tmp;
  }
#line 108
  return ((int )tmp);
}
}
#line 113 "/home/june/repo/benchmarks/collector/temp/signing-party-1.1.5/keyanalyze/process_keys.c"
static void join_siglists(struct sig___0 **sig_d , struct sig___0 **sig_s ) 
{ 


  {
  {
#line 115
  while (1) {
    while_continue: /* CIL Label */ ;
#line 115
    if (! *sig_d) {
#line 115
      goto while_break;
    }
#line 116
    sig_d = & (*sig_d)->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 118
  *sig_d = *sig_s;
#line 119
  *sig_s = (struct sig___0 *)((void *)0);
#line 120
  return;
}
}
#line 124 "/home/june/repo/benchmarks/collector/temp/signing-party-1.1.5/keyanalyze/process_keys.c"
static void cleanup_siglist(struct sig___0 **sig , char *keyid ) 
{ 
  struct sig___0 **last ;
  struct sig___0 *p ;
  struct sig___0 *q ;
  int tmp ;
  int tmp___0 ;

  {
#line 126
  last = sig;
#line 129
  p = *sig;
  {
#line 129
  while (1) {
    while_continue: /* CIL Label */ ;
#line 129
    if (! p) {
#line 129
      goto while_break;
    }
    {
#line 131
    q = p->next;
#line 132
    tmp = strcmp((char const   *)keyid, (char const   *)(p->id));
    }
#line 132
    if (tmp) {
      {
#line 132
      tmp___0 = check_sig_id(p->next, p->id);
      }
#line 132
      if (tmp___0) {
        {
#line 134
        *last = p->next;
#line 135
        p->next = (struct sig___0 *)((void *)0);
#line 136
        free_sig(& p);
        }
      } else {
#line 139
        last = & p->next;
      }
    } else {
      {
#line 134
      *last = p->next;
#line 135
      p->next = (struct sig___0 *)((void *)0);
#line 136
      free_sig(& p);
      }
    }
#line 129
    p = q;
  }
  while_break: /* CIL Label */ ;
  }
#line 141
  return;
}
}
#line 145 "/home/june/repo/benchmarks/collector/temp/signing-party-1.1.5/keyanalyze/process_keys.c"
static void do_key(struct key *k ) 
{ 
  struct sig___0 *interesting_signatures ;
  struct sig___0 *sigp ;
  struct uid *uidp ;
  int tmp ;

  {
#line 147
  interesting_signatures = (struct sig___0 *)((void *)0);
#line 150
  if (k->rev) {
#line 151
    return;
  }
#line 153
  uidp = k->uids;
  {
#line 153
  while (1) {
    while_continue: /* CIL Label */ ;
#line 153
    if (! uidp) {
#line 153
      goto while_break;
    }
#line 154
    if (DontRequireSelfSig) {
      {
#line 155
      join_siglists(& interesting_signatures, & uidp->sigs);
      }
    } else {
      {
#line 154
      tmp = check_selfsig(uidp, k);
      }
#line 154
      if (tmp) {
        {
#line 155
        join_siglists(& interesting_signatures, & uidp->sigs);
        }
      }
    }
#line 153
    uidp = uidp->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 157
  cleanup_siglist(& interesting_signatures, k->id);
  }
#line 158
  if (interesting_signatures) {
    {
#line 160
    printf((char const   */* __restrict  */)"p%s\n", k->id);
#line 161
    sigp = interesting_signatures;
    }
    {
#line 161
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 161
      if (! sigp) {
#line 161
        goto while_break___0;
      }
      {
#line 162
      printf((char const   */* __restrict  */)"s%s\n", sigp->id);
#line 161
      sigp = sigp->next;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  {
#line 165
  free_sig(& interesting_signatures);
#line 166
  free_uid(& k->uids);
  }
#line 167
  return;
}
}
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
#line 147 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 236
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 534
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcasecmp)(char const   *__s1 ,
                                                                                                   char const   *__s2 )  __attribute__((__pure__)) ;
#line 538
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncasecmp)(char const   *__s1 ,
                                                                                                    char const   *__s2 ,
                                                                                                    size_t __n )  __attribute__((__pure__)) ;
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 124
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tolower)(int __c ) ;
#line 353 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 444
extern unsigned int sleep(unsigned int __seconds ) ;
#line 511
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) getcwd)(char *__buf ,
                                                                               size_t __size ) ;
#line 790
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) link)(char const   *__from ,
                                                                                             char const   *__to ) ;
#line 803
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) symlink)(char const   *__from ,
                                                                                                char const   *__to ) ;
#line 826
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) unlink)(char const   *__name ) ;
#line 480 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 209 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) stat)(char const   * __restrict  __file ,
                                                                                             struct stat * __restrict  __buf ) ;
#line 214
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2), __leaf__)) fstat)(int __fd ,
                                                                                            struct stat *__buf ) ;
#line 263
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) lstat)(char const   * __restrict  __file ,
                                                                                              struct stat * __restrict  __buf ) ;
#line 146 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 434 "/usr/include/libio.h"
extern int _IO_getc(_IO_FILE *__fp ) ;
#line 180 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) rename)(char const   *__old ,
                                                                             char const   *__new ) ;
#line 306
extern  __attribute__((__nothrow__)) FILE *( __attribute__((__leaf__)) fdopen)(int __fd ,
                                                                               char const   *__modes ) ;
#line 371
extern int vfprintf(FILE * __restrict  __s , char const   * __restrict  __format ,
                    __gnuc_va_list __arg ) ;
#line 573
extern int fputc(int __c , FILE *__stream ) ;
#line 702
extern int ungetc(int __c , FILE *__stream ) ;
#line 715
extern size_t fwrite(void const   * __restrict  __ptr , size_t __size , size_t __n ,
                     FILE * __restrict  __s ) ;
#line 86 "/home/june/repo/benchmarks/collector/temp/signing-party-1.1.5/keyanalyze/pgpring/lib.h"
void (*mutt_error)(char const   *  , ...) ;
#line 88
void mutt_exit(int code ) ;
#line 92
FILE *safe_fopen(char const   *path , char const   *mode___0 ) ;
#line 94
char *mutt_read_line(char *s , size_t *size , FILE *fp , int *line ) ;
#line 95
char *mutt_skip_whitespace(char *p ) ;
#line 96
char *mutt_strlower(char *s ) ;
#line 97
char *mutt_substrcpy(char *dest , char const   *beg , char const   *end , size_t destlen ) ;
#line 98
char *mutt_substrdup(char const   *begin , char const   *end ) ;
#line 99
char *safe_strdup(char const   *s ) ;
#line 101
char const   *mutt_stristr(char const   *haystack , char const   *needle ) ;
#line 103
int mutt_copy_stream(FILE *fin , FILE *fout ) ;
#line 104
int mutt_copy_bytes(FILE *in , FILE *out , size_t size ) ;
#line 105
int mutt_rx_sanitize_string(char *dest , size_t destlen , char const   *src ) ;
#line 106
int mutt_strcasecmp(char const   *a , char const   *b ) ;
#line 107
int mutt_strcmp(char const   *a , char const   *b ) ;
#line 108
int mutt_strncasecmp(char const   *a , char const   *b , size_t l ) ;
#line 109
int mutt_strncmp(char const   *a , char const   *b , size_t l ) ;
#line 110
int safe_open(char const   *path , int flags ) ;
#line 111
int safe_symlink(char const   *oldpath , char const   *newpath ) ;
#line 112
int safe_rename(char const   *src , char const   *target ) ;
#line 113
int safe_fclose(FILE **f ) ;
#line 115
size_t mutt_quote_filename(char *d , size_t l , char const   *f ) ;
#line 116
size_t mutt_strlen(char const   *a ) ;
#line 118
void *safe_calloc(size_t nmemb , size_t size ) ;
#line 119
void *safe_malloc(size_t siz ) ;
#line 120
void mutt_nocurses_error(char const   *fmt  , ...) ;
#line 121
void mutt_remove_trailing_ws(char *s ) ;
#line 122
void mutt_sanitize_filename(char *f , short slash ) ;
#line 123
void mutt_str_replace(char **p , char const   *s ) ;
#line 124
void mutt_str_adjust(char **p ) ;
#line 125
void mutt_unlink(char const   *s ) ;
#line 126
void safe_free(void *p2 ) ;
#line 127
void safe_realloc(void *p2 , size_t siz ) ;
#line 41 "/home/june/repo/benchmarks/collector/temp/signing-party-1.1.5/keyanalyze/pgpring/lib.c"
void mutt_nocurses_error(char const   *fmt  , ...) 
{ 
  va_list ap ;

  {
  {
#line 45
  __builtin_va_start(ap, fmt);
#line 46
  vfprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)fmt,
           ap);
#line 47
  __builtin_va_end(ap);
#line 48
  fputc('\n', stderr);
  }
#line 49
  return;
}
}
#line 51 "/home/june/repo/benchmarks/collector/temp/signing-party-1.1.5/keyanalyze/pgpring/lib.c"
void *safe_calloc(size_t nmemb , size_t size ) 
{ 
  void *p ;

  {
#line 55
  if (! nmemb) {
#line 56
    return ((void *)0);
  } else
#line 55
  if (! size) {
#line 56
    return ((void *)0);
  }
  {
#line 57
  p = calloc(nmemb, size);
  }
#line 57
  if (! p) {
    {
#line 59
    (*mutt_error)("Out of memory!");
#line 60
    sleep(1U);
#line 61
    mutt_exit(1);
    }
  }
#line 63
  return (p);
}
}
#line 66 "/home/june/repo/benchmarks/collector/temp/signing-party-1.1.5/keyanalyze/pgpring/lib.c"
void *safe_malloc(size_t siz ) 
{ 
  void *p ;
  void *tmp ;

  {
#line 70
  if (siz == 0UL) {
#line 71
    return ((void *)0);
  }
  {
#line 72
  tmp = malloc(siz);
#line 72
  p = tmp;
  }
#line 72
  if ((unsigned long )p == (unsigned long )((void *)0)) {
    {
#line 74
    (*mutt_error)("Out of memory!");
#line 75
    sleep(1U);
#line 76
    mutt_exit(1);
    }
  }
#line 78
  return (p);
}
}
#line 81 "/home/june/repo/benchmarks/collector/temp/signing-party-1.1.5/keyanalyze/pgpring/lib.c"
void safe_realloc(void *p2 , size_t siz ) 
{ 
  void **p ;
  void *r ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 83
  p = (void **)p2;
#line 86
  if (siz == 0UL) {
#line 88
    if (*p) {
      {
#line 90
      free(*p);
#line 91
      *p = (void *)0;
      }
    }
#line 93
    return;
  }
#line 96
  if (*p) {
    {
#line 97
    tmp = realloc(*p, siz);
#line 97
    r = tmp;
    }
  } else {
    {
#line 101
    tmp___0 = malloc(siz);
#line 101
    r = tmp___0;
    }
  }
#line 104
  if (! r) {
    {
#line 106
    (*mutt_error)("Out of memory!");
#line 107
    sleep(1U);
#line 108
    mutt_exit(1);
    }
  }
#line 111
  *p = r;
#line 112
  return;
}
}
#line 114 "/home/june/repo/benchmarks/collector/temp/signing-party-1.1.5/keyanalyze/pgpring/lib.c"
void safe_free(void *p2 ) 
{ 
  void **p ;

  {
#line 116
  p = (void **)p2;
#line 117
  if (*p) {
    {
#line 119
    free(*p);
#line 120
    *p = (void *)0;
    }
  }
#line 122
  return;
}
}
#line 124 "/home/june/repo/benchmarks/collector/temp/signing-party-1.1.5/keyanalyze/pgpring/lib.c"
int safe_fclose(FILE **f ) 
{ 
  int r ;

  {
#line 126
  r = 0;
#line 128
  if (*f) {
    {
#line 129
    r = fclose(*f);
    }
  }
#line 131
  *f = (FILE *)((void *)0);
#line 132
  return (r);
}
}
#line 135 "/home/june/repo/benchmarks/collector/temp/signing-party-1.1.5/keyanalyze/pgpring/lib.c"
char *safe_strdup(char const   *s ) 
{ 
  char *p ;
  size_t l ;
  size_t tmp ;
  void *tmp___0 ;

  {
#line 140
  if (! s) {
#line 141
    return ((char *)0);
  } else
#line 140
  if (! *s) {
#line 141
    return ((char *)0);
  }
  {
#line 142
  tmp = strlen(s);
#line 142
  l = tmp + 1UL;
#line 143
  tmp___0 = safe_malloc(l);
#line 143
  p = (char *)tmp___0;
#line 144
  memcpy((void */* __restrict  */)p, (void const   */* __restrict  */)s, l);
  }
#line 145
  return (p);
}
}
#line 148 "/home/june/repo/benchmarks/collector/temp/signing-party-1.1.5/keyanalyze/pgpring/lib.c"
void mutt_str_replace(char **p , char const   *s ) 
{ 


  {
  {
#line 150
  safe_free((void *)p);
#line 151
  *p = safe_strdup(s);
  }
#line 152
  return;
}
}
#line 154 "/home/june/repo/benchmarks/collector/temp/signing-party-1.1.5/keyanalyze/pgpring/lib.c"
void mutt_str_adjust(char **p ) 
{ 
  size_t tmp ;

  {
#line 156
  if (! p) {
#line 156
    return;
  } else
#line 156
  if (! *p) {
#line 156
    return;
  }
  {
#line 157
  tmp = strlen((char const   *)*p);
#line 157
  safe_realloc((void *)((void **)p), tmp + 1UL);
  }
#line 158
  return;
}
}
#line 161 "/home/june/repo/benchmarks/collector/temp/signing-party-1.1.5/keyanalyze/pgpring/lib.c"
char *mutt_strlower(char *s ) 
{ 
  char *p ;
  int tmp ;

  {
#line 163
  p = s;
  {
#line 165
  while (1) {
    while_continue: /* CIL Label */ ;
#line 165
    if (! *p) {
#line 165
      goto while_break;
    }
    {
#line 167
    tmp = tolower((int )*p);
#line 167
    *p = (char )tmp;
#line 168
    p ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 171
  return (s);
}
}
#line 174 "/home/june/repo/benchmarks/collector/temp/signing-party-1.1.5/keyanalyze/pgpring/lib.c"
void mutt_unlink(char const   *s ) 
{ 
  FILE *f ;
  struct stat sb ;
  char buf[2048] ;
  int tmp ;

  {
  {
#line 180
  tmp = stat((char const   */* __restrict  */)s, (struct stat */* __restrict  */)(& sb));
  }
#line 180
  if (tmp == 0) {
    {
#line 182
    f = fopen((char const   */* __restrict  */)s, (char const   */* __restrict  */)"r+");
    }
#line 182
    if (f) {
      {
#line 184
      unlink(s);
#line 185
      memset((void *)(buf), 0, sizeof(buf));
      }
      {
#line 186
      while (1) {
        while_continue: /* CIL Label */ ;
#line 186
        if (! (sb.st_size > 0L)) {
#line 186
          goto while_break;
        }
        {
#line 188
        fwrite((void const   */* __restrict  */)(buf), (size_t )1, sizeof(buf), (FILE */* __restrict  */)f);
#line 189
        sb.st_size = (__off_t )((unsigned long )sb.st_size - sizeof(buf));
        }
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 191
      fclose(f);
      }
    }
  }
#line 194
  return;
}
}
#line 196 "/home/june/repo/benchmarks/collector/temp/signing-party-1.1.5/keyanalyze/pgpring/lib.c"
int mutt_copy_bytes(FILE *in , FILE *out , size_t size ) 
{ 
  char buf[2048] ;
  size_t chunk ;
  size_t tmp ;

  {
  {
#line 201
  while (1) {
    while_continue: /* CIL Label */ ;
#line 201
    if (! (size > 0UL)) {
#line 201
      goto while_break;
    }
#line 203
    if (size > sizeof(buf)) {
#line 203
      chunk = sizeof(buf);
    } else {
#line 203
      chunk = size;
    }
    {
#line 204
    chunk = fread((void */* __restrict  */)(buf), (size_t )1, chunk, (FILE */* __restrict  */)in);
    }
#line 204
    if (chunk < 1UL) {
#line 205
      goto while_break;
    }
    {
#line 206
    tmp = fwrite((void const   */* __restrict  */)(buf), (size_t )1, chunk, (FILE */* __restrict  */)out);
    }
#line 206
    if (tmp != chunk) {
#line 209
      return (-1);
    }
#line 211
    size -= chunk;
  }
  while_break: /* CIL Label */ ;
  }
#line 214
  return (0);
}
}
#line 217 "/home/june/repo/benchmarks/collector/temp/signing-party-1.1.5/keyanalyze/pgpring/lib.c"
int mutt_copy_stream(FILE *fin , FILE *fout ) 
{ 
  size_t l ;
  char buf[1024] ;
  size_t tmp ;

  {
  {
#line 222
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 222
    l = fread((void */* __restrict  */)(buf), (size_t )1, sizeof(buf), (FILE */* __restrict  */)fin);
    }
#line 222
    if (! (l > 0UL)) {
#line 222
      goto while_break;
    }
    {
#line 224
    tmp = fwrite((void const   */* __restrict  */)(buf), (size_t )1, l, (FILE */* __restrict  */)fout);
    }
#line 224
    if (tmp != l) {
#line 225
      return (-1);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 228
  return (0);
}
}
#line 231 "/home/june/repo/benchmarks/collector/temp/signing-party-1.1.5/keyanalyze/pgpring/lib.c"
static int compare_stat(struct stat *osb , struct stat *nsb ) 
{ 


  {
#line 234
  if (osb->st_dev != nsb->st_dev) {
#line 237
    return (-1);
  } else
#line 234
  if (osb->st_ino != nsb->st_ino) {
#line 237
    return (-1);
  } else
#line 234
  if (osb->st_rdev != nsb->st_rdev) {
#line 237
    return (-1);
  }
#line 240
  return (0);
}
}
#line 243 "/home/june/repo/benchmarks/collector/temp/signing-party-1.1.5/keyanalyze/pgpring/lib.c"
int safe_symlink(char const   *oldpath , char const   *newpath ) 
{ 
  struct stat osb ;
  struct stat nsb ;
  int tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  char abs_oldpath[256] ;
  char *tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;

  {
#line 247
  if (! oldpath) {
#line 248
    return (-1);
  } else
#line 247
  if (! newpath) {
#line 248
    return (-1);
  }
  {
#line 250
  tmp = unlink(newpath);
  }
#line 250
  if (tmp == -1) {
    {
#line 250
    tmp___0 = __errno_location();
    }
#line 250
    if (*tmp___0 != 2) {
#line 251
      return (-1);
    }
  }
#line 253
  if ((int const   )*(oldpath + 0) == 47) {
    {
#line 255
    tmp___1 = symlink(oldpath, newpath);
    }
#line 255
    if (tmp___1 == -1) {
#line 256
      return (-1);
    }
  } else {
    {
#line 262
    tmp___2 = getcwd(abs_oldpath, sizeof(abs_oldpath));
    }
#line 262
    if ((unsigned long )tmp___2 == (unsigned long )((void *)0)) {
#line 264
      return (-1);
    } else {
      {
#line 262
      tmp___3 = strlen((char const   *)(abs_oldpath));
#line 262
      tmp___4 = strlen(oldpath);
      }
#line 262
      if (((tmp___3 + 1UL) + tmp___4) + 1UL > sizeof(abs_oldpath)) {
#line 264
        return (-1);
      }
    }
    {
#line 266
    strcat((char */* __restrict  */)(abs_oldpath), (char const   */* __restrict  */)"/");
#line 267
    strcat((char */* __restrict  */)(abs_oldpath), (char const   */* __restrict  */)oldpath);
#line 268
    tmp___5 = symlink((char const   *)(abs_oldpath), newpath);
    }
#line 268
    if (tmp___5 == -1) {
#line 269
      return (-1);
    }
  }
  {
#line 272
  tmp___6 = stat((char const   */* __restrict  */)oldpath, (struct stat */* __restrict  */)(& osb));
  }
#line 272
  if (tmp___6 == -1) {
    {
#line 275
    unlink(newpath);
    }
#line 276
    return (-1);
  } else {
    {
#line 272
    tmp___7 = stat((char const   */* __restrict  */)newpath, (struct stat */* __restrict  */)(& nsb));
    }
#line 272
    if (tmp___7 == -1) {
      {
#line 275
      unlink(newpath);
      }
#line 276
      return (-1);
    } else {
      {
#line 272
      tmp___8 = compare_stat(& osb, & nsb);
      }
#line 272
      if (tmp___8 == -1) {
        {
#line 275
        unlink(newpath);
        }
#line 276
        return (-1);
      }
    }
  }
#line 279
  return (0);
}
}
#line 288 "/home/june/repo/benchmarks/collector/temp/signing-party-1.1.5/keyanalyze/pgpring/lib.c"
int safe_rename(char const   *src , char const   *target ) 
{ 
  struct stat ssb ;
  struct stat tsb ;
  int tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;

  {
#line 292
  if (! src) {
#line 293
    return (-1);
  } else
#line 292
  if (! target) {
#line 293
    return (-1);
  }
  {
#line 295
  tmp___1 = link(src, target);
  }
#line 295
  if (tmp___1 != 0) {
    {
#line 310
    tmp___0 = __errno_location();
    }
#line 310
    if (*tmp___0 == 18) {
      {
#line 311
      tmp = rename(src, target);
      }
#line 311
      return (tmp);
    }
#line 313
    return (-1);
  }
  {
#line 320
  tmp___2 = stat((char const   */* __restrict  */)src, (struct stat */* __restrict  */)(& ssb));
  }
#line 320
  if (tmp___2 == -1) {
#line 322
    return (-1);
  }
  {
#line 325
  tmp___3 = stat((char const   */* __restrict  */)target, (struct stat */* __restrict  */)(& tsb));
  }
#line 325
  if (tmp___3 == -1) {
#line 327
    return (-1);
  }
  {
#line 335
  tmp___5 = compare_stat(& ssb, & tsb);
  }
#line 335
  if (tmp___5 == -1) {
    {
#line 337
    tmp___4 = __errno_location();
#line 337
    *tmp___4 = 17;
    }
#line 338
    return (-1);
  }
  {
#line 346
  unlink(src);
  }
#line 348
  return (0);
}
}
#line 351 "/home/june/repo/benchmarks/collector/temp/signing-party-1.1.5/keyanalyze/pgpring/lib.c"
int safe_open(char const   *path , int flags ) 
{ 
  struct stat osb ;
  struct stat nsb ;
  int fd ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 356
  fd = open(path, flags, 384);
  }
#line 356
  if (fd < 0) {
#line 357
    return (fd);
  }
  {
#line 360
  tmp = lstat((char const   */* __restrict  */)path, (struct stat */* __restrict  */)(& osb));
  }
#line 360
  if (tmp < 0) {
    {
#line 364
    close(fd);
    }
#line 365
    return (-1);
  } else {
    {
#line 360
    tmp___0 = fstat(fd, & nsb);
    }
#line 360
    if (tmp___0 < 0) {
      {
#line 364
      close(fd);
      }
#line 365
      return (-1);
    } else {
      {
#line 360
      tmp___1 = compare_stat(& osb, & nsb);
      }
#line 360
      if (tmp___1 == -1) {
        {
#line 364
        close(fd);
        }
#line 365
        return (-1);
      }
    }
  }
#line 368
  return (fd);
}
}
#line 374 "/home/june/repo/benchmarks/collector/temp/signing-party-1.1.5/keyanalyze/pgpring/lib.c"
FILE *safe_fopen(char const   *path , char const   *mode___0 ) 
{ 
  int fd ;
  int flags ;
  FILE *tmp ;
  FILE *tmp___0 ;

  {
#line 376
  if ((int const   )*(mode___0 + 0) == 119) {
#line 379
    flags = 192;
#line 382
    flags |= 131072;
#line 385
    if ((int const   )*(mode___0 + 1) == 43) {
#line 386
      flags |= 2;
    } else {
#line 388
      flags |= 1;
    }
    {
#line 390
    fd = safe_open(path, flags);
    }
#line 390
    if (fd < 0) {
#line 391
      return ((FILE *)((void *)0));
    }
    {
#line 393
    tmp = fdopen(fd, mode___0);
    }
#line 393
    return (tmp);
  } else {
    {
#line 396
    tmp___0 = fopen((char const   */* __restrict  */)path, (char const   */* __restrict  */)mode___0);
    }
#line 396
    return (tmp___0);
  }
}
}
#line 399 "/home/june/repo/benchmarks/collector/temp/signing-party-1.1.5/keyanalyze/pgpring/lib.c"
static char safe_chars[73]  = 
#line 399
  {      (char )'A',      (char )'B',      (char )'C',      (char )'D', 
        (char )'E',      (char )'F',      (char )'G',      (char )'H', 
        (char )'I',      (char )'J',      (char )'K',      (char )'L', 
        (char )'M',      (char )'N',      (char )'O',      (char )'P', 
        (char )'Q',      (char )'R',      (char )'S',      (char )'T', 
        (char )'U',      (char )'V',      (char )'W',      (char )'X', 
        (char )'Y',      (char )'Z',      (char )'a',      (char )'b', 
        (char )'c',      (char )'d',      (char )'e',      (char )'f', 
        (char )'g',      (char )'h',      (char )'i',      (char )'j', 
        (char )'k',      (char )'l',      (char )'m',      (char )'n', 
        (char )'o',      (char )'p',      (char )'q',      (char )'r', 
        (char )'s',      (char )'t',      (char )'u',      (char )'v', 
        (char )'w',      (char )'x',      (char )'y',      (char )'z', 
        (char )'0',      (char )'1',      (char )'2',      (char )'3', 
        (char )'4',      (char )'5',      (char )'6',      (char )'7', 
        (char )'8',      (char )'9',      (char )'+',      (char )'@', 
        (char )'{',      (char )'}',      (char )'.',      (char )'_', 
        (char )'-',      (char )':',      (char )'%',      (char )'/', 
        (char )'\000'};
#line 401 "/home/june/repo/benchmarks/collector/temp/signing-party-1.1.5/keyanalyze/pgpring/lib.c"
void mutt_sanitize_filename(char *f , short slash ) 
{ 
  char *tmp ;

  {
#line 403
  if (! f) {
#line 403
    return;
  }
  {
#line 405
  while (1) {
    while_continue: /* CIL Label */ ;
#line 405
    if (! *f) {
#line 405
      goto while_break;
    }
#line 407
    if (slash) {
#line 407
      if ((int )*f == 47) {
#line 408
        *f = (char )'_';
      } else {
#line 407
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      {
#line 407
      tmp = strchr((char const   *)(safe_chars), (int )*f);
      }
#line 407
      if (! tmp) {
#line 408
        *f = (char )'_';
      }
    }
#line 405
    f ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 410
  return;
}
}
#line 414 "/home/june/repo/benchmarks/collector/temp/signing-party-1.1.5/keyanalyze/pgpring/lib.c"
static char rx_special_chars[13]  = 
#line 414
  {      (char )'^',      (char )'.',      (char )'[',      (char )'$', 
        (char )'(',      (char )')',      (char )'|',      (char )'*', 
        (char )'+',      (char )'?',      (char )'{',      (char )'\\', 
        (char )'\000'};
#line 416 "/home/june/repo/benchmarks/collector/temp/signing-party-1.1.5/keyanalyze/pgpring/lib.c"
int mutt_rx_sanitize_string(char *dest , size_t destlen , char const   *src ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char const   *tmp___2 ;

  {
  {
#line 418
  while (1) {
    while_continue: /* CIL Label */ ;
#line 418
    if (*src) {
#line 418
      destlen --;
#line 418
      if (! (destlen > 2UL)) {
#line 418
        goto while_break;
      }
    } else {
#line 418
      goto while_break;
    }
    {
#line 420
    tmp___0 = strchr((char const   *)(rx_special_chars), (int )*src);
    }
#line 420
    if (tmp___0) {
#line 422
      tmp = dest;
#line 422
      dest ++;
#line 422
      *tmp = (char )'\\';
#line 423
      destlen --;
    }
#line 425
    tmp___1 = dest;
#line 425
    dest ++;
#line 425
    tmp___2 = src;
#line 425
    src ++;
#line 425
    *tmp___1 = (char )*tmp___2;
  }
  while_break: /* CIL Label */ ;
  }
#line 428
  *dest = (char )'\000';
#line 430
  if (*src) {
#line 431
    return (-1);
  } else {
#line 433
    return (0);
  }
}
}
#line 441 "/home/june/repo/benchmarks/collector/temp/signing-party-1.1.5/keyanalyze/pgpring/lib.c"
char *mutt_read_line(char *s , size_t *size , FILE *fp , int *line ) 
{ 
  size_t offset ;
  char *ch ;
  void *tmp ;
  char *tmp___0 ;
  int c ;

  {
#line 443
  offset = (size_t )0;
#line 446
  if (! s) {
    {
#line 448
    tmp = safe_malloc((size_t )256);
#line 448
    s = (char *)tmp;
#line 449
    *size = (size_t )256;
    }
  }
  {
#line 452
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 454
    tmp___0 = fgets((char */* __restrict  */)(s + offset), (int )(*size - offset),
                    (FILE */* __restrict  */)fp);
    }
#line 454
    if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
      {
#line 456
      safe_free((void *)(& s));
      }
#line 457
      return ((char *)((void *)0));
    }
    {
#line 459
    ch = strchr((char const   *)(s + offset), '\n');
    }
#line 459
    if ((unsigned long )ch != (unsigned long )((void *)0)) {
#line 461
      (*line) ++;
#line 462
      *ch = (char)0;
#line 463
      if ((unsigned long )ch > (unsigned long )s) {
#line 463
        if ((int )*(ch - 1) == 13) {
#line 464
          ch --;
#line 464
          *ch = (char)0;
        }
      }
#line 465
      if ((unsigned long )ch == (unsigned long )s) {
#line 466
        return (s);
      } else
#line 465
      if ((int )*(ch - 1) != 92) {
#line 466
        return (s);
      }
#line 467
      offset = (size_t )((ch - s) - 1L);
    } else {
      {
#line 472
      c = _IO_getc(fp);
      }
#line 477
      if (c == -1) {
#line 480
        (*line) ++;
#line 481
        return (s);
      } else {
        {
#line 485
        ungetc(c, fp);
#line 487
        offset = *size - 1UL;
#line 488
        *size += 256UL;
#line 489
        safe_realloc((void *)(& s), *size);
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 495 "/home/june/repo/benchmarks/collector/temp/signing-party-1.1.5/keyanalyze/pgpring/lib.c"
char *mutt_substrcpy(char *dest , char const   *beg , char const   *end , size_t destlen ) 
{ 
  size_t len ;

  {
#line 500
  len = (size_t )(end - beg);
#line 501
  if (len > destlen - 1UL) {
#line 502
    len = destlen - 1UL;
  }
  {
#line 503
  memcpy((void */* __restrict  */)dest, (void const   */* __restrict  */)beg, len);
#line 504
  *(dest + len) = (char)0;
  }
#line 505
  return (dest);
}
}
#line 508 "/home/june/repo/benchmarks/collector/temp/signing-party-1.1.5/keyanalyze/pgpring/lib.c"
char *mutt_substrdup(char const   *begin , char const   *end ) 
{ 
  size_t len ;
  char *p ;
  void *tmp ;

  {
#line 513
  if (end) {
#line 514
    len = (size_t )(end - begin);
  } else {
    {
#line 516
    len = strlen(begin);
    }
  }
  {
#line 518
  tmp = safe_malloc(len + 1UL);
#line 518
  p = (char *)tmp;
#line 519
  memcpy((void */* __restrict  */)p, (void const   */* __restrict  */)begin, len);
#line 520
  *(p + len) = (char)0;
  }
#line 521
  return (p);
}
}
#line 528 "/home/june/repo/benchmarks/collector/temp/signing-party-1.1.5/keyanalyze/pgpring/lib.c"
size_t mutt_quote_filename(char *d , size_t l , char const   *f ) 
{ 
  size_t i ;
  size_t j ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;

  {
#line 530
  j = (size_t )0;
#line 532
  if (! f) {
#line 534
    *d = (char )'\000';
#line 535
    return ((size_t )0);
  }
#line 539
  l -= 6UL;
#line 541
  tmp = j;
#line 541
  j ++;
#line 541
  *(d + tmp) = (char )'\'';
#line 543
  i = (size_t )0;
  {
#line 543
  while (1) {
    while_continue: /* CIL Label */ ;
#line 543
    if (j < l) {
#line 543
      if (! *(f + i)) {
#line 543
        goto while_break;
      }
    } else {
#line 543
      goto while_break;
    }
#line 545
    if ((int const   )*(f + i) == 39) {
#line 545
      goto _L;
    } else
#line 545
    if ((int const   )*(f + i) == 96) {
      _L: /* CIL Label */ 
#line 547
      tmp___0 = j;
#line 547
      j ++;
#line 547
      *(d + tmp___0) = (char )'\'';
#line 548
      tmp___1 = j;
#line 548
      j ++;
#line 548
      *(d + tmp___1) = (char )'\\';
#line 549
      tmp___2 = j;
#line 549
      j ++;
#line 549
      *(d + tmp___2) = (char )*(f + i);
#line 550
      tmp___3 = j;
#line 550
      j ++;
#line 550
      *(d + tmp___3) = (char )'\'';
    } else {
#line 553
      tmp___4 = j;
#line 553
      j ++;
#line 553
      *(d + tmp___4) = (char )*(f + i);
    }
#line 543
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 556
  tmp___5 = j;
#line 556
  j ++;
#line 556
  *(d + tmp___5) = (char )'\'';
#line 557
  *(d + j) = (char )'\000';
#line 559
  return (j);
}
}
#line 564 "/home/june/repo/benchmarks/collector/temp/signing-party-1.1.5/keyanalyze/pgpring/lib.c"
int mutt_strcmp(char const   *a , char const   *b ) 
{ 
  char const   *tmp ;
  char const   *tmp___0 ;
  int tmp___1 ;

  {
#line 566
  if (b) {
#line 566
    tmp = b;
  } else {
#line 566
    tmp = "";
  }
#line 566
  if (a) {
#line 566
    tmp___0 = a;
  } else {
#line 566
    tmp___0 = "";
  }
  {
#line 566
  tmp___1 = strcmp(tmp___0, tmp);
  }
#line 566
  return (tmp___1);
}
}
#line 569 "/home/june/repo/benchmarks/collector/temp/signing-party-1.1.5/keyanalyze/pgpring/lib.c"
int mutt_strcasecmp(char const   *a , char const   *b ) 
{ 
  char const   *tmp ;
  char const   *tmp___0 ;
  int tmp___1 ;

  {
#line 571
  if (b) {
#line 571
    tmp = b;
  } else {
#line 571
    tmp = "";
  }
#line 571
  if (a) {
#line 571
    tmp___0 = a;
  } else {
#line 571
    tmp___0 = "";
  }
  {
#line 571
  tmp___1 = strcasecmp(tmp___0, tmp);
  }
#line 571
  return (tmp___1);
}
}
#line 574 "/home/june/repo/benchmarks/collector/temp/signing-party-1.1.5/keyanalyze/pgpring/lib.c"
int mutt_strncmp(char const   *a , char const   *b , size_t l ) 
{ 
  char const   *tmp ;
  char const   *tmp___0 ;
  int tmp___1 ;

  {
#line 576
  if (b) {
#line 576
    tmp = b;
  } else {
#line 576
    tmp = "";
  }
#line 576
  if (a) {
#line 576
    tmp___0 = a;
  } else {
#line 576
    tmp___0 = "";
  }
  {
#line 576
  tmp___1 = strncmp(tmp___0, tmp, l);
  }
#line 576
  return (tmp___1);
}
}
#line 579 "/home/june/repo/benchmarks/collector/temp/signing-party-1.1.5/keyanalyze/pgpring/lib.c"
int mutt_strncasecmp(char const   *a , char const   *b , size_t l ) 
{ 
  char const   *tmp ;
  char const   *tmp___0 ;
  int tmp___1 ;

  {
#line 581
  if (b) {
#line 581
    tmp = b;
  } else {
#line 581
    tmp = "";
  }
#line 581
  if (a) {
#line 581
    tmp___0 = a;
  } else {
#line 581
    tmp___0 = "";
  }
  {
#line 581
  tmp___1 = strncasecmp(tmp___0, tmp, l);
  }
#line 581
  return (tmp___1);
}
}
#line 584 "/home/june/repo/benchmarks/collector/temp/signing-party-1.1.5/keyanalyze/pgpring/lib.c"
size_t mutt_strlen(char const   *a ) 
{ 
  size_t tmp ;
  size_t tmp___0 ;

  {
#line 586
  if (a) {
    {
#line 586
    tmp = strlen(a);
#line 586
    tmp___0 = tmp;
    }
  } else {
#line 586
    tmp___0 = (size_t )0;
  }
#line 586
  return (tmp___0);
}
}
#line 589 "/home/june/repo/benchmarks/collector/temp/signing-party-1.1.5/keyanalyze/pgpring/lib.c"
char const   *mutt_stristr(char const   *haystack , char const   *needle ) 
{ 
  char const   *p ;
  char const   *q ;
  int tmp ;
  int tmp___0 ;

  {
#line 593
  if (! haystack) {
#line 594
    return ((char const   *)((void *)0));
  }
#line 595
  if (! needle) {
#line 596
    return (haystack);
  }
  {
#line 598
  while (1) {
    while_continue: /* CIL Label */ ;
#line 598
    p = haystack;
#line 598
    if (! *p) {
#line 598
      goto while_break;
    }
#line 600
    q = needle;
    {
#line 600
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 600
      if (*p) {
#line 600
        if (*q) {
          {
#line 600
          tmp = tolower((int )*p);
#line 600
          tmp___0 = tolower((int )*q);
          }
#line 600
          if (! (tmp == tmp___0)) {
#line 600
            goto while_break___0;
          }
        } else {
#line 600
          goto while_break___0;
        }
      } else {
#line 600
        goto while_break___0;
      }
#line 600
      p ++;
#line 600
      q ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 602
    if (! *q) {
#line 603
      return (haystack);
    }
#line 604
    haystack ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 606
  return ((char const   *)((void *)0));
}
}
#line 609 "/home/june/repo/benchmarks/collector/temp/signing-party-1.1.5/keyanalyze/pgpring/lib.c"
char *mutt_skip_whitespace(char *p ) 
{ 
  unsigned short const   **tmp ;

  {
  {
#line 611
  while (1) {
    while_continue: /* CIL Label */ ;
#line 611
    if (*p) {
      {
#line 611
      tmp = __ctype_b_loc();
      }
#line 611
      if (! ((int const   )*(*tmp + (int )((unsigned char )*p)) & 8192)) {
#line 611
        goto while_break;
      }
    } else {
#line 611
      goto while_break;
    }
#line 611
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 612
  return (p);
}
}
#line 615 "/home/june/repo/benchmarks/collector/temp/signing-party-1.1.5/keyanalyze/pgpring/lib.c"
void mutt_remove_trailing_ws(char *s ) 
{ 
  char *p ;
  size_t tmp ;
  unsigned short const   **tmp___0 ;

  {
  {
#line 619
  tmp = mutt_strlen((char const   *)s);
#line 619
  p = (s + tmp) - 1;
  }
  {
#line 619
  while (1) {
    while_continue: /* CIL Label */ ;
#line 619
    if ((unsigned long )p >= (unsigned long )s) {
      {
#line 619
      tmp___0 = __ctype_b_loc();
      }
#line 619
      if (! ((int const   )*(*tmp___0 + (int )((unsigned char )*p)) & 8192)) {
#line 619
        goto while_break;
      }
    } else {
#line 619
      goto while_break;
    }
#line 620
    *p = (char)0;
#line 619
    p --;
  }
  while_break: /* CIL Label */ ;
  }
#line 621
  return;
}
}
#line 34 "/home/june/repo/benchmarks/collector/temp/signing-party-1.1.5/keyanalyze/pgpring/extlib.c"
void (*mutt_error)(char const   *  , ...)  =    & mutt_nocurses_error;
#line 36 "/home/june/repo/benchmarks/collector/temp/signing-party-1.1.5/keyanalyze/pgpring/extlib.c"
void mutt_exit(int code ) 
{ 


  {
  {
#line 38
  exit(code);
  }
}
}
#line 96 "/home/june/repo/benchmarks/collector/temp/signing-party-1.1.5/keyanalyze/pgpring/pgplib.h"
char const   *pgp_pkalgbytype(unsigned char type ) ;
#line 98
pgp_key_t *pgp_remove_key(pgp_key_t **klist , pgp_key_t *key ) ;
#line 99
pgp_uid_t *pgp_copy_uids(pgp_uid_t *up , pgp_key_t *parent ) ;
#line 101
short pgp_canencrypt(unsigned char type ) ;
#line 102
short pgp_cansign(unsigned char type ) ;
#line 103
short pgp_get_abilities(unsigned char type ) ;
#line 105
void pgp_free_key(pgp_key_t **kpp ) ;
#line 33 "/home/june/repo/benchmarks/collector/temp/signing-party-1.1.5/keyanalyze/pgpring/pgplib.c"
char const   *pgp_pkalgbytype(unsigned char type ) 
{ 


  {
  {
#line 37
  if ((int )type == 1) {
#line 37
    goto case_1;
  }
#line 39
  if ((int )type == 2) {
#line 39
    goto case_2;
  }
#line 41
  if ((int )type == 3) {
#line 41
    goto case_3;
  }
#line 43
  if ((int )type == 16) {
#line 43
    goto case_16;
  }
#line 45
  if ((int )type == 17) {
#line 45
    goto case_17;
  }
#line 47
  if ((int )type == 20) {
#line 47
    goto case_20;
  }
#line 49
  goto switch_default;
  case_1: /* CIL Label */ 
#line 38
  return ("RSA");
  case_2: /* CIL Label */ 
#line 40
  return ("RSA");
  case_3: /* CIL Label */ 
#line 42
  return ("RSA");
  case_16: /* CIL Label */ 
#line 44
  return ("ElG");
  case_17: /* CIL Label */ 
#line 46
  return ("DSA");
  case_20: /* CIL Label */ 
#line 48
  return ("ElG");
  switch_default: /* CIL Label */ 
#line 50
  return ("unk");
  switch_break: /* CIL Label */ ;
  }
}
}
#line 79 "/home/june/repo/benchmarks/collector/temp/signing-party-1.1.5/keyanalyze/pgpring/pgplib.c"
short pgp_canencrypt(unsigned char type ) 
{ 


  {
  {
#line 86
  if ((int )type == 20) {
#line 86
    goto case_20;
  }
#line 86
  if ((int )type == 16) {
#line 86
    goto case_20;
  }
#line 86
  if ((int )type == 2) {
#line 86
    goto case_20;
  }
#line 86
  if ((int )type == 1) {
#line 86
    goto case_20;
  }
#line 88
  goto switch_default;
  case_20: /* CIL Label */ 
  case_16: /* CIL Label */ 
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
#line 87
  return ((short)1);
  switch_default: /* CIL Label */ 
#line 89
  return ((short)0);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 93 "/home/june/repo/benchmarks/collector/temp/signing-party-1.1.5/keyanalyze/pgpring/pgplib.c"
short pgp_cansign(unsigned char type ) 
{ 


  {
  {
#line 100
  if ((int )type == 20) {
#line 100
    goto case_20;
  }
#line 100
  if ((int )type == 17) {
#line 100
    goto case_20;
  }
#line 100
  if ((int )type == 3) {
#line 100
    goto case_20;
  }
#line 100
  if ((int )type == 1) {
#line 100
    goto case_20;
  }
#line 102
  goto switch_default;
  case_20: /* CIL Label */ 
  case_17: /* CIL Label */ 
  case_3: /* CIL Label */ 
  case_1: /* CIL Label */ 
#line 101
  return ((short)1);
  switch_default: /* CIL Label */ 
#line 103
  return ((short)0);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 114 "/home/june/repo/benchmarks/collector/temp/signing-party-1.1.5/keyanalyze/pgpring/pgplib.c"
short pgp_get_abilities(unsigned char type ) 
{ 
  short tmp ;
  short tmp___0 ;

  {
  {
#line 116
  tmp = pgp_canencrypt(type);
#line 116
  tmp___0 = pgp_cansign(type);
  }
#line 116
  return ((short )(((int )tmp << 1) | (int )tmp___0));
}
}
#line 119 "/home/june/repo/benchmarks/collector/temp/signing-party-1.1.5/keyanalyze/pgpring/pgplib.c"
void pgp_free_sig(pgp_sig_t **sigp ) 
{ 
  pgp_sig_t *sp ;
  pgp_sig_t *q ;

  {
#line 123
  if (! sigp) {
#line 124
    return;
  } else
#line 123
  if (! *sigp) {
#line 124
    return;
  }
#line 126
  sp = *sigp;
  {
#line 126
  while (1) {
    while_continue: /* CIL Label */ ;
#line 126
    if (! sp) {
#line 126
      goto while_break;
    }
    {
#line 128
    q = sp->next;
#line 129
    safe_free((void *)(& sp));
#line 126
    sp = q;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 132
  *sigp = (pgp_sig_t *)((void *)0);
#line 133
  return;
}
}
#line 135 "/home/june/repo/benchmarks/collector/temp/signing-party-1.1.5/keyanalyze/pgpring/pgplib.c"
void pgp_free_uid(pgp_uid_t **upp ) 
{ 
  pgp_uid_t *up ;
  pgp_uid_t *q ;

  {
#line 139
  if (! upp) {
#line 140
    return;
  } else
#line 139
  if (! *upp) {
#line 140
    return;
  }
#line 141
  up = *upp;
  {
#line 141
  while (1) {
    while_continue: /* CIL Label */ ;
#line 141
    if (! up) {
#line 141
      goto while_break;
    }
    {
#line 143
    q = up->next;
#line 144
    pgp_free_sig(& up->sigs);
#line 145
    safe_free((void *)(& up->addr));
#line 146
    safe_free((void *)(& up));
#line 141
    up = q;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 149
  *upp = (pgp_uid_t *)((void *)0);
#line 150
  return;
}
}
#line 152 "/home/june/repo/benchmarks/collector/temp/signing-party-1.1.5/keyanalyze/pgpring/pgplib.c"
pgp_uid_t *pgp_copy_uids(pgp_uid_t *up , pgp_key_t *parent ) 
{ 
  pgp_uid_t *l ;
  pgp_uid_t **lp ;
  void *tmp ;

  {
#line 154
  l = (pgp_uid_t *)((void *)0);
#line 155
  lp = & l;
  {
#line 157
  while (1) {
    while_continue: /* CIL Label */ ;
#line 157
    if (! up) {
#line 157
      goto while_break;
    }
    {
#line 159
    tmp = safe_calloc((size_t )1, sizeof(pgp_uid_t ));
#line 159
    *lp = (pgp_uid_t *)tmp;
#line 160
    (*lp)->trust = up->trust;
#line 161
    (*lp)->flags = up->flags;
#line 162
    (*lp)->addr = safe_strdup((char const   *)up->addr);
#line 163
    (*lp)->parent = parent;
#line 164
    lp = & (*lp)->next;
#line 157
    up = up->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 167
  return (l);
}
}
#line 170 "/home/june/repo/benchmarks/collector/temp/signing-party-1.1.5/keyanalyze/pgpring/pgplib.c"
static void _pgp_free_key(pgp_key_t **kpp ) 
{ 
  pgp_key_t *kp ;

  {
#line 174
  if (! kpp) {
#line 175
    return;
  } else
#line 174
  if (! *kpp) {
#line 175
    return;
  }
  {
#line 177
  kp = *kpp;
#line 179
  pgp_free_uid(& kp->address);
#line 180
  safe_free((void *)(& kp->keyid));
#line 181
  safe_free((void *)kpp);
  }
#line 182
  return;
}
}
#line 184 "/home/june/repo/benchmarks/collector/temp/signing-party-1.1.5/keyanalyze/pgpring/pgplib.c"
pgp_key_t *pgp_remove_key(pgp_key_t **klist , pgp_key_t *key ) 
{ 
  pgp_key_t **last ;
  pgp_key_t *p ;
  pgp_key_t *q ;
  pgp_key_t *r ;

  {
#line 189
  if (! klist) {
#line 190
    return ((pgp_key_t *)((void *)0));
  } else
#line 189
  if (! *klist) {
#line 190
    return ((pgp_key_t *)((void *)0));
  } else
#line 189
  if (! key) {
#line 190
    return ((pgp_key_t *)((void *)0));
  }
#line 192
  if (key->parent) {
#line 192
    if ((unsigned long )key->parent != (unsigned long )key) {
#line 193
      key = key->parent;
    }
  }
#line 195
  last = klist;
#line 196
  p = *klist;
  {
#line 196
  while (1) {
    while_continue: /* CIL Label */ ;
#line 196
    if (p) {
#line 196
      if (! ((unsigned long )p != (unsigned long )key)) {
#line 196
        goto while_break;
      }
    } else {
#line 196
      goto while_break;
    }
#line 197
    last = & p->next;
#line 196
    p = p->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 199
  if (! p) {
#line 200
    return ((pgp_key_t *)((void *)0));
  }
#line 202
  q = p->next;
#line 202
  r = p;
  {
#line 202
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 202
    if (q) {
#line 202
      if (! ((unsigned long )q->parent == (unsigned long )p)) {
#line 202
        goto while_break___0;
      }
    } else {
#line 202
      goto while_break___0;
    }
#line 203
    r = q;
#line 202
    q = q->next;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 205
  if (r) {
#line 206
    r->next = (struct pgp_keyinfo *)((void *)0);
  }
#line 208
  *last = q;
#line 209
  return (q);
}
}
#line 212 "/home/june/repo/benchmarks/collector/temp/signing-party-1.1.5/keyanalyze/pgpring/pgplib.c"
void pgp_free_key(pgp_key_t **kpp ) 
{ 
  pgp_key_t *p ;
  pgp_key_t *q ;
  pgp_key_t *r ;

  {
#line 216
  if (! kpp) {
#line 217
    return;
  } else
#line 216
  if (! *kpp) {
#line 217
    return;
  }
#line 219
  if ((*kpp)->parent) {
#line 219
    if ((unsigned long )(*kpp)->parent != (unsigned long )*kpp) {
#line 220
      *kpp = (*kpp)->parent;
    }
  }
#line 230
  p = *kpp;
  {
#line 230
  while (1) {
    while_continue: /* CIL Label */ ;
#line 230
    if (! p) {
#line 230
      goto while_break;
    }
#line 232
    q = p->next;
    {
#line 232
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 232
      if (q) {
#line 232
        if (! ((unsigned long )q->parent == (unsigned long )p)) {
#line 232
          goto while_break___0;
        }
      } else {
#line 232
        goto while_break___0;
      }
      {
#line 234
      r = q->next;
#line 235
      _pgp_free_key(& q);
#line 232
      q = r;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 237
    if (p->parent) {
      {
#line 238
      _pgp_free_key(& p->parent);
      }
    }
    {
#line 240
    _pgp_free_key(& p);
#line 230
    p = q;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 243
  *kpp = (pgp_key_t *)((void *)0);
#line 244
  return;
}
}
#line 386 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 580
extern int putchar(int __c ) ;
#line 749
extern int fseek(FILE *__stream , long __off , int __whence ) ;
#line 754
extern long ftell(FILE *__stream ) ;
#line 846
extern void perror(char const   *__s ) ;
#line 564 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) getenv)(char const   *__name ) ;
#line 132 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 342
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strstr)(char const   *__haystack ,
                                                                                                 char const   *__needle )  __attribute__((__pure__)) ;
#line 192 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t ( __attribute__((__leaf__)) time)(time_t *__timer ) ;
#line 239
extern  __attribute__((__nothrow__)) struct tm *( __attribute__((__leaf__)) gmtime)(time_t const   *__timer ) ;
#line 38 "/home/june/repo/benchmarks/collector/temp/signing-party-1.1.5/keyanalyze/pgpring/sha1.h"
void SHA1Init(SHA1_CTX *context ) ;
#line 39
void SHA1Update(SHA1_CTX *context , unsigned char const   *data , uint32_t len ) ;
#line 40
void SHA1Final(unsigned char *digest , SHA1_CTX *context ) ;
#line 49 "/home/june/repo/benchmarks/collector/temp/signing-party-1.1.5/keyanalyze/pgpring/pgppacket.h"
unsigned char *pgp_read_packet(FILE *fp , size_t *len ) ;
#line 67 "/home/june/repo/benchmarks/collector/temp/signing-party-1.1.5/keyanalyze/pgpring/pgppubring.c"
static short dump_signatures  =    (short)0;
#line 70
static void pgpring_find_candidates(char *ringfile , char const   **hints , int nhints ) ;
#line 71
static void pgpring_dump_keyblock(pgp_key_t *p ) ;
#line 151 "/home/june/repo/benchmarks/collector/temp/signing-party-1.1.5/keyanalyze/pgpring/pgppubring.c"
static pgp_key_t *pgp_parse_pgp2_key(unsigned char *buff , size_t l ) 
{ 
  pgp_key_t *p ;
  unsigned char alg ;
  size_t expl ;
  unsigned long id ;
  time_t gen_time ;
  unsigned short exp_days ;
  size_t j ;
  int i ;
  int k ;
  unsigned char scratch[1024] ;
  void *tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  time_t tmp___2 ;
  size_t tmp___3 ;
  short tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;

  {
#line 157
  gen_time = (time_t )0;
#line 158
  exp_days = (unsigned short)0;
#line 163
  if (l < 12UL) {
#line 164
    return ((pgp_key_t *)((void *)0));
  }
  {
#line 166
  tmp = safe_calloc(sizeof(pgp_key_t ), (size_t )1);
#line 166
  p = (pgp_key_t *)tmp;
#line 168
  i = 0;
#line 168
  j = (size_t )2;
  }
  {
#line 168
  while (1) {
    while_continue: /* CIL Label */ ;
#line 168
    if (! (i < 4)) {
#line 168
      goto while_break;
    }
#line 169
    tmp___0 = j;
#line 169
    j ++;
#line 169
    gen_time = (gen_time << 8) + (time_t )*(buff + tmp___0);
#line 168
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 171
  p->gen_time = gen_time;
#line 173
  i = 0;
  {
#line 173
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 173
    if (! (i < 2)) {
#line 173
      goto while_break___0;
    }
#line 174
    tmp___1 = j;
#line 174
    j ++;
#line 174
    exp_days = (unsigned short )(((int )exp_days << 8) + (int )*(buff + tmp___1));
#line 173
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 176
  if (exp_days) {
    {
#line 176
    tmp___2 = time((time_t *)((void *)0));
    }
#line 176
    if (tmp___2 > gen_time + (time_t )(((int )exp_days * 24) * 3600)) {
#line 177
      p->flags |= 1 << 8;
    }
  }
  {
#line 179
  tmp___3 = j;
#line 179
  j ++;
#line 179
  alg = *(buff + tmp___3);
#line 181
  p->numalg = (int )alg;
#line 182
  p->algorithm = pgp_pkalgbytype(alg);
#line 183
  tmp___4 = pgp_get_abilities(alg);
#line 183
  p->flags |= (int )tmp___4;
#line 185
  expl = (size_t )0;
#line 186
  i = 0;
  }
  {
#line 186
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 186
    if (! (i < 2)) {
#line 186
      goto while_break___1;
    }
#line 187
    tmp___5 = j;
#line 187
    j ++;
#line 187
    expl = (expl << 8) + (size_t )*(buff + tmp___5);
#line 186
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 189
  p->keylen = (short )expl;
#line 191
  expl = (expl + 7UL) / 8UL;
#line 192
  if (expl < 4UL) {
#line 193
    goto bailout;
  }
#line 196
  j += expl - 8UL;
#line 198
  k = 0;
  {
#line 198
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 198
    if (! (k < 2)) {
#line 198
      goto while_break___2;
    }
#line 200
    id = 0UL;
#line 200
    i = 0;
    {
#line 200
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 200
      if (! (i < 4)) {
#line 200
        goto while_break___3;
      }
#line 201
      tmp___6 = j;
#line 201
      j ++;
#line 201
      id = (id << 8) + (unsigned long )*(buff + tmp___6);
#line 200
      i ++;
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 203
    snprintf((char */* __restrict  */)((char *)(scratch) + k * 8), sizeof(scratch) - (unsigned long )(k * 8),
             (char const   */* __restrict  */)"%08lX", id);
#line 198
    k ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 207
  p->keyid = safe_strdup((char const   *)((char *)(scratch)));
  }
#line 209
  return (p);
  bailout: 
  {
#line 213
  safe_free((void *)(& p));
  }
#line 214
  return ((pgp_key_t *)((void *)0));
}
}
#line 217 "/home/june/repo/benchmarks/collector/temp/signing-party-1.1.5/keyanalyze/pgpring/pgppubring.c"
static void pgp_make_pgp3_fingerprint(unsigned char *buff , size_t l , unsigned char *digest ) 
{ 
  unsigned char dummy ;
  SHA1_CTX context ;

  {
  {
#line 223
  SHA1Init(& context);
#line 225
  dummy = (unsigned char )((int )*(buff + 0) & 63);
  }
#line 227
  if ((int )dummy == 7) {
#line 228
    dummy = (unsigned char)6;
  } else
#line 227
  if ((int )dummy == 14) {
#line 228
    dummy = (unsigned char)6;
  } else
#line 227
  if ((int )dummy == 5) {
#line 228
    dummy = (unsigned char)6;
  }
  {
#line 230
  dummy = (unsigned char )(((int )dummy << 2) | 129);
#line 231
  SHA1Update(& context, (unsigned char const   *)(& dummy), (uint32_t )1);
#line 232
  dummy = (unsigned char )(((l - 1UL) >> 8) & 255UL);
#line 233
  SHA1Update(& context, (unsigned char const   *)(& dummy), (uint32_t )1);
#line 234
  dummy = (unsigned char )((l - 1UL) & 255UL);
#line 235
  SHA1Update(& context, (unsigned char const   *)(& dummy), (uint32_t )1);
#line 236
  SHA1Update(& context, (unsigned char const   *)(buff + 1), (uint32_t )(l - 1UL));
#line 237
  SHA1Final((unsigned char *)digest, & context);
  }
#line 239
  return;
}
}
#line 241 "/home/june/repo/benchmarks/collector/temp/signing-party-1.1.5/keyanalyze/pgpring/pgppubring.c"
static void skip_bignum(unsigned char *buff , size_t l , size_t j , size_t *toff ,
                        size_t n ) 
{ 
  size_t len ;

  {
  {
#line 246
  while (1) {
    while_continue: /* CIL Label */ ;
#line 248
    len = (size_t )(((int )*(buff + j) << 8) + (int )*(buff + (j + 1UL)));
#line 249
    j += (len + 7UL) / 8UL + 2UL;
#line 246
    if (j <= l) {
#line 246
      n --;
#line 246
      if (! (n > 0UL)) {
#line 246
        goto while_break;
      }
    } else {
#line 246
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 253
  if (toff) {
#line 254
    *toff = j;
  }
#line 255
  return;
}
}
#line 258 "/home/june/repo/benchmarks/collector/temp/signing-party-1.1.5/keyanalyze/pgpring/pgppubring.c"
static pgp_key_t *pgp_parse_pgp3_key(unsigned char *buff , size_t l ) 
{ 
  pgp_key_t *p ;
  unsigned char alg ;
  unsigned char digest[20] ;
  unsigned char scratch[1024] ;
  time_t gen_time ;
  unsigned long id ;
  int i ;
  int k ;
  short len ;
  size_t j ;
  void *tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  short tmp___2 ;

  {
  {
#line 264
  gen_time = (time_t )0;
#line 270
  tmp = safe_calloc(sizeof(pgp_key_t ), (size_t )1);
#line 270
  p = (pgp_key_t *)tmp;
#line 271
  j = (size_t )2;
#line 273
  i = 0;
  }
  {
#line 273
  while (1) {
    while_continue: /* CIL Label */ ;
#line 273
    if (! (i < 4)) {
#line 273
      goto while_break;
    }
#line 274
    tmp___0 = j;
#line 274
    j ++;
#line 274
    gen_time = (gen_time << 8) + (time_t )*(buff + tmp___0);
#line 273
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 276
  p->gen_time = gen_time;
#line 278
  tmp___1 = j;
#line 278
  j ++;
#line 278
  alg = *(buff + tmp___1);
#line 280
  p->numalg = (int )alg;
#line 281
  p->algorithm = pgp_pkalgbytype(alg);
#line 282
  tmp___2 = pgp_get_abilities(alg);
#line 282
  p->flags |= (int )tmp___2;
  }
#line 284
  if ((int )alg == 17) {
    {
#line 285
    skip_bignum(buff, l, j, & j, (size_t )3);
    }
  } else
#line 286
  if ((int )alg == 16) {
    {
#line 287
    skip_bignum(buff, l, j, & j, (size_t )2);
    }
  } else
#line 286
  if ((int )alg == 20) {
    {
#line 287
    skip_bignum(buff, l, j, & j, (size_t )2);
    }
  }
#line 289
  len = (short )(((int )*(buff + j) << 8) + (int )*(buff + (j + 1UL)));
#line 290
  p->keylen = len;
#line 292
  if ((int )alg >= 1) {
#line 292
    if ((int )alg <= 3) {
      {
#line 293
      skip_bignum(buff, l, j, & j, (size_t )2);
      }
    } else {
#line 292
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 294
  if ((int )alg == 17) {
    {
#line 295
    skip_bignum(buff, l, j, & j, (size_t )1);
    }
  } else
#line 294
  if ((int )alg == 16) {
    {
#line 295
    skip_bignum(buff, l, j, & j, (size_t )1);
    }
  } else
#line 294
  if ((int )alg == 20) {
    {
#line 295
    skip_bignum(buff, l, j, & j, (size_t )1);
    }
  }
  {
#line 297
  pgp_make_pgp3_fingerprint(buff, j, digest);
#line 299
  k = 0;
  }
  {
#line 299
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 299
    if (! (k < 2)) {
#line 299
      goto while_break___0;
    }
#line 301
    id = 0UL;
#line 301
    i = 12 + k * 4;
    {
#line 301
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 301
      if (! (i < 20 + (k - 1) * 4)) {
#line 301
        goto while_break___1;
      }
#line 303
      id = (id << 8) + (unsigned long )digest[i];
#line 301
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 305
    snprintf((char */* __restrict  */)((char *)(scratch) + k * 8), sizeof(scratch) - (unsigned long )(k * 8),
             (char const   */* __restrict  */)"%08lX", id);
#line 299
    k ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 308
  p->keyid = safe_strdup((char const   *)((char *)(scratch)));
  }
#line 310
  return (p);
}
}
#line 313 "/home/june/repo/benchmarks/collector/temp/signing-party-1.1.5/keyanalyze/pgpring/pgppubring.c"
static pgp_key_t *pgp_parse_keyinfo(unsigned char *buff , size_t l ) 
{ 
  pgp_key_t *tmp ;
  pgp_key_t *tmp___0 ;

  {
#line 315
  if (! buff) {
#line 316
    return ((pgp_key_t *)((void *)0));
  } else
#line 315
  if (l < 2UL) {
#line 316
    return ((pgp_key_t *)((void *)0));
  }
  {
#line 321
  if ((int )*(buff + 1) == 3) {
#line 321
    goto case_3;
  }
#line 321
  if ((int )*(buff + 1) == 2) {
#line 321
    goto case_3;
  }
#line 323
  if ((int )*(buff + 1) == 4) {
#line 323
    goto case_4;
  }
#line 325
  goto switch_default;
  case_3: /* CIL Label */ 
  case_2: /* CIL Label */ 
  {
#line 322
  tmp = pgp_parse_pgp2_key(buff, l);
  }
#line 322
  return (tmp);
  case_4: /* CIL Label */ 
  {
#line 324
  tmp___0 = pgp_parse_pgp3_key(buff, l);
  }
#line 324
  return (tmp___0);
  switch_default: /* CIL Label */ 
#line 326
  return ((pgp_key_t *)((void *)0));
  switch_break: /* CIL Label */ ;
  }
}
}
#line 330 "/home/june/repo/benchmarks/collector/temp/signing-party-1.1.5/keyanalyze/pgpring/pgppubring.c"
static int pgp_parse_pgp2_sig(unsigned char *buff , size_t l , pgp_key_t *p , pgp_sig_t *s ) 
{ 
  unsigned char sigtype ;
  time_t sig_gen_time ;
  unsigned long signerid1 ;
  unsigned long signerid2 ;
  size_t j ;
  int i ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;

  {
#line 339
  if (l < 22UL) {
#line 340
    return (-1);
  }
#line 342
  j = (size_t )3;
#line 343
  tmp = j;
#line 343
  j ++;
#line 343
  sigtype = *(buff + tmp);
#line 345
  sig_gen_time = (time_t )0;
#line 346
  i = 0;
  {
#line 346
  while (1) {
    while_continue: /* CIL Label */ ;
#line 346
    if (! (i < 4)) {
#line 346
      goto while_break;
    }
#line 347
    tmp___0 = j;
#line 347
    j ++;
#line 347
    sig_gen_time = (sig_gen_time << 8) + (time_t )*(buff + tmp___0);
#line 346
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 349
  signerid2 = 0UL;
#line 349
  signerid1 = signerid2;
#line 350
  i = 0;
  {
#line 350
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 350
    if (! (i < 4)) {
#line 350
      goto while_break___0;
    }
#line 351
    tmp___1 = j;
#line 351
    j ++;
#line 351
    signerid1 = (signerid1 << 8) + (unsigned long )*(buff + tmp___1);
#line 350
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 353
  i = 0;
  {
#line 353
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 353
    if (! (i < 4)) {
#line 353
      goto while_break___1;
    }
#line 354
    tmp___2 = j;
#line 354
    j ++;
#line 354
    signerid2 = (signerid2 << 8) + (unsigned long )*(buff + tmp___2);
#line 353
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 357
  if ((int )sigtype == 32) {
#line 358
    p->flags |= 1 << 9;
  } else
#line 357
  if ((int )sigtype == 40) {
#line 358
    p->flags |= 1 << 9;
  }
#line 360
  if (s) {
#line 362
    s->sigtype = sigtype;
#line 363
    s->sid1 = signerid1;
#line 364
    s->sid2 = signerid2;
  }
#line 367
  return (0);
}
}
#line 370 "/home/june/repo/benchmarks/collector/temp/signing-party-1.1.5/keyanalyze/pgpring/pgppubring.c"
static int pgp_parse_pgp3_sig(unsigned char *buff , size_t l , pgp_key_t *p , pgp_sig_t *s ) 
{ 
  unsigned char sigtype ;
  unsigned char pkalg ;
  unsigned char hashalg ;
  unsigned char skt ;
  time_t sig_gen_time ;
  long validity ;
  long key_validity ;
  unsigned long signerid1 ;
  unsigned long signerid2 ;
  size_t ml ;
  size_t j ;
  int i ;
  short ii ;
  short have_critical_spks ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t skl ;
  size_t nextone ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  size_t tmp___7 ;
  size_t tmp___8 ;
  size_t tmp___9 ;
  time_t tmp___10 ;

  {
#line 376
  sig_gen_time = (time_t )-1;
#line 377
  validity = -1L;
#line 378
  key_validity = -1L;
#line 379
  signerid1 = 0UL;
#line 380
  signerid2 = 0UL;
#line 385
  have_critical_spks = (short)0;
#line 387
  if (l < 7UL) {
#line 388
    return (-1);
  }
#line 390
  j = (size_t )2;
#line 392
  tmp = j;
#line 392
  j ++;
#line 392
  sigtype = *(buff + tmp);
#line 393
  tmp___0 = j;
#line 393
  j ++;
#line 393
  pkalg = *(buff + tmp___0);
#line 394
  tmp___1 = j;
#line 394
  j ++;
#line 394
  hashalg = *(buff + tmp___1);
#line 396
  ii = (short)0;
  {
#line 396
  while (1) {
    while_continue: /* CIL Label */ ;
#line 396
    if (! ((int )ii < 2)) {
#line 396
      goto while_break;
    }
#line 401
    ml = (size_t )(((int )*(buff + j) << 8) + (int )*(buff + (j + 1UL)));
#line 402
    j += 2UL;
#line 404
    if (j + ml > l) {
#line 405
      goto while_break;
    }
#line 407
    nextone = j;
    {
#line 408
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 408
      if (! ml) {
#line 408
        goto while_break___0;
      }
#line 410
      j = nextone;
#line 411
      tmp___2 = j;
#line 411
      j ++;
#line 411
      skl = (size_t )*(buff + tmp___2);
#line 412
      ml --;
#line 412
      if (! ml) {
#line 413
        goto while_break___0;
      }
#line 415
      if (skl >= 192UL) {
#line 417
        tmp___3 = j;
#line 417
        j ++;
#line 417
        skl = ((skl - 192UL) * 256UL + (size_t )*(buff + tmp___3)) + 192UL;
#line 418
        ml --;
#line 418
        if (! ml) {
#line 419
          goto while_break___0;
        }
      }
#line 422
      if ((int )ml - (int )skl < 0) {
#line 423
        goto while_break___0;
      }
#line 424
      ml -= skl;
#line 426
      nextone = j + skl;
#line 427
      tmp___4 = j;
#line 427
      j ++;
#line 427
      skt = *(buff + tmp___4);
      {
#line 431
      if (((int )skt & 127) == 2) {
#line 431
        goto case_2;
      }
#line 441
      if (((int )skt & 127) == 3) {
#line 441
        goto case_3;
      }
#line 450
      if (((int )skt & 127) == 9) {
#line 450
        goto case_9;
      }
#line 459
      if (((int )skt & 127) == 16) {
#line 459
        goto case_16;
      }
#line 471
      if (((int )skt & 127) == 10) {
#line 471
        goto case_10;
      }
#line 484
      goto switch_default;
      case_2: /* CIL Label */ 
#line 433
      if (skl < 4UL) {
#line 434
        goto switch_break;
      }
#line 435
      sig_gen_time = (time_t )0;
#line 436
      i = 0;
      {
#line 436
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 436
        if (! (i < 4)) {
#line 436
          goto while_break___1;
        }
#line 437
        tmp___5 = j;
#line 437
        j ++;
#line 437
        sig_gen_time = (sig_gen_time << 8) + (time_t )*(buff + tmp___5);
#line 436
        i ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 439
      goto switch_break;
      case_3: /* CIL Label */ 
#line 443
      if (skl < 4UL) {
#line 444
        goto switch_break;
      }
#line 445
      validity = 0L;
#line 446
      i = 0;
      {
#line 446
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 446
        if (! (i < 4)) {
#line 446
          goto while_break___2;
        }
#line 447
        tmp___6 = j;
#line 447
        j ++;
#line 447
        validity = (validity << 8) + (long )*(buff + tmp___6);
#line 446
        i ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 448
      goto switch_break;
      case_9: /* CIL Label */ 
#line 452
      if (skl < 4UL) {
#line 453
        goto switch_break;
      }
#line 454
      key_validity = 0L;
#line 455
      i = 0;
      {
#line 455
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 455
        if (! (i < 4)) {
#line 455
          goto while_break___3;
        }
#line 456
        tmp___7 = j;
#line 456
        j ++;
#line 456
        key_validity = (key_validity << 8) + (long )*(buff + tmp___7);
#line 455
        i ++;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 457
      goto switch_break;
      case_16: /* CIL Label */ 
#line 461
      if (skl < 8UL) {
#line 462
        goto switch_break;
      }
#line 463
      signerid1 = 0UL;
#line 463
      signerid2 = signerid1;
#line 464
      i = 0;
      {
#line 464
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 464
        if (! (i < 4)) {
#line 464
          goto while_break___4;
        }
#line 465
        tmp___8 = j;
#line 465
        j ++;
#line 465
        signerid1 = (signerid1 << 8) + (unsigned long )*(buff + tmp___8);
#line 464
        i ++;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 466
      i = 0;
      {
#line 466
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 466
        if (! (i < 4)) {
#line 466
          goto while_break___5;
        }
#line 467
        tmp___9 = j;
#line 467
        j ++;
#line 467
        signerid2 = (signerid2 << 8) + (unsigned long )*(buff + tmp___9);
#line 466
        i ++;
      }
      while_break___5: /* CIL Label */ ;
      }
#line 469
      goto switch_break;
      case_10: /* CIL Label */ 
#line 472
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 486
      if ((int )skt & 128) {
#line 487
        have_critical_spks = (short)1;
      }
      switch_break: /* CIL Label */ ;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 491
    j = nextone;
#line 396
    ii = (short )((int )ii + 1);
  }
  while_break: /* CIL Label */ ;
  }
#line 494
  if ((int )sigtype == 32) {
#line 495
    p->flags |= 1 << 9;
  } else
#line 494
  if ((int )sigtype == 40) {
#line 495
    p->flags |= 1 << 9;
  }
#line 496
  if (key_validity != -1L) {
    {
#line 496
    tmp___10 = time((time_t *)((void *)0));
    }
#line 496
    if (tmp___10 > p->gen_time + key_validity) {
#line 497
      p->flags |= 1 << 8;
    }
  }
#line 498
  if (have_critical_spks) {
#line 499
    p->flags |= 1 << 12;
  }
#line 501
  if (s) {
#line 503
    s->sigtype = sigtype;
#line 504
    s->sid1 = signerid1;
#line 505
    s->sid2 = signerid2;
  }
#line 509
  return (0);
}
}
#line 514 "/home/june/repo/benchmarks/collector/temp/signing-party-1.1.5/keyanalyze/pgpring/pgppubring.c"
static int pgp_parse_sig(unsigned char *buff , size_t l , pgp_key_t *p , pgp_sig_t *sig ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 516
  if (! buff) {
#line 517
    return (-1);
  } else
#line 516
  if (l < 2UL) {
#line 517
    return (-1);
  } else
#line 516
  if (! p) {
#line 517
    return (-1);
  }
  {
#line 522
  if ((int )*(buff + 1) == 3) {
#line 522
    goto case_3;
  }
#line 522
  if ((int )*(buff + 1) == 2) {
#line 522
    goto case_3;
  }
#line 524
  if ((int )*(buff + 1) == 4) {
#line 524
    goto case_4;
  }
#line 526
  goto switch_default;
  case_3: /* CIL Label */ 
  case_2: /* CIL Label */ 
  {
#line 523
  tmp = pgp_parse_pgp2_sig(buff, l, p, sig);
  }
#line 523
  return (tmp);
  case_4: /* CIL Label */ 
  {
#line 525
  tmp___0 = pgp_parse_pgp3_sig(buff, l, p, sig);
  }
#line 525
  return (tmp___0);
  switch_default: /* CIL Label */ 
#line 527
  return (-1);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 533 "/home/june/repo/benchmarks/collector/temp/signing-party-1.1.5/keyanalyze/pgpring/pgppubring.c"
static pgp_key_t *pgp_parse_keyblock(FILE *fp ) 
{ 
  unsigned char *buff ;
  unsigned char pt ;
  unsigned char last_pt ;
  size_t l ;
  short err ;
  long pos ;
  pgp_key_t *root ;
  pgp_key_t **last ;
  pgp_key_t *p ;
  pgp_uid_t *uid ;
  pgp_uid_t **addr ;
  pgp_sig_t **lsig ;
  pgp_key_t *tmp ;
  pgp_sig_t *signature ;
  void *tmp___0 ;
  char *chr ;
  void *tmp___1 ;
  void *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;

  {
  {
#line 536
  pt = (unsigned char)0;
#line 539
  err = (short)0;
#line 547
  root = (pgp_key_t *)((void *)0);
#line 548
  last = & root;
#line 549
  p = (pgp_key_t *)((void *)0);
#line 550
  uid = (pgp_uid_t *)((void *)0);
#line 551
  addr = (pgp_uid_t **)((void *)0);
#line 552
  lsig = (pgp_sig_t **)((void *)0);
#line 554
  pos = ftell(fp);
  }
  {
#line 556
  while (1) {
    while_continue: /* CIL Label */ ;
#line 556
    if (! err) {
      {
#line 556
      buff = pgp_read_packet(fp, & l);
      }
#line 556
      if (! ((unsigned long )buff != (unsigned long )((void *)0))) {
#line 556
        goto while_break;
      }
    } else {
#line 556
      goto while_break;
    }
#line 558
    last_pt = pt;
#line 559
    pt = (unsigned char )((int )*(buff + 0) & 63);
#line 563
    if ((int )pt == 5) {
#line 563
      goto _L;
    } else
#line 563
    if ((int )pt == 6) {
      _L: /* CIL Label */ 
#line 563
      if (root) {
        {
#line 565
        fseek(fp, pos, 0);
        }
#line 566
        return (root);
      }
    }
    {
#line 574
    if ((int )pt == 7) {
#line 574
      goto case_7;
    }
#line 574
    if ((int )pt == 14) {
#line 574
      goto case_7;
    }
#line 574
    if ((int )pt == 6) {
#line 574
      goto case_7;
    }
#line 574
    if ((int )pt == 5) {
#line 574
      goto case_7;
    }
#line 603
    if ((int )pt == 2) {
#line 603
      goto case_2;
    }
#line 616
    if ((int )pt == 12) {
#line 616
      goto case_12;
    }
#line 632
    if ((int )pt == 13) {
#line 632
      goto case_13;
    }
#line 569
    goto switch_break;
    case_7: /* CIL Label */ 
    case_14: /* CIL Label */ 
    case_6: /* CIL Label */ 
    case_5: /* CIL Label */ 
    {
#line 576
    p = pgp_parse_keyinfo(buff, l);
#line 576
    tmp = p;
#line 576
    *last = tmp;
    }
#line 576
    if (! tmp) {
#line 578
      err = (short)1;
#line 579
      goto switch_break;
    }
#line 582
    last = & p->next;
#line 583
    addr = & p->address;
#line 584
    lsig = & p->sigs;
#line 586
    if ((int )pt == 14) {
#line 586
      goto _L___0;
    } else
#line 586
    if ((int )pt == 7) {
      _L___0: /* CIL Label */ 
#line 588
      p->flags |= 1 << 11;
#line 589
      if ((unsigned long )p != (unsigned long )root) {
        {
#line 591
        p->parent = root;
#line 592
        p->address = pgp_copy_uids(root->address, p);
        }
        {
#line 593
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 593
          if (! *addr) {
#line 593
            goto while_break___0;
          }
#line 593
          addr = & (*addr)->next;
        }
        while_break___0: /* CIL Label */ ;
        }
      }
    }
#line 597
    if ((int )pt == 5) {
#line 598
      p->flags |= 1 << 7;
    } else
#line 597
    if ((int )pt == 7) {
#line 598
      p->flags |= 1 << 7;
    }
#line 600
    goto switch_break;
    case_2: /* CIL Label */ 
#line 605
    if (lsig) {
      {
#line 607
      tmp___0 = safe_calloc(sizeof(pgp_sig_t ), (size_t )1);
#line 607
      signature = (pgp_sig_t *)tmp___0;
#line 608
      *lsig = signature;
#line 609
      lsig = & signature->next;
#line 611
      pgp_parse_sig(buff, l, p, signature);
      }
    }
#line 613
    goto switch_break;
    case_12: /* CIL Label */ 
#line 618
    if (p) {
#line 618
      if ((int )last_pt == 5) {
#line 618
        goto _L___2;
      } else
#line 618
      if ((int )last_pt == 6) {
#line 618
        goto _L___2;
      } else
#line 618
      if ((int )last_pt == 14) {
#line 618
        goto _L___2;
      } else
#line 618
      if ((int )last_pt == 7) {
        _L___2: /* CIL Label */ 
#line 621
        if ((int )*(buff + 1) & 32) {
#line 623
          p->flags |= 1 << 10;
        }
      } else {
#line 618
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */ 
#line 626
    if ((int )last_pt == 13) {
#line 626
      if (uid) {
#line 628
        uid->trust = (short )*(buff + 1);
      }
    }
#line 630
    goto switch_break;
    case_13: /* CIL Label */ 
#line 637
    if (! addr) {
#line 638
      goto switch_break;
    }
    {
#line 640
    tmp___1 = safe_malloc(l);
#line 640
    chr = (char *)tmp___1;
#line 641
    memcpy((void */* __restrict  */)chr, (void const   */* __restrict  */)(buff + 1),
           l - 1UL);
#line 642
    *(chr + (l - 1UL)) = (char )'\000';
#line 645
    tmp___2 = safe_calloc((size_t )1, sizeof(pgp_uid_t ));
#line 645
    uid = (pgp_uid_t *)tmp___2;
#line 645
    *addr = uid;
#line 646
    uid->addr = chr;
#line 647
    uid->parent = p;
#line 648
    uid->trust = (short)0;
#line 649
    addr = & uid->next;
#line 650
    lsig = & uid->sigs;
#line 656
    tmp___3 = strstr((char const   *)chr, "ENCR");
    }
#line 656
    if (tmp___3) {
#line 657
      p->flags |= 1 << 13;
    }
    {
#line 658
    tmp___4 = strstr((char const   *)chr, "SIGN");
    }
#line 658
    if (tmp___4) {
#line 659
      p->flags |= 1 << 14;
    }
#line 661
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
    {
#line 665
    pos = ftell(fp);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 668
  if (err) {
    {
#line 669
    pgp_free_key(& root);
    }
  }
#line 671
  return (root);
}
}
#line 674 "/home/june/repo/benchmarks/collector/temp/signing-party-1.1.5/keyanalyze/pgpring/pgppubring.c"
static int pgpring_string_matches_hint(char const   *s , char const   **hints , int nhints ) 
{ 
  int i ;
  char const   *tmp ;

  {
#line 678
  if (! hints) {
#line 679
    return (1);
  } else
#line 678
  if (! nhints) {
#line 679
    return (1);
  }
#line 681
  i = 0;
  {
#line 681
  while (1) {
    while_continue: /* CIL Label */ ;
#line 681
    if (! (i < nhints)) {
#line 681
      goto while_break;
    }
    {
#line 683
    tmp = mutt_stristr(s, *(hints + i));
    }
#line 683
    if ((unsigned long )tmp != (unsigned long )((void *)0)) {
#line 684
      return (1);
    }
#line 681
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 687
  return (0);
}
}
#line 695 "/home/june/repo/benchmarks/collector/temp/signing-party-1.1.5/keyanalyze/pgpring/pgppubring.c"
static void pgpring_find_candidates(char *ringfile , char const   **hints , int nhints ) 
{ 
  FILE *rfp ;
  long pos ;
  long keypos ;
  unsigned char *buff ;
  unsigned char pt ;
  size_t l ;
  short err ;
  char *tmp ;
  void *tmp___0 ;
  pgp_key_t *p ;
  int tmp___1 ;

  {
  {
#line 704
  buff = (unsigned char *)((void *)0);
#line 705
  pt = (unsigned char)0;
#line 706
  l = (size_t )0;
#line 708
  err = (short)0;
#line 710
  rfp = fopen((char const   */* __restrict  */)ringfile, (char const   */* __restrict  */)"r");
  }
#line 710
  if ((unsigned long )rfp == (unsigned long )((void *)0)) {
    {
#line 712
    perror("fopen");
    }
#line 713
    return;
  }
  {
#line 716
  pos = ftell(rfp);
#line 717
  keypos = ftell(rfp);
  }
  {
#line 719
  while (1) {
    while_continue: /* CIL Label */ ;
#line 719
    if (! err) {
      {
#line 719
      buff = pgp_read_packet(rfp, & l);
      }
#line 719
      if (! ((unsigned long )buff != (unsigned long )((void *)0))) {
#line 719
        goto while_break;
      }
    } else {
#line 719
      goto while_break;
    }
#line 721
    pt = (unsigned char )((int )*(buff + 0) & 63);
#line 723
    if (l < 1UL) {
#line 724
      goto while_continue;
    }
#line 726
    if ((int )pt == 5) {
#line 728
      keypos = pos;
    } else
#line 726
    if ((int )pt == 6) {
#line 728
      keypos = pos;
    } else
#line 730
    if ((int )pt == 13) {
      {
#line 732
      tmp___0 = safe_malloc(l);
#line 732
      tmp = (char *)tmp___0;
#line 734
      memcpy((void */* __restrict  */)tmp, (void const   */* __restrict  */)(buff + 1),
             l - 1UL);
#line 735
      *(tmp + (l - 1UL)) = (char )'\000';
#line 739
      tmp___1 = pgpring_string_matches_hint((char const   *)tmp, hints, nhints);
      }
#line 739
      if (tmp___1) {
        {
#line 743
        fseek(rfp, keypos, 0);
#line 747
        p = pgp_parse_keyblock(rfp);
        }
#line 747
        if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 748
          err = (short)1;
        }
        {
#line 750
        pgpring_dump_keyblock(p);
#line 751
        pgp_free_key(& p);
        }
      }
      {
#line 754
      safe_free((void *)(& tmp));
      }
    }
    {
#line 757
    pos = ftell(rfp);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 760
  fclose(rfp);
  }
#line 762
  return;
}
}
#line 764 "/home/june/repo/benchmarks/collector/temp/signing-party-1.1.5/keyanalyze/pgpring/pgppubring.c"
static void print_userid(char const   *id ) 
{ 


  {
  {
#line 766
  while (1) {
    while_continue: /* CIL Label */ ;
#line 766
    if (id) {
#line 766
      if (! *id) {
#line 766
        goto while_break;
      }
    } else {
#line 766
      goto while_break;
    }
#line 768
    if ((int const   )*id >= 32) {
#line 768
      if ((int const   )*id <= 122) {
#line 768
        if ((int const   )*id != 58) {
          {
#line 769
          putchar((int )*id);
          }
        } else {
          {
#line 771
          printf((char const   */* __restrict  */)"\\x%02x", (int const   )*id);
          }
        }
      } else {
        {
#line 771
        printf((char const   */* __restrict  */)"\\x%02x", (int const   )*id);
        }
      }
    } else {
      {
#line 771
      printf((char const   */* __restrict  */)"\\x%02x", (int const   )*id);
      }
    }
#line 766
    id ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 773
  return;
}
}
#line 775 "/home/june/repo/benchmarks/collector/temp/signing-party-1.1.5/keyanalyze/pgpring/pgppubring.c"
static void pgpring_dump_signatures(pgp_sig_t *sig ) 
{ 


  {
  {
#line 777
  while (1) {
    while_continue: /* CIL Label */ ;
#line 777
    if (! sig) {
#line 777
      goto while_break;
    }
#line 779
    if ((int )sig->sigtype == 16) {
      {
#line 781
      printf((char const   */* __restrict  */)"sig::::%08lX%08lX::::::%X:\n", sig->sid1,
             sig->sid2, (int )sig->sigtype);
      }
    } else
#line 779
    if ((int )sig->sigtype == 17) {
      {
#line 781
      printf((char const   */* __restrict  */)"sig::::%08lX%08lX::::::%X:\n", sig->sid1,
             sig->sid2, (int )sig->sigtype);
      }
    } else
#line 779
    if ((int )sig->sigtype == 18) {
      {
#line 781
      printf((char const   */* __restrict  */)"sig::::%08lX%08lX::::::%X:\n", sig->sid1,
             sig->sid2, (int )sig->sigtype);
      }
    } else
#line 779
    if ((int )sig->sigtype == 19) {
      {
#line 781
      printf((char const   */* __restrict  */)"sig::::%08lX%08lX::::::%X:\n", sig->sid1,
             sig->sid2, (int )sig->sigtype);
      }
    } else
#line 783
    if ((int )sig->sigtype == 32) {
      {
#line 784
      printf((char const   */* __restrict  */)"rev::::%08lX%08lX::::::%X:\n", sig->sid1,
             sig->sid2, (int )sig->sigtype);
      }
    }
#line 777
    sig = sig->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 787
  return;
}
}
#line 790 "/home/june/repo/benchmarks/collector/temp/signing-party-1.1.5/keyanalyze/pgpring/pgppubring.c"
static char gnupg_trustletter(int t ) 
{ 


  {
  {
#line 794
  if (t == 1) {
#line 794
    goto case_1;
  }
#line 795
  if (t == 2) {
#line 795
    goto case_2;
  }
#line 796
  if (t == 3) {
#line 796
    goto case_3;
  }
#line 792
  goto switch_break;
  case_1: /* CIL Label */ 
#line 794
  return ((char )'n');
  case_2: /* CIL Label */ 
#line 795
  return ((char )'m');
  case_3: /* CIL Label */ 
#line 796
  return ((char )'f');
  switch_break: /* CIL Label */ ;
  }
#line 798
  return ((char )'q');
}
}
#line 801 "/home/june/repo/benchmarks/collector/temp/signing-party-1.1.5/keyanalyze/pgpring/pgppubring.c"
static void pgpring_dump_keyblock(pgp_key_t *p ) 
{ 
  pgp_uid_t *uid ;
  short first ;
  struct tm *tp ;
  time_t t ;
  char tmp ;
  char tmp___0 ;

  {
  {
#line 808
  while (1) {
    while_continue: /* CIL Label */ ;
#line 808
    if (! p) {
#line 808
      goto while_break;
    }
#line 810
    first = (short)1;
#line 812
    if (p->flags & (1 << 7)) {
#line 814
      if (p->flags & (1 << 11)) {
        {
#line 815
        printf((char const   */* __restrict  */)"ssb:");
        }
      } else {
        {
#line 817
        printf((char const   */* __restrict  */)"sec:");
        }
      }
    } else
#line 821
    if (p->flags & (1 << 11)) {
      {
#line 822
      printf((char const   */* __restrict  */)"sub:");
      }
    } else {
      {
#line 824
      printf((char const   */* __restrict  */)"pub:");
      }
    }
#line 827
    if (p->flags & (1 << 9)) {
      {
#line 828
      putchar('r');
      }
    }
#line 829
    if (p->flags & (1 << 8)) {
      {
#line 830
      putchar('e');
      }
    }
#line 831
    if (p->flags & (1 << 10)) {
      {
#line 832
      putchar('d');
      }
    }
#line 834
    uid = p->address;
    {
#line 834
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 834
      if (! uid) {
#line 834
        goto while_break___0;
      }
#line 836
      if (! first) {
        {
#line 838
        tmp = gnupg_trustletter((int )uid->trust);
#line 838
        printf((char const   */* __restrict  */)"uid:%c::::::::", (int )tmp);
#line 839
        print_userid((char const   *)uid->addr);
#line 840
        printf((char const   */* __restrict  */)":\n");
        }
      } else {
#line 844
        if (p->flags & (1 << 7)) {
          {
#line 845
          putchar('u');
          }
        } else {
          {
#line 847
          tmp___0 = gnupg_trustletter((int )uid->trust);
#line 847
          putchar((int )tmp___0);
          }
        }
        {
#line 849
        t = p->gen_time;
#line 850
        tp = gmtime((time_t const   *)(& t));
#line 852
        printf((char const   */* __restrict  */)":%d:%d:%s:%04d-%02d-%02d::::", (int )p->keylen,
               p->numalg, p->keyid, 1900 + tp->tm_year, tp->tm_mon + 1, tp->tm_mday);
#line 855
        print_userid((char const   *)uid->addr);
#line 856
        printf((char const   */* __restrict  */)":\n");
        }
      }
#line 859
      if (dump_signatures) {
#line 861
        if (first) {
          {
#line 861
          pgpring_dump_signatures(p->sigs);
          }
        }
        {
#line 862
        pgpring_dump_signatures(uid->sigs);
        }
      }
#line 834
      uid = uid->next;
#line 834
      first = (short)0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 808
    p = p->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 866
  return;
}
}
#line 873 "/home/june/repo/benchmarks/collector/temp/signing-party-1.1.5/keyanalyze/pgpring/pgppubring.c"
char *mutt_gettext(char const   *message ) 
{ 


  {
#line 875
  return ((char *)message);
}
}
#line 828 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) feof)(FILE *__stream ) ;
#line 50 "/home/june/repo/benchmarks/collector/temp/signing-party-1.1.5/keyanalyze/pgpring/pgppacket.h"
void pgp_release_packet(void) ;
#line 34 "/home/june/repo/benchmarks/collector/temp/signing-party-1.1.5/keyanalyze/pgpring/pgppacket.c"
static unsigned char *pbuf  =    (unsigned char *)((void *)0);
#line 35 "/home/june/repo/benchmarks/collector/temp/signing-party-1.1.5/keyanalyze/pgpring/pgppacket.c"
static size_t plen  =    (size_t )0;
#line 37 "/home/june/repo/benchmarks/collector/temp/signing-party-1.1.5/keyanalyze/pgpring/pgppacket.c"
static int read_material(size_t material , size_t *used , FILE *fp ) 
{ 
  unsigned char *p ;
  size_t nplen ;
  void *tmp ;
  size_t tmp___0 ;

  {
#line 39
  if (*used + material >= plen) {
    {
#line 44
    nplen = (*used + material) + 1024UL;
#line 46
    tmp = realloc((void *)pbuf, nplen);
#line 46
    p = (unsigned char *)tmp;
    }
#line 46
    if (! p) {
      {
#line 48
      perror("realloc");
      }
#line 49
      return (-1);
    }
#line 51
    plen = nplen;
#line 52
    pbuf = p;
  }
  {
#line 55
  tmp___0 = fread((void */* __restrict  */)(pbuf + *used), (size_t )1, material, (FILE */* __restrict  */)fp);
  }
#line 55
  if (tmp___0 < material) {
    {
#line 57
    perror("fread");
    }
#line 58
    return (-1);
  }
#line 61
  *used += material;
#line 62
  return (0);
}
}
#line 65 "/home/june/repo/benchmarks/collector/temp/signing-party-1.1.5/keyanalyze/pgpring/pgppacket.c"
unsigned char *pgp_read_packet(FILE *fp , size_t *len ) 
{ 
  size_t used ;
  long startpos ;
  unsigned char ctb ;
  unsigned char b ;
  size_t material ;
  void *tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  int partial ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  unsigned char buf[4] ;
  size_t tmp___4 ;
  int tmp___5 ;
  int bytes ;
  size_t tmp___6 ;
  int i ;
  size_t tmp___7 ;
  int tmp___8 ;

  {
  {
#line 67
  used = (size_t )0;
#line 73
  startpos = ftell(fp);
  }
#line 75
  if (! plen) {
    {
#line 77
    plen = (size_t )1024;
#line 78
    tmp = safe_malloc(plen);
#line 78
    pbuf = (unsigned char *)tmp;
    }
  }
  {
#line 81
  tmp___1 = fread((void */* __restrict  */)(& ctb), (size_t )1, (size_t )1, (FILE */* __restrict  */)fp);
  }
#line 81
  if (tmp___1 < 1UL) {
    {
#line 83
    tmp___0 = feof(fp);
    }
#line 83
    if (! tmp___0) {
      {
#line 84
      perror("fread");
      }
    }
#line 85
    goto bail;
  }
#line 88
  if (! ((int )ctb & 128)) {
#line 90
    goto bail;
  }
#line 93
  if ((int )ctb & 64) {
#line 95
    partial = 0;
#line 96
    *(pbuf + 0) = ctb;
#line 97
    used ++;
    {
#line 99
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 101
      tmp___2 = fread((void */* __restrict  */)(& b), (size_t )1, (size_t )1, (FILE */* __restrict  */)fp);
      }
#line 101
      if (tmp___2 < 1UL) {
        {
#line 103
        perror("fread");
        }
#line 104
        goto bail;
      }
#line 107
      if ((int )b < 192) {
#line 109
        material = (size_t )b;
#line 110
        partial = 0;
      } else
#line 113
      if (192 <= (int )b) {
#line 113
        if ((int )b <= 223) {
          {
#line 115
          material = (size_t )(((int )b - 192) * 256);
#line 116
          tmp___3 = fread((void */* __restrict  */)(& b), (size_t )1, (size_t )1,
                          (FILE */* __restrict  */)fp);
          }
#line 116
          if (tmp___3 < 1UL) {
            {
#line 118
            perror("fread");
            }
#line 119
            goto bail;
          }
#line 121
          material += (size_t )((int )b + 192);
#line 122
          partial = 0;
        } else {
#line 113
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 125
      if ((int )b < 255) {
#line 127
        material = (size_t )(1 << ((int )b & 31));
#line 128
        partial = 1;
      } else {
        {
#line 135
        tmp___4 = fread((void */* __restrict  */)(buf), (size_t )4, (size_t )1, (FILE */* __restrict  */)fp);
        }
#line 135
        if (tmp___4 < 1UL) {
          {
#line 137
          perror("fread");
          }
#line 138
          goto bail;
        }
#line 141
        material = (size_t )((int )buf[0] << 24);
#line 142
        material |= (unsigned long )((int )buf[1] << 16);
#line 143
        material |= (unsigned long )((int )buf[2] << 8);
#line 144
        material |= (unsigned long )buf[3];
#line 145
        partial = 0;
      }
      {
#line 149
      tmp___5 = read_material(material, & used, fp);
      }
#line 149
      if (tmp___5 == -1) {
#line 150
        goto bail;
      }
#line 99
      if (! partial) {
#line 99
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 158
    bytes = 0;
#line 159
    *(pbuf + 0) = (unsigned char )(128 | (((int )ctb >> 2) & 15));
#line 160
    used ++;
    {
#line 164
    if (((int )ctb & 3) == 0) {
#line 164
      goto case_0;
    }
#line 176
    if (((int )ctb & 3) == 1) {
#line 176
      goto case_1;
    }
#line 179
    if (((int )ctb & 3) == 2) {
#line 179
      goto case_2;
    }
#line 201
    goto switch_default;
    case_0: /* CIL Label */ 
    {
#line 166
    tmp___6 = fread((void */* __restrict  */)(& b), (size_t )1, (size_t )1, (FILE */* __restrict  */)fp);
    }
#line 166
    if (tmp___6 < 1UL) {
      {
#line 168
      perror("fread");
      }
#line 169
      goto bail;
    }
#line 172
    material = (size_t )b;
#line 173
    goto switch_break;
    case_1: /* CIL Label */ 
#line 177
    bytes = 2;
    case_2: /* CIL Label */ 
#line 183
    if (! bytes) {
#line 184
      bytes = 4;
    }
#line 186
    material = (size_t )0;
#line 188
    i = 0;
    {
#line 188
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 188
      if (! (i < bytes)) {
#line 188
        goto while_break___0;
      }
      {
#line 190
      tmp___7 = fread((void */* __restrict  */)(& b), (size_t )1, (size_t )1, (FILE */* __restrict  */)fp);
      }
#line 190
      if (tmp___7 < 1UL) {
        {
#line 192
        perror("fread");
        }
#line 193
        goto bail;
      }
#line 196
      material = (material << 8) + (size_t )b;
#line 188
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 198
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 202
    goto bail;
    switch_break: /* CIL Label */ ;
    }
    {
#line 205
    tmp___8 = read_material(material, & used, fp);
    }
#line 205
    if (tmp___8 == -1) {
#line 206
      goto bail;
    }
  }
#line 209
  if (len) {
#line 210
    *len = used;
  }
#line 212
  return (pbuf);
  bail: 
  {
#line 216
  fseek(fp, startpos, 0);
  }
#line 217
  return ((unsigned char *)((void *)0));
}
}
#line 220 "/home/june/repo/benchmarks/collector/temp/signing-party-1.1.5/keyanalyze/pgpring/pgppacket.c"
void pgp_release_packet(void) 
{ 


  {
  {
#line 222
  plen = (size_t )0;
#line 223
  safe_free((void *)(& pbuf));
  }
#line 224
  return;
}
}
#line 37 "/home/june/repo/benchmarks/collector/temp/signing-party-1.1.5/keyanalyze/pgpring/sha1.h"
void SHA1Transform(uint32_t *state , unsigned char const   *buffer ) ;
#line 48 "/home/june/repo/benchmarks/collector/temp/signing-party-1.1.5/keyanalyze/pgpring/sha1.c"
void SHA1Transform(uint32_t *state , unsigned char const   *buffer ) 
{ 
  uint32_t a ;
  uint32_t b ;
  uint32_t c ;
  uint32_t d ;
  uint32_t e ;
  CHAR64LONG16 block[1] ;

  {
  {
#line 57
  memcpy((void */* __restrict  */)(block), (void const   */* __restrict  */)buffer,
         (size_t )64);
#line 67
  a = *(state + 0);
#line 68
  b = *(state + 1);
#line 69
  c = *(state + 2);
#line 70
  d = *(state + 3);
#line 71
  e = *(state + 4);
#line 73
  block[0].l[0] = (((block[0].l[0] << 24) | (block[0].l[0] >> 8)) & 4278255360U) | (((block[0].l[0] << 8) | (block[0].l[0] >> 24)) & 16711935U);
#line 73
  e += ((((b & (c ^ d)) ^ d) + block[0].l[0]) + 1518500249U) + ((a << 5) | (a >> 27));
#line 73
  b = (b << 30) | (b >> 2);
#line 73
  block[0].l[1] = (((block[0].l[1] << 24) | (block[0].l[1] >> 8)) & 4278255360U) | (((block[0].l[1] << 8) | (block[0].l[1] >> 24)) & 16711935U);
#line 73
  d += ((((a & (b ^ c)) ^ c) + block[0].l[1]) + 1518500249U) + ((e << 5) | (e >> 27));
#line 73
  a = (a << 30) | (a >> 2);
#line 73
  block[0].l[2] = (((block[0].l[2] << 24) | (block[0].l[2] >> 8)) & 4278255360U) | (((block[0].l[2] << 8) | (block[0].l[2] >> 24)) & 16711935U);
#line 73
  c += ((((e & (a ^ b)) ^ b) + block[0].l[2]) + 1518500249U) + ((d << 5) | (d >> 27));
#line 73
  e = (e << 30) | (e >> 2);
#line 73
  block[0].l[3] = (((block[0].l[3] << 24) | (block[0].l[3] >> 8)) & 4278255360U) | (((block[0].l[3] << 8) | (block[0].l[3] >> 24)) & 16711935U);
#line 73
  b += ((((d & (e ^ a)) ^ a) + block[0].l[3]) + 1518500249U) + ((c << 5) | (c >> 27));
#line 73
  d = (d << 30) | (d >> 2);
#line 74
  block[0].l[4] = (((block[0].l[4] << 24) | (block[0].l[4] >> 8)) & 4278255360U) | (((block[0].l[4] << 8) | (block[0].l[4] >> 24)) & 16711935U);
#line 74
  a += ((((c & (d ^ e)) ^ e) + block[0].l[4]) + 1518500249U) + ((b << 5) | (b >> 27));
#line 74
  c = (c << 30) | (c >> 2);
#line 74
  block[0].l[5] = (((block[0].l[5] << 24) | (block[0].l[5] >> 8)) & 4278255360U) | (((block[0].l[5] << 8) | (block[0].l[5] >> 24)) & 16711935U);
#line 74
  e += ((((b & (c ^ d)) ^ d) + block[0].l[5]) + 1518500249U) + ((a << 5) | (a >> 27));
#line 74
  b = (b << 30) | (b >> 2);
#line 74
  block[0].l[6] = (((block[0].l[6] << 24) | (block[0].l[6] >> 8)) & 4278255360U) | (((block[0].l[6] << 8) | (block[0].l[6] >> 24)) & 16711935U);
#line 74
  d += ((((a & (b ^ c)) ^ c) + block[0].l[6]) + 1518500249U) + ((e << 5) | (e >> 27));
#line 74
  a = (a << 30) | (a >> 2);
#line 74
  block[0].l[7] = (((block[0].l[7] << 24) | (block[0].l[7] >> 8)) & 4278255360U) | (((block[0].l[7] << 8) | (block[0].l[7] >> 24)) & 16711935U);
#line 74
  c += ((((e & (a ^ b)) ^ b) + block[0].l[7]) + 1518500249U) + ((d << 5) | (d >> 27));
#line 74
  e = (e << 30) | (e >> 2);
#line 75
  block[0].l[8] = (((block[0].l[8] << 24) | (block[0].l[8] >> 8)) & 4278255360U) | (((block[0].l[8] << 8) | (block[0].l[8] >> 24)) & 16711935U);
#line 75
  b += ((((d & (e ^ a)) ^ a) + block[0].l[8]) + 1518500249U) + ((c << 5) | (c >> 27));
#line 75
  d = (d << 30) | (d >> 2);
#line 75
  block[0].l[9] = (((block[0].l[9] << 24) | (block[0].l[9] >> 8)) & 4278255360U) | (((block[0].l[9] << 8) | (block[0].l[9] >> 24)) & 16711935U);
#line 75
  a += ((((c & (d ^ e)) ^ e) + block[0].l[9]) + 1518500249U) + ((b << 5) | (b >> 27));
#line 75
  c = (c << 30) | (c >> 2);
#line 75
  block[0].l[10] = (((block[0].l[10] << 24) | (block[0].l[10] >> 8)) & 4278255360U) | (((block[0].l[10] << 8) | (block[0].l[10] >> 24)) & 16711935U);
#line 75
  e += ((((b & (c ^ d)) ^ d) + block[0].l[10]) + 1518500249U) + ((a << 5) | (a >> 27));
#line 75
  b = (b << 30) | (b >> 2);
#line 75
  block[0].l[11] = (((block[0].l[11] << 24) | (block[0].l[11] >> 8)) & 4278255360U) | (((block[0].l[11] << 8) | (block[0].l[11] >> 24)) & 16711935U);
#line 75
  d += ((((a & (b ^ c)) ^ c) + block[0].l[11]) + 1518500249U) + ((e << 5) | (e >> 27));
#line 75
  a = (a << 30) | (a >> 2);
#line 76
  block[0].l[12] = (((block[0].l[12] << 24) | (block[0].l[12] >> 8)) & 4278255360U) | (((block[0].l[12] << 8) | (block[0].l[12] >> 24)) & 16711935U);
#line 76
  c += ((((e & (a ^ b)) ^ b) + block[0].l[12]) + 1518500249U) + ((d << 5) | (d >> 27));
#line 76
  e = (e << 30) | (e >> 2);
#line 76
  block[0].l[13] = (((block[0].l[13] << 24) | (block[0].l[13] >> 8)) & 4278255360U) | (((block[0].l[13] << 8) | (block[0].l[13] >> 24)) & 16711935U);
#line 76
  b += ((((d & (e ^ a)) ^ a) + block[0].l[13]) + 1518500249U) + ((c << 5) | (c >> 27));
#line 76
  d = (d << 30) | (d >> 2);
#line 76
  block[0].l[14] = (((block[0].l[14] << 24) | (block[0].l[14] >> 8)) & 4278255360U) | (((block[0].l[14] << 8) | (block[0].l[14] >> 24)) & 16711935U);
#line 76
  a += ((((c & (d ^ e)) ^ e) + block[0].l[14]) + 1518500249U) + ((b << 5) | (b >> 27));
#line 76
  c = (c << 30) | (c >> 2);
#line 76
  block[0].l[15] = (((block[0].l[15] << 24) | (block[0].l[15] >> 8)) & 4278255360U) | (((block[0].l[15] << 8) | (block[0].l[15] >> 24)) & 16711935U);
#line 76
  e += ((((b & (c ^ d)) ^ d) + block[0].l[15]) + 1518500249U) + ((a << 5) | (a >> 27));
#line 76
  b = (b << 30) | (b >> 2);
#line 77
  block[0].l[0] = ((((block[0].l[13] ^ block[0].l[8]) ^ block[0].l[2]) ^ block[0].l[0]) << 1) | ((((block[0].l[13] ^ block[0].l[8]) ^ block[0].l[2]) ^ block[0].l[0]) >> 31);
#line 77
  d += ((((a & (b ^ c)) ^ c) + block[0].l[0]) + 1518500249U) + ((e << 5) | (e >> 27));
#line 77
  a = (a << 30) | (a >> 2);
#line 77
  block[0].l[1] = ((((block[0].l[14] ^ block[0].l[9]) ^ block[0].l[3]) ^ block[0].l[1]) << 1) | ((((block[0].l[14] ^ block[0].l[9]) ^ block[0].l[3]) ^ block[0].l[1]) >> 31);
#line 77
  c += ((((e & (a ^ b)) ^ b) + block[0].l[1]) + 1518500249U) + ((d << 5) | (d >> 27));
#line 77
  e = (e << 30) | (e >> 2);
#line 77
  block[0].l[2] = ((((block[0].l[15] ^ block[0].l[10]) ^ block[0].l[4]) ^ block[0].l[2]) << 1) | ((((block[0].l[15] ^ block[0].l[10]) ^ block[0].l[4]) ^ block[0].l[2]) >> 31);
#line 77
  b += ((((d & (e ^ a)) ^ a) + block[0].l[2]) + 1518500249U) + ((c << 5) | (c >> 27));
#line 77
  d = (d << 30) | (d >> 2);
#line 77
  block[0].l[3] = ((((block[0].l[0] ^ block[0].l[11]) ^ block[0].l[5]) ^ block[0].l[3]) << 1) | ((((block[0].l[0] ^ block[0].l[11]) ^ block[0].l[5]) ^ block[0].l[3]) >> 31);
#line 77
  a += ((((c & (d ^ e)) ^ e) + block[0].l[3]) + 1518500249U) + ((b << 5) | (b >> 27));
#line 77
  c = (c << 30) | (c >> 2);
#line 78
  block[0].l[4] = ((((block[0].l[1] ^ block[0].l[12]) ^ block[0].l[6]) ^ block[0].l[4]) << 1) | ((((block[0].l[1] ^ block[0].l[12]) ^ block[0].l[6]) ^ block[0].l[4]) >> 31);
#line 78
  e += ((((b ^ c) ^ d) + block[0].l[4]) + 1859775393U) + ((a << 5) | (a >> 27));
#line 78
  b = (b << 30) | (b >> 2);
#line 78
  block[0].l[5] = ((((block[0].l[2] ^ block[0].l[13]) ^ block[0].l[7]) ^ block[0].l[5]) << 1) | ((((block[0].l[2] ^ block[0].l[13]) ^ block[0].l[7]) ^ block[0].l[5]) >> 31);
#line 78
  d += ((((a ^ b) ^ c) + block[0].l[5]) + 1859775393U) + ((e << 5) | (e >> 27));
#line 78
  a = (a << 30) | (a >> 2);
#line 78
  block[0].l[6] = ((((block[0].l[3] ^ block[0].l[14]) ^ block[0].l[8]) ^ block[0].l[6]) << 1) | ((((block[0].l[3] ^ block[0].l[14]) ^ block[0].l[8]) ^ block[0].l[6]) >> 31);
#line 78
  c += ((((e ^ a) ^ b) + block[0].l[6]) + 1859775393U) + ((d << 5) | (d >> 27));
#line 78
  e = (e << 30) | (e >> 2);
#line 78
  block[0].l[7] = ((((block[0].l[4] ^ block[0].l[15]) ^ block[0].l[9]) ^ block[0].l[7]) << 1) | ((((block[0].l[4] ^ block[0].l[15]) ^ block[0].l[9]) ^ block[0].l[7]) >> 31);
#line 78
  b += ((((d ^ e) ^ a) + block[0].l[7]) + 1859775393U) + ((c << 5) | (c >> 27));
#line 78
  d = (d << 30) | (d >> 2);
#line 79
  block[0].l[8] = ((((block[0].l[5] ^ block[0].l[0]) ^ block[0].l[10]) ^ block[0].l[8]) << 1) | ((((block[0].l[5] ^ block[0].l[0]) ^ block[0].l[10]) ^ block[0].l[8]) >> 31);
#line 79
  a += ((((c ^ d) ^ e) + block[0].l[8]) + 1859775393U) + ((b << 5) | (b >> 27));
#line 79
  c = (c << 30) | (c >> 2);
#line 79
  block[0].l[9] = ((((block[0].l[6] ^ block[0].l[1]) ^ block[0].l[11]) ^ block[0].l[9]) << 1) | ((((block[0].l[6] ^ block[0].l[1]) ^ block[0].l[11]) ^ block[0].l[9]) >> 31);
#line 79
  e += ((((b ^ c) ^ d) + block[0].l[9]) + 1859775393U) + ((a << 5) | (a >> 27));
#line 79
  b = (b << 30) | (b >> 2);
#line 79
  block[0].l[10] = ((((block[0].l[7] ^ block[0].l[2]) ^ block[0].l[12]) ^ block[0].l[10]) << 1) | ((((block[0].l[7] ^ block[0].l[2]) ^ block[0].l[12]) ^ block[0].l[10]) >> 31);
#line 79
  d += ((((a ^ b) ^ c) + block[0].l[10]) + 1859775393U) + ((e << 5) | (e >> 27));
#line 79
  a = (a << 30) | (a >> 2);
#line 79
  block[0].l[11] = ((((block[0].l[8] ^ block[0].l[3]) ^ block[0].l[13]) ^ block[0].l[11]) << 1) | ((((block[0].l[8] ^ block[0].l[3]) ^ block[0].l[13]) ^ block[0].l[11]) >> 31);
#line 79
  c += ((((e ^ a) ^ b) + block[0].l[11]) + 1859775393U) + ((d << 5) | (d >> 27));
#line 79
  e = (e << 30) | (e >> 2);
#line 80
  block[0].l[12] = ((((block[0].l[9] ^ block[0].l[4]) ^ block[0].l[14]) ^ block[0].l[12]) << 1) | ((((block[0].l[9] ^ block[0].l[4]) ^ block[0].l[14]) ^ block[0].l[12]) >> 31);
#line 80
  b += ((((d ^ e) ^ a) + block[0].l[12]) + 1859775393U) + ((c << 5) | (c >> 27));
#line 80
  d = (d << 30) | (d >> 2);
#line 80
  block[0].l[13] = ((((block[0].l[10] ^ block[0].l[5]) ^ block[0].l[15]) ^ block[0].l[13]) << 1) | ((((block[0].l[10] ^ block[0].l[5]) ^ block[0].l[15]) ^ block[0].l[13]) >> 31);
#line 80
  a += ((((c ^ d) ^ e) + block[0].l[13]) + 1859775393U) + ((b << 5) | (b >> 27));
#line 80
  c = (c << 30) | (c >> 2);
#line 80
  block[0].l[14] = ((((block[0].l[11] ^ block[0].l[6]) ^ block[0].l[0]) ^ block[0].l[14]) << 1) | ((((block[0].l[11] ^ block[0].l[6]) ^ block[0].l[0]) ^ block[0].l[14]) >> 31);
#line 80
  e += ((((b ^ c) ^ d) + block[0].l[14]) + 1859775393U) + ((a << 5) | (a >> 27));
#line 80
  b = (b << 30) | (b >> 2);
#line 80
  block[0].l[15] = ((((block[0].l[12] ^ block[0].l[7]) ^ block[0].l[1]) ^ block[0].l[15]) << 1) | ((((block[0].l[12] ^ block[0].l[7]) ^ block[0].l[1]) ^ block[0].l[15]) >> 31);
#line 80
  d += ((((a ^ b) ^ c) + block[0].l[15]) + 1859775393U) + ((e << 5) | (e >> 27));
#line 80
  a = (a << 30) | (a >> 2);
#line 81
  block[0].l[0] = ((((block[0].l[13] ^ block[0].l[8]) ^ block[0].l[2]) ^ block[0].l[0]) << 1) | ((((block[0].l[13] ^ block[0].l[8]) ^ block[0].l[2]) ^ block[0].l[0]) >> 31);
#line 81
  c += ((((e ^ a) ^ b) + block[0].l[0]) + 1859775393U) + ((d << 5) | (d >> 27));
#line 81
  e = (e << 30) | (e >> 2);
#line 81
  block[0].l[1] = ((((block[0].l[14] ^ block[0].l[9]) ^ block[0].l[3]) ^ block[0].l[1]) << 1) | ((((block[0].l[14] ^ block[0].l[9]) ^ block[0].l[3]) ^ block[0].l[1]) >> 31);
#line 81
  b += ((((d ^ e) ^ a) + block[0].l[1]) + 1859775393U) + ((c << 5) | (c >> 27));
#line 81
  d = (d << 30) | (d >> 2);
#line 81
  block[0].l[2] = ((((block[0].l[15] ^ block[0].l[10]) ^ block[0].l[4]) ^ block[0].l[2]) << 1) | ((((block[0].l[15] ^ block[0].l[10]) ^ block[0].l[4]) ^ block[0].l[2]) >> 31);
#line 81
  a += ((((c ^ d) ^ e) + block[0].l[2]) + 1859775393U) + ((b << 5) | (b >> 27));
#line 81
  c = (c << 30) | (c >> 2);
#line 81
  block[0].l[3] = ((((block[0].l[0] ^ block[0].l[11]) ^ block[0].l[5]) ^ block[0].l[3]) << 1) | ((((block[0].l[0] ^ block[0].l[11]) ^ block[0].l[5]) ^ block[0].l[3]) >> 31);
#line 81
  e += ((((b ^ c) ^ d) + block[0].l[3]) + 1859775393U) + ((a << 5) | (a >> 27));
#line 81
  b = (b << 30) | (b >> 2);
#line 82
  block[0].l[4] = ((((block[0].l[1] ^ block[0].l[12]) ^ block[0].l[6]) ^ block[0].l[4]) << 1) | ((((block[0].l[1] ^ block[0].l[12]) ^ block[0].l[6]) ^ block[0].l[4]) >> 31);
#line 82
  d += ((((a ^ b) ^ c) + block[0].l[4]) + 1859775393U) + ((e << 5) | (e >> 27));
#line 82
  a = (a << 30) | (a >> 2);
#line 82
  block[0].l[5] = ((((block[0].l[2] ^ block[0].l[13]) ^ block[0].l[7]) ^ block[0].l[5]) << 1) | ((((block[0].l[2] ^ block[0].l[13]) ^ block[0].l[7]) ^ block[0].l[5]) >> 31);
#line 82
  c += ((((e ^ a) ^ b) + block[0].l[5]) + 1859775393U) + ((d << 5) | (d >> 27));
#line 82
  e = (e << 30) | (e >> 2);
#line 82
  block[0].l[6] = ((((block[0].l[3] ^ block[0].l[14]) ^ block[0].l[8]) ^ block[0].l[6]) << 1) | ((((block[0].l[3] ^ block[0].l[14]) ^ block[0].l[8]) ^ block[0].l[6]) >> 31);
#line 82
  b += ((((d ^ e) ^ a) + block[0].l[6]) + 1859775393U) + ((c << 5) | (c >> 27));
#line 82
  d = (d << 30) | (d >> 2);
#line 82
  block[0].l[7] = ((((block[0].l[4] ^ block[0].l[15]) ^ block[0].l[9]) ^ block[0].l[7]) << 1) | ((((block[0].l[4] ^ block[0].l[15]) ^ block[0].l[9]) ^ block[0].l[7]) >> 31);
#line 82
  a += ((((c ^ d) ^ e) + block[0].l[7]) + 1859775393U) + ((b << 5) | (b >> 27));
#line 82
  c = (c << 30) | (c >> 2);
#line 83
  block[0].l[8] = ((((block[0].l[5] ^ block[0].l[0]) ^ block[0].l[10]) ^ block[0].l[8]) << 1) | ((((block[0].l[5] ^ block[0].l[0]) ^ block[0].l[10]) ^ block[0].l[8]) >> 31);
#line 83
  e += (((((b | c) & d) | (b & c)) + block[0].l[8]) + 2400959708U) + ((a << 5) | (a >> 27));
#line 83
  b = (b << 30) | (b >> 2);
#line 83
  block[0].l[9] = ((((block[0].l[6] ^ block[0].l[1]) ^ block[0].l[11]) ^ block[0].l[9]) << 1) | ((((block[0].l[6] ^ block[0].l[1]) ^ block[0].l[11]) ^ block[0].l[9]) >> 31);
#line 83
  d += (((((a | b) & c) | (a & b)) + block[0].l[9]) + 2400959708U) + ((e << 5) | (e >> 27));
#line 83
  a = (a << 30) | (a >> 2);
#line 83
  block[0].l[10] = ((((block[0].l[7] ^ block[0].l[2]) ^ block[0].l[12]) ^ block[0].l[10]) << 1) | ((((block[0].l[7] ^ block[0].l[2]) ^ block[0].l[12]) ^ block[0].l[10]) >> 31);
#line 83
  c += (((((e | a) & b) | (e & a)) + block[0].l[10]) + 2400959708U) + ((d << 5) | (d >> 27));
#line 83
  e = (e << 30) | (e >> 2);
#line 83
  block[0].l[11] = ((((block[0].l[8] ^ block[0].l[3]) ^ block[0].l[13]) ^ block[0].l[11]) << 1) | ((((block[0].l[8] ^ block[0].l[3]) ^ block[0].l[13]) ^ block[0].l[11]) >> 31);
#line 83
  b += (((((d | e) & a) | (d & e)) + block[0].l[11]) + 2400959708U) + ((c << 5) | (c >> 27));
#line 83
  d = (d << 30) | (d >> 2);
#line 84
  block[0].l[12] = ((((block[0].l[9] ^ block[0].l[4]) ^ block[0].l[14]) ^ block[0].l[12]) << 1) | ((((block[0].l[9] ^ block[0].l[4]) ^ block[0].l[14]) ^ block[0].l[12]) >> 31);
#line 84
  a += (((((c | d) & e) | (c & d)) + block[0].l[12]) + 2400959708U) + ((b << 5) | (b >> 27));
#line 84
  c = (c << 30) | (c >> 2);
#line 84
  block[0].l[13] = ((((block[0].l[10] ^ block[0].l[5]) ^ block[0].l[15]) ^ block[0].l[13]) << 1) | ((((block[0].l[10] ^ block[0].l[5]) ^ block[0].l[15]) ^ block[0].l[13]) >> 31);
#line 84
  e += (((((b | c) & d) | (b & c)) + block[0].l[13]) + 2400959708U) + ((a << 5) | (a >> 27));
#line 84
  b = (b << 30) | (b >> 2);
#line 84
  block[0].l[14] = ((((block[0].l[11] ^ block[0].l[6]) ^ block[0].l[0]) ^ block[0].l[14]) << 1) | ((((block[0].l[11] ^ block[0].l[6]) ^ block[0].l[0]) ^ block[0].l[14]) >> 31);
#line 84
  d += (((((a | b) & c) | (a & b)) + block[0].l[14]) + 2400959708U) + ((e << 5) | (e >> 27));
#line 84
  a = (a << 30) | (a >> 2);
#line 84
  block[0].l[15] = ((((block[0].l[12] ^ block[0].l[7]) ^ block[0].l[1]) ^ block[0].l[15]) << 1) | ((((block[0].l[12] ^ block[0].l[7]) ^ block[0].l[1]) ^ block[0].l[15]) >> 31);
#line 84
  c += (((((e | a) & b) | (e & a)) + block[0].l[15]) + 2400959708U) + ((d << 5) | (d >> 27));
#line 84
  e = (e << 30) | (e >> 2);
#line 85
  block[0].l[0] = ((((block[0].l[13] ^ block[0].l[8]) ^ block[0].l[2]) ^ block[0].l[0]) << 1) | ((((block[0].l[13] ^ block[0].l[8]) ^ block[0].l[2]) ^ block[0].l[0]) >> 31);
#line 85
  b += (((((d | e) & a) | (d & e)) + block[0].l[0]) + 2400959708U) + ((c << 5) | (c >> 27));
#line 85
  d = (d << 30) | (d >> 2);
#line 85
  block[0].l[1] = ((((block[0].l[14] ^ block[0].l[9]) ^ block[0].l[3]) ^ block[0].l[1]) << 1) | ((((block[0].l[14] ^ block[0].l[9]) ^ block[0].l[3]) ^ block[0].l[1]) >> 31);
#line 85
  a += (((((c | d) & e) | (c & d)) + block[0].l[1]) + 2400959708U) + ((b << 5) | (b >> 27));
#line 85
  c = (c << 30) | (c >> 2);
#line 85
  block[0].l[2] = ((((block[0].l[15] ^ block[0].l[10]) ^ block[0].l[4]) ^ block[0].l[2]) << 1) | ((((block[0].l[15] ^ block[0].l[10]) ^ block[0].l[4]) ^ block[0].l[2]) >> 31);
#line 85
  e += (((((b | c) & d) | (b & c)) + block[0].l[2]) + 2400959708U) + ((a << 5) | (a >> 27));
#line 85
  b = (b << 30) | (b >> 2);
#line 85
  block[0].l[3] = ((((block[0].l[0] ^ block[0].l[11]) ^ block[0].l[5]) ^ block[0].l[3]) << 1) | ((((block[0].l[0] ^ block[0].l[11]) ^ block[0].l[5]) ^ block[0].l[3]) >> 31);
#line 85
  d += (((((a | b) & c) | (a & b)) + block[0].l[3]) + 2400959708U) + ((e << 5) | (e >> 27));
#line 85
  a = (a << 30) | (a >> 2);
#line 86
  block[0].l[4] = ((((block[0].l[1] ^ block[0].l[12]) ^ block[0].l[6]) ^ block[0].l[4]) << 1) | ((((block[0].l[1] ^ block[0].l[12]) ^ block[0].l[6]) ^ block[0].l[4]) >> 31);
#line 86
  c += (((((e | a) & b) | (e & a)) + block[0].l[4]) + 2400959708U) + ((d << 5) | (d >> 27));
#line 86
  e = (e << 30) | (e >> 2);
#line 86
  block[0].l[5] = ((((block[0].l[2] ^ block[0].l[13]) ^ block[0].l[7]) ^ block[0].l[5]) << 1) | ((((block[0].l[2] ^ block[0].l[13]) ^ block[0].l[7]) ^ block[0].l[5]) >> 31);
#line 86
  b += (((((d | e) & a) | (d & e)) + block[0].l[5]) + 2400959708U) + ((c << 5) | (c >> 27));
#line 86
  d = (d << 30) | (d >> 2);
#line 86
  block[0].l[6] = ((((block[0].l[3] ^ block[0].l[14]) ^ block[0].l[8]) ^ block[0].l[6]) << 1) | ((((block[0].l[3] ^ block[0].l[14]) ^ block[0].l[8]) ^ block[0].l[6]) >> 31);
#line 86
  a += (((((c | d) & e) | (c & d)) + block[0].l[6]) + 2400959708U) + ((b << 5) | (b >> 27));
#line 86
  c = (c << 30) | (c >> 2);
#line 86
  block[0].l[7] = ((((block[0].l[4] ^ block[0].l[15]) ^ block[0].l[9]) ^ block[0].l[7]) << 1) | ((((block[0].l[4] ^ block[0].l[15]) ^ block[0].l[9]) ^ block[0].l[7]) >> 31);
#line 86
  e += (((((b | c) & d) | (b & c)) + block[0].l[7]) + 2400959708U) + ((a << 5) | (a >> 27));
#line 86
  b = (b << 30) | (b >> 2);
#line 87
  block[0].l[8] = ((((block[0].l[5] ^ block[0].l[0]) ^ block[0].l[10]) ^ block[0].l[8]) << 1) | ((((block[0].l[5] ^ block[0].l[0]) ^ block[0].l[10]) ^ block[0].l[8]) >> 31);
#line 87
  d += (((((a | b) & c) | (a & b)) + block[0].l[8]) + 2400959708U) + ((e << 5) | (e >> 27));
#line 87
  a = (a << 30) | (a >> 2);
#line 87
  block[0].l[9] = ((((block[0].l[6] ^ block[0].l[1]) ^ block[0].l[11]) ^ block[0].l[9]) << 1) | ((((block[0].l[6] ^ block[0].l[1]) ^ block[0].l[11]) ^ block[0].l[9]) >> 31);
#line 87
  c += (((((e | a) & b) | (e & a)) + block[0].l[9]) + 2400959708U) + ((d << 5) | (d >> 27));
#line 87
  e = (e << 30) | (e >> 2);
#line 87
  block[0].l[10] = ((((block[0].l[7] ^ block[0].l[2]) ^ block[0].l[12]) ^ block[0].l[10]) << 1) | ((((block[0].l[7] ^ block[0].l[2]) ^ block[0].l[12]) ^ block[0].l[10]) >> 31);
#line 87
  b += (((((d | e) & a) | (d & e)) + block[0].l[10]) + 2400959708U) + ((c << 5) | (c >> 27));
#line 87
  d = (d << 30) | (d >> 2);
#line 87
  block[0].l[11] = ((((block[0].l[8] ^ block[0].l[3]) ^ block[0].l[13]) ^ block[0].l[11]) << 1) | ((((block[0].l[8] ^ block[0].l[3]) ^ block[0].l[13]) ^ block[0].l[11]) >> 31);
#line 87
  a += (((((c | d) & e) | (c & d)) + block[0].l[11]) + 2400959708U) + ((b << 5) | (b >> 27));
#line 87
  c = (c << 30) | (c >> 2);
#line 88
  block[0].l[12] = ((((block[0].l[9] ^ block[0].l[4]) ^ block[0].l[14]) ^ block[0].l[12]) << 1) | ((((block[0].l[9] ^ block[0].l[4]) ^ block[0].l[14]) ^ block[0].l[12]) >> 31);
#line 88
  e += ((((b ^ c) ^ d) + block[0].l[12]) + 3395469782U) + ((a << 5) | (a >> 27));
#line 88
  b = (b << 30) | (b >> 2);
#line 88
  block[0].l[13] = ((((block[0].l[10] ^ block[0].l[5]) ^ block[0].l[15]) ^ block[0].l[13]) << 1) | ((((block[0].l[10] ^ block[0].l[5]) ^ block[0].l[15]) ^ block[0].l[13]) >> 31);
#line 88
  d += ((((a ^ b) ^ c) + block[0].l[13]) + 3395469782U) + ((e << 5) | (e >> 27));
#line 88
  a = (a << 30) | (a >> 2);
#line 88
  block[0].l[14] = ((((block[0].l[11] ^ block[0].l[6]) ^ block[0].l[0]) ^ block[0].l[14]) << 1) | ((((block[0].l[11] ^ block[0].l[6]) ^ block[0].l[0]) ^ block[0].l[14]) >> 31);
#line 88
  c += ((((e ^ a) ^ b) + block[0].l[14]) + 3395469782U) + ((d << 5) | (d >> 27));
#line 88
  e = (e << 30) | (e >> 2);
#line 88
  block[0].l[15] = ((((block[0].l[12] ^ block[0].l[7]) ^ block[0].l[1]) ^ block[0].l[15]) << 1) | ((((block[0].l[12] ^ block[0].l[7]) ^ block[0].l[1]) ^ block[0].l[15]) >> 31);
#line 88
  b += ((((d ^ e) ^ a) + block[0].l[15]) + 3395469782U) + ((c << 5) | (c >> 27));
#line 88
  d = (d << 30) | (d >> 2);
#line 89
  block[0].l[0] = ((((block[0].l[13] ^ block[0].l[8]) ^ block[0].l[2]) ^ block[0].l[0]) << 1) | ((((block[0].l[13] ^ block[0].l[8]) ^ block[0].l[2]) ^ block[0].l[0]) >> 31);
#line 89
  a += ((((c ^ d) ^ e) + block[0].l[0]) + 3395469782U) + ((b << 5) | (b >> 27));
#line 89
  c = (c << 30) | (c >> 2);
#line 89
  block[0].l[1] = ((((block[0].l[14] ^ block[0].l[9]) ^ block[0].l[3]) ^ block[0].l[1]) << 1) | ((((block[0].l[14] ^ block[0].l[9]) ^ block[0].l[3]) ^ block[0].l[1]) >> 31);
#line 89
  e += ((((b ^ c) ^ d) + block[0].l[1]) + 3395469782U) + ((a << 5) | (a >> 27));
#line 89
  b = (b << 30) | (b >> 2);
#line 89
  block[0].l[2] = ((((block[0].l[15] ^ block[0].l[10]) ^ block[0].l[4]) ^ block[0].l[2]) << 1) | ((((block[0].l[15] ^ block[0].l[10]) ^ block[0].l[4]) ^ block[0].l[2]) >> 31);
#line 89
  d += ((((a ^ b) ^ c) + block[0].l[2]) + 3395469782U) + ((e << 5) | (e >> 27));
#line 89
  a = (a << 30) | (a >> 2);
#line 89
  block[0].l[3] = ((((block[0].l[0] ^ block[0].l[11]) ^ block[0].l[5]) ^ block[0].l[3]) << 1) | ((((block[0].l[0] ^ block[0].l[11]) ^ block[0].l[5]) ^ block[0].l[3]) >> 31);
#line 89
  c += ((((e ^ a) ^ b) + block[0].l[3]) + 3395469782U) + ((d << 5) | (d >> 27));
#line 89
  e = (e << 30) | (e >> 2);
#line 90
  block[0].l[4] = ((((block[0].l[1] ^ block[0].l[12]) ^ block[0].l[6]) ^ block[0].l[4]) << 1) | ((((block[0].l[1] ^ block[0].l[12]) ^ block[0].l[6]) ^ block[0].l[4]) >> 31);
#line 90
  b += ((((d ^ e) ^ a) + block[0].l[4]) + 3395469782U) + ((c << 5) | (c >> 27));
#line 90
  d = (d << 30) | (d >> 2);
#line 90
  block[0].l[5] = ((((block[0].l[2] ^ block[0].l[13]) ^ block[0].l[7]) ^ block[0].l[5]) << 1) | ((((block[0].l[2] ^ block[0].l[13]) ^ block[0].l[7]) ^ block[0].l[5]) >> 31);
#line 90
  a += ((((c ^ d) ^ e) + block[0].l[5]) + 3395469782U) + ((b << 5) | (b >> 27));
#line 90
  c = (c << 30) | (c >> 2);
#line 90
  block[0].l[6] = ((((block[0].l[3] ^ block[0].l[14]) ^ block[0].l[8]) ^ block[0].l[6]) << 1) | ((((block[0].l[3] ^ block[0].l[14]) ^ block[0].l[8]) ^ block[0].l[6]) >> 31);
#line 90
  e += ((((b ^ c) ^ d) + block[0].l[6]) + 3395469782U) + ((a << 5) | (a >> 27));
#line 90
  b = (b << 30) | (b >> 2);
#line 90
  block[0].l[7] = ((((block[0].l[4] ^ block[0].l[15]) ^ block[0].l[9]) ^ block[0].l[7]) << 1) | ((((block[0].l[4] ^ block[0].l[15]) ^ block[0].l[9]) ^ block[0].l[7]) >> 31);
#line 90
  d += ((((a ^ b) ^ c) + block[0].l[7]) + 3395469782U) + ((e << 5) | (e >> 27));
#line 90
  a = (a << 30) | (a >> 2);
#line 91
  block[0].l[8] = ((((block[0].l[5] ^ block[0].l[0]) ^ block[0].l[10]) ^ block[0].l[8]) << 1) | ((((block[0].l[5] ^ block[0].l[0]) ^ block[0].l[10]) ^ block[0].l[8]) >> 31);
#line 91
  c += ((((e ^ a) ^ b) + block[0].l[8]) + 3395469782U) + ((d << 5) | (d >> 27));
#line 91
  e = (e << 30) | (e >> 2);
#line 91
  block[0].l[9] = ((((block[0].l[6] ^ block[0].l[1]) ^ block[0].l[11]) ^ block[0].l[9]) << 1) | ((((block[0].l[6] ^ block[0].l[1]) ^ block[0].l[11]) ^ block[0].l[9]) >> 31);
#line 91
  b += ((((d ^ e) ^ a) + block[0].l[9]) + 3395469782U) + ((c << 5) | (c >> 27));
#line 91
  d = (d << 30) | (d >> 2);
#line 91
  block[0].l[10] = ((((block[0].l[7] ^ block[0].l[2]) ^ block[0].l[12]) ^ block[0].l[10]) << 1) | ((((block[0].l[7] ^ block[0].l[2]) ^ block[0].l[12]) ^ block[0].l[10]) >> 31);
#line 91
  a += ((((c ^ d) ^ e) + block[0].l[10]) + 3395469782U) + ((b << 5) | (b >> 27));
#line 91
  c = (c << 30) | (c >> 2);
#line 91
  block[0].l[11] = ((((block[0].l[8] ^ block[0].l[3]) ^ block[0].l[13]) ^ block[0].l[11]) << 1) | ((((block[0].l[8] ^ block[0].l[3]) ^ block[0].l[13]) ^ block[0].l[11]) >> 31);
#line 91
  e += ((((b ^ c) ^ d) + block[0].l[11]) + 3395469782U) + ((a << 5) | (a >> 27));
#line 91
  b = (b << 30) | (b >> 2);
#line 92
  block[0].l[12] = ((((block[0].l[9] ^ block[0].l[4]) ^ block[0].l[14]) ^ block[0].l[12]) << 1) | ((((block[0].l[9] ^ block[0].l[4]) ^ block[0].l[14]) ^ block[0].l[12]) >> 31);
#line 92
  d += ((((a ^ b) ^ c) + block[0].l[12]) + 3395469782U) + ((e << 5) | (e >> 27));
#line 92
  a = (a << 30) | (a >> 2);
#line 92
  block[0].l[13] = ((((block[0].l[10] ^ block[0].l[5]) ^ block[0].l[15]) ^ block[0].l[13]) << 1) | ((((block[0].l[10] ^ block[0].l[5]) ^ block[0].l[15]) ^ block[0].l[13]) >> 31);
#line 92
  c += ((((e ^ a) ^ b) + block[0].l[13]) + 3395469782U) + ((d << 5) | (d >> 27));
#line 92
  e = (e << 30) | (e >> 2);
#line 92
  block[0].l[14] = ((((block[0].l[11] ^ block[0].l[6]) ^ block[0].l[0]) ^ block[0].l[14]) << 1) | ((((block[0].l[11] ^ block[0].l[6]) ^ block[0].l[0]) ^ block[0].l[14]) >> 31);
#line 92
  b += ((((d ^ e) ^ a) + block[0].l[14]) + 3395469782U) + ((c << 5) | (c >> 27));
#line 92
  d = (d << 30) | (d >> 2);
#line 92
  block[0].l[15] = ((((block[0].l[12] ^ block[0].l[7]) ^ block[0].l[1]) ^ block[0].l[15]) << 1) | ((((block[0].l[12] ^ block[0].l[7]) ^ block[0].l[1]) ^ block[0].l[15]) >> 31);
#line 92
  a += ((((c ^ d) ^ e) + block[0].l[15]) + 3395469782U) + ((b << 5) | (b >> 27));
#line 92
  c = (c << 30) | (c >> 2);
#line 94
  *(state + 0) += a;
#line 95
  *(state + 1) += b;
#line 96
  *(state + 2) += c;
#line 97
  *(state + 3) += d;
#line 98
  *(state + 4) += e;
#line 100
  e = (uint32_t )0;
#line 100
  d = e;
#line 100
  c = d;
#line 100
  b = c;
#line 100
  a = b;
#line 102
  memset((void *)(block), '\000', sizeof(block));
  }
#line 104
  return;
}
}
#line 109 "/home/june/repo/benchmarks/collector/temp/signing-party-1.1.5/keyanalyze/pgpring/sha1.c"
void SHA1Init(SHA1_CTX *context ) 
{ 
  uint32_t tmp ;

  {
#line 112
  context->state[0] = (uint32_t )1732584193;
#line 113
  context->state[1] = 4023233417U;
#line 114
  context->state[2] = 2562383102U;
#line 115
  context->state[3] = (uint32_t )271733878;
#line 116
  context->state[4] = 3285377520U;
#line 117
  tmp = (uint32_t )0;
#line 117
  context->count[1] = tmp;
#line 117
  context->count[0] = tmp;
#line 118
  return;
}
}
#line 123 "/home/june/repo/benchmarks/collector/temp/signing-party-1.1.5/keyanalyze/pgpring/sha1.c"
void SHA1Update(SHA1_CTX *context , unsigned char const   *data , uint32_t len ) 
{ 
  uint32_t i ;
  uint32_t j ;
  uint32_t tmp ;

  {
#line 128
  j = context->count[0];
#line 129
  tmp = context->count[0] + (len << 3);
#line 129
  context->count[0] = tmp;
#line 129
  if (tmp < j) {
#line 130
    (context->count[1]) ++;
  }
#line 131
  context->count[1] += len >> 29;
#line 132
  j = (j >> 3) & 63U;
#line 133
  if (j + len > 63U) {
    {
#line 134
    i = 64U - j;
#line 134
    memcpy((void */* __restrict  */)(& context->buffer[j]), (void const   */* __restrict  */)data,
           (size_t )i);
#line 135
    SHA1Transform((uint32_t *)(context->state), (unsigned char const   *)(context->buffer));
    }
    {
#line 136
    while (1) {
      while_continue: /* CIL Label */ ;
#line 136
      if (! (i + 63U < len)) {
#line 136
        goto while_break;
      }
      {
#line 137
      SHA1Transform((uint32_t *)(context->state), (unsigned char const   *)(data + i));
#line 136
      i += 64U;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 139
    j = (uint32_t )0;
  } else {
#line 141
    i = (uint32_t )0;
  }
  {
#line 142
  memcpy((void */* __restrict  */)(& context->buffer[j]), (void const   */* __restrict  */)(data + i),
         (size_t )(len - i));
  }
#line 143
  return;
}
}
#line 148 "/home/june/repo/benchmarks/collector/temp/signing-party-1.1.5/keyanalyze/pgpring/sha1.c"
void SHA1Final(unsigned char *digest , SHA1_CTX *context ) 
{ 
  unsigned int i ;
  unsigned char finalcount[8] ;
  unsigned char c ;
  int tmp ;

  {
#line 171
  i = 0U;
  {
#line 171
  while (1) {
    while_continue: /* CIL Label */ ;
#line 171
    if (! (i < 8U)) {
#line 171
      goto while_break;
    }
#line 172
    if (i >= 4U) {
#line 172
      tmp = 0;
    } else {
#line 172
      tmp = 1;
    }
#line 172
    finalcount[i] = (unsigned char )((context->count[tmp] >> (3U - (i & 3U)) * 8U) & 255U);
#line 171
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 176
  c = (unsigned char)128;
#line 177
  SHA1Update(context, (unsigned char const   *)(& c), (uint32_t )1);
  }
  {
#line 178
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 178
    if (! ((context->count[0] & 504U) != 448U)) {
#line 178
      goto while_break___0;
    }
    {
#line 179
    c = (unsigned char)0;
#line 180
    SHA1Update(context, (unsigned char const   *)(& c), (uint32_t )1);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 182
  SHA1Update(context, (unsigned char const   *)(finalcount), (uint32_t )8);
#line 183
  i = 0U;
  }
  {
#line 183
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 183
    if (! (i < 20U)) {
#line 183
      goto while_break___1;
    }
#line 184
    *(digest + i) = (unsigned char )((context->state[i >> 2] >> (3U - (i & 3U)) * 8U) & 255U);
#line 183
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 188
  memset((void *)context, '\000', sizeof(*context));
#line 189
  memset((void *)(& finalcount), '\000', sizeof(finalcount));
  }
#line 190
  return;
}
}
/* compiler builtin: 
   void *__builtin_alloca(unsigned long  ) ;  */
#line 347 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) setlinebuf)(FILE *__stream ) ;
#line 50 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memmove)(void *__dest ,
                                                                                                  void const   *__src ,
                                                                                                  size_t __n ) ;
#line 69
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) memcmp)(void const   *__s1 ,
                                                                                               void const   *__s2 ,
                                                                                               size_t __n )  __attribute__((__pure__)) ;
#line 96
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memchr)(void const   *__s ,
                                                                                               int __c ,
                                                                                               size_t __n )  __attribute__((__pure__)) ;
#line 578 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) putenv)(char *__string ) ;
#line 102 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) __sighandler_t ( __attribute__((__leaf__)) signal)(int __sig ,
                                                                                        void (*__handler)(int  ) ) ;
#line 66 "/usr/include/termios.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tcgetattr)(int __fd ,
                                                                                struct termios *__termios_p ) ;
#line 70
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tcsetattr)(int __fd ,
                                                                                int __optional_actions ,
                                                                                struct termios  const  *__termios_p ) ;
#line 360 "/usr/include/unistd.h"
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 366
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 417
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) pipe)(int *__pipedes ) ;
#line 534
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) dup2)(int __fd ,
                                                                           int __fd2 ) ;
#line 578
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) execvp)(char const   *__file ,
                                                                                               char * const  *__argv ) ;
#line 628
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) getpid)(void) ;
#line 756
extern  __attribute__((__nothrow__)) __pid_t fork(void) ;
#line 102 "/usr/include/x86_64-linux-gnu/sys/wait.h"
extern __pid_t wait(union wait *__stat_loc ) ;
#line 42 "/home/june/repo/benchmarks/collector/temp/signing-party-1.1.5/gpgwrap/src/gpgwrap.c"
static char program_name[8]  = 
#line 42 "/home/june/repo/benchmarks/collector/temp/signing-party-1.1.5/gpgwrap/src/gpgwrap.c"
  {      (char )'g',      (char )'p',      (char )'g',      (char )'w', 
        (char )'r',      (char )'a',      (char )'p',      (char )'\000'};
#line 43 "/home/june/repo/benchmarks/collector/temp/signing-party-1.1.5/gpgwrap/src/gpgwrap.c"
static char environ_name[19]  = 
#line 43
  {      (char )'G',      (char )'P',      (char )'G',      (char )'W', 
        (char )'R',      (char )'A',      (char )'P',      (char )'_', 
        (char )'P',      (char )'A',      (char )'S',      (char )'S', 
        (char )'P',      (char )'H',      (char )'R',      (char )'A', 
        (char )'S',      (char )'E',      (char )'\000'};
#line 44 "/home/june/repo/benchmarks/collector/temp/signing-party-1.1.5/gpgwrap/src/gpgwrap.c"
static int mode  =    0;
#line 45 "/home/june/repo/benchmarks/collector/temp/signing-party-1.1.5/gpgwrap/src/gpgwrap.c"
static int verbose  =    0;
#line 46 "/home/june/repo/benchmarks/collector/temp/signing-party-1.1.5/gpgwrap/src/gpgwrap.c"
static int interactive  =    0;
#line 47 "/home/june/repo/benchmarks/collector/temp/signing-party-1.1.5/gpgwrap/src/gpgwrap.c"
static int ask_twice  =    0;
#line 48 "/home/june/repo/benchmarks/collector/temp/signing-party-1.1.5/gpgwrap/src/gpgwrap.c"
static int check_exit_code  =    0;
#line 49 "/home/june/repo/benchmarks/collector/temp/signing-party-1.1.5/gpgwrap/src/gpgwrap.c"
static char *calling_path  =    (char *)((void *)0);
#line 50 "/home/june/repo/benchmarks/collector/temp/signing-party-1.1.5/gpgwrap/src/gpgwrap.c"
static char *environ_var  =    (char *)((void *)0);
#line 51 "/home/june/repo/benchmarks/collector/temp/signing-party-1.1.5/gpgwrap/src/gpgwrap.c"
static char *passphrase_file  =    (char *)((void *)0);
#line 52 "/home/june/repo/benchmarks/collector/temp/signing-party-1.1.5/gpgwrap/src/gpgwrap.c"
static char *option_name  =    (char *)"--passphrase-fd";
#line 53 "/home/june/repo/benchmarks/collector/temp/signing-party-1.1.5/gpgwrap/src/gpgwrap.c"
static char *files[1024]  ;
#line 54 "/home/june/repo/benchmarks/collector/temp/signing-party-1.1.5/gpgwrap/src/gpgwrap.c"
static int nfiles  =    0;
#line 55 "/home/june/repo/benchmarks/collector/temp/signing-party-1.1.5/gpgwrap/src/gpgwrap.c"
static char **gpg_cmd  =    (char **)((void *)0);
#line 62 "/home/june/repo/benchmarks/collector/temp/signing-party-1.1.5/gpgwrap/src/gpgwrap.c"
static void do_perror(void) 
{ 


  {
  {
#line 67
  perror((char const   *)(program_name));
#line 68
  exit(1);
  }
}
}
#line 105 "/home/june/repo/benchmarks/collector/temp/signing-party-1.1.5/gpgwrap/src/gpgwrap.c"
static void do_error_oom(void) 
{ 


  {
  {
#line 110
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 110
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: ",
            program_name);
#line 110
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"could not allocate memory");
#line 110
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
#line 110
    exit(1);
    }
#line 110
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 111
  return;
}
}
#line 118 "/home/june/repo/benchmarks/collector/temp/signing-party-1.1.5/gpgwrap/src/gpgwrap.c"
static void do_error_too_long(void) 
{ 


  {
  {
#line 123
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 123
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: ",
            program_name);
#line 123
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"passphrase too long");
#line 123
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
#line 123
    exit(1);
    }
#line 123
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 124
  return;
}
}
#line 180 "/home/june/repo/benchmarks/collector/temp/signing-party-1.1.5/gpgwrap/src/gpgwrap.c"
static int do_snprintf2(int len , int max ) 
{ 


  {
#line 186
  if (len == -1) {
#line 186
    goto _L;
  } else
#line 186
  if (len >= max) {
    _L: /* CIL Label */ 
    {
#line 186
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 186
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: ",
              program_name);
#line 186
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"do_snprintf() size exceeded");
#line 186
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
#line 186
      exit(1);
      }
#line 186
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 187
  return (len);
}
}
#line 195 "/home/june/repo/benchmarks/collector/temp/signing-party-1.1.5/gpgwrap/src/gpgwrap.c"
static int mangle_passphrase(char *buffer , int size , char *mbuffer , int msize ) 
{ 
  char c ;
  int i ;
  int j ;
  int c1 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 211
  j = 0;
#line 211
  i = j;
#line 211
  msize --;
  {
#line 211
  while (1) {
    while_continue: /* CIL Label */ ;
#line 211
    if (! (i < size)) {
#line 211
      goto while_break;
    }
#line 213
    c = *(buffer + i);
#line 214
    if (j >= msize) {
#line 214
      goto error;
    }
#line 215
    if ((int )c < 43) {
#line 215
      goto _L;
    } else
#line 215
    if ((int )c > 59) {
#line 215
      if ((int )c < 65) {
#line 215
        goto _L;
      } else {
#line 215
        goto _L___2;
      }
    } else
    _L___2: /* CIL Label */ 
#line 215
    if ((int )c > 90) {
#line 215
      if ((int )c != 95) {
#line 215
        if ((int )c < 97) {
#line 215
          goto _L;
        } else {
#line 215
          goto _L___1;
        }
      } else {
#line 215
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */ 
#line 215
    if ((int )c > 122) {
#line 215
      if ((int )c != 126) {
        _L: /* CIL Label */ 
#line 219
        c1 = (int )((unsigned char )c);
#line 220
        if (j >= msize - 4) {
#line 220
          goto error;
        }
#line 221
        tmp = j;
#line 221
        j ++;
#line 221
        *(mbuffer + tmp) = (char )'\\';
#line 222
        tmp___0 = j;
#line 222
        j ++;
#line 222
        *(mbuffer + tmp___0) = (char )(48 + (c1 >> 6));
#line 223
        tmp___1 = j;
#line 223
        j ++;
#line 223
        *(mbuffer + tmp___1) = (char )(48 + ((c1 >> 3) & 7));
#line 224
        tmp___2 = j;
#line 224
        j ++;
#line 224
        *(mbuffer + tmp___2) = (char )(48 + (c1 & 7));
      } else {
#line 226
        tmp___3 = j;
#line 226
        j ++;
#line 226
        *(mbuffer + tmp___3) = c;
      }
    } else {
#line 226
      tmp___3 = j;
#line 226
      j ++;
#line 226
      *(mbuffer + tmp___3) = c;
    }
#line 211
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 228
  *(mbuffer + j) = (char )'\000';
#line 229
  return (j);
  error: 
  {
#line 231
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 231
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: ",
            program_name);
#line 231
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"could not mangle passphrase");
#line 231
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
#line 231
    exit(1);
    }
#line 231
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 232
  return (0);
}
}
#line 239 "/home/june/repo/benchmarks/collector/temp/signing-party-1.1.5/gpgwrap/src/gpgwrap.c"
static int unmangle_passphrase(char *buffer , int size ) 
{ 
  char c ;
  int i ;
  int j ;
  int c1 ;
  int c2 ;
  int c3 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 250
  j = 0;
#line 250
  i = j;
  {
#line 250
  while (1) {
    while_continue: /* CIL Label */ ;
#line 250
    if (! (j < size)) {
#line 250
      goto while_break;
    }
#line 252
    tmp = j;
#line 252
    j ++;
#line 252
    c = *(buffer + tmp);
#line 253
    if ((int )c == 92) {
#line 255
      if (j > size - 3) {
#line 255
        goto error;
      }
#line 256
      tmp___0 = j;
#line 256
      j ++;
#line 256
      c1 = (int )*(buffer + tmp___0);
#line 257
      tmp___1 = j;
#line 257
      j ++;
#line 257
      c2 = (int )*(buffer + tmp___1);
#line 258
      tmp___2 = j;
#line 258
      j ++;
#line 258
      c3 = (int )*(buffer + tmp___2);
#line 259
      if (c1 < 48) {
#line 260
        goto error;
      } else
#line 259
      if (c1 > 51) {
#line 260
        goto error;
      } else
#line 259
      if (c2 < 48) {
#line 260
        goto error;
      } else
#line 259
      if (c2 > 55) {
#line 260
        goto error;
      } else
#line 259
      if (c3 < 48) {
#line 260
        goto error;
      } else
#line 259
      if (c3 > 55) {
#line 260
        goto error;
      }
#line 261
      c1 -= 48;
#line 262
      c2 -= 48;
#line 263
      c3 -= 48;
#line 264
      c = (char )((((c1 << 6) | (c2 << 3)) | c3) & 255);
    }
#line 266
    *(buffer + i) = c;
#line 250
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 268
  return (i);
  error: 
  {
#line 270
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 270
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: ",
            program_name);
#line 270
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"could not unmangle passphrase");
#line 270
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
#line 270
    exit(1);
    }
#line 270
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 271
  return (0);
}
}
#line 278 "/home/june/repo/benchmarks/collector/temp/signing-party-1.1.5/gpgwrap/src/gpgwrap.c"
static int read_passphrase(char *buffer , int size ) 
{ 
  int fd ;
  int len ;
  int i ;
  __pid_t tmp ;
  int tmp___0 ;
  ssize_t tmp___1 ;
  int tmp___2 ;

  {
  {
#line 286
  while (1) {
    while_continue: /* CIL Label */ ;
#line 286
    if (verbose < 2) {
#line 286
      goto while_break;
    }
    {
#line 286
    tmp = getpid();
#line 286
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s[%d]: ",
            program_name, tmp);
#line 286
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"reading passphrase from file \'%s\'",
            passphrase_file);
#line 286
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
    }
#line 286
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 287
  tmp___0 = strcmp((char const   *)passphrase_file, "-");
  }
#line 287
  if (tmp___0 == 0) {
#line 287
    fd = 0;
  } else {
    {
#line 288
    fd = open((char const   *)passphrase_file, 0);
    }
  }
#line 289
  if (fd == -1) {
    {
#line 289
    do_perror();
    }
  }
#line 290
  len = 0;
  {
#line 290
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 290
    tmp___1 = read(fd, (void *)buffer, (size_t )size);
#line 290
    i = (int )tmp___1;
    }
#line 290
    if (! (i > 0)) {
#line 290
      goto while_break___0;
    }
#line 292
    buffer += i;
#line 293
    size -= i;
#line 294
    if (size == 0) {
      {
#line 294
      do_error_too_long();
      }
    }
#line 290
    len += i;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 296
  if (i == -1) {
    {
#line 296
    do_perror();
    }
  }
  {
#line 297
  tmp___2 = close(fd);
  }
#line 297
  if (tmp___2 == -1) {
    {
#line 297
    do_perror();
    }
  }
#line 298
  return (len);
}
}
#line 306 "/home/june/repo/benchmarks/collector/temp/signing-party-1.1.5/gpgwrap/src/gpgwrap.c"
static int prompt_passphrase(char *buffer , int size ) 
{ 
  int len ;
  int len2 ;
  int fd ;
  struct termios t ;
  struct termios tt ;
  char tty[9] ;
  char pp[13] ;
  char pp2[22] ;
  char *buffer2 ;
  __pid_t tmp ;
  size_t tmp___0 ;
  ssize_t tmp___1 ;
  void *tmp___2 ;
  size_t tmp___3 ;
  ssize_t tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 315
  tty[0] = (char )'/';
#line 315
  tty[1] = (char )'d';
#line 315
  tty[2] = (char )'e';
#line 315
  tty[3] = (char )'v';
#line 315
  tty[4] = (char )'/';
#line 315
  tty[5] = (char )'t';
#line 315
  tty[6] = (char )'t';
#line 315
  tty[7] = (char )'y';
#line 315
  tty[8] = (char )'\000';
#line 316
  pp[0] = (char )'P';
#line 316
  pp[1] = (char )'a';
#line 316
  pp[2] = (char )'s';
#line 316
  pp[3] = (char )'s';
#line 316
  pp[4] = (char )'p';
#line 316
  pp[5] = (char )'h';
#line 316
  pp[6] = (char )'r';
#line 316
  pp[7] = (char )'a';
#line 316
  pp[8] = (char )'s';
#line 316
  pp[9] = (char )'e';
#line 316
  pp[10] = (char )':';
#line 316
  pp[11] = (char )' ';
#line 316
  pp[12] = (char )'\000';
#line 317
  pp2[0] = (char )'\n';
#line 317
  pp2[1] = (char )'P';
#line 317
  pp2[2] = (char )'a';
#line 317
  pp2[3] = (char )'s';
#line 317
  pp2[4] = (char )'s';
#line 317
  pp2[5] = (char )'p';
#line 317
  pp2[6] = (char )'h';
#line 317
  pp2[7] = (char )'r';
#line 317
  pp2[8] = (char )'a';
#line 317
  pp2[9] = (char )'s';
#line 317
  pp2[10] = (char )'e';
#line 317
  pp2[11] = (char )' ';
#line 317
  pp2[12] = (char )'(';
#line 317
  pp2[13] = (char )'a';
#line 317
  pp2[14] = (char )'g';
#line 317
  pp2[15] = (char )'a';
#line 317
  pp2[16] = (char )'i';
#line 317
  pp2[17] = (char )'n';
#line 317
  pp2[18] = (char )')';
#line 317
  pp2[19] = (char )':';
#line 317
  pp2[20] = (char )' ';
#line 317
  pp2[21] = (char )'\000';
  {
#line 325
  while (1) {
    while_continue: /* CIL Label */ ;
#line 325
    if (verbose < 2) {
#line 325
      goto while_break;
    }
    {
#line 325
    tmp = getpid();
#line 325
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s[%d]: ",
            program_name, tmp);
#line 325
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"opening \'%s\' to prompt for passphrase",
            tty);
#line 325
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
    }
#line 325
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 326
  fd = open((char const   *)(tty), 2);
  }
#line 327
  if (fd == -1) {
    {
#line 327
    do_perror();
    }
  }
  {
#line 328
  tmp___0 = strlen((char const   *)(pp));
#line 328
  write(fd, (void const   *)(pp), tmp___0);
#line 329
  tcgetattr(fd, & t);
#line 330
  tt = t;
#line 331
  tt.c_lflag &= 4294967287U;
#line 332
  tcsetattr(fd, 2, (struct termios  const  *)(& tt));
#line 333
  tmp___1 = read(fd, (void *)buffer, (size_t )size);
#line 333
  len = (int )tmp___1;
  }
#line 334
  if (len == -1) {
    {
#line 334
    do_perror();
    }
  }
#line 335
  if (ask_twice) {
#line 335
    if (len < size) {
      {
#line 337
      tmp___2 = __builtin_alloca(sizeof(char ) * (unsigned long )size);
#line 337
      buffer2 = (char *)tmp___2;
      }
#line 338
      if ((unsigned long )buffer2 == (unsigned long )((void *)0)) {
        {
#line 338
        do_error_oom();
        }
      }
      {
#line 339
      tmp___3 = strlen((char const   *)(pp2));
#line 339
      write(fd, (void const   *)(pp2), tmp___3);
#line 340
      tmp___4 = read(fd, (void *)buffer2, (size_t )size);
#line 340
      len2 = (int )tmp___4;
      }
#line 341
      if (len2 == -1) {
        {
#line 341
        do_perror();
        }
      }
      {
#line 342
      write(fd, (void const   *)"\n", (size_t )1);
#line 343
      tcsetattr(fd, 2, (struct termios  const  *)(& t));
      }
#line 344
      if (len != len2) {
#line 344
        goto _L;
      } else {
        {
#line 344
        tmp___5 = memcmp((void const   *)buffer, (void const   *)buffer2, (size_t )len);
        }
#line 344
        if (tmp___5 != 0) {
          _L: /* CIL Label */ 
          {
#line 344
          while (1) {
            while_continue___0: /* CIL Label */ ;
            {
#line 344
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: ",
                    program_name);
#line 344
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"passphrases are not the same");
#line 344
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
#line 344
            exit(1);
            }
#line 344
            goto while_break___0;
          }
          while_break___0: /* CIL Label */ ;
          }
        }
      }
    } else {
#line 335
      goto _L___0;
    }
  } else {
    _L___0: /* CIL Label */ 
    {
#line 348
    write(fd, (void const   *)"\n", (size_t )1);
#line 349
    tcsetattr(fd, 2, (struct termios  const  *)(& t));
    }
#line 357
    if (len >= size) {
      {
#line 357
      do_error_too_long();
      }
    }
  }
  {
#line 359
  tmp___6 = close(fd);
  }
#line 359
  if (tmp___6 == -1) {
    {
#line 359
    do_perror();
    }
  }
#line 363
  return (len - 1);
}
}
#line 371 "/home/june/repo/benchmarks/collector/temp/signing-party-1.1.5/gpgwrap/src/gpgwrap.c"
static int environ_or_prompt(char *buffer , int size ) 
{ 
  int len ;
  int len2 ;
  char *env ;
  __pid_t tmp ;
  size_t tmp___0 ;

  {
  {
#line 380
  env = getenv((char const   *)(environ_name));
  }
#line 381
  if ((unsigned long )env != (unsigned long )((void *)0)) {
#line 381
    if (! interactive) {
      {
#line 383
      while (1) {
        while_continue: /* CIL Label */ ;
#line 383
        if (verbose < 2) {
#line 383
          goto while_break;
        }
        {
#line 383
        tmp = getpid();
#line 383
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s[%d]: ",
                program_name, tmp);
#line 383
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"got passphrase from environment variable: %s=%s",
                environ_name, env);
#line 383
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
        }
#line 383
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 390
      tmp___0 = strlen((char const   *)env);
#line 390
      len2 = (int )tmp___0;
#line 391
      len = unmangle_passphrase(env, len2);
      }
#line 392
      if (len > size) {
        {
#line 392
        do_error_too_long();
        }
      }
      {
#line 393
      memcpy((void */* __restrict  */)buffer, (void const   */* __restrict  */)env,
             (size_t )len);
#line 394
      memset((void *)env, 0, (size_t )len2);
      }
    } else {
      {
#line 396
      len = prompt_passphrase(buffer, size);
      }
    }
  } else {
    {
#line 396
    len = prompt_passphrase(buffer, size);
    }
  }
#line 397
  return (len);
}
}
#line 405 "/home/june/repo/benchmarks/collector/temp/signing-party-1.1.5/gpgwrap/src/gpgwrap.c"
static void do_wait(void) 
{ 
  int status ;
  int value ;
  __pid_t tmp ;
  __pid_t tmp___0 ;
  union __anonunion_52 __constr_expr_0 ;
  union __anonunion_53 __constr_expr_1 ;
  __pid_t tmp___1 ;

  {
#line 410
  value = 1;
  {
#line 412
  while (1) {
    while_continue: /* CIL Label */ ;
#line 412
    if (verbose < 2) {
#line 412
      goto while_break;
    }
    {
#line 412
    tmp = getpid();
#line 412
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s[%d]: ",
            program_name, tmp);
#line 412
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"waiting for child");
#line 412
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
    }
#line 412
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 413
  wait((union wait *)(& status));
  }
#line 414
  if (! check_exit_code) {
#line 414
    return;
  }
  {
#line 415
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 415
    if (verbose < 2) {
#line 415
      goto while_break___0;
    }
    {
#line 415
    tmp___0 = getpid();
#line 415
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s[%d]: ",
            program_name, tmp___0);
#line 415
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"checking child exit code");
#line 415
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
    }
#line 415
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 416
  __constr_expr_0.__in = status;
#line 416
  if (! ((__constr_expr_0.__i & 127) == 0)) {
#line 416
    goto out;
  }
#line 417
  __constr_expr_1.__in = status;
#line 417
  value = (__constr_expr_1.__i & 65280) >> 8;
#line 418
  if (value == 0) {
#line 418
    return;
  }
  {
#line 419
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 419
    if (verbose < 2) {
#line 419
      goto while_break___1;
    }
    {
#line 419
    tmp___1 = getpid();
#line 419
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s[%d]: ",
            program_name, tmp___1);
#line 419
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"child process terminated abnormal, exiting");
#line 419
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
    }
#line 419
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  out: 
  {
#line 421
  exit(value);
  }
}
}
#line 429 "/home/june/repo/benchmarks/collector/temp/signing-party-1.1.5/gpgwrap/src/gpgwrap.c"
static int do_fork(char *buffer , int size ) 
{ 
  int fds[2] ;
  int i ;
  int tmp ;
  __pid_t tmp___0 ;
  __pid_t tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  ssize_t tmp___4 ;
  int *tmp___5 ;
  int tmp___6 ;

  {
  {
#line 442
  tmp = pipe((int *)(fds));
  }
#line 442
  if (tmp == -1) {
    {
#line 442
    do_perror();
    }
  }
  {
#line 443
  while (1) {
    while_continue: /* CIL Label */ ;
#line 443
    if (verbose < 2) {
#line 443
      goto while_break;
    }
    {
#line 443
    tmp___0 = getpid();
#line 443
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s[%d]: ",
            program_name, tmp___0);
#line 443
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"forking");
#line 443
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
    }
#line 443
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 444
  tmp___1 = fork();
  }
  {
#line 446
  if (tmp___1 == -1) {
#line 446
    goto case_neg_1;
  }
#line 448
  if (tmp___1 == 0) {
#line 448
    goto case_0;
  }
#line 453
  goto switch_default;
  case_neg_1: /* CIL Label */ 
  {
#line 447
  do_perror();
  }
  case_0: /* CIL Label */ 
  {
#line 451
  tmp___2 = close(fds[1]);
  }
#line 451
  if (tmp___2 == -1) {
    {
#line 451
    do_perror();
    }
  }
#line 452
  return (fds[0]);
  switch_default: /* CIL Label */ 
#line 454
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 459
  signal(13, (void (*)(int  ))1);
#line 460
  tmp___3 = close(fds[0]);
  }
#line 460
  if (tmp___3 == -1) {
    {
#line 460
    do_perror();
    }
  }
  {
#line 461
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 461
    if (! (size > 0)) {
#line 461
      goto while_break___0;
    }
    {
#line 463
    tmp___4 = write(fds[1], (void const   *)buffer, (size_t )size);
#line 463
    i = (int )tmp___4;
    }
#line 464
    if (i == -1) {
      {
#line 464
      tmp___5 = __errno_location();
      }
#line 464
      if (*tmp___5 == 32) {
#line 464
        goto while_break___0;
      }
    }
#line 465
    if (i == -1) {
      {
#line 465
      do_perror();
      }
    }
#line 466
    buffer += i;
#line 467
    size -= i;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 469
  if (size > 0) {
    {
#line 469
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 469
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: ",
              program_name);
#line 469
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"only partial passphrase written");
#line 469
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
      }
#line 469
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  {
#line 470
  tmp___6 = close(fds[1]);
  }
#line 470
  if (tmp___6 == -1) {
    {
#line 470
    do_perror();
    }
  }
  {
#line 471
  do_wait();
  }
#line 472
  return (-1);
}
}
#line 480 "/home/june/repo/benchmarks/collector/temp/signing-party-1.1.5/gpgwrap/src/gpgwrap.c"
static int get_passphrase_fd(void) 
{ 
  int fd ;
  int len ;
  char buffer[65536] ;
  __pid_t tmp ;
  int tmp___0 ;

  {
#line 488
  if ((unsigned long )passphrase_file == (unsigned long )((void *)0)) {
    {
#line 490
    len = environ_or_prompt(buffer, (int )sizeof(buffer));
#line 491
    fd = do_fork(buffer, len);
    }
  } else
#line 488
  if (interactive) {
    {
#line 490
    len = environ_or_prompt(buffer, (int )sizeof(buffer));
#line 491
    fd = do_fork(buffer, len);
    }
  } else {
    {
#line 493
    tmp___0 = strcmp((char const   *)passphrase_file, "-");
    }
#line 493
    if (tmp___0 == 0) {
      {
#line 495
      len = read_passphrase(buffer, (int )sizeof(buffer));
#line 496
      fd = do_fork(buffer, len);
      }
    } else {
      {
#line 500
      while (1) {
        while_continue: /* CIL Label */ ;
#line 500
        if (verbose < 2) {
#line 500
          goto while_break;
        }
        {
#line 500
        tmp = getpid();
#line 500
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s[%d]: ",
                program_name, tmp);
#line 500
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"opening file \'%s\' to pass fd",
                passphrase_file);
#line 500
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
        }
#line 500
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 501
      fd = open((char const   *)passphrase_file, 0);
      }
#line 502
      if (fd == -1) {
        {
#line 502
        do_perror();
        }
      }
    }
  }
#line 504
  return (fd);
}
}
#line 512 "/home/june/repo/benchmarks/collector/temp/signing-party-1.1.5/gpgwrap/src/gpgwrap.c"
static int get_passphrase(char *buffer , int size ) 
{ 
  int len ;

  {
#line 520
  if ((unsigned long )passphrase_file == (unsigned long )((void *)0)) {
    {
#line 520
    len = environ_or_prompt(buffer, size);
    }
  } else
#line 520
  if (interactive) {
    {
#line 520
    len = environ_or_prompt(buffer, size);
    }
  } else {
    {
#line 521
    len = read_passphrase(buffer, size);
    }
  }
#line 522
  return (len);
}
}
#line 530 "/home/june/repo/benchmarks/collector/temp/signing-party-1.1.5/gpgwrap/src/gpgwrap.c"
static void do_putenv(char *buffer , int len ) 
{ 
  int size ;
  int len2 ;
  char *old_var ;
  size_t tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  __pid_t tmp___2 ;
  int tmp___3 ;

  {
  {
#line 544
  tmp = strlen((char const   *)(environ_name));
#line 544
  size = (int )((tmp + (size_t )(4 * len)) + 2UL);
#line 545
  old_var = environ_var;
#line 546
  tmp___0 = malloc(sizeof(char ) * (unsigned long )size);
#line 546
  environ_var = (char *)tmp___0;
  }
#line 547
  if ((unsigned long )environ_var == (unsigned long )((void *)0)) {
    {
#line 547
    do_error_oom();
    }
  }
  {
#line 548
  tmp___1 = snprintf((char */* __restrict  */)environ_var, (size_t )size, (char const   */* __restrict  */)"%s=",
                     environ_name);
#line 548
  len2 = do_snprintf2(tmp___1, size);
  }
#line 549
  if ((unsigned long )buffer != (unsigned long )((void *)0)) {
#line 549
    if (len > 0) {
      {
#line 549
      mangle_passphrase(buffer, len, environ_var + len2, size - len2);
      }
    }
  }
  {
#line 550
  while (1) {
    while_continue: /* CIL Label */ ;
#line 550
    if (verbose < 2) {
#line 550
      goto while_break;
    }
    {
#line 550
    tmp___2 = getpid();
#line 550
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s[%d]: ",
            program_name, tmp___2);
#line 550
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"setting environment variable: %s",
            environ_var);
#line 550
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
    }
#line 550
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 551
  tmp___3 = putenv(environ_var);
  }
#line 551
  if (tmp___3 == -1) {
    {
#line 551
    do_perror();
    }
  }
#line 552
  if ((unsigned long )old_var != (unsigned long )((void *)0)) {
    {
#line 552
    free((void *)old_var);
    }
  }
#line 553
  return;
}
}
#line 560 "/home/june/repo/benchmarks/collector/temp/signing-party-1.1.5/gpgwrap/src/gpgwrap.c"
static void do_exec(char **argv , int clear ) 
{ 
  int i ;
  __pid_t tmp ;

  {
#line 566
  if (clear) {
    {
#line 566
    do_putenv((char *)((void *)0), 0);
    }
  }
#line 567
  if (verbose > 0) {
    {
#line 571
    while (1) {
      while_continue: /* CIL Label */ ;
#line 571
      if (verbose < 1) {
#line 571
        goto while_break;
      }
      {
#line 571
      tmp = getpid();
#line 571
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s[%d] ",
              program_name, tmp);
#line 571
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"executing:");
      }
#line 571
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
#line 572
    i = 0;
    {
#line 572
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 572
      if (! ((unsigned long )*(argv + i) != (unsigned long )((void *)0))) {
#line 572
        goto while_break___0;
      }
      {
#line 572
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 572
        if (verbose < 1) {
#line 572
          goto while_break___1;
        }
        {
#line 572
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" %s",
                *(argv + i));
        }
#line 572
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 572
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 573
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 573
      if (verbose < 1) {
#line 573
        goto while_break___2;
      }
      {
#line 573
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
      }
#line 573
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
  }
  {
#line 575
  execvp((char const   *)*(argv + 0), (char * const  *)argv);
#line 579
  do_perror();
  }
#line 580
  return;
}
}
#line 587 "/home/june/repo/benchmarks/collector/temp/signing-party-1.1.5/gpgwrap/src/gpgwrap.c"
static void exec_gpg(void) 
{ 
  int fd ;
  int i ;
  int j ;
  int k ;
  char fd_num[32] ;
  char *argv[1024] ;
  char homedir_eq[11] ;
  char options_eq[11] ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;

  {
  {
#line 596
  homedir_eq[0] = (char )'-';
#line 596
  homedir_eq[1] = (char )'-';
#line 596
  homedir_eq[2] = (char )'h';
#line 596
  homedir_eq[3] = (char )'o';
#line 596
  homedir_eq[4] = (char )'m';
#line 596
  homedir_eq[5] = (char )'e';
#line 596
  homedir_eq[6] = (char )'d';
#line 596
  homedir_eq[7] = (char )'i';
#line 596
  homedir_eq[8] = (char )'r';
#line 596
  homedir_eq[9] = (char )'=';
#line 596
  homedir_eq[10] = (char )'\000';
#line 597
  options_eq[0] = (char )'-';
#line 597
  options_eq[1] = (char )'-';
#line 597
  options_eq[2] = (char )'o';
#line 597
  options_eq[3] = (char )'p';
#line 597
  options_eq[4] = (char )'t';
#line 597
  options_eq[5] = (char )'i';
#line 597
  options_eq[6] = (char )'o';
#line 597
  options_eq[7] = (char )'n';
#line 597
  options_eq[8] = (char )'s';
#line 597
  options_eq[9] = (char )'=';
#line 597
  options_eq[10] = (char )'\000';
#line 604
  fd = get_passphrase_fd();
  }
#line 605
  if (fd == -1) {
#line 605
    return;
  }
  {
#line 609
  tmp = snprintf((char */* __restrict  */)(fd_num), sizeof(fd_num), (char const   */* __restrict  */)"%d",
                 fd);
#line 609
  do_snprintf2(tmp, (int )sizeof(fd_num));
#line 610
  i = 0;
#line 610
  j = 0;
#line 610
  k = 1;
  }
  {
#line 610
  while (1) {
    while_continue: /* CIL Label */ ;
#line 610
    if (! ((unsigned long )*(gpg_cmd + i) != (unsigned long )((void *)0))) {
#line 610
      goto while_break;
    }
#line 618
    if (i >= 1020) {
      {
#line 618
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 618
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: ",
                program_name);
#line 618
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"too many gpg arguments specified");
#line 618
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
#line 618
        exit(1);
        }
#line 618
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
    {
#line 619
    tmp___0 = strcmp((char const   *)*(gpg_cmd + i), (char const   *)option_name);
    }
#line 619
    if (tmp___0 == 0) {
      {
#line 619
      while (1) {
        while_continue___1: /* CIL Label */ ;
        {
#line 619
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: ",
                program_name);
#line 619
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"gpg command already has a \'%s\' option",
                option_name);
#line 619
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
#line 619
        exit(1);
        }
#line 619
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
#line 620
    if (k == 0) {
      {
#line 622
      tmp___5 = strncmp((char const   *)*(gpg_cmd + i), (char const   *)(homedir_eq),
                        sizeof(homedir_eq) - 1UL);
      }
#line 622
      if (tmp___5 == 0) {
#line 622
        k = 1;
      } else {
        {
#line 622
        tmp___6 = strncmp((char const   *)*(gpg_cmd + i), (char const   *)(options_eq),
                          sizeof(options_eq) - 1UL);
        }
#line 622
        if (tmp___6 == 0) {
#line 622
          k = 1;
        } else {
          {
#line 623
          tmp___3 = strcmp((char const   *)*(gpg_cmd + i), "--homedir");
          }
#line 623
          if (tmp___3 == 0) {
#line 623
            k = 2;
          } else {
            {
#line 623
            tmp___4 = strcmp((char const   *)*(gpg_cmd + i), "--options");
            }
#line 623
            if (tmp___4 == 0) {
#line 623
              k = 2;
            } else {
#line 626
              tmp___1 = j;
#line 626
              j ++;
#line 626
              argv[tmp___1] = option_name;
#line 627
              tmp___2 = j;
#line 627
              j ++;
#line 627
              argv[tmp___2] = fd_num;
            }
          }
        }
      }
    }
#line 630
    tmp___7 = j;
#line 630
    j ++;
#line 630
    argv[tmp___7] = *(gpg_cmd + i);
#line 610
    i ++;
#line 610
    k --;
  }
  while_break: /* CIL Label */ ;
  }
#line 632
  if (k >= 0) {
#line 634
    tmp___8 = j;
#line 634
    j ++;
#line 634
    argv[tmp___8] = option_name;
#line 635
    tmp___9 = j;
#line 635
    j ++;
#line 635
    argv[tmp___9] = fd_num;
  }
  {
#line 637
  argv[j] = (char *)((void *)0);
#line 638
  do_exec(argv, 1);
  }
#line 639
  return;
}
}
#line 646 "/home/june/repo/benchmarks/collector/temp/signing-party-1.1.5/gpgwrap/src/gpgwrap.c"
static void exec_line(char *line ) 
{ 
  char shell_cmd[65536] ;
  char verbose_string[128] ;
  unsigned int tmp ;
  char *argv[4] ;
  int fds[2] ;
  int i ;
  int tmp___0 ;
  __pid_t tmp___1 ;
  __pid_t tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  size_t tmp___6 ;
  int tmp___7 ;

  {
#line 652
  verbose_string[0] = (char )'\000';
#line 652
  tmp = 1U;
  {
#line 652
  while (1) {
    while_continue: /* CIL Label */ ;
#line 652
    if (tmp >= 128U) {
#line 652
      goto while_break;
    }
#line 652
    verbose_string[tmp] = (char)0;
#line 652
    tmp ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 653
  argv[0] = (char *)"sh";
#line 653
  argv[1] = (char *)"-c";
#line 653
  argv[2] = (char *)((void *)0);
#line 653
  argv[3] = (char *)((void *)0);
#line 658
  tmp___0 = pipe((int *)(fds));
  }
#line 658
  if (tmp___0 == -1) {
    {
#line 658
    do_perror();
    }
  }
  {
#line 659
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 659
    if (verbose < 1) {
#line 659
      goto while_break___0;
    }
    {
#line 659
    tmp___1 = getpid();
#line 659
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s[%d]: ",
            program_name, tmp___1);
#line 659
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"forking");
#line 659
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
    }
#line 659
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 660
  tmp___2 = fork();
  }
  {
#line 662
  if (tmp___2 == -1) {
#line 662
    goto case_neg_1;
  }
#line 664
  if (tmp___2 == 0) {
#line 664
    goto case_0;
  }
#line 666
  goto switch_default;
  case_neg_1: /* CIL Label */ 
  {
#line 663
  do_perror();
  }
  case_0: /* CIL Label */ 
#line 665
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 669
  tmp___3 = close(fds[0]);
  }
#line 669
  if (tmp___3 == -1) {
    {
#line 669
    do_perror();
    }
  }
  {
#line 670
  tmp___4 = close(fds[1]);
  }
#line 670
  if (tmp___4 == -1) {
    {
#line 670
    do_perror();
    }
  }
  {
#line 671
  do_wait();
  }
#line 672
  return;
  switch_break: /* CIL Label */ ;
  }
  {
#line 677
  tmp___5 = close(fds[1]);
  }
#line 677
  if (tmp___5 == -1) {
    {
#line 677
    do_perror();
    }
  }
#line 678
  if (fds[0] != 0) {
    {
#line 678
    dup2(fds[0], 0);
    }
  }
#line 682
  i = 0;
  {
#line 682
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 682
    if (! (i < verbose)) {
#line 682
      goto while_break___1;
    }
    {
#line 684
    tmp___6 = strlen((char const   *)(verbose_string));
    }
#line 684
    if (tmp___6 >= sizeof(verbose_string) - 4UL) {
#line 684
      goto while_break___1;
    }
    {
#line 685
    strcat((char */* __restrict  */)(verbose_string), (char const   */* __restrict  */)" -v");
#line 682
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 687
  tmp___7 = snprintf((char */* __restrict  */)(shell_cmd), sizeof(shell_cmd), (char const   */* __restrict  */)"exec %s%s -o %s -- %s",
                     calling_path, verbose_string, option_name, line);
#line 687
  do_snprintf2(tmp___7, (int )sizeof(shell_cmd));
#line 689
  argv[2] = shell_cmd;
#line 690
  do_exec(argv, 0);
  }
#line 691
  return;
}
}
#line 698 "/home/june/repo/benchmarks/collector/temp/signing-party-1.1.5/gpgwrap/src/gpgwrap.c"
static void exec_list(char *path , char *buffer , int len ) 
{ 
  int fd ;
  char lbuffer[65536] ;
  int inuse ;
  int start ;
  int free___0 ;
  int nread ;
  int llen ;
  char *line ;
  char *next_line ;
  __pid_t tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;
  ssize_t tmp___3 ;
  int tmp___4 ;

  {
  {
#line 712
  while (1) {
    while_continue: /* CIL Label */ ;
#line 712
    if (verbose < 1) {
#line 712
      goto while_break;
    }
    {
#line 712
    tmp = getpid();
#line 712
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s[%d]: ",
            program_name, tmp);
#line 712
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"reading gpg commands from file: \'%s\'",
            path);
#line 712
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
    }
#line 712
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 713
  tmp___0 = strcmp((char const   *)path, "-");
  }
#line 713
  if (tmp___0 == 0) {
#line 713
    fd = 0;
  } else {
    {
#line 714
    fd = open((char const   *)path, 0);
    }
  }
#line 715
  if (fd == -1) {
    {
#line 715
    do_perror();
    }
  }
  {
#line 719
  do_putenv(buffer, len);
#line 723
  inuse = 0;
#line 723
  free___0 = 65536;
  }
  {
#line 723
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 723
    tmp___3 = read(fd, (void *)(& lbuffer[inuse]), (size_t )free___0);
#line 723
    nread = (int )tmp___3;
    }
#line 723
    if (! (nread > 0)) {
#line 723
      goto while_break___0;
    }
#line 725
    inuse += nread;
#line 726
    line = lbuffer;
    {
#line 726
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 726
      tmp___2 = memchr((void const   *)line, '\n', (size_t )inuse);
#line 726
      next_line = (char *)tmp___2;
      }
#line 726
      if (! ((unsigned long )next_line != (unsigned long )((void *)0))) {
#line 726
        goto while_break___1;
      }
      {
#line 728
      *next_line = (char )'\000';
#line 729
      llen = (int )(next_line - line) + 1;
#line 730
      tmp___1 = strlen((char const   *)line);
      }
#line 730
      if ((size_t )llen != tmp___1 + 1UL) {
        {
#line 730
        while (1) {
          while_continue___2: /* CIL Label */ ;
          {
#line 730
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: ",
                  program_name);
#line 730
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"line contains \\0 character");
#line 730
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
#line 730
          exit(1);
          }
#line 730
          goto while_break___2;
        }
        while_break___2: /* CIL Label */ ;
        }
      }
      {
#line 731
      exec_line(line);
#line 732
      inuse -= llen;
#line 733
      line = next_line + 1;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 735
    start = (int )(line - lbuffer);
#line 736
    if (start == 0) {
#line 736
      if (inuse == 65536) {
        {
#line 736
        while (1) {
          while_continue___3: /* CIL Label */ ;
          {
#line 736
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: ",
                  program_name);
#line 736
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"line too long");
#line 736
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
#line 736
          exit(1);
          }
#line 736
          goto while_break___3;
        }
        while_break___3: /* CIL Label */ ;
        }
      }
    }
#line 737
    if (start > 0) {
#line 737
      if (inuse > 0) {
        {
#line 737
        memmove((void *)(lbuffer), (void const   *)(& lbuffer[start]), (size_t )inuse);
        }
      }
    }
#line 738
    free___0 = 65536 - inuse;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 743
  if (nread == -1) {
    {
#line 743
    do_perror();
    }
  }
  {
#line 744
  tmp___4 = close(fd);
  }
#line 744
  if (tmp___4 == -1) {
    {
#line 744
    do_perror();
    }
  }
#line 748
  if (inuse > 0) {
    {
#line 748
    while (1) {
      while_continue___4: /* CIL Label */ ;
      {
#line 748
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: ",
              program_name);
#line 748
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"last line incomplete");
#line 748
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
#line 748
      exit(1);
      }
#line 748
      goto while_break___4;
    }
    while_break___4: /* CIL Label */ ;
    }
  }
#line 749
  return;
}
}
#line 756 "/home/june/repo/benchmarks/collector/temp/signing-party-1.1.5/gpgwrap/src/gpgwrap.c"
static void cmdline_fill_space(char *s ) 
{ 
  char *tmp ;

  {
  {
#line 761
  while (1) {
    while_continue: /* CIL Label */ ;
#line 761
    if (! ((int )*s != 0)) {
#line 761
      goto while_break;
    }
#line 761
    tmp = s;
#line 761
    s ++;
#line 761
    *tmp = (char )' ';
  }
  while_break: /* CIL Label */ ;
  }
#line 762
  return;
}
}
#line 769 "/home/june/repo/benchmarks/collector/temp/signing-party-1.1.5/gpgwrap/src/gpgwrap.c"
static void cmdline_usage(void) 
{ 
  char space1[22] ;
  char space2[8] ;

  {
  {
#line 774
  space1[0] = (char )'g';
#line 774
  space1[1] = (char )'p';
#line 774
  space1[2] = (char )'g';
#line 774
  space1[3] = (char )'w';
#line 774
  space1[4] = (char )'r';
#line 774
  space1[5] = (char )'a';
#line 774
  space1[6] = (char )'p';
#line 774
  space1[7] = (char )' ';
#line 774
  space1[8] = (char )'0';
#line 774
  space1[9] = (char )'.';
#line 774
  space1[10] = (char )'0';
#line 774
  space1[11] = (char )'4';
#line 774
  space1[12] = (char )'-';
#line 774
  space1[13] = (char )'2';
#line 774
  space1[14] = (char )'0';
#line 774
  space1[15] = (char )'0';
#line 774
  space1[16] = (char )'6';
#line 774
  space1[17] = (char )'0';
#line 774
  space1[18] = (char )'9';
#line 774
  space1[19] = (char )'0';
#line 774
  space1[20] = (char )'4';
#line 774
  space1[21] = (char )'\000';
#line 775
  space2[0] = (char )'g';
#line 775
  space2[1] = (char )'p';
#line 775
  space2[2] = (char )'g';
#line 775
  space2[3] = (char )'w';
#line 775
  space2[4] = (char )'r';
#line 775
  space2[5] = (char )'a';
#line 775
  space2[6] = (char )'p';
#line 775
  space2[7] = (char )'\000';
#line 777
  cmdline_fill_space(space1);
#line 778
  cmdline_fill_space(space2);
#line 779
  printf((char const   */* __restrict  */)"gpgwrap 0.04-20060904 | written by Karsten Scheibler\n%s | http://unusedino.de/gpgwrap/\n%s | gpgwrap@unusedino.de\n\nUsage: %s -V\nor:    %s -P [-v] [-i] [-a] [-p <file>]\nor:    %s -F [-v] [-i] [-a] [-c] [-p <file>] [-o <name>]\n       %s    [--] <file> [<file> ... ]\nor:    %s [-v] [-i] [-a] [-p <file>] [-o <name>]\n       %s [--] gpg [gpg options]\n\n  -V          print out version\n  -P          get the passphrase and print it mangled to stdout\n  -F          read gpg commands from file\n  -v          be more verbose\n  -i          be interactive, always prompt for passphrase\n  -a          ask twice if prompting for passphrase\n  -c          check exit code of child processes\n  -p <file>   read passphrase from <file>\n  -o <name>   specify name of \"--passphrase-fd\" option\n  -h          this help\n",
         space1, space1, program_name, program_name, program_name, space2, program_name,
         space2);
#line 800
  exit(0);
  }
}
}
#line 808 "/home/june/repo/benchmarks/collector/temp/signing-party-1.1.5/gpgwrap/src/gpgwrap.c"
static char *cmdline_check_arg(char *msg , char *file ) 
{ 


  {
#line 814
  if ((unsigned long )file == (unsigned long )((void *)0)) {
    {
#line 814
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 814
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: ",
              program_name);
#line 814
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s expects a file name",
              msg);
#line 814
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
#line 814
      exit(1);
      }
#line 814
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 815
  return (file);
}
}
#line 829
static char *cmdline_check_stdin(char *msg , char *file ) ;
#line 829 "/home/june/repo/benchmarks/collector/temp/signing-party-1.1.5/gpgwrap/src/gpgwrap.c"
static int stdin_count  =    0;
#line 823 "/home/june/repo/benchmarks/collector/temp/signing-party-1.1.5/gpgwrap/src/gpgwrap.c"
static char *cmdline_check_stdin(char *msg , char *file ) 
{ 
  int tmp ;

  {
  {
#line 831
  cmdline_check_arg(msg, file);
#line 832
  tmp = strcmp((char const   *)file, "-");
  }
#line 832
  if (tmp == 0) {
#line 832
    stdin_count ++;
  }
#line 833
  if (stdin_count > 1) {
    {
#line 833
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 833
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: ",
              program_name);
#line 833
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s used stdin although already used before",
              msg);
#line 833
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
#line 833
      exit(1);
      }
#line 833
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 834
  return (file);
}
}
#line 842 "/home/june/repo/benchmarks/collector/temp/signing-party-1.1.5/gpgwrap/src/gpgwrap.c"
static void cmdline_parse(int argc , char **argv ) 
{ 
  char *arg ;
  int args ;
  int ignore ;
  int tmp ;
  char **tmp___0 ;
  char **tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  char **tmp___24 ;

  {
#line 850
  ignore = 0;
#line 852
  calling_path = *(argv + 0);
#line 853
  args = 0;
#line 853
  argv ++;
  {
#line 853
  while (1) {
    while_continue: /* CIL Label */ ;
#line 853
    tmp___24 = argv;
#line 853
    argv ++;
#line 853
    arg = *tmp___24;
#line 853
    if (! ((unsigned long )arg != (unsigned long )((void *)0))) {
#line 853
      goto while_break;
    }
#line 855
    if ((int )*(arg + 0) != 45) {
#line 855
      goto _L___7;
    } else
#line 855
    if (ignore) {
      _L___7: /* CIL Label */ 
#line 857
      if (mode == 2) {
#line 857
        goto get_file;
      }
#line 858
      gpg_cmd = argv - 1;
#line 859
      goto while_break;
    } else {
      {
#line 861
      tmp___23 = strcmp((char const   *)arg, "-");
      }
#line 861
      if (tmp___23 == 0) {
#line 861
        if (mode == 2) {
          get_file: 
#line 864
          if (nfiles >= 1024) {
            {
#line 864
            while (1) {
              while_continue___0: /* CIL Label */ ;
              {
#line 864
              fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: ",
                      program_name);
#line 864
              fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"too many files specified");
#line 864
              fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
#line 864
              exit(1);
              }
#line 864
              goto while_break___0;
            }
            while_break___0: /* CIL Label */ ;
            }
          }
          {
#line 865
          tmp = nfiles;
#line 865
          nfiles ++;
#line 865
          files[tmp] = cmdline_check_stdin((char *)"-F/--file", arg);
          }
        } else {
#line 861
          goto _L___6;
        }
      } else {
        _L___6: /* CIL Label */ 
        {
#line 867
        tmp___22 = strcmp((char const   *)arg, "--");
        }
#line 867
        if (tmp___22 == 0) {
#line 869
          ignore = 1;
        } else {
          {
#line 871
          tmp___20 = strcmp((char const   *)arg, "-h");
          }
#line 871
          if (tmp___20 == 0) {
            {
#line 873
            cmdline_usage();
            }
          } else {
            {
#line 871
            tmp___21 = strcmp((char const   *)arg, "--help");
            }
#line 871
            if (tmp___21 == 0) {
              {
#line 873
              cmdline_usage();
              }
            } else {
              {
#line 875
              tmp___18 = strcmp((char const   *)arg, "-V");
              }
#line 875
              if (tmp___18 == 0) {
#line 875
                goto _L___5;
              } else {
                {
#line 875
                tmp___19 = strcmp((char const   *)arg, "--version");
                }
#line 875
                if (tmp___19 == 0) {
                  _L___5: /* CIL Label */ 
#line 875
                  if (args == 0) {
#line 877
                    mode = 1;
                  } else {
#line 875
                    goto _L___4;
                  }
                } else {
                  _L___4: /* CIL Label */ 
                  {
#line 879
                  tmp___16 = strcmp((char const   *)arg, "-F");
                  }
#line 879
                  if (tmp___16 == 0) {
#line 879
                    goto _L___3;
                  } else {
                    {
#line 879
                    tmp___17 = strcmp((char const   *)arg, "--file");
                    }
#line 879
                    if (tmp___17 == 0) {
                      _L___3: /* CIL Label */ 
#line 879
                      if (args == 0) {
#line 881
                        mode = 2;
                      } else {
#line 879
                        goto _L___2;
                      }
                    } else {
                      _L___2: /* CIL Label */ 
                      {
#line 883
                      tmp___14 = strcmp((char const   *)arg, "-P");
                      }
#line 883
                      if (tmp___14 == 0) {
#line 883
                        goto _L___1;
                      } else {
                        {
#line 883
                        tmp___15 = strcmp((char const   *)arg, "--print");
                        }
#line 883
                        if (tmp___15 == 0) {
                          _L___1: /* CIL Label */ 
#line 883
                          if (args == 0) {
#line 885
                            mode = 3;
                          } else {
#line 883
                            goto _L___0;
                          }
                        } else
                        _L___0: /* CIL Label */ 
#line 887
                        if (mode == 1) {
#line 889
                          goto bad_option;
                        } else {
                          {
#line 891
                          tmp___12 = strcmp((char const   *)arg, "-v");
                          }
#line 891
                          if (tmp___12 == 0) {
#line 893
                            verbose ++;
                          } else {
                            {
#line 891
                            tmp___13 = strcmp((char const   *)arg, "--verbose");
                            }
#line 891
                            if (tmp___13 == 0) {
#line 893
                              verbose ++;
                            } else {
                              {
#line 895
                              tmp___10 = strcmp((char const   *)arg, "-i");
                              }
#line 895
                              if (tmp___10 == 0) {
#line 897
                                interactive = 1;
                              } else {
                                {
#line 895
                                tmp___11 = strcmp((char const   *)arg, "--interactive");
                                }
#line 895
                                if (tmp___11 == 0) {
#line 897
                                  interactive = 1;
                                } else {
                                  {
#line 899
                                  tmp___8 = strcmp((char const   *)arg, "-a");
                                  }
#line 899
                                  if (tmp___8 == 0) {
#line 901
                                    ask_twice = 1;
                                  } else {
                                    {
#line 899
                                    tmp___9 = strcmp((char const   *)arg, "--ask-twice");
                                    }
#line 899
                                    if (tmp___9 == 0) {
#line 901
                                      ask_twice = 1;
                                    } else {
                                      {
#line 903
                                      tmp___6 = strcmp((char const   *)arg, "-p");
                                      }
#line 903
                                      if (tmp___6 == 0) {
#line 903
                                        goto _L;
                                      } else {
                                        {
#line 903
                                        tmp___7 = strcmp((char const   *)arg, "--passphrase-file");
                                        }
#line 903
                                        if (tmp___7 == 0) {
                                          _L: /* CIL Label */ 
#line 905
                                          if ((unsigned long )passphrase_file != (unsigned long )((void *)0)) {
                                            {
#line 905
                                            while (1) {
                                              while_continue___1: /* CIL Label */ ;
                                              {
#line 905
                                              fprintf((FILE */* __restrict  */)stderr,
                                                      (char const   */* __restrict  */)"%s: ",
                                                      program_name);
#line 905
                                              fprintf((FILE */* __restrict  */)stderr,
                                                      (char const   */* __restrict  */)"-p/--passphrase-file specified more than once");
#line 905
                                              fprintf((FILE */* __restrict  */)stderr,
                                                      (char const   */* __restrict  */)"\n");
#line 905
                                              exit(1);
                                              }
#line 905
                                              goto while_break___1;
                                            }
                                            while_break___1: /* CIL Label */ ;
                                            }
                                          }
                                          {
#line 906
                                          tmp___0 = argv;
#line 906
                                          argv ++;
#line 906
                                          passphrase_file = cmdline_check_stdin((char *)"-p/--passphrase-file",
                                                                                *tmp___0);
                                          }
                                        } else
#line 908
                                        if (mode == 3) {
#line 910
                                          goto bad_option;
                                        } else {
                                          {
#line 912
                                          tmp___4 = strcmp((char const   *)arg, "-o");
                                          }
#line 912
                                          if (tmp___4 == 0) {
                                            {
#line 914
                                            tmp___1 = argv;
#line 914
                                            argv ++;
#line 914
                                            option_name = cmdline_check_arg((char *)"-o/--option-name",
                                                                            *tmp___1);
                                            }
                                          } else {
                                            {
#line 912
                                            tmp___5 = strcmp((char const   *)arg,
                                                             "--option-name");
                                            }
#line 912
                                            if (tmp___5 == 0) {
                                              {
#line 914
                                              tmp___1 = argv;
#line 914
                                              argv ++;
#line 914
                                              option_name = cmdline_check_arg((char *)"-o/--option-name",
                                                                              *tmp___1);
                                              }
                                            } else
#line 916
                                            if (mode != 2) {
#line 918
                                              goto bad_option;
                                            } else {
                                              {
#line 920
                                              tmp___2 = strcmp((char const   *)arg,
                                                               "-c");
                                              }
#line 920
                                              if (tmp___2 == 0) {
#line 922
                                                check_exit_code = 1;
                                              } else {
                                                {
#line 920
                                                tmp___3 = strcmp((char const   *)arg,
                                                                 "--check-exit-code");
                                                }
#line 920
                                                if (tmp___3 == 0) {
#line 922
                                                  check_exit_code = 1;
                                                } else {
                                                  bad_option: 
                                                  {
#line 927
                                                  while (1) {
                                                    while_continue___2: /* CIL Label */ ;
                                                    {
#line 927
                                                    fprintf((FILE */* __restrict  */)stderr,
                                                            (char const   */* __restrict  */)"%s: ",
                                                            program_name);
#line 927
                                                    fprintf((FILE */* __restrict  */)stderr,
                                                            (char const   */* __restrict  */)"unrecognized option \'%s\'",
                                                            arg);
#line 927
                                                    fprintf((FILE */* __restrict  */)stderr,
                                                            (char const   */* __restrict  */)"\n");
#line 927
                                                    exit(1);
                                                    }
#line 927
                                                    goto while_break___2;
                                                  }
                                                  while_break___2: /* CIL Label */ ;
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
#line 853
    args ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 930
  if (mode == 0) {
#line 930
    if (nfiles == 0) {
#line 930
      if ((unsigned long )gpg_cmd == (unsigned long )((void *)0)) {
        {
#line 930
        while (1) {
          while_continue___3: /* CIL Label */ ;
          {
#line 930
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: ",
                  program_name);
#line 930
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"no gpg command specified");
#line 930
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
#line 930
          exit(1);
          }
#line 930
          goto while_break___3;
        }
        while_break___3: /* CIL Label */ ;
        }
      }
    }
  }
#line 931
  if (mode == 2) {
#line 931
    if (nfiles == 0) {
      {
#line 931
      while (1) {
        while_continue___4: /* CIL Label */ ;
        {
#line 931
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: ",
                program_name);
#line 931
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"no files to process");
#line 931
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
#line 931
        exit(1);
        }
#line 931
        goto while_break___4;
      }
      while_break___4: /* CIL Label */ ;
      }
    }
  }
#line 932
  if (mode == 3) {
#line 932
    if (nfiles > 0) {
      {
#line 932
      while (1) {
        while_continue___5: /* CIL Label */ ;
        {
#line 932
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: ",
                program_name);
#line 932
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"no additional arguments allowed");
#line 932
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
#line 932
        exit(1);
        }
#line 932
        goto while_break___5;
      }
      while_break___5: /* CIL Label */ ;
      }
    }
  }
#line 933
  if (mode != 2) {
#line 933
    check_exit_code = 1;
  }
#line 934
  return;
}
}
