/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 315 "/usr/include/libio.h"
typedef struct _IO_FILE _IO_FILE;
#line 39 "/home/wheatley/newnew/temp/phalanx-22+d051004/phalanx.h"
typedef long long int64;
#line 46 "/home/wheatley/newnew/temp/phalanx-22+d051004/phalanx.h"
typedef unsigned char tsquare;
#line 49 "/home/wheatley/newnew/temp/phalanx-22+d051004/phalanx.h"
struct __anonstruct_tmove_55 {
   unsigned char from ;
   unsigned char to ;
   unsigned char special ;
   unsigned char in1 ;
   unsigned char in2 ;
   unsigned char in2a ;
   short value ;
   short dch ;
   short shift ;
};
#line 49 "/home/wheatley/newnew/temp/phalanx-22+d051004/phalanx.h"
typedef struct __anonstruct_tmove_55 tmove;
#line 68 "/home/wheatley/newnew/temp/phalanx-22+d051004/phalanx.h"
struct __anonstruct_tgamenode_56 {
   tmove m ;
   unsigned int hashboard ;
   unsigned short rule50 ;
   unsigned short castling : 8 ;
   unsigned short check : 8 ;
   short mtrl ;
   short xmtrl ;
};
#line 68 "/home/wheatley/newnew/temp/phalanx-22+d051004/phalanx.h"
typedef struct __anonstruct_tgamenode_56 tgamenode;
#line 116
enum __anonenum_tlevel_59 {
    timecontrol = 0,
    averagetime = 1,
    fixedtime = 2,
    fixeddepth = 3
} ;
#line 116 "/home/wheatley/newnew/temp/phalanx-22+d051004/phalanx.h"
typedef enum __anonenum_tlevel_59 tlevel;
#line 120 "/home/wheatley/newnew/temp/phalanx-22+d051004/phalanx.h"
struct __anonstruct_tflag_60 {
   int centiseconds ;
   unsigned int moves ;
   unsigned int increment ;
   int depth ;
   int noise ;
   int resign ;
   int bench ;
   int machine_color ;
   int post ;
   int xboard ;
   int book ;
   int learn ;
   int cpu ;
   int ponder ;
   int analyze ;
   int polling ;
   tlevel level ;
   unsigned char easy ;
   FILE *log ;
};
#line 120 "/home/wheatley/newnew/temp/phalanx-22+d051004/phalanx.h"
typedef struct __anonstruct_tflag_60 tflag;
#line 147 "/home/wheatley/newnew/temp/phalanx-22+d051004/phalanx.h"
struct __anonstruct_tlist_61 {
   unsigned char prev ;
   unsigned char next ;
};
#line 147 "/home/wheatley/newnew/temp/phalanx-22+d051004/phalanx.h"
typedef struct __anonstruct_tlist_61 tlist;
#line 151 "/home/wheatley/newnew/temp/phalanx-22+d051004/phalanx.h"
struct __anonstruct_tsbook_62 {
   FILE *f ;
   unsigned int firstkey ;
   unsigned int lastkey ;
   int filesize ;
};
#line 151 "/home/wheatley/newnew/temp/phalanx-22+d051004/phalanx.h"
typedef struct __anonstruct_tsbook_62 tsbook;
#line 161 "/home/wheatley/newnew/temp/phalanx-22+d051004/phalanx.h"
struct __anonstruct_tpbook_63 {
   FILE *f ;
   int filesize ;
};
#line 161 "/home/wheatley/newnew/temp/phalanx-22+d051004/phalanx.h"
typedef struct __anonstruct_tpbook_63 tpbook;
#line 403 "/home/wheatley/newnew/temp/phalanx-22+d051004/book.c"
struct teco {
   unsigned int hashboard ;
   unsigned int point ;
};
#line 403 "/home/wheatley/newnew/temp/phalanx-22+d051004/book.c"
typedef struct teco teco;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 141 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds_t;
#line 30 "/usr/include/x86_64-linux-gnu/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 54 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef long __fd_mask;
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
struct __anonstruct_fd_set_16 {
   __fd_mask fds_bits[1024 / (8 * (int )sizeof(__fd_mask ))] ;
};
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef struct __anonstruct_fd_set_16 fd_set;
#line 84 "/home/wheatley/newnew/temp/phalanx-22+d051004/phalanx.h"
struct __anonstruct_thashentry_57 {
   unsigned int hashboard ;
   short value ;
   short depth : 14 ;
   unsigned int result : 2 ;
   unsigned short move ;
   unsigned short age ;
};
#line 84 "/home/wheatley/newnew/temp/phalanx-22+d051004/phalanx.h"
typedef struct __anonstruct_thashentry_57 thashentry;
#line 99 "/home/wheatley/newnew/temp/phalanx-22+d051004/phalanx.h"
struct __anonstruct_tknow_58 {
   short hung ;
   signed char khung ;
   signed char kshield ;
   unsigned char p ;
   unsigned char n ;
   unsigned char b ;
   unsigned char r ;
   unsigned char q ;
   unsigned char kp ;
   unsigned char r7r ;
   signed char prune ;
   signed char kstorm ;
   signed char qstorm ;
   unsigned char devel ;
   unsigned char castling ;
   unsigned char bishopcolor ;
   unsigned char xbishopcolor ;
   signed char worsebm ;
   unsigned char lpf ;
   unsigned char rpf ;
};
#line 99 "/home/wheatley/newnew/temp/phalanx-22+d051004/phalanx.h"
typedef struct __anonstruct_tknow_58 tknow;
#line 165 "/home/wheatley/newnew/temp/phalanx-22+d051004/phalanx.h"
struct __anonstruct_tdist_64 {
   unsigned int taxi ;
   unsigned int max ;
   unsigned int diag ;
   unsigned int min ;
};
#line 165 "/home/wheatley/newnew/temp/phalanx-22+d051004/phalanx.h"
typedef struct __anonstruct_tdist_64 tdist;
#line 124 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 126 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 127 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 130 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 158 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 85 "/usr/include/signal.h"
typedef void (*__sighandler_t)(int  );
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 22 "/home/wheatley/newnew/temp/phalanx-22+d051004/bcreate.c"
struct __anonstruct_tb_65 {
   unsigned int hashboard ;
   unsigned int n ;
   unsigned short move ;
};
#line 22 "/home/wheatley/newnew/temp/phalanx-22+d051004/bcreate.c"
typedef struct __anonstruct_tb_65 tb;
#line 135 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __clock_t;
#line 59 "/usr/include/time.h"
typedef __clock_t clock_t;
#line 55 "/usr/include/x86_64-linux-gnu/sys/time.h"
struct timezone {
   int tz_minuteswest ;
   int tz_dsttime ;
};
#line 61 "/usr/include/x86_64-linux-gnu/sys/time.h"
typedef struct timezone * __restrict  __timezone_ptr_t;
#line 7 "/home/wheatley/newnew/temp/phalanx-22+d051004/learn.c"
struct __anonstruct_tlearn_65 {
   unsigned int hashboard ;
   short depth ;
   short value ;
};
#line 7 "/home/wheatley/newnew/temp/phalanx-22+d051004/learn.c"
typedef struct __anonstruct_tlearn_65 tlearn;
#line 133 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 104 "/usr/include/getopt.h"
struct option {
   char const   *name ;
   int has_arg ;
   int *flag ;
   int val ;
};
#line 75 "/usr/include/time.h"
typedef __time_t time_t;
#line 3 "/home/wheatley/newnew/temp/phalanx-22+d051004/killers.c"
struct __anonstruct_killentry_65 {
   unsigned int f ;
   unsigned int t ;
};
#line 3 "/home/wheatley/newnew/temp/phalanx-22+d051004/killers.c"
typedef struct __anonstruct_killentry_65 killentry;
#line 434 "/usr/include/libio.h"
extern int _IO_getc(_IO_FILE *__fp ) ;
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 362
extern int printf(char const   * __restrict  __format  , ...) ;
#line 364
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 531
extern int fgetc(FILE *__stream ) ;
#line 622
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 689
extern int fputs(char const   * __restrict  __s , FILE * __restrict  __stream ) ;
#line 695
extern int puts(char const   *__s ) ;
#line 702
extern int ungetc(int __c , FILE *__stream ) ;
#line 709
extern size_t fread(void * __restrict  __ptr , size_t __size , size_t __n , FILE * __restrict  __stream ) ;
#line 715
extern size_t fwrite(void const   * __restrict  __ptr , size_t __size , size_t __n ,
                     FILE * __restrict  __s ) ;
#line 749
extern int fseek(FILE *__stream , long __off , int __whence ) ;
#line 754
extern long ftell(FILE *__stream ) ;
#line 828
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) feof)(FILE *__stream ) ;
#line 374 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) rand)(void) ;
#line 466
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 147 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 489
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) index)(char const   *__s ,
                                                                                              int __c )  __attribute__((__pure__)) ;
#line 517
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) rindex)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 392 "/home/wheatley/newnew/temp/phalanx-22+d051004/phalanx.h"
tflag Flag ;
#line 394
tsquare B[120] ;
#line 395
tlist L[120] ;
#line 404
int Color ;
#line 417
tgamenode G[1024] ;
#line 418
int Counter ;
#line 445 "/home/wheatley/newnew/temp/phalanx-22+d051004/phalanx.h"
tpbook Pbook  ;
#line 447 "/home/wheatley/newnew/temp/phalanx-22+d051004/phalanx.h"
tsbook Sbook  ;
#line 448
FILE *Eco ;
#line 449
int Bookout ;
#line 462
void myfwrite(void *ptr , int size , FILE *stream ) ;
#line 463
void myfread(void *ptr , int size , FILE *stream ) ;
#line 470
void printm(tmove m___1 , char *s ) ;
#line 476
int setfen(char *f ) ;
#line 479
tmove *sandex(char *inp , tmove *m___1 , int n___1 ) ;
#line 484
int attacktest(int square___0 , int ocolor ) ;
#line 487
void generate_legal_moves(tmove *moves , int *n___1 , int check ) ;
#line 508
void do_move(tmove *m___1 ) ;
#line 509
void undo_move(tmove *m___1 ) ;
#line 524
int bookmove(tmove *m___1 , int n___1 ) ;
#line 525
unsigned int smove(tmove *m___1 ) ;
#line 9 "/home/wheatley/newnew/temp/phalanx-22+d051004/book.c"
int Bookout  =    0;
#line 17 "/home/wheatley/newnew/temp/phalanx-22+d051004/book.c"
void myfwrite(void *ptr , int size , FILE *stream ) 
{ 
  int i ;
  int j ;

  {
#line 20
  i = 0;
  {
#line 20
  while (1) {
    while_continue: /* CIL Label */ ;
#line 20
    if (! (i < size - (int )sizeof(int ))) {
#line 20
      goto while_break;
    }
#line 21
    j = 0;
    {
#line 21
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 21
      if (! (j != (int )sizeof(int ))) {
#line 21
        goto while_break___0;
      }
      {
#line 21
      fwrite((void const   */* __restrict  */)(((char *)ptr + i) + j), (size_t )1,
             (size_t )1, (FILE */* __restrict  */)stream);
#line 21
      j ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 20
    i += (int )sizeof(int );
  }
  while_break: /* CIL Label */ ;
  }
#line 22
  j = 0;
  {
#line 22
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 22
    if (! (i + j < size)) {
#line 22
      goto while_break___1;
    }
    {
#line 22
    fwrite((void const   */* __restrict  */)(((char *)ptr + i) + j), (size_t )1, (size_t )1,
           (FILE */* __restrict  */)stream);
#line 22
    j ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 23
  return;
}
}
#line 25 "/home/wheatley/newnew/temp/phalanx-22+d051004/book.c"
void myfread(void *ptr , int size , FILE *stream ) 
{ 
  int i ;
  int j ;

  {
#line 28
  i = 0;
  {
#line 28
  while (1) {
    while_continue: /* CIL Label */ ;
#line 28
    if (! (i < size - (int )sizeof(int ))) {
#line 28
      goto while_break;
    }
#line 29
    j = 0;
    {
#line 29
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 29
      if (! (j != (int )sizeof(int ))) {
#line 29
        goto while_break___0;
      }
      {
#line 29
      fread((void */* __restrict  */)(((char *)ptr + i) + j), (size_t )1, (size_t )1,
            (FILE */* __restrict  */)stream);
#line 29
      j ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 28
    i += (int )sizeof(int );
  }
  while_break: /* CIL Label */ ;
  }
#line 30
  j = 0;
  {
#line 30
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 30
    if (! (i + j < size)) {
#line 30
      goto while_break___1;
    }
    {
#line 30
    fread((void */* __restrict  */)(((char *)ptr + i) + j), (size_t )1, (size_t )1,
          (FILE */* __restrict  */)stream);
#line 30
    j ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 31
  return;
}
}
#line 40 "/home/wheatley/newnew/temp/phalanx-22+d051004/book.c"
void postr(char *s ) 
{ 
  int i ;
  int counter ;
  int lenght ;
  char P___0[14] ;

  {
  {
#line 43
  P___0[0] = (char )'-';
#line 43
  P___0[1] = (char )'-';
#line 43
  P___0[2] = (char )'p';
#line 43
  P___0[3] = (char )'P';
#line 43
  P___0[4] = (char )'n';
#line 43
  P___0[5] = (char )'N';
#line 43
  P___0[6] = (char )'b';
#line 43
  P___0[7] = (char )'B';
#line 43
  P___0[8] = (char )'r';
#line 43
  P___0[9] = (char )'R';
#line 43
  P___0[10] = (char )'q';
#line 43
  P___0[11] = (char )'Q';
#line 43
  P___0[12] = (char )'k';
#line 43
  P___0[13] = (char )'K';
#line 46
  sprintf((char */* __restrict  */)s, (char const   */* __restrict  */)"%1X%1X", Color == 2,
          (int )G[Counter].castling & 15);
#line 48
  counter = 0;
#line 48
  lenght = 2;
#line 49
  i = 21;
  }
  {
#line 49
  while (1) {
    while_continue: /* CIL Label */ ;
#line 49
    if (! (i != 99)) {
#line 49
      goto while_break;
    }
#line 49
    if (B[i]) {
#line 49
      if ((int )B[i] != 3) {
#line 51
        if (counter) {
          {
#line 53
          sprintf((char */* __restrict  */)(s + lenght), (char const   */* __restrict  */)"%i",
                  counter);
          }
#line 54
          if (counter > 9) {
#line 54
            lenght ++;
          }
#line 55
          lenght ++;
#line 55
          counter = 0;
        }
        {
#line 57
        sprintf((char */* __restrict  */)(s + lenght), (char const   */* __restrict  */)"%c",
                (int )P___0[(int )B[i] / 8 + (((int )B[i] & 3) == 2)]);
#line 58
        lenght ++;
        }
      } else {
#line 49
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 60
    if ((int )B[i] == 0) {
#line 60
      counter ++;
    }
#line 49
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 62
  if (counter) {
    {
#line 62
    sprintf((char */* __restrict  */)(s + lenght), (char const   */* __restrict  */)"%i ",
            counter);
    }
  } else {
    {
#line 63
    sprintf((char */* __restrict  */)(s + lenght), (char const   */* __restrict  */)" ");
    }
  }
#line 64
  return;
}
}
#line 74 "/home/wheatley/newnew/temp/phalanx-22+d051004/book.c"
int poscmp(char *p1 , char *p2 ) 
{ 
  register int i ;

  {
#line 77
  i = 0;
  {
#line 77
  while (1) {
    while_continue: /* CIL Label */ ;
#line 77
    if (! (i != 80)) {
#line 77
      goto while_break;
    }
#line 79
    if ((int )*(p1 + i) == 0) {
#line 79
      *(p1 + i) = (char )' ';
    }
#line 80
    if ((int )*(p2 + i) == 0) {
#line 80
      *(p2 + i) = (char )' ';
    }
#line 82
    if ((int )*(p1 + i) < (int )*(p2 + i)) {
#line 82
      return (-1);
    }
#line 83
    if ((int )*(p1 + i) > (int )*(p2 + i)) {
#line 83
      return (1);
    }
#line 84
    if ((int )*(p1 + i) == 32) {
#line 84
      return (0);
    }
#line 77
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 86
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Phalanx error: Opening book corrupted.\n");
#line 87
  exit(2);
  }
}
}
#line 96 "/home/wheatley/newnew/temp/phalanx-22+d051004/book.c"
int linSB(FILE *f , long from , long to , char *p , char *s ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;
  int tmp___3 ;

  {
  {
#line 98
  tmp = fseek(f, from, 0);
  }
#line 98
  if (tmp != 0) {
#line 98
    return (-1);
  }
  {
#line 99
  tmp___0 = feof(f);
  }
#line 99
  if (! tmp___0) {
    {
#line 99
    fgets((char */* __restrict  */)s, 80, (FILE */* __restrict  */)f);
    }
  }
  {
#line 101
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 101
    tmp___2 = ftell(f);
    }
#line 101
    if (tmp___2 <= to) {
      {
#line 101
      tmp___3 = feof(f);
      }
#line 101
      if (tmp___3) {
#line 101
        goto while_break;
      }
    } else {
#line 101
      goto while_break;
    }
    {
#line 103
    fgets((char */* __restrict  */)s, 100, (FILE */* __restrict  */)f);
#line 104
    tmp___1 = poscmp(p, s);
    }
#line 104
    if (tmp___1 == 0) {
#line 104
      return (0);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 107
  return (-1);
}
}
#line 115 "/home/wheatley/newnew/temp/phalanx-22+d051004/book.c"
int binSB(FILE *f , long from , long to , char *p , char *s ) 
{ 
  long mid ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 119
  if (to - from < 512L) {
    {
#line 119
    tmp = linSB(f, from, to, p, s);
    }
#line 119
    return (tmp);
  }
  {
#line 121
  mid = (to + from) / 2L;
#line 122
  tmp___0 = fseek(f, mid, 0);
  }
#line 122
  if (tmp___0 != 0) {
#line 122
    return (-1);
  }
  {
#line 123
  tmp___1 = feof(f);
  }
#line 123
  if (! tmp___1) {
    {
#line 123
    fgets((char */* __restrict  */)s, 80, (FILE */* __restrict  */)f);
    }
  }
  {
#line 125
  tmp___2 = feof(f);
  }
#line 125
  if (! tmp___2) {
    {
#line 125
    fgets((char */* __restrict  */)s, 100, (FILE */* __restrict  */)f);
    }
  }
  {
#line 127
  tmp___3 = poscmp(p, s);
  }
  {
#line 129
  if (tmp___3 == 0) {
#line 129
    goto case_0;
  }
#line 130
  if (tmp___3 == 1) {
#line 130
    goto case_1;
  }
#line 131
  if (tmp___3 == -1) {
#line 131
    goto case_neg_1;
  }
#line 132
  goto switch_default;
  case_0: /* CIL Label */ 
#line 129
  return (0);
  case_1: /* CIL Label */ 
  {
#line 130
  tmp___4 = binSB(f, mid, to, p, s);
  }
#line 130
  return (tmp___4);
  case_neg_1: /* CIL Label */ 
  {
#line 131
  tmp___5 = binSB(f, from, mid, p, s);
  }
#line 131
  return (tmp___5);
  switch_default: /* CIL Label */ 
#line 132
  return (-1);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 138 "/home/wheatley/newnew/temp/phalanx-22+d051004/book.c"
int parsemove(char *inp , tmove *m___1 , int n___1 ) 
{ 
  int special ;
  int from ;
  int to ;
  int in2a ;
  int i ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;

  {
  {
#line 142
  special = 0;
#line 143
  from = ((((int )*(inp + 0) - 97) + 1) + 10 * ((int )*(inp + 1) - 49)) + 20;
#line 144
  to = ((((int )*(inp + 2) - 97) + 1) + 10 * ((int )*(inp + 3) - 49)) + 20;
#line 145
  in2a = 0;
#line 147
  tmp___4 = strncmp((char const   *)inp, "o-o-o", (size_t )5);
  }
#line 147
  if (tmp___4 == 0) {
#line 152
    special = 2;
  } else {
    {
#line 147
    tmp___5 = strncmp((char const   *)inp, "0-0-0", (size_t )5);
    }
#line 147
    if (tmp___5 == 0) {
#line 152
      special = 2;
    } else {
      {
#line 147
      tmp___6 = strncmp((char const   *)inp, "O-O-O", (size_t )5);
      }
#line 147
      if (tmp___6 == 0) {
#line 152
        special = 2;
      } else
#line 147
      if ((int )B[25] == 97) {
        {
#line 147
        tmp___7 = strncmp((char const   *)inp, "e1c1", (size_t )4);
        }
#line 147
        if (tmp___7 == 0) {
#line 152
          special = 2;
        } else {
#line 147
          goto _L___1;
        }
      } else
      _L___1: /* CIL Label */ 
#line 147
      if ((int )B[95] == 98) {
        {
#line 147
        tmp___8 = strncmp((char const   *)inp, "e8c8", (size_t )4);
        }
#line 147
        if (tmp___8 == 0) {
#line 152
          special = 2;
        } else {
#line 147
          goto _L___0;
        }
      } else {
        _L___0: /* CIL Label */ 
        {
#line 153
        tmp = strncmp((char const   *)inp, "o-o", (size_t )3);
        }
#line 153
        if (tmp == 0) {
#line 158
          special = 1;
        } else {
          {
#line 153
          tmp___0 = strncmp((char const   *)inp, "0-0", (size_t )3);
          }
#line 153
          if (tmp___0 == 0) {
#line 158
            special = 1;
          } else {
            {
#line 153
            tmp___1 = strncmp((char const   *)inp, "O-O", (size_t )3);
            }
#line 153
            if (tmp___1 == 0) {
#line 158
              special = 1;
            } else
#line 153
            if ((int )B[25] == 97) {
              {
#line 153
              tmp___2 = strncmp((char const   *)inp, "e1g1", (size_t )4);
              }
#line 153
              if (tmp___2 == 0) {
#line 158
                special = 1;
              } else {
#line 153
                goto _L;
              }
            } else
            _L: /* CIL Label */ 
#line 153
            if ((int )B[95] == 98) {
              {
#line 153
              tmp___3 = strncmp((char const   *)inp, "e8g8", (size_t )4);
              }
#line 153
              if (tmp___3 == 0) {
#line 158
                special = 1;
              }
            }
          }
        }
      }
    }
  }
  {
#line 162
  if ((int )*(inp + 4) == 113) {
#line 162
    goto case_113;
  }
#line 162
  if ((int )*(inp + 4) == 81) {
#line 162
    goto case_113;
  }
#line 163
  if ((int )*(inp + 4) == 114) {
#line 163
    goto case_114;
  }
#line 163
  if ((int )*(inp + 4) == 82) {
#line 163
    goto case_114;
  }
#line 164
  if ((int )*(inp + 4) == 98) {
#line 164
    goto case_98;
  }
#line 164
  if ((int )*(inp + 4) == 66) {
#line 164
    goto case_98;
  }
#line 165
  if ((int )*(inp + 4) == 110) {
#line 165
    goto case_110;
  }
#line 165
  if ((int )*(inp + 4) == 78) {
#line 165
    goto case_110;
  }
#line 166
  goto switch_default;
  case_113: /* CIL Label */ 
  case_81: /* CIL Label */ 
#line 162
  in2a = 80 + Color;
#line 162
  goto switch_break;
  case_114: /* CIL Label */ 
  case_82: /* CIL Label */ 
#line 163
  in2a = 64 + Color;
#line 163
  goto switch_break;
  case_98: /* CIL Label */ 
  case_66: /* CIL Label */ 
#line 164
  in2a = 48 + Color;
#line 164
  goto switch_break;
  case_110: /* CIL Label */ 
  case_78: /* CIL Label */ 
#line 165
  in2a = 32 + Color;
#line 165
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 166
  in2a = (int )B[from];
  switch_break: /* CIL Label */ ;
  }
#line 169
  i = 0;
  {
#line 169
  while (1) {
    while_continue: /* CIL Label */ ;
#line 169
    if (! (i != n___1)) {
#line 169
      goto while_break;
    }
#line 171
    if (special > 0) {
#line 171
      if (special < 21) {
#line 171
        if ((int )(m___1 + i)->special == special) {
#line 173
          return (i);
        } else {
#line 171
          goto _L___3;
        }
      } else {
#line 171
        goto _L___3;
      }
    } else
    _L___3: /* CIL Label */ 
#line 171
    if ((int )(m___1 + i)->from == from) {
#line 171
      if ((int )(m___1 + i)->to == to) {
#line 171
        if ((int )(m___1 + i)->in2a == in2a) {
#line 173
          return (i);
        }
      }
    }
#line 169
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 176
  return (-1);
}
}
#line 182 "/home/wheatley/newnew/temp/phalanx-22+d051004/book.c"
int sbookmoves(int *moves , int *values , tmove *m___1 , int n___1 ) 
{ 
  int index___0 ;
  int i ;
  int64 first ;
  int64 last ;
  int64 middle ;
  unsigned int fkey ;
  unsigned int lkey ;
  unsigned int pos ;
  long booksize ;
  FILE *f ;
  int hits ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  unsigned short sm ;
  unsigned int tmp___2 ;

  {
#line 185
  last = (int64 )0;
#line 185
  middle = (int64 )0;
#line 190
  hits = 0;
#line 192
  f = Sbook.f;
#line 192
  if ((unsigned long )f == (unsigned long )((void *)0)) {
#line 192
    return (-1);
  }
#line 194
  if (G[Counter].hashboard < Sbook.firstkey) {
#line 195
    return (-1);
  } else
#line 194
  if (G[Counter].hashboard > Sbook.lastkey) {
#line 195
    return (-1);
  }
#line 197
  fkey = Sbook.firstkey;
#line 197
  lkey = Sbook.lastkey;
#line 199
  booksize = (long )(Sbook.filesize / 6);
#line 201
  first = (int64 )0;
#line 201
  last = (int64 )(booksize - 1L);
#line 202
  if (G[Counter].hashboard == Sbook.firstkey) {
#line 202
    middle = (int64 )0;
  } else
#line 203
  if (G[Counter].hashboard == Sbook.lastkey) {
#line 203
    middle = (int64 )(booksize - 1L);
  } else {
    {
#line 205
    while (1) {
      while_continue: /* CIL Label */ ;
#line 205
      if (! (first < last)) {
#line 205
        goto while_break;
      }
#line 209
      middle = ((int64 )(G[Counter].hashboard - fkey) * (last - first)) / (int64 )(lkey - fkey) + first;
#line 212
      if (middle == first) {
#line 212
        middle ++;
      }
#line 212
      if (middle == last) {
#line 212
        middle --;
      }
#line 213
      if (middle == first) {
#line 218
        return (-1);
      }
      {
#line 221
      tmp = fseek(f, (long )(middle * 6LL), 0);
      }
#line 221
      if (tmp != 0) {
#line 221
        return (-1);
      }
      {
#line 222
      myfread((void *)(& pos), (int )sizeof(unsigned int ), f);
#line 222
      hits ++;
      }
#line 224
      if (pos < G[Counter].hashboard) {
#line 224
        first = middle;
#line 224
        fkey = pos;
      } else
#line 225
      if (pos == G[Counter].hashboard) {
#line 225
        goto while_break;
      } else {
#line 226
        last = middle;
#line 226
        lkey = pos;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 238
  if (middle == 0LL) {
#line 238
    pos = G[Counter].hashboard;
  } else {
    {
#line 240
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 242
      middle --;
#line 243
      tmp___0 = fseek(f, (long )(middle * 6LL), 0);
      }
#line 243
      if (tmp___0 != 0) {
#line 243
        return (-1);
      }
      {
#line 244
      myfread((void *)(& pos), (int )sizeof(unsigned int ), f);
      }
#line 240
      if (middle > 0LL) {
#line 240
        if (! (pos == G[Counter].hashboard)) {
#line 240
          goto while_break___0;
        }
      } else {
#line 240
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 247
  if (pos != G[Counter].hashboard) {
#line 248
    middle ++;
#line 248
    pos = G[Counter].hashboard;
  }
  {
#line 251
  index___0 = 0;
#line 252
  tmp___1 = fseek(f, (long )(middle * 6LL + 4LL), 0);
  }
#line 252
  if (tmp___1 != 0) {
#line 252
    return (-1);
  }
  {
#line 253
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 253
    if (middle < (int64 )booksize) {
#line 253
      if (! (pos == G[Counter].hashboard)) {
#line 253
        goto while_break___1;
      }
    } else {
#line 253
      goto while_break___1;
    }
    {
#line 257
    myfread((void *)(& sm), (int )sizeof(unsigned short ), f);
#line 258
    i = 0;
    }
    {
#line 258
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 258
      if (! (i != n___1)) {
#line 258
        goto while_break___2;
      }
      {
#line 258
      tmp___2 = smove(m___1 + i);
      }
#line 258
      if ((unsigned int )sm == tmp___2) {
#line 259
        *(moves + index___0) = i;
#line 259
        *(values + index___0) = 100;
#line 259
        index___0 ++;
      }
#line 258
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 261
    myfread((void *)(& pos), (int )sizeof(unsigned int ), f);
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 264
  return (index___0);
}
}
#line 275 "/home/wheatley/newnew/temp/phalanx-22+d051004/book.c"
int bookmoves(int *moves , int *values , tmove *m___1 , int n___1 ) 
{ 
  char s[256] ;
  char p[256] ;
  int index___0 ;
  int i ;
  long booksize ;
  FILE *f ;
  int tmp ;
  int pm ;

  {
#line 282
  f = Pbook.f;
#line 282
  if ((unsigned long )f == (unsigned long )((void *)0)) {
#line 282
    return (-1);
  }
  {
#line 284
  booksize = (long )Pbook.filesize;
#line 286
  postr(p);
#line 287
  tmp = binSB(f, 0L, booksize, p, s);
  }
#line 287
  if (tmp == -1) {
#line 288
    return (-1);
  }
#line 291
  index___0 = 0;
#line 292
  i = 0;
  {
#line 292
  while (1) {
    while_continue: /* CIL Label */ ;
#line 292
    if (! ((int )s[i] != 10)) {
#line 292
      goto while_break;
    }
    {
#line 295
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 295
      if ((int )s[i] != 32) {
#line 295
        if (! ((int )s[i] != 10)) {
#line 295
          goto while_break___0;
        }
      } else {
#line 295
        goto while_break___0;
      }
#line 297
      if ((int )s[i] == 33) {
#line 297
        if (index___0) {
#line 297
          *(values + (index___0 - 1)) += 100;
        }
      }
#line 298
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 300
    if ((int )s[i] == 10) {
#line 300
      goto while_break;
    }
#line 300
    i ++;
#line 300
    if ((int )s[i] == 10) {
#line 300
      goto while_break;
    }
    {
#line 301
    pm = parsemove(& s[i], m___1, n___1);
    }
#line 301
    if (pm != -1) {
#line 302
      *(moves + index___0) = pm;
#line 302
      *(values + index___0) = 100;
#line 302
      index___0 ++;
    }
#line 292
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 305
  return (index___0);
}
}
#line 314 "/home/wheatley/newnew/temp/phalanx-22+d051004/book.c"
int bookmove(tmove *m___1 , int n___1 ) 
{ 
  int moves[80] ;
  int values[80] ;
  int index___0 ;
  int foundtxt ;
  int ii ;
  int sumvalues ;
  int rn ;
  int tmp ;
  int i ;
  char s[128] ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  char sm[64] ;

  {
  {
#line 317
  foundtxt = 0;
#line 319
  index___0 = bookmoves(moves, values, m___1, n___1);
  }
#line 320
  if (index___0 <= 0) {
    {
#line 320
    index___0 = sbookmoves(moves, values, m___1, n___1);
    }
  } else {
#line 340
    foundtxt = 1;
  }
#line 343
  if (index___0 > 0) {
#line 345
    sumvalues = 0;
#line 346
    ii = 0;
    {
#line 346
    while (1) {
      while_continue: /* CIL Label */ ;
#line 346
      if (! (ii != index___0)) {
#line 346
        goto while_break;
      }
#line 347
      sumvalues += values[ii];
#line 346
      ii ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 349
    tmp = rand();
#line 349
    rn = tmp % sumvalues;
#line 351
    sumvalues = 0;
#line 352
    ii = 0;
    }
    {
#line 352
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 352
      if (! (ii != index___0)) {
#line 352
        goto while_break___0;
      }
#line 353
      sumvalues += values[ii];
#line 353
      if (sumvalues >= rn) {
#line 353
        goto while_break___0;
      }
#line 352
      ii ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 355
    if (Flag.post) {
#line 358
      if (Flag.xboard) {
        {
#line 359
        sprintf((char */* __restrict  */)(s), (char const   */* __restrict  */)"   0      0       0      0  book");
        }
      } else {
        {
#line 361
        sprintf((char */* __restrict  */)(s), (char const   */* __restrict  */)"Book moves ");
        }
      }
#line 362
      if (foundtxt) {
        {
#line 362
        tmp___0 = strlen((char const   *)(s));
#line 362
        sprintf((char */* __restrict  */)(s + tmp___0), (char const   */* __restrict  */)"1 ");
        }
      } else {
        {
#line 363
        tmp___1 = strlen((char const   *)(s));
#line 363
        sprintf((char */* __restrict  */)(s + tmp___1), (char const   */* __restrict  */)"2 ");
        }
      }
#line 364
      i = 0;
      {
#line 364
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 364
        if (! (i != index___0)) {
#line 364
          goto while_break___1;
        }
        {
#line 365
        tmp___2 = strlen((char const   *)(s));
#line 365
        printm(*(m___1 + moves[i]), s + tmp___2);
#line 364
        i ++;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 366
      tmp___3 = strlen((char const   *)(s));
#line 366
      sprintf((char */* __restrict  */)(s + tmp___3), (char const   */* __restrict  */)"\n");
#line 367
      puts((char const   *)(s));
      }
#line 368
      if ((unsigned long )Flag.log != (unsigned long )((void *)0)) {
#line 368
        if (Flag.ponder < 2) {
#line 371
          if (Flag.xboard) {
            {
#line 371
            fputs((char const   */* __restrict  */)(s + 26), (FILE */* __restrict  */)Flag.log);
            }
          } else {
            {
#line 372
            fputs((char const   */* __restrict  */)(s), (FILE */* __restrict  */)Flag.log);
            }
          }
          {
#line 373
          fputs((char const   */* __restrict  */)"  selected move ", (FILE */* __restrict  */)Flag.log);
#line 374
          printm(*(m___1 + moves[ii]), sm);
#line 375
          fputs((char const   */* __restrict  */)(sm), (FILE */* __restrict  */)Flag.log);
#line 376
          fputs((char const   */* __restrict  */)"\n", (FILE */* __restrict  */)Flag.log);
          }
        }
      }
    }
#line 379
    return (moves[ii]);
  }
#line 382
  return (-1);
}
}
#line 390 "/home/wheatley/newnew/temp/phalanx-22+d051004/book.c"
FILE *Eco  =    (FILE *)((void *)0);
#line 399
void bk(tmove *m___1 , int n___1 ) ;
#line 399 "/home/wheatley/newnew/temp/phalanx-22+d051004/book.c"
static int att  =    1;
#line 400 "/home/wheatley/newnew/temp/phalanx-22+d051004/book.c"
static int seco  =    0;
#line 404 "/home/wheatley/newnew/temp/phalanx-22+d051004/book.c"
static struct teco *peco  =    (struct teco *)((void *)0);
#line 391 "/home/wheatley/newnew/temp/phalanx-22+d051004/book.c"
void bk(tmove *m___1 , int n___1 ) 
{ 
  int moves[80] ;
  int values[80] ;
  int idx ;
  int pass ;
  int sumvalues ;
  int c ;
  tmove *move ;
  void *tmp ;
  tmove m___2[128] ;
  char ms[32] ;
  int msi ;
  int n___2 ;
  long tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int counter ;
  int text ;
  int i ;
  char t[128] ;
  char *c___0 ;
  int i___0 ;
  int i___1 ;
  char c___1[128] ;

  {
#line 395
  sumvalues = 0;
#line 401
  if (att != 0) {
#line 401
    if ((unsigned long )Eco != (unsigned long )((void *)0)) {
#line 405
      if (att == 1) {
#line 405
        if (Counter == 0) {
#line 405
          if (G[Counter].hashboard == 961620240U) {
            {
#line 408
            tmp = malloc(2048UL * sizeof(teco ));
#line 408
            peco = (struct teco *)tmp;
            }
#line 409
            if ((unsigned long )peco == (unsigned long )((void *)0)) {
              {
#line 410
              puts(" telluser cannot alloc memory for ECO");
#line 411
              att = 0;
              }
#line 411
              goto abort;
            }
            {
#line 413
            printf((char const   */* __restrict  */)"telluser creating ECO index, please wait\n");
            }
            {
#line 415
            while (1) {
              while_continue: /* CIL Label */ ;
              {
#line 415
              c = fgetc(Eco);
              }
#line 415
              if (! (c != 91)) {
#line 415
                goto while_break;
              }
#line 415
              if (c == -1) {
#line 415
                goto doneinit;
              }
            }
            while_break: /* CIL Label */ ;
            }
            {
#line 416
            while (1) {
              while_continue___0: /* CIL Label */ ;
              {
#line 420
              tmp___0 = ftell(Eco);
#line 420
              (peco + seco)->point = (unsigned int )(tmp___0 - 1L);
              }
              {
#line 421
              while (1) {
                while_continue___1: /* CIL Label */ ;
                {
#line 421
                c = _IO_getc(Eco);
                }
#line 421
                if (! (c != 93)) {
#line 421
                  goto while_break___1;
                }
#line 421
                if (c == -1) {
#line 421
                  goto doneinit;
                }
              }
              while_break___1: /* CIL Label */ ;
              }
#line 422
              if (c == -1) {
#line 422
                goto doneinit;
              }
              {
#line 423
              setfen((char *)"rnbqkbnr/pppppppp/////PPPPPPPP/RNBQKBNR/w");
              }
              {
#line 424
              while (1) {
                while_continue___2: /* CIL Label */ ;
#line 426
                msi = 0;
                {
#line 427
                while (1) {
                  while_continue___3: /* CIL Label */ ;
                  {
#line 427
                  c = _IO_getc(Eco);
                  }
#line 427
                  if (! (c == 32)) {
#line 427
                    if (! (c == 10)) {
#line 427
                      goto while_break___3;
                    }
                  }
                }
                while_break___3: /* CIL Label */ ;
                }
                {
#line 428
                ungetc(c, Eco);
                }
                {
#line 429
                while (1) {
                  while_continue___4: /* CIL Label */ ;
                  {
#line 429
                  c = _IO_getc(Eco);
                  }
#line 429
                  if (c != 32) {
#line 429
                    if (c != 10) {
#line 429
                      if (! (msi <= 30)) {
#line 429
                        goto while_break___4;
                      }
                    } else {
#line 429
                      goto while_break___4;
                    }
                  } else {
#line 429
                    goto while_break___4;
                  }
#line 430
                  ms[msi] = (char )c;
#line 430
                  msi ++;
#line 431
                  if (c == -1) {
                    {
#line 432
                    ungetc(c, Eco);
                    }
#line 432
                    goto nextgame;
                  } else
#line 431
                  if (c == 91) {
                    {
#line 432
                    ungetc(c, Eco);
                    }
#line 432
                    goto nextgame;
                  }
                }
                while_break___4: /* CIL Label */ ;
                }
#line 434
                ms[msi] = (char )'\000';
#line 435
                if (Color == 1) {
#line 435
                  tmp___1 = (int )L[1].next;
                } else {
#line 435
                  tmp___1 = (int )L[2].next;
                }
                {
#line 435
                tmp___2 = attacktest(tmp___1, Color ^ 3);
#line 435
                generate_legal_moves(m___2, & n___2, tmp___2);
#line 436
                move = sandex(ms, m___2, n___2);
                }
#line 437
                if ((unsigned long )move == (unsigned long )((void *)0)) {
#line 437
                  goto nextgame;
                }
                {
#line 438
                do_move(move);
                }
#line 439
                if (c == -1) {
#line 439
                  goto doneinit;
                }
              }
              while_break___2: /* CIL Label */ ;
              }
              nextgame: 
#line 442
              (peco + seco)->hashboard = G[Counter].hashboard;
#line 443
              seco ++;
              {
#line 444
              while (1) {
                while_continue___5: /* CIL Label */ ;
                {
#line 444
                c = fgetc(Eco);
                }
#line 444
                if (! (c != 91)) {
#line 444
                  goto while_break___5;
                }
#line 444
                if (c == -1) {
#line 444
                  goto doneinit;
                }
              }
              while_break___5: /* CIL Label */ ;
              }
            }
            while_break___0: /* CIL Label */ ;
            }
            doneinit: 
            {
#line 448
            printf((char const   */* __restrict  */)" parsed %i ECO records\n", seco);
#line 449
            att = 2;
#line 450
            setfen((char *)"rnbqkbnr/pppppppp/////PPPPPPPP/RNBQKBNR/w");
            }
          }
        }
      }
#line 453
      if (Counter > 0) {
#line 453
        if (att > 1) {
#line 455
          counter = Counter;
#line 456
          text = -1;
          {
#line 457
          while (1) {
            while_continue___6: /* CIL Label */ ;
#line 457
            if (! (Counter > 0)) {
#line 457
              goto while_break___6;
            }
#line 460
            i = 0;
            {
#line 460
            while (1) {
              while_continue___7: /* CIL Label */ ;
#line 460
              if (! (i != seco)) {
#line 460
                goto while_break___7;
              }
#line 461
              if ((peco + i)->hashboard == G[Counter].hashboard) {
#line 462
                text = (int )(peco + i)->point;
#line 462
                goto foundeco;
              }
#line 460
              i ++;
            }
            while_break___7: /* CIL Label */ ;
            }
            {
#line 463
            undo_move(& G[Counter - 1].m);
            }
          }
          while_break___6: /* CIL Label */ ;
          }
          foundeco: ;
          {
#line 466
          while (1) {
            while_continue___8: /* CIL Label */ ;
#line 466
            if (! (counter > Counter)) {
#line 466
              goto while_break___8;
            }
            {
#line 466
            do_move(& G[Counter].m);
            }
          }
          while_break___8: /* CIL Label */ ;
          }
#line 467
          if (text == -1) {
            {
#line 467
            printf((char const   */* __restrict  */)" no eco found\n");
            }
          } else {
            {
#line 470
            fseek(Eco, (long )text, 0);
#line 471
            fgets((char */* __restrict  */)(t), 126, (FILE */* __restrict  */)Eco);
#line 472
            t[127] = (char )'\000';
#line 473
            c___0 = index((char const   *)(t), '[');
            }
#line 473
            if ((unsigned long )c___0 != (unsigned long )((void *)0)) {
#line 473
              *c___0 = (char )' ';
            }
            {
#line 474
            c___0 = rindex((char const   *)(t), ']');
            }
#line 474
            if ((unsigned long )c___0 != (unsigned long )((void *)0)) {
#line 474
              *c___0 = (char )'\000';
            }
            {
#line 475
            puts((char const   *)(t));
            }
          }
        }
      }
      abort: ;
    }
  }
#line 482
  pass = 0;
  {
#line 482
  while (1) {
    while_continue___9: /* CIL Label */ ;
#line 482
    if (! (pass != 2)) {
#line 482
      goto while_break___9;
    }
#line 484
    if (pass == 0) {
      {
#line 487
      idx = bookmoves(moves, values, m___1, n___1);
      }
#line 488
      if (idx != -1) {
#line 488
        i___0 = 0;
        {
#line 488
        while (1) {
          while_continue___10: /* CIL Label */ ;
#line 488
          if (! (i___0 != idx)) {
#line 488
            goto while_break___10;
          }
#line 488
          sumvalues += values[i___0];
#line 488
          i___0 ++;
        }
        while_break___10: /* CIL Label */ ;
        }
      }
      {
#line 489
      printf((char const   */* __restrict  */)" primary book moves\n");
      }
    } else {
      {
#line 493
      idx = sbookmoves(moves, values, m___1, n___1);
#line 494
      printf((char const   */* __restrict  */)" secondary book moves\n");
      }
    }
#line 497
    if (idx > 0) {
#line 499
      i___1 = 0;
      {
#line 499
      while (1) {
        while_continue___11: /* CIL Label */ ;
#line 499
        if (! (i___1 != idx)) {
#line 499
          goto while_break___11;
        }
#line 500
        if (i___1 == 0) {
#line 500
          goto _L;
        } else
#line 500
        if (moves[i___1 - 1] != moves[i___1]) {
          _L: /* CIL Label */ 
          {
#line 502
          printf((char const   */* __restrict  */)"   ");
#line 503
          printm(*(m___1 + moves[i___1]), (char *)((void *)0));
          }
#line 504
          if (pass == 0) {
            {
#line 505
            printf((char const   */* __restrict  */)"%3d%%\n", (values[i___1] * 100) / sumvalues);
            }
          } else {
            {
#line 506
            printf((char const   */* __restrict  */)"\n");
            }
          }
        }
#line 499
        i___1 ++;
      }
      while_break___11: /* CIL Label */ ;
      }
    } else {
      {
#line 510
      printf((char const   */* __restrict  */)"   no move found\n");
      }
    }
#line 482
    pass ++;
  }
  while_break___9: /* CIL Label */ ;
  }
#line 514
  if (Flag.xboard > 1) {
    {
#line 514
    puts("");
    }
  }
  {
#line 516
  postr(c___1);
#line 516
  printf((char const   */* __restrict  */)"%s\n", c___1);
  }
#line 518
  return;
}
}
#line 168 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 858
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) fileno)(FILE *__stream ) ;
#line 106 "/usr/include/x86_64-linux-gnu/sys/select.h"
extern int select(int __nfds , fd_set * __restrict  __readfds , fd_set * __restrict  __writefds ,
                  fd_set * __restrict  __exceptfds , struct timeval * __restrict  __timeout ) ;
#line 775 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) abs)(int __x )  __attribute__((__const__)) ;
#line 402 "/home/wheatley/newnew/temp/phalanx-22+d051004/phalanx.h"
tdist dist[14400] ;
#line 403
tknow Wknow ;
#line 403
tknow Bknow ;
#line 405
int LastIter ;
#line 406
int Depth ;
#line 407
int Ply ;
#line 408
int FollowPV ;
#line 409
int Totmat ;
#line 410
int Abort ;
#line 414
int DrawScore ;
#line 420
int64 Nodes ;
#line 430
int Values[7] ;
#line 433
tmove PV[40][40] ;
#line 441
unsigned int SizeHT ;
#line 453
int A_n ;
#line 453
int A_i ;
#line 454
tmove *A_m ;
#line 474
void verboseline(tmove *m___1 , int i , int n___1 ) ;
#line 482
void interrupt(int x ) ;
#line 488
void generate_legal_captures(tmove *moves , int *n___1 , int minval ) ;
#line 489
void generate_legal_checks(tmove *moves , int *n___1 ) ;
#line 490
int see(tsquare *b , int from , int square___0 ) ;
#line 492
int search(tmove *m___1 , int n___1 , int Alpha , int Beta ) ;
#line 493
int csearch(tmove *m___1 , int n___1 , int Alpha , int Beta , int extend ) ;
#line 496
__inline int repetition(int n___1 ) ;
#line 497
int material_draw(void) ;
#line 498
int evaluate(int Alpha , int Beta ) ;
#line 500
int score_position(void) ;
#line 512
thashentry *seekHT(void) ;
#line 513
void writeHT(int value , int Alpha , int Beta ) ;
#line 519
long ptime(void) ;
#line 528
int rlearn(void) ;
#line 533
void write_killer(int from , int to ) ;
#line 534
void add_killer(tmove *m___1 , int n___1 , thashentry *ht ) ;
#line 32 "/home/wheatley/newnew/temp/phalanx-22+d051004/evaluate.c"
unsigned int *C  ;
#line 37 "/home/wheatley/newnew/temp/phalanx-22+d051004/evaluate.c"
void blunder(tmove *m___1 , int *n___1 ) 
{ 
  int i ;
  int initp ;
  int p ;
  int tmp ;

  {
#line 40
  initp = (int )Flag.easy;
#line 43
  initp -= Depth / 10;
#line 46
  initp += Ply * 2;
#line 49
  initp += ((int )G[Counter].mtrl + (int )G[Counter].xmtrl) / 200;
#line 51
  if (Counter > 1) {
#line 52
    i = *n___1 - 1;
    {
#line 52
    while (1) {
      while_continue: /* CIL Label */ ;
#line 52
      if (i >= 0) {
#line 52
        if (! (*n___1 > 4)) {
#line 52
          goto while_break;
        }
      } else {
#line 52
        goto while_break;
      }
#line 55
      p = initp;
#line 58
      if ((int )(m___1 + i)->to == (int )G[Counter - 1].m.to) {
#line 59
        p -= 30;
      }
#line 62
      if ((int )(m___1 + i)->in2 != 0) {
#line 62
        if (((int )(m___1 + i)->from & 252) == 16) {
#line 63
          p -= 40;
        }
      }
      {
#line 67
      if (dist[120 * (int )(m___1 + i)->from + (int )(m___1 + i)->to].max == 1U) {
#line 67
        goto case_1;
      }
#line 67
      if (dist[120 * (int )(m___1 + i)->from + (int )(m___1 + i)->to].max == 0U) {
#line 67
        goto case_1;
      }
#line 68
      if (dist[120 * (int )(m___1 + i)->from + (int )(m___1 + i)->to].max == 2U) {
#line 68
        goto case_2;
      }
#line 69
      if (dist[120 * (int )(m___1 + i)->from + (int )(m___1 + i)->to].max == 3U) {
#line 69
        goto case_3;
      }
#line 66
      goto switch_break;
      case_1: /* CIL Label */ 
      case_0: /* CIL Label */ 
#line 67
      p -= 80;
#line 67
      goto switch_break;
      case_2: /* CIL Label */ 
#line 68
      p -= 50;
#line 68
      goto switch_break;
      case_3: /* CIL Label */ 
#line 69
      p -= 10;
#line 69
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
#line 73
      if ((int )(m___1 + i)->in1 != (int )(m___1 + i)->in2a) {
#line 73
        if (((int )(m___1 + i)->in2a & 252) != 80) {
#line 74
          p += 10;
        } else {
#line 76
          p -= 10;
        }
      } else {
#line 76
        p -= 10;
      }
#line 79
      p = (int )((unsigned int )p + dist[120 * (int )(m___1 + i)->from + (int )(m___1 + i)->to].taxi * 2U);
#line 82
      if (((int )(m___1 + i)->in1 & 252) == 32) {
#line 83
        p += 10;
      }
#line 87
      if (Color == 1) {
#line 88
        p += 3 * ((int )(m___1 + i)->to / 10 - (int )(m___1 + i)->from / 10);
      } else {
#line 90
        p += 3 * ((int )(m___1 + i)->from / 10 - (int )(m___1 + i)->to / 10);
      }
      {
#line 92
      tmp = rand();
      }
#line 92
      if (tmp % 128 < p) {
#line 93
        *(m___1 + i) = *(m___1 + (*n___1 - 1));
#line 93
        (*n___1) --;
      }
#line 52
      i --;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 95
  return;
}
}
#line 99 "/home/wheatley/newnew/temp/phalanx-22+d051004/evaluate.c"
void initcache(void) 
{ 
  void *tmp ;

  {
  {
#line 102
  tmp = malloc(65536UL * sizeof(unsigned int ));
#line 102
  C = (unsigned int *)tmp;
  }
#line 103
  if ((unsigned long )C == (unsigned long )((void *)0)) {
    {
#line 103
    puts("cannot alloc static eval cache!");
#line 103
    exit(0);
    }
  }
#line 105
  return;
}
}
#line 108 "/home/wheatley/newnew/temp/phalanx-22+d051004/evaluate.c"
int psnl[40]  ;
#line 109 "/home/wheatley/newnew/temp/phalanx-22+d051004/evaluate.c"
int devi[40]  ;
#line 111 "/home/wheatley/newnew/temp/phalanx-22+d051004/evaluate.c"
int approx_eval(void) 
{ 
  int tmp ;

  {
  {
#line 113
  psnl[Ply] = - psnl[Ply - 1];
#line 115
  tmp = abs(psnl[Ply]);
#line 115
  devi[Ply] = (devi[Ply - 1] * 2) / 3 + tmp / 8;
  }
#line 116
  if (G[Counter - 1].m.in2) {
#line 116
    devi[Ply] += 60;
  } else {
#line 116
    devi[Ply] += 40;
  }
#line 118
  return (((int )G[Counter].mtrl - (int )G[Counter].xmtrl) + psnl[Ply]);
}
}
#line 123 "/home/wheatley/newnew/temp/phalanx-22+d051004/evaluate.c"
int static_eval(void) 
{ 
  int positional ;
  int r50 ;
  int material ;
  unsigned int *cc ;
  unsigned int *cc___0 ;

  {
#line 127
  r50 = 100 - (int )G[Counter].rule50;
#line 128
  material = (int )G[Counter].mtrl - (int )G[Counter].xmtrl;
#line 131
  if (((*(C + (65535U & G[Counter].hashboard)) ^ G[Counter].hashboard) & 4294901760U) == 0U) {
#line 134
    cc = C + (65535U & G[Counter].hashboard);
#line 135
    Wknow.prune = (signed char )((*cc & 20479U) != 0U);
#line 136
    Bknow.prune = (signed char )((*cc & 36863U) != 0U);
#line 137
    return ((int )(*cc & 16383U));
  }
  {
#line 141
  positional = score_position();
  }
#line 143
  if (r50 < 24) {
#line 144
    positional = (positional * r50) / 24;
#line 145
    material = (material * r50) / 24;
  }
#line 167
  cc___0 = C + (65535U & G[Counter].hashboard);
#line 168
  *cc___0 = (4294901760U & G[Counter].hashboard) | (unsigned int )(material + positional);
#line 169
  if (Wknow.prune) {
#line 169
    *cc___0 |= 16384U;
  } else {
#line 169
    *cc___0 &= 4294950911U;
  }
#line 170
  if (Bknow.prune) {
#line 170
    *cc___0 |= 32768U;
  } else {
#line 170
    *cc___0 &= 4294934527U;
  }
#line 174
  psnl[Ply] = positional;
#line 175
  devi[Ply] = 0;
#line 186
  return (material + positional);
}
}
#line 192 "/home/wheatley/newnew/temp/phalanx-22+d051004/evaluate.c"
__inline int repetition(int n___1 ) 
{ 
  int i ;
  int r ;
  unsigned int board ;

  {
#line 195
  r = 0;
#line 196
  board = G[Counter].hashboard;
#line 197
  i = Counter - 2;
  {
#line 197
  while (1) {
    while_continue: /* CIL Label */ ;
#line 197
    if (! (i >= 0)) {
#line 197
      goto while_break;
    }
#line 199
    if (G[i].hashboard == board) {
#line 199
      r ++;
#line 199
      if (r == n___1) {
#line 199
        return (1);
      }
    }
#line 200
    if ((int )G[i].rule50 <= 1) {
#line 200
      goto while_break;
    }
#line 197
    i -= 2;
  }
  while_break: /* CIL Label */ ;
  }
#line 202
  return (0);
}
}
#line 207 "/home/wheatley/newnew/temp/phalanx-22+d051004/evaluate.c"
int material_draw(void) 
{ 
  int i ;
  int n___1 ;

  {
#line 209
  n___1 = 2;
#line 211
  i = (int )L[L[1].next].next;
  {
#line 211
  while (1) {
    while_continue: /* CIL Label */ ;
#line 211
    if (! (i != 0)) {
#line 211
      goto while_break;
    }
    {
#line 213
    if ((int )B[i] == 17) {
#line 213
      goto case_17;
    }
#line 213
    if ((int )B[i] == 65) {
#line 213
      goto case_17;
    }
#line 213
    if ((int )B[i] == 81) {
#line 213
      goto case_17;
    }
#line 214
    goto switch_default;
    case_17: /* CIL Label */ 
    case_65: /* CIL Label */ 
    case_81: /* CIL Label */ 
#line 213
    return (0);
    switch_default: /* CIL Label */ 
#line 214
    n___1 --;
#line 214
    if (n___1 == 0) {
#line 214
      return (0);
    }
    switch_break: /* CIL Label */ ;
    }
#line 211
    i = (int )L[i].next;
  }
  while_break: /* CIL Label */ ;
  }
#line 217
  i = (int )L[L[2].next].next;
  {
#line 217
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 217
    if (! (i != 0)) {
#line 217
      goto while_break___0;
    }
    {
#line 219
    if ((int )B[i] == 18) {
#line 219
      goto case_18;
    }
#line 219
    if ((int )B[i] == 66) {
#line 219
      goto case_18;
    }
#line 219
    if ((int )B[i] == 82) {
#line 219
      goto case_18;
    }
#line 220
    goto switch_default___0;
    case_18: /* CIL Label */ 
    case_66: /* CIL Label */ 
    case_82: /* CIL Label */ 
#line 219
    return (0);
    switch_default___0: /* CIL Label */ 
#line 220
    n___1 --;
#line 220
    if (n___1 == 0) {
#line 220
      return (0);
    }
    switch_break___0: /* CIL Label */ ;
    }
#line 217
    i = (int )L[i].next;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 223
  return (1);
}
}
#line 233 "/home/wheatley/newnew/temp/phalanx-22+d051004/evaluate.c"
static int timeslice  =    2000;
#line 249
long T1 ;
#line 263 "/home/wheatley/newnew/temp/phalanx-22+d051004/evaluate.c"
static int slice  =    4000;
#line 264 "/home/wheatley/newnew/temp/phalanx-22+d051004/evaluate.c"
static int64 lnodes  =    (int64 )0;
#line 267 "/home/wheatley/newnew/temp/phalanx-22+d051004/evaluate.c"
static long lptime  =    0L;
#line 281 "/home/wheatley/newnew/temp/phalanx-22+d051004/evaluate.c"
static fd_set readfds  ;
#line 282 "/home/wheatley/newnew/temp/phalanx-22+d051004/evaluate.c"
static struct timeval tv  ;
#line 230 "/home/wheatley/newnew/temp/phalanx-22+d051004/evaluate.c"
int evaluate(int Alpha , int Beta ) 
{ 
  int result ;
  tmove m___1[256] ;
  int n___1 ;
  thashentry *t ;
  int check ;
  int lastiter ;
  int depthplus ;
  int totmat ;
  int t___1 ;
  long tmp ;
  long nptime ;
  long tmp___0 ;
  int data ;
  int __d0 ;
  int __d1 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int j ;
  int ext ;
  int tmp___8 ;
  int tmp___9 ;
  int val ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int value ;
  int olddepth ;
  int alpha ;
  tmove m___2[256] ;
  int n___2 ;
  int tmp___14 ;
  int tmp___15 ;
  int i ;
  int newdch ;
  int inrow ;
  int i___0 ;
  int i___1 ;
  int j___0 ;
  int support ;
  int newdch___0 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int i___2 ;
  int t___2 ;
  int v1 ;
  int v2 ;
  int newdch___1 ;
  int tmp___19 ;
  int tmp___20 ;
  int i___3 ;
  int target ;
  int cdch ;
  int lresult ;
  int tmp___21 ;

  {
#line 239
  depthplus = 0;
#line 240
  Totmat = (int )G[Counter].mtrl + (int )G[Counter].xmtrl;
#line 240
  totmat = Totmat;
#line 242
  if (Ply % 2) {
#line 242
    lastiter = - LastIter;
  } else {
#line 242
    lastiter = LastIter;
  }
#line 244
  Nodes ++;
#line 246
  if ((unsigned int )Flag.level == 2U) {
#line 246
    goto _L;
  } else
#line 246
  if ((unsigned int )Flag.level == 0U) {
    _L: /* CIL Label */ 
#line 247
    if (Nodes % (long long )timeslice == 0LL) {
#line 247
      if (! Flag.analyze) {
        {
#line 250
        tmp = ptime();
#line 250
        t___1 = (int )(((long )Flag.centiseconds - tmp) + T1);
        }
#line 252
        if (t___1 < 0) {
#line 252
          if (Flag.ponder >= 2) {
#line 252
            Flag.ponder = 3;
          } else {
#line 252
            Abort = 2;
          }
        } else
#line 254
        if (t___1 != Flag.centiseconds) {
#line 255
          timeslice = (int )((((Nodes * (int64 )t___1) / (int64 )(Flag.centiseconds - t___1)) * 2LL) / 3LL);
        }
#line 258
        if (timeslice > 5 * Flag.centiseconds) {
#line 258
          timeslice = 5 * Flag.centiseconds;
        }
#line 259
        if (timeslice < 50) {
#line 259
          timeslice = 50;
        }
      }
    }
  }
#line 265
  if (lnodes + (int64 )slice < Nodes) {
#line 265
    goto _L___0;
  } else
#line 265
  if (Nodes == 1LL) {
    _L___0: /* CIL Label */ 
    {
#line 268
    tmp___0 = ptime();
#line 268
    nptime = tmp___0;
    }
#line 270
    if (nptime == lptime) {
#line 270
      nptime ++;
    }
#line 272
    if (nptime - lptime < 100L) {
#line 272
      slice = (slice * 11) / 10;
    } else {
#line 273
      slice = (slice * 10) / 11;
    }
#line 275
    lptime = nptime;
#line 277
    if (Flag.post) {
#line 277
      if (! Flag.xboard) {
        {
#line 277
        verboseline(A_m, A_i, A_n);
        }
      }
    }
#line 279
    if (Flag.polling) {
      {
#line 285
      while (1) {
        while_continue: /* CIL Label */ ;
#line 285
        __asm__  volatile   ("cld; rep; "
                             "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                             "1" (& readfds.fds_bits[0]): "memory");
#line 285
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 286
      tmp___1 = fileno(stdin);
#line 286
      tmp___2 = fileno(stdin);
#line 286
      readfds.fds_bits[tmp___1 / (8 * (int )sizeof(__fd_mask ))] |= 1L << tmp___2 % (8 * (int )sizeof(__fd_mask ));
#line 287
      tv.tv_sec = (__time_t )0;
#line 288
      tv.tv_usec = (__suseconds_t )0;
#line 289
      select(16, (fd_set */* __restrict  */)(& readfds), (fd_set */* __restrict  */)0,
             (fd_set */* __restrict  */)0, (struct timeval */* __restrict  */)(& tv));
#line 290
      tmp___3 = fileno(stdin);
#line 290
      tmp___4 = fileno(stdin);
#line 290
      data = (readfds.fds_bits[tmp___3 / (8 * (int )sizeof(__fd_mask ))] & (1L << tmp___4 % (8 * (int )sizeof(__fd_mask )))) != 0L;
      }
#line 291
      if (data) {
        {
#line 291
        interrupt(0);
        }
      }
    }
#line 299
    lnodes = Nodes;
  }
#line 303
  if (Ply >= 38) {
#line 304
    PV[Ply][Ply].from = (unsigned char)0;
#line 304
    return ((int )G[Counter].mtrl - (int )G[Counter].xmtrl);
  }
#line 306
  if ((int )G[Counter].rule50 >= 100) {
#line 307
    PV[Ply][Ply].from = (unsigned char)0;
#line 307
    if (Ply % 2) {
#line 307
      tmp___5 = - DrawScore;
    } else {
#line 307
      tmp___5 = DrawScore;
    }
#line 307
    return (tmp___5);
  }
#line 310
  if ((int )G[Counter].mtrl < 400) {
#line 310
    if ((int )G[Counter].mtrl < 400) {
      {
#line 311
      tmp___7 = material_draw();
      }
#line 311
      if (tmp___7) {
#line 312
        PV[Ply][Ply].from = (unsigned char)0;
#line 312
        if (Ply % 2) {
#line 312
          tmp___6 = - DrawScore;
        } else {
#line 312
          tmp___6 = DrawScore;
        }
#line 312
        return (tmp___6);
      }
    }
  }
#line 323
  if ((int )G[Counter].rule50 >= 3) {
    {
#line 324
    tmp___9 = repetition(1);
    }
#line 324
    if (tmp___9) {
#line 327
      ext = 0;
#line 328
      PV[Ply][Ply].from = (unsigned char)0;
#line 330
      j = Counter - 1;
      {
#line 330
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 330
        if (! (j > Counter - Ply)) {
#line 330
          goto while_break___0;
        }
#line 331
        ext += (int )G[j - 1].m.dch - (int )G[j].m.dch;
#line 330
        j -= 2;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 333
      if (ext > 0) {
#line 335
        if (ext > 500) {
#line 335
          ext = 500;
        }
#line 336
        ext += Ply * 20;
      } else
#line 338
      if (ext < 0) {
#line 340
        if (ext < -500) {
#line 340
          ext = -500;
        }
#line 341
        ext -= Ply * 20;
      }
#line 344
      if (Ply % 2) {
#line 344
        tmp___8 = - DrawScore;
      } else {
#line 344
        tmp___8 = DrawScore;
      }
#line 344
      return (ext / 10 + tmp___8);
    }
  }
#line 350
  if (SizeHT == 0U) {
#line 350
    t = (thashentry *)((void *)0);
  } else {
    {
#line 352
    t = seekHT();
    }
#line 352
    if ((unsigned long )t != (unsigned long )((void *)0)) {
#line 353
      if ((int )t->depth >= Depth) {
#line 353
        goto _L___1;
      } else
#line 353
      if (Depth < 300) {
        {
#line 353
        tmp___10 = abs((int )t->value);
        }
#line 353
        if (tmp___10 > 29000) {
          _L___1: /* CIL Label */ 
#line 355
          val = (int )t->value;
#line 356
          if (val > 29000) {
#line 356
            val -= Ply;
          } else
#line 357
          if (val < -29000) {
#line 357
            val += Ply;
          }
          {
#line 361
          if (t->result == 1U) {
#line 361
            goto case_1;
          }
#line 365
          if (t->result == 2U) {
#line 365
            goto case_2;
          }
#line 370
          if (t->result == 3U) {
#line 370
            goto case_3;
          }
#line 359
          goto switch_break;
          case_1: /* CIL Label */ 
#line 362
          PV[Ply][Ply].from = (unsigned char)0;
#line 363
          return (val);
#line 364
          goto switch_break;
          case_2: /* CIL Label */ 
#line 366
          if (val <= Alpha) {
#line 367
            PV[Ply][Ply].from = (unsigned char)0;
#line 367
            return (val);
          }
#line 368
          if (val < Beta) {
#line 368
            Beta = val;
          }
#line 369
          goto switch_break;
          case_3: /* CIL Label */ 
#line 371
          if (val >= Beta) {
#line 372
            PV[Ply][Ply].from = (unsigned char)0;
#line 372
            return (val);
          }
#line 373
          if (val > Alpha) {
#line 373
            Alpha = val;
          }
#line 374
          goto switch_break;
          switch_break: /* CIL Label */ ;
          }
        }
      }
    }
  }
#line 390
  if (Color == 1) {
#line 390
    tmp___11 = (int )L[1].next;
  } else {
#line 390
    tmp___11 = (int )L[2].next;
  }
  {
#line 390
  check = attacktest(tmp___11, Color ^ 3);
#line 390
  G[Counter].check = (unsigned short )check;
  }
#line 392
  if (Depth > 0) {
#line 392
    goto _L___8;
  } else
#line 392
  if (check) {
    _L___8: /* CIL Label */ 
    {
#line 394
    result = approx_eval();
    }
#line 397
    if (Depth < 100) {
#line 397
      if (! check) {
#line 397
        if (Totmat > 2000) {
#line 397
          if (Color == 1) {
#line 397
            tmp___12 = (int )Wknow.prune;
          } else {
#line 397
            tmp___12 = (int )Bknow.prune;
          }
#line 397
          if (tmp___12) {
#line 399
            if (result - devi[Ply] >= Beta) {
#line 400
              return (Beta);
            } else
#line 402
            if (result - devi[Ply] > Alpha) {
#line 403
              Alpha = result - devi[Ply];
            }
          }
        }
      }
    }
#line 407
    if (Depth > 0) {
      {
#line 408
      result = static_eval();
      }
    }
#line 411
    if (Depth < 100) {
#line 411
      if (! check) {
#line 411
        if (Totmat > 2000) {
#line 411
          if (Color == 1) {
#line 411
            tmp___13 = (int )Wknow.prune;
          } else {
#line 411
            tmp___13 = (int )Bknow.prune;
          }
#line 411
          if (tmp___13) {
#line 413
            if (result >= Beta) {
#line 414
              return (Beta);
            } else
#line 416
            if (result > Alpha) {
#line 417
              Alpha = result;
            }
          }
        }
      }
    }
#line 422
    if (Depth >= 100) {
#line 422
      if (result + 100 >= Beta) {
#line 422
        if (result >= Beta) {
#line 422
          goto _L___3;
        } else
#line 422
        if (Depth > 300) {
          _L___3: /* CIL Label */ 
#line 422
          if (! FollowPV) {
#line 422
            if (! check) {
#line 422
              if ((int )G[Counter].mtrl > 1400) {
#line 422
                if ((unsigned long )t == (unsigned long )((void *)0)) {
#line 422
                  goto _L___2;
                } else
#line 422
                if ((int )t->depth <= Depth - 300) {
#line 422
                  goto _L___2;
                } else
#line 422
                if (t->result == 3U) {
#line 422
                  goto _L___2;
                } else
#line 422
                if ((int )t->value >= Beta) {
                  _L___2: /* CIL Label */ 
#line 435
                  olddepth = Depth;
#line 436
                  alpha = - Beta;
#line 440
                  G[Counter].m.in1 = (unsigned char)0;
#line 441
                  G[Counter].m.special = (unsigned char)20;
#line 442
                  G[Counter].m.to = (unsigned char)2;
#line 443
                  Counter ++;
#line 443
                  Ply ++;
#line 444
                  G[Counter].castling = G[Counter - 1].castling;
#line 445
                  G[Counter].rule50 = (unsigned short )((int )G[Counter - 1].rule50 + 1);
#line 446
                  G[Counter].hashboard = 4256789809U ^ G[Counter - 1].hashboard;
#line 448
                  G[Counter].mtrl = G[Counter - 1].xmtrl;
#line 449
                  G[Counter].xmtrl = G[Counter - 1].mtrl;
#line 450
                  Color ^= 3;
#line 452
                  Depth -= 300;
#line 453
                  if (Depth <= 0) {
                    {
#line 455
                    Depth = 0;
#line 459
                    generate_legal_checks(m___2, & n___2);
                    }
                  } else {
                    {
#line 464
                    generate_legal_moves(m___2, & n___2, 0);
                    }
                  }
#line 467
                  if (n___2 != 0) {
                    {
#line 468
                    tmp___14 = search(m___2, n___2, alpha, 30000);
#line 468
                    value = - tmp___14;
                    }
                  } else
#line 470
                  if (Depth != 0) {
#line 470
                    value = Alpha;
                  } else {
#line 470
                    value = result;
                  }
#line 472
                  Color ^= 3;
#line 473
                  Counter --;
#line 473
                  Ply --;
#line 474
                  Depth = olddepth;
#line 475
                  Totmat = totmat;
#line 477
                  if (value >= Beta) {
#line 477
                    result = value;
#line 477
                    goto end;
                  }
#line 479
                  if (value > Alpha) {
#line 479
                    Alpha = value;
                  } else
#line 481
                  if (value < -29900) {
#line 481
                    if (Alpha > -28950) {
#line 482
                      if (Depth <= 300) {
#line 482
                        depthplus = 100;
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    {
#line 486
    generate_legal_moves(m___1, & n___1, check);
    }
#line 489
    if (n___1 == 0) {
#line 491
      PV[Ply][Ply].from = (unsigned char)0;
#line 492
      if (check) {
#line 492
        return (Ply - 30000);
      } else {
#line 493
        if (Ply % 2) {
#line 493
          tmp___15 = - DrawScore;
        } else {
#line 493
          tmp___15 = DrawScore;
        }
#line 493
        return (tmp___15);
      }
    }
#line 497
    if (check) {
#line 499
      if (result > lastiter - 50) {
#line 499
        if (result > -250) {
#line 501
          newdch = 40;
#line 501
          inrow = 0;
#line 503
          if (Depth <= 100) {
#line 503
            newdch -= 30;
          } else
#line 505
          if (Depth <= 200) {
#line 505
            newdch -= 20;
          }
#line 507
          i = Counter - 2;
          {
#line 507
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 507
            if (i > 0) {
#line 507
              if (! G[i].check) {
#line 507
                goto while_break___1;
              }
            } else {
#line 507
              goto while_break___1;
            }
#line 507
            inrow ++;
#line 507
            i -= 2;
          }
          while_break___1: /* CIL Label */ ;
          }
          {
#line 510
          if (inrow == 0) {
#line 510
            goto case_0;
          }
#line 511
          if (inrow == 1) {
#line 511
            goto case_1___0;
          }
#line 512
          goto switch_default;
          case_0: /* CIL Label */ 
#line 510
          goto switch_break___0;
          case_1___0: /* CIL Label */ 
#line 511
          newdch -= 10;
#line 511
          goto switch_break___0;
          switch_default: /* CIL Label */ 
#line 512
          newdch -= 30;
#line 512
          goto switch_break___0;
          switch_break___0: /* CIL Label */ ;
          }
#line 515
          if (n___1 > 4) {
#line 515
            newdch += 6 * (n___1 - 5);
          } else {
#line 516
            newdch -= 20 * (5 - n___1);
          }
#line 518
          if (newdch > 60) {
#line 518
            newdch = 60;
          } else
#line 519
          if (newdch < -40) {
#line 519
            newdch = -40;
          }
#line 521
          i = 0;
          {
#line 521
          while (1) {
            while_continue___2: /* CIL Label */ ;
#line 521
            if (! (i != n___1)) {
#line 521
              goto while_break___2;
            }
#line 522
            m___1[i].dch = (short )newdch;
#line 521
            i ++;
          }
          while_break___2: /* CIL Label */ ;
          }
        } else {
#line 499
          goto _L___4;
        }
      } else {
        _L___4: /* CIL Label */ 
#line 525
        i___0 = 0;
        {
#line 525
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 525
          if (! (i___0 != n___1)) {
#line 525
            goto while_break___3;
          }
#line 525
          m___1[i___0].dch = (short)60;
#line 525
          i___0 ++;
        }
        while_break___3: /* CIL Label */ ;
        }
      }
    }
#line 601
    if (Totmat < 4000) {
#line 602
      if (result < lastiter + 50) {
#line 602
        if (result < 250) {
#line 605
          i___1 = 0;
          {
#line 605
          while (1) {
            while_continue___4: /* CIL Label */ ;
#line 605
            if (! (i___1 != n___1)) {
#line 605
              goto while_break___4;
            }
#line 606
            if (((int )m___1[i___1].in2a & 252) == 16) {
#line 606
              if ((int )m___1[i___1].special == 0) {
#line 606
                if (Color == 1) {
#line 606
                  if ((int )m___1[i___1].to >= 71) {
#line 606
                    goto _L___5;
                  } else {
#line 606
                    goto _L___6;
                  }
                } else
                _L___6: /* CIL Label */ 
#line 606
                if (Color == 2) {
#line 606
                  if ((int )m___1[i___1].to <= 48) {
                    _L___5: /* CIL Label */ 
#line 612
                    support = 0;
#line 613
                    newdch___0 = 60;
#line 615
                    if (Color == 1) {
#line 618
                      j___0 = (int )m___1[i___1].to + 10;
                      {
#line 618
                      while (1) {
                        while_continue___5: /* CIL Label */ ;
#line 618
                        if (! (j___0 <= 88)) {
#line 618
                          goto while_break___5;
                        }
#line 619
                        if ((int )B[j___0 - 1] == 18) {
#line 622
                          goto no_push_extension;
                        } else
#line 619
                        if ((int )B[j___0] == 18) {
#line 622
                          goto no_push_extension;
                        } else
#line 619
                        if ((int )B[j___0 + 1] == 18) {
#line 622
                          goto no_push_extension;
                        }
#line 618
                        j___0 += 10;
                      }
                      while_break___5: /* CIL Label */ ;
                      }
#line 624
                      j___0 = (int )m___1[i___1].to;
                      {
#line 624
                      while (1) {
                        while_continue___6: /* CIL Label */ ;
#line 624
                        if (! (j___0 <= 98)) {
#line 624
                          goto while_break___6;
                        }
#line 626
                        if (B[j___0]) {
#line 626
                          support --;
                        }
                        {
#line 627
                        tmp___16 = see(B, (int )m___1[i___1].from, j___0);
                        }
#line 627
                        if (tmp___16 < 0) {
#line 628
                          support --;
                        } else {
#line 629
                          support ++;
                        }
#line 624
                        j___0 += 10;
                      }
                      while_break___6: /* CIL Label */ ;
                      }
                    } else {
#line 634
                      j___0 = (int )m___1[i___1].to - 10;
                      {
#line 634
                      while (1) {
                        while_continue___7: /* CIL Label */ ;
#line 634
                        if (! (j___0 >= 31)) {
#line 634
                          goto while_break___7;
                        }
#line 635
                        if ((int )B[j___0 - 1] == 17) {
#line 638
                          goto no_push_extension;
                        } else
#line 635
                        if ((int )B[j___0] == 17) {
#line 638
                          goto no_push_extension;
                        } else
#line 635
                        if ((int )B[j___0 + 1] == 17) {
#line 638
                          goto no_push_extension;
                        }
#line 634
                        j___0 -= 10;
                      }
                      while_break___7: /* CIL Label */ ;
                      }
#line 640
                      j___0 = (int )m___1[i___1].to;
                      {
#line 640
                      while (1) {
                        while_continue___8: /* CIL Label */ ;
#line 640
                        if (! (j___0 >= 21)) {
#line 640
                          goto while_break___8;
                        }
#line 642
                        if (B[j___0]) {
#line 642
                          support --;
                        }
                        {
#line 643
                        tmp___17 = see(B, (int )m___1[i___1].from, j___0);
                        }
#line 643
                        if (tmp___17 < 0) {
#line 644
                          support --;
                        } else {
#line 645
                          support ++;
                        }
#line 640
                        j___0 -= 10;
                      }
                      while_break___8: /* CIL Label */ ;
                      }
                    }
#line 649
                    newdch___0 += (Depth / 20 + Totmat / 100) - 30 * support;
                    {
#line 652
                    if ((int )m___1[i___1].to / 10 == 3) {
#line 652
                      goto case_3___0;
                    }
#line 652
                    if ((int )m___1[i___1].to / 10 == 8) {
#line 652
                      goto case_3___0;
                    }
#line 651
                    goto switch_break___1;
                    case_3___0: /* CIL Label */ 
                    case_8: /* CIL Label */ 
#line 653
                    if (support > 0) {
#line 653
                      newdch___0 -= 20 * support + 10;
                    }
#line 653
                    goto switch_break___1;
                    switch_break___1: /* CIL Label */ ;
                    }
#line 655
                    if (newdch___0 < (int )m___1[i___1].dch) {
#line 656
                      m___1[i___1].dch = (short )newdch___0;
                    }
                    no_push_extension: ;
                  }
                }
              }
            }
#line 605
            i___1 ++;
          }
          while_break___4: /* CIL Label */ ;
          }
        }
      }
    }
  } else {
    {
#line 704
    result = approx_eval();
    }
#line 706
    if (Depth < -400) {
#line 708
      PV[Ply][Ply].from = (unsigned char)0;
#line 709
      goto end;
    }
#line 712
    if (result < Beta + devi[Ply]) {
#line 712
      if (result > Alpha - devi[Ply]) {
        {
#line 714
        result = static_eval();
        }
      } else {
#line 712
        goto _L___7;
      }
    } else
    _L___7: /* CIL Label */ 
#line 712
    if (Totmat <= 450) {
      {
#line 714
      result = static_eval();
      }
    }
#line 716
    if (result >= Beta) {
#line 716
      return (result);
    }
#line 718
    if (result <= Alpha - 1150) {
#line 718
      if (Depth <= -100) {
#line 719
        return (Alpha);
      }
    }
#line 725
    if ((int )G[Counter].mtrl - (int )G[Counter].xmtrl < 400) {
#line 725
      if (Depth > -100) {
#line 725
        if (Color == 1) {
#line 725
          tmp___18 = (int )Bknow.khung > 1;
        } else {
#line 725
          tmp___18 = (int )Wknow.khung > 1;
        }
#line 725
        if (tmp___18) {
          {
#line 729
          generate_legal_checks(m___1, & n___1);
          }
        } else {
          {
#line 731
          generate_legal_captures(m___1, & n___1, (Alpha - result) - 100);
          }
        }
      } else {
        {
#line 731
        generate_legal_captures(m___1, & n___1, (Alpha - result) - 100);
        }
      }
    } else {
      {
#line 731
      generate_legal_captures(m___1, & n___1, (Alpha - result) - 100);
      }
    }
  }
#line 736
  if (G[Counter - 1].m.in2) {
#line 737
    if (result < lastiter + 50) {
#line 737
      if (result < 250) {
#line 739
        t___2 = (int )G[Counter - 1].m.to;
#line 740
        v1 = Values[(int )G[Counter - 1].m.in1 >> 4];
#line 741
        v2 = Values[(int )G[Counter - 1].m.in2 >> 4];
#line 744
        if (Depth <= 200) {
#line 745
          newdch___1 = 30;
        } else {
#line 747
          newdch___1 = 40;
        }
#line 749
        if (v1 < v2) {
#line 749
          tmp___20 = v1;
        } else {
#line 749
          tmp___20 = v2;
        }
#line 749
        if (tmp___20 > 400) {
#line 750
          newdch___1 -= 70;
        } else
#line 749
        if ((int )G[Counter].mtrl < 1050) {
#line 750
          newdch___1 -= 70;
        } else {
#line 752
          if (v1 < v2) {
#line 752
            tmp___19 = v1;
          } else {
#line 752
            tmp___19 = v2;
          }
#line 752
          if (tmp___19 > 200) {
#line 753
            newdch___1 -= 45;
          } else
#line 752
          if ((int )G[Counter].mtrl < 1400) {
#line 753
            newdch___1 -= 45;
          }
        }
#line 756
        i___2 = 0;
        {
#line 756
        while (1) {
          while_continue___9: /* CIL Label */ ;
#line 756
          if (! (i___2 != n___1)) {
#line 756
            goto while_break___9;
          }
#line 757
          if ((int )m___1[i___2].to == t___2) {
#line 758
            if ((int )m___1[i___2].dch > newdch___1) {
#line 760
              m___1[i___2].dch = (short )newdch___1;
            }
          }
#line 756
          i___2 ++;
        }
        while_break___9: /* CIL Label */ ;
        }
      }
    }
  }
#line 765
  if (Depth > 200) {
#line 765
    if ((int )G[Counter].mtrl <= 800) {
#line 765
      if ((int )G[Counter].xmtrl <= 1850) {
#line 765
        if ((int )G[Counter - 1].m.in2 > 32) {
#line 771
          target = 0;
#line 774
          i___3 = (int )L[L[Color].next].next;
          {
#line 774
          while (1) {
            while_continue___10: /* CIL Label */ ;
#line 774
            if (! (i___3 != 0)) {
#line 774
              goto while_break___10;
            }
#line 775
            if ((int )B[i___3] >= 32) {
#line 775
              goto nopee;
            }
#line 774
            i___3 = (int )L[i___3].next;
          }
          while_break___10: /* CIL Label */ ;
          }
#line 777
          i___3 = (int )L[L[Color ^ 3].next].next;
          {
#line 777
          while (1) {
            while_continue___11: /* CIL Label */ ;
#line 777
            if (! (i___3 != 0)) {
#line 777
              goto while_break___11;
            }
#line 778
            if ((int )B[i___3] >= 32) {
#line 779
              if (target) {
#line 779
                goto nopee;
              } else {
#line 779
                target = i___3;
              }
            }
#line 777
            i___3 = (int )L[i___3].next;
          }
          while_break___11: /* CIL Label */ ;
          }
#line 781
          if (! target) {
#line 781
            goto nopee;
          }
#line 783
          if ((int )G[Counter - 1].m.in2 >= 80) {
#line 783
            if (Depth < 450) {
#line 783
              cdch = Depth;
            } else {
#line 783
              cdch = 450;
            }
          } else
#line 784
          if ((Depth * 2) / 3 < 350) {
#line 784
            cdch = (Depth * 2) / 3;
          } else {
#line 784
            cdch = 350;
          }
#line 786
          i___3 = 0;
          {
#line 786
          while (1) {
            while_continue___12: /* CIL Label */ ;
#line 786
            if (! (i___3 != n___1)) {
#line 786
              goto while_break___12;
            }
#line 787
            if ((int )m___1[i___3].to == target) {
#line 788
              m___1[i___3].dch = (short )((int )m___1[i___3].dch - cdch);
            }
#line 786
            i___3 ++;
          }
          while_break___12: /* CIL Label */ ;
          }
          nopee: ;
        }
      }
    }
  }
  {
#line 796
  add_killer(m___1, n___1, t);
#line 798
  PV[Ply][Ply].from = (unsigned char)0;
  }
#line 801
  if (Flag.easy) {
#line 801
    if (n___1 > 10) {
      {
#line 801
      blunder(m___1, & n___1);
      }
    }
  }
#line 804
  if (Depth > 0) {
#line 804
    goto _L___9;
  } else
#line 804
  if (check) {
    _L___9: /* CIL Label */ 
#line 806
    if (depthplus) {
      {
#line 806
      result = csearch(m___1, n___1, Alpha, Beta, depthplus);
      }
    } else {
      {
#line 807
      result = search(m___1, n___1, Alpha, Beta);
      }
    }
  } else
#line 811
  if (result > Alpha) {
    {
#line 812
    result = search(m___1, n___1, result, Beta);
    }
  } else {
    {
#line 814
    result = search(m___1, n___1, Alpha, Beta);
    }
  }
  end: 
#line 819
  if (result >= Beta) {
#line 819
    if (Depth > 0) {
      {
#line 820
      write_killer((int )G[Counter].m.from, (int )G[Counter].m.to);
      }
    }
  }
#line 822
  if (SizeHT != 0U) {
#line 822
    if (Abort == 0) {
      {
#line 822
      writeHT(result, Alpha, Beta);
      }
    }
  }
#line 830
  if (Depth > 300) {
#line 830
    if (Flag.learn) {
#line 831
      if (Depth > 400) {
#line 831
        goto _L___10;
      } else
#line 831
      if (Ply < 3) {
        _L___10: /* CIL Label */ 
        {
#line 833
        tmp___21 = rlearn();
#line 833
        lresult = tmp___21;
        }
#line 834
        if (lresult != 32123) {
#line 835
          PV[Ply][Ply].from = (unsigned char)0;
#line 836
          if (lresult > 29000) {
#line 836
            lresult -= Ply;
          }
#line 837
          if (lresult < -29000) {
#line 837
            lresult += Ply;
          }
#line 838
          result = lresult;
        }
      }
    }
  }
#line 842
  return (result);
}
}
#line 399 "/home/wheatley/newnew/temp/phalanx-22+d051004/phalanx.h"
signed char *Th ;
#line 400
signed char *Tv ;
#line 503
int pawns(void) ;
#line 504
int e_nb(int color ) ;
#line 505
int e_mp(void) ;
#line 506
int e_rpr(void) ;
#line 5 "/home/wheatley/newnew/temp/phalanx-22+d051004/endgame.c"
int onepawn(int wk , int wp , int bk___0 , int wtm ) 
{ 
  int wpfile ;
  int target ;
  int steps ;
  int tmp ;
  tdist *tardist ;
  int rookpawn ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int d ;
  int d1 ;
  int tmp___3 ;
  int d2 ;
  int tmp___4 ;

  {
#line 10
  wpfile = wp % 10;
#line 11
  target = wpfile + 90;
#line 12
  if (wk > wp) {
#line 12
    if ((wk - wp) % 10 == 0) {
#line 12
      tmp = 1;
    } else {
#line 12
      tmp = 0;
    }
  } else {
#line 12
    tmp = 0;
  }
#line 12
  steps = ((target / 10 - wp / 10) + tmp) - (wp <= 38);
#line 13
  tardist = dist + 120 * target;
#line 19
  if ((int )(tardist + bk___0)->max > (steps - wtm) + 1) {
#line 19
    return (550 - steps);
  }
#line 28
  if ((bk___0 - wp) % 9 == 0) {
#line 28
    tmp___0 = 1;
  } else
#line 28
  if ((bk___0 - wp) % 11 == 0) {
#line 28
    tmp___0 = 1;
  } else {
#line 28
    tmp___0 = 0;
  }
#line 28
  if (wpfile == 1) {
#line 28
    tmp___1 = 1;
  } else
#line 28
  if (wpfile == 8) {
#line 28
    tmp___1 = 1;
  } else {
#line 28
    tmp___1 = 0;
  }
#line 28
  rookpawn = tmp___1;
#line 28
  if (((dist[120 * wp + bk___0].max + (unsigned int )wtm) + 1U) + (unsigned int )tmp___0 <= dist[120 * wp + wk].max + (unsigned int )rookpawn) {
#line 31
    return (-99);
  }
#line 36
  if (rookpawn) {
#line 38
    if (((tardist + bk___0)->max + (unsigned int )wtm) - 1U > (tardist + wk)->max) {
      {
#line 38
      tmp___2 = abs(wpfile - wk % 10);
      }
#line 38
      if (tmp___2 == 1) {
#line 39
        return (450 - 2 * steps);
      }
    }
#line 40
    return (-99);
  }
#line 47
  if (wk - wp == 19) {
#line 47
    return (550 - 4 * steps);
  } else
#line 47
  if (wk - wp == 20) {
#line 47
    return (550 - 4 * steps);
  } else
#line 47
  if (wk - wp == 21) {
#line 47
    return (550 - 4 * steps);
  }
#line 48
  if (wk - wp == 9) {
#line 48
    goto _L;
  } else
#line 48
  if (wk - wp == 10) {
#line 48
    goto _L;
  } else
#line 48
  if (wk - wp == 11) {
    _L: /* CIL Label */ 
#line 48
    if (wp > 61) {
#line 49
      return (550 - 8 * steps);
    } else
#line 48
    if (wtm != (bk___0 - wk == 20)) {
#line 49
      return (550 - 8 * steps);
    }
  }
#line 54
  if (wp < 81) {
#line 54
    if (bk___0 - wp == 10) {
#line 54
      return (-99);
    }
  }
#line 55
  if (wp < 71) {
#line 57
    if (bk___0 - wp == 20) {
#line 57
      return (-99);
    }
#line 58
    if (bk___0 - wp == 19) {
#line 58
      goto _L___0;
    } else
#line 58
    if (bk___0 - wp == 21) {
      _L___0: /* CIL Label */ 
#line 58
      if (bk___0 - wk == 20) {
#line 58
        return (-99);
      }
    }
  }
#line 67
  if (wp < 61) {
#line 67
    tmp___3 = 19;
  } else {
#line 67
    tmp___3 = 9;
  }
#line 67
  d1 = 120 * (wp + tmp___3);
#line 68
  if (wp < 61) {
#line 68
    tmp___4 = 21;
  } else {
#line 68
    tmp___4 = 11;
  }
#line 68
  d2 = 120 * (wp + tmp___4);
#line 69
  if (dist[wk + d1].max < dist[wk + d2].max) {
#line 70
    d = (int )(((unsigned int )wtm + dist[bk___0 + d1].max) - dist[wk + d1].max);
  } else
#line 72
  if (dist[wk + d1].max > dist[wk + d2].max) {
#line 73
    d = (int )(((unsigned int )wtm + dist[bk___0 + d2].max) - dist[wk + d2].max);
  } else
#line 75
  if (dist[bk___0 + d1].max < dist[bk___0 + d2].max) {
#line 76
    d = (int )(((unsigned int )wtm + dist[bk___0 + d2].max) - dist[wk + d2].max);
  } else {
#line 77
    d = (int )(((unsigned int )wtm + dist[bk___0 + d1].max) - dist[wk + d1].max);
  }
#line 79
  if (d > 0) {
#line 79
    return (450 - 4 * (steps - d));
  } else
#line 81
  if (d < 0) {
#line 81
    return (-79 + 2 * d);
  }
#line 83
  return ((int )(32U * (dist[(wp + 10) * 120 + bk___0].taxi - dist[(wp + 20) * 120 + wk].taxi)));
}
}
#line 90 "/home/wheatley/newnew/temp/phalanx-22+d051004/endgame.c"
int Oppb[17]  = 
#line 90
  {      0,      0,      40,      50, 
        58,      64,      68,      68, 
        68,      68,      68,      68, 
        68,      68,      68,      68, 
        68};
#line 98
int wpf[10] ;
#line 99
int bpf[10] ;
#line 103 "/home/wheatley/newnew/temp/phalanx-22+d051004/endgame.c"
static int passed[16]  = 
#line 103
  {      0,      100,      75,      50, 
        30,      10,      5,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0};
#line 106 "/home/wheatley/newnew/temp/phalanx-22+d051004/endgame.c"
static int kbonus_[80]  = 
#line 106
  {      0,      0,      1,      2, 
        3,      3,      2,      1, 
        0,      0,      0,      10, 
        11,      12,      13,      13, 
        12,      11,      10,      0, 
        0,      20,      21,      22, 
        23,      23,      22,      21, 
        20,      0,      0,      30, 
        31,      32,      33,      33, 
        32,      31,      30,      0, 
        0,      40,      41,      42, 
        43,      43,      42,      41, 
        40,      0,      0,      50, 
        51,      52,      53,      53, 
        52,      51,      50,      0, 
        0,      50,      51,      52, 
        53,      53,      52,      51, 
        50,      0,      0,      42, 
        45,      47,      48,      48, 
        47,      45,      42,      0};
#line 95 "/home/wheatley/newnew/temp/phalanx-22+d051004/endgame.c"
int pawns(void) 
{ 
  int result ;
  int color ;
  int wbest ;
  int bbest ;
  int const   *kbonus ;
  int wk ;
  int wp ;
  int bk___0 ;
  int wtm ;
  int tmp ;
  int step ;
  int tmp___0 ;
  int best ;
  unsigned int pawn ;
  unsigned int xpawn ;
  unsigned int kp ;
  unsigned int xkp ;
  int *pf___0 ;
  int *tmp___1 ;
  int s ;
  int i ;
  int b ;
  int togo ;
  int blocks ;
  int cannotmove ;
  int protected ;
  int stepstosquare ;
  int tmp___2 ;
  int f ;
  int tmp___3 ;
  int tmp___4 ;
  int di ;
  int tmp___5 ;
  int tmp___6 ;
  int whas ;
  int bhas ;
  int wrm ;
  int wlm ;
  int brm ;
  int blm ;

  {
#line 102
  wbest = 32;
#line 102
  bbest = 32;
#line 116
  kbonus = (int const   *)(kbonus_ - 20);
#line 118
  if (Totmat == 100) {
#line 122
    if (Color == 1) {
#line 122
      wtm = 1;
    } else {
#line 122
      wtm = 0;
    }
#line 124
    if ((int )L[L[1].next].next != 0) {
      {
#line 125
      wk = (int )L[1].next;
#line 125
      wp = (int )L[L[1].next].next;
#line 125
      bk___0 = (int )L[2].next;
#line 126
      result = onepawn(wk, wp, bk___0, wtm);
      }
    } else {
      {
#line 129
      wk = (int )*(Th + L[2].next);
#line 129
      wp = (int )*(Th + L[L[2].next].next);
#line 129
      bk___0 = (int )*(Th + L[1].next);
#line 130
      wtm = ! wtm;
#line 131
      tmp = onepawn(wk, wp, bk___0, wtm);
#line 131
      result = - tmp;
      }
    }
#line 134
    if (Color == 1) {
#line 134
      return (result);
    } else {
#line 134
      return (- result);
    }
  }
#line 139
  result = (int )(*(kbonus + L[1].next) - *(kbonus + *(Th + L[2].next)));
#line 141
  color = 1;
  {
#line 141
  while (1) {
    while_continue: /* CIL Label */ ;
#line 141
    if (! (color != 3)) {
#line 141
      goto while_break;
    }
#line 143
    if (color == 1) {
#line 143
      tmp___0 = 10;
    } else {
#line 143
      tmp___0 = -10;
    }
#line 143
    step = tmp___0;
#line 144
    best = 32;
#line 145
    pawn = (unsigned int )(16 + color);
#line 146
    xpawn = (unsigned int )(16 + (color ^ 3));
#line 147
    kp = (unsigned int )L[color].next;
#line 148
    xkp = (unsigned int )L[color ^ 3].next;
#line 149
    if (color == 1) {
#line 149
      tmp___1 = wpf;
    } else {
#line 149
      tmp___1 = bpf;
    }
#line 149
    pf___0 = tmp___1;
#line 153
    i = 1;
    {
#line 153
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 153
      if (! (i != 9)) {
#line 153
        goto while_break___0;
      }
#line 153
      *(pf___0 + i) = 0;
#line 153
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 155
    s = (int )L[kp].next;
    {
#line 155
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 155
      if (! (s != 0)) {
#line 155
        goto while_break___1;
      }
#line 158
      blocks = 0;
#line 163
      (*(pf___0 + s % 10)) ++;
#line 166
      if (*(pf___0 + s % 10) > 1) {
#line 166
        if (color == 1) {
#line 166
          tmp___2 = 8;
        } else {
#line 166
          tmp___2 = -8;
        }
#line 166
        result -= tmp___2;
      }
#line 168
      if (B[s + step]) {
#line 168
        cannotmove = 1;
      } else {
#line 171
        f = 0;
#line 172
        if ((unsigned int )B[((s + step) + step) + 1] == xpawn) {
#line 172
          f ++;
        }
#line 173
        if ((unsigned int )B[((s + step) + step) - 1] == xpawn) {
#line 173
          f ++;
        }
#line 174
        if (f) {
#line 176
          if ((unsigned int )B[s + 1] == pawn) {
#line 176
            f --;
          }
#line 177
          if ((unsigned int )B[s - 1] == pawn) {
#line 177
            f --;
          }
#line 178
          cannotmove = f > 0;
        } else {
#line 179
          cannotmove = 0;
        }
      }
#line 182
      if (cannotmove) {
#line 182
        if (color == 1) {
#line 182
          tmp___3 = 6;
        } else {
#line 182
          tmp___3 = -6;
        }
#line 182
        result -= tmp___3;
      }
#line 184
      if ((unsigned int )B[(s - step) - 1] == pawn) {
#line 184
        tmp___4 = 1;
      } else
#line 184
      if ((unsigned int )B[(s - step) + 1] == pawn) {
#line 184
        tmp___4 = 1;
      } else {
#line 184
        tmp___4 = 0;
      }
#line 184
      protected = tmp___4;
#line 187
      if (! protected) {
#line 189
        di = (int )dist[120U * xkp + (unsigned int )s].max;
#line 190
        if (cannotmove) {
#line 190
          if (color == 1) {
#line 190
            b = 32 - 4 * di;
          } else {
#line 190
            b = - (32 - 4 * di);
          }
        } else
#line 191
        if (color == 1) {
#line 191
          b = 16 - 2 * di;
        } else {
#line 191
          b = - (16 - 2 * di);
        }
#line 192
        if (di == 1) {
#line 193
          if (cannotmove) {
#line 193
            b += 30;
          } else {
#line 193
            b += 20;
          }
        }
#line 195
        result -= b;
      }
#line 198
      if ((unsigned int )B[s + step] == xpawn) {
#line 198
        goto end_passed;
      }
#line 199
      i = (s + step) + step;
      {
#line 199
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 199
        if (! ((int )B[i] != 3)) {
#line 199
          goto while_break___2;
        }
#line 201
        if (B[i]) {
#line 201
          blocks ++;
        }
#line 202
        if ((unsigned int )B[i] == xpawn) {
#line 203
          goto end_passed;
        } else
#line 202
        if ((unsigned int )B[i - 1] == xpawn) {
#line 203
          goto end_passed;
        } else
#line 202
        if ((unsigned int )B[i + 1] == xpawn) {
#line 203
          goto end_passed;
        }
#line 199
        i += step;
      }
      while_break___2: /* CIL Label */ ;
      }
      {
#line 208
      i -= step;
#line 209
      tmp___5 = abs(s - i);
#line 209
      togo = blocks + tmp___5 / 10;
      }
#line 210
      if (color == 1) {
#line 210
        b = passed[togo];
      } else {
#line 210
        b = - passed[togo];
      }
#line 211
      result += b;
#line 214
      if (protected) {
#line 214
        result += b + b;
      }
#line 217
      stepstosquare = ((int )dist[xkp * 120U + (unsigned int )i].max - togo) + (Color == color);
#line 219
      if (stepstosquare > 1) {
#line 221
        result += b + b;
#line 222
        if (togo < best) {
#line 222
          best = togo;
        }
      }
#line 226
      b = (int )(dist[(xkp * 120U + (unsigned int )s) + (unsigned int )step].max * (unsigned int )(12 - togo));
#line 227
      if (color == 1) {
#line 227
        tmp___6 = b;
      } else {
#line 227
        tmp___6 = - b;
      }
#line 227
      result += tmp___6;
      end_passed: 
#line 234
      result += ((s / 10 - 4) - color) * 2;
#line 155
      s = (int )L[s].next;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 236
    if (color == 1) {
#line 236
      wbest = best;
    } else {
#line 236
      bbest = best;
    }
#line 141
    color ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 239
  if (wbest != 32) {
#line 240
    if (bbest != 32) {
#line 241
      if (wbest - bbest > 2) {
#line 241
        result += -300 + (bbest - wbest) * 60;
      } else
#line 242
      if (bbest - wbest > 2) {
#line 242
        result += 300 + (bbest - wbest) * 60;
      } else {
#line 243
        result += (bbest - wbest) * 40;
      }
    } else {
#line 246
      result += (30 - wbest) * 20;
    }
  } else
#line 248
  if (bbest != 32) {
#line 249
    result -= (30 - bbest) * 20;
  }
#line 252
  if (G[Counter].mtrl) {
#line 252
    if (G[Counter].xmtrl) {
#line 254
      whas = 0;
#line 254
      bhas = 0;
#line 257
      wrm = (int )Wknow.rpf;
#line 258
      wlm = (int )Wknow.lpf;
#line 259
      brm = (int )Bknow.rpf;
#line 260
      blm = (int )Bknow.lpf;
#line 263
      if (wlm + 1 < blm) {
#line 263
        if (wrm > wlm + 3) {
#line 263
          whas = blm - wlm;
        } else {
#line 263
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 265
      if (blm + 1 < wlm) {
#line 265
        if (brm > blm + 3) {
#line 265
          bhas = wlm - blm;
        }
      }
#line 268
      if (wrm - 1 > brm) {
#line 268
        if (wrm > wlm + 3) {
#line 268
          whas += wrm - brm;
        } else {
#line 268
          goto _L___0;
        }
      } else
      _L___0: /* CIL Label */ 
#line 270
      if (brm - 1 > wrm) {
#line 270
        if (brm > blm + 3) {
#line 270
          bhas += brm - wrm;
        }
      }
#line 272
      result += Oppb[whas] - Oppb[bhas];
    }
  }
#line 275
  if (Color == 2) {
#line 275
    result = - result;
  }
#line 278
  if ((int )G[Counter].mtrl > (int )G[Counter].xmtrl) {
#line 278
    result += (int )G[Counter].mtrl / 20;
  } else
#line 280
  if ((int )G[Counter].mtrl < (int )G[Counter].xmtrl) {
#line 280
    result -= (int )G[Counter].xmtrl / 20;
  }
#line 282
  return (result);
}
}
#line 289 "/home/wheatley/newnew/temp/phalanx-22+d051004/endgame.c"
int nb_[80]  = 
#line 289
  {      0,      100,      90,      80, 
        70,      60,      50,      40, 
        30,      0,      0,      90, 
        80,      70,      57,      45, 
        32,      20,      40,      0, 
        0,      80,      70,      50, 
        37,      23,      10,      32, 
        50,      0,      0,      70, 
        57,      37,      10,      0, 
        23,      45,      60,      0, 
        0,      60,      45,      23, 
        0,      10,      37,      57, 
        70,      0,      0,      50, 
        32,      10,      23,      37, 
        50,      70,      80,      0, 
        0,      40,      20,      32, 
        45,      57,      70,      80, 
        90,      0,      0,      30, 
        40,      50,      60,      70, 
        80,      90,      100,      0};
#line 299 "/home/wheatley/newnew/temp/phalanx-22+d051004/endgame.c"
int *nb  =    nb_ - 20;
#line 324
signed char *sqcolor ;
#line 303 "/home/wheatley/newnew/temp/phalanx-22+d051004/endgame.c"
int e_mp(void) 
{ 
  int p ;
  int wb ;
  int wp ;
  int wk ;
  int bk___0 ;

  {
#line 306
  if (G[Counter].mtrl) {
#line 306
    if (G[Counter].xmtrl) {
#line 309
      if ((int )G[Counter].mtrl == 100) {
#line 311
        if (Color == 1) {
#line 311
          p = (int )L[L[1].next].next / 10;
        } else {
#line 312
          p = 11 - (int )L[L[2].next].next / 10;
        }
      } else
#line 316
      if (Color == 1) {
#line 316
        p = - (11 - (int )L[L[2].next].next / 10);
      } else {
#line 317
        p = - ((int )L[L[1].next].next) / 10;
      }
#line 319
      return (((int )G[Counter].xmtrl - (int )G[Counter].mtrl) + 3 * p);
    } else {
#line 306
      goto _L___1;
    }
  } else {
    _L___1: /* CIL Label */ 
#line 326
    if (L[L[1].next].next) {
#line 328
      wk = (int )L[1].next;
#line 329
      if ((int )B[L[wk].next] == 17) {
#line 329
        wp = (int )L[wk].next;
#line 329
        wb = (int )L[wp].next;
      } else {
#line 330
        wb = (int )L[wk].next;
#line 330
        wp = (int )L[wb].next;
      }
#line 331
      if ((int )B[wb] == 33) {
#line 333
        if ((int )B[81] == 17) {
#line 333
          if ((int )B[91] == 98) {
#line 335
            return ((int )G[Counter].xmtrl - (int )G[Counter].mtrl);
          } else
#line 333
          if ((int )B[82] == 98) {
#line 335
            return ((int )G[Counter].xmtrl - (int )G[Counter].mtrl);
          } else {
#line 333
            goto _L;
          }
        } else
        _L: /* CIL Label */ 
#line 333
        if ((int )B[88] == 17) {
#line 333
          if ((int )B[98] == 98) {
#line 335
            return ((int )G[Counter].xmtrl - (int )G[Counter].mtrl);
          } else
#line 333
          if ((int )B[87] == 98) {
#line 335
            return ((int )G[Counter].xmtrl - (int )G[Counter].mtrl);
          } else {
#line 336
            return (0);
          }
        } else {
#line 336
          return (0);
        }
      }
#line 338
      bk___0 = (int )L[2].next;
    } else {
#line 342
      wk = (int )L[2].next;
#line 343
      if ((int )B[L[wk].next] == 18) {
#line 343
        wp = (int )L[wk].next;
#line 343
        wb = (int )L[wp].next;
      } else {
#line 344
        wb = (int )L[wk].next;
#line 344
        wp = (int )L[wb].next;
      }
#line 345
      bk___0 = (int )L[1].next;
#line 346
      if ((int )B[wb] == 34) {
#line 348
        if ((int )B[31] == 18) {
#line 348
          if ((int )B[21] == 97) {
#line 350
            return ((int )G[Counter].xmtrl - (int )G[Counter].mtrl);
          } else
#line 348
          if ((int )B[32] == 97) {
#line 350
            return ((int )G[Counter].xmtrl - (int )G[Counter].mtrl);
          } else {
#line 348
            goto _L___0;
          }
        } else
        _L___0: /* CIL Label */ 
#line 348
        if ((int )B[38] == 18) {
#line 348
          if ((int )B[28] == 97) {
#line 350
            return ((int )G[Counter].xmtrl - (int )G[Counter].mtrl);
          } else
#line 348
          if ((int )B[37] == 97) {
#line 350
            return ((int )G[Counter].xmtrl - (int )G[Counter].mtrl);
          } else {
#line 351
            return (0);
          }
        } else {
#line 351
          return (0);
        }
      }
#line 353
      wk = (int )*(Th + wk);
#line 353
      wp = (int )*(Th + wp);
#line 353
      wb = (int )*(Th + wb);
#line 353
      bk___0 = (int )*(Th + bk___0);
    }
    {
#line 357
    if (wp % 10 == 1) {
#line 357
      goto case_1;
    }
#line 358
    if (wp % 10 == 8) {
#line 358
      goto case_8;
    }
#line 359
    goto switch_default;
    case_1: /* CIL Label */ 
#line 357
    goto switch_break;
    case_8: /* CIL Label */ 
#line 358
    wp = (int )*(Tv + wp);
#line 358
    wk = (int )*(Tv + wk);
#line 358
    wb = (int )*(Tv + wb);
#line 358
    bk___0 = (int )*(Tv + bk___0);
#line 358
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 359
    return (0);
    switch_break: /* CIL Label */ ;
    }
#line 362
    if ((int )*(sqcolor + wb) == 1) {
#line 362
      return (0);
    }
#line 365
    if (bk___0 > wp) {
#line 366
      if (bk___0 % 10 < 3) {
#line 366
        if (bk___0 >= 81) {
#line 368
          return ((int )G[Counter].xmtrl - (int )G[Counter].mtrl);
        }
      }
    }
  }
#line 372
  return (0);
}
}
#line 378 "/home/wheatley/newnew/temp/phalanx-22+d051004/endgame.c"
int e_nb(int color ) 
{ 
  int kdist ;
  int kp ;
  int i ;
  int npd ;

  {
#line 380
  kdist = (int )(8U * dist[(int )L[1].next * 120 + (int )L[2].next].max);
#line 381
  kp = 21;
#line 382
  npd = 0;
#line 385
  if (color == 1) {
#line 387
    i = (int )L[L[1].next].next;
    {
#line 387
    while (1) {
      while_continue: /* CIL Label */ ;
#line 387
      if (! (i != 0)) {
#line 387
        goto while_break;
      }
#line 388
      if ((int )B[i] == 33) {
#line 388
        npd = (int )(2U * dist[120 * i + (int )L[2].next].taxi);
      } else
#line 389
      if ((int )B[i] == 49) {
#line 391
        if ((int )*(sqcolor + i) == 1) {
#line 391
          kp = (int )*(Th + L[2].next);
        } else {
#line 391
          kp = (int )L[2].next;
        }
      }
#line 387
      i = (int )L[i].next;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 396
    i = (int )L[L[2].next].next;
    {
#line 396
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 396
      if (! (i != 0)) {
#line 396
        goto while_break___0;
      }
#line 397
      if ((int )B[i] == 34) {
#line 397
        npd = (int )(2U * dist[120 * i + (int )L[1].next].taxi);
      } else
#line 398
      if ((int )B[i] == 50) {
#line 400
        if ((int )*(sqcolor + i) == 1) {
#line 400
          kp = (int )*(Th + L[1].next);
        } else {
#line 400
          kp = (int )L[1].next;
        }
      }
#line 396
      i = (int )L[i].next;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 404
  if (color == Color) {
#line 404
    return ((- kdist - npd) + *(nb + kp));
  } else {
#line 405
    return ((kdist + npd) - *(nb + kp));
  }
}
}
#line 410 "/home/wheatley/newnew/temp/phalanx-22+d051004/endgame.c"
int e_rpr(void) 
{ 
  int wk ;
  int wr ;
  int wp ;
  int bk___0 ;
  int br ;
  int result ;
  int sstm ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 413
  result = 0;
#line 416
  if ((int )G[Counter].mtrl > (int )G[Counter].xmtrl) {
#line 417
    sstm = 1;
#line 417
    wk = (int )L[Color].next;
#line 417
    bk___0 = (int )L[Color ^ 3].next;
#line 417
    br = (int )L[bk___0].next;
  } else {
#line 419
    sstm = 0;
#line 419
    wk = (int )L[Color ^ 3].next;
#line 419
    bk___0 = (int )L[Color].next;
#line 419
    br = (int )L[bk___0].next;
  }
#line 421
  if (((int )B[L[wk].next] & 252) == 64) {
#line 422
    wr = (int )L[wk].next;
#line 422
    wp = (int )L[wr].next;
  } else {
#line 424
    wp = (int )L[wk].next;
#line 424
    wr = (int )L[wp].next;
  }
#line 426
  if ((int )B[bk___0] == 97) {
#line 427
    wk = (int )*(Th + wk);
#line 427
    wr = (int )*(Th + wr);
#line 427
    wp = (int )*(Th + wp);
#line 427
    bk___0 = (int )*(Th + bk___0);
#line 427
    br = (int )*(Th + br);
  }
#line 429
  if (wp % 10 > 4) {
#line 430
    wk = (int )*(Tv + wk);
#line 430
    wr = (int )*(Tv + wr);
#line 430
    wp = (int )*(Tv + wp);
#line 430
    bk___0 = (int )*(Tv + bk___0);
#line 430
    br = (int )*(Tv + br);
  }
#line 432
  result = wp / 10 - 5;
#line 433
  if (wp % 10 == 1) {
#line 433
    result -= 15;
  }
  {
#line 435
  tmp = abs(br % 10 - wp % 10);
#line 435
  result = (int )((unsigned int )result - (2U * dist[br * 120 + wp].max + (unsigned int )(3 * tmp)));
  }
#line 437
  if (bk___0 > wp) {
    {
#line 439
    if (wp % 10 - bk___0 % 10 == -2) {
#line 439
      goto case_neg_2;
    }
#line 440
    if (wp % 10 - bk___0 % 10 == -1) {
#line 440
      goto case_neg_1;
    }
#line 441
    if (wp % 10 - bk___0 % 10 == 0) {
#line 441
      goto case_0;
    }
#line 442
    if (wp % 10 - bk___0 % 10 == 1) {
#line 442
      goto case_1;
    }
#line 443
    if (wp % 10 - bk___0 % 10 == 2) {
#line 443
      goto case_2;
    }
#line 446
    goto switch_default;
    case_neg_2: /* CIL Label */ 
#line 439
    goto switch_break;
    case_neg_1: /* CIL Label */ 
#line 440
    result -= 20;
#line 440
    goto switch_break;
    case_0: /* CIL Label */ 
#line 441
    result -= 50;
#line 441
    goto switch_break;
    case_1: /* CIL Label */ 
#line 442
    result -= 40;
#line 442
    goto switch_break;
    case_2: /* CIL Label */ 
#line 443
    if (br % 10 - wp % 10 > 3) {
#line 443
      result -= 35;
    } else {
      {
#line 444
      tmp___0 = abs(br % 10 - wp % 10);
#line 444
      result -= tmp___0 * 3;
      }
    }
#line 445
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 446
    tmp___1 = abs(wp % 10 - bk___0 % 10);
#line 446
    result += 10 * tmp___1;
    }
    switch_break: /* CIL Label */ ;
    }
  } else {
#line 448
    result += 5 * (wp / 10 - bk___0 / 10);
  }
#line 450
  if (wk < wp) {
#line 450
    result -= 5 * (wp / 10 - wk / 10);
  }
#line 452
  if (br < wp) {
#line 452
    if ((br - wp) % 10 == 0) {
#line 452
      result -= 20;
    }
  }
#line 454
  if (sstm) {
#line 454
    return (result);
  } else {
#line 454
    return (- result);
  }
}
}
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 57 "/usr/include/getopt.h"
extern char *optarg ;
#line 150
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getopt)(int ___argc ,
                                                                             char * const  *___argv ,
                                                                             char const   *__shortopts ) ;
#line 169 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 180
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) rename)(char const   *__old ,
                                                                             char const   *__new ) ;
#line 237
extern int fclose(FILE *__stream ) ;
#line 242
extern int fflush(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 336
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setvbuf)(FILE * __restrict  __stream ,
                                                                              char * __restrict  __buf ,
                                                                              int __modes ,
                                                                              size_t __n ) ;
#line 433
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sscanf)(char const   * __restrict  __s ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 538
extern int getchar(void) ;
#line 759
extern void rewind(FILE *__stream ) ;
#line 765 "/usr/include/stdlib.h"
extern void ( __attribute__((__nonnull__(1,4))) qsort)(void *__base , size_t __nmemb ,
                                                       size_t __size , int (*__compar)(void const   * ,
                                                                                       void const   * ) ) ;
#line 432 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) unsigned int ( __attribute__((__leaf__)) alarm)(unsigned int __seconds ) ;
#line 102 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) __sighandler_t ( __attribute__((__leaf__)) signal)(int __sig ,
                                                                                        void (*__handler)(int  ) ) ;
#line 209 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) stat)(char const   * __restrict  __file ,
                                                                                             struct stat * __restrict  __buf ) ;
#line 465 "/home/wheatley/newnew/temp/phalanx-22+d051004/phalanx.h"
int bcreate(int argc , char **argv ) ;
#line 3 "/home/wheatley/newnew/temp/phalanx-22+d051004/bcreate.c"
int WIN  =    5;
#line 4 "/home/wheatley/newnew/temp/phalanx-22+d051004/bcreate.c"
int DRA  =    2;
#line 5 "/home/wheatley/newnew/temp/phalanx-22+d051004/bcreate.c"
int LOO  =    1;
#line 6 "/home/wheatley/newnew/temp/phalanx-22+d051004/bcreate.c"
int UNK  =    1;
#line 8 "/home/wheatley/newnew/temp/phalanx-22+d051004/bcreate.c"
int Asize  =    500000;
#line 11 "/home/wheatley/newnew/temp/phalanx-22+d051004/bcreate.c"
int MaxBookPly  =    70;
#line 13 "/home/wheatley/newnew/temp/phalanx-22+d051004/bcreate.c"
int MaxComment  =    4096;
#line 15 "/home/wheatley/newnew/temp/phalanx-22+d051004/bcreate.c"
int MinValue  =    15;
#line 17 "/home/wheatley/newnew/temp/phalanx-22+d051004/bcreate.c"
int MinPercentage  =    80;
#line 20 "/home/wheatley/newnew/temp/phalanx-22+d051004/bcreate.c"
FILE *tb1  ;
#line 20 "/home/wheatley/newnew/temp/phalanx-22+d051004/bcreate.c"
FILE *tb2  ;
#line 29 "/home/wheatley/newnew/temp/phalanx-22+d051004/bcreate.c"
tb *A  ;
#line 30 "/home/wheatley/newnew/temp/phalanx-22+d051004/bcreate.c"
int I  =    0;
#line 32 "/home/wheatley/newnew/temp/phalanx-22+d051004/bcreate.c"
int bsortkey(void const   *a , void const   *b ) 
{ 


  {
#line 34
  if (((tb *)a)->hashboard > ((tb *)b)->hashboard) {
#line 35
    return (1);
  } else
#line 37
  if (((tb *)a)->hashboard < ((tb *)b)->hashboard) {
#line 38
    return (-1);
  } else
#line 40
  if ((int )((tb *)a)->move > (int )((tb *)b)->move) {
#line 41
    return (1);
  } else
#line 43
  if ((int )((tb *)a)->move < (int )((tb *)b)->move) {
#line 44
    return (-1);
  } else {
#line 46
    return (0);
  }
}
}
#line 49 "/home/wheatley/newnew/temp/phalanx-22+d051004/bcreate.c"
int usortkey(void const   *a , void const   *b ) 
{ 


  {
#line 51
  if (((tb *)a)->n < ((tb *)b)->n) {
#line 52
    return (1);
  } else {
#line 53
    return (-1);
  }
}
}
#line 56 "/home/wheatley/newnew/temp/phalanx-22+d051004/bcreate.c"
int games  =    0;
#line 56 "/home/wheatley/newnew/temp/phalanx-22+d051004/bcreate.c"
int positions  =    0;
#line 58 "/home/wheatley/newnew/temp/phalanx-22+d051004/bcreate.c"
void printit(int x ) 
{ 


  {
  {
#line 60
  printf((char const   */* __restrict  */)"%8i%10i%7i%%\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b",
         games, positions, (I * 100) / Asize);
#line 62
  fflush(stdout);
#line 63
  signal(14, & printit);
#line 63
  alarm(5U);
  }
#line 64
  return;
}
}
#line 66 "/home/wheatley/newnew/temp/phalanx-22+d051004/bcreate.c"
void compress(void) 
{ 
  int i1 ;
  int i2 ;
  int i ;
  int done_m ;
  int done_f ;
  tb mtb ;
  tb ftb ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 69
  printit(0);
#line 70
  alarm(0U);
#line 71
  printf((char const   */* __restrict  */)"\nsorting buffer ............ ");
#line 73
  qsort((void *)A, (size_t )I, sizeof(tb ), & bsortkey);
#line 75
  puts("done");
#line 76
  printf((char const   */* __restrict  */)"compressing buffer ........ ");
#line 77
  i1 = 0;
#line 77
  i2 = 1;
  }
  {
#line 78
  while (1) {
    while_continue: /* CIL Label */ ;
#line 78
    if (! (i2 != I)) {
#line 78
      goto while_break;
    }
    {
#line 80
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 80
      if (i2 != I) {
#line 80
        if ((A + i1)->hashboard == (A + i2)->hashboard) {
#line 80
          if (! ((int )(A + i1)->move == (int )(A + i2)->move)) {
#line 80
            goto while_break___0;
          }
        } else {
#line 80
          goto while_break___0;
        }
      } else {
#line 80
        goto while_break___0;
      }
#line 84
      (A + i1)->n += (A + i2)->n;
#line 85
      i2 ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 87
    if (i2 != I) {
#line 88
      i1 ++;
#line 88
      *(A + i1) = *(A + i2);
#line 88
      i2 ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 90
  I = i1 + 1;
#line 91
  (A + I)->n = 0U;
#line 92
  printf((char const   */* __restrict  */)"done, buffer usage=%i (%i%%)\n", I, (100 * I) / Asize);
#line 98
  i = 0;
#line 102
  printf((char const   */* __restrict  */)"adding to file ............ ");
#line 103
  tb1 = fopen((char const   */* __restrict  */)"rbook.phalanx", (char const   */* __restrict  */)"rb");
#line 104
  tb2 = fopen((char const   */* __restrict  */)"rbook.phalanx.tmp", (char const   */* __restrict  */)"wb");
#line 105
  rewind(tb1);
#line 107
  mtb = *(A + 0);
#line 107
  i = 1;
#line 107
  done_m = i == I;
#line 108
  myfread((void *)(& ftb), (int )sizeof(tb ), tb1);
#line 108
  done_f = feof(tb1);
  }
  {
#line 110
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 110
    if (! (! done_f)) {
#line 110
      if (! (! done_m)) {
#line 110
        goto while_break___1;
      }
    }
#line 112
    if (! done_m) {
#line 112
      if (! done_f) {
        {
#line 112
        tmp___1 = bsortkey((void const   *)(& mtb), (void const   *)(& ftb));
        }
#line 112
        if (tmp___1 == 0) {
          {
#line 114
          mtb.n += ftb.n;
#line 115
          myfwrite((void *)(& mtb), (int )sizeof(tb ), tb2);
#line 116
          mtb = *(A + i);
#line 116
          i ++;
#line 116
          done_m = i == I;
#line 117
          myfread((void *)(& ftb), (int )sizeof(tb ), tb1);
#line 117
          done_f = feof(tb1);
          }
        } else {
#line 112
          goto _L___1;
        }
      } else {
#line 112
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */ 
#line 120
    if (! done_m) {
#line 120
      if (done_f) {
        {
#line 122
        myfwrite((void *)(& mtb), (int )sizeof(tb ), tb2);
#line 123
        mtb = *(A + i);
#line 123
        i ++;
#line 123
        done_m = i == I;
        }
      } else {
        {
#line 120
        tmp___0 = bsortkey((void const   *)(& mtb), (void const   *)(& ftb));
        }
#line 120
        if (tmp___0 == -1) {
          {
#line 122
          myfwrite((void *)(& mtb), (int )sizeof(tb ), tb2);
#line 123
          mtb = *(A + i);
#line 123
          i ++;
#line 123
          done_m = i == I;
          }
        } else {
#line 120
          goto _L;
        }
      }
    } else
    _L: /* CIL Label */ 
#line 126
    if (! done_f) {
#line 126
      if (done_m) {
        {
#line 128
        myfwrite((void *)(& ftb), (int )sizeof(tb ), tb2);
#line 129
        myfread((void *)(& ftb), (int )sizeof(tb ), tb1);
#line 129
        done_f = feof(tb1);
        }
      } else {
        {
#line 126
        tmp = bsortkey((void const   *)(& mtb), (void const   *)(& ftb));
        }
#line 126
        if (tmp == 1) {
          {
#line 128
          myfwrite((void *)(& ftb), (int )sizeof(tb ), tb2);
#line 129
          myfread((void *)(& ftb), (int )sizeof(tb ), tb1);
#line 129
          done_f = feof(tb1);
          }
        }
      }
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 136
  fclose(tb1);
#line 136
  fclose(tb2);
#line 137
  rename("rbook.phalanx.tmp", "rbook.phalanx");
#line 138
  printf((char const   */* __restrict  */)"done\n");
#line 141
  I = 0;
#line 143
  alarm(5U);
  }
#line 144
  return;
}
}
#line 146 "/home/wheatley/newnew/temp/phalanx-22+d051004/bcreate.c"
int bpoints  ;
#line 146 "/home/wheatley/newnew/temp/phalanx-22+d051004/bcreate.c"
int wpoints  ;
#line 148 "/home/wheatley/newnew/temp/phalanx-22+d051004/bcreate.c"
int findgame(void) 
{ 
  register int c ;
  register int found___0 ;
  char s[64] ;
  char *tmp ;
  int nlns ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 150
  found___0 = 0;
#line 152
  bpoints = 0;
#line 152
  wpoints = 0;
  {
#line 153
  while (1) {
    while_continue: /* CIL Label */ ;
#line 153
    if (! (! found___0)) {
#line 153
      goto while_break;
    }
    {
#line 154
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 154
      c = getchar();
      }
#line 154
      if (c != -1) {
#line 154
        if (! (c != 82)) {
#line 154
          goto while_break___0;
        }
      } else {
#line 154
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 155
    if (c == -1) {
#line 155
      return (0);
    }
    {
#line 156
    tmp = fgets((char */* __restrict  */)(s), 6, (FILE */* __restrict  */)stdin);
    }
#line 156
    if ((unsigned long )tmp == (unsigned long )((void *)0)) {
#line 156
      return (0);
    }
    {
#line 157
    tmp___4 = strncmp((char const   *)(s), "esult", (size_t )5);
    }
#line 157
    if (tmp___4 == 0) {
#line 159
      nlns = 0;
      {
#line 160
      while (1) {
        while_continue___1: /* CIL Label */ ;
        {
#line 160
        c = getchar();
        }
#line 160
        if (! (c == 32)) {
#line 160
          goto while_break___1;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 161
      tmp___0 = fgets((char */* __restrict  */)(s), 4, (FILE */* __restrict  */)stdin);
      }
#line 161
      if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
#line 161
        return (0);
      }
      {
#line 162
      tmp___3 = strncmp((char const   *)(s), "1-0", (size_t )3);
      }
#line 162
      if (tmp___3 == 0) {
#line 162
        bpoints = LOO;
#line 162
        wpoints = WIN;
      } else {
        {
#line 163
        tmp___2 = strncmp((char const   *)(s), "0-1", (size_t )3);
        }
#line 163
        if (tmp___2 == 0) {
#line 163
          bpoints = WIN;
#line 163
          wpoints = LOO;
        } else {
          {
#line 164
          tmp___1 = strncmp((char const   *)(s), "1/2", (size_t )3);
          }
#line 164
          if (tmp___1 == 0) {
#line 164
            bpoints = DRA;
#line 164
            wpoints = DRA;
          } else {
#line 165
            bpoints = UNK;
#line 165
            wpoints = UNK;
          }
        }
      }
      {
#line 168
      while (1) {
        while_continue___2: /* CIL Label */ ;
        {
#line 168
        c = getchar();
        }
#line 168
        if (c != -1) {
#line 168
          if (! (nlns < 2)) {
#line 168
            goto while_break___2;
          }
        } else {
#line 168
          goto while_break___2;
        }
#line 169
        if (c == 10) {
#line 169
          nlns ++;
        } else {
#line 169
          nlns = 0;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
#line 171
      if (c != -1) {
#line 171
        return (1);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 174
  return (0);
}
}
#line 182 "/home/wheatley/newnew/temp/phalanx-22+d051004/bcreate.c"
static tmove m[256]  ;
#line 184 "/home/wheatley/newnew/temp/phalanx-22+d051004/bcreate.c"
static int n  ;
#line 181 "/home/wheatley/newnew/temp/phalanx-22+d051004/bcreate.c"
int addmove(unsigned char *move ) 
{ 
  tmove *mf ;
  int tmp ;
  int tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;

  {
#line 186
  if (Color == 1) {
#line 186
    tmp = (int )L[1].next;
  } else {
#line 186
    tmp = (int )L[2].next;
  }
  {
#line 186
  tmp___0 = attacktest(tmp, Color ^ 3);
#line 186
  generate_legal_moves(m, & n, tmp___0);
#line 187
  mf = sandex((char *)move, m, n);
  }
#line 187
  if ((unsigned long )mf != (unsigned long )((void *)0)) {
#line 189
    if (Color == 1) {
#line 190
      if (wpoints) {
        {
#line 191
        (A + I)->hashboard = G[Counter].hashboard;
#line 192
        tmp___1 = smove(mf);
#line 192
        (A + I)->move = (unsigned short )tmp___1;
#line 193
        (A + I)->n = (unsigned int )wpoints;
#line 193
        positions ++;
#line 194
        I ++;
        }
#line 194
        if (I >= Asize) {
          {
#line 194
          compress();
          }
        }
      }
    } else
#line 198
    if (bpoints) {
      {
#line 199
      (A + I)->hashboard = G[Counter].hashboard;
#line 200
      tmp___2 = smove(mf);
#line 200
      (A + I)->move = (unsigned short )tmp___2;
#line 201
      (A + I)->n = (unsigned int )bpoints;
#line 201
      positions ++;
#line 202
      I ++;
      }
#line 202
      if (I >= Asize) {
        {
#line 202
        compress();
        }
      }
    }
    {
#line 205
    do_move(mf);
    }
#line 206
    return (1);
  } else {
#line 207
    return (0);
  }
}
}
#line 210 "/home/wheatley/newnew/temp/phalanx-22+d051004/bcreate.c"
void parsegame(void) 
{ 
  register int c ;
  unsigned char m___1[128] ;
  int i ;
  int csize ;
  int tmp ;
  unsigned short const   **tmp___0 ;
  int csize___0 ;
  int tmp___1 ;

  {
  {
#line 211
  c = '*';
#line 214
  setfen((char *)"rnbqkbnr/pppppppp/////PPPPPPPP/RNBQKBNR/w");
  }
  {
#line 215
  while (1) {
    while_continue: /* CIL Label */ ;
#line 215
    if (c != 91) {
#line 215
      if (c != -1) {
#line 215
        if (! (Counter < MaxBookPly)) {
#line 215
          goto while_break;
        }
      } else {
#line 215
        goto while_break;
      }
    } else {
#line 215
      goto while_break;
    }
    {
#line 216
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 216
      c = getchar();
      }
#line 216
      if (c != 46) {
#line 216
        if (! (c != -1)) {
#line 216
          goto while_break___0;
        }
      } else {
#line 216
        goto while_break___0;
      }
#line 217
      if (c == 123) {
#line 219
        csize = 0;
        {
#line 220
        while (1) {
          while_continue___1: /* CIL Label */ ;
          {
#line 220
          c = getchar();
          }
#line 220
          if (c != 125) {
#line 220
            if (c != -1) {
#line 220
              if (! (csize < MaxComment)) {
#line 220
                goto while_break___1;
              }
            } else {
#line 220
              goto while_break___1;
            }
          } else {
#line 220
            goto while_break___1;
          }
#line 221
          csize ++;
        }
        while_break___1: /* CIL Label */ ;
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 223
    while (1) {
      while_continue___2: /* CIL Label */ ;
      {
#line 223
      c = getchar();
      }
#line 223
      if (! (c == 32)) {
#line 223
        if (! (c == 10)) {
#line 223
          goto while_break___2;
        }
      }
    }
    while_break___2: /* CIL Label */ ;
    }
#line 224
    m___1[0] = (unsigned char )c;
#line 224
    i = 1;
    {
#line 225
    while (1) {
      while_continue___3: /* CIL Label */ ;
      {
#line 225
      c = getchar();
      }
#line 225
      if (c != 32) {
#line 225
        if (c != 10) {
#line 225
          if (! (c != -1)) {
#line 225
            goto while_break___3;
          }
        } else {
#line 225
          goto while_break___3;
        }
      } else {
#line 225
        goto while_break___3;
      }
#line 225
      m___1[i] = (unsigned char )c;
#line 225
      i ++;
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 226
    m___1[i] = (unsigned char )'\000';
#line 227
    tmp = addmove(m___1);
    }
#line 227
    if (! tmp) {
#line 227
      goto while_break;
    }
    blackmove: ;
    {
#line 231
    while (1) {
      while_continue___4: /* CIL Label */ ;
      {
#line 231
      c = getchar();
      }
#line 231
      if (! (c == 32)) {
#line 231
        if (! (c == 10)) {
#line 231
          if (! (c == 46)) {
            {
#line 231
            tmp___0 = __ctype_b_loc();
            }
#line 231
            if (! ((int const   )*(*tmp___0 + c) & 2048)) {
#line 231
              goto while_break___4;
            }
          }
        }
      }
    }
    while_break___4: /* CIL Label */ ;
    }
#line 232
    if (c == 123) {
#line 234
      csize___0 = 0;
      {
#line 235
      while (1) {
        while_continue___5: /* CIL Label */ ;
        {
#line 235
        c = getchar();
        }
#line 235
        if (c != 125) {
#line 235
          if (c != -1) {
#line 235
            if (! (csize___0 < MaxComment)) {
#line 235
              goto while_break___5;
            }
          } else {
#line 235
            goto while_break___5;
          }
        } else {
#line 235
          goto while_break___5;
        }
#line 236
        csize___0 ++;
      }
      while_break___5: /* CIL Label */ ;
      }
#line 237
      goto blackmove;
    }
#line 239
    if (c == 91) {
#line 239
      return;
    } else
#line 239
    if (c == -1) {
#line 239
      return;
    }
#line 240
    m___1[0] = (unsigned char )c;
#line 240
    i = 1;
    {
#line 241
    while (1) {
      while_continue___6: /* CIL Label */ ;
      {
#line 241
      c = getchar();
      }
#line 241
      if (c != 32) {
#line 241
        if (c != 10) {
#line 241
          if (! (c != -1)) {
#line 241
            goto while_break___6;
          }
        } else {
#line 241
          goto while_break___6;
        }
      } else {
#line 241
        goto while_break___6;
      }
#line 241
      m___1[i] = (unsigned char )c;
#line 241
      i ++;
    }
    while_break___6: /* CIL Label */ ;
    }
    {
#line 242
    m___1[i] = (unsigned char )'\000';
#line 243
    tmp___1 = addmove(m___1);
    }
#line 243
    if (! tmp___1) {
#line 243
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 245
  return;
}
}
#line 247 "/home/wheatley/newnew/temp/phalanx-22+d051004/bcreate.c"
void wusage(void) 
{ 


  {
  {
#line 249
  printf((char const   */* __restrict  */)"Usage:   phalanx bcreate <buffer size in cells>\n");
#line 250
  printf((char const   */* __restrict  */)"Options: -b <buffer size in cells>     one cell is %lu bytes\n",
         sizeof(tb ));
#line 252
  printf((char const   */* __restrict  */)"         -p <maxply>\n");
#line 253
  printf((char const   */* __restrict  */)"         -c <max length of comment>\n");
#line 254
  printf((char const   */* __restrict  */)"         -v <min value of move to add>\n");
#line 255
  printf((char const   */* __restrict  */)"         -g <min value percentage of best move to add others>\n");
#line 256
  printf((char const   */* __restrict  */)"         -w <winning move value>\n");
#line 257
  printf((char const   */* __restrict  */)"         -d <drawing move value>\n");
#line 258
  printf((char const   */* __restrict  */)"         -l <losing move value>\n");
#line 259
  printf((char const   */* __restrict  */)"         -u <unknown result move value>\n");
#line 261
  exit(0);
  }
}
}
#line 264 "/home/wheatley/newnew/temp/phalanx-22+d051004/bcreate.c"
int bcreate(int argc , char **argv ) 
{ 
  FILE *f ;
  int c ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  void *tmp___8 ;
  struct stat fs ;
  int tmp___9 ;
  int tmp___10 ;
  int dots ;
  struct stat fs___0 ;
  int fsize ;
  tb M ;
  int i ;
  int minn ;
  int fpos ;
  long tmp___11 ;
  int tmp___12 ;
  unsigned int i___0 ;
  unsigned int j ;
  unsigned int p ;
  unsigned short m___1 ;
  int tmp___13 ;

  {
  {
#line 269
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 269
    c = getopt(argc, (char * const  *)argv, "b:p:c:v:g:w:d:l:u:");
    }
#line 269
    if (! (c != -1)) {
#line 269
      goto while_break;
    }
    {
#line 272
    if (c == 98) {
#line 272
      goto case_98;
    }
#line 276
    if (c == 112) {
#line 276
      goto case_112;
    }
#line 280
    if (c == 99) {
#line 280
      goto case_99;
    }
#line 284
    if (c == 118) {
#line 284
      goto case_118;
    }
#line 288
    if (c == 103) {
#line 288
      goto case_103;
    }
#line 292
    if (c == 119) {
#line 292
      goto case_119;
    }
#line 296
    if (c == 100) {
#line 296
      goto case_100;
    }
#line 300
    if (c == 108) {
#line 300
      goto case_108;
    }
#line 304
    if (c == 117) {
#line 304
      goto case_117;
    }
#line 308
    goto switch_default;
    case_98: /* CIL Label */ 
    {
#line 273
    tmp = sscanf((char const   */* __restrict  */)optarg, (char const   */* __restrict  */)"%i",
                 & Asize);
    }
#line 273
    if (tmp == 0) {
      {
#line 273
      wusage();
      }
    }
#line 274
    if (Asize < 1000) {
      {
#line 274
      wusage();
      }
    }
#line 275
    goto switch_break;
    case_112: /* CIL Label */ 
    {
#line 277
    tmp___0 = sscanf((char const   */* __restrict  */)optarg, (char const   */* __restrict  */)"%i",
                     & MaxBookPly);
    }
#line 277
    if (tmp___0 == 0) {
      {
#line 277
      wusage();
      }
    }
#line 278
    if (MaxBookPly < 2) {
      {
#line 278
      wusage();
      }
    }
#line 279
    goto switch_break;
    case_99: /* CIL Label */ 
    {
#line 281
    tmp___1 = sscanf((char const   */* __restrict  */)optarg, (char const   */* __restrict  */)"%i",
                     & MaxComment);
    }
#line 281
    if (tmp___1 == 0) {
      {
#line 281
      wusage();
      }
    }
#line 282
    if (MaxComment < 2) {
      {
#line 282
      wusage();
      }
    }
#line 283
    goto switch_break;
    case_118: /* CIL Label */ 
    {
#line 285
    tmp___2 = sscanf((char const   */* __restrict  */)optarg, (char const   */* __restrict  */)"%i",
                     & MinValue);
    }
#line 285
    if (tmp___2 == 0) {
      {
#line 285
      wusage();
      }
    }
#line 286
    if (MinValue < 0) {
      {
#line 286
      wusage();
      }
    }
#line 287
    goto switch_break;
    case_103: /* CIL Label */ 
    {
#line 289
    tmp___3 = sscanf((char const   */* __restrict  */)optarg, (char const   */* __restrict  */)"%i",
                     & MinPercentage);
    }
#line 289
    if (tmp___3 == 0) {
      {
#line 289
      wusage();
      }
    }
#line 290
    if (MinPercentage < 50) {
      {
#line 290
      wusage();
      }
    } else
#line 290
    if (MinPercentage > 100) {
      {
#line 290
      wusage();
      }
    }
#line 291
    goto switch_break;
    case_119: /* CIL Label */ 
    {
#line 293
    tmp___4 = sscanf((char const   */* __restrict  */)optarg, (char const   */* __restrict  */)"%i",
                     & WIN);
    }
#line 293
    if (tmp___4 == 0) {
      {
#line 293
      wusage();
      }
    }
#line 294
    if (WIN < 1) {
      {
#line 294
      wusage();
      }
    } else
#line 294
    if (WIN > 10) {
      {
#line 294
      wusage();
      }
    }
#line 295
    goto switch_break;
    case_100: /* CIL Label */ 
    {
#line 297
    tmp___5 = sscanf((char const   */* __restrict  */)optarg, (char const   */* __restrict  */)"%i",
                     & DRA);
    }
#line 297
    if (tmp___5 == 0) {
      {
#line 297
      wusage();
      }
    }
#line 298
    if (DRA < 0) {
      {
#line 298
      wusage();
      }
    } else
#line 298
    if (DRA > 10) {
      {
#line 298
      wusage();
      }
    }
#line 299
    goto switch_break;
    case_108: /* CIL Label */ 
    {
#line 301
    tmp___6 = sscanf((char const   */* __restrict  */)optarg, (char const   */* __restrict  */)"%i",
                     & LOO);
    }
#line 301
    if (tmp___6 == 0) {
      {
#line 301
      wusage();
      }
    }
#line 302
    if (LOO < 0) {
      {
#line 302
      wusage();
      }
    } else
#line 302
    if (LOO > 10) {
      {
#line 302
      wusage();
      }
    }
#line 303
    goto switch_break;
    case_117: /* CIL Label */ 
    {
#line 305
    tmp___7 = sscanf((char const   */* __restrict  */)optarg, (char const   */* __restrict  */)"%i",
                     & UNK);
    }
#line 305
    if (tmp___7 == 0) {
      {
#line 305
      wusage();
      }
    }
#line 306
    if (UNK < 0) {
      {
#line 306
      wusage();
      }
    } else
#line 306
    if (UNK > 10) {
      {
#line 306
      wusage();
      }
    }
#line 307
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 308
    wusage();
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 311
  tmp___8 = malloc((unsigned long )Asize * sizeof(tb ));
#line 311
  A = (tb *)tmp___8;
  }
#line 312
  if ((unsigned long )A == (unsigned long )((void *)0)) {
    {
#line 313
    printf((char const   */* __restrict  */)"cannot alloc %lu bytes of memory\n",
           (unsigned long )Asize * sizeof(tb ));
#line 314
    exit(0);
    }
  }
  {
#line 319
  tmp___9 = stat((char const   */* __restrict  */)"rbook.phalanx", (struct stat */* __restrict  */)(& fs));
  }
#line 319
  if (tmp___9) {
    {
#line 322
    tb1 = fopen((char const   */* __restrict  */)"rbook.phalanx", (char const   */* __restrict  */)"w+");
    }
  } else {
    {
#line 320
    puts("rbook.phalanx exists, skipping stage 1");
    }
#line 320
    goto stage_2;
  }
  {
#line 325
  setvbuf((FILE */* __restrict  */)stdout, (char */* __restrict  */)((char *)((void *)0)),
          2, (size_t )0);
#line 326
  puts("creating opening book");
#line 327
  puts("-----------------------------");
#line 328
  puts("   games positions buffer%");
#line 329
  puts("-----------------------------");
#line 330
  signal(14, & printit);
#line 330
  alarm(5U);
  }
  {
#line 331
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 331
    tmp___10 = findgame();
    }
#line 331
    if (! tmp___10) {
#line 331
      goto while_break___0;
    }
    {
#line 332
    parsegame();
#line 332
    games ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 333
  printf((char const   */* __restrict  */)"end of file, parsed %i positions in %i games\n",
         positions, games);
  }
#line 334
  if (games == 0) {
    {
#line 335
    puts("opening book not created");
    }
#line 335
    return (0);
  }
  {
#line 336
  compress();
#line 336
  alarm(0U);
  }
  stage_2: 
  {
#line 340
  f = fopen((char const   */* __restrict  */)"sbook.phalanx", (char const   */* __restrict  */)"wb");
  }
#line 340
  if ((unsigned long )f == (unsigned long )((void *)0)) {
    {
#line 341
    printf((char const   */* __restrict  */)"cannot create book file %s\n", "sbook.phalanx");
    }
#line 341
    return (1);
  }
  {
#line 344
  dots = 0;
#line 348
  tb1 = fopen((char const   */* __restrict  */)"rbook.phalanx", (char const   */* __restrict  */)"rb");
#line 349
  myfread((void *)(& M), (int )sizeof(tb ), tb1);
#line 351
  stat((char const   */* __restrict  */)"rbook.phalanx", (struct stat */* __restrict  */)(& fs___0));
#line 351
  fsize = (int )((unsigned long )fs___0.st_size / sizeof(tb ));
#line 353
  printf((char const   */* __restrict  */)"writing book ");
  }
  {
#line 355
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 355
    tmp___13 = feof(tb1);
    }
#line 355
    if (tmp___13) {
#line 355
      goto while_break___1;
    }
#line 359
    *(A + 0) = M;
#line 360
    I = 0;
    {
#line 362
    while (1) {
      while_continue___2: /* CIL Label */ ;
      {
#line 364
      tmp___11 = ftell(tb1);
#line 364
      fpos = (int )((unsigned long )tmp___11 / sizeof(tb ));
      }
#line 365
      if (fpos % (fsize / 30) == 1) {
#line 367
        if (dots == 3) {
          {
#line 368
          printf((char const   */* __restrict  */)"%i%%", (int )(((float )fpos * (float )100) / (float )fsize + (float )1));
#line 368
          dots = 0;
          }
        } else {
          {
#line 369
          printf((char const   */* __restrict  */)".");
          }
        }
#line 370
        dots ++;
      }
      {
#line 372
      I ++;
#line 372
      myfread((void *)(A + I), (int )sizeof(tb ), tb1);
#line 362
      tmp___12 = feof(tb1);
      }
#line 362
      if (tmp___12) {
#line 362
        goto while_break___2;
      } else
#line 362
      if (! (M.hashboard == (A + I)->hashboard)) {
#line 362
        goto while_break___2;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 376
    M = *(A + I);
#line 379
    qsort((void *)A, (size_t )I, sizeof(tb ), & usortkey);
#line 382
    i___0 = 100U;
#line 382
    j = 10U;
#line 382
    p = (unsigned int )MinPercentage;
    }
    {
#line 383
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 383
      if ((A + 0)->n > i___0) {
#line 383
        if (! (p > 10U)) {
#line 383
          goto while_break___3;
        }
      } else {
#line 383
        goto while_break___3;
      }
#line 383
      p -= j;
#line 383
      j --;
#line 383
      i___0 *= 10U;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 384
    minn = (int )(((A + 0)->n * p) / 100U);
#line 387
    if ((unsigned int )minn > (A + 0)->n) {
#line 387
      minn = (int )(A + 0)->n;
    }
#line 389
    if (minn < MinValue) {
#line 389
      minn = MinValue;
    }
#line 391
    i = 0;
    {
#line 391
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 391
      if (i != I) {
#line 391
        if (! ((A + i)->n >= (unsigned int )minn)) {
#line 391
          goto while_break___4;
        }
      } else {
#line 391
        goto while_break___4;
      }
#line 391
      i ++;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 398
    I = i;
#line 400
    i = 0;
    {
#line 400
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 400
      if (! (i != I)) {
#line 400
        goto while_break___5;
      }
      {
#line 402
      m___1 = (A + i)->move;
#line 403
      myfwrite((void *)(A + i), (int )sizeof(unsigned int ), f);
#line 404
      myfwrite((void *)(& m___1), (int )sizeof(unsigned short ), f);
#line 400
      i ++;
      }
    }
    while_break___5: /* CIL Label */ ;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 407
  printf((char const   */* __restrict  */)" done\n");
  }
#line 410
  return (0);
}
}
#line 392 "/home/wheatley/newnew/temp/phalanx-22+d051004/phalanx.h"
tflag Flag  ;
#line 394 "/home/wheatley/newnew/temp/phalanx-22+d051004/phalanx.h"
tsquare B[120]  ;
#line 395 "/home/wheatley/newnew/temp/phalanx-22+d051004/phalanx.h"
tlist L[120]  ;
#line 402 "/home/wheatley/newnew/temp/phalanx-22+d051004/phalanx.h"
tdist dist[14400]  ;
#line 404 "/home/wheatley/newnew/temp/phalanx-22+d051004/phalanx.h"
int Color  ;
#line 405 "/home/wheatley/newnew/temp/phalanx-22+d051004/phalanx.h"
int LastIter  ;
#line 406 "/home/wheatley/newnew/temp/phalanx-22+d051004/phalanx.h"
int Depth  ;
#line 407 "/home/wheatley/newnew/temp/phalanx-22+d051004/phalanx.h"
int Ply  ;
#line 408 "/home/wheatley/newnew/temp/phalanx-22+d051004/phalanx.h"
int FollowPV  ;
#line 409 "/home/wheatley/newnew/temp/phalanx-22+d051004/phalanx.h"
int Totmat  ;
#line 410 "/home/wheatley/newnew/temp/phalanx-22+d051004/phalanx.h"
int Abort  ;
#line 410 "/home/wheatley/newnew/temp/phalanx-22+d051004/phalanx.h"
int NoAbort  ;
#line 411
long AllDepth ;
#line 412
int64 AllNPS ;
#line 417 "/home/wheatley/newnew/temp/phalanx-22+d051004/phalanx.h"
tgamenode G[1024]  ;
#line 418 "/home/wheatley/newnew/temp/phalanx-22+d051004/phalanx.h"
int Counter  ;
#line 420 "/home/wheatley/newnew/temp/phalanx-22+d051004/phalanx.h"
int64 Nodes  ;
#line 427
int N_moves[8] ;
#line 427
int RB_dirs[8] ;
#line 433 "/home/wheatley/newnew/temp/phalanx-22+d051004/phalanx.h"
tmove PV[40][40]  ;
#line 434 "/home/wheatley/newnew/temp/phalanx-22+d051004/phalanx.h"
tmove Pondermove  ;
#line 439
int *HS ;
#line 440
int HP[100] ;
#line 453 "/home/wheatley/newnew/temp/phalanx-22+d051004/phalanx.h"
int A_n  ;
#line 453 "/home/wheatley/newnew/temp/phalanx-22+d051004/phalanx.h"
int A_i  ;
#line 453 "/home/wheatley/newnew/temp/phalanx-22+d051004/phalanx.h"
int A_d  ;
#line 454 "/home/wheatley/newnew/temp/phalanx-22+d051004/phalanx.h"
tmove *A_m  ;
#line 18 "/home/wheatley/newnew/temp/phalanx-22+d051004/data.c"
int DrawScore  =    -20;
#line 19 "/home/wheatley/newnew/temp/phalanx-22+d051004/data.c"
long AllDepth  =    0L;
#line 20 "/home/wheatley/newnew/temp/phalanx-22+d051004/data.c"
int64 AllNPS  =    (int64 )0;
#line 27 "/home/wheatley/newnew/temp/phalanx-22+d051004/data.c"
int N_moves[8]  = 
#line 27
  {      -21,      -19,      -12,      -8, 
        21,      19,      12,      8};
#line 28 "/home/wheatley/newnew/temp/phalanx-22+d051004/data.c"
int RB_dirs[8]  = 
#line 28
  {      1,      -1,      10,      -10, 
        11,      -11,      9,      -9};
#line 30 "/home/wheatley/newnew/temp/phalanx-22+d051004/data.c"
int Values[7]  = {      0,      100,      350,      350, 
        550,      1050,      0};
#line 33 "/home/wheatley/newnew/temp/phalanx-22+d051004/data.c"
signed char Th_[80]  = 
#line 33
  {      (signed char)0,      (signed char)91,      (signed char)92,      (signed char)93, 
        (signed char)94,      (signed char)95,      (signed char)96,      (signed char)97, 
        (signed char)98,      (signed char)0,      (signed char)0,      (signed char)81, 
        (signed char)82,      (signed char)83,      (signed char)84,      (signed char)85, 
        (signed char)86,      (signed char)87,      (signed char)88,      (signed char)0, 
        (signed char)0,      (signed char)71,      (signed char)72,      (signed char)73, 
        (signed char)74,      (signed char)75,      (signed char)76,      (signed char)77, 
        (signed char)78,      (signed char)0,      (signed char)0,      (signed char)61, 
        (signed char)62,      (signed char)63,      (signed char)64,      (signed char)65, 
        (signed char)66,      (signed char)67,      (signed char)68,      (signed char)0, 
        (signed char)0,      (signed char)51,      (signed char)52,      (signed char)53, 
        (signed char)54,      (signed char)55,      (signed char)56,      (signed char)57, 
        (signed char)58,      (signed char)0,      (signed char)0,      (signed char)41, 
        (signed char)42,      (signed char)43,      (signed char)44,      (signed char)45, 
        (signed char)46,      (signed char)47,      (signed char)48,      (signed char)0, 
        (signed char)0,      (signed char)31,      (signed char)32,      (signed char)33, 
        (signed char)34,      (signed char)35,      (signed char)36,      (signed char)37, 
        (signed char)38,      (signed char)0,      (signed char)0,      (signed char)21, 
        (signed char)22,      (signed char)23,      (signed char)24,      (signed char)25, 
        (signed char)26,      (signed char)27,      (signed char)28,      (signed char)0};
#line 43 "/home/wheatley/newnew/temp/phalanx-22+d051004/data.c"
signed char *Th  =    Th_ - 20;
#line 45 "/home/wheatley/newnew/temp/phalanx-22+d051004/data.c"
signed char Tv_[80]  = 
#line 45
  {      (signed char)0,      (signed char)28,      (signed char)27,      (signed char)26, 
        (signed char)25,      (signed char)24,      (signed char)23,      (signed char)22, 
        (signed char)21,      (signed char)0,      (signed char)0,      (signed char)38, 
        (signed char)37,      (signed char)36,      (signed char)35,      (signed char)34, 
        (signed char)33,      (signed char)32,      (signed char)31,      (signed char)0, 
        (signed char)0,      (signed char)48,      (signed char)47,      (signed char)46, 
        (signed char)45,      (signed char)44,      (signed char)43,      (signed char)42, 
        (signed char)41,      (signed char)0,      (signed char)0,      (signed char)58, 
        (signed char)57,      (signed char)56,      (signed char)55,      (signed char)54, 
        (signed char)53,      (signed char)52,      (signed char)51,      (signed char)0, 
        (signed char)0,      (signed char)68,      (signed char)67,      (signed char)66, 
        (signed char)65,      (signed char)64,      (signed char)63,      (signed char)62, 
        (signed char)61,      (signed char)0,      (signed char)0,      (signed char)78, 
        (signed char)77,      (signed char)76,      (signed char)75,      (signed char)74, 
        (signed char)73,      (signed char)72,      (signed char)71,      (signed char)0, 
        (signed char)0,      (signed char)88,      (signed char)87,      (signed char)86, 
        (signed char)85,      (signed char)84,      (signed char)83,      (signed char)82, 
        (signed char)81,      (signed char)0,      (signed char)0,      (signed char)98, 
        (signed char)97,      (signed char)96,      (signed char)95,      (signed char)94, 
        (signed char)93,      (signed char)92,      (signed char)91,      (signed char)0};
#line 55 "/home/wheatley/newnew/temp/phalanx-22+d051004/data.c"
signed char *Tv  =    Tv_ - 20;
#line 57 "/home/wheatley/newnew/temp/phalanx-22+d051004/data.c"
int HP[100]  = 
#line 57
  {      0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      1,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      3,      2,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      5,      4,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      7,      6,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      9,      8,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      11,      10,      0};
#line 68 "/home/wheatley/newnew/temp/phalanx-22+d051004/data.c"
int HS_[80]  = 
#line 68
  {      0,      0,      1,      2, 
        3,      4,      5,      6, 
        7,      0,      0,      8, 
        9,      10,      11,      12, 
        13,      14,      15,      0, 
        0,      16,      17,      18, 
        19,      20,      21,      22, 
        23,      0,      0,      24, 
        25,      26,      27,      28, 
        29,      30,      31,      0, 
        0,      32,      33,      34, 
        35,      36,      37,      38, 
        39,      0,      0,      40, 
        41,      42,      43,      44, 
        45,      46,      47,      0, 
        0,      48,      49,      50, 
        51,      52,      53,      54, 
        55,      0,      0,      56, 
        57,      58,      59,      60, 
        61,      62,      63,      0};
#line 78 "/home/wheatley/newnew/temp/phalanx-22+d051004/data.c"
int *HS  =    HS_ - 20;
#line 83 "/home/wheatley/newnew/temp/phalanx-22+d051004/data.c"
int taxi_dist(int a , int b ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
#line 84
  tmp = abs(a % 10 - b % 10);
#line 84
  tmp___0 = abs(a / 10 - b / 10);
  }
#line 84
  return (tmp + tmp___0);
}
}
#line 86 "/home/wheatley/newnew/temp/phalanx-22+d051004/data.c"
int diag_dist(int a , int b ) 
{ 
  int fdi ;
  int tmp ;
  int rdi ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 88
  tmp = abs(a % 10 - b % 10);
#line 88
  fdi = tmp;
#line 89
  tmp___0 = abs(a / 10 - b / 10);
#line 89
  rdi = tmp___0;
#line 90
  tmp___1 = abs(rdi - fdi);
  }
#line 90
  if (rdi > fdi) {
#line 90
    tmp___2 = rdi;
  } else {
#line 90
    tmp___2 = fdi;
  }
#line 90
  return (tmp___1 + tmp___2);
}
}
#line 93 "/home/wheatley/newnew/temp/phalanx-22+d051004/data.c"
int max_dist(int a , int b ) 
{ 
  int fdi ;
  int tmp ;
  int rdi ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 95
  tmp = abs(a % 10 - b % 10);
#line 95
  fdi = tmp;
#line 96
  tmp___0 = abs(a / 10 - b / 10);
#line 96
  rdi = tmp___0;
  }
#line 97
  if (rdi > fdi) {
#line 97
    tmp___1 = rdi;
  } else {
#line 97
    tmp___1 = fdi;
  }
#line 97
  return (tmp___1);
}
}
#line 100 "/home/wheatley/newnew/temp/phalanx-22+d051004/data.c"
int min_dist(int a , int b ) 
{ 
  int fdi ;
  int tmp ;
  int rdi ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 102
  tmp = abs(a % 10 - b % 10);
#line 102
  fdi = tmp;
#line 103
  tmp___0 = abs(a / 10 - b / 10);
#line 103
  rdi = tmp___0;
  }
#line 104
  if (rdi < fdi) {
#line 104
    tmp___1 = rdi;
  } else {
#line 104
    tmp___1 = fdi;
  }
#line 104
  return (tmp___1);
}
}
#line 107 "/home/wheatley/newnew/temp/phalanx-22+d051004/data.c"
void initdist(void) 
{ 
  int i ;
  int j ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 110
  i = 21;
  {
#line 110
  while (1) {
    while_continue: /* CIL Label */ ;
#line 110
    if (! (i != 99)) {
#line 110
      goto while_break;
    }
#line 110
    j = 21;
    {
#line 110
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 110
      if (! (j != 99)) {
#line 110
        goto while_break___0;
      }
      {
#line 112
      tmp = taxi_dist(i, j);
#line 112
      dist[120 * i + j].taxi = (unsigned int )tmp;
#line 113
      tmp___0 = diag_dist(i, j);
#line 113
      dist[120 * i + j].diag = (unsigned int )tmp___0;
#line 114
      tmp___1 = max_dist(i, j);
#line 114
      dist[120 * i + j].max = (unsigned int )tmp___1;
#line 115
      tmp___2 = min_dist(i, j);
#line 115
      dist[120 * i + j].min = (unsigned int )tmp___2;
#line 110
      j ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 110
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 117
  return;
}
}
#line 124 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tolower)(int __c ) ;
#line 127
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) toupper)(int __c ) ;
#line 431 "/usr/include/stdio.h"
extern int scanf(char const   * __restrict  __format  , ...) ;
#line 129 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 132
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 236
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 421 "/home/wheatley/newnew/temp/phalanx-22+d051004/phalanx.h"
int Scoring ;
#line 424
long Otim ;
#line 472
void printPV(int mpl , int lid , char *s ) ;
#line 473
void infoline(int typ , char *s ) ;
#line 475
void printboard(char *s ) ;
#line 477
void shell(void) ;
#line 478
int command(void) ;
#line 494
tmove root_search(void) ;
#line 511
unsigned int hashboard(void) ;
#line 516
void l_level(char *l___0 ) ;
#line 518
int l_iterate(void) ;
#line 520
long LastTurn ;
#line 521
int Turns ;
#line 4 "/home/wheatley/newnew/temp/phalanx-22+d051004/io.c"
long Time ;
#line 7 "/home/wheatley/newnew/temp/phalanx-22+d051004/io.c"
char Inp[256]  = {      (char )'\000',      (char )'\000'};
#line 8 "/home/wheatley/newnew/temp/phalanx-22+d051004/io.c"
char piece[7]  = {      (char )' ',      (char )'P',      (char )'N',      (char )'B', 
        (char )'R',      (char )'Q',      (char )'K'};
#line 10 "/home/wheatley/newnew/temp/phalanx-22+d051004/io.c"
char file[10]  = 
#line 10
  {      (char )'<',      (char )'a',      (char )'b',      (char )'c', 
        (char )'d',      (char )'e',      (char )'f',      (char )'g', 
        (char )'h',      (char )'>'};
#line 12 "/home/wheatley/newnew/temp/phalanx-22+d051004/io.c"
char row[12]  = 
#line 12
  {      (char )'<',      (char )'0',      (char )'1',      (char )'2', 
        (char )'3',      (char )'4',      (char )'5',      (char )'6', 
        (char )'7',      (char )'8',      (char )'9',      (char )'>'};
#line 15 "/home/wheatley/newnew/temp/phalanx-22+d051004/io.c"
tmove Pm[256]  ;
#line 16 "/home/wheatley/newnew/temp/phalanx-22+d051004/io.c"
int Pn  ;
#line 23 "/home/wheatley/newnew/temp/phalanx-22+d051004/io.c"
void initbs(void) 
{ 
  int s ;
  unsigned char tmp ;
  int wlast ;
  int blast ;

  {
  {
#line 28
  Counter = 0;
#line 29
  DrawScore = 0;
#line 31
  G[0].hashboard = hashboard();
#line 34
  G[0].xmtrl = (short)0;
#line 34
  G[0].mtrl = G[0].xmtrl;
#line 35
  s = 21;
  }
  {
#line 35
  while (1) {
    while_continue: /* CIL Label */ ;
#line 35
    if (! (s != 99)) {
#line 35
      goto while_break;
    }
#line 36
    if (((int )B[s] & 3) == Color) {
#line 36
      G[0].mtrl = (short )((int )G[0].mtrl + Values[(int )B[s] >> 4]);
    } else {
#line 37
      G[0].xmtrl = (short )((int )G[0].xmtrl + Values[(int )B[s] >> 4]);
    }
#line 35
    s ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 39
  G[0].castling = (unsigned short)0;
#line 40
  if ((int )B[25] != 97) {
#line 40
    G[0].castling = (unsigned short )((int )G[0].castling | 2);
  } else
#line 40
  if ((int )B[21] != 65) {
#line 40
    G[0].castling = (unsigned short )((int )G[0].castling | 2);
  }
#line 41
  if ((int )B[25] != 97) {
#line 41
    G[0].castling = (unsigned short )((int )G[0].castling | 1);
  } else
#line 41
  if ((int )B[28] != 65) {
#line 41
    G[0].castling = (unsigned short )((int )G[0].castling | 1);
  }
#line 42
  if ((int )B[95] != 98) {
#line 42
    G[0].castling = (unsigned short )((int )G[0].castling | 8);
  } else
#line 42
  if ((int )B[91] != 66) {
#line 42
    G[0].castling = (unsigned short )((int )G[0].castling | 8);
  }
#line 43
  if ((int )B[95] != 98) {
#line 43
    G[0].castling = (unsigned short )((int )G[0].castling | 4);
  } else
#line 43
  if ((int )B[98] != 66) {
#line 43
    G[0].castling = (unsigned short )((int )G[0].castling | 4);
  }
#line 45
  G[0].rule50 = (unsigned short)0;
#line 48
  L[L[1].next].prev = (unsigned char)1;
#line 49
  L[L[2].next].prev = (unsigned char)2;
#line 50
  tmp = (unsigned char)0;
#line 50
  L[L[2].next].next = tmp;
#line 50
  L[L[1].next].next = tmp;
#line 52
  wlast = (int )L[1].next;
#line 52
  blast = (int )L[2].next;
#line 53
  s = 21;
  {
#line 53
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 53
    if (! (s != 99)) {
#line 53
      goto while_break___0;
    }
#line 54
    if ((int )B[s] != 0) {
#line 54
      if ((int )B[s] != 3) {
#line 54
        if ((int )B[s] != 97) {
#line 54
          if ((int )B[s] != 98) {
#line 56
            if (((int )B[s] & 3) == 1) {
#line 57
              L[wlast].next = (unsigned char )s;
#line 57
              L[s].prev = (unsigned char )wlast;
#line 57
              L[s].next = (unsigned char)0;
#line 57
              wlast = s;
            } else {
#line 59
              L[blast].next = (unsigned char )s;
#line 59
              L[s].prev = (unsigned char )blast;
#line 59
              L[s].next = (unsigned char)0;
#line 59
              blast = s;
            }
          }
        }
      }
    }
#line 53
    s ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 63
  Flag.machine_color = Color ^ 3;
#line 65
  return;
}
}
#line 72 "/home/wheatley/newnew/temp/phalanx-22+d051004/io.c"
void edit(void) 
{ 
  int i ;
  int color ;
  int squ ;
  int pie ;
  char s[8] ;
  int tmp ;
  char *tmp___0 ;

  {
#line 75
  color = 1;
#line 78
  s[0] = (char )'@';
  {
#line 80
  while (1) {
    while_continue: /* CIL Label */ ;
#line 82
    i = 0;
    {
#line 82
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 82
      if (! (i != 3)) {
#line 82
        goto while_break___0;
      }
      {
#line 82
      tmp = toupper((int )s[i]);
#line 82
      s[i] = (char )tmp;
#line 82
      i ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 86
    if ((int )s[0] == 35) {
#line 86
      goto case_35;
    }
#line 89
    if ((int )s[0] == 67) {
#line 89
      goto case_67;
    }
#line 92
    if ((int )s[0] == 83) {
#line 92
      goto case_83;
    }
#line 95
    if ((int )s[0] == 46) {
#line 95
      goto case_46;
    }
#line 96
    if ((int )s[0] == 75) {
#line 96
      goto case_75;
    }
#line 96
    if ((int )s[0] == 81) {
#line 96
      goto case_75;
    }
#line 96
    if ((int )s[0] == 82) {
#line 96
      goto case_75;
    }
#line 96
    if ((int )s[0] == 66) {
#line 96
      goto case_75;
    }
#line 96
    if ((int )s[0] == 78) {
#line 96
      goto case_75;
    }
#line 96
    if ((int )s[0] == 80) {
#line 96
      goto case_75;
    }
#line 84
    goto switch_break;
    case_35: /* CIL Label */ 
#line 87
    i = 21;
    {
#line 87
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 87
      if (! (i != 99)) {
#line 87
        goto while_break___1;
      }
#line 87
      if ((int )B[i] != 3) {
#line 87
        B[i] = (tsquare )0;
      }
#line 87
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 88
    goto switch_break;
    case_67: /* CIL Label */ 
#line 90
    color ^= 3;
#line 91
    goto switch_break;
    case_83: /* CIL Label */ 
#line 93
    Color ^= 3;
#line 94
    goto switch_break;
    case_46: /* CIL Label */ 
#line 95
    goto switch_break;
    case_75: /* CIL Label */ 
    case_81: /* CIL Label */ 
    case_82: /* CIL Label */ 
    case_66: /* CIL Label */ 
    case_78: /* CIL Label */ 
    case_80: /* CIL Label */ 
#line 97
    squ = (((int )s[1] - 65) + 10 * ((int )s[2] - 49)) + 21;
#line 98
    if (squ < 21) {
#line 98
      squ = 0;
    } else
#line 98
    if (squ > 98) {
#line 98
      squ = 0;
    }
#line 99
    pie = 0;
#line 100
    i = 1;
    {
#line 100
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 100
      if (! (i != 7)) {
#line 100
        goto while_break___2;
      }
#line 100
      if ((int )s[0] == (int )piece[i]) {
#line 101
        pie = i * 16 + color;
#line 101
        goto while_break___2;
      }
#line 100
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 102
    B[squ] = (tsquare )pie;
#line 103
    if ((int )s[0] == 75) {
#line 103
      L[color].next = (unsigned char )squ;
    }
#line 104
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
    {
#line 107
    printboard((char *)((void *)0));
#line 107
    printf((char const   */* __restrict  */)"\n");
#line 108
    printf((char const   */* __restrict  */)"       <piece><location>\n");
#line 109
    printf((char const   */* __restrict  */)"       .            exit\n");
#line 110
    printf((char const   */* __restrict  */)"       #           clear\n");
#line 111
    printf((char const   */* __restrict  */)"       c          change          ");
    }
#line 112
    if (color == 1) {
      {
#line 112
      printf((char const   */* __restrict  */)"put white pieces\n");
      }
    } else {
      {
#line 113
      printf((char const   */* __restrict  */)"put black pieces\n");
      }
    }
    {
#line 114
    printf((char const   */* __restrict  */)"       s    side to move\n");
#line 115
    printf((char const   */* __restrict  */)"edit > ");
#line 117
    tmp___0 = fgets((char */* __restrict  */)(s), 7, (FILE */* __restrict  */)stdin);
    }
#line 117
    if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
      {
#line 118
      strcpy((char */* __restrict  */)(Inp), (char const   */* __restrict  */)"quit\n");
      }
#line 118
      return;
    }
#line 120
    if ((int )s[0] == 46) {
#line 120
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 123
  initbs();
#line 124
  Inp[0] = (char )'\000';
  }
#line 124
  return;
}
}
#line 135 "/home/wheatley/newnew/temp/phalanx-22+d051004/io.c"
void printm(tmove m___1 , char *s ) 
{ 
  char ss[64] ;
  int tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;

  {
  {
#line 142
  if ((int )m___1.special == 2) {
#line 142
    goto case_2;
  }
#line 143
  if ((int )m___1.special == 1) {
#line 143
    goto case_1;
  }
#line 140
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 142
  sprintf((char */* __restrict  */)(ss), (char const   */* __restrict  */)"O-O-O  ");
  }
#line 142
  goto endprint;
  case_1: /* CIL Label */ 
  {
#line 143
  sprintf((char */* __restrict  */)(ss), (char const   */* __restrict  */)"O-O  ");
  }
#line 143
  goto endprint;
  switch_break: /* CIL Label */ ;
  }
#line 146
  if (m___1.in2) {
#line 146
    tmp = 'x';
  } else
#line 146
  if (m___1.special) {
#line 146
    tmp = 'x';
  } else {
#line 146
    tmp = '-';
  }
  {
#line 146
  sprintf((char */* __restrict  */)(ss), (char const   */* __restrict  */)"%c%c%c%c%c%c",
          (int )piece[(int )m___1.in1 >> 4], (int )file[(int )m___1.from % 10], (int )row[(int )m___1.from / 10],
          tmp, (int )file[(int )m___1.to % 10], (int )row[(int )m___1.to / 10]);
  }
#line 151
  if ((int )m___1.in2a != (int )m___1.in1) {
    {
#line 151
    tmp___0 = strlen((char const   *)(ss));
#line 151
    sprintf((char */* __restrict  */)(ss + tmp___0), (char const   */* __restrict  */)"%c",
            (int )piece[(int )m___1.in2a >> 4]);
    }
  }
  {
#line 157
  tmp___1 = strlen((char const   *)(ss));
#line 157
  sprintf((char */* __restrict  */)(ss + tmp___1), (char const   */* __restrict  */)"  ");
  }
  endprint: ;
#line 161
  if ((unsigned long )s == (unsigned long )((void *)0)) {
    {
#line 161
    puts((char const   *)(ss));
    }
  } else {
    {
#line 161
    strcpy((char */* __restrict  */)s, (char const   */* __restrict  */)(ss));
    }
  }
#line 163
  return;
}
}
#line 256 "/home/wheatley/newnew/temp/phalanx-22+d051004/io.c"
void gnuprintm(tmove m___1 ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
#line 261
  if ((int )m___1.special == 2) {
#line 261
    goto case_2;
  }
#line 262
  if ((int )m___1.special == 1) {
#line 262
    goto case_1;
  }
#line 259
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 261
  printf((char const   */* __restrict  */)"o-o-o");
  }
#line 261
  return;
  case_1: /* CIL Label */ 
  {
#line 262
  printf((char const   */* __restrict  */)"o-o");
  }
#line 262
  return;
  switch_break: /* CIL Label */ ;
  }
#line 265
  if ((int )m___1.in2a == (int )m___1.in1) {
#line 265
    tmp___0 = ' ';
  } else {
    {
#line 265
    tmp = tolower((int )piece[(int )m___1.in2a >> 4]);
#line 265
    tmp___0 = tmp;
    }
  }
  {
#line 265
  printf((char const   */* __restrict  */)"%c%c%c%c%c", (int )file[(int )m___1.from % 10],
         (int )row[(int )m___1.from / 10], (int )file[(int )m___1.to % 10], (int )row[(int )m___1.to / 10],
         tmp___0);
  }
#line 270
  return;
}
}
#line 316 "/home/wheatley/newnew/temp/phalanx-22+d051004/io.c"
static char ok[20]  = 
#line 316
  {      (char )'P',      (char )'N',      (char )'B',      (char )'R', 
        (char )'Q',      (char )'K',      (char )'a',      (char )'b', 
        (char )'c',      (char )'d',      (char )'e',      (char )'f', 
        (char )'g',      (char )'h',      (char )'p',      (char )'n', 
        (char )'r',      (char )'q',      (char )'k',      (char )'\000'};
#line 317 "/home/wheatley/newnew/temp/phalanx-22+d051004/io.c"
static char up[6]  = {      (char )'p',      (char )'n',      (char )'r',      (char )'q', 
        (char )'k',      (char )'\000'};
#line 278 "/home/wheatley/newnew/temp/phalanx-22+d051004/io.c"
tmove *sandex(char *inp , tmove *m___1 , int n___1 ) 
{ 
  char bufik[32] ;
  char *s ;
  char *ss ;
  char *sto ;
  int move ;
  int to ;
  int i ;
  unsigned int p ;
  int frow ;
  int ffile ;
  int in2a ;
  int color ;
  int sc ;
  int lc___0 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int mn ;
  int tmp___10 ;

  {
  {
#line 281
  s = bufik;
#line 285
  p = 0U;
#line 286
  frow = 0;
#line 286
  ffile = 0;
#line 287
  in2a = 0;
#line 288
  color = (int )m___1->in1 & 3;
#line 289
  sc = -1;
#line 289
  lc___0 = -1;
#line 291
  strncpy((char */* __restrict  */)(bufik), (char const   */* __restrict  */)inp,
          (size_t )30);
#line 293
  i = 0;
  }
  {
#line 293
  while (1) {
    while_continue: /* CIL Label */ ;
#line 293
    if (! (i != n___1)) {
#line 293
      goto while_break;
    }
#line 293
    if ((int )(m___1 + i)->special == 1) {
#line 293
      sc = i;
    } else
#line 294
    if ((int )(m___1 + i)->special == 2) {
#line 294
      lc___0 = i;
    }
#line 293
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 297
  if (lc___0 != -1) {
    {
#line 298
    tmp = strncmp((char const   *)s, "o-o-o", (size_t )5);
    }
#line 298
    if (tmp == 0) {
#line 303
      return (m___1 + lc___0);
    } else {
      {
#line 298
      tmp___0 = strncmp((char const   *)s, "O-O-O", (size_t )5);
      }
#line 298
      if (tmp___0 == 0) {
#line 303
        return (m___1 + lc___0);
      } else {
        {
#line 298
        tmp___1 = strncmp((char const   *)s, "0-0-0", (size_t )5);
        }
#line 298
        if (tmp___1 == 0) {
#line 303
          return (m___1 + lc___0);
        } else {
          {
#line 298
          tmp___2 = strncmp((char const   *)s, "e1c1", (size_t )4);
          }
#line 298
          if (tmp___2 == 0) {
#line 298
            if (color == 1) {
#line 303
              return (m___1 + lc___0);
            } else {
#line 298
              goto _L;
            }
          } else {
            _L: /* CIL Label */ 
            {
#line 298
            tmp___3 = strncmp((char const   *)s, "e8c8", (size_t )4);
            }
#line 298
            if (tmp___3 == 0) {
#line 298
              if (color == 2) {
#line 303
                return (m___1 + lc___0);
              }
            }
          }
        }
      }
    }
  }
#line 305
  if (sc != -1) {
#line 305
    if ((int )*(s + 3) != 45) {
      {
#line 306
      tmp___4 = strncmp((char const   *)s, "o-o", (size_t )3);
      }
#line 306
      if (tmp___4 == 0) {
#line 311
        return (m___1 + sc);
      } else {
        {
#line 306
        tmp___5 = strncmp((char const   *)s, "O-O", (size_t )3);
        }
#line 306
        if (tmp___5 == 0) {
#line 311
          return (m___1 + sc);
        } else {
          {
#line 306
          tmp___6 = strncmp((char const   *)s, "0-0", (size_t )3);
          }
#line 306
          if (tmp___6 == 0) {
#line 311
            return (m___1 + sc);
          } else {
            {
#line 306
            tmp___7 = strncmp((char const   *)s, "e1g1", (size_t )4);
            }
#line 306
            if (tmp___7 == 0) {
#line 306
              if (color == 1) {
#line 311
                return (m___1 + sc);
              } else {
#line 306
                goto _L___0;
              }
            } else {
              _L___0: /* CIL Label */ 
              {
#line 306
              tmp___8 = strncmp((char const   *)s, "e8g8", (size_t )4);
              }
#line 306
              if (tmp___8 == 0) {
#line 306
                if (color == 2) {
#line 311
                  return (m___1 + sc);
                }
              }
            }
          }
        }
      }
    }
  }
#line 318
  i = 0;
  {
#line 318
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 318
    if (! ((int )ok[i] != (int )*s)) {
#line 318
      goto while_break___0;
    }
#line 318
    if ((int )ok[i] == 0) {
#line 318
      return ((tmove *)((void *)0));
    }
#line 318
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 319
  i = 0;
  {
#line 319
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 319
    if (! ((int )up[i] != 0)) {
#line 319
      goto while_break___1;
    }
#line 320
    if ((int )up[i] == (int )*s) {
      {
#line 320
      tmp___9 = toupper((int )*s);
#line 320
      *s = (char )tmp___9;
      }
#line 320
      goto while_break___1;
    }
#line 319
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 327
  sto = (char *)((void *)0);
#line 328
  ss = s + 1;
  {
#line 328
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 328
    if (! ((int )*ss != 0)) {
#line 328
      goto while_break___2;
    }
#line 328
    if ((int )*ss >= 49) {
#line 328
      if ((int )*ss <= 56) {
#line 328
        sto = ss - 1;
      }
    }
#line 328
    ss ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 329
  if ((unsigned long )sto == (unsigned long )((void *)0)) {
#line 331
    if ((int )*(s + 2) == 0) {
#line 331
      goto _L___1;
    } else
#line 331
    if ((int )*(s + 2) == 10) {
      _L___1: /* CIL Label */ 
#line 331
      if ((int )*(s + 1) >= 97) {
#line 331
        if ((int )*(s + 1) <= 104) {
#line 331
          if ((int )*(s + 0) >= 97) {
#line 331
            if ((int )*(s + 0) <= 104) {
#line 335
              mn = -1;
#line 337
              i = 0;
              {
#line 337
              while (1) {
                while_continue___3: /* CIL Label */ ;
#line 337
                if (! (i != n___1)) {
#line 337
                  goto while_break___3;
                }
#line 338
                if (((int )(m___1 + i)->in1 & 252) == 16) {
#line 339
                  if ((int )(m___1 + i)->from % 10 == ((int )*(s + 0) + 1) - 97) {
#line 340
                    if ((int )(m___1 + i)->to % 10 == ((int )*(s + 1) + 1) - 97) {
#line 342
                      if (mn == -1) {
#line 343
                        mn = i;
                      } else {
#line 345
                        mn = -2;
                      }
                    }
                  }
                }
#line 337
                i ++;
              }
              while_break___3: /* CIL Label */ ;
              }
#line 347
              if (mn >= 0) {
#line 347
                return (m___1 + mn);
              }
            }
          }
        }
      }
    }
#line 349
    return ((tmove *)((void *)0));
  }
#line 352
  i = 1;
  {
#line 352
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 352
    if (! (i != 9)) {
#line 352
      goto while_break___4;
    }
#line 352
    if ((int )file[i] == (int )*sto) {
#line 352
      goto while_break___4;
    }
#line 352
    i ++;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 353
  if (i == 9) {
#line 353
    return ((tmove *)((void *)0));
  }
#line 354
  to = i;
#line 355
  i = 2;
  {
#line 355
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 355
    if (! (i != 10)) {
#line 355
      goto while_break___5;
    }
#line 355
    if ((int )row[i] == (int )*(sto + 1)) {
#line 355
      goto while_break___5;
    }
#line 355
    i ++;
  }
  while_break___5: /* CIL Label */ ;
  }
#line 356
  if (i == 10) {
#line 356
    return ((tmove *)((void *)0));
  }
#line 357
  to += i * 10;
#line 361
  ss = sto - 1;
#line 362
  if ((unsigned long )ss >= (unsigned long )s) {
#line 363
    ss = sto - 1;
    {
#line 363
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 363
      if (! ((unsigned long )ss != (unsigned long )s)) {
#line 363
        goto while_break___6;
      }
#line 364
      if ((int )*ss >= 49) {
#line 364
        if ((int )*ss <= 56) {
#line 364
          if ((int )*(ss - 1) >= 97) {
#line 364
            if ((int )*(ss - 1) <= 104) {
#line 366
              i = 2;
              {
#line 366
              while (1) {
                while_continue___7: /* CIL Label */ ;
#line 366
                if (! (i != 10)) {
#line 366
                  goto while_break___7;
                }
#line 366
                if ((int )row[i] == (int )*ss) {
#line 366
                  goto while_break___7;
                }
#line 366
                i ++;
              }
              while_break___7: /* CIL Label */ ;
              }
#line 367
              frow = i;
#line 368
              ss --;
#line 368
              i = 1;
              {
#line 368
              while (1) {
                while_continue___8: /* CIL Label */ ;
#line 368
                if (! (i != 9)) {
#line 368
                  goto while_break___8;
                }
#line 368
                if ((int )file[i] == (int )*ss) {
#line 368
                  goto while_break___8;
                }
#line 368
                i ++;
              }
              while_break___8: /* CIL Label */ ;
              }
#line 369
              ffile = i;
#line 370
              i = 0;
              {
#line 370
              while (1) {
                while_continue___9: /* CIL Label */ ;
#line 370
                if (! (i != n___1)) {
#line 370
                  goto while_break___9;
                }
#line 370
                if ((int )(m___1 + i)->from == frow * 10 + ffile) {
#line 371
                  p = (unsigned int )(m___1 + i)->in1;
#line 371
                  goto while_break___9;
                }
#line 370
                i ++;
              }
              while_break___9: /* CIL Label */ ;
              }
#line 372
              goto step4;
            }
          }
        }
      }
#line 363
      ss --;
    }
    while_break___6: /* CIL Label */ ;
    }
  }
#line 376
  p = 6U;
  {
#line 376
  while (1) {
    while_continue___10: /* CIL Label */ ;
#line 376
    if (! (p != 1U)) {
#line 376
      goto while_break___10;
    }
#line 376
    if ((int )piece[p] == (int )*s) {
#line 376
      s ++;
#line 376
      goto while_break___10;
    }
#line 376
    p --;
  }
  while_break___10: /* CIL Label */ ;
  }
#line 377
  p = (p << 4) + (unsigned int )color;
#line 378
  if ((int )*s != 120) {
#line 378
    if ((unsigned long )s < (unsigned long )sto) {
#line 380
      if ((int )*s >= 97) {
#line 380
        if ((int )*s <= 104) {
#line 380
          ffile = ((int )*s - 97) + 1;
        } else {
#line 380
          goto _L___2;
        }
      } else
      _L___2: /* CIL Label */ 
#line 382
      if ((int )*s >= 49) {
#line 382
        if ((int )*s <= 56) {
#line 382
          frow = ((int )*s - 49) + 2;
        }
      }
    }
  }
  step4: 
#line 389
  in2a = (int )p;
#line 390
  sto += 2;
#line 390
  if ((int )*sto == 61) {
#line 390
    sto ++;
  }
  {
#line 391
  tmp___10 = toupper((int )*sto);
#line 391
  *sto = (char )tmp___10;
#line 392
  i = 2;
  }
  {
#line 392
  while (1) {
    while_continue___11: /* CIL Label */ ;
#line 392
    if (! (i != 7)) {
#line 392
      goto while_break___11;
    }
#line 392
    if ((int )piece[i] == (int )*sto) {
#line 392
      in2a = (i << 4) + color;
    }
#line 392
    i ++;
  }
  while_break___11: /* CIL Label */ ;
  }
#line 395
  move = -1;
#line 396
  i = 0;
  {
#line 396
  while (1) {
    while_continue___12: /* CIL Label */ ;
#line 396
    if (! (i != n___1)) {
#line 396
      goto while_break___12;
    }
#line 396
    if ((int )(m___1 + i)->to == to) {
#line 396
      if ((unsigned int )(m___1 + i)->in1 == p) {
#line 396
        if ((int )(m___1 + i)->in2a == in2a) {
#line 397
          if (ffile == 0) {
#line 397
            goto _L___4;
          } else
#line 397
          if (ffile == (int )(m___1 + i)->from % 10) {
            _L___4: /* CIL Label */ 
#line 398
            if (frow == 0) {
#line 398
              goto _L___3;
            } else
#line 398
            if (frow == (int )(m___1 + i)->from / 10) {
              _L___3: /* CIL Label */ 
#line 399
              if (move == -1) {
#line 399
                move = i;
              } else {
#line 399
                return ((tmove *)((void *)0));
              }
            }
          }
        }
      }
    }
#line 396
    i ++;
  }
  while_break___12: /* CIL Label */ ;
  }
#line 400
  if (move == -1) {
#line 400
    return ((tmove *)((void *)0));
  }
#line 402
  return (m___1 + move);
}
}
#line 412 "/home/wheatley/newnew/temp/phalanx-22+d051004/io.c"
int checkmove(char *s , tmove *m___1 ) 
{ 
  int i ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  unsigned short const   **tmp___12 ;
  unsigned short const   **tmp___13 ;
  int tmp___14 ;

  {
#line 416
  if ((int )m___1->special == 2) {
    {
#line 418
    tmp = strncmp((char const   *)s, "o-o-o", (size_t )5);
    }
#line 418
    if (tmp == 0) {
#line 423
      return (1);
    } else {
      {
#line 418
      tmp___0 = strncmp((char const   *)s, "O-O-O", (size_t )5);
      }
#line 418
      if (tmp___0 == 0) {
#line 423
        return (1);
      } else {
        {
#line 418
        tmp___1 = strncmp((char const   *)s, "0-0-0", (size_t )5);
        }
#line 418
        if (tmp___1 == 0) {
#line 423
          return (1);
        } else
#line 418
        if (Color == 1) {
          {
#line 418
          tmp___2 = strncmp((char const   *)s, "e1c1", (size_t )4);
          }
#line 418
          if (tmp___2 == 0) {
#line 423
            return (1);
          } else {
#line 418
            goto _L;
          }
        } else
        _L: /* CIL Label */ 
#line 418
        if (Color == 2) {
          {
#line 418
          tmp___3 = strncmp((char const   *)s, "e8c8", (size_t )4);
          }
#line 418
          if (tmp___3 == 0) {
#line 423
            return (1);
          } else {
#line 424
            return (0);
          }
        } else {
#line 424
          return (0);
        }
      }
    }
  }
#line 427
  if ((int )m___1->special == 1) {
    {
#line 429
    tmp___4 = strncmp((char const   *)s, "o-o", (size_t )3);
    }
#line 429
    if (tmp___4 == 0) {
      {
#line 429
      tmp___5 = strncmp((char const   *)s, "o-o-o", (size_t )5);
      }
#line 429
      if (tmp___5 != 0) {
#line 434
        return (1);
      } else {
#line 429
        goto _L___3;
      }
    } else {
      _L___3: /* CIL Label */ 
      {
#line 429
      tmp___6 = strncmp((char const   *)s, "O-O", (size_t )3);
      }
#line 429
      if (tmp___6 == 0) {
        {
#line 429
        tmp___7 = strncmp((char const   *)s, "O-O-O", (size_t )5);
        }
#line 429
        if (tmp___7 != 0) {
#line 434
          return (1);
        } else {
#line 429
          goto _L___2;
        }
      } else {
        _L___2: /* CIL Label */ 
        {
#line 429
        tmp___8 = strncmp((char const   *)s, "0-0", (size_t )3);
        }
#line 429
        if (tmp___8 == 0) {
          {
#line 429
          tmp___9 = strncmp((char const   *)s, "0-0-0", (size_t )5);
          }
#line 429
          if (tmp___9 != 0) {
#line 434
            return (1);
          } else {
#line 429
            goto _L___1;
          }
        } else
        _L___1: /* CIL Label */ 
#line 429
        if (Color == 1) {
          {
#line 429
          tmp___10 = strncmp((char const   *)s, "e1g1", (size_t )4);
          }
#line 429
          if (tmp___10 == 0) {
#line 434
            return (1);
          } else {
#line 429
            goto _L___0;
          }
        } else
        _L___0: /* CIL Label */ 
#line 429
        if (Color == 2) {
          {
#line 429
          tmp___11 = strncmp((char const   *)s, "e8g8", (size_t )4);
          }
#line 429
          if (tmp___11 == 0) {
#line 434
            return (1);
          } else {
#line 435
            return (0);
          }
        } else {
#line 435
          return (0);
        }
      }
    }
  }
#line 438
  i = 0;
  {
#line 438
  while (1) {
    while_continue: /* CIL Label */ ;
#line 438
    if ((int )*(s + i) != 0) {
      {
#line 438
      tmp___12 = __ctype_b_loc();
      }
#line 438
      if ((int const   )*(*tmp___12 + (int )*(s + i)) & 512) {
#line 438
        goto while_break;
      }
    } else {
#line 438
      goto while_break;
    }
#line 438
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 439
  if ((int )*(s + i) == 0) {
#line 439
    return (0);
  } else
#line 439
  if ((int )*(s + i) != (int )file[(int )m___1->from % 10]) {
#line 439
    return (0);
  }
#line 441
  i ++;
#line 442
  if ((int )*(s + i) == 0) {
#line 442
    return (0);
  } else
#line 442
  if ((int )*(s + i) != (int )row[(int )m___1->from / 10]) {
#line 442
    return (0);
  }
  {
#line 444
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 444
    if ((int )*(s + i) != 0) {
#line 444
      if (! ((int )*(s + i) == 120)) {
        {
#line 444
        tmp___13 = __ctype_b_loc();
        }
#line 444
        if ((int const   )*(*tmp___13 + (int )*(s + i)) & 512) {
#line 444
          goto while_break___0;
        }
      }
    } else {
#line 444
      goto while_break___0;
    }
#line 444
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 445
  if ((int )*(s + i) == 0) {
#line 445
    return (0);
  } else
#line 445
  if ((int )*(s + i) != (int )file[(int )m___1->to % 10]) {
#line 445
    return (0);
  }
#line 447
  i ++;
#line 448
  if ((int )*(s + i) == 0) {
#line 448
    return (0);
  } else
#line 448
  if ((int )*(s + i) != (int )row[(int )m___1->to / 10]) {
#line 448
    return (0);
  }
#line 450
  i ++;
#line 451
  if ((int )m___1->in2a != (int )m___1->in1) {
#line 453
    if ((int )*(s + i) == 61) {
#line 453
      i ++;
    } else
#line 453
    if ((int )*(s + i) == 58) {
#line 453
      i ++;
    }
    {
#line 454
    tmp___14 = toupper((int )*(s + i));
    }
#line 454
    if (tmp___14 != (int )piece[(int )m___1->in2a >> 4]) {
#line 454
      return (0);
    }
  }
#line 457
  return (1);
}
}
#line 462 "/home/wheatley/newnew/temp/phalanx-22+d051004/io.c"
void printPV(int mpl , int lid , char *s ) 
{ 
  char ss[1024] ;
  unsigned int tmp ;
  int j ;
  int i ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;

  {
#line 465
  ss[0] = (char )'\000';
#line 465
  tmp = 1U;
  {
#line 465
  while (1) {
    while_continue: /* CIL Label */ ;
#line 465
    if (tmp >= 1024U) {
#line 465
      goto while_break;
    }
#line 465
    ss[tmp] = (char)0;
#line 465
    tmp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 486
  j = 0;
  {
#line 486
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 486
    if (! PV[0][j].from) {
#line 486
      goto while_break___0;
    }
#line 488
    if (j % mpl == 0) {
#line 488
      if (j != 0) {
#line 488
        if (Flag.xboard != 2) {
          {
#line 491
          tmp___0 = strlen((char const   *)(ss));
#line 491
          sprintf((char */* __restrict  */)(ss + tmp___0), (char const   */* __restrict  */)"\n");
#line 492
          i = 0;
          }
          {
#line 492
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 492
            if (! (i != lid)) {
#line 492
              goto while_break___1;
            }
            {
#line 492
            tmp___1 = strlen((char const   *)(ss));
#line 492
            sprintf((char */* __restrict  */)(ss + tmp___1), (char const   */* __restrict  */)" ");
#line 492
            i ++;
            }
          }
          while_break___1: /* CIL Label */ ;
          }
        }
      }
    }
    {
#line 494
    tmp___2 = strlen((char const   *)(ss));
#line 494
    printm(PV[0][j], ss + tmp___2);
#line 486
    j ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 497
  if (j < 3) {
    {
#line 497
    tmp___3 = strlen((char const   *)(ss));
#line 497
    sprintf((char */* __restrict  */)(ss + tmp___3), (char const   */* __restrict  */)"           ");
    }
  }
  {
#line 500
  tmp___4 = strlen((char const   *)(ss));
#line 500
  sprintf((char */* __restrict  */)(ss + tmp___4), (char const   */* __restrict  */)"\n");
  }
#line 502
  if ((unsigned long )s == (unsigned long )((void *)0)) {
    {
#line 502
    puts((char const   *)(ss));
    }
  } else {
    {
#line 502
    strcpy((char */* __restrict  */)s, (char const   */* __restrict  */)(ss));
    }
  }
#line 503
  return;
}
}
#line 507 "/home/wheatley/newnew/temp/phalanx-22+d051004/io.c"
void infoline(int typ , char *s ) 
{ 
  char ss[1024] ;
  long t ;
  long tmp ;
  int x ;
  long tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  long tt ;
  long tmp___6 ;
  long t___1 ;
  size_t tmp___7 ;
  size_t tmp___8 ;
  size_t tmp___9 ;
  size_t tmp___10 ;
  size_t tmp___11 ;
  size_t tmp___12 ;
  size_t tmp___13 ;
  size_t tmp___14 ;
  size_t tmp___15 ;
  size_t tmp___16 ;
  size_t tmp___17 ;
  size_t tmp___18 ;
  size_t tmp___19 ;
  size_t tmp___20 ;
  size_t tmp___21 ;
  size_t tmp___22 ;
  size_t tmp___23 ;
  size_t tmp___24 ;

  {
  {
#line 520
  tmp = ptime();
#line 520
  t = tmp;
  }
#line 522
  if (typ != 0) {
#line 522
    if (! Flag.analyze) {
#line 522
      if (Abort) {
#line 522
        return;
      } else
#line 522
      if (t - T1 < (long )Flag.noise) {
#line 522
        return;
      }
    }
  }
#line 524
  if (Flag.log) {
#line 524
    if ((unsigned long )s == (unsigned long )((void *)0)) {
      {
#line 526
      x = Flag.xboard;
#line 527
      Flag.xboard = 0;
#line 528
      infoline(typ, ss);
#line 529
      Flag.xboard = x;
#line 530
      fputs((char const   */* __restrict  */)(ss), (FILE */* __restrict  */)Flag.log);
      }
    }
  }
#line 533
  if (Flag.xboard == 2) {
    {
#line 535
    if (typ == 0) {
#line 535
      goto case_0;
    }
#line 552
    if (typ == 3) {
#line 552
      goto case_3;
    }
#line 534
    goto switch_break;
    case_0: /* CIL Label */ 
#line 536
    if (Flag.ponder < 2) {
#line 536
      if (Flag.xboard > 1) {
#line 536
        if (typ == 0) {
#line 538
          if (t - T1 > 1L) {
#line 538
            tmp___0 = t - T1;
          } else {
#line 538
            tmp___0 = 1L;
          }
          {
#line 538
          tmp___1 = abs((int )PV[0][0].value);
#line 538
          tmp___2 = abs((int )PV[0][0].value / 100);
          }
#line 538
          if ((int )PV[0][0].value >= 0) {
#line 538
            tmp___3 = '+';
          } else {
#line 538
            tmp___3 = '-';
          }
          {
#line 538
          printf((char const   */* __restrict  */)"tellics whisper depth=%i; eval=%c%i.%02i; nodes=%lli; nps=%i\n",
                 A_d, tmp___3, tmp___2, tmp___1 % 100, Nodes, (int )((float )Nodes / ((float )tmp___0 / (float )100)));
          }
        }
      }
    }
#line 551
    return;
    case_3: /* CIL Label */ 
#line 552
    typ = 1;
#line 552
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
#line 555
  if (typ >= 1) {
#line 555
    if (typ <= 5) {
      {
#line 557
      sprintf((char */* __restrict  */)(ss), (char const   */* __restrict  */)"%3i",
              A_d);
      }
#line 558
      if (typ == 1) {
        {
#line 559
        tmp___4 = strlen((char const   *)(ss));
#line 559
        sprintf((char */* __restrict  */)(ss + tmp___4), (char const   */* __restrict  */)"%7i",
                (int )PV[0][0].value);
        }
      } else
#line 558
      if (typ == 2) {
        {
#line 559
        tmp___4 = strlen((char const   *)(ss));
#line 559
        sprintf((char */* __restrict  */)(ss + tmp___4), (char const   */* __restrict  */)"%7i",
                (int )PV[0][0].value);
        }
      } else
#line 558
      if (typ == 4) {
        {
#line 559
        tmp___4 = strlen((char const   *)(ss));
#line 559
        sprintf((char */* __restrict  */)(ss + tmp___4), (char const   */* __restrict  */)"%7i",
                (int )PV[0][0].value);
        }
      } else
#line 558
      if (typ == 5) {
        {
#line 559
        tmp___4 = strlen((char const   *)(ss));
#line 559
        sprintf((char */* __restrict  */)(ss + tmp___4), (char const   */* __restrict  */)"%7i",
                (int )PV[0][0].value);
        }
      } else
#line 560
      if (typ == 3) {
        {
#line 560
        tmp___5 = strlen((char const   *)(ss));
#line 560
        sprintf((char */* __restrict  */)(ss + tmp___5), (char const   */* __restrict  */)" -> ");
        }
      }
#line 562
      if (typ == 3) {
        {
#line 564
        tmp___6 = ptime();
#line 564
        tt = tmp___6 - T1;
#line 565
        t___1 = tt / 100L;
#line 566
        tmp___7 = strlen((char const   *)(ss));
#line 566
        sprintf((char */* __restrict  */)(ss + tmp___7), (char const   */* __restrict  */)"%3i:%02i.%02li",
                (int )t___1 / 60, (int )t___1 % 60, (tt * 100L) / 100L - t___1 * 100L);
        }
      } else {
        {
#line 571
        tmp___8 = strlen((char const   *)(ss));
#line 571
        sprintf((char */* __restrict  */)(ss + tmp___8), (char const   */* __restrict  */)" %5li",
                t - T1);
        }
      }
      {
#line 573
      tmp___9 = strlen((char const   *)(ss));
#line 573
      sprintf((char */* __restrict  */)(ss + tmp___9), (char const   */* __restrict  */)" %8lli  ",
              Nodes);
      }
    } else {
#line 555
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    {
#line 577
    sprintf((char */* __restrict  */)(ss), (char const   */* __restrict  */)"Depth=%i, Value=%i, Time=%i.%02i, Last turn=%i.%02i, Nodes=%i",
            A_d, (int )PV[0][0].value, (int )(t - T1) / 100, (int )(t - T1) % 100,
            (int )(LastTurn - T1) / 100, (int )(LastTurn - T1) % 100, (int )Nodes);
    }
#line 586
    if (t - T1 != 0L) {
      {
#line 587
      tmp___10 = strlen((char const   *)(ss));
#line 587
      sprintf((char */* __restrict  */)(ss + tmp___10), (char const   */* __restrict  */)", N/s=%i\n",
              (int )((float )Nodes / ((float )(t - T1) / (float )100)));
      }
    } else {
      {
#line 591
      tmp___11 = strlen((char const   *)(ss));
#line 591
      sprintf((char */* __restrict  */)(ss + tmp___11), (char const   */* __restrict  */)"\n");
      }
    }
  }
  {
#line 596
  if (typ == 0) {
#line 596
    goto case_0___0;
  }
#line 602
  if (typ == 1) {
#line 602
    goto case_1;
  }
#line 604
  if (typ == 2) {
#line 604
    goto case_2;
  }
#line 608
  if (typ == 3) {
#line 608
    goto case_3___0;
  }
#line 612
  if (typ == 4) {
#line 612
    goto case_4;
  }
#line 615
  if (typ == 5) {
#line 615
    goto case_5;
  }
#line 594
  goto switch_break___0;
  case_0___0: /* CIL Label */ 
  {
#line 597
  tmp___12 = strlen((char const   *)(ss));
#line 597
  sprintf((char */* __restrict  */)(ss + tmp___12), (char const   */* __restrict  */)"PV = ");
#line 597
  tmp___13 = strlen((char const   *)(ss));
#line 597
  printPV(8, 5, ss + tmp___13);
  }
#line 598
  if ((int )PV[0][0].value > 29900) {
    {
#line 599
    tmp___14 = strlen((char const   *)(ss));
#line 599
    sprintf((char */* __restrict  */)(ss + tmp___14), (char const   */* __restrict  */)"     Mate in %i\n",
            ((30000 - (int )PV[0][0].value) + 1) / 2);
    }
  }
#line 601
  goto switch_break___0;
  case_1: /* CIL Label */ 
  {
#line 602
  tmp___15 = strlen((char const   *)(ss));
#line 602
  printPV(6, 27, ss + tmp___15);
  }
#line 603
  goto switch_break___0;
  case_2: /* CIL Label */ 
  {
#line 605
  tmp___16 = strlen((char const   *)(ss));
#line 605
  printm(PV[0][0], ss + tmp___16);
#line 606
  tmp___17 = strlen((char const   *)(ss));
#line 606
  sprintf((char */* __restrict  */)(ss + tmp___17), (char const   */* __restrict  */)"!       \n");
  }
#line 607
  goto switch_break___0;
  case_3___0: /* CIL Label */ 
  {
#line 608
  tmp___18 = strlen((char const   *)(ss));
#line 608
  sprintf((char */* __restrict  */)(ss + tmp___18), (char const   */* __restrict  */)"%2i turn",
          Turns);
  }
#line 609
  if (Turns == 1) {
    {
#line 609
    tmp___19 = strlen((char const   *)(ss));
#line 609
    sprintf((char */* __restrict  */)(ss + tmp___19), (char const   */* __restrict  */)"                          \n");
    }
  } else {
    {
#line 610
    tmp___20 = strlen((char const   *)(ss));
#line 610
    sprintf((char */* __restrict  */)(ss + tmp___20), (char const   */* __restrict  */)"s                         \n");
    }
  }
#line 611
  goto switch_break___0;
  case_4: /* CIL Label */ 
  {
#line 612
  tmp___21 = strlen((char const   *)(ss));
#line 612
  printm(PV[0][0], ss + tmp___21);
#line 613
  tmp___22 = strlen((char const   *)(ss));
#line 613
  sprintf((char */* __restrict  */)(ss + tmp___22), (char const   */* __restrict  */)"??      \n");
  }
#line 614
  goto switch_break___0;
  case_5: /* CIL Label */ 
  {
#line 615
  tmp___23 = strlen((char const   *)(ss));
#line 615
  printm(PV[0][0], ss + tmp___23);
#line 616
  tmp___24 = strlen((char const   *)(ss));
#line 616
  sprintf((char */* __restrict  */)(ss + tmp___24), (char const   */* __restrict  */)"!!      \n");
  }
  switch_break___0: /* CIL Label */ ;
  }
#line 619
  if ((unsigned long )s != (unsigned long )((void *)0)) {
    {
#line 619
    strcpy((char */* __restrict  */)s, (char const   */* __restrict  */)(ss));
    }
  } else {
    {
#line 622
    puts((char const   *)(ss));
    }
  }
#line 625
  return;
}
}
#line 629 "/home/wheatley/newnew/temp/phalanx-22+d051004/io.c"
void verboseline(tmove *m___1 , int i , int n___1 ) 
{ 
  char s[256] ;
  int j ;
  long t ;
  long tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;

  {
  {
#line 634
  tmp = ptime();
#line 634
  t = (tmp - T1) / 100L;
#line 636
  sprintf((char */* __restrict  */)(s), (char const   */* __restrict  */)"(%2i)",
          A_d);
#line 637
  tmp___0 = strlen((char const   *)(s));
#line 637
  sprintf((char */* __restrict  */)(s + tmp___0), (char const   */* __restrict  */)"   ");
#line 638
  tmp___1 = strlen((char const   *)(s));
#line 638
  sprintf((char */* __restrict  */)(s + tmp___1), (char const   */* __restrict  */)"%3li:%02li   ",
          t / 60L, t % 60L);
#line 639
  tmp___2 = strlen((char const   *)(s));
#line 639
  sprintf((char */* __restrict  */)(s + tmp___2), (char const   */* __restrict  */)"%9lli  ",
          Nodes);
#line 640
  tmp___3 = strlen((char const   *)(s));
#line 640
  sprintf((char */* __restrict  */)(s + tmp___3), (char const   */* __restrict  */)"(%2i/%2i) ",
          i + 1, n___1);
#line 641
  tmp___4 = strlen((char const   *)(s));
#line 641
  printm(*(m___1 + i), s + tmp___4);
#line 642
  tmp___5 = strlen((char const   *)(s));
#line 642
  sprintf((char */* __restrict  */)(s + tmp___5), (char const   */* __restrict  */)"     ");
#line 643
  j = 0;
  }
  {
#line 643
  while (1) {
    while_continue: /* CIL Label */ ;
#line 643
    if (! (j != 79)) {
#line 643
      goto while_break;
    }
    {
#line 643
    tmp___6 = strlen((char const   *)(s));
#line 643
    sprintf((char */* __restrict  */)(s + tmp___6), (char const   */* __restrict  */)"\b");
#line 643
    j ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 645
  puts((char const   *)(s));
  }
#line 646
  return;
}
}
#line 650 "/home/wheatley/newnew/temp/phalanx-22+d051004/io.c"
void printboard(char *s ) 
{ 
  int i ;
  char ss[2048] ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;

  {
  {
#line 655
  sprintf((char */* __restrict  */)(ss), (char const   */* __restrict  */)"  +---+---+---+---+---+---+---+---+\n  ");
#line 656
  i = 91;
  }
  {
#line 656
  while (1) {
    while_continue: /* CIL Label */ ;
#line 656
    if (! (i >= 21)) {
#line 656
      goto while_break;
    }
    {
#line 660
    if (((int )B[i] & 3) == 1) {
#line 660
      goto case_1;
    }
#line 663
    if (((int )B[i] & 3) == 2) {
#line 663
      goto case_2;
    }
#line 666
    goto switch_default;
    case_1: /* CIL Label */ 
    {
#line 661
    tmp = strlen((char const   *)(ss));
#line 661
    sprintf((char */* __restrict  */)(ss + tmp), (char const   */* __restrict  */)"| %c ",
            (int )piece[(int )B[i] >> 4]);
    }
#line 662
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 664
    tmp___0 = strlen((char const   *)(ss));
#line 664
    sprintf((char */* __restrict  */)(ss + tmp___0), (char const   */* __restrict  */)"| *%c",
            (int )piece[(int )B[i] >> 4]);
    }
#line 665
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 666
    tmp___1 = strlen((char const   *)(ss));
#line 666
    sprintf((char */* __restrict  */)(ss + tmp___1), (char const   */* __restrict  */)"|   ");
    }
    switch_break: /* CIL Label */ ;
    }
#line 668
    if (i % 10 == 8) {
      {
#line 670
      i -= 18;
#line 671
      tmp___2 = strlen((char const   *)(ss));
#line 671
      sprintf((char */* __restrict  */)(ss + tmp___2), (char const   */* __restrict  */)"|\n  +---+---+---+---+---+---+---+---+");
      }
#line 673
      if (i != 10) {
        {
#line 673
        tmp___3 = strlen((char const   *)(ss));
#line 673
        sprintf((char */* __restrict  */)(ss + tmp___3), (char const   */* __restrict  */)"\n  ");
        }
      }
    }
#line 656
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 676
  if (Color == 1) {
    {
#line 676
    tmp___4 = strlen((char const   *)(ss));
#line 676
    sprintf((char */* __restrict  */)(ss + tmp___4), (char const   */* __restrict  */)"   White to move\n");
    }
  } else {
    {
#line 677
    tmp___5 = strlen((char const   *)(ss));
#line 677
    sprintf((char */* __restrict  */)(ss + tmp___5), (char const   */* __restrict  */)"   Black to move\n");
    }
  }
#line 679
  if ((unsigned long )s == (unsigned long )((void *)0)) {
    {
#line 679
    puts((char const   *)(ss));
    }
  } else {
    {
#line 679
    strcpy((char */* __restrict  */)s, (char const   */* __restrict  */)(ss));
    }
  }
#line 682
  return;
}
}
#line 690 "/home/wheatley/newnew/temp/phalanx-22+d051004/io.c"
int setfen(char *f ) 
{ 
  int s ;
  unsigned short const   **tmp ;
  int tmp___0 ;

  {
#line 695
  if ((unsigned long )Flag.log != (unsigned long )((void *)0)) {
    {
#line 697
    fputs((char const   */* __restrict  */)"\n\nsetting position\n", (FILE */* __restrict  */)Flag.log);
#line 698
    fputs((char const   */* __restrict  */)f, (FILE */* __restrict  */)Flag.log);
#line 699
    fputs((char const   */* __restrict  */)"\n\n", (FILE */* __restrict  */)Flag.log);
    }
  }
#line 702
  s = 0;
  {
#line 702
  while (1) {
    while_continue: /* CIL Label */ ;
#line 702
    if (! (s != 120)) {
#line 702
      goto while_break;
    }
#line 703
    if (s > 98) {
#line 703
      B[s] = (tsquare )3;
    } else
#line 703
    if (s < 21) {
#line 703
      B[s] = (tsquare )3;
    } else
#line 703
    if (s % 10 == 0) {
#line 703
      B[s] = (tsquare )3;
    } else
#line 703
    if (s % 10 == 9) {
#line 703
      B[s] = (tsquare )3;
    } else {
#line 703
      B[s] = (tsquare )0;
    }
#line 702
    s ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 705
  s = 91;
  {
#line 705
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 705
    if (! (s >= 21)) {
#line 705
      goto while_break___0;
    }
#line 707
    if ((int )*f == 0) {
      {
#line 708
      puts("error: unexpected end of fen line");
      }
#line 708
      return (1);
    }
    {
#line 710
    tmp = __ctype_b_loc();
    }
#line 710
    if ((int const   )*(*tmp + (int )*f) & 2048) {
#line 711
      s += (int )*f - 48;
#line 711
      goto __Cont;
    }
    {
#line 715
    if ((int )*f == 75) {
#line 715
      goto case_75;
    }
#line 716
    if ((int )*f == 107) {
#line 716
      goto case_107;
    }
#line 717
    if ((int )*f == 81) {
#line 717
      goto case_81;
    }
#line 718
    if ((int )*f == 113) {
#line 718
      goto case_113;
    }
#line 719
    if ((int )*f == 82) {
#line 719
      goto case_82;
    }
#line 720
    if ((int )*f == 114) {
#line 720
      goto case_114;
    }
#line 721
    if ((int )*f == 66) {
#line 721
      goto case_66;
    }
#line 722
    if ((int )*f == 98) {
#line 722
      goto case_98;
    }
#line 723
    if ((int )*f == 78) {
#line 723
      goto case_78;
    }
#line 724
    if ((int )*f == 110) {
#line 724
      goto case_110;
    }
#line 725
    if ((int )*f == 80) {
#line 725
      goto case_80;
    }
#line 726
    if ((int )*f == 112) {
#line 726
      goto case_112;
    }
#line 727
    if ((int )*f == 59) {
#line 727
      goto case_59;
    }
#line 727
    if ((int )*f == 32) {
#line 727
      goto case_59;
    }
#line 727
    if ((int )*f == 47) {
#line 727
      goto case_59;
    }
#line 728
    goto switch_default;
    case_75: /* CIL Label */ 
#line 715
    B[s] = (tsquare )97;
#line 715
    L[1].next = (unsigned char )s;
#line 715
    goto switch_break;
    case_107: /* CIL Label */ 
#line 716
    B[s] = (tsquare )98;
#line 716
    L[2].next = (unsigned char )s;
#line 716
    goto switch_break;
    case_81: /* CIL Label */ 
#line 717
    B[s] = (tsquare )81;
#line 717
    goto switch_break;
    case_113: /* CIL Label */ 
#line 718
    B[s] = (tsquare )82;
#line 718
    goto switch_break;
    case_82: /* CIL Label */ 
#line 719
    B[s] = (tsquare )65;
#line 719
    goto switch_break;
    case_114: /* CIL Label */ 
#line 720
    B[s] = (tsquare )66;
#line 720
    goto switch_break;
    case_66: /* CIL Label */ 
#line 721
    B[s] = (tsquare )49;
#line 721
    goto switch_break;
    case_98: /* CIL Label */ 
#line 722
    B[s] = (tsquare )50;
#line 722
    goto switch_break;
    case_78: /* CIL Label */ 
#line 723
    B[s] = (tsquare )33;
#line 723
    goto switch_break;
    case_110: /* CIL Label */ 
#line 724
    B[s] = (tsquare )34;
#line 724
    goto switch_break;
    case_80: /* CIL Label */ 
#line 725
    B[s] = (tsquare )17;
#line 725
    goto switch_break;
    case_112: /* CIL Label */ 
#line 726
    B[s] = (tsquare )18;
#line 726
    goto switch_break;
    case_59: /* CIL Label */ 
    case_32: /* CIL Label */ 
    case_47: /* CIL Label */ 
#line 727
    s -= s % 10 + 10;
#line 727
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 728
    puts("error in fen line");
    }
#line 728
    return (1);
    switch_break: /* CIL Label */ ;
    }
#line 731
    s ++;
    __Cont: /* CIL Label */ 
#line 705
    f ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 734
  tmp___0 = tolower((int )*f);
  }
  {
#line 736
  if (tmp___0 == 119) {
#line 736
    goto case_119;
  }
#line 737
  if (tmp___0 == 98) {
#line 737
    goto case_98___0;
  }
#line 738
  goto switch_default___0;
  case_119: /* CIL Label */ 
#line 736
  Color = 1;
#line 736
  goto switch_break___0;
  case_98___0: /* CIL Label */ 
#line 737
  Color = 2;
#line 737
  goto switch_break___0;
  switch_default___0: /* CIL Label */ 
  {
#line 739
  puts("error: side to move must be either \'w\' or \'b\'");
  }
#line 740
  return (1);
  switch_break___0: /* CIL Label */ ;
  }
  {
#line 743
  initbs();
  }
#line 745
  return (0);
}
}
#line 755 "/home/wheatley/newnew/temp/phalanx-22+d051004/io.c"
int sevenslashes(char *s ) 
{ 
  register int n___1 ;

  {
#line 757
  n___1 = 7;
  {
#line 758
  while (1) {
    while_continue: /* CIL Label */ ;
#line 758
    if ((int )*s != 0) {
#line 758
      if (! ((int )*s != 32)) {
#line 758
        goto while_break;
      }
    } else {
#line 758
      goto while_break;
    }
#line 760
    if ((int )*s == 47) {
#line 760
      n___1 --;
#line 760
      if (! n___1) {
#line 760
        return (1);
      }
    }
#line 761
    s ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 763
  return (0);
}
}
#line 775 "/home/wheatley/newnew/temp/phalanx-22+d051004/io.c"
int terminal(void) 
{ 
  tmove m___1[256] ;
  int n___1 ;
  int c ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 781
  if ((int )G[Counter].rule50 >= 100) {
#line 781
    goto _L;
  } else {
    {
#line 781
    tmp = repetition(2);
    }
#line 781
    if (tmp) {
#line 781
      goto _L;
    } else {
      {
#line 781
      tmp___0 = material_draw();
      }
#line 781
      if (tmp___0) {
        _L: /* CIL Label */ 
#line 782
        if (Flag.machine_color == 3) {
#line 782
          Flag.machine_color = 0;
        }
#line 782
        return (1);
      }
    }
  }
#line 784
  if (Color == 1) {
#line 784
    tmp___1 = (int )L[1].next;
  } else {
#line 784
    tmp___1 = (int )L[2].next;
  }
  {
#line 784
  c = attacktest(tmp___1, Color ^ 3);
#line 784
  generate_legal_moves(m___1, & n___1, c);
  }
#line 786
  if (n___1 != 0) {
#line 786
    return (0);
  }
#line 788
  if (c) {
#line 788
    return (3);
  } else {
#line 789
    return (2);
  }
}
}
#line 793 "/home/wheatley/newnew/temp/phalanx-22+d051004/io.c"
void printpositionfen(void) 
{ 
  int s ;
  int empty_counter ;
  int Castling ;
  int c ;
  int destination___0 ;
  int special ;
  int tmp ;

  {
#line 796
  empty_counter = 0;
#line 796
  Castling = 0;
#line 800
  s = 91;
  {
#line 800
  while (1) {
    while_continue: /* CIL Label */ ;
#line 800
    if (! (s >= 21)) {
#line 800
      goto while_break;
    }
    {
#line 804
    if ((int )B[s] == 97) {
#line 804
      goto case_97;
    }
#line 805
    if ((int )B[s] == 98) {
#line 805
      goto case_98;
    }
#line 806
    if ((int )B[s] == 81) {
#line 806
      goto case_81;
    }
#line 807
    if ((int )B[s] == 82) {
#line 807
      goto case_82;
    }
#line 808
    if ((int )B[s] == 65) {
#line 808
      goto case_65;
    }
#line 809
    if ((int )B[s] == 66) {
#line 809
      goto case_66;
    }
#line 810
    if ((int )B[s] == 49) {
#line 810
      goto case_49;
    }
#line 811
    if ((int )B[s] == 50) {
#line 811
      goto case_50;
    }
#line 812
    if ((int )B[s] == 33) {
#line 812
      goto case_33;
    }
#line 813
    if ((int )B[s] == 34) {
#line 813
      goto case_34;
    }
#line 814
    if ((int )B[s] == 17) {
#line 814
      goto case_17;
    }
#line 815
    if ((int )B[s] == 18) {
#line 815
      goto case_18;
    }
#line 817
    goto switch_default;
    case_97: /* CIL Label */ 
#line 804
    if (empty_counter) {
      {
#line 804
      printf((char const   */* __restrict  */)"%d", empty_counter);
#line 804
      empty_counter = 0;
      }
    }
    {
#line 804
    printf((char const   */* __restrict  */)"K");
    }
#line 804
    goto switch_break;
    case_98: /* CIL Label */ 
#line 805
    if (empty_counter) {
      {
#line 805
      printf((char const   */* __restrict  */)"%d", empty_counter);
#line 805
      empty_counter = 0;
      }
    }
    {
#line 805
    printf((char const   */* __restrict  */)"k");
    }
#line 805
    goto switch_break;
    case_81: /* CIL Label */ 
#line 806
    if (empty_counter) {
      {
#line 806
      printf((char const   */* __restrict  */)"%d", empty_counter);
#line 806
      empty_counter = 0;
      }
    }
    {
#line 806
    printf((char const   */* __restrict  */)"Q");
    }
#line 806
    goto switch_break;
    case_82: /* CIL Label */ 
#line 807
    if (empty_counter) {
      {
#line 807
      printf((char const   */* __restrict  */)"%d", empty_counter);
#line 807
      empty_counter = 0;
      }
    }
    {
#line 807
    printf((char const   */* __restrict  */)"q");
    }
#line 807
    goto switch_break;
    case_65: /* CIL Label */ 
#line 808
    if (empty_counter) {
      {
#line 808
      printf((char const   */* __restrict  */)"%d", empty_counter);
#line 808
      empty_counter = 0;
      }
    }
    {
#line 808
    printf((char const   */* __restrict  */)"R");
    }
#line 808
    goto switch_break;
    case_66: /* CIL Label */ 
#line 809
    if (empty_counter) {
      {
#line 809
      printf((char const   */* __restrict  */)"%d", empty_counter);
#line 809
      empty_counter = 0;
      }
    }
    {
#line 809
    printf((char const   */* __restrict  */)"r");
    }
#line 809
    goto switch_break;
    case_49: /* CIL Label */ 
#line 810
    if (empty_counter) {
      {
#line 810
      printf((char const   */* __restrict  */)"%d", empty_counter);
#line 810
      empty_counter = 0;
      }
    }
    {
#line 810
    printf((char const   */* __restrict  */)"B");
    }
#line 810
    goto switch_break;
    case_50: /* CIL Label */ 
#line 811
    if (empty_counter) {
      {
#line 811
      printf((char const   */* __restrict  */)"%d", empty_counter);
#line 811
      empty_counter = 0;
      }
    }
    {
#line 811
    printf((char const   */* __restrict  */)"b");
    }
#line 811
    goto switch_break;
    case_33: /* CIL Label */ 
#line 812
    if (empty_counter) {
      {
#line 812
      printf((char const   */* __restrict  */)"%d", empty_counter);
#line 812
      empty_counter = 0;
      }
    }
    {
#line 812
    printf((char const   */* __restrict  */)"N");
    }
#line 812
    goto switch_break;
    case_34: /* CIL Label */ 
#line 813
    if (empty_counter) {
      {
#line 813
      printf((char const   */* __restrict  */)"%d", empty_counter);
#line 813
      empty_counter = 0;
      }
    }
    {
#line 813
    printf((char const   */* __restrict  */)"n");
    }
#line 813
    goto switch_break;
    case_17: /* CIL Label */ 
#line 814
    if (empty_counter) {
      {
#line 814
      printf((char const   */* __restrict  */)"%d", empty_counter);
#line 814
      empty_counter = 0;
      }
    }
    {
#line 814
    printf((char const   */* __restrict  */)"P");
    }
#line 814
    goto switch_break;
    case_18: /* CIL Label */ 
#line 815
    if (empty_counter) {
      {
#line 815
      printf((char const   */* __restrict  */)"%d", empty_counter);
#line 815
      empty_counter = 0;
      }
    }
    {
#line 815
    printf((char const   */* __restrict  */)"p");
    }
#line 815
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 817
    empty_counter ++;
#line 817
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 820
    if (s % 10 == 8) {
#line 822
      if (empty_counter) {
        {
#line 822
        printf((char const   */* __restrict  */)"%d", empty_counter);
#line 822
        empty_counter = 0;
        }
      }
#line 823
      s -= 18;
#line 824
      if (s != 10) {
        {
#line 824
        printf((char const   */* __restrict  */)"/");
        }
      } else {
        {
#line 824
        printf((char const   */* __restrict  */)" ");
        }
      }
    }
#line 800
    s ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 828
  if (Color == 1) {
    {
#line 828
    printf((char const   */* __restrict  */)"w ");
    }
  } else {
    {
#line 828
    printf((char const   */* __restrict  */)"b ");
    }
  }
#line 831
  if (((int )G[Counter].castling & 1) == 0) {
    {
#line 832
    printf((char const   */* __restrict  */)"K");
#line 832
    Castling ++;
    }
  }
#line 835
  if (((int )G[Counter].castling & 2) == 0) {
    {
#line 836
    printf((char const   */* __restrict  */)"Q");
#line 836
    Castling ++;
    }
  }
#line 839
  if (((int )G[Counter].castling & 4) == 0) {
    {
#line 840
    printf((char const   */* __restrict  */)"k");
#line 840
    Castling ++;
    }
  }
#line 842
  if (((int )G[Counter].castling & 8) == 0) {
    {
#line 843
    printf((char const   */* __restrict  */)"q");
#line 843
    Castling ++;
    }
  }
#line 845
  if (! Castling) {
    {
#line 845
    printf((char const   */* __restrict  */)"- ");
    }
  } else {
    {
#line 845
    printf((char const   */* __restrict  */)" ");
    }
  }
#line 847
  if (Counter != 0) {
#line 849
    c = Counter - 1;
#line 850
    if (((int )G[c].m.in1 & 252) == 16) {
      {
#line 850
      tmp = abs((int )G[c].m.from - (int )G[c].m.to);
      }
#line 850
      if (tmp == 20) {
#line 854
        special = (int )G[c].m.to;
#line 856
        if (Color == 1) {
#line 856
          destination___0 = special + 10;
        } else {
#line 856
          destination___0 = special - 10;
        }
        {
#line 857
        printf((char const   */* __restrict  */)"%c%c ", (int )file[destination___0 % 10],
               (int )row[destination___0 / 10]);
        }
      } else {
        {
#line 860
        printf((char const   */* __restrict  */)"- ");
        }
      }
    } else {
      {
#line 860
      printf((char const   */* __restrict  */)"- ");
      }
    }
  } else {
    {
#line 862
    printf((char const   */* __restrict  */)"- ");
    }
  }
  {
#line 864
  printf((char const   */* __restrict  */)"%d %d\n", (int )G[Counter].rule50, Counter / 2 + 1);
  }
#line 866
  return;
}
}
#line 868 "/home/wheatley/newnew/temp/phalanx-22+d051004/io.c"
void about(void) 
{ 


  {
  {
#line 871
  printf((char const   */* __restrict  */)" Phalanx ");
#line 871
  puts("XXII-pg");
#line 872
  puts(" Copyright (C) Dusan Dobes, 1997-2000");
#line 874
  printf((char const   */* __restrict  */)" Level ................. ");
  }
  {
#line 877
  if ((unsigned int )Flag.level == 1U) {
#line 877
    goto case_1;
  }
#line 880
  if ((unsigned int )Flag.level == 0U) {
#line 880
    goto case_0;
  }
#line 884
  if ((unsigned int )Flag.level == 3U) {
#line 884
    goto case_3;
  }
#line 887
  if ((unsigned int )Flag.level == 2U) {
#line 887
    goto case_2;
  }
#line 875
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 878
  printf((char const   */* __restrict  */)"average time %i seconds\n", Flag.centiseconds / 100);
  }
#line 879
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 881
  printf((char const   */* __restrict  */)"%i moves in %i minutes\n", Flag.moves,
         Flag.centiseconds / 6000);
  }
#line 883
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 885
  printf((char const   */* __restrict  */)"%i search depth\n", Flag.depth / 100);
  }
#line 886
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 888
  printf((char const   */* __restrict  */)"fixed time %i seconds\n", Flag.centiseconds / 100);
  }
  switch_break: /* CIL Label */ ;
  }
  {
#line 891
  printf((char const   */* __restrict  */)" Time .................. ");
  }
#line 892
  if (Flag.cpu) {
    {
#line 892
    puts("cpu");
    }
  } else {
    {
#line 892
    puts("elapsed");
    }
  }
  {
#line 894
  printf((char const   */* __restrict  */)" Book .................. ");
  }
#line 895
  if (Flag.book) {
    {
#line 895
    puts("on");
    }
  } else {
    {
#line 895
    puts("off");
    }
  }
  {
#line 897
  printf((char const   */* __restrict  */)" Learning .............. ");
  }
#line 898
  if (Flag.learn) {
    {
#line 898
    puts("on");
    }
  } else {
    {
#line 898
    puts("off");
    }
  }
  {
#line 900
  printf((char const   */* __restrict  */)" Permanent brain ....... ");
  }
  {
#line 902
  if (Flag.ponder == 0) {
#line 902
    goto case_0___0;
  }
#line 903
  if (Flag.ponder == 1) {
#line 903
    goto case_1___0;
  }
#line 904
  if (Flag.ponder == 2) {
#line 904
    goto case_2___0;
  }
#line 905
  goto switch_default;
  case_0___0: /* CIL Label */ 
  {
#line 902
  puts("off");
  }
#line 902
  goto switch_break___0;
  case_1___0: /* CIL Label */ 
  {
#line 903
  puts("on");
  }
#line 903
  goto switch_break___0;
  case_2___0: /* CIL Label */ 
  {
#line 904
  puts("on (pondering)");
  }
#line 904
  goto switch_break___0;
  switch_default: /* CIL Label */ 
#line 906
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
  {
#line 913
  printf((char const   */* __restrict  */)" Transposition table ... ");
  }
#line 914
  if (SizeHT == 0U) {
    {
#line 914
    puts("not used");
    }
  } else {
    {
#line 917
    printf((char const   */* __restrict  */)"hashing %i positions in %lu bytes\n",
           SizeHT, sizeof(thashentry ) * (unsigned long )SizeHT);
    }
  }
#line 921
  if (Flag.easy) {
    {
#line 923
    printf((char const   */* __restrict  */)" Easy level ............ %i\n", (int )Flag.easy);
    }
  }
  {
#line 926
  printf((char const   */* __restrict  */)" Resigning ............. ");
  }
#line 927
  if (Flag.resign) {
    {
#line 927
    printf((char const   */* __restrict  */)"%i.%02i\n", Flag.resign / 100, Flag.resign % 100);
    }
  } else {
    {
#line 928
    printf((char const   */* __restrict  */)"off\n");
    }
  }
  {
#line 930
  printf((char const   */* __restrict  */)"\n");
  }
#line 932
  return;
}
}
#line 937 "/home/wheatley/newnew/temp/phalanx-22+d051004/io.c"
void interrupt(int x ) 
{ 
  int c ;
  int tmp ;

  {
  {
#line 940
  signal(2, (void (*)(int  ))1);
  }
#line 942
  if (Flag.polling) {
    {
#line 945
    c = _IO_getc(stdin);
#line 945
    ungetc(c, stdin);
    }
#line 946
    if (c == 46) {
      {
#line 946
      fgets((char */* __restrict  */)(Inp), 255, (FILE */* __restrict  */)stdin);
      }
#line 946
      goto go_on;
    }
  }
#line 949
  if (Flag.ponder < 2) {
    {
#line 951
    puts("interrupted");
#line 952
    Abort = 1;
    }
#line 953
    goto go_on;
  }
  {
#line 955
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 955
    tmp = command();
    }
#line 955
    if (! tmp) {
#line 955
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  go_on: ;
#line 958
  if (! Abort) {
#line 958
    if (! Flag.polling) {
      {
#line 958
      signal(2, & interrupt);
      }
    }
  }
#line 959
  return;
}
}
#line 965 "/home/wheatley/newnew/temp/phalanx-22+d051004/io.c"
static int no_prompt  =    0;
#line 1345 "/home/wheatley/newnew/temp/phalanx-22+d051004/io.c"
static int entered  =    0;
#line 1346 "/home/wheatley/newnew/temp/phalanx-22+d051004/io.c"
static int found  =    0;
#line 1363 "/home/wheatley/newnew/temp/phalanx-22+d051004/io.c"
static char filename[16]  = 
#line 1363
  {      (char )'n',      (char )'o',      (char )'t',      (char )'f', 
        (char )'o',      (char )'u',      (char )'n',      (char )'d', 
        (char )'.',      (char )'f',      (char )'i',      (char )'n', 
        (char )'\000'};
#line 963 "/home/wheatley/newnew/temp/phalanx-22+d051004/io.c"
int command(void) 
{ 
  char const   *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  tmove m___1[256] ;
  int n___1 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int phal ;
  int oppo ;
  int diff ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;
  int newdepth ;
  int tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;
  int tmp___35 ;
  int tmp___36 ;
  int tmp___37 ;
  int tmp___38 ;
  int tmp___39 ;
  int i ;
  int sc ;
  int tmp___40 ;
  int tmp___41 ;
  int tmp___42 ;
  int tmp___43 ;
  int tmp___44 ;
  int tmp___45 ;
  int tmp___46 ;
  int tmp___47 ;
  int f ;
  tmove m___2 ;
  int i___0 ;
  int tmp___48 ;
  FILE *nf ;
  int tmp___49 ;
  int tmp___50 ;
  tmove *pm ;
  tmove *tmp___51 ;
  int tmp___52 ;
  tmove m___3[256] ;
  int n___2 ;
  int i___1 ;
  int tmp___53 ;
  int tmp___54 ;
  tmove *sd ;
  tmove *tmp___55 ;
  int tmp___56 ;
  int tmp___57 ;
  char *c ;
  char *tmp___58 ;

  {
#line 967
  if (Flag.xboard < 2) {
#line 969
    if (no_prompt) {
#line 971
      no_prompt = 0;
    } else
#line 974
    if (Flag.ponder >= 2) {
      {
#line 976
      printf((char const   */* __restrict  */)"\n[ pondering ]\n");
      }
    } else {
#line 980
      if (Color == 1) {
#line 980
        tmp = "white";
      } else {
#line 980
        tmp = "black";
      }
      {
#line 980
      printf((char const   */* __restrict  */)"[ %s, %i ]\n", tmp, Counter / 2 + 1);
      }
    }
  }
#line 984
  if ((int )Inp[0] == 0) {
    {
#line 985
    tmp___0 = fgets((char */* __restrict  */)(Inp), 255, (FILE */* __restrict  */)stdin);
    }
#line 985
    if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
      {
#line 985
      strcpy((char */* __restrict  */)(Inp), (char const   */* __restrict  */)"quit\n");
      }
    }
  }
  {
#line 987
  tmp___1 = strncmp((char const   *)(Inp), "exit\n", (size_t )5);
  }
#line 987
  if (tmp___1 == 0) {
#line 987
    if (Flag.analyze) {
#line 988
      Flag.analyze = 0;
#line 988
      Flag.machine_color = Flag.analyze;
#line 988
      Inp[0] = (char )'\000';
#line 988
      return (1);
    }
  }
  {
#line 990
  tmp___2 = strncmp((char const   *)(Inp), "quit\n", (size_t )5);
  }
#line 990
  if (tmp___2 == 0) {
#line 990
    goto _L;
  } else {
    {
#line 990
    tmp___3 = strncmp((char const   *)(Inp), "exit\n", (size_t )5);
    }
#line 990
    if (tmp___3 == 0) {
      _L: /* CIL Label */ 
#line 993
      if (Flag.ponder < 2) {
#line 993
        return (0);
      } else {
#line 995
        Abort = 1;
#line 995
        return (0);
      }
    }
  }
#line 999
  if ((int )Inp[0] == 35) {
    {
#line 1000
    printf((char const   */* __restrict  */)"%s", Inp);
#line 1000
    no_prompt = 1;
#line 1000
    Inp[0] = (char )'\000';
    }
#line 1000
    return (1);
  }
#line 1003
  if ((int )Inp[0] == 10) {
#line 1004
    Inp[0] = (char )'\000';
#line 1005
    if (Flag.ponder >= 2) {
#line 1005
      return (0);
    } else {
#line 1006
      return (1);
    }
  }
  {
#line 1010
  tmp___4 = strncmp((char const   *)(Inp), "analyze\n", (size_t )8);
  }
#line 1010
  if (tmp___4 == 0) {
#line 1012
    if (Flag.ponder >= 2) {
#line 1012
      Abort = 1;
#line 1012
      return (0);
    }
    {
#line 1013
    puts("analyze mode, type \'exit\' to terminate");
#line 1014
    Flag.analyze = 1;
#line 1015
    Flag.machine_color = 3;
#line 1016
    Inp[0] = (char )'\000';
    }
#line 1016
    return (1);
  }
  {
#line 1020
  tmp___5 = strncmp((char const   *)(Inp), "force\n", (size_t )6);
  }
#line 1020
  if (tmp___5 == 0) {
#line 1022
    if (Flag.ponder >= 2) {
#line 1022
      Abort = 1;
#line 1022
      return (0);
    }
    {
#line 1023
    puts("you play both");
    }
#line 1024
    if (Flag.analyze) {
#line 1024
      Flag.machine_color = Color;
    } else {
#line 1025
      Flag.machine_color = 0;
    }
#line 1026
    Inp[0] = (char )'\000';
#line 1026
    return (1);
  }
  {
#line 1030
  tmp___6 = strncmp((char const   *)(Inp), "white\n", (size_t )6);
  }
#line 1030
  if (tmp___6 == 0) {
#line 1030
    goto _L___0;
  } else {
    {
#line 1030
    tmp___7 = strncmp((char const   *)(Inp), "black\n", (size_t )6);
    }
#line 1030
    if (tmp___7 == 0) {
      _L___0: /* CIL Label */ 
#line 1033
      if (Flag.ponder >= 2) {
#line 1033
        Abort = 1;
#line 1033
        return (0);
      }
      {
#line 1034
      puts("you do not play both");
      }
#line 1035
      if (Flag.machine_color == 0) {
#line 1036
        Flag.machine_color = Color ^ 3;
      }
#line 1037
      Inp[0] = (char )'\000';
#line 1037
      return (1);
    }
  }
  {
#line 1041
  tmp___8 = strncmp((char const   *)(Inp), "both\n", (size_t )5);
  }
#line 1041
  if (tmp___8 == 0) {
#line 1043
    if (Flag.ponder >= 2) {
#line 1043
      Abort = 1;
#line 1043
      return (0);
    }
    {
#line 1044
    puts("machine plays both");
#line 1045
    Flag.machine_color = 3;
#line 1046
    Inp[0] = (char )'\000';
    }
#line 1046
    return (1);
  }
  {
#line 1050
  tmp___9 = strncmp((char const   *)(Inp), "new\n", (size_t )4);
  }
#line 1050
  if (tmp___9 == 0) {
#line 1052
    if (Flag.ponder >= 2) {
#line 1052
      Abort = 1;
#line 1052
      return (0);
    }
    {
#line 1053
    setfen((char *)"rnbqkbnr/pppppppp/////PPPPPPPP/RNBQKBNR/w");
#line 1054
    DrawScore = -20;
    }
#line 1055
    if (Flag.analyze) {
#line 1055
      Flag.machine_color = 1;
    } else {
      {
#line 1058
      Flag.machine_color = 2;
#line 1059
      puts("initial position set, machine plays black");
      }
    }
#line 1061
    Inp[0] = (char )'\000';
#line 1061
    return (1);
  }
  {
#line 1065
  tmp___10 = strncmp((char const   *)(Inp), "go\n", (size_t )3);
  }
#line 1065
  if (tmp___10 == 0) {
#line 1067
    if (Flag.ponder >= 2) {
#line 1067
      Abort = 1;
#line 1067
      return (0);
    }
#line 1068
    Flag.machine_color = Color;
#line 1069
    Inp[0] = (char )'\000';
#line 1069
    return (1);
  }
  {
#line 1073
  tmp___11 = strncmp((char const   *)(Inp), "bd\n", (size_t )3);
  }
#line 1073
  if (tmp___11 == 0) {
    {
#line 1074
    printboard((char *)((void *)0));
#line 1074
    Inp[0] = (char )'\000';
    }
#line 1074
    return (1);
  } else {
    {
#line 1073
    tmp___12 = strncmp((char const   *)(Inp), "d\n", (size_t )2);
    }
#line 1073
    if (tmp___12 == 0) {
      {
#line 1074
      printboard((char *)((void *)0));
#line 1074
      Inp[0] = (char )'\000';
      }
#line 1074
      return (1);
    }
  }
  {
#line 1077
  tmp___15 = strncmp((char const   *)(Inp), "bk\n", (size_t )3);
  }
#line 1077
  if (tmp___15 == 0) {
#line 1081
    if (Flag.ponder >= 2) {
#line 1081
      Abort = 1;
#line 1081
      return (0);
    }
#line 1082
    if (Color == 1) {
#line 1082
      tmp___13 = (int )L[1].next;
    } else {
#line 1082
      tmp___13 = (int )L[2].next;
    }
    {
#line 1082
    tmp___14 = attacktest(tmp___13, Color ^ 3);
#line 1082
    generate_legal_moves(m___1, & n___1, tmp___14);
#line 1083
    bk(m___1, n___1);
#line 1085
    Inp[0] = (char )'\000';
    }
#line 1085
    return (1);
  }
  {
#line 1089
  tmp___16 = strncmp((char const   *)(Inp), "post\n", (size_t )5);
  }
#line 1089
  if (tmp___16 == 0) {
    {
#line 1091
    Flag.post = 1;
#line 1092
    puts("post on");
#line 1093
    Inp[0] = (char )'\000';
    }
#line 1093
    return (1);
  }
  {
#line 1097
  tmp___17 = strncmp((char const   *)(Inp), "nopost\n", (size_t )7);
  }
#line 1097
  if (tmp___17 == 0) {
    {
#line 1099
    Flag.post = 0;
#line 1100
    puts("post off");
#line 1101
    Inp[0] = (char )'\000';
    }
#line 1101
    return (1);
  }
  {
#line 1105
  tmp___18 = strncmp((char const   *)(Inp), "level ", (size_t )6);
  }
#line 1105
  if (tmp___18 == 0) {
    {
#line 1107
    l_level(Inp + 6);
#line 1108
    Inp[0] = (char )'\000';
    }
#line 1108
    return (1);
  }
  {
#line 1112
  tmp___19 = strncmp((char const   *)(Inp), "time ", (size_t )5);
  }
#line 1112
  if (tmp___19 == 0) {
    {
#line 1114
    sscanf((char const   */* __restrict  */)(Inp + 5), (char const   */* __restrict  */)"%li",
           & Time);
#line 1115
    Inp[0] = (char )'\000';
    }
#line 1115
    return (1);
  }
  {
#line 1119
  tmp___20 = strncmp((char const   *)(Inp), "otim ", (size_t )5);
  }
#line 1119
  if (tmp___20 == 0) {
    {
#line 1121
    sscanf((char const   */* __restrict  */)(Inp + 5), (char const   */* __restrict  */)"%li",
           & Otim);
#line 1122
    Inp[0] = (char )'\000';
    }
#line 1122
    return (1);
  }
  {
#line 1126
  tmp___22 = strncmp((char const   *)(Inp), "rating ", (size_t )7);
  }
#line 1126
  if (tmp___22 == 0) {
    {
#line 1129
    tmp___21 = sscanf((char const   */* __restrict  */)(Inp + 7), (char const   */* __restrict  */)"%i %i",
                      & phal, & oppo);
    }
#line 1129
    if (tmp___21 == 2) {
#line 1131
      diff = oppo - phal;
#line 1132
      if (diff > 300) {
#line 1132
        DrawScore = 20;
      } else
#line 1133
      if (diff < -300) {
#line 1133
        DrawScore = -20;
      } else {
#line 1134
        DrawScore = diff / 15;
      }
      {
#line 1135
      printf((char const   */* __restrict  */)"setting draw score to %i\n", DrawScore);
#line 1136
      Inp[0] = (char )'\000';
      }
#line 1136
      return (1);
    }
  }
  {
#line 1142
  tmp___23 = strncmp((char const   *)(Inp), "hard\n", (size_t )5);
  }
#line 1142
  if (tmp___23 == 0) {
#line 1144
    if (Flag.ponder == 0) {
#line 1144
      if ((int )Flag.easy == 0) {
#line 1145
        Flag.ponder = 1;
      }
    }
#line 1146
    if (Flag.ponder) {
      {
#line 1146
      puts("pondering on");
      }
    }
#line 1147
    Inp[0] = (char )'\000';
#line 1147
    return (1);
  }
  {
#line 1151
  tmp___24 = strncmp((char const   *)(Inp), "easy\n", (size_t )5);
  }
#line 1151
  if (tmp___24 == 0) {
#line 1153
    if (Flag.ponder != 0) {
#line 1155
      if (Flag.ponder >= 2) {
#line 1155
        Abort = 1;
#line 1155
        return (0);
      }
#line 1156
      Flag.ponder = 0;
    }
    {
#line 1158
    puts("pondering off");
#line 1159
    Inp[0] = (char )'\000';
    }
#line 1159
    return (1);
  }
  {
#line 1163
  tmp___25 = strncmp((char const   *)(Inp), "beep\n", (size_t )5);
  }
#line 1163
  if (tmp___25 == 0) {
#line 1172
    Inp[0] = (char )'\000';
#line 1172
    return (1);
  } else {
    {
#line 1163
    tmp___26 = strncmp((char const   *)(Inp), "bogus\n", (size_t )6);
    }
#line 1163
    if (tmp___26 == 0) {
#line 1172
      Inp[0] = (char )'\000';
#line 1172
      return (1);
    } else {
      {
#line 1163
      tmp___27 = strncmp((char const   *)(Inp), "draw\n", (size_t )5);
      }
#line 1163
      if (tmp___27 == 0) {
#line 1172
        Inp[0] = (char )'\000';
#line 1172
        return (1);
      } else {
        {
#line 1163
        tmp___28 = strncmp((char const   *)(Inp), "name ", (size_t )5);
        }
#line 1163
        if (tmp___28 == 0) {
#line 1172
          Inp[0] = (char )'\000';
#line 1172
          return (1);
        } else {
          {
#line 1163
          tmp___29 = strncmp((char const   *)(Inp), "random\n", (size_t )7);
          }
#line 1163
          if (tmp___29 == 0) {
#line 1172
            Inp[0] = (char )'\000';
#line 1172
            return (1);
          } else {
            {
#line 1163
            tmp___30 = strncmp((char const   *)(Inp), "noise ", (size_t )6);
            }
#line 1163
            if (tmp___30 == 0) {
#line 1172
              Inp[0] = (char )'\000';
#line 1172
              return (1);
            } else {
              {
#line 1163
              tmp___31 = strncmp((char const   *)(Inp), ".\n", (size_t )2);
              }
#line 1163
              if (tmp___31 == 0) {
#line 1172
                Inp[0] = (char )'\000';
#line 1172
                return (1);
              }
            }
          }
        }
      }
    }
  }
  {
#line 1175
  tmp___32 = strncmp((char const   *)(Inp), "depth", (size_t )5);
  }
#line 1175
  if (tmp___32 == 0) {
#line 1178
    if ((int )Inp[5] == 10) {
      {
#line 1179
      printf((char const   */* __restrict  */)"depth= ");
#line 1179
      scanf((char const   */* __restrict  */)"%i", & newdepth);
      }
    } else {
      {
#line 1181
      sscanf((char const   */* __restrict  */)(& Inp[6]), (char const   */* __restrict  */)"%i",
             & newdepth);
      }
    }
#line 1182
    Flag.depth = 100 * newdepth;
#line 1183
    if (Flag.depth < 200) {
#line 1183
      Flag.depth = 200;
    } else
#line 1184
    if (Flag.depth > 4000) {
#line 1184
      Flag.depth = 4000;
    }
    {
#line 1185
    Flag.level = (tlevel )3;
#line 1187
    printf((char const   */* __restrict  */)"search depth %i\n", Flag.depth / 100);
#line 1188
    Inp[0] = (char )'\000';
    }
#line 1188
    return (1);
  }
  {
#line 1192
  tmp___33 = strncmp((char const   *)(Inp), "book\n", (size_t )5);
  }
#line 1192
  if (tmp___33 == 0) {
#line 1194
    Flag.book = ! Flag.book;
#line 1195
    if (Flag.book) {
      {
#line 1195
      puts("book on");
      }
    } else {
      {
#line 1196
      puts("book off");
      }
    }
#line 1197
    Inp[0] = (char )'\000';
#line 1197
    return (1);
  }
  {
#line 1201
  tmp___34 = strncmp((char const   *)(Inp), "about\n", (size_t )6);
  }
#line 1201
  if (tmp___34 == 0) {
    {
#line 1202
    about();
#line 1202
    Inp[0] = (char )'\000';
    }
#line 1202
    return (1);
  }
  {
#line 1205
  tmp___35 = strncmp((char const   *)(Inp), "fen\n", (size_t )3);
  }
#line 1205
  if (tmp___35 == 0) {
    {
#line 1206
    printpositionfen();
#line 1206
    Inp[0] = (char )'\000';
    }
#line 1206
    return (1);
  }
  {
#line 1209
  tmp___36 = strncmp((char const   *)(Inp), "help\n", (size_t )5);
  }
#line 1209
  if (tmp___36 == 0) {
    {
#line 1211
    puts("COMMAND SUMMARY: about (shows settings), bd (displays position - same");
#line 1212
    puts("as \'d\'), bk (shows book info), book (enables/disables book), both");
#line 1213
    puts("(machine plays both), depth <N> (set search depth), fen, force (user");
#line 1214
    puts("plays both, go (start computing), help, history (show game moves),");
#line 1215
    puts("level <moves> <minutes> <increment in seconds>, level <seconds per");
#line 1216
    puts("move>, new (new game), post (show thinking), remove (take back last");
#line 1217
    puts("move, two plies), nopost (do not show thinking), quit (same as \'exit\'");
#line 1218
    puts("or end of file character), score (show static evaluation), time <N>");
#line 1219
    puts("(remaining time is N/100 s), undo (undo last ply - same as \'u\'),");
#line 1220
    puts("<FEN position> (set test position, start search, show result),");
#line 1221
    puts("# (comment)");
#line 1222
    Inp[0] = (char )'\000';
    }
#line 1222
    return (1);
  }
  {
#line 1226
  tmp___38 = strncmp((char const   *)(Inp), "score\n", (size_t )6);
  }
#line 1226
  if (tmp___38 == 0) {
    {
#line 1228
    Scoring = 1;
#line 1228
    Depth = 100;
#line 1229
    printf((char const   */* __restrict  */)"\n (stm) material = %i\n", (int )G[Counter].mtrl - (int )G[Counter].xmtrl);
#line 1231
    tmp___37 = score_position();
#line 1231
    printf((char const   */* __restrict  */)" TOTAL EVALUATION = %i\n", tmp___37);
#line 1233
    printf((char const   */* __restrict  */)"Wknow.hung=%i; Wknow.khung=%i\n", (int )Wknow.hung,
           (int )Wknow.khung);
#line 1235
    printf((char const   */* __restrict  */)"Bknow.hung=%i; Bknow.khung=%i\n", (int )Bknow.hung,
           (int )Bknow.khung);
#line 1237
    puts("");
#line 1238
    Scoring = 0;
#line 1239
    Inp[0] = (char )'\000';
    }
#line 1239
    return (1);
  }
  {
#line 1243
  tmp___39 = strncmp((char const   *)(Inp), "xboard\n", (size_t )7);
  }
#line 1243
  if (tmp___39 == 0) {
    {
#line 1245
    Flag.xboard = 2;
#line 1246
    puts("xboard mode on");
#line 1247
    Inp[0] = (char )'\000';
    }
#line 1247
    return (1);
  }
  {
#line 1251
  tmp___40 = strncmp((char const   *)(Inp), "history\n", (size_t )8);
  }
#line 1251
  if (tmp___40 == 0) {
#line 1254
    sc = ((Counter + Color) + 1) % 2;
#line 1255
    if (sc) {
      {
#line 1255
      printf((char const   */* __restrict  */)"\n 1. ... ");
      }
    }
#line 1256
    i = 0;
    {
#line 1256
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1256
      if (! (i < Counter)) {
#line 1256
        goto while_break;
      }
#line 1258
      if ((i + sc) % 2 == 0) {
#line 1260
        if ((i + sc) % 6 == 0) {
          {
#line 1260
          puts("");
          }
        }
        {
#line 1261
        printf((char const   */* __restrict  */)"%2i. ", ((i + sc) + 2) / 2);
        }
      }
      {
#line 1263
      printm(G[i].m, (char *)((void *)0));
#line 1256
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1265
    puts("");
#line 1266
    Inp[0] = (char )'\000';
    }
#line 1266
    return (1);
  }
  {
#line 1270
  tmp___41 = strncmp((char const   *)(Inp), "undo\n", (size_t )5);
  }
#line 1270
  if (tmp___41 == 0) {
#line 1270
    goto _L___1;
  } else {
    {
#line 1270
    tmp___42 = strncmp((char const   *)(Inp), "u\n", (size_t )2);
    }
#line 1270
    if (tmp___42 == 0) {
      _L___1: /* CIL Label */ 
#line 1272
      if (Flag.ponder >= 2) {
#line 1272
        Abort = 1;
#line 1272
        return (0);
      }
#line 1273
      if (Counter != 0) {
        {
#line 1275
        undo_move(& G[Counter - 1].m);
        }
#line 1276
        if (Flag.xboard < 2) {
          {
#line 1276
          puts("halfmove back");
          }
        }
#line 1277
        if (Flag.machine_color != 0) {
#line 1278
          Flag.machine_color = Color ^ 3;
        }
#line 1279
        if (Flag.analyze) {
#line 1279
          Flag.machine_color = Color;
        }
      } else {
        {
#line 1281
        puts("cannot undo");
        }
      }
#line 1282
      Inp[0] = (char )'\000';
#line 1282
      return (1);
    }
  }
  {
#line 1286
  tmp___43 = strncmp((char const   *)(Inp), "remove\n", (size_t )7);
  }
#line 1286
  if (tmp___43 == 0) {
#line 1288
    if (Flag.ponder >= 2) {
#line 1288
      Abort = 1;
#line 1288
      return (0);
    }
#line 1289
    if (Counter > 1) {
      {
#line 1291
      undo_move(& G[Counter - 1].m);
#line 1292
      undo_move(& G[Counter - 1].m);
      }
#line 1293
      if (Flag.xboard < 2) {
        {
#line 1293
        puts("move back");
        }
      }
#line 1294
      if (Flag.machine_color != 0) {
#line 1295
        Flag.machine_color = Color ^ 3;
      }
    } else {
      {
#line 1297
      puts("cannot remove");
      }
    }
#line 1298
    Inp[0] = (char )'\000';
#line 1298
    return (1);
  }
  {
#line 1302
  tmp___44 = strncmp((char const   *)(Inp), "edit\n", (size_t )5);
  }
#line 1302
  if (tmp___44 == 0) {
#line 1304
    if (Flag.ponder >= 2) {
#line 1304
      Abort = 1;
#line 1304
      return (0);
    }
    {
#line 1305
    edit();
    }
#line 1306
    if (Flag.analyze) {
#line 1306
      Flag.machine_color = 3;
    } else {
#line 1307
      Flag.machine_color = 0;
    }
#line 1308
    if ((int )Inp[0] == 101) {
#line 1308
      Inp[0] = (char )'\000';
    }
#line 1309
    return (1);
  }
  {
#line 1314
  tmp___45 = strncmp((char const   *)(Inp), "setboard ", (size_t )9);
  }
#line 1314
  if (tmp___45 == 0) {
    {
#line 1316
    setfen(Inp + 9);
#line 1317
    Inp[0] = (char )'\000';
    }
#line 1318
    return (1);
  }
  {
#line 1323
  tmp___46 = strncmp((char const   *)(Inp), "setboard ", (size_t )9);
  }
#line 1323
  if (tmp___46 == 0) {
    {
#line 1325
    setfen(Inp + 9);
#line 1326
    Inp[0] = (char )'\000';
    }
#line 1327
    return (1);
  }
  {
#line 1332
  tmp___47 = strncmp((char const   *)(Inp), "setboard ", (size_t )9);
  }
#line 1332
  if (tmp___47 == 0) {
    {
#line 1334
    setfen(Inp + 9);
#line 1335
    Inp[0] = (char )'\000';
    }
#line 1336
    return (1);
  }
  {
#line 1340
  tmp___50 = sevenslashes(Inp);
  }
#line 1340
  if (tmp___50) {
#line 1342
    if (Flag.ponder >= 2) {
#line 1342
      Abort = 1;
#line 1342
      return (0);
    }
    {
#line 1343
    tmp___49 = setfen(Inp);
    }
#line 1343
    if (tmp___49 == 0) {
      {
#line 1347
      f = 0;
#line 1351
      printf((char const   */* __restrict  */)"\n%s", Inp);
#line 1352
      m___2 = root_search();
#line 1353
      Flag.machine_color = 0;
      }
#line 1354
      if (! Flag.post) {
        {
#line 1354
        Depth += 100;
#line 1354
        infoline(0, (char *)((void *)0));
        }
      }
#line 1356
      entered ++;
#line 1357
      i___0 = 0;
      {
#line 1357
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1357
        if (! ((int )Inp[i___0] != 0)) {
#line 1357
          goto while_break___0;
        }
        {
#line 1358
        tmp___48 = checkmove(Inp + i___0, & m___2);
        }
#line 1358
        if (tmp___48) {
#line 1358
          f = 1;
#line 1358
          found ++;
#line 1358
          goto while_break___0;
        }
#line 1357
        i___0 ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 1360
      if (f) {
        {
#line 1360
        printf((char const   */* __restrict  */)"[ Solution correct    ");
        }
      } else {
#line 1364
        if (entered - found == 1) {
          {
#line 1365
          nf = fopen((char const   */* __restrict  */)(filename), (char const   */* __restrict  */)"w");
          }
        } else {
          {
#line 1366
          nf = fopen((char const   */* __restrict  */)(filename), (char const   */* __restrict  */)"a");
          }
        }
#line 1367
        if ((unsigned long )nf != (unsigned long )((void *)0)) {
          {
#line 1369
          fputs((char const   */* __restrict  */)(Inp), (FILE */* __restrict  */)nf);
#line 1370
          fclose(nf);
          }
        }
        {
#line 1372
        printf((char const   */* __restrict  */)"[ Solution incorrect  ");
        }
      }
      {
#line 1375
      printf((char const   */* __restrict  */)" %i.%02i%%, %i/%i ]\n", (found * 100) / entered,
             ((found * 10000) / entered) % 100, found, entered);
#line 1381
      no_prompt = 1;
      }
    }
#line 1383
    Inp[0] = (char )'\000';
#line 1383
    return (1);
  }
#line 1387
  if (Flag.ponder >= 2) {
    {
#line 1389
    tmp___51 = sandex(Inp, Pm, Pn);
#line 1389
    pm = tmp___51;
    }
#line 1391
    if ((unsigned long )pm != (unsigned long )((void *)0)) {
#line 1392
      if ((int )pm->from == (int )Pondermove.from) {
#line 1392
        if ((int )pm->to == (int )Pondermove.to) {
#line 1392
          if ((int )pm->in1 == (int )Pondermove.in1) {
#line 1392
            if ((int )pm->in2 == (int )Pondermove.in2) {
#line 1392
              if ((int )pm->in2a == (int )Pondermove.in2a) {
#line 1392
                if ((int )pm->special == (int )Pondermove.special) {
                  {
#line 1399
                  Flag.ponder = 1;
#line 1400
                  tmp___52 = l_iterate();
                  }
#line 1400
                  if (tmp___52) {
#line 1402
                    if (! Flag.polling) {
                      {
#line 1402
                      signal(2, & interrupt);
                      }
                    }
                  } else {
#line 1400
                    Abort = 2;
                  }
#line 1403
                  Inp[0] = (char )'\000';
#line 1403
                  return (0);
                }
              }
            }
          }
        }
      }
    }
#line 1405
    Abort = 1;
#line 1405
    return (0);
  }
  {
#line 1408
  tmp___57 = terminal();
  }
#line 1408
  if (tmp___57 < 2) {
#line 1411
    if (Color == 1) {
#line 1411
      tmp___53 = (int )L[1].next;
    } else {
#line 1411
      tmp___53 = (int )L[2].next;
    }
    {
#line 1411
    tmp___54 = attacktest(tmp___53, Color ^ 3);
#line 1411
    generate_legal_moves(m___3, & n___2, tmp___54);
#line 1412
    tmp___55 = sandex(Inp, m___3, n___2);
#line 1412
    sd = tmp___55;
    }
#line 1412
    if ((unsigned long )sd != (unsigned long )((void *)0)) {
#line 1412
      i___1 = (int )(sd - m___3);
    } else {
#line 1412
      i___1 = n___2;
    }
#line 1413
    if (i___1 != n___2) {
      {
#line 1415
      printf((char const   */* __restrict  */)"\nyour move is ");
#line 1416
      printm(m___3[i___1], (char *)((void *)0));
#line 1416
      puts("");
#line 1417
      do_move(m___3 + i___1);
#line 1418
      tmp___56 = terminal();
      }
      {
#line 1420
      if (tmp___56 == 1) {
#line 1420
        goto case_1;
      }
#line 1421
      if (tmp___56 == 2) {
#line 1421
        goto case_2;
      }
#line 1422
      if (tmp___56 == 3) {
#line 1422
        goto case_3;
      }
#line 1418
      goto switch_break;
      case_1: /* CIL Label */ 
      {
#line 1420
      puts("1/2-1/2 {Drawn game}");
      }
#line 1420
      goto switch_break;
      case_2: /* CIL Label */ 
      {
#line 1421
      puts("1/2-1/2 {Stalemate}");
      }
#line 1421
      goto switch_break;
      case_3: /* CIL Label */ 
#line 1423
      if (Color == 1) {
        {
#line 1424
        puts("0-1 {Black mates}");
        }
      } else {
        {
#line 1426
        puts("1-0 {White mates}");
        }
      }
      switch_break: /* CIL Label */ ;
      }
#line 1428
      Inp[0] = (char )'\000';
#line 1428
      return (1);
    }
  }
  {
#line 1434
  tmp___58 = strchr((char const   *)(Inp), '\n');
#line 1434
  c = tmp___58;
  }
#line 1434
  if ((unsigned long )c != (unsigned long )((void *)0)) {
#line 1434
    *c = (char )'\000';
  } else {
#line 1434
    Inp[0] = (char )'\000';
  }
  {
#line 1435
  printf((char const   */* __restrict  */)"Illegal move: %s\n", Inp);
#line 1436
  Inp[0] = (char )'\000';
  }
#line 1438
  return (1);
}
}
#line 1472 "/home/wheatley/newnew/temp/phalanx-22+d051004/io.c"
static int resign  =    0;
#line 1443 "/home/wheatley/newnew/temp/phalanx-22+d051004/io.c"
void shell(void) 
{ 
  tmove m___1 ;
  int ter ;
  int i ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 1446
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1446
    tmp___3 = command();
    }
#line 1446
    if (! tmp___3) {
#line 1446
      goto while_break;
    }
    {
#line 1448
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1448
      if (Flag.machine_color & Color) {
        {
#line 1448
        tmp___2 = terminal();
        }
#line 1448
        if (! (tmp___2 < 2)) {
#line 1448
          goto while_break___0;
        }
      } else {
#line 1448
        goto while_break___0;
      }
      {
#line 1451
      m___1 = root_search();
      }
#line 1453
      if (Flag.analyze) {
        {
#line 1454
        undo_move(& m___1);
#line 1454
        Flag.machine_color = Color ^ 3;
        }
#line 1454
        goto while_continue___0;
      }
#line 1456
      if (Flag.ponder >= 2) {
        {
#line 1458
        Flag.ponder = 1;
#line 1459
        undo_move(& m___1);
#line 1460
        undo_move(& Pondermove);
        }
#line 1461
        goto while_continue___0;
      }
#line 1464
      if (Flag.machine_color == 3) {
#line 1464
        if (Abort == 1) {
#line 1465
          Flag.machine_color = 0;
        }
      }
#line 1470
      if (Flag.resign != 0) {
#line 1474
        if ((int )m___1.value < - Flag.resign) {
#line 1474
          if (Counter > 20) {
#line 1475
            resign ++;
          } else {
#line 1475
            resign = 0;
          }
        } else {
#line 1475
          resign = 0;
        }
#line 1477
        if (resign > 3) {
#line 1477
          if (Otim > 2000L) {
#line 1477
            if (Otim + (long )(Flag.increment * 900U) > 9000L) {
#line 1483
              if (Flag.xboard) {
                {
#line 1484
                puts("tellics resign");
                }
              }
#line 1485
              if (Color == 1) {
                {
#line 1486
                puts("1-0 {Black resigns}");
                }
              } else {
                {
#line 1487
                puts("0-1 {White resigns}");
                }
              }
            }
          }
        }
      }
      {
#line 1491
      printf((char const   */* __restrict  */)"my move is ");
#line 1491
      printm(m___1, (char *)((void *)0));
      }
#line 1492
      if (Flag.xboard) {
        {
#line 1493
        printf((char const   */* __restrict  */)"\n%i. ... ", (Counter + 1) / 2);
#line 1493
        gnuprintm(m___1);
        }
      }
      {
#line 1494
      puts("");
#line 1496
      ter = terminal();
      }
      {
#line 1498
      if (ter == 1) {
#line 1498
        goto case_1;
      }
#line 1499
      if (ter == 2) {
#line 1499
        goto case_2;
      }
#line 1500
      if (ter == 3) {
#line 1500
        goto case_3;
      }
#line 1496
      goto switch_break;
      case_1: /* CIL Label */ 
      {
#line 1498
      puts("1/2-1/2 {Drawn game}");
      }
#line 1498
      goto while_continue___0;
      case_2: /* CIL Label */ 
      {
#line 1499
      puts("1/2-1/2 {Stalemate}");
      }
#line 1499
      goto while_continue___0;
      case_3: /* CIL Label */ 
#line 1501
      if (Color == 1) {
        {
#line 1502
        puts("0-1 {Black mates}");
        }
      } else {
        {
#line 1504
        puts("1-0 {White mates}");
        }
      }
#line 1505
      goto while_continue___0;
      switch_break: /* CIL Label */ ;
      }
#line 1508
      if (Flag.ponder == 1) {
#line 1508
        if (Flag.machine_color != 3) {
#line 1508
          if (ter < 2) {
#line 1508
            if (Abort != 0) {
#line 1508
              goto _L;
            } else
#line 1508
            if (Abort != 4) {
              _L: /* CIL Label */ 
#line 1514
              Pondermove = PV[0][1];
#line 1515
              if (Color == 1) {
#line 1515
                tmp = (int )L[1].next;
              } else {
#line 1515
                tmp = (int )L[2].next;
              }
              {
#line 1515
              tmp___0 = attacktest(tmp, Color ^ 3);
#line 1515
              generate_legal_moves(Pm, & Pn, tmp___0);
#line 1517
              i = 0;
              }
              {
#line 1517
              while (1) {
                while_continue___1: /* CIL Label */ ;
#line 1517
                if (! (i != Pn)) {
#line 1517
                  goto while_break___1;
                }
#line 1518
                if ((int )Pondermove.from == (int )Pm[i].from) {
#line 1518
                  if ((int )Pondermove.to == (int )Pm[i].to) {
#line 1518
                    if ((int )Pondermove.in1 == (int )Pm[i].in1) {
#line 1518
                      if ((int )Pondermove.in2a == (int )Pm[i].in2a) {
#line 1521
                        goto while_break___1;
                      }
                    }
                  }
                }
#line 1517
                i ++;
              }
              while_break___1: /* CIL Label */ ;
              }
#line 1523
              if (i == Pn) {
#line 1525
                if (Flag.post) {
                  {
#line 1527
                  puts("No move to ponder from PV.");
#line 1528
                  puts("Looking for a move to ponder.");
                  }
                }
#line 1531
                if (Bookout < 4) {
                  {
#line 1532
                  i = bookmove(Pm, Pn);
                  }
                } else
#line 1531
                if (Counter < 10) {
                  {
#line 1532
                  i = bookmove(Pm, Pn);
                  }
                } else {
#line 1534
                  i = -1;
                }
#line 1536
                if (i != -1) {
#line 1538
                  Pondermove = Pm[i];
#line 1539
                  if (Flag.post) {
                    {
#line 1540
                    puts("Found in book.");
                    }
                  }
                } else {
#line 1544
                  if (Flag.post) {
                    {
#line 1545
                    puts("Trying search.");
                    }
                  }
                  {
#line 1546
                  Depth = -100;
#line 1547
                  NoAbort = 1;
#line 1548
                  Ply = 1;
#line 1549
                  search(Pm, Pn, -30000, 30000);
#line 1550
                  NoAbort = 0;
#line 1551
                  Pondermove = PV[1][1];
                  }
                }
#line 1553
                i = 0;
                {
#line 1553
                while (1) {
                  while_continue___2: /* CIL Label */ ;
#line 1553
                  if (! (i != Pn)) {
#line 1553
                    goto while_break___2;
                  }
#line 1554
                  if ((int )Pondermove.from == (int )Pm[i].from) {
#line 1554
                    if ((int )Pondermove.to == (int )Pm[i].to) {
#line 1554
                      if ((int )Pondermove.in1 == (int )Pm[i].in1) {
#line 1554
                        if ((int )Pondermove.in2a == (int )Pm[i].in2a) {
#line 1558
                          goto while_break___2;
                        }
                      }
                    }
                  }
#line 1553
                  i ++;
                }
                while_break___2: /* CIL Label */ ;
                }
#line 1559
                if (i == Pn) {
#line 1560
                  if (Flag.post) {
                    {
#line 1561
                    puts("No move found.  A bug?");
                    }
                  }
#line 1562
                  i = 0;
                } else
#line 1565
                if (Flag.post) {
                  {
#line 1565
                  puts("Done.");
                  }
                }
              }
#line 1568
              if (i != Pn) {
                {
#line 1573
                do_move(& Pondermove);
#line 1574
                tmp___1 = terminal();
                }
#line 1574
                if (tmp___1 > 1) {
                  {
#line 1575
                  undo_move(& Pondermove);
                  }
                } else {
#line 1578
                  if (Flag.post) {
                    {
#line 1580
                    printf((char const   */* __restrict  */)"Hint: ");
#line 1581
                    printm(Pondermove, (char *)((void *)0));
#line 1582
                    puts("");
                    }
                  }
#line 1584
                  Flag.ponder = 2;
                }
              }
            }
          }
        }
      }
#line 1588
      goto while_continue___0;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1592
  return;
}
}
#line 147 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 189 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) clock_t ( __attribute__((__leaf__)) clock)(void) ;
#line 71 "/usr/include/x86_64-linux-gnu/sys/time.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) gettimeofday)(struct timeval * __restrict  __tv ,
                                                                                                   __timezone_ptr_t __tz ) ;
#line 422 "/home/wheatley/newnew/temp/phalanx-22+d051004/phalanx.h"
int EasyMove ;
#line 517
void l_startsearch(void) ;
#line 3 "/home/wheatley/newnew/temp/phalanx-22+d051004/levels.c"
long T1  ;
#line 3 "/home/wheatley/newnew/temp/phalanx-22+d051004/levels.c"
long T2  ;
#line 5 "/home/wheatley/newnew/temp/phalanx-22+d051004/levels.c"
long Time  =    60000L;
#line 6 "/home/wheatley/newnew/temp/phalanx-22+d051004/levels.c"
long Otim  =    60000L;
#line 10 "/home/wheatley/newnew/temp/phalanx-22+d051004/levels.c"
long ptime(void) 
{ 
  clock_t tmp ;
  struct timeval t ;

  {
#line 12
  if (Flag.easy) {
#line 12
    return ((long )Nodes);
  } else
#line 14
  if (Flag.cpu) {
    {
#line 14
    tmp = clock();
    }
#line 14
    return ((long )(((double )tmp * (double )100) / (double )1000000L));
  } else {
    {
#line 21
    gettimeofday((struct timeval */* __restrict  */)(& t), (__timezone_ptr_t )((void *)0));
    }
#line 22
    return (t.tv_sec * 100L + t.tv_usec / 10000L);
  }
}
}
#line 29 "/home/wheatley/newnew/temp/phalanx-22+d051004/levels.c"
void l_level(char *l___0 ) 
{ 
  int moves ;
  int seconds ;
  int minutes ;
  int increment ;
  unsigned short const   **tmp ;
  unsigned short const   **tmp___0 ;
  unsigned short const   **tmp___1 ;
  unsigned short const   **tmp___2 ;

  {
  {
#line 33
  while (1) {
    while_continue: /* CIL Label */ ;
#line 33
    if (! ((int )*l___0 == 32)) {
#line 33
      goto while_break;
    }
#line 33
    l___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 34
  moves = atoi((char const   *)l___0);
  }
  {
#line 36
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 36
    tmp = __ctype_b_loc();
    }
#line 36
    if (! ((int const   )*(*tmp + (int )*l___0) & 2048)) {
#line 36
      goto while_break___0;
    }
#line 36
    l___0 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 37
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 37
    if (! ((int )*l___0 == 32)) {
#line 37
      goto while_break___1;
    }
#line 37
    l___0 ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 39
  if ((int )*l___0 == 10) {
#line 39
    goto _L;
  } else
#line 39
  if ((int )*l___0 == 0) {
    _L: /* CIL Label */ 
#line 40
    if (! Flag.easy) {
      {
#line 42
      printf((char const   */* __restrict  */)"fixed time %i seconds\n", moves);
#line 43
      Flag.level = (tlevel )2;
#line 43
      Flag.centiseconds = moves * 100;
      }
#line 44
      return;
    }
  }
  {
#line 47
  minutes = atoi((char const   *)l___0);
  }
  {
#line 49
  while (1) {
    while_continue___2: /* CIL Label */ ;
    {
#line 49
    tmp___0 = __ctype_b_loc();
    }
#line 49
    if (! ((int const   )*(*tmp___0 + (int )*l___0) & 2048)) {
#line 49
      goto while_break___2;
    }
#line 49
    l___0 ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 50
  if ((int )*l___0 == 58) {
    {
#line 52
    l___0 ++;
#line 53
    seconds = atoi((char const   *)l___0);
    }
    {
#line 54
    while (1) {
      while_continue___3: /* CIL Label */ ;
      {
#line 54
      tmp___1 = __ctype_b_loc();
      }
#line 54
      if (! ((int const   )*(*tmp___1 + (int )*l___0) & 2048)) {
#line 54
        goto while_break___3;
      }
#line 54
      l___0 ++;
    }
    while_break___3: /* CIL Label */ ;
    }
  } else {
#line 56
    seconds = 0;
  }
  {
#line 58
  while (1) {
    while_continue___4: /* CIL Label */ ;
    {
#line 58
    tmp___2 = __ctype_b_loc();
    }
#line 58
    if (! ((int const   )*(*tmp___2 + (int )*l___0) & 2048)) {
#line 58
      goto while_break___4;
    }
#line 58
    l___0 ++;
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 59
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 59
    if (! ((int )*l___0 == 32)) {
#line 59
      goto while_break___5;
    }
#line 59
    l___0 ++;
  }
  while_break___5: /* CIL Label */ ;
  }
  {
#line 60
  increment = atoi((char const   *)l___0);
  }
#line 62
  if (moves == 0) {
    {
#line 63
    printf((char const   */* __restrict  */)"level: all moves in %i:%02i, increment %i seconds\n",
           minutes, seconds, increment);
    }
  } else {
    {
#line 67
    printf((char const   */* __restrict  */)"level: %i moves in %i:%02i, increment %i seconds\n",
           moves, minutes, seconds, increment);
    }
  }
#line 71
  if (Flag.easy) {
#line 73
    if (moves == 0) {
#line 73
      moves = 80;
    }
#line 74
    Flag.level = (tlevel )2;
#line 75
    Flag.centiseconds = (increment + (minutes * 60) / moves) * (150 - (int )Flag.easy);
#line 78
    if (Flag.post) {
      {
#line 79
      printf((char const   */* __restrict  */)"setting avg time to %i cs\n", Flag.centiseconds);
      }
    }
  } else {
#line 83
    Flag.level = (tlevel )0;
#line 84
    Flag.moves = (unsigned int )moves;
#line 85
    Flag.centiseconds = minutes * 6000 + seconds * 100;
#line 86
    Flag.increment = (unsigned int )increment;
#line 87
    Time = (long )Flag.centiseconds;
  }
#line 89
  return;
}
}
#line 93 "/home/wheatley/newnew/temp/phalanx-22+d051004/levels.c"
void l_startsearch(void) 
{ 
  int moves ;

  {
  {
#line 96
  T1 = ptime();
  }
  {
#line 100
  if ((unsigned int )Flag.level == 0U) {
#line 100
    goto case_0;
  }
#line 161
  if ((unsigned int )Flag.level == 1U) {
#line 161
    goto case_1;
  }
#line 164
  goto switch_default;
  case_0: /* CIL Label */ 
#line 101
  if (Flag.moves > 0U) {
#line 101
    moves = (int )(2U * Flag.moves);
  } else {
#line 104
    moves = Counter + ((int )G[Counter].mtrl + (int )G[Counter].xmtrl) / 800;
#line 106
    if (Counter < 120) {
#line 107
      moves += 60 - Counter / 4;
    } else {
#line 108
      moves += 30;
    }
  }
#line 111
  if (Flag.increment == 0U) {
#line 111
    T2 = 0L;
  } else
#line 113
  if (Time / (long )Flag.increment >= 1600L) {
#line 114
    T2 = (long )(Flag.increment * 60U);
  } else
#line 116
  if (Time / (long )Flag.increment <= 400L) {
#line 117
    T2 = (long )(Flag.increment * 10U);
  } else {
#line 119
    T2 = ((long )Flag.increment * ((Time / (long )Flag.increment) / 8L - 20L)) / 3L;
  }
#line 121
  if (Flag.post) {
#line 121
    if (T2) {
#line 121
      if (Flag.xboard < 2) {
        {
#line 122
        printf((char const   */* __restrict  */)"    -> increment adds %g s to soft time limit\n",
               (double )((float )T2 / (float )100));
        }
      }
    }
  }
#line 125
  T2 += Time / (long )((moves - Counter % moves) + 4);
#line 127
  if (Flag.ponder) {
#line 127
    T2 += T2 / 8L;
  }
#line 129
  if (Flag.increment == 0U) {
#line 129
    if ((unsigned int )Flag.level == 0U) {
#line 131
      if (Time < 1500L) {
#line 131
        T2 -= T2 / 2L;
      } else
#line 132
      if (Time < 6000L) {
#line 132
        T2 -= T2 / 4L;
      }
    }
  }
#line 135
  if (Flag.post) {
#line 135
    if (Flag.xboard < 2) {
      {
#line 136
      printf((char const   */* __restrict  */)"    -> soft time limit %g s\n", (double )((float )T2 / (float )100));
      }
    }
  }
#line 140
  if (Time < 1500L) {
#line 140
    Flag.centiseconds = (int )((Time / (long )(moves + 1)) * 3L);
  } else
#line 141
  if (Time < 3000L) {
#line 141
    Flag.centiseconds = (int )((Time / (long )(moves + 1)) * 6L);
  } else
#line 142
  if (Time < 6000L) {
#line 142
    Flag.centiseconds = (int )((Time / (long )(moves + 1)) * 12L);
  } else {
#line 143
    Flag.centiseconds = (int )((Time / (long )(moves + 1)) * 18L);
  }
#line 145
  Flag.centiseconds = (int )((unsigned int )Flag.centiseconds + 400U * Flag.increment);
#line 147
  if ((long )Flag.centiseconds > Time - (long )(Flag.increment * 100U)) {
#line 149
    if (Time > (long )(200U * Flag.increment)) {
#line 150
      Flag.centiseconds = (int )(Time - (long )(100U * Flag.increment));
    } else {
#line 151
      Flag.centiseconds = (int )(Time / 2L);
    }
  }
#line 154
  if (Flag.centiseconds < 25) {
#line 154
    Flag.centiseconds = 25;
  }
#line 156
  if (Flag.post) {
#line 156
    if (Flag.xboard < 2) {
      {
#line 157
      printf((char const   */* __restrict  */)"    -> hard time limit %g s\n", (double )((float )Flag.centiseconds / (float )100));
      }
    }
  }
#line 160
  goto switch_break;
  case_1: /* CIL Label */ 
#line 162
  T2 = (long )(Flag.centiseconds / 3);
#line 163
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 164
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 167
  if (T2 < 1L) {
#line 167
    T2 = 1L;
  }
#line 168
  return;
}
}
#line 172 "/home/wheatley/newnew/temp/phalanx-22+d051004/levels.c"
int l_iterate(void) 
{ 
  long t ;
  long tmp ;

  {
#line 174
  if ((unsigned int )Flag.level == 3U) {
#line 176
    return (Depth < Flag.depth);
  } else
#line 179
  if ((unsigned int )Flag.level == 1U) {
#line 179
    goto _L;
  } else
#line 179
  if ((unsigned int )Flag.level == 0U) {
    _L: /* CIL Label */ 
    {
#line 181
    tmp = ptime();
#line 181
    t = tmp;
    }
    {
#line 184
    if (EasyMove == 1) {
#line 184
      goto case_1;
    }
#line 185
    if (EasyMove == 2) {
#line 185
      goto case_2;
    }
#line 186
    goto switch_default;
    case_1: /* CIL Label */ 
#line 184
    return (t <= T1 + T2 / 3L);
    case_2: /* CIL Label */ 
#line 185
    return (t <= T1 + T2 / 6L);
    switch_default: /* CIL Label */ 
#line 187
    if (Turns == 0) {
#line 187
      return (t <= T1 + T2);
    } else {
#line 188
      return (t <= T1 + (T2 * (long )(8 + Turns)) / 8L);
    }
    switch_break: /* CIL Label */ ;
    }
  } else {
#line 192
    return (1);
  }
}
}
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 66
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 403 "/home/wheatley/newnew/temp/phalanx-22+d051004/phalanx.h"
tknow Wknow  ;
#line 403 "/home/wheatley/newnew/temp/phalanx-22+d051004/phalanx.h"
tknow Bknow  ;
#line 421 "/home/wheatley/newnew/temp/phalanx-22+d051004/phalanx.h"
int Scoring  ;
#line 431 "/home/wheatley/newnew/temp/phalanx-22+d051004/phalanx.h"
unsigned short P[120]  ;
#line 28 "/home/wheatley/newnew/temp/phalanx-22+d051004/static.c"
static int const   isofile[10]  = 
#line 28 "/home/wheatley/newnew/temp/phalanx-22+d051004/static.c"
  {      (int const   )0,      (int const   )-4,      (int const   )-6,      (int const   )-8, 
        (int const   )-10,      (int const   )-10,      (int const   )-8,      (int const   )-6, 
        (int const   )-4,      (int const   )0};
#line 33 "/home/wheatley/newnew/temp/phalanx-22+d051004/static.c"
signed char sqcolor_[80]  = 
#line 33
  {      (signed char)0,      (signed char)2,      (signed char)1,      (signed char)2, 
        (signed char)1,      (signed char)2,      (signed char)1,      (signed char)2, 
        (signed char)1,      (signed char)0,      (signed char)0,      (signed char)1, 
        (signed char)2,      (signed char)1,      (signed char)2,      (signed char)1, 
        (signed char)2,      (signed char)1,      (signed char)2,      (signed char)0, 
        (signed char)0,      (signed char)2,      (signed char)1,      (signed char)2, 
        (signed char)1,      (signed char)2,      (signed char)1,      (signed char)2, 
        (signed char)1,      (signed char)0,      (signed char)0,      (signed char)1, 
        (signed char)2,      (signed char)1,      (signed char)2,      (signed char)1, 
        (signed char)2,      (signed char)1,      (signed char)2,      (signed char)0, 
        (signed char)0,      (signed char)2,      (signed char)1,      (signed char)2, 
        (signed char)1,      (signed char)2,      (signed char)1,      (signed char)2, 
        (signed char)1,      (signed char)0,      (signed char)0,      (signed char)1, 
        (signed char)2,      (signed char)1,      (signed char)2,      (signed char)1, 
        (signed char)2,      (signed char)1,      (signed char)2,      (signed char)0, 
        (signed char)0,      (signed char)2,      (signed char)1,      (signed char)2, 
        (signed char)1,      (signed char)2,      (signed char)1,      (signed char)2, 
        (signed char)1,      (signed char)0,      (signed char)0,      (signed char)1, 
        (signed char)2,      (signed char)1,      (signed char)2,      (signed char)1, 
        (signed char)2,      (signed char)1,      (signed char)2,      (signed char)0};
#line 43 "/home/wheatley/newnew/temp/phalanx-22+d051004/static.c"
signed char *sqcolor  =    sqcolor_ - 20;
#line 46 "/home/wheatley/newnew/temp/phalanx-22+d051004/static.c"
int pmpb_[80]  = 
#line 46
  {      0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      2, 
        3,      4,      6,      6, 
        4,      3,      2,      0, 
        0,      0,      1,      5, 
        8,      8,      5,      1, 
        0,      0,      0,      0, 
        1,      6,      16,      12, 
        6,      1,      0,      0, 
        0,      1,      5,      7, 
        16,      12,      7,      5, 
        1,      0,      0,      5, 
        8,      10,      16,      12, 
        10,      8,      5,      0, 
        0,      5,      5,      5, 
        6,      6,      5,      5, 
        5,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0};
#line 56 "/home/wheatley/newnew/temp/phalanx-22+d051004/static.c"
int const   *pmpb  =    (int const   *)(pmpb_ - 20);
#line 59 "/home/wheatley/newnew/temp/phalanx-22+d051004/static.c"
int qstormtable_[80]  = 
#line 59
  {      0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      -12, 
        -12,      -12,      0,      0, 
        10,      10,      10,      0, 
        0,      -9,      -10,      -9, 
        0,      6,      8,      8, 
        8,      0,      0,      -6, 
        -6,      -6,      6,      10, 
        4,      4,      4,      0, 
        0,      -3,      -3,      -3, 
        10,      4,      0,      0, 
        0,      0,      0,      0, 
        0,      5,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0};
#line 69 "/home/wheatley/newnew/temp/phalanx-22+d051004/static.c"
int const   *qstormtable  =    (int const   *)(qstormtable_ - 20);
#line 72 "/home/wheatley/newnew/temp/phalanx-22+d051004/static.c"
int kstormtable_[80]  = 
#line 72
  {      0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      10, 
        10,      10,      0,      0, 
        -12,      -12,      -12,      0, 
        0,      8,      8,      8, 
        6,      0,      -9,      -10, 
        -9,      0,      0,      4, 
        4,      4,      10,      6, 
        -6,      -6,      -6,      0, 
        0,      0,      0,      0, 
        4,      10,      -3,      -3, 
        -3,      0,      0,      0, 
        0,      0,      0,      0, 
        5,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0};
#line 82 "/home/wheatley/newnew/temp/phalanx-22+d051004/static.c"
int const   *kstormtable  =    (int const   *)(kstormtable_ - 20);
#line 85 "/home/wheatley/newnew/temp/phalanx-22+d051004/static.c"
int nmpb_[80]  = 
#line 85
  {      0,      -16,      -10,      -8, 
        -8,      -8,      -8,      -10, 
        -16,      0,      0,      -10, 
        -3,      1,      3,      3, 
        1,      -3,      -10,      0, 
        0,      -8,      1,      5, 
        5,      5,      5,      1, 
        -8,      0,      0,      -8, 
        2,      5,      8,      8, 
        5,      2,      -8,      0, 
        0,      -8,      4,      6, 
        10,      10,      6,      4, 
        -8,      0,      0,      -8, 
        4,      7,      8,      8, 
        7,      4,      -8,      0, 
        0,      -10,      0,      3, 
        4,      4,      3,      0, 
        -10,      0,      0,      -16, 
        -10,      -8,      -8,      -8, 
        -8,      -10,      -16,      0};
#line 95 "/home/wheatley/newnew/temp/phalanx-22+d051004/static.c"
int const   *nmpb  =    (int const   *)(nmpb_ - 20);
#line 98 "/home/wheatley/newnew/temp/phalanx-22+d051004/static.c"
int bmpb_[80]  = 
#line 98
  {      0,      10,      8,      6, 
        4,      4,      6,      8, 
        10,      0,      0,      8, 
        12,      8,      9,      9, 
        8,      12,      8,      0, 
        0,      10,      10,      11, 
        11,      11,      11,      10, 
        10,      0,      0,      11, 
        12,      13,      14,      14, 
        13,      12,      11,      0, 
        0,      12,      13,      15, 
        17,      17,      15,      14, 
        12,      0,      0,      13, 
        14,      16,      16,      16, 
        16,      14,      13,      0, 
        0,      11,      14,      12, 
        12,      12,      12,      14, 
        11,      0,      0,      13, 
        10,      10,      10,      10, 
        10,      10,      13,      0};
#line 108 "/home/wheatley/newnew/temp/phalanx-22+d051004/static.c"
int const   *bmpb  =    (int const   *)(bmpb_ - 20);
#line 111 "/home/wheatley/newnew/temp/phalanx-22+d051004/static.c"
int bepb_[80]  = 
#line 111
  {      0,      24,      21,      18, 
        15,      15,      18,      21, 
        24,      0,      0,      21, 
        24,      21,      18,      18, 
        21,      24,      21,      0, 
        0,      18,      21,      24, 
        24,      24,      24,      21, 
        18,      0,      0,      15, 
        18,      24,      30,      30, 
        24,      18,      15,      0, 
        0,      15,      18,      24, 
        30,      30,      24,      18, 
        15,      0,      0,      18, 
        21,      24,      24,      24, 
        24,      21,      18,      0, 
        0,      21,      24,      21, 
        18,      18,      21,      24, 
        21,      0,      0,      24, 
        21,      18,      15,      15, 
        18,      21,      24,      0};
#line 121 "/home/wheatley/newnew/temp/phalanx-22+d051004/static.c"
int const   *bepb  =    (int const   *)(bepb_ - 20);
#line 124 "/home/wheatley/newnew/temp/phalanx-22+d051004/static.c"
int rmpb_[80]  = 
#line 124
  {      0,      0,      1,      2, 
        3,      3,      2,      1, 
        0,      0,      0,      0, 
        1,      2,      3,      3, 
        2,      1,      0,      0, 
        0,      0,      1,      2, 
        3,      3,      2,      1, 
        0,      0,      0,      0, 
        1,      2,      3,      3, 
        2,      1,      0,      0, 
        0,      0,      1,      2, 
        3,      3,      2,      1, 
        0,      0,      0,      7, 
        8,      9,      10,      10, 
        9,      8,      7,      0, 
        0,      10,      11,      12, 
        13,      13,      12,      11, 
        10,      0,      0,      10, 
        11,      12,      13,      13, 
        12,      11,      10,      0};
#line 134 "/home/wheatley/newnew/temp/phalanx-22+d051004/static.c"
int const   *rmpb  =    (int const   *)(rmpb_ - 20);
#line 137 "/home/wheatley/newnew/temp/phalanx-22+d051004/static.c"
int qmpb_[80]  = 
#line 137
  {      0,      0,      1,      2, 
        3,      3,      2,      1, 
        0,      0,      0,      4, 
        5,      6,      7,      7, 
        6,      5,      4,      0, 
        0,      5,      6,      7, 
        8,      8,      7,      6, 
        5,      0,      0,      6, 
        7,      8,      9,      9, 
        8,      7,      6,      0, 
        0,      8,      9,      10, 
        11,      11,      10,      9, 
        8,      0,      0,      10, 
        11,      12,      13,      13, 
        12,      11,      10,      0, 
        0,      8,      10,      11, 
        12,      12,      11,      10, 
        8,      0,      0,      5, 
        6,      7,      8,      8, 
        7,      6,      5,      0};
#line 147 "/home/wheatley/newnew/temp/phalanx-22+d051004/static.c"
int const   *qmpb  =    (int const   *)(qmpb_ - 20);
#line 150 "/home/wheatley/newnew/temp/phalanx-22+d051004/static.c"
int kmpb_[80]  = 
#line 150
  {      0,      0,      0,      -3, 
        -6,      -6,      -3,      0, 
        0,      0,      0,      -2, 
        -4,      -8,      -12,      -12, 
        -8,      -4,      -2,      0, 
        0,      -6,      -12,      -20, 
        -25,      -25,      -20,      -12, 
        -6,      0,      0,      -15, 
        -20,      -30,      -40,      -40, 
        -30,      -20,      -15,      0, 
        0,      -30,      -40,      -50, 
        -60,      -60,      -50,      -40, 
        -30,      0,      0,      -35, 
        -45,      -55,      -65,      -65, 
        -55,      -45,      -35,      0, 
        0,      -30,      -40,      -50, 
        -60,      -60,      -50,      -40, 
        -30,      0,      0,      -20, 
        -30,      -40,      -50,      -50, 
        -40,      -30,      -20,      0};
#line 160 "/home/wheatley/newnew/temp/phalanx-22+d051004/static.c"
int const   *kmpb  =    (int const   *)(kmpb_ - 20);
#line 163 "/home/wheatley/newnew/temp/phalanx-22+d051004/static.c"
int kepb_[80]  = 
#line 163
  {      0,      -5,      5,      10, 
        15,      15,      10,      5, 
        -5,      0,      0,      6, 
        11,      16,      21,      21, 
        16,      11,      6,      0, 
        0,      12,      17,      22, 
        27,      27,      22,      17, 
        12,      0,      0,      18, 
        24,      30,      34,      34, 
        28,      24,      18,      0, 
        0,      20,      27,      33, 
        48,      48,      33,      27, 
        20,      0,      0,      16, 
        25,      34,      40,      40, 
        34,      25,      16,      0, 
        0,      9,      20,      28, 
        35,      35,      28,      20, 
        9,      0,      0,      3, 
        10,      17,      24,      24, 
        17,      10,      3,      0};
#line 173 "/home/wheatley/newnew/temp/phalanx-22+d051004/static.c"
int const   *kepb  =    (int const   *)(kepb_ - 20);
#line 176 "/home/wheatley/newnew/temp/phalanx-22+d051004/static.c"
int c_bonus_[80]  = 
#line 176
  {      0,      -16,      -10,      -6, 
        -2,      -2,      -6,      -10, 
        -16,      0,      0,      -9, 
        -3,      1,      4,      4, 
        1,      -3,      -9,      0, 
        0,      -4,      1,      5, 
        8,      8,      5,      1, 
        -4,      0,      0,      0, 
        4,      8,      12,      12, 
        8,      4,      0,      0, 
        0,      1,      5,      9, 
        13,      13,      9,      5, 
        1,      0,      0,      -2, 
        2,      6,      9,      9, 
        6,      2,      -2,      0, 
        0,      -6,      -1,      2, 
        5,      5,      2,      -1, 
        -6,      0,      0,      -9, 
        -6,      -3,      0,      0, 
        -3,      -6,      -9,      0};
#line 186 "/home/wheatley/newnew/temp/phalanx-22+d051004/static.c"
int *c_bonus  =    c_bonus_ - 20;
#line 188 "/home/wheatley/newnew/temp/phalanx-22+d051004/static.c"
int outpost_[80]  = 
#line 188
  {      0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      1,      1, 
        0,      0,      0,      0, 
        0,      0,      0,      1, 
        2,      2,      1,      0, 
        0,      0,      0,      0, 
        1,      2,      3,      3, 
        2,      1,      0,      0, 
        0,      0,      0,      0, 
        1,      1,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0};
#line 198 "/home/wheatley/newnew/temp/phalanx-22+d051004/static.c"
int const   *outpost  =    (int const   *)(outpost_ - 20);
#line 200 "/home/wheatley/newnew/temp/phalanx-22+d051004/static.c"
int B_mobi[20]  = 
#line 200
  {      -36,      -28,      -20,      -14, 
        -6,      -2,      1,      2, 
        3,      4,      5,      6, 
        7,      8,      8,      8, 
        8,      8,      8,      8};
#line 202 "/home/wheatley/newnew/temp/phalanx-22+d051004/static.c"
int R_mobi[16]  = 
#line 202
  {      -9,      -5,      -2,      0, 
        2,      4,      5,      6, 
        6,      6,      6,      6, 
        6,      6,      6,      6};
#line 208 "/home/wheatley/newnew/temp/phalanx-22+d051004/static.c"
int *pf  ;
#line 208 "/home/wheatley/newnew/temp/phalanx-22+d051004/static.c"
int *xpf  ;
#line 208 "/home/wheatley/newnew/temp/phalanx-22+d051004/static.c"
int wpf[10]  ;
#line 208 "/home/wheatley/newnew/temp/phalanx-22+d051004/static.c"
int bpf[10]  ;
#line 238 "/home/wheatley/newnew/temp/phalanx-22+d051004/static.c"
static int *l  ;
#line 238 "/home/wheatley/newnew/temp/phalanx-22+d051004/static.c"
static int wl[34]  ;
#line 238 "/home/wheatley/newnew/temp/phalanx-22+d051004/static.c"
static int bl[34]  ;
#line 239 "/home/wheatley/newnew/temp/phalanx-22+d051004/static.c"
static int n___0  ;
#line 239 "/home/wheatley/newnew/temp/phalanx-22+d051004/static.c"
static int wn  ;
#line 239 "/home/wheatley/newnew/temp/phalanx-22+d051004/static.c"
static int bn  ;
#line 241 "/home/wheatley/newnew/temp/phalanx-22+d051004/static.c"
static int pin___0[32]  ;
#line 245 "/home/wheatley/newnew/temp/phalanx-22+d051004/static.c"
static tsquare mB[120]  = 
#line 245
  {      (tsquare )3,      (tsquare )3,      (tsquare )3,      (tsquare )3, 
        (tsquare )3,      (tsquare )3,      (tsquare )3,      (tsquare )3, 
        (tsquare )3,      (tsquare )3,      (tsquare )3,      (tsquare )3, 
        (tsquare )3,      (tsquare )3,      (tsquare )3,      (tsquare )3, 
        (tsquare )3,      (tsquare )3,      (tsquare )3,      (tsquare )3, 
        (tsquare )3,      (tsquare )0,      (tsquare )0,      (tsquare )0, 
        (tsquare )0,      (tsquare )0,      (tsquare )0,      (tsquare )0, 
        (tsquare )0,      (tsquare )3,      (tsquare )3,      (tsquare )0, 
        (tsquare )0,      (tsquare )0,      (tsquare )0,      (tsquare )0, 
        (tsquare )0,      (tsquare )0,      (tsquare )0,      (tsquare )3, 
        (tsquare )3,      (tsquare )0,      (tsquare )0,      (tsquare )0, 
        (tsquare )0,      (tsquare )0,      (tsquare )0,      (tsquare )0, 
        (tsquare )0,      (tsquare )3,      (tsquare )3,      (tsquare )0, 
        (tsquare )0,      (tsquare )0,      (tsquare )0,      (tsquare )0, 
        (tsquare )0,      (tsquare )0,      (tsquare )0,      (tsquare )3, 
        (tsquare )3,      (tsquare )0,      (tsquare )0,      (tsquare )0, 
        (tsquare )0,      (tsquare )0,      (tsquare )0,      (tsquare )0, 
        (tsquare )0,      (tsquare )3,      (tsquare )3,      (tsquare )0, 
        (tsquare )0,      (tsquare )0,      (tsquare )0,      (tsquare )0, 
        (tsquare )0,      (tsquare )0,      (tsquare )0,      (tsquare )3, 
        (tsquare )3,      (tsquare )0,      (tsquare )0,      (tsquare )0, 
        (tsquare )0,      (tsquare )0,      (tsquare )0,      (tsquare )0, 
        (tsquare )0,      (tsquare )3,      (tsquare )3,      (tsquare )0, 
        (tsquare )0,      (tsquare )0,      (tsquare )0,      (tsquare )0, 
        (tsquare )0,      (tsquare )0,      (tsquare )0,      (tsquare )3, 
        (tsquare )3,      (tsquare )3,      (tsquare )3,      (tsquare )3, 
        (tsquare )3,      (tsquare )3,      (tsquare )3,      (tsquare )3, 
        (tsquare )3,      (tsquare )3,      (tsquare )3,      (tsquare )3, 
        (tsquare )3,      (tsquare )3,      (tsquare )3,      (tsquare )3, 
        (tsquare )3,      (tsquare )3,      (tsquare )3,      (tsquare )3};
#line 259 "/home/wheatley/newnew/temp/phalanx-22+d051004/static.c"
static tsquare mBinit[80]  = 
#line 259
  {      (tsquare )3,      (tsquare )0,      (tsquare )0,      (tsquare )0, 
        (tsquare )0,      (tsquare )0,      (tsquare )0,      (tsquare )0, 
        (tsquare )0,      (tsquare )3,      (tsquare )3,      (tsquare )0, 
        (tsquare )0,      (tsquare )0,      (tsquare )0,      (tsquare )0, 
        (tsquare )0,      (tsquare )0,      (tsquare )0,      (tsquare )3, 
        (tsquare )3,      (tsquare )0,      (tsquare )0,      (tsquare )0, 
        (tsquare )0,      (tsquare )0,      (tsquare )0,      (tsquare )0, 
        (tsquare )0,      (tsquare )3,      (tsquare )3,      (tsquare )0, 
        (tsquare )0,      (tsquare )0,      (tsquare )0,      (tsquare )0, 
        (tsquare )0,      (tsquare )0,      (tsquare )0,      (tsquare )3, 
        (tsquare )3,      (tsquare )0,      (tsquare )0,      (tsquare )0, 
        (tsquare )0,      (tsquare )0,      (tsquare )0,      (tsquare )0, 
        (tsquare )0,      (tsquare )3,      (tsquare )3,      (tsquare )0, 
        (tsquare )0,      (tsquare )0,      (tsquare )0,      (tsquare )0, 
        (tsquare )0,      (tsquare )0,      (tsquare )0,      (tsquare )3, 
        (tsquare )3,      (tsquare )0,      (tsquare )0,      (tsquare )0, 
        (tsquare )0,      (tsquare )0,      (tsquare )0,      (tsquare )0, 
        (tsquare )0,      (tsquare )3,      (tsquare )3,      (tsquare )0, 
        (tsquare )0,      (tsquare )0,      (tsquare )0,      (tsquare )0, 
        (tsquare )0,      (tsquare )0,      (tsquare )0,      (tsquare )3};
#line 548 "/home/wheatley/newnew/temp/phalanx-22+d051004/static.c"
static unsigned int m___0[112]  = 
#line 548
  {      0U,      0U,      0U,      0U, 
        0U,      0U,      0U,      0U, 
        0U,      0U,      0U,      0U, 
        0U,      0U,      0U,      0U, 
        0U,      0U,      0U,      0U, 
        0U,      0U,      0U,      0U, 
        0U,      0U,      0U,      0U, 
        0U,      0U,      0U,      0U, 
        0U,      1U,      1U,      0U, 
        0U,      0U,      0U,      0U, 
        0U,      0U,      0U,      0U, 
        0U,      0U,      0U,      0U, 
        0U,      1U,      1U,      0U, 
        0U,      0U,      0U,      0U, 
        0U,      0U,      0U,      0U, 
        0U,      0U,      0U,      0U, 
        0U,      7U,      7U,      0U, 
        0U,      0U,      0U,      0U, 
        0U,      0U,      0U,      0U, 
        0U,      0U,      0U,      0U, 
        0U,      15U,      15U,      0U, 
        0U,      0U,      0U,      0U, 
        0U,      0U,      0U,      0U, 
        0U,      0U,      0U,      0U, 
        0U,      15U,      15U,      0U, 
        0U,      0U,      0U,      0U, 
        0U,      0U,      0U,      0U, 
        0U,      0U,      0U,      0U};
#line 888 "/home/wheatley/newnew/temp/phalanx-22+d051004/static.c"
static int const   rfip[10]  = 
#line 888
  {      (int const   )0,      (int const   )-2,      (int const   )-3,      (int const   )-4, 
        (int const   )-5,      (int const   )-5,      (int const   )-4,      (int const   )-3, 
        (int const   )-2,      (int const   )0};
#line 910 "/home/wheatley/newnew/temp/phalanx-22+d051004/static.c"
static int sq  ;
#line 922 "/home/wheatley/newnew/temp/phalanx-22+d051004/static.c"
static int const   P_advance[12]  = 
#line 922
  {      (int const   )0,      (int const   )0,      (int const   )0,      (int const   )10, 
        (int const   )15,      (int const   )25,      (int const   )40,      (int const   )60, 
        (int const   )95,      (int const   )0,      (int const   )0,      (int const   )0};
#line 1209 "/home/wheatley/newnew/temp/phalanx-22+d051004/static.c"
static int frb[12]  = 
#line 1209
  {      0,      0,      -5,      -5, 
        -2,      0,      2,      4, 
        8,      10,      10,      10};
#line 1237 "/home/wheatley/newnew/temp/phalanx-22+d051004/static.c"
static int bon[8]  = 
#line 1237
  {      5,      3,      1,      -2, 
        -2,      -2,      -2,      -2};
#line 1312 "/home/wheatley/newnew/temp/phalanx-22+d051004/static.c"
static int bon___0[16]  = 
#line 1312
  {      8,      8,      8,      7, 
        5,      3,      1,      0, 
        -1,      -2,      -3,      -4, 
        -5,      -6,      -7,      -8};
#line 1390 "/home/wheatley/newnew/temp/phalanx-22+d051004/static.c"
static int bon___1[8]  = 
#line 1390
  {      8,      8,      8,      5, 
        2,      -1,      -4,      -7};
#line 1422 "/home/wheatley/newnew/temp/phalanx-22+d051004/static.c"
static int bon___2[16]  = 
#line 1422
  {      10,      10,      10,      9, 
        7,      5,      3,      0, 
        -2,      -4,      -8,      -8, 
        -8,      -8,      -8,      -8};
#line 211 "/home/wheatley/newnew/temp/phalanx-22+d051004/static.c"
int score_position(void) 
{ 
  int i ;
  int midresult ;
  int endresult ;
  int result ;
  int whp ;
  int bhp ;
  int kp ;
  int xkp ;
  tknow *know ;
  tknow *xknow ;
  int npin ;
  tsquare *b ;
  int r ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int nn ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int i___0 ;
  int np ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int j ;
  int mobi ;
  int d ;
  int step ;
  int d___0 ;
  int step___0 ;
  int d___1 ;
  int step___1 ;
  int d___2 ;
  int j___0 ;
  int mobi___0 ;
  int d___3 ;
  int step___2 ;
  int d___4 ;
  int step___3 ;
  int d___5 ;
  int step___4 ;
  int d___6 ;
  int tmp___13 ;
  int pini ;
  int direction ;
  int d___7 ;
  int ataks ;
  int defs ;
  int ataks___0 ;
  int defs___0 ;
  int hresult ;
  tdist *kdist ;
  tdist *xkdist ;
  int j___1 ;
  int mr ;
  int er ;
  int bb ;
  int d___8 ;
  int cneed ;
  int pen ;
  int j___2 ;
  int row___0 ;
  int abonus ;
  int ppeval ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int difdis ;
  int pen___0 ;
  int j___3 ;
  int cannotmove ;
  int ata ;
  int p ;
  int o ;
  int file___0 ;
  int j___4 ;
  int r___0 ;
  int mrr ;
  int err ;
  int b___0 ;
  int j___5 ;
  int bonus ;
  int tmp___17 ;
  int tmp___18 ;
  int j___6 ;
  int bonus___0 ;
  int tmp___19 ;
  int tmp___20 ;
  int d___9 ;
  int tmp___21 ;
  int tmp___22 ;
  int qb ;
  int tmp___23 ;
  int d___10 ;
  int tmp___24 ;
  int whas ;
  int bhas ;
  int wrm ;
  int wlm ;
  int brm ;
  int blm ;
  int tmp___25 ;
  int tmp___26 ;
  int tbonus ;
  int r___1 ;
  int difference ;

  {
#line 273
  if (Totmat <= 1200) {
    {
#line 282
    if (Totmat == 450) {
#line 282
      goto case_450;
    }
#line 287
    if (Totmat == 700) {
#line 287
      goto case_700;
    }
#line 310
    if (Totmat == 1200) {
#line 310
      goto case_1200;
    }
#line 280
    goto switch_break;
    case_450: /* CIL Label */ 
    {
#line 283
    tmp = e_mp();
#line 283
    r = tmp;
    }
#line 284
    if (r) {
#line 284
      if (Ply % 2) {
#line 284
        tmp___0 = - DrawScore;
      } else {
#line 284
        tmp___0 = DrawScore;
      }
#line 284
      return (tmp___0 + r);
    }
#line 286
    goto switch_break;
    case_700: /* CIL Label */ 
#line 288
    if ((int )G[Counter].mtrl == 350) {
#line 289
      if ((int )G[Counter].m.in2 == 0) {
#line 289
        if (Ply % 2) {
#line 289
          tmp___1 = - DrawScore;
        } else {
#line 289
          tmp___1 = DrawScore;
        }
#line 289
        return (tmp___1);
      }
    }
#line 290
    nn = 0;
#line 291
    i = (int )L[L[1].next].next;
    {
#line 291
    while (1) {
      while_continue: /* CIL Label */ ;
#line 291
      if (! (i != 0)) {
#line 291
        goto while_break;
      }
#line 292
      if ((int )B[i] == 33) {
#line 292
        nn ++;
      }
#line 291
      i = (int )L[i].next;
    }
    while_break: /* CIL Label */ ;
    }
#line 293
    if (nn == 1) {
      {
#line 293
      tmp___2 = e_nb(1);
      }
#line 293
      return (tmp___2);
    }
#line 294
    if (nn == 2) {
#line 294
      if (Color == 1) {
#line 294
        if (Ply % 2) {
#line 294
          tmp___3 = - DrawScore;
        } else {
#line 294
          tmp___3 = DrawScore;
        }
#line 294
        tmp___5 = tmp___3 - 700;
      } else {
#line 294
        if (Ply % 2) {
#line 294
          tmp___4 = - DrawScore;
        } else {
#line 294
          tmp___4 = DrawScore;
        }
#line 294
        tmp___5 = tmp___4 + 700;
      }
#line 294
      return (tmp___5);
    }
#line 298
    if (nn == 0) {
#line 300
      i = (int )L[L[2].next].next;
      {
#line 300
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 300
        if (! (i != 0)) {
#line 300
          goto while_break___0;
        }
#line 301
        if ((int )B[i] == 34) {
#line 301
          nn ++;
        }
#line 300
        i = (int )L[i].next;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 302
      if (nn == 1) {
        {
#line 302
        tmp___6 = e_nb(2);
        }
#line 302
        return (tmp___6);
      }
#line 303
      if (nn == 2) {
#line 303
        if (Color == 1) {
#line 303
          if (Ply % 2) {
#line 303
            tmp___7 = - DrawScore;
          } else {
#line 303
            tmp___7 = DrawScore;
          }
#line 303
          tmp___9 = tmp___7 + 700;
        } else {
#line 303
          if (Ply % 2) {
#line 303
            tmp___8 = - DrawScore;
          } else {
#line 303
            tmp___8 = DrawScore;
          }
#line 303
          tmp___9 = tmp___8 - 700;
        }
#line 303
        return (tmp___9);
      }
    }
#line 309
    goto switch_break;
    case_1200: /* CIL Label */ 
    {
#line 311
    tmp___11 = abs((int )G[Counter].mtrl - (int )G[Counter].xmtrl);
    }
#line 311
    if (tmp___11 == 100) {
#line 313
      np = 0;
#line 314
      i___0 = (int )L[L[1].next].next;
      {
#line 314
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 314
        if (! (i___0 != 0)) {
#line 314
          goto while_break___1;
        }
#line 314
        np ++;
#line 314
        i___0 = (int )L[i___0].next;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 315
      i___0 = (int )L[L[2].next].next;
      {
#line 315
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 315
        if (! (i___0 != 0)) {
#line 315
          goto while_break___2;
        }
#line 315
        np ++;
#line 315
        i___0 = (int )L[i___0].next;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 316
      if (np == 3) {
        {
#line 316
        tmp___10 = e_rpr();
        }
#line 316
        return (tmp___10);
      }
    }
#line 318
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  {
#line 322
  npin = 0;
#line 322
  bhp = npin;
#line 322
  whp = bhp;
#line 322
  endresult = whp;
#line 322
  midresult = endresult;
#line 322
  result = midresult;
#line 324
  memcpy((void */* __restrict  */)(mB + 20), (void const   */* __restrict  */)(mBinit),
         80UL * sizeof(tsquare ));
#line 326
  bn = 1;
#line 326
  wn = bn;
#line 327
  i = 0;
  }
  {
#line 327
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 327
    if (! (i != 10)) {
#line 327
      goto while_break___3;
    }
#line 327
    tmp___12 = 0;
#line 327
    bpf[i] = tmp___12;
#line 327
    wpf[i] = tmp___12;
#line 327
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 329
  memset((void *)(& Wknow), 0, sizeof(tknow ));
#line 330
  memset((void *)(& Bknow), 0, sizeof(tknow ));
#line 331
  memset((void *)(P), 0, 120UL * sizeof(short ));
#line 333
  Wknow.kp = L[1].next;
#line 333
  Wknow.worsebm = (signed char)100;
#line 334
  Wknow.lpf = (unsigned char)9;
#line 335
  Bknow.kp = L[2].next;
#line 335
  Bknow.worsebm = (signed char)100;
#line 336
  Bknow.lpf = (unsigned char)9;
#line 340
  i = (int )L[1].next;
#line 340
  mB[*(Th + i)] = (tsquare )98;
#line 340
  wl[0] = i;
#line 341
  i = (int )L[i].next;
  }
  {
#line 341
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 341
    if (! (i != 0)) {
#line 341
      goto while_break___4;
    }
    {
#line 346
    if ((int )B[i] == 17) {
#line 346
      goto case_17;
    }
#line 357
    if ((int )B[i] == 33) {
#line 357
      goto case_33;
    }
#line 362
    if ((int )B[i] == 49) {
#line 362
      goto case_49;
    }
#line 386
    if ((int )B[i] == 65) {
#line 386
      goto case_65;
    }
#line 404
    if ((int )B[i] == 81) {
#line 404
      goto case_81;
    }
#line 344
    goto switch_break___0;
    case_17: /* CIL Label */ 
#line 346
    mB[*(Th + i)] = (tsquare )18;
#line 346
    wl[wn] = i;
#line 346
    wn ++;
#line 347
    (wpf[i % 10]) ++;
#line 348
    if (i % 10 < (int )Wknow.lpf) {
#line 348
      Wknow.lpf = (unsigned char )(i % 10);
    }
#line 349
    if (i % 10 > (int )Wknow.rpf) {
#line 349
      Wknow.rpf = (unsigned char )(i % 10);
    }
#line 350
    Wknow.p = (unsigned char )((int )Wknow.p + 1);
#line 351
    j = i + 9;
    {
#line 351
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 351
      if (! (j <= i + 11)) {
#line 351
        goto while_break___5;
      }
#line 351
      P[j] = (unsigned short )((int )P[j] | 1);
#line 351
      P[j] = (unsigned short )((int )P[j] + 32);
#line 351
      j += 2;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 352
    if (i >= 71) {
#line 352
      if ((int )B[i + 10] == 0) {
#line 353
        Bknow.hung = (short )((int )Bknow.hung + 4);
#line 354
        if ((int )B[i + 20] == 0) {
#line 354
          Bknow.hung = (short )((int )Bknow.hung + 16);
        } else
#line 354
        if ((int )B[i + 20] == 3) {
#line 354
          Bknow.hung = (short )((int )Bknow.hung + 16);
        }
      }
    }
#line 356
    goto switch_break___0;
    case_33: /* CIL Label */ 
#line 357
    mB[*(Th + i)] = (tsquare )34;
#line 357
    wl[wn] = i;
#line 357
    wn ++;
#line 358
    Wknow.n = (unsigned char )((int )Wknow.n + 1);
#line 359
    j = 0;
    {
#line 359
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 359
      if (! (j != 8)) {
#line 359
        goto while_break___6;
      }
#line 360
      d = i + N_moves[j];
#line 360
      P[d] = (unsigned short )((int )P[d] | 2);
#line 360
      P[d] = (unsigned short )((int )P[d] + 32);
#line 359
      j ++;
    }
    while_break___6: /* CIL Label */ ;
    }
#line 361
    goto switch_break___0;
    case_49: /* CIL Label */ 
#line 362
    mB[*(Th + i)] = (tsquare )50;
#line 362
    wl[wn] = i;
#line 362
    wn ++;
#line 363
    Wknow.b = (unsigned char )((int )Wknow.b + 1);
#line 364
    Wknow.bishopcolor = (unsigned char )((int )Wknow.bishopcolor | (int )*(sqcolor + i));
#line 365
    Bknow.xbishopcolor = (unsigned char )((int )Bknow.xbishopcolor | (3 - (int )*(sqcolor + i)));
#line 366
    mobi = 4;
#line 367
    j = 4;
    {
#line 367
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 367
      if (! (j != 8)) {
#line 367
        goto while_break___7;
      }
#line 368
      step = RB_dirs[j];
#line 368
      d___0 = i;
      {
#line 369
      while (1) {
        while_continue___8: /* CIL Label */ ;
#line 369
        d___0 += step;
#line 369
        mobi ++;
#line 369
        P[d___0] = (unsigned short )((int )P[d___0] | 4);
#line 369
        P[d___0] = (unsigned short )((int )P[d___0] + 32);
#line 369
        if (! ((int )B[d___0] == 0)) {
#line 369
          goto while_break___8;
        }
      }
      while_break___8: /* CIL Label */ ;
      }
#line 371
      if ((int )B[d___0] & 1) {
#line 373
        mobi --;
#line 374
        if ((int )B[d___0] == 3) {
#line 374
          mobi --;
        } else
#line 374
        if ((int )B[d___0] == 17) {
#line 374
          if (B[d___0 + 10]) {
#line 374
            mobi --;
          }
        }
      } else
#line 377
      if ((int )B[d___0] == 34) {
#line 377
        goto _L;
      } else
#line 377
      if ((int )B[d___0] == 66) {
#line 377
        goto _L;
      } else
#line 377
      if ((int )B[d___0] == 82) {
        _L: /* CIL Label */ 
#line 378
        pin___0[npin] = d___0;
        {
#line 379
        while (1) {
          while_continue___9: /* CIL Label */ ;
#line 379
          d___0 += step;
#line 379
          if (! ((int )B[d___0] == 0)) {
#line 379
            goto while_break___9;
          }
        }
        while_break___9: /* CIL Label */ ;
        }
#line 380
        if ((int )B[d___0] == 82) {
#line 380
          npin ++;
        } else
#line 380
        if ((int )B[d___0] == 98) {
#line 380
          npin ++;
        }
      }
#line 367
      j ++;
    }
    while_break___7: /* CIL Label */ ;
    }
#line 383
    result += B_mobi[mobi];
#line 384
    if (mobi < (int )Wknow.worsebm) {
#line 384
      Wknow.worsebm = (signed char )mobi;
    }
#line 385
    goto switch_break___0;
    case_65: /* CIL Label */ 
#line 386
    mB[*(Th + i)] = (tsquare )66;
#line 386
    wl[wn] = i;
#line 386
    wn ++;
#line 387
    if (i >= 81) {
#line 387
      if (i <= 88) {
#line 387
        Wknow.r7r = (unsigned char )((int )Wknow.r7r + 2);
      }
    }
#line 388
    Wknow.r = (unsigned char )((int )Wknow.r + 1);
#line 389
    mobi = 0;
#line 390
    j = 0;
    {
#line 390
    while (1) {
      while_continue___10: /* CIL Label */ ;
#line 390
      if (! (j != 4)) {
#line 390
        goto while_break___10;
      }
#line 391
      step___0 = RB_dirs[j];
#line 391
      d___1 = i;
      {
#line 392
      while (1) {
        while_continue___11: /* CIL Label */ ;
#line 392
        d___1 += step___0;
#line 392
        mobi ++;
#line 392
        P[d___1] = (unsigned short )((int )P[d___1] | 8);
#line 392
        P[d___1] = (unsigned short )((int )P[d___1] + 32);
#line 392
        if (! ((int )B[d___1] == 0)) {
#line 392
          goto while_break___11;
        }
      }
      while_break___11: /* CIL Label */ ;
      }
#line 394
      if ((int )B[d___1] & 1) {
#line 394
        mobi --;
      } else
#line 396
      if ((int )B[d___1] == 34) {
#line 396
        goto _L___0;
      } else
#line 396
      if ((int )B[d___1] == 50) {
#line 396
        goto _L___0;
      } else
#line 396
      if ((int )B[d___1] == 82) {
        _L___0: /* CIL Label */ 
#line 397
        pin___0[npin] = d___1;
        {
#line 398
        while (1) {
          while_continue___12: /* CIL Label */ ;
#line 398
          d___1 += step___0;
#line 398
          if (! ((int )B[d___1] == 0)) {
#line 398
            goto while_break___12;
          }
        }
        while_break___12: /* CIL Label */ ;
        }
#line 399
        if ((int )B[d___1] == 82) {
#line 399
          npin ++;
        } else
#line 399
        if ((int )B[d___1] == 98) {
#line 399
          npin ++;
        }
      }
#line 390
      j ++;
    }
    while_break___10: /* CIL Label */ ;
    }
#line 402
    result += R_mobi[mobi];
#line 403
    goto switch_break___0;
    case_81: /* CIL Label */ 
#line 404
    mB[*(Th + i)] = (tsquare )82;
#line 404
    wl[wn] = i;
#line 404
    wn ++;
#line 405
    if (i >= 21) {
#line 405
      if (i <= 48) {
#line 405
        Wknow.r7r = (unsigned char )((int )Wknow.r7r + 1);
      }
    }
#line 406
    Wknow.q = (unsigned char )((int )Wknow.q + 1);
#line 407
    j = 0;
    {
#line 407
    while (1) {
      while_continue___13: /* CIL Label */ ;
#line 407
      if (! (j != 8)) {
#line 407
        goto while_break___13;
      }
#line 408
      step___1 = RB_dirs[j];
#line 408
      d___2 = i;
      {
#line 409
      while (1) {
        while_continue___14: /* CIL Label */ ;
#line 409
        d___2 += step___1;
#line 409
        P[d___2] = (unsigned short )((int )P[d___2] | 16);
#line 409
        P[d___2] = (unsigned short )((int )P[d___2] + 32);
#line 409
        if (! ((int )B[d___2] == 0)) {
#line 409
          goto while_break___14;
        }
      }
      while_break___14: /* CIL Label */ ;
      }
#line 412
      if ((int )B[d___2] == 34) {
#line 412
        goto _L___1;
      } else
#line 412
      if ((int )B[d___2] == 50) {
#line 412
        if (d___2 < 4) {
#line 412
          goto _L___1;
        } else {
#line 412
          goto _L___2;
        }
      } else
      _L___2: /* CIL Label */ 
#line 412
      if ((int )B[d___2] == 66) {
#line 412
        if (d___2 >= 4) {
          _L___1: /* CIL Label */ 
#line 413
          pin___0[npin] = d___2;
          {
#line 414
          while (1) {
            while_continue___15: /* CIL Label */ ;
#line 414
            d___2 += step___1;
#line 414
            if (! ((int )B[d___2] == 0)) {
#line 414
              goto while_break___15;
            }
          }
          while_break___15: /* CIL Label */ ;
          }
#line 415
          if ((int )B[d___2] == 98) {
#line 415
            npin ++;
          }
        }
      }
#line 407
      j ++;
    }
    while_break___13: /* CIL Label */ ;
    }
#line 418
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
#line 341
    i = (int )L[i].next;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 422
  i = (int )L[2].next;
#line 422
  mB[*(Th + i)] = (tsquare )97;
#line 422
  bl[0] = (int )*(Th + i);
#line 423
  i = (int )L[i].next;
  {
#line 423
  while (1) {
    while_continue___16: /* CIL Label */ ;
#line 423
    if (! (i != 0)) {
#line 423
      goto while_break___16;
    }
    {
#line 429
    if ((int )B[i] == 18) {
#line 429
      goto case_18;
    }
#line 440
    if ((int )B[i] == 34) {
#line 440
      goto case_34;
    }
#line 445
    if ((int )B[i] == 50) {
#line 445
      goto case_50;
    }
#line 469
    if ((int )B[i] == 66) {
#line 469
      goto case_66;
    }
#line 487
    if ((int )B[i] == 82) {
#line 487
      goto case_82;
    }
#line 427
    goto switch_break___1;
    case_18: /* CIL Label */ 
#line 429
    mB[*(Th + i)] = (tsquare )17;
#line 429
    bl[bn] = (int )*(Th + i);
#line 429
    bn ++;
#line 430
    (bpf[i % 10]) ++;
#line 431
    if (i % 10 < (int )Bknow.lpf) {
#line 431
      Bknow.lpf = (unsigned char )(i % 10);
    }
#line 432
    if (i % 10 > (int )Bknow.rpf) {
#line 432
      Bknow.rpf = (unsigned char )(i % 10);
    }
#line 433
    Bknow.p = (unsigned char )((int )Bknow.p + 1);
#line 434
    j___0 = i - 11;
    {
#line 434
    while (1) {
      while_continue___17: /* CIL Label */ ;
#line 434
      if (! (j___0 <= i - 9)) {
#line 434
        goto while_break___17;
      }
#line 434
      P[j___0] = (unsigned short )((int )P[j___0] | 256);
#line 434
      P[j___0] = (unsigned short )((int )P[j___0] + 8192);
#line 434
      j___0 += 2;
    }
    while_break___17: /* CIL Label */ ;
    }
#line 435
    if (i <= 48) {
#line 435
      if ((int )B[i - 10] == 0) {
#line 436
        Wknow.hung = (short )((int )Wknow.hung + 4);
#line 437
        if ((int )B[i - 20] == 0) {
#line 437
          Wknow.hung = (short )((int )Wknow.hung + 16);
        } else
#line 437
        if ((int )B[i - 20] == 3) {
#line 437
          Wknow.hung = (short )((int )Wknow.hung + 16);
        }
      }
    }
#line 439
    goto switch_break___1;
    case_34: /* CIL Label */ 
#line 440
    mB[*(Th + i)] = (tsquare )33;
#line 440
    bl[bn] = (int )*(Th + i);
#line 440
    bn ++;
#line 441
    Bknow.n = (unsigned char )((int )Bknow.n + 1);
#line 442
    j___0 = 0;
    {
#line 442
    while (1) {
      while_continue___18: /* CIL Label */ ;
#line 442
      if (! (j___0 != 8)) {
#line 442
        goto while_break___18;
      }
#line 443
      d___3 = i + N_moves[j___0];
#line 443
      P[d___3] = (unsigned short )((int )P[d___3] | 512);
#line 443
      P[d___3] = (unsigned short )((int )P[d___3] + 8192);
#line 442
      j___0 ++;
    }
    while_break___18: /* CIL Label */ ;
    }
#line 444
    goto switch_break___1;
    case_50: /* CIL Label */ 
#line 445
    mB[*(Th + i)] = (tsquare )49;
#line 445
    bl[bn] = (int )*(Th + i);
#line 445
    bn ++;
#line 446
    Bknow.b = (unsigned char )((int )Bknow.b + 1);
#line 447
    Bknow.bishopcolor = (unsigned char )((int )Bknow.bishopcolor | (3 - (int )*(sqcolor + i)));
#line 448
    Wknow.xbishopcolor = (unsigned char )((int )Wknow.xbishopcolor | (int )*(sqcolor + i));
#line 449
    mobi___0 = 4;
#line 450
    j___0 = 4;
    {
#line 450
    while (1) {
      while_continue___19: /* CIL Label */ ;
#line 450
      if (! (j___0 != 8)) {
#line 450
        goto while_break___19;
      }
#line 451
      step___2 = RB_dirs[j___0];
#line 451
      d___4 = i;
      {
#line 452
      while (1) {
        while_continue___20: /* CIL Label */ ;
#line 452
        d___4 += step___2;
#line 452
        mobi___0 ++;
#line 452
        P[d___4] = (unsigned short )((int )P[d___4] | 1024);
#line 452
        P[d___4] = (unsigned short )((int )P[d___4] + 8192);
#line 452
        if (! ((int )B[d___4] == 0)) {
#line 452
          goto while_break___20;
        }
      }
      while_break___20: /* CIL Label */ ;
      }
#line 454
      if ((int )B[d___4] & 2) {
#line 456
        mobi___0 --;
#line 457
        if ((int )B[d___4] == 3) {
#line 457
          mobi___0 --;
        } else
#line 457
        if ((int )B[d___4] == 18) {
#line 457
          if (B[d___4 - 10]) {
#line 457
            mobi___0 --;
          }
        }
      } else
#line 460
      if ((int )B[d___4] == 33) {
#line 460
        goto _L___3;
      } else
#line 460
      if ((int )B[d___4] == 65) {
#line 460
        goto _L___3;
      } else
#line 460
      if ((int )B[d___4] == 81) {
        _L___3: /* CIL Label */ 
#line 461
        pin___0[npin] = d___4;
        {
#line 462
        while (1) {
          while_continue___21: /* CIL Label */ ;
#line 462
          d___4 += step___2;
#line 462
          if (! ((int )B[d___4] == 0)) {
#line 462
            goto while_break___21;
          }
        }
        while_break___21: /* CIL Label */ ;
        }
#line 463
        if ((int )B[d___4] == 81) {
#line 463
          npin ++;
        } else
#line 463
        if ((int )B[d___4] == 97) {
#line 463
          npin ++;
        }
      }
#line 450
      j___0 ++;
    }
    while_break___19: /* CIL Label */ ;
    }
#line 466
    result -= B_mobi[mobi___0];
#line 467
    if (mobi___0 < (int )Bknow.worsebm) {
#line 467
      Bknow.worsebm = (signed char )mobi___0;
    }
#line 468
    goto switch_break___1;
    case_66: /* CIL Label */ 
#line 469
    mB[*(Th + i)] = (tsquare )65;
#line 469
    bl[bn] = (int )*(Th + i);
#line 469
    bn ++;
#line 470
    if (i >= 31) {
#line 470
      if (i <= 38) {
#line 470
        Bknow.r7r = (unsigned char )((int )Bknow.r7r + 2);
      }
    }
#line 471
    Bknow.r = (unsigned char )((int )Bknow.r + 1);
#line 472
    mobi___0 = 0;
#line 473
    j___0 = 0;
    {
#line 473
    while (1) {
      while_continue___22: /* CIL Label */ ;
#line 473
      if (! (j___0 != 4)) {
#line 473
        goto while_break___22;
      }
#line 474
      step___3 = RB_dirs[j___0];
#line 474
      d___5 = i;
      {
#line 475
      while (1) {
        while_continue___23: /* CIL Label */ ;
#line 475
        d___5 += step___3;
#line 475
        mobi___0 ++;
#line 475
        P[d___5] = (unsigned short )((int )P[d___5] | 2048);
#line 475
        P[d___5] = (unsigned short )((int )P[d___5] + 8192);
#line 475
        if (! ((int )B[d___5] == 0)) {
#line 475
          goto while_break___23;
        }
      }
      while_break___23: /* CIL Label */ ;
      }
#line 477
      if ((int )B[d___5] & 2) {
#line 477
        mobi___0 --;
      } else
#line 479
      if ((int )B[d___5] == 33) {
#line 479
        goto _L___4;
      } else
#line 479
      if ((int )B[d___5] == 49) {
#line 479
        goto _L___4;
      } else
#line 479
      if ((int )B[d___5] == 81) {
        _L___4: /* CIL Label */ 
#line 480
        pin___0[npin] = d___5;
        {
#line 481
        while (1) {
          while_continue___24: /* CIL Label */ ;
#line 481
          d___5 += step___3;
#line 481
          if (! ((int )B[d___5] == 0)) {
#line 481
            goto while_break___24;
          }
        }
        while_break___24: /* CIL Label */ ;
        }
#line 482
        if ((int )B[d___5] == 81) {
#line 482
          npin ++;
        } else
#line 482
        if ((int )B[d___5] == 97) {
#line 482
          npin ++;
        }
      }
#line 473
      j___0 ++;
    }
    while_break___22: /* CIL Label */ ;
    }
#line 485
    result -= R_mobi[mobi___0];
#line 486
    goto switch_break___1;
    case_82: /* CIL Label */ 
#line 487
    mB[*(Th + i)] = (tsquare )81;
#line 487
    bl[bn] = (int )*(Th + i);
#line 487
    bn ++;
#line 488
    if (i >= 21) {
#line 488
      if (i <= 48) {
#line 488
        Bknow.r7r = (unsigned char )((int )Bknow.r7r + 1);
      }
    }
#line 489
    Bknow.q = (unsigned char )((int )Bknow.q + 1);
#line 490
    j___0 = 0;
    {
#line 490
    while (1) {
      while_continue___25: /* CIL Label */ ;
#line 490
      if (! (j___0 != 8)) {
#line 490
        goto while_break___25;
      }
#line 491
      step___4 = RB_dirs[j___0];
#line 491
      d___6 = i;
      {
#line 492
      while (1) {
        while_continue___26: /* CIL Label */ ;
#line 492
        d___6 += step___4;
#line 492
        P[d___6] = (unsigned short )((int )P[d___6] + 8192);
#line 492
        P[d___6] = (unsigned short )((int )P[d___6] | 4096);
#line 492
        if (! ((int )B[d___6] == 0)) {
#line 492
          goto while_break___26;
        }
      }
      while_break___26: /* CIL Label */ ;
      }
#line 494
      if ((int )B[d___6] == 33) {
#line 494
        goto _L___5;
      } else
#line 494
      if ((int )B[d___6] == 49) {
#line 494
        if (d___6 < 4) {
#line 494
          goto _L___5;
        } else {
#line 494
          goto _L___6;
        }
      } else
      _L___6: /* CIL Label */ 
#line 494
      if ((int )B[d___6] == 65) {
#line 494
        if (d___6 >= 4) {
          _L___5: /* CIL Label */ 
#line 495
          pin___0[npin] = d___6;
          {
#line 496
          while (1) {
            while_continue___27: /* CIL Label */ ;
#line 496
            d___6 += step___4;
#line 496
            if (! ((int )B[d___6] == 0)) {
#line 496
              goto while_break___27;
            }
          }
          while_break___27: /* CIL Label */ ;
          }
#line 497
          if ((int )B[d___6] == 97) {
#line 497
            npin ++;
          }
        }
      }
#line 490
      j___0 ++;
    }
    while_break___25: /* CIL Label */ ;
    }
#line 500
    goto switch_break___1;
    switch_break___1: /* CIL Label */ ;
    }
#line 423
    i = (int )L[i].next;
  }
  while_break___16: /* CIL Label */ ;
  }
#line 504
  if (Totmat == 100 * ((int )Wknow.p + (int )Bknow.p)) {
    {
#line 505
    tmp___13 = pawns();
    }
#line 505
    return (tmp___13);
  }
#line 522
  i = 0;
  {
#line 522
  while (1) {
    while_continue___28: /* CIL Label */ ;
#line 522
    if (! (i != npin)) {
#line 522
      goto while_break___28;
    }
#line 523
    pini = pin___0[i];
    {
#line 525
    if ((int )B[pini] == 81) {
#line 525
      goto case_81___0;
    }
#line 527
    if ((int )B[pini] == 82) {
#line 527
      goto case_82___0;
    }
#line 529
    if ((int )B[pini] == 65) {
#line 529
      goto case_65___0;
    }
#line 529
    if ((int )B[pini] == 49) {
#line 529
      goto case_65___0;
    }
#line 529
    if ((int )B[pini] == 33) {
#line 529
      goto case_65___0;
    }
#line 535
    if ((int )B[pini] == 66) {
#line 535
      goto case_66___0;
    }
#line 535
    if ((int )B[pini] == 50) {
#line 535
      goto case_66___0;
    }
#line 535
    if ((int )B[pini] == 34) {
#line 535
      goto case_66___0;
    }
#line 523
    goto switch_break___2;
    case_81___0: /* CIL Label */ 
#line 525
    result -= 50;
#line 525
    Wknow.hung = (short )((int )Wknow.hung + 20);
#line 526
    goto switch_break___2;
    case_82___0: /* CIL Label */ 
#line 527
    result += 50;
#line 527
    Bknow.hung = (short )((int )Bknow.hung + 20);
#line 528
    goto switch_break___2;
    case_65___0: /* CIL Label */ 
    case_49___0: /* CIL Label */ 
    case_33___0: /* CIL Label */ 
#line 530
    if (((int )P[pini] & 1) == 0) {
#line 531
      Wknow.hung = (short )((int )Wknow.hung + 6);
#line 531
      result += -15 * ((int )P[pini] >> 13);
    } else {
#line 532
      result += -6 * ((int )P[pini] >> 13);
    }
#line 533
    if ((int )P[pini] & 256) {
#line 533
      Wknow.hung = (short )((int )Wknow.hung + 5);
#line 533
      result -= 15;
    }
#line 534
    goto switch_break___2;
    case_66___0: /* CIL Label */ 
    case_50___0: /* CIL Label */ 
    case_34___0: /* CIL Label */ 
#line 536
    if (((int )P[pini] & 256) == 0) {
#line 537
      Bknow.hung = (short )((int )Bknow.hung + 6);
#line 537
      result += 15 * ((240 & (int )P[pini]) >> 5);
    } else {
#line 538
      result += 6 * ((240 & (int )P[pini]) >> 5);
    }
#line 539
    if ((int )P[pini] & 1) {
#line 539
      Bknow.hung = (short )((int )Bknow.hung + 5);
#line 539
      result += 15;
    }
#line 540
    goto switch_break___2;
    switch_break___2: /* CIL Label */ ;
    }
#line 522
    i ++;
  }
  while_break___28: /* CIL Label */ ;
  }
#line 557
  i = (int )L[L[1].next].next;
  {
#line 557
  while (1) {
    while_continue___29: /* CIL Label */ ;
#line 557
    if (! (i != 0)) {
#line 557
      goto while_break___29;
    }
#line 558
    if ((int )P[i] & 65280) {
#line 560
      if (((int )P[i] & 255) == 0) {
#line 560
        goto _L___7;
      } else
#line 560
      if (m___0[B[i]] & (unsigned int )((int )P[i] >> 8)) {
        _L___7: /* CIL Label */ 
        {
#line 563
        if ((int )B[i] == 17) {
#line 563
          goto case_17___0;
        }
#line 565
        if ((int )B[i] == 49) {
#line 565
          goto case_49___1;
        }
#line 565
        if ((int )B[i] == 33) {
#line 565
          goto case_49___1;
        }
#line 566
        if ((int )B[i] == 65) {
#line 566
          goto case_65___1;
        }
#line 567
        if ((int )B[i] == 81) {
#line 567
          goto case_81___1;
        }
#line 562
        goto switch_break___3;
        case_17___0: /* CIL Label */ 
#line 563
        Wknow.hung = (short )((int )Wknow.hung + 8);
#line 563
        goto switch_break___3;
        case_49___1: /* CIL Label */ 
        case_33___1: /* CIL Label */ 
#line 565
        whp ++;
#line 565
        Wknow.hung = (short )((int )Wknow.hung + 12);
#line 565
        goto switch_break___3;
        case_65___1: /* CIL Label */ 
#line 566
        whp ++;
#line 566
        Wknow.hung = (short )((int )Wknow.hung + 14);
#line 566
        goto switch_break___3;
        case_81___1: /* CIL Label */ 
#line 567
        whp ++;
#line 567
        Wknow.hung = (short )((int )Wknow.hung + 16);
        switch_break___3: /* CIL Label */ ;
        }
      } else
#line 569
      if (((int )P[i] & 1) == 0) {
#line 571
        if ((int )B[i] == 17) {
#line 571
          result += ((int )P[i] >> 13) * 5;
        } else {
#line 572
          Wknow.hung = (short )((int )Wknow.hung + 6);
        }
      }
    }
#line 557
    i = (int )L[i].next;
  }
  while_break___29: /* CIL Label */ ;
  }
#line 576
  i = (int )L[L[2].next].next;
  {
#line 576
  while (1) {
    while_continue___30: /* CIL Label */ ;
#line 576
    if (! (i != 0)) {
#line 576
      goto while_break___30;
    }
#line 577
    if ((int )P[i] & 255) {
#line 579
      if (((int )P[i] & 65280) == 0) {
#line 579
        goto _L___8;
      } else
#line 579
      if (m___0[B[i]] & (unsigned int )P[i]) {
        _L___8: /* CIL Label */ 
        {
#line 581
        if ((int )B[i] == 18) {
#line 581
          goto case_18___0;
        }
#line 583
        if ((int )B[i] == 50) {
#line 583
          goto case_50___1;
        }
#line 583
        if ((int )B[i] == 34) {
#line 583
          goto case_50___1;
        }
#line 584
        if ((int )B[i] == 66) {
#line 584
          goto case_66___1;
        }
#line 585
        if ((int )B[i] == 82) {
#line 585
          goto case_82___1;
        }
#line 580
        goto switch_break___4;
        case_18___0: /* CIL Label */ 
#line 581
        Bknow.hung = (short )((int )Bknow.hung + 8);
#line 581
        goto switch_break___4;
        case_50___1: /* CIL Label */ 
        case_34___1: /* CIL Label */ 
#line 583
        bhp ++;
#line 583
        Bknow.hung = (short )((int )Bknow.hung + 12);
#line 583
        goto switch_break___4;
        case_66___1: /* CIL Label */ 
#line 584
        bhp ++;
#line 584
        Bknow.hung = (short )((int )Bknow.hung + 14);
#line 584
        goto switch_break___4;
        case_82___1: /* CIL Label */ 
#line 585
        bhp ++;
#line 585
        Bknow.hung = (short )((int )Bknow.hung + 16);
        switch_break___4: /* CIL Label */ ;
        }
      } else
#line 587
      if (((int )P[i] & 256) == 0) {
#line 589
        if ((int )B[i] == 18) {
#line 589
          result -= (((int )P[i] >> 5) & 7) * 5;
        } else {
#line 590
          Bknow.hung = (short )((int )Bknow.hung + 6);
        }
      }
    }
#line 576
    i = (int )L[i].next;
  }
  while_break___30: /* CIL Label */ ;
  }
#line 594
  if (whp > 1) {
#line 594
    Wknow.hung = (short )((int )Wknow.hung + 8 * whp);
  }
#line 595
  if (bhp > 1) {
#line 595
    Bknow.hung = (short )((int )Bknow.hung + 8 * bhp);
  }
#line 599
  i = 0;
  {
#line 599
  while (1) {
    while_continue___31: /* CIL Label */ ;
#line 599
    if (! (i != 8)) {
#line 599
      goto while_break___31;
    }
#line 601
    direction = RB_dirs[i];
#line 602
    d___7 = (int )Wknow.kp + direction;
#line 603
    if ((int )B[d___7] != 3) {
#line 605
      ataks = ((int )P[d___7] >> 13) & 7;
#line 606
      if (ataks) {
#line 608
        defs = ((int )P[d___7] >> 5) & 7;
#line 609
        Wknow.khung = (signed char )((int )Wknow.khung + ataks);
#line 610
        if (defs == 0) {
#line 612
          Wknow.khung = (signed char )((int )Wknow.khung + 1);
#line 613
          if (ataks > 1) {
#line 613
            if ((int )P[d___7] & 4096) {
#line 614
              Wknow.khung = (signed char )((int )Wknow.khung + 2);
            }
          }
        }
      }
#line 619
      if ((int )B[d___7] == 0) {
#line 621
        d___7 += direction;
        {
#line 622
        while (1) {
          while_continue___32: /* CIL Label */ ;
#line 622
          if (! (((int )B[d___7] & 2) == 0)) {
#line 622
            goto while_break___32;
          }
#line 624
          if (((int )P[d___7] & 224) == 0) {
#line 626
            if (i < 4) {
#line 627
              if ((int )P[d___7] & 6144) {
#line 628
                Wknow.khung = (signed char )((int )Wknow.khung + 2);
#line 628
                goto while_break___32;
              }
            } else
#line 630
            if ((int )P[d___7] & 5120) {
#line 631
              Wknow.khung = (signed char )((int )Wknow.khung + 2);
#line 631
              goto while_break___32;
            }
          }
#line 633
          if (B[d___7]) {
#line 633
            goto while_break___32;
          }
#line 634
          d___7 += direction;
        }
        while_break___32: /* CIL Label */ ;
        }
      }
#line 637
      d___7 = (int )Wknow.kp + N_moves[i];
#line 638
      if ((int )P[d___7] & 512) {
#line 638
        if (((int )B[d___7] & 2) == 0) {
#line 638
          if (((int )P[d___7] & 224) == 0) {
#line 639
            Wknow.khung = (signed char )((int )Wknow.khung + 2);
          }
        }
      }
    }
#line 642
    d___7 = (int )Bknow.kp + direction;
#line 643
    if ((int )B[d___7] != 3) {
#line 645
      ataks___0 = ((int )P[d___7] >> 5) & 7;
#line 646
      if (ataks___0) {
#line 648
        defs___0 = ((int )P[d___7] >> 5) & 7;
#line 649
        Bknow.khung = (signed char )((int )Bknow.khung + ataks___0);
#line 650
        if (defs___0 == 0) {
#line 652
          Bknow.khung = (signed char )((int )Bknow.khung + 1);
#line 653
          if (ataks___0 > 1) {
#line 653
            if ((int )P[d___7] & 16) {
#line 654
              Bknow.khung = (signed char )((int )Bknow.khung + 2);
            }
          }
        }
      }
#line 659
      if ((int )B[d___7] == 0) {
#line 661
        d___7 += direction;
        {
#line 662
        while (1) {
          while_continue___33: /* CIL Label */ ;
#line 662
          if (! (((int )B[d___7] & 1) == 0)) {
#line 662
            goto while_break___33;
          }
#line 664
          if (((int )P[d___7] & 57344) == 0) {
#line 666
            if (i < 4) {
#line 667
              if ((int )P[d___7] & 24) {
#line 668
                Bknow.khung = (signed char )((int )Bknow.khung + 2);
#line 668
                goto while_break___33;
              }
            } else
#line 670
            if ((int )P[d___7] & 20) {
#line 671
              Bknow.khung = (signed char )((int )Bknow.khung + 2);
#line 671
              goto while_break___33;
            }
          }
#line 673
          if (B[d___7]) {
#line 673
            goto while_break___33;
          }
#line 674
          d___7 += direction;
        }
        while_break___33: /* CIL Label */ ;
        }
      }
#line 677
      d___7 = (int )Bknow.kp + N_moves[i];
#line 678
      if ((int )P[d___7] & 2) {
#line 678
        if (((int )B[d___7] & 1) == 0) {
#line 678
          if (((int )P[d___7] & 57344) == 0) {
#line 679
            Bknow.khung = (signed char )((int )Bknow.khung + 2);
          }
        }
      }
    }
#line 599
    i ++;
  }
  while_break___31: /* CIL Label */ ;
  }
#line 683
  if (Totmat >= 4050) {
#line 685
    if ((int )Wknow.kp % 10 < 5) {
#line 685
      if ((int )Bknow.kp % 10 > 5) {
#line 687
        Wknow.kstorm = (signed char)1;
#line 687
        Bknow.qstorm = (signed char)1;
      } else {
#line 685
        goto _L___9;
      }
    } else
    _L___9: /* CIL Label */ 
#line 690
    if ((int )Wknow.kp % 10 > 5) {
#line 690
      if ((int )Bknow.kp % 10 < 5) {
#line 692
        Wknow.qstorm = (signed char)1;
#line 692
        Bknow.kstorm = (signed char)1;
      }
    }
  }
#line 696
  if (Wknow.hung) {
#line 698
    hresult = (int )Bknow.hung - (int )Wknow.hung;
#line 699
    midresult += hresult;
#line 700
    endresult += hresult;
  } else
#line 696
  if (Bknow.hung) {
#line 698
    hresult = (int )Bknow.hung - (int )Wknow.hung;
#line 699
    midresult += hresult;
#line 700
    endresult += hresult;
  }
#line 706
  Wknow.castling = (unsigned char )((int )G[Counter].castling & 3);
#line 707
  Bknow.castling = (unsigned char )((int )G[Counter].castling >> 2);
#line 709
  if (((int )P[27] | (int )P[26]) & 65280) {
#line 709
    Wknow.castling = (unsigned char )((int )Wknow.castling | 1);
  }
#line 710
  if (((int )P[23] | (int )P[24]) & 65280) {
#line 710
    Wknow.castling = (unsigned char )((int )Wknow.castling | 2);
  }
#line 712
  if (((int )P[97] | (int )P[96]) & 255) {
#line 712
    Bknow.castling = (unsigned char )((int )Bknow.castling | 1);
  }
#line 713
  if (((int )P[93] | (int )P[94]) & 255) {
#line 713
    Bknow.castling = (unsigned char )((int )Bknow.castling | 2);
  }
#line 719
  n___0 = wn;
#line 719
  l = wl;
#line 719
  b = B;
#line 720
  pf = wpf;
#line 720
  xpf = bpf;
#line 721
  know = & Wknow;
#line 721
  xknow = & Bknow;
#line 722
  kp = (int )Wknow.kp;
#line 722
  xkp = (int )Bknow.kp;
  {
#line 723
  while (1) {
    while_continue___34: /* CIL Label */ ;
#line 725
    kdist = dist + 120 * kp;
#line 726
    xkdist = dist + 120 * xkp;
#line 729
    mr = 0;
#line 729
    er = 0;
#line 732
    if ((int )know->bishopcolor == 3) {
#line 734
      bb = 18 + 2 * (int )know->worsebm;
#line 735
      mr += bb;
#line 736
      er += bb * 2;
    }
#line 746
    if ((int )know->r7r > 1) {
#line 748
      if (xkp >= 91) {
#line 749
        er += 12 * (int )know->r7r;
#line 749
        mr += 5 * (int )know->r7r;
      }
#line 750
      mr += 10 * (int )know->r7r;
#line 750
      er += 4 * (int )know->r7r;
#line 751
      if ((int )know->r7r > 2) {
#line 751
        mr += (int )know->r7r * (int )know->r7r + 4;
      }
    }
#line 754
    if (Totmat >= 3000) {
#line 756
      d___8 = 0;
#line 759
      if ((int )*(b + 64) == 18) {
#line 761
        if ((int )*(b + 53) == 17) {
#line 762
          mr += 10;
#line 763
          if ((int )*(b + 75) == 18) {
#line 763
            if ((int )B[54] == 17) {
#line 763
              mr += 10;
            }
          }
#line 766
          if ((int )*(b + 66) == 18) {
#line 766
            mr += 15;
          }
        }
#line 768
        if ((int )*(b + 33) == 17) {
#line 770
          if ((int )*(b + 43) != 0) {
#line 770
            mr -= 7;
          } else {
#line 771
            mr -= 3;
          }
#line 772
          if ((int )*(b + 35) == 17) {
#line 772
            mr -= 5;
          } else
#line 772
          if ((int )*(b + 45) == 17) {
#line 772
            mr -= 5;
          }
#line 773
          if ((int )*(b + 75) == 18) {
#line 773
            mr -= 4;
          } else
#line 773
          if ((int )*(b + 73) == 18) {
#line 773
            mr -= 4;
          }
        }
      }
#line 778
      if ((int )*(b + 21) == 65) {
#line 778
        if (*(pf + 1) != 0) {
#line 778
          d___8 += 2;
        }
      }
#line 779
      if ((int )*(b + 22) == 33) {
#line 779
        d___8 += 5;
      }
#line 780
      if ((int )*(b + 23) == 49) {
#line 780
        d___8 += 3;
#line 780
        if (*(b + 32)) {
#line 780
          if (*(b + 34)) {
#line 780
            d___8 += 4;
          }
        }
      }
#line 781
      if ((int )*(b + 24) == 81) {
#line 781
        d___8 ++;
      }
#line 782
      if ((int )*(b + 26) == 49) {
#line 782
        d___8 += 3;
#line 782
        if (*(b + 35)) {
#line 782
          if (*(b + 37)) {
#line 782
            d___8 += 4;
          }
        }
      }
#line 783
      if ((int )*(b + 27) == 33) {
#line 783
        d___8 += 5;
      }
#line 784
      if ((int )*(b + 28) == 65) {
#line 784
        if (*(pf + 8) != 0) {
#line 784
          d___8 += 2;
        }
      }
#line 786
      know->devel = (unsigned char )d___8;
#line 789
      if ((int )*(b + 54) == 17) {
#line 789
        if ((int )*(b + 55) == 17) {
#line 791
          if ((int )*(b + 65) != 18) {
#line 791
            if ((int )*(b + 64) != 18) {
#line 791
              d___8 = 12;
            } else {
#line 791
              d___8 = 6;
            }
          } else {
#line 791
            d___8 = 6;
          }
#line 792
          if ((int )*(b + 53) == 17) {
#line 792
            d___8 += 4;
          } else
#line 792
          if ((int )*(b + 56) == 17) {
#line 792
            d___8 += 4;
          }
#line 794
          mr += d___8;
        }
      }
#line 808
      d___8 = 0;
#line 809
      if (kp % 10 < 4) {
#line 809
        cneed = 0;
      } else
#line 809
      if (kp % 10 > 5) {
#line 809
        cneed = 0;
      } else {
#line 812
        cneed = 4;
#line 813
        if (! *(pf + 5)) {
#line 813
          cneed += 3;
        }
#line 814
        if (! *(xpf + 5)) {
#line 814
          cneed += 5;
        }
      }
      {
#line 819
      if ((int )know->castling == 0) {
#line 819
        goto case_0;
      }
#line 826
      if ((int )know->castling == 1) {
#line 826
        goto case_1;
      }
#line 832
      if ((int )know->castling == 2) {
#line 832
        goto case_2;
      }
#line 837
      if ((int )know->castling == 3) {
#line 837
        goto case_3;
      }
#line 817
      goto switch_break___5;
      case_0: /* CIL Label */ 
#line 820
      if (*(b + 26)) {
#line 820
        d___8 -= 2 * cneed;
      }
#line 821
      if (*(b + 27)) {
#line 821
        d___8 -= 2 * cneed;
      }
#line 822
      if (*(b + 22)) {
#line 822
        d___8 -= cneed;
      }
#line 823
      if (*(b + 23)) {
#line 823
        d___8 -= cneed;
      }
#line 824
      if (*(b + 24)) {
#line 824
        d___8 -= cneed;
      }
#line 825
      goto switch_break___5;
      case_1: /* CIL Label */ 
#line 827
      d___8 -= 20;
#line 828
      if (*(b + 22)) {
#line 828
        d___8 -= cneed;
      }
#line 829
      if (*(b + 23)) {
#line 829
        d___8 -= cneed;
      }
#line 830
      if (*(b + 24)) {
#line 830
        d___8 -= cneed;
      }
#line 831
      goto switch_break___5;
      case_2: /* CIL Label */ 
#line 833
      d___8 -= 8;
#line 834
      if (*(b + 26)) {
#line 834
        d___8 -= 2 * cneed;
      }
#line 835
      if (*(b + 27)) {
#line 835
        d___8 -= 2 * cneed;
      }
#line 836
      goto switch_break___5;
      case_3: /* CIL Label */ 
#line 838
      if (kp % 10 > 5) {
#line 840
        if ((int )*(b + 37) != 17) {
#line 840
          if ((int )*(b + 47) != 17) {
#line 840
            d___8 -= 10;
          }
        }
#line 841
        if ((int )*(b + 38) != 17) {
#line 841
          if ((int )*(b + 48) != 17) {
#line 841
            d___8 -= 8;
          }
        }
      } else
#line 843
      if (kp % 10 < 4) {
#line 845
        d___8 -= 15;
#line 846
        if ((int )*(b + 32) != 17) {
#line 846
          if ((int )*(b + 42) != 17) {
#line 846
            d___8 -= 10;
          }
        }
#line 847
        if ((int )*(b + 31) != 17) {
#line 847
          if ((int )*(b + 41) != 17) {
#line 847
            d___8 -= 8;
          }
        }
      } else {
#line 850
        d___8 -= 5 * cneed;
      }
#line 851
      goto switch_break___5;
      switch_break___5: /* CIL Label */ ;
      }
#line 854
      if (Totmat < 5000) {
#line 854
        d___8 /= 2;
      }
#line 856
      mr += d___8;
    }
#line 871
    i = 1;
    {
#line 871
    while (1) {
      while_continue___35: /* CIL Label */ ;
#line 871
      if (! (i != 9)) {
#line 871
        goto while_break___35;
      }
#line 871
      if (*(pf + i)) {
#line 873
        if (*(pf + i) > 1) {
#line 873
          mr -= 5;
#line 873
          er -= 10;
        }
#line 875
        if (*(pf + (i - 1)) == 0) {
#line 875
          if (*(pf + (i + 1)) == 0) {
#line 879
            pen = (int )((isofile[i] + (int const   )((2 + (int )isofile[i]) * (int )xknow->n)) + (int const   )(4 * (int )know->b));
#line 885
            if (*(xpf + i) == 0) {
#line 885
              if (xknow->r) {
#line 890
                j___2 = i + 20;
                {
#line 890
                while (1) {
                  while_continue___36: /* CIL Label */ ;
#line 890
                  if (! (j___2 < 99)) {
#line 890
                    goto while_break___36;
                  }
#line 890
                  if ((int )*(b + j___2) == 66) {
#line 891
                    pen += (int )rfip[i];
                  }
#line 890
                  j___2 += 10;
                }
                while_break___36: /* CIL Label */ ;
                }
#line 892
                pen += (int )((rfip[i] - 2) * (int const   )xknow->r);
              }
            }
#line 895
            if (*(pf + i) > 1) {
#line 895
              pen = pen * *(pf + i) + 2 * (int )isofile[i];
            }
#line 897
            mr += pen;
#line 897
            er += pen;
          }
        }
      }
#line 871
      i ++;
    }
    while_break___35: /* CIL Label */ ;
    }
#line 908
    i = 0;
    {
#line 908
    while (1) {
      while_continue___37: /* CIL Label */ ;
#line 908
      if (! (i != n___0)) {
#line 908
        goto while_break___37;
      }
#line 911
      sq = *(l + i);
      {
#line 914
      if ((int )*(b + sq) == 17) {
#line 914
        goto case_17___1;
      }
#line 1144
      if ((int )*(b + sq) == 97) {
#line 1144
        goto case_97;
      }
#line 1204
      if ((int )*(b + sq) == 65) {
#line 1204
        goto case_65___2;
      }
#line 1264
      if ((int )*(b + sq) == 49) {
#line 1264
        goto case_49___5;
      }
#line 1320
      if ((int )*(b + sq) == 33) {
#line 1320
        goto case_33___2;
      }
#line 1412
      if ((int )*(b + sq) == 81) {
#line 1412
        goto case_81___2;
      }
#line 912
      goto switch_break___6;
      case_17___1: /* CIL Label */ 
#line 916
      j___1 = sq + 10;
      {
#line 916
      while (1) {
        while_continue___38: /* CIL Label */ ;
#line 916
        if (! (j___1 < 91)) {
#line 916
          goto while_break___38;
        }
#line 917
        if ((int )*(b + (j___1 - 1)) == 18) {
#line 917
          goto not_passed;
        } else
#line 917
        if ((int )*(b + j___1) == 18) {
#line 917
          goto not_passed;
        } else
#line 917
        if ((int )*(b + (j___1 + 1)) == 18) {
#line 917
          goto not_passed;
        }
#line 916
        j___1 += 10;
      }
      while_break___38: /* CIL Label */ ;
      }
#line 926
      row___0 = sq / 10;
#line 927
      abonus = (int )P_advance[row___0];
#line 928
      ppeval = abonus;
#line 930
      if ((int )*(b + (sq + 10)) == 0) {
#line 932
        if (row___0 == 8) {
          {
#line 933
          tmp___14 = see(b, sq, sq + 10);
          }
#line 933
          if (tmp___14 >= 0) {
#line 933
            ppeval += 80;
          }
        } else
#line 935
        if (row___0 == 7) {
#line 935
          if ((int )*(b + (sq + 20)) == 0) {
            {
#line 936
            tmp___15 = see(b, sq, sq + 10);
            }
#line 936
            if (tmp___15 >= 0) {
              {
#line 936
              tmp___16 = see(b, sq, sq + 20);
              }
#line 936
              if (tmp___16 >= 0) {
#line 937
                ppeval += 50;
              }
            }
          }
        }
      } else
#line 940
      if (((int )*(b + (sq + 10)) & 3) == 2) {
#line 940
        ppeval -= abonus / 2;
      }
#line 943
      if (((int )*(b + (sq + 20)) & 3) == 2) {
#line 943
        ppeval -= abonus / 4;
      }
#line 946
      if ((int )*(b + (sq - 9)) == 17) {
#line 948
        ppeval += 2 * abonus;
      } else
#line 946
      if ((int )*(b + (sq - 11)) == 17) {
#line 948
        ppeval += 2 * abonus;
      } else
#line 946
      if ((int )*(b + (sq - 1)) == 17) {
#line 948
        ppeval += 2 * abonus;
      } else
#line 946
      if ((int )*(b + (sq + 1)) == 17) {
#line 948
        ppeval += 2 * abonus;
      }
#line 951
      j___1 = sq - 10;
      {
#line 951
      while (1) {
        while_continue___39: /* CIL Label */ ;
#line 951
        if (! ((int )*(b + j___1) == 0)) {
#line 951
          if (! ((int )*(b + j___1) == 65)) {
#line 951
            if (! ((int )*(b + j___1) == 66)) {
#line 951
              if (! ((int )*(b + j___1) == 82)) {
#line 951
                if (! ((int )*(b + j___1) == 81)) {
#line 951
                  goto while_break___39;
                }
              }
            }
          }
        }
#line 955
        if ((int )*(b + j___1) == 65) {
#line 956
          ppeval += abonus / 2 + 4;
        } else
#line 957
        if ((int )*(b + j___1) == 66) {
#line 958
          ppeval -= abonus / 2 + 9;
        }
#line 951
        j___1 -= 10;
      }
      while_break___39: /* CIL Label */ ;
      }
#line 960
      if (Totmat < 3000) {
#line 963
        difdis = (int )(2U * (xkdist + (sq + 10))->max - (unsigned int )(9 - row___0));
#line 965
        if (difdis >= 0) {
#line 965
          ppeval += 8 + 4 * difdis;
        }
#line 968
        if ((kdist + (sq + 10))->max < 2U) {
#line 968
          ppeval += abonus;
        }
      }
#line 971
      er += ppeval;
#line 972
      mr += ppeval / 2;
      not_passed: ;
#line 988
      if (sq <= 48) {
#line 988
        if ((int )*(b + (sq + 19)) == 18) {
#line 988
          goto _L___10;
        } else
#line 988
        if ((int )*(b + (sq + 21)) == 18) {
          _L___10: /* CIL Label */ 
#line 988
          if ((int )*(b + (sq + 10)) != 18) {
#line 988
            if ((int )*(b + (sq - 1)) != 17) {
#line 988
              if ((int )*(b + (sq + 1)) != 17) {
#line 988
                if ((int )*(b + (sq - 9)) != 17) {
#line 988
                  if ((int )*(b + (sq - 11)) != 17) {
#line 996
                    pen___0 = 0;
#line 1001
                    if (*(xpf + sq % 10) == 0) {
#line 1001
                      if (xknow->r) {
#line 1004
                        j___3 = sq % 10 + 20;
                        {
#line 1004
                        while (1) {
                          while_continue___40: /* CIL Label */ ;
#line 1004
                          if (! (j___3 < 99)) {
#line 1004
                            goto while_break___40;
                          }
#line 1004
                          if ((int )*(b + j___3) == 66) {
#line 1005
                            pen___0 += -2 + (int )(isofile[sq % 10] / 2);
                          }
#line 1004
                          j___3 += 10;
                        }
                        while_break___40: /* CIL Label */ ;
                        }
#line 1006
                        pen___0 += (int )(isofile[sq % 10] * (int const   )xknow->r);
                      }
                    }
#line 1009
                    mr += (int )(isofile[sq % 10] + (int const   )(pen___0 / 2));
#line 1010
                    er += -15 + pen___0;
                  }
                }
              }
            }
          }
        }
      }
#line 1024
      cannotmove = 0;
#line 1026
      if ((int )*(b + (sq + 10)) != 0) {
#line 1028
        mr -= 12 - sq / 10;
#line 1028
        er -= 12 - sq / 10;
#line 1029
        if (sq == 35) {
#line 1030
          mr -= 10;
#line 1030
          er -= 8;
        } else
#line 1029
        if (sq == 34) {
#line 1030
          mr -= 10;
#line 1030
          er -= 8;
        }
#line 1032
        if (*(b + (sq + 10))) {
#line 1034
          if (know->kstorm) {
#line 1034
            if (sq % 10 > 5) {
#line 1035
              mr -= 12;
            } else {
#line 1034
              goto _L___11;
            }
          } else
          _L___11: /* CIL Label */ 
#line 1037
          if (know->qstorm) {
#line 1037
            if (sq % 10 < 4) {
#line 1038
              mr -= 12;
            }
          }
#line 1040
          if ((int )*(b + (sq + 10)) == 18) {
#line 1040
            if (*(pf + (sq % 10 - 1)) == 0) {
#line 1040
              if (*(pf + (sq % 10 + 1)) == 0) {
#line 1049
                mr += 5;
#line 1049
                er += 8;
              }
            }
          }
        }
#line 1052
        cannotmove = 1;
      } else {
#line 1056
        ata = 0;
#line 1057
        if ((int )*(b + (sq - 1)) == 17) {
#line 1057
          ata ++;
        }
#line 1058
        if ((int )*(b + (sq + 1)) == 17) {
#line 1058
          ata ++;
        }
#line 1059
        if ((int )*(b + (sq + 9)) == 18) {
#line 1059
          ata --;
        }
#line 1060
        if ((int )*(b + (sq + 11)) == 18) {
#line 1060
          ata --;
        }
#line 1062
        if (ata < 1) {
#line 1064
          mr += -4 + ata;
#line 1064
          er += -8 + 2 * ata;
#line 1065
          cannotmove = 1;
        }
      }
#line 1069
      if (cannotmove) {
#line 1071
        p = 1 + ((int )*(b + (sq + 10)) == 18);
#line 1073
        if (Totmat < 1500) {
#line 1073
          er -= 6 * p;
        }
#line 1077
        if ((int )*(sqcolor + sq) & (int )know->bishopcolor) {
#line 1079
          if (sq == 55) {
#line 1081
            er -= 7 * p;
#line 1081
            mr -= 5 * p;
          } else
#line 1079
          if (sq == 54) {
#line 1081
            er -= 7 * p;
#line 1081
            mr -= 5 * p;
          } else
#line 1079
          if (sq == 45) {
#line 1081
            er -= 7 * p;
#line 1081
            mr -= 5 * p;
          } else
#line 1079
          if (sq == 44) {
#line 1081
            er -= 7 * p;
#line 1081
            mr -= 5 * p;
          } else {
#line 1083
            er -= 5 * p;
#line 1083
            mr -= 4 * p;
          }
        }
      }
#line 1089
      if ((int )*(b + (sq - 1)) == 17) {
#line 1089
        goto _L___12;
      } else
#line 1089
      if ((int )*(b + (sq - 9)) == 17) {
#line 1089
        goto _L___12;
      } else
#line 1089
      if ((int )*(b + (sq - 11)) == 17) {
        _L___12: /* CIL Label */ 
#line 1091
        if (sq >= 51) {
#line 1092
          mr += 6;
#line 1092
          er += 4;
        } else {
#line 1094
          mr += 2;
#line 1094
          er += 2;
        }
      }
#line 1097
      if (Totmat >= 3000) {
#line 1100
        if (*(outpost + sq)) {
#line 1102
          o = (int )(*(outpost + sq) + (int const   )(sq == 54));
#line 1103
          if ((int )*(b + (sq - 1)) == 17) {
#line 1103
            mr += 2 * o;
          }
#line 1104
          if ((int )*(b + (sq + 1)) == 17) {
#line 1104
            mr += 2 * o;
          }
#line 1105
          if ((int )*(b + (sq - 9)) == 17) {
#line 1105
            mr += 3 * o;
          } else
#line 1105
          if ((int )*(b + (sq - 11)) == 17) {
#line 1105
            mr += 3 * o;
          }
#line 1106
          if ((int )*(b + (sq + 9)) == 18) {
#line 1106
            mr -= 3 * o;
          } else
#line 1106
          if ((int )*(b + (sq + 11)) == 18) {
#line 1106
            mr -= 3 * o;
          }
#line 1107
          if ((unsigned long )b == (unsigned long )(B)) {
#line 1107
            mr += ((((int )P[sq] & 255) / 32) * 5) * o;
          } else {
#line 1108
            mr += ((((int )P[sq] >> 8) / 32) * 5) * o;
          }
        }
#line 1112
        if (know->qstorm) {
#line 1112
          mr += (int )*(qstormtable + sq);
        } else
#line 1113
        if (know->kstorm) {
#line 1113
          mr += (int )*(kstormtable + sq);
        }
#line 1116
        mr += (int )*(pmpb + sq);
#line 1119
        if (sq >= 51) {
#line 1121
          if ((int )know->castling == 3) {
#line 1123
            if (kp % 10 > 5) {
#line 1125
              if (sq % 10 > 6) {
#line 1126
                mr -= 10;
              }
            } else
#line 1130
            if (kp % 10 < 4) {
#line 1130
              if (sq % 10 < 3) {
#line 1131
                mr -= 8;
              }
            }
          } else
#line 1136
          if (sq % 10 < 3) {
#line 1137
            mr -= (int )know->devel;
          } else
#line 1138
          if (sq % 10 > 6) {
#line 1138
            mr -= 4 + (int )know->devel;
          }
        }
      }
#line 1143
      goto switch_break___6;
      case_97: /* CIL Label */ 
#line 1145
      er += (int )*(kepb + sq);
#line 1147
      if (Totmat >= 3000) {
#line 1149
        mr += (int )*(kmpb + sq);
        {
#line 1153
        if ((int )*(b + (sq - 1)) == 17) {
#line 1153
          goto case_17___2;
        }
#line 1154
        if ((int )*(b + (sq - 1)) == 49) {
#line 1154
          goto case_49___2;
        }
#line 1152
        goto switch_break___7;
        case_17___2: /* CIL Label */ 
#line 1153
        mr += 3;
#line 1153
        know->kshield = (signed char )((int )know->kshield + 1);
#line 1153
        goto switch_break___7;
        case_49___2: /* CIL Label */ 
#line 1154
        mr += 2;
#line 1154
        know->kshield = (signed char )((int )know->kshield + 1);
#line 1155
        if ((int )*(b + (sq + 9)) == 17) {
#line 1155
          mr += 2;
        }
        switch_break___7: /* CIL Label */ ;
        }
        {
#line 1158
        if ((int )*(b + (sq + 1)) == 17) {
#line 1158
          goto case_17___3;
        }
#line 1159
        if ((int )*(b + (sq + 1)) == 49) {
#line 1159
          goto case_49___3;
        }
#line 1157
        goto switch_break___8;
        case_17___3: /* CIL Label */ 
#line 1158
        mr += 3;
#line 1158
        know->kshield = (signed char )((int )know->kshield + 1);
#line 1158
        goto switch_break___8;
        case_49___3: /* CIL Label */ 
#line 1159
        mr += 2;
#line 1159
        know->kshield = (signed char )((int )know->kshield + 1);
#line 1160
        if ((int )*(b + (sq + 11)) == 17) {
#line 1160
          mr += 2;
        }
        switch_break___8: /* CIL Label */ ;
        }
        {
#line 1163
        if ((int )*(b + (sq + 10)) == 17) {
#line 1163
          goto case_17___4;
        }
#line 1167
        if ((int )*(b + (sq + 10)) == 49) {
#line 1167
          goto case_49___4;
        }
#line 1162
        goto switch_break___9;
        case_17___4: /* CIL Label */ 
#line 1163
        mr += 6;
#line 1163
        know->kshield = (signed char )((int )know->kshield + 2);
#line 1164
        if ((int )*(b + (sq + 9)) == 17) {
#line 1165
          mr += 3;
#line 1165
          know->kshield = (signed char )((int )know->kshield + 2);
        } else
#line 1164
        if ((int )*(b + (sq + 11)) == 17) {
#line 1165
          mr += 3;
#line 1165
          know->kshield = (signed char )((int )know->kshield + 2);
        }
#line 1166
        goto switch_break___9;
        case_49___4: /* CIL Label */ 
#line 1167
        mr += 2;
#line 1167
        know->kshield = (signed char )((int )know->kshield + 1);
#line 1168
        if ((int )*(b + (sq + 9)) == 17) {
#line 1168
          goto _L___13;
        } else
#line 1168
        if ((int )*(b + (sq + 11)) == 17) {
          _L___13: /* CIL Label */ 
#line 1170
          know->kshield = (signed char )((int )know->kshield + 1);
#line 1171
          if ((int )*(b + (sq + 20)) == 17) {
#line 1172
            mr += 2;
#line 1172
            know->kshield = (signed char )((int )know->kshield + 1);
          }
        }
        switch_break___9: /* CIL Label */ ;
        }
#line 1176
        if ((int )*(b + (sq + 20)) == 17) {
#line 1177
          know->kshield = (signed char )((int )know->kshield + 1);
#line 1178
          if ((int )*(b + (sq + 19)) == 17) {
#line 1179
            know->kshield = (signed char )((int )know->kshield + 1);
          } else
#line 1178
          if ((int )*(b + (sq + 21)) == 17) {
#line 1179
            know->kshield = (signed char )((int )know->kshield + 1);
          }
        }
#line 1182
        if ((int )*(b + (sq + 9)) == 17) {
#line 1182
          know->kshield = (signed char )((int )know->kshield + 1);
#line 1182
          mr += 4;
        }
#line 1184
        if ((int )*(b + (sq + 11)) == 17) {
#line 1184
          know->kshield = (signed char )((int )know->kshield + 1);
#line 1184
          mr += 4;
        }
#line 1186
        if (xknow->q) {
#line 1186
          goto _L___14;
        } else
#line 1186
        if ((int )xknow->r >= 2) {
          _L___14: /* CIL Label */ 
#line 1187
          file___0 = sq % 10;
#line 1188
          if (*(pf + file___0) == 0) {
#line 1188
            mr -= 6;
          }
#line 1189
          if (*(pf + (file___0 - 1)) == 0) {
#line 1189
            mr -= 3;
          }
#line 1190
          if (*(pf + (file___0 + 1)) == 0) {
#line 1190
            mr -= 3;
          }
#line 1192
          if (file___0 > 3) {
#line 1192
            if (file___0 < 6) {
#line 1194
              if (*(xpf + file___0) == 0) {
#line 1196
                if (*(pf + file___0) == 0) {
#line 1196
                  mr -= 8;
                } else {
#line 1197
                  mr -= 5;
                }
              }
            }
          }
        }
      }
#line 1203
      goto switch_break___6;
      case_65___2: /* CIL Label */ 
#line 1208
      mrr = 0;
#line 1208
      err = 0;
#line 1212
      j___4 = sq + 10;
      {
#line 1212
      while (1) {
        while_continue___41: /* CIL Label */ ;
#line 1212
        if (! ((int )*(b + j___4) == 0)) {
#line 1212
          if (! ((int )*(b + j___4) >= 64)) {
#line 1212
            goto while_break___41;
          }
        }
#line 1212
        j___4 += 10;
      }
      while_break___41: /* CIL Label */ ;
      }
#line 1214
      r___0 = j___4 / 10;
#line 1216
      if ((int )*(b + j___4) == 17) {
#line 1216
        if (*(b + (j___4 + 1))) {
#line 1216
          r___0 --;
        }
      }
#line 1218
      err = frb[r___0];
#line 1218
      mrr = err;
#line 1220
      if (*(xpf + sq % 10) != 0) {
#line 1220
        mrr -= 5;
      }
#line 1222
      if (*(pf + sq % 10) != 0) {
#line 1224
        mrr -= 5;
#line 1225
        if ((int )*(b + j___4) == 17) {
#line 1230
          if (sq == 28) {
#line 1230
            goto _L___15;
          } else
#line 1230
          if (sq == 38) {
#line 1230
            goto _L___15;
          } else
#line 1230
          if (sq == 27) {
            _L___15: /* CIL Label */ 
#line 1231
            if (kp == 26) {
#line 1232
              mrr -= 33;
#line 1232
              err -= 33;
            } else
#line 1231
            if (kp == 27) {
#line 1232
              mrr -= 33;
#line 1232
              err -= 33;
            }
          }
        }
      }
#line 1239
      b___0 = bon[(xkdist + sq)->min];
#line 1240
      if (b___0 > 0) {
#line 1242
        b___0 += r___0;
#line 1243
        if (know->qstorm) {
#line 1243
          mrr += b___0;
        } else
#line 1243
        if (know->kstorm) {
#line 1243
          mrr += b___0;
        }
#line 1244
        if (b___0 > 5) {
#line 1246
          if (b___0 > 8) {
#line 1246
            xknow->khung = (signed char )((int )xknow->khung + 2);
          } else {
#line 1247
            xknow->khung = (signed char )((int )xknow->khung + 1);
          }
        }
      }
#line 1252
      mrr += (int )*(rmpb + sq);
#line 1254
      mr += mrr;
#line 1254
      er += err;
#line 1263
      goto switch_break___6;
      case_49___5: /* CIL Label */ 
#line 1265
      if ((int )*(b + (sq + 10)) == 18) {
#line 1265
        goto _L___17;
      } else
#line 1265
      if (*(outpost + sq)) {
#line 1265
        if ((int )*(b + (sq - 9)) == 17) {
#line 1265
          goto _L___17;
        } else
#line 1265
        if ((int )*(b + (sq - 11)) == 17) {
          _L___17: /* CIL Label */ 
#line 1274
          j___5 = sq + 9;
          {
#line 1274
          while (1) {
            while_continue___42: /* CIL Label */ ;
#line 1274
            if (! (j___5 < 91)) {
#line 1274
              goto while_break___42;
            }
#line 1275
            if ((int )*(b + j___5) == 18) {
#line 1275
              goto no_bishop_outpost;
            } else
#line 1275
            if ((int )*(b + (j___5 + 2)) == 18) {
#line 1275
              goto no_bishop_outpost;
            }
#line 1274
            j___5 += 10;
          }
          while_break___42: /* CIL Label */ ;
          }
#line 1277
          bonus = 0;
#line 1278
          if ((int )*(b + (sq + 10)) == 18) {
#line 1278
            bonus += 12 * *(xpf + sq % 10);
          }
#line 1279
          if ((int )*(b + (sq + 20)) == 18) {
#line 1279
            bonus += 8;
          }
#line 1280
          if (*(outpost + sq)) {
#line 1280
            bonus += 10 + 4 * (int )*(outpost + sq);
          }
#line 1281
          if ((int )*(b + (sq - 9)) == 17) {
#line 1281
            bonus += 10;
          }
#line 1282
          if ((int )*(b + (sq - 11)) == 17) {
#line 1282
            bonus += 10;
          }
#line 1284
          mr += bonus;
#line 1284
          er += bonus / 2;
          no_bishop_outpost: ;
        }
      }
#line 1298
      if (sq == 81) {
#line 1300
        if ((int )*(b + 72) == 18) {
          {
#line 1300
          tmp___17 = see(b, 81, 72);
          }
#line 1300
          if (tmp___17 < -200) {
#line 1301
            mr -= 140;
#line 1301
            er -= 140;
          }
        }
      } else
#line 1304
      if (sq == 88) {
#line 1306
        if ((int )*(b + 77) == 18) {
          {
#line 1306
          tmp___18 = see(b, 88, 77);
          }
#line 1306
          if (tmp___18 < -200) {
#line 1307
            mr -= 140;
#line 1307
            er -= 140;
          }
        }
      }
#line 1310
      if (know->qstorm) {
#line 1315
        mr += bon___0[(xkdist + sq)->diag];
      } else
#line 1310
      if (know->kstorm) {
#line 1315
        mr += bon___0[(xkdist + sq)->diag];
      }
#line 1318
      mr += (int )*(bmpb + sq);
#line 1318
      er += (int )*(bepb + sq);
#line 1319
      goto switch_break___6;
      case_33___2: /* CIL Label */ 
#line 1321
      if ((int )*(b + (sq + 10)) == 18) {
#line 1321
        goto _L___19;
      } else
#line 1321
      if (*(outpost + sq)) {
#line 1321
        if ((int )*(b + (sq - 9)) == 17) {
#line 1321
          goto _L___19;
        } else
#line 1321
        if ((int )*(b + (sq - 11)) == 17) {
          _L___19: /* CIL Label */ 
#line 1330
          j___6 = sq + 9;
          {
#line 1330
          while (1) {
            while_continue___43: /* CIL Label */ ;
#line 1330
            if (! (j___6 < 91)) {
#line 1330
              goto while_break___43;
            }
#line 1331
            if ((int )*(b + j___6) == 18) {
#line 1331
              goto no_knight_outpost;
            } else
#line 1331
            if ((int )*(b + (j___6 + 2)) == 18) {
#line 1331
              goto no_knight_outpost;
            }
#line 1330
            j___6 += 10;
          }
          while_break___43: /* CIL Label */ ;
          }
#line 1333
          bonus___0 = 0;
#line 1334
          if ((int )*(b + (sq + 10)) == 18) {
#line 1334
            bonus___0 += 15 * *(xpf + sq % 10);
          }
#line 1335
          if (*(outpost + sq)) {
#line 1335
            bonus___0 += 8 + 5 * (int )*(outpost + sq);
          }
#line 1336
          if ((int )*(b + (sq - 9)) == 17) {
#line 1336
            bonus___0 += 10;
          }
#line 1337
          if ((int )*(b + (sq - 11)) == 17) {
#line 1337
            bonus___0 += 10;
          }
#line 1342
          if (sq >= 51) {
#line 1342
            if (sq % 10 >= 2) {
#line 1342
              if (sq % 10 <= 7) {
#line 1342
                if ((int )xknow->n == 0) {
#line 1342
                  if (((int )know->xbishopcolor & (int )*(sqcolor + sq)) == 0) {
#line 1342
                    if ((int )*(b + (sq - 9)) == 17) {
#line 1347
                      mr += 8 + 2 * (int )*(outpost + sq);
#line 1347
                      er += 15 + 4 * (int )*(outpost + sq);
                    } else
#line 1342
                    if ((int )*(b + (sq - 11)) == 17) {
#line 1347
                      mr += 8 + 2 * (int )*(outpost + sq);
#line 1347
                      er += 15 + 4 * (int )*(outpost + sq);
                    }
                  }
                }
              }
            }
          }
#line 1349
          mr += bonus___0;
#line 1349
          er += bonus___0 / 2;
          no_knight_outpost: ;
        }
      }
#line 1363
      if (sq == 91) {
#line 1365
        if ((int )*(b + 81) == 18) {
          {
#line 1365
          tmp___19 = see(b, 91, 83);
          }
#line 1365
          if (tmp___19 < -200) {
#line 1366
            mr -= 140;
#line 1366
            er -= 140;
          }
        }
      } else
#line 1368
      if (sq == 98) {
#line 1370
        if ((int )*(b + 88) == 18) {
          {
#line 1370
          tmp___20 = see(b, 98, 86);
          }
#line 1370
          if (tmp___20 < -200) {
#line 1371
            mr -= 140;
#line 1371
            er -= 140;
          }
        }
      } else
#line 1373
      if (sq == 81) {
#line 1375
        if ((int )*(b + 82) == 18) {
#line 1376
          if ((int )*(b + 71) == 18) {
#line 1377
            mr -= 45;
#line 1377
            er -= 45;
          } else
#line 1376
          if ((int )*(b + 73) == 18) {
#line 1377
            mr -= 45;
#line 1377
            er -= 45;
          }
        }
      } else
#line 1379
      if (sq == 88) {
#line 1381
        if ((int )*(b + 87) == 18) {
#line 1382
          if ((int )*(b + 78) == 18) {
#line 1383
            mr -= 45;
#line 1383
            er -= 45;
          } else
#line 1382
          if ((int )*(b + 76) == 18) {
#line 1383
            mr -= 45;
#line 1383
            er -= 45;
          }
        }
      }
#line 1386
      mr += (int )*(nmpb + sq);
#line 1388
      if (know->qstorm) {
#line 1393
        mr += bon___1[(xkdist + sq)->max];
      } else
#line 1388
      if (know->kstorm) {
#line 1393
        mr += bon___1[(xkdist + sq)->max];
      }
#line 1396
      if (Totmat < 3000) {
#line 1401
        if ((int )Wknow.rpf > (int )Bknow.rpf) {
#line 1401
          tmp___21 = (int )Wknow.rpf;
        } else {
#line 1401
          tmp___21 = (int )Bknow.rpf;
        }
#line 1401
        if ((int )Wknow.lpf < (int )Bknow.lpf) {
#line 1401
          tmp___22 = (int )Wknow.lpf;
        } else {
#line 1401
          tmp___22 = (int )Bknow.lpf;
        }
#line 1401
        d___9 = tmp___21 - tmp___22;
#line 1403
        if (d___9 > 3) {
#line 1404
          if (Totmat - 100 * ((int )Wknow.p + (int )Bknow.p) <= 700) {
#line 1405
            er -= 5 * d___9;
          } else {
#line 1406
            er -= 3 * d___9;
          }
        }
      }
#line 1410
      er += *(c_bonus + sq);
#line 1411
      goto switch_break___6;
      case_81___2: /* CIL Label */ 
#line 1415
      if ((int )know->devel >= 8) {
#line 1416
        if (sq >= 41) {
#line 1416
          mr -= 2 + (int )know->devel;
        }
      }
#line 1427
      if ((unsigned long )(B) == (unsigned long )b) {
#line 1427
        tmp___23 = (int )P[sq] >> 8;
      } else {
#line 1427
        tmp___23 = (int )P[*(Th + sq)] & 255;
      }
#line 1427
      if (tmp___23) {
#line 1429
        qb = -8;
      } else {
#line 1428
        qb = bon___2[(xkdist + sq)->taxi];
      }
#line 1431
      if (know->qstorm) {
#line 1431
        mr += 2 * qb;
      } else
#line 1431
      if (know->kstorm) {
#line 1431
        mr += 2 * qb;
      } else {
#line 1432
        mr += qb;
      }
#line 1433
      er += 3 * qb;
#line 1436
      mr += (int )*(qmpb + sq);
#line 1438
      goto switch_break___6;
      switch_break___6: /* CIL Label */ ;
      }
#line 908
      i ++;
    }
    while_break___37: /* CIL Label */ ;
    }
#line 1442
    if ((unsigned long )l == (unsigned long )(wl)) {
#line 1444
      midresult += mr;
#line 1444
      endresult += er;
#line 1445
      l = bl;
#line 1445
      n___0 = bn;
#line 1445
      b = mB;
#line 1446
      pf = bpf;
#line 1446
      xpf = wpf;
#line 1447
      know = & Bknow;
#line 1447
      xknow = & Wknow;
#line 1448
      kp = (int )*(Th + Bknow.kp);
#line 1448
      xkp = (int )*(Th + Wknow.kp);
    } else {
#line 1452
      midresult -= mr;
#line 1452
      endresult -= er;
#line 1453
      goto while_break___34;
    }
  }
  while_break___34: /* CIL Label */ ;
  }
#line 1460
  if (Totmat >= 3000) {
#line 1463
    if (Color == 1) {
#line 1463
      if ((int )Wknow.devel > 1) {
#line 1463
        if ((int )Wknow.hung < 10) {
#line 1463
          Wknow.devel = (unsigned char )((int )Wknow.devel - 2);
        }
      }
    } else
#line 1464
    if ((int )Bknow.devel > 1) {
#line 1464
      if ((int )Bknow.hung < 10) {
#line 1464
        Bknow.devel = (unsigned char )((int )Bknow.devel - 2);
      }
    }
#line 1467
    d___10 = (int )Bknow.devel - (int )Wknow.devel;
#line 1468
    if ((int )Wknow.devel > (int )Bknow.devel) {
#line 1468
      tmp___24 = (int )Wknow.devel;
    } else {
#line 1468
      tmp___24 = (int )Bknow.devel;
    }
#line 1468
    d___10 = 4 * d___10 + (d___10 * tmp___24) / 8;
#line 1470
    midresult += d___10;
  } else {
#line 1484
    whas = 0;
#line 1484
    bhas = 0;
#line 1489
    wrm = (int )Wknow.rpf;
#line 1490
    wlm = (int )Wknow.lpf;
#line 1491
    brm = (int )Bknow.rpf;
#line 1492
    blm = (int )Bknow.lpf;
#line 1495
    if (wlm + 1 < blm) {
#line 1495
      if (wrm > wlm + 3) {
#line 1495
        whas = blm - wlm;
      } else {
#line 1495
        goto _L___20;
      }
    } else
    _L___20: /* CIL Label */ 
#line 1497
    if (blm + 1 < wlm) {
#line 1497
      if (brm > blm + 3) {
#line 1497
        bhas = wlm - blm;
      }
    }
#line 1500
    if (wrm - 1 > brm) {
#line 1500
      if (wrm > wlm + 3) {
#line 1500
        whas += wrm - brm;
      } else {
#line 1500
        goto _L___21;
      }
    } else
    _L___21: /* CIL Label */ 
#line 1502
    if (brm - 1 > wrm) {
#line 1502
      if (brm > blm + 3) {
#line 1502
        bhas += brm - wrm;
      }
    }
#line 1504
    endresult += ((Oppb[whas] - Oppb[bhas]) * 1050) / ((1050 + Totmat) - 100 * ((int )Wknow.p + (int )Bknow.p));
  }
#line 1509
  midresult += ((int )Bknow.khung - (int )Wknow.khung) * 2;
#line 1512
  Wknow.khung = (signed char )((int )Wknow.khung - (int )Wknow.kshield / 3);
#line 1513
  Bknow.khung = (signed char )((int )Bknow.khung - (int )Bknow.kshield / 3);
#line 1514
  if ((int )Wknow.khung > 1) {
#line 1516
    midresult -= (int )Wknow.khung * (int )Wknow.khung;
  }
#line 1523
  if ((int )Bknow.khung > 1) {
#line 1525
    midresult += (int )Bknow.khung * (int )Bknow.khung;
  }
#line 1532
  if ((int )Wknow.hung < 10) {
#line 1532
    if ((int )Wknow.khung < 2) {
#line 1532
      tmp___25 = 1;
    } else {
#line 1532
      tmp___25 = 0;
    }
  } else {
#line 1532
    tmp___25 = 0;
  }
#line 1532
  Wknow.prune = (signed char )tmp___25;
#line 1533
  if ((int )Bknow.hung < 10) {
#line 1533
    if ((int )Bknow.khung < 2) {
#line 1533
      tmp___26 = 1;
    } else {
#line 1533
      tmp___26 = 0;
    }
  } else {
#line 1533
    tmp___26 = 0;
  }
#line 1533
  Bknow.prune = (signed char )tmp___26;
#line 1539
  tbonus = (int )G[Counter].mtrl - (int )G[Counter].xmtrl;
#line 1540
  if (tbonus != 0) {
#line 1544
    if (Color == 2) {
#line 1544
      tbonus = - tbonus;
    }
#line 1546
    if (tbonus > 0) {
#line 1548
      if (Wknow.p) {
#line 1549
        r___1 = (tbonus * (int )Wknow.p - tbonus * (((2 * (int )Bknow.q + (int )Bknow.b) + (int )Bknow.r) + (int )Bknow.n)) / 30;
      } else
#line 1548
      if (tbonus >= 450) {
#line 1549
        r___1 = (tbonus * (int )Wknow.p - tbonus * (((2 * (int )Bknow.q + (int )Bknow.b) + (int )Bknow.r) + (int )Bknow.n)) / 30;
      } else {
#line 1553
        r___1 = - tbonus / 2;
      }
    } else
#line 1557
    if (Bknow.p) {
#line 1558
      r___1 = (tbonus * (int )Bknow.p - tbonus * (((2 * (int )Wknow.q + (int )Wknow.b) + (int )Wknow.r) + (int )Wknow.n)) / 30;
    } else
#line 1557
    if (tbonus <= 450) {
#line 1558
      r___1 = (tbonus * (int )Bknow.p - tbonus * (((2 * (int )Wknow.q + (int )Wknow.b) + (int )Wknow.r) + (int )Wknow.n)) / 30;
    } else {
#line 1562
      r___1 = - tbonus / 2;
    }
#line 1565
    endresult += r___1;
#line 1566
    midresult += r___1 / 2;
  }
#line 1575
  if (Totmat < 3000) {
#line 1575
    result += endresult;
  } else
#line 1576
  if (Totmat > 6000) {
#line 1576
    result += midresult;
  } else {
#line 1577
    result += ((Totmat - 3000) * midresult) / 3000 + ((6000 - Totmat) * endresult) / 3000;
  }
#line 1581
  if (Totmat < 3000) {
#line 1582
    if (Wknow.bishopcolor) {
#line 1582
      if (Wknow.xbishopcolor) {
#line 1582
        if ((int )Wknow.bishopcolor + (int )Wknow.xbishopcolor == 3) {
#line 1582
          if ((int )Wknow.n == 0) {
#line 1582
            if ((int )Wknow.r == 0) {
#line 1582
              if ((int )Wknow.q == 0) {
#line 1582
                if ((int )Bknow.n == 0) {
#line 1582
                  if ((int )Bknow.r == 0) {
#line 1582
                    if ((int )Bknow.q == 0) {
#line 1588
                      difference = ((int )G[Counter].mtrl - (int )G[Counter].xmtrl) / 4;
#line 1589
                      result /= 2;
#line 1590
                      if (difference > 0) {
#line 1591
                        if (Color == 1) {
#line 1591
                          result -= 50 + difference;
                        } else {
#line 1592
                          result += 50 + difference;
                        }
                      } else
#line 1594
                      if (difference < 0) {
#line 1595
                        if (Color == 1) {
#line 1595
                          result += 50 - difference;
                        } else {
#line 1596
                          result -= 50 - difference;
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
#line 1601
  if (Color == 1) {
#line 1601
    return (result + 4);
  } else {
#line 1602
    return (- result - 4);
  }
}
}
#line 8 "/home/wheatley/newnew/temp/phalanx-22+d051004/genmoves.c"
unsigned char pin[120]  ;
#line 9 "/home/wheatley/newnew/temp/phalanx-22+d051004/genmoves.c"
unsigned char tar[120]  ;
#line 18 "/home/wheatley/newnew/temp/phalanx-22+d051004/genmoves.c"
static int wl___0[16]  ;
#line 19 "/home/wheatley/newnew/temp/phalanx-22+d051004/genmoves.c"
static int bl___0[16]  ;
#line 24 "/home/wheatley/newnew/temp/phalanx-22+d051004/genmoves.c"
static unsigned int backup  ;
#line 15 "/home/wheatley/newnew/temp/phalanx-22+d051004/genmoves.c"
int see(tsquare *b , int from , int square___0 ) 
{ 
  int wn___0 ;
  int bn___0 ;
  int color ;
  int i ;
  int p ;
  int minwn ;
  int minbn ;
  int step ;
  int minw ;
  int minb ;
  int dest ;
  int j ;
  int val ;
  int wi ;
  int bi ;
  int result ;
  int alpha ;
  int beta ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 21
  color = (int )*(b + from) & 3;
#line 28
  bn___0 = 1;
#line 28
  wn___0 = bn___0;
#line 29
  if (color == 1) {
#line 30
    wl___0[0] = Values[(int )*(b + from) >> 4];
#line 31
    bl___0[0] = Values[(int )*(b + square___0) >> 4];
  } else {
#line 34
    wl___0[0] = Values[(int )*(b + square___0) >> 4];
#line 35
    bl___0[0] = Values[(int )*(b + from) >> 4];
  }
#line 38
  backup = (unsigned int )*(b + from);
#line 38
  *(b + from) = (tsquare )0;
#line 40
  if ((int )*(b + (square___0 - 9)) == 17) {
#line 40
    wl___0[wn___0] = 100;
#line 40
    wn___0 ++;
  }
#line 41
  if ((int )*(b + (square___0 - 11)) == 17) {
#line 41
    wl___0[wn___0] = 100;
#line 41
    wn___0 ++;
  }
#line 42
  if ((int )*(b + (square___0 + 9)) == 18) {
#line 42
    bl___0[bn___0] = 100;
#line 42
    bn___0 ++;
  }
#line 43
  if ((int )*(b + (square___0 + 11)) == 18) {
#line 43
    bl___0[bn___0] = 100;
#line 43
    bn___0 ++;
  }
#line 45
  i = 0;
  {
#line 45
  while (1) {
    while_continue: /* CIL Label */ ;
#line 45
    if (! (i != 8)) {
#line 45
      goto while_break;
    }
#line 45
    p = (int )*(b + (square___0 + N_moves[i]));
#line 45
    if (p) {
      {
#line 47
      if (p == 33) {
#line 47
        goto case_33;
      }
#line 48
      if (p == 34) {
#line 48
        goto case_34;
      }
#line 46
      goto switch_break;
      case_33: /* CIL Label */ 
#line 47
      wl___0[wn___0] = 350;
#line 47
      wn___0 ++;
#line 47
      goto switch_break;
      case_34: /* CIL Label */ 
#line 48
      bl___0[bn___0] = 350;
#line 48
      bn___0 ++;
#line 48
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
#line 45
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 51
  minwn = wn___0;
#line 51
  wl___0[minwn] = 30000;
#line 52
  minbn = bn___0;
#line 52
  bl___0[minbn] = 30000;
#line 54
  i = 0;
  {
#line 54
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 54
    if (! (i != 8)) {
#line 54
      goto while_break___0;
    }
#line 55
    step = RB_dirs[i];
#line 56
    minw = minwn;
#line 57
    minb = minbn;
#line 58
    dest = square___0;
    {
#line 59
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 61
      dest += step;
      {
#line 62
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 62
        if (! ((int )*(b + dest) == 0)) {
#line 62
          goto while_break___2;
        }
#line 62
        dest += step;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 63
      p = (int )*(b + dest);
#line 64
      if (p == 3) {
#line 64
        goto while_break___1;
      } else
#line 64
      if ((p & 252) == 32) {
#line 64
        goto while_break___1;
      }
#line 65
      if (i < 4) {
#line 65
        if ((p & 252) == 48) {
#line 65
          goto while_break___1;
        }
      } else
#line 66
      if ((p & 252) == 64) {
#line 66
        goto while_break___1;
      }
#line 67
      if (p == 97) {
#line 69
        if (dest - step == square___0) {
#line 70
          wl___0[wn___0] = 30000;
#line 70
          wn___0 ++;
#line 71
          wl___0[wn___0] = 30000;
        }
#line 72
        goto while_break___1;
      } else
#line 74
      if (p == 98) {
#line 76
        if (dest - step == square___0) {
#line 77
          bl___0[bn___0] = 30000;
#line 77
          bn___0 ++;
#line 78
          bl___0[bn___0] = 30000;
        }
#line 79
        goto while_break___1;
      } else
#line 81
      if (p == 17) {
#line 83
        if (dest - square___0 == 9) {
#line 84
          goto __Cont;
        } else
#line 83
        if (dest - square___0 == 11) {
#line 84
          goto __Cont;
        } else {
#line 84
          goto while_break___1;
        }
      } else
#line 86
      if (p == 18) {
#line 88
        if (dest - square___0 == -9) {
#line 89
          goto __Cont;
        } else
#line 88
        if (dest - square___0 == -11) {
#line 89
          goto __Cont;
        } else {
#line 89
          goto while_break___1;
        }
      } else {
#line 94
        val = Values[p >> 4];
#line 95
        if ((p & 3) == 1) {
          {
#line 97
          while (1) {
            while_continue___3: /* CIL Label */ ;
#line 97
            if (! (wl___0[minw] <= val)) {
#line 97
              goto while_break___3;
            }
#line 97
            minw ++;
          }
          while_break___3: /* CIL Label */ ;
          }
#line 98
          j = wn___0 + 1;
          {
#line 98
          while (1) {
            while_continue___4: /* CIL Label */ ;
#line 98
            if (! (j != minw)) {
#line 98
              goto while_break___4;
            }
#line 99
            wl___0[j] = wl___0[j - 1];
#line 98
            j --;
          }
          while_break___4: /* CIL Label */ ;
          }
#line 100
          wl___0[minw] = val;
#line 101
          wn___0 ++;
#line 101
          wl___0[wn___0] = 30000;
#line 102
          minw ++;
        } else {
          {
#line 106
          while (1) {
            while_continue___5: /* CIL Label */ ;
#line 106
            if (! (bl___0[minb] <= val)) {
#line 106
              goto while_break___5;
            }
#line 106
            minb ++;
          }
          while_break___5: /* CIL Label */ ;
          }
#line 107
          j = bn___0 + 1;
          {
#line 107
          while (1) {
            while_continue___6: /* CIL Label */ ;
#line 107
            if (! (j != minb)) {
#line 107
              goto while_break___6;
            }
#line 108
            bl___0[j] = bl___0[j - 1];
#line 107
            j --;
          }
          while_break___6: /* CIL Label */ ;
          }
#line 109
          bl___0[minb] = val;
#line 110
          bn___0 ++;
#line 110
          bl___0[bn___0] = 30000;
#line 111
          minb ++;
        }
      }
      __Cont: /* CIL Label */ ;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 54
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 116
  *(b + from) = (tsquare )backup;
#line 125
  wi = 0;
#line 125
  bi = 0;
#line 125
  result = 0;
#line 126
  alpha = -30000;
#line 126
  beta = 30000;
#line 128
  if (color == 2) {
#line 129
    result -= wl___0[wi];
#line 129
    wi ++;
#line 129
    alpha = result;
  }
  {
#line 131
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 133
    if (wi == wn___0) {
#line 133
      if (color == 1) {
#line 133
        tmp = alpha;
      } else {
#line 133
        tmp = - alpha;
      }
#line 133
      return (tmp);
    } else {
#line 136
      result += bl___0[bi];
#line 136
      bi ++;
#line 137
      if (result < beta) {
#line 138
        if (result < alpha) {
#line 138
          if (color == 1) {
#line 138
            tmp___0 = alpha;
          } else {
#line 138
            tmp___0 = - alpha;
          }
#line 138
          return (tmp___0);
        }
#line 138
        beta = result;
      }
    }
#line 144
    if (bi == bn___0) {
#line 144
      if (color == 1) {
#line 144
        tmp___1 = beta;
      } else {
#line 144
        tmp___1 = - beta;
      }
#line 144
      return (tmp___1);
    } else {
#line 147
      result -= wl___0[wi];
#line 147
      wi ++;
#line 148
      if (result > alpha) {
#line 149
        if (result > beta) {
#line 149
          if (color == 1) {
#line 149
            tmp___2 = beta;
          } else {
#line 149
            tmp___2 = - beta;
          }
#line 149
          return (tmp___2);
        }
#line 149
        alpha = result;
      }
    }
  }
  while_break___7: /* CIL Label */ ;
  }
}
}
#line 161 "/home/wheatley/newnew/temp/phalanx-22+d051004/genmoves.c"
void find_pins(int check ) 
{ 
  int d ;
  int square___0 ;
  int step ;
  int destination___0 ;
  int mark ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 165
  if (check) {
    {
#line 165
    memset((void *)(pin + 20), 1, 80UL * sizeof(char ));
    }
#line 165
    return;
  }
  {
#line 167
  memset((void *)(pin + 20), 0, 80UL * sizeof(char ));
#line 169
  square___0 = (int )L[Color].next;
#line 171
  pin[square___0] = (unsigned char)1;
#line 173
  d = 0;
  }
  {
#line 173
  while (1) {
    while_continue: /* CIL Label */ ;
#line 173
    if (! (d != 8)) {
#line 173
      goto while_break;
    }
#line 175
    step = RB_dirs[d];
#line 176
    destination___0 = square___0;
#line 177
    mark = 0;
    {
#line 178
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 179
      destination___0 += step;
#line 180
      if (B[destination___0]) {
#line 182
        if (((int )B[destination___0] & 3) == Color) {
#line 184
          if (mark) {
#line 184
            goto while_break___0;
          }
#line 185
          mark = destination___0;
        } else {
#line 189
          if (mark) {
            {
#line 193
            if (((int )B[destination___0] & 252) == 80) {
#line 193
              goto case_80;
            }
#line 196
            if (((int )B[destination___0] & 252) == 64) {
#line 196
              goto case_64;
            }
#line 199
            if (((int )B[destination___0] & 252) == 48) {
#line 199
              goto case_48;
            }
#line 191
            goto switch_break;
            case_80: /* CIL Label */ 
            {
#line 194
            tmp = abs(step);
#line 194
            pin[mark] = (unsigned char )tmp;
            }
#line 195
            goto switch_break;
            case_64: /* CIL Label */ 
#line 197
            if (d < 4) {
              {
#line 197
              tmp___0 = abs(step);
#line 197
              pin[mark] = (unsigned char )tmp___0;
              }
            }
#line 198
            goto switch_break;
            case_48: /* CIL Label */ 
#line 200
            if (d > 3) {
              {
#line 200
              tmp___1 = abs(step);
#line 200
              pin[mark] = (unsigned char )tmp___1;
              }
            }
#line 201
            goto switch_break;
            switch_break: /* CIL Label */ ;
            }
          }
#line 204
          goto while_break___0;
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 173
    d ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 221
  return;
}
}
#line 225 "/home/wheatley/newnew/temp/phalanx-22+d051004/genmoves.c"
void find_targets(void) 
{ 
  int d ;
  int square___0 ;
  int step ;
  int destination___0 ;

  {
  {
#line 230
  memset((void *)(tar + 20), 0, 80UL * sizeof(char ));
#line 232
  square___0 = (int )L[Color ^ 3].next;
#line 234
  d = 0;
  }
  {
#line 234
  while (1) {
    while_continue: /* CIL Label */ ;
#line 234
    if (! (d != 8)) {
#line 234
      goto while_break;
    }
#line 236
    step = RB_dirs[d];
#line 237
    destination___0 = square___0;
    {
#line 238
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 239
      destination___0 += step;
#line 240
      if (B[destination___0]) {
#line 240
        goto while_break___0;
      }
#line 241
      if (d < 4) {
#line 241
        tar[destination___0] = (unsigned char)64;
      } else {
#line 242
        tar[destination___0] = (unsigned char)48;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 245
    destination___0 = square___0 + N_moves[d];
#line 245
    if ((int )B[destination___0] == 0) {
#line 245
      tar[destination___0] = (unsigned char)32;
    }
#line 234
    d ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 259
  return;
}
}
#line 267 "/home/wheatley/newnew/temp/phalanx-22+d051004/genmoves.c"
int square  ;
#line 267 "/home/wheatley/newnew/temp/phalanx-22+d051004/genmoves.c"
int destination  ;
#line 271 "/home/wheatley/newnew/temp/phalanx-22+d051004/genmoves.c"
void lm(tmove *m___1 , unsigned char In2a , unsigned char Special , int *i ) 
{ 
  unsigned char tmp ;
  unsigned char tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 277
  tmp = (unsigned char )square;
#line 277
  m___1->from = tmp;
#line 277
  m___1->in1 = B[tmp];
#line 278
  tmp___0 = (unsigned char )destination;
#line 278
  m___1->to = tmp___0;
#line 278
  m___1->in2 = B[tmp___0];
#line 279
  m___1->in2a = In2a;
#line 280
  m___1->dch = (short)100;
#line 281
  m___1->value = (short)0;
#line 282
  m___1->special = Special;
#line 283
  if ((int )m___1->special != 0) {
#line 283
    goto _L;
  } else
#line 283
  if (pin[m___1->from]) {
    _L: /* CIL Label */ 
    {
#line 285
    do_move(m___1);
    }
#line 286
    if ((Color ^ 3) == 1) {
#line 286
      tmp___1 = (int )L[1].next;
    } else {
#line 286
      tmp___1 = (int )L[2].next;
    }
    {
#line 286
    tmp___2 = attacktest(tmp___1, (Color ^ 3) ^ 3);
    }
#line 286
    if (! tmp___2) {
#line 286
      (*i) ++;
    }
    {
#line 287
    undo_move(m___1);
    }
  } else {
#line 288
    (*i) ++;
  }
#line 290
  return;
}
}
#line 306 "/home/wheatley/newnew/temp/phalanx-22+d051004/genmoves.c"
void generate_legal_moves(tmove *moves , int *n___1 , int check ) 
{ 
  int i ;
  unsigned int pbs ;
  unsigned int piece___0 ;
  unsigned int piece___1 ;
  unsigned int piece___2 ;
  unsigned int piece___3 ;
  int j ;
  int *mov ;
  int *tmp ;
  int d ;
  int d1 ;
  int tmp___0 ;
  int d2 ;
  int tmp___1 ;
  int step ;
  int c ;
  int special ;
  int tmp___2 ;
  register tmove *m___1 ;
  int tmp___3 ;
  int tmp___4 ;
  register tmove *m___2 ;
  int tmp___5 ;
  int tmp___6 ;
  register tmove *m___3 ;
  int tmp___7 ;
  int tmp___8 ;
  register tmove *m___4 ;
  int tmp___9 ;
  int tmp___10 ;

  {
  {
#line 309
  i = 0;
#line 311
  find_pins(check);
#line 313
  square = (int )L[Color].next;
  }
  {
#line 313
  while (1) {
    while_continue: /* CIL Label */ ;
#line 313
    if (! (square != 0)) {
#line 313
      goto while_break;
    }
#line 315
    pbs = (unsigned int )((int )B[square] & 252);
    {
#line 318
    if (pbs == 16U) {
#line 318
      goto case_16;
    }
#line 387
    if (pbs == 96U) {
#line 387
      goto case_96;
    }
#line 387
    if (pbs == 32U) {
#line 387
      goto case_96;
    }
#line 397
    goto switch_default;
    case_16: /* CIL Label */ 
#line 319
    if (Color == 1) {
#line 320
      destination = square + 10;
#line 321
      if ((int )B[destination] == 0) {
#line 323
        if (destination < 91) {
          {
#line 324
          lm(moves + i, (unsigned char)17, (unsigned char)0, & i);
          }
        } else {
#line 328
          piece___0 = 81U;
          {
#line 328
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 328
            if (! (piece___0 != 17U)) {
#line 328
              goto while_break___0;
            }
            {
#line 329
            lm(moves + i, (unsigned char )piece___0, (unsigned char)0, & i);
#line 328
            piece___0 -= 16U;
            }
          }
          while_break___0: /* CIL Label */ ;
          }
        }
#line 331
        if (square < 41) {
#line 332
          destination += 10;
#line 333
          if ((int )B[destination] == 0) {
            {
#line 334
            lm(moves + i, B[square], (unsigned char)0, & i);
            }
          }
        }
      }
#line 337
      destination = square + 9;
      {
#line 337
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 337
        if (! (destination != square + 13)) {
#line 337
          goto while_break___1;
        }
#line 340
        if (((int )B[destination] & 3) == 2) {
#line 342
          if (destination < 91) {
            {
#line 343
            lm(moves + i, (unsigned char)17, (unsigned char)0, & i);
            }
          } else {
#line 347
            piece___1 = 81U;
            {
#line 347
            while (1) {
              while_continue___2: /* CIL Label */ ;
#line 347
              if (! (piece___1 != 17U)) {
#line 347
                goto while_break___2;
              }
              {
#line 348
              lm(moves + i, (unsigned char )piece___1, (unsigned char)0, & i);
#line 347
              piece___1 -= 16U;
              }
            }
            while_break___2: /* CIL Label */ ;
            }
          }
        }
#line 337
        destination += 2;
      }
      while_break___1: /* CIL Label */ ;
      }
    } else {
#line 353
      destination = square - 10;
#line 354
      if ((int )B[destination] == 0) {
#line 356
        if (destination > 28) {
          {
#line 357
          lm(moves + i, (unsigned char)18, (unsigned char)0, & i);
          }
        } else {
#line 361
          piece___2 = 82U;
          {
#line 361
          while (1) {
            while_continue___3: /* CIL Label */ ;
#line 361
            if (! (piece___2 != 18U)) {
#line 361
              goto while_break___3;
            }
            {
#line 362
            lm(moves + i, (unsigned char )piece___2, (unsigned char)0, & i);
#line 361
            piece___2 -= 16U;
            }
          }
          while_break___3: /* CIL Label */ ;
          }
        }
#line 365
        if (square > 78) {
#line 366
          destination -= 10;
#line 367
          if ((int )B[destination] == 0) {
            {
#line 368
            lm(moves + i, (unsigned char)18, (unsigned char)0, & i);
            }
          }
        }
      }
#line 371
      destination = square - 9;
      {
#line 371
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 371
        if (! (destination != square - 13)) {
#line 371
          goto while_break___4;
        }
#line 374
        if (((int )B[destination] & 3) == 1) {
#line 376
          if (destination > 28) {
            {
#line 377
            lm(moves + i, (unsigned char)18, (unsigned char)0, & i);
            }
          } else {
#line 381
            piece___3 = 82U;
            {
#line 381
            while (1) {
              while_continue___5: /* CIL Label */ ;
#line 381
              if (! (piece___3 != 18U)) {
#line 381
                goto while_break___5;
              }
              {
#line 382
              lm(moves + i, (unsigned char )piece___3, (unsigned char)0, & i);
#line 381
              piece___3 -= 16U;
              }
            }
            while_break___5: /* CIL Label */ ;
            }
          }
        }
#line 371
        destination -= 2;
      }
      while_break___4: /* CIL Label */ ;
      }
    }
#line 386
    goto switch_break;
    case_96: /* CIL Label */ 
    case_32: /* CIL Label */ 
#line 389
    if (pbs == 96U) {
#line 389
      tmp = RB_dirs;
    } else {
#line 389
      tmp = N_moves;
    }
#line 389
    mov = tmp;
#line 390
    j = 0;
    {
#line 390
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 390
      if (! (j != 8)) {
#line 390
        goto while_break___6;
      }
#line 391
      destination = square + *(mov + j);
#line 392
      if (! (((int )B[destination] & 3) & Color)) {
        {
#line 393
        lm(moves + i, B[square], (unsigned char)0, & i);
        }
      }
#line 390
      j ++;
    }
    while_break___6: /* CIL Label */ ;
    }
#line 396
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 399
    if (pbs == 48U) {
#line 399
      tmp___0 = 4;
    } else {
#line 399
      tmp___0 = 0;
    }
#line 399
    d1 = tmp___0;
#line 400
    if (pbs == 64U) {
#line 400
      tmp___1 = 4;
    } else {
#line 400
      tmp___1 = 8;
    }
#line 400
    d2 = tmp___1;
#line 401
    d = d1;
    {
#line 401
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 401
      if (! (d != d2)) {
#line 401
        goto while_break___7;
      }
#line 402
      step = RB_dirs[d];
#line 403
      destination = square;
      {
#line 404
      while (1) {
        while_continue___8: /* CIL Label */ ;
#line 405
        destination += step;
#line 406
        if (! (((int )B[destination] & 3) & Color)) {
          {
#line 407
          lm(moves + i, B[square], (unsigned char)0, & i);
          }
        }
#line 408
        if (B[destination]) {
#line 408
          goto while_break___8;
        }
      }
      while_break___8: /* CIL Label */ ;
      }
#line 401
      d ++;
    }
    while_break___7: /* CIL Label */ ;
    }
    switch_break: /* CIL Label */ ;
    }
#line 313
    square = (int )L[square].next;
  }
  while_break: /* CIL Label */ ;
  }
#line 417
  if (Counter != 0) {
#line 419
    c = Counter - 1;
#line 420
    if (((int )G[c].m.in1 & 252) == 16) {
      {
#line 420
      tmp___2 = abs((int )G[c].m.from - (int )G[c].m.to);
      }
#line 420
      if (tmp___2 == 20) {
#line 423
        square = (int )G[c].m.to - 1;
        {
#line 423
        while (1) {
          while_continue___9: /* CIL Label */ ;
#line 423
          if (! (square != (int )G[c].m.to + 3)) {
#line 423
            goto while_break___9;
          }
#line 424
          if ((int )B[square] == 16 + Color) {
#line 426
            special = (int )G[c].m.to;
#line 427
            if (Color == 1) {
#line 427
              destination = special + 10;
            } else {
#line 427
              destination = special - 10;
            }
            {
#line 428
            lm(moves + i, B[square], (unsigned char )special, & i);
            }
          }
#line 423
          square += 2;
        }
        while_break___9: /* CIL Label */ ;
        }
      }
    }
  }
#line 434
  if (! check) {
#line 436
    if (Color == 1) {
#line 439
      if (((int )G[Counter].castling & 1) == 0) {
#line 440
        if ((int )B[26] == 0) {
#line 440
          if ((int )B[27] == 0) {
            {
#line 441
            tmp___3 = attacktest(26, 2);
            }
#line 441
            if (! tmp___3) {
              {
#line 441
              tmp___4 = attacktest(27, 2);
              }
#line 441
              if (! tmp___4) {
#line 442
                m___1 = moves + i;
#line 442
                m___1->from = (unsigned char)21;
#line 442
                m___1->to = (unsigned char)21;
#line 442
                m___1->dch = (short)100;
#line 442
                m___1->special = (unsigned char)1;
#line 442
                i ++;
              }
            }
          }
        }
      }
#line 444
      if (((int )G[Counter].castling & 2) == 0) {
#line 445
        if ((int )B[22] == 0) {
#line 445
          if ((int )B[23] == 0) {
#line 445
            if ((int )B[24] == 0) {
              {
#line 446
              tmp___5 = attacktest(23, 2);
              }
#line 446
              if (! tmp___5) {
                {
#line 446
                tmp___6 = attacktest(24, 2);
                }
#line 446
                if (! tmp___6) {
#line 447
                  m___2 = moves + i;
#line 447
                  m___2->from = (unsigned char)21;
#line 447
                  m___2->to = (unsigned char)21;
#line 447
                  m___2->dch = (short)100;
#line 447
                  m___2->special = (unsigned char)2;
#line 447
                  i ++;
                }
              }
            }
          }
        }
      }
    } else {
#line 452
      if (((int )G[Counter].castling & 4) == 0) {
#line 453
        if ((int )B[96] == 0) {
#line 453
          if ((int )B[97] == 0) {
            {
#line 454
            tmp___7 = attacktest(96, 1);
            }
#line 454
            if (! tmp___7) {
              {
#line 454
              tmp___8 = attacktest(97, 1);
              }
#line 454
              if (! tmp___8) {
#line 455
                m___3 = moves + i;
#line 455
                m___3->from = (unsigned char)21;
#line 455
                m___3->to = (unsigned char)21;
#line 455
                m___3->dch = (short)100;
#line 455
                m___3->special = (unsigned char)1;
#line 455
                i ++;
              }
            }
          }
        }
      }
#line 457
      if (((int )G[Counter].castling & 8) == 0) {
#line 458
        if ((int )B[92] == 0) {
#line 458
          if ((int )B[93] == 0) {
#line 458
            if ((int )B[94] == 0) {
              {
#line 459
              tmp___9 = attacktest(93, 1);
              }
#line 459
              if (! tmp___9) {
                {
#line 459
                tmp___10 = attacktest(94, 1);
                }
#line 459
                if (! tmp___10) {
#line 460
                  m___4 = moves + i;
#line 460
                  m___4->from = (unsigned char)21;
#line 460
                  m___4->to = (unsigned char)21;
#line 460
                  m___4->dch = (short)100;
#line 460
                  m___4->special = (unsigned char)2;
#line 460
                  i ++;
                }
              }
            }
          }
        }
      }
    }
  }
#line 464
  *n___1 = i;
#line 466
  return;
}
}
#line 470 "/home/wheatley/newnew/temp/phalanx-22+d051004/genmoves.c"
void lc(tmove *m___1 , int *i ) 
{ 
  int tmp ;
  unsigned char tmp___0 ;
  unsigned char tmp___1 ;
  unsigned char tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 473
  if (Depth < -200) {
#line 475
    if (Values[(int )B[square] >> 4] > Values[(int )B[destination] >> 4]) {
#line 477
      if (Color == 2) {
#line 478
        if ((int )P[destination] & 255) {
#line 478
          return;
        }
      } else
#line 480
      if ((int )P[destination] & 65280) {
#line 480
        return;
      }
    }
  } else
#line 484
  if (Values[(int )B[square] >> 4] > Values[(int )B[destination] >> 4]) {
    {
#line 486
    tmp = see(B, square, destination);
    }
#line 486
    if (tmp < 0) {
#line 486
      return;
    }
  }
#line 489
  tmp___1 = (unsigned char )square;
#line 489
  m___1->from = tmp___1;
#line 489
  tmp___0 = B[tmp___1];
#line 489
  m___1->in2a = tmp___0;
#line 489
  m___1->in1 = tmp___0;
#line 490
  tmp___2 = (unsigned char )destination;
#line 490
  m___1->to = tmp___2;
#line 490
  m___1->in2 = B[tmp___2];
#line 491
  m___1->dch = (short)100;
#line 492
  m___1->value = (short)0;
#line 493
  m___1->special = (unsigned char)0;
#line 494
  if (pin[m___1->from]) {
    {
#line 496
    do_move(m___1);
    }
#line 497
    if ((Color ^ 3) == 1) {
#line 497
      tmp___3 = (int )L[1].next;
    } else {
#line 497
      tmp___3 = (int )L[2].next;
    }
    {
#line 497
    tmp___4 = attacktest(tmp___3, (Color ^ 3) ^ 3);
    }
#line 497
    if (! tmp___4) {
#line 497
      (*i) ++;
    }
    {
#line 498
    undo_move(m___1);
    }
  } else {
#line 499
    (*i) ++;
  }
#line 501
  return;
}
}
#line 508 "/home/wheatley/newnew/temp/phalanx-22+d051004/genmoves.c"
void generate_legal_captures(tmove *moves , int *n___1 , int minval ) 
{ 
  int i ;
  unsigned int pbs ;
  int j ;
  int *mov ;
  int *tmp ;
  int d ;
  int d1 ;
  int tmp___0 ;
  int d2 ;
  int tmp___1 ;
  int step ;

  {
  {
#line 512
  i = 0;
#line 514
  find_pins(0);
#line 516
  square = (int )L[Color].next;
  }
  {
#line 516
  while (1) {
    while_continue: /* CIL Label */ ;
#line 516
    if (! (square != 0)) {
#line 516
      goto while_break;
    }
#line 518
    pbs = (unsigned int )((int )B[square] & 252);
    {
#line 521
    if (pbs == 16U) {
#line 521
      goto case_16;
    }
#line 563
    if (pbs == 96U) {
#line 563
      goto case_96;
    }
#line 563
    if (pbs == 32U) {
#line 563
      goto case_96;
    }
#line 573
    goto switch_default;
    case_16: /* CIL Label */ 
#line 522
    if (Color == 1) {
#line 523
      destination = square + 10;
#line 524
      if ((int )B[destination] == 0) {
#line 524
        if (destination >= 91) {
          {
#line 525
          lm(moves + i, (unsigned char)81, (unsigned char)0, & i);
          }
        }
      }
#line 526
      destination = square + 9;
      {
#line 526
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 526
        if (! (destination != square + 13)) {
#line 526
          goto while_break___0;
        }
#line 529
        if (((int )B[destination] & 3) == 2) {
#line 531
          if (destination < 91) {
#line 533
            if (Values[(int )B[destination] >> 4] >= minval) {
              {
#line 534
              lm(moves + i, (unsigned char)17, (unsigned char)0, & i);
              }
            }
          } else {
            {
#line 538
            lm(moves + i, (unsigned char)81, (unsigned char)0, & i);
            }
          }
        }
#line 526
        destination += 2;
      }
      while_break___0: /* CIL Label */ ;
      }
    } else {
#line 543
      destination = square - 10;
#line 544
      if ((int )B[destination] == 0) {
#line 544
        if (destination <= 28) {
          {
#line 545
          lm(moves + i, (unsigned char)82, (unsigned char)0, & i);
          }
        }
      }
#line 546
      destination = square - 9;
      {
#line 546
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 546
        if (! (destination != square - 13)) {
#line 546
          goto while_break___1;
        }
#line 549
        if (((int )B[destination] & 3) == 1) {
#line 551
          if (destination > 28) {
#line 553
            if (Values[(int )B[destination] >> 4] >= minval) {
              {
#line 554
              lm(moves + i, (unsigned char)18, (unsigned char)0, & i);
              }
            }
          } else {
            {
#line 558
            lm(moves + i, (unsigned char)82, (unsigned char)0, & i);
            }
          }
        }
#line 546
        destination -= 2;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
#line 562
    goto switch_break;
    case_96: /* CIL Label */ 
    case_32: /* CIL Label */ 
#line 565
    if (pbs == 96U) {
#line 565
      tmp = RB_dirs;
    } else {
#line 565
      tmp = N_moves;
    }
#line 565
    mov = tmp;
#line 566
    j = 0;
    {
#line 566
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 566
      if (! (j != 8)) {
#line 566
        goto while_break___2;
      }
#line 567
      destination = square + *(mov + j);
#line 568
      if (((int )B[destination] & 3) == (Color ^ 3)) {
#line 569
        if (Values[(int )B[destination] >> 4] >= minval) {
          {
#line 569
          lc(moves + i, & i);
          }
        }
      }
#line 566
      j ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 572
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 575
    if (pbs == 48U) {
#line 575
      tmp___0 = 4;
    } else {
#line 575
      tmp___0 = 0;
    }
#line 575
    d1 = tmp___0;
#line 576
    if (pbs == 64U) {
#line 576
      tmp___1 = 4;
    } else {
#line 576
      tmp___1 = 8;
    }
#line 576
    d2 = tmp___1;
#line 577
    d = d1;
    {
#line 577
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 577
      if (! (d != d2)) {
#line 577
        goto while_break___3;
      }
#line 578
      step = RB_dirs[d];
#line 579
      destination = square;
      {
#line 580
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 581
        destination += step;
#line 582
        if (((int )B[destination] & 3) == (Color ^ 3)) {
#line 583
          if (Values[(int )B[destination] >> 4] >= minval) {
            {
#line 584
            lc(moves + i, & i);
            }
          }
        }
#line 585
        if (B[destination]) {
#line 585
          goto while_break___4;
        }
      }
      while_break___4: /* CIL Label */ ;
      }
#line 577
      d ++;
    }
    while_break___3: /* CIL Label */ ;
    }
    switch_break: /* CIL Label */ ;
    }
#line 516
    square = (int )L[square].next;
  }
  while_break: /* CIL Label */ ;
  }
#line 592
  *n___1 = i;
#line 594
  return;
}
}
#line 600 "/home/wheatley/newnew/temp/phalanx-22+d051004/genmoves.c"
void generate_legal_checks(tmove *moves , int *n___1 ) 
{ 
  int i ;
  unsigned int pbs ;
  int j ;
  int *mov ;
  int *tmp ;
  int d ;
  int d1 ;
  int tmp___0 ;
  int d2 ;
  int tmp___1 ;
  int step ;

  {
  {
#line 605
  i = 0;
#line 607
  find_pins(0);
#line 608
  find_targets();
#line 610
  square = (int )L[Color].next;
  }
  {
#line 610
  while (1) {
    while_continue: /* CIL Label */ ;
#line 610
    if (! (square != 0)) {
#line 610
      goto while_break;
    }
#line 612
    pbs = (unsigned int )((int )B[square] & 252);
    {
#line 615
    if (pbs == 16U) {
#line 615
      goto case_16;
    }
#line 659
    if (pbs == 96U) {
#line 659
      goto case_96;
    }
#line 659
    if (pbs == 32U) {
#line 659
      goto case_96;
    }
#line 670
    goto switch_default;
    case_16: /* CIL Label */ 
#line 616
    if (Color == 1) {
#line 617
      destination = square + 10;
#line 618
      if ((int )B[destination] == 0) {
#line 618
        if (destination >= 91) {
          {
#line 620
          lm(moves + i, (unsigned char)81, (unsigned char)0, & i);
#line 621
          lm(moves + i, (unsigned char)33, (unsigned char)0, & i);
          }
        }
      }
#line 623
      destination = square + 9;
      {
#line 623
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 623
        if (! (destination != square + 13)) {
#line 623
          goto while_break___0;
        }
#line 626
        if (((int )B[destination] & 3) == 2) {
#line 628
          if (destination < 91) {
            {
#line 629
            lm(moves + i, (unsigned char)17, (unsigned char)0, & i);
            }
          } else {
            {
#line 632
            lm(moves + i, (unsigned char)81, (unsigned char)0, & i);
#line 633
            lm(moves + i, (unsigned char)33, (unsigned char)0, & i);
            }
          }
        }
#line 623
        destination += 2;
      }
      while_break___0: /* CIL Label */ ;
      }
    } else {
#line 638
      destination = square - 10;
#line 639
      if ((int )B[destination] == 0) {
#line 639
        if (destination <= 28) {
          {
#line 641
          lm(moves + i, (unsigned char)82, (unsigned char)0, & i);
#line 642
          lm(moves + i, (unsigned char)34, (unsigned char)0, & i);
          }
        }
      }
#line 644
      destination = square - 9;
      {
#line 644
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 644
        if (! (destination != square - 13)) {
#line 644
          goto while_break___1;
        }
#line 647
        if (((int )B[destination] & 3) == 1) {
#line 649
          if (destination > 28) {
            {
#line 650
            lm(moves + i, (unsigned char)18, (unsigned char)0, & i);
            }
          } else {
            {
#line 653
            lm(moves + i, (unsigned char)82, (unsigned char)0, & i);
#line 654
            lm(moves + i, (unsigned char)34, (unsigned char)0, & i);
            }
          }
        }
#line 644
        destination -= 2;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
#line 658
    goto switch_break;
    case_96: /* CIL Label */ 
    case_32: /* CIL Label */ 
#line 661
    if (pbs == 96U) {
#line 661
      tmp = RB_dirs;
    } else {
#line 661
      tmp = N_moves;
    }
#line 661
    mov = tmp;
#line 662
    j = 0;
    {
#line 662
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 662
      if (! (j != 8)) {
#line 662
        goto while_break___2;
      }
#line 663
      destination = square + *(mov + j);
#line 664
      if (((int )B[destination] & 3) == (Color ^ 3)) {
        {
#line 666
        lc(moves + i, & i);
        }
      } else
#line 664
      if ((int )B[destination] == 0) {
#line 664
        if ((unsigned int )tar[destination] == pbs) {
          {
#line 666
          lc(moves + i, & i);
          }
        }
      }
#line 662
      j ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 669
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 672
    if (pbs == 48U) {
#line 672
      tmp___0 = 4;
    } else {
#line 672
      tmp___0 = 0;
    }
#line 672
    d1 = tmp___0;
#line 673
    if (pbs == 64U) {
#line 673
      tmp___1 = 4;
    } else {
#line 673
      tmp___1 = 8;
    }
#line 673
    d2 = tmp___1;
#line 674
    d = d1;
    {
#line 674
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 674
      if (! (d != d2)) {
#line 674
        goto while_break___3;
      }
#line 675
      step = RB_dirs[d];
#line 676
      destination = square;
      {
#line 677
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 678
        destination += step;
#line 679
        if (((int )B[destination] & 3) == (Color ^ 3)) {
          {
#line 688
          lc(moves + i, & i);
          }
        } else
#line 679
        if ((int )B[destination] == 0) {
#line 679
          if (tar[destination]) {
#line 679
            if ((unsigned int )tar[destination] == pbs) {
              {
#line 688
              lc(moves + i, & i);
              }
            } else
#line 679
            if ((int )tar[destination] != 32) {
#line 679
              if (pbs == 80U) {
                {
#line 688
                lc(moves + i, & i);
                }
              }
            }
          }
        }
#line 689
        if (B[destination]) {
#line 689
          goto while_break___4;
        }
      }
      while_break___4: /* CIL Label */ ;
      }
#line 674
      d ++;
    }
    while_break___3: /* CIL Label */ ;
    }
    switch_break: /* CIL Label */ ;
    }
#line 610
    square = (int )L[square].next;
  }
  while_break: /* CIL Label */ ;
  }
#line 696
  *n___1 = i;
#line 698
  return;
}
}
#line 446 "/home/wheatley/newnew/temp/phalanx-22+d051004/phalanx.h"
tpbook Learn  ;
#line 529
void wlearn(int depth , int value ) ;
#line 13 "/home/wheatley/newnew/temp/phalanx-22+d051004/learn.c"
void wlearn(int depth , int value ) 
{ 
  int size ;
  int pos ;
  int i ;
  int bdepth ;
  int bpos ;
  tlearn cell ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 21
  if (Flag.learn == 0) {
#line 21
    return;
  } else
#line 21
  if ((unsigned long )Learn.f == (unsigned long )((void *)0)) {
#line 21
    return;
  } else
#line 21
  if (depth <= 400) {
#line 21
    return;
  }
  {
#line 23
  size = (int )((unsigned long )Learn.filesize / sizeof(tlearn ));
#line 24
  pos = (int )(G[Counter].hashboard % (unsigned int )size);
#line 26
  tmp = fseek(Learn.f, (long )((unsigned long )pos * sizeof(tlearn )), 0);
  }
#line 26
  if (tmp != 0) {
#line 26
    return;
  }
  {
#line 27
  myfread((void *)(& cell), (int )sizeof(tlearn ), Learn.f);
#line 29
  bdepth = -1000;
#line 30
  bpos = pos;
#line 32
  i = 0;
  }
  {
#line 32
  while (1) {
    while_continue: /* CIL Label */ ;
#line 32
    if (! (i < 8)) {
#line 32
      goto while_break;
    }
    {
#line 34
    tmp___0 = fseek(Learn.f, (long )((unsigned long )((pos + i) % size) * sizeof(tlearn )),
                    0);
    }
#line 34
    if (tmp___0 != 0) {
#line 35
      return;
    }
    {
#line 36
    myfread((void *)(& cell), (int )sizeof(tlearn ), Learn.f);
    }
#line 38
    if (cell.hashboard == 0U) {
#line 39
      bpos = pos + i;
#line 39
      bdepth = (int )cell.depth;
#line 39
      goto while_break;
    } else
#line 38
    if (cell.hashboard == G[Counter].hashboard) {
#line 39
      bpos = pos + i;
#line 39
      bdepth = (int )cell.depth;
#line 39
      goto while_break;
    }
#line 41
    if ((int )cell.depth > bdepth) {
#line 42
      bdepth = (int )cell.depth;
#line 42
      bpos = pos + i;
    }
#line 32
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 45
  if (cell.hashboard == G[Counter].hashboard) {
#line 45
    if ((int )cell.depth > depth) {
#line 46
      return;
    }
  }
  {
#line 48
  tmp___1 = fseek(Learn.f, (long )((unsigned long )(bpos % size) * sizeof(tlearn )),
                  0);
  }
#line 48
  if (tmp___1 != 0) {
#line 49
    return;
  }
  {
#line 51
  cell.hashboard = G[Counter].hashboard;
#line 52
  cell.depth = (short )depth;
#line 53
  cell.value = (short )value;
#line 55
  myfwrite((void *)(& cell), (int )sizeof(tlearn ), Learn.f);
  }
#line 57
  return;
}
}
#line 61 "/home/wheatley/newnew/temp/phalanx-22+d051004/learn.c"
int rlearn(void) 
{ 
  int size ;
  int pos ;
  int i ;
  tlearn cell ;
  int tmp ;

  {
#line 68
  if (Flag.learn == 0) {
#line 68
    return (32123);
  } else
#line 68
  if ((unsigned long )Learn.f == (unsigned long )((void *)0)) {
#line 68
    return (32123);
  }
#line 70
  size = (int )((unsigned long )Learn.filesize / sizeof(tlearn ));
#line 71
  pos = (int )(G[Counter].hashboard % (unsigned int )size);
#line 73
  i = 0;
  {
#line 73
  while (1) {
    while_continue: /* CIL Label */ ;
#line 73
    if (! (i < 8)) {
#line 73
      goto while_break;
    }
    {
#line 75
    tmp = fseek(Learn.f, (long )((unsigned long )((pos + i) % size) * sizeof(tlearn )),
                0);
    }
#line 75
    if (tmp != 0) {
#line 76
      return (32123);
    }
    {
#line 77
    myfread((void *)(& cell), (int )sizeof(tlearn ), Learn.f);
    }
#line 79
    if (cell.hashboard == 0U) {
#line 79
      return (32123);
    }
#line 81
    if (cell.hashboard == G[Counter].hashboard) {
#line 83
      if ((int )cell.depth >= Depth) {
#line 83
        return ((int )cell.value);
      } else {
#line 84
        return (32123);
      }
    }
#line 73
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 88
  return (32123);
}
}
#line 422 "/home/wheatley/newnew/temp/phalanx-22+d051004/phalanx.h"
int EasyMove  ;
#line 442
unsigned int Age ;
#line 520 "/home/wheatley/newnew/temp/phalanx-22+d051004/phalanx.h"
long LastTurn  ;
#line 521 "/home/wheatley/newnew/temp/phalanx-22+d051004/phalanx.h"
int Turns  ;
#line 532
void init_killers(void) ;
#line 24 "/home/wheatley/newnew/temp/phalanx-22+d051004/search.c"
int sortkey(void const   *a , void const   *b ) 
{ 


  {
#line 25
  return ((int )((tmove *)b)->value - (int )((tmove *)a)->value);
}
}
#line 30 "/home/wheatley/newnew/temp/phalanx-22+d051004/search.c"
int attacktest(int square___0 , int ocolor ) 
{ 
  int i ;
  int enemy ;
  int d ;
  int enemy1 ;
  int enemy2 ;
  int i___0 ;
  int step ;
  int d___0 ;
  int enemy1___0 ;
  int enemy2___0 ;
  int i___1 ;
  int step___0 ;

  {
#line 34
  if (ocolor != 1) {
#line 35
    if ((int )B[square___0 + 11] == 18) {
#line 35
      return (2);
    } else
#line 35
    if ((int )B[square___0 + 9] == 18) {
#line 35
      return (2);
    }
  } else
#line 37
  if ((int )B[square___0 - 11] == 17) {
#line 37
    return (2);
  } else
#line 37
  if ((int )B[square___0 - 9] == 17) {
#line 37
    return (2);
  }
#line 40
  enemy = 32 + ocolor;
#line 41
  i = 0;
  {
#line 41
  while (1) {
    while_continue: /* CIL Label */ ;
#line 41
    if (! (i != 8)) {
#line 41
      goto while_break;
    }
#line 42
    if ((int )B[square___0 + N_moves[i]] == enemy) {
#line 42
      return (2);
    }
#line 41
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 46
  enemy1 = 64 + ocolor;
#line 46
  enemy2 = 80 + ocolor;
#line 47
  d = 0;
  {
#line 47
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 47
    if (! (d != 4)) {
#line 47
      goto while_break___0;
    }
#line 48
    i___0 = square___0;
#line 48
    step = RB_dirs[d];
    {
#line 49
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 49
      i___0 += step;
#line 49
      if (! ((int )B[i___0] == 0)) {
#line 49
        goto while_break___1;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 50
    if ((int )B[i___0] == enemy1) {
#line 50
      return (2);
    } else
#line 50
    if ((int )B[i___0] == enemy2) {
#line 50
      return (2);
    }
#line 47
    d ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 55
  enemy1___0 = 48 + ocolor;
#line 55
  enemy2___0 = 80 + ocolor;
#line 56
  d___0 = 4;
  {
#line 56
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 56
    if (! (d___0 != 8)) {
#line 56
      goto while_break___2;
    }
#line 57
    i___1 = square___0;
#line 57
    step___0 = RB_dirs[d___0];
    {
#line 58
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 58
      i___1 += step___0;
#line 58
      if (! ((int )B[i___1] == 0)) {
#line 58
        goto while_break___3;
      }
    }
    while_break___3: /* CIL Label */ ;
    }
#line 59
    if ((int )B[i___1] == enemy1___0) {
#line 59
      return (2);
    } else
#line 59
    if ((int )B[i___1] == enemy2___0) {
#line 59
      return (2);
    }
#line 56
    d___0 ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 64
  if (dist[120 * square___0 + (int )L[ocolor].next].max == 1U) {
#line 64
    return (1);
  }
#line 66
  return (0);
}
}
#line 80 "/home/wheatley/newnew/temp/phalanx-22+d051004/search.c"
int csearch(tmove *m___1 , int n___1 , int Alpha , int Beta , int extend ) 
{ 
  int i ;
  int result ;
  int max ;
  int j ;
  int tmp ;
  int tmp___0 ;
  register int j___0 ;

  {
#line 91
  i = 0;
  {
#line 91
  while (1) {
    while_continue: /* CIL Label */ ;
#line 91
    if (! (i != n___1)) {
#line 91
      goto while_break;
    }
#line 97
    max = i;
#line 98
    j = i + 1;
    {
#line 98
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 98
      if (! (j != n___1)) {
#line 98
        goto while_break___0;
      }
#line 98
      if ((int )(m___1 + j)->value > (int )(m___1 + max)->value) {
#line 98
        max = j;
      }
#line 98
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 101
    do_move(m___1 + max);
#line 103
    tmp = evaluate(- Alpha - 1, - Alpha);
#line 103
    result = - tmp;
    }
#line 105
    if (result > Alpha) {
      {
#line 107
      Depth += extend;
#line 108
      tmp___0 = evaluate(- Beta, - Alpha);
#line 108
      result = - tmp___0;
#line 116
      Depth -= extend;
      }
    }
    {
#line 119
    undo_move(m___1 + max);
#line 121
    FollowPV = 0;
    }
#line 123
    if (result > Alpha) {
#line 125
      PV[Ply][Ply] = *(m___1 + max);
#line 125
      j___0 = Ply + 1;
      {
#line 125
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 125
        if (! PV[Ply + 1][j___0].from) {
#line 125
          goto while_break___1;
        }
#line 125
        PV[Ply][j___0] = PV[Ply + 1][j___0];
#line 125
        j___0 ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 125
      PV[Ply][j___0].from = (unsigned char)0;
#line 126
      Alpha = result;
#line 127
      if (Alpha >= Beta) {
#line 127
        return (Alpha);
      }
#line 128
      extend = 0;
    }
#line 131
    *(m___1 + max) = *(m___1 + i);
#line 91
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 134
  return (Alpha);
}
}
#line 140 "/home/wheatley/newnew/temp/phalanx-22+d051004/search.c"
int search(tmove *m___1 , int n___1 , int Alpha , int Beta ) 
{ 
  int i ;
  int maxi ;
  int result ;
  int max ;
  int depth ;
  int max___0 ;
  int j ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  register int j___0 ;
  tmove mo ;

  {
#line 148
  maxi = -1;
#line 151
  if (Abort) {
#line 151
    if (! NoAbort) {
#line 151
      return (0);
    }
  }
#line 156
  if (Depth > 200) {
#line 158
    max = 0;
#line 159
    i = 1;
    {
#line 159
    while (1) {
      while_continue: /* CIL Label */ ;
#line 159
      if (! (i != n___1)) {
#line 159
        goto while_break;
      }
#line 159
      if ((int )(m___1 + i)->value > (int )(m___1 + max)->value) {
#line 159
        max = i;
      }
#line 159
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 160
    if ((int )(m___1 + max)->value != 30000) {
      {
#line 162
      depth = Depth;
#line 163
      Depth -= 200;
#line 164
      search(m___1, n___1, Alpha, Beta);
#line 165
      Depth = depth;
      }
    }
  }
#line 179
  i = 0;
  {
#line 179
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 179
    if (! (i != n___1)) {
#line 179
      goto while_break___0;
    }
#line 185
    max___0 = i;
#line 186
    j = i + 1;
    {
#line 186
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 186
      if (! (j != n___1)) {
#line 186
        goto while_break___1;
      }
#line 186
      if ((int )(m___1 + j)->value > (int )(m___1 + max___0)->value) {
#line 186
        max___0 = j;
      }
#line 186
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 189
    do_move(m___1 + max___0);
    }
#line 191
    if (i == 0) {
      {
#line 192
      tmp = evaluate(- Beta, - Alpha);
#line 192
      result = - tmp;
      }
    } else
#line 191
    if (Depth <= 0) {
      {
#line 192
      tmp = evaluate(- Beta, - Alpha);
#line 192
      result = - tmp;
      }
    } else {
      {
#line 195
      tmp___0 = evaluate(- Alpha - 1, - Alpha);
#line 195
      result = - tmp___0;
      }
#line 196
      if (result > Alpha) {
#line 196
        if (result < Beta) {
          {
#line 197
          tmp___1 = evaluate(- Beta, - Alpha - 1);
#line 197
          result = - tmp___1;
          }
        }
      }
    }
    {
#line 200
    undo_move(m___1 + max___0);
#line 202
    FollowPV = 0;
    }
#line 204
    if (result > Alpha) {
#line 210
      PV[Ply][Ply] = *(m___1 + max___0);
#line 210
      j___0 = Ply + 1;
      {
#line 210
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 210
        if (! PV[Ply + 1][j___0].from) {
#line 210
          goto while_break___2;
        }
#line 210
        PV[Ply][j___0] = PV[Ply + 1][j___0];
#line 210
        j___0 ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 210
      PV[Ply][j___0].from = (unsigned char)0;
#line 211
      Alpha = result;
#line 212
      if (Alpha >= Beta) {
#line 213
        (m___1 + max___0)->value = (short )(25000 + Depth);
#line 213
        return (Alpha);
      }
#line 214
      maxi = i;
    }
#line 217
    mo = *(m___1 + max___0);
#line 217
    *(m___1 + max___0) = *(m___1 + i);
#line 217
    *(m___1 + i) = mo;
#line 179
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 220
  if (maxi != -1) {
#line 220
    (m___1 + maxi)->value = (short )(25000 + Depth);
  }
#line 222
  return (Alpha);
}
}
#line 229 "/home/wheatley/newnew/temp/phalanx-22+d051004/search.c"
int bgs  ;
#line 234 "/home/wheatley/newnew/temp/phalanx-22+d051004/search.c"
int sort_root_moves(tmove *m___1 , int n___1 ) 
{ 
  int i ;
  int best ;
  int secondbest ;
  int result ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  tmove mm ;
  register int j ;
  int tmp___2 ;

  {
#line 237
  best = -30000;
#line 238
  secondbest = -30000;
#line 241
  bgs = 0;
#line 243
  FollowPV = 0;
#line 244
  PV[0][0] = *(m___1 + 0);
#line 246
  EasyMove = 0;
#line 247
  Depth = 100;
#line 249
  i = 0;
  {
#line 249
  while (1) {
    while_continue: /* CIL Label */ ;
#line 249
    if (! (i != n___1)) {
#line 249
      goto while_break;
    }
    {
#line 251
    do_move(m___1 + i);
#line 253
    tmp = evaluate(-30000, 30000);
#line 253
    result = - tmp;
#line 255
    (m___1 + i)->value = (short )(result / 4);
    }
#line 256
    if ((m___1 + i)->in2) {
#line 257
      (m___1 + i)->value = (short )((int )(m___1 + i)->value + Values[(int )(m___1 + i)->in2 >> 4]);
#line 257
      bgs ++;
    } else
#line 258
    if ((m___1 + i)->special) {
#line 259
      (m___1 + i)->value = (short )((int )(m___1 + i)->value + 100);
#line 259
      bgs ++;
    }
#line 260
    if (Color == 1) {
#line 260
      tmp___0 = (int )L[1].next;
    } else {
#line 260
      tmp___0 = (int )L[2].next;
    }
    {
#line 260
    tmp___1 = attacktest(tmp___0, Color ^ 3);
    }
#line 260
    if (tmp___1) {
#line 261
      (m___1 + i)->value = (short )((int )(m___1 + i)->value + 150);
#line 261
      bgs ++;
    }
    {
#line 263
    undo_move(m___1 + i);
    }
#line 265
    if (result > best) {
#line 267
      mm = *(m___1 + 0);
#line 267
      *(m___1 + 0) = *(m___1 + i);
#line 267
      *(m___1 + i) = mm;
#line 268
      secondbest = best;
#line 268
      best = result;
#line 269
      PV[0][0] = *(m___1 + 0);
#line 269
      j = 1;
      {
#line 269
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 269
        if (! PV[1][j].from) {
#line 269
          goto while_break___0;
        }
#line 269
        PV[0][j] = PV[1][j];
#line 269
        j ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 269
      PV[0][j].from = (unsigned char)0;
    } else
#line 271
    if (result > secondbest) {
#line 271
      secondbest = result;
    }
#line 249
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 274
  qsort((void *)(m___1 + 1), (size_t )(n___1 - 1), sizeof(tmove ), & sortkey);
  }
#line 276
  if (n___1 == 1) {
#line 276
    EasyMove = 3;
  } else {
    {
#line 278
    tmp___2 = abs(best);
    }
#line 278
    if (tmp___2 > 29900) {
#line 278
      EasyMove = 2;
    } else
#line 280
    if (best - secondbest > 250) {
#line 280
      EasyMove = 2;
    } else
#line 282
    if (best - secondbest > 70) {
#line 282
      EasyMove = 1;
    }
  }
#line 284
  if (Flag.post) {
#line 284
    if (EasyMove != 0) {
#line 284
      if (Flag.xboard < 2) {
        {
#line 286
        printf((char const   */* __restrict  */)"    -> easy move      (%i)  ", EasyMove);
#line 287
        printm(*(m___1 + 0), (char *)((void *)0));
#line 287
        puts("               ");
        }
      }
    }
  }
#line 292
  return (best);
}
}
#line 299 "/home/wheatley/newnew/temp/phalanx-22+d051004/search.c"
tmove root_search(void) 
{ 
  tmove m___1[256] ;
  int n___1 ;
  int i ;
  int Alpha ;
  int Beta ;
  int r ;
  int Nod[256] ;
  int tmp ;
  int tmp___0 ;
  char pb[2048] ;
  int b ;
  int tmp___1 ;
  int learndepth ;
  int learnalpha ;
  int64 lastnodes ;
  int tmp___2 ;
  int tmp___3 ;
  register int j ;
  int tmp___4 ;
  register int j___0 ;
  int tmp___5 ;
  int tmp___6 ;
  int j___1 ;
  tmove pom ;
  register int j___2 ;
  int j___3 ;
  int64 ipom ;
  tmove pom___0 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  long t ;
  long tmp___11 ;

  {
#line 309
  Abort = 0;
#line 309
  NoAbort = 1;
#line 311
  if (Color == 1) {
#line 311
    tmp = (int )L[1].next;
  } else {
#line 311
    tmp = (int )L[2].next;
  }
  {
#line 311
  tmp___0 = attacktest(tmp, Color ^ 3);
#line 311
  generate_legal_moves(m___1, & n___1, tmp___0);
  }
#line 316
  if ((unsigned long )Flag.log != (unsigned long )((void *)0)) {
#line 320
    if (Counter > 0) {
      {
#line 322
      fputs((char const   */* __restrict  */)"\n", (FILE */* __restrict  */)Flag.log);
      }
#line 323
      if (Flag.ponder == 2) {
        {
#line 324
        fputs((char const   */* __restrict  */)"  pondering move ", (FILE */* __restrict  */)Flag.log);
        }
      } else {
        {
#line 326
        fputs((char const   */* __restrict  */)"  opponent plays ", (FILE */* __restrict  */)Flag.log);
        }
      }
      {
#line 327
      printm(G[Counter - 1].m, pb);
#line 328
      fputs((char const   */* __restrict  */)(pb), (FILE */* __restrict  */)Flag.log);
#line 329
      fputs((char const   */* __restrict  */)"\n", (FILE */* __restrict  */)Flag.log);
      }
    }
    {
#line 332
    printboard(pb);
#line 333
    fputs((char const   */* __restrict  */)(pb), (FILE */* __restrict  */)Flag.log);
#line 334
    fputs((char const   */* __restrict  */)"\n", (FILE */* __restrict  */)Flag.log);
    }
  }
#line 337
  if (Flag.book) {
#line 338
    if (Counter < 20) {
#line 338
      goto _L;
    } else
#line 338
    if (Bookout < 4) {
#line 338
      goto _L;
    } else
#line 338
    if (Flag.analyze) {
      _L: /* CIL Label */ 
#line 340
      b = 0;
#line 342
      if (Flag.easy) {
#line 342
        if (Counter > 4) {
          {
#line 343
          tmp___1 = rand();
          }
#line 343
          if (tmp___1 % 128 < (int )Flag.easy + Counter * 4) {
#line 343
            b = -1;
          }
        }
      }
#line 345
      if (b == 0) {
        {
#line 345
        b = bookmove(m___1, n___1);
        }
      }
#line 347
      if (b != -1) {
        {
#line 350
        Bookout = 0;
#line 351
        PV[0][1].from = (unsigned char)0;
#line 352
        m___1[b].value = (short)0;
#line 353
        do_move(m___1 + b);
        }
#line 354
        return (m___1[b]);
      } else {
#line 355
        Bookout ++;
      }
    }
  }
  {
#line 358
  init_killers();
  }
#line 360
  if (n___1 == 0) {
#line 360
    NoAbort = 0;
  } else {
    {
#line 363
    learndepth = 0;
#line 364
    learnalpha = 0;
#line 366
    Age ++;
#line 367
    Nodes = (int64 )0;
#line 369
    A_n = n___1;
#line 369
    A_m = m___1;
#line 369
    A_i = 0;
#line 371
    PV[0][0].from = (unsigned char)0;
#line 373
    l_startsearch();
#line 375
    Ply = 0;
#line 377
    Alpha = sort_root_moves(m___1, n___1);
#line 377
    LastIter = Alpha;
#line 378
    LastTurn = ptime();
    }
#line 380
    if (EasyMove == 3) {
#line 380
      if (! Flag.analyze) {
        {
#line 380
        do_move(m___1);
        }
#line 380
        return (m___1[0]);
      }
    }
    {
#line 382
    FollowPV = 1;
#line 383
    NoAbort = 0;
#line 384
    Depth = 290;
#line 384
    Ply = 0;
#line 385
    A_d = 2;
#line 387
    memset((void *)(Nod), 0, 256UL * sizeof(int ));
    }
#line 389
    if (! Flag.polling) {
      {
#line 389
      signal(2, & interrupt);
      }
    }
#line 391
    Turns = n___1;
    {
#line 393
    while (1) {
      while_continue: /* CIL Label */ ;
#line 393
      if (Flag.ponder == 2) {
#line 393
        goto _L___0;
      } else {
        {
#line 393
        tmp___10 = l_iterate();
        }
#line 393
        if (tmp___10) {
#line 393
          goto _L___0;
        } else
#line 393
        if (Flag.analyze) {
          _L___0: /* CIL Label */ 
#line 393
          if (! Abort) {
#line 393
            if (! (Depth < 4000)) {
#line 393
              goto while_break;
            }
          } else {
#line 393
            goto while_break;
          }
        } else {
#line 393
          goto while_break;
        }
      }
#line 396
      A_d ++;
#line 397
      Turns = 0;
#line 399
      Beta = Alpha + 60;
#line 400
      Alpha -= 60;
#line 402
      if (Flag.post) {
#line 402
        if (! Flag.xboard) {
          {
#line 402
          verboseline(m___1, 0, n___1);
          }
        }
      }
#line 404
      i = 0;
      {
#line 404
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 404
        if (! (i != n___1)) {
#line 404
          goto while_break___0;
        }
        {
#line 406
        lastnodes = Nodes;
#line 407
        A_i = i;
#line 409
        do_move(m___1 + i);
        }
#line 412
        if (i == 0) {
          {
#line 414
          tmp___2 = evaluate(- Beta, - Alpha);
#line 414
          r = - tmp___2;
          }
#line 415
          if (! Abort) {
#line 415
            m___1[i].value = (short )r;
          }
#line 416
          if ((int )m___1[i].value <= Alpha) {
#line 416
            if (! Abort) {
#line 418
              if (Flag.post) {
                {
#line 418
                infoline(4, (char *)((void *)0));
                }
              }
              {
#line 419
              tmp___3 = evaluate(- Alpha, 30000);
#line 419
              r = - tmp___3;
              }
#line 420
              if (! Abort) {
#line 420
                Alpha = r;
#line 420
                m___1[i].value = (short )Alpha;
              }
#line 421
              PV[0][0] = m___1[0];
#line 421
              j = 1;
              {
#line 421
              while (1) {
                while_continue___1: /* CIL Label */ ;
#line 421
                if (! PV[1][j].from) {
#line 421
                  goto while_break___1;
                }
#line 421
                PV[0][j] = PV[1][j];
#line 421
                j ++;
              }
              while_break___1: /* CIL Label */ ;
              }
#line 421
              PV[0][j].from = (unsigned char)0;
#line 422
              if (Flag.post) {
                {
#line 422
                infoline(1, (char *)((void *)0));
                }
              }
            }
          }
        } else {
          {
#line 428
          tmp___4 = evaluate(- Alpha - 5, - Alpha);
#line 428
          r = - tmp___4;
          }
#line 429
          if (! Abort) {
#line 429
            m___1[i].value = (short )r;
          }
#line 430
          if ((int )m___1[i].value > Alpha) {
#line 432
            if (! Abort) {
#line 434
              Turns ++;
#line 435
              if (i > bgs) {
#line 435
                bgs ++;
              }
#line 436
              PV[0][0] = m___1[i];
#line 436
              j___0 = 1;
              {
#line 436
              while (1) {
                while_continue___2: /* CIL Label */ ;
#line 436
                if (! PV[1][j___0].from) {
#line 436
                  goto while_break___2;
                }
#line 436
                PV[0][j___0] = PV[1][j___0];
#line 436
                j___0 ++;
              }
              while_break___2: /* CIL Label */ ;
              }
              {
#line 436
              PV[0][j___0].from = (unsigned char)0;
#line 437
              LastTurn = ptime();
              }
#line 438
              if (EasyMove != 0) {
#line 440
                EasyMove = 0;
#line 441
                if (Flag.post) {
#line 441
                  if (Flag.xboard < 2) {
                    {
#line 442
                    printf((char const   */* __restrict  */)"    -> easy move off                                    \n");
                    }
                  }
                }
              }
            }
#line 446
            if ((int )m___1[i].value >= Alpha + 5) {
#line 448
              if (Flag.post) {
                {
#line 448
                infoline(2, (char *)((void *)0));
                }
              }
              {
#line 449
              tmp___5 = evaluate(- Beta, - Alpha);
#line 449
              r = - tmp___5;
              }
#line 450
              if (! Abort) {
#line 450
                m___1[i].value = (short )r;
              }
            }
          }
        }
#line 468
        if ((int )m___1[i].value >= Beta) {
#line 474
          PV[0][0].value = (short )Beta;
#line 475
          if (Flag.post) {
            {
#line 475
            infoline(5, (char *)((void *)0));
            }
          }
          {
#line 476
          tmp___6 = evaluate(-30000, - Beta);
#line 476
          r = - tmp___6;
          }
#line 477
          if (! Abort) {
#line 477
            m___1[i].value = (short )r;
          }
        }
        {
#line 480
        undo_move(m___1 + i);
        }
#line 482
        if (Abort) {
#line 484
          if (Abort == 1) {
#line 484
            if (Flag.post) {
              {
#line 485
              puts("search aborted");
              }
            }
          }
#line 486
          goto while_break___0;
        }
#line 489
        if ((int )m___1[i].value > Alpha) {
#line 496
          PV[0][0] = m___1[i];
#line 496
          j___2 = 1;
          {
#line 496
          while (1) {
            while_continue___3: /* CIL Label */ ;
#line 496
            if (! PV[1][j___2].from) {
#line 496
              goto while_break___3;
            }
#line 496
            PV[0][j___2] = PV[1][j___2];
#line 496
            j___2 ++;
          }
          while_break___3: /* CIL Label */ ;
          }
#line 496
          PV[0][j___2].from = (unsigned char)0;
#line 497
          Alpha = (int )m___1[i].value;
#line 498
          if (Flag.post) {
            {
#line 498
            infoline(1, (char *)((void *)0));
            }
          }
#line 501
          pom = m___1[i];
#line 502
          j___1 = i;
          {
#line 502
          while (1) {
            while_continue___4: /* CIL Label */ ;
#line 502
            if (! (j___1 != 0)) {
#line 502
              goto while_break___4;
            }
#line 502
            m___1[j___1] = m___1[j___1 - 1];
#line 502
            j___1 --;
          }
          while_break___4: /* CIL Label */ ;
          }
#line 503
          m___1[0] = pom;
#line 505
          Beta = Alpha + 60;
        } else {
#line 510
          tmp___7 = (int )(Nodes - lastnodes);
#line 510
          Nod[i] = tmp___7;
#line 510
          ipom = (int64 )tmp___7;
#line 512
          pom___0 = m___1[i];
#line 513
          j___3 = i;
          {
#line 513
          while (1) {
            while_continue___5: /* CIL Label */ ;
#line 513
            if (j___3 > bgs + 1) {
#line 513
              if (! (Nod[i] > Nod[j___3 - 1])) {
#line 513
                goto while_break___5;
              }
            } else {
#line 513
              goto while_break___5;
            }
#line 514
            m___1[j___3] = m___1[j___3 - 1];
#line 514
            Nod[j___3] = Nod[j___3 - 1];
#line 513
            j___3 --;
          }
          while_break___5: /* CIL Label */ ;
          }
#line 515
          m___1[j___3] = pom___0;
#line 515
          Nod[j___3] = (int )ipom;
        }
#line 404
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 519
      if (! Abort) {
#line 519
        if (Depth > 300) {
#line 520
          learndepth = Depth;
#line 520
          learnalpha = Alpha;
        }
      }
#line 522
      if (Flag.post) {
        {
#line 522
        infoline(3, (char *)((void *)0));
        }
      }
      {
#line 523
      Depth += 100;
#line 524
      FollowPV = 1;
#line 526
      tmp___9 = abs(Alpha);
      }
#line 526
      if (tmp___9 > 29000) {
        {
#line 528
        tmp___8 = abs(Alpha);
        }
#line 528
        if (tmp___8 + Depth / 100 > 30000) {
#line 528
          goto while_break;
        }
#line 530
        if (EasyMove < 2) {
#line 532
          EasyMove = 2;
#line 533
          if (Flag.post) {
#line 533
            if (Flag.xboard < 2) {
              {
#line 534
              printf((char const   */* __restrict  */)"    -> forced checkmate -> easy move (2)              \n");
              }
            }
          }
        }
      }
#line 539
      LastIter = Alpha;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 542
    Depth -= 100;
#line 543
    AllDepth += (long )Depth;
#line 546
    tmp___11 = ptime();
#line 546
    t = tmp___11 - T1;
    }
#line 547
    if (t != 0L) {
#line 547
      AllNPS += (100LL * Nodes) / (int64 )t;
    }
#line 550
    if (Flag.post) {
      {
#line 550
      infoline(0, (char *)((void *)0));
      }
    }
#line 552
    if (Flag.learn) {
#line 552
      if (learndepth) {
        {
#line 552
        wlearn(learndepth, learnalpha);
        }
      }
    }
    {
#line 554
    do_move(PV[0]);
    }
  }
  {
#line 557
  signal(2, (void (*)(int  ))1);
  }
#line 559
  return (PV[0][0]);
}
}
#line 437 "/home/wheatley/newnew/temp/phalanx-22+d051004/phalanx.h"
unsigned int H[12][64] ;
#line 92 "/home/wheatley/newnew/temp/phalanx-22+d051004/moving.c"
static unsigned char cb_[80]  = 
#line 92 "/home/wheatley/newnew/temp/phalanx-22+d051004/moving.c"
  {      (unsigned char)0,      (unsigned char)2,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)3,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)1,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)8, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)12, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)4,      (unsigned char)0};
#line 102 "/home/wheatley/newnew/temp/phalanx-22+d051004/moving.c"
static unsigned char *cb  =    cb_ - 20;
#line 51 "/home/wheatley/newnew/temp/phalanx-22+d051004/moving.c"
void do_move(tmove *m___1 ) 
{ 
  unsigned char tmp ;
  unsigned char tmp___0 ;
  unsigned char tmp___1 ;
  unsigned char tmp___2 ;
  unsigned char tmp___3 ;
  unsigned char tmp___4 ;
  unsigned char tmp___5 ;
  unsigned char tmp___6 ;
  unsigned char tmp___7 ;
  unsigned char tmp___8 ;

  {
#line 54
  G[Counter].m = *m___1;
#line 55
  Counter ++;
#line 56
  G[Counter].castling = G[Counter - 1].castling;
#line 57
  G[Counter].rule50 = (unsigned short )((int )G[Counter - 1].rule50 + 1);
#line 58
  G[Counter].hashboard = 4256789809U ^ G[Counter - 1].hashboard;
#line 59
  G[Counter].mtrl = G[Counter - 1].xmtrl;
#line 60
  G[Counter].xmtrl = G[Counter - 1].mtrl;
#line 61
  Ply ++;
  {
#line 65
  if ((int )m___1->special == 0) {
#line 65
    goto case_0;
  }
#line 109
  if ((int )m___1->special == 1) {
#line 109
    goto case_1;
  }
#line 133
  if ((int )m___1->special == 2) {
#line 133
    goto case_2;
  }
#line 157
  goto switch_default;
  case_0: /* CIL Label */ 
#line 67
  G[Counter].hashboard ^= H[HP[m___1->in1]][*(HS + m___1->from)];
#line 68
  G[Counter].hashboard ^= H[HP[m___1->in2a]][*(HS + m___1->to)];
#line 69
  if ((int )m___1->in2 != 0) {
#line 71
    G[Counter].hashboard ^= H[HP[m___1->in2]][*(HS + m___1->to)];
#line 72
    G[Counter].mtrl = (short )((int )G[Counter].mtrl - Values[(int )m___1->in2 >> 4]);
#line 73
    G[Counter].rule50 = (unsigned short)0;
#line 76
    L[L[m___1->to].prev].next = L[m___1->to].next;
#line 77
    L[L[m___1->to].next].prev = L[m___1->to].prev;
  } else
#line 79
  if (((int )m___1->in1 & 252) == 16) {
#line 79
    G[Counter].rule50 = (unsigned short)0;
  }
#line 82
  L[m___1->to] = L[m___1->from];
#line 83
  tmp = m___1->to;
#line 83
  L[L[m___1->to].next].prev = tmp;
#line 83
  L[L[m___1->to].prev].next = tmp;
#line 85
  if ((int )m___1->in2a != (int )m___1->in1) {
#line 86
    G[Counter].xmtrl = (short )((int )G[Counter].xmtrl + (Values[(int )m___1->in2a >> 4] - 100));
  }
#line 88
  B[m___1->from] = (tsquare )0;
#line 89
  B[m___1->to] = m___1->in2a;
#line 104
  G[Counter].castling = (unsigned short )((int )G[Counter].castling | ((int )*(cb + m___1->from) | (int )*(cb + m___1->to)));
#line 107
  goto switch_break;
  case_1: /* CIL Label */ 
#line 110
  if (Color == 1) {
#line 112
    B[25] = (tsquare )0;
#line 112
    B[26] = (tsquare )65;
#line 112
    B[27] = (tsquare )97;
#line 112
    B[28] = (tsquare )0;
#line 113
    G[Counter].castling = (unsigned short )((int )G[Counter].castling | 3);
#line 114
    G[Counter].hashboard ^= H[HP[97]][*(HS + 25)];
#line 115
    G[Counter].hashboard ^= H[HP[97]][*(HS + 27)];
#line 116
    G[Counter].hashboard ^= H[HP[65]][*(HS + 28)];
#line 117
    G[Counter].hashboard ^= H[HP[65]][*(HS + 26)];
#line 118
    L[27] = L[25];
#line 118
    tmp___0 = (unsigned char)27;
#line 118
    L[L[27].next].prev = tmp___0;
#line 118
    L[1].next = tmp___0;
#line 119
    L[26] = L[28];
#line 119
    tmp___1 = (unsigned char)26;
#line 119
    L[L[26].next].prev = tmp___1;
#line 119
    L[L[26].prev].next = tmp___1;
  } else {
#line 123
    B[95] = (tsquare )0;
#line 123
    B[96] = (tsquare )66;
#line 123
    B[97] = (tsquare )98;
#line 123
    B[98] = (tsquare )0;
#line 124
    G[Counter].castling = (unsigned short )((int )G[Counter].castling | 12);
#line 125
    G[Counter].hashboard ^= H[HP[98]][*(HS + 95)];
#line 126
    G[Counter].hashboard ^= H[HP[98]][*(HS + 97)];
#line 127
    G[Counter].hashboard ^= H[HP[66]][*(HS + 98)];
#line 128
    G[Counter].hashboard ^= H[HP[66]][*(HS + 96)];
#line 129
    L[97] = L[95];
#line 129
    tmp___2 = (unsigned char)97;
#line 129
    L[L[97].next].prev = tmp___2;
#line 129
    L[2].next = tmp___2;
#line 130
    L[96] = L[98];
#line 130
    tmp___3 = (unsigned char)96;
#line 130
    L[L[96].next].prev = tmp___3;
#line 130
    L[L[96].prev].next = tmp___3;
  }
#line 132
  goto switch_break;
  case_2: /* CIL Label */ 
#line 134
  if (Color == 1) {
#line 136
    B[21] = (tsquare )0;
#line 136
    B[23] = (tsquare )97;
#line 136
    B[24] = (tsquare )65;
#line 136
    B[25] = (tsquare )0;
#line 137
    G[Counter].castling = (unsigned short )((int )G[Counter].castling | 3);
#line 138
    G[Counter].hashboard ^= H[HP[97]][*(HS + 25)];
#line 139
    G[Counter].hashboard ^= H[HP[97]][*(HS + 23)];
#line 140
    G[Counter].hashboard ^= H[HP[65]][*(HS + 21)];
#line 141
    G[Counter].hashboard ^= H[HP[65]][*(HS + 24)];
#line 142
    L[23] = L[25];
#line 142
    tmp___4 = (unsigned char)23;
#line 142
    L[L[23].next].prev = tmp___4;
#line 142
    L[1].next = tmp___4;
#line 143
    L[24] = L[21];
#line 143
    tmp___5 = (unsigned char)24;
#line 143
    L[L[24].next].prev = tmp___5;
#line 143
    L[L[24].prev].next = tmp___5;
  } else {
#line 147
    B[91] = (tsquare )0;
#line 147
    B[93] = (tsquare )98;
#line 147
    B[94] = (tsquare )66;
#line 147
    B[95] = (tsquare )0;
#line 148
    G[Counter].castling = (unsigned short )((int )G[Counter].castling | 12);
#line 149
    G[Counter].hashboard ^= H[HP[98]][*(HS + 95)];
#line 150
    G[Counter].hashboard ^= H[HP[98]][*(HS + 93)];
#line 151
    G[Counter].hashboard ^= H[HP[66]][*(HS + 91)];
#line 152
    G[Counter].hashboard ^= H[HP[66]][*(HS + 94)];
#line 153
    L[93] = L[95];
#line 153
    tmp___6 = (unsigned char)93;
#line 153
    L[L[93].next].prev = tmp___6;
#line 153
    L[2].next = tmp___6;
#line 154
    L[94] = L[91];
#line 154
    tmp___7 = (unsigned char)94;
#line 154
    L[L[94].next].prev = tmp___7;
#line 154
    L[L[94].prev].next = tmp___7;
  }
#line 156
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 159
  G[Counter].hashboard ^= H[HP[m___1->in1]][*(HS + m___1->from)];
#line 160
  G[Counter].hashboard ^= H[HP[m___1->in2a]][*(HS + m___1->to)];
#line 161
  G[Counter].hashboard ^= H[HP[B[m___1->special]]][*(HS + m___1->special)];
#line 163
  B[m___1->from] = (tsquare )0;
#line 164
  B[m___1->to] = m___1->in2a;
#line 165
  B[m___1->special] = (tsquare )0;
#line 168
  L[m___1->to] = L[m___1->from];
#line 169
  tmp___8 = m___1->to;
#line 169
  L[L[m___1->to].next].prev = tmp___8;
#line 169
  L[L[m___1->to].prev].next = tmp___8;
#line 170
  L[L[m___1->special].next].prev = L[m___1->special].prev;
#line 171
  L[L[m___1->special].prev].next = L[m___1->special].next;
#line 173
  G[Counter].mtrl = (short )((int )G[Counter].mtrl - 100);
#line 174
  G[Counter].rule50 = (unsigned short)0;
  switch_break: /* CIL Label */ ;
  }
#line 177
  Color ^= 3;
#line 178
  Depth -= (int )m___1->dch;
#line 184
  return;
}
}
#line 188 "/home/wheatley/newnew/temp/phalanx-22+d051004/moving.c"
void undo_move(tmove *m___1 ) 
{ 
  unsigned char tmp ;
  unsigned char tmp___0 ;
  unsigned char tmp___1 ;
  unsigned char tmp___2 ;
  unsigned char tmp___3 ;
  unsigned char tmp___4 ;
  unsigned char tmp___5 ;
  unsigned char tmp___6 ;
  unsigned char tmp___7 ;
  unsigned char tmp___8 ;

  {
#line 191
  Color ^= 3;
#line 192
  Depth += (int )m___1->dch;
#line 193
  Ply --;
#line 193
  Counter --;
  {
#line 197
  if ((int )m___1->special == 0) {
#line 197
    goto case_0;
  }
#line 222
  if ((int )m___1->special == 1) {
#line 222
    goto case_1;
  }
#line 236
  if ((int )m___1->special == 2) {
#line 236
    goto case_2;
  }
#line 250
  goto switch_default;
  case_0: /* CIL Label */ 
#line 198
  B[m___1->from] = m___1->in1;
#line 199
  B[m___1->to] = m___1->in2;
#line 202
  L[m___1->from] = L[m___1->to];
#line 203
  tmp = m___1->from;
#line 203
  L[L[m___1->from].next].prev = tmp;
#line 203
  L[L[m___1->from].prev].next = tmp;
#line 204
  if ((int )m___1->in2 != 0) {
#line 206
    if (((int )m___1->in2 & 3) == 1) {
#line 208
      L[m___1->to].next = L[L[1].next].next;
#line 209
      L[m___1->to].prev = L[1].next;
#line 210
      L[L[L[1].next].next].prev = m___1->to;
#line 211
      L[L[1].next].next = m___1->to;
    } else {
#line 215
      L[m___1->to].next = L[L[2].next].next;
#line 216
      L[m___1->to].prev = L[2].next;
#line 217
      L[L[L[2].next].next].prev = m___1->to;
#line 218
      L[L[2].next].next = m___1->to;
    }
  }
#line 221
  goto switch_break;
  case_1: /* CIL Label */ 
#line 223
  if (Color == 1) {
#line 225
    B[25] = (tsquare )97;
#line 225
    B[26] = (tsquare )0;
#line 225
    B[27] = (tsquare )0;
#line 225
    B[28] = (tsquare )65;
#line 226
    L[25] = L[27];
#line 226
    tmp___0 = (unsigned char)25;
#line 226
    L[L[25].next].prev = tmp___0;
#line 226
    L[1].next = tmp___0;
#line 227
    L[28] = L[26];
#line 227
    tmp___1 = (unsigned char)28;
#line 227
    L[L[28].next].prev = tmp___1;
#line 227
    L[L[28].prev].next = tmp___1;
  } else {
#line 231
    B[95] = (tsquare )98;
#line 231
    B[96] = (tsquare )0;
#line 231
    B[97] = (tsquare )0;
#line 231
    B[98] = (tsquare )66;
#line 232
    L[95] = L[97];
#line 232
    tmp___2 = (unsigned char)95;
#line 232
    L[L[95].next].prev = tmp___2;
#line 232
    L[2].next = tmp___2;
#line 233
    L[98] = L[96];
#line 233
    tmp___3 = (unsigned char)98;
#line 233
    L[L[98].next].prev = tmp___3;
#line 233
    L[L[98].prev].next = tmp___3;
  }
#line 235
  goto switch_break;
  case_2: /* CIL Label */ 
#line 237
  if (Color == 1) {
#line 239
    B[21] = (tsquare )65;
#line 239
    B[23] = (tsquare )0;
#line 239
    B[24] = (tsquare )0;
#line 239
    B[25] = (tsquare )97;
#line 240
    L[25] = L[23];
#line 240
    tmp___4 = (unsigned char)25;
#line 240
    L[L[25].next].prev = tmp___4;
#line 240
    L[1].next = tmp___4;
#line 241
    L[21] = L[24];
#line 241
    tmp___5 = (unsigned char)21;
#line 241
    L[L[21].next].prev = tmp___5;
#line 241
    L[L[21].prev].next = tmp___5;
  } else {
#line 245
    B[91] = (tsquare )66;
#line 245
    B[93] = (tsquare )0;
#line 245
    B[94] = (tsquare )0;
#line 245
    B[95] = (tsquare )98;
#line 246
    L[95] = L[93];
#line 246
    tmp___6 = (unsigned char)95;
#line 246
    L[L[95].next].prev = tmp___6;
#line 246
    L[2].next = tmp___6;
#line 247
    L[91] = L[94];
#line 247
    tmp___7 = (unsigned char)91;
#line 247
    L[L[91].next].prev = tmp___7;
#line 247
    L[L[91].prev].next = tmp___7;
  }
#line 249
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 251
  B[m___1->to] = (tsquare )0;
#line 252
  L[m___1->from] = L[m___1->to];
#line 253
  tmp___8 = m___1->from;
#line 253
  L[L[m___1->from].next].prev = tmp___8;
#line 253
  L[L[m___1->from].prev].next = tmp___8;
#line 254
  if (Color == 1) {
#line 256
    B[m___1->from] = (tsquare )17;
#line 257
    B[m___1->special] = (tsquare )18;
#line 258
    L[m___1->special].next = L[L[2].next].next;
#line 259
    L[m___1->special].prev = L[2].next;
#line 260
    L[L[L[2].next].next].prev = m___1->special;
#line 261
    L[L[2].next].next = m___1->special;
  } else {
#line 265
    B[m___1->from] = (tsquare )18;
#line 266
    B[m___1->special] = (tsquare )17;
#line 267
    L[m___1->special].next = L[L[1].next].next;
#line 268
    L[m___1->special].prev = L[1].next;
#line 269
    L[L[L[1].next].next].prev = m___1->special;
#line 270
    L[L[1].next].next = m___1->special;
  }
  switch_break: /* CIL Label */ ;
  }
#line 278
  return;
}
}
#line 71 "/usr/include/getopt.h"
extern int optind ;
#line 76
extern int opterr ;
#line 173
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getopt_long)(int ___argc ,
                                                                                  char * const  *___argv ,
                                                                                  char const   *__shortopts ,
                                                                                  struct option  const  *__longopts ,
                                                                                  int *__longind ) ;
#line 386 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 376 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) srand)(unsigned int __seed ) ;
#line 468
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) calloc)(size_t __nmemb ,
                                                                               size_t __size )  __attribute__((__malloc__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 564
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) getenv)(char const   *__name ) ;
#line 176 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 192 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t ( __attribute__((__leaf__)) time)(time_t *__timer ) ;
#line 287 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) access)(char const   *__name ,
                                                                                             int __type ) ;
#line 628
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) getpid)(void) ;
#line 438 "/home/wheatley/newnew/temp/phalanx-22+d051004/phalanx.h"
thashentry *HT ;
#line 13 "/home/wheatley/newnew/temp/phalanx-22+d051004/phalanx.c"
void badoptions(void) 
{ 


  {
  {
#line 15
  printf((char const   */* __restrict  */)"\nUsage:    phalanx [options] [<moves> <minutes> [<increment in seconds>]]\n          phalanx [options] [<seconds per move>]\n          phalanx bench\n          phalanx bcreate [options]\nOptions:  -t <transposition table size in kilobytes>\n          -f <fixed search time in seconds>\n          -x <+/->  xboard mode on/off        default: on\n          -p <+/->  permanent brain on/off    default: off\n          -s <+/->  show thinking on/off      default: off\n           -c <+/->  cpu time                  default: off\n          -o <+/->  polling input             default: on\n          -b <+/->  opening book              default: on\n          -r <resign value in centipawns>     default: 0 (no resigning)\n          -e <easy level 0...100>             default: 0 (best play)\n          -l <+/->  learning on/off           default: on\n          -v        print version and exit\n          -P <primary book directory>\n          -S <secondary book directory>\n          -L <learning file directory>\n          -g <log file name>\nExamples: phalanx -c+ -s+ -o - -x- -f 60 -t4000\n          xboard -fcp \"phalanx -l+ -r800\"\n");
#line 16
  exit(0);
  }
}
}
#line 20 "/home/wheatley/newnew/temp/phalanx-22+d051004/phalanx.c"
char *get_book_file(char *bookdir , char *env_variable , char *path , char *name ,
                    int mode ) 
{ 
  char file___0[256] ;
  char *aux ;
  int tmp ;
  char *tmp___0 ;

  {
#line 26
  if (bookdir) {
#line 27
    path = bookdir;
  } else {
    {
#line 28
    aux = getenv((char const   *)env_variable);
    }
#line 28
    if (aux) {
#line 29
      path = aux;
    } else {
      {
#line 30
      tmp = access((char const   *)name, mode);
      }
#line 30
      if (! tmp) {
#line 31
        path = (char *)".";
      }
    }
  }
  {
#line 36
  snprintf((char */* __restrict  */)(file___0), (size_t )255, (char const   */* __restrict  */)"%s/%s",
           path, name);
#line 40
  tmp___0 = strdup((char const   *)(file___0));
  }
#line 40
  return (tmp___0);
}
}
#line 160 "/home/wheatley/newnew/temp/phalanx-22+d051004/phalanx.c"
static int t___0  ;
#line 167 "/home/wheatley/newnew/temp/phalanx-22+d051004/phalanx.c"
static int e  ;
#line 44 "/home/wheatley/newnew/temp/phalanx-22+d051004/phalanx.c"
int main(int argc , char **argv ) 
{ 
  int c ;
  clock_t t ;
  char *PbookDir ;
  char *SbookDir ;
  char *LbookDir ;
  char *EcoDir ;
  int indexptr ;
  struct option longopts[26] ;
  int tmp ;
  int tmp___0 ;
  time_t tmp___1 ;
  __pid_t tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int i ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int m___1 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  void *tmp___15 ;
  int i___0 ;
  long tim ;
  int64 allnodes ;
  char *positions___0[10] ;
  long tmp___16 ;
  int b[65536] ;
  char filename___0[256] ;
  size_t tmp___17 ;
  struct stat fs ;
  struct stat fs___0 ;
  unsigned int pos ;
  struct stat fs___1 ;
  struct stat fs___2 ;
  clock_t tmp___18 ;

  {
  {
#line 53
  longopts[0].name = "help";
#line 53
  longopts[0].has_arg = 0;
#line 53
  longopts[0].flag = (int *)((void *)0);
#line 53
  longopts[0].val = '?';
#line 53
  longopts[1].name = "version";
#line 53
  longopts[1].has_arg = 0;
#line 53
  longopts[1].flag = (int *)((void *)0);
#line 53
  longopts[1].val = 'v';
#line 53
  longopts[2].name = "trans-table-cells";
#line 53
  longopts[2].has_arg = 1;
#line 53
  longopts[2].flag = (int *)((void *)0);
#line 53
  longopts[2].val = 'T';
#line 53
  longopts[3].name = "trans-table-bytes";
#line 53
  longopts[3].has_arg = 1;
#line 53
  longopts[3].flag = (int *)((void *)0);
#line 53
  longopts[3].val = 't';
#line 53
  longopts[4].name = "fixed-search-time";
#line 53
  longopts[4].has_arg = 1;
#line 53
  longopts[4].flag = (int *)((void *)0);
#line 53
  longopts[4].val = 'f';
#line 53
  longopts[5].name = "xboard-mode";
#line 53
  longopts[5].has_arg = 0;
#line 53
  longopts[5].flag = & Flag.xboard;
#line 53
  longopts[5].val = 1;
#line 53
  longopts[6].name = "no-xboard-mode";
#line 53
  longopts[6].has_arg = 0;
#line 53
  longopts[6].flag = & Flag.xboard;
#line 53
  longopts[6].val = 0;
#line 53
  longopts[7].name = "permanent-brain";
#line 53
  longopts[7].has_arg = 0;
#line 53
  longopts[7].flag = & Flag.ponder;
#line 53
  longopts[7].val = 1;
#line 53
  longopts[8].name = "no-permanent-brain";
#line 53
  longopts[8].has_arg = 0;
#line 53
  longopts[8].flag = & Flag.ponder;
#line 53
  longopts[8].val = 0;
#line 53
  longopts[9].name = "show-thinking";
#line 53
  longopts[9].has_arg = 0;
#line 53
  longopts[9].flag = & Flag.post;
#line 53
  longopts[9].val = 0;
#line 53
  longopts[10].name = "no-show-thinking";
#line 53
  longopts[10].has_arg = 0;
#line 53
  longopts[10].flag = & Flag.post;
#line 53
  longopts[10].val = 1;
#line 53
  longopts[11].name = "cpu-time";
#line 53
  longopts[11].has_arg = 0;
#line 53
  longopts[11].flag = & Flag.cpu;
#line 53
  longopts[11].val = 1;
#line 53
  longopts[12].name = "no-cpu-time";
#line 53
  longopts[12].has_arg = 0;
#line 53
  longopts[12].flag = & Flag.cpu;
#line 53
  longopts[12].val = 0;
#line 53
  longopts[13].name = "poll-input";
#line 53
  longopts[13].has_arg = 0;
#line 53
  longopts[13].flag = & Flag.polling;
#line 53
  longopts[13].val = 1;
#line 53
  longopts[14].name = "no-poll-input";
#line 53
  longopts[14].has_arg = 0;
#line 53
  longopts[14].flag = & Flag.polling;
#line 53
  longopts[14].val = 0;
#line 53
  longopts[15].name = "use-opening-book";
#line 53
  longopts[15].has_arg = 0;
#line 53
  longopts[15].flag = & Flag.book;
#line 53
  longopts[15].val = 1;
#line 53
  longopts[16].name = "no-use-opening-book";
#line 53
  longopts[16].has_arg = 0;
#line 53
  longopts[16].flag = & Flag.book;
#line 53
  longopts[16].val = 0;
#line 53
  longopts[17].name = "easy-level";
#line 53
  longopts[17].has_arg = 1;
#line 53
  longopts[17].flag = (int *)((void *)0);
#line 53
  longopts[17].val = 'e';
#line 53
  longopts[18].name = "resign-value";
#line 53
  longopts[18].has_arg = 1;
#line 53
  longopts[18].flag = (int *)((void *)0);
#line 53
  longopts[18].val = 'r';
#line 53
  longopts[19].name = "learning";
#line 53
  longopts[19].has_arg = 0;
#line 53
  longopts[19].flag = & Flag.learn;
#line 53
  longopts[19].val = 1;
#line 53
  longopts[20].name = "no-learning";
#line 53
  longopts[20].has_arg = 0;
#line 53
  longopts[20].flag = & Flag.learn;
#line 53
  longopts[20].val = 0;
#line 53
  longopts[21].name = "primary-book-dir";
#line 53
  longopts[21].has_arg = 1;
#line 53
  longopts[21].flag = (int *)((void *)0);
#line 53
  longopts[21].val = 'P';
#line 53
  longopts[22].name = "secondary-book-dir";
#line 53
  longopts[22].has_arg = 1;
#line 53
  longopts[22].flag = (int *)((void *)0);
#line 53
  longopts[22].val = 'S';
#line 53
  longopts[23].name = "learning-file-dir";
#line 53
  longopts[23].has_arg = 1;
#line 53
  longopts[23].flag = (int *)((void *)0);
#line 53
  longopts[23].val = 'L';
#line 53
  longopts[24].name = "log-file-name";
#line 53
  longopts[24].has_arg = 1;
#line 53
  longopts[24].flag = (int *)((void *)0);
#line 53
  longopts[24].val = 'g';
#line 53
  longopts[25].name = (char const   *)0;
#line 53
  longopts[25].has_arg = 0;
#line 53
  longopts[25].flag = (int *)0;
#line 53
  longopts[25].val = 0;
#line 83
  t = clock();
#line 86
  setvbuf((FILE */* __restrict  */)stdout, (char */* __restrict  */)((char *)((void *)0)),
          2, (size_t )0);
#line 88
  printf((char const   */* __restrict  */)"Phalanx ");
#line 88
  puts("XXII-pg");
  }
#line 90
  if (argc > 1) {
    {
#line 90
    tmp___0 = strncmp("bcreate\000", (char const   *)*(argv + 1), (size_t )8);
    }
#line 90
    if (tmp___0 == 0) {
      {
#line 91
      tmp = bcreate(argc - 1, argv + 1);
      }
#line 91
      return (tmp);
    }
  }
  {
#line 94
  tmp___1 = time((time_t *)((void *)0));
#line 94
  tmp___2 = getpid();
#line 94
  srand((unsigned int )tmp___1 + (unsigned int )tmp___2);
#line 97
  signal(2, (void (*)(int  ))1);
#line 99
  setfen((char *)"rnbqkbnr/pppppppp/////PPPPPPPP/RNBQKBNR/w");
#line 113
  Flag.machine_color = 2;
#line 114
  Flag.post = 0;
#line 115
  Flag.analyze = 0;
#line 116
  Flag.xboard = 1;
#line 117
  Flag.book = 1;
#line 118
  Flag.centiseconds = 1000;
#line 119
  Flag.level = (tlevel )1;
#line 120
  Flag.ponder = 0;
#line 121
  Flag.cpu = 0;
#line 122
  Flag.increment = 0U;
#line 123
  Flag.polling = 1;
#line 124
  Flag.resign = 0;
#line 125
  Flag.easy = (unsigned char)0;
#line 126
  Flag.noise = 50;
#line 127
  Flag.learn = 1;
#line 128
  Flag.bench = 0;
#line 129
  Flag.log = (FILE *)((void *)0);
#line 130
  Scoring = 0;
#line 132
  SbookDir = (char *)((void *)0);
#line 133
  PbookDir = (char *)((void *)0);
#line 134
  EcoDir = (char *)((void *)0);
#line 135
  LbookDir = (char *)((void *)0);
#line 137
  opterr = 0;
  }
  {
#line 140
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 140
    c = getopt_long(argc, (char * const  *)argv, "vf:T:t:p:s:x:c:o:r:b:e:l:S:P:L:g:",
                    (struct option  const  *)(longopts), & indexptr);
    }
#line 140
    if (! (c != -1)) {
#line 140
      goto while_break;
    }
    {
#line 147
    if (c == 84) {
#line 147
      goto case_84;
    }
#line 150
    if (c == 116) {
#line 150
      goto case_116;
    }
#line 154
    if (c == 114) {
#line 154
      goto case_114;
    }
#line 158
    if (c == 102) {
#line 158
      goto case_102;
    }
#line 165
    if (c == 101) {
#line 165
      goto case_101;
    }
#line 172
    if (c == 112) {
#line 172
      goto case_112;
    }
#line 177
    if (c == 115) {
#line 177
      goto case_115;
    }
#line 182
    if (c == 120) {
#line 182
      goto case_120;
    }
#line 187
    if (c == 99) {
#line 187
      goto case_99;
    }
#line 192
    if (c == 111) {
#line 192
      goto case_111;
    }
#line 197
    if (c == 98) {
#line 197
      goto case_98;
    }
#line 202
    if (c == 108) {
#line 202
      goto case_108;
    }
#line 207
    if (c == 103) {
#line 207
      goto case_103;
    }
#line 217
    if (c == 118) {
#line 217
      goto case_118;
    }
#line 218
    if (c == 80) {
#line 218
      goto case_80;
    }
#line 219
    if (c == 69) {
#line 219
      goto case_69;
    }
#line 220
    if (c == 83) {
#line 220
      goto case_83;
    }
#line 221
    if (c == 76) {
#line 221
      goto case_76;
    }
#line 222
    if (c == 63) {
#line 222
      goto case_63;
    }
#line 145
    goto switch_break;
    case_84: /* CIL Label */ 
    {
#line 148
    tmp___3 = sscanf((char const   */* __restrict  */)optarg, (char const   */* __restrict  */)"%i",
                     & SizeHT);
    }
#line 148
    if (tmp___3 == 0) {
      {
#line 148
      badoptions();
      }
    }
#line 149
    goto switch_break;
    case_116: /* CIL Label */ 
    {
#line 151
    tmp___4 = sscanf((char const   */* __restrict  */)optarg, (char const   */* __restrict  */)"%i",
                     & SizeHT);
    }
#line 151
    if (tmp___4 == 0) {
      {
#line 151
      badoptions();
      }
    }
#line 152
    SizeHT = (unsigned int )((unsigned long )(1024U * SizeHT) / sizeof(thashentry ));
#line 153
    goto switch_break;
    case_114: /* CIL Label */ 
    {
#line 155
    tmp___5 = sscanf((char const   */* __restrict  */)optarg, (char const   */* __restrict  */)"%i",
                     & i);
    }
#line 155
    if (tmp___5 == 0) {
      {
#line 155
      badoptions();
      }
    }
    {
#line 156
    Flag.resign = abs(i);
    }
#line 157
    goto switch_break;
    case_102: /* CIL Label */ 
    {
#line 161
    tmp___6 = sscanf((char const   */* __restrict  */)optarg, (char const   */* __restrict  */)"%i",
                     & t___0);
    }
#line 161
    if (tmp___6 == 0) {
      {
#line 161
      badoptions();
      }
    }
#line 162
    Flag.centiseconds = t___0 * 100;
#line 163
    Flag.level = (tlevel )2;
#line 164
    goto switch_break;
    case_101: /* CIL Label */ 
    {
#line 168
    tmp___7 = sscanf((char const   */* __restrict  */)optarg, (char const   */* __restrict  */)"%i",
                     & e);
    }
#line 168
    if (tmp___7 == 0) {
      {
#line 168
      badoptions();
      }
    }
#line 169
    if (e > 100) {
      {
#line 169
      badoptions();
      }
    }
#line 170
    Flag.easy = (unsigned char )e;
#line 171
    goto switch_break;
    case_112: /* CIL Label */ 
    {
#line 173
    if ((int )*optarg == 43) {
#line 173
      goto case_43;
    }
#line 174
    if ((int )*optarg == 45) {
#line 174
      goto case_45;
    }
#line 175
    goto switch_default;
    case_43: /* CIL Label */ 
#line 173
    Flag.ponder = 1;
#line 173
    goto switch_break___0;
    case_45: /* CIL Label */ 
#line 174
    Flag.ponder = 0;
#line 174
    goto switch_break___0;
    switch_default: /* CIL Label */ 
    {
#line 175
    badoptions();
    }
    switch_break___0: /* CIL Label */ ;
    }
#line 176
    goto switch_break;
    case_115: /* CIL Label */ 
    {
#line 178
    if ((int )*optarg == 43) {
#line 178
      goto case_43___0;
    }
#line 179
    if ((int )*optarg == 45) {
#line 179
      goto case_45___0;
    }
#line 180
    goto switch_default___0;
    case_43___0: /* CIL Label */ 
#line 178
    Flag.post = 1;
#line 178
    goto switch_break___1;
    case_45___0: /* CIL Label */ 
#line 179
    Flag.post = 0;
#line 179
    goto switch_break___1;
    switch_default___0: /* CIL Label */ 
    {
#line 180
    badoptions();
    }
    switch_break___1: /* CIL Label */ ;
    }
#line 181
    goto switch_break;
    case_120: /* CIL Label */ 
    {
#line 183
    if ((int )*optarg == 43) {
#line 183
      goto case_43___1;
    }
#line 184
    if ((int )*optarg == 45) {
#line 184
      goto case_45___1;
    }
#line 185
    goto switch_default___1;
    case_43___1: /* CIL Label */ 
#line 183
    Flag.xboard = 1;
#line 183
    goto switch_break___2;
    case_45___1: /* CIL Label */ 
#line 184
    Flag.xboard = 0;
#line 184
    goto switch_break___2;
    switch_default___1: /* CIL Label */ 
    {
#line 185
    badoptions();
    }
    switch_break___2: /* CIL Label */ ;
    }
#line 186
    goto switch_break;
    case_99: /* CIL Label */ 
    {
#line 188
    if ((int )*optarg == 43) {
#line 188
      goto case_43___2;
    }
#line 189
    if ((int )*optarg == 45) {
#line 189
      goto case_45___2;
    }
#line 190
    goto switch_default___2;
    case_43___2: /* CIL Label */ 
#line 188
    Flag.cpu = 1;
#line 188
    goto switch_break___3;
    case_45___2: /* CIL Label */ 
#line 189
    Flag.cpu = 0;
#line 189
    goto switch_break___3;
    switch_default___2: /* CIL Label */ 
    {
#line 190
    badoptions();
    }
    switch_break___3: /* CIL Label */ ;
    }
#line 191
    goto switch_break;
    case_111: /* CIL Label */ 
    {
#line 193
    if ((int )*optarg == 43) {
#line 193
      goto case_43___3;
    }
#line 194
    if ((int )*optarg == 45) {
#line 194
      goto case_45___3;
    }
#line 195
    goto switch_default___3;
    case_43___3: /* CIL Label */ 
#line 193
    Flag.polling = 1;
#line 193
    goto switch_break___4;
    case_45___3: /* CIL Label */ 
#line 194
    Flag.polling = 0;
#line 194
    goto switch_break___4;
    switch_default___3: /* CIL Label */ 
    {
#line 195
    badoptions();
    }
    switch_break___4: /* CIL Label */ ;
    }
#line 196
    goto switch_break;
    case_98: /* CIL Label */ 
    {
#line 198
    if ((int )*optarg == 43) {
#line 198
      goto case_43___4;
    }
#line 199
    if ((int )*optarg == 45) {
#line 199
      goto case_45___4;
    }
#line 200
    goto switch_default___4;
    case_43___4: /* CIL Label */ 
#line 198
    Flag.book = 1;
#line 198
    goto switch_break___5;
    case_45___4: /* CIL Label */ 
#line 199
    Flag.book = 0;
#line 199
    goto switch_break___5;
    switch_default___4: /* CIL Label */ 
    {
#line 200
    badoptions();
    }
    switch_break___5: /* CIL Label */ ;
    }
#line 201
    goto switch_break;
    case_108: /* CIL Label */ 
    {
#line 203
    if ((int )*optarg == 43) {
#line 203
      goto case_43___5;
    }
#line 204
    if ((int )*optarg == 45) {
#line 204
      goto case_45___5;
    }
#line 205
    goto switch_default___5;
    case_43___5: /* CIL Label */ 
#line 203
    Flag.learn = 1;
#line 203
    goto switch_break___6;
    case_45___5: /* CIL Label */ 
#line 204
    Flag.learn = 0;
#line 204
    goto switch_break___6;
    switch_default___5: /* CIL Label */ 
    {
#line 205
    badoptions();
    }
    switch_break___6: /* CIL Label */ ;
    }
#line 206
    goto switch_break;
    case_103: /* CIL Label */ 
    {
#line 209
    Flag.log = fopen((char const   */* __restrict  */)optarg, (char const   */* __restrict  */)"a");
    }
#line 209
    if ((unsigned long )Flag.log != (unsigned long )((void *)0)) {
      {
#line 211
      setvbuf((FILE */* __restrict  */)Flag.log, (char */* __restrict  */)((char *)((void *)0)),
              2, (size_t )0);
#line 212
      printf((char const   */* __restrict  */)"log file %s\n", optarg);
      }
    } else {
      {
#line 215
      printf((char const   */* __restrict  */)"telluser Phalanx: cannot open log file\n");
      }
    }
#line 216
    goto switch_break;
    case_118: /* CIL Label */ 
    {
#line 217
    exit(0);
    }
    case_80: /* CIL Label */ 
    {
#line 218
    PbookDir = strdup((char const   *)optarg);
    }
#line 218
    goto switch_break;
    case_69: /* CIL Label */ 
    {
#line 219
    EcoDir = strdup((char const   *)optarg);
    }
#line 219
    goto switch_break;
    case_83: /* CIL Label */ 
    {
#line 220
    SbookDir = strdup((char const   *)optarg);
    }
#line 220
    goto switch_break;
    case_76: /* CIL Label */ 
    {
#line 221
    LbookDir = strdup((char const   *)optarg);
    }
#line 221
    goto switch_break;
    case_63: /* CIL Label */ 
    {
#line 223
    badoptions();
    }
#line 224
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 231
  if (argc - optind == 0) {
#line 231
    goto case_0;
  }
#line 232
  if (argc - optind == 1) {
#line 232
    goto case_1;
  }
#line 239
  if (argc - optind == 2) {
#line 239
    goto case_2;
  }
#line 246
  if (argc - optind == 3) {
#line 246
    goto case_3;
  }
#line 255
  goto switch_default___6;
  case_0: /* CIL Label */ 
#line 231
  goto switch_break___7;
  case_1: /* CIL Label */ 
#line 233
  if (argc == 2) {
    {
#line 233
    tmp___8 = strncmp("bench\000", (char const   *)*(argv + 1), (size_t )6);
    }
#line 233
    if (tmp___8 == 0) {
#line 234
      Flag.bench = 1;
#line 234
      goto switch_break___7;
    }
  }
  {
#line 235
  tmp___9 = sscanf((char const   */* __restrict  */)*(argv + optind), (char const   */* __restrict  */)"%i",
                   & m___1);
  }
#line 235
  if (tmp___9 == 0) {
    {
#line 235
    badoptions();
    }
  }
#line 236
  Flag.centiseconds = 100 * m___1;
#line 237
  Flag.level = (tlevel )1;
#line 238
  goto switch_break___7;
  case_2: /* CIL Label */ 
  {
#line 240
  tmp___10 = sscanf((char const   */* __restrict  */)*(argv + optind), (char const   */* __restrict  */)"%i",
                    & m___1);
  }
#line 240
  if (tmp___10 == 0) {
    {
#line 240
    badoptions();
    }
  }
  {
#line 241
  Flag.moves = (unsigned int )m___1;
#line 242
  tmp___11 = sscanf((char const   */* __restrict  */)*(argv + (optind + 1)), (char const   */* __restrict  */)"%i",
                    & m___1);
  }
#line 242
  if (tmp___11 == 0) {
    {
#line 242
    badoptions();
    }
  }
#line 243
  Flag.centiseconds = m___1 * 6000;
#line 244
  Flag.level = (tlevel )0;
#line 245
  goto switch_break___7;
  case_3: /* CIL Label */ 
  {
#line 247
  tmp___12 = sscanf((char const   */* __restrict  */)*(argv + optind), (char const   */* __restrict  */)"%i",
                    & m___1);
  }
#line 247
  if (tmp___12 == 0) {
    {
#line 247
    badoptions();
    }
  }
  {
#line 248
  Flag.moves = (unsigned int )m___1;
#line 249
  tmp___13 = sscanf((char const   */* __restrict  */)*(argv + (optind + 1)), (char const   */* __restrict  */)"%i",
                    & m___1);
  }
#line 249
  if (tmp___13 == 0) {
    {
#line 249
    badoptions();
    }
  }
  {
#line 250
  Flag.centiseconds = m___1 * 6000;
#line 251
  tmp___14 = sscanf((char const   */* __restrict  */)*(argv + (optind + 2)), (char const   */* __restrict  */)"%i",
                    & m___1);
  }
#line 251
  if (tmp___14 == 0) {
    {
#line 251
    badoptions();
    }
  }
#line 252
  Flag.increment = (unsigned int )m___1;
#line 253
  Flag.level = (tlevel )0;
#line 254
  goto switch_break___7;
  switch_default___6: /* CIL Label */ 
  {
#line 255
  badoptions();
  }
  switch_break___7: /* CIL Label */ ;
  }
#line 259
  if (Flag.easy) {
#line 260
    SizeHT = 0U;
#line 260
    Flag.ponder = 0;
#line 260
    Flag.learn = 0;
  } else
#line 262
  if (SizeHT != 0U) {
    {
#line 264
    tmp___15 = calloc((size_t )SizeHT, sizeof(thashentry ));
#line 264
    HT = (thashentry *)tmp___15;
    }
#line 265
    if ((unsigned long )HT == (unsigned long )((void *)0)) {
      {
#line 267
      puts("cannot alloc hashtable");
#line 267
      SizeHT = 0U;
      }
    }
  }
  {
#line 272
  initcache();
#line 275
  initdist();
  }
#line 277
  if (Flag.bench) {
    {
#line 282
    allnodes = (int64 )0;
#line 283
    positions___0[0] = (char *)"rnbqkbnr/pppppppp/////PPPPPPPP/RNBQKBNR/w";
#line 283
    positions___0[1] = (char *)"2kr3r/pp3Npp/2pbbn2/6B1/2BPp3/6Pq/PPP1Q2P/2KR3R b";
#line 283
    positions___0[2] = (char *)"r1bq1r1k/2pn2bp/1p1p1np1/pN1Pp3/1PP1Pp2/P2B1P2/1BQN2PP/1R3RK1 b";
#line 283
    positions___0[3] = (char *)"r4rk1/2p1p1b1/p1n3pp/1p1qP3/P1pP4/B1P2PPN/4Q1K1/R6R b";
#line 283
    positions___0[4] = (char *)"8/1p3rpp/p2nk3/P3p3/2R5/2N2PP1/1P2K2P/8 w";
#line 283
    positions___0[5] = (char *)"rnbr2k1/ppq1ppbp/6p1/2p5/3P4/2PBPN2/P4PPP/1RBQ1RK1 w";
#line 283
    positions___0[6] = (char *)"3r1rk1/1q2b1pp/pn3p2/1pp5/4PB2/5N2/PP1RQPPP/3R2K1 w";
#line 283
    positions___0[7] = (char *)"8/2p5/5pK1/5R2/4k2P/p4P2/1r6/8 b";
#line 283
    positions___0[8] = (char *)"3r1rk1/p3qp1p/2bb2p1/2pp4/8/1P2P3/PBQN1PPP/2R2RK1 b";
#line 283
    positions___0[9] = (char *)"k7/ppp5/8/8/8/8/P1P5/K7/w";
#line 295
    Flag.cpu = 1;
#line 296
    Flag.level = (tlevel )2;
#line 297
    Flag.centiseconds = 3000;
#line 298
    Flag.polling = 0;
#line 298
    Flag.ponder = Flag.polling;
#line 298
    Flag.learn = Flag.ponder;
#line 298
    Flag.book = Flag.learn;
#line 298
    Flag.post = Flag.book;
#line 299
    printf((char const   */* __restrict  */)"Running benchmark, this will take 5 minutes of CPU time.\n");
#line 300
    printf((char const   */* __restrict  */)"----------\b\b\b\b\b\b\b\b\b\b");
#line 301
    tim = ptime();
#line 303
    i___0 = 0;
    }
    {
#line 303
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 303
      if (! (i___0 != 10)) {
#line 303
        goto while_break___0;
      }
      {
#line 305
      setfen(positions___0[i___0]);
      }
#line 306
      if (i___0 != 0) {
        {
#line 306
        printf((char const   */* __restrict  */)"+");
        }
      }
      {
#line 307
      fflush(stdout);
#line 308
      root_search();
      }
#line 309
      if (Abort == 1) {
#line 309
        return (0);
      }
#line 310
      allnodes += Nodes;
#line 303
      i___0 ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 312
    tmp___16 = ptime();
#line 312
    printf((char const   */* __restrict  */)"+\n%10i nodes per second\n", (int )((100LL * allnodes) / (int64 )(tmp___16 - tim)));
    }
#line 315
    return (0);
  }
  {
#line 320
  SbookDir = get_book_file(SbookDir, (char *)"PHALANXSBOOKDIR", (char *)"/usr/lib/games/phalanx",
                           (char *)"sbook.phalanx", 4);
#line 321
  Sbook.f = fopen((char const   */* __restrict  */)SbookDir, (char const   */* __restrict  */)"rb");
#line 322
  PbookDir = get_book_file(PbookDir, (char *)"PHALANXPBOOKDIR", (char *)"/usr/share/games/phalanx",
                           (char *)"pbook.phalanx", 4);
#line 323
  Pbook.f = fopen((char const   */* __restrict  */)PbookDir, (char const   */* __restrict  */)"rb");
#line 324
  EcoDir = get_book_file(EcoDir, (char *)"PHALANXECODIR", (char *)"/usr/local/lib/phalanx",
                         (char *)"eco.phalanx", 4);
#line 325
  Eco = fopen((char const   */* __restrict  */)EcoDir, (char const   */* __restrict  */)"rb");
  }
#line 326
  if (Flag.learn) {
    {
#line 328
    LbookDir = get_book_file(LbookDir, (char *)"PHALANXLEARNDIR", (char *)"/var/games",
                             (char *)"phalanx.learn", 6);
#line 330
    Learn.f = fopen((char const   */* __restrict  */)LbookDir, (char const   */* __restrict  */)"r+");
    }
#line 331
    if ((unsigned long )Learn.f == (unsigned long )((void *)0)) {
      {
#line 336
      memset((void *)(b), 0, 65536UL * sizeof(int ));
#line 337
      sprintf((char */* __restrict  */)(filename___0), (char const   */* __restrict  */)"./%s",
              "phalanx.learn");
#line 338
      free((void *)LbookDir);
#line 339
      LbookDir = strdup((char const   *)(filename___0));
#line 340
      Learn.f = fopen((char const   */* __restrict  */)LbookDir, (char const   */* __restrict  */)"w+");
#line 341
      tmp___17 = fwrite((void const   */* __restrict  */)(b), sizeof(int ), (size_t )65536,
                        (FILE */* __restrict  */)Learn.f);
      }
#line 341
      if (tmp___17 == 65536UL) {
        {
#line 342
        printf((char const   */* __restrict  */)"telluser Phalanx: created learn file %s\n",
               LbookDir);
        }
      }
    }
  } else {
#line 344
    Learn.f = (FILE *)((void *)0);
  }
#line 346
  if ((unsigned long )Pbook.f != (unsigned long )((void *)0)) {
    {
#line 349
    stat((char const   */* __restrict  */)PbookDir, (struct stat */* __restrict  */)(& fs));
#line 349
    Pbook.filesize = (int )fs.st_size;
#line 350
    printf((char const   */* __restrict  */)"primary book %s, %d bytes\n", PbookDir,
           Pbook.filesize);
    }
  }
#line 353
  if ((unsigned long )Sbook.f != (unsigned long )((void *)0)) {
    {
#line 357
    stat((char const   */* __restrict  */)SbookDir, (struct stat */* __restrict  */)(& fs___0));
#line 357
    Sbook.filesize = (int )fs___0.st_size;
#line 358
    myfread((void *)(& pos), (int )sizeof(unsigned int ), Sbook.f);
#line 358
    Sbook.firstkey = pos;
#line 359
    fseek(Sbook.f, (long )(Sbook.filesize - 6), 0);
#line 360
    myfread((void *)(& pos), (int )sizeof(unsigned int ), Sbook.f);
#line 360
    Sbook.lastkey = pos;
#line 361
    printf((char const   */* __restrict  */)"secondary book %s, %d bytes\n", SbookDir,
           Sbook.filesize);
    }
  }
#line 364
  if ((unsigned long )Learn.f != (unsigned long )((void *)0)) {
    {
#line 367
    stat((char const   */* __restrict  */)LbookDir, (struct stat */* __restrict  */)(& fs___1));
#line 367
    Learn.filesize = (int )fs___1.st_size;
#line 368
    printf((char const   */* __restrict  */)"learning file %s, %d bytes\n", LbookDir,
           Learn.filesize);
    }
  }
#line 371
  if ((unsigned long )Eco != (unsigned long )((void *)0)) {
    {
#line 374
    stat((char const   */* __restrict  */)EcoDir, (struct stat */* __restrict  */)(& fs___2));
#line 375
    printf((char const   */* __restrict  */)"eco file %s, %i bytes\n", EcoDir, (int )fs___2.st_size);
    }
  }
#line 378
  if ((unsigned long )Sbook.f == (unsigned long )((void *)0)) {
#line 378
    goto _L;
  } else
#line 378
  if ((unsigned long )Pbook.f == (unsigned long )((void *)0)) {
    _L: /* CIL Label */ 
#line 379
    if (Flag.xboard) {
      {
#line 379
      printf((char const   */* __restrict  */)"telluser Phalanx: ");
      }
    }
    {
#line 380
    printf((char const   */* __restrict  */)"Cannot open ");
    }
  }
#line 383
  if ((unsigned long )Sbook.f == (unsigned long )((void *)0)) {
#line 384
    if ((unsigned long )Pbook.f == (unsigned long )((void *)0)) {
      {
#line 385
      printf((char const   */* __restrict  */)"both [%s] and [%s]\n", "sbook.phalanx",
             "pbook.phalanx");
      }
    } else {
      {
#line 387
      printf((char const   */* __restrict  */)"[%s]\n", "sbook.phalanx");
      }
    }
  } else
#line 389
  if ((unsigned long )Pbook.f == (unsigned long )((void *)0)) {
    {
#line 390
    printf((char const   */* __restrict  */)"[%s]\n", "pbook.phalanx");
    }
  }
#line 392
  if ((unsigned long )Learn.f == (unsigned long )((void *)0)) {
#line 392
    if (Flag.learn) {
      {
#line 393
      Flag.learn = 0;
#line 393
      puts("telluser Phalanx: cannot open learn file");
      }
    }
  }
  {
#line 395
  printf((char const   */* __restrict  */)"tellics set 1 Phalanx ");
#line 395
  printf((char const   */* __restrict  */)"XXII-pg");
  }
#line 396
  if (Flag.easy) {
    {
#line 397
    printf((char const   */* __restrict  */)", easy level %i\n", (int )Flag.easy);
    }
  } else {
    {
#line 399
    printf((char const   */* __restrict  */)", %i kB hashtable, %i/%i kB P/S opening book",
           (int )(((unsigned long )(1U + SizeHT) * sizeof(thashentry ) - 1UL) / 1024UL),
           Pbook.filesize / 1024, Sbook.filesize / 1024);
    }
  }
  {
#line 400
  printf((char const   */* __restrict  */)"\n");
#line 404
  shell();
#line 408
  tmp___18 = clock();
#line 408
  t = tmp___18 - t;
#line 409
  printf((char const   */* __restrict  */)"Processor time ......... %i:%02i:%02i.%02i\n",
         (int )((t / 1000000L) / 3600L), (int )(((t / 1000000L) % 3600L) / 60L), (int )((t / 1000000L) % 60L),
         (int )(((t * 100L) / 1000000L) % 100L));
  }
#line 415
  if (Age != 0U) {
    {
#line 417
    printf((char const   */* __restrict  */)"Average search depth ... %g\n", (double )((float )AllDepth / (float )(Age * 100U)));
#line 419
    printf((char const   */* __restrict  */)"Average NPS report ..... %g\n", (double )((float )AllNPS / (float )Age));
    }
  }
  {
#line 423
  printf((char const   */* __restrict  */)"Hash table age ......... %i\n", Age);
#line 425
  puts("Good bye!");
  }
#line 427
  return (0);
}
}
#line 438 "/home/wheatley/newnew/temp/phalanx-22+d051004/phalanx.h"
thashentry *HT  ;
#line 8 "/home/wheatley/newnew/temp/phalanx-22+d051004/hash.c"
unsigned int SizeHT  =    70000U;
#line 9 "/home/wheatley/newnew/temp/phalanx-22+d051004/hash.c"
unsigned int Age  =    0U;
#line 15 "/home/wheatley/newnew/temp/phalanx-22+d051004/hash.c"
unsigned int smove(tmove *m___1 ) 
{ 
  unsigned int sm ;

  {
#line 18
  sm = (unsigned int )((int )m___1->from << 8);
#line 19
  if (m___1->special) {
#line 19
    return (sm | (unsigned int )m___1->special);
  }
#line 20
  sm |= (unsigned int )m___1->to;
#line 21
  if ((int )m___1->in1 != (int )m___1->in2a) {
    {
#line 22
    if ((int )m___1->in2a == 81) {
#line 22
      goto case_81;
    }
#line 22
    if ((int )m___1->in2a == 82) {
#line 22
      goto case_82;
    }
#line 23
    if ((int )m___1->in2a == 65) {
#line 23
      goto case_65;
    }
#line 23
    if ((int )m___1->in2a == 66) {
#line 23
      goto case_66;
    }
#line 24
    if ((int )m___1->in2a == 49) {
#line 24
      goto case_49;
    }
#line 24
    if ((int )m___1->in2a == 50) {
#line 24
      goto case_50;
    }
#line 25
    if ((int )m___1->in2a == 33) {
#line 25
      goto case_33;
    }
#line 25
    if ((int )m___1->in2a == 34) {
#line 25
      goto case_34;
    }
#line 21
    goto switch_break;
    case_81: /* CIL Label */ 
#line 22
    sm -= 10U;
#line 22
    goto switch_break;
    case_82: /* CIL Label */ 
#line 22
    sm += 10U;
#line 22
    goto switch_break;
    case_65: /* CIL Label */ 
#line 23
    sm -= 20U;
#line 23
    goto switch_break;
    case_66: /* CIL Label */ 
#line 23
    sm += 20U;
#line 23
    goto switch_break;
    case_49: /* CIL Label */ 
#line 24
    sm -= 30U;
#line 24
    goto switch_break;
    case_50: /* CIL Label */ 
#line 24
    sm += 30U;
#line 24
    goto switch_break;
    case_33: /* CIL Label */ 
#line 25
    sm -= 40U;
#line 25
    goto switch_break;
    case_34: /* CIL Label */ 
#line 25
    sm += 40U;
#line 25
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
#line 27
  return (sm);
}
}
#line 31 "/home/wheatley/newnew/temp/phalanx-22+d051004/hash.c"
thashentry *seekHT(void) 
{ 
  register int i ;
  register thashentry *t ;

  {
#line 36
  i = 0;
  {
#line 36
  while (1) {
    while_continue: /* CIL Label */ ;
#line 36
    if (! (i != 3)) {
#line 36
      goto while_break;
    }
#line 38
    t = HT + (G[Counter].hashboard + (unsigned int )i) % SizeHT;
#line 39
    if (G[Counter].hashboard == t->hashboard) {
#line 39
      return (t);
    }
#line 36
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 42
  return ((thashentry *)((void *)0));
}
}
#line 55 "/home/wheatley/newnew/temp/phalanx-22+d051004/hash.c"
void writeHT(int value , int Alpha , int Beta ) 
{ 
  register int i ;
  register thashentry *t ;
  register thashentry *best ;
  tmove *m___1 ;
  unsigned int tmp ;

  {
#line 59
  best = (thashentry *)((void *)0);
#line 60
  m___1 = & PV[Ply][Ply];
#line 63
  i = 0;
  {
#line 63
  while (1) {
    while_continue: /* CIL Label */ ;
#line 63
    if (! (i != 3)) {
#line 63
      goto while_break;
    }
#line 65
    t = HT + (G[Counter].hashboard + (unsigned int )i) % SizeHT;
#line 66
    if (G[Counter].hashboard == t->hashboard) {
#line 67
      best = t;
#line 67
      goto while_break;
    } else
#line 66
    if (t->hashboard == 0U) {
#line 67
      best = t;
#line 67
      goto while_break;
    }
#line 63
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 71
  if ((unsigned long )best == (unsigned long )((void *)0)) {
#line 72
    i = 0;
    {
#line 72
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 72
      if (! (i != 3)) {
#line 72
        goto while_break___0;
      }
#line 74
      t = HT + (G[Counter].hashboard + (unsigned int )i) % SizeHT;
#line 75
      if ((unsigned int )t->age < Age) {
#line 75
        if ((unsigned long )best == (unsigned long )((void *)0)) {
#line 75
          best = t;
        } else
#line 75
        if ((int )best->age > (int )t->age) {
#line 75
          best = t;
        }
      }
#line 72
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 79
  if ((unsigned long )best == (unsigned long )((void *)0)) {
#line 80
    i = 0;
    {
#line 80
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 80
      if (! (i != 3)) {
#line 80
        goto while_break___1;
      }
#line 82
      t = HT + (G[Counter].hashboard + (unsigned int )i) % SizeHT;
#line 83
      if ((unsigned long )best == (unsigned long )((void *)0)) {
#line 85
        best = t;
      } else
#line 83
      if ((int )best->depth > (int )t->depth) {
#line 85
        best = t;
      } else
#line 83
      if ((int )best->depth == (int )t->depth) {
#line 83
        if (best->result != 3U) {
#line 83
          if (t->result == 3U) {
#line 85
            best = t;
          }
        }
      }
#line 80
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 88
  if (best->hashboard == G[Counter].hashboard) {
#line 88
    if ((int )best->depth > Depth) {
#line 88
      if (best->result != 3U) {
#line 89
        return;
      }
    }
  }
#line 91
  if (value > 29900) {
#line 91
    best->value = (short )(value + Ply);
  } else
#line 92
  if (value < -29900) {
#line 92
    best->value = (short )(value - Ply);
  } else {
#line 93
    best->value = (short )value;
  }
#line 95
  if (value <= Alpha) {
#line 95
    best->result = 2U;
  } else
#line 97
  if (value >= Beta) {
#line 97
    best->result = 3U;
  } else {
#line 99
    best->result = 1U;
  }
#line 102
  if (best->result != 2U) {
    {
#line 102
    tmp = smove(m___1);
#line 102
    best->move = (unsigned short )tmp;
    }
  } else
#line 103
  if (best->hashboard != G[Counter].hashboard) {
#line 103
    best->move = (unsigned short)0;
  }
#line 105
  best->hashboard = G[Counter].hashboard;
#line 106
  best->age = (unsigned short )Age;
#line 107
  best->depth = (short )Depth;
#line 109
  return;
}
}
#line 116 "/home/wheatley/newnew/temp/phalanx-22+d051004/hash.c"
unsigned int hashboard(void) 
{ 
  register int i ;
  unsigned int result ;

  {
#line 120
  result = 0U;
#line 121
  i = 21;
  {
#line 121
  while (1) {
    while_continue: /* CIL Label */ ;
#line 121
    if (! (i != 99)) {
#line 121
      goto while_break;
    }
#line 121
    if ((int )B[i] != 3) {
#line 121
      if ((int )B[i] != 0) {
#line 128
        result ^= H[HP[B[i]]][*(HS + i)];
      }
    }
#line 121
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 131
  if (Color == 2) {
#line 131
    result ^= 4256789809U;
  }
#line 140
  return (result);
}
}
#line 152 "/home/wheatley/newnew/temp/phalanx-22+d051004/hash.c"
unsigned int H[12][64]  = 
#line 152
  { {        2356691068U,        3278273354U,        581782765U,        197846567U, 
            1541581219U,        3298035285U,        659332555U,        3042882408U, 
            3871809134U,        2594078446U,        3290823975U,        3422584557U, 
            1197576933U,        2313409445U,        3933797115U,        661019600U, 
            2655445253U,        3448472258U,        782793402U,        1413885076U, 
            3007618517U,        1114008157U,        1063614824U,        1305423333U, 
            153683000U,        1050007895U,        3538238799U,        2383859186U, 
            3463315106U,        1969490851U,        3986635172U,        986078252U, 
            3151831267U,        2551391369U,        1602206225U,        683695757U, 
            2467123902U,        1528942711U,        158400912U,        222680914U, 
            1683817491U,        774036439U,        2713147455U,        922961011U, 
            2722623946U,        1845213941U,        1161338863U,        4165065905U, 
            1883304343U,        4020036143U,        4151687220U,        2594741668U, 
            2371080944U,        933074509U,        489282231U,        3645930431U, 
            2523984747U,        1167810745U,        2577862819U,        1005723518U, 
            135475726U,        4254718967U,        852291921U,        1876777989U}, 
   {        4078925052U,        1536397862U,        3654630035U,        975647793U, 
            4012468608U,        4114689563U,        1307586395U,        2753010000U, 
            1931267156U,        1341353904U,        1749392444U,        3602399813U, 
            993815615U,        1835626870U,        3925596685U,        2688387212U, 
            1225368675U,        2903834575U,        1348391772U,        3256862295U, 
            1036195685U,        2460664898U,        3544304655U,        1817950897U, 
            3092261515U,        413563414U,        2385426609U,        2024589910U, 
            3651355126U,        3878409569U,        2291809513U,        2927020482U, 
            2330539859U,        4188636178U,        2470377768U,        856992034U, 
            4068034863U,        1256278431U,        438258259U,        1261165915U, 
            533055463U,        518698549U,        3910732538U,        453325691U, 
            2027691727U,        3497711264U,        3381022903U,        2818552624U, 
            1320852613U,        3650937128U,        3163875077U,        1317181734U, 
            2823738763U,        2270025730U,        4101384355U,        2628094896U, 
            262628737U,        3427339436U,        3281109580U,        2715757099U, 
            59755709U,        4242111908U,        2917372471U,        2684680703U}, 
   {        1357662618U,        1461997009U,        2560469884U,        966015129U, 
            84339262U,        1656327583U,        3529518960U,        2616949953U, 
            2115890285U,        3927315632U,        2588400309U,        677618285U, 
            773290866U,        3669758945U,        3860510409U,        416557861U, 
            3396950732U,        1716421789U,        2606332512U,        1945121346U, 
            3411501892U,        824524779U,        389867835U,        1584543946U, 
            3226607345U,        1735817238U,        4176521996U,        2249013124U, 
            3899372227U,        1196744135U,        1308703393U,        3699258928U, 
            3623517938U,        1054303380U,        2306732127U,        2943159215U, 
            3743907095U,        3611131574U,        3458819082U,        358004090U, 
            1290000290U,        2695500859U,        1315976912U,        419334844U, 
            1049511889U,        3022813437U,        1448177097U,        1780704992U, 
            1162372078U,        3940293682U,        117307035U,        3184086667U, 
            1410617213U,        1162755409U,        1167492034U,        3042934203U, 
            531300272U,        158352815U,        3961130326U,        1234921889U, 
            3904120474U,        2029671386U,        4198467180U,        922399352U}, 
   {        2587135219U,        3732817035U,        3475461452U,        754606991U, 
            3467191356U,        669170558U,        2575199390U,        2124747961U, 
            2830571193U,        1172610400U,        4059845409U,        2839002357U, 
            3298203420U,        3300395835U,        839307771U,        1450205547U, 
            3391992771U,        32177802U,        3172419413U,        231985218U, 
            3092847744U,        364310779U,        601073399U,        501813418U, 
            790234474U,        2534727994U,        253222414U,        3368323412U, 
            3881455668U,        852993376U,        1925946450U,        1652116274U, 
            2564697838U,        289465879U,        1287767045U,        741448626U, 
            1646983657U,        2641283616U,        2111121575U,        1651694164U, 
            249286470U,        1225907566U,        2312398655U,        387938484U, 
            3206582827U,        3947885434U,        111014481U,        930909762U, 
            3850969191U,        2013215276U,        2655752514U,        2934781628U, 
            3531356553U,        3223072652U,        1494384273U,        558859918U, 
            155564074U,        2037515238U,        3824231903U,        713019453U, 
            3286619651U,        4157303466U,        3453037316U,        2255084492U}, 
   {        1767443761U,        383365361U,        1733000179U,        3614402983U, 
            2791794353U,        2146375796U,        4122084547U,        3746860415U, 
            1091992658U,        840786078U,        2876166615U,        40990932U, 
            2309878395U,        3101865695U,        435645118U,        1106748433U, 
            3174092164U,        1440169518U,        2661838035U,        1312584681U, 
            3447054135U,        1283555582U,        3641580753U,        3515079262U, 
            1376793752U,        2056407572U,        1949577747U,        1054619084U, 
            1676139804U,        1698055238U,        92675115U,        4073092936U, 
            794354107U,        661518107U,        2722697770U,        1743819403U, 
            1577254940U,        3952739353U,        2493107974U,        3326356503U, 
            2554324520U,        712963992U,        3090180952U,        3238741863U, 
            2716835515U,        1571096752U,        3765011593U,        1345200486U, 
            469894113U,        3976659272U,        801392734U,        1877326595U, 
            1114460215U,        3367301152U,        43708241U,        2745592380U, 
            1544650554U,        335972674U,        1457377644U,        2801953109U, 
            3412829646U,        3945849355U,        351263978U,        2967868908U}, 
   {        1575874724U,        3084474529U,        1575228961U,        3863286401U, 
            2307455915U,        4288753401U,        1306105023U,        3048121304U, 
            1174222680U,        1129655682U,        3325433024U,        1270233742U, 
            2119168037U,        4059145156U,        1130609044U,        924695784U, 
            1006619292U,        295894939U,        1516850842U,        53504480U, 
            4075081615U,        1342317837U,        3885044054U,        2887650316U, 
            1216586755U,        4086621550U,        2423254629U,        1724172435U, 
            232389813U,        2470960571U,        2229290874U,        142398486U, 
            2291712557U,        386073746U,        688582373U,        3605098697U, 
            3390871685U,        2144128008U,        780754335U,        1299432242U, 
            179662073U,        2675175779U,        767721445U,        4179088687U, 
            244732297U,        306517158U,        1062227473U,        2669589721U, 
            759730554U,        2073723086U,        2979740935U,        3447317855U, 
            782703418U,        911896452U,        481382487U,        1928331548U, 
            3226069877U,        3860983742U,        2217582015U,        2802115622U, 
            2682391918U,        2555528214U,        1053587964U,        990246567U}, 
   {        3044765049U,        3554484376U,        2870320750U,        3663951163U, 
            885552107U,        4216698632U,        886045220U,        761830873U, 
            1600807931U,        2894473759U,        287196263U,        1843221508U, 
            544285762U,        2727461724U,        4156606528U,        4172323242U, 
            725781344U,        4234694635U,        1037989109U,        3624934613U, 
            26664388U,        754185807U,        958866733U,        2046549213U, 
            3897905556U,        2796838887U,        1999986178U,        4027047011U, 
            520219361U,        84607853U,        1527942470U,        118702239U, 
            1194511227U,        13587042U,        2268806133U,        701178137U, 
            2602527980U,        3320880069U,        2902121595U,        2600048638U, 
            4087877490U,        2597869162U,        978863844U,        3466156007U, 
            1517763085U,        1691999259U,        336820072U,        3588363421U, 
            3776949362U,        4047620865U,        3520748228U,        2272095732U, 
            1034234400U,        2040636300U,        1386795821U,        1209596973U, 
            1917274701U,        952391191U,        2032851938U,        1413396143U, 
            3378993243U,        3114901433U,        3110857426U,        2646558034U}, 
   {        1595043207U,        546672890U,        2431488664U,        3314760956U, 
            2974969797U,        1450156614U,        1867981642U,        4262306460U, 
            1754124291U,        3009404158U,        3489951107U,        2452060797U, 
            1686667275U,        365441439U,        1950957852U,        3787856325U, 
            2046922843U,        432180848U,        2861329569U,        3759597731U, 
            2445226080U,        1792582845U,        912412961U,        1836332639U, 
            2514539376U,        1437592904U,        3969518080U,        4084604131U, 
            152913089U,        2213987414U,        3263908827U,        4046451583U, 
            3477055242U,        4257442214U,        2210995632U,        1154521026U, 
            264221220U,        4065252374U,        1329826197U,        2064640742U, 
            960721566U,        905456762U,        2317569929U,        2160664090U, 
            3944354402U,        2542696646U,        1987804667U,        150002398U, 
            770284832U,        905650923U,        2343632287U,        1616831210U, 
            3204402333U,        266829223U,        1342890346U,        282282027U, 
            2826012651U,        2235574268U,        2081415307U,        878739151U, 
            3491974284U,        4141301038U,        155735947U,        1957494440U}, 
   {        340085622U,        2311701755U,        1128523826U,        3992702383U, 
            3601753713U,        833760637U,        3684516190U,        3503416571U, 
            1942183302U,        694768210U,        2582544178U,        590343776U, 
            726655037U,        1506353960U,        1136100186U,        183628626U, 
            1124932939U,        1604204057U,        1238416711U,        2748768905U, 
            2472949437U,        1335994457U,        2048209279U,        2482748956U, 
            535060078U,        1160170718U,        128587264U,        1063102064U, 
            3227215154U,        2599906290U,        983200761U,        331182696U, 
            1809376127U,        4220921630U,        2499890016U,        4106728899U, 
            30555574U,        188680837U,        1271613059U,        1501484672U, 
            1405074262U,        3017265222U,        4105260682U,        3054166648U, 
            1294595502U,        646619636U,        3800783562U,        692592218U, 
            198352097U,        3299725457U,        569446657U,        2937596820U, 
            2026495308U,        207209926U,        4102351541U,        983981387U, 
            947713448U,        2112809961U,        2458279900U,        2204435010U, 
            2213854132U,        1204542667U,        464962283U,        3655011731U}, 
   {        132506498U,        2912374427U,        4043897210U,        3163708236U, 
            1140600074U,        757929716U,        4237177792U,        1569739011U, 
            151006806U,        875510694U,        3308224593U,        3167203261U, 
            4098608270U,        2633153123U,        720775495U,        1832035554U, 
            2546682750U,        2125687145U,        1817844719U,        2447223727U, 
            3516872913U,        672564310U,        418758647U,        3645022720U, 
            3612001808U,        2693052951U,        1644808072U,        1898545462U, 
            776441520U,        3338609905U,        2142315824U,        2958937821U, 
            1674502840U,        2552810663U,        1948677957U,        3459370507U, 
            2136876058U,        2648082391U,        4103749633U,        544854638U, 
            2007497131U,        4028168422U,        1731373016U,        84928307U, 
            1352610892U,        3722095220U,        3185673430U,        3390672601U, 
            234960208U,        4138432149U,        2175484036U,        505396755U, 
            1952717935U,        2754440297U,        2052696030U,        2550019041U, 
            581288167U,        769308470U,        300418166U,        3944315920U, 
            4012727821U,        2819284865U,        28747053U,        1063315528U}, 
   {        93452958U,        3628911920U,        2944812531U,        2834383128U, 
            4014878389U,        494844504U,        2986103147U,        848205010U, 
            2565873634U,        2738597411U,        4227823842U,        832554912U, 
            3036261693U,        2201309018U,        2184062901U,        1850576831U, 
            234708039U,        3980469791U,        2112914263U,        2773283088U, 
            3212444531U,        982093863U,        1738288669U,        2419045841U, 
            2473678314U,        202475357U,        2596598749U,        3237788882U, 
            2736244580U,        2103510722U,        1217600895U,        2369301781U, 
            509537009U,        2040357990U,        302648696U,        2740514599U, 
            2197940231U,        1095053426U,        1037949006U,        1742382519U, 
            3296927508U,        3036626636U,        1425793503U,        4102489355U, 
            3795828939U,        1302426770U,        3793553229U,        2029328820U, 
            1935941228U,        1192728542U,        194967673U,        3409240899U, 
            154928027U,        53248172U,        2373035240U,        1089362703U, 
            4225536733U,        738435773U,        1312860940U,        28052570U, 
            987678429U,        1158302760U,        4064703069U,        2043515371U}, 
   {        1923931163U,        4060172084U,        4201118582U,        1812550115U, 
            3360651110U,        200799207U,        1347814287U,        2977381055U, 
            1086497757U,        3155811608U,        768911084U,        1109290866U, 
            3756096731U,        4262160905U,        1067500522U,        375502497U, 
            1090447204U,        2226285081U,        4166571848U,        3421638495U, 
            3090649791U,        2211340612U,        1528571873U,        3134477625U, 
            4229382787U,        3638826267U,        2622600611U,        2764814215U, 
            2191037108U,        2967189845U,        2929456976U,        3589053925U, 
            3124908048U,        1564483333U,        3248913943U,        4283941810U, 
            3539598577U,        4203923843U,        4109151235U,        32742799U, 
            2240031687U,        2599562239U,        2722153770U,        3375331461U, 
            3468779025U,        2635266028U,        2458984998U,        1647121132U, 
            4048955269U,        1302640791U,        951679692U,        3622241897U, 
            1395700864U,        2182988930U,        1147373544U,        654310992U, 
            4105234554U,        733512572U,        1748618986U,        3930345190U, 
            1446375662U,        1439314464U,        3743903199U,        3146833941U}};
#line 4 "/home/wheatley/newnew/temp/phalanx-22+d051004/killers.c"
killentry RK[99][99]  ;
#line 6 "/home/wheatley/newnew/temp/phalanx-22+d051004/killers.c"
unsigned int HK[99][99]  ;
#line 7 "/home/wheatley/newnew/temp/phalanx-22+d051004/killers.c"
unsigned int Maxhist  =    1U;
#line 10 "/home/wheatley/newnew/temp/phalanx-22+d051004/killers.c"
void init_killers(void) 
{ 


  {
  {
#line 12
  memset((void *)(RK), 0, 9801UL * sizeof(killentry ));
#line 13
  memset((void *)(HK), 0, 9801UL * sizeof(unsigned int ));
#line 14
  Maxhist = 1U;
  }
#line 15
  return;
}
}
#line 19 "/home/wheatley/newnew/temp/phalanx-22+d051004/killers.c"
void write_killer(int from , int to ) 
{ 
  int f ;
  int t ;

  {
#line 22
  if ((int )B[to] == 0) {
#line 24
    RK[G[Counter - 1].m.from][G[Counter - 1].m.to].f = (unsigned int )from;
#line 25
    RK[G[Counter - 1].m.from][G[Counter - 1].m.to].t = (unsigned int )to;
#line 27
    HK[from][to] += (unsigned int )(Depth / 10 + 1);
#line 28
    if (HK[from][to] > Maxhist) {
#line 30
      Maxhist = HK[from][to];
#line 31
      if (Maxhist > 16000U) {
#line 34
        Maxhist /= 2U;
#line 35
        f = 21;
        {
#line 35
        while (1) {
          while_continue: /* CIL Label */ ;
#line 35
          if (! (f != 99)) {
#line 35
            goto while_break;
          }
#line 36
          t = 21;
          {
#line 36
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 36
            if (! (t != 99)) {
#line 36
              goto while_break___0;
            }
#line 37
            HK[f][t] /= 2U;
#line 36
            t ++;
          }
          while_break___0: /* CIL Label */ ;
          }
#line 35
          f ++;
        }
        while_break: /* CIL Label */ ;
        }
      }
    }
  }
#line 42
  return;
}
}
#line 46 "/home/wheatley/newnew/temp/phalanx-22+d051004/killers.c"
void add_killer(tmove *m___1 , int n___1 , thashentry *ht ) 
{ 
  int i ;
  int f ;
  int t ;
  tmove *mpv ;
  tmove *mlv ;
  register tmove *m1 ;
  unsigned int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 49
  f = 0;
#line 49
  t = 0;
#line 50
  mpv = & PV[0][Ply];
#line 51
  mlv = & PV[Ply][Ply];
#line 53
  if (Depth > 0) {
#line 55
    f = (int )RK[G[Counter - 1].m.from][G[Counter - 1].m.to].f;
#line 56
    t = (int )RK[G[Counter - 1].m.from][G[Counter - 1].m.to].t;
  }
#line 59
  i = 0;
  {
#line 59
  while (1) {
    while_continue: /* CIL Label */ ;
#line 59
    if (! (i != n___1)) {
#line 59
      goto while_break;
    }
#line 61
    m1 = m___1 + i;
#line 63
    if (FollowPV) {
#line 65
      if ((int )m1->from == (int )mpv->from) {
#line 65
        if ((int )m1->to == (int )mpv->to) {
#line 65
          if ((int )m1->in2a == (int )mpv->in2a) {
#line 67
            m1->value = (short)30000;
          }
        }
      }
    } else {
#line 71
      if ((int )m1->from == (int )mlv->from) {
#line 71
        if ((int )m1->to == (int )mlv->to) {
#line 71
          if ((int )m1->in2a == (int )mlv->in2a) {
#line 73
            m1->value = (short )((int )m1->value + 350);
          }
        }
      }
#line 75
      if ((unsigned long )ht != (unsigned long )((void *)0)) {
#line 75
        if ((int )ht->move != 0) {
          {
#line 76
          tmp = smove(m1);
          }
#line 76
          if ((unsigned int )ht->move == tmp) {
#line 76
            m1->value = (short)30000;
          }
        }
      }
    }
#line 79
    if ((int )m1->value != 30000) {
#line 81
      if (m1->in2) {
#line 83
        m1->value = (short )((int )m1->value + Values[(int )m1->in2 >> 4]);
#line 84
        if (Color == 1) {
#line 85
          if ((int )P[m1->to] & 65280) {
#line 86
            m1->value = (short )((int )m1->value - (Values[(int )m1->in1 >> 4] >> 2));
          } else {
#line 87
            m1->value = (short )((int )m1->value + 100);
          }
        } else
#line 89
        if ((int )P[m1->to] & 255) {
#line 90
          m1->value = (short )((int )m1->value - (Values[(int )m1->in1 >> 4] >> 2));
        } else {
#line 91
          m1->value = (short )((int )m1->value + 100);
        }
#line 92
        if ((int )m1->value < 30) {
#line 92
          m1->value = (short)30;
        }
      }
#line 96
      if (Color == 1) {
#line 97
        if ((int )P[m1->from] & 65280) {
#line 97
          m1->value = (short )((int )m1->value + 50);
        }
      } else
#line 99
      if ((int )P[m1->from] & 255) {
#line 99
        m1->value = (short )((int )m1->value + 50);
      }
#line 101
      if ((int )m___1->in1 != (int )m___1->in2) {
#line 102
        m___1->value = (short )((int )m___1->value + (Values[(int )m___1->in2 >> 4] - Values[(int )m___1->in1 >> 4]));
      }
#line 104
      if (Depth > 200) {
        {
#line 104
        tmp___0 = see(B, (int )m1->from, (int )m1->to);
#line 104
        m1->value = (short )((int )m1->value + tmp___0);
        }
      } else
#line 106
      if ((int )m1->to == (int )G[Counter - 1].m.to) {
#line 106
        m1->value = (short )((int )m1->value + 150);
      }
#line 108
      if (Depth > 0) {
#line 110
        if ((int )m1->from == f) {
#line 110
          if ((int )m1->to == t) {
#line 111
            if (Depth > 50) {
#line 111
              tmp___1 = Depth;
            } else {
#line 111
              tmp___1 = 50;
            }
#line 111
            m1->value = (short )((int )m1->value + tmp___1);
          }
        }
#line 112
        if (HK[m1->from][m1->to]) {
#line 113
          m1->value = (short )((unsigned int )m1->value + (1U + (HK[m1->from][m1->to] * 500U) / Maxhist));
        }
      }
    }
#line 59
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 120
  return;
}
}
