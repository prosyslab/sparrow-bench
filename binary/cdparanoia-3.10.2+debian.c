/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 195 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef short int16_t;
#line 196 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef int int32_t;
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigset.h"
struct __anonstruct___sigset_t_9 {
   unsigned long __val[1024UL / (8UL * sizeof(unsigned long ))] ;
};
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigset.h"
typedef struct __anonstruct___sigset_t_9 __sigset_t;
#line 37 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef __sigset_t sigset_t;
#line 26 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/paranoia/../interface/cdda_interface.h"
struct TOC {
   unsigned char bFlags ;
   unsigned char bTrack ;
   int32_t dwStartSector ;
};
#line 26 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/paranoia/../interface/cdda_interface.h"
typedef struct TOC TOC;
#line 45
struct cdda_private_data;
#line 45 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/paranoia/../interface/cdda_interface.h"
typedef struct cdda_private_data cdda_private_data_t;
#line 47 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/paranoia/../interface/cdda_interface.h"
struct cdrom_drive {
   int opened ;
   char *cdda_device_name ;
   char *ioctl_device_name ;
   int cdda_fd ;
   int ioctl_fd ;
   char *drive_model ;
   int drive_type ;
   int interface ;
   int bigendianp ;
   int nsectors ;
   int cd_extra ;
   int tracks ;
   TOC disc_toc[100] ;
   long audio_first_sector ;
   long audio_last_sector ;
   int errordest ;
   int messagedest ;
   char *errorbuf ;
   char *messagebuf ;
   int (*enable_cdda)(struct cdrom_drive *d , int onoff ) ;
   int (*read_toc)(struct cdrom_drive *d ) ;
   long (*read_audio)(struct cdrom_drive *d , void *p , long begin , long sectors ) ;
   int (*set_speed)(struct cdrom_drive *d , int speed ) ;
   int error_retry ;
   int report_all ;
   int is_atapi ;
   int is_mmc ;
   cdda_private_data_t *private_data ;
   void *reserved ;
   unsigned char inqbytes[4] ;
   unsigned char density ;
   unsigned char orgdens ;
   unsigned int orgsize ;
   long bigbuff ;
   int adjust_ssize ;
   int fua ;
   int lun ;
   sigset_t sigset ;
};
#line 47 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/paranoia/../interface/cdda_interface.h"
typedef struct cdrom_drive cdrom_drive;
#line 9 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/paranoia/isort.h"
struct sort_link {
   struct sort_link *next ;
};
#line 9 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/paranoia/isort.h"
typedef struct sort_link sort_link;
#line 13 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/paranoia/isort.h"
struct sort_info {
   int16_t *vector ;
   long *abspos ;
   long size ;
   long maxsize ;
   long sortbegin ;
   long lo ;
   long hi ;
   int val ;
   sort_link **head ;
   long *bucketusage ;
   long lastbucket ;
   sort_link *revindex ;
};
#line 13 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/paranoia/isort.h"
typedef struct sort_info sort_info;
#line 26 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/paranoia/p_block.h"
struct linked_element;
#line 26 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/paranoia/p_block.h"
struct linked_list {
   struct linked_element *head ;
   struct linked_element *tail ;
   void *(*new_poly)() ;
   void (*free_poly)(void *poly ) ;
   long current ;
   long active ;
};
#line 26 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/paranoia/p_block.h"
typedef struct linked_list linked_list;
#line 38 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/paranoia/p_block.h"
struct linked_element {
   void *ptr ;
   struct linked_element *prev ;
   struct linked_element *next ;
   struct linked_list *list ;
   int stamp ;
};
#line 38 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/paranoia/p_block.h"
typedef struct linked_element linked_element;
#line 56
struct cdrom_paranoia;
#line 56 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/paranoia/p_block.h"
struct c_block {
   int16_t *vector ;
   long begin ;
   long size ;
   unsigned char *flags ;
   long lastsector ;
   struct cdrom_paranoia *p ;
   struct linked_element *e ;
};
#line 56 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/paranoia/p_block.h"
typedef struct c_block c_block;
#line 84 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/paranoia/p_block.h"
struct v_fragment {
   c_block *one ;
   long begin ;
   long size ;
   int16_t *vector ;
   long lastsector ;
   struct cdrom_paranoia *p ;
   struct linked_element *e ;
};
#line 84 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/paranoia/p_block.h"
typedef struct v_fragment v_fragment;
#line 115 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/paranoia/p_block.h"
struct root_block {
   long returnedlimit ;
   long lastsector ;
   struct cdrom_paranoia *p ;
   c_block *vector ;
   int silenceflag ;
   long silencebegin ;
};
#line 115 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/paranoia/p_block.h"
typedef struct root_block root_block;
#line 125 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/paranoia/p_block.h"
struct offsets {
   long offpoints ;
   long newpoints ;
   long offaccum ;
   long offdiff ;
   long offmin ;
   long offmax ;
};
#line 136 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/paranoia/p_block.h"
struct cdrom_paranoia {
   cdrom_drive *d ;
   root_block root ;
   linked_list *cache ;
   long cache_limit ;
   linked_list *fragments ;
   sort_info *sortcache ;
   int cdcache_size ;
   int cdcache_begin ;
   int cdcache_end ;
   int jitter ;
   int enable ;
   long cursor ;
   long current_lastsector ;
   long current_firstsector ;
   struct offsets stage1 ;
   struct offsets stage2 ;
   long dynoverlap ;
   long dyndrift ;
};
#line 136 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/paranoia/p_block.h"
typedef struct cdrom_paranoia cdrom_paranoia;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 147 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __clockid_t;
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 102 "/usr/include/stdio.h"
typedef __ssize_t ssize_t;
#line 91 "/usr/include/time.h"
typedef __clockid_t clockid_t;
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 222 "/usr/include/scsi/sg.h"
struct sg_header {
   int pack_len ;
   int reply_len ;
   int pack_id ;
   int result ;
   unsigned int twelve_byte : 1 ;
   unsigned int target_status : 5 ;
   unsigned int host_status : 8 ;
   unsigned int driver_status : 8 ;
   unsigned int other_flags : 10 ;
   unsigned char sense_buffer[16] ;
};
#line 20 "/usr/include/asm-generic/int-ll64.h"
typedef unsigned char __u8;
#line 154 "/usr/include/linux/cdrom.h"
struct cdrom_msf0 {
   __u8 minute ;
   __u8 second ;
   __u8 frame ;
};
#line 162 "/usr/include/linux/cdrom.h"
union cdrom_addr {
   struct cdrom_msf0 msf ;
   int lba ;
};
#line 189 "/usr/include/linux/cdrom.h"
struct cdrom_tochdr {
   __u8 cdth_trk0 ;
   __u8 cdth_trk1 ;
};
#line 219 "/usr/include/linux/cdrom.h"
struct cdrom_tocentry {
   __u8 cdte_track ;
   __u8 cdte_adr : 4 ;
   __u8 cdte_ctrl : 4 ;
   __u8 cdte_format ;
   union cdrom_addr cdte_addr ;
   __u8 cdte_datamode ;
};
#line 238 "/usr/include/linux/cdrom.h"
struct cdrom_read_audio {
   union cdrom_addr addr ;
   __u8 addr_format ;
   int nframes ;
   __u8 *buf ;
};
#line 114 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/low_interface.h"
struct cdda_private_data {
   struct sg_header *sg_hd ;
   unsigned char *sg_buffer ;
   clockid_t clock ;
   int last_milliseconds ;
};
#line 10 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/drive_exceptions.h"
struct exception {
   char *model ;
   int atapi ;
   unsigned char density ;
   int (*enable)(struct cdrom_drive * , int  ) ;
   long (*read)(struct cdrom_drive * , void * , long  , long  ) ;
   int bigendianp ;
};
#line 10 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/drive_exceptions.h"
typedef struct exception exception;
#line 124 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 126 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 127 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 130 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 140 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __useconds_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 158 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 44 "/usr/include/scsi/sg.h"
struct sg_io_hdr {
   int interface_id ;
   int dxfer_direction ;
   unsigned char cmd_len ;
   unsigned char mx_sb_len ;
   unsigned short iovec_count ;
   unsigned int dxfer_len ;
   void *dxferp ;
   unsigned char *cmdp ;
   unsigned char *sbp ;
   unsigned int timeout ;
   unsigned int flags ;
   int pack_id ;
   void *usr_ptr ;
   unsigned char status ;
   unsigned char masked_status ;
   unsigned char msg_status ;
   unsigned char sb_len_wr ;
   unsigned short host_status ;
   unsigned short driver_status ;
   int resid ;
   unsigned int duration ;
   unsigned int info ;
};
#line 354 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/scan_devices.c"
struct sg_id {
   long l1 ;
   long l2 ;
};
#line 359 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/scan_devices.c"
struct scsiid {
   int bus ;
   int id ;
   int lun ;
};
#line 359 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/scan_devices.c"
typedef struct scsiid scsiid;
#line 201 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef unsigned short u_int16_t;
#line 196 "/usr/include/linux/cdrom.h"
struct cdrom_volctrl {
   __u8 channel0 ;
   __u8 channel1 ;
   __u8 channel2 ;
   __u8 channel3 ;
};
#line 247 "/usr/include/linux/cdrom.h"
struct cdrom_multisession {
   union cdrom_addr addr ;
   __u8 xa_flag ;
   __u8 addr_format ;
};
#line 385 "/usr/include/linux/hdreg.h"
struct hd_driveid {
   unsigned short config ;
   unsigned short cyls ;
   unsigned short reserved2 ;
   unsigned short heads ;
   unsigned short track_bytes ;
   unsigned short sector_bytes ;
   unsigned short sectors ;
   unsigned short vendor0 ;
   unsigned short vendor1 ;
   unsigned short vendor2 ;
   unsigned char serial_no[20] ;
   unsigned short buf_type ;
   unsigned short buf_size ;
   unsigned short ecc_bytes ;
   unsigned char fw_rev[8] ;
   unsigned char model[40] ;
   unsigned char max_multsect ;
   unsigned char vendor3 ;
   unsigned short dword_io ;
   unsigned char vendor4 ;
   unsigned char capability ;
   unsigned short reserved50 ;
   unsigned char vendor5 ;
   unsigned char tPIO ;
   unsigned char vendor6 ;
   unsigned char tDMA ;
   unsigned short field_valid ;
   unsigned short cur_cyls ;
   unsigned short cur_heads ;
   unsigned short cur_sectors ;
   unsigned short cur_capacity0 ;
   unsigned short cur_capacity1 ;
   unsigned char multsect ;
   unsigned char multsect_valid ;
   unsigned int lba_capacity ;
   unsigned short dma_1word ;
   unsigned short dma_mword ;
   unsigned short eide_pio_modes ;
   unsigned short eide_dma_min ;
   unsigned short eide_dma_time ;
   unsigned short eide_pio ;
   unsigned short eide_pio_iordy ;
   unsigned short words69_70[2] ;
   unsigned short words71_74[4] ;
   unsigned short queue_depth ;
   unsigned short words76_79[4] ;
   unsigned short major_rev_num ;
   unsigned short minor_rev_num ;
   unsigned short command_set_1 ;
   unsigned short command_set_2 ;
   unsigned short cfsse ;
   unsigned short cfs_enable_1 ;
   unsigned short cfs_enable_2 ;
   unsigned short csf_default ;
   unsigned short dma_ultra ;
   unsigned short trseuc ;
   unsigned short trsEuc ;
   unsigned short CurAPMvalues ;
   unsigned short mprc ;
   unsigned short hw_config ;
   unsigned short acoustic ;
   unsigned short msrqs ;
   unsigned short sxfert ;
   unsigned short sal ;
   unsigned int spg ;
   unsigned long long lba_capacity_2 ;
   unsigned short words104_125[22] ;
   unsigned short last_lun ;
   unsigned short word127 ;
   unsigned short dlf ;
   unsigned short csfo ;
   unsigned short words130_155[26] ;
   unsigned short word156 ;
   unsigned short words157_159[3] ;
   unsigned short cfa_power ;
   unsigned short words161_175[15] ;
   unsigned short words176_205[30] ;
   unsigned short words206_254[49] ;
   unsigned short integrity_word ;
};
#line 141 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds_t;
#line 202 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef unsigned int u_int32_t;
#line 30 "/usr/include/x86_64-linux-gnu/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 54 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef long __fd_mask;
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
struct __anonstruct_fd_set_14 {
   __fd_mask __fds_bits[1024 / (8 * (int )sizeof(__fd_mask ))] ;
};
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef struct __anonstruct_fd_set_14 fd_set;
#line 766 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
struct scsi_TOC {
   unsigned char reserved1 ;
   unsigned char bFlags ;
   unsigned char bTrack ;
   unsigned char reserved2 ;
   signed char start_MSB ;
   unsigned char start_1 ;
   unsigned char start_2 ;
   unsigned char start_LSB ;
};
#line 766 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
typedef struct scsi_TOC scsi_TOC;
#line 125 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/paranoia/p_block.h"
typedef struct offsets offsets;
#line 126 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/paranoia/paranoia.c"
enum __anonenum_paranoia_read_flags_54 {
    FLAGS_EDGE = 1,
    FLAGS_UNREAD = 2,
    FLAGS_VERIFIED = 4
} ;
#line 757 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/paranoia/paranoia.c"
struct sync_result {
   long offset ;
   long begin ;
   long end ;
};
#line 757 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/paranoia/paranoia.c"
typedef struct sync_result sync_result;
#line 38 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/paranoia/cdda_paranoia.h"
typedef void cdrom_paranoia___0;
#line 104 "/usr/include/getopt.h"
struct option {
   char const   *name ;
   int has_arg ;
   int *flag ;
   int val ;
};
#line 55 "/usr/include/x86_64-linux-gnu/sys/time.h"
struct timezone {
   int tz_minuteswest ;
   int tz_dsttime ;
};
#line 61 "/usr/include/x86_64-linux-gnu/sys/time.h"
typedef struct timezone * __restrict  __timezone_ptr_t;
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 468
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) calloc)(size_t __nmemb ,
                                                                               size_t __size )  __attribute__((__malloc__)) ;
#line 480
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 50
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memmove)(void *__dest ,
                                                                                                  void const   *__src ,
                                                                                                  size_t __n ) ;
#line 137 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/paranoia/../interface/cdda_interface.h"
long cdda_track_firstsector(cdrom_drive *d___0 , int track ) ;
#line 138
long cdda_track_lastsector(cdrom_drive *d___0 , int track ) ;
#line 139
long cdda_tracks(cdrom_drive *d___0 ) ;
#line 140
int cdda_sector_gettrack(cdrom_drive *d___0 , long sector ) ;
#line 142
int cdda_track_audiop(cdrom_drive *d___0 , int track ) ;
#line 145
long cdda_disc_firstsector(cdrom_drive *d___0 ) ;
#line 146
long cdda_disc_lastsector(cdrom_drive *d___0 ) ;
#line 40 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/paranoia/isort.h"
sort_info *sort_alloc(long size ) ;
#line 47 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/paranoia/p_block.h"
linked_list *new_list(void *(*newp)(void) , void (*freep)(void * ) ) ;
#line 48
linked_element *new_elem(linked_list *list ) ;
#line 49
linked_element *add_elem(linked_list *l , void *elem ) ;
#line 50
void free_list(linked_list *list , int free_ptr ) ;
#line 51
void free_elem(linked_element *e , int free_ptr ) ;
#line 52
void *get_elem(linked_element *e ) ;
#line 53
linked_list *copy_list(linked_list *list ) ;
#line 80
void free_c_block(c_block *c ) ;
#line 81
void i_cblock_destructor(c_block *c ) ;
#line 82
c_block *new_c_block(struct cdrom_paranoia *p___0 ) ;
#line 100
void free_v_fragment(v_fragment *v ) ;
#line 101
v_fragment *new_v_fragment(struct cdrom_paranoia *p___0 , c_block *one , long begin ,
                           long end , int last___0 ) ;
#line 103
int16_t *v_buffer(v_fragment *v ) ;
#line 105
c_block *c_first(struct cdrom_paranoia *p___0 ) ;
#line 106
c_block *c_last(struct cdrom_paranoia *p___0 ) ;
#line 107
c_block *c_next(c_block *c ) ;
#line 108
c_block *c_prev(c_block *c ) ;
#line 110
v_fragment *v_first(struct cdrom_paranoia *p___0 ) ;
#line 111
v_fragment *v_last(struct cdrom_paranoia *p___0 ) ;
#line 112
v_fragment *v_next(v_fragment *v ) ;
#line 113
v_fragment *v_prev(v_fragment *v ) ;
#line 167
c_block *c_alloc(int16_t *vector , long begin , long size ) ;
#line 168
void c_set(c_block *v , long begin ) ;
#line 169
void c_insert(c_block *v , long pos , int16_t *b , long size ) ;
#line 170
void c_remove(c_block *v , long cutpos , long cutsize ) ;
#line 171
void c_overwrite(c_block *v , long pos , int16_t *b , long size ) ;
#line 172
void c_append(c_block *v , int16_t *vector , long size ) ;
#line 173
void c_removef(c_block *v , long cut ) ;
#line 181
void recover_cache(cdrom_paranoia *p___0 ) ;
#line 182
void i_paranoia_firstlast(cdrom_paranoia *p___0 ) ;
#line 44 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/paranoia/cdda_paranoia.h"
cdrom_paranoia *paranoia_init(cdrom_drive *d___0 ) ;
#line 51
int paranoia_cachemodel_size(cdrom_paranoia *p___0 , int sectors ) ;
#line 9 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/paranoia/p_block.c"
linked_list *new_list(void *(*newp)(void) , void (*freep)(void * ) ) 
{ 
  linked_list *ret ;
  void *tmp ;

  {
  {
#line 10
  tmp = calloc((size_t )1, sizeof(linked_list ));
#line 10
  ret = (linked_list *)tmp;
#line 11
  ret->new_poly = newp;
#line 12
  ret->free_poly = freep;
  }
#line 13
  return (ret);
}
}
#line 16 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/paranoia/p_block.c"
linked_element *add_elem(linked_list *l , void *elem ) 
{ 
  linked_element *ret ;
  void *tmp ;
  long tmp___0 ;

  {
  {
#line 18
  tmp = calloc((size_t )1, sizeof(linked_element ));
#line 18
  ret = (linked_element *)tmp;
#line 19
  tmp___0 = l->current;
#line 19
  (l->current) ++;
#line 19
  ret->stamp = (int )tmp___0;
#line 20
  ret->ptr = elem;
#line 21
  ret->list = l;
  }
#line 23
  if (l->head) {
#line 24
    (l->head)->prev = ret;
  } else {
#line 26
    l->tail = ret;
  }
#line 27
  ret->next = l->head;
#line 28
  ret->prev = (struct linked_element *)((void *)0);
#line 29
  l->head = ret;
#line 30
  (l->active) ++;
#line 32
  return (ret);
}
}
#line 35 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/paranoia/p_block.c"
linked_element *new_elem(linked_list *list ) 
{ 
  void *new ;
  void *tmp ;
  linked_element *tmp___0 ;

  {
  {
#line 36
  tmp = (*(list->new_poly))();
#line 36
  new = tmp;
#line 37
  tmp___0 = add_elem(list, new);
  }
#line 37
  return (tmp___0);
}
}
#line 40 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/paranoia/p_block.c"
void free_elem(linked_element *e , int free_ptr ) 
{ 
  linked_list *l ;

  {
#line 41
  l = e->list;
#line 42
  if (free_ptr) {
    {
#line 42
    (*(l->free_poly))(e->ptr);
    }
  }
#line 44
  if ((unsigned long )e == (unsigned long )l->head) {
#line 45
    l->head = e->next;
  }
#line 46
  if ((unsigned long )e == (unsigned long )l->tail) {
#line 47
    l->tail = e->prev;
  }
#line 49
  if (e->prev) {
#line 50
    (e->prev)->next = e->next;
  }
#line 51
  if (e->next) {
#line 52
    (e->next)->prev = e->prev;
  }
  {
#line 54
  (l->active) --;
#line 55
  free((void *)e);
  }
#line 56
  return;
}
}
#line 58 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/paranoia/p_block.c"
void free_list(linked_list *list , int free_ptr ) 
{ 


  {
  {
#line 59
  while (1) {
    while_continue: /* CIL Label */ ;
#line 59
    if (! list->head) {
#line 59
      goto while_break;
    }
    {
#line 60
    free_elem(list->head, free_ptr);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 61
  free((void *)list);
  }
#line 62
  return;
}
}
#line 64 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/paranoia/p_block.c"
void *get_elem(linked_element *e ) 
{ 


  {
#line 65
  return (e->ptr);
}
}
#line 68 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/paranoia/p_block.c"
linked_list *copy_list(linked_list *list ) 
{ 
  linked_list *new ;
  linked_list *tmp ;
  linked_element *i ;

  {
  {
#line 69
  tmp = new_list(list->new_poly, list->free_poly);
#line 69
  new = tmp;
#line 70
  i = list->tail;
  }
  {
#line 72
  while (1) {
    while_continue: /* CIL Label */ ;
#line 72
    if (! i) {
#line 72
      goto while_break;
    }
    {
#line 73
    add_elem(new, i->ptr);
#line 74
    i = i->prev;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 76
  return (new);
}
}
#line 81 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/paranoia/p_block.c"
static c_block *i_cblock_constructor(cdrom_paranoia *p___0 ) 
{ 
  c_block *ret ;
  void *tmp ;

  {
  {
#line 82
  tmp = calloc((size_t )1, sizeof(c_block ));
#line 82
  ret = (c_block *)tmp;
  }
#line 83
  return (ret);
}
}
#line 86 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/paranoia/p_block.c"
void i_cblock_destructor(c_block *c ) 
{ 


  {
#line 87
  if (c) {
#line 88
    if (c->vector) {
      {
#line 88
      free((void *)c->vector);
      }
    }
#line 89
    if (c->flags) {
      {
#line 89
      free((void *)c->flags);
      }
    }
    {
#line 90
    c->e = (struct linked_element *)((void *)0);
#line 91
    free((void *)c);
    }
  }
#line 93
  return;
}
}
#line 95 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/paranoia/p_block.c"
c_block *new_c_block(struct cdrom_paranoia *p___0 ) 
{ 
  linked_element *e ;
  linked_element *tmp ;
  c_block *c ;

  {
  {
#line 96
  tmp = new_elem(p___0->cache);
#line 96
  e = tmp;
#line 97
  c = (c_block *)e->ptr;
#line 98
  c->e = e;
#line 99
  c->p = p___0;
  }
#line 100
  return (c);
}
}
#line 103 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/paranoia/p_block.c"
void free_c_block(c_block *c ) 
{ 
  v_fragment *v ;
  v_fragment *tmp ;
  v_fragment *next ;
  v_fragment *tmp___0 ;

  {
  {
#line 105
  tmp = v_first(c->p);
#line 105
  v = tmp;
  }
  {
#line 107
  while (1) {
    while_continue: /* CIL Label */ ;
#line 107
    if (! v) {
#line 107
      goto while_break;
    }
    {
#line 108
    tmp___0 = v_next(v);
#line 108
    next = tmp___0;
    }
#line 109
    if ((unsigned long )v->one == (unsigned long )c) {
      {
#line 109
      free_v_fragment(v);
      }
    }
#line 110
    v = next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 113
  free_elem(c->e, 1);
  }
#line 114
  return;
}
}
#line 116 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/paranoia/p_block.c"
static v_fragment *i_vfragment_constructor(void) 
{ 
  v_fragment *ret ;
  void *tmp ;

  {
  {
#line 117
  tmp = calloc((size_t )1, sizeof(v_fragment ));
#line 117
  ret = (v_fragment *)tmp;
  }
#line 118
  return (ret);
}
}
#line 121 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/paranoia/p_block.c"
static void i_v_fragment_destructor(v_fragment *v ) 
{ 


  {
  {
#line 122
  free((void *)v);
  }
#line 123
  return;
}
}
#line 125 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/paranoia/p_block.c"
v_fragment *new_v_fragment(struct cdrom_paranoia *p___0 , c_block *one , long begin ,
                           long end , int last___0 ) 
{ 
  linked_element *e ;
  linked_element *tmp ;
  v_fragment *b ;

  {
  {
#line 127
  tmp = new_elem(p___0->fragments);
#line 127
  e = tmp;
#line 128
  b = (v_fragment *)e->ptr;
#line 130
  b->e = e;
#line 131
  b->p = p___0;
#line 133
  b->one = one;
#line 134
  b->begin = begin;
#line 135
  b->vector = (one->vector + begin) - one->begin;
#line 136
  b->size = end - begin;
#line 137
  b->lastsector = (long )last___0;
  }
#line 139
  return (b);
}
}
#line 142 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/paranoia/p_block.c"
void free_v_fragment(v_fragment *v ) 
{ 


  {
  {
#line 143
  free_elem(v->e, 1);
  }
#line 144
  return;
}
}
#line 146 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/paranoia/p_block.c"
c_block *c_first(struct cdrom_paranoia *p___0 ) 
{ 


  {
#line 147
  if ((p___0->cache)->head) {
#line 148
    return ((c_block *)((p___0->cache)->head)->ptr);
  }
#line 149
  return ((c_block *)((void *)0));
}
}
#line 152 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/paranoia/p_block.c"
c_block *c_last(struct cdrom_paranoia *p___0 ) 
{ 


  {
#line 153
  if ((p___0->cache)->tail) {
#line 154
    return ((c_block *)((p___0->cache)->tail)->ptr);
  }
#line 155
  return ((c_block *)((void *)0));
}
}
#line 158 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/paranoia/p_block.c"
c_block *c_next(c_block *c ) 
{ 


  {
#line 159
  if ((c->e)->next) {
#line 160
    return ((c_block *)((c->e)->next)->ptr);
  }
#line 161
  return ((c_block *)((void *)0));
}
}
#line 164 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/paranoia/p_block.c"
c_block *c_prev(c_block *c ) 
{ 


  {
#line 165
  if ((c->e)->prev) {
#line 166
    return ((c_block *)((c->e)->prev)->ptr);
  }
#line 167
  return ((c_block *)((void *)0));
}
}
#line 170 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/paranoia/p_block.c"
v_fragment *v_first(struct cdrom_paranoia *p___0 ) 
{ 


  {
#line 171
  if ((p___0->fragments)->head) {
#line 172
    return ((v_fragment *)((p___0->fragments)->head)->ptr);
  }
#line 174
  return ((v_fragment *)((void *)0));
}
}
#line 177 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/paranoia/p_block.c"
v_fragment *v_last(struct cdrom_paranoia *p___0 ) 
{ 


  {
#line 178
  if ((p___0->fragments)->tail) {
#line 179
    return ((v_fragment *)((p___0->fragments)->tail)->ptr);
  }
#line 180
  return ((v_fragment *)((void *)0));
}
}
#line 183 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/paranoia/p_block.c"
v_fragment *v_next(v_fragment *v ) 
{ 


  {
#line 184
  if ((v->e)->next) {
#line 185
    return ((v_fragment *)((v->e)->next)->ptr);
  }
#line 186
  return ((v_fragment *)((void *)0));
}
}
#line 189 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/paranoia/p_block.c"
v_fragment *v_prev(v_fragment *v ) 
{ 


  {
#line 190
  if ((v->e)->prev) {
#line 191
    return ((v_fragment *)((v->e)->prev)->ptr);
  }
#line 192
  return ((v_fragment *)((void *)0));
}
}
#line 195 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/paranoia/p_block.c"
void recover_cache(cdrom_paranoia *p___0 ) 
{ 
  linked_list *l ;
  c_block *tmp ;

  {
#line 196
  l = p___0->cache;
  {
#line 199
  while (1) {
    while_continue: /* CIL Label */ ;
#line 199
    if (! (l->active > p___0->cache_limit)) {
#line 199
      goto while_break;
    }
    {
#line 201
    tmp = c_last(p___0);
#line 201
    free_c_block(tmp);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 203
  return;
}
}
#line 205 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/paranoia/p_block.c"
int16_t *v_buffer(v_fragment *v ) 
{ 


  {
#line 206
  if (! v->one) {
#line 206
    return ((int16_t *)((void *)0));
  }
#line 207
  if (! (v->one)->vector) {
#line 207
    return ((int16_t *)((void *)0));
  }
#line 208
  return (v->vector);
}
}
#line 212 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/paranoia/p_block.c"
c_block *c_alloc(int16_t *vector , long begin , long size ) 
{ 
  c_block *c ;
  void *tmp ;

  {
  {
#line 213
  tmp = calloc((size_t )1, sizeof(c_block ));
#line 213
  c = (c_block *)tmp;
#line 214
  c->vector = vector;
#line 215
  c->begin = begin;
#line 216
  c->size = size;
  }
#line 217
  return (c);
}
}
#line 220 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/paranoia/p_block.c"
void c_set(c_block *v , long begin ) 
{ 


  {
#line 221
  v->begin = begin;
#line 222
  return;
}
}
#line 225 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/paranoia/p_block.c"
void c_insert(c_block *v , long pos , int16_t *b , long size ) 
{ 
  int vs ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 226
  vs = (int )v->size;
#line 227
  if (pos < 0L) {
#line 227
    return;
  } else
#line 227
  if (pos > (long )vs) {
#line 227
    return;
  }
#line 229
  if (v->vector) {
    {
#line 230
    tmp = realloc((void *)v->vector, sizeof(int16_t ) * (unsigned long )(size + (long )vs));
#line 230
    v->vector = (int16_t *)tmp;
    }
  } else {
    {
#line 232
    tmp___0 = malloc(sizeof(int16_t ) * (unsigned long )size);
#line 232
    v->vector = (int16_t *)tmp___0;
    }
  }
#line 234
  if (pos < (long )vs) {
    {
#line 234
    memmove((void *)((v->vector + pos) + size), (void const   *)(v->vector + pos),
            (unsigned long )((long )vs - pos) * sizeof(int16_t ));
    }
  }
  {
#line 236
  memcpy((void */* __restrict  */)(v->vector + pos), (void const   */* __restrict  */)b,
         (unsigned long )size * sizeof(int16_t ));
#line 238
  v->size += size;
  }
#line 239
  return;
}
}
#line 241 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/paranoia/p_block.c"
void c_remove(c_block *v , long cutpos , long cutsize ) 
{ 
  int vs ;

  {
#line 242
  vs = (int )v->size;
#line 243
  if (cutpos < 0L) {
#line 243
    return;
  } else
#line 243
  if (cutpos > (long )vs) {
#line 243
    return;
  }
#line 244
  if (cutpos + cutsize > (long )vs) {
#line 244
    cutsize = (long )vs - cutpos;
  }
#line 245
  if (cutsize < 0L) {
#line 245
    cutsize = (long )vs - cutpos;
  }
#line 246
  if (cutsize < 1L) {
#line 246
    return;
  }
  {
#line 248
  memmove((void *)(v->vector + cutpos), (void const   *)((v->vector + cutpos) + cutsize),
          (unsigned long )(((long )vs - cutpos) - cutsize) * sizeof(int16_t ));
#line 251
  v->size -= cutsize;
  }
#line 252
  return;
}
}
#line 254 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/paranoia/p_block.c"
void c_overwrite(c_block *v , long pos , int16_t *b , long size ) 
{ 
  int vs ;

  {
#line 255
  vs = (int )v->size;
#line 257
  if (pos < 0L) {
#line 257
    return;
  }
#line 258
  if (pos + size > (long )vs) {
#line 258
    size = (long )vs - pos;
  }
  {
#line 260
  memcpy((void */* __restrict  */)(v->vector + pos), (void const   */* __restrict  */)b,
         (unsigned long )size * sizeof(int16_t ));
  }
#line 261
  return;
}
}
#line 263 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/paranoia/p_block.c"
void c_append(c_block *v , int16_t *vector , long size ) 
{ 
  int vs ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 264
  vs = (int )v->size;
#line 267
  if (v->vector) {
    {
#line 268
    tmp = realloc((void *)v->vector, sizeof(int16_t ) * (unsigned long )(size + (long )vs));
#line 268
    v->vector = (int16_t *)tmp;
    }
  } else {
    {
#line 270
    tmp___0 = malloc(sizeof(int16_t ) * (unsigned long )size);
#line 270
    v->vector = (int16_t *)tmp___0;
    }
  }
  {
#line 271
  memcpy((void */* __restrict  */)(v->vector + vs), (void const   */* __restrict  */)vector,
         sizeof(int16_t ) * (unsigned long )size);
#line 273
  v->size += size;
  }
#line 274
  return;
}
}
#line 276 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/paranoia/p_block.c"
void c_removef(c_block *v , long cut ) 
{ 


  {
  {
#line 277
  c_remove(v, 0L, cut);
#line 278
  v->begin += cut;
  }
#line 279
  return;
}
}
#line 294 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/paranoia/p_block.c"
void i_paranoia_firstlast(cdrom_paranoia *p___0 ) 
{ 
  int i ;
  cdrom_drive *d___0 ;
  int tmp ;
  long tmp___0 ;
  int tmp___1 ;

  {
  {
#line 296
  d___0 = p___0->d;
#line 297
  p___0->current_lastsector = -1L;
#line 298
  i = cdda_sector_gettrack(d___0, p___0->cursor);
  }
  {
#line 298
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 298
    tmp___0 = cdda_tracks(d___0);
    }
#line 298
    if (! ((long )i < tmp___0)) {
#line 298
      goto while_break;
    }
    {
#line 299
    tmp = cdda_track_audiop(d___0, i);
    }
#line 299
    if (! tmp) {
      {
#line 300
      p___0->current_lastsector = cdda_track_lastsector(d___0, i - 1);
      }
    }
#line 298
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 301
  if (p___0->current_lastsector == -1L) {
    {
#line 302
    p___0->current_lastsector = cdda_disc_lastsector(d___0);
    }
  }
  {
#line 304
  p___0->current_firstsector = -1L;
#line 305
  i = cdda_sector_gettrack(d___0, p___0->cursor);
  }
  {
#line 305
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 305
    if (! (i > 0)) {
#line 305
      goto while_break___0;
    }
    {
#line 306
    tmp___1 = cdda_track_audiop(d___0, i);
    }
#line 306
    if (! tmp___1) {
      {
#line 307
      p___0->current_firstsector = cdda_track_firstsector(d___0, i + 1);
      }
    }
#line 305
    i --;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 308
  if (p___0->current_firstsector == -1L) {
    {
#line 309
    p___0->current_firstsector = cdda_disc_firstsector(d___0);
    }
  }
#line 311
  return;
}
}
#line 313 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/paranoia/p_block.c"
cdrom_paranoia *paranoia_init(cdrom_drive *d___0 ) 
{ 
  cdrom_paranoia *p___0 ;
  void *tmp ;

  {
  {
#line 314
  tmp = calloc((size_t )1, sizeof(cdrom_paranoia ));
#line 314
  p___0 = (cdrom_paranoia *)tmp;
#line 316
  p___0->cache = new_list((void *(*)(void))((void *)(& i_cblock_constructor)), (void (*)(void * ))((void *)(& i_cblock_destructor)));
#line 319
  p___0->fragments = new_list((void *(*)(void))((void *)(& i_vfragment_constructor)),
                              (void (*)(void * ))((void *)(& i_v_fragment_destructor)));
#line 322
  p___0->cdcache_begin = 9999999;
#line 323
  p___0->cdcache_end = 9999999;
#line 324
  p___0->cdcache_size = 1200;
#line 325
  p___0->sortcache = sort_alloc((long )(p___0->cdcache_size * 1176));
#line 326
  p___0->d = d___0;
#line 327
  p___0->dynoverlap = 37632L;
#line 328
  p___0->cache_limit = 15L;
#line 329
  p___0->enable = 255;
#line 330
  p___0->cursor = cdda_disc_firstsector(d___0);
#line 333
  i_paranoia_firstlast(p___0);
  }
#line 335
  return (p___0);
}
}
#line 339 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/paranoia/p_block.c"
int paranoia_cachemodel_size(cdrom_paranoia *p___0 , int sectors ) 
{ 
  int ret ;

  {
#line 340
  ret = p___0->cdcache_size;
#line 341
  if (sectors >= 0) {
#line 342
    p___0->cdcache_size = sectors;
  }
#line 343
  return (ret);
}
}
#line 364 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 366 "/usr/include/unistd.h"
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 137 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcat)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 147
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 342 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) clock_gettime)(clockid_t __clock_id ,
                                                                                    struct timespec *__tp ) ;
#line 41 "/usr/include/x86_64-linux-gnu/sys/ioctl.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ioctl)(int __fd ,
                                                                            unsigned long __request 
                                                                            , ...) ;
#line 132 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/low_interface.h"
int cooked_init_drive(cdrom_drive *d___0 ) ;
#line 15 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/common_interface.h"
int FixupTOC(cdrom_drive *d___0 , int tracks ) ;
#line 98 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/utils.h"
__inline static char *catstring(char *buff , char const   *s ) 
{ 
  size_t tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  size_t tmp___2 ;
  void *tmp___3 ;

  {
#line 99
  if (s) {
#line 100
    if (buff) {
      {
#line 101
      tmp = strlen((char const   *)buff);
#line 101
      tmp___0 = strlen(s);
#line 101
      tmp___1 = realloc((void *)buff, (tmp + tmp___0) + 9UL);
#line 101
      buff = (char *)tmp___1;
      }
    } else {
      {
#line 103
      tmp___2 = strlen(s);
#line 103
      tmp___3 = calloc(tmp___2 + 9UL, (size_t )1);
#line 103
      buff = (char *)tmp___3;
      }
    }
    {
#line 104
    strcat((char */* __restrict  */)buff, (char const   */* __restrict  */)s);
    }
  }
#line 106
  return (buff);
}
}
#line 109 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/utils.h"
static void cderror(cdrom_drive *d___0 , char const   *s ) 
{ 
  size_t tmp ;

  {
#line 110
  if (s) {
#line 110
    if (d___0) {
      {
#line 112
      if (d___0->errordest == 1) {
#line 112
        goto case_1;
      }
#line 115
      if (d___0->errordest == 2) {
#line 115
        goto case_2;
      }
#line 119
      goto switch_default;
      case_1: /* CIL Label */ 
      {
#line 113
      tmp = strlen(s);
#line 113
      write(2, (void const   *)s, tmp);
      }
#line 114
      goto switch_break;
      case_2: /* CIL Label */ 
      {
#line 116
      d___0->errorbuf = catstring(d___0->errorbuf, s);
      }
#line 117
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 120
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
  }
#line 123
  return;
}
}
#line 125 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/utils.h"
static void cdmessage(cdrom_drive *d___0 , char const   *s ) 
{ 
  size_t tmp ;

  {
#line 126
  if (s) {
#line 126
    if (d___0) {
      {
#line 128
      if (d___0->messagedest == 1) {
#line 128
        goto case_1;
      }
#line 131
      if (d___0->messagedest == 2) {
#line 131
        goto case_2;
      }
#line 135
      goto switch_default;
      case_1: /* CIL Label */ 
      {
#line 129
      tmp = strlen(s);
#line 129
      write(2, (void const   *)s, tmp);
      }
#line 130
      goto switch_break;
      case_2: /* CIL Label */ 
      {
#line 132
      d___0->messagebuf = catstring(d___0->messagebuf, s);
      }
#line 133
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 136
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
  }
#line 139
  return;
}
}
#line 15 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/cooked_interface.c"
static int timed_ioctl(cdrom_drive *d___0 , int fd , int command , void *arg ) 
{ 
  struct timespec tv1 ;
  struct timespec tv2 ;
  int ret1 ;
  int tmp ;
  int ret2 ;
  int tmp___0 ;
  int ret3 ;
  int tmp___1 ;

  {
  {
#line 18
  tmp = clock_gettime((d___0->private_data)->clock, & tv1);
#line 18
  ret1 = tmp;
#line 19
  tmp___0 = ioctl(fd, (unsigned long )command, arg);
#line 19
  ret2 = tmp___0;
#line 20
  tmp___1 = clock_gettime((d___0->private_data)->clock, & tv2);
#line 20
  ret3 = tmp___1;
  }
#line 21
  if (ret1 < 0) {
#line 22
    (d___0->private_data)->last_milliseconds = -1;
  } else
#line 21
  if (ret3 < 0) {
#line 22
    (d___0->private_data)->last_milliseconds = -1;
  } else {
#line 24
    (d___0->private_data)->last_milliseconds = (int )((double )(tv2.tv_sec - tv1.tv_sec) * 1000. + (double )(tv2.tv_nsec - tv1.tv_nsec) / 1000000.);
  }
#line 26
  return (ret2);
}
}
#line 30 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/cooked_interface.c"
static int cooked_readtoc(cdrom_drive *d___0 ) 
{ 
  int i ;
  int tracks ;
  struct cdrom_tochdr hdr ;
  struct cdrom_tocentry entry ;
  int *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 37
  tmp___0 = ioctl(d___0->ioctl_fd, 21253UL, & hdr);
  }
#line 37
  if (tmp___0) {
    {
#line 38
    tmp = __errno_location();
    }
    {
#line 39
    if (*tmp == 1) {
#line 39
      goto case_1;
    }
#line 42
    goto switch_default;
    case_1: /* CIL Label */ 
    {
#line 40
    cderror(d___0, "102: Permision denied on cdrom (ioctl) device\n");
    }
#line 41
    return (-102);
    switch_default: /* CIL Label */ 
    {
#line 43
    cderror(d___0, "004: Unable to read table of contents header\n");
    }
#line 44
    return (-4);
    switch_break: /* CIL Label */ ;
    }
  }
#line 48
  i = 0;
  {
#line 48
  while (1) {
    while_continue: /* CIL Label */ ;
#line 48
    if (! (i < (int )hdr.cdth_trk1)) {
#line 48
      goto while_break;
    }
    {
#line 49
    entry.cdte_track = (__u8 )(i + 1);
#line 50
    entry.cdte_format = (__u8 )1;
#line 51
    tmp___1 = ioctl(d___0->ioctl_fd, 21254UL, & entry);
    }
#line 51
    if (tmp___1) {
      {
#line 52
      cderror(d___0, "005: Unable to read table of contents entry\n");
      }
#line 53
      return (-5);
    }
#line 56
    d___0->disc_toc[i].bFlags = (unsigned char )(((int )entry.cdte_adr << 4) | ((int )entry.cdte_ctrl & 15));
#line 57
    d___0->disc_toc[i].bTrack = (unsigned char )(i + 1);
#line 58
    d___0->disc_toc[i].dwStartSector = entry.cdte_addr.lba;
#line 48
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 61
  entry.cdte_track = (__u8 )170;
#line 62
  entry.cdte_format = (__u8 )1;
#line 63
  tmp___2 = ioctl(d___0->ioctl_fd, 21254UL, & entry);
  }
#line 63
  if (tmp___2) {
    {
#line 64
    cderror(d___0, "005: Unable to read table of contents entry\n");
    }
#line 65
    return (-5);
  }
  {
#line 67
  d___0->disc_toc[i].bFlags = (unsigned char )(((int )entry.cdte_adr << 4) | ((int )entry.cdte_ctrl & 15));
#line 68
  d___0->disc_toc[i].bTrack = entry.cdte_track;
#line 69
  d___0->disc_toc[i].dwStartSector = entry.cdte_addr.lba;
#line 71
  tracks = (int )hdr.cdth_trk1 + 1;
#line 72
  d___0->cd_extra = FixupTOC(d___0, tracks);
#line 73
  tracks --;
  }
#line 73
  return (tracks);
}
}
#line 77 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/cooked_interface.c"
static int cooked_setspeed(cdrom_drive *d___0 , int speed ) 
{ 
  int tmp ;

  {
#line 79
  if (d___0->ioctl_fd != -1) {
    {
#line 80
    tmp = ioctl(d___0->ioctl_fd, 21282UL, speed);
    }
#line 80
    return (tmp);
  } else {
#line 82
    return (0);
  }
}
}
#line 89 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/cooked_interface.c"
static long cooked_read(cdrom_drive *d___0 , void *p___0 , long begin , long sectors ) 
{ 
  int retry_count ;
  int err ;
  int ret ;
  struct cdrom_read_audio arg ;
  char *buffer ;
  void *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  char b[256] ;

  {
#line 90
  ret = 0;
#line 92
  buffer = (char *)p___0;
#line 95
  if (sectors > (long )d___0->nsectors) {
#line 95
    sectors = (long )d___0->nsectors;
  } else {
#line 95
    sectors = sectors;
  }
#line 96
  if ((unsigned long )p___0 == (unsigned long )((void *)0)) {
    {
#line 96
    tmp = malloc((size_t )(sectors * 2352L));
#line 96
    buffer = (char *)tmp;
    }
  }
#line 98
  arg.addr.lba = (int )begin;
#line 99
  arg.addr_format = (__u8 )1;
#line 100
  arg.nframes = (int )sectors;
#line 101
  arg.buf = (__u8 *)buffer;
#line 102
  retry_count = 0;
  {
#line 104
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 105
    err = timed_ioctl(d___0, d___0->ioctl_fd, 21262, (void *)(& arg));
    }
#line 105
    if (err) {
#line 106
      if (! d___0->error_retry) {
#line 107
        ret = -7;
#line 108
        goto done;
      }
      {
#line 110
      tmp___0 = __errno_location();
      }
      {
#line 111
      if (*tmp___0 == 12) {
#line 111
        goto case_12;
      }
#line 121
      if (*tmp___0 == 123) {
#line 121
        goto case_123;
      }
#line 121
      if (*tmp___0 == 9) {
#line 121
        goto case_123;
      }
#line 121
      if (*tmp___0 == 6) {
#line 121
        goto case_123;
      }
#line 125
      goto switch_default;
      case_12: /* CIL Label */ 
#line 113
      if (sectors == 1L) {
        {
#line 115
        cderror(d___0, "300: Kernel memory error\n");
#line 116
        ret = -300;
        }
#line 117
        goto done;
      }
      case_123: /* CIL Label */ 
      case_9: /* CIL Label */ 
      case_6: /* CIL Label */ 
      {
#line 122
      tmp___1 = __errno_location();
#line 122
      *tmp___1 = 123;
#line 123
      ret = 0;
      }
#line 124
      goto done;
      switch_default: /* CIL Label */ 
#line 126
      if (sectors == 1L) {
#line 132
        if (retry_count > 7) {
          {
#line 134
          sprintf((char */* __restrict  */)(b), (char const   */* __restrict  */)"010: Unable to access sector %ld: skipping...\n",
                  begin);
#line 136
          cderror(d___0, (char const   *)(b));
#line 137
          ret = -10;
          }
#line 138
          goto done;
        }
#line 140
        goto switch_break;
      }
      switch_break: /* CIL Label */ ;
      }
#line 143
      if (retry_count > 4) {
#line 144
        if (sectors > 1L) {
#line 145
          sectors = (sectors * 3L) / 4L;
        }
      }
#line 146
      retry_count ++;
#line 147
      if (retry_count > 8) {
        {
#line 148
        cderror(d___0, "007: Unknown, unrecoverable error reading data\n");
#line 149
        ret = -7;
        }
#line 150
        goto done;
      }
    } else {
#line 153
      goto while_break;
    }
#line 104
    if (! err) {
#line 104
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 156
  ret = (int )sectors;
  done: 
#line 159
  if ((unsigned long )p___0 == (unsigned long )((void *)0)) {
#line 159
    if (buffer) {
      {
#line 159
      free((void *)buffer);
      }
    }
  }
#line 160
  return ((long )ret);
}
}
#line 298 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/cooked_interface.c"
static int Dummy(cdrom_drive *d___0 , int Switch ) 
{ 


  {
#line 299
  return (0);
}
}
#line 302 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/cooked_interface.c"
static int verify_read_command(cdrom_drive *d___0 ) 
{ 
  int i ;
  int16_t *buff ;
  void *tmp ;
  int audioflag ;
  long firstsector ;
  long tmp___0 ;
  long lastsector ;
  long tmp___1 ;
  long sector ;
  long tmp___2 ;
  int tmp___3 ;

  {
  {
#line 304
  tmp = malloc((size_t )2352);
#line 304
  buff = (int16_t *)tmp;
#line 305
  audioflag = 0;
#line 307
  cdmessage(d___0, "Verifying drive can read CDDA...\n");
#line 309
  (*(d___0->enable_cdda))(d___0, 1);
#line 311
  i = 1;
  }
  {
#line 311
  while (1) {
    while_continue: /* CIL Label */ ;
#line 311
    if (! (i <= d___0->tracks)) {
#line 311
      goto while_break;
    }
    {
#line 312
    tmp___3 = cdda_track_audiop(d___0, i);
    }
#line 312
    if (tmp___3 == 1) {
      {
#line 313
      tmp___0 = cdda_track_firstsector(d___0, i);
#line 313
      firstsector = tmp___0;
#line 314
      tmp___1 = cdda_track_lastsector(d___0, i);
#line 314
      lastsector = tmp___1;
#line 315
      sector = (firstsector + lastsector) >> 1;
#line 316
      audioflag = 1;
#line 318
      tmp___2 = (*(d___0->read_audio))(d___0, (void *)buff, sector, 1L);
      }
#line 318
      if (tmp___2 > 0L) {
        {
#line 319
        cdmessage(d___0, "\tExpected command set reads OK.\n");
#line 320
        (*(d___0->enable_cdda))(d___0, 0);
#line 321
        free((void *)buff);
        }
#line 322
        return (0);
      }
    }
#line 311
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 327
  (*(d___0->enable_cdda))(d___0, 0);
  }
#line 329
  if (! audioflag) {
    {
#line 330
    cdmessage(d___0, "\tCould not find any audio tracks on this disk.\n");
    }
#line 331
    return (-403);
  }
  {
#line 334
  cdmessage(d___0, "\n\tUnable to read any data; drive probably not CDDA capable.\n");
#line 337
  cderror(d___0, "006: Could not read any data from drive\n");
#line 339
  free((void *)buff);
  }
#line 340
  return (-6);
}
}
#line 3 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/drive_exceptions.h"
long scsi_read_mmc2(cdrom_drive *d___0 , void *p___0 , long begin , long sectors ) ;
#line 24 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/drive_exceptions.h"
static exception atapi_list[5]  = {      {(char *)"SAMSUNG SCR-830 REV 2.09 2.09 ", 1, (unsigned char)0, & Dummy, & scsi_read_mmc2,
      0}, 
        {(char *)"Memorex CR-622", 1, (unsigned char)0, & Dummy, (long (*)(struct cdrom_drive * ,
                                                                        void * , long  ,
                                                                        long  ))((void *)0),
      0}, 
        {(char *)"SONY CD-ROM CDU-561", 0, (unsigned char)0, & Dummy, (long (*)(struct cdrom_drive * ,
                                                                             void * ,
                                                                             long  ,
                                                                             long  ))((void *)0),
      0}, 
        {(char *)"Chinon CD-ROM CDS-525", 0, (unsigned char)0, & Dummy, (long (*)(struct cdrom_drive * ,
                                                                               void * ,
                                                                               long  ,
                                                                               long  ))((void *)0),
      0}, 
        {(char *)((void *)0), 0, (unsigned char)0, (int (*)(struct cdrom_drive * , int  ))((void *)0),
      (long (*)(struct cdrom_drive * , void * , long  , long  ))((void *)0), 0}};
#line 345 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/cooked_interface.c"
static void check_exceptions(cdrom_drive *d___0 , exception *list ) 
{ 
  int i ;
  size_t tmp ;
  int tmp___0 ;

  {
#line 347
  i = 0;
  {
#line 348
  while (1) {
    while_continue: /* CIL Label */ ;
#line 348
    if (! (list + i)->model) {
#line 348
      goto while_break;
    }
    {
#line 349
    tmp = strlen((char const   *)(list + i)->model);
#line 349
    tmp___0 = strncmp((char const   *)(list + i)->model, (char const   *)d___0->drive_model,
                      tmp);
    }
#line 349
    if (! tmp___0) {
#line 350
      if ((list + i)->bigendianp != -1) {
#line 350
        d___0->bigendianp = (list + i)->bigendianp;
      }
#line 351
      return;
    }
#line 353
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 355
  return;
}
}
#line 358 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/cooked_interface.c"
int cooked_init_drive(cdrom_drive *d___0 ) 
{ 
  int ret ;
  char buffer[256] ;
  char buffer___0[256] ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 366
  if (d___0->drive_type == 28) {
#line 366
    goto case_28;
  }
#line 366
  if (d___0->drive_type == 27) {
#line 366
    goto case_28;
  }
#line 366
  if (d___0->drive_type == 26) {
#line 366
    goto case_28;
  }
#line 366
  if (d___0->drive_type == 25) {
#line 366
    goto case_28;
  }
#line 400
  if (d___0->drive_type == 34) {
#line 400
    goto case_34;
  }
#line 400
  if (d___0->drive_type == 33) {
#line 400
    goto case_34;
  }
#line 400
  if (d___0->drive_type == 22) {
#line 400
    goto case_34;
  }
#line 400
  if (d___0->drive_type == 3) {
#line 400
    goto case_34;
  }
#line 409
  goto switch_default;
  case_28: /* CIL Label */ 
  case_27: /* CIL Label */ 
  case_26: /* CIL Label */ 
  case_25: /* CIL Label */ 
  {
#line 369
  cdmessage(d___0, "Attempting to set sbpcd buffer size...\n");
#line 371
  d___0->nsectors = 8;
  }
  {
#line 372
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 377
    tmp = ioctl(d___0->ioctl_fd, 21378UL, d___0->nsectors);
    }
#line 377
    if (tmp == 0) {
#line 378
      d___0->nsectors >>= 1;
#line 379
      if (d___0->nsectors == 0) {
        {
#line 381
        d___0->nsectors = 8;
#line 382
        sprintf((char */* __restrict  */)(buffer), (char const   */* __restrict  */)"\tTrouble setting buffer size.  Defaulting to %d sectors.\n",
                d___0->nsectors);
#line 384
        cdmessage(d___0, (char const   *)(buffer));
        }
#line 385
        goto while_break;
      }
    } else {
      {
#line 389
      sprintf((char */* __restrict  */)(buffer___0), (char const   */* __restrict  */)"\tSetting read block size at %d sectors (%ld bytes).\n",
              d___0->nsectors, (long )d___0->nsectors * 2352L);
#line 391
      cdmessage(d___0, (char const   *)(buffer___0));
      }
#line 392
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 396
  goto switch_break;
  case_34: /* CIL Label */ 
  case_33: /* CIL Label */ 
  case_22: /* CIL Label */ 
  case_3: /* CIL Label */ 
  {
#line 401
  d___0->nsectors = 8;
#line 403
  d___0->bigendianp = 0;
#line 404
  d___0->is_atapi = 1;
#line 406
  check_exceptions(d___0, atapi_list);
  }
#line 408
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 410
  d___0->nsectors = 40;
  switch_break: /* CIL Label */ ;
  }
  {
#line 415
  d___0->enable_cdda = & Dummy;
#line 416
  d___0->read_audio = & cooked_read;
#line 417
  d___0->read_toc = & cooked_readtoc;
#line 418
  d___0->set_speed = & cooked_setspeed;
#line 419
  tmp___0 = (*(d___0->read_toc))(d___0);
#line 419
  d___0->tracks = tmp___0;
#line 419
  ret = tmp___0;
  }
#line 420
  if (d___0->tracks < 1) {
#line 421
    return (ret);
  }
  {
#line 423
  d___0->opened = 1;
#line 424
  ret = verify_read_command(d___0);
  }
#line 424
  if (ret) {
#line 424
    return (ret);
  }
#line 425
  d___0->error_retry = 1;
#line 426
  return (0);
}
}
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 891
extern char *cuserid(char *__s ) ;
#line 353 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 460
extern int usleep(__useconds_t __useconds ) ;
#line 531
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) dup)(int __fd ) ;
#line 374 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) rand)(void) ;
#line 734
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) realpath)(char const   * __restrict  __name ,
                                                                                 char * __restrict  __resolved ) ;
#line 209 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) stat)(char const   * __restrict  __file ,
                                                                                             struct stat * __restrict  __buf ) ;
#line 263
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) lstat)(char const   * __restrict  __file ,
                                                                                              struct stat * __restrict  __buf ) ;
#line 109 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/cdda_interface.h"
cdrom_drive *cdda_find_a_cdrom(int messagedest , char **messages ) ;
#line 110
cdrom_drive *cdda_identify(char const   *device , int messagedest , char **messages ) ;
#line 112
cdrom_drive *cdda_identify_cooked(char const   *dev , int messagedest , char **messages ) ;
#line 114
cdrom_drive *cdda_identify_scsi(char const   *generic_device , char const   *specialized_device ,
                                int messagedest , char **messages ) ;
#line 66 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 129
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 140
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncat)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 176
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 236
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 263
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strrchr)(char const   *__s ,
                                                                                                int __c )  __attribute__((__pure__)) ;
#line 413
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
#line 146 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 134 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/low_interface.h"
unsigned char *scsi_inquiry(cdrom_drive *d___0 ) ;
#line 12 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/common_interface.h"
int ioctl_ping_cdrom(int fd ) ;
#line 13
char *atapi_drive_info(int fd ) ;
#line 88 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/utils.h"
__inline static char *copystring(char const   *s ) 
{ 
  char *ret ;
  size_t tmp ;
  void *tmp___0 ;

  {
#line 89
  if (s) {
    {
#line 90
    tmp = strlen(s);
#line 90
    tmp___0 = malloc((tmp + 9UL) * sizeof(char ));
#line 90
    ret = (char *)tmp___0;
#line 92
    strcpy((char */* __restrict  */)ret, (char const   */* __restrict  */)s);
    }
#line 93
    return (ret);
  }
#line 95
  return ((char *)((void *)0));
}
}
#line 141 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/utils.h"
static void idperror(int messagedest , char **messages , char const   *f , char const   *s ) 
{ 
  char *buffer ;
  int malloced ;
  size_t tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  size_t tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  size_t tmp___5 ;
  int *tmp___6 ;
  char *tmp___7 ;
  int *tmp___8 ;
  int *tmp___9 ;
  char *tmp___10 ;
  int *tmp___11 ;

  {
#line 145
  malloced = 0;
#line 146
  if (! f) {
#line 147
    buffer = (char *)s;
  } else
#line 149
  if (! s) {
#line 150
    buffer = (char *)f;
  } else {
    {
#line 152
    tmp = strlen(f);
#line 152
    tmp___0 = strlen(s);
#line 152
    tmp___1 = malloc((tmp + tmp___0) + 9UL);
#line 152
    buffer = (char *)tmp___1;
#line 153
    sprintf((char */* __restrict  */)buffer, (char const   */* __restrict  */)f, s);
#line 154
    malloced = 1;
    }
  }
#line 157
  if (buffer) {
    {
#line 159
    if (messagedest == 1) {
#line 159
      goto case_1;
    }
#line 167
    if (messagedest == 2) {
#line 167
      goto case_2;
    }
#line 178
    goto switch_default;
    case_1: /* CIL Label */ 
    {
#line 160
    tmp___2 = strlen((char const   *)buffer);
#line 160
    write(2, (void const   *)buffer, tmp___2);
#line 161
    tmp___8 = __errno_location();
    }
#line 161
    if (*tmp___8) {
      {
#line 162
      write(2, (void const   *)": ", (size_t )2);
#line 163
      tmp___3 = __errno_location();
#line 163
      tmp___4 = strerror(*tmp___3);
#line 163
      tmp___5 = strlen((char const   *)tmp___4);
#line 163
      tmp___6 = __errno_location();
#line 163
      tmp___7 = strerror(*tmp___6);
#line 163
      write(2, (void const   *)tmp___7, tmp___5);
#line 164
      write(2, (void const   *)"\n", (size_t )1);
      }
    }
#line 166
    goto switch_break;
    case_2: /* CIL Label */ 
#line 168
    if (messages) {
      {
#line 169
      *messages = catstring(*messages, (char const   *)buffer);
#line 170
      tmp___11 = __errno_location();
      }
#line 170
      if (*tmp___11) {
        {
#line 171
        *messages = catstring(*messages, ": ");
#line 172
        tmp___9 = __errno_location();
#line 172
        tmp___10 = strerror(*tmp___9);
#line 172
        *messages = catstring(*messages, (char const   *)tmp___10);
#line 173
        *messages = catstring(*messages, "\n");
        }
      }
    }
#line 176
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 179
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
#line 182
  if (malloced) {
    {
#line 182
    free((void *)buffer);
    }
  }
#line 183
  return;
}
}
#line 186 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/utils.h"
static void idmessage(int messagedest , char **messages , char const   *f , char const   *s ) 
{ 
  char *buffer ;
  int malloced ;
  size_t tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  size_t tmp___2 ;

  {
#line 189
  malloced = 0;
#line 190
  if (! f) {
#line 191
    buffer = (char *)s;
  } else
#line 193
  if (! s) {
#line 194
    buffer = (char *)f;
  } else {
    {
#line 196
    tmp = strlen(f);
#line 196
    tmp___0 = strlen(s);
#line 196
    tmp___1 = malloc((tmp + tmp___0) + 10UL);
#line 196
    buffer = (char *)tmp___1;
#line 197
    sprintf((char */* __restrict  */)buffer, (char const   */* __restrict  */)f, s);
#line 198
    strcat((char */* __restrict  */)buffer, (char const   */* __restrict  */)"\n");
#line 199
    malloced = 1;
    }
  }
#line 202
  if (buffer) {
    {
#line 204
    if (messagedest == 1) {
#line 204
      goto case_1;
    }
#line 208
    if (messagedest == 2) {
#line 208
      goto case_2;
    }
#line 215
    goto switch_default;
    case_1: /* CIL Label */ 
    {
#line 205
    tmp___2 = strlen((char const   *)buffer);
#line 205
    write(2, (void const   *)buffer, tmp___2);
    }
#line 206
    if (! malloced) {
      {
#line 206
      write(2, (void const   *)"\n", (size_t )1);
      }
    }
#line 207
    goto switch_break;
    case_2: /* CIL Label */ 
#line 209
    if (messages) {
      {
#line 210
      *messages = catstring(*messages, (char const   *)buffer);
      }
#line 211
      if (! malloced) {
        {
#line 211
        *messages = catstring(*messages, "\n");
        }
      }
    }
#line 213
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 216
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
#line 219
  if (malloced) {
    {
#line 219
    free((void *)buffer);
    }
  }
#line 220
  return;
}
}
#line 29 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/scan_devices.c"
static char *scsi_cdrom_prefixes[3]  = {      (char *)"/dev/scd",      (char *)"/dev/sr",      (char *)((void *)0)};
#line 33 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/scan_devices.c"
static char *scsi_generic_prefixes[2]  = {      (char *)"/dev/sg",      (char *)((void *)0)};
#line 37 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/scan_devices.c"
static char *devfs_scsi_test  =    (char *)"/dev/scsi/";
#line 38 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/scan_devices.c"
static char *devfs_scsi_cd  =    (char *)"cd";
#line 39 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/scan_devices.c"
static char *devfs_scsi_generic  =    (char *)"generic";
#line 41 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/scan_devices.c"
static char *cdrom_devices[15]  = 
#line 41
  {      (char *)"/dev/cdrom",      (char *)"/dev/cdroms/cdrom?",      (char *)"/dev/hd?",      (char *)"/dev/sg?", 
        (char *)"/dev/cdu31a",      (char *)"/dev/cdu535",      (char *)"/dev/sbpcd",      (char *)"/dev/sbpcd?", 
        (char *)"/dev/sonycd",      (char *)"/dev/mcd",      (char *)"/dev/sjcd",      (char *)"/dev/cm206cd", 
        (char *)"/dev/gscd",      (char *)"/dev/optcd",      (char *)((void *)0)};
#line 72 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/scan_devices.c"
cdrom_drive *cdda_find_a_cdrom(int messagedest , char **messages ) 
{ 
  int i ;
  cdrom_drive *d___0 ;
  char *pos ;
  int j ;
  char *buffer ;
  char *tmp ;
  char *tmp___0 ;

  {
#line 75
  i = 0;
  {
#line 78
  while (1) {
    while_continue: /* CIL Label */ ;
#line 78
    if (! ((unsigned long )cdrom_devices[i] != (unsigned long )((void *)0))) {
#line 78
      goto while_break;
    }
    {
#line 82
    pos = strchr((char const   *)cdrom_devices[i], '?');
    }
#line 82
    if (pos) {
#line 85
      j = 0;
      {
#line 85
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 85
        if (! (j < 4)) {
#line 85
          goto while_break___0;
        }
        {
#line 86
        tmp = copystring((char const   *)cdrom_devices[i]);
#line 86
        buffer = tmp;
#line 90
        *(buffer + (pos - cdrom_devices[i])) = (char )(j + 48);
#line 91
        d___0 = cdda_identify((char const   *)buffer, messagedest, messages);
        }
#line 91
        if (d___0) {
#line 92
          return (d___0);
        }
        {
#line 93
        idmessage(messagedest, messages, "", (char const   *)((void *)0));
#line 95
        *(buffer + (pos - cdrom_devices[i])) = (char )(j + 97);
#line 96
        d___0 = cdda_identify((char const   *)buffer, messagedest, messages);
        }
#line 96
        if (d___0) {
#line 97
          return (d___0);
        }
        {
#line 98
        idmessage(messagedest, messages, "", (char const   *)((void *)0));
#line 85
        j ++;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
    } else {
      {
#line 103
      d___0 = cdda_identify((char const   *)cdrom_devices[i], messagedest, messages);
      }
#line 103
      if (d___0) {
#line 104
        return (d___0);
      }
      {
#line 106
      idmessage(messagedest, messages, "", (char const   *)((void *)0));
      }
    }
#line 108
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 110
  tmp___0 = cuserid((char *)((void *)0));
#line 110
  idmessage(messagedest, messages, "\n\nNo cdrom drives accessible to %s found.\n",
            (char const   *)tmp___0);
  }
#line 113
  return ((cdrom_drive *)((void *)0));
}
}
#line 116 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/scan_devices.c"
cdrom_drive *cdda_identify(char const   *device , int messagedest , char **messages ) 
{ 
  struct stat st ;
  cdrom_drive *d___0 ;
  int tmp ;

  {
  {
#line 118
  d___0 = (cdrom_drive *)((void *)0);
#line 120
  idmessage(messagedest, messages, "Checking %s for cdrom...", device);
#line 122
  tmp = stat((char const   */* __restrict  */)device, (struct stat */* __restrict  */)(& st));
  }
#line 122
  if (tmp) {
    {
#line 123
    idperror(messagedest, messages, "\tCould not stat %s", device);
    }
#line 124
    return ((cdrom_drive *)((void *)0));
  }
#line 128
  if (! ((st.st_mode & 61440U) == 8192U)) {
#line 128
    if (! ((st.st_mode & 61440U) == 24576U)) {
      {
#line 130
      idmessage(messagedest, messages, "\t%s is not a block or character device",
                device);
      }
#line 131
      return ((cdrom_drive *)((void *)0));
    }
  }
  {
#line 137
  d___0 = cdda_identify_scsi((char const   *)((void *)0), device, messagedest, messages);
  }
#line 138
  if (! d___0) {
    {
#line 138
    d___0 = cdda_identify_cooked(device, messagedest, messages);
    }
  }
#line 144
  return (d___0);
}
}
#line 147 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/scan_devices.c"
char *test_resolve_symlink(char const   *file , int messagedest , char **messages ) 
{ 
  char resolved[4096] ;
  struct stat st ;
  int tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 150
  tmp = lstat((char const   */* __restrict  */)file, (struct stat */* __restrict  */)(& st));
  }
#line 150
  if (tmp) {
    {
#line 151
    idperror(messagedest, messages, "\t\tCould not stat %s", file);
    }
#line 152
    return ((char *)((void *)0));
  }
  {
#line 155
  tmp___1 = realpath((char const   */* __restrict  */)file, (char */* __restrict  */)(resolved));
  }
#line 155
  if (tmp___1) {
    {
#line 156
    tmp___0 = strdup((char const   *)(resolved));
    }
#line 156
    return (tmp___0);
  }
  {
#line 158
  idperror(messagedest, messages, "\t\tCould not resolve symlink %s", file);
  }
#line 159
  return ((char *)((void *)0));
}
}
#line 164 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/scan_devices.c"
cdrom_drive *cdda_identify_cooked(char const   *dev , int messagedest , char **messages ) 
{ 
  cdrom_drive *d___0 ;
  struct stat st ;
  int fd ;
  int type ;
  char *description ;
  char *device ;
  int tmp ;
  int tmp___0 ;
  char *temp ;
  char *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  struct timespec tv ;
  int tmp___5 ;

  {
  {
#line 167
  d___0 = (cdrom_drive *)((void *)0);
#line 169
  fd = -1;
#line 171
  description = (char *)((void *)0);
#line 174
  idmessage(messagedest, messages, "\tTesting %s for cooked ioctl() interface", dev);
#line 176
  device = test_resolve_symlink(dev, messagedest, messages);
  }
#line 177
  if ((unsigned long )device == (unsigned long )((void *)0)) {
#line 177
    return ((cdrom_drive *)((void *)0));
  }
  {
#line 179
  tmp = stat((char const   */* __restrict  */)device, (struct stat */* __restrict  */)(& st));
  }
#line 179
  if (tmp) {
    {
#line 180
    idperror(messagedest, messages, "\t\tCould not stat %s", (char const   *)device);
#line 181
    free((void *)device);
    }
#line 182
    return ((cdrom_drive *)((void *)0));
  }
#line 185
  if (! ((st.st_mode & 61440U) == 8192U)) {
#line 185
    if (! ((st.st_mode & 61440U) == 24576U)) {
      {
#line 187
      idmessage(messagedest, messages, "\t\t%s is not a block or character device",
                (char const   *)device);
#line 188
      free((void *)device);
      }
#line 189
      return ((cdrom_drive *)((void *)0));
    }
  }
#line 192
  type = (int )(st.st_rdev >> 8);
  {
#line 203
  if (type == 91) {
#line 203
    goto case_91;
  }
#line 203
  if (type == 90) {
#line 203
    goto case_91;
  }
#line 203
  if (type == 89) {
#line 203
    goto case_91;
  }
#line 203
  if (type == 88) {
#line 203
    goto case_91;
  }
#line 203
  if (type == 57) {
#line 203
    goto case_91;
  }
#line 203
  if (type == 56) {
#line 203
    goto case_91;
  }
#line 203
  if (type == 34) {
#line 203
    goto case_91;
  }
#line 203
  if (type == 33) {
#line 203
    goto case_91;
  }
#line 203
  if (type == 22) {
#line 203
    goto case_91;
  }
#line 203
  if (type == 3) {
#line 203
    goto case_91;
  }
#line 228
  if (type == 15) {
#line 228
    goto case_15;
  }
#line 232
  if (type == 24) {
#line 232
    goto case_24;
  }
#line 240
  if (type == 28) {
#line 240
    goto case_28;
  }
#line 240
  if (type == 27) {
#line 240
    goto case_28;
  }
#line 240
  if (type == 26) {
#line 240
    goto case_28;
  }
#line 240
  if (type == 25) {
#line 240
    goto case_28;
  }
#line 244
  if (type == 18) {
#line 244
    goto case_18;
  }
#line 248
  if (type == 20) {
#line 248
    goto case_20;
  }
#line 248
  if (type == 23) {
#line 248
    goto case_20;
  }
#line 251
  if (type == 17) {
#line 251
    goto case_17;
  }
#line 254
  if (type == 29) {
#line 254
    goto case_29;
  }
#line 257
  if (type == 16) {
#line 257
    goto case_16;
  }
#line 260
  if (type == 32) {
#line 260
    goto case_32;
  }
#line 265
  if (type == 21) {
#line 265
    goto case_21;
  }
#line 265
  if (type == 11) {
#line 265
    goto case_21;
  }
#line 270
  goto switch_default;
  case_91: /* CIL Label */ 
  case_90: /* CIL Label */ 
  case_89: /* CIL Label */ 
  case_88: /* CIL Label */ 
  case_57: /* CIL Label */ 
  case_56: /* CIL Label */ 
  case_34: /* CIL Label */ 
  case_33: /* CIL Label */ 
  case_22: /* CIL Label */ 
  case_3: /* CIL Label */ 
  {
#line 207
  fd = open((char const   *)device, 2048);
  }
#line 208
  if (fd == -1) {
    {
#line 209
    idperror(messagedest, messages, "\t\tUnable to open %s", (char const   *)device);
#line 210
    free((void *)device);
    }
#line 211
    return ((cdrom_drive *)((void *)0));
  }
  {
#line 214
  tmp___0 = ioctl_ping_cdrom(fd);
  }
#line 214
  if (tmp___0) {
    {
#line 215
    idmessage(messagedest, messages, "\t\tDevice %s is not a CDROM", (char const   *)device);
#line 216
    close(fd);
#line 217
    free((void *)device);
    }
#line 218
    return ((cdrom_drive *)((void *)0));
  }
  {
#line 221
  tmp___1 = atapi_drive_info(fd);
#line 221
  temp = tmp___1;
#line 222
  description = catstring((char *)((void *)0), "ATAPI compatible ");
#line 223
  description = catstring(description, (char const   *)temp);
#line 224
  free((void *)temp);
  }
#line 227
  goto switch_break;
  case_15: /* CIL Label */ 
  {
#line 230
  description = copystring("Sony CDU31A or compatible");
  }
#line 231
  goto switch_break;
  case_24: /* CIL Label */ 
  {
#line 234
  description = copystring("Sony CDU535 or compatible");
  }
#line 235
  goto switch_break;
  case_28: /* CIL Label */ 
  case_27: /* CIL Label */ 
  case_26: /* CIL Label */ 
  case_25: /* CIL Label */ 
  {
#line 242
  description = copystring("non-ATAPI IDE-style Matsushita/Panasonic CR-5xx or compatible");
  }
#line 243
  goto switch_break;
  case_18: /* CIL Label */ 
  {
#line 245
  description = copystring("Sanyo proprietary or compatible: NOT CDDA CAPABLE");
  }
#line 246
  goto switch_break;
  case_20: /* CIL Label */ 
  case_23: /* CIL Label */ 
  {
#line 249
  description = copystring("Mitsumi proprietary or compatible: NOT CDDA CAPABLE");
  }
#line 250
  goto switch_break;
  case_17: /* CIL Label */ 
  {
#line 252
  description = copystring("Optics Dolphin or compatible: NOT CDDA CAPABLE");
  }
#line 253
  goto switch_break;
  case_29: /* CIL Label */ 
  {
#line 255
  description = copystring("Aztech proprietary or compatible: NOT CDDA CAPABLE");
  }
#line 256
  goto switch_break;
  case_16: /* CIL Label */ 
  {
#line 258
  description = copystring("Goldstar proprietary: NOT CDDA CAPABLE");
  }
#line 259
  goto switch_break;
  case_32: /* CIL Label */ 
  {
#line 261
  description = copystring("Philips/LMS CM206 proprietary: NOT CDDA CAPABLE");
  }
#line 262
  goto switch_break;
  case_21: /* CIL Label */ 
  case_11: /* CIL Label */ 
  {
#line 267
  idmessage(messagedest, messages, "\t\t%s is not a cooked ioctl CDROM.", (char const   *)device);
#line 268
  free((void *)device);
  }
#line 269
  return ((cdrom_drive *)((void *)0));
  switch_default: /* CIL Label */ 
  {
#line 272
  idmessage(messagedest, messages, "\t\t%s is not a cooked ioctl CDROM.", (char const   *)device);
#line 273
  free((void *)device);
  }
#line 274
  return ((cdrom_drive *)((void *)0));
  switch_break: /* CIL Label */ ;
  }
  {
#line 279
  tmp___2 = calloc((size_t )1, sizeof(cdrom_drive ));
#line 279
  d___0 = (cdrom_drive *)tmp___2;
#line 280
  d___0->cdda_device_name = device;
#line 281
  d___0->ioctl_device_name = copystring((char const   *)device);
#line 282
  d___0->drive_model = description;
#line 283
  d___0->drive_type = type;
#line 284
  d___0->cdda_fd = fd;
#line 285
  d___0->ioctl_fd = fd;
#line 286
  d___0->interface = 1;
#line 287
  d___0->bigendianp = -1;
#line 288
  d___0->nsectors = -1;
#line 289
  tmp___3 = calloc((size_t )1, sizeof(*(d___0->private_data)));
#line 289
  d___0->private_data = (cdda_private_data_t *)tmp___3;
#line 293
  tmp___5 = clock_gettime(1, & tv);
  }
#line 293
  if (tmp___5 < 0) {
#line 293
    (d___0->private_data)->clock = 0;
  } else {
#line 293
    (d___0->private_data)->clock = 1;
  }
  {
#line 295
  idmessage(messagedest, messages, "\t\tCDROM sensed: %s\n", (char const   *)description);
  }
#line 296
  return (d___0);
}
}
#line 354 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/scan_devices.c"
struct sg_id sg_id  ;
#line 367 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/scan_devices.c"
static int get_scsi_id(int fd , scsiid *id ) 
{ 
  struct sg_id argid ;
  int busarg ;
  int tmp ;
  int tmp___0 ;

  {
#line 373
  if (fd == -1) {
#line 373
    return (-1);
  }
  {
#line 374
  tmp = ioctl(fd, 21378UL, & argid);
  }
#line 374
  if (tmp) {
#line 374
    return (-1);
  }
  {
#line 375
  id->bus = (int )argid.l2;
#line 376
  id->id = (int )(argid.l1 & 255L);
#line 377
  id->lun = (int )((argid.l1 >> 8) & 255L);
#line 379
  tmp___0 = ioctl(fd, 21382UL, & busarg);
  }
#line 379
  if (tmp___0 == 0) {
#line 380
    id->bus = busarg;
  }
#line 382
  return (0);
}
}
#line 386 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/scan_devices.c"
static char *scsi_match(char const   *device , char **prefixes , char *devfs_test ,
                        char *devfs_other , char *prompt , int messagedest , char **messages ) 
{ 
  int dev ;
  int tmp ;
  scsiid a ;
  scsiid b ;
  int i ;
  int j ;
  char buffer[200] ;
  char *pos ;
  int matchf ;
  int *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int pattern ;
  int matchf___0 ;
  int k ;
  int *tmp___7 ;
  char *tmp___8 ;
  int tmp___9 ;
  char *tmp___10 ;
  int tmp___11 ;

  {
  {
#line 390
  tmp = open(device, 2048);
#line 390
  dev = tmp;
#line 398
  tmp___4 = strlen((char const   *)devfs_test);
#line 398
  tmp___5 = strncmp(device, (char const   *)devfs_test, tmp___4);
  }
#line 398
  if (! tmp___5) {
    {
#line 400
    strcpy((char */* __restrict  */)(buffer), (char const   */* __restrict  */)device);
#line 401
    pos = strrchr((char const   *)(buffer), '/');
    }
#line 402
    if (pos) {
      {
#line 404
      sprintf((char */* __restrict  */)pos, (char const   */* __restrict  */)"/%s",
              devfs_other);
#line 405
      matchf = open((char const   *)(buffer), 2048);
#line 406
      i = 0;
      }
      {
#line 406
      while (1) {
        while_continue: /* CIL Label */ ;
#line 406
        if (i < 10) {
#line 406
          if (! (matchf == -1)) {
#line 406
            goto while_break;
          }
        } else {
#line 406
          goto while_break;
        }
        {
#line 407
        tmp___0 = __errno_location();
#line 407
        tmp___1 = strerror(*tmp___0);
#line 407
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error trying to open %s exclusively (%s). retrying in 1 seconds.\n",
                buffer, tmp___1);
#line 408
        tmp___2 = rand();
#line 408
        usleep((__useconds_t )((double )1000000 + (100000.0 * (double )tmp___2) / ((double )2147483647 + 1.0)));
#line 409
        matchf = open((char const   *)(buffer), 2048);
#line 406
        i ++;
        }
      }
      while_break: /* CIL Label */ ;
      }
#line 411
      if (matchf != -1) {
        {
#line 412
        close(matchf);
#line 413
        close(dev);
#line 414
        tmp___3 = strdup((char const   *)(buffer));
        }
#line 414
        return (tmp___3);
      }
    }
  }
#line 420
  if (dev == -1) {
    {
#line 421
    idperror(messagedest, messages, "\t\tCould not access device %s", device);
    }
#line 424
    goto matchfail;
  }
  {
#line 426
  tmp___6 = get_scsi_id(dev, & a);
  }
#line 426
  if (tmp___6) {
    {
#line 427
    idperror(messagedest, messages, "\t\tDevice %s could not perform ioctl()", device);
    }
#line 430
    goto matchfail;
  }
#line 434
  i = 0;
  {
#line 434
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 434
    if (! (i < 25)) {
#line 434
      goto while_break___0;
    }
#line 435
    j = 0;
    {
#line 435
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 435
      if (! (j < 2)) {
#line 435
        goto while_break___1;
      }
#line 436
      pattern = 0;
      {
#line 439
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 439
        if (! ((unsigned long )*(prefixes + pattern) != (unsigned long )((void *)0))) {
#line 439
          goto while_break___2;
        }
        {
#line 441
        if (j == 0) {
#line 441
          goto case_0;
        }
#line 445
        if (j == 1) {
#line 445
          goto case_1;
        }
#line 440
        goto switch_break;
        case_0: /* CIL Label */ 
        {
#line 443
        sprintf((char */* __restrict  */)(buffer), (char const   */* __restrict  */)"%s%d",
                *(prefixes + pattern), i);
        }
#line 444
        goto switch_break;
        case_1: /* CIL Label */ 
        {
#line 447
        sprintf((char */* __restrict  */)(buffer), (char const   */* __restrict  */)"%s%c",
                *(prefixes + pattern), i + 97);
        }
#line 448
        goto switch_break;
        switch_break: /* CIL Label */ ;
        }
        {
#line 451
        matchf___0 = open((char const   *)(buffer), 2048);
#line 452
        k = 0;
        }
        {
#line 452
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 452
          if (k < 10) {
#line 452
            if (! (matchf___0 == -1)) {
#line 452
              goto while_break___3;
            }
          } else {
#line 452
            goto while_break___3;
          }
          {
#line 453
          tmp___7 = __errno_location();
#line 453
          tmp___8 = strerror(*tmp___7);
#line 453
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error trying to open %s exclusively (%s). retrying in 1 second.\n",
                  buffer, tmp___8);
#line 454
          tmp___9 = rand();
#line 454
          usleep((__useconds_t )((double )1000000 + (100000.0 * (double )tmp___9) / ((double )2147483647 + 1.0)));
#line 455
          matchf___0 = open((char const   *)(buffer), 2048);
#line 452
          k ++;
          }
        }
        while_break___3: /* CIL Label */ ;
        }
#line 458
        if (matchf___0 != -1) {
          {
#line 459
          tmp___11 = get_scsi_id(matchf___0, & b);
          }
#line 459
          if (tmp___11 == 0) {
#line 460
            if (a.bus == b.bus) {
#line 460
              if (a.id == b.id) {
#line 460
                if (a.lun == b.lun) {
                  {
#line 461
                  close(matchf___0);
#line 462
                  close(dev);
#line 463
                  tmp___10 = strdup((char const   *)(buffer));
                  }
#line 463
                  return (tmp___10);
                }
              }
            }
          }
          {
#line 466
          close(matchf___0);
          }
        }
#line 468
        pattern ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 435
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 434
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 473
  idmessage(messagedest, messages, (char const   *)prompt, device);
  }
  matchfail: 
#line 477
  if (dev != -1) {
    {
#line 477
    close(dev);
    }
  }
#line 478
  return ((char *)((void *)0));
}
}
#line 482 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/scan_devices.c"
void strscat(char *a , char *b , int n ) 
{ 
  int i ;

  {
#line 485
  i = n;
  {
#line 485
  while (1) {
    while_continue: /* CIL Label */ ;
#line 485
    if (! (i > 0)) {
#line 485
      goto while_break;
    }
#line 486
    if ((int )*(b + (i - 1)) > 32) {
#line 486
      goto while_break;
    }
#line 485
    i --;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 488
  strncat((char */* __restrict  */)a, (char const   */* __restrict  */)b, (size_t )i);
#line 489
  strcat((char */* __restrict  */)a, (char const   */* __restrict  */)" ");
  }
#line 490
  return;
}
}
#line 495 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/scan_devices.c"
static int verify_SG_version(cdrom_drive *d___0 , int messagedest , char **messages ) 
{ 
  int version ;
  int major ;
  int minor ;
  char buffer[256] ;
  int tmp ;

  {
  {
#line 500
  idmessage(messagedest, messages, "\nFound an accessible SCSI CDROM drive.\nLooking at revision of the SG interface in use...",
            "");
#line 504
  tmp = ioctl(d___0->cdda_fd, 8834UL, & version);
  }
#line 504
  if (tmp) {
    {
#line 506
    idmessage(messagedest, messages, "\tOOPS!  Old 2.0/early 2.1/early 2.2.x (non-ac patch) style SG.\n\tCdparanoia no longer supports the old interface.\n",
              "");
    }
#line 509
    return (0);
  }
  {
#line 511
  major = version / 10000;
#line 512
  version -= major * 10000;
#line 513
  minor = version / 100;
#line 514
  version -= minor * 100;
#line 516
  sprintf((char */* __restrict  */)(buffer), (char const   */* __restrict  */)"\tSG interface version %d.%d.%d; OK.",
          major, minor, version);
#line 519
  idmessage(messagedest, messages, (char const   *)(buffer), "");
  }
#line 520
  return (major);
}
}
#line 523 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/scan_devices.c"
int check_sgio(char const   *device , int messagedest , char **messages ) 
{ 
  int fd ;
  struct sg_io_hdr hdr ;
  int *tmp ;
  int tmp___0 ;

  {
#line 527
  if (! device) {
#line 527
    return (0);
  }
  {
#line 532
  fd = open(device, 2050);
  }
#line 533
  if (fd < 0) {
    {
#line 534
    idperror(messagedest, messages, "\t\tCould not access device %s to test for SG_IO support",
             device);
    }
#line 536
    return (0);
  }
  {
#line 539
  memset((void *)(& hdr), 0, sizeof(struct sg_io_hdr ));
#line 543
  hdr.interface_id = 'A';
#line 544
  tmp___0 = ioctl(fd, 8837UL, & hdr);
  }
#line 544
  if (tmp___0) {
    {
#line 545
    tmp = __errno_location();
    }
    {
#line 549
    if (*tmp == 38) {
#line 549
      goto case_38;
    }
#line 549
    if (*tmp == 22) {
#line 549
      goto case_38;
    }
#line 556
    goto switch_default;
    case_38: /* CIL Label */ 
    case_22: /* CIL Label */ 
    {
#line 553
    close(fd);
    }
#line 554
    return (1);
    switch_default: /* CIL Label */ 
    {
#line 559
    close(fd);
    }
#line 560
    return (0);
    switch_break: /* CIL Label */ ;
    }
  }
  {
#line 567
  close(fd);
  }
#line 568
  return (0);
}
}
#line 575 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/scan_devices.c"
cdrom_drive *cdda_identify_scsi(char const   *generic_device , char const   *specialized_device ,
                                int messagedest , char **messages ) 
{ 
  cdrom_drive *d___0 ;
  struct stat i_st ;
  struct stat g_st ;
  int use_sgio ;
  int i_fd ;
  int g_fd ;
  int version ;
  int type ;
  char *p___0 ;
  int tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  char *temp ;
  char *tmp___4 ;
  char *tmp___5 ;
  char const   *tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  void *tmp___9 ;
  void *tmp___10 ;
  struct timespec tv ;
  int tmp___12 ;
  struct sg_header *tmp___13 ;
  void *tmp___14 ;
  int tmp___15 ;
  void *tmp___16 ;
  scsiid lun ;
  int tmp___17 ;
  unsigned char *tmp___18 ;
  unsigned char *tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  void *tmp___22 ;
  void *tmp___23 ;

  {
#line 579
  d___0 = (cdrom_drive *)((void *)0);
#line 582
  use_sgio = 1;
#line 583
  i_fd = -1;
#line 584
  g_fd = -1;
#line 589
  if (generic_device) {
    {
#line 590
    idmessage(messagedest, messages, "\tTesting %s for SCSI/MMC interface", generic_device);
    }
  } else
#line 593
  if (specialized_device) {
    {
#line 594
    idmessage(messagedest, messages, "\tTesting %s for SCSI/MMC interface", specialized_device);
    }
  }
#line 598
  if (generic_device) {
    {
#line 599
    use_sgio = 0;
#line 600
    idmessage(messagedest, messages, "\t\tgeneric device forced; not testing for SG_IO interface",
              generic_device);
#line 603
    tmp = stat((char const   */* __restrict  */)generic_device, (struct stat */* __restrict  */)(& g_st));
    }
#line 603
    if (tmp) {
      {
#line 604
      idperror(messagedest, messages, "\t\tCould not access device %s", generic_device);
      }
#line 606
      return ((cdrom_drive *)((void *)0));
    }
#line 609
    if ((int )(g_st.st_rdev >> 8) != 21) {
      {
#line 610
      idmessage(messagedest, messages, "\t\t%s is not a generic SCSI device", generic_device);
      }
#line 612
      return ((cdrom_drive *)((void *)0));
    }
  }
#line 616
  if (specialized_device) {
    {
#line 617
    tmp___0 = stat((char const   */* __restrict  */)specialized_device, (struct stat */* __restrict  */)(& i_st));
    }
#line 617
    if (tmp___0) {
      {
#line 618
      idperror(messagedest, messages, "\t\tCould not access device %s", specialized_device);
      }
#line 620
      return ((cdrom_drive *)((void *)0));
    }
  }
#line 626
  if (generic_device) {
    {
#line 627
    tmp___1 = test_resolve_symlink(generic_device, messagedest, messages);
#line 627
    generic_device = (char const   *)tmp___1;
    }
#line 628
    if ((unsigned long )generic_device == (unsigned long )((void *)0)) {
#line 628
      goto cdda_identify_scsi_fail;
    }
  }
#line 630
  if (specialized_device) {
    {
#line 631
    tmp___2 = test_resolve_symlink(specialized_device, messagedest, messages);
#line 631
    specialized_device = (char const   *)tmp___2;
    }
#line 632
    if ((unsigned long )specialized_device == (unsigned long )((void *)0)) {
#line 632
      goto cdda_identify_scsi_fail;
    }
  }
#line 636
  if (use_sgio) {
    {
#line 637
    tmp___3 = check_sgio(specialized_device, messagedest, messages);
    }
#line 637
    if (tmp___3) {
      {
#line 638
      idmessage(messagedest, messages, "\t\tSG_IO device: %s", specialized_device);
      }
    } else {
      {
#line 640
      idmessage(messagedest, messages, "\t\tno SG_IO support for device: %s", specialized_device);
#line 641
      use_sgio = 0;
      }
    }
  }
#line 645
  if (! use_sgio) {
#line 648
    if (specialized_device) {
#line 649
      if ((int )(i_st.st_rdev >> 8) == 21) {
#line 650
        temp = (char *)generic_device;
#line 651
        generic_device = specialized_device;
#line 652
        specialized_device = (char const   *)temp;
      }
#line 655
      if (! generic_device) {
#line 655
        goto _L;
      } else
#line 655
      if (! specialized_device) {
        _L: /* CIL Label */ 
#line 656
        if (generic_device) {
          {
#line 657
          tmp___4 = scsi_match(generic_device, scsi_cdrom_prefixes, devfs_scsi_test,
                               devfs_scsi_cd, (char *)"\t\tNo cdrom device found to match generic device %s",
                               messagedest, messages);
#line 657
          specialized_device = (char const   *)tmp___4;
          }
        } else {
          {
#line 663
          tmp___5 = scsi_match(specialized_device, scsi_generic_prefixes, devfs_scsi_test,
                               devfs_scsi_generic, (char *)"\t\tNo generic SCSI device found to match CDROM device %s",
                               messagedest, messages);
#line 663
          generic_device = (char const   *)tmp___5;
          }
#line 668
          if (! generic_device) {
#line 669
            goto cdda_identify_scsi_fail;
          }
        }
      }
    }
    {
#line 674
    idmessage(messagedest, messages, "\t\tgeneric device: %s", generic_device);
    }
#line 675
    if (specialized_device) {
#line 675
      tmp___6 = specialized_device;
    } else {
#line 675
      tmp___6 = "not found";
    }
    {
#line 675
    idmessage(messagedest, messages, "\t\tioctl device: %s", tmp___6);
    }
#line 678
    if (specialized_device) {
      {
#line 679
      tmp___7 = stat((char const   */* __restrict  */)specialized_device, (struct stat */* __restrict  */)(& i_st));
      }
#line 679
      if (tmp___7) {
        {
#line 680
        idperror(messagedest, messages, "\t\tCould not access cdrom device %s", specialized_device);
        }
#line 682
        goto cdda_identify_scsi_fail;
      }
    }
    {
#line 686
    tmp___8 = stat((char const   */* __restrict  */)generic_device, (struct stat */* __restrict  */)(& g_st));
    }
#line 686
    if (tmp___8) {
      {
#line 687
      idperror(messagedest, messages, "\t\tCould not access generic SCSI device %s",
               generic_device);
      }
#line 690
      goto cdda_identify_scsi_fail;
    }
  }
#line 694
  if (specialized_device) {
#line 695
    if (use_sgio) {
      {
#line 696
      i_fd = open(specialized_device, 2050);
      }
    } else {
      {
#line 698
      i_fd = open(specialized_device, 2048);
      }
    }
  }
#line 701
  if (generic_device) {
    {
#line 702
    g_fd = open(generic_device, 2);
    }
  }
#line 705
  if (specialized_device) {
#line 705
    if (i_fd == -1) {
      {
#line 706
      idperror(messagedest, messages, "\t\tCould not open cdrom device %s (continuing)",
               specialized_device);
      }
#line 708
      goto cdda_identify_scsi_fail;
    }
  }
#line 711
  if (generic_device) {
#line 711
    if (g_fd == -1) {
      {
#line 712
      idperror(messagedest, messages, "\t\tCould not open generic SCSI device %s",
               generic_device);
      }
#line 714
      goto cdda_identify_scsi_fail;
    }
  }
#line 717
  if (i_fd != -1) {
#line 718
    type = (int )(i_st.st_rdev >> 8);
#line 720
    if (! use_sgio) {
#line 721
      if (type == 11) {
#line 722
        if (! ((i_st.st_mode & 61440U) == 24576U)) {
          {
#line 723
          idmessage(messagedest, messages, "\t\tSCSI CDROM device %s not a block device",
                    specialized_device);
          }
#line 725
          goto cdda_identify_scsi_fail;
        }
      } else {
        {
#line 728
        idmessage(messagedest, messages, "\t\tSCSI CDROM device %s has wrong major number",
                  specialized_device);
        }
#line 730
        goto cdda_identify_scsi_fail;
      }
    }
  }
#line 735
  if (g_fd != -1) {
#line 736
    if ((int )(g_st.st_rdev >> 8) == 21) {
#line 737
      if (! ((g_st.st_mode & 61440U) == 8192U)) {
        {
#line 738
        idmessage(messagedest, messages, "\t\tGeneric SCSI device %s not a char device",
                  generic_device);
        }
#line 740
        goto cdda_identify_scsi_fail;
      }
    } else {
      {
#line 743
      idmessage(messagedest, messages, "\t\tGeneric SCSI device %s has wrong major number",
                generic_device);
      }
#line 745
      goto cdda_identify_scsi_fail;
    }
  }
  {
#line 749
  tmp___9 = calloc((size_t )1, sizeof(cdrom_drive ));
#line 749
  d___0 = (cdrom_drive *)tmp___9;
#line 750
  d___0->drive_type = type;
#line 751
  d___0->cdda_fd = g_fd;
#line 752
  d___0->ioctl_fd = i_fd;
#line 753
  d___0->bigendianp = -1;
#line 754
  d___0->nsectors = -1;
#line 755
  d___0->messagedest = messagedest;
#line 756
  tmp___10 = calloc((size_t )1, sizeof(*(d___0->private_data)));
#line 756
  d___0->private_data = (cdda_private_data_t *)tmp___10;
#line 760
  tmp___12 = clock_gettime(1, & tv);
  }
#line 760
  if (tmp___12 < 0) {
#line 760
    (d___0->private_data)->clock = 0;
  } else {
#line 760
    (d___0->private_data)->clock = 1;
  }
#line 762
  if (use_sgio) {
    {
#line 763
    d___0->interface = 3;
#line 764
    tmp___14 = malloc((size_t )65536);
#line 764
    tmp___13 = (struct sg_header *)tmp___14;
#line 764
    (d___0->private_data)->sg_hd = tmp___13;
#line 764
    (d___0->private_data)->sg_buffer = (unsigned char *)tmp___13;
#line 765
    tmp___15 = dup(d___0->ioctl_fd);
#line 765
    d___0->cdda_fd = tmp___15;
#line 765
    g_fd = tmp___15;
    }
  } else {
    {
#line 767
    version = verify_SG_version(d___0, messagedest, messages);
    }
    {
#line 769
    if (version == 1) {
#line 769
      goto case_1;
    }
#line 769
    if (version == 0) {
#line 769
      goto case_1;
    }
#line 769
    if (version == -1) {
#line 769
      goto case_1;
    }
#line 772
    if (version == 3) {
#line 772
      goto case_3;
    }
#line 772
    if (version == 2) {
#line 772
      goto case_3;
    }
#line 768
    goto switch_break;
    case_1: /* CIL Label */ 
    case_0: /* CIL Label */ 
    case_neg_1: /* CIL Label */ 
#line 770
    d___0->interface = 0;
#line 771
    goto cdda_identify_scsi_fail;
    case_3: /* CIL Label */ 
    case_2: /* CIL Label */ 
#line 773
    d___0->interface = 0;
#line 774
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
    {
#line 778
    tmp___16 = malloc((size_t )65536);
#line 778
    (d___0->private_data)->sg_hd = (struct sg_header *)tmp___16;
#line 779
    (d___0->private_data)->sg_buffer = (unsigned char *)(d___0->private_data)->sg_hd + sizeof(struct sg_header );
    }
  }
  {
#line 785
  tmp___17 = get_scsi_id(i_fd, & lun);
  }
#line 785
  if (tmp___17) {
#line 786
    d___0->lun = 0;
  } else {
#line 788
    d___0->lun = lun.lun;
  }
  {
#line 791
  tmp___18 = scsi_inquiry(d___0);
#line 791
  p___0 = (char *)tmp___18;
  }
#line 793
  if (! p___0) {
#line 800
    if (d___0->interface == 3) {
      {
#line 802
      d___0->interface = 4;
#line 803
      tmp___19 = scsi_inquiry(d___0);
#line 803
      p___0 = (char *)tmp___19;
      }
#line 805
      if (p___0) {
        {
#line 806
        idmessage(messagedest, messages, "\t\tThis kernel\'s block layer has a buggy SG_DXFER_TO_FROM_DEVICE;\n\t\t   activating workaround.\n",
                  (char const   *)((void *)0));
        }
      } else {
#line 810
        d___0->interface = 3;
      }
    }
  }
#line 815
  if (! p___0) {
    {
#line 816
    idmessage(messagedest, messages, "\t\tInquiry command failed; unable to probe drive\n",
              (char const   *)((void *)0));
    }
#line 818
    goto cdda_identify_scsi_fail;
  }
#line 822
  if (p___0) {
    {
#line 822
    tmp___20 = strncmp((char const   *)(p___0 + 8), "TOSHIBA", (size_t )7);
    }
#line 822
    if (! tmp___20) {
      {
#line 822
      tmp___21 = strncmp((char const   *)(p___0 + 16), "CD-ROM", (size_t )6);
      }
#line 822
      if (! tmp___21) {
#line 822
        if ((int )*(p___0 + 0) == 0) {
#line 826
          *(p___0 + 0) = (char)5;
#line 827
          *(p___0 + 1) = (char )((int )*(p___0 + 1) | 128);
        }
      }
    }
  }
#line 830
  if ((int )*p___0 != 5) {
#line 830
    if ((int )*p___0 != 4) {
      {
#line 831
      idmessage(messagedest, messages, "\t\tDrive is neither a CDROM nor a WORM device\n",
                (char const   *)((void *)0));
      }
#line 833
      goto cdda_identify_scsi_fail;
    }
  }
  {
#line 836
  tmp___22 = calloc((size_t )36, (size_t )1);
#line 836
  d___0->drive_model = (char *)tmp___22;
#line 837
  memcpy((void */* __restrict  */)(d___0->inqbytes), (void const   */* __restrict  */)p___0,
         (size_t )4);
#line 838
  d___0->cdda_device_name = copystring(generic_device);
#line 839
  d___0->ioctl_device_name = copystring(specialized_device);
#line 840
  tmp___23 = calloc((size_t )36, (size_t )1);
#line 840
  d___0->drive_model = (char *)tmp___23;
#line 841
  strscat(d___0->drive_model, p___0 + 8, 8);
#line 842
  strscat(d___0->drive_model, p___0 + 16, 16);
#line 843
  strscat(d___0->drive_model, p___0 + 32, 4);
#line 845
  idmessage(messagedest, messages, "\nCDROM model sensed sensed: %s", (char const   *)d___0->drive_model);
  }
#line 846
  return (d___0);
  cdda_identify_scsi_fail: 
#line 849
  if (generic_device) {
    {
#line 849
    free((void *)((char *)generic_device));
    }
  }
#line 850
  if (specialized_device) {
    {
#line 850
    free((void *)((char *)specialized_device));
    }
  }
#line 851
  if (i_fd != -1) {
    {
#line 851
    close(i_fd);
    }
  }
#line 852
  if (g_fd != -1) {
    {
#line 852
    close(g_fd);
    }
  }
#line 853
  if (d___0) {
#line 854
    if (d___0->private_data) {
#line 855
      if ((d___0->private_data)->sg_hd) {
        {
#line 855
        free((void *)(d___0->private_data)->sg_hd);
        }
      }
      {
#line 856
      free((void *)d___0->private_data);
      }
    }
    {
#line 858
    free((void *)d___0);
    }
  }
#line 860
  return ((cdrom_drive *)((void *)0));
}
}
#line 181 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) fabs)(double __x )  __attribute__((__const__)) ;
#line 14 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/utils.h"
__inline static int bigendianp(void) 
{ 
  int test ;
  char *hack ;

  {
#line 15
  test = 1;
#line 16
  hack = (char *)(& test);
#line 17
  if (*(hack + 0)) {
#line 17
    return (0);
  }
#line 18
  return (1);
}
}
#line 28 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/utils.h"
__inline static int16_t swap16(int16_t x ) 
{ 


  {
#line 29
  return ((int16_t )((((unsigned int )((u_int16_t )x) & 255U) << 8) | (((unsigned int )((u_int16_t )x) & 65280U) >> 8)));
}
}
#line 39 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/utils.h"
__inline static int16_t be16_to_cpu(int16_t x ) 
{ 
  int16_t tmp ;

  {
  {
#line 40
  tmp = swap16(x);
  }
#line 40
  return (tmp);
}
}
#line 47 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/utils.h"
__inline static int16_t le16_to_cpu(int16_t x ) 
{ 


  {
#line 48
  return (x);
}
}
#line 125 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/utils.h"
static void cdmessage___0(cdrom_drive *d___0 , char const   *s ) 
{ 
  size_t tmp ;

  {
#line 126
  if (s) {
#line 126
    if (d___0) {
      {
#line 128
      if (d___0->messagedest == 1) {
#line 128
        goto case_1;
      }
#line 131
      if (d___0->messagedest == 2) {
#line 131
        goto case_2;
      }
#line 135
      goto switch_default;
      case_1: /* CIL Label */ 
      {
#line 129
      tmp = strlen(s);
#line 129
      write(2, (void const   *)s, tmp);
      }
#line 130
      goto switch_break;
      case_2: /* CIL Label */ 
      {
#line 132
      d___0->messagebuf = catstring(d___0->messagebuf, s);
      }
#line 133
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 136
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
  }
#line 139
  return;
}
}
#line 10 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/smallft.h"
void fft_forward(int n , float *buf , float *trigcache , int *splitcache ) ;
#line 23 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/common_interface.c"
int ioctl_ping_cdrom(int fd ) 
{ 
  struct cdrom_volctrl volctl ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 26
  tmp = ioctl(fd, 21267UL, & volctl);
  }
#line 26
  if (tmp) {
    {
#line 26
    tmp___0 = ioctl(fd, 21297UL, (void *)0);
    }
#line 26
    if (tmp___0 < 0) {
#line 32
      return (1);
    }
  }
#line 34
  return (0);
}
}
#line 41 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/common_interface.c"
char *atapi_drive_info(int fd ) 
{ 
  struct hd_driveid *id ;
  void *tmp ;
  char *ret ;
  int tmp___0 ;

  {
  {
#line 45
  tmp = malloc((size_t )512);
#line 45
  id = (struct hd_driveid *)tmp;
#line 48
  tmp___0 = ioctl(fd, 781UL, id);
  }
#line 48
  if (tmp___0) {
    {
#line 55
    ret = copystring("Generic Unidentifiable CDROM");
    }
  } else
#line 50
  if ((unsigned long )(id->model) == (unsigned long )((unsigned char *)0)) {
    {
#line 51
    ret = copystring("Generic Unidentifiable ATAPI CDROM");
    }
  } else
#line 50
  if ((int )id->model[0] == 0) {
    {
#line 51
    ret = copystring("Generic Unidentifiable ATAPI CDROM");
    }
  } else {
    {
#line 53
    ret = copystring((char const   *)(id->model));
    }
  }
  {
#line 57
  free((void *)id);
  }
#line 58
  return (ret);
}
}
#line 62 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/common_interface.c"
int data_bigendianp(cdrom_drive *d___0 ) 
{ 
  float lsb_votes ;
  float msb_votes ;
  int i ;
  int checked ;
  int endiancache ;
  float *a ;
  void *tmp ;
  float *b ;
  void *tmp___0 ;
  long readsectors ;
  int16_t *buff ;
  void *tmp___1 ;
  float lsb_energy ;
  float msb_energy ;
  long firstsector ;
  long tmp___2 ;
  long lastsector ;
  long tmp___3 ;
  int zeroflag ;
  long beginsec ;
  int j ;
  int offset ;
  long tmp___4 ;
  int j___0 ;
  int16_t tmp___5 ;
  int16_t tmp___6 ;
  double tmp___7 ;
  double tmp___8 ;
  int16_t tmp___9 ;
  int16_t tmp___10 ;
  double tmp___11 ;
  double tmp___12 ;
  int tmp___13 ;
  char buffer[256] ;
  char buffer___0[256] ;
  int tmp___14 ;

  {
  {
#line 63
  lsb_votes = (float )0;
#line 64
  msb_votes = (float )0;
#line 66
  endiancache = d___0->bigendianp;
#line 67
  tmp = calloc((size_t )1024, sizeof(float ));
#line 67
  a = (float *)tmp;
#line 68
  tmp___0 = calloc((size_t )1024, sizeof(float ));
#line 68
  b = (float *)tmp___0;
#line 69
  readsectors = 5L;
#line 70
  tmp___1 = malloc((size_t )(readsectors * 2352L));
#line 70
  buff = (int16_t *)tmp___1;
#line 76
  d___0->bigendianp = -1;
#line 78
  cdmessage___0(d___0, "\nAttempting to determine drive endianness from data...");
#line 79
  (*(d___0->enable_cdda))(d___0, 1);
#line 80
  i = 0;
#line 80
  checked = 0;
  }
  {
#line 80
  while (1) {
    while_continue: /* CIL Label */ ;
#line 80
    if (! (i < d___0->tracks)) {
#line 80
      goto while_break;
    }
    {
#line 81
    lsb_energy = (float )0;
#line 82
    msb_energy = (float )0;
#line 83
    tmp___13 = cdda_track_audiop(d___0, i + 1);
    }
#line 83
    if (tmp___13 == 1) {
      {
#line 84
      tmp___2 = cdda_track_firstsector(d___0, i + 1);
#line 84
      firstsector = tmp___2;
#line 85
      tmp___3 = cdda_track_lastsector(d___0, i + 1);
#line 85
      lastsector = tmp___3;
#line 86
      zeroflag = -1;
#line 87
      beginsec = 0L;
      }
      {
#line 91
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 91
        if (! (firstsector + readsectors <= lastsector)) {
#line 91
          goto while_break___0;
        }
        {
#line 94
        tmp___4 = (*(d___0->read_audio))(d___0, (void *)buff, firstsector, readsectors);
        }
#line 94
        if (tmp___4 > 0L) {
#line 97
          beginsec = 0L;
          {
#line 97
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 97
            if (! (beginsec < readsectors)) {
#line 97
              goto while_break___1;
            }
#line 98
            offset = (int )((beginsec * 2352L) / 2L);
#line 100
            j = 460;
            {
#line 100
            while (1) {
              while_continue___2: /* CIL Label */ ;
#line 100
              if (! (j < 588)) {
#line 100
                goto while_break___2;
              }
#line 101
              if ((int )*(buff + (offset + j)) != 0) {
#line 102
                zeroflag = 0;
#line 103
                goto while_break___2;
              }
#line 100
              j ++;
            }
            while_break___2: /* CIL Label */ ;
            }
#line 105
            if (! zeroflag) {
#line 105
              goto while_break___1;
            }
#line 97
            beginsec ++;
          }
          while_break___1: /* CIL Label */ ;
          }
#line 107
          if (! zeroflag) {
#line 107
            goto while_break___0;
          }
#line 108
          firstsector += readsectors;
        } else {
          {
#line 110
          (*(d___0->enable_cdda))(d___0, 0);
#line 111
          free((void *)a);
#line 112
          free((void *)b);
#line 113
          free((void *)buff);
          }
#line 114
          return (-1);
        }
      }
      while_break___0: /* CIL Label */ ;
      }
#line 118
      beginsec *= 1176L;
#line 121
      if (! zeroflag) {
#line 124
        j___0 = 0;
        {
#line 124
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 124
          if (! (j___0 < 128)) {
#line 124
            goto while_break___3;
          }
          {
#line 124
          tmp___5 = le16_to_cpu(*(buff + (((long )(j___0 * 2) + beginsec) + 460L)));
#line 124
          *(a + j___0) = (float )tmp___5;
#line 124
          j___0 ++;
          }
        }
        while_break___3: /* CIL Label */ ;
        }
#line 125
        j___0 = 0;
        {
#line 125
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 125
          if (! (j___0 < 128)) {
#line 125
            goto while_break___4;
          }
          {
#line 125
          tmp___6 = le16_to_cpu(*(buff + (((long )(j___0 * 2) + beginsec) + 461L)));
#line 125
          *(b + j___0) = (float )tmp___6;
#line 125
          j___0 ++;
          }
        }
        while_break___4: /* CIL Label */ ;
        }
        {
#line 126
        fft_forward(128, a, (float *)((void *)0), (int *)((void *)0));
#line 127
        fft_forward(128, b, (float *)((void *)0), (int *)((void *)0));
#line 128
        j___0 = 0;
        }
        {
#line 128
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 128
          if (! (j___0 < 128)) {
#line 128
            goto while_break___5;
          }
          {
#line 128
          tmp___7 = fabs((double )*(a + j___0));
#line 128
          tmp___8 = fabs((double )*(b + j___0));
#line 128
          lsb_energy = (float )((double )lsb_energy + (tmp___7 + tmp___8));
#line 128
          j___0 ++;
          }
        }
        while_break___5: /* CIL Label */ ;
        }
#line 130
        j___0 = 0;
        {
#line 130
        while (1) {
          while_continue___6: /* CIL Label */ ;
#line 130
          if (! (j___0 < 128)) {
#line 130
            goto while_break___6;
          }
          {
#line 130
          tmp___9 = be16_to_cpu(*(buff + (((long )(j___0 * 2) + beginsec) + 460L)));
#line 130
          *(a + j___0) = (float )tmp___9;
#line 130
          j___0 ++;
          }
        }
        while_break___6: /* CIL Label */ ;
        }
#line 131
        j___0 = 0;
        {
#line 131
        while (1) {
          while_continue___7: /* CIL Label */ ;
#line 131
          if (! (j___0 < 128)) {
#line 131
            goto while_break___7;
          }
          {
#line 131
          tmp___10 = be16_to_cpu(*(buff + (((long )(j___0 * 2) + beginsec) + 461L)));
#line 131
          *(b + j___0) = (float )tmp___10;
#line 131
          j___0 ++;
          }
        }
        while_break___7: /* CIL Label */ ;
        }
        {
#line 132
        fft_forward(128, a, (float *)((void *)0), (int *)((void *)0));
#line 133
        fft_forward(128, b, (float *)((void *)0), (int *)((void *)0));
#line 134
        j___0 = 0;
        }
        {
#line 134
        while (1) {
          while_continue___8: /* CIL Label */ ;
#line 134
          if (! (j___0 < 128)) {
#line 134
            goto while_break___8;
          }
          {
#line 134
          tmp___11 = fabs((double )*(a + j___0));
#line 134
          tmp___12 = fabs((double )*(b + j___0));
#line 134
          msb_energy = (float )((double )msb_energy + (tmp___11 + tmp___12));
#line 134
          j___0 ++;
          }
        }
        while_break___8: /* CIL Label */ ;
        }
      }
    }
#line 137
    if (lsb_energy < msb_energy) {
#line 138
      lsb_votes += msb_energy / lsb_energy;
#line 139
      checked ++;
    } else
#line 141
    if (lsb_energy > msb_energy) {
#line 142
      msb_votes += lsb_energy / msb_energy;
#line 143
      checked ++;
    }
#line 146
    if (checked == 5) {
#line 146
      if (lsb_votes == (float )0) {
#line 146
        goto while_break;
      } else
#line 146
      if (msb_votes == (float )0) {
#line 146
        goto while_break;
      }
    }
    {
#line 147
    cdmessage___0(d___0, ".");
#line 80
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 150
  free((void *)buff);
#line 151
  free((void *)a);
#line 152
  free((void *)b);
#line 153
  d___0->bigendianp = endiancache;
#line 154
  (*(d___0->enable_cdda))(d___0, 0);
  }
#line 157
  if (lsb_votes > msb_votes) {
    {
#line 159
    cdmessage___0(d___0, "\n\tData appears to be coming back little endian.\n");
#line 160
    sprintf((char */* __restrict  */)(buffer), (char const   */* __restrict  */)"\tcertainty: %d%%\n",
            (int )((100. * (double )lsb_votes) / (double )(lsb_votes + msb_votes) + .5));
#line 162
    cdmessage___0(d___0, (char const   *)(buffer));
    }
#line 163
    return (0);
  } else {
#line 165
    if (msb_votes > lsb_votes) {
      {
#line 167
      cdmessage___0(d___0, "\n\tData appears to be coming back big endian.\n");
#line 168
      sprintf((char */* __restrict  */)(buffer___0), (char const   */* __restrict  */)"\tcertainty: %d%%\n",
              (int )((100. * (double )msb_votes) / (double )(lsb_votes + msb_votes) + .5));
#line 170
      cdmessage___0(d___0, (char const   *)(buffer___0));
      }
#line 171
      return (1);
    }
    {
#line 174
    cdmessage___0(d___0, "\n\tCannot determine CDROM drive endianness.\n");
#line 175
    tmp___14 = bigendianp();
    }
#line 175
    return (tmp___14);
#line 176
    return (-1);
  }
}
}
#line 185 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/common_interface.c"
int FixupTOC(cdrom_drive *d___0 , int tracks ) 
{ 
  struct cdrom_multisession ms_str ;
  int j ;
  long last___0 ;
  int result ;

  {
#line 193
  j = 0;
  {
#line 193
  while (1) {
    while_continue: /* CIL Label */ ;
#line 193
    if (! (j < tracks)) {
#line 193
      goto while_break;
    }
#line 194
    if (d___0->disc_toc[j].dwStartSector < 0) {
      {
#line 195
      cdmessage___0(d___0, "\n\tTOC entry claims a negative start offset: massaging.\n");
#line 197
      d___0->disc_toc[j].dwStartSector = 0;
      }
    }
#line 199
    if (j < tracks - 1) {
#line 199
      if (d___0->disc_toc[j].dwStartSector > d___0->disc_toc[j + 1].dwStartSector) {
        {
#line 201
        cdmessage___0(d___0, "\n\tTOC entry claims an overly large start offset: massaging.\n");
#line 203
        d___0->disc_toc[j].dwStartSector = 0;
        }
      }
    }
#line 193
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 210
  last___0 = (long )d___0->disc_toc[0].dwStartSector;
#line 211
  j = 1;
  {
#line 211
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 211
    if (! (j < tracks)) {
#line 211
      goto while_break___0;
    }
#line 212
    if ((long )d___0->disc_toc[j].dwStartSector < last___0) {
      {
#line 213
      cdmessage___0(d___0, "\n\tTOC entries claim non-increasing offsets: massaging.\n");
#line 215
      d___0->disc_toc[j].dwStartSector = (int32_t )last___0;
      }
    }
#line 218
    last___0 = (long )d___0->disc_toc[j].dwStartSector;
#line 211
    j ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 227
  if (d___0->ioctl_fd != -1) {
    {
#line 230
    ms_str.addr_format = (__u8 )1;
#line 231
    result = ioctl(d___0->ioctl_fd, 21264UL, & ms_str);
    }
#line 232
    if (result == -1) {
#line 232
      return (-1);
    }
#line 234
    if (ms_str.addr.lba > 100) {
#line 240
      j = tracks - 1;
      {
#line 240
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 240
        if (! (j >= 0)) {
#line 240
          goto while_break___1;
        }
#line 241
        if (j > 0) {
#line 241
          if (! (! ((int )d___0->disc_toc[j].bFlags & 4))) {
#line 241
            if (! ((int )d___0->disc_toc[j - 1].bFlags & 4)) {
#line 242
              if (d___0->disc_toc[j].dwStartSector > ms_str.addr.lba - 11400) {
#line 242
                if (ms_str.addr.lba - 11400 > d___0->disc_toc[j - 1].dwStartSector) {
#line 244
                  d___0->disc_toc[j].dwStartSector = ms_str.addr.lba - 11400;
                }
              }
#line 245
              goto while_break___1;
            }
          }
        }
#line 240
        j --;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 248
      return (1);
    }
  }
#line 252
  return (0);
}
}
#line 109 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/utils.h"
static void cderror___0(cdrom_drive *d___0 , char const   *s ) 
{ 
  size_t tmp ;

  {
#line 110
  if (s) {
#line 110
    if (d___0) {
      {
#line 112
      if (d___0->errordest == 1) {
#line 112
        goto case_1;
      }
#line 115
      if (d___0->errordest == 2) {
#line 115
        goto case_2;
      }
#line 119
      goto switch_default;
      case_1: /* CIL Label */ 
      {
#line 113
      tmp = strlen(s);
#line 113
      write(2, (void const   *)s, tmp);
      }
#line 114
      goto switch_break;
      case_2: /* CIL Label */ 
      {
#line 116
      d___0->errorbuf = catstring(d___0->errorbuf, s);
      }
#line 117
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 120
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
  }
#line 123
  return;
}
}
#line 125 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/utils.h"
static void cdmessage___1(cdrom_drive *d___0 , char const   *s ) 
{ 
  size_t tmp ;

  {
#line 126
  if (s) {
#line 126
    if (d___0) {
      {
#line 128
      if (d___0->messagedest == 1) {
#line 128
        goto case_1;
      }
#line 131
      if (d___0->messagedest == 2) {
#line 131
        goto case_2;
      }
#line 135
      goto switch_default;
      case_1: /* CIL Label */ 
      {
#line 129
      tmp = strlen(s);
#line 129
      write(2, (void const   *)s, tmp);
      }
#line 130
      goto switch_break;
      case_2: /* CIL Label */ 
      {
#line 132
      d___0->messagebuf = catstring(d___0->messagebuf, s);
      }
#line 133
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 136
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
  }
#line 139
  return;
}
}
#line 15 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/cooked_interface.c"
static int timed_ioctl___0(cdrom_drive *d___0 , int fd , int command , void *arg ) 
{ 
  struct timespec tv1 ;
  struct timespec tv2 ;
  int ret1 ;
  int tmp ;
  int ret2 ;
  int tmp___0 ;
  int ret3 ;
  int tmp___1 ;

  {
  {
#line 18
  tmp = clock_gettime((d___0->private_data)->clock, & tv1);
#line 18
  ret1 = tmp;
#line 19
  tmp___0 = ioctl(fd, (unsigned long )command, arg);
#line 19
  ret2 = tmp___0;
#line 20
  tmp___1 = clock_gettime((d___0->private_data)->clock, & tv2);
#line 20
  ret3 = tmp___1;
  }
#line 21
  if (ret1 < 0) {
#line 22
    (d___0->private_data)->last_milliseconds = -1;
  } else
#line 21
  if (ret3 < 0) {
#line 22
    (d___0->private_data)->last_milliseconds = -1;
  } else {
#line 24
    (d___0->private_data)->last_milliseconds = (int )((double )(tv2.tv_sec - tv1.tv_sec) * 1000. + (double )(tv2.tv_nsec - tv1.tv_nsec) / 1000000.);
  }
#line 26
  return (ret2);
}
}
#line 30 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/cooked_interface.c"
static int cooked_readtoc___0(cdrom_drive *d___0 ) 
{ 
  int i ;
  int tracks ;
  struct cdrom_tochdr hdr ;
  struct cdrom_tocentry entry ;
  int *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 37
  tmp___0 = ioctl(d___0->ioctl_fd, 21253UL, & hdr);
  }
#line 37
  if (tmp___0) {
    {
#line 38
    tmp = __errno_location();
    }
    {
#line 39
    if (*tmp == 1) {
#line 39
      goto case_1;
    }
#line 42
    goto switch_default;
    case_1: /* CIL Label */ 
    {
#line 40
    cderror___0(d___0, "102: Permision denied on cdrom (ioctl) device\n");
    }
#line 41
    return (-102);
    switch_default: /* CIL Label */ 
    {
#line 43
    cderror___0(d___0, "004: Unable to read table of contents header\n");
    }
#line 44
    return (-4);
    switch_break: /* CIL Label */ ;
    }
  }
#line 48
  i = 0;
  {
#line 48
  while (1) {
    while_continue: /* CIL Label */ ;
#line 48
    if (! (i < (int )hdr.cdth_trk1)) {
#line 48
      goto while_break;
    }
    {
#line 49
    entry.cdte_track = (__u8 )(i + 1);
#line 50
    entry.cdte_format = (__u8 )1;
#line 51
    tmp___1 = ioctl(d___0->ioctl_fd, 21254UL, & entry);
    }
#line 51
    if (tmp___1) {
      {
#line 52
      cderror___0(d___0, "005: Unable to read table of contents entry\n");
      }
#line 53
      return (-5);
    }
#line 56
    d___0->disc_toc[i].bFlags = (unsigned char )(((int )entry.cdte_adr << 4) | ((int )entry.cdte_ctrl & 15));
#line 57
    d___0->disc_toc[i].bTrack = (unsigned char )(i + 1);
#line 58
    d___0->disc_toc[i].dwStartSector = entry.cdte_addr.lba;
#line 48
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 61
  entry.cdte_track = (__u8 )170;
#line 62
  entry.cdte_format = (__u8 )1;
#line 63
  tmp___2 = ioctl(d___0->ioctl_fd, 21254UL, & entry);
  }
#line 63
  if (tmp___2) {
    {
#line 64
    cderror___0(d___0, "005: Unable to read table of contents entry\n");
    }
#line 65
    return (-5);
  }
  {
#line 67
  d___0->disc_toc[i].bFlags = (unsigned char )(((int )entry.cdte_adr << 4) | ((int )entry.cdte_ctrl & 15));
#line 68
  d___0->disc_toc[i].bTrack = entry.cdte_track;
#line 69
  d___0->disc_toc[i].dwStartSector = entry.cdte_addr.lba;
#line 71
  tracks = (int )hdr.cdth_trk1 + 1;
#line 72
  d___0->cd_extra = FixupTOC(d___0, tracks);
#line 73
  tracks --;
  }
#line 73
  return (tracks);
}
}
#line 77 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/cooked_interface.c"
static int cooked_setspeed___0(cdrom_drive *d___0 , int speed ) 
{ 
  int tmp ;

  {
#line 79
  if (d___0->ioctl_fd != -1) {
    {
#line 80
    tmp = ioctl(d___0->ioctl_fd, 21282UL, speed);
    }
#line 80
    return (tmp);
  } else {
#line 82
    return (0);
  }
}
}
#line 89 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/cooked_interface.c"
static long cooked_read___0(cdrom_drive *d___0 , void *p___0 , long begin , long sectors ) 
{ 
  int retry_count ;
  int err ;
  int ret ;
  struct cdrom_read_audio arg ;
  char *buffer ;
  void *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  char b[256] ;

  {
#line 90
  ret = 0;
#line 92
  buffer = (char *)p___0;
#line 95
  if (sectors > (long )d___0->nsectors) {
#line 95
    sectors = (long )d___0->nsectors;
  } else {
#line 95
    sectors = sectors;
  }
#line 96
  if ((unsigned long )p___0 == (unsigned long )((void *)0)) {
    {
#line 96
    tmp = malloc((size_t )(sectors * 2352L));
#line 96
    buffer = (char *)tmp;
    }
  }
#line 98
  arg.addr.lba = (int )begin;
#line 99
  arg.addr_format = (__u8 )1;
#line 100
  arg.nframes = (int )sectors;
#line 101
  arg.buf = (__u8 *)buffer;
#line 102
  retry_count = 0;
  {
#line 104
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 105
    err = timed_ioctl___0(d___0, d___0->ioctl_fd, 21262, (void *)(& arg));
    }
#line 105
    if (err) {
#line 106
      if (! d___0->error_retry) {
#line 107
        ret = -7;
#line 108
        goto done;
      }
      {
#line 110
      tmp___0 = __errno_location();
      }
      {
#line 111
      if (*tmp___0 == 12) {
#line 111
        goto case_12;
      }
#line 121
      if (*tmp___0 == 123) {
#line 121
        goto case_123;
      }
#line 121
      if (*tmp___0 == 9) {
#line 121
        goto case_123;
      }
#line 121
      if (*tmp___0 == 6) {
#line 121
        goto case_123;
      }
#line 125
      goto switch_default;
      case_12: /* CIL Label */ 
#line 113
      if (sectors == 1L) {
        {
#line 115
        cderror___0(d___0, "300: Kernel memory error\n");
#line 116
        ret = -300;
        }
#line 117
        goto done;
      }
      case_123: /* CIL Label */ 
      case_9: /* CIL Label */ 
      case_6: /* CIL Label */ 
      {
#line 122
      tmp___1 = __errno_location();
#line 122
      *tmp___1 = 123;
#line 123
      ret = 0;
      }
#line 124
      goto done;
      switch_default: /* CIL Label */ 
#line 126
      if (sectors == 1L) {
#line 132
        if (retry_count > 7) {
          {
#line 134
          sprintf((char */* __restrict  */)(b), (char const   */* __restrict  */)"010: Unable to access sector %ld: skipping...\n",
                  begin);
#line 136
          cderror___0(d___0, (char const   *)(b));
#line 137
          ret = -10;
          }
#line 138
          goto done;
        }
#line 140
        goto switch_break;
      }
      switch_break: /* CIL Label */ ;
      }
#line 143
      if (retry_count > 4) {
#line 144
        if (sectors > 1L) {
#line 145
          sectors = (sectors * 3L) / 4L;
        }
      }
#line 146
      retry_count ++;
#line 147
      if (retry_count > 8) {
        {
#line 148
        cderror___0(d___0, "007: Unknown, unrecoverable error reading data\n");
#line 149
        ret = -7;
        }
#line 150
        goto done;
      }
    } else {
#line 153
      goto while_break;
    }
#line 104
    if (! err) {
#line 104
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 156
  ret = (int )sectors;
  done: 
#line 159
  if ((unsigned long )p___0 == (unsigned long )((void *)0)) {
#line 159
    if (buffer) {
      {
#line 159
      free((void *)buffer);
      }
    }
  }
#line 160
  return ((long )ret);
}
}
#line 298 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/cooked_interface.c"
static int Dummy___0(cdrom_drive *d___0 , int Switch ) 
{ 


  {
#line 299
  return (0);
}
}
#line 302 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/cooked_interface.c"
static int verify_read_command___0(cdrom_drive *d___0 ) 
{ 
  int i ;
  int16_t *buff ;
  void *tmp ;
  int audioflag ;
  long firstsector ;
  long tmp___0 ;
  long lastsector ;
  long tmp___1 ;
  long sector ;
  long tmp___2 ;
  int tmp___3 ;

  {
  {
#line 304
  tmp = malloc((size_t )2352);
#line 304
  buff = (int16_t *)tmp;
#line 305
  audioflag = 0;
#line 307
  cdmessage___1(d___0, "Verifying drive can read CDDA...\n");
#line 309
  (*(d___0->enable_cdda))(d___0, 1);
#line 311
  i = 1;
  }
  {
#line 311
  while (1) {
    while_continue: /* CIL Label */ ;
#line 311
    if (! (i <= d___0->tracks)) {
#line 311
      goto while_break;
    }
    {
#line 312
    tmp___3 = cdda_track_audiop(d___0, i);
    }
#line 312
    if (tmp___3 == 1) {
      {
#line 313
      tmp___0 = cdda_track_firstsector(d___0, i);
#line 313
      firstsector = tmp___0;
#line 314
      tmp___1 = cdda_track_lastsector(d___0, i);
#line 314
      lastsector = tmp___1;
#line 315
      sector = (firstsector + lastsector) >> 1;
#line 316
      audioflag = 1;
#line 318
      tmp___2 = (*(d___0->read_audio))(d___0, (void *)buff, sector, 1L);
      }
#line 318
      if (tmp___2 > 0L) {
        {
#line 319
        cdmessage___1(d___0, "\tExpected command set reads OK.\n");
#line 320
        (*(d___0->enable_cdda))(d___0, 0);
#line 321
        free((void *)buff);
        }
#line 322
        return (0);
      }
    }
#line 311
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 327
  (*(d___0->enable_cdda))(d___0, 0);
  }
#line 329
  if (! audioflag) {
    {
#line 330
    cdmessage___1(d___0, "\tCould not find any audio tracks on this disk.\n");
    }
#line 331
    return (-403);
  }
  {
#line 334
  cdmessage___1(d___0, "\n\tUnable to read any data; drive probably not CDDA capable.\n");
#line 337
  cderror___0(d___0, "006: Could not read any data from drive\n");
#line 339
  free((void *)buff);
  }
#line 340
  return (-6);
}
}
#line 24 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/drive_exceptions.h"
static exception atapi_list___0[5]  = {      {(char *)"SAMSUNG SCR-830 REV 2.09 2.09 ", 1, (unsigned char)0, & Dummy___0,
      & scsi_read_mmc2, 0}, 
        {(char *)"Memorex CR-622", 1, (unsigned char)0, & Dummy___0, (long (*)(struct cdrom_drive * ,
                                                                            void * ,
                                                                            long  ,
                                                                            long  ))((void *)0),
      0}, 
        {(char *)"SONY CD-ROM CDU-561", 0, (unsigned char)0, & Dummy___0, (long (*)(struct cdrom_drive * ,
                                                                                 void * ,
                                                                                 long  ,
                                                                                 long  ))((void *)0),
      0}, 
        {(char *)"Chinon CD-ROM CDS-525", 0, (unsigned char)0, & Dummy___0, (long (*)(struct cdrom_drive * ,
                                                                                   void * ,
                                                                                   long  ,
                                                                                   long  ))((void *)0),
      0}, 
        {(char *)((void *)0), 0, (unsigned char)0, (int (*)(struct cdrom_drive * , int  ))((void *)0),
      (long (*)(struct cdrom_drive * , void * , long  , long  ))((void *)0), 0}};
#line 345 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/cooked_interface.c"
static void check_exceptions___0(cdrom_drive *d___0 , exception *list ) 
{ 
  int i ;
  size_t tmp ;
  int tmp___0 ;

  {
#line 347
  i = 0;
  {
#line 348
  while (1) {
    while_continue: /* CIL Label */ ;
#line 348
    if (! (list + i)->model) {
#line 348
      goto while_break;
    }
    {
#line 349
    tmp = strlen((char const   *)(list + i)->model);
#line 349
    tmp___0 = strncmp((char const   *)(list + i)->model, (char const   *)d___0->drive_model,
                      tmp);
    }
#line 349
    if (! tmp___0) {
#line 350
      if ((list + i)->bigendianp != -1) {
#line 350
        d___0->bigendianp = (list + i)->bigendianp;
      }
#line 351
      return;
    }
#line 353
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 355
  return;
}
}
#line 9 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/paranoia/gap.h"
long i_paranoia_overlap_r(int16_t *buffA , int16_t *buffB , long offsetA , long offsetB ) ;
#line 11
long i_paranoia_overlap_f(int16_t *buffA , int16_t *buffB , long offsetA , long offsetB ,
                          long sizeA , long sizeB ) ;
#line 14
int i_stutter_or_gap(int16_t *A , int16_t *B , long offA , long offB , long gap ) ;
#line 16
void i_analyze_rift_f(int16_t *A , int16_t *B , long sizeA , long sizeB , long aoffset ,
                      long boffset , long *matchA , long *matchB , long *matchC ) ;
#line 20
void i_analyze_rift_r(int16_t *A , int16_t *B , long sizeA , long sizeB , long aoffset ,
                      long boffset , long *matchA , long *matchB , long *matchC ) ;
#line 25
void analyze_rift_silence_f(int16_t *A , int16_t *B , long sizeA , long sizeB , long aoffset ,
                            long boffset , long *matchA , long *matchB ) ;
#line 69 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) memcmp)(void const   *__s1 ,
                                                                                               void const   *__s2 ,
                                                                                               size_t __n )  __attribute__((__pure__)) ;
#line 29 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/paranoia/gap.c"
long i_paranoia_overlap_r(int16_t *buffA , int16_t *buffB , long offsetA , long offsetB ) 
{ 
  long beginA ;
  long beginB ;

  {
#line 31
  beginA = offsetA;
#line 32
  beginB = offsetB;
  {
#line 37
  while (1) {
    while_continue: /* CIL Label */ ;
#line 37
    if (beginA >= 0L) {
#line 37
      if (! (beginB >= 0L)) {
#line 37
        goto while_break;
      }
    } else {
#line 37
      goto while_break;
    }
#line 38
    if ((int )*(buffA + beginA) != (int )*(buffB + beginB)) {
#line 38
      goto while_break;
    }
#line 37
    beginA --;
#line 37
    beginB --;
  }
  while_break: /* CIL Label */ ;
  }
#line 40
  return (offsetA - beginA);
}
}
#line 57 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/paranoia/gap.c"
long i_paranoia_overlap_f(int16_t *buffA , int16_t *buffB , long offsetA , long offsetB ,
                          long sizeA , long sizeB ) 
{ 
  long endA ;
  long endB ;

  {
#line 60
  endA = offsetA;
#line 61
  endB = offsetB;
  {
#line 66
  while (1) {
    while_continue: /* CIL Label */ ;
#line 66
    if (endA < sizeA) {
#line 66
      if (! (endB < sizeB)) {
#line 66
        goto while_break;
      }
    } else {
#line 66
      goto while_break;
    }
#line 67
    if ((int )*(buffA + endA) != (int )*(buffB + endB)) {
#line 67
      goto while_break;
    }
#line 66
    endA ++;
#line 66
    endB ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 69
  return (endA - offsetA);
}
}
#line 84 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/paranoia/gap.c"
int i_stutter_or_gap(int16_t *A , int16_t *B , long offA , long offB , long gap ) 
{ 
  long a1 ;
  long b1 ;
  int tmp ;

  {
#line 86
  a1 = offA;
#line 87
  b1 = offB;
#line 103
  if (a1 < 0L) {
#line 106
    b1 -= a1;
#line 107
    gap += a1;
#line 108
    a1 = 0L;
  }
  {
#line 119
  tmp = memcmp((void const   *)(A + a1), (void const   *)(B + b1), (size_t )(gap * 2L));
  }
#line 119
  return (tmp);
}
}
#line 141 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/paranoia/gap.c"
void i_analyze_rift_f(int16_t *A , int16_t *B , long sizeA , long sizeB , long aoffset ,
                      long boffset , long *matchA , long *matchB , long *matchC ) 
{ 
  long apast ;
  long bpast ;
  long i ;
  long tmp ;
  long tmp___0 ;
  long tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 146
  apast = sizeA - aoffset;
#line 147
  bpast = sizeB - boffset;
#line 150
  *matchA = 0L;
#line 150
  *matchB = 0L;
#line 150
  *matchC = 0L;
#line 177
  i = 1L;
  {
#line 177
  while (1) {
    while_continue: /* CIL Label */ ;
#line 183
    if (i < bpast) {
      {
#line 188
      tmp = i_paranoia_overlap_f(A, B, aoffset, boffset + i, sizeA, sizeB);
      }
#line 188
      if (tmp >= 16L) {
#line 189
        *matchA = i;
#line 190
        goto while_break;
      }
    }
#line 194
    if (i < apast) {
      {
#line 199
      tmp___0 = i_paranoia_overlap_f(A, B, aoffset + i, boffset, sizeA, sizeB);
      }
#line 199
      if (tmp___0 >= 16L) {
#line 200
        *matchB = i;
#line 201
        goto while_break;
      }
#line 205
      if (i < bpast) {
        {
#line 210
        tmp___1 = i_paranoia_overlap_f(A, B, aoffset + i, boffset + i, sizeA, sizeB);
        }
#line 210
        if (tmp___1 >= 16L) {
#line 211
          *matchC = i;
#line 212
          goto while_break;
        }
      }
    } else
#line 220
    if (i >= bpast) {
#line 220
      goto while_break;
    }
#line 177
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 225
  if (*matchA == 0L) {
#line 225
    if (*matchB == 0L) {
#line 225
      if (*matchC == 0L) {
#line 225
        return;
      }
    }
  }
#line 227
  if (*matchC) {
#line 227
    return;
  }
#line 249
  if (*matchA) {
    {
#line 256
    tmp___2 = i_stutter_or_gap(A, B, aoffset - *matchA, boffset, *matchA);
    }
#line 256
    if (tmp___2) {
#line 257
      return;
    }
#line 262
    *matchB = - *matchA;
#line 263
    *matchA = 0L;
#line 264
    return;
  } else {
    {
#line 268
    tmp___3 = i_stutter_or_gap(B, A, boffset - *matchB, aoffset, *matchB);
    }
#line 268
    if (tmp___3) {
#line 269
      return;
    }
#line 271
    *matchA = - *matchB;
#line 272
    *matchB = 0L;
#line 273
    return;
  }
}
}
#line 296 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/paranoia/gap.c"
void i_analyze_rift_r(int16_t *A , int16_t *B , long sizeA , long sizeB , long aoffset ,
                      long boffset , long *matchA , long *matchB , long *matchC ) 
{ 
  long apast ;
  long bpast ;
  long i ;
  long tmp ;
  long tmp___0 ;
  long tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 301
  apast = aoffset + 1L;
#line 302
  bpast = boffset + 1L;
#line 305
  *matchA = 0L;
#line 305
  *matchB = 0L;
#line 305
  *matchC = 0L;
#line 332
  i = 1L;
  {
#line 332
  while (1) {
    while_continue: /* CIL Label */ ;
#line 338
    if (i < bpast) {
      {
#line 343
      tmp = i_paranoia_overlap_r(A, B, aoffset, boffset - i);
      }
#line 343
      if (tmp >= 16L) {
#line 344
        *matchA = i;
#line 345
        goto while_break;
      }
    }
#line 349
    if (i < apast) {
      {
#line 354
      tmp___0 = i_paranoia_overlap_r(A, B, aoffset - i, boffset);
      }
#line 354
      if (tmp___0 >= 16L) {
#line 355
        *matchB = i;
#line 356
        goto while_break;
      }
#line 360
      if (i < bpast) {
        {
#line 365
        tmp___1 = i_paranoia_overlap_r(A, B, aoffset - i, boffset - i);
        }
#line 365
        if (tmp___1 >= 16L) {
#line 366
          *matchC = i;
#line 367
          goto while_break;
        }
      }
    } else
#line 375
    if (i >= bpast) {
#line 375
      goto while_break;
    }
#line 332
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 380
  if (*matchA == 0L) {
#line 380
    if (*matchB == 0L) {
#line 380
      if (*matchC == 0L) {
#line 380
        return;
      }
    }
  }
#line 382
  if (*matchC) {
#line 382
    return;
  }
#line 405
  if (*matchA) {
    {
#line 421
    tmp___2 = i_stutter_or_gap(A, B, aoffset + 1L, (boffset - *matchA) + 1L, *matchA);
    }
#line 421
    if (tmp___2) {
#line 422
      return;
    }
#line 427
    *matchB = - *matchA;
#line 428
    *matchA = 0L;
#line 429
    return;
  } else {
    {
#line 433
    tmp___3 = i_stutter_or_gap(B, A, boffset + 1L, (aoffset - *matchB) + 1L, *matchB);
    }
#line 433
    if (tmp___3) {
#line 434
      return;
    }
#line 436
    *matchA = - *matchB;
#line 437
    *matchB = 0L;
#line 438
    return;
  }
}
}
#line 463 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/paranoia/gap.c"
void analyze_rift_silence_f(int16_t *A , int16_t *B , long sizeA , long sizeB , long aoffset ,
                            long boffset , long *matchA , long *matchB ) 
{ 


  {
#line 466
  *matchA = -1L;
#line 467
  *matchB = -1L;
#line 472
  if (sizeA > aoffset + 16L) {
#line 472
    sizeA = aoffset + 16L;
  } else {
#line 472
    sizeA = sizeA;
  }
#line 473
  if (sizeB > boffset + 16L) {
#line 473
    sizeB = boffset + 16L;
  } else {
#line 473
    sizeB = sizeB;
  }
#line 475
  aoffset ++;
#line 476
  boffset ++;
  {
#line 481
  while (1) {
    while_continue: /* CIL Label */ ;
#line 481
    if (! (aoffset < sizeA)) {
#line 481
      goto while_break;
    }
#line 482
    if ((int )*(A + aoffset) != (int )*(A + (aoffset - 1L))) {
#line 483
      *matchA = 0L;
#line 484
      goto while_break;
    }
#line 486
    aoffset ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 495
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 495
    if (! (boffset < sizeB)) {
#line 495
      goto while_break___0;
    }
#line 496
    if ((int )*(B + boffset) != (int )*(B + (boffset - 1L))) {
#line 497
      *matchB = 0L;
#line 498
      goto while_break___0;
    }
#line 500
    boffset ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 502
  return;
}
}
#line 141 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/utils.h"
static void idperror___0(int messagedest , char **messages , char const   *f , char const   *s ) 
{ 
  char *buffer ;
  int malloced ;
  size_t tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  size_t tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  size_t tmp___5 ;
  int *tmp___6 ;
  char *tmp___7 ;
  int *tmp___8 ;
  int *tmp___9 ;
  char *tmp___10 ;
  int *tmp___11 ;

  {
#line 145
  malloced = 0;
#line 146
  if (! f) {
#line 147
    buffer = (char *)s;
  } else
#line 149
  if (! s) {
#line 150
    buffer = (char *)f;
  } else {
    {
#line 152
    tmp = strlen(f);
#line 152
    tmp___0 = strlen(s);
#line 152
    tmp___1 = malloc((tmp + tmp___0) + 9UL);
#line 152
    buffer = (char *)tmp___1;
#line 153
    sprintf((char */* __restrict  */)buffer, (char const   */* __restrict  */)f, s);
#line 154
    malloced = 1;
    }
  }
#line 157
  if (buffer) {
    {
#line 159
    if (messagedest == 1) {
#line 159
      goto case_1;
    }
#line 167
    if (messagedest == 2) {
#line 167
      goto case_2;
    }
#line 178
    goto switch_default;
    case_1: /* CIL Label */ 
    {
#line 160
    tmp___2 = strlen((char const   *)buffer);
#line 160
    write(2, (void const   *)buffer, tmp___2);
#line 161
    tmp___8 = __errno_location();
    }
#line 161
    if (*tmp___8) {
      {
#line 162
      write(2, (void const   *)": ", (size_t )2);
#line 163
      tmp___3 = __errno_location();
#line 163
      tmp___4 = strerror(*tmp___3);
#line 163
      tmp___5 = strlen((char const   *)tmp___4);
#line 163
      tmp___6 = __errno_location();
#line 163
      tmp___7 = strerror(*tmp___6);
#line 163
      write(2, (void const   *)tmp___7, tmp___5);
#line 164
      write(2, (void const   *)"\n", (size_t )1);
      }
    }
#line 166
    goto switch_break;
    case_2: /* CIL Label */ 
#line 168
    if (messages) {
      {
#line 169
      *messages = catstring(*messages, (char const   *)buffer);
#line 170
      tmp___11 = __errno_location();
      }
#line 170
      if (*tmp___11) {
        {
#line 171
        *messages = catstring(*messages, ": ");
#line 172
        tmp___9 = __errno_location();
#line 172
        tmp___10 = strerror(*tmp___9);
#line 172
        *messages = catstring(*messages, (char const   *)tmp___10);
#line 173
        *messages = catstring(*messages, "\n");
        }
      }
    }
#line 176
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 179
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
#line 182
  if (malloced) {
    {
#line 182
    free((void *)buffer);
    }
  }
#line 183
  return;
}
}
#line 186 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/utils.h"
static void idmessage___0(int messagedest , char **messages , char const   *f , char const   *s ) 
{ 
  char *buffer ;
  int malloced ;
  size_t tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  size_t tmp___2 ;

  {
#line 189
  malloced = 0;
#line 190
  if (! f) {
#line 191
    buffer = (char *)s;
  } else
#line 193
  if (! s) {
#line 194
    buffer = (char *)f;
  } else {
    {
#line 196
    tmp = strlen(f);
#line 196
    tmp___0 = strlen(s);
#line 196
    tmp___1 = malloc((tmp + tmp___0) + 10UL);
#line 196
    buffer = (char *)tmp___1;
#line 197
    sprintf((char */* __restrict  */)buffer, (char const   */* __restrict  */)f, s);
#line 198
    strcat((char */* __restrict  */)buffer, (char const   */* __restrict  */)"\n");
#line 199
    malloced = 1;
    }
  }
#line 202
  if (buffer) {
    {
#line 204
    if (messagedest == 1) {
#line 204
      goto case_1;
    }
#line 208
    if (messagedest == 2) {
#line 208
      goto case_2;
    }
#line 215
    goto switch_default;
    case_1: /* CIL Label */ 
    {
#line 205
    tmp___2 = strlen((char const   *)buffer);
#line 205
    write(2, (void const   *)buffer, tmp___2);
    }
#line 206
    if (! malloced) {
      {
#line 206
      write(2, (void const   *)"\n", (size_t )1);
      }
    }
#line 207
    goto switch_break;
    case_2: /* CIL Label */ 
#line 209
    if (messages) {
      {
#line 210
      *messages = catstring(*messages, (char const   *)buffer);
      }
#line 211
      if (! malloced) {
        {
#line 211
        *messages = catstring(*messages, "\n");
        }
      }
    }
#line 213
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 216
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
#line 219
  if (malloced) {
    {
#line 219
    free((void *)buffer);
    }
  }
#line 220
  return;
}
}
#line 29 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/scan_devices.c"
static char *scsi_cdrom_prefixes___0[3]  = {      (char *)"/dev/scd",      (char *)"/dev/sr",      (char *)((void *)0)};
#line 33 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/scan_devices.c"
static char *scsi_generic_prefixes___0[2]  = {      (char *)"/dev/sg",      (char *)((void *)0)};
#line 37 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/scan_devices.c"
static char *devfs_scsi_test___0  =    (char *)"/dev/scsi/";
#line 38 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/scan_devices.c"
static char *devfs_scsi_cd___0  =    (char *)"cd";
#line 39 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/scan_devices.c"
static char *devfs_scsi_generic___0  =    (char *)"generic";
#line 41 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/scan_devices.c"
static char *cdrom_devices___0[15]  = 
#line 41
  {      (char *)"/dev/cdrom",      (char *)"/dev/cdroms/cdrom?",      (char *)"/dev/hd?",      (char *)"/dev/sg?", 
        (char *)"/dev/cdu31a",      (char *)"/dev/cdu535",      (char *)"/dev/sbpcd",      (char *)"/dev/sbpcd?", 
        (char *)"/dev/sonycd",      (char *)"/dev/mcd",      (char *)"/dev/sjcd",      (char *)"/dev/cm206cd", 
        (char *)"/dev/gscd",      (char *)"/dev/optcd",      (char *)((void *)0)};
#line 367 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/scan_devices.c"
static int get_scsi_id___0(int fd , scsiid *id ) 
{ 
  struct sg_id argid ;
  int busarg ;
  int tmp ;
  int tmp___0 ;

  {
#line 373
  if (fd == -1) {
#line 373
    return (-1);
  }
  {
#line 374
  tmp = ioctl(fd, 21378UL, & argid);
  }
#line 374
  if (tmp) {
#line 374
    return (-1);
  }
  {
#line 375
  id->bus = (int )argid.l2;
#line 376
  id->id = (int )(argid.l1 & 255L);
#line 377
  id->lun = (int )((argid.l1 >> 8) & 255L);
#line 379
  tmp___0 = ioctl(fd, 21382UL, & busarg);
  }
#line 379
  if (tmp___0 == 0) {
#line 380
    id->bus = busarg;
  }
#line 382
  return (0);
}
}
#line 386 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/scan_devices.c"
static char *scsi_match___0(char const   *device , char **prefixes , char *devfs_test ,
                            char *devfs_other , char *prompt , int messagedest , char **messages ) 
{ 
  int dev ;
  int tmp ;
  scsiid a ;
  scsiid b ;
  int i ;
  int j ;
  char buffer[200] ;
  char *pos ;
  int matchf ;
  int *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int pattern ;
  int matchf___0 ;
  int k ;
  int *tmp___7 ;
  char *tmp___8 ;
  int tmp___9 ;
  char *tmp___10 ;
  int tmp___11 ;

  {
  {
#line 390
  tmp = open(device, 2048);
#line 390
  dev = tmp;
#line 398
  tmp___4 = strlen((char const   *)devfs_test);
#line 398
  tmp___5 = strncmp(device, (char const   *)devfs_test, tmp___4);
  }
#line 398
  if (! tmp___5) {
    {
#line 400
    strcpy((char */* __restrict  */)(buffer), (char const   */* __restrict  */)device);
#line 401
    pos = strrchr((char const   *)(buffer), '/');
    }
#line 402
    if (pos) {
      {
#line 404
      sprintf((char */* __restrict  */)pos, (char const   */* __restrict  */)"/%s",
              devfs_other);
#line 405
      matchf = open((char const   *)(buffer), 2048);
#line 406
      i = 0;
      }
      {
#line 406
      while (1) {
        while_continue: /* CIL Label */ ;
#line 406
        if (i < 10) {
#line 406
          if (! (matchf == -1)) {
#line 406
            goto while_break;
          }
        } else {
#line 406
          goto while_break;
        }
        {
#line 407
        tmp___0 = __errno_location();
#line 407
        tmp___1 = strerror(*tmp___0);
#line 407
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error trying to open %s exclusively (%s). retrying in 1 seconds.\n",
                buffer, tmp___1);
#line 408
        tmp___2 = rand();
#line 408
        usleep((__useconds_t )((double )1000000 + (100000.0 * (double )tmp___2) / ((double )2147483647 + 1.0)));
#line 409
        matchf = open((char const   *)(buffer), 2048);
#line 406
        i ++;
        }
      }
      while_break: /* CIL Label */ ;
      }
#line 411
      if (matchf != -1) {
        {
#line 412
        close(matchf);
#line 413
        close(dev);
#line 414
        tmp___3 = strdup((char const   *)(buffer));
        }
#line 414
        return (tmp___3);
      }
    }
  }
#line 420
  if (dev == -1) {
    {
#line 421
    idperror___0(messagedest, messages, "\t\tCould not access device %s", device);
    }
#line 424
    goto matchfail;
  }
  {
#line 426
  tmp___6 = get_scsi_id___0(dev, & a);
  }
#line 426
  if (tmp___6) {
    {
#line 427
    idperror___0(messagedest, messages, "\t\tDevice %s could not perform ioctl()",
                 device);
    }
#line 430
    goto matchfail;
  }
#line 434
  i = 0;
  {
#line 434
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 434
    if (! (i < 25)) {
#line 434
      goto while_break___0;
    }
#line 435
    j = 0;
    {
#line 435
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 435
      if (! (j < 2)) {
#line 435
        goto while_break___1;
      }
#line 436
      pattern = 0;
      {
#line 439
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 439
        if (! ((unsigned long )*(prefixes + pattern) != (unsigned long )((void *)0))) {
#line 439
          goto while_break___2;
        }
        {
#line 441
        if (j == 0) {
#line 441
          goto case_0;
        }
#line 445
        if (j == 1) {
#line 445
          goto case_1;
        }
#line 440
        goto switch_break;
        case_0: /* CIL Label */ 
        {
#line 443
        sprintf((char */* __restrict  */)(buffer), (char const   */* __restrict  */)"%s%d",
                *(prefixes + pattern), i);
        }
#line 444
        goto switch_break;
        case_1: /* CIL Label */ 
        {
#line 447
        sprintf((char */* __restrict  */)(buffer), (char const   */* __restrict  */)"%s%c",
                *(prefixes + pattern), i + 97);
        }
#line 448
        goto switch_break;
        switch_break: /* CIL Label */ ;
        }
        {
#line 451
        matchf___0 = open((char const   *)(buffer), 2048);
#line 452
        k = 0;
        }
        {
#line 452
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 452
          if (k < 10) {
#line 452
            if (! (matchf___0 == -1)) {
#line 452
              goto while_break___3;
            }
          } else {
#line 452
            goto while_break___3;
          }
          {
#line 453
          tmp___7 = __errno_location();
#line 453
          tmp___8 = strerror(*tmp___7);
#line 453
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error trying to open %s exclusively (%s). retrying in 1 second.\n",
                  buffer, tmp___8);
#line 454
          tmp___9 = rand();
#line 454
          usleep((__useconds_t )((double )1000000 + (100000.0 * (double )tmp___9) / ((double )2147483647 + 1.0)));
#line 455
          matchf___0 = open((char const   *)(buffer), 2048);
#line 452
          k ++;
          }
        }
        while_break___3: /* CIL Label */ ;
        }
#line 458
        if (matchf___0 != -1) {
          {
#line 459
          tmp___11 = get_scsi_id___0(matchf___0, & b);
          }
#line 459
          if (tmp___11 == 0) {
#line 460
            if (a.bus == b.bus) {
#line 460
              if (a.id == b.id) {
#line 460
                if (a.lun == b.lun) {
                  {
#line 461
                  close(matchf___0);
#line 462
                  close(dev);
#line 463
                  tmp___10 = strdup((char const   *)(buffer));
                  }
#line 463
                  return (tmp___10);
                }
              }
            }
          }
          {
#line 466
          close(matchf___0);
          }
        }
#line 468
        pattern ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 435
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 434
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 473
  idmessage___0(messagedest, messages, (char const   *)prompt, device);
  }
  matchfail: 
#line 477
  if (dev != -1) {
    {
#line 477
    close(dev);
    }
  }
#line 478
  return ((char *)((void *)0));
}
}
#line 495 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/scan_devices.c"
static int verify_SG_version___0(cdrom_drive *d___0 , int messagedest , char **messages ) 
{ 
  int version ;
  int major ;
  int minor ;
  char buffer[256] ;
  int tmp ;

  {
  {
#line 500
  idmessage___0(messagedest, messages, "\nFound an accessible SCSI CDROM drive.\nLooking at revision of the SG interface in use...",
                "");
#line 504
  tmp = ioctl(d___0->cdda_fd, 8834UL, & version);
  }
#line 504
  if (tmp) {
    {
#line 506
    idmessage___0(messagedest, messages, "\tOOPS!  Old 2.0/early 2.1/early 2.2.x (non-ac patch) style SG.\n\tCdparanoia no longer supports the old interface.\n",
                  "");
    }
#line 509
    return (0);
  }
  {
#line 511
  major = version / 10000;
#line 512
  version -= major * 10000;
#line 513
  minor = version / 100;
#line 514
  version -= minor * 100;
#line 516
  sprintf((char */* __restrict  */)(buffer), (char const   */* __restrict  */)"\tSG interface version %d.%d.%d; OK.",
          major, minor, version);
#line 519
  idmessage___0(messagedest, messages, (char const   *)(buffer), "");
  }
#line 520
  return (major);
}
}
#line 48 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/paranoia/isort.h"
void sort_unsortall(sort_info *i ) ;
#line 63
void sort_setup(sort_info *i , int16_t *vector , long *abspos , long size , long sortlo ,
                long sorthi ) ;
#line 71
void sort_free(sort_info *i ) ;
#line 84
sort_link *sort_getmatch(sort_info *i , long post , long overlap___0 , int value ) ;
#line 95
sort_link *sort_nextmatch(sort_info *i , sort_link *prev ) ;
#line 36 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/paranoia/isort.c"
sort_info *sort_alloc(long size ) 
{ 
  sort_info *ret ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;

  {
  {
#line 37
  tmp = calloc((size_t )1, sizeof(sort_info ));
#line 37
  ret = (sort_info *)tmp;
#line 39
  ret->vector = (int16_t *)((void *)0);
#line 40
  ret->sortbegin = -1L;
#line 41
  ret->size = -1L;
#line 42
  ret->maxsize = size;
#line 44
  tmp___0 = calloc((size_t )65536, sizeof(sort_link *));
#line 44
  ret->head = (sort_link **)tmp___0;
#line 45
  tmp___1 = malloc(65536UL * sizeof(long ));
#line 45
  ret->bucketusage = (long *)tmp___1;
#line 46
  tmp___2 = calloc((size_t )size, sizeof(sort_link ));
#line 46
  ret->revindex = (sort_link *)tmp___2;
#line 47
  ret->lastbucket = 0L;
  }
#line 49
  return (ret);
}
}
#line 60 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/paranoia/isort.c"
void sort_unsortall(sort_info *i ) 
{ 
  long b ;

  {
#line 67
  if (i->lastbucket > 2000L) {
    {
#line 68
    memset((void *)i->head, 0, 65536UL * sizeof(sort_link *));
    }
  } else {
#line 71
    b = 0L;
    {
#line 71
    while (1) {
      while_continue: /* CIL Label */ ;
#line 71
      if (! (b < i->lastbucket)) {
#line 71
        goto while_break;
      }
#line 72
      *(i->head + *(i->bucketusage + b)) = (sort_link *)((void *)0);
#line 71
      b ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 75
  i->lastbucket = 0L;
#line 76
  i->sortbegin = -1L;
#line 82
  return;
}
}
#line 91 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/paranoia/isort.c"
void sort_free(sort_info *i ) 
{ 


  {
  {
#line 92
  free((void *)i->revindex);
#line 93
  free((void *)i->head);
#line 94
  free((void *)i->bucketusage);
#line 95
  free((void *)i);
  }
#line 96
  return;
}
}
#line 107 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/paranoia/isort.c"
static void sort_sort(sort_info *i , long sortlo , long sorthi ) 
{ 
  long j ;
  sort_link **hv ;
  sort_link *l ;

  {
#line 114
  j = sorthi - 1L;
  {
#line 114
  while (1) {
    while_continue: /* CIL Label */ ;
#line 114
    if (! (j >= sortlo)) {
#line 114
      goto while_break;
    }
#line 127
    hv = (i->head + (int )*(i->vector + j)) + 32768;
#line 128
    l = i->revindex + j;
#line 134
    if ((unsigned long )*hv == (unsigned long )((void *)0)) {
#line 135
      *(i->bucketusage + i->lastbucket) = (long )((int )*(i->vector + j) + 32768);
#line 136
      (i->lastbucket) ++;
    }
#line 142
    l->next = *hv;
#line 143
    *hv = l;
#line 114
    j --;
  }
  while_break: /* CIL Label */ ;
  }
#line 148
  i->sortbegin = 0L;
#line 149
  return;
}
}
#line 166 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/paranoia/isort.c"
void sort_setup(sort_info *i , int16_t *vector , long *abspos , long size , long sortlo ,
                long sorthi ) 
{ 
  long tmp___0 ;
  long tmp___1 ;
  long tmp___3 ;
  long tmp___4 ;

  {
#line 170
  if (i->sortbegin != -1L) {
    {
#line 170
    sort_unsortall(i);
    }
  }
#line 172
  i->vector = vector;
#line 173
  i->size = size;
#line 174
  i->abspos = abspos;
#line 180
  if (sortlo - *abspos < 0L) {
#line 180
    tmp___1 = 0L;
  } else {
#line 180
    tmp___1 = sortlo - *abspos;
  }
#line 180
  if (size > tmp___1) {
#line 180
    if (sortlo - *abspos < 0L) {
#line 180
      tmp___0 = 0L;
    } else {
#line 180
      tmp___0 = sortlo - *abspos;
    }
#line 180
    i->lo = tmp___0;
  } else {
#line 180
    i->lo = size;
  }
#line 181
  if (sorthi - *abspos > size) {
#line 181
    tmp___4 = size;
  } else {
#line 181
    tmp___4 = sorthi - *abspos;
  }
#line 181
  if (0L < tmp___4) {
#line 181
    if (sorthi - *abspos > size) {
#line 181
      tmp___3 = size;
    } else {
#line 181
      tmp___3 = sorthi - *abspos;
    }
#line 181
    i->hi = tmp___3;
  } else {
#line 181
    i->hi = 0L;
  }
#line 182
  return;
}
}
#line 196 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/paranoia/isort.c"
sort_link *sort_getmatch(sort_info *i , long post , long overlap___0 , int value ) 
{ 
  sort_link *ret ;
  long tmp___0 ;
  long tmp___1 ;

  {
#line 201
  if (i->sortbegin == -1L) {
    {
#line 201
    sort_sort(i, i->lo, i->hi);
    }
  }
#line 211
  if (i->size > post) {
#line 211
    tmp___1 = post;
  } else {
#line 211
    tmp___1 = i->size;
  }
#line 211
  if (0L < tmp___1) {
#line 211
    if (i->size > post) {
#line 211
      tmp___0 = post;
    } else {
#line 211
      tmp___0 = i->size;
    }
#line 211
    post = tmp___0;
  } else {
#line 211
    post = 0L;
  }
#line 212
  i->val = value + 32768;
#line 213
  if (0L < post - overlap___0) {
#line 213
    i->lo = post - overlap___0;
  } else {
#line 213
    i->lo = 0L;
  }
#line 214
  if (i->size > post + overlap___0) {
#line 214
    i->hi = post + overlap___0;
  } else {
#line 214
    i->hi = i->size;
  }
#line 220
  ret = *(i->head + i->val);
  {
#line 222
  while (1) {
    while_continue: /* CIL Label */ ;
#line 222
    if (! ret) {
#line 222
      goto while_break;
    }
#line 227
    if (ret - i->revindex < i->lo) {
#line 228
      ret = ret->next;
    } else {
#line 230
      if (ret - i->revindex >= i->hi) {
#line 231
        ret = (sort_link *)((void *)0);
      }
#line 232
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 236
  return (ret);
}
}
#line 250 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/paranoia/isort.c"
sort_link *sort_nextmatch(sort_info *i , sort_link *prev ) 
{ 
  sort_link *ret ;

  {
#line 251
  ret = prev->next;
#line 256
  if (! ret) {
#line 256
    return ((sort_link *)((void *)0));
  } else
#line 256
  if (ret - i->revindex >= i->hi) {
#line 256
    return ((sort_link *)((void *)0));
  }
#line 258
  return (ret);
}
}
#line 106 "/usr/include/x86_64-linux-gnu/sys/select.h"
extern int select(int __nfds , fd_set * __restrict  __readfds , fd_set * __restrict  __writefds ,
                  fd_set * __restrict  __exceptfds , struct timeval * __restrict  __timeout ) ;
#line 543 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 564
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) getenv)(char const   *__name ) ;
#line 360 "/usr/include/unistd.h"
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 248 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sigprocmask)(int __how ,
                                                                                  sigset_t const   * __restrict  __set ,
                                                                                  sigset_t * __restrict  __oset ) ;
#line 163 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/cdda_interface.h"
static char *strerror_tr[12]  = 
#line 163 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/cdda_interface.h"
  {      (char *)"Success",      (char *)"Error writing packet command to device",      (char *)"Error reading command from device",      (char *)"SCSI packet data underrun (too little data)", 
        (char *)"SCSI packet data overrun (too much data)",      (char *)"Illegal SCSI request (rejected by target)",      (char *)"Medium reading data from medium",      (char *)"Device busy", 
        (char *)"Device not ready",      (char *)"Target hardware fault",      (char *)"Unspecified error",      (char *)"Drive lost streaming"};
#line 139 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/low_interface.h"
int scsi_init_drive(cdrom_drive *d___0 ) ;
#line 21 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/utils.h"
__inline static int32_t swap32(int32_t x ) 
{ 


  {
#line 22
  return ((int32_t )((((((u_int32_t )x & 255U) << 24) | (((u_int32_t )x & 65280U) << 8)) | (((u_int32_t )x & 16711680U) >> 8)) | (((u_int32_t )x & 4278190080U) >> 24)));
}
}
#line 35 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/utils.h"
__inline static int32_t be32_to_cpu(int32_t x ) 
{ 
  int32_t tmp ;

  {
  {
#line 36
  tmp = swap32(x);
  }
#line 36
  return (tmp);
}
}
#line 109 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/utils.h"
static void cderror___1(cdrom_drive *d___0 , char const   *s ) 
{ 
  size_t tmp ;

  {
#line 110
  if (s) {
#line 110
    if (d___0) {
      {
#line 112
      if (d___0->errordest == 1) {
#line 112
        goto case_1;
      }
#line 115
      if (d___0->errordest == 2) {
#line 115
        goto case_2;
      }
#line 119
      goto switch_default;
      case_1: /* CIL Label */ 
      {
#line 113
      tmp = strlen(s);
#line 113
      write(2, (void const   *)s, tmp);
      }
#line 114
      goto switch_break;
      case_2: /* CIL Label */ 
      {
#line 116
      d___0->errorbuf = catstring(d___0->errorbuf, s);
      }
#line 117
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 120
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
  }
#line 123
  return;
}
}
#line 125 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/utils.h"
static void cdmessage___2(cdrom_drive *d___0 , char const   *s ) 
{ 
  size_t tmp ;

  {
#line 126
  if (s) {
#line 126
    if (d___0) {
      {
#line 128
      if (d___0->messagedest == 1) {
#line 128
        goto case_1;
      }
#line 131
      if (d___0->messagedest == 2) {
#line 131
        goto case_2;
      }
#line 135
      goto switch_default;
      case_1: /* CIL Label */ 
      {
#line 129
      tmp = strlen(s);
#line 129
      write(2, (void const   *)s, tmp);
      }
#line 130
      goto switch_break;
      case_2: /* CIL Label */ 
      {
#line 132
      d___0->messagebuf = catstring(d___0->messagebuf, s);
      }
#line 133
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 136
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
  }
#line 139
  return;
}
}
#line 20 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
static int timed_ioctl___1(cdrom_drive *d___0 , int fd , int command , void *arg ) 
{ 
  struct timespec tv1 ;
  struct timespec tv2 ;
  int ret1 ;
  int tmp ;
  int ret2 ;
  int tmp___0 ;
  int ret3 ;
  int tmp___1 ;

  {
  {
#line 23
  tmp = clock_gettime((d___0->private_data)->clock, & tv1);
#line 23
  ret1 = tmp;
#line 24
  tmp___0 = ioctl(fd, (unsigned long )command, arg);
#line 24
  ret2 = tmp___0;
#line 25
  tmp___1 = clock_gettime((d___0->private_data)->clock, & tv2);
#line 25
  ret3 = tmp___1;
  }
#line 26
  if (ret1 < 0) {
#line 27
    (d___0->private_data)->last_milliseconds = -1;
  } else
#line 26
  if (ret3 < 0) {
#line 27
    (d___0->private_data)->last_milliseconds = -1;
  } else {
#line 29
    (d___0->private_data)->last_milliseconds = (int )((double )(tv2.tv_sec - tv1.tv_sec) * 1000. + (double )(tv2.tv_nsec - tv1.tv_nsec) / 1000000.);
  }
#line 31
  return (ret2);
}
}
#line 35 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
static int Dummy___1(cdrom_drive *d___0 , int s ) 
{ 


  {
#line 36
  return (0);
}
}
#line 1 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/drive_exceptions.h"
int scsi_enable_cdda(cdrom_drive *d___0 , int fAudioMode ) ;
#line 2
long scsi_read_mmc(cdrom_drive *d___0 , void *p___0 , long begin , long sectors ) ;
#line 4
long scsi_read_D4_10(cdrom_drive *d___0 , void *p___0 , long begin , long sectors ) ;
#line 5
long scsi_read_D4_12(cdrom_drive *d___0 , void *p___0 , long begin , long sectors ) ;
#line 6
long scsi_read_D8(cdrom_drive *d___0 , void *p___0 , long begin , long sectors ) ;
#line 7
long scsi_read_28(cdrom_drive *d___0 , void *p___0 , long begin , long sectors ) ;
#line 8
long scsi_read_A8(cdrom_drive *d___0 , void *p___0 , long begin , long sectors ) ;
#line 24 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/drive_exceptions.h"
static exception atapi_list___1[5]  = {      {(char *)"SAMSUNG SCR-830 REV 2.09 2.09 ", 1, (unsigned char)0, & Dummy___1,
      & scsi_read_mmc2, 0}, 
        {(char *)"Memorex CR-622", 1, (unsigned char)0, & Dummy___1, (long (*)(struct cdrom_drive * ,
                                                                            void * ,
                                                                            long  ,
                                                                            long  ))((void *)0),
      0}, 
        {(char *)"SONY CD-ROM CDU-561", 0, (unsigned char)0, & Dummy___1, (long (*)(struct cdrom_drive * ,
                                                                                 void * ,
                                                                                 long  ,
                                                                                 long  ))((void *)0),
      0}, 
        {(char *)"Chinon CD-ROM CDS-525", 0, (unsigned char)0, & Dummy___1, (long (*)(struct cdrom_drive * ,
                                                                                   void * ,
                                                                                   long  ,
                                                                                   long  ))((void *)0),
      0}, 
        {(char *)((void *)0), 0, (unsigned char)0, (int (*)(struct cdrom_drive * , int  ))((void *)0),
      (long (*)(struct cdrom_drive * , void * , long  , long  ))((void *)0), 0}};
#line 33 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/drive_exceptions.h"
static exception mmc_list[6]  = {      {(char *)"SAMSUNG SCR-830 REV 2.09 2.09 ", 1, (unsigned char)0, & Dummy___1,
      & scsi_read_mmc2, 0}, 
        {(char *)"Memorex CR-622", 1, (unsigned char)0, & Dummy___1, (long (*)(struct cdrom_drive * ,
                                                                            void * ,
                                                                            long  ,
                                                                            long  ))((void *)0),
      0}, 
        {(char *)"SONY CD-ROM CDU-561", 0, (unsigned char)0, & Dummy___1, (long (*)(struct cdrom_drive * ,
                                                                                 void * ,
                                                                                 long  ,
                                                                                 long  ))((void *)0),
      0}, 
        {(char *)"Chinon CD-ROM CDS-525", 0, (unsigned char)0, & Dummy___1, (long (*)(struct cdrom_drive * ,
                                                                                   void * ,
                                                                                   long  ,
                                                                                   long  ))((void *)0),
      0}, 
        {(char *)"KENWOOD CD-ROM UCR", -1, (unsigned char)0, (int (*)(struct cdrom_drive * ,
                                                                   int  ))((void *)0),
      & scsi_read_D8, 0}, 
        {(char *)((void *)0), 0, (unsigned char)0, (int (*)(struct cdrom_drive * , int  ))((void *)0),
      (long (*)(struct cdrom_drive * , void * , long  , long  ))((void *)0), 0}};
#line 43 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/drive_exceptions.h"
static exception scsi_list[18]  = 
#line 43
  {      {(char *)"TOSHIBA", -1, (unsigned char)130, & scsi_enable_cdda, & scsi_read_28,
      0}, 
        {(char *)"IBM", -1, (unsigned char)130, & scsi_enable_cdda, & scsi_read_28, 0}, 
        {(char *)"DEC",
      -1, (unsigned char)130, & scsi_enable_cdda, & scsi_read_28, 0}, 
        {(char *)"IMS", -1, (unsigned char)0, & scsi_enable_cdda, & scsi_read_28, 1}, 
        {(char *)"KODAK",
      -1, (unsigned char)0, & scsi_enable_cdda, & scsi_read_28, 1}, 
        {(char *)"RICOH", -1, (unsigned char)0, & scsi_enable_cdda, & scsi_read_28, 1}, 
        {(char *)"HP",
      -1, (unsigned char)0, & scsi_enable_cdda, & scsi_read_28, 1}, 
        {(char *)"PHILIPS", -1, (unsigned char)0, & scsi_enable_cdda, & scsi_read_28,
      1}, 
        {(char *)"PLASMON", -1, (unsigned char)0, & scsi_enable_cdda, & scsi_read_28,
      1}, 
        {(char *)"GRUNDIG CDR100IPW", -1, (unsigned char)0, & scsi_enable_cdda, & scsi_read_28,
      1}, 
        {(char *)"MITSUMI CD-R ", -1, (unsigned char)0, & scsi_enable_cdda, & scsi_read_28,
      1}, 
        {(char *)"KENWOOD CD-ROM UCR", -1, (unsigned char)0, (int (*)(struct cdrom_drive * ,
                                                                   int  ))((void *)0),
      & scsi_read_D8, 0}, 
        {(char *)"YAMAHA", -1, (unsigned char)0, & scsi_enable_cdda, (long (*)(struct cdrom_drive * ,
                                                                            void * ,
                                                                            long  ,
                                                                            long  ))((void *)0),
      0}, 
        {(char *)"PLEXTOR", -1, (unsigned char)0, (int (*)(struct cdrom_drive * , int  ))((void *)0),
      (long (*)(struct cdrom_drive * , void * , long  , long  ))((void *)0), 0}, 
        {(char *)"SONY", -1, (unsigned char)0, (int (*)(struct cdrom_drive * , int  ))((void *)0),
      (long (*)(struct cdrom_drive * , void * , long  , long  ))((void *)0), 0}, 
        {(char *)"NEC", -1, (unsigned char)0, (int (*)(struct cdrom_drive * , int  ))((void *)0),
      & scsi_read_D4_10, 0}, 
        {(char *)"MATSHITA CD-R   CW-7501", -1, (unsigned char)0, (int (*)(struct cdrom_drive * ,
                                                                        int  ))((void *)0),
      & scsi_read_D4_12, -1}, 
        {(char *)((void *)0), 0, (unsigned char)0, (int (*)(struct cdrom_drive * , int  ))((void *)0),
      (long (*)(struct cdrom_drive * , void * , long  , long  ))((void *)0), 0}};
#line 40 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
static void tweak_SG_buffer(cdrom_drive *d___0 ) 
{ 
  int table ;
  int reserved ;
  int cur ;
  int err ;
  char buffer[256] ;
  int tmp ;
  char *tmp___0 ;

  {
#line 52
  cur = 1;
  {
#line 53
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 54
    cur <<= 1;
#line 54
    reserved = cur * (1 << 9);
#line 55
    err = ioctl(d___0->cdda_fd, 8821UL, & reserved);
    }
#line 53
    if (err >= 0) {
#line 53
      if (! (cur * (1 << 9) < 1073741824)) {
#line 53
        goto while_break;
      }
    } else {
#line 53
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 57
  ioctl(d___0->cdda_fd, 8818UL, & reserved);
#line 61
  tmp = ioctl(d___0->cdda_fd, 8831UL, & table);
  }
#line 61
  if (tmp < 0) {
#line 62
    table = 1;
  }
  {
#line 64
  sprintf((char */* __restrict  */)(buffer), (char const   */* __restrict  */)"\tDMA scatter/gather table entries: %d\n\ttable entry size: %d bytes\n\tmaximum theoretical transfer: %d sectors\n",
          table, reserved, table * (reserved / 2352));
#line 69
  cdmessage___2(d___0, (char const   *)(buffer));
#line 71
  cur = reserved;
#line 85
  tmp___0 = getenv("CDDA_IGNORE_BUFSIZE_LIMIT");
  }
#line 85
  if (tmp___0) {
    {
#line 88
    cdmessage___2(d___0, "\tEnvironment variable CDDA_IGNORE_BUFSIZE_LIMIT set,\n\t\tforcing maximum possible sector size.  This can break\n\t\tspectacularly; use with caution!\n");
    }
  } else
#line 86
  if (cur > 65536) {
#line 86
    cur = 65536;
  } else {
#line 86
    cur = cur;
  }
  {
#line 92
  d___0->nsectors = cur / 2352;
#line 93
  d___0->bigbuff = (long )cur;
#line 95
  sprintf((char */* __restrict  */)(buffer), (char const   */* __restrict  */)"\tSetting default read size to %d sectors (%d bytes).\n\n",
          d___0->nsectors, d___0->nsectors * 2352);
  }
#line 98
  if (cur == 0) {
    {
#line 98
    exit(1);
    }
  }
  {
#line 108
  cdmessage___2(d___0, (char const   *)(buffer));
  }
#line 109
  return;
}
}
#line 113 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
static void clear_garbage(cdrom_drive *d___0 ) 
{ 
  fd_set fdset ;
  struct timeval tv ;
  struct sg_header *sg_hd ;
  int flag ;
  int __d0 ;
  int __d1 ;
  int __d0___0 ;
  int __d1___0 ;
  int tmp ;

  {
#line 116
  sg_hd = (d___0->private_data)->sg_hd;
#line 117
  flag = 0;
  {
#line 120
  while (1) {
    while_continue: /* CIL Label */ ;
#line 120
    __asm__  volatile   ("cld; rep; "
                         "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                         "1" (& fdset.__fds_bits[0]): "memory");
#line 120
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 121
  fdset.__fds_bits[d___0->cdda_fd / (8 * (int )sizeof(__fd_mask ))] |= 1L << d___0->cdda_fd % (8 * (int )sizeof(__fd_mask ));
#line 122
  tv.tv_sec = (__time_t )0;
#line 123
  tv.tv_usec = (__suseconds_t )0;
  {
#line 126
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 126
    tmp = select(d___0->cdda_fd + 1, (fd_set */* __restrict  */)(& fdset), (fd_set */* __restrict  */)((void *)0),
                 (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)(& tv));
    }
#line 126
    if (! (tmp == 1)) {
#line 126
      goto while_break___0;
    }
    {
#line 128
    sg_hd->twelve_byte = 0U;
#line 129
    sg_hd->result = 0;
#line 130
    sg_hd->reply_len = (int )sizeof(struct sg_header );
#line 131
    read(d___0->cdda_fd, (void *)sg_hd, (size_t )1);
    }
    {
#line 134
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 134
      __asm__  volatile   ("cld; rep; "
                           "stosq": "=c" (__d0___0), "=D" (__d1___0): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                           "1" (& fdset.__fds_bits[0]): "memory");
#line 134
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 135
    fdset.__fds_bits[d___0->cdda_fd / (8 * (int )sizeof(__fd_mask ))] |= 1L << d___0->cdda_fd % (8 * (int )sizeof(__fd_mask ));
#line 136
    tv.tv_sec = (__time_t )0;
#line 137
    tv.tv_usec = (__suseconds_t )0;
#line 138
    if (! flag) {
#line 138
      if (d___0->report_all) {
        {
#line 139
        cdmessage___2(d___0, "Clearing previously returned data from SCSI buffer\n");
        }
      }
    }
#line 140
    flag = 1;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 142
  return;
}
}
#line 145 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
static int check_sbp_error(unsigned char const   status , unsigned char const   *sbp ) 
{ 
  char key ;
  char ASC ;
  char ASCQ ;
  int *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  int *tmp___5 ;
  int *tmp___6 ;
  int *tmp___7 ;
  int *tmp___8 ;
  int *tmp___9 ;
  int *tmp___10 ;
  int *tmp___11 ;

  {
#line 147
  key = (char )((int const   )*(sbp + 2) & 15);
#line 148
  ASC = (char )*(sbp + 12);
#line 149
  ASCQ = (char )*(sbp + 13);
#line 151
  if ((int const   )status == 0) {
#line 151
    return (0);
  }
#line 152
  if ((int const   )status == 8) {
#line 152
    return (7);
  }
#line 154
  if (*(sbp + 0)) {
    {
#line 156
    if ((int )key == 0) {
#line 156
      goto case_0;
    }
#line 160
    if ((int )key == 1) {
#line 160
      goto case_1;
    }
#line 162
    if ((int )key == 2) {
#line 162
      goto case_2;
    }
#line 169
    if ((int )key == 3) {
#line 169
      goto case_3;
    }
#line 180
    if ((int )key == 4) {
#line 180
      goto case_4;
    }
#line 184
    if ((int )key == 5) {
#line 184
      goto case_5;
    }
#line 188
    goto switch_default;
    case_0: /* CIL Label */ 
    {
#line 157
    tmp___0 = __errno_location();
    }
#line 157
    if (*tmp___0 == 0) {
      {
#line 158
      tmp = __errno_location();
#line 158
      *tmp = 5;
      }
    }
#line 159
    return (10);
    case_1: /* CIL Label */ 
#line 161
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 164
    tmp___1 = __errno_location();
#line 164
    *tmp___1 = 123;
    }
#line 168
    return (8);
    case_3: /* CIL Label */ 
#line 170
    if (((int )ASC == 12) & ((int )ASCQ == 9)) {
      {
#line 172
      tmp___3 = __errno_location();
      }
#line 172
      if (*tmp___3 == 0) {
        {
#line 173
        tmp___2 = __errno_location();
#line 173
        *tmp___2 = 5;
        }
      }
#line 174
      return (11);
    } else {
      {
#line 176
      tmp___5 = __errno_location();
      }
#line 176
      if (*tmp___5 == 0) {
        {
#line 177
        tmp___4 = __errno_location();
#line 177
        *tmp___4 = 5;
        }
      }
#line 178
      return (6);
    }
    case_4: /* CIL Label */ 
    {
#line 181
    tmp___7 = __errno_location();
    }
#line 181
    if (*tmp___7 == 0) {
      {
#line 182
      tmp___6 = __errno_location();
#line 182
      *tmp___6 = 5;
      }
    }
#line 183
    return (9);
    case_5: /* CIL Label */ 
    {
#line 185
    tmp___9 = __errno_location();
    }
#line 185
    if (*tmp___9 == 0) {
      {
#line 186
      tmp___8 = __errno_location();
#line 186
      *tmp___8 = 22;
      }
    }
#line 187
    return (5);
    switch_default: /* CIL Label */ 
    {
#line 189
    tmp___11 = __errno_location();
    }
#line 189
    if (*tmp___11 == 0) {
      {
#line 190
      tmp___10 = __errno_location();
#line 190
      *tmp___10 = 5;
      }
    }
#line 191
    return (10);
    switch_break: /* CIL Label */ ;
    }
  }
#line 194
  return (0);
}
}
#line 199 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
static int sg2_handle_scsi_cmd(cdrom_drive *d___0 , unsigned char *cmd , unsigned int cmd_len ,
                               unsigned int in_size , unsigned int out_size , unsigned char bytefill ,
                               int bytecheck , unsigned char *sense_buffer ) 
{ 
  struct timespec tv1 ;
  struct timespec tv2 ;
  int tret1 ;
  int tret2 ;
  int status ;
  struct sg_header *sg_hd ;
  long writebytes ;
  fd_set fdset ;
  struct timeval tv ;
  int __d0 ;
  int __d1 ;
  int ret ;
  int tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  ssize_t tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  fd_set rset ;
  struct timeval tv___0 ;
  int __d0___0 ;
  int __d1___0 ;
  int ret___0 ;
  int tmp___5 ;
  int *tmp___6 ;
  int *tmp___7 ;
  ssize_t tmp___8 ;
  int *tmp___9 ;
  int *tmp___10 ;
  long i ;
  long flag ;
  int *tmp___11 ;
  int *tmp___12 ;

  {
  {
#line 210
  status = 0;
#line 211
  sg_hd = (d___0->private_data)->sg_hd;
#line 212
  writebytes = (long )((sizeof(struct sg_header ) + (unsigned long )cmd_len) + (unsigned long )in_size);
#line 217
  clear_garbage(d___0);
#line 219
  memset((void *)sg_hd, 0, sizeof(sg_hd));
#line 220
  memset((void *)sense_buffer, 0, (size_t )16);
#line 221
  memcpy((void */* __restrict  */)(d___0->private_data)->sg_buffer, (void const   */* __restrict  */)cmd,
         (size_t )(cmd_len + in_size));
#line 222
  sg_hd->twelve_byte = (unsigned int )(cmd_len == 12U);
#line 223
  sg_hd->result = 0;
#line 224
  sg_hd->reply_len = (int )(sizeof(struct sg_header ) + (unsigned long )out_size);
  }
#line 234
  if (bytecheck) {
#line 234
    if (out_size > in_size) {
      {
#line 235
      memset((void *)(((d___0->private_data)->sg_buffer + cmd_len) + in_size), (int )bytefill,
             (size_t )(out_size - in_size));
#line 238
      writebytes += (long )(out_size - in_size);
      }
    }
  }
  {
#line 249
  while (1) {
    while_continue: /* CIL Label */ ;
#line 249
    __asm__  volatile   ("cld; rep; "
                         "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                         "1" (& fdset.__fds_bits[0]): "memory");
#line 249
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 250
  fdset.__fds_bits[d___0->cdda_fd / (8 * (int )sizeof(__fd_mask ))] |= 1L << d___0->cdda_fd % (8 * (int )sizeof(__fd_mask ));
#line 251
  tv.tv_sec = (__time_t )60;
#line 254
  tv.tv_usec = (__suseconds_t )0;
  {
#line 256
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 257
    tmp = select(d___0->cdda_fd + 1, (fd_set */* __restrict  */)((void *)0), (fd_set */* __restrict  */)(& fdset),
                 (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)(& tv));
#line 257
    ret = tmp;
    }
#line 258
    if (ret > 0) {
#line 258
      goto while_break___0;
    }
#line 259
    if (ret < 0) {
      {
#line 259
      tmp___0 = __errno_location();
      }
#line 259
      if (*tmp___0 != 4) {
#line 259
        goto while_break___0;
      }
    }
#line 260
    if (ret == 0) {
      {
#line 261
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\nSCSI transport error: timeout waiting to write packet\n\n");
      }
#line 263
      return (1);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 268
  sigprocmask(0, (sigset_t const   */* __restrict  */)(& d___0->sigset), (sigset_t */* __restrict  */)((void *)0));
#line 269
  tret1 = clock_gettime((d___0->private_data)->clock, & tv1);
#line 270
  tmp___1 = __errno_location();
#line 270
  *tmp___1 = 0;
#line 271
  tmp___2 = write(d___0->cdda_fd, (void const   *)sg_hd, (size_t )writebytes);
#line 271
  status = (int )tmp___2;
  }
#line 273
  if (status < 0) {
#line 273
    goto _L;
  } else
#line 273
  if ((long )status != writebytes) {
    _L: /* CIL Label */ 
    {
#line 274
    sigprocmask(1, (sigset_t const   */* __restrict  */)(& d___0->sigset), (sigset_t */* __restrict  */)((void *)0));
#line 275
    tmp___4 = __errno_location();
    }
#line 275
    if (*tmp___4 == 0) {
      {
#line 275
      tmp___3 = __errno_location();
#line 275
      *tmp___3 = 5;
      }
    }
#line 276
    return (1);
  }
  {
#line 289
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 289
    __asm__  volatile   ("cld; rep; "
                         "stosq": "=c" (__d0___0), "=D" (__d1___0): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                         "1" (& rset.__fds_bits[0]): "memory");
#line 289
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 290
  rset.__fds_bits[d___0->cdda_fd / (8 * (int )sizeof(__fd_mask ))] |= 1L << d___0->cdda_fd % (8 * (int )sizeof(__fd_mask ));
#line 291
  tv___0.tv_sec = (__time_t )60;
#line 294
  tv___0.tv_usec = (__suseconds_t )0;
  {
#line 296
  while (1) {
    while_continue___2: /* CIL Label */ ;
    {
#line 297
    tmp___5 = select(d___0->cdda_fd + 1, (fd_set */* __restrict  */)(& rset), (fd_set */* __restrict  */)((void *)0),
                     (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)(& tv___0));
#line 297
    ret___0 = tmp___5;
    }
#line 298
    if (ret___0 < 0) {
      {
#line 298
      tmp___6 = __errno_location();
      }
#line 298
      if (*tmp___6 != 4) {
#line 298
        goto while_break___2;
      }
    }
#line 299
    if (ret___0 == 0) {
      {
#line 300
      sigprocmask(1, (sigset_t const   */* __restrict  */)(& d___0->sigset), (sigset_t */* __restrict  */)((void *)0));
#line 301
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\nSCSI transport error: timeout waiting to read packet\n\n");
      }
#line 303
      return (2);
    }
#line 305
    if (ret___0 > 0) {
#line 307
      if ((rset.__fds_bits[d___0->cdda_fd / (8 * (int )sizeof(__fd_mask ))] & (1L << d___0->cdda_fd % (8 * (int )sizeof(__fd_mask )))) != 0L) {
#line 307
        goto while_break___2;
      }
      {
#line 308
      sigprocmask(1, (sigset_t const   */* __restrict  */)(& d___0->sigset), (sigset_t */* __restrict  */)((void *)0));
#line 309
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\nSCSI transport: error reading packet\n\n");
      }
#line 310
      return (2);
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 315
  tret2 = clock_gettime((d___0->private_data)->clock, & tv2);
#line 316
  tmp___7 = __errno_location();
#line 316
  *tmp___7 = 0;
#line 317
  tmp___8 = read(d___0->cdda_fd, (void *)sg_hd, sizeof(struct sg_header ) + (unsigned long )out_size);
#line 317
  status = (int )tmp___8;
#line 318
  sigprocmask(1, (sigset_t const   */* __restrict  */)(& d___0->sigset), (sigset_t */* __restrict  */)((void *)0));
#line 319
  memcpy((void */* __restrict  */)sense_buffer, (void const   */* __restrict  */)(sg_hd->sense_buffer),
         (size_t )16);
  }
#line 321
  if (status < 0) {
#line 321
    return (status);
  }
#line 323
  if ((unsigned long )status != sizeof(struct sg_header ) + (unsigned long )out_size) {
#line 323
    goto _L___0;
  } else
#line 323
  if (sg_hd->result) {
    _L___0: /* CIL Label */ 
    {
#line 324
    tmp___10 = __errno_location();
    }
#line 324
    if (*tmp___10 == 0) {
      {
#line 324
      tmp___9 = __errno_location();
#line 324
      *tmp___9 = 5;
      }
    }
#line 325
    return (2);
  }
  {
#line 328
  status = check_sbp_error((unsigned char const   )sg_hd->target_status, (unsigned char const   *)sense_buffer);
  }
#line 329
  if (status) {
#line 329
    return (status);
  }
#line 336
  if (bytecheck) {
#line 336
    if (in_size + cmd_len < out_size) {
#line 337
      flag = 0L;
#line 338
      i = (long )in_size;
      {
#line 338
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 338
        if (! (i < (long )out_size)) {
#line 338
          goto while_break___3;
        }
#line 339
        if ((int )*((d___0->private_data)->sg_buffer + i) != (int )bytefill) {
#line 340
          flag = 1L;
#line 341
          goto while_break___3;
        }
#line 338
        i ++;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 344
      if (! flag) {
        {
#line 345
        tmp___11 = __errno_location();
#line 345
        *tmp___11 = 22;
        }
#line 346
        return (5);
      }
    }
  }
  {
#line 350
  tmp___12 = __errno_location();
#line 350
  *tmp___12 = 0;
  }
#line 351
  if (tret1 < 0) {
#line 352
    (d___0->private_data)->last_milliseconds = -1;
  } else
#line 351
  if (tret2 < 0) {
#line 352
    (d___0->private_data)->last_milliseconds = -1;
  } else {
#line 354
    (d___0->private_data)->last_milliseconds = (int )((tv2.tv_sec - tv1.tv_sec) * 1000L + (tv2.tv_nsec - tv1.tv_nsec) / 1000000L);
  }
#line 356
  return (0);
}
}
#line 359 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
static int sgio_handle_scsi_cmd(cdrom_drive *d___0 , unsigned char *cmd , unsigned int cmd_len ,
                                unsigned int in_size , unsigned int out_size , unsigned char bytefill ,
                                int bytecheck , unsigned char *sense ) 
{ 
  int status ;
  struct sg_io_hdr hdr ;
  int *tmp ;
  int *tmp___0 ;
  long i ;
  long flag ;
  int *tmp___1 ;
  int *tmp___2 ;

  {
  {
#line 368
  status = 0;
#line 371
  memset((void *)(& hdr), 0, sizeof(hdr));
#line 372
  memset((void *)sense, 0, sizeof(sense));
#line 373
  memcpy((void */* __restrict  */)(d___0->private_data)->sg_buffer, (void const   */* __restrict  */)(cmd + cmd_len),
         (size_t )in_size);
#line 375
  hdr.cmdp = cmd;
#line 376
  hdr.cmd_len = (unsigned char )cmd_len;
#line 377
  hdr.sbp = sense;
#line 378
  hdr.mx_sb_len = (unsigned char)16;
#line 379
  hdr.timeout = 50000U;
#line 380
  hdr.interface_id = 'S';
#line 381
  hdr.dxferp = (void *)(d___0->private_data)->sg_buffer;
#line 382
  hdr.flags = 1U;
  }
#line 385
  if (bytecheck) {
#line 385
    if (out_size > in_size) {
      {
#line 386
      memset(hdr.dxferp + in_size, (int )bytefill, (size_t )(out_size - in_size));
      }
    }
  }
#line 388
  if (in_size) {
    {
#line 389
    hdr.dxfer_len = in_size;
#line 390
    hdr.dxfer_direction = -2;
#line 392
    tmp = __errno_location();
#line 392
    *tmp = 0;
#line 393
    status = ioctl(d___0->ioctl_fd, 8837UL, & hdr);
    }
#line 394
    if (status >= 0) {
#line 394
      if (hdr.status) {
        {
#line 395
        status = check_sbp_error((unsigned char const   )hdr.status, (unsigned char const   *)hdr.sbp);
        }
#line 396
        if (status) {
#line 396
          return (status);
        }
      }
    }
#line 398
    if (status < 0) {
#line 398
      return (1);
    }
  }
#line 401
  if ((unsigned int )(! in_size) | out_size) {
#line 402
    hdr.dxfer_len = out_size;
#line 404
    if (bytecheck) {
#line 404
      if (d___0->interface != 4) {
#line 405
        if (out_size) {
#line 405
          hdr.dxfer_direction = -4;
        } else {
#line 405
          hdr.dxfer_direction = -1;
        }
      } else {
#line 404
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 407
    if (out_size) {
#line 407
      hdr.dxfer_direction = -3;
    } else {
#line 407
      hdr.dxfer_direction = -1;
    }
    {
#line 409
    tmp___0 = __errno_location();
#line 409
    *tmp___0 = 0;
#line 410
    status = timed_ioctl___1(d___0, d___0->ioctl_fd, 8837, (void *)(& hdr));
    }
#line 411
    if (status >= 0) {
#line 411
      if (hdr.status) {
        {
#line 412
        status = check_sbp_error((unsigned char const   )hdr.status, (unsigned char const   *)hdr.sbp);
        }
#line 413
        if (status) {
#line 413
          return (status);
        }
      }
    }
#line 415
    if (status < 0) {
#line 415
      return (status);
    }
  }
#line 423
  if (bytecheck) {
#line 423
    if (in_size < out_size) {
#line 424
      flag = 0L;
#line 425
      i = (long )in_size;
      {
#line 425
      while (1) {
        while_continue: /* CIL Label */ ;
#line 425
        if (! (i < (long )out_size)) {
#line 425
          goto while_break;
        }
#line 426
        if ((int )*((d___0->private_data)->sg_buffer + i) != (int )bytefill) {
#line 427
          flag = 1L;
#line 428
          goto while_break;
        }
#line 425
        i ++;
      }
      while_break: /* CIL Label */ ;
      }
#line 431
      if (! flag) {
        {
#line 432
        tmp___1 = __errno_location();
#line 432
        *tmp___1 = 22;
        }
#line 433
        return (5);
      }
    }
  }
  {
#line 440
  tmp___2 = __errno_location();
#line 440
  *tmp___2 = 0;
  }
#line 441
  return (0);
}
}
#line 444 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
static int handle_scsi_cmd(cdrom_drive *d___0 , unsigned char *cmd , unsigned int cmd_len ,
                           unsigned int in_size , unsigned int out_size , unsigned char bytefill ,
                           int bytecheck , unsigned char *sense ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 453
  if (d___0->interface == 3) {
    {
#line 454
    tmp = sgio_handle_scsi_cmd(d___0, cmd, cmd_len, in_size, out_size, bytefill, bytecheck,
                               sense);
    }
#line 454
    return (tmp);
  } else
#line 453
  if (d___0->interface == 4) {
    {
#line 454
    tmp = sgio_handle_scsi_cmd(d___0, cmd, cmd_len, in_size, out_size, bytefill, bytecheck,
                               sense);
    }
#line 454
    return (tmp);
  }
  {
#line 455
  tmp___0 = sg2_handle_scsi_cmd(d___0, cmd, cmd_len, in_size, out_size, bytefill,
                                bytecheck, sense);
  }
#line 455
  return (tmp___0);
}
}
#line 544 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
static int test_unit_ready(cdrom_drive *d___0 ) 
{ 
  unsigned char sense[16] ;
  unsigned char key ;
  unsigned char ASC ;
  unsigned char ASCQ ;
  unsigned char cmd[6] ;

  {
  {
#line 547
  cmd[0] = (unsigned char)0;
#line 547
  cmd[1] = (unsigned char)0;
#line 547
  cmd[2] = (unsigned char)0;
#line 547
  cmd[3] = (unsigned char)0;
#line 547
  cmd[4] = (unsigned char)0;
#line 547
  cmd[5] = (unsigned char)0;
#line 554
  handle_scsi_cmd(d___0, cmd, 6U, 0U, 56U, (unsigned char)0, 0, sense);
#line 556
  key = (unsigned char )((int )*((d___0->private_data)->sg_buffer + 2) & 15);
#line 557
  ASC = *((d___0->private_data)->sg_buffer + 12);
#line 558
  ASCQ = *((d___0->private_data)->sg_buffer + 13);
  }
#line 560
  if ((int )key == 2) {
#line 560
    if ((int )ASC == 4) {
#line 560
      if ((int )ASCQ == 1) {
#line 560
        return (0);
      }
    }
  }
#line 561
  return (1);
}
}
#line 565 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
static void reset_scsi(cdrom_drive *d___0 ) 
{ 
  int arg ;
  int tries ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 566
  tries = 0;
#line 567
  (*(d___0->enable_cdda))(d___0, 0);
#line 569
  cdmessage___2(d___0, "sending SG SCSI reset... ");
#line 570
  tmp = ioctl(d___0->cdda_fd, 8836UL, & arg);
  }
#line 570
  if (tmp) {
    {
#line 571
    cdmessage___2(d___0, "FAILED: EBUSY\n");
    }
  } else {
    {
#line 573
    cdmessage___2(d___0, "OK\n");
    }
  }
  {
#line 575
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 576
    tmp___0 = test_unit_ready(d___0);
    }
#line 576
    if (tmp___0) {
#line 576
      goto while_break;
    }
    {
#line 577
    tries ++;
#line 578
    usleep((__useconds_t )10);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 581
  (*(d___0->enable_cdda))(d___0, 1);
  }
#line 582
  return;
}
}
#line 607 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
static int mode_sense_atapi(cdrom_drive *d___0 , int size , int page ) 
{ 
  unsigned char sense[16] ;
  unsigned char cmd[10] ;
  int tmp ;
  unsigned char *b ;

  {
  {
#line 609
  cmd[0] = (unsigned char)90;
#line 609
  cmd[1] = (unsigned char)0;
#line 609
  cmd[2] = (unsigned char)0;
#line 609
  cmd[3] = (unsigned char)0;
#line 609
  cmd[4] = (unsigned char)0;
#line 609
  cmd[5] = (unsigned char)0;
#line 609
  cmd[6] = (unsigned char)0;
#line 609
  cmd[7] = (unsigned char)0;
#line 609
  cmd[8] = (unsigned char)0;
#line 609
  cmd[9] = (unsigned char)0;
#line 620
  cmd[1] = (unsigned char )(d___0->lun << 5);
#line 621
  cmd[2] = (unsigned char )(63 & page);
#line 622
  cmd[8] = (unsigned char )(size + 4);
#line 624
  tmp = handle_scsi_cmd(d___0, cmd, 10U, 0U, (unsigned int )(size + 4), (unsigned char )'\377',
                        1, sense);
  }
#line 624
  if (tmp) {
#line 624
    return (1);
  }
#line 627
  b = (d___0->private_data)->sg_buffer;
#line 628
  if (*(b + 0)) {
#line 628
    return (1);
  }
#line 629
  if (*(b + 6)) {
#line 629
    return (1);
  }
  {
#line 631
  *(b + 0) = (unsigned char )((int )*(b + 1) - 3);
#line 632
  *(b + 1) = *(b + 2);
#line 633
  *(b + 2) = *(b + 3);
#line 634
  *(b + 3) = *(b + 7);
#line 636
  memmove((void *)(b + 4), (void const   *)(b + 8), (size_t )(size - 4));
  }
#line 638
  return (0);
}
}
#line 643 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
static int mode_sense_scsi(cdrom_drive *d___0 , int size , int page ) 
{ 
  unsigned char sense[16] ;
  unsigned char cmd[6] ;
  int tmp ;

  {
  {
#line 645
  cmd[0] = (unsigned char)26;
#line 645
  cmd[1] = (unsigned char)0;
#line 645
  cmd[2] = (unsigned char)0;
#line 645
  cmd[3] = (unsigned char)0;
#line 645
  cmd[4] = (unsigned char)0;
#line 645
  cmd[5] = (unsigned char)0;
#line 652
  cmd[1] = (unsigned char )(d___0->lun << 5);
#line 653
  cmd[2] = (unsigned char )(63 & page);
#line 654
  cmd[4] = (unsigned char )size;
#line 656
  tmp = handle_scsi_cmd(d___0, cmd, 6U, 0U, (unsigned int )size, (unsigned char )'\377',
                        1, sense);
  }
#line 656
  if (tmp) {
#line 656
    return (1);
  }
#line 661
  return (0);
}
}
#line 664 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
static int mode_sense(cdrom_drive *d___0 , int size , int page ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 665
  if (d___0->is_atapi) {
    {
#line 666
    tmp = mode_sense_atapi(d___0, size, page);
    }
#line 666
    return (tmp);
  }
  {
#line 667
  tmp___0 = mode_sense_scsi(d___0, size, page);
  }
#line 667
  return (tmp___0);
}
}
#line 674 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
static int mode_select(cdrom_drive *d___0 , int density , int secsize ) 
{ 
  unsigned char sense[16] ;
  unsigned char cmd[26] ;
  unsigned char *mode ;
  int tmp ;
  unsigned char cmd___0[18] ;
  unsigned char *mode___0 ;
  int tmp___0 ;

  {
#line 677
  if (d___0->is_atapi) {
    {
#line 678
    cmd[0] = (unsigned char)85;
#line 678
    cmd[1] = (unsigned char)16;
#line 678
    cmd[2] = (unsigned char)0;
#line 678
    cmd[3] = (unsigned char)0;
#line 678
    cmd[4] = (unsigned char)0;
#line 678
    cmd[5] = (unsigned char)0;
#line 678
    cmd[6] = (unsigned char)0;
#line 678
    cmd[7] = (unsigned char)0;
#line 678
    cmd[8] = (unsigned char)16;
#line 678
    cmd[9] = (unsigned char)0;
#line 678
    cmd[10] = (unsigned char)0;
#line 678
    cmd[11] = (unsigned char)0;
#line 678
    cmd[12] = (unsigned char)0;
#line 678
    cmd[13] = (unsigned char)0;
#line 678
    cmd[14] = (unsigned char)0;
#line 678
    cmd[15] = (unsigned char)0;
#line 678
    cmd[16] = (unsigned char)0;
#line 678
    cmd[17] = (unsigned char)8;
#line 678
    cmd[18] = (unsigned char)0;
#line 678
    cmd[19] = (unsigned char)0;
#line 678
    cmd[20] = (unsigned char)0;
#line 678
    cmd[21] = (unsigned char)0;
#line 678
    cmd[22] = (unsigned char)0;
#line 678
    cmd[23] = (unsigned char)0;
#line 678
    cmd[24] = (unsigned char)0;
#line 678
    cmd[25] = (unsigned char)0;
#line 698
    mode = cmd + 18;
#line 701
    *(mode + 0) = (unsigned char )density;
#line 702
    *(mode + 6) = (unsigned char )(secsize >> 8);
#line 703
    *(mode + 7) = (unsigned char )(secsize & 255);
#line 706
    tmp = handle_scsi_cmd(d___0, cmd, 10U, 16U, 0U, (unsigned char)0, 0, sense);
    }
#line 706
    return (tmp);
  } else {
    {
#line 709
    cmd___0[0] = (unsigned char)21;
#line 709
    cmd___0[1] = (unsigned char)16;
#line 709
    cmd___0[2] = (unsigned char)0;
#line 709
    cmd___0[3] = (unsigned char)0;
#line 709
    cmd___0[4] = (unsigned char)12;
#line 709
    cmd___0[5] = (unsigned char)0;
#line 709
    cmd___0[6] = (unsigned char)0;
#line 709
    cmd___0[7] = (unsigned char)0;
#line 709
    cmd___0[8] = (unsigned char)0;
#line 709
    cmd___0[9] = (unsigned char)8;
#line 709
    cmd___0[10] = (unsigned char)0;
#line 709
    cmd___0[11] = (unsigned char)0;
#line 709
    cmd___0[12] = (unsigned char)0;
#line 709
    cmd___0[13] = (unsigned char)0;
#line 709
    cmd___0[14] = (unsigned char)0;
#line 709
    cmd___0[15] = (unsigned char)0;
#line 709
    cmd___0[16] = (unsigned char)0;
#line 709
    cmd___0[17] = (unsigned char)0;
#line 723
    mode___0 = cmd___0 + 10;
#line 726
    *(mode___0 + 0) = (unsigned char )density;
#line 727
    *(mode___0 + 6) = (unsigned char )(secsize >> 8);
#line 728
    *(mode___0 + 7) = (unsigned char )(secsize & 255);
#line 731
    tmp___0 = handle_scsi_cmd(d___0, cmd___0, 6U, 12U, 0U, (unsigned char)0, 0, sense);
    }
#line 731
    return (tmp___0);
  }
}
}
#line 736 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
static unsigned int get_orig_sectorsize(cdrom_drive *d___0 ) 
{ 
  int tmp ;
  unsigned int tmp___0 ;

  {
  {
#line 737
  tmp = mode_sense(d___0, 12, 1);
  }
#line 737
  if (tmp) {
#line 737
    return (4294967295U);
  }
#line 739
  d___0->orgdens = *((d___0->private_data)->sg_buffer + 4);
#line 740
  tmp___0 = (unsigned int )(((int )*((d___0->private_data)->sg_buffer + 10) << 8) + (int )*((d___0->private_data)->sg_buffer + 11));
#line 740
  d___0->orgsize = tmp___0;
#line 740
  return (tmp___0);
}
}
#line 744 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
static int set_sectorsize(cdrom_drive *d___0 , unsigned int secsize ) 
{ 
  int tmp ;

  {
  {
#line 745
  tmp = mode_select(d___0, (int )d___0->orgdens, (int )secsize);
  }
#line 745
  return (tmp);
}
}
#line 749 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
int scsi_enable_cdda(cdrom_drive *d___0 , int fAudioMode ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 750
  if (fAudioMode) {
    {
#line 751
    tmp = mode_select(d___0, (int )d___0->density, 2352);
    }
#line 751
    if (tmp) {
#line 752
      if (d___0->error_retry) {
        {
#line 753
        cderror___1(d___0, "001: Unable to set CDROM to read audio mode\n");
        }
      }
#line 754
      return (-1);
    }
  } else {
    {
#line 757
    tmp___0 = mode_select(d___0, (int )d___0->orgdens, (int )d___0->orgsize);
    }
#line 757
    if (tmp___0) {
#line 758
      if (d___0->error_retry) {
        {
#line 759
        cderror___1(d___0, "001: Unable to set CDROM to read audio mode\n");
        }
      }
#line 760
      return (-1);
    }
  }
#line 763
  return (0);
}
}
#line 782 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
static int scsi_read_toc(cdrom_drive *d___0 ) 
{ 
  int i ;
  int first ;
  int last___0 ;
  unsigned int tracks ;
  unsigned char sense[16] ;
  unsigned char cmd[10] ;
  int tmp ;
  char __constr_expr_0[10] ;
  int tmp___0 ;
  scsi_TOC *toc ;
  char __constr_expr_1[10] ;
  int tmp___1 ;
  scsi_TOC *toc___0 ;

  {
  {
#line 791
  cmd[0] = (unsigned char)67;
#line 791
  cmd[1] = (unsigned char)0;
#line 791
  cmd[2] = (unsigned char)0;
#line 791
  cmd[3] = (unsigned char)0;
#line 791
  cmd[4] = (unsigned char)0;
#line 791
  cmd[5] = (unsigned char)0;
#line 791
  cmd[6] = (unsigned char)1;
#line 791
  cmd[7] = (unsigned char)0;
#line 791
  cmd[8] = (unsigned char)12;
#line 791
  cmd[9] = (unsigned char)0;
#line 792
  cmd[1] = (unsigned char )(d___0->lun << 5);
#line 794
  tmp = handle_scsi_cmd(d___0, cmd, 10U, 0U, 12U, (unsigned char )'\377', 1, sense);
  }
#line 794
  if (tmp) {
    {
#line 795
    cderror___1(d___0, "004: Unable to read table of contents header\n");
    }
#line 796
    return (-4);
  }
#line 799
  first = (int )*((d___0->private_data)->sg_buffer + 2);
#line 800
  last___0 = (int )*((d___0->private_data)->sg_buffer + 3);
#line 801
  tracks = (unsigned int )((last___0 - first) + 1);
#line 803
  if (last___0 > 100) {
    {
#line 804
    cderror___1(d___0, "003: CDROM reporting illegal number of tracks\n");
    }
#line 805
    return (-3);
  } else
#line 803
  if (first > 100) {
    {
#line 804
    cderror___1(d___0, "003: CDROM reporting illegal number of tracks\n");
    }
#line 805
    return (-3);
  } else
#line 803
  if (last___0 < 0) {
    {
#line 804
    cderror___1(d___0, "003: CDROM reporting illegal number of tracks\n");
    }
#line 805
    return (-3);
  } else
#line 803
  if (first < 0) {
    {
#line 804
    cderror___1(d___0, "003: CDROM reporting illegal number of tracks\n");
    }
#line 805
    return (-3);
  }
#line 808
  i = first;
  {
#line 808
  while (1) {
    while_continue: /* CIL Label */ ;
#line 808
    if (! (i <= last___0)) {
#line 808
      goto while_break;
    }
    {
#line 809
    __constr_expr_0[0] = (char)67;
#line 809
    __constr_expr_0[1] = (char)0;
#line 809
    __constr_expr_0[2] = (char)0;
#line 809
    __constr_expr_0[3] = (char)0;
#line 809
    __constr_expr_0[4] = (char)0;
#line 809
    __constr_expr_0[5] = (char)0;
#line 809
    __constr_expr_0[6] = (char)0;
#line 809
    __constr_expr_0[7] = (char)0;
#line 809
    __constr_expr_0[8] = (char)12;
#line 809
    __constr_expr_0[9] = (char)0;
#line 809
    memcpy((void */* __restrict  */)(cmd), (void const   */* __restrict  */)(__constr_expr_0),
           (size_t )10);
#line 810
    cmd[1] = (unsigned char )(d___0->lun << 5);
#line 811
    cmd[6] = (unsigned char )i;
#line 813
    tmp___0 = handle_scsi_cmd(d___0, cmd, 10U, 0U, 12U, (unsigned char )'\377', 1,
                              sense);
    }
#line 813
    if (tmp___0) {
      {
#line 814
      cderror___1(d___0, "005: Unable to read table of contents entry\n");
      }
#line 815
      return (-5);
    }
#line 818
    toc = (scsi_TOC *)((d___0->private_data)->sg_buffer + 4);
#line 820
    d___0->disc_toc[i - first].bFlags = toc->bFlags;
#line 821
    d___0->disc_toc[i - first].bTrack = (unsigned char )i;
#line 822
    d___0->disc_toc[i - first].dwStartSector = d___0->adjust_ssize * (((((int )toc->start_MSB << 24) | ((int )toc->start_1 << 16)) | ((int )toc->start_2 << 8)) | (int )toc->start_LSB);
#line 808
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 830
  __constr_expr_1[0] = (char)67;
#line 830
  __constr_expr_1[1] = (char)0;
#line 830
  __constr_expr_1[2] = (char)0;
#line 830
  __constr_expr_1[3] = (char)0;
#line 830
  __constr_expr_1[4] = (char)0;
#line 830
  __constr_expr_1[5] = (char)0;
#line 830
  __constr_expr_1[6] = (char)0;
#line 830
  __constr_expr_1[7] = (char)0;
#line 830
  __constr_expr_1[8] = (char)12;
#line 830
  __constr_expr_1[9] = (char)0;
#line 830
  memcpy((void */* __restrict  */)(cmd), (void const   */* __restrict  */)(__constr_expr_1),
         (size_t )10);
#line 831
  cmd[1] = (unsigned char )(d___0->lun << 5);
#line 832
  cmd[6] = (unsigned char)170;
#line 834
  tmp___1 = handle_scsi_cmd(d___0, cmd, 10U, 0U, 12U, (unsigned char )'\377', 1, sense);
  }
#line 834
  if (tmp___1) {
    {
#line 835
    cderror___1(d___0, "002: Unable to read table of contents lead-out\n");
    }
#line 836
    return (-2);
  }
  {
#line 839
  toc___0 = (scsi_TOC *)((d___0->private_data)->sg_buffer + 4);
#line 841
  d___0->disc_toc[i - first].bFlags = toc___0->bFlags;
#line 842
  d___0->disc_toc[i - first].bTrack = (unsigned char)170;
#line 843
  d___0->disc_toc[i - first].dwStartSector = d___0->adjust_ssize * (((((int )toc___0->start_MSB << 24) | ((int )toc___0->start_1 << 16)) | ((int )toc___0->start_2 << 8)) | (int )toc___0->start_LSB);
#line 850
  d___0->cd_extra = FixupTOC(d___0, (int )(tracks + 1U));
  }
#line 851
  return ((int )tracks);
}
}
#line 856 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
static int scsi_read_toc2(cdrom_drive *d___0 ) 
{ 
  u_int32_t foo ;
  u_int32_t bar ;
  int i ;
  unsigned int tracks ;
  unsigned char cmd[10] ;
  unsigned char sense[16] ;
  int tmp ;
  char __constr_expr_2[10] ;
  int tmp___0 ;
  int32_t tmp___1 ;
  int32_t tmp___2 ;

  {
  {
#line 862
  cmd[0] = (unsigned char)229;
#line 862
  cmd[1] = (unsigned char)0;
#line 862
  cmd[2] = (unsigned char)0;
#line 862
  cmd[3] = (unsigned char)0;
#line 862
  cmd[4] = (unsigned char)0;
#line 862
  cmd[5] = (unsigned char)0;
#line 862
  cmd[6] = (unsigned char)0;
#line 862
  cmd[7] = (unsigned char)0;
#line 862
  cmd[8] = (unsigned char)0;
#line 862
  cmd[9] = (unsigned char)0;
#line 864
  cmd[5] = (unsigned char)1;
#line 865
  cmd[8] = (unsigned char)255;
#line 867
  tmp = handle_scsi_cmd(d___0, cmd, 10U, 0U, 256U, (unsigned char )'\377', 1, sense);
  }
#line 867
  if (tmp) {
    {
#line 868
    cderror___1(d___0, "004: Unable to read table of contents header\n");
    }
#line 869
    return (-4);
  }
#line 873
  tracks = (unsigned int )*((d___0->private_data)->sg_buffer + 1);
#line 874
  if (tracks > 100U) {
    {
#line 875
    cderror___1(d___0, "003: CDROM reporting illegal number of tracks\n");
    }
#line 876
    return (-3);
  }
#line 879
  i = 0;
  {
#line 879
  while (1) {
    while_continue: /* CIL Label */ ;
#line 879
    if (! ((unsigned int )i < tracks)) {
#line 879
      goto while_break;
    }
    {
#line 880
    __constr_expr_2[0] = (char)-27;
#line 880
    __constr_expr_2[1] = (char)0;
#line 880
    __constr_expr_2[2] = (char)0;
#line 880
    __constr_expr_2[3] = (char)0;
#line 880
    __constr_expr_2[4] = (char)0;
#line 880
    __constr_expr_2[5] = (char)0;
#line 880
    __constr_expr_2[6] = (char)0;
#line 880
    __constr_expr_2[7] = (char)0;
#line 880
    __constr_expr_2[8] = (char)0;
#line 880
    __constr_expr_2[9] = (char)0;
#line 880
    memcpy((void */* __restrict  */)(cmd), (void const   */* __restrict  */)(__constr_expr_2),
           (size_t )10);
#line 881
    cmd[5] = (unsigned char )(i + 1);
#line 882
    cmd[8] = (unsigned char)255;
#line 884
    tmp___0 = handle_scsi_cmd(d___0, cmd, 10U, 0U, 256U, (unsigned char )'\377', 1,
                              sense);
    }
#line 884
    if (tmp___0) {
      {
#line 885
      cderror___1(d___0, "005: Unable to read table of contents entry\n");
      }
#line 886
      return (-5);
    }
#line 889
    d___0->disc_toc[i].bFlags = *((d___0->private_data)->sg_buffer + 10);
#line 890
    d___0->disc_toc[i].bTrack = (unsigned char )(i + 1);
#line 892
    d___0->disc_toc[i].dwStartSector = d___0->adjust_ssize * (((((int )((signed char )*((d___0->private_data)->sg_buffer + 2)) << 24) | ((int )*((d___0->private_data)->sg_buffer + 3) << 16)) | ((int )*((d___0->private_data)->sg_buffer + 4) << 8)) | (int )*((d___0->private_data)->sg_buffer + 5));
#line 879
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 899
  d___0->disc_toc[i].bFlags = (unsigned char)0;
#line 900
  d___0->disc_toc[i].bTrack = (unsigned char )(i + 1);
#line 901
  memcpy((void */* __restrict  */)(& foo), (void const   */* __restrict  */)((d___0->private_data)->sg_buffer + 2),
         (size_t )4);
#line 902
  memcpy((void */* __restrict  */)(& bar), (void const   */* __restrict  */)((d___0->private_data)->sg_buffer + 6),
         (size_t )4);
#line 903
  tmp___1 = be32_to_cpu((int32_t )foo);
#line 903
  tmp___2 = be32_to_cpu((int32_t )bar);
#line 903
  d___0->disc_toc[i].dwStartSector = d___0->adjust_ssize * (tmp___1 + tmp___2);
#line 906
  d___0->disc_toc[i].dwStartSector = d___0->adjust_ssize * ((((((int )((signed char )*((d___0->private_data)->sg_buffer + 2)) << 24) | ((int )*((d___0->private_data)->sg_buffer + 3) << 16)) | ((int )*((d___0->private_data)->sg_buffer + 4) << 8)) | (int )*((d___0->private_data)->sg_buffer + 5)) + (((((int )((signed char )*((d___0->private_data)->sg_buffer + 6)) << 24) | ((int )*((d___0->private_data)->sg_buffer + 7) << 16)) | ((int )*((d___0->private_data)->sg_buffer + 8) << 8)) | (int )*((d___0->private_data)->sg_buffer + 9)));
#line 918
  d___0->cd_extra = FixupTOC(d___0, (int )(tracks + 1U));
  }
#line 919
  return ((int )tracks);
}
}
#line 922 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
static int scsi_set_speed(cdrom_drive *d___0 , int speed ) 
{ 
  unsigned char cmd[12] ;
  unsigned char sense[16] ;
  int tmp ;

  {
#line 923
  cmd[0] = (unsigned char)187;
#line 923
  cmd[1] = (unsigned char)0;
#line 923
  cmd[2] = (unsigned char)0;
#line 923
  cmd[3] = (unsigned char)0;
#line 923
  cmd[4] = (unsigned char)255;
#line 923
  cmd[5] = (unsigned char)255;
#line 923
  cmd[6] = (unsigned char)0;
#line 923
  cmd[7] = (unsigned char)0;
#line 923
  cmd[8] = (unsigned char)0;
#line 923
  cmd[9] = (unsigned char)0;
#line 923
  cmd[10] = (unsigned char)0;
#line 923
  cmd[11] = (unsigned char)0;
#line 926
  if (speed >= 0) {
#line 927
    speed = ((speed * 44100) * 4) / 1024;
  } else {
#line 929
    speed = -1;
  }
  {
#line 930
  cmd[2] = (unsigned char )((speed >> 8) & 255);
#line 931
  cmd[3] = (unsigned char )(speed & 255);
#line 932
  tmp = handle_scsi_cmd(d___0, cmd, 12U, 0U, 0U, (unsigned char)0, 0, sense);
  }
#line 932
  return (tmp);
}
}
#line 937 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
static int i_read_28(cdrom_drive *d___0 , void *p___0 , long begin , long sectors ,
                     unsigned char *sense ) 
{ 
  int ret ;
  unsigned char cmd[10] ;

  {
#line 939
  cmd[0] = (unsigned char)40;
#line 939
  cmd[1] = (unsigned char)0;
#line 939
  cmd[2] = (unsigned char)0;
#line 939
  cmd[3] = (unsigned char)0;
#line 939
  cmd[4] = (unsigned char)0;
#line 939
  cmd[5] = (unsigned char)0;
#line 939
  cmd[6] = (unsigned char)0;
#line 939
  cmd[7] = (unsigned char)0;
#line 939
  cmd[8] = (unsigned char)0;
#line 939
  cmd[9] = (unsigned char)0;
#line 941
  if (d___0->fua) {
#line 942
    cmd[1] = (unsigned char)8;
  }
  {
#line 944
  cmd[1] = (unsigned char )((int )cmd[1] | (d___0->lun << 5));
#line 946
  cmd[3] = (unsigned char )((begin >> 16) & 255L);
#line 947
  cmd[4] = (unsigned char )((begin >> 8) & 255L);
#line 948
  cmd[5] = (unsigned char )(begin & 255L);
#line 949
  cmd[8] = (unsigned char )sectors;
#line 950
  ret = handle_scsi_cmd(d___0, cmd, 10U, 0U, (unsigned int )(sectors * 2352L), (unsigned char )'\177',
                        1, sense);
  }
#line 950
  if (ret) {
#line 951
    return (ret);
  }
#line 952
  if (p___0) {
    {
#line 952
    memcpy((void */* __restrict  */)p___0, (void const   */* __restrict  */)(d___0->private_data)->sg_buffer,
           (size_t )(sectors * 2352L));
    }
  }
#line 953
  return (0);
}
}
#line 956 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
static int i_read_A8(cdrom_drive *d___0 , void *p___0 , long begin , long sectors ,
                     unsigned char *sense ) 
{ 
  int ret ;
  unsigned char cmd[12] ;

  {
#line 958
  cmd[0] = (unsigned char)168;
#line 958
  cmd[1] = (unsigned char)0;
#line 958
  cmd[2] = (unsigned char)0;
#line 958
  cmd[3] = (unsigned char)0;
#line 958
  cmd[4] = (unsigned char)0;
#line 958
  cmd[5] = (unsigned char)0;
#line 958
  cmd[6] = (unsigned char)0;
#line 958
  cmd[7] = (unsigned char)0;
#line 958
  cmd[8] = (unsigned char)0;
#line 958
  cmd[9] = (unsigned char)0;
#line 958
  cmd[10] = (unsigned char)0;
#line 958
  cmd[11] = (unsigned char)0;
#line 960
  if (d___0->fua) {
#line 961
    cmd[1] = (unsigned char)8;
  }
  {
#line 963
  cmd[1] = (unsigned char )((int )cmd[1] | (d___0->lun << 5));
#line 965
  cmd[3] = (unsigned char )((begin >> 16) & 255L);
#line 966
  cmd[4] = (unsigned char )((begin >> 8) & 255L);
#line 967
  cmd[5] = (unsigned char )(begin & 255L);
#line 968
  cmd[9] = (unsigned char )sectors;
#line 969
  ret = handle_scsi_cmd(d___0, cmd, 12U, 0U, (unsigned int )(sectors * 2352L), (unsigned char )'\177',
                        1, sense);
  }
#line 969
  if (ret) {
#line 970
    return (ret);
  }
#line 971
  if (p___0) {
    {
#line 971
    memcpy((void */* __restrict  */)p___0, (void const   */* __restrict  */)(d___0->private_data)->sg_buffer,
           (size_t )(sectors * 2352L));
    }
  }
#line 972
  return (0);
}
}
#line 975 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
static int i_read_D4_10(cdrom_drive *d___0 , void *p___0 , long begin , long sectors ,
                        unsigned char *sense ) 
{ 
  int ret ;
  unsigned char cmd[10] ;

  {
#line 977
  cmd[0] = (unsigned char)212;
#line 977
  cmd[1] = (unsigned char)0;
#line 977
  cmd[2] = (unsigned char)0;
#line 977
  cmd[3] = (unsigned char)0;
#line 977
  cmd[4] = (unsigned char)0;
#line 977
  cmd[5] = (unsigned char)0;
#line 977
  cmd[6] = (unsigned char)0;
#line 977
  cmd[7] = (unsigned char)0;
#line 977
  cmd[8] = (unsigned char)0;
#line 977
  cmd[9] = (unsigned char)0;
#line 979
  if (d___0->fua) {
#line 980
    cmd[1] = (unsigned char)8;
  }
  {
#line 982
  cmd[1] = (unsigned char )((int )cmd[1] | (d___0->lun << 5));
#line 983
  cmd[3] = (unsigned char )((begin >> 16) & 255L);
#line 984
  cmd[4] = (unsigned char )((begin >> 8) & 255L);
#line 985
  cmd[5] = (unsigned char )(begin & 255L);
#line 986
  cmd[8] = (unsigned char )sectors;
#line 987
  ret = handle_scsi_cmd(d___0, cmd, 10U, 0U, (unsigned int )(sectors * 2352L), (unsigned char )'\177',
                        1, sense);
  }
#line 987
  if (ret) {
#line 988
    return (ret);
  }
#line 989
  if (p___0) {
    {
#line 989
    memcpy((void */* __restrict  */)p___0, (void const   */* __restrict  */)(d___0->private_data)->sg_buffer,
           (size_t )(sectors * 2352L));
    }
  }
#line 990
  return (0);
}
}
#line 993 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
static int i_read_D4_12(cdrom_drive *d___0 , void *p___0 , long begin , long sectors ,
                        unsigned char *sense ) 
{ 
  int ret ;
  unsigned char cmd[12] ;

  {
#line 995
  cmd[0] = (unsigned char)212;
#line 995
  cmd[1] = (unsigned char)0;
#line 995
  cmd[2] = (unsigned char)0;
#line 995
  cmd[3] = (unsigned char)0;
#line 995
  cmd[4] = (unsigned char)0;
#line 995
  cmd[5] = (unsigned char)0;
#line 995
  cmd[6] = (unsigned char)0;
#line 995
  cmd[7] = (unsigned char)0;
#line 995
  cmd[8] = (unsigned char)0;
#line 995
  cmd[9] = (unsigned char)0;
#line 995
  cmd[10] = (unsigned char)0;
#line 995
  cmd[11] = (unsigned char)0;
#line 997
  if (d___0->fua) {
#line 998
    cmd[1] = (unsigned char)8;
  }
  {
#line 1000
  cmd[1] = (unsigned char )((int )cmd[1] | (d___0->lun << 5));
#line 1001
  cmd[3] = (unsigned char )((begin >> 16) & 255L);
#line 1002
  cmd[4] = (unsigned char )((begin >> 8) & 255L);
#line 1003
  cmd[5] = (unsigned char )(begin & 255L);
#line 1004
  cmd[9] = (unsigned char )sectors;
#line 1005
  ret = handle_scsi_cmd(d___0, cmd, 12U, 0U, (unsigned int )(sectors * 2352L), (unsigned char )'\177',
                        1, sense);
  }
#line 1005
  if (ret) {
#line 1006
    return (ret);
  }
#line 1007
  if (p___0) {
    {
#line 1007
    memcpy((void */* __restrict  */)p___0, (void const   */* __restrict  */)(d___0->private_data)->sg_buffer,
           (size_t )(sectors * 2352L));
    }
  }
#line 1008
  return (0);
}
}
#line 1011 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
static int i_read_D5(cdrom_drive *d___0 , void *p___0 , long begin , long sectors ,
                     unsigned char *sense ) 
{ 
  int ret ;
  unsigned char cmd[10] ;

  {
#line 1013
  cmd[0] = (unsigned char)213;
#line 1013
  cmd[1] = (unsigned char)0;
#line 1013
  cmd[2] = (unsigned char)0;
#line 1013
  cmd[3] = (unsigned char)0;
#line 1013
  cmd[4] = (unsigned char)0;
#line 1013
  cmd[5] = (unsigned char)0;
#line 1013
  cmd[6] = (unsigned char)0;
#line 1013
  cmd[7] = (unsigned char)0;
#line 1013
  cmd[8] = (unsigned char)0;
#line 1013
  cmd[9] = (unsigned char)0;
#line 1015
  if (d___0->fua) {
#line 1016
    cmd[1] = (unsigned char)8;
  }
  {
#line 1018
  cmd[1] = (unsigned char )((int )cmd[1] | (d___0->lun << 5));
#line 1019
  cmd[3] = (unsigned char )((begin >> 16) & 255L);
#line 1020
  cmd[4] = (unsigned char )((begin >> 8) & 255L);
#line 1021
  cmd[5] = (unsigned char )(begin & 255L);
#line 1022
  cmd[8] = (unsigned char )sectors;
#line 1023
  ret = handle_scsi_cmd(d___0, cmd, 10U, 0U, (unsigned int )(sectors * 2352L), (unsigned char )'\177',
                        1, sense);
  }
#line 1023
  if (ret) {
#line 1024
    return (ret);
  }
#line 1025
  if (p___0) {
    {
#line 1025
    memcpy((void */* __restrict  */)p___0, (void const   */* __restrict  */)(d___0->private_data)->sg_buffer,
           (size_t )(sectors * 2352L));
    }
  }
#line 1026
  return (0);
}
}
#line 1029 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
static int i_read_D8(cdrom_drive *d___0 , void *p___0 , long begin , long sectors ,
                     unsigned char *sense ) 
{ 
  int ret ;
  unsigned char cmd[12] ;

  {
#line 1031
  cmd[0] = (unsigned char)216;
#line 1031
  cmd[1] = (unsigned char)0;
#line 1031
  cmd[2] = (unsigned char)0;
#line 1031
  cmd[3] = (unsigned char)0;
#line 1031
  cmd[4] = (unsigned char)0;
#line 1031
  cmd[5] = (unsigned char)0;
#line 1031
  cmd[6] = (unsigned char)0;
#line 1031
  cmd[7] = (unsigned char)0;
#line 1031
  cmd[8] = (unsigned char)0;
#line 1031
  cmd[9] = (unsigned char)0;
#line 1031
  cmd[10] = (unsigned char)0;
#line 1031
  cmd[11] = (unsigned char)0;
#line 1033
  if (d___0->fua) {
#line 1034
    cmd[1] = (unsigned char)8;
  }
  {
#line 1036
  cmd[1] = (unsigned char )((int )cmd[1] | (d___0->lun << 5));
#line 1037
  cmd[3] = (unsigned char )((begin >> 16) & 255L);
#line 1038
  cmd[4] = (unsigned char )((begin >> 8) & 255L);
#line 1039
  cmd[5] = (unsigned char )(begin & 255L);
#line 1040
  cmd[9] = (unsigned char )sectors;
#line 1041
  ret = handle_scsi_cmd(d___0, cmd, 12U, 0U, (unsigned int )(sectors * 2352L), (unsigned char )'\177',
                        1, sense);
  }
#line 1041
  if (ret) {
#line 1042
    return (ret);
  }
#line 1043
  if (p___0) {
    {
#line 1043
    memcpy((void */* __restrict  */)p___0, (void const   */* __restrict  */)(d___0->private_data)->sg_buffer,
           (size_t )(sectors * 2352L));
    }
  }
#line 1044
  return (0);
}
}
#line 1047 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
static int i_read_mmc(cdrom_drive *d___0 , void *p___0 , long begin , long sectors ,
                      unsigned char *sense ) 
{ 
  int ret ;
  unsigned char cmd[12] ;

  {
  {
#line 1049
  cmd[0] = (unsigned char)190;
#line 1049
  cmd[1] = (unsigned char)2;
#line 1049
  cmd[2] = (unsigned char)0;
#line 1049
  cmd[3] = (unsigned char)0;
#line 1049
  cmd[4] = (unsigned char)0;
#line 1049
  cmd[5] = (unsigned char)0;
#line 1049
  cmd[6] = (unsigned char)0;
#line 1049
  cmd[7] = (unsigned char)0;
#line 1049
  cmd[8] = (unsigned char)0;
#line 1049
  cmd[9] = (unsigned char)16;
#line 1049
  cmd[10] = (unsigned char)0;
#line 1049
  cmd[11] = (unsigned char)0;
#line 1051
  cmd[3] = (unsigned char )((begin >> 16) & 255L);
#line 1052
  cmd[4] = (unsigned char )((begin >> 8) & 255L);
#line 1053
  cmd[5] = (unsigned char )(begin & 255L);
#line 1054
  cmd[8] = (unsigned char )sectors;
#line 1055
  ret = handle_scsi_cmd(d___0, cmd, 12U, 0U, (unsigned int )(sectors * 2352L), (unsigned char )'\177',
                        1, sense);
  }
#line 1055
  if (ret) {
#line 1056
    return (ret);
  }
#line 1057
  if (p___0) {
    {
#line 1057
    memcpy((void */* __restrict  */)p___0, (void const   */* __restrict  */)(d___0->private_data)->sg_buffer,
           (size_t )(sectors * 2352L));
    }
  }
#line 1058
  return (0);
}
}
#line 1061 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
static int i_read_mmcB(cdrom_drive *d___0 , void *p___0 , long begin , long sectors ,
                       unsigned char *sense ) 
{ 
  int ret ;
  unsigned char cmd[12] ;

  {
  {
#line 1063
  cmd[0] = (unsigned char)190;
#line 1063
  cmd[1] = (unsigned char)0;
#line 1063
  cmd[2] = (unsigned char)0;
#line 1063
  cmd[3] = (unsigned char)0;
#line 1063
  cmd[4] = (unsigned char)0;
#line 1063
  cmd[5] = (unsigned char)0;
#line 1063
  cmd[6] = (unsigned char)0;
#line 1063
  cmd[7] = (unsigned char)0;
#line 1063
  cmd[8] = (unsigned char)0;
#line 1063
  cmd[9] = (unsigned char)16;
#line 1063
  cmd[10] = (unsigned char)0;
#line 1063
  cmd[11] = (unsigned char)0;
#line 1065
  cmd[3] = (unsigned char )((begin >> 16) & 255L);
#line 1066
  cmd[4] = (unsigned char )((begin >> 8) & 255L);
#line 1067
  cmd[5] = (unsigned char )(begin & 255L);
#line 1068
  cmd[8] = (unsigned char )sectors;
#line 1069
  ret = handle_scsi_cmd(d___0, cmd, 12U, 0U, (unsigned int )(sectors * 2352L), (unsigned char )'\177',
                        1, sense);
  }
#line 1069
  if (ret) {
#line 1070
    return (ret);
  }
#line 1071
  if (p___0) {
    {
#line 1071
    memcpy((void */* __restrict  */)p___0, (void const   */* __restrict  */)(d___0->private_data)->sg_buffer,
           (size_t )(sectors * 2352L));
    }
  }
#line 1072
  return (0);
}
}
#line 1075 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
static int i_read_mmc2(cdrom_drive *d___0 , void *p___0 , long begin , long sectors ,
                       unsigned char *sense ) 
{ 
  int ret ;
  unsigned char cmd[12] ;

  {
  {
#line 1077
  cmd[0] = (unsigned char)190;
#line 1077
  cmd[1] = (unsigned char)2;
#line 1077
  cmd[2] = (unsigned char)0;
#line 1077
  cmd[3] = (unsigned char)0;
#line 1077
  cmd[4] = (unsigned char)0;
#line 1077
  cmd[5] = (unsigned char)0;
#line 1077
  cmd[6] = (unsigned char)0;
#line 1077
  cmd[7] = (unsigned char)0;
#line 1077
  cmd[8] = (unsigned char)0;
#line 1077
  cmd[9] = (unsigned char)248;
#line 1077
  cmd[10] = (unsigned char)0;
#line 1077
  cmd[11] = (unsigned char)0;
#line 1079
  cmd[3] = (unsigned char )((begin >> 16) & 255L);
#line 1080
  cmd[4] = (unsigned char )((begin >> 8) & 255L);
#line 1081
  cmd[5] = (unsigned char )(begin & 255L);
#line 1082
  cmd[8] = (unsigned char )sectors;
#line 1083
  ret = handle_scsi_cmd(d___0, cmd, 12U, 0U, (unsigned int )(sectors * 2352L), (unsigned char )'\177',
                        1, sense);
  }
#line 1083
  if (ret) {
#line 1084
    return (ret);
  }
#line 1085
  if (p___0) {
    {
#line 1085
    memcpy((void */* __restrict  */)p___0, (void const   */* __restrict  */)(d___0->private_data)->sg_buffer,
           (size_t )(sectors * 2352L));
    }
  }
#line 1086
  return (0);
}
}
#line 1089 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
static int i_read_mmc2B(cdrom_drive *d___0 , void *p___0 , long begin , long sectors ,
                        unsigned char *sense ) 
{ 
  int ret ;
  unsigned char cmd[12] ;

  {
  {
#line 1091
  cmd[0] = (unsigned char)190;
#line 1091
  cmd[1] = (unsigned char)0;
#line 1091
  cmd[2] = (unsigned char)0;
#line 1091
  cmd[3] = (unsigned char)0;
#line 1091
  cmd[4] = (unsigned char)0;
#line 1091
  cmd[5] = (unsigned char)0;
#line 1091
  cmd[6] = (unsigned char)0;
#line 1091
  cmd[7] = (unsigned char)0;
#line 1091
  cmd[8] = (unsigned char)0;
#line 1091
  cmd[9] = (unsigned char)248;
#line 1091
  cmd[10] = (unsigned char)0;
#line 1091
  cmd[11] = (unsigned char)0;
#line 1093
  cmd[3] = (unsigned char )((begin >> 16) & 255L);
#line 1094
  cmd[4] = (unsigned char )((begin >> 8) & 255L);
#line 1095
  cmd[5] = (unsigned char )(begin & 255L);
#line 1096
  cmd[8] = (unsigned char )sectors;
#line 1097
  ret = handle_scsi_cmd(d___0, cmd, 12U, 0U, (unsigned int )(sectors * 2352L), (unsigned char )'\177',
                        1, sense);
  }
#line 1097
  if (ret) {
#line 1098
    return (ret);
  }
#line 1099
  if (p___0) {
    {
#line 1099
    memcpy((void */* __restrict  */)p___0, (void const   */* __restrict  */)(d___0->private_data)->sg_buffer,
           (size_t )(sectors * 2352L));
    }
  }
#line 1100
  return (0);
}
}
#line 1103 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
static int i_read_mmc3(cdrom_drive *d___0 , void *p___0 , long begin , long sectors ,
                       unsigned char *sense ) 
{ 
  int ret ;
  unsigned char cmd[12] ;

  {
  {
#line 1105
  cmd[0] = (unsigned char)190;
#line 1105
  cmd[1] = (unsigned char)6;
#line 1105
  cmd[2] = (unsigned char)0;
#line 1105
  cmd[3] = (unsigned char)0;
#line 1105
  cmd[4] = (unsigned char)0;
#line 1105
  cmd[5] = (unsigned char)0;
#line 1105
  cmd[6] = (unsigned char)0;
#line 1105
  cmd[7] = (unsigned char)0;
#line 1105
  cmd[8] = (unsigned char)0;
#line 1105
  cmd[9] = (unsigned char)248;
#line 1105
  cmd[10] = (unsigned char)0;
#line 1105
  cmd[11] = (unsigned char)0;
#line 1107
  cmd[3] = (unsigned char )((begin >> 16) & 255L);
#line 1108
  cmd[4] = (unsigned char )((begin >> 8) & 255L);
#line 1109
  cmd[5] = (unsigned char )(begin & 255L);
#line 1110
  cmd[8] = (unsigned char )sectors;
#line 1111
  ret = handle_scsi_cmd(d___0, cmd, 12U, 0U, (unsigned int )(sectors * 2352L), (unsigned char )'\177',
                        1, sense);
  }
#line 1111
  if (ret) {
#line 1112
    return (ret);
  }
#line 1113
  if (p___0) {
    {
#line 1113
    memcpy((void */* __restrict  */)p___0, (void const   */* __restrict  */)(d___0->private_data)->sg_buffer,
           (size_t )(sectors * 2352L));
    }
  }
#line 1114
  return (0);
}
}
#line 1117 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
static int i_read_mmc3B(cdrom_drive *d___0 , void *p___0 , long begin , long sectors ,
                        unsigned char *sense ) 
{ 
  int ret ;
  unsigned char cmd[12] ;

  {
  {
#line 1119
  cmd[0] = (unsigned char)190;
#line 1119
  cmd[1] = (unsigned char)4;
#line 1119
  cmd[2] = (unsigned char)0;
#line 1119
  cmd[3] = (unsigned char)0;
#line 1119
  cmd[4] = (unsigned char)0;
#line 1119
  cmd[5] = (unsigned char)0;
#line 1119
  cmd[6] = (unsigned char)0;
#line 1119
  cmd[7] = (unsigned char)0;
#line 1119
  cmd[8] = (unsigned char)0;
#line 1119
  cmd[9] = (unsigned char)248;
#line 1119
  cmd[10] = (unsigned char)0;
#line 1119
  cmd[11] = (unsigned char)0;
#line 1121
  cmd[3] = (unsigned char )((begin >> 16) & 255L);
#line 1122
  cmd[4] = (unsigned char )((begin >> 8) & 255L);
#line 1123
  cmd[5] = (unsigned char )(begin & 255L);
#line 1124
  cmd[8] = (unsigned char )sectors;
#line 1125
  ret = handle_scsi_cmd(d___0, cmd, 12U, 0U, (unsigned int )(sectors * 2352L), (unsigned char )'\177',
                        1, sense);
  }
#line 1125
  if (ret) {
#line 1126
    return (ret);
  }
#line 1127
  if (p___0) {
    {
#line 1127
    memcpy((void */* __restrict  */)p___0, (void const   */* __restrict  */)(d___0->private_data)->sg_buffer,
           (size_t )(sectors * 2352L));
    }
  }
#line 1128
  return (0);
}
}
#line 1132 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
__inline static void LBA_to_MSF(long lba , unsigned char *M , unsigned char *S , unsigned char *F ) 
{ 


  {
#line 1136
  if (lba >= -150L) {
#line 1137
    *M = (unsigned char )((lba + 150L) / 4500L);
#line 1138
    lba -= (long )(((int )*M * 60) * 75);
#line 1139
    *S = (unsigned char )((lba + 150L) / 75L);
#line 1140
    lba -= (long )((int )*S * 75);
#line 1141
    *F = (unsigned char )(lba + 150L);
  } else {
#line 1143
    *M = (unsigned char )((lba + 450150L) / 4500L);
#line 1144
    lba -= (long )(((int )*M * 60) * 75);
#line 1145
    *S = (unsigned char )((lba + 450150L) / 75L);
#line 1146
    lba -= (long )((int )*S * 75);
#line 1147
    *F = (unsigned char )(lba + 450150L);
  }
#line 1149
  return;
}
}
#line 1152 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
static int i_read_msf(cdrom_drive *d___0 , void *p___0 , long begin , long sectors ,
                      unsigned char *sense ) 
{ 
  int ret ;
  unsigned char cmd[12] ;

  {
  {
#line 1154
  cmd[0] = (unsigned char)185;
#line 1154
  cmd[1] = (unsigned char)0;
#line 1154
  cmd[2] = (unsigned char)0;
#line 1154
  cmd[3] = (unsigned char)0;
#line 1154
  cmd[4] = (unsigned char)0;
#line 1154
  cmd[5] = (unsigned char)0;
#line 1154
  cmd[6] = (unsigned char)0;
#line 1154
  cmd[7] = (unsigned char)0;
#line 1154
  cmd[8] = (unsigned char)0;
#line 1154
  cmd[9] = (unsigned char)16;
#line 1154
  cmd[10] = (unsigned char)0;
#line 1154
  cmd[11] = (unsigned char)0;
#line 1156
  LBA_to_MSF(begin, cmd + 3, cmd + 4, cmd + 5);
#line 1157
  LBA_to_MSF(begin + sectors, cmd + 6, cmd + 7, cmd + 8);
#line 1159
  ret = handle_scsi_cmd(d___0, cmd, 12U, 0U, (unsigned int )(sectors * 2352L), (unsigned char )'\177',
                        1, sense);
  }
#line 1159
  if (ret) {
#line 1160
    return (ret);
  }
#line 1161
  if (p___0) {
    {
#line 1161
    memcpy((void */* __restrict  */)p___0, (void const   */* __restrict  */)(d___0->private_data)->sg_buffer,
           (size_t )(sectors * 2352L));
    }
  }
#line 1162
  return (0);
}
}
#line 1165 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
static int i_read_msf2(cdrom_drive *d___0 , void *p___0 , long begin , long sectors ,
                       unsigned char *sense ) 
{ 
  int ret ;
  unsigned char cmd[12] ;

  {
  {
#line 1167
  cmd[0] = (unsigned char)185;
#line 1167
  cmd[1] = (unsigned char)0;
#line 1167
  cmd[2] = (unsigned char)0;
#line 1167
  cmd[3] = (unsigned char)0;
#line 1167
  cmd[4] = (unsigned char)0;
#line 1167
  cmd[5] = (unsigned char)0;
#line 1167
  cmd[6] = (unsigned char)0;
#line 1167
  cmd[7] = (unsigned char)0;
#line 1167
  cmd[8] = (unsigned char)0;
#line 1167
  cmd[9] = (unsigned char)248;
#line 1167
  cmd[10] = (unsigned char)0;
#line 1167
  cmd[11] = (unsigned char)0;
#line 1169
  LBA_to_MSF(begin, cmd + 3, cmd + 4, cmd + 5);
#line 1170
  LBA_to_MSF(begin + sectors, cmd + 6, cmd + 7, cmd + 8);
#line 1172
  ret = handle_scsi_cmd(d___0, cmd, 12U, 0U, (unsigned int )(sectors * 2352L), (unsigned char )'\177',
                        1, sense);
  }
#line 1172
  if (ret) {
#line 1173
    return (ret);
  }
#line 1174
  if (p___0) {
    {
#line 1174
    memcpy((void */* __restrict  */)p___0, (void const   */* __restrict  */)(d___0->private_data)->sg_buffer,
           (size_t )(sectors * 2352L));
    }
  }
#line 1175
  return (0);
}
}
#line 1178 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
static int i_read_msf3(cdrom_drive *d___0 , void *p___0 , long begin , long sectors ,
                       unsigned char *sense ) 
{ 
  int ret ;
  unsigned char cmd[12] ;

  {
  {
#line 1180
  cmd[0] = (unsigned char)185;
#line 1180
  cmd[1] = (unsigned char)4;
#line 1180
  cmd[2] = (unsigned char)0;
#line 1180
  cmd[3] = (unsigned char)0;
#line 1180
  cmd[4] = (unsigned char)0;
#line 1180
  cmd[5] = (unsigned char)0;
#line 1180
  cmd[6] = (unsigned char)0;
#line 1180
  cmd[7] = (unsigned char)0;
#line 1180
  cmd[8] = (unsigned char)0;
#line 1180
  cmd[9] = (unsigned char)248;
#line 1180
  cmd[10] = (unsigned char)0;
#line 1180
  cmd[11] = (unsigned char)0;
#line 1182
  LBA_to_MSF(begin, cmd + 3, cmd + 4, cmd + 5);
#line 1183
  LBA_to_MSF(begin + sectors, cmd + 6, cmd + 7, cmd + 8);
#line 1185
  ret = handle_scsi_cmd(d___0, cmd, 12U, 0U, (unsigned int )(sectors * 2352L), (unsigned char )'\177',
                        1, sense);
  }
#line 1185
  if (ret) {
#line 1186
    return (ret);
  }
#line 1187
  if (p___0) {
    {
#line 1187
    memcpy((void */* __restrict  */)p___0, (void const   */* __restrict  */)(d___0->private_data)->sg_buffer,
           (size_t )(sectors * 2352L));
    }
  }
#line 1188
  return (0);
}
}
#line 1192 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
static long scsi_read_map(cdrom_drive *d___0 , void *p___0 , long begin , long sectors ,
                          int (*map)(cdrom_drive * , void * , long  , long  , unsigned char * ) ) 
{ 
  unsigned char sense[16] ;
  int retry_count ;
  int err ;
  char *buffer ;
  char b[256] ;
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int *tmp___3 ;
  char b___0[256] ;
  int *tmp___4 ;
  char b___1[256] ;
  long i ;
  char b___2[256] ;
  char *tmp___5 ;

  {
#line 1197
  buffer = (char *)p___0;
#line 1200
  if (sectors > (long )d___0->nsectors) {
#line 1200
    sectors = (long )d___0->nsectors;
  } else {
#line 1200
    sectors = sectors;
  }
#line 1201
  if (sectors < 1L) {
#line 1201
    sectors = 1L;
  } else {
#line 1201
    sectors = sectors;
  }
#line 1203
  retry_count = 0;
  {
#line 1205
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1207
    if (p___0) {
#line 1207
      tmp___5 = buffer;
    } else {
#line 1207
      tmp___5 = (char *)((void *)0);
    }
    {
#line 1207
    err = (*map)(d___0, (void *)tmp___5, begin, sectors, sense);
    }
#line 1207
    if (err) {
#line 1208
      if (d___0->report_all) {
        {
#line 1211
        sprintf((char */* __restrict  */)(b), (char const   */* __restrict  */)"scsi_read error: sector=%ld length=%ld retry=%d\n",
                begin, sectors, retry_count);
#line 1213
        cdmessage___2(d___0, (char const   *)(b));
#line 1215
        sprintf((char */* __restrict  */)(b), (char const   */* __restrict  */)"                 Sense key: %x ASC: %x ASCQ: %x\n",
                (int )sense[2] & 15, (int )sense[12], (int )sense[13]);
#line 1228
        cdmessage___2(d___0, (char const   *)(b));
#line 1229
        sprintf((char */* __restrict  */)(b), (char const   */* __restrict  */)"                 Transport error: %s\n",
                strerror_tr[err]);
#line 1230
        cdmessage___2(d___0, (char const   *)(b));
#line 1231
        tmp = __errno_location();
#line 1231
        tmp___0 = strerror(*tmp);
#line 1231
        sprintf((char */* __restrict  */)(b), (char const   */* __restrict  */)"                 System error: %s\n",
                tmp___0);
#line 1232
        cdmessage___2(d___0, (char const   *)(b));
#line 1234
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"scsi_read error: sector=%ld length=%ld retry=%d\n",
                begin, sectors, retry_count);
#line 1237
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"                 Sense key: %x ASC: %x ASCQ: %x\n",
                (int )sense[2] & 15, (int )sense[12], (int )sense[13]);
#line 1249
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"                 Transport error: %s\n",
                strerror_tr[err]);
#line 1250
        tmp___1 = __errno_location();
#line 1250
        tmp___2 = strerror(*tmp___1);
#line 1250
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"                 System error: %s\n",
                tmp___2);
        }
      }
      {
#line 1253
      tmp___3 = __errno_location();
      }
      {
#line 1254
      if (*tmp___3 == 4) {
#line 1254
        goto case_4;
      }
#line 1257
      if (*tmp___3 == 12) {
#line 1257
        goto case_12;
      }
#line 1275
      if (*tmp___3 == 123) {
#line 1275
        goto case_123;
      }
#line 1279
      goto switch_default;
      case_4: /* CIL Label */ 
      {
#line 1255
      usleep((__useconds_t )100);
      }
#line 1256
      goto while_continue;
      case_12: /* CIL Label */ 
      {
#line 1259
      usleep((__useconds_t )100);
      }
#line 1260
      if (sectors == 1L) {
        {
#line 1262
        cderror___1(d___0, "300: Kernel memory error\n");
        }
#line 1263
        return (-300L);
      }
#line 1265
      if (d___0->report_all) {
        {
#line 1267
        sprintf((char */* __restrict  */)(b___0), (char const   */* __restrict  */)"scsi_read: kernel couldn\'t alloc %ld bytes.  backing off...\n",
                sectors * 2352L);
#line 1270
        cdmessage___2(d___0, (char const   *)(b___0));
        }
      }
#line 1272
      sectors --;
#line 1273
      goto while_continue;
      case_123: /* CIL Label */ 
      {
#line 1276
      cderror___1(d___0, "404: No medium present\n");
      }
#line 1277
      return (-404L);
      switch_default: /* CIL Label */ 
#line 1280
      if (sectors == 1L) {
        {
#line 1281
        tmp___4 = __errno_location();
        }
#line 1281
        if (*tmp___4 == 5) {
#line 1282
          if (d___0->fua == -1) {
#line 1283
            return (-7L);
          }
        }
#line 1288
        if (retry_count > 7) {
          {
#line 1290
          sprintf((char */* __restrict  */)(b___1), (char const   */* __restrict  */)"010: Unable to access sector %ld\n",
                  begin);
#line 1292
          cderror___1(d___0, (char const   *)(b___1));
          }
#line 1293
          return (-10L);
        }
#line 1296
        goto switch_break;
      }
      {
#line 1302
      reset_scsi(d___0);
      }
      switch_break: /* CIL Label */ ;
      }
#line 1304
      if (! d___0->error_retry) {
#line 1304
        return (-7L);
      }
    } else
#line 1310
    if (buffer) {
#line 1312
      i = sectors * 2352L;
      {
#line 1312
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1312
        if (! (i > 1L)) {
#line 1312
          goto while_break___0;
        }
#line 1313
        if ((int )*(buffer + (i - 1L)) != 127) {
#line 1314
          goto while_break___0;
        } else
#line 1313
        if ((int )*(buffer + (i - 2L)) != 127) {
#line 1314
          goto while_break___0;
        }
#line 1312
        i -= 2L;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 1316
      i /= 2352L;
#line 1317
      if (i != sectors) {
#line 1318
        if (d___0->report_all) {
          {
#line 1320
          sprintf((char */* __restrict  */)(b___2), (char const   */* __restrict  */)"scsi_read underrun: pos=%ld len=%ld read=%ld retry=%d\n",
                  begin, sectors, i, retry_count);
#line 1323
          cdmessage___2(d___0, (char const   *)(b___2));
          }
        }
        {
#line 1325
        reset_scsi(d___0);
        }
      }
#line 1328
      if (i > 0L) {
#line 1328
        return (i);
      }
    } else {
#line 1331
      goto while_break;
    }
#line 1334
    retry_count ++;
#line 1335
    if (sectors == 1L) {
#line 1335
      if (retry_count > 8) {
        {
#line 1336
        cderror___1(d___0, "007: Unknown, unrecoverable error reading data\n");
        }
#line 1337
        return (-7L);
      }
    }
#line 1339
    if (sectors > 1L) {
#line 1339
      sectors /= 2L;
    }
    {
#line 1340
    (*(d___0->enable_cdda))(d___0, 0);
#line 1341
    (*(d___0->enable_cdda))(d___0, 1);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1344
  return (sectors);
}
}
#line 1347 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
long scsi_read_28(cdrom_drive *d___0 , void *p___0 , long begin , long sectors ) 
{ 
  long tmp ;

  {
  {
#line 1349
  tmp = scsi_read_map(d___0, p___0, begin, sectors, & i_read_28);
  }
#line 1349
  return (tmp);
}
}
#line 1352 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
long scsi_read_A8(cdrom_drive *d___0 , void *p___0 , long begin , long sectors ) 
{ 
  long tmp ;

  {
  {
#line 1354
  tmp = scsi_read_map(d___0, p___0, begin, sectors, & i_read_A8);
  }
#line 1354
  return (tmp);
}
}
#line 1357 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
long scsi_read_D4_10(cdrom_drive *d___0 , void *p___0 , long begin , long sectors ) 
{ 
  long tmp ;

  {
  {
#line 1359
  tmp = scsi_read_map(d___0, p___0, begin, sectors, & i_read_D4_10);
  }
#line 1359
  return (tmp);
}
}
#line 1362 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
long scsi_read_D4_12(cdrom_drive *d___0 , void *p___0 , long begin , long sectors ) 
{ 
  long tmp ;

  {
  {
#line 1364
  tmp = scsi_read_map(d___0, p___0, begin, sectors, & i_read_D4_12);
  }
#line 1364
  return (tmp);
}
}
#line 1367 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
long scsi_read_D5(cdrom_drive *d___0 , void *p___0 , long begin , long sectors ) 
{ 
  long tmp ;

  {
  {
#line 1369
  tmp = scsi_read_map(d___0, p___0, begin, sectors, & i_read_D5);
  }
#line 1369
  return (tmp);
}
}
#line 1372 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
long scsi_read_D8(cdrom_drive *d___0 , void *p___0 , long begin , long sectors ) 
{ 
  long tmp ;

  {
  {
#line 1374
  tmp = scsi_read_map(d___0, p___0, begin, sectors, & i_read_D8);
  }
#line 1374
  return (tmp);
}
}
#line 1377 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
long scsi_read_mmc(cdrom_drive *d___0 , void *p___0 , long begin , long sectors ) 
{ 
  long tmp ;

  {
  {
#line 1379
  tmp = scsi_read_map(d___0, p___0, begin, sectors, & i_read_mmc);
  }
#line 1379
  return (tmp);
}
}
#line 1382 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
long scsi_read_mmc2(cdrom_drive *d___0 , void *p___0 , long begin , long sectors ) 
{ 
  long tmp ;

  {
  {
#line 1384
  tmp = scsi_read_map(d___0, p___0, begin, sectors, & i_read_mmc2);
  }
#line 1384
  return (tmp);
}
}
#line 1387 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
long scsi_read_mmc3(cdrom_drive *d___0 , void *p___0 , long begin , long sectors ) 
{ 
  long tmp ;

  {
  {
#line 1389
  tmp = scsi_read_map(d___0, p___0, begin, sectors, & i_read_mmc3);
  }
#line 1389
  return (tmp);
}
}
#line 1392 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
long scsi_read_mmcB(cdrom_drive *d___0 , void *p___0 , long begin , long sectors ) 
{ 
  long tmp ;

  {
  {
#line 1394
  tmp = scsi_read_map(d___0, p___0, begin, sectors, & i_read_mmcB);
  }
#line 1394
  return (tmp);
}
}
#line 1397 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
long scsi_read_mmc2B(cdrom_drive *d___0 , void *p___0 , long begin , long sectors ) 
{ 
  long tmp ;

  {
  {
#line 1399
  tmp = scsi_read_map(d___0, p___0, begin, sectors, & i_read_mmc2B);
  }
#line 1399
  return (tmp);
}
}
#line 1402 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
long scsi_read_mmc3B(cdrom_drive *d___0 , void *p___0 , long begin , long sectors ) 
{ 
  long tmp ;

  {
  {
#line 1404
  tmp = scsi_read_map(d___0, p___0, begin, sectors, & i_read_mmc3B);
  }
#line 1404
  return (tmp);
}
}
#line 1407 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
long scsi_read_msf(cdrom_drive *d___0 , void *p___0 , long begin , long sectors ) 
{ 
  long tmp ;

  {
  {
#line 1409
  tmp = scsi_read_map(d___0, p___0, begin, sectors, & i_read_msf);
  }
#line 1409
  return (tmp);
}
}
#line 1412 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
long scsi_read_msf2(cdrom_drive *d___0 , void *p___0 , long begin , long sectors ) 
{ 
  long tmp ;

  {
  {
#line 1414
  tmp = scsi_read_map(d___0, p___0, begin, sectors, & i_read_msf2);
  }
#line 1414
  return (tmp);
}
}
#line 1417 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
long scsi_read_msf3(cdrom_drive *d___0 , void *p___0 , long begin , long sectors ) 
{ 
  long tmp ;

  {
  {
#line 1419
  tmp = scsi_read_map(d___0, p___0, begin, sectors, & i_read_msf3);
  }
#line 1419
  return (tmp);
}
}
#line 1427 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
static int count_2352_bytes(cdrom_drive *d___0 ) 
{ 
  long i ;

  {
#line 1429
  i = 2351L;
  {
#line 1429
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1429
    if (! (i >= 0L)) {
#line 1429
      goto while_break;
    }
#line 1430
    if ((int )*((d___0->private_data)->sg_buffer + i) != 127) {
#line 1431
      return ((int )(((i + 3L) >> 2) << 2));
    }
#line 1429
    i --;
  }
  while_break: /* CIL Label */ ;
  }
#line 1433
  return (0);
}
}
#line 1436 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
static int verify_nonzero(cdrom_drive *d___0 ) 
{ 
  long i ;
  long flag ;

  {
#line 1437
  flag = 0L;
#line 1438
  i = 0L;
  {
#line 1438
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1438
    if (! (i < 2352L)) {
#line 1438
      goto while_break;
    }
#line 1439
    if ((int )*((d___0->private_data)->sg_buffer + i) != 0) {
#line 1440
      flag = 1L;
#line 1441
      goto while_break;
    }
#line 1438
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1444
  return ((int )flag);
}
}
#line 1451 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
static int verify_read_command___1(cdrom_drive *d___0 ) 
{ 
  int i ;
  int j ;
  int k ;
  int audioflag ;
  int (*enablecommand)(struct cdrom_drive *d , int speed ) ;
  long (*readcommand)(struct cdrom_drive *d , void *p , long begin , long sectors ) ;
  unsigned char density ;
  int16_t *buff ;
  void *tmp ;
  long firstsector ;
  long tmp___0 ;
  long lastsector ;
  long tmp___1 ;
  long sector ;
  int tmp___2 ;
  long tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  char *es ;
  char *rs___0 ;
  int densitypossible ;
  int densityflag ;
  int rejectflag ;
  int zeroflag ;
  int lengthflag ;
  long firstsector___0 ;
  long tmp___6 ;
  long lastsector___0 ;
  long tmp___7 ;
  long sector___0 ;
  int tmp___8 ;
  long tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  char buffer[256] ;
  char buffer___0[256] ;
  char buffer___1[256] ;

  {
  {
#line 1453
  audioflag = 0;
#line 1460
  tmp = malloc((size_t )2352);
#line 1460
  buff = (int16_t *)tmp;
#line 1462
  cdmessage___2(d___0, "Verifying CDDA command set...\n");
#line 1467
  tmp___5 = (*(d___0->enable_cdda))(d___0, 1);
  }
#line 1467
  if (tmp___5 == 0) {
#line 1469
    i = 1;
    {
#line 1469
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1469
      if (! (i <= d___0->tracks)) {
#line 1469
        goto while_break;
      }
      {
#line 1470
      tmp___4 = cdda_track_audiop(d___0, i);
      }
#line 1470
      if (tmp___4 == 1) {
        {
#line 1471
        tmp___0 = cdda_track_firstsector(d___0, i);
#line 1471
        firstsector = tmp___0;
#line 1472
        tmp___1 = cdda_track_lastsector(d___0, i);
#line 1472
        lastsector = tmp___1;
#line 1473
        sector = (firstsector + lastsector) >> 1;
#line 1474
        audioflag = 1;
#line 1476
        tmp___3 = (*(d___0->read_audio))(d___0, (void *)buff, sector, 1L);
        }
#line 1476
        if (tmp___3 > 0L) {
          {
#line 1477
          tmp___2 = count_2352_bytes(d___0);
          }
#line 1477
          if (tmp___2 == 2352) {
            {
#line 1478
            cdmessage___2(d___0, "\tExpected command set reads OK.\n");
#line 1479
            (*(d___0->enable_cdda))(d___0, 0);
#line 1480
            free((void *)buff);
            }
#line 1481
            return (0);
          }
        }
      }
#line 1469
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1487
    (*(d___0->enable_cdda))(d___0, 0);
    }
  }
#line 1489
  if (! audioflag) {
    {
#line 1490
    cdmessage___2(d___0, "\tCould not find any audio tracks on this disk.\n");
    }
#line 1491
    return (-403);
  }
  {
#line 1495
  es = (char *)"";
#line 1495
  rs___0 = (char *)"";
#line 1496
  d___0->bigendianp = -1;
#line 1497
  density = d___0->density;
#line 1498
  readcommand = d___0->read_audio;
#line 1499
  enablecommand = d___0->enable_cdda;
#line 1503
  cdmessage___2(d___0, "\tExpected command set FAILED!\n\tPerforming full probe for CDDA command set...\n");
#line 1513
  j = 0;
  }
  {
#line 1513
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1513
    if (! (j < 15)) {
#line 1513
      goto while_break___0;
    }
#line 1514
    densitypossible = 1;
    {
#line 1517
    if (j == 0) {
#line 1517
      goto case_0;
    }
#line 1521
    if (j == 1) {
#line 1521
      goto case_1;
    }
#line 1526
    if (j == 2) {
#line 1526
      goto case_2;
    }
#line 1531
    if (j == 3) {
#line 1531
      goto case_3;
    }
#line 1536
    if (j == 4) {
#line 1536
      goto case_4;
    }
#line 1542
    if (j == 5) {
#line 1542
      goto case_5;
    }
#line 1547
    if (j == 6) {
#line 1547
      goto case_6;
    }
#line 1552
    if (j == 7) {
#line 1552
      goto case_7;
    }
#line 1558
    if (j == 8) {
#line 1558
      goto case_8;
    }
#line 1563
    if (j == 9) {
#line 1563
      goto case_9;
    }
#line 1568
    if (j == 10) {
#line 1568
      goto case_10;
    }
#line 1574
    if (j == 11) {
#line 1574
      goto case_11;
    }
#line 1578
    if (j == 12) {
#line 1578
      goto case_12;
    }
#line 1582
    if (j == 13) {
#line 1582
      goto case_13;
    }
#line 1586
    if (j == 14) {
#line 1586
      goto case_14;
    }
#line 1516
    goto switch_break;
    case_0: /* CIL Label */ 
#line 1518
    d___0->read_audio = & scsi_read_28;
#line 1519
    rs___0 = (char *)"28 0x,00";
#line 1520
    goto switch_break;
    case_1: /* CIL Label */ 
#line 1522
    d___0->read_audio = & scsi_read_A8;
#line 1523
    rs___0 = (char *)"a8 0x,00";
#line 1524
    goto switch_break;
    case_2: /* CIL Label */ 
#line 1527
    d___0->read_audio = & scsi_read_mmcB;
#line 1528
    rs___0 = (char *)"be 02,10";
#line 1529
    densitypossible = 0;
#line 1530
    goto switch_break;
    case_3: /* CIL Label */ 
#line 1532
    d___0->read_audio = & scsi_read_mmc2B;
#line 1533
    rs___0 = (char *)"be 02,f8";
#line 1534
    densitypossible = 0;
#line 1535
    goto switch_break;
    case_4: /* CIL Label */ 
#line 1537
    d___0->read_audio = & scsi_read_mmc3B;
#line 1538
    rs___0 = (char *)"be 06,f8";
#line 1539
    densitypossible = 0;
#line 1540
    goto switch_break;
    case_5: /* CIL Label */ 
#line 1543
    d___0->read_audio = & scsi_read_mmc;
#line 1544
    rs___0 = (char *)"be 00,10";
#line 1545
    densitypossible = 0;
#line 1546
    goto switch_break;
    case_6: /* CIL Label */ 
#line 1548
    d___0->read_audio = & scsi_read_mmc2;
#line 1549
    rs___0 = (char *)"be 00,f8";
#line 1550
    densitypossible = 0;
#line 1551
    goto switch_break;
    case_7: /* CIL Label */ 
#line 1553
    d___0->read_audio = & scsi_read_mmc3;
#line 1554
    rs___0 = (char *)"be 04,f8";
#line 1555
    densitypossible = 0;
#line 1556
    goto switch_break;
    case_8: /* CIL Label */ 
#line 1559
    d___0->read_audio = & scsi_read_msf;
#line 1560
    rs___0 = (char *)"b9 00,10";
#line 1561
    densitypossible = 0;
#line 1562
    goto switch_break;
    case_9: /* CIL Label */ 
#line 1564
    d___0->read_audio = & scsi_read_msf2;
#line 1565
    rs___0 = (char *)"b9 00,f8";
#line 1566
    densitypossible = 0;
#line 1567
    goto switch_break;
    case_10: /* CIL Label */ 
#line 1569
    d___0->read_audio = & scsi_read_msf3;
#line 1570
    rs___0 = (char *)"b9 04,f8";
#line 1571
    densitypossible = 0;
#line 1572
    goto switch_break;
    case_11: /* CIL Label */ 
#line 1575
    d___0->read_audio = & scsi_read_D4_10;
#line 1576
    rs___0 = (char *)"d4(10)0x";
#line 1577
    goto switch_break;
    case_12: /* CIL Label */ 
#line 1579
    d___0->read_audio = & scsi_read_D4_12;
#line 1580
    rs___0 = (char *)"d4(12)0x";
#line 1581
    goto switch_break;
    case_13: /* CIL Label */ 
#line 1583
    d___0->read_audio = & scsi_read_D5;
#line 1584
    rs___0 = (char *)"d5 0x,00";
#line 1585
    goto switch_break;
    case_14: /* CIL Label */ 
#line 1587
    d___0->read_audio = & scsi_read_D8;
#line 1588
    rs___0 = (char *)"d8 0x,00";
#line 1589
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 1592
    i = 0;
    {
#line 1592
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1592
      if (! (i < 5)) {
#line 1592
        goto while_break___1;
      }
      {
#line 1594
      if (i == 0) {
#line 1594
        goto case_0___0;
      }
#line 1600
      if (i == 1) {
#line 1600
        goto case_1___0;
      }
#line 1605
      if (i == 2) {
#line 1605
        goto case_2___0;
      }
#line 1610
      if (i == 3) {
#line 1610
        goto case_3___0;
      }
#line 1615
      if (i == 4) {
#line 1615
        goto case_4___0;
      }
#line 1593
      goto switch_break___0;
      case_0___0: /* CIL Label */ 
#line 1595
      d___0->density = (unsigned char)0;
#line 1596
      d___0->enable_cdda = & Dummy___1;
#line 1597
      es = (char *)"none    ";
#line 1598
      if (! densitypossible) {
#line 1598
        i = 5;
      }
#line 1599
      goto switch_break___0;
      case_1___0: /* CIL Label */ 
#line 1601
      d___0->density = (unsigned char)0;
#line 1602
      d___0->enable_cdda = & scsi_enable_cdda;
#line 1603
      es = (char *)"yes/0x00";
#line 1604
      goto switch_break___0;
      case_2___0: /* CIL Label */ 
#line 1606
      d___0->density = (unsigned char)4;
#line 1607
      d___0->enable_cdda = & scsi_enable_cdda;
#line 1608
      es = (char *)"yes/0x04";
#line 1609
      goto switch_break___0;
      case_3___0: /* CIL Label */ 
#line 1611
      d___0->density = (unsigned char)130;
#line 1612
      d___0->enable_cdda = & scsi_enable_cdda;
#line 1613
      es = (char *)"yes/0x82";
#line 1614
      goto switch_break___0;
      case_4___0: /* CIL Label */ 
#line 1616
      d___0->density = (unsigned char)129;
#line 1617
      d___0->enable_cdda = & scsi_enable_cdda;
#line 1618
      es = (char *)"yes/0x81";
#line 1619
      goto switch_break___0;
      switch_break___0: /* CIL Label */ ;
      }
      {
#line 1622
      cdmessage___2(d___0, "\ttest -> density: [");
#line 1623
      cdmessage___2(d___0, (char const   *)es);
#line 1624
      cdmessage___2(d___0, "]  command: [");
#line 1625
      cdmessage___2(d___0, (char const   *)rs___0);
#line 1626
      cdmessage___2(d___0, "]\n");
#line 1629
      densityflag = 0;
#line 1630
      rejectflag = 0;
#line 1631
      zeroflag = 0;
#line 1632
      lengthflag = 0;
#line 1634
      tmp___11 = (*(d___0->enable_cdda))(d___0, 1);
      }
#line 1634
      if (tmp___11 == 0) {
#line 1635
        k = 1;
        {
#line 1635
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 1635
          if (! (k <= d___0->tracks)) {
#line 1635
            goto while_break___2;
          }
          {
#line 1636
          tmp___10 = cdda_track_audiop(d___0, k);
          }
#line 1636
          if (tmp___10 == 1) {
            {
#line 1637
            tmp___6 = cdda_track_firstsector(d___0, k);
#line 1637
            firstsector___0 = tmp___6;
#line 1638
            tmp___7 = cdda_track_lastsector(d___0, k);
#line 1638
            lastsector___0 = tmp___7;
#line 1639
            sector___0 = (firstsector___0 + lastsector___0) >> 1;
#line 1641
            tmp___9 = (*(d___0->read_audio))(d___0, (void *)buff, sector___0, 1L);
            }
#line 1641
            if (tmp___9 > 0L) {
              {
#line 1642
              lengthflag = count_2352_bytes(d___0);
              }
#line 1642
              if (lengthflag == 2352) {
                {
#line 1643
                tmp___8 = verify_nonzero(d___0);
                }
#line 1643
                if (tmp___8) {
                  {
#line 1644
                  cdmessage___2(d___0, "\t\tCommand set FOUND!\n");
#line 1646
                  free((void *)buff);
#line 1647
                  (*(d___0->enable_cdda))(d___0, 0);
                  }
#line 1648
                  return (0);
                } else {
#line 1650
                  zeroflag ++;
                }
              }
            } else {
#line 1654
              rejectflag ++;
#line 1655
              goto while_break___2;
            }
          }
#line 1635
          k ++;
        }
        while_break___2: /* CIL Label */ ;
        }
        {
#line 1659
        (*(d___0->enable_cdda))(d___0, 0);
        }
      } else {
#line 1661
        densityflag ++;
      }
#line 1664
      if (densityflag) {
        {
#line 1665
        cdmessage___2(d___0, "\t\tDrive rejected density set\n");
        }
      }
#line 1666
      if (rejectflag) {
        {
#line 1668
        sprintf((char */* __restrict  */)(buffer), (char const   */* __restrict  */)"\t\tDrive rejected read command packet(s)\n");
#line 1669
        cdmessage___2(d___0, (char const   *)(buffer));
        }
      }
#line 1671
      if (lengthflag > 0) {
#line 1671
        if (lengthflag < 2352) {
          {
#line 1673
          sprintf((char */* __restrict  */)(buffer___0), (char const   */* __restrict  */)"\t\tDrive returned at least one packet, but with\n\t\tincorrect size (%d)\n",
                  lengthflag);
#line 1675
          cdmessage___2(d___0, (char const   *)(buffer___0));
          }
        }
      }
#line 1677
      if (zeroflag) {
        {
#line 1679
        sprintf((char */* __restrict  */)(buffer___1), (char const   */* __restrict  */)"\t\tDrive returned %d packet(s), but contents\n\t\twere entirely zero\n",
                zeroflag);
#line 1681
        cdmessage___2(d___0, (char const   *)(buffer___1));
        }
      }
#line 1592
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1513
    j ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1688
  d___0->density = density;
#line 1689
  d___0->read_audio = readcommand;
#line 1690
  d___0->enable_cdda = enablecommand;
#line 1692
  cdmessage___2(d___0, "\tUnable to find any suitable command set from probe;\n\tdrive probably not CDDA capable.\n");
#line 1695
  cderror___1(d___0, "006: Could not read any data from drive\n");
#line 1698
  free((void *)buff);
  }
#line 1699
  return (-6);
}
}
#line 1702 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
static void check_cache(cdrom_drive *d___0 ) 
{ 
  long i ;
  long firstsector ;
  long tmp ;
  long lastsector ;
  long tmp___0 ;
  long sector ;
  long tmp___1 ;
  int tmp___2 ;

  {
#line 1705
  if (! ((unsigned long )d___0->read_audio == (unsigned long )(& scsi_read_mmc))) {
#line 1705
    if (! ((unsigned long )d___0->read_audio == (unsigned long )(& scsi_read_mmc2))) {
#line 1705
      if (! ((unsigned long )d___0->read_audio == (unsigned long )(& scsi_read_mmc3))) {
#line 1705
        if (! ((unsigned long )d___0->read_audio == (unsigned long )(& scsi_read_mmcB))) {
#line 1705
          if (! ((unsigned long )d___0->read_audio == (unsigned long )(& scsi_read_mmc2B))) {
#line 1705
            if (! ((unsigned long )d___0->read_audio == (unsigned long )(& scsi_read_mmc3B))) {
              {
#line 1712
              cdmessage___2(d___0, "This command set may use a Force Unit Access bit.");
#line 1713
              cdmessage___2(d___0, "\nChecking drive for FUA bit support...\n");
#line 1715
              (*(d___0->enable_cdda))(d___0, 1);
#line 1716
              d___0->fua = 1;
#line 1718
              i = 1L;
              }
              {
#line 1718
              while (1) {
                while_continue: /* CIL Label */ ;
#line 1718
                if (! (i <= (long )d___0->tracks)) {
#line 1718
                  goto while_break;
                }
                {
#line 1719
                tmp___2 = cdda_track_audiop(d___0, (int )i);
                }
#line 1719
                if (tmp___2 == 1) {
                  {
#line 1720
                  tmp = cdda_track_firstsector(d___0, (int )i);
#line 1720
                  firstsector = tmp;
#line 1721
                  tmp___0 = cdda_track_lastsector(d___0, (int )i);
#line 1721
                  lastsector = tmp___0;
#line 1722
                  sector = (firstsector + lastsector) >> 1;
#line 1724
                  tmp___1 = (*(d___0->read_audio))(d___0, (void *)0, sector, 1L);
                  }
#line 1724
                  if (tmp___1 > 0L) {
                    {
#line 1725
                    cdmessage___2(d___0, "\tDrive accepted FUA bit.\n");
#line 1726
                    (*(d___0->enable_cdda))(d___0, 0);
                    }
#line 1727
                    return;
                  }
                }
#line 1718
                i ++;
              }
              while_break: /* CIL Label */ ;
              }
              {
#line 1732
              d___0->fua = 0;
#line 1733
              cdmessage___2(d___0, "\tDrive rejected FUA bit.\n");
              }
#line 1738
              return;
            }
          }
        }
      }
    }
  }
#line 1740
  return;
}
}
#line 1743 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
static int check_atapi(cdrom_drive *d___0 ) 
{ 
  int atapiret ;
  int fd ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 1744
  atapiret = -1;
#line 1745
  fd = d___0->cdda_fd;
#line 1747
  cdmessage___2(d___0, "\nChecking for SCSI emulation...\n");
#line 1749
  tmp___0 = ioctl(fd, 8707UL, & atapiret);
  }
#line 1749
  if (tmp___0) {
    {
#line 1750
    cderror___1(d___0, "\tSG_EMULATED_HOST ioctl() failed!\n");
    }
#line 1751
    return (-1);
  } else {
#line 1753
    if (atapiret == 1) {
#line 1754
      if (d___0->interface == 3) {
        {
#line 1755
        cdmessage___2(d___0, "\tDrive is ATAPI (using SG_IO host adaptor emulation)\n");
        }
      } else
#line 1756
      if (d___0->interface == 4) {
        {
#line 1757
        cdmessage___2(d___0, "\tDrive is ATAPI (using SG_IO host adaptor emulation with workarounds)\n");
        }
      } else {
        {
#line 1759
        cdmessage___2(d___0, "\tDrive is ATAPI (using SCSI host adaptor emulation)\n");
#line 1761
        tmp = ioctl(fd, 8708UL, 0);
        }
#line 1761
        if (tmp) {
          {
#line 1762
          cderror___1(d___0, "\tCouldn\'t disable kernel command translation layer\n");
          }
        }
      }
#line 1764
      d___0->is_atapi = 1;
    } else {
      {
#line 1766
      cdmessage___2(d___0, "\tDrive is SCSI\n");
#line 1767
      d___0->is_atapi = 0;
      }
    }
#line 1770
    return (d___0->is_atapi);
  }
}
}
#line 1815 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
static int check_mmc(cdrom_drive *d___0 ) 
{ 
  unsigned char *b ;
  int tmp ;

  {
  {
#line 1817
  cdmessage___2(d___0, "\nChecking for MMC style command set...\n");
#line 1819
  d___0->is_mmc = 0;
#line 1820
  tmp = mode_sense(d___0, 22, 42);
  }
#line 1820
  if (tmp == 0) {
#line 1822
    b = (d___0->private_data)->sg_buffer;
#line 1823
    b += (int )*(b + 3) + 4;
#line 1825
    if (((int )*(b + 0) & 63) == 42) {
#line 1827
      d___0->is_mmc = 1;
#line 1829
      if ((int )*(b + 1) >= 4) {
#line 1830
        if ((int )*(b + 5) & 1) {
          {
#line 1831
          cdmessage___2(d___0, "\tDrive is MMC style\n");
          }
#line 1832
          return (1);
        } else {
          {
#line 1834
          cdmessage___2(d___0, "\tDrive is MMC, but reports CDDA incapable.\n");
#line 1835
          cdmessage___2(d___0, "\tIt will likely not be able to read audio data.\n");
          }
#line 1836
          return (1);
        }
      }
    }
  }
  {
#line 1842
  cdmessage___2(d___0, "\tDrive does not have MMC CDDA support\n");
  }
#line 1843
  return (0);
}
}
#line 1846 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
static void check_exceptions___1(cdrom_drive *d___0 , exception *list ) 
{ 
  int i ;
  size_t tmp ;
  int tmp___0 ;

  {
#line 1848
  i = 0;
  {
#line 1849
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1849
    if (! (list + i)->model) {
#line 1849
      goto while_break;
    }
    {
#line 1850
    tmp = strlen((char const   *)(list + i)->model);
#line 1850
    tmp___0 = strncmp((char const   *)(list + i)->model, (char const   *)d___0->drive_model,
                      tmp);
    }
#line 1850
    if (! tmp___0) {
#line 1851
      if ((list + i)->density) {
#line 1851
        d___0->density = (list + i)->density;
      }
#line 1852
      if ((list + i)->enable) {
#line 1852
        d___0->enable_cdda = (list + i)->enable;
      }
#line 1853
      if ((list + i)->read) {
#line 1853
        d___0->read_audio = (list + i)->read;
      }
#line 1854
      if ((list + i)->bigendianp != -1) {
#line 1854
        d___0->bigendianp = (list + i)->bigendianp;
      }
#line 1855
      return;
    }
#line 1857
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1859
  return;
}
}
#line 1863 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
unsigned char *scsi_inquiry(cdrom_drive *d___0 ) 
{ 
  unsigned char sense[16] ;
  unsigned char cmd[6] ;
  int tmp ;

  {
  {
#line 1865
  cmd[0] = (unsigned char)18;
#line 1865
  cmd[1] = (unsigned char)0;
#line 1865
  cmd[2] = (unsigned char)0;
#line 1865
  cmd[3] = (unsigned char)0;
#line 1865
  cmd[4] = (unsigned char)56;
#line 1865
  cmd[5] = (unsigned char)0;
#line 1867
  tmp = handle_scsi_cmd(d___0, cmd, 6U, 0U, 56U, (unsigned char )'\377', 1, sense);
  }
#line 1867
  if (tmp) {
    {
#line 1868
    cderror___1(d___0, "008: Unable to identify CDROM model\n");
    }
#line 1869
    return ((unsigned char *)((void *)0));
  }
#line 1871
  return ((d___0->private_data)->sg_buffer);
}
}
#line 1875 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
int scsi_init_drive(cdrom_drive *d___0 ) 
{ 
  int ret ;
  int tmp___0 ;
  unsigned int sector_size ;
  unsigned int tmp___1 ;
  int tmp___2 ;
  void *tmp___3 ;

  {
  {
#line 1878
  check_atapi(d___0);
#line 1879
  check_mmc(d___0);
#line 1882
  d___0->density = (unsigned char)0;
#line 1883
  d___0->enable_cdda = & Dummy___1;
#line 1884
  d___0->read_audio = & scsi_read_D8;
#line 1885
  d___0->fua = 0;
  }
#line 1886
  if (d___0->is_atapi) {
#line 1886
    d___0->lun = 0;
  }
#line 1888
  if (d___0->is_mmc) {
    {
#line 1890
    d___0->read_audio = & scsi_read_mmc2B;
#line 1891
    d___0->bigendianp = 0;
#line 1893
    check_exceptions___1(d___0, mmc_list);
    }
  } else
#line 1897
  if (d___0->is_atapi) {
    {
#line 1900
    d___0->read_audio = & scsi_read_mmc2B;
#line 1901
    d___0->bigendianp = 0;
#line 1903
    check_exceptions___1(d___0, atapi_list___1);
    }
  } else {
    {
#line 1907
    check_exceptions___1(d___0, scsi_list);
    }
  }
#line 1912
  if (! d___0->is_atapi) {
    {
#line 1912
    set_sectorsize(d___0, 2048U);
    }
  }
  {
#line 1914
  (*(d___0->enable_cdda))(d___0, 0);
#line 1916
  tmp___0 = memcmp((void const   *)d___0->drive_model, (void const   *)"IMS", (size_t )3);
  }
#line 1916
  if (tmp___0) {
#line 1916
    d___0->read_toc = & scsi_read_toc;
  } else
#line 1916
  if (! d___0->is_atapi) {
#line 1916
    d___0->read_toc = & scsi_read_toc2;
  } else {
#line 1916
    d___0->read_toc = & scsi_read_toc;
  }
#line 1918
  d___0->set_speed = & scsi_set_speed;
#line 1920
  if (! d___0->is_atapi) {
    {
#line 1921
    tmp___1 = get_orig_sectorsize(d___0);
#line 1921
    sector_size = tmp___1;
    }
#line 1923
    if (sector_size < 2048U) {
      {
#line 1923
      tmp___2 = set_sectorsize(d___0, 2048U);
      }
#line 1923
      if (tmp___2) {
#line 1924
        d___0->adjust_ssize = (int )(2048U / sector_size);
      } else {
#line 1926
        d___0->adjust_ssize = 1;
      }
    } else {
#line 1926
      d___0->adjust_ssize = 1;
    }
  } else {
#line 1928
    d___0->adjust_ssize = 1;
  }
  {
#line 1930
  d___0->tracks = (*(d___0->read_toc))(d___0);
  }
#line 1931
  if (d___0->tracks < 1) {
#line 1932
    return (d___0->tracks);
  }
  {
#line 1934
  tweak_SG_buffer(d___0);
#line 1935
  d___0->opened = 1;
#line 1937
  ret = verify_read_command___1(d___0);
  }
#line 1937
  if (ret) {
#line 1937
    return (ret);
  }
  {
#line 1938
  check_cache(d___0);
#line 1940
  d___0->error_retry = 1;
#line 1942
  tmp___3 = realloc((void *)(d___0->private_data)->sg_hd, ((unsigned long )(d___0->nsectors * 2352) + sizeof(struct sg_header )) + 128UL);
#line 1942
  (d___0->private_data)->sg_hd = (struct sg_header *)tmp___3;
#line 1943
  (d___0->private_data)->sg_buffer = (unsigned char *)(d___0->private_data)->sg_hd + sizeof(struct sg_header );
#line 1947
  d___0->report_all = 1;
  }
#line 1948
  return (0);
}
}
#line 163 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/cdda_interface.h"
static char *strerror_tr___0[12]  = 
#line 163 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/cdda_interface.h"
  {      (char *)"Success",      (char *)"Error writing packet command to device",      (char *)"Error reading command from device",      (char *)"SCSI packet data underrun (too little data)", 
        (char *)"SCSI packet data overrun (too much data)",      (char *)"Illegal SCSI request (rejected by target)",      (char *)"Medium reading data from medium",      (char *)"Device busy", 
        (char *)"Device not ready",      (char *)"Target hardware fault",      (char *)"Unspecified error",      (char *)"Drive lost streaming"};
#line 109 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/utils.h"
static void cderror___2(cdrom_drive *d___0 , char const   *s ) 
{ 
  size_t tmp ;

  {
#line 110
  if (s) {
#line 110
    if (d___0) {
      {
#line 112
      if (d___0->errordest == 1) {
#line 112
        goto case_1;
      }
#line 115
      if (d___0->errordest == 2) {
#line 115
        goto case_2;
      }
#line 119
      goto switch_default;
      case_1: /* CIL Label */ 
      {
#line 113
      tmp = strlen(s);
#line 113
      write(2, (void const   *)s, tmp);
      }
#line 114
      goto switch_break;
      case_2: /* CIL Label */ 
      {
#line 116
      d___0->errorbuf = catstring(d___0->errorbuf, s);
      }
#line 117
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 120
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
  }
#line 123
  return;
}
}
#line 125 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/utils.h"
static void cdmessage___3(cdrom_drive *d___0 , char const   *s ) 
{ 
  size_t tmp ;

  {
#line 126
  if (s) {
#line 126
    if (d___0) {
      {
#line 128
      if (d___0->messagedest == 1) {
#line 128
        goto case_1;
      }
#line 131
      if (d___0->messagedest == 2) {
#line 131
        goto case_2;
      }
#line 135
      goto switch_default;
      case_1: /* CIL Label */ 
      {
#line 129
      tmp = strlen(s);
#line 129
      write(2, (void const   *)s, tmp);
      }
#line 130
      goto switch_break;
      case_2: /* CIL Label */ 
      {
#line 132
      d___0->messagebuf = catstring(d___0->messagebuf, s);
      }
#line 133
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 136
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
  }
#line 139
  return;
}
}
#line 20 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
static int timed_ioctl___2(cdrom_drive *d___0 , int fd , int command , void *arg ) 
{ 
  struct timespec tv1 ;
  struct timespec tv2 ;
  int ret1 ;
  int tmp ;
  int ret2 ;
  int tmp___0 ;
  int ret3 ;
  int tmp___1 ;

  {
  {
#line 23
  tmp = clock_gettime((d___0->private_data)->clock, & tv1);
#line 23
  ret1 = tmp;
#line 24
  tmp___0 = ioctl(fd, (unsigned long )command, arg);
#line 24
  ret2 = tmp___0;
#line 25
  tmp___1 = clock_gettime((d___0->private_data)->clock, & tv2);
#line 25
  ret3 = tmp___1;
  }
#line 26
  if (ret1 < 0) {
#line 27
    (d___0->private_data)->last_milliseconds = -1;
  } else
#line 26
  if (ret3 < 0) {
#line 27
    (d___0->private_data)->last_milliseconds = -1;
  } else {
#line 29
    (d___0->private_data)->last_milliseconds = (int )((double )(tv2.tv_sec - tv1.tv_sec) * 1000. + (double )(tv2.tv_nsec - tv1.tv_nsec) / 1000000.);
  }
#line 31
  return (ret2);
}
}
#line 35 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
static int Dummy___2(cdrom_drive *d___0 , int s ) 
{ 


  {
#line 36
  return (0);
}
}
#line 24 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/drive_exceptions.h"
static exception atapi_list___2[5]  = {      {(char *)"SAMSUNG SCR-830 REV 2.09 2.09 ", 1, (unsigned char)0, & Dummy___2,
      & scsi_read_mmc2, 0}, 
        {(char *)"Memorex CR-622", 1, (unsigned char)0, & Dummy___2, (long (*)(struct cdrom_drive * ,
                                                                            void * ,
                                                                            long  ,
                                                                            long  ))((void *)0),
      0}, 
        {(char *)"SONY CD-ROM CDU-561", 0, (unsigned char)0, & Dummy___2, (long (*)(struct cdrom_drive * ,
                                                                                 void * ,
                                                                                 long  ,
                                                                                 long  ))((void *)0),
      0}, 
        {(char *)"Chinon CD-ROM CDS-525", 0, (unsigned char)0, & Dummy___2, (long (*)(struct cdrom_drive * ,
                                                                                   void * ,
                                                                                   long  ,
                                                                                   long  ))((void *)0),
      0}, 
        {(char *)((void *)0), 0, (unsigned char)0, (int (*)(struct cdrom_drive * , int  ))((void *)0),
      (long (*)(struct cdrom_drive * , void * , long  , long  ))((void *)0), 0}};
#line 33 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/drive_exceptions.h"
static exception mmc_list___0[6]  = {      {(char *)"SAMSUNG SCR-830 REV 2.09 2.09 ", 1, (unsigned char)0, & Dummy___2,
      & scsi_read_mmc2, 0}, 
        {(char *)"Memorex CR-622", 1, (unsigned char)0, & Dummy___2, (long (*)(struct cdrom_drive * ,
                                                                            void * ,
                                                                            long  ,
                                                                            long  ))((void *)0),
      0}, 
        {(char *)"SONY CD-ROM CDU-561", 0, (unsigned char)0, & Dummy___2, (long (*)(struct cdrom_drive * ,
                                                                                 void * ,
                                                                                 long  ,
                                                                                 long  ))((void *)0),
      0}, 
        {(char *)"Chinon CD-ROM CDS-525", 0, (unsigned char)0, & Dummy___2, (long (*)(struct cdrom_drive * ,
                                                                                   void * ,
                                                                                   long  ,
                                                                                   long  ))((void *)0),
      0}, 
        {(char *)"KENWOOD CD-ROM UCR", -1, (unsigned char)0, (int (*)(struct cdrom_drive * ,
                                                                   int  ))((void *)0),
      & scsi_read_D8, 0}, 
        {(char *)((void *)0), 0, (unsigned char)0, (int (*)(struct cdrom_drive * , int  ))((void *)0),
      (long (*)(struct cdrom_drive * , void * , long  , long  ))((void *)0), 0}};
#line 43 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/drive_exceptions.h"
static exception scsi_list___0[18]  = 
#line 43
  {      {(char *)"TOSHIBA", -1, (unsigned char)130, & scsi_enable_cdda, & scsi_read_28,
      0}, 
        {(char *)"IBM", -1, (unsigned char)130, & scsi_enable_cdda, & scsi_read_28, 0}, 
        {(char *)"DEC",
      -1, (unsigned char)130, & scsi_enable_cdda, & scsi_read_28, 0}, 
        {(char *)"IMS", -1, (unsigned char)0, & scsi_enable_cdda, & scsi_read_28, 1}, 
        {(char *)"KODAK",
      -1, (unsigned char)0, & scsi_enable_cdda, & scsi_read_28, 1}, 
        {(char *)"RICOH", -1, (unsigned char)0, & scsi_enable_cdda, & scsi_read_28, 1}, 
        {(char *)"HP",
      -1, (unsigned char)0, & scsi_enable_cdda, & scsi_read_28, 1}, 
        {(char *)"PHILIPS", -1, (unsigned char)0, & scsi_enable_cdda, & scsi_read_28,
      1}, 
        {(char *)"PLASMON", -1, (unsigned char)0, & scsi_enable_cdda, & scsi_read_28,
      1}, 
        {(char *)"GRUNDIG CDR100IPW", -1, (unsigned char)0, & scsi_enable_cdda, & scsi_read_28,
      1}, 
        {(char *)"MITSUMI CD-R ", -1, (unsigned char)0, & scsi_enable_cdda, & scsi_read_28,
      1}, 
        {(char *)"KENWOOD CD-ROM UCR", -1, (unsigned char)0, (int (*)(struct cdrom_drive * ,
                                                                   int  ))((void *)0),
      & scsi_read_D8, 0}, 
        {(char *)"YAMAHA", -1, (unsigned char)0, & scsi_enable_cdda, (long (*)(struct cdrom_drive * ,
                                                                            void * ,
                                                                            long  ,
                                                                            long  ))((void *)0),
      0}, 
        {(char *)"PLEXTOR", -1, (unsigned char)0, (int (*)(struct cdrom_drive * , int  ))((void *)0),
      (long (*)(struct cdrom_drive * , void * , long  , long  ))((void *)0), 0}, 
        {(char *)"SONY", -1, (unsigned char)0, (int (*)(struct cdrom_drive * , int  ))((void *)0),
      (long (*)(struct cdrom_drive * , void * , long  , long  ))((void *)0), 0}, 
        {(char *)"NEC", -1, (unsigned char)0, (int (*)(struct cdrom_drive * , int  ))((void *)0),
      & scsi_read_D4_10, 0}, 
        {(char *)"MATSHITA CD-R   CW-7501", -1, (unsigned char)0, (int (*)(struct cdrom_drive * ,
                                                                        int  ))((void *)0),
      & scsi_read_D4_12, -1}, 
        {(char *)((void *)0), 0, (unsigned char)0, (int (*)(struct cdrom_drive * , int  ))((void *)0),
      (long (*)(struct cdrom_drive * , void * , long  , long  ))((void *)0), 0}};
#line 40 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
static void tweak_SG_buffer___0(cdrom_drive *d___0 ) 
{ 
  int table ;
  int reserved ;
  int cur ;
  int err ;
  char buffer[256] ;
  int tmp ;
  char *tmp___0 ;

  {
#line 52
  cur = 1;
  {
#line 53
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 54
    cur <<= 1;
#line 54
    reserved = cur * (1 << 9);
#line 55
    err = ioctl(d___0->cdda_fd, 8821UL, & reserved);
    }
#line 53
    if (err >= 0) {
#line 53
      if (! (cur * (1 << 9) < 1073741824)) {
#line 53
        goto while_break;
      }
    } else {
#line 53
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 57
  ioctl(d___0->cdda_fd, 8818UL, & reserved);
#line 61
  tmp = ioctl(d___0->cdda_fd, 8831UL, & table);
  }
#line 61
  if (tmp < 0) {
#line 62
    table = 1;
  }
  {
#line 64
  sprintf((char */* __restrict  */)(buffer), (char const   */* __restrict  */)"\tDMA scatter/gather table entries: %d\n\ttable entry size: %d bytes\n\tmaximum theoretical transfer: %d sectors\n",
          table, reserved, table * (reserved / 2352));
#line 69
  cdmessage___3(d___0, (char const   *)(buffer));
#line 71
  cur = reserved;
#line 85
  tmp___0 = getenv("CDDA_IGNORE_BUFSIZE_LIMIT");
  }
#line 85
  if (tmp___0) {
    {
#line 88
    cdmessage___3(d___0, "\tEnvironment variable CDDA_IGNORE_BUFSIZE_LIMIT set,\n\t\tforcing maximum possible sector size.  This can break\n\t\tspectacularly; use with caution!\n");
    }
  } else
#line 86
  if (cur > 65536) {
#line 86
    cur = 65536;
  } else {
#line 86
    cur = cur;
  }
  {
#line 92
  d___0->nsectors = cur / 2352;
#line 93
  d___0->bigbuff = (long )cur;
#line 95
  sprintf((char */* __restrict  */)(buffer), (char const   */* __restrict  */)"\tSetting default read size to %d sectors (%d bytes).\n\n",
          d___0->nsectors, d___0->nsectors * 2352);
  }
#line 98
  if (cur == 0) {
    {
#line 98
    exit(1);
    }
  }
  {
#line 108
  cdmessage___3(d___0, (char const   *)(buffer));
  }
#line 109
  return;
}
}
#line 113 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
static void clear_garbage___0(cdrom_drive *d___0 ) 
{ 
  fd_set fdset ;
  struct timeval tv ;
  struct sg_header *sg_hd ;
  int flag ;
  int __d0 ;
  int __d1 ;
  int __d0___0 ;
  int __d1___0 ;
  int tmp ;

  {
#line 116
  sg_hd = (d___0->private_data)->sg_hd;
#line 117
  flag = 0;
  {
#line 120
  while (1) {
    while_continue: /* CIL Label */ ;
#line 120
    __asm__  volatile   ("cld; rep; "
                         "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                         "1" (& fdset.__fds_bits[0]): "memory");
#line 120
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 121
  fdset.__fds_bits[d___0->cdda_fd / (8 * (int )sizeof(__fd_mask ))] |= 1L << d___0->cdda_fd % (8 * (int )sizeof(__fd_mask ));
#line 122
  tv.tv_sec = (__time_t )0;
#line 123
  tv.tv_usec = (__suseconds_t )0;
  {
#line 126
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 126
    tmp = select(d___0->cdda_fd + 1, (fd_set */* __restrict  */)(& fdset), (fd_set */* __restrict  */)((void *)0),
                 (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)(& tv));
    }
#line 126
    if (! (tmp == 1)) {
#line 126
      goto while_break___0;
    }
    {
#line 128
    sg_hd->twelve_byte = 0U;
#line 129
    sg_hd->result = 0;
#line 130
    sg_hd->reply_len = (int )sizeof(struct sg_header );
#line 131
    read(d___0->cdda_fd, (void *)sg_hd, (size_t )1);
    }
    {
#line 134
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 134
      __asm__  volatile   ("cld; rep; "
                           "stosq": "=c" (__d0___0), "=D" (__d1___0): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                           "1" (& fdset.__fds_bits[0]): "memory");
#line 134
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 135
    fdset.__fds_bits[d___0->cdda_fd / (8 * (int )sizeof(__fd_mask ))] |= 1L << d___0->cdda_fd % (8 * (int )sizeof(__fd_mask ));
#line 136
    tv.tv_sec = (__time_t )0;
#line 137
    tv.tv_usec = (__suseconds_t )0;
#line 138
    if (! flag) {
#line 138
      if (d___0->report_all) {
        {
#line 139
        cdmessage___3(d___0, "Clearing previously returned data from SCSI buffer\n");
        }
      }
    }
#line 140
    flag = 1;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 142
  return;
}
}
#line 145 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
static int check_sbp_error___0(unsigned char const   status , unsigned char const   *sbp ) 
{ 
  char key ;
  char ASC ;
  char ASCQ ;
  int *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  int *tmp___5 ;
  int *tmp___6 ;
  int *tmp___7 ;
  int *tmp___8 ;
  int *tmp___9 ;
  int *tmp___10 ;
  int *tmp___11 ;

  {
#line 147
  key = (char )((int const   )*(sbp + 2) & 15);
#line 148
  ASC = (char )*(sbp + 12);
#line 149
  ASCQ = (char )*(sbp + 13);
#line 151
  if ((int const   )status == 0) {
#line 151
    return (0);
  }
#line 152
  if ((int const   )status == 8) {
#line 152
    return (7);
  }
#line 154
  if (*(sbp + 0)) {
    {
#line 156
    if ((int )key == 0) {
#line 156
      goto case_0;
    }
#line 160
    if ((int )key == 1) {
#line 160
      goto case_1;
    }
#line 162
    if ((int )key == 2) {
#line 162
      goto case_2;
    }
#line 169
    if ((int )key == 3) {
#line 169
      goto case_3;
    }
#line 180
    if ((int )key == 4) {
#line 180
      goto case_4;
    }
#line 184
    if ((int )key == 5) {
#line 184
      goto case_5;
    }
#line 188
    goto switch_default;
    case_0: /* CIL Label */ 
    {
#line 157
    tmp___0 = __errno_location();
    }
#line 157
    if (*tmp___0 == 0) {
      {
#line 158
      tmp = __errno_location();
#line 158
      *tmp = 5;
      }
    }
#line 159
    return (10);
    case_1: /* CIL Label */ 
#line 161
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 164
    tmp___1 = __errno_location();
#line 164
    *tmp___1 = 123;
    }
#line 168
    return (8);
    case_3: /* CIL Label */ 
#line 170
    if (((int )ASC == 12) & ((int )ASCQ == 9)) {
      {
#line 172
      tmp___3 = __errno_location();
      }
#line 172
      if (*tmp___3 == 0) {
        {
#line 173
        tmp___2 = __errno_location();
#line 173
        *tmp___2 = 5;
        }
      }
#line 174
      return (11);
    } else {
      {
#line 176
      tmp___5 = __errno_location();
      }
#line 176
      if (*tmp___5 == 0) {
        {
#line 177
        tmp___4 = __errno_location();
#line 177
        *tmp___4 = 5;
        }
      }
#line 178
      return (6);
    }
    case_4: /* CIL Label */ 
    {
#line 181
    tmp___7 = __errno_location();
    }
#line 181
    if (*tmp___7 == 0) {
      {
#line 182
      tmp___6 = __errno_location();
#line 182
      *tmp___6 = 5;
      }
    }
#line 183
    return (9);
    case_5: /* CIL Label */ 
    {
#line 185
    tmp___9 = __errno_location();
    }
#line 185
    if (*tmp___9 == 0) {
      {
#line 186
      tmp___8 = __errno_location();
#line 186
      *tmp___8 = 22;
      }
    }
#line 187
    return (5);
    switch_default: /* CIL Label */ 
    {
#line 189
    tmp___11 = __errno_location();
    }
#line 189
    if (*tmp___11 == 0) {
      {
#line 190
      tmp___10 = __errno_location();
#line 190
      *tmp___10 = 5;
      }
    }
#line 191
    return (10);
    switch_break: /* CIL Label */ ;
    }
  }
#line 194
  return (0);
}
}
#line 199 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
static int sg2_handle_scsi_cmd___0(cdrom_drive *d___0 , unsigned char *cmd , unsigned int cmd_len ,
                                   unsigned int in_size , unsigned int out_size ,
                                   unsigned char bytefill , int bytecheck , unsigned char *sense_buffer ) 
{ 
  struct timespec tv1 ;
  struct timespec tv2 ;
  int tret1 ;
  int tret2 ;
  int status ;
  struct sg_header *sg_hd ;
  long writebytes ;
  fd_set fdset ;
  struct timeval tv ;
  int __d0 ;
  int __d1 ;
  int ret ;
  int tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  ssize_t tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  fd_set rset ;
  struct timeval tv___0 ;
  int __d0___0 ;
  int __d1___0 ;
  int ret___0 ;
  int tmp___5 ;
  int *tmp___6 ;
  int *tmp___7 ;
  ssize_t tmp___8 ;
  int *tmp___9 ;
  int *tmp___10 ;
  long i ;
  long flag ;
  int *tmp___11 ;
  int *tmp___12 ;

  {
  {
#line 210
  status = 0;
#line 211
  sg_hd = (d___0->private_data)->sg_hd;
#line 212
  writebytes = (long )((sizeof(struct sg_header ) + (unsigned long )cmd_len) + (unsigned long )in_size);
#line 217
  clear_garbage___0(d___0);
#line 219
  memset((void *)sg_hd, 0, sizeof(sg_hd));
#line 220
  memset((void *)sense_buffer, 0, (size_t )16);
#line 221
  memcpy((void */* __restrict  */)(d___0->private_data)->sg_buffer, (void const   */* __restrict  */)cmd,
         (size_t )(cmd_len + in_size));
#line 222
  sg_hd->twelve_byte = (unsigned int )(cmd_len == 12U);
#line 223
  sg_hd->result = 0;
#line 224
  sg_hd->reply_len = (int )(sizeof(struct sg_header ) + (unsigned long )out_size);
  }
#line 234
  if (bytecheck) {
#line 234
    if (out_size > in_size) {
      {
#line 235
      memset((void *)(((d___0->private_data)->sg_buffer + cmd_len) + in_size), (int )bytefill,
             (size_t )(out_size - in_size));
#line 238
      writebytes += (long )(out_size - in_size);
      }
    }
  }
  {
#line 249
  while (1) {
    while_continue: /* CIL Label */ ;
#line 249
    __asm__  volatile   ("cld; rep; "
                         "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                         "1" (& fdset.__fds_bits[0]): "memory");
#line 249
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 250
  fdset.__fds_bits[d___0->cdda_fd / (8 * (int )sizeof(__fd_mask ))] |= 1L << d___0->cdda_fd % (8 * (int )sizeof(__fd_mask ));
#line 251
  tv.tv_sec = (__time_t )60;
#line 254
  tv.tv_usec = (__suseconds_t )0;
  {
#line 256
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 257
    tmp = select(d___0->cdda_fd + 1, (fd_set */* __restrict  */)((void *)0), (fd_set */* __restrict  */)(& fdset),
                 (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)(& tv));
#line 257
    ret = tmp;
    }
#line 258
    if (ret > 0) {
#line 258
      goto while_break___0;
    }
#line 259
    if (ret < 0) {
      {
#line 259
      tmp___0 = __errno_location();
      }
#line 259
      if (*tmp___0 != 4) {
#line 259
        goto while_break___0;
      }
    }
#line 260
    if (ret == 0) {
      {
#line 261
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\nSCSI transport error: timeout waiting to write packet\n\n");
      }
#line 263
      return (1);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 268
  sigprocmask(0, (sigset_t const   */* __restrict  */)(& d___0->sigset), (sigset_t */* __restrict  */)((void *)0));
#line 269
  tret1 = clock_gettime((d___0->private_data)->clock, & tv1);
#line 270
  tmp___1 = __errno_location();
#line 270
  *tmp___1 = 0;
#line 271
  tmp___2 = write(d___0->cdda_fd, (void const   *)sg_hd, (size_t )writebytes);
#line 271
  status = (int )tmp___2;
  }
#line 273
  if (status < 0) {
#line 273
    goto _L;
  } else
#line 273
  if ((long )status != writebytes) {
    _L: /* CIL Label */ 
    {
#line 274
    sigprocmask(1, (sigset_t const   */* __restrict  */)(& d___0->sigset), (sigset_t */* __restrict  */)((void *)0));
#line 275
    tmp___4 = __errno_location();
    }
#line 275
    if (*tmp___4 == 0) {
      {
#line 275
      tmp___3 = __errno_location();
#line 275
      *tmp___3 = 5;
      }
    }
#line 276
    return (1);
  }
  {
#line 289
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 289
    __asm__  volatile   ("cld; rep; "
                         "stosq": "=c" (__d0___0), "=D" (__d1___0): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                         "1" (& rset.__fds_bits[0]): "memory");
#line 289
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 290
  rset.__fds_bits[d___0->cdda_fd / (8 * (int )sizeof(__fd_mask ))] |= 1L << d___0->cdda_fd % (8 * (int )sizeof(__fd_mask ));
#line 291
  tv___0.tv_sec = (__time_t )60;
#line 294
  tv___0.tv_usec = (__suseconds_t )0;
  {
#line 296
  while (1) {
    while_continue___2: /* CIL Label */ ;
    {
#line 297
    tmp___5 = select(d___0->cdda_fd + 1, (fd_set */* __restrict  */)(& rset), (fd_set */* __restrict  */)((void *)0),
                     (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)(& tv___0));
#line 297
    ret___0 = tmp___5;
    }
#line 298
    if (ret___0 < 0) {
      {
#line 298
      tmp___6 = __errno_location();
      }
#line 298
      if (*tmp___6 != 4) {
#line 298
        goto while_break___2;
      }
    }
#line 299
    if (ret___0 == 0) {
      {
#line 300
      sigprocmask(1, (sigset_t const   */* __restrict  */)(& d___0->sigset), (sigset_t */* __restrict  */)((void *)0));
#line 301
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\nSCSI transport error: timeout waiting to read packet\n\n");
      }
#line 303
      return (2);
    }
#line 305
    if (ret___0 > 0) {
#line 307
      if ((rset.__fds_bits[d___0->cdda_fd / (8 * (int )sizeof(__fd_mask ))] & (1L << d___0->cdda_fd % (8 * (int )sizeof(__fd_mask )))) != 0L) {
#line 307
        goto while_break___2;
      }
      {
#line 308
      sigprocmask(1, (sigset_t const   */* __restrict  */)(& d___0->sigset), (sigset_t */* __restrict  */)((void *)0));
#line 309
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\nSCSI transport: error reading packet\n\n");
      }
#line 310
      return (2);
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 315
  tret2 = clock_gettime((d___0->private_data)->clock, & tv2);
#line 316
  tmp___7 = __errno_location();
#line 316
  *tmp___7 = 0;
#line 317
  tmp___8 = read(d___0->cdda_fd, (void *)sg_hd, sizeof(struct sg_header ) + (unsigned long )out_size);
#line 317
  status = (int )tmp___8;
#line 318
  sigprocmask(1, (sigset_t const   */* __restrict  */)(& d___0->sigset), (sigset_t */* __restrict  */)((void *)0));
#line 319
  memcpy((void */* __restrict  */)sense_buffer, (void const   */* __restrict  */)(sg_hd->sense_buffer),
         (size_t )16);
  }
#line 321
  if (status < 0) {
#line 321
    return (status);
  }
#line 323
  if ((unsigned long )status != sizeof(struct sg_header ) + (unsigned long )out_size) {
#line 323
    goto _L___0;
  } else
#line 323
  if (sg_hd->result) {
    _L___0: /* CIL Label */ 
    {
#line 324
    tmp___10 = __errno_location();
    }
#line 324
    if (*tmp___10 == 0) {
      {
#line 324
      tmp___9 = __errno_location();
#line 324
      *tmp___9 = 5;
      }
    }
#line 325
    return (2);
  }
  {
#line 328
  status = check_sbp_error___0((unsigned char const   )sg_hd->target_status, (unsigned char const   *)sense_buffer);
  }
#line 329
  if (status) {
#line 329
    return (status);
  }
#line 336
  if (bytecheck) {
#line 336
    if (in_size + cmd_len < out_size) {
#line 337
      flag = 0L;
#line 338
      i = (long )in_size;
      {
#line 338
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 338
        if (! (i < (long )out_size)) {
#line 338
          goto while_break___3;
        }
#line 339
        if ((int )*((d___0->private_data)->sg_buffer + i) != (int )bytefill) {
#line 340
          flag = 1L;
#line 341
          goto while_break___3;
        }
#line 338
        i ++;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 344
      if (! flag) {
        {
#line 345
        tmp___11 = __errno_location();
#line 345
        *tmp___11 = 22;
        }
#line 346
        return (5);
      }
    }
  }
  {
#line 350
  tmp___12 = __errno_location();
#line 350
  *tmp___12 = 0;
  }
#line 351
  if (tret1 < 0) {
#line 352
    (d___0->private_data)->last_milliseconds = -1;
  } else
#line 351
  if (tret2 < 0) {
#line 352
    (d___0->private_data)->last_milliseconds = -1;
  } else {
#line 354
    (d___0->private_data)->last_milliseconds = (int )((tv2.tv_sec - tv1.tv_sec) * 1000L + (tv2.tv_nsec - tv1.tv_nsec) / 1000000L);
  }
#line 356
  return (0);
}
}
#line 359 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
static int sgio_handle_scsi_cmd___0(cdrom_drive *d___0 , unsigned char *cmd , unsigned int cmd_len ,
                                    unsigned int in_size , unsigned int out_size ,
                                    unsigned char bytefill , int bytecheck , unsigned char *sense ) 
{ 
  int status ;
  struct sg_io_hdr hdr ;
  int *tmp ;
  int *tmp___0 ;
  long i ;
  long flag ;
  int *tmp___1 ;
  int *tmp___2 ;

  {
  {
#line 368
  status = 0;
#line 371
  memset((void *)(& hdr), 0, sizeof(hdr));
#line 372
  memset((void *)sense, 0, sizeof(sense));
#line 373
  memcpy((void */* __restrict  */)(d___0->private_data)->sg_buffer, (void const   */* __restrict  */)(cmd + cmd_len),
         (size_t )in_size);
#line 375
  hdr.cmdp = cmd;
#line 376
  hdr.cmd_len = (unsigned char )cmd_len;
#line 377
  hdr.sbp = sense;
#line 378
  hdr.mx_sb_len = (unsigned char)16;
#line 379
  hdr.timeout = 50000U;
#line 380
  hdr.interface_id = 'S';
#line 381
  hdr.dxferp = (void *)(d___0->private_data)->sg_buffer;
#line 382
  hdr.flags = 1U;
  }
#line 385
  if (bytecheck) {
#line 385
    if (out_size > in_size) {
      {
#line 386
      memset(hdr.dxferp + in_size, (int )bytefill, (size_t )(out_size - in_size));
      }
    }
  }
#line 388
  if (in_size) {
    {
#line 389
    hdr.dxfer_len = in_size;
#line 390
    hdr.dxfer_direction = -2;
#line 392
    tmp = __errno_location();
#line 392
    *tmp = 0;
#line 393
    status = ioctl(d___0->ioctl_fd, 8837UL, & hdr);
    }
#line 394
    if (status >= 0) {
#line 394
      if (hdr.status) {
        {
#line 395
        status = check_sbp_error___0((unsigned char const   )hdr.status, (unsigned char const   *)hdr.sbp);
        }
#line 396
        if (status) {
#line 396
          return (status);
        }
      }
    }
#line 398
    if (status < 0) {
#line 398
      return (1);
    }
  }
#line 401
  if ((unsigned int )(! in_size) | out_size) {
#line 402
    hdr.dxfer_len = out_size;
#line 404
    if (bytecheck) {
#line 404
      if (d___0->interface != 4) {
#line 405
        if (out_size) {
#line 405
          hdr.dxfer_direction = -4;
        } else {
#line 405
          hdr.dxfer_direction = -1;
        }
      } else {
#line 404
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 407
    if (out_size) {
#line 407
      hdr.dxfer_direction = -3;
    } else {
#line 407
      hdr.dxfer_direction = -1;
    }
    {
#line 409
    tmp___0 = __errno_location();
#line 409
    *tmp___0 = 0;
#line 410
    status = timed_ioctl___2(d___0, d___0->ioctl_fd, 8837, (void *)(& hdr));
    }
#line 411
    if (status >= 0) {
#line 411
      if (hdr.status) {
        {
#line 412
        status = check_sbp_error___0((unsigned char const   )hdr.status, (unsigned char const   *)hdr.sbp);
        }
#line 413
        if (status) {
#line 413
          return (status);
        }
      }
    }
#line 415
    if (status < 0) {
#line 415
      return (status);
    }
  }
#line 423
  if (bytecheck) {
#line 423
    if (in_size < out_size) {
#line 424
      flag = 0L;
#line 425
      i = (long )in_size;
      {
#line 425
      while (1) {
        while_continue: /* CIL Label */ ;
#line 425
        if (! (i < (long )out_size)) {
#line 425
          goto while_break;
        }
#line 426
        if ((int )*((d___0->private_data)->sg_buffer + i) != (int )bytefill) {
#line 427
          flag = 1L;
#line 428
          goto while_break;
        }
#line 425
        i ++;
      }
      while_break: /* CIL Label */ ;
      }
#line 431
      if (! flag) {
        {
#line 432
        tmp___1 = __errno_location();
#line 432
        *tmp___1 = 22;
        }
#line 433
        return (5);
      }
    }
  }
  {
#line 440
  tmp___2 = __errno_location();
#line 440
  *tmp___2 = 0;
  }
#line 441
  return (0);
}
}
#line 444 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
static int handle_scsi_cmd___0(cdrom_drive *d___0 , unsigned char *cmd , unsigned int cmd_len ,
                               unsigned int in_size , unsigned int out_size , unsigned char bytefill ,
                               int bytecheck , unsigned char *sense ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 453
  if (d___0->interface == 3) {
    {
#line 454
    tmp = sgio_handle_scsi_cmd___0(d___0, cmd, cmd_len, in_size, out_size, bytefill,
                                   bytecheck, sense);
    }
#line 454
    return (tmp);
  } else
#line 453
  if (d___0->interface == 4) {
    {
#line 454
    tmp = sgio_handle_scsi_cmd___0(d___0, cmd, cmd_len, in_size, out_size, bytefill,
                                   bytecheck, sense);
    }
#line 454
    return (tmp);
  }
  {
#line 455
  tmp___0 = sg2_handle_scsi_cmd___0(d___0, cmd, cmd_len, in_size, out_size, bytefill,
                                    bytecheck, sense);
  }
#line 455
  return (tmp___0);
}
}
#line 544 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
static int test_unit_ready___0(cdrom_drive *d___0 ) 
{ 
  unsigned char sense[16] ;
  unsigned char key ;
  unsigned char ASC ;
  unsigned char ASCQ ;
  unsigned char cmd[6] ;

  {
  {
#line 547
  cmd[0] = (unsigned char)0;
#line 547
  cmd[1] = (unsigned char)0;
#line 547
  cmd[2] = (unsigned char)0;
#line 547
  cmd[3] = (unsigned char)0;
#line 547
  cmd[4] = (unsigned char)0;
#line 547
  cmd[5] = (unsigned char)0;
#line 554
  handle_scsi_cmd___0(d___0, cmd, 6U, 0U, 56U, (unsigned char)0, 0, sense);
#line 556
  key = (unsigned char )((int )*((d___0->private_data)->sg_buffer + 2) & 15);
#line 557
  ASC = *((d___0->private_data)->sg_buffer + 12);
#line 558
  ASCQ = *((d___0->private_data)->sg_buffer + 13);
  }
#line 560
  if ((int )key == 2) {
#line 560
    if ((int )ASC == 4) {
#line 560
      if ((int )ASCQ == 1) {
#line 560
        return (0);
      }
    }
  }
#line 561
  return (1);
}
}
#line 565 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
static void reset_scsi___0(cdrom_drive *d___0 ) 
{ 
  int arg ;
  int tries ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 566
  tries = 0;
#line 567
  (*(d___0->enable_cdda))(d___0, 0);
#line 569
  cdmessage___3(d___0, "sending SG SCSI reset... ");
#line 570
  tmp = ioctl(d___0->cdda_fd, 8836UL, & arg);
  }
#line 570
  if (tmp) {
    {
#line 571
    cdmessage___3(d___0, "FAILED: EBUSY\n");
    }
  } else {
    {
#line 573
    cdmessage___3(d___0, "OK\n");
    }
  }
  {
#line 575
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 576
    tmp___0 = test_unit_ready___0(d___0);
    }
#line 576
    if (tmp___0) {
#line 576
      goto while_break;
    }
    {
#line 577
    tries ++;
#line 578
    usleep((__useconds_t )10);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 581
  (*(d___0->enable_cdda))(d___0, 1);
  }
#line 582
  return;
}
}
#line 607 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
static int mode_sense_atapi___0(cdrom_drive *d___0 , int size , int page ) 
{ 
  unsigned char sense[16] ;
  unsigned char cmd[10] ;
  int tmp ;
  unsigned char *b ;

  {
  {
#line 609
  cmd[0] = (unsigned char)90;
#line 609
  cmd[1] = (unsigned char)0;
#line 609
  cmd[2] = (unsigned char)0;
#line 609
  cmd[3] = (unsigned char)0;
#line 609
  cmd[4] = (unsigned char)0;
#line 609
  cmd[5] = (unsigned char)0;
#line 609
  cmd[6] = (unsigned char)0;
#line 609
  cmd[7] = (unsigned char)0;
#line 609
  cmd[8] = (unsigned char)0;
#line 609
  cmd[9] = (unsigned char)0;
#line 620
  cmd[1] = (unsigned char )(d___0->lun << 5);
#line 621
  cmd[2] = (unsigned char )(63 & page);
#line 622
  cmd[8] = (unsigned char )(size + 4);
#line 624
  tmp = handle_scsi_cmd___0(d___0, cmd, 10U, 0U, (unsigned int )(size + 4), (unsigned char )'\377',
                            1, sense);
  }
#line 624
  if (tmp) {
#line 624
    return (1);
  }
#line 627
  b = (d___0->private_data)->sg_buffer;
#line 628
  if (*(b + 0)) {
#line 628
    return (1);
  }
#line 629
  if (*(b + 6)) {
#line 629
    return (1);
  }
  {
#line 631
  *(b + 0) = (unsigned char )((int )*(b + 1) - 3);
#line 632
  *(b + 1) = *(b + 2);
#line 633
  *(b + 2) = *(b + 3);
#line 634
  *(b + 3) = *(b + 7);
#line 636
  memmove((void *)(b + 4), (void const   *)(b + 8), (size_t )(size - 4));
  }
#line 638
  return (0);
}
}
#line 643 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
static int mode_sense_scsi___0(cdrom_drive *d___0 , int size , int page ) 
{ 
  unsigned char sense[16] ;
  unsigned char cmd[6] ;
  int tmp ;

  {
  {
#line 645
  cmd[0] = (unsigned char)26;
#line 645
  cmd[1] = (unsigned char)0;
#line 645
  cmd[2] = (unsigned char)0;
#line 645
  cmd[3] = (unsigned char)0;
#line 645
  cmd[4] = (unsigned char)0;
#line 645
  cmd[5] = (unsigned char)0;
#line 652
  cmd[1] = (unsigned char )(d___0->lun << 5);
#line 653
  cmd[2] = (unsigned char )(63 & page);
#line 654
  cmd[4] = (unsigned char )size;
#line 656
  tmp = handle_scsi_cmd___0(d___0, cmd, 6U, 0U, (unsigned int )size, (unsigned char )'\377',
                            1, sense);
  }
#line 656
  if (tmp) {
#line 656
    return (1);
  }
#line 661
  return (0);
}
}
#line 664 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
static int mode_sense___0(cdrom_drive *d___0 , int size , int page ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 665
  if (d___0->is_atapi) {
    {
#line 666
    tmp = mode_sense_atapi___0(d___0, size, page);
    }
#line 666
    return (tmp);
  }
  {
#line 667
  tmp___0 = mode_sense_scsi___0(d___0, size, page);
  }
#line 667
  return (tmp___0);
}
}
#line 674 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
static int mode_select___0(cdrom_drive *d___0 , int density , int secsize ) 
{ 
  unsigned char sense[16] ;
  unsigned char cmd[26] ;
  unsigned char *mode ;
  int tmp ;
  unsigned char cmd___0[18] ;
  unsigned char *mode___0 ;
  int tmp___0 ;

  {
#line 677
  if (d___0->is_atapi) {
    {
#line 678
    cmd[0] = (unsigned char)85;
#line 678
    cmd[1] = (unsigned char)16;
#line 678
    cmd[2] = (unsigned char)0;
#line 678
    cmd[3] = (unsigned char)0;
#line 678
    cmd[4] = (unsigned char)0;
#line 678
    cmd[5] = (unsigned char)0;
#line 678
    cmd[6] = (unsigned char)0;
#line 678
    cmd[7] = (unsigned char)0;
#line 678
    cmd[8] = (unsigned char)16;
#line 678
    cmd[9] = (unsigned char)0;
#line 678
    cmd[10] = (unsigned char)0;
#line 678
    cmd[11] = (unsigned char)0;
#line 678
    cmd[12] = (unsigned char)0;
#line 678
    cmd[13] = (unsigned char)0;
#line 678
    cmd[14] = (unsigned char)0;
#line 678
    cmd[15] = (unsigned char)0;
#line 678
    cmd[16] = (unsigned char)0;
#line 678
    cmd[17] = (unsigned char)8;
#line 678
    cmd[18] = (unsigned char)0;
#line 678
    cmd[19] = (unsigned char)0;
#line 678
    cmd[20] = (unsigned char)0;
#line 678
    cmd[21] = (unsigned char)0;
#line 678
    cmd[22] = (unsigned char)0;
#line 678
    cmd[23] = (unsigned char)0;
#line 678
    cmd[24] = (unsigned char)0;
#line 678
    cmd[25] = (unsigned char)0;
#line 698
    mode = cmd + 18;
#line 701
    *(mode + 0) = (unsigned char )density;
#line 702
    *(mode + 6) = (unsigned char )(secsize >> 8);
#line 703
    *(mode + 7) = (unsigned char )(secsize & 255);
#line 706
    tmp = handle_scsi_cmd___0(d___0, cmd, 10U, 16U, 0U, (unsigned char)0, 0, sense);
    }
#line 706
    return (tmp);
  } else {
    {
#line 709
    cmd___0[0] = (unsigned char)21;
#line 709
    cmd___0[1] = (unsigned char)16;
#line 709
    cmd___0[2] = (unsigned char)0;
#line 709
    cmd___0[3] = (unsigned char)0;
#line 709
    cmd___0[4] = (unsigned char)12;
#line 709
    cmd___0[5] = (unsigned char)0;
#line 709
    cmd___0[6] = (unsigned char)0;
#line 709
    cmd___0[7] = (unsigned char)0;
#line 709
    cmd___0[8] = (unsigned char)0;
#line 709
    cmd___0[9] = (unsigned char)8;
#line 709
    cmd___0[10] = (unsigned char)0;
#line 709
    cmd___0[11] = (unsigned char)0;
#line 709
    cmd___0[12] = (unsigned char)0;
#line 709
    cmd___0[13] = (unsigned char)0;
#line 709
    cmd___0[14] = (unsigned char)0;
#line 709
    cmd___0[15] = (unsigned char)0;
#line 709
    cmd___0[16] = (unsigned char)0;
#line 709
    cmd___0[17] = (unsigned char)0;
#line 723
    mode___0 = cmd___0 + 10;
#line 726
    *(mode___0 + 0) = (unsigned char )density;
#line 727
    *(mode___0 + 6) = (unsigned char )(secsize >> 8);
#line 728
    *(mode___0 + 7) = (unsigned char )(secsize & 255);
#line 731
    tmp___0 = handle_scsi_cmd___0(d___0, cmd___0, 6U, 12U, 0U, (unsigned char)0, 0,
                                  sense);
    }
#line 731
    return (tmp___0);
  }
}
}
#line 736 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
static unsigned int get_orig_sectorsize___0(cdrom_drive *d___0 ) 
{ 
  int tmp ;
  unsigned int tmp___0 ;

  {
  {
#line 737
  tmp = mode_sense___0(d___0, 12, 1);
  }
#line 737
  if (tmp) {
#line 737
    return (4294967295U);
  }
#line 739
  d___0->orgdens = *((d___0->private_data)->sg_buffer + 4);
#line 740
  tmp___0 = (unsigned int )(((int )*((d___0->private_data)->sg_buffer + 10) << 8) + (int )*((d___0->private_data)->sg_buffer + 11));
#line 740
  d___0->orgsize = tmp___0;
#line 740
  return (tmp___0);
}
}
#line 744 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
static int set_sectorsize___0(cdrom_drive *d___0 , unsigned int secsize ) 
{ 
  int tmp ;

  {
  {
#line 745
  tmp = mode_select___0(d___0, (int )d___0->orgdens, (int )secsize);
  }
#line 745
  return (tmp);
}
}
#line 782 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
static int scsi_read_toc___0(cdrom_drive *d___0 ) 
{ 
  int i ;
  int first ;
  int last___0 ;
  unsigned int tracks ;
  unsigned char sense[16] ;
  unsigned char cmd[10] ;
  int tmp ;
  char __constr_expr_3[10] ;
  int tmp___0 ;
  scsi_TOC *toc ;
  char __constr_expr_4[10] ;
  int tmp___1 ;
  scsi_TOC *toc___0 ;

  {
  {
#line 791
  cmd[0] = (unsigned char)67;
#line 791
  cmd[1] = (unsigned char)0;
#line 791
  cmd[2] = (unsigned char)0;
#line 791
  cmd[3] = (unsigned char)0;
#line 791
  cmd[4] = (unsigned char)0;
#line 791
  cmd[5] = (unsigned char)0;
#line 791
  cmd[6] = (unsigned char)1;
#line 791
  cmd[7] = (unsigned char)0;
#line 791
  cmd[8] = (unsigned char)12;
#line 791
  cmd[9] = (unsigned char)0;
#line 792
  cmd[1] = (unsigned char )(d___0->lun << 5);
#line 794
  tmp = handle_scsi_cmd___0(d___0, cmd, 10U, 0U, 12U, (unsigned char )'\377', 1, sense);
  }
#line 794
  if (tmp) {
    {
#line 795
    cderror___2(d___0, "004: Unable to read table of contents header\n");
    }
#line 796
    return (-4);
  }
#line 799
  first = (int )*((d___0->private_data)->sg_buffer + 2);
#line 800
  last___0 = (int )*((d___0->private_data)->sg_buffer + 3);
#line 801
  tracks = (unsigned int )((last___0 - first) + 1);
#line 803
  if (last___0 > 100) {
    {
#line 804
    cderror___2(d___0, "003: CDROM reporting illegal number of tracks\n");
    }
#line 805
    return (-3);
  } else
#line 803
  if (first > 100) {
    {
#line 804
    cderror___2(d___0, "003: CDROM reporting illegal number of tracks\n");
    }
#line 805
    return (-3);
  } else
#line 803
  if (last___0 < 0) {
    {
#line 804
    cderror___2(d___0, "003: CDROM reporting illegal number of tracks\n");
    }
#line 805
    return (-3);
  } else
#line 803
  if (first < 0) {
    {
#line 804
    cderror___2(d___0, "003: CDROM reporting illegal number of tracks\n");
    }
#line 805
    return (-3);
  }
#line 808
  i = first;
  {
#line 808
  while (1) {
    while_continue: /* CIL Label */ ;
#line 808
    if (! (i <= last___0)) {
#line 808
      goto while_break;
    }
    {
#line 809
    __constr_expr_3[0] = (char)67;
#line 809
    __constr_expr_3[1] = (char)0;
#line 809
    __constr_expr_3[2] = (char)0;
#line 809
    __constr_expr_3[3] = (char)0;
#line 809
    __constr_expr_3[4] = (char)0;
#line 809
    __constr_expr_3[5] = (char)0;
#line 809
    __constr_expr_3[6] = (char)0;
#line 809
    __constr_expr_3[7] = (char)0;
#line 809
    __constr_expr_3[8] = (char)12;
#line 809
    __constr_expr_3[9] = (char)0;
#line 809
    memcpy((void */* __restrict  */)(cmd), (void const   */* __restrict  */)(__constr_expr_3),
           (size_t )10);
#line 810
    cmd[1] = (unsigned char )(d___0->lun << 5);
#line 811
    cmd[6] = (unsigned char )i;
#line 813
    tmp___0 = handle_scsi_cmd___0(d___0, cmd, 10U, 0U, 12U, (unsigned char )'\377',
                                  1, sense);
    }
#line 813
    if (tmp___0) {
      {
#line 814
      cderror___2(d___0, "005: Unable to read table of contents entry\n");
      }
#line 815
      return (-5);
    }
#line 818
    toc = (scsi_TOC *)((d___0->private_data)->sg_buffer + 4);
#line 820
    d___0->disc_toc[i - first].bFlags = toc->bFlags;
#line 821
    d___0->disc_toc[i - first].bTrack = (unsigned char )i;
#line 822
    d___0->disc_toc[i - first].dwStartSector = d___0->adjust_ssize * (((((int )toc->start_MSB << 24) | ((int )toc->start_1 << 16)) | ((int )toc->start_2 << 8)) | (int )toc->start_LSB);
#line 808
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 830
  __constr_expr_4[0] = (char)67;
#line 830
  __constr_expr_4[1] = (char)0;
#line 830
  __constr_expr_4[2] = (char)0;
#line 830
  __constr_expr_4[3] = (char)0;
#line 830
  __constr_expr_4[4] = (char)0;
#line 830
  __constr_expr_4[5] = (char)0;
#line 830
  __constr_expr_4[6] = (char)0;
#line 830
  __constr_expr_4[7] = (char)0;
#line 830
  __constr_expr_4[8] = (char)12;
#line 830
  __constr_expr_4[9] = (char)0;
#line 830
  memcpy((void */* __restrict  */)(cmd), (void const   */* __restrict  */)(__constr_expr_4),
         (size_t )10);
#line 831
  cmd[1] = (unsigned char )(d___0->lun << 5);
#line 832
  cmd[6] = (unsigned char)170;
#line 834
  tmp___1 = handle_scsi_cmd___0(d___0, cmd, 10U, 0U, 12U, (unsigned char )'\377',
                                1, sense);
  }
#line 834
  if (tmp___1) {
    {
#line 835
    cderror___2(d___0, "002: Unable to read table of contents lead-out\n");
    }
#line 836
    return (-2);
  }
  {
#line 839
  toc___0 = (scsi_TOC *)((d___0->private_data)->sg_buffer + 4);
#line 841
  d___0->disc_toc[i - first].bFlags = toc___0->bFlags;
#line 842
  d___0->disc_toc[i - first].bTrack = (unsigned char)170;
#line 843
  d___0->disc_toc[i - first].dwStartSector = d___0->adjust_ssize * (((((int )toc___0->start_MSB << 24) | ((int )toc___0->start_1 << 16)) | ((int )toc___0->start_2 << 8)) | (int )toc___0->start_LSB);
#line 850
  d___0->cd_extra = FixupTOC(d___0, (int )(tracks + 1U));
  }
#line 851
  return ((int )tracks);
}
}
#line 856 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
static int scsi_read_toc2___0(cdrom_drive *d___0 ) 
{ 
  u_int32_t foo ;
  u_int32_t bar ;
  int i ;
  unsigned int tracks ;
  unsigned char cmd[10] ;
  unsigned char sense[16] ;
  int tmp ;
  char __constr_expr_5[10] ;
  int tmp___0 ;
  int32_t tmp___1 ;
  int32_t tmp___2 ;

  {
  {
#line 862
  cmd[0] = (unsigned char)229;
#line 862
  cmd[1] = (unsigned char)0;
#line 862
  cmd[2] = (unsigned char)0;
#line 862
  cmd[3] = (unsigned char)0;
#line 862
  cmd[4] = (unsigned char)0;
#line 862
  cmd[5] = (unsigned char)0;
#line 862
  cmd[6] = (unsigned char)0;
#line 862
  cmd[7] = (unsigned char)0;
#line 862
  cmd[8] = (unsigned char)0;
#line 862
  cmd[9] = (unsigned char)0;
#line 864
  cmd[5] = (unsigned char)1;
#line 865
  cmd[8] = (unsigned char)255;
#line 867
  tmp = handle_scsi_cmd___0(d___0, cmd, 10U, 0U, 256U, (unsigned char )'\377', 1,
                            sense);
  }
#line 867
  if (tmp) {
    {
#line 868
    cderror___2(d___0, "004: Unable to read table of contents header\n");
    }
#line 869
    return (-4);
  }
#line 873
  tracks = (unsigned int )*((d___0->private_data)->sg_buffer + 1);
#line 874
  if (tracks > 100U) {
    {
#line 875
    cderror___2(d___0, "003: CDROM reporting illegal number of tracks\n");
    }
#line 876
    return (-3);
  }
#line 879
  i = 0;
  {
#line 879
  while (1) {
    while_continue: /* CIL Label */ ;
#line 879
    if (! ((unsigned int )i < tracks)) {
#line 879
      goto while_break;
    }
    {
#line 880
    __constr_expr_5[0] = (char)-27;
#line 880
    __constr_expr_5[1] = (char)0;
#line 880
    __constr_expr_5[2] = (char)0;
#line 880
    __constr_expr_5[3] = (char)0;
#line 880
    __constr_expr_5[4] = (char)0;
#line 880
    __constr_expr_5[5] = (char)0;
#line 880
    __constr_expr_5[6] = (char)0;
#line 880
    __constr_expr_5[7] = (char)0;
#line 880
    __constr_expr_5[8] = (char)0;
#line 880
    __constr_expr_5[9] = (char)0;
#line 880
    memcpy((void */* __restrict  */)(cmd), (void const   */* __restrict  */)(__constr_expr_5),
           (size_t )10);
#line 881
    cmd[5] = (unsigned char )(i + 1);
#line 882
    cmd[8] = (unsigned char)255;
#line 884
    tmp___0 = handle_scsi_cmd___0(d___0, cmd, 10U, 0U, 256U, (unsigned char )'\377',
                                  1, sense);
    }
#line 884
    if (tmp___0) {
      {
#line 885
      cderror___2(d___0, "005: Unable to read table of contents entry\n");
      }
#line 886
      return (-5);
    }
#line 889
    d___0->disc_toc[i].bFlags = *((d___0->private_data)->sg_buffer + 10);
#line 890
    d___0->disc_toc[i].bTrack = (unsigned char )(i + 1);
#line 892
    d___0->disc_toc[i].dwStartSector = d___0->adjust_ssize * (((((int )((signed char )*((d___0->private_data)->sg_buffer + 2)) << 24) | ((int )*((d___0->private_data)->sg_buffer + 3) << 16)) | ((int )*((d___0->private_data)->sg_buffer + 4) << 8)) | (int )*((d___0->private_data)->sg_buffer + 5));
#line 879
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 899
  d___0->disc_toc[i].bFlags = (unsigned char)0;
#line 900
  d___0->disc_toc[i].bTrack = (unsigned char )(i + 1);
#line 901
  memcpy((void */* __restrict  */)(& foo), (void const   */* __restrict  */)((d___0->private_data)->sg_buffer + 2),
         (size_t )4);
#line 902
  memcpy((void */* __restrict  */)(& bar), (void const   */* __restrict  */)((d___0->private_data)->sg_buffer + 6),
         (size_t )4);
#line 903
  tmp___1 = be32_to_cpu((int32_t )foo);
#line 903
  tmp___2 = be32_to_cpu((int32_t )bar);
#line 903
  d___0->disc_toc[i].dwStartSector = d___0->adjust_ssize * (tmp___1 + tmp___2);
#line 906
  d___0->disc_toc[i].dwStartSector = d___0->adjust_ssize * ((((((int )((signed char )*((d___0->private_data)->sg_buffer + 2)) << 24) | ((int )*((d___0->private_data)->sg_buffer + 3) << 16)) | ((int )*((d___0->private_data)->sg_buffer + 4) << 8)) | (int )*((d___0->private_data)->sg_buffer + 5)) + (((((int )((signed char )*((d___0->private_data)->sg_buffer + 6)) << 24) | ((int )*((d___0->private_data)->sg_buffer + 7) << 16)) | ((int )*((d___0->private_data)->sg_buffer + 8) << 8)) | (int )*((d___0->private_data)->sg_buffer + 9)));
#line 918
  d___0->cd_extra = FixupTOC(d___0, (int )(tracks + 1U));
  }
#line 919
  return ((int )tracks);
}
}
#line 922 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
static int scsi_set_speed___0(cdrom_drive *d___0 , int speed ) 
{ 
  unsigned char cmd[12] ;
  unsigned char sense[16] ;
  int tmp ;

  {
#line 923
  cmd[0] = (unsigned char)187;
#line 923
  cmd[1] = (unsigned char)0;
#line 923
  cmd[2] = (unsigned char)0;
#line 923
  cmd[3] = (unsigned char)0;
#line 923
  cmd[4] = (unsigned char)255;
#line 923
  cmd[5] = (unsigned char)255;
#line 923
  cmd[6] = (unsigned char)0;
#line 923
  cmd[7] = (unsigned char)0;
#line 923
  cmd[8] = (unsigned char)0;
#line 923
  cmd[9] = (unsigned char)0;
#line 923
  cmd[10] = (unsigned char)0;
#line 923
  cmd[11] = (unsigned char)0;
#line 926
  if (speed >= 0) {
#line 927
    speed = ((speed * 44100) * 4) / 1024;
  } else {
#line 929
    speed = -1;
  }
  {
#line 930
  cmd[2] = (unsigned char )((speed >> 8) & 255);
#line 931
  cmd[3] = (unsigned char )(speed & 255);
#line 932
  tmp = handle_scsi_cmd___0(d___0, cmd, 12U, 0U, 0U, (unsigned char)0, 0, sense);
  }
#line 932
  return (tmp);
}
}
#line 937 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
static int i_read_28___0(cdrom_drive *d___0 , void *p___0 , long begin , long sectors ,
                         unsigned char *sense ) 
{ 
  int ret ;
  unsigned char cmd[10] ;

  {
#line 939
  cmd[0] = (unsigned char)40;
#line 939
  cmd[1] = (unsigned char)0;
#line 939
  cmd[2] = (unsigned char)0;
#line 939
  cmd[3] = (unsigned char)0;
#line 939
  cmd[4] = (unsigned char)0;
#line 939
  cmd[5] = (unsigned char)0;
#line 939
  cmd[6] = (unsigned char)0;
#line 939
  cmd[7] = (unsigned char)0;
#line 939
  cmd[8] = (unsigned char)0;
#line 939
  cmd[9] = (unsigned char)0;
#line 941
  if (d___0->fua) {
#line 942
    cmd[1] = (unsigned char)8;
  }
  {
#line 944
  cmd[1] = (unsigned char )((int )cmd[1] | (d___0->lun << 5));
#line 946
  cmd[3] = (unsigned char )((begin >> 16) & 255L);
#line 947
  cmd[4] = (unsigned char )((begin >> 8) & 255L);
#line 948
  cmd[5] = (unsigned char )(begin & 255L);
#line 949
  cmd[8] = (unsigned char )sectors;
#line 950
  ret = handle_scsi_cmd___0(d___0, cmd, 10U, 0U, (unsigned int )(sectors * 2352L),
                            (unsigned char )'\177', 1, sense);
  }
#line 950
  if (ret) {
#line 951
    return (ret);
  }
#line 952
  if (p___0) {
    {
#line 952
    memcpy((void */* __restrict  */)p___0, (void const   */* __restrict  */)(d___0->private_data)->sg_buffer,
           (size_t )(sectors * 2352L));
    }
  }
#line 953
  return (0);
}
}
#line 956 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
static int i_read_A8___0(cdrom_drive *d___0 , void *p___0 , long begin , long sectors ,
                         unsigned char *sense ) 
{ 
  int ret ;
  unsigned char cmd[12] ;

  {
#line 958
  cmd[0] = (unsigned char)168;
#line 958
  cmd[1] = (unsigned char)0;
#line 958
  cmd[2] = (unsigned char)0;
#line 958
  cmd[3] = (unsigned char)0;
#line 958
  cmd[4] = (unsigned char)0;
#line 958
  cmd[5] = (unsigned char)0;
#line 958
  cmd[6] = (unsigned char)0;
#line 958
  cmd[7] = (unsigned char)0;
#line 958
  cmd[8] = (unsigned char)0;
#line 958
  cmd[9] = (unsigned char)0;
#line 958
  cmd[10] = (unsigned char)0;
#line 958
  cmd[11] = (unsigned char)0;
#line 960
  if (d___0->fua) {
#line 961
    cmd[1] = (unsigned char)8;
  }
  {
#line 963
  cmd[1] = (unsigned char )((int )cmd[1] | (d___0->lun << 5));
#line 965
  cmd[3] = (unsigned char )((begin >> 16) & 255L);
#line 966
  cmd[4] = (unsigned char )((begin >> 8) & 255L);
#line 967
  cmd[5] = (unsigned char )(begin & 255L);
#line 968
  cmd[9] = (unsigned char )sectors;
#line 969
  ret = handle_scsi_cmd___0(d___0, cmd, 12U, 0U, (unsigned int )(sectors * 2352L),
                            (unsigned char )'\177', 1, sense);
  }
#line 969
  if (ret) {
#line 970
    return (ret);
  }
#line 971
  if (p___0) {
    {
#line 971
    memcpy((void */* __restrict  */)p___0, (void const   */* __restrict  */)(d___0->private_data)->sg_buffer,
           (size_t )(sectors * 2352L));
    }
  }
#line 972
  return (0);
}
}
#line 975 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
static int i_read_D4_10___0(cdrom_drive *d___0 , void *p___0 , long begin , long sectors ,
                            unsigned char *sense ) 
{ 
  int ret ;
  unsigned char cmd[10] ;

  {
#line 977
  cmd[0] = (unsigned char)212;
#line 977
  cmd[1] = (unsigned char)0;
#line 977
  cmd[2] = (unsigned char)0;
#line 977
  cmd[3] = (unsigned char)0;
#line 977
  cmd[4] = (unsigned char)0;
#line 977
  cmd[5] = (unsigned char)0;
#line 977
  cmd[6] = (unsigned char)0;
#line 977
  cmd[7] = (unsigned char)0;
#line 977
  cmd[8] = (unsigned char)0;
#line 977
  cmd[9] = (unsigned char)0;
#line 979
  if (d___0->fua) {
#line 980
    cmd[1] = (unsigned char)8;
  }
  {
#line 982
  cmd[1] = (unsigned char )((int )cmd[1] | (d___0->lun << 5));
#line 983
  cmd[3] = (unsigned char )((begin >> 16) & 255L);
#line 984
  cmd[4] = (unsigned char )((begin >> 8) & 255L);
#line 985
  cmd[5] = (unsigned char )(begin & 255L);
#line 986
  cmd[8] = (unsigned char )sectors;
#line 987
  ret = handle_scsi_cmd___0(d___0, cmd, 10U, 0U, (unsigned int )(sectors * 2352L),
                            (unsigned char )'\177', 1, sense);
  }
#line 987
  if (ret) {
#line 988
    return (ret);
  }
#line 989
  if (p___0) {
    {
#line 989
    memcpy((void */* __restrict  */)p___0, (void const   */* __restrict  */)(d___0->private_data)->sg_buffer,
           (size_t )(sectors * 2352L));
    }
  }
#line 990
  return (0);
}
}
#line 993 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
static int i_read_D4_12___0(cdrom_drive *d___0 , void *p___0 , long begin , long sectors ,
                            unsigned char *sense ) 
{ 
  int ret ;
  unsigned char cmd[12] ;

  {
#line 995
  cmd[0] = (unsigned char)212;
#line 995
  cmd[1] = (unsigned char)0;
#line 995
  cmd[2] = (unsigned char)0;
#line 995
  cmd[3] = (unsigned char)0;
#line 995
  cmd[4] = (unsigned char)0;
#line 995
  cmd[5] = (unsigned char)0;
#line 995
  cmd[6] = (unsigned char)0;
#line 995
  cmd[7] = (unsigned char)0;
#line 995
  cmd[8] = (unsigned char)0;
#line 995
  cmd[9] = (unsigned char)0;
#line 995
  cmd[10] = (unsigned char)0;
#line 995
  cmd[11] = (unsigned char)0;
#line 997
  if (d___0->fua) {
#line 998
    cmd[1] = (unsigned char)8;
  }
  {
#line 1000
  cmd[1] = (unsigned char )((int )cmd[1] | (d___0->lun << 5));
#line 1001
  cmd[3] = (unsigned char )((begin >> 16) & 255L);
#line 1002
  cmd[4] = (unsigned char )((begin >> 8) & 255L);
#line 1003
  cmd[5] = (unsigned char )(begin & 255L);
#line 1004
  cmd[9] = (unsigned char )sectors;
#line 1005
  ret = handle_scsi_cmd___0(d___0, cmd, 12U, 0U, (unsigned int )(sectors * 2352L),
                            (unsigned char )'\177', 1, sense);
  }
#line 1005
  if (ret) {
#line 1006
    return (ret);
  }
#line 1007
  if (p___0) {
    {
#line 1007
    memcpy((void */* __restrict  */)p___0, (void const   */* __restrict  */)(d___0->private_data)->sg_buffer,
           (size_t )(sectors * 2352L));
    }
  }
#line 1008
  return (0);
}
}
#line 1011 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
static int i_read_D5___0(cdrom_drive *d___0 , void *p___0 , long begin , long sectors ,
                         unsigned char *sense ) 
{ 
  int ret ;
  unsigned char cmd[10] ;

  {
#line 1013
  cmd[0] = (unsigned char)213;
#line 1013
  cmd[1] = (unsigned char)0;
#line 1013
  cmd[2] = (unsigned char)0;
#line 1013
  cmd[3] = (unsigned char)0;
#line 1013
  cmd[4] = (unsigned char)0;
#line 1013
  cmd[5] = (unsigned char)0;
#line 1013
  cmd[6] = (unsigned char)0;
#line 1013
  cmd[7] = (unsigned char)0;
#line 1013
  cmd[8] = (unsigned char)0;
#line 1013
  cmd[9] = (unsigned char)0;
#line 1015
  if (d___0->fua) {
#line 1016
    cmd[1] = (unsigned char)8;
  }
  {
#line 1018
  cmd[1] = (unsigned char )((int )cmd[1] | (d___0->lun << 5));
#line 1019
  cmd[3] = (unsigned char )((begin >> 16) & 255L);
#line 1020
  cmd[4] = (unsigned char )((begin >> 8) & 255L);
#line 1021
  cmd[5] = (unsigned char )(begin & 255L);
#line 1022
  cmd[8] = (unsigned char )sectors;
#line 1023
  ret = handle_scsi_cmd___0(d___0, cmd, 10U, 0U, (unsigned int )(sectors * 2352L),
                            (unsigned char )'\177', 1, sense);
  }
#line 1023
  if (ret) {
#line 1024
    return (ret);
  }
#line 1025
  if (p___0) {
    {
#line 1025
    memcpy((void */* __restrict  */)p___0, (void const   */* __restrict  */)(d___0->private_data)->sg_buffer,
           (size_t )(sectors * 2352L));
    }
  }
#line 1026
  return (0);
}
}
#line 1029 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
static int i_read_D8___0(cdrom_drive *d___0 , void *p___0 , long begin , long sectors ,
                         unsigned char *sense ) 
{ 
  int ret ;
  unsigned char cmd[12] ;

  {
#line 1031
  cmd[0] = (unsigned char)216;
#line 1031
  cmd[1] = (unsigned char)0;
#line 1031
  cmd[2] = (unsigned char)0;
#line 1031
  cmd[3] = (unsigned char)0;
#line 1031
  cmd[4] = (unsigned char)0;
#line 1031
  cmd[5] = (unsigned char)0;
#line 1031
  cmd[6] = (unsigned char)0;
#line 1031
  cmd[7] = (unsigned char)0;
#line 1031
  cmd[8] = (unsigned char)0;
#line 1031
  cmd[9] = (unsigned char)0;
#line 1031
  cmd[10] = (unsigned char)0;
#line 1031
  cmd[11] = (unsigned char)0;
#line 1033
  if (d___0->fua) {
#line 1034
    cmd[1] = (unsigned char)8;
  }
  {
#line 1036
  cmd[1] = (unsigned char )((int )cmd[1] | (d___0->lun << 5));
#line 1037
  cmd[3] = (unsigned char )((begin >> 16) & 255L);
#line 1038
  cmd[4] = (unsigned char )((begin >> 8) & 255L);
#line 1039
  cmd[5] = (unsigned char )(begin & 255L);
#line 1040
  cmd[9] = (unsigned char )sectors;
#line 1041
  ret = handle_scsi_cmd___0(d___0, cmd, 12U, 0U, (unsigned int )(sectors * 2352L),
                            (unsigned char )'\177', 1, sense);
  }
#line 1041
  if (ret) {
#line 1042
    return (ret);
  }
#line 1043
  if (p___0) {
    {
#line 1043
    memcpy((void */* __restrict  */)p___0, (void const   */* __restrict  */)(d___0->private_data)->sg_buffer,
           (size_t )(sectors * 2352L));
    }
  }
#line 1044
  return (0);
}
}
#line 1047 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
static int i_read_mmc___0(cdrom_drive *d___0 , void *p___0 , long begin , long sectors ,
                          unsigned char *sense ) 
{ 
  int ret ;
  unsigned char cmd[12] ;

  {
  {
#line 1049
  cmd[0] = (unsigned char)190;
#line 1049
  cmd[1] = (unsigned char)2;
#line 1049
  cmd[2] = (unsigned char)0;
#line 1049
  cmd[3] = (unsigned char)0;
#line 1049
  cmd[4] = (unsigned char)0;
#line 1049
  cmd[5] = (unsigned char)0;
#line 1049
  cmd[6] = (unsigned char)0;
#line 1049
  cmd[7] = (unsigned char)0;
#line 1049
  cmd[8] = (unsigned char)0;
#line 1049
  cmd[9] = (unsigned char)16;
#line 1049
  cmd[10] = (unsigned char)0;
#line 1049
  cmd[11] = (unsigned char)0;
#line 1051
  cmd[3] = (unsigned char )((begin >> 16) & 255L);
#line 1052
  cmd[4] = (unsigned char )((begin >> 8) & 255L);
#line 1053
  cmd[5] = (unsigned char )(begin & 255L);
#line 1054
  cmd[8] = (unsigned char )sectors;
#line 1055
  ret = handle_scsi_cmd___0(d___0, cmd, 12U, 0U, (unsigned int )(sectors * 2352L),
                            (unsigned char )'\177', 1, sense);
  }
#line 1055
  if (ret) {
#line 1056
    return (ret);
  }
#line 1057
  if (p___0) {
    {
#line 1057
    memcpy((void */* __restrict  */)p___0, (void const   */* __restrict  */)(d___0->private_data)->sg_buffer,
           (size_t )(sectors * 2352L));
    }
  }
#line 1058
  return (0);
}
}
#line 1061 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
static int i_read_mmcB___0(cdrom_drive *d___0 , void *p___0 , long begin , long sectors ,
                           unsigned char *sense ) 
{ 
  int ret ;
  unsigned char cmd[12] ;

  {
  {
#line 1063
  cmd[0] = (unsigned char)190;
#line 1063
  cmd[1] = (unsigned char)0;
#line 1063
  cmd[2] = (unsigned char)0;
#line 1063
  cmd[3] = (unsigned char)0;
#line 1063
  cmd[4] = (unsigned char)0;
#line 1063
  cmd[5] = (unsigned char)0;
#line 1063
  cmd[6] = (unsigned char)0;
#line 1063
  cmd[7] = (unsigned char)0;
#line 1063
  cmd[8] = (unsigned char)0;
#line 1063
  cmd[9] = (unsigned char)16;
#line 1063
  cmd[10] = (unsigned char)0;
#line 1063
  cmd[11] = (unsigned char)0;
#line 1065
  cmd[3] = (unsigned char )((begin >> 16) & 255L);
#line 1066
  cmd[4] = (unsigned char )((begin >> 8) & 255L);
#line 1067
  cmd[5] = (unsigned char )(begin & 255L);
#line 1068
  cmd[8] = (unsigned char )sectors;
#line 1069
  ret = handle_scsi_cmd___0(d___0, cmd, 12U, 0U, (unsigned int )(sectors * 2352L),
                            (unsigned char )'\177', 1, sense);
  }
#line 1069
  if (ret) {
#line 1070
    return (ret);
  }
#line 1071
  if (p___0) {
    {
#line 1071
    memcpy((void */* __restrict  */)p___0, (void const   */* __restrict  */)(d___0->private_data)->sg_buffer,
           (size_t )(sectors * 2352L));
    }
  }
#line 1072
  return (0);
}
}
#line 1075 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
static int i_read_mmc2___0(cdrom_drive *d___0 , void *p___0 , long begin , long sectors ,
                           unsigned char *sense ) 
{ 
  int ret ;
  unsigned char cmd[12] ;

  {
  {
#line 1077
  cmd[0] = (unsigned char)190;
#line 1077
  cmd[1] = (unsigned char)2;
#line 1077
  cmd[2] = (unsigned char)0;
#line 1077
  cmd[3] = (unsigned char)0;
#line 1077
  cmd[4] = (unsigned char)0;
#line 1077
  cmd[5] = (unsigned char)0;
#line 1077
  cmd[6] = (unsigned char)0;
#line 1077
  cmd[7] = (unsigned char)0;
#line 1077
  cmd[8] = (unsigned char)0;
#line 1077
  cmd[9] = (unsigned char)248;
#line 1077
  cmd[10] = (unsigned char)0;
#line 1077
  cmd[11] = (unsigned char)0;
#line 1079
  cmd[3] = (unsigned char )((begin >> 16) & 255L);
#line 1080
  cmd[4] = (unsigned char )((begin >> 8) & 255L);
#line 1081
  cmd[5] = (unsigned char )(begin & 255L);
#line 1082
  cmd[8] = (unsigned char )sectors;
#line 1083
  ret = handle_scsi_cmd___0(d___0, cmd, 12U, 0U, (unsigned int )(sectors * 2352L),
                            (unsigned char )'\177', 1, sense);
  }
#line 1083
  if (ret) {
#line 1084
    return (ret);
  }
#line 1085
  if (p___0) {
    {
#line 1085
    memcpy((void */* __restrict  */)p___0, (void const   */* __restrict  */)(d___0->private_data)->sg_buffer,
           (size_t )(sectors * 2352L));
    }
  }
#line 1086
  return (0);
}
}
#line 1089 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
static int i_read_mmc2B___0(cdrom_drive *d___0 , void *p___0 , long begin , long sectors ,
                            unsigned char *sense ) 
{ 
  int ret ;
  unsigned char cmd[12] ;

  {
  {
#line 1091
  cmd[0] = (unsigned char)190;
#line 1091
  cmd[1] = (unsigned char)0;
#line 1091
  cmd[2] = (unsigned char)0;
#line 1091
  cmd[3] = (unsigned char)0;
#line 1091
  cmd[4] = (unsigned char)0;
#line 1091
  cmd[5] = (unsigned char)0;
#line 1091
  cmd[6] = (unsigned char)0;
#line 1091
  cmd[7] = (unsigned char)0;
#line 1091
  cmd[8] = (unsigned char)0;
#line 1091
  cmd[9] = (unsigned char)248;
#line 1091
  cmd[10] = (unsigned char)0;
#line 1091
  cmd[11] = (unsigned char)0;
#line 1093
  cmd[3] = (unsigned char )((begin >> 16) & 255L);
#line 1094
  cmd[4] = (unsigned char )((begin >> 8) & 255L);
#line 1095
  cmd[5] = (unsigned char )(begin & 255L);
#line 1096
  cmd[8] = (unsigned char )sectors;
#line 1097
  ret = handle_scsi_cmd___0(d___0, cmd, 12U, 0U, (unsigned int )(sectors * 2352L),
                            (unsigned char )'\177', 1, sense);
  }
#line 1097
  if (ret) {
#line 1098
    return (ret);
  }
#line 1099
  if (p___0) {
    {
#line 1099
    memcpy((void */* __restrict  */)p___0, (void const   */* __restrict  */)(d___0->private_data)->sg_buffer,
           (size_t )(sectors * 2352L));
    }
  }
#line 1100
  return (0);
}
}
#line 1103 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
static int i_read_mmc3___0(cdrom_drive *d___0 , void *p___0 , long begin , long sectors ,
                           unsigned char *sense ) 
{ 
  int ret ;
  unsigned char cmd[12] ;

  {
  {
#line 1105
  cmd[0] = (unsigned char)190;
#line 1105
  cmd[1] = (unsigned char)6;
#line 1105
  cmd[2] = (unsigned char)0;
#line 1105
  cmd[3] = (unsigned char)0;
#line 1105
  cmd[4] = (unsigned char)0;
#line 1105
  cmd[5] = (unsigned char)0;
#line 1105
  cmd[6] = (unsigned char)0;
#line 1105
  cmd[7] = (unsigned char)0;
#line 1105
  cmd[8] = (unsigned char)0;
#line 1105
  cmd[9] = (unsigned char)248;
#line 1105
  cmd[10] = (unsigned char)0;
#line 1105
  cmd[11] = (unsigned char)0;
#line 1107
  cmd[3] = (unsigned char )((begin >> 16) & 255L);
#line 1108
  cmd[4] = (unsigned char )((begin >> 8) & 255L);
#line 1109
  cmd[5] = (unsigned char )(begin & 255L);
#line 1110
  cmd[8] = (unsigned char )sectors;
#line 1111
  ret = handle_scsi_cmd___0(d___0, cmd, 12U, 0U, (unsigned int )(sectors * 2352L),
                            (unsigned char )'\177', 1, sense);
  }
#line 1111
  if (ret) {
#line 1112
    return (ret);
  }
#line 1113
  if (p___0) {
    {
#line 1113
    memcpy((void */* __restrict  */)p___0, (void const   */* __restrict  */)(d___0->private_data)->sg_buffer,
           (size_t )(sectors * 2352L));
    }
  }
#line 1114
  return (0);
}
}
#line 1117 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
static int i_read_mmc3B___0(cdrom_drive *d___0 , void *p___0 , long begin , long sectors ,
                            unsigned char *sense ) 
{ 
  int ret ;
  unsigned char cmd[12] ;

  {
  {
#line 1119
  cmd[0] = (unsigned char)190;
#line 1119
  cmd[1] = (unsigned char)4;
#line 1119
  cmd[2] = (unsigned char)0;
#line 1119
  cmd[3] = (unsigned char)0;
#line 1119
  cmd[4] = (unsigned char)0;
#line 1119
  cmd[5] = (unsigned char)0;
#line 1119
  cmd[6] = (unsigned char)0;
#line 1119
  cmd[7] = (unsigned char)0;
#line 1119
  cmd[8] = (unsigned char)0;
#line 1119
  cmd[9] = (unsigned char)248;
#line 1119
  cmd[10] = (unsigned char)0;
#line 1119
  cmd[11] = (unsigned char)0;
#line 1121
  cmd[3] = (unsigned char )((begin >> 16) & 255L);
#line 1122
  cmd[4] = (unsigned char )((begin >> 8) & 255L);
#line 1123
  cmd[5] = (unsigned char )(begin & 255L);
#line 1124
  cmd[8] = (unsigned char )sectors;
#line 1125
  ret = handle_scsi_cmd___0(d___0, cmd, 12U, 0U, (unsigned int )(sectors * 2352L),
                            (unsigned char )'\177', 1, sense);
  }
#line 1125
  if (ret) {
#line 1126
    return (ret);
  }
#line 1127
  if (p___0) {
    {
#line 1127
    memcpy((void */* __restrict  */)p___0, (void const   */* __restrict  */)(d___0->private_data)->sg_buffer,
           (size_t )(sectors * 2352L));
    }
  }
#line 1128
  return (0);
}
}
#line 1152 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
static int i_read_msf___0(cdrom_drive *d___0 , void *p___0 , long begin , long sectors ,
                          unsigned char *sense ) 
{ 
  int ret ;
  unsigned char cmd[12] ;

  {
  {
#line 1154
  cmd[0] = (unsigned char)185;
#line 1154
  cmd[1] = (unsigned char)0;
#line 1154
  cmd[2] = (unsigned char)0;
#line 1154
  cmd[3] = (unsigned char)0;
#line 1154
  cmd[4] = (unsigned char)0;
#line 1154
  cmd[5] = (unsigned char)0;
#line 1154
  cmd[6] = (unsigned char)0;
#line 1154
  cmd[7] = (unsigned char)0;
#line 1154
  cmd[8] = (unsigned char)0;
#line 1154
  cmd[9] = (unsigned char)16;
#line 1154
  cmd[10] = (unsigned char)0;
#line 1154
  cmd[11] = (unsigned char)0;
#line 1156
  LBA_to_MSF(begin, cmd + 3, cmd + 4, cmd + 5);
#line 1157
  LBA_to_MSF(begin + sectors, cmd + 6, cmd + 7, cmd + 8);
#line 1159
  ret = handle_scsi_cmd___0(d___0, cmd, 12U, 0U, (unsigned int )(sectors * 2352L),
                            (unsigned char )'\177', 1, sense);
  }
#line 1159
  if (ret) {
#line 1160
    return (ret);
  }
#line 1161
  if (p___0) {
    {
#line 1161
    memcpy((void */* __restrict  */)p___0, (void const   */* __restrict  */)(d___0->private_data)->sg_buffer,
           (size_t )(sectors * 2352L));
    }
  }
#line 1162
  return (0);
}
}
#line 1165 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
static int i_read_msf2___0(cdrom_drive *d___0 , void *p___0 , long begin , long sectors ,
                           unsigned char *sense ) 
{ 
  int ret ;
  unsigned char cmd[12] ;

  {
  {
#line 1167
  cmd[0] = (unsigned char)185;
#line 1167
  cmd[1] = (unsigned char)0;
#line 1167
  cmd[2] = (unsigned char)0;
#line 1167
  cmd[3] = (unsigned char)0;
#line 1167
  cmd[4] = (unsigned char)0;
#line 1167
  cmd[5] = (unsigned char)0;
#line 1167
  cmd[6] = (unsigned char)0;
#line 1167
  cmd[7] = (unsigned char)0;
#line 1167
  cmd[8] = (unsigned char)0;
#line 1167
  cmd[9] = (unsigned char)248;
#line 1167
  cmd[10] = (unsigned char)0;
#line 1167
  cmd[11] = (unsigned char)0;
#line 1169
  LBA_to_MSF(begin, cmd + 3, cmd + 4, cmd + 5);
#line 1170
  LBA_to_MSF(begin + sectors, cmd + 6, cmd + 7, cmd + 8);
#line 1172
  ret = handle_scsi_cmd___0(d___0, cmd, 12U, 0U, (unsigned int )(sectors * 2352L),
                            (unsigned char )'\177', 1, sense);
  }
#line 1172
  if (ret) {
#line 1173
    return (ret);
  }
#line 1174
  if (p___0) {
    {
#line 1174
    memcpy((void */* __restrict  */)p___0, (void const   */* __restrict  */)(d___0->private_data)->sg_buffer,
           (size_t )(sectors * 2352L));
    }
  }
#line 1175
  return (0);
}
}
#line 1178 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
static int i_read_msf3___0(cdrom_drive *d___0 , void *p___0 , long begin , long sectors ,
                           unsigned char *sense ) 
{ 
  int ret ;
  unsigned char cmd[12] ;

  {
  {
#line 1180
  cmd[0] = (unsigned char)185;
#line 1180
  cmd[1] = (unsigned char)4;
#line 1180
  cmd[2] = (unsigned char)0;
#line 1180
  cmd[3] = (unsigned char)0;
#line 1180
  cmd[4] = (unsigned char)0;
#line 1180
  cmd[5] = (unsigned char)0;
#line 1180
  cmd[6] = (unsigned char)0;
#line 1180
  cmd[7] = (unsigned char)0;
#line 1180
  cmd[8] = (unsigned char)0;
#line 1180
  cmd[9] = (unsigned char)248;
#line 1180
  cmd[10] = (unsigned char)0;
#line 1180
  cmd[11] = (unsigned char)0;
#line 1182
  LBA_to_MSF(begin, cmd + 3, cmd + 4, cmd + 5);
#line 1183
  LBA_to_MSF(begin + sectors, cmd + 6, cmd + 7, cmd + 8);
#line 1185
  ret = handle_scsi_cmd___0(d___0, cmd, 12U, 0U, (unsigned int )(sectors * 2352L),
                            (unsigned char )'\177', 1, sense);
  }
#line 1185
  if (ret) {
#line 1186
    return (ret);
  }
#line 1187
  if (p___0) {
    {
#line 1187
    memcpy((void */* __restrict  */)p___0, (void const   */* __restrict  */)(d___0->private_data)->sg_buffer,
           (size_t )(sectors * 2352L));
    }
  }
#line 1188
  return (0);
}
}
#line 1192 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
static long scsi_read_map___0(cdrom_drive *d___0 , void *p___0 , long begin , long sectors ,
                              int (*map)(cdrom_drive * , void * , long  , long  ,
                                         unsigned char * ) ) 
{ 
  unsigned char sense[16] ;
  int retry_count ;
  int err ;
  char *buffer ;
  char b[256] ;
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int *tmp___3 ;
  char b___0[256] ;
  int *tmp___4 ;
  char b___1[256] ;
  long i ;
  char b___2[256] ;
  char *tmp___5 ;

  {
#line 1197
  buffer = (char *)p___0;
#line 1200
  if (sectors > (long )d___0->nsectors) {
#line 1200
    sectors = (long )d___0->nsectors;
  } else {
#line 1200
    sectors = sectors;
  }
#line 1201
  if (sectors < 1L) {
#line 1201
    sectors = 1L;
  } else {
#line 1201
    sectors = sectors;
  }
#line 1203
  retry_count = 0;
  {
#line 1205
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1207
    if (p___0) {
#line 1207
      tmp___5 = buffer;
    } else {
#line 1207
      tmp___5 = (char *)((void *)0);
    }
    {
#line 1207
    err = (*map)(d___0, (void *)tmp___5, begin, sectors, sense);
    }
#line 1207
    if (err) {
#line 1208
      if (d___0->report_all) {
        {
#line 1211
        sprintf((char */* __restrict  */)(b), (char const   */* __restrict  */)"scsi_read error: sector=%ld length=%ld retry=%d\n",
                begin, sectors, retry_count);
#line 1213
        cdmessage___3(d___0, (char const   *)(b));
#line 1215
        sprintf((char */* __restrict  */)(b), (char const   */* __restrict  */)"                 Sense key: %x ASC: %x ASCQ: %x\n",
                (int )sense[2] & 15, (int )sense[12], (int )sense[13]);
#line 1228
        cdmessage___3(d___0, (char const   *)(b));
#line 1229
        sprintf((char */* __restrict  */)(b), (char const   */* __restrict  */)"                 Transport error: %s\n",
                strerror_tr___0[err]);
#line 1230
        cdmessage___3(d___0, (char const   *)(b));
#line 1231
        tmp = __errno_location();
#line 1231
        tmp___0 = strerror(*tmp);
#line 1231
        sprintf((char */* __restrict  */)(b), (char const   */* __restrict  */)"                 System error: %s\n",
                tmp___0);
#line 1232
        cdmessage___3(d___0, (char const   *)(b));
#line 1234
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"scsi_read error: sector=%ld length=%ld retry=%d\n",
                begin, sectors, retry_count);
#line 1237
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"                 Sense key: %x ASC: %x ASCQ: %x\n",
                (int )sense[2] & 15, (int )sense[12], (int )sense[13]);
#line 1249
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"                 Transport error: %s\n",
                strerror_tr___0[err]);
#line 1250
        tmp___1 = __errno_location();
#line 1250
        tmp___2 = strerror(*tmp___1);
#line 1250
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"                 System error: %s\n",
                tmp___2);
        }
      }
      {
#line 1253
      tmp___3 = __errno_location();
      }
      {
#line 1254
      if (*tmp___3 == 4) {
#line 1254
        goto case_4;
      }
#line 1257
      if (*tmp___3 == 12) {
#line 1257
        goto case_12;
      }
#line 1275
      if (*tmp___3 == 123) {
#line 1275
        goto case_123;
      }
#line 1279
      goto switch_default;
      case_4: /* CIL Label */ 
      {
#line 1255
      usleep((__useconds_t )100);
      }
#line 1256
      goto while_continue;
      case_12: /* CIL Label */ 
      {
#line 1259
      usleep((__useconds_t )100);
      }
#line 1260
      if (sectors == 1L) {
        {
#line 1262
        cderror___2(d___0, "300: Kernel memory error\n");
        }
#line 1263
        return (-300L);
      }
#line 1265
      if (d___0->report_all) {
        {
#line 1267
        sprintf((char */* __restrict  */)(b___0), (char const   */* __restrict  */)"scsi_read: kernel couldn\'t alloc %ld bytes.  backing off...\n",
                sectors * 2352L);
#line 1270
        cdmessage___3(d___0, (char const   *)(b___0));
        }
      }
#line 1272
      sectors --;
#line 1273
      goto while_continue;
      case_123: /* CIL Label */ 
      {
#line 1276
      cderror___2(d___0, "404: No medium present\n");
      }
#line 1277
      return (-404L);
      switch_default: /* CIL Label */ 
#line 1280
      if (sectors == 1L) {
        {
#line 1281
        tmp___4 = __errno_location();
        }
#line 1281
        if (*tmp___4 == 5) {
#line 1282
          if (d___0->fua == -1) {
#line 1283
            return (-7L);
          }
        }
#line 1288
        if (retry_count > 7) {
          {
#line 1290
          sprintf((char */* __restrict  */)(b___1), (char const   */* __restrict  */)"010: Unable to access sector %ld\n",
                  begin);
#line 1292
          cderror___2(d___0, (char const   *)(b___1));
          }
#line 1293
          return (-10L);
        }
#line 1296
        goto switch_break;
      }
      {
#line 1302
      reset_scsi___0(d___0);
      }
      switch_break: /* CIL Label */ ;
      }
#line 1304
      if (! d___0->error_retry) {
#line 1304
        return (-7L);
      }
    } else
#line 1310
    if (buffer) {
#line 1312
      i = sectors * 2352L;
      {
#line 1312
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1312
        if (! (i > 1L)) {
#line 1312
          goto while_break___0;
        }
#line 1313
        if ((int )*(buffer + (i - 1L)) != 127) {
#line 1314
          goto while_break___0;
        } else
#line 1313
        if ((int )*(buffer + (i - 2L)) != 127) {
#line 1314
          goto while_break___0;
        }
#line 1312
        i -= 2L;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 1316
      i /= 2352L;
#line 1317
      if (i != sectors) {
#line 1318
        if (d___0->report_all) {
          {
#line 1320
          sprintf((char */* __restrict  */)(b___2), (char const   */* __restrict  */)"scsi_read underrun: pos=%ld len=%ld read=%ld retry=%d\n",
                  begin, sectors, i, retry_count);
#line 1323
          cdmessage___3(d___0, (char const   *)(b___2));
          }
        }
        {
#line 1325
        reset_scsi___0(d___0);
        }
      }
#line 1328
      if (i > 0L) {
#line 1328
        return (i);
      }
    } else {
#line 1331
      goto while_break;
    }
#line 1334
    retry_count ++;
#line 1335
    if (sectors == 1L) {
#line 1335
      if (retry_count > 8) {
        {
#line 1336
        cderror___2(d___0, "007: Unknown, unrecoverable error reading data\n");
        }
#line 1337
        return (-7L);
      }
    }
#line 1339
    if (sectors > 1L) {
#line 1339
      sectors /= 2L;
    }
    {
#line 1340
    (*(d___0->enable_cdda))(d___0, 0);
#line 1341
    (*(d___0->enable_cdda))(d___0, 1);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1344
  return (sectors);
}
}
#line 1427 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
static int count_2352_bytes___0(cdrom_drive *d___0 ) 
{ 
  long i ;

  {
#line 1429
  i = 2351L;
  {
#line 1429
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1429
    if (! (i >= 0L)) {
#line 1429
      goto while_break;
    }
#line 1430
    if ((int )*((d___0->private_data)->sg_buffer + i) != 127) {
#line 1431
      return ((int )(((i + 3L) >> 2) << 2));
    }
#line 1429
    i --;
  }
  while_break: /* CIL Label */ ;
  }
#line 1433
  return (0);
}
}
#line 1436 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
static int verify_nonzero___0(cdrom_drive *d___0 ) 
{ 
  long i ;
  long flag ;

  {
#line 1437
  flag = 0L;
#line 1438
  i = 0L;
  {
#line 1438
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1438
    if (! (i < 2352L)) {
#line 1438
      goto while_break;
    }
#line 1439
    if ((int )*((d___0->private_data)->sg_buffer + i) != 0) {
#line 1440
      flag = 1L;
#line 1441
      goto while_break;
    }
#line 1438
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1444
  return ((int )flag);
}
}
#line 1451 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
static int verify_read_command___2(cdrom_drive *d___0 ) 
{ 
  int i ;
  int j ;
  int k ;
  int audioflag ;
  int (*enablecommand)(struct cdrom_drive *d , int speed ) ;
  long (*readcommand)(struct cdrom_drive *d , void *p , long begin , long sectors ) ;
  unsigned char density ;
  int16_t *buff ;
  void *tmp ;
  long firstsector ;
  long tmp___0 ;
  long lastsector ;
  long tmp___1 ;
  long sector ;
  int tmp___2 ;
  long tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  char *es ;
  char *rs___0 ;
  int densitypossible ;
  int densityflag ;
  int rejectflag ;
  int zeroflag ;
  int lengthflag ;
  long firstsector___0 ;
  long tmp___6 ;
  long lastsector___0 ;
  long tmp___7 ;
  long sector___0 ;
  int tmp___8 ;
  long tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  char buffer[256] ;
  char buffer___0[256] ;
  char buffer___1[256] ;

  {
  {
#line 1453
  audioflag = 0;
#line 1460
  tmp = malloc((size_t )2352);
#line 1460
  buff = (int16_t *)tmp;
#line 1462
  cdmessage___3(d___0, "Verifying CDDA command set...\n");
#line 1467
  tmp___5 = (*(d___0->enable_cdda))(d___0, 1);
  }
#line 1467
  if (tmp___5 == 0) {
#line 1469
    i = 1;
    {
#line 1469
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1469
      if (! (i <= d___0->tracks)) {
#line 1469
        goto while_break;
      }
      {
#line 1470
      tmp___4 = cdda_track_audiop(d___0, i);
      }
#line 1470
      if (tmp___4 == 1) {
        {
#line 1471
        tmp___0 = cdda_track_firstsector(d___0, i);
#line 1471
        firstsector = tmp___0;
#line 1472
        tmp___1 = cdda_track_lastsector(d___0, i);
#line 1472
        lastsector = tmp___1;
#line 1473
        sector = (firstsector + lastsector) >> 1;
#line 1474
        audioflag = 1;
#line 1476
        tmp___3 = (*(d___0->read_audio))(d___0, (void *)buff, sector, 1L);
        }
#line 1476
        if (tmp___3 > 0L) {
          {
#line 1477
          tmp___2 = count_2352_bytes___0(d___0);
          }
#line 1477
          if (tmp___2 == 2352) {
            {
#line 1478
            cdmessage___3(d___0, "\tExpected command set reads OK.\n");
#line 1479
            (*(d___0->enable_cdda))(d___0, 0);
#line 1480
            free((void *)buff);
            }
#line 1481
            return (0);
          }
        }
      }
#line 1469
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1487
    (*(d___0->enable_cdda))(d___0, 0);
    }
  }
#line 1489
  if (! audioflag) {
    {
#line 1490
    cdmessage___3(d___0, "\tCould not find any audio tracks on this disk.\n");
    }
#line 1491
    return (-403);
  }
  {
#line 1495
  es = (char *)"";
#line 1495
  rs___0 = (char *)"";
#line 1496
  d___0->bigendianp = -1;
#line 1497
  density = d___0->density;
#line 1498
  readcommand = d___0->read_audio;
#line 1499
  enablecommand = d___0->enable_cdda;
#line 1503
  cdmessage___3(d___0, "\tExpected command set FAILED!\n\tPerforming full probe for CDDA command set...\n");
#line 1513
  j = 0;
  }
  {
#line 1513
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1513
    if (! (j < 15)) {
#line 1513
      goto while_break___0;
    }
#line 1514
    densitypossible = 1;
    {
#line 1517
    if (j == 0) {
#line 1517
      goto case_0;
    }
#line 1521
    if (j == 1) {
#line 1521
      goto case_1;
    }
#line 1526
    if (j == 2) {
#line 1526
      goto case_2;
    }
#line 1531
    if (j == 3) {
#line 1531
      goto case_3;
    }
#line 1536
    if (j == 4) {
#line 1536
      goto case_4;
    }
#line 1542
    if (j == 5) {
#line 1542
      goto case_5;
    }
#line 1547
    if (j == 6) {
#line 1547
      goto case_6;
    }
#line 1552
    if (j == 7) {
#line 1552
      goto case_7;
    }
#line 1558
    if (j == 8) {
#line 1558
      goto case_8;
    }
#line 1563
    if (j == 9) {
#line 1563
      goto case_9;
    }
#line 1568
    if (j == 10) {
#line 1568
      goto case_10;
    }
#line 1574
    if (j == 11) {
#line 1574
      goto case_11;
    }
#line 1578
    if (j == 12) {
#line 1578
      goto case_12;
    }
#line 1582
    if (j == 13) {
#line 1582
      goto case_13;
    }
#line 1586
    if (j == 14) {
#line 1586
      goto case_14;
    }
#line 1516
    goto switch_break;
    case_0: /* CIL Label */ 
#line 1518
    d___0->read_audio = & scsi_read_28;
#line 1519
    rs___0 = (char *)"28 0x,00";
#line 1520
    goto switch_break;
    case_1: /* CIL Label */ 
#line 1522
    d___0->read_audio = & scsi_read_A8;
#line 1523
    rs___0 = (char *)"a8 0x,00";
#line 1524
    goto switch_break;
    case_2: /* CIL Label */ 
#line 1527
    d___0->read_audio = & scsi_read_mmcB;
#line 1528
    rs___0 = (char *)"be 02,10";
#line 1529
    densitypossible = 0;
#line 1530
    goto switch_break;
    case_3: /* CIL Label */ 
#line 1532
    d___0->read_audio = & scsi_read_mmc2B;
#line 1533
    rs___0 = (char *)"be 02,f8";
#line 1534
    densitypossible = 0;
#line 1535
    goto switch_break;
    case_4: /* CIL Label */ 
#line 1537
    d___0->read_audio = & scsi_read_mmc3B;
#line 1538
    rs___0 = (char *)"be 06,f8";
#line 1539
    densitypossible = 0;
#line 1540
    goto switch_break;
    case_5: /* CIL Label */ 
#line 1543
    d___0->read_audio = & scsi_read_mmc;
#line 1544
    rs___0 = (char *)"be 00,10";
#line 1545
    densitypossible = 0;
#line 1546
    goto switch_break;
    case_6: /* CIL Label */ 
#line 1548
    d___0->read_audio = & scsi_read_mmc2;
#line 1549
    rs___0 = (char *)"be 00,f8";
#line 1550
    densitypossible = 0;
#line 1551
    goto switch_break;
    case_7: /* CIL Label */ 
#line 1553
    d___0->read_audio = & scsi_read_mmc3;
#line 1554
    rs___0 = (char *)"be 04,f8";
#line 1555
    densitypossible = 0;
#line 1556
    goto switch_break;
    case_8: /* CIL Label */ 
#line 1559
    d___0->read_audio = & scsi_read_msf;
#line 1560
    rs___0 = (char *)"b9 00,10";
#line 1561
    densitypossible = 0;
#line 1562
    goto switch_break;
    case_9: /* CIL Label */ 
#line 1564
    d___0->read_audio = & scsi_read_msf2;
#line 1565
    rs___0 = (char *)"b9 00,f8";
#line 1566
    densitypossible = 0;
#line 1567
    goto switch_break;
    case_10: /* CIL Label */ 
#line 1569
    d___0->read_audio = & scsi_read_msf3;
#line 1570
    rs___0 = (char *)"b9 04,f8";
#line 1571
    densitypossible = 0;
#line 1572
    goto switch_break;
    case_11: /* CIL Label */ 
#line 1575
    d___0->read_audio = & scsi_read_D4_10;
#line 1576
    rs___0 = (char *)"d4(10)0x";
#line 1577
    goto switch_break;
    case_12: /* CIL Label */ 
#line 1579
    d___0->read_audio = & scsi_read_D4_12;
#line 1580
    rs___0 = (char *)"d4(12)0x";
#line 1581
    goto switch_break;
    case_13: /* CIL Label */ 
#line 1583
    d___0->read_audio = & scsi_read_D5;
#line 1584
    rs___0 = (char *)"d5 0x,00";
#line 1585
    goto switch_break;
    case_14: /* CIL Label */ 
#line 1587
    d___0->read_audio = & scsi_read_D8;
#line 1588
    rs___0 = (char *)"d8 0x,00";
#line 1589
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 1592
    i = 0;
    {
#line 1592
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1592
      if (! (i < 5)) {
#line 1592
        goto while_break___1;
      }
      {
#line 1594
      if (i == 0) {
#line 1594
        goto case_0___0;
      }
#line 1600
      if (i == 1) {
#line 1600
        goto case_1___0;
      }
#line 1605
      if (i == 2) {
#line 1605
        goto case_2___0;
      }
#line 1610
      if (i == 3) {
#line 1610
        goto case_3___0;
      }
#line 1615
      if (i == 4) {
#line 1615
        goto case_4___0;
      }
#line 1593
      goto switch_break___0;
      case_0___0: /* CIL Label */ 
#line 1595
      d___0->density = (unsigned char)0;
#line 1596
      d___0->enable_cdda = & Dummy___2;
#line 1597
      es = (char *)"none    ";
#line 1598
      if (! densitypossible) {
#line 1598
        i = 5;
      }
#line 1599
      goto switch_break___0;
      case_1___0: /* CIL Label */ 
#line 1601
      d___0->density = (unsigned char)0;
#line 1602
      d___0->enable_cdda = & scsi_enable_cdda;
#line 1603
      es = (char *)"yes/0x00";
#line 1604
      goto switch_break___0;
      case_2___0: /* CIL Label */ 
#line 1606
      d___0->density = (unsigned char)4;
#line 1607
      d___0->enable_cdda = & scsi_enable_cdda;
#line 1608
      es = (char *)"yes/0x04";
#line 1609
      goto switch_break___0;
      case_3___0: /* CIL Label */ 
#line 1611
      d___0->density = (unsigned char)130;
#line 1612
      d___0->enable_cdda = & scsi_enable_cdda;
#line 1613
      es = (char *)"yes/0x82";
#line 1614
      goto switch_break___0;
      case_4___0: /* CIL Label */ 
#line 1616
      d___0->density = (unsigned char)129;
#line 1617
      d___0->enable_cdda = & scsi_enable_cdda;
#line 1618
      es = (char *)"yes/0x81";
#line 1619
      goto switch_break___0;
      switch_break___0: /* CIL Label */ ;
      }
      {
#line 1622
      cdmessage___3(d___0, "\ttest -> density: [");
#line 1623
      cdmessage___3(d___0, (char const   *)es);
#line 1624
      cdmessage___3(d___0, "]  command: [");
#line 1625
      cdmessage___3(d___0, (char const   *)rs___0);
#line 1626
      cdmessage___3(d___0, "]\n");
#line 1629
      densityflag = 0;
#line 1630
      rejectflag = 0;
#line 1631
      zeroflag = 0;
#line 1632
      lengthflag = 0;
#line 1634
      tmp___11 = (*(d___0->enable_cdda))(d___0, 1);
      }
#line 1634
      if (tmp___11 == 0) {
#line 1635
        k = 1;
        {
#line 1635
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 1635
          if (! (k <= d___0->tracks)) {
#line 1635
            goto while_break___2;
          }
          {
#line 1636
          tmp___10 = cdda_track_audiop(d___0, k);
          }
#line 1636
          if (tmp___10 == 1) {
            {
#line 1637
            tmp___6 = cdda_track_firstsector(d___0, k);
#line 1637
            firstsector___0 = tmp___6;
#line 1638
            tmp___7 = cdda_track_lastsector(d___0, k);
#line 1638
            lastsector___0 = tmp___7;
#line 1639
            sector___0 = (firstsector___0 + lastsector___0) >> 1;
#line 1641
            tmp___9 = (*(d___0->read_audio))(d___0, (void *)buff, sector___0, 1L);
            }
#line 1641
            if (tmp___9 > 0L) {
              {
#line 1642
              lengthflag = count_2352_bytes___0(d___0);
              }
#line 1642
              if (lengthflag == 2352) {
                {
#line 1643
                tmp___8 = verify_nonzero___0(d___0);
                }
#line 1643
                if (tmp___8) {
                  {
#line 1644
                  cdmessage___3(d___0, "\t\tCommand set FOUND!\n");
#line 1646
                  free((void *)buff);
#line 1647
                  (*(d___0->enable_cdda))(d___0, 0);
                  }
#line 1648
                  return (0);
                } else {
#line 1650
                  zeroflag ++;
                }
              }
            } else {
#line 1654
              rejectflag ++;
#line 1655
              goto while_break___2;
            }
          }
#line 1635
          k ++;
        }
        while_break___2: /* CIL Label */ ;
        }
        {
#line 1659
        (*(d___0->enable_cdda))(d___0, 0);
        }
      } else {
#line 1661
        densityflag ++;
      }
#line 1664
      if (densityflag) {
        {
#line 1665
        cdmessage___3(d___0, "\t\tDrive rejected density set\n");
        }
      }
#line 1666
      if (rejectflag) {
        {
#line 1668
        sprintf((char */* __restrict  */)(buffer), (char const   */* __restrict  */)"\t\tDrive rejected read command packet(s)\n");
#line 1669
        cdmessage___3(d___0, (char const   *)(buffer));
        }
      }
#line 1671
      if (lengthflag > 0) {
#line 1671
        if (lengthflag < 2352) {
          {
#line 1673
          sprintf((char */* __restrict  */)(buffer___0), (char const   */* __restrict  */)"\t\tDrive returned at least one packet, but with\n\t\tincorrect size (%d)\n",
                  lengthflag);
#line 1675
          cdmessage___3(d___0, (char const   *)(buffer___0));
          }
        }
      }
#line 1677
      if (zeroflag) {
        {
#line 1679
        sprintf((char */* __restrict  */)(buffer___1), (char const   */* __restrict  */)"\t\tDrive returned %d packet(s), but contents\n\t\twere entirely zero\n",
                zeroflag);
#line 1681
        cdmessage___3(d___0, (char const   *)(buffer___1));
        }
      }
#line 1592
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1513
    j ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1688
  d___0->density = density;
#line 1689
  d___0->read_audio = readcommand;
#line 1690
  d___0->enable_cdda = enablecommand;
#line 1692
  cdmessage___3(d___0, "\tUnable to find any suitable command set from probe;\n\tdrive probably not CDDA capable.\n");
#line 1695
  cderror___2(d___0, "006: Could not read any data from drive\n");
#line 1698
  free((void *)buff);
  }
#line 1699
  return (-6);
}
}
#line 1702 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
static void check_cache___0(cdrom_drive *d___0 ) 
{ 
  long i ;
  long firstsector ;
  long tmp ;
  long lastsector ;
  long tmp___0 ;
  long sector ;
  long tmp___1 ;
  int tmp___2 ;

  {
#line 1705
  if (! ((unsigned long )d___0->read_audio == (unsigned long )(& scsi_read_mmc))) {
#line 1705
    if (! ((unsigned long )d___0->read_audio == (unsigned long )(& scsi_read_mmc2))) {
#line 1705
      if (! ((unsigned long )d___0->read_audio == (unsigned long )(& scsi_read_mmc3))) {
#line 1705
        if (! ((unsigned long )d___0->read_audio == (unsigned long )(& scsi_read_mmcB))) {
#line 1705
          if (! ((unsigned long )d___0->read_audio == (unsigned long )(& scsi_read_mmc2B))) {
#line 1705
            if (! ((unsigned long )d___0->read_audio == (unsigned long )(& scsi_read_mmc3B))) {
              {
#line 1712
              cdmessage___3(d___0, "This command set may use a Force Unit Access bit.");
#line 1713
              cdmessage___3(d___0, "\nChecking drive for FUA bit support...\n");
#line 1715
              (*(d___0->enable_cdda))(d___0, 1);
#line 1716
              d___0->fua = 1;
#line 1718
              i = 1L;
              }
              {
#line 1718
              while (1) {
                while_continue: /* CIL Label */ ;
#line 1718
                if (! (i <= (long )d___0->tracks)) {
#line 1718
                  goto while_break;
                }
                {
#line 1719
                tmp___2 = cdda_track_audiop(d___0, (int )i);
                }
#line 1719
                if (tmp___2 == 1) {
                  {
#line 1720
                  tmp = cdda_track_firstsector(d___0, (int )i);
#line 1720
                  firstsector = tmp;
#line 1721
                  tmp___0 = cdda_track_lastsector(d___0, (int )i);
#line 1721
                  lastsector = tmp___0;
#line 1722
                  sector = (firstsector + lastsector) >> 1;
#line 1724
                  tmp___1 = (*(d___0->read_audio))(d___0, (void *)0, sector, 1L);
                  }
#line 1724
                  if (tmp___1 > 0L) {
                    {
#line 1725
                    cdmessage___3(d___0, "\tDrive accepted FUA bit.\n");
#line 1726
                    (*(d___0->enable_cdda))(d___0, 0);
                    }
#line 1727
                    return;
                  }
                }
#line 1718
                i ++;
              }
              while_break: /* CIL Label */ ;
              }
              {
#line 1732
              d___0->fua = 0;
#line 1733
              cdmessage___3(d___0, "\tDrive rejected FUA bit.\n");
              }
#line 1738
              return;
            }
          }
        }
      }
    }
  }
#line 1740
  return;
}
}
#line 1743 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
static int check_atapi___0(cdrom_drive *d___0 ) 
{ 
  int atapiret ;
  int fd ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 1744
  atapiret = -1;
#line 1745
  fd = d___0->cdda_fd;
#line 1747
  cdmessage___3(d___0, "\nChecking for SCSI emulation...\n");
#line 1749
  tmp___0 = ioctl(fd, 8707UL, & atapiret);
  }
#line 1749
  if (tmp___0) {
    {
#line 1750
    cderror___2(d___0, "\tSG_EMULATED_HOST ioctl() failed!\n");
    }
#line 1751
    return (-1);
  } else {
#line 1753
    if (atapiret == 1) {
#line 1754
      if (d___0->interface == 3) {
        {
#line 1755
        cdmessage___3(d___0, "\tDrive is ATAPI (using SG_IO host adaptor emulation)\n");
        }
      } else
#line 1756
      if (d___0->interface == 4) {
        {
#line 1757
        cdmessage___3(d___0, "\tDrive is ATAPI (using SG_IO host adaptor emulation with workarounds)\n");
        }
      } else {
        {
#line 1759
        cdmessage___3(d___0, "\tDrive is ATAPI (using SCSI host adaptor emulation)\n");
#line 1761
        tmp = ioctl(fd, 8708UL, 0);
        }
#line 1761
        if (tmp) {
          {
#line 1762
          cderror___2(d___0, "\tCouldn\'t disable kernel command translation layer\n");
          }
        }
      }
#line 1764
      d___0->is_atapi = 1;
    } else {
      {
#line 1766
      cdmessage___3(d___0, "\tDrive is SCSI\n");
#line 1767
      d___0->is_atapi = 0;
      }
    }
#line 1770
    return (d___0->is_atapi);
  }
}
}
#line 1815 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
static int check_mmc___0(cdrom_drive *d___0 ) 
{ 
  unsigned char *b ;
  int tmp ;

  {
  {
#line 1817
  cdmessage___3(d___0, "\nChecking for MMC style command set...\n");
#line 1819
  d___0->is_mmc = 0;
#line 1820
  tmp = mode_sense___0(d___0, 22, 42);
  }
#line 1820
  if (tmp == 0) {
#line 1822
    b = (d___0->private_data)->sg_buffer;
#line 1823
    b += (int )*(b + 3) + 4;
#line 1825
    if (((int )*(b + 0) & 63) == 42) {
#line 1827
      d___0->is_mmc = 1;
#line 1829
      if ((int )*(b + 1) >= 4) {
#line 1830
        if ((int )*(b + 5) & 1) {
          {
#line 1831
          cdmessage___3(d___0, "\tDrive is MMC style\n");
          }
#line 1832
          return (1);
        } else {
          {
#line 1834
          cdmessage___3(d___0, "\tDrive is MMC, but reports CDDA incapable.\n");
#line 1835
          cdmessage___3(d___0, "\tIt will likely not be able to read audio data.\n");
          }
#line 1836
          return (1);
        }
      }
    }
  }
  {
#line 1842
  cdmessage___3(d___0, "\tDrive does not have MMC CDDA support\n");
  }
#line 1843
  return (0);
}
}
#line 1846 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
static void check_exceptions___2(cdrom_drive *d___0 , exception *list ) 
{ 
  int i ;
  size_t tmp ;
  int tmp___0 ;

  {
#line 1848
  i = 0;
  {
#line 1849
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1849
    if (! (list + i)->model) {
#line 1849
      goto while_break;
    }
    {
#line 1850
    tmp = strlen((char const   *)(list + i)->model);
#line 1850
    tmp___0 = strncmp((char const   *)(list + i)->model, (char const   *)d___0->drive_model,
                      tmp);
    }
#line 1850
    if (! tmp___0) {
#line 1851
      if ((list + i)->density) {
#line 1851
        d___0->density = (list + i)->density;
      }
#line 1852
      if ((list + i)->enable) {
#line 1852
        d___0->enable_cdda = (list + i)->enable;
      }
#line 1853
      if ((list + i)->read) {
#line 1853
        d___0->read_audio = (list + i)->read;
      }
#line 1854
      if ((list + i)->bigendianp != -1) {
#line 1854
        d___0->bigendianp = (list + i)->bigendianp;
      }
#line 1855
      return;
    }
#line 1857
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1859
  return;
}
}
#line 124 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/cdda_interface.h"
char *cdda_version(void) ;
#line 125
int cdda_speed_set(cdrom_drive *d___0 , int speed ) ;
#line 126
void cdda_verbose_set(cdrom_drive *d___0 , int err_action , int mes_action ) ;
#line 127
extern char *cdda_messages(cdrom_drive *d___0 ) ;
#line 128
extern char *cdda_errors(cdrom_drive *d___0 ) ;
#line 130
int cdda_close(cdrom_drive *d___0 ) ;
#line 131
int cdda_open(cdrom_drive *d___0 ) ;
#line 132
long cdda_read(cdrom_drive *d___0 , void *buffer , long beginsector , long sectors ) ;
#line 134
long cdda_read_timed(cdrom_drive *d___0 , void *buffer , long beginsector , long sectors ,
                     int *ms ) ;
#line 109 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/utils.h"
static void cderror___3(cdrom_drive *d___0 , char const   *s ) 
{ 
  size_t tmp ;

  {
#line 110
  if (s) {
#line 110
    if (d___0) {
      {
#line 112
      if (d___0->errordest == 1) {
#line 112
        goto case_1;
      }
#line 115
      if (d___0->errordest == 2) {
#line 115
        goto case_2;
      }
#line 119
      goto switch_default;
      case_1: /* CIL Label */ 
      {
#line 113
      tmp = strlen(s);
#line 113
      write(2, (void const   *)s, tmp);
      }
#line 114
      goto switch_break;
      case_2: /* CIL Label */ 
      {
#line 116
      d___0->errorbuf = catstring(d___0->errorbuf, s);
      }
#line 117
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 120
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
  }
#line 123
  return;
}
}
#line 17 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/interface.c"
char *cdda_version(void) 
{ 


  {
#line 18
  return ((char *)"10.2");
}
}
#line 21 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/interface.c"
static void _clean_messages(cdrom_drive *d___0 ) 
{ 


  {
#line 22
  if (d___0) {
#line 23
    if (d___0->messagebuf) {
      {
#line 23
      free((void *)d___0->messagebuf);
      }
    }
#line 24
    if (d___0->errorbuf) {
      {
#line 24
      free((void *)d___0->errorbuf);
      }
    }
#line 25
    d___0->messagebuf = (char *)((void *)0);
#line 26
    d___0->errorbuf = (char *)((void *)0);
  }
#line 28
  return;
}
}
#line 31 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/interface.c"
int cdda_close(cdrom_drive *d___0 ) 
{ 


  {
#line 32
  if (d___0) {
#line 33
    if (d___0->opened) {
      {
#line 34
      (*(d___0->enable_cdda))(d___0, 0);
      }
    }
    {
#line 36
    _clean_messages(d___0);
    }
#line 37
    if (d___0->cdda_device_name) {
      {
#line 37
      free((void *)d___0->cdda_device_name);
      }
    }
#line 38
    if (d___0->ioctl_device_name) {
      {
#line 38
      free((void *)d___0->ioctl_device_name);
      }
    }
#line 39
    if (d___0->drive_model) {
      {
#line 39
      free((void *)d___0->drive_model);
      }
    }
#line 40
    if (d___0->cdda_fd != -1) {
      {
#line 40
      close(d___0->cdda_fd);
      }
    }
#line 41
    if (d___0->ioctl_fd != -1) {
#line 41
      if (d___0->ioctl_fd != d___0->cdda_fd) {
        {
#line 41
        close(d___0->ioctl_fd);
        }
      }
    }
#line 42
    if (d___0->private_data) {
#line 44
      if ((d___0->private_data)->sg_hd) {
        {
#line 44
        free((void *)(d___0->private_data)->sg_hd);
        }
      }
      {
#line 52
      free((void *)d___0->private_data);
      }
    }
    {
#line 55
    free((void *)d___0);
    }
  }
#line 57
  return (0);
}
}
#line 61 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/interface.c"
int cdda_open(cdrom_drive *d___0 ) 
{ 
  int ret ;
  int i ;

  {
#line 63
  if (d___0->opened) {
#line 63
    return (0);
  }
  {
#line 68
  if (d___0->interface == 0) {
#line 68
    goto case_0;
  }
#line 68
  if (d___0->interface == 3) {
#line 68
    goto case_0;
  }
#line 68
  if (d___0->interface == 4) {
#line 68
    goto case_0;
  }
#line 72
  if (d___0->interface == 1) {
#line 72
    goto case_1;
  }
#line 82
  goto switch_default;
  case_0: /* CIL Label */ 
  case_3: /* CIL Label */ 
  case_4: /* CIL Label */ 
  {
#line 69
  ret = scsi_init_drive(d___0);
  }
#line 69
  if (ret) {
#line 70
    return (ret);
  }
#line 71
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 73
  ret = cooked_init_drive(d___0);
  }
#line 73
  if (ret) {
#line 74
    return (ret);
  }
#line 75
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 83
  cderror___3(d___0, "100: Interface not supported\n");
  }
#line 84
  return (-100);
  switch_break: /* CIL Label */ ;
  }
#line 92
  i = 0;
  {
#line 92
  while (1) {
    while_continue: /* CIL Label */ ;
#line 92
    if (! (i < d___0->tracks)) {
#line 92
      goto while_break;
    }
#line 93
    if (d___0->disc_toc[i].dwStartSector < 0) {
      {
#line 95
      d___0->opened = 0;
#line 96
      cderror___3(d___0, "009: CDROM reporting illegal table of contents\n");
      }
#line 97
      return (-9);
    } else
#line 93
    if (d___0->disc_toc[i + 1].dwStartSector == 0) {
      {
#line 95
      d___0->opened = 0;
#line 96
      cderror___3(d___0, "009: CDROM reporting illegal table of contents\n");
      }
#line 97
      return (-9);
    }
#line 92
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 101
  ret = (*(d___0->enable_cdda))(d___0, 1);
  }
#line 101
  if (ret) {
#line 102
    return (ret);
  }
#line 105
  if (d___0->bigendianp == -1) {
    {
#line 105
    d___0->bigendianp = data_bigendianp(d___0);
    }
  }
#line 106
  return (0);
}
}
#line 109 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/interface.c"
int cdda_speed_set(cdrom_drive *d___0 , int speed ) 
{ 
  int tmp ;

  {
#line 111
  if (d___0->set_speed) {
    {
#line 112
    tmp = (*(d___0->set_speed))(d___0, speed);
    }
#line 112
    if (! tmp) {
#line 112
      return (0);
    }
  }
  {
#line 114
  cderror___3(d___0, "405: Option not supported by drive\n");
  }
#line 115
  return (-405);
}
}
#line 118 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/interface.c"
long cdda_read_timed(cdrom_drive *d___0 , void *buffer , long beginsector , long sectors ,
                     int *ms ) 
{ 
  int i ;
  u_int16_t *p___0 ;
  long els ;
  int16_t tmp ;
  int tmp___0 ;

  {
#line 119
  if (ms) {
#line 119
    *ms = -1;
  }
#line 120
  if (d___0->opened) {
#line 121
    if (sectors > 0L) {
      {
#line 122
      sectors = (*(d___0->read_audio))(d___0, buffer, beginsector, sectors);
      }
#line 124
      if (sectors > 0L) {
#line 126
        if (d___0->bigendianp == -1) {
          {
#line 127
          d___0->bigendianp = data_bigendianp(d___0);
          }
        }
#line 129
        if (buffer) {
          {
#line 129
          tmp___0 = bigendianp();
          }
#line 129
          if (d___0->bigendianp != tmp___0) {
#line 131
            p___0 = (u_int16_t *)buffer;
#line 132
            els = (sectors * 2352L) / 2L;
#line 134
            i = 0;
            {
#line 134
            while (1) {
              while_continue: /* CIL Label */ ;
#line 134
              if (! ((long )i < els)) {
#line 134
                goto while_break;
              }
              {
#line 134
              tmp = swap16((int16_t )*(p___0 + i));
#line 134
              *(p___0 + i) = (u_int16_t )tmp;
#line 134
              i ++;
              }
            }
            while_break: /* CIL Label */ ;
            }
          }
        }
      }
    }
#line 138
    if (ms) {
#line 138
      *ms = (d___0->private_data)->last_milliseconds;
    }
#line 139
    return (sectors);
  }
  {
#line 142
  cderror___3(d___0, "400: Device not open\n");
  }
#line 143
  return (-400L);
}
}
#line 146 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/interface.c"
long cdda_read(cdrom_drive *d___0 , void *buffer , long beginsector , long sectors ) 
{ 
  long tmp ;

  {
  {
#line 147
  tmp = cdda_read_timed(d___0, buffer, beginsector, sectors, (int *)((void *)0));
  }
#line 147
  return (tmp);
}
}
#line 150 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/interface.c"
void cdda_verbose_set(cdrom_drive *d___0 , int err_action , int mes_action ) 
{ 


  {
#line 151
  d___0->messagedest = mes_action;
#line 152
  d___0->errordest = err_action;
#line 153
  return;
}
}
#line 155 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/interface.c"
extern char *cdda_messages(cdrom_drive *d___0 ) 
{ 
  char *ret ;

  {
#line 156
  ret = d___0->messagebuf;
#line 157
  d___0->messagebuf = (char *)((void *)0);
#line 158
  return (ret);
}
}
#line 161 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/interface.c"
extern char *cdda_errors(cdrom_drive *d___0 ) 
{ 
  char *ret ;

  {
#line 162
  ret = d___0->errorbuf;
#line 163
  d___0->errorbuf = (char *)((void *)0);
#line 164
  return (ret);
}
}
#line 63 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) cos)(double __x ) ;
#line 65
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) sin)(double __x ) ;
#line 11 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/smallft.h"
void fft_backward(int n , float *buf , float *trigcache , int *splitcache ) ;
#line 12
void fft_i(int n , float **trigcache , int **splitcache ) ;
#line 18 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/smallft.c"
static void drfti1(int n , float *wa , int *ifac ) ;
#line 18 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/smallft.c"
static int ntryh[4]  = {      4,      2,      3,      5};
#line 19 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/smallft.c"
static float tpi  =    (float )6.28318530717958647692528676655900577;
#line 17 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/smallft.c"
static void drfti1(int n , float *wa , int *ifac ) 
{ 
  float arg ;
  float argh ;
  float argld ;
  float fi ;
  int ntry ;
  int i ;
  int j ;
  int k1 ;
  int l1 ;
  int l2 ;
  int ib ;
  int ld ;
  int ii ;
  int ip ;
  int is ;
  int nq ;
  int nr ;
  int ido ;
  int ipm ;
  int nfm1 ;
  int nl ;
  int nf ;
  int tmp ;
  double tmp___0 ;
  int tmp___1 ;
  double tmp___2 ;

  {
#line 21
  ntry = 0;
#line 21
  j = -1;
#line 25
  nl = n;
#line 26
  nf = 0;
  L101: 
#line 29
  j ++;
#line 30
  if (j < 4) {
#line 31
    ntry = ntryh[j];
  } else {
#line 33
    ntry += 2;
  }
  L104: 
#line 36
  nq = nl / ntry;
#line 37
  nr = nl - ntry * nq;
#line 38
  if (nr != 0) {
#line 38
    goto L101;
  }
#line 40
  nf ++;
#line 41
  *(ifac + (nf + 1)) = ntry;
#line 42
  nl = nq;
#line 43
  if (ntry != 2) {
#line 43
    goto L107;
  }
#line 44
  if (nf == 1) {
#line 44
    goto L107;
  }
#line 46
  i = 1;
  {
#line 46
  while (1) {
    while_continue: /* CIL Label */ ;
#line 46
    if (! (i < nf)) {
#line 46
      goto while_break;
    }
#line 47
    ib = (nf - i) + 1;
#line 48
    *(ifac + (ib + 1)) = *(ifac + ib);
#line 46
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 50
  *(ifac + 2) = 2;
  L107: 
#line 53
  if (nl != 1) {
#line 53
    goto L104;
  }
#line 54
  *(ifac + 0) = n;
#line 55
  *(ifac + 1) = nf;
#line 56
  argh = tpi / (float )n;
#line 57
  is = 0;
#line 58
  nfm1 = nf - 1;
#line 59
  l1 = 1;
#line 61
  if (nfm1 == 0) {
#line 61
    return;
  }
#line 63
  k1 = 0;
  {
#line 63
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 63
    if (! (k1 < nfm1)) {
#line 63
      goto while_break___0;
    }
#line 64
    ip = *(ifac + (k1 + 2));
#line 65
    ld = 0;
#line 66
    l2 = l1 * ip;
#line 67
    ido = n / l2;
#line 68
    ipm = ip - 1;
#line 70
    j = 0;
    {
#line 70
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 70
      if (! (j < ipm)) {
#line 70
        goto while_break___1;
      }
#line 71
      ld += l1;
#line 72
      i = is;
#line 73
      argld = (float )ld * argh;
#line 74
      fi = (float )0.;
#line 75
      ii = 2;
      {
#line 75
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 75
        if (! (ii < ido)) {
#line 75
          goto while_break___2;
        }
        {
#line 76
        fi = (float )((double )fi + 1.);
#line 77
        arg = fi * argld;
#line 78
        tmp = i;
#line 78
        i ++;
#line 78
        tmp___0 = cos((double )arg);
#line 78
        *(wa + tmp) = (float )tmp___0;
#line 79
        tmp___1 = i;
#line 79
        i ++;
#line 79
        tmp___2 = sin((double )arg);
#line 79
        *(wa + tmp___1) = (float )tmp___2;
#line 75
        ii += 2;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
#line 81
      is += ido;
#line 70
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 83
    l1 = l2;
#line 63
    k1 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 85
  return;
}
}
#line 87 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/smallft.c"
static void fdrffti(int n , float *wsave , int *ifac ) 
{ 


  {
#line 89
  if (n == 1) {
#line 89
    return;
  }
  {
#line 90
  drfti1(n, wsave + n, ifac);
  }
#line 91
  return;
}
}
#line 93 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/smallft.c"
static void dradf2(int ido , int l1 , float *cc , float *ch , float *wa1 ) 
{ 
  int i ;
  int k ;
  float ti2 ;
  float tr2 ;
  int t0 ;
  int t1 ;
  int t2 ;
  int t3 ;
  int t4 ;
  int t5 ;
  int t6 ;

  {
#line 98
  t1 = 0;
#line 99
  t2 = l1 * ido;
#line 99
  t0 = t2;
#line 100
  t3 = ido << 1;
#line 101
  k = 0;
  {
#line 101
  while (1) {
    while_continue: /* CIL Label */ ;
#line 101
    if (! (k < l1)) {
#line 101
      goto while_break;
    }
#line 102
    *(ch + (t1 << 1)) = *(cc + t1) + *(cc + t2);
#line 103
    *(ch + (((t1 << 1) + t3) - 1)) = *(cc + t1) - *(cc + t2);
#line 104
    t1 += ido;
#line 105
    t2 += ido;
#line 101
    k ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 108
  if (ido < 2) {
#line 108
    return;
  }
#line 109
  if (ido == 2) {
#line 109
    goto L105;
  }
#line 111
  t1 = 0;
#line 112
  t2 = t0;
#line 113
  k = 0;
  {
#line 113
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 113
    if (! (k < l1)) {
#line 113
      goto while_break___0;
    }
#line 114
    t3 = t2;
#line 115
    t4 = (t1 << 1) + (ido << 1);
#line 116
    t5 = t1;
#line 117
    t6 = t1 + t1;
#line 118
    i = 2;
    {
#line 118
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 118
      if (! (i < ido)) {
#line 118
        goto while_break___1;
      }
#line 119
      t3 += 2;
#line 120
      t4 -= 2;
#line 121
      t5 += 2;
#line 122
      t6 += 2;
#line 123
      tr2 = *(wa1 + (i - 2)) * *(cc + (t3 - 1)) + *(wa1 + (i - 1)) * *(cc + t3);
#line 124
      ti2 = *(wa1 + (i - 2)) * *(cc + t3) - *(wa1 + (i - 1)) * *(cc + (t3 - 1));
#line 125
      *(ch + t6) = *(cc + t5) + ti2;
#line 126
      *(ch + t4) = ti2 - *(cc + t5);
#line 127
      *(ch + (t6 - 1)) = *(cc + (t5 - 1)) + tr2;
#line 128
      *(ch + (t4 - 1)) = *(cc + (t5 - 1)) - tr2;
#line 118
      i += 2;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 130
    t1 += ido;
#line 131
    t2 += ido;
#line 113
    k ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 134
  if (ido % 2 == 1) {
#line 134
    return;
  }
  L105: 
#line 137
  t1 = ido;
#line 137
  t2 = t1 - 1;
#line 137
  t3 = t2;
#line 138
  t2 += t0;
#line 139
  k = 0;
  {
#line 139
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 139
    if (! (k < l1)) {
#line 139
      goto while_break___2;
    }
#line 140
    *(ch + t1) = - *(cc + t2);
#line 141
    *(ch + (t1 - 1)) = *(cc + t3);
#line 142
    t1 += ido << 1;
#line 143
    t2 += ido;
#line 144
    t3 += ido;
#line 139
    k ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 146
  return;
}
}
#line 150
static void dradf4(int ido , int l1 , float *cc , float *ch , float *wa1 , float *wa2 ,
                   float *wa3 ) ;
#line 150 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/smallft.c"
static float hsqt2  =    (float ).70710678118654752440084436210485;
#line 148 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/smallft.c"
static void dradf4(int ido , int l1 , float *cc , float *ch , float *wa1 , float *wa2 ,
                   float *wa3 ) 
{ 
  int i ;
  int k ;
  int t0 ;
  int t1 ;
  int t2 ;
  int t3 ;
  int t4 ;
  int t5 ;
  int t6 ;
  float ci2 ;
  float ci3 ;
  float ci4 ;
  float cr2 ;
  float cr3 ;
  float cr4 ;
  float ti1 ;
  float ti2 ;
  float ti3 ;
  float ti4 ;
  float tr1 ;
  float tr2 ;
  float tr3 ;
  float tr4 ;

  {
#line 153
  t0 = l1 * ido;
#line 155
  t1 = t0;
#line 156
  t4 = t1 << 1;
#line 157
  t2 = t1 + (t1 << 1);
#line 158
  t3 = 0;
#line 160
  k = 0;
  {
#line 160
  while (1) {
    while_continue: /* CIL Label */ ;
#line 160
    if (! (k < l1)) {
#line 160
      goto while_break;
    }
#line 161
    tr1 = *(cc + t1) + *(cc + t2);
#line 162
    tr2 = *(cc + t3) + *(cc + t4);
#line 164
    t5 = t3 << 2;
#line 164
    *(ch + t5) = tr1 + tr2;
#line 165
    *(ch + (((ido << 2) + t5) - 1)) = tr2 - tr1;
#line 166
    t5 += ido << 1;
#line 166
    *(ch + (t5 - 1)) = *(cc + t3) - *(cc + t4);
#line 167
    *(ch + t5) = *(cc + t2) - *(cc + t1);
#line 169
    t1 += ido;
#line 170
    t2 += ido;
#line 171
    t3 += ido;
#line 172
    t4 += ido;
#line 160
    k ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 175
  if (ido < 2) {
#line 175
    return;
  }
#line 176
  if (ido == 2) {
#line 176
    goto L105;
  }
#line 179
  t1 = 0;
#line 180
  k = 0;
  {
#line 180
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 180
    if (! (k < l1)) {
#line 180
      goto while_break___0;
    }
#line 181
    t2 = t1;
#line 182
    t4 = t1 << 2;
#line 183
    t6 = ido << 1;
#line 183
    t5 = t6 + t4;
#line 184
    i = 2;
    {
#line 184
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 184
      if (! (i < ido)) {
#line 184
        goto while_break___1;
      }
#line 185
      t2 += 2;
#line 185
      t3 = t2;
#line 186
      t4 += 2;
#line 187
      t5 -= 2;
#line 189
      t3 += t0;
#line 190
      cr2 = *(wa1 + (i - 2)) * *(cc + (t3 - 1)) + *(wa1 + (i - 1)) * *(cc + t3);
#line 191
      ci2 = *(wa1 + (i - 2)) * *(cc + t3) - *(wa1 + (i - 1)) * *(cc + (t3 - 1));
#line 192
      t3 += t0;
#line 193
      cr3 = *(wa2 + (i - 2)) * *(cc + (t3 - 1)) + *(wa2 + (i - 1)) * *(cc + t3);
#line 194
      ci3 = *(wa2 + (i - 2)) * *(cc + t3) - *(wa2 + (i - 1)) * *(cc + (t3 - 1));
#line 195
      t3 += t0;
#line 196
      cr4 = *(wa3 + (i - 2)) * *(cc + (t3 - 1)) + *(wa3 + (i - 1)) * *(cc + t3);
#line 197
      ci4 = *(wa3 + (i - 2)) * *(cc + t3) - *(wa3 + (i - 1)) * *(cc + (t3 - 1));
#line 199
      tr1 = cr2 + cr4;
#line 200
      tr4 = cr4 - cr2;
#line 201
      ti1 = ci2 + ci4;
#line 202
      ti4 = ci2 - ci4;
#line 204
      ti2 = *(cc + t2) + ci3;
#line 205
      ti3 = *(cc + t2) - ci3;
#line 206
      tr2 = *(cc + (t2 - 1)) + cr3;
#line 207
      tr3 = *(cc + (t2 - 1)) - cr3;
#line 209
      *(ch + (t4 - 1)) = tr1 + tr2;
#line 210
      *(ch + t4) = ti1 + ti2;
#line 212
      *(ch + (t5 - 1)) = tr3 - ti4;
#line 213
      *(ch + t5) = tr4 - ti3;
#line 215
      *(ch + ((t4 + t6) - 1)) = ti4 + tr3;
#line 216
      *(ch + (t4 + t6)) = tr4 + ti3;
#line 218
      *(ch + ((t5 + t6) - 1)) = tr2 - tr1;
#line 219
      *(ch + (t5 + t6)) = ti1 - ti2;
#line 184
      i += 2;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 221
    t1 += ido;
#line 180
    k ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 223
  if (ido & 1) {
#line 223
    return;
  }
  L105: 
#line 227
  t1 = (t0 + ido) - 1;
#line 227
  t2 = t1 + (t0 << 1);
#line 228
  t3 = ido << 2;
#line 229
  t4 = ido;
#line 230
  t5 = ido << 1;
#line 231
  t6 = ido;
#line 233
  k = 0;
  {
#line 233
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 233
    if (! (k < l1)) {
#line 233
      goto while_break___2;
    }
#line 234
    ti1 = - hsqt2 * (*(cc + t1) + *(cc + t2));
#line 235
    tr1 = hsqt2 * (*(cc + t1) - *(cc + t2));
#line 237
    *(ch + (t4 - 1)) = tr1 + *(cc + (t6 - 1));
#line 238
    *(ch + ((t4 + t5) - 1)) = *(cc + (t6 - 1)) - tr1;
#line 240
    *(ch + t4) = ti1 - *(cc + (t1 + t0));
#line 241
    *(ch + (t4 + t5)) = ti1 + *(cc + (t1 + t0));
#line 243
    t1 += ido;
#line 244
    t2 += ido;
#line 245
    t4 += t3;
#line 246
    t6 += ido;
#line 233
    k ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 248
  return;
}
}
#line 250 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/smallft.c"
static void drftf1(int n , float *c , float *ch , float *wa , int *ifac ) 
{ 
  int i ;
  int k1 ;
  int l1 ;
  int l2 ;
  int na ;
  int kh ;
  int nf ;
  int ip ;
  int iw ;
  int ido ;
  int idl1 ;
  int ix2 ;
  int ix3 ;

  {
#line 255
  nf = *(ifac + 1);
#line 256
  na = 1;
#line 257
  l2 = n;
#line 258
  iw = n;
#line 260
  k1 = 0;
  {
#line 260
  while (1) {
    while_continue: /* CIL Label */ ;
#line 260
    if (! (k1 < nf)) {
#line 260
      goto while_break;
    }
#line 261
    kh = nf - k1;
#line 262
    ip = *(ifac + (kh + 1));
#line 263
    l1 = l2 / ip;
#line 264
    ido = n / l2;
#line 265
    idl1 = ido * l1;
#line 266
    iw -= (ip - 1) * ido;
#line 267
    na = 1 - na;
#line 269
    if (ip != 4) {
#line 269
      goto L102;
    }
#line 271
    ix2 = iw + ido;
#line 272
    ix3 = ix2 + ido;
#line 273
    if (na != 0) {
      {
#line 274
      dradf4(ido, l1, ch, c, (wa + iw) - 1, (wa + ix2) - 1, (wa + ix3) - 1);
      }
    } else {
      {
#line 276
      dradf4(ido, l1, c, ch, (wa + iw) - 1, (wa + ix2) - 1, (wa + ix3) - 1);
      }
    }
#line 277
    goto L110;
    L102: 
#line 280
    if (ip != 2) {
#line 280
      goto L104;
    }
#line 281
    if (na != 0) {
#line 281
      goto L103;
    }
    {
#line 283
    dradf2(ido, l1, c, ch, (wa + iw) - 1);
    }
#line 284
    goto L110;
    L103: 
    {
#line 287
    dradf2(ido, l1, ch, c, (wa + iw) - 1);
    }
#line 288
    goto L110;
    L104: 
#line 291
    return;
    L110: 
#line 294
    l2 = l1;
#line 260
    k1 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 297
  if (na == 1) {
#line 297
    return;
  }
#line 299
  i = 0;
  {
#line 299
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 299
    if (! (i < n)) {
#line 299
      goto while_break___0;
    }
#line 299
    *(c + i) = *(ch + i);
#line 299
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 300
  return;
}
}
#line 302 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/smallft.c"
static void fdrfftf(int n , float *r , float *wsave , int *ifac ) 
{ 


  {
#line 303
  if (n == 1) {
#line 303
    return;
  }
  {
#line 304
  drftf1(n, r, wsave, wsave + n, ifac);
  }
#line 305
  return;
}
}
#line 307 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/smallft.c"
static void dradb2(int ido , int l1 , float *cc , float *ch , float *wa1 ) 
{ 
  int i ;
  int k ;
  int t0 ;
  int t1 ;
  int t2 ;
  int t3 ;
  int t4 ;
  int t5 ;
  int t6 ;
  float ti2 ;
  float tr2 ;

  {
#line 311
  t0 = l1 * ido;
#line 313
  t1 = 0;
#line 314
  t2 = 0;
#line 315
  t3 = (ido << 1) - 1;
#line 316
  k = 0;
  {
#line 316
  while (1) {
    while_continue: /* CIL Label */ ;
#line 316
    if (! (k < l1)) {
#line 316
      goto while_break;
    }
#line 317
    *(ch + t1) = *(cc + t2) + *(cc + (t3 + t2));
#line 318
    *(ch + (t1 + t0)) = *(cc + t2) - *(cc + (t3 + t2));
#line 319
    t1 += ido;
#line 319
    t2 = t1 << 1;
#line 316
    k ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 322
  if (ido < 2) {
#line 322
    return;
  }
#line 323
  if (ido == 2) {
#line 323
    goto L105;
  }
#line 325
  t1 = 0;
#line 326
  t2 = 0;
#line 327
  k = 0;
  {
#line 327
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 327
    if (! (k < l1)) {
#line 327
      goto while_break___0;
    }
#line 328
    t3 = t1;
#line 329
    t4 = t2;
#line 329
    t5 = t4 + (ido << 1);
#line 330
    t6 = t0 + t1;
#line 331
    i = 2;
    {
#line 331
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 331
      if (! (i < ido)) {
#line 331
        goto while_break___1;
      }
#line 332
      t3 += 2;
#line 333
      t4 += 2;
#line 334
      t5 -= 2;
#line 335
      t6 += 2;
#line 336
      *(ch + (t3 - 1)) = *(cc + (t4 - 1)) + *(cc + (t5 - 1));
#line 337
      tr2 = *(cc + (t4 - 1)) - *(cc + (t5 - 1));
#line 338
      *(ch + t3) = *(cc + t4) - *(cc + t5);
#line 339
      ti2 = *(cc + t4) + *(cc + t5);
#line 340
      *(ch + (t6 - 1)) = *(wa1 + (i - 2)) * tr2 - *(wa1 + (i - 1)) * ti2;
#line 341
      *(ch + t6) = *(wa1 + (i - 2)) * ti2 + *(wa1 + (i - 1)) * tr2;
#line 331
      i += 2;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 343
    t1 += ido;
#line 343
    t2 = t1 << 1;
#line 327
    k ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 346
  if (ido % 2 == 1) {
#line 346
    return;
  }
  L105: 
#line 349
  t1 = ido - 1;
#line 350
  t2 = ido - 1;
#line 351
  k = 0;
  {
#line 351
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 351
    if (! (k < l1)) {
#line 351
      goto while_break___2;
    }
#line 352
    *(ch + t1) = *(cc + t2) + *(cc + t2);
#line 353
    *(ch + (t1 + t0)) = - (*(cc + (t2 + 1)) + *(cc + (t2 + 1)));
#line 354
    t1 += ido;
#line 355
    t2 += ido << 1;
#line 351
    k ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 357
  return;
}
}
#line 361
static void dradb4(int ido , int l1 , float *cc , float *ch , float *wa1 , float *wa2 ,
                   float *wa3 ) ;
#line 361 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/smallft.c"
static float sqrt2  =    (float )1.4142135623730950488016887242097;
#line 359 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/smallft.c"
static void dradb4(int ido , int l1 , float *cc , float *ch , float *wa1 , float *wa2 ,
                   float *wa3 ) 
{ 
  int i ;
  int k ;
  int t0 ;
  int t1 ;
  int t2 ;
  int t3 ;
  int t4 ;
  int t5 ;
  int t6 ;
  int t7 ;
  int t8 ;
  float ci2 ;
  float ci3 ;
  float ci4 ;
  float cr2 ;
  float cr3 ;
  float cr4 ;
  float ti1 ;
  float ti2 ;
  float ti3 ;
  float ti4 ;
  float tr1 ;
  float tr2 ;
  float tr3 ;
  float tr4 ;

  {
#line 364
  t0 = l1 * ido;
#line 366
  t1 = 0;
#line 367
  t2 = ido << 2;
#line 368
  t3 = 0;
#line 369
  t6 = ido << 1;
#line 370
  k = 0;
  {
#line 370
  while (1) {
    while_continue: /* CIL Label */ ;
#line 370
    if (! (k < l1)) {
#line 370
      goto while_break;
    }
#line 371
    t4 = t3 + t6;
#line 372
    t5 = t1;
#line 373
    tr3 = *(cc + (t4 - 1)) + *(cc + (t4 - 1));
#line 374
    tr4 = *(cc + t4) + *(cc + t4);
#line 375
    t4 += t6;
#line 375
    tr1 = *(cc + t3) - *(cc + (t4 - 1));
#line 376
    tr2 = *(cc + t3) + *(cc + (t4 - 1));
#line 377
    *(ch + t5) = tr2 + tr3;
#line 378
    t5 += t0;
#line 378
    *(ch + t5) = tr1 - tr4;
#line 379
    t5 += t0;
#line 379
    *(ch + t5) = tr2 - tr3;
#line 380
    t5 += t0;
#line 380
    *(ch + t5) = tr1 + tr4;
#line 381
    t1 += ido;
#line 382
    t3 += t2;
#line 370
    k ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 385
  if (ido < 2) {
#line 385
    return;
  }
#line 386
  if (ido == 2) {
#line 386
    goto L105;
  }
#line 388
  t1 = 0;
#line 389
  k = 0;
  {
#line 389
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 389
    if (! (k < l1)) {
#line 389
      goto while_break___0;
    }
#line 390
    t2 = t1 << 2;
#line 390
    t3 = t2 + t6;
#line 390
    t4 = t3;
#line 390
    t5 = t4 + t6;
#line 391
    t7 = t1;
#line 392
    i = 2;
    {
#line 392
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 392
      if (! (i < ido)) {
#line 392
        goto while_break___1;
      }
#line 393
      t2 += 2;
#line 394
      t3 += 2;
#line 395
      t4 -= 2;
#line 396
      t5 -= 2;
#line 397
      t7 += 2;
#line 398
      ti1 = *(cc + t2) + *(cc + t5);
#line 399
      ti2 = *(cc + t2) - *(cc + t5);
#line 400
      ti3 = *(cc + t3) - *(cc + t4);
#line 401
      tr4 = *(cc + t3) + *(cc + t4);
#line 402
      tr1 = *(cc + (t2 - 1)) - *(cc + (t5 - 1));
#line 403
      tr2 = *(cc + (t2 - 1)) + *(cc + (t5 - 1));
#line 404
      ti4 = *(cc + (t3 - 1)) - *(cc + (t4 - 1));
#line 405
      tr3 = *(cc + (t3 - 1)) + *(cc + (t4 - 1));
#line 406
      *(ch + (t7 - 1)) = tr2 + tr3;
#line 407
      cr3 = tr2 - tr3;
#line 408
      *(ch + t7) = ti2 + ti3;
#line 409
      ci3 = ti2 - ti3;
#line 410
      cr2 = tr1 - tr4;
#line 411
      cr4 = tr1 + tr4;
#line 412
      ci2 = ti1 + ti4;
#line 413
      ci4 = ti1 - ti4;
#line 415
      t8 = t7 + t0;
#line 415
      *(ch + (t8 - 1)) = *(wa1 + (i - 2)) * cr2 - *(wa1 + (i - 1)) * ci2;
#line 416
      *(ch + t8) = *(wa1 + (i - 2)) * ci2 + *(wa1 + (i - 1)) * cr2;
#line 417
      t8 += t0;
#line 417
      *(ch + (t8 - 1)) = *(wa2 + (i - 2)) * cr3 - *(wa2 + (i - 1)) * ci3;
#line 418
      *(ch + t8) = *(wa2 + (i - 2)) * ci3 + *(wa2 + (i - 1)) * cr3;
#line 419
      t8 += t0;
#line 419
      *(ch + (t8 - 1)) = *(wa3 + (i - 2)) * cr4 - *(wa3 + (i - 1)) * ci4;
#line 420
      *(ch + t8) = *(wa3 + (i - 2)) * ci4 + *(wa3 + (i - 1)) * cr4;
#line 392
      i += 2;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 422
    t1 += ido;
#line 389
    k ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 425
  if (ido % 2 == 1) {
#line 425
    return;
  }
  L105: 
#line 429
  t1 = ido;
#line 430
  t2 = ido << 2;
#line 431
  t3 = ido - 1;
#line 432
  t4 = ido + (ido << 1);
#line 433
  k = 0;
  {
#line 433
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 433
    if (! (k < l1)) {
#line 433
      goto while_break___2;
    }
#line 434
    t5 = t3;
#line 435
    ti1 = *(cc + t1) + *(cc + t4);
#line 436
    ti2 = *(cc + t4) - *(cc + t1);
#line 437
    tr1 = *(cc + (t1 - 1)) - *(cc + (t4 - 1));
#line 438
    tr2 = *(cc + (t1 - 1)) + *(cc + (t4 - 1));
#line 439
    *(ch + t5) = tr2 + tr2;
#line 440
    t5 += t0;
#line 440
    *(ch + t5) = sqrt2 * (tr1 - ti1);
#line 441
    t5 += t0;
#line 441
    *(ch + t5) = ti2 + ti2;
#line 442
    t5 += t0;
#line 442
    *(ch + t5) = - sqrt2 * (tr1 + ti1);
#line 444
    t3 += ido;
#line 445
    t1 += t2;
#line 446
    t4 += t2;
#line 433
    k ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 448
  return;
}
}
#line 450 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/smallft.c"
static void drftb1(int n , float *c , float *ch , float *wa , int *ifac ) 
{ 
  int i ;
  int k1 ;
  int l1 ;
  int l2 ;
  int na ;
  int nf ;
  int ip ;
  int iw ;
  int ix2 ;
  int ix3 ;
  int ido ;
  int idl1 ;

  {
#line 455
  nf = *(ifac + 1);
#line 456
  na = 0;
#line 457
  l1 = 1;
#line 458
  iw = 1;
#line 460
  k1 = 0;
  {
#line 460
  while (1) {
    while_continue: /* CIL Label */ ;
#line 460
    if (! (k1 < nf)) {
#line 460
      goto while_break;
    }
#line 461
    ip = *(ifac + (k1 + 2));
#line 462
    l2 = ip * l1;
#line 463
    ido = n / l2;
#line 464
    idl1 = ido * l1;
#line 465
    if (ip != 4) {
#line 465
      goto L103;
    }
#line 466
    ix2 = iw + ido;
#line 467
    ix3 = ix2 + ido;
#line 469
    if (na != 0) {
      {
#line 470
      dradb4(ido, l1, ch, c, (wa + iw) - 1, (wa + ix2) - 1, (wa + ix3) - 1);
      }
    } else {
      {
#line 472
      dradb4(ido, l1, c, ch, (wa + iw) - 1, (wa + ix2) - 1, (wa + ix3) - 1);
      }
    }
#line 473
    na = 1 - na;
#line 474
    goto L115;
    L103: 
#line 477
    if (ip != 2) {
#line 477
      goto L106;
    }
#line 479
    if (na != 0) {
      {
#line 480
      dradb2(ido, l1, ch, c, (wa + iw) - 1);
      }
    } else {
      {
#line 482
      dradb2(ido, l1, c, ch, (wa + iw) - 1);
      }
    }
#line 483
    na = 1 - na;
#line 484
    goto L115;
    L106: 
#line 487
    return;
    L115: 
#line 490
    l1 = l2;
#line 491
    iw += (ip - 1) * ido;
#line 460
    k1 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 494
  if (na == 0) {
#line 494
    return;
  }
#line 496
  i = 0;
  {
#line 496
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 496
    if (! (i < n)) {
#line 496
      goto while_break___0;
    }
#line 496
    *(c + i) = *(ch + i);
#line 496
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 497
  return;
}
}
#line 499 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/smallft.c"
static void fdrfftb(int n , float *r , float *wsave , int *ifac ) 
{ 


  {
#line 500
  if (n == 1) {
#line 500
    return;
  }
  {
#line 501
  drftb1(n, r, wsave, wsave + n, ifac);
  }
#line 502
  return;
}
}
#line 504 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/smallft.c"
void fft_forward(int n , float *buf , float *trigcache , int *splitcache ) 
{ 
  int flag ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 505
  flag = 0;
#line 507
  if (! trigcache) {
#line 507
    goto _L;
  } else
#line 507
  if (! splitcache) {
    _L: /* CIL Label */ 
    {
#line 508
    tmp = calloc((size_t )(3 * n), sizeof(float ));
#line 508
    trigcache = (float *)tmp;
#line 509
    tmp___0 = calloc((size_t )32, sizeof(int ));
#line 509
    splitcache = (int *)tmp___0;
#line 510
    fdrffti(n, trigcache, splitcache);
#line 511
    flag = 1;
    }
  }
  {
#line 514
  fdrfftf(n, buf, trigcache, splitcache);
  }
#line 516
  if (flag) {
    {
#line 517
    free((void *)trigcache);
#line 518
    free((void *)splitcache);
    }
  }
#line 520
  return;
}
}
#line 522 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/smallft.c"
void fft_backward(int n , float *buf , float *trigcache , int *splitcache ) 
{ 
  int i ;
  int flag ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 524
  flag = 0;
#line 526
  if (! trigcache) {
#line 526
    goto _L;
  } else
#line 526
  if (! splitcache) {
    _L: /* CIL Label */ 
    {
#line 527
    tmp = calloc((size_t )(3 * n), sizeof(float ));
#line 527
    trigcache = (float *)tmp;
#line 528
    tmp___0 = calloc((size_t )32, sizeof(int ));
#line 528
    splitcache = (int *)tmp___0;
#line 529
    fdrffti(n, trigcache, splitcache);
#line 530
    flag = 1;
    }
  }
  {
#line 533
  fdrfftb(n, buf, trigcache, splitcache);
#line 535
  i = 0;
  }
  {
#line 535
  while (1) {
    while_continue: /* CIL Label */ ;
#line 535
    if (! (i < n)) {
#line 535
      goto while_break;
    }
#line 535
    *(buf + i) /= (float )n;
#line 535
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 537
  if (flag) {
    {
#line 538
    free((void *)trigcache);
#line 539
    free((void *)splitcache);
    }
  }
#line 541
  return;
}
}
#line 543 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/smallft.c"
void fft_i(int n , float **trigcache , int **splitcache ) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 544
  tmp = calloc((size_t )(3 * n), sizeof(float ));
#line 544
  *trigcache = (float *)tmp;
#line 545
  tmp___0 = calloc((size_t )32, sizeof(int ));
#line 545
  *splitcache = (int *)tmp___0;
#line 546
  fdrffti(n, *trigcache, *splitcache);
  }
#line 547
  return;
}
}
#line 141 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/cdda_interface.h"
int cdda_track_channels(cdrom_drive *d___0 , int track ) ;
#line 143
int cdda_track_copyp(cdrom_drive *d___0 , int track ) ;
#line 144
int cdda_track_preemp(cdrom_drive *d___0 , int track ) ;
#line 109 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/utils.h"
static void cderror___4(cdrom_drive *d___0 , char const   *s ) 
{ 
  size_t tmp ;

  {
#line 110
  if (s) {
#line 110
    if (d___0) {
      {
#line 112
      if (d___0->errordest == 1) {
#line 112
        goto case_1;
      }
#line 115
      if (d___0->errordest == 2) {
#line 115
        goto case_2;
      }
#line 119
      goto switch_default;
      case_1: /* CIL Label */ 
      {
#line 113
      tmp = strlen(s);
#line 113
      write(2, (void const   *)s, tmp);
      }
#line 114
      goto switch_break;
      case_2: /* CIL Label */ 
      {
#line 116
      d___0->errorbuf = catstring(d___0->errorbuf, s);
      }
#line 117
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 120
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
  }
#line 123
  return;
}
}
#line 13 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/toc.c"
long cdda_track_firstsector(cdrom_drive *d___0 , int track ) 
{ 


  {
#line 14
  if (! d___0->opened) {
    {
#line 15
    cderror___4(d___0, "400: Device not open\n");
    }
#line 16
    return (-400L);
  }
#line 19
  if (track == 0) {
#line 20
    if (d___0->disc_toc[0].dwStartSector == 0) {
      {
#line 22
      cderror___4(d___0, "401: Invalid track number\n");
      }
#line 23
      return (-401L);
    } else {
#line 26
      return (0L);
    }
  }
#line 30
  if (track < 0) {
    {
#line 31
    cderror___4(d___0, "401: Invalid track number\n");
    }
#line 32
    return (-401L);
  } else
#line 30
  if (track > d___0->tracks) {
    {
#line 31
    cderror___4(d___0, "401: Invalid track number\n");
    }
#line 32
    return (-401L);
  }
#line 34
  return ((long )d___0->disc_toc[track - 1].dwStartSector);
}
}
#line 37 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/toc.c"
long cdda_disc_firstsector(cdrom_drive *d___0 ) 
{ 
  int i ;
  long tmp ;
  int tmp___0 ;

  {
#line 39
  if (! d___0->opened) {
    {
#line 40
    cderror___4(d___0, "400: Device not open\n");
    }
#line 41
    return (-400L);
  }
#line 45
  i = 0;
  {
#line 45
  while (1) {
    while_continue: /* CIL Label */ ;
#line 45
    if (! (i < d___0->tracks)) {
#line 45
      goto while_break;
    }
    {
#line 46
    tmp___0 = cdda_track_audiop(d___0, i + 1);
    }
#line 46
    if (tmp___0 == 1) {
#line 47
      if (i == 0) {
#line 48
        return (0L);
      } else {
        {
#line 50
        tmp = cdda_track_firstsector(d___0, i + 1);
        }
#line 50
        return (tmp);
      }
    }
#line 45
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 53
  cderror___4(d___0, "403: No audio tracks on disc\n");
  }
#line 54
  return (-403L);
}
}
#line 57 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/toc.c"
long cdda_track_lastsector(cdrom_drive *d___0 , int track ) 
{ 


  {
#line 58
  if (! d___0->opened) {
    {
#line 59
    cderror___4(d___0, "400: Device not open\n");
    }
#line 60
    return (-400L);
  }
#line 63
  if (track == 0) {
#line 64
    if (d___0->disc_toc[0].dwStartSector == 0) {
      {
#line 66
      cderror___4(d___0, "401: Invalid track number\n");
      }
#line 67
      return (-401L);
    } else {
#line 70
      return ((long )(d___0->disc_toc[0].dwStartSector - 1));
    }
  }
#line 74
  if (track < 1) {
    {
#line 75
    cderror___4(d___0, "401: Invalid track number\n");
    }
#line 76
    return (-401L);
  } else
#line 74
  if (track > d___0->tracks) {
    {
#line 75
    cderror___4(d___0, "401: Invalid track number\n");
    }
#line 76
    return (-401L);
  }
#line 79
  return ((long )(d___0->disc_toc[track].dwStartSector - 1));
}
}
#line 82 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/toc.c"
long cdda_disc_lastsector(cdrom_drive *d___0 ) 
{ 
  int i ;
  long tmp ;
  int tmp___0 ;

  {
#line 84
  if (! d___0->opened) {
    {
#line 85
    cderror___4(d___0, "400: Device not open\n");
    }
#line 86
    return (-400L);
  }
#line 90
  i = d___0->tracks - 1;
  {
#line 90
  while (1) {
    while_continue: /* CIL Label */ ;
#line 90
    if (! (i >= 0)) {
#line 90
      goto while_break;
    }
    {
#line 91
    tmp___0 = cdda_track_audiop(d___0, i + 1);
    }
#line 91
    if (tmp___0 == 1) {
      {
#line 92
      tmp = cdda_track_lastsector(d___0, i + 1);
      }
#line 92
      return (tmp);
    }
#line 90
    i --;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 94
  cderror___4(d___0, "403: No audio tracks on disc\n");
  }
#line 95
  return (-403L);
}
}
#line 98 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/toc.c"
long cdda_tracks(cdrom_drive *d___0 ) 
{ 


  {
#line 99
  if (! d___0->opened) {
    {
#line 100
    cderror___4(d___0, "400: Device not open\n");
    }
#line 101
    return (-400L);
  }
#line 103
  return ((long )d___0->tracks);
}
}
#line 106 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/toc.c"
int cdda_sector_gettrack(cdrom_drive *d___0 , long sector ) 
{ 
  int i ;

  {
#line 107
  if (! d___0->opened) {
    {
#line 108
    cderror___4(d___0, "400: Device not open\n");
    }
#line 109
    return (-400);
  } else {
#line 113
    if (sector < (long )d___0->disc_toc[0].dwStartSector) {
#line 114
      return (0);
    }
#line 116
    i = 0;
    {
#line 116
    while (1) {
      while_continue: /* CIL Label */ ;
#line 116
      if (! (i < d___0->tracks)) {
#line 116
        goto while_break;
      }
#line 117
      if ((long )d___0->disc_toc[i].dwStartSector <= sector) {
#line 117
        if ((long )d___0->disc_toc[i + 1].dwStartSector > sector) {
#line 119
          return (i + 1);
        }
      }
#line 116
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 122
    cderror___4(d___0, "401: Invalid track number\n");
    }
#line 123
    return (-401);
  }
}
}
#line 127 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/toc.c"
int cdda_track_bitmap(cdrom_drive *d___0 , int track , int bit , int set , int clear ) 
{ 


  {
#line 128
  if (! d___0->opened) {
    {
#line 129
    cderror___4(d___0, "400: Device not open\n");
    }
#line 130
    return (-400);
  }
#line 133
  if (track == 0) {
#line 134
    track = 1;
  }
#line 136
  if (track < 1) {
    {
#line 137
    cderror___4(d___0, "401: Invalid track number\n");
    }
#line 138
    return (-401);
  } else
#line 136
  if (track > d___0->tracks) {
    {
#line 137
    cderror___4(d___0, "401: Invalid track number\n");
    }
#line 138
    return (-401);
  }
#line 140
  if ((int )d___0->disc_toc[track - 1].bFlags & bit) {
#line 141
    return (set);
  } else {
#line 143
    return (clear);
  }
}
}
#line 147 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/toc.c"
int cdda_track_channels(cdrom_drive *d___0 , int track ) 
{ 
  int tmp ;

  {
  {
#line 148
  tmp = cdda_track_bitmap(d___0, track, 8, 4, 2);
  }
#line 148
  return (tmp);
}
}
#line 151 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/toc.c"
int cdda_track_audiop(cdrom_drive *d___0 , int track ) 
{ 
  int tmp ;

  {
  {
#line 152
  tmp = cdda_track_bitmap(d___0, track, 4, 0, 1);
  }
#line 152
  return (tmp);
}
}
#line 155 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/toc.c"
int cdda_track_copyp(cdrom_drive *d___0 , int track ) 
{ 
  int tmp ;

  {
  {
#line 156
  tmp = cdda_track_bitmap(d___0, track, 2, 1, 0);
  }
#line 156
  return (tmp);
}
}
#line 159 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/toc.c"
int cdda_track_preemp(cdrom_drive *d___0 , int track ) 
{ 
  int tmp ;

  {
  {
#line 160
  tmp = cdda_track_bitmap(d___0, track, 1, 1, 0);
  }
#line 160
  return (tmp);
}
}
#line 846 "/usr/include/stdio.h"
extern void perror(char const   *__s ) ;
#line 15 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/header.c"
static void PutNum(long num , int f , int endianness , int bytes ) 
{ 
  int i ;
  unsigned char c ;
  ssize_t tmp ;
  int tmp___0 ;

  {
#line 19
  if (! endianness) {
#line 20
    i = 0;
  } else {
#line 22
    i = bytes - 1;
  }
  {
#line 23
  while (1) {
    while_continue: /* CIL Label */ ;
#line 23
    tmp___0 = bytes;
#line 23
    bytes --;
#line 23
    if (! tmp___0) {
#line 23
      goto while_break;
    }
    {
#line 24
    c = (unsigned char )((num >> (i << 3)) & 255L);
#line 25
    tmp = write(f, (void const   *)(& c), (size_t )1);
    }
#line 25
    if (tmp == -1L) {
      {
#line 26
      perror("Could not write to output.");
#line 27
      exit(1);
      }
    }
#line 29
    if (endianness) {
#line 30
      i --;
    } else {
#line 32
      i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 34
  return;
}
}
#line 36 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/header.c"
void WriteWav(int f , long bytes ) 
{ 


  {
  {
#line 39
  write(f, (void const   *)"RIFF", (size_t )4);
#line 40
  PutNum((bytes + 44L) - 8L, f, 0, 4);
#line 41
  write(f, (void const   *)"WAVEfmt ", (size_t )8);
#line 42
  PutNum(16L, f, 0, 4);
#line 43
  PutNum(1L, f, 0, 2);
#line 44
  PutNum(2L, f, 0, 2);
#line 45
  PutNum(44100L, f, 0, 4);
#line 46
  PutNum(176400L, f, 0, 4);
#line 47
  PutNum(4L, f, 0, 2);
#line 48
  PutNum(16L, f, 0, 2);
#line 49
  write(f, (void const   *)"data", (size_t )4);
#line 50
  PutNum(bytes, f, 0, 4);
  }
#line 51
  return;
}
}
#line 53 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/header.c"
void WriteAiff(int f , long bytes ) 
{ 
  long size ;
  long frames ;

  {
  {
#line 54
  size = bytes + 54L;
#line 55
  frames = bytes / 4L;
#line 59
  write(f, (void const   *)"FORM", (size_t )4);
#line 60
  PutNum(size - 8L, f, 1, 4);
#line 61
  write(f, (void const   *)"AIFF", (size_t )4);
#line 63
  write(f, (void const   *)"COMM", (size_t )4);
#line 64
  PutNum(18L, f, 1, 4);
#line 65
  PutNum(2L, f, 1, 2);
#line 66
  PutNum(frames, f, 1, 4);
#line 67
  PutNum(16L, f, 1, 2);
#line 68
  write(f, (void const   *)"@\016\254D\000\000\000\000\000\000", (size_t )10);
#line 70
  write(f, (void const   *)"SSND", (size_t )4);
#line 71
  PutNum(bytes + 8L, f, 1, 4);
#line 72
  PutNum(0L, f, 1, 4);
#line 73
  PutNum(0L, f, 1, 4);
  }
#line 75
  return;
}
}
#line 77 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/header.c"
void WriteAifc(int f , long bytes ) 
{ 
  long size ;
  long frames ;

  {
  {
#line 78
  size = bytes + 86L;
#line 79
  frames = bytes / 4L;
#line 83
  write(f, (void const   *)"FORM", (size_t )4);
#line 84
  PutNum(size - 8L, f, 1, 4);
#line 85
  write(f, (void const   *)"AIFC", (size_t )4);
#line 86
  write(f, (void const   *)"FVER", (size_t )4);
#line 87
  PutNum(4L, f, 1, 4);
#line 88
  PutNum(2726318400L, f, 1, 4);
#line 90
  write(f, (void const   *)"COMM", (size_t )4);
#line 91
  PutNum(38L, f, 1, 4);
#line 92
  PutNum(2L, f, 1, 2);
#line 93
  PutNum(frames, f, 1, 4);
#line 94
  PutNum(16L, f, 1, 2);
#line 95
  write(f, (void const   *)"@\016\254D\000\000\000\000\000\000", (size_t )10);
#line 97
  write(f, (void const   *)"NONE", (size_t )4);
#line 98
  PutNum(14L, f, 1, 1);
#line 99
  write(f, (void const   *)"not compressed", (size_t )14);
#line 100
  PutNum(0L, f, 1, 1);
#line 102
  write(f, (void const   *)"SSND", (size_t )4);
#line 103
  PutNum(bytes + 8L, f, 1, 4);
#line 104
  PutNum(0L, f, 1, 4);
#line 105
  PutNum(0L, f, 1, 4);
  }
#line 107
  return;
}
}
#line 4 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/report.c"
int quiet  =    0;
#line 5 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/report.c"
int verbose  =    0;
#line 6 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/report.c"
FILE *reportfile  =    (FILE *)((void *)0);
#line 109 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/utils.h"
static void cderror___5(cdrom_drive *d___0 , char const   *s ) 
{ 
  size_t tmp ;

  {
#line 110
  if (s) {
#line 110
    if (d___0) {
      {
#line 112
      if (d___0->errordest == 1) {
#line 112
        goto case_1;
      }
#line 115
      if (d___0->errordest == 2) {
#line 115
        goto case_2;
      }
#line 119
      goto switch_default;
      case_1: /* CIL Label */ 
      {
#line 113
      tmp = strlen(s);
#line 113
      write(2, (void const   *)s, tmp);
      }
#line 114
      goto switch_break;
      case_2: /* CIL Label */ 
      {
#line 116
      d___0->errorbuf = catstring(d___0->errorbuf, s);
      }
#line 117
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 120
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
  }
#line 123
  return;
}
}
#line 21 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/interface.c"
static void _clean_messages___0(cdrom_drive *d___0 ) 
{ 


  {
#line 22
  if (d___0) {
#line 23
    if (d___0->messagebuf) {
      {
#line 23
      free((void *)d___0->messagebuf);
      }
    }
#line 24
    if (d___0->errorbuf) {
      {
#line 24
      free((void *)d___0->errorbuf);
      }
    }
#line 25
    d___0->messagebuf = (char *)((void *)0);
#line 26
    d___0->errorbuf = (char *)((void *)0);
  }
#line 28
  return;
}
}
/* compiler builtin: 
   void *__builtin_alloca(unsigned long  ) ;  */
#line 765 "/usr/include/stdlib.h"
extern void ( __attribute__((__nonnull__(1,4))) qsort)(void *__base , size_t __nmemb ,
                                                       size_t __size , int (*__compar)(void const   * ,
                                                                                       void const   * ) ) ;
#line 43 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/paranoia/cdda_paranoia.h"
char *paranoia_version(void) ;
#line 45
void paranoia_modeset(cdrom_paranoia *p___0 , int enable ) ;
#line 46
long paranoia_seek(cdrom_paranoia *p___0 , long seek , int mode ) ;
#line 47
int16_t *paranoia_read(cdrom_paranoia *p___0 , void (*callback___0)(long  , int  ) ) ;
#line 48
int16_t *paranoia_read_limited(cdrom_paranoia *p___0 , void (*callback___0)(long  ,
                                                                            int  ) ,
                               int max_retries ) ;
#line 49
void paranoia_free(cdrom_paranoia *p___0 ) ;
#line 50
void paranoia_overlapset(cdrom_paranoia *p___0 , long overlap___0 ) ;
#line 9 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/paranoia/overlap.h"
void offset_add_value(cdrom_paranoia *p___0 , offsets *o , long value , void (*callback___0)(long  ,
                                                                                             int  ) ) ;
#line 14
void i_paranoia_trim(cdrom_paranoia *p___0 , long beginword , long endword ) ;
#line 15
void paranoia_resetall(cdrom_paranoia *p___0 ) ;
#line 16
void paranoia_resetcache(cdrom_paranoia *p___0 ) ;
#line 89 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/paranoia/paranoia.c"
__inline static long re(root_block *root ) 
{ 


  {
#line 90
  if (! root) {
#line 90
    return (-1L);
  }
#line 91
  if (! root->vector) {
#line 91
    return (-1L);
  }
#line 92
  return ((root->vector)->begin + (root->vector)->size);
}
}
#line 95 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/paranoia/paranoia.c"
__inline static long rb(root_block *root ) 
{ 


  {
#line 96
  if (! root) {
#line 96
    return (-1L);
  }
#line 97
  if (! root->vector) {
#line 97
    return (-1L);
  }
#line 98
  return ((root->vector)->begin);
}
}
#line 101 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/paranoia/paranoia.c"
__inline static long rs(root_block *root ) 
{ 


  {
#line 102
  if (! root) {
#line 102
    return (-1L);
  }
#line 103
  if (! root->vector) {
#line 103
    return (-1L);
  }
#line 104
  return ((root->vector)->size);
}
}
#line 107 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/paranoia/paranoia.c"
__inline static int16_t *rv(root_block *root ) 
{ 


  {
#line 108
  if (! root) {
#line 108
    return ((int16_t *)((void *)0));
  }
#line 109
  if (! root->vector) {
#line 109
    return ((int16_t *)((void *)0));
  }
#line 110
  return ((root->vector)->vector);
}
}
#line 126 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/paranoia/paranoia.c"
enum __anonenum_paranoia_read_flags_54 paranoia_read_flags  ;
#line 148 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/paranoia/paranoia.c"
__inline static long i_paranoia_overlap(int16_t *buffA , int16_t *buffB , long offsetA ,
                                        long offsetB , long sizeA , long sizeB , long *ret_begin ,
                                        long *ret_end ) 
{ 
  long beginA ;
  long endA ;
  long beginB ;
  long endB ;

  {
#line 152
  beginA = offsetA;
#line 152
  endA = offsetA;
#line 153
  beginB = offsetB;
#line 153
  endB = offsetB;
  {
#line 156
  while (1) {
    while_continue: /* CIL Label */ ;
#line 156
    if (beginA >= 0L) {
#line 156
      if (! (beginB >= 0L)) {
#line 156
        goto while_break;
      }
    } else {
#line 156
      goto while_break;
    }
#line 157
    if ((int )*(buffA + beginA) != (int )*(buffB + beginB)) {
#line 157
      goto while_break;
    }
#line 156
    beginA --;
#line 156
    beginB --;
  }
  while_break: /* CIL Label */ ;
  }
#line 158
  beginA ++;
#line 159
  beginB ++;
  {
#line 162
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 162
    if (endA < sizeA) {
#line 162
      if (! (endB < sizeB)) {
#line 162
        goto while_break___0;
      }
    } else {
#line 162
      goto while_break___0;
    }
#line 163
    if ((int )*(buffA + endA) != (int )*(buffB + endB)) {
#line 163
      goto while_break___0;
    }
#line 162
    endA ++;
#line 162
    endB ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 166
  if (ret_begin) {
#line 166
    *ret_begin = beginA;
  }
#line 167
  if (ret_end) {
#line 167
    *ret_end = endA;
  }
#line 168
  return (endA - beginA);
}
}
#line 188 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/paranoia/paranoia.c"
__inline static long i_paranoia_overlap2(int16_t *buffA , int16_t *buffB , unsigned char *flagsA ,
                                         unsigned char *flagsB , long offsetA , long offsetB ,
                                         long sizeA , long sizeB , long *ret_begin ,
                                         long *ret_end ) 
{ 
  long beginA ;
  long endA ;
  long beginB ;
  long endB ;

  {
#line 194
  beginA = offsetA;
#line 194
  endA = offsetA;
#line 195
  beginB = offsetB;
#line 195
  endB = offsetB;
  {
#line 198
  while (1) {
    while_continue: /* CIL Label */ ;
#line 198
    if (beginA >= 0L) {
#line 198
      if (! (beginB >= 0L)) {
#line 198
        goto while_break;
      }
    } else {
#line 198
      goto while_break;
    }
#line 199
    if ((int )*(buffA + beginA) != (int )*(buffB + beginB)) {
#line 199
      goto while_break;
    }
#line 208
    if (((int )*(flagsA + beginA) & (int )*(flagsB + beginB)) & 1) {
#line 209
      beginA --;
#line 210
      beginB --;
#line 211
      goto while_break;
    }
#line 215
    if ((int )*(flagsA + beginA) & 2) {
#line 215
      goto while_break;
    } else
#line 215
    if ((int )*(flagsB + beginB) & 2) {
#line 215
      goto while_break;
    }
#line 198
    beginA --;
#line 198
    beginB --;
  }
  while_break: /* CIL Label */ ;
  }
#line 217
  beginA ++;
#line 218
  beginB ++;
  {
#line 221
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 221
    if (endA < sizeA) {
#line 221
      if (! (endB < sizeB)) {
#line 221
        goto while_break___0;
      }
    } else {
#line 221
      goto while_break___0;
    }
#line 222
    if ((int )*(buffA + endA) != (int )*(buffB + endB)) {
#line 222
      goto while_break___0;
    }
#line 227
    if (((int )*(flagsA + endA) & (int )*(flagsB + endB)) & 1) {
#line 227
      if (endA != beginA) {
#line 228
        goto while_break___0;
      }
    }
#line 232
    if ((int )*(flagsA + endA) & 2) {
#line 232
      goto while_break___0;
    } else
#line 232
    if ((int )*(flagsB + endB) & 2) {
#line 232
      goto while_break___0;
    }
#line 221
    endA ++;
#line 221
    endB ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 236
  if (ret_begin) {
#line 236
    *ret_begin = beginA;
  }
#line 237
  if (ret_end) {
#line 237
    *ret_end = endA;
  }
#line 238
  return (endA - beginA);
}
}
#line 258 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/paranoia/paranoia.c"
__inline static long do_const_sync(c_block *A , sort_info *B , unsigned char *flagB ,
                                   long posA , long posB , long *begin , long *end ,
                                   long *offset ) 
{ 
  unsigned char *flagA ;
  long ret ;

  {
#line 263
  flagA = A->flags;
#line 264
  ret = 0L;
#line 271
  if ((unsigned long )flagB == (unsigned long )((void *)0)) {
    {
#line 272
    ret = i_paranoia_overlap(A->vector, B->vector, posA, posB, A->size, B->size, begin,
                             end);
    }
  } else
#line 275
  if (((int )*(flagB + posB) & 2) == 0) {
    {
#line 276
    ret = i_paranoia_overlap2(A->vector, B->vector, flagA, flagB, posA, posB, A->size,
                              B->size, begin, end);
    }
  }
#line 282
  if (ret > 64L) {
#line 283
    *offset = (posA + A->begin) - (posB + *(B->abspos));
#line 289
    *begin += A->begin;
#line 290
    *end += A->begin;
#line 291
    return (ret);
  }
#line 294
  return (0L);
}
}
#line 325 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/paranoia/paranoia.c"
__inline static long try_sort_sync(cdrom_paranoia *p___0 , sort_info *A , unsigned char *Aflags ,
                                   c_block *B , long post , long *begin , long *end ,
                                   long *offset , void (*callback___0)(long  , int  ) ) 
{ 
  long dynoverlap ;
  sort_link *ptr ;
  unsigned char *Bflags ;
  long zeropos ;
  long tmp ;
  long tmp___0 ;

  {
#line 331
  dynoverlap = p___0->dynoverlap;
#line 332
  ptr = (sort_link *)((void *)0);
#line 333
  Bflags = B->flags;
#line 336
  if ((unsigned long )Bflags == (unsigned long )((void *)0)) {
#line 336
    goto _L;
  } else
#line 336
  if (((int )*(Bflags + (post - B->begin)) & 2) == 0) {
    _L: /* CIL Label */ 
#line 339
    zeropos = post - *(A->abspos);
#line 340
    if (zeropos >= 0L) {
#line 340
      if (zeropos < A->size) {
#line 348
        if ((int )*(B->vector + (post - B->begin)) == (int )*(A->vector + zeropos)) {
          {
#line 354
          tmp = do_const_sync(B, A, Aflags, post - B->begin, zeropos, begin, end,
                              offset);
          }
#line 354
          if (tmp) {
            {
#line 358
            offset_add_value(p___0, & p___0->stage1, *offset, callback___0);
            }
#line 360
            return (1L);
          }
        }
      }
    }
  } else {
#line 366
    return (0L);
  }
  {
#line 374
  ptr = sort_getmatch(A, post - *(A->abspos), dynoverlap, (int )*(B->vector + (post - B->begin)));
  }
  {
#line 376
  while (1) {
    while_continue: /* CIL Label */ ;
#line 376
    if (! ptr) {
#line 376
      goto while_break;
    }
    {
#line 382
    tmp___0 = do_const_sync(B, A, Aflags, post - B->begin, ptr - A->revindex, begin,
                            end, offset);
    }
#line 382
    if (tmp___0) {
      {
#line 386
      offset_add_value(p___0, & p___0->stage1, *offset, callback___0);
      }
#line 387
      return (1L);
    }
    {
#line 394
    ptr = sort_nextmatch(A, ptr);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 398
  *begin = -1L;
#line 399
  *end = -1L;
#line 400
  *offset = -1L;
#line 401
  return (0L);
}
}
#line 439 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/paranoia/paranoia.c"
__inline static void stage1_matched(c_block *old , c_block *new , long matchbegin ,
                                    long matchend , long matchoffset , void (*callback___0)(long  ,
                                                                                            int  ) ) 
{ 
  long i ;
  long oldadjbegin ;
  long oldadjend ;
  long newadjbegin ;
  long newadjend ;

  {
#line 443
  oldadjbegin = matchbegin - old->begin;
#line 444
  oldadjend = matchend - old->begin;
#line 445
  newadjbegin = (matchbegin - matchoffset) - new->begin;
#line 446
  newadjend = (matchend - matchoffset) - new->begin;
#line 461
  if (matchbegin - matchoffset <= new->begin) {
#line 461
    goto _L;
  } else
#line 461
  if (matchbegin <= old->begin) {
#line 461
    goto _L;
  } else
#line 461
  if ((int )*(new->flags + newadjbegin) & 1) {
#line 461
    goto _L;
  } else
#line 461
  if ((int )*(old->flags + oldadjbegin) & 1) {
    _L: /* CIL Label */ 
#line 465
    if (matchoffset) {
#line 466
      if (callback___0) {
        {
#line 466
        (*callback___0)(matchbegin, 2);
        }
      }
    }
  } else
#line 468
  if (callback___0) {
    {
#line 468
    (*callback___0)(matchbegin, 3);
    }
  }
#line 470
  if (matchend - matchoffset >= new->begin + new->size) {
#line 470
    goto _L___0;
  } else
#line 470
  if ((int )*(new->flags + newadjend) & 1) {
#line 470
    goto _L___0;
  } else
#line 470
  if (matchend >= old->begin + old->size) {
#line 470
    goto _L___0;
  } else
#line 470
  if ((int )*(old->flags + oldadjend) & 1) {
    _L___0: /* CIL Label */ 
#line 474
    if (matchoffset) {
#line 475
      if (callback___0) {
        {
#line 475
        (*callback___0)(matchend, 2);
        }
      }
    }
  } else
#line 477
  if (callback___0) {
    {
#line 477
    (*callback___0)(matchend, 3);
    }
  }
#line 530
  newadjbegin += 31L;
#line 531
  newadjend -= 31L;
#line 532
  i = newadjbegin;
  {
#line 532
  while (1) {
    while_continue: /* CIL Label */ ;
#line 532
    if (! (i < newadjend)) {
#line 532
      goto while_break;
    }
#line 533
    *(new->flags + i) = (unsigned char )((int )*(new->flags + i) | 4);
#line 532
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 535
  oldadjbegin += 31L;
#line 536
  oldadjend -= 31L;
#line 537
  i = oldadjbegin;
  {
#line 537
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 537
    if (! (i < oldadjend)) {
#line 537
      goto while_break___0;
    }
#line 538
    *(old->flags + i) = (unsigned char )((int )*(old->flags + i) | 4);
#line 537
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 540
  return;
}
}
#line 566 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/paranoia/paranoia.c"
static long i_iterate_stage1(cdrom_paranoia *p___0 , c_block *old , c_block *new ,
                             void (*callback___0)(long  , int  ) ) 
{ 
  long matchbegin ;
  long matchend ;
  long matchoffset ;
  long searchend ;
  long tmp ;
  long searchbegin ;
  long tmp___0 ;
  long searchsize ;
  sort_info *i ;
  long ret ;
  long j ;
  long tried ;
  long matched ;
  long j___0 ;
  long end ;
  long tmp___1 ;

  {
#line 569
  matchbegin = -1L;
#line 569
  matchend = -1L;
#line 584
  if (old->begin + old->size > new->begin + new->size) {
#line 584
    tmp = new->begin + new->size;
  } else {
#line 584
    tmp = old->begin + old->size;
  }
#line 584
  searchend = tmp;
#line 585
  if (old->begin < new->begin) {
#line 585
    tmp___0 = new->begin;
  } else {
#line 585
    tmp___0 = old->begin;
  }
#line 585
  searchbegin = tmp___0;
#line 586
  searchsize = searchend - searchbegin;
#line 587
  i = p___0->sortcache;
#line 588
  ret = 0L;
#line 591
  tried = 0L;
#line 591
  matched = 0L;
#line 593
  if (searchsize <= 0L) {
#line 593
    return (0L);
  }
#line 598
  j = searchbegin;
  {
#line 598
  while (1) {
    while_continue: /* CIL Label */ ;
#line 598
    if (! (j < searchend)) {
#line 598
      goto while_break;
    }
#line 604
    if (((int )*(new->flags + (j - new->begin)) & 6) == 0) {
      {
#line 605
      tried ++;
#line 616
      tmp___1 = try_sort_sync(p___0, i, new->flags, old, j, & matchbegin, & matchend,
                              & matchoffset, callback___0);
      }
#line 616
      if (tmp___1 == 1L) {
#line 619
        matched += matchend - matchbegin;
#line 624
        j___0 = matchbegin - old->begin;
#line 625
        end = matchend - old->begin;
        {
#line 626
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 626
          if (! (j___0 < end)) {
#line 626
            goto while_break___0;
          }
#line 626
          if ((int )*(old->vector + j___0) != 0) {
#line 626
            goto while_break___0;
          }
#line 626
          j___0 ++;
        }
        while_break___0: /* CIL Label */ ;
        }
#line 632
        if (j___0 < end) {
          {
#line 633
          stage1_matched(old, new, matchbegin, matchend, matchoffset, callback___0);
          }
        } else {
          {
#line 635
          stage1_matched(old, new, matchbegin, matchend, matchoffset, (void (*)(long  ,
                                                                                int  ))((void *)0));
          }
        }
#line 638
        ret ++;
#line 641
        if (matchend - 1L > j) {
#line 641
          j = matchend - 1L;
        }
      }
    }
#line 598
    j += 23L;
  }
  while_break: /* CIL Label */ ;
  }
#line 651
  return (ret);
}
}
#line 684 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/paranoia/paranoia.c"
static long i_stage1(cdrom_paranoia *p___0 , c_block *new , void (*callback___0)(long  ,
                                                                                 int  ) ) 
{ 
  long size ;
  c_block *ptr ;
  c_block *tmp ;
  int ret ;
  long begin ;
  long end ;
  int tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;

  {
  {
#line 687
  size = new->size;
#line 688
  tmp = c_last(p___0);
#line 688
  ptr = tmp;
#line 689
  ret = 0;
#line 690
  begin = 0L;
  }
#line 697
  if (ptr) {
    {
#line 697
    sort_setup(p___0->sortcache, new->vector, & new->begin, new->size, new->begin,
               new->begin + new->size);
    }
  }
  {
#line 708
  while (1) {
    while_continue: /* CIL Label */ ;
#line 708
    if (ptr) {
#line 708
      if (! ((unsigned long )ptr != (unsigned long )new)) {
#line 708
        goto while_break;
      }
    } else {
#line 708
      goto while_break;
    }
#line 710
    if (callback___0) {
      {
#line 710
      (*callback___0)(new->begin, 1);
      }
    }
    {
#line 711
    i_iterate_stage1(p___0, ptr, new, callback___0);
#line 713
    ptr = c_prev(ptr);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 721
  begin = 0L;
  {
#line 722
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 722
    if (! (begin < size)) {
#line 722
      goto while_break___0;
    }
    {
#line 723
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 723
      if (! (begin < size)) {
#line 723
        goto while_break___1;
      }
#line 723
      if ((int )*(new->flags + begin) & 4) {
#line 723
        goto while_break___1;
      }
#line 723
      begin ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 724
    end = begin;
    {
#line 724
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 724
      if (! (end < size)) {
#line 724
        goto while_break___2;
      }
#line 724
      if (((int )*(new->flags + end) & 4) == 0) {
#line 724
        goto while_break___2;
      }
#line 724
      end ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 725
    if (begin >= size) {
#line 725
      goto while_break___0;
    }
#line 727
    ret ++;
#line 738
    if (end + 31L >= size) {
#line 738
      if (new->lastsector) {
#line 738
        tmp___0 = 1;
      } else {
#line 738
        tmp___0 = 0;
      }
    } else {
#line 738
      tmp___0 = 0;
    }
#line 738
    if (size > end + 31L) {
#line 738
      tmp___1 = end + 31L;
    } else {
#line 738
      tmp___1 = size;
    }
#line 738
    if (0L < begin - 31L) {
#line 738
      tmp___2 = begin - 31L;
    } else {
#line 738
      tmp___2 = 0L;
    }
    {
#line 738
    new_v_fragment(p___0, new, new->begin + tmp___2, new->begin + tmp___1, tmp___0);
#line 742
    begin = end;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 748
  return ((long )ret);
}
}
#line 795 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/paranoia/paranoia.c"
static long i_iterate_stage2(cdrom_paranoia *p___0 , v_fragment *v , sync_result *r ,
                             void (*callback___0)(long  , int  ) ) 
{ 
  root_block *root ;
  long matchbegin ;
  long matchend ;
  long offset ;
  long fbv ;
  long fev ;
  long tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  long tmp___4 ;
  long tmp___5 ;
  long tmp___6 ;
  long tmp___8 ;
  long tmp___9 ;
  int16_t *tmp___10 ;
  long tmp___16 ;
  long tmp___17 ;
  long tmp___18 ;
  long tmp___20 ;
  long tmp___21 ;
  long tmp___22 ;
  long searchend ;
  long tmp___24 ;
  long tmp___25 ;
  long tmp___26 ;
  long searchbegin ;
  long tmp___28 ;
  long tmp___29 ;
  long tmp___30 ;
  sort_info *i ;
  long j ;
  int16_t *tmp___31 ;
  int16_t *tmp___32 ;
  long tmp___33 ;
  long tmp___34 ;

  {
  {
#line 797
  root = & p___0->root;
#line 798
  matchbegin = -1L;
#line 798
  matchend = -1L;
#line 814
  tmp___2 = re(root);
  }
#line 814
  if ((v->begin + v->size) + p___0->dynoverlap > tmp___2) {
    {
#line 814
    tmp___0 = re(root);
#line 814
    tmp___1 = tmp___0;
    }
  } else {
#line 814
    tmp___1 = (v->begin + v->size) + p___0->dynoverlap;
  }
  {
#line 814
  tmp___6 = rb(root);
  }
#line 814
  if (v->begin - p___0->dynoverlap < tmp___6) {
    {
#line 814
    tmp___4 = rb(root);
#line 814
    tmp___5 = tmp___4;
    }
  } else {
#line 814
    tmp___5 = v->begin - p___0->dynoverlap;
  }
#line 814
  if (tmp___1 - tmp___5 <= 0L) {
#line 815
    return (0L);
  }
#line 817
  if (callback___0) {
    {
#line 817
    (*callback___0)(v->begin, 1);
    }
  }
  {
#line 825
  tmp___9 = rb(root);
  }
#line 825
  if (v->begin < tmp___9 - p___0->dynoverlap) {
    {
#line 825
    tmp___8 = rb(root);
#line 825
    fbv = tmp___8 - p___0->dynoverlap;
    }
  } else {
#line 825
    fbv = v->begin;
  }
  {
#line 830
  while (1) {
    while_continue: /* CIL Label */ ;
#line 830
    if (fbv < v->begin + v->size) {
      {
#line 830
      tmp___10 = v_buffer(v);
      }
#line 830
      if (! ((int )*(tmp___10 + (fbv - v->begin)) == 0)) {
#line 830
        goto while_break;
      }
    } else {
#line 830
      goto while_break;
    }
#line 830
    fbv ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 831
  if (fbv == v->begin + v->size) {
#line 831
    return (0L);
  }
  {
#line 846
  tmp___22 = re(root);
  }
#line 846
  if (fbv + 256L > tmp___22 + p___0->dynoverlap) {
    {
#line 846
    tmp___20 = re(root);
#line 846
    tmp___21 = tmp___20 + p___0->dynoverlap;
    }
  } else {
#line 846
    tmp___21 = fbv + 256L;
  }
#line 846
  if (tmp___21 > v->begin + v->size) {
#line 846
    fev = v->begin + v->size;
  } else {
    {
#line 846
    tmp___18 = re(root);
    }
#line 846
    if (fbv + 256L > tmp___18 + p___0->dynoverlap) {
      {
#line 846
      tmp___16 = re(root);
#line 846
      tmp___17 = tmp___16 + p___0->dynoverlap;
      }
    } else {
#line 846
      tmp___17 = fbv + 256L;
    }
#line 846
    fev = tmp___17;
  }
  {
#line 855
  tmp___26 = re(root);
  }
#line 855
  if (fev + p___0->dynoverlap > tmp___26) {
    {
#line 855
    tmp___24 = re(root);
#line 855
    tmp___25 = tmp___24;
    }
  } else {
#line 855
    tmp___25 = fev + p___0->dynoverlap;
  }
  {
#line 855
  searchend = tmp___25;
#line 856
  tmp___30 = rb(root);
  }
#line 856
  if (fbv - p___0->dynoverlap < tmp___30) {
    {
#line 856
    tmp___28 = rb(root);
#line 856
    tmp___29 = tmp___28;
    }
  } else {
#line 856
    tmp___29 = fbv - p___0->dynoverlap;
  }
  {
#line 856
  searchbegin = tmp___29;
#line 857
  i = p___0->sortcache;
#line 864
  tmp___31 = v_buffer(v);
#line 864
  sort_setup(i, tmp___31, & v->begin, v->size, fbv, fev);
#line 866
  j = searchbegin;
  }
  {
#line 866
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 866
    if (! (j < searchend)) {
#line 866
      goto while_break___0;
    }
    {
#line 879
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 879
      if (j < searchend) {
        {
#line 879
        tmp___32 = rv(root);
#line 879
        tmp___33 = rb(root);
        }
#line 879
        if (! ((int )*(tmp___32 + (j - tmp___33)) == 0)) {
#line 879
          goto while_break___1;
        }
      } else {
#line 879
        goto while_break___1;
      }
#line 879
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 880
    if (j == searchend) {
#line 880
      goto while_break___0;
    }
    {
#line 895
    tmp___34 = try_sort_sync(p___0, i, (unsigned char *)((void *)0), root->vector,
                             j, & matchbegin, & matchend, & offset, callback___0);
    }
#line 895
    if (tmp___34) {
#line 911
      r->begin = matchbegin;
#line 912
      r->end = matchend;
#line 913
      r->offset = - offset;
#line 914
      if (offset) {
#line 914
        if (callback___0) {
          {
#line 914
          (*callback___0)(r->begin, 2);
          }
        }
      }
#line 915
      return (1L);
    }
#line 866
    j += 23L;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 920
  return (0L);
}
}
#line 936 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/paranoia/paranoia.c"
static void i_silence_test(root_block *root ) 
{ 
  int16_t *vec ;
  int16_t *tmp ;
  long end ;
  long tmp___0 ;
  long tmp___1 ;
  long j ;
  long tmp___2 ;

  {
  {
#line 937
  tmp = rv(root);
#line 937
  vec = tmp;
#line 938
  tmp___0 = re(root);
#line 938
  tmp___1 = rb(root);
#line 938
  end = (tmp___0 - tmp___1) - 1L;
#line 944
  j = end - 1L;
  }
  {
#line 944
  while (1) {
    while_continue: /* CIL Label */ ;
#line 944
    if (! (j >= 0L)) {
#line 944
      goto while_break;
    }
#line 944
    if ((int )*(vec + j) != 0) {
#line 944
      goto while_break;
    }
#line 944
    j --;
  }
  while_break: /* CIL Label */ ;
  }
#line 950
  if (j < 0L) {
#line 950
    goto _L;
  } else
#line 950
  if (end - j > 1024L) {
    _L: /* CIL Label */ 
    {
#line 951
    root->silenceflag = 1;
#line 952
    tmp___2 = rb(root);
#line 952
    root->silencebegin = (tmp___2 + j) + 1L;
    }
#line 953
    if (root->silencebegin < root->returnedlimit) {
#line 954
      root->silencebegin = root->returnedlimit;
    }
  }
#line 956
  return;
}
}
#line 984 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/paranoia/paranoia.c"
static long i_silence_match(root_block *root , v_fragment *v , void (*callback___0)(long  ,
                                                                                    int  ) ) 
{ 
  cdrom_paranoia *p___0 ;
  int16_t *vec ;
  int16_t *tmp ;
  long end ;
  long begin ;
  long j ;
  long addto ;
  long tmp___0 ;
  int16_t *vec___0 ;
  unsigned long __lengthofvec___0 ;
  void *tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;
  long tmp___5 ;
  long tmp___6 ;
  long voff ;
  long tmp___7 ;
  long tmp___8 ;
  long voff___0 ;
  long tmp___9 ;
  long tmp___10 ;

  {
  {
#line 987
  p___0 = v->p;
#line 988
  tmp = v_buffer(v);
#line 988
  vec = tmp;
#line 989
  end = v->size;
  }
#line 1001
  if (end < 1024L) {
#line 1001
    return (0L);
  }
#line 1002
  j = 0L;
  {
#line 1002
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1002
    if (! (j < end)) {
#line 1002
      goto while_break;
    }
#line 1002
    if ((int )*(vec + j) != 0) {
#line 1002
      goto while_break;
    }
#line 1002
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1003
  if (j < 1024L) {
#line 1003
    return (0L);
  }
  {
#line 1009
  j += v->begin;
#line 1014
  tmp___2 = re(root);
  }
#line 1014
  if (v->begin >= tmp___2) {
    {
#line 1014
    tmp___3 = re(root);
    }
#line 1014
    if (v->begin - p___0->dynoverlap < tmp___3) {
      {
#line 1021
      tmp___0 = re(root);
#line 1021
      addto = (v->begin + 1024L) - tmp___0;
#line 1022
      __lengthofvec___0 = (unsigned long )addto;
#line 1022
      tmp___1 = __builtin_alloca(sizeof(*vec___0) * __lengthofvec___0);
#line 1022
      vec___0 = (int16_t *)tmp___1;
#line 1023
      memset((void *)vec___0, 0, sizeof(*vec___0) * __lengthofvec___0);
#line 1024
      c_append(root->vector, vec___0, addto);
      }
    }
  }
#line 1030
  if (v->begin < root->silencebegin) {
#line 1030
    begin = root->silencebegin;
  } else {
#line 1030
    begin = v->begin;
  }
  {
#line 1031
  tmp___6 = re(root);
  }
#line 1031
  if (j > tmp___6) {
    {
#line 1031
    tmp___5 = re(root);
#line 1031
    end = tmp___5;
    }
  } else {
#line 1031
    end = j;
  }
#line 1036
  if (begin < end) {
    {
#line 1042
    tmp___8 = re(root);
    }
#line 1042
    if (v->begin + v->size > tmp___8) {
      {
#line 1043
      voff = begin - v->begin;
#line 1047
      tmp___7 = rb(root);
#line 1047
      c_remove(root->vector, begin - tmp___7, -1L);
#line 1051
      c_append(root->vector, vec + voff, v->size - voff);
      }
    }
    {
#line 1056
    offset_add_value(p___0, & p___0->stage2, 0L, callback___0);
    }
  } else
#line 1066
  if (j < begin) {
    {
#line 1089
    voff___0 = j - v->begin;
#line 1097
    tmp___10 = re(root);
    }
#line 1097
    if ((begin + v->size) - voff___0 > tmp___10) {
      {
#line 1101
      tmp___9 = rb(root);
#line 1101
      c_remove(root->vector, root->silencebegin - tmp___9, -1L);
#line 1105
      c_append(root->vector, vec + voff___0, v->size - voff___0);
      }
    }
    {
#line 1111
    offset_add_value(p___0, & p___0->stage2, end - begin, callback___0);
    }
  } else {
#line 1122
    return (0L);
  }
  {
#line 1133
  root->silenceflag = 0;
#line 1137
  i_silence_test(root);
  }
#line 1143
  if (v->lastsector) {
#line 1143
    root->lastsector = 1L;
  }
  {
#line 1144
  free_v_fragment(v);
  }
#line 1145
  return (1L);
}
}
#line 1171 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/paranoia/paranoia.c"
static long i_stage2_each(root_block *root , v_fragment *v , void (*callback___0)(long  ,
                                                                                  int  ) ) 
{ 
  cdrom_paranoia *p___0 ;
  long dynoverlap ;
  sync_result r ;
  long begin ;
  long tmp ;
  long end ;
  long tmp___0 ;
  long offset ;
  long temp ;
  c_block *l ;
  long matchA ;
  long matchB ;
  long matchC ;
  long beginL ;
  int16_t *buff ;
  void *tmp___1 ;
  int16_t *tmp___2 ;
  long tmp___3 ;
  int16_t *tmp___4 ;
  long tmp___5 ;
  long tmp___6 ;
  long tmp___7 ;
  long tmp___8 ;
  long tmp___9 ;
  int16_t *tmp___10 ;
  long tmp___11 ;
  long tmp___12 ;
  long tmp___13 ;
  int16_t *tmp___14 ;
  long matchA___0 ;
  long matchB___0 ;
  long matchC___0 ;
  long beginL___0 ;
  long endL ;
  int16_t *buff___0 ;
  void *tmp___15 ;
  int16_t *tmp___16 ;
  long tmp___17 ;
  int16_t *tmp___18 ;
  long tmp___19 ;
  long tmp___20 ;
  long tmp___21 ;
  long tmp___22 ;
  long tmp___23 ;
  int16_t *tmp___24 ;
  long tmp___25 ;
  long tmp___26 ;
  long tmp___27 ;
  int16_t *tmp___28 ;
  long tmp___29 ;
  long tmp___30 ;
  int16_t *tmp___31 ;
  long tmp___32 ;
  long sizeA ;
  long tmp___33 ;
  long sizeB ;
  long vecbegin ;
  int16_t *vector ;
  long tmp___34 ;
  long tmp___35 ;
  long tmp___36 ;
  int16_t *tmp___37 ;

  {
#line 1174
  p___0 = v->p;
#line 1175
  dynoverlap = (p___0->dynoverlap / 2L) * 2L;
#line 1180
  if (! v) {
#line 1180
    return (0L);
  } else
#line 1180
  if (! v->one) {
#line 1180
    return (0L);
  }
  {
#line 1183
  tmp___37 = rv(root);
  }
#line 1183
  if (tmp___37) {
    {
#line 1192
    tmp___36 = i_iterate_stage2(p___0, v, & r, callback___0);
    }
#line 1192
    if (tmp___36) {
      {
#line 1195
      tmp = rb(root);
#line 1195
      begin = r.begin - tmp;
#line 1196
      tmp___0 = rb(root);
#line 1196
      end = r.end - tmp___0;
#line 1206
      offset = ((r.begin + r.offset) - v->begin) - begin;
#line 1208
      l = (c_block *)((void *)0);
      }
      {
#line 1260
      while (1) {
        while_continue: /* CIL Label */ ;
#line 1260
        if (begin + offset > 0L) {
#line 1260
          if (! (begin > 0L)) {
#line 1260
            goto while_break;
          }
        } else {
#line 1260
          goto while_break;
        }
#line 1261
        matchA = 0L;
#line 1261
        matchB = 0L;
#line 1261
        matchC = 0L;
#line 1267
        beginL = begin + offset;
#line 1274
        if ((unsigned long )l == (unsigned long )((void *)0)) {
          {
#line 1275
          tmp___1 = malloc((unsigned long )v->size * sizeof(int16_t ));
#line 1275
          buff = (int16_t *)tmp___1;
#line 1276
          l = c_alloc(buff, v->begin, v->size);
#line 1277
          tmp___2 = v_buffer(v);
#line 1277
          memcpy((void */* __restrict  */)buff, (void const   */* __restrict  */)tmp___2,
                 (unsigned long )v->size * sizeof(int16_t ));
          }
        }
        {
#line 1291
        tmp___3 = rs(root);
#line 1291
        tmp___4 = rv(root);
#line 1291
        i_analyze_rift_r(tmp___4, l->vector, tmp___3, l->size, begin - 1L, beginL - 1L,
                         & matchA, & matchB, & matchC);
        }
#line 1305
        if (matchA) {
#line 1308
          if (matchA > 0L) {
#line 1312
            if (callback___0) {
              {
#line 1312
              tmp___5 = rb(root);
#line 1312
              (*callback___0)((begin + tmp___5) - 1L, 10);
              }
            }
            {
#line 1313
            tmp___6 = rb(root);
            }
#line 1313
            if (tmp___6 + begin < p___0->root.returnedlimit) {
#line 1314
              goto while_break;
            } else {
              {
#line 1322
              c_insert(root->vector, begin, (l->vector + beginL) - matchA, matchA);
#line 1330
              offset -= matchA;
#line 1331
              begin += matchA;
#line 1332
              end += matchA;
              }
            }
          } else {
#line 1339
            if (callback___0) {
              {
#line 1339
              tmp___7 = rb(root);
#line 1339
              (*callback___0)((begin + tmp___7) - 1L, 11);
              }
            }
            {
#line 1340
            tmp___8 = rb(root);
            }
#line 1340
            if ((tmp___8 + begin) + matchA < p___0->root.returnedlimit) {
#line 1341
              goto while_break;
            } else {
              {
#line 1347
              c_remove(root->vector, begin + matchA, - matchA);
#line 1354
              offset -= matchA;
#line 1355
              begin += matchA;
#line 1356
              end += matchA;
              }
            }
          }
        } else
#line 1359
        if (matchB) {
#line 1362
          if (matchB > 0L) {
#line 1366
            if (callback___0) {
              {
#line 1366
              tmp___9 = rb(root);
#line 1366
              (*callback___0)((begin + tmp___9) - 1L, 10);
              }
            }
            {
#line 1373
            tmp___10 = rv(root);
#line 1373
            c_insert(l, beginL, (tmp___10 + begin) - matchB, matchB);
#line 1380
            offset += matchB;
            }
          } else {
#line 1386
            if (callback___0) {
              {
#line 1386
              tmp___11 = rb(root);
#line 1386
              (*callback___0)((begin + tmp___11) - 1L, 11);
              }
            }
            {
#line 1391
            c_remove(l, beginL + matchB, - matchB);
#line 1397
            offset += matchB;
            }
          }
        } else
#line 1400
        if (matchC) {
          {
#line 1415
          tmp___12 = rb(root);
          }
#line 1415
          if ((tmp___12 + begin) - matchC < p___0->root.returnedlimit) {
#line 1416
            goto while_break;
          }
          {
#line 1426
          c_overwrite(root->vector, begin - matchC, (l->vector + beginL) - matchC,
                      matchC);
          }
        } else {
#line 1453
          goto while_break;
        }
        {
#line 1463
        beginL = begin + offset;
#line 1470
        tmp___13 = rs(root);
#line 1470
        tmp___14 = rv(root);
#line 1470
        i_paranoia_overlap(tmp___14, l->vector, begin, beginL, tmp___13, l->size,
                           & begin, & end);
        }
      }
      while_break: /* CIL Label */ ;
      }
#line 1496
      if (l) {
#line 1496
        temp = l->size;
      } else {
#line 1496
        temp = v->size;
      }
      {
#line 1497
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1497
        if (end + offset < temp) {
          {
#line 1497
          tmp___32 = rs(root);
          }
#line 1497
          if (! (end < tmp___32)) {
#line 1497
            goto while_break___0;
          }
        } else {
#line 1497
          goto while_break___0;
        }
#line 1498
        matchA___0 = 0L;
#line 1498
        matchB___0 = 0L;
#line 1498
        matchC___0 = 0L;
#line 1505
        beginL___0 = begin + offset;
#line 1511
        endL = end + offset;
#line 1520
        if ((unsigned long )l == (unsigned long )((void *)0)) {
          {
#line 1521
          tmp___15 = malloc((unsigned long )v->size * sizeof(int16_t ));
#line 1521
          buff___0 = (int16_t *)tmp___15;
#line 1522
          l = c_alloc(buff___0, v->begin, v->size);
#line 1523
          tmp___16 = v_buffer(v);
#line 1523
          memcpy((void */* __restrict  */)buff___0, (void const   */* __restrict  */)tmp___16,
                 (unsigned long )v->size * sizeof(int16_t ));
          }
        }
        {
#line 1537
        tmp___17 = rs(root);
#line 1537
        tmp___18 = rv(root);
#line 1537
        i_analyze_rift_f(tmp___18, l->vector, tmp___17, l->size, end, endL, & matchA___0,
                         & matchB___0, & matchC___0);
        }
#line 1547
        if (matchA___0) {
#line 1550
          if (matchA___0 > 0L) {
#line 1554
            if (callback___0) {
              {
#line 1554
              tmp___19 = rb(root);
#line 1554
              (*callback___0)(end + tmp___19, 10);
              }
            }
            {
#line 1555
            tmp___20 = rb(root);
            }
#line 1555
            if (end + tmp___20 < p___0->root.returnedlimit) {
#line 1556
              goto while_break___0;
            }
            {
#line 1563
            c_insert(root->vector, end, l->vector + endL, matchA___0);
            }
          } else {
#line 1573
            if (callback___0) {
              {
#line 1573
              tmp___21 = rb(root);
#line 1573
              (*callback___0)(end + tmp___21, 11);
              }
            }
            {
#line 1574
            tmp___22 = rb(root);
            }
#line 1574
            if (end + tmp___22 < p___0->root.returnedlimit) {
#line 1575
              goto while_break___0;
            }
            {
#line 1580
            c_remove(root->vector, end, - matchA___0);
            }
          }
        } else
#line 1587
        if (matchB___0) {
#line 1590
          if (matchB___0 > 0L) {
#line 1594
            if (callback___0) {
              {
#line 1594
              tmp___23 = rb(root);
#line 1594
              (*callback___0)(end + tmp___23, 10);
              }
            }
            {
#line 1601
            tmp___24 = rv(root);
#line 1601
            c_insert(l, endL, tmp___24 + end, matchB___0);
            }
          } else {
#line 1611
            if (callback___0) {
              {
#line 1611
              tmp___25 = rb(root);
#line 1611
              (*callback___0)(end + tmp___25, 11);
              }
            }
            {
#line 1616
            c_remove(l, endL, - matchB___0);
            }
          }
        } else
#line 1622
        if (matchC___0) {
          {
#line 1634
          tmp___26 = rb(root);
          }
#line 1634
          if (end + tmp___26 < p___0->root.returnedlimit) {
#line 1635
            goto while_break___0;
          }
          {
#line 1640
          c_overwrite(root->vector, end, l->vector + endL, matchC___0);
          }
        } else {
          {
#line 1650
          tmp___27 = rs(root);
#line 1650
          tmp___28 = rv(root);
#line 1650
          analyze_rift_silence_f(tmp___28, l->vector, tmp___27, l->size, end, endL,
                                 & matchA___0, & matchB___0);
          }
#line 1654
          if (matchA___0) {
            {
#line 1666
            tmp___29 = rb(root);
            }
#line 1666
            if (end + tmp___29 >= p___0->root.returnedlimit) {
              {
#line 1667
              c_remove(root->vector, end, -1L);
              }
            }
          } else
#line 1670
          if (matchB___0) {
#line 1684
            if (l) {
              {
#line 1684
              i_cblock_destructor(l);
              }
            }
            {
#line 1685
            free_v_fragment(v);
            }
#line 1686
            return (1L);
          }
#line 1696
          goto while_break___0;
        }
        {
#line 1704
        tmp___30 = rs(root);
#line 1704
        tmp___31 = rv(root);
#line 1704
        i_paranoia_overlap(tmp___31, l->vector, begin, beginL___0, tmp___30, l->size,
                           (long *)((void *)0), & end);
#line 1709
        temp = l->size;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 1737
      tmp___33 = rs(root);
#line 1737
      sizeA = tmp___33;
      }
#line 1745
      if (l) {
#line 1746
        sizeB = l->size;
#line 1747
        vector = l->vector;
#line 1748
        vecbegin = l->begin;
      } else {
        {
#line 1750
        sizeB = v->size;
#line 1751
        vector = v_buffer(v);
#line 1752
        vecbegin = v->begin;
        }
      }
#line 1765
      if (sizeB - offset > sizeA) {
#line 1765
        goto _L;
      } else
#line 1765
      if (v->lastsector) {
        _L: /* CIL Label */ 
#line 1766
        if (v->lastsector) {
#line 1767
          root->lastsector = 1L;
        }
#line 1776
        if (end < sizeA) {
          {
#line 1776
          c_remove(root->vector, end, -1L);
          }
        }
#line 1781
        if ((sizeB - offset) - end) {
          {
#line 1781
          c_append(root->vector, (vector + end) + offset, (sizeB - offset) - end);
          }
        }
        {
#line 1787
        i_silence_test(root);
#line 1802
        tmp___34 = rb(root);
#line 1802
        offset_add_value(p___0, & p___0->stage2, (offset + vecbegin) - tmp___34, callback___0);
        }
      }
#line 1805
      if (l) {
        {
#line 1805
        i_cblock_destructor(l);
        }
      }
      {
#line 1806
      free_v_fragment(v);
      }
#line 1807
      return (1L);
    } else {
      {
#line 1827
      tmp___35 = re(root);
      }
#line 1827
      if ((v->begin + v->size) + dynoverlap < tmp___35) {
#line 1827
        if (! root->silenceflag) {
          {
#line 1829
          free_v_fragment(v);
          }
        }
      }
#line 1834
      return (0L);
    }
  } else {
#line 1184
    return (0L);
  }
}
}
#line 1840 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/paranoia/paranoia.c"
static int i_init_root(root_block *root , v_fragment *v , long begin , void (*callback___0)(long  ,
                                                                                            int  ) ) 
{ 
  int16_t *tmp ;
  int16_t *buff ;
  void *tmp___0 ;
  int16_t *tmp___1 ;

  {
#line 1842
  if (v->begin <= begin) {
#line 1842
    if (v->begin + v->size > begin) {
      {
#line 1844
      root->lastsector = v->lastsector;
#line 1845
      root->returnedlimit = begin;
#line 1847
      tmp = rv(root);
      }
#line 1847
      if (tmp) {
        {
#line 1848
        i_cblock_destructor(root->vector);
#line 1849
        root->vector = (c_block *)((void *)0);
        }
      }
      {
#line 1853
      tmp___0 = malloc((unsigned long )v->size * sizeof(int16_t ));
#line 1853
      buff = (int16_t *)tmp___0;
#line 1854
      tmp___1 = v_buffer(v);
#line 1854
      memcpy((void */* __restrict  */)buff, (void const   */* __restrict  */)tmp___1,
             (unsigned long )v->size * sizeof(int16_t ));
#line 1855
      root->vector = c_alloc(buff, v->begin, v->size);
#line 1860
      i_silence_test(root);
      }
#line 1862
      return (1);
    } else {
#line 1864
      return (0);
    }
  } else {
#line 1864
    return (0);
  }
}
}
#line 1867 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/paranoia/paranoia.c"
static int vsort(void const   *a , void const   *b ) 
{ 


  {
#line 1868
  return ((int )((*((v_fragment **)a))->begin - (*((v_fragment **)b))->begin));
}
}
#line 1897 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/paranoia/paranoia.c"
static int i_stage2(cdrom_paranoia *p___0 , long beginword , long endword , void (*callback___0)(long  ,
                                                                                                 int  ) ) 
{ 
  int flag ;
  int ret ;
  root_block *root ;
  v_fragment *first ;
  v_fragment *tmp ;
  long active ;
  long count ;
  v_fragment **list ;
  unsigned long __lengthoflist ;
  void *tmp___0 ;
  v_fragment *next ;
  v_fragment *tmp___1 ;
  long tmp___2 ;
  int tmp___3 ;
  long tmp___4 ;
  int16_t *tmp___5 ;
  long tmp___6 ;
  int16_t *tmp___7 ;

  {
#line 1900
  flag = 1;
#line 1900
  ret = 0;
#line 1901
  root = & p___0->root;
  {
#line 1917
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1917
    if (! flag) {
#line 1917
      goto while_break;
    }
    {
#line 1922
    tmp = v_first(p___0);
#line 1922
    first = tmp;
#line 1923
    active = (p___0->fragments)->active;
#line 1923
    count = 0L;
#line 1924
    __lengthoflist = (unsigned long )active;
#line 1924
    tmp___0 = __builtin_alloca(sizeof(*list) * __lengthoflist);
#line 1924
    list = (v_fragment **)tmp___0;
    }
    {
#line 1926
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1926
      if (! first) {
#line 1926
        goto while_break___0;
      }
      {
#line 1927
      tmp___1 = v_next(first);
#line 1927
      next = tmp___1;
#line 1928
      tmp___2 = count;
#line 1928
      count ++;
#line 1928
      *(list + tmp___2) = first;
#line 1929
      first = next;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1936
    flag = 0;
#line 1937
    if (count) {
      {
#line 1942
      qsort((void *)list, (size_t )active, sizeof(v_fragment *), & vsort);
#line 1953
      count = 0L;
      }
      {
#line 1953
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1953
        if (! (count < active)) {
#line 1953
          goto while_break___1;
        }
#line 1954
        first = *(list + count);
#line 1958
        if (first->one) {
          {
#line 1984
          tmp___5 = rv(root);
          }
#line 1984
          if ((unsigned long )tmp___5 == (unsigned long )((void *)0)) {
            {
#line 1985
            tmp___3 = i_init_root(& p___0->root, first, beginword, callback___0);
            }
#line 1985
            if (tmp___3) {
              {
#line 1986
              free_v_fragment(first);
#line 1991
              flag = 1;
#line 1992
              ret ++;
              }
            }
          } else {
            {
#line 1999
            tmp___4 = i_stage2_each(root, first, callback___0);
            }
#line 1999
            if (tmp___4) {
#line 2004
              ret ++;
#line 2005
              flag = 1;
            }
          }
        }
#line 1953
        count ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 2015
      if (! flag) {
#line 2015
        if (p___0->root.silenceflag) {
#line 2016
          count = 0L;
          {
#line 2016
          while (1) {
            while_continue___2: /* CIL Label */ ;
#line 2016
            if (! (count < active)) {
#line 2016
              goto while_break___2;
            }
#line 2017
            first = *(list + count);
#line 2021
            if (first->one) {
              {
#line 2022
              tmp___7 = rv(root);
              }
#line 2022
              if ((unsigned long )tmp___7 != (unsigned long )((void *)0)) {
                {
#line 2031
                tmp___6 = i_silence_match(root, first, callback___0);
                }
#line 2031
                if (tmp___6) {
#line 2036
                  ret ++;
#line 2037
                  flag = 1;
                }
              }
            }
#line 2016
            count ++;
          }
          while_break___2: /* CIL Label */ ;
          }
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2055
  return (ret);
}
}
#line 2058 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/paranoia/paranoia.c"
static void i_end_case(cdrom_paranoia *p___0 , long endword , void (*callback___0)(long  ,
                                                                                   int  ) ) 
{ 
  root_block *root ;
  long tmp ;
  long addto ;
  long tmp___0 ;
  char *temp ;
  void *tmp___1 ;

  {
#line 2061
  root = & p___0->root;
#line 2068
  if (root->lastsector == 0L) {
#line 2068
    return;
  }
  {
#line 2069
  tmp = re(root);
  }
#line 2069
  if (endword < tmp) {
#line 2069
    return;
  }
  {
#line 2072
  tmp___0 = re(root);
#line 2072
  addto = endword - tmp___0;
#line 2073
  tmp___1 = calloc((size_t )addto, sizeof(char ) * 2UL);
#line 2073
  temp = (char *)tmp___1;
#line 2075
  c_append(root->vector, (int16_t *)((void *)temp), addto);
#line 2076
  free((void *)temp);
#line 2079
  paranoia_resetcache(p___0);
  }
#line 2082
  return;
}
}
#line 2092 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/paranoia/paranoia.c"
static void verify_skip_case(cdrom_paranoia *p___0 , void (*callback___0)(long  ,
                                                                          int  ) ) 
{ 
  root_block *root ;
  c_block *graft ;
  int vflag ;
  int gend ;
  long post ;
  int16_t *tmp ;
  c_block *c ;
  c_block *tmp___0 ;
  long cbegin ;
  long cend ;
  long vend ;
  long cbegin___0 ;
  long cend___0 ;
  int16_t *buff ;
  void *tmp___1 ;
  int16_t *tmp___2 ;
  void *temp ;
  void *tmp___3 ;
  int16_t *tmp___4 ;

  {
  {
#line 2094
  root = & p___0->root;
#line 2095
  graft = (c_block *)((void *)0);
#line 2096
  vflag = 0;
#line 2097
  gend = 0;
#line 2104
  tmp = rv(root);
  }
#line 2104
  if ((unsigned long )tmp == (unsigned long )((void *)0)) {
#line 2105
    post = 0L;
  } else {
    {
#line 2107
    post = re(root);
    }
  }
#line 2109
  if (post == -1L) {
#line 2109
    post = 0L;
  }
#line 2111
  if (callback___0) {
    {
#line 2111
    (*callback___0)(post, 6);
    }
  }
  {
#line 2117
  tmp___0 = c_first(p___0);
#line 2117
  c = tmp___0;
  }
  {
#line 2118
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2118
    if (! c) {
#line 2118
      goto while_break;
    }
#line 2119
    cbegin = c->begin;
#line 2120
    cend = c->begin + c->size;
#line 2121
    if (cbegin <= post) {
#line 2121
      if (cend > post) {
#line 2122
        vend = post;
#line 2124
        if ((int )*(c->flags + (post - cbegin)) & 4) {
          {
#line 2126
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 2126
            if (vend < cend) {
#line 2126
              if (! ((int )*(c->flags + (vend - cbegin)) & 4)) {
#line 2126
                goto while_break___0;
              }
            } else {
#line 2126
              goto while_break___0;
            }
#line 2126
            vend ++;
          }
          while_break___0: /* CIL Label */ ;
          }
#line 2127
          if (! vflag) {
#line 2128
            graft = c;
#line 2129
            gend = (int )vend;
          } else
#line 2127
          if (vend > (long )vflag) {
#line 2128
            graft = c;
#line 2129
            gend = (int )vend;
          }
#line 2131
          vflag = 1;
        } else
#line 2134
        if (! vflag) {
          {
#line 2135
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 2135
            if (vend < cend) {
#line 2135
              if (! (((int )*(c->flags + (vend - cbegin)) & 4) == 0)) {
#line 2135
                goto while_break___1;
              }
            } else {
#line 2135
              goto while_break___1;
            }
#line 2135
            vend ++;
          }
          while_break___1: /* CIL Label */ ;
          }
#line 2136
          if ((unsigned long )graft == (unsigned long )((void *)0)) {
#line 2138
            graft = c;
#line 2139
            gend = (int )vend;
          } else
#line 2136
          if ((long )gend > vend) {
#line 2138
            graft = c;
#line 2139
            gend = (int )vend;
          }
        }
      }
    }
    {
#line 2144
    c = c_next(c);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2147
  if (graft) {
#line 2148
    cbegin___0 = graft->begin;
#line 2149
    cend___0 = graft->begin + graft->size;
    {
#line 2151
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 2151
      if ((long )gend < cend___0) {
#line 2151
        if (! ((int )*(graft->flags + ((long )gend - cbegin___0)) & 4)) {
#line 2151
          goto while_break___2;
        }
      } else {
#line 2151
        goto while_break___2;
      }
#line 2151
      gend ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 2152
    if ((long )(gend + 31) > cend___0) {
#line 2152
      gend = (int )cend___0;
    } else {
#line 2152
      gend += 31;
    }
    {
#line 2154
    tmp___2 = rv(root);
    }
#line 2154
    if ((unsigned long )tmp___2 == (unsigned long )((void *)0)) {
      {
#line 2155
      tmp___1 = malloc((size_t )graft->size);
#line 2155
      buff = (int16_t *)tmp___1;
#line 2156
      memcpy((void */* __restrict  */)buff, (void const   */* __restrict  */)graft->vector,
             (size_t )graft->size);
#line 2157
      root->vector = c_alloc(buff, graft->begin, graft->size);
      }
    } else {
      {
#line 2159
      c_append(root->vector, (graft->vector + post) - cbegin___0, (long )gend - post);
      }
    }
    {
#line 2163
    root->returnedlimit = re(root);
    }
#line 2164
    return;
  }
  {
#line 2170
  tmp___3 = calloc((size_t )2352, sizeof(int16_t ));
#line 2170
  temp = tmp___3;
#line 2172
  tmp___4 = rv(root);
  }
#line 2172
  if ((unsigned long )tmp___4 == (unsigned long )((void *)0)) {
    {
#line 2173
    root->vector = c_alloc((int16_t *)temp, post, 2352L);
    }
  } else {
    {
#line 2175
    c_append(root->vector, (int16_t *)temp, 2352L);
#line 2176
    free(temp);
    }
  }
  {
#line 2179
  root->returnedlimit = re(root);
  }
#line 2181
  return;
}
}
#line 2185 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/paranoia/paranoia.c"
void paranoia_free(cdrom_paranoia *p___0 ) 
{ 


  {
  {
#line 2186
  paranoia_resetall(p___0);
#line 2187
  sort_free(p___0->sortcache);
#line 2188
  free_list(p___0->cache, 1);
#line 2189
  free_list(p___0->fragments, 1);
#line 2190
  free((void *)p___0);
  }
#line 2191
  return;
}
}
#line 2193 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/paranoia/paranoia.c"
void paranoia_modeset(cdrom_paranoia *p___0 , int enable ) 
{ 


  {
#line 2194
  p___0->enable = enable;
#line 2195
  return;
}
}
#line 2197 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/paranoia/paranoia.c"
long paranoia_seek(cdrom_paranoia *p___0 , long seek , int mode ) 
{ 
  long sector ;
  long ret ;
  long tmp ;
  int tmp___0 ;

  {
  {
#line 2201
  if (mode == 0) {
#line 2201
    goto case_0;
  }
#line 2204
  if (mode == 2) {
#line 2204
    goto case_2;
  }
#line 2207
  goto switch_default;
  case_0: /* CIL Label */ 
#line 2202
  sector = seek;
#line 2203
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 2205
  tmp = cdda_disc_lastsector(p___0->d);
#line 2205
  sector = tmp + seek;
  }
#line 2206
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 2208
  sector = p___0->cursor + seek;
#line 2209
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 2212
  tmp___0 = cdda_sector_gettrack(p___0->d, sector);
  }
#line 2212
  if (tmp___0 == -1) {
#line 2212
    return (-1L);
  }
  {
#line 2214
  i_cblock_destructor(p___0->root.vector);
#line 2215
  p___0->root.vector = (c_block *)((void *)0);
#line 2216
  p___0->root.lastsector = 0L;
#line 2217
  p___0->root.returnedlimit = 0L;
#line 2219
  ret = p___0->cursor;
#line 2220
  p___0->cursor = sector;
#line 2222
  i_paranoia_firstlast(p___0);
#line 2225
  p___0->current_firstsector = sector;
  }
#line 2227
  return (ret);
}
}
#line 2230 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/paranoia/paranoia.c"
static void cdrom_cache_update(cdrom_paranoia *p___0 , int lba , int sectors ) 
{ 
  int end ;

  {
#line 2232
  if (lba + sectors > p___0->cdcache_size) {
#line 2233
    end = lba + sectors;
#line 2234
    lba = end - p___0->cdcache_size;
#line 2235
    sectors = end - lba;
  }
#line 2238
  if (lba < p___0->cdcache_begin) {
#line 2240
    p___0->cdcache_begin = lba;
#line 2241
    p___0->cdcache_end = lba + sectors;
  } else {
#line 2243
    if (lba + sectors > p___0->cdcache_end) {
#line 2244
      p___0->cdcache_end = lba + sectors;
    }
#line 2245
    if ((lba + sectors) - p___0->cdcache_size > p___0->cdcache_begin) {
#line 2246
      if ((lba + sectors) - p___0->cdcache_size < p___0->cdcache_end) {
#line 2247
        p___0->cdcache_begin = (lba + sectors) - p___0->cdcache_size;
      } else {
#line 2249
        p___0->cdcache_begin = lba;
      }
    }
  }
#line 2253
  return;
}
}
#line 2255 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/paranoia/paranoia.c"
static void cdrom_cache_handler(cdrom_paranoia *p___0 , int lba , void (*callback___0)(long  ,
                                                                                       int  ) ) 
{ 
  int seekpos ;
  int ms ;
  long tmp___0 ;
  int pre ;
  int post ;
  long tmp___2 ;
  long tmp___3 ;

  {
#line 2258
  if (lba >= p___0->cdcache_end) {
#line 2258
    return;
  }
#line 2260
  if (lba < 0) {
#line 2260
    lba = 0;
  }
#line 2262
  if (lba < p___0->cdcache_begin) {
#line 2264
    if (lba == 0) {
#line 2264
      seekpos = lba;
    } else {
      {
#line 2264
      tmp___0 = cdda_disc_firstsector(p___0->d);
      }
#line 2264
      if ((long )(lba - 1) < tmp___0) {
#line 2264
        seekpos = lba;
      } else {
#line 2264
        seekpos = lba - 1;
      }
    }
  } else {
    {
#line 2266
    pre = p___0->cdcache_begin - 1;
#line 2267
    post = lba + p___0->cdcache_size;
#line 2269
    tmp___2 = cdda_disc_firstsector(p___0->d);
    }
#line 2269
    if ((long )pre < tmp___2) {
#line 2269
      seekpos = post;
    } else {
#line 2269
      seekpos = pre;
    }
  }
  {
#line 2272
  tmp___3 = cdda_read_timed(p___0->d, (void *)0, (long )seekpos, 1L, & ms);
  }
#line 2272
  if (tmp___3 == 1L) {
#line 2273
    if (seekpos < p___0->cdcache_begin) {
#line 2273
      if (ms < 6) {
        {
#line 2274
        (*callback___0)((long )(seekpos * 1176), 13);
        }
      }
    }
  }
  {
#line 2275
  cdrom_cache_update(p___0, seekpos, 1);
  }
#line 2276
  return;
}
}
#line 2312 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/paranoia/paranoia.c"
c_block *i_read_c_block(cdrom_paranoia *p___0 , long beginword , long endword , void (*callback___0)(long  ,
                                                                                                     int  ) ) 
{ 
  long readat ;
  long firstread ;
  long totaltoread ;
  long sectatonce ;
  long driftcomp ;
  c_block *new ;
  root_block *root ;
  int16_t *buffer ;
  unsigned char *flags ;
  long sofar ;
  long dynoverlap ;
  long anyflag ;
  long target ;
  long tmp ;
  int16_t *tmp___0 ;
  long tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  long secread ;
  long adjread ;
  long thisread ;
  int *tmp___4 ;
  int i ;

  {
#line 2322
  totaltoread = (long )p___0->cdcache_size;
#line 2323
  sectatonce = (long )(p___0->d)->nsectors;
#line 2324
  driftcomp = (long )((double )((float )p___0->dyndrift / (float )1176) + .5);
#line 2325
  new = (c_block *)((void *)0);
#line 2326
  root = & p___0->root;
#line 2327
  buffer = (int16_t *)((void *)0);
#line 2328
  flags = (unsigned char *)((void *)0);
#line 2330
  dynoverlap = ((p___0->dynoverlap + 1176L) - 1L) / 1176L;
#line 2331
  anyflag = 0L;
#line 2343
  if (p___0->enable & 5) {
    {
#line 2346
    tmp___0 = rv(root);
    }
#line 2346
    if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
#line 2347
      target = p___0->cursor - dynoverlap;
    } else {
      {
#line 2346
      tmp___1 = rb(root);
      }
#line 2346
      if (tmp___1 > beginword) {
#line 2347
        target = p___0->cursor - dynoverlap;
      } else {
        {
#line 2349
        tmp = re(root);
#line 2349
        target = tmp / 1176L - dynoverlap;
        }
      }
    }
#line 2357
    readat = (target & -15L) + (long )p___0->jitter;
#line 2358
    if (readat > target) {
#line 2358
      readat -= 15L;
    }
#line 2359
    (p___0->jitter) --;
#line 2360
    if (p___0->jitter < 0) {
#line 2360
      p___0->jitter += 15;
    }
  } else {
#line 2363
    readat = p___0->cursor;
  }
#line 2366
  readat += driftcomp;
#line 2372
  if (p___0->enable & 5) {
    {
#line 2373
    tmp___2 = calloc((size_t )(totaltoread * 1176L), (size_t )1);
#line 2373
    flags = (unsigned char *)tmp___2;
#line 2374
    new = new_c_block(p___0);
#line 2375
    recover_cache(p___0);
    }
  } else {
    {
#line 2378
    paranoia_resetall(p___0);
#line 2379
    new = new_c_block(p___0);
    }
  }
  {
#line 2382
  tmp___3 = malloc((size_t )(totaltoread * 2352L));
#line 2382
  buffer = (int16_t *)tmp___3;
#line 2383
  sofar = 0L;
#line 2384
  firstread = -1L;
#line 2387
  cdrom_cache_handler(p___0, (int )readat, callback___0);
  }
  {
#line 2399
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2399
    if (! (sofar < totaltoread)) {
#line 2399
      goto while_break;
    }
#line 2400
    secread = sectatonce;
#line 2401
    adjread = readat;
#line 2405
    if (adjread < p___0->current_firstsector) {
#line 2406
      secread -= p___0->current_firstsector - adjread;
#line 2407
      adjread = p___0->current_firstsector;
    }
#line 2409
    if ((adjread + secread) - 1L > p___0->current_lastsector) {
#line 2410
      secread = (p___0->current_lastsector - adjread) + 1L;
    }
#line 2412
    if (sofar + secread > totaltoread) {
#line 2412
      secread = totaltoread - sofar;
    }
#line 2414
    if (secread > 0L) {
#line 2416
      if (firstread < 0L) {
#line 2416
        firstread = adjread;
      }
      {
#line 2438
      thisread = cdda_read(p___0->d, (void *)(buffer + sofar * 1176L), adjread, secread);
      }
#line 2438
      if (thisread < secread) {
#line 2441
        if (thisread < 0L) {
          {
#line 2443
          tmp___4 = __errno_location();
          }
#line 2443
          if (*tmp___4 == 123) {
#line 2445
            if (new) {
              {
#line 2445
              free_c_block(new);
              }
            }
#line 2446
            if (buffer) {
              {
#line 2446
              free((void *)buffer);
              }
            }
#line 2447
            if (flags) {
              {
#line 2447
              free((void *)flags);
              }
            }
#line 2448
            return ((c_block *)((void *)0));
          }
#line 2451
          thisread = 0L;
        }
#line 2457
        if (callback___0) {
          {
#line 2457
          (*callback___0)((adjread + thisread) * 1176L, 12);
          }
        }
        {
#line 2458
        memset((void *)(buffer + (sofar + thisread) * 1176L), 0, (size_t )(2352L * (secread - thisread)));
        }
#line 2460
        if (flags) {
          {
#line 2460
          memset((void *)(flags + (sofar + thisread) * 1176L), 2, (size_t )(1176L * (secread - thisread)));
          }
        }
      }
#line 2463
      if (thisread != 0L) {
#line 2463
        anyflag = 1L;
      }
#line 2479
      if (flags) {
#line 2479
        if (sofar != 0L) {
#line 2482
          i = 0;
#line 2483
          i = -32;
          {
#line 2483
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 2483
            if (! (i < 32)) {
#line 2483
              goto while_break___0;
            }
#line 2484
            *(flags + (sofar * 1176L + (long )i)) = (unsigned char )((int )*(flags + (sofar * 1176L + (long )i)) | 1);
#line 2483
            i ++;
          }
          while_break___0: /* CIL Label */ ;
          }
        }
      }
#line 2487
      if ((adjread + secread) - 1L == p___0->current_lastsector) {
#line 2488
        new->lastsector = -1L;
      }
#line 2490
      if (callback___0) {
        {
#line 2490
        (*callback___0)(((adjread + secread) - 1L) * 1176L, 0);
        }
      }
      {
#line 2492
      cdrom_cache_update(p___0, (int )adjread, (int )secread);
#line 2493
      sofar += secread;
#line 2494
      readat = adjread + secread;
      }
    } else
#line 2496
    if (readat < p___0->current_firstsector) {
#line 2497
      readat += sectatonce;
    } else {
#line 2499
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2513
  if (anyflag) {
#line 2514
    new->vector = buffer;
#line 2515
    new->begin = firstread * 1176L - p___0->dyndrift;
#line 2516
    new->size = sofar * 1176L;
#line 2517
    new->flags = flags;
  } else {
#line 2519
    if (new) {
      {
#line 2519
      free_c_block(new);
      }
    }
    {
#line 2520
    free((void *)buffer);
#line 2521
    free((void *)flags);
#line 2522
    new = (c_block *)((void *)0);
    }
  }
#line 2524
  return (new);
}
}
#line 2538 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/paranoia/paranoia.c"
int16_t *paranoia_read(cdrom_paranoia *p___0 , void (*callback___0)(long  , int  ) ) 
{ 
  int16_t *tmp ;

  {
  {
#line 2539
  tmp = paranoia_read_limited(p___0, callback___0, 20);
  }
#line 2539
  return (tmp);
}
}
#line 2545 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/paranoia/paranoia.c"
int16_t *paranoia_read_limited(cdrom_paranoia *p___0 , void (*callback___0)(long  ,
                                                                            int  ) ,
                               int max_retries ) 
{ 
  long beginword ;
  long endword ;
  long retry_count ;
  long lastend ;
  root_block *root ;
  int *tmp ;
  long tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;
  c_block *new ;
  c_block *tmp___4 ;
  long begin ;
  long end ;
  int tmp___5 ;
  int *tmp___6 ;
  long tmp___7 ;
  long tmp___8 ;
  int16_t *tmp___9 ;
  long tmp___10 ;
  long tmp___11 ;
  long tmp___12 ;
  int16_t *tmp___13 ;
  long tmp___14 ;

  {
#line 2548
  beginword = p___0->cursor * 1176L;
#line 2549
  endword = beginword + 1176L;
#line 2550
  retry_count = 0L;
#line 2550
  lastend = -2L;
#line 2551
  root = & p___0->root;
#line 2553
  if ((p___0->d)->opened == 0) {
    {
#line 2554
    tmp = __errno_location();
#line 2554
    *tmp = 9;
    }
#line 2555
    return ((int16_t *)((void *)0));
  }
#line 2558
  if (beginword > p___0->root.returnedlimit) {
#line 2558
    p___0->root.returnedlimit = beginword;
  }
  {
#line 2559
  lastend = re(root);
  }
  {
#line 2572
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 2572
    tmp___9 = rv(root);
    }
#line 2572
    if (! ((unsigned long )tmp___9 == (unsigned long )((void *)0))) {
      {
#line 2572
      tmp___10 = rb(root);
      }
#line 2572
      if (! (tmp___10 > beginword)) {
        {
#line 2572
        tmp___11 = re(root);
        }
#line 2572
        if (tmp___11 < endword + 37632L) {
#line 2572
          if (! (p___0->enable & 5)) {
#line 2572
            goto _L___1;
          }
        } else {
          _L___1: /* CIL Label */ 
          {
#line 2572
          tmp___12 = re(root);
          }
#line 2572
          if (! (tmp___12 < endword)) {
#line 2572
            goto while_break;
          }
        }
      }
    }
#line 2586
    if (p___0->enable & 5) {
      {
#line 2597
      i_paranoia_trim(p___0, beginword, endword);
#line 2598
      recover_cache(p___0);
#line 2600
      tmp___0 = rb(root);
      }
#line 2600
      if (tmp___0 != -1L) {
#line 2600
        if (p___0->root.lastsector) {
          {
#line 2601
          i_end_case(p___0, endword + 37632L, callback___0);
          }
        } else {
          {
#line 2610
          i_stage2(p___0, beginword, endword + 37632L, callback___0);
          }
        }
      } else {
        {
#line 2610
        i_stage2(p___0, beginword, endword + 37632L, callback___0);
        }
      }
    } else {
      {
#line 2614
      i_end_case(p___0, endword + 37632L, callback___0);
      }
    }
    {
#line 2620
    tmp___1 = rb(root);
    }
#line 2620
    if (! (tmp___1 == -1L)) {
      {
#line 2620
      tmp___2 = rb(root);
      }
#line 2620
      if (! (tmp___2 > beginword)) {
        {
#line 2620
        tmp___3 = re(root);
        }
#line 2620
        if (! (tmp___3 < endword + 37632L)) {
#line 2622
          goto while_break;
        }
      }
    }
    {
#line 2634
    tmp___4 = i_read_c_block(p___0, beginword, endword, callback___0);
#line 2634
    new = tmp___4;
    }
#line 2636
    if (new) {
#line 2637
      if (p___0->enable & 5) {
#line 2645
        if (p___0->enable & 1) {
          {
#line 2646
          i_stage1(p___0, new, callback___0);
          }
        } else {
#line 2658
          begin = 0L;
#line 2658
          end = 0L;
          {
#line 2660
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 2660
            if (! (begin < new->size)) {
#line 2660
              goto while_break___0;
            }
            {
#line 2661
            while (1) {
              while_continue___1: /* CIL Label */ ;
#line 2661
              if (begin < new->size) {
#line 2661
                if (! ((int )*(new->flags + begin) & 1)) {
#line 2661
                  goto while_break___1;
                }
              } else {
#line 2661
                goto while_break___1;
              }
#line 2661
              begin ++;
            }
            while_break___1: /* CIL Label */ ;
            }
#line 2662
            end = begin + 1L;
            {
#line 2663
            while (1) {
              while_continue___2: /* CIL Label */ ;
#line 2663
              if (end < new->size) {
#line 2663
                if (! (((int )*(new->flags + end) & 1) == 0)) {
#line 2663
                  goto while_break___2;
                }
              } else {
#line 2663
                goto while_break___2;
              }
#line 2663
              end ++;
            }
            while_break___2: /* CIL Label */ ;
            }
#line 2665
            if (new->lastsector) {
#line 2665
              if (new->begin + end == new->begin + new->size) {
#line 2665
                tmp___5 = 1;
              } else {
#line 2665
                tmp___5 = 0;
              }
            } else {
#line 2665
              tmp___5 = 0;
            }
            {
#line 2665
            new_v_fragment(p___0, new, begin + new->begin, end + new->begin, tmp___5);
#line 2669
            begin = end;
            }
          }
          while_break___0: /* CIL Label */ ;
          }
        }
      } else {
#line 2680
        if (p___0->root.vector) {
          {
#line 2680
          i_cblock_destructor(p___0->root.vector);
          }
        }
        {
#line 2681
        free_elem(new->e, 0);
#line 2682
        p___0->root.vector = new;
#line 2684
        i_end_case(p___0, endword + 37632L, callback___0);
        }
      }
    } else {
      {
#line 2693
      tmp___6 = __errno_location();
      }
#line 2693
      if (*tmp___6 == 123) {
#line 2693
        return ((int16_t *)((void *)0));
      }
    }
    {
#line 2704
    tmp___7 = rb(root);
    }
#line 2704
    if (tmp___7 != -1L) {
      {
#line 2704
      tmp___8 = re(root);
      }
#line 2704
      if (lastend + 588L < tmp___8) {
        {
#line 2706
        lastend = re(root);
#line 2707
        retry_count = 0L;
        }
      } else {
#line 2704
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
#line 2710
      retry_count ++;
#line 2715
      if (retry_count % 5L == 0L) {
#line 2716
        if (p___0->dynoverlap == 37632L) {
#line 2716
          goto _L;
        } else
#line 2716
        if (retry_count == (long )max_retries) {
          _L: /* CIL Label */ 
#line 2718
          if (! (p___0->enable & 32)) {
            {
#line 2718
            verify_skip_case(p___0, callback___0);
            }
          }
#line 2719
          retry_count = 0L;
        } else
#line 2721
        if (p___0->stage1.offpoints != -1L) {
#line 2722
          p___0->dynoverlap = (long )((double )p___0->dynoverlap * 1.5);
#line 2723
          if (p___0->dynoverlap > 37632L) {
#line 2724
            p___0->dynoverlap = 37632L;
          }
#line 2725
          if (callback___0) {
            {
#line 2725
            (*callback___0)(p___0->dynoverlap, 9);
            }
          }
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2738
  (p___0->cursor) ++;
#line 2743
  tmp___13 = rv(root);
#line 2743
  tmp___14 = rb(root);
  }
#line 2743
  return (tmp___13 + (beginword - tmp___14));
}
}
#line 2747 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/paranoia/paranoia.c"
void paranoia_overlapset(cdrom_paranoia *p___0 , long overlap___0 ) 
{ 


  {
#line 2748
  p___0->dynoverlap = overlap___0 * 1176L;
#line 2749
  p___0->stage1.offpoints = -1L;
#line 2750
  return;
}
}
#line 2752 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/paranoia/paranoia.c"
char *paranoia_version(void) 
{ 


  {
#line 2753
  return ((char *)"10.2");
}
}
#line 18 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/smallft.c"
static void drfti1___0(int n , float *wa , int *ifac ) ;
#line 18 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/smallft.c"
static int ntryh___0[4]  = {      4,      2,      3,      5};
#line 19 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/smallft.c"
static float tpi___0  =    (float )6.28318530717958647692528676655900577;
#line 17 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/smallft.c"
static void drfti1___0(int n , float *wa , int *ifac ) 
{ 
  float arg ;
  float argh ;
  float argld ;
  float fi ;
  int ntry ;
  int i ;
  int j ;
  int k1 ;
  int l1 ;
  int l2 ;
  int ib ;
  int ld ;
  int ii ;
  int ip ;
  int is ;
  int nq ;
  int nr ;
  int ido ;
  int ipm ;
  int nfm1 ;
  int nl ;
  int nf ;
  int tmp ;
  double tmp___0 ;
  int tmp___1 ;
  double tmp___2 ;

  {
#line 21
  ntry = 0;
#line 21
  j = -1;
#line 25
  nl = n;
#line 26
  nf = 0;
  L101: 
#line 29
  j ++;
#line 30
  if (j < 4) {
#line 31
    ntry = ntryh___0[j];
  } else {
#line 33
    ntry += 2;
  }
  L104: 
#line 36
  nq = nl / ntry;
#line 37
  nr = nl - ntry * nq;
#line 38
  if (nr != 0) {
#line 38
    goto L101;
  }
#line 40
  nf ++;
#line 41
  *(ifac + (nf + 1)) = ntry;
#line 42
  nl = nq;
#line 43
  if (ntry != 2) {
#line 43
    goto L107;
  }
#line 44
  if (nf == 1) {
#line 44
    goto L107;
  }
#line 46
  i = 1;
  {
#line 46
  while (1) {
    while_continue: /* CIL Label */ ;
#line 46
    if (! (i < nf)) {
#line 46
      goto while_break;
    }
#line 47
    ib = (nf - i) + 1;
#line 48
    *(ifac + (ib + 1)) = *(ifac + ib);
#line 46
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 50
  *(ifac + 2) = 2;
  L107: 
#line 53
  if (nl != 1) {
#line 53
    goto L104;
  }
#line 54
  *(ifac + 0) = n;
#line 55
  *(ifac + 1) = nf;
#line 56
  argh = tpi___0 / (float )n;
#line 57
  is = 0;
#line 58
  nfm1 = nf - 1;
#line 59
  l1 = 1;
#line 61
  if (nfm1 == 0) {
#line 61
    return;
  }
#line 63
  k1 = 0;
  {
#line 63
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 63
    if (! (k1 < nfm1)) {
#line 63
      goto while_break___0;
    }
#line 64
    ip = *(ifac + (k1 + 2));
#line 65
    ld = 0;
#line 66
    l2 = l1 * ip;
#line 67
    ido = n / l2;
#line 68
    ipm = ip - 1;
#line 70
    j = 0;
    {
#line 70
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 70
      if (! (j < ipm)) {
#line 70
        goto while_break___1;
      }
#line 71
      ld += l1;
#line 72
      i = is;
#line 73
      argld = (float )ld * argh;
#line 74
      fi = (float )0.;
#line 75
      ii = 2;
      {
#line 75
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 75
        if (! (ii < ido)) {
#line 75
          goto while_break___2;
        }
        {
#line 76
        fi = (float )((double )fi + 1.);
#line 77
        arg = fi * argld;
#line 78
        tmp = i;
#line 78
        i ++;
#line 78
        tmp___0 = cos((double )arg);
#line 78
        *(wa + tmp) = (float )tmp___0;
#line 79
        tmp___1 = i;
#line 79
        i ++;
#line 79
        tmp___2 = sin((double )arg);
#line 79
        *(wa + tmp___1) = (float )tmp___2;
#line 75
        ii += 2;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
#line 81
      is += ido;
#line 70
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 83
    l1 = l2;
#line 63
    k1 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 85
  return;
}
}
#line 87 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/smallft.c"
static void fdrffti___0(int n , float *wsave , int *ifac ) 
{ 


  {
#line 89
  if (n == 1) {
#line 89
    return;
  }
  {
#line 90
  drfti1___0(n, wsave + n, ifac);
  }
#line 91
  return;
}
}
#line 93 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/smallft.c"
static void dradf2___0(int ido , int l1 , float *cc , float *ch , float *wa1 ) 
{ 
  int i ;
  int k ;
  float ti2 ;
  float tr2 ;
  int t0 ;
  int t1 ;
  int t2 ;
  int t3 ;
  int t4 ;
  int t5 ;
  int t6 ;

  {
#line 98
  t1 = 0;
#line 99
  t2 = l1 * ido;
#line 99
  t0 = t2;
#line 100
  t3 = ido << 1;
#line 101
  k = 0;
  {
#line 101
  while (1) {
    while_continue: /* CIL Label */ ;
#line 101
    if (! (k < l1)) {
#line 101
      goto while_break;
    }
#line 102
    *(ch + (t1 << 1)) = *(cc + t1) + *(cc + t2);
#line 103
    *(ch + (((t1 << 1) + t3) - 1)) = *(cc + t1) - *(cc + t2);
#line 104
    t1 += ido;
#line 105
    t2 += ido;
#line 101
    k ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 108
  if (ido < 2) {
#line 108
    return;
  }
#line 109
  if (ido == 2) {
#line 109
    goto L105;
  }
#line 111
  t1 = 0;
#line 112
  t2 = t0;
#line 113
  k = 0;
  {
#line 113
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 113
    if (! (k < l1)) {
#line 113
      goto while_break___0;
    }
#line 114
    t3 = t2;
#line 115
    t4 = (t1 << 1) + (ido << 1);
#line 116
    t5 = t1;
#line 117
    t6 = t1 + t1;
#line 118
    i = 2;
    {
#line 118
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 118
      if (! (i < ido)) {
#line 118
        goto while_break___1;
      }
#line 119
      t3 += 2;
#line 120
      t4 -= 2;
#line 121
      t5 += 2;
#line 122
      t6 += 2;
#line 123
      tr2 = *(wa1 + (i - 2)) * *(cc + (t3 - 1)) + *(wa1 + (i - 1)) * *(cc + t3);
#line 124
      ti2 = *(wa1 + (i - 2)) * *(cc + t3) - *(wa1 + (i - 1)) * *(cc + (t3 - 1));
#line 125
      *(ch + t6) = *(cc + t5) + ti2;
#line 126
      *(ch + t4) = ti2 - *(cc + t5);
#line 127
      *(ch + (t6 - 1)) = *(cc + (t5 - 1)) + tr2;
#line 128
      *(ch + (t4 - 1)) = *(cc + (t5 - 1)) - tr2;
#line 118
      i += 2;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 130
    t1 += ido;
#line 131
    t2 += ido;
#line 113
    k ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 134
  if (ido % 2 == 1) {
#line 134
    return;
  }
  L105: 
#line 137
  t1 = ido;
#line 137
  t2 = t1 - 1;
#line 137
  t3 = t2;
#line 138
  t2 += t0;
#line 139
  k = 0;
  {
#line 139
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 139
    if (! (k < l1)) {
#line 139
      goto while_break___2;
    }
#line 140
    *(ch + t1) = - *(cc + t2);
#line 141
    *(ch + (t1 - 1)) = *(cc + t3);
#line 142
    t1 += ido << 1;
#line 143
    t2 += ido;
#line 144
    t3 += ido;
#line 139
    k ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 146
  return;
}
}
#line 150
static void dradf4___0(int ido , int l1 , float *cc , float *ch , float *wa1 , float *wa2 ,
                       float *wa3 ) ;
#line 150 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/smallft.c"
static float hsqt2___0  =    (float ).70710678118654752440084436210485;
#line 148 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/smallft.c"
static void dradf4___0(int ido , int l1 , float *cc , float *ch , float *wa1 , float *wa2 ,
                       float *wa3 ) 
{ 
  int i ;
  int k ;
  int t0 ;
  int t1 ;
  int t2 ;
  int t3 ;
  int t4 ;
  int t5 ;
  int t6 ;
  float ci2 ;
  float ci3 ;
  float ci4 ;
  float cr2 ;
  float cr3 ;
  float cr4 ;
  float ti1 ;
  float ti2 ;
  float ti3 ;
  float ti4 ;
  float tr1 ;
  float tr2 ;
  float tr3 ;
  float tr4 ;

  {
#line 153
  t0 = l1 * ido;
#line 155
  t1 = t0;
#line 156
  t4 = t1 << 1;
#line 157
  t2 = t1 + (t1 << 1);
#line 158
  t3 = 0;
#line 160
  k = 0;
  {
#line 160
  while (1) {
    while_continue: /* CIL Label */ ;
#line 160
    if (! (k < l1)) {
#line 160
      goto while_break;
    }
#line 161
    tr1 = *(cc + t1) + *(cc + t2);
#line 162
    tr2 = *(cc + t3) + *(cc + t4);
#line 164
    t5 = t3 << 2;
#line 164
    *(ch + t5) = tr1 + tr2;
#line 165
    *(ch + (((ido << 2) + t5) - 1)) = tr2 - tr1;
#line 166
    t5 += ido << 1;
#line 166
    *(ch + (t5 - 1)) = *(cc + t3) - *(cc + t4);
#line 167
    *(ch + t5) = *(cc + t2) - *(cc + t1);
#line 169
    t1 += ido;
#line 170
    t2 += ido;
#line 171
    t3 += ido;
#line 172
    t4 += ido;
#line 160
    k ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 175
  if (ido < 2) {
#line 175
    return;
  }
#line 176
  if (ido == 2) {
#line 176
    goto L105;
  }
#line 179
  t1 = 0;
#line 180
  k = 0;
  {
#line 180
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 180
    if (! (k < l1)) {
#line 180
      goto while_break___0;
    }
#line 181
    t2 = t1;
#line 182
    t4 = t1 << 2;
#line 183
    t6 = ido << 1;
#line 183
    t5 = t6 + t4;
#line 184
    i = 2;
    {
#line 184
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 184
      if (! (i < ido)) {
#line 184
        goto while_break___1;
      }
#line 185
      t2 += 2;
#line 185
      t3 = t2;
#line 186
      t4 += 2;
#line 187
      t5 -= 2;
#line 189
      t3 += t0;
#line 190
      cr2 = *(wa1 + (i - 2)) * *(cc + (t3 - 1)) + *(wa1 + (i - 1)) * *(cc + t3);
#line 191
      ci2 = *(wa1 + (i - 2)) * *(cc + t3) - *(wa1 + (i - 1)) * *(cc + (t3 - 1));
#line 192
      t3 += t0;
#line 193
      cr3 = *(wa2 + (i - 2)) * *(cc + (t3 - 1)) + *(wa2 + (i - 1)) * *(cc + t3);
#line 194
      ci3 = *(wa2 + (i - 2)) * *(cc + t3) - *(wa2 + (i - 1)) * *(cc + (t3 - 1));
#line 195
      t3 += t0;
#line 196
      cr4 = *(wa3 + (i - 2)) * *(cc + (t3 - 1)) + *(wa3 + (i - 1)) * *(cc + t3);
#line 197
      ci4 = *(wa3 + (i - 2)) * *(cc + t3) - *(wa3 + (i - 1)) * *(cc + (t3 - 1));
#line 199
      tr1 = cr2 + cr4;
#line 200
      tr4 = cr4 - cr2;
#line 201
      ti1 = ci2 + ci4;
#line 202
      ti4 = ci2 - ci4;
#line 204
      ti2 = *(cc + t2) + ci3;
#line 205
      ti3 = *(cc + t2) - ci3;
#line 206
      tr2 = *(cc + (t2 - 1)) + cr3;
#line 207
      tr3 = *(cc + (t2 - 1)) - cr3;
#line 209
      *(ch + (t4 - 1)) = tr1 + tr2;
#line 210
      *(ch + t4) = ti1 + ti2;
#line 212
      *(ch + (t5 - 1)) = tr3 - ti4;
#line 213
      *(ch + t5) = tr4 - ti3;
#line 215
      *(ch + ((t4 + t6) - 1)) = ti4 + tr3;
#line 216
      *(ch + (t4 + t6)) = tr4 + ti3;
#line 218
      *(ch + ((t5 + t6) - 1)) = tr2 - tr1;
#line 219
      *(ch + (t5 + t6)) = ti1 - ti2;
#line 184
      i += 2;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 221
    t1 += ido;
#line 180
    k ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 223
  if (ido & 1) {
#line 223
    return;
  }
  L105: 
#line 227
  t1 = (t0 + ido) - 1;
#line 227
  t2 = t1 + (t0 << 1);
#line 228
  t3 = ido << 2;
#line 229
  t4 = ido;
#line 230
  t5 = ido << 1;
#line 231
  t6 = ido;
#line 233
  k = 0;
  {
#line 233
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 233
    if (! (k < l1)) {
#line 233
      goto while_break___2;
    }
#line 234
    ti1 = - hsqt2___0 * (*(cc + t1) + *(cc + t2));
#line 235
    tr1 = hsqt2___0 * (*(cc + t1) - *(cc + t2));
#line 237
    *(ch + (t4 - 1)) = tr1 + *(cc + (t6 - 1));
#line 238
    *(ch + ((t4 + t5) - 1)) = *(cc + (t6 - 1)) - tr1;
#line 240
    *(ch + t4) = ti1 - *(cc + (t1 + t0));
#line 241
    *(ch + (t4 + t5)) = ti1 + *(cc + (t1 + t0));
#line 243
    t1 += ido;
#line 244
    t2 += ido;
#line 245
    t4 += t3;
#line 246
    t6 += ido;
#line 233
    k ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 248
  return;
}
}
#line 250 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/smallft.c"
static void drftf1___0(int n , float *c , float *ch , float *wa , int *ifac ) 
{ 
  int i ;
  int k1 ;
  int l1 ;
  int l2 ;
  int na ;
  int kh ;
  int nf ;
  int ip ;
  int iw ;
  int ido ;
  int idl1 ;
  int ix2 ;
  int ix3 ;

  {
#line 255
  nf = *(ifac + 1);
#line 256
  na = 1;
#line 257
  l2 = n;
#line 258
  iw = n;
#line 260
  k1 = 0;
  {
#line 260
  while (1) {
    while_continue: /* CIL Label */ ;
#line 260
    if (! (k1 < nf)) {
#line 260
      goto while_break;
    }
#line 261
    kh = nf - k1;
#line 262
    ip = *(ifac + (kh + 1));
#line 263
    l1 = l2 / ip;
#line 264
    ido = n / l2;
#line 265
    idl1 = ido * l1;
#line 266
    iw -= (ip - 1) * ido;
#line 267
    na = 1 - na;
#line 269
    if (ip != 4) {
#line 269
      goto L102;
    }
#line 271
    ix2 = iw + ido;
#line 272
    ix3 = ix2 + ido;
#line 273
    if (na != 0) {
      {
#line 274
      dradf4___0(ido, l1, ch, c, (wa + iw) - 1, (wa + ix2) - 1, (wa + ix3) - 1);
      }
    } else {
      {
#line 276
      dradf4___0(ido, l1, c, ch, (wa + iw) - 1, (wa + ix2) - 1, (wa + ix3) - 1);
      }
    }
#line 277
    goto L110;
    L102: 
#line 280
    if (ip != 2) {
#line 280
      goto L104;
    }
#line 281
    if (na != 0) {
#line 281
      goto L103;
    }
    {
#line 283
    dradf2___0(ido, l1, c, ch, (wa + iw) - 1);
    }
#line 284
    goto L110;
    L103: 
    {
#line 287
    dradf2___0(ido, l1, ch, c, (wa + iw) - 1);
    }
#line 288
    goto L110;
    L104: 
#line 291
    return;
    L110: 
#line 294
    l2 = l1;
#line 260
    k1 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 297
  if (na == 1) {
#line 297
    return;
  }
#line 299
  i = 0;
  {
#line 299
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 299
    if (! (i < n)) {
#line 299
      goto while_break___0;
    }
#line 299
    *(c + i) = *(ch + i);
#line 299
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 300
  return;
}
}
#line 302 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/smallft.c"
static void fdrfftf___0(int n , float *r , float *wsave , int *ifac ) 
{ 


  {
#line 303
  if (n == 1) {
#line 303
    return;
  }
  {
#line 304
  drftf1___0(n, r, wsave, wsave + n, ifac);
  }
#line 305
  return;
}
}
#line 307 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/smallft.c"
static void dradb2___0(int ido , int l1 , float *cc , float *ch , float *wa1 ) 
{ 
  int i ;
  int k ;
  int t0 ;
  int t1 ;
  int t2 ;
  int t3 ;
  int t4 ;
  int t5 ;
  int t6 ;
  float ti2 ;
  float tr2 ;

  {
#line 311
  t0 = l1 * ido;
#line 313
  t1 = 0;
#line 314
  t2 = 0;
#line 315
  t3 = (ido << 1) - 1;
#line 316
  k = 0;
  {
#line 316
  while (1) {
    while_continue: /* CIL Label */ ;
#line 316
    if (! (k < l1)) {
#line 316
      goto while_break;
    }
#line 317
    *(ch + t1) = *(cc + t2) + *(cc + (t3 + t2));
#line 318
    *(ch + (t1 + t0)) = *(cc + t2) - *(cc + (t3 + t2));
#line 319
    t1 += ido;
#line 319
    t2 = t1 << 1;
#line 316
    k ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 322
  if (ido < 2) {
#line 322
    return;
  }
#line 323
  if (ido == 2) {
#line 323
    goto L105;
  }
#line 325
  t1 = 0;
#line 326
  t2 = 0;
#line 327
  k = 0;
  {
#line 327
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 327
    if (! (k < l1)) {
#line 327
      goto while_break___0;
    }
#line 328
    t3 = t1;
#line 329
    t4 = t2;
#line 329
    t5 = t4 + (ido << 1);
#line 330
    t6 = t0 + t1;
#line 331
    i = 2;
    {
#line 331
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 331
      if (! (i < ido)) {
#line 331
        goto while_break___1;
      }
#line 332
      t3 += 2;
#line 333
      t4 += 2;
#line 334
      t5 -= 2;
#line 335
      t6 += 2;
#line 336
      *(ch + (t3 - 1)) = *(cc + (t4 - 1)) + *(cc + (t5 - 1));
#line 337
      tr2 = *(cc + (t4 - 1)) - *(cc + (t5 - 1));
#line 338
      *(ch + t3) = *(cc + t4) - *(cc + t5);
#line 339
      ti2 = *(cc + t4) + *(cc + t5);
#line 340
      *(ch + (t6 - 1)) = *(wa1 + (i - 2)) * tr2 - *(wa1 + (i - 1)) * ti2;
#line 341
      *(ch + t6) = *(wa1 + (i - 2)) * ti2 + *(wa1 + (i - 1)) * tr2;
#line 331
      i += 2;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 343
    t1 += ido;
#line 343
    t2 = t1 << 1;
#line 327
    k ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 346
  if (ido % 2 == 1) {
#line 346
    return;
  }
  L105: 
#line 349
  t1 = ido - 1;
#line 350
  t2 = ido - 1;
#line 351
  k = 0;
  {
#line 351
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 351
    if (! (k < l1)) {
#line 351
      goto while_break___2;
    }
#line 352
    *(ch + t1) = *(cc + t2) + *(cc + t2);
#line 353
    *(ch + (t1 + t0)) = - (*(cc + (t2 + 1)) + *(cc + (t2 + 1)));
#line 354
    t1 += ido;
#line 355
    t2 += ido << 1;
#line 351
    k ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 357
  return;
}
}
#line 361
static void dradb4___0(int ido , int l1 , float *cc , float *ch , float *wa1 , float *wa2 ,
                       float *wa3 ) ;
#line 361 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/smallft.c"
static float sqrt2___0  =    (float )1.4142135623730950488016887242097;
#line 359 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/smallft.c"
static void dradb4___0(int ido , int l1 , float *cc , float *ch , float *wa1 , float *wa2 ,
                       float *wa3 ) 
{ 
  int i ;
  int k ;
  int t0 ;
  int t1 ;
  int t2 ;
  int t3 ;
  int t4 ;
  int t5 ;
  int t6 ;
  int t7 ;
  int t8 ;
  float ci2 ;
  float ci3 ;
  float ci4 ;
  float cr2 ;
  float cr3 ;
  float cr4 ;
  float ti1 ;
  float ti2 ;
  float ti3 ;
  float ti4 ;
  float tr1 ;
  float tr2 ;
  float tr3 ;
  float tr4 ;

  {
#line 364
  t0 = l1 * ido;
#line 366
  t1 = 0;
#line 367
  t2 = ido << 2;
#line 368
  t3 = 0;
#line 369
  t6 = ido << 1;
#line 370
  k = 0;
  {
#line 370
  while (1) {
    while_continue: /* CIL Label */ ;
#line 370
    if (! (k < l1)) {
#line 370
      goto while_break;
    }
#line 371
    t4 = t3 + t6;
#line 372
    t5 = t1;
#line 373
    tr3 = *(cc + (t4 - 1)) + *(cc + (t4 - 1));
#line 374
    tr4 = *(cc + t4) + *(cc + t4);
#line 375
    t4 += t6;
#line 375
    tr1 = *(cc + t3) - *(cc + (t4 - 1));
#line 376
    tr2 = *(cc + t3) + *(cc + (t4 - 1));
#line 377
    *(ch + t5) = tr2 + tr3;
#line 378
    t5 += t0;
#line 378
    *(ch + t5) = tr1 - tr4;
#line 379
    t5 += t0;
#line 379
    *(ch + t5) = tr2 - tr3;
#line 380
    t5 += t0;
#line 380
    *(ch + t5) = tr1 + tr4;
#line 381
    t1 += ido;
#line 382
    t3 += t2;
#line 370
    k ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 385
  if (ido < 2) {
#line 385
    return;
  }
#line 386
  if (ido == 2) {
#line 386
    goto L105;
  }
#line 388
  t1 = 0;
#line 389
  k = 0;
  {
#line 389
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 389
    if (! (k < l1)) {
#line 389
      goto while_break___0;
    }
#line 390
    t2 = t1 << 2;
#line 390
    t3 = t2 + t6;
#line 390
    t4 = t3;
#line 390
    t5 = t4 + t6;
#line 391
    t7 = t1;
#line 392
    i = 2;
    {
#line 392
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 392
      if (! (i < ido)) {
#line 392
        goto while_break___1;
      }
#line 393
      t2 += 2;
#line 394
      t3 += 2;
#line 395
      t4 -= 2;
#line 396
      t5 -= 2;
#line 397
      t7 += 2;
#line 398
      ti1 = *(cc + t2) + *(cc + t5);
#line 399
      ti2 = *(cc + t2) - *(cc + t5);
#line 400
      ti3 = *(cc + t3) - *(cc + t4);
#line 401
      tr4 = *(cc + t3) + *(cc + t4);
#line 402
      tr1 = *(cc + (t2 - 1)) - *(cc + (t5 - 1));
#line 403
      tr2 = *(cc + (t2 - 1)) + *(cc + (t5 - 1));
#line 404
      ti4 = *(cc + (t3 - 1)) - *(cc + (t4 - 1));
#line 405
      tr3 = *(cc + (t3 - 1)) + *(cc + (t4 - 1));
#line 406
      *(ch + (t7 - 1)) = tr2 + tr3;
#line 407
      cr3 = tr2 - tr3;
#line 408
      *(ch + t7) = ti2 + ti3;
#line 409
      ci3 = ti2 - ti3;
#line 410
      cr2 = tr1 - tr4;
#line 411
      cr4 = tr1 + tr4;
#line 412
      ci2 = ti1 + ti4;
#line 413
      ci4 = ti1 - ti4;
#line 415
      t8 = t7 + t0;
#line 415
      *(ch + (t8 - 1)) = *(wa1 + (i - 2)) * cr2 - *(wa1 + (i - 1)) * ci2;
#line 416
      *(ch + t8) = *(wa1 + (i - 2)) * ci2 + *(wa1 + (i - 1)) * cr2;
#line 417
      t8 += t0;
#line 417
      *(ch + (t8 - 1)) = *(wa2 + (i - 2)) * cr3 - *(wa2 + (i - 1)) * ci3;
#line 418
      *(ch + t8) = *(wa2 + (i - 2)) * ci3 + *(wa2 + (i - 1)) * cr3;
#line 419
      t8 += t0;
#line 419
      *(ch + (t8 - 1)) = *(wa3 + (i - 2)) * cr4 - *(wa3 + (i - 1)) * ci4;
#line 420
      *(ch + t8) = *(wa3 + (i - 2)) * ci4 + *(wa3 + (i - 1)) * cr4;
#line 392
      i += 2;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 422
    t1 += ido;
#line 389
    k ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 425
  if (ido % 2 == 1) {
#line 425
    return;
  }
  L105: 
#line 429
  t1 = ido;
#line 430
  t2 = ido << 2;
#line 431
  t3 = ido - 1;
#line 432
  t4 = ido + (ido << 1);
#line 433
  k = 0;
  {
#line 433
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 433
    if (! (k < l1)) {
#line 433
      goto while_break___2;
    }
#line 434
    t5 = t3;
#line 435
    ti1 = *(cc + t1) + *(cc + t4);
#line 436
    ti2 = *(cc + t4) - *(cc + t1);
#line 437
    tr1 = *(cc + (t1 - 1)) - *(cc + (t4 - 1));
#line 438
    tr2 = *(cc + (t1 - 1)) + *(cc + (t4 - 1));
#line 439
    *(ch + t5) = tr2 + tr2;
#line 440
    t5 += t0;
#line 440
    *(ch + t5) = sqrt2___0 * (tr1 - ti1);
#line 441
    t5 += t0;
#line 441
    *(ch + t5) = ti2 + ti2;
#line 442
    t5 += t0;
#line 442
    *(ch + t5) = - sqrt2___0 * (tr1 + ti1);
#line 444
    t3 += ido;
#line 445
    t1 += t2;
#line 446
    t4 += t2;
#line 433
    k ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 448
  return;
}
}
#line 450 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/smallft.c"
static void drftb1___0(int n , float *c , float *ch , float *wa , int *ifac ) 
{ 
  int i ;
  int k1 ;
  int l1 ;
  int l2 ;
  int na ;
  int nf ;
  int ip ;
  int iw ;
  int ix2 ;
  int ix3 ;
  int ido ;
  int idl1 ;

  {
#line 455
  nf = *(ifac + 1);
#line 456
  na = 0;
#line 457
  l1 = 1;
#line 458
  iw = 1;
#line 460
  k1 = 0;
  {
#line 460
  while (1) {
    while_continue: /* CIL Label */ ;
#line 460
    if (! (k1 < nf)) {
#line 460
      goto while_break;
    }
#line 461
    ip = *(ifac + (k1 + 2));
#line 462
    l2 = ip * l1;
#line 463
    ido = n / l2;
#line 464
    idl1 = ido * l1;
#line 465
    if (ip != 4) {
#line 465
      goto L103;
    }
#line 466
    ix2 = iw + ido;
#line 467
    ix3 = ix2 + ido;
#line 469
    if (na != 0) {
      {
#line 470
      dradb4___0(ido, l1, ch, c, (wa + iw) - 1, (wa + ix2) - 1, (wa + ix3) - 1);
      }
    } else {
      {
#line 472
      dradb4___0(ido, l1, c, ch, (wa + iw) - 1, (wa + ix2) - 1, (wa + ix3) - 1);
      }
    }
#line 473
    na = 1 - na;
#line 474
    goto L115;
    L103: 
#line 477
    if (ip != 2) {
#line 477
      goto L106;
    }
#line 479
    if (na != 0) {
      {
#line 480
      dradb2___0(ido, l1, ch, c, (wa + iw) - 1);
      }
    } else {
      {
#line 482
      dradb2___0(ido, l1, c, ch, (wa + iw) - 1);
      }
    }
#line 483
    na = 1 - na;
#line 484
    goto L115;
    L106: 
#line 487
    return;
    L115: 
#line 490
    l1 = l2;
#line 491
    iw += (ip - 1) * ido;
#line 460
    k1 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 494
  if (na == 0) {
#line 494
    return;
  }
#line 496
  i = 0;
  {
#line 496
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 496
    if (! (i < n)) {
#line 496
      goto while_break___0;
    }
#line 496
    *(c + i) = *(ch + i);
#line 496
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 497
  return;
}
}
#line 499 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/smallft.c"
static void fdrfftb___0(int n , float *r , float *wsave , int *ifac ) 
{ 


  {
#line 500
  if (n == 1) {
#line 500
    return;
  }
  {
#line 501
  drftb1___0(n, r, wsave, wsave + n, ifac);
  }
#line 502
  return;
}
}
#line 144 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 156 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) sqrt)(double __x ) ;
#line 48 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/cachetest.c"
static int time_drive(cdrom_drive *d___0 , FILE *progress , FILE *log___0 , int lba ,
                      int len , int initial_seek ) 
{ 
  int i ;
  int x ;
  int latency ;
  double sum ;
  double sumsq ;
  int sofar ;
  int toread ;
  int tmp ;
  int ret ;
  long tmp___0 ;
  double mean ;
  double stddev ;
  double tmp___1 ;

  {
#line 50
  latency = 0;
#line 51
  sum = (double )0;
#line 52
  sumsq = (double )0;
#line 55
  if (log___0) {
    {
#line 55
    fprintf((FILE */* __restrict  */)log___0, (char const   */* __restrict  */)"\n");
    }
  }
#line 57
  i = 0;
#line 57
  sofar = 0;
  {
#line 57
  while (1) {
    while_continue: /* CIL Label */ ;
#line 57
    if (! (sofar < len)) {
#line 57
      goto while_break;
    }
#line 58
    if (i == 0) {
#line 58
      if (initial_seek) {
#line 58
        tmp = 1;
      } else {
#line 58
        tmp = len - sofar;
      }
    } else {
#line 58
      tmp = len - sofar;
    }
    {
#line 58
    toread = tmp;
#line 61
    tmp___0 = cdda_read_timed(d___0, (void *)0, (long )(lba + sofar), (long )toread,
                              & x);
#line 61
    ret = (int )tmp___0;
    }
#line 61
    if (ret <= 0) {
#line 63
      if (ret == -404) {
#line 63
        return (-404);
      }
#line 64
      return (-1);
    }
#line 67
    if (x > 9999) {
#line 67
      x = 9999;
    }
#line 68
    if (x < 0) {
#line 68
      x = 0;
    }
#line 69
    if (log___0) {
      {
#line 69
      fprintf((FILE */* __restrict  */)log___0, (char const   */* __restrict  */)"%d:%d:%d ",
              lba + sofar, ret, x);
      }
    }
#line 71
    sofar += ret;
#line 72
    if (i) {
#line 73
      sum += (double )x;
#line 74
      sumsq += (double )((float )(x * x) / (float )ret);
    } else
#line 72
    if (! initial_seek) {
#line 73
      sum += (double )x;
#line 74
      sumsq += (double )((float )(x * x) / (float )ret);
    } else {
#line 76
      latency = x;
    }
#line 57
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 85
  mean = sum / (double )((float )(len - 1));
#line 86
  tmp___1 = sqrt(sumsq / (double )((float )(len - 1)) - mean * mean);
#line 86
  stddev = tmp___1;
  }
#line 88
  if (initial_seek) {
#line 89
    if (progress) {
      {
#line 89
      fprintf((FILE */* __restrict  */)progress, (char const   */* __restrict  */)"%4dms seek, %.2fms/sec read [%.1fx]",
              latency, mean, (1000. / 75.) / mean);
      }
    }
#line 90
    if (log___0) {
      {
#line 90
      fprintf((FILE */* __restrict  */)log___0, (char const   */* __restrict  */)"\n\tInitial seek latency (%d sectors): %dms",
              len, latency);
      }
    }
  }
#line 93
  if (log___0) {
    {
#line 93
    fprintf((FILE */* __restrict  */)log___0, (char const   */* __restrict  */)"\n\tAverage read latency: %.2fms/sector (raw speed: %.1fx)",
            mean, (1000. / 75.) / mean);
    }
  }
#line 94
  if (log___0) {
    {
#line 94
    fprintf((FILE */* __restrict  */)log___0, (char const   */* __restrict  */)"\n\tRead latency standard deviation: %.2fms/sector",
            stddev);
    }
  }
#line 96
  return ((int )sum);
}
}
#line 100 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/cachetest.c"
static float retime_drive(cdrom_drive *d___0 , FILE *progress , FILE *log___0 , int lba ,
                          int readahead , float oldmean ) 
{ 
  int sectors ;
  int total ;
  float newmean ;

  {
#line 101
  sectors = 2000;
#line 104
  if ((float )sectors * oldmean > (float )5000) {
#line 104
    sectors = (int )((float )5000 / oldmean);
  }
#line 105
  readahead *= 10;
#line 106
  readahead /= 9;
#line 107
  if (readahead > sectors) {
#line 107
    sectors = readahead;
  }
#line 109
  if (progress) {
    {
#line 109
    fprintf((FILE */* __restrict  */)progress, (char const   */* __restrict  */)"\bo");
    }
  }
#line 110
  if (log___0) {
    {
#line 110
    fprintf((FILE */* __restrict  */)log___0, (char const   */* __restrict  */)"\n\tRetiming drive...                               ");
    }
  }
  {
#line 112
  total = time_drive(d___0, (FILE *)((void *)0), log___0, lba, sectors, 1);
#line 113
  newmean = (float )total / (float )sectors;
  }
#line 115
  if (log___0) {
    {
#line 115
    fprintf((FILE */* __restrict  */)log___0, (char const   */* __restrict  */)"\n\tOld mean=%.2fms/sec, New mean=%.2fms/sec\n",
            (double )oldmean, (double )newmean);
    }
  }
#line 116
  if (progress) {
    {
#line 116
    fprintf((FILE */* __restrict  */)progress, (char const   */* __restrict  */)"\b");
    }
  }
#line 118
  if (newmean > oldmean) {
#line 118
    return (newmean);
  }
#line 119
  return (oldmean);
}
}
#line 122 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/cachetest.c"
int analyze_cache(cdrom_drive *d___0 , FILE *progress , FILE *log___0 , int speed ) 
{ 
  int i ;
  int j ;
  int ret ;
  int x ;
  int firstsector ;
  int lastsector ;
  int firsttest ;
  int lasttest ;
  int offset ;
  int warn ;
  int current ;
  int hi ;
  int cachesize ;
  int readahead ;
  int rollbehind ;
  int cachegran ;
  float mspersector ;
  char *tmp ;
  int tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  int tmp___3 ;
  int best ;
  int bestcount ;
  int iterating ;
  int m ;
  int s ;
  int f ;
  int sofar ;
  long tmp___4 ;
  int under ;
  int onex ;
  int i___0 ;
  int j___0 ;
  int tmp___5 ;
  int ret1 ;
  int ret2 ;
  int sofar___0 ;
  int tmp___6 ;
  long tmp___7 ;
  long tmp___8 ;
  long tmp___9 ;
  cdrom_paranoia___0 *p___0 ;
  cdrom_paranoia___0 *tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int seekoff ;
  int under___0 ;
  int ret1___0 ;
  int ret2___0 ;
  long tmp___13 ;
  long tmp___14 ;
  int lower ;
  int gran ;
  int it ;
  int tests ;
  int under___1 ;
  int sofar___1 ;
  int ret___0 ;
  long tmp___15 ;
  int usec ;
  int max ;
  long tmp___16 ;
  int sofar___2 ;
  int ret___1 ;
  int retry ;
  long tmp___17 ;
  int usec___0 ;
  long tmp___18 ;
  float newms ;
  float tmp___19 ;
  int sofar___3 ;
  int ret___2 ;
  int retry___0 ;
  long tmp___20 ;
  int usec___1 ;
  long tmp___21 ;
  float newms___0 ;
  float tmp___22 ;
  float cachems ;
  float readms ;
  int readsize ;
  int retry___1 ;
  int ret___3 ;
  int tmp___23 ;
  int elapsed ;
  int sectors ;
  int spinner ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int total ;
  int elapsed___0 ;
  int sectors___0 ;
  int spinner___0 ;
  int retry___2 ;
  int ret___4 ;
  int seekpos ;
  long tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;

  {
#line 148
  ret = 0;
#line 149
  firstsector = -1;
#line 150
  lastsector = -1;
#line 151
  firsttest = -1;
#line 152
  lasttest = -1;
#line 154
  warn = 0;
#line 155
  current = 1000;
#line 156
  hi = 15000;
#line 157
  cachesize = 0;
#line 158
  readahead = 0;
#line 159
  rollbehind = 0;
#line 160
  cachegran = 0;
#line 161
  mspersector = (float )0;
#line 162
  if (speed <= 0) {
#line 162
    speed = -1;
  }
#line 164
  if (progress) {
    {
#line 164
    fprintf((FILE */* __restrict  */)progress, (char const   */* __restrict  */)"\n=================== Checking drive cache/timing behavior ===================\n");
    }
  }
#line 164
  if (log___0) {
    {
#line 164
    fprintf((FILE */* __restrict  */)log___0, (char const   */* __restrict  */)"\n=================== Checking drive cache/timing behavior ===================\n");
    }
  }
  {
#line 165
  d___0->error_retry = 0;
#line 168
  tmp = paranoia_version();
#line 168
  tmp___0 = strcmp("10.2", (char const   *)tmp);
  }
#line 168
  if (tmp___0) {
#line 169
    if (progress) {
      {
#line 169
      fprintf((FILE */* __restrict  */)progress, (char const   */* __restrict  */)"\nWARNING: cdparanoia application (and thus the cache tests) does not match the\ninstalled (or in use) libcdda_paranoia.so library.  The final verdict of this\ntesting may or may not be accurate for the actual version of the paranoialibrary.  Continuing anyway...\n\n");
      }
    }
#line 169
    if (log___0) {
      {
#line 169
      fprintf((FILE */* __restrict  */)log___0, (char const   */* __restrict  */)"\nWARNING: cdparanoia application (and thus the cache tests) does not match the\ninstalled (or in use) libcdda_paranoia.so library.  The final verdict of this\ntesting may or may not be accurate for the actual version of the paranoialibrary.  Continuing anyway...\n\n");
      }
    }
  }
#line 177
  i = 0;
  {
#line 177
  while (1) {
    while_continue: /* CIL Label */ ;
#line 177
    if (! (i < d___0->tracks)) {
#line 177
      goto while_break;
    }
    {
#line 178
    tmp___3 = cdda_track_audiop(d___0, i + 1);
    }
#line 178
    if (tmp___3 == 1) {
#line 179
      if (firsttest == -1) {
        {
#line 180
        tmp___1 = cdda_track_firstsector(d___0, i + 1);
#line 180
        firsttest = (int )tmp___1;
        }
      }
      {
#line 181
      tmp___2 = cdda_track_lastsector(d___0, i + 1);
#line 181
      lasttest = (int )tmp___2;
      }
#line 182
      if (lasttest - firsttest > lastsector - firstsector) {
#line 183
        firstsector = firsttest;
#line 184
        lastsector = lasttest;
      }
    } else {
#line 187
      firsttest = -1;
#line 188
      lasttest = -1;
    }
#line 177
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 192
  if (firstsector == -1) {
#line 193
    if (progress) {
      {
#line 193
      fprintf((FILE */* __restrict  */)progress, (char const   */* __restrict  */)"\n\tNo audio on disc; Cannot determine timing behavior...");
      }
    }
#line 193
    if (log___0) {
      {
#line 193
      fprintf((FILE */* __restrict  */)log___0, (char const   */* __restrict  */)"\n\tNo audio on disc; Cannot determine timing behavior...");
      }
    }
#line 194
    return (-1);
  }
#line 200
  best = 0;
#line 201
  bestcount = 0;
#line 202
  iterating = 0;
#line 204
  offset = ((lastsector - firstsector) - current) - 1;
#line 206
  if (progress) {
    {
#line 206
    fprintf((FILE */* __restrict  */)progress, (char const   */* __restrict  */)"\nSeek/read timing:\n");
    }
  }
#line 206
  if (log___0) {
    {
#line 206
    fprintf((FILE */* __restrict  */)log___0, (char const   */* __restrict  */)"\nSeek/read timing:\n");
    }
  }
  {
#line 208
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 208
    if (! (offset >= firstsector)) {
#line 208
      goto while_break___0;
    }
#line 209
    m = offset / 4500;
#line 210
    s = (offset - m * 4500) / 75;
#line 211
    f = (offset - m * 4500) - s * 75;
#line 214
    if (iterating) {
#line 215
      if (progress) {
        {
#line 215
        fprintf((FILE */* __restrict  */)progress, (char const   */* __restrict  */)"\n");
        }
      }
#line 215
      if (log___0) {
        {
#line 215
        fprintf((FILE */* __restrict  */)log___0, (char const   */* __restrict  */)"\n");
        }
      }
    } else {
#line 217
      if (progress) {
        {
#line 217
        fprintf((FILE */* __restrict  */)progress, (char const   */* __restrict  */)"\r");
        }
      }
#line 218
      if (log___0) {
        {
#line 218
        fprintf((FILE */* __restrict  */)log___0, (char const   */* __restrict  */)"\n");
        }
      }
    }
#line 220
    if (progress) {
      {
#line 220
      fprintf((FILE */* __restrict  */)progress, (char const   */* __restrict  */)"\t[%02d:%02d.%02d]: ",
              m, s, f);
      }
    }
#line 220
    if (log___0) {
      {
#line 220
      fprintf((FILE */* __restrict  */)log___0, (char const   */* __restrict  */)"\t[%02d:%02d.%02d]: ",
              m, s, f);
      }
    }
    {
#line 223
    tmp___4 = cdda_read(d___0, (void *)0, (long )((offset + current) + 1), 1L);
#line 223
    ret = (int )tmp___4;
    }
#line 223
    if (ret < 0) {
#line 225
      if (ret == -404) {
#line 225
        return (-1);
      }
#line 226
      if (progress) {
        {
#line 226
        fprintf((FILE */* __restrict  */)progress, (char const   */* __restrict  */)"\n\tWARNING: media error during read; continuing at next offset...");
        }
      }
#line 226
      if (log___0) {
        {
#line 226
        fprintf((FILE */* __restrict  */)log___0, (char const   */* __restrict  */)"\n\tWARNING: media error during read; continuing at next offset...");
        }
      }
#line 227
      offset = (((offset - firstsector) + 44999) / 45000) * 45000 + firstsector;
#line 228
      offset -= 45000;
#line 229
      goto while_continue___0;
    }
    {
#line 232
    sofar = time_drive(d___0, progress, log___0, offset, current, 1);
    }
#line 233
    if (offset == firstsector) {
#line 233
      mspersector = (float )sofar / (float )current;
    }
#line 234
    if (sofar == -404) {
#line 235
      return (-1);
    } else
#line 236
    if (sofar < 0) {
#line 237
      if (progress) {
        {
#line 237
        fprintf((FILE */* __restrict  */)progress, (char const   */* __restrict  */)"\n\tWARNING: media error during read; continuing at next offset...");
        }
      }
#line 237
      if (log___0) {
        {
#line 237
        fprintf((FILE */* __restrict  */)log___0, (char const   */* __restrict  */)"\n\tWARNING: media error during read; continuing at next offset...");
        }
      }
#line 238
      offset = (((offset - firstsector) + 44999) / 45000) * 45000 + firstsector;
#line 239
      offset -= 45000;
#line 240
      goto while_continue___0;
    } else
#line 242
    if (! iterating) {
#line 243
      if (best == 0) {
#line 244
        best = sofar;
#line 245
        bestcount = 0;
      } else
#line 243
      if ((double )sofar * 1.01 < (double )best) {
#line 244
        best = sofar;
#line 245
        bestcount = 0;
      } else {
#line 247
        bestcount += sofar;
#line 248
        if (bestcount > sofar) {
#line 248
          if (bestcount > 4000) {
#line 249
            iterating = 1;
          }
        }
      }
    }
#line 254
    if (iterating) {
#line 255
      offset = (((offset - firstsector) + 44999) / 45000) * 45000 + firstsector;
#line 256
      offset -= 45000;
#line 257
      if (progress) {
        {
#line 257
        fprintf((FILE */* __restrict  */)progress, (char const   */* __restrict  */)"                 ");
        }
      }
    } else {
#line 259
      offset --;
#line 260
      if (progress) {
        {
#line 260
        fprintf((FILE */* __restrict  */)progress, (char const   */* __restrict  */)" spinning up...  ");
        }
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 265
  if (progress) {
    {
#line 265
    fprintf((FILE */* __restrict  */)progress, (char const   */* __restrict  */)"\n\nAnalyzing cache behavior...\n");
    }
  }
#line 265
  if (log___0) {
    {
#line 265
    fprintf((FILE */* __restrict  */)log___0, (char const   */* __restrict  */)"\n\nAnalyzing cache behavior...\n");
    }
  }
#line 271
  under = 1;
#line 272
  onex = 0;
#line 273
  current = 0;
#line 274
  offset = firstsector + 10;
  {
#line 276
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 276
    if (current <= hi) {
#line 276
      if (! under) {
#line 276
        goto while_break___1;
      }
    } else {
#line 276
      goto while_break___1;
    }
#line 278
    under = 0;
#line 279
    current ++;
#line 281
    if (onex) {
#line 282
      if (speed == -1) {
#line 283
        if (log___0) {
          {
#line 283
          fprintf((FILE */* __restrict  */)log___0, (char const   */* __restrict  */)"\tAttempting to reset read speed to full... ");
          }
        }
      } else
#line 285
      if (log___0) {
        {
#line 285
        fprintf((FILE */* __restrict  */)log___0, (char const   */* __restrict  */)"\tAttempting to reset read speed to %dx... ",
                speed);
        }
      }
      {
#line 287
      tmp___5 = cdda_speed_set(d___0, speed);
      }
#line 287
      if (tmp___5) {
#line 288
        if (log___0) {
          {
#line 288
          fprintf((FILE */* __restrict  */)log___0, (char const   */* __restrict  */)"failed.\n");
          }
        }
      } else
#line 290
      if (log___0) {
        {
#line 290
        fprintf((FILE */* __restrict  */)log___0, (char const   */* __restrict  */)"drive said OK\n");
        }
      }
#line 292
      onex = 0;
    }
#line 295
    if (progress) {
      {
#line 295
      fprintf((FILE */* __restrict  */)progress, (char const   */* __restrict  */)"\r");
      }
    }
#line 296
    if (progress) {
      {
#line 296
      fprintf((FILE */* __restrict  */)progress, (char const   */* __restrict  */)"\tFast search for approximate cache size... %d sectors            ",
              current - 1);
      }
    }
#line 296
    if (log___0) {
      {
#line 296
      fprintf((FILE */* __restrict  */)log___0, (char const   */* __restrict  */)"\tFast search for approximate cache size... %d sectors            ",
              current - 1);
      }
    }
#line 297
    if (log___0) {
      {
#line 297
      fprintf((FILE */* __restrict  */)log___0, (char const   */* __restrict  */)"\n");
      }
    }
#line 299
    i___0 = 0;
    {
#line 299
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 299
      if (i___0 < 25) {
#line 299
        if (! (! under)) {
#line 299
          goto while_break___2;
        }
      } else {
#line 299
        goto while_break___2;
      }
#line 300
      j___0 = 0;
      {
#line 300
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 301
        ret1 = 0;
#line 301
        ret2 = 0;
#line 302
        if (i___0 >= 15) {
#line 303
          sofar___0 = 0;
#line 305
          if (i___0 == 15) {
#line 306
            if (progress) {
              {
#line 306
              fprintf((FILE */* __restrict  */)progress, (char const   */* __restrict  */)"\r");
              }
            }
#line 307
            if (progress) {
              {
#line 307
              fprintf((FILE */* __restrict  */)progress, (char const   */* __restrict  */)"\tSlow verify for approximate cache size... %d sectors",
                      current - 1);
              }
            }
#line 307
            if (log___0) {
              {
#line 307
              fprintf((FILE */* __restrict  */)log___0, (char const   */* __restrict  */)"\tSlow verify for approximate cache size... %d sectors",
                      current - 1);
              }
            }
#line 308
            if (log___0) {
              {
#line 308
              fprintf((FILE */* __restrict  */)log___0, (char const   */* __restrict  */)"\n");
              }
            }
#line 310
            if (log___0) {
              {
#line 310
              fprintf((FILE */* __restrict  */)log___0, (char const   */* __restrict  */)"\tAttempting to reduce read speed to 1x... ");
              }
            }
            {
#line 311
            tmp___6 = cdda_speed_set(d___0, 1);
            }
#line 311
            if (tmp___6) {
#line 312
              if (log___0) {
                {
#line 312
                fprintf((FILE */* __restrict  */)log___0, (char const   */* __restrict  */)"failed.\n");
                }
              }
            } else
#line 314
            if (log___0) {
              {
#line 314
              fprintf((FILE */* __restrict  */)log___0, (char const   */* __restrict  */)"drive said OK\n");
              }
            }
#line 316
            onex = 1;
          }
#line 318
          if (progress) {
            {
#line 318
            fprintf((FILE */* __restrict  */)progress, (char const   */* __restrict  */)".");
            }
          }
#line 319
          if (log___0) {
            {
#line 319
            fprintf((FILE */* __restrict  */)log___0, (char const   */* __restrict  */)"\t\t>>> ");
            }
          }
          {
#line 321
          while (1) {
            while_continue___4: /* CIL Label */ ;
#line 321
            if (! (sofar___0 < current)) {
#line 321
              goto while_break___4;
            }
            {
#line 322
            tmp___7 = cdda_read_timed(d___0, (void *)0, (long )(offset + sofar___0),
                                      (long )(current - sofar___0), & x);
#line 322
            ret1 = (int )tmp___7;
            }
#line 323
            if (log___0) {
              {
#line 323
              fprintf((FILE */* __restrict  */)log___0, (char const   */* __restrict  */)"slow_read=%d:%d:%d ",
                      offset + sofar___0, ret1, x);
              }
            }
#line 324
            if (ret1 <= 0) {
#line 324
              goto while_break___4;
            }
#line 325
            sofar___0 += ret1;
          }
          while_break___4: /* CIL Label */ ;
          }
        } else {
          {
#line 328
          tmp___8 = cdda_read_timed(d___0, (void *)0, (long )((offset + current) - 1),
                                    1L, & x);
#line 328
          ret1 = (int )tmp___8;
          }
#line 329
          if (log___0) {
            {
#line 329
            fprintf((FILE */* __restrict  */)log___0, (char const   */* __restrict  */)"\t\t>>> fast_read=%d:%d:%d ",
                    (offset + current) - 1, ret1, x);
            }
          }
#line 338
          if (ret == 1) {
#line 338
            if (i___0) {
#line 338
              if (x < 6) {
#line 339
                under = 1;
#line 340
                if (log___0) {
                  {
#line 340
                  fprintf((FILE */* __restrict  */)log___0, (char const   */* __restrict  */)"\n");
                  }
                }
#line 341
                goto while_break___3;
              }
            }
          }
        }
        {
#line 344
        tmp___9 = cdda_read_timed(d___0, (void *)0, (long )offset, 1L, & x);
#line 344
        ret2 = (int )tmp___9;
        }
#line 345
        if (log___0) {
          {
#line 345
          fprintf((FILE */* __restrict  */)log___0, (char const   */* __restrict  */)"seek_read=%d:%d:%d\n",
                  offset, ret2, x);
          }
        }
#line 347
        if (ret1 <= 0) {
#line 347
          goto _L___0;
        } else
#line 347
        if (ret2 <= 0) {
          _L___0: /* CIL Label */ 
#line 348
          offset += current + 100;
#line 349
          if (j___0 == 10) {
#line 349
            goto _L;
          } else
#line 349
          if (offset + current > lastsector) {
            _L: /* CIL Label */ 
#line 350
            if (progress) {
              {
#line 350
              fprintf((FILE */* __restrict  */)progress, (char const   */* __restrict  */)"\n\tToo many read errors while performing drive cache checks;\n\t  aborting test.\n\n");
              }
            }
#line 350
            if (log___0) {
              {
#line 350
              fprintf((FILE */* __restrict  */)log___0, (char const   */* __restrict  */)"\n\tToo many read errors while performing drive cache checks;\n\t  aborting test.\n\n");
              }
            }
#line 352
            return (-1);
          }
#line 354
          if (progress) {
            {
#line 354
            fprintf((FILE */* __restrict  */)progress, (char const   */* __restrict  */)"\n\tRead error while performing drive cache checks;\n\t  choosing new offset and trying again.\n");
            }
          }
#line 354
          if (log___0) {
            {
#line 354
            fprintf((FILE */* __restrict  */)log___0, (char const   */* __restrict  */)"\n\tRead error while performing drive cache checks;\n\t  choosing new offset and trying again.\n");
            }
          }
        } else
#line 357
        if (x == -1) {
#line 358
          if (progress) {
            {
#line 358
            fprintf((FILE */* __restrict  */)progress, (char const   */* __restrict  */)"\n\tTiming error while performing drive cache checks; aborting test.\n");
            }
          }
#line 358
          if (log___0) {
            {
#line 358
            fprintf((FILE */* __restrict  */)log___0, (char const   */* __restrict  */)"\n\tTiming error while performing drive cache checks; aborting test.\n");
            }
          }
#line 359
          return (-1);
        } else {
#line 361
          if (x < 6) {
#line 362
            under = 1;
          }
#line 364
          goto while_break___3;
        }
#line 300
        j___0 ++;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 299
      i___0 ++;
    }
    while_break___2: /* CIL Label */ ;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 371
  cachesize = current - 1;
#line 373
  if (progress) {
    {
#line 373
    fprintf((FILE */* __restrict  */)progress, (char const   */* __restrict  */)"\r");
    }
  }
#line 374
  if (cachesize == hi) {
#line 375
    if (progress) {
      {
#line 375
      fprintf((FILE */* __restrict  */)progress, (char const   */* __restrict  */)"\tWARNING: Cannot determine drive cache size or behavior!          \n");
      }
    }
#line 375
    if (log___0) {
      {
#line 375
      fprintf((FILE */* __restrict  */)log___0, (char const   */* __restrict  */)"\tWARNING: Cannot determine drive cache size or behavior!          \n");
      }
    }
#line 376
    return (1);
  } else
#line 377
  if (cachesize) {
#line 378
    if (progress) {
      {
#line 378
      fprintf((FILE */* __restrict  */)progress, (char const   */* __restrict  */)"\tApproximate random access cache size: %d sector(s)               \n",
              cachesize);
      }
    }
#line 378
    if (log___0) {
      {
#line 378
      fprintf((FILE */* __restrict  */)log___0, (char const   */* __restrict  */)"\tApproximate random access cache size: %d sector(s)               \n",
              cachesize);
      }
    }
  } else {
#line 380
    if (progress) {
      {
#line 380
      fprintf((FILE */* __restrict  */)progress, (char const   */* __restrict  */)"\tDrive does not cache nonlinear access                            \n");
      }
    }
#line 380
    if (log___0) {
      {
#line 380
      fprintf((FILE */* __restrict  */)log___0, (char const   */* __restrict  */)"\tDrive does not cache nonlinear access                            \n");
      }
    }
#line 381
    return (0);
  }
  {
#line 386
  tmp___10 = paranoia_init(d___0);
#line 386
  p___0 = tmp___10;
#line 387
  tmp___11 = paranoia_cachemodel_size(p___0, -1);
  }
#line 387
  if (cachesize > tmp___11) {
#line 388
    if (progress) {
      {
#line 388
      fprintf((FILE */* __restrict  */)progress, (char const   */* __restrict  */)"\nWARNING: This drive appears to be caching more sectors of\n           readahead than Paranoia can currently handle!\n");
      }
    }
#line 388
    if (log___0) {
      {
#line 388
      fprintf((FILE */* __restrict  */)log___0, (char const   */* __restrict  */)"\nWARNING: This drive appears to be caching more sectors of\n           readahead than Paranoia can currently handle!\n");
      }
    }
#line 390
    warn = 1;
  }
  {
#line 393
  paranoia_free(p___0);
  }
#line 395
  if (speed == -1) {
#line 396
    if (log___0) {
      {
#line 396
      fprintf((FILE */* __restrict  */)log___0, (char const   */* __restrict  */)"\tAttempting to reset read speed to full... ");
      }
    }
  } else
#line 398
  if (log___0) {
    {
#line 398
    fprintf((FILE */* __restrict  */)log___0, (char const   */* __restrict  */)"\tAttempting to reset read speed to %d... ",
            speed);
    }
  }
  {
#line 400
  tmp___12 = cdda_speed_set(d___0, speed);
  }
#line 400
  if (tmp___12) {
#line 401
    if (log___0) {
      {
#line 401
      fprintf((FILE */* __restrict  */)log___0, (char const   */* __restrict  */)"failed.\n");
      }
    }
  } else
#line 403
  if (log___0) {
    {
#line 403
    fprintf((FILE */* __restrict  */)log___0, (char const   */* __restrict  */)"drive said OK\n");
    }
  }
#line 410
  seekoff = cachesize * 3;
#line 411
  under___0 = 0;
#line 412
  if (progress) {
    {
#line 412
    fprintf((FILE */* __restrict  */)progress, (char const   */* __restrict  */)"\tVerifying that cache is contiguous...");
    }
  }
#line 412
  if (log___0) {
    {
#line 412
    fprintf((FILE */* __restrict  */)log___0, (char const   */* __restrict  */)"\tVerifying that cache is contiguous...");
    }
  }
#line 414
  i = 0;
  {
#line 414
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 414
    if (i < 20) {
#line 414
      if (! (! under___0)) {
#line 414
        goto while_break___5;
      }
    } else {
#line 414
      goto while_break___5;
    }
#line 415
    if (progress) {
      {
#line 415
      fprintf((FILE */* __restrict  */)progress, (char const   */* __restrict  */)".");
      }
    }
#line 416
    j = 0;
    {
#line 416
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 419
      if (offset + seekoff > lastsector) {
#line 420
        if (progress) {
          {
#line 420
          fprintf((FILE */* __restrict  */)progress, (char const   */* __restrict  */)"\n\tOut of readable space on CDROM while performing drive checks;\n\t  aborting test.\n\n");
          }
        }
#line 420
        if (log___0) {
          {
#line 420
          fprintf((FILE */* __restrict  */)log___0, (char const   */* __restrict  */)"\n\tOut of readable space on CDROM while performing drive checks;\n\t  aborting test.\n\n");
          }
        }
#line 422
        return (-1);
      }
      {
#line 426
      tmp___13 = cdda_read_timed(d___0, (void *)0, (long )(offset + seekoff), 1L,
                                 & x);
#line 426
      ret1___0 = (int )tmp___13;
      }
#line 427
      if (log___0) {
        {
#line 427
        fprintf((FILE */* __restrict  */)log___0, (char const   */* __restrict  */)"\t\t>>> %d:%d:%d ",
                offset + seekoff, ret1___0, x);
        }
      }
      {
#line 428
      tmp___14 = cdda_read_timed(d___0, (void *)0, (long )offset, 1L, & x);
#line 428
      ret2___0 = (int )tmp___14;
      }
#line 429
      if (log___0) {
        {
#line 429
        fprintf((FILE */* __restrict  */)log___0, (char const   */* __restrict  */)"seek_read:%d:%d:%d\n",
                offset, ret2___0, x);
        }
      }
#line 431
      if (ret1___0 <= 0) {
#line 431
        goto _L___1;
      } else
#line 431
      if (ret2___0 <= 0) {
        _L___1: /* CIL Label */ 
#line 432
        offset += cachesize + 100;
#line 433
        if (j == 10) {
#line 434
          if (progress) {
            {
#line 434
            fprintf((FILE */* __restrict  */)progress, (char const   */* __restrict  */)"\n\tToo many read errors while performing drive cache checks;\n\t  aborting test.\n\n");
            }
          }
#line 434
          if (log___0) {
            {
#line 434
            fprintf((FILE */* __restrict  */)log___0, (char const   */* __restrict  */)"\n\tToo many read errors while performing drive cache checks;\n\t  aborting test.\n\n");
            }
          }
#line 436
          return (-1);
        }
#line 438
        if (progress) {
          {
#line 438
          fprintf((FILE */* __restrict  */)progress, (char const   */* __restrict  */)"\n\tRead error while performing drive cache checks;\n\t  choosing new offset and trying again.\n");
          }
        }
#line 438
        if (log___0) {
          {
#line 438
          fprintf((FILE */* __restrict  */)log___0, (char const   */* __restrict  */)"\n\tRead error while performing drive cache checks;\n\t  choosing new offset and trying again.\n");
          }
        }
      } else
#line 441
      if (x == -1) {
#line 442
        if (progress) {
          {
#line 442
          fprintf((FILE */* __restrict  */)progress, (char const   */* __restrict  */)"\n\tTiming error while performing drive cache checks; aborting test.\n");
          }
        }
#line 442
        if (log___0) {
          {
#line 442
          fprintf((FILE */* __restrict  */)log___0, (char const   */* __restrict  */)"\n\tTiming error while performing drive cache checks; aborting test.\n");
          }
        }
#line 443
        return (-1);
      } else {
#line 445
        if (x < 6) {
#line 445
          under___0 = 1;
        }
#line 446
        goto while_break___6;
      }
#line 416
      j ++;
    }
    while_break___6: /* CIL Label */ ;
    }
#line 414
    i ++;
  }
  while_break___5: /* CIL Label */ ;
  }
#line 451
  if (progress) {
    {
#line 451
    fprintf((FILE */* __restrict  */)progress, (char const   */* __restrict  */)"\r");
    }
  }
#line 452
  if (under___0) {
#line 453
    if (progress) {
      {
#line 453
      fprintf((FILE */* __restrict  */)progress, (char const   */* __restrict  */)"\nWARNING: Drive cache does not appear to be contiguous!\n");
      }
    }
#line 453
    if (log___0) {
      {
#line 453
      fprintf((FILE */* __restrict  */)log___0, (char const   */* __restrict  */)"\nWARNING: Drive cache does not appear to be contiguous!\n");
      }
    }
#line 454
    warn = 1;
  } else {
#line 456
    if (progress) {
      {
#line 456
      fprintf((FILE */* __restrict  */)progress, (char const   */* __restrict  */)"\tDrive cache tests as contiguous                           \n");
      }
    }
#line 456
    if (log___0) {
      {
#line 456
      fprintf((FILE */* __restrict  */)log___0, (char const   */* __restrict  */)"\tDrive cache tests as contiguous                           \n");
      }
    }
  }
#line 475
  lower = 0;
#line 476
  gran = 64;
#line 477
  it = 3;
#line 478
  tests = 0;
#line 479
  under___1 = 1;
#line 480
  readahead = 0;
  {
#line 482
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 482
    if (! (gran > 1)) {
#line 482
      if (! under___1) {
#line 482
        goto while_break___7;
      }
    }
#line 483
    tests ++;
#line 484
    if (tests > 8) {
#line 484
      if (gran < 64) {
#line 485
        gran <<= 3;
#line 486
        tests = 0;
#line 487
        it = 3;
      }
    }
#line 489
    if (gran) {
#line 489
      if (! under___1) {
#line 490
        gran >>= 3;
#line 491
        tests = 0;
#line 492
        if (gran == 1) {
#line 492
          it = 10;
        }
      }
    }
#line 495
    under___1 = 0;
#line 496
    readahead = lower + gran;
#line 498
    if (progress) {
      {
#line 498
      fprintf((FILE */* __restrict  */)progress, (char const   */* __restrict  */)"\r");
      }
    }
#line 499
    if (log___0) {
      {
#line 499
      fprintf((FILE */* __restrict  */)log___0, (char const   */* __restrict  */)"\n");
      }
    }
#line 500
    if (progress) {
      {
#line 500
      fprintf((FILE */* __restrict  */)progress, (char const   */* __restrict  */)"\tTesting background readahead past read cursor... %d",
              readahead);
      }
    }
#line 500
    if (log___0) {
      {
#line 500
      fprintf((FILE */* __restrict  */)log___0, (char const   */* __restrict  */)"\tTesting background readahead past read cursor... %d",
              readahead);
      }
    }
#line 501
    if (progress) {
      {
#line 501
      fprintf((FILE */* __restrict  */)progress, (char const   */* __restrict  */)"           \b\b\b\b\b\b\b\b\b\b\b");
      }
    }
#line 502
    i = 0;
    {
#line 502
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 502
      if (! (i < it)) {
#line 502
        goto while_break___8;
      }
#line 503
      sofar___1 = 0;
#line 504
      if (log___0) {
        {
#line 504
        fprintf((FILE */* __restrict  */)log___0, (char const   */* __restrict  */)"\n\t\t%d >>> ",
                i);
        }
      }
      {
#line 506
      while (1) {
        while_continue___9: /* CIL Label */ ;
#line 506
        if (! (sofar___1 < cachesize)) {
#line 506
          goto while_break___9;
        }
        {
#line 507
        tmp___15 = cdda_read_timed(d___0, (void *)0, (long )(offset + sofar___1),
                                   (long )(cachesize - sofar___1), & x);
#line 507
        ret___0 = (int )tmp___15;
        }
#line 508
        if (ret___0 <= 0) {
#line 508
          goto error;
        }
#line 509
        if (log___0) {
          {
#line 509
          fprintf((FILE */* __restrict  */)log___0, (char const   */* __restrict  */)"%d:%d:%d ",
                  offset + sofar___1, ret___0, x);
          }
        }
#line 516
        sofar___1 += ret___0;
      }
      while_break___9: /* CIL Label */ ;
      }
#line 519
      if (progress) {
        {
#line 519
        fprintf((FILE */* __restrict  */)progress, (char const   */* __restrict  */)".");
        }
      }
#line 523
      usec = (int )(((mspersector * (float )readahead) * (float )(6 + i)) * (float )200);
#line 524
      max = 26000 * readahead;
#line 525
      if (usec > max) {
#line 525
        usec = max;
      }
#line 526
      if (log___0) {
        {
#line 526
        fprintf((FILE */* __restrict  */)log___0, (char const   */* __restrict  */)"sleep=%dus ",
                usec);
        }
      }
      {
#line 527
      usleep((__useconds_t )usec);
#line 531
      tmp___16 = cdda_read_timed(d___0, (void *)0, (long )(((offset + cachesize) + readahead) - 1),
                                 1L, & x);
#line 531
      ret___0 = (int )tmp___16;
      }
#line 532
      if (ret___0 <= 0) {
#line 532
        goto while_break___8;
      }
#line 533
      if (log___0) {
        {
#line 533
        fprintf((FILE */* __restrict  */)log___0, (char const   */* __restrict  */)"seek=%d:%d:%d",
                ((offset + cachesize) + readahead) - 1, ret___0, x);
        }
      }
#line 534
      if (x < 6) {
#line 535
        under___1 = 1;
#line 536
        goto while_break___8;
      } else
#line 537
      if (i % 3 == 1) {
        {
#line 539
        mspersector = retime_drive(d___0, progress, log___0, offset, readahead, mspersector);
        }
      }
#line 502
      i ++;
    }
    while_break___8: /* CIL Label */ ;
    }
#line 543
    if (under___1) {
#line 544
      lower = readahead;
    }
  }
  while_break___7: /* CIL Label */ ;
  }
#line 547
  readahead = lower;
#line 549
  if (log___0) {
    {
#line 549
    fprintf((FILE */* __restrict  */)log___0, (char const   */* __restrict  */)"\n");
    }
  }
#line 550
  if (progress) {
    {
#line 550
    fprintf((FILE */* __restrict  */)progress, (char const   */* __restrict  */)"\r");
    }
  }
#line 551
  if (readahead == 0) {
#line 552
    if (progress) {
      {
#line 552
      fprintf((FILE */* __restrict  */)progress, (char const   */* __restrict  */)"\tDrive does not read ahead past read cursor (very strange)     \n");
      }
    }
#line 552
    if (log___0) {
      {
#line 552
      fprintf((FILE */* __restrict  */)log___0, (char const   */* __restrict  */)"\tDrive does not read ahead past read cursor (very strange)     \n");
      }
    }
  } else {
#line 554
    if (progress) {
      {
#line 554
      fprintf((FILE */* __restrict  */)progress, (char const   */* __restrict  */)"\tDrive readahead past read cursor: %d sector(s)                \n",
              readahead);
      }
    }
#line 554
    if (log___0) {
      {
#line 554
      fprintf((FILE */* __restrict  */)log___0, (char const   */* __restrict  */)"\tDrive readahead past read cursor: %d sector(s)                \n",
              readahead);
      }
    }
  }
#line 557
  if (progress) {
    {
#line 557
    fprintf((FILE */* __restrict  */)progress, (char const   */* __restrict  */)"\tTesting cache tail cursor...");
    }
  }
#line 557
  if (log___0) {
    {
#line 557
    fprintf((FILE */* __restrict  */)log___0, (char const   */* __restrict  */)"\tTesting cache tail cursor...");
    }
  }
  {
#line 559
  while (1) {
    while_continue___10: /* CIL Label */ ;
#line 560
    rollbehind = cachesize;
#line 562
    i = 0;
    {
#line 562
    while (1) {
      while_continue___11: /* CIL Label */ ;
#line 562
      if (i < 10) {
#line 562
        if (! rollbehind) {
#line 562
          goto while_break___11;
        }
      } else {
#line 562
        goto while_break___11;
      }
#line 563
      sofar___2 = 0;
#line 563
      ret___1 = 0;
#line 563
      retry = 0;
#line 564
      if (log___0) {
        {
#line 564
        fprintf((FILE */* __restrict  */)log___0, (char const   */* __restrict  */)"\n\t\t>>> ");
        }
      }
#line 565
      if (progress) {
        {
#line 565
        fprintf((FILE */* __restrict  */)progress, (char const   */* __restrict  */)".");
        }
      }
      {
#line 566
      while (1) {
        while_continue___12: /* CIL Label */ ;
#line 566
        if (! (sofar___2 < cachesize)) {
#line 566
          goto while_break___12;
        }
        {
#line 567
        tmp___17 = cdda_read_timed(d___0, (void *)0, (long )(offset + sofar___2),
                                   (long )(cachesize - sofar___2), & x);
#line 567
        ret___1 = (int )tmp___17;
        }
#line 568
        if (ret___1 <= 0) {
#line 568
          goto error;
        }
#line 569
        if (log___0) {
          {
#line 569
          fprintf((FILE */* __restrict  */)log___0, (char const   */* __restrict  */)"%d:%d:%d ",
                  offset + sofar___2, ret___1, x);
          }
        }
#line 570
        sofar___2 += ret___1;
      }
      while_break___12: /* CIL Label */ ;
      }
#line 575
      usec___0 = (int )((mspersector * (float )readahead) * (float )1500);
#line 576
      if (log___0) {
        {
#line 576
        fprintf((FILE */* __restrict  */)log___0, (char const   */* __restrict  */)"\n\t\tsleeping %d microseconds",
                usec___0);
        }
      }
      {
#line 577
      usleep((__useconds_t )usec___0);
      }
#line 581
      if (log___0) {
        {
#line 581
        fprintf((FILE */* __restrict  */)log___0, (char const   */* __restrict  */)"\n\t\t<<< ");
        }
      }
#line 582
      sofar___2 = rollbehind;
      {
#line 583
      while (1) {
        while_continue___13: /* CIL Label */ ;
#line 583
        if (! (sofar___2 > 0)) {
#line 583
          goto while_break___13;
        }
        {
#line 584
        sofar___2 --;
#line 585
        tmp___18 = cdda_read_timed(d___0, (void *)0, (long )(offset + sofar___2),
                                   1L, & x);
#line 585
        ret___1 = (int )tmp___18;
        }
#line 586
        if (ret___1 <= 0) {
#line 586
          goto while_break___13;
        }
#line 587
        if (log___0) {
          {
#line 587
          fprintf((FILE */* __restrict  */)log___0, (char const   */* __restrict  */)"%d:%d:%d ",
                  sofar___2, ret___1, x);
          }
        }
#line 588
        if (x >= 6) {
#line 589
          if (rollbehind != sofar___2 + 1) {
#line 590
            rollbehind = sofar___2 + 1;
#line 591
            i = 0;
          } else {
#line 593
            i ++;
          }
#line 595
          goto while_break___13;
        }
#line 597
        if (sofar___2 == 0) {
#line 597
          rollbehind = 0;
        }
      }
      while_break___13: /* CIL Label */ ;
      }
      error: 
#line 601
      if (ret___1 <= 0) {
#line 602
        offset += cachesize;
#line 603
        retry ++;
#line 604
        if (retry > 10) {
#line 604
          goto _L___2;
        } else
#line 604
        if (offset + cachesize > lastsector) {
          _L___2: /* CIL Label */ 
#line 605
          if (progress) {
            {
#line 605
            fprintf((FILE */* __restrict  */)progress, (char const   */* __restrict  */)"\n\tToo many read errors while performing drive cache checks;\n\t  aborting test.\n\n");
            }
          }
#line 605
          if (log___0) {
            {
#line 605
            fprintf((FILE */* __restrict  */)log___0, (char const   */* __restrict  */)"\n\tToo many read errors while performing drive cache checks;\n\t  aborting test.\n\n");
            }
          }
#line 607
          return (-1);
        }
#line 609
        if (progress) {
          {
#line 609
          fprintf((FILE */* __restrict  */)progress, (char const   */* __restrict  */)"\n\tRead error while performing drive cache checks;\n\t  choosing new offset and trying again.\n");
          }
        }
#line 609
        if (log___0) {
          {
#line 609
          fprintf((FILE */* __restrict  */)log___0, (char const   */* __restrict  */)"\n\tRead error while performing drive cache checks;\n\t  choosing new offset and trying again.\n");
          }
        }
#line 611
        goto __Cont;
      }
      __Cont: /* CIL Label */ ;
    }
    while_break___11: /* CIL Label */ ;
    }
    {
#line 617
    tmp___19 = retime_drive(d___0, progress, log___0, offset, readahead, mspersector);
#line 617
    newms = tmp___19;
    }
#line 618
    if ((double )newms > (double )mspersector * 1.2) {
#line 619
      mspersector = newms;
#line 620
      if (progress) {
        {
#line 620
        fprintf((FILE */* __restrict  */)progress, (char const   */* __restrict  */)"\r");
        }
      }
#line 621
      if (progress) {
        {
#line 621
        fprintf((FILE */* __restrict  */)progress, (char const   */* __restrict  */)"\tDrive timing changed during test; retrying...");
        }
      }
#line 621
      if (log___0) {
        {
#line 621
        fprintf((FILE */* __restrict  */)log___0, (char const   */* __restrict  */)"\tDrive timing changed during test; retrying...");
        }
      }
#line 622
      goto while_continue___10;
    }
#line 625
    goto while_break___10;
  }
  while_break___10: /* CIL Label */ ;
  }
#line 629
  if (log___0) {
    {
#line 629
    fprintf((FILE */* __restrict  */)log___0, (char const   */* __restrict  */)"\n");
    }
  }
#line 630
  if (progress) {
    {
#line 630
    fprintf((FILE */* __restrict  */)progress, (char const   */* __restrict  */)"\r");
    }
  }
#line 631
  if (rollbehind == 0) {
#line 632
    if (progress) {
      {
#line 632
      fprintf((FILE */* __restrict  */)progress, (char const   */* __restrict  */)"\tCache tail cursor tied to read cursor                      \n");
      }
    }
#line 632
    if (log___0) {
      {
#line 632
      fprintf((FILE */* __restrict  */)log___0, (char const   */* __restrict  */)"\tCache tail cursor tied to read cursor                      \n");
      }
    }
  } else {
#line 634
    if (progress) {
      {
#line 634
      fprintf((FILE */* __restrict  */)progress, (char const   */* __restrict  */)"\tCache tail rollbehind: %d sector(s)                        \n",
              rollbehind);
      }
    }
#line 634
    if (log___0) {
      {
#line 634
      fprintf((FILE */* __restrict  */)log___0, (char const   */* __restrict  */)"\tCache tail rollbehind: %d sector(s)                        \n",
              rollbehind);
      }
    }
  }
#line 636
  if (progress) {
    {
#line 636
    fprintf((FILE */* __restrict  */)progress, (char const   */* __restrict  */)"\tTesting granularity of cache tail");
    }
  }
#line 636
  if (log___0) {
    {
#line 636
    fprintf((FILE */* __restrict  */)log___0, (char const   */* __restrict  */)"\tTesting granularity of cache tail");
    }
  }
  {
#line 638
  while (1) {
    while_continue___14: /* CIL Label */ ;
#line 639
    cachegran = cachesize + 1;
#line 640
    i = 0;
    {
#line 640
    while (1) {
      while_continue___15: /* CIL Label */ ;
#line 640
      if (i < 10) {
#line 640
        if (! cachegran) {
#line 640
          goto while_break___15;
        }
      } else {
#line 640
        goto while_break___15;
      }
#line 641
      sofar___3 = 0;
#line 641
      ret___2 = 0;
#line 641
      retry___0 = 0;
#line 642
      if (log___0) {
        {
#line 642
        fprintf((FILE */* __restrict  */)log___0, (char const   */* __restrict  */)"\n\t\t>>> ");
        }
      }
#line 643
      if (progress) {
        {
#line 643
        fprintf((FILE */* __restrict  */)progress, (char const   */* __restrict  */)".");
        }
      }
      {
#line 644
      while (1) {
        while_continue___16: /* CIL Label */ ;
#line 644
        if (! (sofar___3 < cachesize + 1)) {
#line 644
          goto while_break___16;
        }
        {
#line 645
        tmp___20 = cdda_read_timed(d___0, (void *)0, (long )(offset + sofar___3),
                                   (long )((cachesize - sofar___3) + 1), & x);
#line 645
        ret___2 = (int )tmp___20;
        }
#line 646
        if (ret___2 <= 0) {
#line 646
          goto error2;
        }
#line 647
        if (log___0) {
          {
#line 647
          fprintf((FILE */* __restrict  */)log___0, (char const   */* __restrict  */)"%d:%d:%d ",
                  offset + sofar___3, ret___2, x);
          }
        }
#line 648
        sofar___3 += ret___2;
      }
      while_break___16: /* CIL Label */ ;
      }
#line 653
      usec___1 = (int )((mspersector * (float )readahead) * (float )1500);
#line 654
      if (log___0) {
        {
#line 654
        fprintf((FILE */* __restrict  */)log___0, (char const   */* __restrict  */)"\n\t\tsleeping %d microseconds",
                usec___1);
        }
      }
      {
#line 655
      usleep((__useconds_t )usec___1);
      }
#line 659
      if (log___0) {
        {
#line 659
        fprintf((FILE */* __restrict  */)log___0, (char const   */* __restrict  */)"\n\t\t<<< ");
        }
      }
#line 660
      sofar___3 = cachegran;
      {
#line 661
      while (1) {
        while_continue___17: /* CIL Label */ ;
#line 661
        if (! sofar___3) {
#line 661
          goto while_break___17;
        }
        {
#line 662
        sofar___3 --;
#line 663
        tmp___21 = cdda_read_timed(d___0, (void *)0, (long )(offset + sofar___3),
                                   1L, & x);
#line 663
        ret___2 = (int )tmp___21;
        }
#line 664
        if (ret___2 <= 0) {
#line 664
          goto while_break___17;
        }
#line 665
        if (log___0) {
          {
#line 665
          fprintf((FILE */* __restrict  */)log___0, (char const   */* __restrict  */)"%d:%d:%d ",
                  offset + sofar___3, ret___2, x);
          }
        }
#line 666
        if (x >= 6) {
#line 667
          if (cachegran == sofar___3 + 1) {
#line 668
            i ++;
          } else {
#line 670
            cachegran = sofar___3 + 1;
#line 671
            i = 0;
          }
#line 673
          goto while_break___17;
        }
#line 675
        if (sofar___3 == 0) {
#line 675
          cachegran = 0;
        }
      }
      while_break___17: /* CIL Label */ ;
      }
      error2: 
#line 679
      if (ret___2 <= 0) {
#line 680
        offset += cachesize;
#line 681
        retry___0 ++;
#line 682
        if (retry___0 > 10) {
#line 682
          goto _L___3;
        } else
#line 682
        if (offset + cachesize > lastsector) {
          _L___3: /* CIL Label */ 
#line 683
          if (progress) {
            {
#line 683
            fprintf((FILE */* __restrict  */)progress, (char const   */* __restrict  */)"\n\tToo many read errors while performing drive cache checks;\n\t  aborting test.\n\n");
            }
          }
#line 683
          if (log___0) {
            {
#line 683
            fprintf((FILE */* __restrict  */)log___0, (char const   */* __restrict  */)"\n\tToo many read errors while performing drive cache checks;\n\t  aborting test.\n\n");
            }
          }
#line 685
          return (-1);
        }
#line 687
        if (progress) {
          {
#line 687
          fprintf((FILE */* __restrict  */)progress, (char const   */* __restrict  */)"\n\tRead error while performing drive cache checks;\n\t  choosing new offset and trying again.\n");
          }
        }
#line 687
        if (log___0) {
          {
#line 687
          fprintf((FILE */* __restrict  */)log___0, (char const   */* __restrict  */)"\n\tRead error while performing drive cache checks;\n\t  choosing new offset and trying again.\n");
          }
        }
#line 689
        goto __Cont___0;
      }
      __Cont___0: /* CIL Label */ ;
    }
    while_break___15: /* CIL Label */ ;
    }
    {
#line 695
    tmp___22 = retime_drive(d___0, progress, log___0, offset, readahead, mspersector);
#line 695
    newms___0 = tmp___22;
    }
#line 696
    if ((double )newms___0 > (double )mspersector * 1.2) {
#line 697
      mspersector = newms___0;
#line 698
      if (progress) {
        {
#line 698
        fprintf((FILE */* __restrict  */)progress, (char const   */* __restrict  */)"\r");
        }
      }
#line 699
      if (progress) {
        {
#line 699
        fprintf((FILE */* __restrict  */)progress, (char const   */* __restrict  */)"\tDrive timing changed during test; retrying...");
        }
      }
#line 699
      if (log___0) {
        {
#line 699
        fprintf((FILE */* __restrict  */)log___0, (char const   */* __restrict  */)"\tDrive timing changed during test; retrying...");
        }
      }
#line 700
      goto while_continue___14;
    }
#line 703
    goto while_break___14;
  }
  while_break___14: /* CIL Label */ ;
  }
#line 707
  cachegran -= rollbehind;
#line 709
  if (log___0) {
    {
#line 709
    fprintf((FILE */* __restrict  */)log___0, (char const   */* __restrict  */)"\n");
    }
  }
#line 710
  if (progress) {
    {
#line 710
    fprintf((FILE */* __restrict  */)progress, (char const   */* __restrict  */)"\r");
    }
  }
#line 711
  if (progress) {
    {
#line 711
    fprintf((FILE */* __restrict  */)progress, (char const   */* __restrict  */)"\tCache tail granularity: %d sector(s)                      \n",
            cachegran);
    }
  }
#line 711
  if (log___0) {
    {
#line 711
    fprintf((FILE */* __restrict  */)log___0, (char const   */* __restrict  */)"\tCache tail granularity: %d sector(s)                      \n",
            cachegran);
    }
  }
#line 733
  readsize = (cachesize - rollbehind) - 8;
#line 734
  retry___1 = 0;
#line 736
  if (readsize > cachesize - 1) {
#line 736
    readsize = cachesize - 1;
  }
#line 738
  if (readsize < 7) {
#line 739
    if (progress) {
      {
#line 739
      fprintf((FILE */* __restrict  */)progress, (char const   */* __restrict  */)"\tCache size (considering rollbehind) too small to test cache speed.\n");
      }
    }
#line 739
    if (log___0) {
      {
#line 739
      fprintf((FILE */* __restrict  */)log___0, (char const   */* __restrict  */)"\tCache size (considering rollbehind) too small to test cache speed.\n");
      }
    }
  } else {
#line 741
    if (progress) {
      {
#line 741
      fprintf((FILE */* __restrict  */)progress, (char const   */* __restrict  */)"\tTesting cache transfer speed...");
      }
    }
#line 741
    if (log___0) {
      {
#line 741
      fprintf((FILE */* __restrict  */)log___0, (char const   */* __restrict  */)"\tTesting cache transfer speed...");
      }
    }
    {
#line 753
    while (1) {
      while_continue___18: /* CIL Label */ ;
      {
#line 754
      tmp___23 = time_drive(d___0, (FILE *)((void *)0), log___0, offset, readsize,
                            0);
#line 754
      ret___3 = tmp___23;
      }
#line 755
      if (ret___3 == -404) {
#line 755
        return (-1);
      }
#line 756
      if (ret___3 > 0) {
#line 756
        goto while_break___18;
      }
#line 757
      retry___1 ++;
#line 758
      if (retry___1 == 10) {
#line 759
        if (progress) {
          {
#line 759
          fprintf((FILE */* __restrict  */)progress, (char const   */* __restrict  */)"\n\tToo many read errors while performing drive cache checks;\n\t  aborting test.\n\n");
          }
        }
#line 759
        if (log___0) {
          {
#line 759
          fprintf((FILE */* __restrict  */)log___0, (char const   */* __restrict  */)"\n\tToo many read errors while performing drive cache checks;\n\t  aborting test.\n\n");
          }
        }
#line 761
        return (-1);
      }
#line 763
      if (progress) {
        {
#line 763
        fprintf((FILE */* __restrict  */)progress, (char const   */* __restrict  */)"\n\tRead error while performing drive cache checks;\n\t  choosing new offset and trying again.\n");
        }
      }
#line 763
      if (log___0) {
        {
#line 763
        fprintf((FILE */* __restrict  */)log___0, (char const   */* __restrict  */)"\n\tRead error while performing drive cache checks;\n\t  choosing new offset and trying again.\n");
        }
      }
    }
    while_break___18: /* CIL Label */ ;
    }
#line 768
    elapsed = 0;
#line 769
    sectors = 0;
#line 770
    spinner = 0;
    {
#line 771
    while (1) {
      while_continue___19: /* CIL Label */ ;
#line 771
      if (! (elapsed < 5000)) {
#line 771
        goto while_break___19;
      }
      {
#line 772
      sectors += readsize;
#line 773
      tmp___24 = time_drive(d___0, (FILE *)((void *)0), log___0, offset, readsize,
                            0);
#line 773
      elapsed += tmp___24;
#line 774
      spinner = ((elapsed * 5) / 1000) % 4;
      }
#line 775
      if (progress) {
#line 775
        if (spinner == 0) {
#line 775
          tmp___27 = 'o';
        } else {
#line 775
          if (spinner == 1) {
#line 775
            tmp___26 = 'O';
          } else {
#line 775
            if (spinner == 2) {
#line 775
              tmp___25 = 'o';
            } else {
#line 775
              tmp___25 = '.';
            }
#line 775
            tmp___26 = tmp___25;
          }
#line 775
          tmp___27 = tmp___26;
        }
        {
#line 775
        fprintf((FILE */* __restrict  */)progress, (char const   */* __restrict  */)"\b%c",
                tmp___27);
        }
      }
    }
    while_break___19: /* CIL Label */ ;
    }
#line 777
    if (progress) {
      {
#line 777
      fprintf((FILE */* __restrict  */)progress, (char const   */* __restrict  */)"\r");
      }
    }
#line 778
    if (log___0) {
      {
#line 778
      fprintf((FILE */* __restrict  */)log___0, (char const   */* __restrict  */)"\n");
      }
    }
#line 779
    cachems = (float )elapsed / (float )sectors;
#line 780
    if (progress) {
      {
#line 780
      fprintf((FILE */* __restrict  */)progress, (char const   */* __restrict  */)"\t        Cache read speed: %.2fms/sector [%dx]\n",
              (double )cachems, (int )((1000. / 75.) / (double )cachems));
      }
    }
#line 780
    if (log___0) {
      {
#line 780
      fprintf((FILE */* __restrict  */)log___0, (char const   */* __restrict  */)"\t        Cache read speed: %.2fms/sector [%dx]\n",
              (double )cachems, (int )((1000. / 75.) / (double )cachems));
      }
    }
#line 784
    if (cachems * (float )3 > mspersector) {
#line 785
      if (progress) {
        {
#line 785
        fprintf((FILE */* __restrict  */)progress, (char const   */* __restrict  */)"\tCache access insufficiently faster than media access to\n\t\tperform cache backseek tests\n\n");
        }
      }
#line 785
      if (log___0) {
        {
#line 785
        fprintf((FILE */* __restrict  */)log___0, (char const   */* __restrict  */)"\tCache access insufficiently faster than media access to\n\t\tperform cache backseek tests\n\n");
        }
      }
    } else {
#line 790
      if (progress) {
        {
#line 790
        fprintf((FILE */* __restrict  */)progress, (char const   */* __restrict  */)"\tTesting that backseek flushes cache...");
        }
      }
#line 790
      if (log___0) {
        {
#line 790
        fprintf((FILE */* __restrict  */)log___0, (char const   */* __restrict  */)"\tTesting that backseek flushes cache...");
        }
      }
#line 792
      total = 0;
#line 793
      elapsed___0 = 0;
#line 794
      sectors___0 = 0;
#line 795
      spinner___0 = 0;
#line 796
      retry___2 = 0;
      {
#line 797
      while (1) {
        while_continue___20: /* CIL Label */ ;
#line 797
        if (elapsed___0 < 5000) {
#line 797
          if (! (total < 25)) {
#line 797
            goto while_break___20;
          }
        } else {
#line 797
          goto while_break___20;
        }
        {
#line 799
        while (1) {
          while_continue___21: /* CIL Label */ ;
#line 801
          seekpos = (offset + cachesize) + 20000;
#line 802
          if (seekpos > lastsector - 150) {
#line 802
            seekpos = lastsector - 150;
          }
          {
#line 803
          tmp___28 = cdda_read(d___0, (void *)0, (long )seekpos, 1L);
#line 803
          ret___4 = (int )tmp___28;
          }
#line 804
          if (ret___4 > 0) {
            {
#line 804
            ret___4 = time_drive(d___0, (FILE *)((void *)0), log___0, offset + 1,
                                 readsize, 1);
            }
          }
#line 805
          if (ret___4 >= 0) {
            {
#line 805
            ret___4 = time_drive(d___0, (FILE *)((void *)0), log___0, offset, readsize,
                                 1);
            }
          }
#line 807
          if (ret___4 <= 0) {
#line 808
            retry___2 ++;
#line 809
            if (retry___2 == 10) {
#line 810
              if (progress) {
                {
#line 810
                fprintf((FILE */* __restrict  */)progress, (char const   */* __restrict  */)"\n\tToo many read errors while performing drive cache checks;\n\t  aborting test.\n\n");
                }
              }
#line 810
              if (log___0) {
                {
#line 810
                fprintf((FILE */* __restrict  */)log___0, (char const   */* __restrict  */)"\n\tToo many read errors while performing drive cache checks;\n\t  aborting test.\n\n");
                }
              }
#line 812
              return (-1);
            }
#line 814
            if (progress) {
              {
#line 814
              fprintf((FILE */* __restrict  */)progress, (char const   */* __restrict  */)"\n\tRead error while performing drive cache checks; retrying...");
              }
            }
#line 814
            if (log___0) {
              {
#line 814
              fprintf((FILE */* __restrict  */)log___0, (char const   */* __restrict  */)"\n\tRead error while performing drive cache checks; retrying...");
              }
            }
          } else {
#line 816
            goto while_break___21;
          }
        }
        while_break___21: /* CIL Label */ ;
        }
#line 819
        sectors___0 += readsize - 1;
#line 820
        elapsed___0 += ret___4;
#line 821
        total ++;
#line 823
        spinner___0 = ((elapsed___0 * 5) / 1000) % 4;
#line 824
        if (progress) {
#line 824
          if (spinner___0 == 0) {
#line 824
            tmp___31 = 'o';
          } else {
#line 824
            if (spinner___0 == 1) {
#line 824
              tmp___30 = 'O';
            } else {
#line 824
              if (spinner___0 == 2) {
#line 824
                tmp___29 = 'o';
              } else {
#line 824
                tmp___29 = '.';
              }
#line 824
              tmp___30 = tmp___29;
            }
#line 824
            tmp___31 = tmp___30;
          }
          {
#line 824
          fprintf((FILE */* __restrict  */)progress, (char const   */* __restrict  */)"\b%c",
                  tmp___31);
          }
        }
      }
      while_break___20: /* CIL Label */ ;
      }
#line 827
      if (progress) {
        {
#line 827
        fprintf((FILE */* __restrict  */)progress, (char const   */* __restrict  */)"\r");
        }
      }
#line 828
      if (log___0) {
        {
#line 828
        fprintf((FILE */* __restrict  */)log___0, (char const   */* __restrict  */)"\n");
        }
      }
#line 829
      readms = (float )elapsed___0 / (float )sectors___0;
#line 830
      if (progress) {
        {
#line 830
        fprintf((FILE */* __restrict  */)progress, (char const   */* __restrict  */)"\t        Access speed after backseek: %.2fms/sector [%dx]\n",
                (double )readms, (int )((1000. / 75.) / (double )readms));
        }
      }
#line 830
      if (log___0) {
        {
#line 830
        fprintf((FILE */* __restrict  */)log___0, (char const   */* __restrict  */)"\t        Access speed after backseek: %.2fms/sector [%dx]\n",
                (double )readms, (int )((1000. / 75.) / (double )readms));
        }
      }
#line 832
      if ((double )readms * 2. < (double )mspersector) {
#line 832
        goto _L___4;
      } else
#line 832
      if ((double )cachems * 2. > (double )readms) {
        _L___4: /* CIL Label */ 
#line 834
        if (progress) {
          {
#line 834
          fprintf((FILE */* __restrict  */)progress, (char const   */* __restrict  */)"\tWARNING: Read timing after backseek faster than expected!\n\t         It\'s possible/likely that this drive is not\n\t         flushing the readahead cache on backward seeks!\n\n");
          }
        }
#line 834
        if (log___0) {
          {
#line 834
          fprintf((FILE */* __restrict  */)log___0, (char const   */* __restrict  */)"\tWARNING: Read timing after backseek faster than expected!\n\t         It\'s possible/likely that this drive is not\n\t         flushing the readahead cache on backward seeks!\n\n");
          }
        }
#line 837
        warn = 1;
      } else {
#line 839
        if (progress) {
          {
#line 839
          fprintf((FILE */* __restrict  */)progress, (char const   */* __restrict  */)"\tBackseek flushes the cache as expected\n");
          }
        }
#line 839
        if (log___0) {
          {
#line 839
          fprintf((FILE */* __restrict  */)log___0, (char const   */* __restrict  */)"\tBackseek flushes the cache as expected\n");
          }
        }
      }
    }
  }
#line 849
  return (warn);
}
}
#line 125 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/utils.h"
static void cdmessage___4(cdrom_drive *d___0 , char const   *s ) 
{ 
  size_t tmp ;

  {
#line 126
  if (s) {
#line 126
    if (d___0) {
      {
#line 128
      if (d___0->messagedest == 1) {
#line 128
        goto case_1;
      }
#line 131
      if (d___0->messagedest == 2) {
#line 131
        goto case_2;
      }
#line 135
      goto switch_default;
      case_1: /* CIL Label */ 
      {
#line 129
      tmp = strlen(s);
#line 129
      write(2, (void const   *)s, tmp);
      }
#line 130
      goto switch_break;
      case_2: /* CIL Label */ 
      {
#line 132
      d___0->messagebuf = catstring(d___0->messagebuf, s);
      }
#line 133
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 136
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
  }
#line 139
  return;
}
}
#line 109 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/utils.h"
static void cderror___6(cdrom_drive *d___0 , char const   *s ) 
{ 
  size_t tmp ;

  {
#line 110
  if (s) {
#line 110
    if (d___0) {
      {
#line 112
      if (d___0->errordest == 1) {
#line 112
        goto case_1;
      }
#line 115
      if (d___0->errordest == 2) {
#line 115
        goto case_2;
      }
#line 119
      goto switch_default;
      case_1: /* CIL Label */ 
      {
#line 113
      tmp = strlen(s);
#line 113
      write(2, (void const   *)s, tmp);
      }
#line 114
      goto switch_break;
      case_2: /* CIL Label */ 
      {
#line 116
      d___0->errorbuf = catstring(d___0->errorbuf, s);
      }
#line 117
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 120
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
  }
#line 123
  return;
}
}
#line 11 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/utils.h"
long buffering_write(int fd , char *buffer , long num ) ;
#line 12
int buffering_close(int fd ) ;
#line 12 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/buffering_write.c"
long blocking_write(int outf , char *buffer , long num ) ;
#line 16 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/buffering_write.c"
static int bw_fd  =    -1;
#line 17 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/buffering_write.c"
static long bw_pos  =    0L;
#line 18 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/buffering_write.c"
static char bw_outbuf[32768]  ;
#line 27 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/buffering_write.c"
long buffering_write(int fd , char *buffer , long num ) 
{ 
  long tmp ;
  long tmp___0 ;

  {
#line 29
  if (fd != bw_fd) {
#line 31
    if (bw_fd >= 0) {
#line 31
      if (bw_pos > 0L) {
        {
#line 32
        tmp = blocking_write(bw_fd, bw_outbuf, bw_pos);
        }
#line 32
        if (tmp) {
          {
#line 33
          perror("write (in buffering_write, flushing)");
          }
        }
      }
    }
#line 36
    bw_fd = fd;
#line 37
    bw_pos = 0L;
  }
#line 40
  if (bw_pos + num > 32768L) {
    {
#line 42
    memcpy((void */* __restrict  */)(& bw_outbuf[bw_pos]), (void const   */* __restrict  */)buffer,
           (size_t )(32768L - bw_pos));
#line 43
    tmp___0 = blocking_write(fd, bw_outbuf, 32768L);
    }
#line 43
    if (tmp___0) {
      {
#line 44
      perror("write (in buffering_write, full buffer)");
      }
#line 45
      return (-1L);
    }
#line 47
    num -= 32768L - bw_pos;
#line 48
    buffer += 32768L - bw_pos;
#line 49
    bw_pos = 0L;
  }
#line 52
  if (buffer) {
#line 52
    if (num) {
      {
#line 53
      memcpy((void */* __restrict  */)(& bw_outbuf[bw_pos]), (void const   */* __restrict  */)buffer,
             (size_t )num);
      }
    }
  }
#line 54
  bw_pos += num;
#line 56
  return (0L);
}
}
#line 63 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/buffering_write.c"
int buffering_close(int fd ) 
{ 
  long tmp ;
  int tmp___0 ;

  {
#line 65
  if (fd == bw_fd) {
#line 65
    if (bw_pos > 0L) {
      {
#line 67
      tmp = blocking_write(fd, bw_outbuf, bw_pos);
      }
#line 67
      if (tmp) {
        {
#line 68
        perror("write (in buffering_close)");
        }
      }
#line 70
      bw_fd = -1;
#line 71
      bw_pos = 0L;
    }
  }
  {
#line 73
  tmp___0 = close(fd);
  }
#line 73
  return (tmp___0);
}
}
#line 775 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) abs)(int __x )  __attribute__((__const__)) ;
#line 12 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/paranoia/overlap.h"
void offset_adjust_settings(cdrom_paranoia *p___0 , void (*callback___0)(long  , int  ) ) ;
#line 19 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/paranoia/overlap.c"
void paranoia_resetcache(cdrom_paranoia *p___0 ) 
{ 
  c_block *c ;
  c_block *tmp ;
  v_fragment *v ;

  {
  {
#line 20
  tmp = c_first(p___0);
#line 20
  c = tmp;
  }
  {
#line 23
  while (1) {
    while_continue: /* CIL Label */ ;
#line 23
    if (! c) {
#line 23
      goto while_break;
    }
    {
#line 24
    free_c_block(c);
#line 25
    c = c_first(p___0);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 28
  v = v_first(p___0);
  }
  {
#line 29
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 29
    if (! v) {
#line 29
      goto while_break___0;
    }
    {
#line 30
    free_v_fragment(v);
#line 31
    v = v_first(p___0);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 33
  return;
}
}
#line 35 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/paranoia/overlap.c"
void paranoia_resetall(cdrom_paranoia *p___0 ) 
{ 


  {
#line 36
  p___0->root.returnedlimit = 0L;
#line 37
  p___0->dyndrift = 0L;
#line 38
  p___0->root.lastsector = 0L;
#line 40
  if (p___0->root.vector) {
    {
#line 41
    i_cblock_destructor(p___0->root.vector);
#line 42
    p___0->root.vector = (c_block *)((void *)0);
    }
  }
  {
#line 45
  paranoia_resetcache(p___0);
  }
#line 46
  return;
}
}
#line 48 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/paranoia/overlap.c"
void i_paranoia_trim(cdrom_paranoia *p___0 , long beginword , long endword ) 
{ 
  root_block *root ;
  long target ;
  long rbegin ;
  long rend ;
  long offset ;
  c_block *c ;
  c_block *tmp ;
  c_block *next ;
  c_block *tmp___0 ;

  {
#line 49
  root = & p___0->root;
#line 50
  if ((unsigned long )root->vector != (unsigned long )((void *)0)) {
#line 51
    target = beginword - 37632L;
#line 52
    rbegin = (root->vector)->begin;
#line 53
    rend = (root->vector)->begin + (root->vector)->size;
#line 55
    if (rbegin > beginword) {
#line 56
      goto rootfree;
    }
#line 58
    if (rbegin + 37632L < beginword) {
#line 59
      if (target + 64L > rend) {
#line 60
        goto rootfree;
      }
      {
#line 63
      offset = target - rbegin;
#line 64
      c_removef(root->vector, offset);
      }
    }
    {
#line 69
    tmp = c_first(p___0);
#line 69
    c = tmp;
    }
    {
#line 70
    while (1) {
      while_continue: /* CIL Label */ ;
#line 70
      if (! c) {
#line 70
        goto while_break;
      }
      {
#line 71
      tmp___0 = c_next(c);
#line 71
      next = tmp___0;
      }
#line 72
      if (c->begin + c->size < beginword - 37632L) {
        {
#line 73
        free_c_block(c);
        }
      }
#line 74
      c = next;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 79
  return;
  rootfree: 
  {
#line 83
  i_cblock_destructor(root->vector);
#line 84
  root->vector = (c_block *)((void *)0);
#line 85
  root->returnedlimit = -1L;
#line 86
  root->lastsector = 0L;
  }
#line 88
  return;
}
}
#line 104 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/paranoia/overlap.c"
void offset_adjust_settings(cdrom_paranoia *p___0 , void (*callback___0)(long  , int  ) ) 
{ 
  long av ;
  long tmp ;
  c_block *c ;
  c_block *tmp___0 ;
  v_fragment *v ;
  v_fragment *tmp___1 ;
  long adj ;
  long tmp___2 ;
  int tmp___3 ;

  {
#line 105
  if (p___0->stage2.offpoints >= 10L) {
#line 108
    if (p___0->stage2.offpoints) {
#line 108
      tmp = p___0->stage2.offaccum / p___0->stage2.offpoints;
    } else {
#line 108
      tmp = 0L;
    }
    {
#line 108
    av = tmp;
#line 110
    tmp___3 = abs((int )av);
    }
#line 110
    if ((long )tmp___3 > p___0->dynoverlap / 4L) {
#line 111
      av = (av / 128L) * 128L;
#line 113
      if (callback___0) {
        {
#line 113
        (*callback___0)((p___0->root.vector)->begin + (p___0->root.vector)->size,
                        7);
        }
      }
      {
#line 114
      p___0->dyndrift += av;
#line 119
      tmp___0 = c_first(p___0);
#line 119
      c = tmp___0;
#line 120
      tmp___1 = v_first(p___0);
#line 120
      v = tmp___1;
      }
      {
#line 122
      while (1) {
        while_continue: /* CIL Label */ ;
#line 122
        if (v) {
#line 122
          if (! v->one) {
#line 122
            goto while_break;
          }
        } else {
#line 122
          goto while_break;
        }
#line 124
        if (v->begin < av) {
#line 125
          v->one = (c_block *)((void *)0);
        } else
#line 124
        if ((v->one)->begin < av) {
#line 125
          v->one = (c_block *)((void *)0);
        } else {
#line 127
          v->begin -= av;
        }
        {
#line 129
        v = v_next(v);
        }
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 131
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 131
        if (! c) {
#line 131
          goto while_break___0;
        }
#line 132
        if (av > c->begin) {
#line 132
          tmp___2 = c->begin;
        } else {
#line 132
          tmp___2 = av;
        }
        {
#line 132
        adj = tmp___2;
#line 133
        c_set(c, c->begin - adj);
#line 134
        c = c_next(c);
        }
      }
      while_break___0: /* CIL Label */ ;
      }
#line 138
      p___0->stage2.offaccum = 0L;
#line 139
      p___0->stage2.offmin = 0L;
#line 140
      p___0->stage2.offmax = 0L;
#line 141
      p___0->stage2.offpoints = 0L;
#line 142
      p___0->stage2.newpoints = 0L;
#line 143
      p___0->stage2.offdiff = 0L;
    }
  }
#line 147
  if (p___0->stage1.offpoints >= 10L) {
#line 151
    if (p___0->stage1.offpoints) {
#line 151
      p___0->dynoverlap = (p___0->stage1.offdiff / p___0->stage1.offpoints) * 3L;
    } else {
#line 151
      p___0->dynoverlap = 1176L;
    }
#line 154
    if ((double )p___0->dynoverlap < (double )(- p___0->stage1.offmin) * 1.5) {
#line 155
      p___0->dynoverlap = (long )((double )(- p___0->stage1.offmin) * 1.5);
    }
#line 157
    if ((double )p___0->dynoverlap < (double )p___0->stage1.offmax * 1.5) {
#line 158
      p___0->dynoverlap = (long )((double )p___0->stage1.offmax * 1.5);
    }
#line 160
    if (p___0->dynoverlap < 128L) {
#line 160
      p___0->dynoverlap = 128L;
    }
#line 161
    if (p___0->dynoverlap > 37632L) {
#line 162
      p___0->dynoverlap = 37632L;
    }
#line 164
    if (callback___0) {
      {
#line 164
      (*callback___0)(p___0->dynoverlap, 9);
      }
    }
#line 166
    if (p___0->stage1.offpoints > 600L) {
#line 169
      p___0->stage1.offpoints = (long )((double )p___0->stage1.offpoints / 1.2);
#line 170
      p___0->stage1.offaccum = (long )((double )p___0->stage1.offaccum / 1.2);
#line 171
      p___0->stage1.offdiff = (long )((double )p___0->stage1.offdiff / 1.2);
    }
#line 173
    p___0->stage1.offmin = 0L;
#line 174
    p___0->stage1.offmax = 0L;
#line 175
    p___0->stage1.newpoints = 0L;
  }
#line 177
  return;
}
}
#line 205 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/paranoia/overlap.c"
void offset_add_value(cdrom_paranoia *p___0 , offsets *o , long value , void (*callback___0)(long  ,
                                                                                             int  ) ) 
{ 
  int tmp ;

  {
#line 207
  if (o->offpoints != -1L) {
    {
#line 210
    tmp = abs((int )value);
#line 210
    o->offdiff += (long )tmp;
#line 211
    (o->offpoints) ++;
#line 212
    (o->newpoints) ++;
#line 215
    o->offaccum += value;
    }
#line 218
    if (value < o->offmin) {
#line 218
      o->offmin = value;
    }
#line 219
    if (value > o->offmax) {
#line 219
      o->offmax = value;
    }
#line 222
    if (o->newpoints >= 10L) {
      {
#line 222
      offset_adjust_settings(p___0, callback___0);
      }
    }
  }
#line 224
  return;
}
}
#line 169 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 237
extern int fclose(FILE *__stream ) ;
#line 242
extern int fflush(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 386
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 573
extern int fputc(int __c , FILE *__stream ) ;
#line 858
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) fileno)(FILE *__stream ) ;
#line 147 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 519
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atexit)(void (*__func)(void) ) ;
#line 675 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __uid_t ( __attribute__((__leaf__)) getuid)(void) ;
#line 681
extern  __attribute__((__nothrow__)) __gid_t ( __attribute__((__leaf__)) getgid)(void) ;
#line 710
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) seteuid)(__uid_t __uid ) ;
#line 727
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setegid)(__gid_t __gid ) ;
#line 779
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) isatty)(int __fd ) ;
#line 826
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) unlink)(char const   *__name ) ;
#line 57 "/usr/include/getopt.h"
extern char *optarg ;
#line 71
extern int optind ;
#line 289 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1,2), __leaf__)) strspn)(char const   *__s ,
                                                                                                  char const   *__accept )  __attribute__((__pure__)) ;
#line 173 "/usr/include/getopt.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getopt_long)(int ___argc ,
                                                                                  char * const  *___argv ,
                                                                                  char const   *__shortopts ,
                                                                                  struct option  const  *__longopts ,
                                                                                  int *__longind ) ;
#line 71 "/usr/include/x86_64-linux-gnu/sys/time.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) gettimeofday)(struct timeval * __restrict  __tv ,
                                                                                                   __timezone_ptr_t __tz ) ;
#line 91 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/utils.h"
__inline static char *copystring___3(char const   *s ) 
{ 
  char *ret ;
  size_t tmp ;
  void *tmp___0 ;

  {
#line 92
  if (s) {
    {
#line 93
    tmp = strlen(s);
#line 93
    tmp___0 = malloc((tmp + 1UL) * sizeof(char ));
#line 93
    ret = (char *)tmp___0;
#line 94
    strcpy((char */* __restrict  */)ret, (char const   */* __restrict  */)s);
    }
#line 95
    return (ret);
  }
#line 97
  return ((char *)((void *)0));
}
}
#line 43 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/main.c"
static long parse_offset(cdrom_drive *d___0 , char *offset , int begin ) 
{ 
  long track ;
  long hours ;
  long minutes ;
  long seconds ;
  long sectors ;
  char *time ;
  char *temp ;
  long ret ;
  int chars ;
  size_t tmp ;
  int tmp___0 ;
  long val ;
  long chars___0 ;
  char *sec ;
  char *tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;
  long tmp___4 ;
  long tmp___5 ;
  int tmp___6 ;
  long tmp___7 ;

  {
#line 44
  track = -1L;
#line 45
  hours = -1L;
#line 46
  minutes = -1L;
#line 47
  seconds = -1L;
#line 48
  sectors = -1L;
#line 49
  time = (char *)((void *)0);
#line 49
  temp = (char *)((void *)0);
#line 52
  if ((unsigned long )offset == (unsigned long )((void *)0)) {
#line 52
    return (-1L);
  }
  {
#line 55
  temp = strchr((char const   *)offset, ']');
  }
#line 56
  if (temp) {
    {
#line 57
    *temp = (char )'\000';
#line 58
    temp = strchr((char const   *)offset, '[');
    }
#line 59
    if ((unsigned long )temp == (unsigned long )((void *)0)) {
#line 60
      if (! quiet) {
        {
#line 60
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error parsing span argument");
#line 60
        fputc('\n', stderr);
        }
      }
#line 60
      if (reportfile) {
        {
#line 60
        fprintf((FILE */* __restrict  */)reportfile, (char const   */* __restrict  */)"Error parsing span argument");
#line 60
        fputc('\n', reportfile);
        }
      }
      {
#line 61
      exit(1);
      }
    }
#line 63
    *temp = (char )'\000';
#line 64
    time = temp + 1;
  }
  {
#line 69
  tmp = strspn((char const   *)offset, "0123456789");
#line 69
  chars = (int )tmp;
  }
#line 70
  if (chars > 0) {
    {
#line 71
    *(offset + chars) = (char )'\000';
#line 72
    tmp___0 = atoi((char const   *)offset);
#line 72
    track = (long )tmp___0;
    }
#line 73
    if (track < 0L) {
#line 73
      goto _L;
    } else
#line 73
    if (track > (long )d___0->tracks) {
      _L: /* CIL Label */ 
#line 74
      if (! quiet) {
        {
#line 74
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Track #%ld does not exist.",
                track);
#line 74
        fputc('\n', stderr);
        }
      }
#line 74
      if (reportfile) {
        {
#line 74
        fprintf((FILE */* __restrict  */)reportfile, (char const   */* __restrict  */)"Track #%ld does not exist.",
                track);
#line 74
        fputc('\n', reportfile);
        }
      }
      {
#line 75
      exit(1);
      }
    }
  }
  {
#line 80
  while (1) {
    while_continue: /* CIL Label */ ;
#line 80
    if (! time) {
#line 80
      goto while_break;
    }
    {
#line 82
    tmp___1 = strrchr((char const   *)time, '.');
#line 82
    sec = tmp___1;
    }
#line 83
    if (! sec) {
      {
#line 83
      sec = strrchr((char const   *)time, ':');
      }
    }
#line 84
    if (! sec) {
#line 84
      sec = time - 1;
    }
    {
#line 86
    tmp___2 = strspn((char const   *)(sec + 1), "0123456789");
#line 86
    chars___0 = (long )tmp___2;
    }
#line 87
    if (chars___0) {
      {
#line 88
      tmp___3 = atoi((char const   *)(sec + 1));
#line 88
      val = (long )tmp___3;
      }
    } else {
#line 90
      val = 0L;
    }
    {
#line 93
    if ((int )*sec == 46) {
#line 93
      goto case_46;
    }
#line 100
    goto switch_default;
    case_46: /* CIL Label */ 
#line 94
    if (sectors != -1L) {
#line 95
      if (! quiet) {
        {
#line 95
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error parsing span argument");
#line 95
        fputc('\n', stderr);
        }
      }
#line 95
      if (reportfile) {
        {
#line 95
        fprintf((FILE */* __restrict  */)reportfile, (char const   */* __restrict  */)"Error parsing span argument");
#line 95
        fputc('\n', reportfile);
        }
      }
      {
#line 96
      exit(1);
      }
    }
#line 98
    sectors = val;
#line 99
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 101
    if (seconds == -1L) {
#line 102
      seconds = val;
    } else
#line 104
    if (minutes == -1L) {
#line 105
      minutes = val;
    } else
#line 107
    if (hours == -1L) {
#line 108
      hours = val;
    } else {
#line 110
      if (! quiet) {
        {
#line 110
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error parsing span argument");
#line 110
        fputc('\n', stderr);
        }
      }
#line 110
      if (reportfile) {
        {
#line 110
        fprintf((FILE */* __restrict  */)reportfile, (char const   */* __restrict  */)"Error parsing span argument");
#line 110
        fputc('\n', reportfile);
        }
      }
      {
#line 111
      exit(1);
      }
    }
#line 113
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 116
    if ((unsigned long )sec <= (unsigned long )time) {
#line 116
      goto while_break;
    }
#line 117
    *sec = (char )'\000';
  }
  while_break: /* CIL Label */ ;
  }
#line 120
  if (track == -1L) {
#line 121
    if (seconds == -1L) {
#line 121
      if (sectors == -1L) {
#line 121
        return (-1L);
      }
    }
#line 122
    if (begin == -1) {
      {
#line 123
      ret = cdda_disc_firstsector(d___0);
      }
    } else {
#line 125
      ret = (long )begin;
    }
  } else
#line 127
  if (seconds == -1L) {
#line 127
    if (sectors == -1L) {
#line 128
      if (begin == -1) {
        {
#line 129
        tmp___4 = cdda_track_firstsector(d___0, (int )track);
        }
#line 129
        return (tmp___4);
      } else {
        {
#line 131
        tmp___5 = cdda_track_lastsector(d___0, (int )track);
        }
#line 131
        return (tmp___5);
      }
    } else {
      {
#line 135
      ret = cdda_track_firstsector(d___0, (int )track);
      }
    }
  } else {
    {
#line 135
    ret = cdda_track_firstsector(d___0, (int )track);
    }
  }
#line 141
  if (sectors != -1L) {
#line 141
    ret += sectors;
  }
#line 142
  if (seconds != -1L) {
#line 142
    ret += seconds * 75L;
  }
#line 143
  if (minutes != -1L) {
#line 143
    ret += (minutes * 60L) * 75L;
  }
#line 144
  if (hours != -1L) {
#line 144
    ret += ((hours * 60L) * 60L) * 75L;
  }
#line 147
  if (track != -1L) {
    {
#line 148
    tmp___6 = cdda_sector_gettrack(d___0, ret);
    }
#line 148
    if ((long )tmp___6 != track) {
#line 149
      if (! quiet) {
        {
#line 149
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Time/sector offset goes beyond end of specified track.");
#line 149
        fputc('\n', stderr);
        }
      }
#line 149
      if (reportfile) {
        {
#line 149
        fprintf((FILE */* __restrict  */)reportfile, (char const   */* __restrict  */)"Time/sector offset goes beyond end of specified track.");
#line 149
        fputc('\n', reportfile);
        }
      }
      {
#line 150
      exit(1);
      }
    }
  }
  {
#line 156
  tmp___7 = cdda_disc_lastsector(d___0);
  }
#line 156
  if (ret > tmp___7) {
#line 157
    if (! quiet) {
      {
#line 157
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Time/sector offset goes beyond end of disc.");
#line 157
      fputc('\n', stderr);
      }
    }
#line 157
    if (reportfile) {
      {
#line 157
      fprintf((FILE */* __restrict  */)reportfile, (char const   */* __restrict  */)"Time/sector offset goes beyond end of disc.");
#line 157
      fputc('\n', reportfile);
      }
    }
    {
#line 158
    exit(1);
    }
  }
#line 161
  return (ret);
}
}
#line 166 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/main.c"
static void display_toc(cdrom_drive *d___0 ) 
{ 
  long audiolen ;
  int i ;
  long sec ;
  long tmp ;
  long off ;
  long tmp___0 ;
  char const   *tmp___2 ;
  int tmp___3 ;
  char const   *tmp___5 ;
  int tmp___6 ;
  char const   *tmp___8 ;
  int tmp___9 ;
  char const   *tmp___11 ;
  int tmp___12 ;
  char const   *tmp___14 ;
  int tmp___15 ;
  char const   *tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;

  {
#line 167
  audiolen = 0L;
#line 169
  if (! quiet) {
    {
#line 169
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\nTable of contents (audio tracks only):\ntrack        length               begin        copy pre ch\n===========================================================");
#line 169
    fputc('\n', stderr);
    }
  }
#line 169
  if (reportfile) {
    {
#line 169
    fprintf((FILE */* __restrict  */)reportfile, (char const   */* __restrict  */)"\nTable of contents (audio tracks only):\ntrack        length               begin        copy pre ch\n===========================================================");
#line 169
    fputc('\n', reportfile);
    }
  }
#line 173
  i = 1;
  {
#line 173
  while (1) {
    while_continue: /* CIL Label */ ;
#line 173
    if (! (i <= d___0->tracks)) {
#line 173
      goto while_break;
    }
    {
#line 174
    tmp___19 = cdda_track_audiop(d___0, i);
    }
#line 174
    if (tmp___19 > 0) {
      {
#line 176
      tmp = cdda_track_firstsector(d___0, i);
#line 176
      sec = tmp;
#line 177
      tmp___0 = cdda_track_lastsector(d___0, i);
#line 177
      off = (tmp___0 - sec) + 1L;
      }
#line 179
      if (! quiet) {
        {
#line 179
        tmp___3 = cdda_track_channels(d___0, i);
        }
#line 179
        if (tmp___3 == 2) {
#line 179
          tmp___2 = " 2";
        } else {
#line 179
          tmp___2 = " 4";
        }
        {
#line 179
        tmp___6 = cdda_track_preemp(d___0, i);
        }
#line 179
        if (tmp___6) {
#line 179
          tmp___5 = " yes";
        } else {
#line 179
          tmp___5 = "  no";
        }
        {
#line 179
        tmp___9 = cdda_track_copyp(d___0, i);
        }
#line 179
        if (tmp___9) {
#line 179
          tmp___8 = "  OK";
        } else {
#line 179
          tmp___8 = "  no";
        }
        {
#line 179
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%3d.  %7ld [%02d:%02d.%02d]  %7ld [%02d:%02d.%02d]  %s %s %s",
                i, off, (int )(off / 4500L), (int )((off / 75L) % 60L), (int )(off % 75L),
                sec, (int )(sec / 4500L), (int )((sec / 75L) % 60L), (int )(sec % 75L),
                tmp___8, tmp___5, tmp___2);
#line 179
        fputc('\n', stderr);
        }
      }
#line 179
      if (reportfile) {
        {
#line 179
        tmp___12 = cdda_track_channels(d___0, i);
        }
#line 179
        if (tmp___12 == 2) {
#line 179
          tmp___11 = " 2";
        } else {
#line 179
          tmp___11 = " 4";
        }
        {
#line 179
        tmp___15 = cdda_track_preemp(d___0, i);
        }
#line 179
        if (tmp___15) {
#line 179
          tmp___14 = " yes";
        } else {
#line 179
          tmp___14 = "  no";
        }
        {
#line 179
        tmp___18 = cdda_track_copyp(d___0, i);
        }
#line 179
        if (tmp___18) {
#line 179
          tmp___17 = "  OK";
        } else {
#line 179
          tmp___17 = "  no";
        }
        {
#line 179
        fprintf((FILE */* __restrict  */)reportfile, (char const   */* __restrict  */)"%3d.  %7ld [%02d:%02d.%02d]  %7ld [%02d:%02d.%02d]  %s %s %s",
                i, off, (int )(off / 4500L), (int )((off / 75L) % 60L), (int )(off % 75L),
                sec, (int )(sec / 4500L), (int )((sec / 75L) % 60L), (int )(sec % 75L),
                tmp___17, tmp___14, tmp___11);
#line 179
        fputc('\n', reportfile);
        }
      }
#line 186
      audiolen += off;
    }
#line 173
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 188
  if (! quiet) {
    {
#line 188
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"TOTAL %7ld [%02d:%02d.%02d]    (audio only)",
            audiolen, (int )(audiolen / 4500L), (int )((audiolen / 75L) % 60L), (int )(audiolen % 75L));
#line 188
    fputc('\n', stderr);
    }
  }
#line 188
  if (reportfile) {
    {
#line 188
    fprintf((FILE */* __restrict  */)reportfile, (char const   */* __restrict  */)"TOTAL %7ld [%02d:%02d.%02d]    (audio only)",
            audiolen, (int )(audiolen / 4500L), (int )((audiolen / 75L) % 60L), (int )(audiolen % 75L));
#line 188
    fputc('\n', reportfile);
    }
  }
#line 191
  if (! quiet) {
    {
#line 191
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" ");
#line 191
    fputc('\n', stderr);
    }
  }
#line 191
  if (reportfile) {
    {
#line 191
    fprintf((FILE */* __restrict  */)reportfile, (char const   */* __restrict  */)" ");
#line 191
    fputc('\n', reportfile);
    }
  }
#line 192
  return;
}
}
#line 194 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/main.c"
static void usage(FILE *f ) 
{ 


  {
  {
#line 195
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"cdparanoia III release 10.2 (September 11, 2008)\n\n(C) 2008 Monty <monty@xiph.org> and Xiph.Org\n\nReport bugs to paranoia@xiph.org\nhttp://www.xiph.org/paranoia/\nUSAGE:\n  cdparanoia [options] <span> [outfile]\n\nOPTIONS:\n  -A --analyze-drive              : run and log a complete analysis of drive\n                                    caching, timing and reading behavior;\n                                    verifies that cdparanoia is correctly\n                                    modelling a sprcific drive\'s cache and\n                                    read behavior. Implies -vQL\n\n  -v --verbose                    : extra verbose operation\n  -q --quiet                      : quiet operation\n  -e --stderr-progress            : force output of progress information to\n                                    stderr (for wrapper scripts)\n  -E --force-progress-bar         : force output of progress bar even if\n                                    stderr is not a terminal\n  -l --log-summary [<file>]       : save result summary to file, default\n                                    filename cdparanoia.log\n  -L --log-debug   [<file>]       : save detailed device autosense and\n                                    debugging output to file, default\n                                    filename cdparanoia.log\n  -V --version                    : print version info and quit\n  -Q --query                      : autosense drive, query disc and quit\n  -B --batch                      : \'batch\' mode (saves each track to a\n                                    separate file.\n  -s --search-for-drive           : do an exhaustive search for drive\n  -h --help                       : print help\n\n  -p --output-raw                 : output raw 16-bit PCM in host byte \n                                    order\n  -r --output-raw-little-endian   : output raw 16-bit little-endian PCM\n  -R --output-raw-big-endian      : output raw 16-bit big-endian PCM\n  -w --output-wav                 : output as WAV file (default)\n  -f --output-aiff                : output as AIFF file\n  -a --output-aifc                : output as AIFF-C file\n\n  -c --force-cdrom-little-endian  : force treating drive as little endian\n  -C --force-cdrom-big-endian     : force treating drive as big endian\n  -n --force-default-sectors <n>  : force default number of sectors in read\n                                    to n sectors\n  -o --force-search-overlap  <n>  : force minimum overlap search during\n                                    verification to n sectors\n  -d --force-cdrom-device   <dev> : use specified device; disallow \n                                    autosense\n  -k --force-cooked-device  <dev> : use specified cdrom device and force\n                                    use of the old \'cooked ioctl\' kernel\n                                    interface. -k cannot be used with -d\n                                    or -g.\n  -g --force-generic-device <dev> : use specified generic scsi device and\n                                    force use of the old SG kernel\n                                    interface. -g cannot be used with -k.\n  -S --force-read-speed <n>       : read from device at specified speed; by\n                                    default, cdparanoia sets drive to full\n                                    speed.\n  -t --toc-offset <n>             : Add <n> sectors to the values reported\n                                    when addressing tracks. May be negative\n  -T --toc-bias                   : Assume that the beginning offset of \n                                    track 1 as reported in the TOC will be\n                                    addressed as LBA 0.  Necessary for some\n                                    Toshiba drives to get track boundaries\n                                    correct\n  -O --sample-offset <n>          : Add <n> samples to the offset when\n                                    reading data.  May be negative.\n  -z --never-skip[=n]             : never accept any less than perfect\n                                    data reconstruction (don\'t allow \'V\'s)\n                                    but if [n] is given, skip after [n]\n                                    retries without progress.\n  -Z --disable-paranoia           : disable all paranoia checking\n  -Y --disable-extra-paranoia     : only do cdda2wav-style overlap checking\n  -X --abort-on-skip              : abort on imperfect reads/skips\n\nOUTPUT SMILIES:\n  :-)   Normal operation, low/no jitter\n  :-|   Normal operation, considerable jitter\n  :-/   Read drift\n  :-P   Unreported loss of streaming in atomic read operation\n  8-|   Finding read problems at same point during reread; hard to correct\n  :-0   SCSI/ATAPI transport error\n  :-(   Scratch detected\n  ;-(   Gave up trying to perform a correction\n  8-X   Aborted (as per -X) due to a scratch/skip\n  :^D   Finished extracting\n\nPROGRESS BAR SYMBOLS:\n<space> No corrections needed\n   -    Jitter correction required\n   +    Unreported loss of streaming/other error in read\n   !    Errors are getting through stage 1 but corrected in stage2\n   e    SCSI/ATAPI transport error (corrected)\n   V    Uncorrected error/skip\n\nSPAN ARGUMENT:\nThe span argument may be a simple track number or a offset/span\nspecification.  The syntax of an offset/span takes the rough form:\n\n                       1[ww:xx:yy.zz]-2[aa:bb:cc.dd] \n\nHere, 1 and 2 are track numbers; the numbers in brackets provide a\nfiner-grained offset within a particular track. [aa:bb:cc.dd] is in\nhours/minutes/seconds/sectors format. Zero fields need not be\nspecified: [::20], [:20], [20], [20.], etc, would be interpreted as\ntwenty seconds, [10:] would be ten minutes, [.30] would be thirty\nsectors (75 sectors per second).\n\nWhen only a single offset is supplied, it is interpreted as a starting\noffset and ripping will continue to the end of he track.  If a single\noffset is preceded or followed by a hyphen, the implicit missing\noffset is taken to be the start or end of the disc, respectively. Thus:\n\n    1:[20.35]    Specifies ripping from track 1, second 20, sector 35 to \n                 the end of track 1.\n\n    1:[20.35]-   Specifies ripping from 1[20.35] to the end of the disc\n\n    -2           Specifies ripping from the beginning of the disc up to\n                 (and including) track 2\n\n    -2:[30.35]   Specifies ripping from the beginning of the disc up to\n                 2:[30.35]\n\n    2-4          Specifies ripping from the beginning of track two to the\n                 end of track 4.\n\nDon\'t forget to protect square brackets and preceding hyphens from\nthe shell...\n\nA few examples, protected from the shell:\nDon\'t forget to protect square brackets from the shell...\n\nA few examples, protected from the shell where appropriate:\n  A) query only with exhaustive search for a drive and full reporting\n     of autosense:\n       cdparanoia -vsQ\n\n  B) extract up to and including track 3, putting each track in a separate\n     file:\n       cdparanoia -B -- -3\n\n  C) extract from track 1, time 0:30.12 to 1:10.00:\n       cdparanoia \"1[:30.12]-1[1:10]\"\n\nSubmit bug reports to paranoia@xiph.org\n\n");
  }
#line 341
  return;
}
}
#line 343 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/main.c"
long callbegin  ;
#line 344 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/main.c"
long callend  ;
#line 345 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/main.c"
long callscript  =    0L;
#line 346 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/main.c"
long force_progress_bar  =    0L;
#line 348 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/main.c"
static char *callback_strings[16]  = 
#line 348
  {      (char *)"wrote",      (char *)"finished",      (char *)"read",      (char *)"verify", 
        (char *)"jitter",      (char *)"correction",      (char *)"scratch",      (char *)"scratch repair", 
        (char *)"skip",      (char *)"drift",      (char *)"backoff",      (char *)"overlap", 
        (char *)"dropped",      (char *)"duped",      (char *)"transport error",      (char *)"cache error"};
#line 365 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/main.c"
static int skipped_flag  =    0;
#line 366 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/main.c"
static int abort_on_skip  =    0;
#line 367 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/main.c"
FILE *logfile  =    (FILE *)((void *)0);
#line 377
static void callback(long inpos , int function ) ;
#line 377 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/main.c"
static long c_sector  =    0L;
#line 377 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/main.c"
static long v_sector  =    0L;
#line 378 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/main.c"
static char dispcache[31]  = 
#line 378
  {      (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )'\000'};
#line 379 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/main.c"
static int last  =    0;
#line 380 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/main.c"
static long lasttime  =    0L;
#line 383 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/main.c"
static char heartbeat  =    (char )' ';
#line 385 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/main.c"
static int overlap  =    0;
#line 386 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/main.c"
static int printit  =    -1;
#line 388 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/main.c"
static int slevel  =    0;
#line 389 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/main.c"
static int slast  =    0;
#line 390 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/main.c"
static int stimeout  =    0;
#line 391 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/main.c"
static int cacheerr  =    0;
#line 368 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/main.c"
static void callback(long inpos , int function ) 
{ 
  int graph ;
  char buffer[256] ;
  long sector ;
  long osector ;
  struct timeval thistime ;
  int position ;
  int aheadposition ;
  char *smilie ;
  char const   *tmp ;
  long test ;
  int tmp___0 ;

  {
#line 375
  graph = 30;
#line 381
  osector = 0L;
#line 384
  position = 0;
#line 384
  aheadposition = 0;
#line 392
  smilie = (char *)"= :-)";
#line 394
  if (callscript) {
#line 395
    if (function >= -2) {
#line 395
      if (function <= 13) {
#line 395
        tmp = (char const   *)callback_strings[function + 2];
      } else {
#line 395
        tmp = "";
      }
    } else {
#line 395
      tmp = "";
    }
    {
#line 395
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"##: %d [%s] @ %ld\n",
            function, tmp, inpos);
    }
  } else
#line 399
  if (function == 13) {
#line 400
    if (! cacheerr) {
      {
#line 401
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\rWARNING: The CDROM drive appears to be seeking impossibly quickly.\nThis could be due to timer bugs, a drive that really is improbably fast,\nor, most likely, a bug in cdparanoia\'s cache modelling.\n\nPlease consider using the -A option to perform an analysis run, then mail\nthe cdparanoia.log file produced by the analysis to paranoia-dev@xiph.org\nto assist developers in correcting the problem.\n\n");
      }
    }
#line 409
    cacheerr ++;
  }
#line 413
  if (force_progress_bar) {
#line 413
    goto _L___3;
  } else
#line 413
  if (! quiet) {
    _L___3: /* CIL Label */ 
#line 415
    osector = inpos;
#line 416
    sector = inpos / 1176L;
#line 418
    if (printit == -1) {
#line 419
      if (force_progress_bar) {
#line 420
        printit = 1;
      } else {
        {
#line 419
        tmp___0 = isatty(2);
        }
#line 419
        if (tmp___0) {
#line 420
          printit = 1;
        } else {
#line 422
          printit = 0;
        }
      }
    }
#line 426
    if (printit == 1) {
#line 428
      position = (int )(((float )(sector - callbegin) / (float )(callend - callbegin)) * (float )graph);
#line 431
      aheadposition = (int )(((float )(c_sector - callbegin) / (float )(callend - callbegin)) * (float )graph);
#line 434
      if (function == -2) {
#line 435
        v_sector = sector;
#line 436
        return;
      }
#line 438
      if (function == -1) {
#line 439
        last = 8;
#line 440
        heartbeat = (char )'*';
#line 441
        slevel = 0;
#line 442
        v_sector = sector;
      } else
#line 444
      if (position < graph) {
#line 444
        if (position >= 0) {
          {
#line 446
          if (function == 1) {
#line 446
            goto case_1;
          }
#line 454
          if (function == 0) {
#line 454
            goto case_0;
          }
#line 458
          if (function == 2) {
#line 458
            goto case_2;
          }
#line 468
          if (function == 3) {
#line 468
            goto case_3;
          }
#line 474
          if (function == 12) {
#line 474
            goto case_12;
          }
#line 479
          if (function == 13) {
#line 479
            goto case_13;
          }
#line 483
          if (function == 6) {
#line 483
            goto case_6;
          }
#line 488
          if (function == 9) {
#line 488
            goto case_9;
          }
#line 491
          if (function == 4) {
#line 491
            goto case_4;
          }
#line 494
          if (function == 7) {
#line 494
            goto case_7;
          }
#line 498
          if (function == 11) {
#line 498
            goto case_11;
          }
#line 498
          if (function == 10) {
#line 498
            goto case_11;
          }
#line 445
          goto switch_break;
          case_1: /* CIL Label */ 
#line 447
          if (stimeout >= 30) {
#line 448
            if (overlap > 1176) {
#line 449
              slevel = 2;
            } else {
#line 451
              slevel = 1;
            }
          }
#line 453
          goto switch_break;
          case_0: /* CIL Label */ 
#line 455
          if (sector > c_sector) {
#line 455
            c_sector = sector;
          }
#line 456
          goto switch_break;
          case_2: /* CIL Label */ 
#line 459
          if (stimeout >= 5) {
#line 460
            if (overlap > 1176) {
#line 461
              slevel = 2;
            } else {
#line 463
              slevel = 1;
            }
          }
#line 465
          if ((int )dispcache[position] == 32) {
#line 466
            dispcache[position] = (char )'-';
          }
#line 467
          goto switch_break;
          case_3: /* CIL Label */ 
#line 469
          if (slevel < 3) {
#line 469
            slevel = 3;
          } else
#line 469
          if (stimeout > 5) {
#line 469
            slevel = 3;
          }
#line 470
          if ((int )dispcache[position] == 32) {
#line 472
            dispcache[position] = (char )'+';
          } else
#line 470
          if ((int )dispcache[position] == 45) {
#line 472
            dispcache[position] = (char )'+';
          }
#line 473
          goto switch_break;
          case_12: /* CIL Label */ 
#line 475
          slevel = 6;
#line 476
          if ((int )dispcache[position] != 86) {
#line 476
            if ((int )dispcache[position] != 67) {
#line 477
              dispcache[position] = (char )'e';
            }
          }
#line 478
          goto switch_break;
          case_13: /* CIL Label */ 
#line 480
          slevel = 8;
#line 481
          dispcache[position] = (char )'C';
#line 482
          goto switch_break;
          case_6: /* CIL Label */ 
#line 484
          slevel = 8;
#line 485
          if ((int )dispcache[position] != 67) {
#line 486
            dispcache[position] = (char )'V';
          }
#line 487
          goto switch_break;
          case_9: /* CIL Label */ 
#line 489
          overlap = (int )osector;
#line 490
          goto switch_break;
          case_4: /* CIL Label */ 
#line 492
          slevel = 7;
#line 493
          goto switch_break;
          case_7: /* CIL Label */ 
#line 495
          if (slevel < 4) {
#line 495
            slevel = 4;
          } else
#line 495
          if (stimeout > 5) {
#line 495
            slevel = 4;
          }
#line 496
          goto switch_break;
          case_11: /* CIL Label */ 
          case_10: /* CIL Label */ 
#line 499
          slevel = 5;
#line 500
          if ((int )dispcache[position] == 32) {
#line 503
            dispcache[position] = (char )'!';
          } else
#line 500
          if ((int )dispcache[position] == 45) {
#line 503
            dispcache[position] = (char )'!';
          } else
#line 500
          if ((int )dispcache[position] == 43) {
#line 503
            dispcache[position] = (char )'!';
          }
#line 504
          goto switch_break;
          switch_break: /* CIL Label */ ;
          }
        }
      }
      {
#line 508
      if (slevel == 0) {
#line 508
        goto case_0___0;
      }
#line 514
      if (slevel == 1) {
#line 514
        goto case_1___0;
      }
#line 517
      if (slevel == 2) {
#line 517
        goto case_2___0;
      }
#line 520
      if (slevel == 4) {
#line 520
        goto case_4___0;
      }
#line 523
      if (slevel == 3) {
#line 523
        goto case_3___0;
      }
#line 526
      if (slevel == 5) {
#line 526
        goto case_5;
      }
#line 529
      if (slevel == 6) {
#line 529
        goto case_6___0;
      }
#line 532
      if (slevel == 7) {
#line 532
        goto case_7___0;
      }
#line 535
      if (slevel == 8) {
#line 535
        goto case_8;
      }
#line 507
      goto switch_break___0;
      case_0___0: /* CIL Label */ 
#line 509
      if (skipped_flag) {
#line 510
        smilie = (char *)" 8-X";
      } else {
#line 512
        smilie = (char *)" :^D";
      }
#line 513
      goto switch_break___0;
      case_1___0: /* CIL Label */ 
#line 515
      smilie = (char *)" :-)";
#line 516
      goto switch_break___0;
      case_2___0: /* CIL Label */ 
#line 518
      smilie = (char *)" :-|";
#line 519
      goto switch_break___0;
      case_4___0: /* CIL Label */ 
#line 521
      smilie = (char *)" :-/";
#line 522
      goto switch_break___0;
      case_3___0: /* CIL Label */ 
#line 524
      smilie = (char *)" :-P";
#line 525
      goto switch_break___0;
      case_5: /* CIL Label */ 
#line 527
      smilie = (char *)" 8-|";
#line 528
      goto switch_break___0;
      case_6___0: /* CIL Label */ 
#line 530
      smilie = (char *)" :-0";
#line 531
      goto switch_break___0;
      case_7___0: /* CIL Label */ 
#line 533
      smilie = (char *)" :-(";
#line 534
      goto switch_break___0;
      case_8: /* CIL Label */ 
#line 536
      smilie = (char *)" ;-(";
#line 537
      skipped_flag = 1;
#line 538
      goto switch_break___0;
      switch_break___0: /* CIL Label */ ;
      }
      {
#line 542
      gettimeofday((struct timeval */* __restrict  */)(& thistime), (__timezone_ptr_t )((void *)0));
#line 543
      test = thistime.tv_sec * 10L + thistime.tv_usec / 100000L;
      }
#line 545
      if (lasttime != test) {
#line 545
        goto _L___2;
      } else
#line 545
      if (function == -1) {
#line 545
        goto _L___2;
      } else
#line 545
      if (slast != slevel) {
        _L___2: /* CIL Label */ 
#line 546
        if (lasttime != test) {
#line 546
          goto _L;
        } else
#line 546
        if (function == -1) {
          _L: /* CIL Label */ 
#line 547
          last ++;
#line 548
          lasttime = test;
#line 549
          if (last > 7) {
#line 549
            last = 0;
          }
#line 550
          stimeout ++;
          {
#line 552
          if (last == 0) {
#line 552
            goto case_0___1;
          }
#line 555
          if (last == 7) {
#line 555
            goto case_7___1;
          }
#line 555
          if (last == 1) {
#line 555
            goto case_7___1;
          }
#line 558
          if (last == 6) {
#line 558
            goto case_6___1;
          }
#line 558
          if (last == 2) {
#line 558
            goto case_6___1;
          }
#line 561
          if (last == 5) {
#line 561
            goto case_5___0;
          }
#line 561
          if (last == 3) {
#line 561
            goto case_5___0;
          }
#line 564
          if (last == 4) {
#line 564
            goto case_4___1;
          }
#line 551
          goto switch_break___1;
          case_0___1: /* CIL Label */ 
#line 553
          heartbeat = (char )' ';
#line 554
          goto switch_break___1;
          case_7___1: /* CIL Label */ 
          case_1___1: /* CIL Label */ 
#line 556
          heartbeat = (char )'.';
#line 557
          goto switch_break___1;
          case_6___1: /* CIL Label */ 
          case_2___1: /* CIL Label */ 
#line 559
          heartbeat = (char )'o';
#line 560
          goto switch_break___1;
          case_5___0: /* CIL Label */ 
          case_3___1: /* CIL Label */ 
#line 562
          heartbeat = (char )'0';
#line 563
          goto switch_break___1;
          case_4___1: /* CIL Label */ 
#line 565
          heartbeat = (char )'O';
#line 566
          goto switch_break___1;
          switch_break___1: /* CIL Label */ ;
          }
#line 568
          if (function == -1) {
#line 569
            heartbeat = (char )'*';
          }
        }
#line 572
        if (slast != slevel) {
#line 573
          stimeout = 0;
        }
#line 575
        slast = slevel;
#line 577
        if (abort_on_skip) {
#line 577
          if (skipped_flag) {
#line 577
            if (function != -1) {
              {
#line 578
              sprintf((char */* __restrict  */)(buffer), (char const   */* __restrict  */)"\r (== PROGRESS == [%s| %06ld %02d ] ==%s %c ==)   ",
                      "  ...aborting; please wait... ", v_sector, overlap / 1176,
                      smilie, (int )heartbeat);
              }
            } else {
#line 577
              goto _L___1;
            }
          } else {
#line 577
            goto _L___1;
          }
        } else {
          _L___1: /* CIL Label */ 
#line 583
          if (v_sector == 0L) {
            {
#line 584
            sprintf((char */* __restrict  */)(buffer), (char const   */* __restrict  */)"\r (== PROGRESS == [%s| ...... %02d ] ==%s %c ==)   ",
                    dispcache, overlap / 1176, smilie, (int )heartbeat);
            }
          } else {
            {
#line 589
            sprintf((char */* __restrict  */)(buffer), (char const   */* __restrict  */)"\r (== PROGRESS == [%s| %06ld %02d ] ==%s %c ==)   ",
                    dispcache, v_sector, overlap / 1176, smilie, (int )heartbeat);
            }
          }
#line 593
          if (aheadposition >= 0) {
#line 593
            if (aheadposition < graph) {
#line 593
              if (! (function == -1)) {
#line 594
                buffer[aheadposition + 19] = (char )'>';
              }
            }
          }
        }
        {
#line 597
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)(buffer));
        }
#line 599
        if ((unsigned long )logfile != (unsigned long )((void *)0)) {
#line 599
          if (function == -1) {
            {
#line 600
            fprintf((FILE */* __restrict  */)logfile, (char const   */* __restrict  */)(buffer + 1));
#line 601
            fprintf((FILE */* __restrict  */)logfile, (char const   */* __restrict  */)"\n\n");
#line 602
            fflush(logfile);
            }
          }
        }
      }
    }
  }
#line 609
  if (function == -1) {
    {
#line 610
    memset((void *)(dispcache), ' ', (size_t )graph);
    }
  }
#line 611
  return;
}
}
#line 613 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/main.c"
char const   *optstring  =    "eEscCn:o:O:d:g:k:S:prRwafvqVQhZz::YXWBi:Tt:l::L::A";
#line 615 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/main.c"
struct option options[36]  = 
#line 615
  {      {"stderr-progress", 0, (int *)((void *)0), 'e'}, 
        {"force-progress-bar", 0, (int *)((void *)0), 'E'}, 
        {"search-for-drive", 0, (int *)((void *)0), 's'}, 
        {"force-cdrom-little-endian", 0, (int *)((void *)0), 'c'}, 
        {"force-cdrom-big-endian", 0, (int *)((void *)0), 'C'}, 
        {"force-default-sectors", 1, (int *)((void *)0), 'n'}, 
        {"force-search-overlap", 1, (int *)((void *)0), 'o'}, 
        {"force-cdrom-device", 1, (int *)((void *)0), 'd'}, 
        {"force-cooked-device", 1, (int *)((void *)0), 'k'}, 
        {"force-generic-device", 1, (int *)((void *)0), 'g'}, 
        {"force-read-speed", 1, (int *)((void *)0), 'S'}, 
        {"sample-offset", 1, (int *)((void *)0), 'O'}, 
        {"toc-offset", 1, (int *)((void *)0), 't'}, 
        {"toc-bias", 0, (int *)((void *)0), 'T'}, 
        {"output-raw", 0, (int *)((void *)0), 'p'}, 
        {"output-raw-little-endian", 0, (int *)((void *)0), 'r'}, 
        {"output-raw-big-endian", 0, (int *)((void *)0), 'R'}, 
        {"output-wav", 0, (int *)((void *)0), 'w'}, 
        {"output-aiff", 0, (int *)((void *)0), 'f'}, 
        {"output-aifc", 0, (int *)((void *)0), 'a'}, 
        {"batch", 0, (int *)((void *)0), 'B'}, 
        {"verbose", 0, (int *)((void *)0), 'v'}, 
        {"quiet", 0, (int *)((void *)0), 'q'}, 
        {"version", 0, (int *)((void *)0), 'V'}, 
        {"query", 0, (int *)((void *)0), 'Q'}, 
        {"help", 0, (int *)((void *)0), 'h'}, 
        {"analyze-drive", 0, (int *)((void *)0), 'A'}, 
        {"disable-paranoia", 0, (int *)((void *)0), 'Z'}, 
        {"disable-extra-paranoia", 0, (int *)((void *)0), 'Y'}, 
        {"abort-on-skip", 0, (int *)((void *)0), 'X'}, 
        {"disable-fragmentation", 0, (int *)((void *)0), 'F'}, 
        {"output-info", 1, (int *)((void *)0), 'i'}, 
        {"never-skip", 2, (int *)((void *)0), 'z'}, 
        {"log-summary", 2, (int *)((void *)0), 'l'}, 
        {"log-debug", 2, (int *)((void *)0), 'L'}, 
        {(char const   *)((void *)0), 0, (int *)((void *)0), 0}};
#line 655 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/main.c"
long blocking_write(int outf , char *buffer , long num ) 
{ 
  long words ;
  long temp ;
  int *tmp ;
  int *tmp___0 ;

  {
#line 656
  words = 0L;
  {
#line 658
  while (1) {
    while_continue: /* CIL Label */ ;
#line 658
    if (! (words < num)) {
#line 658
      goto while_break;
    }
    {
#line 659
    temp = write(outf, (void const   *)(buffer + words), (size_t )(num - words));
    }
#line 660
    if (temp == -1L) {
      {
#line 661
      tmp = __errno_location();
      }
#line 661
      if (*tmp != 4) {
        {
#line 661
        tmp___0 = __errno_location();
        }
#line 661
        if (*tmp___0 != 11) {
#line 662
          return (-1L);
        }
      }
#line 663
      temp = 0L;
    }
#line 665
    words += temp;
  }
  while_break: /* CIL Label */ ;
  }
#line 667
  return (0L);
}
}
#line 670 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/main.c"
static cdrom_drive *d  =    (cdrom_drive *)((void *)0);
#line 671 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/main.c"
static cdrom_paranoia___0 *p  =    (void *)0;
#line 673 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/main.c"
static void cleanup(void) 
{ 


  {
#line 674
  if (p) {
    {
#line 674
    paranoia_free(p);
    }
  }
#line 675
  if (d) {
    {
#line 675
    cdda_close(d);
    }
  }
#line 676
  return;
}
}
#line 678 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/main.c"
int main(int argc , char **argv ) 
{ 
  int toc_bias ;
  int toc_offset ;
  int sample_offset ;
  int force_cdrom_endian ;
  int force_cdrom_sectors ;
  int force_cdrom_overlap ;
  char *force_cdrom_device ;
  char *force_generic_device ;
  char *force_cooked_device ;
  int force_cdrom_speed ;
  int max_retries ;
  char *span ;
  int output_type ;
  int output_endian ;
  int query_only ;
  int batch ;
  int i ;
  int run_cache_test ;
  char *logfile_name ;
  char *reportfile_name ;
  int logfile_open ;
  int reportfile_open ;
  int paranoia_mode ;
  char *info_file ;
  int out ;
  int search ;
  int c ;
  int long_option_index ;
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;
  int *tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int i___0 ;
  char *tmp___10 ;
  char *tmp___11 ;
  int i___1 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  struct stat s ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int warn ;
  int tmp___19 ;
  long tmp___20 ;
  long first_sector ;
  long last_sector ;
  long batch_first ;
  long batch_last ;
  int batch_track ;
  char *span2 ;
  char *tmp___21 ;
  char *tmp___22 ;
  long tmp___23 ;
  int tmp___24 ;
  int track1 ;
  int tmp___25 ;
  int track2 ;
  int tmp___26 ;
  long off1 ;
  long tmp___27 ;
  long off2 ;
  long tmp___28 ;
  int i___2 ;
  int tmp___29 ;
  long cursor ;
  int16_t offset_buffer[1176] ;
  int offset_buffer_used ;
  int offset_skip ;
  __uid_t tmp___30 ;
  __gid_t tmp___31 ;
  char outfile_name[256] ;
  int tmp___32 ;
  char path[256] ;
  char *post ;
  char *tmp___33 ;
  int pos ;
  long tmp___34 ;
  char *file ;
  int tmp___35 ;
  int *tmp___36 ;
  char *tmp___37 ;
  int *tmp___38 ;
  char *tmp___39 ;
  int tmp___40 ;
  int *tmp___41 ;
  char *tmp___42 ;
  int *tmp___43 ;
  char *tmp___44 ;
  int *tmp___45 ;
  char *tmp___46 ;
  int *tmp___47 ;
  char *tmp___48 ;
  long tmp___49 ;
  int16_t *readbuf ;
  int16_t *tmp___50 ;
  char *err ;
  char *tmp___51 ;
  char *mes ;
  char *tmp___52 ;
  char const   *tmp___53 ;
  char const   *tmp___54 ;
  int *tmp___55 ;
  int *tmp___56 ;
  int i___3 ;
  int tmp___57 ;
  int *tmp___58 ;
  char *tmp___59 ;
  int *tmp___60 ;
  char *tmp___61 ;
  long tmp___62 ;
  int i___4 ;
  int tmp___63 ;
  int i___5 ;
  char const   *tmp___64 ;
  char const   *tmp___65 ;
  int tmp___66 ;
  int *tmp___67 ;
  char *tmp___68 ;
  int *tmp___69 ;
  char *tmp___70 ;
  long tmp___71 ;

  {
  {
#line 679
  toc_bias = 0;
#line 680
  toc_offset = 0;
#line 681
  sample_offset = 0;
#line 682
  force_cdrom_endian = -1;
#line 683
  force_cdrom_sectors = -1;
#line 684
  force_cdrom_overlap = -1;
#line 685
  force_cdrom_device = (char *)((void *)0);
#line 686
  force_generic_device = (char *)((void *)0);
#line 687
  force_cooked_device = (char *)((void *)0);
#line 688
  force_cdrom_speed = 0;
#line 689
  max_retries = 20;
#line 690
  span = (char *)((void *)0);
#line 691
  output_type = 1;
#line 692
  output_endian = 0;
#line 693
  query_only = 0;
#line 694
  batch = 0;
#line 695
  run_cache_test = 0;
#line 697
  logfile_name = (char *)((void *)0);
#line 698
  reportfile_name = (char *)((void *)0);
#line 699
  logfile_open = 0;
#line 700
  reportfile_open = 0;
#line 703
  paranoia_mode = 223;
#line 705
  info_file = (char *)((void *)0);
#line 708
  search = 0;
#line 711
  atexit(& cleanup);
  }
  {
#line 713
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 713
    c = getopt_long(argc, (char * const  *)argv, optstring, (struct option  const  *)(options),
                    & long_option_index);
    }
#line 713
    if (! (c != -1)) {
#line 713
      goto while_break;
    }
    {
#line 715
    if (c == 66) {
#line 715
      goto case_66;
    }
#line 718
    if (c == 99) {
#line 718
      goto case_99;
    }
#line 721
    if (c == 67) {
#line 721
      goto case_67;
    }
#line 724
    if (c == 110) {
#line 724
      goto case_110;
    }
#line 727
    if (c == 111) {
#line 727
      goto case_111;
    }
#line 730
    if (c == 100) {
#line 730
      goto case_100;
    }
#line 734
    if (c == 103) {
#line 734
      goto case_103;
    }
#line 743
    if (c == 107) {
#line 743
      goto case_107;
    }
#line 751
    if (c == 83) {
#line 751
      goto case_83;
    }
#line 754
    if (c == 112) {
#line 754
      goto case_112;
    }
#line 758
    if (c == 114) {
#line 758
      goto case_114;
    }
#line 762
    if (c == 82) {
#line 762
      goto case_82;
    }
#line 766
    if (c == 119) {
#line 766
      goto case_119;
    }
#line 770
    if (c == 97) {
#line 770
      goto case_97;
    }
#line 774
    if (c == 102) {
#line 774
      goto case_102;
    }
#line 778
    if (c == 118) {
#line 778
      goto case_118;
    }
#line 782
    if (c == 115) {
#line 782
      goto case_115;
    }
#line 785
    if (c == 113) {
#line 785
      goto case_113;
    }
#line 789
    if (c == 101) {
#line 789
      goto case_101;
    }
#line 793
    if (c == 69) {
#line 793
      goto case_69;
    }
#line 796
    if (c == 86) {
#line 796
      goto case_86;
    }
#line 801
    if (c == 81) {
#line 801
      goto case_81;
    }
#line 804
    if (c == 104) {
#line 804
      goto case_104;
    }
#line 807
    if (c == 90) {
#line 807
      goto case_90;
    }
#line 810
    if (c == 65) {
#line 810
      goto case_65;
    }
#line 816
    if (c == 122) {
#line 816
      goto case_122;
    }
#line 824
    if (c == 89) {
#line 824
      goto case_89;
    }
#line 829
    if (c == 88) {
#line 829
      goto case_88;
    }
#line 833
    if (c == 87) {
#line 833
      goto case_87;
    }
#line 836
    if (c == 70) {
#line 836
      goto case_70;
    }
#line 839
    if (c == 105) {
#line 839
      goto case_105;
    }
#line 843
    if (c == 84) {
#line 843
      goto case_84;
    }
#line 846
    if (c == 116) {
#line 846
      goto case_116;
    }
#line 849
    if (c == 108) {
#line 849
      goto case_108;
    }
#line 856
    if (c == 76) {
#line 856
      goto case_76;
    }
#line 863
    if (c == 79) {
#line 863
      goto case_79;
    }
#line 866
    goto switch_default;
    case_66: /* CIL Label */ 
#line 716
    batch = 1;
#line 717
    goto switch_break;
    case_99: /* CIL Label */ 
#line 719
    force_cdrom_endian = 0;
#line 720
    goto switch_break;
    case_67: /* CIL Label */ 
#line 722
    force_cdrom_endian = 1;
#line 723
    goto switch_break;
    case_110: /* CIL Label */ 
    {
#line 725
    force_cdrom_sectors = atoi((char const   *)optarg);
    }
#line 726
    goto switch_break;
    case_111: /* CIL Label */ 
    {
#line 728
    force_cdrom_overlap = atoi((char const   *)optarg);
    }
#line 729
    goto switch_break;
    case_100: /* CIL Label */ 
#line 731
    if (force_cdrom_device) {
      {
#line 731
      free((void *)force_cdrom_device);
      }
    }
    {
#line 732
    force_cdrom_device = copystring___3((char const   *)optarg);
    }
#line 733
    goto switch_break;
    case_103: /* CIL Label */ 
#line 735
    if (force_cooked_device) {
#line 736
      if (! quiet) {
        {
#line 736
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"-g option incompatible with -k\n");
#line 736
        fputc('\n', stderr);
        }
      }
#line 736
      if (reportfile) {
        {
#line 736
        fprintf((FILE */* __restrict  */)reportfile, (char const   */* __restrict  */)"-g option incompatible with -k\n");
#line 736
        fputc('\n', reportfile);
        }
      }
      {
#line 737
      exit(1);
      }
    }
#line 739
    force_cooked_device = (char *)((void *)0);
#line 740
    if (force_generic_device) {
      {
#line 740
      free((void *)force_generic_device);
      }
    }
    {
#line 741
    force_generic_device = copystring___3((char const   *)optarg);
    }
#line 742
    goto switch_break;
    case_107: /* CIL Label */ 
#line 744
    if (force_generic_device) {
#line 744
      goto _L;
    } else
#line 744
    if (force_cdrom_device) {
      _L: /* CIL Label */ 
#line 745
      if (! quiet) {
        {
#line 745
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"-k option incompatible with -d and -g\n");
#line 745
        fputc('\n', stderr);
        }
      }
#line 745
      if (reportfile) {
        {
#line 745
        fprintf((FILE */* __restrict  */)reportfile, (char const   */* __restrict  */)"-k option incompatible with -d and -g\n");
#line 745
        fputc('\n', reportfile);
        }
      }
      {
#line 746
      exit(1);
      }
    }
#line 748
    if (force_cooked_device) {
      {
#line 748
      free((void *)force_cooked_device);
      }
    }
    {
#line 749
    force_cooked_device = copystring___3((char const   *)optarg);
    }
#line 750
    goto switch_break;
    case_83: /* CIL Label */ 
    {
#line 752
    force_cdrom_speed = atoi((char const   *)optarg);
    }
#line 753
    goto switch_break;
    case_112: /* CIL Label */ 
#line 755
    output_type = 0;
#line 756
    output_endian = -1;
#line 757
    goto switch_break;
    case_114: /* CIL Label */ 
#line 759
    output_type = 0;
#line 760
    output_endian = 0;
#line 761
    goto switch_break;
    case_82: /* CIL Label */ 
#line 763
    output_type = 0;
#line 764
    output_endian = 1;
#line 765
    goto switch_break;
    case_119: /* CIL Label */ 
#line 767
    output_type = 1;
#line 768
    output_endian = 0;
#line 769
    goto switch_break;
    case_97: /* CIL Label */ 
#line 771
    output_type = 2;
#line 772
    output_endian = 1;
#line 773
    goto switch_break;
    case_102: /* CIL Label */ 
#line 775
    output_type = 3;
#line 776
    output_endian = 1;
#line 777
    goto switch_break;
    case_118: /* CIL Label */ 
#line 779
    verbose = 1;
#line 780
    quiet = 0;
#line 781
    goto switch_break;
    case_115: /* CIL Label */ 
#line 783
    search = 1;
#line 784
    goto switch_break;
    case_113: /* CIL Label */ 
#line 786
    verbose = 0;
#line 787
    quiet = 1;
#line 788
    goto switch_break;
    case_101: /* CIL Label */ 
    {
#line 790
    callscript = 1L;
#line 791
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Sending all callbacks to stderr for wrapper script\n");
    }
#line 792
    goto switch_break;
    case_69: /* CIL Label */ 
#line 794
    force_progress_bar = 1L;
#line 795
    goto switch_break;
    case_86: /* CIL Label */ 
    {
#line 797
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"cdparanoia III release 10.2 (September 11, 2008)\n");
#line 798
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
#line 799
    exit(0);
    }
#line 800
    goto switch_break;
    case_81: /* CIL Label */ 
#line 802
    query_only = 1;
#line 803
    goto switch_break;
    case_104: /* CIL Label */ 
    {
#line 805
    usage(stdout);
#line 806
    exit(0);
    }
    case_90: /* CIL Label */ 
#line 808
    paranoia_mode = 0;
#line 809
    goto switch_break;
    case_65: /* CIL Label */ 
#line 811
    run_cache_test = 1;
#line 812
    query_only = 1;
#line 813
    reportfile_open = 1;
#line 814
    verbose = 1;
#line 815
    goto switch_break;
    case_122: /* CIL Label */ 
#line 817
    if (optarg) {
      {
#line 818
      max_retries = atoi((char const   *)optarg);
#line 819
      paranoia_mode &= -33;
      }
    } else {
#line 821
      paranoia_mode |= 32;
    }
#line 823
    goto switch_break;
    case_89: /* CIL Label */ 
#line 825
    paranoia_mode |= 4;
#line 827
    paranoia_mode &= -2;
#line 828
    goto switch_break;
    case_88: /* CIL Label */ 
#line 831
    abort_on_skip = 1;
#line 832
    goto switch_break;
    case_87: /* CIL Label */ 
#line 834
    paranoia_mode &= -17;
#line 835
    goto switch_break;
    case_70: /* CIL Label */ 
#line 837
    paranoia_mode &= -3;
#line 838
    goto switch_break;
    case_105: /* CIL Label */ 
#line 840
    if (info_file) {
      {
#line 840
      free((void *)info_file);
      }
    }
    {
#line 841
    info_file = copystring___3((char const   *)info_file);
    }
#line 842
    goto switch_break;
    case_84: /* CIL Label */ 
#line 844
    toc_bias = -1;
#line 845
    goto switch_break;
    case_116: /* CIL Label */ 
    {
#line 847
    toc_offset = atoi((char const   *)optarg);
    }
#line 848
    goto switch_break;
    case_108: /* CIL Label */ 
#line 850
    if (logfile_name) {
      {
#line 850
      free((void *)logfile_name);
      }
    }
#line 851
    logfile_name = (char *)((void *)0);
#line 852
    if (optarg) {
      {
#line 853
      logfile_name = strdup((char const   *)optarg);
      }
    }
#line 854
    logfile_open = 1;
#line 855
    goto switch_break;
    case_76: /* CIL Label */ 
#line 857
    if (reportfile_name) {
      {
#line 857
      free((void *)reportfile_name);
      }
    }
#line 858
    reportfile_name = (char *)((void *)0);
#line 859
    if (optarg) {
      {
#line 860
      reportfile_name = strdup((char const   *)optarg);
      }
    }
#line 861
    reportfile_open = 1;
#line 862
    goto switch_break;
    case_79: /* CIL Label */ 
    {
#line 864
    sample_offset = atoi((char const   *)optarg);
    }
#line 865
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 867
    usage(stderr);
#line 868
    exit(1);
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 872
  if (logfile_open) {
#line 873
    if ((unsigned long )logfile_name == (unsigned long )((void *)0)) {
      {
#line 874
      logfile_name = strdup("cdparanoia.log");
      }
    }
    {
#line 875
    tmp___3 = strcmp((char const   *)logfile_name, "-");
    }
#line 875
    if (tmp___3) {
      {
#line 879
      logfile = fopen((char const   */* __restrict  */)logfile_name, (char const   */* __restrict  */)"w");
      }
#line 880
      if ((unsigned long )logfile == (unsigned long )((void *)0)) {
#line 881
        if (! quiet) {
          {
#line 881
          tmp = __errno_location();
#line 881
          tmp___0 = strerror(*tmp);
#line 881
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Cannot open log summary file %s: %s",
                  logfile_name, tmp___0);
#line 881
          fputc('\n', stderr);
          }
        }
#line 881
        if (reportfile) {
          {
#line 881
          tmp___1 = __errno_location();
#line 881
          tmp___2 = strerror(*tmp___1);
#line 881
          fprintf((FILE */* __restrict  */)reportfile, (char const   */* __restrict  */)"Cannot open log summary file %s: %s",
                  logfile_name, tmp___2);
#line 881
          fputc('\n', reportfile);
          }
        }
        {
#line 883
        exit(1);
        }
      }
    } else {
#line 876
      logfile = stdout;
#line 877
      logfile_open = 0;
    }
  }
#line 887
  if (reportfile_open) {
#line 888
    if ((unsigned long )reportfile_name == (unsigned long )((void *)0)) {
      {
#line 889
      reportfile_name = strdup("cdparanoia.log");
      }
    }
    {
#line 890
    tmp___9 = strcmp((char const   *)reportfile_name, "-");
    }
#line 890
    if (tmp___9) {
#line 894
      if (logfile_name) {
        {
#line 894
        tmp___8 = strcmp((char const   *)reportfile_name, (char const   *)logfile_name);
        }
#line 894
        if (tmp___8) {
#line 894
          goto _L___0;
        } else {
#line 895
          reportfile = logfile;
#line 896
          reportfile_open = 0;
        }
      } else {
        _L___0: /* CIL Label */ 
        {
#line 898
        reportfile = fopen((char const   */* __restrict  */)reportfile_name, (char const   */* __restrict  */)"w");
        }
#line 899
        if ((unsigned long )reportfile == (unsigned long )((void *)0)) {
#line 900
          if (! quiet) {
            {
#line 900
            tmp___4 = __errno_location();
#line 900
            tmp___5 = strerror(*tmp___4);
#line 900
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Cannot open debug log file %s: %s",
                    reportfile_name, tmp___5);
#line 900
            fputc('\n', stderr);
            }
          }
#line 900
          if (reportfile) {
            {
#line 900
            tmp___6 = __errno_location();
#line 900
            tmp___7 = strerror(*tmp___6);
#line 900
            fprintf((FILE */* __restrict  */)reportfile, (char const   */* __restrict  */)"Cannot open debug log file %s: %s",
                    reportfile_name, tmp___7);
#line 900
            fputc('\n', reportfile);
            }
          }
          {
#line 902
          exit(1);
          }
        }
      }
    } else {
#line 891
      reportfile = stdout;
#line 892
      reportfile_open = 0;
    }
  }
#line 908
  if (logfile) {
#line 911
    i___0 = 0;
    {
#line 911
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 911
      if (! (i___0 < argc)) {
#line 911
        goto while_break___0;
      }
      {
#line 912
      fprintf((FILE */* __restrict  */)logfile, (char const   */* __restrict  */)"%s ",
              *(argv + i___0));
#line 911
      i___0 ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 913
    fprintf((FILE */* __restrict  */)logfile, (char const   */* __restrict  */)"\n");
    }
#line 915
    if ((unsigned long )reportfile != (unsigned long )logfile) {
      {
#line 916
      fprintf((FILE */* __restrict  */)logfile, (char const   */* __restrict  */)"cdparanoia III release 10.2 (September 11, 2008)\n");
#line 917
      fprintf((FILE */* __restrict  */)logfile, (char const   */* __restrict  */)"\n");
#line 918
      tmp___10 = cdda_version();
#line 918
      fprintf((FILE */* __restrict  */)logfile, (char const   */* __restrict  */)"Using cdda library version: %s\n",
              tmp___10);
#line 919
      tmp___11 = paranoia_version();
#line 919
      fprintf((FILE */* __restrict  */)logfile, (char const   */* __restrict  */)"Using paranoia library version: %s\n",
              tmp___11);
      }
    }
    {
#line 921
    fflush(logfile);
    }
  }
#line 924
  if (reportfile) {
#line 924
    if ((unsigned long )reportfile != (unsigned long )logfile) {
#line 927
      i___1 = 0;
      {
#line 927
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 927
        if (! (i___1 < argc)) {
#line 927
          goto while_break___1;
        }
        {
#line 928
        fprintf((FILE */* __restrict  */)reportfile, (char const   */* __restrict  */)"%s ",
                *(argv + i___1));
#line 927
        i___1 ++;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 929
      fprintf((FILE */* __restrict  */)reportfile, (char const   */* __restrict  */)"\n");
#line 930
      fflush(reportfile);
      }
    }
  }
#line 933
  if (optind >= argc) {
#line 933
    if (! query_only) {
#line 934
      if (batch) {
#line 935
        span = (char *)((void *)0);
      } else {
        {
#line 938
        usage(stderr);
#line 939
        exit(1);
        }
      }
    } else {
      {
#line 942
      span = copystring___3((char const   *)*(argv + optind));
      }
    }
  } else {
    {
#line 942
    span = copystring___3((char const   *)*(argv + optind));
    }
  }
#line 944
  if (! quiet) {
    {
#line 944
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"cdparanoia III release 10.2 (September 11, 2008)\n");
#line 944
    fputc('\n', stderr);
    }
  }
#line 944
  if (reportfile) {
    {
#line 944
    fprintf((FILE */* __restrict  */)reportfile, (char const   */* __restrict  */)"cdparanoia III release 10.2 (September 11, 2008)\n");
#line 944
    fputc('\n', reportfile);
    }
  }
#line 945
  if (verbose) {
#line 946
    if (! quiet) {
      {
#line 946
      tmp___12 = cdda_version();
#line 946
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Using cdda library version: %s",
              tmp___12);
#line 946
      fputc('\n', stderr);
      }
    }
#line 946
    if (reportfile) {
      {
#line 946
      tmp___13 = cdda_version();
#line 946
      fprintf((FILE */* __restrict  */)reportfile, (char const   */* __restrict  */)"Using cdda library version: %s",
              tmp___13);
#line 946
      fputc('\n', reportfile);
      }
    }
#line 947
    if (! quiet) {
      {
#line 947
      tmp___14 = paranoia_version();
#line 947
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Using paranoia library version: %s",
              tmp___14);
#line 947
      fputc('\n', stderr);
      }
    }
#line 947
    if (reportfile) {
      {
#line 947
      tmp___15 = paranoia_version();
#line 947
      fprintf((FILE */* __restrict  */)reportfile, (char const   */* __restrict  */)"Using paranoia library version: %s",
              tmp___15);
#line 947
      fputc('\n', reportfile);
      }
    }
  }
#line 952
  if (force_cooked_device) {
    {
#line 953
    d = cdda_identify_cooked((char const   *)force_cooked_device, verbose, (char **)((void *)0));
    }
  } else
#line 954
  if (force_generic_device) {
    {
#line 955
    d = cdda_identify_scsi((char const   *)force_generic_device, (char const   *)force_cdrom_device,
                           verbose, (char **)((void *)0));
    }
  } else
#line 957
  if (force_cdrom_device) {
    {
#line 958
    d = cdda_identify((char const   *)force_cdrom_device, verbose, (char **)((void *)0));
    }
  } else
#line 960
  if (search) {
    {
#line 961
    d = cdda_find_a_cdrom(verbose, (char **)((void *)0));
    }
  } else {
    {
#line 965
    tmp___16 = lstat((char const   */* __restrict  */)"/dev/cdrom", (struct stat */* __restrict  */)(& s));
    }
#line 965
    if (tmp___16) {
      {
#line 967
      d = cdda_find_a_cdrom(verbose, (char **)((void *)0));
      }
    } else {
      {
#line 969
      d = cdda_identify("/dev/cdrom", verbose, (char **)((void *)0));
      }
#line 970
      if ((unsigned long )d == (unsigned long )((void *)0)) {
#line 970
        if (! verbose) {
#line 971
          verbose = 1;
#line 972
          if (! quiet) {
            {
#line 972
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n/dev/cdrom exists but isn\'t accessible.  By default,\ncdparanoia stops searching for an accessible drive here.\nConsider using -sv to force a more complete autosense\nof the machine.\n\nMore information about /dev/cdrom:");
#line 972
            fputc('\n', stderr);
            }
          }
#line 972
          if (reportfile) {
            {
#line 972
            fprintf((FILE */* __restrict  */)reportfile, (char const   */* __restrict  */)"\n/dev/cdrom exists but isn\'t accessible.  By default,\ncdparanoia stops searching for an accessible drive here.\nConsider using -sv to force a more complete autosense\nof the machine.\n\nMore information about /dev/cdrom:");
#line 972
            fputc('\n', reportfile);
            }
          }
          {
#line 977
          d = cdda_identify("/dev/cdrom", 1, (char **)((void *)0));
          }
#line 978
          if (! quiet) {
            {
#line 978
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
#line 978
            fputc('\n', stderr);
            }
          }
#line 978
          if (reportfile) {
            {
#line 978
            fprintf((FILE */* __restrict  */)reportfile, (char const   */* __restrict  */)"\n");
#line 978
            fputc('\n', reportfile);
            }
          }
          {
#line 979
          exit(1);
          }
        } else {
#line 970
          goto _L___1;
        }
      } else {
        _L___1: /* CIL Label */ 
#line 981
        if (! quiet) {
          {
#line 981
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" ");
#line 981
          fputc('\n', stderr);
          }
        }
#line 981
        if (reportfile) {
          {
#line 981
          fprintf((FILE */* __restrict  */)reportfile, (char const   */* __restrict  */)" ");
#line 981
          fputc('\n', reportfile);
          }
        }
      }
    }
  }
#line 985
  if (! d) {
#line 986
    if (! verbose) {
#line 987
      if (! quiet) {
        {
#line 987
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\nUnable to open cdrom drive; -v will give more information.");
#line 987
        fputc('\n', stderr);
        }
      }
#line 987
      if (reportfile) {
        {
#line 987
        fprintf((FILE */* __restrict  */)reportfile, (char const   */* __restrict  */)"\nUnable to open cdrom drive; -v will give more information.");
#line 987
        fputc('\n', reportfile);
        }
      }
    }
    {
#line 988
    exit(1);
    }
  }
#line 991
  if (verbose) {
    {
#line 992
    cdda_verbose_set(d, 1, 1);
    }
  } else {
    {
#line 994
    cdda_verbose_set(d, 1, 0);
    }
  }
#line 997
  if (force_cdrom_endian != -1) {
#line 998
    d->bigendianp = force_cdrom_endian;
    {
#line 1000
    if (force_cdrom_endian == 0) {
#line 1000
      goto case_0;
    }
#line 1003
    if (force_cdrom_endian == 1) {
#line 1003
      goto case_1;
    }
#line 999
    goto switch_break___0;
    case_0: /* CIL Label */ 
#line 1001
    if (! quiet) {
      {
#line 1001
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Forcing CDROM sense to little-endian; ignoring preset and autosense");
#line 1001
      fputc('\n', stderr);
      }
    }
#line 1001
    if (reportfile) {
      {
#line 1001
      fprintf((FILE */* __restrict  */)reportfile, (char const   */* __restrict  */)"Forcing CDROM sense to little-endian; ignoring preset and autosense");
#line 1001
      fputc('\n', reportfile);
      }
    }
#line 1002
    goto switch_break___0;
    case_1: /* CIL Label */ 
#line 1004
    if (! quiet) {
      {
#line 1004
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Forcing CDROM sense to big-endian; ignoring preset and autosense");
#line 1004
      fputc('\n', stderr);
      }
    }
#line 1004
    if (reportfile) {
      {
#line 1004
      fprintf((FILE */* __restrict  */)reportfile, (char const   */* __restrict  */)"Forcing CDROM sense to big-endian; ignoring preset and autosense");
#line 1004
      fputc('\n', reportfile);
      }
    }
#line 1005
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
  }
#line 1008
  if (force_cdrom_sectors != -1) {
#line 1009
    if (force_cdrom_sectors < 0) {
#line 1009
      goto _L___2;
    } else
#line 1009
    if (force_cdrom_sectors > 100) {
      _L___2: /* CIL Label */ 
#line 1010
      if (! quiet) {
        {
#line 1010
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Default sector read size must be 1<= n <= 100\n");
#line 1010
        fputc('\n', stderr);
        }
      }
#line 1010
      if (reportfile) {
        {
#line 1010
        fprintf((FILE */* __restrict  */)reportfile, (char const   */* __restrict  */)"Default sector read size must be 1<= n <= 100\n");
#line 1010
        fputc('\n', reportfile);
        }
      }
      {
#line 1011
      cdda_close(d);
#line 1012
      d = (cdrom_drive *)((void *)0);
#line 1013
      exit(1);
      }
    }
#line 1015
    if (! quiet) {
      {
#line 1015
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Forcing default to read %d sectors; ignoring preset and autosense",
              force_cdrom_sectors);
#line 1015
      fputc('\n', stderr);
      }
    }
#line 1015
    if (reportfile) {
      {
#line 1015
      fprintf((FILE */* __restrict  */)reportfile, (char const   */* __restrict  */)"Forcing default to read %d sectors; ignoring preset and autosense",
              force_cdrom_sectors);
#line 1015
      fputc('\n', reportfile);
      }
    }
#line 1017
    d->nsectors = force_cdrom_sectors;
#line 1018
    d->bigbuff = (long )(force_cdrom_sectors * 2352);
  }
#line 1020
  if (force_cdrom_overlap != -1) {
#line 1021
    if (force_cdrom_overlap < 0) {
#line 1021
      goto _L___3;
    } else
#line 1021
    if (force_cdrom_overlap > 75) {
      _L___3: /* CIL Label */ 
#line 1022
      if (! quiet) {
        {
#line 1022
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Search overlap sectors must be 0<= n <=75\n");
#line 1022
        fputc('\n', stderr);
        }
      }
#line 1022
      if (reportfile) {
        {
#line 1022
        fprintf((FILE */* __restrict  */)reportfile, (char const   */* __restrict  */)"Search overlap sectors must be 0<= n <=75\n");
#line 1022
        fputc('\n', reportfile);
        }
      }
      {
#line 1023
      cdda_close(d);
#line 1024
      d = (cdrom_drive *)((void *)0);
#line 1025
      exit(1);
      }
    }
#line 1027
    if (! quiet) {
      {
#line 1027
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Forcing search overlap to %d sectors; ignoring autosense",
              force_cdrom_overlap);
#line 1027
      fputc('\n', stderr);
      }
    }
#line 1027
    if (reportfile) {
      {
#line 1027
      fprintf((FILE */* __restrict  */)reportfile, (char const   */* __restrict  */)"Forcing search overlap to %d sectors; ignoring autosense",
              force_cdrom_overlap);
#line 1027
      fputc('\n', reportfile);
      }
    }
  }
  {
#line 1031
  tmp___17 = cdda_open(d);
  }
  {
#line 1032
  if (tmp___17 == -5) {
#line 1032
    goto case_neg_5;
  }
#line 1032
  if (tmp___17 == -4) {
#line 1032
    goto case_neg_5;
  }
#line 1032
  if (tmp___17 == -3) {
#line 1032
    goto case_neg_5;
  }
#line 1032
  if (tmp___17 == -2) {
#line 1032
    goto case_neg_5;
  }
#line 1035
  if (tmp___17 == -6) {
#line 1035
    goto case_neg_6;
  }
#line 1038
  if (tmp___17 == 0) {
#line 1038
    goto case_0___0;
  }
#line 1040
  goto switch_default___0;
  case_neg_5: /* CIL Label */ 
  case_neg_4: /* CIL Label */ 
  case_neg_3: /* CIL Label */ 
  case_neg_2: /* CIL Label */ 
#line 1033
  if (! quiet) {
    {
#line 1033
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\nUnable to open disc.  Is there an audio CD in the drive?");
#line 1033
    fputc('\n', stderr);
    }
  }
#line 1033
  if (reportfile) {
    {
#line 1033
    fprintf((FILE */* __restrict  */)reportfile, (char const   */* __restrict  */)"\nUnable to open disc.  Is there an audio CD in the drive?");
#line 1033
    fputc('\n', reportfile);
    }
  }
  {
#line 1034
  exit(1);
  }
  case_neg_6: /* CIL Label */ 
#line 1036
  if (! quiet) {
    {
#line 1036
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\ncdparanoia could not find a way to read audio from this drive.");
#line 1036
    fputc('\n', stderr);
    }
  }
#line 1036
  if (reportfile) {
    {
#line 1036
    fprintf((FILE */* __restrict  */)reportfile, (char const   */* __restrict  */)"\ncdparanoia could not find a way to read audio from this drive.");
#line 1036
    fputc('\n', reportfile);
    }
  }
  {
#line 1037
  exit(1);
  }
  case_0___0: /* CIL Label */ 
#line 1039
  goto switch_break___1;
  switch_default___0: /* CIL Label */ 
#line 1041
  if (! quiet) {
    {
#line 1041
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\nUnable to open disc.");
#line 1041
    fputc('\n', stderr);
    }
  }
#line 1041
  if (reportfile) {
    {
#line 1041
    fprintf((FILE */* __restrict  */)reportfile, (char const   */* __restrict  */)"\nUnable to open disc.");
#line 1041
    fputc('\n', reportfile);
    }
  }
  {
#line 1042
  exit(1);
  }
  switch_break___1: /* CIL Label */ ;
  }
#line 1045
  if (force_cdrom_speed == 0) {
#line 1045
    force_cdrom_speed = -1;
  }
#line 1046
  if (force_cdrom_speed != -1) {
#line 1047
    if (! quiet) {
      {
#line 1047
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\nAttempting to set speed to %dx... ",
              force_cdrom_speed);
#line 1047
      fputc('\n', stderr);
      }
    }
#line 1047
    if (reportfile) {
      {
#line 1047
      fprintf((FILE */* __restrict  */)reportfile, (char const   */* __restrict  */)"\nAttempting to set speed to %dx... ",
              force_cdrom_speed);
#line 1047
      fputc('\n', reportfile);
      }
    }
  } else
#line 1049
  if (verbose) {
#line 1050
    if (! quiet) {
      {
#line 1050
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\nAttempting to set cdrom to full speed... ");
#line 1050
      fputc('\n', stderr);
      }
    }
#line 1050
    if (reportfile) {
      {
#line 1050
      fprintf((FILE */* __restrict  */)reportfile, (char const   */* __restrict  */)"\nAttempting to set cdrom to full speed... ");
#line 1050
      fputc('\n', reportfile);
      }
    }
  }
  {
#line 1053
  tmp___18 = cdda_speed_set(d, force_cdrom_speed);
  }
#line 1053
  if (tmp___18) {
#line 1054
    if (verbose) {
#line 1054
      goto _L___4;
    } else
#line 1054
    if (force_cdrom_speed != -1) {
      _L___4: /* CIL Label */ 
#line 1055
      if (! quiet) {
        {
#line 1055
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\tCDROM speed set FAILED. Continuing anyway...");
#line 1055
        fputc('\n', stderr);
        }
      }
#line 1055
      if (reportfile) {
        {
#line 1055
        fprintf((FILE */* __restrict  */)reportfile, (char const   */* __restrict  */)"\tCDROM speed set FAILED. Continuing anyway...");
#line 1055
        fputc('\n', reportfile);
        }
      }
    }
  } else
#line 1057
  if (verbose) {
#line 1058
    if (! quiet) {
      {
#line 1058
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\tdrive returned OK.");
#line 1058
      fputc('\n', stderr);
      }
    }
#line 1058
    if (reportfile) {
      {
#line 1058
      fprintf((FILE */* __restrict  */)reportfile, (char const   */* __restrict  */)"\tdrive returned OK.");
#line 1058
      fputc('\n', reportfile);
      }
    }
  }
#line 1061
  if (run_cache_test) {
    {
#line 1062
    tmp___19 = analyze_cache(d, stderr, reportfile, force_cdrom_speed);
#line 1062
    warn = tmp___19;
    }
#line 1064
    if (warn == 0) {
#line 1065
      if (! quiet) {
        {
#line 1065
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\nDrive tests OK with Paranoia.\n\n");
        }
      }
#line 1065
      if (reportfile) {
        {
#line 1065
        fprintf((FILE */* __restrict  */)reportfile, (char const   */* __restrict  */)"\nDrive tests OK with Paranoia.\n\n");
        }
      }
#line 1066
      return (0);
    }
#line 1069
    if (warn == 1) {
#line 1070
      if (! quiet) {
        {
#line 1070
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\nWARNING! PARANOIA MAY NOT BE TRUSTWORTHY WITH THIS DRIVE!\n\nThe Paranoia library may not model this CDROM drive\'s cache\ncorrectly according to this analysis run. Analysis is not\nalways accurate (it can be fooled by machine load or random\nkernel latencies), but if a failed result happens more often\nthan one time in twenty on an unloaded machine, please mail\nthe %s file produced by this failed analysis to\nparanoia-dev@xiph.org to assist developers in extending\nParanoia to handle this CDROM properly.\n\n",
                reportfile_name);
        }
      }
#line 1070
      if (reportfile) {
        {
#line 1070
        fprintf((FILE */* __restrict  */)reportfile, (char const   */* __restrict  */)"\nWARNING! PARANOIA MAY NOT BE TRUSTWORTHY WITH THIS DRIVE!\n\nThe Paranoia library may not model this CDROM drive\'s cache\ncorrectly according to this analysis run. Analysis is not\nalways accurate (it can be fooled by machine load or random\nkernel latencies), but if a failed result happens more often\nthan one time in twenty on an unloaded machine, please mail\nthe %s file produced by this failed analysis to\nparanoia-dev@xiph.org to assist developers in extending\nParanoia to handle this CDROM properly.\n\n",
                reportfile_name);
        }
      }
    }
#line 1079
    return (1);
  }
#line 1084
  if (query_only) {
    {
#line 1084
    display_toc(d);
    }
  } else
#line 1084
  if (verbose) {
    {
#line 1084
    display_toc(d);
    }
  }
#line 1085
  if (query_only) {
    {
#line 1085
    exit(0);
    }
  }
#line 1091
  if (sample_offset) {
#line 1092
    toc_offset += sample_offset / 588;
#line 1093
    sample_offset %= 588;
#line 1094
    if (sample_offset < 0) {
#line 1095
      sample_offset += 588;
#line 1096
      toc_offset --;
    }
  }
#line 1100
  if (toc_bias) {
    {
#line 1101
    tmp___20 = cdda_track_firstsector(d, 1);
#line 1101
    toc_offset = (int )(- tmp___20);
    }
  }
#line 1103
  i = 0;
  {
#line 1103
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 1103
    if (! (i < d->tracks + 1)) {
#line 1103
      goto while_break___2;
    }
#line 1104
    d->disc_toc[i].dwStartSector += toc_offset;
#line 1103
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 1107
  if (d->nsectors == 1) {
#line 1108
    if (! quiet) {
      {
#line 1108
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"WARNING: The autosensed/selected sectors per read value is\n         one sector, making it very unlikely Paranoia can \n         work.\n\n         Attempting to continue...\n\n");
#line 1108
      fputc('\n', stderr);
      }
    }
#line 1108
    if (reportfile) {
      {
#line 1108
      fprintf((FILE */* __restrict  */)reportfile, (char const   */* __restrict  */)"WARNING: The autosensed/selected sectors per read value is\n         one sector, making it very unlikely Paranoia can \n         work.\n\n         Attempting to continue...\n\n");
#line 1108
      fputc('\n', reportfile);
      }
    }
  }
#line 1123
  if (span) {
    {
#line 1125
    tmp___21 = strchr((char const   *)span, '-');
#line 1125
    span2 = tmp___21;
#line 1126
    tmp___22 = strrchr((char const   *)span, '-');
    }
#line 1126
    if ((unsigned long )tmp___22 != (unsigned long )span2) {
#line 1127
      if (! quiet) {
        {
#line 1127
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error parsing span argument");
#line 1127
        fputc('\n', stderr);
        }
      }
#line 1127
      if (reportfile) {
        {
#line 1127
        fprintf((FILE */* __restrict  */)reportfile, (char const   */* __restrict  */)"Error parsing span argument");
#line 1127
        fputc('\n', reportfile);
        }
      }
      {
#line 1128
      cdda_close(d);
#line 1129
      d = (cdrom_drive *)((void *)0);
#line 1130
      exit(1);
      }
    }
#line 1133
    if ((unsigned long )span2 != (unsigned long )((void *)0)) {
#line 1134
      *span2 = (char )'\000';
#line 1135
      span2 ++;
    }
    {
#line 1138
    first_sector = parse_offset(d, span, -1);
    }
#line 1139
    if (first_sector == -1L) {
      {
#line 1140
      tmp___23 = cdda_disc_firstsector(d);
#line 1140
      last_sector = parse_offset(d, span2, (int )tmp___23);
      }
    } else {
      {
#line 1142
      last_sector = parse_offset(d, span2, (int )first_sector);
      }
    }
#line 1144
    if (first_sector == -1L) {
#line 1145
      if (last_sector == -1L) {
#line 1146
        if (! quiet) {
          {
#line 1146
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error parsing span argument");
#line 1146
          fputc('\n', stderr);
          }
        }
#line 1146
        if (reportfile) {
          {
#line 1146
          fprintf((FILE */* __restrict  */)reportfile, (char const   */* __restrict  */)"Error parsing span argument");
#line 1146
          fputc('\n', reportfile);
          }
        }
        {
#line 1147
        cdda_close(d);
#line 1148
        d = (cdrom_drive *)((void *)0);
#line 1149
        exit(1);
        }
      } else {
        {
#line 1151
        first_sector = cdda_disc_firstsector(d);
        }
      }
    } else
#line 1154
    if (last_sector == -1L) {
#line 1155
      if (span2) {
        {
#line 1156
        last_sector = cdda_disc_lastsector(d);
        }
      } else {
        {
#line 1158
        tmp___24 = cdda_sector_gettrack(d, first_sector);
#line 1158
        last_sector = cdda_track_lastsector(d, tmp___24);
        }
      }
    }
  } else {
    {
#line 1164
    first_sector = cdda_disc_firstsector(d);
#line 1165
    last_sector = cdda_disc_lastsector(d);
    }
  }
  {
#line 1169
  tmp___25 = cdda_sector_gettrack(d, first_sector);
#line 1169
  track1 = tmp___25;
#line 1170
  tmp___26 = cdda_sector_gettrack(d, last_sector);
#line 1170
  track2 = tmp___26;
#line 1171
  tmp___27 = cdda_track_firstsector(d, track1);
#line 1171
  off1 = first_sector - tmp___27;
#line 1172
  tmp___28 = cdda_track_firstsector(d, track2);
#line 1172
  off2 = last_sector - tmp___28;
#line 1175
  i___2 = track1;
  }
  {
#line 1175
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 1175
    if (! (i___2 <= track2)) {
#line 1175
      goto while_break___3;
    }
    {
#line 1176
    tmp___29 = cdda_track_audiop(d, i___2);
    }
#line 1176
    if (! tmp___29) {
#line 1177
      if (! quiet) {
        {
#line 1177
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Selected span contains non audio tracks.  Aborting.\n\n");
#line 1177
        fputc('\n', stderr);
        }
      }
#line 1177
      if (reportfile) {
        {
#line 1177
        fprintf((FILE */* __restrict  */)reportfile, (char const   */* __restrict  */)"Selected span contains non audio tracks.  Aborting.\n\n");
#line 1177
        fputc('\n', reportfile);
        }
      }
      {
#line 1178
      exit(1);
      }
    }
#line 1175
    i___2 ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 1181
  if (! quiet) {
    {
#line 1181
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Ripping from sector %7ld (track %2d [%d:%02d.%02d])\n\t  to sector %7ld (track %2d [%d:%02d.%02d])\n",
            first_sector, track1, (int )(off1 / 4500L), (int )((off1 / 75L) % 60L),
            (int )(off1 % 75L), last_sector, track2, (int )(off2 / 4500L), (int )((off2 / 75L) % 60L),
            (int )(off2 % 75L));
#line 1181
    fputc('\n', stderr);
    }
  }
#line 1181
  if (reportfile) {
    {
#line 1181
    fprintf((FILE */* __restrict  */)reportfile, (char const   */* __restrict  */)"Ripping from sector %7ld (track %2d [%d:%02d.%02d])\n\t  to sector %7ld (track %2d [%d:%02d.%02d])\n",
            first_sector, track1, (int )(off1 / 4500L), (int )((off1 / 75L) % 60L),
            (int )(off1 % 75L), last_sector, track2, (int )(off2 / 4500L), (int )((off2 / 75L) % 60L),
            (int )(off2 % 75L));
#line 1181
    fputc('\n', reportfile);
    }
  }
  {
#line 1192
  offset_buffer_used = 0;
#line 1193
  offset_skip = sample_offset * 4;
#line 1195
  p = paranoia_init(d);
#line 1196
  paranoia_modeset(p, paranoia_mode);
  }
#line 1197
  if (force_cdrom_overlap != -1) {
    {
#line 1197
    paranoia_overlapset(p, (long )force_cdrom_overlap);
    }
  }
#line 1199
  if (verbose) {
    {
#line 1200
    cdda_verbose_set(d, 2, 2);
    }
  } else {
    {
#line 1202
    cdda_verbose_set(d, 0, 0);
    }
  }
  {
#line 1204
  cursor = first_sector;
#line 1204
  paranoia_seek(p, cursor, 0);
#line 1207
  tmp___30 = getuid();
#line 1207
  seteuid(tmp___30);
#line 1208
  tmp___31 = getgid();
#line 1208
  setegid(tmp___31);
  }
#line 1215
  if (sample_offset) {
#line 1216
    (d->disc_toc[d->tracks].dwStartSector) ++;
  }
  {
#line 1218
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 1218
    if (! (cursor <= last_sector)) {
#line 1218
      goto while_break___4;
    }
#line 1220
    if (batch) {
      {
#line 1221
      batch_first = cursor;
#line 1222
      batch_track = cdda_sector_gettrack(d, cursor);
#line 1222
      batch_last = cdda_track_lastsector(d, batch_track);
      }
#line 1225
      if (batch_last > last_sector) {
#line 1225
        batch_last = last_sector;
      }
    } else {
#line 1227
      batch_first = first_sector;
#line 1228
      batch_last = last_sector;
#line 1229
      batch_track = -1;
    }
#line 1232
    callbegin = batch_first;
#line 1233
    callend = batch_last;
#line 1237
    if (optind + 1 < argc) {
      {
#line 1238
      tmp___40 = strcmp((char const   *)*(argv + (optind + 1)), "-");
      }
#line 1238
      if (tmp___40) {
        {
#line 1251
        tmp___33 = strrchr((char const   *)*(argv + (optind + 1)), '/');
#line 1251
        post = tmp___33;
        }
#line 1252
        if (post) {
#line 1252
          tmp___34 = (post - *(argv + (optind + 1))) + 1L;
        } else {
#line 1252
          tmp___34 = 0L;
        }
#line 1252
        pos = (int )tmp___34;
#line 1253
        file = *(argv + (optind + 1)) + pos;
#line 1255
        path[0] = (char )'\000';
#line 1257
        if (pos) {
#line 1258
          if (pos > 256) {
#line 1258
            tmp___35 = 256;
          } else {
#line 1258
            tmp___35 = pos;
          }
          {
#line 1258
          strncat((char */* __restrict  */)(path), (char const   */* __restrict  */)*(argv + (optind + 1)),
                  (size_t )tmp___35);
          }
        }
#line 1260
        if (batch) {
          {
#line 1261
          snprintf((char */* __restrict  */)(outfile_name), (size_t )246, (char const   */* __restrict  */)"%strack%02d.%s",
                   path, batch_track, file);
          }
        } else {
          {
#line 1263
          snprintf((char */* __restrict  */)(outfile_name), (size_t )246, (char const   */* __restrict  */)"%s%s",
                   path, file);
          }
        }
#line 1265
        if ((int )*(file + 0) == 0) {
          {
#line 1267
          if (output_type == 0) {
#line 1267
            goto case_0___1;
          }
#line 1270
          if (output_type == 1) {
#line 1270
            goto case_1___0;
          }
#line 1273
          if (output_type == 2) {
#line 1273
            goto case_2;
          }
#line 1276
          if (output_type == 3) {
#line 1276
            goto case_3;
          }
#line 1266
          goto switch_break___2;
          case_0___1: /* CIL Label */ 
          {
#line 1268
          strcat((char */* __restrict  */)(outfile_name), (char const   */* __restrict  */)"cdda.raw");
          }
#line 1269
          goto switch_break___2;
          case_1___0: /* CIL Label */ 
          {
#line 1271
          strcat((char */* __restrict  */)(outfile_name), (char const   */* __restrict  */)"cdda.wav");
          }
#line 1272
          goto switch_break___2;
          case_2: /* CIL Label */ 
          {
#line 1274
          strcat((char */* __restrict  */)(outfile_name), (char const   */* __restrict  */)"cdda.aifc");
          }
#line 1275
          goto switch_break___2;
          case_3: /* CIL Label */ 
          {
#line 1277
          strcat((char */* __restrict  */)(outfile_name), (char const   */* __restrict  */)"cdda.aiff");
          }
#line 1278
          goto switch_break___2;
          switch_break___2: /* CIL Label */ ;
          }
        }
        {
#line 1282
        out = open((char const   *)(outfile_name), 578, 438);
        }
#line 1283
        if (out == -1) {
#line 1284
          if (! quiet) {
            {
#line 1284
            tmp___36 = __errno_location();
#line 1284
            tmp___37 = strerror(*tmp___36);
#line 1284
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Cannot open specified output file %s: %s",
                    outfile_name, tmp___37);
#line 1284
            fputc('\n', stderr);
            }
          }
#line 1284
          if (reportfile) {
            {
#line 1284
            tmp___38 = __errno_location();
#line 1284
            tmp___39 = strerror(*tmp___38);
#line 1284
            fprintf((FILE */* __restrict  */)reportfile, (char const   */* __restrict  */)"Cannot open specified output file %s: %s",
                    outfile_name, tmp___39);
#line 1284
            fputc('\n', reportfile);
            }
          }
          {
#line 1286
          cdda_close(d);
#line 1287
          d = (cdrom_drive *)((void *)0);
#line 1288
          exit(1);
          }
        }
#line 1290
        if (! quiet) {
          {
#line 1290
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"outputting to %s\n",
                  outfile_name);
#line 1290
          fputc('\n', stderr);
          }
        }
#line 1290
        if (reportfile) {
          {
#line 1290
          fprintf((FILE */* __restrict  */)reportfile, (char const   */* __restrict  */)"outputting to %s\n",
                  outfile_name);
#line 1290
          fputc('\n', reportfile);
          }
        }
#line 1291
        if (logfile) {
          {
#line 1292
          fprintf((FILE */* __restrict  */)logfile, (char const   */* __restrict  */)"outputting to %s\n",
                  outfile_name);
#line 1293
          fflush(logfile);
          }
        }
      } else {
        {
#line 1239
        tmp___32 = fileno(stdout);
#line 1239
        out = dup(tmp___32);
        }
#line 1240
        if (batch) {
#line 1240
          if (! quiet) {
            {
#line 1240
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Are you sure you wanted \'batch\' (-B) output with stdout?");
#line 1240
            fputc('\n', stderr);
            }
          }
#line 1240
          if (reportfile) {
            {
#line 1240
            fprintf((FILE */* __restrict  */)reportfile, (char const   */* __restrict  */)"Are you sure you wanted \'batch\' (-B) output with stdout?");
#line 1240
            fputc('\n', reportfile);
            }
          }
        }
#line 1242
        if (! quiet) {
          {
#line 1242
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"outputting to stdout\n");
#line 1242
          fputc('\n', stderr);
          }
        }
#line 1242
        if (reportfile) {
          {
#line 1242
          fprintf((FILE */* __restrict  */)reportfile, (char const   */* __restrict  */)"outputting to stdout\n");
#line 1242
          fputc('\n', reportfile);
          }
        }
#line 1243
        if (logfile) {
          {
#line 1244
          fprintf((FILE */* __restrict  */)logfile, (char const   */* __restrict  */)"outputting to stdout\n");
#line 1245
          fflush(logfile);
          }
        }
#line 1247
        outfile_name[0] = (char )'\000';
      }
    } else {
#line 1298
      if (batch) {
        {
#line 1299
        sprintf((char */* __restrict  */)(outfile_name), (char const   */* __restrict  */)"track%02d.",
                batch_track);
        }
      } else {
#line 1301
        outfile_name[0] = (char )'\000';
      }
      {
#line 1304
      if (output_type == 0) {
#line 1304
        goto case_0___2;
      }
#line 1307
      if (output_type == 1) {
#line 1307
        goto case_1___1;
      }
#line 1310
      if (output_type == 2) {
#line 1310
        goto case_2___0;
      }
#line 1313
      if (output_type == 3) {
#line 1313
        goto case_3___0;
      }
#line 1303
      goto switch_break___3;
      case_0___2: /* CIL Label */ 
      {
#line 1305
      strcat((char */* __restrict  */)(outfile_name), (char const   */* __restrict  */)"cdda.raw");
      }
#line 1306
      goto switch_break___3;
      case_1___1: /* CIL Label */ 
      {
#line 1308
      strcat((char */* __restrict  */)(outfile_name), (char const   */* __restrict  */)"cdda.wav");
      }
#line 1309
      goto switch_break___3;
      case_2___0: /* CIL Label */ 
      {
#line 1311
      strcat((char */* __restrict  */)(outfile_name), (char const   */* __restrict  */)"cdda.aifc");
      }
#line 1312
      goto switch_break___3;
      case_3___0: /* CIL Label */ 
      {
#line 1314
      strcat((char */* __restrict  */)(outfile_name), (char const   */* __restrict  */)"cdda.aiff");
      }
#line 1315
      goto switch_break___3;
      switch_break___3: /* CIL Label */ ;
      }
      {
#line 1318
      out = open((char const   *)(outfile_name), 578, 438);
      }
#line 1319
      if (out == -1) {
#line 1320
        if (! quiet) {
          {
#line 1320
          tmp___41 = __errno_location();
#line 1320
          tmp___42 = strerror(*tmp___41);
#line 1320
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Cannot open default output file %s: %s",
                  outfile_name, tmp___42);
#line 1320
          fputc('\n', stderr);
          }
        }
#line 1320
        if (reportfile) {
          {
#line 1320
          tmp___43 = __errno_location();
#line 1320
          tmp___44 = strerror(*tmp___43);
#line 1320
          fprintf((FILE */* __restrict  */)reportfile, (char const   */* __restrict  */)"Cannot open default output file %s: %s",
                  outfile_name, tmp___44);
#line 1320
          fputc('\n', reportfile);
          }
        }
        {
#line 1322
        cdda_close(d);
#line 1323
        d = (cdrom_drive *)((void *)0);
#line 1324
        exit(1);
        }
      }
#line 1326
      if (! quiet) {
        {
#line 1326
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"outputting to %s\n",
                outfile_name);
#line 1326
        fputc('\n', stderr);
        }
      }
#line 1326
      if (reportfile) {
        {
#line 1326
        fprintf((FILE */* __restrict  */)reportfile, (char const   */* __restrict  */)"outputting to %s\n",
                outfile_name);
#line 1326
        fputc('\n', reportfile);
        }
      }
#line 1327
      if (logfile) {
        {
#line 1328
        fprintf((FILE */* __restrict  */)logfile, (char const   */* __restrict  */)"outputting to %s\n",
                outfile_name);
#line 1329
        fflush(logfile);
        }
      }
    }
    {
#line 1334
    if (output_type == 0) {
#line 1334
      goto case_0___3;
    }
#line 1336
    if (output_type == 1) {
#line 1336
      goto case_1___2;
    }
#line 1339
    if (output_type == 2) {
#line 1339
      goto case_2___1;
    }
#line 1342
    if (output_type == 3) {
#line 1342
      goto case_3___1;
    }
#line 1333
    goto switch_break___4;
    case_0___3: /* CIL Label */ 
#line 1335
    goto switch_break___4;
    case_1___2: /* CIL Label */ 
    {
#line 1337
    WriteWav(out, ((batch_last - batch_first) + 1L) * 2352L);
    }
#line 1338
    goto switch_break___4;
    case_2___1: /* CIL Label */ 
    {
#line 1340
    WriteAifc(out, ((batch_last - batch_first) + 1L) * 2352L);
    }
#line 1341
    goto switch_break___4;
    case_3___1: /* CIL Label */ 
    {
#line 1343
    WriteAiff(out, ((batch_last - batch_first) + 1L) * 2352L);
    }
#line 1344
    goto switch_break___4;
    switch_break___4: /* CIL Label */ ;
    }
#line 1349
    if (offset_buffer_used) {
      {
#line 1351
      cursor ++;
#line 1352
      tmp___49 = buffering_write(out, (char *)(offset_buffer) + offset_buffer_used,
                                 (long )(2352 - offset_buffer_used));
      }
#line 1352
      if (tmp___49) {
#line 1355
        if (! quiet) {
          {
#line 1355
          tmp___45 = __errno_location();
#line 1355
          tmp___46 = strerror(*tmp___45);
#line 1355
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error writing output: %s",
                  tmp___46);
#line 1355
          fputc('\n', stderr);
          }
        }
#line 1355
        if (reportfile) {
          {
#line 1355
          tmp___47 = __errno_location();
#line 1355
          tmp___48 = strerror(*tmp___47);
#line 1355
          fprintf((FILE */* __restrict  */)reportfile, (char const   */* __restrict  */)"Error writing output: %s",
                  tmp___48);
#line 1355
          fputc('\n', reportfile);
          }
        }
        {
#line 1356
        exit(1);
        }
      }
    }
#line 1360
    skipped_flag = 0;
    {
#line 1361
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 1361
      if (! (cursor <= batch_last)) {
#line 1361
        goto while_break___5;
      }
      {
#line 1363
      tmp___50 = paranoia_read_limited(p, & callback, max_retries);
#line 1363
      readbuf = tmp___50;
#line 1364
      tmp___51 = cdda_errors(d);
#line 1364
      err = tmp___51;
#line 1365
      tmp___52 = cdda_messages(d);
#line 1365
      mes = tmp___52;
      }
#line 1367
      if (mes) {
#line 1367
        goto _L___5;
      } else
#line 1367
      if (err) {
        _L___5: /* CIL Label */ 
#line 1368
        if (err) {
#line 1368
          tmp___53 = (char const   *)err;
        } else {
#line 1368
          tmp___53 = "";
        }
#line 1368
        if (mes) {
#line 1368
          tmp___54 = (char const   *)mes;
        } else {
#line 1368
          tmp___54 = "";
        }
        {
#line 1368
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\r                                                                          \r%s%s\n",
                tmp___54, tmp___53);
        }
      }
#line 1372
      if (err) {
        {
#line 1372
        free((void *)err);
        }
      }
#line 1373
      if (mes) {
        {
#line 1373
        free((void *)mes);
        }
      }
#line 1374
      if ((unsigned long )readbuf == (unsigned long )((void *)0)) {
        {
#line 1375
        tmp___55 = __errno_location();
        }
#line 1375
        if (*tmp___55 == 9) {
#line 1375
          goto _L___6;
        } else {
          {
#line 1375
          tmp___56 = __errno_location();
          }
#line 1375
          if (*tmp___56 == 123) {
            _L___6: /* CIL Label */ 
#line 1380
            if (! quiet) {
              {
#line 1380
              fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\nparanoia_read: CDROM drive unavailable, bailing.\n");
#line 1380
              fputc('\n', stderr);
              }
            }
#line 1380
            if (reportfile) {
              {
#line 1380
              fprintf((FILE */* __restrict  */)reportfile, (char const   */* __restrict  */)"\nparanoia_read: CDROM drive unavailable, bailing.\n");
#line 1380
              fputc('\n', reportfile);
              }
            }
            {
#line 1381
            exit(1);
            }
          }
        }
#line 1383
        skipped_flag = 1;
#line 1384
        if (! quiet) {
          {
#line 1384
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\nparanoia_read: Unrecoverable error, bailing.\n");
#line 1384
          fputc('\n', stderr);
          }
        }
#line 1384
        if (reportfile) {
          {
#line 1384
          fprintf((FILE */* __restrict  */)reportfile, (char const   */* __restrict  */)"\nparanoia_read: Unrecoverable error, bailing.\n");
#line 1384
          fputc('\n', reportfile);
          }
        }
#line 1385
        goto while_break___5;
      }
#line 1387
      if (skipped_flag) {
#line 1387
        if (abort_on_skip) {
#line 1388
          cursor = batch_last + 1L;
#line 1389
          goto while_break___5;
        }
      }
      {
#line 1392
      skipped_flag = 0;
#line 1393
      cursor ++;
#line 1395
      tmp___57 = bigendianp();
      }
#line 1395
      if (output_endian != tmp___57) {
#line 1397
        i___3 = 0;
        {
#line 1397
        while (1) {
          while_continue___6: /* CIL Label */ ;
#line 1397
          if (! (i___3 < 1176)) {
#line 1397
            goto while_break___6;
          }
          {
#line 1397
          *(readbuf + i___3) = swap16(*(readbuf + i___3));
#line 1397
          i___3 ++;
          }
        }
        while_break___6: /* CIL Label */ ;
        }
      }
      {
#line 1400
      callback(cursor * 1176L - 1L, -2);
#line 1402
      tmp___62 = buffering_write(out, (char *)readbuf + offset_skip, (long )(2352 - offset_skip));
      }
#line 1402
      if (tmp___62) {
#line 1404
        if (! quiet) {
          {
#line 1404
          tmp___58 = __errno_location();
#line 1404
          tmp___59 = strerror(*tmp___58);
#line 1404
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error writing output: %s",
                  tmp___59);
#line 1404
          fputc('\n', stderr);
          }
        }
#line 1404
        if (reportfile) {
          {
#line 1404
          tmp___60 = __errno_location();
#line 1404
          tmp___61 = strerror(*tmp___60);
#line 1404
          fprintf((FILE */* __restrict  */)reportfile, (char const   */* __restrict  */)"Error writing output: %s",
                  tmp___61);
#line 1404
          fputc('\n', reportfile);
          }
        }
        {
#line 1405
        exit(1);
        }
      }
      {
#line 1407
      offset_skip = 0;
#line 1409
      tmp___63 = bigendianp();
      }
#line 1409
      if (output_endian != tmp___63) {
#line 1411
        i___4 = 0;
        {
#line 1411
        while (1) {
          while_continue___7: /* CIL Label */ ;
#line 1411
          if (! (i___4 < 1176)) {
#line 1411
            goto while_break___7;
          }
          {
#line 1411
          *(readbuf + i___4) = swap16(*(readbuf + i___4));
#line 1411
          i___4 ++;
          }
        }
        while_break___7: /* CIL Label */ ;
        }
      }
#line 1415
      if (sample_offset) {
#line 1415
        if (cursor > batch_last) {
          {
#line 1419
          readbuf = paranoia_read_limited(p, & callback, max_retries);
#line 1420
          err = cdda_errors(d);
#line 1420
          mes = cdda_messages(d);
          }
#line 1422
          if (mes) {
#line 1422
            goto _L___7;
          } else
#line 1422
          if (err) {
            _L___7: /* CIL Label */ 
#line 1423
            if (err) {
#line 1423
              tmp___64 = (char const   *)err;
            } else {
#line 1423
              tmp___64 = "";
            }
#line 1423
            if (mes) {
#line 1423
              tmp___65 = (char const   *)mes;
            } else {
#line 1423
              tmp___65 = "";
            }
            {
#line 1423
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\r                                                                          \r%s%s\n",
                    tmp___65, tmp___64);
            }
          }
#line 1427
          if (err) {
            {
#line 1427
            free((void *)err);
            }
          }
#line 1427
          if (mes) {
            {
#line 1427
            free((void *)mes);
            }
          }
#line 1428
          if ((unsigned long )readbuf == (unsigned long )((void *)0)) {
#line 1429
            skipped_flag = 1;
#line 1430
            if (! quiet) {
              {
#line 1430
              fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\nparanoia_read: Unrecoverable error reading through sample_offset shift\n\tat end of track, bailing.\n");
#line 1430
              fputc('\n', stderr);
              }
            }
#line 1430
            if (reportfile) {
              {
#line 1430
              fprintf((FILE */* __restrict  */)reportfile, (char const   */* __restrict  */)"\nparanoia_read: Unrecoverable error reading through sample_offset shift\n\tat end of track, bailing.\n");
#line 1430
              fputc('\n', reportfile);
              }
            }
#line 1432
            goto while_break___5;
          }
#line 1434
          if (skipped_flag) {
#line 1434
            if (abort_on_skip) {
#line 1434
              goto while_break___5;
            }
          }
          {
#line 1435
          skipped_flag = 0;
#line 1438
          tmp___66 = bigendianp();
          }
#line 1438
          if (output_endian != tmp___66) {
#line 1439
            i___5 = 0;
            {
#line 1439
            while (1) {
              while_continue___8: /* CIL Label */ ;
#line 1439
              if (! (i___5 < 1176)) {
#line 1439
                goto while_break___8;
              }
              {
#line 1440
              offset_buffer[i___5] = swap16(*(readbuf + i___5));
#line 1439
              i___5 ++;
              }
            }
            while_break___8: /* CIL Label */ ;
            }
          } else {
            {
#line 1442
            memcpy((void */* __restrict  */)(offset_buffer), (void const   */* __restrict  */)readbuf,
                   (size_t )2352);
            }
          }
          {
#line 1443
          offset_buffer_used = sample_offset * 4;
#line 1445
          callback(cursor * 1176L, -2);
#line 1447
          tmp___71 = buffering_write(out, (char *)(offset_buffer), (long )offset_buffer_used);
          }
#line 1447
          if (tmp___71) {
#line 1449
            if (! quiet) {
              {
#line 1449
              tmp___67 = __errno_location();
#line 1449
              tmp___68 = strerror(*tmp___67);
#line 1449
              fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error writing output: %s",
                      tmp___68);
#line 1449
              fputc('\n', stderr);
              }
            }
#line 1449
            if (reportfile) {
              {
#line 1449
              tmp___69 = __errno_location();
#line 1449
              tmp___70 = strerror(*tmp___69);
#line 1449
              fprintf((FILE */* __restrict  */)reportfile, (char const   */* __restrict  */)"Error writing output: %s",
                      tmp___70);
#line 1449
              fputc('\n', reportfile);
              }
            }
            {
#line 1450
            exit(1);
            }
          }
        }
      }
    }
    while_break___5: /* CIL Label */ ;
    }
    {
#line 1454
    callback(cursor * 1176L - 1L, -1);
#line 1455
    buffering_close(out);
    }
#line 1456
    if (skipped_flag) {
#line 1458
      if (! quiet) {
        {
#line 1458
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\nRemoving aborted file: %s",
                outfile_name);
#line 1458
        fputc('\n', stderr);
        }
      }
#line 1458
      if (reportfile) {
        {
#line 1458
        fprintf((FILE */* __restrict  */)reportfile, (char const   */* __restrict  */)"\nRemoving aborted file: %s",
                outfile_name);
#line 1458
        fputc('\n', reportfile);
        }
      }
      {
#line 1459
      unlink((char const   *)(outfile_name));
      }
#line 1461
      if (batch_track != -1) {
        {
#line 1462
        batch_track ++;
#line 1463
        cursor = cdda_track_firstsector(d, batch_track);
#line 1464
        paranoia_seek(p, cursor, 0);
#line 1465
        offset_skip = sample_offset * 4;
#line 1466
        offset_buffer_used = 0;
        }
      }
    }
#line 1469
    if (! quiet) {
      {
#line 1469
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
#line 1469
      fputc('\n', stderr);
      }
    }
#line 1469
    if (reportfile) {
      {
#line 1469
      fprintf((FILE */* __restrict  */)reportfile, (char const   */* __restrict  */)"\n");
#line 1469
      fputc('\n', reportfile);
      }
    }
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 1472
  paranoia_free(p);
#line 1473
  p = (void *)0;
  }
#line 1477
  if (! quiet) {
    {
#line 1477
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Done.\n\n");
#line 1477
    fputc('\n', stderr);
    }
  }
#line 1477
  if (reportfile) {
    {
#line 1477
    fprintf((FILE */* __restrict  */)reportfile, (char const   */* __restrict  */)"Done.\n\n");
#line 1477
    fputc('\n', reportfile);
    }
  }
  {
#line 1479
  cdda_close(d);
#line 1480
  d = (cdrom_drive *)((void *)0);
  }
#line 1481
  if (logfile_open) {
    {
#line 1482
    fclose(logfile);
    }
  }
#line 1483
  if (reportfile_open) {
    {
#line 1484
    fclose(reportfile);
    }
  }
#line 1485
  return (0);
}
}
#line 125 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/utils.h"
static void cdmessage___5(cdrom_drive *d___0 , char const   *s ) 
{ 
  size_t tmp ;

  {
#line 126
  if (s) {
#line 126
    if (d___0) {
      {
#line 128
      if (d___0->messagedest == 1) {
#line 128
        goto case_1;
      }
#line 131
      if (d___0->messagedest == 2) {
#line 131
        goto case_2;
      }
#line 135
      goto switch_default;
      case_1: /* CIL Label */ 
      {
#line 129
      tmp = strlen(s);
#line 129
      write(2, (void const   *)s, tmp);
      }
#line 130
      goto switch_break;
      case_2: /* CIL Label */ 
      {
#line 132
      d___0->messagebuf = catstring(d___0->messagebuf, s);
      }
#line 133
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 136
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
  }
#line 139
  return;
}
}
#line 109 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/utils.h"
static void cderror___7(cdrom_drive *d___0 , char const   *s ) 
{ 
  size_t tmp ;

  {
#line 110
  if (s) {
#line 110
    if (d___0) {
      {
#line 112
      if (d___0->errordest == 1) {
#line 112
        goto case_1;
      }
#line 115
      if (d___0->errordest == 2) {
#line 115
        goto case_2;
      }
#line 119
      goto switch_default;
      case_1: /* CIL Label */ 
      {
#line 113
      tmp = strlen(s);
#line 113
      write(2, (void const   *)s, tmp);
      }
#line 114
      goto switch_break;
      case_2: /* CIL Label */ 
      {
#line 116
      d___0->errorbuf = catstring(d___0->errorbuf, s);
      }
#line 117
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 120
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
  }
#line 123
  return;
}
}
#line 125 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/utils.h"
static void cdmessage___6(cdrom_drive *d___0 , char const   *s ) 
{ 
  size_t tmp ;

  {
#line 126
  if (s) {
#line 126
    if (d___0) {
      {
#line 128
      if (d___0->messagedest == 1) {
#line 128
        goto case_1;
      }
#line 131
      if (d___0->messagedest == 2) {
#line 131
        goto case_2;
      }
#line 135
      goto switch_default;
      case_1: /* CIL Label */ 
      {
#line 129
      tmp = strlen(s);
#line 129
      write(2, (void const   *)s, tmp);
      }
#line 130
      goto switch_break;
      case_2: /* CIL Label */ 
      {
#line 132
      d___0->messagebuf = catstring(d___0->messagebuf, s);
      }
#line 133
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 136
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
  }
#line 139
  return;
}
}
#line 15 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/cooked_interface.c"
static int timed_ioctl___3(cdrom_drive *d___0 , int fd , int command , void *arg ) 
{ 
  struct timespec tv1 ;
  struct timespec tv2 ;
  int ret1 ;
  int tmp ;
  int ret2 ;
  int tmp___0 ;
  int ret3 ;
  int tmp___1 ;

  {
  {
#line 18
  tmp = clock_gettime((d___0->private_data)->clock, & tv1);
#line 18
  ret1 = tmp;
#line 19
  tmp___0 = ioctl(fd, (unsigned long )command, arg);
#line 19
  ret2 = tmp___0;
#line 20
  tmp___1 = clock_gettime((d___0->private_data)->clock, & tv2);
#line 20
  ret3 = tmp___1;
  }
#line 21
  if (ret1 < 0) {
#line 22
    (d___0->private_data)->last_milliseconds = -1;
  } else
#line 21
  if (ret3 < 0) {
#line 22
    (d___0->private_data)->last_milliseconds = -1;
  } else {
#line 24
    (d___0->private_data)->last_milliseconds = (int )((double )(tv2.tv_sec - tv1.tv_sec) * 1000. + (double )(tv2.tv_nsec - tv1.tv_nsec) / 1000000.);
  }
#line 26
  return (ret2);
}
}
#line 30 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/cooked_interface.c"
static int cooked_readtoc___1(cdrom_drive *d___0 ) 
{ 
  int i ;
  int tracks ;
  struct cdrom_tochdr hdr ;
  struct cdrom_tocentry entry ;
  int *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 37
  tmp___0 = ioctl(d___0->ioctl_fd, 21253UL, & hdr);
  }
#line 37
  if (tmp___0) {
    {
#line 38
    tmp = __errno_location();
    }
    {
#line 39
    if (*tmp == 1) {
#line 39
      goto case_1;
    }
#line 42
    goto switch_default;
    case_1: /* CIL Label */ 
    {
#line 40
    cderror___7(d___0, "102: Permision denied on cdrom (ioctl) device\n");
    }
#line 41
    return (-102);
    switch_default: /* CIL Label */ 
    {
#line 43
    cderror___7(d___0, "004: Unable to read table of contents header\n");
    }
#line 44
    return (-4);
    switch_break: /* CIL Label */ ;
    }
  }
#line 48
  i = 0;
  {
#line 48
  while (1) {
    while_continue: /* CIL Label */ ;
#line 48
    if (! (i < (int )hdr.cdth_trk1)) {
#line 48
      goto while_break;
    }
    {
#line 49
    entry.cdte_track = (__u8 )(i + 1);
#line 50
    entry.cdte_format = (__u8 )1;
#line 51
    tmp___1 = ioctl(d___0->ioctl_fd, 21254UL, & entry);
    }
#line 51
    if (tmp___1) {
      {
#line 52
      cderror___7(d___0, "005: Unable to read table of contents entry\n");
      }
#line 53
      return (-5);
    }
#line 56
    d___0->disc_toc[i].bFlags = (unsigned char )(((int )entry.cdte_adr << 4) | ((int )entry.cdte_ctrl & 15));
#line 57
    d___0->disc_toc[i].bTrack = (unsigned char )(i + 1);
#line 58
    d___0->disc_toc[i].dwStartSector = entry.cdte_addr.lba;
#line 48
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 61
  entry.cdte_track = (__u8 )170;
#line 62
  entry.cdte_format = (__u8 )1;
#line 63
  tmp___2 = ioctl(d___0->ioctl_fd, 21254UL, & entry);
  }
#line 63
  if (tmp___2) {
    {
#line 64
    cderror___7(d___0, "005: Unable to read table of contents entry\n");
    }
#line 65
    return (-5);
  }
  {
#line 67
  d___0->disc_toc[i].bFlags = (unsigned char )(((int )entry.cdte_adr << 4) | ((int )entry.cdte_ctrl & 15));
#line 68
  d___0->disc_toc[i].bTrack = entry.cdte_track;
#line 69
  d___0->disc_toc[i].dwStartSector = entry.cdte_addr.lba;
#line 71
  tracks = (int )hdr.cdth_trk1 + 1;
#line 72
  d___0->cd_extra = FixupTOC(d___0, tracks);
#line 73
  tracks --;
  }
#line 73
  return (tracks);
}
}
#line 77 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/cooked_interface.c"
static int cooked_setspeed___1(cdrom_drive *d___0 , int speed ) 
{ 
  int tmp ;

  {
#line 79
  if (d___0->ioctl_fd != -1) {
    {
#line 80
    tmp = ioctl(d___0->ioctl_fd, 21282UL, speed);
    }
#line 80
    return (tmp);
  } else {
#line 82
    return (0);
  }
}
}
#line 89 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/cooked_interface.c"
static long cooked_read___1(cdrom_drive *d___0 , void *p___0 , long begin , long sectors ) 
{ 
  int retry_count ;
  int err ;
  int ret ;
  struct cdrom_read_audio arg ;
  char *buffer ;
  void *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  char b[256] ;

  {
#line 90
  ret = 0;
#line 92
  buffer = (char *)p___0;
#line 95
  if (sectors > (long )d___0->nsectors) {
#line 95
    sectors = (long )d___0->nsectors;
  } else {
#line 95
    sectors = sectors;
  }
#line 96
  if ((unsigned long )p___0 == (unsigned long )((void *)0)) {
    {
#line 96
    tmp = malloc((size_t )(sectors * 2352L));
#line 96
    buffer = (char *)tmp;
    }
  }
#line 98
  arg.addr.lba = (int )begin;
#line 99
  arg.addr_format = (__u8 )1;
#line 100
  arg.nframes = (int )sectors;
#line 101
  arg.buf = (__u8 *)buffer;
#line 102
  retry_count = 0;
  {
#line 104
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 105
    err = timed_ioctl___3(d___0, d___0->ioctl_fd, 21262, (void *)(& arg));
    }
#line 105
    if (err) {
#line 106
      if (! d___0->error_retry) {
#line 107
        ret = -7;
#line 108
        goto done;
      }
      {
#line 110
      tmp___0 = __errno_location();
      }
      {
#line 111
      if (*tmp___0 == 12) {
#line 111
        goto case_12;
      }
#line 121
      if (*tmp___0 == 123) {
#line 121
        goto case_123;
      }
#line 121
      if (*tmp___0 == 9) {
#line 121
        goto case_123;
      }
#line 121
      if (*tmp___0 == 6) {
#line 121
        goto case_123;
      }
#line 125
      goto switch_default;
      case_12: /* CIL Label */ 
#line 113
      if (sectors == 1L) {
        {
#line 115
        cderror___7(d___0, "300: Kernel memory error\n");
#line 116
        ret = -300;
        }
#line 117
        goto done;
      }
      case_123: /* CIL Label */ 
      case_9: /* CIL Label */ 
      case_6: /* CIL Label */ 
      {
#line 122
      tmp___1 = __errno_location();
#line 122
      *tmp___1 = 123;
#line 123
      ret = 0;
      }
#line 124
      goto done;
      switch_default: /* CIL Label */ 
#line 126
      if (sectors == 1L) {
#line 132
        if (retry_count > 7) {
          {
#line 134
          sprintf((char */* __restrict  */)(b), (char const   */* __restrict  */)"010: Unable to access sector %ld: skipping...\n",
                  begin);
#line 136
          cderror___7(d___0, (char const   *)(b));
#line 137
          ret = -10;
          }
#line 138
          goto done;
        }
#line 140
        goto switch_break;
      }
      switch_break: /* CIL Label */ ;
      }
#line 143
      if (retry_count > 4) {
#line 144
        if (sectors > 1L) {
#line 145
          sectors = (sectors * 3L) / 4L;
        }
      }
#line 146
      retry_count ++;
#line 147
      if (retry_count > 8) {
        {
#line 148
        cderror___7(d___0, "007: Unknown, unrecoverable error reading data\n");
#line 149
        ret = -7;
        }
#line 150
        goto done;
      }
    } else {
#line 153
      goto while_break;
    }
#line 104
    if (! err) {
#line 104
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 156
  ret = (int )sectors;
  done: 
#line 159
  if ((unsigned long )p___0 == (unsigned long )((void *)0)) {
#line 159
    if (buffer) {
      {
#line 159
      free((void *)buffer);
      }
    }
  }
#line 160
  return ((long )ret);
}
}
#line 298 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/cooked_interface.c"
static int Dummy___3(cdrom_drive *d___0 , int Switch ) 
{ 


  {
#line 299
  return (0);
}
}
#line 302 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/cooked_interface.c"
static int verify_read_command___3(cdrom_drive *d___0 ) 
{ 
  int i ;
  int16_t *buff ;
  void *tmp ;
  int audioflag ;
  long firstsector ;
  long tmp___0 ;
  long lastsector ;
  long tmp___1 ;
  long sector ;
  long tmp___2 ;
  int tmp___3 ;

  {
  {
#line 304
  tmp = malloc((size_t )2352);
#line 304
  buff = (int16_t *)tmp;
#line 305
  audioflag = 0;
#line 307
  cdmessage___6(d___0, "Verifying drive can read CDDA...\n");
#line 309
  (*(d___0->enable_cdda))(d___0, 1);
#line 311
  i = 1;
  }
  {
#line 311
  while (1) {
    while_continue: /* CIL Label */ ;
#line 311
    if (! (i <= d___0->tracks)) {
#line 311
      goto while_break;
    }
    {
#line 312
    tmp___3 = cdda_track_audiop(d___0, i);
    }
#line 312
    if (tmp___3 == 1) {
      {
#line 313
      tmp___0 = cdda_track_firstsector(d___0, i);
#line 313
      firstsector = tmp___0;
#line 314
      tmp___1 = cdda_track_lastsector(d___0, i);
#line 314
      lastsector = tmp___1;
#line 315
      sector = (firstsector + lastsector) >> 1;
#line 316
      audioflag = 1;
#line 318
      tmp___2 = (*(d___0->read_audio))(d___0, (void *)buff, sector, 1L);
      }
#line 318
      if (tmp___2 > 0L) {
        {
#line 319
        cdmessage___6(d___0, "\tExpected command set reads OK.\n");
#line 320
        (*(d___0->enable_cdda))(d___0, 0);
#line 321
        free((void *)buff);
        }
#line 322
        return (0);
      }
    }
#line 311
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 327
  (*(d___0->enable_cdda))(d___0, 0);
  }
#line 329
  if (! audioflag) {
    {
#line 330
    cdmessage___6(d___0, "\tCould not find any audio tracks on this disk.\n");
    }
#line 331
    return (-403);
  }
  {
#line 334
  cdmessage___6(d___0, "\n\tUnable to read any data; drive probably not CDDA capable.\n");
#line 337
  cderror___7(d___0, "006: Could not read any data from drive\n");
#line 339
  free((void *)buff);
  }
#line 340
  return (-6);
}
}
#line 24 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/drive_exceptions.h"
static exception atapi_list___3[5]  = {      {(char *)"SAMSUNG SCR-830 REV 2.09 2.09 ", 1, (unsigned char)0, & Dummy___3,
      & scsi_read_mmc2, 0}, 
        {(char *)"Memorex CR-622", 1, (unsigned char)0, & Dummy___3, (long (*)(struct cdrom_drive * ,
                                                                            void * ,
                                                                            long  ,
                                                                            long  ))((void *)0),
      0}, 
        {(char *)"SONY CD-ROM CDU-561", 0, (unsigned char)0, & Dummy___3, (long (*)(struct cdrom_drive * ,
                                                                                 void * ,
                                                                                 long  ,
                                                                                 long  ))((void *)0),
      0}, 
        {(char *)"Chinon CD-ROM CDS-525", 0, (unsigned char)0, & Dummy___3, (long (*)(struct cdrom_drive * ,
                                                                                   void * ,
                                                                                   long  ,
                                                                                   long  ))((void *)0),
      0}, 
        {(char *)((void *)0), 0, (unsigned char)0, (int (*)(struct cdrom_drive * , int  ))((void *)0),
      (long (*)(struct cdrom_drive * , void * , long  , long  ))((void *)0), 0}};
#line 345 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/cooked_interface.c"
static void check_exceptions___3(cdrom_drive *d___0 , exception *list ) 
{ 
  int i ;
  size_t tmp ;
  int tmp___0 ;

  {
#line 347
  i = 0;
  {
#line 348
  while (1) {
    while_continue: /* CIL Label */ ;
#line 348
    if (! (list + i)->model) {
#line 348
      goto while_break;
    }
    {
#line 349
    tmp = strlen((char const   *)(list + i)->model);
#line 349
    tmp___0 = strncmp((char const   *)(list + i)->model, (char const   *)d___0->drive_model,
                      tmp);
    }
#line 349
    if (! tmp___0) {
#line 350
      if ((list + i)->bigendianp != -1) {
#line 350
        d___0->bigendianp = (list + i)->bigendianp;
      }
#line 351
      return;
    }
#line 353
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 355
  return;
}
}
#line 141 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/utils.h"
static void idperror___1(int messagedest , char **messages , char const   *f , char const   *s ) 
{ 
  char *buffer ;
  int malloced ;
  size_t tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  size_t tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  size_t tmp___5 ;
  int *tmp___6 ;
  char *tmp___7 ;
  int *tmp___8 ;
  int *tmp___9 ;
  char *tmp___10 ;
  int *tmp___11 ;

  {
#line 145
  malloced = 0;
#line 146
  if (! f) {
#line 147
    buffer = (char *)s;
  } else
#line 149
  if (! s) {
#line 150
    buffer = (char *)f;
  } else {
    {
#line 152
    tmp = strlen(f);
#line 152
    tmp___0 = strlen(s);
#line 152
    tmp___1 = malloc((tmp + tmp___0) + 9UL);
#line 152
    buffer = (char *)tmp___1;
#line 153
    sprintf((char */* __restrict  */)buffer, (char const   */* __restrict  */)f, s);
#line 154
    malloced = 1;
    }
  }
#line 157
  if (buffer) {
    {
#line 159
    if (messagedest == 1) {
#line 159
      goto case_1;
    }
#line 167
    if (messagedest == 2) {
#line 167
      goto case_2;
    }
#line 178
    goto switch_default;
    case_1: /* CIL Label */ 
    {
#line 160
    tmp___2 = strlen((char const   *)buffer);
#line 160
    write(2, (void const   *)buffer, tmp___2);
#line 161
    tmp___8 = __errno_location();
    }
#line 161
    if (*tmp___8) {
      {
#line 162
      write(2, (void const   *)": ", (size_t )2);
#line 163
      tmp___3 = __errno_location();
#line 163
      tmp___4 = strerror(*tmp___3);
#line 163
      tmp___5 = strlen((char const   *)tmp___4);
#line 163
      tmp___6 = __errno_location();
#line 163
      tmp___7 = strerror(*tmp___6);
#line 163
      write(2, (void const   *)tmp___7, tmp___5);
#line 164
      write(2, (void const   *)"\n", (size_t )1);
      }
    }
#line 166
    goto switch_break;
    case_2: /* CIL Label */ 
#line 168
    if (messages) {
      {
#line 169
      *messages = catstring(*messages, (char const   *)buffer);
#line 170
      tmp___11 = __errno_location();
      }
#line 170
      if (*tmp___11) {
        {
#line 171
        *messages = catstring(*messages, ": ");
#line 172
        tmp___9 = __errno_location();
#line 172
        tmp___10 = strerror(*tmp___9);
#line 172
        *messages = catstring(*messages, (char const   *)tmp___10);
#line 173
        *messages = catstring(*messages, "\n");
        }
      }
    }
#line 176
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 179
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
#line 182
  if (malloced) {
    {
#line 182
    free((void *)buffer);
    }
  }
#line 183
  return;
}
}
#line 186 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/utils.h"
static void idmessage___1(int messagedest , char **messages , char const   *f , char const   *s ) 
{ 
  char *buffer ;
  int malloced ;
  size_t tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  size_t tmp___2 ;

  {
#line 189
  malloced = 0;
#line 190
  if (! f) {
#line 191
    buffer = (char *)s;
  } else
#line 193
  if (! s) {
#line 194
    buffer = (char *)f;
  } else {
    {
#line 196
    tmp = strlen(f);
#line 196
    tmp___0 = strlen(s);
#line 196
    tmp___1 = malloc((tmp + tmp___0) + 10UL);
#line 196
    buffer = (char *)tmp___1;
#line 197
    sprintf((char */* __restrict  */)buffer, (char const   */* __restrict  */)f, s);
#line 198
    strcat((char */* __restrict  */)buffer, (char const   */* __restrict  */)"\n");
#line 199
    malloced = 1;
    }
  }
#line 202
  if (buffer) {
    {
#line 204
    if (messagedest == 1) {
#line 204
      goto case_1;
    }
#line 208
    if (messagedest == 2) {
#line 208
      goto case_2;
    }
#line 215
    goto switch_default;
    case_1: /* CIL Label */ 
    {
#line 205
    tmp___2 = strlen((char const   *)buffer);
#line 205
    write(2, (void const   *)buffer, tmp___2);
    }
#line 206
    if (! malloced) {
      {
#line 206
      write(2, (void const   *)"\n", (size_t )1);
      }
    }
#line 207
    goto switch_break;
    case_2: /* CIL Label */ 
#line 209
    if (messages) {
      {
#line 210
      *messages = catstring(*messages, (char const   *)buffer);
      }
#line 211
      if (! malloced) {
        {
#line 211
        *messages = catstring(*messages, "\n");
        }
      }
    }
#line 213
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 216
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
#line 219
  if (malloced) {
    {
#line 219
    free((void *)buffer);
    }
  }
#line 220
  return;
}
}
#line 29 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/scan_devices.c"
static char *scsi_cdrom_prefixes___1[3]  = {      (char *)"/dev/scd",      (char *)"/dev/sr",      (char *)((void *)0)};
#line 33 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/scan_devices.c"
static char *scsi_generic_prefixes___1[2]  = {      (char *)"/dev/sg",      (char *)((void *)0)};
#line 37 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/scan_devices.c"
static char *devfs_scsi_test___1  =    (char *)"/dev/scsi/";
#line 38 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/scan_devices.c"
static char *devfs_scsi_cd___1  =    (char *)"cd";
#line 39 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/scan_devices.c"
static char *devfs_scsi_generic___1  =    (char *)"generic";
#line 41 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/scan_devices.c"
static char *cdrom_devices___1[15]  = 
#line 41
  {      (char *)"/dev/cdrom",      (char *)"/dev/cdroms/cdrom?",      (char *)"/dev/hd?",      (char *)"/dev/sg?", 
        (char *)"/dev/cdu31a",      (char *)"/dev/cdu535",      (char *)"/dev/sbpcd",      (char *)"/dev/sbpcd?", 
        (char *)"/dev/sonycd",      (char *)"/dev/mcd",      (char *)"/dev/sjcd",      (char *)"/dev/cm206cd", 
        (char *)"/dev/gscd",      (char *)"/dev/optcd",      (char *)((void *)0)};
#line 367 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/scan_devices.c"
static int get_scsi_id___1(int fd , scsiid *id ) 
{ 
  struct sg_id argid ;
  int busarg ;
  int tmp ;
  int tmp___0 ;

  {
#line 373
  if (fd == -1) {
#line 373
    return (-1);
  }
  {
#line 374
  tmp = ioctl(fd, 21378UL, & argid);
  }
#line 374
  if (tmp) {
#line 374
    return (-1);
  }
  {
#line 375
  id->bus = (int )argid.l2;
#line 376
  id->id = (int )(argid.l1 & 255L);
#line 377
  id->lun = (int )((argid.l1 >> 8) & 255L);
#line 379
  tmp___0 = ioctl(fd, 21382UL, & busarg);
  }
#line 379
  if (tmp___0 == 0) {
#line 380
    id->bus = busarg;
  }
#line 382
  return (0);
}
}
#line 386 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/scan_devices.c"
static char *scsi_match___1(char const   *device , char **prefixes , char *devfs_test ,
                            char *devfs_other , char *prompt , int messagedest , char **messages ) 
{ 
  int dev ;
  int tmp ;
  scsiid a ;
  scsiid b ;
  int i ;
  int j ;
  char buffer[200] ;
  char *pos ;
  int matchf ;
  int *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int pattern ;
  int matchf___0 ;
  int k ;
  int *tmp___7 ;
  char *tmp___8 ;
  int tmp___9 ;
  char *tmp___10 ;
  int tmp___11 ;

  {
  {
#line 390
  tmp = open(device, 2048);
#line 390
  dev = tmp;
#line 398
  tmp___4 = strlen((char const   *)devfs_test);
#line 398
  tmp___5 = strncmp(device, (char const   *)devfs_test, tmp___4);
  }
#line 398
  if (! tmp___5) {
    {
#line 400
    strcpy((char */* __restrict  */)(buffer), (char const   */* __restrict  */)device);
#line 401
    pos = strrchr((char const   *)(buffer), '/');
    }
#line 402
    if (pos) {
      {
#line 404
      sprintf((char */* __restrict  */)pos, (char const   */* __restrict  */)"/%s",
              devfs_other);
#line 405
      matchf = open((char const   *)(buffer), 2048);
#line 406
      i = 0;
      }
      {
#line 406
      while (1) {
        while_continue: /* CIL Label */ ;
#line 406
        if (i < 10) {
#line 406
          if (! (matchf == -1)) {
#line 406
            goto while_break;
          }
        } else {
#line 406
          goto while_break;
        }
        {
#line 407
        tmp___0 = __errno_location();
#line 407
        tmp___1 = strerror(*tmp___0);
#line 407
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error trying to open %s exclusively (%s). retrying in 1 seconds.\n",
                buffer, tmp___1);
#line 408
        tmp___2 = rand();
#line 408
        usleep((__useconds_t )((double )1000000 + (100000.0 * (double )tmp___2) / ((double )2147483647 + 1.0)));
#line 409
        matchf = open((char const   *)(buffer), 2048);
#line 406
        i ++;
        }
      }
      while_break: /* CIL Label */ ;
      }
#line 411
      if (matchf != -1) {
        {
#line 412
        close(matchf);
#line 413
        close(dev);
#line 414
        tmp___3 = strdup((char const   *)(buffer));
        }
#line 414
        return (tmp___3);
      }
    }
  }
#line 420
  if (dev == -1) {
    {
#line 421
    idperror___1(messagedest, messages, "\t\tCould not access device %s", device);
    }
#line 424
    goto matchfail;
  }
  {
#line 426
  tmp___6 = get_scsi_id___1(dev, & a);
  }
#line 426
  if (tmp___6) {
    {
#line 427
    idperror___1(messagedest, messages, "\t\tDevice %s could not perform ioctl()",
                 device);
    }
#line 430
    goto matchfail;
  }
#line 434
  i = 0;
  {
#line 434
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 434
    if (! (i < 25)) {
#line 434
      goto while_break___0;
    }
#line 435
    j = 0;
    {
#line 435
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 435
      if (! (j < 2)) {
#line 435
        goto while_break___1;
      }
#line 436
      pattern = 0;
      {
#line 439
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 439
        if (! ((unsigned long )*(prefixes + pattern) != (unsigned long )((void *)0))) {
#line 439
          goto while_break___2;
        }
        {
#line 441
        if (j == 0) {
#line 441
          goto case_0;
        }
#line 445
        if (j == 1) {
#line 445
          goto case_1;
        }
#line 440
        goto switch_break;
        case_0: /* CIL Label */ 
        {
#line 443
        sprintf((char */* __restrict  */)(buffer), (char const   */* __restrict  */)"%s%d",
                *(prefixes + pattern), i);
        }
#line 444
        goto switch_break;
        case_1: /* CIL Label */ 
        {
#line 447
        sprintf((char */* __restrict  */)(buffer), (char const   */* __restrict  */)"%s%c",
                *(prefixes + pattern), i + 97);
        }
#line 448
        goto switch_break;
        switch_break: /* CIL Label */ ;
        }
        {
#line 451
        matchf___0 = open((char const   *)(buffer), 2048);
#line 452
        k = 0;
        }
        {
#line 452
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 452
          if (k < 10) {
#line 452
            if (! (matchf___0 == -1)) {
#line 452
              goto while_break___3;
            }
          } else {
#line 452
            goto while_break___3;
          }
          {
#line 453
          tmp___7 = __errno_location();
#line 453
          tmp___8 = strerror(*tmp___7);
#line 453
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error trying to open %s exclusively (%s). retrying in 1 second.\n",
                  buffer, tmp___8);
#line 454
          tmp___9 = rand();
#line 454
          usleep((__useconds_t )((double )1000000 + (100000.0 * (double )tmp___9) / ((double )2147483647 + 1.0)));
#line 455
          matchf___0 = open((char const   *)(buffer), 2048);
#line 452
          k ++;
          }
        }
        while_break___3: /* CIL Label */ ;
        }
#line 458
        if (matchf___0 != -1) {
          {
#line 459
          tmp___11 = get_scsi_id___1(matchf___0, & b);
          }
#line 459
          if (tmp___11 == 0) {
#line 460
            if (a.bus == b.bus) {
#line 460
              if (a.id == b.id) {
#line 460
                if (a.lun == b.lun) {
                  {
#line 461
                  close(matchf___0);
#line 462
                  close(dev);
#line 463
                  tmp___10 = strdup((char const   *)(buffer));
                  }
#line 463
                  return (tmp___10);
                }
              }
            }
          }
          {
#line 466
          close(matchf___0);
          }
        }
#line 468
        pattern ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 435
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 434
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 473
  idmessage___1(messagedest, messages, (char const   *)prompt, device);
  }
  matchfail: 
#line 477
  if (dev != -1) {
    {
#line 477
    close(dev);
    }
  }
#line 478
  return ((char *)((void *)0));
}
}
#line 495 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/scan_devices.c"
static int verify_SG_version___1(cdrom_drive *d___0 , int messagedest , char **messages ) 
{ 
  int version ;
  int major ;
  int minor ;
  char buffer[256] ;
  int tmp ;

  {
  {
#line 500
  idmessage___1(messagedest, messages, "\nFound an accessible SCSI CDROM drive.\nLooking at revision of the SG interface in use...",
                "");
#line 504
  tmp = ioctl(d___0->cdda_fd, 8834UL, & version);
  }
#line 504
  if (tmp) {
    {
#line 506
    idmessage___1(messagedest, messages, "\tOOPS!  Old 2.0/early 2.1/early 2.2.x (non-ac patch) style SG.\n\tCdparanoia no longer supports the old interface.\n",
                  "");
    }
#line 509
    return (0);
  }
  {
#line 511
  major = version / 10000;
#line 512
  version -= major * 10000;
#line 513
  minor = version / 100;
#line 514
  version -= minor * 100;
#line 516
  sprintf((char */* __restrict  */)(buffer), (char const   */* __restrict  */)"\tSG interface version %d.%d.%d; OK.",
          major, minor, version);
#line 519
  idmessage___1(messagedest, messages, (char const   *)(buffer), "");
  }
#line 520
  return (major);
}
}
#line 163 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/cdda_interface.h"
static char *strerror_tr___1[12]  = 
#line 163 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/cdda_interface.h"
  {      (char *)"Success",      (char *)"Error writing packet command to device",      (char *)"Error reading command from device",      (char *)"SCSI packet data underrun (too little data)", 
        (char *)"SCSI packet data overrun (too much data)",      (char *)"Illegal SCSI request (rejected by target)",      (char *)"Medium reading data from medium",      (char *)"Device busy", 
        (char *)"Device not ready",      (char *)"Target hardware fault",      (char *)"Unspecified error",      (char *)"Drive lost streaming"};
#line 109 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/utils.h"
static void cderror___8(cdrom_drive *d___0 , char const   *s ) 
{ 
  size_t tmp ;

  {
#line 110
  if (s) {
#line 110
    if (d___0) {
      {
#line 112
      if (d___0->errordest == 1) {
#line 112
        goto case_1;
      }
#line 115
      if (d___0->errordest == 2) {
#line 115
        goto case_2;
      }
#line 119
      goto switch_default;
      case_1: /* CIL Label */ 
      {
#line 113
      tmp = strlen(s);
#line 113
      write(2, (void const   *)s, tmp);
      }
#line 114
      goto switch_break;
      case_2: /* CIL Label */ 
      {
#line 116
      d___0->errorbuf = catstring(d___0->errorbuf, s);
      }
#line 117
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 120
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
  }
#line 123
  return;
}
}
#line 125 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/utils.h"
static void cdmessage___7(cdrom_drive *d___0 , char const   *s ) 
{ 
  size_t tmp ;

  {
#line 126
  if (s) {
#line 126
    if (d___0) {
      {
#line 128
      if (d___0->messagedest == 1) {
#line 128
        goto case_1;
      }
#line 131
      if (d___0->messagedest == 2) {
#line 131
        goto case_2;
      }
#line 135
      goto switch_default;
      case_1: /* CIL Label */ 
      {
#line 129
      tmp = strlen(s);
#line 129
      write(2, (void const   *)s, tmp);
      }
#line 130
      goto switch_break;
      case_2: /* CIL Label */ 
      {
#line 132
      d___0->messagebuf = catstring(d___0->messagebuf, s);
      }
#line 133
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 136
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
  }
#line 139
  return;
}
}
#line 20 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
static int timed_ioctl___4(cdrom_drive *d___0 , int fd , int command , void *arg ) 
{ 
  struct timespec tv1 ;
  struct timespec tv2 ;
  int ret1 ;
  int tmp ;
  int ret2 ;
  int tmp___0 ;
  int ret3 ;
  int tmp___1 ;

  {
  {
#line 23
  tmp = clock_gettime((d___0->private_data)->clock, & tv1);
#line 23
  ret1 = tmp;
#line 24
  tmp___0 = ioctl(fd, (unsigned long )command, arg);
#line 24
  ret2 = tmp___0;
#line 25
  tmp___1 = clock_gettime((d___0->private_data)->clock, & tv2);
#line 25
  ret3 = tmp___1;
  }
#line 26
  if (ret1 < 0) {
#line 27
    (d___0->private_data)->last_milliseconds = -1;
  } else
#line 26
  if (ret3 < 0) {
#line 27
    (d___0->private_data)->last_milliseconds = -1;
  } else {
#line 29
    (d___0->private_data)->last_milliseconds = (int )((double )(tv2.tv_sec - tv1.tv_sec) * 1000. + (double )(tv2.tv_nsec - tv1.tv_nsec) / 1000000.);
  }
#line 31
  return (ret2);
}
}
#line 35 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
static int Dummy___4(cdrom_drive *d___0 , int s ) 
{ 


  {
#line 36
  return (0);
}
}
#line 24 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/drive_exceptions.h"
static exception atapi_list___4[5]  = {      {(char *)"SAMSUNG SCR-830 REV 2.09 2.09 ", 1, (unsigned char)0, & Dummy___4,
      & scsi_read_mmc2, 0}, 
        {(char *)"Memorex CR-622", 1, (unsigned char)0, & Dummy___4, (long (*)(struct cdrom_drive * ,
                                                                            void * ,
                                                                            long  ,
                                                                            long  ))((void *)0),
      0}, 
        {(char *)"SONY CD-ROM CDU-561", 0, (unsigned char)0, & Dummy___4, (long (*)(struct cdrom_drive * ,
                                                                                 void * ,
                                                                                 long  ,
                                                                                 long  ))((void *)0),
      0}, 
        {(char *)"Chinon CD-ROM CDS-525", 0, (unsigned char)0, & Dummy___4, (long (*)(struct cdrom_drive * ,
                                                                                   void * ,
                                                                                   long  ,
                                                                                   long  ))((void *)0),
      0}, 
        {(char *)((void *)0), 0, (unsigned char)0, (int (*)(struct cdrom_drive * , int  ))((void *)0),
      (long (*)(struct cdrom_drive * , void * , long  , long  ))((void *)0), 0}};
#line 33 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/drive_exceptions.h"
static exception mmc_list___1[6]  = {      {(char *)"SAMSUNG SCR-830 REV 2.09 2.09 ", 1, (unsigned char)0, & Dummy___4,
      & scsi_read_mmc2, 0}, 
        {(char *)"Memorex CR-622", 1, (unsigned char)0, & Dummy___4, (long (*)(struct cdrom_drive * ,
                                                                            void * ,
                                                                            long  ,
                                                                            long  ))((void *)0),
      0}, 
        {(char *)"SONY CD-ROM CDU-561", 0, (unsigned char)0, & Dummy___4, (long (*)(struct cdrom_drive * ,
                                                                                 void * ,
                                                                                 long  ,
                                                                                 long  ))((void *)0),
      0}, 
        {(char *)"Chinon CD-ROM CDS-525", 0, (unsigned char)0, & Dummy___4, (long (*)(struct cdrom_drive * ,
                                                                                   void * ,
                                                                                   long  ,
                                                                                   long  ))((void *)0),
      0}, 
        {(char *)"KENWOOD CD-ROM UCR", -1, (unsigned char)0, (int (*)(struct cdrom_drive * ,
                                                                   int  ))((void *)0),
      & scsi_read_D8, 0}, 
        {(char *)((void *)0), 0, (unsigned char)0, (int (*)(struct cdrom_drive * , int  ))((void *)0),
      (long (*)(struct cdrom_drive * , void * , long  , long  ))((void *)0), 0}};
#line 43 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/drive_exceptions.h"
static exception scsi_list___1[18]  = 
#line 43
  {      {(char *)"TOSHIBA", -1, (unsigned char)130, & scsi_enable_cdda, & scsi_read_28,
      0}, 
        {(char *)"IBM", -1, (unsigned char)130, & scsi_enable_cdda, & scsi_read_28, 0}, 
        {(char *)"DEC",
      -1, (unsigned char)130, & scsi_enable_cdda, & scsi_read_28, 0}, 
        {(char *)"IMS", -1, (unsigned char)0, & scsi_enable_cdda, & scsi_read_28, 1}, 
        {(char *)"KODAK",
      -1, (unsigned char)0, & scsi_enable_cdda, & scsi_read_28, 1}, 
        {(char *)"RICOH", -1, (unsigned char)0, & scsi_enable_cdda, & scsi_read_28, 1}, 
        {(char *)"HP",
      -1, (unsigned char)0, & scsi_enable_cdda, & scsi_read_28, 1}, 
        {(char *)"PHILIPS", -1, (unsigned char)0, & scsi_enable_cdda, & scsi_read_28,
      1}, 
        {(char *)"PLASMON", -1, (unsigned char)0, & scsi_enable_cdda, & scsi_read_28,
      1}, 
        {(char *)"GRUNDIG CDR100IPW", -1, (unsigned char)0, & scsi_enable_cdda, & scsi_read_28,
      1}, 
        {(char *)"MITSUMI CD-R ", -1, (unsigned char)0, & scsi_enable_cdda, & scsi_read_28,
      1}, 
        {(char *)"KENWOOD CD-ROM UCR", -1, (unsigned char)0, (int (*)(struct cdrom_drive * ,
                                                                   int  ))((void *)0),
      & scsi_read_D8, 0}, 
        {(char *)"YAMAHA", -1, (unsigned char)0, & scsi_enable_cdda, (long (*)(struct cdrom_drive * ,
                                                                            void * ,
                                                                            long  ,
                                                                            long  ))((void *)0),
      0}, 
        {(char *)"PLEXTOR", -1, (unsigned char)0, (int (*)(struct cdrom_drive * , int  ))((void *)0),
      (long (*)(struct cdrom_drive * , void * , long  , long  ))((void *)0), 0}, 
        {(char *)"SONY", -1, (unsigned char)0, (int (*)(struct cdrom_drive * , int  ))((void *)0),
      (long (*)(struct cdrom_drive * , void * , long  , long  ))((void *)0), 0}, 
        {(char *)"NEC", -1, (unsigned char)0, (int (*)(struct cdrom_drive * , int  ))((void *)0),
      & scsi_read_D4_10, 0}, 
        {(char *)"MATSHITA CD-R   CW-7501", -1, (unsigned char)0, (int (*)(struct cdrom_drive * ,
                                                                        int  ))((void *)0),
      & scsi_read_D4_12, -1}, 
        {(char *)((void *)0), 0, (unsigned char)0, (int (*)(struct cdrom_drive * , int  ))((void *)0),
      (long (*)(struct cdrom_drive * , void * , long  , long  ))((void *)0), 0}};
#line 40 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
static void tweak_SG_buffer___1(cdrom_drive *d___0 ) 
{ 
  int table ;
  int reserved ;
  int cur ;
  int err ;
  char buffer[256] ;
  int tmp ;
  char *tmp___0 ;

  {
#line 52
  cur = 1;
  {
#line 53
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 54
    cur <<= 1;
#line 54
    reserved = cur * (1 << 9);
#line 55
    err = ioctl(d___0->cdda_fd, 8821UL, & reserved);
    }
#line 53
    if (err >= 0) {
#line 53
      if (! (cur * (1 << 9) < 1073741824)) {
#line 53
        goto while_break;
      }
    } else {
#line 53
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 57
  ioctl(d___0->cdda_fd, 8818UL, & reserved);
#line 61
  tmp = ioctl(d___0->cdda_fd, 8831UL, & table);
  }
#line 61
  if (tmp < 0) {
#line 62
    table = 1;
  }
  {
#line 64
  sprintf((char */* __restrict  */)(buffer), (char const   */* __restrict  */)"\tDMA scatter/gather table entries: %d\n\ttable entry size: %d bytes\n\tmaximum theoretical transfer: %d sectors\n",
          table, reserved, table * (reserved / 2352));
#line 69
  cdmessage___7(d___0, (char const   *)(buffer));
#line 71
  cur = reserved;
#line 85
  tmp___0 = getenv("CDDA_IGNORE_BUFSIZE_LIMIT");
  }
#line 85
  if (tmp___0) {
    {
#line 88
    cdmessage___7(d___0, "\tEnvironment variable CDDA_IGNORE_BUFSIZE_LIMIT set,\n\t\tforcing maximum possible sector size.  This can break\n\t\tspectacularly; use with caution!\n");
    }
  } else
#line 86
  if (cur > 65536) {
#line 86
    cur = 65536;
  } else {
#line 86
    cur = cur;
  }
  {
#line 92
  d___0->nsectors = cur / 2352;
#line 93
  d___0->bigbuff = (long )cur;
#line 95
  sprintf((char */* __restrict  */)(buffer), (char const   */* __restrict  */)"\tSetting default read size to %d sectors (%d bytes).\n\n",
          d___0->nsectors, d___0->nsectors * 2352);
  }
#line 98
  if (cur == 0) {
    {
#line 98
    exit(1);
    }
  }
  {
#line 108
  cdmessage___7(d___0, (char const   *)(buffer));
  }
#line 109
  return;
}
}
#line 113 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
static void clear_garbage___1(cdrom_drive *d___0 ) 
{ 
  fd_set fdset ;
  struct timeval tv ;
  struct sg_header *sg_hd ;
  int flag ;
  int __d0 ;
  int __d1 ;
  int __d0___0 ;
  int __d1___0 ;
  int tmp ;

  {
#line 116
  sg_hd = (d___0->private_data)->sg_hd;
#line 117
  flag = 0;
  {
#line 120
  while (1) {
    while_continue: /* CIL Label */ ;
#line 120
    __asm__  volatile   ("cld; rep; "
                         "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                         "1" (& fdset.__fds_bits[0]): "memory");
#line 120
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 121
  fdset.__fds_bits[d___0->cdda_fd / (8 * (int )sizeof(__fd_mask ))] |= 1L << d___0->cdda_fd % (8 * (int )sizeof(__fd_mask ));
#line 122
  tv.tv_sec = (__time_t )0;
#line 123
  tv.tv_usec = (__suseconds_t )0;
  {
#line 126
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 126
    tmp = select(d___0->cdda_fd + 1, (fd_set */* __restrict  */)(& fdset), (fd_set */* __restrict  */)((void *)0),
                 (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)(& tv));
    }
#line 126
    if (! (tmp == 1)) {
#line 126
      goto while_break___0;
    }
    {
#line 128
    sg_hd->twelve_byte = 0U;
#line 129
    sg_hd->result = 0;
#line 130
    sg_hd->reply_len = (int )sizeof(struct sg_header );
#line 131
    read(d___0->cdda_fd, (void *)sg_hd, (size_t )1);
    }
    {
#line 134
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 134
      __asm__  volatile   ("cld; rep; "
                           "stosq": "=c" (__d0___0), "=D" (__d1___0): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                           "1" (& fdset.__fds_bits[0]): "memory");
#line 134
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 135
    fdset.__fds_bits[d___0->cdda_fd / (8 * (int )sizeof(__fd_mask ))] |= 1L << d___0->cdda_fd % (8 * (int )sizeof(__fd_mask ));
#line 136
    tv.tv_sec = (__time_t )0;
#line 137
    tv.tv_usec = (__suseconds_t )0;
#line 138
    if (! flag) {
#line 138
      if (d___0->report_all) {
        {
#line 139
        cdmessage___7(d___0, "Clearing previously returned data from SCSI buffer\n");
        }
      }
    }
#line 140
    flag = 1;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 142
  return;
}
}
#line 145 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
static int check_sbp_error___1(unsigned char const   status , unsigned char const   *sbp ) 
{ 
  char key ;
  char ASC ;
  char ASCQ ;
  int *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  int *tmp___5 ;
  int *tmp___6 ;
  int *tmp___7 ;
  int *tmp___8 ;
  int *tmp___9 ;
  int *tmp___10 ;
  int *tmp___11 ;

  {
#line 147
  key = (char )((int const   )*(sbp + 2) & 15);
#line 148
  ASC = (char )*(sbp + 12);
#line 149
  ASCQ = (char )*(sbp + 13);
#line 151
  if ((int const   )status == 0) {
#line 151
    return (0);
  }
#line 152
  if ((int const   )status == 8) {
#line 152
    return (7);
  }
#line 154
  if (*(sbp + 0)) {
    {
#line 156
    if ((int )key == 0) {
#line 156
      goto case_0;
    }
#line 160
    if ((int )key == 1) {
#line 160
      goto case_1;
    }
#line 162
    if ((int )key == 2) {
#line 162
      goto case_2;
    }
#line 169
    if ((int )key == 3) {
#line 169
      goto case_3;
    }
#line 180
    if ((int )key == 4) {
#line 180
      goto case_4;
    }
#line 184
    if ((int )key == 5) {
#line 184
      goto case_5;
    }
#line 188
    goto switch_default;
    case_0: /* CIL Label */ 
    {
#line 157
    tmp___0 = __errno_location();
    }
#line 157
    if (*tmp___0 == 0) {
      {
#line 158
      tmp = __errno_location();
#line 158
      *tmp = 5;
      }
    }
#line 159
    return (10);
    case_1: /* CIL Label */ 
#line 161
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 164
    tmp___1 = __errno_location();
#line 164
    *tmp___1 = 123;
    }
#line 168
    return (8);
    case_3: /* CIL Label */ 
#line 170
    if (((int )ASC == 12) & ((int )ASCQ == 9)) {
      {
#line 172
      tmp___3 = __errno_location();
      }
#line 172
      if (*tmp___3 == 0) {
        {
#line 173
        tmp___2 = __errno_location();
#line 173
        *tmp___2 = 5;
        }
      }
#line 174
      return (11);
    } else {
      {
#line 176
      tmp___5 = __errno_location();
      }
#line 176
      if (*tmp___5 == 0) {
        {
#line 177
        tmp___4 = __errno_location();
#line 177
        *tmp___4 = 5;
        }
      }
#line 178
      return (6);
    }
    case_4: /* CIL Label */ 
    {
#line 181
    tmp___7 = __errno_location();
    }
#line 181
    if (*tmp___7 == 0) {
      {
#line 182
      tmp___6 = __errno_location();
#line 182
      *tmp___6 = 5;
      }
    }
#line 183
    return (9);
    case_5: /* CIL Label */ 
    {
#line 185
    tmp___9 = __errno_location();
    }
#line 185
    if (*tmp___9 == 0) {
      {
#line 186
      tmp___8 = __errno_location();
#line 186
      *tmp___8 = 22;
      }
    }
#line 187
    return (5);
    switch_default: /* CIL Label */ 
    {
#line 189
    tmp___11 = __errno_location();
    }
#line 189
    if (*tmp___11 == 0) {
      {
#line 190
      tmp___10 = __errno_location();
#line 190
      *tmp___10 = 5;
      }
    }
#line 191
    return (10);
    switch_break: /* CIL Label */ ;
    }
  }
#line 194
  return (0);
}
}
#line 199 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
static int sg2_handle_scsi_cmd___1(cdrom_drive *d___0 , unsigned char *cmd , unsigned int cmd_len ,
                                   unsigned int in_size , unsigned int out_size ,
                                   unsigned char bytefill , int bytecheck , unsigned char *sense_buffer ) 
{ 
  struct timespec tv1 ;
  struct timespec tv2 ;
  int tret1 ;
  int tret2 ;
  int status ;
  struct sg_header *sg_hd ;
  long writebytes ;
  fd_set fdset ;
  struct timeval tv ;
  int __d0 ;
  int __d1 ;
  int ret ;
  int tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  ssize_t tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  fd_set rset ;
  struct timeval tv___0 ;
  int __d0___0 ;
  int __d1___0 ;
  int ret___0 ;
  int tmp___5 ;
  int *tmp___6 ;
  int *tmp___7 ;
  ssize_t tmp___8 ;
  int *tmp___9 ;
  int *tmp___10 ;
  long i ;
  long flag ;
  int *tmp___11 ;
  int *tmp___12 ;

  {
  {
#line 210
  status = 0;
#line 211
  sg_hd = (d___0->private_data)->sg_hd;
#line 212
  writebytes = (long )((sizeof(struct sg_header ) + (unsigned long )cmd_len) + (unsigned long )in_size);
#line 217
  clear_garbage___1(d___0);
#line 219
  memset((void *)sg_hd, 0, sizeof(sg_hd));
#line 220
  memset((void *)sense_buffer, 0, (size_t )16);
#line 221
  memcpy((void */* __restrict  */)(d___0->private_data)->sg_buffer, (void const   */* __restrict  */)cmd,
         (size_t )(cmd_len + in_size));
#line 222
  sg_hd->twelve_byte = (unsigned int )(cmd_len == 12U);
#line 223
  sg_hd->result = 0;
#line 224
  sg_hd->reply_len = (int )(sizeof(struct sg_header ) + (unsigned long )out_size);
  }
#line 234
  if (bytecheck) {
#line 234
    if (out_size > in_size) {
      {
#line 235
      memset((void *)(((d___0->private_data)->sg_buffer + cmd_len) + in_size), (int )bytefill,
             (size_t )(out_size - in_size));
#line 238
      writebytes += (long )(out_size - in_size);
      }
    }
  }
  {
#line 249
  while (1) {
    while_continue: /* CIL Label */ ;
#line 249
    __asm__  volatile   ("cld; rep; "
                         "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                         "1" (& fdset.__fds_bits[0]): "memory");
#line 249
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 250
  fdset.__fds_bits[d___0->cdda_fd / (8 * (int )sizeof(__fd_mask ))] |= 1L << d___0->cdda_fd % (8 * (int )sizeof(__fd_mask ));
#line 251
  tv.tv_sec = (__time_t )60;
#line 254
  tv.tv_usec = (__suseconds_t )0;
  {
#line 256
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 257
    tmp = select(d___0->cdda_fd + 1, (fd_set */* __restrict  */)((void *)0), (fd_set */* __restrict  */)(& fdset),
                 (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)(& tv));
#line 257
    ret = tmp;
    }
#line 258
    if (ret > 0) {
#line 258
      goto while_break___0;
    }
#line 259
    if (ret < 0) {
      {
#line 259
      tmp___0 = __errno_location();
      }
#line 259
      if (*tmp___0 != 4) {
#line 259
        goto while_break___0;
      }
    }
#line 260
    if (ret == 0) {
      {
#line 261
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\nSCSI transport error: timeout waiting to write packet\n\n");
      }
#line 263
      return (1);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 268
  sigprocmask(0, (sigset_t const   */* __restrict  */)(& d___0->sigset), (sigset_t */* __restrict  */)((void *)0));
#line 269
  tret1 = clock_gettime((d___0->private_data)->clock, & tv1);
#line 270
  tmp___1 = __errno_location();
#line 270
  *tmp___1 = 0;
#line 271
  tmp___2 = write(d___0->cdda_fd, (void const   *)sg_hd, (size_t )writebytes);
#line 271
  status = (int )tmp___2;
  }
#line 273
  if (status < 0) {
#line 273
    goto _L;
  } else
#line 273
  if ((long )status != writebytes) {
    _L: /* CIL Label */ 
    {
#line 274
    sigprocmask(1, (sigset_t const   */* __restrict  */)(& d___0->sigset), (sigset_t */* __restrict  */)((void *)0));
#line 275
    tmp___4 = __errno_location();
    }
#line 275
    if (*tmp___4 == 0) {
      {
#line 275
      tmp___3 = __errno_location();
#line 275
      *tmp___3 = 5;
      }
    }
#line 276
    return (1);
  }
  {
#line 289
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 289
    __asm__  volatile   ("cld; rep; "
                         "stosq": "=c" (__d0___0), "=D" (__d1___0): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                         "1" (& rset.__fds_bits[0]): "memory");
#line 289
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 290
  rset.__fds_bits[d___0->cdda_fd / (8 * (int )sizeof(__fd_mask ))] |= 1L << d___0->cdda_fd % (8 * (int )sizeof(__fd_mask ));
#line 291
  tv___0.tv_sec = (__time_t )60;
#line 294
  tv___0.tv_usec = (__suseconds_t )0;
  {
#line 296
  while (1) {
    while_continue___2: /* CIL Label */ ;
    {
#line 297
    tmp___5 = select(d___0->cdda_fd + 1, (fd_set */* __restrict  */)(& rset), (fd_set */* __restrict  */)((void *)0),
                     (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)(& tv___0));
#line 297
    ret___0 = tmp___5;
    }
#line 298
    if (ret___0 < 0) {
      {
#line 298
      tmp___6 = __errno_location();
      }
#line 298
      if (*tmp___6 != 4) {
#line 298
        goto while_break___2;
      }
    }
#line 299
    if (ret___0 == 0) {
      {
#line 300
      sigprocmask(1, (sigset_t const   */* __restrict  */)(& d___0->sigset), (sigset_t */* __restrict  */)((void *)0));
#line 301
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\nSCSI transport error: timeout waiting to read packet\n\n");
      }
#line 303
      return (2);
    }
#line 305
    if (ret___0 > 0) {
#line 307
      if ((rset.__fds_bits[d___0->cdda_fd / (8 * (int )sizeof(__fd_mask ))] & (1L << d___0->cdda_fd % (8 * (int )sizeof(__fd_mask )))) != 0L) {
#line 307
        goto while_break___2;
      }
      {
#line 308
      sigprocmask(1, (sigset_t const   */* __restrict  */)(& d___0->sigset), (sigset_t */* __restrict  */)((void *)0));
#line 309
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\nSCSI transport: error reading packet\n\n");
      }
#line 310
      return (2);
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 315
  tret2 = clock_gettime((d___0->private_data)->clock, & tv2);
#line 316
  tmp___7 = __errno_location();
#line 316
  *tmp___7 = 0;
#line 317
  tmp___8 = read(d___0->cdda_fd, (void *)sg_hd, sizeof(struct sg_header ) + (unsigned long )out_size);
#line 317
  status = (int )tmp___8;
#line 318
  sigprocmask(1, (sigset_t const   */* __restrict  */)(& d___0->sigset), (sigset_t */* __restrict  */)((void *)0));
#line 319
  memcpy((void */* __restrict  */)sense_buffer, (void const   */* __restrict  */)(sg_hd->sense_buffer),
         (size_t )16);
  }
#line 321
  if (status < 0) {
#line 321
    return (status);
  }
#line 323
  if ((unsigned long )status != sizeof(struct sg_header ) + (unsigned long )out_size) {
#line 323
    goto _L___0;
  } else
#line 323
  if (sg_hd->result) {
    _L___0: /* CIL Label */ 
    {
#line 324
    tmp___10 = __errno_location();
    }
#line 324
    if (*tmp___10 == 0) {
      {
#line 324
      tmp___9 = __errno_location();
#line 324
      *tmp___9 = 5;
      }
    }
#line 325
    return (2);
  }
  {
#line 328
  status = check_sbp_error___1((unsigned char const   )sg_hd->target_status, (unsigned char const   *)sense_buffer);
  }
#line 329
  if (status) {
#line 329
    return (status);
  }
#line 336
  if (bytecheck) {
#line 336
    if (in_size + cmd_len < out_size) {
#line 337
      flag = 0L;
#line 338
      i = (long )in_size;
      {
#line 338
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 338
        if (! (i < (long )out_size)) {
#line 338
          goto while_break___3;
        }
#line 339
        if ((int )*((d___0->private_data)->sg_buffer + i) != (int )bytefill) {
#line 340
          flag = 1L;
#line 341
          goto while_break___3;
        }
#line 338
        i ++;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 344
      if (! flag) {
        {
#line 345
        tmp___11 = __errno_location();
#line 345
        *tmp___11 = 22;
        }
#line 346
        return (5);
      }
    }
  }
  {
#line 350
  tmp___12 = __errno_location();
#line 350
  *tmp___12 = 0;
  }
#line 351
  if (tret1 < 0) {
#line 352
    (d___0->private_data)->last_milliseconds = -1;
  } else
#line 351
  if (tret2 < 0) {
#line 352
    (d___0->private_data)->last_milliseconds = -1;
  } else {
#line 354
    (d___0->private_data)->last_milliseconds = (int )((tv2.tv_sec - tv1.tv_sec) * 1000L + (tv2.tv_nsec - tv1.tv_nsec) / 1000000L);
  }
#line 356
  return (0);
}
}
#line 359 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
static int sgio_handle_scsi_cmd___1(cdrom_drive *d___0 , unsigned char *cmd , unsigned int cmd_len ,
                                    unsigned int in_size , unsigned int out_size ,
                                    unsigned char bytefill , int bytecheck , unsigned char *sense ) 
{ 
  int status ;
  struct sg_io_hdr hdr ;
  int *tmp ;
  int *tmp___0 ;
  long i ;
  long flag ;
  int *tmp___1 ;
  int *tmp___2 ;

  {
  {
#line 368
  status = 0;
#line 371
  memset((void *)(& hdr), 0, sizeof(hdr));
#line 372
  memset((void *)sense, 0, sizeof(sense));
#line 373
  memcpy((void */* __restrict  */)(d___0->private_data)->sg_buffer, (void const   */* __restrict  */)(cmd + cmd_len),
         (size_t )in_size);
#line 375
  hdr.cmdp = cmd;
#line 376
  hdr.cmd_len = (unsigned char )cmd_len;
#line 377
  hdr.sbp = sense;
#line 378
  hdr.mx_sb_len = (unsigned char)16;
#line 379
  hdr.timeout = 50000U;
#line 380
  hdr.interface_id = 'S';
#line 381
  hdr.dxferp = (void *)(d___0->private_data)->sg_buffer;
#line 382
  hdr.flags = 1U;
  }
#line 385
  if (bytecheck) {
#line 385
    if (out_size > in_size) {
      {
#line 386
      memset(hdr.dxferp + in_size, (int )bytefill, (size_t )(out_size - in_size));
      }
    }
  }
#line 388
  if (in_size) {
    {
#line 389
    hdr.dxfer_len = in_size;
#line 390
    hdr.dxfer_direction = -2;
#line 392
    tmp = __errno_location();
#line 392
    *tmp = 0;
#line 393
    status = ioctl(d___0->ioctl_fd, 8837UL, & hdr);
    }
#line 394
    if (status >= 0) {
#line 394
      if (hdr.status) {
        {
#line 395
        status = check_sbp_error___1((unsigned char const   )hdr.status, (unsigned char const   *)hdr.sbp);
        }
#line 396
        if (status) {
#line 396
          return (status);
        }
      }
    }
#line 398
    if (status < 0) {
#line 398
      return (1);
    }
  }
#line 401
  if ((unsigned int )(! in_size) | out_size) {
#line 402
    hdr.dxfer_len = out_size;
#line 404
    if (bytecheck) {
#line 404
      if (d___0->interface != 4) {
#line 405
        if (out_size) {
#line 405
          hdr.dxfer_direction = -4;
        } else {
#line 405
          hdr.dxfer_direction = -1;
        }
      } else {
#line 404
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 407
    if (out_size) {
#line 407
      hdr.dxfer_direction = -3;
    } else {
#line 407
      hdr.dxfer_direction = -1;
    }
    {
#line 409
    tmp___0 = __errno_location();
#line 409
    *tmp___0 = 0;
#line 410
    status = timed_ioctl___4(d___0, d___0->ioctl_fd, 8837, (void *)(& hdr));
    }
#line 411
    if (status >= 0) {
#line 411
      if (hdr.status) {
        {
#line 412
        status = check_sbp_error___1((unsigned char const   )hdr.status, (unsigned char const   *)hdr.sbp);
        }
#line 413
        if (status) {
#line 413
          return (status);
        }
      }
    }
#line 415
    if (status < 0) {
#line 415
      return (status);
    }
  }
#line 423
  if (bytecheck) {
#line 423
    if (in_size < out_size) {
#line 424
      flag = 0L;
#line 425
      i = (long )in_size;
      {
#line 425
      while (1) {
        while_continue: /* CIL Label */ ;
#line 425
        if (! (i < (long )out_size)) {
#line 425
          goto while_break;
        }
#line 426
        if ((int )*((d___0->private_data)->sg_buffer + i) != (int )bytefill) {
#line 427
          flag = 1L;
#line 428
          goto while_break;
        }
#line 425
        i ++;
      }
      while_break: /* CIL Label */ ;
      }
#line 431
      if (! flag) {
        {
#line 432
        tmp___1 = __errno_location();
#line 432
        *tmp___1 = 22;
        }
#line 433
        return (5);
      }
    }
  }
  {
#line 440
  tmp___2 = __errno_location();
#line 440
  *tmp___2 = 0;
  }
#line 441
  return (0);
}
}
#line 444 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
static int handle_scsi_cmd___1(cdrom_drive *d___0 , unsigned char *cmd , unsigned int cmd_len ,
                               unsigned int in_size , unsigned int out_size , unsigned char bytefill ,
                               int bytecheck , unsigned char *sense ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 453
  if (d___0->interface == 3) {
    {
#line 454
    tmp = sgio_handle_scsi_cmd___1(d___0, cmd, cmd_len, in_size, out_size, bytefill,
                                   bytecheck, sense);
    }
#line 454
    return (tmp);
  } else
#line 453
  if (d___0->interface == 4) {
    {
#line 454
    tmp = sgio_handle_scsi_cmd___1(d___0, cmd, cmd_len, in_size, out_size, bytefill,
                                   bytecheck, sense);
    }
#line 454
    return (tmp);
  }
  {
#line 455
  tmp___0 = sg2_handle_scsi_cmd___1(d___0, cmd, cmd_len, in_size, out_size, bytefill,
                                    bytecheck, sense);
  }
#line 455
  return (tmp___0);
}
}
#line 544 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
static int test_unit_ready___1(cdrom_drive *d___0 ) 
{ 
  unsigned char sense[16] ;
  unsigned char key ;
  unsigned char ASC ;
  unsigned char ASCQ ;
  unsigned char cmd[6] ;

  {
  {
#line 547
  cmd[0] = (unsigned char)0;
#line 547
  cmd[1] = (unsigned char)0;
#line 547
  cmd[2] = (unsigned char)0;
#line 547
  cmd[3] = (unsigned char)0;
#line 547
  cmd[4] = (unsigned char)0;
#line 547
  cmd[5] = (unsigned char)0;
#line 554
  handle_scsi_cmd___1(d___0, cmd, 6U, 0U, 56U, (unsigned char)0, 0, sense);
#line 556
  key = (unsigned char )((int )*((d___0->private_data)->sg_buffer + 2) & 15);
#line 557
  ASC = *((d___0->private_data)->sg_buffer + 12);
#line 558
  ASCQ = *((d___0->private_data)->sg_buffer + 13);
  }
#line 560
  if ((int )key == 2) {
#line 560
    if ((int )ASC == 4) {
#line 560
      if ((int )ASCQ == 1) {
#line 560
        return (0);
      }
    }
  }
#line 561
  return (1);
}
}
#line 565 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
static void reset_scsi___1(cdrom_drive *d___0 ) 
{ 
  int arg ;
  int tries ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 566
  tries = 0;
#line 567
  (*(d___0->enable_cdda))(d___0, 0);
#line 569
  cdmessage___7(d___0, "sending SG SCSI reset... ");
#line 570
  tmp = ioctl(d___0->cdda_fd, 8836UL, & arg);
  }
#line 570
  if (tmp) {
    {
#line 571
    cdmessage___7(d___0, "FAILED: EBUSY\n");
    }
  } else {
    {
#line 573
    cdmessage___7(d___0, "OK\n");
    }
  }
  {
#line 575
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 576
    tmp___0 = test_unit_ready___1(d___0);
    }
#line 576
    if (tmp___0) {
#line 576
      goto while_break;
    }
    {
#line 577
    tries ++;
#line 578
    usleep((__useconds_t )10);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 581
  (*(d___0->enable_cdda))(d___0, 1);
  }
#line 582
  return;
}
}
#line 607 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
static int mode_sense_atapi___1(cdrom_drive *d___0 , int size , int page ) 
{ 
  unsigned char sense[16] ;
  unsigned char cmd[10] ;
  int tmp ;
  unsigned char *b ;

  {
  {
#line 609
  cmd[0] = (unsigned char)90;
#line 609
  cmd[1] = (unsigned char)0;
#line 609
  cmd[2] = (unsigned char)0;
#line 609
  cmd[3] = (unsigned char)0;
#line 609
  cmd[4] = (unsigned char)0;
#line 609
  cmd[5] = (unsigned char)0;
#line 609
  cmd[6] = (unsigned char)0;
#line 609
  cmd[7] = (unsigned char)0;
#line 609
  cmd[8] = (unsigned char)0;
#line 609
  cmd[9] = (unsigned char)0;
#line 620
  cmd[1] = (unsigned char )(d___0->lun << 5);
#line 621
  cmd[2] = (unsigned char )(63 & page);
#line 622
  cmd[8] = (unsigned char )(size + 4);
#line 624
  tmp = handle_scsi_cmd___1(d___0, cmd, 10U, 0U, (unsigned int )(size + 4), (unsigned char )'\377',
                            1, sense);
  }
#line 624
  if (tmp) {
#line 624
    return (1);
  }
#line 627
  b = (d___0->private_data)->sg_buffer;
#line 628
  if (*(b + 0)) {
#line 628
    return (1);
  }
#line 629
  if (*(b + 6)) {
#line 629
    return (1);
  }
  {
#line 631
  *(b + 0) = (unsigned char )((int )*(b + 1) - 3);
#line 632
  *(b + 1) = *(b + 2);
#line 633
  *(b + 2) = *(b + 3);
#line 634
  *(b + 3) = *(b + 7);
#line 636
  memmove((void *)(b + 4), (void const   *)(b + 8), (size_t )(size - 4));
  }
#line 638
  return (0);
}
}
#line 643 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
static int mode_sense_scsi___1(cdrom_drive *d___0 , int size , int page ) 
{ 
  unsigned char sense[16] ;
  unsigned char cmd[6] ;
  int tmp ;

  {
  {
#line 645
  cmd[0] = (unsigned char)26;
#line 645
  cmd[1] = (unsigned char)0;
#line 645
  cmd[2] = (unsigned char)0;
#line 645
  cmd[3] = (unsigned char)0;
#line 645
  cmd[4] = (unsigned char)0;
#line 645
  cmd[5] = (unsigned char)0;
#line 652
  cmd[1] = (unsigned char )(d___0->lun << 5);
#line 653
  cmd[2] = (unsigned char )(63 & page);
#line 654
  cmd[4] = (unsigned char )size;
#line 656
  tmp = handle_scsi_cmd___1(d___0, cmd, 6U, 0U, (unsigned int )size, (unsigned char )'\377',
                            1, sense);
  }
#line 656
  if (tmp) {
#line 656
    return (1);
  }
#line 661
  return (0);
}
}
#line 664 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
static int mode_sense___1(cdrom_drive *d___0 , int size , int page ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 665
  if (d___0->is_atapi) {
    {
#line 666
    tmp = mode_sense_atapi___1(d___0, size, page);
    }
#line 666
    return (tmp);
  }
  {
#line 667
  tmp___0 = mode_sense_scsi___1(d___0, size, page);
  }
#line 667
  return (tmp___0);
}
}
#line 674 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
static int mode_select___1(cdrom_drive *d___0 , int density , int secsize ) 
{ 
  unsigned char sense[16] ;
  unsigned char cmd[26] ;
  unsigned char *mode ;
  int tmp ;
  unsigned char cmd___0[18] ;
  unsigned char *mode___0 ;
  int tmp___0 ;

  {
#line 677
  if (d___0->is_atapi) {
    {
#line 678
    cmd[0] = (unsigned char)85;
#line 678
    cmd[1] = (unsigned char)16;
#line 678
    cmd[2] = (unsigned char)0;
#line 678
    cmd[3] = (unsigned char)0;
#line 678
    cmd[4] = (unsigned char)0;
#line 678
    cmd[5] = (unsigned char)0;
#line 678
    cmd[6] = (unsigned char)0;
#line 678
    cmd[7] = (unsigned char)0;
#line 678
    cmd[8] = (unsigned char)16;
#line 678
    cmd[9] = (unsigned char)0;
#line 678
    cmd[10] = (unsigned char)0;
#line 678
    cmd[11] = (unsigned char)0;
#line 678
    cmd[12] = (unsigned char)0;
#line 678
    cmd[13] = (unsigned char)0;
#line 678
    cmd[14] = (unsigned char)0;
#line 678
    cmd[15] = (unsigned char)0;
#line 678
    cmd[16] = (unsigned char)0;
#line 678
    cmd[17] = (unsigned char)8;
#line 678
    cmd[18] = (unsigned char)0;
#line 678
    cmd[19] = (unsigned char)0;
#line 678
    cmd[20] = (unsigned char)0;
#line 678
    cmd[21] = (unsigned char)0;
#line 678
    cmd[22] = (unsigned char)0;
#line 678
    cmd[23] = (unsigned char)0;
#line 678
    cmd[24] = (unsigned char)0;
#line 678
    cmd[25] = (unsigned char)0;
#line 698
    mode = cmd + 18;
#line 701
    *(mode + 0) = (unsigned char )density;
#line 702
    *(mode + 6) = (unsigned char )(secsize >> 8);
#line 703
    *(mode + 7) = (unsigned char )(secsize & 255);
#line 706
    tmp = handle_scsi_cmd___1(d___0, cmd, 10U, 16U, 0U, (unsigned char)0, 0, sense);
    }
#line 706
    return (tmp);
  } else {
    {
#line 709
    cmd___0[0] = (unsigned char)21;
#line 709
    cmd___0[1] = (unsigned char)16;
#line 709
    cmd___0[2] = (unsigned char)0;
#line 709
    cmd___0[3] = (unsigned char)0;
#line 709
    cmd___0[4] = (unsigned char)12;
#line 709
    cmd___0[5] = (unsigned char)0;
#line 709
    cmd___0[6] = (unsigned char)0;
#line 709
    cmd___0[7] = (unsigned char)0;
#line 709
    cmd___0[8] = (unsigned char)0;
#line 709
    cmd___0[9] = (unsigned char)8;
#line 709
    cmd___0[10] = (unsigned char)0;
#line 709
    cmd___0[11] = (unsigned char)0;
#line 709
    cmd___0[12] = (unsigned char)0;
#line 709
    cmd___0[13] = (unsigned char)0;
#line 709
    cmd___0[14] = (unsigned char)0;
#line 709
    cmd___0[15] = (unsigned char)0;
#line 709
    cmd___0[16] = (unsigned char)0;
#line 709
    cmd___0[17] = (unsigned char)0;
#line 723
    mode___0 = cmd___0 + 10;
#line 726
    *(mode___0 + 0) = (unsigned char )density;
#line 727
    *(mode___0 + 6) = (unsigned char )(secsize >> 8);
#line 728
    *(mode___0 + 7) = (unsigned char )(secsize & 255);
#line 731
    tmp___0 = handle_scsi_cmd___1(d___0, cmd___0, 6U, 12U, 0U, (unsigned char)0, 0,
                                  sense);
    }
#line 731
    return (tmp___0);
  }
}
}
#line 736 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
static unsigned int get_orig_sectorsize___1(cdrom_drive *d___0 ) 
{ 
  int tmp ;
  unsigned int tmp___0 ;

  {
  {
#line 737
  tmp = mode_sense___1(d___0, 12, 1);
  }
#line 737
  if (tmp) {
#line 737
    return (4294967295U);
  }
#line 739
  d___0->orgdens = *((d___0->private_data)->sg_buffer + 4);
#line 740
  tmp___0 = (unsigned int )(((int )*((d___0->private_data)->sg_buffer + 10) << 8) + (int )*((d___0->private_data)->sg_buffer + 11));
#line 740
  d___0->orgsize = tmp___0;
#line 740
  return (tmp___0);
}
}
#line 744 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
static int set_sectorsize___1(cdrom_drive *d___0 , unsigned int secsize ) 
{ 
  int tmp ;

  {
  {
#line 745
  tmp = mode_select___1(d___0, (int )d___0->orgdens, (int )secsize);
  }
#line 745
  return (tmp);
}
}
#line 782 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
static int scsi_read_toc___1(cdrom_drive *d___0 ) 
{ 
  int i ;
  int first ;
  int last___0 ;
  unsigned int tracks ;
  unsigned char sense[16] ;
  unsigned char cmd[10] ;
  int tmp ;
  char __constr_expr_6[10] ;
  int tmp___0 ;
  scsi_TOC *toc ;
  char __constr_expr_7[10] ;
  int tmp___1 ;
  scsi_TOC *toc___0 ;

  {
  {
#line 791
  cmd[0] = (unsigned char)67;
#line 791
  cmd[1] = (unsigned char)0;
#line 791
  cmd[2] = (unsigned char)0;
#line 791
  cmd[3] = (unsigned char)0;
#line 791
  cmd[4] = (unsigned char)0;
#line 791
  cmd[5] = (unsigned char)0;
#line 791
  cmd[6] = (unsigned char)1;
#line 791
  cmd[7] = (unsigned char)0;
#line 791
  cmd[8] = (unsigned char)12;
#line 791
  cmd[9] = (unsigned char)0;
#line 792
  cmd[1] = (unsigned char )(d___0->lun << 5);
#line 794
  tmp = handle_scsi_cmd___1(d___0, cmd, 10U, 0U, 12U, (unsigned char )'\377', 1, sense);
  }
#line 794
  if (tmp) {
    {
#line 795
    cderror___8(d___0, "004: Unable to read table of contents header\n");
    }
#line 796
    return (-4);
  }
#line 799
  first = (int )*((d___0->private_data)->sg_buffer + 2);
#line 800
  last___0 = (int )*((d___0->private_data)->sg_buffer + 3);
#line 801
  tracks = (unsigned int )((last___0 - first) + 1);
#line 803
  if (last___0 > 100) {
    {
#line 804
    cderror___8(d___0, "003: CDROM reporting illegal number of tracks\n");
    }
#line 805
    return (-3);
  } else
#line 803
  if (first > 100) {
    {
#line 804
    cderror___8(d___0, "003: CDROM reporting illegal number of tracks\n");
    }
#line 805
    return (-3);
  } else
#line 803
  if (last___0 < 0) {
    {
#line 804
    cderror___8(d___0, "003: CDROM reporting illegal number of tracks\n");
    }
#line 805
    return (-3);
  } else
#line 803
  if (first < 0) {
    {
#line 804
    cderror___8(d___0, "003: CDROM reporting illegal number of tracks\n");
    }
#line 805
    return (-3);
  }
#line 808
  i = first;
  {
#line 808
  while (1) {
    while_continue: /* CIL Label */ ;
#line 808
    if (! (i <= last___0)) {
#line 808
      goto while_break;
    }
    {
#line 809
    __constr_expr_6[0] = (char)67;
#line 809
    __constr_expr_6[1] = (char)0;
#line 809
    __constr_expr_6[2] = (char)0;
#line 809
    __constr_expr_6[3] = (char)0;
#line 809
    __constr_expr_6[4] = (char)0;
#line 809
    __constr_expr_6[5] = (char)0;
#line 809
    __constr_expr_6[6] = (char)0;
#line 809
    __constr_expr_6[7] = (char)0;
#line 809
    __constr_expr_6[8] = (char)12;
#line 809
    __constr_expr_6[9] = (char)0;
#line 809
    memcpy((void */* __restrict  */)(cmd), (void const   */* __restrict  */)(__constr_expr_6),
           (size_t )10);
#line 810
    cmd[1] = (unsigned char )(d___0->lun << 5);
#line 811
    cmd[6] = (unsigned char )i;
#line 813
    tmp___0 = handle_scsi_cmd___1(d___0, cmd, 10U, 0U, 12U, (unsigned char )'\377',
                                  1, sense);
    }
#line 813
    if (tmp___0) {
      {
#line 814
      cderror___8(d___0, "005: Unable to read table of contents entry\n");
      }
#line 815
      return (-5);
    }
#line 818
    toc = (scsi_TOC *)((d___0->private_data)->sg_buffer + 4);
#line 820
    d___0->disc_toc[i - first].bFlags = toc->bFlags;
#line 821
    d___0->disc_toc[i - first].bTrack = (unsigned char )i;
#line 822
    d___0->disc_toc[i - first].dwStartSector = d___0->adjust_ssize * (((((int )toc->start_MSB << 24) | ((int )toc->start_1 << 16)) | ((int )toc->start_2 << 8)) | (int )toc->start_LSB);
#line 808
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 830
  __constr_expr_7[0] = (char)67;
#line 830
  __constr_expr_7[1] = (char)0;
#line 830
  __constr_expr_7[2] = (char)0;
#line 830
  __constr_expr_7[3] = (char)0;
#line 830
  __constr_expr_7[4] = (char)0;
#line 830
  __constr_expr_7[5] = (char)0;
#line 830
  __constr_expr_7[6] = (char)0;
#line 830
  __constr_expr_7[7] = (char)0;
#line 830
  __constr_expr_7[8] = (char)12;
#line 830
  __constr_expr_7[9] = (char)0;
#line 830
  memcpy((void */* __restrict  */)(cmd), (void const   */* __restrict  */)(__constr_expr_7),
         (size_t )10);
#line 831
  cmd[1] = (unsigned char )(d___0->lun << 5);
#line 832
  cmd[6] = (unsigned char)170;
#line 834
  tmp___1 = handle_scsi_cmd___1(d___0, cmd, 10U, 0U, 12U, (unsigned char )'\377',
                                1, sense);
  }
#line 834
  if (tmp___1) {
    {
#line 835
    cderror___8(d___0, "002: Unable to read table of contents lead-out\n");
    }
#line 836
    return (-2);
  }
  {
#line 839
  toc___0 = (scsi_TOC *)((d___0->private_data)->sg_buffer + 4);
#line 841
  d___0->disc_toc[i - first].bFlags = toc___0->bFlags;
#line 842
  d___0->disc_toc[i - first].bTrack = (unsigned char)170;
#line 843
  d___0->disc_toc[i - first].dwStartSector = d___0->adjust_ssize * (((((int )toc___0->start_MSB << 24) | ((int )toc___0->start_1 << 16)) | ((int )toc___0->start_2 << 8)) | (int )toc___0->start_LSB);
#line 850
  d___0->cd_extra = FixupTOC(d___0, (int )(tracks + 1U));
  }
#line 851
  return ((int )tracks);
}
}
#line 856 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
static int scsi_read_toc2___1(cdrom_drive *d___0 ) 
{ 
  u_int32_t foo ;
  u_int32_t bar ;
  int i ;
  unsigned int tracks ;
  unsigned char cmd[10] ;
  unsigned char sense[16] ;
  int tmp ;
  char __constr_expr_8[10] ;
  int tmp___0 ;
  int32_t tmp___1 ;
  int32_t tmp___2 ;

  {
  {
#line 862
  cmd[0] = (unsigned char)229;
#line 862
  cmd[1] = (unsigned char)0;
#line 862
  cmd[2] = (unsigned char)0;
#line 862
  cmd[3] = (unsigned char)0;
#line 862
  cmd[4] = (unsigned char)0;
#line 862
  cmd[5] = (unsigned char)0;
#line 862
  cmd[6] = (unsigned char)0;
#line 862
  cmd[7] = (unsigned char)0;
#line 862
  cmd[8] = (unsigned char)0;
#line 862
  cmd[9] = (unsigned char)0;
#line 864
  cmd[5] = (unsigned char)1;
#line 865
  cmd[8] = (unsigned char)255;
#line 867
  tmp = handle_scsi_cmd___1(d___0, cmd, 10U, 0U, 256U, (unsigned char )'\377', 1,
                            sense);
  }
#line 867
  if (tmp) {
    {
#line 868
    cderror___8(d___0, "004: Unable to read table of contents header\n");
    }
#line 869
    return (-4);
  }
#line 873
  tracks = (unsigned int )*((d___0->private_data)->sg_buffer + 1);
#line 874
  if (tracks > 100U) {
    {
#line 875
    cderror___8(d___0, "003: CDROM reporting illegal number of tracks\n");
    }
#line 876
    return (-3);
  }
#line 879
  i = 0;
  {
#line 879
  while (1) {
    while_continue: /* CIL Label */ ;
#line 879
    if (! ((unsigned int )i < tracks)) {
#line 879
      goto while_break;
    }
    {
#line 880
    __constr_expr_8[0] = (char)-27;
#line 880
    __constr_expr_8[1] = (char)0;
#line 880
    __constr_expr_8[2] = (char)0;
#line 880
    __constr_expr_8[3] = (char)0;
#line 880
    __constr_expr_8[4] = (char)0;
#line 880
    __constr_expr_8[5] = (char)0;
#line 880
    __constr_expr_8[6] = (char)0;
#line 880
    __constr_expr_8[7] = (char)0;
#line 880
    __constr_expr_8[8] = (char)0;
#line 880
    __constr_expr_8[9] = (char)0;
#line 880
    memcpy((void */* __restrict  */)(cmd), (void const   */* __restrict  */)(__constr_expr_8),
           (size_t )10);
#line 881
    cmd[5] = (unsigned char )(i + 1);
#line 882
    cmd[8] = (unsigned char)255;
#line 884
    tmp___0 = handle_scsi_cmd___1(d___0, cmd, 10U, 0U, 256U, (unsigned char )'\377',
                                  1, sense);
    }
#line 884
    if (tmp___0) {
      {
#line 885
      cderror___8(d___0, "005: Unable to read table of contents entry\n");
      }
#line 886
      return (-5);
    }
#line 889
    d___0->disc_toc[i].bFlags = *((d___0->private_data)->sg_buffer + 10);
#line 890
    d___0->disc_toc[i].bTrack = (unsigned char )(i + 1);
#line 892
    d___0->disc_toc[i].dwStartSector = d___0->adjust_ssize * (((((int )((signed char )*((d___0->private_data)->sg_buffer + 2)) << 24) | ((int )*((d___0->private_data)->sg_buffer + 3) << 16)) | ((int )*((d___0->private_data)->sg_buffer + 4) << 8)) | (int )*((d___0->private_data)->sg_buffer + 5));
#line 879
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 899
  d___0->disc_toc[i].bFlags = (unsigned char)0;
#line 900
  d___0->disc_toc[i].bTrack = (unsigned char )(i + 1);
#line 901
  memcpy((void */* __restrict  */)(& foo), (void const   */* __restrict  */)((d___0->private_data)->sg_buffer + 2),
         (size_t )4);
#line 902
  memcpy((void */* __restrict  */)(& bar), (void const   */* __restrict  */)((d___0->private_data)->sg_buffer + 6),
         (size_t )4);
#line 903
  tmp___1 = be32_to_cpu((int32_t )foo);
#line 903
  tmp___2 = be32_to_cpu((int32_t )bar);
#line 903
  d___0->disc_toc[i].dwStartSector = d___0->adjust_ssize * (tmp___1 + tmp___2);
#line 906
  d___0->disc_toc[i].dwStartSector = d___0->adjust_ssize * ((((((int )((signed char )*((d___0->private_data)->sg_buffer + 2)) << 24) | ((int )*((d___0->private_data)->sg_buffer + 3) << 16)) | ((int )*((d___0->private_data)->sg_buffer + 4) << 8)) | (int )*((d___0->private_data)->sg_buffer + 5)) + (((((int )((signed char )*((d___0->private_data)->sg_buffer + 6)) << 24) | ((int )*((d___0->private_data)->sg_buffer + 7) << 16)) | ((int )*((d___0->private_data)->sg_buffer + 8) << 8)) | (int )*((d___0->private_data)->sg_buffer + 9)));
#line 918
  d___0->cd_extra = FixupTOC(d___0, (int )(tracks + 1U));
  }
#line 919
  return ((int )tracks);
}
}
#line 922 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
static int scsi_set_speed___1(cdrom_drive *d___0 , int speed ) 
{ 
  unsigned char cmd[12] ;
  unsigned char sense[16] ;
  int tmp ;

  {
#line 923
  cmd[0] = (unsigned char)187;
#line 923
  cmd[1] = (unsigned char)0;
#line 923
  cmd[2] = (unsigned char)0;
#line 923
  cmd[3] = (unsigned char)0;
#line 923
  cmd[4] = (unsigned char)255;
#line 923
  cmd[5] = (unsigned char)255;
#line 923
  cmd[6] = (unsigned char)0;
#line 923
  cmd[7] = (unsigned char)0;
#line 923
  cmd[8] = (unsigned char)0;
#line 923
  cmd[9] = (unsigned char)0;
#line 923
  cmd[10] = (unsigned char)0;
#line 923
  cmd[11] = (unsigned char)0;
#line 926
  if (speed >= 0) {
#line 927
    speed = ((speed * 44100) * 4) / 1024;
  } else {
#line 929
    speed = -1;
  }
  {
#line 930
  cmd[2] = (unsigned char )((speed >> 8) & 255);
#line 931
  cmd[3] = (unsigned char )(speed & 255);
#line 932
  tmp = handle_scsi_cmd___1(d___0, cmd, 12U, 0U, 0U, (unsigned char)0, 0, sense);
  }
#line 932
  return (tmp);
}
}
#line 937 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
static int i_read_28___1(cdrom_drive *d___0 , void *p___0 , long begin , long sectors ,
                         unsigned char *sense ) 
{ 
  int ret ;
  unsigned char cmd[10] ;

  {
#line 939
  cmd[0] = (unsigned char)40;
#line 939
  cmd[1] = (unsigned char)0;
#line 939
  cmd[2] = (unsigned char)0;
#line 939
  cmd[3] = (unsigned char)0;
#line 939
  cmd[4] = (unsigned char)0;
#line 939
  cmd[5] = (unsigned char)0;
#line 939
  cmd[6] = (unsigned char)0;
#line 939
  cmd[7] = (unsigned char)0;
#line 939
  cmd[8] = (unsigned char)0;
#line 939
  cmd[9] = (unsigned char)0;
#line 941
  if (d___0->fua) {
#line 942
    cmd[1] = (unsigned char)8;
  }
  {
#line 944
  cmd[1] = (unsigned char )((int )cmd[1] | (d___0->lun << 5));
#line 946
  cmd[3] = (unsigned char )((begin >> 16) & 255L);
#line 947
  cmd[4] = (unsigned char )((begin >> 8) & 255L);
#line 948
  cmd[5] = (unsigned char )(begin & 255L);
#line 949
  cmd[8] = (unsigned char )sectors;
#line 950
  ret = handle_scsi_cmd___1(d___0, cmd, 10U, 0U, (unsigned int )(sectors * 2352L),
                            (unsigned char )'\177', 1, sense);
  }
#line 950
  if (ret) {
#line 951
    return (ret);
  }
#line 952
  if (p___0) {
    {
#line 952
    memcpy((void */* __restrict  */)p___0, (void const   */* __restrict  */)(d___0->private_data)->sg_buffer,
           (size_t )(sectors * 2352L));
    }
  }
#line 953
  return (0);
}
}
#line 956 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
static int i_read_A8___1(cdrom_drive *d___0 , void *p___0 , long begin , long sectors ,
                         unsigned char *sense ) 
{ 
  int ret ;
  unsigned char cmd[12] ;

  {
#line 958
  cmd[0] = (unsigned char)168;
#line 958
  cmd[1] = (unsigned char)0;
#line 958
  cmd[2] = (unsigned char)0;
#line 958
  cmd[3] = (unsigned char)0;
#line 958
  cmd[4] = (unsigned char)0;
#line 958
  cmd[5] = (unsigned char)0;
#line 958
  cmd[6] = (unsigned char)0;
#line 958
  cmd[7] = (unsigned char)0;
#line 958
  cmd[8] = (unsigned char)0;
#line 958
  cmd[9] = (unsigned char)0;
#line 958
  cmd[10] = (unsigned char)0;
#line 958
  cmd[11] = (unsigned char)0;
#line 960
  if (d___0->fua) {
#line 961
    cmd[1] = (unsigned char)8;
  }
  {
#line 963
  cmd[1] = (unsigned char )((int )cmd[1] | (d___0->lun << 5));
#line 965
  cmd[3] = (unsigned char )((begin >> 16) & 255L);
#line 966
  cmd[4] = (unsigned char )((begin >> 8) & 255L);
#line 967
  cmd[5] = (unsigned char )(begin & 255L);
#line 968
  cmd[9] = (unsigned char )sectors;
#line 969
  ret = handle_scsi_cmd___1(d___0, cmd, 12U, 0U, (unsigned int )(sectors * 2352L),
                            (unsigned char )'\177', 1, sense);
  }
#line 969
  if (ret) {
#line 970
    return (ret);
  }
#line 971
  if (p___0) {
    {
#line 971
    memcpy((void */* __restrict  */)p___0, (void const   */* __restrict  */)(d___0->private_data)->sg_buffer,
           (size_t )(sectors * 2352L));
    }
  }
#line 972
  return (0);
}
}
#line 975 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
static int i_read_D4_10___1(cdrom_drive *d___0 , void *p___0 , long begin , long sectors ,
                            unsigned char *sense ) 
{ 
  int ret ;
  unsigned char cmd[10] ;

  {
#line 977
  cmd[0] = (unsigned char)212;
#line 977
  cmd[1] = (unsigned char)0;
#line 977
  cmd[2] = (unsigned char)0;
#line 977
  cmd[3] = (unsigned char)0;
#line 977
  cmd[4] = (unsigned char)0;
#line 977
  cmd[5] = (unsigned char)0;
#line 977
  cmd[6] = (unsigned char)0;
#line 977
  cmd[7] = (unsigned char)0;
#line 977
  cmd[8] = (unsigned char)0;
#line 977
  cmd[9] = (unsigned char)0;
#line 979
  if (d___0->fua) {
#line 980
    cmd[1] = (unsigned char)8;
  }
  {
#line 982
  cmd[1] = (unsigned char )((int )cmd[1] | (d___0->lun << 5));
#line 983
  cmd[3] = (unsigned char )((begin >> 16) & 255L);
#line 984
  cmd[4] = (unsigned char )((begin >> 8) & 255L);
#line 985
  cmd[5] = (unsigned char )(begin & 255L);
#line 986
  cmd[8] = (unsigned char )sectors;
#line 987
  ret = handle_scsi_cmd___1(d___0, cmd, 10U, 0U, (unsigned int )(sectors * 2352L),
                            (unsigned char )'\177', 1, sense);
  }
#line 987
  if (ret) {
#line 988
    return (ret);
  }
#line 989
  if (p___0) {
    {
#line 989
    memcpy((void */* __restrict  */)p___0, (void const   */* __restrict  */)(d___0->private_data)->sg_buffer,
           (size_t )(sectors * 2352L));
    }
  }
#line 990
  return (0);
}
}
#line 993 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
static int i_read_D4_12___1(cdrom_drive *d___0 , void *p___0 , long begin , long sectors ,
                            unsigned char *sense ) 
{ 
  int ret ;
  unsigned char cmd[12] ;

  {
#line 995
  cmd[0] = (unsigned char)212;
#line 995
  cmd[1] = (unsigned char)0;
#line 995
  cmd[2] = (unsigned char)0;
#line 995
  cmd[3] = (unsigned char)0;
#line 995
  cmd[4] = (unsigned char)0;
#line 995
  cmd[5] = (unsigned char)0;
#line 995
  cmd[6] = (unsigned char)0;
#line 995
  cmd[7] = (unsigned char)0;
#line 995
  cmd[8] = (unsigned char)0;
#line 995
  cmd[9] = (unsigned char)0;
#line 995
  cmd[10] = (unsigned char)0;
#line 995
  cmd[11] = (unsigned char)0;
#line 997
  if (d___0->fua) {
#line 998
    cmd[1] = (unsigned char)8;
  }
  {
#line 1000
  cmd[1] = (unsigned char )((int )cmd[1] | (d___0->lun << 5));
#line 1001
  cmd[3] = (unsigned char )((begin >> 16) & 255L);
#line 1002
  cmd[4] = (unsigned char )((begin >> 8) & 255L);
#line 1003
  cmd[5] = (unsigned char )(begin & 255L);
#line 1004
  cmd[9] = (unsigned char )sectors;
#line 1005
  ret = handle_scsi_cmd___1(d___0, cmd, 12U, 0U, (unsigned int )(sectors * 2352L),
                            (unsigned char )'\177', 1, sense);
  }
#line 1005
  if (ret) {
#line 1006
    return (ret);
  }
#line 1007
  if (p___0) {
    {
#line 1007
    memcpy((void */* __restrict  */)p___0, (void const   */* __restrict  */)(d___0->private_data)->sg_buffer,
           (size_t )(sectors * 2352L));
    }
  }
#line 1008
  return (0);
}
}
#line 1011 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
static int i_read_D5___1(cdrom_drive *d___0 , void *p___0 , long begin , long sectors ,
                         unsigned char *sense ) 
{ 
  int ret ;
  unsigned char cmd[10] ;

  {
#line 1013
  cmd[0] = (unsigned char)213;
#line 1013
  cmd[1] = (unsigned char)0;
#line 1013
  cmd[2] = (unsigned char)0;
#line 1013
  cmd[3] = (unsigned char)0;
#line 1013
  cmd[4] = (unsigned char)0;
#line 1013
  cmd[5] = (unsigned char)0;
#line 1013
  cmd[6] = (unsigned char)0;
#line 1013
  cmd[7] = (unsigned char)0;
#line 1013
  cmd[8] = (unsigned char)0;
#line 1013
  cmd[9] = (unsigned char)0;
#line 1015
  if (d___0->fua) {
#line 1016
    cmd[1] = (unsigned char)8;
  }
  {
#line 1018
  cmd[1] = (unsigned char )((int )cmd[1] | (d___0->lun << 5));
#line 1019
  cmd[3] = (unsigned char )((begin >> 16) & 255L);
#line 1020
  cmd[4] = (unsigned char )((begin >> 8) & 255L);
#line 1021
  cmd[5] = (unsigned char )(begin & 255L);
#line 1022
  cmd[8] = (unsigned char )sectors;
#line 1023
  ret = handle_scsi_cmd___1(d___0, cmd, 10U, 0U, (unsigned int )(sectors * 2352L),
                            (unsigned char )'\177', 1, sense);
  }
#line 1023
  if (ret) {
#line 1024
    return (ret);
  }
#line 1025
  if (p___0) {
    {
#line 1025
    memcpy((void */* __restrict  */)p___0, (void const   */* __restrict  */)(d___0->private_data)->sg_buffer,
           (size_t )(sectors * 2352L));
    }
  }
#line 1026
  return (0);
}
}
#line 1029 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
static int i_read_D8___1(cdrom_drive *d___0 , void *p___0 , long begin , long sectors ,
                         unsigned char *sense ) 
{ 
  int ret ;
  unsigned char cmd[12] ;

  {
#line 1031
  cmd[0] = (unsigned char)216;
#line 1031
  cmd[1] = (unsigned char)0;
#line 1031
  cmd[2] = (unsigned char)0;
#line 1031
  cmd[3] = (unsigned char)0;
#line 1031
  cmd[4] = (unsigned char)0;
#line 1031
  cmd[5] = (unsigned char)0;
#line 1031
  cmd[6] = (unsigned char)0;
#line 1031
  cmd[7] = (unsigned char)0;
#line 1031
  cmd[8] = (unsigned char)0;
#line 1031
  cmd[9] = (unsigned char)0;
#line 1031
  cmd[10] = (unsigned char)0;
#line 1031
  cmd[11] = (unsigned char)0;
#line 1033
  if (d___0->fua) {
#line 1034
    cmd[1] = (unsigned char)8;
  }
  {
#line 1036
  cmd[1] = (unsigned char )((int )cmd[1] | (d___0->lun << 5));
#line 1037
  cmd[3] = (unsigned char )((begin >> 16) & 255L);
#line 1038
  cmd[4] = (unsigned char )((begin >> 8) & 255L);
#line 1039
  cmd[5] = (unsigned char )(begin & 255L);
#line 1040
  cmd[9] = (unsigned char )sectors;
#line 1041
  ret = handle_scsi_cmd___1(d___0, cmd, 12U, 0U, (unsigned int )(sectors * 2352L),
                            (unsigned char )'\177', 1, sense);
  }
#line 1041
  if (ret) {
#line 1042
    return (ret);
  }
#line 1043
  if (p___0) {
    {
#line 1043
    memcpy((void */* __restrict  */)p___0, (void const   */* __restrict  */)(d___0->private_data)->sg_buffer,
           (size_t )(sectors * 2352L));
    }
  }
#line 1044
  return (0);
}
}
#line 1047 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
static int i_read_mmc___1(cdrom_drive *d___0 , void *p___0 , long begin , long sectors ,
                          unsigned char *sense ) 
{ 
  int ret ;
  unsigned char cmd[12] ;

  {
  {
#line 1049
  cmd[0] = (unsigned char)190;
#line 1049
  cmd[1] = (unsigned char)2;
#line 1049
  cmd[2] = (unsigned char)0;
#line 1049
  cmd[3] = (unsigned char)0;
#line 1049
  cmd[4] = (unsigned char)0;
#line 1049
  cmd[5] = (unsigned char)0;
#line 1049
  cmd[6] = (unsigned char)0;
#line 1049
  cmd[7] = (unsigned char)0;
#line 1049
  cmd[8] = (unsigned char)0;
#line 1049
  cmd[9] = (unsigned char)16;
#line 1049
  cmd[10] = (unsigned char)0;
#line 1049
  cmd[11] = (unsigned char)0;
#line 1051
  cmd[3] = (unsigned char )((begin >> 16) & 255L);
#line 1052
  cmd[4] = (unsigned char )((begin >> 8) & 255L);
#line 1053
  cmd[5] = (unsigned char )(begin & 255L);
#line 1054
  cmd[8] = (unsigned char )sectors;
#line 1055
  ret = handle_scsi_cmd___1(d___0, cmd, 12U, 0U, (unsigned int )(sectors * 2352L),
                            (unsigned char )'\177', 1, sense);
  }
#line 1055
  if (ret) {
#line 1056
    return (ret);
  }
#line 1057
  if (p___0) {
    {
#line 1057
    memcpy((void */* __restrict  */)p___0, (void const   */* __restrict  */)(d___0->private_data)->sg_buffer,
           (size_t )(sectors * 2352L));
    }
  }
#line 1058
  return (0);
}
}
#line 1061 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
static int i_read_mmcB___1(cdrom_drive *d___0 , void *p___0 , long begin , long sectors ,
                           unsigned char *sense ) 
{ 
  int ret ;
  unsigned char cmd[12] ;

  {
  {
#line 1063
  cmd[0] = (unsigned char)190;
#line 1063
  cmd[1] = (unsigned char)0;
#line 1063
  cmd[2] = (unsigned char)0;
#line 1063
  cmd[3] = (unsigned char)0;
#line 1063
  cmd[4] = (unsigned char)0;
#line 1063
  cmd[5] = (unsigned char)0;
#line 1063
  cmd[6] = (unsigned char)0;
#line 1063
  cmd[7] = (unsigned char)0;
#line 1063
  cmd[8] = (unsigned char)0;
#line 1063
  cmd[9] = (unsigned char)16;
#line 1063
  cmd[10] = (unsigned char)0;
#line 1063
  cmd[11] = (unsigned char)0;
#line 1065
  cmd[3] = (unsigned char )((begin >> 16) & 255L);
#line 1066
  cmd[4] = (unsigned char )((begin >> 8) & 255L);
#line 1067
  cmd[5] = (unsigned char )(begin & 255L);
#line 1068
  cmd[8] = (unsigned char )sectors;
#line 1069
  ret = handle_scsi_cmd___1(d___0, cmd, 12U, 0U, (unsigned int )(sectors * 2352L),
                            (unsigned char )'\177', 1, sense);
  }
#line 1069
  if (ret) {
#line 1070
    return (ret);
  }
#line 1071
  if (p___0) {
    {
#line 1071
    memcpy((void */* __restrict  */)p___0, (void const   */* __restrict  */)(d___0->private_data)->sg_buffer,
           (size_t )(sectors * 2352L));
    }
  }
#line 1072
  return (0);
}
}
#line 1075 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
static int i_read_mmc2___1(cdrom_drive *d___0 , void *p___0 , long begin , long sectors ,
                           unsigned char *sense ) 
{ 
  int ret ;
  unsigned char cmd[12] ;

  {
  {
#line 1077
  cmd[0] = (unsigned char)190;
#line 1077
  cmd[1] = (unsigned char)2;
#line 1077
  cmd[2] = (unsigned char)0;
#line 1077
  cmd[3] = (unsigned char)0;
#line 1077
  cmd[4] = (unsigned char)0;
#line 1077
  cmd[5] = (unsigned char)0;
#line 1077
  cmd[6] = (unsigned char)0;
#line 1077
  cmd[7] = (unsigned char)0;
#line 1077
  cmd[8] = (unsigned char)0;
#line 1077
  cmd[9] = (unsigned char)248;
#line 1077
  cmd[10] = (unsigned char)0;
#line 1077
  cmd[11] = (unsigned char)0;
#line 1079
  cmd[3] = (unsigned char )((begin >> 16) & 255L);
#line 1080
  cmd[4] = (unsigned char )((begin >> 8) & 255L);
#line 1081
  cmd[5] = (unsigned char )(begin & 255L);
#line 1082
  cmd[8] = (unsigned char )sectors;
#line 1083
  ret = handle_scsi_cmd___1(d___0, cmd, 12U, 0U, (unsigned int )(sectors * 2352L),
                            (unsigned char )'\177', 1, sense);
  }
#line 1083
  if (ret) {
#line 1084
    return (ret);
  }
#line 1085
  if (p___0) {
    {
#line 1085
    memcpy((void */* __restrict  */)p___0, (void const   */* __restrict  */)(d___0->private_data)->sg_buffer,
           (size_t )(sectors * 2352L));
    }
  }
#line 1086
  return (0);
}
}
#line 1089 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
static int i_read_mmc2B___1(cdrom_drive *d___0 , void *p___0 , long begin , long sectors ,
                            unsigned char *sense ) 
{ 
  int ret ;
  unsigned char cmd[12] ;

  {
  {
#line 1091
  cmd[0] = (unsigned char)190;
#line 1091
  cmd[1] = (unsigned char)0;
#line 1091
  cmd[2] = (unsigned char)0;
#line 1091
  cmd[3] = (unsigned char)0;
#line 1091
  cmd[4] = (unsigned char)0;
#line 1091
  cmd[5] = (unsigned char)0;
#line 1091
  cmd[6] = (unsigned char)0;
#line 1091
  cmd[7] = (unsigned char)0;
#line 1091
  cmd[8] = (unsigned char)0;
#line 1091
  cmd[9] = (unsigned char)248;
#line 1091
  cmd[10] = (unsigned char)0;
#line 1091
  cmd[11] = (unsigned char)0;
#line 1093
  cmd[3] = (unsigned char )((begin >> 16) & 255L);
#line 1094
  cmd[4] = (unsigned char )((begin >> 8) & 255L);
#line 1095
  cmd[5] = (unsigned char )(begin & 255L);
#line 1096
  cmd[8] = (unsigned char )sectors;
#line 1097
  ret = handle_scsi_cmd___1(d___0, cmd, 12U, 0U, (unsigned int )(sectors * 2352L),
                            (unsigned char )'\177', 1, sense);
  }
#line 1097
  if (ret) {
#line 1098
    return (ret);
  }
#line 1099
  if (p___0) {
    {
#line 1099
    memcpy((void */* __restrict  */)p___0, (void const   */* __restrict  */)(d___0->private_data)->sg_buffer,
           (size_t )(sectors * 2352L));
    }
  }
#line 1100
  return (0);
}
}
#line 1103 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
static int i_read_mmc3___1(cdrom_drive *d___0 , void *p___0 , long begin , long sectors ,
                           unsigned char *sense ) 
{ 
  int ret ;
  unsigned char cmd[12] ;

  {
  {
#line 1105
  cmd[0] = (unsigned char)190;
#line 1105
  cmd[1] = (unsigned char)6;
#line 1105
  cmd[2] = (unsigned char)0;
#line 1105
  cmd[3] = (unsigned char)0;
#line 1105
  cmd[4] = (unsigned char)0;
#line 1105
  cmd[5] = (unsigned char)0;
#line 1105
  cmd[6] = (unsigned char)0;
#line 1105
  cmd[7] = (unsigned char)0;
#line 1105
  cmd[8] = (unsigned char)0;
#line 1105
  cmd[9] = (unsigned char)248;
#line 1105
  cmd[10] = (unsigned char)0;
#line 1105
  cmd[11] = (unsigned char)0;
#line 1107
  cmd[3] = (unsigned char )((begin >> 16) & 255L);
#line 1108
  cmd[4] = (unsigned char )((begin >> 8) & 255L);
#line 1109
  cmd[5] = (unsigned char )(begin & 255L);
#line 1110
  cmd[8] = (unsigned char )sectors;
#line 1111
  ret = handle_scsi_cmd___1(d___0, cmd, 12U, 0U, (unsigned int )(sectors * 2352L),
                            (unsigned char )'\177', 1, sense);
  }
#line 1111
  if (ret) {
#line 1112
    return (ret);
  }
#line 1113
  if (p___0) {
    {
#line 1113
    memcpy((void */* __restrict  */)p___0, (void const   */* __restrict  */)(d___0->private_data)->sg_buffer,
           (size_t )(sectors * 2352L));
    }
  }
#line 1114
  return (0);
}
}
#line 1117 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
static int i_read_mmc3B___1(cdrom_drive *d___0 , void *p___0 , long begin , long sectors ,
                            unsigned char *sense ) 
{ 
  int ret ;
  unsigned char cmd[12] ;

  {
  {
#line 1119
  cmd[0] = (unsigned char)190;
#line 1119
  cmd[1] = (unsigned char)4;
#line 1119
  cmd[2] = (unsigned char)0;
#line 1119
  cmd[3] = (unsigned char)0;
#line 1119
  cmd[4] = (unsigned char)0;
#line 1119
  cmd[5] = (unsigned char)0;
#line 1119
  cmd[6] = (unsigned char)0;
#line 1119
  cmd[7] = (unsigned char)0;
#line 1119
  cmd[8] = (unsigned char)0;
#line 1119
  cmd[9] = (unsigned char)248;
#line 1119
  cmd[10] = (unsigned char)0;
#line 1119
  cmd[11] = (unsigned char)0;
#line 1121
  cmd[3] = (unsigned char )((begin >> 16) & 255L);
#line 1122
  cmd[4] = (unsigned char )((begin >> 8) & 255L);
#line 1123
  cmd[5] = (unsigned char )(begin & 255L);
#line 1124
  cmd[8] = (unsigned char )sectors;
#line 1125
  ret = handle_scsi_cmd___1(d___0, cmd, 12U, 0U, (unsigned int )(sectors * 2352L),
                            (unsigned char )'\177', 1, sense);
  }
#line 1125
  if (ret) {
#line 1126
    return (ret);
  }
#line 1127
  if (p___0) {
    {
#line 1127
    memcpy((void */* __restrict  */)p___0, (void const   */* __restrict  */)(d___0->private_data)->sg_buffer,
           (size_t )(sectors * 2352L));
    }
  }
#line 1128
  return (0);
}
}
#line 1152 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
static int i_read_msf___1(cdrom_drive *d___0 , void *p___0 , long begin , long sectors ,
                          unsigned char *sense ) 
{ 
  int ret ;
  unsigned char cmd[12] ;

  {
  {
#line 1154
  cmd[0] = (unsigned char)185;
#line 1154
  cmd[1] = (unsigned char)0;
#line 1154
  cmd[2] = (unsigned char)0;
#line 1154
  cmd[3] = (unsigned char)0;
#line 1154
  cmd[4] = (unsigned char)0;
#line 1154
  cmd[5] = (unsigned char)0;
#line 1154
  cmd[6] = (unsigned char)0;
#line 1154
  cmd[7] = (unsigned char)0;
#line 1154
  cmd[8] = (unsigned char)0;
#line 1154
  cmd[9] = (unsigned char)16;
#line 1154
  cmd[10] = (unsigned char)0;
#line 1154
  cmd[11] = (unsigned char)0;
#line 1156
  LBA_to_MSF(begin, cmd + 3, cmd + 4, cmd + 5);
#line 1157
  LBA_to_MSF(begin + sectors, cmd + 6, cmd + 7, cmd + 8);
#line 1159
  ret = handle_scsi_cmd___1(d___0, cmd, 12U, 0U, (unsigned int )(sectors * 2352L),
                            (unsigned char )'\177', 1, sense);
  }
#line 1159
  if (ret) {
#line 1160
    return (ret);
  }
#line 1161
  if (p___0) {
    {
#line 1161
    memcpy((void */* __restrict  */)p___0, (void const   */* __restrict  */)(d___0->private_data)->sg_buffer,
           (size_t )(sectors * 2352L));
    }
  }
#line 1162
  return (0);
}
}
#line 1165 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
static int i_read_msf2___1(cdrom_drive *d___0 , void *p___0 , long begin , long sectors ,
                           unsigned char *sense ) 
{ 
  int ret ;
  unsigned char cmd[12] ;

  {
  {
#line 1167
  cmd[0] = (unsigned char)185;
#line 1167
  cmd[1] = (unsigned char)0;
#line 1167
  cmd[2] = (unsigned char)0;
#line 1167
  cmd[3] = (unsigned char)0;
#line 1167
  cmd[4] = (unsigned char)0;
#line 1167
  cmd[5] = (unsigned char)0;
#line 1167
  cmd[6] = (unsigned char)0;
#line 1167
  cmd[7] = (unsigned char)0;
#line 1167
  cmd[8] = (unsigned char)0;
#line 1167
  cmd[9] = (unsigned char)248;
#line 1167
  cmd[10] = (unsigned char)0;
#line 1167
  cmd[11] = (unsigned char)0;
#line 1169
  LBA_to_MSF(begin, cmd + 3, cmd + 4, cmd + 5);
#line 1170
  LBA_to_MSF(begin + sectors, cmd + 6, cmd + 7, cmd + 8);
#line 1172
  ret = handle_scsi_cmd___1(d___0, cmd, 12U, 0U, (unsigned int )(sectors * 2352L),
                            (unsigned char )'\177', 1, sense);
  }
#line 1172
  if (ret) {
#line 1173
    return (ret);
  }
#line 1174
  if (p___0) {
    {
#line 1174
    memcpy((void */* __restrict  */)p___0, (void const   */* __restrict  */)(d___0->private_data)->sg_buffer,
           (size_t )(sectors * 2352L));
    }
  }
#line 1175
  return (0);
}
}
#line 1178 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
static int i_read_msf3___1(cdrom_drive *d___0 , void *p___0 , long begin , long sectors ,
                           unsigned char *sense ) 
{ 
  int ret ;
  unsigned char cmd[12] ;

  {
  {
#line 1180
  cmd[0] = (unsigned char)185;
#line 1180
  cmd[1] = (unsigned char)4;
#line 1180
  cmd[2] = (unsigned char)0;
#line 1180
  cmd[3] = (unsigned char)0;
#line 1180
  cmd[4] = (unsigned char)0;
#line 1180
  cmd[5] = (unsigned char)0;
#line 1180
  cmd[6] = (unsigned char)0;
#line 1180
  cmd[7] = (unsigned char)0;
#line 1180
  cmd[8] = (unsigned char)0;
#line 1180
  cmd[9] = (unsigned char)248;
#line 1180
  cmd[10] = (unsigned char)0;
#line 1180
  cmd[11] = (unsigned char)0;
#line 1182
  LBA_to_MSF(begin, cmd + 3, cmd + 4, cmd + 5);
#line 1183
  LBA_to_MSF(begin + sectors, cmd + 6, cmd + 7, cmd + 8);
#line 1185
  ret = handle_scsi_cmd___1(d___0, cmd, 12U, 0U, (unsigned int )(sectors * 2352L),
                            (unsigned char )'\177', 1, sense);
  }
#line 1185
  if (ret) {
#line 1186
    return (ret);
  }
#line 1187
  if (p___0) {
    {
#line 1187
    memcpy((void */* __restrict  */)p___0, (void const   */* __restrict  */)(d___0->private_data)->sg_buffer,
           (size_t )(sectors * 2352L));
    }
  }
#line 1188
  return (0);
}
}
#line 1192 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
static long scsi_read_map___1(cdrom_drive *d___0 , void *p___0 , long begin , long sectors ,
                              int (*map)(cdrom_drive * , void * , long  , long  ,
                                         unsigned char * ) ) 
{ 
  unsigned char sense[16] ;
  int retry_count ;
  int err ;
  char *buffer ;
  char b[256] ;
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int *tmp___3 ;
  char b___0[256] ;
  int *tmp___4 ;
  char b___1[256] ;
  long i ;
  char b___2[256] ;
  char *tmp___5 ;

  {
#line 1197
  buffer = (char *)p___0;
#line 1200
  if (sectors > (long )d___0->nsectors) {
#line 1200
    sectors = (long )d___0->nsectors;
  } else {
#line 1200
    sectors = sectors;
  }
#line 1201
  if (sectors < 1L) {
#line 1201
    sectors = 1L;
  } else {
#line 1201
    sectors = sectors;
  }
#line 1203
  retry_count = 0;
  {
#line 1205
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1207
    if (p___0) {
#line 1207
      tmp___5 = buffer;
    } else {
#line 1207
      tmp___5 = (char *)((void *)0);
    }
    {
#line 1207
    err = (*map)(d___0, (void *)tmp___5, begin, sectors, sense);
    }
#line 1207
    if (err) {
#line 1208
      if (d___0->report_all) {
        {
#line 1211
        sprintf((char */* __restrict  */)(b), (char const   */* __restrict  */)"scsi_read error: sector=%ld length=%ld retry=%d\n",
                begin, sectors, retry_count);
#line 1213
        cdmessage___7(d___0, (char const   *)(b));
#line 1215
        sprintf((char */* __restrict  */)(b), (char const   */* __restrict  */)"                 Sense key: %x ASC: %x ASCQ: %x\n",
                (int )sense[2] & 15, (int )sense[12], (int )sense[13]);
#line 1228
        cdmessage___7(d___0, (char const   *)(b));
#line 1229
        sprintf((char */* __restrict  */)(b), (char const   */* __restrict  */)"                 Transport error: %s\n",
                strerror_tr___1[err]);
#line 1230
        cdmessage___7(d___0, (char const   *)(b));
#line 1231
        tmp = __errno_location();
#line 1231
        tmp___0 = strerror(*tmp);
#line 1231
        sprintf((char */* __restrict  */)(b), (char const   */* __restrict  */)"                 System error: %s\n",
                tmp___0);
#line 1232
        cdmessage___7(d___0, (char const   *)(b));
#line 1234
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"scsi_read error: sector=%ld length=%ld retry=%d\n",
                begin, sectors, retry_count);
#line 1237
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"                 Sense key: %x ASC: %x ASCQ: %x\n",
                (int )sense[2] & 15, (int )sense[12], (int )sense[13]);
#line 1249
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"                 Transport error: %s\n",
                strerror_tr___1[err]);
#line 1250
        tmp___1 = __errno_location();
#line 1250
        tmp___2 = strerror(*tmp___1);
#line 1250
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"                 System error: %s\n",
                tmp___2);
        }
      }
      {
#line 1253
      tmp___3 = __errno_location();
      }
      {
#line 1254
      if (*tmp___3 == 4) {
#line 1254
        goto case_4;
      }
#line 1257
      if (*tmp___3 == 12) {
#line 1257
        goto case_12;
      }
#line 1275
      if (*tmp___3 == 123) {
#line 1275
        goto case_123;
      }
#line 1279
      goto switch_default;
      case_4: /* CIL Label */ 
      {
#line 1255
      usleep((__useconds_t )100);
      }
#line 1256
      goto while_continue;
      case_12: /* CIL Label */ 
      {
#line 1259
      usleep((__useconds_t )100);
      }
#line 1260
      if (sectors == 1L) {
        {
#line 1262
        cderror___8(d___0, "300: Kernel memory error\n");
        }
#line 1263
        return (-300L);
      }
#line 1265
      if (d___0->report_all) {
        {
#line 1267
        sprintf((char */* __restrict  */)(b___0), (char const   */* __restrict  */)"scsi_read: kernel couldn\'t alloc %ld bytes.  backing off...\n",
                sectors * 2352L);
#line 1270
        cdmessage___7(d___0, (char const   *)(b___0));
        }
      }
#line 1272
      sectors --;
#line 1273
      goto while_continue;
      case_123: /* CIL Label */ 
      {
#line 1276
      cderror___8(d___0, "404: No medium present\n");
      }
#line 1277
      return (-404L);
      switch_default: /* CIL Label */ 
#line 1280
      if (sectors == 1L) {
        {
#line 1281
        tmp___4 = __errno_location();
        }
#line 1281
        if (*tmp___4 == 5) {
#line 1282
          if (d___0->fua == -1) {
#line 1283
            return (-7L);
          }
        }
#line 1288
        if (retry_count > 7) {
          {
#line 1290
          sprintf((char */* __restrict  */)(b___1), (char const   */* __restrict  */)"010: Unable to access sector %ld\n",
                  begin);
#line 1292
          cderror___8(d___0, (char const   *)(b___1));
          }
#line 1293
          return (-10L);
        }
#line 1296
        goto switch_break;
      }
      {
#line 1302
      reset_scsi___1(d___0);
      }
      switch_break: /* CIL Label */ ;
      }
#line 1304
      if (! d___0->error_retry) {
#line 1304
        return (-7L);
      }
    } else
#line 1310
    if (buffer) {
#line 1312
      i = sectors * 2352L;
      {
#line 1312
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1312
        if (! (i > 1L)) {
#line 1312
          goto while_break___0;
        }
#line 1313
        if ((int )*(buffer + (i - 1L)) != 127) {
#line 1314
          goto while_break___0;
        } else
#line 1313
        if ((int )*(buffer + (i - 2L)) != 127) {
#line 1314
          goto while_break___0;
        }
#line 1312
        i -= 2L;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 1316
      i /= 2352L;
#line 1317
      if (i != sectors) {
#line 1318
        if (d___0->report_all) {
          {
#line 1320
          sprintf((char */* __restrict  */)(b___2), (char const   */* __restrict  */)"scsi_read underrun: pos=%ld len=%ld read=%ld retry=%d\n",
                  begin, sectors, i, retry_count);
#line 1323
          cdmessage___7(d___0, (char const   *)(b___2));
          }
        }
        {
#line 1325
        reset_scsi___1(d___0);
        }
      }
#line 1328
      if (i > 0L) {
#line 1328
        return (i);
      }
    } else {
#line 1331
      goto while_break;
    }
#line 1334
    retry_count ++;
#line 1335
    if (sectors == 1L) {
#line 1335
      if (retry_count > 8) {
        {
#line 1336
        cderror___8(d___0, "007: Unknown, unrecoverable error reading data\n");
        }
#line 1337
        return (-7L);
      }
    }
#line 1339
    if (sectors > 1L) {
#line 1339
      sectors /= 2L;
    }
    {
#line 1340
    (*(d___0->enable_cdda))(d___0, 0);
#line 1341
    (*(d___0->enable_cdda))(d___0, 1);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1344
  return (sectors);
}
}
#line 1427 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
static int count_2352_bytes___1(cdrom_drive *d___0 ) 
{ 
  long i ;

  {
#line 1429
  i = 2351L;
  {
#line 1429
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1429
    if (! (i >= 0L)) {
#line 1429
      goto while_break;
    }
#line 1430
    if ((int )*((d___0->private_data)->sg_buffer + i) != 127) {
#line 1431
      return ((int )(((i + 3L) >> 2) << 2));
    }
#line 1429
    i --;
  }
  while_break: /* CIL Label */ ;
  }
#line 1433
  return (0);
}
}
#line 1436 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
static int verify_nonzero___1(cdrom_drive *d___0 ) 
{ 
  long i ;
  long flag ;

  {
#line 1437
  flag = 0L;
#line 1438
  i = 0L;
  {
#line 1438
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1438
    if (! (i < 2352L)) {
#line 1438
      goto while_break;
    }
#line 1439
    if ((int )*((d___0->private_data)->sg_buffer + i) != 0) {
#line 1440
      flag = 1L;
#line 1441
      goto while_break;
    }
#line 1438
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1444
  return ((int )flag);
}
}
#line 1451 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
static int verify_read_command___4(cdrom_drive *d___0 ) 
{ 
  int i ;
  int j ;
  int k ;
  int audioflag ;
  int (*enablecommand)(struct cdrom_drive *d , int speed ) ;
  long (*readcommand)(struct cdrom_drive *d , void *p , long begin , long sectors ) ;
  unsigned char density ;
  int16_t *buff ;
  void *tmp ;
  long firstsector ;
  long tmp___0 ;
  long lastsector ;
  long tmp___1 ;
  long sector ;
  int tmp___2 ;
  long tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  char *es ;
  char *rs___0 ;
  int densitypossible ;
  int densityflag ;
  int rejectflag ;
  int zeroflag ;
  int lengthflag ;
  long firstsector___0 ;
  long tmp___6 ;
  long lastsector___0 ;
  long tmp___7 ;
  long sector___0 ;
  int tmp___8 ;
  long tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  char buffer[256] ;
  char buffer___0[256] ;
  char buffer___1[256] ;

  {
  {
#line 1453
  audioflag = 0;
#line 1460
  tmp = malloc((size_t )2352);
#line 1460
  buff = (int16_t *)tmp;
#line 1462
  cdmessage___7(d___0, "Verifying CDDA command set...\n");
#line 1467
  tmp___5 = (*(d___0->enable_cdda))(d___0, 1);
  }
#line 1467
  if (tmp___5 == 0) {
#line 1469
    i = 1;
    {
#line 1469
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1469
      if (! (i <= d___0->tracks)) {
#line 1469
        goto while_break;
      }
      {
#line 1470
      tmp___4 = cdda_track_audiop(d___0, i);
      }
#line 1470
      if (tmp___4 == 1) {
        {
#line 1471
        tmp___0 = cdda_track_firstsector(d___0, i);
#line 1471
        firstsector = tmp___0;
#line 1472
        tmp___1 = cdda_track_lastsector(d___0, i);
#line 1472
        lastsector = tmp___1;
#line 1473
        sector = (firstsector + lastsector) >> 1;
#line 1474
        audioflag = 1;
#line 1476
        tmp___3 = (*(d___0->read_audio))(d___0, (void *)buff, sector, 1L);
        }
#line 1476
        if (tmp___3 > 0L) {
          {
#line 1477
          tmp___2 = count_2352_bytes___1(d___0);
          }
#line 1477
          if (tmp___2 == 2352) {
            {
#line 1478
            cdmessage___7(d___0, "\tExpected command set reads OK.\n");
#line 1479
            (*(d___0->enable_cdda))(d___0, 0);
#line 1480
            free((void *)buff);
            }
#line 1481
            return (0);
          }
        }
      }
#line 1469
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1487
    (*(d___0->enable_cdda))(d___0, 0);
    }
  }
#line 1489
  if (! audioflag) {
    {
#line 1490
    cdmessage___7(d___0, "\tCould not find any audio tracks on this disk.\n");
    }
#line 1491
    return (-403);
  }
  {
#line 1495
  es = (char *)"";
#line 1495
  rs___0 = (char *)"";
#line 1496
  d___0->bigendianp = -1;
#line 1497
  density = d___0->density;
#line 1498
  readcommand = d___0->read_audio;
#line 1499
  enablecommand = d___0->enable_cdda;
#line 1503
  cdmessage___7(d___0, "\tExpected command set FAILED!\n\tPerforming full probe for CDDA command set...\n");
#line 1513
  j = 0;
  }
  {
#line 1513
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1513
    if (! (j < 15)) {
#line 1513
      goto while_break___0;
    }
#line 1514
    densitypossible = 1;
    {
#line 1517
    if (j == 0) {
#line 1517
      goto case_0;
    }
#line 1521
    if (j == 1) {
#line 1521
      goto case_1;
    }
#line 1526
    if (j == 2) {
#line 1526
      goto case_2;
    }
#line 1531
    if (j == 3) {
#line 1531
      goto case_3;
    }
#line 1536
    if (j == 4) {
#line 1536
      goto case_4;
    }
#line 1542
    if (j == 5) {
#line 1542
      goto case_5;
    }
#line 1547
    if (j == 6) {
#line 1547
      goto case_6;
    }
#line 1552
    if (j == 7) {
#line 1552
      goto case_7;
    }
#line 1558
    if (j == 8) {
#line 1558
      goto case_8;
    }
#line 1563
    if (j == 9) {
#line 1563
      goto case_9;
    }
#line 1568
    if (j == 10) {
#line 1568
      goto case_10;
    }
#line 1574
    if (j == 11) {
#line 1574
      goto case_11;
    }
#line 1578
    if (j == 12) {
#line 1578
      goto case_12;
    }
#line 1582
    if (j == 13) {
#line 1582
      goto case_13;
    }
#line 1586
    if (j == 14) {
#line 1586
      goto case_14;
    }
#line 1516
    goto switch_break;
    case_0: /* CIL Label */ 
#line 1518
    d___0->read_audio = & scsi_read_28;
#line 1519
    rs___0 = (char *)"28 0x,00";
#line 1520
    goto switch_break;
    case_1: /* CIL Label */ 
#line 1522
    d___0->read_audio = & scsi_read_A8;
#line 1523
    rs___0 = (char *)"a8 0x,00";
#line 1524
    goto switch_break;
    case_2: /* CIL Label */ 
#line 1527
    d___0->read_audio = & scsi_read_mmcB;
#line 1528
    rs___0 = (char *)"be 02,10";
#line 1529
    densitypossible = 0;
#line 1530
    goto switch_break;
    case_3: /* CIL Label */ 
#line 1532
    d___0->read_audio = & scsi_read_mmc2B;
#line 1533
    rs___0 = (char *)"be 02,f8";
#line 1534
    densitypossible = 0;
#line 1535
    goto switch_break;
    case_4: /* CIL Label */ 
#line 1537
    d___0->read_audio = & scsi_read_mmc3B;
#line 1538
    rs___0 = (char *)"be 06,f8";
#line 1539
    densitypossible = 0;
#line 1540
    goto switch_break;
    case_5: /* CIL Label */ 
#line 1543
    d___0->read_audio = & scsi_read_mmc;
#line 1544
    rs___0 = (char *)"be 00,10";
#line 1545
    densitypossible = 0;
#line 1546
    goto switch_break;
    case_6: /* CIL Label */ 
#line 1548
    d___0->read_audio = & scsi_read_mmc2;
#line 1549
    rs___0 = (char *)"be 00,f8";
#line 1550
    densitypossible = 0;
#line 1551
    goto switch_break;
    case_7: /* CIL Label */ 
#line 1553
    d___0->read_audio = & scsi_read_mmc3;
#line 1554
    rs___0 = (char *)"be 04,f8";
#line 1555
    densitypossible = 0;
#line 1556
    goto switch_break;
    case_8: /* CIL Label */ 
#line 1559
    d___0->read_audio = & scsi_read_msf;
#line 1560
    rs___0 = (char *)"b9 00,10";
#line 1561
    densitypossible = 0;
#line 1562
    goto switch_break;
    case_9: /* CIL Label */ 
#line 1564
    d___0->read_audio = & scsi_read_msf2;
#line 1565
    rs___0 = (char *)"b9 00,f8";
#line 1566
    densitypossible = 0;
#line 1567
    goto switch_break;
    case_10: /* CIL Label */ 
#line 1569
    d___0->read_audio = & scsi_read_msf3;
#line 1570
    rs___0 = (char *)"b9 04,f8";
#line 1571
    densitypossible = 0;
#line 1572
    goto switch_break;
    case_11: /* CIL Label */ 
#line 1575
    d___0->read_audio = & scsi_read_D4_10;
#line 1576
    rs___0 = (char *)"d4(10)0x";
#line 1577
    goto switch_break;
    case_12: /* CIL Label */ 
#line 1579
    d___0->read_audio = & scsi_read_D4_12;
#line 1580
    rs___0 = (char *)"d4(12)0x";
#line 1581
    goto switch_break;
    case_13: /* CIL Label */ 
#line 1583
    d___0->read_audio = & scsi_read_D5;
#line 1584
    rs___0 = (char *)"d5 0x,00";
#line 1585
    goto switch_break;
    case_14: /* CIL Label */ 
#line 1587
    d___0->read_audio = & scsi_read_D8;
#line 1588
    rs___0 = (char *)"d8 0x,00";
#line 1589
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 1592
    i = 0;
    {
#line 1592
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1592
      if (! (i < 5)) {
#line 1592
        goto while_break___1;
      }
      {
#line 1594
      if (i == 0) {
#line 1594
        goto case_0___0;
      }
#line 1600
      if (i == 1) {
#line 1600
        goto case_1___0;
      }
#line 1605
      if (i == 2) {
#line 1605
        goto case_2___0;
      }
#line 1610
      if (i == 3) {
#line 1610
        goto case_3___0;
      }
#line 1615
      if (i == 4) {
#line 1615
        goto case_4___0;
      }
#line 1593
      goto switch_break___0;
      case_0___0: /* CIL Label */ 
#line 1595
      d___0->density = (unsigned char)0;
#line 1596
      d___0->enable_cdda = & Dummy___4;
#line 1597
      es = (char *)"none    ";
#line 1598
      if (! densitypossible) {
#line 1598
        i = 5;
      }
#line 1599
      goto switch_break___0;
      case_1___0: /* CIL Label */ 
#line 1601
      d___0->density = (unsigned char)0;
#line 1602
      d___0->enable_cdda = & scsi_enable_cdda;
#line 1603
      es = (char *)"yes/0x00";
#line 1604
      goto switch_break___0;
      case_2___0: /* CIL Label */ 
#line 1606
      d___0->density = (unsigned char)4;
#line 1607
      d___0->enable_cdda = & scsi_enable_cdda;
#line 1608
      es = (char *)"yes/0x04";
#line 1609
      goto switch_break___0;
      case_3___0: /* CIL Label */ 
#line 1611
      d___0->density = (unsigned char)130;
#line 1612
      d___0->enable_cdda = & scsi_enable_cdda;
#line 1613
      es = (char *)"yes/0x82";
#line 1614
      goto switch_break___0;
      case_4___0: /* CIL Label */ 
#line 1616
      d___0->density = (unsigned char)129;
#line 1617
      d___0->enable_cdda = & scsi_enable_cdda;
#line 1618
      es = (char *)"yes/0x81";
#line 1619
      goto switch_break___0;
      switch_break___0: /* CIL Label */ ;
      }
      {
#line 1622
      cdmessage___7(d___0, "\ttest -> density: [");
#line 1623
      cdmessage___7(d___0, (char const   *)es);
#line 1624
      cdmessage___7(d___0, "]  command: [");
#line 1625
      cdmessage___7(d___0, (char const   *)rs___0);
#line 1626
      cdmessage___7(d___0, "]\n");
#line 1629
      densityflag = 0;
#line 1630
      rejectflag = 0;
#line 1631
      zeroflag = 0;
#line 1632
      lengthflag = 0;
#line 1634
      tmp___11 = (*(d___0->enable_cdda))(d___0, 1);
      }
#line 1634
      if (tmp___11 == 0) {
#line 1635
        k = 1;
        {
#line 1635
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 1635
          if (! (k <= d___0->tracks)) {
#line 1635
            goto while_break___2;
          }
          {
#line 1636
          tmp___10 = cdda_track_audiop(d___0, k);
          }
#line 1636
          if (tmp___10 == 1) {
            {
#line 1637
            tmp___6 = cdda_track_firstsector(d___0, k);
#line 1637
            firstsector___0 = tmp___6;
#line 1638
            tmp___7 = cdda_track_lastsector(d___0, k);
#line 1638
            lastsector___0 = tmp___7;
#line 1639
            sector___0 = (firstsector___0 + lastsector___0) >> 1;
#line 1641
            tmp___9 = (*(d___0->read_audio))(d___0, (void *)buff, sector___0, 1L);
            }
#line 1641
            if (tmp___9 > 0L) {
              {
#line 1642
              lengthflag = count_2352_bytes___1(d___0);
              }
#line 1642
              if (lengthflag == 2352) {
                {
#line 1643
                tmp___8 = verify_nonzero___1(d___0);
                }
#line 1643
                if (tmp___8) {
                  {
#line 1644
                  cdmessage___7(d___0, "\t\tCommand set FOUND!\n");
#line 1646
                  free((void *)buff);
#line 1647
                  (*(d___0->enable_cdda))(d___0, 0);
                  }
#line 1648
                  return (0);
                } else {
#line 1650
                  zeroflag ++;
                }
              }
            } else {
#line 1654
              rejectflag ++;
#line 1655
              goto while_break___2;
            }
          }
#line 1635
          k ++;
        }
        while_break___2: /* CIL Label */ ;
        }
        {
#line 1659
        (*(d___0->enable_cdda))(d___0, 0);
        }
      } else {
#line 1661
        densityflag ++;
      }
#line 1664
      if (densityflag) {
        {
#line 1665
        cdmessage___7(d___0, "\t\tDrive rejected density set\n");
        }
      }
#line 1666
      if (rejectflag) {
        {
#line 1668
        sprintf((char */* __restrict  */)(buffer), (char const   */* __restrict  */)"\t\tDrive rejected read command packet(s)\n");
#line 1669
        cdmessage___7(d___0, (char const   *)(buffer));
        }
      }
#line 1671
      if (lengthflag > 0) {
#line 1671
        if (lengthflag < 2352) {
          {
#line 1673
          sprintf((char */* __restrict  */)(buffer___0), (char const   */* __restrict  */)"\t\tDrive returned at least one packet, but with\n\t\tincorrect size (%d)\n",
                  lengthflag);
#line 1675
          cdmessage___7(d___0, (char const   *)(buffer___0));
          }
        }
      }
#line 1677
      if (zeroflag) {
        {
#line 1679
        sprintf((char */* __restrict  */)(buffer___1), (char const   */* __restrict  */)"\t\tDrive returned %d packet(s), but contents\n\t\twere entirely zero\n",
                zeroflag);
#line 1681
        cdmessage___7(d___0, (char const   *)(buffer___1));
        }
      }
#line 1592
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1513
    j ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1688
  d___0->density = density;
#line 1689
  d___0->read_audio = readcommand;
#line 1690
  d___0->enable_cdda = enablecommand;
#line 1692
  cdmessage___7(d___0, "\tUnable to find any suitable command set from probe;\n\tdrive probably not CDDA capable.\n");
#line 1695
  cderror___8(d___0, "006: Could not read any data from drive\n");
#line 1698
  free((void *)buff);
  }
#line 1699
  return (-6);
}
}
#line 1702 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
static void check_cache___1(cdrom_drive *d___0 ) 
{ 
  long i ;
  long firstsector ;
  long tmp ;
  long lastsector ;
  long tmp___0 ;
  long sector ;
  long tmp___1 ;
  int tmp___2 ;

  {
#line 1705
  if (! ((unsigned long )d___0->read_audio == (unsigned long )(& scsi_read_mmc))) {
#line 1705
    if (! ((unsigned long )d___0->read_audio == (unsigned long )(& scsi_read_mmc2))) {
#line 1705
      if (! ((unsigned long )d___0->read_audio == (unsigned long )(& scsi_read_mmc3))) {
#line 1705
        if (! ((unsigned long )d___0->read_audio == (unsigned long )(& scsi_read_mmcB))) {
#line 1705
          if (! ((unsigned long )d___0->read_audio == (unsigned long )(& scsi_read_mmc2B))) {
#line 1705
            if (! ((unsigned long )d___0->read_audio == (unsigned long )(& scsi_read_mmc3B))) {
              {
#line 1712
              cdmessage___7(d___0, "This command set may use a Force Unit Access bit.");
#line 1713
              cdmessage___7(d___0, "\nChecking drive for FUA bit support...\n");
#line 1715
              (*(d___0->enable_cdda))(d___0, 1);
#line 1716
              d___0->fua = 1;
#line 1718
              i = 1L;
              }
              {
#line 1718
              while (1) {
                while_continue: /* CIL Label */ ;
#line 1718
                if (! (i <= (long )d___0->tracks)) {
#line 1718
                  goto while_break;
                }
                {
#line 1719
                tmp___2 = cdda_track_audiop(d___0, (int )i);
                }
#line 1719
                if (tmp___2 == 1) {
                  {
#line 1720
                  tmp = cdda_track_firstsector(d___0, (int )i);
#line 1720
                  firstsector = tmp;
#line 1721
                  tmp___0 = cdda_track_lastsector(d___0, (int )i);
#line 1721
                  lastsector = tmp___0;
#line 1722
                  sector = (firstsector + lastsector) >> 1;
#line 1724
                  tmp___1 = (*(d___0->read_audio))(d___0, (void *)0, sector, 1L);
                  }
#line 1724
                  if (tmp___1 > 0L) {
                    {
#line 1725
                    cdmessage___7(d___0, "\tDrive accepted FUA bit.\n");
#line 1726
                    (*(d___0->enable_cdda))(d___0, 0);
                    }
#line 1727
                    return;
                  }
                }
#line 1718
                i ++;
              }
              while_break: /* CIL Label */ ;
              }
              {
#line 1732
              d___0->fua = 0;
#line 1733
              cdmessage___7(d___0, "\tDrive rejected FUA bit.\n");
              }
#line 1738
              return;
            }
          }
        }
      }
    }
  }
#line 1740
  return;
}
}
#line 1743 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
static int check_atapi___1(cdrom_drive *d___0 ) 
{ 
  int atapiret ;
  int fd ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 1744
  atapiret = -1;
#line 1745
  fd = d___0->cdda_fd;
#line 1747
  cdmessage___7(d___0, "\nChecking for SCSI emulation...\n");
#line 1749
  tmp___0 = ioctl(fd, 8707UL, & atapiret);
  }
#line 1749
  if (tmp___0) {
    {
#line 1750
    cderror___8(d___0, "\tSG_EMULATED_HOST ioctl() failed!\n");
    }
#line 1751
    return (-1);
  } else {
#line 1753
    if (atapiret == 1) {
#line 1754
      if (d___0->interface == 3) {
        {
#line 1755
        cdmessage___7(d___0, "\tDrive is ATAPI (using SG_IO host adaptor emulation)\n");
        }
      } else
#line 1756
      if (d___0->interface == 4) {
        {
#line 1757
        cdmessage___7(d___0, "\tDrive is ATAPI (using SG_IO host adaptor emulation with workarounds)\n");
        }
      } else {
        {
#line 1759
        cdmessage___7(d___0, "\tDrive is ATAPI (using SCSI host adaptor emulation)\n");
#line 1761
        tmp = ioctl(fd, 8708UL, 0);
        }
#line 1761
        if (tmp) {
          {
#line 1762
          cderror___8(d___0, "\tCouldn\'t disable kernel command translation layer\n");
          }
        }
      }
#line 1764
      d___0->is_atapi = 1;
    } else {
      {
#line 1766
      cdmessage___7(d___0, "\tDrive is SCSI\n");
#line 1767
      d___0->is_atapi = 0;
      }
    }
#line 1770
    return (d___0->is_atapi);
  }
}
}
#line 1815 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
static int check_mmc___1(cdrom_drive *d___0 ) 
{ 
  unsigned char *b ;
  int tmp ;

  {
  {
#line 1817
  cdmessage___7(d___0, "\nChecking for MMC style command set...\n");
#line 1819
  d___0->is_mmc = 0;
#line 1820
  tmp = mode_sense___1(d___0, 22, 42);
  }
#line 1820
  if (tmp == 0) {
#line 1822
    b = (d___0->private_data)->sg_buffer;
#line 1823
    b += (int )*(b + 3) + 4;
#line 1825
    if (((int )*(b + 0) & 63) == 42) {
#line 1827
      d___0->is_mmc = 1;
#line 1829
      if ((int )*(b + 1) >= 4) {
#line 1830
        if ((int )*(b + 5) & 1) {
          {
#line 1831
          cdmessage___7(d___0, "\tDrive is MMC style\n");
          }
#line 1832
          return (1);
        } else {
          {
#line 1834
          cdmessage___7(d___0, "\tDrive is MMC, but reports CDDA incapable.\n");
#line 1835
          cdmessage___7(d___0, "\tIt will likely not be able to read audio data.\n");
          }
#line 1836
          return (1);
        }
      }
    }
  }
  {
#line 1842
  cdmessage___7(d___0, "\tDrive does not have MMC CDDA support\n");
  }
#line 1843
  return (0);
}
}
#line 1846 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
static void check_exceptions___4(cdrom_drive *d___0 , exception *list ) 
{ 
  int i ;
  size_t tmp ;
  int tmp___0 ;

  {
#line 1848
  i = 0;
  {
#line 1849
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1849
    if (! (list + i)->model) {
#line 1849
      goto while_break;
    }
    {
#line 1850
    tmp = strlen((char const   *)(list + i)->model);
#line 1850
    tmp___0 = strncmp((char const   *)(list + i)->model, (char const   *)d___0->drive_model,
                      tmp);
    }
#line 1850
    if (! tmp___0) {
#line 1851
      if ((list + i)->density) {
#line 1851
        d___0->density = (list + i)->density;
      }
#line 1852
      if ((list + i)->enable) {
#line 1852
        d___0->enable_cdda = (list + i)->enable;
      }
#line 1853
      if ((list + i)->read) {
#line 1853
        d___0->read_audio = (list + i)->read;
      }
#line 1854
      if ((list + i)->bigendianp != -1) {
#line 1854
        d___0->bigendianp = (list + i)->bigendianp;
      }
#line 1855
      return;
    }
#line 1857
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1859
  return;
}
}
#line 18 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/smallft.c"
static void drfti1___1(int n , float *wa , int *ifac ) ;
#line 18 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/smallft.c"
static int ntryh___1[4]  = {      4,      2,      3,      5};
#line 19 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/smallft.c"
static float tpi___1  =    (float )6.28318530717958647692528676655900577;
#line 17 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/smallft.c"
static void drfti1___1(int n , float *wa , int *ifac ) 
{ 
  float arg ;
  float argh ;
  float argld ;
  float fi ;
  int ntry ;
  int i ;
  int j ;
  int k1 ;
  int l1 ;
  int l2 ;
  int ib ;
  int ld ;
  int ii ;
  int ip ;
  int is ;
  int nq ;
  int nr ;
  int ido ;
  int ipm ;
  int nfm1 ;
  int nl ;
  int nf ;
  int tmp ;
  double tmp___0 ;
  int tmp___1 ;
  double tmp___2 ;

  {
#line 21
  ntry = 0;
#line 21
  j = -1;
#line 25
  nl = n;
#line 26
  nf = 0;
  L101: 
#line 29
  j ++;
#line 30
  if (j < 4) {
#line 31
    ntry = ntryh___1[j];
  } else {
#line 33
    ntry += 2;
  }
  L104: 
#line 36
  nq = nl / ntry;
#line 37
  nr = nl - ntry * nq;
#line 38
  if (nr != 0) {
#line 38
    goto L101;
  }
#line 40
  nf ++;
#line 41
  *(ifac + (nf + 1)) = ntry;
#line 42
  nl = nq;
#line 43
  if (ntry != 2) {
#line 43
    goto L107;
  }
#line 44
  if (nf == 1) {
#line 44
    goto L107;
  }
#line 46
  i = 1;
  {
#line 46
  while (1) {
    while_continue: /* CIL Label */ ;
#line 46
    if (! (i < nf)) {
#line 46
      goto while_break;
    }
#line 47
    ib = (nf - i) + 1;
#line 48
    *(ifac + (ib + 1)) = *(ifac + ib);
#line 46
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 50
  *(ifac + 2) = 2;
  L107: 
#line 53
  if (nl != 1) {
#line 53
    goto L104;
  }
#line 54
  *(ifac + 0) = n;
#line 55
  *(ifac + 1) = nf;
#line 56
  argh = tpi___1 / (float )n;
#line 57
  is = 0;
#line 58
  nfm1 = nf - 1;
#line 59
  l1 = 1;
#line 61
  if (nfm1 == 0) {
#line 61
    return;
  }
#line 63
  k1 = 0;
  {
#line 63
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 63
    if (! (k1 < nfm1)) {
#line 63
      goto while_break___0;
    }
#line 64
    ip = *(ifac + (k1 + 2));
#line 65
    ld = 0;
#line 66
    l2 = l1 * ip;
#line 67
    ido = n / l2;
#line 68
    ipm = ip - 1;
#line 70
    j = 0;
    {
#line 70
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 70
      if (! (j < ipm)) {
#line 70
        goto while_break___1;
      }
#line 71
      ld += l1;
#line 72
      i = is;
#line 73
      argld = (float )ld * argh;
#line 74
      fi = (float )0.;
#line 75
      ii = 2;
      {
#line 75
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 75
        if (! (ii < ido)) {
#line 75
          goto while_break___2;
        }
        {
#line 76
        fi = (float )((double )fi + 1.);
#line 77
        arg = fi * argld;
#line 78
        tmp = i;
#line 78
        i ++;
#line 78
        tmp___0 = cos((double )arg);
#line 78
        *(wa + tmp) = (float )tmp___0;
#line 79
        tmp___1 = i;
#line 79
        i ++;
#line 79
        tmp___2 = sin((double )arg);
#line 79
        *(wa + tmp___1) = (float )tmp___2;
#line 75
        ii += 2;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
#line 81
      is += ido;
#line 70
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 83
    l1 = l2;
#line 63
    k1 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 85
  return;
}
}
#line 87 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/smallft.c"
static void fdrffti___1(int n , float *wsave , int *ifac ) 
{ 


  {
#line 89
  if (n == 1) {
#line 89
    return;
  }
  {
#line 90
  drfti1___1(n, wsave + n, ifac);
  }
#line 91
  return;
}
}
#line 93 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/smallft.c"
static void dradf2___1(int ido , int l1 , float *cc , float *ch , float *wa1 ) 
{ 
  int i ;
  int k ;
  float ti2 ;
  float tr2 ;
  int t0 ;
  int t1 ;
  int t2 ;
  int t3 ;
  int t4 ;
  int t5 ;
  int t6 ;

  {
#line 98
  t1 = 0;
#line 99
  t2 = l1 * ido;
#line 99
  t0 = t2;
#line 100
  t3 = ido << 1;
#line 101
  k = 0;
  {
#line 101
  while (1) {
    while_continue: /* CIL Label */ ;
#line 101
    if (! (k < l1)) {
#line 101
      goto while_break;
    }
#line 102
    *(ch + (t1 << 1)) = *(cc + t1) + *(cc + t2);
#line 103
    *(ch + (((t1 << 1) + t3) - 1)) = *(cc + t1) - *(cc + t2);
#line 104
    t1 += ido;
#line 105
    t2 += ido;
#line 101
    k ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 108
  if (ido < 2) {
#line 108
    return;
  }
#line 109
  if (ido == 2) {
#line 109
    goto L105;
  }
#line 111
  t1 = 0;
#line 112
  t2 = t0;
#line 113
  k = 0;
  {
#line 113
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 113
    if (! (k < l1)) {
#line 113
      goto while_break___0;
    }
#line 114
    t3 = t2;
#line 115
    t4 = (t1 << 1) + (ido << 1);
#line 116
    t5 = t1;
#line 117
    t6 = t1 + t1;
#line 118
    i = 2;
    {
#line 118
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 118
      if (! (i < ido)) {
#line 118
        goto while_break___1;
      }
#line 119
      t3 += 2;
#line 120
      t4 -= 2;
#line 121
      t5 += 2;
#line 122
      t6 += 2;
#line 123
      tr2 = *(wa1 + (i - 2)) * *(cc + (t3 - 1)) + *(wa1 + (i - 1)) * *(cc + t3);
#line 124
      ti2 = *(wa1 + (i - 2)) * *(cc + t3) - *(wa1 + (i - 1)) * *(cc + (t3 - 1));
#line 125
      *(ch + t6) = *(cc + t5) + ti2;
#line 126
      *(ch + t4) = ti2 - *(cc + t5);
#line 127
      *(ch + (t6 - 1)) = *(cc + (t5 - 1)) + tr2;
#line 128
      *(ch + (t4 - 1)) = *(cc + (t5 - 1)) - tr2;
#line 118
      i += 2;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 130
    t1 += ido;
#line 131
    t2 += ido;
#line 113
    k ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 134
  if (ido % 2 == 1) {
#line 134
    return;
  }
  L105: 
#line 137
  t1 = ido;
#line 137
  t2 = t1 - 1;
#line 137
  t3 = t2;
#line 138
  t2 += t0;
#line 139
  k = 0;
  {
#line 139
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 139
    if (! (k < l1)) {
#line 139
      goto while_break___2;
    }
#line 140
    *(ch + t1) = - *(cc + t2);
#line 141
    *(ch + (t1 - 1)) = *(cc + t3);
#line 142
    t1 += ido << 1;
#line 143
    t2 += ido;
#line 144
    t3 += ido;
#line 139
    k ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 146
  return;
}
}
#line 150
static void dradf4___1(int ido , int l1 , float *cc , float *ch , float *wa1 , float *wa2 ,
                       float *wa3 ) ;
#line 150 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/smallft.c"
static float hsqt2___1  =    (float ).70710678118654752440084436210485;
#line 148 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/smallft.c"
static void dradf4___1(int ido , int l1 , float *cc , float *ch , float *wa1 , float *wa2 ,
                       float *wa3 ) 
{ 
  int i ;
  int k ;
  int t0 ;
  int t1 ;
  int t2 ;
  int t3 ;
  int t4 ;
  int t5 ;
  int t6 ;
  float ci2 ;
  float ci3 ;
  float ci4 ;
  float cr2 ;
  float cr3 ;
  float cr4 ;
  float ti1 ;
  float ti2 ;
  float ti3 ;
  float ti4 ;
  float tr1 ;
  float tr2 ;
  float tr3 ;
  float tr4 ;

  {
#line 153
  t0 = l1 * ido;
#line 155
  t1 = t0;
#line 156
  t4 = t1 << 1;
#line 157
  t2 = t1 + (t1 << 1);
#line 158
  t3 = 0;
#line 160
  k = 0;
  {
#line 160
  while (1) {
    while_continue: /* CIL Label */ ;
#line 160
    if (! (k < l1)) {
#line 160
      goto while_break;
    }
#line 161
    tr1 = *(cc + t1) + *(cc + t2);
#line 162
    tr2 = *(cc + t3) + *(cc + t4);
#line 164
    t5 = t3 << 2;
#line 164
    *(ch + t5) = tr1 + tr2;
#line 165
    *(ch + (((ido << 2) + t5) - 1)) = tr2 - tr1;
#line 166
    t5 += ido << 1;
#line 166
    *(ch + (t5 - 1)) = *(cc + t3) - *(cc + t4);
#line 167
    *(ch + t5) = *(cc + t2) - *(cc + t1);
#line 169
    t1 += ido;
#line 170
    t2 += ido;
#line 171
    t3 += ido;
#line 172
    t4 += ido;
#line 160
    k ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 175
  if (ido < 2) {
#line 175
    return;
  }
#line 176
  if (ido == 2) {
#line 176
    goto L105;
  }
#line 179
  t1 = 0;
#line 180
  k = 0;
  {
#line 180
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 180
    if (! (k < l1)) {
#line 180
      goto while_break___0;
    }
#line 181
    t2 = t1;
#line 182
    t4 = t1 << 2;
#line 183
    t6 = ido << 1;
#line 183
    t5 = t6 + t4;
#line 184
    i = 2;
    {
#line 184
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 184
      if (! (i < ido)) {
#line 184
        goto while_break___1;
      }
#line 185
      t2 += 2;
#line 185
      t3 = t2;
#line 186
      t4 += 2;
#line 187
      t5 -= 2;
#line 189
      t3 += t0;
#line 190
      cr2 = *(wa1 + (i - 2)) * *(cc + (t3 - 1)) + *(wa1 + (i - 1)) * *(cc + t3);
#line 191
      ci2 = *(wa1 + (i - 2)) * *(cc + t3) - *(wa1 + (i - 1)) * *(cc + (t3 - 1));
#line 192
      t3 += t0;
#line 193
      cr3 = *(wa2 + (i - 2)) * *(cc + (t3 - 1)) + *(wa2 + (i - 1)) * *(cc + t3);
#line 194
      ci3 = *(wa2 + (i - 2)) * *(cc + t3) - *(wa2 + (i - 1)) * *(cc + (t3 - 1));
#line 195
      t3 += t0;
#line 196
      cr4 = *(wa3 + (i - 2)) * *(cc + (t3 - 1)) + *(wa3 + (i - 1)) * *(cc + t3);
#line 197
      ci4 = *(wa3 + (i - 2)) * *(cc + t3) - *(wa3 + (i - 1)) * *(cc + (t3 - 1));
#line 199
      tr1 = cr2 + cr4;
#line 200
      tr4 = cr4 - cr2;
#line 201
      ti1 = ci2 + ci4;
#line 202
      ti4 = ci2 - ci4;
#line 204
      ti2 = *(cc + t2) + ci3;
#line 205
      ti3 = *(cc + t2) - ci3;
#line 206
      tr2 = *(cc + (t2 - 1)) + cr3;
#line 207
      tr3 = *(cc + (t2 - 1)) - cr3;
#line 209
      *(ch + (t4 - 1)) = tr1 + tr2;
#line 210
      *(ch + t4) = ti1 + ti2;
#line 212
      *(ch + (t5 - 1)) = tr3 - ti4;
#line 213
      *(ch + t5) = tr4 - ti3;
#line 215
      *(ch + ((t4 + t6) - 1)) = ti4 + tr3;
#line 216
      *(ch + (t4 + t6)) = tr4 + ti3;
#line 218
      *(ch + ((t5 + t6) - 1)) = tr2 - tr1;
#line 219
      *(ch + (t5 + t6)) = ti1 - ti2;
#line 184
      i += 2;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 221
    t1 += ido;
#line 180
    k ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 223
  if (ido & 1) {
#line 223
    return;
  }
  L105: 
#line 227
  t1 = (t0 + ido) - 1;
#line 227
  t2 = t1 + (t0 << 1);
#line 228
  t3 = ido << 2;
#line 229
  t4 = ido;
#line 230
  t5 = ido << 1;
#line 231
  t6 = ido;
#line 233
  k = 0;
  {
#line 233
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 233
    if (! (k < l1)) {
#line 233
      goto while_break___2;
    }
#line 234
    ti1 = - hsqt2___1 * (*(cc + t1) + *(cc + t2));
#line 235
    tr1 = hsqt2___1 * (*(cc + t1) - *(cc + t2));
#line 237
    *(ch + (t4 - 1)) = tr1 + *(cc + (t6 - 1));
#line 238
    *(ch + ((t4 + t5) - 1)) = *(cc + (t6 - 1)) - tr1;
#line 240
    *(ch + t4) = ti1 - *(cc + (t1 + t0));
#line 241
    *(ch + (t4 + t5)) = ti1 + *(cc + (t1 + t0));
#line 243
    t1 += ido;
#line 244
    t2 += ido;
#line 245
    t4 += t3;
#line 246
    t6 += ido;
#line 233
    k ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 248
  return;
}
}
#line 250 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/smallft.c"
static void drftf1___1(int n , float *c , float *ch , float *wa , int *ifac ) 
{ 
  int i ;
  int k1 ;
  int l1 ;
  int l2 ;
  int na ;
  int kh ;
  int nf ;
  int ip ;
  int iw ;
  int ido ;
  int idl1 ;
  int ix2 ;
  int ix3 ;

  {
#line 255
  nf = *(ifac + 1);
#line 256
  na = 1;
#line 257
  l2 = n;
#line 258
  iw = n;
#line 260
  k1 = 0;
  {
#line 260
  while (1) {
    while_continue: /* CIL Label */ ;
#line 260
    if (! (k1 < nf)) {
#line 260
      goto while_break;
    }
#line 261
    kh = nf - k1;
#line 262
    ip = *(ifac + (kh + 1));
#line 263
    l1 = l2 / ip;
#line 264
    ido = n / l2;
#line 265
    idl1 = ido * l1;
#line 266
    iw -= (ip - 1) * ido;
#line 267
    na = 1 - na;
#line 269
    if (ip != 4) {
#line 269
      goto L102;
    }
#line 271
    ix2 = iw + ido;
#line 272
    ix3 = ix2 + ido;
#line 273
    if (na != 0) {
      {
#line 274
      dradf4___1(ido, l1, ch, c, (wa + iw) - 1, (wa + ix2) - 1, (wa + ix3) - 1);
      }
    } else {
      {
#line 276
      dradf4___1(ido, l1, c, ch, (wa + iw) - 1, (wa + ix2) - 1, (wa + ix3) - 1);
      }
    }
#line 277
    goto L110;
    L102: 
#line 280
    if (ip != 2) {
#line 280
      goto L104;
    }
#line 281
    if (na != 0) {
#line 281
      goto L103;
    }
    {
#line 283
    dradf2___1(ido, l1, c, ch, (wa + iw) - 1);
    }
#line 284
    goto L110;
    L103: 
    {
#line 287
    dradf2___1(ido, l1, ch, c, (wa + iw) - 1);
    }
#line 288
    goto L110;
    L104: 
#line 291
    return;
    L110: 
#line 294
    l2 = l1;
#line 260
    k1 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 297
  if (na == 1) {
#line 297
    return;
  }
#line 299
  i = 0;
  {
#line 299
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 299
    if (! (i < n)) {
#line 299
      goto while_break___0;
    }
#line 299
    *(c + i) = *(ch + i);
#line 299
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 300
  return;
}
}
#line 302 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/smallft.c"
static void fdrfftf___1(int n , float *r , float *wsave , int *ifac ) 
{ 


  {
#line 303
  if (n == 1) {
#line 303
    return;
  }
  {
#line 304
  drftf1___1(n, r, wsave, wsave + n, ifac);
  }
#line 305
  return;
}
}
#line 307 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/smallft.c"
static void dradb2___1(int ido , int l1 , float *cc , float *ch , float *wa1 ) 
{ 
  int i ;
  int k ;
  int t0 ;
  int t1 ;
  int t2 ;
  int t3 ;
  int t4 ;
  int t5 ;
  int t6 ;
  float ti2 ;
  float tr2 ;

  {
#line 311
  t0 = l1 * ido;
#line 313
  t1 = 0;
#line 314
  t2 = 0;
#line 315
  t3 = (ido << 1) - 1;
#line 316
  k = 0;
  {
#line 316
  while (1) {
    while_continue: /* CIL Label */ ;
#line 316
    if (! (k < l1)) {
#line 316
      goto while_break;
    }
#line 317
    *(ch + t1) = *(cc + t2) + *(cc + (t3 + t2));
#line 318
    *(ch + (t1 + t0)) = *(cc + t2) - *(cc + (t3 + t2));
#line 319
    t1 += ido;
#line 319
    t2 = t1 << 1;
#line 316
    k ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 322
  if (ido < 2) {
#line 322
    return;
  }
#line 323
  if (ido == 2) {
#line 323
    goto L105;
  }
#line 325
  t1 = 0;
#line 326
  t2 = 0;
#line 327
  k = 0;
  {
#line 327
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 327
    if (! (k < l1)) {
#line 327
      goto while_break___0;
    }
#line 328
    t3 = t1;
#line 329
    t4 = t2;
#line 329
    t5 = t4 + (ido << 1);
#line 330
    t6 = t0 + t1;
#line 331
    i = 2;
    {
#line 331
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 331
      if (! (i < ido)) {
#line 331
        goto while_break___1;
      }
#line 332
      t3 += 2;
#line 333
      t4 += 2;
#line 334
      t5 -= 2;
#line 335
      t6 += 2;
#line 336
      *(ch + (t3 - 1)) = *(cc + (t4 - 1)) + *(cc + (t5 - 1));
#line 337
      tr2 = *(cc + (t4 - 1)) - *(cc + (t5 - 1));
#line 338
      *(ch + t3) = *(cc + t4) - *(cc + t5);
#line 339
      ti2 = *(cc + t4) + *(cc + t5);
#line 340
      *(ch + (t6 - 1)) = *(wa1 + (i - 2)) * tr2 - *(wa1 + (i - 1)) * ti2;
#line 341
      *(ch + t6) = *(wa1 + (i - 2)) * ti2 + *(wa1 + (i - 1)) * tr2;
#line 331
      i += 2;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 343
    t1 += ido;
#line 343
    t2 = t1 << 1;
#line 327
    k ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 346
  if (ido % 2 == 1) {
#line 346
    return;
  }
  L105: 
#line 349
  t1 = ido - 1;
#line 350
  t2 = ido - 1;
#line 351
  k = 0;
  {
#line 351
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 351
    if (! (k < l1)) {
#line 351
      goto while_break___2;
    }
#line 352
    *(ch + t1) = *(cc + t2) + *(cc + t2);
#line 353
    *(ch + (t1 + t0)) = - (*(cc + (t2 + 1)) + *(cc + (t2 + 1)));
#line 354
    t1 += ido;
#line 355
    t2 += ido << 1;
#line 351
    k ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 357
  return;
}
}
#line 361
static void dradb4___1(int ido , int l1 , float *cc , float *ch , float *wa1 , float *wa2 ,
                       float *wa3 ) ;
#line 361 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/smallft.c"
static float sqrt2___1  =    (float )1.4142135623730950488016887242097;
#line 359 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/smallft.c"
static void dradb4___1(int ido , int l1 , float *cc , float *ch , float *wa1 , float *wa2 ,
                       float *wa3 ) 
{ 
  int i ;
  int k ;
  int t0 ;
  int t1 ;
  int t2 ;
  int t3 ;
  int t4 ;
  int t5 ;
  int t6 ;
  int t7 ;
  int t8 ;
  float ci2 ;
  float ci3 ;
  float ci4 ;
  float cr2 ;
  float cr3 ;
  float cr4 ;
  float ti1 ;
  float ti2 ;
  float ti3 ;
  float ti4 ;
  float tr1 ;
  float tr2 ;
  float tr3 ;
  float tr4 ;

  {
#line 364
  t0 = l1 * ido;
#line 366
  t1 = 0;
#line 367
  t2 = ido << 2;
#line 368
  t3 = 0;
#line 369
  t6 = ido << 1;
#line 370
  k = 0;
  {
#line 370
  while (1) {
    while_continue: /* CIL Label */ ;
#line 370
    if (! (k < l1)) {
#line 370
      goto while_break;
    }
#line 371
    t4 = t3 + t6;
#line 372
    t5 = t1;
#line 373
    tr3 = *(cc + (t4 - 1)) + *(cc + (t4 - 1));
#line 374
    tr4 = *(cc + t4) + *(cc + t4);
#line 375
    t4 += t6;
#line 375
    tr1 = *(cc + t3) - *(cc + (t4 - 1));
#line 376
    tr2 = *(cc + t3) + *(cc + (t4 - 1));
#line 377
    *(ch + t5) = tr2 + tr3;
#line 378
    t5 += t0;
#line 378
    *(ch + t5) = tr1 - tr4;
#line 379
    t5 += t0;
#line 379
    *(ch + t5) = tr2 - tr3;
#line 380
    t5 += t0;
#line 380
    *(ch + t5) = tr1 + tr4;
#line 381
    t1 += ido;
#line 382
    t3 += t2;
#line 370
    k ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 385
  if (ido < 2) {
#line 385
    return;
  }
#line 386
  if (ido == 2) {
#line 386
    goto L105;
  }
#line 388
  t1 = 0;
#line 389
  k = 0;
  {
#line 389
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 389
    if (! (k < l1)) {
#line 389
      goto while_break___0;
    }
#line 390
    t2 = t1 << 2;
#line 390
    t3 = t2 + t6;
#line 390
    t4 = t3;
#line 390
    t5 = t4 + t6;
#line 391
    t7 = t1;
#line 392
    i = 2;
    {
#line 392
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 392
      if (! (i < ido)) {
#line 392
        goto while_break___1;
      }
#line 393
      t2 += 2;
#line 394
      t3 += 2;
#line 395
      t4 -= 2;
#line 396
      t5 -= 2;
#line 397
      t7 += 2;
#line 398
      ti1 = *(cc + t2) + *(cc + t5);
#line 399
      ti2 = *(cc + t2) - *(cc + t5);
#line 400
      ti3 = *(cc + t3) - *(cc + t4);
#line 401
      tr4 = *(cc + t3) + *(cc + t4);
#line 402
      tr1 = *(cc + (t2 - 1)) - *(cc + (t5 - 1));
#line 403
      tr2 = *(cc + (t2 - 1)) + *(cc + (t5 - 1));
#line 404
      ti4 = *(cc + (t3 - 1)) - *(cc + (t4 - 1));
#line 405
      tr3 = *(cc + (t3 - 1)) + *(cc + (t4 - 1));
#line 406
      *(ch + (t7 - 1)) = tr2 + tr3;
#line 407
      cr3 = tr2 - tr3;
#line 408
      *(ch + t7) = ti2 + ti3;
#line 409
      ci3 = ti2 - ti3;
#line 410
      cr2 = tr1 - tr4;
#line 411
      cr4 = tr1 + tr4;
#line 412
      ci2 = ti1 + ti4;
#line 413
      ci4 = ti1 - ti4;
#line 415
      t8 = t7 + t0;
#line 415
      *(ch + (t8 - 1)) = *(wa1 + (i - 2)) * cr2 - *(wa1 + (i - 1)) * ci2;
#line 416
      *(ch + t8) = *(wa1 + (i - 2)) * ci2 + *(wa1 + (i - 1)) * cr2;
#line 417
      t8 += t0;
#line 417
      *(ch + (t8 - 1)) = *(wa2 + (i - 2)) * cr3 - *(wa2 + (i - 1)) * ci3;
#line 418
      *(ch + t8) = *(wa2 + (i - 2)) * ci3 + *(wa2 + (i - 1)) * cr3;
#line 419
      t8 += t0;
#line 419
      *(ch + (t8 - 1)) = *(wa3 + (i - 2)) * cr4 - *(wa3 + (i - 1)) * ci4;
#line 420
      *(ch + t8) = *(wa3 + (i - 2)) * ci4 + *(wa3 + (i - 1)) * cr4;
#line 392
      i += 2;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 422
    t1 += ido;
#line 389
    k ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 425
  if (ido % 2 == 1) {
#line 425
    return;
  }
  L105: 
#line 429
  t1 = ido;
#line 430
  t2 = ido << 2;
#line 431
  t3 = ido - 1;
#line 432
  t4 = ido + (ido << 1);
#line 433
  k = 0;
  {
#line 433
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 433
    if (! (k < l1)) {
#line 433
      goto while_break___2;
    }
#line 434
    t5 = t3;
#line 435
    ti1 = *(cc + t1) + *(cc + t4);
#line 436
    ti2 = *(cc + t4) - *(cc + t1);
#line 437
    tr1 = *(cc + (t1 - 1)) - *(cc + (t4 - 1));
#line 438
    tr2 = *(cc + (t1 - 1)) + *(cc + (t4 - 1));
#line 439
    *(ch + t5) = tr2 + tr2;
#line 440
    t5 += t0;
#line 440
    *(ch + t5) = sqrt2___1 * (tr1 - ti1);
#line 441
    t5 += t0;
#line 441
    *(ch + t5) = ti2 + ti2;
#line 442
    t5 += t0;
#line 442
    *(ch + t5) = - sqrt2___1 * (tr1 + ti1);
#line 444
    t3 += ido;
#line 445
    t1 += t2;
#line 446
    t4 += t2;
#line 433
    k ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 448
  return;
}
}
#line 450 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/smallft.c"
static void drftb1___1(int n , float *c , float *ch , float *wa , int *ifac ) 
{ 
  int i ;
  int k1 ;
  int l1 ;
  int l2 ;
  int na ;
  int nf ;
  int ip ;
  int iw ;
  int ix2 ;
  int ix3 ;
  int ido ;
  int idl1 ;

  {
#line 455
  nf = *(ifac + 1);
#line 456
  na = 0;
#line 457
  l1 = 1;
#line 458
  iw = 1;
#line 460
  k1 = 0;
  {
#line 460
  while (1) {
    while_continue: /* CIL Label */ ;
#line 460
    if (! (k1 < nf)) {
#line 460
      goto while_break;
    }
#line 461
    ip = *(ifac + (k1 + 2));
#line 462
    l2 = ip * l1;
#line 463
    ido = n / l2;
#line 464
    idl1 = ido * l1;
#line 465
    if (ip != 4) {
#line 465
      goto L103;
    }
#line 466
    ix2 = iw + ido;
#line 467
    ix3 = ix2 + ido;
#line 469
    if (na != 0) {
      {
#line 470
      dradb4___1(ido, l1, ch, c, (wa + iw) - 1, (wa + ix2) - 1, (wa + ix3) - 1);
      }
    } else {
      {
#line 472
      dradb4___1(ido, l1, c, ch, (wa + iw) - 1, (wa + ix2) - 1, (wa + ix3) - 1);
      }
    }
#line 473
    na = 1 - na;
#line 474
    goto L115;
    L103: 
#line 477
    if (ip != 2) {
#line 477
      goto L106;
    }
#line 479
    if (na != 0) {
      {
#line 480
      dradb2___1(ido, l1, ch, c, (wa + iw) - 1);
      }
    } else {
      {
#line 482
      dradb2___1(ido, l1, c, ch, (wa + iw) - 1);
      }
    }
#line 483
    na = 1 - na;
#line 484
    goto L115;
    L106: 
#line 487
    return;
    L115: 
#line 490
    l1 = l2;
#line 491
    iw += (ip - 1) * ido;
#line 460
    k1 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 494
  if (na == 0) {
#line 494
    return;
  }
#line 496
  i = 0;
  {
#line 496
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 496
    if (! (i < n)) {
#line 496
      goto while_break___0;
    }
#line 496
    *(c + i) = *(ch + i);
#line 496
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 497
  return;
}
}
#line 499 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/smallft.c"
static void fdrfftb___1(int n , float *r , float *wsave , int *ifac ) 
{ 


  {
#line 500
  if (n == 1) {
#line 500
    return;
  }
  {
#line 501
  drftb1___1(n, r, wsave, wsave + n, ifac);
  }
#line 502
  return;
}
}
#line 81 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/paranoia/p_block.c"
static c_block *i_cblock_constructor___0(cdrom_paranoia *p___0 ) 
{ 
  c_block *ret ;
  void *tmp ;

  {
  {
#line 82
  tmp = calloc((size_t )1, sizeof(c_block ));
#line 82
  ret = (c_block *)tmp;
  }
#line 83
  return (ret);
}
}
#line 116 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/paranoia/p_block.c"
static v_fragment *i_vfragment_constructor___0(void) 
{ 
  v_fragment *ret ;
  void *tmp ;

  {
  {
#line 117
  tmp = calloc((size_t )1, sizeof(v_fragment ));
#line 117
  ret = (v_fragment *)tmp;
  }
#line 118
  return (ret);
}
}
#line 121 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/paranoia/p_block.c"
static void i_v_fragment_destructor___0(v_fragment *v ) 
{ 


  {
  {
#line 122
  free((void *)v);
  }
#line 123
  return;
}
}
#line 109 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/utils.h"
static void cderror___9(cdrom_drive *d___0 , char const   *s ) 
{ 
  size_t tmp ;

  {
#line 110
  if (s) {
#line 110
    if (d___0) {
      {
#line 112
      if (d___0->errordest == 1) {
#line 112
        goto case_1;
      }
#line 115
      if (d___0->errordest == 2) {
#line 115
        goto case_2;
      }
#line 119
      goto switch_default;
      case_1: /* CIL Label */ 
      {
#line 113
      tmp = strlen(s);
#line 113
      write(2, (void const   *)s, tmp);
      }
#line 114
      goto switch_break;
      case_2: /* CIL Label */ 
      {
#line 116
      d___0->errorbuf = catstring(d___0->errorbuf, s);
      }
#line 117
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 120
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
  }
#line 123
  return;
}
}
#line 21 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/interface.c"
static void _clean_messages___1(cdrom_drive *d___0 ) 
{ 


  {
#line 22
  if (d___0) {
#line 23
    if (d___0->messagebuf) {
      {
#line 23
      free((void *)d___0->messagebuf);
      }
    }
#line 24
    if (d___0->errorbuf) {
      {
#line 24
      free((void *)d___0->errorbuf);
      }
    }
#line 25
    d___0->messagebuf = (char *)((void *)0);
#line 26
    d___0->errorbuf = (char *)((void *)0);
  }
#line 28
  return;
}
}
#line 566 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/paranoia/paranoia.c"
static long i_iterate_stage1___0(cdrom_paranoia *p___0 , c_block *old , c_block *new ,
                                 void (*callback___0)(long  , int  ) ) 
{ 
  long matchbegin ;
  long matchend ;
  long matchoffset ;
  long searchend ;
  long tmp ;
  long searchbegin ;
  long tmp___0 ;
  long searchsize ;
  sort_info *i ;
  long ret ;
  long j ;
  long tried ;
  long matched ;
  long j___0 ;
  long end ;
  long tmp___1 ;

  {
#line 569
  matchbegin = -1L;
#line 569
  matchend = -1L;
#line 584
  if (old->begin + old->size > new->begin + new->size) {
#line 584
    tmp = new->begin + new->size;
  } else {
#line 584
    tmp = old->begin + old->size;
  }
#line 584
  searchend = tmp;
#line 585
  if (old->begin < new->begin) {
#line 585
    tmp___0 = new->begin;
  } else {
#line 585
    tmp___0 = old->begin;
  }
#line 585
  searchbegin = tmp___0;
#line 586
  searchsize = searchend - searchbegin;
#line 587
  i = p___0->sortcache;
#line 588
  ret = 0L;
#line 591
  tried = 0L;
#line 591
  matched = 0L;
#line 593
  if (searchsize <= 0L) {
#line 593
    return (0L);
  }
#line 598
  j = searchbegin;
  {
#line 598
  while (1) {
    while_continue: /* CIL Label */ ;
#line 598
    if (! (j < searchend)) {
#line 598
      goto while_break;
    }
#line 604
    if (((int )*(new->flags + (j - new->begin)) & 6) == 0) {
      {
#line 605
      tried ++;
#line 616
      tmp___1 = try_sort_sync(p___0, i, new->flags, old, j, & matchbegin, & matchend,
                              & matchoffset, callback___0);
      }
#line 616
      if (tmp___1 == 1L) {
#line 619
        matched += matchend - matchbegin;
#line 624
        j___0 = matchbegin - old->begin;
#line 625
        end = matchend - old->begin;
        {
#line 626
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 626
          if (! (j___0 < end)) {
#line 626
            goto while_break___0;
          }
#line 626
          if ((int )*(old->vector + j___0) != 0) {
#line 626
            goto while_break___0;
          }
#line 626
          j___0 ++;
        }
        while_break___0: /* CIL Label */ ;
        }
#line 632
        if (j___0 < end) {
          {
#line 633
          stage1_matched(old, new, matchbegin, matchend, matchoffset, callback___0);
          }
        } else {
          {
#line 635
          stage1_matched(old, new, matchbegin, matchend, matchoffset, (void (*)(long  ,
                                                                                int  ))((void *)0));
          }
        }
#line 638
        ret ++;
#line 641
        if (matchend - 1L > j) {
#line 641
          j = matchend - 1L;
        }
      }
    }
#line 598
    j += 23L;
  }
  while_break: /* CIL Label */ ;
  }
#line 651
  return (ret);
}
}
#line 684 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/paranoia/paranoia.c"
static long i_stage1___0(cdrom_paranoia *p___0 , c_block *new , void (*callback___0)(long  ,
                                                                                     int  ) ) 
{ 
  long size ;
  c_block *ptr ;
  c_block *tmp ;
  int ret ;
  long begin ;
  long end ;
  int tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;

  {
  {
#line 687
  size = new->size;
#line 688
  tmp = c_last(p___0);
#line 688
  ptr = tmp;
#line 689
  ret = 0;
#line 690
  begin = 0L;
  }
#line 697
  if (ptr) {
    {
#line 697
    sort_setup(p___0->sortcache, new->vector, & new->begin, new->size, new->begin,
               new->begin + new->size);
    }
  }
  {
#line 708
  while (1) {
    while_continue: /* CIL Label */ ;
#line 708
    if (ptr) {
#line 708
      if (! ((unsigned long )ptr != (unsigned long )new)) {
#line 708
        goto while_break;
      }
    } else {
#line 708
      goto while_break;
    }
#line 710
    if (callback___0) {
      {
#line 710
      (*callback___0)(new->begin, 1);
      }
    }
    {
#line 711
    i_iterate_stage1___0(p___0, ptr, new, callback___0);
#line 713
    ptr = c_prev(ptr);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 721
  begin = 0L;
  {
#line 722
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 722
    if (! (begin < size)) {
#line 722
      goto while_break___0;
    }
    {
#line 723
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 723
      if (! (begin < size)) {
#line 723
        goto while_break___1;
      }
#line 723
      if ((int )*(new->flags + begin) & 4) {
#line 723
        goto while_break___1;
      }
#line 723
      begin ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 724
    end = begin;
    {
#line 724
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 724
      if (! (end < size)) {
#line 724
        goto while_break___2;
      }
#line 724
      if (((int )*(new->flags + end) & 4) == 0) {
#line 724
        goto while_break___2;
      }
#line 724
      end ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 725
    if (begin >= size) {
#line 725
      goto while_break___0;
    }
#line 727
    ret ++;
#line 738
    if (end + 31L >= size) {
#line 738
      if (new->lastsector) {
#line 738
        tmp___0 = 1;
      } else {
#line 738
        tmp___0 = 0;
      }
    } else {
#line 738
      tmp___0 = 0;
    }
#line 738
    if (size > end + 31L) {
#line 738
      tmp___1 = end + 31L;
    } else {
#line 738
      tmp___1 = size;
    }
#line 738
    if (0L < begin - 31L) {
#line 738
      tmp___2 = begin - 31L;
    } else {
#line 738
      tmp___2 = 0L;
    }
    {
#line 738
    new_v_fragment(p___0, new, new->begin + tmp___2, new->begin + tmp___1, tmp___0);
#line 742
    begin = end;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 748
  return ((long )ret);
}
}
#line 795 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/paranoia/paranoia.c"
static long i_iterate_stage2___0(cdrom_paranoia *p___0 , v_fragment *v , sync_result *r ,
                                 void (*callback___0)(long  , int  ) ) 
{ 
  root_block *root ;
  long matchbegin ;
  long matchend ;
  long offset ;
  long fbv ;
  long fev ;
  long tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  long tmp___4 ;
  long tmp___5 ;
  long tmp___6 ;
  long tmp___8 ;
  long tmp___9 ;
  int16_t *tmp___10 ;
  long tmp___16 ;
  long tmp___17 ;
  long tmp___18 ;
  long tmp___20 ;
  long tmp___21 ;
  long tmp___22 ;
  long searchend ;
  long tmp___24 ;
  long tmp___25 ;
  long tmp___26 ;
  long searchbegin ;
  long tmp___28 ;
  long tmp___29 ;
  long tmp___30 ;
  sort_info *i ;
  long j ;
  int16_t *tmp___31 ;
  int16_t *tmp___32 ;
  long tmp___33 ;
  long tmp___34 ;

  {
  {
#line 797
  root = & p___0->root;
#line 798
  matchbegin = -1L;
#line 798
  matchend = -1L;
#line 814
  tmp___2 = re(root);
  }
#line 814
  if ((v->begin + v->size) + p___0->dynoverlap > tmp___2) {
    {
#line 814
    tmp___0 = re(root);
#line 814
    tmp___1 = tmp___0;
    }
  } else {
#line 814
    tmp___1 = (v->begin + v->size) + p___0->dynoverlap;
  }
  {
#line 814
  tmp___6 = rb(root);
  }
#line 814
  if (v->begin - p___0->dynoverlap < tmp___6) {
    {
#line 814
    tmp___4 = rb(root);
#line 814
    tmp___5 = tmp___4;
    }
  } else {
#line 814
    tmp___5 = v->begin - p___0->dynoverlap;
  }
#line 814
  if (tmp___1 - tmp___5 <= 0L) {
#line 815
    return (0L);
  }
#line 817
  if (callback___0) {
    {
#line 817
    (*callback___0)(v->begin, 1);
    }
  }
  {
#line 825
  tmp___9 = rb(root);
  }
#line 825
  if (v->begin < tmp___9 - p___0->dynoverlap) {
    {
#line 825
    tmp___8 = rb(root);
#line 825
    fbv = tmp___8 - p___0->dynoverlap;
    }
  } else {
#line 825
    fbv = v->begin;
  }
  {
#line 830
  while (1) {
    while_continue: /* CIL Label */ ;
#line 830
    if (fbv < v->begin + v->size) {
      {
#line 830
      tmp___10 = v_buffer(v);
      }
#line 830
      if (! ((int )*(tmp___10 + (fbv - v->begin)) == 0)) {
#line 830
        goto while_break;
      }
    } else {
#line 830
      goto while_break;
    }
#line 830
    fbv ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 831
  if (fbv == v->begin + v->size) {
#line 831
    return (0L);
  }
  {
#line 846
  tmp___22 = re(root);
  }
#line 846
  if (fbv + 256L > tmp___22 + p___0->dynoverlap) {
    {
#line 846
    tmp___20 = re(root);
#line 846
    tmp___21 = tmp___20 + p___0->dynoverlap;
    }
  } else {
#line 846
    tmp___21 = fbv + 256L;
  }
#line 846
  if (tmp___21 > v->begin + v->size) {
#line 846
    fev = v->begin + v->size;
  } else {
    {
#line 846
    tmp___18 = re(root);
    }
#line 846
    if (fbv + 256L > tmp___18 + p___0->dynoverlap) {
      {
#line 846
      tmp___16 = re(root);
#line 846
      tmp___17 = tmp___16 + p___0->dynoverlap;
      }
    } else {
#line 846
      tmp___17 = fbv + 256L;
    }
#line 846
    fev = tmp___17;
  }
  {
#line 855
  tmp___26 = re(root);
  }
#line 855
  if (fev + p___0->dynoverlap > tmp___26) {
    {
#line 855
    tmp___24 = re(root);
#line 855
    tmp___25 = tmp___24;
    }
  } else {
#line 855
    tmp___25 = fev + p___0->dynoverlap;
  }
  {
#line 855
  searchend = tmp___25;
#line 856
  tmp___30 = rb(root);
  }
#line 856
  if (fbv - p___0->dynoverlap < tmp___30) {
    {
#line 856
    tmp___28 = rb(root);
#line 856
    tmp___29 = tmp___28;
    }
  } else {
#line 856
    tmp___29 = fbv - p___0->dynoverlap;
  }
  {
#line 856
  searchbegin = tmp___29;
#line 857
  i = p___0->sortcache;
#line 864
  tmp___31 = v_buffer(v);
#line 864
  sort_setup(i, tmp___31, & v->begin, v->size, fbv, fev);
#line 866
  j = searchbegin;
  }
  {
#line 866
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 866
    if (! (j < searchend)) {
#line 866
      goto while_break___0;
    }
    {
#line 879
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 879
      if (j < searchend) {
        {
#line 879
        tmp___32 = rv(root);
#line 879
        tmp___33 = rb(root);
        }
#line 879
        if (! ((int )*(tmp___32 + (j - tmp___33)) == 0)) {
#line 879
          goto while_break___1;
        }
      } else {
#line 879
        goto while_break___1;
      }
#line 879
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 880
    if (j == searchend) {
#line 880
      goto while_break___0;
    }
    {
#line 895
    tmp___34 = try_sort_sync(p___0, i, (unsigned char *)((void *)0), root->vector,
                             j, & matchbegin, & matchend, & offset, callback___0);
    }
#line 895
    if (tmp___34) {
#line 911
      r->begin = matchbegin;
#line 912
      r->end = matchend;
#line 913
      r->offset = - offset;
#line 914
      if (offset) {
#line 914
        if (callback___0) {
          {
#line 914
          (*callback___0)(r->begin, 2);
          }
        }
      }
#line 915
      return (1L);
    }
#line 866
    j += 23L;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 920
  return (0L);
}
}
#line 936 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/paranoia/paranoia.c"
static void i_silence_test___0(root_block *root ) 
{ 
  int16_t *vec ;
  int16_t *tmp ;
  long end ;
  long tmp___0 ;
  long tmp___1 ;
  long j ;
  long tmp___2 ;

  {
  {
#line 937
  tmp = rv(root);
#line 937
  vec = tmp;
#line 938
  tmp___0 = re(root);
#line 938
  tmp___1 = rb(root);
#line 938
  end = (tmp___0 - tmp___1) - 1L;
#line 944
  j = end - 1L;
  }
  {
#line 944
  while (1) {
    while_continue: /* CIL Label */ ;
#line 944
    if (! (j >= 0L)) {
#line 944
      goto while_break;
    }
#line 944
    if ((int )*(vec + j) != 0) {
#line 944
      goto while_break;
    }
#line 944
    j --;
  }
  while_break: /* CIL Label */ ;
  }
#line 950
  if (j < 0L) {
#line 950
    goto _L;
  } else
#line 950
  if (end - j > 1024L) {
    _L: /* CIL Label */ 
    {
#line 951
    root->silenceflag = 1;
#line 952
    tmp___2 = rb(root);
#line 952
    root->silencebegin = (tmp___2 + j) + 1L;
    }
#line 953
    if (root->silencebegin < root->returnedlimit) {
#line 954
      root->silencebegin = root->returnedlimit;
    }
  }
#line 956
  return;
}
}
#line 984 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/paranoia/paranoia.c"
static long i_silence_match___0(root_block *root , v_fragment *v , void (*callback___0)(long  ,
                                                                                        int  ) ) 
{ 
  cdrom_paranoia *p___0 ;
  int16_t *vec ;
  int16_t *tmp ;
  long end ;
  long begin ;
  long j ;
  long addto ;
  long tmp___0 ;
  int16_t *vec___0 ;
  unsigned long __lengthofvec___0 ;
  void *tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;
  long tmp___5 ;
  long tmp___6 ;
  long voff ;
  long tmp___7 ;
  long tmp___8 ;
  long voff___0 ;
  long tmp___9 ;
  long tmp___10 ;

  {
  {
#line 987
  p___0 = v->p;
#line 988
  tmp = v_buffer(v);
#line 988
  vec = tmp;
#line 989
  end = v->size;
  }
#line 1001
  if (end < 1024L) {
#line 1001
    return (0L);
  }
#line 1002
  j = 0L;
  {
#line 1002
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1002
    if (! (j < end)) {
#line 1002
      goto while_break;
    }
#line 1002
    if ((int )*(vec + j) != 0) {
#line 1002
      goto while_break;
    }
#line 1002
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1003
  if (j < 1024L) {
#line 1003
    return (0L);
  }
  {
#line 1009
  j += v->begin;
#line 1014
  tmp___2 = re(root);
  }
#line 1014
  if (v->begin >= tmp___2) {
    {
#line 1014
    tmp___3 = re(root);
    }
#line 1014
    if (v->begin - p___0->dynoverlap < tmp___3) {
      {
#line 1021
      tmp___0 = re(root);
#line 1021
      addto = (v->begin + 1024L) - tmp___0;
#line 1022
      __lengthofvec___0 = (unsigned long )addto;
#line 1022
      tmp___1 = __builtin_alloca(sizeof(*vec___0) * __lengthofvec___0);
#line 1022
      vec___0 = (int16_t *)tmp___1;
#line 1023
      memset((void *)vec___0, 0, sizeof(*vec___0) * __lengthofvec___0);
#line 1024
      c_append(root->vector, vec___0, addto);
      }
    }
  }
#line 1030
  if (v->begin < root->silencebegin) {
#line 1030
    begin = root->silencebegin;
  } else {
#line 1030
    begin = v->begin;
  }
  {
#line 1031
  tmp___6 = re(root);
  }
#line 1031
  if (j > tmp___6) {
    {
#line 1031
    tmp___5 = re(root);
#line 1031
    end = tmp___5;
    }
  } else {
#line 1031
    end = j;
  }
#line 1036
  if (begin < end) {
    {
#line 1042
    tmp___8 = re(root);
    }
#line 1042
    if (v->begin + v->size > tmp___8) {
      {
#line 1043
      voff = begin - v->begin;
#line 1047
      tmp___7 = rb(root);
#line 1047
      c_remove(root->vector, begin - tmp___7, -1L);
#line 1051
      c_append(root->vector, vec + voff, v->size - voff);
      }
    }
    {
#line 1056
    offset_add_value(p___0, & p___0->stage2, 0L, callback___0);
    }
  } else
#line 1066
  if (j < begin) {
    {
#line 1089
    voff___0 = j - v->begin;
#line 1097
    tmp___10 = re(root);
    }
#line 1097
    if ((begin + v->size) - voff___0 > tmp___10) {
      {
#line 1101
      tmp___9 = rb(root);
#line 1101
      c_remove(root->vector, root->silencebegin - tmp___9, -1L);
#line 1105
      c_append(root->vector, vec + voff___0, v->size - voff___0);
      }
    }
    {
#line 1111
    offset_add_value(p___0, & p___0->stage2, end - begin, callback___0);
    }
  } else {
#line 1122
    return (0L);
  }
  {
#line 1133
  root->silenceflag = 0;
#line 1137
  i_silence_test___0(root);
  }
#line 1143
  if (v->lastsector) {
#line 1143
    root->lastsector = 1L;
  }
  {
#line 1144
  free_v_fragment(v);
  }
#line 1145
  return (1L);
}
}
#line 1171 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/paranoia/paranoia.c"
static long i_stage2_each___0(root_block *root , v_fragment *v , void (*callback___0)(long  ,
                                                                                      int  ) ) 
{ 
  cdrom_paranoia *p___0 ;
  long dynoverlap ;
  sync_result r ;
  long begin ;
  long tmp ;
  long end ;
  long tmp___0 ;
  long offset ;
  long temp ;
  c_block *l ;
  long matchA ;
  long matchB ;
  long matchC ;
  long beginL ;
  int16_t *buff ;
  void *tmp___1 ;
  int16_t *tmp___2 ;
  long tmp___3 ;
  int16_t *tmp___4 ;
  long tmp___5 ;
  long tmp___6 ;
  long tmp___7 ;
  long tmp___8 ;
  long tmp___9 ;
  int16_t *tmp___10 ;
  long tmp___11 ;
  long tmp___12 ;
  long tmp___13 ;
  int16_t *tmp___14 ;
  long matchA___0 ;
  long matchB___0 ;
  long matchC___0 ;
  long beginL___0 ;
  long endL ;
  int16_t *buff___0 ;
  void *tmp___15 ;
  int16_t *tmp___16 ;
  long tmp___17 ;
  int16_t *tmp___18 ;
  long tmp___19 ;
  long tmp___20 ;
  long tmp___21 ;
  long tmp___22 ;
  long tmp___23 ;
  int16_t *tmp___24 ;
  long tmp___25 ;
  long tmp___26 ;
  long tmp___27 ;
  int16_t *tmp___28 ;
  long tmp___29 ;
  long tmp___30 ;
  int16_t *tmp___31 ;
  long tmp___32 ;
  long sizeA ;
  long tmp___33 ;
  long sizeB ;
  long vecbegin ;
  int16_t *vector ;
  long tmp___34 ;
  long tmp___35 ;
  long tmp___36 ;
  int16_t *tmp___37 ;

  {
#line 1174
  p___0 = v->p;
#line 1175
  dynoverlap = (p___0->dynoverlap / 2L) * 2L;
#line 1180
  if (! v) {
#line 1180
    return (0L);
  } else
#line 1180
  if (! v->one) {
#line 1180
    return (0L);
  }
  {
#line 1183
  tmp___37 = rv(root);
  }
#line 1183
  if (tmp___37) {
    {
#line 1192
    tmp___36 = i_iterate_stage2___0(p___0, v, & r, callback___0);
    }
#line 1192
    if (tmp___36) {
      {
#line 1195
      tmp = rb(root);
#line 1195
      begin = r.begin - tmp;
#line 1196
      tmp___0 = rb(root);
#line 1196
      end = r.end - tmp___0;
#line 1206
      offset = ((r.begin + r.offset) - v->begin) - begin;
#line 1208
      l = (c_block *)((void *)0);
      }
      {
#line 1260
      while (1) {
        while_continue: /* CIL Label */ ;
#line 1260
        if (begin + offset > 0L) {
#line 1260
          if (! (begin > 0L)) {
#line 1260
            goto while_break;
          }
        } else {
#line 1260
          goto while_break;
        }
#line 1261
        matchA = 0L;
#line 1261
        matchB = 0L;
#line 1261
        matchC = 0L;
#line 1267
        beginL = begin + offset;
#line 1274
        if ((unsigned long )l == (unsigned long )((void *)0)) {
          {
#line 1275
          tmp___1 = malloc((unsigned long )v->size * sizeof(int16_t ));
#line 1275
          buff = (int16_t *)tmp___1;
#line 1276
          l = c_alloc(buff, v->begin, v->size);
#line 1277
          tmp___2 = v_buffer(v);
#line 1277
          memcpy((void */* __restrict  */)buff, (void const   */* __restrict  */)tmp___2,
                 (unsigned long )v->size * sizeof(int16_t ));
          }
        }
        {
#line 1291
        tmp___3 = rs(root);
#line 1291
        tmp___4 = rv(root);
#line 1291
        i_analyze_rift_r(tmp___4, l->vector, tmp___3, l->size, begin - 1L, beginL - 1L,
                         & matchA, & matchB, & matchC);
        }
#line 1305
        if (matchA) {
#line 1308
          if (matchA > 0L) {
#line 1312
            if (callback___0) {
              {
#line 1312
              tmp___5 = rb(root);
#line 1312
              (*callback___0)((begin + tmp___5) - 1L, 10);
              }
            }
            {
#line 1313
            tmp___6 = rb(root);
            }
#line 1313
            if (tmp___6 + begin < p___0->root.returnedlimit) {
#line 1314
              goto while_break;
            } else {
              {
#line 1322
              c_insert(root->vector, begin, (l->vector + beginL) - matchA, matchA);
#line 1330
              offset -= matchA;
#line 1331
              begin += matchA;
#line 1332
              end += matchA;
              }
            }
          } else {
#line 1339
            if (callback___0) {
              {
#line 1339
              tmp___7 = rb(root);
#line 1339
              (*callback___0)((begin + tmp___7) - 1L, 11);
              }
            }
            {
#line 1340
            tmp___8 = rb(root);
            }
#line 1340
            if ((tmp___8 + begin) + matchA < p___0->root.returnedlimit) {
#line 1341
              goto while_break;
            } else {
              {
#line 1347
              c_remove(root->vector, begin + matchA, - matchA);
#line 1354
              offset -= matchA;
#line 1355
              begin += matchA;
#line 1356
              end += matchA;
              }
            }
          }
        } else
#line 1359
        if (matchB) {
#line 1362
          if (matchB > 0L) {
#line 1366
            if (callback___0) {
              {
#line 1366
              tmp___9 = rb(root);
#line 1366
              (*callback___0)((begin + tmp___9) - 1L, 10);
              }
            }
            {
#line 1373
            tmp___10 = rv(root);
#line 1373
            c_insert(l, beginL, (tmp___10 + begin) - matchB, matchB);
#line 1380
            offset += matchB;
            }
          } else {
#line 1386
            if (callback___0) {
              {
#line 1386
              tmp___11 = rb(root);
#line 1386
              (*callback___0)((begin + tmp___11) - 1L, 11);
              }
            }
            {
#line 1391
            c_remove(l, beginL + matchB, - matchB);
#line 1397
            offset += matchB;
            }
          }
        } else
#line 1400
        if (matchC) {
          {
#line 1415
          tmp___12 = rb(root);
          }
#line 1415
          if ((tmp___12 + begin) - matchC < p___0->root.returnedlimit) {
#line 1416
            goto while_break;
          }
          {
#line 1426
          c_overwrite(root->vector, begin - matchC, (l->vector + beginL) - matchC,
                      matchC);
          }
        } else {
#line 1453
          goto while_break;
        }
        {
#line 1463
        beginL = begin + offset;
#line 1470
        tmp___13 = rs(root);
#line 1470
        tmp___14 = rv(root);
#line 1470
        i_paranoia_overlap(tmp___14, l->vector, begin, beginL, tmp___13, l->size,
                           & begin, & end);
        }
      }
      while_break: /* CIL Label */ ;
      }
#line 1496
      if (l) {
#line 1496
        temp = l->size;
      } else {
#line 1496
        temp = v->size;
      }
      {
#line 1497
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1497
        if (end + offset < temp) {
          {
#line 1497
          tmp___32 = rs(root);
          }
#line 1497
          if (! (end < tmp___32)) {
#line 1497
            goto while_break___0;
          }
        } else {
#line 1497
          goto while_break___0;
        }
#line 1498
        matchA___0 = 0L;
#line 1498
        matchB___0 = 0L;
#line 1498
        matchC___0 = 0L;
#line 1505
        beginL___0 = begin + offset;
#line 1511
        endL = end + offset;
#line 1520
        if ((unsigned long )l == (unsigned long )((void *)0)) {
          {
#line 1521
          tmp___15 = malloc((unsigned long )v->size * sizeof(int16_t ));
#line 1521
          buff___0 = (int16_t *)tmp___15;
#line 1522
          l = c_alloc(buff___0, v->begin, v->size);
#line 1523
          tmp___16 = v_buffer(v);
#line 1523
          memcpy((void */* __restrict  */)buff___0, (void const   */* __restrict  */)tmp___16,
                 (unsigned long )v->size * sizeof(int16_t ));
          }
        }
        {
#line 1537
        tmp___17 = rs(root);
#line 1537
        tmp___18 = rv(root);
#line 1537
        i_analyze_rift_f(tmp___18, l->vector, tmp___17, l->size, end, endL, & matchA___0,
                         & matchB___0, & matchC___0);
        }
#line 1547
        if (matchA___0) {
#line 1550
          if (matchA___0 > 0L) {
#line 1554
            if (callback___0) {
              {
#line 1554
              tmp___19 = rb(root);
#line 1554
              (*callback___0)(end + tmp___19, 10);
              }
            }
            {
#line 1555
            tmp___20 = rb(root);
            }
#line 1555
            if (end + tmp___20 < p___0->root.returnedlimit) {
#line 1556
              goto while_break___0;
            }
            {
#line 1563
            c_insert(root->vector, end, l->vector + endL, matchA___0);
            }
          } else {
#line 1573
            if (callback___0) {
              {
#line 1573
              tmp___21 = rb(root);
#line 1573
              (*callback___0)(end + tmp___21, 11);
              }
            }
            {
#line 1574
            tmp___22 = rb(root);
            }
#line 1574
            if (end + tmp___22 < p___0->root.returnedlimit) {
#line 1575
              goto while_break___0;
            }
            {
#line 1580
            c_remove(root->vector, end, - matchA___0);
            }
          }
        } else
#line 1587
        if (matchB___0) {
#line 1590
          if (matchB___0 > 0L) {
#line 1594
            if (callback___0) {
              {
#line 1594
              tmp___23 = rb(root);
#line 1594
              (*callback___0)(end + tmp___23, 10);
              }
            }
            {
#line 1601
            tmp___24 = rv(root);
#line 1601
            c_insert(l, endL, tmp___24 + end, matchB___0);
            }
          } else {
#line 1611
            if (callback___0) {
              {
#line 1611
              tmp___25 = rb(root);
#line 1611
              (*callback___0)(end + tmp___25, 11);
              }
            }
            {
#line 1616
            c_remove(l, endL, - matchB___0);
            }
          }
        } else
#line 1622
        if (matchC___0) {
          {
#line 1634
          tmp___26 = rb(root);
          }
#line 1634
          if (end + tmp___26 < p___0->root.returnedlimit) {
#line 1635
            goto while_break___0;
          }
          {
#line 1640
          c_overwrite(root->vector, end, l->vector + endL, matchC___0);
          }
        } else {
          {
#line 1650
          tmp___27 = rs(root);
#line 1650
          tmp___28 = rv(root);
#line 1650
          analyze_rift_silence_f(tmp___28, l->vector, tmp___27, l->size, end, endL,
                                 & matchA___0, & matchB___0);
          }
#line 1654
          if (matchA___0) {
            {
#line 1666
            tmp___29 = rb(root);
            }
#line 1666
            if (end + tmp___29 >= p___0->root.returnedlimit) {
              {
#line 1667
              c_remove(root->vector, end, -1L);
              }
            }
          } else
#line 1670
          if (matchB___0) {
#line 1684
            if (l) {
              {
#line 1684
              i_cblock_destructor(l);
              }
            }
            {
#line 1685
            free_v_fragment(v);
            }
#line 1686
            return (1L);
          }
#line 1696
          goto while_break___0;
        }
        {
#line 1704
        tmp___30 = rs(root);
#line 1704
        tmp___31 = rv(root);
#line 1704
        i_paranoia_overlap(tmp___31, l->vector, begin, beginL___0, tmp___30, l->size,
                           (long *)((void *)0), & end);
#line 1709
        temp = l->size;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 1737
      tmp___33 = rs(root);
#line 1737
      sizeA = tmp___33;
      }
#line 1745
      if (l) {
#line 1746
        sizeB = l->size;
#line 1747
        vector = l->vector;
#line 1748
        vecbegin = l->begin;
      } else {
        {
#line 1750
        sizeB = v->size;
#line 1751
        vector = v_buffer(v);
#line 1752
        vecbegin = v->begin;
        }
      }
#line 1765
      if (sizeB - offset > sizeA) {
#line 1765
        goto _L;
      } else
#line 1765
      if (v->lastsector) {
        _L: /* CIL Label */ 
#line 1766
        if (v->lastsector) {
#line 1767
          root->lastsector = 1L;
        }
#line 1776
        if (end < sizeA) {
          {
#line 1776
          c_remove(root->vector, end, -1L);
          }
        }
#line 1781
        if ((sizeB - offset) - end) {
          {
#line 1781
          c_append(root->vector, (vector + end) + offset, (sizeB - offset) - end);
          }
        }
        {
#line 1787
        i_silence_test___0(root);
#line 1802
        tmp___34 = rb(root);
#line 1802
        offset_add_value(p___0, & p___0->stage2, (offset + vecbegin) - tmp___34, callback___0);
        }
      }
#line 1805
      if (l) {
        {
#line 1805
        i_cblock_destructor(l);
        }
      }
      {
#line 1806
      free_v_fragment(v);
      }
#line 1807
      return (1L);
    } else {
      {
#line 1827
      tmp___35 = re(root);
      }
#line 1827
      if ((v->begin + v->size) + dynoverlap < tmp___35) {
#line 1827
        if (! root->silenceflag) {
          {
#line 1829
          free_v_fragment(v);
          }
        }
      }
#line 1834
      return (0L);
    }
  } else {
#line 1184
    return (0L);
  }
}
}
#line 1840 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/paranoia/paranoia.c"
static int i_init_root___0(root_block *root , v_fragment *v , long begin , void (*callback___0)(long  ,
                                                                                                int  ) ) 
{ 
  int16_t *tmp ;
  int16_t *buff ;
  void *tmp___0 ;
  int16_t *tmp___1 ;

  {
#line 1842
  if (v->begin <= begin) {
#line 1842
    if (v->begin + v->size > begin) {
      {
#line 1844
      root->lastsector = v->lastsector;
#line 1845
      root->returnedlimit = begin;
#line 1847
      tmp = rv(root);
      }
#line 1847
      if (tmp) {
        {
#line 1848
        i_cblock_destructor(root->vector);
#line 1849
        root->vector = (c_block *)((void *)0);
        }
      }
      {
#line 1853
      tmp___0 = malloc((unsigned long )v->size * sizeof(int16_t ));
#line 1853
      buff = (int16_t *)tmp___0;
#line 1854
      tmp___1 = v_buffer(v);
#line 1854
      memcpy((void */* __restrict  */)buff, (void const   */* __restrict  */)tmp___1,
             (unsigned long )v->size * sizeof(int16_t ));
#line 1855
      root->vector = c_alloc(buff, v->begin, v->size);
#line 1860
      i_silence_test___0(root);
      }
#line 1862
      return (1);
    } else {
#line 1864
      return (0);
    }
  } else {
#line 1864
    return (0);
  }
}
}
#line 1867 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/paranoia/paranoia.c"
static int vsort___0(void const   *a , void const   *b ) 
{ 


  {
#line 1868
  return ((int )((*((v_fragment **)a))->begin - (*((v_fragment **)b))->begin));
}
}
#line 1897 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/paranoia/paranoia.c"
static int i_stage2___0(cdrom_paranoia *p___0 , long beginword , long endword , void (*callback___0)(long  ,
                                                                                                     int  ) ) 
{ 
  int flag ;
  int ret ;
  root_block *root ;
  v_fragment *first ;
  v_fragment *tmp ;
  long active ;
  long count ;
  v_fragment **list ;
  unsigned long __lengthoflist ;
  void *tmp___0 ;
  v_fragment *next ;
  v_fragment *tmp___1 ;
  long tmp___2 ;
  int tmp___3 ;
  long tmp___4 ;
  int16_t *tmp___5 ;
  long tmp___6 ;
  int16_t *tmp___7 ;

  {
#line 1900
  flag = 1;
#line 1900
  ret = 0;
#line 1901
  root = & p___0->root;
  {
#line 1917
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1917
    if (! flag) {
#line 1917
      goto while_break;
    }
    {
#line 1922
    tmp = v_first(p___0);
#line 1922
    first = tmp;
#line 1923
    active = (p___0->fragments)->active;
#line 1923
    count = 0L;
#line 1924
    __lengthoflist = (unsigned long )active;
#line 1924
    tmp___0 = __builtin_alloca(sizeof(*list) * __lengthoflist);
#line 1924
    list = (v_fragment **)tmp___0;
    }
    {
#line 1926
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1926
      if (! first) {
#line 1926
        goto while_break___0;
      }
      {
#line 1927
      tmp___1 = v_next(first);
#line 1927
      next = tmp___1;
#line 1928
      tmp___2 = count;
#line 1928
      count ++;
#line 1928
      *(list + tmp___2) = first;
#line 1929
      first = next;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1936
    flag = 0;
#line 1937
    if (count) {
      {
#line 1942
      qsort((void *)list, (size_t )active, sizeof(v_fragment *), & vsort___0);
#line 1953
      count = 0L;
      }
      {
#line 1953
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1953
        if (! (count < active)) {
#line 1953
          goto while_break___1;
        }
#line 1954
        first = *(list + count);
#line 1958
        if (first->one) {
          {
#line 1984
          tmp___5 = rv(root);
          }
#line 1984
          if ((unsigned long )tmp___5 == (unsigned long )((void *)0)) {
            {
#line 1985
            tmp___3 = i_init_root___0(& p___0->root, first, beginword, callback___0);
            }
#line 1985
            if (tmp___3) {
              {
#line 1986
              free_v_fragment(first);
#line 1991
              flag = 1;
#line 1992
              ret ++;
              }
            }
          } else {
            {
#line 1999
            tmp___4 = i_stage2_each___0(root, first, callback___0);
            }
#line 1999
            if (tmp___4) {
#line 2004
              ret ++;
#line 2005
              flag = 1;
            }
          }
        }
#line 1953
        count ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 2015
      if (! flag) {
#line 2015
        if (p___0->root.silenceflag) {
#line 2016
          count = 0L;
          {
#line 2016
          while (1) {
            while_continue___2: /* CIL Label */ ;
#line 2016
            if (! (count < active)) {
#line 2016
              goto while_break___2;
            }
#line 2017
            first = *(list + count);
#line 2021
            if (first->one) {
              {
#line 2022
              tmp___7 = rv(root);
              }
#line 2022
              if ((unsigned long )tmp___7 != (unsigned long )((void *)0)) {
                {
#line 2031
                tmp___6 = i_silence_match___0(root, first, callback___0);
                }
#line 2031
                if (tmp___6) {
#line 2036
                  ret ++;
#line 2037
                  flag = 1;
                }
              }
            }
#line 2016
            count ++;
          }
          while_break___2: /* CIL Label */ ;
          }
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2055
  return (ret);
}
}
#line 2058 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/paranoia/paranoia.c"
static void i_end_case___0(cdrom_paranoia *p___0 , long endword , void (*callback___0)(long  ,
                                                                                       int  ) ) 
{ 
  root_block *root ;
  long tmp ;
  long addto ;
  long tmp___0 ;
  char *temp ;
  void *tmp___1 ;

  {
#line 2061
  root = & p___0->root;
#line 2068
  if (root->lastsector == 0L) {
#line 2068
    return;
  }
  {
#line 2069
  tmp = re(root);
  }
#line 2069
  if (endword < tmp) {
#line 2069
    return;
  }
  {
#line 2072
  tmp___0 = re(root);
#line 2072
  addto = endword - tmp___0;
#line 2073
  tmp___1 = calloc((size_t )addto, sizeof(char ) * 2UL);
#line 2073
  temp = (char *)tmp___1;
#line 2075
  c_append(root->vector, (int16_t *)((void *)temp), addto);
#line 2076
  free((void *)temp);
#line 2079
  paranoia_resetcache(p___0);
  }
#line 2082
  return;
}
}
#line 2092 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/paranoia/paranoia.c"
static void verify_skip_case___0(cdrom_paranoia *p___0 , void (*callback___0)(long  ,
                                                                              int  ) ) 
{ 
  root_block *root ;
  c_block *graft ;
  int vflag ;
  int gend ;
  long post ;
  int16_t *tmp ;
  c_block *c ;
  c_block *tmp___0 ;
  long cbegin ;
  long cend ;
  long vend ;
  long cbegin___0 ;
  long cend___0 ;
  int16_t *buff ;
  void *tmp___1 ;
  int16_t *tmp___2 ;
  void *temp ;
  void *tmp___3 ;
  int16_t *tmp___4 ;

  {
  {
#line 2094
  root = & p___0->root;
#line 2095
  graft = (c_block *)((void *)0);
#line 2096
  vflag = 0;
#line 2097
  gend = 0;
#line 2104
  tmp = rv(root);
  }
#line 2104
  if ((unsigned long )tmp == (unsigned long )((void *)0)) {
#line 2105
    post = 0L;
  } else {
    {
#line 2107
    post = re(root);
    }
  }
#line 2109
  if (post == -1L) {
#line 2109
    post = 0L;
  }
#line 2111
  if (callback___0) {
    {
#line 2111
    (*callback___0)(post, 6);
    }
  }
  {
#line 2117
  tmp___0 = c_first(p___0);
#line 2117
  c = tmp___0;
  }
  {
#line 2118
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2118
    if (! c) {
#line 2118
      goto while_break;
    }
#line 2119
    cbegin = c->begin;
#line 2120
    cend = c->begin + c->size;
#line 2121
    if (cbegin <= post) {
#line 2121
      if (cend > post) {
#line 2122
        vend = post;
#line 2124
        if ((int )*(c->flags + (post - cbegin)) & 4) {
          {
#line 2126
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 2126
            if (vend < cend) {
#line 2126
              if (! ((int )*(c->flags + (vend - cbegin)) & 4)) {
#line 2126
                goto while_break___0;
              }
            } else {
#line 2126
              goto while_break___0;
            }
#line 2126
            vend ++;
          }
          while_break___0: /* CIL Label */ ;
          }
#line 2127
          if (! vflag) {
#line 2128
            graft = c;
#line 2129
            gend = (int )vend;
          } else
#line 2127
          if (vend > (long )vflag) {
#line 2128
            graft = c;
#line 2129
            gend = (int )vend;
          }
#line 2131
          vflag = 1;
        } else
#line 2134
        if (! vflag) {
          {
#line 2135
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 2135
            if (vend < cend) {
#line 2135
              if (! (((int )*(c->flags + (vend - cbegin)) & 4) == 0)) {
#line 2135
                goto while_break___1;
              }
            } else {
#line 2135
              goto while_break___1;
            }
#line 2135
            vend ++;
          }
          while_break___1: /* CIL Label */ ;
          }
#line 2136
          if ((unsigned long )graft == (unsigned long )((void *)0)) {
#line 2138
            graft = c;
#line 2139
            gend = (int )vend;
          } else
#line 2136
          if ((long )gend > vend) {
#line 2138
            graft = c;
#line 2139
            gend = (int )vend;
          }
        }
      }
    }
    {
#line 2144
    c = c_next(c);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2147
  if (graft) {
#line 2148
    cbegin___0 = graft->begin;
#line 2149
    cend___0 = graft->begin + graft->size;
    {
#line 2151
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 2151
      if ((long )gend < cend___0) {
#line 2151
        if (! ((int )*(graft->flags + ((long )gend - cbegin___0)) & 4)) {
#line 2151
          goto while_break___2;
        }
      } else {
#line 2151
        goto while_break___2;
      }
#line 2151
      gend ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 2152
    if ((long )(gend + 31) > cend___0) {
#line 2152
      gend = (int )cend___0;
    } else {
#line 2152
      gend += 31;
    }
    {
#line 2154
    tmp___2 = rv(root);
    }
#line 2154
    if ((unsigned long )tmp___2 == (unsigned long )((void *)0)) {
      {
#line 2155
      tmp___1 = malloc((size_t )graft->size);
#line 2155
      buff = (int16_t *)tmp___1;
#line 2156
      memcpy((void */* __restrict  */)buff, (void const   */* __restrict  */)graft->vector,
             (size_t )graft->size);
#line 2157
      root->vector = c_alloc(buff, graft->begin, graft->size);
      }
    } else {
      {
#line 2159
      c_append(root->vector, (graft->vector + post) - cbegin___0, (long )gend - post);
      }
    }
    {
#line 2163
    root->returnedlimit = re(root);
    }
#line 2164
    return;
  }
  {
#line 2170
  tmp___3 = calloc((size_t )2352, sizeof(int16_t ));
#line 2170
  temp = tmp___3;
#line 2172
  tmp___4 = rv(root);
  }
#line 2172
  if ((unsigned long )tmp___4 == (unsigned long )((void *)0)) {
    {
#line 2173
    root->vector = c_alloc((int16_t *)temp, post, 2352L);
    }
  } else {
    {
#line 2175
    c_append(root->vector, (int16_t *)temp, 2352L);
#line 2176
    free(temp);
    }
  }
  {
#line 2179
  root->returnedlimit = re(root);
  }
#line 2181
  return;
}
}
#line 2230 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/paranoia/paranoia.c"
static void cdrom_cache_update___0(cdrom_paranoia *p___0 , int lba , int sectors ) 
{ 
  int end ;

  {
#line 2232
  if (lba + sectors > p___0->cdcache_size) {
#line 2233
    end = lba + sectors;
#line 2234
    lba = end - p___0->cdcache_size;
#line 2235
    sectors = end - lba;
  }
#line 2238
  if (lba < p___0->cdcache_begin) {
#line 2240
    p___0->cdcache_begin = lba;
#line 2241
    p___0->cdcache_end = lba + sectors;
  } else {
#line 2243
    if (lba + sectors > p___0->cdcache_end) {
#line 2244
      p___0->cdcache_end = lba + sectors;
    }
#line 2245
    if ((lba + sectors) - p___0->cdcache_size > p___0->cdcache_begin) {
#line 2246
      if ((lba + sectors) - p___0->cdcache_size < p___0->cdcache_end) {
#line 2247
        p___0->cdcache_begin = (lba + sectors) - p___0->cdcache_size;
      } else {
#line 2249
        p___0->cdcache_begin = lba;
      }
    }
  }
#line 2253
  return;
}
}
#line 2255 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/paranoia/paranoia.c"
static void cdrom_cache_handler___0(cdrom_paranoia *p___0 , int lba , void (*callback___0)(long  ,
                                                                                           int  ) ) 
{ 
  int seekpos ;
  int ms ;
  long tmp___0 ;
  int pre ;
  int post ;
  long tmp___2 ;
  long tmp___3 ;

  {
#line 2258
  if (lba >= p___0->cdcache_end) {
#line 2258
    return;
  }
#line 2260
  if (lba < 0) {
#line 2260
    lba = 0;
  }
#line 2262
  if (lba < p___0->cdcache_begin) {
#line 2264
    if (lba == 0) {
#line 2264
      seekpos = lba;
    } else {
      {
#line 2264
      tmp___0 = cdda_disc_firstsector(p___0->d);
      }
#line 2264
      if ((long )(lba - 1) < tmp___0) {
#line 2264
        seekpos = lba;
      } else {
#line 2264
        seekpos = lba - 1;
      }
    }
  } else {
    {
#line 2266
    pre = p___0->cdcache_begin - 1;
#line 2267
    post = lba + p___0->cdcache_size;
#line 2269
    tmp___2 = cdda_disc_firstsector(p___0->d);
    }
#line 2269
    if ((long )pre < tmp___2) {
#line 2269
      seekpos = post;
    } else {
#line 2269
      seekpos = pre;
    }
  }
  {
#line 2272
  tmp___3 = cdda_read_timed(p___0->d, (void *)0, (long )seekpos, 1L, & ms);
  }
#line 2272
  if (tmp___3 == 1L) {
#line 2273
    if (seekpos < p___0->cdcache_begin) {
#line 2273
      if (ms < 6) {
        {
#line 2274
        (*callback___0)((long )(seekpos * 1176), 13);
        }
      }
    }
  }
  {
#line 2275
  cdrom_cache_update___0(p___0, seekpos, 1);
  }
#line 2276
  return;
}
}
#line 109 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/utils.h"
static void cderror___10(cdrom_drive *d___0 , char const   *s ) 
{ 
  size_t tmp ;

  {
#line 110
  if (s) {
#line 110
    if (d___0) {
      {
#line 112
      if (d___0->errordest == 1) {
#line 112
        goto case_1;
      }
#line 115
      if (d___0->errordest == 2) {
#line 115
        goto case_2;
      }
#line 119
      goto switch_default;
      case_1: /* CIL Label */ 
      {
#line 113
      tmp = strlen(s);
#line 113
      write(2, (void const   *)s, tmp);
      }
#line 114
      goto switch_break;
      case_2: /* CIL Label */ 
      {
#line 116
      d___0->errorbuf = catstring(d___0->errorbuf, s);
      }
#line 117
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 120
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
  }
#line 123
  return;
}
}
#line 107 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/paranoia/isort.c"
static void sort_sort___0(sort_info *i , long sortlo , long sorthi ) 
{ 
  long j ;
  sort_link **hv ;
  sort_link *l ;

  {
#line 114
  j = sorthi - 1L;
  {
#line 114
  while (1) {
    while_continue: /* CIL Label */ ;
#line 114
    if (! (j >= sortlo)) {
#line 114
      goto while_break;
    }
#line 127
    hv = (i->head + (int )*(i->vector + j)) + 32768;
#line 128
    l = i->revindex + j;
#line 134
    if ((unsigned long )*hv == (unsigned long )((void *)0)) {
#line 135
      *(i->bucketusage + i->lastbucket) = (long )((int )*(i->vector + j) + 32768);
#line 136
      (i->lastbucket) ++;
    }
#line 142
    l->next = *hv;
#line 143
    *hv = l;
#line 114
    j --;
  }
  while_break: /* CIL Label */ ;
  }
#line 148
  i->sortbegin = 0L;
#line 149
  return;
}
}
#line 109 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/utils.h"
static void cderror___11(cdrom_drive *d___0 , char const   *s ) 
{ 
  size_t tmp ;

  {
#line 110
  if (s) {
#line 110
    if (d___0) {
      {
#line 112
      if (d___0->errordest == 1) {
#line 112
        goto case_1;
      }
#line 115
      if (d___0->errordest == 2) {
#line 115
        goto case_2;
      }
#line 119
      goto switch_default;
      case_1: /* CIL Label */ 
      {
#line 113
      tmp = strlen(s);
#line 113
      write(2, (void const   *)s, tmp);
      }
#line 114
      goto switch_break;
      case_2: /* CIL Label */ 
      {
#line 116
      d___0->errorbuf = catstring(d___0->errorbuf, s);
      }
#line 117
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 120
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
  }
#line 123
  return;
}
}
#line 21 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/interface.c"
static void _clean_messages___2(cdrom_drive *d___0 ) 
{ 


  {
#line 22
  if (d___0) {
#line 23
    if (d___0->messagebuf) {
      {
#line 23
      free((void *)d___0->messagebuf);
      }
    }
#line 24
    if (d___0->errorbuf) {
      {
#line 24
      free((void *)d___0->errorbuf);
      }
    }
#line 25
    d___0->messagebuf = (char *)((void *)0);
#line 26
    d___0->errorbuf = (char *)((void *)0);
  }
#line 28
  return;
}
}
#line 109 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/utils.h"
static void cderror___12(cdrom_drive *d___0 , char const   *s ) 
{ 
  size_t tmp ;

  {
#line 110
  if (s) {
#line 110
    if (d___0) {
      {
#line 112
      if (d___0->errordest == 1) {
#line 112
        goto case_1;
      }
#line 115
      if (d___0->errordest == 2) {
#line 115
        goto case_2;
      }
#line 119
      goto switch_default;
      case_1: /* CIL Label */ 
      {
#line 113
      tmp = strlen(s);
#line 113
      write(2, (void const   *)s, tmp);
      }
#line 114
      goto switch_break;
      case_2: /* CIL Label */ 
      {
#line 116
      d___0->errorbuf = catstring(d___0->errorbuf, s);
      }
#line 117
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 120
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
  }
#line 123
  return;
}
}
#line 163 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/cdda_interface.h"
static char *strerror_tr___2[12]  = 
#line 163 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/cdda_interface.h"
  {      (char *)"Success",      (char *)"Error writing packet command to device",      (char *)"Error reading command from device",      (char *)"SCSI packet data underrun (too little data)", 
        (char *)"SCSI packet data overrun (too much data)",      (char *)"Illegal SCSI request (rejected by target)",      (char *)"Medium reading data from medium",      (char *)"Device busy", 
        (char *)"Device not ready",      (char *)"Target hardware fault",      (char *)"Unspecified error",      (char *)"Drive lost streaming"};
#line 109 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/utils.h"
static void cderror___13(cdrom_drive *d___0 , char const   *s ) 
{ 
  size_t tmp ;

  {
#line 110
  if (s) {
#line 110
    if (d___0) {
      {
#line 112
      if (d___0->errordest == 1) {
#line 112
        goto case_1;
      }
#line 115
      if (d___0->errordest == 2) {
#line 115
        goto case_2;
      }
#line 119
      goto switch_default;
      case_1: /* CIL Label */ 
      {
#line 113
      tmp = strlen(s);
#line 113
      write(2, (void const   *)s, tmp);
      }
#line 114
      goto switch_break;
      case_2: /* CIL Label */ 
      {
#line 116
      d___0->errorbuf = catstring(d___0->errorbuf, s);
      }
#line 117
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 120
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
  }
#line 123
  return;
}
}
#line 125 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/utils.h"
static void cdmessage___8(cdrom_drive *d___0 , char const   *s ) 
{ 
  size_t tmp ;

  {
#line 126
  if (s) {
#line 126
    if (d___0) {
      {
#line 128
      if (d___0->messagedest == 1) {
#line 128
        goto case_1;
      }
#line 131
      if (d___0->messagedest == 2) {
#line 131
        goto case_2;
      }
#line 135
      goto switch_default;
      case_1: /* CIL Label */ 
      {
#line 129
      tmp = strlen(s);
#line 129
      write(2, (void const   *)s, tmp);
      }
#line 130
      goto switch_break;
      case_2: /* CIL Label */ 
      {
#line 132
      d___0->messagebuf = catstring(d___0->messagebuf, s);
      }
#line 133
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 136
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
  }
#line 139
  return;
}
}
#line 20 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
static int timed_ioctl___5(cdrom_drive *d___0 , int fd , int command , void *arg ) 
{ 
  struct timespec tv1 ;
  struct timespec tv2 ;
  int ret1 ;
  int tmp ;
  int ret2 ;
  int tmp___0 ;
  int ret3 ;
  int tmp___1 ;

  {
  {
#line 23
  tmp = clock_gettime((d___0->private_data)->clock, & tv1);
#line 23
  ret1 = tmp;
#line 24
  tmp___0 = ioctl(fd, (unsigned long )command, arg);
#line 24
  ret2 = tmp___0;
#line 25
  tmp___1 = clock_gettime((d___0->private_data)->clock, & tv2);
#line 25
  ret3 = tmp___1;
  }
#line 26
  if (ret1 < 0) {
#line 27
    (d___0->private_data)->last_milliseconds = -1;
  } else
#line 26
  if (ret3 < 0) {
#line 27
    (d___0->private_data)->last_milliseconds = -1;
  } else {
#line 29
    (d___0->private_data)->last_milliseconds = (int )((double )(tv2.tv_sec - tv1.tv_sec) * 1000. + (double )(tv2.tv_nsec - tv1.tv_nsec) / 1000000.);
  }
#line 31
  return (ret2);
}
}
#line 35 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
static int Dummy___5(cdrom_drive *d___0 , int s ) 
{ 


  {
#line 36
  return (0);
}
}
#line 24 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/drive_exceptions.h"
static exception atapi_list___5[5]  = {      {(char *)"SAMSUNG SCR-830 REV 2.09 2.09 ", 1, (unsigned char)0, & Dummy___5,
      & scsi_read_mmc2, 0}, 
        {(char *)"Memorex CR-622", 1, (unsigned char)0, & Dummy___5, (long (*)(struct cdrom_drive * ,
                                                                            void * ,
                                                                            long  ,
                                                                            long  ))((void *)0),
      0}, 
        {(char *)"SONY CD-ROM CDU-561", 0, (unsigned char)0, & Dummy___5, (long (*)(struct cdrom_drive * ,
                                                                                 void * ,
                                                                                 long  ,
                                                                                 long  ))((void *)0),
      0}, 
        {(char *)"Chinon CD-ROM CDS-525", 0, (unsigned char)0, & Dummy___5, (long (*)(struct cdrom_drive * ,
                                                                                   void * ,
                                                                                   long  ,
                                                                                   long  ))((void *)0),
      0}, 
        {(char *)((void *)0), 0, (unsigned char)0, (int (*)(struct cdrom_drive * , int  ))((void *)0),
      (long (*)(struct cdrom_drive * , void * , long  , long  ))((void *)0), 0}};
#line 33 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/drive_exceptions.h"
static exception mmc_list___2[6]  = {      {(char *)"SAMSUNG SCR-830 REV 2.09 2.09 ", 1, (unsigned char)0, & Dummy___5,
      & scsi_read_mmc2, 0}, 
        {(char *)"Memorex CR-622", 1, (unsigned char)0, & Dummy___5, (long (*)(struct cdrom_drive * ,
                                                                            void * ,
                                                                            long  ,
                                                                            long  ))((void *)0),
      0}, 
        {(char *)"SONY CD-ROM CDU-561", 0, (unsigned char)0, & Dummy___5, (long (*)(struct cdrom_drive * ,
                                                                                 void * ,
                                                                                 long  ,
                                                                                 long  ))((void *)0),
      0}, 
        {(char *)"Chinon CD-ROM CDS-525", 0, (unsigned char)0, & Dummy___5, (long (*)(struct cdrom_drive * ,
                                                                                   void * ,
                                                                                   long  ,
                                                                                   long  ))((void *)0),
      0}, 
        {(char *)"KENWOOD CD-ROM UCR", -1, (unsigned char)0, (int (*)(struct cdrom_drive * ,
                                                                   int  ))((void *)0),
      & scsi_read_D8, 0}, 
        {(char *)((void *)0), 0, (unsigned char)0, (int (*)(struct cdrom_drive * , int  ))((void *)0),
      (long (*)(struct cdrom_drive * , void * , long  , long  ))((void *)0), 0}};
#line 43 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/drive_exceptions.h"
static exception scsi_list___2[18]  = 
#line 43
  {      {(char *)"TOSHIBA", -1, (unsigned char)130, & scsi_enable_cdda, & scsi_read_28,
      0}, 
        {(char *)"IBM", -1, (unsigned char)130, & scsi_enable_cdda, & scsi_read_28, 0}, 
        {(char *)"DEC",
      -1, (unsigned char)130, & scsi_enable_cdda, & scsi_read_28, 0}, 
        {(char *)"IMS", -1, (unsigned char)0, & scsi_enable_cdda, & scsi_read_28, 1}, 
        {(char *)"KODAK",
      -1, (unsigned char)0, & scsi_enable_cdda, & scsi_read_28, 1}, 
        {(char *)"RICOH", -1, (unsigned char)0, & scsi_enable_cdda, & scsi_read_28, 1}, 
        {(char *)"HP",
      -1, (unsigned char)0, & scsi_enable_cdda, & scsi_read_28, 1}, 
        {(char *)"PHILIPS", -1, (unsigned char)0, & scsi_enable_cdda, & scsi_read_28,
      1}, 
        {(char *)"PLASMON", -1, (unsigned char)0, & scsi_enable_cdda, & scsi_read_28,
      1}, 
        {(char *)"GRUNDIG CDR100IPW", -1, (unsigned char)0, & scsi_enable_cdda, & scsi_read_28,
      1}, 
        {(char *)"MITSUMI CD-R ", -1, (unsigned char)0, & scsi_enable_cdda, & scsi_read_28,
      1}, 
        {(char *)"KENWOOD CD-ROM UCR", -1, (unsigned char)0, (int (*)(struct cdrom_drive * ,
                                                                   int  ))((void *)0),
      & scsi_read_D8, 0}, 
        {(char *)"YAMAHA", -1, (unsigned char)0, & scsi_enable_cdda, (long (*)(struct cdrom_drive * ,
                                                                            void * ,
                                                                            long  ,
                                                                            long  ))((void *)0),
      0}, 
        {(char *)"PLEXTOR", -1, (unsigned char)0, (int (*)(struct cdrom_drive * , int  ))((void *)0),
      (long (*)(struct cdrom_drive * , void * , long  , long  ))((void *)0), 0}, 
        {(char *)"SONY", -1, (unsigned char)0, (int (*)(struct cdrom_drive * , int  ))((void *)0),
      (long (*)(struct cdrom_drive * , void * , long  , long  ))((void *)0), 0}, 
        {(char *)"NEC", -1, (unsigned char)0, (int (*)(struct cdrom_drive * , int  ))((void *)0),
      & scsi_read_D4_10, 0}, 
        {(char *)"MATSHITA CD-R   CW-7501", -1, (unsigned char)0, (int (*)(struct cdrom_drive * ,
                                                                        int  ))((void *)0),
      & scsi_read_D4_12, -1}, 
        {(char *)((void *)0), 0, (unsigned char)0, (int (*)(struct cdrom_drive * , int  ))((void *)0),
      (long (*)(struct cdrom_drive * , void * , long  , long  ))((void *)0), 0}};
#line 40 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
static void tweak_SG_buffer___2(cdrom_drive *d___0 ) 
{ 
  int table ;
  int reserved ;
  int cur ;
  int err ;
  char buffer[256] ;
  int tmp ;
  char *tmp___0 ;

  {
#line 52
  cur = 1;
  {
#line 53
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 54
    cur <<= 1;
#line 54
    reserved = cur * (1 << 9);
#line 55
    err = ioctl(d___0->cdda_fd, 8821UL, & reserved);
    }
#line 53
    if (err >= 0) {
#line 53
      if (! (cur * (1 << 9) < 1073741824)) {
#line 53
        goto while_break;
      }
    } else {
#line 53
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 57
  ioctl(d___0->cdda_fd, 8818UL, & reserved);
#line 61
  tmp = ioctl(d___0->cdda_fd, 8831UL, & table);
  }
#line 61
  if (tmp < 0) {
#line 62
    table = 1;
  }
  {
#line 64
  sprintf((char */* __restrict  */)(buffer), (char const   */* __restrict  */)"\tDMA scatter/gather table entries: %d\n\ttable entry size: %d bytes\n\tmaximum theoretical transfer: %d sectors\n",
          table, reserved, table * (reserved / 2352));
#line 69
  cdmessage___8(d___0, (char const   *)(buffer));
#line 71
  cur = reserved;
#line 85
  tmp___0 = getenv("CDDA_IGNORE_BUFSIZE_LIMIT");
  }
#line 85
  if (tmp___0) {
    {
#line 88
    cdmessage___8(d___0, "\tEnvironment variable CDDA_IGNORE_BUFSIZE_LIMIT set,\n\t\tforcing maximum possible sector size.  This can break\n\t\tspectacularly; use with caution!\n");
    }
  } else
#line 86
  if (cur > 65536) {
#line 86
    cur = 65536;
  } else {
#line 86
    cur = cur;
  }
  {
#line 92
  d___0->nsectors = cur / 2352;
#line 93
  d___0->bigbuff = (long )cur;
#line 95
  sprintf((char */* __restrict  */)(buffer), (char const   */* __restrict  */)"\tSetting default read size to %d sectors (%d bytes).\n\n",
          d___0->nsectors, d___0->nsectors * 2352);
  }
#line 98
  if (cur == 0) {
    {
#line 98
    exit(1);
    }
  }
  {
#line 108
  cdmessage___8(d___0, (char const   *)(buffer));
  }
#line 109
  return;
}
}
#line 113 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
static void clear_garbage___2(cdrom_drive *d___0 ) 
{ 
  fd_set fdset ;
  struct timeval tv ;
  struct sg_header *sg_hd ;
  int flag ;
  int __d0 ;
  int __d1 ;
  int __d0___0 ;
  int __d1___0 ;
  int tmp ;

  {
#line 116
  sg_hd = (d___0->private_data)->sg_hd;
#line 117
  flag = 0;
  {
#line 120
  while (1) {
    while_continue: /* CIL Label */ ;
#line 120
    __asm__  volatile   ("cld; rep; "
                         "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                         "1" (& fdset.__fds_bits[0]): "memory");
#line 120
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 121
  fdset.__fds_bits[d___0->cdda_fd / (8 * (int )sizeof(__fd_mask ))] |= 1L << d___0->cdda_fd % (8 * (int )sizeof(__fd_mask ));
#line 122
  tv.tv_sec = (__time_t )0;
#line 123
  tv.tv_usec = (__suseconds_t )0;
  {
#line 126
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 126
    tmp = select(d___0->cdda_fd + 1, (fd_set */* __restrict  */)(& fdset), (fd_set */* __restrict  */)((void *)0),
                 (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)(& tv));
    }
#line 126
    if (! (tmp == 1)) {
#line 126
      goto while_break___0;
    }
    {
#line 128
    sg_hd->twelve_byte = 0U;
#line 129
    sg_hd->result = 0;
#line 130
    sg_hd->reply_len = (int )sizeof(struct sg_header );
#line 131
    read(d___0->cdda_fd, (void *)sg_hd, (size_t )1);
    }
    {
#line 134
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 134
      __asm__  volatile   ("cld; rep; "
                           "stosq": "=c" (__d0___0), "=D" (__d1___0): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                           "1" (& fdset.__fds_bits[0]): "memory");
#line 134
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 135
    fdset.__fds_bits[d___0->cdda_fd / (8 * (int )sizeof(__fd_mask ))] |= 1L << d___0->cdda_fd % (8 * (int )sizeof(__fd_mask ));
#line 136
    tv.tv_sec = (__time_t )0;
#line 137
    tv.tv_usec = (__suseconds_t )0;
#line 138
    if (! flag) {
#line 138
      if (d___0->report_all) {
        {
#line 139
        cdmessage___8(d___0, "Clearing previously returned data from SCSI buffer\n");
        }
      }
    }
#line 140
    flag = 1;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 142
  return;
}
}
#line 145 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
static int check_sbp_error___2(unsigned char const   status , unsigned char const   *sbp ) 
{ 
  char key ;
  char ASC ;
  char ASCQ ;
  int *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  int *tmp___5 ;
  int *tmp___6 ;
  int *tmp___7 ;
  int *tmp___8 ;
  int *tmp___9 ;
  int *tmp___10 ;
  int *tmp___11 ;

  {
#line 147
  key = (char )((int const   )*(sbp + 2) & 15);
#line 148
  ASC = (char )*(sbp + 12);
#line 149
  ASCQ = (char )*(sbp + 13);
#line 151
  if ((int const   )status == 0) {
#line 151
    return (0);
  }
#line 152
  if ((int const   )status == 8) {
#line 152
    return (7);
  }
#line 154
  if (*(sbp + 0)) {
    {
#line 156
    if ((int )key == 0) {
#line 156
      goto case_0;
    }
#line 160
    if ((int )key == 1) {
#line 160
      goto case_1;
    }
#line 162
    if ((int )key == 2) {
#line 162
      goto case_2;
    }
#line 169
    if ((int )key == 3) {
#line 169
      goto case_3;
    }
#line 180
    if ((int )key == 4) {
#line 180
      goto case_4;
    }
#line 184
    if ((int )key == 5) {
#line 184
      goto case_5;
    }
#line 188
    goto switch_default;
    case_0: /* CIL Label */ 
    {
#line 157
    tmp___0 = __errno_location();
    }
#line 157
    if (*tmp___0 == 0) {
      {
#line 158
      tmp = __errno_location();
#line 158
      *tmp = 5;
      }
    }
#line 159
    return (10);
    case_1: /* CIL Label */ 
#line 161
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 164
    tmp___1 = __errno_location();
#line 164
    *tmp___1 = 123;
    }
#line 168
    return (8);
    case_3: /* CIL Label */ 
#line 170
    if (((int )ASC == 12) & ((int )ASCQ == 9)) {
      {
#line 172
      tmp___3 = __errno_location();
      }
#line 172
      if (*tmp___3 == 0) {
        {
#line 173
        tmp___2 = __errno_location();
#line 173
        *tmp___2 = 5;
        }
      }
#line 174
      return (11);
    } else {
      {
#line 176
      tmp___5 = __errno_location();
      }
#line 176
      if (*tmp___5 == 0) {
        {
#line 177
        tmp___4 = __errno_location();
#line 177
        *tmp___4 = 5;
        }
      }
#line 178
      return (6);
    }
    case_4: /* CIL Label */ 
    {
#line 181
    tmp___7 = __errno_location();
    }
#line 181
    if (*tmp___7 == 0) {
      {
#line 182
      tmp___6 = __errno_location();
#line 182
      *tmp___6 = 5;
      }
    }
#line 183
    return (9);
    case_5: /* CIL Label */ 
    {
#line 185
    tmp___9 = __errno_location();
    }
#line 185
    if (*tmp___9 == 0) {
      {
#line 186
      tmp___8 = __errno_location();
#line 186
      *tmp___8 = 22;
      }
    }
#line 187
    return (5);
    switch_default: /* CIL Label */ 
    {
#line 189
    tmp___11 = __errno_location();
    }
#line 189
    if (*tmp___11 == 0) {
      {
#line 190
      tmp___10 = __errno_location();
#line 190
      *tmp___10 = 5;
      }
    }
#line 191
    return (10);
    switch_break: /* CIL Label */ ;
    }
  }
#line 194
  return (0);
}
}
#line 199 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
static int sg2_handle_scsi_cmd___2(cdrom_drive *d___0 , unsigned char *cmd , unsigned int cmd_len ,
                                   unsigned int in_size , unsigned int out_size ,
                                   unsigned char bytefill , int bytecheck , unsigned char *sense_buffer ) 
{ 
  struct timespec tv1 ;
  struct timespec tv2 ;
  int tret1 ;
  int tret2 ;
  int status ;
  struct sg_header *sg_hd ;
  long writebytes ;
  fd_set fdset ;
  struct timeval tv ;
  int __d0 ;
  int __d1 ;
  int ret ;
  int tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  ssize_t tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  fd_set rset ;
  struct timeval tv___0 ;
  int __d0___0 ;
  int __d1___0 ;
  int ret___0 ;
  int tmp___5 ;
  int *tmp___6 ;
  int *tmp___7 ;
  ssize_t tmp___8 ;
  int *tmp___9 ;
  int *tmp___10 ;
  long i ;
  long flag ;
  int *tmp___11 ;
  int *tmp___12 ;

  {
  {
#line 210
  status = 0;
#line 211
  sg_hd = (d___0->private_data)->sg_hd;
#line 212
  writebytes = (long )((sizeof(struct sg_header ) + (unsigned long )cmd_len) + (unsigned long )in_size);
#line 217
  clear_garbage___2(d___0);
#line 219
  memset((void *)sg_hd, 0, sizeof(sg_hd));
#line 220
  memset((void *)sense_buffer, 0, (size_t )16);
#line 221
  memcpy((void */* __restrict  */)(d___0->private_data)->sg_buffer, (void const   */* __restrict  */)cmd,
         (size_t )(cmd_len + in_size));
#line 222
  sg_hd->twelve_byte = (unsigned int )(cmd_len == 12U);
#line 223
  sg_hd->result = 0;
#line 224
  sg_hd->reply_len = (int )(sizeof(struct sg_header ) + (unsigned long )out_size);
  }
#line 234
  if (bytecheck) {
#line 234
    if (out_size > in_size) {
      {
#line 235
      memset((void *)(((d___0->private_data)->sg_buffer + cmd_len) + in_size), (int )bytefill,
             (size_t )(out_size - in_size));
#line 238
      writebytes += (long )(out_size - in_size);
      }
    }
  }
  {
#line 249
  while (1) {
    while_continue: /* CIL Label */ ;
#line 249
    __asm__  volatile   ("cld; rep; "
                         "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                         "1" (& fdset.__fds_bits[0]): "memory");
#line 249
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 250
  fdset.__fds_bits[d___0->cdda_fd / (8 * (int )sizeof(__fd_mask ))] |= 1L << d___0->cdda_fd % (8 * (int )sizeof(__fd_mask ));
#line 251
  tv.tv_sec = (__time_t )60;
#line 254
  tv.tv_usec = (__suseconds_t )0;
  {
#line 256
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 257
    tmp = select(d___0->cdda_fd + 1, (fd_set */* __restrict  */)((void *)0), (fd_set */* __restrict  */)(& fdset),
                 (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)(& tv));
#line 257
    ret = tmp;
    }
#line 258
    if (ret > 0) {
#line 258
      goto while_break___0;
    }
#line 259
    if (ret < 0) {
      {
#line 259
      tmp___0 = __errno_location();
      }
#line 259
      if (*tmp___0 != 4) {
#line 259
        goto while_break___0;
      }
    }
#line 260
    if (ret == 0) {
      {
#line 261
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\nSCSI transport error: timeout waiting to write packet\n\n");
      }
#line 263
      return (1);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 268
  sigprocmask(0, (sigset_t const   */* __restrict  */)(& d___0->sigset), (sigset_t */* __restrict  */)((void *)0));
#line 269
  tret1 = clock_gettime((d___0->private_data)->clock, & tv1);
#line 270
  tmp___1 = __errno_location();
#line 270
  *tmp___1 = 0;
#line 271
  tmp___2 = write(d___0->cdda_fd, (void const   *)sg_hd, (size_t )writebytes);
#line 271
  status = (int )tmp___2;
  }
#line 273
  if (status < 0) {
#line 273
    goto _L;
  } else
#line 273
  if ((long )status != writebytes) {
    _L: /* CIL Label */ 
    {
#line 274
    sigprocmask(1, (sigset_t const   */* __restrict  */)(& d___0->sigset), (sigset_t */* __restrict  */)((void *)0));
#line 275
    tmp___4 = __errno_location();
    }
#line 275
    if (*tmp___4 == 0) {
      {
#line 275
      tmp___3 = __errno_location();
#line 275
      *tmp___3 = 5;
      }
    }
#line 276
    return (1);
  }
  {
#line 289
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 289
    __asm__  volatile   ("cld; rep; "
                         "stosq": "=c" (__d0___0), "=D" (__d1___0): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                         "1" (& rset.__fds_bits[0]): "memory");
#line 289
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 290
  rset.__fds_bits[d___0->cdda_fd / (8 * (int )sizeof(__fd_mask ))] |= 1L << d___0->cdda_fd % (8 * (int )sizeof(__fd_mask ));
#line 291
  tv___0.tv_sec = (__time_t )60;
#line 294
  tv___0.tv_usec = (__suseconds_t )0;
  {
#line 296
  while (1) {
    while_continue___2: /* CIL Label */ ;
    {
#line 297
    tmp___5 = select(d___0->cdda_fd + 1, (fd_set */* __restrict  */)(& rset), (fd_set */* __restrict  */)((void *)0),
                     (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)(& tv___0));
#line 297
    ret___0 = tmp___5;
    }
#line 298
    if (ret___0 < 0) {
      {
#line 298
      tmp___6 = __errno_location();
      }
#line 298
      if (*tmp___6 != 4) {
#line 298
        goto while_break___2;
      }
    }
#line 299
    if (ret___0 == 0) {
      {
#line 300
      sigprocmask(1, (sigset_t const   */* __restrict  */)(& d___0->sigset), (sigset_t */* __restrict  */)((void *)0));
#line 301
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\nSCSI transport error: timeout waiting to read packet\n\n");
      }
#line 303
      return (2);
    }
#line 305
    if (ret___0 > 0) {
#line 307
      if ((rset.__fds_bits[d___0->cdda_fd / (8 * (int )sizeof(__fd_mask ))] & (1L << d___0->cdda_fd % (8 * (int )sizeof(__fd_mask )))) != 0L) {
#line 307
        goto while_break___2;
      }
      {
#line 308
      sigprocmask(1, (sigset_t const   */* __restrict  */)(& d___0->sigset), (sigset_t */* __restrict  */)((void *)0));
#line 309
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\nSCSI transport: error reading packet\n\n");
      }
#line 310
      return (2);
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 315
  tret2 = clock_gettime((d___0->private_data)->clock, & tv2);
#line 316
  tmp___7 = __errno_location();
#line 316
  *tmp___7 = 0;
#line 317
  tmp___8 = read(d___0->cdda_fd, (void *)sg_hd, sizeof(struct sg_header ) + (unsigned long )out_size);
#line 317
  status = (int )tmp___8;
#line 318
  sigprocmask(1, (sigset_t const   */* __restrict  */)(& d___0->sigset), (sigset_t */* __restrict  */)((void *)0));
#line 319
  memcpy((void */* __restrict  */)sense_buffer, (void const   */* __restrict  */)(sg_hd->sense_buffer),
         (size_t )16);
  }
#line 321
  if (status < 0) {
#line 321
    return (status);
  }
#line 323
  if ((unsigned long )status != sizeof(struct sg_header ) + (unsigned long )out_size) {
#line 323
    goto _L___0;
  } else
#line 323
  if (sg_hd->result) {
    _L___0: /* CIL Label */ 
    {
#line 324
    tmp___10 = __errno_location();
    }
#line 324
    if (*tmp___10 == 0) {
      {
#line 324
      tmp___9 = __errno_location();
#line 324
      *tmp___9 = 5;
      }
    }
#line 325
    return (2);
  }
  {
#line 328
  status = check_sbp_error___2((unsigned char const   )sg_hd->target_status, (unsigned char const   *)sense_buffer);
  }
#line 329
  if (status) {
#line 329
    return (status);
  }
#line 336
  if (bytecheck) {
#line 336
    if (in_size + cmd_len < out_size) {
#line 337
      flag = 0L;
#line 338
      i = (long )in_size;
      {
#line 338
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 338
        if (! (i < (long )out_size)) {
#line 338
          goto while_break___3;
        }
#line 339
        if ((int )*((d___0->private_data)->sg_buffer + i) != (int )bytefill) {
#line 340
          flag = 1L;
#line 341
          goto while_break___3;
        }
#line 338
        i ++;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 344
      if (! flag) {
        {
#line 345
        tmp___11 = __errno_location();
#line 345
        *tmp___11 = 22;
        }
#line 346
        return (5);
      }
    }
  }
  {
#line 350
  tmp___12 = __errno_location();
#line 350
  *tmp___12 = 0;
  }
#line 351
  if (tret1 < 0) {
#line 352
    (d___0->private_data)->last_milliseconds = -1;
  } else
#line 351
  if (tret2 < 0) {
#line 352
    (d___0->private_data)->last_milliseconds = -1;
  } else {
#line 354
    (d___0->private_data)->last_milliseconds = (int )((tv2.tv_sec - tv1.tv_sec) * 1000L + (tv2.tv_nsec - tv1.tv_nsec) / 1000000L);
  }
#line 356
  return (0);
}
}
#line 359 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
static int sgio_handle_scsi_cmd___2(cdrom_drive *d___0 , unsigned char *cmd , unsigned int cmd_len ,
                                    unsigned int in_size , unsigned int out_size ,
                                    unsigned char bytefill , int bytecheck , unsigned char *sense ) 
{ 
  int status ;
  struct sg_io_hdr hdr ;
  int *tmp ;
  int *tmp___0 ;
  long i ;
  long flag ;
  int *tmp___1 ;
  int *tmp___2 ;

  {
  {
#line 368
  status = 0;
#line 371
  memset((void *)(& hdr), 0, sizeof(hdr));
#line 372
  memset((void *)sense, 0, sizeof(sense));
#line 373
  memcpy((void */* __restrict  */)(d___0->private_data)->sg_buffer, (void const   */* __restrict  */)(cmd + cmd_len),
         (size_t )in_size);
#line 375
  hdr.cmdp = cmd;
#line 376
  hdr.cmd_len = (unsigned char )cmd_len;
#line 377
  hdr.sbp = sense;
#line 378
  hdr.mx_sb_len = (unsigned char)16;
#line 379
  hdr.timeout = 50000U;
#line 380
  hdr.interface_id = 'S';
#line 381
  hdr.dxferp = (void *)(d___0->private_data)->sg_buffer;
#line 382
  hdr.flags = 1U;
  }
#line 385
  if (bytecheck) {
#line 385
    if (out_size > in_size) {
      {
#line 386
      memset(hdr.dxferp + in_size, (int )bytefill, (size_t )(out_size - in_size));
      }
    }
  }
#line 388
  if (in_size) {
    {
#line 389
    hdr.dxfer_len = in_size;
#line 390
    hdr.dxfer_direction = -2;
#line 392
    tmp = __errno_location();
#line 392
    *tmp = 0;
#line 393
    status = ioctl(d___0->ioctl_fd, 8837UL, & hdr);
    }
#line 394
    if (status >= 0) {
#line 394
      if (hdr.status) {
        {
#line 395
        status = check_sbp_error___2((unsigned char const   )hdr.status, (unsigned char const   *)hdr.sbp);
        }
#line 396
        if (status) {
#line 396
          return (status);
        }
      }
    }
#line 398
    if (status < 0) {
#line 398
      return (1);
    }
  }
#line 401
  if ((unsigned int )(! in_size) | out_size) {
#line 402
    hdr.dxfer_len = out_size;
#line 404
    if (bytecheck) {
#line 404
      if (d___0->interface != 4) {
#line 405
        if (out_size) {
#line 405
          hdr.dxfer_direction = -4;
        } else {
#line 405
          hdr.dxfer_direction = -1;
        }
      } else {
#line 404
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 407
    if (out_size) {
#line 407
      hdr.dxfer_direction = -3;
    } else {
#line 407
      hdr.dxfer_direction = -1;
    }
    {
#line 409
    tmp___0 = __errno_location();
#line 409
    *tmp___0 = 0;
#line 410
    status = timed_ioctl___5(d___0, d___0->ioctl_fd, 8837, (void *)(& hdr));
    }
#line 411
    if (status >= 0) {
#line 411
      if (hdr.status) {
        {
#line 412
        status = check_sbp_error___2((unsigned char const   )hdr.status, (unsigned char const   *)hdr.sbp);
        }
#line 413
        if (status) {
#line 413
          return (status);
        }
      }
    }
#line 415
    if (status < 0) {
#line 415
      return (status);
    }
  }
#line 423
  if (bytecheck) {
#line 423
    if (in_size < out_size) {
#line 424
      flag = 0L;
#line 425
      i = (long )in_size;
      {
#line 425
      while (1) {
        while_continue: /* CIL Label */ ;
#line 425
        if (! (i < (long )out_size)) {
#line 425
          goto while_break;
        }
#line 426
        if ((int )*((d___0->private_data)->sg_buffer + i) != (int )bytefill) {
#line 427
          flag = 1L;
#line 428
          goto while_break;
        }
#line 425
        i ++;
      }
      while_break: /* CIL Label */ ;
      }
#line 431
      if (! flag) {
        {
#line 432
        tmp___1 = __errno_location();
#line 432
        *tmp___1 = 22;
        }
#line 433
        return (5);
      }
    }
  }
  {
#line 440
  tmp___2 = __errno_location();
#line 440
  *tmp___2 = 0;
  }
#line 441
  return (0);
}
}
#line 444 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
static int handle_scsi_cmd___2(cdrom_drive *d___0 , unsigned char *cmd , unsigned int cmd_len ,
                               unsigned int in_size , unsigned int out_size , unsigned char bytefill ,
                               int bytecheck , unsigned char *sense ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 453
  if (d___0->interface == 3) {
    {
#line 454
    tmp = sgio_handle_scsi_cmd___2(d___0, cmd, cmd_len, in_size, out_size, bytefill,
                                   bytecheck, sense);
    }
#line 454
    return (tmp);
  } else
#line 453
  if (d___0->interface == 4) {
    {
#line 454
    tmp = sgio_handle_scsi_cmd___2(d___0, cmd, cmd_len, in_size, out_size, bytefill,
                                   bytecheck, sense);
    }
#line 454
    return (tmp);
  }
  {
#line 455
  tmp___0 = sg2_handle_scsi_cmd___2(d___0, cmd, cmd_len, in_size, out_size, bytefill,
                                    bytecheck, sense);
  }
#line 455
  return (tmp___0);
}
}
#line 544 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
static int test_unit_ready___2(cdrom_drive *d___0 ) 
{ 
  unsigned char sense[16] ;
  unsigned char key ;
  unsigned char ASC ;
  unsigned char ASCQ ;
  unsigned char cmd[6] ;

  {
  {
#line 547
  cmd[0] = (unsigned char)0;
#line 547
  cmd[1] = (unsigned char)0;
#line 547
  cmd[2] = (unsigned char)0;
#line 547
  cmd[3] = (unsigned char)0;
#line 547
  cmd[4] = (unsigned char)0;
#line 547
  cmd[5] = (unsigned char)0;
#line 554
  handle_scsi_cmd___2(d___0, cmd, 6U, 0U, 56U, (unsigned char)0, 0, sense);
#line 556
  key = (unsigned char )((int )*((d___0->private_data)->sg_buffer + 2) & 15);
#line 557
  ASC = *((d___0->private_data)->sg_buffer + 12);
#line 558
  ASCQ = *((d___0->private_data)->sg_buffer + 13);
  }
#line 560
  if ((int )key == 2) {
#line 560
    if ((int )ASC == 4) {
#line 560
      if ((int )ASCQ == 1) {
#line 560
        return (0);
      }
    }
  }
#line 561
  return (1);
}
}
#line 565 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
static void reset_scsi___2(cdrom_drive *d___0 ) 
{ 
  int arg ;
  int tries ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 566
  tries = 0;
#line 567
  (*(d___0->enable_cdda))(d___0, 0);
#line 569
  cdmessage___8(d___0, "sending SG SCSI reset... ");
#line 570
  tmp = ioctl(d___0->cdda_fd, 8836UL, & arg);
  }
#line 570
  if (tmp) {
    {
#line 571
    cdmessage___8(d___0, "FAILED: EBUSY\n");
    }
  } else {
    {
#line 573
    cdmessage___8(d___0, "OK\n");
    }
  }
  {
#line 575
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 576
    tmp___0 = test_unit_ready___2(d___0);
    }
#line 576
    if (tmp___0) {
#line 576
      goto while_break;
    }
    {
#line 577
    tries ++;
#line 578
    usleep((__useconds_t )10);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 581
  (*(d___0->enable_cdda))(d___0, 1);
  }
#line 582
  return;
}
}
#line 607 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
static int mode_sense_atapi___2(cdrom_drive *d___0 , int size , int page ) 
{ 
  unsigned char sense[16] ;
  unsigned char cmd[10] ;
  int tmp ;
  unsigned char *b ;

  {
  {
#line 609
  cmd[0] = (unsigned char)90;
#line 609
  cmd[1] = (unsigned char)0;
#line 609
  cmd[2] = (unsigned char)0;
#line 609
  cmd[3] = (unsigned char)0;
#line 609
  cmd[4] = (unsigned char)0;
#line 609
  cmd[5] = (unsigned char)0;
#line 609
  cmd[6] = (unsigned char)0;
#line 609
  cmd[7] = (unsigned char)0;
#line 609
  cmd[8] = (unsigned char)0;
#line 609
  cmd[9] = (unsigned char)0;
#line 620
  cmd[1] = (unsigned char )(d___0->lun << 5);
#line 621
  cmd[2] = (unsigned char )(63 & page);
#line 622
  cmd[8] = (unsigned char )(size + 4);
#line 624
  tmp = handle_scsi_cmd___2(d___0, cmd, 10U, 0U, (unsigned int )(size + 4), (unsigned char )'\377',
                            1, sense);
  }
#line 624
  if (tmp) {
#line 624
    return (1);
  }
#line 627
  b = (d___0->private_data)->sg_buffer;
#line 628
  if (*(b + 0)) {
#line 628
    return (1);
  }
#line 629
  if (*(b + 6)) {
#line 629
    return (1);
  }
  {
#line 631
  *(b + 0) = (unsigned char )((int )*(b + 1) - 3);
#line 632
  *(b + 1) = *(b + 2);
#line 633
  *(b + 2) = *(b + 3);
#line 634
  *(b + 3) = *(b + 7);
#line 636
  memmove((void *)(b + 4), (void const   *)(b + 8), (size_t )(size - 4));
  }
#line 638
  return (0);
}
}
#line 643 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
static int mode_sense_scsi___2(cdrom_drive *d___0 , int size , int page ) 
{ 
  unsigned char sense[16] ;
  unsigned char cmd[6] ;
  int tmp ;

  {
  {
#line 645
  cmd[0] = (unsigned char)26;
#line 645
  cmd[1] = (unsigned char)0;
#line 645
  cmd[2] = (unsigned char)0;
#line 645
  cmd[3] = (unsigned char)0;
#line 645
  cmd[4] = (unsigned char)0;
#line 645
  cmd[5] = (unsigned char)0;
#line 652
  cmd[1] = (unsigned char )(d___0->lun << 5);
#line 653
  cmd[2] = (unsigned char )(63 & page);
#line 654
  cmd[4] = (unsigned char )size;
#line 656
  tmp = handle_scsi_cmd___2(d___0, cmd, 6U, 0U, (unsigned int )size, (unsigned char )'\377',
                            1, sense);
  }
#line 656
  if (tmp) {
#line 656
    return (1);
  }
#line 661
  return (0);
}
}
#line 664 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
static int mode_sense___2(cdrom_drive *d___0 , int size , int page ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 665
  if (d___0->is_atapi) {
    {
#line 666
    tmp = mode_sense_atapi___2(d___0, size, page);
    }
#line 666
    return (tmp);
  }
  {
#line 667
  tmp___0 = mode_sense_scsi___2(d___0, size, page);
  }
#line 667
  return (tmp___0);
}
}
#line 674 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
static int mode_select___2(cdrom_drive *d___0 , int density , int secsize ) 
{ 
  unsigned char sense[16] ;
  unsigned char cmd[26] ;
  unsigned char *mode ;
  int tmp ;
  unsigned char cmd___0[18] ;
  unsigned char *mode___0 ;
  int tmp___0 ;

  {
#line 677
  if (d___0->is_atapi) {
    {
#line 678
    cmd[0] = (unsigned char)85;
#line 678
    cmd[1] = (unsigned char)16;
#line 678
    cmd[2] = (unsigned char)0;
#line 678
    cmd[3] = (unsigned char)0;
#line 678
    cmd[4] = (unsigned char)0;
#line 678
    cmd[5] = (unsigned char)0;
#line 678
    cmd[6] = (unsigned char)0;
#line 678
    cmd[7] = (unsigned char)0;
#line 678
    cmd[8] = (unsigned char)16;
#line 678
    cmd[9] = (unsigned char)0;
#line 678
    cmd[10] = (unsigned char)0;
#line 678
    cmd[11] = (unsigned char)0;
#line 678
    cmd[12] = (unsigned char)0;
#line 678
    cmd[13] = (unsigned char)0;
#line 678
    cmd[14] = (unsigned char)0;
#line 678
    cmd[15] = (unsigned char)0;
#line 678
    cmd[16] = (unsigned char)0;
#line 678
    cmd[17] = (unsigned char)8;
#line 678
    cmd[18] = (unsigned char)0;
#line 678
    cmd[19] = (unsigned char)0;
#line 678
    cmd[20] = (unsigned char)0;
#line 678
    cmd[21] = (unsigned char)0;
#line 678
    cmd[22] = (unsigned char)0;
#line 678
    cmd[23] = (unsigned char)0;
#line 678
    cmd[24] = (unsigned char)0;
#line 678
    cmd[25] = (unsigned char)0;
#line 698
    mode = cmd + 18;
#line 701
    *(mode + 0) = (unsigned char )density;
#line 702
    *(mode + 6) = (unsigned char )(secsize >> 8);
#line 703
    *(mode + 7) = (unsigned char )(secsize & 255);
#line 706
    tmp = handle_scsi_cmd___2(d___0, cmd, 10U, 16U, 0U, (unsigned char)0, 0, sense);
    }
#line 706
    return (tmp);
  } else {
    {
#line 709
    cmd___0[0] = (unsigned char)21;
#line 709
    cmd___0[1] = (unsigned char)16;
#line 709
    cmd___0[2] = (unsigned char)0;
#line 709
    cmd___0[3] = (unsigned char)0;
#line 709
    cmd___0[4] = (unsigned char)12;
#line 709
    cmd___0[5] = (unsigned char)0;
#line 709
    cmd___0[6] = (unsigned char)0;
#line 709
    cmd___0[7] = (unsigned char)0;
#line 709
    cmd___0[8] = (unsigned char)0;
#line 709
    cmd___0[9] = (unsigned char)8;
#line 709
    cmd___0[10] = (unsigned char)0;
#line 709
    cmd___0[11] = (unsigned char)0;
#line 709
    cmd___0[12] = (unsigned char)0;
#line 709
    cmd___0[13] = (unsigned char)0;
#line 709
    cmd___0[14] = (unsigned char)0;
#line 709
    cmd___0[15] = (unsigned char)0;
#line 709
    cmd___0[16] = (unsigned char)0;
#line 709
    cmd___0[17] = (unsigned char)0;
#line 723
    mode___0 = cmd___0 + 10;
#line 726
    *(mode___0 + 0) = (unsigned char )density;
#line 727
    *(mode___0 + 6) = (unsigned char )(secsize >> 8);
#line 728
    *(mode___0 + 7) = (unsigned char )(secsize & 255);
#line 731
    tmp___0 = handle_scsi_cmd___2(d___0, cmd___0, 6U, 12U, 0U, (unsigned char)0, 0,
                                  sense);
    }
#line 731
    return (tmp___0);
  }
}
}
#line 736 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
static unsigned int get_orig_sectorsize___2(cdrom_drive *d___0 ) 
{ 
  int tmp ;
  unsigned int tmp___0 ;

  {
  {
#line 737
  tmp = mode_sense___2(d___0, 12, 1);
  }
#line 737
  if (tmp) {
#line 737
    return (4294967295U);
  }
#line 739
  d___0->orgdens = *((d___0->private_data)->sg_buffer + 4);
#line 740
  tmp___0 = (unsigned int )(((int )*((d___0->private_data)->sg_buffer + 10) << 8) + (int )*((d___0->private_data)->sg_buffer + 11));
#line 740
  d___0->orgsize = tmp___0;
#line 740
  return (tmp___0);
}
}
#line 744 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
static int set_sectorsize___2(cdrom_drive *d___0 , unsigned int secsize ) 
{ 
  int tmp ;

  {
  {
#line 745
  tmp = mode_select___2(d___0, (int )d___0->orgdens, (int )secsize);
  }
#line 745
  return (tmp);
}
}
#line 782 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
static int scsi_read_toc___2(cdrom_drive *d___0 ) 
{ 
  int i ;
  int first ;
  int last___0 ;
  unsigned int tracks ;
  unsigned char sense[16] ;
  unsigned char cmd[10] ;
  int tmp ;
  char __constr_expr_9[10] ;
  int tmp___0 ;
  scsi_TOC *toc ;
  char __constr_expr_10[10] ;
  int tmp___1 ;
  scsi_TOC *toc___0 ;

  {
  {
#line 791
  cmd[0] = (unsigned char)67;
#line 791
  cmd[1] = (unsigned char)0;
#line 791
  cmd[2] = (unsigned char)0;
#line 791
  cmd[3] = (unsigned char)0;
#line 791
  cmd[4] = (unsigned char)0;
#line 791
  cmd[5] = (unsigned char)0;
#line 791
  cmd[6] = (unsigned char)1;
#line 791
  cmd[7] = (unsigned char)0;
#line 791
  cmd[8] = (unsigned char)12;
#line 791
  cmd[9] = (unsigned char)0;
#line 792
  cmd[1] = (unsigned char )(d___0->lun << 5);
#line 794
  tmp = handle_scsi_cmd___2(d___0, cmd, 10U, 0U, 12U, (unsigned char )'\377', 1, sense);
  }
#line 794
  if (tmp) {
    {
#line 795
    cderror___13(d___0, "004: Unable to read table of contents header\n");
    }
#line 796
    return (-4);
  }
#line 799
  first = (int )*((d___0->private_data)->sg_buffer + 2);
#line 800
  last___0 = (int )*((d___0->private_data)->sg_buffer + 3);
#line 801
  tracks = (unsigned int )((last___0 - first) + 1);
#line 803
  if (last___0 > 100) {
    {
#line 804
    cderror___13(d___0, "003: CDROM reporting illegal number of tracks\n");
    }
#line 805
    return (-3);
  } else
#line 803
  if (first > 100) {
    {
#line 804
    cderror___13(d___0, "003: CDROM reporting illegal number of tracks\n");
    }
#line 805
    return (-3);
  } else
#line 803
  if (last___0 < 0) {
    {
#line 804
    cderror___13(d___0, "003: CDROM reporting illegal number of tracks\n");
    }
#line 805
    return (-3);
  } else
#line 803
  if (first < 0) {
    {
#line 804
    cderror___13(d___0, "003: CDROM reporting illegal number of tracks\n");
    }
#line 805
    return (-3);
  }
#line 808
  i = first;
  {
#line 808
  while (1) {
    while_continue: /* CIL Label */ ;
#line 808
    if (! (i <= last___0)) {
#line 808
      goto while_break;
    }
    {
#line 809
    __constr_expr_9[0] = (char)67;
#line 809
    __constr_expr_9[1] = (char)0;
#line 809
    __constr_expr_9[2] = (char)0;
#line 809
    __constr_expr_9[3] = (char)0;
#line 809
    __constr_expr_9[4] = (char)0;
#line 809
    __constr_expr_9[5] = (char)0;
#line 809
    __constr_expr_9[6] = (char)0;
#line 809
    __constr_expr_9[7] = (char)0;
#line 809
    __constr_expr_9[8] = (char)12;
#line 809
    __constr_expr_9[9] = (char)0;
#line 809
    memcpy((void */* __restrict  */)(cmd), (void const   */* __restrict  */)(__constr_expr_9),
           (size_t )10);
#line 810
    cmd[1] = (unsigned char )(d___0->lun << 5);
#line 811
    cmd[6] = (unsigned char )i;
#line 813
    tmp___0 = handle_scsi_cmd___2(d___0, cmd, 10U, 0U, 12U, (unsigned char )'\377',
                                  1, sense);
    }
#line 813
    if (tmp___0) {
      {
#line 814
      cderror___13(d___0, "005: Unable to read table of contents entry\n");
      }
#line 815
      return (-5);
    }
#line 818
    toc = (scsi_TOC *)((d___0->private_data)->sg_buffer + 4);
#line 820
    d___0->disc_toc[i - first].bFlags = toc->bFlags;
#line 821
    d___0->disc_toc[i - first].bTrack = (unsigned char )i;
#line 822
    d___0->disc_toc[i - first].dwStartSector = d___0->adjust_ssize * (((((int )toc->start_MSB << 24) | ((int )toc->start_1 << 16)) | ((int )toc->start_2 << 8)) | (int )toc->start_LSB);
#line 808
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 830
  __constr_expr_10[0] = (char)67;
#line 830
  __constr_expr_10[1] = (char)0;
#line 830
  __constr_expr_10[2] = (char)0;
#line 830
  __constr_expr_10[3] = (char)0;
#line 830
  __constr_expr_10[4] = (char)0;
#line 830
  __constr_expr_10[5] = (char)0;
#line 830
  __constr_expr_10[6] = (char)0;
#line 830
  __constr_expr_10[7] = (char)0;
#line 830
  __constr_expr_10[8] = (char)12;
#line 830
  __constr_expr_10[9] = (char)0;
#line 830
  memcpy((void */* __restrict  */)(cmd), (void const   */* __restrict  */)(__constr_expr_10),
         (size_t )10);
#line 831
  cmd[1] = (unsigned char )(d___0->lun << 5);
#line 832
  cmd[6] = (unsigned char)170;
#line 834
  tmp___1 = handle_scsi_cmd___2(d___0, cmd, 10U, 0U, 12U, (unsigned char )'\377',
                                1, sense);
  }
#line 834
  if (tmp___1) {
    {
#line 835
    cderror___13(d___0, "002: Unable to read table of contents lead-out\n");
    }
#line 836
    return (-2);
  }
  {
#line 839
  toc___0 = (scsi_TOC *)((d___0->private_data)->sg_buffer + 4);
#line 841
  d___0->disc_toc[i - first].bFlags = toc___0->bFlags;
#line 842
  d___0->disc_toc[i - first].bTrack = (unsigned char)170;
#line 843
  d___0->disc_toc[i - first].dwStartSector = d___0->adjust_ssize * (((((int )toc___0->start_MSB << 24) | ((int )toc___0->start_1 << 16)) | ((int )toc___0->start_2 << 8)) | (int )toc___0->start_LSB);
#line 850
  d___0->cd_extra = FixupTOC(d___0, (int )(tracks + 1U));
  }
#line 851
  return ((int )tracks);
}
}
#line 856 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
static int scsi_read_toc2___2(cdrom_drive *d___0 ) 
{ 
  u_int32_t foo ;
  u_int32_t bar ;
  int i ;
  unsigned int tracks ;
  unsigned char cmd[10] ;
  unsigned char sense[16] ;
  int tmp ;
  char __constr_expr_11[10] ;
  int tmp___0 ;
  int32_t tmp___1 ;
  int32_t tmp___2 ;

  {
  {
#line 862
  cmd[0] = (unsigned char)229;
#line 862
  cmd[1] = (unsigned char)0;
#line 862
  cmd[2] = (unsigned char)0;
#line 862
  cmd[3] = (unsigned char)0;
#line 862
  cmd[4] = (unsigned char)0;
#line 862
  cmd[5] = (unsigned char)0;
#line 862
  cmd[6] = (unsigned char)0;
#line 862
  cmd[7] = (unsigned char)0;
#line 862
  cmd[8] = (unsigned char)0;
#line 862
  cmd[9] = (unsigned char)0;
#line 864
  cmd[5] = (unsigned char)1;
#line 865
  cmd[8] = (unsigned char)255;
#line 867
  tmp = handle_scsi_cmd___2(d___0, cmd, 10U, 0U, 256U, (unsigned char )'\377', 1,
                            sense);
  }
#line 867
  if (tmp) {
    {
#line 868
    cderror___13(d___0, "004: Unable to read table of contents header\n");
    }
#line 869
    return (-4);
  }
#line 873
  tracks = (unsigned int )*((d___0->private_data)->sg_buffer + 1);
#line 874
  if (tracks > 100U) {
    {
#line 875
    cderror___13(d___0, "003: CDROM reporting illegal number of tracks\n");
    }
#line 876
    return (-3);
  }
#line 879
  i = 0;
  {
#line 879
  while (1) {
    while_continue: /* CIL Label */ ;
#line 879
    if (! ((unsigned int )i < tracks)) {
#line 879
      goto while_break;
    }
    {
#line 880
    __constr_expr_11[0] = (char)-27;
#line 880
    __constr_expr_11[1] = (char)0;
#line 880
    __constr_expr_11[2] = (char)0;
#line 880
    __constr_expr_11[3] = (char)0;
#line 880
    __constr_expr_11[4] = (char)0;
#line 880
    __constr_expr_11[5] = (char)0;
#line 880
    __constr_expr_11[6] = (char)0;
#line 880
    __constr_expr_11[7] = (char)0;
#line 880
    __constr_expr_11[8] = (char)0;
#line 880
    __constr_expr_11[9] = (char)0;
#line 880
    memcpy((void */* __restrict  */)(cmd), (void const   */* __restrict  */)(__constr_expr_11),
           (size_t )10);
#line 881
    cmd[5] = (unsigned char )(i + 1);
#line 882
    cmd[8] = (unsigned char)255;
#line 884
    tmp___0 = handle_scsi_cmd___2(d___0, cmd, 10U, 0U, 256U, (unsigned char )'\377',
                                  1, sense);
    }
#line 884
    if (tmp___0) {
      {
#line 885
      cderror___13(d___0, "005: Unable to read table of contents entry\n");
      }
#line 886
      return (-5);
    }
#line 889
    d___0->disc_toc[i].bFlags = *((d___0->private_data)->sg_buffer + 10);
#line 890
    d___0->disc_toc[i].bTrack = (unsigned char )(i + 1);
#line 892
    d___0->disc_toc[i].dwStartSector = d___0->adjust_ssize * (((((int )((signed char )*((d___0->private_data)->sg_buffer + 2)) << 24) | ((int )*((d___0->private_data)->sg_buffer + 3) << 16)) | ((int )*((d___0->private_data)->sg_buffer + 4) << 8)) | (int )*((d___0->private_data)->sg_buffer + 5));
#line 879
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 899
  d___0->disc_toc[i].bFlags = (unsigned char)0;
#line 900
  d___0->disc_toc[i].bTrack = (unsigned char )(i + 1);
#line 901
  memcpy((void */* __restrict  */)(& foo), (void const   */* __restrict  */)((d___0->private_data)->sg_buffer + 2),
         (size_t )4);
#line 902
  memcpy((void */* __restrict  */)(& bar), (void const   */* __restrict  */)((d___0->private_data)->sg_buffer + 6),
         (size_t )4);
#line 903
  tmp___1 = be32_to_cpu((int32_t )foo);
#line 903
  tmp___2 = be32_to_cpu((int32_t )bar);
#line 903
  d___0->disc_toc[i].dwStartSector = d___0->adjust_ssize * (tmp___1 + tmp___2);
#line 906
  d___0->disc_toc[i].dwStartSector = d___0->adjust_ssize * ((((((int )((signed char )*((d___0->private_data)->sg_buffer + 2)) << 24) | ((int )*((d___0->private_data)->sg_buffer + 3) << 16)) | ((int )*((d___0->private_data)->sg_buffer + 4) << 8)) | (int )*((d___0->private_data)->sg_buffer + 5)) + (((((int )((signed char )*((d___0->private_data)->sg_buffer + 6)) << 24) | ((int )*((d___0->private_data)->sg_buffer + 7) << 16)) | ((int )*((d___0->private_data)->sg_buffer + 8) << 8)) | (int )*((d___0->private_data)->sg_buffer + 9)));
#line 918
  d___0->cd_extra = FixupTOC(d___0, (int )(tracks + 1U));
  }
#line 919
  return ((int )tracks);
}
}
#line 922 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
static int scsi_set_speed___2(cdrom_drive *d___0 , int speed ) 
{ 
  unsigned char cmd[12] ;
  unsigned char sense[16] ;
  int tmp ;

  {
#line 923
  cmd[0] = (unsigned char)187;
#line 923
  cmd[1] = (unsigned char)0;
#line 923
  cmd[2] = (unsigned char)0;
#line 923
  cmd[3] = (unsigned char)0;
#line 923
  cmd[4] = (unsigned char)255;
#line 923
  cmd[5] = (unsigned char)255;
#line 923
  cmd[6] = (unsigned char)0;
#line 923
  cmd[7] = (unsigned char)0;
#line 923
  cmd[8] = (unsigned char)0;
#line 923
  cmd[9] = (unsigned char)0;
#line 923
  cmd[10] = (unsigned char)0;
#line 923
  cmd[11] = (unsigned char)0;
#line 926
  if (speed >= 0) {
#line 927
    speed = ((speed * 44100) * 4) / 1024;
  } else {
#line 929
    speed = -1;
  }
  {
#line 930
  cmd[2] = (unsigned char )((speed >> 8) & 255);
#line 931
  cmd[3] = (unsigned char )(speed & 255);
#line 932
  tmp = handle_scsi_cmd___2(d___0, cmd, 12U, 0U, 0U, (unsigned char)0, 0, sense);
  }
#line 932
  return (tmp);
}
}
#line 937 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
static int i_read_28___2(cdrom_drive *d___0 , void *p___0 , long begin , long sectors ,
                         unsigned char *sense ) 
{ 
  int ret ;
  unsigned char cmd[10] ;

  {
#line 939
  cmd[0] = (unsigned char)40;
#line 939
  cmd[1] = (unsigned char)0;
#line 939
  cmd[2] = (unsigned char)0;
#line 939
  cmd[3] = (unsigned char)0;
#line 939
  cmd[4] = (unsigned char)0;
#line 939
  cmd[5] = (unsigned char)0;
#line 939
  cmd[6] = (unsigned char)0;
#line 939
  cmd[7] = (unsigned char)0;
#line 939
  cmd[8] = (unsigned char)0;
#line 939
  cmd[9] = (unsigned char)0;
#line 941
  if (d___0->fua) {
#line 942
    cmd[1] = (unsigned char)8;
  }
  {
#line 944
  cmd[1] = (unsigned char )((int )cmd[1] | (d___0->lun << 5));
#line 946
  cmd[3] = (unsigned char )((begin >> 16) & 255L);
#line 947
  cmd[4] = (unsigned char )((begin >> 8) & 255L);
#line 948
  cmd[5] = (unsigned char )(begin & 255L);
#line 949
  cmd[8] = (unsigned char )sectors;
#line 950
  ret = handle_scsi_cmd___2(d___0, cmd, 10U, 0U, (unsigned int )(sectors * 2352L),
                            (unsigned char )'\177', 1, sense);
  }
#line 950
  if (ret) {
#line 951
    return (ret);
  }
#line 952
  if (p___0) {
    {
#line 952
    memcpy((void */* __restrict  */)p___0, (void const   */* __restrict  */)(d___0->private_data)->sg_buffer,
           (size_t )(sectors * 2352L));
    }
  }
#line 953
  return (0);
}
}
#line 956 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
static int i_read_A8___2(cdrom_drive *d___0 , void *p___0 , long begin , long sectors ,
                         unsigned char *sense ) 
{ 
  int ret ;
  unsigned char cmd[12] ;

  {
#line 958
  cmd[0] = (unsigned char)168;
#line 958
  cmd[1] = (unsigned char)0;
#line 958
  cmd[2] = (unsigned char)0;
#line 958
  cmd[3] = (unsigned char)0;
#line 958
  cmd[4] = (unsigned char)0;
#line 958
  cmd[5] = (unsigned char)0;
#line 958
  cmd[6] = (unsigned char)0;
#line 958
  cmd[7] = (unsigned char)0;
#line 958
  cmd[8] = (unsigned char)0;
#line 958
  cmd[9] = (unsigned char)0;
#line 958
  cmd[10] = (unsigned char)0;
#line 958
  cmd[11] = (unsigned char)0;
#line 960
  if (d___0->fua) {
#line 961
    cmd[1] = (unsigned char)8;
  }
  {
#line 963
  cmd[1] = (unsigned char )((int )cmd[1] | (d___0->lun << 5));
#line 965
  cmd[3] = (unsigned char )((begin >> 16) & 255L);
#line 966
  cmd[4] = (unsigned char )((begin >> 8) & 255L);
#line 967
  cmd[5] = (unsigned char )(begin & 255L);
#line 968
  cmd[9] = (unsigned char )sectors;
#line 969
  ret = handle_scsi_cmd___2(d___0, cmd, 12U, 0U, (unsigned int )(sectors * 2352L),
                            (unsigned char )'\177', 1, sense);
  }
#line 969
  if (ret) {
#line 970
    return (ret);
  }
#line 971
  if (p___0) {
    {
#line 971
    memcpy((void */* __restrict  */)p___0, (void const   */* __restrict  */)(d___0->private_data)->sg_buffer,
           (size_t )(sectors * 2352L));
    }
  }
#line 972
  return (0);
}
}
#line 975 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
static int i_read_D4_10___2(cdrom_drive *d___0 , void *p___0 , long begin , long sectors ,
                            unsigned char *sense ) 
{ 
  int ret ;
  unsigned char cmd[10] ;

  {
#line 977
  cmd[0] = (unsigned char)212;
#line 977
  cmd[1] = (unsigned char)0;
#line 977
  cmd[2] = (unsigned char)0;
#line 977
  cmd[3] = (unsigned char)0;
#line 977
  cmd[4] = (unsigned char)0;
#line 977
  cmd[5] = (unsigned char)0;
#line 977
  cmd[6] = (unsigned char)0;
#line 977
  cmd[7] = (unsigned char)0;
#line 977
  cmd[8] = (unsigned char)0;
#line 977
  cmd[9] = (unsigned char)0;
#line 979
  if (d___0->fua) {
#line 980
    cmd[1] = (unsigned char)8;
  }
  {
#line 982
  cmd[1] = (unsigned char )((int )cmd[1] | (d___0->lun << 5));
#line 983
  cmd[3] = (unsigned char )((begin >> 16) & 255L);
#line 984
  cmd[4] = (unsigned char )((begin >> 8) & 255L);
#line 985
  cmd[5] = (unsigned char )(begin & 255L);
#line 986
  cmd[8] = (unsigned char )sectors;
#line 987
  ret = handle_scsi_cmd___2(d___0, cmd, 10U, 0U, (unsigned int )(sectors * 2352L),
                            (unsigned char )'\177', 1, sense);
  }
#line 987
  if (ret) {
#line 988
    return (ret);
  }
#line 989
  if (p___0) {
    {
#line 989
    memcpy((void */* __restrict  */)p___0, (void const   */* __restrict  */)(d___0->private_data)->sg_buffer,
           (size_t )(sectors * 2352L));
    }
  }
#line 990
  return (0);
}
}
#line 993 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
static int i_read_D4_12___2(cdrom_drive *d___0 , void *p___0 , long begin , long sectors ,
                            unsigned char *sense ) 
{ 
  int ret ;
  unsigned char cmd[12] ;

  {
#line 995
  cmd[0] = (unsigned char)212;
#line 995
  cmd[1] = (unsigned char)0;
#line 995
  cmd[2] = (unsigned char)0;
#line 995
  cmd[3] = (unsigned char)0;
#line 995
  cmd[4] = (unsigned char)0;
#line 995
  cmd[5] = (unsigned char)0;
#line 995
  cmd[6] = (unsigned char)0;
#line 995
  cmd[7] = (unsigned char)0;
#line 995
  cmd[8] = (unsigned char)0;
#line 995
  cmd[9] = (unsigned char)0;
#line 995
  cmd[10] = (unsigned char)0;
#line 995
  cmd[11] = (unsigned char)0;
#line 997
  if (d___0->fua) {
#line 998
    cmd[1] = (unsigned char)8;
  }
  {
#line 1000
  cmd[1] = (unsigned char )((int )cmd[1] | (d___0->lun << 5));
#line 1001
  cmd[3] = (unsigned char )((begin >> 16) & 255L);
#line 1002
  cmd[4] = (unsigned char )((begin >> 8) & 255L);
#line 1003
  cmd[5] = (unsigned char )(begin & 255L);
#line 1004
  cmd[9] = (unsigned char )sectors;
#line 1005
  ret = handle_scsi_cmd___2(d___0, cmd, 12U, 0U, (unsigned int )(sectors * 2352L),
                            (unsigned char )'\177', 1, sense);
  }
#line 1005
  if (ret) {
#line 1006
    return (ret);
  }
#line 1007
  if (p___0) {
    {
#line 1007
    memcpy((void */* __restrict  */)p___0, (void const   */* __restrict  */)(d___0->private_data)->sg_buffer,
           (size_t )(sectors * 2352L));
    }
  }
#line 1008
  return (0);
}
}
#line 1011 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
static int i_read_D5___2(cdrom_drive *d___0 , void *p___0 , long begin , long sectors ,
                         unsigned char *sense ) 
{ 
  int ret ;
  unsigned char cmd[10] ;

  {
#line 1013
  cmd[0] = (unsigned char)213;
#line 1013
  cmd[1] = (unsigned char)0;
#line 1013
  cmd[2] = (unsigned char)0;
#line 1013
  cmd[3] = (unsigned char)0;
#line 1013
  cmd[4] = (unsigned char)0;
#line 1013
  cmd[5] = (unsigned char)0;
#line 1013
  cmd[6] = (unsigned char)0;
#line 1013
  cmd[7] = (unsigned char)0;
#line 1013
  cmd[8] = (unsigned char)0;
#line 1013
  cmd[9] = (unsigned char)0;
#line 1015
  if (d___0->fua) {
#line 1016
    cmd[1] = (unsigned char)8;
  }
  {
#line 1018
  cmd[1] = (unsigned char )((int )cmd[1] | (d___0->lun << 5));
#line 1019
  cmd[3] = (unsigned char )((begin >> 16) & 255L);
#line 1020
  cmd[4] = (unsigned char )((begin >> 8) & 255L);
#line 1021
  cmd[5] = (unsigned char )(begin & 255L);
#line 1022
  cmd[8] = (unsigned char )sectors;
#line 1023
  ret = handle_scsi_cmd___2(d___0, cmd, 10U, 0U, (unsigned int )(sectors * 2352L),
                            (unsigned char )'\177', 1, sense);
  }
#line 1023
  if (ret) {
#line 1024
    return (ret);
  }
#line 1025
  if (p___0) {
    {
#line 1025
    memcpy((void */* __restrict  */)p___0, (void const   */* __restrict  */)(d___0->private_data)->sg_buffer,
           (size_t )(sectors * 2352L));
    }
  }
#line 1026
  return (0);
}
}
#line 1029 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
static int i_read_D8___2(cdrom_drive *d___0 , void *p___0 , long begin , long sectors ,
                         unsigned char *sense ) 
{ 
  int ret ;
  unsigned char cmd[12] ;

  {
#line 1031
  cmd[0] = (unsigned char)216;
#line 1031
  cmd[1] = (unsigned char)0;
#line 1031
  cmd[2] = (unsigned char)0;
#line 1031
  cmd[3] = (unsigned char)0;
#line 1031
  cmd[4] = (unsigned char)0;
#line 1031
  cmd[5] = (unsigned char)0;
#line 1031
  cmd[6] = (unsigned char)0;
#line 1031
  cmd[7] = (unsigned char)0;
#line 1031
  cmd[8] = (unsigned char)0;
#line 1031
  cmd[9] = (unsigned char)0;
#line 1031
  cmd[10] = (unsigned char)0;
#line 1031
  cmd[11] = (unsigned char)0;
#line 1033
  if (d___0->fua) {
#line 1034
    cmd[1] = (unsigned char)8;
  }
  {
#line 1036
  cmd[1] = (unsigned char )((int )cmd[1] | (d___0->lun << 5));
#line 1037
  cmd[3] = (unsigned char )((begin >> 16) & 255L);
#line 1038
  cmd[4] = (unsigned char )((begin >> 8) & 255L);
#line 1039
  cmd[5] = (unsigned char )(begin & 255L);
#line 1040
  cmd[9] = (unsigned char )sectors;
#line 1041
  ret = handle_scsi_cmd___2(d___0, cmd, 12U, 0U, (unsigned int )(sectors * 2352L),
                            (unsigned char )'\177', 1, sense);
  }
#line 1041
  if (ret) {
#line 1042
    return (ret);
  }
#line 1043
  if (p___0) {
    {
#line 1043
    memcpy((void */* __restrict  */)p___0, (void const   */* __restrict  */)(d___0->private_data)->sg_buffer,
           (size_t )(sectors * 2352L));
    }
  }
#line 1044
  return (0);
}
}
#line 1047 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
static int i_read_mmc___2(cdrom_drive *d___0 , void *p___0 , long begin , long sectors ,
                          unsigned char *sense ) 
{ 
  int ret ;
  unsigned char cmd[12] ;

  {
  {
#line 1049
  cmd[0] = (unsigned char)190;
#line 1049
  cmd[1] = (unsigned char)2;
#line 1049
  cmd[2] = (unsigned char)0;
#line 1049
  cmd[3] = (unsigned char)0;
#line 1049
  cmd[4] = (unsigned char)0;
#line 1049
  cmd[5] = (unsigned char)0;
#line 1049
  cmd[6] = (unsigned char)0;
#line 1049
  cmd[7] = (unsigned char)0;
#line 1049
  cmd[8] = (unsigned char)0;
#line 1049
  cmd[9] = (unsigned char)16;
#line 1049
  cmd[10] = (unsigned char)0;
#line 1049
  cmd[11] = (unsigned char)0;
#line 1051
  cmd[3] = (unsigned char )((begin >> 16) & 255L);
#line 1052
  cmd[4] = (unsigned char )((begin >> 8) & 255L);
#line 1053
  cmd[5] = (unsigned char )(begin & 255L);
#line 1054
  cmd[8] = (unsigned char )sectors;
#line 1055
  ret = handle_scsi_cmd___2(d___0, cmd, 12U, 0U, (unsigned int )(sectors * 2352L),
                            (unsigned char )'\177', 1, sense);
  }
#line 1055
  if (ret) {
#line 1056
    return (ret);
  }
#line 1057
  if (p___0) {
    {
#line 1057
    memcpy((void */* __restrict  */)p___0, (void const   */* __restrict  */)(d___0->private_data)->sg_buffer,
           (size_t )(sectors * 2352L));
    }
  }
#line 1058
  return (0);
}
}
#line 1061 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
static int i_read_mmcB___2(cdrom_drive *d___0 , void *p___0 , long begin , long sectors ,
                           unsigned char *sense ) 
{ 
  int ret ;
  unsigned char cmd[12] ;

  {
  {
#line 1063
  cmd[0] = (unsigned char)190;
#line 1063
  cmd[1] = (unsigned char)0;
#line 1063
  cmd[2] = (unsigned char)0;
#line 1063
  cmd[3] = (unsigned char)0;
#line 1063
  cmd[4] = (unsigned char)0;
#line 1063
  cmd[5] = (unsigned char)0;
#line 1063
  cmd[6] = (unsigned char)0;
#line 1063
  cmd[7] = (unsigned char)0;
#line 1063
  cmd[8] = (unsigned char)0;
#line 1063
  cmd[9] = (unsigned char)16;
#line 1063
  cmd[10] = (unsigned char)0;
#line 1063
  cmd[11] = (unsigned char)0;
#line 1065
  cmd[3] = (unsigned char )((begin >> 16) & 255L);
#line 1066
  cmd[4] = (unsigned char )((begin >> 8) & 255L);
#line 1067
  cmd[5] = (unsigned char )(begin & 255L);
#line 1068
  cmd[8] = (unsigned char )sectors;
#line 1069
  ret = handle_scsi_cmd___2(d___0, cmd, 12U, 0U, (unsigned int )(sectors * 2352L),
                            (unsigned char )'\177', 1, sense);
  }
#line 1069
  if (ret) {
#line 1070
    return (ret);
  }
#line 1071
  if (p___0) {
    {
#line 1071
    memcpy((void */* __restrict  */)p___0, (void const   */* __restrict  */)(d___0->private_data)->sg_buffer,
           (size_t )(sectors * 2352L));
    }
  }
#line 1072
  return (0);
}
}
#line 1075 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
static int i_read_mmc2___2(cdrom_drive *d___0 , void *p___0 , long begin , long sectors ,
                           unsigned char *sense ) 
{ 
  int ret ;
  unsigned char cmd[12] ;

  {
  {
#line 1077
  cmd[0] = (unsigned char)190;
#line 1077
  cmd[1] = (unsigned char)2;
#line 1077
  cmd[2] = (unsigned char)0;
#line 1077
  cmd[3] = (unsigned char)0;
#line 1077
  cmd[4] = (unsigned char)0;
#line 1077
  cmd[5] = (unsigned char)0;
#line 1077
  cmd[6] = (unsigned char)0;
#line 1077
  cmd[7] = (unsigned char)0;
#line 1077
  cmd[8] = (unsigned char)0;
#line 1077
  cmd[9] = (unsigned char)248;
#line 1077
  cmd[10] = (unsigned char)0;
#line 1077
  cmd[11] = (unsigned char)0;
#line 1079
  cmd[3] = (unsigned char )((begin >> 16) & 255L);
#line 1080
  cmd[4] = (unsigned char )((begin >> 8) & 255L);
#line 1081
  cmd[5] = (unsigned char )(begin & 255L);
#line 1082
  cmd[8] = (unsigned char )sectors;
#line 1083
  ret = handle_scsi_cmd___2(d___0, cmd, 12U, 0U, (unsigned int )(sectors * 2352L),
                            (unsigned char )'\177', 1, sense);
  }
#line 1083
  if (ret) {
#line 1084
    return (ret);
  }
#line 1085
  if (p___0) {
    {
#line 1085
    memcpy((void */* __restrict  */)p___0, (void const   */* __restrict  */)(d___0->private_data)->sg_buffer,
           (size_t )(sectors * 2352L));
    }
  }
#line 1086
  return (0);
}
}
#line 1089 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
static int i_read_mmc2B___2(cdrom_drive *d___0 , void *p___0 , long begin , long sectors ,
                            unsigned char *sense ) 
{ 
  int ret ;
  unsigned char cmd[12] ;

  {
  {
#line 1091
  cmd[0] = (unsigned char)190;
#line 1091
  cmd[1] = (unsigned char)0;
#line 1091
  cmd[2] = (unsigned char)0;
#line 1091
  cmd[3] = (unsigned char)0;
#line 1091
  cmd[4] = (unsigned char)0;
#line 1091
  cmd[5] = (unsigned char)0;
#line 1091
  cmd[6] = (unsigned char)0;
#line 1091
  cmd[7] = (unsigned char)0;
#line 1091
  cmd[8] = (unsigned char)0;
#line 1091
  cmd[9] = (unsigned char)248;
#line 1091
  cmd[10] = (unsigned char)0;
#line 1091
  cmd[11] = (unsigned char)0;
#line 1093
  cmd[3] = (unsigned char )((begin >> 16) & 255L);
#line 1094
  cmd[4] = (unsigned char )((begin >> 8) & 255L);
#line 1095
  cmd[5] = (unsigned char )(begin & 255L);
#line 1096
  cmd[8] = (unsigned char )sectors;
#line 1097
  ret = handle_scsi_cmd___2(d___0, cmd, 12U, 0U, (unsigned int )(sectors * 2352L),
                            (unsigned char )'\177', 1, sense);
  }
#line 1097
  if (ret) {
#line 1098
    return (ret);
  }
#line 1099
  if (p___0) {
    {
#line 1099
    memcpy((void */* __restrict  */)p___0, (void const   */* __restrict  */)(d___0->private_data)->sg_buffer,
           (size_t )(sectors * 2352L));
    }
  }
#line 1100
  return (0);
}
}
#line 1103 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
static int i_read_mmc3___2(cdrom_drive *d___0 , void *p___0 , long begin , long sectors ,
                           unsigned char *sense ) 
{ 
  int ret ;
  unsigned char cmd[12] ;

  {
  {
#line 1105
  cmd[0] = (unsigned char)190;
#line 1105
  cmd[1] = (unsigned char)6;
#line 1105
  cmd[2] = (unsigned char)0;
#line 1105
  cmd[3] = (unsigned char)0;
#line 1105
  cmd[4] = (unsigned char)0;
#line 1105
  cmd[5] = (unsigned char)0;
#line 1105
  cmd[6] = (unsigned char)0;
#line 1105
  cmd[7] = (unsigned char)0;
#line 1105
  cmd[8] = (unsigned char)0;
#line 1105
  cmd[9] = (unsigned char)248;
#line 1105
  cmd[10] = (unsigned char)0;
#line 1105
  cmd[11] = (unsigned char)0;
#line 1107
  cmd[3] = (unsigned char )((begin >> 16) & 255L);
#line 1108
  cmd[4] = (unsigned char )((begin >> 8) & 255L);
#line 1109
  cmd[5] = (unsigned char )(begin & 255L);
#line 1110
  cmd[8] = (unsigned char )sectors;
#line 1111
  ret = handle_scsi_cmd___2(d___0, cmd, 12U, 0U, (unsigned int )(sectors * 2352L),
                            (unsigned char )'\177', 1, sense);
  }
#line 1111
  if (ret) {
#line 1112
    return (ret);
  }
#line 1113
  if (p___0) {
    {
#line 1113
    memcpy((void */* __restrict  */)p___0, (void const   */* __restrict  */)(d___0->private_data)->sg_buffer,
           (size_t )(sectors * 2352L));
    }
  }
#line 1114
  return (0);
}
}
#line 1117 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
static int i_read_mmc3B___2(cdrom_drive *d___0 , void *p___0 , long begin , long sectors ,
                            unsigned char *sense ) 
{ 
  int ret ;
  unsigned char cmd[12] ;

  {
  {
#line 1119
  cmd[0] = (unsigned char)190;
#line 1119
  cmd[1] = (unsigned char)4;
#line 1119
  cmd[2] = (unsigned char)0;
#line 1119
  cmd[3] = (unsigned char)0;
#line 1119
  cmd[4] = (unsigned char)0;
#line 1119
  cmd[5] = (unsigned char)0;
#line 1119
  cmd[6] = (unsigned char)0;
#line 1119
  cmd[7] = (unsigned char)0;
#line 1119
  cmd[8] = (unsigned char)0;
#line 1119
  cmd[9] = (unsigned char)248;
#line 1119
  cmd[10] = (unsigned char)0;
#line 1119
  cmd[11] = (unsigned char)0;
#line 1121
  cmd[3] = (unsigned char )((begin >> 16) & 255L);
#line 1122
  cmd[4] = (unsigned char )((begin >> 8) & 255L);
#line 1123
  cmd[5] = (unsigned char )(begin & 255L);
#line 1124
  cmd[8] = (unsigned char )sectors;
#line 1125
  ret = handle_scsi_cmd___2(d___0, cmd, 12U, 0U, (unsigned int )(sectors * 2352L),
                            (unsigned char )'\177', 1, sense);
  }
#line 1125
  if (ret) {
#line 1126
    return (ret);
  }
#line 1127
  if (p___0) {
    {
#line 1127
    memcpy((void */* __restrict  */)p___0, (void const   */* __restrict  */)(d___0->private_data)->sg_buffer,
           (size_t )(sectors * 2352L));
    }
  }
#line 1128
  return (0);
}
}
#line 1152 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
static int i_read_msf___2(cdrom_drive *d___0 , void *p___0 , long begin , long sectors ,
                          unsigned char *sense ) 
{ 
  int ret ;
  unsigned char cmd[12] ;

  {
  {
#line 1154
  cmd[0] = (unsigned char)185;
#line 1154
  cmd[1] = (unsigned char)0;
#line 1154
  cmd[2] = (unsigned char)0;
#line 1154
  cmd[3] = (unsigned char)0;
#line 1154
  cmd[4] = (unsigned char)0;
#line 1154
  cmd[5] = (unsigned char)0;
#line 1154
  cmd[6] = (unsigned char)0;
#line 1154
  cmd[7] = (unsigned char)0;
#line 1154
  cmd[8] = (unsigned char)0;
#line 1154
  cmd[9] = (unsigned char)16;
#line 1154
  cmd[10] = (unsigned char)0;
#line 1154
  cmd[11] = (unsigned char)0;
#line 1156
  LBA_to_MSF(begin, cmd + 3, cmd + 4, cmd + 5);
#line 1157
  LBA_to_MSF(begin + sectors, cmd + 6, cmd + 7, cmd + 8);
#line 1159
  ret = handle_scsi_cmd___2(d___0, cmd, 12U, 0U, (unsigned int )(sectors * 2352L),
                            (unsigned char )'\177', 1, sense);
  }
#line 1159
  if (ret) {
#line 1160
    return (ret);
  }
#line 1161
  if (p___0) {
    {
#line 1161
    memcpy((void */* __restrict  */)p___0, (void const   */* __restrict  */)(d___0->private_data)->sg_buffer,
           (size_t )(sectors * 2352L));
    }
  }
#line 1162
  return (0);
}
}
#line 1165 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
static int i_read_msf2___2(cdrom_drive *d___0 , void *p___0 , long begin , long sectors ,
                           unsigned char *sense ) 
{ 
  int ret ;
  unsigned char cmd[12] ;

  {
  {
#line 1167
  cmd[0] = (unsigned char)185;
#line 1167
  cmd[1] = (unsigned char)0;
#line 1167
  cmd[2] = (unsigned char)0;
#line 1167
  cmd[3] = (unsigned char)0;
#line 1167
  cmd[4] = (unsigned char)0;
#line 1167
  cmd[5] = (unsigned char)0;
#line 1167
  cmd[6] = (unsigned char)0;
#line 1167
  cmd[7] = (unsigned char)0;
#line 1167
  cmd[8] = (unsigned char)0;
#line 1167
  cmd[9] = (unsigned char)248;
#line 1167
  cmd[10] = (unsigned char)0;
#line 1167
  cmd[11] = (unsigned char)0;
#line 1169
  LBA_to_MSF(begin, cmd + 3, cmd + 4, cmd + 5);
#line 1170
  LBA_to_MSF(begin + sectors, cmd + 6, cmd + 7, cmd + 8);
#line 1172
  ret = handle_scsi_cmd___2(d___0, cmd, 12U, 0U, (unsigned int )(sectors * 2352L),
                            (unsigned char )'\177', 1, sense);
  }
#line 1172
  if (ret) {
#line 1173
    return (ret);
  }
#line 1174
  if (p___0) {
    {
#line 1174
    memcpy((void */* __restrict  */)p___0, (void const   */* __restrict  */)(d___0->private_data)->sg_buffer,
           (size_t )(sectors * 2352L));
    }
  }
#line 1175
  return (0);
}
}
#line 1178 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
static int i_read_msf3___2(cdrom_drive *d___0 , void *p___0 , long begin , long sectors ,
                           unsigned char *sense ) 
{ 
  int ret ;
  unsigned char cmd[12] ;

  {
  {
#line 1180
  cmd[0] = (unsigned char)185;
#line 1180
  cmd[1] = (unsigned char)4;
#line 1180
  cmd[2] = (unsigned char)0;
#line 1180
  cmd[3] = (unsigned char)0;
#line 1180
  cmd[4] = (unsigned char)0;
#line 1180
  cmd[5] = (unsigned char)0;
#line 1180
  cmd[6] = (unsigned char)0;
#line 1180
  cmd[7] = (unsigned char)0;
#line 1180
  cmd[8] = (unsigned char)0;
#line 1180
  cmd[9] = (unsigned char)248;
#line 1180
  cmd[10] = (unsigned char)0;
#line 1180
  cmd[11] = (unsigned char)0;
#line 1182
  LBA_to_MSF(begin, cmd + 3, cmd + 4, cmd + 5);
#line 1183
  LBA_to_MSF(begin + sectors, cmd + 6, cmd + 7, cmd + 8);
#line 1185
  ret = handle_scsi_cmd___2(d___0, cmd, 12U, 0U, (unsigned int )(sectors * 2352L),
                            (unsigned char )'\177', 1, sense);
  }
#line 1185
  if (ret) {
#line 1186
    return (ret);
  }
#line 1187
  if (p___0) {
    {
#line 1187
    memcpy((void */* __restrict  */)p___0, (void const   */* __restrict  */)(d___0->private_data)->sg_buffer,
           (size_t )(sectors * 2352L));
    }
  }
#line 1188
  return (0);
}
}
#line 1192 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
static long scsi_read_map___2(cdrom_drive *d___0 , void *p___0 , long begin , long sectors ,
                              int (*map)(cdrom_drive * , void * , long  , long  ,
                                         unsigned char * ) ) 
{ 
  unsigned char sense[16] ;
  int retry_count ;
  int err ;
  char *buffer ;
  char b[256] ;
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int *tmp___3 ;
  char b___0[256] ;
  int *tmp___4 ;
  char b___1[256] ;
  long i ;
  char b___2[256] ;
  char *tmp___5 ;

  {
#line 1197
  buffer = (char *)p___0;
#line 1200
  if (sectors > (long )d___0->nsectors) {
#line 1200
    sectors = (long )d___0->nsectors;
  } else {
#line 1200
    sectors = sectors;
  }
#line 1201
  if (sectors < 1L) {
#line 1201
    sectors = 1L;
  } else {
#line 1201
    sectors = sectors;
  }
#line 1203
  retry_count = 0;
  {
#line 1205
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1207
    if (p___0) {
#line 1207
      tmp___5 = buffer;
    } else {
#line 1207
      tmp___5 = (char *)((void *)0);
    }
    {
#line 1207
    err = (*map)(d___0, (void *)tmp___5, begin, sectors, sense);
    }
#line 1207
    if (err) {
#line 1208
      if (d___0->report_all) {
        {
#line 1211
        sprintf((char */* __restrict  */)(b), (char const   */* __restrict  */)"scsi_read error: sector=%ld length=%ld retry=%d\n",
                begin, sectors, retry_count);
#line 1213
        cdmessage___8(d___0, (char const   *)(b));
#line 1215
        sprintf((char */* __restrict  */)(b), (char const   */* __restrict  */)"                 Sense key: %x ASC: %x ASCQ: %x\n",
                (int )sense[2] & 15, (int )sense[12], (int )sense[13]);
#line 1228
        cdmessage___8(d___0, (char const   *)(b));
#line 1229
        sprintf((char */* __restrict  */)(b), (char const   */* __restrict  */)"                 Transport error: %s\n",
                strerror_tr___2[err]);
#line 1230
        cdmessage___8(d___0, (char const   *)(b));
#line 1231
        tmp = __errno_location();
#line 1231
        tmp___0 = strerror(*tmp);
#line 1231
        sprintf((char */* __restrict  */)(b), (char const   */* __restrict  */)"                 System error: %s\n",
                tmp___0);
#line 1232
        cdmessage___8(d___0, (char const   *)(b));
#line 1234
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"scsi_read error: sector=%ld length=%ld retry=%d\n",
                begin, sectors, retry_count);
#line 1237
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"                 Sense key: %x ASC: %x ASCQ: %x\n",
                (int )sense[2] & 15, (int )sense[12], (int )sense[13]);
#line 1249
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"                 Transport error: %s\n",
                strerror_tr___2[err]);
#line 1250
        tmp___1 = __errno_location();
#line 1250
        tmp___2 = strerror(*tmp___1);
#line 1250
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"                 System error: %s\n",
                tmp___2);
        }
      }
      {
#line 1253
      tmp___3 = __errno_location();
      }
      {
#line 1254
      if (*tmp___3 == 4) {
#line 1254
        goto case_4;
      }
#line 1257
      if (*tmp___3 == 12) {
#line 1257
        goto case_12;
      }
#line 1275
      if (*tmp___3 == 123) {
#line 1275
        goto case_123;
      }
#line 1279
      goto switch_default;
      case_4: /* CIL Label */ 
      {
#line 1255
      usleep((__useconds_t )100);
      }
#line 1256
      goto while_continue;
      case_12: /* CIL Label */ 
      {
#line 1259
      usleep((__useconds_t )100);
      }
#line 1260
      if (sectors == 1L) {
        {
#line 1262
        cderror___13(d___0, "300: Kernel memory error\n");
        }
#line 1263
        return (-300L);
      }
#line 1265
      if (d___0->report_all) {
        {
#line 1267
        sprintf((char */* __restrict  */)(b___0), (char const   */* __restrict  */)"scsi_read: kernel couldn\'t alloc %ld bytes.  backing off...\n",
                sectors * 2352L);
#line 1270
        cdmessage___8(d___0, (char const   *)(b___0));
        }
      }
#line 1272
      sectors --;
#line 1273
      goto while_continue;
      case_123: /* CIL Label */ 
      {
#line 1276
      cderror___13(d___0, "404: No medium present\n");
      }
#line 1277
      return (-404L);
      switch_default: /* CIL Label */ 
#line 1280
      if (sectors == 1L) {
        {
#line 1281
        tmp___4 = __errno_location();
        }
#line 1281
        if (*tmp___4 == 5) {
#line 1282
          if (d___0->fua == -1) {
#line 1283
            return (-7L);
          }
        }
#line 1288
        if (retry_count > 7) {
          {
#line 1290
          sprintf((char */* __restrict  */)(b___1), (char const   */* __restrict  */)"010: Unable to access sector %ld\n",
                  begin);
#line 1292
          cderror___13(d___0, (char const   *)(b___1));
          }
#line 1293
          return (-10L);
        }
#line 1296
        goto switch_break;
      }
      {
#line 1302
      reset_scsi___2(d___0);
      }
      switch_break: /* CIL Label */ ;
      }
#line 1304
      if (! d___0->error_retry) {
#line 1304
        return (-7L);
      }
    } else
#line 1310
    if (buffer) {
#line 1312
      i = sectors * 2352L;
      {
#line 1312
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1312
        if (! (i > 1L)) {
#line 1312
          goto while_break___0;
        }
#line 1313
        if ((int )*(buffer + (i - 1L)) != 127) {
#line 1314
          goto while_break___0;
        } else
#line 1313
        if ((int )*(buffer + (i - 2L)) != 127) {
#line 1314
          goto while_break___0;
        }
#line 1312
        i -= 2L;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 1316
      i /= 2352L;
#line 1317
      if (i != sectors) {
#line 1318
        if (d___0->report_all) {
          {
#line 1320
          sprintf((char */* __restrict  */)(b___2), (char const   */* __restrict  */)"scsi_read underrun: pos=%ld len=%ld read=%ld retry=%d\n",
                  begin, sectors, i, retry_count);
#line 1323
          cdmessage___8(d___0, (char const   *)(b___2));
          }
        }
        {
#line 1325
        reset_scsi___2(d___0);
        }
      }
#line 1328
      if (i > 0L) {
#line 1328
        return (i);
      }
    } else {
#line 1331
      goto while_break;
    }
#line 1334
    retry_count ++;
#line 1335
    if (sectors == 1L) {
#line 1335
      if (retry_count > 8) {
        {
#line 1336
        cderror___13(d___0, "007: Unknown, unrecoverable error reading data\n");
        }
#line 1337
        return (-7L);
      }
    }
#line 1339
    if (sectors > 1L) {
#line 1339
      sectors /= 2L;
    }
    {
#line 1340
    (*(d___0->enable_cdda))(d___0, 0);
#line 1341
    (*(d___0->enable_cdda))(d___0, 1);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1344
  return (sectors);
}
}
#line 1427 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
static int count_2352_bytes___2(cdrom_drive *d___0 ) 
{ 
  long i ;

  {
#line 1429
  i = 2351L;
  {
#line 1429
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1429
    if (! (i >= 0L)) {
#line 1429
      goto while_break;
    }
#line 1430
    if ((int )*((d___0->private_data)->sg_buffer + i) != 127) {
#line 1431
      return ((int )(((i + 3L) >> 2) << 2));
    }
#line 1429
    i --;
  }
  while_break: /* CIL Label */ ;
  }
#line 1433
  return (0);
}
}
#line 1436 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
static int verify_nonzero___2(cdrom_drive *d___0 ) 
{ 
  long i ;
  long flag ;

  {
#line 1437
  flag = 0L;
#line 1438
  i = 0L;
  {
#line 1438
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1438
    if (! (i < 2352L)) {
#line 1438
      goto while_break;
    }
#line 1439
    if ((int )*((d___0->private_data)->sg_buffer + i) != 0) {
#line 1440
      flag = 1L;
#line 1441
      goto while_break;
    }
#line 1438
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1444
  return ((int )flag);
}
}
#line 1451 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
static int verify_read_command___5(cdrom_drive *d___0 ) 
{ 
  int i ;
  int j ;
  int k ;
  int audioflag ;
  int (*enablecommand)(struct cdrom_drive *d , int speed ) ;
  long (*readcommand)(struct cdrom_drive *d , void *p , long begin , long sectors ) ;
  unsigned char density ;
  int16_t *buff ;
  void *tmp ;
  long firstsector ;
  long tmp___0 ;
  long lastsector ;
  long tmp___1 ;
  long sector ;
  int tmp___2 ;
  long tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  char *es ;
  char *rs___0 ;
  int densitypossible ;
  int densityflag ;
  int rejectflag ;
  int zeroflag ;
  int lengthflag ;
  long firstsector___0 ;
  long tmp___6 ;
  long lastsector___0 ;
  long tmp___7 ;
  long sector___0 ;
  int tmp___8 ;
  long tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  char buffer[256] ;
  char buffer___0[256] ;
  char buffer___1[256] ;

  {
  {
#line 1453
  audioflag = 0;
#line 1460
  tmp = malloc((size_t )2352);
#line 1460
  buff = (int16_t *)tmp;
#line 1462
  cdmessage___8(d___0, "Verifying CDDA command set...\n");
#line 1467
  tmp___5 = (*(d___0->enable_cdda))(d___0, 1);
  }
#line 1467
  if (tmp___5 == 0) {
#line 1469
    i = 1;
    {
#line 1469
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1469
      if (! (i <= d___0->tracks)) {
#line 1469
        goto while_break;
      }
      {
#line 1470
      tmp___4 = cdda_track_audiop(d___0, i);
      }
#line 1470
      if (tmp___4 == 1) {
        {
#line 1471
        tmp___0 = cdda_track_firstsector(d___0, i);
#line 1471
        firstsector = tmp___0;
#line 1472
        tmp___1 = cdda_track_lastsector(d___0, i);
#line 1472
        lastsector = tmp___1;
#line 1473
        sector = (firstsector + lastsector) >> 1;
#line 1474
        audioflag = 1;
#line 1476
        tmp___3 = (*(d___0->read_audio))(d___0, (void *)buff, sector, 1L);
        }
#line 1476
        if (tmp___3 > 0L) {
          {
#line 1477
          tmp___2 = count_2352_bytes___2(d___0);
          }
#line 1477
          if (tmp___2 == 2352) {
            {
#line 1478
            cdmessage___8(d___0, "\tExpected command set reads OK.\n");
#line 1479
            (*(d___0->enable_cdda))(d___0, 0);
#line 1480
            free((void *)buff);
            }
#line 1481
            return (0);
          }
        }
      }
#line 1469
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1487
    (*(d___0->enable_cdda))(d___0, 0);
    }
  }
#line 1489
  if (! audioflag) {
    {
#line 1490
    cdmessage___8(d___0, "\tCould not find any audio tracks on this disk.\n");
    }
#line 1491
    return (-403);
  }
  {
#line 1495
  es = (char *)"";
#line 1495
  rs___0 = (char *)"";
#line 1496
  d___0->bigendianp = -1;
#line 1497
  density = d___0->density;
#line 1498
  readcommand = d___0->read_audio;
#line 1499
  enablecommand = d___0->enable_cdda;
#line 1503
  cdmessage___8(d___0, "\tExpected command set FAILED!\n\tPerforming full probe for CDDA command set...\n");
#line 1513
  j = 0;
  }
  {
#line 1513
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1513
    if (! (j < 15)) {
#line 1513
      goto while_break___0;
    }
#line 1514
    densitypossible = 1;
    {
#line 1517
    if (j == 0) {
#line 1517
      goto case_0;
    }
#line 1521
    if (j == 1) {
#line 1521
      goto case_1;
    }
#line 1526
    if (j == 2) {
#line 1526
      goto case_2;
    }
#line 1531
    if (j == 3) {
#line 1531
      goto case_3;
    }
#line 1536
    if (j == 4) {
#line 1536
      goto case_4;
    }
#line 1542
    if (j == 5) {
#line 1542
      goto case_5;
    }
#line 1547
    if (j == 6) {
#line 1547
      goto case_6;
    }
#line 1552
    if (j == 7) {
#line 1552
      goto case_7;
    }
#line 1558
    if (j == 8) {
#line 1558
      goto case_8;
    }
#line 1563
    if (j == 9) {
#line 1563
      goto case_9;
    }
#line 1568
    if (j == 10) {
#line 1568
      goto case_10;
    }
#line 1574
    if (j == 11) {
#line 1574
      goto case_11;
    }
#line 1578
    if (j == 12) {
#line 1578
      goto case_12;
    }
#line 1582
    if (j == 13) {
#line 1582
      goto case_13;
    }
#line 1586
    if (j == 14) {
#line 1586
      goto case_14;
    }
#line 1516
    goto switch_break;
    case_0: /* CIL Label */ 
#line 1518
    d___0->read_audio = & scsi_read_28;
#line 1519
    rs___0 = (char *)"28 0x,00";
#line 1520
    goto switch_break;
    case_1: /* CIL Label */ 
#line 1522
    d___0->read_audio = & scsi_read_A8;
#line 1523
    rs___0 = (char *)"a8 0x,00";
#line 1524
    goto switch_break;
    case_2: /* CIL Label */ 
#line 1527
    d___0->read_audio = & scsi_read_mmcB;
#line 1528
    rs___0 = (char *)"be 02,10";
#line 1529
    densitypossible = 0;
#line 1530
    goto switch_break;
    case_3: /* CIL Label */ 
#line 1532
    d___0->read_audio = & scsi_read_mmc2B;
#line 1533
    rs___0 = (char *)"be 02,f8";
#line 1534
    densitypossible = 0;
#line 1535
    goto switch_break;
    case_4: /* CIL Label */ 
#line 1537
    d___0->read_audio = & scsi_read_mmc3B;
#line 1538
    rs___0 = (char *)"be 06,f8";
#line 1539
    densitypossible = 0;
#line 1540
    goto switch_break;
    case_5: /* CIL Label */ 
#line 1543
    d___0->read_audio = & scsi_read_mmc;
#line 1544
    rs___0 = (char *)"be 00,10";
#line 1545
    densitypossible = 0;
#line 1546
    goto switch_break;
    case_6: /* CIL Label */ 
#line 1548
    d___0->read_audio = & scsi_read_mmc2;
#line 1549
    rs___0 = (char *)"be 00,f8";
#line 1550
    densitypossible = 0;
#line 1551
    goto switch_break;
    case_7: /* CIL Label */ 
#line 1553
    d___0->read_audio = & scsi_read_mmc3;
#line 1554
    rs___0 = (char *)"be 04,f8";
#line 1555
    densitypossible = 0;
#line 1556
    goto switch_break;
    case_8: /* CIL Label */ 
#line 1559
    d___0->read_audio = & scsi_read_msf;
#line 1560
    rs___0 = (char *)"b9 00,10";
#line 1561
    densitypossible = 0;
#line 1562
    goto switch_break;
    case_9: /* CIL Label */ 
#line 1564
    d___0->read_audio = & scsi_read_msf2;
#line 1565
    rs___0 = (char *)"b9 00,f8";
#line 1566
    densitypossible = 0;
#line 1567
    goto switch_break;
    case_10: /* CIL Label */ 
#line 1569
    d___0->read_audio = & scsi_read_msf3;
#line 1570
    rs___0 = (char *)"b9 04,f8";
#line 1571
    densitypossible = 0;
#line 1572
    goto switch_break;
    case_11: /* CIL Label */ 
#line 1575
    d___0->read_audio = & scsi_read_D4_10;
#line 1576
    rs___0 = (char *)"d4(10)0x";
#line 1577
    goto switch_break;
    case_12: /* CIL Label */ 
#line 1579
    d___0->read_audio = & scsi_read_D4_12;
#line 1580
    rs___0 = (char *)"d4(12)0x";
#line 1581
    goto switch_break;
    case_13: /* CIL Label */ 
#line 1583
    d___0->read_audio = & scsi_read_D5;
#line 1584
    rs___0 = (char *)"d5 0x,00";
#line 1585
    goto switch_break;
    case_14: /* CIL Label */ 
#line 1587
    d___0->read_audio = & scsi_read_D8;
#line 1588
    rs___0 = (char *)"d8 0x,00";
#line 1589
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 1592
    i = 0;
    {
#line 1592
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1592
      if (! (i < 5)) {
#line 1592
        goto while_break___1;
      }
      {
#line 1594
      if (i == 0) {
#line 1594
        goto case_0___0;
      }
#line 1600
      if (i == 1) {
#line 1600
        goto case_1___0;
      }
#line 1605
      if (i == 2) {
#line 1605
        goto case_2___0;
      }
#line 1610
      if (i == 3) {
#line 1610
        goto case_3___0;
      }
#line 1615
      if (i == 4) {
#line 1615
        goto case_4___0;
      }
#line 1593
      goto switch_break___0;
      case_0___0: /* CIL Label */ 
#line 1595
      d___0->density = (unsigned char)0;
#line 1596
      d___0->enable_cdda = & Dummy___5;
#line 1597
      es = (char *)"none    ";
#line 1598
      if (! densitypossible) {
#line 1598
        i = 5;
      }
#line 1599
      goto switch_break___0;
      case_1___0: /* CIL Label */ 
#line 1601
      d___0->density = (unsigned char)0;
#line 1602
      d___0->enable_cdda = & scsi_enable_cdda;
#line 1603
      es = (char *)"yes/0x00";
#line 1604
      goto switch_break___0;
      case_2___0: /* CIL Label */ 
#line 1606
      d___0->density = (unsigned char)4;
#line 1607
      d___0->enable_cdda = & scsi_enable_cdda;
#line 1608
      es = (char *)"yes/0x04";
#line 1609
      goto switch_break___0;
      case_3___0: /* CIL Label */ 
#line 1611
      d___0->density = (unsigned char)130;
#line 1612
      d___0->enable_cdda = & scsi_enable_cdda;
#line 1613
      es = (char *)"yes/0x82";
#line 1614
      goto switch_break___0;
      case_4___0: /* CIL Label */ 
#line 1616
      d___0->density = (unsigned char)129;
#line 1617
      d___0->enable_cdda = & scsi_enable_cdda;
#line 1618
      es = (char *)"yes/0x81";
#line 1619
      goto switch_break___0;
      switch_break___0: /* CIL Label */ ;
      }
      {
#line 1622
      cdmessage___8(d___0, "\ttest -> density: [");
#line 1623
      cdmessage___8(d___0, (char const   *)es);
#line 1624
      cdmessage___8(d___0, "]  command: [");
#line 1625
      cdmessage___8(d___0, (char const   *)rs___0);
#line 1626
      cdmessage___8(d___0, "]\n");
#line 1629
      densityflag = 0;
#line 1630
      rejectflag = 0;
#line 1631
      zeroflag = 0;
#line 1632
      lengthflag = 0;
#line 1634
      tmp___11 = (*(d___0->enable_cdda))(d___0, 1);
      }
#line 1634
      if (tmp___11 == 0) {
#line 1635
        k = 1;
        {
#line 1635
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 1635
          if (! (k <= d___0->tracks)) {
#line 1635
            goto while_break___2;
          }
          {
#line 1636
          tmp___10 = cdda_track_audiop(d___0, k);
          }
#line 1636
          if (tmp___10 == 1) {
            {
#line 1637
            tmp___6 = cdda_track_firstsector(d___0, k);
#line 1637
            firstsector___0 = tmp___6;
#line 1638
            tmp___7 = cdda_track_lastsector(d___0, k);
#line 1638
            lastsector___0 = tmp___7;
#line 1639
            sector___0 = (firstsector___0 + lastsector___0) >> 1;
#line 1641
            tmp___9 = (*(d___0->read_audio))(d___0, (void *)buff, sector___0, 1L);
            }
#line 1641
            if (tmp___9 > 0L) {
              {
#line 1642
              lengthflag = count_2352_bytes___2(d___0);
              }
#line 1642
              if (lengthflag == 2352) {
                {
#line 1643
                tmp___8 = verify_nonzero___2(d___0);
                }
#line 1643
                if (tmp___8) {
                  {
#line 1644
                  cdmessage___8(d___0, "\t\tCommand set FOUND!\n");
#line 1646
                  free((void *)buff);
#line 1647
                  (*(d___0->enable_cdda))(d___0, 0);
                  }
#line 1648
                  return (0);
                } else {
#line 1650
                  zeroflag ++;
                }
              }
            } else {
#line 1654
              rejectflag ++;
#line 1655
              goto while_break___2;
            }
          }
#line 1635
          k ++;
        }
        while_break___2: /* CIL Label */ ;
        }
        {
#line 1659
        (*(d___0->enable_cdda))(d___0, 0);
        }
      } else {
#line 1661
        densityflag ++;
      }
#line 1664
      if (densityflag) {
        {
#line 1665
        cdmessage___8(d___0, "\t\tDrive rejected density set\n");
        }
      }
#line 1666
      if (rejectflag) {
        {
#line 1668
        sprintf((char */* __restrict  */)(buffer), (char const   */* __restrict  */)"\t\tDrive rejected read command packet(s)\n");
#line 1669
        cdmessage___8(d___0, (char const   *)(buffer));
        }
      }
#line 1671
      if (lengthflag > 0) {
#line 1671
        if (lengthflag < 2352) {
          {
#line 1673
          sprintf((char */* __restrict  */)(buffer___0), (char const   */* __restrict  */)"\t\tDrive returned at least one packet, but with\n\t\tincorrect size (%d)\n",
                  lengthflag);
#line 1675
          cdmessage___8(d___0, (char const   *)(buffer___0));
          }
        }
      }
#line 1677
      if (zeroflag) {
        {
#line 1679
        sprintf((char */* __restrict  */)(buffer___1), (char const   */* __restrict  */)"\t\tDrive returned %d packet(s), but contents\n\t\twere entirely zero\n",
                zeroflag);
#line 1681
        cdmessage___8(d___0, (char const   *)(buffer___1));
        }
      }
#line 1592
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1513
    j ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1688
  d___0->density = density;
#line 1689
  d___0->read_audio = readcommand;
#line 1690
  d___0->enable_cdda = enablecommand;
#line 1692
  cdmessage___8(d___0, "\tUnable to find any suitable command set from probe;\n\tdrive probably not CDDA capable.\n");
#line 1695
  cderror___13(d___0, "006: Could not read any data from drive\n");
#line 1698
  free((void *)buff);
  }
#line 1699
  return (-6);
}
}
#line 1702 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
static void check_cache___2(cdrom_drive *d___0 ) 
{ 
  long i ;
  long firstsector ;
  long tmp ;
  long lastsector ;
  long tmp___0 ;
  long sector ;
  long tmp___1 ;
  int tmp___2 ;

  {
#line 1705
  if (! ((unsigned long )d___0->read_audio == (unsigned long )(& scsi_read_mmc))) {
#line 1705
    if (! ((unsigned long )d___0->read_audio == (unsigned long )(& scsi_read_mmc2))) {
#line 1705
      if (! ((unsigned long )d___0->read_audio == (unsigned long )(& scsi_read_mmc3))) {
#line 1705
        if (! ((unsigned long )d___0->read_audio == (unsigned long )(& scsi_read_mmcB))) {
#line 1705
          if (! ((unsigned long )d___0->read_audio == (unsigned long )(& scsi_read_mmc2B))) {
#line 1705
            if (! ((unsigned long )d___0->read_audio == (unsigned long )(& scsi_read_mmc3B))) {
              {
#line 1712
              cdmessage___8(d___0, "This command set may use a Force Unit Access bit.");
#line 1713
              cdmessage___8(d___0, "\nChecking drive for FUA bit support...\n");
#line 1715
              (*(d___0->enable_cdda))(d___0, 1);
#line 1716
              d___0->fua = 1;
#line 1718
              i = 1L;
              }
              {
#line 1718
              while (1) {
                while_continue: /* CIL Label */ ;
#line 1718
                if (! (i <= (long )d___0->tracks)) {
#line 1718
                  goto while_break;
                }
                {
#line 1719
                tmp___2 = cdda_track_audiop(d___0, (int )i);
                }
#line 1719
                if (tmp___2 == 1) {
                  {
#line 1720
                  tmp = cdda_track_firstsector(d___0, (int )i);
#line 1720
                  firstsector = tmp;
#line 1721
                  tmp___0 = cdda_track_lastsector(d___0, (int )i);
#line 1721
                  lastsector = tmp___0;
#line 1722
                  sector = (firstsector + lastsector) >> 1;
#line 1724
                  tmp___1 = (*(d___0->read_audio))(d___0, (void *)0, sector, 1L);
                  }
#line 1724
                  if (tmp___1 > 0L) {
                    {
#line 1725
                    cdmessage___8(d___0, "\tDrive accepted FUA bit.\n");
#line 1726
                    (*(d___0->enable_cdda))(d___0, 0);
                    }
#line 1727
                    return;
                  }
                }
#line 1718
                i ++;
              }
              while_break: /* CIL Label */ ;
              }
              {
#line 1732
              d___0->fua = 0;
#line 1733
              cdmessage___8(d___0, "\tDrive rejected FUA bit.\n");
              }
#line 1738
              return;
            }
          }
        }
      }
    }
  }
#line 1740
  return;
}
}
#line 1743 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
static int check_atapi___2(cdrom_drive *d___0 ) 
{ 
  int atapiret ;
  int fd ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 1744
  atapiret = -1;
#line 1745
  fd = d___0->cdda_fd;
#line 1747
  cdmessage___8(d___0, "\nChecking for SCSI emulation...\n");
#line 1749
  tmp___0 = ioctl(fd, 8707UL, & atapiret);
  }
#line 1749
  if (tmp___0) {
    {
#line 1750
    cderror___13(d___0, "\tSG_EMULATED_HOST ioctl() failed!\n");
    }
#line 1751
    return (-1);
  } else {
#line 1753
    if (atapiret == 1) {
#line 1754
      if (d___0->interface == 3) {
        {
#line 1755
        cdmessage___8(d___0, "\tDrive is ATAPI (using SG_IO host adaptor emulation)\n");
        }
      } else
#line 1756
      if (d___0->interface == 4) {
        {
#line 1757
        cdmessage___8(d___0, "\tDrive is ATAPI (using SG_IO host adaptor emulation with workarounds)\n");
        }
      } else {
        {
#line 1759
        cdmessage___8(d___0, "\tDrive is ATAPI (using SCSI host adaptor emulation)\n");
#line 1761
        tmp = ioctl(fd, 8708UL, 0);
        }
#line 1761
        if (tmp) {
          {
#line 1762
          cderror___13(d___0, "\tCouldn\'t disable kernel command translation layer\n");
          }
        }
      }
#line 1764
      d___0->is_atapi = 1;
    } else {
      {
#line 1766
      cdmessage___8(d___0, "\tDrive is SCSI\n");
#line 1767
      d___0->is_atapi = 0;
      }
    }
#line 1770
    return (d___0->is_atapi);
  }
}
}
#line 1815 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
static int check_mmc___2(cdrom_drive *d___0 ) 
{ 
  unsigned char *b ;
  int tmp ;

  {
  {
#line 1817
  cdmessage___8(d___0, "\nChecking for MMC style command set...\n");
#line 1819
  d___0->is_mmc = 0;
#line 1820
  tmp = mode_sense___2(d___0, 22, 42);
  }
#line 1820
  if (tmp == 0) {
#line 1822
    b = (d___0->private_data)->sg_buffer;
#line 1823
    b += (int )*(b + 3) + 4;
#line 1825
    if (((int )*(b + 0) & 63) == 42) {
#line 1827
      d___0->is_mmc = 1;
#line 1829
      if ((int )*(b + 1) >= 4) {
#line 1830
        if ((int )*(b + 5) & 1) {
          {
#line 1831
          cdmessage___8(d___0, "\tDrive is MMC style\n");
          }
#line 1832
          return (1);
        } else {
          {
#line 1834
          cdmessage___8(d___0, "\tDrive is MMC, but reports CDDA incapable.\n");
#line 1835
          cdmessage___8(d___0, "\tIt will likely not be able to read audio data.\n");
          }
#line 1836
          return (1);
        }
      }
    }
  }
  {
#line 1842
  cdmessage___8(d___0, "\tDrive does not have MMC CDDA support\n");
  }
#line 1843
  return (0);
}
}
#line 1846 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
static void check_exceptions___5(cdrom_drive *d___0 , exception *list ) 
{ 
  int i ;
  size_t tmp ;
  int tmp___0 ;

  {
#line 1848
  i = 0;
  {
#line 1849
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1849
    if (! (list + i)->model) {
#line 1849
      goto while_break;
    }
    {
#line 1850
    tmp = strlen((char const   *)(list + i)->model);
#line 1850
    tmp___0 = strncmp((char const   *)(list + i)->model, (char const   *)d___0->drive_model,
                      tmp);
    }
#line 1850
    if (! tmp___0) {
#line 1851
      if ((list + i)->density) {
#line 1851
        d___0->density = (list + i)->density;
      }
#line 1852
      if ((list + i)->enable) {
#line 1852
        d___0->enable_cdda = (list + i)->enable;
      }
#line 1853
      if ((list + i)->read) {
#line 1853
        d___0->read_audio = (list + i)->read;
      }
#line 1854
      if ((list + i)->bigendianp != -1) {
#line 1854
        d___0->bigendianp = (list + i)->bigendianp;
      }
#line 1855
      return;
    }
#line 1857
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1859
  return;
}
}
#line 18 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/smallft.c"
static void drfti1___2(int n , float *wa , int *ifac ) ;
#line 18 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/smallft.c"
static int ntryh___2[4]  = {      4,      2,      3,      5};
#line 19 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/smallft.c"
static float tpi___2  =    (float )6.28318530717958647692528676655900577;
#line 17 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/smallft.c"
static void drfti1___2(int n , float *wa , int *ifac ) 
{ 
  float arg ;
  float argh ;
  float argld ;
  float fi ;
  int ntry ;
  int i ;
  int j ;
  int k1 ;
  int l1 ;
  int l2 ;
  int ib ;
  int ld ;
  int ii ;
  int ip ;
  int is ;
  int nq ;
  int nr ;
  int ido ;
  int ipm ;
  int nfm1 ;
  int nl ;
  int nf ;
  int tmp ;
  double tmp___0 ;
  int tmp___1 ;
  double tmp___2 ;

  {
#line 21
  ntry = 0;
#line 21
  j = -1;
#line 25
  nl = n;
#line 26
  nf = 0;
  L101: 
#line 29
  j ++;
#line 30
  if (j < 4) {
#line 31
    ntry = ntryh___2[j];
  } else {
#line 33
    ntry += 2;
  }
  L104: 
#line 36
  nq = nl / ntry;
#line 37
  nr = nl - ntry * nq;
#line 38
  if (nr != 0) {
#line 38
    goto L101;
  }
#line 40
  nf ++;
#line 41
  *(ifac + (nf + 1)) = ntry;
#line 42
  nl = nq;
#line 43
  if (ntry != 2) {
#line 43
    goto L107;
  }
#line 44
  if (nf == 1) {
#line 44
    goto L107;
  }
#line 46
  i = 1;
  {
#line 46
  while (1) {
    while_continue: /* CIL Label */ ;
#line 46
    if (! (i < nf)) {
#line 46
      goto while_break;
    }
#line 47
    ib = (nf - i) + 1;
#line 48
    *(ifac + (ib + 1)) = *(ifac + ib);
#line 46
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 50
  *(ifac + 2) = 2;
  L107: 
#line 53
  if (nl != 1) {
#line 53
    goto L104;
  }
#line 54
  *(ifac + 0) = n;
#line 55
  *(ifac + 1) = nf;
#line 56
  argh = tpi___2 / (float )n;
#line 57
  is = 0;
#line 58
  nfm1 = nf - 1;
#line 59
  l1 = 1;
#line 61
  if (nfm1 == 0) {
#line 61
    return;
  }
#line 63
  k1 = 0;
  {
#line 63
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 63
    if (! (k1 < nfm1)) {
#line 63
      goto while_break___0;
    }
#line 64
    ip = *(ifac + (k1 + 2));
#line 65
    ld = 0;
#line 66
    l2 = l1 * ip;
#line 67
    ido = n / l2;
#line 68
    ipm = ip - 1;
#line 70
    j = 0;
    {
#line 70
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 70
      if (! (j < ipm)) {
#line 70
        goto while_break___1;
      }
#line 71
      ld += l1;
#line 72
      i = is;
#line 73
      argld = (float )ld * argh;
#line 74
      fi = (float )0.;
#line 75
      ii = 2;
      {
#line 75
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 75
        if (! (ii < ido)) {
#line 75
          goto while_break___2;
        }
        {
#line 76
        fi = (float )((double )fi + 1.);
#line 77
        arg = fi * argld;
#line 78
        tmp = i;
#line 78
        i ++;
#line 78
        tmp___0 = cos((double )arg);
#line 78
        *(wa + tmp) = (float )tmp___0;
#line 79
        tmp___1 = i;
#line 79
        i ++;
#line 79
        tmp___2 = sin((double )arg);
#line 79
        *(wa + tmp___1) = (float )tmp___2;
#line 75
        ii += 2;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
#line 81
      is += ido;
#line 70
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 83
    l1 = l2;
#line 63
    k1 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 85
  return;
}
}
#line 87 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/smallft.c"
static void fdrffti___2(int n , float *wsave , int *ifac ) 
{ 


  {
#line 89
  if (n == 1) {
#line 89
    return;
  }
  {
#line 90
  drfti1___2(n, wsave + n, ifac);
  }
#line 91
  return;
}
}
#line 93 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/smallft.c"
static void dradf2___2(int ido , int l1 , float *cc , float *ch , float *wa1 ) 
{ 
  int i ;
  int k ;
  float ti2 ;
  float tr2 ;
  int t0 ;
  int t1 ;
  int t2 ;
  int t3 ;
  int t4 ;
  int t5 ;
  int t6 ;

  {
#line 98
  t1 = 0;
#line 99
  t2 = l1 * ido;
#line 99
  t0 = t2;
#line 100
  t3 = ido << 1;
#line 101
  k = 0;
  {
#line 101
  while (1) {
    while_continue: /* CIL Label */ ;
#line 101
    if (! (k < l1)) {
#line 101
      goto while_break;
    }
#line 102
    *(ch + (t1 << 1)) = *(cc + t1) + *(cc + t2);
#line 103
    *(ch + (((t1 << 1) + t3) - 1)) = *(cc + t1) - *(cc + t2);
#line 104
    t1 += ido;
#line 105
    t2 += ido;
#line 101
    k ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 108
  if (ido < 2) {
#line 108
    return;
  }
#line 109
  if (ido == 2) {
#line 109
    goto L105;
  }
#line 111
  t1 = 0;
#line 112
  t2 = t0;
#line 113
  k = 0;
  {
#line 113
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 113
    if (! (k < l1)) {
#line 113
      goto while_break___0;
    }
#line 114
    t3 = t2;
#line 115
    t4 = (t1 << 1) + (ido << 1);
#line 116
    t5 = t1;
#line 117
    t6 = t1 + t1;
#line 118
    i = 2;
    {
#line 118
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 118
      if (! (i < ido)) {
#line 118
        goto while_break___1;
      }
#line 119
      t3 += 2;
#line 120
      t4 -= 2;
#line 121
      t5 += 2;
#line 122
      t6 += 2;
#line 123
      tr2 = *(wa1 + (i - 2)) * *(cc + (t3 - 1)) + *(wa1 + (i - 1)) * *(cc + t3);
#line 124
      ti2 = *(wa1 + (i - 2)) * *(cc + t3) - *(wa1 + (i - 1)) * *(cc + (t3 - 1));
#line 125
      *(ch + t6) = *(cc + t5) + ti2;
#line 126
      *(ch + t4) = ti2 - *(cc + t5);
#line 127
      *(ch + (t6 - 1)) = *(cc + (t5 - 1)) + tr2;
#line 128
      *(ch + (t4 - 1)) = *(cc + (t5 - 1)) - tr2;
#line 118
      i += 2;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 130
    t1 += ido;
#line 131
    t2 += ido;
#line 113
    k ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 134
  if (ido % 2 == 1) {
#line 134
    return;
  }
  L105: 
#line 137
  t1 = ido;
#line 137
  t2 = t1 - 1;
#line 137
  t3 = t2;
#line 138
  t2 += t0;
#line 139
  k = 0;
  {
#line 139
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 139
    if (! (k < l1)) {
#line 139
      goto while_break___2;
    }
#line 140
    *(ch + t1) = - *(cc + t2);
#line 141
    *(ch + (t1 - 1)) = *(cc + t3);
#line 142
    t1 += ido << 1;
#line 143
    t2 += ido;
#line 144
    t3 += ido;
#line 139
    k ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 146
  return;
}
}
#line 150
static void dradf4___2(int ido , int l1 , float *cc , float *ch , float *wa1 , float *wa2 ,
                       float *wa3 ) ;
#line 150 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/smallft.c"
static float hsqt2___2  =    (float ).70710678118654752440084436210485;
#line 148 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/smallft.c"
static void dradf4___2(int ido , int l1 , float *cc , float *ch , float *wa1 , float *wa2 ,
                       float *wa3 ) 
{ 
  int i ;
  int k ;
  int t0 ;
  int t1 ;
  int t2 ;
  int t3 ;
  int t4 ;
  int t5 ;
  int t6 ;
  float ci2 ;
  float ci3 ;
  float ci4 ;
  float cr2 ;
  float cr3 ;
  float cr4 ;
  float ti1 ;
  float ti2 ;
  float ti3 ;
  float ti4 ;
  float tr1 ;
  float tr2 ;
  float tr3 ;
  float tr4 ;

  {
#line 153
  t0 = l1 * ido;
#line 155
  t1 = t0;
#line 156
  t4 = t1 << 1;
#line 157
  t2 = t1 + (t1 << 1);
#line 158
  t3 = 0;
#line 160
  k = 0;
  {
#line 160
  while (1) {
    while_continue: /* CIL Label */ ;
#line 160
    if (! (k < l1)) {
#line 160
      goto while_break;
    }
#line 161
    tr1 = *(cc + t1) + *(cc + t2);
#line 162
    tr2 = *(cc + t3) + *(cc + t4);
#line 164
    t5 = t3 << 2;
#line 164
    *(ch + t5) = tr1 + tr2;
#line 165
    *(ch + (((ido << 2) + t5) - 1)) = tr2 - tr1;
#line 166
    t5 += ido << 1;
#line 166
    *(ch + (t5 - 1)) = *(cc + t3) - *(cc + t4);
#line 167
    *(ch + t5) = *(cc + t2) - *(cc + t1);
#line 169
    t1 += ido;
#line 170
    t2 += ido;
#line 171
    t3 += ido;
#line 172
    t4 += ido;
#line 160
    k ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 175
  if (ido < 2) {
#line 175
    return;
  }
#line 176
  if (ido == 2) {
#line 176
    goto L105;
  }
#line 179
  t1 = 0;
#line 180
  k = 0;
  {
#line 180
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 180
    if (! (k < l1)) {
#line 180
      goto while_break___0;
    }
#line 181
    t2 = t1;
#line 182
    t4 = t1 << 2;
#line 183
    t6 = ido << 1;
#line 183
    t5 = t6 + t4;
#line 184
    i = 2;
    {
#line 184
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 184
      if (! (i < ido)) {
#line 184
        goto while_break___1;
      }
#line 185
      t2 += 2;
#line 185
      t3 = t2;
#line 186
      t4 += 2;
#line 187
      t5 -= 2;
#line 189
      t3 += t0;
#line 190
      cr2 = *(wa1 + (i - 2)) * *(cc + (t3 - 1)) + *(wa1 + (i - 1)) * *(cc + t3);
#line 191
      ci2 = *(wa1 + (i - 2)) * *(cc + t3) - *(wa1 + (i - 1)) * *(cc + (t3 - 1));
#line 192
      t3 += t0;
#line 193
      cr3 = *(wa2 + (i - 2)) * *(cc + (t3 - 1)) + *(wa2 + (i - 1)) * *(cc + t3);
#line 194
      ci3 = *(wa2 + (i - 2)) * *(cc + t3) - *(wa2 + (i - 1)) * *(cc + (t3 - 1));
#line 195
      t3 += t0;
#line 196
      cr4 = *(wa3 + (i - 2)) * *(cc + (t3 - 1)) + *(wa3 + (i - 1)) * *(cc + t3);
#line 197
      ci4 = *(wa3 + (i - 2)) * *(cc + t3) - *(wa3 + (i - 1)) * *(cc + (t3 - 1));
#line 199
      tr1 = cr2 + cr4;
#line 200
      tr4 = cr4 - cr2;
#line 201
      ti1 = ci2 + ci4;
#line 202
      ti4 = ci2 - ci4;
#line 204
      ti2 = *(cc + t2) + ci3;
#line 205
      ti3 = *(cc + t2) - ci3;
#line 206
      tr2 = *(cc + (t2 - 1)) + cr3;
#line 207
      tr3 = *(cc + (t2 - 1)) - cr3;
#line 209
      *(ch + (t4 - 1)) = tr1 + tr2;
#line 210
      *(ch + t4) = ti1 + ti2;
#line 212
      *(ch + (t5 - 1)) = tr3 - ti4;
#line 213
      *(ch + t5) = tr4 - ti3;
#line 215
      *(ch + ((t4 + t6) - 1)) = ti4 + tr3;
#line 216
      *(ch + (t4 + t6)) = tr4 + ti3;
#line 218
      *(ch + ((t5 + t6) - 1)) = tr2 - tr1;
#line 219
      *(ch + (t5 + t6)) = ti1 - ti2;
#line 184
      i += 2;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 221
    t1 += ido;
#line 180
    k ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 223
  if (ido & 1) {
#line 223
    return;
  }
  L105: 
#line 227
  t1 = (t0 + ido) - 1;
#line 227
  t2 = t1 + (t0 << 1);
#line 228
  t3 = ido << 2;
#line 229
  t4 = ido;
#line 230
  t5 = ido << 1;
#line 231
  t6 = ido;
#line 233
  k = 0;
  {
#line 233
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 233
    if (! (k < l1)) {
#line 233
      goto while_break___2;
    }
#line 234
    ti1 = - hsqt2___2 * (*(cc + t1) + *(cc + t2));
#line 235
    tr1 = hsqt2___2 * (*(cc + t1) - *(cc + t2));
#line 237
    *(ch + (t4 - 1)) = tr1 + *(cc + (t6 - 1));
#line 238
    *(ch + ((t4 + t5) - 1)) = *(cc + (t6 - 1)) - tr1;
#line 240
    *(ch + t4) = ti1 - *(cc + (t1 + t0));
#line 241
    *(ch + (t4 + t5)) = ti1 + *(cc + (t1 + t0));
#line 243
    t1 += ido;
#line 244
    t2 += ido;
#line 245
    t4 += t3;
#line 246
    t6 += ido;
#line 233
    k ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 248
  return;
}
}
#line 250 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/smallft.c"
static void drftf1___2(int n , float *c , float *ch , float *wa , int *ifac ) 
{ 
  int i ;
  int k1 ;
  int l1 ;
  int l2 ;
  int na ;
  int kh ;
  int nf ;
  int ip ;
  int iw ;
  int ido ;
  int idl1 ;
  int ix2 ;
  int ix3 ;

  {
#line 255
  nf = *(ifac + 1);
#line 256
  na = 1;
#line 257
  l2 = n;
#line 258
  iw = n;
#line 260
  k1 = 0;
  {
#line 260
  while (1) {
    while_continue: /* CIL Label */ ;
#line 260
    if (! (k1 < nf)) {
#line 260
      goto while_break;
    }
#line 261
    kh = nf - k1;
#line 262
    ip = *(ifac + (kh + 1));
#line 263
    l1 = l2 / ip;
#line 264
    ido = n / l2;
#line 265
    idl1 = ido * l1;
#line 266
    iw -= (ip - 1) * ido;
#line 267
    na = 1 - na;
#line 269
    if (ip != 4) {
#line 269
      goto L102;
    }
#line 271
    ix2 = iw + ido;
#line 272
    ix3 = ix2 + ido;
#line 273
    if (na != 0) {
      {
#line 274
      dradf4___2(ido, l1, ch, c, (wa + iw) - 1, (wa + ix2) - 1, (wa + ix3) - 1);
      }
    } else {
      {
#line 276
      dradf4___2(ido, l1, c, ch, (wa + iw) - 1, (wa + ix2) - 1, (wa + ix3) - 1);
      }
    }
#line 277
    goto L110;
    L102: 
#line 280
    if (ip != 2) {
#line 280
      goto L104;
    }
#line 281
    if (na != 0) {
#line 281
      goto L103;
    }
    {
#line 283
    dradf2___2(ido, l1, c, ch, (wa + iw) - 1);
    }
#line 284
    goto L110;
    L103: 
    {
#line 287
    dradf2___2(ido, l1, ch, c, (wa + iw) - 1);
    }
#line 288
    goto L110;
    L104: 
#line 291
    return;
    L110: 
#line 294
    l2 = l1;
#line 260
    k1 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 297
  if (na == 1) {
#line 297
    return;
  }
#line 299
  i = 0;
  {
#line 299
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 299
    if (! (i < n)) {
#line 299
      goto while_break___0;
    }
#line 299
    *(c + i) = *(ch + i);
#line 299
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 300
  return;
}
}
#line 302 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/smallft.c"
static void fdrfftf___2(int n , float *r , float *wsave , int *ifac ) 
{ 


  {
#line 303
  if (n == 1) {
#line 303
    return;
  }
  {
#line 304
  drftf1___2(n, r, wsave, wsave + n, ifac);
  }
#line 305
  return;
}
}
#line 307 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/smallft.c"
static void dradb2___2(int ido , int l1 , float *cc , float *ch , float *wa1 ) 
{ 
  int i ;
  int k ;
  int t0 ;
  int t1 ;
  int t2 ;
  int t3 ;
  int t4 ;
  int t5 ;
  int t6 ;
  float ti2 ;
  float tr2 ;

  {
#line 311
  t0 = l1 * ido;
#line 313
  t1 = 0;
#line 314
  t2 = 0;
#line 315
  t3 = (ido << 1) - 1;
#line 316
  k = 0;
  {
#line 316
  while (1) {
    while_continue: /* CIL Label */ ;
#line 316
    if (! (k < l1)) {
#line 316
      goto while_break;
    }
#line 317
    *(ch + t1) = *(cc + t2) + *(cc + (t3 + t2));
#line 318
    *(ch + (t1 + t0)) = *(cc + t2) - *(cc + (t3 + t2));
#line 319
    t1 += ido;
#line 319
    t2 = t1 << 1;
#line 316
    k ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 322
  if (ido < 2) {
#line 322
    return;
  }
#line 323
  if (ido == 2) {
#line 323
    goto L105;
  }
#line 325
  t1 = 0;
#line 326
  t2 = 0;
#line 327
  k = 0;
  {
#line 327
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 327
    if (! (k < l1)) {
#line 327
      goto while_break___0;
    }
#line 328
    t3 = t1;
#line 329
    t4 = t2;
#line 329
    t5 = t4 + (ido << 1);
#line 330
    t6 = t0 + t1;
#line 331
    i = 2;
    {
#line 331
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 331
      if (! (i < ido)) {
#line 331
        goto while_break___1;
      }
#line 332
      t3 += 2;
#line 333
      t4 += 2;
#line 334
      t5 -= 2;
#line 335
      t6 += 2;
#line 336
      *(ch + (t3 - 1)) = *(cc + (t4 - 1)) + *(cc + (t5 - 1));
#line 337
      tr2 = *(cc + (t4 - 1)) - *(cc + (t5 - 1));
#line 338
      *(ch + t3) = *(cc + t4) - *(cc + t5);
#line 339
      ti2 = *(cc + t4) + *(cc + t5);
#line 340
      *(ch + (t6 - 1)) = *(wa1 + (i - 2)) * tr2 - *(wa1 + (i - 1)) * ti2;
#line 341
      *(ch + t6) = *(wa1 + (i - 2)) * ti2 + *(wa1 + (i - 1)) * tr2;
#line 331
      i += 2;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 343
    t1 += ido;
#line 343
    t2 = t1 << 1;
#line 327
    k ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 346
  if (ido % 2 == 1) {
#line 346
    return;
  }
  L105: 
#line 349
  t1 = ido - 1;
#line 350
  t2 = ido - 1;
#line 351
  k = 0;
  {
#line 351
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 351
    if (! (k < l1)) {
#line 351
      goto while_break___2;
    }
#line 352
    *(ch + t1) = *(cc + t2) + *(cc + t2);
#line 353
    *(ch + (t1 + t0)) = - (*(cc + (t2 + 1)) + *(cc + (t2 + 1)));
#line 354
    t1 += ido;
#line 355
    t2 += ido << 1;
#line 351
    k ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 357
  return;
}
}
#line 361
static void dradb4___2(int ido , int l1 , float *cc , float *ch , float *wa1 , float *wa2 ,
                       float *wa3 ) ;
#line 361 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/smallft.c"
static float sqrt2___2  =    (float )1.4142135623730950488016887242097;
#line 359 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/smallft.c"
static void dradb4___2(int ido , int l1 , float *cc , float *ch , float *wa1 , float *wa2 ,
                       float *wa3 ) 
{ 
  int i ;
  int k ;
  int t0 ;
  int t1 ;
  int t2 ;
  int t3 ;
  int t4 ;
  int t5 ;
  int t6 ;
  int t7 ;
  int t8 ;
  float ci2 ;
  float ci3 ;
  float ci4 ;
  float cr2 ;
  float cr3 ;
  float cr4 ;
  float ti1 ;
  float ti2 ;
  float ti3 ;
  float ti4 ;
  float tr1 ;
  float tr2 ;
  float tr3 ;
  float tr4 ;

  {
#line 364
  t0 = l1 * ido;
#line 366
  t1 = 0;
#line 367
  t2 = ido << 2;
#line 368
  t3 = 0;
#line 369
  t6 = ido << 1;
#line 370
  k = 0;
  {
#line 370
  while (1) {
    while_continue: /* CIL Label */ ;
#line 370
    if (! (k < l1)) {
#line 370
      goto while_break;
    }
#line 371
    t4 = t3 + t6;
#line 372
    t5 = t1;
#line 373
    tr3 = *(cc + (t4 - 1)) + *(cc + (t4 - 1));
#line 374
    tr4 = *(cc + t4) + *(cc + t4);
#line 375
    t4 += t6;
#line 375
    tr1 = *(cc + t3) - *(cc + (t4 - 1));
#line 376
    tr2 = *(cc + t3) + *(cc + (t4 - 1));
#line 377
    *(ch + t5) = tr2 + tr3;
#line 378
    t5 += t0;
#line 378
    *(ch + t5) = tr1 - tr4;
#line 379
    t5 += t0;
#line 379
    *(ch + t5) = tr2 - tr3;
#line 380
    t5 += t0;
#line 380
    *(ch + t5) = tr1 + tr4;
#line 381
    t1 += ido;
#line 382
    t3 += t2;
#line 370
    k ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 385
  if (ido < 2) {
#line 385
    return;
  }
#line 386
  if (ido == 2) {
#line 386
    goto L105;
  }
#line 388
  t1 = 0;
#line 389
  k = 0;
  {
#line 389
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 389
    if (! (k < l1)) {
#line 389
      goto while_break___0;
    }
#line 390
    t2 = t1 << 2;
#line 390
    t3 = t2 + t6;
#line 390
    t4 = t3;
#line 390
    t5 = t4 + t6;
#line 391
    t7 = t1;
#line 392
    i = 2;
    {
#line 392
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 392
      if (! (i < ido)) {
#line 392
        goto while_break___1;
      }
#line 393
      t2 += 2;
#line 394
      t3 += 2;
#line 395
      t4 -= 2;
#line 396
      t5 -= 2;
#line 397
      t7 += 2;
#line 398
      ti1 = *(cc + t2) + *(cc + t5);
#line 399
      ti2 = *(cc + t2) - *(cc + t5);
#line 400
      ti3 = *(cc + t3) - *(cc + t4);
#line 401
      tr4 = *(cc + t3) + *(cc + t4);
#line 402
      tr1 = *(cc + (t2 - 1)) - *(cc + (t5 - 1));
#line 403
      tr2 = *(cc + (t2 - 1)) + *(cc + (t5 - 1));
#line 404
      ti4 = *(cc + (t3 - 1)) - *(cc + (t4 - 1));
#line 405
      tr3 = *(cc + (t3 - 1)) + *(cc + (t4 - 1));
#line 406
      *(ch + (t7 - 1)) = tr2 + tr3;
#line 407
      cr3 = tr2 - tr3;
#line 408
      *(ch + t7) = ti2 + ti3;
#line 409
      ci3 = ti2 - ti3;
#line 410
      cr2 = tr1 - tr4;
#line 411
      cr4 = tr1 + tr4;
#line 412
      ci2 = ti1 + ti4;
#line 413
      ci4 = ti1 - ti4;
#line 415
      t8 = t7 + t0;
#line 415
      *(ch + (t8 - 1)) = *(wa1 + (i - 2)) * cr2 - *(wa1 + (i - 1)) * ci2;
#line 416
      *(ch + t8) = *(wa1 + (i - 2)) * ci2 + *(wa1 + (i - 1)) * cr2;
#line 417
      t8 += t0;
#line 417
      *(ch + (t8 - 1)) = *(wa2 + (i - 2)) * cr3 - *(wa2 + (i - 1)) * ci3;
#line 418
      *(ch + t8) = *(wa2 + (i - 2)) * ci3 + *(wa2 + (i - 1)) * cr3;
#line 419
      t8 += t0;
#line 419
      *(ch + (t8 - 1)) = *(wa3 + (i - 2)) * cr4 - *(wa3 + (i - 1)) * ci4;
#line 420
      *(ch + t8) = *(wa3 + (i - 2)) * ci4 + *(wa3 + (i - 1)) * cr4;
#line 392
      i += 2;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 422
    t1 += ido;
#line 389
    k ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 425
  if (ido % 2 == 1) {
#line 425
    return;
  }
  L105: 
#line 429
  t1 = ido;
#line 430
  t2 = ido << 2;
#line 431
  t3 = ido - 1;
#line 432
  t4 = ido + (ido << 1);
#line 433
  k = 0;
  {
#line 433
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 433
    if (! (k < l1)) {
#line 433
      goto while_break___2;
    }
#line 434
    t5 = t3;
#line 435
    ti1 = *(cc + t1) + *(cc + t4);
#line 436
    ti2 = *(cc + t4) - *(cc + t1);
#line 437
    tr1 = *(cc + (t1 - 1)) - *(cc + (t4 - 1));
#line 438
    tr2 = *(cc + (t1 - 1)) + *(cc + (t4 - 1));
#line 439
    *(ch + t5) = tr2 + tr2;
#line 440
    t5 += t0;
#line 440
    *(ch + t5) = sqrt2___2 * (tr1 - ti1);
#line 441
    t5 += t0;
#line 441
    *(ch + t5) = ti2 + ti2;
#line 442
    t5 += t0;
#line 442
    *(ch + t5) = - sqrt2___2 * (tr1 + ti1);
#line 444
    t3 += ido;
#line 445
    t1 += t2;
#line 446
    t4 += t2;
#line 433
    k ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 448
  return;
}
}
#line 450 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/smallft.c"
static void drftb1___2(int n , float *c , float *ch , float *wa , int *ifac ) 
{ 
  int i ;
  int k1 ;
  int l1 ;
  int l2 ;
  int na ;
  int nf ;
  int ip ;
  int iw ;
  int ix2 ;
  int ix3 ;
  int ido ;
  int idl1 ;

  {
#line 455
  nf = *(ifac + 1);
#line 456
  na = 0;
#line 457
  l1 = 1;
#line 458
  iw = 1;
#line 460
  k1 = 0;
  {
#line 460
  while (1) {
    while_continue: /* CIL Label */ ;
#line 460
    if (! (k1 < nf)) {
#line 460
      goto while_break;
    }
#line 461
    ip = *(ifac + (k1 + 2));
#line 462
    l2 = ip * l1;
#line 463
    ido = n / l2;
#line 464
    idl1 = ido * l1;
#line 465
    if (ip != 4) {
#line 465
      goto L103;
    }
#line 466
    ix2 = iw + ido;
#line 467
    ix3 = ix2 + ido;
#line 469
    if (na != 0) {
      {
#line 470
      dradb4___2(ido, l1, ch, c, (wa + iw) - 1, (wa + ix2) - 1, (wa + ix3) - 1);
      }
    } else {
      {
#line 472
      dradb4___2(ido, l1, c, ch, (wa + iw) - 1, (wa + ix2) - 1, (wa + ix3) - 1);
      }
    }
#line 473
    na = 1 - na;
#line 474
    goto L115;
    L103: 
#line 477
    if (ip != 2) {
#line 477
      goto L106;
    }
#line 479
    if (na != 0) {
      {
#line 480
      dradb2___2(ido, l1, ch, c, (wa + iw) - 1);
      }
    } else {
      {
#line 482
      dradb2___2(ido, l1, c, ch, (wa + iw) - 1);
      }
    }
#line 483
    na = 1 - na;
#line 484
    goto L115;
    L106: 
#line 487
    return;
    L115: 
#line 490
    l1 = l2;
#line 491
    iw += (ip - 1) * ido;
#line 460
    k1 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 494
  if (na == 0) {
#line 494
    return;
  }
#line 496
  i = 0;
  {
#line 496
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 496
    if (! (i < n)) {
#line 496
      goto while_break___0;
    }
#line 496
    *(c + i) = *(ch + i);
#line 496
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 497
  return;
}
}
#line 499 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/smallft.c"
static void fdrfftb___2(int n , float *r , float *wsave , int *ifac ) 
{ 


  {
#line 500
  if (n == 1) {
#line 500
    return;
  }
  {
#line 501
  drftb1___2(n, r, wsave, wsave + n, ifac);
  }
#line 502
  return;
}
}
#line 141 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/utils.h"
static void idperror___2(int messagedest , char **messages , char const   *f , char const   *s ) 
{ 
  char *buffer ;
  int malloced ;
  size_t tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  size_t tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  size_t tmp___5 ;
  int *tmp___6 ;
  char *tmp___7 ;
  int *tmp___8 ;
  int *tmp___9 ;
  char *tmp___10 ;
  int *tmp___11 ;

  {
#line 145
  malloced = 0;
#line 146
  if (! f) {
#line 147
    buffer = (char *)s;
  } else
#line 149
  if (! s) {
#line 150
    buffer = (char *)f;
  } else {
    {
#line 152
    tmp = strlen(f);
#line 152
    tmp___0 = strlen(s);
#line 152
    tmp___1 = malloc((tmp + tmp___0) + 9UL);
#line 152
    buffer = (char *)tmp___1;
#line 153
    sprintf((char */* __restrict  */)buffer, (char const   */* __restrict  */)f, s);
#line 154
    malloced = 1;
    }
  }
#line 157
  if (buffer) {
    {
#line 159
    if (messagedest == 1) {
#line 159
      goto case_1;
    }
#line 167
    if (messagedest == 2) {
#line 167
      goto case_2;
    }
#line 178
    goto switch_default;
    case_1: /* CIL Label */ 
    {
#line 160
    tmp___2 = strlen((char const   *)buffer);
#line 160
    write(2, (void const   *)buffer, tmp___2);
#line 161
    tmp___8 = __errno_location();
    }
#line 161
    if (*tmp___8) {
      {
#line 162
      write(2, (void const   *)": ", (size_t )2);
#line 163
      tmp___3 = __errno_location();
#line 163
      tmp___4 = strerror(*tmp___3);
#line 163
      tmp___5 = strlen((char const   *)tmp___4);
#line 163
      tmp___6 = __errno_location();
#line 163
      tmp___7 = strerror(*tmp___6);
#line 163
      write(2, (void const   *)tmp___7, tmp___5);
#line 164
      write(2, (void const   *)"\n", (size_t )1);
      }
    }
#line 166
    goto switch_break;
    case_2: /* CIL Label */ 
#line 168
    if (messages) {
      {
#line 169
      *messages = catstring(*messages, (char const   *)buffer);
#line 170
      tmp___11 = __errno_location();
      }
#line 170
      if (*tmp___11) {
        {
#line 171
        *messages = catstring(*messages, ": ");
#line 172
        tmp___9 = __errno_location();
#line 172
        tmp___10 = strerror(*tmp___9);
#line 172
        *messages = catstring(*messages, (char const   *)tmp___10);
#line 173
        *messages = catstring(*messages, "\n");
        }
      }
    }
#line 176
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 179
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
#line 182
  if (malloced) {
    {
#line 182
    free((void *)buffer);
    }
  }
#line 183
  return;
}
}
#line 186 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/utils.h"
static void idmessage___2(int messagedest , char **messages , char const   *f , char const   *s ) 
{ 
  char *buffer ;
  int malloced ;
  size_t tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  size_t tmp___2 ;

  {
#line 189
  malloced = 0;
#line 190
  if (! f) {
#line 191
    buffer = (char *)s;
  } else
#line 193
  if (! s) {
#line 194
    buffer = (char *)f;
  } else {
    {
#line 196
    tmp = strlen(f);
#line 196
    tmp___0 = strlen(s);
#line 196
    tmp___1 = malloc((tmp + tmp___0) + 10UL);
#line 196
    buffer = (char *)tmp___1;
#line 197
    sprintf((char */* __restrict  */)buffer, (char const   */* __restrict  */)f, s);
#line 198
    strcat((char */* __restrict  */)buffer, (char const   */* __restrict  */)"\n");
#line 199
    malloced = 1;
    }
  }
#line 202
  if (buffer) {
    {
#line 204
    if (messagedest == 1) {
#line 204
      goto case_1;
    }
#line 208
    if (messagedest == 2) {
#line 208
      goto case_2;
    }
#line 215
    goto switch_default;
    case_1: /* CIL Label */ 
    {
#line 205
    tmp___2 = strlen((char const   *)buffer);
#line 205
    write(2, (void const   *)buffer, tmp___2);
    }
#line 206
    if (! malloced) {
      {
#line 206
      write(2, (void const   *)"\n", (size_t )1);
      }
    }
#line 207
    goto switch_break;
    case_2: /* CIL Label */ 
#line 209
    if (messages) {
      {
#line 210
      *messages = catstring(*messages, (char const   *)buffer);
      }
#line 211
      if (! malloced) {
        {
#line 211
        *messages = catstring(*messages, "\n");
        }
      }
    }
#line 213
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 216
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
#line 219
  if (malloced) {
    {
#line 219
    free((void *)buffer);
    }
  }
#line 220
  return;
}
}
#line 29 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/scan_devices.c"
static char *scsi_cdrom_prefixes___2[3]  = {      (char *)"/dev/scd",      (char *)"/dev/sr",      (char *)((void *)0)};
#line 33 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/scan_devices.c"
static char *scsi_generic_prefixes___2[2]  = {      (char *)"/dev/sg",      (char *)((void *)0)};
#line 37 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/scan_devices.c"
static char *devfs_scsi_test___2  =    (char *)"/dev/scsi/";
#line 38 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/scan_devices.c"
static char *devfs_scsi_cd___2  =    (char *)"cd";
#line 39 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/scan_devices.c"
static char *devfs_scsi_generic___2  =    (char *)"generic";
#line 41 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/scan_devices.c"
static char *cdrom_devices___2[15]  = 
#line 41
  {      (char *)"/dev/cdrom",      (char *)"/dev/cdroms/cdrom?",      (char *)"/dev/hd?",      (char *)"/dev/sg?", 
        (char *)"/dev/cdu31a",      (char *)"/dev/cdu535",      (char *)"/dev/sbpcd",      (char *)"/dev/sbpcd?", 
        (char *)"/dev/sonycd",      (char *)"/dev/mcd",      (char *)"/dev/sjcd",      (char *)"/dev/cm206cd", 
        (char *)"/dev/gscd",      (char *)"/dev/optcd",      (char *)((void *)0)};
#line 367 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/scan_devices.c"
static int get_scsi_id___2(int fd , scsiid *id ) 
{ 
  struct sg_id argid ;
  int busarg ;
  int tmp ;
  int tmp___0 ;

  {
#line 373
  if (fd == -1) {
#line 373
    return (-1);
  }
  {
#line 374
  tmp = ioctl(fd, 21378UL, & argid);
  }
#line 374
  if (tmp) {
#line 374
    return (-1);
  }
  {
#line 375
  id->bus = (int )argid.l2;
#line 376
  id->id = (int )(argid.l1 & 255L);
#line 377
  id->lun = (int )((argid.l1 >> 8) & 255L);
#line 379
  tmp___0 = ioctl(fd, 21382UL, & busarg);
  }
#line 379
  if (tmp___0 == 0) {
#line 380
    id->bus = busarg;
  }
#line 382
  return (0);
}
}
#line 386 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/scan_devices.c"
static char *scsi_match___2(char const   *device , char **prefixes , char *devfs_test ,
                            char *devfs_other , char *prompt , int messagedest , char **messages ) 
{ 
  int dev ;
  int tmp ;
  scsiid a ;
  scsiid b ;
  int i ;
  int j ;
  char buffer[200] ;
  char *pos ;
  int matchf ;
  int *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int pattern ;
  int matchf___0 ;
  int k ;
  int *tmp___7 ;
  char *tmp___8 ;
  int tmp___9 ;
  char *tmp___10 ;
  int tmp___11 ;

  {
  {
#line 390
  tmp = open(device, 2048);
#line 390
  dev = tmp;
#line 398
  tmp___4 = strlen((char const   *)devfs_test);
#line 398
  tmp___5 = strncmp(device, (char const   *)devfs_test, tmp___4);
  }
#line 398
  if (! tmp___5) {
    {
#line 400
    strcpy((char */* __restrict  */)(buffer), (char const   */* __restrict  */)device);
#line 401
    pos = strrchr((char const   *)(buffer), '/');
    }
#line 402
    if (pos) {
      {
#line 404
      sprintf((char */* __restrict  */)pos, (char const   */* __restrict  */)"/%s",
              devfs_other);
#line 405
      matchf = open((char const   *)(buffer), 2048);
#line 406
      i = 0;
      }
      {
#line 406
      while (1) {
        while_continue: /* CIL Label */ ;
#line 406
        if (i < 10) {
#line 406
          if (! (matchf == -1)) {
#line 406
            goto while_break;
          }
        } else {
#line 406
          goto while_break;
        }
        {
#line 407
        tmp___0 = __errno_location();
#line 407
        tmp___1 = strerror(*tmp___0);
#line 407
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error trying to open %s exclusively (%s). retrying in 1 seconds.\n",
                buffer, tmp___1);
#line 408
        tmp___2 = rand();
#line 408
        usleep((__useconds_t )((double )1000000 + (100000.0 * (double )tmp___2) / ((double )2147483647 + 1.0)));
#line 409
        matchf = open((char const   *)(buffer), 2048);
#line 406
        i ++;
        }
      }
      while_break: /* CIL Label */ ;
      }
#line 411
      if (matchf != -1) {
        {
#line 412
        close(matchf);
#line 413
        close(dev);
#line 414
        tmp___3 = strdup((char const   *)(buffer));
        }
#line 414
        return (tmp___3);
      }
    }
  }
#line 420
  if (dev == -1) {
    {
#line 421
    idperror___2(messagedest, messages, "\t\tCould not access device %s", device);
    }
#line 424
    goto matchfail;
  }
  {
#line 426
  tmp___6 = get_scsi_id___2(dev, & a);
  }
#line 426
  if (tmp___6) {
    {
#line 427
    idperror___2(messagedest, messages, "\t\tDevice %s could not perform ioctl()",
                 device);
    }
#line 430
    goto matchfail;
  }
#line 434
  i = 0;
  {
#line 434
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 434
    if (! (i < 25)) {
#line 434
      goto while_break___0;
    }
#line 435
    j = 0;
    {
#line 435
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 435
      if (! (j < 2)) {
#line 435
        goto while_break___1;
      }
#line 436
      pattern = 0;
      {
#line 439
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 439
        if (! ((unsigned long )*(prefixes + pattern) != (unsigned long )((void *)0))) {
#line 439
          goto while_break___2;
        }
        {
#line 441
        if (j == 0) {
#line 441
          goto case_0;
        }
#line 445
        if (j == 1) {
#line 445
          goto case_1;
        }
#line 440
        goto switch_break;
        case_0: /* CIL Label */ 
        {
#line 443
        sprintf((char */* __restrict  */)(buffer), (char const   */* __restrict  */)"%s%d",
                *(prefixes + pattern), i);
        }
#line 444
        goto switch_break;
        case_1: /* CIL Label */ 
        {
#line 447
        sprintf((char */* __restrict  */)(buffer), (char const   */* __restrict  */)"%s%c",
                *(prefixes + pattern), i + 97);
        }
#line 448
        goto switch_break;
        switch_break: /* CIL Label */ ;
        }
        {
#line 451
        matchf___0 = open((char const   *)(buffer), 2048);
#line 452
        k = 0;
        }
        {
#line 452
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 452
          if (k < 10) {
#line 452
            if (! (matchf___0 == -1)) {
#line 452
              goto while_break___3;
            }
          } else {
#line 452
            goto while_break___3;
          }
          {
#line 453
          tmp___7 = __errno_location();
#line 453
          tmp___8 = strerror(*tmp___7);
#line 453
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error trying to open %s exclusively (%s). retrying in 1 second.\n",
                  buffer, tmp___8);
#line 454
          tmp___9 = rand();
#line 454
          usleep((__useconds_t )((double )1000000 + (100000.0 * (double )tmp___9) / ((double )2147483647 + 1.0)));
#line 455
          matchf___0 = open((char const   *)(buffer), 2048);
#line 452
          k ++;
          }
        }
        while_break___3: /* CIL Label */ ;
        }
#line 458
        if (matchf___0 != -1) {
          {
#line 459
          tmp___11 = get_scsi_id___2(matchf___0, & b);
          }
#line 459
          if (tmp___11 == 0) {
#line 460
            if (a.bus == b.bus) {
#line 460
              if (a.id == b.id) {
#line 460
                if (a.lun == b.lun) {
                  {
#line 461
                  close(matchf___0);
#line 462
                  close(dev);
#line 463
                  tmp___10 = strdup((char const   *)(buffer));
                  }
#line 463
                  return (tmp___10);
                }
              }
            }
          }
          {
#line 466
          close(matchf___0);
          }
        }
#line 468
        pattern ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 435
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 434
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 473
  idmessage___2(messagedest, messages, (char const   *)prompt, device);
  }
  matchfail: 
#line 477
  if (dev != -1) {
    {
#line 477
    close(dev);
    }
  }
#line 478
  return ((char *)((void *)0));
}
}
#line 495 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/scan_devices.c"
static int verify_SG_version___2(cdrom_drive *d___0 , int messagedest , char **messages ) 
{ 
  int version ;
  int major ;
  int minor ;
  char buffer[256] ;
  int tmp ;

  {
  {
#line 500
  idmessage___2(messagedest, messages, "\nFound an accessible SCSI CDROM drive.\nLooking at revision of the SG interface in use...",
                "");
#line 504
  tmp = ioctl(d___0->cdda_fd, 8834UL, & version);
  }
#line 504
  if (tmp) {
    {
#line 506
    idmessage___2(messagedest, messages, "\tOOPS!  Old 2.0/early 2.1/early 2.2.x (non-ac patch) style SG.\n\tCdparanoia no longer supports the old interface.\n",
                  "");
    }
#line 509
    return (0);
  }
  {
#line 511
  major = version / 10000;
#line 512
  version -= major * 10000;
#line 513
  minor = version / 100;
#line 514
  version -= minor * 100;
#line 516
  sprintf((char */* __restrict  */)(buffer), (char const   */* __restrict  */)"\tSG interface version %d.%d.%d; OK.",
          major, minor, version);
#line 519
  idmessage___2(messagedest, messages, (char const   *)(buffer), "");
  }
#line 520
  return (major);
}
}
#line 125 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/utils.h"
static void cdmessage___9(cdrom_drive *d___0 , char const   *s ) 
{ 
  size_t tmp ;

  {
#line 126
  if (s) {
#line 126
    if (d___0) {
      {
#line 128
      if (d___0->messagedest == 1) {
#line 128
        goto case_1;
      }
#line 131
      if (d___0->messagedest == 2) {
#line 131
        goto case_2;
      }
#line 135
      goto switch_default;
      case_1: /* CIL Label */ 
      {
#line 129
      tmp = strlen(s);
#line 129
      write(2, (void const   *)s, tmp);
      }
#line 130
      goto switch_break;
      case_2: /* CIL Label */ 
      {
#line 132
      d___0->messagebuf = catstring(d___0->messagebuf, s);
      }
#line 133
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 136
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
  }
#line 139
  return;
}
}
#line 109 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/utils.h"
static void cderror___14(cdrom_drive *d___0 , char const   *s ) 
{ 
  size_t tmp ;

  {
#line 110
  if (s) {
#line 110
    if (d___0) {
      {
#line 112
      if (d___0->errordest == 1) {
#line 112
        goto case_1;
      }
#line 115
      if (d___0->errordest == 2) {
#line 115
        goto case_2;
      }
#line 119
      goto switch_default;
      case_1: /* CIL Label */ 
      {
#line 113
      tmp = strlen(s);
#line 113
      write(2, (void const   *)s, tmp);
      }
#line 114
      goto switch_break;
      case_2: /* CIL Label */ 
      {
#line 116
      d___0->errorbuf = catstring(d___0->errorbuf, s);
      }
#line 117
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 120
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
  }
#line 123
  return;
}
}
#line 125 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/utils.h"
static void cdmessage___10(cdrom_drive *d___0 , char const   *s ) 
{ 
  size_t tmp ;

  {
#line 126
  if (s) {
#line 126
    if (d___0) {
      {
#line 128
      if (d___0->messagedest == 1) {
#line 128
        goto case_1;
      }
#line 131
      if (d___0->messagedest == 2) {
#line 131
        goto case_2;
      }
#line 135
      goto switch_default;
      case_1: /* CIL Label */ 
      {
#line 129
      tmp = strlen(s);
#line 129
      write(2, (void const   *)s, tmp);
      }
#line 130
      goto switch_break;
      case_2: /* CIL Label */ 
      {
#line 132
      d___0->messagebuf = catstring(d___0->messagebuf, s);
      }
#line 133
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 136
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
  }
#line 139
  return;
}
}
#line 15 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/cooked_interface.c"
static int timed_ioctl___6(cdrom_drive *d___0 , int fd , int command , void *arg ) 
{ 
  struct timespec tv1 ;
  struct timespec tv2 ;
  int ret1 ;
  int tmp ;
  int ret2 ;
  int tmp___0 ;
  int ret3 ;
  int tmp___1 ;

  {
  {
#line 18
  tmp = clock_gettime((d___0->private_data)->clock, & tv1);
#line 18
  ret1 = tmp;
#line 19
  tmp___0 = ioctl(fd, (unsigned long )command, arg);
#line 19
  ret2 = tmp___0;
#line 20
  tmp___1 = clock_gettime((d___0->private_data)->clock, & tv2);
#line 20
  ret3 = tmp___1;
  }
#line 21
  if (ret1 < 0) {
#line 22
    (d___0->private_data)->last_milliseconds = -1;
  } else
#line 21
  if (ret3 < 0) {
#line 22
    (d___0->private_data)->last_milliseconds = -1;
  } else {
#line 24
    (d___0->private_data)->last_milliseconds = (int )((double )(tv2.tv_sec - tv1.tv_sec) * 1000. + (double )(tv2.tv_nsec - tv1.tv_nsec) / 1000000.);
  }
#line 26
  return (ret2);
}
}
#line 30 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/cooked_interface.c"
static int cooked_readtoc___2(cdrom_drive *d___0 ) 
{ 
  int i ;
  int tracks ;
  struct cdrom_tochdr hdr ;
  struct cdrom_tocentry entry ;
  int *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 37
  tmp___0 = ioctl(d___0->ioctl_fd, 21253UL, & hdr);
  }
#line 37
  if (tmp___0) {
    {
#line 38
    tmp = __errno_location();
    }
    {
#line 39
    if (*tmp == 1) {
#line 39
      goto case_1;
    }
#line 42
    goto switch_default;
    case_1: /* CIL Label */ 
    {
#line 40
    cderror___14(d___0, "102: Permision denied on cdrom (ioctl) device\n");
    }
#line 41
    return (-102);
    switch_default: /* CIL Label */ 
    {
#line 43
    cderror___14(d___0, "004: Unable to read table of contents header\n");
    }
#line 44
    return (-4);
    switch_break: /* CIL Label */ ;
    }
  }
#line 48
  i = 0;
  {
#line 48
  while (1) {
    while_continue: /* CIL Label */ ;
#line 48
    if (! (i < (int )hdr.cdth_trk1)) {
#line 48
      goto while_break;
    }
    {
#line 49
    entry.cdte_track = (__u8 )(i + 1);
#line 50
    entry.cdte_format = (__u8 )1;
#line 51
    tmp___1 = ioctl(d___0->ioctl_fd, 21254UL, & entry);
    }
#line 51
    if (tmp___1) {
      {
#line 52
      cderror___14(d___0, "005: Unable to read table of contents entry\n");
      }
#line 53
      return (-5);
    }
#line 56
    d___0->disc_toc[i].bFlags = (unsigned char )(((int )entry.cdte_adr << 4) | ((int )entry.cdte_ctrl & 15));
#line 57
    d___0->disc_toc[i].bTrack = (unsigned char )(i + 1);
#line 58
    d___0->disc_toc[i].dwStartSector = entry.cdte_addr.lba;
#line 48
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 61
  entry.cdte_track = (__u8 )170;
#line 62
  entry.cdte_format = (__u8 )1;
#line 63
  tmp___2 = ioctl(d___0->ioctl_fd, 21254UL, & entry);
  }
#line 63
  if (tmp___2) {
    {
#line 64
    cderror___14(d___0, "005: Unable to read table of contents entry\n");
    }
#line 65
    return (-5);
  }
  {
#line 67
  d___0->disc_toc[i].bFlags = (unsigned char )(((int )entry.cdte_adr << 4) | ((int )entry.cdte_ctrl & 15));
#line 68
  d___0->disc_toc[i].bTrack = entry.cdte_track;
#line 69
  d___0->disc_toc[i].dwStartSector = entry.cdte_addr.lba;
#line 71
  tracks = (int )hdr.cdth_trk1 + 1;
#line 72
  d___0->cd_extra = FixupTOC(d___0, tracks);
#line 73
  tracks --;
  }
#line 73
  return (tracks);
}
}
#line 77 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/cooked_interface.c"
static int cooked_setspeed___2(cdrom_drive *d___0 , int speed ) 
{ 
  int tmp ;

  {
#line 79
  if (d___0->ioctl_fd != -1) {
    {
#line 80
    tmp = ioctl(d___0->ioctl_fd, 21282UL, speed);
    }
#line 80
    return (tmp);
  } else {
#line 82
    return (0);
  }
}
}
#line 89 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/cooked_interface.c"
static long cooked_read___2(cdrom_drive *d___0 , void *p___0 , long begin , long sectors ) 
{ 
  int retry_count ;
  int err ;
  int ret ;
  struct cdrom_read_audio arg ;
  char *buffer ;
  void *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  char b[256] ;

  {
#line 90
  ret = 0;
#line 92
  buffer = (char *)p___0;
#line 95
  if (sectors > (long )d___0->nsectors) {
#line 95
    sectors = (long )d___0->nsectors;
  } else {
#line 95
    sectors = sectors;
  }
#line 96
  if ((unsigned long )p___0 == (unsigned long )((void *)0)) {
    {
#line 96
    tmp = malloc((size_t )(sectors * 2352L));
#line 96
    buffer = (char *)tmp;
    }
  }
#line 98
  arg.addr.lba = (int )begin;
#line 99
  arg.addr_format = (__u8 )1;
#line 100
  arg.nframes = (int )sectors;
#line 101
  arg.buf = (__u8 *)buffer;
#line 102
  retry_count = 0;
  {
#line 104
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 105
    err = timed_ioctl___6(d___0, d___0->ioctl_fd, 21262, (void *)(& arg));
    }
#line 105
    if (err) {
#line 106
      if (! d___0->error_retry) {
#line 107
        ret = -7;
#line 108
        goto done;
      }
      {
#line 110
      tmp___0 = __errno_location();
      }
      {
#line 111
      if (*tmp___0 == 12) {
#line 111
        goto case_12;
      }
#line 121
      if (*tmp___0 == 123) {
#line 121
        goto case_123;
      }
#line 121
      if (*tmp___0 == 9) {
#line 121
        goto case_123;
      }
#line 121
      if (*tmp___0 == 6) {
#line 121
        goto case_123;
      }
#line 125
      goto switch_default;
      case_12: /* CIL Label */ 
#line 113
      if (sectors == 1L) {
        {
#line 115
        cderror___14(d___0, "300: Kernel memory error\n");
#line 116
        ret = -300;
        }
#line 117
        goto done;
      }
      case_123: /* CIL Label */ 
      case_9: /* CIL Label */ 
      case_6: /* CIL Label */ 
      {
#line 122
      tmp___1 = __errno_location();
#line 122
      *tmp___1 = 123;
#line 123
      ret = 0;
      }
#line 124
      goto done;
      switch_default: /* CIL Label */ 
#line 126
      if (sectors == 1L) {
#line 132
        if (retry_count > 7) {
          {
#line 134
          sprintf((char */* __restrict  */)(b), (char const   */* __restrict  */)"010: Unable to access sector %ld: skipping...\n",
                  begin);
#line 136
          cderror___14(d___0, (char const   *)(b));
#line 137
          ret = -10;
          }
#line 138
          goto done;
        }
#line 140
        goto switch_break;
      }
      switch_break: /* CIL Label */ ;
      }
#line 143
      if (retry_count > 4) {
#line 144
        if (sectors > 1L) {
#line 145
          sectors = (sectors * 3L) / 4L;
        }
      }
#line 146
      retry_count ++;
#line 147
      if (retry_count > 8) {
        {
#line 148
        cderror___14(d___0, "007: Unknown, unrecoverable error reading data\n");
#line 149
        ret = -7;
        }
#line 150
        goto done;
      }
    } else {
#line 153
      goto while_break;
    }
#line 104
    if (! err) {
#line 104
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 156
  ret = (int )sectors;
  done: 
#line 159
  if ((unsigned long )p___0 == (unsigned long )((void *)0)) {
#line 159
    if (buffer) {
      {
#line 159
      free((void *)buffer);
      }
    }
  }
#line 160
  return ((long )ret);
}
}
#line 298 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/cooked_interface.c"
static int Dummy___6(cdrom_drive *d___0 , int Switch ) 
{ 


  {
#line 299
  return (0);
}
}
#line 302 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/cooked_interface.c"
static int verify_read_command___6(cdrom_drive *d___0 ) 
{ 
  int i ;
  int16_t *buff ;
  void *tmp ;
  int audioflag ;
  long firstsector ;
  long tmp___0 ;
  long lastsector ;
  long tmp___1 ;
  long sector ;
  long tmp___2 ;
  int tmp___3 ;

  {
  {
#line 304
  tmp = malloc((size_t )2352);
#line 304
  buff = (int16_t *)tmp;
#line 305
  audioflag = 0;
#line 307
  cdmessage___10(d___0, "Verifying drive can read CDDA...\n");
#line 309
  (*(d___0->enable_cdda))(d___0, 1);
#line 311
  i = 1;
  }
  {
#line 311
  while (1) {
    while_continue: /* CIL Label */ ;
#line 311
    if (! (i <= d___0->tracks)) {
#line 311
      goto while_break;
    }
    {
#line 312
    tmp___3 = cdda_track_audiop(d___0, i);
    }
#line 312
    if (tmp___3 == 1) {
      {
#line 313
      tmp___0 = cdda_track_firstsector(d___0, i);
#line 313
      firstsector = tmp___0;
#line 314
      tmp___1 = cdda_track_lastsector(d___0, i);
#line 314
      lastsector = tmp___1;
#line 315
      sector = (firstsector + lastsector) >> 1;
#line 316
      audioflag = 1;
#line 318
      tmp___2 = (*(d___0->read_audio))(d___0, (void *)buff, sector, 1L);
      }
#line 318
      if (tmp___2 > 0L) {
        {
#line 319
        cdmessage___10(d___0, "\tExpected command set reads OK.\n");
#line 320
        (*(d___0->enable_cdda))(d___0, 0);
#line 321
        free((void *)buff);
        }
#line 322
        return (0);
      }
    }
#line 311
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 327
  (*(d___0->enable_cdda))(d___0, 0);
  }
#line 329
  if (! audioflag) {
    {
#line 330
    cdmessage___10(d___0, "\tCould not find any audio tracks on this disk.\n");
    }
#line 331
    return (-403);
  }
  {
#line 334
  cdmessage___10(d___0, "\n\tUnable to read any data; drive probably not CDDA capable.\n");
#line 337
  cderror___14(d___0, "006: Could not read any data from drive\n");
#line 339
  free((void *)buff);
  }
#line 340
  return (-6);
}
}
#line 24 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/drive_exceptions.h"
static exception atapi_list___6[5]  = {      {(char *)"SAMSUNG SCR-830 REV 2.09 2.09 ", 1, (unsigned char)0, & Dummy___6,
      & scsi_read_mmc2, 0}, 
        {(char *)"Memorex CR-622", 1, (unsigned char)0, & Dummy___6, (long (*)(struct cdrom_drive * ,
                                                                            void * ,
                                                                            long  ,
                                                                            long  ))((void *)0),
      0}, 
        {(char *)"SONY CD-ROM CDU-561", 0, (unsigned char)0, & Dummy___6, (long (*)(struct cdrom_drive * ,
                                                                                 void * ,
                                                                                 long  ,
                                                                                 long  ))((void *)0),
      0}, 
        {(char *)"Chinon CD-ROM CDS-525", 0, (unsigned char)0, & Dummy___6, (long (*)(struct cdrom_drive * ,
                                                                                   void * ,
                                                                                   long  ,
                                                                                   long  ))((void *)0),
      0}, 
        {(char *)((void *)0), 0, (unsigned char)0, (int (*)(struct cdrom_drive * , int  ))((void *)0),
      (long (*)(struct cdrom_drive * , void * , long  , long  ))((void *)0), 0}};
#line 345 "/home/june/repo/benchmarks/collector/temp/cdparanoia-3.10.2+debian/interface/cooked_interface.c"
static void check_exceptions___6(cdrom_drive *d___0 , exception *list ) 
{ 
  int i ;
  size_t tmp ;
  int tmp___0 ;

  {
#line 347
  i = 0;
  {
#line 348
  while (1) {
    while_continue: /* CIL Label */ ;
#line 348
    if (! (list + i)->model) {
#line 348
      goto while_break;
    }
    {
#line 349
    tmp = strlen((char const   *)(list + i)->model);
#line 349
    tmp___0 = strncmp((char const   *)(list + i)->model, (char const   *)d___0->drive_model,
                      tmp);
    }
#line 349
    if (! tmp___0) {
#line 350
      if ((list + i)->bigendianp != -1) {
#line 350
        d___0->bigendianp = (list + i)->bigendianp;
      }
#line 351
      return;
    }
#line 353
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 355
  return;
}
}
