/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 211 "/usr/lib/gcc/i486-linux-gnu/4.4.3/include/stddef.h"
typedef unsigned int size_t;
#line 56 "/usr/include/bits/types.h"
typedef long long __quad_t;
#line 141 "/usr/include/bits/types.h"
typedef long __off_t;
#line 142 "/usr/include/bits/types.h"
typedef __quad_t __off64_t;
#line 149 "/usr/include/bits/types.h"
typedef long __time_t;
#line 151 "/usr/include/bits/types.h"
typedef long __suseconds_t;
#line 180 "/usr/include/bits/types.h"
typedef int __ssize_t;
#line 110 "/usr/include/sys/types.h"
typedef __ssize_t ssize_t;
#line 69 "/usr/include/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 55 "/usr/include/sys/select.h"
typedef long __fd_mask;
#line 67 "/usr/include/sys/select.h"
struct __anonstruct_fd_set_6 {
   __fd_mask __fds_bits[1024 / (8 * (int )sizeof(__fd_mask ))] ;
};
#line 67 "/usr/include/sys/select.h"
typedef struct __anonstruct_fd_set_6 fd_set;
#line 209 "/usr/include/linux/soundcard.h"
struct patch_info {
   unsigned short key ;
   short device_no ;
   short instr_no ;
   unsigned int mode ;
   int len ;
   int loop_start ;
   int loop_end ;
   unsigned int base_freq ;
   unsigned int base_note ;
   unsigned int high_note ;
   unsigned int low_note ;
   int panning ;
   int detuning ;
   unsigned char env_rate[6] ;
   unsigned char env_offset[6] ;
   unsigned char tremolo_sweep ;
   unsigned char tremolo_rate ;
   unsigned char tremolo_depth ;
   unsigned char vibrato_sweep ;
   unsigned char vibrato_rate ;
   unsigned char vibrato_depth ;
   int scale_frequency ;
   unsigned int scale_factor ;
   int volume ;
   int fractions ;
   int reserved1 ;
   int spare[2] ;
   char data[1] ;
};
#line 465 "/usr/include/linux/soundcard.h"
typedef unsigned char sbi_instr_data[32];
#line 467 "/usr/include/linux/soundcard.h"
struct sbi_instrument {
   unsigned short key ;
   short device ;
   int channel ;
   sbi_instr_data operators ;
};
#line 476 "/usr/include/linux/soundcard.h"
struct synth_info {
   char name[30] ;
   int device ;
   int synth_type ;
   int synth_subtype ;
   int perc_mode ;
   int nr_voices ;
   int nr_drums ;
   int instr_bank_size ;
   unsigned int capabilities ;
   int dummies[19] ;
};
#line 45 "/usr/include/stdio.h"
struct _IO_FILE;
#line 49 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 180 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 186 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 271 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 60 "src/include/common.h"
typedef signed char int8;
#line 63 "src/include/common.h"
typedef unsigned char uint8;
#line 64 "src/include/common.h"
typedef unsigned short uint16;
#line 91 "src/include/xmp.h"
struct xmp_options {
   int big_endian ;
   char *drv_id ;
   char *outfile ;
   int verbosity ;
   int amplify ;
   int outfmt ;
   int resol ;
   int freq ;
   int flags ;
   int quirk ;
   int crunch ;
   int start ;
   int mix ;
   int time ;
   int tempo ;
   int chorus ;
   int reverb ;
   int skipsmp ;
   int cf_cutoff ;
   char *parm[16] ;
};
#line 155 "src/include/xmp.h"
struct xmp_drv_info {
   char *id ;
   char *description ;
   char **help ;
   int (*init)() ;
   void (*shutdown)() ;
   int (*numvoices)() ;
   void (*voicepos)() ;
   void (*echoback)() ;
   void (*setpatch)() ;
   void (*setvol)() ;
   void (*setnote)() ;
   void (*setpan)() ;
   void (*setbend)() ;
   void (*seteffect)() ;
   void (*starttimer)() ;
   void (*stoptimer)() ;
   void (*reset)() ;
   void (*bufdump)() ;
   void (*bufwipe)() ;
   void (*clearmem)() ;
   void (*sync)() ;
   int (*writepatch)() ;
   int (*getmsg)() ;
   struct xmp_drv_info *next ;
};
#line 5 "src/include/xxm.h"
struct xxm_header {
   int flg ;
   int pat ;
   int ptc ;
   int trk ;
   int chn ;
   int ins ;
   int smp ;
   int tpo ;
   int bpm ;
   int len ;
   int rst ;
   int gvl ;
};
#line 23 "src/include/xxm.h"
struct xxm_channel {
   int pan ;
   int vol ;
   int flg ;
   int cho ;
   int rvb ;
};
#line 34 "src/include/xxm.h"
struct xxm_trackinfo {
   int index ;
};
#line 38 "src/include/xxm.h"
struct xxm_pattern {
   int rows ;
   struct xxm_trackinfo info[1] ;
};
#line 43 "src/include/xxm.h"
struct xxm_event {
   uint8 note ;
   uint8 ins ;
   uint8 vol ;
   uint8 fxt ;
   uint8 fxp ;
   uint8 f2t ;
   uint8 f2p ;
};
#line 53 "src/include/xxm.h"
struct xxm_track {
   int rows ;
   struct xxm_event event[1] ;
};
#line 58 "src/include/xxm.h"
struct xxm_envinfo {
   int flg ;
   int npt ;
   int scl ;
   int sus ;
   int sue ;
   int lps ;
   int lpe ;
};
#line 72 "src/include/xxm.h"
struct xxm_instrument_header {
   uint8 name[32] ;
   int vol ;
   int nsm ;
   int rls ;
   struct xxm_envinfo aei ;
   struct xxm_envinfo pei ;
   struct xxm_envinfo fei ;
   int vts ;
   int wts ;
};
#line 85 "src/include/xxm.h"
struct xxm_instrument_map {
   uint8 ins[108] ;
   int8 xpo[108] ;
};
#line 90 "src/include/xxm.h"
struct xxm_instrument {
   int vol ;
   int gvl ;
   int pan ;
   int xpo ;
   int fin ;
   int vwf ;
   int vde ;
   int vra ;
   int vsw ;
   int rvv ;
   int sid ;
   int nna ;
   int dct ;
   int dca ;
   int ifc ;
   int ifr ;
   int hld ;
};
#line 121 "src/include/xxm.h"
struct xxm_sample {
   uint8 name[32] ;
   int len ;
   int lps ;
   int lpe ;
   int flg ;
};
#line 140 "src/include/common.h"
struct xmp_ord_info {
   int bpm ;
   int tempo ;
   int gvl ;
   int time ;
};
#line 154 "src/include/common.h"
struct xmp_mod_context {
   int verbosity ;
   int time ;
   char *dirname ;
   char *basename ;
   char name[64] ;
   char type[64] ;
   char author[64] ;
   char *filename ;
   char *comment ;
   int size ;
   double rrate ;
   int c4rate ;
   int volbase ;
   int volume ;
   int *vol_xlat ;
   int flags ;
   int quirk ;
   struct xxm_header *xxh ;
   struct xxm_pattern **xxp ;
   struct xxm_track **xxt ;
   struct xxm_instrument_header *xxih ;
   struct xxm_instrument_map *xxim ;
   struct xxm_instrument **xxi ;
   struct xxm_sample *xxs ;
   uint16 **xxae ;
   uint16 **xxpe ;
   uint16 **xxfe ;
   struct xxm_channel xxc[64] ;
   struct xmp_ord_info xxo_info[256] ;
   int xxo_fstrow[256] ;
   uint8 xxo[256] ;
   uint8 **med_vol_table ;
   uint8 **med_wav_table ;
};
#line 192 "src/include/common.h"
struct flow_control {
   int pbreak ;
   int jump ;
   int delay ;
   int jumpline ;
   int row ;
   int loop_chn ;
   int *loop_start ;
   int *loop_stack ;
   int frame ;
   int num_rows ;
   int ord ;
   int end_point ;
   double time ;
   double playing_time ;
};
#line 209
struct xmp_channel;
#line 209 "src/include/common.h"
struct xmp_player_context {
   int pause ;
   int pos ;
   int tempo ;
   int gvol_slide ;
   int gvol_flag ;
   int gvol_base ;
   double tick_time ;
   struct flow_control flow ;
   struct xmp_channel *xc_data ;
   int *fetch_ctl ;
   int xmp_scan_ord ;
   int xmp_scan_row ;
   int xmp_scan_num ;
   int xmp_bpm ;
   void (*event_callback)(unsigned long  ) ;
   struct xmp_mod_context m ;
};
#line 226
struct voice_info;
#line 226 "src/include/common.h"
struct xmp_driver_context {
   struct xmp_drv_info *driver ;
   char *description ;
   char **help ;
   int ext ;
   int memavl ;
   int numtrk ;
   int numchn ;
   int numbuf ;
   int curvoc ;
   int maxvoc ;
   int chnvoc ;
   int agevoc ;
   int cmute_array[64] ;
   int *ch2vo_count ;
   int *ch2vo_array ;
   struct voice_info *voice_array ;
   struct patch_info **patch_array ;
   void *buffer ;
   int size ;
};
#line 252 "src/include/common.h"
struct xmp_smixer_context {
   char **buffer ;
   int *buf32b ;
   int numvoc ;
   int numbuf ;
   int mode ;
   int resol ;
   int ticksize ;
   int dtright ;
   int dtleft ;
   int echo_msg ;
};
#line 265 "src/include/common.h"
struct xmp_context {
   struct xmp_options o ;
   struct xmp_driver_context d ;
   struct xmp_player_context p ;
   struct xmp_smixer_context s ;
};
#line 568 "/usr/include/linux/soundcard.h"
struct audio_buf_info {
   int fragments ;
   int fragstotal ;
   int fragsize ;
   int bytes ;
};
#line 568 "/usr/include/linux/soundcard.h"
typedef struct audio_buf_info audio_buf_info;
#line 25 "src/include/mixer.h"
struct voice_info {
   int chn ;
   int root ;
   unsigned int age ;
   int note ;
   int pan ;
   int vol ;
   int period ;
   int pbase ;
   int itpt ;
   int pos ;
   int fidx ;
   int fxor ;
   int ins ;
   int smp ;
   int end ;
   int freq ;
   int shl8 ;
   int act ;
   int sleft ;
   int sright ;
   void *sptr ;
   int flt_X1 ;
   int flt_X2 ;
   int flt_B0 ;
   int flt_B1 ;
   int flt_B2 ;
   int cutoff ;
   int resonance ;
   int attack ;
};
#line 65 "src/include/common.h"
typedef unsigned int uint32;
#line 143 "/usr/include/bits/types.h"
typedef int __pid_t;
#line 150 "/usr/include/bits/types.h"
typedef unsigned int __useconds_t;
#line 76 "/usr/include/time.h"
typedef __time_t time_t;
#line 57 "/usr/include/sys/time.h"
struct timezone {
   int tz_minuteswest ;
   int tz_dsttime ;
};
#line 63 "/usr/include/sys/time.h"
typedef struct timezone * __restrict  __timezone_ptr_t;
#line 84 "/usr/include/signal.h"
typedef void (*__sighandler_t)(int  );
#line 25 "/usr/include/bits/termios.h"
typedef unsigned char cc_t;
#line 26 "/usr/include/bits/termios.h"
typedef unsigned int speed_t;
#line 27 "/usr/include/bits/termios.h"
typedef unsigned int tcflag_t;
#line 30 "/usr/include/bits/termios.h"
struct termios {
   tcflag_t c_iflag ;
   tcflag_t c_oflag ;
   tcflag_t c_cflag ;
   tcflag_t c_lflag ;
   cc_t c_line ;
   cc_t c_cc[32] ;
   speed_t c_ispeed ;
   speed_t c_ospeed ;
};
#line 182 "src/include/xmp.h"
struct xmp_module_info {
   char name[64] ;
   char type[64] ;
   int chn ;
   int pat ;
   int ins ;
   int trk ;
   int smp ;
   int len ;
   int bpm ;
   int tpo ;
   int time ;
};
#line 196 "src/include/xmp.h"
typedef char *xmp_context;
#line 81 "src/include/getopt.h"
struct option {
   char const   *name ;
   int has_arg ;
   int *flag ;
   int val ;
};
#line 149 "src/include/xmp.h"
struct xmp_fmt_info {
   struct xmp_fmt_info *next ;
   char *id ;
   char *tracker ;
};
#line 61 "src/include/common.h"
typedef short int16;
#line 62 "src/include/common.h"
typedef int int32;
#line 74 "src/include/common.h"
typedef long long int64;
#line 226 "src/include/common.h"
struct xmp_driver_context___0 {
   struct xmp_drv_info *driver ;
   char *description ;
   char **help ;
   int ext ;
   int memavl ;
   int numtrk ;
   int numchn ;
   int numbuf ;
   int curvoc ;
   int maxvoc ;
   int chnvoc ;
   int agevoc ;
   int cmute_array[64] ;
   int *ch2vo_count ;
   int *ch2vo_array ;
   struct voice_info *voice_array ;
   struct patch_info___0 **patch_array ;
   void *buffer ;
   int size ;
};
#line 265 "src/include/common.h"
struct xmp_context___0 {
   struct xmp_options o ;
   struct xmp_driver_context___0 d ;
   struct xmp_player_context p ;
   struct xmp_smixer_context s ;
};
#line 89 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/player/player.h"
struct xmp_channel {
   int flags ;
   int per_flags ;
   int note ;
   int key ;
   double period ;
   int pitchbend ;
   int finetune ;
   int ins ;
   int smp ;
   int insdef ;
   int pan ;
   int masterpan ;
   int mastervol ;
   int delay ;
   int retrig ;
   int rval ;
   int rtype ;
   int rcount ;
   int tremor ;
   int tcnt_up ;
   int tcnt_dn ;
   int keyoff ;
   int volume ;
   int gvl ;
   int v_val ;
   int v_fval ;
   int v_val2 ;
   int volslide ;
   int fvolslide ;
   int p_val ;
   int trk_val ;
   int trk_fval ;
   int trkvsld ;
   uint16 v_idx ;
   uint16 p_idx ;
   uint16 f_idx ;
   int y_type ;
   int y_depth ;
   int y_sweep ;
   int y_rate ;
   int y_idx ;
   int t_type ;
   int t_depth ;
   int t_rate ;
   int t_idx ;
   int f_val ;
   int f_fval ;
   int porta ;
   int fadeout ;
   int gliss ;
   int s_end ;
   int s_sgn ;
   int s_val ;
   int a_val[4] ;
   int a_idx ;
   int a_size ;
   int insvib_idx ;
   int insvib_swp ;
   int offset ;
   int offset_val ;
   int ns_val ;
   int ns_fval ;
   int ns_speed ;
   int ns_count ;
   int cutoff ;
   int cutoff2 ;
   int resonance ;
   int med_vp ;
   int med_vv ;
   int med_vs ;
   int med_vc ;
   int med_vw ;
   int med_wp ;
   int med_wv ;
   int med_ws ;
   int med_wc ;
   int med_ww ;
   int med_period ;
   int med_arp ;
   int med_aidx ;
   int med_vwf ;
   int med_vib_depth ;
   int med_vib_speed ;
   int med_vib_idx ;
   int med_vib_wf ;
   int flt_B0 ;
   int flt_B1 ;
   int flt_B2 ;
   struct xxm_event *delayed_event ;
   int delayed_ins ;
};
#line 13 "src/include/driver.h"
struct patch_info___0 {
   unsigned short key ;
   short device_no ;
   short instr_no ;
   unsigned int mode ;
   int len ;
   int loop_start ;
   int loop_end ;
   unsigned int base_freq ;
   unsigned int base_note ;
   unsigned int high_note ;
   unsigned int low_note ;
   int panning ;
   int detuning ;
   int volume ;
   char data[1] ;
};
#line 11 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/player/fmopl.h"
typedef unsigned char UINT8;
#line 13 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/player/fmopl.h"
typedef unsigned int UINT32;
#line 16 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/player/fmopl.h"
typedef int INT32;
#line 19 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/player/fmopl.h"
typedef INT32 FMSAMPLE;
#line 39 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/player/fmopl.h"
struct fm_opl_slot {
   INT32 TL ;
   INT32 TLL ;
   UINT8 KSR ;
   INT32 *AR ;
   INT32 *DR ;
   INT32 SL ;
   INT32 *RR ;
   UINT8 ksl ;
   UINT8 ksr ;
   UINT32 mul ;
   UINT32 Cnt ;
   UINT32 Incr ;
   UINT8 eg_typ ;
   UINT8 evm ;
   INT32 evc ;
   INT32 eve ;
   INT32 evs ;
   INT32 evsa ;
   INT32 evsd ;
   INT32 evsr ;
   UINT8 ams ;
   UINT8 vib ;
   INT32 **wavetable ;
};
#line 39 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/player/fmopl.h"
typedef struct fm_opl_slot OPL_SLOT;
#line 69 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/player/fmopl.h"
struct fm_opl_channel {
   OPL_SLOT SLOT[2] ;
   UINT8 CON ;
   UINT8 FB ;
   INT32 *connect1 ;
   INT32 *connect2 ;
   INT32 op1_out[2] ;
   UINT32 block_fnum ;
   UINT8 kcode ;
   UINT32 fc ;
   UINT32 ksl_base ;
   UINT8 keyon ;
};
#line 69 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/player/fmopl.h"
typedef struct fm_opl_channel OPL_CH;
#line 85 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/player/fmopl.h"
struct fm_opl_f {
   UINT8 type ;
   int clock ;
   int rate ;
   double freqbase ;
   double TimerBase ;
   UINT8 address ;
   UINT8 status ;
   UINT8 statusmask ;
   UINT32 mode ;
   int T[2] ;
   UINT8 st[2] ;
   OPL_CH *P_CH ;
   int max_ch ;
   UINT8 rythm ;
   UINT8 portDirection ;
   UINT8 portLatch ;
   unsigned char (*porthandler_r)(int param ) ;
   void (*porthandler_w)(int param , unsigned char data ) ;
   int port_param ;
   unsigned char (*keyboardhandler_r)(int param ) ;
   void (*keyboardhandler_w)(int param , unsigned char data ) ;
   int keyboard_param ;
   INT32 AR_TABLE[75] ;
   INT32 DR_TABLE[75] ;
   UINT32 FN_TABLE[1024] ;
   INT32 *ams_table ;
   INT32 *vib_table ;
   INT32 amsCnt ;
   INT32 amsIncr ;
   INT32 vibCnt ;
   INT32 vibIncr ;
   UINT8 wavesel ;
   void (*TimerHandler)(int channel , double interval_Sec ) ;
   int TimerParam ;
   void (*IRQHandler)(int param , int irq ) ;
   int IRQParam ;
   void (*UpdateHandler)(int param , int min_interval_us ) ;
   int UpdateParam ;
};
#line 85 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/player/fmopl.h"
typedef struct fm_opl_f FM_OPL;
#line 42 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/player/player.h"
struct retrig_t {
   int s ;
   int m ;
   int d ;
};
#line 40 "/usr/lib/gcc/i486-linux-gnu/4.4.3/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 102 "/usr/lib/gcc/i486-linux-gnu/4.4.3/include/stdarg.h"
typedef __gnuc_va_list va_list;
#line 21 "src/include/list.h"
struct list_head {
   struct list_head *next ;
   struct list_head *prev ;
};
#line 8 "src/include/loader.h"
struct xmp_loader_info {
   char *id ;
   char *name ;
   int (*test)(FILE * , char * , int const    ) ;
   int (*loader)(struct xmp_context * , FILE * , int const    ) ;
   int enable ;
   struct list_head list ;
};
#line 48 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/misc/unlzx.c"
struct filename_node {
   struct filename_node *next ;
   unsigned int length ;
   unsigned int crc ;
   char filename[256] ;
};
#line 341 "/usr/include/libio.h"
typedef struct _IO_FILE _IO_FILE;
#line 32 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/misc/inflate.c"
struct bitstream_t {
   unsigned int holding ;
   int bitptr ;
};
#line 38 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/misc/inflate.c"
struct huffman_t {
   unsigned char window[32768] ;
   int window_ptr ;
   unsigned int checksum ;
   int len[288] ;
   int dist_len[33] ;
   int dist_huff_count ;
};
#line 48 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/misc/inflate.c"
struct huffman_tree_t {
   unsigned short code ;
   short left ;
   short right ;
};
#line 57 "/usr/include/bits/types.h"
typedef unsigned long long __u_quad_t;
#line 134 "/usr/include/bits/types.h"
typedef __u_quad_t __dev_t;
#line 135 "/usr/include/bits/types.h"
typedef unsigned int __uid_t;
#line 136 "/usr/include/bits/types.h"
typedef unsigned int __gid_t;
#line 137 "/usr/include/bits/types.h"
typedef unsigned long __ino_t;
#line 139 "/usr/include/bits/types.h"
typedef unsigned int __mode_t;
#line 140 "/usr/include/bits/types.h"
typedef unsigned int __nlink_t;
#line 164 "/usr/include/bits/types.h"
typedef long __blksize_t;
#line 169 "/usr/include/bits/types.h"
typedef long __blkcnt_t;
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   long tv_nsec ;
};
#line 43 "/usr/include/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   unsigned short __pad1 ;
   __ino_t st_ino ;
   __mode_t st_mode ;
   __nlink_t st_nlink ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   __dev_t st_rdev ;
   unsigned short __pad2 ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   unsigned long __unused4 ;
   unsigned long __unused5 ;
};
#line 63 "/usr/include/sys/wait.h"
union wait;
#line 67 "/usr/include/bits/waitstatus.h"
struct __anonstruct___wait_terminated_44 {
   unsigned int __w_termsig : 7 ;
   unsigned int __w_coredump : 1 ;
   unsigned int __w_retcode : 8 ;
   unsigned int  : 16 ;
};
#line 67 "/usr/include/bits/waitstatus.h"
struct __anonstruct___wait_stopped_45 {
   unsigned int __w_stopval : 8 ;
   unsigned int __w_stopsig : 8 ;
   unsigned int  : 16 ;
};
#line 67 "/usr/include/bits/waitstatus.h"
union wait {
   int w_status ;
   struct __anonstruct___wait_terminated_44 __wait_terminated ;
   struct __anonstruct___wait_stopped_45 __wait_stopped ;
};
#line 28 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/misc/oxm.c"
struct xm_instrument {
   uint32 len ;
   uint8 buf[36] ;
};
#line 173 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/misc/oxm.c"
union __anonunion_51 {
   int __in ;
   int __i ;
};
#line 173 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/misc/oxm.c"
union __anonunion_52 {
   int __in ;
   int __i ;
};
#line 29 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/misc/arcfs.c"
struct archived_file_header_tag {
   unsigned char method ;
   unsigned char bits ;
   char name[13] ;
   unsigned long compressed_size ;
   unsigned int date ;
   unsigned int time ;
   unsigned int crc ;
   unsigned long orig_size ;
   unsigned long offset ;
};
#line 43 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/misc/unarc.c"
struct archived_file_header_tag___0 {
   unsigned char method ;
   char name[13] ;
   unsigned long compressed_size ;
   unsigned int date ;
   unsigned int time ;
   unsigned int crc ;
   unsigned long orig_size ;
   int has_crc ;
};
#line 20 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/misc/readhuff.c"
struct huff_node_tag {
   int kids[2] ;
};
#line 26 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/misc/mmcmp.c"
struct MMCMPFILEHEADER {
   uint32 id_ziRC ;
   uint32 id_ONia ;
   uint16 hdrsize ;
};
#line 26 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/misc/mmcmp.c"
typedef struct MMCMPFILEHEADER *LPMMCMPFILEHEADER;
#line 33 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/misc/mmcmp.c"
struct MMCMPHEADER {
   uint16 version ;
   uint16 nblocks ;
   uint32 filesize ;
   uint32 blktable ;
   uint8 glb_comp ;
   uint8 fmt_comp ;
};
#line 33 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/misc/mmcmp.c"
typedef struct MMCMPHEADER *LPMMCMPHEADER;
#line 43 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/misc/mmcmp.c"
struct MMCMPBLOCK {
   uint32 unpk_size ;
   uint32 pk_size ;
   uint32 xor_chk ;
   uint16 sub_blk ;
   uint16 flags ;
   uint16 tt_entries ;
   uint16 num_bits ;
};
#line 43 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/misc/mmcmp.c"
typedef struct MMCMPBLOCK *LPMMCMPBLOCK;
#line 54 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/misc/mmcmp.c"
struct MMCMPSUBBLOCK {
   uint32 unpk_pos ;
   uint32 unpk_size ;
};
#line 54 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/misc/mmcmp.c"
typedef struct MMCMPSUBBLOCK *LPMMCMPSUBBLOCK;
#line 67 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/misc/mmcmp.c"
struct MMCMPBITBUFFER {
   uint32 bitcount ;
   uint32 bitbuffer ;
   uint8 *pSrc ;
   uint8 *pEnd ;
};
#line 67 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/misc/mmcmp.c"
typedef struct MMCMPBITBUFFER MMCMPBITBUFFER;
#line 38 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/misc/load.c"
struct tmpfilename {
   char *name ;
   struct list_head list ;
};
#line 36 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/prowizard/prowiz.h"
struct pw_format {
   char *id ;
   char *name ;
   int flags ;
   int (*test)(uint8 * , int  ) ;
   int (*depack)(FILE * , FILE * ) ;
   int enable ;
   struct list_head list ;
};
#line 29 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/prowizard/p40.c"
struct smp {
   uint8 name[22] ;
   int addr ;
   uint16 size ;
   int loop_addr ;
   uint16 loop_size ;
   int16 fine ;
   uint8 vol ;
};
#line 10 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/mod.h"
struct mod_instrument {
   uint8 name[22] ;
   uint16 size ;
   int8 finetune ;
   int8 volume ;
   uint16 loop_start ;
   uint16 loop_size ;
};
#line 19 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/mod.h"
struct mod_header {
   uint8 name[20] ;
   struct mod_instrument ins[31] ;
   uint8 len ;
   uint8 restart ;
   uint8 order[128] ;
   uint8 magic[4] ;
};
#line 50 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/dmf_load.c"
struct hnode {
   short left ;
   short right ;
   uint8 value ;
};
#line 55 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/dmf_load.c"
struct htree {
   uint8 *ibuf ;
   uint8 *ibufmax ;
   uint32 bitbuf ;
   int bitnum ;
   int lastnode ;
   int nodecount ;
   struct hnode nodes[256] ;
};
#line 9 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/rtm.h"
typedef uint8 BYTE;
#line 10 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/rtm.h"
typedef uint16 WORD;
#line 12 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/rtm.h"
typedef uint32 DWORD;
#line 18 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/rtm.h"
struct ObjectHeader {
   char id[4] ;
   char rc ;
   char name[32] ;
   char eof ;
   WORD version ;
   WORD headerSize ;
};
#line 27 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/rtm.h"
struct RTMMHeader {
   char software[20] ;
   char composer[32] ;
   WORD flags ;
   BYTE ntrack ;
   BYTE ninstr ;
   WORD nposition ;
   WORD npattern ;
   BYTE speed ;
   BYTE tempo ;
   char panning[32] ;
   DWORD extraDataSize ;
};
#line 43 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/rtm.h"
struct RTNDHeader {
   WORD flags ;
   BYTE ntrack ;
   WORD nrows ;
   DWORD datasize ;
};
#line 50 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/rtm.h"
struct EnvelopePoint {
   long x ;
   long y ;
};
#line 55 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/rtm.h"
struct Envelope {
   BYTE npoint ;
   struct EnvelopePoint point[12] ;
   BYTE sustain ;
   BYTE loopstart ;
   BYTE loopend ;
   WORD flags ;
};
#line 65 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/rtm.h"
struct RTINHeader {
   BYTE nsample ;
   WORD flags ;
   BYTE table[120] ;
   struct Envelope volumeEnv ;
   struct Envelope panningEnv ;
   char vibflg ;
   char vibsweep ;
   char vibdepth ;
   char vibrate ;
   WORD volfade ;
   BYTE midiPort ;
   BYTE midiChannel ;
   BYTE midiProgram ;
   BYTE midiEnable ;
};
#line 82 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/rtm.h"
struct RTSMHeader {
   WORD flags ;
   BYTE basevolume ;
   BYTE defaultvolume ;
   DWORD length ;
   long loop ;
   DWORD loopbegin ;
   DWORD loopend ;
   DWORD basefreq ;
   BYTE basenote ;
   char panning ;
};
#line 12 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/med.h"
typedef uint32 ULONG;
#line 13 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/med.h"
typedef int16 WORD___0;
#line 14 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/med.h"
typedef uint16 UWORD;
#line 15 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/med.h"
typedef int8 BYTE___0;
#line 16 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/med.h"
typedef uint8 UBYTE;
#line 18 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/med.h"
typedef char *STRPTR;
#line 26 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/med.h"
struct PlaySeq {
   char name[32] ;
   ULONG reserved[2] ;
   UWORD length ;
   UWORD seq[1] ;
};
#line 34 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/med.h"
struct MMD0sample {
   UWORD rep ;
   UWORD replen ;
   UBYTE midich ;
   UBYTE midipreset ;
   UBYTE svol ;
   BYTE___0 strans ;
};
#line 43 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/med.h"
struct MMD0song {
   struct MMD0sample sample[63] ;
   UWORD numblocks ;
   UWORD songlen ;
   UBYTE playseq[256] ;
   UWORD deftempo ;
   BYTE___0 playtransp ;
   UBYTE flags ;
   UBYTE flags2 ;
   UBYTE tempo2 ;
   UBYTE trkvol[16] ;
   UBYTE mastervol ;
   UBYTE numsamples ;
};
#line 74 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/med.h"
struct MMD2song {
   struct MMD0sample sample[63] ;
   UWORD numblocks ;
   UWORD songlen ;
   struct PlaySeq **playseqtable ;
   UWORD *sectiontable ;
   UBYTE *trackvols ;
   UWORD numtracks ;
   UWORD numpseqs ;
   BYTE___0 *trackpans ;
   ULONG flags3 ;
   UWORD voladj ;
   UWORD channels ;
   UBYTE mix_echotype ;
   UBYTE mix_echodepth ;
   UWORD mix_echolen ;
   BYTE___0 mix_stereosep ;
   UBYTE pad0[223] ;
   UWORD deftempo ;
   BYTE___0 playtransp ;
   UBYTE flags ;
   UBYTE flags2 ;
   UBYTE tempo2 ;
   UBYTE pad1[16] ;
   UBYTE mastervol ;
   UBYTE numsamples ;
};
#line 108
struct MMD0Block;
#line 108
struct InstrHdr;
#line 108
struct MMD0exp;
#line 108 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/med.h"
struct MMD0 {
   ULONG id ;
   ULONG modlen ;
   struct MMD0song *song ;
   UWORD psecnum ;
   UWORD pseq ;
   struct MMD0Block **blockarr ;
   UBYTE mmdflags ;
   UBYTE reserved[3] ;
   struct InstrHdr **smplarr ;
   ULONG reserved2 ;
   struct MMD0exp *expdata ;
   ULONG reserved3 ;
   UWORD pstate ;
   UWORD pblock ;
   UWORD pline ;
   UWORD pseqnum ;
   WORD___0 actplayline ;
   UBYTE counter ;
   UBYTE extra_songs ;
};
#line 132 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/med.h"
struct MMD0Block {
   UBYTE numtracks ;
   UBYTE lines ;
};
#line 137 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/med.h"
struct BlockCmdPageTable {
   UWORD num_pages ;
   UWORD reserved ;
   UWORD *page[1] ;
};
#line 144 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/med.h"
struct BlockInfo {
   ULONG *hlmask ;
   UBYTE *blockname ;
   ULONG blocknamelen ;
   struct BlockCmdPageTable *pagetable ;
   ULONG reserved[5] ;
};
#line 153 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/med.h"
struct MMD1Block {
   UWORD numtracks ;
   UWORD lines ;
   struct BlockInfo *info ;
};
#line 160 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/med.h"
struct InstrHdr {
   ULONG length ;
   WORD___0 type ;
};
#line 175 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/med.h"
struct SynthInstr {
   ULONG length ;
   WORD___0 type ;
   UBYTE defaultdecay ;
   UBYTE reserved[3] ;
   UWORD rep ;
   UWORD replen ;
   UWORD voltbllen ;
   UWORD wftbllen ;
   UBYTE volspeed ;
   UBYTE wfspeed ;
   UWORD wforms ;
   UBYTE voltbl[128] ;
   UBYTE wftbl[128] ;
   ULONG wf[64] ;
};
#line 193 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/med.h"
struct InstrExt {
   UBYTE hold ;
   UBYTE decay ;
   UBYTE suppress_midi_off ;
   BYTE___0 finetune ;
   UBYTE default_pitch ;
   UBYTE instr_flags ;
   UWORD long_midi_preset ;
   UBYTE output_device ;
   UBYTE reserved ;
   ULONG long_repeat ;
   ULONG long_replen ;
};
#line 211 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/med.h"
struct MMDInfo {
   struct MMDInfo *next ;
   UWORD reserved ;
   UWORD type ;
   ULONG length ;
};
#line 220 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/med.h"
struct MMDARexxTrigCmd {
   struct MMDARexxTrigCmd *next ;
   UBYTE cmdnum ;
   UBYTE pad ;
   WORD___0 cmdtype ;
   STRPTR cmd ;
   STRPTR port ;
   UWORD cmd_len ;
   UWORD port_len ;
};
#line 234 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/med.h"
struct MMDARexx {
   UWORD res ;
   UWORD trigcmdlen ;
   struct MMDARexxTrigCmd *trigcmd ;
};
#line 242 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/med.h"
struct MMDMIDICmd3x {
   UBYTE struct_vers ;
   UBYTE pad ;
   UWORD num_of_settings ;
   UBYTE *ctrlr_types ;
   UWORD *ctrlr_numbers ;
};
#line 252 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/med.h"
struct MMDInstrInfo {
   UBYTE name[40] ;
};
#line 256
struct NotationInfo;
#line 256
struct MMDDumpData;
#line 256 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/med.h"
struct MMD0exp {
   struct MMD0 *nextmod ;
   struct InstrExt *exp_smp ;
   UWORD s_ext_entries ;
   UWORD s_ext_entrsz ;
   UBYTE *annotxt ;
   ULONG annolen ;
   struct MMDInstrInfo *iinfo ;
   UWORD i_ext_entries ;
   UWORD i_ext_entrsz ;
   ULONG jumpmask ;
   UWORD *rgbtable ;
   UBYTE channelsplit[4] ;
   struct NotationInfo *n_info ;
   UBYTE *songname ;
   ULONG songnamelen ;
   struct MMDDumpData *dumps ;
   struct MMDInfo *mmdinfo ;
   struct MMDARexx *mmdrexx ;
   struct MMDMIDICmd3x *mmdcmd3x ;
   ULONG reserved2[3] ;
   ULONG tag_end ;
};
#line 281 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/med.h"
struct NotationInfo {
   UBYTE n_of_sharps ;
   UBYTE flags ;
   WORD___0 trksel[5] ;
   UBYTE trkshow[16] ;
   UBYTE trkghost[16] ;
   BYTE___0 notetr[63] ;
   UBYTE pad ;
};
#line 294 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/med.h"
struct MMDDumpData {
   UWORD numdumps ;
   UWORD reserved[3] ;
};
#line 48 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/stim_load.c"
struct stim_instrument {
   uint16 size ;
   uint8 finetune ;
   uint8 volume ;
   uint16 loop_start ;
   uint16 loop_size ;
};
#line 56 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/stim_load.c"
struct stim_header {
   uint32 id ;
   uint32 smpaddr ;
   uint32 unknown[2] ;
   uint16 nos ;
   uint16 len ;
   uint16 pat ;
   uint8 order[128] ;
   uint32 pataddr[64] ;
};
#line 38 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/ims_load.c"
struct ims_instrument {
   uint8 name[20] ;
   int16 finetune ;
   uint16 size ;
   uint8 unknown ;
   uint8 volume ;
   uint16 loop_start ;
   uint16 loop_size ;
};
#line 48 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/ims_load.c"
struct ims_header {
   uint8 title[20] ;
   struct ims_instrument ins[31] ;
   uint8 len ;
   uint8 zero ;
   uint8 orders[128] ;
   uint8 magic[4] ;
};
#line 9 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/liq.h"
struct liq_header {
   uint8 magic[14] ;
   uint8 name[30] ;
   uint8 author[20] ;
   uint8 _0x1a ;
   uint8 tracker[20] ;
   uint16 version ;
   uint16 speed ;
   uint16 bpm ;
   uint16 low ;
   uint16 high ;
   uint16 chn ;
   uint32 flags ;
   uint16 pat ;
   uint16 ins ;
   uint16 len ;
   uint16 hdrsz ;
};
#line 28 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/liq.h"
struct liq_instrument {
   uint16 version ;
   uint8 name[30] ;
   uint8 editor[20] ;
   uint8 author[20] ;
   uint8 hw_id ;
   uint32 length ;
   uint32 loopstart ;
   uint32 loopend ;
   uint32 c2spd ;
   uint8 vol ;
   uint8 flags ;
   uint8 pan ;
   uint8 midi_ins ;
   uint8 gvl ;
   uint8 chord ;
   uint16 hdrsz ;
   uint16 comp ;
   uint32 crc ;
   uint8 midi_ch ;
   uint8 rsvd[11] ;
   uint8 filename[25] ;
};
#line 55 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/liq.h"
struct liq_pattern {
   uint8 name[30] ;
   uint16 rows ;
   uint32 size ;
   uint32 reserved ;
};
#line 47 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/ice_load.c"
struct ice_ins {
   char name[22] ;
   uint16 len ;
   uint8 finetune ;
   uint8 volume ;
   uint16 loop_start ;
   uint16 loop_size ;
};
#line 56 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/ice_load.c"
struct ice_header {
   char title[20] ;
   struct ice_ins ins[31] ;
   uint8 len ;
   uint8 trk ;
   uint8 ord[128][4] ;
   uint32 magic ;
};
#line 52 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/fnk_load.c"
struct fnk_instrument {
   uint8 name[19] ;
   uint32 loop_start ;
   uint32 length ;
   uint8 volume ;
   uint8 pan ;
   uint8 shifter ;
   uint8 waveform ;
   uint8 retrig ;
};
#line 63 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/fnk_load.c"
struct fnk_header {
   uint8 marker[4] ;
   uint8 info[4] ;
   uint32 filesize ;
   uint8 fmt[4] ;
   uint8 loop ;
   uint8 order[256] ;
   uint8 pbrk[128] ;
   struct fnk_instrument fih[64] ;
};
#line 60 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/digi_load.c"
struct digi_header {
   uint8 id[20] ;
   uint8 vstr[4] ;
   uint8 ver ;
   uint8 chn ;
   uint8 pack ;
   uint8 unknown[19] ;
   uint8 pat ;
   uint8 len ;
   uint8 ord[128] ;
   uint32 slen[31] ;
   uint32 sloop[31] ;
   uint32 sllen[31] ;
   uint8 vol[31] ;
   uint8 fin[31] ;
   uint8 title[32] ;
   uint8 insname[31][30] ;
};
#line 15 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/imf.h"
struct imf_channel {
   char name[12] ;
   uint8 status ;
   uint8 pan ;
   uint8 chorus ;
   uint8 reverb ;
};
#line 23 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/imf.h"
struct imf_header {
   char name[32] ;
   uint16 len ;
   uint16 pat ;
   uint16 ins ;
   uint16 flg ;
   uint8 unused1[8] ;
   uint8 tpo ;
   uint8 bpm ;
   uint8 vol ;
   uint8 amp ;
   uint8 unused2[8] ;
   uint32 magic ;
   struct imf_channel chn[32] ;
   uint8 pos[256] ;
};
#line 40 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/imf.h"
struct imf_env {
   uint8 npt ;
   uint8 sus ;
   uint8 lps ;
   uint8 lpe ;
   uint8 flg ;
   uint8 unused[3] ;
};
#line 49 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/imf.h"
struct imf_instrument {
   char name[32] ;
   uint8 map[120] ;
   uint8 unused[8] ;
   uint16 vol_env[32] ;
   uint16 pan_env[32] ;
   uint16 pitch_env[32] ;
   struct imf_env env[3] ;
   uint16 fadeout ;
   uint16 nsm ;
   uint32 magic ;
};
#line 62 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/imf.h"
struct imf_sample {
   char name[13] ;
   uint8 unused1[3] ;
   uint32 len ;
   uint32 lps ;
   uint32 lpe ;
   uint32 rate ;
   uint8 vol ;
   uint8 pan ;
   uint8 unused2[14] ;
   uint8 flg ;
   uint8 unused3[5] ;
   uint16 ems ;
   uint32 dram ;
   uint32 magic ;
};
#line 34 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/mod.h"
struct st_header {
   uint8 name[20] ;
   struct mod_instrument ins[15] ;
   uint8 len ;
   uint8 restart ;
   uint8 order[128] ;
};
#line 74 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/flt_load.c"
struct am_instrument {
   int16 l0 ;
   int16 a1l ;
   int16 a1s ;
   int16 a2l ;
   int16 a2s ;
   int16 sl ;
   int16 ds ;
   int16 st ;
   int16 rs ;
   int16 wf ;
   int16 p_fall ;
   int16 v_amp ;
   int16 v_spd ;
   int16 fq ;
};
#line 57 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/sfx_load.c"
struct sfx_ins {
   uint8 name[22] ;
   uint16 len ;
   uint8 finetune ;
   uint8 volume ;
   uint16 loop_start ;
   uint16 loop_length ;
};
#line 66 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/sfx_load.c"
struct sfx_header {
   uint32 magic ;
   uint16 delay ;
   uint16 unknown[7] ;
};
#line 72 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/sfx_load.c"
struct sfx_header2 {
   uint8 len ;
   uint8 restart ;
   uint8 order[128] ;
};
#line 9 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/stx.h"
struct stx_file_header {
   uint8 name[20] ;
   uint8 magic[8] ;
   uint16 psize ;
   uint16 unknown1 ;
   uint16 pp_pat ;
   uint16 pp_ins ;
   uint16 pp_chn ;
   uint16 unknown2 ;
   uint16 unknown3 ;
   uint8 gvol ;
   uint8 tempo ;
   uint16 unknown4 ;
   uint16 unknown5 ;
   uint16 patnum ;
   uint16 insnum ;
   uint16 ordnum ;
   uint16 unknown6 ;
   uint16 unknown7 ;
   uint16 unknown8 ;
   uint8 magic2[4] ;
};
#line 32 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/stx.h"
struct stx_instrument_header {
   uint8 type ;
   uint8 dosname[13] ;
   uint16 memseg ;
   uint32 length ;
   uint32 loopbeg ;
   uint32 loopend ;
   uint8 vol ;
   uint8 rsvd1 ;
   uint8 pack ;
   uint8 flags ;
   uint16 c2spd ;
   uint16 rsvd2 ;
   uint8 rsvd3[4] ;
   uint16 int_gp ;
   uint16 int_512 ;
   uint32 int_last ;
   uint8 name[28] ;
   uint8 magic[4] ;
};
#line 54 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/it.h"
struct it_file_header {
   uint32 magic ;
   uint8 name[26] ;
   uint8 rsvd1[2] ;
   uint16 ordnum ;
   uint16 insnum ;
   uint16 smpnum ;
   uint16 patnum ;
   uint16 cwt ;
   uint16 cmwt ;
   uint16 flags ;
   uint16 special ;
   uint8 gv ;
   uint8 mv ;
   uint8 is ;
   uint8 it ;
   uint8 sep ;
   uint8 zero ;
   uint16 msglen ;
   uint32 msgofs ;
   uint8 rsvd2[4] ;
   uint8 chpan[64] ;
   uint8 chvol[64] ;
};
#line 79 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/it.h"
struct it_instrument1_header {
   uint32 magic ;
   uint8 dosname[12] ;
   uint8 zero ;
   uint8 flags ;
   uint8 vls ;
   uint8 vle ;
   uint8 sls ;
   uint8 sle ;
   uint16 rsvd1 ;
   uint16 fadeout ;
   uint8 nna ;
   uint8 dnc ;
   uint16 trkvers ;
   uint8 nos ;
   uint8 rsvd2 ;
   uint8 name[26] ;
   uint8 rsvd3[6] ;
   uint8 keys[240] ;
   uint8 epoint[200] ;
   uint8 enode[50] ;
};
#line 102 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/it.h"
struct it_instrument2_header {
   uint32 magic ;
   uint8 dosname[12] ;
   uint8 zero ;
   uint8 nna ;
   uint8 dct ;
   uint8 dca ;
   uint16 fadeout ;
   uint8 pps ;
   uint8 ppc ;
   uint8 gbv ;
   uint8 dfp ;
   uint8 rv ;
   uint8 rp ;
   uint16 trkvers ;
   uint8 nos ;
   uint8 rsvd1 ;
   uint8 name[26] ;
   uint8 ifc ;
   uint8 ifr ;
   uint8 mch ;
   uint8 mpr ;
   uint16 mbnk ;
   uint8 keys[240] ;
};
#line 128 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/it.h"
struct it_envelope_node {
   int8 y ;
   uint16 x ;
};
#line 133 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/it.h"
struct it_envelope {
   uint8 flg ;
   uint8 num ;
   uint8 lpb ;
   uint8 lpe ;
   uint8 slb ;
   uint8 sle ;
   struct it_envelope_node node[25] ;
   uint8 unused ;
};
#line 144 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/it.h"
struct it_sample_header {
   uint32 magic ;
   uint8 dosname[12] ;
   uint8 zero ;
   uint8 gvl ;
   uint8 flags ;
   uint8 vol ;
   uint8 name[26] ;
   uint8 convert ;
   uint8 dfp ;
   uint32 length ;
   uint32 loopbeg ;
   uint32 loopend ;
   uint32 c5spd ;
   uint32 sloopbeg ;
   uint32 sloopend ;
   uint32 sample_ptr ;
   uint8 vis ;
   uint8 vid ;
   uint8 vir ;
   uint8 vit ;
};
#line 66 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/mdl_load.c"
struct mdl_envelope {
   uint8 num ;
   uint8 data[30] ;
   uint8 sus ;
   uint8 loop ;
};
#line 55 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/ult_load.c"
struct ult_header {
   uint8 magic[15] ;
   uint8 name[32] ;
   uint8 msgsize ;
};
#line 61 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/ult_load.c"
struct ult_header2 {
   uint8 order[256] ;
   uint8 channels ;
   uint8 patterns ;
};
#line 67 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/ult_load.c"
struct ult_instrument {
   uint8 name[32] ;
   uint8 dosname[12] ;
   uint32 loop_start ;
   uint32 loopend ;
   uint32 sizestart ;
   uint32 sizeend ;
   uint8 volume ;
   uint8 bidiloop ;
   uint16 finetune ;
   uint16 c2spd ;
};
#line 80 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/ult_load.c"
struct ult_event {
   uint8 ins ;
   uint8 fxt ;
   uint8 f2p ;
   uint8 fxp ;
};
#line 44 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/amd_load.c"
struct amd_instrument {
   uint8 name[23] ;
   uint8 reg[11] ;
};
#line 50 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/amd_load.c"
struct amd_file_header {
   uint8 name[24] ;
   uint8 author[24] ;
   struct amd_instrument ins[26] ;
   uint8 len ;
   uint8 pat ;
   uint8 order[128] ;
   uint8 magic[9] ;
   uint8 version ;
};
#line 53 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/alm_load.c"
struct alm_file_header {
   uint8 id[7] ;
   uint8 speed ;
   uint8 length ;
   uint8 restart ;
   uint8 order[128] ;
};
#line 14 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/ptm.h"
struct ptm_file_header {
   uint8 name[28] ;
   uint8 doseof ;
   uint8 vermin ;
   uint8 vermaj ;
   uint8 rsvd1 ;
   uint16 ordnum ;
   uint16 insnum ;
   uint16 patnum ;
   uint16 chnnum ;
   uint16 flags ;
   uint16 rsvd2 ;
   uint32 magic ;
   uint8 rsvd3[16] ;
   uint8 chset[32] ;
   uint8 order[256] ;
   uint16 patseg[128] ;
};
#line 33 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/ptm.h"
struct ptm_instrument_header {
   uint8 type ;
   uint8 dosname[12] ;
   uint8 vol ;
   uint16 c4spd ;
   uint16 smpseg ;
   uint32 smpofs ;
   uint32 length ;
   uint32 loopbeg ;
   uint32 loopend ;
   uint32 gusbeg ;
   uint32 guslps ;
   uint32 guslpe ;
   uint8 gusflg ;
   uint8 rsvd1 ;
   uint8 name[28] ;
   uint32 magic ;
};
#line 9 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/mtm.h"
struct mtm_file_header {
   uint8 magic[3] ;
   uint8 version ;
   uint8 name[20] ;
   uint16 tracks ;
   uint8 patterns ;
   uint8 modlen ;
   uint16 extralen ;
   uint8 samples ;
   uint8 attr ;
   uint8 rows ;
   uint8 channels ;
   uint8 pan[32] ;
};
#line 24 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/mtm.h"
struct mtm_instrument_header {
   uint8 name[22] ;
   uint32 length ;
   uint32 loop_start ;
   uint32 loopend ;
   uint8 finetune ;
   uint8 volume ;
   uint8 attr ;
};
#line 9 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/far.h"
struct far_header {
   uint32 magic ;
   uint8 name[40] ;
   uint8 crlf[3] ;
   uint16 headersize ;
   uint8 version ;
   uint8 ch_on[16] ;
   uint8 rsvd1[9] ;
   uint8 tempo ;
   uint8 pan[16] ;
   uint8 rsvd2[4] ;
   uint16 textlen ;
};
#line 23 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/far.h"
struct far_header2 {
   uint8 order[256] ;
   uint8 patterns ;
   uint8 songlen ;
   uint8 restart ;
   uint16 patsize[256] ;
};
#line 31 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/far.h"
struct far_instrument {
   uint8 name[32] ;
   uint32 length ;
   uint8 finetune ;
   uint8 volume ;
   uint32 loop_start ;
   uint32 loopend ;
   uint8 sampletype ;
   uint8 loopmode ;
};
#line 46 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/669_load.c"
struct ssn_file_header {
   uint8 marker[2] ;
   uint8 message[108] ;
   uint8 nos ;
   uint8 nop ;
   uint8 loop ;
   uint8 order[128] ;
   uint8 tempo[128] ;
   uint8 pbrk[128] ;
};
#line 57 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/669_load.c"
struct ssn_instrument_header {
   uint8 name[13] ;
   uint32 length ;
   uint32 loop_start ;
   uint32 loopend ;
};
#line 13 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/stm.h"
struct stm_instrument_header {
   uint8 name[12] ;
   uint8 id ;
   uint8 idisk ;
   uint16 rsvd1 ;
   uint16 length ;
   uint16 loopbeg ;
   uint16 loopend ;
   uint8 volume ;
   uint8 rsvd2 ;
   uint16 c2spd ;
   uint32 rsvd3 ;
   uint16 paralen ;
};
#line 28 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/stm.h"
struct stm_file_header {
   uint8 name[20] ;
   uint8 magic[8] ;
   uint8 rsvd1 ;
   uint8 type ;
   uint8 vermaj ;
   uint8 vermin ;
   uint8 tempo ;
   uint8 patterns ;
   uint8 gvol ;
   uint8 rsvd2[13] ;
   struct stm_instrument_header ins[31] ;
};
#line 45 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/s3m.h"
struct s3m_file_header {
   uint8 name[28] ;
   uint8 doseof ;
   uint8 type ;
   uint8 rsvd1[2] ;
   uint16 ordnum ;
   uint16 insnum ;
   uint16 patnum ;
   uint16 flags ;
   uint16 version ;
   uint16 ffi ;
   uint32 magic ;
   uint8 gv ;
   uint8 is ;
   uint8 it ;
   uint8 mv ;
   uint8 uc ;
   uint8 dp ;
   uint8 rsvd2[8] ;
   uint16 special ;
   uint8 chset[32] ;
};
#line 68 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/s3m.h"
struct s3m_instrument_header {
   uint8 dosname[13] ;
   uint16 memseg ;
   uint32 length ;
   uint32 loopbeg ;
   uint32 loopend ;
   uint8 vol ;
   uint8 rsvd1 ;
   uint8 pack ;
   uint8 flags ;
   uint16 c2spd ;
   uint16 rsvd2 ;
   uint8 rsvd3[4] ;
   uint16 int_gp ;
   uint16 int_512 ;
   uint32 int_last ;
   uint8 name[28] ;
   uint32 magic ;
};
#line 88 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/s3m.h"
struct s3m_adlib_header {
   uint8 dosname[12] ;
   uint8 rsvd1[3] ;
   uint8 reg[12] ;
   uint8 vol ;
   uint8 dsk ;
   uint8 rsvd2[2] ;
   uint16 c2spd ;
   uint16 rsvd3 ;
   uint8 rsvd4[12] ;
   uint8 name[28] ;
   uint32 magic ;
};
#line 35 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/mod_load.c"
struct __anonstruct_mod_magic_48 {
   char *magic ;
   int flag ;
   int ptkloop ;
   char *tracker ;
   int ch ;
};
#line 30 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/xm.h"
struct xm_file_header {
   uint8 id[17] ;
   uint8 name[20] ;
   uint8 doseof ;
   uint8 tracker[20] ;
   uint16 version ;
   uint32 headersz ;
   uint16 songlen ;
   uint16 restart ;
   uint16 channels ;
   uint16 patterns ;
   uint16 instruments ;
   uint16 flags ;
   uint16 tempo ;
   uint16 bpm ;
   uint8 order[256] ;
};
#line 48 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/xm.h"
struct xm_pattern_header {
   uint32 length ;
   uint8 packing ;
   uint16 rows ;
   uint16 datasize ;
};
#line 55 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/xm.h"
struct xm_instrument_header {
   uint32 size ;
   uint8 name[22] ;
   uint8 type ;
   uint16 samples ;
   uint32 sh_size ;
};
#line 63 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/xm.h"
struct xm_instrument___0 {
   uint8 sample[96] ;
   uint16 v_env[24] ;
   uint16 p_env[24] ;
   uint8 v_pts ;
   uint8 p_pts ;
   uint8 v_sus ;
   uint8 v_start ;
   uint8 v_end ;
   uint8 p_sus ;
   uint8 p_start ;
   uint8 p_end ;
   uint8 v_type ;
   uint8 p_type ;
   uint8 y_wave ;
   uint8 y_sweep ;
   uint8 y_depth ;
   uint8 y_rate ;
   uint16 v_fade ;
};
#line 87 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/xm.h"
struct xm_sample_header {
   uint32 length ;
   uint32 loop_start ;
   uint32 loop_length ;
   uint8 volume ;
   int8 finetune ;
   uint8 type ;
   uint8 pan ;
   int8 relnote ;
   uint8 reserved ;
   uint8 name[22] ;
};
#line 146 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/itsex.c"
typedef uint8 byte;
#line 147 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/itsex.c"
typedef int8 sbyte;
#line 148 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/itsex.c"
typedef uint16 word;
#line 149 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/itsex.c"
typedef int16 sword;
#line 150 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/itsex.c"
typedef uint32 dword;
#line 23 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/iff.h"
struct iff_info {
   char id[5] ;
   void (*loader)(struct xmp_context * , int  , FILE * ) ;
   struct list_head list ;
};
#line 43 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2))) memcpy)(void * __restrict  __dest ,
                                                                                       void const   * __restrict  __src ,
                                                                                       size_t __n ) ;
#line 48
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2))) memmove)(void *__dest ,
                                                                                        void const   *__src ,
                                                                                        size_t __n ) ;
#line 130
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strncpy)(char * __restrict  __dest ,
                                                                                        char const   * __restrict  __src ,
                                                                                        size_t __n ) ;
#line 142
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) strcmp)(char const   *__s1 ,
                                                                                     char const   *__s2 )  __attribute__((__pure__)) ;
#line 346
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(2))) strtok)(char * __restrict  __s ,
                                                                                     char const   * __restrict  __delim ) ;
#line 188 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) unsigned long ( __attribute__((__nonnull__(1))) strtoul)(char const   * __restrict  __nptr ,
                                                                                              char ** __restrict  __endptr ,
                                                                                              int __base ) ;
#line 109 "/usr/include/sys/select.h"
extern int select(int __nfds , fd_set * __restrict  __readfds , fd_set * __restrict  __writefds ,
                  fd_set * __restrict  __exceptfds , struct timeval * __restrict  __timeout ) ;
#line 473 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *calloc(size_t __nmemb , size_t __size )  __attribute__((__malloc__)) ;
#line 488
extern  __attribute__((__nothrow__)) void free(void *__ptr ) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void exit(int __status ) ;
#line 350 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 357
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 363
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 73 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 42 "/usr/include/sys/ioctl.h"
extern  __attribute__((__nothrow__)) int ioctl(int __fd , unsigned long __request 
                                               , ...) ;
#line 147 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 333
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 341
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 819
extern void perror(char const   *__s ) ;
#line 61 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/drivers/oss_seq.c"
unsigned char _seqbuf[2048]  ;
#line 61 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/drivers/oss_seq.c"
int _seqbuflen  =    2048;
#line 61 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/drivers/oss_seq.c"
int _seqbufptr  =    0;
#line 63 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/drivers/oss_seq.c"
static int seqfd  =    -1;
#line 63 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/drivers/oss_seq.c"
static int hz  ;
#line 64 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/drivers/oss_seq.c"
static int echo_msg  ;
#line 66
static int numvoices(struct xmp_context *ctx___0 , int num ) ;
#line 67
static void voicepos(int ch , int pos___0 ) ;
#line 68
static void echoback(struct xmp_context *ctx___0 , int msg ) ;
#line 69
static void setpatch(int ch , int smp ) ;
#line 70
static void setvol(struct xmp_context *ctx___0 , int ch , int vol ) ;
#line 71
static void setnote(int ch , int note ) ;
#line 72
static void setpan(struct xmp_context *ctx___0 , int ch , int pan ) ;
#line 73
static void setbend(int ch , int bend ) ;
#line 74
static void seteffect(struct xmp_context *ctx___0 , int ch , int type , int val ) ;
#line 75
static void starttimer(void) ;
#line 76
static void stoptimer(void) ;
#line 77
static void resetvoices(void) ;
#line 78
static void bufdump(void) ;
#line 79
static void bufwipe(void) ;
#line 80
static void clearmem(void) ;
#line 81
static void seq_sync(double next_time___0 ) ;
#line 82
static int writepatch(struct xmp_context *ctx___0 , struct patch_info *patch ) ;
#line 83
static int init(struct xmp_context *ctx___0 ) ;
#line 84
static int getmsg(void) ;
#line 85
static void shutdown(struct xmp_context *ctx___0 ) ;
#line 89 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/drivers/oss_seq.c"
static char *help[9]  = 
#line 89
  {      (char *)"awechorus=mode",      (char *)"Set chorus mode in AWE cards",      (char *)"awereverb=mode",      (char *)"Set reverb mode in AWE cards", 
        (char *)"dev=<device_name>",      (char *)"Device to use (default /dev/sequencer)",      (char *)"opl2",      (char *)"Use OPL2 (YM3812) FM synthesizer", 
        (char *)((void *)0)};
#line 97 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/drivers/oss_seq.c"
struct xmp_drv_info drv_oss_seq  = 
#line 97
     {(char *)"oss_seq", (char *)"OSS sequencer", help, (int (*)())(& init), (void (*)())(& shutdown),
    (int (*)())(& numvoices), (void (*)())(& voicepos), (void (*)())(& echoback),
    (void (*)())(& setpatch), (void (*)())(& setvol), (void (*)())(& setnote), (void (*)())(& setpan),
    (void (*)())(& setbend), (void (*)())(& seteffect), & starttimer, & stoptimer,
    & resetvoices, & bufdump, & bufwipe, & clearmem, (void (*)())(& seq_sync), (int (*)())(& writepatch),
    & getmsg, (struct xmp_drv_info *)((void *)0)};
#line 124 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/drivers/oss_seq.c"
static int dev  ;
#line 125 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/drivers/oss_seq.c"
static struct synth_info si  ;
#line 126 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/drivers/oss_seq.c"
static int chorusmode  =    0;
#line 127 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/drivers/oss_seq.c"
static int reverbmode  =    0;
#line 128 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/drivers/oss_seq.c"
static char *dev_sequencer  =    (char *)"/dev/sequencer";
#line 129 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/drivers/oss_seq.c"
static struct xmp_player_context *p_ctx  ;
#line 131 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/drivers/oss_seq.c"
static int numvoices(struct xmp_context *ctx___0 , int num ) 
{ 


  {
  {
#line 134
  if (si.synth_subtype == 16) {
#line 134
    goto case_16;
  }
#line 133
  goto switch_break;
  case_16: /* CIL Label */ 
#line 135
  if (num < 14) {
#line 136
    num = 14;
  }
#line 140
  if (num > 32) {
#line 141
    return (32);
  }
#line 142
  if (_seqbufptr + 8 > _seqbuflen) {
    {
#line 142
    bufdump();
    }
  }
#line 142
  _seqbuf[_seqbufptr] = (unsigned char)254;
#line 142
  _seqbuf[_seqbufptr + 1] = (unsigned char )dev;
#line 142
  _seqbuf[_seqbufptr + 2] = (unsigned char)0;
#line 142
  _seqbuf[_seqbufptr + 3] = (unsigned char)0;
#line 142
  *((unsigned short *)(& _seqbuf[_seqbufptr + 4])) = (unsigned short )num;
#line 142
  *((unsigned short *)(& _seqbuf[_seqbufptr + 6])) = (unsigned short)0;
#line 142
  _seqbufptr += 8;
#line 143
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 146
  return (num);
}
}
#line 149 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/drivers/oss_seq.c"
static void voicepos(int ch , int pos___0 ) 
{ 


  {
#line 151
  if (_seqbufptr + 8 > _seqbuflen) {
    {
#line 151
    bufdump();
    }
  }
#line 151
  _seqbuf[_seqbufptr] = (unsigned char)254;
#line 151
  _seqbuf[_seqbufptr + 1] = (unsigned char )dev;
#line 151
  _seqbuf[_seqbufptr + 2] = (unsigned char)16;
#line 151
  _seqbuf[_seqbufptr + 3] = (unsigned char )ch;
#line 151
  *((unsigned short *)(& _seqbuf[_seqbufptr + 4])) = (unsigned short )(pos___0 & 65535);
#line 151
  *((unsigned short *)(& _seqbuf[_seqbufptr + 6])) = (unsigned short )((pos___0 >> 16) & 65535);
#line 151
  _seqbufptr += 8;
#line 152
  return;
}
}
#line 154 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/drivers/oss_seq.c"
static void echoback(struct xmp_context *ctx___0 , int msg ) 
{ 


  {
#line 156
  if (_seqbufptr + 8 > _seqbuflen) {
    {
#line 156
    bufdump();
    }
  }
#line 156
  _seqbuf[_seqbufptr] = (unsigned char)129;
#line 156
  _seqbuf[_seqbufptr + 1] = (unsigned char)8;
#line 156
  _seqbuf[_seqbufptr + 2] = (unsigned char)0;
#line 156
  _seqbuf[_seqbufptr + 3] = (unsigned char)0;
#line 156
  *((unsigned int *)(& _seqbuf[_seqbufptr + 4])) = (unsigned int )msg;
#line 156
  _seqbufptr += 8;
#line 157
  return;
}
}
#line 159 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/drivers/oss_seq.c"
static void setpatch(int ch , int smp ) 
{ 


  {
#line 161
  if (_seqbufptr + 8 > _seqbuflen) {
    {
#line 161
    bufdump();
    }
  }
#line 161
  _seqbuf[_seqbufptr] = (unsigned char)146;
#line 161
  _seqbuf[_seqbufptr + 1] = (unsigned char )dev;
#line 161
  _seqbuf[_seqbufptr + 2] = (unsigned char)192;
#line 161
  _seqbuf[_seqbufptr + 3] = (unsigned char )ch;
#line 161
  _seqbuf[_seqbufptr + 4] = (unsigned char )smp;
#line 161
  _seqbuf[_seqbufptr + 5] = (unsigned char)0;
#line 161
  *((short *)(& _seqbuf[_seqbufptr + 6])) = (short)0;
#line 161
  _seqbufptr += 8;
#line 162
  return;
}
}
#line 164 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/drivers/oss_seq.c"
static void setvol(struct xmp_context *ctx___0 , int ch , int vol ) 
{ 


  {
#line 166
  if (_seqbufptr + 8 > _seqbuflen) {
    {
#line 166
    bufdump();
    }
  }
#line 166
  _seqbuf[_seqbufptr] = (unsigned char)147;
#line 166
  _seqbuf[_seqbufptr + 1] = (unsigned char )dev;
#line 166
  _seqbuf[_seqbufptr + 2] = (unsigned char)144;
#line 166
  _seqbuf[_seqbufptr + 3] = (unsigned char )ch;
#line 166
  _seqbuf[_seqbufptr + 4] = (unsigned char)255;
#line 166
  _seqbuf[_seqbufptr + 5] = (unsigned char )(vol >> 4);
#line 166
  _seqbuf[_seqbufptr + 6] = (unsigned char)0;
#line 166
  _seqbuf[_seqbufptr + 7] = (unsigned char)0;
#line 166
  _seqbufptr += 8;
#line 167
  return;
}
}
#line 169 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/drivers/oss_seq.c"
static void setnote(int ch , int note ) 
{ 


  {
#line 171
  if (_seqbufptr + 8 > _seqbuflen) {
    {
#line 171
    bufdump();
    }
  }
#line 171
  _seqbuf[_seqbufptr] = (unsigned char)147;
#line 171
  _seqbuf[_seqbufptr + 1] = (unsigned char )dev;
#line 171
  _seqbuf[_seqbufptr + 2] = (unsigned char)144;
#line 171
  _seqbuf[_seqbufptr + 3] = (unsigned char )ch;
#line 171
  _seqbuf[_seqbufptr + 4] = (unsigned char )note;
#line 171
  _seqbuf[_seqbufptr + 5] = (unsigned char)0;
#line 171
  _seqbuf[_seqbufptr + 6] = (unsigned char)0;
#line 171
  _seqbuf[_seqbufptr + 7] = (unsigned char)0;
#line 171
  _seqbufptr += 8;
#line 172
  return;
}
}
#line 174 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/drivers/oss_seq.c"
static void seteffect(struct xmp_context *ctx___0 , int ch , int type , int val ) 
{ 


  {
#line 194
  return;
}
}
#line 196 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/drivers/oss_seq.c"
static void setpan(struct xmp_context *ctx___0 , int ch , int pan ) 
{ 


  {
#line 198
  if (_seqbufptr + 8 > _seqbuflen) {
    {
#line 198
    bufdump();
    }
  }
#line 198
  _seqbuf[_seqbufptr] = (unsigned char)254;
#line 198
  _seqbuf[_seqbufptr + 1] = (unsigned char )dev;
#line 198
  _seqbuf[_seqbufptr + 2] = (unsigned char)5;
#line 198
  _seqbuf[_seqbufptr + 3] = (unsigned char )ch;
#line 198
  *((unsigned short *)(& _seqbuf[_seqbufptr + 4])) = (unsigned short )((pan + 128) >> 4);
#line 198
  *((unsigned short *)(& _seqbuf[_seqbufptr + 6])) = (unsigned short)0;
#line 198
  _seqbufptr += 8;
#line 199
  return;
}
}
#line 201 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/drivers/oss_seq.c"
static void setbend(int ch , int bend ) 
{ 


  {
#line 203
  if (_seqbufptr + 8 > _seqbuflen) {
    {
#line 203
    bufdump();
    }
  }
#line 203
  _seqbuf[_seqbufptr] = (unsigned char)255;
#line 203
  _seqbuf[_seqbufptr + 1] = (unsigned char)10;
#line 203
  _seqbuf[_seqbufptr + 2] = (unsigned char )dev;
#line 203
  _seqbuf[_seqbufptr + 3] = (unsigned char )ch;
#line 203
  _seqbuf[_seqbufptr + 4] = (unsigned char)255;
#line 203
  _seqbuf[_seqbufptr + 5] = (unsigned char )(bend & 255);
#line 203
  _seqbuf[_seqbufptr + 6] = (unsigned char )((bend >> 8) & 255);
#line 203
  _seqbuf[_seqbufptr + 7] = (unsigned char)0;
#line 203
  _seqbufptr += 8;
#line 204
  return;
}
}
#line 206 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/drivers/oss_seq.c"
static void starttimer(void) 
{ 


  {
#line 208
  if (_seqbufptr + 8 > _seqbuflen) {
    {
#line 208
    bufdump();
    }
  }
  {
#line 208
  _seqbuf[_seqbufptr] = (unsigned char)129;
#line 208
  _seqbuf[_seqbufptr + 1] = (unsigned char)4;
#line 208
  _seqbuf[_seqbufptr + 2] = (unsigned char)0;
#line 208
  _seqbuf[_seqbufptr + 3] = (unsigned char)0;
#line 208
  *((unsigned int *)(& _seqbuf[_seqbufptr + 4])) = 0U;
#line 208
  _seqbufptr += 8;
#line 209
  seq_sync((double )0);
#line 210
  bufdump();
  }
#line 211
  return;
}
}
#line 213 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/drivers/oss_seq.c"
static void stoptimer(void) 
{ 


  {
#line 215
  if (_seqbufptr + 8 > _seqbuflen) {
    {
#line 215
    bufdump();
    }
  }
  {
#line 215
  _seqbuf[_seqbufptr] = (unsigned char)129;
#line 215
  _seqbuf[_seqbufptr + 1] = (unsigned char)3;
#line 215
  _seqbuf[_seqbufptr + 2] = (unsigned char)0;
#line 215
  _seqbuf[_seqbufptr + 3] = (unsigned char)0;
#line 215
  *((unsigned int *)(& _seqbuf[_seqbufptr + 4])) = 0U;
#line 215
  _seqbufptr += 8;
#line 216
  bufdump();
  }
#line 217
  return;
}
}
#line 219 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/drivers/oss_seq.c"
static void resetvoices(void) 
{ 
  int i___3 ;

  {
#line 229
  i___3 = 0;
  {
#line 229
  while (1) {
    while_continue: /* CIL Label */ ;
#line 229
    if (! (i___3 < 32)) {
#line 229
      goto while_break;
    }
#line 230
    if (_seqbufptr + 8 > _seqbuflen) {
      {
#line 230
      bufdump();
      }
    }
#line 230
    _seqbuf[_seqbufptr] = (unsigned char)147;
#line 230
    _seqbuf[_seqbufptr + 1] = (unsigned char )dev;
#line 230
    _seqbuf[_seqbufptr + 2] = (unsigned char)128;
#line 230
    _seqbuf[_seqbufptr + 3] = (unsigned char )i___3;
#line 230
    _seqbuf[_seqbufptr + 4] = (unsigned char)255;
#line 230
    _seqbuf[_seqbufptr + 5] = (unsigned char)0;
#line 230
    _seqbuf[_seqbufptr + 6] = (unsigned char)0;
#line 230
    _seqbuf[_seqbufptr + 7] = (unsigned char)0;
#line 230
    _seqbufptr += 8;
#line 231
    if (_seqbufptr + 8 > _seqbuflen) {
      {
#line 231
      bufdump();
      }
    }
#line 231
    _seqbuf[_seqbufptr] = (unsigned char)146;
#line 231
    _seqbuf[_seqbufptr + 1] = (unsigned char )dev;
#line 231
    _seqbuf[_seqbufptr + 2] = (unsigned char)176;
#line 231
    _seqbuf[_seqbufptr + 3] = (unsigned char )i___3;
#line 231
    _seqbuf[_seqbufptr + 4] = (unsigned char)11;
#line 231
    _seqbuf[_seqbufptr + 5] = (unsigned char)0;
#line 231
    *((short *)(& _seqbuf[_seqbufptr + 6])) = (short)32640;
#line 231
    _seqbufptr += 8;
#line 232
    if (_seqbufptr + 8 > _seqbuflen) {
      {
#line 232
      bufdump();
      }
    }
#line 232
    _seqbuf[_seqbufptr] = (unsigned char)146;
#line 232
    _seqbuf[_seqbufptr + 1] = (unsigned char )dev;
#line 232
    _seqbuf[_seqbufptr + 2] = (unsigned char)176;
#line 232
    _seqbuf[_seqbufptr + 3] = (unsigned char )i___3;
#line 232
    _seqbuf[_seqbufptr + 4] = (unsigned char)7;
#line 232
    _seqbuf[_seqbufptr + 5] = (unsigned char)0;
#line 232
    *((short *)(& _seqbuf[_seqbufptr + 6])) = (short)16383;
#line 232
    _seqbufptr += 8;
#line 233
    if (_seqbufptr + 8 > _seqbuflen) {
      {
#line 233
      bufdump();
      }
    }
#line 233
    _seqbuf[_seqbufptr] = (unsigned char)146;
#line 233
    _seqbuf[_seqbufptr + 1] = (unsigned char )dev;
#line 233
    _seqbuf[_seqbufptr + 2] = (unsigned char)176;
#line 233
    _seqbuf[_seqbufptr + 3] = (unsigned char )i___3;
#line 233
    _seqbuf[_seqbufptr + 4] = (unsigned char)254;
#line 233
    _seqbuf[_seqbufptr + 5] = (unsigned char)0;
#line 233
    *((short *)(& _seqbuf[_seqbufptr + 6])) = (short)8191;
#line 233
    _seqbufptr += 8;
#line 234
    if (_seqbufptr + 8 > _seqbuflen) {
      {
#line 234
      bufdump();
      }
    }
#line 234
    _seqbuf[_seqbufptr] = (unsigned char)146;
#line 234
    _seqbuf[_seqbufptr + 1] = (unsigned char )dev;
#line 234
    _seqbuf[_seqbufptr + 2] = (unsigned char)224;
#line 234
    _seqbuf[_seqbufptr + 3] = (unsigned char )i___3;
#line 234
    _seqbuf[_seqbufptr + 4] = (unsigned char)0;
#line 234
    _seqbuf[_seqbufptr + 5] = (unsigned char)0;
#line 234
    *((short *)(& _seqbuf[_seqbufptr + 6])) = (short)0;
#line 234
    _seqbufptr += 8;
#line 235
    if (_seqbufptr + 8 > _seqbuflen) {
      {
#line 235
      bufdump();
      }
    }
    {
#line 235
    _seqbuf[_seqbufptr] = (unsigned char)146;
#line 235
    _seqbuf[_seqbufptr + 1] = (unsigned char )dev;
#line 235
    _seqbuf[_seqbufptr + 2] = (unsigned char)176;
#line 235
    _seqbuf[_seqbufptr + 3] = (unsigned char )i___3;
#line 235
    _seqbuf[_seqbufptr + 4] = (unsigned char)10;
#line 235
    _seqbuf[_seqbufptr + 5] = (unsigned char)0;
#line 235
    *((short *)(& _seqbuf[_seqbufptr + 6])) = (short)64;
#line 235
    _seqbufptr += 8;
#line 236
    bufdump();
#line 229
    i___3 ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 238
  return;
}
}
#line 240 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/drivers/oss_seq.c"
static void bufwipe(void) 
{ 


  {
  {
#line 242
  bufdump();
#line 243
  ioctl(seqfd, (unsigned long )((unsigned int )(81 << 8)), 0);
#line 244
  _seqbufptr = 0;
  }
#line 245
  return;
}
}
#line 247 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/drivers/oss_seq.c"
static void bufdump(void) 
{ 
  int i___3 ;
  int j ;
  fd_set rfds ;
  fd_set wfds ;
  int __d0 ;
  int __d1 ;
  int __d0___0 ;
  int __d1___0 ;
  ssize_t tmp ;
  void *__cil_tmp10 ;
  void *__cil_tmp11 ;
  void *__cil_tmp12 ;
  void *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
  {
#line 252
  while (1) {
    while_continue: /* CIL Label */ ;
#line 252
    __asm__  volatile   ("cld; rep; "
                         "stosl": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                         "1" (& rfds.__fds_bits[0]): "memory");
#line 252
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 253
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 253
    __asm__  volatile   ("cld; rep; "
                         "stosl": "=c" (__d0___0), "=D" (__d1___0): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                         "1" (& wfds.__fds_bits[0]): "memory");
#line 253
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 255
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 256
    rfds.__fds_bits[seqfd / (8 * (int )sizeof(__fd_mask ))] |= 1L << seqfd % (8 * (int )sizeof(__fd_mask ));
#line 257
    wfds.__fds_bits[seqfd / (8 * (int )sizeof(__fd_mask ))] |= 1L << seqfd % (8 * (int )sizeof(__fd_mask ));
#line 258
    select(seqfd + 1, (fd_set */* __restrict  */)(& rfds), (fd_set */* __restrict  */)(& wfds),
           (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)((void *)0));
    }
#line 260
    if ((rfds.__fds_bits[seqfd / (8 * (int )sizeof(__fd_mask ))] & (1L << seqfd % (8 * (int )sizeof(__fd_mask )))) != 0L) {
      {
#line 261
      tmp = read(seqfd, (void *)(& echo_msg), (size_t )4);
      }
#line 261
      if (tmp == 4) {
#line 261
        if ((echo_msg & 255) == 8) {
          {
#line 263
          echo_msg >>= 8;
#line 264
          (*(p_ctx->event_callback))((unsigned long )echo_msg);
          }
        } else {
#line 266
          echo_msg = 0;
        }
      } else {
#line 266
        echo_msg = 0;
      }
    }
#line 269
    if ((wfds.__fds_bits[seqfd / (8 * (int )sizeof(__fd_mask ))] & (1L << seqfd % (8 * (int )sizeof(__fd_mask )))) != 0L) {
#line 269
      j = _seqbufptr;
#line 269
      if (j != 0) {
        {
#line 270
        i___3 = write(seqfd, (void const   *)(_seqbuf), (size_t )_seqbufptr);
        }
#line 270
        if (i___3 == -1) {
          {
#line 271
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"xmp: can\'t write to sequencer\n");
#line 273
          exit(-4);
          }
        } else
#line 274
        if (i___3 < j) {
          {
#line 275
          _seqbufptr -= i___3;
#line 276
          memmove((void *)(_seqbuf), (void const   *)(_seqbuf + i___3), (size_t )_seqbufptr);
          }
        } else {
#line 278
          _seqbufptr = 0;
        }
      }
    }
#line 255
    if (! _seqbufptr) {
#line 255
      goto while_break___1;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 281
  return;
}
}
#line 283 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/drivers/oss_seq.c"
static void clearmem(void) 
{ 
  int i___3 ;

  {
  {
#line 285
  i___3 = dev;
#line 287
  ioctl(seqfd, (unsigned long )(((1U << 30) | (unsigned int )(81 << 8)) | 9U) | (sizeof(int ) << 16),
        & i___3);
  }
#line 288
  return;
}
}
#line 292 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/drivers/oss_seq.c"
static double this_time  =    (double )0;
#line 290 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/drivers/oss_seq.c"
static void seq_sync(double next_time___0 ) 
{ 


  {
#line 294
  if (next_time___0 == (double )0) {
#line 295
    this_time = (double )0;
  }
#line 297
  if (next_time___0 - this_time < 1.0) {
#line 298
    return;
  }
#line 300
  if (next_time___0 > this_time) {
#line 301
    if (_seqbufptr + 8 > _seqbuflen) {
      {
#line 301
      bufdump();
      }
    }
#line 301
    _seqbuf[_seqbufptr] = (unsigned char)129;
#line 301
    _seqbuf[_seqbufptr + 1] = (unsigned char)2;
#line 301
    _seqbuf[_seqbufptr + 2] = (unsigned char)0;
#line 301
    _seqbuf[_seqbufptr + 3] = (unsigned char)0;
#line 301
    *((unsigned int *)(& _seqbuf[_seqbufptr + 4])) = (unsigned int )((next_time___0 * (double )hz) / (double )100);
#line 301
    _seqbufptr += 8;
#line 302
    this_time = next_time___0;
  }
#line 304
  return;
}
}
#line 306 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/drivers/oss_seq.c"
static int writepatch(struct xmp_context *ctx___0 , struct patch_info *patch ) 
{ 
  struct sbi_instrument sbi ;
  struct xmp_options *o___0 ;
  ssize_t tmp ;
  void *__cil_tmp6 ;
  void *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
#line 309
  o___0 = & ctx___0->o;
#line 311
  if (! patch) {
    {
#line 312
    clearmem();
    }
#line 313
    return (0);
  }
#line 316
  if (! (! (o___0->outfmt & 1)) ^ (patch->len == -1)) {
#line 317
    return (-6);
  }
#line 319
  patch->device_no = (short )dev;
#line 320
  if (patch->len == -1) {
    {
#line 321
    sbi.key = (unsigned short )((1 << 8) | 253);
#line 322
    sbi.device = (short )dev;
#line 323
    sbi.channel = (int )patch->instr_no;
#line 324
    memcpy((void */* __restrict  */)(& sbi.operators), (void const   */* __restrict  */)(patch->data),
           (size_t )11);
#line 325
    write(seqfd, (void const   *)(& sbi), (size_t )sizeof(sbi));
    }
#line 327
    return (0);
  }
#line 329
  if (_seqbufptr) {
    {
#line 329
    bufdump();
    }
  }
  {
#line 329
  tmp = write(seqfd, (void const   *)((char *)patch), (size_t )((sizeof(struct patch_info ) + (unsigned long )patch->len) - 1UL));
  }
#line 329
  if (tmp == -1) {
    {
#line 329
    perror("Write patch: /dev/sequencer");
    }
  }
#line 331
  return (0);
}
}
#line 334 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/drivers/oss_seq.c"
static int getmsg(void) 
{ 


  {
#line 336
  return (echo_msg);
}
}
#line 339 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/drivers/oss_seq.c"
static int init(struct xmp_context *ctx___0 ) 
{ 
  int found ;
  char *buf___1 ;
  char *token___0 ;
  char **parm ;
  struct xmp_driver_context *d ;
  struct xmp_options *o___0 ;
  char s[80] ;
  unsigned long tmp ;
  int tmp___0 ;
  unsigned long tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int i___3 ;
  void *tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  void *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;

  {
#line 344
  d = & ctx___0->d;
#line 345
  o___0 = & ctx___0->o;
#line 347
  parm = o___0->parm;
  {
#line 347
  while (1) {
    while_continue: /* CIL Label */ ;
#line 347
    if (! *parm) {
#line 347
      goto while_break;
    }
    {
#line 347
    strncpy((char */* __restrict  */)(s), (char const   */* __restrict  */)*parm,
            (size_t )80);
#line 347
    token___0 = strtok((char */* __restrict  */)(s), (char const   */* __restrict  */)":=");
#line 347
    token___0 = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)"");
#line 348
    tmp___0 = strcmp((char const   *)(s), "awechorus");
    }
#line 348
    if (! tmp___0) {
#line 348
      if ((unsigned long )token___0 == (unsigned long )((void *)0)) {
        {
#line 348
        while (1) {
          while_continue___0: /* CIL Label */ ;
          {
#line 348
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"xmp: incorrect parameters in -D %s\n",
                  s);
#line 348
          exit(-4);
          }
#line 348
          goto while_break___0;
        }
        while_break___0: /* CIL Label */ ;
        }
      } else {
        {
#line 348
        tmp = strtoul((char const   */* __restrict  */)token___0, (char **/* __restrict  */)((void *)0),
                      0);
#line 348
        chorusmode = (int )tmp;
        }
      }
    }
    {
#line 349
    tmp___2 = strcmp((char const   *)(s), "awereverb");
    }
#line 349
    if (! tmp___2) {
#line 349
      if ((unsigned long )token___0 == (unsigned long )((void *)0)) {
        {
#line 349
        while (1) {
          while_continue___1: /* CIL Label */ ;
          {
#line 349
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"xmp: incorrect parameters in -D %s\n",
                  s);
#line 349
          exit(-4);
          }
#line 349
          goto while_break___1;
        }
        while_break___1: /* CIL Label */ ;
        }
      } else {
        {
#line 349
        tmp___1 = strtoul((char const   */* __restrict  */)token___0, (char **/* __restrict  */)((void *)0),
                          0);
#line 349
        reverbmode = (int )tmp___1;
        }
      }
    }
    {
#line 350
    tmp___3 = strcmp((char const   *)(s), "opl2");
    }
#line 350
    if (! tmp___3) {
#line 350
      if ((unsigned long )token___0 != (unsigned long )((void *)0)) {
        {
#line 350
        while (1) {
          while_continue___2: /* CIL Label */ ;
          {
#line 350
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"xmp: incorrect parameters in -D %s\n",
                  s);
#line 350
          exit(-4);
          }
#line 350
          goto while_break___2;
        }
        while_break___2: /* CIL Label */ ;
        }
      } else {
#line 350
        o___0->outfmt |= 1;
      }
    }
    {
#line 351
    tmp___4 = strcmp((char const   *)(s), "dev");
    }
#line 351
    if (! tmp___4) {
#line 351
      if ((unsigned long )token___0 == (unsigned long )((void *)0)) {
        {
#line 351
        while (1) {
          while_continue___3: /* CIL Label */ ;
          {
#line 351
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"xmp: incorrect parameters in -D %s\n",
                  s);
#line 351
          exit(-4);
          }
#line 351
          goto while_break___3;
        }
        while_break___3: /* CIL Label */ ;
        }
      } else {
#line 351
        dev_sequencer = token___0;
      }
    }
#line 347
    parm ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 354
  p_ctx = & ctx___0->p;
#line 356
  seqfd = open((char const   *)dev_sequencer, 2);
  }
#line 356
  if (seqfd != -1) {
#line 357
    if (seqfd != -1) {
      {
#line 357
      tmp___5 = ioctl(seqfd, (unsigned long )(((2U << 30) | (unsigned int )(81 << 8)) | 10U) | (sizeof(int ) << 16),
                      & dev);
      }
#line 357
      if (tmp___5 == -1) {
        {
#line 359
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"xmp: can\'t determine number of synths\n");
        }
#line 361
        return (-5);
      }
    }
  } else {
#line 364
    if (o___0->verbosity > 2) {
      {
#line 365
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"xmp: can\'t open sequencer\n");
      }
    }
#line 366
    return (-5);
  }
#line 369
  found = 0;
  {
#line 369
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 369
    tmp___9 = dev;
#line 369
    dev --;
#line 369
    if (! tmp___9) {
#line 369
      goto while_break___4;
    }
    {
#line 370
    si.device = dev;
#line 372
    tmp___6 = ioctl(seqfd, (unsigned long )(((3U << 30) | (unsigned int )(81 << 8)) | 2U) | (sizeof(struct synth_info ) << 16),
                    & si);
    }
#line 372
    if (tmp___6 == -1) {
      {
#line 373
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"xmp: can\'t determine synth info\n");
      }
#line 374
      return (-5);
    }
#line 377
    if (o___0->outfmt & 1) {
#line 377
      tmp___8 = 0;
    } else {
#line 377
      tmp___8 = 1;
    }
#line 377
    if (si.synth_type == tmp___8) {
#line 379
      if (si.synth_type != 0) {
        {
#line 380
        i___3 = dev;
#line 381
        ioctl(seqfd, (unsigned long )(((1U << 30) | (unsigned int )(81 << 8)) | 9U) | (sizeof(int ) << 16),
              & i___3);
#line 382
        i___3 = dev;
#line 383
        ioctl(seqfd, (unsigned long )(((3U << 30) | (unsigned int )(81 << 8)) | 14U) | (sizeof(int ) << 16),
              & i___3);
        }
#line 384
        if (! i___3) {
#line 385
          goto __Cont;
        }
#line 386
        d->memavl = i___3;
      }
      {
#line 389
      tmp___7 = calloc((size_t )1, (size_t )256);
#line 389
      buf___1 = (char *)tmp___7;
#line 390
      sprintf((char */* __restrict  */)buf___1, (char const   */* __restrict  */)"%s [%s]",
              drv_oss_seq.description, si.name);
#line 398
      drv_oss_seq.description = buf___1;
#line 400
      found = 1;
      }
#line 401
      goto while_break___4;
    }
    __Cont: /* CIL Label */ ;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 405
  if (! found) {
    {
#line 406
    close(seqfd);
    }
#line 407
    return (-5);
  }
  {
#line 410
  hz = 0;
#line 411
  ioctl(seqfd, (unsigned long )(((3U << 30) | (unsigned int )(81 << 8)) | 3U) | (sizeof(int ) << 16),
        & hz);
  }
#line 412
  if (_seqbufptr + 8 > _seqbuflen) {
    {
#line 412
    bufdump();
    }
  }
  {
#line 412
  _seqbuf[_seqbufptr] = (unsigned char)255;
#line 412
  _seqbuf[_seqbufptr + 1] = (unsigned char)12;
#line 412
  _seqbuf[_seqbufptr + 2] = (unsigned char )dev;
#line 412
  _seqbuf[_seqbufptr + 3] = (unsigned char)2;
#line 412
  _seqbuf[_seqbufptr + 4] = (unsigned char)0;
#line 412
  _seqbuf[_seqbufptr + 5] = (unsigned char)0;
#line 412
  _seqbuf[_seqbufptr + 6] = (unsigned char)0;
#line 412
  _seqbuf[_seqbufptr + 7] = (unsigned char)0;
#line 412
  _seqbufptr += 8;
#line 413
  bufdump();
#line 414
  ioctl(seqfd, (unsigned long )((unsigned int )(81 << 8) | 1U), 0);
  }
#line 416
  return (0);
}
}
#line 419 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/drivers/oss_seq.c"
static void shutdown(struct xmp_context *ctx___0 ) 
{ 


  {
  {
#line 421
  free((void *)drv_oss_seq.description);
#line 422
  close(seqfd);
  }
#line 423
  return;
}
}
#line 363 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 415
extern  __attribute__((__nothrow__)) int sscanf(char const   * __restrict  __s , char const   * __restrict  __format 
                                                , ...)  __asm__("__isoc99_sscanf")  ;
#line 59 "src/include/mixer.h"
int xmp_smix_on(struct xmp_context *ctx___0 ) ;
#line 60
void xmp_smix_off(struct xmp_context *ctx___0 ) ;
#line 61
void xmp_smix_setvol(struct xmp_context *ctx___0 , int voc , int vol ) ;
#line 62
void xmp_smix_seteffect(struct xmp_context *ctx___0 , int voc , int type , int val ) ;
#line 63
void xmp_smix_setpan(struct xmp_context *ctx___0 , int voc , int pan ) ;
#line 64
int xmp_smix_numvoices(struct xmp_context *ctx___0 , int num ) ;
#line 65
void xmp_smix_echoback(struct xmp_context *ctx___0 , int msg ) ;
#line 69
int xmp_smix_writepatch(struct xmp_context *ctx___0 , struct patch_info *patch ) ;
#line 70
int xmp_smix_getmsg(struct xmp_context *ctx___0 ) ;
#line 71
void *xmp_smix_buffer(struct xmp_context *ctx___0 ) ;
#line 35 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/drivers/oss.c"
static int audio_fd  ;
#line 37
static void from_fmt(struct xmp_options *o___0 , int outfmt ) ;
#line 38
static int to_fmt(struct xmp_options *o___0 ) ;
#line 39
static void setaudio(struct xmp_options *o___0 ) ;
#line 40
static int init___0(struct xmp_context *ctx___0 ) ;
#line 41
static void shutdown___0(struct xmp_context *ctx___0 ) ;
#line 42
static void bufdump___0(struct xmp_context *ctx___0 , int i___3 ) ;
#line 43
static void flush(void) ;
#line 45 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/drivers/oss.c"
static void dummy(void) 
{ 


  {
#line 47
  return;
}
}
#line 49 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/drivers/oss.c"
static char *help___0[9]  = 
#line 49
  {      (char *)"frag=num,size",      (char *)"Set the number and size of fragments",      (char *)"dev=<device_name>",      (char *)"Audio device to use (default /dev/dsp)", 
        (char *)"nosync",      (char *)"Don\'t flush OSS buffers between modules",      (char *)"voxware",      (char *)"For VoxWare 2.90 (used in Linux 1.2.13)", 
        (char *)((void *)0)};
#line 59 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/drivers/oss.c"
struct xmp_drv_info drv_oss  = 
#line 59
     {(char *)"oss", (char *)"OSS PCM audio", help___0, (int (*)())(& init___0), (void (*)())(& shutdown___0),
    (int (*)())(& xmp_smix_numvoices), & dummy, (void (*)())(& xmp_smix_echoback),
    & dummy, (void (*)())(& xmp_smix_setvol), & dummy, (void (*)())(& xmp_smix_setpan),
    & dummy, (void (*)())(& xmp_smix_seteffect), & dummy, & flush, & dummy, (void (*)())(& bufdump___0),
    & dummy, & dummy, & dummy, (int (*)())(& xmp_smix_writepatch), (int (*)())(& xmp_smix_getmsg),
    (struct xmp_drv_info *)((void *)0)};
#line 86 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/drivers/oss.c"
static int fragnum  ;
#line 86 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/drivers/oss.c"
static int fragsize  ;
#line 87 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/drivers/oss.c"
static int do_sync  =    1;
#line 89 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/drivers/oss.c"
static int voxware  =    0;
#line 92 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/drivers/oss.c"
static int to_fmt(struct xmp_options *o___0 ) 
{ 
  int fmt___0 ;

  {
#line 96
  if (! o___0->resol) {
#line 97
    return (1);
  }
#line 99
  if (o___0->resol == 8) {
#line 100
    fmt___0 = 72;
  } else
#line 102
  if (o___0->big_endian) {
#line 102
    fmt___0 = 288;
  } else {
#line 102
    fmt___0 = 144;
  }
#line 106
  if (o___0->outfmt & (1 << 1)) {
#line 107
    fmt___0 &= 392;
  } else {
#line 109
    fmt___0 &= 112;
  }
#line 111
  return (fmt___0);
}
}
#line 114 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/drivers/oss.c"
static void from_fmt(struct xmp_options *o___0 , int outfmt ) 
{ 


  {
#line 116
  if (outfmt & 1) {
#line 117
    o___0->resol = 0;
#line 118
    return;
  }
#line 121
  if (outfmt & 432) {
#line 122
    o___0->resol = 16;
  } else {
#line 124
    o___0->resol = 8;
  }
#line 126
  if (outfmt & 392) {
#line 127
    o___0->outfmt |= 1 << 1;
  } else {
#line 129
    o___0->outfmt &= ~ (1 << 1);
  }
#line 130
  return;
}
}
#line 134 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/drivers/oss.c"
static int fragset  =    0;
#line 132 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/drivers/oss.c"
static void setaudio(struct xmp_options *o___0 ) 
{ 
  int frag ;
  int fmt___0 ;

  {
  {
#line 135
  frag = 0;
#line 138
  frag = (fragnum << 16) + fragsize;
#line 140
  fmt___0 = to_fmt(o___0);
#line 141
  ioctl(audio_fd, (unsigned long )(((3U << 30) | (unsigned int )(80 << 8)) | 5U) | (sizeof(int ) << 16),
        & fmt___0);
#line 142
  from_fmt(o___0, fmt___0);
#line 144
  fmt___0 = ! (o___0->outfmt & (1 << 2));
#line 145
  ioctl(audio_fd, (unsigned long )(((3U << 30) | (unsigned int )(80 << 8)) | 3U) | (sizeof(int ) << 16),
        & fmt___0);
  }
#line 146
  if (fmt___0) {
#line 147
    o___0->outfmt &= ~ (1 << 2);
  } else {
#line 149
    o___0->outfmt |= 1 << 2;
  }
  {
#line 151
  ioctl(audio_fd, (unsigned long )(((3U << 30) | (unsigned int )(80 << 8)) | 2U) | (sizeof(int ) << 16),
        & o___0->freq);
  }
#line 154
  if (! fragset) {
#line 155
    if (fragnum) {
#line 155
      if (fragsize) {
        {
#line 156
        ioctl(audio_fd, (unsigned long )(((3U << 30) | (unsigned int )(80 << 8)) | 10U) | (sizeof(int ) << 16),
              & frag);
        }
      }
    }
#line 157
    fragset ++;
  }
#line 159
  return;
}
}
#line 168 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/drivers/oss.c"
static char buf[80]  ;
#line 161 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/drivers/oss.c"
static int init___0(struct xmp_context *ctx___0 ) 
{ 
  char *dev_audio[2] ;
  struct xmp_options *o___0 ;
  audio_buf_info info ;
  char *token___0 ;
  char **parm ;
  int i___3 ;
  char s[80] ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  void *__cil_tmp16 ;
  void *__cil_tmp17 ;
  void *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;

  {
#line 163
  dev_audio[0] = (char *)"/dev/dsp";
#line 163
  dev_audio[1] = (char *)"/dev/sound/dsp";
#line 164
  o___0 = & ctx___0->o;
#line 171
  i___3 = 1024;
#line 173
  parm = o___0->parm;
  {
#line 173
  while (1) {
    while_continue: /* CIL Label */ ;
#line 173
    if (! *parm) {
#line 173
      goto while_break;
    }
    {
#line 173
    strncpy((char */* __restrict  */)(s), (char const   */* __restrict  */)*parm,
            (size_t )80);
#line 173
    token___0 = strtok((char */* __restrict  */)(s), (char const   */* __restrict  */)":=");
#line 173
    token___0 = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)"");
#line 174
    tmp___0 = strcmp((char const   *)(s), "frag");
    }
#line 174
    if (! tmp___0) {
      {
#line 174
      tmp = sscanf((char const   */* __restrict  */)token___0, (char const   */* __restrict  */)"%d,%d",
                   & fragnum, & i___3);
      }
#line 174
      if (2 > tmp) {
        {
#line 174
        while (1) {
          while_continue___0: /* CIL Label */ ;
          {
#line 174
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"xmp: incorrect parameters in -D %s\n",
                  s);
#line 174
          exit(-4);
          }
#line 174
          goto while_break___0;
        }
        while_break___0: /* CIL Label */ ;
        }
      }
    }
    {
#line 175
    tmp___1 = strcmp((char const   *)(s), "dev");
    }
#line 175
    if (! tmp___1) {
#line 175
      if ((unsigned long )token___0 == (unsigned long )((void *)0)) {
        {
#line 175
        while (1) {
          while_continue___1: /* CIL Label */ ;
          {
#line 175
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"xmp: incorrect parameters in -D %s\n",
                  s);
#line 175
          exit(-4);
          }
#line 175
          goto while_break___1;
        }
        while_break___1: /* CIL Label */ ;
        }
      } else {
#line 175
        dev_audio[0] = token___0;
      }
    }
    {
#line 177
    tmp___2 = strcmp((char const   *)(s), "voxware");
    }
#line 177
    if (! tmp___2) {
#line 177
      if ((unsigned long )token___0 != (unsigned long )((void *)0)) {
        {
#line 177
        while (1) {
          while_continue___2: /* CIL Label */ ;
          {
#line 177
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"xmp: incorrect parameters in -D %s\n",
                  s);
#line 177
          exit(-4);
          }
#line 177
          goto while_break___2;
        }
        while_break___2: /* CIL Label */ ;
        }
      } else {
#line 177
        voxware = 1;
      }
    }
    {
#line 179
    tmp___3 = strcmp((char const   *)(s), "nosync");
    }
#line 179
    if (! tmp___3) {
#line 179
      if ((unsigned long )token___0 != (unsigned long )((void *)0)) {
        {
#line 179
        while (1) {
          while_continue___3: /* CIL Label */ ;
          {
#line 179
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"xmp: incorrect parameters in -D %s\n",
                  s);
#line 179
          exit(-4);
          }
#line 179
          goto while_break___3;
        }
        while_break___3: /* CIL Label */ ;
        }
      } else {
#line 179
        do_sync = 0;
      }
    }
#line 173
    parm ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 182
  fragsize = 0;
  {
#line 182
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 182
    i___3 >>= 1;
#line 182
    if (! i___3) {
#line 182
      goto while_break___4;
    }
#line 182
    fragsize ++;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 183
  if (fragsize < 4) {
#line 184
    fragsize = 4;
  }
#line 185
  if (fragnum > 1) {
#line 186
    fragnum --;
  }
#line 188
  i___3 = 0;
  {
#line 188
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 188
    if (! ((unsigned long )i___3 < sizeof(dev_audio) / sizeof(dev_audio[0]))) {
#line 188
      goto while_break___5;
    }
    {
#line 189
    audio_fd = open((char const   *)dev_audio[i___3], 1);
    }
#line 189
    if (audio_fd >= 0) {
#line 190
      goto while_break___5;
    }
#line 188
    i___3 ++;
  }
  while_break___5: /* CIL Label */ ;
  }
#line 191
  if (audio_fd < 0) {
#line 192
    return (-5);
  }
  {
#line 194
  setaudio(o___0);
  }
#line 197
  if (! voxware) {
    {
#line 198
    tmp___4 = ioctl(audio_fd, (unsigned long )(((2U << 30) | (unsigned int )(80 << 8)) | 12U) | (sizeof(audio_buf_info ) << 16),
                    & info);
    }
#line 198
    if (tmp___4 == 0) {
      {
#line 199
      snprintf((char */* __restrict  */)(buf), (size_t )80, (char const   */* __restrict  */)"%s [%d fragments of %d bytes]",
               drv_oss.description, info.fragstotal, info.fragsize);
#line 202
      drv_oss.description = buf;
      }
    }
  }
  {
#line 207
  tmp___5 = xmp_smix_on(ctx___0);
  }
#line 207
  return (tmp___5);
}
}
#line 213 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/drivers/oss.c"
static void bufdump___0(struct xmp_context *ctx___0 , int i___3 ) 
{ 
  int j ;
  void *b___1 ;

  {
  {
#line 218
  b___1 = xmp_smix_buffer(ctx___0);
  }
  {
#line 219
  while (1) {
    while_continue: /* CIL Label */ ;
#line 219
    if (! i___3) {
#line 219
      goto while_break;
    }
    {
#line 220
    j = write(audio_fd, (void const   *)b___1, (size_t )i___3);
    }
#line 220
    if (j > 0) {
#line 221
      i___3 -= j;
#line 222
      b___1 = (void *)((char *)b___1 + j);
    } else {
#line 224
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 226
  return;
}
}
#line 228 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/drivers/oss.c"
static void shutdown___0(struct xmp_context *ctx___0 ) 
{ 


  {
  {
#line 230
  xmp_smix_off(ctx___0);
#line 231
  ioctl(audio_fd, (unsigned long )((unsigned int )(80 << 8)));
#line 232
  close(audio_fd);
  }
#line 233
  return;
}
}
#line 235 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/drivers/oss.c"
static void flush(void) 
{ 


  {
#line 237
  if (! do_sync) {
#line 238
    return;
  }
  {
#line 240
  ioctl(audio_fd, (unsigned long )((unsigned int )(80 << 8) | 1U));
  }
#line 241
  return;
}
}
#line 471 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *malloc(size_t __size )  __attribute__((__malloc__)) ;
#line 127 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strcpy)(char * __restrict  __dest ,
                                                                                       char const   * __restrict  __src ) ;
#line 138
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strncat)(char * __restrict  __dest ,
                                                                                        char const   * __restrict  __src ,
                                                                                        size_t __n ) ;
#line 260
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1))) strrchr)(char const   *__s ,
                                                                                      int __c )  __attribute__((__pure__)) ;
#line 397
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1))) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 331 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __off_t lseek(int __fd , __off_t __offset , int __whence ) ;
#line 198 "src/include/xmp.h"
char *global_filename ;
#line 11 "src/include/convert.h"
void xmp_cvt_sex(int l , char *p ) ;
#line 28 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/drivers/wav.c"
static int fd  ;
#line 29 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/drivers/wav.c"
static uint32 size  ;
#line 31
static int init___1(struct xmp_context *ctx___0 ) ;
#line 32
static void bufdump___1(struct xmp_context *ctx___0 , int i___3 ) ;
#line 33
static void shutdown___1(struct xmp_context *ctx___0 ) ;
#line 35 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/drivers/wav.c"
static void dummy___0(void) 
{ 


  {
#line 37
  return;
}
}
#line 39 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/drivers/wav.c"
struct xmp_drv_info drv_wav  = 
#line 39
     {(char *)"wav", (char *)"WAV writer", (char **)((void *)0), (int (*)())(& init___1),
    (void (*)())(& shutdown___1), (int (*)())(& xmp_smix_numvoices), & dummy___0,
    (void (*)())(& xmp_smix_echoback), & dummy___0, (void (*)())(& xmp_smix_setvol),
    & dummy___0, (void (*)())(& xmp_smix_setpan), & dummy___0, (void (*)())(& xmp_smix_seteffect),
    & dummy___0, & dummy___0, & dummy___0, (void (*)())(& bufdump___1), & dummy___0,
    & dummy___0, & dummy___0, (int (*)())(& xmp_smix_writepatch), (int (*)())(& xmp_smix_getmsg),
    (struct xmp_drv_info *)((void *)0)};
#line 66 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/drivers/wav.c"
static void writeval_16l(int fd___1 , uint16 v ) 
{ 
  uint8 x ;

  {
  {
#line 70
  x = (uint8 )((int )v & 255);
#line 71
  write(fd___1, (void const   *)(& x), (size_t )1);
#line 73
  x = (uint8 )((int )v >> 8);
#line 74
  write(fd___1, (void const   *)(& x), (size_t )1);
  }
#line 75
  return;
}
}
#line 77 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/drivers/wav.c"
static void writeval_32l(int fd___1 , uint32 v ) 
{ 
  uint8 x ;

  {
  {
#line 81
  x = (uint8 )(v & 255U);
#line 82
  write(fd___1, (void const   *)(& x), (size_t )1);
#line 84
  x = (uint8 )((v >> 8) & 255U);
#line 85
  write(fd___1, (void const   *)(& x), (size_t )1);
#line 87
  x = (uint8 )((v >> 16) & 255U);
#line 88
  write(fd___1, (void const   *)(& x), (size_t )1);
#line 90
  x = (uint8 )((v >> 24) & 255U);
#line 91
  write(fd___1, (void const   *)(& x), (size_t )1);
  }
#line 92
  return;
}
}
#line 94 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/drivers/wav.c"
static int init___1(struct xmp_context *ctx___0 ) 
{ 
  char *buf___1 ;
  uint32 len ;
  uint16 chan ;
  uint32 sampling_rate ;
  uint32 bytes_per_second ;
  uint16 bytes_per_frame ;
  uint16 bits_per_sample ;
  char *f ;
  char filename[260] ;
  struct xmp_options *o___0 ;
  int tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  void *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;

  {
#line 97
  len = (uint32 )0;
#line 102
  o___0 = & ctx___0->o;
#line 104
  if (! o___0->outfile) {
#line 105
    if (global_filename) {
      {
#line 106
      f = strrchr((char const   *)global_filename, '/');
      }
#line 106
      if ((unsigned long )f != (unsigned long )((void *)0)) {
        {
#line 107
        strncpy((char */* __restrict  */)(filename), (char const   */* __restrict  */)(f + 1),
                (size_t )255);
        }
      } else {
        {
#line 109
        strncpy((char */* __restrict  */)(filename), (char const   */* __restrict  */)global_filename,
                (size_t )255);
        }
      }
    } else {
      {
#line 111
      strcpy((char */* __restrict  */)(filename), (char const   */* __restrict  */)"xmp");
      }
    }
    {
#line 114
    strncat((char */* __restrict  */)(filename), (char const   */* __restrict  */)".wav",
            (size_t )260);
#line 116
    o___0->outfile = filename;
    }
  }
  {
#line 119
  tmp = strcmp((char const   *)o___0->outfile, "-");
  }
#line 119
  if (tmp) {
    {
#line 120
    fd = open((char const   *)o___0->outfile, 577, 420);
    }
#line 122
    if (fd < 0) {
#line 123
      return (-1);
    }
  } else {
#line 125
    fd = 1;
  }
  {
#line 128
  tmp___0 = strlen((char const   *)drv_wav.description);
#line 128
  tmp___1 = strlen((char const   *)o___0->outfile);
#line 128
  tmp___2 = malloc((tmp___0 + tmp___1) + 8U);
#line 128
  buf___1 = (char *)tmp___2;
#line 129
  tmp___3 = strcmp((char const   *)o___0->outfile, "-");
  }
#line 129
  if (tmp___3) {
    {
#line 130
    sprintf((char */* __restrict  */)buf___1, (char const   */* __restrict  */)"%s: %s",
            drv_wav.description, o___0->outfile);
#line 131
    drv_wav.description = buf___1;
    }
  } else {
#line 133
    drv_wav.description = (char *)"WAV writer: stdout";
#line 134
    len = (uint32 )-1;
  }
  {
#line 137
  write(fd, (void const   *)"RIFF", (size_t )4);
#line 138
  writeval_32l(fd, len);
#line 139
  write(fd, (void const   *)"WAVE", (size_t )4);
  }
#line 141
  if (o___0->outfmt & (1 << 2)) {
#line 141
    chan = (uint16 )1;
  } else {
#line 141
    chan = (uint16 )2;
  }
#line 142
  sampling_rate = (uint32 )o___0->freq;
#line 143
  bits_per_sample = (uint16 )o___0->resol;
#line 144
  if ((int )bits_per_sample == 8) {
#line 145
    o___0->outfmt |= 1 << 1;
  }
  {
#line 146
  bytes_per_frame = (uint16 )(((int )chan * (int )bits_per_sample) / 8);
#line 147
  bytes_per_second = sampling_rate * (uint32 )bytes_per_frame;
#line 149
  write(fd, (void const   *)"fmt ", (size_t )4);
#line 150
  writeval_32l(fd, (uint32 )16);
#line 151
  writeval_16l(fd, (uint16 )1);
#line 152
  writeval_16l(fd, chan);
#line 153
  writeval_32l(fd, sampling_rate);
#line 154
  writeval_32l(fd, bytes_per_second);
#line 155
  writeval_16l(fd, bytes_per_frame);
#line 156
  writeval_16l(fd, bits_per_sample);
#line 158
  write(fd, (void const   *)"data", (size_t )4);
#line 159
  writeval_32l(fd, len);
#line 161
  size = (uint32 )0;
#line 163
  tmp___4 = xmp_smix_on(ctx___0);
  }
#line 163
  return (tmp___4);
}
}
#line 166 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/drivers/wav.c"
static void bufdump___1(struct xmp_context *ctx___0 , int i___3 ) 
{ 
  struct xmp_options *o___0 ;
  char *b___1 ;
  void *tmp ;

  {
  {
#line 168
  o___0 = & ctx___0->o;
#line 171
  tmp = xmp_smix_buffer(ctx___0);
#line 171
  b___1 = (char *)tmp;
  }
#line 172
  if (o___0->big_endian) {
    {
#line 173
    xmp_cvt_sex(i___3, b___1);
    }
  }
  {
#line 174
  write(fd, (void const   *)b___1, (size_t )i___3);
#line 175
  size += (uint32 )i___3;
  }
#line 176
  return;
}
}
#line 178 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/drivers/wav.c"
static void shutdown___1(struct xmp_context *ctx___0 ) 
{ 


  {
  {
#line 180
  xmp_smix_off(ctx___0);
#line 182
  lseek(fd, (__off_t )40, 0);
#line 183
  writeval_32l(fd, size);
#line 185
  lseek(fd, (__off_t )4, 0);
#line 186
  writeval_32l(fd, size + 40U);
  }
#line 188
  if (fd) {
    {
#line 189
    close(fd);
    }
  }
#line 190
  return;
}
}
#line 28 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/drivers/file.c"
static int fd___0  ;
#line 29 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/drivers/file.c"
static int endian  ;
#line 31
static int init___2(struct xmp_context *ctx___0 ) ;
#line 32
static void bufdump___2(struct xmp_context *ctx___0 , int i___3 ) ;
#line 33
static void shutdown___2(struct xmp_context *ctx___0 ) ;
#line 35 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/drivers/file.c"
static void dummy___1(void) 
{ 


  {
#line 37
  return;
}
}
#line 39 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/drivers/file.c"
static char *help___1[5]  = {      (char *)"big-endian",      (char *)"Generate big-endian 16-bit samples",      (char *)"little-endian",      (char *)"Generate little-endian 16-bit samples", 
        (char *)((void *)0)};
#line 45 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/drivers/file.c"
struct xmp_drv_info drv_file  = 
#line 45
     {(char *)"file", (char *)"file", help___1, (int (*)())(& init___2), (void (*)())(& shutdown___2),
    (int (*)())(& xmp_smix_numvoices), & dummy___1, (void (*)())(& xmp_smix_echoback),
    & dummy___1, (void (*)())(& xmp_smix_setvol), & dummy___1, (void (*)())(& xmp_smix_setpan),
    & dummy___1, (void (*)())(& xmp_smix_seteffect), & dummy___1, & dummy___1, & dummy___1,
    (void (*)())(& bufdump___2), & dummy___1, & dummy___1, & dummy___1, (int (*)())(& xmp_smix_writepatch),
    (int (*)())(& xmp_smix_getmsg), (struct xmp_drv_info *)((void *)0)};
#line 72 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/drivers/file.c"
static int init___2(struct xmp_context *ctx___0 ) 
{ 
  struct xmp_options *o___0 ;
  char *buf___1 ;
  int bsize ;
  char *token___0 ;
  char **parm ;
  char s[80] ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  void *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  void *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;

  {
#line 74
  o___0 = & ctx___0->o;
#line 79
  endian = 0;
#line 80
  parm = o___0->parm;
  {
#line 80
  while (1) {
    while_continue: /* CIL Label */ ;
#line 80
    if (! *parm) {
#line 80
      goto while_break;
    }
    {
#line 80
    strncpy((char */* __restrict  */)(s), (char const   */* __restrict  */)*parm,
            (size_t )80);
#line 80
    token___0 = strtok((char */* __restrict  */)(s), (char const   */* __restrict  */)":=");
#line 80
    token___0 = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)"");
#line 81
    tmp = strcmp((char const   *)(s), "big-endian");
    }
#line 81
    if (! tmp) {
#line 81
      if ((unsigned long )token___0 != (unsigned long )((void *)0)) {
        {
#line 81
        while (1) {
          while_continue___0: /* CIL Label */ ;
          {
#line 81
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"xmp: incorrect parameters in -D %s\n",
                  s);
#line 81
          exit(-4);
          }
#line 81
          goto while_break___0;
        }
        while_break___0: /* CIL Label */ ;
        }
      } else {
#line 81
        endian = 1;
      }
    }
    {
#line 82
    tmp___0 = strcmp((char const   *)(s), "little-endian");
    }
#line 82
    if (! tmp___0) {
#line 82
      if ((unsigned long )token___0 != (unsigned long )((void *)0)) {
        {
#line 82
        while (1) {
          while_continue___1: /* CIL Label */ ;
          {
#line 82
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"xmp: incorrect parameters in -D %s\n",
                  s);
#line 82
          exit(-4);
          }
#line 82
          goto while_break___1;
        }
        while_break___1: /* CIL Label */ ;
        }
      } else {
#line 82
        endian = -1;
      }
    }
#line 80
    parm ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 85
  if (! o___0->outfile) {
#line 86
    o___0->outfile = (char *)"xmp.out";
  }
  {
#line 88
  tmp___1 = strcmp((char const   *)o___0->outfile, "-");
  }
#line 88
  if (tmp___1) {
    {
#line 89
    fd___0 = open((char const   *)o___0->outfile, 577, 420);
    }
#line 91
    if (fd___0 < 0) {
#line 92
      return (-1);
    }
  } else {
#line 94
    fd___0 = 1;
  }
  {
#line 97
  tmp___2 = strlen((char const   *)drv_file.description);
#line 97
  tmp___3 = strlen((char const   *)o___0->outfile);
#line 97
  bsize = (int )((tmp___2 + tmp___3) + 8U);
#line 98
  tmp___4 = malloc((size_t )bsize);
#line 98
  buf___1 = (char *)tmp___4;
#line 99
  tmp___5 = strcmp((char const   *)o___0->outfile, "-");
  }
#line 99
  if (tmp___5) {
    {
#line 100
    snprintf((char */* __restrict  */)buf___1, (size_t )bsize, (char const   */* __restrict  */)"%s: %s",
             drv_file.description, o___0->outfile);
#line 102
    drv_file.description = buf___1;
    }
  } else {
#line 104
    drv_file.description = (char *)"Output to stdout";
  }
  {
#line 107
  tmp___6 = xmp_smix_on(ctx___0);
  }
#line 107
  return (tmp___6);
}
}
#line 110 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/drivers/file.c"
static void bufdump___2(struct xmp_context *ctx___0 , int i___3 ) 
{ 
  struct xmp_options *o___0 ;
  int j ;
  void *b___1 ;

  {
  {
#line 112
  o___0 = & ctx___0->o;
#line 116
  b___1 = xmp_smix_buffer(ctx___0);
  }
#line 117
  if (o___0->big_endian) {
#line 117
    if (endian == -1) {
      {
#line 118
      xmp_cvt_sex(i___3, (char *)b___1);
      }
    } else {
#line 117
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 117
  if (! o___0->big_endian) {
#line 117
    if (endian == 1) {
      {
#line 118
      xmp_cvt_sex(i___3, (char *)b___1);
      }
    }
  }
  {
#line 120
  while (1) {
    while_continue: /* CIL Label */ ;
#line 120
    if (! i___3) {
#line 120
      goto while_break;
    }
    {
#line 121
    j = write(fd___0, (void const   *)b___1, (size_t )i___3);
    }
#line 121
    if (j > 0) {
#line 122
      i___3 -= j;
#line 123
      b___1 = (void *)((char *)b___1 + j);
    } else {
#line 125
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 127
  return;
}
}
#line 129 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/drivers/file.c"
static void shutdown___2(struct xmp_context *ctx___0 ) 
{ 


  {
  {
#line 131
  xmp_smix_off(ctx___0);
  }
#line 133
  if (fd___0) {
    {
#line 134
    close(fd___0);
    }
  }
#line 135
  return;
}
}
#line 380 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int rand(void) ;
#line 382
extern  __attribute__((__nothrow__)) void srand(unsigned int __seed ) ;
#line 186 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t time(time_t *__timer ) ;
#line 189
extern  __attribute__((__nothrow__)) double difftime(time_t __time1 , time_t __time0 )  __attribute__((__const__)) ;
#line 73 "/usr/include/sys/time.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) gettimeofday)(struct timeval * __restrict  __tv ,
                                                                                         __timezone_ptr_t __tz ) ;
#line 101 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) __sighandler_t signal(int __sig , void (*__handler)(int  ) ) ;
#line 126
extern  __attribute__((__nothrow__)) int kill(__pid_t __pid , int __sig ) ;
#line 456 "/usr/include/unistd.h"
extern int usleep(__useconds_t __useconds ) ;
#line 623
extern  __attribute__((__nothrow__)) __pid_t getpid(void) ;
#line 626
extern  __attribute__((__nothrow__)) __pid_t getppid(void) ;
#line 855
extern  __attribute__((__nothrow__)) __pid_t tcgetpgrp(int __fd ) ;
#line 49 "src/include/getopt.h"
extern int optind ;
#line 67 "/usr/include/termios.h"
extern  __attribute__((__nothrow__)) int tcgetattr(int __fd , struct termios *__termios_p ) ;
#line 71
extern  __attribute__((__nothrow__)) int tcsetattr(int __fd , int __optional_actions ,
                                                   struct termios  const  *__termios_p ) ;
#line 200 "src/include/xmp.h"
void *xmp_create_context(void) ;
#line 201
void xmp_free_context(xmp_context ctx___0 ) ;
#line 203
struct xmp_options *xmp_get_options(xmp_context ctx___0 ) ;
#line 205
void xmp_init(xmp_context ctx___0 , int argc , char **argv ) ;
#line 207
int xmp_load_module(xmp_context ctx___0 , char *s ) ;
#line 209
struct xmp_module_info *xmp_get_module_info(xmp_context ctx___0 , struct xmp_module_info *i___3 ) ;
#line 212
char *xmp_get_driver_description(xmp_context ctx___0 ) ;
#line 214
void xmp_get_driver_cfg(xmp_context ctx___0 , int *srate , int *res , int *chn , int *itpt ) ;
#line 215
void xmp_channel_mute(xmp_context ctx___0 , int from , int num , int on ) ;
#line 216
void xmp_register_event_callback(xmp_context ctx___0 , void (*cb)(unsigned long  ) ) ;
#line 217
int xmp_player_ctl(xmp_context ctx___0 , int cmd , int arg ) ;
#line 218
int xmp_open_audio(xmp_context ctx___0 ) ;
#line 219
void xmp_close_audio(xmp_context ctx___0 ) ;
#line 221
int xmp_player_start(xmp_context ctx___0 ) ;
#line 222
int xmp_player_frame(xmp_context ctx___0 ) ;
#line 223
void xmp_player_end(xmp_context ctx___0 ) ;
#line 224
void xmp_play_buffer(xmp_context ctx___0 ) ;
#line 226
void xmp_release_module(xmp_context ctx___0 ) ;
#line 227
int xmp_verbosity_level(xmp_context ctx___0 , int i___3 ) ;
#line 74 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/main/main.c"
int probeonly  =    0;
#line 75 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/main/main.c"
int randomize  =    0;
#line 76 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/main/main.c"
int loadonly  =    0;
#line 77 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/main/main.c"
int nocmd  =    0;
#line 78 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/main/main.c"
int showtime  =    0;
#line 83 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/main/main.c"
static struct xmp_module_info mi  ;
#line 85 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/main/main.c"
static int verbosity  ;
#line 87 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/main/main.c"
static struct termios term  ;
#line 89 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/main/main.c"
static int background  =    0;
#line 91 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/main/main.c"
static int stopped  =    0;
#line 93 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/main/main.c"
static int refresh_status  =    0;
#line 94 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/main/main.c"
static int max_nch  =    0;
#line 95 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/main/main.c"
static double rows  ;
#line 95 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/main/main.c"
static double tot_nch  ;
#line 96 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/main/main.c"
int skip  =    0;
#line 99 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/main/main.c"
static int sigusr  =    0;
#line 102
void get_options(int argc , char **argv , struct xmp_options *opt , xmp_context ctx___0 ) ;
#line 103
void init_drivers(void) ;
#line 105 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/main/main.c"
static xmp_context ctx  ;
#line 106 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/main/main.c"
static int paused  ;
#line 109 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/main/main.c"
static int set_tty(void) 
{ 
  struct termios t ;
  int tmp ;
  int tmp___0 ;
  void *__cil_tmp4 ;
  void *__cil_tmp5 ;

  {
#line 114
  if (background) {
#line 115
    return (-1);
  }
  {
#line 117
  tmp = tcgetattr(0, & term);
  }
#line 117
  if (tmp < 0) {
#line 118
    return (-1);
  }
  {
#line 120
  t = term;
#line 121
  t.c_lflag &= 4294967029U;
#line 122
  t.c_cc[5] = (cc_t )0;
#line 122
  t.c_cc[6] = t.c_cc[5];
#line 124
  tmp___0 = tcsetattr(0, 2, (struct termios  const  *)(& t));
  }
#line 124
  if (tmp___0 < 0) {
#line 125
    return (-1);
  }
#line 128
  return (0);
}
}
#line 132 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/main/main.c"
static int reset_tty(void) 
{ 
  int tmp ;
  char *__cil_tmp2 ;

  {
#line 135
  if (background) {
#line 136
    return (-1);
  }
  {
#line 138
  tmp = tcsetattr(0, 2, (struct termios  const  *)(& term));
  }
#line 138
  if (tmp < 0) {
    {
#line 139
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"can\'t reset terminal!\n");
    }
#line 140
    return (-1);
  }
#line 144
  return (0);
}
}
#line 151 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/main/main.c"
static void sigtstp_handler(void) 
{ 
  __pid_t tmp ;
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;

  {
#line 153
  if (! stopped) {
#line 154
    if (showtime) {
      {
#line 155
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
      }
    } else
#line 156
    if (verbosity) {
      {
#line 157
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"] - STOPPED\n");
      }
    }
    {
#line 158
    xmp_player_ctl(ctx, 7, 0);
#line 159
    stopped = 1;
    }
  }
  {
#line 162
  signal(20, (void (*)(int  ))0);
#line 163
  tmp = getpid();
#line 163
  kill(tmp, 20);
  }
#line 164
  return;
}
}
#line 167 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/main/main.c"
static void sigcont_handler(void) 
{ 
  __pid_t tmp ;
  __pid_t tmp___0 ;

  {
  {
#line 170
  tmp = tcgetpgrp(0);
#line 170
  tmp___0 = getppid();
#line 170
  background = tmp == tmp___0;
  }
#line 173
  if (background) {
    {
#line 174
    reset_tty();
    }
  } else {
    {
#line 176
    set_tty();
    }
  }
#line 178
  if (stopped) {
    {
#line 179
    xmp_player_ctl(ctx, 8, 0);
    }
  }
  {
#line 181
  stopped = 0;
#line 182
  refresh_status = 1;
#line 187
  signal(18, (void (*)(int  ))(& sigcont_handler));
#line 188
  signal(20, (void (*)(int  ))(& sigtstp_handler));
  }
#line 189
  return;
}
}
#line 192 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/main/main.c"
static void sigusr_handler(int i___3 ) 
{ 


  {
  {
#line 194
  sigusr = i___3;
#line 194
  signal(sigusr, & sigusr_handler);
  }
#line 195
  return;
}
}
#line 198 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/main/main.c"
static void cleanup(int s ) 
{ 
  char *__cil_tmp2 ;

  {
  {
#line 200
  signal(15, (void (*)(int  ))0);
#line 201
  signal(2, (void (*)(int  ))0);
#line 203
  signal(3, (void (*)(int  ))0);
#line 205
  signal(8, (void (*)(int  ))0);
#line 206
  signal(11, (void (*)(int  ))0);
#line 208
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n*** Interrupted: signal %d caught\n",
          s);
#line 209
  xmp_player_ctl(ctx, 3, 0);
#line 210
  xmp_close_audio(ctx);
#line 212
  reset_tty();
#line 214
  exit(-2);
  }
}
}
#line 262
static void process_echoback(unsigned long i___3 ) ;
#line 262 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/main/main.c"
static int _pos  =    -1;
#line 263 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/main/main.c"
static int tpo  ;
#line 263 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/main/main.c"
static int bpm  ;
#line 263 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/main/main.c"
static int nch  ;
#line 263 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/main/main.c"
static int _tpo  =    -1;
#line 263 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/main/main.c"
static int _bpm  =    -1;
#line 264 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/main/main.c"
static int pos  ;
#line 264 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/main/main.c"
static int pat  ;
#line 259 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/main/main.c"
static void process_echoback(unsigned long i___3 ) 
{ 
  unsigned long msg ;
  int rem ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
#line 261
  msg = i___3 >> 4;
#line 267
  if (sigusr == 10) {
    {
#line 268
    skip = 1;
#line 269
    xmp_player_ctl(ctx, 3, 0);
#line 270
    paused = 0;
#line 271
    sigusr = 0;
    }
  } else
#line 272
  if (sigusr == 12) {
    {
#line 273
    skip = -1;
#line 274
    xmp_player_ctl(ctx, 3, 0);
#line 275
    paused = 0;
#line 276
    sigusr = 0;
    }
  }
#line 280
  if (background) {
#line 281
    return;
  }
#line 283
  if (showtime) {
    {
#line 285
    if ((i___3 & 15UL) == 12UL) {
#line 285
      goto case_12;
    }
#line 284
    goto switch_break;
    case_12: /* CIL Label */ 
    {
#line 287
    rem = (int )((unsigned long )(mi.time / 100) - msg);
#line 288
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\r%02d:%02d:%02d.%d  ",
            (int )(msg / 36000UL), (int )((msg / 600UL) % 60UL), (int )((msg / 10UL) % 60UL),
            (int )(msg % 10UL));
#line 291
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"-%02d:%02d:%02d.%d",
            rem / 36000, (rem / 600) % 60, (rem / 10) % 60, rem % 10);
    }
#line 295
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
#line 298
  if (verbosity) {
    {
#line 300
    if ((i___3 & 15UL) == 2UL) {
#line 300
      goto case_2;
    }
#line 306
    if ((i___3 & 15UL) == 5UL) {
#line 306
      goto case_5;
    }
#line 310
    if ((i___3 & 15UL) == 10UL) {
#line 310
      goto case_10;
    }
#line 315
    if ((i___3 & 15UL) == 6UL) {
#line 315
      goto case_6;
    }
#line 299
    goto switch_break___0;
    case_2: /* CIL Label */ 
#line 301
    _bpm = bpm;
#line 302
    _tpo = tpo;
#line 303
    bpm = (int )(msg & 255UL);
#line 304
    tpo = (int )(msg >> 8);
#line 305
    goto switch_break___0;
    case_5: /* CIL Label */ 
#line 307
    pos = (int )(msg & 255UL);
#line 308
    pat = (int )(msg >> 8);
#line 309
    goto switch_break___0;
    case_10: /* CIL Label */ 
#line 311
    nch = (int )(msg & 255UL);
#line 312
    if (nch > max_nch) {
#line 313
      max_nch = nch;
    }
#line 314
    goto switch_break___0;
    case_6: /* CIL Label */ 
#line 316
    if (showtime) {
#line 317
      goto switch_break___0;
    }
#line 318
    rows += (double )1;
#line 319
    tot_nch += (double )nch;
#line 320
    if (refresh_status) {
#line 320
      goto _L;
    } else
#line 320
    if (! (msg & 255UL)) {
#line 320
      goto _L;
    } else
#line 320
    if (pos != _pos) {
#line 320
      goto _L;
    } else
#line 320
    if (bpm != _bpm) {
#line 320
      goto _L;
    } else
#line 320
    if (tpo != _tpo) {
      _L: /* CIL Label */ 
      {
#line 322
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\rTempo[%02X] BPM[%02X] Pos[%02X/%02X] Pat[%02X/%02X] Row[  /  ] Chn[  /  ]\b",
              tpo, bpm, pos, mi.len - 1, pat, mi.pat - 1);
#line 325
      _pos = pos;
      }
#line 326
      if (refresh_status) {
#line 327
        refresh_status = 0;
      }
    }
    {
#line 329
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b%02X/%02X] Chn[%02X/%02X",
            (int )(msg & 255UL), (int )(msg >> 8), nch, max_nch);
    }
#line 331
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
  }
#line 334
  return;
}
}
#line 337 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/main/main.c"
void read_keyboard(void) 
{ 
  unsigned char cmd ;
  int k ;
  char const   *tmp ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
#line 344
  if (nocmd) {
#line 345
    return;
  }
  {
#line 352
  k = read(0, (void *)(& cmd), (size_t )1);
  }
#line 370
  if (k > 0) {
    {
#line 372
    if ((int )cmd == 113) {
#line 372
      goto case_113;
    }
#line 377
    if ((int )cmd == 102) {
#line 377
      goto case_102;
    }
#line 381
    if ((int )cmd == 98) {
#line 381
      goto case_98;
    }
#line 385
    if ((int )cmd == 110) {
#line 385
      goto case_110;
    }
#line 390
    if ((int )cmd == 112) {
#line 390
      goto case_112;
    }
#line 395
    if ((int )cmd == 32) {
#line 395
      goto case_32;
    }
#line 411
    if ((int )cmd == 57) {
#line 411
      goto case_57;
    }
#line 411
    if ((int )cmd == 56) {
#line 411
      goto case_57;
    }
#line 411
    if ((int )cmd == 55) {
#line 411
      goto case_57;
    }
#line 411
    if ((int )cmd == 54) {
#line 411
      goto case_57;
    }
#line 411
    if ((int )cmd == 53) {
#line 411
      goto case_57;
    }
#line 411
    if ((int )cmd == 52) {
#line 411
      goto case_57;
    }
#line 411
    if ((int )cmd == 51) {
#line 411
      goto case_57;
    }
#line 411
    if ((int )cmd == 50) {
#line 411
      goto case_57;
    }
#line 411
    if ((int )cmd == 49) {
#line 411
      goto case_57;
    }
#line 414
    if ((int )cmd == 48) {
#line 414
      goto case_48;
    }
#line 417
    if ((int )cmd == 33) {
#line 417
      goto case_33;
    }
#line 371
    goto switch_break;
    case_113: /* CIL Label */ 
    {
#line 373
    skip = -2;
#line 374
    xmp_player_ctl(ctx, 3, 0);
#line 375
    paused = 0;
    }
#line 376
    goto switch_break;
    case_102: /* CIL Label */ 
    {
#line 378
    xmp_player_ctl(ctx, 0, 0);
#line 379
    paused = 0;
    }
#line 380
    goto switch_break;
    case_98: /* CIL Label */ 
    {
#line 382
    xmp_player_ctl(ctx, 1, 0);
#line 383
    paused = 0;
    }
#line 384
    goto switch_break;
    case_110: /* CIL Label */ 
    {
#line 386
    skip = 1;
#line 387
    xmp_player_ctl(ctx, 3, 0);
#line 388
    paused = 0;
    }
#line 389
    goto switch_break;
    case_112: /* CIL Label */ 
    {
#line 391
    skip = -1;
#line 392
    xmp_player_ctl(ctx, 3, 0);
#line 393
    paused = 0;
    }
#line 394
    goto switch_break;
    case_32: /* CIL Label */ 
#line 396
    paused ^= 1;
#line 397
    if (verbosity) {
#line 398
      if (paused) {
#line 398
        tmp = "] - PAUSED\b\b\b\b\b\b\b\b\b\b";
      } else {
#line 398
        tmp = "]         \b\b\b\b\b\b\b\b\b\b";
      }
      {
#line 398
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s",
              tmp);
      }
    }
#line 402
    goto switch_break;
    case_57: /* CIL Label */ 
    case_56: /* CIL Label */ 
    case_55: /* CIL Label */ 
    case_54: /* CIL Label */ 
    case_53: /* CIL Label */ 
    case_52: /* CIL Label */ 
    case_51: /* CIL Label */ 
    case_50: /* CIL Label */ 
    case_49: /* CIL Label */ 
    {
#line 412
    xmp_channel_mute(ctx, (int )cmd - 49, 1, -1);
    }
#line 413
    goto switch_break;
    case_48: /* CIL Label */ 
    {
#line 415
    xmp_channel_mute(ctx, 9, 1, -1);
    }
#line 416
    goto switch_break;
    case_33: /* CIL Label */ 
    {
#line 418
    xmp_channel_mute(ctx, 0, 8, 0);
    }
#line 419
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
#line 422
  return;
}
}
#line 425 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/main/main.c"
static void shuffle(int argc , char **argv ) 
{ 
  int i___3 ;
  int j ;
  char *x ;
  int tmp ;

  {
#line 430
  i___3 = 1;
  {
#line 430
  while (1) {
    while_continue: /* CIL Label */ ;
#line 430
    if (! (i___3 < argc)) {
#line 430
      goto while_break;
    }
    {
#line 431
    tmp = rand();
#line 431
    j = 1 + tmp % (argc - 1);
#line 432
    x = *(argv + i___3);
#line 433
    *(argv + i___3) = *(argv + j);
#line 434
    *(argv + j) = x;
#line 430
    i___3 ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 436
  return;
}
}
#line 439 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/main/main.c"
int main(int argc , char **argv ) 
{ 
  int i___3 ;
  int t ;
  int lf_flag ;
  int first ;
  int num_mod ;
  int verb ;
  time_t t0 ;
  time_t t1 ;
  time_t t2 ;
  time_t t3 ;
  struct timeval tv ;
  struct timezone tz ;
  struct xmp_options *opt ;
  int getprevious ;
  int skipprev ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  __pid_t tmp___2 ;
  __pid_t tmp___3 ;
  int srate ;
  int res ;
  int chn ;
  int itpt ;
  char *tmp___4 ;
  char const   *tmp___5 ;
  char const   *tmp___6 ;
  char *line ;
  int lsize ;
  size_t tmp___7 ;
  size_t tmp___8 ;
  void *tmp___9 ;
  int tmp___10 ;
  double tmp___11 ;
  char const   *tmp___12 ;
  int tmp___13 ;
  double tmp___14 ;
  void *__cil_tmp40 ;
  void *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;
  char *__cil_tmp66 ;
  char *__cil_tmp67 ;
  char *__cil_tmp68 ;
  char *__cil_tmp69 ;
  char *__cil_tmp70 ;

  {
  {
#line 441
  verb = 0;
#line 451
  getprevious = 0;
#line 451
  skipprev = 0;
#line 456
  init_drivers();
#line 458
  tmp = xmp_create_context();
#line 458
  ctx = (xmp_context )tmp;
#line 460
  xmp_init(ctx, argc, argv);
#line 461
  opt = xmp_get_options(ctx);
#line 463
  opt->verbosity = 1;
#line 464
  get_options(argc, argv, opt, ctx);
#line 465
  verbosity = opt->verbosity;
  }
#line 467
  if (! probeonly) {
#line 467
    if (! *(argv + optind)) {
      {
#line 468
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: no modules to play\nUse `%s --help\' for more information.\n",
              *(argv + 0), *(argv + 0));
#line 470
      exit(-1);
      }
    }
  }
  {
#line 474
  gettimeofday((struct timeval */* __restrict  */)(& tv), (__timezone_ptr_t )(& tz));
#line 475
  srand((unsigned int )tv.tv_usec);
  }
#line 480
  if (randomize) {
    {
#line 481
    shuffle((argc - optind) + 1, argv + (optind - 1));
    }
  }
#line 483
  if (opt->outfile) {
#line 483
    if (! opt->drv_id) {
#line 484
      opt->drv_id = (char *)"file";
    } else {
      {
#line 483
      tmp___0 = strcmp((char const   *)opt->drv_id, "wav");
      }
#line 483
      if (tmp___0) {
#line 484
        opt->drv_id = (char *)"file";
      }
    }
  }
  {
#line 486
  global_filename = *(argv + optind);
#line 489
  tmp___2 = tcgetpgrp(0);
#line 489
  tmp___3 = getppid();
#line 489
  background = tmp___2 == tmp___3;
  }
#line 489
  if (background) {
    {
#line 490
    verb = opt->verbosity;
#line 491
    opt->verbosity = 0;
#line 492
    i___3 = xmp_open_audio(ctx);
#line 493
    tmp___1 = verb;
#line 493
    opt->verbosity = tmp___1;
#line 493
    xmp_verbosity_level(ctx, tmp___1);
    }
  } else {
    {
#line 497
    i___3 = xmp_open_audio(ctx);
    }
  }
#line 500
  if (i___3 < 0) {
    {
#line 501
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: ",
            *(argv + 0));
    }
    {
#line 503
    if (i___3 == -5) {
#line 503
      goto case_neg_5;
    }
#line 506
    if (i___3 == -2) {
#line 506
      goto case_neg_2;
    }
#line 509
    if (i___3 == -3) {
#line 509
      goto case_neg_3;
    }
#line 512
    goto switch_default;
    case_neg_5: /* CIL Label */ 
    {
#line 504
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"can\'t initialize driver\n");
    }
#line 505
    return (-1);
    case_neg_2: /* CIL Label */ 
    {
#line 507
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"driver does not exist\n");
    }
#line 508
    return (-2);
    case_neg_3: /* CIL Label */ 
    {
#line 510
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"driver not specified\n");
    }
#line 511
    return (-3);
    switch_default: /* CIL Label */ 
    {
#line 513
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"unknown error\n");
    }
#line 514
    return (-128);
    switch_break: /* CIL Label */ ;
    }
  }
  {
#line 518
  xmp_register_event_callback(ctx, & process_echoback);
  }
#line 520
  if (opt->verbosity) {
    {
#line 521
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Extended Module Player 3.0.0-pre\nCopyright (C) 1996-2009 Claudio Matsuoka and Hipolito Carraro Jr\n");
    }
  }
#line 525
  if (probeonly) {
#line 525
    goto _L;
  } else
#line 525
  if (opt->verbosity) {
    _L: /* CIL Label */ 
    {
#line 528
    xmp_get_driver_cfg(ctx, & srate, & res, & chn, & itpt);
#line 529
    tmp___4 = xmp_get_driver_description(ctx);
#line 529
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Using %s\n",
            tmp___4);
    }
#line 530
    if (srate) {
#line 531
      if (chn > 1) {
#line 531
        tmp___5 = "stereo";
      } else {
#line 531
        tmp___5 = "mono";
      }
#line 531
      if (itpt) {
#line 531
        tmp___6 = "interpolated ";
      } else {
#line 531
        tmp___6 = "";
      }
      {
#line 531
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Mixer set to %dbit, %d Hz, %s%s\n",
              res, srate, tmp___6, tmp___5);
      }
    }
  }
#line 536
  if (probeonly) {
    {
#line 537
    exit(0);
    }
  }
  {
#line 561
  signal(15, & cleanup);
#line 562
  signal(2, & cleanup);
#line 563
  signal(8, & cleanup);
#line 564
  signal(11, & cleanup);
#line 566
  signal(3, & cleanup);
#line 569
  signal(20, (void (*)(int  ))(& sigtstp_handler));
#line 572
  signal(18, (void (*)(int  ))(& sigcont_handler));
#line 575
  signal(10, & sigusr_handler);
#line 576
  signal(12, & sigusr_handler);
#line 580
  set_tty();
#line 582
  paused = 0;
#line 583
  time(& t0);
#line 585
  lf_flag = 0;
#line 585
  num_mod = lf_flag;
#line 586
  first = optind;
  }
  {
#line 586
  while (1) {
    while_continue: /* CIL Label */ ;
#line 586
    if (! (optind < argc)) {
#line 586
      goto while_break;
    }
#line 587
    if (getprevious) {
#line 588
      optind -= 2;
#line 589
      if (optind < first) {
#line 590
        optind += 2;
      }
    }
#line 594
    if (opt->verbosity > 0) {
#line 594
      if (! background) {
#line 595
        if (lf_flag) {
          {
#line 596
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
          }
        }
        {
#line 597
        lf_flag = fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Loading %s... (%d of %d)\n",
                          *(argv + optind), (optind - first) + 1, argc - first);
        }
      }
    }
#line 601
    if (background) {
      {
#line 602
      verb = xmp_verbosity_level(ctx, 0);
#line 603
      t = xmp_load_module(ctx, *(argv + optind));
#line 604
      xmp_verbosity_level(ctx, verb);
      }
    } else {
      {
#line 606
      t = xmp_load_module(ctx, *(argv + optind));
      }
    }
#line 609
    if (t < 0) {
      {
#line 611
      if (t == -1) {
#line 611
        goto case_neg_1;
      }
#line 616
      if (t == -2) {
#line 616
        goto case_neg_2___0;
      }
#line 621
      if (t == -3) {
#line 621
        goto case_neg_3___0;
      }
#line 610
      goto switch_break___0;
      case_neg_1: /* CIL Label */ 
      {
#line 612
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s: unrecognized file format\n",
              *(argv + 0), *(argv + optind));
#line 614
      getprevious = skipprev;
      }
#line 615
      goto __Cont;
      case_neg_2___0: /* CIL Label */ 
      {
#line 617
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s: possibly corrupted file\n",
              *(argv + 0), *(argv + optind));
#line 619
      getprevious = skipprev;
      }
#line 620
      goto __Cont;
      case_neg_3___0: /* CIL Label */ 
      {
#line 623
      tmp___7 = strlen((char const   *)*argv);
#line 623
      tmp___8 = strlen((char const   *)*(argv + optind));
#line 623
      lsize = (int )((tmp___7 + tmp___8) + 10U);
#line 624
      tmp___9 = malloc((size_t )lsize);
#line 624
      line = (char *)tmp___9;
#line 625
      snprintf((char */* __restrict  */)line, (size_t )lsize, (char const   */* __restrict  */)"%s: %s",
               *argv, *(argv + optind));
#line 626
      perror((char const   *)line);
#line 627
      getprevious = skipprev;
      }
#line 628
      goto __Cont;
      switch_break___0: /* CIL Label */ ;
      }
    }
    {
#line 632
    skipprev = 0;
#line 632
    getprevious = skipprev;
#line 632
    max_nch = getprevious;
#line 632
    tot_nch = (double )max_nch;
#line 632
    rows = tot_nch;
#line 633
    num_mod ++;
#line 635
    xmp_get_module_info(ctx, & mi);
    }
#line 637
    if (loadonly) {
#line 638
      goto skip_play;
    }
    {
#line 641
    time(& t2);
#line 642
    xmp_player_start(ctx);
    }
    {
#line 643
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 644
      read_keyboard();
      }
#line 646
      if (paused) {
        {
#line 647
        usleep((__useconds_t )100000);
        }
      } else {
        {
#line 649
        tmp___10 = xmp_player_frame(ctx);
        }
#line 649
        if (tmp___10 != 0) {
#line 650
          goto while_break___0;
        }
        {
#line 651
        xmp_play_buffer(ctx);
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 654
    xmp_player_end(ctx);
#line 655
    time(& t3);
#line 656
    tmp___11 = difftime(t3, t2);
#line 656
    t = (int )tmp___11;
#line 658
    xmp_release_module(ctx);
    }
#line 660
    if (showtime) {
      {
#line 661
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\r                       \r");
      }
    }
#line 663
    if (opt->verbosity) {
#line 663
      if (! background) {
#line 664
        if (skip) {
#line 664
          tmp___12 = "(SKIPPED)";
        } else {
#line 664
          tmp___12 = "         ";
        }
        {
#line 664
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\rElapsed time   : %dmin%02ds %s                                \n",
                t / 60, t % 60, tmp___12);
#line 668
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Channels used  : %d/%d",
                max_nch, mi.chn);
        }
#line 669
        if (max_nch) {
          {
#line 670
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)", avg %.2f (%.1f%%)\n",
                  tot_nch / rows, ((100.0 * tot_nch) / rows) / (double )mi.chn);
          }
        } else {
          {
#line 673
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
          }
        }
      }
    }
    skip_play: 
#line 678
    if (skip == -1) {
#line 679
      if (optind > first) {
#line 679
        tmp___13 = 2;
      } else {
#line 679
        tmp___13 = 1;
      }
#line 679
      optind -= tmp___13;
#line 680
      skipprev = 1;
    }
#line 683
    if (skip == -2) {
#line 684
      goto while_break;
    }
#line 686
    skip = 0;
    __Cont: /* CIL Label */ 
#line 586
    optind ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 689
  time(& t1);
  }
#line 691
  if (! loadonly) {
#line 691
    if (opt->verbosity) {
#line 691
      if (! background) {
#line 691
        if (num_mod > 1) {
          {
#line 692
          tmp___14 = difftime(t1, t0);
#line 692
          t = (int )tmp___14;
#line 693
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n\t%d modules played, total time %dh%02dmin%02ds\n",
                  num_mod, t / 3600, (t % 3600) / 60, t % 60);
          }
        }
      }
    }
  }
  {
#line 697
  xmp_close_audio(ctx);
#line 698
  xmp_free_context(ctx);
#line 699
  reset_tty();
  }
#line 701
  return (0);
}
}
#line 206 "src/include/xmp.h"
void xmp_drv_register(struct xmp_drv_info *drv ) ;
#line 34 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/main/drivers.c"
void init_drivers(void) 
{ 


  {
  {
#line 61
  xmp_drv_register(& drv_oss_seq);
#line 64
  xmp_drv_register(& drv_oss);
#line 99
  xmp_drv_register(& drv_file);
#line 100
  xmp_drv_register(& drv_wav);
  }
#line 102
  return;
}
}
#line 339 "/usr/include/stdio.h"
extern int printf(char const   * __restrict  __format  , ...) ;
#line 668
extern int puts(char const   *__s ) ;
#line 233 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1))) strchr)(char const   *__s ,
                                                                                     int __c )  __attribute__((__pure__)) ;
#line 282
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1,2))) strcspn)(char const   *__s ,
                                                                                         char const   *__reject )  __attribute__((__pure__)) ;
#line 534
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) strcasecmp)(char const   *__s1 ,
                                                                                         char const   *__s2 )  __attribute__((__pure__)) ;
#line 148 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 35 "src/include/getopt.h"
extern char *optarg ;
#line 110
extern int getopt_long(int argc , char * const  *argv , char const   *shortopts ,
                       struct option  const  *longopts , int *longind ) ;
#line 210 "src/include/xmp.h"
struct xmp_fmt_info *xmp_get_fmt_info(struct xmp_fmt_info **x ) ;
#line 211
struct xmp_drv_info *xmp_get_drv_info(struct xmp_drv_info **x ) ;
#line 213
void xmp_set_driver_parameter(struct xmp_options *o___0 , char *s ) ;
#line 230
int xmp_enable_format(char *id , int enable ) ;
#line 23 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/main/options.c"
static int o  ;
#line 23 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/main/options.c"
static int i  ;
#line 24 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/main/options.c"
static char *token  ;
#line 54 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/main/options.c"
static void exclude_formats(char *list ) 
{ 
  char *tok ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;

  {
  {
#line 58
  tok = strtok((char */* __restrict  */)list, (char const   */* __restrict  */)", ");
  }
  {
#line 59
  while (1) {
    while_continue: /* CIL Label */ ;
#line 59
    if (! tok) {
#line 59
      goto while_break;
    }
    {
#line 60
    xmp_enable_format(tok, 0);
#line 61
    tok = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)", ");
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 63
  return;
}
}
#line 69
static void list_wrap(char *s , int l , int r , int v ) ;
#line 69 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/main/options.c"
static int c  =    0;
#line 70 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/main/options.c"
static int m  =    0;
#line 66 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/main/options.c"
static void list_wrap(char *s , int l , int r , int v ) 
{ 
  int i___3 ;
  char *t ;
  char const   *tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;

  {
#line 73
  if ((unsigned long )s == (unsigned long )((void *)0)) {
#line 74
    i___3 = 0;
    {
#line 74
    while (1) {
      while_continue: /* CIL Label */ ;
#line 74
      if (! (i___3 < l)) {
#line 74
        goto while_break;
      }
      {
#line 75
      printf((char const   */* __restrict  */)" ");
#line 74
      i___3 ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 76
    c = l;
#line 77
    m = r;
#line 78
    return;
  } else
#line 79
  if (c > l) {
#line 80
    c ++;
#line 81
    if (v) {
#line 81
      tmp = ",";
    } else {
#line 81
      tmp = " ";
    }
    {
#line 81
    printf((char const   */* __restrict  */)tmp);
    }
  }
  {
#line 84
  t = strtok((char */* __restrict  */)s, (char const   */* __restrict  */)" ");
  }
  {
#line 86
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 86
    if (! t) {
#line 86
      goto while_break___0;
    }
    {
#line 87
    tmp___0 = strlen((char const   *)t);
    }
#line 87
    if (((size_t )c + tmp___0) + 1U > (size_t )m) {
      {
#line 88
      c = l;
#line 89
      printf((char const   */* __restrict  */)"\n");
#line 90
      i___3 = 0;
      }
      {
#line 90
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 90
        if (! (i___3 < l)) {
#line 90
          goto while_break___1;
        }
        {
#line 91
        printf((char const   */* __restrict  */)" ");
#line 90
        i___3 ++;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
    } else
#line 93
    if (c > l) {
      {
#line 94
      printf((char const   */* __restrict  */)" ");
      }
    }
    {
#line 96
    tmp___1 = strlen((char const   *)t);
#line 96
    c = (int )((size_t )c + (tmp___1 + 1U));
#line 97
    printf((char const   */* __restrict  */)"%s", t);
#line 98
    t = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)" ");
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 100
  return;
}
}
#line 103 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/main/options.c"
static void copyright_header(void) 
{ 
  char *__cil_tmp1 ;
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;

  {
  {
#line 105
  printf((char const   */* __restrict  */)"Extended Module Player %s\n", "3.0.0-pre");
#line 106
  printf((char const   */* __restrict  */)"Copyright (C) 1996-2009 Claudio Matsuoka and Hipolito Carraro Jr\nPortions Copyright (C) 1996-1997 Takashi Iwai, (C) 1988 Tammo Hinrichs,\n(C) 1989 Rich Gopstein and Harris Corporation, (C) 1997 Bert Jahn, (C) 1998\nSylvain Chipaux, (C) 1998,2000 Olivier Lapicque, (C) 1999 Tatsuyuki Satoh,\n(C) 2001-2006 Russell Marks, (C) 2005-2006 Michael Kohn\n\n");
  }
#line 112
  return;
}
}
#line 115 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/main/options.c"
static void usage(char *s , struct xmp_options *opt ) 
{ 
  struct xmp_fmt_info *f ;
  struct xmp_fmt_info *fmt___0 ;
  struct xmp_drv_info *d ;
  struct xmp_drv_info *drv ;
  char **hlp ;
  char buf___1[80] ;
  int i___3 ;
  char const   *tmp ;
  void *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;

  {
  {
#line 122
  copyright_header();
#line 124
  printf((char const   */* __restrict  */)"Usage: %s [options] [modules]\n", s);
#line 126
  printf((char const   */* __restrict  */)"\nSupported module formats:\n");
#line 127
  xmp_get_fmt_info(& fmt___0);
#line 128
  list_wrap((char *)((void *)0), 3, 78, 1);
#line 130
  i___3 = 0;
#line 130
  f = fmt___0;
  }
  {
#line 130
  while (1) {
    while_continue: /* CIL Label */ ;
#line 130
    if (! f) {
#line 130
      goto while_break;
    }
    {
#line 131
    snprintf((char */* __restrict  */)(buf___1), (size_t )80, (char const   */* __restrict  */)"%s (%s)",
             f->id, f->tracker);
#line 132
    list_wrap(buf___1, 3, 0, 1);
#line 130
    i___3 ++;
#line 130
    f = f->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 135
  snprintf((char */* __restrict  */)(buf___1), (size_t )80, (char const   */* __restrict  */)"[%d known formats]",
           i___3);
#line 136
  list_wrap(buf___1, 3, 0, 0);
#line 137
  printf((char const   */* __restrict  */)"\n");
#line 139
  printf((char const   */* __restrict  */)"\nAvailable drivers:\n");
#line 141
  xmp_get_drv_info(& drv);
#line 142
  list_wrap((char *)((void *)0), 3, 78, 1);
#line 143
  d = drv;
  }
  {
#line 143
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 143
    if (! d) {
#line 143
      goto while_break___0;
    }
    {
#line 144
    snprintf((char */* __restrict  */)(buf___1), (size_t )80, (char const   */* __restrict  */)"%s (%s)",
             d->id, d->description);
#line 145
    list_wrap(buf___1, 3, 0, 1);
#line 143
    d = d->next;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 148
  printf((char const   */* __restrict  */)"\n");
#line 150
  d = drv;
  }
  {
#line 150
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 150
    if (! d) {
#line 150
      goto while_break___1;
    }
#line 151
    if (d->help) {
      {
#line 152
      printf((char const   */* __restrict  */)"\n%s options:\n", d->description);
      }
    }
#line 153
    hlp = d->help;
    {
#line 153
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 153
      if (hlp) {
#line 153
        if (! *hlp) {
#line 153
          goto while_break___2;
        }
      } else {
#line 153
        goto while_break___2;
      }
      {
#line 154
      printf((char const   */* __restrict  */)"   -D%-20.20s %s\n", *(hlp + 0), *(hlp + 1));
#line 153
      hlp += 2;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
#line 150
    d = d->next;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 157
  if (opt->flags & 1) {
#line 157
    tmp = "enabled";
  } else {
#line 157
    tmp = "disabled";
  }
  {
#line 157
  printf((char const   */* __restrict  */)"\nPlayer control options:\n   -D parameter[=val]     Pass configuration parameter to the output driver\n   -d --driver name       Force output to the specified device\n   --fix-sample-loops     Use sample loop start /2 in MOD/UNIC/NP3\n   --offset-bug-emulation Emulate Protracker 2.x bug in effect 9\n   -l --loop              Enable module looping\n   -M --mute ch-list      Mute the specified channels\n   --nocmd                Disable interactive commands\n   --norc                 Don\'t read configuration files\n   -R --random            Random order playing\n   -S --solo ch-list      Set channels to solo mode\n   -s --start num         Start from the specified order\n   -T --tempo num         Initial tempo (default 6)\n   -t --time num          Maximum playing time in seconds\n   --vblank               Force vblank timing in Amiga modules (no CIA)\n\nPlayer sound options:\n   -8 --8bit              Convert 16 bit samples to 8 bit\n   --chorus num           Chorus depth (if supported)\n   -m --mono              Mono output\n   --nofilter             Disable IT filter\n   --nopan                Disable dynamic panning\n   -P --pan pan           Percentual pan amplitude (default %d%%)\n   -r --reverse           Reverse left/right stereo channels\n   --reverb num           Reverb depth (if supported)\n   --stereo               Stereo output\n\nSoftware mixer options:\n   -a --amplify {0|1|2|3} Amplification factor: 0=Normal, 1=x2, 2=x4, 3=x8\n   -b --bits {8|16}       Software mixer resolution (8 or 16 bits)\n   -c --stdout            Mix the module to stdout\n   -F --click-filter      Apply LPF filter to remove clicks\n   -f --frequency rate    Sampling rate in hertz (default %d Hz)\n   -i --interpolate       Use linear interpolation (default %s)\n   -n --nearest           Use nearest neighbor interpolation\n   -o --output-file name  Mix the module to file (\'-\' for stdout)\n   -u --unsigned          Set the mixer to use unsigned samples\n\nInformation options:\n   -h --help              Print a summary of the command line options\n   --load-only            Load module and exit\n   --probe-only           Probe audio device and exit\n   -q --quiet             Quiet mode (verbosity level = 0)\n   --show-time            Display elapsed and remaining time\n   -V --version           Print version information\n   -v --verbose           Verbose mode (incremental)\n",
         opt->mix, opt->freq, tmp);
  }
#line 211
  return;
}
}
#line 218 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/main/options.c"
static struct option lopt[41]  = 
#line 218
  {      {"8bit", 0, (int *)0, '8'}, 
        {"amplify", 1, (int *)0, 'a'}, 
        {"bits", 1, (int *)0, 'b'}, 
        {"chorus", 1, (int *)0, 256}, 
        {"crunch", 1, (int *)0, 270}, 
        {"driver", 1, (int *)0, 'd'}, 
        {"fix-sample-loops", 0, (int *)0, 269}, 
        {"frequency", 1, (int *)0, 'f'}, 
        {"click-filter", 0, (int *)0, 'F'}, 
        {"offset-bug-emulation", 0, (int *)0, 261}, 
        {"help", 0, (int *)0, 'h'}, 
        {"interpolate", 0, (int *)0, 'i'}, 
        {"load-only", 0, (int *)0, 259}, 
        {"loop", 0, (int *)0, 'l'}, 
        {"mute", 1, (int *)0, 'M'}, 
        {"mono", 0, (int *)0, 'm'}, 
        {"nocmd", 0, (int *)0, 267}, 
        {"nofilter", 0, (int *)0, 271}, 
        {"nearest", 0, (int *)0, 'n'}, 
        {"nopan", 0, (int *)0, 258}, 
        {"norc", 0, (int *)0, 260}, 
        {"output-file", 1, (int *)0, 'o'}, 
        {"pan", 1, (int *)0, 'P'}, 
        {"probe-only", 0, (int *)0, 262}, 
        {"quiet", 0, (int *)0, 'q'}, 
        {"random", 0, (int *)0, 'R'}, 
        {"reverb", 1, (int *)0, 256}, 
        {"reverse", 0, (int *)0, 'r'}, 
        {"show-time", 0, (int *)0, 273}, 
        {"solo", 1, (int *)0, 'S'}, 
        {"start", 1, (int *)0, 's'}, 
        {"stdout", 0, (int *)0, 'c'}, 
        {"stereo", 0, (int *)0, 266}, 
        {"tempo", 1, (int *)0, 'T'}, 
        {"time", 1, (int *)0, 't'}, 
        {"unsigned", 0, (int *)0, 'u'}, 
        {"vblank", 0, (int *)0, 272}, 
        {"version", 0, (int *)0, 'V'}, 
        {"verbose", 0, (int *)0, 'v'}, 
        {"exclude-formats", 1, (int *)0, 'x'}, 
        {(char const   *)((void *)0), 0, (int *)0, 0}};
#line 214 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/main/options.c"
void get_options(int argc , char **argv , struct xmp_options *opt , xmp_context ctx___0 ) 
{ 
  int optidx ;
  unsigned long tmp ;
  unsigned long tmp___0 ;
  unsigned long tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  int tmp___4 ;
  unsigned long tmp___5 ;
  unsigned long tmp___6 ;
  int a ;
  int b___1 ;
  char buf___1[40] ;
  size_t tmp___7 ;
  size_t tmp___8 ;
  char *tmp___9 ;
  unsigned long tmp___10 ;
  unsigned long tmp___11 ;
  unsigned long tmp___12 ;
  void *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;

  {
#line 216
  optidx = 0;
#line 265
  i = 0;
  {
#line 266
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 266
    o = getopt_long(argc, (char * const  *)argv, "8a:b:cD:d:Ff:hilM:mno:P:qRrS:s:T:t:uVvx:",
                    (struct option  const  *)(lopt), & optidx);
    }
#line 266
    if (! (o != -1)) {
#line 266
      goto while_break;
    }
    {
#line 268
    if (o == 56) {
#line 268
      goto case_56;
    }
#line 271
    if (o == 97) {
#line 271
      goto case_97;
    }
#line 274
    if (o == 98) {
#line 274
      goto case_98;
    }
#line 279
    if (o == 256) {
#line 279
      goto case_256;
    }
#line 282
    if (o == 270) {
#line 282
      goto case_270;
    }
#line 285
    if (o == 99) {
#line 285
      goto case_99;
    }
#line 288
    if (o == 68) {
#line 288
      goto case_68;
    }
#line 291
    if (o == 100) {
#line 291
      goto case_100;
    }
#line 294
    if (o == 269) {
#line 294
      goto case_269;
    }
#line 297
    if (o == 261) {
#line 297
      goto case_261;
    }
#line 300
    if (o == 70) {
#line 300
      goto case_70;
    }
#line 304
    if (o == 102) {
#line 304
      goto case_102;
    }
#line 307
    if (o == 105) {
#line 307
      goto case_105;
    }
#line 310
    if (o == 108) {
#line 310
      goto case_108;
    }
#line 313
    if (o == 259) {
#line 313
      goto case_259;
    }
#line 316
    if (o == 109) {
#line 316
      goto case_109;
    }
#line 319
    if (o == 267) {
#line 319
      goto case_267;
    }
#line 322
    if (o == 271) {
#line 322
      goto case_271;
    }
#line 325
    if (o == 110) {
#line 325
      goto case_110;
    }
#line 328
    if (o == 258) {
#line 328
      goto case_258;
    }
#line 331
    if (o == 260) {
#line 331
      goto case_260;
    }
#line 333
    if (o == 111) {
#line 333
      goto case_111;
    }
#line 340
    if (o == 80) {
#line 340
      goto case_80;
    }
#line 347
    if (o == 262) {
#line 347
      goto case_262;
    }
#line 351
    if (o == 113) {
#line 351
      goto case_113;
    }
#line 359
    if (o == 257) {
#line 359
      goto case_257;
    }
#line 362
    if (o == 82) {
#line 362
      goto case_82;
    }
#line 365
    if (o == 114) {
#line 365
      goto case_114;
    }
#line 369
    if (o == 83) {
#line 369
      goto case_83;
    }
#line 369
    if (o == 77) {
#line 369
      goto case_83;
    }
#line 392
    if (o == 115) {
#line 392
      goto case_115;
    }
#line 395
    if (o == 273) {
#line 395
      goto case_273;
    }
#line 398
    if (o == 266) {
#line 398
      goto case_266;
    }
#line 401
    if (o == 84) {
#line 401
      goto case_84;
    }
#line 404
    if (o == 116) {
#line 404
      goto case_116;
    }
#line 407
    if (o == 117) {
#line 407
      goto case_117;
    }
#line 410
    if (o == 272) {
#line 410
      goto case_272;
    }
#line 413
    if (o == 86) {
#line 413
      goto case_86;
    }
#line 416
    if (o == 118) {
#line 416
      goto case_118;
    }
#line 419
    if (o == 120) {
#line 419
      goto case_120;
    }
#line 422
    if (o == 104) {
#line 422
      goto case_104;
    }
#line 424
    goto switch_default;
    case_56: /* CIL Label */ 
#line 269
    opt->flags |= 1 << 2;
#line 270
    goto switch_break;
    case_97: /* CIL Label */ 
    {
#line 272
    opt->amplify = atoi((char const   *)optarg);
    }
#line 273
    goto switch_break;
    case_98: /* CIL Label */ 
    {
#line 275
    opt->resol = atoi((char const   *)optarg);
    }
#line 276
    if (opt->resol != 8) {
#line 276
      if (opt->resol != 16) {
#line 277
        opt->resol = 16;
      }
    }
#line 278
    goto switch_break;
    case_256: /* CIL Label */ 
    {
#line 280
    tmp = strtoul((char const   */* __restrict  */)optarg, (char **/* __restrict  */)((void *)0),
                  0);
#line 280
    opt->chorus = (int )tmp;
    }
#line 281
    goto switch_break;
    case_270: /* CIL Label */ 
    {
#line 283
    tmp___0 = strtoul((char const   */* __restrict  */)optarg, (char **/* __restrict  */)((void *)0),
                      0);
#line 283
    opt->crunch = (int )tmp___0;
    }
#line 284
    goto switch_break;
    case_99: /* CIL Label */ 
#line 286
    opt->outfile = (char *)"-";
#line 287
    goto switch_break;
    case_68: /* CIL Label */ 
    {
#line 289
    xmp_set_driver_parameter(opt, optarg);
    }
#line 290
    goto switch_break;
    case_100: /* CIL Label */ 
#line 292
    opt->drv_id = optarg;
#line 293
    goto switch_break;
    case_269: /* CIL Label */ 
#line 295
    opt->flags |= 1 << 7;
#line 296
    goto switch_break;
    case_261: /* CIL Label */ 
#line 298
    opt->quirk |= 1 << 10;
#line 299
    goto switch_break;
    case_70: /* CIL Label */ 
#line 301
    opt->flags |= 1 << 8;
#line 302
    opt->cf_cutoff = 253;
#line 303
    goto switch_break;
    case_102: /* CIL Label */ 
    {
#line 305
    tmp___1 = strtoul((char const   */* __restrict  */)optarg, (char **/* __restrict  */)((void *)0),
                      0);
#line 305
    opt->freq = (int )tmp___1;
    }
#line 306
    goto switch_break;
    case_105: /* CIL Label */ 
#line 308
    opt->flags |= 1;
#line 309
    goto switch_break;
    case_108: /* CIL Label */ 
#line 311
    opt->flags |= 1 << 3;
#line 312
    goto switch_break;
    case_259: /* CIL Label */ 
#line 314
    loadonly = 1;
#line 315
    goto switch_break;
    case_109: /* CIL Label */ 
#line 317
    opt->outfmt |= 1 << 2;
#line 318
    goto switch_break;
    case_267: /* CIL Label */ 
#line 320
    nocmd = 1;
#line 321
    goto switch_break;
    case_271: /* CIL Label */ 
#line 323
    opt->flags &= ~ (1 << 8);
#line 324
    goto switch_break;
    case_110: /* CIL Label */ 
#line 326
    opt->flags &= -2;
#line 327
    goto switch_break;
    case_258: /* CIL Label */ 
#line 329
    opt->flags &= ~ (1 << 6);
#line 330
    goto switch_break;
    case_260: /* CIL Label */ 
#line 332
    goto switch_break;
    case_111: /* CIL Label */ 
    {
#line 334
    opt->outfile = optarg;
#line 335
    tmp___2 = strlen((char const   *)optarg);
    }
#line 335
    if (tmp___2 >= 4U) {
      {
#line 335
      tmp___3 = strlen((char const   *)optarg);
#line 335
      tmp___4 = strcasecmp((char const   *)((optarg + tmp___3) - 4), ".wav");
      }
#line 335
      if (! tmp___4) {
#line 337
        opt->drv_id = (char *)"wav";
      }
    }
#line 339
    goto switch_break;
    case_80: /* CIL Label */ 
    {
#line 341
    tmp___5 = strtoul((char const   */* __restrict  */)optarg, (char **/* __restrict  */)((void *)0),
                      0);
#line 341
    opt->mix = (int )tmp___5;
    }
#line 342
    if (opt->mix < 0) {
#line 343
      opt->mix = 0;
    }
#line 344
    if (opt->mix > 100) {
#line 345
      opt->mix = 100;
    }
#line 346
    goto switch_break;
    case_262: /* CIL Label */ 
#line 348
    probeonly = 1;
#line 349
    opt->verbosity = 0;
#line 350
    goto switch_break;
    case_113: /* CIL Label */ 
#line 352
    opt->verbosity = 0;
#line 353
    goto switch_break;
    case_257: /* CIL Label */ 
    {
#line 360
    tmp___6 = strtoul((char const   */* __restrict  */)optarg, (char **/* __restrict  */)((void *)0),
                      0);
#line 360
    opt->reverb = (int )tmp___6;
    }
#line 361
    goto switch_break;
    case_82: /* CIL Label */ 
#line 363
    randomize = 1;
#line 364
    goto switch_break;
    case_114: /* CIL Label */ 
#line 366
    opt->flags |= 1 << 1;
#line 367
    goto switch_break;
    case_83: /* CIL Label */ 
    case_77: /* CIL Label */ 
#line 370
    if (o == 83) {
      {
#line 371
      xmp_channel_mute(ctx___0, 0, 64, 1);
      }
    }
    {
#line 372
    token = strtok((char */* __restrict  */)optarg, (char const   */* __restrict  */)",");
    }
    {
#line 373
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 373
      if (! token) {
#line 373
        goto while_break___0;
      }
      {
#line 376
      tmp___9 = strchr((char const   *)token, '-');
      }
#line 376
      if (tmp___9) {
        {
#line 377
        tmp___7 = strcspn((char const   *)token, "-");
#line 377
        b___1 = (int )tmp___7;
#line 378
        strncpy((char */* __restrict  */)(buf___1), (char const   */* __restrict  */)token,
                (size_t )b___1);
#line 379
        a = atoi((char const   *)(buf___1));
#line 380
        tmp___8 = strlen((char const   *)token);
#line 380
        strncpy((char */* __restrict  */)(buf___1), (char const   */* __restrict  */)((token + b___1) + 1),
                (tmp___8 - (size_t )b___1) - 1U);
#line 382
        b___1 = atoi((char const   *)(buf___1));
        }
      } else {
        {
#line 384
        b___1 = atoi((char const   *)token);
#line 384
        a = b___1;
        }
      }
      {
#line 385
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 385
        if (! (b___1 >= a)) {
#line 385
          goto while_break___1;
        }
#line 386
        if (b___1 < 64) {
          {
#line 387
          xmp_channel_mute(ctx___0, b___1, 1, o == 77);
          }
        }
#line 385
        b___1 --;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 389
      token = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)",");
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 391
    goto switch_break;
    case_115: /* CIL Label */ 
    {
#line 393
    tmp___10 = strtoul((char const   */* __restrict  */)optarg, (char **/* __restrict  */)((void *)0),
                       0);
#line 393
    opt->start = (int )tmp___10;
    }
#line 394
    goto switch_break;
    case_273: /* CIL Label */ 
#line 396
    showtime = 1;
#line 397
    goto switch_break;
    case_266: /* CIL Label */ 
#line 399
    opt->outfmt &= ~ (1 << 2);
#line 400
    goto switch_break;
    case_84: /* CIL Label */ 
    {
#line 402
    tmp___11 = strtoul((char const   */* __restrict  */)optarg, (char **/* __restrict  */)((void *)0),
                       0);
#line 402
    opt->tempo = (int )tmp___11;
    }
#line 403
    goto switch_break;
    case_116: /* CIL Label */ 
    {
#line 405
    tmp___12 = strtoul((char const   */* __restrict  */)optarg, (char **/* __restrict  */)((void *)0),
                       0);
#line 405
    opt->time = (int )tmp___12;
    }
#line 406
    goto switch_break;
    case_117: /* CIL Label */ 
#line 408
    opt->outfmt |= 1 << 1;
#line 409
    goto switch_break;
    case_272: /* CIL Label */ 
#line 411
    opt->flags |= 1 << 4;
#line 412
    goto switch_break;
    case_86: /* CIL Label */ 
    {
#line 414
    puts("Extended Module Player 3.0.0-pre");
#line 415
    exit(0);
    }
    case_118: /* CIL Label */ 
#line 417
    (opt->verbosity) ++;
#line 418
    goto switch_break;
    case_120: /* CIL Label */ 
    {
#line 420
    exclude_formats(optarg);
    }
#line 421
    goto switch_break;
    case_104: /* CIL Label */ 
    {
#line 423
    usage(*(argv + 0), opt);
    }
    switch_default: /* CIL Label */ 
    {
#line 425
    exit(-1);
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 430
  if (opt->freq < 1000) {
#line 431
    opt->freq = 1000;
  }
#line 432
  if (opt->freq > 48000) {
#line 433
    opt->freq = 48000;
  }
#line 434
  return;
}
}
#line 64 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1))) memset)(void *__s ,
                                                                                     int __c ,
                                                                                     size_t __n ) ;
#line 71 "/usr/include/assert.h"
extern  __attribute__((__nothrow__, __noreturn__)) void __assert_fail(char const   *__assertion ,
                                                                      char const   *__file ,
                                                                      unsigned int __line ,
                                                                      char const   *__function ) ;
#line 282 "src/include/common.h"
int ulaw_encode(int c___0 ) ;
#line 92 "src/include/driver.h"
void xmp_drv_resetvoice(struct xmp_context *ctx___0 , int voc , int mute ) ;
#line 68 "src/include/mixer.h"
int xmp_smix_softmixer(struct xmp_context *ctx___0 ) ;
#line 10 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/player/synth.h"
void synth_setpatch(int c___0 , uint8 *data ) ;
#line 11
void synth_setnote(int c___0 , int note , int bend ) ;
#line 12
void synth_setvol(int c___0 , int vol ) ;
#line 4 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/player/smix.h"
void smix_resetvar(struct xmp_context *ctx___0 ) ;
#line 5
void smix_setpatch(struct xmp_context *ctx___0 , int voc , int smp ) ;
#line 6
void smix_voicepos(struct xmp_context *ctx___0 , int voc , int pos___0 , int itp ) ;
#line 7
void smix_setnote(struct xmp_context *ctx___0 , int voc , int note ) ;
#line 8
void smix_setbend(struct xmp_context *ctx___0 , int voc , int bend ) ;
#line 20 "src/include/period.h"
int note_to_period_mix(int n___0 , int b___1 ) ;
#line 10 "src/include/convert.h"
void xmp_cvt_sig2uns(int l , int r , char *p ) ;
#line 44 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/player/mixer.c"
void smix_mn8norm(struct voice_info *vi , int *tmp_bk , int count , int vl , int vr ,
                  int itpt_inc ) ;
#line 45
void smix_mn8itpt(struct voice_info *vi , int *tmp_bk , int count , int vl , int vr ,
                  int itpt_inc ) ;
#line 46
void smix_mn16norm(struct voice_info *vi , int *tmp_bk , int count , int vl , int vr ,
                   int itpt_inc ) ;
#line 47
void smix_mn16itpt(struct voice_info *vi , int *tmp_bk , int count , int vl , int vr ,
                   int itpt_inc ) ;
#line 48
void smix_st8norm(struct voice_info *vi , int *tmp_bk , int count , int vl , int vr ,
                  int itpt_inc ) ;
#line 49
void smix_st8itpt(struct voice_info *vi , int *tmp_bk , int count , int vl , int vr ,
                  int itpt_inc ) ;
#line 50
void smix_st16norm(struct voice_info *vi , int *tmp_bk , int count , int vl , int vr ,
                   int itpt_inc ) ;
#line 51
void smix_st16itpt(struct voice_info *vi , int *tmp_bk , int count , int vl , int vr ,
                   int itpt_inc ) ;
#line 53
void smix_mn8itpt_flt(struct voice_info *vi , int *tmp_bk , int count , int vl , int vr ,
                      int itpt_inc ) ;
#line 54
void smix_mn16itpt_flt(struct voice_info *vi , int *tmp_bk , int count , int vl ,
                       int vr , int itpt_inc ) ;
#line 55
void smix_st8itpt_flt(struct voice_info *vi , int *tmp_bk , int count , int vl , int vr ,
                      int itpt_inc ) ;
#line 56
void smix_st16itpt_flt(struct voice_info *vi , int *tmp_bk , int count , int vl ,
                       int vr , int itpt_inc ) ;
#line 58
void smix_synth(struct voice_info *vi , int *tmp_bk , int count , int vl , int vr ,
                int itpt_inc ) ;
#line 60
static void out_su8norm(char *dest , int *src , int num , int amp , int flags ) ;
#line 61
static void out_su16norm(int16 *dest , int *src , int num , int amp , int flags ) ;
#line 62
static void out_u8ulaw(char *dest , int *src , int num , int amp , int flags ) ;
#line 71 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/player/mixer.c"
static void (*mix_fn[16])()  = 
#line 71
  {      (void (*)())(& smix_mn8norm),      (void (*)())(& smix_mn8itpt),      (void (*)())(& smix_mn16norm),      (void (*)())(& smix_mn16itpt), 
        (void (*)())(& smix_st8norm),      (void (*)())(& smix_st8itpt),      (void (*)())(& smix_st16norm),      (void (*)())(& smix_st16itpt), 
        (void (*)())(& smix_mn8norm),      (void (*)())(& smix_mn8itpt_flt),      (void (*)())(& smix_mn16norm),      (void (*)())(& smix_mn16itpt_flt), 
        (void (*)())(& smix_st8norm),      (void (*)())(& smix_st8itpt_flt),      (void (*)())(& smix_st16norm),      (void (*)())(& smix_st16itpt_flt)};
#line 97 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/player/mixer.c"
static void (*out_fn[3])()  = {      (void (*)())(& out_u8ulaw),      (void (*)())(& out_su8norm),      (void (*)())(& out_su16norm)};
#line 104 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/player/mixer.c"
static void out_su8norm(char *dest , int *src , int num , int amp , int flags ) 
{ 
  int smp ;
  int lhi ;
  int llo ;
  int offs ;
  int shift ;
  int tmp ;
  int tmp___0 ;

  {
#line 107
  shift = 20 - amp;
#line 109
  if (flags & (1 << 1)) {
#line 109
    offs = 128;
  } else {
#line 109
    offs = 0;
  }
#line 111
  lhi = 127 + offs;
#line 112
  llo = -127 + offs;
  {
#line 114
  while (1) {
    while_continue: /* CIL Label */ ;
#line 114
    tmp___0 = num;
#line 114
    num --;
#line 114
    if (! tmp___0) {
#line 114
      goto while_break;
    }
#line 115
    smp = *src >> shift;
#line 116
    if (smp > 127) {
#line 116
      *dest = (char )lhi;
    } else {
#line 116
      if (smp < -127) {
#line 116
        tmp = llo;
      } else {
#line 116
        tmp = smp + offs;
      }
#line 116
      *dest = (char )tmp;
    }
#line 114
    src ++;
#line 114
    dest ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 118
  return;
}
}
#line 122 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/player/mixer.c"
static void out_su16norm(int16 *dest , int *src , int num , int amp , int flags ) 
{ 
  int smp ;
  int lhi ;
  int llo ;
  int offs ;
  int shift ;
  int tmp ;
  int tmp___0 ;

  {
#line 125
  shift = 12 - amp;
#line 127
  if (flags & (1 << 1)) {
#line 127
    offs = 32768;
  } else {
#line 127
    offs = 0;
  }
#line 129
  lhi = 32767 + offs;
#line 130
  llo = -32768 + offs;
  {
#line 132
  while (1) {
    while_continue: /* CIL Label */ ;
#line 132
    tmp___0 = num;
#line 132
    num --;
#line 132
    if (! tmp___0) {
#line 132
      goto while_break;
    }
#line 133
    smp = *src >> shift;
#line 134
    if (smp > 32767) {
#line 134
      *dest = (int16 )lhi;
    } else {
#line 134
      if (smp < -32768) {
#line 134
        tmp = llo;
      } else {
#line 134
        tmp = smp + offs;
      }
#line 134
      *dest = (int16 )tmp;
    }
#line 132
    src ++;
#line 132
    dest ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 136
  return;
}
}
#line 140 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/player/mixer.c"
static void out_u8ulaw(char *dest , int *src , int num , int amp , int flags ) 
{ 
  int smp ;
  int shift ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 143
  shift = 16 - amp;
  {
#line 145
  while (1) {
    while_continue: /* CIL Label */ ;
#line 145
    tmp___3 = num;
#line 145
    num --;
#line 145
    if (! tmp___3) {
#line 145
      goto while_break;
    }
#line 146
    smp = *src >> shift;
#line 147
    if (smp > 4095) {
      {
#line 147
      tmp = ulaw_encode(4095);
#line 147
      *dest = (char )tmp;
      }
    } else {
#line 147
      if (smp < -4096) {
        {
#line 147
        tmp___0 = ulaw_encode(-4096);
#line 147
        tmp___2 = tmp___0;
        }
      } else {
        {
#line 147
        tmp___1 = ulaw_encode(smp);
#line 147
        tmp___2 = tmp___1;
        }
      }
#line 147
      *dest = (char )tmp___2;
    }
#line 145
    src ++;
#line 145
    dest ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 150
  return;
}
}
#line 154 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/player/mixer.c"
void smix_resetvar(struct xmp_context *ctx___0 ) 
{ 
  struct xmp_player_context *p ;
  struct xmp_mod_context *m___0 ;
  struct xmp_smixer_context *s ;
  struct xmp_options *o___0 ;
  int tmp ;

  {
#line 156
  p = & ctx___0->p;
#line 157
  m___0 = & p->m;
#line 158
  s = & ctx___0->s;
#line 159
  o___0 = & ctx___0->o;
#line 161
  if (m___0->quirk & 1) {
#line 161
    s->ticksize = (int )(((((double )o___0->freq * m___0->rrate) * (double )33) / (double )p->xmp_bpm) / (double )12500);
  } else {
#line 161
    s->ticksize = (int )((((double )o___0->freq * m___0->rrate) / (double )p->xmp_bpm) / (double )100);
  }
#line 165
  if (s->buf32b) {
    {
#line 166
    tmp = 0;
#line 166
    s->dtleft = tmp;
#line 166
    s->dtright = tmp;
#line 167
    memset((void *)s->buf32b, 0, (size_t )((unsigned long )(s->ticksize * s->mode) * sizeof(int )));
    }
  }
#line 169
  return;
}
}
#line 173 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/player/mixer.c"
static void smix_rampdown(struct xmp_context *ctx___0 , int voc , int32 *buf___1 ,
                          int cnt ) 
{ 
  struct xmp_driver_context *d ;
  struct xmp_smixer_context *s ;
  int smp_l ;
  int smp_r ;
  int dec_l ;
  int dec_r ;
  int tmp ;
  int32 *tmp___0 ;
  int tmp___1 ;
  int32 *tmp___2 ;
  int tmp___3 ;
  int32 *tmp___4 ;
  int tmp___5 ;
  int32 *tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;

  {
#line 175
  d = & ctx___0->d;
#line 176
  s = & ctx___0->s;
#line 180
  if (voc < 0) {
#line 182
    smp_r = s->dtright;
#line 183
    smp_l = s->dtleft;
  } else {
#line 185
    smp_r = (d->voice_array + voc)->sright;
#line 186
    smp_l = (d->voice_array + voc)->sleft;
#line 187
    tmp = 0;
#line 187
    (d->voice_array + voc)->sleft = tmp;
#line 187
    (d->voice_array + voc)->sright = tmp;
  }
#line 190
  if (! smp_l) {
#line 190
    if (! smp_r) {
#line 191
      return;
    }
  }
#line 193
  if (! buf___1) {
#line 194
    buf___1 = s->buf32b;
#line 195
    cnt = 16;
  }
#line 197
  if (! cnt) {
#line 198
    return;
  }
#line 200
  dec_r = smp_r / cnt;
#line 201
  dec_l = smp_l / cnt;
  {
#line 203
  while (1) {
    while_continue: /* CIL Label */ ;
#line 203
    if (smp_r) {
#line 203
      goto _L;
    } else
#line 203
    if (smp_l) {
      _L: /* CIL Label */ 
#line 203
      tmp___8 = cnt;
#line 203
      cnt --;
#line 203
      if (! tmp___8) {
#line 203
        goto while_break;
      }
    } else {
#line 203
      goto while_break;
    }
#line 204
    if (dec_r > 0) {
#line 205
      tmp___0 = buf___1;
#line 205
      buf___1 ++;
#line 205
      if (smp_r > dec_r) {
#line 205
        smp_r -= dec_r;
#line 205
        tmp___1 = smp_r;
      } else {
#line 205
        smp_r = 0;
#line 205
        tmp___1 = smp_r;
      }
#line 205
      *tmp___0 += tmp___1;
    } else {
#line 207
      tmp___2 = buf___1;
#line 207
      buf___1 ++;
#line 207
      if (smp_r < dec_r) {
#line 207
        smp_r -= dec_r;
#line 207
        tmp___3 = smp_r;
      } else {
#line 207
        smp_r = 0;
#line 207
        tmp___3 = smp_r;
      }
#line 207
      *tmp___2 += tmp___3;
    }
#line 209
    if (dec_l > 0) {
#line 210
      tmp___4 = buf___1;
#line 210
      buf___1 ++;
#line 210
      if (smp_l > dec_l) {
#line 210
        smp_l -= dec_l;
#line 210
        tmp___5 = smp_l;
      } else {
#line 210
        smp_l = 0;
#line 210
        tmp___5 = smp_l;
      }
#line 210
      *tmp___4 += tmp___5;
    } else {
#line 212
      tmp___6 = buf___1;
#line 212
      buf___1 ++;
#line 212
      if (smp_l < dec_l) {
#line 212
        smp_l -= dec_l;
#line 212
        tmp___7 = smp_l;
      } else {
#line 212
        smp_l = 0;
#line 212
        tmp___7 = smp_l;
      }
#line 212
      *tmp___6 += tmp___7;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 214
  return;
}
}
#line 218 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/player/mixer.c"
static void smix_anticlick(struct xmp_context *ctx___0 , int voc , int vol , int pan ,
                           int *buf___1 , int cnt ) 
{ 
  int oldvol ;
  int newvol ;
  int pan0 ;
  struct xmp_driver_context *d ;
  struct xmp_smixer_context *s ;
  struct voice_info *vi ;
  int tmp ;

  {
#line 221
  d = & ctx___0->d;
#line 222
  s = & ctx___0->s;
#line 223
  vi = d->voice_array + voc;
#line 225
  if (d->ext) {
#line 226
    return;
  }
#line 236
  pan0 = vi->pan;
#line 237
  if (pan0 < -127) {
#line 238
    pan0 = -127;
  }
#line 240
  if (vi->vol) {
#line 241
    oldvol = vi->vol * (128 - pan0);
#line 242
    newvol = vol * (128 - pan);
#line 243
    vi->sright -= (vi->sright / oldvol) * newvol;
#line 245
    oldvol = vi->vol * (128 + pan0);
#line 246
    newvol = vol * (128 + pan);
#line 247
    vi->sleft -= (vi->sleft / oldvol) * newvol;
  }
#line 250
  if (! buf___1) {
#line 251
    s->dtright += vi->sright;
#line 252
    s->dtleft += vi->sleft;
#line 253
    tmp = 0;
#line 253
    vi->sleft = tmp;
#line 253
    vi->sright = tmp;
  } else {
    {
#line 255
    smix_rampdown(ctx___0, voc, buf___1, cnt);
    }
  }
#line 257
  return;
}
}
#line 263 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/player/mixer.c"
int xmp_smix_softmixer(struct xmp_context *ctx___0 ) 
{ 
  struct xmp_driver_context *d ;
  struct xmp_smixer_context *s ;
  struct voice_info *vi ;
  struct patch_info *pi ;
  int smp_cnt ;
  int tic_cnt ;
  int lps ;
  int lpe ;
  int vol_l ;
  int vol_r ;
  int itp_inc ;
  int voc ;
  int prv_l ;
  int prv_r ;
  int synth ;
  int *buf_pos ;
  int idx___0 ;
  int mix_size ;
  int mixer ;
  int tmp ;

  {
#line 265
  d = & ctx___0->d;
#line 266
  s = & ctx___0->s;
#line 272
  synth = 1;
#line 275
  if (! d->ext) {
    {
#line 276
    smix_rampdown(ctx___0, -1, (int32 *)((void *)0), 0);
    }
  }
#line 278
  voc = d->maxvoc;
  {
#line 278
  while (1) {
    while_continue: /* CIL Label */ ;
#line 278
    tmp = voc;
#line 278
    voc --;
#line 278
    if (! tmp) {
#line 278
      goto while_break;
    }
#line 279
    vi = d->voice_array + voc;
#line 281
    if (vi->chn < 0) {
#line 282
      goto __Cont;
    }
#line 284
    if (vi->period < 1) {
      {
#line 285
      xmp_drv_resetvoice(ctx___0, voc, 1);
      }
#line 286
      goto __Cont;
    }
#line 289
    buf_pos = s->buf32b;
#line 290
    vol_r = vi->vol * (128 - vi->pan);
#line 291
    vol_l = vi->vol * (128 + vi->pan);
#line 293
    if (vi->fidx & 64) {
#line 294
      if (synth) {
        {
#line 295
        smix_synth(vi, buf_pos, s->ticksize, vol_l, vol_r, vi->fidx & 4);
#line 297
        synth = 0;
        }
      }
#line 299
      goto __Cont;
    }
#line 302
    itp_inc = (int )(((int64 )vi->pbase << 16) / (int64 )vi->period);
#line 304
    if (itp_inc == 0) {
#line 305
      goto __Cont;
    }
#line 307
    pi = *(d->patch_array + vi->smp);
#line 310
    if (vi->fidx & 16) {
#line 311
      itp_inc = - itp_inc;
    }
#line 314
    if (vi->fidx & 2) {
#line 315
      lps = pi->loop_start >> 1;
#line 316
      lpe = pi->loop_end >> 1;
    } else {
#line 318
      lps = pi->loop_start;
#line 319
      lpe = pi->loop_end;
    }
#line 323
    if (pi->mode & 128U) {
#line 323
      if (pi->mode & 64U) {
#line 324
        lpe = pi->len - 2;
#line 325
        if (vi->fidx & 2) {
#line 326
          lpe >>= 1;
        }
      }
    }
#line 329
    tic_cnt = s->ticksize;
    {
#line 329
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 329
      if (! tic_cnt) {
#line 329
        goto while_break___0;
      }
#line 332
      smp_cnt = (int )(1LL + (((int64 )(vi->end - vi->pos) << 16) - (int64 )vi->itpt) / (int64 )itp_inc);
#line 335
      if (itp_inc > 0) {
#line 336
        if (vi->end < vi->pos) {
#line 337
          smp_cnt = 0;
        }
      } else
#line 339
      if (vi->end > vi->pos) {
#line 340
        smp_cnt = 0;
      }
#line 344
      if (smp_cnt < 0) {
#line 345
        smp_cnt = 0;
      }
#line 348
      if (smp_cnt > tic_cnt) {
#line 349
        smp_cnt = tic_cnt;
      }
#line 351
      if (vi->vol) {
#line 353
        mix_size = s->mode * smp_cnt;
#line 354
        mixer = vi->fidx & 15;
#line 360
        idx___0 = mix_size;
#line 361
        if (idx___0 < 2) {
#line 362
          idx___0 = 2;
        }
#line 363
        prv_r = *(buf_pos + (idx___0 - 2));
#line 364
        prv_l = *(buf_pos + (idx___0 - 1));
#line 367
        if (vi->cutoff >= 254) {
#line 368
          mixer &= -9;
        }
        {
#line 371
        (*(mix_fn[mixer]))(vi, buf_pos, smp_cnt, vol_l, vol_r, itp_inc);
#line 372
        buf_pos += s->mode * smp_cnt;
#line 375
        idx___0 = 0;
        }
#line 376
        if (mix_size < 2) {
#line 377
          idx___0 = 2;
        }
#line 378
        vi->sright = *(buf_pos + (idx___0 - 2)) - prv_r;
#line 379
        vi->sleft = *(buf_pos + (idx___0 - 1)) - prv_l;
      }
#line 382
      vi->itpt += itp_inc * smp_cnt;
#line 383
      vi->pos += vi->itpt >> 16;
#line 384
      vi->itpt &= 65535;
#line 387
      tic_cnt -= smp_cnt;
#line 387
      if (! tic_cnt) {
#line 388
        goto __Cont___0;
      }
#line 390
      vi->fidx ^= vi->fxor;
#line 393
      if (vi->fidx == 0) {
        {
#line 394
        smix_anticlick(ctx___0, voc, 0, 0, buf_pos, tic_cnt);
#line 395
        xmp_drv_resetvoice(ctx___0, voc, 0);
#line 396
        tic_cnt = 0;
        }
#line 397
        goto __Cont___0;
      } else
#line 393
      if (lps >= lpe) {
        {
#line 394
        smix_anticlick(ctx___0, voc, 0, 0, buf_pos, tic_cnt);
#line 395
        xmp_drv_resetvoice(ctx___0, voc, 0);
#line 396
        tic_cnt = 0;
        }
#line 397
        goto __Cont___0;
      }
#line 400
      if (~ vi->fidx & 16) {
#line 400
        if (vi->fxor == 0) {
#line 401
          vi->pos -= lpe - lps;
#line 402
          if (pi->mode & 128U) {
#line 403
            lpe = pi->loop_end;
#line 403
            vi->end = lpe;
#line 404
            pi->mode &= 4294967231U;
          }
        } else {
#line 400
          goto _L;
        }
      } else {
        _L: /* CIL Label */ 
#line 407
        itp_inc = - itp_inc;
#line 408
        vi->itpt += itp_inc;
#line 410
        vi->pos += (vi->itpt >> 16) + 1;
#line 411
        vi->itpt &= 65535;
#line 412
        if (itp_inc > 0) {
#line 412
          vi->end = lpe;
        } else {
#line 412
          vi->end = lps;
        }
      }
      __Cont___0: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 417
  return ((s->ticksize * s->mode) * s->resol);
}
}
#line 421 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/player/mixer.c"
void smix_voicepos(struct xmp_context *ctx___0 , int voc , int pos___0 , int itp ) 
{ 
  struct xmp_driver_context *d ;
  struct voice_info *vi ;
  struct patch_info *pi ;
  int lpe ;
  int res ;
  int mode___1 ;
  int tmp ;

  {
#line 423
  d = & ctx___0->d;
#line 424
  vi = d->voice_array + voc;
#line 425
  pi = *(d->patch_array + vi->smp);
#line 428
  if (pi->len == -1) {
#line 429
    return;
  }
#line 431
  res = ! (! (pi->mode & 1U));
#line 432
  if (pi->mode & 4U) {
#line 432
    if (! (pi->mode & 8U)) {
#line 432
      tmp = 1;
    } else {
#line 432
      tmp = 0;
    }
  } else {
#line 432
    tmp = 0;
  }
#line 432
  mode___1 = tmp;
#line 433
  mode___1 = ((mode___1 << res) + res) + 1;
#line 435
  lpe = pi->len - mode___1;
#line 436
  if (pi->mode & 4U) {
#line 436
    if (~ pi->mode & 64U) {
#line 437
      if (lpe > pi->loop_end) {
#line 437
        lpe = pi->loop_end;
      } else {
#line 437
        lpe = lpe;
      }
    }
  }
#line 439
  lpe >>= res;
#line 441
  if (pos___0 >= lpe) {
#line 442
    pos___0 = 0;
  }
#line 444
  vi->pos = pos___0;
#line 445
  vi->itpt = itp;
#line 446
  vi->end = lpe;
#line 448
  if (vi->fidx & 16) {
#line 449
    vi->fidx ^= vi->fxor;
  }
#line 450
  return;
}
}
#line 453 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/player/mixer.c"
void smix_setpatch(struct xmp_context *ctx___0 , int voc , int smp ) 
{ 
  struct xmp_player_context *p ;
  struct xmp_driver_context *d ;
  struct xmp_mod_context *m___0 ;
  struct xmp_options *o___0 ;
  struct voice_info *vi ;
  struct patch_info *pi ;

  {
#line 455
  p = & ctx___0->p;
#line 456
  d = & ctx___0->d;
#line 457
  m___0 = & p->m;
#line 458
  o___0 = & ctx___0->o;
#line 459
  vi = d->voice_array + voc;
#line 460
  pi = *(d->patch_array + smp);
#line 462
  vi->smp = smp;
#line 463
  vi->vol = 0;
#line 464
  vi->freq = (int )((130812LL * (int64 )pi->base_freq) / (int64 )o___0->freq);
#line 466
  if (pi->len == -1) {
#line 467
    vi->fidx = 64;
#line 468
    if (o___0->outfmt & (1 << 2)) {
#line 469
      vi->pan = 0;
    } else {
#line 471
      vi->pan = pi->panning;
#line 472
      vi->fidx |= 4;
    }
    {
#line 475
    synth_setpatch(voc, (uint8 *)(pi->data));
    }
#line 477
    return;
  }
  {
#line 480
  xmp_smix_setvol(ctx___0, voc, 0);
  }
#line 482
  if (d->ext) {
#line 482
    vi->sptr = (void *)0;
  } else {
#line 482
    vi->sptr = (void *)(pi->data);
  }
#line 483
  if (m___0->flags & 1) {
#line 483
    vi->fidx = 33;
  } else {
#line 483
    vi->fidx = 32;
  }
#line 485
  if (o___0->outfmt & (1 << 2)) {
#line 486
    vi->pan = 0;
  } else {
#line 488
    vi->pan = pi->panning;
#line 489
    vi->fidx |= 4;
  }
#line 492
  if (pi->mode & 1U) {
#line 493
    vi->fidx |= 2;
  }
#line 495
  if (m___0->flags & (1 << 8)) {
#line 496
    vi->fidx |= 8;
  }
#line 498
  if (pi->mode & 4U) {
#line 499
    if (pi->mode & 8U) {
#line 499
      vi->fxor = 16;
    } else {
#line 499
      vi->fxor = 0;
    }
  } else {
#line 501
    vi->fxor = vi->fidx;
  }
#line 503
  if (o___0->cf_cutoff) {
#line 504
    vi->fidx |= 8;
  }
#line 506
  if (pi->mode & 128U) {
#line 507
    pi->mode |= 64U;
  }
  {
#line 509
  smix_voicepos(ctx___0, voc, 0, 0);
  }
#line 510
  return;
}
}
#line 513 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/player/mixer.c"
void smix_setnote(struct xmp_context *ctx___0 , int voc , int note ) 
{ 
  struct xmp_driver_context *d ;
  struct voice_info *vi ;
  int tmp ;

  {
  {
#line 515
  d = & ctx___0->d;
#line 516
  vi = d->voice_array + voc;
#line 518
  tmp = note;
#line 518
  vi->note = tmp;
#line 518
  vi->period = note_to_period_mix(tmp, 0);
#line 519
  vi->pbase = (int )((unsigned int )(6864 * vi->freq) / (*(d->patch_array + vi->smp))->base_note);
#line 520
  vi->attack = 64;
  }
#line 521
  return;
}
}
#line 524 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/player/mixer.c"
void smix_setbend(struct xmp_context *ctx___0 , int voc , int bend ) 
{ 
  struct xmp_driver_context *d ;
  struct voice_info *vi ;

  {
  {
#line 526
  d = & ctx___0->d;
#line 527
  vi = d->voice_array + voc;
#line 529
  vi->period = note_to_period_mix(vi->note, bend);
  }
#line 531
  if (vi->fidx & 64) {
    {
#line 532
    synth_setnote(voc, vi->note, bend);
    }
  }
#line 533
  return;
}
}
#line 536 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/player/mixer.c"
void xmp_smix_setvol(struct xmp_context *ctx___0 , int voc , int vol ) 
{ 
  struct xmp_driver_context *d ;
  struct voice_info *vi ;

  {
  {
#line 538
  d = & ctx___0->d;
#line 539
  vi = d->voice_array + voc;
#line 541
  smix_anticlick(ctx___0, voc, vol, vi->pan, (int *)((void *)0), 0);
#line 542
  vi->vol = vol;
  }
#line 544
  if (vi->fidx & 64) {
    {
#line 545
    synth_setvol(voc, vol >> 4);
    }
  }
#line 546
  return;
}
}
#line 549 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/player/mixer.c"
void xmp_smix_seteffect(struct xmp_context *ctx___0 , int voc , int type , int val ) 
{ 
  struct xmp_driver_context *d ;
  struct voice_info *vi ;

  {
#line 551
  d = & ctx___0->d;
#line 552
  vi = d->voice_array + voc;
  {
#line 555
  if (type == 2) {
#line 555
    goto case_2;
  }
#line 558
  if (type == 3) {
#line 558
    goto case_3;
  }
#line 561
  if (type == 176) {
#line 561
    goto case_176;
  }
#line 564
  if (type == 177) {
#line 564
    goto case_177;
  }
#line 567
  if (type == 178) {
#line 567
    goto case_178;
  }
#line 554
  goto switch_break;
  case_2: /* CIL Label */ 
#line 556
  vi->cutoff = val;
#line 557
  goto switch_break;
  case_3: /* CIL Label */ 
#line 559
  vi->resonance = val;
#line 560
  goto switch_break;
  case_176: /* CIL Label */ 
#line 562
  vi->flt_B0 = val;
#line 563
  goto switch_break;
  case_177: /* CIL Label */ 
#line 565
  vi->flt_B1 = val;
#line 566
  goto switch_break;
  case_178: /* CIL Label */ 
#line 568
  vi->flt_B2 = val;
#line 569
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 571
  return;
}
}
#line 574 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/player/mixer.c"
void xmp_smix_setpan(struct xmp_context *ctx___0 , int voc , int pan ) 
{ 
  struct xmp_driver_context *d ;
  struct voice_info *vi ;

  {
#line 576
  d = & ctx___0->d;
#line 577
  vi = d->voice_array + voc;
#line 579
  vi->pan = pan;
#line 580
  return;
}
}
#line 583 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/player/mixer.c"
void xmp_smix_echoback(struct xmp_context *ctx___0 , int msg ) 
{ 
  struct xmp_player_context *p ;
  struct xmp_smixer_context *s ;
  int tmp ;

  {
  {
#line 585
  p = & ctx___0->p;
#line 586
  s = & ctx___0->s;
#line 588
  tmp = msg;
#line 588
  s->echo_msg = tmp;
#line 588
  (*(p->event_callback))((unsigned long )tmp);
  }
#line 589
  return;
}
}
#line 592 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/player/mixer.c"
int xmp_smix_getmsg(struct xmp_context *ctx___0 ) 
{ 
  struct xmp_smixer_context *s ;

  {
#line 594
  s = & ctx___0->s;
#line 595
  return (s->echo_msg);
}
}
#line 599 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/player/mixer.c"
int xmp_smix_numvoices(struct xmp_context *ctx___0 , int num ) 
{ 
  struct xmp_smixer_context *s ;
  int tmp ;

  {
#line 601
  s = & ctx___0->s;
#line 602
  if (num > s->numvoc) {
#line 602
    tmp = s->numvoc;
  } else {
#line 602
    tmp = num;
  }
#line 602
  return (tmp);
}
}
#line 608 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/player/mixer.c"
int xmp_smix_writepatch(struct xmp_context *ctx___0 , struct patch_info *patch ) 
{ 


  {
#line 610
  if (patch) {
#line 611
    if (patch->len == -1) {
#line 612
      return (0);
    }
#line 614
    if (patch->len <= 0) {
#line 615
      return (-6);
    }
#line 617
    if (patch->mode & 2U) {
      {
#line 618
      xmp_cvt_sig2uns(patch->len, (int )(patch->mode & 1U), patch->data);
      }
    }
  }
#line 622
  return (0);
}
}
#line 626 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/player/mixer.c"
int xmp_smix_on(struct xmp_context *ctx___0 ) 
{ 
  struct xmp_driver_context *d ;
  struct xmp_smixer_context *s ;
  int cnt ;
  int tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  char *tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;

  {
#line 628
  d = & ctx___0->d;
#line 629
  s = & ctx___0->s;
#line 632
  if (s->numbuf) {
#line 633
    return (0);
  }
#line 635
  if (d->numbuf < 1) {
#line 636
    d->numbuf = 1;
  }
  {
#line 637
  tmp = d->numbuf;
#line 637
  s->numbuf = tmp;
#line 637
  cnt = tmp;
#line 639
  tmp___0 = calloc((size_t )sizeof(void *), (size_t )cnt);
#line 639
  s->buffer = (char **)tmp___0;
#line 640
  tmp___1 = calloc((size_t )sizeof(int ), (size_t )(((480000UL * sizeof(int16 )) / 5UL) / 3UL));
#line 640
  s->buf32b = (int *)tmp___1;
  }
#line 641
  if (s->buffer) {
#line 641
    if (! s->buf32b) {
#line 642
      return (-8);
    }
  } else {
#line 642
    return (-8);
  }
  {
#line 644
  while (1) {
    while_continue: /* CIL Label */ ;
#line 644
    tmp___4 = cnt;
#line 644
    cnt --;
#line 644
    if (! tmp___4) {
#line 644
      goto while_break;
    }
    {
#line 645
    tmp___3 = calloc((size_t )sizeof(int16 ), (size_t )(((480000UL * sizeof(int16 )) / 5UL) / 3UL));
#line 645
    tmp___2 = (char *)tmp___3;
#line 645
    *(s->buffer + cnt) = tmp___2;
    }
#line 645
    if (! tmp___2) {
#line 646
      return (-8);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 649
  s->numvoc = 64;
#line 650
  d->ext = 0;
#line 652
  return (0);
}
}
#line 656 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/player/mixer.c"
void xmp_smix_off(struct xmp_context *ctx___0 ) 
{ 
  struct xmp_driver_context *d ;
  struct xmp_smixer_context *s ;

  {
#line 658
  d = & ctx___0->d;
#line 659
  s = & ctx___0->s;
  {
#line 661
  while (1) {
    while_continue: /* CIL Label */ ;
#line 661
    if (! s->numbuf) {
#line 661
      goto while_break;
    }
    {
#line 662
    (s->numbuf) --;
#line 662
    free((void *)*(s->buffer + s->numbuf));
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 664
  free((void *)s->buf32b);
#line 665
  free((void *)s->buffer);
#line 666
  s->buf32b = (int *)((void *)0);
#line 667
  s->buffer = (char **)((void *)0);
#line 668
  d->ext = 1;
  }
#line 669
  return;
}
}
#line 674 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/player/mixer.c"
static int outbuf  ;
#line 672 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/player/mixer.c"
void *xmp_smix_buffer(struct xmp_context *ctx___0 ) 
{ 
  int fmt___0 ;
  int size___0 ;
  struct xmp_smixer_context *s ;
  struct xmp_options *o___0 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
#line 676
  s = & ctx___0->s;
#line 677
  o___0 = & ctx___0->o;
#line 679
  if (! o___0->resol) {
#line 680
    fmt___0 = 0;
  } else
#line 681
  if (o___0->resol > 8) {
#line 682
    fmt___0 = 2;
  } else {
#line 684
    fmt___0 = 1;
  }
#line 690
  outbuf ++;
#line 690
  if (outbuf >= s->numbuf) {
#line 691
    outbuf = 0;
  }
#line 693
  size___0 = s->mode * s->ticksize;
#line 694
  if (! ((unsigned long )size___0 <= ((480000UL * sizeof(int16 )) / 5UL) / 3UL)) {
    {
#line 694
    __assert_fail("size <= (5 * 2 * 48000 * (sizeof (int16)) / 5 / 3)", "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/player/mixer.c",
                  694U, "xmp_smix_buffer");
    }
  }
  {
#line 696
  (*(out_fn[fmt___0]))(*(s->buffer + outbuf), s->buf32b, size___0, o___0->amplify,
                       o___0->outfmt);
#line 698
  smix_resetvar(ctx___0);
  }
#line 700
  return ((void *)*(s->buffer + outbuf));
}
}
#line 186 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/player/player.h"
void process_fx(struct xmp_context___0 *ctx___0 , int chn , uint8 note , uint8 fxt ,
                uint8 fxp , struct xmp_channel *xc , int fnum ) ;
#line 19 "src/include/period.h"
double note_to_period(int n___0 , int f , int type ) ;
#line 82 "src/include/driver.h"
extern void xmp_drv_setnna(struct xmp_context___0 * , int  , int  ) ;
#line 83
extern void xmp_drv_pastnote(struct xmp_context___0 * , int  , int  ) ;
#line 29 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/player/effects.c"
void process_fx(struct xmp_context___0 *ctx___0 , int chn , uint8 note , uint8 fxt ,
                uint8 fxp , struct xmp_channel *xc , int fnum ) 
{ 
  struct xmp_player_context *p ;
  struct xmp_mod_context *m___0 ;
  struct flow_control *f ;
  int h ;
  int l ;
  int tmp ;
  int tmp___0 ;
  double tmp___1 ;
  uint8 tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  double tmp___5 ;
  uint8 tmp___6 ;
  double tmp___7 ;
  uint8 tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;

  {
#line 31
  p = & ctx___0->p;
#line 32
  m___0 = & p->m;
#line 33
  f = & p->flow;
  {
#line 37
  if ((int )fxt == 0) {
#line 37
    goto case_0;
  }
#line 45
  if ((int )fxt == 112) {
#line 45
    goto case_112;
  }
#line 52
  if ((int )fxt == 113) {
#line 52
    goto case_113;
  }
#line 61
  if ((int )fxt == 114) {
#line 61
    goto case_114;
  }
#line 69
  if ((int )fxt == 1) {
#line 69
    goto case_1;
  }
#line 95
  if ((int )fxt == 2) {
#line 95
    goto case_2;
  }
#line 121
  if ((int )fxt == 3) {
#line 121
    goto case_3;
  }
#line 132
  if ((int )fxt == 121) {
#line 132
    goto case_121;
  }
#line 138
  if ((int )fxt == 120) {
#line 138
    goto case_120;
  }
#line 144
  if ((int )fxt == 122) {
#line 144
    goto case_122;
  }
#line 153
  if ((int )fxt == 124) {
#line 153
    goto case_124;
  }
#line 159
  if ((int )fxt == 125) {
#line 159
    goto case_125;
  }
#line 165
  if ((int )fxt == 126) {
#line 165
    goto case_126;
  }
#line 169
  if ((int )fxt == 127) {
#line 169
    goto case_127;
  }
#line 172
  if ((int )fxt == 4) {
#line 172
    goto case_4;
  }
#line 179
  if ((int )fxt == 134) {
#line 179
    goto case_134;
  }
#line 186
  if ((int )fxt == 172) {
#line 186
    goto case_172;
  }
#line 193
  if ((int )fxt == 123) {
#line 193
    goto case_123;
  }
#line 202
  if ((int )fxt == 5) {
#line 202
    goto case_5;
  }
#line 208
  if ((int )fxt == 6) {
#line 208
    goto case_6;
  }
#line 211
  if ((int )fxt == 7) {
#line 211
    goto case_7;
  }
#line 218
  if ((int )fxt == 8) {
#line 218
    goto case_8;
  }
#line 222
  if ((int )fxt == 9) {
#line 222
    goto case_9;
  }
#line 229
  if ((int )fxt == 10) {
#line 229
    goto fx_volslide;
  }
#line 278
  if ((int )fxt == 164) {
#line 278
    goto case_164;
  }
#line 283
  if ((int )fxt == 160) {
#line 283
    goto case_160;
  }
#line 288
  if ((int )fxt == 161) {
#line 288
    goto case_161;
  }
#line 293
  if ((int )fxt == 165) {
#line 293
    goto case_165;
  }
#line 298
  if ((int )fxt == 11) {
#line 298
    goto case_11;
  }
#line 302
  if ((int )fxt == 12) {
#line 302
    goto case_12;
  }
#line 307
  if ((int )fxt == 13) {
#line 307
    goto case_13;
  }
#line 311
  if ((int )fxt == 14) {
#line 311
    goto case_14___1;
  }
#line 393
  if ((int )fxt == 15) {
#line 393
    goto case_15___1;
  }
#line 401
  if ((int )fxt == 163) {
#line 401
    goto case_163;
  }
#line 405
  if ((int )fxt == 171) {
#line 405
    goto case_171;
  }
#line 413
  if ((int )fxt == 173) {
#line 413
    goto case_173;
  }
#line 429
  if ((int )fxt == 16) {
#line 429
    goto case_16;
  }
#line 432
  if ((int )fxt == 17) {
#line 432
    goto case_17;
  }
#line 446
  if ((int )fxt == 20) {
#line 446
    goto case_20;
  }
#line 449
  if ((int )fxt == 21) {
#line 449
    goto case_21;
  }
#line 452
  if ((int )fxt == 22) {
#line 452
    goto case_22;
  }
#line 455
  if ((int )fxt == 25) {
#line 455
    goto case_25;
  }
#line 460
  if ((int )fxt == 27) {
#line 460
    goto case_27;
  }
#line 471
  if ((int )fxt == 29) {
#line 471
    goto case_29;
  }
#line 476
  if ((int )fxt == 33) {
#line 476
    goto fx_xf_porta;
  }
#line 488
  if ((int )fxt == 128) {
#line 488
    goto case_128;
  }
#line 492
  if ((int )fxt == 129) {
#line 492
    goto fx_trk_vslide;
  }
#line 522
  if ((int )fxt == 130) {
#line 522
    goto fx_trk_fvslide;
  }
#line 528
  if ((int )fxt == 166) {
#line 528
    goto fx_finetune;
  }
#line 533
  if ((int )fxt == 131) {
#line 533
    goto case_131;
  }
#line 562
  if ((int )fxt == 132) {
#line 562
    goto case_132;
  }
#line 565
  if ((int )fxt == 133) {
#line 565
    goto case_133;
  }
#line 568
  if ((int )fxt == 169) {
#line 568
    goto case_169;
  }
#line 571
  if ((int )fxt == 170) {
#line 571
    goto case_170;
  }
#line 574
  if ((int )fxt == 159) {
#line 574
    goto case_159;
  }
#line 579
  if ((int )fxt == 156) {
#line 579
    goto case_156;
  }
#line 584
  if ((int )fxt == 158) {
#line 584
    goto case_158;
  }
#line 589
  if ((int )fxt == 157) {
#line 589
    goto case_157;
  }
#line 594
  if ((int )fxt == 115) {
#line 594
    goto case_115;
  }
#line 599
  if ((int )fxt == 116) {
#line 599
    goto case_116;
  }
#line 604
  if ((int )fxt == 117) {
#line 604
    goto case_117;
  }
#line 608
  if ((int )fxt == 118) {
#line 608
    goto case_118;
  }
#line 36
  goto switch_break;
  case_0: /* CIL Label */ 
#line 38
  if (! fxp) {
#line 39
    goto switch_break;
  }
#line 40
  xc->a_val[0] = 0;
#line 41
  xc->a_val[1] = 100 * (((int )fxp & 240) >> 4);
#line 42
  xc->a_val[2] = 100 * ((int )fxp & 15);
#line 43
  xc->a_size = 3;
#line 44
  goto switch_break;
  case_112: /* CIL Label */ 
#line 46
  if (! fxp) {
#line 47
    goto switch_break;
  }
#line 48
  xc->a_val[0] = -100 * (((int )fxp & 240) >> 4);
#line 49
  xc->a_val[1] = 0;
#line 50
  xc->a_val[2] = 100 * ((int )fxp & 15);
#line 51
  xc->a_size = 3;
  case_113: /* CIL Label */ 
#line 53
  if (! fxp) {
#line 54
    goto switch_break;
  }
#line 55
  xc->a_val[0] = 0;
#line 56
  xc->a_val[1] = 100 * ((int )fxp & 15);
#line 57
  xc->a_val[2] = 0;
#line 58
  xc->a_val[3] = -100 * (((int )fxp & 240) >> 4);
#line 59
  xc->a_size = 4;
#line 60
  goto switch_break;
  case_114: /* CIL Label */ 
#line 62
  if (! fxp) {
#line 63
    goto switch_break;
  }
#line 64
  xc->a_val[0] = 100 * ((int )fxp & 15);
#line 65
  xc->a_val[1] = 100 * ((int )fxp & 15);
#line 66
  xc->a_val[2] = 0;
#line 67
  xc->a_size = 3;
#line 68
  goto switch_break;
  case_1: /* CIL Label */ 
#line 70
  if ((int )fxp == 0) {
#line 71
    fxp = (uint8 )xc->porta;
  }
#line 73
  if (m___0->quirk & (1 << 12)) {
#line 73
    if (fnum == 0) {
#line 73
      goto _L;
    } else
#line 73
    if (! (m___0->quirk & (1 << 20))) {
      _L: /* CIL Label */ 
      {
#line 75
      if (((int )fxp & 240) >> 4 == 15) {
#line 75
        goto case_15;
      }
#line 79
      if (((int )fxp & 240) >> 4 == 14) {
#line 79
        goto case_14;
      }
#line 74
      goto switch_break___0;
      case_15: /* CIL Label */ 
#line 76
      xc->porta = (int )fxp;
#line 77
      fxp = (uint8 )((int )fxp & 15);
#line 78
      goto ex_f_porta_up;
      case_14: /* CIL Label */ 
#line 80
      xc->porta = (int )fxp;
#line 81
      fxp = (uint8 )((int )fxp & 14);
#line 82
      fxp = (uint8 )((int )fxp | 16);
#line 83
      goto fx_xf_porta;
      switch_break___0: /* CIL Label */ ;
      }
    }
  }
#line 86
  xc->flags |= 8;
#line 87
  tmp = (int )fxp;
#line 87
  xc->porta = tmp;
#line 87
  if (tmp != 0) {
#line 88
    xc->f_val = - ((int )fxp);
#line 89
    if (m___0->quirk & (1 << 18)) {
#line 90
      xc->s_val = - ((int )fxp);
    }
  } else
#line 91
  if (xc->f_val > 0) {
#line 92
    xc->f_val *= -1;
  }
#line 94
  goto switch_break;
  case_2: /* CIL Label */ 
#line 96
  if ((int )fxp == 0) {
#line 97
    fxp = (uint8 )xc->porta;
  }
#line 99
  if (m___0->quirk & (1 << 12)) {
#line 99
    if (fnum == 0) {
#line 99
      goto _L___0;
    } else
#line 99
    if (! (m___0->quirk & (1 << 20))) {
      _L___0: /* CIL Label */ 
      {
#line 101
      if (((int )fxp & 240) >> 4 == 15) {
#line 101
        goto case_15___0;
      }
#line 105
      if (((int )fxp & 240) >> 4 == 14) {
#line 105
        goto case_14___0;
      }
#line 100
      goto switch_break___1;
      case_15___0: /* CIL Label */ 
#line 102
      xc->porta = (int )fxp;
#line 103
      fxp = (uint8 )((int )fxp & 15);
#line 104
      goto ex_f_porta_dn;
      case_14___0: /* CIL Label */ 
#line 106
      xc->porta = (int )fxp;
#line 107
      fxp = (uint8 )((int )fxp & 14);
#line 108
      fxp = (uint8 )((int )fxp | 32);
#line 109
      goto fx_xf_porta;
      switch_break___1: /* CIL Label */ ;
      }
    }
  }
#line 112
  xc->flags |= 8;
#line 113
  tmp___0 = (int )fxp;
#line 113
  xc->porta = tmp___0;
#line 113
  if (tmp___0 != 0) {
#line 114
    xc->f_val = (int )fxp;
#line 115
    if (m___0->quirk & (1 << 18)) {
#line 116
      xc->s_val = (int )fxp;
    }
  } else
#line 117
  if (xc->f_val < 0) {
#line 118
    xc->f_val *= -1;
  }
#line 120
  goto switch_break;
  case_3: /* CIL Label */ 
#line 122
  if (! (! (! (xc->flags & 32768)))) {
#line 123
    goto switch_break;
  }
#line 124
  tmp___2 = note;
#line 124
  note = (uint8 )((int )note - 1);
#line 124
  if (tmp___2) {
#line 124
    if ((int )note < 96) {
#line 124
      if ((uint32 )xc->ins < (uint32 )(p->m.xxh)->ins) {
        {
#line 124
        tmp___1 = note_to_period(((int )note + (*(p->m.xxi + xc->ins) + (p->m.xxim + xc->ins)->ins[note])->xpo) + (int )(p->m.xxim + xc->ins)->xpo[note],
                                 (*(p->m.xxi + xc->ins) + (p->m.xxim + xc->ins)->ins[note])->fin,
                                 (p->m.xxh)->flg & 1);
#line 124
        xc->s_end = (int )tmp___1;
        }
      }
    }
  }
#line 124
  if (xc->period < (double )xc->s_end) {
#line 124
    xc->s_sgn = 1;
  } else {
#line 124
    xc->s_sgn = -1;
  }
#line 125
  if (fxp) {
#line 126
    xc->s_val = (int )fxp;
#line 127
    if (m___0->quirk & (1 << 18)) {
#line 128
      xc->porta = (int )fxp;
    }
  }
#line 130
  xc->flags |= 4;
#line 131
  goto switch_break;
  case_121: /* CIL Label */ 
#line 133
  xc->per_flags |= 8;
#line 134
  xc->f_val = - ((int )fxp);
#line 135
  tmp___3 = (int )fxp;
#line 135
  xc->porta = tmp___3;
#line 135
  if (tmp___3 == 0) {
#line 136
    xc->per_flags &= -9;
  }
#line 137
  goto switch_break;
  case_120: /* CIL Label */ 
#line 139
  xc->flags |= 8;
#line 140
  xc->f_val = (int )fxp;
#line 141
  tmp___4 = (int )fxp;
#line 141
  xc->porta = tmp___4;
#line 141
  if (tmp___4 == 0) {
#line 142
    xc->per_flags &= -9;
  }
#line 143
  goto switch_break;
  case_122: /* CIL Label */ 
#line 145
  if (! (! (! (xc->flags & 32768)))) {
#line 146
    goto switch_break;
  }
#line 147
  xc->per_flags |= 4;
#line 148
  tmp___6 = note;
#line 148
  note = (uint8 )((int )note - 1);
#line 148
  if (tmp___6) {
#line 148
    if ((int )note < 96) {
#line 148
      if ((uint32 )xc->ins < (uint32 )(p->m.xxh)->ins) {
        {
#line 148
        tmp___5 = note_to_period(((int )note + (*(p->m.xxi + xc->ins) + (p->m.xxim + xc->ins)->ins[note])->xpo) + (int )(p->m.xxim + xc->ins)->xpo[note],
                                 (*(p->m.xxi + xc->ins) + (p->m.xxim + xc->ins)->ins[note])->fin,
                                 (p->m.xxh)->flg & 1);
#line 148
        xc->s_end = (int )tmp___5;
        }
      }
    }
  }
#line 148
  if (xc->period < (double )xc->s_end) {
#line 148
    xc->s_sgn = 1;
  } else {
#line 148
    xc->s_sgn = -1;
  }
#line 149
  xc->s_val = (int )fxp;
#line 150
  if ((int )fxp == 0) {
#line 151
    xc->per_flags &= -5;
  }
#line 152
  goto switch_break;
  case_124: /* CIL Label */ 
#line 154
  xc->per_flags |= 1;
#line 155
  xc->v_val = (int )fxp;
#line 156
  if ((int )fxp == 0) {
#line 157
    xc->per_flags &= -2;
  }
#line 158
  goto switch_break;
  case_125: /* CIL Label */ 
#line 160
  xc->per_flags |= 1;
#line 161
  xc->v_val = - ((int )fxp);
#line 162
  if ((int )fxp == 0) {
#line 163
    xc->per_flags &= -2;
  }
#line 164
  goto switch_break;
  case_126: /* CIL Label */ 
#line 166
  if (fxp) {
#line 167
    p->tempo = (int )fxp;
  }
  case_127: /* CIL Label */ 
#line 170
  xc->per_flags = 0;
#line 171
  goto switch_break;
  case_4: /* CIL Label */ 
#line 173
  xc->flags |= 16;
#line 174
  if ((int )fxp & 15) {
#line 175
    xc->y_depth = ((int )fxp & 15) * 4;
  }
#line 176
  if (((int )fxp & 240) >> 4) {
#line 177
    xc->y_rate = ((int )fxp & 240) >> 4;
  }
#line 178
  goto switch_break;
  case_134: /* CIL Label */ 
#line 180
  xc->flags |= 16;
#line 181
  if ((int )fxp & 15) {
#line 182
    xc->y_depth = ((int )fxp & 15) * 2;
  }
#line 183
  if (((int )fxp & 240) >> 4) {
#line 184
    xc->y_rate = ((int )fxp & 240) >> 4;
  }
#line 185
  goto switch_break;
  case_172: /* CIL Label */ 
#line 187
  xc->flags |= 16;
#line 188
  if ((int )fxp & 15) {
#line 189
    xc->y_depth = (int )fxp & 15;
  }
#line 190
  if (((int )fxp & 240) >> 4) {
#line 191
    xc->y_rate = ((int )fxp & 240) >> 4;
  }
#line 192
  goto switch_break;
  case_123: /* CIL Label */ 
#line 194
  xc->per_flags |= 16;
#line 195
  if ((int )fxp & 15) {
#line 196
    xc->y_depth = ((int )fxp & 15) * 4;
  } else {
#line 198
    xc->per_flags &= -17;
  }
#line 199
  if (((int )fxp & 240) >> 4) {
#line 200
    xc->y_rate = ((int )fxp & 240) >> 4;
  }
#line 201
  goto switch_break;
  case_5: /* CIL Label */ 
#line 203
  if (! (! (! (xc->flags & 32768)))) {
#line 204
    goto switch_break;
  }
#line 205
  tmp___8 = note;
#line 205
  note = (uint8 )((int )note - 1);
#line 205
  if (tmp___8) {
#line 205
    if ((int )note < 96) {
#line 205
      if ((uint32 )xc->ins < (uint32 )(p->m.xxh)->ins) {
        {
#line 205
        tmp___7 = note_to_period(((int )note + (*(p->m.xxi + xc->ins) + (p->m.xxim + xc->ins)->ins[note])->xpo) + (int )(p->m.xxim + xc->ins)->xpo[note],
                                 (*(p->m.xxi + xc->ins) + (p->m.xxim + xc->ins)->ins[note])->fin,
                                 (p->m.xxh)->flg & 1);
#line 205
        xc->s_end = (int )tmp___7;
        }
      }
    }
  }
#line 205
  if (xc->period < (double )xc->s_end) {
#line 205
    xc->s_sgn = 1;
  } else {
#line 205
    xc->s_sgn = -1;
  }
#line 206
  xc->flags |= 4;
#line 207
  goto fx_volslide;
  case_6: /* CIL Label */ 
#line 209
  xc->flags |= 16;
#line 210
  goto fx_volslide;
  case_7: /* CIL Label */ 
#line 212
  xc->flags |= 32;
#line 213
  if (((int )fxp & 240) >> 4) {
#line 214
    xc->t_rate = ((int )fxp & 240) >> 4;
  }
#line 215
  if ((int )fxp & 15) {
#line 216
    xc->t_depth = (int )fxp & 15;
  }
#line 217
  goto switch_break;
  case_8: /* CIL Label */ 
#line 219
  xc->flags |= 256;
#line 220
  xc->pan = (int )fxp;
#line 221
  goto switch_break;
  case_9: /* CIL Label */ 
#line 223
  xc->flags |= 1024;
#line 224
  if (fxp) {
#line 225
    tmp___9 = (int )fxp << 8;
#line 225
    xc->offset = tmp___9;
#line 225
    xc->offset_val = tmp___9;
  } else {
#line 227
    xc->offset_val = xc->offset;
  }
#line 228
  goto switch_break;
  fx_volslide: 
  case_10: /* CIL Label */ 
#line 236
  if (m___0->quirk & (1 << 12)) {
#line 237
    h = ((int )fxp & 240) >> 4;
#line 238
    l = (int )fxp & 15;
#line 239
    if (l == 15) {
#line 239
      if (h != 0) {
#line 240
        xc->volslide = (int )fxp;
#line 241
        fxp = (uint8 )((int )fxp >> 4);
#line 242
        goto ex_f_vslide_up;
      } else {
#line 239
        goto _L___2;
      }
    } else
    _L___2: /* CIL Label */ 
#line 243
    if (h == 15) {
#line 243
      if (l != 0) {
#line 244
        xc->volslide = (int )fxp;
#line 245
        fxp = (uint8 )((int )fxp & 15);
#line 246
        goto ex_f_vslide_dn;
      } else {
#line 243
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */ 
#line 247
    if (! fxp) {
#line 248
      fxp = (uint8 )xc->volslide;
#line 248
      if ((int )fxp != 0) {
#line 249
        goto fx_volslide;
      }
    }
  }
#line 252
  xc->flags |= 1;
#line 258
  if (fxp) {
#line 259
    if (m___0->quirk & (1 << 17)) {
#line 260
      tmp___10 = (int )fxp;
#line 260
      xc->volslide = tmp___10;
#line 260
      if (tmp___10) {
#line 261
        if ((int )fxp & 15) {
#line 261
          xc->v_val = - ((int )fxp & 15);
        } else {
#line 261
          xc->v_val = ((int )fxp & 240) >> 4;
        }
      }
    } else {
#line 263
      xc->v_val = - ((int )fxp & 15) + (((int )fxp & 240) >> 4);
    }
  }
#line 267
  if (m___0->quirk & (1 << 12)) {
#line 272
    if ((xc->volslide & 240) >> 4 == 15) {
#line 273
      xc->flags |= 64;
#line 274
      xc->v_fval = xc->v_val;
    } else
#line 272
    if ((xc->volslide & 15) == 15) {
#line 273
      xc->flags |= 64;
#line 274
      xc->v_fval = xc->v_val;
    }
  }
#line 277
  goto switch_break;
  case_164: /* CIL Label */ 
#line 279
  xc->flags |= 524288;
#line 280
  if (fxp) {
#line 281
    xc->v_val2 = - ((int )fxp & 15) + (((int )fxp & 240) >> 4);
  }
#line 282
  goto switch_break;
  case_160: /* CIL Label */ 
#line 284
  if (fxp) {
#line 285
    xc->v_val = (int )fxp;
  }
#line 286
  xc->flags |= 1;
#line 287
  goto switch_break;
  case_161: /* CIL Label */ 
#line 289
  if (fxp) {
#line 290
    xc->v_val = - ((int )fxp);
  }
#line 291
  xc->flags |= 1;
#line 292
  goto switch_break;
  case_165: /* CIL Label */ 
#line 294
  xc->flags |= 64;
#line 295
  tmp___11 = (int )fxp;
#line 295
  xc->fvolslide = tmp___11;
#line 295
  if (tmp___11) {
#line 296
    xc->v_fval = (((int )fxp & 240) >> 4) - ((int )fxp & 15);
  }
#line 297
  goto switch_break;
  case_11: /* CIL Label */ 
#line 299
  p->flow.pbreak = 1;
#line 300
  p->flow.jump = (int )fxp;
#line 301
  goto switch_break;
  case_12: /* CIL Label */ 
#line 303
  xc->flags &= -8193;
#line 304
  xc->flags |= 131072;
#line 305
  xc->volume = (int )fxp;
#line 306
  goto switch_break;
  case_13: /* CIL Label */ 
#line 308
  p->flow.pbreak = 1;
#line 309
  p->flow.jumpline = 10 * (((int )fxp & 240) >> 4) + ((int )fxp & 15);
#line 310
  goto switch_break;
  case_14___1: /* CIL Label */ 
#line 312
  fxt = (uint8 )((int )fxp >> 4);
#line 313
  fxp = (uint8 )((int )fxp & 15);
  {
#line 315
  if ((int )fxt == 1) {
#line 315
    goto ex_f_porta_up;
  }
#line 323
  if ((int )fxt == 2) {
#line 323
    goto ex_f_porta_dn;
  }
#line 331
  if ((int )fxt == 3) {
#line 331
    goto case_3___0;
  }
#line 334
  if ((int )fxt == 4) {
#line 334
    goto case_4___0;
  }
#line 337
  if ((int )fxt == 5) {
#line 337
    goto case_5___0;
  }
#line 340
  if ((int )fxt == 6) {
#line 340
    goto case_6___0;
  }
#line 361
  if ((int )fxt == 7) {
#line 361
    goto case_7___0;
  }
#line 364
  if ((int )fxt == 9) {
#line 364
    goto case_9___0;
  }
#line 369
  if ((int )fxt == 10) {
#line 369
    goto ex_f_vslide_up;
  }
#line 375
  if ((int )fxt == 11) {
#line 375
    goto ex_f_vslide_dn;
  }
#line 381
  if ((int )fxt == 12) {
#line 381
    goto case_12___0;
  }
#line 385
  if ((int )fxt == 13) {
#line 385
    goto case_13___0;
  }
#line 388
  if ((int )fxt == 14) {
#line 388
    goto case_14___2;
  }
#line 314
  goto switch_break___2;
  ex_f_porta_up: 
  case_1___0: /* CIL Label */ 
#line 317
  xc->flags |= 128;
#line 318
  if (fxp) {
#line 319
    xc->f_fval = - ((int )fxp) * 4;
  } else
#line 320
  if (xc->f_val > 0) {
#line 321
    xc->f_val *= -1;
  }
#line 322
  goto switch_break___2;
  ex_f_porta_dn: 
  case_2___0: /* CIL Label */ 
#line 325
  xc->flags |= 128;
#line 326
  if (fxp) {
#line 327
    xc->f_fval = (int )fxp * 4;
  } else
#line 328
  if (xc->f_val < 0) {
#line 329
    xc->f_val *= -1;
  }
#line 330
  goto switch_break___2;
  case_3___0: /* CIL Label */ 
#line 332
  xc->gliss = (int )fxp;
#line 333
  goto switch_break___2;
  case_4___0: /* CIL Label */ 
#line 335
  xc->y_type = (int )fxp & 3;
#line 336
  goto switch_break___2;
  case_5___0: /* CIL Label */ 
#line 338
  fxp = (uint8 )((int )fxp << 4);
#line 339
  goto fx_finetune;
  case_6___0: /* CIL Label */ 
#line 341
  if ((int )fxp == 0) {
#line 343
    *(f->loop_start + chn) = p->flow.row;
  } else
#line 346
  if (*(f->loop_stack + chn)) {
#line 347
    (*(f->loop_stack + chn)) --;
#line 347
    if (*(f->loop_stack + chn)) {
#line 348
      chn ++;
#line 348
      f->loop_chn = chn;
    } else
#line 350
    if (m___0->quirk & (1 << 1)) {
#line 351
      *(f->loop_start + chn) = f->row + 1;
    }
  } else
#line 354
  if (*(f->loop_start + chn) <= f->row) {
#line 355
    *(f->loop_stack + chn) = (int )fxp;
#line 356
    chn ++;
#line 356
    f->loop_chn = chn;
  }
#line 360
  goto switch_break___2;
  case_7___0: /* CIL Label */ 
#line 362
  xc->t_type = (int )fxp & 3;
#line 363
  goto switch_break___2;
  case_9___0: /* CIL Label */ 
#line 365
  if (fxp) {
#line 365
    tmp___12 = (int )fxp;
  } else {
#line 365
    tmp___12 = xc->rval;
  }
#line 365
  xc->rcount = tmp___12;
#line 365
  xc->retrig = tmp___12;
#line 366
  xc->rval = xc->retrig;
#line 367
  xc->rtype = 0;
#line 368
  goto switch_break___2;
  ex_f_vslide_up: 
  case_10___0: /* CIL Label */ 
#line 371
  xc->flags |= 64;
#line 372
  if (fxp) {
#line 373
    xc->v_fval = (int )fxp;
  }
#line 374
  goto switch_break___2;
  ex_f_vslide_dn: 
  case_11___0: /* CIL Label */ 
#line 377
  xc->flags |= 64;
#line 378
  if (fxp) {
#line 379
    xc->v_fval = - ((int )fxp);
  }
#line 380
  goto switch_break___2;
  case_12___0: /* CIL Label */ 
#line 382
  tmp___13 = (int )fxp + 1;
#line 382
  xc->rcount = tmp___13;
#line 382
  xc->retrig = tmp___13;
#line 383
  xc->rtype = 16;
#line 384
  goto switch_break___2;
  case_13___0: /* CIL Label */ 
#line 386
  xc->delay = (int )fxp + 1;
#line 387
  goto switch_break___2;
  case_14___2: /* CIL Label */ 
#line 389
  p->flow.delay = (int )fxp;
#line 390
  goto switch_break___2;
  switch_break___2: /* CIL Label */ ;
  }
#line 392
  goto switch_break;
  case_15___1: /* CIL Label */ 
#line 394
  if (fxp) {
#line 395
    if ((int )fxp < 32) {
#line 396
      p->tempo = (int )fxp;
    } else
#line 397
    if (~ m___0->flags & (1 << 4)) {
#line 398
      tmp___14 = (int )fxp;
#line 398
      p->xmp_bpm = tmp___14;
#line 398
      p->tick_time = m___0->rrate / (double )tmp___14;
    }
  }
#line 400
  goto switch_break;
  case_163: /* CIL Label */ 
#line 402
  if (fxp) {
#line 403
    p->tempo = (int )fxp;
  }
#line 404
  goto switch_break;
  case_171: /* CIL Label */ 
#line 406
  if (fxp) {
#line 407
    if ((int )fxp < 5) {
#line 408
      fxp = (uint8 )5;
    }
#line 409
    p->xmp_bpm = (int )fxp;
#line 410
    p->tick_time = m___0->rrate / (double )p->xmp_bpm;
  }
#line 412
  goto switch_break;
  case_173: /* CIL Label */ 
#line 414
  if (((int )fxp & 240) >> 4 == 0) {
#line 415
    p->xmp_bpm -= (int )fxp & 15;
#line 416
    if (p->xmp_bpm < 32) {
#line 417
      p->xmp_bpm = 32;
    }
  } else
#line 418
  if (((int )fxp & 240) >> 4 == 1) {
#line 419
    p->xmp_bpm += (int )fxp & 15;
#line 420
    if (p->xmp_bpm > 255) {
#line 421
      p->xmp_bpm = 255;
    }
  } else {
#line 423
    if ((int )fxp < 5) {
#line 424
      fxp = (uint8 )5;
    }
#line 425
    p->xmp_bpm = (int )fxp;
  }
#line 427
  p->tick_time = m___0->rrate / (double )p->xmp_bpm;
#line 428
  goto switch_break;
  case_16: /* CIL Label */ 
#line 430
  if ((int )fxp > m___0->volbase) {
#line 430
    m___0->volume = m___0->volbase;
  } else {
#line 430
    m___0->volume = (int )fxp;
  }
#line 431
  goto switch_break;
  case_17: /* CIL Label */ 
#line 433
  p->gvol_flag = 1;
#line 434
  if (m___0->quirk & (1 << 12)) {
#line 435
    h = ((int )fxp & 240) >> 4;
#line 436
    l = (int )fxp & 15;
#line 437
    if (h == 15) {
#line 437
      if (l != 0) {
#line 438
        fxp = (uint8 )1;
      } else {
#line 437
        goto _L___3;
      }
    } else
    _L___3: /* CIL Label */ 
#line 439
    if (l == 15) {
#line 439
      if (h != 0) {
#line 440
        fxp = (uint8 )16;
      }
    }
  }
#line 443
  if (fxp) {
#line 444
    p->gvol_slide = (((int )fxp & 240) >> 4) - ((int )fxp & 15);
  }
#line 445
  goto switch_break;
  case_20: /* CIL Label */ 
#line 447
  xc->keyoff = (int )fxp;
#line 448
  goto switch_break;
  case_21: /* CIL Label */ ;
#line 451
  goto switch_break;
  case_22: /* CIL Label */ 
#line 453
  xc->masterpan = (int )fxp;
#line 454
  goto switch_break;
  case_25: /* CIL Label */ 
#line 456
  xc->flags |= 2;
#line 457
  if (fxp) {
#line 458
    xc->p_val = (((int )fxp & 240) >> 4) - ((int )fxp & 15);
  }
#line 459
  goto switch_break;
  case_27: /* CIL Label */ 
#line 461
  if ((int )fxp & 15) {
#line 462
    tmp___15 = (int )fxp & 15;
#line 462
    xc->rcount = tmp___15;
#line 462
    xc->retrig = tmp___15;
#line 463
    xc->rval = xc->retrig;
  } else {
#line 465
    tmp___16 = xc->rval;
#line 465
    xc->rcount = tmp___16;
#line 465
    xc->retrig = tmp___16;
  }
#line 467
  if (((int )fxp & 240) >> 4) {
#line 468
    xc->rtype = ((int )fxp & 240) >> 4;
  }
#line 470
  goto switch_break;
  case_29: /* CIL Label */ 
#line 472
  xc->tremor = (int )fxp;
#line 473
  xc->tcnt_up = ((int )fxp & 240) >> 4;
#line 474
  xc->tcnt_dn = -1;
#line 475
  goto switch_break;
  fx_xf_porta: 
  case_33: /* CIL Label */ 
#line 478
  xc->flags |= 128;
  {
#line 480
  if (((int )fxp & 240) >> 4 == 1) {
#line 480
    goto case_1___1;
  }
#line 483
  if (((int )fxp & 240) >> 4 == 2) {
#line 483
    goto case_2___1;
  }
#line 479
  goto switch_break___3;
  case_1___1: /* CIL Label */ 
#line 481
  xc->f_fval = - ((int )fxp & 15);
#line 482
  goto switch_break___3;
  case_2___1: /* CIL Label */ 
#line 484
  xc->f_fval = (int )fxp & 15;
#line 485
  goto switch_break___3;
  switch_break___3: /* CIL Label */ ;
  }
#line 487
  goto switch_break;
  case_128: /* CIL Label */ 
#line 489
  if ((int )fxp <= m___0->volbase) {
#line 490
    xc->mastervol = (int )fxp;
  }
#line 491
  goto switch_break;
  fx_trk_vslide: 
  case_129: /* CIL Label */ 
#line 494
  if (m___0->quirk & (1 << 12)) {
#line 495
    h = ((int )fxp & 240) >> 4;
#line 496
    l = (int )fxp & 15;
#line 497
    if (h == 15) {
#line 497
      if (l != 0) {
#line 498
        xc->trkvsld = (int )fxp;
#line 499
        fxp = (uint8 )((int )fxp & 15);
#line 500
        goto fx_trk_fvslide;
      } else {
#line 497
        goto _L___7;
      }
    } else
    _L___7: /* CIL Label */ 
#line 501
    if (h == 14) {
#line 501
      if (l != 0) {
#line 502
        xc->trkvsld = (int )fxp;
#line 503
        fxp = (uint8 )((int )fxp & 15);
#line 504
        goto fx_trk_fvslide;
      } else {
#line 501
        goto _L___6;
      }
    } else
    _L___6: /* CIL Label */ 
#line 505
    if (l == 15) {
#line 505
      if (h != 0) {
#line 506
        xc->trkvsld = (int )fxp;
#line 507
        fxp = (uint8 )((int )fxp & 240);
#line 508
        goto fx_trk_fvslide;
      } else {
#line 505
        goto _L___5;
      }
    } else
    _L___5: /* CIL Label */ 
#line 509
    if (l == 14) {
#line 509
      if (h != 0) {
#line 510
        xc->trkvsld = (int )fxp;
#line 511
        fxp = (uint8 )((int )fxp & 240);
#line 512
        goto fx_trk_fvslide;
      } else {
#line 509
        goto _L___4;
      }
    } else
    _L___4: /* CIL Label */ 
#line 513
    if (! fxp) {
#line 514
      fxp = (uint8 )xc->trkvsld;
#line 514
      if ((int )fxp != 0) {
#line 515
        goto fx_trk_vslide;
      }
    }
  }
#line 518
  xc->flags |= 2048;
#line 519
  tmp___17 = (int )fxp;
#line 519
  xc->trkvsld = tmp___17;
#line 519
  if (tmp___17) {
#line 520
    xc->trk_val = (((int )fxp & 240) >> 4) - ((int )fxp & 15);
  }
#line 521
  goto switch_break;
  fx_trk_fvslide: 
  case_130: /* CIL Label */ 
#line 524
  xc->flags |= 4096;
#line 525
  if (fxp) {
#line 526
    xc->trk_fval = (((int )fxp & 240) >> 4) - ((int )fxp & 15);
  }
#line 527
  goto switch_break;
  fx_finetune: 
  case_166: /* CIL Label */ 
#line 530
  xc->flags |= 512;
#line 531
  xc->finetune = (int )((int16 )((int )fxp - 128));
#line 532
  goto switch_break;
  case_131: /* CIL Label */ 
  {
#line 535
  if ((int )fxp == 0) {
#line 535
    goto case_0___0;
  }
#line 538
  if ((int )fxp == 1) {
#line 538
    goto case_1___2;
  }
#line 541
  if ((int )fxp == 2) {
#line 541
    goto case_2___2;
  }
#line 544
  if ((int )fxp == 3) {
#line 544
    goto case_3___1;
  }
#line 547
  if ((int )fxp == 4) {
#line 547
    goto case_4___1;
  }
#line 550
  if ((int )fxp == 5) {
#line 550
    goto case_5___1;
  }
#line 553
  if ((int )fxp == 6) {
#line 553
    goto case_6___1;
  }
#line 556
  if ((int )fxp == 7) {
#line 556
    goto case_7___1;
  }
#line 558
  if ((int )fxp == 8) {
#line 558
    goto case_8___0;
  }
#line 534
  goto switch_break___4;
  case_0___0: /* CIL Label */ 
  {
#line 536
  xmp_drv_pastnote(ctx___0, chn, 0);
  }
#line 537
  goto switch_break___4;
  case_1___2: /* CIL Label */ 
  {
#line 539
  xmp_drv_pastnote(ctx___0, chn, 2);
  }
#line 540
  goto switch_break___4;
  case_2___2: /* CIL Label */ 
  {
#line 542
  xmp_drv_pastnote(ctx___0, chn, 3);
  }
#line 543
  goto switch_break___4;
  case_3___1: /* CIL Label */ 
  {
#line 545
  xmp_drv_setnna(ctx___0, chn, 0);
  }
#line 546
  goto switch_break___4;
  case_4___1: /* CIL Label */ 
  {
#line 548
  xmp_drv_setnna(ctx___0, chn, 1);
  }
#line 549
  goto switch_break___4;
  case_5___1: /* CIL Label */ 
  {
#line 551
  xmp_drv_setnna(ctx___0, chn, 2);
  }
#line 552
  goto switch_break___4;
  case_6___1: /* CIL Label */ 
  {
#line 554
  xmp_drv_setnna(ctx___0, chn, 3);
  }
#line 555
  goto switch_break___4;
  case_7___1: /* CIL Label */ 
#line 557
  goto switch_break___4;
  case_8___0: /* CIL Label */ 
#line 559
  goto switch_break___4;
  switch_break___4: /* CIL Label */ ;
  }
#line 561
  goto switch_break;
  case_132: /* CIL Label */ 
#line 563
  xc->cutoff = (int )fxp;
#line 564
  goto switch_break;
  case_133: /* CIL Label */ 
#line 566
  xc->resonance = (int )fxp;
#line 567
  goto switch_break;
  case_169: /* CIL Label */ 
#line 569
  m___0->xxc[chn].cho = (int )fxp;
#line 570
  goto switch_break;
  case_170: /* CIL Label */ 
#line 572
  m___0->xxc[chn].rvb = (int )fxp;
#line 573
  goto switch_break;
  case_159: /* CIL Label */ 
#line 575
  if (((int )fxp & 240) >> 4) {
#line 575
    tmp___18 = ((int )fxp & 240) >> 4;
  } else {
#line 575
    tmp___18 = xc->rval;
  }
#line 575
  xc->rcount = tmp___18;
#line 575
  xc->retrig = tmp___18;
#line 576
  xc->rval = xc->retrig;
#line 577
  xc->rtype = 0;
  case_156: /* CIL Label */ 
#line 580
  xc->flags |= 1048576;
#line 581
  xc->ns_val = - ((int )fxp & 15);
#line 582
  tmp___19 = ((int )fxp & 240) >> 4;
#line 582
  xc->ns_speed = tmp___19;
#line 582
  xc->ns_count = tmp___19;
#line 583
  goto switch_break;
  case_158: /* CIL Label */ 
#line 585
  if (((int )fxp & 240) >> 4) {
#line 585
    tmp___20 = ((int )fxp & 240) >> 4;
  } else {
#line 585
    tmp___20 = xc->rval;
  }
#line 585
  xc->rcount = tmp___20;
#line 585
  xc->retrig = tmp___20;
#line 586
  xc->rval = xc->retrig;
#line 587
  xc->rtype = 0;
  case_157: /* CIL Label */ 
#line 590
  xc->flags |= 1048576;
#line 591
  xc->ns_val = (int )fxp & 15;
#line 592
  tmp___21 = ((int )fxp & 240) >> 4;
#line 592
  xc->ns_speed = tmp___21;
#line 592
  xc->ns_count = tmp___21;
#line 593
  goto switch_break;
  case_115: /* CIL Label */ 
#line 595
  xc->flags |= 1048576;
#line 596
  xc->ns_val = - ((int )fxp);
#line 597
  tmp___22 = 1;
#line 597
  xc->ns_speed = tmp___22;
#line 597
  xc->ns_count = tmp___22;
#line 598
  goto switch_break;
  case_116: /* CIL Label */ 
#line 600
  xc->flags |= 1048576;
#line 601
  xc->ns_val = (int )fxp;
#line 602
  tmp___23 = 1;
#line 602
  xc->ns_speed = tmp___23;
#line 602
  xc->ns_count = tmp___23;
#line 603
  goto switch_break;
  case_117: /* CIL Label */ 
#line 605
  xc->flags |= 2097152;
#line 606
  xc->ns_fval = - ((int )fxp);
#line 607
  goto switch_break;
  case_118: /* CIL Label */ 
#line 609
  xc->flags |= 2097152;
#line 610
  xc->ns_fval = (int )fxp;
#line 611
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 613
  return;
}
}
#line 13 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/player/synth.h"
void synth_mixer(int *tmp_bk , int count , int vl , int vr , int stereo ) ;
#line 102 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/player/mix_all.c"
void smix_st8itpt(struct voice_info *vi , int *tmp_bk , int count , int vl , int vr ,
                  int itpt_inc ) 
{ 
  register int smp_in ;
  int8 *in_bk ;
  int cur_bk ;
  int itpt ;
  int smp_x1 ;
  int smp_dt ;
  int a ;
  int *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;

  {
#line 104
  in_bk = (int8 *)vi->sptr;
#line 104
  cur_bk = vi->pos - 1;
#line 104
  itpt = vi->itpt + (1 << 16);
#line 104
  smp_x1 = 0;
#line 104
  smp_dt = 0;
  {
#line 105
  while (1) {
    while_continue: /* CIL Label */ ;
#line 105
    tmp___3 = count;
#line 105
    count --;
#line 105
    if (! tmp___3) {
#line 105
      goto while_break;
    }
    {
#line 105
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 105
      if (itpt >> 16) {
#line 105
        cur_bk += itpt >> 16;
#line 105
        smp_x1 = (int )*(in_bk + cur_bk);
#line 105
        smp_dt = (int )*(in_bk + (cur_bk + 1)) - smp_x1;
#line 105
        itpt &= 65535;
      }
#line 105
      smp_in = smp_x1 + (itpt * smp_dt >> 16);
#line 105
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 105
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 105
      if (vi->attack) {
#line 105
        a = 64 - vi->attack;
#line 105
        tmp = tmp_bk;
#line 105
        tmp_bk ++;
#line 105
        *tmp += ((smp_in * vr) * a) / 64;
#line 105
        tmp___0 = tmp_bk;
#line 105
        tmp_bk ++;
#line 105
        *tmp___0 += ((smp_in * vl) * a) / 64;
#line 105
        (vi->attack) --;
      } else {
#line 105
        tmp___1 = tmp_bk;
#line 105
        tmp_bk ++;
#line 105
        *tmp___1 += smp_in * vr;
#line 105
        tmp___2 = tmp_bk;
#line 105
        tmp_bk ++;
#line 105
        *tmp___2 += smp_in * vl;
      }
#line 105
      itpt += itpt_inc;
#line 105
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 106
  return;
}
}
#line 111 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/player/mix_all.c"
void smix_st16itpt(struct voice_info *vi , int *tmp_bk , int count , int vl , int vr ,
                   int itpt_inc ) 
{ 
  register int smp_in ;
  int16 *in_bk ;
  int cur_bk ;
  int itpt ;
  int smp_x1 ;
  int smp_dt ;
  int a ;
  int *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;

  {
#line 113
  in_bk = (int16 *)vi->sptr;
#line 113
  cur_bk = vi->pos - 1;
#line 113
  itpt = vi->itpt + (1 << 16);
#line 113
  smp_x1 = 0;
#line 113
  smp_dt = 0;
#line 115
  vl >>= 8;
#line 116
  vr >>= 8;
  {
#line 117
  while (1) {
    while_continue: /* CIL Label */ ;
#line 117
    tmp___3 = count;
#line 117
    count --;
#line 117
    if (! tmp___3) {
#line 117
      goto while_break;
    }
    {
#line 117
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 117
      if (itpt >> 16) {
#line 117
        cur_bk += itpt >> 16;
#line 117
        smp_x1 = (int )*(in_bk + cur_bk);
#line 117
        smp_dt = (int )*(in_bk + (cur_bk + 1)) - smp_x1;
#line 117
        itpt &= 65535;
      }
#line 117
      smp_in = smp_x1 + (itpt * smp_dt >> 16);
#line 117
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 117
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 117
      if (vi->attack) {
#line 117
        a = 64 - vi->attack;
#line 117
        tmp = tmp_bk;
#line 117
        tmp_bk ++;
#line 117
        *tmp += ((smp_in * vr) * a) / 64;
#line 117
        tmp___0 = tmp_bk;
#line 117
        tmp_bk ++;
#line 117
        *tmp___0 += ((smp_in * vl) * a) / 64;
#line 117
        (vi->attack) --;
      } else {
#line 117
        tmp___1 = tmp_bk;
#line 117
        tmp_bk ++;
#line 117
        *tmp___1 += smp_in * vr;
#line 117
        tmp___2 = tmp_bk;
#line 117
        tmp_bk ++;
#line 117
        *tmp___2 += smp_in * vl;
      }
#line 117
      itpt += itpt_inc;
#line 117
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 118
  return;
}
}
#line 123 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/player/mix_all.c"
void smix_st8norm(struct voice_info *vi , int *tmp_bk , int count , int vl , int vr ,
                  int itpt_inc ) 
{ 
  register int smp_in ;
  int8 *in_bk ;
  int cur_bk ;
  int itpt ;
  int *tmp ;
  int *tmp___0 ;
  int tmp___1 ;

  {
#line 125
  in_bk = (int8 *)vi->sptr;
#line 125
  cur_bk = vi->pos - 1;
#line 125
  itpt = vi->itpt + (1 << 16);
#line 127
  in_bk += cur_bk;
  {
#line 128
  while (1) {
    while_continue: /* CIL Label */ ;
#line 128
    tmp___1 = count;
#line 128
    count --;
#line 128
    if (! tmp___1) {
#line 128
      goto while_break;
    }
    {
#line 128
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 128
      smp_in = (int )*(in_bk + (itpt >> 16));
#line 128
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 128
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 128
      tmp = tmp_bk;
#line 128
      tmp_bk ++;
#line 128
      *tmp += smp_in * vr;
#line 128
      tmp___0 = tmp_bk;
#line 128
      tmp_bk ++;
#line 128
      *tmp___0 += smp_in * vl;
#line 128
      itpt += itpt_inc;
#line 128
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 129
  return;
}
}
#line 134 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/player/mix_all.c"
void smix_st16norm(struct voice_info *vi , int *tmp_bk , int count , int vl , int vr ,
                   int itpt_inc ) 
{ 
  register int smp_in ;
  int16 *in_bk ;
  int cur_bk ;
  int itpt ;
  int *tmp ;
  int *tmp___0 ;
  int tmp___1 ;

  {
#line 136
  in_bk = (int16 *)vi->sptr;
#line 136
  cur_bk = vi->pos - 1;
#line 136
  itpt = vi->itpt + (1 << 16);
#line 138
  vl >>= 8;
#line 139
  vr >>= 8;
#line 140
  in_bk += cur_bk;
  {
#line 141
  while (1) {
    while_continue: /* CIL Label */ ;
#line 141
    tmp___1 = count;
#line 141
    count --;
#line 141
    if (! tmp___1) {
#line 141
      goto while_break;
    }
    {
#line 141
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 141
      smp_in = (int )*(in_bk + (itpt >> 16));
#line 141
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 141
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 141
      tmp = tmp_bk;
#line 141
      tmp_bk ++;
#line 141
      *tmp += smp_in * vr;
#line 141
      tmp___0 = tmp_bk;
#line 141
      tmp_bk ++;
#line 141
      *tmp___0 += smp_in * vl;
#line 141
      itpt += itpt_inc;
#line 141
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 142
  return;
}
}
#line 147 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/player/mix_all.c"
void smix_mn8itpt(struct voice_info *vi , int *tmp_bk , int count , int vl , int vr ,
                  int itpt_inc ) 
{ 
  register int smp_in ;
  int8 *in_bk ;
  int cur_bk ;
  int itpt ;
  int smp_x1 ;
  int smp_dt ;
  int *tmp ;
  int *tmp___0 ;
  int tmp___1 ;

  {
#line 149
  in_bk = (int8 *)vi->sptr;
#line 149
  cur_bk = vi->pos - 1;
#line 149
  itpt = vi->itpt + (1 << 16);
#line 149
  smp_x1 = 0;
#line 149
  smp_dt = 0;
#line 151
  vl <<= 1;
  {
#line 152
  while (1) {
    while_continue: /* CIL Label */ ;
#line 152
    tmp___1 = count;
#line 152
    count --;
#line 152
    if (! tmp___1) {
#line 152
      goto while_break;
    }
    {
#line 152
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 152
      if (itpt >> 16) {
#line 152
        cur_bk += itpt >> 16;
#line 152
        smp_x1 = (int )*(in_bk + cur_bk);
#line 152
        smp_dt = (int )*(in_bk + (cur_bk + 1)) - smp_x1;
#line 152
        itpt &= 65535;
      }
#line 152
      smp_in = smp_x1 + (itpt * smp_dt >> 16);
#line 152
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 152
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 152
      if (vi->attack) {
#line 152
        tmp = tmp_bk;
#line 152
        tmp_bk ++;
#line 152
        *tmp += ((smp_in * vl) * (64 - vi->attack)) / 64;
#line 152
        (vi->attack) --;
      } else {
#line 152
        tmp___0 = tmp_bk;
#line 152
        tmp_bk ++;
#line 152
        *tmp___0 += smp_in * vl;
      }
#line 152
      itpt += itpt_inc;
#line 152
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 153
  return;
}
}
#line 158 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/player/mix_all.c"
void smix_mn16itpt(struct voice_info *vi , int *tmp_bk , int count , int vl , int vr ,
                   int itpt_inc ) 
{ 
  register int smp_in ;
  int16 *in_bk ;
  int cur_bk ;
  int itpt ;
  int smp_x1 ;
  int smp_dt ;
  int *tmp ;
  int *tmp___0 ;
  int tmp___1 ;

  {
#line 160
  in_bk = (int16 *)vi->sptr;
#line 160
  cur_bk = vi->pos - 1;
#line 160
  itpt = vi->itpt + (1 << 16);
#line 160
  smp_x1 = 0;
#line 160
  smp_dt = 0;
#line 162
  vl >>= 7;
  {
#line 163
  while (1) {
    while_continue: /* CIL Label */ ;
#line 163
    tmp___1 = count;
#line 163
    count --;
#line 163
    if (! tmp___1) {
#line 163
      goto while_break;
    }
    {
#line 163
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 163
      if (itpt >> 16) {
#line 163
        cur_bk += itpt >> 16;
#line 163
        smp_x1 = (int )*(in_bk + cur_bk);
#line 163
        smp_dt = (int )*(in_bk + (cur_bk + 1)) - smp_x1;
#line 163
        itpt &= 65535;
      }
#line 163
      smp_in = smp_x1 + (itpt * smp_dt >> 16);
#line 163
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 163
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 163
      if (vi->attack) {
#line 163
        tmp = tmp_bk;
#line 163
        tmp_bk ++;
#line 163
        *tmp += ((smp_in * vl) * (64 - vi->attack)) / 64;
#line 163
        (vi->attack) --;
      } else {
#line 163
        tmp___0 = tmp_bk;
#line 163
        tmp_bk ++;
#line 163
        *tmp___0 += smp_in * vl;
      }
#line 163
      itpt += itpt_inc;
#line 163
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 164
  return;
}
}
#line 169 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/player/mix_all.c"
void smix_mn8norm(struct voice_info *vi , int *tmp_bk , int count , int vl , int vr ,
                  int itpt_inc ) 
{ 
  register int smp_in ;
  int8 *in_bk ;
  int cur_bk ;
  int itpt ;
  int *tmp ;
  int tmp___0 ;

  {
#line 171
  in_bk = (int8 *)vi->sptr;
#line 171
  cur_bk = vi->pos - 1;
#line 171
  itpt = vi->itpt + (1 << 16);
#line 173
  vl <<= 1;
#line 174
  in_bk += cur_bk;
  {
#line 175
  while (1) {
    while_continue: /* CIL Label */ ;
#line 175
    tmp___0 = count;
#line 175
    count --;
#line 175
    if (! tmp___0) {
#line 175
      goto while_break;
    }
    {
#line 175
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 175
      smp_in = (int )*(in_bk + (itpt >> 16));
#line 175
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 175
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 175
      tmp = tmp_bk;
#line 175
      tmp_bk ++;
#line 175
      *tmp += smp_in * vl;
#line 175
      itpt += itpt_inc;
#line 175
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 176
  return;
}
}
#line 181 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/player/mix_all.c"
void smix_mn16norm(struct voice_info *vi , int *tmp_bk , int count , int vl , int vr ,
                   int itpt_inc ) 
{ 
  register int smp_in ;
  int16 *in_bk ;
  int cur_bk ;
  int itpt ;
  int *tmp ;
  int tmp___0 ;

  {
#line 183
  in_bk = (int16 *)vi->sptr;
#line 183
  cur_bk = vi->pos - 1;
#line 183
  itpt = vi->itpt + (1 << 16);
#line 185
  vl >>= 7;
#line 186
  in_bk += cur_bk;
  {
#line 187
  while (1) {
    while_continue: /* CIL Label */ ;
#line 187
    tmp___0 = count;
#line 187
    count --;
#line 187
    if (! tmp___0) {
#line 187
      goto while_break;
    }
    {
#line 187
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 187
      smp_in = (int )*(in_bk + (itpt >> 16));
#line 187
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 187
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 187
      tmp = tmp_bk;
#line 187
      tmp_bk ++;
#line 187
      *tmp += smp_in * vl;
#line 187
      itpt += itpt_inc;
#line 187
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 188
  return;
}
}
#line 196 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/player/mix_all.c"
void smix_st8itpt_flt(struct voice_info *vi , int *tmp_bk , int count , int vl , int vr ,
                      int itpt_inc ) 
{ 
  register int smp_in ;
  int8 *in_bk ;
  int cur_bk ;
  int itpt ;
  int smp_x1 ;
  int smp_dt ;
  int fx1 ;
  int fx2 ;
  int a ;
  int *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;

  {
#line 198
  in_bk = (int8 *)vi->sptr;
#line 198
  cur_bk = vi->pos - 1;
#line 198
  itpt = vi->itpt + (1 << 16);
#line 198
  smp_x1 = 0;
#line 198
  smp_dt = 0;
#line 199
  fx1 = vi->flt_X1;
#line 199
  fx2 = vi->flt_X2;
  {
#line 201
  while (1) {
    while_continue: /* CIL Label */ ;
#line 201
    tmp___3 = count;
#line 201
    count --;
#line 201
    if (! tmp___3) {
#line 201
      goto while_break;
    }
    {
#line 201
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 201
      if (itpt >> 16) {
#line 201
        cur_bk += itpt >> 16;
#line 201
        smp_x1 = (int )*(in_bk + cur_bk);
#line 201
        smp_dt = (int )*(in_bk + (cur_bk + 1)) - smp_x1;
#line 201
        itpt &= 65535;
      }
#line 201
      smp_in = smp_x1 + (itpt * smp_dt >> 16);
#line 201
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 201
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 201
      smp_in = ((smp_in * vi->flt_B0 + fx1 * vi->flt_B1) + fx2 * vi->flt_B2) / (1 << 12);
#line 201
      fx2 = fx1;
#line 201
      fx1 = smp_in;
#line 201
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 201
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 201
      if (vi->attack) {
#line 201
        a = 64 - vi->attack;
#line 201
        tmp = tmp_bk;
#line 201
        tmp_bk ++;
#line 201
        *tmp += ((smp_in * vr) * a) / 64;
#line 201
        tmp___0 = tmp_bk;
#line 201
        tmp_bk ++;
#line 201
        *tmp___0 += ((smp_in * vl) * a) / 64;
#line 201
        (vi->attack) --;
      } else {
#line 201
        tmp___1 = tmp_bk;
#line 201
        tmp_bk ++;
#line 201
        *tmp___1 += smp_in * vr;
#line 201
        tmp___2 = tmp_bk;
#line 201
        tmp_bk ++;
#line 201
        *tmp___2 += smp_in * vl;
      }
#line 201
      itpt += itpt_inc;
#line 201
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 202
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 202
    vi->flt_X1 = fx1;
#line 202
    vi->flt_X2 = fx2;
#line 202
    goto while_break___3;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 203
  return;
}
}
#line 208 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/player/mix_all.c"
void smix_st16itpt_flt(struct voice_info *vi , int *tmp_bk , int count , int vl ,
                       int vr , int itpt_inc ) 
{ 
  register int smp_in ;
  int16 *in_bk ;
  int cur_bk ;
  int itpt ;
  int smp_x1 ;
  int smp_dt ;
  int fx1 ;
  int fx2 ;
  int a ;
  int *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;

  {
#line 210
  in_bk = (int16 *)vi->sptr;
#line 210
  cur_bk = vi->pos - 1;
#line 210
  itpt = vi->itpt + (1 << 16);
#line 210
  smp_x1 = 0;
#line 210
  smp_dt = 0;
#line 211
  fx1 = vi->flt_X1;
#line 211
  fx2 = vi->flt_X2;
#line 213
  vl >>= 8;
#line 214
  vr >>= 8;
  {
#line 215
  while (1) {
    while_continue: /* CIL Label */ ;
#line 215
    tmp___3 = count;
#line 215
    count --;
#line 215
    if (! tmp___3) {
#line 215
      goto while_break;
    }
    {
#line 215
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 215
      if (itpt >> 16) {
#line 215
        cur_bk += itpt >> 16;
#line 215
        smp_x1 = (int )*(in_bk + cur_bk);
#line 215
        smp_dt = (int )*(in_bk + (cur_bk + 1)) - smp_x1;
#line 215
        itpt &= 65535;
      }
#line 215
      smp_in = smp_x1 + (itpt * smp_dt >> 16);
#line 215
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 215
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 215
      smp_in = ((smp_in * vi->flt_B0 + fx1 * vi->flt_B1) + fx2 * vi->flt_B2) / (1 << 12);
#line 215
      fx2 = fx1;
#line 215
      fx1 = smp_in;
#line 215
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 215
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 215
      if (vi->attack) {
#line 215
        a = 64 - vi->attack;
#line 215
        tmp = tmp_bk;
#line 215
        tmp_bk ++;
#line 215
        *tmp += ((smp_in * vr) * a) / 64;
#line 215
        tmp___0 = tmp_bk;
#line 215
        tmp_bk ++;
#line 215
        *tmp___0 += ((smp_in * vl) * a) / 64;
#line 215
        (vi->attack) --;
      } else {
#line 215
        tmp___1 = tmp_bk;
#line 215
        tmp_bk ++;
#line 215
        *tmp___1 += smp_in * vr;
#line 215
        tmp___2 = tmp_bk;
#line 215
        tmp_bk ++;
#line 215
        *tmp___2 += smp_in * vl;
      }
#line 215
      itpt += itpt_inc;
#line 215
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 216
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 216
    vi->flt_X1 = fx1;
#line 216
    vi->flt_X2 = fx2;
#line 216
    goto while_break___3;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 217
  return;
}
}
#line 222 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/player/mix_all.c"
void smix_mn8itpt_flt(struct voice_info *vi , int *tmp_bk , int count , int vl , int vr ,
                      int itpt_inc ) 
{ 
  register int smp_in ;
  int8 *in_bk ;
  int cur_bk ;
  int itpt ;
  int smp_x1 ;
  int smp_dt ;
  int fx1 ;
  int fx2 ;
  int *tmp ;
  int *tmp___0 ;
  int tmp___1 ;

  {
#line 224
  in_bk = (int8 *)vi->sptr;
#line 224
  cur_bk = vi->pos - 1;
#line 224
  itpt = vi->itpt + (1 << 16);
#line 224
  smp_x1 = 0;
#line 224
  smp_dt = 0;
#line 225
  fx1 = vi->flt_X1;
#line 225
  fx2 = vi->flt_X2;
#line 227
  vl <<= 1;
  {
#line 228
  while (1) {
    while_continue: /* CIL Label */ ;
#line 228
    tmp___1 = count;
#line 228
    count --;
#line 228
    if (! tmp___1) {
#line 228
      goto while_break;
    }
    {
#line 228
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 228
      if (itpt >> 16) {
#line 228
        cur_bk += itpt >> 16;
#line 228
        smp_x1 = (int )*(in_bk + cur_bk);
#line 228
        smp_dt = (int )*(in_bk + (cur_bk + 1)) - smp_x1;
#line 228
        itpt &= 65535;
      }
#line 228
      smp_in = smp_x1 + (itpt * smp_dt >> 16);
#line 228
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 228
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 228
      smp_in = ((smp_in * vi->flt_B0 + fx1 * vi->flt_B1) + fx2 * vi->flt_B2) / (1 << 12);
#line 228
      fx2 = fx1;
#line 228
      fx1 = smp_in;
#line 228
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 228
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 228
      if (vi->attack) {
#line 228
        tmp = tmp_bk;
#line 228
        tmp_bk ++;
#line 228
        *tmp += ((smp_in * vl) * (64 - vi->attack)) / 64;
#line 228
        (vi->attack) --;
      } else {
#line 228
        tmp___0 = tmp_bk;
#line 228
        tmp_bk ++;
#line 228
        *tmp___0 += smp_in * vl;
      }
#line 228
      itpt += itpt_inc;
#line 228
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 229
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 229
    vi->flt_X1 = fx1;
#line 229
    vi->flt_X2 = fx2;
#line 229
    goto while_break___3;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 230
  return;
}
}
#line 235 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/player/mix_all.c"
void smix_mn16itpt_flt(struct voice_info *vi , int *tmp_bk , int count , int vl ,
                       int vr , int itpt_inc ) 
{ 
  register int smp_in ;
  int16 *in_bk ;
  int cur_bk ;
  int itpt ;
  int smp_x1 ;
  int smp_dt ;
  int fx1 ;
  int fx2 ;
  int *tmp ;
  int *tmp___0 ;
  int tmp___1 ;

  {
#line 237
  in_bk = (int16 *)vi->sptr;
#line 237
  cur_bk = vi->pos - 1;
#line 237
  itpt = vi->itpt + (1 << 16);
#line 237
  smp_x1 = 0;
#line 237
  smp_dt = 0;
#line 238
  fx1 = vi->flt_X1;
#line 238
  fx2 = vi->flt_X2;
#line 240
  vl >>= 7;
  {
#line 241
  while (1) {
    while_continue: /* CIL Label */ ;
#line 241
    tmp___1 = count;
#line 241
    count --;
#line 241
    if (! tmp___1) {
#line 241
      goto while_break;
    }
    {
#line 241
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 241
      if (itpt >> 16) {
#line 241
        cur_bk += itpt >> 16;
#line 241
        smp_x1 = (int )*(in_bk + cur_bk);
#line 241
        smp_dt = (int )*(in_bk + (cur_bk + 1)) - smp_x1;
#line 241
        itpt &= 65535;
      }
#line 241
      smp_in = smp_x1 + (itpt * smp_dt >> 16);
#line 241
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 241
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 241
      smp_in = ((smp_in * vi->flt_B0 + fx1 * vi->flt_B1) + fx2 * vi->flt_B2) / (1 << 12);
#line 241
      fx2 = fx1;
#line 241
      fx1 = smp_in;
#line 241
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 241
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 241
      if (vi->attack) {
#line 241
        tmp = tmp_bk;
#line 241
        tmp_bk ++;
#line 241
        *tmp += ((smp_in * vl) * (64 - vi->attack)) / 64;
#line 241
        (vi->attack) --;
      } else {
#line 241
        tmp___0 = tmp_bk;
#line 241
        tmp_bk ++;
#line 241
        *tmp___0 += smp_in * vl;
      }
#line 241
      itpt += itpt_inc;
#line 241
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 242
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 242
    vi->flt_X1 = fx1;
#line 242
    vi->flt_X2 = fx2;
#line 242
    goto while_break___3;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 243
  return;
}
}
#line 248 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/player/mix_all.c"
void smix_synth(struct voice_info *vi , int *tmp_bk , int count , int vl , int vr ,
                int itpt_inc ) 
{ 


  {
  {
#line 250
  synth_mixer(tmp_bk, count, vl >> 7, vr >> 7, itpt_inc);
  }
#line 251
  return;
}
}
#line 143 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/player/fmopl.h"
FM_OPL *OPLCreate(int type , int clock , int rate ) ;
#line 144
void OPLDestroy(FM_OPL *OPL ) ;
#line 152
void OPLResetChip(FM_OPL *OPL ) ;
#line 153
int OPLWrite(FM_OPL *OPL , int a , int v ) ;
#line 154
unsigned char OPLRead(FM_OPL *OPL , int a ) ;
#line 158
void YM3812UpdateOne(FM_OPL *OPL , FMSAMPLE *bk , int len , int vl , int vr , int st ) ;
#line 22 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/player/synth.c"
static FM_OPL *ym3812  ;
#line 72 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/player/synth.c"
static int register_base[11]  = 
#line 72
  {      32,      32,      64,      64, 
        96,      96,      128,      128, 
        224,      224,      192};
#line 78 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/player/synth.c"
static int register_offset[2][9]  = { {        0,        1,        2,        8, 
            9,        10,        16,        17, 
            18}, 
   {        3,        4,        5,        11, 
            12,        13,        19,        20, 
            21}};
#line 104 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/player/synth.c"
static int ym3812_note[13]  = 
#line 104
  {      343,      363,      385,      408, 
        432,      458,      485,      514, 
        544,      577,      611,      647, 
        686};
#line 111 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/player/synth.c"
static int voc2ch[9]  ;
#line 131 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/player/synth.c"
__inline static int opl_write(int a , int v ) 
{ 
  int tmp ;

  {
  {
#line 140
  OPLWrite(ym3812, 0, a);
#line 141
  tmp = OPLWrite(ym3812, 1, v);
  }
#line 141
  return (tmp);
}
}
#line 146 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/player/synth.c"
__inline static uint8 opl_read(int a ) 
{ 
  unsigned char tmp ;

  {
  {
#line 157
  OPLWrite(ym3812, 0, a);
#line 158
  tmp = OPLRead(ym3812, 1);
  }
#line 158
  return (tmp);
}
}
#line 163 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/player/synth.c"
static int synth_getchannel(int c___0 ) 
{ 
  int i___3 ;
  int free___0 ;

  {
#line 165
  free___0 = -1;
#line 167
  c___0 ++;
#line 167
  i___3 = 0;
  {
#line 167
  while (1) {
    while_continue: /* CIL Label */ ;
#line 167
    if (! (i___3 < 9)) {
#line 167
      goto while_break;
    }
#line 168
    if (voc2ch[i___3] == c___0) {
#line 169
      return (i___3);
    }
#line 172
    if (voc2ch[i___3] == 0) {
#line 173
      free___0 = i___3;
#line 174
      goto while_break;
    }
#line 167
    i___3 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 177
  if (free___0 != -1) {
#line 178
    voc2ch[free___0] = c___0;
  }
#line 180
  return (free___0);
}
}
#line 184 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/player/synth.c"
void synth_chreset(void) 
{ 
  int i___3 ;
  int tmp ;

  {
#line 188
  i___3 = 9;
  {
#line 188
  while (1) {
    while_continue: /* CIL Label */ ;
#line 188
    tmp = i___3;
#line 188
    i___3 --;
#line 188
    if (! tmp) {
#line 188
      goto while_break;
    }
#line 189
    voc2ch[i___3] = 0;
  }
  while_break: /* CIL Label */ ;
  }
#line 190
  return;
}
}
#line 193 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/player/synth.c"
void synth_setpatch(int c___0 , uint8 *data ) 
{ 
  int i___3 ;
  int x ;
  uint8 tmp ;

  {
  {
#line 197
  c___0 = synth_getchannel(c___0);
  }
#line 197
  if (c___0 < 0) {
#line 198
    return;
  }
#line 200
  i___3 = 0;
  {
#line 200
  while (1) {
    while_continue: /* CIL Label */ ;
#line 200
    if (! (i___3 < 10)) {
#line 200
      goto while_break;
    }
    {
#line 201
    opl_write(register_base[i___3] + register_offset[i___3 % 2][c___0], (int )*(data + i___3));
#line 200
    i___3 ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 202
  opl_write(register_base[10] + c___0, (int )*(data + 10));
#line 204
  tmp = opl_read(176 + c___0);
#line 204
  x = (int )tmp;
#line 205
  opl_write(176 + c___0, x & -33);
  }
#line 206
  return;
}
}
#line 228 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/player/synth.c"
void synth_setnote(int c___0 , int note , int bend ) 
{ 
  int n___0 ;
  int f ;
  int o___0 ;

  {
  {
#line 232
  c___0 = synth_getchannel(c___0);
  }
#line 232
  if (c___0 < 0) {
#line 233
    return;
  }
#line 235
  n___0 = note % 12;
#line 236
  f = ym3812_note[n___0] + ((ym3812_note[n___0 + 1] - ym3812_note[n___0]) * bend) / 100;
#line 237
  o___0 = note / 12 - 1;
#line 239
  if (o___0 < 0) {
#line 240
    o___0 = 0;
  }
  {
#line 242
  opl_write(160 + c___0, f & 255);
#line 243
  opl_write(176 + c___0, (32 | ((o___0 << 2) & 28)) | ((f >> 8) & 3));
  }
#line 244
  return;
}
}
#line 247 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/player/synth.c"
void synth_setvol(int c___0 , int vol ) 
{ 
  int b___1 ;
  int ofs ;
  uint8 tmp ;
  uint8 tmp___0 ;
  uint8 tmp___1 ;

  {
  {
#line 251
  c___0 = synth_getchannel(c___0);
  }
#line 251
  if (c___0 < 0) {
#line 252
    return;
  }
#line 254
  if (vol > 63) {
#line 255
    vol = 63;
  }
  {
#line 258
  tmp___0 = opl_read(200 + c___0);
  }
#line 258
  if (tmp___0) {
    {
#line 259
    ofs = register_offset[0][c___0];
#line 260
    tmp = opl_read(64 + ofs);
#line 260
    b___1 = (int )tmp;
#line 261
    opl_write(64 + ofs, (b___1 & 192) | (63 - vol));
    }
  }
  {
#line 264
  ofs = register_offset[1][c___0];
#line 265
  tmp___1 = opl_read(64 + ofs);
#line 265
  b___1 = (int )tmp___1;
#line 266
  opl_write(64 + ofs, (b___1 & 192) | (63 - vol));
  }
#line 267
  return;
}
}
#line 270 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/player/synth.c"
int synth_init(int freq ) 
{ 


  {
  {
#line 275
  synth_chreset();
#line 277
  ym3812 = OPLCreate(8, 3579545, freq);
  }
#line 277
  return ((unsigned long )ym3812 != (unsigned long )((void *)0));
}
}
#line 281 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/player/synth.c"
int synth_reset(void) 
{ 


  {
  {
#line 289
  OPLResetChip(ym3812);
#line 291
  synth_chreset();
  }
#line 293
  return (0);
}
}
#line 297 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/player/synth.c"
int synth_deinit(void) 
{ 


  {
  {
#line 299
  synth_reset();
#line 300
  OPLDestroy(ym3812);
  }
#line 302
  return (0);
}
}
#line 306 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/player/synth.c"
void synth_mixer(int *tmp_bk , int count , int vl , int vr , int stereo ) 
{ 


  {
#line 308
  if (! tmp_bk) {
#line 309
    return;
  }
  {
#line 311
  YM3812UpdateOne(ym3812, tmp_bk, count, vl, vr, stereo);
  }
#line 312
  return;
}
}
#line 66 "/usr/include/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) double sin(double __x ) ;
#line 113
extern  __attribute__((__nothrow__)) double log10(double __x ) ;
#line 154
extern  __attribute__((__nothrow__)) double pow(double __x , double __y ) ;
#line 145 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/player/fmopl.h"
void OPLSetTimerHandler(FM_OPL *OPL , void (*TimerHandler)(int channel , double interval_Sec ) ,
                        int channelOffset ) ;
#line 146
void OPLSetIRQHandler(FM_OPL *OPL , void (*IRQHandler)(int param , int irq ) , int param ) ;
#line 147
void OPLSetUpdateHandler(FM_OPL *OPL , void (*UpdateHandler)(int param , int min_interval_us ) ,
                         int param ) ;
#line 155
int OPLTimerOver(FM_OPL *OPL , int c___0 ) ;
#line 96 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/player/fmopl.c"
static int const   slot_array[32]  = 
#line 96 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/player/fmopl.c"
  {      (int const   )0,      (int const   )2,      (int const   )4,      (int const   )1, 
        (int const   )3,      (int const   )5,      (int const   )-1,      (int const   )-1, 
        (int const   )6,      (int const   )8,      (int const   )10,      (int const   )7, 
        (int const   )9,      (int const   )11,      (int const   )-1,      (int const   )-1, 
        (int const   )12,      (int const   )14,      (int const   )16,      (int const   )13, 
        (int const   )15,      (int const   )17,      (int const   )-1,      (int const   )-1, 
        (int const   )-1,      (int const   )-1,      (int const   )-1,      (int const   )-1, 
        (int const   )-1,      (int const   )-1,      (int const   )-1,      (int const   )-1};
#line 106 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/player/fmopl.c"
static UINT32 const   KSL_TABLE[128]  = 
#line 106
  {      (UINT32 const   )(0.000 * ((0.1875 * (double )2) / (96.0 / (double )4096))),      (UINT32 const   )(0.000 * ((0.1875 * (double )2) / (96.0 / (double )4096))),      (UINT32 const   )(0.000 * ((0.1875 * (double )2) / (96.0 / (double )4096))),      (UINT32 const   )(0.000 * ((0.1875 * (double )2) / (96.0 / (double )4096))), 
        (UINT32 const   )(0.000 * ((0.1875 * (double )2) / (96.0 / (double )4096))),      (UINT32 const   )(0.000 * ((0.1875 * (double )2) / (96.0 / (double )4096))),      (UINT32 const   )(0.000 * ((0.1875 * (double )2) / (96.0 / (double )4096))),      (UINT32 const   )(0.000 * ((0.1875 * (double )2) / (96.0 / (double )4096))), 
        (UINT32 const   )(0.000 * ((0.1875 * (double )2) / (96.0 / (double )4096))),      (UINT32 const   )(0.000 * ((0.1875 * (double )2) / (96.0 / (double )4096))),      (UINT32 const   )(0.000 * ((0.1875 * (double )2) / (96.0 / (double )4096))),      (UINT32 const   )(0.000 * ((0.1875 * (double )2) / (96.0 / (double )4096))), 
        (UINT32 const   )(0.000 * ((0.1875 * (double )2) / (96.0 / (double )4096))),      (UINT32 const   )(0.000 * ((0.1875 * (double )2) / (96.0 / (double )4096))),      (UINT32 const   )(0.000 * ((0.1875 * (double )2) / (96.0 / (double )4096))),      (UINT32 const   )(0.000 * ((0.1875 * (double )2) / (96.0 / (double )4096))), 
        (UINT32 const   )(0.000 * ((0.1875 * (double )2) / (96.0 / (double )4096))),      (UINT32 const   )(0.000 * ((0.1875 * (double )2) / (96.0 / (double )4096))),      (UINT32 const   )(0.000 * ((0.1875 * (double )2) / (96.0 / (double )4096))),      (UINT32 const   )(0.000 * ((0.1875 * (double )2) / (96.0 / (double )4096))), 
        (UINT32 const   )(0.000 * ((0.1875 * (double )2) / (96.0 / (double )4096))),      (UINT32 const   )(0.000 * ((0.1875 * (double )2) / (96.0 / (double )4096))),      (UINT32 const   )(0.000 * ((0.1875 * (double )2) / (96.0 / (double )4096))),      (UINT32 const   )(0.000 * ((0.1875 * (double )2) / (96.0 / (double )4096))), 
        (UINT32 const   )(0.000 * ((0.1875 * (double )2) / (96.0 / (double )4096))),      (UINT32 const   )(0.750 * ((0.1875 * (double )2) / (96.0 / (double )4096))),      (UINT32 const   )(1.125 * ((0.1875 * (double )2) / (96.0 / (double )4096))),      (UINT32 const   )(1.500 * ((0.1875 * (double )2) / (96.0 / (double )4096))), 
        (UINT32 const   )(1.875 * ((0.1875 * (double )2) / (96.0 / (double )4096))),      (UINT32 const   )(2.250 * ((0.1875 * (double )2) / (96.0 / (double )4096))),      (UINT32 const   )(2.625 * ((0.1875 * (double )2) / (96.0 / (double )4096))),      (UINT32 const   )(3.000 * ((0.1875 * (double )2) / (96.0 / (double )4096))), 
        (UINT32 const   )(0.000 * ((0.1875 * (double )2) / (96.0 / (double )4096))),      (UINT32 const   )(0.000 * ((0.1875 * (double )2) / (96.0 / (double )4096))),      (UINT32 const   )(0.000 * ((0.1875 * (double )2) / (96.0 / (double )4096))),      (UINT32 const   )(0.000 * ((0.1875 * (double )2) / (96.0 / (double )4096))), 
        (UINT32 const   )(0.000 * ((0.1875 * (double )2) / (96.0 / (double )4096))),      (UINT32 const   )(1.125 * ((0.1875 * (double )2) / (96.0 / (double )4096))),      (UINT32 const   )(1.875 * ((0.1875 * (double )2) / (96.0 / (double )4096))),      (UINT32 const   )(2.625 * ((0.1875 * (double )2) / (96.0 / (double )4096))), 
        (UINT32 const   )(3.000 * ((0.1875 * (double )2) / (96.0 / (double )4096))),      (UINT32 const   )(3.750 * ((0.1875 * (double )2) / (96.0 / (double )4096))),      (UINT32 const   )(4.125 * ((0.1875 * (double )2) / (96.0 / (double )4096))),      (UINT32 const   )(4.500 * ((0.1875 * (double )2) / (96.0 / (double )4096))), 
        (UINT32 const   )(4.875 * ((0.1875 * (double )2) / (96.0 / (double )4096))),      (UINT32 const   )(5.250 * ((0.1875 * (double )2) / (96.0 / (double )4096))),      (UINT32 const   )(5.625 * ((0.1875 * (double )2) / (96.0 / (double )4096))),      (UINT32 const   )(6.000 * ((0.1875 * (double )2) / (96.0 / (double )4096))), 
        (UINT32 const   )(0.000 * ((0.1875 * (double )2) / (96.0 / (double )4096))),      (UINT32 const   )(0.000 * ((0.1875 * (double )2) / (96.0 / (double )4096))),      (UINT32 const   )(0.000 * ((0.1875 * (double )2) / (96.0 / (double )4096))),      (UINT32 const   )(1.875 * ((0.1875 * (double )2) / (96.0 / (double )4096))), 
        (UINT32 const   )(3.000 * ((0.1875 * (double )2) / (96.0 / (double )4096))),      (UINT32 const   )(4.125 * ((0.1875 * (double )2) / (96.0 / (double )4096))),      (UINT32 const   )(4.875 * ((0.1875 * (double )2) / (96.0 / (double )4096))),      (UINT32 const   )(5.625 * ((0.1875 * (double )2) / (96.0 / (double )4096))), 
        (UINT32 const   )(6.000 * ((0.1875 * (double )2) / (96.0 / (double )4096))),      (UINT32 const   )(6.750 * ((0.1875 * (double )2) / (96.0 / (double )4096))),      (UINT32 const   )(7.125 * ((0.1875 * (double )2) / (96.0 / (double )4096))),      (UINT32 const   )(7.500 * ((0.1875 * (double )2) / (96.0 / (double )4096))), 
        (UINT32 const   )(7.875 * ((0.1875 * (double )2) / (96.0 / (double )4096))),      (UINT32 const   )(8.250 * ((0.1875 * (double )2) / (96.0 / (double )4096))),      (UINT32 const   )(8.625 * ((0.1875 * (double )2) / (96.0 / (double )4096))),      (UINT32 const   )(9.000 * ((0.1875 * (double )2) / (96.0 / (double )4096))), 
        (UINT32 const   )(0.000 * ((0.1875 * (double )2) / (96.0 / (double )4096))),      (UINT32 const   )(0.000 * ((0.1875 * (double )2) / (96.0 / (double )4096))),      (UINT32 const   )(3.000 * ((0.1875 * (double )2) / (96.0 / (double )4096))),      (UINT32 const   )(4.875 * ((0.1875 * (double )2) / (96.0 / (double )4096))), 
        (UINT32 const   )(6.000 * ((0.1875 * (double )2) / (96.0 / (double )4096))),      (UINT32 const   )(7.125 * ((0.1875 * (double )2) / (96.0 / (double )4096))),      (UINT32 const   )(7.875 * ((0.1875 * (double )2) / (96.0 / (double )4096))),      (UINT32 const   )(8.625 * ((0.1875 * (double )2) / (96.0 / (double )4096))), 
        (UINT32 const   )(9.000 * ((0.1875 * (double )2) / (96.0 / (double )4096))),      (UINT32 const   )(9.750 * ((0.1875 * (double )2) / (96.0 / (double )4096))),      (UINT32 const   )(10.125 * ((0.1875 * (double )2) / (96.0 / (double )4096))),      (UINT32 const   )(10.500 * ((0.1875 * (double )2) / (96.0 / (double )4096))), 
        (UINT32 const   )(10.875 * ((0.1875 * (double )2) / (96.0 / (double )4096))),      (UINT32 const   )(11.250 * ((0.1875 * (double )2) / (96.0 / (double )4096))),      (UINT32 const   )(11.625 * ((0.1875 * (double )2) / (96.0 / (double )4096))),      (UINT32 const   )(12.000 * ((0.1875 * (double )2) / (96.0 / (double )4096))), 
        (UINT32 const   )(0.000 * ((0.1875 * (double )2) / (96.0 / (double )4096))),      (UINT32 const   )(3.000 * ((0.1875 * (double )2) / (96.0 / (double )4096))),      (UINT32 const   )(6.000 * ((0.1875 * (double )2) / (96.0 / (double )4096))),      (UINT32 const   )(7.875 * ((0.1875 * (double )2) / (96.0 / (double )4096))), 
        (UINT32 const   )(9.000 * ((0.1875 * (double )2) / (96.0 / (double )4096))),      (UINT32 const   )(10.125 * ((0.1875 * (double )2) / (96.0 / (double )4096))),      (UINT32 const   )(10.875 * ((0.1875 * (double )2) / (96.0 / (double )4096))),      (UINT32 const   )(11.625 * ((0.1875 * (double )2) / (96.0 / (double )4096))), 
        (UINT32 const   )(12.000 * ((0.1875 * (double )2) / (96.0 / (double )4096))),      (UINT32 const   )(12.750 * ((0.1875 * (double )2) / (96.0 / (double )4096))),      (UINT32 const   )(13.125 * ((0.1875 * (double )2) / (96.0 / (double )4096))),      (UINT32 const   )(13.500 * ((0.1875 * (double )2) / (96.0 / (double )4096))), 
        (UINT32 const   )(13.875 * ((0.1875 * (double )2) / (96.0 / (double )4096))),      (UINT32 const   )(14.250 * ((0.1875 * (double )2) / (96.0 / (double )4096))),      (UINT32 const   )(14.625 * ((0.1875 * (double )2) / (96.0 / (double )4096))),      (UINT32 const   )(15.000 * ((0.1875 * (double )2) / (96.0 / (double )4096))), 
        (UINT32 const   )(0.000 * ((0.1875 * (double )2) / (96.0 / (double )4096))),      (UINT32 const   )(6.000 * ((0.1875 * (double )2) / (96.0 / (double )4096))),      (UINT32 const   )(9.000 * ((0.1875 * (double )2) / (96.0 / (double )4096))),      (UINT32 const   )(10.875 * ((0.1875 * (double )2) / (96.0 / (double )4096))), 
        (UINT32 const   )(12.000 * ((0.1875 * (double )2) / (96.0 / (double )4096))),      (UINT32 const   )(13.125 * ((0.1875 * (double )2) / (96.0 / (double )4096))),      (UINT32 const   )(13.875 * ((0.1875 * (double )2) / (96.0 / (double )4096))),      (UINT32 const   )(14.625 * ((0.1875 * (double )2) / (96.0 / (double )4096))), 
        (UINT32 const   )(15.000 * ((0.1875 * (double )2) / (96.0 / (double )4096))),      (UINT32 const   )(15.750 * ((0.1875 * (double )2) / (96.0 / (double )4096))),      (UINT32 const   )(16.125 * ((0.1875 * (double )2) / (96.0 / (double )4096))),      (UINT32 const   )(16.500 * ((0.1875 * (double )2) / (96.0 / (double )4096))), 
        (UINT32 const   )(16.875 * ((0.1875 * (double )2) / (96.0 / (double )4096))),      (UINT32 const   )(17.250 * ((0.1875 * (double )2) / (96.0 / (double )4096))),      (UINT32 const   )(17.625 * ((0.1875 * (double )2) / (96.0 / (double )4096))),      (UINT32 const   )(18.000 * ((0.1875 * (double )2) / (96.0 / (double )4096))), 
        (UINT32 const   )(0.000 * ((0.1875 * (double )2) / (96.0 / (double )4096))),      (UINT32 const   )(9.000 * ((0.1875 * (double )2) / (96.0 / (double )4096))),      (UINT32 const   )(12.000 * ((0.1875 * (double )2) / (96.0 / (double )4096))),      (UINT32 const   )(13.875 * ((0.1875 * (double )2) / (96.0 / (double )4096))), 
        (UINT32 const   )(15.000 * ((0.1875 * (double )2) / (96.0 / (double )4096))),      (UINT32 const   )(16.125 * ((0.1875 * (double )2) / (96.0 / (double )4096))),      (UINT32 const   )(16.875 * ((0.1875 * (double )2) / (96.0 / (double )4096))),      (UINT32 const   )(17.625 * ((0.1875 * (double )2) / (96.0 / (double )4096))), 
        (UINT32 const   )(18.000 * ((0.1875 * (double )2) / (96.0 / (double )4096))),      (UINT32 const   )(18.750 * ((0.1875 * (double )2) / (96.0 / (double )4096))),      (UINT32 const   )(19.125 * ((0.1875 * (double )2) / (96.0 / (double )4096))),      (UINT32 const   )(19.500 * ((0.1875 * (double )2) / (96.0 / (double )4096))), 
        (UINT32 const   )(19.875 * ((0.1875 * (double )2) / (96.0 / (double )4096))),      (UINT32 const   )(20.250 * ((0.1875 * (double )2) / (96.0 / (double )4096))),      (UINT32 const   )(20.625 * ((0.1875 * (double )2) / (96.0 / (double )4096))),      (UINT32 const   )(21.000 * ((0.1875 * (double )2) / (96.0 / (double )4096)))};
#line 154 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/player/fmopl.c"
static INT32 const   SL_TABLE[16]  = 
#line 154
  {      (INT32 const   )((double )0 * (((double )3 / (96.0 / (double )4096)) * (double )(1 << 16)) + (double )(4096 << 16)),      (INT32 const   )((double )1 * (((double )3 / (96.0 / (double )4096)) * (double )(1 << 16)) + (double )(4096 << 16)),      (INT32 const   )((double )2 * (((double )3 / (96.0 / (double )4096)) * (double )(1 << 16)) + (double )(4096 << 16)),      (INT32 const   )((double )3 * (((double )3 / (96.0 / (double )4096)) * (double )(1 << 16)) + (double )(4096 << 16)), 
        (INT32 const   )((double )4 * (((double )3 / (96.0 / (double )4096)) * (double )(1 << 16)) + (double )(4096 << 16)),      (INT32 const   )((double )5 * (((double )3 / (96.0 / (double )4096)) * (double )(1 << 16)) + (double )(4096 << 16)),      (INT32 const   )((double )6 * (((double )3 / (96.0 / (double )4096)) * (double )(1 << 16)) + (double )(4096 << 16)),      (INT32 const   )((double )7 * (((double )3 / (96.0 / (double )4096)) * (double )(1 << 16)) + (double )(4096 << 16)), 
        (INT32 const   )((double )8 * (((double )3 / (96.0 / (double )4096)) * (double )(1 << 16)) + (double )(4096 << 16)),      (INT32 const   )((double )9 * (((double )3 / (96.0 / (double )4096)) * (double )(1 << 16)) + (double )(4096 << 16)),      (INT32 const   )((double )10 * (((double )3 / (96.0 / (double )4096)) * (double )(1 << 16)) + (double )(4096 << 16)),      (INT32 const   )((double )11 * (((double )3 / (96.0 / (double )4096)) * (double )(1 << 16)) + (double )(4096 << 16)), 
        (INT32 const   )((double )12 * (((double )3 / (96.0 / (double )4096)) * (double )(1 << 16)) + (double )(4096 << 16)),      (INT32 const   )((double )13 * (((double )3 / (96.0 / (double )4096)) * (double )(1 << 16)) + (double )(4096 << 16)),      (INT32 const   )((double )14 * (((double )3 / (96.0 / (double )4096)) * (double )(1 << 16)) + (double )(4096 << 16)),      (INT32 const   )((double )31 * (((double )3 / (96.0 / (double )4096)) * (double )(1 << 16)) + (double )(4096 << 16))};
#line 164 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/player/fmopl.c"
static INT32 *TL_TABLE  ;
#line 167 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/player/fmopl.c"
static INT32 **SIN_TABLE  ;
#line 170 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/player/fmopl.c"
static INT32 *AMS_TABLE  ;
#line 171 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/player/fmopl.c"
static INT32 *VIB_TABLE  ;
#line 175 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/player/fmopl.c"
static INT32 ENV_CURVE[8193]  ;
#line 179 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/player/fmopl.c"
static UINT32 const   MUL_TABLE[16]  = 
#line 179
  {      (UINT32 const   )(0.50 * (double )2),      (UINT32 const   )(1.00 * (double )2),      (UINT32 const   )(2.00 * (double )2),      (UINT32 const   )(3.00 * (double )2), 
        (UINT32 const   )(4.00 * (double )2),      (UINT32 const   )(5.00 * (double )2),      (UINT32 const   )(6.00 * (double )2),      (UINT32 const   )(7.00 * (double )2), 
        (UINT32 const   )(8.00 * (double )2),      (UINT32 const   )(9.00 * (double )2),      (UINT32 const   )(10.00 * (double )2),      (UINT32 const   )(10.00 * (double )2), 
        (UINT32 const   )(12.00 * (double )2),      (UINT32 const   )(12.00 * (double )2),      (UINT32 const   )(15.00 * (double )2),      (UINT32 const   )(15.00 * (double )2)};
#line 187 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/player/fmopl.c"
static INT32 RATE_0[16]  = 
#line 187
  {      0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0};
#line 193 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/player/fmopl.c"
static int num_lock  =    0;
#line 196 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/player/fmopl.c"
static void *cur_chip  =    (void *)0;
#line 199 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/player/fmopl.c"
static OPL_CH *S_CH  ;
#line 200 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/player/fmopl.c"
static OPL_CH *E_CH  ;
#line 201 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/player/fmopl.c"
OPL_SLOT *SLOT7_1  ;
#line 201 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/player/fmopl.c"
OPL_SLOT *SLOT7_2  ;
#line 201 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/player/fmopl.c"
OPL_SLOT *SLOT8_1  ;
#line 201 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/player/fmopl.c"
OPL_SLOT *SLOT8_2  ;
#line 203 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/player/fmopl.c"
static INT32 outd[1]  ;
#line 204 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/player/fmopl.c"
static INT32 ams  ;
#line 205 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/player/fmopl.c"
static INT32 vib  ;
#line 206 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/player/fmopl.c"
INT32 *ams_table  ;
#line 207 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/player/fmopl.c"
INT32 *vib_table  ;
#line 208 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/player/fmopl.c"
static INT32 amsIncr  ;
#line 209 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/player/fmopl.c"
static INT32 vibIncr  ;
#line 210 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/player/fmopl.c"
static INT32 feedback2  ;
#line 219 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/player/fmopl.c"
static void Log(int level , char *format  , ...) 
{ 


  {
#line 229
  return;
}
}
#line 233 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/player/fmopl.c"
__inline static int Limit(int val , int max , int min ) 
{ 


  {
#line 234
  if (val > max) {
#line 235
    val = max;
  } else
#line 236
  if (val < min) {
#line 237
    val = min;
  }
#line 239
  return (val);
}
}
#line 243 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/player/fmopl.c"
__inline static void OPL_STATUS_SET(FM_OPL *OPL , int flag ) 
{ 


  {
#line 246
  OPL->status = (UINT8 )((int )OPL->status | flag);
#line 247
  if (! ((int )OPL->status & 128)) {
#line 249
    if ((int )OPL->status & (int )OPL->statusmask) {
#line 251
      OPL->status = (UINT8 )((int )OPL->status | 128);
#line 253
      if (OPL->IRQHandler) {
        {
#line 253
        (*(OPL->IRQHandler))(OPL->IRQParam, 1);
        }
      }
    }
  }
#line 256
  return;
}
}
#line 259 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/player/fmopl.c"
__inline static void OPL_STATUS_RESET(FM_OPL *OPL , int flag ) 
{ 


  {
#line 262
  OPL->status = (UINT8 )((int )OPL->status & ~ flag);
#line 263
  if ((int )OPL->status & 128) {
#line 265
    if (! ((int )OPL->status & (int )OPL->statusmask)) {
#line 267
      OPL->status = (UINT8 )((int )OPL->status & 127);
#line 269
      if (OPL->IRQHandler) {
        {
#line 269
        (*(OPL->IRQHandler))(OPL->IRQParam, 0);
        }
      }
    }
  }
#line 272
  return;
}
}
#line 275 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/player/fmopl.c"
__inline static void OPL_STATUSMASK_SET(FM_OPL *OPL , int flag ) 
{ 


  {
  {
#line 277
  OPL->statusmask = (UINT8 )flag;
#line 279
  OPL_STATUS_SET(OPL, 0);
#line 280
  OPL_STATUS_RESET(OPL, 0);
  }
#line 281
  return;
}
}
#line 284 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/player/fmopl.c"
__inline static void OPL_KEYON(OPL_SLOT *SLOT ) 
{ 


  {
#line 287
  SLOT->Cnt = (UINT32 )0;
#line 289
  SLOT->evm = (UINT8 )2;
#line 290
  SLOT->evs = SLOT->evsa;
#line 291
  SLOT->evc = 0;
#line 292
  SLOT->eve = 4096 << 16;
#line 293
  return;
}
}
#line 295 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/player/fmopl.c"
__inline static void OPL_KEYOFF(OPL_SLOT *SLOT ) 
{ 


  {
#line 297
  if ((int )SLOT->evm > 0) {
#line 300
    SLOT->evm = (UINT8 )0;
#line 301
    if (! (SLOT->evc & (4096 << 16))) {
#line 303
      SLOT->evc = 4096 << 16;
    }
#line 304
    SLOT->eve = 8192 << 16;
#line 305
    SLOT->evs = SLOT->evsr;
  }
#line 307
  return;
}
}
#line 311 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/player/fmopl.c"
__inline static UINT32 OPL_CALC_SLOT(OPL_SLOT *SLOT ) 
{ 
  INT32 tmp ;
  INT32 tmp___0 ;

  {
#line 314
  tmp = SLOT->evc + SLOT->evs;
#line 314
  SLOT->evc = tmp;
#line 314
  if (tmp >= SLOT->eve) {
    {
#line 317
    if ((int )SLOT->evm == 2) {
#line 317
      goto case_2;
    }
#line 324
    if ((int )SLOT->evm == 1) {
#line 324
      goto case_1;
    }
#line 337
    if ((int )SLOT->evm == 0) {
#line 337
      goto case_0;
    }
#line 316
    goto switch_break;
    case_2: /* CIL Label */ 
#line 319
    SLOT->evm = (UINT8 )1;
#line 320
    SLOT->evc = 4096 << 16;
#line 321
    SLOT->eve = SLOT->SL;
#line 322
    SLOT->evs = SLOT->evsd;
#line 323
    goto switch_break;
    case_1: /* CIL Label */ 
#line 325
    SLOT->evc = SLOT->SL;
#line 326
    SLOT->eve = 8192 << 16;
#line 327
    if (SLOT->eg_typ) {
#line 329
      SLOT->evs = 0;
    } else {
#line 333
      SLOT->evm = (UINT8 )0;
#line 334
      SLOT->evs = SLOT->evsr;
    }
#line 336
    goto switch_break;
    case_0: /* CIL Label */ 
#line 338
    SLOT->evc = 8192 << 16;
#line 339
    SLOT->eve = (8192 << 16) + 1;
#line 340
    SLOT->evs = 0;
#line 341
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
#line 345
  if (SLOT->ams) {
#line 345
    tmp___0 = ams;
  } else {
#line 345
    tmp___0 = 0;
  }
#line 345
  return ((UINT32 )((SLOT->TLL + ENV_CURVE[SLOT->evc >> 16]) + tmp___0));
}
}
#line 349 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/player/fmopl.c"
static void set_algorythm(OPL_CH *CH ) 
{ 
  INT32 *carrier ;

  {
#line 351
  carrier = & outd[0];
#line 352
  if (CH->CON) {
#line 352
    CH->connect1 = carrier;
  } else {
#line 352
    CH->connect1 = & feedback2;
  }
#line 353
  CH->connect2 = carrier;
#line 354
  return;
}
}
#line 357 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/player/fmopl.c"
__inline static void CALC_FCSLOT(OPL_CH *CH , OPL_SLOT *SLOT ) 
{ 
  int ksr ;

  {
#line 362
  SLOT->Incr = CH->fc * SLOT->mul;
#line 363
  ksr = (int )CH->kcode >> (int )SLOT->KSR;
#line 365
  if ((int )SLOT->ksr != ksr) {
#line 367
    SLOT->ksr = (UINT8 )ksr;
#line 369
    SLOT->evsa = *(SLOT->AR + ksr);
#line 370
    SLOT->evsd = *(SLOT->DR + ksr);
#line 371
    SLOT->evsr = *(SLOT->RR + ksr);
  }
#line 373
  SLOT->TLL = (INT32 )((UINT32 )SLOT->TL + (CH->ksl_base >> (int )SLOT->ksl));
#line 374
  return;
}
}
#line 377 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/player/fmopl.c"
__inline static void set_mul(FM_OPL *OPL , int slot , int v ) 
{ 
  OPL_CH *CH ;
  OPL_SLOT *SLOT ;

  {
#line 379
  CH = OPL->P_CH + slot / 2;
#line 380
  SLOT = & CH->SLOT[slot & 1];
#line 382
  SLOT->mul = (UINT32 )MUL_TABLE[v & 15];
#line 383
  if (v & 16) {
#line 383
    SLOT->KSR = (UINT8 )0;
  } else {
#line 383
    SLOT->KSR = (UINT8 )2;
  }
  {
#line 384
  SLOT->eg_typ = (UINT8 )((v & 32) >> 5);
#line 385
  SLOT->vib = (UINT8 )(v & 64);
#line 386
  SLOT->ams = (UINT8 )(v & 128);
#line 387
  CALC_FCSLOT(CH, SLOT);
  }
#line 388
  return;
}
}
#line 391 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/player/fmopl.c"
__inline static void set_ksl_tl(FM_OPL *OPL , int slot , int v ) 
{ 
  OPL_CH *CH ;
  OPL_SLOT *SLOT ;
  int ksl ;

  {
#line 393
  CH = OPL->P_CH + slot / 2;
#line 394
  SLOT = & CH->SLOT[slot & 1];
#line 395
  ksl = v >> 6;
#line 397
  if (ksl) {
#line 397
    SLOT->ksl = (UINT8 )(3 - ksl);
  } else {
#line 397
    SLOT->ksl = (UINT8 )31;
  }
#line 398
  SLOT->TL = (INT32 )((double )(v & 63) * (0.75 / (96.0 / (double )4096)));
#line 400
  if (! (OPL->mode & 128U)) {
#line 402
    SLOT->TLL = (INT32 )((UINT32 )SLOT->TL + (CH->ksl_base >> (int )SLOT->ksl));
  }
#line 404
  return;
}
}
#line 407 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/player/fmopl.c"
__inline static void set_ar_dr(FM_OPL *OPL , int slot , int v ) 
{ 
  OPL_CH *CH ;
  OPL_SLOT *SLOT ;
  int ar ;
  int dr ;

  {
#line 409
  CH = OPL->P_CH + slot / 2;
#line 410
  SLOT = & CH->SLOT[slot & 1];
#line 411
  ar = v >> 4;
#line 412
  dr = v & 15;
#line 414
  if (ar) {
#line 414
    SLOT->AR = & OPL->AR_TABLE[ar << 2];
  } else {
#line 414
    SLOT->AR = RATE_0;
  }
#line 415
  SLOT->evsa = *(SLOT->AR + SLOT->ksr);
#line 416
  if ((int )SLOT->evm == 2) {
#line 416
    SLOT->evs = SLOT->evsa;
  }
#line 418
  if (dr) {
#line 418
    SLOT->DR = & OPL->DR_TABLE[dr << 2];
  } else {
#line 418
    SLOT->DR = RATE_0;
  }
#line 419
  SLOT->evsd = *(SLOT->DR + SLOT->ksr);
#line 420
  if ((int )SLOT->evm == 1) {
#line 420
    SLOT->evs = SLOT->evsd;
  }
#line 421
  return;
}
}
#line 424 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/player/fmopl.c"
__inline static void set_sl_rr(FM_OPL *OPL , int slot , int v ) 
{ 
  OPL_CH *CH ;
  OPL_SLOT *SLOT ;
  int sl ;
  int rr ;

  {
#line 426
  CH = OPL->P_CH + slot / 2;
#line 427
  SLOT = & CH->SLOT[slot & 1];
#line 428
  sl = v >> 4;
#line 429
  rr = v & 15;
#line 431
  SLOT->SL = (INT32 )SL_TABLE[sl];
#line 432
  if ((int )SLOT->evm == 1) {
#line 432
    SLOT->eve = SLOT->SL;
  }
#line 433
  SLOT->RR = & OPL->DR_TABLE[rr << 2];
#line 434
  SLOT->evsr = *(SLOT->RR + SLOT->ksr);
#line 435
  if ((int )SLOT->evm == 0) {
#line 435
    SLOT->evs = SLOT->evsr;
  }
#line 436
  return;
}
}
#line 441 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/player/fmopl.c"
__inline static void OPL_CALC_CH(OPL_CH *CH ) 
{ 
  UINT32 env_out ;
  OPL_SLOT *SLOT ;
  int feedback1 ;
  INT32 tmp ;

  {
  {
#line 446
  feedback2 = 0;
#line 448
  SLOT = & CH->SLOT[0];
#line 449
  env_out = OPL_CALC_SLOT(SLOT);
  }
#line 450
  if (env_out < 4095U) {
#line 453
    if (SLOT->vib) {
#line 453
      SLOT->Cnt += (SLOT->Incr * (UINT32 )vib) / 256U;
    } else {
#line 454
      SLOT->Cnt += SLOT->Incr;
    }
#line 456
    if (CH->FB) {
#line 458
      feedback1 = (CH->op1_out[0] + CH->op1_out[1]) >> (int )CH->FB;
#line 459
      CH->op1_out[1] = CH->op1_out[0];
#line 460
      tmp = *(*(SLOT->wavetable + ((SLOT->Cnt + (UINT32 )feedback1) / 8192U & 2047U)) + env_out);
#line 460
      CH->op1_out[0] = tmp;
#line 460
      *(CH->connect1) += tmp;
    } else {
#line 464
      *(CH->connect1) += *(*(SLOT->wavetable + (SLOT->Cnt / 8192U & 2047U)) + env_out);
    }
  } else {
#line 468
    CH->op1_out[1] = CH->op1_out[0];
#line 469
    CH->op1_out[0] = 0;
  }
  {
#line 472
  SLOT = & CH->SLOT[1];
#line 473
  env_out = OPL_CALC_SLOT(SLOT);
  }
#line 474
  if (env_out < 4095U) {
#line 477
    if (SLOT->vib) {
#line 477
      SLOT->Cnt += (SLOT->Incr * (UINT32 )vib) / 256U;
    } else {
#line 478
      SLOT->Cnt += SLOT->Incr;
    }
#line 480
    outd[0] += *(*(SLOT->wavetable + ((SLOT->Cnt + (UINT32 )feedback2) / 8192U & 2047U)) + env_out);
  }
#line 482
  return;
}
}
#line 486 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/player/fmopl.c"
__inline static void OPL_CALC_RH(OPL_CH *CH ) 
{ 
  UINT32 env_tam ;
  UINT32 env_sd ;
  UINT32 env_top ;
  UINT32 env_hh ;
  int whitenoise ;
  int tmp ;
  INT32 tone8 ;
  OPL_SLOT *SLOT ;
  int env_out ;
  UINT32 tmp___0 ;
  int feedback1 ;
  INT32 tmp___1 ;
  UINT32 tmp___2 ;
  UINT32 tmp___3 ;
  UINT32 tmp___4 ;

  {
  {
#line 489
  tmp = rand();
#line 489
  whitenoise = (int )((double )(tmp & 1) * (6.0 / (96.0 / (double )4096)));
#line 496
  feedback2 = 0;
#line 498
  SLOT = & (CH + 6)->SLOT[0];
#line 499
  tmp___0 = OPL_CALC_SLOT(SLOT);
#line 499
  env_out = (int )tmp___0;
  }
#line 500
  if (env_out < 4095) {
#line 503
    if (SLOT->vib) {
#line 503
      SLOT->Cnt += (SLOT->Incr * (UINT32 )vib) / 256U;
    } else {
#line 504
      SLOT->Cnt += SLOT->Incr;
    }
#line 506
    if ((CH + 6)->FB) {
#line 508
      feedback1 = ((CH + 6)->op1_out[0] + (CH + 6)->op1_out[1]) >> (int )(CH + 6)->FB;
#line 509
      (CH + 6)->op1_out[1] = (CH + 6)->op1_out[0];
#line 510
      tmp___1 = *(*(SLOT->wavetable + ((SLOT->Cnt + (UINT32 )feedback1) / 8192U & 2047U)) + env_out);
#line 510
      (CH + 6)->op1_out[0] = tmp___1;
#line 510
      feedback2 = tmp___1;
    } else {
#line 514
      feedback2 = *(*(SLOT->wavetable + (SLOT->Cnt / 8192U & 2047U)) + env_out);
    }
  } else {
#line 518
    feedback2 = 0;
#line 519
    (CH + 6)->op1_out[1] = (CH + 6)->op1_out[0];
#line 520
    (CH + 6)->op1_out[0] = 0;
  }
  {
#line 523
  SLOT = & (CH + 6)->SLOT[1];
#line 524
  tmp___2 = OPL_CALC_SLOT(SLOT);
#line 524
  env_out = (int )tmp___2;
  }
#line 525
  if (env_out < 4095) {
#line 528
    if (SLOT->vib) {
#line 528
      SLOT->Cnt += (SLOT->Incr * (UINT32 )vib) / 256U;
    } else {
#line 529
      SLOT->Cnt += SLOT->Incr;
    }
#line 531
    outd[0] += *(*(SLOT->wavetable + ((SLOT->Cnt + (UINT32 )feedback2) / 8192U & 2047U)) + env_out) * 2;
  }
  {
#line 538
  tmp___3 = OPL_CALC_SLOT(SLOT7_2);
#line 538
  env_sd = tmp___3 + (UINT32 )whitenoise;
#line 539
  env_tam = OPL_CALC_SLOT(SLOT8_1);
#line 540
  env_top = OPL_CALC_SLOT(SLOT8_2);
#line 541
  tmp___4 = OPL_CALC_SLOT(SLOT7_1);
#line 541
  env_hh = tmp___4 + (UINT32 )whitenoise;
  }
#line 544
  if (SLOT7_1->vib) {
#line 544
    SLOT7_1->Cnt += ((2U * SLOT7_1->Incr) * (UINT32 )vib) / 256U;
  } else {
#line 545
    SLOT7_1->Cnt += 2U * SLOT7_1->Incr;
  }
#line 546
  if (SLOT7_2->vib) {
#line 546
    SLOT7_2->Cnt += (((CH + 7)->fc * 8U) * (UINT32 )vib) / 256U;
  } else {
#line 547
    SLOT7_2->Cnt += (CH + 7)->fc * 8U;
  }
#line 548
  if (SLOT8_1->vib) {
#line 548
    SLOT8_1->Cnt += (SLOT8_1->Incr * (UINT32 )vib) / 256U;
  } else {
#line 549
    SLOT8_1->Cnt += SLOT8_1->Incr;
  }
#line 550
  if (SLOT8_2->vib) {
#line 550
    SLOT8_2->Cnt += (((CH + 8)->fc * 48U) * (UINT32 )vib) / 256U;
  } else {
#line 551
    SLOT8_2->Cnt += (CH + 8)->fc * 48U;
  }
#line 553
  tone8 = *(*(SLOT8_2->wavetable + (SLOT8_2->Cnt / 8192U & 2047U)) + whitenoise);
#line 556
  if (env_sd < 4095U) {
#line 557
    outd[0] += *(*(SLOT7_1->wavetable + (SLOT7_1->Cnt / 8192U & 2047U)) + env_sd) * 8;
  }
#line 559
  if (env_tam < 4095U) {
#line 560
    outd[0] += *(*(SLOT8_1->wavetable + (SLOT8_1->Cnt / 8192U & 2047U)) + env_tam) * 2;
  }
#line 562
  if (env_top < 4095U) {
#line 563
    outd[0] += *(*(SLOT7_2->wavetable + ((SLOT7_2->Cnt + (UINT32 )tone8) / 8192U & 2047U)) + env_top) * 2;
  }
#line 565
  if (env_hh < 4095U) {
#line 566
    outd[0] += *(*(SLOT7_2->wavetable + ((SLOT7_2->Cnt + (UINT32 )tone8) / 8192U & 2047U)) + env_hh) * 2;
  }
#line 567
  return;
}
}
#line 570 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/player/fmopl.c"
static void init_timetables(FM_OPL *OPL , int ARRATE , int DRRATE ) 
{ 
  int i___3 ;
  double rate ;
  INT32 tmp ;

  {
#line 576
  i___3 = 0;
  {
#line 576
  while (1) {
    while_continue: /* CIL Label */ ;
#line 576
    if (! (i___3 < 4)) {
#line 576
      goto while_break;
    }
#line 576
    tmp = 0;
#line 576
    OPL->DR_TABLE[i___3] = tmp;
#line 576
    OPL->AR_TABLE[i___3] = tmp;
#line 576
    i___3 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 577
  i___3 = 4;
  {
#line 577
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 577
    if (! (i___3 <= 60)) {
#line 577
      goto while_break___0;
    }
#line 578
    rate = OPL->freqbase;
#line 579
    if (i___3 < 60) {
#line 579
      rate *= 1.0 + (double )(i___3 & 3) * 0.25;
    }
#line 580
    rate *= (double )(1 << ((i___3 >> 2) - 1));
#line 581
    rate *= (double )(4096 << 16);
#line 582
    OPL->AR_TABLE[i___3] = (INT32 )(rate / (double )ARRATE);
#line 583
    OPL->DR_TABLE[i___3] = (INT32 )(rate / (double )DRRATE);
#line 577
    i___3 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 585
  i___3 = 60;
  {
#line 585
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 585
    if (! (i___3 < 76)) {
#line 585
      goto while_break___1;
    }
#line 587
    OPL->AR_TABLE[i___3] = (4096 << 16) - 1;
#line 588
    OPL->DR_TABLE[i___3] = OPL->DR_TABLE[60];
#line 585
    i___3 ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 597
  return;
}
}
#line 600 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/player/fmopl.c"
static int OPLOpenTable(void) 
{ 
  int s ;
  int t ;
  double rate ;
  int i___3 ;
  int j ;
  double pom ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  double tmp___3 ;
  INT32 tmp___4 ;
  INT32 *tmp___5 ;
  double tmp___6 ;
  INT32 *tmp___7 ;
  INT32 *tmp___8 ;
  double tmp___9 ;
  double tmp___10 ;
  double tmp___11 ;

  {
  {
#line 608
  tmp = malloc((size_t )(16384UL * sizeof(INT32 )));
#line 608
  TL_TABLE = (INT32 *)tmp;
  }
#line 608
  if ((unsigned long )TL_TABLE == (unsigned long )((void *)0)) {
#line 609
    return (0);
  }
  {
#line 610
  tmp___0 = malloc((size_t )(8192UL * sizeof(INT32 *)));
#line 610
  SIN_TABLE = (INT32 **)tmp___0;
  }
#line 610
  if ((unsigned long )SIN_TABLE == (unsigned long )((void *)0)) {
    {
#line 612
    free((void *)TL_TABLE);
    }
#line 613
    return (0);
  }
  {
#line 615
  tmp___1 = malloc((size_t )(1024UL * sizeof(INT32 )));
#line 615
  AMS_TABLE = (INT32 *)tmp___1;
  }
#line 615
  if ((unsigned long )AMS_TABLE == (unsigned long )((void *)0)) {
    {
#line 617
    free((void *)TL_TABLE);
#line 618
    free((void *)SIN_TABLE);
    }
#line 619
    return (0);
  }
  {
#line 621
  tmp___2 = malloc((size_t )(1024UL * sizeof(INT32 )));
#line 621
  VIB_TABLE = (INT32 *)tmp___2;
  }
#line 621
  if ((unsigned long )VIB_TABLE == (unsigned long )((void *)0)) {
    {
#line 623
    free((void *)TL_TABLE);
#line 624
    free((void *)SIN_TABLE);
#line 625
    free((void *)AMS_TABLE);
    }
#line 626
    return (0);
  }
#line 629
  t = 0;
  {
#line 629
  while (1) {
    while_continue: /* CIL Label */ ;
#line 629
    if (! (t < 4095)) {
#line 629
      goto while_break;
    }
    {
#line 630
    tmp___3 = pow((double )10, ((96.0 / (double )4096) * (double )t) / (double )20);
#line 630
    rate = (double )((1 << 26) - 1) / tmp___3;
#line 631
    *(TL_TABLE + t) = (int )rate;
#line 632
    *(TL_TABLE + (8192 + t)) = - *(TL_TABLE + t);
#line 629
    t ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 636
  t = 4095;
  {
#line 636
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 636
    if (! (t < 8192)) {
#line 636
      goto while_break___0;
    }
#line 637
    tmp___4 = 0;
#line 637
    *(TL_TABLE + (8192 + t)) = tmp___4;
#line 637
    *(TL_TABLE + t) = tmp___4;
#line 636
    t ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 642
  tmp___5 = TL_TABLE + 4095;
#line 642
  *(SIN_TABLE + 1024) = tmp___5;
#line 642
  *(SIN_TABLE + 0) = tmp___5;
#line 643
  s = 1;
  {
#line 643
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 643
    if (! (s <= 512)) {
#line 643
      goto while_break___1;
    }
    {
#line 644
    pom = sin((((double )2 * 3.14159265358979323846) * (double )s) / (double )2048);
#line 645
    tmp___6 = log10((double )1 / pom);
#line 645
    pom = (double )20 * tmp___6;
#line 646
    j = (int )(pom / (96.0 / (double )4096));
#line 649
    tmp___7 = TL_TABLE + j;
#line 649
    *(SIN_TABLE + (1024 - s)) = tmp___7;
#line 649
    *(SIN_TABLE + s) = tmp___7;
#line 651
    tmp___8 = TL_TABLE + (8192 + j);
#line 651
    *(SIN_TABLE + (2048 - s)) = tmp___8;
#line 651
    *(SIN_TABLE + (1024 + s)) = tmp___8;
#line 643
    s ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 654
  s = 0;
  {
#line 654
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 654
    if (! (s < 2048)) {
#line 654
      goto while_break___2;
    }
#line 656
    if (s < 1024) {
#line 656
      *(SIN_TABLE + (2048 + s)) = *(SIN_TABLE + s);
    } else {
#line 656
      *(SIN_TABLE + (2048 + s)) = TL_TABLE + 4096;
    }
#line 657
    *(SIN_TABLE + (4096 + s)) = *(SIN_TABLE + s % 1024);
#line 658
    if (s / 512 & 1) {
#line 658
      *(SIN_TABLE + (6144 + s)) = TL_TABLE + 4096;
    } else {
#line 658
      *(SIN_TABLE + (6144 + s)) = *(SIN_TABLE + (4096 + s));
    }
#line 654
    s ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 662
  i___3 = 0;
  {
#line 662
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 662
    if (! (i___3 < 4096)) {
#line 662
      goto while_break___3;
    }
    {
#line 665
    tmp___9 = pow((double )(4095 - i___3) / (double )4096, (double )8);
#line 665
    pom = tmp___9 * (double )4096;
#line 667
    ENV_CURVE[i___3] = (int )pom;
#line 669
    ENV_CURVE[((4096 << 16) >> 16) + i___3] = i___3;
#line 662
    i___3 ++;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
#line 672
  ENV_CURVE[(8192 << 16) >> 16] = 4095;
#line 674
  i___3 = 0;
  {
#line 674
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 674
    if (! (i___3 < 512)) {
#line 674
      goto while_break___4;
    }
    {
#line 676
    tmp___10 = sin((((double )2 * 3.14159265358979323846) * (double )i___3) / (double )512);
#line 676
    pom = (1.0 + tmp___10) / (double )2;
#line 677
    *(AMS_TABLE + i___3) = (INT32 )((1.0 / (96.0 / (double )4096)) * pom);
#line 678
    *(AMS_TABLE + (512 + i___3)) = (INT32 )((4.8 / (96.0 / (double )4096)) * pom);
#line 674
    i___3 ++;
    }
  }
  while_break___4: /* CIL Label */ ;
  }
#line 681
  i___3 = 0;
  {
#line 681
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 681
    if (! (i___3 < 512)) {
#line 681
      goto while_break___5;
    }
    {
#line 684
    tmp___11 = sin((((double )2 * 3.14159265358979323846) * (double )i___3) / (double )512);
#line 684
    pom = ((double )256 * 0.06) * tmp___11;
#line 685
    *(VIB_TABLE + i___3) = (INT32 )((double )256 + pom * 0.07);
#line 686
    *(VIB_TABLE + (512 + i___3)) = (INT32 )((double )256 + pom * 0.14);
#line 681
    i___3 ++;
    }
  }
  while_break___5: /* CIL Label */ ;
  }
#line 689
  return (1);
}
}
#line 693 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/player/fmopl.c"
static void OPLCloseTable(void) 
{ 


  {
  {
#line 695
  free((void *)TL_TABLE);
#line 696
  free((void *)SIN_TABLE);
#line 697
  free((void *)AMS_TABLE);
#line 698
  free((void *)VIB_TABLE);
  }
#line 699
  return;
}
}
#line 702 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/player/fmopl.c"
__inline static void CSMKeyControll(OPL_CH *CH ) 
{ 
  OPL_SLOT *slot1 ;
  OPL_SLOT *slot2 ;
  INT32 tmp ;

  {
  {
#line 704
  slot1 = & CH->SLOT[0];
#line 705
  slot2 = & CH->SLOT[1];
#line 707
  OPL_KEYOFF(slot1);
#line 708
  OPL_KEYOFF(slot2);
#line 710
  slot1->TLL = (INT32 )((UINT32 )slot1->TL + (CH->ksl_base >> (int )slot1->ksl));
#line 711
  slot1->TLL = (INT32 )((UINT32 )slot1->TL + (CH->ksl_base >> (int )slot1->ksl));
#line 713
  tmp = 0;
#line 713
  CH->op1_out[1] = tmp;
#line 713
  CH->op1_out[0] = tmp;
#line 714
  OPL_KEYON(slot1);
#line 715
  OPL_KEYON(slot2);
  }
#line 716
  return;
}
}
#line 719 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/player/fmopl.c"
static void OPL_initalize(FM_OPL *OPL ) 
{ 
  int fn ;

  {
#line 724
  if (OPL->rate) {
#line 724
    OPL->freqbase = ((double )OPL->clock / (double )OPL->rate) / (double )72;
  } else {
#line 724
    OPL->freqbase = (double )0;
  }
  {
#line 726
  OPL->TimerBase = 1.0 / ((double )OPL->clock / 72.0);
#line 728
  init_timetables(OPL, 141280, 1956000);
#line 730
  fn = 0;
  }
  {
#line 730
  while (1) {
    while_continue: /* CIL Label */ ;
#line 730
    if (! (fn < 1024)) {
#line 730
      goto while_break;
    }
#line 732
    OPL->FN_TABLE[fn] = (UINT32 )((((OPL->freqbase * (double )fn) * (double )(1 << 4)) * (double )(1 << 7)) / (double )2);
#line 730
    fn ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 735
  if (OPL->rate) {
#line 735
    OPL->amsIncr = (INT32 )(((((double )512 * (double )(1 << 23)) / (double )OPL->rate) * 3.7) * ((double )OPL->clock / (double )3600000));
  } else {
#line 735
    OPL->amsIncr = 0;
  }
#line 736
  if (OPL->rate) {
#line 736
    OPL->vibIncr = (INT32 )(((((double )512 * (double )(1 << 23)) / (double )OPL->rate) * 6.4) * ((double )OPL->clock / (double )3600000));
  } else {
#line 736
    OPL->vibIncr = 0;
  }
#line 737
  return;
}
}
#line 740 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/player/fmopl.c"
static void OPLWriteReg(FM_OPL *OPL , int r , int v ) 
{ 
  OPL_CH *CH ;
  int slot ;
  int block_fnum ;
  int c___0 ;
  UINT8 st1 ;
  UINT8 st2 ;
  double interval ;
  double tmp ;
  double interval___0 ;
  double tmp___0 ;
  UINT8 rkey ;
  int tmp___1 ;
  int tmp___2 ;
  INT32 tmp___3 ;
  int keyon ;
  INT32 tmp___4 ;
  UINT8 tmp___5 ;
  int blockRv ;
  int fnum ;
  int feedback ;

  {
  {
#line 748
  if ((r & 224) == 0) {
#line 748
    goto case_0;
  }
#line 855
  if ((r & 224) == 32) {
#line 855
    goto case_32;
  }
#line 860
  if ((r & 224) == 64) {
#line 860
    goto case_64;
  }
#line 865
  if ((r & 224) == 96) {
#line 865
    goto case_96;
  }
#line 870
  if ((r & 224) == 128) {
#line 870
    goto case_128;
  }
#line 875
  if ((r & 224) == 160) {
#line 875
    goto case_160;
  }
#line 973
  if ((r & 224) == 192) {
#line 973
    goto case_192;
  }
#line 984
  if ((r & 224) == 224) {
#line 984
    goto case_224;
  }
#line 746
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 751
  if ((r & 31) == 1) {
#line 751
    goto case_1;
  }
#line 768
  if ((r & 31) == 2) {
#line 768
    goto case_2;
  }
#line 771
  if ((r & 31) == 3) {
#line 771
    goto case_3;
  }
#line 774
  if ((r & 31) == 4) {
#line 774
    goto case_4;
  }
#line 749
  goto switch_break___0;
  case_1: /* CIL Label */ 
#line 753
  if ((int )OPL->type & 1) {
#line 755
    OPL->wavesel = (UINT8 )(v & 32);
#line 756
    if (! OPL->wavesel) {
#line 760
      c___0 = 0;
      {
#line 760
      while (1) {
        while_continue: /* CIL Label */ ;
#line 760
        if (! (c___0 < OPL->max_ch)) {
#line 760
          goto while_break;
        }
#line 762
        (OPL->P_CH + c___0)->SLOT[0].wavetable = SIN_TABLE + 0;
#line 763
        (OPL->P_CH + c___0)->SLOT[1].wavetable = SIN_TABLE + 0;
#line 760
        c___0 ++;
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
#line 767
  return;
  case_2: /* CIL Label */ 
#line 769
  OPL->T[0] = (256 - v) * 4;
#line 770
  goto switch_break___0;
  case_3: /* CIL Label */ 
#line 772
  OPL->T[1] = (256 - v) * 16;
#line 773
  return;
  case_4: /* CIL Label */ 
#line 775
  if (v & 128) {
    {
#line 777
    OPL_STATUS_RESET(OPL, 127);
    }
  } else {
    {
#line 781
    st1 = (UINT8 )(v & 1);
#line 782
    st2 = (UINT8 )((v >> 1) & 1);
#line 784
    OPL_STATUS_RESET(OPL, v & 120);
#line 785
    OPL_STATUSMASK_SET(OPL, (~ v & 120) | 1);
    }
#line 787
    if ((int )OPL->st[1] != (int )st2) {
#line 789
      if (st2) {
#line 789
        tmp = (double )OPL->T[1] * OPL->TimerBase;
      } else {
#line 789
        tmp = 0.0;
      }
#line 789
      interval = tmp;
#line 790
      OPL->st[1] = st2;
#line 791
      if (OPL->TimerHandler) {
        {
#line 791
        (*(OPL->TimerHandler))(OPL->TimerParam + 1, interval);
        }
      }
    }
#line 794
    if ((int )OPL->st[0] != (int )st1) {
#line 796
      if (st1) {
#line 796
        tmp___0 = (double )OPL->T[0] * OPL->TimerBase;
      } else {
#line 796
        tmp___0 = 0.0;
      }
#line 796
      interval___0 = tmp___0;
#line 797
      OPL->st[0] = st1;
#line 798
      if (OPL->TimerHandler) {
        {
#line 798
        (*(OPL->TimerHandler))(OPL->TimerParam, interval___0);
        }
      }
    }
  }
#line 801
  return;
  switch_break___0: /* CIL Label */ ;
  }
#line 854
  goto switch_break;
  case_32: /* CIL Label */ 
#line 856
  slot = (int )slot_array[r & 31];
#line 857
  if (slot == -1) {
#line 857
    return;
  }
  {
#line 858
  set_mul(OPL, slot, v);
  }
#line 859
  return;
  case_64: /* CIL Label */ 
#line 861
  slot = (int )slot_array[r & 31];
#line 862
  if (slot == -1) {
#line 862
    return;
  }
  {
#line 863
  set_ksl_tl(OPL, slot, v);
  }
#line 864
  return;
  case_96: /* CIL Label */ 
#line 866
  slot = (int )slot_array[r & 31];
#line 867
  if (slot == -1) {
#line 867
    return;
  }
  {
#line 868
  set_ar_dr(OPL, slot, v);
  }
#line 869
  return;
  case_128: /* CIL Label */ 
#line 871
  slot = (int )slot_array[r & 31];
#line 872
  if (slot == -1) {
#line 872
    return;
  }
  {
#line 873
  set_sl_rr(OPL, slot, v);
  }
#line 874
  return;
  case_160: /* CIL Label */ 
  {
#line 878
  if (r == 189) {
#line 878
    goto case_189;
  }
#line 876
  goto switch_break___1;
  case_189: /* CIL Label */ 
#line 881
  rkey = (UINT8 )((int )OPL->rythm ^ v);
#line 882
  if (v & 128) {
#line 882
    tmp___1 = 512;
  } else {
#line 882
    tmp___1 = 0;
  }
#line 882
  OPL->ams_table = AMS_TABLE + tmp___1;
#line 883
  if (v & 64) {
#line 883
    tmp___2 = 512;
  } else {
#line 883
    tmp___2 = 0;
  }
#line 883
  OPL->vib_table = VIB_TABLE + tmp___2;
#line 884
  OPL->rythm = (UINT8 )(v & 63);
#line 885
  if ((int )OPL->rythm & 32) {
#line 891
    if ((int )rkey & 16) {
#line 893
      if (v & 16) {
        {
#line 895
        tmp___3 = 0;
#line 895
        (OPL->P_CH + 6)->op1_out[1] = tmp___3;
#line 895
        (OPL->P_CH + 6)->op1_out[0] = tmp___3;
#line 896
        OPL_KEYON(& (OPL->P_CH + 6)->SLOT[0]);
#line 897
        OPL_KEYON(& (OPL->P_CH + 6)->SLOT[1]);
        }
      } else {
        {
#line 901
        OPL_KEYOFF(& (OPL->P_CH + 6)->SLOT[0]);
#line 902
        OPL_KEYOFF(& (OPL->P_CH + 6)->SLOT[1]);
        }
      }
    }
#line 906
    if ((int )rkey & 8) {
#line 908
      if (v & 8) {
        {
#line 908
        OPL_KEYON(& (OPL->P_CH + 7)->SLOT[1]);
        }
      } else {
        {
#line 909
        OPL_KEYOFF(& (OPL->P_CH + 7)->SLOT[1]);
        }
      }
    }
#line 911
    if ((int )rkey & 4) {
#line 913
      if (v & 4) {
        {
#line 913
        OPL_KEYON(& (OPL->P_CH + 8)->SLOT[0]);
        }
      } else {
        {
#line 914
        OPL_KEYOFF(& (OPL->P_CH + 8)->SLOT[0]);
        }
      }
    }
#line 917
    if ((int )rkey & 2) {
#line 919
      if (v & 2) {
        {
#line 919
        OPL_KEYON(& (OPL->P_CH + 8)->SLOT[1]);
        }
      } else {
        {
#line 920
        OPL_KEYOFF(& (OPL->P_CH + 8)->SLOT[1]);
        }
      }
    }
#line 923
    if ((int )rkey & 1) {
#line 925
      if (v & 1) {
        {
#line 925
        OPL_KEYON(& (OPL->P_CH + 7)->SLOT[0]);
        }
      } else {
        {
#line 926
        OPL_KEYOFF(& (OPL->P_CH + 7)->SLOT[0]);
        }
      }
    }
  }
#line 930
  return;
  switch_break___1: /* CIL Label */ ;
  }
#line 933
  if ((r & 15) > 8) {
#line 933
    return;
  }
#line 934
  CH = OPL->P_CH + (r & 15);
#line 935
  if (! (r & 16)) {
#line 937
    block_fnum = (int )((CH->block_fnum & 7936U) | (unsigned int )v);
  } else {
#line 941
    keyon = (v >> 5) & 1;
#line 942
    block_fnum = (int )((unsigned int )((v & 31) << 8) | (CH->block_fnum & 255U));
#line 943
    if ((int )CH->keyon != keyon) {
#line 945
      tmp___5 = (UINT8 )keyon;
#line 945
      CH->keyon = tmp___5;
#line 945
      if (tmp___5) {
        {
#line 947
        tmp___4 = 0;
#line 947
        CH->op1_out[1] = tmp___4;
#line 947
        CH->op1_out[0] = tmp___4;
#line 948
        OPL_KEYON(& CH->SLOT[0]);
#line 949
        OPL_KEYON(& CH->SLOT[1]);
        }
      } else {
        {
#line 953
        OPL_KEYOFF(& CH->SLOT[0]);
#line 954
        OPL_KEYOFF(& CH->SLOT[1]);
        }
      }
    }
  }
#line 959
  if (CH->block_fnum != (UINT32 )block_fnum) {
#line 961
    blockRv = 7 - (block_fnum >> 10);
#line 962
    fnum = block_fnum & 1023;
#line 963
    CH->block_fnum = (UINT32 )block_fnum;
#line 965
    CH->ksl_base = (UINT32 )KSL_TABLE[block_fnum >> 6];
#line 966
    CH->fc = OPL->FN_TABLE[fnum] >> blockRv;
#line 967
    CH->kcode = (UINT8 )(CH->block_fnum >> 9);
#line 968
    if (OPL->mode & 64U) {
#line 968
      if (CH->block_fnum & 256U) {
#line 968
        CH->kcode = (UINT8 )((int )CH->kcode | 1);
      }
    }
    {
#line 969
    CALC_FCSLOT(CH, & CH->SLOT[0]);
#line 970
    CALC_FCSLOT(CH, & CH->SLOT[1]);
    }
  }
#line 972
  return;
  case_192: /* CIL Label */ 
#line 975
  if ((r & 15) > 8) {
#line 975
    return;
  }
#line 976
  CH = OPL->P_CH + (r & 15);
#line 978
  feedback = (v >> 1) & 7;
#line 979
  if (feedback) {
#line 979
    CH->FB = (UINT8 )(9 - feedback);
  } else {
#line 979
    CH->FB = (UINT8 )0;
  }
  {
#line 980
  CH->CON = (UINT8 )(v & 1);
#line 981
  set_algorythm(CH);
  }
#line 983
  return;
  case_224: /* CIL Label */ 
#line 985
  slot = (int )slot_array[r & 31];
#line 986
  if (slot == -1) {
#line 986
    return;
  }
#line 987
  CH = OPL->P_CH + slot / 2;
#line 988
  if (OPL->wavesel) {
#line 991
    CH->SLOT[slot & 1].wavetable = SIN_TABLE + (v & 3) * 2048;
  }
#line 993
  return;
  switch_break: /* CIL Label */ ;
  }
#line 995
  return;
}
}
#line 998 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/player/fmopl.c"
static int OPL_LockTable(void) 
{ 
  int tmp ;

  {
#line 1000
  num_lock ++;
#line 1001
  if (num_lock > 1) {
#line 1001
    return (0);
  }
  {
#line 1003
  cur_chip = (void *)0;
#line 1005
  tmp = OPLOpenTable();
  }
#line 1005
  if (! tmp) {
#line 1007
    num_lock --;
#line 1008
    return (-1);
  }
#line 1010
  return (0);
}
}
#line 1013 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/player/fmopl.c"
static void OPL_UnLockTable(void) 
{ 


  {
#line 1015
  if (num_lock) {
#line 1015
    num_lock --;
  }
#line 1016
  if (num_lock) {
#line 1016
    return;
  }
  {
#line 1018
  cur_chip = (void *)0;
#line 1019
  OPLCloseTable();
  }
#line 1020
  return;
}
}
#line 1029 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/player/fmopl.c"
void YM3812UpdateOne(FM_OPL *OPL , FMSAMPLE *bk , int len , int vl , int vr , int st ) 
{ 
  int data ;
  UINT32 amsCnt ;
  UINT32 vibCnt ;
  UINT8 rythm ;
  OPL_CH *CH ;
  OPL_CH *R_CH ;
  FMSAMPLE *tmp ;
  FMSAMPLE *tmp___0 ;
  int tmp___1 ;

  {
#line 1032
  amsCnt = (UINT32 )OPL->amsCnt;
#line 1033
  vibCnt = (UINT32 )OPL->vibCnt;
#line 1034
  rythm = (UINT8 )((int )OPL->rythm & 32);
#line 1037
  if ((unsigned long )((void *)OPL) != (unsigned long )cur_chip) {
#line 1038
    cur_chip = (void *)OPL;
#line 1040
    S_CH = OPL->P_CH;
#line 1041
    E_CH = S_CH + 9;
#line 1043
    SLOT7_1 = & (S_CH + 7)->SLOT[0];
#line 1044
    SLOT7_2 = & (S_CH + 7)->SLOT[1];
#line 1045
    SLOT8_1 = & (S_CH + 8)->SLOT[0];
#line 1046
    SLOT8_2 = & (S_CH + 8)->SLOT[1];
#line 1048
    amsIncr = OPL->amsIncr;
#line 1049
    vibIncr = OPL->vibIncr;
#line 1050
    ams_table = OPL->ams_table;
#line 1051
    vib_table = OPL->vib_table;
  }
#line 1053
  if (rythm) {
#line 1053
    R_CH = S_CH + 6;
  } else {
#line 1053
    R_CH = E_CH;
  }
  {
#line 1054
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1054
    tmp___1 = len;
#line 1054
    len --;
#line 1054
    if (! tmp___1) {
#line 1054
      goto while_break;
    }
#line 1057
    amsCnt += (UINT32 )amsIncr;
#line 1057
    ams = *(ams_table + (amsCnt >> 23));
#line 1058
    vibCnt += (UINT32 )vibIncr;
#line 1058
    vib = *(vib_table + (vibCnt >> 23));
#line 1059
    outd[0] = 0;
#line 1061
    CH = S_CH;
    {
#line 1061
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1061
      if (! ((unsigned long )CH < (unsigned long )R_CH)) {
#line 1061
        goto while_break___0;
      }
      {
#line 1062
      OPL_CALC_CH(CH);
#line 1061
      CH ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1064
    if (rythm) {
      {
#line 1065
      OPL_CALC_RH(S_CH);
      }
    }
    {
#line 1067
    data = Limit(outd[0], 32767 << 13, -32768 << 13);
    }
#line 1070
    if (st) {
#line 1071
      tmp = bk;
#line 1071
      bk ++;
#line 1071
      *tmp += (data >> 13) * vr;
    }
#line 1072
    tmp___0 = bk;
#line 1072
    bk ++;
#line 1072
    *tmp___0 += (data >> 13) * vl;
  }
  while_break: /* CIL Label */ ;
  }
#line 1075
  OPL->amsCnt = (INT32 )amsCnt;
#line 1076
  OPL->vibCnt = (INT32 )vibCnt;
#line 1077
  return;
}
}
#line 1143 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/player/fmopl.c"
void OPLResetChip(FM_OPL *OPL ) 
{ 
  int c___0 ;
  int s ;
  int i___3 ;
  OPL_CH *CH ;

  {
  {
#line 1149
  OPL->mode = (UINT32 )0;
#line 1150
  OPL_STATUS_RESET(OPL, 127);
#line 1152
  OPLWriteReg(OPL, 1, 0);
#line 1153
  OPLWriteReg(OPL, 2, 0);
#line 1154
  OPLWriteReg(OPL, 3, 0);
#line 1155
  OPLWriteReg(OPL, 4, 0);
#line 1156
  i___3 = 255;
  }
  {
#line 1156
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1156
    if (! (i___3 >= 32)) {
#line 1156
      goto while_break;
    }
    {
#line 1156
    OPLWriteReg(OPL, i___3, 0);
#line 1156
    i___3 --;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1158
  c___0 = 0;
  {
#line 1158
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1158
    if (! (c___0 < OPL->max_ch)) {
#line 1158
      goto while_break___0;
    }
#line 1160
    CH = OPL->P_CH + c___0;
#line 1162
    s = 0;
    {
#line 1162
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1162
      if (! (s < 2)) {
#line 1162
        goto while_break___1;
      }
#line 1165
      CH->SLOT[s].wavetable = SIN_TABLE + 0;
#line 1167
      CH->SLOT[s].evc = 8192 << 16;
#line 1168
      CH->SLOT[s].eve = (8192 << 16) + 1;
#line 1169
      CH->SLOT[s].evs = 0;
#line 1162
      s ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1158
    c___0 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1184
  return;
}
}
#line 1188 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/player/fmopl.c"
FM_OPL *OPLCreate(int type , int clock , int rate ) 
{ 
  char *ptr ;
  FM_OPL *OPL ;
  int state_size ;
  int max_ch ;
  int tmp ;
  void *tmp___0 ;

  {
  {
#line 1193
  max_ch = 9;
#line 1195
  tmp = OPL_LockTable();
  }
#line 1195
  if (tmp == -1) {
#line 1195
    return ((FM_OPL *)((void *)0));
  }
  {
#line 1197
  state_size = (int )sizeof(FM_OPL );
#line 1198
  state_size = (int )((unsigned long )state_size + sizeof(OPL_CH ) * (unsigned long )max_ch);
#line 1203
  tmp___0 = malloc((size_t )state_size);
#line 1203
  ptr = (char *)tmp___0;
  }
#line 1204
  if ((unsigned long )ptr == (unsigned long )((void *)0)) {
#line 1204
    return ((FM_OPL *)((void *)0));
  }
  {
#line 1206
  memset((void *)ptr, 0, (size_t )state_size);
#line 1207
  OPL = (FM_OPL *)ptr;
#line 1207
  ptr += sizeof(FM_OPL );
#line 1208
  OPL->P_CH = (OPL_CH *)ptr;
#line 1208
  ptr += sizeof(OPL_CH ) * (unsigned long )max_ch;
#line 1213
  OPL->type = (UINT8 )type;
#line 1214
  OPL->clock = clock;
#line 1215
  OPL->rate = rate;
#line 1216
  OPL->max_ch = max_ch;
#line 1218
  OPL_initalize(OPL);
#line 1220
  OPLResetChip(OPL);
  }
#line 1221
  return (OPL);
}
}
#line 1225 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/player/fmopl.c"
void OPLDestroy(FM_OPL *OPL ) 
{ 


  {
  {
#line 1227
  OPL_UnLockTable();
#line 1228
  free((void *)OPL);
  }
#line 1229
  return;
}
}
#line 1233 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/player/fmopl.c"
void OPLSetTimerHandler(FM_OPL *OPL , void (*TimerHandler)(int channel , double interval_Sec ) ,
                        int channelOffset ) 
{ 


  {
#line 1235
  OPL->TimerHandler = TimerHandler;
#line 1236
  OPL->TimerParam = channelOffset;
#line 1237
  return;
}
}
#line 1238 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/player/fmopl.c"
void OPLSetIRQHandler(FM_OPL *OPL , void (*IRQHandler)(int param , int irq ) , int param ) 
{ 


  {
#line 1240
  OPL->IRQHandler = IRQHandler;
#line 1241
  OPL->IRQParam = param;
#line 1242
  return;
}
}
#line 1243 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/player/fmopl.c"
void OPLSetUpdateHandler(FM_OPL *OPL , void (*UpdateHandler)(int param , int min_interval_us ) ,
                         int param ) 
{ 


  {
#line 1245
  OPL->UpdateHandler = UpdateHandler;
#line 1246
  OPL->UpdateParam = param;
#line 1247
  return;
}
}
#line 1264 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/player/fmopl.c"
int OPLWrite(FM_OPL *OPL , int a , int v ) 
{ 


  {
#line 1266
  if (! (a & 1)) {
#line 1268
    OPL->address = (UINT8 )(v & 255);
  } else {
#line 1272
    if (OPL->UpdateHandler) {
      {
#line 1272
      (*(OPL->UpdateHandler))(OPL->UpdateParam, 0);
      }
    }
    {
#line 1273
    OPLWriteReg(OPL, (int )OPL->address, v);
    }
  }
#line 1275
  return ((int )OPL->status >> 7);
}
}
#line 1278 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/player/fmopl.c"
unsigned char OPLRead(FM_OPL *OPL , int a ) 
{ 
  unsigned char tmp ;
  unsigned char tmp___0 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
#line 1280
  if (! (a & 1)) {
#line 1282
    return ((unsigned char )((int )OPL->status & ((int )OPL->statusmask | 128)));
  }
  {
#line 1287
  if ((int )OPL->address == 5) {
#line 1287
    goto case_5;
  }
#line 1300
  if ((int )OPL->address == 25) {
#line 1300
    goto case_25;
  }
#line 1309
  if ((int )OPL->address == 26) {
#line 1309
    goto case_26;
  }
#line 1285
  goto switch_break;
  case_5: /* CIL Label */ 
#line 1288
  if ((int )OPL->type & 4) {
#line 1290
    if (OPL->keyboardhandler_r) {
      {
#line 1291
      tmp = (*(OPL->keyboardhandler_r))(OPL->keyboard_param);
      }
#line 1291
      return (tmp);
    } else {
      {
#line 1293
      Log(2, (char *)"OPL:read unmapped KEYBOARD port\n");
      }
    }
  }
#line 1295
  return ((unsigned char)0);
  case_25: /* CIL Label */ 
#line 1301
  if ((int )OPL->type & 8) {
#line 1303
    if (OPL->porthandler_r) {
      {
#line 1304
      tmp___0 = (*(OPL->porthandler_r))(OPL->port_param);
      }
#line 1304
      return (tmp___0);
    } else {
      {
#line 1306
      Log(2, (char *)"OPL:read unmapped I/O port\n");
      }
    }
  }
#line 1308
  return ((unsigned char)0);
  case_26: /* CIL Label */ 
#line 1310
  return ((unsigned char)0);
  switch_break: /* CIL Label */ ;
  }
#line 1312
  return ((unsigned char)0);
}
}
#line 1315 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/player/fmopl.c"
int OPLTimerOver(FM_OPL *OPL , int c___0 ) 
{ 
  int ch ;

  {
#line 1317
  if (c___0) {
    {
#line 1319
    OPL_STATUS_SET(OPL, 32);
    }
  } else {
    {
#line 1323
    OPL_STATUS_SET(OPL, 64);
    }
#line 1325
    if (OPL->mode & 128U) {
#line 1328
      if (OPL->UpdateHandler) {
        {
#line 1328
        (*(OPL->UpdateHandler))(OPL->UpdateParam, 0);
        }
      }
#line 1329
      ch = 0;
      {
#line 1329
      while (1) {
        while_continue: /* CIL Label */ ;
#line 1329
        if (! (ch < 9)) {
#line 1329
          goto while_break;
        }
        {
#line 1330
        CSMKeyControll(OPL->P_CH + ch);
#line 1329
        ch ++;
        }
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
#line 1334
  if (OPL->TimerHandler) {
    {
#line 1334
    (*(OPL->TimerHandler))(OPL->TimerParam + c___0, (double )OPL->T[c___0] * OPL->TimerBase);
    }
  }
#line 1335
  return ((int )OPL->status >> 7);
}
}
#line 190 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/player/player.h"
void filter_setup(struct xmp_context *ctx___0 , struct xmp_channel *xc , int cutoff ) ;
#line 26 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/player/filter.c"
static int filter_cutoff[256]  = 
#line 26 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/player/filter.c"
  {      130,      132,      134,      136, 
        138,      140,      142,      144, 
        146,      148,      151,      153, 
        155,      157,      160,      162, 
        164,      167,      169,      172, 
        174,      177,      179,      182, 
        184,      187,      190,      193, 
        195,      198,      201,      204, 
        207,      210,      213,      216, 
        220,      223,      226,      229, 
        233,      236,      239,      243, 
        246,      250,      254,      257, 
        261,      265,      269,      273, 
        277,      281,      285,      289, 
        293,      297,      302,      306, 
        311,      315,      320,      324, 
        329,      334,      339,      344, 
        349,      354,      359,      364, 
        369,      375,      380,      386, 
        391,      397,      403,      409, 
        415,      421,      427,      433, 
        440,      446,      452,      459, 
        466,      472,      479,      486, 
        493,      501,      508,      515, 
        523,      530,      538,      546, 
        554,      562,      570,      578, 
        587,      595,      604,      613, 
        622,      631,      640,      649, 
        659,      668,      678,      688, 
        698,      708,      718,      729, 
        739,      750,      761,      772, 
        783,      795,      806,      818, 
        830,      842,      854,      867, 
        880,      892,      905,      918, 
        932,      945,      959,      973, 
        987,      1002,      1016,      1031, 
        1046,      1061,      1077,      1092, 
        1108,      1124,      1141,      1157, 
        1174,      1191,      1209,      1226, 
        1244,      1262,      1280,      1299, 
        1318,      1337,      1357,      1376, 
        1396,      1417,      1437,      1458, 
        1479,      1501,      1523,      1545, 
        1567,      1590,      1613,      1637, 
        1661,      1685,      1709,      1734, 
        1760,      1785,      1811,      1837, 
        1864,      1891,      1919,      1947, 
        1975,      2004,      2033,      2062, 
        2093,      2123,      2154,      2185, 
        2217,      2249,      2282,      2315, 
        2349,      2383,      2418,      2453, 
        2489,      2525,      2561,      2599, 
        2637,      2675,      2714,      2753, 
        2793,      2834,      2875,      2917, 
        2959,      3003,      3046,      3091, 
        3135,      3181,      3227,      3274, 
        3322,      3370,      3419,      3469, 
        3520,      3571,      3623,      3675, 
        3729,      3783,      3838,      3894, 
        3951,      4008,      4066,      4125, 
        4186,      4246,      4308,      4371, 
        4434,      4499,      4564,      4631, 
        4698,      4766,      4836,      4906, 
        4978,      5050,      5123,      5198};
#line 62 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/player/filter.c"
int dmpfac[256]  = 
#line 62
  {      131072,      128272,      125533,      122852, 
        120229,      117661,      115148,      112689, 
        110283,      107928,      105623,      103367, 
        101160,      98999,      96885,      94816, 
        92791,      90810,      88870,      86973, 
        85115,      83298,      81519,      79778, 
        78074,      76407,      74775,      73178, 
        71615,      70086,      68589,      67125, 
        65691,      64288,      62915,      61572, 
        60257,      58970,      57711,      56478, 
        55272,      54092,      52937,      51806, 
        50700,      49617,      48557,      47520, 
        46506,      45512,      44540,      43589, 
        42658,      41747,      40856,      39983, 
        39130,      38294,      37476,      36676, 
        35893,      35126,      34376,      33642, 
        32923,      32220,      31532,      30859, 
        30200,      29555,      28924,      28306, 
        27701,      27110,      26531,      25964, 
        25410,      24867,      24336,      23816, 
        23308,      22810,      22323,      21846, 
        21380,      20923,      20476,      20039, 
        19611,      19192,      18782,      18381, 
        17989,      17604,      17228,      16861, 
        16500,      16148,      15803,      15466, 
        15135,      14812,      14496,      14186, 
        13883,      13587,      13297,      13013, 
        12735,      12463,      12197,      11936, 
        11681,      11432,      11188,      10949, 
        10715,      10486,      10262,      10043, 
        9829,      9619,      9413,      9212, 
        9015,      8823,      8634,      8450, 
        8270,      8093,      7920,      7751, 
        7585,      7423,      7265,      7110, 
        6958,      6809,      6664,      6522, 
        6382,      6246,      6113,      5982, 
        5854,      5729,      5607,      5487, 
        5370,      5255,      5143,      5033, 
        4926,      4820,      4718,      4617, 
        4518,      4422,      4327,      4235, 
        4144,      4056,      3969,      3884, 
        3801,      3720,      3641,      3563, 
        3487,      3412,      3340,      3268, 
        3198,      3130,      3063,      2998, 
        2934,      2871,      2810,      2750, 
        2691,      2634,      2577,      2522, 
        2468,      2416,      2364,      2314, 
        2264,      2216,      2169,      2122, 
        2077,      2032,      1989,      1947, 
        1905,      1864,      1824,      1786, 
        1747,      1710,      1674,      1638, 
        1603,      1569,      1535,      1502, 
        1470,      1439,      1408,      1378, 
        1348,      1320,      1291,      1264, 
        1237,      1210,      1185,      1159, 
        1135,      1110,      1087,      1063, 
        1041,      1018,      997,      975, 
        955,      934,      914,      895, 
        876,      857,      838,      821, 
        803,      786,      769,      753, 
        737,      721,      705,      690, 
        676,      661,      647,      633, 
        620,      606,      593,      581, 
        568,      556,      544,      533};
#line 101 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/player/filter.c"
void filter_setup(struct xmp_context *ctx___0 , struct xmp_channel *xc , int cutoff ) 
{ 
  struct xmp_options *o___0 ;
  float fc ;
  float fs ;
  float fg ;
  float fb0 ;
  float fb1 ;
  float d2 ;
  float d ;
  float e ;

  {
#line 103
  o___0 = & ctx___0->o;
#line 105
  fc = (float )filter_cutoff[cutoff];
#line 106
  fs = (float )o___0->freq;
#line 110
  fc = (float )((double )fc * ((3.14159265358979 * (double )2) / (double )fs));
#line 111
  d2 = (float )dmpfac[xc->resonance] / (float )32768;
#line 112
  d = (float )((1.0 - (double )d2) * (double )fc);
#line 114
  if ((double )d > 2.0) {
#line 115
    d = (float )2.0;
  }
#line 117
  d = (d2 - d) / fc;
#line 118
  e = (float )(1.0 / (double )(fc * fc));
#line 120
  fg = (float )(1.0 / (double )(((float )1 + d) + e));
#line 121
  fb0 = ((d + e) + e) / (((float )1 + d) + e);
#line 122
  fb1 = - e / (((float )1 + d) + e);
#line 124
  xc->flt_B0 = (int )(fg * (float )(1 << 12));
#line 125
  xc->flt_B1 = (int )(fb0 * (float )(1 << 12));
#line 126
  xc->flt_B2 = (int )(fb1 * (float )(1 << 12));
#line 127
  return;
}
}
#line 187 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/player/player.h"
void xmp_med_synth(struct xmp_context *ctx___0 , int chn , struct xmp_channel *xc ,
                   int rst ) ;
#line 188
int get_med_arp(struct xmp_player_context *p , struct xmp_channel *xc ) ;
#line 189
int get_med_vibrato(struct xmp_channel *xc ) ;
#line 81 "src/include/driver.h"
void xmp_drv_setsmp(struct xmp_context *ctx___0 , int chn , int smp ) ;
#line 48 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/player/med_synth.c"
static int sine[32]  = 
#line 48 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/player/med_synth.c"
  {      0,      49,      97,      141, 
        180,      212,      235,      250, 
        255,      250,      235,      212, 
        180,      141,      97,      49, 
        0,      -49,      -97,      -141, 
        -180,      -212,      -235,      -250, 
        -255,      -250,      -235,      -212, 
        -180,      -141,      -97,      -49};
#line 55 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/player/med_synth.c"
int get_med_vibrato(struct xmp_channel *xc ) 
{ 
  int vib___0 ;

  {
#line 69
  vib___0 = sine[xc->med_vib_idx >> 5] * xc->med_vib_depth >> 11;
#line 70
  xc->med_vib_idx += xc->med_vib_speed;
#line 71
  xc->med_vib_idx %= 32 << 5;
#line 73
  return (vib___0);
}
}
#line 77 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/player/med_synth.c"
int get_med_arp(struct xmp_player_context *p , struct xmp_channel *xc ) 
{ 
  int arp ;
  int tmp ;
  int tmp___0 ;

  {
#line 81
  if (xc->med_arp == 0) {
#line 82
    return (0);
  }
#line 84
  if ((int )*(*(p->m.med_wav_table + xc->ins) + xc->med_arp) == 253) {
#line 85
    return (0);
  }
#line 87
  tmp = xc->med_aidx;
#line 87
  (xc->med_aidx) ++;
#line 87
  arp = (int )*(*(p->m.med_wav_table + xc->ins) + tmp);
#line 88
  if (arp == 253) {
#line 89
    xc->med_aidx = xc->med_arp;
#line 90
    tmp___0 = xc->med_aidx;
#line 90
    (xc->med_aidx) ++;
#line 90
    arp = (int )*(*(p->m.med_wav_table + xc->ins) + tmp___0);
  }
#line 93
  return (100 * arp);
}
}
#line 97 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/player/med_synth.c"
void xmp_med_synth(struct xmp_context *ctx___0 , int chn , struct xmp_channel *xc ,
                   int rst ) 
{ 
  struct xmp_player_context *p ;
  int b___1 ;
  int jws ;
  int jvs ;
  int loop ;
  int jump ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;

  {
#line 99
  p = & ctx___0->p;
#line 101
  jws = 0;
#line 101
  jvs = 0;
#line 101
  loop = 0;
#line 101
  jump = 0;
#line 103
  if ((unsigned long )p->m.med_vol_table == (unsigned long )((void *)0)) {
#line 104
    return;
  } else
#line 103
  if ((unsigned long )p->m.med_wav_table == (unsigned long )((void *)0)) {
#line 104
    return;
  }
#line 106
  if ((unsigned long )*(p->m.med_vol_table + xc->ins) == (unsigned long )((void *)0)) {
#line 107
    return;
  } else
#line 106
  if ((unsigned long )*(p->m.med_wav_table + xc->ins) == (unsigned long )((void *)0)) {
#line 107
    return;
  }
#line 109
  if (rst) {
#line 110
    tmp = 0;
#line 110
    xc->med_aidx = tmp;
#line 110
    xc->med_arp = tmp;
#line 111
    xc->med_period = (int )xc->period;
#line 112
    tmp___1 = 0;
#line 112
    xc->med_vw = tmp___1;
#line 112
    tmp___0 = tmp___1;
#line 112
    xc->med_vc = tmp___0;
#line 112
    xc->med_vp = tmp___0;
#line 113
    tmp___3 = 0;
#line 113
    xc->med_ww = tmp___3;
#line 113
    tmp___2 = tmp___3;
#line 113
    xc->med_wc = tmp___2;
#line 113
    xc->med_wp = tmp___2;
#line 114
    xc->med_vs = (p->m.xxih + xc->ins)->vts;
#line 115
    xc->med_ws = (p->m.xxih + xc->ins)->wts;
  }
#line 118
  if (xc->med_vs > 0) {
#line 118
    tmp___26 = xc->med_vc;
#line 118
    (xc->med_vc) --;
#line 118
    if (tmp___26 == 0) {
#line 119
      xc->med_vc = xc->med_vs - 1;
#line 121
      if (xc->med_vw > 0) {
#line 122
        (xc->med_vw) --;
#line 123
        goto skip_vol;
      }
#line 126
      jws = 0;
#line 126
      loop = jws;
#line 126
      jump = loop;
#line 127
      tmp___4 = xc->med_vp;
#line 127
      (xc->med_vp) ++;
#line 127
      b___1 = (int )*(*(p->m.med_vol_table + xc->ins) + tmp___4);
      {
#line 130
      if (b___1 == 251) {
#line 130
        goto case_251;
      }
#line 130
      if (b___1 == 255) {
#line 130
        goto case_251;
      }
#line 133
      if (b___1 == 254) {
#line 133
        goto case_254;
      }
#line 139
      if (b___1 == 250) {
#line 139
        goto case_250;
      }
#line 143
      if (b___1 == 244) {
#line 143
        goto case_244;
      }
#line 143
      if (b___1 == 245) {
#line 143
        goto case_244;
      }
#line 146
      if (b___1 == 243) {
#line 146
        goto case_243;
      }
#line 149
      if (b___1 == 242) {
#line 149
        goto case_242;
      }
#line 152
      if (b___1 == 241) {
#line 152
        goto case_241;
      }
#line 155
      if (b___1 == 240) {
#line 155
        goto case_240;
      }
#line 158
      goto switch_default;
      {
#line 128
      while (1) {
        while_continue: /* CIL Label */ ;
#line 128
        tmp___11 = jump;
#line 128
        jump --;
#line 128
        if (! tmp___11) {
#line 128
          goto while_break;
        }
        case_251: /* CIL Label */ 
        case_255: /* CIL Label */ 
#line 131
        (xc->med_vp) --;
#line 132
        goto while_break;
        case_254: /* CIL Label */ 
#line 134
        if (loop) {
#line 135
          goto while_break;
        }
#line 136
        tmp___5 = xc->med_vp;
#line 136
        (xc->med_vp) ++;
#line 136
        xc->med_vp = (int )*(*(p->m.med_vol_table + xc->ins) + tmp___5);
#line 137
        jump = 1;
#line 137
        loop = jump;
#line 138
        goto while_break;
        case_250: /* CIL Label */ 
#line 140
        tmp___6 = xc->med_vp;
#line 140
        (xc->med_vp) ++;
#line 140
        jws = (int )*(*(p->m.med_vol_table + xc->ins) + tmp___6);
#line 141
        goto while_break;
        case_244: /* CIL Label */ 
        case_245: /* CIL Label */ 
#line 144
        (xc->med_vp) ++;
#line 145
        goto while_break;
        case_243: /* CIL Label */ 
#line 147
        tmp___7 = xc->med_vp;
#line 147
        (xc->med_vp) ++;
#line 147
        xc->med_vv = (int )*(*(p->m.med_vol_table + xc->ins) + tmp___7);
#line 148
        goto while_break;
        case_242: /* CIL Label */ 
#line 150
        tmp___8 = xc->med_vp;
#line 150
        (xc->med_vp) ++;
#line 150
        xc->med_vv = - ((int )*(*(p->m.med_vol_table + xc->ins) + tmp___8));
#line 151
        goto while_break;
        case_241: /* CIL Label */ 
#line 153
        tmp___9 = xc->med_vp;
#line 153
        (xc->med_vp) ++;
#line 153
        xc->med_vw = (int )*(*(p->m.med_vol_table + xc->ins) + tmp___9);
#line 154
        goto while_break;
        case_240: /* CIL Label */ 
#line 156
        tmp___10 = xc->med_vp;
#line 156
        (xc->med_vp) ++;
#line 156
        xc->med_vs = (int )*(*(p->m.med_vol_table + xc->ins) + tmp___10);
#line 157
        goto while_break;
        switch_default: /* CIL Label */ 
#line 159
        if (b___1 >= 0) {
#line 159
          if (b___1 <= 64) {
#line 160
            xc->volume = b___1;
          }
        }
      }
      while_break: /* CIL Label */ ;
      }
      switch_break: /* CIL Label */ ;
      }
#line 164
      xc->volume += xc->med_vv;
#line 165
      if (xc->volume < 0) {
#line 166
        xc->volume = 0;
      }
#line 167
      if (xc->volume > 64) {
#line 168
        xc->volume = 64;
      }
      skip_vol: 
#line 172
      if (xc->med_ww > 0) {
#line 173
        (xc->med_ww) --;
#line 174
        goto skip_wav;
      }
#line 177
      jvs = 0;
#line 177
      loop = jvs;
#line 177
      jump = loop;
#line 178
      tmp___12 = xc->med_wp;
#line 178
      (xc->med_wp) ++;
#line 178
      b___1 = (int )*(*(p->m.med_wav_table + xc->ins) + tmp___12);
      {
#line 181
      if (b___1 == 251) {
#line 181
        goto case_251___0;
      }
#line 181
      if (b___1 == 255) {
#line 181
        goto case_251___0;
      }
#line 184
      if (b___1 == 254) {
#line 184
        goto case_254___0;
      }
#line 190
      if (b___1 == 253) {
#line 190
        goto case_253;
      }
#line 192
      if (b___1 == 252) {
#line 192
        goto case_252;
      }
#line 196
      if (b___1 == 250) {
#line 196
        goto case_250___0;
      }
#line 199
      if (b___1 == 247) {
#line 199
        goto case_247;
      }
#line 202
      if (b___1 == 246) {
#line 202
        goto case_246;
      }
#line 205
      if (b___1 == 245) {
#line 205
        goto case_245___0;
      }
#line 208
      if (b___1 == 244) {
#line 208
        goto case_244___0;
      }
#line 211
      if (b___1 == 243) {
#line 211
        goto case_243___0;
      }
#line 214
      if (b___1 == 242) {
#line 214
        goto case_242___0;
      }
#line 217
      if (b___1 == 241) {
#line 217
        goto case_241___0;
      }
#line 220
      if (b___1 == 240) {
#line 220
        goto case_240___0;
      }
#line 223
      goto switch_default___0;
      {
#line 179
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 179
        tmp___25 = jump;
#line 179
        jump --;
#line 179
        if (! tmp___25) {
#line 179
          goto while_break___0;
        }
        case_251___0: /* CIL Label */ 
        case_255___0: /* CIL Label */ 
#line 182
        (xc->med_wp) --;
#line 183
        goto while_break___0;
        case_254___0: /* CIL Label */ 
#line 185
        if (loop) {
#line 186
          goto while_break___0;
        }
#line 187
        tmp___13 = xc->med_wp;
#line 187
        (xc->med_wp) ++;
#line 187
        xc->med_wp = (int )*(*(p->m.med_wav_table + xc->ins) + tmp___13);
#line 188
        jump = 1;
#line 188
        loop = jump;
#line 189
        goto while_break___0;
        case_253: /* CIL Label */ 
#line 191
        goto while_break___0;
        case_252: /* CIL Label */ 
#line 193
        tmp___15 = xc->med_wp;
#line 193
        (xc->med_wp) ++;
#line 193
        tmp___14 = tmp___15;
#line 193
        xc->med_aidx = tmp___14;
#line 193
        xc->med_arp = tmp___14;
        {
#line 194
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 194
          tmp___16 = xc->med_wp;
#line 194
          (xc->med_wp) ++;
#line 194
          if (! ((int )*(*(p->m.med_wav_table + xc->ins) + tmp___16) != 253)) {
#line 194
            goto while_break___1;
          }
        }
        while_break___1: /* CIL Label */ ;
        }
#line 195
        goto while_break___0;
        case_250___0: /* CIL Label */ 
#line 197
        tmp___17 = xc->med_wp;
#line 197
        (xc->med_wp) ++;
#line 197
        jws = (int )*(*(p->m.med_wav_table + xc->ins) + tmp___17);
#line 198
        goto while_break___0;
        case_247: /* CIL Label */ 
#line 200
        tmp___18 = xc->med_wp;
#line 200
        (xc->med_wp) ++;
#line 200
        xc->med_vwf = (int )*(*(p->m.med_wav_table + xc->ins) + tmp___18);
#line 201
        goto while_break___0;
        case_246: /* CIL Label */ 
#line 203
        xc->period = (double )xc->med_period;
#line 204
        goto while_break___0;
        case_245___0: /* CIL Label */ 
#line 206
        tmp___19 = xc->med_wp;
#line 206
        (xc->med_wp) ++;
#line 206
        xc->med_vib_speed = (int )*(*(p->m.med_wav_table + xc->ins) + tmp___19);
#line 207
        goto while_break___0;
        case_244___0: /* CIL Label */ 
#line 209
        tmp___20 = xc->med_wp;
#line 209
        (xc->med_wp) ++;
#line 209
        xc->med_vib_depth = (int )*(*(p->m.med_wav_table + xc->ins) + tmp___20);
#line 210
        goto while_break___0;
        case_243___0: /* CIL Label */ 
#line 212
        tmp___21 = xc->med_wp;
#line 212
        (xc->med_wp) ++;
#line 212
        xc->med_wv = - ((int )*(*(p->m.med_wav_table + xc->ins) + tmp___21));
#line 213
        goto while_break___0;
        case_242___0: /* CIL Label */ 
#line 215
        tmp___22 = xc->med_wp;
#line 215
        (xc->med_wp) ++;
#line 215
        xc->med_wv = (int )*(*(p->m.med_wav_table + xc->ins) + tmp___22);
#line 216
        goto while_break___0;
        case_241___0: /* CIL Label */ 
#line 218
        tmp___23 = xc->med_wp;
#line 218
        (xc->med_wp) ++;
#line 218
        xc->med_ww = (int )*(*(p->m.med_wav_table + xc->ins) + tmp___23);
#line 219
        goto while_break___0;
        case_240___0: /* CIL Label */ 
#line 221
        tmp___24 = xc->med_wp;
#line 221
        (xc->med_wp) ++;
#line 221
        xc->med_ws = (int )*(*(p->m.med_wav_table + xc->ins) + tmp___24);
#line 222
        goto while_break___0;
        switch_default___0: /* CIL Label */ 
#line 224
        if (b___1 < (p->m.xxih + xc->ins)->nsm) {
#line 224
          if ((*(p->m.xxi + xc->ins) + b___1)->sid != xc->smp) {
            {
#line 225
            xc->smp = (*(p->m.xxi + xc->ins) + b___1)->sid;
#line 226
            xmp_drv_setsmp(ctx___0, chn, xc->smp);
            }
          }
        }
      }
      while_break___0: /* CIL Label */ ;
      }
      switch_break___0: /* CIL Label */ ;
      }
      skip_wav: ;
    }
  }
#line 235
  if (jws) {
#line 236
    xc->med_wp = jws;
#line 237
    jws = 0;
  }
#line 240
  if (jvs) {
#line 241
    xc->med_vp = jvs;
#line 242
    jvs = 0;
  }
#line 244
  return;
}
}
#line 19 "src/include/convert.h"
int xmp_cvt_crunch(struct patch_info **patch , unsigned int ratio ) ;
#line 53 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/player/cruncher.c"
static void cruncher_8bit(int count , int itpt_inc , char *in_bk , char *out_bk ) 
{ 
  int smp_x1 ;
  int smp_dt ;
  int itpt ;
  int cur_bk ;
  char *tmp ;
  int tmp___0 ;

  {
#line 58
  cur_bk = -1;
#line 58
  itpt = 65536;
#line 58
  smp_dt = 0;
#line 58
  smp_x1 = smp_dt;
  {
#line 58
  while (1) {
    while_continue: /* CIL Label */ ;
#line 58
    tmp___0 = count;
#line 58
    count --;
#line 58
    if (! tmp___0) {
#line 58
      goto while_break;
    }
#line 58
    if (itpt >> 16) {
#line 58
      cur_bk += itpt >> 16;
#line 58
      smp_x1 = (int )*(in_bk + cur_bk);
#line 58
      smp_dt = (int )*(in_bk + (cur_bk + 1)) - smp_x1;
#line 58
      itpt &= 65535;
    }
#line 58
    tmp = out_bk;
#line 58
    out_bk ++;
#line 58
    *tmp = (char )(smp_x1 + (itpt * smp_dt >> 16));
#line 58
    itpt += itpt_inc;
  }
  while_break: /* CIL Label */ ;
  }
#line 59
  return;
}
}
#line 62 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/player/cruncher.c"
static void cruncher_16bit(int count , int itpt_inc , int16 *in_bk , int16 *out_bk ) 
{ 
  int smp_x1 ;
  int smp_dt ;
  int itpt ;
  int cur_bk ;
  int16 *tmp ;
  int tmp___0 ;

  {
#line 67
  cur_bk = -1;
#line 67
  itpt = 65536;
#line 67
  smp_dt = 0;
#line 67
  smp_x1 = smp_dt;
  {
#line 67
  while (1) {
    while_continue: /* CIL Label */ ;
#line 67
    tmp___0 = count;
#line 67
    count --;
#line 67
    if (! tmp___0) {
#line 67
      goto while_break;
    }
#line 67
    if (itpt >> 16) {
#line 67
      cur_bk += itpt >> 16;
#line 67
      smp_x1 = (int )*(in_bk + cur_bk);
#line 67
      smp_dt = (int )*(in_bk + (cur_bk + 1)) - smp_x1;
#line 67
      itpt &= 65535;
    }
#line 67
    tmp = out_bk;
#line 67
    out_bk ++;
#line 67
    *tmp = (int16 )(smp_x1 + (itpt * smp_dt >> 16));
#line 67
    itpt += itpt_inc;
  }
  while_break: /* CIL Label */ ;
  }
#line 68
  return;
}
}
#line 71 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/player/cruncher.c"
int xmp_cvt_crunch(struct patch_info **patch , unsigned int ratio ) 
{ 
  struct patch_info *pi ;
  int type ;
  int loop_end ;
  int loop_dt ;
  int smp_len ;
  int itpt_inc ;
  int base_note ;
  void *tmp ;

  {
#line 77
  if (ratio == 65536U) {
#line 78
    return ((int )ratio);
  }
#line 80
  if ((*patch)->len == -1) {
#line 81
    return (0);
  }
#line 83
  type = 0;
#line 84
  loop_end = (*patch)->loop_end;
#line 85
  loop_dt = loop_end - (*patch)->loop_start;
#line 86
  smp_len = (*patch)->len;
#line 88
  if ((*patch)->mode & 1U) {
#line 89
    smp_len >>= 1;
#line 90
    loop_dt >>= 1;
#line 91
    loop_end >>= 1;
#line 92
    type ++;
  }
#line 95
  if (ratio < 65536U) {
#line 95
    if (smp_len < 4096) {
#line 96
      return (65536);
    }
  }
  {
#line 98
  base_note = (int )(((int64 )(*patch)->base_note << 16) / (int64 )ratio);
#line 99
  itpt_inc = (int )(((int64 )base_note << 16) / (int64 )(*patch)->base_note);
#line 100
  smp_len = (int )(((int64 )smp_len << 16) / (int64 )itpt_inc);
#line 101
  loop_end = (int )(((int64 )loop_end << 16) / (int64 )itpt_inc);
#line 102
  loop_dt = (int )(((int64 )loop_dt << 16) / (int64 )itpt_inc);
#line 104
  tmp = calloc((size_t )1, (size_t )((sizeof(struct patch_info ) + (unsigned long )(smp_len << type)) + sizeof(int )));
#line 104
  pi = (struct patch_info *)tmp;
#line 107
  memcpy((void */* __restrict  */)pi, (void const   */* __restrict  */)*patch, (size_t )sizeof(struct patch_info ));
#line 108
  pi->len = smp_len << type;
#line 109
  pi->loop_end = loop_end << type;
#line 110
  pi->loop_start = (loop_end - loop_dt) << type;
#line 111
  pi->base_note = (unsigned int )base_note;
  }
#line 113
  if (type) {
    {
#line 114
    cruncher_16bit(smp_len, itpt_inc, (int16 *)(& (*patch)->data), (int16 *)(& pi->data));
    }
  } else {
    {
#line 117
    cruncher_8bit(smp_len, itpt_inc, (char *)(& (*patch)->data), (char *)(& pi->data));
    }
  }
  {
#line 120
  free((void *)*patch);
#line 121
  *patch = pi;
  }
#line 123
  return ((int )ratio);
}
}
#line 19 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/player/ulaw.c"
int ulaw_encode(int c___0 ) 
{ 
  register int mask ;

  {
#line 23
  if (c___0 < 0) {
#line 24
    c___0 = - c___0;
#line 25
    mask = 127;
  } else {
#line 27
    mask = 255;
  }
#line 29
  if (c___0 < 32) {
#line 30
    c___0 = 240 | (15 - (c___0 >> 1));
  } else
#line 31
  if (c___0 < 96) {
#line 32
    c___0 = 224 | (15 - ((c___0 - 32) >> 2));
  } else
#line 33
  if (c___0 < 224) {
#line 34
    c___0 = 208 | (15 - ((c___0 - 96) >> 3));
  } else
#line 35
  if (c___0 < 480) {
#line 36
    c___0 = 192 | (15 - ((c___0 - 224) >> 4));
  } else
#line 37
  if (c___0 < 992) {
#line 38
    c___0 = 176 | (15 - ((c___0 - 480) >> 5));
  } else
#line 39
  if (c___0 < 2016) {
#line 40
    c___0 = 160 | (15 - ((c___0 - 992) >> 6));
  } else
#line 41
  if (c___0 < 4064) {
#line 42
    c___0 = 144 | (15 - ((c___0 - 2016) >> 7));
  } else
#line 43
  if (c___0 < 8160) {
#line 44
    c___0 = 128 | (15 - ((c___0 - 4064) >> 8));
  } else {
#line 46
    c___0 = 128;
  }
#line 48
  return (mask & c___0);
}
}
#line 284 "src/include/common.h"
int _xmp_scan_module(struct xmp_context *ctx___0 ) ;
#line 43 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/player/scan.c"
int _xmp_scan_module(struct xmp_context *ctx___0 ) 
{ 
  int parm ;
  int gvol_slide ;
  int f1 ;
  int f2 ;
  int p1 ;
  int p2 ;
  int ord ;
  int ord2 ;
  int row ;
  int last_row ;
  int break_row ;
  int cnt_row ;
  int gvl ;
  int bpm___0 ;
  int tempo ;
  int base_time ;
  int chn ;
  int alltmp ;
  int clock ;
  int clock_rst ;
  int medbpm ;
  int loop_chn ;
  int loop_flg ;
  int *loop_stk ;
  int *loop_row ;
  char **tab_cnt ;
  struct xxm_event *event ;
  struct xmp_player_context *p ;
  struct xmp_mod_context *m___0 ;
  struct xmp_options *o___0 ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  int tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
#line 54
  p = & ctx___0->p;
#line 55
  m___0 = & p->m;
#line 56
  o___0 = & ctx___0->o;
#line 58
  if ((m___0->xxh)->len == 0) {
#line 59
    return (0);
  }
  {
#line 61
  medbpm = m___0->quirk & 1;
#line 63
  tmp = calloc((size_t )sizeof(char *), (size_t )(m___0->xxh)->len);
#line 63
  tab_cnt = (char **)tmp;
#line 64
  ord = (m___0->xxh)->len;
  }
  {
#line 64
  while (1) {
    while_continue: /* CIL Label */ ;
#line 64
    tmp___3 = ord;
#line 64
    ord --;
#line 64
    if (! tmp___3) {
#line 64
      goto while_break;
    }
#line 65
    if ((int )m___0->xxo[ord] >= (m___0->xxh)->pat) {
#line 65
      tmp___1 = 1;
    } else {
#line 65
      if ((*(m___0->xxp + m___0->xxo[ord]))->rows) {
#line 65
        tmp___0 = (*(m___0->xxp + m___0->xxo[ord]))->rows;
      } else {
#line 65
        tmp___0 = 1;
      }
#line 65
      tmp___1 = tmp___0;
    }
    {
#line 65
    tmp___2 = calloc((size_t )1, (size_t )tmp___1);
#line 65
    *(tab_cnt + ord) = (char *)tmp___2;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 68
  tmp___4 = calloc((size_t )sizeof(int ), (size_t )(m___0->xxh)->chn);
#line 68
  loop_stk = (int *)tmp___4;
#line 69
  tmp___5 = calloc((size_t )sizeof(int ), (size_t )(m___0->xxh)->chn);
#line 69
  loop_row = (int *)tmp___5;
#line 70
  loop_flg = 0;
#line 70
  loop_chn = loop_flg;
#line 72
  memset((void *)(m___0->xxo_fstrow), 0, (size_t )256);
#line 74
  gvl = (m___0->xxh)->gvl;
#line 75
  bpm___0 = (m___0->xxh)->bpm;
  }
#line 77
  if (o___0->tempo) {
#line 77
    tempo = o___0->tempo;
  } else {
#line 77
    tempo = (m___0->xxh)->tpo;
  }
#line 77
  if (tempo) {
#line 77
    tempo = tempo;
  } else {
#line 77
    tempo = 6;
  }
#line 78
  base_time = (int )m___0->rrate;
#line 93
  ord2 = -1;
#line 94
  ord = ctx___0->o.start - 1;
#line 96
  clock = 0;
#line 96
  clock_rst = clock;
#line 96
  alltmp = clock_rst;
#line 96
  cnt_row = alltmp;
#line 96
  break_row = cnt_row;
#line 96
  gvol_slide = break_row;
  {
#line 98
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 99
    ord ++;
#line 99
    if ((uint32 )ord >= (uint32 )(m___0->xxh)->len) {
#line 101
      if ((uint32 )(m___0->xxh)->rst > (uint32 )(m___0->xxh)->len) {
#line 101
        ord = 0;
      } else
#line 101
      if ((uint32 )m___0->xxo[(m___0->xxh)->rst] >= (uint32 )(m___0->xxh)->pat) {
#line 101
        ord = 0;
      } else {
#line 101
        ord = (m___0->xxh)->rst;
      }
    }
#line 109
    if ((uint32 )m___0->xxo[ord] >= (uint32 )(m___0->xxh)->pat) {
#line 111
      if ((int )m___0->xxo[ord] == 255) {
#line 112
        ord = (m___0->xxh)->len;
#line 113
        goto while_continue___0;
      }
#line 115
      goto while_continue___0;
    }
#line 118
    if (break_row < (*(m___0->xxp + m___0->xxo[ord]))->rows) {
#line 118
      if (*(*(tab_cnt + ord) + break_row)) {
#line 119
        goto while_break___0;
      }
    }
#line 121
    m___0->xxo_info[ord].gvl = gvl;
#line 122
    m___0->xxo_info[ord].bpm = bpm___0;
#line 123
    m___0->xxo_info[ord].tempo = tempo;
#line 125
    if (medbpm) {
#line 126
      m___0->xxo_info[ord].time = (clock + ((132 * alltmp) / 5) / bpm___0) / 10;
    } else {
#line 128
      m___0->xxo_info[ord].time = (clock + (100 * alltmp) / bpm___0) / 10;
    }
#line 130
    if (! m___0->xxo_fstrow[ord]) {
#line 130
      if (ord) {
#line 131
        if (ord == o___0->start) {
#line 131
          if (! (m___0->flags & (1 << 3))) {
#line 132
            if (medbpm) {
#line 133
              clock_rst = clock + ((132 * alltmp) / 5) / bpm___0;
            } else {
#line 135
              clock_rst = clock + (100 * alltmp) / bpm___0;
            }
          }
        }
#line 138
        m___0->xxo_fstrow[ord] = break_row;
      }
    }
#line 141
    last_row = (*(m___0->xxp + m___0->xxo[ord]))->rows;
#line 142
    row = break_row;
#line 142
    break_row = 0;
    {
#line 142
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 142
      if (! (row < last_row)) {
#line 142
        goto while_break___1;
      }
#line 144
      if (bpm___0 < 5) {
#line 145
        bpm___0 = 5;
      }
#line 160
      if (cnt_row > 512) {
#line 161
        goto end_module;
      }
#line 163
      if (! loop_flg) {
#line 163
        if (*(*(tab_cnt + ord) + row)) {
#line 164
          cnt_row --;
#line 165
          goto end_module;
        }
      }
#line 167
      *(*(tab_cnt + ord) + row) = (char )((int )*(*(tab_cnt + ord) + row) + 1);
#line 169
      chn = 0;
      {
#line 169
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 169
        if (! (chn < (m___0->xxh)->chn)) {
#line 169
          goto while_break___2;
        }
#line 170
        if (row >= (*(m___0->xxt + (*(m___0->xxp + m___0->xxo[ord]))->info[chn].index))->rows) {
#line 171
          goto __Cont;
        }
#line 173
        event = & (*(m___0->xxt + (*(m___0->xxp + m___0->xxo[ord]))->info[chn].index))->event[row];
#line 175
        f1 = (int )event->fxt;
#line 176
        p1 = (int )event->fxp;
#line 177
        f2 = (int )event->f2t;
#line 178
        p2 = (int )event->f2p;
#line 180
        if (f1 == 16) {
#line 180
          goto _L;
        } else
#line 180
        if (f2 == 16) {
          _L: /* CIL Label */ 
#line 181
          if (f1 == 16) {
#line 181
            gvl = p1;
          } else {
#line 181
            gvl = p2;
          }
#line 182
          if (gvl > 64) {
#line 182
            gvl = 64;
          } else {
#line 182
            if (gvl < 0) {
#line 182
              tmp___6 = 0;
            } else {
#line 182
              tmp___6 = gvl;
            }
#line 182
            gvl = tmp___6;
          }
        }
#line 185
        if (f1 == 17) {
#line 185
          goto _L___0;
        } else
#line 185
        if (f2 == 17) {
          _L___0: /* CIL Label */ 
#line 186
          if (f1 == 17) {
#line 186
            parm = p1;
          } else {
#line 186
            parm = p2;
          }
#line 187
          if (parm) {
#line 188
            gvol_slide = ((parm & 240) >> 4) - (parm & 15);
          }
#line 189
          gvl += gvol_slide * (tempo - ! (m___0->quirk & (1 << 13)));
        }
#line 192
        if (f1 == 15) {
#line 192
          if (p1) {
#line 192
            goto _L___1;
          } else {
#line 192
            goto _L___2;
          }
        } else
        _L___2: /* CIL Label */ 
#line 192
        if (f2 == 15) {
#line 192
          if (p2) {
            _L___1: /* CIL Label */ 
#line 193
            if (f1 == 15) {
#line 193
              parm = p1;
            } else {
#line 193
              parm = p2;
            }
#line 194
            alltmp += (cnt_row * tempo) * base_time;
#line 195
            cnt_row = 0;
#line 196
            if (parm) {
#line 197
              if (parm <= 32) {
#line 198
                tempo = parm;
              } else
#line 199
              if (~ m___0->flags & (1 << 4)) {
#line 200
                if (medbpm) {
#line 201
                  clock += ((132 * alltmp) / 5) / bpm___0;
                } else {
#line 203
                  clock += (100 * alltmp) / bpm___0;
                }
#line 205
                alltmp = 0;
#line 206
                bpm___0 = parm;
              }
            }
          }
        }
#line 211
        if (f1 == 163) {
#line 211
          if (p1) {
#line 211
            goto _L___3;
          } else {
#line 211
            goto _L___4;
          }
        } else
        _L___4: /* CIL Label */ 
#line 211
        if (f2 == 163) {
#line 211
          if (p2) {
            _L___3: /* CIL Label */ 
#line 212
            if (f1 == 163) {
#line 212
              parm = p1;
            } else {
#line 212
              parm = p2;
            }
#line 213
            alltmp += (cnt_row * tempo) * base_time;
#line 214
            cnt_row = 0;
#line 215
            tempo = parm;
          }
        }
#line 218
        if (f1 == 171) {
#line 218
          if (p1) {
#line 218
            goto _L___5;
          } else {
#line 218
            goto _L___6;
          }
        } else
        _L___6: /* CIL Label */ 
#line 218
        if (f2 == 171) {
#line 218
          if (p2) {
            _L___5: /* CIL Label */ 
#line 219
            if (f1 == 171) {
#line 219
              parm = p1;
            } else {
#line 219
              parm = p2;
            }
#line 220
            alltmp += (cnt_row * tempo) * base_time;
#line 221
            cnt_row = 0;
#line 223
            if (medbpm) {
#line 224
              clock += ((132 * alltmp) / 5) / bpm___0;
            } else {
#line 226
              clock += (100 * alltmp) / bpm___0;
            }
#line 228
            alltmp = 0;
#line 229
            bpm___0 = parm;
          }
        }
#line 232
        if (f1 == 173) {
#line 232
          if (p1) {
#line 232
            goto _L___7;
          } else {
#line 232
            goto _L___8;
          }
        } else
        _L___8: /* CIL Label */ 
#line 232
        if (f2 == 173) {
#line 232
          if (p2) {
            _L___7: /* CIL Label */ 
#line 233
            if (f1 == 173) {
#line 233
              parm = p1;
            } else {
#line 233
              parm = p2;
            }
#line 234
            alltmp += (cnt_row * tempo) * base_time;
#line 235
            cnt_row = 0;
#line 236
            clock += (100 * alltmp) / bpm___0;
#line 237
            alltmp = 0;
#line 239
            if ((parm & 240) >> 4 == 0) {
#line 240
              bpm___0 -= parm & 15;
#line 241
              if (bpm___0 < 32) {
#line 242
                bpm___0 = 32;
              }
            } else
#line 243
            if ((parm & 240) >> 4 == 1) {
#line 244
              bpm___0 += parm & 15;
#line 245
              if (bpm___0 > 255) {
#line 246
                bpm___0 = 255;
              }
            } else {
#line 248
              bpm___0 = parm;
            }
          }
        }
#line 252
        if (f1 == 11) {
#line 252
          goto _L___9;
        } else
#line 252
        if (f2 == 11) {
          _L___9: /* CIL Label */ 
#line 253
          if (f1 == 11) {
#line 253
            ord2 = p1;
          } else {
#line 253
            ord2 = p2;
          }
#line 254
          last_row = 0;
        }
#line 257
        if (f1 == 13) {
#line 257
          goto _L___10;
        } else
#line 257
        if (f2 == 13) {
          _L___10: /* CIL Label */ 
#line 258
          if (f1 == 13) {
#line 258
            parm = p1;
          } else {
#line 258
            parm = p2;
          }
#line 259
          break_row = 10 * ((parm & 240) >> 4) + (parm & 15);
#line 260
          last_row = 0;
        }
#line 263
        if (f1 == 14) {
#line 263
          goto _L___11;
        } else
#line 263
        if (f2 == 14) {
          _L___11: /* CIL Label */ 
#line 264
          if (f1 == 14) {
#line 264
            parm = p1;
          } else {
#line 264
            parm = p2;
          }
#line 266
          if (parm >> 4 == 14) {
#line 267
            alltmp += ((parm & 15) * tempo) * base_time;
          }
#line 269
          if (parm >> 4 == 6) {
#line 270
            parm &= 15;
#line 270
            if (parm) {
#line 271
              if (*(loop_stk + chn)) {
#line 272
                (*(loop_stk + chn)) --;
#line 272
                if (*(loop_stk + chn)) {
#line 273
                  loop_chn = chn + 1;
                } else {
#line 275
                  loop_flg --;
#line 276
                  if (m___0->quirk & (1 << 1)) {
#line 277
                    *(loop_row + chn) = row + 1;
                  }
                }
              } else
#line 280
              if (*(loop_row + chn) <= row) {
#line 281
                *(loop_stk + chn) = parm;
#line 282
                loop_chn = chn + 1;
#line 283
                loop_flg ++;
              }
            } else {
#line 287
              *(loop_row + chn) = row;
            }
          }
        }
        __Cont: /* CIL Label */ 
#line 169
        chn ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 293
      if (loop_chn) {
#line 294
        loop_chn --;
#line 294
        row = *(loop_row + loop_chn) - 1;
#line 295
        loop_chn = 0;
      }
#line 142
      row ++;
#line 142
      cnt_row ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 299
    if (ord2 >= 0) {
#line 300
      ord2 --;
#line 300
      ord = ord2;
#line 301
      ord2 = -1;
    }
#line 304
    alltmp += (cnt_row * tempo) * base_time;
#line 305
    cnt_row = 0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 307
  row = break_row;
  end_module: 
#line 310
  if (o___0->start > ord) {
#line 310
    p->xmp_scan_num = 0;
  } else {
#line 310
    p->xmp_scan_num = (int )*(*(tab_cnt + ord) + row);
  }
  {
#line 311
  p->xmp_scan_row = row;
#line 312
  p->xmp_scan_ord = ord;
#line 314
  free((void *)loop_row);
#line 315
  free((void *)loop_stk);
#line 317
  ord = (m___0->xxh)->len;
  }
  {
#line 317
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 317
    tmp___7 = ord;
#line 317
    ord --;
#line 317
    if (! tmp___7) {
#line 317
      goto while_break___3;
    }
    {
#line 317
    free((void *)*(tab_cnt + ord));
    }
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 318
  free((void *)tab_cnt);
#line 320
  clock -= clock_rst;
#line 321
  alltmp += (cnt_row * tempo) * base_time;
  }
#line 323
  if (medbpm) {
#line 324
    return ((clock + ((132 * alltmp) / 5) / bpm___0) / 10);
  } else {
#line 326
    return ((clock + (100 * alltmp) / bpm___0) / 10);
  }
}
}
#line 214 "/usr/include/stdio.h"
extern int fclose(FILE *__stream ) ;
#line 249
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 407
extern int fscanf(FILE * __restrict  __stream , char const   * __restrict  __format 
                  , ...)  __asm__("__isoc99_fscanf")  ;
#line 513
extern int fgetc(FILE *__stream ) ;
#line 801
extern  __attribute__((__nothrow__)) int feof(FILE *__stream ) ;
#line 145 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) strncmp)(char const   *__s1 ,
                                                                                      char const   *__s2 ,
                                                                                      size_t __n )  __attribute__((__pure__)) ;
#line 566 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1))) getenv)(char const   *__name ) ;
#line 280 "src/include/common.h"
int report(char *fmt___0  , ...) ;
#line 290
int _xmp_read_rc(struct xmp_context *ctx___0 ) ;
#line 291
void _xmp_read_modconf(struct xmp_context *ctx___0 , uint32 crc___0 , long size___0 ) ;
#line 25 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/player/readrc.c"
static char drive_id[32]  ;
#line 28 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/player/readrc.c"
static void delete_spaces(char *l ) 
{ 
  char *s ;
  size_t tmp ;

  {
#line 32
  s = l;
  {
#line 32
  while (1) {
    while_continue: /* CIL Label */ ;
#line 32
    if (! *s) {
#line 32
      goto while_break;
    }
#line 33
    if ((int )*s == 32) {
      {
#line 34
      tmp = strlen((char const   *)s);
#line 34
      memmove((void *)s, (void const   *)(s + 1), tmp);
#line 35
      s --;
      }
    } else
#line 33
    if ((int )*s == 9) {
      {
#line 34
      tmp = strlen((char const   *)s);
#line 34
      memmove((void *)s, (void const   *)(s + 1), tmp);
#line 35
      s --;
      }
    }
#line 32
    s ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 38
  return;
}
}
#line 41 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/player/readrc.c"
static int get_yesno(char *s ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
  {
#line 43
  tmp = strncmp((char const   *)s, "y", (size_t )1);
  }
#line 43
  if (tmp) {
    {
#line 43
    tmp___0 = strncmp((char const   *)s, "o", (size_t )1);
    }
#line 43
    if (tmp___0) {
#line 43
      tmp___1 = 0;
    } else {
#line 43
      tmp___1 = 1;
    }
  } else {
#line 43
    tmp___1 = 1;
  }
#line 43
  return (tmp___1);
}
}
#line 47 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/player/readrc.c"
int _xmp_read_rc(struct xmp_context *ctx___0 ) 
{ 
  struct xmp_options *o___0 ;
  FILE *rc ;
  char myrc[4096] ;
  char *hash ;
  char *var ;
  char *val ;
  char line[256] ;
  char cparm[512] ;
  char *home ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  void *__cil_tmp38 ;
  void *__cil_tmp39 ;
  void *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;
  char *__cil_tmp66 ;
  char *__cil_tmp67 ;

  {
  {
#line 49
  o___0 = & ctx___0->o;
#line 81
  tmp = getenv("HOME");
#line 81
  home = tmp;
#line 83
  snprintf((char */* __restrict  */)(myrc), (size_t )4096, (char const   */* __restrict  */)"%s/.xmp/xmp.conf",
           home);
#line 86
  rc = fopen((char const   */* __restrict  */)(myrc), (char const   */* __restrict  */)"r");
  }
#line 86
  if ((unsigned long )rc == (unsigned long )((void *)0)) {
    {
#line 87
    rc = fopen((char const   */* __restrict  */)"/etc/xmp/xmp.conf", (char const   */* __restrict  */)"r");
    }
#line 87
    if ((unsigned long )rc == (unsigned long )((void *)0)) {
#line 88
      return (-1);
    }
  }
  {
#line 93
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 93
    tmp___25 = feof(rc);
    }
#line 93
    if (tmp___25) {
#line 93
      goto while_break;
    }
    {
#line 94
    memset((void *)(line), 0, (size_t )256);
#line 95
    fscanf((FILE */* __restrict  */)rc, (char const   */* __restrict  */)"%255[^\n]",
           line);
#line 96
    fgetc(rc);
#line 99
    hash = strchr((char const   *)(line), '#');
    }
#line 99
    if (hash) {
#line 100
      *hash = (char)0;
    }
    {
#line 102
    delete_spaces(line);
#line 104
    var = strtok((char */* __restrict  */)(line), (char const   */* __restrict  */)"=\n");
    }
#line 104
    if (! var) {
#line 105
      goto while_continue;
    }
    {
#line 107
    val = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)" \t\n");
#line 116
    tmp___1 = strcmp((char const   *)var, "8bit");
    }
#line 116
    if (! tmp___1) {
      {
#line 116
      tmp___0 = get_yesno(val);
      }
#line 116
      if (tmp___0) {
#line 116
        o___0->flags |= 1 << 2;
      } else {
#line 116
        o___0->flags &= ~ (1 << 2);
      }
#line 116
      goto while_continue;
    }
    {
#line 117
    tmp___3 = strcmp((char const   *)var, "interpolate");
    }
#line 117
    if (! tmp___3) {
      {
#line 117
      tmp___2 = get_yesno(val);
      }
#line 117
      if (tmp___2) {
#line 117
        o___0->flags |= 1;
      } else {
#line 117
        o___0->flags &= -2;
      }
#line 117
      goto while_continue;
    }
    {
#line 118
    tmp___5 = strcmp((char const   *)var, "loop");
    }
#line 118
    if (! tmp___5) {
      {
#line 118
      tmp___4 = get_yesno(val);
      }
#line 118
      if (tmp___4) {
#line 118
        o___0->flags |= 1 << 3;
      } else {
#line 118
        o___0->flags &= ~ (1 << 3);
      }
#line 118
      goto while_continue;
    }
    {
#line 119
    tmp___7 = strcmp((char const   *)var, "reverse");
    }
#line 119
    if (! tmp___7) {
      {
#line 119
      tmp___6 = get_yesno(val);
      }
#line 119
      if (tmp___6) {
#line 119
        o___0->flags |= 1 << 1;
      } else {
#line 119
        o___0->flags &= ~ (1 << 1);
      }
#line 119
      goto while_continue;
    }
    {
#line 120
    tmp___9 = strcmp((char const   *)var, "pan");
    }
#line 120
    if (! tmp___9) {
      {
#line 120
      tmp___8 = get_yesno(val);
      }
#line 120
      if (tmp___8) {
#line 120
        o___0->flags |= 1 << 6;
      } else {
#line 120
        o___0->flags &= ~ (1 << 6);
      }
#line 120
      goto while_continue;
    }
    {
#line 121
    tmp___11 = strcmp((char const   *)var, "filter");
    }
#line 121
    if (! tmp___11) {
      {
#line 121
      tmp___10 = get_yesno(val);
      }
#line 121
      if (tmp___10) {
#line 121
        o___0->flags |= 1 << 8;
      } else {
#line 121
        o___0->flags &= ~ (1 << 8);
      }
#line 121
      goto while_continue;
    }
    {
#line 122
    tmp___13 = strcmp((char const   *)var, "mono");
    }
#line 122
    if (! tmp___13) {
      {
#line 122
      tmp___12 = get_yesno(val);
      }
#line 122
      if (tmp___12) {
#line 122
        o___0->outfmt |= 1 << 2;
      } else {
#line 122
        o___0->outfmt &= ~ (1 << 2);
      }
#line 122
      goto while_continue;
    }
    {
#line 123
    tmp___14 = strcmp((char const   *)var, "amplify");
    }
#line 123
    if (! tmp___14) {
      {
#line 123
      o___0->amplify = atoi((char const   *)val);
      }
#line 123
      goto while_continue;
    }
    {
#line 124
    tmp___15 = strcmp((char const   *)var, "mix");
    }
#line 124
    if (! tmp___15) {
      {
#line 124
      o___0->mix = atoi((char const   *)val);
      }
#line 124
      goto while_continue;
    }
    {
#line 125
    tmp___16 = strcmp((char const   *)var, "crunch");
    }
#line 125
    if (! tmp___16) {
      {
#line 125
      o___0->crunch = atoi((char const   *)val);
      }
#line 125
      goto while_continue;
    }
    {
#line 126
    tmp___17 = strcmp((char const   *)var, "chorus");
    }
#line 126
    if (! tmp___17) {
      {
#line 126
      o___0->chorus = atoi((char const   *)val);
      }
#line 126
      goto while_continue;
    }
    {
#line 127
    tmp___18 = strcmp((char const   *)var, "reverb");
    }
#line 127
    if (! tmp___18) {
      {
#line 127
      o___0->reverb = atoi((char const   *)val);
      }
#line 127
      goto while_continue;
    }
    {
#line 128
    tmp___19 = strcmp((char const   *)var, "srate");
    }
#line 128
    if (! tmp___19) {
      {
#line 128
      o___0->freq = atoi((char const   *)val);
      }
#line 128
      goto while_continue;
    }
    {
#line 129
    tmp___20 = strcmp((char const   *)var, "time");
    }
#line 129
    if (! tmp___20) {
      {
#line 129
      o___0->time = atoi((char const   *)val);
      }
#line 129
      goto while_continue;
    }
    {
#line 130
    tmp___21 = strcmp((char const   *)var, "verbosity");
    }
#line 130
    if (! tmp___21) {
      {
#line 130
      o___0->verbosity = atoi((char const   *)val);
      }
#line 130
      goto while_continue;
    }
    {
#line 135
    tmp___22 = strcmp((char const   *)var, "driver");
    }
#line 135
    if (! tmp___22) {
      {
#line 136
      strncpy((char */* __restrict  */)(drive_id), (char const   */* __restrict  */)val,
              (size_t )31);
#line 137
      o___0->drv_id = drive_id;
      }
#line 138
      goto while_continue;
    }
    {
#line 141
    tmp___23 = strcmp((char const   *)var, "amplify");
    }
#line 141
    if (! tmp___23) {
      {
#line 142
      o___0->amplify = atoi((char const   *)val);
      }
#line 143
      goto while_continue;
    }
    {
#line 146
    tmp___24 = strcmp((char const   *)var, "bits");
    }
#line 146
    if (! tmp___24) {
      {
#line 147
      o___0->resol = atoi((char const   *)val);
      }
#line 148
      if (o___0->resol != 16) {
#line 149
        o___0->resol = 16;
      } else
#line 148
      if (o___0->resol != 8) {
#line 149
        o___0->resol = 16;
      } else
#line 148
      if (o___0->resol != 0) {
#line 149
        o___0->resol = 16;
      }
#line 150
      goto while_continue;
    }
    {
#line 156
    snprintf((char */* __restrict  */)(cparm), (size_t )512, (char const   */* __restrict  */)"%s=%s",
             var, val);
#line 157
    xmp_set_driver_parameter(& ctx___0->o, cparm);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 160
  fclose(rc);
  }
#line 162
  return (0);
}
}
#line 166 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/player/readrc.c"
static void parse_modconf(struct xmp_context *ctx___0 , char *s , unsigned int crc___0 ,
                          unsigned int size___0 ) 
{ 
  struct xmp_player_context *p ;
  struct xmp_mod_context *m___0 ;
  struct xmp_options *o___0 ;
  FILE *rc ;
  char *hash ;
  char *var ;
  char *val ;
  char line[256] ;
  int active ;
  unsigned long tmp ;
  unsigned long tmp___0 ;
  int tmp___1 ;
  unsigned long tmp___2 ;
  unsigned long tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  void *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;
  char *__cil_tmp66 ;
  char *__cil_tmp67 ;
  char *__cil_tmp68 ;

  {
  {
#line 168
  p = & ctx___0->p;
#line 169
  m___0 = & p->m;
#line 170
  o___0 = & ctx___0->o;
#line 173
  active = 0;
#line 175
  rc = fopen((char const   */* __restrict  */)s, (char const   */* __restrict  */)"r");
  }
#line 175
  if ((unsigned long )rc == (unsigned long )((void *)0)) {
#line 176
    return;
  }
  {
#line 178
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 178
    tmp___30 = feof(rc);
    }
#line 178
    if (tmp___30) {
#line 178
      goto while_break;
    }
    {
#line 179
    memset((void *)(line), 0, (size_t )256);
#line 180
    fscanf((FILE */* __restrict  */)rc, (char const   */* __restrict  */)"%255[^\n]",
           line);
#line 181
    fgetc(rc);
#line 184
    hash = strchr((char const   *)(line), '#');
    }
#line 184
    if (hash) {
#line 185
      *hash = (char)0;
    }
#line 187
    if ((int )line[0] == 58) {
      {
#line 188
      strtok((char */* __restrict  */)(& line[1]), (char const   */* __restrict  */)" ");
#line 189
      val = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)" \t\n");
#line 190
      tmp___2 = strtoul((char const   */* __restrict  */)(& line[1]), (char **/* __restrict  */)((void *)0),
                        0);
      }
#line 190
      if (tmp___2) {
        {
#line 190
        tmp___3 = strtoul((char const   */* __restrict  */)val, (char **/* __restrict  */)((void *)0),
                          0);
        }
#line 190
        if (tmp___3) {
          {
#line 191
          tmp = strtoul((char const   */* __restrict  */)(& line[1]), (char **/* __restrict  */)((void *)0),
                        0);
          }
#line 191
          if (tmp == (unsigned long )crc___0) {
            {
#line 191
            tmp___0 = strtoul((char const   */* __restrict  */)val, (char **/* __restrict  */)((void *)0),
                              0);
            }
#line 191
            if (tmp___0 == (unsigned long )size___0) {
#line 191
              tmp___1 = 1;
            } else {
#line 191
              tmp___1 = 0;
            }
          } else {
#line 191
            tmp___1 = 0;
          }
#line 191
          active = tmp___1;
#line 193
          if (active) {
#line 193
            if (o___0->verbosity > 2) {
              {
#line 194
              report((char *)"Quirk found in %s\n", s);
              }
            }
          }
        }
      }
#line 196
      goto while_continue;
    }
#line 199
    if (! active) {
#line 200
      goto while_continue;
    }
    {
#line 202
    delete_spaces(line);
#line 204
    var = strtok((char */* __restrict  */)(line), (char const   */* __restrict  */)"=\n");
    }
#line 204
    if (! var) {
#line 205
      goto while_continue;
    }
    {
#line 207
    val = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)" \t\n");
#line 209
    tmp___5 = strcmp((char const   *)var, "8bit");
    }
#line 209
    if (! tmp___5) {
      {
#line 209
      tmp___4 = get_yesno(val);
      }
#line 209
      if (tmp___4) {
#line 209
        m___0->flags |= 1 << 2;
      } else {
#line 209
        m___0->flags &= ~ (1 << 2);
      }
#line 209
      goto while_continue;
    }
    {
#line 210
    tmp___7 = strcmp((char const   *)var, "interpolate");
    }
#line 210
    if (! tmp___7) {
      {
#line 210
      tmp___6 = get_yesno(val);
      }
#line 210
      if (tmp___6) {
#line 210
        m___0->flags |= 1;
      } else {
#line 210
        m___0->flags &= -2;
      }
#line 210
      goto while_continue;
    }
    {
#line 211
    tmp___9 = strcmp((char const   *)var, "loop");
    }
#line 211
    if (! tmp___9) {
      {
#line 211
      tmp___8 = get_yesno(val);
      }
#line 211
      if (tmp___8) {
#line 211
        m___0->flags |= 1 << 3;
      } else {
#line 211
        m___0->flags &= ~ (1 << 3);
      }
#line 211
      goto while_continue;
    }
    {
#line 212
    tmp___11 = strcmp((char const   *)var, "reverse");
    }
#line 212
    if (! tmp___11) {
      {
#line 212
      tmp___10 = get_yesno(val);
      }
#line 212
      if (tmp___10) {
#line 212
        m___0->flags |= 1 << 1;
      } else {
#line 212
        m___0->flags &= ~ (1 << 1);
      }
#line 212
      goto while_continue;
    }
    {
#line 213
    tmp___13 = strcmp((char const   *)var, "pan");
    }
#line 213
    if (! tmp___13) {
      {
#line 213
      tmp___12 = get_yesno(val);
      }
#line 213
      if (tmp___12) {
#line 213
        m___0->flags |= 1 << 6;
      } else {
#line 213
        m___0->flags &= ~ (1 << 6);
      }
#line 213
      goto while_continue;
    }
    {
#line 214
    tmp___15 = strcmp((char const   *)var, "filter");
    }
#line 214
    if (! tmp___15) {
      {
#line 214
      tmp___14 = get_yesno(val);
      }
#line 214
      if (tmp___14) {
#line 214
        m___0->flags |= 1 << 8;
      } else {
#line 214
        m___0->flags &= ~ (1 << 8);
      }
#line 214
      goto while_continue;
    }
    {
#line 215
    tmp___17 = strcmp((char const   *)var, "fixloop");
    }
#line 215
    if (! tmp___17) {
      {
#line 215
      tmp___16 = get_yesno(val);
      }
#line 215
      if (tmp___16) {
#line 215
        m___0->flags |= 1 << 7;
      } else {
#line 215
        m___0->flags &= ~ (1 << 7);
      }
#line 215
      goto while_continue;
    }
    {
#line 216
    tmp___19 = strcmp((char const   *)var, "fx9bug");
    }
#line 216
    if (! tmp___19) {
      {
#line 216
      tmp___18 = get_yesno(val);
      }
#line 216
      if (tmp___18) {
#line 216
        m___0->quirk |= 1 << 10;
      } else {
#line 216
        m___0->quirk &= ~ (1 << 10);
      }
#line 216
      goto while_continue;
    }
    {
#line 217
    tmp___21 = strcmp((char const   *)var, "vblank");
    }
#line 217
    if (! tmp___21) {
      {
#line 217
      tmp___20 = get_yesno(val);
      }
#line 217
      if (tmp___20) {
#line 217
        m___0->flags |= 1 << 4;
      } else {
#line 217
        m___0->flags &= ~ (1 << 4);
      }
#line 217
      goto while_continue;
    }
    {
#line 218
    tmp___23 = strcmp((char const   *)var, "mono");
    }
#line 218
    if (! tmp___23) {
      {
#line 218
      tmp___22 = get_yesno(val);
      }
#line 218
      if (tmp___22) {
#line 218
        o___0->outfmt |= 1 << 2;
      } else {
#line 218
        o___0->outfmt &= ~ (1 << 2);
      }
#line 218
      goto while_continue;
    }
    {
#line 219
    tmp___24 = strcmp((char const   *)var, "mix");
    }
#line 219
    if (! tmp___24) {
      {
#line 219
      o___0->mix = atoi((char const   *)val);
      }
#line 219
      goto while_continue;
    }
    {
#line 220
    tmp___25 = strcmp((char const   *)var, "crunch");
    }
#line 220
    if (! tmp___25) {
      {
#line 220
      o___0->crunch = atoi((char const   *)val);
      }
#line 220
      goto while_continue;
    }
    {
#line 221
    tmp___26 = strcmp((char const   *)var, "chorus");
    }
#line 221
    if (! tmp___26) {
      {
#line 221
      o___0->chorus = atoi((char const   *)val);
      }
#line 221
      goto while_continue;
    }
    {
#line 222
    tmp___27 = strcmp((char const   *)var, "reverb");
    }
#line 222
    if (! tmp___27) {
      {
#line 222
      o___0->reverb = atoi((char const   *)val);
      }
#line 222
      goto while_continue;
    }
    {
#line 224
    tmp___29 = strcmp((char const   *)var, "clickfilter");
    }
#line 224
    if (! tmp___29) {
      {
#line 225
      tmp___28 = get_yesno(val);
      }
#line 225
      if (tmp___28) {
#line 226
        o___0->flags |= 1 << 8;
#line 227
        o___0->cf_cutoff = 253;
      }
#line 229
      goto while_continue;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 233
  fclose(rc);
  }
#line 234
  return;
}
}
#line 237 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/player/readrc.c"
void _xmp_read_modconf(struct xmp_context *ctx___0 , uint32 crc___0 , long size___0 ) 
{ 
  char myrc[4096] ;
  char *home ;
  char *tmp ;
  void *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
  {
#line 256
  tmp = getenv("HOME");
#line 256
  home = tmp;
#line 258
  snprintf((char */* __restrict  */)(myrc), (size_t )4096, (char const   */* __restrict  */)"%s/.xmp/modules.conf",
           home);
#line 259
  parse_modconf(ctx___0, (char *)"/etc/xmp/modules.conf", crc___0, (unsigned int )size___0);
#line 260
  parse_modconf(ctx___0, myrc, crc___0, (unsigned int )size___0);
  }
#line 262
  return;
}
}
#line 766 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int abs(int __x )  __attribute__((__const__)) ;
#line 285 "src/include/common.h"
int _xmp_player_start(struct xmp_context *ctx___0 ) ;
#line 286
int _xmp_player_frame(struct xmp_context *ctx___0 ) ;
#line 287
void _xmp_player_end(struct xmp_context *ctx___0 ) ;
#line 73 "src/include/driver.h"
int xmp_drv_on(struct xmp_context *ctx___0 , int num ) ;
#line 74
void xmp_drv_off(struct xmp_context *ctx___0 ) ;
#line 78
int xmp_drv_setpatch(struct xmp_context *ctx___0 , int chn , int ins , int smp , int note ,
                     int nna___0 , int dct___0 , int dca , int flg , int cont_sample ) ;
#line 84
void xmp_drv_retrig(struct xmp_context *ctx___0 , int chn ) ;
#line 85
void xmp_drv_setvol(struct xmp_context *ctx___0 , int chn , int vol ) ;
#line 86
void xmp_drv_voicepos(struct xmp_context *ctx___0 , int chn , int pos___0 ) ;
#line 87
void xmp_drv_setbend(struct xmp_context *ctx___0 , int chn , int bend ) ;
#line 88
void xmp_drv_setpan(struct xmp_context *ctx___0 , int chn , int pan ) ;
#line 89
void xmp_drv_seteffect(struct xmp_context *ctx___0 , int chn , int type , int val ) ;
#line 90
int xmp_drv_cstat(struct xmp_context *ctx___0 , int chn ) ;
#line 91
void xmp_drv_resetchannel(struct xmp_context *ctx___0 , int chn ) ;
#line 93
void xmp_drv_reset(struct xmp_context *ctx___0 ) ;
#line 94
double xmp_drv_sync(struct xmp_context *ctx___0 , double step ) ;
#line 95
int xmp_drv_getmsg(struct xmp_context *ctx___0 ) ;
#line 96
void xmp_drv_stoptimer(struct xmp_context *ctx___0 ) ;
#line 98
void xmp_drv_starttimer(struct xmp_context *ctx___0 ) ;
#line 99
void xmp_drv_echoback(struct xmp_context *ctx___0 , int msg ) ;
#line 100
void xmp_drv_bufwipe(struct xmp_context *ctx___0 ) ;
#line 101
void xmp_drv_bufdump(struct xmp_context *ctx___0 ) ;
#line 22 "src/include/period.h"
int period_to_bend(double p , int n___0 , int limit , int gliss , int type ) ;
#line 41 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/player/player.c"
static struct retrig_t rval[17]  = 
#line 41 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/player/player.c"
  {      {0, 1, 1}, 
        {-1, 1, 1}, 
        {-2, 1, 1}, 
        {-4, 1, 1}, 
        {-8, 1, 1}, 
        {-16, 1, 1}, 
        {0, 2, 3}, 
        {0, 1, 2}, 
        {0, 1, 1}, 
        {1, 1, 1}, 
        {2, 1, 1}, 
        {4, 1, 1}, 
        {8, 1, 1}, 
        {16, 1, 1}, 
        {0, 3, 2}, 
        {0, 2, 1}, 
        {0, 0, 1}};
#line 50 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/player/player.c"
static int waveform[4][64]  = { {        0,        24,        49,        74, 
            97,        120,        141,        161, 
            180,        197,        212,        224, 
            235,        244,        250,        253, 
            255,        253,        250,        244, 
            235,        224,        212,        197, 
            180,        161,        141,        120, 
            97,        74,        49,        24, 
            0,        -24,        -49,        -74, 
            -97,        -120,        -141,        -161, 
            -180,        -197,        -212,        -224, 
            -235,        -244,        -250,        -253, 
            -255,        -253,        -250,        -244, 
            -235,        -224,        -212,        -197, 
            -180,        -161,        -141,        -120, 
            -97,        -74,        -49,        -24}, 
   {        0,        -8,        -16,        -24, 
            -32,        -40,        -48,        -56, 
            -64,        -72,        -80,        -88, 
            -96,        -104,        -112,        -120, 
            -128,        -136,        -144,        -152, 
            -160,        -168,        -176,        -184, 
            -192,        -200,        -208,        -216, 
            -224,        -232,        -240,        -248, 
            255,        248,        240,        232, 
            224,        216,        208,        200, 
            192,        184,        176,        168, 
            160,        152,        144,        136, 
            128,        120,        112,        104, 
            96,        88,        80,        72, 
            64,        56,        48,        40, 
            32,        24,        16,        8}, 
   {        255,        255,        255,        255, 
            255,        255,        255,        255, 
            255,        255,        255,        255, 
            255,        255,        255,        255, 
            255,        255,        255,        255, 
            255,        255,        255,        255, 
            255,        255,        255,        255, 
            255,        255,        255,        255, 
            -255,        -255,        -255,        -255, 
            -255,        -255,        -255,        -255, 
            -255,        -255,        -255,        -255, 
            -255,        -255,        -255,        -255, 
            -255,        -255,        -255,        -255, 
            -255,        -255,        -255,        -255, 
            -255,        -255,        -255,        -255, 
            -255,        -255,        -255,        -255}, 
   {        0,        8,        16,        24, 
            32,        40,        48,        56, 
            64,        72,        80,        88, 
            96,        104,        112,        120, 
            128,        136,        144,        152, 
            160,        168,        176,        184, 
            192,        200,        208,        216, 
            224,        232,        240,        248, 
            -255,        -248,        -240,        -232, 
            -224,        -216,        -208,        -200, 
            -192,        -184,        -176,        -168, 
            -160,        -152,        -144,        -136, 
            -128,        -120,        -112,        -104, 
            -96,        -88,        -80,        -72, 
            -64,        -56,        -48,        -40, 
            -32,        -24,        -16,        -8}};
#line 86
static int fetch_channel(struct xmp_context *ctx___0 , struct xxm_event *e , int chn ,
                         int ctl ) ;
#line 87
static void play_channel(struct xmp_context *ctx___0 , int chn , int t ) ;
#line 92 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/player/player.c"
static void dummy___2(unsigned long ul ) 
{ 


  {
#line 95
  return;
}
}
#line 98 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/player/player.c"
static int get_envelope(int16 *env , int p , int x ) 
{ 
  int x1 ;
  int x2 ;
  int y1 ;
  int y2 ;

  {
#line 102
  p --;
#line 102
  if (p < 0) {
#line 103
    return (64);
  }
#line 105
  p <<= 1;
#line 107
  x1 = (int )*(env + p);
#line 107
  if (x1 <= x) {
#line 108
    return ((int )*(env + (p + 1)));
  }
  {
#line 110
  while (1) {
    while_continue: /* CIL Label */ ;
#line 111
    p -= 2;
#line 112
    x1 = (int )*(env + p);
#line 110
    if (x1 > x) {
#line 110
      if (! p) {
#line 110
        goto while_break;
      }
    } else {
#line 110
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 115
  y1 = (int )*(env + (p + 1));
#line 116
  x2 = (int )*(env + (p + 2));
#line 117
  y2 = (int )*(env + (p + 3));
#line 119
  return (((y2 - y1) * (x - x1)) / (x2 - x1) + y1);
}
}
#line 123 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/player/player.c"
static int do_envelope(struct xmp_context *ctx___0 , struct xxm_envinfo *ei , uint16 *env ,
                       uint16 *x , int rl , int chn ) 
{ 
  struct xmp_player_context *p ;
  struct xmp_mod_context *m___0 ;
  int loop ;

  {
#line 125
  p = & ctx___0->p;
#line 126
  m___0 = & p->m;
#line 129
  if ((int )*x < 65535) {
#line 130
    *x = (uint16 )((int )*x + 1);
  }
#line 132
  if (! (ei->flg & 1)) {
#line 133
    return (0);
  }
#line 135
  if (ei->npt <= 0) {
#line 136
    return (0);
  }
#line 138
  if (ei->lps >= ei->npt) {
#line 139
    loop = 0;
  } else
#line 138
  if (ei->lpe >= ei->npt) {
#line 139
    loop = 0;
  } else {
#line 141
    loop = ei->flg & 4;
  }
#line 143
  if (m___0->quirk & (1 << 3)) {
#line 144
    if (! rl) {
#line 144
      if (ei->flg & 2) {
#line 145
        if ((int )*x >= (int )*(env + (ei->sue << 1))) {
#line 146
          *x = *(env + (ei->sus << 1));
        }
      } else {
#line 144
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 148
    if (loop) {
#line 149
      if ((int )*x >= (int )*(env + (ei->lpe << 1))) {
#line 150
        *x = *(env + (ei->lps << 1));
      }
    }
  } else {
#line 153
    if (! rl) {
#line 153
      if (ei->flg & 2) {
#line 153
        if ((int )*x > (int )*(env + (ei->sus << 1))) {
#line 154
          *x = *(env + (ei->sus << 1));
        }
      }
    }
#line 155
    if (loop) {
#line 155
      if ((int )*x >= (int )*(env + (ei->lpe << 1))) {
#line 156
        if (rl) {
#line 156
          if (ei->flg & 2) {
#line 156
            if (! (ei->sus == ei->lpe)) {
#line 157
              *x = *(env + (ei->lps << 1));
            }
          } else {
#line 157
            *x = *(env + (ei->lps << 1));
          }
        } else {
#line 157
          *x = *(env + (ei->lps << 1));
        }
      }
    }
  }
#line 160
  if (chn < 0) {
#line 161
    return (0);
  }
#line 163
  rl = (ei->npt - 1) << 1;
#line 163
  if ((int )*x > (int )*(env + rl)) {
#line 164
    if (! *(env + (rl + 1))) {
      {
#line 165
      xmp_drv_resetchannel(ctx___0, chn);
      }
    } else {
#line 167
      return (m___0->quirk & (1 << 2));
    }
  }
#line 170
  return (0);
}
}
#line 174 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/player/player.c"
__inline static int copy_channel(struct xmp_player_context *p , int to , int from ) 
{ 


  {
#line 176
  if (to > 0) {
#line 176
    if (to != from) {
      {
#line 177
      memcpy((void */* __restrict  */)(p->xc_data + to), (void const   */* __restrict  */)(p->xc_data + from),
             (size_t )sizeof(struct xmp_channel ));
      }
    }
  }
#line 179
  return (to);
}
}
#line 183 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/player/player.c"
__inline static void reset_channel(struct xmp_context *ctx___0 ) 
{ 
  struct xmp_player_context *p ;
  struct xmp_driver_context *d ;
  int i___3 ;
  struct xmp_channel *xc ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 185
  p = & ctx___0->p;
#line 186
  d = & ctx___0->d;
#line 190
  synth_reset();
#line 191
  memset((void *)p->xc_data, 0, (size_t )(sizeof(struct xmp_channel ) * (unsigned long )d->numchn));
#line 193
  i___3 = d->numchn;
  }
  {
#line 193
  while (1) {
    while_continue: /* CIL Label */ ;
#line 193
    tmp___1 = i___3;
#line 193
    i___3 --;
#line 193
    if (! tmp___1) {
#line 193
      goto while_break;
    }
#line 194
    xc = p->xc_data + i___3;
#line 195
    tmp___0 = -1;
#line 195
    xc->key = tmp___0;
#line 195
    tmp = tmp___0;
#line 195
    xc->ins = tmp;
#line 195
    xc->insdef = tmp;
  }
  while_break: /* CIL Label */ ;
  }
#line 197
  i___3 = d->numtrk;
  {
#line 197
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 197
    tmp___2 = i___3;
#line 197
    i___3 --;
#line 197
    if (! tmp___2) {
#line 197
      goto while_break___0;
    }
#line 198
    xc = p->xc_data + i___3;
#line 199
    xc->masterpan = p->m.xxc[i___3].pan;
#line 200
    xc->mastervol = p->m.xxc[i___3].vol;
#line 201
    xc->cutoff = 255;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 203
  return;
}
}
#line 206 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/player/player.c"
__inline static void fetch_row(struct xmp_context *ctx___0 , int ord , int row ) 
{ 
  int count ;
  int chn ;
  struct xmp_player_context *p ;
  struct xmp_mod_context *m___0 ;
  int tmp ;

  {
#line 209
  p = & ctx___0->p;
#line 210
  m___0 = & p->m;
#line 212
  count = 0;
#line 213
  chn = 0;
  {
#line 213
  while (1) {
    while_continue: /* CIL Label */ ;
#line 213
    if (! (chn < (p->m.xxh)->chn)) {
#line 213
      goto while_break;
    }
    {
#line 214
    tmp = fetch_channel(ctx___0, & (*(m___0->xxt + (*(m___0->xxp + ord))->info[chn].index))->event[row],
                        chn, 1);
    }
#line 214
    if (tmp != 0) {
#line 215
      (*(p->fetch_ctl + chn)) ++;
#line 216
      count ++;
    }
#line 213
    chn ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 220
  chn = 0;
  {
#line 220
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 220
    if (! count) {
#line 220
      goto while_break___0;
    }
#line 221
    if (*(p->fetch_ctl + chn)) {
      {
#line 222
      fetch_channel(ctx___0, & (*(m___0->xxt + (*(m___0->xxp + ord))->info[chn].index))->event[row],
                    chn, 0);
#line 223
      *(p->fetch_ctl + chn) = 0;
#line 224
      count --;
      }
    }
#line 220
    chn ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 227
  return;
}
}
#line 230 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/player/player.c"
__inline static void play_frame(struct xmp_context *ctx___0 , int tick ) 
{ 
  struct xmp_driver_context *d ;
  int i___3 ;

  {
#line 232
  d = & ctx___0->d;
#line 235
  i___3 = 0;
  {
#line 235
  while (1) {
    while_continue: /* CIL Label */ ;
#line 235
    if (! (i___3 < d->numchn)) {
#line 235
      goto while_break;
    }
    {
#line 236
    play_channel(ctx___0, i___3, tick);
#line 235
    i___3 ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 237
  return;
}
}
#line 240 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/player/player.c"
static int fetch_channel(struct xmp_context *ctx___0 , struct xxm_event *e , int chn ,
                         int ctl ) 
{ 
  struct xmp_player_context *p ;
  struct xmp_mod_context *m___0 ;
  int xins ;
  int ins ;
  int smp ;
  int note ;
  int key ;
  int flg ;
  struct xmp_channel *xc ;
  int cont_sample ;
  uint8 tmp ;
  uint8 tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  double tmp___5 ;
  int tmp___6 ;
  uint16 tmp___7 ;
  uint16 tmp___8 ;

  {
#line 242
  p = & ctx___0->p;
#line 243
  m___0 = & p->m;
#line 248
  xc = p->xc_data + chn;
#line 251
  if ((int )e->fxt == 15) {
#line 251
    if ((int )e->fxp < 32) {
#line 251
      goto _L;
    } else {
#line 251
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 251
  if ((int )e->fxt == 163) {
    _L: /* CIL Label */ 
#line 252
    if (e->fxp) {
#line 253
      p->tempo = (int )e->fxp;
    }
  }
#line 255
  if ((int )e->f2t == 15) {
#line 255
    if ((int )e->f2p < 32) {
#line 255
      goto _L___1;
    } else {
#line 255
      goto _L___2;
    }
  } else
  _L___2: /* CIL Label */ 
#line 255
  if ((int )e->f2t == 163) {
    _L___1: /* CIL Label */ 
#line 256
    if (e->f2p) {
#line 257
      p->tempo = (int )e->f2p;
    }
  }
#line 261
  if ((int )e->fxt == 14) {
#line 261
    if (((int )e->fxp & 240) >> 4 == 13) {
#line 262
      xc->delay = ((int )e->fxp & 15) + 1;
#line 263
      xc->delayed_event = e;
#line 264
      if (e->ins) {
#line 265
        xc->delayed_ins = (int )e->ins;
      }
#line 266
      tmp = (uint8 )0;
#line 266
      e->fxp = tmp;
#line 266
      e->fxt = tmp;
#line 267
      return (0);
    }
  }
#line 269
  if ((int )e->f2t == 14) {
#line 269
    if (((int )e->f2p & 240) >> 4 == 13) {
#line 270
      xc->delay = ((int )e->f2p & 15) + 1;
#line 271
      xc->delayed_event = e;
#line 272
      if (e->ins) {
#line 273
        xc->delayed_ins = (int )e->ins;
      }
#line 274
      tmp___0 = (uint8 )0;
#line 274
      e->f2p = tmp___0;
#line 274
      e->f2t = tmp___0;
#line 275
      return (0);
    }
  }
#line 279
  if (e->note) {
#line 279
    if (! e->ins) {
#line 279
      if (xc->delayed_ins) {
#line 279
        if (m___0->quirk & (1 << 19)) {
#line 280
          e->ins = (uint8 )xc->delayed_ins;
#line 281
          xc->delayed_ins = 0;
        }
      }
    }
  }
#line 284
  flg = 0;
#line 285
  note = -1;
#line 285
  ins = note;
#line 285
  smp = ins;
#line 286
  xins = xc->ins;
#line 287
  key = (int )e->note;
#line 288
  cont_sample = 0;
#line 292
  if (e->ins) {
#line 293
    ins = (int )e->ins - 1;
#line 294
    flg = 90112;
#line 295
    xc->fadeout = 32768;
#line 296
    xc->per_flags = 0;
#line 298
    if (m___0->quirk & (1 << 8)) {
#line 299
      if (! (! (xc->flags & 16777216))) {
#line 300
        xins = xc->insdef;
#line 301
        xc->flags &= -16777217;
      }
    } else
#line 303
    if ((uint32 )ins < (uint32 )(m___0->xxh)->ins) {
#line 303
      if ((m___0->xxih + ins)->nsm) {
#line 304
        if (! key) {
#line 304
          if (m___0->quirk & (1 << 6)) {
#line 305
            if (xins == ins) {
#line 306
              flg = 73728;
            } else {
#line 308
              key = xc->key + 1;
            }
          }
        }
#line 310
        xins = ins;
      } else {
#line 303
        goto _L___3;
      }
    } else {
      _L___3: /* CIL Label */ 
#line 312
      if (! (m___0->quirk & (1 << 5))) {
        {
#line 313
        xmp_drv_resetchannel(ctx___0, chn);
        }
      }
#line 315
      if (m___0->quirk & (1 << 4)) {
#line 316
        ins = -1;
#line 317
        flg = 0;
      }
    }
#line 321
    xc->insdef = ins;
#line 322
    tmp___1 = 0;
#line 322
    xc->med_aidx = tmp___1;
#line 322
    xc->med_arp = tmp___1;
  }
#line 327
  if (key) {
#line 328
    flg |= 4194304;
#line 330
    if (key == 131) {
#line 331
      xc->flags |= 33554432;
#line 332
      flg &= -24577;
    } else
#line 333
    if (key == 130) {
      {
#line 334
      xmp_drv_resetchannel(ctx___0, chn);
      }
    } else
#line 335
    if (key == 129) {
#line 336
      xc->flags |= 67108864;
#line 337
      flg &= -24577;
    } else
#line 338
    if ((int )e->fxt == 3) {
#line 338
      goto _L___4;
    } else
#line 338
    if ((int )e->f2t == 3) {
#line 338
      goto _L___4;
    } else
#line 338
    if ((int )e->fxt == 5) {
#line 338
      goto _L___4;
    } else
#line 338
    if ((int )e->f2t == 5) {
      _L___4: /* CIL Label */ 
#line 341
      if (m___0->quirk & (1 << 14)) {
#line 341
        if (e->ins) {
#line 341
          if (xc->ins != ins) {
#line 342
            flg |= 65536;
#line 343
            xins = ins;
          } else {
#line 355
            cont_sample = 1;
#line 360
            key = 0;
          }
        } else {
#line 355
          cont_sample = 1;
#line 360
          key = 0;
        }
      } else {
#line 355
        cont_sample = 1;
#line 360
        key = 0;
      }
    } else
#line 366
    if (flg & 65536) {
#line 367
      xins = ins;
    } else {
#line 369
      ins = xc->insdef;
#line 370
      flg |= 16777216;
    }
  }
#line 374
  if (! key) {
#line 375
    ins = xins;
  } else
#line 374
  if (key >= 129) {
#line 375
    ins = xins;
  }
#line 377
  if ((uint32 )ins < (uint32 )(m___0->xxh)->ins) {
#line 377
    if ((m___0->xxih + ins)->nsm) {
#line 378
      flg |= 32768;
    }
  }
#line 380
  if ((uint32 )key < 129U) {
#line 380
    if (key > 0) {
#line 381
      key --;
#line 381
      xc->key = key;
#line 383
      if (flg & 32768) {
#line 383
        if (key < 108) {
#line 384
          if ((int )(m___0->xxim + ins)->ins[key] != 255) {
#line 385
            note = (key + (*(m___0->xxi + ins) + (m___0->xxim + ins)->ins[key])->xpo) + (int )(m___0->xxim + ins)->xpo[key];
#line 387
            smp = (*(m___0->xxi + ins) + (m___0->xxim + ins)->ins[key])->sid;
          } else {
#line 389
            flg &= -4284417;
          }
        } else {
#line 383
          goto _L___5;
        }
      } else
      _L___5: /* CIL Label */ 
#line 392
      if (! (m___0->quirk & (1 << 7))) {
        {
#line 393
        xmp_drv_resetchannel(ctx___0, chn);
        }
      }
    }
  }
#line 397
  if (smp >= 0) {
    {
#line 398
    tmp___2 = xmp_drv_setpatch(ctx___0, chn, ins, smp, note, (*(m___0->xxi + ins) + (m___0->xxim + ins)->ins[key])->nna,
                               (*(m___0->xxi + ins) + (m___0->xxim + ins)->ins[key])->dct,
                               (*(m___0->xxi + ins) + (m___0->xxim + ins)->ins[key])->dca,
                               ctl, cont_sample);
#line 398
    tmp___3 = copy_channel(p, tmp___2, chn);
    }
#line 398
    if (tmp___3 < 0) {
#line 404
      return (-7);
    }
#line 406
    xc->smp = smp;
  }
#line 410
  tmp___4 = 0;
#line 410
  xc->retrig = tmp___4;
#line 410
  xc->delay = tmp___4;
#line 411
  xc->flags = (int )((unsigned int )flg | ((unsigned int )xc->flags & 4278190080U));
#line 413
  xc->a_idx = 0;
#line 414
  xc->a_size = 1;
#line 415
  xc->a_val[0] = 0;
#line 417
  if ((uint32 )xins >= (uint32 )(m___0->xxh)->ins) {
#line 418
    xc->flags &= -32769;
  } else
#line 417
  if (! (m___0->xxih + xins)->nsm) {
#line 418
    xc->flags &= -32769;
  } else {
#line 420
    xc->flags |= 32768;
  }
#line 423
  xc->ins = xins;
#line 426
  if (e->vol) {
#line 427
    xc->volume = (int )e->vol - 1;
#line 428
    xc->flags &= -8193;
#line 429
    xc->flags |= 131072;
  }
#line 432
  if (! (! (xc->flags & 65536))) {
#line 433
    xc->offset_val = 0;
  } else
#line 432
  if (m___0->quirk & (1 << 9)) {
#line 433
    xc->offset_val = 0;
  }
  {
#line 438
  process_fx(ctx___0, chn, e->note, e->f2t, e->f2p, xc, 1);
#line 439
  process_fx(ctx___0, chn, e->note, e->fxt, e->fxp, xc, 0);
  }
#line 441
  if (! (! (! (xc->flags & 32768)))) {
#line 442
    xc->volume = 0;
#line 443
    return (0);
  }
#line 446
  if (note >= 0) {
#line 447
    xc->note = note;
#line 449
    if (cont_sample == 0) {
      {
#line 450
      xmp_drv_voicepos(ctx___0, chn, xc->offset_val);
      }
#line 451
      if (! (! (xc->flags & 1024))) {
#line 451
        if (m___0->quirk & (1 << 10)) {
#line 452
          xc->offset_val <<= 1;
        }
      }
    }
#line 454
    xc->flags &= -1025;
#line 457
    if (! (! (! (xc->flags & 256)))) {
#line 458
      xc->pan = (*(m___0->xxi + ins) + (m___0->xxim + ins)->ins[key])->pan;
    }
#line 460
    if (! (! (! (xc->flags & 512)))) {
#line 461
      xc->finetune = (*(m___0->xxi + ins) + (m___0->xxim + ins)->ins[key])->fin;
    }
    {
#line 463
    tmp___5 = note_to_period(note, xc->finetune, (m___0->xxh)->flg & 1);
#line 463
    xc->period = tmp___5;
#line 463
    xc->s_end = (int )tmp___5;
#line 466
    tmp___6 = 0;
#line 466
    xc->t_idx = tmp___6;
#line 466
    xc->y_idx = tmp___6;
#line 468
    xc->flags |= 262144;
    }
  }
#line 471
  if (xc->key == 255) {
#line 472
    return (0);
  } else
#line 471
  if ((int )(p->m.xxim + xc->ins)->ins[xc->key] == 255) {
#line 472
    return (0);
  }
#line 474
  if (! (! (xc->flags & 16384))) {
#line 476
    xc->flags &= -100663297;
#line 477
    xc->gvl = (*(p->m.xxi + xc->ins) + (p->m.xxim + xc->ins)->ins[xc->key])->gvl;
#line 478
    xc->insvib_swp = (*(p->m.xxi + xc->ins))->vsw;
#line 479
    xc->insvib_idx = 0;
#line 480
    tmp___8 = (uint16 )0;
#line 480
    xc->f_idx = tmp___8;
#line 480
    tmp___7 = tmp___8;
#line 480
    xc->p_idx = tmp___7;
#line 480
    xc->v_idx = tmp___7;
#line 481
    if ((*(p->m.xxi + xc->ins))->ifc & 128) {
#line 481
      xc->cutoff = ((*(p->m.xxi + xc->ins))->ifc - 128) * 2;
    } else {
#line 481
      xc->cutoff = 255;
    }
#line 482
    if ((*(p->m.xxi + xc->ins))->ifr & 128) {
#line 482
      xc->resonance = ((*(p->m.xxi + xc->ins))->ifr - 128) * 2;
    } else {
#line 482
      xc->resonance = 0;
    }
  }
#line 485
  if (! (! (xc->flags & 8192))) {
#line 486
    xc->volume = (*(p->m.xxi + xc->ins) + (p->m.xxim + xc->ins)->ins[xc->key])->vol;
#line 487
    xc->flags |= 393216;
  }
#line 490
  if (m___0->quirk & (1 << 11)) {
#line 490
    if (! (! (xc->flags & 131072))) {
#line 490
      if (m___0->volbase) {
#line 491
        xc->volume = (xc->volume * m___0->volume) / m___0->volbase;
      }
    }
  }
#line 493
  return (0);
}
}
#line 497 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/player/player.c"
static void play_channel(struct xmp_context *ctx___0 , int chn , int t ) 
{ 
  struct xmp_channel *xc ;
  int finalvol ;
  int finalpan ;
  int cutoff ;
  int act ;
  int pan_envelope ;
  int frq_envelope ;
  int med_arp ;
  int vibrato ;
  int med_vibrato ;
  uint16 vol_envelope ;
  struct xmp_player_context *p ;
  struct xmp_driver_context *d ;
  struct xmp_mod_context *m___0 ;
  struct xmp_options *o___0 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;

  {
#line 504
  p = & ctx___0->p;
#line 505
  d = & ctx___0->d;
#line 506
  m___0 = & p->m;
#line 507
  o___0 = & ctx___0->o;
#line 509
  xc = p->xc_data + chn;
#line 512
  if (xc->delay) {
#line 512
    (xc->delay) --;
#line 512
    if (! xc->delay) {
      {
#line 513
      tmp = fetch_channel(ctx___0, xc->delayed_event, chn, 1);
      }
#line 513
      if (tmp != 0) {
        {
#line 514
        fetch_channel(ctx___0, xc->delayed_event, chn, 0);
        }
      }
    }
  }
  {
#line 517
  act = xmp_drv_cstat(ctx___0, chn);
  }
#line 517
  if (act == -1) {
#line 518
    return;
  }
#line 520
  if (! t) {
#line 520
    if (act != 256) {
#line 521
      if (! (! (! (xc->flags & 32768)))) {
        {
#line 522
        xmp_drv_resetchannel(ctx___0, chn);
        }
#line 523
        return;
      } else
#line 521
      if (act == 0) {
        {
#line 522
        xmp_drv_resetchannel(ctx___0, chn);
        }
#line 523
        return;
      }
#line 525
      tmp___1 = 0;
#line 525
      xc->a_idx = tmp___1;
#line 525
      tmp___0 = tmp___1;
#line 525
      xc->retrig = tmp___0;
#line 525
      xc->delay = tmp___0;
#line 526
      xc->a_size = 1;
#line 527
      xc->a_val[0] = 0;
#line 528
      xc->flags = (int )((unsigned int )xc->flags & 4278222848U);
    }
  }
#line 531
  if (! (! (! (xc->flags & 32768)))) {
#line 532
    return;
  }
#line 535
  if (! t) {
#line 535
    if (! (! (xc->flags & 4259840))) {
#line 535
      tmp___2 = 1;
    } else {
#line 535
      tmp___2 = 0;
    }
  } else {
#line 535
    tmp___2 = 0;
  }
  {
#line 535
  xmp_med_synth(ctx___0, chn, xc, tmp___2);
  }
#line 537
  if (! (! (xc->flags & 67108864))) {
#line 537
    if (! ((p->m.xxih + xc->ins)->aei.flg & 1)) {
#line 538
      xc->fadeout = 0;
    }
  }
#line 540
  if (! (! (xc->flags & 100663296))) {
#line 540
    goto _L;
  } else
#line 540
  if (act == 3) {
#line 540
    goto _L;
  } else
#line 540
  if (act == 2) {
    _L: /* CIL Label */ 
#line 541
    if (xc->fadeout > (p->m.xxih + xc->ins)->rls) {
#line 541
      xc->fadeout -= (p->m.xxih + xc->ins)->rls;
    } else {
#line 541
      xc->fadeout = 0;
    }
#line 543
    if (xc->fadeout == 0) {
#line 552
      if (m___0->flags & (1 << 5)) {
        {
#line 553
        xmp_drv_resetchannel(ctx___0, chn);
        }
#line 554
        return;
      } else {
#line 556
        xc->volume = 0;
      }
    }
  }
#line 561
  if ((p->m.xxih + xc->ins)->aei.flg & 1) {
    {
#line 561
    tmp___3 = get_envelope((int16 *)*(p->m.xxae + xc->ins), (p->m.xxih + xc->ins)->aei.npt,
                           (int )xc->v_idx);
#line 561
    vol_envelope = (uint16 )tmp___3;
    }
  } else {
#line 561
    vol_envelope = (uint16 )64;
  }
#line 564
  if ((p->m.xxih + xc->ins)->pei.flg & 1) {
    {
#line 564
    tmp___4 = get_envelope((int16 *)*(p->m.xxpe + xc->ins), (p->m.xxih + xc->ins)->pei.npt,
                           (int )xc->p_idx);
#line 564
    pan_envelope = tmp___4;
    }
  } else {
#line 564
    pan_envelope = 32;
  }
#line 567
  if ((p->m.xxih + xc->ins)->fei.flg & 1) {
    {
#line 567
    tmp___5 = get_envelope((int16 *)*(p->m.xxfe + xc->ins), (p->m.xxih + xc->ins)->fei.npt,
                           (int )xc->f_idx);
#line 567
    frq_envelope = (int )((int16 )tmp___5);
    }
  } else {
#line 567
    frq_envelope = 0;
  }
#line 571
  if (! (! (xc->flags & 67108864))) {
#line 571
    tmp___6 = 1;
  } else
#line 571
  if (act == 2) {
#line 571
    tmp___6 = 1;
  } else {
#line 571
    tmp___6 = 0;
  }
  {
#line 571
  tmp___7 = do_envelope(ctx___0, & (p->m.xxih + xc->ins)->aei, *(p->m.xxae + xc->ins),
                        & xc->v_idx, tmp___6, chn);
  }
#line 571
  if (tmp___7) {
#line 572
    xc->flags |= 33554432;
  }
#line 573
  if (! (! (xc->flags & 67108864))) {
#line 573
    tmp___8 = 1;
  } else
#line 573
  if (act == 2) {
#line 573
    tmp___8 = 1;
  } else {
#line 573
    tmp___8 = 0;
  }
  {
#line 573
  do_envelope(ctx___0, & (p->m.xxih + xc->ins)->pei, *(p->m.xxpe + xc->ins), & xc->p_idx,
              tmp___8, -1323);
  }
#line 574
  if (! (! (xc->flags & 67108864))) {
#line 574
    tmp___9 = 1;
  } else
#line 574
  if (act == 2) {
#line 574
    tmp___9 = 1;
  } else {
#line 574
    tmp___9 = 0;
  }
  {
#line 574
  do_envelope(ctx___0, & (p->m.xxih + xc->ins)->fei, *(p->m.xxfe + xc->ins), & xc->f_idx,
              tmp___9, -1137);
  }
#line 577
  if (! (! (xc->flags & 1048576))) {
#line 578
    (xc->ns_count) --;
#line 578
    if (! xc->ns_count) {
      {
#line 579
      xc->note += xc->ns_val;
#line 580
      xc->period = note_to_period(xc->note, xc->finetune, (m___0->xxh)->flg & 1);
#line 582
      xc->ns_count = xc->ns_speed;
      }
    }
  }
#line 587
  if (xc->retrig) {
#line 588
    (xc->rcount) --;
#line 588
    if (! xc->rcount) {
#line 589
      if (xc->rtype < 16) {
        {
#line 590
        xmp_drv_retrig(ctx___0, chn);
        }
      }
#line 591
      xc->volume += rval[xc->rtype].s;
#line 592
      xc->volume *= rval[xc->rtype].m;
#line 593
      xc->volume /= rval[xc->rtype].d;
#line 594
      xc->rcount = xc->retrig;
    }
  }
#line 598
  finalvol = xc->volume;
#line 600
  if (! (! (xc->flags & 32))) {
#line 601
    finalvol += (waveform[xc->t_type][xc->t_idx] * xc->t_depth) / 512;
  }
#line 602
  if (finalvol > p->gvol_base) {
#line 603
    finalvol = p->gvol_base;
  }
#line 604
  if (finalvol < 0) {
#line 605
    finalvol = 0;
  }
#line 607
  finalvol = finalvol * xc->fadeout >> 5;
#line 609
  if (m___0->quirk & (1 << 11)) {
#line 609
    tmp___10 = 64;
  } else {
#line 609
    tmp___10 = m___0->volume;
  }
#line 609
  finalvol = (int )((uint32 )(((((int )vol_envelope * tmp___10) * xc->mastervol) / 64) * ((finalvol * 64) / p->gvol_base)) >> 18);
#line 614
  if (m___0->vol_xlat) {
#line 615
    finalvol = *(m___0->vol_xlat + (finalvol >> 4)) << 4;
  }
#line 617
  if ((m___0->xxh)->flg & 4) {
#line 618
    finalvol = (finalvol * (p->m.xxih + xc->ins)->vol) * xc->gvl >> 12;
  }
  {
#line 620
  med_vibrato = get_med_vibrato(xc);
  }
#line 622
  if (! (! (xc->flags & 16))) {
#line 622
    tmp___11 = waveform[xc->y_type][xc->y_idx] * xc->y_depth >> 10;
  } else
#line 622
  if (! (! (xc->per_flags & 16))) {
#line 622
    tmp___11 = waveform[xc->y_type][xc->y_idx] * xc->y_depth >> 10;
  } else {
#line 622
    tmp___11 = 0;
  }
  {
#line 622
  vibrato = tmp___11 + (waveform[(*(p->m.xxi + xc->ins))->vwf][xc->insvib_idx] * (*(p->m.xxi + xc->ins))->vde) / (1024 * (1 + xc->insvib_swp));
#line 630
  xc->pitchbend = period_to_bend((xc->period + (double )vibrato) + (double )med_vibrato,
                                 xc->note, (m___0->xxh)->flg & 2, xc->gliss, (m___0->xxh)->flg & 1);
  }
#line 638
  if ((p->m.xxih + xc->ins)->fei.flg & 8) {
#line 638
    tmp___12 = 0;
  } else {
#line 638
    tmp___12 = frq_envelope;
  }
#line 638
  xc->pitchbend += tmp___12;
#line 649
  if (m___0->flags & (1 << 6)) {
    {
#line 649
    tmp___13 = abs(xc->pan - 128);
#line 649
    finalpan = xc->pan + ((pan_envelope - 32) * (128 - tmp___13)) / 32;
    }
  } else {
#line 649
    finalpan = 128;
  }
  {
#line 651
  tmp___14 = abs(xc->masterpan - 128);
#line 651
  finalpan = xc->masterpan + ((finalpan - 128) * (128 - tmp___14)) / 128;
  }
#line 654
  if (o___0->cf_cutoff) {
#line 655
    cutoff = o___0->cf_cutoff;
  } else {
#line 657
    if ((p->m.xxih + xc->ins)->fei.flg & 8) {
#line 657
      cutoff = frq_envelope;
    } else {
#line 657
      cutoff = 255;
    }
#line 658
    cutoff = (xc->cutoff * cutoff) / 255;
  }
#line 662
  if (chn < d->numtrk) {
    {
#line 663
    xmp_drv_echoback(ctx___0, ((finalpan << 12) | (chn << 4)) | 7);
    }
#line 665
    if (! (! (xc->flags & 262156))) {
      {
#line 667
      xmp_drv_echoback(ctx___0, ((xc->key << 12) | (xc->ins << 4)) | 4);
#line 668
      xmp_drv_echoback(ctx___0, ((xc->volume << 4) * 64) / p->gvol_base | 3);
#line 671
      xmp_drv_echoback(ctx___0, (xc->pitchbend << 4) | 8);
      }
    } else
#line 665
    if (! (! (xc->per_flags & 12))) {
      {
#line 667
      xmp_drv_echoback(ctx___0, ((xc->key << 12) | (xc->ins << 4)) | 4);
#line 668
      xmp_drv_echoback(ctx___0, ((xc->volume << 4) * 64) / p->gvol_base | 3);
#line 671
      xmp_drv_echoback(ctx___0, (xc->pitchbend << 4) | 8);
      }
    }
  }
#line 676
  if (xc->tcnt_up) {
#line 676
    goto _L___0;
  } else
#line 676
  if (xc->tcnt_dn) {
    _L___0: /* CIL Label */ 
#line 677
    if (xc->tcnt_up > 0) {
#line 678
      tmp___15 = xc->tcnt_up;
#line 678
      (xc->tcnt_up) --;
#line 678
      if (tmp___15) {
#line 679
        xc->tcnt_dn = xc->tremor & 15;
      }
    } else {
#line 681
      finalvol = 0;
#line 682
      tmp___16 = xc->tcnt_dn;
#line 682
      (xc->tcnt_dn) --;
#line 682
      if (tmp___16) {
#line 683
        xc->tcnt_up = (xc->tremor & 240) >> 4;
      }
    }
  }
#line 688
  if (xc->keyoff) {
#line 689
    (xc->keyoff) --;
#line 689
    if (! xc->keyoff) {
#line 690
      xc->flags |= 67108864;
    }
  }
#line 696
  if (t % p->tempo) {
#line 696
    goto _L___1;
  } else
#line 696
  if (m___0->quirk & (1 << 13)) {
    _L___1: /* CIL Label */ 
#line 697
    if (! chn) {
#line 697
      if (p->gvol_flag) {
#line 698
        m___0->volume += p->gvol_slide;
#line 699
        if (m___0->volume < 0) {
#line 700
          m___0->volume = 0;
        } else
#line 701
        if (m___0->volume > p->gvol_base) {
#line 702
          m___0->volume = p->gvol_base;
        }
      }
    }
#line 704
    if (! (! (xc->flags & 1))) {
#line 705
      xc->volume += xc->v_val;
    } else
#line 704
    if (! (! (xc->per_flags & 1))) {
#line 705
      xc->volume += xc->v_val;
    }
#line 707
    if (! (! (xc->per_flags & 1))) {
#line 708
      if (xc->v_val > 0) {
#line 708
        if (xc->volume > m___0->volbase) {
#line 709
          xc->volume = m___0->volbase;
#line 710
          xc->per_flags &= -2;
        }
      }
#line 712
      if (xc->v_val < 0) {
#line 712
        if (xc->volume < 0) {
#line 713
          xc->volume = 0;
#line 714
          xc->per_flags &= -2;
        }
      }
    }
#line 718
    if (! (! (xc->flags & 524288))) {
#line 719
      xc->volume += xc->v_val2;
    }
#line 721
    if (! (! (xc->flags & 2048))) {
#line 722
      xc->mastervol += xc->trk_val;
    }
  }
#line 728
  if (t % p->tempo) {
#line 728
    goto _L___3;
  } else
#line 728
  if (m___0->quirk & (1 << 15)) {
    _L___3: /* CIL Label */ 
#line 730
    if (! (! (xc->flags & 2))) {
#line 731
      xc->pan += xc->p_val;
#line 732
      if (xc->pan < 0) {
#line 733
        xc->pan = 0;
      } else
#line 734
      if (xc->pan > 255) {
#line 735
        xc->pan = 255;
      }
    }
#line 738
    if (! (! (xc->flags & 8))) {
#line 739
      xc->period += (double )xc->f_val;
    } else
#line 738
    if (! (! (xc->per_flags & 8))) {
#line 739
      xc->period += (double )xc->f_val;
    }
#line 742
    if (! (! (xc->flags & 4))) {
#line 742
      goto _L___2;
    } else
#line 742
    if (! (! (xc->per_flags & 4))) {
      _L___2: /* CIL Label */ 
#line 743
      xc->period += (double )(xc->s_sgn * xc->s_val);
#line 744
      if ((double )(xc->s_sgn * xc->s_end) < (double )xc->s_sgn * xc->period) {
#line 745
        xc->period = (double )xc->s_end;
#line 746
        xc->flags &= -5;
#line 747
        xc->per_flags &= -5;
      }
    }
#line 752
    if (xc->period <= (double )8) {
#line 753
      xc->volume = 0;
    }
  }
#line 756
  if (t % p->tempo == 0) {
#line 758
    if (! (! (xc->flags & 64))) {
#line 759
      xc->volume += xc->v_fval;
    }
#line 760
    if (! (! (xc->flags & 128))) {
#line 761
      xc->period = ((double )4 * xc->period + (double )xc->f_fval) / (double )4;
    }
#line 762
    if (! (! (xc->flags & 4096))) {
#line 763
      xc->mastervol += xc->trk_fval;
    }
#line 764
    if (! (! (xc->flags & 2097152))) {
      {
#line 765
      xc->note += xc->ns_fval;
#line 766
      xc->period = note_to_period(xc->note, xc->finetune, (m___0->xxh)->flg & 1);
      }
    }
  }
#line 771
  if (xc->volume < 0) {
#line 772
    xc->volume = 0;
  } else
#line 773
  if (xc->volume > p->gvol_base) {
#line 774
    xc->volume = p->gvol_base;
  }
#line 776
  if (xc->mastervol < 0) {
#line 777
    xc->mastervol = 0;
  } else
#line 778
  if (xc->mastervol > p->gvol_base) {
#line 779
    xc->mastervol = p->gvol_base;
  }
#line 781
  if ((m___0->xxh)->flg & 1) {
#line 782
    if (xc->period < (double )0) {
#line 783
      xc->period = (double )0;
    } else
#line 784
    if (xc->period > (double )7680) {
#line 785
      xc->period = (double )7680;
    }
  } else
#line 787
  if (xc->period < (double )8) {
#line 788
    xc->period = (double )8;
  } else
#line 789
  if (xc->period > (double )6847) {
#line 790
    xc->period = (double )6847;
  }
#line 794
  xc->insvib_idx += (*(p->m.xxi + xc->ins))->vra >> 2;
#line 795
  xc->insvib_idx %= 64;
#line 796
  if (xc->insvib_swp > 1) {
#line 797
    xc->insvib_swp -= 2;
  } else {
#line 799
    xc->insvib_swp = 0;
  }
  {
#line 800
  xc->y_idx += xc->y_rate;
#line 801
  xc->y_idx %= 64;
#line 802
  xc->t_idx += xc->t_rate;
#line 803
  xc->t_idx %= 64;
#line 804
  (xc->a_idx) ++;
#line 805
  xc->a_idx %= xc->a_size;
#line 808
  med_arp = get_med_arp(p, xc);
  }
#line 811
  if (o___0->outfmt & (1 << 2)) {
#line 811
    finalpan = 0;
  } else {
#line 811
    finalpan = ((finalpan - 128) * o___0->mix) / 100;
  }
  {
#line 813
  xmp_drv_setbend(ctx___0, chn, (xc->pitchbend + xc->a_val[xc->a_idx]) + med_arp);
  }
#line 814
  if (m___0->flags & (1 << 1)) {
#line 814
    tmp___17 = - finalpan;
  } else {
#line 814
    tmp___17 = finalpan;
  }
  {
#line 814
  xmp_drv_setpan(ctx___0, chn, tmp___17);
#line 815
  xmp_drv_setvol(ctx___0, chn, finalvol);
  }
#line 817
  if (cutoff < 255) {
#line 817
    if (m___0->flags & (1 << 8)) {
      {
#line 818
      filter_setup(ctx___0, xc, cutoff);
#line 819
      xmp_drv_seteffect(ctx___0, chn, 176, xc->flt_B0);
#line 820
      xmp_drv_seteffect(ctx___0, chn, 177, xc->flt_B1);
#line 821
      xmp_drv_seteffect(ctx___0, chn, 178, xc->flt_B2);
      }
    } else {
#line 823
      cutoff = 255;
    }
  } else {
#line 823
    cutoff = 255;
  }
  {
#line 826
  xmp_drv_seteffect(ctx___0, chn, 3, xc->resonance);
#line 827
  xmp_drv_seteffect(ctx___0, chn, 2, cutoff);
#line 828
  xmp_drv_seteffect(ctx___0, chn, 0, m___0->xxc[chn].cho);
#line 829
  xmp_drv_seteffect(ctx___0, chn, 1, m___0->xxc[chn].rvb);
  }
#line 830
  return;
}
}
#line 833 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/player/player.c"
int _xmp_player_start(struct xmp_context *ctx___0 ) 
{ 
  struct xmp_player_context *p ;
  struct xmp_driver_context *d ;
  struct xmp_mod_context *m___0 ;
  struct xmp_options *o___0 ;
  struct flow_control *f ;
  int ret ;
  int tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;

  {
#line 835
  p = & ctx___0->p;
#line 836
  d = & ctx___0->d;
#line 837
  m___0 = & p->m;
#line 838
  o___0 = & ctx___0->o;
#line 839
  f = & p->flow;
#line 842
  if ((m___0->xxh)->len == 0) {
#line 843
    return (0);
  } else
#line 842
  if ((m___0->xxh)->chn == 0) {
#line 843
    return (0);
  }
#line 845
  if ((unsigned long )p->event_callback == (unsigned long )((void *)0)) {
#line 846
    p->event_callback = & dummy___2;
  }
#line 848
  p->gvol_slide = 0;
#line 849
  p->gvol_base = m___0->volbase;
#line 850
  tmp = o___0->start;
#line 850
  f->ord = tmp;
#line 850
  p->pos = tmp;
#line 851
  f->frame = 0;
#line 852
  f->row = 0;
#line 853
  f->num_rows = (*(m___0->xxp + m___0->xxo[f->ord]))->rows;
  {
#line 856
  while (1) {
    while_continue: /* CIL Label */ ;
#line 856
    if (f->ord < (m___0->xxh)->len) {
#line 856
      if (! ((int )m___0->xxo[f->ord] >= (m___0->xxh)->pat)) {
#line 856
        goto while_break;
      }
    } else {
#line 856
      goto while_break;
    }
#line 857
    (f->ord) ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 859
  m___0->volume = m___0->xxo_info[f->ord].gvl;
#line 860
  tmp___0 = m___0->xxo_info[f->ord].bpm;
#line 860
  p->xmp_bpm = tmp___0;
#line 860
  p->tick_time = m___0->rrate / (double )tmp___0;
#line 861
  p->tempo = m___0->xxo_info[f->ord].tempo;
#line 862
  f->jumpline = m___0->xxo_fstrow[f->ord];
#line 863
  f->playing_time = (double )0;
#line 864
  f->end_point = p->xmp_scan_num;
#line 866
  ret = xmp_drv_on(ctx___0, (m___0->xxh)->chn);
  }
#line 866
  if (ret != 0) {
#line 867
    return (ret);
  }
  {
#line 869
  f->jump = -1;
#line 871
  tmp___1 = calloc((size_t )(m___0->xxh)->chn, (size_t )sizeof(int ));
#line 871
  p->fetch_ctl = (int *)tmp___1;
#line 872
  tmp___2 = calloc((size_t )d->numchn, (size_t )sizeof(int ));
#line 872
  f->loop_stack = (int *)tmp___2;
#line 873
  tmp___3 = calloc((size_t )d->numchn, (size_t )sizeof(int ));
#line 873
  f->loop_start = (int *)tmp___3;
#line 874
  tmp___4 = calloc((size_t )d->numchn, (size_t )sizeof(struct xmp_channel ));
#line 874
  p->xc_data = (struct xmp_channel *)tmp___4;
  }
#line 875
  if (p->fetch_ctl) {
#line 875
    if (f->loop_stack) {
#line 875
      if (f->loop_start) {
#line 875
        if (! p->xc_data) {
#line 876
          return (-8);
        }
      } else {
#line 876
        return (-8);
      }
    } else {
#line 876
      return (-8);
    }
  } else {
#line 876
    return (-8);
  }
  {
#line 878
  reset_channel(ctx___0);
#line 880
  xmp_drv_starttimer(ctx___0);
  }
#line 882
  return (0);
}
}
#line 886 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/player/player.c"
int _xmp_player_frame(struct xmp_context *ctx___0 ) 
{ 
  struct xmp_player_context *p ;
  struct xmp_driver_context *d ;
  struct xmp_mod_context *m___0 ;
  struct xmp_options *o___0 ;
  struct flow_control *f ;
  int tmp ;
  int chn ;

  {
#line 888
  p = & ctx___0->p;
#line 889
  d = & ctx___0->d;
#line 890
  m___0 = & p->m;
#line 891
  o___0 = & ctx___0->o;
#line 892
  f = & p->flow;
#line 894
  if (p->pause) {
    {
#line 895
    (*(p->event_callback))(0UL);
    }
#line 896
    return (0);
  }
#line 900
  if (f->ord != p->pos) {
#line 901
    if (p->pos == -1) {
#line 902
      (p->pos) ++;
    }
#line 904
    if (p->pos == -2) {
      {
#line 905
      xmp_drv_bufwipe(ctx___0);
      }
#line 906
      return (-1);
    }
#line 909
    if (p->pos == 0) {
#line 910
      f->end_point = p->xmp_scan_num;
    }
#line 912
    f->ord = p->pos;
#line 913
    if (m___0->xxo_info[f->ord].tempo) {
#line 914
      p->tempo = m___0->xxo_info[f->ord].tempo;
    }
    {
#line 915
    p->xmp_bpm = m___0->xxo_info[f->ord].bpm;
#line 916
    p->tick_time = m___0->rrate / (double )p->xmp_bpm;
#line 917
    m___0->volume = m___0->xxo_info[f->ord].gvl;
#line 918
    f->jump = f->ord;
#line 919
    f->time = (double )m___0->xxo_info[f->ord].time / (double )1000;
#line 920
    f->jumpline = m___0->xxo_fstrow[f->ord];
#line 921
    f->row = -1;
#line 922
    f->pbreak = 1;
#line 923
    (f->ord) --;
#line 924
    xmp_drv_bufwipe(ctx___0);
#line 925
    xmp_drv_sync(ctx___0, (double )0);
#line 926
    xmp_drv_reset(ctx___0);
#line 927
    reset_channel(ctx___0);
    }
#line 928
    goto next_row;
  }
#line 933
  if (f->frame == 0) {
#line 935
    if (~ m___0->flags & (1 << 3)) {
#line 935
      if (f->ord == p->xmp_scan_ord) {
#line 935
        if (f->row == p->xmp_scan_row) {
#line 937
          tmp = f->end_point;
#line 937
          (f->end_point) --;
#line 937
          if (! tmp) {
#line 938
            return (-1);
          }
        }
      }
    }
    {
#line 941
    p->gvol_flag = 0;
#line 942
    fetch_row(ctx___0, (int )m___0->xxo[f->ord], f->row);
#line 944
    xmp_drv_echoback(ctx___0, ((p->tempo << 12) | (p->xmp_bpm << 4)) | 2);
#line 946
    xmp_drv_echoback(ctx___0, (m___0->volume << 4) | 9);
#line 947
    xmp_drv_echoback(ctx___0, (((int )m___0->xxo[f->ord] << 12) | (f->ord << 4)) | 5);
#line 949
    xmp_drv_echoback(ctx___0, (d->curvoc << 4) | 10);
#line 950
    xmp_drv_echoback(ctx___0, ((((*(m___0->xxp + m___0->xxo[f->ord]))->rows - 1) << 12) | (f->row << 4)) | 6);
#line 952
    xmp_drv_echoback(ctx___0, ((int )(f->time * (double )10) << 4) | 12);
    }
  }
  {
#line 958
  xmp_drv_echoback(ctx___0, (f->frame << 4) | 11);
#line 959
  play_frame(ctx___0, f->frame);
  }
#line 961
  if (o___0->time) {
#line 961
    if ((double )o___0->time < f->playing_time) {
#line 962
      return (-1);
    }
  }
#line 964
  if (m___0->quirk & 1) {
    {
#line 965
    xmp_drv_sync(ctx___0, (p->tick_time * (double )33) / (double )125);
#line 966
    f->playing_time += (m___0->rrate * (double )33) / (double )((100 * p->xmp_bpm) * 125);
    }
  } else {
    {
#line 968
    xmp_drv_sync(ctx___0, p->tick_time);
#line 969
    f->playing_time += m___0->rrate / (double )(100 * p->xmp_bpm);
#line 970
    f->time += m___0->rrate / (double )(100 * p->xmp_bpm);
    }
  }
#line 973
  (f->frame) ++;
#line 975
  if (f->frame >= p->tempo * (1 + f->delay)) {
    next_row: 
#line 977
    f->frame = 0;
#line 978
    f->delay = 0;
#line 980
    if (f->pbreak) {
#line 981
      f->pbreak = 0;
#line 983
      if (f->jump != -1) {
#line 984
        f->ord = f->jump - 1;
#line 985
        f->jump = -1;
#line 986
        goto next_order;
      }
#line 989
      goto next_order;
    }
#line 992
    if (f->loop_chn) {
#line 993
      (f->loop_chn) --;
#line 993
      f->row = *(f->loop_start + f->loop_chn) - 1;
#line 994
      f->loop_chn = 0;
    }
#line 997
    (f->row) ++;
#line 1000
    if (f->row >= f->num_rows) {
      next_order: 
#line 1002
      (f->ord) ++;
#line 1005
      if (f->ord >= (m___0->xxh)->len) {
#line 1006
        if ((uint32 )(m___0->xxh)->rst > (uint32 )(m___0->xxh)->len) {
#line 1006
          f->ord = 0;
        } else
#line 1006
        if ((uint32 )m___0->xxo[(m___0->xxh)->rst] >= (uint32 )(m___0->xxh)->pat) {
#line 1006
          f->ord = 0;
        } else {
#line 1006
          f->ord = (m___0->xxh)->rst;
        }
#line 1009
        m___0->volume = m___0->xxo_info[f->ord].gvl;
      }
#line 1013
      if ((int )m___0->xxo[f->ord] >= (m___0->xxh)->pat) {
#line 1014
        (f->ord) ++;
#line 1015
        goto next_order;
      }
#line 1018
      f->num_rows = (*(m___0->xxp + m___0->xxo[f->ord]))->rows;
#line 1019
      if (f->jumpline >= f->num_rows) {
#line 1020
        f->jumpline = 0;
      }
#line 1021
      f->row = f->jumpline;
#line 1022
      f->jumpline = 0;
#line 1024
      p->pos = f->ord;
#line 1027
      if (m___0->quirk & (1 << 16)) {
#line 1029
        chn = 0;
        {
#line 1029
        while (1) {
          while_continue: /* CIL Label */ ;
#line 1029
          if (! (chn < (p->m.xxh)->chn)) {
#line 1029
            goto while_break;
          }
#line 1030
          (p->xc_data + chn)->per_flags = 0;
#line 1029
          chn ++;
        }
        while_break: /* CIL Label */ ;
        }
      }
    }
  }
#line 1035
  return (0);
}
}
#line 1039 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/player/player.c"
void _xmp_player_end(struct xmp_context *ctx___0 ) 
{ 
  struct xmp_player_context *p ;
  struct flow_control *f ;
  int tmp ;

  {
  {
#line 1041
  p = & ctx___0->p;
#line 1042
  f = & p->flow;
#line 1044
  xmp_drv_echoback(ctx___0, 1);
  }
  {
#line 1045
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1045
    tmp = xmp_drv_getmsg(ctx___0);
    }
#line 1045
    if (! (tmp != 1)) {
#line 1045
      goto while_break;
    }
    {
#line 1046
    xmp_drv_bufdump(ctx___0);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1047
  xmp_drv_stoptimer(ctx___0);
#line 1049
  free((void *)p->xc_data);
#line 1050
  free((void *)f->loop_start);
#line 1051
  free((void *)f->loop_stack);
#line 1052
  free((void *)p->fetch_ctl);
#line 1054
  xmp_drv_off(ctx___0);
  }
#line 1055
  return;
}
}
#line 21 "src/include/period.h"
int period_to_note(int p ) ;
#line 23
void c2spd_to_note(int c2spd___0 , int *n___0 , int *f ) ;
#line 110 "/usr/include/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) double log(double __x ) ;
#line 21 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/player/period.c"
static int period_amiga[104]  = 
#line 21 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/player/period.c"
  {      7254,      7202,      7150,      7099, 
        7047,      6997,      6946,      6896, 
        6847,      6798,      6749,      6700, 
        6652,      6604,      6556,      6509, 
        6462,      6416,      6370,      6324, 
        6278,      6233,      6188,      6144, 
        6100,      6056,      6012,      5969, 
        5926,      5883,      5841,      5799, 
        5757,      5716,      5675,      5634, 
        5593,      5553,      5513,      5474, 
        5434,      5395,      5356,      5318, 
        5279,      5241,      5204,      5166, 
        5129,      5092,      5056,      5019, 
        4983,      4947,      4912,      4876, 
        4841,      4806,      4772,      4738, 
        4703,      4670,      4636,      4603, 
        4570,      4537,      4504,      4472, 
        4439,      4407,      4376,      4344, 
        4313,      4282,      4251,      4221, 
        4190,      4160,      4130,      4100, 
        4071,      4042,      4013,      3984, 
        3955,      3927,      3898,      3870, 
        3842,      3815,      3787,      3760, 
        3733,      3706,      3679,      3653, 
        3627,      3601,      3575,      3549, 
        3523,      3498,      3473,      3448};
#line 40 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/player/period.c"
double note_to_period(int n___0 , int f , int type ) 
{ 
  double d ;
  double tmp ;
  double tmp___0 ;

  {
#line 42
  d = (double )n___0 + (double )f / (double )128;
#line 44
  if (type) {
#line 44
    tmp___0 = (120.0 - d) * (double )16;
  } else {
    {
#line 44
    tmp = pow((double )2, d / (double )12);
#line 44
    tmp___0 = 6847.0 / tmp;
    }
  }
#line 44
  return (tmp___0);
}
}
#line 51 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/player/period.c"
int note_to_period_mix(int n___0 , int b___1 ) 
{ 
  double d ;
  double tmp ;

  {
  {
#line 53
  d = (double )n___0 + (double )b___1 / (double )100;
#line 54
  tmp = pow((double )2, d / (double )12);
  }
#line 54
  return ((int )((16.0 * 6847.0) / tmp));
}
}
#line 60 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/player/period.c"
int period_to_note(int p ) 
{ 
  int n___0 ;
  int f ;
  int *t ;

  {
#line 62
  t = period_amiga + 88;
#line 64
  if (! p) {
#line 65
    return (0);
  }
#line 66
  n___0 = 12;
  {
#line 66
  while (1) {
    while_continue: /* CIL Label */ ;
#line 66
    if (! (p <= 3627)) {
#line 66
      goto while_break;
    }
#line 66
    n___0 += 12;
#line 66
    p <<= 1;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 67
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 67
    if (! (p > *t)) {
#line 67
      goto while_break___0;
    }
#line 67
    t -= 8;
#line 67
    n___0 --;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 68
  f = 7;
  {
#line 68
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 68
    if (f) {
#line 68
      if (! (*t > p)) {
#line 68
        goto while_break___1;
      }
    } else {
#line 68
      goto while_break___1;
    }
#line 68
    t ++;
#line 68
    f --;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 69
  return (n___0 - (f >> 2));
}
}
#line 74 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/player/period.c"
int period_to_bend(double p , int n___0 , int limit , int gliss , int type ) 
{ 
  int b___1 ;
  double d ;
  int tmp ;
  double tmp___0 ;
  int tmp___1 ;

  {
#line 79
  if (! n___0) {
#line 80
    return (0);
  }
#line 82
  if (limit) {
#line 83
    if (p > (double )907) {
#line 84
      p = (double )907;
    }
#line 85
    if (p < (double )108) {
#line 86
      p = (double )108;
    }
  }
#line 89
  if (type) {
#line 91
    b___1 = (int )(((double )100 * ((double )8 * ((double )((120 - n___0) << 4) - p))) / (double )128);
#line 92
    if (gliss) {
#line 92
      tmp = (b___1 / 100) * 100;
    } else {
#line 92
      tmp = b___1;
    }
#line 92
    return (tmp);
  }
#line 95
  if (p < (double )8) {
#line 96
    p = (double )8;
  }
  {
#line 98
  d = note_to_period(n___0, 0, 0);
#line 99
  tmp___0 = log(d / p);
#line 99
  b___1 = (int )((100.0 * ((1536.0 * tmp___0) / 0.69314718055994530942)) / (double )128);
  }
#line 101
  if (gliss) {
#line 101
    tmp___1 = (b___1 / 100) * 100;
  } else {
#line 101
    tmp___1 = b___1;
  }
#line 101
  return (tmp___1);
}
}
#line 111 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/player/period.c"
void c2spd_to_note(int c2spd___0 , int *n___0 , int *f ) 
{ 
  int c___0 ;
  int tmp ;
  double tmp___0 ;

  {
#line 115
  if (c2spd___0 == 0) {
#line 116
    tmp = 0;
#line 116
    *f = tmp;
#line 116
    *n___0 = tmp;
#line 117
    return;
  }
  {
#line 120
  tmp___0 = log((double )c2spd___0 / (double )8363);
#line 120
  c___0 = (int )((1536.0 * tmp___0) / 0.69314718055994530942);
#line 121
  *n___0 = c___0 / 128;
#line 122
  *f = c___0 % 128;
  }
#line 123
  return;
}
}
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
#line 348 "/usr/include/stdio.h"
extern int vfprintf(FILE * __restrict  __s , char const   * __restrict  __format ,
                    __gnuc_va_list __arg ) ;
#line 81 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **__ctype_b_loc(void)  __attribute__((__const__)) ;
#line 281 "src/include/common.h"
int reportv(struct xmp_context *ctx___0 , int v , char *fmt___0  , ...) ;
#line 283
char *str_adj(char *s ) ;
#line 314
int get_temp_dir(char *buf___1 , int size___0 ) ;
#line 20 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/player/misc.c"
int report(char *fmt___0  , ...) 
{ 
  va_list a ;
  int n___0 ;

  {
  {
#line 25
  __builtin_va_start(a, fmt___0);
#line 26
  n___0 = vfprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)fmt___0,
                   a);
#line 27
  __builtin_va_end(a);
  }
#line 29
  return (n___0);
}
}
#line 32 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/player/misc.c"
int reportv(struct xmp_context *ctx___0 , int v , char *fmt___0  , ...) 
{ 
  va_list a ;
  int n___0 ;
  struct xmp_options *o___0 ;

  {
#line 36
  o___0 = & ctx___0->o;
#line 38
  if (o___0->verbosity <= v) {
#line 39
    return (0);
  }
  {
#line 41
  __builtin_va_start(a, fmt___0);
#line 42
  n___0 = vfprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)fmt___0,
                   a);
#line 43
  __builtin_va_end(a);
  }
#line 45
  return (n___0);
}
}
#line 48 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/player/misc.c"
char *str_adj(char *s ) 
{ 
  int i___3 ;
  unsigned short const   **tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;

  {
#line 52
  i___3 = 0;
  {
#line 52
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 52
    tmp___0 = strlen((char const   *)s);
    }
#line 52
    if (! ((size_t )i___3 < tmp___0)) {
#line 52
      goto while_break;
    }
    {
#line 53
    tmp = __ctype_b_loc();
    }
#line 53
    if ((int const   )*(*tmp + (int )*(s + i___3)) & 16384) {
#line 53
      if ((int )((uint8 )*(s + i___3)) > 127) {
#line 54
        *(s + i___3) = (char )' ';
      }
    } else {
#line 54
      *(s + i___3) = (char )' ';
    }
#line 52
    i___3 ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 56
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 56
    if (*s) {
      {
#line 56
      tmp___2 = strlen((char const   *)s);
      }
#line 56
      if (! ((int )*(s + (tmp___2 - 1U)) == 32)) {
#line 56
        goto while_break___0;
      }
    } else {
#line 56
      goto while_break___0;
    }
    {
#line 57
    tmp___1 = strlen((char const   *)s);
#line 57
    *(s + (tmp___1 - 1U)) = (char)0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 59
  return (s);
}
}
#line 62 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/player/misc.c"
int get_temp_dir(char *buf___1 , int size___0 ) 
{ 
  char *def ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
  {
#line 75
  def = (char *)"/tmp";
#line 76
  tmp___0 = getenv("TMPDIR");
#line 76
  tmp = tmp___0;
  }
#line 78
  if (tmp) {
#line 78
    tmp___1 = tmp;
  } else {
#line 78
    tmp___1 = def;
  }
  {
#line 78
  strncpy((char */* __restrict  */)buf___1, (char const   */* __restrict  */)tmp___1,
          (size_t )size___0);
#line 79
  strncat((char */* __restrict  */)buf___1, (char const   */* __restrict  */)"/",
          (size_t )size___0);
  }
#line 82
  return (0);
}
}
#line 229 "src/include/xmp.h"
void xmp_init_formats(xmp_context ctx___0 ) ;
#line 40 "src/include/list.h"
__inline static void __list_add(struct list_head *new , struct list_head *prev , struct list_head *next ) 
{ 


  {
#line 44
  next->prev = new;
#line 45
  new->next = next;
#line 46
  new->prev = prev;
#line 47
  prev->next = new;
#line 48
  return;
}
}
#line 71 "src/include/list.h"
__inline static void list_add_tail(struct list_head *new , struct list_head *head ) 
{ 


  {
  {
#line 73
  __list_add(new, head->prev, head);
  }
#line 74
  return;
}
}
#line 18 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/player/formats.c"
struct xmp_fmt_info *__fmt_head  ;
#line 20 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/player/formats.c"
struct list_head loader_list  =    {& loader_list, & loader_list};
#line 22
struct xmp_loader_info pw_loader ;
#line 24 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/player/formats.c"
void register_format(char *id , char *tracker ) 
{ 
  struct xmp_fmt_info *f ;
  void *tmp ;
  struct xmp_fmt_info *i___3 ;

  {
  {
#line 28
  tmp = malloc((size_t )sizeof(struct xmp_fmt_info ));
#line 28
  f = (struct xmp_fmt_info *)tmp;
#line 29
  f->tracker = tracker;
#line 30
  f->id = id;
  }
#line 32
  if (! __fmt_head) {
#line 33
    __fmt_head = f;
  } else {
#line 36
    i___3 = __fmt_head;
    {
#line 36
    while (1) {
      while_continue: /* CIL Label */ ;
#line 36
      if (! i___3->next) {
#line 36
        goto while_break;
      }
#line 36
      i___3 = i___3->next;
    }
    while_break: /* CIL Label */ ;
    }
#line 37
    i___3->next = f;
  }
#line 40
  f->next = (struct xmp_fmt_info *)((void *)0);
#line 41
  return;
}
}
#line 43 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/player/formats.c"
static void register_loader(struct xmp_loader_info *l ) 
{ 


  {
  {
#line 45
  l->enable = 1;
#line 46
  list_add_tail(& l->list, & loader_list);
#line 47
  register_format(l->id, l->name);
  }
#line 48
  return;
}
}
#line 57
struct xmp_loader_info xm_loader ;
#line 58
struct xmp_loader_info mod_loader ;
#line 59
struct xmp_loader_info flt_loader ;
#line 60
struct xmp_loader_info st_loader ;
#line 61
struct xmp_loader_info it_loader ;
#line 62
struct xmp_loader_info s3m_loader ;
#line 63
struct xmp_loader_info stm_loader ;
#line 64
struct xmp_loader_info stx_loader ;
#line 65
struct xmp_loader_info mtm_loader ;
#line 66
struct xmp_loader_info ice_loader ;
#line 67
struct xmp_loader_info imf_loader ;
#line 68
struct xmp_loader_info ptm_loader ;
#line 69
struct xmp_loader_info mdl_loader ;
#line 70
struct xmp_loader_info ult_loader ;
#line 71
struct xmp_loader_info liq_loader ;
#line 72
struct xmp_loader_info no_loader ;
#line 73
struct xmp_loader_info masi_loader ;
#line 74
struct xmp_loader_info gal5_loader ;
#line 75
struct xmp_loader_info gal4_loader ;
#line 76
struct xmp_loader_info psm_loader ;
#line 77
struct xmp_loader_info amf_loader ;
#line 78
struct xmp_loader_info gdm_loader ;
#line 79
struct xmp_loader_info mmd1_loader ;
#line 80
struct xmp_loader_info mmd3_loader ;
#line 81
struct xmp_loader_info med3_loader ;
#line 82
struct xmp_loader_info med4_loader ;
#line 83
struct xmp_loader_info dmf_loader ;
#line 84
struct xmp_loader_info rtm_loader ;
#line 85
struct xmp_loader_info pt3_loader ;
#line 86
struct xmp_loader_info tcb_loader ;
#line 87
struct xmp_loader_info dt_loader ;
#line 88
struct xmp_loader_info gtk_loader ;
#line 89
struct xmp_loader_info dtt_loader ;
#line 90
struct xmp_loader_info mgt_loader ;
#line 91
struct xmp_loader_info arch_loader ;
#line 92
struct xmp_loader_info sym_loader ;
#line 93
struct xmp_loader_info digi_loader ;
#line 94
struct xmp_loader_info dbm_loader ;
#line 95
struct xmp_loader_info emod_loader ;
#line 96
struct xmp_loader_info okt_loader ;
#line 97
struct xmp_loader_info sfx_loader ;
#line 98
struct xmp_loader_info far_loader ;
#line 99
struct xmp_loader_info umx_loader ;
#line 100
struct xmp_loader_info stim_loader ;
#line 102
struct xmp_loader_info mtp_loader ;
#line 103
struct xmp_loader_info ims_loader ;
#line 104
struct xmp_loader_info ssn_loader ;
#line 105
struct xmp_loader_info fnk_loader ;
#line 106
struct xmp_loader_info amd_loader ;
#line 107
struct xmp_loader_info rad_loader ;
#line 108
struct xmp_loader_info hsc_loader ;
#line 109
struct xmp_loader_info alm_loader ;
#line 55 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/player/formats.c"
void xmp_init_formats(xmp_context ctx___0 ) 
{ 


  {
  {
#line 57
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 57
    register_loader(& xm_loader);
    }
#line 57
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 58
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 58
    register_loader(& mod_loader);
    }
#line 58
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 59
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 59
    register_loader(& flt_loader);
    }
#line 59
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 60
  while (1) {
    while_continue___2: /* CIL Label */ ;
    {
#line 60
    register_loader(& st_loader);
    }
#line 60
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 61
  while (1) {
    while_continue___3: /* CIL Label */ ;
    {
#line 61
    register_loader(& it_loader);
    }
#line 61
    goto while_break___3;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 62
  while (1) {
    while_continue___4: /* CIL Label */ ;
    {
#line 62
    register_loader(& s3m_loader);
    }
#line 62
    goto while_break___4;
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 63
  while (1) {
    while_continue___5: /* CIL Label */ ;
    {
#line 63
    register_loader(& stm_loader);
    }
#line 63
    goto while_break___5;
  }
  while_break___5: /* CIL Label */ ;
  }
  {
#line 64
  while (1) {
    while_continue___6: /* CIL Label */ ;
    {
#line 64
    register_loader(& stx_loader);
    }
#line 64
    goto while_break___6;
  }
  while_break___6: /* CIL Label */ ;
  }
  {
#line 65
  while (1) {
    while_continue___7: /* CIL Label */ ;
    {
#line 65
    register_loader(& mtm_loader);
    }
#line 65
    goto while_break___7;
  }
  while_break___7: /* CIL Label */ ;
  }
  {
#line 66
  while (1) {
    while_continue___8: /* CIL Label */ ;
    {
#line 66
    register_loader(& ice_loader);
    }
#line 66
    goto while_break___8;
  }
  while_break___8: /* CIL Label */ ;
  }
  {
#line 67
  while (1) {
    while_continue___9: /* CIL Label */ ;
    {
#line 67
    register_loader(& imf_loader);
    }
#line 67
    goto while_break___9;
  }
  while_break___9: /* CIL Label */ ;
  }
  {
#line 68
  while (1) {
    while_continue___10: /* CIL Label */ ;
    {
#line 68
    register_loader(& ptm_loader);
    }
#line 68
    goto while_break___10;
  }
  while_break___10: /* CIL Label */ ;
  }
  {
#line 69
  while (1) {
    while_continue___11: /* CIL Label */ ;
    {
#line 69
    register_loader(& mdl_loader);
    }
#line 69
    goto while_break___11;
  }
  while_break___11: /* CIL Label */ ;
  }
  {
#line 70
  while (1) {
    while_continue___12: /* CIL Label */ ;
    {
#line 70
    register_loader(& ult_loader);
    }
#line 70
    goto while_break___12;
  }
  while_break___12: /* CIL Label */ ;
  }
  {
#line 71
  while (1) {
    while_continue___13: /* CIL Label */ ;
    {
#line 71
    register_loader(& liq_loader);
    }
#line 71
    goto while_break___13;
  }
  while_break___13: /* CIL Label */ ;
  }
  {
#line 72
  while (1) {
    while_continue___14: /* CIL Label */ ;
    {
#line 72
    register_loader(& no_loader);
    }
#line 72
    goto while_break___14;
  }
  while_break___14: /* CIL Label */ ;
  }
  {
#line 73
  while (1) {
    while_continue___15: /* CIL Label */ ;
    {
#line 73
    register_loader(& masi_loader);
    }
#line 73
    goto while_break___15;
  }
  while_break___15: /* CIL Label */ ;
  }
  {
#line 74
  while (1) {
    while_continue___16: /* CIL Label */ ;
    {
#line 74
    register_loader(& gal5_loader);
    }
#line 74
    goto while_break___16;
  }
  while_break___16: /* CIL Label */ ;
  }
  {
#line 75
  while (1) {
    while_continue___17: /* CIL Label */ ;
    {
#line 75
    register_loader(& gal4_loader);
    }
#line 75
    goto while_break___17;
  }
  while_break___17: /* CIL Label */ ;
  }
  {
#line 76
  while (1) {
    while_continue___18: /* CIL Label */ ;
    {
#line 76
    register_loader(& psm_loader);
    }
#line 76
    goto while_break___18;
  }
  while_break___18: /* CIL Label */ ;
  }
  {
#line 77
  while (1) {
    while_continue___19: /* CIL Label */ ;
    {
#line 77
    register_loader(& amf_loader);
    }
#line 77
    goto while_break___19;
  }
  while_break___19: /* CIL Label */ ;
  }
  {
#line 78
  while (1) {
    while_continue___20: /* CIL Label */ ;
    {
#line 78
    register_loader(& gdm_loader);
    }
#line 78
    goto while_break___20;
  }
  while_break___20: /* CIL Label */ ;
  }
  {
#line 79
  while (1) {
    while_continue___21: /* CIL Label */ ;
    {
#line 79
    register_loader(& mmd1_loader);
    }
#line 79
    goto while_break___21;
  }
  while_break___21: /* CIL Label */ ;
  }
  {
#line 80
  while (1) {
    while_continue___22: /* CIL Label */ ;
    {
#line 80
    register_loader(& mmd3_loader);
    }
#line 80
    goto while_break___22;
  }
  while_break___22: /* CIL Label */ ;
  }
  {
#line 81
  while (1) {
    while_continue___23: /* CIL Label */ ;
    {
#line 81
    register_loader(& med3_loader);
    }
#line 81
    goto while_break___23;
  }
  while_break___23: /* CIL Label */ ;
  }
  {
#line 82
  while (1) {
    while_continue___24: /* CIL Label */ ;
    {
#line 82
    register_loader(& med4_loader);
    }
#line 82
    goto while_break___24;
  }
  while_break___24: /* CIL Label */ ;
  }
  {
#line 83
  while (1) {
    while_continue___25: /* CIL Label */ ;
    {
#line 83
    register_loader(& dmf_loader);
    }
#line 83
    goto while_break___25;
  }
  while_break___25: /* CIL Label */ ;
  }
  {
#line 84
  while (1) {
    while_continue___26: /* CIL Label */ ;
    {
#line 84
    register_loader(& rtm_loader);
    }
#line 84
    goto while_break___26;
  }
  while_break___26: /* CIL Label */ ;
  }
  {
#line 85
  while (1) {
    while_continue___27: /* CIL Label */ ;
    {
#line 85
    register_loader(& pt3_loader);
    }
#line 85
    goto while_break___27;
  }
  while_break___27: /* CIL Label */ ;
  }
  {
#line 86
  while (1) {
    while_continue___28: /* CIL Label */ ;
    {
#line 86
    register_loader(& tcb_loader);
    }
#line 86
    goto while_break___28;
  }
  while_break___28: /* CIL Label */ ;
  }
  {
#line 87
  while (1) {
    while_continue___29: /* CIL Label */ ;
    {
#line 87
    register_loader(& dt_loader);
    }
#line 87
    goto while_break___29;
  }
  while_break___29: /* CIL Label */ ;
  }
  {
#line 88
  while (1) {
    while_continue___30: /* CIL Label */ ;
    {
#line 88
    register_loader(& gtk_loader);
    }
#line 88
    goto while_break___30;
  }
  while_break___30: /* CIL Label */ ;
  }
  {
#line 89
  while (1) {
    while_continue___31: /* CIL Label */ ;
    {
#line 89
    register_loader(& dtt_loader);
    }
#line 89
    goto while_break___31;
  }
  while_break___31: /* CIL Label */ ;
  }
  {
#line 90
  while (1) {
    while_continue___32: /* CIL Label */ ;
    {
#line 90
    register_loader(& mgt_loader);
    }
#line 90
    goto while_break___32;
  }
  while_break___32: /* CIL Label */ ;
  }
  {
#line 91
  while (1) {
    while_continue___33: /* CIL Label */ ;
    {
#line 91
    register_loader(& arch_loader);
    }
#line 91
    goto while_break___33;
  }
  while_break___33: /* CIL Label */ ;
  }
  {
#line 92
  while (1) {
    while_continue___34: /* CIL Label */ ;
    {
#line 92
    register_loader(& sym_loader);
    }
#line 92
    goto while_break___34;
  }
  while_break___34: /* CIL Label */ ;
  }
  {
#line 93
  while (1) {
    while_continue___35: /* CIL Label */ ;
    {
#line 93
    register_loader(& digi_loader);
    }
#line 93
    goto while_break___35;
  }
  while_break___35: /* CIL Label */ ;
  }
  {
#line 94
  while (1) {
    while_continue___36: /* CIL Label */ ;
    {
#line 94
    register_loader(& dbm_loader);
    }
#line 94
    goto while_break___36;
  }
  while_break___36: /* CIL Label */ ;
  }
  {
#line 95
  while (1) {
    while_continue___37: /* CIL Label */ ;
    {
#line 95
    register_loader(& emod_loader);
    }
#line 95
    goto while_break___37;
  }
  while_break___37: /* CIL Label */ ;
  }
  {
#line 96
  while (1) {
    while_continue___38: /* CIL Label */ ;
    {
#line 96
    register_loader(& okt_loader);
    }
#line 96
    goto while_break___38;
  }
  while_break___38: /* CIL Label */ ;
  }
  {
#line 97
  while (1) {
    while_continue___39: /* CIL Label */ ;
    {
#line 97
    register_loader(& sfx_loader);
    }
#line 97
    goto while_break___39;
  }
  while_break___39: /* CIL Label */ ;
  }
  {
#line 98
  while (1) {
    while_continue___40: /* CIL Label */ ;
    {
#line 98
    register_loader(& far_loader);
    }
#line 98
    goto while_break___40;
  }
  while_break___40: /* CIL Label */ ;
  }
  {
#line 99
  while (1) {
    while_continue___41: /* CIL Label */ ;
    {
#line 99
    register_loader(& umx_loader);
    }
#line 99
    goto while_break___41;
  }
  while_break___41: /* CIL Label */ ;
  }
  {
#line 100
  while (1) {
    while_continue___42: /* CIL Label */ ;
    {
#line 100
    register_loader(& stim_loader);
    }
#line 100
    goto while_break___42;
  }
  while_break___42: /* CIL Label */ ;
  }
  {
#line 102
  while (1) {
    while_continue___43: /* CIL Label */ ;
    {
#line 102
    register_loader(& mtp_loader);
    }
#line 102
    goto while_break___43;
  }
  while_break___43: /* CIL Label */ ;
  }
  {
#line 103
  while (1) {
    while_continue___44: /* CIL Label */ ;
    {
#line 103
    register_loader(& ims_loader);
    }
#line 103
    goto while_break___44;
  }
  while_break___44: /* CIL Label */ ;
  }
  {
#line 104
  while (1) {
    while_continue___45: /* CIL Label */ ;
    {
#line 104
    register_loader(& ssn_loader);
    }
#line 104
    goto while_break___45;
  }
  while_break___45: /* CIL Label */ ;
  }
  {
#line 105
  while (1) {
    while_continue___46: /* CIL Label */ ;
    {
#line 105
    register_loader(& fnk_loader);
    }
#line 105
    goto while_break___46;
  }
  while_break___46: /* CIL Label */ ;
  }
  {
#line 106
  while (1) {
    while_continue___47: /* CIL Label */ ;
    {
#line 106
    register_loader(& amd_loader);
    }
#line 106
    goto while_break___47;
  }
  while_break___47: /* CIL Label */ ;
  }
  {
#line 107
  while (1) {
    while_continue___48: /* CIL Label */ ;
    {
#line 107
    register_loader(& rad_loader);
    }
#line 107
    goto while_break___48;
  }
  while_break___48: /* CIL Label */ ;
  }
  {
#line 108
  while (1) {
    while_continue___49: /* CIL Label */ ;
    {
#line 108
    register_loader(& hsc_loader);
    }
#line 108
    goto while_break___49;
  }
  while_break___49: /* CIL Label */ ;
  }
  {
#line 109
  while (1) {
    while_continue___50: /* CIL Label */ ;
    {
#line 109
    register_loader(& alm_loader);
    }
#line 109
    goto while_break___50;
  }
  while_break___50: /* CIL Label */ ;
  }
  {
#line 111
  pw_loader.enable = 1;
#line 112
  list_add_tail(& pw_loader.list, & loader_list);
  }
#line 113
  return;
}
}
#line 485 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__)) realloc)(void *__ptr ,
                                                                                              size_t __size ) ;
#line 682 "/usr/include/stdio.h"
extern size_t fread(void * __restrict  __ptr , size_t __size , size_t __n , FILE * __restrict  __stream ) ;
#line 722
extern int fseek(FILE *__stream , long __off , int __whence ) ;
#line 727
extern long ftell(FILE *__stream ) ;
#line 70 "src/include/driver.h"
int xmp_drv_open(struct xmp_context *ctx___0 ) ;
#line 71
int xmp_drv_set(struct xmp_context *ctx___0 ) ;
#line 72
void xmp_drv_close(struct xmp_context *ctx___0 ) ;
#line 75
void xmp_drv_mute(struct xmp_context *ctx___0 , int chn , int status ) ;
#line 76
int xmp_drv_flushpatch(struct xmp_context *ctx___0 , int ratio ) ;
#line 77
int xmp_drv_writepatch(struct xmp_context *ctx___0 , struct patch_info *patch ) ;
#line 97
void xmp_drv_clearmem(struct xmp_context *ctx___0 ) ;
#line 102
int xmp_drv_loadpatch(struct xmp_context *ctx___0 , FILE *f , int id , int basefreq ,
                      int flags , struct xxm_sample *xxs , char *buffer ) ;
#line 105
__inline struct xmp_drv_info *xmp_drv_array(void) ;
#line 8 "src/include/convert.h"
void xmp_cvt_diff2abs(int l , int r , char *p ) ;
#line 9
void xmp_cvt_stdownmix(int l , int r , char *p ) ;
#line 12
void xmp_cvt_2xsmp(int l , char *p ) ;
#line 13
void xmp_cvt_vidc(int l , char *p ) ;
#line 18
void xmp_cvt_anticlick(struct patch_info *patch ) ;
#line 26 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/player/driver.c"
static struct xmp_drv_info *drv_array  =    (struct xmp_drv_info *)((void *)0);
#line 29 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/player/driver.c"
static int drv_select(struct xmp_context *ctx___0 ) 
{ 
  struct xmp_drv_info *drv ;
  int ret ;
  struct xmp_driver_context *d ;
  struct xmp_options *o___0 ;
  int tmp ;
  int tmp___0 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
#line 33
  d = & ctx___0->d;
#line 34
  o___0 = & ctx___0->o;
#line 36
  if (! drv_array) {
#line 37
    return (-2);
  }
#line 39
  if (o___0->drv_id) {
#line 40
    ret = -2;
#line 41
    drv = drv_array;
    {
#line 41
    while (1) {
      while_continue: /* CIL Label */ ;
#line 41
      if (! drv) {
#line 41
        goto while_break;
      }
      {
#line 42
      tmp = strcmp((char const   *)drv->id, (char const   *)o___0->drv_id);
      }
#line 42
      if (! tmp) {
        {
#line 43
        ret = (*(drv->init))(ctx___0);
        }
#line 43
        if (ret == 0) {
#line 44
          goto while_break;
        }
      }
#line 41
      drv = drv->next;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 48
    ret = -3;
#line 50
    drv = drv_array;
    {
#line 50
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 50
      if (! drv) {
#line 50
        goto while_break___0;
      }
#line 51
      if (o___0->verbosity > 2) {
        {
#line 52
        report((char *)"Probing %s... ", drv->description);
        }
      }
      {
#line 53
      tmp___0 = (*(drv->init))(ctx___0);
      }
#line 53
      if (tmp___0 == 0) {
#line 54
        if (o___0->verbosity > 2) {
          {
#line 55
          report((char *)"found\n");
          }
        }
#line 56
        ret = 0;
#line 57
        goto while_break___0;
      }
#line 59
      if (o___0->verbosity > 2) {
        {
#line 60
        report((char *)"not found\n");
        }
      }
#line 50
      drv = drv->next;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 63
  if (ret) {
#line 64
    return (ret);
  }
#line 66
  o___0->drv_id = drv->id;
#line 67
  d->description = drv->description;
#line 68
  d->help = drv->help;
#line 69
  d->driver = drv;
#line 71
  return (0);
}
}
#line 75 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/player/driver.c"
void xmp_drv_resetvoice(struct xmp_context *ctx___0 , int voc , int mute ) 
{ 
  struct xmp_driver_context *d ;
  struct voice_info *vi ;
  int tmp ;

  {
#line 77
  d = & ctx___0->d;
#line 78
  vi = d->voice_array + voc;
#line 80
  if ((uint32 )voc >= (uint32 )d->maxvoc) {
#line 81
    return;
  }
#line 83
  if (mute) {
    {
#line 84
    (*((d->driver)->setvol))(ctx___0, voc, 0);
    }
  }
  {
#line 86
  (d->curvoc) --;
#line 87
  (*(d->ch2vo_count + vi->root)) --;
#line 88
  *(d->ch2vo_array + vi->chn) = -1;
#line 89
  memset((void *)vi, 0, (size_t )sizeof(struct voice_info ));
#line 90
  tmp = -1;
#line 90
  vi->root = tmp;
#line 90
  vi->chn = tmp;
  }
#line 91
  return;
}
}
#line 94 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/player/driver.c"
void xmp_drv_register(struct xmp_drv_info *drv ) 
{ 
  struct xmp_drv_info *tmp ;

  {
#line 96
  if (! drv_array) {
#line 97
    drv_array = drv;
  } else {
#line 101
    tmp = drv_array;
    {
#line 101
    while (1) {
      while_continue: /* CIL Label */ ;
#line 101
      if (! tmp->next) {
#line 101
        goto while_break;
      }
#line 101
      tmp = tmp->next;
    }
    while_break: /* CIL Label */ ;
    }
#line 102
    tmp->next = drv;
  }
#line 104
  drv->next = (struct xmp_drv_info *)((void *)0);
#line 105
  return;
}
}
#line 108 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/player/driver.c"
int xmp_drv_open(struct xmp_context *ctx___0 ) 
{ 
  int status ;
  struct xmp_driver_context *d ;
  struct xmp_smixer_context *s ;
  struct xmp_options *o___0 ;
  void *tmp ;

  {
  {
#line 111
  d = & ctx___0->d;
#line 112
  s = & ctx___0->s;
#line 113
  o___0 = & ctx___0->o;
#line 115
  d->memavl = 0;
#line 116
  s->buf32b = (int *)((void *)0);
#line 117
  d->ext = 1;
#line 118
  status = drv_select(ctx___0);
  }
#line 118
  if (status != 0) {
#line 119
    return (status);
  }
  {
#line 121
  tmp = calloc((size_t )1024, (size_t )sizeof(struct patch_info *));
#line 121
  d->patch_array = (struct patch_info **)tmp;
  }
#line 123
  if ((unsigned long )d->patch_array == (unsigned long )((void *)0)) {
    {
#line 124
    (*((d->driver)->shutdown))(ctx___0);
    }
#line 125
    return (-8);
  }
  {
#line 128
  synth_init(o___0->freq);
#line 129
  synth_reset();
  }
#line 131
  return (0);
}
}
#line 136 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/player/driver.c"
int xmp_drv_set(struct xmp_context *ctx___0 ) 
{ 
  struct xmp_driver_context *d ;
  struct xmp_options *o___0 ;
  struct xmp_drv_info *drv ;
  int tmp ;

  {
#line 138
  d = & ctx___0->d;
#line 139
  o___0 = & ctx___0->o;
#line 142
  if (! drv_array) {
#line 143
    return (-2);
  }
#line 145
  drv = drv_array;
  {
#line 145
  while (1) {
    while_continue: /* CIL Label */ ;
#line 145
    if (! drv) {
#line 145
      goto while_break;
    }
    {
#line 146
    tmp = strcmp((char const   *)drv->id, (char const   *)o___0->drv_id);
    }
#line 146
    if (! tmp) {
#line 147
      d->driver = drv;
#line 148
      return (0);
    }
#line 145
    drv = drv->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 152
  return (-2);
}
}
#line 156 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/player/driver.c"
void xmp_drv_close(struct xmp_context *ctx___0 ) 
{ 
  struct xmp_driver_context *d ;

  {
  {
#line 158
  d = & ctx___0->d;
#line 160
  xmp_drv_off(ctx___0);
#line 161
  memset((void *)(d->cmute_array), 0, (size_t )(64UL * sizeof(int )));
#line 162
  (*((d->driver)->shutdown))(ctx___0);
#line 163
  free((void *)d->patch_array);
  }
#line 165
  return;
}
}
#line 169 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/player/driver.c"
int xmp_drv_on(struct xmp_context *ctx___0 , int num ) 
{ 
  struct xmp_player_context *p ;
  struct xmp_driver_context *d ;
  struct xmp_smixer_context *s ;
  struct xmp_mod_context *m___0 ;
  struct xmp_options *o___0 ;
  int tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
  {
#line 171
  p = & ctx___0->p;
#line 172
  d = & ctx___0->d;
#line 173
  s = & ctx___0->s;
#line 174
  m___0 = & p->m;
#line 175
  o___0 = & ctx___0->o;
#line 177
  d->numtrk = num;
#line 178
  num = (*((d->driver)->numvoices))(ctx___0, 135711);
#line 179
  (*((d->driver)->reset))();
#line 181
  d->numchn = d->numtrk;
  }
#line 182
  if (m___0->flags & (1 << 5)) {
#line 182
    d->chnvoc = 16;
  } else {
#line 182
    d->chnvoc = 1;
  }
#line 184
  if (d->chnvoc > 1) {
#line 185
    d->numchn += num;
  } else
#line 186
  if (num > d->numchn) {
#line 187
    num = d->numchn;
  }
  {
#line 189
  tmp = (*((d->driver)->numvoices))(ctx___0, num);
#line 189
  d->maxvoc = tmp;
#line 189
  num = tmp;
#line 191
  tmp___0 = calloc((size_t )d->maxvoc, (size_t )sizeof(struct voice_info ));
#line 191
  d->voice_array = (struct voice_info *)tmp___0;
#line 192
  tmp___1 = calloc((size_t )d->numchn, (size_t )sizeof(int ));
#line 192
  d->ch2vo_array = (int *)tmp___1;
#line 193
  tmp___2 = calloc((size_t )d->numchn, (size_t )sizeof(int ));
#line 193
  d->ch2vo_count = (int *)tmp___2;
  }
#line 195
  if (d->voice_array) {
#line 195
    if (d->ch2vo_array) {
#line 195
      if (! d->ch2vo_count) {
#line 196
        return (-8);
      }
    } else {
#line 196
      return (-8);
    }
  } else {
#line 196
    return (-8);
  }
  {
#line 198
  while (1) {
    while_continue: /* CIL Label */ ;
#line 198
    tmp___4 = num;
#line 198
    num --;
#line 198
    if (! tmp___4) {
#line 198
      goto while_break;
    }
#line 198
    tmp___3 = -1;
#line 198
    (d->voice_array + num)->root = tmp___3;
#line 198
    (d->voice_array + num)->chn = tmp___3;
  }
  while_break: /* CIL Label */ ;
  }
#line 199
  num = d->numchn;
  {
#line 199
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 199
    tmp___5 = num;
#line 199
    num --;
#line 199
    if (! tmp___5) {
#line 199
      goto while_break___0;
    }
#line 199
    *(d->ch2vo_array + num) = -1;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 201
  tmp___6 = 0;
#line 201
  d->agevoc = tmp___6;
#line 201
  d->curvoc = tmp___6;
#line 203
  if (o___0->outfmt & (1 << 2)) {
#line 203
    s->mode = 1;
  } else {
#line 203
    s->mode = 2;
  }
#line 204
  if (o___0->resol > 8) {
#line 204
    s->resol = 2;
  } else {
#line 204
    s->resol = 1;
  }
  {
#line 205
  smix_resetvar(ctx___0);
  }
#line 207
  return (0);
}
}
#line 211 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/player/driver.c"
void xmp_drv_off(struct xmp_context *ctx___0 ) 
{ 
  struct xmp_driver_context *d ;
  int tmp ;

  {
#line 213
  d = & ctx___0->d;
#line 215
  if (d->numchn < 1) {
#line 216
    return;
  }
  {
#line 218
  xmp_drv_writepatch(ctx___0, (struct patch_info *)((void *)0));
#line 219
  tmp = 0;
#line 219
  d->maxvoc = tmp;
#line 219
  d->curvoc = tmp;
#line 220
  d->numchn = 0;
#line 221
  d->numtrk = 0;
#line 222
  free((void *)d->voice_array);
#line 223
  free((void *)d->ch2vo_array);
#line 224
  free((void *)d->ch2vo_count);
  }
#line 225
  return;
}
}
#line 228 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/player/driver.c"
void xmp_drv_clearmem(struct xmp_context *ctx___0 ) 
{ 
  struct xmp_driver_context *d ;

  {
#line 230
  d = & ctx___0->d;
#line 232
  if (d->driver) {
    {
#line 233
    (*((d->driver)->clearmem))();
    }
  }
#line 234
  return;
}
}
#line 237 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/player/driver.c"
void xmp_drv_reset(struct xmp_context *ctx___0 ) 
{ 
  struct xmp_driver_context *d ;
  int i___3 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 239
  d = & ctx___0->d;
#line 242
  if (d->numchn < 1) {
#line 243
    return;
  }
  {
#line 245
  tmp = (*((d->driver)->numvoices))(ctx___0, 43210);
#line 245
  (*((d->driver)->numvoices))(ctx___0, tmp);
#line 246
  (*((d->driver)->reset))();
#line 247
  (*((d->driver)->numvoices))(ctx___0, d->maxvoc);
#line 249
  memset((void *)d->ch2vo_count, 0, (size_t )((unsigned long )d->numchn * sizeof(int )));
#line 250
  memset((void *)d->voice_array, 0, (size_t )((unsigned long )d->maxvoc * sizeof(struct voice_info )));
#line 252
  i___3 = 0;
  }
  {
#line 252
  while (1) {
    while_continue: /* CIL Label */ ;
#line 252
    if (! (i___3 < d->maxvoc)) {
#line 252
      goto while_break;
    }
#line 253
    tmp___0 = -1;
#line 253
    (d->voice_array + i___3)->root = tmp___0;
#line 253
    (d->voice_array + i___3)->chn = tmp___0;
#line 252
    i___3 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 255
  i___3 = 0;
  {
#line 255
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 255
    if (! (i___3 < d->numchn)) {
#line 255
      goto while_break___0;
    }
#line 256
    *(d->ch2vo_array + i___3) = -1;
#line 255
    i___3 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 258
  tmp___1 = 0;
#line 258
  d->agevoc = tmp___1;
#line 258
  d->curvoc = tmp___1;
#line 259
  return;
}
}
#line 262 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/player/driver.c"
void xmp_drv_resetchannel(struct xmp_context *ctx___0 , int chn ) 
{ 
  struct xmp_driver_context *d ;
  int voc ;
  int tmp ;

  {
#line 264
  d = & ctx___0->d;
#line 267
  voc = *(d->ch2vo_array + chn);
#line 269
  if ((uint32 )chn >= (uint32 )d->numchn) {
#line 270
    return;
  } else
#line 269
  if ((uint32 )voc >= (uint32 )d->maxvoc) {
#line 270
    return;
  }
  {
#line 272
  (*((d->driver)->setvol))(ctx___0, voc, 0);
#line 274
  (d->curvoc) --;
#line 275
  (*(d->ch2vo_count + (d->voice_array + voc)->root)) --;
#line 276
  *(d->ch2vo_array + chn) = -1;
#line 277
  memset((void *)(d->voice_array + voc), 0, (size_t )sizeof(struct voice_info ));
#line 278
  tmp = -1;
#line 278
  (d->voice_array + voc)->root = tmp;
#line 278
  (d->voice_array + voc)->chn = tmp;
  }
#line 279
  return;
}
}
#line 282 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/player/driver.c"
static int drv_allocvoice(struct xmp_context *ctx___0 , int chn ) 
{ 
  struct xmp_driver_context *d ;
  int voc ;
  int vfree ;
  uint32 age ;
  int tmp ;
  int tmp___0 ;

  {
#line 284
  d = & ctx___0->d;
#line 288
  if (*(d->ch2vo_count + chn) < d->chnvoc) {
#line 289
    voc = d->maxvoc;
    {
#line 289
    while (1) {
      while_continue: /* CIL Label */ ;
#line 289
      tmp = voc;
#line 289
      voc --;
#line 289
      if (tmp) {
#line 289
        if (! ((d->voice_array + voc)->chn != -1)) {
#line 289
          goto while_break;
        }
      } else {
#line 289
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 290
    if (voc < 0) {
#line 291
      return (voc);
    }
#line 293
    (d->voice_array + voc)->age = (unsigned int )d->agevoc;
#line 294
    (*(d->ch2vo_count + chn)) ++;
#line 295
    (d->curvoc) ++;
#line 297
    return (voc);
  }
#line 300
  voc = d->maxvoc;
#line 300
  age = (uint32 )-1;
#line 300
  vfree = (int )age;
  {
#line 300
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 300
    tmp___0 = voc;
#line 300
    voc --;
#line 300
    if (! tmp___0) {
#line 300
      goto while_break___0;
    }
#line 301
    if ((d->voice_array + voc)->root == chn) {
#line 301
      if ((d->voice_array + voc)->age < age) {
#line 302
        vfree = voc;
#line 302
        age = (d->voice_array + vfree)->age;
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 305
  *(d->ch2vo_array + (d->voice_array + vfree)->chn) = -1;
#line 306
  (d->voice_array + vfree)->age = (unsigned int )d->agevoc;
#line 308
  return (vfree);
}
}
#line 312 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/player/driver.c"
void xmp_drv_mute(struct xmp_context *ctx___0 , int chn , int status ) 
{ 
  struct xmp_driver_context *d ;

  {
#line 314
  d = & ctx___0->d;
#line 316
  if ((uint32 )chn >= 64U) {
#line 317
    return;
  }
#line 319
  if (status < 0) {
#line 320
    d->cmute_array[chn] = ! d->cmute_array[chn];
  } else {
#line 322
    d->cmute_array[chn] = status;
  }
#line 323
  return;
}
}
#line 326 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/player/driver.c"
void xmp_drv_setvol(struct xmp_context *ctx___0 , int chn , int vol ) 
{ 
  struct xmp_driver_context *d ;
  int voc ;

  {
#line 328
  d = & ctx___0->d;
#line 331
  voc = *(d->ch2vo_array + chn);
#line 333
  if ((uint32 )chn >= (uint32 )d->numchn) {
#line 334
    return;
  } else
#line 333
  if ((uint32 )voc >= (uint32 )d->maxvoc) {
#line 334
    return;
  }
#line 336
  if ((d->voice_array + voc)->root < 64) {
#line 336
    if (d->cmute_array[(d->voice_array + voc)->root]) {
#line 337
      vol = 0;
    }
  }
  {
#line 339
  (*((d->driver)->setvol))(ctx___0, voc, vol);
  }
#line 341
  if (! vol) {
#line 341
    if (! (chn < d->numtrk)) {
      {
#line 342
      xmp_drv_resetvoice(ctx___0, voc, 1);
      }
    }
  }
#line 343
  return;
}
}
#line 346 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/player/driver.c"
void xmp_drv_setpan(struct xmp_context *ctx___0 , int chn , int pan ) 
{ 
  struct xmp_driver_context *d ;
  int voc ;

  {
#line 348
  d = & ctx___0->d;
#line 351
  voc = *(d->ch2vo_array + chn);
#line 353
  if ((uint32 )chn >= (uint32 )d->numchn) {
#line 354
    return;
  } else
#line 353
  if ((uint32 )voc >= (uint32 )d->maxvoc) {
#line 354
    return;
  }
  {
#line 356
  (*((d->driver)->setpan))(ctx___0, voc, pan);
  }
#line 357
  return;
}
}
#line 360 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/player/driver.c"
void xmp_drv_seteffect(struct xmp_context *ctx___0 , int chn , int type , int val ) 
{ 
  struct xmp_driver_context *d ;
  int voc ;

  {
#line 362
  d = & ctx___0->d;
#line 365
  voc = *(d->ch2vo_array + chn);
#line 367
  if ((uint32 )chn >= (uint32 )d->numchn) {
#line 368
    return;
  } else
#line 367
  if ((uint32 )voc >= (uint32 )d->maxvoc) {
#line 368
    return;
  }
  {
#line 370
  (*((d->driver)->seteffect))(ctx___0, voc, type, val);
  }
#line 371
  return;
}
}
#line 374 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/player/driver.c"
void xmp_drv_setsmp(struct xmp_context *ctx___0 , int chn , int smp ) 
{ 
  struct xmp_driver_context *d ;
  int voc ;
  int pos___0 ;
  int itp ;
  struct voice_info *vi ;

  {
#line 376
  d = & ctx___0->d;
#line 380
  voc = *(d->ch2vo_array + chn);
#line 382
  if ((uint32 )chn >= (uint32 )d->numchn) {
#line 383
    return;
  } else
#line 382
  if ((uint32 )voc >= (uint32 )d->maxvoc) {
#line 383
    return;
  }
#line 385
  vi = d->voice_array + voc;
#line 386
  if ((uint32 )smp >= 1024U) {
#line 387
    return;
  } else
#line 386
  if (! *(d->patch_array + smp)) {
#line 387
    return;
  } else
#line 386
  if (vi->smp == smp) {
#line 387
    return;
  }
  {
#line 389
  pos___0 = vi->pos;
#line 390
  itp = vi->itpt;
#line 392
  smix_setpatch(ctx___0, voc, smp);
#line 393
  smix_voicepos(ctx___0, voc, pos___0, itp);
  }
#line 395
  if (d->ext) {
    {
#line 396
    (*((d->driver)->setpatch))(voc, smp);
#line 397
    (*((d->driver)->setnote))(voc, vi->note);
#line 398
    (*((d->driver)->voicepos))(voc, pos___0 << ! (! ((*(d->patch_array + smp))->mode & 1U)));
    }
  }
#line 401
  return;
}
}
#line 404 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/player/driver.c"
int xmp_drv_setpatch(struct xmp_context *ctx___0 , int chn , int ins , int smp , int note ,
                     int nna___0 , int dct___0 , int dca , int flg , int cont_sample ) 
{ 
  struct xmp_driver_context *d ;
  int voc ;
  int vfree ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 406
  d = & ctx___0->d;
#line 409
  if ((uint32 )chn >= (uint32 )d->numchn) {
#line 410
    return (-1);
  }
#line 412
  if (ins < 0) {
#line 413
    smp = -1;
  } else
#line 412
  if ((uint32 )smp >= 1024U) {
#line 413
    smp = -1;
  } else
#line 412
  if (! *(d->patch_array + smp)) {
#line 413
    smp = -1;
  }
#line 415
  if (dct___0) {
#line 416
    voc = d->maxvoc;
    {
#line 416
    while (1) {
      while_continue: /* CIL Label */ ;
#line 416
      tmp = voc;
#line 416
      voc --;
#line 416
      if (! tmp) {
#line 416
        goto while_break;
      }
#line 417
      if ((d->voice_array + voc)->root == chn) {
#line 417
        if ((d->voice_array + voc)->ins == ins) {
#line 418
          if (dct___0 == 3) {
#line 418
            goto _L;
          } else
#line 418
          if (dct___0 == 2) {
#line 418
            if ((d->voice_array + voc)->smp == smp) {
#line 418
              goto _L;
            } else {
#line 418
              goto _L___0;
            }
          } else
          _L___0: /* CIL Label */ 
#line 418
          if (dct___0 == 1) {
#line 418
            if ((d->voice_array + voc)->note == note) {
              _L: /* CIL Label */ 
#line 421
              if (dca) {
#line 422
                if (voc != *(d->ch2vo_array + chn)) {
#line 423
                  (d->voice_array + voc)->act = dca;
                } else
#line 422
                if ((d->voice_array + voc)->act) {
#line 423
                  (d->voice_array + voc)->act = dca;
                }
              } else {
                {
#line 425
                xmp_drv_resetvoice(ctx___0, voc, 1);
                }
              }
            }
          }
        }
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 432
  voc = *(d->ch2vo_array + chn);
#line 434
  if (voc > -1) {
#line 435
    if ((d->voice_array + voc)->act) {
#line 435
      if (d->chnvoc > 1) {
        {
#line 436
        vfree = drv_allocvoice(ctx___0, chn);
        }
#line 436
        if (vfree > -1) {
#line 437
          (d->voice_array + vfree)->root = chn;
#line 438
          tmp___0 = vfree;
#line 438
          *(d->ch2vo_array + chn) = tmp___0;
#line 438
          (d->voice_array + tmp___0)->chn = chn;
#line 439
          chn = d->numtrk;
          {
#line 439
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 439
            tmp___1 = chn;
#line 439
            chn ++;
#line 439
            if (! (*(d->ch2vo_array + tmp___1) > -1)) {
#line 439
              goto while_break___0;
            }
          }
          while_break___0: /* CIL Label */ ;
          }
#line 440
          chn --;
#line 440
          (d->voice_array + voc)->chn = chn;
#line 441
          *(d->ch2vo_array + chn) = voc;
#line 442
          voc = vfree;
        } else
#line 443
        if (flg) {
#line 444
          return (-1);
        }
      }
    }
  } else {
    {
#line 448
    voc = drv_allocvoice(ctx___0, chn);
    }
#line 448
    if (voc < 0) {
#line 449
      return (-1);
    }
#line 450
    tmp___2 = voc;
#line 450
    *(d->ch2vo_array + chn) = tmp___2;
#line 450
    (d->voice_array + tmp___2)->chn = chn;
#line 451
    (d->voice_array + voc)->root = chn;
  }
#line 454
  if (smp < 0) {
    {
#line 455
    xmp_drv_resetvoice(ctx___0, voc, 1);
    }
#line 456
    return (chn);
  }
#line 459
  if (! cont_sample) {
    {
#line 460
    smix_setpatch(ctx___0, voc, smp);
    }
  }
  {
#line 461
  smix_setnote(ctx___0, voc, note);
#line 462
  (d->voice_array + voc)->ins = ins;
#line 463
  (d->voice_array + voc)->act = nna___0;
  }
#line 465
  if (d->ext) {
#line 466
    if (! cont_sample) {
      {
#line 467
      (*((d->driver)->setpatch))(voc, smp);
      }
    }
    {
#line 468
    (*((d->driver)->setnote))(voc, note);
    }
  }
#line 471
  (d->agevoc) ++;
#line 473
  return (chn);
}
}
#line 477 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/player/driver.c"
void xmp_drv_setnna(struct xmp_context *ctx___0 , int chn , int nna___0 ) 
{ 
  struct xmp_driver_context *d ;
  int voc ;

  {
#line 479
  d = & ctx___0->d;
#line 482
  voc = *(d->ch2vo_array + chn);
#line 484
  if ((uint32 )chn >= (uint32 )d->numchn) {
#line 485
    return;
  } else
#line 484
  if ((uint32 )voc >= (uint32 )d->maxvoc) {
#line 485
    return;
  }
#line 487
  (d->voice_array + voc)->act = nna___0;
#line 488
  return;
}
}
#line 491 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/player/driver.c"
void xmp_drv_setbend(struct xmp_context *ctx___0 , int chn , int bend ) 
{ 
  struct xmp_driver_context *d ;
  int voc ;

  {
#line 493
  d = & ctx___0->d;
#line 496
  voc = *(d->ch2vo_array + chn);
#line 498
  if ((uint32 )chn >= (uint32 )d->numchn) {
#line 499
    return;
  } else
#line 498
  if ((uint32 )voc >= (uint32 )d->maxvoc) {
#line 499
    return;
  }
  {
#line 501
  smix_setbend(ctx___0, voc, bend);
  }
#line 503
  if (d->ext) {
    {
#line 504
    (*((d->driver)->setbend))(voc, bend);
    }
  }
#line 505
  return;
}
}
#line 508 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/player/driver.c"
void xmp_drv_retrig(struct xmp_context *ctx___0 , int chn ) 
{ 
  struct xmp_driver_context *d ;
  int voc ;

  {
#line 510
  d = & ctx___0->d;
#line 513
  voc = *(d->ch2vo_array + chn);
#line 515
  if ((uint32 )chn >= (uint32 )d->numchn) {
#line 516
    return;
  } else
#line 515
  if ((uint32 )voc >= (uint32 )d->maxvoc) {
#line 516
    return;
  }
  {
#line 518
  smix_voicepos(ctx___0, voc, 0, 0);
  }
#line 520
  if (d->ext) {
    {
#line 521
    (*((d->driver)->setnote))(voc, (d->voice_array + voc)->note);
    }
  }
#line 522
  return;
}
}
#line 525 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/player/driver.c"
void xmp_drv_pastnote(struct xmp_context *ctx___0 , int chn , int act ) 
{ 
  struct xmp_driver_context *d ;
  int voc ;
  int tmp ;

  {
#line 527
  d = & ctx___0->d;
#line 530
  voc = d->maxvoc;
  {
#line 530
  while (1) {
    while_continue: /* CIL Label */ ;
#line 530
    tmp = voc;
#line 530
    voc --;
#line 530
    if (! tmp) {
#line 530
      goto while_break;
    }
#line 531
    if ((d->voice_array + voc)->root == chn) {
#line 531
      if ((d->voice_array + voc)->chn >= d->numtrk) {
#line 532
        if (act == 0) {
          {
#line 533
          xmp_drv_resetvoice(ctx___0, voc, 1);
          }
        } else {
#line 535
          (d->voice_array + voc)->act = act;
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 538
  return;
}
}
#line 541 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/player/driver.c"
void xmp_drv_voicepos(struct xmp_context *ctx___0 , int chn , int pos___0 ) 
{ 
  struct xmp_driver_context *d ;
  int voc ;
  struct patch_info *pi ;

  {
#line 543
  d = & ctx___0->d;
#line 547
  if ((uint32 )chn >= (uint32 )d->numchn) {
#line 548
    return;
  } else {
#line 547
    voc = *(d->ch2vo_array + chn);
#line 547
    if ((uint32 )voc >= (uint32 )d->maxvoc) {
#line 548
      return;
    }
  }
#line 550
  pi = *(d->patch_array + (d->voice_array + voc)->smp);
#line 552
  if (pi->base_note != 130812U) {
#line 553
    pos___0 = (int )(((int64 )pos___0 << 16) / (int64 )((int )(((int64 )pi->base_note << 16) / 130812LL)));
  }
#line 556
  if (pos___0 > pi->len) {
#line 557
    return;
  }
  {
#line 559
  smix_voicepos(ctx___0, voc, pos___0, 0);
  }
#line 561
  if (d->ext) {
    {
#line 562
    (*((d->driver)->voicepos))(voc, pos___0 << ! (! (pi->mode & 1U)));
    }
  }
#line 563
  return;
}
}
#line 566 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/player/driver.c"
int xmp_drv_cstat(struct xmp_context *ctx___0 , int chn ) 
{ 
  struct xmp_driver_context *d ;
  int voc ;
  int tmp ;

  {
#line 568
  d = & ctx___0->d;
#line 571
  voc = *(d->ch2vo_array + chn);
#line 573
  if ((uint32 )chn >= (uint32 )d->numchn) {
#line 574
    return (-1);
  } else
#line 573
  if ((uint32 )voc >= (uint32 )d->maxvoc) {
#line 574
    return (-1);
  }
#line 576
  if (chn < d->numtrk) {
#line 576
    tmp = 256;
  } else {
#line 576
    tmp = (d->voice_array + voc)->act;
  }
#line 576
  return (tmp);
}
}
#line 580 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/player/driver.c"
void xmp_drv_echoback(struct xmp_context *ctx___0 , int msg ) 
{ 
  struct xmp_driver_context *d ;

  {
  {
#line 582
  d = & ctx___0->d;
#line 584
  (*((d->driver)->echoback))(ctx___0, msg);
  }
#line 585
  return;
}
}
#line 588 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/player/driver.c"
int xmp_drv_getmsg(struct xmp_context *ctx___0 ) 
{ 
  struct xmp_driver_context *d ;
  int tmp ;

  {
  {
#line 590
  d = & ctx___0->d;
#line 592
  tmp = (*((d->driver)->getmsg))(ctx___0);
  }
#line 592
  return (tmp);
}
}
#line 596 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/player/driver.c"
void xmp_drv_bufdump(struct xmp_context *ctx___0 ) 
{ 
  struct xmp_driver_context *d ;
  int i___3 ;
  int tmp ;

  {
  {
#line 598
  d = & ctx___0->d;
#line 599
  tmp = xmp_smix_softmixer(ctx___0);
#line 599
  i___3 = tmp;
#line 601
  (*((d->driver)->bufdump))(ctx___0, i___3);
  }
#line 602
  return;
}
}
#line 605 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/player/driver.c"
void xmp_drv_starttimer(struct xmp_context *ctx___0 ) 
{ 
  struct xmp_driver_context *d ;

  {
  {
#line 607
  d = & ctx___0->d;
#line 609
  xmp_drv_sync(ctx___0, (double )0);
#line 610
  (*((d->driver)->starttimer))();
  }
#line 611
  return;
}
}
#line 614 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/player/driver.c"
void xmp_drv_stoptimer(struct xmp_context *ctx___0 ) 
{ 
  struct xmp_driver_context *d ;
  int voc ;
  int tmp ;

  {
#line 616
  d = & ctx___0->d;
#line 619
  voc = d->maxvoc;
  {
#line 619
  while (1) {
    while_continue: /* CIL Label */ ;
#line 619
    tmp = voc;
#line 619
    voc --;
#line 619
    if (! tmp) {
#line 619
      goto while_break;
    }
    {
#line 620
    (*((d->driver)->setvol))(ctx___0, voc, 0);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 622
  (*((d->driver)->stoptimer))();
#line 624
  xmp_drv_bufdump(ctx___0);
  }
#line 625
  return;
}
}
#line 631 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/player/driver.c"
static double next_time  =    (double )0;
#line 628 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/player/driver.c"
double xmp_drv_sync(struct xmp_context *ctx___0 , double step ) 
{ 
  struct xmp_driver_context *d ;

  {
#line 630
  d = & ctx___0->d;
#line 633
  if (step == (double )0) {
#line 634
    next_time = step;
  }
  {
#line 636
  next_time += step;
#line 636
  (*((d->driver)->sync))(next_time);
  }
#line 638
  return (next_time);
}
}
#line 642 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/player/driver.c"
void xmp_drv_bufwipe(struct xmp_context *ctx___0 ) 
{ 
  struct xmp_driver_context *d ;

  {
  {
#line 644
  d = & ctx___0->d;
#line 646
  (*((d->driver)->bufwipe))();
  }
#line 647
  return;
}
}
#line 650 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/player/driver.c"
int xmp_drv_writepatch(struct xmp_context *ctx___0 , struct patch_info *patch ) 
{ 
  struct xmp_driver_context *d ;
  int num ;
  int tmp ;

  {
#line 652
  d = & ctx___0->d;
#line 655
  if (! d->patch_array) {
#line 656
    return (0);
  }
#line 658
  if (! patch) {
    {
#line 659
    (*((d->driver)->writepatch))(ctx___0, patch);
#line 661
    num = 1024;
    }
    {
#line 661
    while (1) {
      while_continue: /* CIL Label */ ;
#line 661
      tmp = num;
#line 661
      num --;
#line 661
      if (! tmp) {
#line 661
        goto while_break;
      }
      {
#line 662
      free((void *)*(d->patch_array + num));
#line 663
      *(d->patch_array + num) = (struct patch_info *)((void *)0);
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 665
    return (0);
  }
#line 667
  if ((int )patch->instr_no >= 1024) {
#line 668
    return (-6);
  }
#line 669
  *(d->patch_array + patch->instr_no) = patch;
#line 671
  return (0);
}
}
#line 675 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/player/driver.c"
int xmp_drv_flushpatch(struct xmp_context *ctx___0 , int ratio ) 
{ 
  struct xmp_driver_context *d ;
  struct xmp_options *o___0 ;
  struct patch_info *patch ;
  int smp ;
  int num ;
  int crunch ;
  int tmp ;
  void *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;

  {
#line 677
  d = & ctx___0->d;
#line 678
  o___0 = & ctx___0->o;
#line 682
  if (! d->patch_array) {
#line 683
    return (0);
  }
#line 685
  if (! ratio) {
#line 686
    ratio = 65536;
  }
#line 688
  smp = 1024;
#line 688
  num = 0;
  {
#line 688
  while (1) {
    while_continue: /* CIL Label */ ;
#line 688
    tmp = smp;
#line 688
    smp --;
#line 688
    if (! tmp) {
#line 688
      goto while_break;
    }
#line 689
    if (*(d->patch_array + smp)) {
#line 690
      num ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 692
  if (d->ext) {
    {
#line 693
    reportv(ctx___0, 0, (char *)"Uploading smps : %d ", num);
#line 695
    smp = 1024;
    }
    {
#line 695
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 695
      tmp___3 = smp;
#line 695
      smp --;
#line 695
      if (! tmp___3) {
#line 695
        goto while_break___0;
      }
#line 696
      if (! *(d->patch_array + smp)) {
#line 697
        goto __Cont;
      }
#line 698
      patch = *(d->patch_array + smp);
#line 700
      if (patch->len == -1) {
        {
#line 701
        reportv(ctx___0, 0, (char *)"F");
        }
#line 702
        goto __Cont;
      }
      {
#line 705
      crunch = xmp_cvt_crunch(& patch, (unsigned int )ratio);
#line 706
      xmp_cvt_anticlick(patch);
#line 707
      num = (*((d->driver)->writepatch))(ctx___0, patch);
      }
#line 707
      if (num != 0) {
        {
#line 708
        *(d->patch_array + smp) = (struct patch_info *)((void *)0);
#line 709
        free((void *)patch);
        }
      } else {
        {
#line 711
        tmp___0 = realloc((void *)patch, (size_t )sizeof(struct patch_info ));
#line 711
        *(d->patch_array + smp) = (struct patch_info *)tmp___0;
        }
      }
#line 713
      if (o___0->verbosity) {
#line 714
        if (num) {
          {
#line 715
          report((char *)"E");
          }
        } else
#line 716
        if (! crunch) {
          {
#line 717
          report((char *)"i");
          }
        } else {
#line 718
          if (crunch < 65536) {
#line 718
            tmp___2 = "c";
          } else {
#line 718
            if (crunch > 65536) {
#line 718
              tmp___1 = "x";
            } else {
#line 718
              tmp___1 = ".";
            }
#line 718
            tmp___2 = tmp___1;
          }
          {
#line 718
          report((char *)tmp___2);
          }
        }
      }
      __Cont: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 722
    reportv(ctx___0, 0, (char *)"\n");
    }
  } else {
#line 724
    smp = 1024;
    {
#line 724
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 724
      tmp___5 = smp;
#line 724
      smp --;
#line 724
      if (! tmp___5) {
#line 724
        goto while_break___1;
      }
#line 725
      if (! *(d->patch_array + smp)) {
#line 726
        goto __Cont___0;
      }
      {
#line 727
      patch = *(d->patch_array + smp);
#line 728
      xmp_cvt_anticlick(patch);
#line 729
      tmp___4 = (*((d->driver)->writepatch))(ctx___0, patch);
      }
#line 729
      if (tmp___4 != 0) {
        {
#line 730
        *(d->patch_array + smp) = (struct patch_info *)((void *)0);
#line 731
        free((void *)patch);
        }
      }
      __Cont___0: /* CIL Label */ ;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 736
  return (0);
}
}
#line 740 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/player/driver.c"
static void adpcm4_decoder(uint8 *inp , uint8 *outp , char *tab , int len ) 
{ 
  char delta ;
  uint8 b0 ;
  uint8 b1 ;
  int i___3 ;
  uint8 *tmp ;
  uint8 *tmp___0 ;
  uint8 *tmp___1 ;

  {
#line 742
  delta = (char)0;
#line 746
  len = (len + 1) / 2;
#line 748
  i___3 = 0;
  {
#line 748
  while (1) {
    while_continue: /* CIL Label */ ;
#line 748
    if (! (i___3 < len)) {
#line 748
      goto while_break;
    }
#line 749
    b0 = *inp;
#line 750
    tmp = inp;
#line 750
    inp ++;
#line 750
    b1 = (uint8 )((int )*tmp >> 4);
#line 751
    delta = (char )((int )delta + (int )*(tab + ((int )b0 & 15)));
#line 752
    tmp___0 = outp;
#line 752
    outp ++;
#line 752
    *tmp___0 = (uint8 )delta;
#line 753
    delta = (char )((int )delta + (int )*(tab + ((int )b1 & 15)));
#line 754
    tmp___1 = outp;
#line 754
    outp ++;
#line 754
    *tmp___1 = (uint8 )delta;
#line 748
    i___3 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 756
  return;
}
}
#line 759 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/player/driver.c"
int xmp_drv_loadpatch(struct xmp_context *ctx___0 , FILE *f , int id , int basefreq ,
                      int flags , struct xxm_sample *xxs , char *buffer ) 
{ 
  struct xmp_options *o___0 ;
  struct patch_info *patch ;
  int datasize ;
  char s[5] ;
  void *tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  int pos___0 ;
  long tmp___2 ;
  int x2 ;
  char table[16] ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  void *__cil_tmp23 ;
  void *__cil_tmp24 ;
  char *__cil_tmp25 ;

  {
#line 761
  o___0 = & ctx___0->o;
#line 768
  if (! xxs) {
    {
#line 769
    tmp = calloc((size_t )1, (size_t )(sizeof(struct patch_info ) + 11UL));
#line 769
    patch = (struct patch_info *)tmp;
    }
#line 769
    if ((unsigned long )patch == (unsigned long )((void *)0)) {
#line 770
      return (-8);
    }
    {
#line 771
    memcpy((void */* __restrict  */)(patch->data), (void const   */* __restrict  */)buffer,
           (size_t )11);
#line 772
    patch->instr_no = (short )id;
#line 773
    patch->len = -1;
#line 774
    patch->base_note = 60U;
#line 776
    tmp___0 = xmp_drv_writepatch(ctx___0, patch);
    }
#line 776
    return (tmp___0);
  }
#line 779
  if (o___0->skipsmp) {
#line 780
    if (~ flags & 16) {
      {
#line 781
      fseek(f, (long )xxs->len, 1);
      }
    }
#line 782
    return (0);
  }
#line 787
  if (xxs->len < 4) {
#line 788
    if (~ flags & 16) {
      {
#line 789
      fread((void */* __restrict  */)(s), (size_t )1, (size_t )xxs->len, (FILE */* __restrict  */)f);
      }
    }
#line 790
    return (0);
  }
  {
#line 794
  datasize = (int )((sizeof(struct patch_info ) + (unsigned long )xxs->len) + sizeof(int ));
#line 795
  tmp___1 = calloc((size_t )1, (size_t )datasize);
#line 795
  patch = (struct patch_info *)tmp___1;
  }
#line 795
  if ((unsigned long )patch == (unsigned long )((void *)0)) {
#line 796
    return (-8);
  }
#line 798
  if (flags & 16) {
    {
#line 799
    memcpy((void */* __restrict  */)(patch->data), (void const   */* __restrict  */)buffer,
           (size_t )xxs->len);
    }
  } else {
    {
#line 801
    tmp___2 = ftell(f);
#line 801
    pos___0 = (int )tmp___2;
#line 802
    fread((void */* __restrict  */)(s), (size_t )1, (size_t )5, (FILE */* __restrict  */)f);
#line 803
    fseek(f, (long )pos___0, 0);
#line 805
    tmp___3 = strncmp((char const   *)(s), "ADPCM", (size_t )5);
    }
#line 805
    if (tmp___3) {
      {
#line 815
      fread((void */* __restrict  */)(patch->data), (size_t )1, (size_t )xxs->len,
            (FILE */* __restrict  */)f);
      }
    } else {
      {
#line 806
      x2 = xxs->len >> 1;
#line 809
      fseek(f, 5L, 1);
#line 810
      fread((void */* __restrict  */)(table), (size_t )1, (size_t )16, (FILE */* __restrict  */)f);
#line 811
      fread((void */* __restrict  */)(patch->data + x2), (size_t )1, (size_t )x2,
            (FILE */* __restrict  */)f);
#line 812
      adpcm4_decoder((uint8 *)(patch->data) + x2, (uint8 *)(patch->data), table, xxs->len);
      }
    }
  }
#line 820
  if (xxs->flg & 1) {
#line 821
    if (! (! o___0->big_endian) ^ ! (! (flags & 64))) {
      {
#line 822
      xmp_cvt_sex(xxs->len, patch->data);
      }
    }
  }
#line 825
  if (flags & 256) {
    {
#line 826
    xmp_cvt_stdownmix(xxs->len, xxs->flg & 1, patch->data);
#line 827
    xxs->len /= 2;
    }
  }
#line 830
  if (flags & 8) {
    {
#line 831
    xmp_cvt_2xsmp(xxs->len, patch->data);
    }
  }
#line 833
  if (flags & 1) {
    {
#line 834
    xmp_cvt_diff2abs(xxs->len, xxs->flg & 1, patch->data);
    }
  } else
#line 835
  if (flags & 4) {
    {
#line 836
    xmp_cvt_diff2abs(xxs->len, 0, patch->data);
    }
  }
#line 838
  if (flags & 128) {
    {
#line 839
    xmp_cvt_vidc(xxs->len, patch->data);
    }
  }
#line 843
  if (xxs->flg & 1) {
#line 844
    patch->data[xxs->len] = patch->data[xxs->len - 2];
#line 845
    patch->data[xxs->len + 1] = patch->data[xxs->len - 1];
#line 846
    xxs->len += 2;
  } else {
#line 848
    patch->data[xxs->len] = patch->data[xxs->len - 1];
#line 849
    (xxs->len) ++;
  }
#line 862
  patch->key = (unsigned short )((4 << 8) | 253);
#line 863
  patch->instr_no = (short )id;
#line 864
  patch->mode = (unsigned int )xxs->flg;
#line 865
  if (flags & 2) {
#line 865
    tmp___4 = 2;
  } else {
#line 865
    tmp___4 = 0;
  }
#line 865
  patch->mode |= (unsigned int )tmp___4;
#line 866
  patch->len = xxs->len;
#line 867
  if (xxs->lps > xxs->len) {
#line 867
    patch->loop_start = xxs->len;
  } else {
#line 867
    patch->loop_start = xxs->lps;
  }
#line 868
  if (xxs->lpe > xxs->len) {
#line 868
    patch->loop_end = xxs->len;
  } else {
#line 868
    patch->loop_end = xxs->lpe;
  }
#line 869
  if (patch->loop_end <= patch->loop_start) {
#line 870
    patch->mode &= 4294967267U;
  } else
#line 869
  if (! (patch->mode & 4U)) {
#line 870
    patch->mode &= 4294967267U;
  }
#line 872
  patch->base_note = 130812U;
#line 873
  patch->base_freq = (unsigned int )basefreq;
#line 874
  patch->high_note = 2147483647U;
#line 875
  patch->low_note = 0U;
#line 876
  patch->volume = 120;
#line 877
  patch->detuning = 0;
#line 878
  patch->panning = 0;
#line 880
  if (flags & 32) {
#line 880
    tmp___5 = 524288;
  } else {
#line 880
    tmp___5 = 65536;
  }
  {
#line 880
  xmp_cvt_crunch(& patch, (unsigned int )tmp___5);
#line 882
  tmp___6 = xmp_drv_writepatch(ctx___0, patch);
  }
#line 882
  return (tmp___6);
}
}
#line 886 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/player/driver.c"
__inline struct xmp_drv_info *xmp_drv_array(void) 
{ 


  {
#line 888
  return (drv_array);
}
}
#line 7 "src/include/convert.h"
void xmp_cvt_hsc2sbi(char *a ) ;
#line 14
void xmp_cvt_to8bit(struct xmp_context *ctx___0 ) ;
#line 15
void xmp_cvt_to16bit(struct xmp_context *ctx___0 ) ;
#line 16
void xmp_cvt_bid2und(struct xmp_context *ctx___0 ) ;
#line 32 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/player/convert.c"
static int8 vdic_table[128]  = 
#line 32 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/player/convert.c"
  {      (int8 )0,      (int8 )0,      (int8 )0,      (int8 )0, 
        (int8 )0,      (int8 )0,      (int8 )0,      (int8 )0, 
        (int8 )0,      (int8 )0,      (int8 )0,      (int8 )0, 
        (int8 )0,      (int8 )0,      (int8 )0,      (int8 )0, 
        (int8 )0,      (int8 )0,      (int8 )0,      (int8 )0, 
        (int8 )0,      (int8 )0,      (int8 )0,      (int8 )0, 
        (int8 )1,      (int8 )1,      (int8 )1,      (int8 )1, 
        (int8 )1,      (int8 )1,      (int8 )1,      (int8 )1, 
        (int8 )1,      (int8 )1,      (int8 )1,      (int8 )1, 
        (int8 )2,      (int8 )2,      (int8 )2,      (int8 )2, 
        (int8 )2,      (int8 )2,      (int8 )2,      (int8 )2, 
        (int8 )3,      (int8 )3,      (int8 )3,      (int8 )3, 
        (int8 )3,      (int8 )3,      (int8 )4,      (int8 )4, 
        (int8 )4,      (int8 )4,      (int8 )5,      (int8 )5, 
        (int8 )5,      (int8 )5,      (int8 )6,      (int8 )6, 
        (int8 )6,      (int8 )6,      (int8 )7,      (int8 )7, 
        (int8 )7,      (int8 )8,      (int8 )8,      (int8 )9, 
        (int8 )9,      (int8 )10,      (int8 )10,      (int8 )11, 
        (int8 )11,      (int8 )12,      (int8 )12,      (int8 )13, 
        (int8 )13,      (int8 )14,      (int8 )14,      (int8 )15, 
        (int8 )15,      (int8 )16,      (int8 )17,      (int8 )18, 
        (int8 )19,      (int8 )20,      (int8 )21,      (int8 )22, 
        (int8 )23,      (int8 )24,      (int8 )25,      (int8 )26, 
        (int8 )27,      (int8 )28,      (int8 )29,      (int8 )30, 
        (int8 )31,      (int8 )33,      (int8 )34,      (int8 )36, 
        (int8 )38,      (int8 )40,      (int8 )42,      (int8 )44, 
        (int8 )46,      (int8 )48,      (int8 )50,      (int8 )52, 
        (int8 )54,      (int8 )56,      (int8 )58,      (int8 )60, 
        (int8 )62,      (int8 )65,      (int8 )68,      (int8 )72, 
        (int8 )77,      (int8 )80,      (int8 )84,      (int8 )91, 
        (int8 )95,      (int8 )98,      (int8 )103,      (int8 )109, 
        (int8 )114,      (int8 )120,      (int8 )126,      (int8 )127};
#line 54 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/player/convert.c"
void xmp_cvt_diff2abs(int l , int r , char *p ) 
{ 
  uint16 *w ;
  uint16 abs___0 ;
  uint16 *tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;

  {
#line 56
  w = (uint16 *)p;
#line 57
  abs___0 = (uint16 )0;
#line 59
  if (r) {
#line 60
    l >>= 1;
    {
#line 60
    while (1) {
      while_continue: /* CIL Label */ ;
#line 60
      tmp___0 = l;
#line 60
      l --;
#line 60
      if (! tmp___0) {
#line 60
        goto while_break;
      }
#line 61
      abs___0 = (uint16 )((int )*w + (int )abs___0);
#line 62
      tmp = w;
#line 62
      w ++;
#line 62
      *tmp = abs___0;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
#line 65
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 65
      tmp___2 = l;
#line 65
      l --;
#line 65
      if (! tmp___2) {
#line 65
        goto while_break___0;
      }
#line 66
      abs___0 = (uint16 )((int )*p + (int )abs___0);
#line 67
      tmp___1 = p;
#line 67
      p ++;
#line 67
      *tmp___1 = (char )((uint8 )abs___0);
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 70
  return;
}
}
#line 74 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/player/convert.c"
void xmp_cvt_sig2uns(int l , int r , char *p ) 
{ 
  uint16 *w ;
  int tmp ;
  int tmp___0 ;

  {
#line 76
  w = (uint16 *)p;
#line 78
  if (r) {
#line 79
    l >>= 1;
    {
#line 79
    while (1) {
      while_continue: /* CIL Label */ ;
#line 79
      tmp = l;
#line 79
      l --;
#line 79
      if (! tmp) {
#line 79
        goto while_break;
      }
#line 80
      *w = (uint16 )((int )*w + 32768);
#line 79
      w ++;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
#line 82
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 82
      tmp___0 = l;
#line 82
      l --;
#line 82
      if (! tmp___0) {
#line 82
        goto while_break___0;
      }
#line 83
      *p = (char )((int )*p + -128);
#line 82
      p ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 85
  return;
}
}
#line 89 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/player/convert.c"
void xmp_cvt_sex(int l , char *p ) 
{ 
  uint8 b___1 ;
  int tmp ;

  {
#line 93
  l >>= 1;
  {
#line 93
  while (1) {
    while_continue: /* CIL Label */ ;
#line 93
    tmp = l;
#line 93
    l --;
#line 93
    if (! tmp) {
#line 93
      goto while_break;
    }
#line 94
    b___1 = (uint8 )*(p + 0);
#line 95
    *(p + 0) = *(p + 1);
#line 96
    *(p + 1) = (char )b___1;
#line 97
    p += 2;
  }
  while_break: /* CIL Label */ ;
  }
#line 99
  return;
}
}
#line 103 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/player/convert.c"
void xmp_cvt_stdownmix(int l , int r , char *p ) 
{ 
  int16 *b___1 ;
  int i___3 ;

  {
#line 105
  b___1 = (int16 *)p;
#line 108
  if (r) {
#line 109
    l /= 4;
#line 110
    i___3 = 0;
    {
#line 110
    while (1) {
      while_continue: /* CIL Label */ ;
#line 110
      if (! (i___3 < l)) {
#line 110
        goto while_break;
      }
#line 111
      *(b___1 + i___3) = (int16 )(((int )*(b___1 + i___3 * 2) + (int )*(b___1 + (i___3 * 2 + 1))) / 2);
#line 110
      i___3 ++;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 113
    l /= 2;
#line 114
    i___3 = 0;
    {
#line 114
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 114
      if (! (i___3 < l)) {
#line 114
        goto while_break___0;
      }
#line 115
      *(p + i___3) = (char )(((int )*(p + i___3 * 2) + (int )*(p + (i___3 * 2 + 1))) / 2);
#line 114
      i___3 ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 117
  return;
}
}
#line 121 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/player/convert.c"
void xmp_cvt_2xsmp(int l , char *p ) 
{ 
  char *tmp ;
  int tmp___0 ;

  {
  {
#line 123
  while (1) {
    while_continue: /* CIL Label */ ;
#line 123
    tmp___0 = l;
#line 123
    l --;
#line 123
    if (! tmp___0) {
#line 123
      goto while_break;
    }
#line 123
    tmp = p;
#line 123
    p ++;
#line 123
    *tmp = (char )((int )*tmp << 1);
  }
  while_break: /* CIL Label */ ;
  }
#line 124
  return;
}
}
#line 128 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/player/convert.c"
void xmp_cvt_vidc(int l , char *p ) 
{ 
  int i___3 ;
  uint8 x ;

  {
#line 133
  i___3 = 0;
  {
#line 133
  while (1) {
    while_continue: /* CIL Label */ ;
#line 133
    if (! (i___3 < l)) {
#line 133
      goto while_break;
    }
#line 134
    x = (uint8 )*(p + i___3);
#line 135
    *(p + i___3) = (char )vdic_table[(int )x >> 1];
#line 136
    if ((int )x & 1) {
#line 137
      *(p + i___3) = (char )((int )*(p + i___3) * -1);
    }
#line 133
    i___3 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 139
  return;
}
}
#line 143 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/player/convert.c"
void xmp_cvt_to8bit(struct xmp_context *ctx___0 ) 
{ 
  struct xmp_driver_context *d ;
  int l ;
  int smp ;
  int8 *p8 ;
  int16 *p16 ;
  struct patch_info *patch ;
  int tmp ;
  int8 *tmp___0 ;
  int16 *tmp___1 ;
  int tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;

  {
#line 145
  d = & ctx___0->d;
#line 151
  smp = 1024;
  {
#line 151
  while (1) {
    while_continue: /* CIL Label */ ;
#line 151
    tmp___4 = smp;
#line 151
    smp --;
#line 151
    if (! tmp___4) {
#line 151
      goto while_break;
    }
#line 152
    patch = *(d->patch_array + smp);
#line 154
    if (patch) {
#line 154
      if (patch->mode & 1U) {
#line 154
        if (! (patch->len != -1)) {
#line 156
          goto __Cont;
        }
      } else {
#line 156
        goto __Cont;
      }
    } else {
#line 156
      goto __Cont;
    }
#line 158
    patch->mode &= 4294967294U;
#line 160
    p8 = (int8 *)(patch->data);
#line 161
    p16 = (int16 *)(patch->data);
#line 163
    patch->loop_end >>= 1;
#line 164
    patch->loop_start >>= 1;
#line 165
    tmp = patch->len >> 1;
#line 165
    patch->len = tmp;
#line 165
    l = tmp;
    {
#line 165
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 165
      tmp___2 = l;
#line 165
      l --;
#line 165
      if (! tmp___2) {
#line 165
        goto while_break___0;
      }
#line 165
      tmp___0 = p8;
#line 165
      p8 ++;
#line 165
      tmp___1 = p16;
#line 165
      p16 ++;
#line 165
      *tmp___0 = (int8 )((int )((int8 )*tmp___1) >> 8);
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 167
    tmp___3 = realloc((void *)patch, (size_t )(sizeof(struct patch_info ) + (unsigned long )patch->len));
#line 167
    *(d->patch_array + smp) = (struct patch_info *)tmp___3;
    }
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 170
  return;
}
}
#line 174 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/player/convert.c"
void xmp_cvt_to16bit(struct xmp_context *ctx___0 ) 
{ 
  struct xmp_driver_context *d ;
  int l ;
  int smp ;
  int8 *p8 ;
  int16 *p16 ;
  struct patch_info *patch ;
  int tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 176
  d = & ctx___0->d;
#line 182
  smp = 1024;
  {
#line 182
  while (1) {
    while_continue: /* CIL Label */ ;
#line 182
    tmp___2 = smp;
#line 182
    smp --;
#line 182
    if (! tmp___2) {
#line 182
      goto while_break;
    }
#line 183
    patch = *(d->patch_array + smp);
#line 184
    if (! patch) {
#line 186
      goto __Cont;
    } else
#line 184
    if (patch->mode & 1U) {
#line 186
      goto __Cont;
    } else
#line 184
    if (patch->len == -1) {
#line 186
      goto __Cont;
    }
    {
#line 188
    patch->mode |= 1U;
#line 190
    l = patch->len;
#line 191
    tmp = patch->len << 1;
#line 191
    patch->len = tmp;
#line 191
    tmp___0 = realloc((void *)patch, (size_t )(sizeof(struct patch_info ) + (unsigned long )tmp));
#line 191
    patch = (struct patch_info *)tmp___0;
#line 193
    patch->loop_start <<= 1;
#line 194
    patch->loop_end <<= 1;
#line 196
    p8 = (int8 *)(patch->data);
#line 197
    p16 = (int16 *)(patch->data);
#line 198
    p8 += l;
#line 198
    p16 += l;
    }
    {
#line 198
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 198
      tmp___1 = l;
#line 198
      l --;
#line 198
      if (! tmp___1) {
#line 198
        goto while_break___0;
      }
#line 198
      p16 --;
#line 198
      p8 --;
#line 198
      *p16 = (int16 )((int )((int16 )*p8) << 8);
    }
    while_break___0: /* CIL Label */ ;
    }
#line 200
    *(d->patch_array + smp) = patch;
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 202
  return;
}
}
#line 206 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/player/convert.c"
void xmp_cvt_anticlick(struct patch_info *patch ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 208
  if (patch->len == -1) {
#line 209
    return;
  }
#line 213
  if (patch->mode & 4U) {
#line 213
    if (! (patch->mode & 8U)) {
#line 214
      if (patch->mode & 1U) {
#line 215
        tmp = patch->loop_end;
#line 215
        (patch->loop_end) ++;
#line 215
        tmp___0 = patch->loop_start;
#line 215
        (patch->loop_start) ++;
#line 215
        patch->data[tmp] = patch->data[tmp___0];
#line 216
        tmp___1 = patch->loop_end;
#line 216
        (patch->loop_end) ++;
#line 216
        tmp___2 = patch->loop_start;
#line 216
        (patch->loop_start) ++;
#line 216
        patch->data[tmp___1] = patch->data[tmp___2];
#line 217
        patch->data[patch->loop_end] = patch->data[patch->loop_start];
#line 218
        patch->data[patch->loop_end + 1] = patch->data[patch->loop_start + 1];
#line 219
        patch->len += 4;
      } else {
#line 221
        tmp___3 = patch->loop_end;
#line 221
        (patch->loop_end) ++;
#line 221
        tmp___4 = patch->loop_start;
#line 221
        (patch->loop_start) ++;
#line 221
        patch->data[tmp___3] = patch->data[tmp___4];
#line 222
        patch->data[patch->loop_end] = patch->data[patch->loop_start];
#line 223
        patch->len += 2;
      }
    } else {
#line 213
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 227
  if (patch->mode & 1U) {
#line 228
    patch->data[patch->len] = patch->data[patch->len - 2];
#line 229
    patch->data[patch->len + 1] = patch->data[patch->len - 1];
#line 230
    patch->len += 2;
  } else {
#line 232
    patch->data[patch->len] = patch->data[patch->len - 1];
#line 233
    (patch->len) ++;
  }
#line 236
  return;
}
}
#line 240 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/player/convert.c"
void xmp_cvt_bid2und(struct xmp_context *ctx___0 ) 
{ 
  struct xmp_driver_context *d ;
  int8 *s8 ;
  int16 *s16 ;
  int r ;
  int l ;
  int le ;
  int smp ;
  struct patch_info *patch ;
  int tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 242
  d = & ctx___0->d;
#line 248
  smp = 1024;
  {
#line 248
  while (1) {
    while_continue: /* CIL Label */ ;
#line 248
    tmp___3 = smp;
#line 248
    smp --;
#line 248
    if (! tmp___3) {
#line 248
      goto while_break;
    }
#line 249
    patch = *(d->patch_array + smp);
#line 250
    if (patch) {
#line 250
      if (patch->mode & 8U) {
#line 250
        if (! (patch->len != -1)) {
#line 252
          goto __Cont;
        }
      } else {
#line 252
        goto __Cont;
      }
    } else {
#line 252
      goto __Cont;
    }
#line 254
    patch->mode &= 4294967287U;
#line 256
    r = ! (! (patch->mode & 1U));
#line 257
    le = patch->loop_end >> r;
#line 258
    l = patch->len >> r;
#line 259
    if (l > le) {
#line 259
      l = le;
    } else {
#line 259
      l --;
    }
    {
#line 259
    le = l;
#line 260
    l -= patch->loop_start >> r;
#line 261
    le --;
#line 261
    tmp = (le + l) << r;
#line 261
    patch->loop_end = tmp;
#line 261
    patch->len = tmp;
#line 262
    tmp___0 = realloc((void *)patch, (size_t )((sizeof(struct patch_info ) + (unsigned long )patch->len) + sizeof(int )));
#line 262
    patch = (struct patch_info *)tmp___0;
#line 265
    s8 = (int8 *)(patch->data);
#line 266
    s16 = (int16 *)(patch->data);
    }
#line 267
    if (r) {
#line 268
      s16 += le;
      {
#line 268
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 268
        tmp___1 = l;
#line 268
        l --;
#line 268
        if (! tmp___1) {
#line 268
          goto while_break___0;
        }
#line 268
        *(s16 + l) = *(s16 - l);
      }
      while_break___0: /* CIL Label */ ;
      }
    } else {
#line 270
      s8 += le;
      {
#line 270
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 270
        tmp___2 = l;
#line 270
        l --;
#line 270
        if (! tmp___2) {
#line 270
          goto while_break___1;
        }
#line 270
        *(s8 + l) = *(s8 - l);
      }
      while_break___1: /* CIL Label */ ;
      }
    }
    {
#line 272
    xmp_cvt_anticlick(patch);
#line 273
    *(d->patch_array + smp) = patch;
    }
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 275
  return;
}
}
#line 279 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/player/convert.c"
void xmp_cvt_hsc2sbi(char *a ) 
{ 
  char b___1[11] ;
  int i___3 ;
  uint8 x ;
  void *__cil_tmp5 ;

  {
#line 284
  i___3 = 0;
  {
#line 284
  while (1) {
    while_continue: /* CIL Label */ ;
#line 284
    if (! (i___3 < 10)) {
#line 284
      goto while_break;
    }
#line 286
    x = (uint8 )*(a + i___3);
#line 287
    *(a + i___3) = *(a + (i___3 + 1));
#line 288
    *(a + (i___3 + 1)) = (char )x;
#line 284
    i___3 += 2;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 291
  memcpy((void */* __restrict  */)(b___1), (void const   */* __restrict  */)a, (size_t )11);
#line 292
  *(a + 8) = b___1[10];
#line 293
  *(a + 10) = b___1[9];
#line 294
  *(a + 9) = b___1[8];
  }
#line 295
  return;
}
}
#line 688 "/usr/include/stdio.h"
extern size_t fwrite(void const   * __restrict  __ptr , size_t __size , size_t __n ,
                     FILE * __restrict  __s ) ;
#line 803
extern  __attribute__((__nothrow__)) int ferror(FILE *__stream ) ;
#line 340 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strstr)(char const   *__haystack ,
                                                                                       char const   *__needle )  __attribute__((__pure__)) ;
#line 30 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/misc/unlzx.c"
int mode  ;
#line 32 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/misc/unlzx.c"
unsigned char info_header[10]  ;
#line 33 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/misc/unlzx.c"
unsigned char archive_header[31]  ;
#line 34 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/misc/unlzx.c"
unsigned char header_filename[256]  ;
#line 35 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/misc/unlzx.c"
unsigned char header_comment[256]  ;
#line 37 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/misc/unlzx.c"
unsigned int pack_size  ;
#line 38 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/misc/unlzx.c"
unsigned int unpack_size  ;
#line 40 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/misc/unlzx.c"
unsigned int crc  ;
#line 41 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/misc/unlzx.c"
unsigned int year  ;
#line 41 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/misc/unlzx.c"
unsigned int month  ;
#line 41 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/misc/unlzx.c"
unsigned int day  ;
#line 42 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/misc/unlzx.c"
unsigned int hour  ;
#line 42 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/misc/unlzx.c"
unsigned int minute  ;
#line 42 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/misc/unlzx.c"
unsigned int second  ;
#line 43 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/misc/unlzx.c"
unsigned char attributes  ;
#line 44 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/misc/unlzx.c"
unsigned char pack_mode  ;
#line 56 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/misc/unlzx.c"
struct filename_node *filename_list  ;
#line 60 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/misc/unlzx.c"
unsigned char read_buffer[16384]  ;
#line 61 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/misc/unlzx.c"
unsigned char decrunch_buffer[66052]  ;
#line 63 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/misc/unlzx.c"
unsigned char *source  ;
#line 64 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/misc/unlzx.c"
unsigned char *destination  ;
#line 65 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/misc/unlzx.c"
unsigned char *source_end  ;
#line 66 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/misc/unlzx.c"
unsigned char *destination_end  ;
#line 68 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/misc/unlzx.c"
unsigned int decrunch_method  ;
#line 69 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/misc/unlzx.c"
unsigned int decrunch_length  ;
#line 70 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/misc/unlzx.c"
unsigned int last_offset  ;
#line 71 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/misc/unlzx.c"
unsigned int global_control  ;
#line 72 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/misc/unlzx.c"
int global_shift  ;
#line 74 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/misc/unlzx.c"
unsigned char offset_len[8]  ;
#line 75 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/misc/unlzx.c"
unsigned short offset_table[128]  ;
#line 76 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/misc/unlzx.c"
unsigned char huffman20_len[20]  ;
#line 77 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/misc/unlzx.c"
unsigned short huffman20_table[96]  ;
#line 78 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/misc/unlzx.c"
unsigned char literal_len[768]  ;
#line 79 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/misc/unlzx.c"
unsigned short literal_table[5120]  ;
#line 93 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/misc/unlzx.c"
unsigned int sum  ;
#line 95 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/misc/unlzx.c"
static unsigned int const   crc_table[256]  = 
#line 95
  {      (unsigned int const   )0,      (unsigned int const   )1996959894,      (unsigned int const   )3993919788U,      (unsigned int const   )2567524794U, 
        (unsigned int const   )124634137,      (unsigned int const   )1886057615,      (unsigned int const   )3915621685U,      (unsigned int const   )2657392035U, 
        (unsigned int const   )249268274,      (unsigned int const   )2044508324,      (unsigned int const   )3772115230U,      (unsigned int const   )2547177864U, 
        (unsigned int const   )162941995,      (unsigned int const   )2125561021,      (unsigned int const   )3887607047U,      (unsigned int const   )2428444049U, 
        (unsigned int const   )498536548,      (unsigned int const   )1789927666,      (unsigned int const   )4089016648U,      (unsigned int const   )2227061214U, 
        (unsigned int const   )450548861,      (unsigned int const   )1843258603,      (unsigned int const   )4107580753U,      (unsigned int const   )2211677639U, 
        (unsigned int const   )325883990,      (unsigned int const   )1684777152,      (unsigned int const   )4251122042U,      (unsigned int const   )2321926636U, 
        (unsigned int const   )335633487,      (unsigned int const   )1661365465,      (unsigned int const   )4195302755U,      (unsigned int const   )2366115317U, 
        (unsigned int const   )997073096,      (unsigned int const   )1281953886,      (unsigned int const   )3579855332U,      (unsigned int const   )2724688242U, 
        (unsigned int const   )1006888145,      (unsigned int const   )1258607687,      (unsigned int const   )3524101629U,      (unsigned int const   )2768942443U, 
        (unsigned int const   )901097722,      (unsigned int const   )1119000684,      (unsigned int const   )3686517206U,      (unsigned int const   )2898065728U, 
        (unsigned int const   )853044451,      (unsigned int const   )1172266101,      (unsigned int const   )3705015759U,      (unsigned int const   )2882616665U, 
        (unsigned int const   )651767980,      (unsigned int const   )1373503546,      (unsigned int const   )3369554304U,      (unsigned int const   )3218104598U, 
        (unsigned int const   )565507253,      (unsigned int const   )1454621731,      (unsigned int const   )3485111705U,      (unsigned int const   )3099436303U, 
        (unsigned int const   )671266974,      (unsigned int const   )1594198024,      (unsigned int const   )3322730930U,      (unsigned int const   )2970347812U, 
        (unsigned int const   )795835527,      (unsigned int const   )1483230225,      (unsigned int const   )3244367275U,      (unsigned int const   )3060149565U, 
        (unsigned int const   )1994146192,      (unsigned int const   )31158534,      (unsigned int const   )2563907772U,      (unsigned int const   )4023717930U, 
        (unsigned int const   )1907459465,      (unsigned int const   )112637215,      (unsigned int const   )2680153253U,      (unsigned int const   )3904427059U, 
        (unsigned int const   )2013776290,      (unsigned int const   )251722036,      (unsigned int const   )2517215374U,      (unsigned int const   )3775830040U, 
        (unsigned int const   )2137656763,      (unsigned int const   )141376813,      (unsigned int const   )2439277719U,      (unsigned int const   )3865271297U, 
        (unsigned int const   )1802195444,      (unsigned int const   )476864866,      (unsigned int const   )2238001368U,      (unsigned int const   )4066508878U, 
        (unsigned int const   )1812370925,      (unsigned int const   )453092731,      (unsigned int const   )2181625025U,      (unsigned int const   )4111451223U, 
        (unsigned int const   )1706088902,      (unsigned int const   )314042704,      (unsigned int const   )2344532202U,      (unsigned int const   )4240017532U, 
        (unsigned int const   )1658658271,      (unsigned int const   )366619977,      (unsigned int const   )2362670323U,      (unsigned int const   )4224994405U, 
        (unsigned int const   )1303535960,      (unsigned int const   )984961486,      (unsigned int const   )2747007092U,      (unsigned int const   )3569037538U, 
        (unsigned int const   )1256170817,      (unsigned int const   )1037604311,      (unsigned int const   )2765210733U,      (unsigned int const   )3554079995U, 
        (unsigned int const   )1131014506,      (unsigned int const   )879679996,      (unsigned int const   )2909243462U,      (unsigned int const   )3663771856U, 
        (unsigned int const   )1141124467,      (unsigned int const   )855842277,      (unsigned int const   )2852801631U,      (unsigned int const   )3708648649U, 
        (unsigned int const   )1342533948,      (unsigned int const   )654459306,      (unsigned int const   )3188396048U,      (unsigned int const   )3373015174U, 
        (unsigned int const   )1466479909,      (unsigned int const   )544179635,      (unsigned int const   )3110523913U,      (unsigned int const   )3462522015U, 
        (unsigned int const   )1591671054,      (unsigned int const   )702138776,      (unsigned int const   )2966460450U,      (unsigned int const   )3352799412U, 
        (unsigned int const   )1504918807,      (unsigned int const   )783551873,      (unsigned int const   )3082640443U,      (unsigned int const   )3233442989U, 
        (unsigned int const   )3988292384U,      (unsigned int const   )2596254646U,      (unsigned int const   )62317068,      (unsigned int const   )1957810842, 
        (unsigned int const   )3939845945U,      (unsigned int const   )2647816111U,      (unsigned int const   )81470997,      (unsigned int const   )1943803523, 
        (unsigned int const   )3814918930U,      (unsigned int const   )2489596804U,      (unsigned int const   )225274430,      (unsigned int const   )2053790376, 
        (unsigned int const   )3826175755U,      (unsigned int const   )2466906013U,      (unsigned int const   )167816743,      (unsigned int const   )2097651377, 
        (unsigned int const   )4027552580U,      (unsigned int const   )2265490386U,      (unsigned int const   )503444072,      (unsigned int const   )1762050814, 
        (unsigned int const   )4150417245U,      (unsigned int const   )2154129355U,      (unsigned int const   )426522225,      (unsigned int const   )1852507879, 
        (unsigned int const   )4275313526U,      (unsigned int const   )2312317920U,      (unsigned int const   )282753626,      (unsigned int const   )1742555852, 
        (unsigned int const   )4189708143U,      (unsigned int const   )2394877945U,      (unsigned int const   )397917763,      (unsigned int const   )1622183637, 
        (unsigned int const   )3604390888U,      (unsigned int const   )2714866558U,      (unsigned int const   )953729732,      (unsigned int const   )1340076626, 
        (unsigned int const   )3518719985U,      (unsigned int const   )2797360999U,      (unsigned int const   )1068828381,      (unsigned int const   )1219638859, 
        (unsigned int const   )3624741850U,      (unsigned int const   )2936675148U,      (unsigned int const   )906185462,      (unsigned int const   )1090812512, 
        (unsigned int const   )3747672003U,      (unsigned int const   )2825379669U,      (unsigned int const   )829329135,      (unsigned int const   )1181335161, 
        (unsigned int const   )3412177804U,      (unsigned int const   )3160834842U,      (unsigned int const   )628085408,      (unsigned int const   )1382605366, 
        (unsigned int const   )3423369109U,      (unsigned int const   )3138078467U,      (unsigned int const   )570562233,      (unsigned int const   )1426400815, 
        (unsigned int const   )3317316542U,      (unsigned int const   )2998733608U,      (unsigned int const   )733239954,      (unsigned int const   )1555261956, 
        (unsigned int const   )3268935591U,      (unsigned int const   )3050360625U,      (unsigned int const   )752459403,      (unsigned int const   )1541320221, 
        (unsigned int const   )2607071920U,      (unsigned int const   )3965973030U,      (unsigned int const   )1969922972,      (unsigned int const   )40735498, 
        (unsigned int const   )2617837225U,      (unsigned int const   )3943577151U,      (unsigned int const   )1913087877,      (unsigned int const   )83908371, 
        (unsigned int const   )2512341634U,      (unsigned int const   )3803740692U,      (unsigned int const   )2075208622,      (unsigned int const   )213261112, 
        (unsigned int const   )2463272603U,      (unsigned int const   )3855990285U,      (unsigned int const   )2094854071,      (unsigned int const   )198958881, 
        (unsigned int const   )2262029012U,      (unsigned int const   )4057260610U,      (unsigned int const   )1759359992,      (unsigned int const   )534414190, 
        (unsigned int const   )2176718541U,      (unsigned int const   )4139329115U,      (unsigned int const   )1873836001,      (unsigned int const   )414664567, 
        (unsigned int const   )2282248934U,      (unsigned int const   )4279200368U,      (unsigned int const   )1711684554,      (unsigned int const   )285281116, 
        (unsigned int const   )2405801727U,      (unsigned int const   )4167216745U,      (unsigned int const   )1634467795,      (unsigned int const   )376229701, 
        (unsigned int const   )2685067896U,      (unsigned int const   )3608007406U,      (unsigned int const   )1308918612,      (unsigned int const   )956543938, 
        (unsigned int const   )2808555105U,      (unsigned int const   )3495958263U,      (unsigned int const   )1231636301,      (unsigned int const   )1047427035, 
        (unsigned int const   )2932959818U,      (unsigned int const   )3654703836U,      (unsigned int const   )1088359270,      (unsigned int const   )936918000, 
        (unsigned int const   )2847714899U,      (unsigned int const   )3736837829U,      (unsigned int const   )1202900863,      (unsigned int const   )817233897, 
        (unsigned int const   )3183342108U,      (unsigned int const   )3401237130U,      (unsigned int const   )1404277552,      (unsigned int const   )615818150, 
        (unsigned int const   )3134207493U,      (unsigned int const   )3453421203U,      (unsigned int const   )1423857449,      (unsigned int const   )601450431, 
        (unsigned int const   )3009837614U,      (unsigned int const   )3294710456U,      (unsigned int const   )1567103746,      (unsigned int const   )711928724, 
        (unsigned int const   )3020668471U,      (unsigned int const   )3272380065U,      (unsigned int const   )1510334235,      (unsigned int const   )755167117};
#line 144 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/misc/unlzx.c"
static unsigned char const   table_one[32]  = 
#line 144
  {      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )3,      (unsigned char const   )3,      (unsigned char const   )4,      (unsigned char const   )4, 
        (unsigned char const   )5,      (unsigned char const   )5,      (unsigned char const   )6,      (unsigned char const   )6, 
        (unsigned char const   )7,      (unsigned char const   )7,      (unsigned char const   )8,      (unsigned char const   )8, 
        (unsigned char const   )9,      (unsigned char const   )9,      (unsigned char const   )10,      (unsigned char const   )10, 
        (unsigned char const   )11,      (unsigned char const   )11,      (unsigned char const   )12,      (unsigned char const   )12, 
        (unsigned char const   )13,      (unsigned char const   )13,      (unsigned char const   )14,      (unsigned char const   )14};
#line 149 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/misc/unlzx.c"
static unsigned int const   table_two[32]  = 
#line 149
  {      (unsigned int const   )0,      (unsigned int const   )1,      (unsigned int const   )2,      (unsigned int const   )3, 
        (unsigned int const   )4,      (unsigned int const   )6,      (unsigned int const   )8,      (unsigned int const   )12, 
        (unsigned int const   )16,      (unsigned int const   )24,      (unsigned int const   )32,      (unsigned int const   )48, 
        (unsigned int const   )64,      (unsigned int const   )96,      (unsigned int const   )128,      (unsigned int const   )192, 
        (unsigned int const   )256,      (unsigned int const   )384,      (unsigned int const   )512,      (unsigned int const   )768, 
        (unsigned int const   )1024,      (unsigned int const   )1536,      (unsigned int const   )2048,      (unsigned int const   )3072, 
        (unsigned int const   )4096,      (unsigned int const   )6144,      (unsigned int const   )8192,      (unsigned int const   )12288, 
        (unsigned int const   )16384,      (unsigned int const   )24576,      (unsigned int const   )32768,      (unsigned int const   )49152};
#line 155 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/misc/unlzx.c"
static unsigned int const   table_three[16]  = 
#line 155
  {      (unsigned int const   )0,      (unsigned int const   )1,      (unsigned int const   )3,      (unsigned int const   )7, 
        (unsigned int const   )15,      (unsigned int const   )31,      (unsigned int const   )63,      (unsigned int const   )127, 
        (unsigned int const   )255,      (unsigned int const   )511,      (unsigned int const   )1023,      (unsigned int const   )2047, 
        (unsigned int const   )4095,      (unsigned int const   )8191,      (unsigned int const   )16383,      (unsigned int const   )32767};
#line 160 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/misc/unlzx.c"
static unsigned char const   table_four[34]  = 
#line 160
  {      (unsigned char const   )0,      (unsigned char const   )1,      (unsigned char const   )2,      (unsigned char const   )3, 
        (unsigned char const   )4,      (unsigned char const   )5,      (unsigned char const   )6,      (unsigned char const   )7, 
        (unsigned char const   )8,      (unsigned char const   )9,      (unsigned char const   )10,      (unsigned char const   )11, 
        (unsigned char const   )12,      (unsigned char const   )13,      (unsigned char const   )14,      (unsigned char const   )15, 
        (unsigned char const   )16,      (unsigned char const   )0,      (unsigned char const   )1,      (unsigned char const   )2, 
        (unsigned char const   )3,      (unsigned char const   )4,      (unsigned char const   )5,      (unsigned char const   )6, 
        (unsigned char const   )7,      (unsigned char const   )8,      (unsigned char const   )9,      (unsigned char const   )10, 
        (unsigned char const   )11,      (unsigned char const   )12,      (unsigned char const   )13,      (unsigned char const   )14, 
        (unsigned char const   )15,      (unsigned char const   )16};
#line 171 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/misc/unlzx.c"
static void crc_calc(unsigned char *memory , unsigned int length ) 
{ 
  register unsigned int temp ;
  unsigned char *tmp ;

  {
#line 175
  if (length) {
#line 177
    temp = ~ sum;
    {
#line 178
    while (1) {
      while_continue: /* CIL Label */ ;
#line 180
      tmp = memory;
#line 180
      memory ++;
#line 180
      temp = (unsigned int )(crc_table[((unsigned int )*tmp ^ temp) & 255U] ^ (unsigned int const   )(temp >> 8));
#line 178
      length --;
#line 178
      if (! length) {
#line 178
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 182
    sum = ~ temp;
  }
#line 184
  return;
}
}
#line 191 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/misc/unlzx.c"
static int make_decode_table(int number_symbols , int table_size , unsigned char *length ,
                             unsigned short *table ) 
{ 
  register unsigned char bit_num ;
  register int symbol ;
  unsigned int leaf ;
  unsigned int table_mask ;
  unsigned int bit_mask ;
  unsigned int pos___0 ;
  unsigned int fill ;
  unsigned int next_symbol ;
  unsigned int reverse___0 ;
  int abort___0 ;
  unsigned int tmp ;

  {
#line 194
  bit_num = (unsigned char)0;
#line 198
  abort___0 = 0;
#line 200
  pos___0 = 0U;
#line 202
  table_mask = (unsigned int )(1 << table_size);
#line 202
  bit_mask = table_mask;
#line 204
  bit_mask >>= 1;
#line 205
  bit_num = (unsigned char )((int )bit_num + 1);
  {
#line 207
  while (1) {
    while_continue: /* CIL Label */ ;
#line 207
    if (! abort___0) {
#line 207
      if (! ((int )bit_num <= table_size)) {
#line 207
        goto while_break;
      }
    } else {
#line 207
      goto while_break;
    }
#line 209
    symbol = 0;
    {
#line 209
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 209
      if (! (symbol < number_symbols)) {
#line 209
        goto while_break___0;
      }
#line 211
      if ((int )*(length + symbol) == (int )bit_num) {
#line 213
        reverse___0 = pos___0;
#line 214
        leaf = 0U;
#line 215
        fill = (unsigned int )table_size;
        {
#line 216
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 218
          leaf = (leaf << 1) + (reverse___0 & 1U);
#line 219
          reverse___0 >>= 1;
#line 216
          fill --;
#line 216
          if (! fill) {
#line 216
            goto while_break___1;
          }
        }
        while_break___1: /* CIL Label */ ;
        }
#line 221
        pos___0 += bit_mask;
#line 221
        if (pos___0 > table_mask) {
#line 223
          abort___0 = 1;
#line 224
          goto while_break___0;
        }
#line 226
        fill = bit_mask;
#line 227
        next_symbol = (unsigned int )(1 << (int )bit_num);
        {
#line 228
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 230
          *(table + leaf) = (unsigned short )symbol;
#line 231
          leaf += next_symbol;
#line 228
          fill --;
#line 228
          if (! fill) {
#line 228
            goto while_break___2;
          }
        }
        while_break___2: /* CIL Label */ ;
        }
      }
#line 209
      symbol ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 235
    bit_mask >>= 1;
#line 236
    bit_num = (unsigned char )((int )bit_num + 1);
  }
  while_break: /* CIL Label */ ;
  }
#line 239
  if (! abort___0) {
#line 239
    if (pos___0 != table_mask) {
#line 241
      symbol = (int )pos___0;
      {
#line 241
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 241
        if (! ((unsigned int )symbol < table_mask)) {
#line 241
          goto while_break___3;
        }
#line 243
        reverse___0 = (unsigned int )symbol;
#line 244
        leaf = 0U;
#line 245
        fill = (unsigned int )table_size;
        {
#line 246
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 248
          leaf = (leaf << 1) + (reverse___0 & 1U);
#line 249
          reverse___0 >>= 1;
#line 246
          fill --;
#line 246
          if (! fill) {
#line 246
            goto while_break___4;
          }
        }
        while_break___4: /* CIL Label */ ;
        }
#line 251
        *(table + leaf) = (unsigned short)0;
#line 241
        symbol ++;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 253
      next_symbol = table_mask >> 1;
#line 254
      pos___0 <<= 16;
#line 255
      table_mask <<= 16;
#line 256
      bit_mask = 32768U;
      {
#line 258
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 258
        if (! abort___0) {
#line 258
          if (! ((int )bit_num <= 16)) {
#line 258
            goto while_break___5;
          }
        } else {
#line 258
          goto while_break___5;
        }
#line 260
        symbol = 0;
        {
#line 260
        while (1) {
          while_continue___6: /* CIL Label */ ;
#line 260
          if (! (symbol < number_symbols)) {
#line 260
            goto while_break___6;
          }
#line 262
          if ((int )*(length + symbol) == (int )bit_num) {
#line 264
            reverse___0 = pos___0 >> 16;
#line 265
            leaf = 0U;
#line 266
            fill = (unsigned int )table_size;
            {
#line 267
            while (1) {
              while_continue___7: /* CIL Label */ ;
#line 269
              leaf = (leaf << 1) + (reverse___0 & 1U);
#line 270
              reverse___0 >>= 1;
#line 267
              fill --;
#line 267
              if (! fill) {
#line 267
                goto while_break___7;
              }
            }
            while_break___7: /* CIL Label */ ;
            }
#line 272
            fill = 0U;
            {
#line 272
            while (1) {
              while_continue___8: /* CIL Label */ ;
#line 272
              if (! (fill < (unsigned int )((int )bit_num - table_size))) {
#line 272
                goto while_break___8;
              }
#line 274
              if ((int )*(table + leaf) == 0) {
#line 276
                *(table + (next_symbol << 1)) = (unsigned short)0;
#line 277
                *(table + ((next_symbol << 1) + 1U)) = (unsigned short)0;
#line 278
                tmp = next_symbol;
#line 278
                next_symbol ++;
#line 278
                *(table + leaf) = (unsigned short )tmp;
              }
#line 280
              leaf = (unsigned int )((int )*(table + leaf) << 1);
#line 281
              leaf += (pos___0 >> (15U - fill)) & 1U;
#line 272
              fill ++;
            }
            while_break___8: /* CIL Label */ ;
            }
#line 283
            *(table + leaf) = (unsigned short )symbol;
#line 284
            pos___0 += bit_mask;
#line 284
            if (pos___0 > table_mask) {
#line 286
              abort___0 = 1;
#line 287
              goto while_break___6;
            }
          }
#line 260
          symbol ++;
        }
        while_break___6: /* CIL Label */ ;
        }
#line 291
        bit_mask >>= 1;
#line 292
        bit_num = (unsigned char )((int )bit_num + 1);
      }
      while_break___5: /* CIL Label */ ;
      }
    }
  }
#line 295
  if (pos___0 != table_mask) {
#line 295
    abort___0 = 1;
  }
#line 297
  return (abort___0);
}
}
#line 305 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/misc/unlzx.c"
static int read_literal_table(void) 
{ 
  register unsigned int control ;
  register int shift ;
  unsigned int temp ;
  unsigned int symbol ;
  unsigned int pos___0 ;
  unsigned int count ;
  unsigned int fix ;
  unsigned int max_symbol ;
  int abort___0 ;
  unsigned char *tmp ;
  unsigned char *tmp___0 ;
  unsigned char *tmp___1 ;
  unsigned char *tmp___2 ;
  unsigned char *tmp___3 ;
  unsigned char *tmp___4 ;
  unsigned char *tmp___5 ;
  unsigned char *tmp___6 ;
  unsigned char *tmp___7 ;
  unsigned char *tmp___8 ;
  unsigned char *tmp___9 ;
  unsigned char *tmp___10 ;
  unsigned char *tmp___11 ;
  unsigned char *tmp___12 ;
  unsigned char *tmp___13 ;
  unsigned char *tmp___14 ;
  int tmp___15 ;
  unsigned char *tmp___16 ;
  unsigned char *tmp___17 ;
  unsigned char *tmp___18 ;
  unsigned char *tmp___19 ;
  unsigned int tmp___20 ;
  unsigned int tmp___21 ;
  unsigned char *tmp___22 ;
  unsigned char *tmp___23 ;
  int tmp___24 ;
  unsigned char *tmp___25 ;
  unsigned char *tmp___26 ;
  int tmp___27 ;
  unsigned char *tmp___28 ;
  unsigned char *tmp___29 ;
  unsigned int tmp___30 ;
  unsigned int tmp___31 ;
  unsigned int tmp___32 ;

  {
#line 311
  abort___0 = 0;
#line 313
  control = global_control;
#line 314
  shift = global_shift;
#line 316
  if (shift < 0) {
#line 318
    shift += 16;
#line 319
    tmp = source;
#line 319
    source ++;
#line 319
    control += (unsigned int )((int )*tmp << (8 + shift));
#line 320
    tmp___0 = source;
#line 320
    source ++;
#line 320
    control += (unsigned int )((int )*tmp___0 << shift);
  }
#line 325
  decrunch_method = control & 7U;
#line 326
  control >>= 3;
#line 327
  shift -= 3;
#line 327
  if (shift < 0) {
#line 329
    shift += 16;
#line 330
    tmp___1 = source;
#line 330
    source ++;
#line 330
    control += (unsigned int )((int )*tmp___1 << (8 + shift));
#line 331
    tmp___2 = source;
#line 331
    source ++;
#line 331
    control += (unsigned int )((int )*tmp___2 << shift);
  }
#line 336
  if (! abort___0) {
#line 336
    if (decrunch_method == 3U) {
#line 338
      temp = 0U;
      {
#line 338
      while (1) {
        while_continue: /* CIL Label */ ;
#line 338
        if (! (temp < 8U)) {
#line 338
          goto while_break;
        }
#line 340
        offset_len[temp] = (unsigned char )(control & 7U);
#line 341
        control >>= 3;
#line 342
        shift -= 3;
#line 342
        if (shift < 0) {
#line 344
          shift += 16;
#line 345
          tmp___3 = source;
#line 345
          source ++;
#line 345
          control += (unsigned int )((int )*tmp___3 << (8 + shift));
#line 346
          tmp___4 = source;
#line 346
          source ++;
#line 346
          control += (unsigned int )((int )*tmp___4 << shift);
        }
#line 338
        temp ++;
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 349
      abort___0 = make_decode_table(8, 7, offset_len, offset_table);
      }
    }
  }
#line 354
  if (! abort___0) {
#line 356
    decrunch_length = (control & 255U) << 16;
#line 357
    control >>= 8;
#line 358
    shift -= 8;
#line 358
    if (shift < 0) {
#line 360
      shift += 16;
#line 361
      tmp___5 = source;
#line 361
      source ++;
#line 361
      control += (unsigned int )((int )*tmp___5 << (8 + shift));
#line 362
      tmp___6 = source;
#line 362
      source ++;
#line 362
      control += (unsigned int )((int )*tmp___6 << shift);
    }
#line 364
    decrunch_length += (control & 255U) << 8;
#line 365
    control >>= 8;
#line 366
    shift -= 8;
#line 366
    if (shift < 0) {
#line 368
      shift += 16;
#line 369
      tmp___7 = source;
#line 369
      source ++;
#line 369
      control += (unsigned int )((int )*tmp___7 << (8 + shift));
#line 370
      tmp___8 = source;
#line 370
      source ++;
#line 370
      control += (unsigned int )((int )*tmp___8 << shift);
    }
#line 372
    decrunch_length += control & 255U;
#line 373
    control >>= 8;
#line 374
    shift -= 8;
#line 374
    if (shift < 0) {
#line 376
      shift += 16;
#line 377
      tmp___9 = source;
#line 377
      source ++;
#line 377
      control += (unsigned int )((int )*tmp___9 << (8 + shift));
#line 378
      tmp___10 = source;
#line 378
      source ++;
#line 378
      control += (unsigned int )((int )*tmp___10 << shift);
    }
  }
#line 384
  if (! abort___0) {
#line 384
    if (decrunch_method != 1U) {
#line 386
      pos___0 = 0U;
#line 387
      fix = 1U;
#line 388
      max_symbol = 256U;
      {
#line 390
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 392
        temp = 0U;
        {
#line 392
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 392
          if (! (temp < 20U)) {
#line 392
            goto while_break___1;
          }
#line 394
          huffman20_len[temp] = (unsigned char )(control & 15U);
#line 395
          control >>= 4;
#line 396
          shift -= 4;
#line 396
          if (shift < 0) {
#line 398
            shift += 16;
#line 399
            tmp___11 = source;
#line 399
            source ++;
#line 399
            control += (unsigned int )((int )*tmp___11 << (8 + shift));
#line 400
            tmp___12 = source;
#line 400
            source ++;
#line 400
            control += (unsigned int )((int )*tmp___12 << shift);
          }
#line 392
          temp ++;
        }
        while_break___1: /* CIL Label */ ;
        }
        {
#line 403
        abort___0 = make_decode_table(20, 6, huffman20_len, huffman20_table);
        }
#line 405
        if (abort___0) {
#line 405
          goto while_break___0;
        }
        {
#line 407
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 409
          symbol = (unsigned int )huffman20_table[control & 63U];
#line 409
          if (symbol >= 20U) {
            {
#line 411
            while (1) {
              while_continue___3: /* CIL Label */ ;
#line 413
              symbol = (unsigned int )huffman20_table[((control >> 6) & 1U) + (symbol << 1)];
#line 414
              tmp___15 = shift;
#line 414
              shift --;
#line 414
              if (! tmp___15) {
#line 416
                shift += 16;
#line 417
                tmp___13 = source;
#line 417
                source ++;
#line 417
                control += (unsigned int )((int )*tmp___13 << 24);
#line 418
                tmp___14 = source;
#line 418
                source ++;
#line 418
                control += (unsigned int )((int )*tmp___14 << 16);
              }
#line 420
              control >>= 1;
#line 411
              if (! (symbol >= 20U)) {
#line 411
                goto while_break___3;
              }
            }
            while_break___3: /* CIL Label */ ;
            }
#line 422
            temp = 6U;
          } else {
#line 426
            temp = (unsigned int )huffman20_len[symbol];
          }
#line 428
          control >>= temp;
#line 429
          shift = (int )((unsigned int )shift - temp);
#line 429
          if (shift < 0) {
#line 431
            shift += 16;
#line 432
            tmp___16 = source;
#line 432
            source ++;
#line 432
            control += (unsigned int )((int )*tmp___16 << (8 + shift));
#line 433
            tmp___17 = source;
#line 433
            source ++;
#line 433
            control += (unsigned int )((int )*tmp___17 << shift);
          }
          {
#line 438
          if (symbol == 18U) {
#line 438
            goto case_18;
          }
#line 438
          if (symbol == 17U) {
#line 438
            goto case_18;
          }
#line 462
          if (symbol == 19U) {
#line 462
            goto case_19;
          }
#line 503
          goto switch_default;
          case_18: /* CIL Label */ 
          case_17: /* CIL Label */ 
#line 440
          if (symbol == 17U) {
#line 442
            temp = 4U;
#line 443
            count = 3U;
          } else {
#line 447
            temp = 6U - fix;
#line 448
            count = 19U;
          }
#line 450
          count += (control & (unsigned int )table_three[temp]) + fix;
#line 451
          control >>= temp;
#line 452
          shift = (int )((unsigned int )shift - temp);
#line 452
          if (shift < 0) {
#line 454
            shift += 16;
#line 455
            tmp___18 = source;
#line 455
            source ++;
#line 455
            control += (unsigned int )((int )*tmp___18 << (8 + shift));
#line 456
            tmp___19 = source;
#line 456
            source ++;
#line 456
            control += (unsigned int )((int )*tmp___19 << shift);
          }
          {
#line 458
          while (1) {
            while_continue___4: /* CIL Label */ ;
#line 458
            if (pos___0 < max_symbol) {
#line 458
              tmp___21 = count;
#line 458
              count --;
#line 458
              if (! tmp___21) {
#line 458
                goto while_break___4;
              }
            } else {
#line 458
              goto while_break___4;
            }
#line 459
            tmp___20 = pos___0;
#line 459
            pos___0 ++;
#line 459
            literal_len[tmp___20] = (unsigned char)0;
          }
          while_break___4: /* CIL Label */ ;
          }
#line 460
          goto switch_break;
          case_19: /* CIL Label */ 
#line 464
          count = ((control & 1U) + 3U) + fix;
#line 465
          tmp___24 = shift;
#line 465
          shift --;
#line 465
          if (! tmp___24) {
#line 467
            shift += 16;
#line 468
            tmp___22 = source;
#line 468
            source ++;
#line 468
            control += (unsigned int )((int )*tmp___22 << 24);
#line 469
            tmp___23 = source;
#line 469
            source ++;
#line 469
            control += (unsigned int )((int )*tmp___23 << 16);
          }
#line 471
          control >>= 1;
#line 472
          symbol = (unsigned int )huffman20_table[control & 63U];
#line 472
          if (symbol >= 20U) {
            {
#line 474
            while (1) {
              while_continue___5: /* CIL Label */ ;
#line 476
              symbol = (unsigned int )huffman20_table[((control >> 6) & 1U) + (symbol << 1)];
#line 477
              tmp___27 = shift;
#line 477
              shift --;
#line 477
              if (! tmp___27) {
#line 479
                shift += 16;
#line 480
                tmp___25 = source;
#line 480
                source ++;
#line 480
                control += (unsigned int )((int )*tmp___25 << 24);
#line 481
                tmp___26 = source;
#line 481
                source ++;
#line 481
                control += (unsigned int )((int )*tmp___26 << 16);
              }
#line 483
              control >>= 1;
#line 474
              if (! (symbol >= 20U)) {
#line 474
                goto while_break___5;
              }
            }
            while_break___5: /* CIL Label */ ;
            }
#line 485
            temp = 6U;
          } else {
#line 489
            temp = (unsigned int )huffman20_len[symbol];
          }
#line 491
          control >>= temp;
#line 492
          shift = (int )((unsigned int )shift - temp);
#line 492
          if (shift < 0) {
#line 494
            shift += 16;
#line 495
            tmp___28 = source;
#line 495
            source ++;
#line 495
            control += (unsigned int )((int )*tmp___28 << (8 + shift));
#line 496
            tmp___29 = source;
#line 496
            source ++;
#line 496
            control += (unsigned int )((int )*tmp___29 << shift);
          }
#line 498
          symbol = (unsigned int )table_four[(unsigned int )((int )literal_len[pos___0] + 17) - symbol];
          {
#line 499
          while (1) {
            while_continue___6: /* CIL Label */ ;
#line 499
            if (pos___0 < max_symbol) {
#line 499
              tmp___31 = count;
#line 499
              count --;
#line 499
              if (! tmp___31) {
#line 499
                goto while_break___6;
              }
            } else {
#line 499
              goto while_break___6;
            }
#line 500
            tmp___30 = pos___0;
#line 500
            pos___0 ++;
#line 500
            literal_len[tmp___30] = (unsigned char )symbol;
          }
          while_break___6: /* CIL Label */ ;
          }
#line 501
          goto switch_break;
          switch_default: /* CIL Label */ 
#line 505
          symbol = (unsigned int )table_four[(unsigned int )((int )literal_len[pos___0] + 17) - symbol];
#line 506
          tmp___32 = pos___0;
#line 506
          pos___0 ++;
#line 506
          literal_len[tmp___32] = (unsigned char )symbol;
#line 507
          goto switch_break;
          switch_break: /* CIL Label */ ;
          }
#line 407
          if (! (pos___0 < max_symbol)) {
#line 407
            goto while_break___2;
          }
        }
        while_break___2: /* CIL Label */ ;
        }
#line 511
        fix --;
#line 512
        max_symbol += 512U;
#line 390
        if (! (max_symbol == 768U)) {
#line 390
          goto while_break___0;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
#line 515
      if (! abort___0) {
        {
#line 516
        abort___0 = make_decode_table(768, 12, literal_len, literal_table);
        }
      }
    }
  }
#line 519
  global_control = control;
#line 520
  global_shift = shift;
#line 522
  return (abort___0);
}
}
#line 531 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/misc/unlzx.c"
static void decrunch(void) 
{ 
  register unsigned int control ;
  register int shift ;
  unsigned int temp ;
  unsigned int symbol ;
  unsigned int count ;
  unsigned char *string ;
  unsigned char *tmp ;
  unsigned char *tmp___0 ;
  unsigned char *tmp___1 ;
  unsigned char *tmp___2 ;
  int tmp___3 ;
  unsigned char *tmp___4 ;
  unsigned char *tmp___5 ;
  unsigned char *tmp___6 ;
  unsigned char *tmp___7 ;
  unsigned char *tmp___8 ;
  unsigned char *tmp___9 ;
  unsigned char *tmp___10 ;
  unsigned char *tmp___11 ;
  unsigned char *tmp___12 ;
  unsigned char *tmp___13 ;
  unsigned char *tmp___14 ;

  {
#line 539
  control = global_control;
#line 540
  shift = global_shift;
  {
#line 542
  while (1) {
    while_continue: /* CIL Label */ ;
#line 544
    symbol = (unsigned int )literal_table[control & 4095U];
#line 544
    if (symbol >= 768U) {
#line 546
      control >>= 12;
#line 547
      shift -= 12;
#line 547
      if (shift < 0) {
#line 549
        shift += 16;
#line 550
        tmp = source;
#line 550
        source ++;
#line 550
        control += (unsigned int )((int )*tmp << (8 + shift));
#line 551
        tmp___0 = source;
#line 551
        source ++;
#line 551
        control += (unsigned int )((int )*tmp___0 << shift);
      }
      {
#line 553
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 555
        symbol = (unsigned int )literal_table[(control & 1U) + (symbol << 1)];
#line 556
        tmp___3 = shift;
#line 556
        shift --;
#line 556
        if (! tmp___3) {
#line 558
          shift += 16;
#line 559
          tmp___1 = source;
#line 559
          source ++;
#line 559
          control += (unsigned int )((int )*tmp___1 << 24);
#line 560
          tmp___2 = source;
#line 560
          source ++;
#line 560
          control += (unsigned int )((int )*tmp___2 << 16);
        }
#line 562
        control >>= 1;
#line 553
        if (! (symbol >= 768U)) {
#line 553
          goto while_break___0;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
    } else {
#line 567
      temp = (unsigned int )literal_len[symbol];
#line 568
      control >>= temp;
#line 569
      shift = (int )((unsigned int )shift - temp);
#line 569
      if (shift < 0) {
#line 571
        shift += 16;
#line 572
        tmp___4 = source;
#line 572
        source ++;
#line 572
        control += (unsigned int )((int )*tmp___4 << (8 + shift));
#line 573
        tmp___5 = source;
#line 573
        source ++;
#line 573
        control += (unsigned int )((int )*tmp___5 << shift);
      }
    }
#line 576
    if (symbol < 256U) {
#line 578
      tmp___6 = destination;
#line 578
      destination ++;
#line 578
      *tmp___6 = (unsigned char )symbol;
    } else {
#line 582
      symbol -= 256U;
#line 583
      temp = symbol & 31U;
#line 583
      count = (unsigned int )table_two[temp];
#line 584
      temp = (unsigned int )table_one[temp];
#line 585
      if (temp >= 3U) {
#line 585
        if (decrunch_method == 3U) {
#line 587
          temp -= 3U;
#line 588
          count += (control & (unsigned int )table_three[temp]) << 3;
#line 589
          control >>= temp;
#line 590
          shift = (int )((unsigned int )shift - temp);
#line 590
          if (shift < 0) {
#line 592
            shift += 16;
#line 593
            tmp___7 = source;
#line 593
            source ++;
#line 593
            control += (unsigned int )((int )*tmp___7 << (8 + shift));
#line 594
            tmp___8 = source;
#line 594
            source ++;
#line 594
            control += (unsigned int )((int )*tmp___8 << shift);
          }
#line 596
          temp = (unsigned int )offset_table[control & 127U];
#line 596
          count += temp;
#line 597
          temp = (unsigned int )offset_len[temp];
        } else {
#line 585
          goto _L;
        }
      } else {
        _L: /* CIL Label */ 
#line 601
        count += control & (unsigned int )table_three[temp];
#line 602
        if (! count) {
#line 602
          count = last_offset;
        }
      }
#line 604
      control >>= temp;
#line 605
      shift = (int )((unsigned int )shift - temp);
#line 605
      if (shift < 0) {
#line 607
        shift += 16;
#line 608
        tmp___9 = source;
#line 608
        source ++;
#line 608
        control += (unsigned int )((int )*tmp___9 << (8 + shift));
#line 609
        tmp___10 = source;
#line 609
        source ++;
#line 609
        control += (unsigned int )((int )*tmp___10 << shift);
      }
#line 611
      last_offset = count;
#line 613
      temp = (symbol >> 5) & 15U;
#line 613
      count = (unsigned int )(table_two[temp] + 3U);
#line 614
      temp = (unsigned int )table_one[temp];
#line 615
      count += control & (unsigned int )table_three[temp];
#line 616
      control >>= temp;
#line 617
      shift = (int )((unsigned int )shift - temp);
#line 617
      if (shift < 0) {
#line 619
        shift += 16;
#line 620
        tmp___11 = source;
#line 620
        source ++;
#line 620
        control += (unsigned int )((int )*tmp___11 << (8 + shift));
#line 621
        tmp___12 = source;
#line 621
        source ++;
#line 621
        control += (unsigned int )((int )*tmp___12 << shift);
      }
#line 623
      if ((unsigned long )(decrunch_buffer + last_offset) < (unsigned long )destination) {
#line 623
        string = destination - last_offset;
      } else {
#line 623
        string = (destination + 65536) - last_offset;
      }
      {
#line 625
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 627
        tmp___13 = destination;
#line 627
        destination ++;
#line 627
        tmp___14 = string;
#line 627
        string ++;
#line 627
        *tmp___13 = *tmp___14;
#line 625
        count --;
#line 625
        if (! count) {
#line 625
          goto while_break___1;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
    }
#line 542
    if ((unsigned long )destination < (unsigned long )destination_end) {
#line 542
      if (! ((unsigned long )source < (unsigned long )source_end)) {
#line 542
        goto while_break;
      }
    } else {
#line 542
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 632
  global_control = control;
#line 633
  global_shift = shift;
#line 634
  return;
}
}
#line 640 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/misc/unlzx.c"
static FILE *_outfile  ;
#line 642 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/misc/unlzx.c"
static FILE *open_output(char *filename ) 
{ 


  {
#line 667
  return (_outfile);
}
}
#line 674 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/misc/unlzx.c"
static int extract_normal(FILE *in_file ) 
{ 
  struct filename_node *node ;
  FILE *out_file ;
  unsigned char *pos___0 ;
  unsigned char *temp ;
  unsigned int count ;
  int abort___0 ;
  unsigned char *tmp ;
  unsigned char *tmp___0 ;
  int tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;
  unsigned char *tmp___4 ;
  unsigned char *tmp___5 ;
  size_t tmp___6 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;

  {
#line 677
  out_file = (FILE *)0;
#line 681
  abort___0 = 0;
#line 683
  global_control = 0U;
#line 684
  global_shift = -16;
#line 685
  last_offset = 1U;
#line 686
  unpack_size = 0U;
#line 687
  decrunch_length = 0U;
#line 689
  count = 0U;
  {
#line 689
  while (1) {
    while_continue: /* CIL Label */ ;
#line 689
    if (! (count < 8U)) {
#line 689
      goto while_break;
    }
#line 690
    offset_len[count] = (unsigned char)0;
#line 689
    count ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 691
  count = 0U;
  {
#line 691
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 691
    if (! (count < 768U)) {
#line 691
      goto while_break___0;
    }
#line 692
    literal_len[count] = (unsigned char)0;
#line 691
    count ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 694
  source = read_buffer + 16384;
#line 694
  source_end = source - 1024;
#line 695
  destination = (decrunch_buffer + 258) + 65536;
#line 695
  destination_end = destination;
#line 695
  pos___0 = destination_end;
#line 697
  node = filename_list;
  {
#line 697
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 697
    if (! abort___0) {
#line 697
      if (! node) {
#line 697
        goto while_break___1;
      }
    } else {
#line 697
      goto while_break___1;
    }
    {
#line 702
    out_file = open_output(node->filename);
#line 704
    sum = 0U;
#line 706
    unpack_size = node->length;
    }
    {
#line 708
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 708
      if (! (unpack_size > 0U)) {
#line 708
        goto while_break___2;
      }
#line 711
      if ((unsigned long )pos___0 == (unsigned long )destination) {
#line 714
        if ((unsigned long )source >= (unsigned long )source_end) {
#line 716
          temp = read_buffer;
#line 717
          count = (unsigned int )((temp - source) + 16384L);
#line 717
          if (count) {
            {
#line 719
            while (1) {
              while_continue___3: /* CIL Label */ ;
#line 721
              tmp = temp;
#line 721
              temp ++;
#line 721
              tmp___0 = source;
#line 721
              source ++;
#line 721
              *tmp = *tmp___0;
#line 719
              count --;
#line 719
              if (! count) {
#line 719
                goto while_break___3;
              }
            }
            while_break___3: /* CIL Label */ ;
            }
          }
#line 724
          source = read_buffer;
#line 725
          count = (unsigned int )((source - temp) + 16384L);
#line 727
          if (pack_size < count) {
#line 727
            count = pack_size;
          }
          {
#line 729
          tmp___2 = fread((void */* __restrict  */)temp, (size_t )1, count, (FILE */* __restrict  */)in_file);
          }
#line 729
          if (tmp___2 != count) {
            {
#line 731
            printf((char const   */* __restrict  */)"\n");
#line 732
            tmp___1 = ferror(in_file);
            }
#line 732
            if (tmp___1) {
              {
#line 733
              perror("FRead(Data)");
              }
            } else {
              {
#line 735
              fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"EOF: Data\n");
              }
            }
#line 736
            abort___0 = 1;
#line 737
            goto while_break___2;
          }
#line 739
          pack_size -= count;
#line 741
          temp += count;
#line 742
          if ((unsigned long )source >= (unsigned long )temp) {
#line 742
            goto while_break___2;
          }
        }
#line 746
        if (decrunch_length <= 0U) {
          {
#line 748
          tmp___3 = read_literal_table();
          }
#line 748
          if (tmp___3) {
#line 748
            goto while_break___2;
          }
        }
#line 752
        if ((unsigned long )destination >= (unsigned long )((decrunch_buffer + 258) + 65536)) {
#line 754
          count = (unsigned int )((destination - decrunch_buffer) - 65536L);
#line 754
          if (count) {
#line 756
            destination = decrunch_buffer;
#line 756
            temp = destination + 65536;
            {
#line 757
            while (1) {
              while_continue___4: /* CIL Label */ ;
#line 759
              tmp___4 = destination;
#line 759
              destination ++;
#line 759
              tmp___5 = temp;
#line 759
              temp ++;
#line 759
              *tmp___4 = *tmp___5;
#line 757
              count --;
#line 757
              if (! count) {
#line 757
                goto while_break___4;
              }
            }
            while_break___4: /* CIL Label */ ;
            }
          }
#line 762
          pos___0 = destination;
        }
#line 764
        destination_end = destination + decrunch_length;
#line 765
        if ((unsigned long )destination_end > (unsigned long )((decrunch_buffer + 258) + 65536)) {
#line 766
          destination_end = (decrunch_buffer + 258) + 65536;
        }
        {
#line 767
        temp = destination;
#line 769
        decrunch();
#line 771
        decrunch_length = (unsigned int )((long )decrunch_length - (destination - temp));
        }
      }
#line 775
      count = (unsigned int )(destination - pos___0);
#line 776
      if (count > unpack_size) {
#line 776
        count = unpack_size;
      }
      {
#line 778
      crc_calc(pos___0, count);
      }
#line 780
      if (out_file) {
        {
#line 782
        tmp___6 = fwrite((void const   */* __restrict  */)pos___0, (size_t )1, count,
                         (FILE */* __restrict  */)out_file);
        }
      }
#line 791
      unpack_size -= count;
#line 792
      pos___0 += count;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 697
    node = node->next;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 804
  return (abort___0);
}
}
#line 811 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/misc/unlzx.c"
static int extract_store(FILE *in_file ) 
{ 
  struct filename_node *node ;
  FILE *out_file ;
  unsigned int count ;
  int abort___0 ;
  int tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
#line 816
  abort___0 = 0;
#line 818
  node = filename_list;
  {
#line 818
  while (1) {
    while_continue: /* CIL Label */ ;
#line 818
    if (! abort___0) {
#line 818
      if (! node) {
#line 818
        goto while_break;
      }
    } else {
#line 818
      goto while_break;
    }
    {
#line 823
    out_file = open_output(node->filename);
#line 825
    sum = 0U;
#line 827
    unpack_size = node->length;
    }
#line 828
    if (unpack_size > pack_size) {
#line 828
      unpack_size = pack_size;
    }
    {
#line 830
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 830
      if (! (unpack_size > 0U)) {
#line 830
        goto while_break___0;
      }
#line 832
      if (unpack_size > 16384U) {
#line 832
        count = 16384U;
      } else {
#line 832
        count = unpack_size;
      }
      {
#line 834
      tmp___0 = fread((void */* __restrict  */)(read_buffer), (size_t )1, count, (FILE */* __restrict  */)in_file);
      }
#line 834
      if (tmp___0 != count) {
        {
#line 836
        printf((char const   */* __restrict  */)"\n");
#line 837
        tmp = ferror(in_file);
        }
#line 837
        if (tmp) {
          {
#line 838
          perror("FRead(Data)");
          }
        } else {
          {
#line 840
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"EOF: Data\n");
          }
        }
#line 841
        abort___0 = 1;
#line 842
        goto while_break___0;
      }
      {
#line 844
      pack_size -= count;
#line 846
      crc_calc(read_buffer, count);
      }
#line 848
      if (out_file) {
        {
#line 850
        tmp___1 = fwrite((void const   */* __restrict  */)(read_buffer), (size_t )1,
                         count, (FILE */* __restrict  */)out_file);
        }
      }
#line 859
      unpack_size -= count;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 818
    node = node->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 871
  return (abort___0);
}
}
#line 878 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/misc/unlzx.c"
static int extract_unknown(FILE *in_file ) 
{ 
  struct filename_node *node ;
  int abort___0 ;
  char *__cil_tmp4 ;

  {
#line 881
  abort___0 = 0;
#line 883
  node = filename_list;
  {
#line 883
  while (1) {
    while_continue: /* CIL Label */ ;
#line 883
    if (! node) {
#line 883
      goto while_break;
    }
    {
#line 885
    printf((char const   */* __restrict  */)"Unknown \"%s\"\n", node->filename);
#line 883
    node = node->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 888
  return (abort___0);
}
}
#line 896 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/misc/unlzx.c"
static int extract_archive(FILE *in_file ) 
{ 
  unsigned int temp ;
  struct filename_node **filename_next ;
  struct filename_node *node ;
  struct filename_node *temp_node ;
  int actual ;
  int abort___0 ;
  int result ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  char tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  void *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  void *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;

  {
#line 904
  result = 1;
#line 906
  filename_list = (struct filename_node *)0;
#line 907
  filename_next = & filename_list;
  {
#line 909
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 911
    abort___0 = 1;
#line 912
    tmp = fread((void */* __restrict  */)(archive_header), (size_t )1, (size_t )31,
                (FILE */* __restrict  */)in_file);
#line 912
    actual = (int )tmp;
#line 913
    tmp___8 = ferror(in_file);
    }
#line 913
    if (tmp___8) {
      {
#line 1032
      perror("FRead(Archive_Header)");
      }
    } else
#line 915
    if (actual) {
#line 917
      if (actual == 31) {
        {
#line 919
        sum = 0U;
#line 920
        crc = (unsigned int )(((((int )archive_header[29] << 24) + ((int )archive_header[28] << 16)) + ((int )archive_header[27] << 8)) + (int )archive_header[26]);
#line 921
        archive_header[29] = (unsigned char)0;
#line 922
        archive_header[28] = (unsigned char)0;
#line 923
        archive_header[27] = (unsigned char)0;
#line 924
        archive_header[26] = (unsigned char)0;
#line 925
        crc_calc(archive_header, 31U);
#line 926
        temp = (unsigned int )archive_header[30];
#line 927
        tmp___0 = fread((void */* __restrict  */)(header_filename), (size_t )1, temp,
                        (FILE */* __restrict  */)in_file);
#line 927
        actual = (int )tmp___0;
#line 928
        tmp___7 = ferror(in_file);
        }
#line 928
        if (tmp___7) {
          {
#line 1021
          perror("FRead(Header_Filename)");
          }
        } else
#line 930
        if ((unsigned int )actual == temp) {
          {
#line 932
          header_filename[temp] = (unsigned char)0;
#line 933
          crc_calc(header_filename, temp);
#line 934
          temp = (unsigned int )archive_header[14];
#line 935
          tmp___1 = fread((void */* __restrict  */)(header_comment), (size_t )1, temp,
                          (FILE */* __restrict  */)in_file);
#line 935
          actual = (int )tmp___1;
#line 936
          tmp___6 = ferror(in_file);
          }
#line 936
          if (tmp___6) {
            {
#line 1015
            perror("FRead(Header_Comment)");
            }
          } else
#line 938
          if ((unsigned int )actual == temp) {
            {
#line 940
            header_comment[temp] = (unsigned char)0;
#line 941
            crc_calc(header_comment, temp);
            }
#line 942
            if (sum == crc) {
              {
#line 944
              unpack_size = (unsigned int )(((((int )archive_header[5] << 24) + ((int )archive_header[4] << 16)) + ((int )archive_header[3] << 8)) + (int )archive_header[2]);
#line 945
              pack_size = (unsigned int )(((((int )archive_header[9] << 24) + ((int )archive_header[8] << 16)) + ((int )archive_header[7] << 8)) + (int )archive_header[6]);
#line 946
              pack_mode = archive_header[11];
#line 947
              crc = (unsigned int )(((((int )archive_header[25] << 24) + ((int )archive_header[24] << 16)) + ((int )archive_header[23] << 8)) + (int )archive_header[22]);
#line 949
              tmp___5 = malloc((size_t )sizeof(struct filename_node ));
#line 949
              node = (struct filename_node *)tmp___5;
              }
#line 949
              if (node) {
#line 951
                *filename_next = node;
#line 952
                filename_next = & node->next;
#line 953
                node->next = (struct filename_node *)0;
#line 954
                node->length = unpack_size;
#line 955
                node->crc = crc;
#line 956
                temp = 0U;
                {
#line 956
                while (1) {
                  while_continue___0: /* CIL Label */ ;
#line 956
                  tmp___2 = (char )header_filename[temp];
#line 956
                  node->filename[temp] = tmp___2;
#line 956
                  if (! tmp___2) {
#line 956
                    goto while_break___0;
                  }
#line 956
                  temp ++;
                }
                while_break___0: /* CIL Label */ ;
                }
                {
#line 960
                tmp___3 = strstr((char const   *)(node->filename), ".txt");
                }
#line 960
                if (tmp___3) {
#line 961
                  pack_mode = (unsigned char)255;
                }
#line 963
                if (pack_size) {
                  {
#line 967
                  if ((int )pack_mode == 0) {
#line 967
                    goto case_0;
                  }
#line 973
                  if ((int )pack_mode == 2) {
#line 973
                    goto case_2;
                  }
#line 979
                  goto switch_default;
                  case_0: /* CIL Label */ 
                  {
#line 969
                  abort___0 = extract_store(in_file);
#line 970
                  abort___0 = 1;
                  }
#line 971
                  goto switch_break;
                  case_2: /* CIL Label */ 
                  {
#line 975
                  abort___0 = extract_normal(in_file);
#line 976
                  abort___0 = 1;
                  }
#line 977
                  goto switch_break;
                  switch_default: /* CIL Label */ 
                  {
#line 981
                  abort___0 = extract_unknown(in_file);
                  }
#line 982
                  goto switch_break;
                  switch_break: /* CIL Label */ ;
                  }
#line 985
                  if (abort___0) {
#line 985
                    goto while_break;
                  }
#line 987
                  temp_node = filename_list;
                  {
#line 988
                  while (1) {
                    while_continue___1: /* CIL Label */ ;
#line 988
                    node = temp_node;
#line 988
                    if (! node) {
#line 988
                      goto while_break___1;
                    }
                    {
#line 990
                    temp_node = node->next;
#line 991
                    free((void *)node);
                    }
                  }
                  while_break___1: /* CIL Label */ ;
                  }
                  {
#line 993
                  filename_list = (struct filename_node *)0;
#line 994
                  filename_next = & filename_list;
#line 996
                  tmp___4 = fseek(in_file, (long )pack_size, 1);
                  }
#line 996
                  if (tmp___4) {
                    {
#line 998
                    perror("FSeek(Data)");
                    }
#line 999
                    goto while_break;
                  }
                } else {
#line 1003
                  abort___0 = 0;
                }
              } else {
                {
#line 1006
                fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"MAlloc(Filename_node)\n");
                }
              }
            } else {
              {
#line 1009
              fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"CRC: Archive_Header\n");
              }
            }
          } else {
            {
#line 1012
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"EOF: Header_Comment\n");
            }
          }
        } else {
          {
#line 1018
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"EOF: Header_Filename\n");
          }
        }
      } else {
        {
#line 1024
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"EOF: Archive_Header\n");
        }
      }
    } else {
#line 1028
      result = 0;
    }
#line 909
    if (! (! abort___0)) {
#line 909
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1036
  temp_node = filename_list;
  {
#line 1037
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 1037
    node = temp_node;
#line 1037
    if (! node) {
#line 1037
      goto while_break___2;
    }
    {
#line 1039
    temp_node = node->next;
#line 1040
    free((void *)node);
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 1043
  return (result);
}
}
#line 1388 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/misc/unlzx.c"
int decrunch_lzx(FILE *f , FILE *fo ) 
{ 


  {
#line 1390
  if ((unsigned long )fo == (unsigned long )((void *)0)) {
#line 1391
    return (-1);
  }
  {
#line 1393
  fseek(f, 10L, 1);
#line 1395
  _outfile = fo;
#line 1396
  extract_archive(f);
  }
#line 1398
  return (0);
}
}
#line 17 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/misc/muse.c"
int kunzip_inflate_init(void) ;
#line 18
int kunzip_inflate_free(void) ;
#line 19
int inflate(FILE *in , FILE *out , unsigned int *checksum ) ;
#line 22 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/misc/muse.c"
int decrunch_muse(FILE *f , FILE *fo ) 
{ 
  uint32 checksum ;

  {
#line 26
  if ((unsigned long )fo == (unsigned long )((void *)0)) {
#line 27
    return (-1);
  }
  {
#line 29
  fseek(f, 24L, 0);
#line 31
  kunzip_inflate_init();
#line 32
  inflate(f, fo, & checksum);
#line 33
  kunzip_inflate_free();
  }
#line 35
  return (0);
}
}
#line 460 "/usr/include/libio.h"
extern int _IO_getc(_IO_FILE *__fp ) ;
#line 296 "src/include/common.h"
uint16 read16l(FILE *f ) ;
#line 301
uint32 read32b(FILE *f ) ;
#line 55 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/misc/inflate.c"
static int length_codes[29]  = 
#line 55 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/misc/inflate.c"
  {      3,      4,      5,      6, 
        7,      8,      9,      10, 
        11,      13,      15,      17, 
        19,      23,      27,      31, 
        35,      43,      51,      59, 
        67,      83,      99,      115, 
        131,      163,      195,      227, 
        258};
#line 59 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/misc/inflate.c"
static int length_extra_bits[29]  = 
#line 59
  {      0,      0,      0,      0, 
        0,      0,      0,      0, 
        1,      1,      1,      1, 
        2,      2,      2,      2, 
        3,      3,      3,      3, 
        4,      4,      4,      4, 
        5,      5,      5,      5, 
        0};
#line 63 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/misc/inflate.c"
static int dist_codes[30]  = 
#line 63
  {      1,      2,      3,      4, 
        5,      7,      9,      13, 
        17,      25,      33,      49, 
        65,      97,      129,      193, 
        257,      385,      513,      769, 
        1025,      1537,      2049,      3073, 
        4097,      6145,      8193,      12289, 
        16385,      24577};
#line 68 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/misc/inflate.c"
static int dist_extra_bits[30]  = 
#line 68
  {      0,      0,      0,      0, 
        1,      1,      2,      2, 
        3,      3,      4,      4, 
        5,      5,      6,      6, 
        7,      7,      8,      8, 
        9,      9,      10,      10, 
        11,      11,      12,      12, 
        13,      13};
#line 72 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/misc/inflate.c"
static int dyn_huff_trans[19]  = 
#line 72
  {      16,      17,      18,      0, 
        8,      7,      9,      6, 
        10,      5,      11,      4, 
        12,      3,      13,      2, 
        14,      1,      15};
#line 75 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/misc/inflate.c"
static unsigned char reverse[256]  = 
#line 75
  {      (unsigned char)0,      (unsigned char)128,      (unsigned char)64,      (unsigned char)192, 
        (unsigned char)32,      (unsigned char)160,      (unsigned char)96,      (unsigned char)224, 
        (unsigned char)16,      (unsigned char)144,      (unsigned char)80,      (unsigned char)208, 
        (unsigned char)48,      (unsigned char)176,      (unsigned char)112,      (unsigned char)240, 
        (unsigned char)8,      (unsigned char)136,      (unsigned char)72,      (unsigned char)200, 
        (unsigned char)40,      (unsigned char)168,      (unsigned char)104,      (unsigned char)232, 
        (unsigned char)24,      (unsigned char)152,      (unsigned char)88,      (unsigned char)216, 
        (unsigned char)56,      (unsigned char)184,      (unsigned char)120,      (unsigned char)248, 
        (unsigned char)4,      (unsigned char)132,      (unsigned char)68,      (unsigned char)196, 
        (unsigned char)36,      (unsigned char)164,      (unsigned char)100,      (unsigned char)228, 
        (unsigned char)20,      (unsigned char)148,      (unsigned char)84,      (unsigned char)212, 
        (unsigned char)52,      (unsigned char)180,      (unsigned char)116,      (unsigned char)244, 
        (unsigned char)12,      (unsigned char)140,      (unsigned char)76,      (unsigned char)204, 
        (unsigned char)44,      (unsigned char)172,      (unsigned char)108,      (unsigned char)236, 
        (unsigned char)28,      (unsigned char)156,      (unsigned char)92,      (unsigned char)220, 
        (unsigned char)60,      (unsigned char)188,      (unsigned char)124,      (unsigned char)252, 
        (unsigned char)2,      (unsigned char)130,      (unsigned char)66,      (unsigned char)194, 
        (unsigned char)34,      (unsigned char)162,      (unsigned char)98,      (unsigned char)226, 
        (unsigned char)18,      (unsigned char)146,      (unsigned char)82,      (unsigned char)210, 
        (unsigned char)50,      (unsigned char)178,      (unsigned char)114,      (unsigned char)242, 
        (unsigned char)10,      (unsigned char)138,      (unsigned char)74,      (unsigned char)202, 
        (unsigned char)42,      (unsigned char)170,      (unsigned char)106,      (unsigned char)234, 
        (unsigned char)26,      (unsigned char)154,      (unsigned char)90,      (unsigned char)218, 
        (unsigned char)58,      (unsigned char)186,      (unsigned char)122,      (unsigned char)250, 
        (unsigned char)6,      (unsigned char)134,      (unsigned char)70,      (unsigned char)198, 
        (unsigned char)38,      (unsigned char)166,      (unsigned char)102,      (unsigned char)230, 
        (unsigned char)22,      (unsigned char)150,      (unsigned char)86,      (unsigned char)214, 
        (unsigned char)54,      (unsigned char)182,      (unsigned char)118,      (unsigned char)246, 
        (unsigned char)14,      (unsigned char)142,      (unsigned char)78,      (unsigned char)206, 
        (unsigned char)46,      (unsigned char)174,      (unsigned char)110,      (unsigned char)238, 
        (unsigned char)30,      (unsigned char)158,      (unsigned char)94,      (unsigned char)222, 
        (unsigned char)62,      (unsigned char)190,      (unsigned char)126,      (unsigned char)254, 
        (unsigned char)1,      (unsigned char)129,      (unsigned char)65,      (unsigned char)193, 
        (unsigned char)33,      (unsigned char)161,      (unsigned char)97,      (unsigned char)225, 
        (unsigned char)17,      (unsigned char)145,      (unsigned char)81,      (unsigned char)209, 
        (unsigned char)49,      (unsigned char)177,      (unsigned char)113,      (unsigned char)241, 
        (unsigned char)9,      (unsigned char)137,      (unsigned char)73,      (unsigned char)201, 
        (unsigned char)41,      (unsigned char)169,      (unsigned char)105,      (unsigned char)233, 
        (unsigned char)25,      (unsigned char)153,      (unsigned char)89,      (unsigned char)217, 
        (unsigned char)57,      (unsigned char)185,      (unsigned char)121,      (unsigned char)249, 
        (unsigned char)5,      (unsigned char)133,      (unsigned char)69,      (unsigned char)197, 
        (unsigned char)37,      (unsigned char)165,      (unsigned char)101,      (unsigned char)229, 
        (unsigned char)21,      (unsigned char)149,      (unsigned char)85,      (unsigned char)213, 
        (unsigned char)53,      (unsigned char)181,      (unsigned char)117,      (unsigned char)245, 
        (unsigned char)13,      (unsigned char)141,      (unsigned char)77,      (unsigned char)205, 
        (unsigned char)45,      (unsigned char)173,      (unsigned char)109,      (unsigned char)237, 
        (unsigned char)29,      (unsigned char)157,      (unsigned char)93,      (unsigned char)221, 
        (unsigned char)61,      (unsigned char)189,      (unsigned char)125,      (unsigned char)253, 
        (unsigned char)3,      (unsigned char)131,      (unsigned char)67,      (unsigned char)195, 
        (unsigned char)35,      (unsigned char)163,      (unsigned char)99,      (unsigned char)227, 
        (unsigned char)19,      (unsigned char)147,      (unsigned char)83,      (unsigned char)211, 
        (unsigned char)51,      (unsigned char)179,      (unsigned char)115,      (unsigned char)243, 
        (unsigned char)11,      (unsigned char)139,      (unsigned char)75,      (unsigned char)203, 
        (unsigned char)43,      (unsigned char)171,      (unsigned char)107,      (unsigned char)235, 
        (unsigned char)27,      (unsigned char)155,      (unsigned char)91,      (unsigned char)219, 
        (unsigned char)59,      (unsigned char)187,      (unsigned char)123,      (unsigned char)251, 
        (unsigned char)7,      (unsigned char)135,      (unsigned char)71,      (unsigned char)199, 
        (unsigned char)39,      (unsigned char)167,      (unsigned char)103,      (unsigned char)231, 
        (unsigned char)23,      (unsigned char)151,      (unsigned char)87,      (unsigned char)215, 
        (unsigned char)55,      (unsigned char)183,      (unsigned char)119,      (unsigned char)247, 
        (unsigned char)15,      (unsigned char)143,      (unsigned char)79,      (unsigned char)207, 
        (unsigned char)47,      (unsigned char)175,      (unsigned char)111,      (unsigned char)239, 
        (unsigned char)31,      (unsigned char)159,      (unsigned char)95,      (unsigned char)223, 
        (unsigned char)63,      (unsigned char)191,      (unsigned char)127,      (unsigned char)255};
#line 93 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/misc/inflate.c"
static struct huffman_tree_t *huffman_tree_len_static  =    (struct huffman_tree_t *)0;
#line 94 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/misc/inflate.c"
static int crc_built  =    0;
#line 95 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/misc/inflate.c"
static unsigned int crc_table___0[256]  ;
#line 111 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/misc/inflate.c"
static int build_crc32(void) 
{ 
  unsigned int c___0 ;
  int n___0 ;
  int k ;

  {
#line 116
  n___0 = 0;
  {
#line 116
  while (1) {
    while_continue: /* CIL Label */ ;
#line 116
    if (! (n___0 < 256)) {
#line 116
      goto while_break;
    }
#line 118
    c___0 = (unsigned int )n___0;
#line 119
    k = 0;
    {
#line 119
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 119
      if (! (k < 8)) {
#line 119
        goto while_break___0;
      }
#line 121
      if (c___0 & 1U) {
#line 122
        c___0 = 3988292384U ^ (c___0 >> 1);
      } else {
#line 124
        c___0 >>= 1;
      }
#line 119
      k ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 126
    crc_table___0[n___0] = c___0;
#line 116
    n___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 129
  crc_built = 1;
#line 131
  return (0);
}
}
#line 134 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/misc/inflate.c"
static unsigned int crc32(unsigned char *buffer , int len , unsigned int crc___0 ) 
{ 
  int t ;

  {
#line 138
  t = 0;
  {
#line 138
  while (1) {
    while_continue: /* CIL Label */ ;
#line 138
    if (! (t < len)) {
#line 138
      goto while_break;
    }
#line 140
    crc___0 = crc_table___0[(crc___0 ^ (unsigned int )*(buffer + t)) & 255U] ^ (crc___0 >> 8);
#line 138
    t ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 143
  return (crc___0);
}
}
#line 146 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/misc/inflate.c"
int kunzip_inflate_init(void) 
{ 


  {
#line 164
  if (crc_built == 0) {
    {
#line 164
    build_crc32();
    }
  }
#line 166
  return (0);
}
}
#line 169 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/misc/inflate.c"
int kunzip_inflate_free(void) 
{ 


  {
#line 171
  if ((unsigned long )huffman_tree_len_static != (unsigned long )((struct huffman_tree_t *)0)) {
    {
#line 172
    free((void *)huffman_tree_len_static);
    }
  }
#line 174
  return (0);
}
}
#line 207 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/misc/inflate.c"
static int reverse_bitstream(struct bitstream_t *bitstream ) 
{ 
  unsigned int i___3 ;

  {
#line 211
  i___3 = (unsigned int )((((int )reverse[(bitstream->holding >> 24) & 255U] | ((int )reverse[(bitstream->holding >> 16) & 255U] << 8)) | ((int )reverse[(bitstream->holding >> 8) & 255U] << 16)) | ((int )reverse[bitstream->holding & 255U] << 24));
#line 216
  i___3 >>= 32 - bitstream->bitptr;
#line 217
  bitstream->holding = i___3;
#line 219
  return (0);
}
}
#line 223 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/misc/inflate.c"
static int add_static_codes_to_tree(struct huffman_tree_t *huffman_tree , int code_len ,
                                    int count , int start_code , int start_uncomp_code ,
                                    int next_leaf ) 
{ 
  struct huffman_tree_t *curr_huffman_leaf ;
  int t ;
  int x ;
  int r ;
  int tmp ;

  {
#line 230
  t = 0;
  {
#line 230
  while (1) {
    while_continue: /* CIL Label */ ;
#line 230
    if (! (t < count)) {
#line 230
      goto while_break;
    }
#line 232
    curr_huffman_leaf = huffman_tree;
#line 233
    x = 1 << (code_len - 1);
#line 234
    r = 0;
    {
#line 234
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 234
      if (! (r < code_len)) {
#line 234
        goto while_break___0;
      }
#line 236
      if ((start_code & x) == 0) {
#line 238
        if ((int )curr_huffman_leaf->left == 0) {
#line 240
          next_leaf ++;
#line 241
          curr_huffman_leaf->left = (short )next_leaf;
#line 242
          (huffman_tree + next_leaf)->left = (short)0;
#line 243
          (huffman_tree + next_leaf)->right = (short)0;
        }
#line 246
        curr_huffman_leaf = huffman_tree + curr_huffman_leaf->left;
      } else {
#line 250
        if ((int )curr_huffman_leaf->right == 0) {
#line 252
          next_leaf ++;
#line 253
          curr_huffman_leaf->right = (short )next_leaf;
#line 254
          (huffman_tree + next_leaf)->left = (short)0;
#line 255
          (huffman_tree + next_leaf)->right = (short)0;
        }
#line 258
        curr_huffman_leaf = huffman_tree + curr_huffman_leaf->right;
      }
#line 261
      x >>= 1;
#line 234
      r ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 264
    tmp = start_uncomp_code;
#line 264
    start_uncomp_code ++;
#line 264
    curr_huffman_leaf->code = (unsigned short )tmp;
#line 265
    start_code ++;
#line 230
    t ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 269
  return (next_leaf);
}
}
#line 272 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/misc/inflate.c"
static int load_fixed_huffman(struct huffman_t *huffman , struct huffman_tree_t **huffman_tree_ptr ) 
{ 
  struct huffman_tree_t *huffman_tree ;
  int next_leaf ;
  void *tmp ;

  {
  {
#line 320
  huffman->dist_huff_count = 0;
#line 322
  tmp = malloc((size_t )(600UL * sizeof(struct huffman_tree_t )));
#line 322
  huffman_tree = (struct huffman_tree_t *)tmp;
#line 324
  *huffman_tree_ptr = huffman_tree;
#line 326
  huffman_tree->left = (short)0;
#line 327
  huffman_tree->right = (short)0;
#line 330
  next_leaf = 0;
#line 331
  next_leaf = add_static_codes_to_tree(huffman_tree, 8, 144, 48, 0, next_leaf);
#line 332
  next_leaf = add_static_codes_to_tree(huffman_tree, 9, 112, 400, 144, next_leaf);
#line 333
  next_leaf = add_static_codes_to_tree(huffman_tree, 7, 24, 0, 256, next_leaf);
#line 334
  next_leaf = add_static_codes_to_tree(huffman_tree, 8, 8, 192, 280, next_leaf);
  }
#line 337
  return (0);
}
}
#line 340 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/misc/inflate.c"
static int load_codes(FILE *in , struct bitstream_t *bitstream , int *lengths , int count ,
                      int *hclen_code_length , int *hclen_code , struct huffman_tree_t *huffman_tree ) 
{ 
  int r ;
  int t ;
  int c___0 ;
  int x ;
  int code ;
  int curr_code ;
  int bl_count[512] ;
  int next_code[512] ;
  int bits ;
  int max_bits ;
  int next_leaf ;
  int curr_leaf ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  void *__cil_tmp26 ;
  void *__cil_tmp27 ;
  char *__cil_tmp28 ;

  {
#line 354
  r = 0;
  {
#line 355
  while (1) {
    while_continue: /* CIL Label */ ;
#line 355
    if (! (r < count)) {
#line 355
      goto while_break;
    }
#line 357
    t = 0;
    {
#line 357
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 357
      if (! (t < 19)) {
#line 357
        goto while_break___0;
      }
#line 359
      if (*(hclen_code_length + t) == 0) {
#line 359
        goto __Cont;
      }
      {
#line 360
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 360
        if (! (bitstream->bitptr < *(hclen_code_length + t))) {
#line 360
          goto while_break___1;
        }
        {
#line 362
        tmp = _IO_getc(in);
#line 362
        bitstream->holding = (unsigned int )reverse[tmp] + (bitstream->holding << 8);
#line 363
        bitstream->bitptr += 8;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 366
      curr_code = (int )(bitstream->holding >> (bitstream->bitptr - *(hclen_code_length + t)));
#line 377
      if (curr_code == *(hclen_code + t)) {
#line 379
        bitstream->bitptr -= *(hclen_code_length + t);
#line 380
        bitstream->holding &= (unsigned int )((1 << bitstream->bitptr) - 1);
#line 381
        goto while_break___0;
      }
      __Cont: /* CIL Label */ 
#line 357
      t ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 385
    if (t <= 15) {
#line 387
      tmp___0 = r;
#line 387
      r ++;
#line 387
      *(lengths + tmp___0) = t;
    } else
#line 390
    if (t == 16) {
#line 392
      if (r != 0) {
#line 393
        code = *(lengths + (r - 1));
      } else {
#line 395
        code = 0;
      }
#line 397
      if (bitstream->bitptr < 2) {
        {
#line 399
        tmp___1 = _IO_getc(in);
#line 399
        bitstream->holding = (unsigned int )reverse[tmp___1] + (bitstream->holding << 8);
#line 400
        bitstream->bitptr += 8;
        }
      }
#line 403
      x = (int )reverse[bitstream->holding >> (bitstream->bitptr - 2)] >> 6;
#line 404
      bitstream->bitptr -= 2;
#line 405
      bitstream->holding &= (unsigned int )((1 << bitstream->bitptr) - 1);
#line 407
      c___0 = 0;
      {
#line 407
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 407
        if (! (c___0 < x + 3)) {
#line 407
          goto while_break___2;
        }
#line 408
        tmp___2 = r;
#line 408
        r ++;
#line 408
        *(lengths + tmp___2) = code;
#line 407
        c___0 ++;
      }
      while_break___2: /* CIL Label */ ;
      }
    } else
#line 411
    if (t == 17) {
#line 413
      if (bitstream->bitptr < 3) {
        {
#line 415
        tmp___3 = _IO_getc(in);
#line 415
        bitstream->holding = (unsigned int )reverse[tmp___3] + (bitstream->holding << 8);
#line 416
        bitstream->bitptr += 8;
        }
      }
      {
#line 419
      x = (int )reverse[bitstream->holding >> (bitstream->bitptr - 3)] >> 5;
#line 420
      bitstream->bitptr -= 3;
#line 421
      bitstream->holding &= (unsigned int )((1 << bitstream->bitptr) - 1);
#line 423
      c___0 = x + 3;
#line 424
      memset((void *)(lengths + r), 0, (size_t )(sizeof(int ) * (unsigned long )c___0));
#line 425
      r += c___0;
      }
    } else
#line 428
    if (t == 18) {
#line 430
      if (bitstream->bitptr < 7) {
        {
#line 432
        tmp___4 = _IO_getc(in);
#line 432
        bitstream->holding = (unsigned int )reverse[tmp___4] + (bitstream->holding << 8);
#line 433
        bitstream->bitptr += 8;
        }
      }
      {
#line 436
      x = (int )reverse[bitstream->holding >> (bitstream->bitptr - 7)] >> 1;
#line 437
      bitstream->bitptr -= 7;
#line 438
      bitstream->holding &= (unsigned int )((1 << bitstream->bitptr) - 1);
#line 440
      c___0 = x + 11;
#line 441
      memset((void *)(lengths + r), 0, (size_t )(sizeof(int ) * (unsigned long )c___0));
#line 442
      r += c___0;
      }
    } else {
      {
#line 447
      printf((char const   */* __restrict  */)"Error in bitstream reading in literal code length %d\n",
             t);
#line 448
      exit(0);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 458
  memset((void *)(bl_count), 0, (size_t )((unsigned long )count * sizeof(int )));
#line 461
  max_bits = 0;
#line 462
  t = 0;
  }
  {
#line 462
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 462
    if (! (t < count)) {
#line 462
      goto while_break___3;
    }
#line 464
    (bl_count[*(lengths + t)]) ++;
#line 465
    if (max_bits < *(lengths + t)) {
#line 465
      max_bits = *(lengths + t);
    }
#line 462
    t ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 468
  code = 0;
#line 469
  bl_count[0] = 0;
#line 470
  bits = 1;
  {
#line 470
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 470
    if (! (bits <= max_bits)) {
#line 470
      goto while_break___4;
    }
#line 472
    code = (code + bl_count[bits - 1]) << 1;
#line 473
    next_code[bits] = code;
#line 470
    bits ++;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 476
  huffman_tree->left = (short)0;
#line 477
  huffman_tree->right = (short)0;
#line 478
  next_leaf = 0;
#line 480
  t = 0;
  {
#line 480
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 480
    if (! (t < count)) {
#line 480
      goto while_break___5;
    }
#line 482
    if (*(lengths + t) != 0) {
#line 488
      code = next_code[*(lengths + t)];
#line 490
      curr_leaf = 0;
#line 492
      x = 1 << (*(lengths + t) - 1);
#line 493
      r = 0;
      {
#line 493
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 493
        if (! (r < *(lengths + t))) {
#line 493
          goto while_break___6;
        }
#line 495
        if ((code & x) == 0) {
#line 497
          if ((int )(huffman_tree + curr_leaf)->left == 0) {
#line 499
            next_leaf ++;
#line 500
            (huffman_tree + curr_leaf)->left = (short )next_leaf;
#line 501
            (huffman_tree + next_leaf)->left = (short)0;
#line 502
            (huffman_tree + next_leaf)->right = (short)0;
          }
#line 505
          curr_leaf = (int )(huffman_tree + curr_leaf)->left;
        } else {
#line 509
          if ((int )(huffman_tree + curr_leaf)->right == 0) {
#line 511
            next_leaf ++;
#line 512
            (huffman_tree + curr_leaf)->right = (short )next_leaf;
#line 513
            (huffman_tree + next_leaf)->left = (short)0;
#line 514
            (huffman_tree + next_leaf)->right = (short)0;
          }
#line 517
          curr_leaf = (int )(huffman_tree + curr_leaf)->right;
        }
#line 520
        x >>= 1;
#line 493
        r ++;
      }
      while_break___6: /* CIL Label */ ;
      }
#line 523
      (huffman_tree + curr_leaf)->code = (unsigned short )t;
#line 525
      (next_code[*(lengths + t)]) ++;
    }
#line 480
    t ++;
  }
  while_break___5: /* CIL Label */ ;
  }
#line 533
  return (0);
}
}
#line 536 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/misc/inflate.c"
static int load_dynamic_huffman(FILE *in , struct huffman_t *huffman , struct bitstream_t *bitstream ,
                                struct huffman_tree_t *huffman_tree_len , struct huffman_tree_t *huffman_tree_dist ) 
{ 
  int hlit ;
  int hdist ;
  int hclen ;
  int hclen_code_lengths[19] ;
  int hclen_code[19] ;
  int bl_count[19] ;
  int next_code[19] ;
  int code ;
  int bits ;
  int t ;
  int tmp ;
  int tmp___0 ;
  void *__cil_tmp18 ;
  void *__cil_tmp19 ;
  void *__cil_tmp20 ;
  void *__cil_tmp21 ;

  {
  {
#line 547
  while (1) {
    while_continue: /* CIL Label */ ;
#line 547
    if (! (bitstream->bitptr < 14)) {
#line 547
      goto while_break;
    }
    {
#line 549
    tmp = _IO_getc(in);
#line 549
    bitstream->holding = (unsigned int )reverse[tmp] + (bitstream->holding << 8);
#line 550
    bitstream->bitptr += 8;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 553
  hlit = (int )(bitstream->holding >> (bitstream->bitptr - 5));
#line 554
  bitstream->bitptr -= 5;
#line 555
  bitstream->holding &= (unsigned int )((1 << bitstream->bitptr) - 1);
#line 557
  hdist = (int )(bitstream->holding >> (bitstream->bitptr - 5));
#line 558
  bitstream->bitptr -= 5;
#line 559
  bitstream->holding &= (unsigned int )((1 << bitstream->bitptr) - 1);
#line 561
  hclen = (int )(bitstream->holding >> (bitstream->bitptr - 4));
#line 562
  bitstream->bitptr -= 4;
#line 563
  bitstream->holding &= (unsigned int )((1 << bitstream->bitptr) - 1);
#line 565
  hlit = ((int )reverse[hlit] >> 3) + 257;
#line 566
  hdist = ((int )reverse[hdist] >> 3) + 1;
#line 567
  hclen = ((int )reverse[hclen] >> 4) + 4;
#line 577
  memset((void *)(hclen_code_lengths), 0, (size_t )(19UL * sizeof(int )));
#line 578
  memset((void *)(hclen_code), 0, (size_t )(19UL * sizeof(int )));
#line 579
  memset((void *)(bl_count), 0, (size_t )(19UL * sizeof(int )));
#line 584
  t = 0;
  }
  {
#line 584
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 584
    if (! (t < hclen)) {
#line 584
      goto while_break___0;
    }
#line 586
    if (bitstream->bitptr < 3) {
      {
#line 588
      tmp___0 = _IO_getc(in);
#line 588
      bitstream->holding = (unsigned int )reverse[tmp___0] + (bitstream->holding << 8);
#line 589
      bitstream->bitptr += 8;
      }
    }
#line 592
    hclen_code_lengths[dyn_huff_trans[t]] = (int )(bitstream->holding >> (bitstream->bitptr - 3));
#line 593
    hclen_code_lengths[dyn_huff_trans[t]] = (int )reverse[hclen_code_lengths[dyn_huff_trans[t]]] >> 5;
#line 594
    bitstream->bitptr -= 3;
#line 595
    bitstream->holding &= (unsigned int )((1 << bitstream->bitptr) - 1);
#line 584
    t ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 608
  t = 0;
  {
#line 608
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 608
    if (! (t < 19)) {
#line 608
      goto while_break___1;
    }
#line 610
    (bl_count[hclen_code_lengths[t]]) ++;
#line 608
    t ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 623
  code = 0;
#line 624
  bl_count[0] = 0;
#line 625
  bits = 1;
  {
#line 625
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 625
    if (! (bits <= 7)) {
#line 625
      goto while_break___2;
    }
#line 627
    code = (code + bl_count[bits - 1]) << 1;
#line 628
    next_code[bits] = code;
#line 625
    bits ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 643
  t = 0;
  {
#line 643
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 643
    if (! (t < 19)) {
#line 643
      goto while_break___3;
    }
#line 645
    if (hclen_code_lengths[t] != 0) {
#line 647
      hclen_code[t] = next_code[hclen_code_lengths[t]];
#line 648
      (next_code[hclen_code_lengths[t]]) ++;
    }
#line 643
    t ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 666
  memset((void *)(huffman->len), 0, (size_t )(288UL * sizeof(int )));
#line 669
  load_codes(in, bitstream, huffman->len, hlit, hclen_code_lengths, hclen_code, huffman_tree_len);
  }
#line 687
  if (hdist == 0) {
#line 689
    huffman->dist_huff_count = 0;
  } else {
    {
#line 693
    huffman->dist_huff_count = hdist;
#line 695
    memset((void *)(huffman->dist_len), 0, (size_t )(33UL * sizeof(int )));
#line 698
    load_codes(in, bitstream, huffman->dist_len, hdist, hclen_code_lengths, hclen_code,
               huffman_tree_dist);
    }
  }
#line 702
  return (0);
}
}
#line 705 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/misc/inflate.c"
int decompress(FILE *in , struct huffman_t *huffman , struct bitstream_t *bitstream ,
               struct huffman_tree_t *huffman_tree_len , struct huffman_tree_t *huffman_tree_dist ,
               FILE *out ) 
{ 
  int code ;
  int len ;
  int dist ;
  int t ;
  int r ;
  unsigned char *window ;
  struct huffman_tree_t *curr_huffman_leaf ;
  int window_ptr ;
  int curr_leaf ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
  {
#line 707
  code = 0;
#line 720
  reverse_bitstream(bitstream);
#line 723
  window_ptr = huffman->window_ptr;
#line 724
  window = huffman->window;
  }
  {
#line 726
  while (1) {
    while_continue: /* CIL Label */ ;
#line 728
    curr_huffman_leaf = huffman_tree_len;
#line 729
    curr_leaf = 0;
    {
#line 731
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 733
      if (bitstream->bitptr <= 0) {
        {
#line 737
        tmp = _IO_getc(in);
#line 737
        bitstream->holding = (unsigned int )tmp;
#line 738
        bitstream->bitptr = 8;
        }
      }
#line 745
      if ((bitstream->holding & 1U) == 0U) {
#line 747
        if ((int )(huffman_tree_len + curr_leaf)->left == 0) {
#line 749
          code = (int )(huffman_tree_len + curr_leaf)->code;
#line 750
          goto while_break___0;
        }
#line 752
        curr_leaf = (int )(huffman_tree_len + curr_leaf)->left;
      } else {
#line 756
        if ((int )(huffman_tree_len + curr_leaf)->right == 0) {
#line 758
          code = (int )(huffman_tree_len + curr_leaf)->code;
#line 759
          goto while_break___0;
        }
#line 761
        curr_leaf = (int )(huffman_tree_len + curr_leaf)->right;
      }
#line 764
      (bitstream->bitptr) --;
#line 765
      bitstream->holding >>= 1;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 775
    if (code < 256) {
#line 784
      tmp___0 = window_ptr;
#line 784
      window_ptr ++;
#line 784
      *(window + tmp___0) = (unsigned char )code;
#line 785
      if (window_ptr >= 32768) {
        {
#line 787
        fwrite((void const   */* __restrict  */)window, (size_t )1, (size_t )32768,
               (FILE */* __restrict  */)out);
#line 788
        huffman->checksum = crc32(huffman->window, 32768, huffman->checksum);
#line 789
        window_ptr = 0;
        }
      }
    } else
#line 793
    if (code == 256) {
#line 798
      goto while_break;
    } else {
#line 806
      code -= 257;
#line 807
      len = length_codes[code];
#line 808
      if (length_extra_bits[code] != 0) {
        {
#line 810
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 810
          if (! (bitstream->bitptr < length_extra_bits[code])) {
#line 810
            goto while_break___1;
          }
          {
#line 812
          tmp___1 = _IO_getc(in);
#line 812
          bitstream->holding += (unsigned int )(tmp___1 << bitstream->bitptr);
#line 813
          bitstream->bitptr += 8;
          }
        }
        while_break___1: /* CIL Label */ ;
        }
#line 821
        len = (int )((unsigned int )len + (bitstream->holding & (unsigned int )((1 << length_extra_bits[code]) - 1)));
#line 822
        bitstream->bitptr -= length_extra_bits[code];
#line 823
        bitstream->holding >>= length_extra_bits[code];
      }
#line 826
      if (huffman->dist_huff_count == 0) {
#line 828
        if (bitstream->bitptr < 5) {
          {
#line 830
          tmp___2 = _IO_getc(in);
#line 830
          bitstream->holding += (unsigned int )(tmp___2 << bitstream->bitptr);
#line 831
          bitstream->bitptr += 8;
          }
        }
#line 834
        code = (int )(bitstream->holding & 31U);
#line 835
        code = (int )reverse[code & 255] >> 3;
#line 836
        bitstream->bitptr -= 5;
#line 837
        bitstream->holding >>= 5;
      } else {
#line 845
        curr_huffman_leaf = huffman_tree_len;
#line 846
        curr_leaf = 0;
        {
#line 848
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 850
          if (bitstream->bitptr <= 0) {
            {
#line 854
            tmp___3 = _IO_getc(in);
#line 854
            bitstream->holding = (unsigned int )tmp___3;
#line 855
            bitstream->bitptr = 8;
            }
          }
#line 862
          if ((bitstream->holding & 1U) == 0U) {
#line 864
            if ((int )(huffman_tree_dist + curr_leaf)->left == 0) {
#line 866
              code = (int )(huffman_tree_dist + curr_leaf)->code;
#line 867
              goto while_break___2;
            }
#line 869
            curr_leaf = (int )(huffman_tree_dist + curr_leaf)->left;
          } else {
#line 873
            if ((int )(huffman_tree_dist + curr_leaf)->right == 0) {
#line 875
              code = (int )(huffman_tree_dist + curr_leaf)->code;
#line 876
              goto while_break___2;
            }
#line 878
            curr_leaf = (int )(huffman_tree_dist + curr_leaf)->right;
          }
#line 881
          (bitstream->bitptr) --;
#line 882
          bitstream->holding >>= 1;
        }
        while_break___2: /* CIL Label */ ;
        }
      }
#line 886
      dist = dist_codes[code];
#line 888
      if (dist_extra_bits[code] != 0) {
        {
#line 890
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 890
          if (! (bitstream->bitptr < dist_extra_bits[code])) {
#line 890
            goto while_break___3;
          }
          {
#line 892
          tmp___4 = _IO_getc(in);
#line 892
          bitstream->holding += (unsigned int )(tmp___4 << bitstream->bitptr);
#line 893
          bitstream->bitptr += 8;
          }
        }
        while_break___3: /* CIL Label */ ;
        }
#line 901
        dist = (int )((unsigned int )dist + (bitstream->holding & (unsigned int )((1 << dist_extra_bits[code]) - 1)));
#line 903
        bitstream->bitptr -= dist_extra_bits[code];
#line 904
        bitstream->holding >>= dist_extra_bits[code];
      }
#line 922
      r = window_ptr - dist;
#line 928
      if (r >= 0) {
#line 928
        if (window_ptr + len < 32768) {
#line 928
          if (r + len < window_ptr) {
            {
#line 931
            memcpy((void */* __restrict  */)(window + window_ptr), (void const   */* __restrict  */)(window + r),
                   (size_t )len);
#line 932
            window_ptr += len;
            }
          } else {
#line 928
            goto _L;
          }
        } else {
#line 928
          goto _L;
        }
      } else {
        _L: /* CIL Label */ 
#line 936
        if (r < 0) {
#line 936
          r += 32768;
        }
#line 938
        t = 0;
        {
#line 938
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 938
          if (! (t < len)) {
#line 938
            goto while_break___4;
          }
#line 940
          tmp___5 = window_ptr;
#line 940
          window_ptr ++;
#line 940
          tmp___6 = r;
#line 940
          r ++;
#line 940
          *(window + tmp___5) = *(window + tmp___6);
#line 941
          if (r >= 32768) {
#line 941
            r = 0;
          }
#line 943
          if (window_ptr >= 32768) {
            {
#line 945
            fwrite((void const   */* __restrict  */)window, (size_t )1, (size_t )32768,
                   (FILE */* __restrict  */)out);
#line 946
            huffman->checksum = crc32(huffman->window, 32768, huffman->checksum);
#line 947
            window_ptr = 0;
            }
          }
#line 938
          t ++;
        }
        while_break___4: /* CIL Label */ ;
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 958
  huffman->window_ptr = window_ptr;
#line 960
  reverse_bitstream(bitstream);
  }
#line 962
  return (0);
}
}
#line 965 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/misc/inflate.c"
int inflate(FILE *in , FILE *out , unsigned int *checksum ) 
{ 
  unsigned char CMF ;
  unsigned char FLG ;
  unsigned int DICT ;
  struct bitstream_t bitstream ;
  struct huffman_t huffman ;
  int comp_method ;
  int block_len ;
  int bfinal ;
  int t ;
  struct huffman_tree_t *huffman_tree_len ;
  struct huffman_tree_t *huffman_tree_dist ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  uint16 tmp___4 ;
  uint16 tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  void *__cil_tmp24 ;
  void *__cil_tmp25 ;
  void *__cil_tmp26 ;
  void *__cil_tmp27 ;
  void *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;

  {
  {
#line 979
  huffman.checksum = 4294967295U;
#line 981
  huffman_tree_len_static = (struct huffman_tree_t *)0;
#line 982
  tmp = malloc((size_t )(1024UL * sizeof(struct huffman_tree_t )));
#line 982
  huffman_tree_len = (struct huffman_tree_t *)tmp;
#line 983
  tmp___0 = malloc((size_t )(1024UL * sizeof(struct huffman_tree_t )));
#line 983
  huffman_tree_dist = (struct huffman_tree_t *)tmp___0;
#line 985
  huffman.window_ptr = 0;
#line 992
  tmp___1 = _IO_getc(in);
#line 992
  CMF = (unsigned char )tmp___1;
#line 993
  tmp___2 = _IO_getc(in);
#line 993
  FLG = (unsigned char )tmp___2;
  }
#line 1005
  if (((int )CMF & 15) != 8) {
    {
#line 1007
    printf((char const   */* __restrict  */)"Unsupported compression used.\n");
    }
#line 1008
    return (-1);
  }
#line 1011
  if (((int )FLG & 32) != 0) {
    {
#line 1013
    DICT = read32b(in);
    }
  }
#line 1016
  if (((int )CMF * 256 + (int )FLG) % 31 != 0) {
    {
#line 1018
    printf((char const   */* __restrict  */)"FCHECK fails.\n");
    }
  }
#line 1023
  bitstream.holding = 0U;
#line 1024
  bitstream.bitptr = 0;
  {
#line 1026
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1028
    if (bitstream.bitptr < 3) {
      {
#line 1030
      tmp___3 = _IO_getc(in);
#line 1030
      bitstream.holding = (unsigned int )reverse[tmp___3] + (bitstream.holding << 8);
#line 1031
      bitstream.bitptr += 8;
      }
    }
#line 1038
    bfinal = (int )(bitstream.holding >> (bitstream.bitptr - 1));
#line 1039
    comp_method = (int )((bitstream.holding >> (bitstream.bitptr - 3)) & 3U);
#line 1041
    bitstream.bitptr -= 3;
#line 1042
    bitstream.holding &= (unsigned int )((1 << bitstream.bitptr) - 1);
#line 1048
    if (comp_method == 0) {
      {
#line 1051
      bitstream.holding = 0U;
#line 1052
      bitstream.bitptr = 0;
#line 1054
      tmp___4 = read16l(in);
#line 1054
      block_len = (int )tmp___4;
#line 1056
      tmp___5 = read16l(in);
#line 1056
      t = (int )tmp___5 ^ 65535;
      }
#line 1058
      if (block_len != t) {
        {
#line 1060
        printf((char const   */* __restrict  */)"Error: LEN and NLEN don\'t match (%d %d)\n",
               block_len, t);
        }
#line 1061
        goto while_break;
      }
#line 1064
      t = 0;
      {
#line 1064
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1064
        if (! (t < block_len)) {
#line 1064
          goto while_break___0;
        }
        {
#line 1066
        tmp___6 = huffman.window_ptr;
#line 1066
        (huffman.window_ptr) ++;
#line 1066
        tmp___7 = _IO_getc(in);
#line 1066
        huffman.window[tmp___6] = (unsigned char )tmp___7;
        }
#line 1068
        if (huffman.window_ptr >= 32768) {
          {
#line 1070
          fwrite((void const   */* __restrict  */)(huffman.window), (size_t )1, (size_t )32768,
                 (FILE */* __restrict  */)out);
#line 1071
          huffman.checksum = crc32(huffman.window, 32768, huffman.checksum);
#line 1072
          huffman.window_ptr = 0;
          }
        }
#line 1064
        t ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    } else
#line 1077
    if (comp_method == 2) {
#line 1080
      if ((unsigned long )huffman_tree_len_static == (unsigned long )((struct huffman_tree_t *)0)) {
        {
#line 1081
        load_fixed_huffman(& huffman, & huffman_tree_len_static);
        }
      }
      {
#line 1082
      decompress(in, & huffman, & bitstream, huffman_tree_len_static, (struct huffman_tree_t *)0,
                 out);
      }
    } else
#line 1089
    if (comp_method == 1) {
      {
#line 1093
      load_dynamic_huffman(in, & huffman, & bitstream, huffman_tree_len, huffman_tree_dist);
#line 1094
      decompress(in, & huffman, & bitstream, huffman_tree_len, huffman_tree_dist,
                 out);
      }
    } else
#line 1098
    if (comp_method == 3) {
      {
#line 1101
      printf((char const   */* __restrict  */)"Error (inflate): unknown compression type\n");
      }
#line 1102
      goto while_break;
    }
#line 1105
    if (bfinal == 1) {
#line 1105
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1108
  if (huffman.window_ptr != 0) {
    {
#line 1110
    fwrite((void const   */* __restrict  */)(huffman.window), (size_t )1, (size_t )huffman.window_ptr,
           (FILE */* __restrict  */)out);
#line 1111
    huffman.checksum = crc32(huffman.window, huffman.window_ptr, huffman.checksum);
    }
  }
#line 1119
  if ((unsigned long )huffman_tree_len != (unsigned long )((struct huffman_tree_t *)0)) {
    {
#line 1119
    free((void *)huffman_tree_len);
    }
  }
#line 1120
  if ((unsigned long )huffman_tree_dist != (unsigned long )((struct huffman_tree_t *)0)) {
    {
#line 1120
    free((void *)huffman_tree_dist);
    }
  }
#line 1122
  *checksum = huffman.checksum ^ 4294967295U;
#line 1129
  return (0);
}
}
#line 10 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/misc/crc32.c"
static unsigned long const   crctab[256]  = 
#line 10 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/misc/crc32.c"
  {      (unsigned long const   )0,      (unsigned long const   )79764919,      (unsigned long const   )159529838,      (unsigned long const   )222504665, 
        (unsigned long const   )319059676,      (unsigned long const   )398814059,      (unsigned long const   )445009330,      (unsigned long const   )507990021, 
        (unsigned long const   )638119352,      (unsigned long const   )583659535,      (unsigned long const   )797628118,      (unsigned long const   )726387553, 
        (unsigned long const   )890018660,      (unsigned long const   )835552979,      (unsigned long const   )1015980042,      (unsigned long const   )944750013, 
        (unsigned long const   )1276238704,      (unsigned long const   )1221641927,      (unsigned long const   )1167319070,      (unsigned long const   )1095957929, 
        (unsigned long const   )1595256236,      (unsigned long const   )1540665371,      (unsigned long const   )1452775106,      (unsigned long const   )1381403509, 
        (unsigned long const   )1780037320,      (unsigned long const   )1859660671,      (unsigned long const   )1671105958,      (unsigned long const   )1733955601, 
        (unsigned long const   )2031960084,      (unsigned long const   )2111593891,      (unsigned long const   )1889500026,      (unsigned long const   )1952343757, 
        (unsigned long const   )2552477408U,      (unsigned long const   )2632100695U,      (unsigned long const   )2443283854U,      (unsigned long const   )2506133561U, 
        (unsigned long const   )2334638140U,      (unsigned long const   )2414271883U,      (unsigned long const   )2191915858U,      (unsigned long const   )2254759653U, 
        (unsigned long const   )3190512472U,      (unsigned long const   )3135915759U,      (unsigned long const   )3081330742U,      (unsigned long const   )3009969537U, 
        (unsigned long const   )2905550212U,      (unsigned long const   )2850959411U,      (unsigned long const   )2762807018U,      (unsigned long const   )2691435357U, 
        (unsigned long const   )3560074640U,      (unsigned long const   )3505614887U,      (unsigned long const   )3719321342U,      (unsigned long const   )3648080713U, 
        (unsigned long const   )3342211916U,      (unsigned long const   )3287746299U,      (unsigned long const   )3467911202U,      (unsigned long const   )3396681109U, 
        (unsigned long const   )4063920168U,      (unsigned long const   )4143685023U,      (unsigned long const   )4223187782U,      (unsigned long const   )4286162673U, 
        (unsigned long const   )3779000052U,      (unsigned long const   )3858754371U,      (unsigned long const   )3904687514U,      (unsigned long const   )3967668269U, 
        (unsigned long const   )881225847,      (unsigned long const   )809987520,      (unsigned long const   )1023691545,      (unsigned long const   )969234094, 
        (unsigned long const   )662832811,      (unsigned long const   )591600412,      (unsigned long const   )771767749,      (unsigned long const   )717299826, 
        (unsigned long const   )311336399,      (unsigned long const   )374308984,      (unsigned long const   )453813921,      (unsigned long const   )533576470, 
        (unsigned long const   )25881363,      (unsigned long const   )88864420,      (unsigned long const   )134795389,      (unsigned long const   )214552010, 
        (unsigned long const   )2023205639,      (unsigned long const   )2086057648,      (unsigned long const   )1897238633,      (unsigned long const   )1976864222, 
        (unsigned long const   )1804852699,      (unsigned long const   )1867694188,      (unsigned long const   )1645340341,      (unsigned long const   )1724971778, 
        (unsigned long const   )1587496639,      (unsigned long const   )1516133128,      (unsigned long const   )1461550545,      (unsigned long const   )1406951526, 
        (unsigned long const   )1302016099,      (unsigned long const   )1230646740,      (unsigned long const   )1142491917,      (unsigned long const   )1087903418, 
        (unsigned long const   )2896545431U,      (unsigned long const   )2825181984U,      (unsigned long const   )2770861561U,      (unsigned long const   )2716262478U, 
        (unsigned long const   )3215044683U,      (unsigned long const   )3143675388U,      (unsigned long const   )3055782693U,      (unsigned long const   )3001194130U, 
        (unsigned long const   )2326604591U,      (unsigned long const   )2389456536U,      (unsigned long const   )2200899649U,      (unsigned long const   )2280525302U, 
        (unsigned long const   )2578013683U,      (unsigned long const   )2640855108U,      (unsigned long const   )2418763421U,      (unsigned long const   )2498394922U, 
        (unsigned long const   )3769900519U,      (unsigned long const   )3832873040U,      (unsigned long const   )3912640137U,      (unsigned long const   )3992402750U, 
        (unsigned long const   )4088425275U,      (unsigned long const   )4151408268U,      (unsigned long const   )4197601365U,      (unsigned long const   )4277358050U, 
        (unsigned long const   )3334271071U,      (unsigned long const   )3263032808U,      (unsigned long const   )3476998961U,      (unsigned long const   )3422541446U, 
        (unsigned long const   )3585640067U,      (unsigned long const   )3514407732U,      (unsigned long const   )3694837229U,      (unsigned long const   )3640369242U, 
        (unsigned long const   )1762451694,      (unsigned long const   )1842216281,      (unsigned long const   )1619975040,      (unsigned long const   )1682949687, 
        (unsigned long const   )2047383090,      (unsigned long const   )2127137669,      (unsigned long const   )1938468188,      (unsigned long const   )2001449195, 
        (unsigned long const   )1325665622,      (unsigned long const   )1271206113,      (unsigned long const   )1183200824,      (unsigned long const   )1111960463, 
        (unsigned long const   )1543535498,      (unsigned long const   )1489069629,      (unsigned long const   )1434599652,      (unsigned long const   )1363369299, 
        (unsigned long const   )622672798,      (unsigned long const   )568075817,      (unsigned long const   )748617968,      (unsigned long const   )677256519, 
        (unsigned long const   )907627842,      (unsigned long const   )853037301,      (unsigned long const   )1067152940,      (unsigned long const   )995781531, 
        (unsigned long const   )51762726,      (unsigned long const   )131386257,      (unsigned long const   )177728840,      (unsigned long const   )240578815, 
        (unsigned long const   )269590778,      (unsigned long const   )349224269,      (unsigned long const   )429104020,      (unsigned long const   )491947555, 
        (unsigned long const   )4046411278U,      (unsigned long const   )4126034873U,      (unsigned long const   )4172115296U,      (unsigned long const   )4234965207U, 
        (unsigned long const   )3794477266U,      (unsigned long const   )3874110821U,      (unsigned long const   )3953728444U,      (unsigned long const   )4016571915U, 
        (unsigned long const   )3609705398U,      (unsigned long const   )3555108353U,      (unsigned long const   )3735388376U,      (unsigned long const   )3664026991U, 
        (unsigned long const   )3290680682U,      (unsigned long const   )3236090077U,      (unsigned long const   )3449943556U,      (unsigned long const   )3378572211U, 
        (unsigned long const   )3174993278U,      (unsigned long const   )3120533705U,      (unsigned long const   )3032266256U,      (unsigned long const   )2961025959U, 
        (unsigned long const   )2923101090U,      (unsigned long const   )2868635157U,      (unsigned long const   )2813903052U,      (unsigned long const   )2742672763U, 
        (unsigned long const   )2604032198U,      (unsigned long const   )2683796849U,      (unsigned long const   )2461293480U,      (unsigned long const   )2524268063U, 
        (unsigned long const   )2284983834U,      (unsigned long const   )2364738477U,      (unsigned long const   )2175806836U,      (unsigned long const   )2238787779U, 
        (unsigned long const   )1569362073,      (unsigned long const   )1498123566,      (unsigned long const   )1409854455,      (unsigned long const   )1355396672, 
        (unsigned long const   )1317987909,      (unsigned long const   )1246755826,      (unsigned long const   )1192025387,      (unsigned long const   )1137557660, 
        (unsigned long const   )2072149281,      (unsigned long const   )2135122070,      (unsigned long const   )1912620623,      (unsigned long const   )1992383480, 
        (unsigned long const   )1753615357,      (unsigned long const   )1816598090,      (unsigned long const   )1627664531,      (unsigned long const   )1707420964, 
        (unsigned long const   )295390185,      (unsigned long const   )358241886,      (unsigned long const   )404320391,      (unsigned long const   )483945776, 
        (unsigned long const   )43990325,      (unsigned long const   )106832002,      (unsigned long const   )186451547,      (unsigned long const   )266083308, 
        (unsigned long const   )932423249,      (unsigned long const   )861060070,      (unsigned long const   )1041341759,      (unsigned long const   )986742920, 
        (unsigned long const   )613929101,      (unsigned long const   )542559546,      (unsigned long const   )756411363,      (unsigned long const   )701822548, 
        (unsigned long const   )3316196985U,      (unsigned long const   )3244833742U,      (unsigned long const   )3425377559U,      (unsigned long const   )3370778784U, 
        (unsigned long const   )3601682597U,      (unsigned long const   )3530312978U,      (unsigned long const   )3744426955U,      (unsigned long const   )3689838204U, 
        (unsigned long const   )3819031489U,      (unsigned long const   )3881883254U,      (unsigned long const   )3928223919U,      (unsigned long const   )4007849240U, 
        (unsigned long const   )4037393693U,      (unsigned long const   )4100235434U,      (unsigned long const   )4180117107U,      (unsigned long const   )4259748804U, 
        (unsigned long const   )2310601993U,      (unsigned long const   )2373574846U,      (unsigned long const   )2151335527U,      (unsigned long const   )2231098320U, 
        (unsigned long const   )2596047829U,      (unsigned long const   )2659030626U,      (unsigned long const   )2470359227U,      (unsigned long const   )2550115596U, 
        (unsigned long const   )2947551409U,      (unsigned long const   )2876312838U,      (unsigned long const   )2788305887U,      (unsigned long const   )2733848168U, 
        (unsigned long const   )3165939309U,      (unsigned long const   )3094707162U,      (unsigned long const   )3040238851U,      (unsigned long const   )2985771188U};
#line 65 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/misc/crc32.c"
int cksum(FILE *fp ) 
{ 
  unsigned char buf___1[1 << 16] ;
  unsigned long crc___0 ;
  long length ;
  long bytes_read ;
  unsigned char *cp ;
  unsigned char *tmp ;
  long tmp___0 ;
  size_t tmp___1 ;
  void *__cil_tmp10 ;

  {
#line 68
  crc___0 = 0UL;
#line 69
  length = 0L;
  {
#line 72
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 72
    tmp___1 = fread((void */* __restrict  */)(buf___1), (size_t )1, (size_t )(1 << 16),
                    (FILE */* __restrict  */)fp);
#line 72
    bytes_read = (long )tmp___1;
    }
#line 72
    if (! (bytes_read > 0L)) {
#line 72
      goto while_break;
    }
#line 73
    cp = buf___1;
#line 75
    length += bytes_read;
    {
#line 76
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 76
      tmp___0 = bytes_read;
#line 76
      bytes_read --;
#line 76
      if (! tmp___0) {
#line 76
        goto while_break___0;
      }
#line 77
      tmp = cp;
#line 77
      cp ++;
#line 77
      crc___0 = (crc___0 << 8) ^ (unsigned long )crctab[((crc___0 >> 24) ^ (unsigned long )*tmp) & 255UL];
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 80
  bytes_read = length;
  {
#line 81
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 81
    if (! (bytes_read > 0L)) {
#line 81
      goto while_break___1;
    }
#line 82
    crc___0 = (crc___0 << 8) ^ (unsigned long )crctab[((crc___0 >> 24) ^ (unsigned long )bytes_read) & 255UL];
#line 83
    bytes_read >>= 8;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 86
  crc___0 = ~ crc___0 & 4294967295UL;
#line 88
  return ((int )crc___0);
}
}
#line 172 "/usr/include/stdio.h"
extern FILE *tmpfile(void) ;
#line 831
extern  __attribute__((__nothrow__)) int fileno(FILE *__stream ) ;
#line 67 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) memcmp)(void const   *__s1 ,
                                                                                     void const   *__s2 ,
                                                                                     size_t __n )  __attribute__((__pure__)) ;
#line 214 "/usr/include/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2))) fstat)(int __fd ,
                                                                                  struct stat *__buf ) ;
#line 116 "/usr/include/sys/wait.h"
extern __pid_t wait(union wait *__stat_loc ) ;
#line 414 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int pipe(int *__pipedes ) ;
#line 529
extern  __attribute__((__nothrow__)) int dup2(int __fd , int __fd2 ) ;
#line 579
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) execlp)(char const   *__file ,
                                                                                   char const   *__arg 
                                                                                   , ...) ;
#line 773
extern  __attribute__((__nothrow__)) __pid_t fork(void) ;
#line 300 "src/include/common.h"
uint32 read32l(FILE *f ) ;
#line 306
void write32l(FILE *f , uint32 w ) ;
#line 309
uint16 readmem16l(uint8 *m___0 ) ;
#line 33 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/misc/oxm.c"
static void move_data(FILE *out , FILE *in , int len ) 
{ 
  uint8 buf___1[1024] ;
  int l ;
  int tmp ;
  size_t tmp___0 ;
  void *__cil_tmp8 ;

  {
  {
#line 38
  while (1) {
    while_continue: /* CIL Label */ ;
#line 39
    if (len > 1024) {
#line 39
      tmp = 1024;
    } else {
#line 39
      tmp = len;
    }
    {
#line 39
    tmp___0 = fread((void */* __restrict  */)(buf___1), (size_t )1, (size_t )tmp,
                    (FILE */* __restrict  */)in);
#line 39
    l = (int )tmp___0;
#line 40
    fwrite((void const   */* __restrict  */)(buf___1), (size_t )1, (size_t )l, (FILE */* __restrict  */)out);
#line 41
    len -= l;
    }
#line 38
    if (l > 0) {
#line 38
      if (! (len > 0)) {
#line 38
        goto while_break;
      }
    } else {
#line 38
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 43
  return;
}
}
#line 46 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/misc/oxm.c"
int test_oxm(FILE *f ) 
{ 
  int i___3 ;
  int j ;
  int hlen ;
  int npat ;
  int len ;
  int plen ;
  int nins ;
  int nsmp ;
  uint32 ilen ;
  int slen[256] ;
  uint8 buf___1[1024] ;
  int tmp ;
  uint32 tmp___0 ;
  uint16 tmp___1 ;
  uint16 tmp___2 ;
  uint32 tmp___3 ;
  uint16 tmp___4 ;
  uint16 tmp___5 ;
  uint32 tmp___6 ;
  uint32 tmp___7 ;
  void *__cil_tmp22 ;
  void *__cil_tmp23 ;
  char *__cil_tmp24 ;

  {
  {
#line 55
  fseek(f, 0L, 0);
#line 56
  fread((void */* __restrict  */)(buf___1), (size_t )16, (size_t )1, (FILE */* __restrict  */)f);
#line 57
  tmp = memcmp((void const   *)(buf___1), (void const   *)"Extended Module:", (size_t )16);
  }
#line 57
  if (tmp) {
#line 58
    return (-1);
  }
  {
#line 60
  fseek(f, 60L, 0);
#line 61
  tmp___0 = read32l(f);
#line 61
  hlen = (int )tmp___0;
#line 62
  fseek(f, 6L, 1);
#line 63
  tmp___1 = read16l(f);
#line 63
  npat = (int )tmp___1;
#line 64
  tmp___2 = read16l(f);
#line 64
  nins = (int )tmp___2;
  }
#line 66
  if (npat > 256) {
#line 67
    return (-1);
  } else
#line 66
  if (nins > 128) {
#line 67
    return (-1);
  }
  {
#line 69
  fseek(f, (long )(60 + hlen), 0);
#line 71
  i___3 = 0;
  }
  {
#line 71
  while (1) {
    while_continue: /* CIL Label */ ;
#line 71
    if (! (i___3 < npat)) {
#line 71
      goto while_break;
    }
    {
#line 72
    tmp___3 = read32l(f);
#line 72
    len = (int )tmp___3;
#line 73
    fseek(f, 3L, 1);
#line 74
    tmp___4 = read16l(f);
#line 74
    plen = (int )tmp___4;
#line 75
    fseek(f, (long )((len - 9) + plen), 1);
#line 71
    i___3 ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 78
  i___3 = 0;
  {
#line 78
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 78
    if (! (i___3 < nins)) {
#line 78
      goto while_break___0;
    }
    {
#line 79
    ilen = read32l(f);
    }
#line 80
    if (ilen > 263U) {
#line 81
      return (-1);
    }
    {
#line 82
    fseek(f, -4L, 1);
#line 83
    fread((void */* __restrict  */)(buf___1), ilen, (size_t )1, (FILE */* __restrict  */)f);
#line 84
    tmp___5 = readmem16l(buf___1 + 27);
#line 84
    nsmp = (int )tmp___5;
    }
#line 86
    if (nsmp > 255) {
#line 87
      return (-1);
    }
#line 88
    if (nsmp == 0) {
#line 89
      goto __Cont;
    }
#line 92
    j = 0;
    {
#line 92
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 92
      if (! (j < nsmp)) {
#line 92
        goto while_break___1;
      }
      {
#line 93
      tmp___6 = read32l(f);
#line 93
      slen[j] = (int )tmp___6;
#line 94
      fseek(f, 36L, 1);
#line 92
      j ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 98
    j = 0;
    {
#line 98
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 98
      if (! (j < nsmp)) {
#line 98
        goto while_break___2;
      }
      {
#line 99
      read32b(f);
#line 100
      tmp___7 = read32b(f);
      }
#line 100
      if (tmp___7 == 1332176723U) {
#line 101
        return (0);
      }
      {
#line 102
      fseek(f, (long )(slen[j] - 8), 1);
#line 98
      j ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
#line 78
    i___3 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 106
  return (-1);
}
}
#line 113 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/misc/oxm.c"
static char *oggdec(FILE *f , int len , int res , int *newlen ) 
{ 
  char buf___1[1024] ;
  FILE *t ;
  int i___3 ;
  int l ;
  struct stat st ;
  int8 *pcm ;
  int16 *pcm16 ;
  uint32 id ;
  int status ;
  int p[2] ;
  void *tmp ;
  int tmp___0 ;
  char b___1[10] ;
  int l___0 ;
  int tmp___1 ;
  __pid_t tmp___2 ;
  union __anonunion_51 __constr_expr_0 ;
  union __anonunion_52 __constr_expr_1 ;
  int tmp___3 ;
  int tmp___4 ;
  void *tmp___5 ;
  void *__cil_tmp26 ;
  void *__cil_tmp27 ;
  void *__cil_tmp28 ;
  void *__cil_tmp29 ;
  void *__cil_tmp30 ;
  void *__cil_tmp31 ;
  void *__cil_tmp32 ;
  void *__cil_tmp33 ;
  void *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;

  {
  {
#line 124
  read32b(f);
#line 125
  id = read32b(f);
#line 126
  fseek(f, -8L, 1);
  }
#line 128
  if (id != 1332176723U) {
    {
#line 129
    tmp = malloc((size_t )len);
#line 129
    pcm = (int8 *)tmp;
    }
#line 129
    if ((unsigned long )pcm == (unsigned long )((void *)0)) {
#line 130
      return ((char *)((void *)0));
    }
    {
#line 131
    fread((void */* __restrict  */)pcm, (size_t )1, (size_t )len, (FILE */* __restrict  */)f);
#line 132
    *newlen = len;
    }
#line 133
    return ((char *)pcm);
  }
  {
#line 136
  t = tmpfile();
  }
#line 136
  if ((unsigned long )t == (unsigned long )((void *)0)) {
#line 137
    return ((char *)((void *)0));
  }
  {
#line 139
  tmp___0 = pipe((int *)(p));
  }
#line 139
  if (tmp___0 < 0) {
#line 140
    return ((char *)((void *)0));
  }
  {
#line 142
  tmp___2 = fork();
  }
#line 142
  if (tmp___2 == 0) {
    {
#line 146
    close(p[1]);
#line 147
    dup2(p[0], 0);
#line 148
    tmp___1 = fileno(t);
#line 148
    dup2(tmp___1, 1);
#line 150
    snprintf((char */* __restrict  */)(b___1), (size_t )10, (char const   */* __restrict  */)"-b%d",
             res);
#line 151
    execlp("oggdec", "oggdec", "-Q", b___1, "-e0", "-R", "-s1", "-o-", "-", (void *)0);
    }
    {
#line 154
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 155
      l___0 = read(0, (void *)(buf___1), (size_t )1024);
      }
#line 154
      if (! (l___0 == 1024)) {
#line 154
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 158
    exit(1);
    }
  }
  {
#line 161
  close(p[0]);
  }
  {
#line 163
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 164
    if (len > 1024) {
#line 164
      l = 1024;
    } else {
#line 164
      l = len;
    }
    {
#line 165
    fread((void */* __restrict  */)(buf___1), (size_t )1, (size_t )l, (FILE */* __restrict  */)f);
#line 166
    write(p[1], (void const   *)(buf___1), (size_t )l);
#line 167
    len -= l;
    }
#line 163
    if (l > 0) {
#line 163
      if (! (len > 0)) {
#line 163
        goto while_break___0;
      }
    } else {
#line 163
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 170
  close(p[1]);
#line 171
  wait((union wait *)(& status));
#line 173
  __constr_expr_0.__in = status;
  }
#line 173
  if ((__constr_expr_0.__i & 127) == 0) {
#line 173
    __constr_expr_1.__in = status;
#line 173
    if ((__constr_expr_1.__i & 65280) >> 8 != 0) {
      {
#line 174
      fclose(t);
      }
#line 175
      return ((char *)((void *)0));
    }
  } else {
    {
#line 174
    fclose(t);
    }
#line 175
    return ((char *)((void *)0));
  }
  {
#line 178
  tmp___3 = fileno(t);
#line 178
  tmp___4 = fstat(tmp___3, & st);
  }
#line 178
  if (tmp___4 < 0) {
    {
#line 179
    fclose(t);
    }
#line 180
    return ((char *)((void *)0));
  }
  {
#line 183
  tmp___5 = malloc((size_t )st.st_size);
#line 183
  pcm = (int8 *)tmp___5;
  }
#line 183
  if ((unsigned long )pcm == (unsigned long )((void *)0)) {
    {
#line 184
    fclose(t);
    }
#line 185
    return ((char *)((void *)0));
  }
  {
#line 188
  pcm16 = (int16 *)pcm;
#line 189
  fseek(t, 0L, 0);
#line 190
  fread((void */* __restrict  */)pcm, (size_t )1, (size_t )st.st_size, (FILE */* __restrict  */)t);
#line 191
  fclose(t);
  }
#line 194
  if (res == 8) {
#line 195
    i___3 = (int )(st.st_size - 1L);
    {
#line 195
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 195
      if (! (i___3 > 0)) {
#line 195
        goto while_break___1;
      }
#line 196
      *(pcm + i___3) = (int8 )((int )*(pcm + i___3) - (int )*(pcm + (i___3 - 1)));
#line 195
      i___3 --;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 197
    *newlen = (int )st.st_size;
  } else {
#line 199
    i___3 = (int )(st.st_size / 2L - 1L);
    {
#line 199
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 199
      if (! (i___3 > 0)) {
#line 199
        goto while_break___2;
      }
#line 200
      *(pcm16 + i___3) = (int16 )((int )*(pcm16 + i___3) - (int )*(pcm16 + (i___3 - 1)));
#line 199
      i___3 --;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 201
    *newlen = (int )(st.st_size / 2L);
  }
#line 204
  return ((char *)pcm);
}
}
#line 207 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/misc/oxm.c"
int decrunch_oxm(FILE *f , FILE *fo ) 
{ 
  int i___3 ;
  int j ;
  int pos___0 ;
  int hlen ;
  int npat ;
  int len ;
  int plen ;
  int nins ;
  int nsmp ;
  uint32 ilen ;
  uint8 buf___1[1024] ;
  struct xm_instrument xi[256] ;
  char *pcm[256] ;
  int newlen ;
  uint32 tmp ;
  uint16 tmp___0 ;
  uint16 tmp___1 ;
  uint32 tmp___2 ;
  uint16 tmp___3 ;
  long tmp___4 ;
  uint16 tmp___5 ;
  int res ;
  void *__cil_tmp25 ;
  void *__cil_tmp26 ;
  int __cil_tmp27 ;
  void *__cil_tmp28 ;
  void *__cil_tmp29 ;
  void *__cil_tmp30 ;

  {
  {
#line 216
  newlen = 0;
#line 218
  fseek(f, 60L, 0);
#line 219
  tmp = read32l(f);
#line 219
  hlen = (int )tmp;
#line 220
  fseek(f, 6L, 1);
#line 221
  tmp___0 = read16l(f);
#line 221
  npat = (int )tmp___0;
#line 222
  tmp___1 = read16l(f);
#line 222
  nins = (int )tmp___1;
#line 224
  fseek(f, (long )(60 + hlen), 0);
#line 226
  i___3 = 0;
  }
  {
#line 226
  while (1) {
    while_continue: /* CIL Label */ ;
#line 226
    if (! (i___3 < npat)) {
#line 226
      goto while_break;
    }
    {
#line 227
    tmp___2 = read32l(f);
#line 227
    len = (int )tmp___2;
#line 228
    fseek(f, 3L, 1);
#line 229
    tmp___3 = read16l(f);
#line 229
    plen = (int )tmp___3;
#line 230
    fseek(f, (long )((len - 9) + plen), 1);
#line 226
    i___3 ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 233
  tmp___4 = ftell(f);
#line 233
  pos___0 = (int )tmp___4;
#line 234
  fseek(f, 0L, 0);
#line 235
  move_data(fo, f, pos___0);
#line 237
  i___3 = 0;
  }
  {
#line 237
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 237
    if (! (i___3 < nins)) {
#line 237
      goto while_break___0;
    }
    {
#line 238
    ilen = read32l(f);
    }
#line 239
    if (ilen > 1024U) {
#line 240
      return (-1);
    }
    {
#line 241
    fseek(f, -4L, 1);
#line 242
    fread((void */* __restrict  */)(buf___1), ilen, (size_t )1, (FILE */* __restrict  */)f);
#line 243
    buf___1[26] = (uint8 )0;
#line 244
    fwrite((void const   */* __restrict  */)(buf___1), ilen, (size_t )1, (FILE */* __restrict  */)fo);
#line 245
    tmp___5 = readmem16l(buf___1 + 27);
#line 245
    nsmp = (int )tmp___5;
    }
#line 247
    if (nsmp == 0) {
#line 248
      goto __Cont;
    }
#line 251
    j = 0;
    {
#line 251
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 251
      if (! (j < nsmp)) {
#line 251
        goto while_break___1;
      }
      {
#line 252
      xi[j].len = read32l(f);
#line 253
      fread((void */* __restrict  */)(xi[j].buf), (size_t )1, (size_t )36, (FILE */* __restrict  */)f);
#line 251
      j ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 257
    j = 0;
    {
#line 257
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 257
      if (! (j < nsmp)) {
#line 257
        goto while_break___2;
      }
#line 258
      if (xi[j].len > 0U) {
#line 259
        res = 8;
#line 260
        if ((int )xi[j].buf[10] & 16) {
#line 261
          res = 16;
        }
        {
#line 262
        pcm[j] = oggdec(f, (int )xi[j].len, res, & newlen);
#line 263
        xi[j].len = (uint32 )newlen;
        }
#line 265
        if ((unsigned long )pcm[j] == (unsigned long )((void *)0)) {
#line 266
          return (-1);
        }
      }
#line 257
      j ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 271
    j = 0;
    {
#line 271
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 271
      if (! (j < nsmp)) {
#line 271
        goto while_break___3;
      }
      {
#line 272
      write32l(fo, xi[j].len);
#line 273
      fwrite((void const   */* __restrict  */)(xi[j].buf), (size_t )1, (size_t )36,
             (FILE */* __restrict  */)fo);
#line 271
      j ++;
      }
    }
    while_break___3: /* CIL Label */ ;
    }
#line 277
    j = 0;
    {
#line 277
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 277
      if (! (j < nsmp)) {
#line 277
        goto while_break___4;
      }
#line 278
      if (xi[j].len > 0U) {
        {
#line 279
        fwrite((void const   */* __restrict  */)pcm[j], (size_t )1, xi[j].len, (FILE */* __restrict  */)fo);
#line 280
        free((void *)pcm[j]);
        }
      }
#line 277
      j ++;
    }
    while_break___4: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
#line 237
    i___3 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 285
  return (0);
}
}
#line 411 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *strerror(int __errnum ) ;
#line 43 "/usr/include/bits/errno.h"
extern  __attribute__((__nothrow__)) int *__errno_location(void)  __attribute__((__const__)) ;
#line 295 "src/include/common.h"
uint8 read8(FILE *f ) ;
#line 8 "src/include/readrle.h"
unsigned char *convert_rle(unsigned char *data_in , unsigned long in_len , unsigned long orig_len ) ;
#line 7 "src/include/readhuff.h"
unsigned char *convert_huff(unsigned char *data_in , unsigned long in_len , unsigned long orig_len ) ;
#line 23 "src/include/readlzw.h"
unsigned char *convert_lzw_dynamic(unsigned char *data_in , int max_bits , int use_rle ,
                                   unsigned long in_len , unsigned long orig_len ,
                                   int q ) ;
#line 40 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/misc/arcfs.c"
static int read_file_header(FILE *in , struct archived_file_header_tag *hdrp ) 
{ 
  int hlen ;
  int start ;
  int ver___0 ;
  int i___3 ;
  uint32 tmp ;
  uint32 tmp___0 ;
  uint32 tmp___1 ;
  uint32 tmp___2 ;
  int x ;
  uint8 tmp___3 ;
  uint32 tmp___4 ;
  uint32 tmp___5 ;
  uint32 tmp___6 ;
  uint32 tmp___7 ;

  {
  {
#line 45
  fseek(in, 8L, 1);
#line 46
  tmp = read32l(in);
#line 46
  hlen = (int )(tmp / 36U);
#line 47
  tmp___0 = read32l(in);
#line 47
  start = (int )tmp___0;
#line 48
  tmp___1 = read32l(in);
#line 48
  ver___0 = (int )tmp___1;
#line 52
  read32l(in);
#line 53
  tmp___2 = read32l(in);
#line 53
  ver___0 = (int )tmp___2;
#line 56
  fseek(in, 68L, 1);
#line 58
  i___3 = 0;
  }
  {
#line 58
  while (1) {
    while_continue: /* CIL Label */ ;
#line 58
    if (! (i___3 < hlen)) {
#line 58
      goto while_break;
    }
    {
#line 59
    tmp___3 = read8(in);
#line 59
    x = (int )tmp___3;
    }
#line 61
    if (x == 0) {
#line 62
      goto while_break;
    }
    {
#line 64
    hdrp->method = (unsigned char )(x & 127);
#line 65
    fread((void */* __restrict  */)(hdrp->name), (size_t )1, (size_t )11, (FILE */* __restrict  */)in);
#line 66
    hdrp->name[12] = (char)0;
#line 67
    tmp___4 = read32l(in);
#line 67
    hdrp->orig_size = (unsigned long )tmp___4;
#line 68
    read32l(in);
#line 69
    read32l(in);
#line 70
    tmp___5 = read32l(in);
#line 70
    x = (int )tmp___5;
#line 71
    tmp___6 = read32l(in);
#line 71
    hdrp->compressed_size = (unsigned long )tmp___6;
#line 72
    tmp___7 = read32l(in);
#line 72
    hdrp->offset = (unsigned long )tmp___7;
    }
#line 79
    if (x == 1) {
#line 80
      goto __Cont;
    }
#line 82
    if (hdrp->offset & 2147483648UL) {
#line 83
      goto __Cont;
    }
#line 85
    hdrp->crc = (unsigned int )(x >> 16);
#line 86
    hdrp->bits = (unsigned char )((x & 65280) >> 8);
#line 87
    hdrp->offset &= 2147483647UL;
#line 88
    hdrp->offset += (unsigned long )start;
#line 103
    goto while_break;
    __Cont: /* CIL Label */ 
#line 58
    i___3 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 106
  return (1);
}
}
#line 114 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/misc/arcfs.c"
static unsigned char *read_file_data(FILE *in , struct archived_file_header_tag *hdrp ) 
{ 
  unsigned char *data ;
  int siz ;
  void *tmp ;
  size_t tmp___0 ;
  char *__cil_tmp7 ;

  {
  {
#line 118
  siz = (int )hdrp->compressed_size;
#line 120
  tmp = malloc((size_t )siz);
#line 120
  data = (unsigned char *)tmp;
  }
#line 120
  if ((unsigned long )data == (unsigned long )((void *)0)) {
    {
#line 121
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"nomarch: out of memory!\n");
#line 121
    exit(1);
    }
  }
  {
#line 123
  fseek(in, (long )hdrp->offset, 0);
#line 124
  tmp___0 = fread((void */* __restrict  */)data, (size_t )1, (size_t )siz, (FILE */* __restrict  */)in);
  }
#line 124
  if (tmp___0 != (size_t )siz) {
    {
#line 125
    free((void *)data);
#line 126
    data = (unsigned char *)((void *)0);
    }
  }
#line 129
  return (data);
}
}
#line 132 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/misc/arcfs.c"
static int arcfs_extract(FILE *in , FILE *out ) 
{ 
  struct archived_file_header_tag hdr ;
  unsigned char *data ;
  unsigned char *orig_data ;
  int exitval ;
  int supported ;
  int tmp ;
  char *ptr ;
  int *tmp___0 ;
  char *tmp___1 ;
  size_t tmp___2 ;
  void *__cil_tmp13 ;
  void *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;

  {
  {
#line 137
  exitval = 0;
#line 140
  tmp = read_file_header(in, & hdr);
  }
#line 140
  if (! tmp) {
#line 141
    return (-1);
  }
#line 143
  if ((int )hdr.method == 0) {
#line 146
    return (-1);
  }
  {
#line 149
  data = read_file_data(in, & hdr);
  }
#line 149
  if ((unsigned long )data == (unsigned long )((void *)0)) {
    {
#line 150
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"nomarch: error reading data (hit EOF)\n");
    }
#line 151
    return (-1);
  }
#line 160
  orig_data = (unsigned char *)((void *)0);
#line 161
  supported = 0;
  {
#line 170
  if ((int )hdr.method == 2) {
#line 170
    goto case_2;
  }
#line 170
  if ((int )hdr.method == 1) {
#line 170
    goto case_2;
  }
#line 175
  if ((int )hdr.method == 3) {
#line 175
    goto case_3;
  }
#line 181
  if ((int )hdr.method == 4) {
#line 181
    goto case_4;
  }
#line 187
  if ((int )hdr.method == 5) {
#line 187
    goto case_5;
  }
#line 193
  if ((int )hdr.method == 6) {
#line 193
    goto case_6;
  }
#line 199
  if ((int )hdr.method == 7) {
#line 199
    goto case_7;
  }
#line 207
  if ((int )hdr.method == 8) {
#line 207
    goto case_8;
  }
#line 214
  if ((int )hdr.method == 9) {
#line 214
    goto case_9;
  }
#line 220
  if ((int )hdr.method == 127) {
#line 220
    goto case_127;
  }
#line 168
  goto switch_break;
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
#line 171
  supported = 1;
#line 172
  orig_data = data;
#line 173
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 176
  supported = 1;
#line 177
  orig_data = convert_rle(data, hdr.compressed_size, hdr.orig_size);
  }
#line 179
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 182
  supported = 1;
#line 183
  orig_data = convert_huff(data, hdr.compressed_size, hdr.orig_size);
  }
#line 185
  goto switch_break;
  case_5: /* CIL Label */ 
  {
#line 188
  supported = 1;
#line 189
  orig_data = convert_lzw_dynamic(data, 0, 0, hdr.compressed_size, hdr.orig_size,
                                  0);
  }
#line 191
  goto switch_break;
  case_6: /* CIL Label */ 
  {
#line 194
  supported = 1;
#line 195
  orig_data = convert_lzw_dynamic(data, 0, 1, hdr.compressed_size, hdr.orig_size,
                                  0);
  }
#line 197
  goto switch_break;
  case_7: /* CIL Label */ 
#line 205
  goto switch_break;
  case_8: /* CIL Label */ 
  {
#line 209
  supported = 1;
#line 210
  orig_data = convert_lzw_dynamic(data, (int )hdr.bits, 1, hdr.compressed_size, hdr.orig_size,
                                  0);
  }
#line 212
  goto switch_break;
  case_9: /* CIL Label */ 
  {
#line 215
  supported = 1;
#line 216
  orig_data = convert_lzw_dynamic(data, (int )hdr.bits, 0, hdr.compressed_size, hdr.orig_size,
                                  0);
  }
#line 218
  goto switch_break;
  case_127: /* CIL Label */ 
  {
#line 221
  supported = 1;
#line 222
  orig_data = convert_lzw_dynamic(data, (int )hdr.bits, 0, hdr.compressed_size, hdr.orig_size,
                                  0);
  }
#line 224
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 228
  if ((unsigned long )orig_data == (unsigned long )((void *)0)) {
    {
#line 229
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"error extracting file");
#line 230
    exitval = 1;
    }
  } else {
    {
#line 235
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 235
      ptr = strchr((char const   *)(hdr.name), '/');
      }
#line 235
      if (! ((unsigned long )ptr != (unsigned long )((void *)0))) {
#line 235
        goto while_break;
      }
#line 236
      *ptr = (char )'_';
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 238
    tmp___2 = fwrite((void const   */* __restrict  */)orig_data, (size_t )1, (size_t )hdr.orig_size,
                     (FILE */* __restrict  */)out);
    }
#line 238
    if ((unsigned long )tmp___2 != hdr.orig_size) {
      {
#line 239
      tmp___0 = __errno_location();
#line 239
      tmp___1 = strerror(*tmp___0);
#line 239
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"error, %s\n",
              tmp___1);
#line 240
      exitval = 1;
      }
    }
#line 243
    if ((unsigned long )orig_data != (unsigned long )data) {
      {
#line 244
      free((void *)orig_data);
      }
    }
  }
  {
#line 247
  free((void *)data);
  }
#line 249
  return (exitval);
}
}
#line 252 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/misc/arcfs.c"
int decrunch_arcfs(FILE *f , FILE *fo ) 
{ 
  int ret ;

  {
#line 256
  if ((unsigned long )fo == (unsigned long )((void *)0)) {
#line 257
    return (-1);
  }
  {
#line 259
  ret = arcfs_extract(f, fo);
  }
#line 260
  if (ret < 0) {
#line 261
    return (-1);
  }
#line 263
  return (0);
}
}
#line 675 "/usr/include/stdio.h"
extern int ungetc(int __c , FILE *__stream ) ;
#line 58 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/misc/unarc.c"
static int read_file_header___0(FILE *in , struct archived_file_header_tag___0 *hdrp ) 
{ 
  unsigned char buf___1[14] ;
  int bufsiz ;
  int method_high ;
  int c___0 ;
  int tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  void *__cil_tmp11 ;

  {
  {
#line 61
  bufsiz = (int )sizeof(buf___1);
#line 65
  hdrp->method = (unsigned char)255;
#line 66
  tmp = fgetc(in);
  }
#line 66
  if (tmp != 26) {
#line 67
    return (0);
  }
  {
#line 69
  c___0 = fgetc(in);
  }
#line 69
  if (c___0 == -1) {
#line 70
    return (0);
  }
#line 73
  method_high = c___0 >> 7;
#line 74
  hdrp->method = (unsigned char )(c___0 & 127);
#line 77
  if ((int )hdrp->method == 0) {
#line 78
    return (1);
  }
#line 81
  if ((int )hdrp->method == 1) {
#line 82
    bufsiz -= 4;
  }
  {
#line 84
  tmp___0 = fread((void */* __restrict  */)(hdrp->name), (size_t )1, (size_t )sizeof(hdrp->name),
                  (FILE */* __restrict  */)in);
  }
#line 84
  if ((unsigned long )tmp___0 != sizeof(hdrp->name)) {
#line 86
    return (0);
  } else {
    {
#line 84
    tmp___1 = fread((void */* __restrict  */)(buf___1), (size_t )1, (size_t )bufsiz,
                    (FILE */* __restrict  */)in);
    }
#line 84
    if (tmp___1 != (size_t )bufsiz) {
#line 86
      return (0);
    }
  }
#line 89
  hdrp->compressed_size = (unsigned long )((((int )buf___1[0] | ((int )buf___1[1] << 8)) | ((int )buf___1[2] << 16)) | ((int )buf___1[3] << 24));
#line 91
  hdrp->date = (unsigned int )((int )buf___1[4] | ((int )buf___1[5] << 8));
#line 92
  hdrp->time = (unsigned int )((int )buf___1[6] | ((int )buf___1[7] << 8));
#line 93
  hdrp->crc = (unsigned int )((int )buf___1[8] | ((int )buf___1[9] << 8));
#line 94
  hdrp->has_crc = 1;
#line 95
  if ((int )hdrp->method == 1) {
#line 96
    hdrp->orig_size = hdrp->compressed_size;
  } else {
#line 98
    hdrp->orig_size = (unsigned long )((((int )buf___1[10] | ((int )buf___1[11] << 8)) | ((int )buf___1[12] << 16)) | ((int )buf___1[13] << 24));
  }
#line 103
  hdrp->name[12] = (char)0;
#line 112
  if (method_high) {
    {
#line 113
    tmp___2 = fread((void */* __restrict  */)(buf___1), (size_t )1, (size_t )12, (FILE */* __restrict  */)in);
    }
#line 113
    if (tmp___2 != 12U) {
#line 114
      return (0);
    }
#line 121
    if ((int )hdrp->method == 2) {
#line 121
      if ((int )buf___1[3] == 255) {
#line 121
        if ((int )buf___1[2] == 253) {
#line 121
          if ((int )buf___1[1] == 220) {
#line 123
            hdrp->has_crc = 0;
          }
        }
      }
    }
  }
#line 126
  return (1);
}
}
#line 145 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/misc/unarc.c"
static int skip_sfx_header(FILE *in ) 
{ 
  int c___0 ;
  int f ;
  int got ;

  {
#line 147
  got = 0;
#line 149
  f = 0;
  {
#line 149
  while (1) {
    while_continue: /* CIL Label */ ;
#line 149
    if (! (f < 4)) {
#line 149
      goto while_break;
    }
    {
#line 150
    c___0 = fgetc(in);
    }
#line 150
    if (c___0 == -1) {
#line 151
      return (0);
    }
#line 152
    if (c___0 == 26) {
      {
#line 153
      got = 1;
#line 154
      ungetc(c___0, in);
      }
#line 155
      goto while_break;
    }
#line 149
    f ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 159
  return (got);
}
}
#line 167 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/misc/unarc.c"
static unsigned char *read_file_data___0(FILE *in , struct archived_file_header_tag___0 *hdrp ) 
{ 
  unsigned char *data ;
  int siz ;
  void *tmp ;
  size_t tmp___0 ;
  char *__cil_tmp7 ;

  {
  {
#line 171
  siz = (int )hdrp->compressed_size;
#line 173
  tmp = malloc((size_t )siz);
#line 173
  data = (unsigned char *)tmp;
  }
#line 173
  if ((unsigned long )data == (unsigned long )((void *)0)) {
    {
#line 174
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"nomarch: out of memory!\n");
#line 174
    exit(1);
    }
  }
  {
#line 176
  tmp___0 = fread((void */* __restrict  */)data, (size_t )1, (size_t )siz, (FILE */* __restrict  */)in);
  }
#line 176
  if (tmp___0 != (size_t )siz) {
    {
#line 177
    free((void *)data);
#line 178
    data = (unsigned char *)((void *)0);
    }
  }
#line 181
  return (data);
}
}
#line 185 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/misc/unarc.c"
static int skip_file_data(FILE *in , struct archived_file_header_tag___0 *hdrp ) 
{ 
  int siz ;
  int f ;
  int tmp ;

  {
#line 187
  siz = (int )hdrp->compressed_size;
#line 190
  f = 0;
  {
#line 190
  while (1) {
    while_continue: /* CIL Label */ ;
#line 190
    if (! (f < siz)) {
#line 190
      goto while_break;
    }
    {
#line 191
    tmp = fgetc(in);
    }
#line 191
    if (tmp == -1) {
#line 192
      return (0);
    }
#line 190
    f ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 194
  return (1);
}
}
#line 197 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/misc/unarc.c"
static int arc_extract(FILE *in , FILE *out ) 
{ 
  struct archived_file_header_tag___0 hdr ;
  unsigned char *data ;
  unsigned char *orig_data ;
  int supported ;
  int exitval ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char *ptr ;
  int *tmp___4 ;
  char *tmp___5 ;
  size_t tmp___6 ;
  void *__cil_tmp17 ;
  void *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;

  {
  {
#line 203
  exitval = 0;
#line 205
  tmp = skip_sfx_header(in);
  }
#line 205
  if (tmp) {
    {
#line 205
    tmp___0 = read_file_header___0(in, & hdr);
    }
#line 205
    if (! tmp___0) {
#line 206
      return (-1);
    }
  } else {
#line 206
    return (-1);
  }
  {
#line 209
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 209
    tmp___3 = strcmp((char const   *)(hdr.name), "From?");
    }
#line 209
    if (tmp___3) {
#line 209
      if (! ((int )hdr.name[0] == 33)) {
#line 209
        goto while_break;
      }
    }
    {
#line 210
    tmp___1 = skip_file_data(in, & hdr);
    }
#line 210
    if (! tmp___1) {
#line 211
      return (-1);
    }
    {
#line 212
    tmp___2 = read_file_header___0(in, & hdr);
    }
#line 212
    if (! tmp___2) {
#line 213
      return (-1);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 218
  if ((int )hdr.method == 0) {
#line 221
    return (-1);
  }
  {
#line 224
  data = read_file_data___0(in, & hdr);
  }
#line 224
  if ((unsigned long )data == (unsigned long )((void *)0)) {
    {
#line 225
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"nomarch: error reading data (hit EOF)\n");
    }
#line 226
    return (-1);
  }
#line 229
  orig_data = (unsigned char *)((void *)0);
#line 230
  supported = 0;
  {
#line 239
  if ((int )hdr.method == 2) {
#line 239
    goto case_2;
  }
#line 239
  if ((int )hdr.method == 1) {
#line 239
    goto case_2;
  }
#line 244
  if ((int )hdr.method == 3) {
#line 244
    goto case_3;
  }
#line 250
  if ((int )hdr.method == 4) {
#line 250
    goto case_4;
  }
#line 256
  if ((int )hdr.method == 5) {
#line 256
    goto case_5;
  }
#line 262
  if ((int )hdr.method == 6) {
#line 262
    goto case_6;
  }
#line 268
  if ((int )hdr.method == 7) {
#line 268
    goto case_7;
  }
#line 276
  if ((int )hdr.method == 8) {
#line 276
    goto case_8;
  }
#line 284
  if ((int )hdr.method == 9) {
#line 284
    goto case_9;
  }
#line 290
  if ((int )hdr.method == 127) {
#line 290
    goto case_127;
  }
#line 237
  goto switch_break;
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
#line 240
  supported = 1;
#line 241
  orig_data = data;
#line 242
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 245
  supported = 1;
#line 246
  orig_data = convert_rle(data, hdr.compressed_size, hdr.orig_size);
  }
#line 248
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 251
  supported = 1;
#line 252
  orig_data = convert_huff(data, hdr.compressed_size, hdr.orig_size);
  }
#line 254
  goto switch_break;
  case_5: /* CIL Label */ 
  {
#line 257
  supported = 1;
#line 258
  orig_data = convert_lzw_dynamic(data, 0, 0, hdr.compressed_size, hdr.orig_size,
                                  0);
  }
#line 260
  goto switch_break;
  case_6: /* CIL Label */ 
  {
#line 263
  supported = 1;
#line 264
  orig_data = convert_lzw_dynamic(data, 0, 1, hdr.compressed_size, hdr.orig_size,
                                  0);
  }
#line 266
  goto switch_break;
  case_7: /* CIL Label */ 
#line 274
  goto switch_break;
  case_8: /* CIL Label */ 
  {
#line 278
  supported = 1;
#line 279
  orig_data = convert_lzw_dynamic(data, 12, 1, hdr.compressed_size, hdr.orig_size,
                                  (int )(1L << 5));
  }
#line 282
  goto switch_break;
  case_9: /* CIL Label */ 
  {
#line 285
  supported = 1;
#line 286
  orig_data = convert_lzw_dynamic(data, 13, 0, hdr.compressed_size, hdr.orig_size,
                                  0);
  }
#line 288
  goto switch_break;
  case_127: /* CIL Label */ 
  {
#line 291
  supported = 1;
#line 292
  orig_data = convert_lzw_dynamic(data, 16, 0, hdr.compressed_size, hdr.orig_size,
                                  0);
  }
#line 294
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 301
  if ((unsigned long )orig_data == (unsigned long )((void *)0)) {
#line 302
    if (supported) {
      {
#line 303
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"error extracting file");
      }
    } else {
      {
#line 305
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"unsupported compression method %d\n",
              (int )hdr.method);
      }
    }
#line 307
    exitval = 1;
  } else {
    {
#line 312
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 312
      ptr = strchr((char const   *)(hdr.name), '/');
      }
#line 312
      if (! ((unsigned long )ptr != (unsigned long )((void *)0))) {
#line 312
        goto while_break___0;
      }
#line 313
      *ptr = (char )'_';
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 315
    tmp___6 = fwrite((void const   */* __restrict  */)orig_data, (size_t )1, (size_t )hdr.orig_size,
                     (FILE */* __restrict  */)out);
    }
#line 315
    if ((unsigned long )tmp___6 != hdr.orig_size) {
      {
#line 316
      tmp___4 = __errno_location();
#line 316
      tmp___5 = strerror(*tmp___4);
#line 316
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"error, %s\n",
              tmp___5);
#line 317
      exitval = 1;
      }
    }
#line 320
    if ((unsigned long )orig_data != (unsigned long )data) {
      {
#line 321
      free((void *)orig_data);
      }
    }
  }
  {
#line 324
  free((void *)data);
  }
#line 335
  return (exitval);
}
}
#line 338 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/misc/unarc.c"
int decrunch_arc(FILE *f , FILE *fo ) 
{ 
  int ret ;

  {
#line 342
  if ((unsigned long )fo == (unsigned long )((void *)0)) {
#line 343
    return (-1);
  }
  {
#line 345
  ret = arc_extract(f, fo);
  }
#line 346
  if (ret < 0) {
#line 347
    return (-1);
  }
#line 349
  return (0);
}
}
#line 7 "src/include/readrle.h"
void outputrle(int chr , void (*outputfunc)(int  ) ) ;
#line 29 "src/include/readlzw.h"
unsigned char *read_lzw_dynamic(FILE *f , uint8 *buf___1 , int max_bits , int use_rle ,
                                unsigned long in_len , unsigned long orig_len , int q ) ;
#line 39 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/misc/readlzw.c"
static int st_ptr[65536]  ;
#line 39 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/misc/readlzw.c"
static int st_chr[65536]  ;
#line 39 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/misc/readlzw.c"
static int st_last  ;
#line 40 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/misc/readlzw.c"
static int st_ptr1st[65536]  ;
#line 45 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/misc/readlzw.c"
static int dc_bitbox  ;
#line 45 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/misc/readlzw.c"
static int dc_bitsleft  ;
#line 47 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/misc/readlzw.c"
static unsigned char *data_in_point  ;
#line 47 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/misc/readlzw.c"
static unsigned char *data_in_max  ;
#line 48 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/misc/readlzw.c"
static unsigned char *data_out_point  ;
#line 48 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/misc/readlzw.c"
static unsigned char *data_out_max  ;
#line 50 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/misc/readlzw.c"
static int codeofs  ;
#line 51 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/misc/readlzw.c"
static int global_use_rle  ;
#line 51 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/misc/readlzw.c"
static int oldver  ;
#line 52 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/misc/readlzw.c"
static uint32 quirk  ;
#line 54 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/misc/readlzw.c"
static int maxstr  ;
#line 56 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/misc/readlzw.c"
static int st_oldverhashlinks[4096]  ;
#line 58 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/misc/readlzw.c"
static int nomarch_input_size  ;
#line 61
void code_resync(int old ) ;
#line 62
void inittable(int orgcsize ) ;
#line 63
int addstring(int oldcode , int chr ) ;
#line 64
int readcode(int *newcode , int numbits ) ;
#line 65
void outputstring(int code ) ;
#line 66
void outputchr(int chr ) ;
#line 67
int findfirstchr(int code ) ;
#line 70 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/misc/readlzw.c"
unsigned char *read_lzw_dynamic(FILE *f , uint8 *buf___1 , int max_bits , int use_rle ,
                                unsigned long in_len , unsigned long orig_len , int q ) 
{ 
  uint8 *buf2 ;
  uint8 *b___1 ;
  int pos___0 ;
  int size___0 ;
  void *tmp ;
  long tmp___0 ;
  char *__cil_tmp14 ;

  {
  {
#line 77
  tmp = malloc((size_t )in_len);
#line 77
  buf2 = (uint8 *)tmp;
  }
#line 77
  if ((unsigned long )buf2 == (unsigned long )((void *)0)) {
    {
#line 78
    perror("read_lzw_dynamic");
#line 78
    exit(1);
    }
  }
  {
#line 79
  tmp___0 = ftell(f);
#line 79
  pos___0 = (int )tmp___0;
#line 80
  fread((void */* __restrict  */)buf2, (size_t )1, (size_t )in_len, (FILE */* __restrict  */)f);
#line 81
  b___1 = convert_lzw_dynamic(buf2, max_bits, use_rle, in_len, orig_len, q);
#line 82
  memcpy((void */* __restrict  */)buf___1, (void const   */* __restrict  */)b___1,
         (size_t )orig_len);
  }
#line 83
  if ((long )q & (1L << 4)) {
#line 83
    size___0 = (int )((long )(nomarch_input_size + 3) & -4L);
  } else {
#line 83
    size___0 = nomarch_input_size;
  }
  {
#line 85
  fseek(f, (long )(pos___0 + size___0), 0);
#line 86
  free((void *)b___1);
#line 87
  free((void *)buf2);
  }
#line 89
  return (buf___1);
}
}
#line 92 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/misc/readlzw.c"
unsigned char *convert_lzw_dynamic(unsigned char *data_in , int max_bits , int use_rle ,
                                   unsigned long in_len , unsigned long orig_len ,
                                   int q ) 
{ 
  unsigned char *data_out ;
  int csize ;
  int orgcsize ;
  int newcode ;
  int oldcode ;
  int k ;
  int first ;
  int noadd ;
  void *tmp ;
  unsigned char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  char *__cil_tmp21 ;

  {
  {
#line 99
  k = 0;
#line 100
  first = 1;
#line 103
  quirk = (uint32 )q;
#line 104
  global_use_rle = use_rle;
#line 105
  maxstr = 1 << max_bits;
#line 107
  tmp = malloc((size_t )orig_len);
#line 107
  data_out = (unsigned char *)tmp;
  }
#line 107
  if ((unsigned long )data_out == (unsigned long )((void *)0)) {
    {
#line 108
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"nomarch: out of memory!\n");
#line 108
    exit(1);
    }
  }
  {
#line 110
  data_in_point = data_in;
#line 110
  data_in_max = data_in + in_len;
#line 111
  data_out_point = data_out;
#line 111
  data_out_max = data_out + orig_len;
#line 112
  dc_bitsleft = 0;
#line 112
  dc_bitbox = dc_bitsleft;
#line 113
  codeofs = 0;
#line 114
  outputrle(-1, (void (*)(int  ))((void *)0));
#line 116
  oldver = 0;
#line 117
  csize = 9;
  }
#line 118
  if (max_bits == 0) {
#line 119
    oldver = 1;
#line 119
    csize = 12;
#line 119
    maxstr = 4096;
  }
  {
#line 120
  orgcsize = csize;
#line 121
  inittable(orgcsize);
#line 123
  newcode = 0;
#line 123
  oldcode = newcode;
  }
#line 124
  if ((long )quirk & (1L << 5)) {
#line 125
    data_in_point ++;
  }
#line 127
  if (max_bits == 16) {
#line 128
    tmp___0 = data_in_point;
#line 128
    data_in_point ++;
#line 128
    maxstr = 1 << (int )*tmp___0;
  }
#line 130
  nomarch_input_size = 0;
  {
#line 132
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 135
    tmp___1 = readcode(& newcode, csize);
    }
#line 135
    if (! tmp___1) {
#line 137
      goto while_break;
    }
#line 141
    if ((long )quirk & 1L) {
#line 142
      if (newcode == 257) {
#line 144
        goto while_break;
      }
    }
#line 148
    noadd = 0;
#line 149
    if (first) {
#line 151
      k = newcode;
#line 151
      first = 0;
#line 152
      if (oldver) {
#line 152
        noadd = 1;
      }
    }
#line 155
    if (newcode == 256) {
#line 155
      if (! oldver) {
#line 161
        st_last = 255;
#line 163
        if ((long )quirk & (1L << 3)) {
#line 164
          st_last ++;
        }
        {
#line 169
        code_resync(csize);
#line 170
        csize = orgcsize;
#line 171
        tmp___2 = readcode(& newcode, csize);
        }
#line 171
        if (! tmp___2) {
#line 172
          goto while_break;
        }
      }
    }
#line 175
    if (! oldver) {
#line 175
      if (newcode <= st_last) {
        {
#line 178
        outputstring(newcode);
#line 179
        k = findfirstchr(newcode);
        }
      } else {
#line 175
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 175
    if (oldver) {
#line 175
      if (st_chr[newcode] != -1) {
        {
#line 178
        outputstring(newcode);
#line 179
        k = findfirstchr(newcode);
        }
      } else {
        {
#line 192
        outputstring(oldcode);
#line 193
        outputchr(k);
        }
      }
    } else {
      {
#line 192
      outputstring(oldcode);
#line 193
      outputchr(k);
      }
    }
#line 196
    if (st_last != maxstr - 1) {
#line 198
      if (! noadd) {
        {
#line 200
        tmp___3 = addstring(oldcode, k);
        }
#line 200
        if (tmp___3) {
#line 200
          tmp___4 = 0;
        } else {
#line 200
          tmp___4 = 1;
        }
#line 206
        if (st_last != maxstr - 1) {
#line 206
          if (st_last == (1 << csize) - 1) {
            {
#line 208
            csize ++;
#line 209
            code_resync(csize - 1);
            }
          }
        }
      }
    }
#line 214
    oldcode = newcode;
  }
  while_break: /* CIL Label */ ;
  }
#line 217
  if ((long )(~ quirk) & (1L << 1)) {
#line 219
    if ((unsigned long )data_in_point != (unsigned long )data_in_max) {
      {
#line 220
      free((void *)data_out);
      }
#line 221
      return ((unsigned char *)((void *)0));
    }
  }
#line 225
  return (data_out);
}
}
#line 235 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/misc/readlzw.c"
void code_resync(int old ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 239
  if ((long )quirk & (1L << 2)) {
#line 240
    return;
  }
  {
#line 242
  while (1) {
    while_continue: /* CIL Label */ ;
#line 242
    if (! codeofs) {
#line 242
      goto while_break;
    }
    {
#line 243
    tmp___0 = readcode(& tmp, old);
    }
#line 243
    if (! tmp___0) {
#line 244
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 245
  return;
}
}
#line 248 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/misc/readlzw.c"
void inittable(int orgcsize ) 
{ 
  int f ;
  int numcols ;

  {
#line 251
  numcols = 1 << (orgcsize - 1);
#line 253
  f = 0;
  {
#line 253
  while (1) {
    while_continue: /* CIL Label */ ;
#line 253
    if (! (f < 65536)) {
#line 253
      goto while_break;
    }
#line 255
    st_chr[f] = -1;
#line 256
    st_ptr[f] = -1;
#line 257
    st_ptr1st[f] = -1;
#line 253
    f ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 260
  f = 0;
  {
#line 260
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 260
    if (! (f < 4096)) {
#line 260
      goto while_break___0;
    }
#line 261
    st_oldverhashlinks[f] = -1;
#line 260
    f ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 264
  if (oldver) {
#line 266
    st_last = -1;
#line 267
    f = 0;
    {
#line 267
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 267
      if (! (f < 256)) {
#line 267
        goto while_break___1;
      }
      {
#line 268
      addstring(65535, f);
#line 267
      f ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
  } else {
#line 272
    f = 0;
    {
#line 272
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 272
      if (! (f < numcols)) {
#line 272
        goto while_break___2;
      }
#line 273
      st_chr[f] = f;
#line 272
      f ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 274
    st_last = numcols - 1;
#line 276
    if ((long )quirk & (1L << 3)) {
#line 277
      st_last ++;
    }
  }
#line 279
  return;
}
}
#line 283 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/misc/readlzw.c"
int oldver_getidx(int oldcode , int chr ) 
{ 
  int lasthash ;
  int hashval ;
  int a ;
  int f ;

  {
#line 296
  a = ((oldcode + chr) | 2048) & 65535;
#line 297
  hashval = (a * a >> 6) & 4095;
  {
#line 300
  while (1) {
    while_continue: /* CIL Label */ ;
#line 300
    if (st_chr[hashval] != -1) {
#line 300
      if (! (st_oldverhashlinks[hashval] != -1)) {
#line 300
        goto while_break;
      }
    } else {
#line 300
      goto while_break;
    }
#line 301
    hashval = st_oldverhashlinks[hashval];
  }
  while_break: /* CIL Label */ ;
  }
#line 304
  if (st_chr[hashval] == -1) {
#line 305
    return (hashval);
  }
#line 307
  lasthash = hashval;
#line 314
  hashval += 101;
#line 315
  hashval &= 4095;
#line 317
  if (st_chr[hashval] != -1) {
#line 319
    f = 0;
    {
#line 319
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 319
      if (! (f < maxstr)) {
#line 319
        goto while_break___0;
      }
#line 320
      if (st_chr[hashval] == -1) {
#line 321
        goto while_break___0;
      }
#line 319
      f ++;
#line 319
      hashval ++;
#line 319
      hashval &= 4095;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 322
    if (hashval == maxstr) {
#line 323
      return (-1);
    }
  }
#line 327
  st_oldverhashlinks[lasthash] = hashval;
#line 329
  return (hashval);
}
}
#line 334 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/misc/readlzw.c"
int addstring(int oldcode , int chr ) 
{ 
  int idx___0 ;

  {
#line 339
  st_last ++;
#line 340
  if (st_last & maxstr) {
#line 342
    st_last = maxstr - 1;
#line 343
    return (1);
  }
#line 346
  idx___0 = st_last;
#line 349
  if (oldver) {
    {
#line 352
    idx___0 = oldver_getidx(oldcode, chr);
    }
#line 352
    if (idx___0 == -1) {
#line 353
      return (0);
    }
  }
#line 356
  st_chr[idx___0] = chr;
#line 363
  if (oldcode >= maxstr) {
#line 363
    return (1);
  }
#line 364
  st_ptr[idx___0] = oldcode;
#line 366
  if (st_ptr[oldcode] == -1) {
#line 367
    st_ptr1st[idx___0] = oldcode;
  } else {
#line 369
    st_ptr1st[idx___0] = st_ptr1st[oldcode];
  }
#line 371
  return (1);
}
}
#line 376 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/misc/readlzw.c"
int readcode(int *newcode , int numbits ) 
{ 
  int bitsfilled ;
  int got ;
  unsigned char *tmp ;

  {
#line 380
  got = 0;
#line 380
  bitsfilled = got;
#line 381
  *newcode = 0;
  {
#line 383
  while (1) {
    while_continue: /* CIL Label */ ;
#line 383
    if (! (bitsfilled < numbits)) {
#line 383
      goto while_break;
    }
#line 385
    if (dc_bitsleft == 0) {
#line 387
      if ((unsigned long )data_in_point >= (unsigned long )data_in_max) {
#line 389
        return (0);
      }
#line 391
      tmp = data_in_point;
#line 391
      data_in_point ++;
#line 391
      dc_bitbox = (int )*tmp;
#line 392
      dc_bitsleft = 8;
#line 393
      nomarch_input_size ++;
    }
#line 395
    if (dc_bitsleft < numbits - bitsfilled) {
#line 396
      got = dc_bitsleft;
    } else {
#line 398
      got = numbits - bitsfilled;
    }
#line 400
    if (oldver) {
#line 402
      dc_bitbox &= 255;
#line 403
      dc_bitbox <<= got;
#line 404
      bitsfilled += got;
#line 405
      *newcode |= (dc_bitbox >> 8) << (numbits - bitsfilled);
#line 406
      dc_bitsleft -= got;
    } else {
#line 410
      *newcode |= (dc_bitbox & ((1 << got) - 1)) << bitsfilled;
#line 411
      dc_bitbox >>= got;
#line 412
      dc_bitsleft -= got;
#line 413
      bitsfilled += got;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 417
  if (*newcode < 0) {
#line 419
    return (0);
  } else
#line 417
  if (*newcode > maxstr - 1) {
#line 419
    return (0);
  }
#line 423
  codeofs ++;
#line 424
  codeofs &= 7;
#line 426
  return (1);
}
}
#line 432 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/misc/readlzw.c"
static int buf___0[65536]  ;
#line 430 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/misc/readlzw.c"
void outputstring(int code ) 
{ 
  int *ptr ;
  int *tmp ;

  {
#line 433
  ptr = buf___0;
  {
#line 435
  while (1) {
    while_continue: /* CIL Label */ ;
#line 435
    if (st_ptr[code] != -1) {
#line 435
      if (! ((unsigned long )ptr < (unsigned long )(buf___0 + maxstr))) {
#line 435
        goto while_break;
      }
    } else {
#line 435
      goto while_break;
    }
#line 437
    tmp = ptr;
#line 437
    ptr ++;
#line 437
    *tmp = st_chr[code];
#line 438
    code = st_ptr[code];
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 441
  outputchr(st_chr[code]);
  }
  {
#line 442
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 442
    if (! ((unsigned long )ptr > (unsigned long )(buf___0))) {
#line 442
      goto while_break___0;
    }
    {
#line 443
    ptr --;
#line 443
    outputchr(*ptr);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 444
  return;
}
}
#line 447 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/misc/readlzw.c"
static void rawoutput(int byte ) 
{ 
  unsigned char *tmp ;

  {
#line 450
  if ((unsigned long )data_out_point < (unsigned long )data_out_max) {
#line 451
    tmp = data_out_point;
#line 451
    data_out_point ++;
#line 451
    *tmp = (unsigned char )byte;
  }
#line 453
  return;
}
}
#line 456 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/misc/readlzw.c"
void outputchr(int chr ) 
{ 


  {
#line 458
  if (global_use_rle) {
    {
#line 459
    outputrle(chr, & rawoutput);
    }
  } else {
    {
#line 461
    rawoutput(chr);
    }
  }
#line 462
  return;
}
}
#line 465 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/misc/readlzw.c"
int findfirstchr(int code ) 
{ 


  {
#line 467
  if (st_ptr[code] != -1) {
#line 468
    code = st_ptr1st[code];
  }
#line 469
  return (st_chr[code]);
}
}
#line 32 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/misc/readhuff.c"
static int bitbox  ;
#line 32 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/misc/readhuff.c"
static int bitsleft  ;
#line 34 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/misc/readhuff.c"
static unsigned char *data_in_point___0  ;
#line 34 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/misc/readhuff.c"
static unsigned char *data_in_max___0  ;
#line 35 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/misc/readhuff.c"
static unsigned char *data_out_point___0  ;
#line 35 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/misc/readhuff.c"
static unsigned char *data_out_max___0  ;
#line 38 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/misc/readhuff.c"
static int rawinput(void) 
{ 
  unsigned char *tmp ;

  {
#line 40
  if ((unsigned long )data_in_point___0 < (unsigned long )data_in_max___0) {
#line 41
    tmp = data_in_point___0;
#line 41
    data_in_point___0 ++;
#line 41
    return ((int )*tmp);
  }
#line 42
  return (-1);
}
}
#line 45 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/misc/readhuff.c"
static void rawoutput___0(int byte ) 
{ 
  unsigned char *tmp ;

  {
#line 47
  if ((unsigned long )data_out_point___0 < (unsigned long )data_out_max___0) {
#line 48
    tmp = data_out_point___0;
#line 48
    data_out_point___0 ++;
#line 48
    *tmp = (unsigned char )byte;
  }
#line 49
  return;
}
}
#line 52 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/misc/readhuff.c"
static void bit_init(void) 
{ 


  {
#line 54
  bitbox = 0;
#line 54
  bitsleft = 0;
#line 55
  return;
}
}
#line 57 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/misc/readhuff.c"
static int bit_input(void) 
{ 
  int tmp ;

  {
#line 59
  if (bitsleft == 0) {
    {
#line 61
    bitbox = rawinput();
    }
#line 62
    if (bitbox == -1) {
#line 62
      return (-1);
    }
#line 63
    bitsleft = 8;
  }
#line 66
  bitsleft --;
#line 67
  if (bitbox & (1 << (7 - bitsleft))) {
#line 67
    tmp = 1;
  } else {
#line 67
    tmp = 0;
  }
#line 67
  return (tmp);
}
}
#line 71 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/misc/readhuff.c"
unsigned char *convert_huff(unsigned char *data_in , unsigned long in_len , unsigned long orig_len ) 
{ 
  unsigned char *data_out ;
  struct huff_node_tag *nodearr ;
  int nodes ;
  int f ;
  int b___1 ;
  void *tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;

  {
  {
#line 79
  tmp = malloc((size_t )orig_len);
#line 79
  data_out = (unsigned char *)tmp;
  }
#line 79
  if ((unsigned long )data_out == (unsigned long )((void *)0)) {
    {
#line 80
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"nomarch: out of memory!\n");
#line 80
    exit(1);
    }
  }
  {
#line 82
  data_in_point___0 = data_in;
#line 82
  data_in_max___0 = data_in + in_len;
#line 83
  data_out_point___0 = data_out;
#line 83
  data_out_max___0 = data_out + orig_len;
#line 85
  nodes = rawinput();
#line 85
  tmp___0 = rawinput();
#line 85
  nodes |= tmp___0 << 8;
  }
#line 87
  if (! nodes) {
    {
#line 89
    free((void *)data_out);
    }
#line 90
    return ((unsigned char *)((void *)0));
  }
  {
#line 93
  tmp___1 = malloc((size_t )(sizeof(struct huff_node_tag ) * (unsigned long )nodes));
#line 93
  nodearr = (struct huff_node_tag *)tmp___1;
  }
#line 93
  if ((unsigned long )nodearr == (unsigned long )((void *)0)) {
    {
#line 94
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"nomarch: out of memory!\n");
#line 94
    exit(1);
    }
  }
#line 101
  tmp___2 = 65279;
#line 101
  (nodearr + 0)->kids[1] = tmp___2;
#line 101
  (nodearr + 0)->kids[0] = tmp___2;
#line 103
  f = 0;
  {
#line 103
  while (1) {
    while_continue: /* CIL Label */ ;
#line 103
    if (! (f < nodes)) {
#line 103
      goto while_break;
    }
    {
#line 105
    (nodearr + f)->kids[0] = rawinput();
#line 105
    tmp___3 = rawinput();
#line 105
    (nodearr + f)->kids[0] |= tmp___3 << 8;
#line 106
    (nodearr + f)->kids[1] = rawinput();
#line 106
    tmp___4 = rawinput();
#line 106
    (nodearr + f)->kids[1] |= tmp___4 << 8;
#line 103
    f ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 112
  bit_init();
#line 113
  outputrle(-1, (void (*)(int  ))((void *)0));
  }
  {
#line 115
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 117
    f = 0;
    {
#line 118
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 118
      if (! ((f & 32768) == 0)) {
#line 118
        goto while_break___1;
      }
#line 120
      if (f >= nodes) {
        {
#line 123
        free((void *)nodearr);
#line 124
        free((void *)data_out);
        }
#line 125
        return ((unsigned char *)((void *)0));
      }
      {
#line 132
      b___1 = bit_input();
      }
#line 132
      if (b___1 == -1) {
#line 134
        f = 65279;
#line 135
        goto while_break___1;
      }
#line 138
      f = (nodearr + f)->kids[b___1];
    }
    while_break___1: /* CIL Label */ ;
    }
#line 141
    f ^= 65535;
#line 142
    if (f != 256) {
      {
#line 143
      outputrle(f, & rawoutput___0);
      }
    }
#line 115
    if (! (f != 256)) {
#line 115
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 147
  free((void *)nodearr);
  }
#line 149
  return (data_out);
}
}
#line 18 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/misc/readrle.c"
static unsigned char *data_in_point___1  ;
#line 18 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/misc/readrle.c"
static unsigned char *data_in_max___1  ;
#line 19 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/misc/readrle.c"
static unsigned char *data_out_point___1  ;
#line 19 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/misc/readrle.c"
static unsigned char *data_out_max___1  ;
#line 22 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/misc/readrle.c"
static void rawoutput___1(int byte ) 
{ 
  unsigned char *tmp ;

  {
#line 24
  if ((unsigned long )data_out_point___1 < (unsigned long )data_out_max___1) {
#line 25
    tmp = data_out_point___1;
#line 25
    data_out_point___1 ++;
#line 25
    *tmp = (unsigned char )byte;
  }
#line 26
  return;
}
}
#line 32 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/misc/readrle.c"
static int lastchr  =    0;
#line 32 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/misc/readrle.c"
static int repeating  =    0;
#line 30 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/misc/readrle.c"
void outputrle(int chr , void (*outputfunc)(int  ) ) 
{ 
  int f ;

  {
#line 35
  if (chr == -1) {
#line 37
    repeating = 0;
#line 37
    lastchr = repeating;
#line 38
    return;
  }
#line 41
  if (repeating) {
#line 43
    if (chr == 0) {
      {
#line 44
      (*outputfunc)(144);
      }
    } else {
#line 46
      f = 1;
      {
#line 46
      while (1) {
        while_continue: /* CIL Label */ ;
#line 46
        if (! (f < chr)) {
#line 46
          goto while_break;
        }
        {
#line 47
        (*outputfunc)(lastchr);
#line 46
        f ++;
        }
      }
      while_break: /* CIL Label */ ;
      }
    }
#line 48
    repeating = 0;
  } else
#line 52
  if (chr == 144) {
#line 53
    repeating = 1;
  } else {
    {
#line 56
    (*outputfunc)(chr);
#line 57
    lastchr = chr;
    }
  }
#line 60
  return;
}
}
#line 63 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/misc/readrle.c"
unsigned char *convert_rle(unsigned char *data_in , unsigned long in_len , unsigned long orig_len ) 
{ 
  unsigned char *data_out ;
  void *tmp ;
  unsigned char *tmp___0 ;
  char *__cil_tmp7 ;

  {
  {
#line 69
  tmp = malloc((size_t )orig_len);
#line 69
  data_out = (unsigned char *)tmp;
  }
#line 69
  if ((unsigned long )data_out == (unsigned long )((void *)0)) {
    {
#line 70
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"nomarch: out of memory!\n");
#line 70
    exit(1);
    }
  }
  {
#line 72
  data_in_point___1 = data_in;
#line 72
  data_in_max___1 = data_in + in_len;
#line 73
  data_out_point___1 = data_out;
#line 73
  data_out_max___1 = data_out + orig_len;
#line 74
  outputrle(-1, (void (*)(int  ))((void *)0));
  }
  {
#line 76
  while (1) {
    while_continue: /* CIL Label */ ;
#line 76
    if (! ((unsigned long )data_in_point___1 < (unsigned long )data_in_max___1)) {
#line 76
      goto while_break;
    }
    {
#line 77
    tmp___0 = data_in_point___1;
#line 77
    data_in_point___1 ++;
#line 77
    outputrle((int )*tmp___0, & rawoutput___1);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 79
  return (data_out);
}
}
#line 77 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/misc/mmcmp.c"
uint32 GetBits(struct MMCMPBITBUFFER *bb , uint32 nBits ) 
{ 
  uint32 d ;
  uint8 *tmp ;
  int tmp___0 ;

  {
#line 81
  if (! nBits) {
#line 81
    return ((uint32 )0);
  }
  {
#line 82
  while (1) {
    while_continue: /* CIL Label */ ;
#line 82
    if (! (bb->bitcount < 24U)) {
#line 82
      goto while_break;
    }
#line 84
    if ((unsigned long )bb->pSrc < (unsigned long )bb->pEnd) {
#line 84
      tmp = bb->pSrc;
#line 84
      (bb->pSrc) ++;
#line 84
      tmp___0 = (int )*tmp;
    } else {
#line 84
      tmp___0 = 0;
    }
#line 84
    bb->bitbuffer |= (unsigned int )(tmp___0 << bb->bitcount);
#line 85
    bb->bitcount += 8U;
  }
  while_break: /* CIL Label */ ;
  }
#line 87
  d = bb->bitbuffer & (unsigned int )((1 << nBits) - 1);
#line 88
  bb->bitbuffer >>= nBits;
#line 89
  bb->bitcount -= nBits;
#line 90
  return (d);
}
}
#line 99 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/misc/mmcmp.c"
uint32 const   MMCMP8BitCommands[8]  = 
#line 99
  {      (uint32 const   )1,      (uint32 const   )3,      (uint32 const   )7,      (uint32 const   )15, 
        (uint32 const   )30,      (uint32 const   )60,      (uint32 const   )120,      (uint32 const   )248};
#line 104 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/misc/mmcmp.c"
uint32 const   MMCMP8BitFetch[8]  = 
#line 104
  {      (uint32 const   )3,      (uint32 const   )3,      (uint32 const   )3,      (uint32 const   )3, 
        (uint32 const   )2,      (uint32 const   )1,      (uint32 const   )0,      (uint32 const   )0};
#line 109 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/misc/mmcmp.c"
uint32 const   MMCMP16BitCommands[16]  = 
#line 109
  {      (uint32 const   )1,      (uint32 const   )3,      (uint32 const   )7,      (uint32 const   )15, 
        (uint32 const   )30,      (uint32 const   )60,      (uint32 const   )120,      (uint32 const   )240, 
        (uint32 const   )496,      (uint32 const   )1008,      (uint32 const   )2032,      (uint32 const   )4080, 
        (uint32 const   )8176,      (uint32 const   )16368,      (uint32 const   )32752,      (uint32 const   )65520};
#line 115 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/misc/mmcmp.c"
uint32 const   MMCMP16BitFetch[16]  = 
#line 115
  {      (uint32 const   )4,      (uint32 const   )4,      (uint32 const   )4,      (uint32 const   )4, 
        (uint32 const   )3,      (uint32 const   )2,      (uint32 const   )1,      (uint32 const   )0, 
        (uint32 const   )0,      (uint32 const   )0,      (uint32 const   )0,      (uint32 const   )0, 
        (uint32 const   )0,      (uint32 const   )0,      (uint32 const   )0,      (uint32 const   )0};
#line 123 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/misc/mmcmp.c"
static int mmcmp_unpack(uint8 **ppMemFile , uint32 *pdwMemLength ) 
{ 
  uint32 dwMemLength ;
  uint8 *lpMemFile ;
  uint8 *pBuffer ;
  LPMMCMPFILEHEADER pmfh ;
  LPMMCMPHEADER pmmh ;
  uint32 *pblk_table ;
  uint32 dwFileSize ;
  uint32 nBlock ;
  uint32 i___3 ;
  void *tmp ;
  uint32 dwMemPos ;
  LPMMCMPBLOCK pblk ;
  LPMMCMPSUBBLOCK psubblk ;
  MMCMPBITBUFFER bb ;
  uint16 *pDest ;
  uint32 dwSize ;
  uint32 dwPos ;
  uint32 numbits ;
  uint32 subblk ;
  uint32 oldval ;
  uint32 newval ;
  uint32 d ;
  uint32 tmp___0 ;
  uint32 nFetch ;
  uint32 newbits ;
  uint32 tmp___1 ;
  uint32 tmp___2 ;
  uint32 tmp___3 ;
  MMCMPBITBUFFER bb___0 ;
  uint8 *pDest___0 ;
  uint32 dwSize___0 ;
  uint32 dwPos___0 ;
  uint32 numbits___0 ;
  uint32 subblk___0 ;
  uint32 oldval___0 ;
  uint8 *ptable ;
  uint32 newval___0 ;
  uint32 d___0 ;
  uint32 tmp___4 ;
  uint32 nFetch___0 ;
  uint32 newbits___0 ;
  uint32 tmp___5 ;
  uint32 tmp___6 ;
  int n___0 ;
  uint32 tmp___7 ;
  void *__cil_tmp48 ;
  void *__cil_tmp49 ;

  {
#line 126
  dwMemLength = *pdwMemLength;
#line 127
  lpMemFile = *ppMemFile;
#line 129
  pmfh = (LPMMCMPFILEHEADER )lpMemFile;
#line 130
  pmmh = (LPMMCMPHEADER )(lpMemFile + 10);
#line 135
  if (dwMemLength < 256U) {
#line 137
    return (-1);
  } else
#line 135
  if (! pmfh) {
#line 137
    return (-1);
  } else
#line 135
  if (pmfh->id_ziRC != 1129474426U) {
#line 137
    return (-1);
  } else
#line 135
  if (pmfh->id_ONia != 1634291279U) {
#line 137
    return (-1);
  } else
#line 135
  if ((int )pmfh->hdrsize < 14) {
#line 137
    return (-1);
  } else
#line 135
  if (! pmmh->nblocks) {
#line 137
    return (-1);
  } else
#line 135
  if (pmmh->filesize < 16U) {
#line 137
    return (-1);
  } else
#line 135
  if (pmmh->filesize > 134217728U) {
#line 137
    return (-1);
  } else
#line 135
  if (pmmh->blktable >= dwMemLength) {
#line 137
    return (-1);
  } else
#line 135
  if (pmmh->blktable + (uint32 )(4 * (int )pmmh->nblocks) > dwMemLength) {
#line 137
    return (-1);
  }
  {
#line 138
  dwFileSize = pmmh->filesize;
#line 142
  tmp = calloc((size_t )1, (dwFileSize + 31U) & 4294967280U);
#line 142
  pBuffer = (uint8 *)tmp;
  }
#line 142
  if ((unsigned long )pBuffer == (unsigned long )((void *)0)) {
#line 142
    return (-1);
  }
#line 143
  pblk_table = (uint32 *)(lpMemFile + pmmh->blktable);
#line 144
  nBlock = (uint32 )0;
  {
#line 144
  while (1) {
    while_continue: /* CIL Label */ ;
#line 144
    if (! (nBlock < (uint32 )pmmh->nblocks)) {
#line 144
      goto while_break;
    }
#line 146
    dwMemPos = *(pblk_table + nBlock);
#line 147
    pblk = (LPMMCMPBLOCK )(lpMemFile + dwMemPos);
#line 148
    psubblk = (LPMMCMPSUBBLOCK )((lpMemFile + dwMemPos) + 20);
#line 150
    if (dwMemPos + 20U >= dwMemLength) {
#line 150
      goto while_break;
    } else
#line 150
    if ((dwMemPos + 20U) + (uint32 )((int )pblk->sub_blk * 8) >= dwMemLength) {
#line 150
      goto while_break;
    }
#line 151
    dwMemPos += (uint32 )(20 + (int )pblk->sub_blk * 8);
#line 158
    if (! ((int )pblk->flags & 1)) {
#line 160
      i___3 = (uint32 )0;
      {
#line 160
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 160
        if (! (i___3 < (uint32 )pblk->sub_blk)) {
#line 160
          goto while_break___0;
        }
#line 162
        if (psubblk->unpk_pos > dwFileSize) {
#line 162
          goto while_break___0;
        } else
#line 162
        if (psubblk->unpk_pos + psubblk->unpk_size > dwFileSize) {
#line 162
          goto while_break___0;
        }
        {
#line 166
        memcpy((void */* __restrict  */)(pBuffer + psubblk->unpk_pos), (void const   */* __restrict  */)(lpMemFile + dwMemPos),
               psubblk->unpk_size);
#line 167
        dwMemPos += psubblk->unpk_size;
#line 168
        psubblk ++;
#line 160
        i___3 ++;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
    } else
#line 172
    if ((int )pblk->flags & 4) {
#line 175
      pDest = (uint16 *)(pBuffer + psubblk->unpk_pos);
#line 176
      dwSize = psubblk->unpk_size >> 1;
#line 177
      dwPos = (uint32 )0;
#line 178
      numbits = (uint32 )pblk->num_bits;
#line 179
      subblk = (uint32 )0;
#line 179
      oldval = (uint32 )0;
#line 187
      bb.bitcount = (uint32 )0;
#line 188
      bb.bitbuffer = (uint32 )0;
#line 189
      bb.pSrc = (lpMemFile + dwMemPos) + (int )pblk->tt_entries;
#line 190
      bb.pEnd = (lpMemFile + dwMemPos) + pblk->pk_size;
      {
#line 191
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 191
        if (! (subblk < (uint32 )pblk->sub_blk)) {
#line 191
          goto while_break___1;
        }
        {
#line 193
        newval = (uint32 )65536;
#line 194
        tmp___0 = GetBits(& bb, numbits + 1U);
#line 194
        d = tmp___0;
        }
#line 196
        if (d >= (uint32 )MMCMP16BitCommands[numbits]) {
          {
#line 198
          nFetch = (uint32 )MMCMP16BitFetch[numbits];
#line 199
          tmp___1 = GetBits(& bb, nFetch);
#line 199
          newbits = tmp___1 + ((d - (uint32 )MMCMP16BitCommands[numbits]) << nFetch);
          }
#line 200
          if (newbits != numbits) {
#line 202
            numbits = newbits & 15U;
          } else {
            {
#line 205
            d = GetBits(& bb, (uint32 )4);
            }
#line 205
            if (d == 15U) {
              {
#line 207
              tmp___2 = GetBits(& bb, (uint32 )1);
              }
#line 207
              if (tmp___2) {
#line 207
                goto while_break___1;
              }
#line 208
              newval = (uint32 )65535;
            } else {
#line 211
              newval = 65520U + d;
            }
          }
        } else {
#line 216
          newval = d;
        }
#line 218
        if (newval < 65536U) {
#line 220
          if (newval & 1U) {
#line 220
            newval = (uint32 )(- ((int32 )((newval + 1U) >> 1)));
          } else {
#line 220
            newval >>= 1;
          }
#line 221
          if ((int )pblk->flags & 2) {
#line 223
            newval += oldval;
#line 224
            oldval = newval;
          } else
#line 226
          if (! ((int )pblk->flags & 512)) {
#line 228
            newval ^= 32768U;
          }
#line 230
          tmp___3 = dwPos;
#line 230
          dwPos ++;
#line 230
          *(pDest + tmp___3) = (uint16 )newval;
        }
#line 232
        if (dwPos >= dwSize) {
#line 234
          subblk ++;
#line 235
          dwPos = (uint32 )0;
#line 236
          dwSize = (psubblk + subblk)->unpk_size >> 1;
#line 237
          pDest = (uint16 *)(pBuffer + (psubblk + subblk)->unpk_pos);
        }
      }
      while_break___1: /* CIL Label */ ;
      }
    } else {
#line 244
      pDest___0 = pBuffer + psubblk->unpk_pos;
#line 245
      dwSize___0 = psubblk->unpk_size;
#line 246
      dwPos___0 = (uint32 )0;
#line 247
      numbits___0 = (uint32 )pblk->num_bits;
#line 248
      subblk___0 = (uint32 )0;
#line 248
      oldval___0 = (uint32 )0;
#line 249
      ptable = lpMemFile + dwMemPos;
#line 251
      bb___0.bitcount = (uint32 )0;
#line 252
      bb___0.bitbuffer = (uint32 )0;
#line 253
      bb___0.pSrc = (lpMemFile + dwMemPos) + (int )pblk->tt_entries;
#line 254
      bb___0.pEnd = (lpMemFile + dwMemPos) + pblk->pk_size;
      {
#line 255
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 255
        if (! (subblk___0 < (uint32 )pblk->sub_blk)) {
#line 255
          goto while_break___2;
        }
        {
#line 257
        newval___0 = (uint32 )256;
#line 258
        tmp___4 = GetBits(& bb___0, numbits___0 + 1U);
#line 258
        d___0 = tmp___4;
        }
#line 260
        if (d___0 >= (uint32 )MMCMP8BitCommands[numbits___0]) {
          {
#line 262
          nFetch___0 = (uint32 )MMCMP8BitFetch[numbits___0];
#line 263
          tmp___5 = GetBits(& bb___0, nFetch___0);
#line 263
          newbits___0 = tmp___5 + ((d___0 - (uint32 )MMCMP8BitCommands[numbits___0]) << nFetch___0);
          }
#line 264
          if (newbits___0 != numbits___0) {
#line 266
            numbits___0 = newbits___0 & 7U;
          } else {
            {
#line 269
            d___0 = GetBits(& bb___0, (uint32 )3);
            }
#line 269
            if (d___0 == 7U) {
              {
#line 271
              tmp___6 = GetBits(& bb___0, (uint32 )1);
              }
#line 271
              if (tmp___6) {
#line 271
                goto while_break___2;
              }
#line 272
              newval___0 = (uint32 )255;
            } else {
#line 275
              newval___0 = 248U + d___0;
            }
          }
        } else {
#line 280
          newval___0 = d___0;
        }
#line 282
        if (newval___0 < 256U) {
#line 284
          n___0 = (int )*(ptable + newval___0);
#line 285
          if ((int )pblk->flags & 2) {
#line 287
            n___0 = (int )((uint32 )n___0 + oldval___0);
#line 288
            oldval___0 = (uint32 )n___0;
          }
#line 290
          tmp___7 = dwPos___0;
#line 290
          dwPos___0 ++;
#line 290
          *(pDest___0 + tmp___7) = (uint8 )n___0;
        }
#line 292
        if (dwPos___0 >= dwSize___0) {
#line 294
          subblk___0 ++;
#line 295
          dwPos___0 = (uint32 )0;
#line 296
          dwSize___0 = (psubblk + subblk___0)->unpk_size;
#line 297
          pDest___0 = pBuffer + (psubblk + subblk___0)->unpk_pos;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
    }
#line 144
    nBlock ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 302
  *ppMemFile = pBuffer;
#line 303
  *pdwMemLength = dwFileSize;
#line 304
  return (0);
}
}
#line 308 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/misc/mmcmp.c"
int decrunch_mmcmp(FILE *f , FILE *fo ) 
{ 
  struct stat st ;
  uint8 *b___1 ;
  uint8 *buf___1 ;
  uint32 s ;
  int tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  void *__cil_tmp10 ;
  void *__cil_tmp11 ;
  void *__cil_tmp12 ;
  void *__cil_tmp13 ;

  {
#line 314
  if ((unsigned long )fo == (unsigned long )((void *)0)) {
#line 315
    return (-1);
  }
  {
#line 317
  tmp = fileno(f);
#line 317
  tmp___0 = fstat(tmp, & st);
  }
#line 317
  if (tmp___0) {
#line 318
    return (-1);
  }
  {
#line 320
  s = (uint32 )st.st_size;
#line 320
  tmp___1 = malloc(s);
#line 320
  buf___1 = (uint8 *)tmp___1;
#line 320
  b___1 = buf___1;
#line 321
  fread((void */* __restrict  */)buf___1, (size_t )1, s, (FILE */* __restrict  */)f);
#line 322
  mmcmp_unpack(& buf___1, & s);
#line 323
  fwrite((void const   */* __restrict  */)buf___1, (size_t )1, s, (FILE */* __restrict  */)fo);
#line 324
  free((void *)b___1);
#line 325
  free((void *)buf___1);
  }
#line 327
  return (0);
}
}
#line 31 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/misc/unsqsh.c"
static int volatile   xpkerrno  ;
#line 33
static int unpack(uint8 *src , uint8 *dst , int len ) ;
#line 35 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/misc/unsqsh.c"
static int unsqsh(FILE *in , FILE *out ) 
{ 
  unsigned char *src ;
  unsigned char *dst ;
  int srclen ;
  int dstlen ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  void *tmp___13 ;
  void *tmp___14 ;
  size_t tmp___15 ;
  int tmp___16 ;
  size_t tmp___17 ;

  {
  {
#line 42
  tmp = fgetc(in);
  }
#line 42
  if (88 != tmp) {
#line 46
    return (-1);
  } else {
    {
#line 42
    tmp___0 = fgetc(in);
    }
#line 42
    if (80 != tmp___0) {
#line 46
      return (-1);
    } else {
      {
#line 42
      tmp___1 = fgetc(in);
      }
#line 42
      if (75 != tmp___1) {
#line 46
        return (-1);
      } else {
        {
#line 42
        tmp___2 = fgetc(in);
        }
#line 42
        if (70 != tmp___2) {
#line 46
          return (-1);
        }
      }
    }
  }
  {
#line 49
  srclen = fgetc(in);
#line 49
  srclen <<= 8;
#line 50
  tmp___3 = fgetc(in);
#line 50
  srclen |= tmp___3;
#line 50
  srclen <<= 8;
#line 51
  tmp___4 = fgetc(in);
#line 51
  srclen |= tmp___4;
#line 51
  srclen <<= 8;
#line 52
  tmp___5 = fgetc(in);
#line 52
  srclen |= tmp___5;
#line 54
  tmp___6 = fgetc(in);
  }
#line 54
  if (83 != tmp___6) {
#line 58
    return (-1);
  } else {
    {
#line 54
    tmp___7 = fgetc(in);
    }
#line 54
    if (81 != tmp___7) {
#line 58
      return (-1);
    } else {
      {
#line 54
      tmp___8 = fgetc(in);
      }
#line 54
      if (83 != tmp___8) {
#line 58
        return (-1);
      } else {
        {
#line 54
        tmp___9 = fgetc(in);
        }
#line 54
        if (72 != tmp___9) {
#line 58
          return (-1);
        }
      }
    }
  }
  {
#line 61
  dstlen = fgetc(in);
#line 61
  dstlen <<= 8;
#line 62
  tmp___10 = fgetc(in);
#line 62
  dstlen |= tmp___10;
#line 62
  dstlen <<= 8;
#line 63
  tmp___11 = fgetc(in);
#line 63
  dstlen |= tmp___11;
#line 63
  dstlen <<= 8;
#line 64
  tmp___12 = fgetc(in);
#line 64
  dstlen |= tmp___12;
#line 66
  tmp___13 = malloc((size_t )(srclen + 3));
#line 66
  src = (unsigned char *)tmp___13;
#line 67
  tmp___14 = malloc((size_t )(dstlen + 100));
#line 67
  dst = (unsigned char *)tmp___14;
  }
#line 68
  if ((unsigned long )src == (unsigned long )((void *)0)) {
#line 69
    return (-1);
  } else
#line 68
  if ((unsigned long )dst == (unsigned long )((void *)0)) {
#line 69
    return (-1);
  }
  {
#line 71
  tmp___15 = fread((void */* __restrict  */)src, (size_t )(srclen - 8), (size_t )1,
                   (FILE */* __restrict  */)in);
  }
#line 71
  if (1U != tmp___15) {
#line 72
    return (-1);
  }
  {
#line 74
  tmp___16 = unpack(src, dst, dstlen);
  }
#line 74
  if (tmp___16 != dstlen) {
#line 75
    return (-1);
  }
  {
#line 77
  tmp___17 = fwrite((void const   */* __restrict  */)dst, (size_t )dstlen, (size_t )1,
                    (FILE */* __restrict  */)out);
  }
#line 77
  if (1U != tmp___17) {
#line 78
    return (-1);
  }
  {
#line 80
  free((void *)src);
#line 81
  free((void *)dst);
  }
#line 83
  return (0);
}
}
#line 86 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/misc/unsqsh.c"
static uint16 xchecksum(uint32 *ptr , uint32 count ) 
{ 
  register uint32 sum___0 ;
  uint32 *tmp ;
  uint32 tmp___0 ;

  {
#line 88
  sum___0 = (uint32 )0;
  {
#line 90
  while (1) {
    while_continue: /* CIL Label */ ;
#line 90
    tmp___0 = count;
#line 90
    count --;
#line 90
    if (! (tmp___0 > 0U)) {
#line 90
      goto while_break;
    }
#line 91
    tmp = ptr;
#line 91
    ptr ++;
#line 91
    sum___0 ^= *tmp;
  }
  while_break: /* CIL Label */ ;
  }
#line 94
  return ((uint16 )(sum___0 ^ (sum___0 >> 16)));
}
}
#line 97 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/misc/unsqsh.c"
static int bfextu(uint8 *p , int bo , int bc ) 
{ 
  int r ;
  uint8 *tmp ;
  uint8 *tmp___0 ;

  {
#line 101
  p += bo / 8;
#line 102
  tmp = p;
#line 102
  p ++;
#line 102
  r = (int )*tmp;
#line 103
  r <<= 8;
#line 104
  tmp___0 = p;
#line 104
  p ++;
#line 104
  r |= (int )*tmp___0;
#line 105
  r <<= 8;
#line 106
  r |= (int )*p;
#line 107
  r <<= bo % 8;
#line 108
  r &= 16777215;
#line 109
  r >>= 24 - bc;
#line 111
  return (r);
}
}
#line 114 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/misc/unsqsh.c"
static int bfexts(uint8 *p , int bo , int bc ) 
{ 
  int r ;
  uint8 *tmp ;
  uint8 *tmp___0 ;

  {
#line 118
  p += bo / 8;
#line 119
  tmp = p;
#line 119
  p ++;
#line 119
  r = (int )*tmp;
#line 120
  r <<= 8;
#line 121
  tmp___0 = p;
#line 121
  p ++;
#line 121
  r |= (int )*tmp___0;
#line 122
  r <<= 8;
#line 123
  r |= (int )*p;
#line 124
  r <<= bo % 8 + 8;
#line 125
  r >>= 32 - bc;
#line 127
  return (r);
}
}
#line 148 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/misc/unsqsh.c"
static int unpack(uint8 *src , uint8 *dst , int len ) 
{ 
  int decrunched ;
  int type ;
  int hchk ;
  int d0 ;
  int d1 ;
  int d2 ;
  int d3 ;
  int d4 ;
  int d5 ;
  int d6 ;
  int a2 ;
  int a5 ;
  int u ;
  int cp ;
  int cup1 ;
  int lchk ;
  uint8 *a4 ;
  uint8 *a6 ;
  uint8 *c___0 ;
  uint8 bc1 ;
  uint8 bc2 ;
  uint8 bc3 ;
  uint8 a3[56] ;
  uint8 *tmp ;
  uint8 *tmp___0 ;
  uint8 *tmp___1 ;
  uint8 *tmp___2 ;
  uint8 *tmp___3 ;
  uint8 *tmp___4 ;
  uint16 tmp___5 ;
  uint8 *tmp___6 ;
  uint8 *tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  uint8 *tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  uint8 *tmp___20 ;
  uint8 *tmp___21 ;
  void *__cil_tmp50 ;

  {
#line 149
  decrunched = 0;
#line 157
  a3[0] = (uint8 )2;
#line 157
  a3[1] = (uint8 )3;
#line 157
  a3[2] = (uint8 )4;
#line 157
  a3[3] = (uint8 )5;
#line 157
  a3[4] = (uint8 )6;
#line 157
  a3[5] = (uint8 )7;
#line 157
  a3[6] = (uint8 )8;
#line 157
  a3[7] = (uint8 )0;
#line 157
  a3[8] = (uint8 )3;
#line 157
  a3[9] = (uint8 )2;
#line 157
  a3[10] = (uint8 )4;
#line 157
  a3[11] = (uint8 )5;
#line 157
  a3[12] = (uint8 )6;
#line 157
  a3[13] = (uint8 )7;
#line 157
  a3[14] = (uint8 )8;
#line 157
  a3[15] = (uint8 )0;
#line 157
  a3[16] = (uint8 )4;
#line 157
  a3[17] = (uint8 )3;
#line 157
  a3[18] = (uint8 )5;
#line 157
  a3[19] = (uint8 )2;
#line 157
  a3[20] = (uint8 )6;
#line 157
  a3[21] = (uint8 )7;
#line 157
  a3[22] = (uint8 )8;
#line 157
  a3[23] = (uint8 )0;
#line 157
  a3[24] = (uint8 )5;
#line 157
  a3[25] = (uint8 )4;
#line 157
  a3[26] = (uint8 )6;
#line 157
  a3[27] = (uint8 )2;
#line 157
  a3[28] = (uint8 )3;
#line 157
  a3[29] = (uint8 )7;
#line 157
  a3[30] = (uint8 )8;
#line 157
  a3[31] = (uint8 )0;
#line 157
  a3[32] = (uint8 )6;
#line 157
  a3[33] = (uint8 )5;
#line 157
  a3[34] = (uint8 )7;
#line 157
  a3[35] = (uint8 )2;
#line 157
  a3[36] = (uint8 )3;
#line 157
  a3[37] = (uint8 )4;
#line 157
  a3[38] = (uint8 )8;
#line 157
  a3[39] = (uint8 )0;
#line 157
  a3[40] = (uint8 )7;
#line 157
  a3[41] = (uint8 )6;
#line 157
  a3[42] = (uint8 )8;
#line 157
  a3[43] = (uint8 )2;
#line 157
  a3[44] = (uint8 )3;
#line 157
  a3[45] = (uint8 )4;
#line 157
  a3[46] = (uint8 )5;
#line 157
  a3[47] = (uint8 )0;
#line 157
  a3[48] = (uint8 )8;
#line 157
  a3[49] = (uint8 )7;
#line 157
  a3[50] = (uint8 )6;
#line 157
  a3[51] = (uint8 )2;
#line 157
  a3[52] = (uint8 )3;
#line 157
  a3[53] = (uint8 )4;
#line 157
  a3[54] = (uint8 )5;
#line 157
  a3[55] = (uint8 )0;
#line 161
  xpkerrno = (int volatile   )0;
#line 162
  c___0 = src + 20;
  {
#line 164
  while (1) {
    while_continue: /* CIL Label */ ;
#line 164
    if (! len) {
#line 164
      goto while_break;
    }
    {
#line 165
    tmp = c___0;
#line 165
    c___0 ++;
#line 165
    type = (int )*tmp;
#line 165
    tmp___0 = c___0;
#line 165
    c___0 ++;
#line 165
    hchk = (int )*tmp___0;
#line 169
    u = (int )*((uint16 *)c___0);
#line 169
    c___0 += 2;
#line 170
    tmp___1 = c___0;
#line 170
    c___0 ++;
#line 170
    cp = (int )*tmp___1;
#line 170
    cp <<= 8;
#line 170
    tmp___2 = c___0;
#line 170
    c___0 ++;
#line 170
    cp |= (int )*tmp___2;
#line 171
    tmp___3 = c___0;
#line 171
    c___0 ++;
#line 171
    cup1 = (int )*tmp___3;
#line 171
    cup1 <<= 8;
#line 171
    tmp___4 = c___0;
#line 171
    c___0 ++;
#line 171
    cup1 |= (int )*tmp___4;
#line 173
    src = c___0 + 2;
#line 174
    bc1 = *(c___0 + (cp + 2));
#line 174
    bc2 = *(c___0 + (cp + 1));
#line 174
    bc3 = *(c___0 + cp);
#line 175
    *(c___0 + (cp + 2)) = (uint8 )0;
#line 175
    *(c___0 + (cp + 1)) = (uint8 )0;
#line 175
    *(c___0 + cp) = (uint8 )0;
#line 176
    tmp___5 = xchecksum((uint32 *)c___0, (uint32 )((cp + 3) >> 2));
#line 176
    lchk = (int )tmp___5;
#line 177
    *(c___0 + (cp + 2)) = bc1;
#line 177
    *(c___0 + (cp + 1)) = bc2;
#line 177
    *(c___0 + cp) = bc3;
    }
#line 179
    if (lchk != u) {
#line 180
      xpkerrno = (int volatile   )1;
#line 181
      return (decrunched);
    }
#line 184
    if (type == 0) {
      {
#line 186
      memcpy((void */* __restrict  */)dst, (void const   */* __restrict  */)c___0,
             (size_t )cp);
#line 187
      dst += cp;
#line 188
      c___0 += cp;
#line 189
      len -= cp;
#line 190
      decrunched += cp;
      }
#line 191
      goto while_continue;
    }
#line 194
    if (type != 1) {
#line 195
      xpkerrno = (int volatile   )2;
#line 196
      return (decrunched);
    }
#line 199
    len -= cup1;
#line 200
    decrunched += cup1;
#line 202
    cp = (cp + 3) & 65532;
#line 203
    c___0 += cp;
#line 205
    a6 = dst + cup1;
#line 206
    a2 = 0;
#line 206
    d3 = a2;
#line 206
    d2 = d3;
#line 206
    d1 = d2;
#line 206
    d0 = d1;
#line 208
    tmp___6 = src;
#line 208
    src ++;
#line 208
    d3 = (int )*tmp___6;
#line 209
    tmp___7 = dst;
#line 209
    dst ++;
#line 209
    *tmp___7 = (uint8 )d3;
    l6c6: 
#line 210
    if (d1 >= 8) {
#line 210
      goto l6dc;
    }
    {
#line 211
    tmp___8 = bfextu(src, d0, 1);
    }
#line 211
    if (tmp___8) {
#line 211
      goto l75a;
    }
#line 212
    d0 ++;
#line 213
    d5 = 0;
#line 214
    d6 = 8;
#line 215
    goto l734;
    l6dc: 
    {
#line 217
    tmp___9 = bfextu(src, d0, 1);
    }
#line 217
    if (tmp___9) {
#line 217
      goto l726;
    }
    {
#line 218
    d0 ++;
#line 219
    tmp___10 = bfextu(src, d0, 1);
    }
#line 219
    if (! tmp___10) {
#line 219
      goto l75a;
    }
    {
#line 220
    d0 ++;
#line 221
    tmp___11 = bfextu(src, d0, 1);
    }
#line 221
    if (tmp___11) {
#line 221
      goto l6f6;
    }
#line 222
    d6 = 2;
#line 223
    goto l708;
    l6f6: 
    {
#line 225
    d0 ++;
#line 226
    tmp___12 = bfextu(src, d0, 1);
    }
#line 226
    if (! tmp___12) {
#line 226
      goto l706;
    }
    {
#line 227
    d6 = bfextu(src, d0, 3);
#line 228
    d0 += 3;
    }
#line 229
    goto l70a;
    l706: 
#line 231
    d6 = 3;
    l708: 
#line 232
    d0 ++;
    l70a: 
#line 233
    d6 = (int )*(((a3 + 8 * a2) + d6) - 17);
#line 234
    if (d6 != 8) {
#line 234
      goto l730;
    }
    l718: 
#line 235
    if (d2 < 20) {
#line 235
      goto l722;
    }
#line 236
    d5 = 1;
#line 237
    goto l732;
    l722: 
#line 239
    d5 = 0;
#line 240
    goto l734;
    l726: 
#line 242
    d0 ++;
#line 243
    d6 = 8;
#line 244
    if (d6 == a2) {
#line 244
      goto l718;
    }
#line 245
    d6 = a2;
    l730: 
#line 246
    d5 = 4;
    l732: 
#line 247
    d2 += 8;
    l734: 
    {
#line 248
    d4 = bfexts(src, d0, d6);
#line 249
    d0 += d6;
#line 250
    d3 -= d4;
#line 251
    tmp___13 = dst;
#line 251
    dst ++;
#line 251
    *tmp___13 = (uint8 )d3;
#line 252
    d5 --;
    }
#line 253
    if (d5 != -1) {
#line 253
      goto l734;
    }
#line 254
    if (d1 == 31) {
#line 254
      goto l74a;
    }
#line 255
    d1 ++;
    l74a: 
#line 256
    a2 = d6;
    l74c: 
#line 257
    d6 = d2;
#line 258
    d6 >>= 3;
#line 259
    d2 -= d6;
#line 260
    if ((unsigned long )dst < (unsigned long )a6) {
#line 260
      goto l6c6;
    }
#line 267
    dst = a6;
  }
  while_break: /* CIL Label */ ;
  }
#line 269
  return (decrunched);
  l75a: 
  {
#line 271
  d0 ++;
#line 272
  tmp___14 = bfextu(src, d0, 1);
  }
#line 272
  if (tmp___14) {
#line 272
    goto l766;
  }
#line 273
  d4 = 2;
#line 274
  goto l79e;
  l766: 
  {
#line 276
  d0 ++;
#line 277
  tmp___15 = bfextu(src, d0, 1);
  }
#line 277
  if (tmp___15) {
#line 277
    goto l772;
  }
#line 278
  d4 = 4;
#line 279
  goto l79e;
  l772: 
  {
#line 281
  d0 ++;
#line 282
  tmp___16 = bfextu(src, d0, 1);
  }
#line 282
  if (tmp___16) {
#line 282
    goto l77e;
  }
#line 283
  d4 = 6;
#line 284
  goto l79e;
  l77e: 
  {
#line 286
  d0 ++;
#line 287
  tmp___17 = bfextu(src, d0, 1);
  }
#line 287
  if (tmp___17) {
#line 287
    goto l792;
  }
  {
#line 288
  d0 ++;
#line 289
  d6 = bfextu(src, d0, 3);
#line 290
  d0 += 3;
#line 291
  d6 += 8;
  }
#line 292
  goto l7a8;
  l792: 
  {
#line 294
  d0 ++;
#line 295
  d6 = bfextu(src, d0, 5);
#line 296
  d0 += 5;
#line 297
  d4 = 16;
  }
#line 298
  goto l7a6;
  l79e: 
  {
#line 300
  d0 ++;
#line 301
  d6 = bfextu(src, d0, 1);
#line 302
  d0 ++;
  }
  l7a6: 
#line 303
  d6 += d4;
  l7a8: 
  {
#line 304
  tmp___18 = bfextu(src, d0, 1);
  }
#line 304
  if (tmp___18) {
#line 304
    goto l7c4;
  }
  {
#line 305
  d0 ++;
#line 306
  tmp___19 = bfextu(src, d0, 1);
  }
#line 306
  if (tmp___19) {
#line 306
    goto l7bc;
  }
#line 307
  d5 = 8;
#line 308
  a5 = 0;
#line 309
  goto l7ca;
  l7bc: 
#line 311
  d5 = 14;
#line 312
  a5 = -4352;
#line 313
  goto l7ca;
  l7c4: 
#line 315
  d5 = 12;
#line 316
  a5 = -256;
  l7ca: 
  {
#line 317
  d0 ++;
#line 318
  d4 = bfextu(src, d0, d5);
#line 319
  d0 += d5;
#line 320
  d6 -= 3;
  }
#line 321
  if (d6 < 0) {
#line 321
    goto l7e0;
  }
#line 322
  if (d6 == 0) {
#line 322
    goto l7da;
  }
#line 323
  d1 --;
  l7da: 
#line 324
  d1 --;
#line 325
  if (d1 >= 0) {
#line 325
    goto l7e0;
  }
#line 326
  d1 = 0;
  l7e0: 
#line 327
  d6 += 2;
#line 328
  a4 = ((dst + -1) + a5) - d4;
  l7ex: 
#line 329
  tmp___20 = dst;
#line 329
  dst ++;
#line 329
  tmp___21 = a4;
#line 329
  a4 ++;
#line 329
  *tmp___20 = *tmp___21;
#line 330
  d6 --;
#line 331
  if (d6 != -1) {
#line 331
    goto l7ex;
  }
#line 332
  a4 --;
#line 332
  d3 = (int )*a4;
#line 333
  goto l74c;
}
}
#line 517 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/misc/unsqsh.c"
int decrunch_sqsh(FILE *f , FILE *fo ) 
{ 
  int tmp ;

  {
#line 519
  if ((unsigned long )fo == (unsigned long )((void *)0)) {
#line 520
    return (-1);
  }
  {
#line 522
  tmp = unsqsh(f, fo);
  }
#line 522
  if (tmp < 0) {
#line 523
    return (-1);
  }
#line 525
  return (0);
}
}
#line 146 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 219
extern int fflush(FILE *__stream ) ;
#line 45 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/misc/ppdepack.c"
int savefile(FILE *fo , void *mem , size_t length ) 
{ 
  int ok ;
  size_t tmp ;
  int tmp___0 ;

  {
#line 47
  if (fo) {
    {
#line 47
    tmp = fwrite((void const   */* __restrict  */)mem, (size_t )1, length, (FILE */* __restrict  */)fo);
    }
#line 47
    if (tmp == length) {
#line 47
      tmp___0 = 1;
    } else {
#line 47
      tmp___0 = 0;
    }
  } else {
#line 47
    tmp___0 = 0;
  }
#line 47
  ok = tmp___0;
#line 48
  return (ok);
}
}
#line 52 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/misc/ppdepack.c"
static uint32 key_start  =    (uint32 )0;
#line 55 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/misc/ppdepack.c"
__inline static void ppDecryptCopy(uint8 *src , uint8 *dest , uint32 len , uint32 key ) 
{ 
  uint8 a ;
  uint8 b___1 ;
  uint8 c___0 ;
  uint8 d ;
  uint8 *tmp ;
  uint8 *tmp___0 ;
  uint8 *tmp___1 ;
  uint8 *tmp___2 ;
  uint8 *tmp___3 ;
  uint8 *tmp___4 ;
  uint8 *tmp___5 ;
  uint8 *tmp___6 ;
  uint32 tmp___7 ;

  {
#line 58
  a = (uint8 )((key >> 24) & 255U);
#line 59
  b___1 = (uint8 )((key >> 16) & 255U);
#line 60
  c___0 = (uint8 )((key >> 8) & 255U);
#line 61
  d = (uint8 )(key & 255U);
#line 63
  len = (len + 3U) >> 2;
  {
#line 64
  while (1) {
    while_continue: /* CIL Label */ ;
#line 64
    tmp___7 = len;
#line 64
    len --;
#line 64
    if (! tmp___7) {
#line 64
      goto while_break;
    }
#line 65
    tmp = dest;
#line 65
    dest ++;
#line 65
    tmp___0 = src;
#line 65
    src ++;
#line 65
    *tmp = (uint8 )((int )*tmp___0 ^ (int )a);
#line 66
    tmp___1 = dest;
#line 66
    dest ++;
#line 66
    tmp___2 = src;
#line 66
    src ++;
#line 66
    *tmp___1 = (uint8 )((int )*tmp___2 ^ (int )b___1);
#line 67
    tmp___3 = dest;
#line 67
    dest ++;
#line 67
    tmp___4 = src;
#line 67
    src ++;
#line 67
    *tmp___3 = (uint8 )((int )*tmp___4 ^ (int )c___0);
#line 68
    tmp___5 = dest;
#line 68
    dest ++;
#line 68
    tmp___6 = src;
#line 68
    src ++;
#line 68
    *tmp___5 = (uint8 )((int )*tmp___6 ^ (int )d);
  }
  while_break: /* CIL Label */ ;
  }
#line 70
  return;
}
}
#line 93 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/misc/ppdepack.c"
int ppDecrunch(uint8 *src , uint8 *dest , uint8 *offset_lens , uint32 src_len , uint32 dest_len ,
               uint8 skip_bits ) 
{ 
  uint8 *buf_src ;
  uint8 *out ;
  uint8 *dest_end ;
  uint8 bits_left ;
  uint8 bit_cnt ;
  uint32 bit_buffer ;
  uint32 x ;
  uint32 todo ;
  uint32 offbits ;
  uint32 offset ;
  uint32 written ;
  uint8 tmp ;
  uint8 tmp___0 ;
  uint8 tmp___1 ;
  uint8 tmp___2 ;
  uint32 tmp___3 ;
  uint8 tmp___4 ;
  uint8 tmp___5 ;
  uint8 tmp___6 ;
  uint8 tmp___7 ;
  uint8 tmp___8 ;
  uint32 tmp___9 ;

  {
#line 96
  bits_left = (uint8 )0;
#line 97
  bit_buffer = (uint32 )0;
#line 97
  written = (uint32 )0;
#line 99
  if ((unsigned long )src == (unsigned long )((void *)0)) {
#line 99
    return (0);
  } else
#line 99
  if ((unsigned long )dest == (unsigned long )((void *)0)) {
#line 99
    return (0);
  } else
#line 99
  if ((unsigned long )offset_lens == (unsigned long )((void *)0)) {
#line 99
    return (0);
  }
#line 102
  buf_src = src + src_len;
#line 103
  dest_end = dest + dest_len;
#line 103
  out = dest_end;
  {
#line 106
  while (1) {
    while_continue: /* CIL Label */ ;
#line 106
    bit_cnt = skip_bits;
    {
#line 106
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 106
      if (! ((int )bits_left < (int )bit_cnt)) {
#line 106
        goto while_break___0;
      }
#line 106
      if ((unsigned long )buf_src < (unsigned long )src) {
#line 106
        return (0);
      }
#line 106
      buf_src --;
#line 106
      bit_buffer |= (unsigned int )((int )*buf_src << (int )bits_left);
#line 106
      bits_left = (uint8 )((int )bits_left + 8);
    }
    while_break___0: /* CIL Label */ ;
    }
#line 106
    x = (uint32 )0;
#line 106
    bits_left = (uint8 )((int )bits_left - (int )bit_cnt);
    {
#line 106
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 106
      tmp = bit_cnt;
#line 106
      bit_cnt = (uint8 )((int )bit_cnt - 1);
#line 106
      if (! tmp) {
#line 106
        goto while_break___1;
      }
#line 106
      x = (x << 1) | (bit_buffer & 1U);
#line 106
      bit_buffer >>= 1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 106
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 109
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 109
    if (! (written < dest_len)) {
#line 109
      goto while_break___2;
    }
    {
#line 110
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 110
      bit_cnt = (uint8 )1;
      {
#line 110
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 110
        if (! ((int )bits_left < (int )bit_cnt)) {
#line 110
          goto while_break___4;
        }
#line 110
        if ((unsigned long )buf_src < (unsigned long )src) {
#line 110
          return (0);
        }
#line 110
        buf_src --;
#line 110
        bit_buffer |= (unsigned int )((int )*buf_src << (int )bits_left);
#line 110
        bits_left = (uint8 )((int )bits_left + 8);
      }
      while_break___4: /* CIL Label */ ;
      }
#line 110
      x = (uint32 )0;
#line 110
      bits_left = (uint8 )((int )bits_left - (int )bit_cnt);
      {
#line 110
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 110
        tmp___0 = bit_cnt;
#line 110
        bit_cnt = (uint8 )((int )bit_cnt - 1);
#line 110
        if (! tmp___0) {
#line 110
          goto while_break___5;
        }
#line 110
        x = (x << 1) | (bit_buffer & 1U);
#line 110
        bit_buffer >>= 1;
      }
      while_break___5: /* CIL Label */ ;
      }
#line 110
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 111
    if (x == 0U) {
#line 113
      todo = (uint32 )1;
      {
#line 113
      while (1) {
        while_continue___6: /* CIL Label */ ;
        {
#line 113
        while (1) {
          while_continue___7: /* CIL Label */ ;
#line 113
          bit_cnt = (uint8 )2;
          {
#line 113
          while (1) {
            while_continue___8: /* CIL Label */ ;
#line 113
            if (! ((int )bits_left < (int )bit_cnt)) {
#line 113
              goto while_break___8;
            }
#line 113
            if ((unsigned long )buf_src < (unsigned long )src) {
#line 113
              return (0);
            }
#line 113
            buf_src --;
#line 113
            bit_buffer |= (unsigned int )((int )*buf_src << (int )bits_left);
#line 113
            bits_left = (uint8 )((int )bits_left + 8);
          }
          while_break___8: /* CIL Label */ ;
          }
#line 113
          x = (uint32 )0;
#line 113
          bits_left = (uint8 )((int )bits_left - (int )bit_cnt);
          {
#line 113
          while (1) {
            while_continue___9: /* CIL Label */ ;
#line 113
            tmp___1 = bit_cnt;
#line 113
            bit_cnt = (uint8 )((int )bit_cnt - 1);
#line 113
            if (! tmp___1) {
#line 113
              goto while_break___9;
            }
#line 113
            x = (x << 1) | (bit_buffer & 1U);
#line 113
            bit_buffer >>= 1;
          }
          while_break___9: /* CIL Label */ ;
          }
#line 113
          goto while_break___7;
        }
        while_break___7: /* CIL Label */ ;
        }
#line 113
        todo += x;
#line 113
        if (! (x == 3U)) {
#line 113
          goto while_break___6;
        }
      }
      while_break___6: /* CIL Label */ ;
      }
      {
#line 114
      while (1) {
        while_continue___10: /* CIL Label */ ;
#line 114
        tmp___3 = todo;
#line 114
        todo --;
#line 114
        if (! tmp___3) {
#line 114
          goto while_break___10;
        }
        {
#line 114
        while (1) {
          while_continue___11: /* CIL Label */ ;
#line 114
          bit_cnt = (uint8 )8;
          {
#line 114
          while (1) {
            while_continue___12: /* CIL Label */ ;
#line 114
            if (! ((int )bits_left < (int )bit_cnt)) {
#line 114
              goto while_break___12;
            }
#line 114
            if ((unsigned long )buf_src < (unsigned long )src) {
#line 114
              return (0);
            }
#line 114
            buf_src --;
#line 114
            bit_buffer |= (unsigned int )((int )*buf_src << (int )bits_left);
#line 114
            bits_left = (uint8 )((int )bits_left + 8);
          }
          while_break___12: /* CIL Label */ ;
          }
#line 114
          x = (uint32 )0;
#line 114
          bits_left = (uint8 )((int )bits_left - (int )bit_cnt);
          {
#line 114
          while (1) {
            while_continue___13: /* CIL Label */ ;
#line 114
            tmp___2 = bit_cnt;
#line 114
            bit_cnt = (uint8 )((int )bit_cnt - 1);
#line 114
            if (! tmp___2) {
#line 114
              goto while_break___13;
            }
#line 114
            x = (x << 1) | (bit_buffer & 1U);
#line 114
            bit_buffer >>= 1;
          }
          while_break___13: /* CIL Label */ ;
          }
#line 114
          goto while_break___11;
        }
        while_break___11: /* CIL Label */ ;
        }
        {
#line 114
        while (1) {
          while_continue___14: /* CIL Label */ ;
#line 114
          if ((unsigned long )out <= (unsigned long )dest) {
#line 114
            return (0);
          }
#line 114
          out --;
#line 114
          *out = (uint8 )x;
#line 114
          written ++;
#line 114
          goto while_break___14;
        }
        while_break___14: /* CIL Label */ ;
        }
      }
      while_break___10: /* CIL Label */ ;
      }
#line 117
      if (written == dest_len) {
#line 117
        goto while_break___2;
      }
    }
    {
#line 121
    while (1) {
      while_continue___15: /* CIL Label */ ;
#line 121
      bit_cnt = (uint8 )2;
      {
#line 121
      while (1) {
        while_continue___16: /* CIL Label */ ;
#line 121
        if (! ((int )bits_left < (int )bit_cnt)) {
#line 121
          goto while_break___16;
        }
#line 121
        if ((unsigned long )buf_src < (unsigned long )src) {
#line 121
          return (0);
        }
#line 121
        buf_src --;
#line 121
        bit_buffer |= (unsigned int )((int )*buf_src << (int )bits_left);
#line 121
        bits_left = (uint8 )((int )bits_left + 8);
      }
      while_break___16: /* CIL Label */ ;
      }
#line 121
      x = (uint32 )0;
#line 121
      bits_left = (uint8 )((int )bits_left - (int )bit_cnt);
      {
#line 121
      while (1) {
        while_continue___17: /* CIL Label */ ;
#line 121
        tmp___4 = bit_cnt;
#line 121
        bit_cnt = (uint8 )((int )bit_cnt - 1);
#line 121
        if (! tmp___4) {
#line 121
          goto while_break___17;
        }
#line 121
        x = (x << 1) | (bit_buffer & 1U);
#line 121
        bit_buffer >>= 1;
      }
      while_break___17: /* CIL Label */ ;
      }
#line 121
      goto while_break___15;
    }
    while_break___15: /* CIL Label */ ;
    }
#line 122
    offbits = (uint32 )*(offset_lens + x);
#line 123
    todo = x + 2U;
#line 124
    if (x == 3U) {
      {
#line 125
      while (1) {
        while_continue___18: /* CIL Label */ ;
#line 125
        bit_cnt = (uint8 )1;
        {
#line 125
        while (1) {
          while_continue___19: /* CIL Label */ ;
#line 125
          if (! ((int )bits_left < (int )bit_cnt)) {
#line 125
            goto while_break___19;
          }
#line 125
          if ((unsigned long )buf_src < (unsigned long )src) {
#line 125
            return (0);
          }
#line 125
          buf_src --;
#line 125
          bit_buffer |= (unsigned int )((int )*buf_src << (int )bits_left);
#line 125
          bits_left = (uint8 )((int )bits_left + 8);
        }
        while_break___19: /* CIL Label */ ;
        }
#line 125
        x = (uint32 )0;
#line 125
        bits_left = (uint8 )((int )bits_left - (int )bit_cnt);
        {
#line 125
        while (1) {
          while_continue___20: /* CIL Label */ ;
#line 125
          tmp___5 = bit_cnt;
#line 125
          bit_cnt = (uint8 )((int )bit_cnt - 1);
#line 125
          if (! tmp___5) {
#line 125
            goto while_break___20;
          }
#line 125
          x = (x << 1) | (bit_buffer & 1U);
#line 125
          bit_buffer >>= 1;
        }
        while_break___20: /* CIL Label */ ;
        }
#line 125
        goto while_break___18;
      }
      while_break___18: /* CIL Label */ ;
      }
#line 126
      if (x == 0U) {
#line 126
        offbits = (uint32 )7;
      }
      {
#line 127
      while (1) {
        while_continue___21: /* CIL Label */ ;
#line 127
        bit_cnt = (uint8 )offbits;
        {
#line 127
        while (1) {
          while_continue___22: /* CIL Label */ ;
#line 127
          if (! ((int )bits_left < (int )bit_cnt)) {
#line 127
            goto while_break___22;
          }
#line 127
          if ((unsigned long )buf_src < (unsigned long )src) {
#line 127
            return (0);
          }
#line 127
          buf_src --;
#line 127
          bit_buffer |= (unsigned int )((int )*buf_src << (int )bits_left);
#line 127
          bits_left = (uint8 )((int )bits_left + 8);
        }
        while_break___22: /* CIL Label */ ;
        }
#line 127
        offset = (uint32 )0;
#line 127
        bits_left = (uint8 )((int )bits_left - (int )bit_cnt);
        {
#line 127
        while (1) {
          while_continue___23: /* CIL Label */ ;
#line 127
          tmp___6 = bit_cnt;
#line 127
          bit_cnt = (uint8 )((int )bit_cnt - 1);
#line 127
          if (! tmp___6) {
#line 127
            goto while_break___23;
          }
#line 127
          offset = (offset << 1) | (bit_buffer & 1U);
#line 127
          bit_buffer >>= 1;
        }
        while_break___23: /* CIL Label */ ;
        }
#line 127
        goto while_break___21;
      }
      while_break___21: /* CIL Label */ ;
      }
      {
#line 128
      while (1) {
        while_continue___24: /* CIL Label */ ;
        {
#line 128
        while (1) {
          while_continue___25: /* CIL Label */ ;
#line 128
          bit_cnt = (uint8 )3;
          {
#line 128
          while (1) {
            while_continue___26: /* CIL Label */ ;
#line 128
            if (! ((int )bits_left < (int )bit_cnt)) {
#line 128
              goto while_break___26;
            }
#line 128
            if ((unsigned long )buf_src < (unsigned long )src) {
#line 128
              return (0);
            }
#line 128
            buf_src --;
#line 128
            bit_buffer |= (unsigned int )((int )*buf_src << (int )bits_left);
#line 128
            bits_left = (uint8 )((int )bits_left + 8);
          }
          while_break___26: /* CIL Label */ ;
          }
#line 128
          x = (uint32 )0;
#line 128
          bits_left = (uint8 )((int )bits_left - (int )bit_cnt);
          {
#line 128
          while (1) {
            while_continue___27: /* CIL Label */ ;
#line 128
            tmp___7 = bit_cnt;
#line 128
            bit_cnt = (uint8 )((int )bit_cnt - 1);
#line 128
            if (! tmp___7) {
#line 128
              goto while_break___27;
            }
#line 128
            x = (x << 1) | (bit_buffer & 1U);
#line 128
            bit_buffer >>= 1;
          }
          while_break___27: /* CIL Label */ ;
          }
#line 128
          goto while_break___25;
        }
        while_break___25: /* CIL Label */ ;
        }
#line 128
        todo += x;
#line 128
        if (! (x == 7U)) {
#line 128
          goto while_break___24;
        }
      }
      while_break___24: /* CIL Label */ ;
      }
    } else {
      {
#line 131
      while (1) {
        while_continue___28: /* CIL Label */ ;
#line 131
        bit_cnt = (uint8 )offbits;
        {
#line 131
        while (1) {
          while_continue___29: /* CIL Label */ ;
#line 131
          if (! ((int )bits_left < (int )bit_cnt)) {
#line 131
            goto while_break___29;
          }
#line 131
          if ((unsigned long )buf_src < (unsigned long )src) {
#line 131
            return (0);
          }
#line 131
          buf_src --;
#line 131
          bit_buffer |= (unsigned int )((int )*buf_src << (int )bits_left);
#line 131
          bits_left = (uint8 )((int )bits_left + 8);
        }
        while_break___29: /* CIL Label */ ;
        }
#line 131
        offset = (uint32 )0;
#line 131
        bits_left = (uint8 )((int )bits_left - (int )bit_cnt);
        {
#line 131
        while (1) {
          while_continue___30: /* CIL Label */ ;
#line 131
          tmp___8 = bit_cnt;
#line 131
          bit_cnt = (uint8 )((int )bit_cnt - 1);
#line 131
          if (! tmp___8) {
#line 131
            goto while_break___30;
          }
#line 131
          offset = (offset << 1) | (bit_buffer & 1U);
#line 131
          bit_buffer >>= 1;
        }
        while_break___30: /* CIL Label */ ;
        }
#line 131
        goto while_break___28;
      }
      while_break___28: /* CIL Label */ ;
      }
    }
#line 133
    if ((unsigned long )(out + offset) >= (unsigned long )dest_end) {
#line 133
      return (0);
    }
    {
#line 134
    while (1) {
      while_continue___31: /* CIL Label */ ;
#line 134
      tmp___9 = todo;
#line 134
      todo --;
#line 134
      if (! tmp___9) {
#line 134
        goto while_break___31;
      }
#line 134
      x = (uint32 )*(out + offset);
      {
#line 134
      while (1) {
        while_continue___32: /* CIL Label */ ;
#line 134
        if ((unsigned long )out <= (unsigned long )dest) {
#line 134
          return (0);
        }
#line 134
        out --;
#line 134
        *out = (uint8 )x;
#line 134
        written ++;
#line 134
        goto while_break___32;
      }
      while_break___32: /* CIL Label */ ;
      }
    }
    while_break___31: /* CIL Label */ ;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 138
  return (1);
}
}
#line 148 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/misc/ppdepack.c"
__inline static int ppValidate(uint8 *src , uint8 *offset_lens , uint32 src_len ,
                               uint32 dest_len , uint8 skip_bits ) 
{ 
  uint8 *buf_src ;
  uint8 bits_left ;
  uint8 bit_cnt ;
  uint32 bit_buffer ;
  uint32 x ;
  uint32 todo ;
  uint32 offbits ;
  uint32 offset ;
  uint32 written ;
  uint8 tmp ;
  uint8 tmp___0 ;
  uint8 tmp___1 ;
  uint8 tmp___2 ;
  uint32 tmp___3 ;
  uint8 tmp___4 ;
  uint8 tmp___5 ;
  uint8 tmp___6 ;
  uint8 tmp___7 ;
  uint8 tmp___8 ;

  {
#line 152
  bits_left = (uint8 )0;
#line 153
  bit_buffer = (uint32 )0;
#line 153
  written = (uint32 )0;
#line 155
  if ((unsigned long )src == (unsigned long )((void *)0)) {
#line 155
    return (0);
  } else
#line 155
  if ((unsigned long )offset_lens == (unsigned long )((void *)0)) {
#line 155
    return (0);
  }
#line 158
  buf_src = src + src_len;
  {
#line 161
  while (1) {
    while_continue: /* CIL Label */ ;
#line 161
    bit_cnt = skip_bits;
    {
#line 161
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 161
      if (! ((int )bits_left < (int )bit_cnt)) {
#line 161
        goto while_break___0;
      }
#line 161
      if ((unsigned long )buf_src < (unsigned long )src) {
#line 161
        return (0);
      }
#line 161
      buf_src --;
#line 161
      bit_buffer |= (unsigned int )((int )*buf_src << (int )bits_left);
#line 161
      bits_left = (uint8 )((int )bits_left + 8);
    }
    while_break___0: /* CIL Label */ ;
    }
#line 161
    x = (uint32 )0;
#line 161
    bits_left = (uint8 )((int )bits_left - (int )bit_cnt);
    {
#line 161
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 161
      tmp = bit_cnt;
#line 161
      bit_cnt = (uint8 )((int )bit_cnt - 1);
#line 161
      if (! tmp) {
#line 161
        goto while_break___1;
      }
#line 161
      x = (x << 1) | (bit_buffer & 1U);
#line 161
      bit_buffer >>= 1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 161
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 164
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 164
    if (! (written < dest_len)) {
#line 164
      goto while_break___2;
    }
    {
#line 165
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 165
      bit_cnt = (uint8 )1;
      {
#line 165
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 165
        if (! ((int )bits_left < (int )bit_cnt)) {
#line 165
          goto while_break___4;
        }
#line 165
        if ((unsigned long )buf_src < (unsigned long )src) {
#line 165
          return (0);
        }
#line 165
        buf_src --;
#line 165
        bit_buffer |= (unsigned int )((int )*buf_src << (int )bits_left);
#line 165
        bits_left = (uint8 )((int )bits_left + 8);
      }
      while_break___4: /* CIL Label */ ;
      }
#line 165
      x = (uint32 )0;
#line 165
      bits_left = (uint8 )((int )bits_left - (int )bit_cnt);
      {
#line 165
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 165
        tmp___0 = bit_cnt;
#line 165
        bit_cnt = (uint8 )((int )bit_cnt - 1);
#line 165
        if (! tmp___0) {
#line 165
          goto while_break___5;
        }
#line 165
        x = (x << 1) | (bit_buffer & 1U);
#line 165
        bit_buffer >>= 1;
      }
      while_break___5: /* CIL Label */ ;
      }
#line 165
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 166
    if (x == 0U) {
#line 168
      todo = (uint32 )1;
      {
#line 168
      while (1) {
        while_continue___6: /* CIL Label */ ;
        {
#line 168
        while (1) {
          while_continue___7: /* CIL Label */ ;
#line 168
          bit_cnt = (uint8 )2;
          {
#line 168
          while (1) {
            while_continue___8: /* CIL Label */ ;
#line 168
            if (! ((int )bits_left < (int )bit_cnt)) {
#line 168
              goto while_break___8;
            }
#line 168
            if ((unsigned long )buf_src < (unsigned long )src) {
#line 168
              return (0);
            }
#line 168
            buf_src --;
#line 168
            bit_buffer |= (unsigned int )((int )*buf_src << (int )bits_left);
#line 168
            bits_left = (uint8 )((int )bits_left + 8);
          }
          while_break___8: /* CIL Label */ ;
          }
#line 168
          x = (uint32 )0;
#line 168
          bits_left = (uint8 )((int )bits_left - (int )bit_cnt);
          {
#line 168
          while (1) {
            while_continue___9: /* CIL Label */ ;
#line 168
            tmp___1 = bit_cnt;
#line 168
            bit_cnt = (uint8 )((int )bit_cnt - 1);
#line 168
            if (! tmp___1) {
#line 168
              goto while_break___9;
            }
#line 168
            x = (x << 1) | (bit_buffer & 1U);
#line 168
            bit_buffer >>= 1;
          }
          while_break___9: /* CIL Label */ ;
          }
#line 168
          goto while_break___7;
        }
        while_break___7: /* CIL Label */ ;
        }
#line 168
        todo += x;
#line 168
        if (! (x == 3U)) {
#line 168
          goto while_break___6;
        }
      }
      while_break___6: /* CIL Label */ ;
      }
#line 169
      written += todo;
#line 169
      if (written > dest_len) {
#line 169
        return (0);
      }
      {
#line 170
      while (1) {
        while_continue___10: /* CIL Label */ ;
#line 170
        tmp___3 = todo;
#line 170
        todo --;
#line 170
        if (! tmp___3) {
#line 170
          goto while_break___10;
        }
        {
#line 170
        while (1) {
          while_continue___11: /* CIL Label */ ;
#line 170
          bit_cnt = (uint8 )8;
          {
#line 170
          while (1) {
            while_continue___12: /* CIL Label */ ;
#line 170
            if (! ((int )bits_left < (int )bit_cnt)) {
#line 170
              goto while_break___12;
            }
#line 170
            if ((unsigned long )buf_src < (unsigned long )src) {
#line 170
              return (0);
            }
#line 170
            buf_src --;
#line 170
            bit_buffer |= (unsigned int )((int )*buf_src << (int )bits_left);
#line 170
            bits_left = (uint8 )((int )bits_left + 8);
          }
          while_break___12: /* CIL Label */ ;
          }
#line 170
          x = (uint32 )0;
#line 170
          bits_left = (uint8 )((int )bits_left - (int )bit_cnt);
          {
#line 170
          while (1) {
            while_continue___13: /* CIL Label */ ;
#line 170
            tmp___2 = bit_cnt;
#line 170
            bit_cnt = (uint8 )((int )bit_cnt - 1);
#line 170
            if (! tmp___2) {
#line 170
              goto while_break___13;
            }
#line 170
            x = (x << 1) | (bit_buffer & 1U);
#line 170
            bit_buffer >>= 1;
          }
          while_break___13: /* CIL Label */ ;
          }
#line 170
          goto while_break___11;
        }
        while_break___11: /* CIL Label */ ;
        }
      }
      while_break___10: /* CIL Label */ ;
      }
#line 173
      if (written == dest_len) {
#line 173
        goto while_break___2;
      }
    }
    {
#line 177
    while (1) {
      while_continue___14: /* CIL Label */ ;
#line 177
      bit_cnt = (uint8 )2;
      {
#line 177
      while (1) {
        while_continue___15: /* CIL Label */ ;
#line 177
        if (! ((int )bits_left < (int )bit_cnt)) {
#line 177
          goto while_break___15;
        }
#line 177
        if ((unsigned long )buf_src < (unsigned long )src) {
#line 177
          return (0);
        }
#line 177
        buf_src --;
#line 177
        bit_buffer |= (unsigned int )((int )*buf_src << (int )bits_left);
#line 177
        bits_left = (uint8 )((int )bits_left + 8);
      }
      while_break___15: /* CIL Label */ ;
      }
#line 177
      x = (uint32 )0;
#line 177
      bits_left = (uint8 )((int )bits_left - (int )bit_cnt);
      {
#line 177
      while (1) {
        while_continue___16: /* CIL Label */ ;
#line 177
        tmp___4 = bit_cnt;
#line 177
        bit_cnt = (uint8 )((int )bit_cnt - 1);
#line 177
        if (! tmp___4) {
#line 177
          goto while_break___16;
        }
#line 177
        x = (x << 1) | (bit_buffer & 1U);
#line 177
        bit_buffer >>= 1;
      }
      while_break___16: /* CIL Label */ ;
      }
#line 177
      goto while_break___14;
    }
    while_break___14: /* CIL Label */ ;
    }
#line 178
    offbits = (uint32 )*(offset_lens + x);
#line 179
    todo = x + 2U;
#line 180
    if (x == 3U) {
      {
#line 181
      while (1) {
        while_continue___17: /* CIL Label */ ;
#line 181
        bit_cnt = (uint8 )1;
        {
#line 181
        while (1) {
          while_continue___18: /* CIL Label */ ;
#line 181
          if (! ((int )bits_left < (int )bit_cnt)) {
#line 181
            goto while_break___18;
          }
#line 181
          if ((unsigned long )buf_src < (unsigned long )src) {
#line 181
            return (0);
          }
#line 181
          buf_src --;
#line 181
          bit_buffer |= (unsigned int )((int )*buf_src << (int )bits_left);
#line 181
          bits_left = (uint8 )((int )bits_left + 8);
        }
        while_break___18: /* CIL Label */ ;
        }
#line 181
        x = (uint32 )0;
#line 181
        bits_left = (uint8 )((int )bits_left - (int )bit_cnt);
        {
#line 181
        while (1) {
          while_continue___19: /* CIL Label */ ;
#line 181
          tmp___5 = bit_cnt;
#line 181
          bit_cnt = (uint8 )((int )bit_cnt - 1);
#line 181
          if (! tmp___5) {
#line 181
            goto while_break___19;
          }
#line 181
          x = (x << 1) | (bit_buffer & 1U);
#line 181
          bit_buffer >>= 1;
        }
        while_break___19: /* CIL Label */ ;
        }
#line 181
        goto while_break___17;
      }
      while_break___17: /* CIL Label */ ;
      }
#line 182
      if (x == 0U) {
#line 182
        offbits = (uint32 )7;
      }
      {
#line 183
      while (1) {
        while_continue___20: /* CIL Label */ ;
#line 183
        bit_cnt = (uint8 )offbits;
        {
#line 183
        while (1) {
          while_continue___21: /* CIL Label */ ;
#line 183
          if (! ((int )bits_left < (int )bit_cnt)) {
#line 183
            goto while_break___21;
          }
#line 183
          if ((unsigned long )buf_src < (unsigned long )src) {
#line 183
            return (0);
          }
#line 183
          buf_src --;
#line 183
          bit_buffer |= (unsigned int )((int )*buf_src << (int )bits_left);
#line 183
          bits_left = (uint8 )((int )bits_left + 8);
        }
        while_break___21: /* CIL Label */ ;
        }
#line 183
        offset = (uint32 )0;
#line 183
        bits_left = (uint8 )((int )bits_left - (int )bit_cnt);
        {
#line 183
        while (1) {
          while_continue___22: /* CIL Label */ ;
#line 183
          tmp___6 = bit_cnt;
#line 183
          bit_cnt = (uint8 )((int )bit_cnt - 1);
#line 183
          if (! tmp___6) {
#line 183
            goto while_break___22;
          }
#line 183
          offset = (offset << 1) | (bit_buffer & 1U);
#line 183
          bit_buffer >>= 1;
        }
        while_break___22: /* CIL Label */ ;
        }
#line 183
        goto while_break___20;
      }
      while_break___20: /* CIL Label */ ;
      }
      {
#line 184
      while (1) {
        while_continue___23: /* CIL Label */ ;
        {
#line 184
        while (1) {
          while_continue___24: /* CIL Label */ ;
#line 184
          bit_cnt = (uint8 )3;
          {
#line 184
          while (1) {
            while_continue___25: /* CIL Label */ ;
#line 184
            if (! ((int )bits_left < (int )bit_cnt)) {
#line 184
              goto while_break___25;
            }
#line 184
            if ((unsigned long )buf_src < (unsigned long )src) {
#line 184
              return (0);
            }
#line 184
            buf_src --;
#line 184
            bit_buffer |= (unsigned int )((int )*buf_src << (int )bits_left);
#line 184
            bits_left = (uint8 )((int )bits_left + 8);
          }
          while_break___25: /* CIL Label */ ;
          }
#line 184
          x = (uint32 )0;
#line 184
          bits_left = (uint8 )((int )bits_left - (int )bit_cnt);
          {
#line 184
          while (1) {
            while_continue___26: /* CIL Label */ ;
#line 184
            tmp___7 = bit_cnt;
#line 184
            bit_cnt = (uint8 )((int )bit_cnt - 1);
#line 184
            if (! tmp___7) {
#line 184
              goto while_break___26;
            }
#line 184
            x = (x << 1) | (bit_buffer & 1U);
#line 184
            bit_buffer >>= 1;
          }
          while_break___26: /* CIL Label */ ;
          }
#line 184
          goto while_break___24;
        }
        while_break___24: /* CIL Label */ ;
        }
#line 184
        todo += x;
#line 184
        if (! (x == 7U)) {
#line 184
          goto while_break___23;
        }
      }
      while_break___23: /* CIL Label */ ;
      }
    } else {
      {
#line 187
      while (1) {
        while_continue___27: /* CIL Label */ ;
#line 187
        bit_cnt = (uint8 )offbits;
        {
#line 187
        while (1) {
          while_continue___28: /* CIL Label */ ;
#line 187
          if (! ((int )bits_left < (int )bit_cnt)) {
#line 187
            goto while_break___28;
          }
#line 187
          if ((unsigned long )buf_src < (unsigned long )src) {
#line 187
            return (0);
          }
#line 187
          buf_src --;
#line 187
          bit_buffer |= (unsigned int )((int )*buf_src << (int )bits_left);
#line 187
          bits_left = (uint8 )((int )bits_left + 8);
        }
        while_break___28: /* CIL Label */ ;
        }
#line 187
        offset = (uint32 )0;
#line 187
        bits_left = (uint8 )((int )bits_left - (int )bit_cnt);
        {
#line 187
        while (1) {
          while_continue___29: /* CIL Label */ ;
#line 187
          tmp___8 = bit_cnt;
#line 187
          bit_cnt = (uint8 )((int )bit_cnt - 1);
#line 187
          if (! tmp___8) {
#line 187
            goto while_break___29;
          }
#line 187
          offset = (offset << 1) | (bit_buffer & 1U);
#line 187
          bit_buffer >>= 1;
        }
        while_break___29: /* CIL Label */ ;
        }
#line 187
        goto while_break___27;
      }
      while_break___27: /* CIL Label */ ;
      }
    }
#line 189
    if (offset >= written) {
#line 189
      return (0);
    }
#line 190
    written += todo;
#line 190
    if (written > dest_len) {
#line 190
      return (0);
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 194
  return (1);
}
}
#line 198 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/misc/ppdepack.c"
static int ppcrack(FILE *fo , uint8 *data , uint32 len ) 
{ 
  int success ;
  uint8 *output ;
  uint8 crypted ;
  uint32 outlen ;
  void *tmp ;
  int tmp___0 ;
  uint32 key ;
  uint32 drop_mask ;
  uint32 drop_value ;
  uint8 *temp ;
  void *tmp___1 ;
  int tmp___2 ;
  uint32 tmp___3 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;

  {
#line 207
  success = 0;
#line 211
  if (len < 16U) {
    {
#line 212
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"File is too short to be a PP file (%u bytes)\n",
            len);
    }
#line 213
    return (-1);
  }
#line 216
  if ((int )*(data + 0) == 80) {
#line 216
    if ((int )*(data + 1) == 80) {
#line 216
      if ((int )*(data + 2) == 50) {
#line 216
        if ((int )*(data + 3) == 48) {
#line 217
          if (len & 3U) {
            {
#line 218
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"File length is not a multiple of 4\n");
            }
#line 219
            return (-1);
          }
#line 221
          crypted = (uint8 )0;
        } else {
#line 216
          goto _L___1;
        }
      } else {
#line 216
        goto _L___1;
      }
    } else {
#line 216
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
#line 223
  if ((int )*(data + 0) == 80) {
#line 223
    if ((int )*(data + 1) == 88) {
#line 223
      if ((int )*(data + 2) == 50) {
#line 223
        if ((int )*(data + 3) == 48) {
#line 224
          if ((len - 2U) & 3U) {
            {
#line 225
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"(file length - 2) is not a multiple of 4\n");
            }
#line 226
            return (-1);
          }
#line 228
          crypted = (uint8 )1;
        } else {
          {
#line 231
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"File does not have the PP signature\n");
          }
#line 232
          return (-1);
        }
      } else {
        {
#line 231
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"File does not have the PP signature\n");
        }
#line 232
        return (-1);
      }
    } else {
      {
#line 231
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"File does not have the PP signature\n");
      }
#line 232
      return (-1);
    }
  } else {
    {
#line 231
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"File does not have the PP signature\n");
    }
#line 232
    return (-1);
  }
  {
#line 235
  outlen = (uint32 )((((int )*(data + (len - 4U)) << 16) | ((int )*(data + (len - 3U)) << 8)) | (int )*(data + (len - 2U)));
#line 239
  tmp = malloc(outlen);
#line 239
  output = (uint8 *)tmp;
  }
#line 240
  if ((unsigned long )output == (unsigned long )((void *)0)) {
    {
#line 241
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"out of memory!\n");
    }
#line 242
    return (-1);
  }
#line 245
  if ((int )crypted == 0) {
    {
#line 247
    tmp___0 = ppDecrunch(data + 8, output, data + 4, len - 12U, outlen, *(data + (len - 1U)));
    }
#line 247
    if (tmp___0) {
      {
#line 249
      savefile(fo, (void *)output, outlen);
      }
    } else {
#line 251
      success = -1;
    }
  } else {
    {
#line 258
    key = key_start;
#line 279
    drop_mask = (uint32 )(1 << (int )*(data + (len - 1U)));
#line 280
    drop_value = (unsigned int )(((((int )*(data + (len - 8U)) << 24) | ((int )*(data + (len - 7U)) << 16)) | ((int )*(data + (len - 6U)) << 8)) | (int )*(data + (len - 5U))) & drop_mask;
#line 283
    tmp___1 = malloc(len - 14U);
#line 283
    temp = (uint8 *)tmp___1;
#line 287
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\nEncrypted. Hang on, while trying to find the right key...\n");
    }
#line 288
    if ((unsigned long )temp == (unsigned long )((void *)0)) {
      {
#line 289
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"out of memory!\n");
      }
#line 290
      return (-1);
    }
    {
#line 293
    while (1) {
      while_continue: /* CIL Label */ ;
#line 294
      if ((key & 4095U) == 0U) {
        {
#line 295
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"key %08x\r",
                key);
#line 296
        fflush(stdout);
        }
      }
#line 299
      if ((key & drop_mask) != drop_value) {
#line 299
        goto __Cont;
      }
      {
#line 302
      ppDecryptCopy(data + 10, temp, len - 14U, key);
#line 304
      tmp___2 = ppValidate(temp, data + 6, len - 14U, outlen, *(data + (len - 1U)));
      }
#line 304
      if (tmp___2) {
        {
#line 305
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"key %08x success!\n",
                key);
#line 306
        ppDecrunch(temp, output, data + 6, len - 14U, outlen, *(data + (len - 1U)));
#line 311
        savefile(fo, (void *)output, outlen);
        }
#line 312
        goto while_break;
      }
      __Cont: /* CIL Label */ 
#line 293
      tmp___3 = key;
#line 293
      key ++;
#line 293
      if (! (tmp___3 != 4294967295U)) {
#line 293
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 315
    free((void *)temp);
#line 316
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"All keys done!\n");
    }
  }
  {
#line 322
  free((void *)output);
  }
#line 323
  return (success);
}
}
#line 327 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/misc/ppdepack.c"
static int ppdepack(uint8 *src , size_t s , FILE *fo ) 
{ 
  int success ;

  {
  {
#line 330
  key_start = (uint32 )0;
#line 331
  success = ppcrack(fo, src, s);
  }
#line 332
  return (success);
}
}
#line 336 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/misc/ppdepack.c"
int decrunch_pp(FILE *f , FILE *fo ) 
{ 
  uint8 *packed ;
  int plen ;
  int unplen ;
  struct stat st ;
  int tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  void *__cil_tmp10 ;
  void *__cil_tmp11 ;
  void *__cil_tmp12 ;
  void *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;

  {
#line 342
  if ((unsigned long )fo == (unsigned long )((void *)0)) {
#line 343
    return (-1);
  }
  {
#line 345
  tmp = fileno(f);
#line 345
  fstat(tmp, & st);
#line 346
  plen = (int )st.st_size;
  }
#line 356
  if (plen != (plen / 2) * 2) {
    {
#line 357
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"filesize not even\n");
    }
#line 358
    return (-1);
  }
  {
#line 361
  tmp___0 = malloc((size_t )plen);
#line 361
  packed = (uint8 *)tmp___0;
  }
#line 362
  if (! packed) {
    {
#line 363
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"can\'t allocate memory for packed data\n");
    }
#line 364
    return (-1);
  }
  {
#line 367
  fread((void */* __restrict  */)packed, (size_t )plen, (size_t )1, (FILE */* __restrict  */)f);
  }
#line 379
  if ((int )*(packed + 4) < 9) {
    {
#line 380
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"invalid efficiency\n");
    }
#line 381
    return (-1);
  } else
#line 379
  if ((int )*(packed + 5) < 9) {
    {
#line 380
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"invalid efficiency\n");
    }
#line 381
    return (-1);
  } else
#line 379
  if ((int )*(packed + 6) < 9) {
    {
#line 380
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"invalid efficiency\n");
    }
#line 381
    return (-1);
  } else
#line 379
  if ((int )*(packed + 7) < 9) {
    {
#line 380
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"invalid efficiency\n");
    }
#line 381
    return (-1);
  }
#line 385
  if (((unsigned int )(((((int )*((packed + 4) + 0) << 16) | ((int )*((packed + 4) + 1) << 8)) | (int )*((packed + 4) + 2)) * 256 + (int )*(packed + 7)) & 4042322160U) != 0U) {
    {
#line 386
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"invalid efficiency(?)\n");
    }
#line 387
    return (-1);
  }
#line 390
  unplen = (((int )*(((packed + plen) - 4) + 0) << 16) | ((int )*(((packed + plen) - 4) + 1) << 8)) | (int )*(((packed + plen) - 4) + 2);
#line 391
  if (! unplen) {
    {
#line 392
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"not a powerpacked file\n");
    }
#line 393
    return (-1);
  }
  {
#line 396
  tmp___1 = ppdepack(packed, (size_t )plen, fo);
  }
#line 396
  if (tmp___1 == -1) {
    {
#line 397
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"error while decrunching data...");
    }
#line 398
    return (-1);
  }
  {
#line 401
  free((void *)packed);
  }
#line 403
  return (0);
}
}
#line 283 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) FILE *fdopen(int __fd , char const   *__modes ) ;
#line 846
extern FILE *popen(char const   *__command , char const   *__modes ) ;
#line 852
extern int pclose(FILE *__stream ) ;
#line 615 "/usr/include/stdlib.h"
extern int ( __attribute__((__nonnull__(1))) mkstemp)(char *__template ) ;
#line 173 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1))) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 842 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) unlink)(char const   *__name ) ;
#line 198 "src/include/xmp.h"
char *global_filename  ;
#line 202
void xmp_unlink_tempfiles(void) ;
#line 208
int xmp_test_module(xmp_context ctx___0 , char *s , char *n___0 ) ;
#line 83 "src/include/list.h"
__inline static void __list_del(struct list_head *prev , struct list_head *next ) 
{ 


  {
#line 86
  next->prev = prev;
#line 87
  prev->next = next;
#line 88
  return;
}
}
#line 94 "src/include/list.h"
__inline static void list_del(struct list_head *entry ) 
{ 


  {
  {
#line 96
  __list_del(entry->prev, entry->next);
  }
#line 97
  return;
}
}
#line 311 "src/include/common.h"
uint32 readmem32l(uint8 *m___0 ) ;
#line 32 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/misc/load.c"
int pw_enable(char *id , int enable ) ;
#line 36 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/misc/load.c"
struct list_head tmpfiles_list  =    {& tmpfiles_list, & tmpfiles_list};
#line 77 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/misc/load.c"
static int decrunch___0(struct xmp_context *ctx___0 , FILE **f , char **s ) 
{ 
  struct xmp_options *o___0 ;
  unsigned char b___1[1024] ;
  char *cmd ;
  FILE *t ;
  int fd___1 ;
  int builtin ;
  int res ;
  char *packer ;
  char *temp2 ;
  char tmp[4096] ;
  struct tmpfilename *temp ;
  int tmp___0 ;
  int tmp___1 ;
  int x ;
  int i___3 ;
  int flag ;
  long size___0 ;
  unsigned short const   **tmp___2 ;
  uint32 tmp___3 ;
  void *tmp___4 ;
  int n___0 ;
  int lsize ;
  char *line ;
  char *buf___1 ;
  FILE *p ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  size_t tmp___9 ;
  void *__cil_tmp34 ;
  void *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;
  char *__cil_tmp66 ;
  char *__cil_tmp67 ;
  char *__cil_tmp68 ;
  char *__cil_tmp69 ;
  char *__cil_tmp70 ;
  char *__cil_tmp71 ;
  char *__cil_tmp72 ;
  char *__cil_tmp73 ;
  char *__cil_tmp74 ;
  char *__cil_tmp75 ;
  char *__cil_tmp76 ;
  char *__cil_tmp77 ;

  {
  {
#line 79
  o___0 = & ctx___0->o;
#line 87
  cmd = (char *)((void *)0);
#line 87
  packer = cmd;
#line 88
  res = 0;
#line 88
  builtin = res;
#line 89
  get_temp_dir(tmp, 4096);
#line 90
  strncat((char */* __restrict  */)(tmp), (char const   */* __restrict  */)"xmp_XXXXXX",
          (size_t )4096);
#line 92
  fseek(*f, 0L, 0);
#line 93
  fread((void */* __restrict  */)(b___1), (size_t )1, (size_t )1024, (FILE */* __restrict  */)*f);
  }
#line 100
  if ((int )b___1[0] == 80) {
#line 100
    if ((int )b___1[1] == 75) {
#line 101
      packer = (char *)"Zip";
#line 106
      cmd = (char *)"unzip -pqqC \"%s\" -x readme \'*.diz\' \'*.nfo\' \'*.txt\' \'*.exe\' \'*.com\' README \'*.DIZ\' \'*.NFO\' \'*.TXT\' \'*.EXE\' \'*.COM\' 2>/dev/null";
    } else {
#line 100
      goto _L___51;
    }
  } else
  _L___51: /* CIL Label */ 
#line 110
  if ((int )b___1[2] == 45) {
#line 110
    if ((int )b___1[3] == 108) {
#line 110
      if ((int )b___1[4] == 104) {
#line 111
        packer = (char *)"LHa";
#line 117
        cmd = (char *)"lha -pq \"%s\"";
      } else {
#line 110
        goto _L___50;
      }
    } else {
#line 110
      goto _L___50;
    }
  } else
  _L___50: /* CIL Label */ 
#line 119
  if ((int )b___1[0] == 31) {
#line 119
    if ((int )b___1[1] == 139) {
#line 120
      packer = (char *)"gzip";
#line 121
      cmd = (char *)"gzip -dc \"%s\"";
    } else {
#line 119
      goto _L___48;
    }
  } else
  _L___48: /* CIL Label */ 
#line 122
  if ((int )b___1[0] == 66) {
#line 122
    if ((int )b___1[1] == 90) {
#line 122
      if ((int )b___1[2] == 104) {
#line 123
        packer = (char *)"bzip2";
#line 124
        cmd = (char *)"bzip2 -dc \"%s\"";
      } else {
#line 122
        goto _L___47;
      }
    } else {
#line 122
      goto _L___47;
    }
  } else
  _L___47: /* CIL Label */ 
#line 125
  if ((int )b___1[0] == 93) {
#line 125
    if ((int )b___1[1] == 0) {
#line 125
      if ((int )b___1[2] == 0) {
#line 125
        if ((int )b___1[3] == 128) {
#line 126
          packer = (char *)"lzma";
#line 127
          cmd = (char *)"lzma -dc \"%s\"";
        } else {
#line 125
          goto _L___45;
        }
      } else {
#line 125
        goto _L___45;
      }
    } else {
#line 125
      goto _L___45;
    }
  } else
  _L___45: /* CIL Label */ 
#line 128
  if ((int )b___1[0] == 253) {
#line 128
    if ((int )b___1[3] == 88) {
#line 128
      if ((int )b___1[4] == 90) {
#line 128
        if ((int )b___1[5] == 0) {
#line 129
          packer = (char *)"xz";
#line 130
          cmd = (char *)"xz -dc \"%s\"";
        } else {
#line 128
          goto _L___42;
        }
      } else {
#line 128
        goto _L___42;
      }
    } else {
#line 128
      goto _L___42;
    }
  } else
  _L___42: /* CIL Label */ 
#line 131
  if ((int )b___1[0] == 90) {
#line 131
    if ((int )b___1[1] == 79) {
#line 131
      if ((int )b___1[2] == 79) {
#line 131
        if ((int )b___1[3] == 32) {
#line 132
          packer = (char *)"zoo";
#line 133
          cmd = (char *)"zoo xpq \"%s\"";
        } else {
#line 131
          goto _L___39;
        }
      } else {
#line 131
        goto _L___39;
      }
    } else {
#line 131
      goto _L___39;
    }
  } else
  _L___39: /* CIL Label */ 
#line 134
  if ((int )b___1[0] == 77) {
#line 134
    if ((int )b___1[1] == 79) {
#line 134
      if ((int )b___1[2] == 51) {
#line 135
        packer = (char *)"MO3";
#line 136
        cmd = (char *)"unmo3 -s \"%s\" STDOUT";
      } else {
#line 134
        goto _L___36;
      }
    } else {
#line 134
      goto _L___36;
    }
  } else
  _L___36: /* CIL Label */ 
#line 137
  if ((int )b___1[0] == 31) {
#line 137
    if ((int )b___1[1] == 157) {
#line 138
      packer = (char *)"compress";
#line 143
      cmd = (char *)"uncompress -c \"%s\"";
    } else {
#line 137
      goto _L___34;
    }
  } else
  _L___34: /* CIL Label */ 
#line 144
  if ((int )b___1[0] == 80) {
#line 144
    if ((int )b___1[1] == 80) {
#line 144
      if ((int )b___1[2] == 50) {
#line 144
        if ((int )b___1[3] == 48) {
#line 145
          packer = (char *)"PowerPack";
#line 146
          builtin = 1;
        } else {
#line 144
          goto _L___33;
        }
      } else {
#line 144
        goto _L___33;
      }
    } else {
#line 144
      goto _L___33;
    }
  } else
  _L___33: /* CIL Label */ 
#line 147
  if ((int )b___1[0] == 88) {
#line 147
    if ((int )b___1[1] == 80) {
#line 147
      if ((int )b___1[2] == 75) {
#line 147
        if ((int )b___1[3] == 70) {
#line 147
          if ((int )b___1[8] == 83) {
#line 147
            if ((int )b___1[9] == 81) {
#line 147
              if ((int )b___1[10] == 83) {
#line 147
                if ((int )b___1[11] == 72) {
#line 149
                  packer = (char *)"SQSH";
#line 150
                  builtin = 2;
                } else {
#line 147
                  goto _L___30;
                }
              } else {
#line 147
                goto _L___30;
              }
            } else {
#line 147
              goto _L___30;
            }
          } else {
#line 147
            goto _L___30;
          }
        } else {
#line 147
          goto _L___30;
        }
      } else {
#line 147
        goto _L___30;
      }
    } else {
#line 147
      goto _L___30;
    }
  } else {
    _L___30: /* CIL Label */ 
    {
#line 151
    tmp___1 = memcmp((void const   *)(b___1), (void const   *)"Archive\000", (size_t )8);
    }
#line 151
    if (tmp___1) {
#line 154
      if ((int )b___1[0] == 122) {
#line 154
        if ((int )b___1[1] == 105) {
#line 154
          if ((int )b___1[2] == 82) {
#line 154
            if ((int )b___1[3] == 67) {
#line 154
              if ((int )b___1[4] == 79) {
#line 154
                if ((int )b___1[5] == 78) {
#line 154
                  if ((int )b___1[6] == 105) {
#line 154
                    if ((int )b___1[7] == 97) {
#line 156
                      packer = (char *)"MMCMP";
#line 157
                      builtin = 3;
                    } else {
#line 154
                      goto _L___23;
                    }
                  } else {
#line 154
                    goto _L___23;
                  }
                } else {
#line 154
                  goto _L___23;
                }
              } else {
#line 154
                goto _L___23;
              }
            } else {
#line 154
              goto _L___23;
            }
          } else {
#line 154
            goto _L___23;
          }
        } else {
#line 154
          goto _L___23;
        }
      } else
      _L___23: /* CIL Label */ 
#line 158
      if ((int )b___1[0] == 77) {
#line 158
        if ((int )b___1[1] == 85) {
#line 158
          if ((int )b___1[2] == 83) {
#line 158
            if ((int )b___1[3] == 69) {
#line 158
              if ((int )b___1[4] == 222) {
#line 158
                if ((int )b___1[5] == 173) {
#line 158
                  if ((int )b___1[6] == 190) {
#line 158
                    if ((int )b___1[7] == 175) {
#line 160
                      packer = (char *)"J2B MUSE";
#line 161
                      builtin = 10;
                    } else {
#line 158
                      goto _L___16;
                    }
                  } else {
#line 158
                    goto _L___16;
                  }
                } else {
#line 158
                  goto _L___16;
                }
              } else {
#line 158
                goto _L___16;
              }
            } else {
#line 158
              goto _L___16;
            }
          } else {
#line 158
            goto _L___16;
          }
        } else {
#line 158
          goto _L___16;
        }
      } else
      _L___16: /* CIL Label */ 
#line 162
      if ((int )b___1[0] == 77) {
#line 162
        if ((int )b___1[1] == 85) {
#line 162
          if ((int )b___1[2] == 83) {
#line 162
            if ((int )b___1[3] == 69) {
#line 162
              if ((int )b___1[4] == 222) {
#line 162
                if ((int )b___1[5] == 173) {
#line 162
                  if ((int )b___1[6] == 186) {
#line 162
                    if ((int )b___1[7] == 190) {
#line 164
                      packer = (char *)"MOD2J2B MUSE";
#line 165
                      builtin = 10;
                    } else {
#line 162
                      goto _L___9;
                    }
                  } else {
#line 162
                    goto _L___9;
                  }
                } else {
#line 162
                  goto _L___9;
                }
              } else {
#line 162
                goto _L___9;
              }
            } else {
#line 162
              goto _L___9;
            }
          } else {
#line 162
            goto _L___9;
          }
        } else {
#line 162
          goto _L___9;
        }
      } else
      _L___9: /* CIL Label */ 
#line 166
      if ((int )b___1[0] == 76) {
#line 166
        if ((int )b___1[1] == 90) {
#line 166
          if ((int )b___1[2] == 88) {
#line 167
            packer = (char *)"LZX";
#line 168
            builtin = 11;
          } else {
#line 166
            goto _L___2;
          }
        } else {
#line 166
          goto _L___2;
        }
      } else
      _L___2: /* CIL Label */ 
#line 169
      if ((int )b___1[0] == 82) {
#line 169
        if ((int )b___1[1] == 97) {
#line 169
          if ((int )b___1[2] == 114) {
#line 170
            packer = (char *)"rar";
#line 171
            cmd = (char *)"unrar p -inul -xreadme -x*.diz -x*.nfo -x*.txt -x*.exe -x*.com \"%s\"";
          } else {
#line 169
            goto _L___0;
          }
        } else {
#line 169
          goto _L___0;
        }
      } else {
        _L___0: /* CIL Label */ 
        {
#line 174
        tmp___0 = test_oxm(*f);
        }
#line 174
        if (tmp___0 == 0) {
#line 175
          packer = (char *)"oggmod";
#line 176
          builtin = 8;
        }
      }
    } else {
#line 152
      packer = (char *)"ArcFS";
#line 153
      builtin = 6;
    }
  }
#line 180
  if ((unsigned long )packer == (unsigned long )((void *)0)) {
#line 180
    if ((int )b___1[0] == 26) {
#line 181
      x = (int )b___1[1] & 127;
#line 182
      flag = 0;
#line 186
      i___3 = 0;
      {
#line 186
      while (1) {
        while_continue: /* CIL Label */ ;
#line 186
        if (! (i___3 < 13)) {
#line 186
          goto while_break;
        }
#line 187
        if ((int )b___1[2 + i___3] == 0) {
#line 188
          if (i___3 == 0) {
#line 189
            flag = 1;
          }
#line 190
          goto while_break;
        }
        {
#line 192
        tmp___2 = __ctype_b_loc();
        }
#line 192
        if (! ((int const   )*(*tmp___2 + (int )b___1[2 + i___3]) & 16384)) {
#line 193
          flag = 1;
#line 194
          goto while_break;
        }
#line 186
        i___3 ++;
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 198
      tmp___3 = readmem32l(b___1 + 15);
#line 198
      size___0 = (long )tmp___3;
      }
#line 199
      if (size___0 < 0L) {
#line 200
        flag = 1;
      } else
#line 199
      if (size___0 > 524288L) {
#line 200
        flag = 1;
      }
#line 202
      if (flag == 0) {
#line 203
        if (x >= 1) {
#line 203
          if (x <= 9) {
#line 203
            if (x != 7) {
#line 204
              packer = (char *)"Arc";
#line 205
              builtin = 5;
            } else {
#line 203
              goto _L___53;
            }
          } else {
#line 203
            goto _L___53;
          }
        } else
        _L___53: /* CIL Label */ 
#line 206
        if (x == 127) {
#line 207
          packer = (char *)"!Spark";
#line 208
          builtin = 5;
        }
      }
    }
  }
  {
#line 213
  fseek(*f, 0L, 0);
  }
#line 215
  if ((unsigned long )packer == (unsigned long )((void *)0)) {
#line 216
    return (0);
  }
  {
#line 218
  reportv(ctx___0, 0, (char *)"Depacking %s file... ", packer);
#line 220
  tmp___4 = calloc((size_t )sizeof(struct tmpfilename ), (size_t )1);
#line 220
  temp = (struct tmpfilename *)tmp___4;
  }
#line 221
  if (! temp) {
    {
#line 222
    report((char *)"calloc failed\n");
    }
#line 223
    goto err;
  }
  {
#line 226
  temp->name = strdup((char const   *)(tmp));
#line 227
  fd___1 = mkstemp(temp->name);
  }
#line 227
  if (fd___1 < 0) {
#line 228
    if (o___0->verbosity > 0) {
      {
#line 229
      report((char *)"failed\n");
      }
    }
#line 230
    goto err;
  }
  {
#line 233
  list_add_tail(& temp->list, & tmpfiles_list);
#line 235
  t = fdopen(fd___1, "w+b");
  }
#line 235
  if ((unsigned long )t == (unsigned long )((void *)0)) {
    {
#line 236
    reportv(ctx___0, 0, (char *)"failed\n");
    }
#line 237
    goto err;
  }
#line 240
  if (cmd) {
    {
#line 245
    tmp___5 = strlen((char const   *)cmd);
#line 245
    tmp___6 = strlen((char const   *)*s);
#line 245
    lsize = (int )((tmp___5 + tmp___6) + 16U);
#line 246
    tmp___7 = malloc((size_t )lsize);
#line 246
    line = (char *)tmp___7;
#line 247
    snprintf((char */* __restrict  */)line, (size_t )lsize, (char const   */* __restrict  */)cmd,
             *s);
#line 260
    p = popen((char const   *)line, "r");
    }
#line 260
    if ((unsigned long )p == (unsigned long )((void *)0)) {
      {
#line 262
      reportv(ctx___0, 0, (char *)"failed\n");
#line 263
      fclose(t);
#line 264
      free((void *)line);
      }
#line 265
      goto err;
    }
    {
#line 267
    free((void *)line);
#line 269
    tmp___8 = malloc((size_t )16384);
#line 269
    buf___1 = (char *)tmp___8;
    }
#line 269
    if ((unsigned long )buf___1 == (unsigned long )((void *)0)) {
      {
#line 270
      reportv(ctx___0, 0, (char *)"failed\n");
#line 271
      pclose(p);
#line 272
      fclose(t);
      }
#line 273
      goto err;
    }
    {
#line 275
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 275
      tmp___9 = fread((void */* __restrict  */)buf___1, (size_t )1, (size_t )16384,
                      (FILE */* __restrict  */)p);
#line 275
      n___0 = (int )tmp___9;
      }
#line 275
      if (! (n___0 > 0)) {
#line 275
        goto while_break___0;
      }
      {
#line 276
      fwrite((void const   */* __restrict  */)buf___1, (size_t )1, (size_t )n___0,
             (FILE */* __restrict  */)t);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 278
    free((void *)buf___1);
#line 279
    pclose(p);
    }
  } else {
    {
#line 282
    if (builtin == 1) {
#line 282
      goto case_1;
    }
#line 285
    if (builtin == 5) {
#line 285
      goto case_5;
    }
#line 288
    if (builtin == 6) {
#line 288
      goto case_6;
    }
#line 291
    if (builtin == 2) {
#line 291
      goto case_2;
    }
#line 294
    if (builtin == 3) {
#line 294
      goto case_3;
    }
#line 297
    if (builtin == 10) {
#line 297
      goto case_10;
    }
#line 300
    if (builtin == 11) {
#line 300
      goto case_11;
    }
#line 304
    if (builtin == 8) {
#line 304
      goto case_8;
    }
#line 281
    goto switch_break;
    case_1: /* CIL Label */ 
    {
#line 283
    res = decrunch_pp(*f, t);
    }
#line 284
    goto switch_break;
    case_5: /* CIL Label */ 
    {
#line 286
    res = decrunch_arc(*f, t);
    }
#line 287
    goto switch_break;
    case_6: /* CIL Label */ 
    {
#line 289
    res = decrunch_arcfs(*f, t);
    }
#line 290
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 292
    res = decrunch_sqsh(*f, t);
    }
#line 293
    goto switch_break;
    case_3: /* CIL Label */ 
    {
#line 295
    res = decrunch_mmcmp(*f, t);
    }
#line 296
    goto switch_break;
    case_10: /* CIL Label */ 
    {
#line 298
    res = decrunch_muse(*f, t);
    }
#line 299
    goto switch_break;
    case_11: /* CIL Label */ 
    {
#line 301
    res = decrunch_lzx(*f, t);
    }
#line 302
    goto switch_break;
    case_8: /* CIL Label */ 
    {
#line 305
    res = decrunch_oxm(*f, t);
    }
#line 306
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
#line 316
  if (res < 0) {
    {
#line 317
    reportv(ctx___0, 0, (char *)"failed\n");
    }
#line 318
    goto err;
  }
  {
#line 321
  reportv(ctx___0, 0, (char *)"done\n");
#line 323
  fclose(*f);
#line 324
  *f = t;
#line 326
  temp2 = strdup((char const   *)temp->name);
#line 327
  decrunch___0(ctx___0, f, & temp->name);
#line 328
  unlink((char const   *)temp2);
#line 329
  free((void *)temp2);
  }
#line 337
  return (1);
  err: 
#line 340
  return (-1);
}
}
#line 348 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/misc/load.c"
void xmp_unlink_tempfiles(void) 
{ 
  struct tmpfilename *li ;
  struct list_head *tmp ;

  {
#line 354
  tmp = tmpfiles_list.next;
  {
#line 354
  while (1) {
    while_continue: /* CIL Label */ ;
#line 354
    if (! ((unsigned long )tmp != (unsigned long )(& tmpfiles_list))) {
#line 354
      goto while_break;
    }
#line 355
    li = (struct tmpfilename *)((char *)tmp - (unsigned long )(& ((struct tmpfilename *)0)->list));
    {
#line 356
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 356
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 357
    unlink((char const   *)li->name);
#line 358
    free((void *)li->name);
#line 359
    list_del(& li->list);
#line 360
    tmp = tmp->next;
#line 361
    free((void *)li);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 363
  return;
}
}
#line 366 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/misc/load.c"
static void get_smp_size(struct xmp_player_context *p , int awe , int *a , int *b___1 ) 
{ 
  int i___3 ;
  int len ;
  int smp_size ;
  int smp_4kb ;

  {
#line 370
  i___3 = 0;
#line 370
  smp_size = i___3;
#line 370
  smp_4kb = smp_size;
  {
#line 370
  while (1) {
    while_continue: /* CIL Label */ ;
#line 370
    if (! (i___3 < (p->m.xxh)->smp)) {
#line 370
      goto while_break;
    }
#line 371
    len = (p->m.xxs + i___3)->len;
#line 376
    if (awe) {
#line 377
      if ((p->m.xxs + i___3)->flg & 8) {
#line 378
        len += (p->m.xxs + i___3)->lpe - (p->m.xxs + i___3)->lps;
      }
#line 379
      if (awe) {
#line 379
        if (~ (p->m.xxs + i___3)->flg & 1) {
#line 380
          len <<= 1;
        }
      }
    }
#line 383
    len = (int )((unsigned long )len + sizeof(int ));
#line 383
    smp_size += len;
#line 384
    if (len < 4096) {
#line 385
      smp_4kb += len;
    }
#line 370
    i___3 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 388
  *a = smp_size;
#line 389
  *b___1 = smp_4kb;
#line 390
  return;
}
}
#line 393 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/misc/load.c"
static int crunch_ratio(struct xmp_context *ctx___0 , int awe ) 
{ 
  struct xmp_player_context *p ;
  struct xmp_driver_context *d ;
  struct xmp_options *o___0 ;
  int memavl ;
  int smp_size ;
  int ratio ;
  int smp_4kb ;
  char *__cil_tmp10 ;

  {
#line 395
  p = & ctx___0->p;
#line 396
  d = & ctx___0->d;
#line 397
  o___0 = & ctx___0->o;
#line 400
  ratio = 65536;
#line 401
  memavl = d->memavl;
#line 403
  if (memavl == 0) {
#line 404
    return (ratio);
  }
  {
#line 406
  memavl = (memavl * 100) / (100 + o___0->crunch);
#line 408
  get_smp_size(p, awe, & smp_size, & smp_4kb);
  }
#line 410
  if (smp_size > memavl) {
#line 411
    if (! awe) {
      {
#line 412
      xmp_cvt_to8bit(ctx___0);
      }
    }
    {
#line 413
    get_smp_size(p, awe, & smp_size, & smp_4kb);
    }
  }
#line 416
  if (smp_size > memavl) {
#line 417
    ratio = (int )(((int64 )(memavl - smp_4kb) << 16) / (int64 )(smp_size - smp_4kb));
#line 419
    if (o___0->verbosity) {
      {
#line 420
      report((char *)"Crunch ratio   : %d%% [Mem:%.3fMb Smp:%.3fMb]\n", 100 - (100 * ratio) / 65536,
             .000001 * (double )d->memavl, .000001 * (double )smp_size);
      }
    }
  }
#line 425
  return (ratio);
}
}
#line 429 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/misc/load.c"
int xmp_test_module(xmp_context ctx___0 , char *s , char *n___0 ) 
{ 
  FILE *f ;
  struct xmp_loader_info *li ;
  struct list_head *head ;
  struct stat st ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  void *__cil_tmp14 ;
  void *__cil_tmp15 ;
  void *__cil_tmp16 ;
  void *__cil_tmp17 ;
  char *__cil_tmp18 ;

  {
  {
#line 436
  f = fopen((char const   */* __restrict  */)s, (char const   */* __restrict  */)"rb");
  }
#line 436
  if ((unsigned long )f == (unsigned long )((void *)0)) {
#line 437
    return (-3);
  }
  {
#line 439
  tmp = fileno(f);
#line 439
  tmp___0 = fstat(tmp, & st);
  }
#line 439
  if (tmp___0 < 0) {
#line 440
    goto err;
  }
#line 442
  if ((st.st_mode & 61440U) == 16384U) {
#line 443
    goto err;
  }
  {
#line 445
  tmp___1 = decrunch___0((struct xmp_context *)ctx___0, & f, & s);
  }
#line 445
  if (tmp___1 < 0) {
#line 446
    goto err;
  }
  {
#line 448
  tmp___2 = fileno(f);
#line 448
  tmp___3 = fstat(tmp___2, & st);
  }
#line 448
  if (tmp___3 < 0) {
#line 449
    goto err;
  }
#line 451
  head = loader_list.next;
  {
#line 451
  while (1) {
    while_continue: /* CIL Label */ ;
#line 451
    if (! ((unsigned long )head != (unsigned long )(& loader_list))) {
#line 451
      goto while_break;
    }
#line 452
    li = (struct xmp_loader_info *)((char *)head - (unsigned long )(& ((struct xmp_loader_info *)0)->list));
#line 453
    if (li->enable) {
      {
#line 454
      fseek(f, 0L, 0);
#line 455
      tmp___4 = (*(li->test))(f, n___0, (int const   )0);
      }
#line 455
      if (tmp___4 == 0) {
        {
#line 456
        fclose(f);
#line 457
        xmp_unlink_tempfiles();
        }
#line 458
        return (0);
      }
    }
#line 451
    head = head->next;
  }
  while_break: /* CIL Label */ ;
  }
  err: 
  {
#line 464
  fclose(f);
  }
#line 465
  return (-1);
}
}
#line 469 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/misc/load.c"
static void split_name(char *s , char **d , char **b___1 ) 
{ 
  char tmp ;
  char *div___0 ;
  char *__cil_tmp6 ;

  {
  {
#line 473
  while (1) {
    while_continue: /* CIL Label */ ;
#line 473
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 474
  div___0 = strrchr((char const   *)s, '/');
  }
#line 474
  if (div___0) {
    {
#line 475
    tmp = *(div___0 + 1);
#line 476
    *(div___0 + 1) = (char)0;
#line 477
    *d = strdup((char const   *)s);
#line 478
    *(div___0 + 1) = tmp;
#line 479
    *b___1 = strdup((char const   *)(div___0 + 1));
    }
  } else {
    {
#line 481
    *d = strdup("");
#line 482
    *b___1 = strdup((char const   *)s);
    }
  }
#line 484
  return;
}
}
#line 487 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/misc/load.c"
int xmp_load_module(xmp_context ctx___0 , char *s ) 
{ 
  FILE *f ;
  int i___3 ;
  int t ;
  struct xmp_loader_info *li ;
  struct list_head *head ;
  struct stat st ;
  struct xmp_player_context *p ;
  struct xmp_driver_context *d ;
  struct xmp_mod_context *m___0 ;
  struct xmp_options *o___0 ;
  uint32 crc___0 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  char const   *tmp___8 ;
  char const   *tmp___9 ;
  char *amp_factor[4] ;
  char const   *tmp___10 ;
  char const   *tmp___11 ;
  int tmp___12 ;
  void *__cil_tmp29 ;
  void *__cil_tmp30 ;
  void *__cil_tmp31 ;
  void *__cil_tmp32 ;
  void *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;

  {
#line 494
  p = & ((struct xmp_context *)ctx___0)->p;
#line 495
  d = & ((struct xmp_context *)ctx___0)->d;
#line 496
  m___0 = & p->m;
#line 497
  o___0 = & ((struct xmp_context *)ctx___0)->o;
#line 498
  crc___0 = (uint32 )0;
  {
#line 500
  while (1) {
    while_continue: /* CIL Label */ ;
#line 500
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 502
  f = fopen((char const   */* __restrict  */)s, (char const   */* __restrict  */)"rb");
  }
#line 502
  if ((unsigned long )f == (unsigned long )((void *)0)) {
#line 503
    return (-3);
  }
  {
#line 505
  tmp = fileno(f);
#line 505
  tmp___0 = fstat(tmp, & st);
  }
#line 505
  if (tmp___0 < 0) {
#line 506
    goto err;
  }
#line 508
  if ((st.st_mode & 61440U) == 16384U) {
#line 509
    goto err;
  }
  {
#line 511
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 511
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 512
  t = decrunch___0((struct xmp_context *)ctx___0, & f, & s);
  }
#line 512
  if (t < 0) {
#line 513
    goto err;
  }
  {
#line 515
  tmp___1 = fileno(f);
#line 515
  tmp___2 = fstat(tmp___1, & st);
  }
#line 515
  if (tmp___2 < 0) {
#line 516
    goto err;
  }
  {
#line 518
  split_name(s, & m___0->dirname, & m___0->basename);
  }
  {
#line 520
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 520
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 521
  xmp_drv_clearmem((struct xmp_context *)ctx___0);
#line 524
  memset((void *)(m___0->name), 0, (size_t )64);
#line 525
  memset((void *)(m___0->type), 0, (size_t )64);
#line 526
  memset((void *)(m___0->author), 0, (size_t )64);
#line 527
  m___0->filename = s;
#line 528
  m___0->size = (int )st.st_size;
#line 529
  m___0->rrate = 250.0;
#line 530
  m___0->c4rate = 8287;
#line 531
  m___0->volbase = 64;
#line 532
  m___0->volume = 64;
#line 533
  m___0->vol_xlat = (int *)((void *)0);
#line 535
  m___0->flags = o___0->flags & ~ (1 << 8);
#line 536
  m___0->quirk = o___0->quirk;
#line 537
  m___0->comment = (char *)((void *)0);
#line 539
  tmp___3 = calloc((size_t )sizeof(struct xxm_header ), (size_t )1);
#line 539
  m___0->xxh = (struct xxm_header *)tmp___3;
#line 541
  (m___0->xxh)->tpo = 6;
#line 542
  (m___0->xxh)->bpm = 125;
#line 543
  (m___0->xxh)->chn = 4;
#line 545
  i___3 = 0;
  }
  {
#line 545
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 545
    if (! (i___3 < 64)) {
#line 545
      goto while_break___2;
    }
#line 546
    m___0->xxc[i___3].pan = (((i___3 + 1) / 2) % 2) * 255;
#line 547
    m___0->xxc[i___3].vol = 64;
#line 548
    m___0->xxc[i___3].flg = 0;
#line 545
    i___3 ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 551
  m___0->verbosity = o___0->verbosity;
  {
#line 553
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 553
    goto while_break___3;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 554
  head = loader_list.next;
  {
#line 554
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 554
    if (! ((unsigned long )head != (unsigned long )(& loader_list))) {
#line 554
      goto while_break___4;
    }
#line 555
    li = (struct xmp_loader_info *)((char *)head - (unsigned long )(& ((struct xmp_loader_info *)0)->list));
    {
#line 557
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 557
      goto while_break___5;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 558
    if (li->enable == 0) {
#line 559
      goto __Cont;
    }
    {
#line 560
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 560
      goto while_break___6;
    }
    while_break___6: /* CIL Label */ ;
    }
#line 562
    if (o___0->verbosity > 3) {
      {
#line 563
      report((char *)"Test format: %s (%s)\n", li->id, li->name);
      }
    }
    {
#line 564
    fseek(f, 0L, 0);
#line 565
    i___3 = (*(li->test))(f, (char *)((void *)0), (int const   )0);
    }
#line 565
    if (i___3 == 0) {
#line 566
      if (o___0->verbosity > 3) {
        {
#line 567
        report((char *)"Identified as %s\n", li->id);
        }
      }
      {
#line 568
      fseek(f, 0L, 0);
      }
      {
#line 569
      while (1) {
        while_continue___7: /* CIL Label */ ;
#line 569
        goto while_break___7;
      }
      while_break___7: /* CIL Label */ ;
      }
      {
#line 570
      tmp___5 = (*(li->loader))((struct xmp_context *)ctx___0, f, (int const   )0);
#line 570
      i___3 = tmp___5 == 0;
      }
#line 570
      if (i___3) {
        {
#line 571
        tmp___4 = cksum(f);
#line 571
        crc___0 = (uint32 )tmp___4;
        }
#line 572
        goto while_break___4;
      }
    }
    __Cont: /* CIL Label */ 
#line 554
    head = head->next;
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 577
  fclose(f);
#line 578
  xmp_unlink_tempfiles();
  }
#line 580
  if (i___3 < 0) {
    {
#line 581
    free((void *)m___0->basename);
#line 582
    free((void *)m___0->dirname);
#line 583
    free((void *)m___0->xxh);
    }
#line 584
    return (i___3);
  }
  {
#line 587
  _xmp_read_modconf((struct xmp_context *)ctx___0, crc___0, st.st_size);
#line 589
  i___3 = 0;
  }
  {
#line 589
  while (1) {
    while_continue___8: /* CIL Label */ ;
#line 589
    if (! (i___3 < 64)) {
#line 589
      goto while_break___8;
    }
#line 590
    m___0->xxc[i___3].cho = o___0->chorus;
#line 591
    m___0->xxc[i___3].rvb = o___0->reverb;
#line 589
    i___3 ++;
  }
  while_break___8: /* CIL Label */ ;
  }
#line 594
  if (d->description) {
    {
#line 594
    tmp___6 = strstr((char const   *)d->description, " [AWE");
#line 594
    i___3 = (unsigned long )tmp___6 != (unsigned long )((void *)0);
    }
#line 594
    if (i___3) {
      {
#line 595
      xmp_cvt_to16bit((struct xmp_context *)ctx___0);
#line 596
      xmp_cvt_bid2und((struct xmp_context *)ctx___0);
      }
    }
  }
  {
#line 599
  tmp___7 = crunch_ratio((struct xmp_context *)ctx___0, i___3);
#line 599
  xmp_drv_flushpatch((struct xmp_context *)ctx___0, tmp___7);
  }
#line 605
  if ((m___0->xxh)->rst >= (m___0->xxh)->len) {
#line 606
    (m___0->xxh)->rst = 0;
  }
  {
#line 609
  m___0->flags &= ~ (~ o___0->flags & (1 << 8));
#line 611
  str_adj(m___0->name);
  }
#line 612
  if (! m___0->name[0]) {
    {
#line 613
    strncpy((char */* __restrict  */)(m___0->name), (char const   */* __restrict  */)m___0->basename,
            (size_t )64);
    }
  }
#line 615
  if (o___0->verbosity > 1) {
#line 616
    if (m___0->flags & (1 << 3)) {
#line 616
      tmp___8 = "yes";
    } else {
#line 616
      tmp___8 = "no";
    }
    {
#line 616
    report((char *)"Module looping : %s\n", tmp___8);
    }
#line 618
    if ((m___0->xxh)->flg & 1) {
#line 618
      tmp___9 = "linear";
    } else {
#line 618
      tmp___9 = "Amiga";
    }
    {
#line 618
    report((char *)"Period mode    : %s\n", tmp___9);
    }
  }
#line 622
  if (o___0->verbosity > 2) {
#line 623
    amp_factor[0] = (char *)"Normal";
#line 623
    amp_factor[1] = (char *)"x2";
#line 623
    amp_factor[2] = (char *)"x4";
#line 623
    amp_factor[3] = (char *)"x8";
#line 624
    if ((m___0->xxh)->flg & 2) {
#line 624
      tmp___10 = "yes";
    } else {
#line 624
      tmp___10 = "no";
    }
    {
#line 624
    report((char *)"Amiga range    : %s\n", tmp___10);
#line 626
    report((char *)"Restart pos    : %d\n", (m___0->xxh)->rst);
#line 627
    report((char *)"Base volume    : %d\n", m___0->volbase);
#line 628
    report((char *)"C4 replay rate : %d\n", m___0->c4rate);
    }
#line 629
    if (m___0->flags & (1 << 6)) {
#line 629
      tmp___11 = "enabled";
    } else {
#line 629
      tmp___11 = "disabled";
    }
#line 629
    if (m___0->flags & (1 << 1)) {
#line 629
      tmp___12 = - o___0->mix;
    } else {
#line 629
      tmp___12 = o___0->mix;
    }
    {
#line 629
    report((char *)"Channel mixing : %d%% (dynamic pan %s)\n", tmp___12, tmp___11);
#line 632
    report((char *)"Checksum       : %u %ld\n", crc___0, st.st_size);
#line 633
    report((char *)"Volume amplify : %s\n", amp_factor[o___0->amplify]);
    }
  }
#line 636
  if (o___0->verbosity) {
    {
#line 637
    report((char *)"Channels       : %d [ ", (m___0->xxh)->chn);
#line 638
    i___3 = 0;
    }
    {
#line 638
    while (1) {
      while_continue___9: /* CIL Label */ ;
#line 638
      if (! (i___3 < (m___0->xxh)->chn)) {
#line 638
        goto while_break___9;
      }
#line 639
      if (m___0->xxc[i___3].flg & 4) {
        {
#line 640
        report((char *)"- ");
        }
      } else
#line 641
      if (m___0->xxc[i___3].flg & 1) {
        {
#line 642
        report((char *)"F ");
        }
      } else {
        {
#line 644
        report((char *)"%x ", m___0->xxc[i___3].pan >> 4);
        }
      }
#line 638
      i___3 ++;
    }
    while_break___9: /* CIL Label */ ;
    }
    {
#line 646
    report((char *)"]\n");
    }
  }
  {
#line 649
  t = _xmp_scan_module((struct xmp_context *)ctx___0);
  }
#line 651
  if (o___0->verbosity) {
#line 652
    if (m___0->flags & (1 << 3)) {
      {
#line 653
      report((char *)"One loop time  : %dmin%02ds\n", (t + 500) / 60000, ((t + 500) / 1000) % 60);
      }
    } else {
      {
#line 656
      report((char *)"Estimated time : %dmin%02ds\n", (t + 500) / 60000, ((t + 500) / 1000) % 60);
      }
    }
  }
#line 660
  m___0->time = t;
#line 662
  return (t);
  err: 
  {
#line 665
  fclose(f);
#line 666
  xmp_unlink_tempfiles();
  }
#line 667
  return (-1);
}
}
#line 671 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/misc/load.c"
int xmp_enable_format(char *id , int enable ) 
{ 
  struct list_head *head ;
  struct xmp_loader_info *li ;
  int tmp ;
  int tmp___0 ;

  {
#line 676
  head = loader_list.next;
  {
#line 676
  while (1) {
    while_continue: /* CIL Label */ ;
#line 676
    if (! ((unsigned long )head != (unsigned long )(& loader_list))) {
#line 676
      goto while_break;
    }
    {
#line 677
    li = (struct xmp_loader_info *)((char *)head - (unsigned long )(& ((struct xmp_loader_info *)0)->list));
#line 678
    tmp = strcasecmp((char const   *)id, (char const   *)li->id);
    }
#line 678
    if (! tmp) {
#line 679
      li->enable = enable;
#line 680
      return (0);
    }
#line 676
    head = head->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 684
  tmp___0 = pw_enable(id, enable);
  }
#line 684
  return (tmp___0);
}
}
#line 688 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/misc/load.c"
void xmp_release_module(xmp_context ctx___0 ) 
{ 
  struct xmp_player_context *p ;
  struct xmp_mod_context *m___0 ;
  int i___3 ;

  {
#line 690
  p = & ((struct xmp_context *)ctx___0)->p;
#line 691
  m___0 = & p->m;
  {
#line 694
  while (1) {
    while_continue: /* CIL Label */ ;
#line 694
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 696
  if (m___0->med_vol_table) {
#line 697
    i___3 = 0;
    {
#line 697
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 697
      if (! (i___3 < (m___0->xxh)->ins)) {
#line 697
        goto while_break___0;
      }
#line 698
      if (*(m___0->med_vol_table + i___3)) {
        {
#line 699
        free((void *)*(m___0->med_vol_table + i___3));
        }
      }
#line 697
      i___3 ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 700
    free((void *)m___0->med_vol_table);
    }
  }
#line 703
  if (m___0->med_wav_table) {
#line 704
    i___3 = 0;
    {
#line 704
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 704
      if (! (i___3 < (m___0->xxh)->ins)) {
#line 704
        goto while_break___1;
      }
#line 705
      if (*(m___0->med_wav_table + i___3)) {
        {
#line 706
        free((void *)*(m___0->med_wav_table + i___3));
        }
      }
#line 704
      i___3 ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 707
    free((void *)m___0->med_wav_table);
    }
  }
#line 710
  i___3 = 0;
  {
#line 710
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 710
    if (! (i___3 < (m___0->xxh)->trk)) {
#line 710
      goto while_break___2;
    }
    {
#line 711
    free((void *)*(m___0->xxt + i___3));
#line 710
    i___3 ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 713
  i___3 = 0;
  {
#line 713
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 713
    if (! (i___3 < (m___0->xxh)->pat)) {
#line 713
      goto while_break___3;
    }
    {
#line 714
    free((void *)*(m___0->xxp + i___3));
#line 713
    i___3 ++;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
#line 716
  i___3 = 0;
  {
#line 716
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 716
    if (! (i___3 < (m___0->xxh)->ins)) {
#line 716
      goto while_break___4;
    }
    {
#line 717
    free((void *)*(m___0->xxfe + i___3));
#line 718
    free((void *)*(m___0->xxpe + i___3));
#line 719
    free((void *)*(m___0->xxae + i___3));
#line 720
    free((void *)*(m___0->xxi + i___3));
#line 716
    i___3 ++;
    }
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 723
  free((void *)m___0->xxt);
#line 724
  free((void *)m___0->xxp);
#line 725
  free((void *)m___0->xxi);
  }
#line 726
  if ((m___0->xxh)->smp > 0) {
    {
#line 727
    free((void *)m___0->xxs);
    }
  }
  {
#line 728
  free((void *)m___0->xxim);
#line 729
  free((void *)m___0->xxih);
#line 730
  free((void *)m___0->xxfe);
#line 731
  free((void *)m___0->xxpe);
#line 732
  free((void *)m___0->xxae);
#line 733
  free((void *)m___0->xxh);
  }
#line 734
  if (m___0->comment) {
    {
#line 735
    free((void *)m___0->comment);
    }
  }
  {
#line 737
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 737
    goto while_break___5;
  }
  while_break___5: /* CIL Label */ ;
  }
  {
#line 738
  free((void *)m___0->dirname);
#line 739
  free((void *)m___0->basename);
  }
#line 740
  return;
}
}
#line 555 "/usr/include/stdio.h"
extern int fputc(int __c , FILE *__stream ) ;
#line 294 "src/include/common.h"
__inline int8 read8s(FILE *f ) ;
#line 297
uint16 read16b(FILE *f ) ;
#line 298
uint32 read24l(FILE *f ) ;
#line 299
uint32 read24b(FILE *f ) ;
#line 303
__inline void write8(FILE *f , uint8 b___1 ) ;
#line 304
void write16l(FILE *f , uint16 w ) ;
#line 305
void write16b(FILE *f , uint16 w ) ;
#line 307
void write32b(FILE *f , uint32 w ) ;
#line 310
uint16 readmem16b(uint8 *m___0 ) ;
#line 312
uint32 readmem32b(uint8 *m___0 ) ;
#line 16 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/misc/readdata.c"
uint8 read8(FILE *f ) 
{ 
  int tmp ;

  {
  {
#line 18
  tmp = fgetc(f);
  }
#line 18
  return ((uint8 )tmp);
}
}
#line 21 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/misc/readdata.c"
__inline int8 read8s(FILE *f ) 
{ 
  int tmp ;

  {
  {
#line 23
  tmp = fgetc(f);
  }
#line 23
  return ((int8 )tmp);
}
}
#line 26 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/misc/readdata.c"
uint16 read16l(FILE *f ) 
{ 
  uint32 a ;
  uint32 b___1 ;
  uint8 tmp ;
  uint8 tmp___0 ;

  {
  {
#line 30
  tmp = read8(f);
#line 30
  a = (uint32 )tmp;
#line 31
  tmp___0 = read8(f);
#line 31
  b___1 = (uint32 )tmp___0;
  }
#line 33
  return ((uint16 )((b___1 << 8) | a));
}
}
#line 36 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/misc/readdata.c"
uint16 read16b(FILE *f ) 
{ 
  uint32 a ;
  uint32 b___1 ;
  uint8 tmp ;
  uint8 tmp___0 ;

  {
  {
#line 40
  tmp = read8(f);
#line 40
  a = (uint32 )tmp;
#line 41
  tmp___0 = read8(f);
#line 41
  b___1 = (uint32 )tmp___0;
  }
#line 43
  return ((uint16 )((a << 8) | b___1));
}
}
#line 46 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/misc/readdata.c"
uint32 read24l(FILE *f ) 
{ 
  uint32 a ;
  uint32 b___1 ;
  uint32 c___0 ;
  uint8 tmp ;
  uint8 tmp___0 ;
  uint8 tmp___1 ;

  {
  {
#line 50
  tmp = read8(f);
#line 50
  a = (uint32 )tmp;
#line 51
  tmp___0 = read8(f);
#line 51
  b___1 = (uint32 )tmp___0;
#line 52
  tmp___1 = read8(f);
#line 52
  c___0 = (uint32 )tmp___1;
  }
#line 54
  return (((c___0 << 16) | (b___1 << 8)) | a);
}
}
#line 57 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/misc/readdata.c"
uint32 read24b(FILE *f ) 
{ 
  uint32 a ;
  uint32 b___1 ;
  uint32 c___0 ;
  uint8 tmp ;
  uint8 tmp___0 ;
  uint8 tmp___1 ;

  {
  {
#line 61
  tmp = read8(f);
#line 61
  a = (uint32 )tmp;
#line 62
  tmp___0 = read8(f);
#line 62
  b___1 = (uint32 )tmp___0;
#line 63
  tmp___1 = read8(f);
#line 63
  c___0 = (uint32 )tmp___1;
  }
#line 65
  return (((a << 16) | (b___1 << 8)) | c___0);
}
}
#line 68 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/misc/readdata.c"
uint32 read32l(FILE *f ) 
{ 
  uint32 a ;
  uint32 b___1 ;
  uint32 c___0 ;
  uint32 d ;
  uint8 tmp ;
  uint8 tmp___0 ;
  uint8 tmp___1 ;
  uint8 tmp___2 ;

  {
  {
#line 72
  tmp = read8(f);
#line 72
  a = (uint32 )tmp;
#line 73
  tmp___0 = read8(f);
#line 73
  b___1 = (uint32 )tmp___0;
#line 74
  tmp___1 = read8(f);
#line 74
  c___0 = (uint32 )tmp___1;
#line 75
  tmp___2 = read8(f);
#line 75
  d = (uint32 )tmp___2;
  }
#line 77
  return ((((d << 24) | (c___0 << 16)) | (b___1 << 8)) | a);
}
}
#line 80 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/misc/readdata.c"
uint32 read32b(FILE *f ) 
{ 
  uint32 a ;
  uint32 b___1 ;
  uint32 c___0 ;
  uint32 d ;
  uint8 tmp ;
  uint8 tmp___0 ;
  uint8 tmp___1 ;
  uint8 tmp___2 ;

  {
  {
#line 84
  tmp = read8(f);
#line 84
  a = (uint32 )tmp;
#line 85
  tmp___0 = read8(f);
#line 85
  b___1 = (uint32 )tmp___0;
#line 86
  tmp___1 = read8(f);
#line 86
  c___0 = (uint32 )tmp___1;
#line 87
  tmp___2 = read8(f);
#line 87
  d = (uint32 )tmp___2;
  }
#line 89
  return ((((a << 24) | (b___1 << 16)) | (c___0 << 8)) | d);
}
}
#line 94 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/misc/readdata.c"
__inline void write8(FILE *f , uint8 b___1 ) 
{ 


  {
  {
#line 96
  fputc((int )b___1, f);
  }
#line 97
  return;
}
}
#line 99 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/misc/readdata.c"
void write16l(FILE *f , uint16 w ) 
{ 


  {
  {
#line 101
  write8(f, (uint8 )((int )w & 255));
#line 102
  write8(f, (uint8 )(((int )w & 65280) >> 8));
  }
#line 103
  return;
}
}
#line 105 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/misc/readdata.c"
void write16b(FILE *f , uint16 w ) 
{ 


  {
  {
#line 107
  write8(f, (uint8 )(((int )w & 65280) >> 8));
#line 108
  write8(f, (uint8 )((int )w & 255));
  }
#line 109
  return;
}
}
#line 111 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/misc/readdata.c"
void write32l(FILE *f , uint32 w ) 
{ 


  {
  {
#line 113
  write8(f, (uint8 )(w & 255U));
#line 114
  write8(f, (uint8 )((w & 65280U) >> 8));
#line 115
  write8(f, (uint8 )((w & 16711680U) >> 16));
#line 116
  write8(f, (uint8 )((w & 4278190080U) >> 24));
  }
#line 117
  return;
}
}
#line 119 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/misc/readdata.c"
void write32b(FILE *f , uint32 w ) 
{ 


  {
  {
#line 121
  write8(f, (uint8 )((w & 4278190080U) >> 24));
#line 122
  write8(f, (uint8 )((w & 16711680U) >> 16));
#line 123
  write8(f, (uint8 )((w & 65280U) >> 8));
#line 124
  write8(f, (uint8 )(w & 255U));
  }
#line 125
  return;
}
}
#line 127 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/misc/readdata.c"
uint16 readmem16l(uint8 *m___0 ) 
{ 
  uint32 a ;
  uint32 b___1 ;

  {
#line 131
  a = (uint32 )*(m___0 + 0);
#line 132
  b___1 = (uint32 )*(m___0 + 1);
#line 134
  return ((uint16 )((b___1 << 8) | a));
}
}
#line 137 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/misc/readdata.c"
uint16 readmem16b(uint8 *m___0 ) 
{ 
  uint32 a ;
  uint32 b___1 ;

  {
#line 141
  a = (uint32 )*(m___0 + 0);
#line 142
  b___1 = (uint32 )*(m___0 + 1);
#line 144
  return ((uint16 )((a << 8) | b___1));
}
}
#line 147 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/misc/readdata.c"
uint32 readmem32l(uint8 *m___0 ) 
{ 
  uint32 a ;
  uint32 b___1 ;
  uint32 c___0 ;
  uint32 d ;

  {
#line 151
  a = (uint32 )*(m___0 + 0);
#line 152
  b___1 = (uint32 )*(m___0 + 1);
#line 153
  c___0 = (uint32 )*(m___0 + 2);
#line 154
  d = (uint32 )*(m___0 + 3);
#line 156
  return ((((d << 24) | (c___0 << 16)) | (b___1 << 8)) | a);
}
}
#line 159 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/misc/readdata.c"
uint32 readmem32b(uint8 *m___0 ) 
{ 
  uint32 a ;
  uint32 b___1 ;
  uint32 c___0 ;
  uint32 d ;

  {
#line 163
  a = (uint32 )*(m___0 + 0);
#line 164
  b___1 = (uint32 )*(m___0 + 1);
#line 165
  c___0 = (uint32 )*(m___0 + 2);
#line 166
  d = (uint32 )*(m___0 + 3);
#line 168
  return ((((a << 24) | (b___1 << 16)) | (c___0 << 8)) | d);
}
}
#line 19 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/misc/info.c"
struct xmp_module_info *xmp_get_module_info(xmp_context ctx___0 , struct xmp_module_info *i___3 ) 
{ 
  struct xmp_player_context *p ;
  struct xmp_mod_context *m___0 ;

  {
  {
#line 21
  p = & ((struct xmp_context *)ctx___0)->p;
#line 22
  m___0 = & p->m;
#line 24
  strncpy((char */* __restrict  */)(i___3->name), (char const   */* __restrict  */)(m___0->name),
          (size_t )64);
#line 25
  strncpy((char */* __restrict  */)(i___3->type), (char const   */* __restrict  */)(m___0->type),
          (size_t )64);
#line 26
  i___3->chn = (m___0->xxh)->chn;
#line 27
  i___3->pat = (m___0->xxh)->pat;
#line 28
  i___3->ins = (m___0->xxh)->ins;
#line 29
  i___3->trk = (m___0->xxh)->trk;
#line 30
  i___3->smp = (m___0->xxh)->smp;
#line 31
  i___3->len = (m___0->xxh)->len;
#line 32
  i___3->time = m___0->time;
  }
#line 34
  return (i___3);
}
}
#line 38 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/misc/info.c"
char *xmp_get_driver_description(xmp_context ctx___0 ) 
{ 
  struct xmp_driver_context *d ;

  {
#line 40
  d = & ((struct xmp_context *)ctx___0)->d;
#line 42
  return (d->description);
}
}
#line 46 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/misc/info.c"
struct xmp_fmt_info *xmp_get_fmt_info(struct xmp_fmt_info **x ) 
{ 
  struct xmp_fmt_info *tmp ;

  {
#line 48
  tmp = __fmt_head;
#line 48
  *x = tmp;
#line 48
  return (tmp);
}
}
#line 52 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/misc/info.c"
struct xmp_drv_info *xmp_get_drv_info(struct xmp_drv_info **x ) 
{ 
  struct xmp_drv_info *tmp ;

  {
  {
#line 54
  tmp = xmp_drv_array();
#line 54
  *x = tmp;
  }
#line 54
  return (tmp);
}
}
#line 225 "src/include/xmp.h"
void xmp_get_buffer(xmp_context ctx___0 , void **buffer , int *size___0 ) ;
#line 228
int xmp_seek_time(xmp_context ctx___0 , int time___0 ) ;
#line 24 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/misc/control.c"
static int drv_parm  =    0;
#line 27
int pw_init(void) ;
#line 29 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/misc/control.c"
void *xmp_create_context(void) 
{ 
  struct xmp_context *ctx___0 ;
  struct xmp_options *o___0 ;
  uint16 w ;
  void *tmp ;

  {
  {
#line 35
  tmp = calloc((size_t )1, (size_t )sizeof(struct xmp_context ));
#line 35
  ctx___0 = (struct xmp_context *)tmp;
  }
#line 37
  if ((unsigned long )ctx___0 == (unsigned long )((void *)0)) {
#line 38
    return ((void *)0);
  }
#line 40
  o___0 = & ctx___0->o;
#line 42
  w = (uint16 )255;
#line 43
  o___0->big_endian = (int )*((char *)(& w)) == 0;
#line 46
  o___0->amplify = 0;
#line 47
  o___0->freq = 44100;
#line 48
  o___0->mix = 70;
#line 49
  o___0->resol = 16;
#line 50
  o___0->flags = ((1 << 6) | (1 << 8)) | 1;
#line 51
  o___0->cf_cutoff = 0;
#line 53
  return ((void *)ctx___0);
}
}
#line 56 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/misc/control.c"
void xmp_free_context(xmp_context ctx___0 ) 
{ 


  {
  {
#line 58
  free((void *)ctx___0);
  }
#line 59
  return;
}
}
#line 61 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/misc/control.c"
struct xmp_options *xmp_get_options(xmp_context ctx___0 ) 
{ 


  {
#line 63
  return (& ((struct xmp_context *)ctx___0)->o);
}
}
#line 66 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/misc/control.c"
void xmp_init(xmp_context ctx___0 , int argc , char **argv ) 
{ 
  struct xmp_player_context *p ;
  int num ;
  int tmp ;
  char *__cil_tmp7 ;

  {
  {
#line 68
  p = & ((struct xmp_context *)ctx___0)->p;
#line 71
  xmp_init_formats(ctx___0);
#line 72
  pw_init();
#line 74
  p->event_callback = (void (*)(unsigned long  ))((void *)0);
#line 77
  num = 1;
  }
  {
#line 77
  while (1) {
    while_continue: /* CIL Label */ ;
#line 77
    if (! (num < argc)) {
#line 77
      goto while_break;
    }
    {
#line 78
    tmp = strcmp((char const   *)*(argv + num), "--norc");
    }
#line 78
    if (! tmp) {
#line 79
      goto while_break;
    }
#line 77
    num ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 81
  if (num >= argc) {
    {
#line 82
    _xmp_read_rc((struct xmp_context *)ctx___0);
    }
  }
#line 83
  return;
}
}
#line 85 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/misc/control.c"
int xmp_open_audio(xmp_context ctx___0 ) 
{ 
  int tmp ;

  {
  {
#line 87
  tmp = xmp_drv_open((struct xmp_context *)ctx___0);
  }
#line 87
  return (tmp);
}
}
#line 90 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/misc/control.c"
void xmp_close_audio(xmp_context ctx___0 ) 
{ 


  {
  {
#line 92
  xmp_drv_close((struct xmp_context *)ctx___0);
  }
#line 93
  return;
}
}
#line 95 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/misc/control.c"
void xmp_set_driver_parameter(struct xmp_options *o___0 , char *s ) 
{ 
  unsigned short const   **tmp ;

  {
#line 97
  o___0->parm[drv_parm] = s;
  {
#line 98
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 98
    tmp = __ctype_b_loc();
    }
#line 98
    if (! ((int const   )*(*tmp + (int )*(o___0->parm[drv_parm])) & 8192)) {
#line 98
      goto while_break;
    }
#line 99
    (o___0->parm[drv_parm]) ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 100
  drv_parm ++;
#line 101
  return;
}
}
#line 103 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/misc/control.c"
void xmp_register_event_callback(xmp_context ctx___0 , void (*cb)(unsigned long  ) ) 
{ 
  struct xmp_player_context *p ;

  {
#line 105
  p = & ((struct xmp_context *)ctx___0)->p;
#line 107
  p->event_callback = cb;
#line 108
  return;
}
}
#line 110 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/misc/control.c"
void xmp_channel_mute(xmp_context ctx___0 , int from , int num , int on ) 
{ 
  int tmp ;

  {
#line 112
  from += num - 1;
#line 114
  if (num > 0) {
    {
#line 115
    while (1) {
      while_continue: /* CIL Label */ ;
#line 115
      tmp = num;
#line 115
      num --;
#line 115
      if (! tmp) {
#line 115
        goto while_break;
      }
      {
#line 116
      xmp_drv_mute((struct xmp_context *)ctx___0, from - num, on);
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 118
  return;
}
}
#line 120 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/misc/control.c"
int xmp_player_ctl(xmp_context ctx___0 , int cmd , int arg ) 
{ 
  struct xmp_player_context *p ;
  struct xmp_mod_context *m___0 ;

  {
#line 122
  p = & ((struct xmp_context *)ctx___0)->p;
#line 123
  m___0 = & p->m;
  {
#line 126
  if (cmd == 1) {
#line 126
    goto case_1;
  }
#line 130
  if (cmd == 0) {
#line 130
    goto case_0;
  }
#line 134
  if (cmd == 2) {
#line 134
    goto case_2;
  }
#line 138
  if (cmd == 3) {
#line 138
    goto case_3;
  }
#line 141
  if (cmd == 4) {
#line 141
    goto case_4;
  }
#line 144
  if (cmd == 6) {
#line 144
    goto case_6;
  }
#line 148
  if (cmd == 5) {
#line 148
    goto case_5;
  }
#line 152
  if (cmd == 7) {
#line 152
    goto case_7;
  }
#line 155
  if (cmd == 8) {
#line 155
    goto case_8;
  }
#line 125
  goto switch_break;
  case_1: /* CIL Label */ 
#line 127
  if (p->pos > 0) {
#line 128
    (p->pos) --;
  }
#line 129
  return (p->pos);
  case_0: /* CIL Label */ 
#line 131
  if (p->pos < (m___0->xxh)->len) {
#line 132
    (p->pos) ++;
  }
#line 133
  return (p->pos);
  case_2: /* CIL Label */ 
#line 135
  if (arg < (m___0->xxh)->len) {
#line 135
    if (arg >= 0) {
#line 136
      p->pos = arg;
    }
  }
#line 137
  return (p->pos);
  case_3: /* CIL Label */ 
#line 139
  p->pos = -2;
#line 140
  goto switch_break;
  case_4: /* CIL Label */ 
#line 142
  p->pos = -1;
#line 143
  goto switch_break;
  case_6: /* CIL Label */ 
#line 145
  if (m___0->volume > 0) {
#line 146
    (m___0->volume) --;
  }
#line 147
  return (m___0->volume);
  case_5: /* CIL Label */ 
#line 149
  if (m___0->volume < 64) {
#line 150
    (m___0->volume) ++;
  }
#line 151
  return (m___0->volume);
  case_7: /* CIL Label */ 
  {
#line 153
  xmp_drv_stoptimer((struct xmp_context *)ctx___0);
  }
#line 154
  goto switch_break;
  case_8: /* CIL Label */ 
  {
#line 156
  xmp_drv_starttimer((struct xmp_context *)ctx___0);
  }
#line 157
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 160
  return (0);
}
}
#line 163 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/misc/control.c"
int xmp_player_start(xmp_context ctx___0 ) 
{ 
  int tmp ;

  {
  {
#line 165
  tmp = _xmp_player_start((struct xmp_context *)ctx___0);
  }
#line 165
  return (tmp);
}
}
#line 168 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/misc/control.c"
int xmp_player_frame(xmp_context ctx___0 ) 
{ 
  int tmp ;

  {
  {
#line 170
  tmp = _xmp_player_frame((struct xmp_context *)ctx___0);
  }
#line 170
  return (tmp);
}
}
#line 173 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/misc/control.c"
void xmp_player_end(xmp_context ctx___0 ) 
{ 


  {
  {
#line 175
  _xmp_player_end((struct xmp_context *)ctx___0);
  }
#line 176
  return;
}
}
#line 178 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/misc/control.c"
void xmp_play_buffer(xmp_context ctx___0 ) 
{ 


  {
  {
#line 180
  xmp_drv_bufdump((struct xmp_context *)ctx___0);
  }
#line 181
  return;
}
}
#line 183 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/misc/control.c"
void xmp_get_buffer(xmp_context ctx___0 , void **buffer , int *size___0 ) 
{ 


  {
  {
#line 185
  *size___0 = xmp_smix_softmixer((struct xmp_context *)ctx___0);
#line 186
  *buffer = xmp_smix_buffer((struct xmp_context *)ctx___0);
  }
#line 187
  return;
}
}
#line 189 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/misc/control.c"
void xmp_get_driver_cfg(xmp_context ctx___0 , int *srate , int *res , int *chn , int *itpt ) 
{ 
  struct xmp_driver_context *d ;
  struct xmp_options *o___0 ;

  {
#line 192
  d = & ((struct xmp_context *)ctx___0)->d;
#line 193
  o___0 = & ((struct xmp_context *)ctx___0)->o;
#line 195
  if (d->memavl) {
#line 195
    *srate = 0;
  } else {
#line 195
    *srate = o___0->freq;
  }
#line 196
  if (o___0->resol) {
#line 196
    *res = o___0->resol;
  } else {
#line 196
    *res = 8;
  }
#line 197
  if (o___0->outfmt & (1 << 2)) {
#line 197
    *chn = 1;
  } else {
#line 197
    *chn = 2;
  }
#line 198
  *itpt = ! (! (o___0->flags & 1));
#line 199
  return;
}
}
#line 201 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/misc/control.c"
int xmp_verbosity_level(xmp_context ctx___0 , int i___3 ) 
{ 
  struct xmp_options *o___0 ;
  int tmp ;

  {
#line 203
  o___0 = & ((struct xmp_context *)ctx___0)->o;
#line 206
  tmp = o___0->verbosity;
#line 207
  o___0->verbosity = i___3;
#line 209
  return (tmp);
}
}
#line 212 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/misc/control.c"
int xmp_seek_time(xmp_context ctx___0 , int time___0 ) 
{ 
  struct xmp_player_context *p ;
  int i___3 ;
  int t ;

  {
#line 214
  p = & ((struct xmp_context *)ctx___0)->p;
#line 218
  time___0 *= 1000;
#line 219
  i___3 = 0;
  {
#line 219
  while (1) {
    while_continue: /* CIL Label */ ;
#line 219
    if (! (i___3 < (p->m.xxh)->len)) {
#line 219
      goto while_break;
    }
#line 220
    t = p->m.xxo_info[i___3].time;
    {
#line 222
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 222
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 224
    if (t > time___0) {
#line 225
      if (i___3 > 0) {
#line 226
        i___3 --;
      }
      {
#line 227
      xmp_player_ctl(ctx___0, 2, i___3);
      }
#line 228
      return (0);
    }
#line 219
    i___3 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 231
  return (-1);
}
}
#line 47 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/prowizard/prowiz.h"
int pw_move_data(FILE *out , FILE *in , int len ) ;
#line 48
int pw_write_zero(FILE *out , int len ) ;
#line 83
struct pw_format pw_starpack ;
#line 12 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/prowizard/starpack.c"
static int depack_starpack(FILE *in , FILE *out ) ;
#line 13
static int test_starpack(uint8 *data , int s ) ;
#line 15 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/prowizard/starpack.c"
struct pw_format pw_starpack  =    {(char *)"STP", (char *)"Startrakker Packer", 0, & test_starpack, & depack_starpack,
    0, {(struct list_head *)0, (struct list_head *)0}};
#line 23 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/prowizard/starpack.c"
static int depack_starpack(FILE *in , FILE *out ) 
{ 
  uint8 c1 ;
  uint8 c2 ;
  uint8 c3 ;
  uint8 c4 ;
  uint8 c5 ;
  uint8 pnum[128] ;
  uint8 pnum_tmp[128] ;
  uint8 pat_pos ;
  uint8 Pattern[1024] ;
  uint8 PatMax ;
  int i___3 ;
  int j ;
  int k ;
  int size___0 ;
  int ssize ;
  int paddr[128] ;
  int paddr_tmp[128] ;
  int paddr_tmp2[128] ;
  int tmp_ptr ;
  int tmp1 ;
  int tmp2 ;
  int sdataAddress ;
  uint16 tmp ;
  uint8 tmp___0 ;
  uint8 tmp___1 ;
  uint16 tmp___2 ;
  uint16 tmp___3 ;
  uint16 tmp___4 ;
  uint32 tmp___5 ;
  int tmp___6 ;
  uint32 tmp___7 ;
  void *__cil_tmp34 ;
  void *__cil_tmp35 ;
  void *__cil_tmp36 ;
  void *__cil_tmp37 ;
  void *__cil_tmp38 ;
  void *__cil_tmp39 ;

  {
  {
#line 25
  c1 = (uint8 )0;
#line 25
  c2 = (uint8 )0;
#line 25
  c3 = (uint8 )0;
#line 25
  c4 = (uint8 )0;
#line 30
  PatMax = (uint8 )0;
#line 31
  i___3 = 0;
#line 31
  j = 0;
#line 31
  k = 0;
#line 32
  ssize = 0;
#line 37
  sdataAddress = 0;
#line 39
  memset((void *)(pnum), 0, (size_t )128);
#line 40
  memset((void *)(pnum_tmp), 0, (size_t )128);
#line 41
  memset((void *)(paddr), 0, (size_t )512);
#line 42
  memset((void *)(paddr_tmp), 0, (size_t )512);
#line 43
  memset((void *)(paddr_tmp2), 0, (size_t )512);
#line 45
  pw_move_data(in, out, 20);
#line 47
  i___3 = 0;
  }
  {
#line 47
  while (1) {
    while_continue: /* CIL Label */ ;
#line 47
    if (! (i___3 < 31)) {
#line 47
      goto while_break;
    }
    {
#line 48
    pw_write_zero(out, 22);
#line 49
    tmp = read16b(in);
#line 49
    size___0 = (int )tmp;
#line 49
    write16b(out, (uint16 )size___0);
#line 50
    ssize += 2 * size___0;
#line 51
    tmp___0 = read8(in);
#line 51
    write8(out, tmp___0);
#line 52
    tmp___1 = read8(in);
#line 52
    write8(out, tmp___1);
#line 53
    tmp___2 = read16b(in);
#line 53
    write16b(out, tmp___2);
#line 54
    tmp___3 = read16b(in);
#line 54
    write16b(out, tmp___3);
#line 47
    i___3 ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 57
  tmp___4 = read16b(in);
#line 57
  pat_pos = (uint8 )tmp___4;
#line 59
  fseek(in, 2L, 1);
#line 61
  i___3 = 0;
  }
  {
#line 61
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 61
    if (! (i___3 < 128)) {
#line 61
      goto while_break___0;
    }
    {
#line 62
    tmp___5 = read32b(in);
#line 62
    paddr[i___3] = (int )tmp___5;
#line 61
    i___3 ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 66
  tmp_ptr = 0;
#line 67
  i___3 = 0;
  {
#line 67
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 67
    if (! (i___3 < (int )pat_pos)) {
#line 67
      goto while_break___1;
    }
#line 68
    if (i___3 == 0) {
#line 69
      pnum[0] = (uint8 )0;
#line 70
      tmp_ptr ++;
#line 71
      goto __Cont;
    }
#line 74
    j = 0;
    {
#line 74
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 74
      if (! (j < i___3)) {
#line 74
        goto while_break___2;
      }
#line 75
      if (paddr[i___3] == paddr[j]) {
#line 76
        pnum[i___3] = pnum[j];
#line 77
        goto while_break___2;
      }
#line 74
      j ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 80
    if (j == i___3) {
#line 81
      tmp___6 = tmp_ptr;
#line 81
      tmp_ptr ++;
#line 81
      pnum[i___3] = (uint8 )tmp___6;
    }
    __Cont: /* CIL Label */ 
#line 67
    i___3 ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 84
  i___3 = 0;
  {
#line 84
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 84
    if (! (i___3 < 128)) {
#line 84
      goto while_break___3;
    }
#line 85
    paddr_tmp[i___3] = paddr[i___3];
#line 84
    i___3 ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  restart: 
#line 88
  i___3 = 0;
  {
#line 88
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 88
    if (! (i___3 < (int )pat_pos)) {
#line 88
      goto while_break___4;
    }
#line 89
    j = 0;
    {
#line 89
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 89
      if (! (j < i___3)) {
#line 89
        goto while_break___5;
      }
#line 90
      if (paddr_tmp[i___3] < paddr_tmp[j]) {
#line 91
        tmp2 = (int )pnum[j];
#line 92
        pnum[j] = pnum[i___3];
#line 93
        pnum[i___3] = (uint8 )tmp2;
#line 94
        tmp1 = paddr_tmp[j];
#line 95
        paddr_tmp[j] = paddr_tmp[i___3];
#line 96
        paddr_tmp[i___3] = tmp1;
#line 97
        goto restart;
      }
#line 89
      j ++;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 88
    i___3 ++;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 102
  j = 0;
#line 103
  i___3 = 0;
  {
#line 103
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 103
    if (! (i___3 < 128)) {
#line 103
      goto while_break___6;
    }
#line 104
    if (i___3 == 0) {
#line 105
      paddr_tmp2[j] = paddr_tmp[i___3];
#line 106
      goto __Cont___0;
    }
#line 109
    if (paddr_tmp[i___3] == paddr_tmp2[j]) {
#line 110
      goto __Cont___0;
    }
#line 111
    j ++;
#line 111
    paddr_tmp2[j] = paddr_tmp[i___3];
    __Cont___0: /* CIL Label */ 
#line 103
    i___3 ++;
  }
  while_break___6: /* CIL Label */ ;
  }
#line 115
  j = 0;
#line 116
  i___3 = 0;
  {
#line 116
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 116
    if (! (i___3 < (int )pat_pos - 1)) {
#line 116
      goto while_break___7;
    }
#line 117
    paddr_tmp[j] = paddr_tmp2[i___3];
#line 118
    j ++;
#line 119
    if (paddr_tmp2[i___3 + 1] - paddr_tmp2[i___3] > 1024) {
#line 121
      paddr_tmp[j] = paddr_tmp2[i___3] + 1024;
#line 122
      j ++;
    }
#line 116
    i___3 ++;
  }
  while_break___7: /* CIL Label */ ;
  }
#line 127
  c1 = (uint8 )0;
  {
#line 127
  while (1) {
    while_continue___8: /* CIL Label */ ;
#line 127
    if (! ((int )c1 < 128)) {
#line 127
      goto while_break___8;
    }
#line 128
    c2 = (uint8 )0;
    {
#line 128
    while (1) {
      while_continue___9: /* CIL Label */ ;
#line 128
      if (! ((int )c2 < 128)) {
#line 128
        goto while_break___9;
      }
#line 129
      if (paddr[c1] == paddr_tmp[c2]) {
#line 130
        pnum_tmp[c1] = c2;
#line 131
        goto while_break___9;
      }
#line 128
      c2 = (uint8 )((int )c2 + 1);
    }
    while_break___9: /* CIL Label */ ;
    }
#line 127
    c1 = (uint8 )((int )c1 + 1);
  }
  while_break___8: /* CIL Label */ ;
  }
  {
#line 135
  memset((void *)(pnum), 0, (size_t )128);
#line 136
  i___3 = 0;
  }
  {
#line 136
  while (1) {
    while_continue___10: /* CIL Label */ ;
#line 136
    if (! (i___3 < (int )pat_pos)) {
#line 136
      goto while_break___10;
    }
#line 137
    pnum[i___3] = pnum_tmp[i___3];
#line 136
    i___3 ++;
  }
  while_break___10: /* CIL Label */ ;
  }
  {
#line 140
  write8(out, pat_pos);
#line 143
  i___3 = 0;
  }
  {
#line 143
  while (1) {
    while_continue___11: /* CIL Label */ ;
#line 143
    if (! (i___3 < (int )pat_pos)) {
#line 143
      goto while_break___11;
    }
#line 144
    if ((int )pnum[i___3] > (int )PatMax) {
#line 145
      PatMax = pnum[i___3];
    }
#line 143
    i___3 ++;
  }
  while_break___11: /* CIL Label */ ;
  }
  {
#line 148
  write8(out, (uint8 )127);
#line 149
  fwrite((void const   */* __restrict  */)(pnum), (size_t )128, (size_t )1, (FILE */* __restrict  */)out);
#line 150
  write32b(out, (((77U << 24) | (46U << 16)) | (75U << 8)) | 46U);
#line 153
  fseek(in, 784L, 0);
#line 154
  tmp___7 = read32b(in);
#line 154
  sdataAddress = (int )(tmp___7 + 788U);
#line 157
  fseek(in, 788L, 0);
#line 158
  PatMax = (uint8 )((int )PatMax + 1);
#line 159
  i___3 = 0;
  }
  {
#line 159
  while (1) {
    while_continue___12: /* CIL Label */ ;
#line 159
    if (! (i___3 < (int )PatMax)) {
#line 159
      goto while_break___12;
    }
    {
#line 160
    memset((void *)(Pattern), 0, (size_t )1024);
#line 161
    j = 0;
    }
    {
#line 161
    while (1) {
      while_continue___13: /* CIL Label */ ;
#line 161
      if (! (j < 64)) {
#line 161
        goto while_break___13;
      }
#line 162
      k = 0;
      {
#line 162
      while (1) {
        while_continue___14: /* CIL Label */ ;
#line 162
        if (! (k < 4)) {
#line 162
          goto while_break___14;
        }
        {
#line 163
        fread((void */* __restrict  */)(& c1), (size_t )1, (size_t )1, (FILE */* __restrict  */)in);
        }
#line 164
        if ((int )c1 == 128) {
#line 165
          Pattern[j * 16 + k * 4] = (uint8 )0;
#line 166
          Pattern[(j * 16 + k * 4) + 1] = (uint8 )0;
#line 167
          Pattern[(j * 16 + k * 4) + 2] = (uint8 )0;
#line 168
          Pattern[(j * 16 + k * 4) + 3] = (uint8 )0;
#line 169
          goto __Cont___1;
        }
        {
#line 171
        fread((void */* __restrict  */)(& c2), (size_t )1, (size_t )1, (FILE */* __restrict  */)in);
#line 172
        fread((void */* __restrict  */)(& c3), (size_t )1, (size_t )1, (FILE */* __restrict  */)in);
#line 173
        fread((void */* __restrict  */)(& c4), (size_t )1, (size_t )1, (FILE */* __restrict  */)in);
#line 174
        Pattern[j * 16 + k * 4] = (uint8 )((int )c1 & 15);
#line 175
        Pattern[(j * 16 + k * 4) + 1] = c2;
#line 176
        Pattern[(j * 16 + k * 4) + 2] = (uint8 )((int )c3 & 15);
#line 177
        Pattern[(j * 16 + k * 4) + 3] = c4;
#line 179
        c5 = (uint8 )(((int )c1 & 240) | (((int )c3 >> 4) & 15));
#line 180
        c5 = (uint8 )((int )c5 / 4);
#line 181
        Pattern[j * 16 + k * 4] = (uint8 )((int )Pattern[j * 16 + k * 4] | ((int )c5 & 240));
#line 182
        Pattern[(j * 16 + k * 4) + 2] = (uint8 )((int )Pattern[(j * 16 + k * 4) + 2] | (((int )c5 << 4) & 240));
        }
        __Cont___1: /* CIL Label */ 
#line 162
        k ++;
      }
      while_break___14: /* CIL Label */ ;
      }
#line 161
      j ++;
    }
    while_break___13: /* CIL Label */ ;
    }
    {
#line 186
    fwrite((void const   */* __restrict  */)(Pattern), (size_t )1024, (size_t )1,
           (FILE */* __restrict  */)out);
#line 159
    i___3 ++;
    }
  }
  while_break___12: /* CIL Label */ ;
  }
  {
#line 192
  fseek(in, (long )sdataAddress, 0);
#line 193
  pw_move_data(in, out, ssize);
  }
#line 195
  return (0);
}
}
#line 199 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/prowizard/starpack.c"
static int test_starpack(uint8 *data , int s ) 
{ 
  int start ;
  int j ;
  int k ;
  int l ;
  int m___0 ;
  int ssize ;
  char *__cil_tmp9 ;

  {
#line 201
  start = 0;
#line 214
  l = ((int )*(data + (start + 268)) << 8) + (int )*(data + (start + 269));
#line 215
  if (l & 3) {
#line 216
    return (-1);
  }
#line 218
  k = l / 4;
#line 219
  if (k == 0) {
#line 220
    return (-1);
  } else
#line 219
  if (k > 127) {
#line 220
    return (-1);
  }
#line 222
  if ((int )*(data + (start + 784)) != 0) {
#line 223
    return (-1);
  }
#line 227
  k = 0;
  {
#line 227
  while (1) {
    while_continue: /* CIL Label */ ;
#line 227
    if (! (k < 31)) {
#line 227
      goto while_break;
    }
#line 228
    j = (((int )*(data + ((start + 20) + k * 8)) << 8) + (int )*(data + ((start + 21) + k * 8))) * 2;
#line 229
    ssize = (((int )*(data + ((start + 24) + k * 8)) << 8) + (int )*(data + ((start + 25) + k * 8))) * 2 + (((int )*(data + ((start + 26) + k * 8)) << 8) + (int )*(data + ((start + 27) + k * 8))) * 2;
#line 231
    if (j + 2 < ssize) {
#line 232
      return (-1);
    }
#line 227
    k ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 234
  printf((char const   */* __restrict  */)"e\n");
#line 238
  k = 0;
  }
  {
#line 238
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 238
    if (! (k < 31)) {
#line 238
      goto while_break___0;
    }
#line 239
    if ((int )*(data + ((start + 22) + k * 8)) > 15) {
#line 240
      return (-1);
    } else
#line 239
    if ((int )*(data + ((start + 23) + k * 8)) > 64) {
#line 240
      return (-1);
    }
#line 238
    k ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 254
  k = ((((int )*(data + (start + 784)) << 24) + ((int )*(data + (start + 785)) << 16)) + ((int )*(data + (start + 786)) << 8)) + (int )*(data + (start + 787));
#line 264
  if (k < 788) {
#line 265
    return (-1);
  }
#line 269
  j = 0;
  {
#line 269
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 269
    if (! (j < l)) {
#line 269
      goto while_break___1;
    }
#line 270
    m___0 = ((((int )*(data + ((start + 272) + j)) << 24) + ((int )*(data + ((start + 273) + j)) << 16)) + ((int )*(data + ((start + 274) + j)) << 8)) + (int )*(data + ((start + 275) + j));
#line 275
    if (m___0 > k) {
#line 276
      return (-1);
    }
#line 269
    j += 4;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 280
  j += 2;
  {
#line 280
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 280
    if (! (j < 128)) {
#line 280
      goto while_break___2;
    }
#line 281
    m___0 = ((((int )*(data + ((start + 272) + j * 4)) << 24) + ((int )*(data + ((start + 273) + j * 4)) << 16)) + ((int )*(data + ((start + 274) + j * 4)) << 8)) + (int )*(data + ((start + 275) + j * 4));
#line 285
    if (m___0 != 0) {
#line 286
      return (-1);
    }
#line 280
    j ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 291
  j = start + 788;
  {
#line 293
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 293
    if (! (j < (k + start) - 4)) {
#line 293
      goto while_break___3;
    }
#line 294
    if ((int )*(data + j) == 128) {
#line 295
      j ++;
#line 296
      goto while_continue___3;
    }
#line 299
    if ((int )*(data + j) > 128) {
#line 300
      return (-1);
    }
#line 303
    if ((int )*(data + j) == 0) {
#line 303
      if ((int )*(data + (j + 1)) == 0) {
#line 303
        if ((int )*(data + (j + 2)) == 0) {
#line 303
          if ((int )*(data + (j + 3)) == 0) {
#line 307
            return (-1);
          }
        }
      }
    }
#line 311
    if ((int )*(data + (j + 2)) * 15 == 12) {
#line 311
      if ((int )*(data + (j + 3)) > 64) {
#line 312
        return (-1);
      }
    }
#line 315
    if ((int )*(data + (j + 2)) * 15 == 13) {
#line 315
      if ((int )*(data + (j + 3)) > 64) {
#line 316
        return (-1);
      }
    }
#line 318
    j += 4;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 321
  return (0);
}
}
#line 80 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/prowizard/prowiz.h"
struct pw_format pw_pp21 ;
#line 14 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/prowizard/pp21.c"
static int depack_pp21(FILE *in , FILE *out ) ;
#line 15
static int test_pp21(uint8 *data , int s ) ;
#line 17 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/prowizard/pp21.c"
struct pw_format pw_pp21  =    {(char *)"PP21", (char *)"ProPacker 2.1", 0, & test_pp21, & depack_pp21, 0, {(struct list_head *)0,
                                                                                (struct list_head *)0}};
#line 25 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/prowizard/pp21.c"
static int depack_pp21(FILE *in , FILE *out ) 
{ 
  uint8 ptable[128] ;
  int max ;
  uint8 trk[4][128] ;
  int tptr[512][64] ;
  uint8 numpat ;
  uint8 *tab ;
  uint8 buf___1[1024] ;
  int i___3 ;
  int j ;
  int size___0 ;
  int ssize ;
  int tabsize ;
  uint16 tmp ;
  uint8 tmp___0 ;
  uint8 tmp___1 ;
  uint16 tmp___2 ;
  uint16 tmp___3 ;
  uint8 tmp___4 ;
  uint16 tmp___5 ;
  uint32 tmp___6 ;
  void *tmp___7 ;
  uint8 *b___1 ;
  void *__cil_tmp25 ;
  void *__cil_tmp26 ;
  int __cil_tmp27 ;
  void *__cil_tmp28 ;
  void *__cil_tmp29 ;
  int __cil_tmp30 ;
  void *__cil_tmp31 ;
  void *__cil_tmp32 ;

  {
  {
#line 28
  max = 0;
#line 36
  ssize = 0;
#line 37
  tabsize = 0;
#line 39
  memset((void *)(ptable), 0, (size_t )128);
#line 40
  memset((void *)(trk), 0, (size_t )512);
#line 41
  memset((void *)(tptr), 0, (size_t )65536);
#line 43
  pw_write_zero(out, 20);
#line 45
  i___3 = 0;
  }
  {
#line 45
  while (1) {
    while_continue: /* CIL Label */ ;
#line 45
    if (! (i___3 < 31)) {
#line 45
      goto while_break;
    }
    {
#line 46
    pw_write_zero(out, 22);
#line 47
    tmp = read16b(in);
#line 47
    size___0 = (int )tmp;
#line 47
    write16b(out, (uint16 )size___0);
#line 48
    ssize += size___0 * 2;
#line 49
    tmp___0 = read8(in);
#line 49
    write8(out, tmp___0);
#line 50
    tmp___1 = read8(in);
#line 50
    write8(out, tmp___1);
#line 51
    tmp___2 = read16b(in);
#line 51
    write16b(out, tmp___2);
#line 52
    tmp___3 = read16b(in);
#line 52
    write16b(out, tmp___3);
#line 45
    i___3 ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 55
  numpat = read8(in);
#line 55
  write8(out, numpat);
#line 56
  tmp___4 = read8(in);
#line 56
  write8(out, tmp___4);
#line 58
  max = 0;
#line 59
  j = 0;
  }
  {
#line 59
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 59
    if (! (j < 4)) {
#line 59
      goto while_break___0;
    }
#line 60
    i___3 = 0;
    {
#line 60
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 60
      if (! (i___3 < 128)) {
#line 60
        goto while_break___1;
      }
      {
#line 61
      trk[j][i___3] = read8(in);
      }
#line 62
      if ((int )trk[j][i___3] > max) {
#line 63
        max = (int )trk[j][i___3];
      }
#line 60
      i___3 ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 59
    j ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 68
  i___3 = 0;
  {
#line 68
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 68
    if (! (i___3 < (int )numpat)) {
#line 68
      goto while_break___2;
    }
    {
#line 69
    write8(out, (uint8 )i___3);
#line 68
    i___3 ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 70
  pw_write_zero(out, 128 - i___3);
#line 72
  write32b(out, (((77U << 24) | (46U << 16)) | (75U << 8)) | 46U);
#line 78
  j = 0;
  }
  {
#line 78
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 78
    if (! (j <= max)) {
#line 78
      goto while_break___3;
    }
#line 79
    i___3 = 0;
    {
#line 79
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 79
      if (! (i___3 < 64)) {
#line 79
        goto while_break___4;
      }
      {
#line 80
      tmp___5 = read16b(in);
#line 80
      tptr[j][i___3] = (int )tmp___5;
#line 79
      i___3 ++;
      }
    }
    while_break___4: /* CIL Label */ ;
    }
#line 78
    j ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 84
  tmp___6 = read32b(in);
#line 84
  tabsize = (int )tmp___6;
#line 87
  tmp___7 = malloc((size_t )tabsize);
#line 87
  tab = (uint8 *)tmp___7;
#line 88
  fread((void */* __restrict  */)tab, (size_t )tabsize, (size_t )1, (FILE */* __restrict  */)in);
#line 90
  i___3 = 0;
  }
  {
#line 90
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 90
    if (! (i___3 < (int )numpat)) {
#line 90
      goto while_break___5;
    }
    {
#line 91
    memset((void *)(buf___1), 0, (size_t )1024);
#line 92
    j = 0;
    }
    {
#line 92
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 92
      if (! (j < 64)) {
#line 92
        goto while_break___6;
      }
      {
#line 93
      b___1 = buf___1 + j * 16;
#line 94
      memcpy((void */* __restrict  */)b___1, (void const   */* __restrict  */)(tab + tptr[trk[0][i___3]][j] * 4),
             (size_t )4);
#line 95
      memcpy((void */* __restrict  */)(b___1 + 4), (void const   */* __restrict  */)(tab + tptr[trk[1][i___3]][j] * 4),
             (size_t )4);
#line 96
      memcpy((void */* __restrict  */)(b___1 + 8), (void const   */* __restrict  */)(tab + tptr[trk[2][i___3]][j] * 4),
             (size_t )4);
#line 97
      memcpy((void */* __restrict  */)(b___1 + 12), (void const   */* __restrict  */)(tab + tptr[trk[3][i___3]][j] * 4),
             (size_t )4);
#line 92
      j ++;
      }
    }
    while_break___6: /* CIL Label */ ;
    }
    {
#line 99
    fwrite((void const   */* __restrict  */)(buf___1), (size_t )1024, (size_t )1,
           (FILE */* __restrict  */)out);
#line 90
    i___3 ++;
    }
  }
  while_break___5: /* CIL Label */ ;
  }
  {
#line 102
  free((void *)tab);
#line 105
  pw_move_data(out, in, ssize);
  }
#line 107
  return (0);
}
}
#line 111 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/prowizard/pp21.c"
static int test_pp21(uint8 *data , int s ) 
{ 
  int j ;
  int k ;
  int l ;
  int start ;
  int ssize ;

  {
#line 114
  start = 0;
#line 117
  l = 0;
#line 118
  j = 0;
  {
#line 118
  while (1) {
    while_continue: /* CIL Label */ ;
#line 118
    if (! (j < 31)) {
#line 118
      goto while_break;
    }
#line 119
    k = (((int )*(data + (start + j * 8)) << 8) + (int )*(data + ((start + 1) + j * 8))) * 2;
#line 120
    l += k;
#line 123
    if ((int )*(data + ((start + 2) + 8 * j)) > 15) {
#line 124
      return (-1);
    }
#line 127
    if ((((int )*(data + ((start + 4) + j * 8)) << 8) + (int )*(data + ((start + 5) + j * 8))) * 2 > k) {
#line 128
      return (-1);
    }
#line 118
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 131
  if (l <= 2) {
#line 132
    return (-1);
  }
#line 135
  l = (int )*(data + (start + 248));
#line 136
  if (l > 127) {
#line 137
    return (-1);
  } else
#line 136
  if (l == 0) {
#line 137
    return (-1);
  }
#line 140
  k = 0;
#line 141
  j = 0;
  {
#line 141
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 141
    if (! (j < 512)) {
#line 141
      goto while_break___0;
    }
#line 142
    l = (int )*(data + ((start + 250) + j));
#line 143
    if (l > k) {
#line 144
      k = l;
    }
#line 141
    j ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 147
  k ++;
#line 148
  k *= 64;
#line 152
  ssize = 0;
#line 153
  j = 0;
  {
#line 153
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 153
    if (! (j < k)) {
#line 153
      goto while_break___1;
    }
#line 154
    l = ((int )*(data + ((start + 762) + j * 2)) << 8) + (int )*(data + ((start + 763) + j * 2));
#line 155
    if (l > ssize) {
#line 156
      ssize = l;
    }
#line 158
    if (l > 16384) {
#line 159
      return (-1);
    }
#line 153
    j ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 164
  k *= 2;
#line 165
  l = ((((int )*(data + ((start + k) + 762)) << 24) + ((int )*(data + ((start + k) + 763)) << 16)) + ((int )*(data + ((start + k) + 764)) << 8)) + (int )*(data + ((start + k) + 765));
#line 168
  if (l != (ssize + 1) * 4) {
#line 169
    return (-1);
  }
#line 171
  return (0);
}
}
#line 52 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/prowizard/prowiz.h"
uint8 const   ptk_table[37][2] ;
#line 76
struct pw_format pw_p50a ;
#line 19 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/prowizard/p50a.c"
static int test_p50a(uint8 *data , int s ) ;
#line 20
static int depack_p50a(FILE *in , FILE *out ) ;
#line 22 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/prowizard/p50a.c"
struct pw_format pw_p50a  =    {(char *)"P50A", (char *)"The Player 5.0a", 0, & test_p50a, & depack_p50a, 0, {(struct list_head *)0,
                                                                                  (struct list_head *)0}};
#line 33 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/prowizard/p50a.c"
static int depack_p50a(FILE *in , FILE *out ) 
{ 
  uint8 c1 ;
  uint8 c2 ;
  uint8 c3 ;
  uint8 c4 ;
  uint8 c5 ;
  uint8 c6 ;
  int max_row ;
  signed char *insDataWork ;
  uint8 PatPos ;
  uint8 npat ;
  uint8 nins ;
  uint8 tdata[512][256] ;
  uint8 ptable[128] ;
  uint8 GLOBAL_DELTA ;
  int isize[31] ;
  int taddr[128][4] ;
  int tdata_addr ;
  int sdata_addr ;
  int ssize ;
  int i___3 ;
  int j ;
  int k ;
  int l ;
  int a ;
  int b___1 ;
  int smp_size[31] ;
  int saddr[32] ;
  int val ;
  uint8 buf___1[1024] ;
  uint16 tmp ;
  int tmp___0 ;
  uint16 tmp___1 ;
  uint8 tmp___2 ;
  uint8 tmp___3 ;
  uint16 tmp___4 ;
  uint16 tmp___5 ;
  long tmp___6 ;
  uint8 *x ;
  uint8 *tmp___7 ;
  uint8 *tmp___8 ;
  uint8 *tmp___9 ;
  uint8 *tmp___10 ;
  uint8 *tmp___11 ;
  uint8 *tmp___12 ;
  uint8 *tmp___13 ;
  uint8 *tmp___14 ;
  long tmp___15 ;
  uint8 *tmp___16 ;
  uint8 *tmp___17 ;
  uint8 *tmp___18 ;
  uint8 *tmp___19 ;
  uint8 *tmp___20 ;
  uint8 *tmp___21 ;
  uint8 *tmp___22 ;
  uint8 *tmp___23 ;
  uint8 *tmp___24 ;
  uint8 *tmp___25 ;
  uint8 *tmp___26 ;
  uint8 *tmp___27 ;
  uint8 *tmp___28 ;
  uint8 *tmp___29 ;
  uint8 *tmp___30 ;
  uint8 *tmp___31 ;
  void *tmp___32 ;
  void *__cil_tmp67 ;
  int __cil_tmp68 ;
  void *__cil_tmp69 ;
  void *__cil_tmp70 ;
  void *__cil_tmp71 ;
  void *__cil_tmp72 ;
  int __cil_tmp73 ;
  void *__cil_tmp74 ;
  void *__cil_tmp75 ;
  void *__cil_tmp76 ;
  void *__cil_tmp77 ;

  {
  {
#line 38
  PatPos = (uint8 )0;
#line 39
  npat = (uint8 )0;
#line 40
  nins = (uint8 )0;
#line 43
  GLOBAL_DELTA = (uint8 )2;
#line 46
  tdata_addr = 0;
#line 47
  sdata_addr = 0;
#line 48
  ssize = 0;
#line 49
  i___3 = 0;
#line 55
  memset((void *)(taddr), 0, (size_t )2048);
#line 56
  memset((void *)(tdata), 0, (size_t )(512 << 8));
#line 57
  memset((void *)(ptable), 0, (size_t )128);
#line 58
  memset((void *)(smp_size), 0, (size_t )124);
#line 59
  memset((void *)(saddr), 0, (size_t )128);
#line 60
  memset((void *)(isize), 0, (size_t )(31UL * sizeof(int )));
#line 62
  tmp = read16b(in);
#line 62
  sdata_addr = (int )tmp;
#line 63
  npat = read8(in);
#line 64
  nins = read8(in);
  }
#line 66
  if (((int )nins & 128) == 128) {
#line 68
    GLOBAL_DELTA = (uint8 )1;
  }
  {
#line 70
  nins = (uint8 )((int )nins & 63);
#line 72
  pw_write_zero(out, 20);
#line 75
  i___3 = 0;
  }
  {
#line 75
  while (1) {
    while_continue: /* CIL Label */ ;
#line 75
    if (! (i___3 < (int )nins)) {
#line 75
      goto while_break;
    }
    {
#line 76
    pw_write_zero(out, 22);
#line 78
    tmp___1 = read16b(in);
#line 78
    tmp___0 = (int )tmp___1;
#line 78
    isize[i___3] = tmp___0;
#line 78
    j = tmp___0;
    }
#line 80
    if (j > 65280) {
#line 81
      smp_size[i___3] = smp_size[65535 - j];
#line 82
      isize[i___3] = isize[65535 - j];
#line 83
      saddr[i___3 + 1] = saddr[(65535 - j) + 1];
    } else {
#line 85
      saddr[i___3 + 1] = saddr[i___3] + smp_size[i___3 - 1];
#line 86
      smp_size[i___3] = j * 2;
#line 87
      ssize += smp_size[i___3];
    }
    {
#line 89
    j = smp_size[i___3] / 2;
#line 91
    write16b(out, (uint16 )isize[i___3]);
#line 93
    tmp___2 = read8(in);
#line 93
    write8(out, tmp___2);
#line 94
    tmp___3 = read8(in);
#line 94
    write8(out, tmp___3);
#line 95
    tmp___4 = read16b(in);
#line 95
    val = (int )tmp___4;
    }
#line 97
    if (val == 65535) {
      {
#line 98
      write16b(out, (uint16 )0);
#line 99
      write16b(out, (uint16 )1);
      }
    } else {
      {
#line 101
      write16b(out, (uint16 )val);
#line 102
      write16b(out, (uint16 )(j - val));
      }
    }
#line 75
    i___3 ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 107
  memset((void *)(buf___1), 0, (size_t )30);
#line 108
  buf___1[29] = (uint8 )1;
  }
  {
#line 109
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 109
    if (! (i___3 < 31)) {
#line 109
      goto while_break___0;
    }
    {
#line 110
    fwrite((void const   */* __restrict  */)(buf___1), (size_t )30, (size_t )1, (FILE */* __restrict  */)out);
#line 109
    i___3 ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 113
  i___3 = 0;
  {
#line 113
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 113
    if (! (i___3 < (int )npat)) {
#line 113
      goto while_break___1;
    }
#line 114
    j = 0;
    {
#line 114
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 114
      if (! (j < 4)) {
#line 114
        goto while_break___2;
      }
      {
#line 115
      tmp___5 = read16b(in);
#line 115
      taddr[i___3][j] = (int )tmp___5;
#line 114
      j ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
#line 113
    i___3 ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 119
  PatPos = (uint8 )0;
  {
#line 119
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 119
    if (! ((int )PatPos < 128)) {
#line 119
      goto while_break___3;
    }
    {
#line 120
    c1 = read8(in);
    }
#line 121
    if ((int )c1 == 255) {
#line 122
      goto while_break___3;
    }
#line 123
    ptable[PatPos] = (uint8 )((int )c1 / 2);
#line 119
    PatPos = (uint8 )((int )PatPos + 1);
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 125
  write8(out, PatPos);
#line 126
  write8(out, (uint8 )127);
#line 127
  fwrite((void const   */* __restrict  */)(ptable), (size_t )128, (size_t )1, (FILE */* __restrict  */)out);
#line 128
  write32b(out, (((77U << 24) | (46U << 16)) | (75U << 8)) | 46U);
#line 130
  tmp___6 = ftell(in);
#line 130
  tdata_addr = (int )tmp___6;
#line 134
  i___3 = 0;
  }
  {
#line 134
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 134
    if (! (i___3 < (int )npat)) {
#line 134
      goto while_break___4;
    }
#line 135
    max_row = 63;
#line 136
    j = 0;
    {
#line 136
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 136
      if (! (j < 4)) {
#line 136
        goto while_break___5;
      }
      {
#line 137
      fseek(in, (long )(taddr[i___3][j] + tdata_addr), 0);
#line 138
      k = 0;
      }
      {
#line 138
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 138
        if (! (k <= max_row)) {
#line 138
          goto while_break___6;
        }
        {
#line 139
        x = & tdata[i___3 * 4 + j][k * 4];
#line 140
        c1 = read8(in);
#line 141
        c2 = read8(in);
#line 142
        c3 = read8(in);
        }
#line 144
        if (((int )c1 & 128) == 128) {
#line 144
          if ((int )c1 != 128) {
            {
#line 145
            c4 = read8(in);
#line 146
            c1 = (uint8 )(255 - (int )c1);
#line 148
            tmp___7 = x;
#line 148
            x ++;
#line 148
            *tmp___7 = (uint8 )((((int )c1 << 4) & 16) | (int )ptk_table[(int )c1 / 2][0]);
#line 149
            tmp___8 = x;
#line 149
            x ++;
#line 149
            *tmp___8 = (uint8 )ptk_table[(int )c1 / 2][1];
#line 151
            c6 = (uint8 )((int )c2 & 15);
            }
#line 152
            if ((int )c6 == 8) {
#line 153
              c2 = (uint8 )((int )c2 - 8);
            }
#line 155
            tmp___9 = x;
#line 155
            x ++;
#line 155
            *tmp___9 = c2;
#line 157
            if ((int )c6 == 5) {
#line 157
              goto _L;
            } else
#line 157
            if ((int )c6 == 6) {
#line 157
              goto _L;
            } else
#line 157
            if ((int )c6 == 10) {
              _L: /* CIL Label */ 
#line 158
              if ((int )c3 > 127) {
#line 158
                c3 = (uint8 )((256 - (int )c3) << 4);
              } else {
#line 158
                c3 = c3;
              }
            }
#line 160
            tmp___10 = x;
#line 160
            x ++;
#line 160
            *tmp___10 = c3;
#line 162
            if ((int )c6 == 13) {
#line 163
              max_row = k;
#line 164
              k = 9999;
#line 165
              goto __Cont;
            }
#line 167
            if ((int )c6 == 11) {
#line 168
              max_row = k;
#line 169
              k = 9999;
#line 170
              goto __Cont;
            }
#line 172
            if ((int )c4 < 128) {
#line 173
              k += (int )c4;
#line 174
              goto __Cont;
            }
#line 176
            c4 = (uint8 )(256 - (int )c4);
#line 178
            l = 0;
            {
#line 178
            while (1) {
              while_continue___7: /* CIL Label */ ;
#line 178
              if (! (l < (int )c4)) {
#line 178
                goto while_break___7;
              }
#line 179
              k ++;
#line 180
              x = & tdata[i___3 * 4 + j][k * 4];
#line 182
              tmp___11 = x;
#line 182
              x ++;
#line 182
              *tmp___11 = (uint8 )((((int )c1 << 4) & 16) | (int )ptk_table[(int )c1 / 2][0]);
#line 183
              tmp___12 = x;
#line 183
              x ++;
#line 183
              *tmp___12 = (uint8 )ptk_table[(int )c1 / 2][1];
#line 185
              c6 = (uint8 )((int )c2 & 15);
#line 186
              if ((int )c6 == 8) {
#line 187
                c2 = (uint8 )((int )c2 - 8);
              }
#line 189
              tmp___13 = x;
#line 189
              x ++;
#line 189
              *tmp___13 = c2;
#line 191
              if ((int )c6 == 5) {
#line 191
                goto _L___0;
              } else
#line 191
              if ((int )c6 == 6) {
#line 191
                goto _L___0;
              } else
#line 191
              if ((int )c6 == 10) {
                _L___0: /* CIL Label */ 
#line 192
                if ((int )c3 > 127) {
#line 192
                  c3 = (uint8 )((256 - (int )c3) << 4);
                } else {
#line 192
                  c3 = c3;
                }
              }
#line 194
              tmp___14 = x;
#line 194
              x ++;
#line 194
              *tmp___14 = c3;
#line 178
              l ++;
            }
            while_break___7: /* CIL Label */ ;
            }
#line 196
            goto __Cont;
          }
        }
#line 199
        if ((int )c1 == 128) {
          {
#line 200
          c4 = read8(in);
#line 201
          tmp___15 = ftell(in);
#line 201
          a = (int )tmp___15;
#line 202
          c5 = c2;
#line 203
          fseek(in, (long )(- (((int )c3 << 8) + (int )c4)), 1);
#line 204
          l = 0;
          }
          {
#line 204
          while (1) {
            while_continue___8: /* CIL Label */ ;
#line 204
            if (! (l <= (int )c5)) {
#line 204
              goto while_break___8;
            }
            {
#line 205
            x = & tdata[i___3 * 4 + j][k * 4];
#line 207
            c1 = read8(in);
#line 208
            c2 = read8(in);
#line 209
            c3 = read8(in);
            }
#line 211
            if (((int )c1 & 128) == 128) {
#line 211
              if ((int )c1 != 128) {
                {
#line 212
                c4 = read8(in);
#line 213
                c1 = (uint8 )(255 - (int )c1);
#line 214
                tmp___16 = x;
#line 214
                x ++;
#line 214
                *tmp___16 = (uint8 )((((int )c1 << 4) & 16) | (int )ptk_table[(int )c1 / 2][0]);
#line 215
                tmp___17 = x;
#line 215
                x ++;
#line 215
                *tmp___17 = (uint8 )ptk_table[(int )c1 / 2][1];
#line 217
                c6 = (uint8 )((int )c2 & 15);
                }
#line 218
                if ((int )c6 == 8) {
#line 219
                  c2 = (uint8 )((int )c2 - 8);
                }
#line 221
                tmp___18 = x;
#line 221
                x ++;
#line 221
                *tmp___18 = c2;
#line 223
                if ((int )c6 == 5) {
#line 223
                  goto _L___1;
                } else
#line 223
                if ((int )c6 == 6) {
#line 223
                  goto _L___1;
                } else
#line 223
                if ((int )c6 == 10) {
                  _L___1: /* CIL Label */ 
#line 224
                  if ((int )c3 > 127) {
#line 224
                    c3 = (uint8 )((256 - (int )c3) << 4);
                  } else {
#line 224
                    c3 = c3;
                  }
                }
#line 226
                tmp___19 = x;
#line 226
                x ++;
#line 226
                *tmp___19 = c3;
#line 228
                if ((int )c6 == 13) {
#line 229
                  max_row = k;
#line 230
                  l = 9999;
#line 230
                  k = l;
#line 231
                  goto __Cont___0;
                }
#line 233
                if ((int )c6 == 11) {
#line 234
                  max_row = k;
#line 235
                  l = 9999;
#line 235
                  k = l;
#line 236
                  goto __Cont___0;
                }
#line 238
                if ((int )c4 < 128) {
#line 239
                  k += (int )c4;
#line 240
                  goto __Cont___0;
                }
#line 242
                c4 = (uint8 )(256 - (int )c4);
#line 244
                b___1 = 0;
                {
#line 244
                while (1) {
                  while_continue___9: /* CIL Label */ ;
#line 244
                  if (! (b___1 < (int )c4)) {
#line 244
                    goto while_break___9;
                  }
#line 245
                  k ++;
#line 246
                  x = & tdata[i___3 * 4 + j][k * 4];
#line 248
                  tmp___20 = x;
#line 248
                  x ++;
#line 248
                  *tmp___20 = (uint8 )((((int )c1 << 4) & 16) | (int )ptk_table[(int )c1 / 2][0]);
#line 250
                  tmp___21 = x;
#line 250
                  x ++;
#line 250
                  *tmp___21 = (uint8 )ptk_table[(int )c1 / 2][1];
#line 252
                  c6 = (uint8 )((int )c2 & 15);
#line 253
                  if ((int )c6 == 8) {
#line 254
                    c2 = (uint8 )((int )c2 - 8);
                  }
#line 256
                  tmp___22 = x;
#line 256
                  x ++;
#line 256
                  *tmp___22 = c2;
#line 258
                  if ((int )c6 == 5) {
#line 258
                    goto _L___2;
                  } else
#line 258
                  if ((int )c6 == 6) {
#line 258
                    goto _L___2;
                  } else
#line 258
                  if ((int )c6 == 10) {
                    _L___2: /* CIL Label */ 
#line 259
                    if ((int )c3 > 127) {
#line 259
                      c3 = (uint8 )((256 - (int )c3) << 4);
                    } else {
#line 259
                      c3 = c3;
                    }
                  }
#line 260
                  tmp___23 = x;
#line 260
                  x ++;
#line 260
                  *tmp___23 = c3;
#line 244
                  b___1 ++;
                }
                while_break___9: /* CIL Label */ ;
                }
              }
            }
#line 264
            x = & tdata[i___3 * 4 + j][k * 4];
#line 266
            tmp___24 = x;
#line 266
            x ++;
#line 266
            *tmp___24 = (uint8 )((((int )c1 << 4) & 16) | (int )ptk_table[(int )c1 / 2][0]);
#line 267
            tmp___25 = x;
#line 267
            x ++;
#line 267
            *tmp___25 = (uint8 )ptk_table[(int )c1 / 2][1];
#line 269
            c6 = (uint8 )((int )c2 & 15);
#line 270
            if ((int )c6 == 8) {
#line 271
              c2 = (uint8 )((int )c2 - 8);
            }
#line 273
            tmp___26 = x;
#line 273
            x ++;
#line 273
            *tmp___26 = c2;
#line 275
            if ((int )c6 == 5) {
#line 275
              goto _L___3;
            } else
#line 275
            if ((int )c6 == 6) {
#line 275
              goto _L___3;
            } else
#line 275
            if ((int )c6 == 10) {
              _L___3: /* CIL Label */ 
#line 276
              if ((int )c3 > 127) {
#line 276
                c3 = (uint8 )((256 - (int )c3) << 4);
              } else {
#line 276
                c3 = c3;
              }
            }
#line 278
            tmp___27 = x;
#line 278
            x ++;
#line 278
            *tmp___27 = c3;
            __Cont___0: /* CIL Label */ 
#line 204
            l ++;
#line 204
            k ++;
          }
          while_break___8: /* CIL Label */ ;
          }
          {
#line 280
          fseek(in, (long )a, 0);
#line 281
          k --;
          }
#line 282
          goto __Cont;
        }
#line 285
        x = & tdata[i___3 * 4 + j][k * 4];
#line 287
        tmp___28 = x;
#line 287
        x ++;
#line 287
        *tmp___28 = (uint8 )((((int )c1 << 4) & 16) | (int )ptk_table[(int )c1 / 2][0]);
#line 288
        tmp___29 = x;
#line 288
        x ++;
#line 288
        *tmp___29 = (uint8 )ptk_table[(int )c1 / 2][1];
#line 290
        c6 = (uint8 )((int )c2 & 15);
#line 291
        if ((int )c6 == 8) {
#line 292
          c2 = (uint8 )((int )c2 - 8);
        }
#line 294
        tmp___30 = x;
#line 294
        x ++;
#line 294
        *tmp___30 = c2;
#line 296
        if ((int )c6 == 5) {
#line 296
          goto _L___4;
        } else
#line 296
        if ((int )c6 == 6) {
#line 296
          goto _L___4;
        } else
#line 296
        if ((int )c6 == 10) {
          _L___4: /* CIL Label */ 
#line 297
          if ((int )c3 > 127) {
#line 297
            c3 = (uint8 )((256 - (int )c3) << 4);
          } else {
#line 297
            c3 = c3;
          }
        }
#line 299
        tmp___31 = x;
#line 299
        x ++;
#line 299
        *tmp___31 = c3;
#line 301
        if ((int )c6 == 13) {
#line 302
          max_row = k;
#line 303
          goto while_break___6;
        }
#line 305
        if ((int )c6 == 11) {
#line 306
          max_row = k;
#line 307
          goto while_break___6;
        }
        __Cont: /* CIL Label */ 
#line 138
        k ++;
      }
      while_break___6: /* CIL Label */ ;
      }
#line 136
      j ++;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 134
    i___3 ++;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 315
  i___3 = 0;
  {
#line 315
  while (1) {
    while_continue___10: /* CIL Label */ ;
#line 315
    if (! (i___3 < (int )npat)) {
#line 315
      goto while_break___10;
    }
    {
#line 316
    memset((void *)(buf___1), 0, (size_t )1024);
#line 317
    j = 0;
    }
    {
#line 317
    while (1) {
      while_continue___11: /* CIL Label */ ;
#line 317
      if (! (j < 64)) {
#line 317
        goto while_break___11;
      }
#line 318
      k = 0;
      {
#line 318
      while (1) {
        while_continue___12: /* CIL Label */ ;
#line 318
        if (! (k < 4)) {
#line 318
          goto while_break___12;
        }
        {
#line 319
        memcpy((void */* __restrict  */)(& buf___1[j * 16 + k * 4]), (void const   */* __restrict  */)(& tdata[k + i___3 * 4][j * 4]),
               (size_t )4);
#line 318
        k ++;
        }
      }
      while_break___12: /* CIL Label */ ;
      }
#line 317
      j ++;
    }
    while_break___11: /* CIL Label */ ;
    }
    {
#line 321
    fwrite((void const   */* __restrict  */)(buf___1), (size_t )1024, (size_t )1,
           (FILE */* __restrict  */)out);
#line 315
    i___3 ++;
    }
  }
  while_break___10: /* CIL Label */ ;
  }
  {
#line 325
  fseek(in, (long )sdata_addr, 0);
#line 328
  i___3 = 0;
  }
  {
#line 328
  while (1) {
    while_continue___13: /* CIL Label */ ;
#line 328
    if (! (i___3 < (int )nins)) {
#line 328
      goto while_break___13;
    }
    {
#line 329
    fseek(in, (long )(sdata_addr + saddr[i___3 + 1]), 0);
#line 330
    tmp___32 = malloc((size_t )smp_size[i___3]);
#line 330
    insDataWork = (signed char *)tmp___32;
#line 331
    memset((void *)insDataWork, 0, (size_t )smp_size[i___3]);
#line 332
    fread((void */* __restrict  */)insDataWork, (size_t )smp_size[i___3], (size_t )1,
          (FILE */* __restrict  */)in);
    }
#line 333
    if ((int )GLOBAL_DELTA == 1) {
#line 334
      c1 = (uint8 )*(insDataWork + 0);
#line 335
      j = 1;
      {
#line 335
      while (1) {
        while_continue___14: /* CIL Label */ ;
#line 335
        if (! (j < smp_size[i___3])) {
#line 335
          goto while_break___14;
        }
#line 336
        c2 = (uint8 )*(insDataWork + j);
#line 337
        c3 = (uint8 )((int )c1 - (int )c2);
#line 338
        *(insDataWork + j) = (signed char )c3;
#line 339
        c1 = c3;
#line 335
        j ++;
      }
      while_break___14: /* CIL Label */ ;
      }
    }
    {
#line 342
    fwrite((void const   */* __restrict  */)insDataWork, (size_t )smp_size[i___3],
           (size_t )1, (FILE */* __restrict  */)out);
#line 343
    free((void *)insDataWork);
#line 328
    i___3 ++;
    }
  }
  while_break___13: /* CIL Label */ ;
  }
#line 346
  if ((int )GLOBAL_DELTA == 1) {
#line 347
    pw_p50a.flags |= 2;
  }
#line 349
  return (0);
}
}
#line 353 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/prowizard/p50a.c"
static int test_p50a(uint8 *data , int s ) 
{ 
  int j ;
  int k ;
  int l ;
  int m___0 ;
  int n___0 ;
  int o___0 ;
  int start ;
  int ssize ;

  {
#line 356
  start = 0;
#line 360
  m___0 = (int )*(data + (start + 2));
#line 361
  if (m___0 > 127) {
#line 362
    return (-1);
  } else
#line 361
  if (m___0 == 0) {
#line 362
    return (-1);
  }
#line 366
  k = (int )*(data + (start + 3));
#line 367
  if ((k & 128) == 128) {
#line 368
    return (-1);
  }
#line 369
  if ((k & 63) > 31) {
#line 370
    return (-1);
  } else
#line 369
  if ((k & 63) == 0) {
#line 370
    return (-1);
  }
#line 371
  k &= 63;
#line 373
  l = 0;
  {
#line 373
  while (1) {
    while_continue: /* CIL Label */ ;
#line 373
    if (! (l < k)) {
#line 373
      goto while_break;
    }
#line 375
    if ((int )*(data + ((start + 7) + l * 6)) > 64) {
#line 376
      return (-1);
    }
#line 378
    if ((int )*(data + ((start + 6) + l * 6)) > 15) {
#line 379
      return (-1);
    }
#line 373
    l ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 383
  ssize = 0;
#line 384
  n___0 = 0;
  {
#line 384
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 384
    if (! (n___0 < k)) {
#line 384
      goto while_break___0;
    }
#line 385
    o___0 = ((int )*(data + ((start + 4) + n___0 * 6)) << 8) + (int )*(data + ((start + 5) + n___0 * 6));
#line 386
    if (o___0 < 65503) {
#line 386
      if (o___0 > 32768) {
#line 387
        return (-1);
      } else {
#line 386
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 386
    if (o___0 == 0) {
#line 387
      return (-1);
    }
#line 388
    if (o___0 < 65280) {
#line 389
      ssize += o___0 * 2;
    }
#line 391
    j = ((int )*(data + ((start + 8) + n___0 * 6)) << 8) + (int )*(data + ((start + 9) + n___0 * 6));
#line 392
    if (j != 65535) {
#line 392
      if (j >= o___0) {
#line 393
        return (-1);
      }
    }
#line 395
    if (o___0 > 65503) {
#line 396
      if (65535 - o___0 > k) {
#line 397
        return (-1);
      }
    }
#line 384
    n___0 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 403
  j = ((int )*(data + start) << 8) + (int )*(data + (start + 1));
#line 404
  if (j < (k * 6 + 4) + m___0 * 8) {
#line 405
    return (-1);
  }
#line 408
  l = 0;
  {
#line 408
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 408
    if (! (l < m___0 * 4)) {
#line 408
      goto while_break___1;
    }
#line 409
    o___0 = ((int )*(data + (((start + 4) + k * 6) + l * 2)) << 8) + (int )*(data + ((((start + 4) + k * 6) + l * 2) + 1));
#line 411
    if (((o___0 + k * 6) + 4) + m___0 * 8 > j) {
#line 412
      return (-1);
    }
#line 408
    l ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 416
  l = 0;
#line 417
  o___0 = 0;
  {
#line 419
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 419
    if (s < (((start + k * 6) + 4) + m___0 * 8) + 128) {
#line 419
      return (((((start + k * 6) + 4) + m___0 * 8) + 128) - s);
    }
#line 419
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 421
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 421
    if ((int )*(data + ((((start + k * 6) + 4) + m___0 * 8) + l)) != 255) {
#line 421
      if (! (l < 128)) {
#line 421
        goto while_break___3;
      }
    } else {
#line 421
      goto while_break___3;
    }
#line 423
    if (((int )*(data + ((((start + k * 6) + 4) + m___0 * 8) + l)) / 2) * 2 != (int )*(data + ((((start + k * 6) + 4) + m___0 * 8) + l))) {
#line 425
      return (-1);
    }
#line 427
    if ((int )*(data + ((((start + k * 6) + 4) + m___0 * 8) + l)) > m___0 * 2) {
#line 428
      return (-1);
    }
#line 430
    if ((int )*(data + ((((start + k * 6) + 4) + m___0 * 8) + l)) > o___0) {
#line 431
      o___0 = (int )*(data + ((((start + k * 6) + 4) + m___0 * 8) + l));
    }
#line 432
    l ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 436
  if (((k * 6 + 4) + m___0 * 8) + l > j) {
#line 437
    return (-1);
  }
#line 439
  if (l == 0) {
#line 440
    return (-1);
  } else
#line 439
  if (l == 128) {
#line 440
    return (-1);
  }
#line 442
  o___0 /= 2;
#line 443
  o___0 ++;
  {
#line 449
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 449
    if (s < (start + j) + 1) {
#line 449
      return (((start + j) + 1) - s);
    }
#line 449
    goto while_break___4;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 451
  l ++;
#line 452
  n___0 = ((k * 6 + 4) + m___0 * 8) + l;
  {
#line 452
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 452
    if (! (n___0 < j)) {
#line 452
      goto while_break___5;
    }
#line 453
    if (((int )*(data + (start + n___0)) & 128) == 0) {
#line 454
      if ((int )*(data + (start + n___0)) > 73) {
#line 455
        return (-1);
      }
#line 457
      if (((((int )*(data + (start + n___0)) << 4) & 16) | (((int )*(data + ((start + n___0) + 1)) >> 4) & 15)) > k) {
#line 458
        return (-1);
      }
#line 459
      n___0 += 2;
#line 460
      goto __Cont;
    }
#line 463
    if ((int )*(data + (start + n___0)) == 128) {
#line 465
      if ((int )*(data + ((start + n___0) + 1)) > 64) {
#line 466
        return (-1);
      }
#line 467
      if (((int )*(data + ((start + n___0) + 2)) << 8) + (int )*(data + ((start + n___0) + 3)) < (int )*(data + ((start + n___0) + 1)) * 3) {
#line 468
        return (-1);
      }
    }
#line 470
    n___0 += 3;
    __Cont: /* CIL Label */ 
#line 452
    n___0 ++;
  }
  while_break___5: /* CIL Label */ ;
  }
#line 476
  return (0);
}
}
#line 92 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/prowizard/prowiz.h"
struct pw_format pw_xann ;
#line 11 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/prowizard/xann.c"
static int depack_xann(FILE *in , FILE *out ) ;
#line 12
static int test_xann(uint8 *data , int s ) ;
#line 14 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/prowizard/xann.c"
struct pw_format pw_xann  =    {(char *)"XANN", (char *)"XANN Packer", 0, & test_xann, & depack_xann, 0, {(struct list_head *)0,
                                                                              (struct list_head *)0}};
#line 25 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/prowizard/xann.c"
static int depack_xann(FILE *in , FILE *out ) 
{ 
  uint8 c1 ;
  uint8 c2 ;
  uint8 c5 ;
  uint8 ptable[128] ;
  uint8 pat___0 ;
  uint8 note ;
  uint8 ins ;
  uint8 fxt ;
  uint8 fxp ;
  uint8 fine ;
  uint8 vol ;
  uint8 pdata[1025] ;
  int i___3 ;
  int j ;
  int l ;
  int size___0 ;
  int ssize ;
  int lsize ;
  uint32 tmp ;
  uint16 tmp___0 ;
  uint32 tmp___1 ;
  uint16 tmp___2 ;
  uint32 tmp___3 ;
  uint8 tmp___4 ;
  void *__cil_tmp27 ;
  void *__cil_tmp28 ;

  {
  {
#line 29
  pat___0 = (uint8 )0;
#line 34
  ssize = 0;
#line 37
  memset((void *)(ptable), 0, (size_t )128);
#line 38
  memset((void *)(pdata), 0, (size_t )1025);
#line 40
  pw_write_zero(out, 20);
#line 43
  fseek(in, 518L, 0);
#line 45
  i___3 = 0;
  }
  {
#line 45
  while (1) {
    while_continue: /* CIL Label */ ;
#line 45
    if (! (i___3 < 31)) {
#line 45
      goto while_break;
    }
    {
#line 46
    pw_write_zero(out, 22);
#line 48
    fine = read8(in);
#line 49
    vol = read8(in);
#line 50
    tmp = read32b(in);
#line 50
    j = (int )tmp;
#line 51
    tmp___0 = read16b(in);
#line 51
    lsize = (int )tmp___0;
#line 52
    tmp___1 = read32b(in);
#line 52
    l = (int )tmp___1;
#line 53
    tmp___2 = read16b(in);
#line 53
    size___0 = (int )tmp___2;
#line 53
    write16b(out, (uint16 )size___0);
#line 54
    ssize += size___0 * 2;
#line 56
    j -= l;
#line 57
    write8(out, fine);
#line 58
    write8(out, vol);
#line 59
    write16b(out, (uint16 )(j / 2));
#line 60
    write16b(out, (uint16 )lsize);
#line 62
    read16b(in);
#line 45
    i___3 ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 66
  fseek(in, 0L, 0);
#line 68
  c5 = (uint8 )0;
#line 68
  pat___0 = c5;
  }
  {
#line 68
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 68
    if (! ((int )c5 < 128)) {
#line 68
      goto while_break___0;
    }
    {
#line 69
    tmp___3 = read32b(in);
#line 69
    l = (int )tmp___3;
    }
#line 70
    if (l == 0) {
#line 71
      goto while_break___0;
    }
#line 72
    ptable[c5] = (uint8 )((l - 60) / 1024 - 1);
#line 73
    if ((int )ptable[c5] > (int )pat___0) {
#line 74
      pat___0 = ptable[c5];
    }
#line 68
    c5 = (uint8 )((int )c5 + 1);
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 76
  pat___0 = (uint8 )((int )pat___0 + 1);
#line 78
  write8(out, c5);
#line 79
  write8(out, (uint8 )127);
#line 81
  fwrite((void const   */* __restrict  */)(ptable), (size_t )128, (size_t )1, (FILE */* __restrict  */)out);
#line 82
  write32b(out, (((77U << 24) | (46U << 16)) | (75U << 8)) | 46U);
#line 85
  fseek(in, 1084L, 0);
#line 87
  i___3 = 0;
  }
  {
#line 87
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 87
    if (! (i___3 < (int )pat___0)) {
#line 87
      goto while_break___1;
    }
#line 88
    j = 0;
    {
#line 88
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 88
      if (! (j < 256)) {
#line 88
        goto while_break___2;
      }
      {
#line 89
      tmp___4 = read8(in);
#line 89
      ins = (uint8 )(((int )tmp___4 >> 3) & 31);
#line 90
      note = read8(in);
#line 91
      fxt = read8(in);
#line 92
      fxp = read8(in);
      }
      {
#line 95
      if ((int )fxt == 0) {
#line 95
        goto case_0;
      }
#line 98
      if ((int )fxt == 4) {
#line 98
        goto case_4;
      }
#line 101
      if ((int )fxt == 8) {
#line 101
        goto case_8;
      }
#line 104
      if ((int )fxt == 12) {
#line 104
        goto case_12;
      }
#line 107
      if ((int )fxt == 16) {
#line 107
        goto case_16;
      }
#line 110
      if ((int )fxt == 20) {
#line 110
        goto case_20;
      }
#line 113
      if ((int )fxt == 24) {
#line 113
        goto case_24;
      }
#line 116
      if ((int )fxt == 28) {
#line 116
        goto case_28;
      }
#line 119
      if ((int )fxt == 36) {
#line 119
        goto case_36;
      }
#line 122
      if ((int )fxt == 40) {
#line 122
        goto case_40;
      }
#line 128
      if ((int )fxt == 44) {
#line 128
        goto case_44;
      }
#line 131
      if ((int )fxt == 56) {
#line 131
        goto case_56;
      }
#line 134
      if ((int )fxt == 60) {
#line 134
        goto case_60;
      }
#line 140
      if ((int )fxt == 64) {
#line 140
        goto case_64;
      }
#line 143
      if ((int )fxt == 68) {
#line 143
        goto case_68;
      }
#line 146
      if ((int )fxt == 72) {
#line 146
        goto case_72;
      }
#line 149
      if ((int )fxt == 76) {
#line 149
        goto case_76;
      }
#line 152
      if ((int )fxt == 80) {
#line 152
        goto case_80;
      }
#line 155
      if ((int )fxt == 88) {
#line 155
        goto case_88;
      }
#line 159
      if ((int )fxt == 92) {
#line 159
        goto case_92;
      }
#line 163
      if ((int )fxt == 96) {
#line 163
        goto case_96;
      }
#line 167
      if ((int )fxt == 132) {
#line 167
        goto case_132;
      }
#line 171
      if ((int )fxt == 136) {
#line 171
        goto case_136;
      }
#line 175
      if ((int )fxt == 140) {
#line 175
        goto case_140;
      }
#line 179
      if ((int )fxt == 148) {
#line 179
        goto case_148;
      }
#line 183
      if ((int )fxt == 152) {
#line 183
        goto case_152;
      }
#line 187
      goto switch_default;
      case_0: /* CIL Label */ 
#line 96
      fxt = (uint8 )0;
#line 97
      goto switch_break;
      case_4: /* CIL Label */ 
#line 99
      fxt = (uint8 )0;
#line 100
      goto switch_break;
      case_8: /* CIL Label */ 
#line 102
      fxt = (uint8 )1;
#line 103
      goto switch_break;
      case_12: /* CIL Label */ 
#line 105
      fxt = (uint8 )2;
#line 106
      goto switch_break;
      case_16: /* CIL Label */ 
#line 108
      fxt = (uint8 )3;
#line 109
      goto switch_break;
      case_20: /* CIL Label */ 
#line 111
      fxt = (uint8 )3;
#line 112
      goto switch_break;
      case_24: /* CIL Label */ 
#line 114
      fxt = (uint8 )4;
#line 115
      goto switch_break;
      case_28: /* CIL Label */ 
#line 117
      fxt = (uint8 )4;
#line 118
      goto switch_break;
      case_36: /* CIL Label */ 
#line 120
      fxt = (uint8 )5;
#line 121
      goto switch_break;
      case_40: /* CIL Label */ 
#line 123
      fxt = (uint8 )6;
#line 124
      c1 = (uint8 )(((int )fxp << 4) & 240);
#line 125
      c2 = (uint8 )(((int )fxp >> 4) & 15);
#line 126
      fxp = (uint8 )((int )c1 | (int )c2);
#line 127
      goto switch_break;
      case_44: /* CIL Label */ 
#line 129
      fxt = (uint8 )6;
#line 130
      goto switch_break;
      case_56: /* CIL Label */ 
#line 132
      fxt = (uint8 )9;
#line 133
      goto switch_break;
      case_60: /* CIL Label */ 
#line 135
      fxt = (uint8 )10;
#line 136
      c1 = (uint8 )(((int )fxp << 4) & 240);
#line 137
      c2 = (uint8 )(((int )fxp >> 4) & 15);
#line 138
      fxp = (uint8 )((int )c1 | (int )c2);
#line 139
      goto switch_break;
      case_64: /* CIL Label */ 
#line 141
      fxt = (uint8 )10;
#line 142
      goto switch_break;
      case_68: /* CIL Label */ 
#line 144
      fxt = (uint8 )11;
#line 145
      goto switch_break;
      case_72: /* CIL Label */ 
#line 147
      fxt = (uint8 )12;
#line 148
      goto switch_break;
      case_76: /* CIL Label */ 
#line 150
      fxt = (uint8 )13;
#line 151
      goto switch_break;
      case_80: /* CIL Label */ 
#line 153
      fxt = (uint8 )15;
#line 154
      goto switch_break;
      case_88: /* CIL Label */ 
#line 156
      fxt = (uint8 )14;
#line 157
      fxp = (uint8 )1;
#line 158
      goto switch_break;
      case_92: /* CIL Label */ 
#line 160
      fxt = (uint8 )14;
#line 161
      fxp = (uint8 )((int )fxp | 16);
#line 162
      goto switch_break;
      case_96: /* CIL Label */ 
#line 164
      fxt = (uint8 )14;
#line 165
      fxp = (uint8 )((int )fxp | 32);
#line 166
      goto switch_break;
      case_132: /* CIL Label */ 
#line 168
      fxt = (uint8 )14;
#line 169
      fxp = (uint8 )((int )fxp | 144);
#line 170
      goto switch_break;
      case_136: /* CIL Label */ 
#line 172
      fxt = (uint8 )14;
#line 173
      fxp = (uint8 )((int )fxp | 160);
#line 174
      goto switch_break;
      case_140: /* CIL Label */ 
#line 176
      fxt = (uint8 )14;
#line 177
      fxp = (uint8 )((int )fxp | 176);
#line 178
      goto switch_break;
      case_148: /* CIL Label */ 
#line 180
      fxt = (uint8 )14;
#line 181
      fxp = (uint8 )((int )fxp | 208);
#line 182
      goto switch_break;
      case_152: /* CIL Label */ 
#line 184
      fxt = (uint8 )14;
#line 185
      fxp = (uint8 )((int )fxp | 224);
#line 186
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 188
      fxp = (uint8 )0;
#line 188
      fxt = fxp;
#line 189
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
#line 192
      pdata[j * 4] = (uint8 )((int )ins & 240);
#line 193
      pdata[j * 4] = (uint8 )((int )pdata[j * 4] | (int )ptk_table[(int )note / 2][0]);
#line 194
      pdata[j * 4 + 1] = (uint8 )ptk_table[(int )note / 2][1];
#line 195
      pdata[j * 4 + 2] = (uint8 )(((int )ins << 4) & 240);
#line 196
      pdata[j * 4 + 2] = (uint8 )((int )pdata[j * 4 + 2] | (int )fxt);
#line 197
      pdata[j * 4 + 3] = fxp;
#line 88
      j ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 200
    fwrite((void const   */* __restrict  */)(pdata), (size_t )1024, (size_t )1, (FILE */* __restrict  */)out);
#line 87
    i___3 ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 204
  pw_move_data(out, in, ssize);
  }
#line 206
  return (0);
}
}
#line 210 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/prowizard/xann.c"
static int test_xann(uint8 *data , int s ) 
{ 
  int i___3 ;
  int j ;
  int k ;
  int l ;
  int m___0 ;
  int start ;
  uint32 tmp ;
  uint16 tmp___0 ;
  uint32 tmp___1 ;

  {
#line 212
  i___3 = 0;
#line 213
  start = 0;
  {
#line 215
  while (1) {
    while_continue: /* CIL Label */ ;
#line 215
    if (s < 2048) {
#line 215
      return (2048 - s);
    }
#line 215
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 218
  if ((int )*(data + (i___3 + 3)) != 60) {
#line 219
    return (-1);
  }
#line 222
  l = 0;
  {
#line 222
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 222
    if (! (l < 128)) {
#line 222
      goto while_break___0;
    }
#line 223
    j = ((((int )*(data + (start + l * 4)) << 24) + ((int )*(data + ((start + l * 4) + 1)) << 16)) + ((int )*(data + ((start + l * 4) + 2)) << 8)) + (int )*(data + ((start + l * 4) + 3));
#line 227
    k = (j / 4) * 4;
#line 228
    if (k != j) {
#line 229
      return (-1);
    } else
#line 228
    if (j > 132156) {
#line 229
      return (-1);
    }
#line 222
    l ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 239
  j = 0;
  {
#line 239
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 239
    if (! (j < 64)) {
#line 239
      goto while_break___1;
    }
#line 240
    if ((int )*(data + ((start + 3) + j * 4)) != 60) {
#line 240
      if ((int )*(data + ((start + 3) + j * 4)) != 0) {
#line 242
        return (-1);
      }
    }
#line 239
    j ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 247
  j = 0;
  {
#line 247
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 247
    if (! (j < 31)) {
#line 247
      goto while_break___2;
    }
#line 248
    if ((int )*(data + ((start + 519) + 16 * j)) > 64) {
#line 249
      return (-1);
    }
#line 247
    j ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 253
  l = 0;
  {
#line 253
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 253
    if (! (l < 30)) {
#line 253
      goto while_break___3;
    }
    {
#line 254
    tmp = readmem32b(((data + start) + 526) + 16 * l);
#line 254
    k = (int )tmp;
#line 255
    tmp___0 = readmem16b(((data + start) + 524) + 16 * l);
#line 255
    j = (int )tmp___0 * 2;
#line 256
    tmp___1 = readmem32b(((data + start) + 520) + 16 * (l + 1));
#line 256
    m___0 = (int )tmp___1;
    }
#line 258
    if (k < 2108) {
#line 259
      return (-1);
    } else
#line 258
    if (m___0 < 2108) {
#line 259
      return (-1);
    }
#line 261
    if (k > m___0) {
#line 262
      return (-1);
    }
#line 253
    l ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 279
  return (0);
}
}
#line 75 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/prowizard/prowiz.h"
struct pw_format pw_p4x ;
#line 17 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/prowizard/p40.c"
static int test_p4x(uint8 *data , int s ) ;
#line 18
static int depack_p4x(FILE *in , FILE *out ) ;
#line 20 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/prowizard/p40.c"
struct pw_format pw_p4x  =    {(char *)"P4x", (char *)"The Player 4.x", 0, & test_p4x, & depack_p4x, 0, {(struct list_head *)0,
                                                                              (struct list_head *)0}};
#line 39 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/prowizard/p40.c"
static int depack_p4x(FILE *in , FILE *out ) 
{ 
  uint8 c1 ;
  uint8 c2 ;
  uint8 c3 ;
  uint8 c4 ;
  uint8 c5 ;
  uint8 tmp[1024] ;
  uint8 len ;
  uint8 npat ;
  uint8 nsmp ;
  uint8 sample___0 ;
  uint8 mynote ;
  uint8 note[2] ;
  uint8 tr[512][256] ;
  short track_addr[128][4] ;
  int trkdat_ofs ;
  int trktab_ofs ;
  int smp_ofs ;
  int ssize ;
  int SampleAddress[31] ;
  int SampleSize[31] ;
  int i___3 ;
  int j ;
  int k ;
  int l ;
  int a ;
  int b___1 ;
  int c___0 ;
  struct smp ins ;
  uint32 id ;
  uint32 tmp___0 ;
  uint32 tmp___1 ;
  uint32 tmp___2 ;
  uint32 tmp___3 ;
  uint32 tmp___4 ;
  uint16 tmp___5 ;
  uint16 tmp___6 ;
  uint16 tmp___7 ;
  int y ;
  int x ;
  long tmp___8 ;
  int x___0 ;
  int y___0 ;
  void *__cil_tmp45 ;
  void *__cil_tmp46 ;
  void *__cil_tmp47 ;
  int __cil_tmp48 ;
  void *__cil_tmp49 ;
  void *__cil_tmp50 ;
  int __cil_tmp51 ;
  void *__cil_tmp52 ;
  void *__cil_tmp53 ;
  void *__cil_tmp54 ;
  void *__cil_tmp55 ;
  void *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;

  {
  {
#line 48
  ssize = 0;
#line 55
  memset((void *)(track_addr), 0, (size_t )1024);
#line 56
  memset((void *)(tr), 0, (size_t )(512 << 8));
#line 57
  memset((void *)(SampleAddress), 0, (size_t )124);
#line 58
  memset((void *)(SampleSize), 0, (size_t )124);
#line 60
  id = read32b(in);
  }
#line 61
  if (id == ((((80U << 24) | (52U << 16)) | (48U << 8)) | 65U)) {
#line 62
    pw_p4x.id = (char *)"P40A";
#line 63
    pw_p4x.name = (char *)"The Player 4.0A";
  } else
#line 64
  if (id == ((((80U << 24) | (52U << 16)) | (48U << 8)) | 66U)) {
#line 65
    pw_p4x.id = (char *)"P40B";
#line 66
    pw_p4x.name = (char *)"The Player 4.0B";
  } else {
#line 68
    pw_p4x.id = (char *)"P41A";
#line 69
    pw_p4x.name = (char *)"The Player 4.1A";
  }
  {
#line 72
  npat = read8(in);
#line 73
  len = read8(in);
#line 74
  nsmp = read8(in);
#line 75
  read8(in);
#line 76
  tmp___0 = read32b(in);
#line 76
  trkdat_ofs = (int )tmp___0;
#line 77
  tmp___1 = read32b(in);
#line 77
  trktab_ofs = (int )tmp___1;
#line 78
  tmp___2 = read32b(in);
#line 78
  smp_ofs = (int )tmp___2;
#line 80
  pw_write_zero(out, 20);
#line 83
  i___3 = 0;
  }
  {
#line 83
  while (1) {
    while_continue: /* CIL Label */ ;
#line 83
    if (! (i___3 < (int )nsmp)) {
#line 83
      goto while_break;
    }
    {
#line 84
    tmp___3 = read32b(in);
#line 84
    ins.addr = (int )tmp___3;
#line 85
    SampleAddress[i___3] = ins.addr;
#line 86
    ins.size = read16b(in);
#line 87
    SampleSize[i___3] = (int )ins.size * 2;
#line 88
    ssize += SampleSize[i___3];
#line 89
    tmp___4 = read32b(in);
#line 89
    ins.loop_addr = (int )tmp___4;
#line 90
    ins.loop_size = read16b(in);
#line 91
    ins.fine = (int16 )0;
    }
#line 92
    if (id == ((((80U << 24) | (52U << 16)) | (48U << 8)) | 65U)) {
      {
#line 93
      tmp___5 = read16b(in);
#line 93
      ins.fine = (int16 )tmp___5;
      }
    } else
#line 92
    if (id == ((((80U << 24) | (52U << 16)) | (48U << 8)) | 66U)) {
      {
#line 93
      tmp___5 = read16b(in);
#line 93
      ins.fine = (int16 )tmp___5;
      }
    }
    {
#line 94
    read8(in);
#line 95
    ins.vol = read8(in);
    }
#line 96
    if (id == ((((80U << 24) | (52U << 16)) | (49U << 8)) | 65U)) {
      {
#line 97
      tmp___6 = read16b(in);
#line 97
      ins.fine = (int16 )tmp___6;
      }
    }
    {
#line 100
    pw_write_zero(out, 22);
#line 101
    write16b(out, ins.size);
#line 102
    write8(out, (uint8 )((int )ins.fine / 74));
#line 103
    write8(out, ins.vol);
#line 104
    write16b(out, (uint16 )((ins.loop_addr - ins.addr) / 2));
#line 105
    write16b(out, ins.loop_size);
#line 83
    i___3 ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 109
  memset((void *)(tmp), 0, (size_t )30);
#line 110
  tmp[29] = (uint8 )1;
  }
  {
#line 111
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 111
    if (! (i___3 < 31)) {
#line 111
      goto while_break___0;
    }
    {
#line 112
    fwrite((void const   */* __restrict  */)(tmp), (size_t )30, (size_t )1, (FILE */* __restrict  */)out);
#line 111
    i___3 ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 114
  write8(out, len);
#line 115
  write8(out, (uint8 )127);
#line 117
  fseek(in, (long )(trktab_ofs + 4), 0);
#line 119
  c1 = (uint8 )0;
  }
  {
#line 119
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 119
    if (! ((int )c1 < (int )len)) {
#line 119
      goto while_break___1;
    }
    {
#line 120
    write8(out, c1);
#line 119
    c1 = (uint8 )((int )c1 + 1);
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 121
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 121
    if (! ((int )c1 < 128)) {
#line 121
      goto while_break___2;
    }
    {
#line 122
    write8(out, (uint8 )0);
#line 121
    c1 = (uint8 )((int )c1 + 1);
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 124
  write32b(out, (((77U << 24) | (46U << 16)) | (75U << 8)) | 46U);
#line 126
  i___3 = 0;
  }
  {
#line 126
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 126
    if (! (i___3 < (int )len)) {
#line 126
      goto while_break___3;
    }
#line 127
    j = 0;
    {
#line 127
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 127
      if (! (j < 4)) {
#line 127
        goto while_break___4;
      }
      {
#line 128
      tmp___7 = read16b(in);
#line 128
      track_addr[i___3][j] = (short )(((int )tmp___7 + trkdat_ofs) + 4);
#line 127
      j ++;
      }
    }
    while_break___4: /* CIL Label */ ;
    }
#line 126
    i___3 ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 131
  fseek(in, (long )(trkdat_ofs + 4), 0);
#line 133
  i___3 = 0;
  }
  {
#line 133
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 133
    if (! (i___3 < (int )len)) {
#line 133
      goto while_break___5;
    }
#line 134
    j = 0;
    {
#line 134
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 134
      if (! (j < 4)) {
#line 134
        goto while_break___6;
      }
      {
#line 135
      x = i___3 * 4 + j;
#line 137
      fseek(in, (long )track_addr[i___3][j], 0);
#line 139
      k = 0;
      }
      {
#line 139
      while (1) {
        while_continue___7: /* CIL Label */ ;
#line 139
        if (! (k < 64)) {
#line 139
          goto while_break___7;
        }
        {
#line 140
        c1 = read8(in);
#line 141
        c2 = read8(in);
#line 142
        c3 = read8(in);
#line 143
        c4 = read8(in);
        }
#line 145
        if ((int )c1 != 128) {
          {
#line 146
          sample___0 = (uint8 )((((int )c1 << 4) & 16) | (((int )c2 >> 4) & 15));
#line 148
          memset((void *)(note), 0, (size_t )2);
#line 149
          mynote = (uint8 )((int )c1 & 127);
#line 150
          note[0] = (uint8 )ptk_table[(int )mynote / 2][0];
#line 151
          note[1] = (uint8 )ptk_table[(int )mynote / 2][1];
          }
          {
#line 153
          if (((int )c2 & 15) == 8) {
#line 153
            goto case_8;
          }
#line 158
          if (((int )c2 & 15) == 10) {
#line 158
            goto case_10;
          }
#line 158
          if (((int )c2 & 15) == 6) {
#line 158
            goto case_10;
          }
#line 158
          if (((int )c2 & 15) == 5) {
#line 158
            goto case_10;
          }
#line 162
          goto switch_default;
          case_8: /* CIL Label */ 
#line 154
          c2 = (uint8 )((int )c2 - 8);
#line 155
          goto switch_break;
          case_10: /* CIL Label */ 
          case_6: /* CIL Label */ 
          case_5: /* CIL Label */ 
#line 159
          if ((int )c3 >= 128) {
#line 160
            c3 = (uint8 )(((int )c3 << 4) & 240);
          }
#line 161
          goto switch_break;
          switch_default: /* CIL Label */ 
#line 163
          goto switch_break;
          switch_break: /* CIL Label */ ;
          }
#line 165
          y = k * 4;
#line 166
          tr[x][y] = (uint8 )(((int )sample___0 & 240) | ((int )note[0] & 15));
#line 168
          tr[x][y + 1] = note[1];
#line 169
          tr[x][y + 2] = c2;
#line 170
          tr[x][y + 3] = c3;
#line 172
          if ((int )c4 > 0) {
#line 172
            if ((int )c4 < 128) {
#line 173
              k += (int )c4;
            }
          }
#line 174
          if ((int )c4 > 127) {
#line 175
            k ++;
#line 176
            l = 256;
            {
#line 176
            while (1) {
              while_continue___8: /* CIL Label */ ;
#line 176
              if (! (l > (int )c4)) {
#line 176
                goto while_break___8;
              }
#line 177
              y = k * 4;
#line 178
              tr[x][y] = (uint8 )(((int )sample___0 & 240) | ((int )note[0] & 15));
#line 181
              tr[x][y + 1] = note[1];
#line 182
              tr[x][y + 2] = c2;
#line 183
              tr[x][y + 3] = c3;
#line 184
              k ++;
#line 176
              l --;
            }
            while_break___8: /* CIL Label */ ;
            }
#line 186
            k --;
          }
#line 188
          goto __Cont;
        }
        {
#line 191
        tmp___8 = ftell(in);
#line 191
        a = (int )tmp___8;
#line 193
        c5 = c2;
#line 194
        b___1 = ((((int )c3 << 8) + (int )c4) + trkdat_ofs) + 4;
#line 196
        fseek(in, (long )b___1, 0);
#line 198
        c___0 = 0;
        }
        {
#line 198
        while (1) {
          while_continue___9: /* CIL Label */ ;
#line 198
          if (! (c___0 <= (int )c5)) {
#line 198
            goto while_break___9;
          }
          {
#line 199
          c1 = read8(in);
#line 200
          c2 = read8(in);
#line 201
          c3 = read8(in);
#line 202
          c4 = read8(in);
#line 204
          sample___0 = (uint8 )((((int )c1 << 4) & 16) | (((int )c2 >> 4) & 15));
#line 206
          memset((void *)(note), 0, (size_t )2);
#line 207
          mynote = (uint8 )((int )c1 & 127);
#line 208
          note[0] = (uint8 )ptk_table[(int )mynote / 2][0];
#line 209
          note[1] = (uint8 )ptk_table[(int )mynote / 2][1];
          }
          {
#line 211
          if (((int )c2 & 15) == 8) {
#line 211
            goto case_8___0;
          }
#line 216
          if (((int )c2 & 15) == 10) {
#line 216
            goto case_10___0;
          }
#line 216
          if (((int )c2 & 15) == 6) {
#line 216
            goto case_10___0;
          }
#line 216
          if (((int )c2 & 15) == 5) {
#line 216
            goto case_10___0;
          }
#line 220
          goto switch_default___0;
          case_8___0: /* CIL Label */ 
#line 212
          c2 = (uint8 )((int )c2 - 8);
#line 213
          goto switch_break___0;
          case_10___0: /* CIL Label */ 
          case_6___0: /* CIL Label */ 
          case_5___0: /* CIL Label */ 
#line 217
          if ((int )c3 >= 128) {
#line 218
            c3 = (uint8 )(((int )c3 << 4) & 240);
          }
#line 219
          goto switch_break___0;
          switch_default___0: /* CIL Label */ 
#line 221
          goto switch_break___0;
          switch_break___0: /* CIL Label */ ;
          }
#line 223
          tr[x][k * 4] = (uint8 )(((int )sample___0 & 240) | ((int )note[0] & 15));
#line 225
          tr[x][k * 4 + 1] = note[1];
#line 226
          tr[x][k * 4 + 2] = c2;
#line 227
          tr[x][k * 4 + 3] = c3;
#line 229
          if ((int )c4 > 0) {
#line 229
            if ((int )c4 < 128) {
#line 230
              k += (int )c4;
            }
          }
#line 231
          if ((int )c4 > 127) {
#line 232
            k ++;
#line 233
            l = 256;
            {
#line 233
            while (1) {
              while_continue___10: /* CIL Label */ ;
#line 233
              if (! (l > (int )c4)) {
#line 233
                goto while_break___10;
              }
#line 234
              y = k * 4;
#line 235
              tr[x][y] = (uint8 )(((int )sample___0 & 240) | ((int )note[0] & 15));
#line 238
              tr[x][y + 1] = note[1];
#line 239
              tr[x][y + 2] = c2;
#line 240
              tr[x][y + 3] = c3;
#line 241
              k ++;
#line 233
              l --;
            }
            while_break___10: /* CIL Label */ ;
            }
#line 243
            k --;
          }
#line 245
          k ++;
#line 198
          c___0 ++;
        }
        while_break___9: /* CIL Label */ ;
        }
        {
#line 247
        k --;
#line 248
        fseek(in, (long )a, 0);
        }
        __Cont: /* CIL Label */ 
#line 139
        k ++;
      }
      while_break___7: /* CIL Label */ ;
      }
#line 134
      j ++;
    }
    while_break___6: /* CIL Label */ ;
    }
#line 133
    i___3 ++;
  }
  while_break___5: /* CIL Label */ ;
  }
#line 254
  i___3 = 0;
  {
#line 254
  while (1) {
    while_continue___11: /* CIL Label */ ;
#line 254
    if (! (i___3 < (int )len)) {
#line 254
      goto while_break___11;
    }
    {
#line 255
    memset((void *)(tmp), 0, (size_t )1024);
#line 256
    j = 0;
    }
    {
#line 256
    while (1) {
      while_continue___12: /* CIL Label */ ;
#line 256
      if (! (j < 64)) {
#line 256
        goto while_break___12;
      }
#line 257
      k = 0;
      {
#line 257
      while (1) {
        while_continue___13: /* CIL Label */ ;
#line 257
        if (! (k < 4)) {
#line 257
          goto while_break___13;
        }
#line 258
        x___0 = j * 16 + k * 4;
#line 259
        y___0 = k + i___3 * 4;
#line 261
        tmp[x___0] = tr[y___0][j * 4];
#line 262
        tmp[x___0 + 1] = tr[y___0][j * 4 + 1];
#line 263
        tmp[x___0 + 2] = tr[y___0][j * 4 + 2];
#line 264
        tmp[x___0 + 3] = tr[y___0][j * 4 + 3];
#line 257
        k ++;
      }
      while_break___13: /* CIL Label */ ;
      }
#line 256
      j ++;
    }
    while_break___12: /* CIL Label */ ;
    }
    {
#line 267
    fwrite((void const   */* __restrict  */)(tmp), (size_t )1024, (size_t )1, (FILE */* __restrict  */)out);
#line 254
    i___3 ++;
    }
  }
  while_break___11: /* CIL Label */ ;
  }
#line 271
  i___3 = 0;
  {
#line 271
  while (1) {
    while_continue___14: /* CIL Label */ ;
#line 271
    if (! (i___3 < (int )nsmp)) {
#line 271
      goto while_break___14;
    }
    {
#line 272
    fseek(in, (long )(SampleAddress[i___3] + smp_ofs), 0);
#line 273
    pw_move_data(out, in, SampleSize[i___3]);
#line 271
    i___3 ++;
    }
  }
  while_break___14: /* CIL Label */ ;
  }
#line 276
  return (0);
}
}
#line 280 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/prowizard/p40.c"
static int test_p4x(uint8 *data , int s ) 
{ 
  uint32 id ;

  {
  {
#line 286
  id = readmem32b(data);
  }
#line 288
  if (id == ((((80U << 24) | (52U << 16)) | (48U << 8)) | 65U)) {
#line 289
    return (0);
  } else
#line 288
  if (id == ((((80U << 24) | (52U << 16)) | (48U << 8)) | 66U)) {
#line 289
    return (0);
  } else
#line 288
  if (id == ((((80U << 24) | (52U << 16)) | (49U << 8)) | 65U)) {
#line 289
    return (0);
  }
#line 291
  return (-1);
}
}
#line 86 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/prowizard/prowiz.h"
struct pw_format pw_tp3 ;
#line 13 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/prowizard/tp3.c"
static int depack_tp3(FILE *in , FILE *out ) ;
#line 14
static int test_tp3(uint8 *data , int s ) ;
#line 16 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/prowizard/tp3.c"
struct pw_format pw_tp3  =    {(char *)"TP3", (char *)"Tracker Packer v3", 0, & test_tp3, & depack_tp3, 0, {(struct list_head *)0,
                                                                                 (struct list_head *)0}};
#line 25 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/prowizard/tp3.c"
static int depack_tp3(FILE *in , FILE *out ) 
{ 
  uint8 c1 ;
  uint8 c2 ;
  uint8 c3 ;
  uint8 c4 ;
  uint8 pnum[128] ;
  uint8 pdata[1024] ;
  uint8 tmp[50] ;
  uint8 note ;
  uint8 ins ;
  uint8 fxt ;
  uint8 fxp ;
  uint8 npat ;
  uint8 nsmp ;
  uint8 len ;
  int trk_ofs[128][4] ;
  int i___3 ;
  int j ;
  int k ;
  int pat_ofs ;
  int size___0 ;
  int ssize ;
  int max_trk_ofs ;
  uint16 tmp___0 ;
  uint16 tmp___1 ;
  uint16 tmp___2 ;
  uint16 tmp___3 ;
  uint16 tmp___4 ;
  uint16 tmp___5 ;
  long tmp___6 ;
  int where ;
  int x ;
  long tmp___7 ;
  void *__cil_tmp35 ;
  void *__cil_tmp36 ;
  void *__cil_tmp37 ;
  void *__cil_tmp38 ;
  int __cil_tmp39 ;
  void *__cil_tmp40 ;

  {
  {
#line 35
  i___3 = 0;
#line 35
  j = 0;
#line 36
  pat_ofs = 999999;
#line 37
  ssize = 0;
#line 38
  max_trk_ofs = 0;
#line 40
  memset((void *)(trk_ofs), 0, (size_t )2048);
#line 41
  memset((void *)(pnum), 0, (size_t )128);
#line 43
  fseek(in, 8L, 1);
#line 44
  pw_move_data(out, in, 20);
#line 45
  tmp___0 = read16b(in);
#line 45
  nsmp = (uint8 )((int )tmp___0 / 8);
#line 47
  i___3 = 0;
  }
  {
#line 47
  while (1) {
    while_continue: /* CIL Label */ ;
#line 47
    if (! (i___3 < (int )nsmp)) {
#line 47
      goto while_break;
    }
    {
#line 48
    pw_write_zero(out, 22);
#line 50
    c3 = read8(in);
#line 51
    c4 = read8(in);
#line 53
    tmp___1 = read16b(in);
#line 53
    size___0 = (int )tmp___1;
#line 53
    write16b(out, (uint16 )size___0);
#line 54
    ssize += size___0 * 2;
#line 56
    write8(out, c3);
#line 57
    write8(out, c4);
#line 59
    tmp___2 = read16b(in);
#line 59
    write16b(out, tmp___2);
#line 60
    tmp___3 = read16b(in);
#line 60
    write16b(out, tmp___3);
#line 47
    i___3 ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 63
  memset((void *)(tmp), 0, (size_t )30);
#line 64
  tmp[29] = (uint8 )1;
  }
  {
#line 66
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 66
    if (! (i___3 < 31)) {
#line 66
      goto while_break___0;
    }
    {
#line 67
    fwrite((void const   */* __restrict  */)(tmp), (size_t )30, (size_t )1, (FILE */* __restrict  */)out);
#line 66
    i___3 ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 70
  read8(in);
#line 71
  len = read8(in);
#line 71
  write8(out, len);
#line 72
  write8(out, (uint8 )127);
#line 74
  i___3 = 0;
#line 74
  npat = (uint8 )i___3;
  }
  {
#line 74
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 74
    if (! (i___3 < (int )len)) {
#line 74
      goto while_break___1;
    }
    {
#line 75
    tmp___4 = read16b(in);
#line 75
    pnum[i___3] = (uint8 )((int )tmp___4 / 8);
    }
#line 76
    if ((int )pnum[i___3] > (int )npat) {
#line 77
      npat = pnum[i___3];
    }
#line 74
    i___3 ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 84
  i___3 = 0;
  {
#line 84
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 84
    if (! (i___3 <= (int )npat)) {
#line 84
      goto while_break___2;
    }
#line 85
    j = 0;
    {
#line 85
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 85
      if (! (j < 4)) {
#line 85
        goto while_break___3;
      }
      {
#line 86
      tmp___5 = read16b(in);
#line 86
      trk_ofs[i___3][j] = (int )tmp___5;
      }
#line 87
      if (trk_ofs[i___3][j] > max_trk_ofs) {
#line 88
        max_trk_ofs = trk_ofs[i___3][j];
      }
#line 85
      j ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 84
    i___3 ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 92
  fwrite((void const   */* __restrict  */)(pnum), (size_t )128, (size_t )1, (FILE */* __restrict  */)out);
#line 93
  write32b(out, (((77U << 24) | (46U << 16)) | (75U << 8)) | 46U);
#line 95
  tmp___6 = ftell(in);
#line 95
  pat_ofs = (int )(tmp___6 + 2L);
#line 98
  i___3 = 0;
  }
  {
#line 98
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 98
    if (! (i___3 <= (int )npat)) {
#line 98
      goto while_break___4;
    }
    {
#line 99
    memset((void *)(pdata), 0, (size_t )1024);
#line 101
    j = 0;
    }
    {
#line 101
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 101
      if (! (j < 4)) {
#line 101
        goto while_break___5;
      }
      {
#line 104
      fseek(in, (long )(pat_ofs + trk_ofs[i___3][j]), 0);
#line 106
      k = 0;
      }
      {
#line 106
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 106
        if (! (k < 64)) {
#line 106
          goto while_break___6;
        }
        {
#line 107
        x = k * 16 + j * 4;
#line 109
        c1 = read8(in);
        }
#line 110
        if (((int )c1 & 192) == 192) {
#line 113
          k += 128 - ((int )c1 & 63);
#line 114
          goto __Cont;
        }
#line 117
        if (((int )c1 & 192) == 128) {
          {
#line 118
          c2 = read8(in);
#line 119
          fxt = (uint8 )(((int )c1 >> 1) & 15);
#line 120
          fxp = c2;
          }
#line 121
          if ((int )fxt == 5) {
#line 121
            goto _L;
          } else
#line 121
          if ((int )fxt == 6) {
#line 121
            goto _L;
          } else
#line 121
          if ((int )fxt == 10) {
            _L: /* CIL Label */ 
#line 123
            if ((int )fxp > 128) {
#line 124
              fxp = (uint8 )(256 - (int )fxp);
            } else
#line 125
            if ((int )fxp <= 128) {
#line 126
              fxp = (uint8 )(((int )fxp << 4) & 240);
            }
          }
#line 128
          if ((int )fxt == 8) {
#line 129
            fxt = (uint8 )0;
          }
#line 130
          pdata[x + 2] = fxt;
#line 131
          pdata[x + 3] = fxp;
#line 132
          goto __Cont;
        }
        {
#line 135
        c2 = read8(in);
#line 137
        ins = (uint8 )((((int )c2 >> 4) & 15) | (((int )c1 >> 2) & 16));
        }
#line 139
        if (((int )c1 & 64) == 64) {
#line 140
          note = (uint8 )(127 - (int )c1);
        } else {
#line 142
          note = (uint8 )((int )c1 & 63);
        }
#line 144
        fxt = (uint8 )((int )c2 & 15);
#line 146
        if ((int )fxt == 0) {
#line 147
          pdata[x] = (uint8 )((int )ins & 240);
#line 148
          pdata[x] = (uint8 )((int )pdata[x] | (int )ptk_table[note][0]);
#line 149
          pdata[x + 1] = (uint8 )ptk_table[note][1];
#line 150
          pdata[x + 2] = (uint8 )(((int )ins << 4) & 240);
#line 151
          goto __Cont;
        }
        {
#line 154
        c3 = read8(in);
        }
#line 156
        if ((int )fxt == 8) {
#line 157
          fxt = (uint8 )0;
        }
#line 159
        fxp = c3;
#line 160
        if ((int )fxt == 5) {
#line 160
          goto _L___0;
        } else
#line 160
        if ((int )fxt == 6) {
#line 160
          goto _L___0;
        } else
#line 160
        if ((int )fxt == 10) {
          _L___0: /* CIL Label */ 
#line 162
          if ((int )fxp > 128) {
#line 163
            fxp = (uint8 )(256 - (int )fxp);
          } else
#line 164
          if ((int )fxp <= 128) {
#line 165
            fxp = (uint8 )(((int )fxp << 4) & 240);
          }
        }
#line 168
        pdata[x] = (uint8 )((int )ins & 240);
#line 169
        pdata[x] = (uint8 )((int )pdata[x] | (int )ptk_table[note][0]);
#line 170
        pdata[x + 1] = (uint8 )ptk_table[note][1];
#line 171
        pdata[x + 2] = (uint8 )(((int )ins << 4) & 240);
#line 172
        pdata[x + 2] = (uint8 )((int )pdata[x + 2] | (int )fxt);
#line 173
        pdata[x + 3] = fxp;
        __Cont: /* CIL Label */ 
#line 106
        k ++;
      }
      while_break___6: /* CIL Label */ ;
      }
      {
#line 175
      tmp___7 = ftell(in);
#line 175
      where = (int )tmp___7;
      }
#line 176
      if (where > max_trk_ofs) {
#line 177
        max_trk_ofs = where;
      }
#line 101
      j ++;
    }
    while_break___5: /* CIL Label */ ;
    }
    {
#line 179
    fwrite((void const   */* __restrict  */)(pdata), (size_t )1024, (size_t )1, (FILE */* __restrict  */)out);
#line 98
    i___3 ++;
    }
  }
  while_break___4: /* CIL Label */ ;
  }
#line 183
  if ((max_trk_ofs / 2) * 2 != max_trk_ofs) {
#line 184
    max_trk_ofs ++;
  }
  {
#line 186
  fseek(in, (long )max_trk_ofs, 0);
#line 187
  pw_move_data(out, in, ssize);
  }
#line 189
  return (0);
}
}
#line 193 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/prowizard/tp3.c"
static int test_tp3(uint8 *data , int s ) 
{ 
  int start ;
  int j ;
  int k ;
  int l ;
  int m___0 ;
  int n___0 ;
  int ssize ;
  int tmp ;
  int x ;
  char *__cil_tmp12 ;

  {
#line 195
  start = 0;
  {
#line 199
  while (1) {
    while_continue: /* CIL Label */ ;
#line 199
    if (s < 1024) {
#line 199
      return (1024 - s);
    }
#line 199
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 201
  tmp = memcmp((void const   *)data, (void const   *)"CPLX_TP3", (size_t )8);
  }
#line 201
  if (tmp) {
#line 202
    return (-1);
  }
#line 205
  l = ((int )*(data + (start + 28)) << 8) + (int )*(data + (start + 29));
#line 207
  if ((l / 8) * 8 != l) {
#line 208
    return (-1);
  } else
#line 207
  if (l == 0) {
#line 208
    return (-1);
  }
#line 210
  l /= 8;
#line 215
  k = 0;
  {
#line 215
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 215
    if (! (k < l)) {
#line 215
      goto while_break___0;
    }
#line 216
    if ((int )*(data + ((start + 30) + k * 8)) > 15) {
#line 217
      return (-1);
    }
#line 215
    k ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 221
  k = 0;
  {
#line 221
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 221
    if (! (k < l)) {
#line 221
      goto while_break___1;
    }
#line 222
    if ((int )*(data + ((start + 31) + k * 8)) > 64) {
#line 223
      return (-1);
    }
#line 221
    k ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 227
  ssize = 0;
#line 228
  k = 0;
  {
#line 228
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 228
    if (! (k < l)) {
#line 228
      goto while_break___2;
    }
#line 229
    x = start + k * 8;
#line 231
    j = (((int )*(data + (x + 32)) << 8) + (int )*(data + (x + 33))) * 2;
#line 232
    m___0 = (((int )*(data + (x + 34)) << 8) + (int )*(data + (x + 35))) * 2;
#line 233
    n___0 = (((int )*(data + (x + 36)) << 8) + (int )*(data + (x + 37))) * 2;
#line 235
    if (j > 65535) {
#line 236
      return (-1);
    } else
#line 235
    if (m___0 > 65535) {
#line 236
      return (-1);
    } else
#line 235
    if (n___0 > 65535) {
#line 236
      return (-1);
    }
#line 238
    if (m___0 + n___0 > j + 2) {
#line 239
      return (-1);
    }
#line 241
    if (m___0 != 0) {
#line 241
      if (n___0 == 0) {
#line 242
        return (-1);
      }
    }
#line 244
    ssize += j;
#line 228
    k ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 247
  if (ssize <= 4) {
#line 248
    return (-1);
  }
#line 251
  j = (int )*(data + ((start + l * 8) + 31));
#line 252
  if (l == 0) {
#line 253
    return (-1);
  } else
#line 252
  if (l > 128) {
#line 253
    return (-1);
  }
#line 259
  return (0);
}
}
#line 93 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/prowizard/prowiz.h"
struct pw_format pw_zen ;
#line 13 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/prowizard/zen.c"
static int test_zen(uint8 *data , int s ) ;
#line 14
static int depack_zen(FILE *in , FILE *out ) ;
#line 16 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/prowizard/zen.c"
struct pw_format pw_zen  =    {(char *)"ZEN", (char *)"Zen Packer", 0, & test_zen, & depack_zen, 0, {(struct list_head *)0,
                                                                          (struct list_head *)0}};
#line 24 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/prowizard/zen.c"
static int depack_zen(FILE *in , FILE *out ) 
{ 
  uint8 c1 ;
  uint8 c2 ;
  uint8 c3 ;
  uint8 c4 ;
  uint8 finetune ;
  uint8 vol ;
  uint8 pat_pos ;
  uint8 pat_max ;
  uint8 note ;
  uint8 ins ;
  uint8 fxt ;
  uint8 fxp ;
  uint8 pat___0[1024] ;
  uint8 ptable[128] ;
  int size___0 ;
  int ssize ;
  int paddr[128] ;
  int paddr_Real[128] ;
  int ptable_addr ;
  int sdata_addr ;
  int i___3 ;
  int j ;
  int k ;
  uint32 tmp ;
  uint16 tmp___0 ;
  uint16 tmp___1 ;
  uint16 tmp___2 ;
  uint32 tmp___3 ;
  uint32 tmp___4 ;
  uint32 tmp___5 ;
  void *__cil_tmp33 ;
  void *__cil_tmp34 ;
  void *__cil_tmp35 ;
  void *__cil_tmp36 ;

  {
  {
#line 33
  ssize = 0;
#line 37
  sdata_addr = 999999;
#line 40
  memset((void *)(paddr), 0, (size_t )512);
#line 41
  memset((void *)(paddr_Real), 0, (size_t )512);
#line 42
  memset((void *)(ptable), 0, (size_t )128);
#line 44
  tmp = read32b(in);
#line 44
  ptable_addr = (int )tmp;
#line 45
  pat_max = read8(in);
#line 46
  pat_pos = read8(in);
#line 48
  pw_write_zero(out, 20);
#line 50
  i___3 = 0;
  }
  {
#line 50
  while (1) {
    while_continue: /* CIL Label */ ;
#line 50
    if (! (i___3 < 31)) {
#line 50
      goto while_break;
    }
    {
#line 51
    pw_write_zero(out, 22);
#line 53
    tmp___0 = read16b(in);
#line 53
    finetune = (uint8 )((int )tmp___0 / 72);
#line 55
    read8(in);
#line 56
    vol = read8(in);
#line 58
    tmp___1 = read16b(in);
#line 58
    size___0 = (int )tmp___1;
#line 58
    write16b(out, (uint16 )size___0);
#line 59
    ssize += size___0 * 2;
#line 61
    write8(out, finetune);
#line 62
    write8(out, vol);
#line 64
    tmp___2 = read16b(in);
#line 64
    size___0 = (int )tmp___2;
#line 66
    tmp___3 = read32b(in);
#line 66
    k = (int )tmp___3;
    }
#line 67
    if (k < sdata_addr) {
#line 68
      sdata_addr = k;
    }
    {
#line 71
    tmp___4 = read32b(in);
#line 71
    j = (int )((tmp___4 - (uint32 )k) / 2U);
#line 73
    write16b(out, (uint16 )j);
#line 74
    write16b(out, (uint16 )size___0);
#line 50
    i___3 ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 77
  write8(out, pat_pos);
#line 78
  write8(out, (uint8 )127);
#line 81
  fseek(in, (long )ptable_addr, 0);
#line 82
  i___3 = 0;
  }
  {
#line 82
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 82
    if (! (i___3 < (int )pat_pos)) {
#line 82
      goto while_break___0;
    }
    {
#line 83
    tmp___5 = read32b(in);
#line 83
    paddr[i___3] = (int )tmp___5;
#line 82
    i___3 ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 86
  c4 = (uint8 )0;
#line 87
  i___3 = 0;
  {
#line 87
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 87
    if (! (i___3 < (int )pat_pos)) {
#line 87
      goto while_break___1;
    }
#line 88
    if (i___3 == 0) {
#line 89
      ptable[0] = (uint8 )0;
#line 90
      paddr_Real[0] = paddr[0];
#line 91
      c4 = (uint8 )((int )c4 + 1);
#line 92
      goto __Cont;
    }
#line 94
    j = 0;
    {
#line 94
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 94
      if (! (j < i___3)) {
#line 94
        goto while_break___2;
      }
#line 95
      if (paddr[i___3] == paddr[j]) {
#line 96
        ptable[i___3] = ptable[j];
#line 97
        goto while_break___2;
      }
#line 94
      j ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 100
    if (j == i___3) {
#line 101
      paddr_Real[c4] = paddr[i___3];
#line 102
      ptable[i___3] = c4;
#line 103
      c4 = (uint8 )((int )c4 + 1);
    }
    __Cont: /* CIL Label */ 
#line 87
    i___3 ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 107
  fwrite((void const   */* __restrict  */)(ptable), (size_t )128, (size_t )1, (FILE */* __restrict  */)out);
#line 108
  write32b(out, (((77U << 24) | (46U << 16)) | (75U << 8)) | 46U);
#line 112
  i___3 = 0;
  }
  {
#line 112
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 112
    if (! (i___3 <= (int )pat_max)) {
#line 112
      goto while_break___3;
    }
    {
#line 113
    memset((void *)(pat___0), 0, (size_t )1024);
#line 114
    fseek(in, (long )paddr_Real[i___3], 0);
#line 115
    j = 0;
    }
    {
#line 115
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 115
      if (! (j < 256)) {
#line 115
        goto while_break___4;
      }
      {
#line 116
      c1 = read8(in);
#line 117
      c2 = read8(in);
#line 118
      c3 = read8(in);
#line 119
      c4 = read8(in);
#line 121
      note = (uint8 )(((int )c2 & 127) / 2);
#line 122
      fxp = c4;
#line 123
      ins = (uint8 )((((int )c2 << 4) & 16) | (((int )c3 >> 4) & 15));
#line 124
      fxt = (uint8 )((int )c3 & 15);
#line 126
      k = (int )c1;
#line 127
      pat___0[k * 4] = (uint8 )((int )ins & 240);
#line 128
      pat___0[k * 4] = (uint8 )((int )pat___0[k * 4] | (int )ptk_table[note][0]);
#line 129
      pat___0[k * 4 + 1] = (uint8 )ptk_table[note][1];
#line 130
      pat___0[k * 4 + 2] = (uint8 )((int )fxt | (((int )ins << 4) & 240));
#line 131
      pat___0[k * 4 + 3] = fxp;
#line 132
      j = (int )c1;
#line 115
      j ++;
      }
    }
    while_break___4: /* CIL Label */ ;
    }
    {
#line 134
    fwrite((void const   */* __restrict  */)(pat___0), (size_t )1024, (size_t )1,
           (FILE */* __restrict  */)out);
#line 112
    i___3 ++;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 140
  fseek(in, (long )sdata_addr, 0);
#line 141
  pw_move_data(out, in, ssize);
  }
#line 143
  return (0);
}
}
#line 147 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/prowizard/zen.c"
static int test_zen(uint8 *data , int s ) 
{ 
  int j ;
  int k ;
  int l ;
  int m___0 ;
  int n___0 ;
  int o___0 ;
  int start ;
  int ssize ;

  {
#line 150
  start = 0;
  {
#line 152
  while (1) {
    while_continue: /* CIL Label */ ;
#line 152
    if (s < 505) {
#line 152
      return (505 - s);
    }
#line 152
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 155
  l = ((((int )*(data + start) << 24) + ((int )*(data + (start + 1)) << 16)) + ((int )*(data + (start + 2)) << 8)) + (int )*(data + (start + 3));
#line 157
  if (l < 502) {
#line 158
    return (-1);
  } else
#line 157
  if ((long )l > 2163190L) {
#line 158
    return (-1);
  }
#line 161
  k = 0;
  {
#line 161
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 161
    if (! (k < 31)) {
#line 161
      goto while_break___0;
    }
#line 163
    if ((int )*(data + ((start + 9) + 16 * k)) > 64) {
#line 164
      return (-1);
    }
#line 167
    j = ((int )*(data + ((start + 6) + k * 16)) << 8) + (int )*(data + ((start + 7) + k * 16));
#line 169
    if ((j / 72) * 72 != j) {
#line 170
      return (-1);
    }
#line 161
    k ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 174
  n___0 = 0;
#line 175
  k = 0;
  {
#line 175
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 175
    if (! (k < 31)) {
#line 175
      goto while_break___1;
    }
#line 176
    o___0 = ((int )*(data + ((start + 10) + k * 16)) << 8) + (int )*(data + ((start + 11) + k * 16));
#line 178
    m___0 = ((int )*(data + ((start + 12) + k * 16)) << 8) + (int )*(data + ((start + 13) + k * 16));
#line 180
    j = ((((int )*(data + ((start + 14) + k * 16)) << 24) + ((int )*(data + ((start + 15) + k * 16)) << 16)) + ((int )*(data + ((start + 16) + k * 16)) << 8)) + (int )*(data + ((start + 17) + k * 16));
#line 184
    o___0 *= 2;
#line 185
    m___0 *= 2;
#line 188
    if (o___0 > 65535) {
#line 189
      return (-1);
    } else
#line 188
    if (m___0 > 65535) {
#line 189
      return (-1);
    }
#line 192
    if (j < l) {
#line 193
      return (-1);
    }
#line 204
    if (j > n___0) {
#line 205
      n___0 = j;
#line 206
      ssize = o___0;
    }
#line 175
    k ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 213
  j = (int )*(data + (start + 5));
#line 214
  if (j > 127) {
#line 215
    return (-1);
  } else
#line 214
  if (j == 0) {
#line 215
    return (-1);
  }
  {
#line 217
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 217
    if (s < ((start + l) + j * 4) + 4) {
#line 217
      return ((((start + l) + j * 4) + 4) - s);
    }
#line 217
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 220
  if ((int )*(data + ((start + l) + j * 4)) != 255) {
#line 224
    return (-1);
  } else
#line 220
  if ((int )*(data + (((start + l) + j * 4) + 1)) != 255) {
#line 224
    return (-1);
  } else
#line 220
  if ((int )*(data + (((start + l) + j * 4) + 2)) != 255) {
#line 224
    return (-1);
  } else
#line 220
  if ((int )*(data + (((start + l) + j * 4) + 3)) != 255) {
#line 224
    return (-1);
  }
#line 229
  return (0);
}
}
#line 91 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/prowizard/prowiz.h"
struct pw_format pw_wn ;
#line 13 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/prowizard/wn.c"
static int test_wn(uint8 *data , int s ) ;
#line 14
static int depack_wn(FILE *in , FILE *out ) ;
#line 16 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/prowizard/wn.c"
struct pw_format pw_wn  =    {(char *)"WN", (char *)"Wanton Packer", 0, & test_wn, & depack_wn, 0, {(struct list_head *)0,
                                                                          (struct list_head *)0}};
#line 25 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/prowizard/wn.c"
static int depack_wn(FILE *in , FILE *out ) 
{ 
  uint8 c1 ;
  uint8 c2 ;
  uint8 c3 ;
  uint8 c4 ;
  uint8 npat ;
  uint8 max ;
  uint8 tmp[1024] ;
  int ssize ;
  int i___3 ;
  int j ;
  uint16 tmp___0 ;
  void *__cil_tmp14 ;

  {
  {
#line 30
  ssize = 0;
#line 34
  pw_move_data(out, in, 950);
#line 37
  i___3 = 0;
  }
  {
#line 37
  while (1) {
    while_continue: /* CIL Label */ ;
#line 37
    if (! (i___3 < 31)) {
#line 37
      goto while_break;
    }
    {
#line 38
    fseek(in, (long )(42 + i___3 * 30), 0);
#line 39
    tmp___0 = read16b(in);
#line 39
    ssize += (int )tmp___0 * 2;
#line 37
    i___3 ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 43
  fseek(in, 950L, 0);
#line 44
  npat = read8(in);
#line 44
  write8(out, npat);
#line 46
  fread((void */* __restrict  */)(tmp), (size_t )129, (size_t )1, (FILE */* __restrict  */)in);
#line 47
  fwrite((void const   */* __restrict  */)(tmp), (size_t )129, (size_t )1, (FILE */* __restrict  */)out);
#line 50
  write32b(out, (((77U << 24) | (46U << 16)) | (75U << 8)) | 46U);
#line 53
  i___3 = 0;
#line 53
  max = (uint8 )i___3;
  }
  {
#line 53
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 53
    if (! (i___3 < 128)) {
#line 53
      goto while_break___0;
    }
#line 54
    if ((int )tmp[i___3 + 1] > (int )max) {
#line 55
      max = tmp[i___3 + 1];
    }
#line 53
    i___3 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 57
  max = (uint8 )((int )max + 1);
#line 60
  fseek(in, 1084L, 0);
#line 61
  i___3 = 0;
  }
  {
#line 61
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 61
    if (! (i___3 < (int )max)) {
#line 61
      goto while_break___1;
    }
#line 62
    j = 0;
    {
#line 62
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 62
      if (! (j < 256)) {
#line 62
        goto while_break___2;
      }
      {
#line 63
      c1 = read8(in);
#line 64
      c2 = read8(in);
#line 65
      c3 = read8(in);
#line 66
      c4 = read8(in);
#line 68
      write8(out, (uint8 )((int )c1 * 240 | (int )ptk_table[(int )c1 / 2][0]));
#line 69
      write8(out, (uint8 )ptk_table[(int )c1 / 2][1]);
#line 70
      write8(out, (uint8 )((((int )c2 << 4) & 240) | (int )c3));
#line 71
      write8(out, c4);
#line 62
      j ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
#line 61
    i___3 ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 76
  pw_move_data(out, in, ssize);
  }
#line 78
  return (0);
}
}
#line 81 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/prowizard/wn.c"
static int test_wn(uint8 *data , int s ) 
{ 
  int start ;

  {
#line 83
  start = 0;
  {
#line 85
  while (1) {
    while_continue: /* CIL Label */ ;
#line 85
    if (s < 1082) {
#line 85
      return (1082 - s);
    }
#line 85
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 88
  if ((int )*(data + 1080) != 87) {
#line 89
    return (-1);
  } else
#line 88
  if ((int )*(data + 1081) != 78) {
#line 89
    return (-1);
  }
#line 92
  if ((int )*(data + (start + 951)) != 127) {
#line 93
    return (-1);
  }
#line 96
  if ((int )*(data + (start + 950)) > 127) {
#line 97
    return (-1);
  }
#line 99
  return (0);
}
}
#line 90 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/prowizard/prowiz.h"
struct pw_format pw_unic2 ;
#line 12 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/prowizard/unic2.c"
static int test_unic2(uint8 *data , int s ) ;
#line 13
static int depack_unic2(FILE *in , FILE *out ) ;
#line 15 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/prowizard/unic2.c"
struct pw_format pw_unic2  =    {(char *)"UNIC2", (char *)"Unic Tracker 2", 0, & test_unic2, & depack_unic2, 0,
    {(struct list_head *)0, (struct list_head *)0}};
#line 27 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/prowizard/unic2.c"
static int depack_unic2(FILE *in , FILE *out ) 
{ 
  uint8 c1 ;
  uint8 c2 ;
  uint8 c3 ;
  uint8 c4 ;
  uint8 npat ;
  uint8 maxpat ;
  uint8 ins ;
  uint8 note ;
  uint8 fxt ;
  uint8 fxp ;
  uint8 fine ;
  uint8 tmp[1025] ;
  uint8 loop_status ;
  int i___3 ;
  int j ;
  int k ;
  int l ;
  int ssize ;
  uint16 tmp___0 ;
  uint8 tmp___1 ;
  uint16 tmp___2 ;
  uint16 tmp___3 ;
  void *__cil_tmp25 ;

  {
  {
#line 32
  fine = (uint8 )0;
#line 34
  loop_status = (uint8 )2;
#line 36
  ssize = 0;
#line 38
  pw_write_zero(out, 20);
#line 40
  i___3 = 0;
  }
  {
#line 40
  while (1) {
    while_continue: /* CIL Label */ ;
#line 40
    if (! (i___3 < 31)) {
#line 40
      goto while_break;
    }
    {
#line 41
    pw_move_data(out, in, 20);
#line 42
    write8(out, (uint8 )0);
#line 43
    write8(out, (uint8 )0);
#line 46
    c1 = read8(in);
#line 47
    c2 = read8(in);
#line 48
    j = ((int )c1 << 8) + (int )c2;
    }
#line 49
    if (j != 0) {
#line 50
      if (j < 256) {
#line 51
        fine = (uint8 )(16 - (int )c2);
      } else {
#line 53
        fine = (uint8 )(256 - (int )c2);
      }
    } else {
#line 55
      fine = (uint8 )0;
    }
    {
#line 59
    tmp___0 = read16b(in);
#line 59
    l = (int )tmp___0;
#line 59
    write16b(out, (uint16 )l);
#line 60
    ssize += l * 2;
#line 62
    read8(in);
#line 63
    write8(out, fine);
#line 64
    tmp___1 = read8(in);
#line 64
    write8(out, tmp___1);
#line 66
    tmp___2 = read16b(in);
#line 66
    j = (int )tmp___2;
#line 67
    tmp___3 = read16b(in);
#line 67
    k = (int )tmp___3;
    }
#line 69
    if (j * 2 + k <= l) {
#line 69
      if (j != 0) {
#line 70
        loop_status = (uint8 )1;
#line 71
        j *= 2;
      }
    }
    {
#line 74
    write16b(out, (uint16 )j);
#line 75
    write16b(out, (uint16 )k);
#line 40
    i___3 ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 78
  npat = read8(in);
#line 78
  write8(out, npat);
#line 79
  write8(out, (uint8 )127);
#line 80
  read8(in);
#line 82
  fread((void */* __restrict  */)(tmp), (size_t )128, (size_t )1, (FILE */* __restrict  */)in);
#line 83
  fwrite((void const   */* __restrict  */)(tmp), (size_t )128, (size_t )1, (FILE */* __restrict  */)out);
#line 86
  i___3 = 0;
#line 86
  maxpat = (uint8 )i___3;
  }
  {
#line 86
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 86
    if (! (i___3 < 128)) {
#line 86
      goto while_break___0;
    }
#line 87
    if ((int )tmp[i___3] > (int )maxpat) {
#line 88
      maxpat = tmp[i___3];
    }
#line 86
    i___3 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 90
  maxpat = (uint8 )((int )maxpat + 1);
#line 92
  write32b(out, (((77U << 24) | (46U << 16)) | (75U << 8)) | 46U);
#line 95
  i___3 = 0;
  }
  {
#line 95
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 95
    if (! (i___3 < (int )maxpat)) {
#line 95
      goto while_break___1;
    }
#line 96
    j = 0;
    {
#line 96
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 96
      if (! (j < 256)) {
#line 96
        goto while_break___2;
      }
      {
#line 97
      c1 = read8(in);
#line 98
      c2 = read8(in);
#line 99
      c3 = read8(in);
#line 101
      ins = (uint8 )((((int )c1 >> 2) & 16) | (((int )c2 >> 4) & 15));
#line 102
      note = (uint8 )((int )c1 & 63);
#line 103
      fxt = (uint8 )((int )c2 & 15);
#line 104
      fxp = c3;
      }
#line 106
      if ((int )fxt == 13) {
#line 107
        c4 = (uint8 )((int )fxp % 10);
#line 108
        c3 = (uint8 )((int )fxp / 10);
#line 109
        fxp = (uint8 )(16 * (int )c3 + (int )c4);
      }
#line 112
      tmp[j * 4] = (uint8 )((int )ins & 240);
#line 113
      tmp[j * 4] = (uint8 )((int )tmp[j * 4] | (int )ptk_table[note][0]);
#line 114
      tmp[j * 4 + 1] = (uint8 )ptk_table[note][1];
#line 115
      tmp[j * 4 + 2] = (uint8 )((((int )ins << 4) & 240) | (int )fxt);
#line 116
      tmp[j * 4 + 3] = fxp;
#line 96
      j ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 118
    fwrite((void const   */* __restrict  */)(tmp), (size_t )1024, (size_t )1, (FILE */* __restrict  */)out);
#line 95
    i___3 ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 122
  pw_move_data(out, in, ssize);
  }
#line 124
  return (0);
}
}
#line 128 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/prowizard/unic2.c"
static int test_unic2(uint8 *data , int s ) 
{ 
  int j ;
  int k ;
  int l ;
  int m___0 ;
  int n___0 ;
  int o___0 ;
  int start ;
  int ssize ;
  int x ;
  uint16 tmp ;
  uint16 tmp___0 ;
  uint16 tmp___1 ;
  uint16 tmp___2 ;
  int y ;

  {
#line 131
  start = 0;
  {
#line 134
  while (1) {
    while_continue: /* CIL Label */ ;
#line 134
    if (s < 1084) {
#line 134
      return (1084 - s);
    }
#line 134
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 137
  if ((int )*(data + (start + 1080)) == 0) {
#line 137
    if ((int )*(data + (start + 1081)) == 0) {
#line 137
      if ((int )*(data + (start + 1082)) == 0) {
#line 137
        if ((int )*(data + (start + 1083)) == 0) {
#line 139
          return (-1);
        }
      }
    }
  }
#line 142
  o___0 = 0;
#line 143
  ssize = 0;
#line 144
  k = 0;
  {
#line 144
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 144
    if (! (k < 31)) {
#line 144
      goto while_break___0;
    }
    {
#line 145
    x = start + k * 30;
#line 147
    tmp = readmem16b((data + x) + 22);
#line 147
    j = (int )tmp * 2;
#line 148
    tmp___0 = readmem16b((data + x) + 26);
#line 148
    m___0 = (int )tmp___0 * 2;
#line 149
    tmp___1 = readmem16b((data + x) + 28);
#line 149
    n___0 = (int )tmp___1 * 2;
#line 150
    ssize += j;
    }
#line 152
    if (j + 2 < m___0 + n___0) {
#line 153
      return (-1);
    }
#line 155
    if (j > 65535) {
#line 156
      return (-1);
    } else
#line 155
    if (m___0 > 65535) {
#line 156
      return (-1);
    } else
#line 155
    if (n___0 > 65535) {
#line 156
      return (-1);
    }
#line 158
    if ((int )*(data + (x + 25)) > 64) {
#line 159
      return (-1);
    }
    {
#line 161
    tmp___2 = readmem16b((data + x) + 20);
    }
#line 161
    if (tmp___2) {
#line 161
      if (j == 0) {
#line 162
        return (-1);
      }
    }
#line 164
    if ((int )*(data + (x + 25)) != 0) {
#line 164
      if (j == 0) {
#line 165
        return (-1);
      }
    }
#line 168
    if (j != 0) {
#line 169
      o___0 = j + 1;
    }
#line 144
    k ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 172
  if (ssize <= 2) {
#line 173
    return (-1);
  }
#line 176
  l = (int )*(data + (start + 930));
#line 177
  if (l > 127) {
#line 178
    return (-1);
  } else
#line 177
  if (l == 0) {
#line 178
    return (-1);
  }
#line 181
  k = 0;
#line 182
  j = 0;
  {
#line 182
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 182
    if (! (j < l)) {
#line 182
      goto while_break___1;
    }
#line 183
    if ((int )*(data + ((start + 932) + j)) > k) {
#line 184
      k = (int )*(data + ((start + 932) + j));
    }
#line 185
    if ((int )*(data + ((start + 932) + j)) > 127) {
#line 186
      return (-1);
    }
#line 182
    j ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 191
  j += 2;
  {
#line 192
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 192
    if (! (j != 128)) {
#line 192
      goto while_break___2;
    }
#line 193
    if ((int )*(data + ((start + 932) + j)) != 0) {
#line 194
      return (-1);
    }
#line 195
    j ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 198
  k ++;
  {
#line 209
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 209
    if (s < (1060 + (k * 256) * 3) + 2) {
#line 209
      return (((1060 + (k * 256) * 3) + 2) - s);
    }
#line 209
    goto while_break___3;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 211
  j = 0;
  {
#line 211
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 211
    if (! (j < k << 8)) {
#line 211
      goto while_break___4;
    }
#line 212
    y = (start + 1060) + j * 3;
#line 215
    if ((int )*(data + y) > 116) {
#line 216
      return (-1);
    }
#line 217
    if (((int )*(data + y) & 63) > 36) {
#line 218
      return (-1);
    }
#line 219
    if (((int )*(data + (y + 1)) & 15) == 12) {
#line 219
      if ((int )*(data + (y + 2)) > 64) {
#line 220
        return (-1);
      }
    }
#line 221
    if (((int )*(data + (y + 1)) & 15) == 11) {
#line 221
      if ((int )*(data + (y + 2)) > 127) {
#line 222
        return (-1);
      }
    }
#line 223
    if (((int )*(data + (y + 1)) & 15) == 13) {
#line 223
      if ((int )*(data + (y + 2)) > 64) {
#line 224
        return (-1);
      }
    }
#line 226
    n___0 = (((int )*(data + y) >> 2) & 48) | (((int )*(data + (y + 2)) >> 4) & 15);
#line 228
    if (n___0 > o___0) {
#line 229
      return (-1);
    }
#line 211
    j ++;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 232
  return (0);
}
}
#line 87 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/prowizard/prowiz.h"
struct pw_format pw_unic_emptyid ;
#line 88
struct pw_format pw_unic_id ;
#line 89
struct pw_format pw_unic_noid ;
#line 18 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/prowizard/unic.c"
static int test_unic_id(uint8 *data , int s ) ;
#line 19
static int test_unic_noid(uint8 *data , int s ) ;
#line 20
static int test_unic_emptyid(uint8 *data , int s ) ;
#line 21
static int depack_unic(FILE *in , FILE *out ) ;
#line 23 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/prowizard/unic.c"
struct pw_format pw_unic_id  =    {(char *)"UNIC", (char *)"UNIC Tracker", 0, & test_unic_id, & depack_unic, 0, {(struct list_head *)0,
                                                                                  (struct list_head *)0}};
#line 31 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/prowizard/unic.c"
struct pw_format pw_unic_noid  =    {(char *)"UNIC", (char *)"UNIC Tracker noid", 0, & test_unic_noid, & depack_unic,
    0, {(struct list_head *)0, (struct list_head *)0}};
#line 39 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/prowizard/unic.c"
struct pw_format pw_unic_emptyid  =    {(char *)"UNIC", (char *)"UNIC Tracker id0", 0, & test_unic_emptyid, & depack_unic,
    0, {(struct list_head *)0, (struct list_head *)0}};
#line 51 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/prowizard/unic.c"
static int depack_unic(FILE *in , FILE *out ) 
{ 
  uint8 c1 ;
  uint8 c2 ;
  uint8 c3 ;
  uint8 c4 ;
  uint8 npat ;
  uint8 max ;
  uint8 ins ;
  uint8 note ;
  uint8 fxt ;
  uint8 fxp ;
  uint8 fine ;
  uint8 tmp[1025] ;
  uint8 loop_status ;
  int i___3 ;
  int j ;
  int k ;
  int l ;
  int ssize ;
  uint32 id ;
  uint16 tmp___0 ;
  uint8 tmp___1 ;
  uint16 tmp___2 ;
  uint16 tmp___3 ;
  void *__cil_tmp26 ;

  {
  {
#line 55
  max = (uint8 )0;
#line 59
  loop_status = (uint8 )2;
#line 60
  i___3 = 0;
#line 60
  j = 0;
#line 60
  k = 0;
#line 60
  l = 0;
#line 61
  ssize = 0;
#line 64
  pw_move_data(out, in, 20);
#line 66
  i___3 = 0;
  }
  {
#line 66
  while (1) {
    while_continue: /* CIL Label */ ;
#line 66
    if (! (i___3 < 31)) {
#line 66
      goto while_break;
    }
    {
#line 67
    pw_move_data(out, in, 20);
#line 68
    write8(out, (uint8 )0);
#line 69
    write8(out, (uint8 )0);
#line 72
    c1 = read8(in);
#line 73
    c2 = read8(in);
#line 74
    j = ((int )c1 << 8) + (int )c2;
    }
#line 75
    if (j != 0) {
#line 76
      if (j < 256) {
#line 77
        fine = (uint8 )(16 - (int )c2);
      } else {
#line 79
        fine = (uint8 )(256 - (int )c2);
      }
    } else {
#line 81
      fine = (uint8 )0;
    }
    {
#line 85
    tmp___0 = read16b(in);
#line 85
    l = (int )tmp___0;
#line 85
    write16b(out, (uint16 )l);
#line 86
    ssize += l * 2;
#line 88
    read8(in);
#line 89
    write8(out, fine);
#line 90
    tmp___1 = read8(in);
#line 90
    write8(out, tmp___1);
#line 91
    tmp___2 = read16b(in);
#line 91
    j = (int )tmp___2;
#line 92
    tmp___3 = read16b(in);
#line 92
    k = (int )tmp___3;
    }
#line 94
    if (j * 2 + k <= l) {
#line 94
      if (j != 0) {
#line 95
        loop_status = (uint8 )1;
#line 96
        j *= 2;
      }
    }
    {
#line 99
    write16b(out, (uint16 )j);
#line 100
    write16b(out, (uint16 )k);
#line 66
    i___3 ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 103
  npat = read8(in);
#line 103
  write8(out, npat);
#line 104
  write8(out, (uint8 )127);
#line 105
  read8(in);
#line 107
  fread((void */* __restrict  */)(tmp), (size_t )128, (size_t )1, (FILE */* __restrict  */)in);
#line 108
  fwrite((void const   */* __restrict  */)(tmp), (size_t )128, (size_t )1, (FILE */* __restrict  */)out);
#line 111
  i___3 = 0;
  }
  {
#line 111
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 111
    if (! (i___3 < 128)) {
#line 111
      goto while_break___0;
    }
#line 112
    if ((int )tmp[i___3] > (int )max) {
#line 113
      max = tmp[i___3];
    }
#line 111
    i___3 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 115
  max = (uint8 )((int )max + 1);
#line 117
  write32b(out, (((77U << 24) | (46U << 16)) | (75U << 8)) | 46U);
#line 120
  fseek(in, 1080L, 0);
#line 121
  id = read32b(in);
  }
#line 123
  if (id) {
#line 123
    if (id != ((((77U << 24) | (46U << 16)) | (75U << 8)) | 46U)) {
#line 123
      if (id != ((((85U << 24) | (78U << 16)) | (73U << 8)) | 67U)) {
        {
#line 124
        fseek(in, -4L, 1);
        }
      }
    }
  }
#line 127
  i___3 = 0;
  {
#line 127
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 127
    if (! (i___3 < (int )max)) {
#line 127
      goto while_break___1;
    }
#line 128
    j = 0;
    {
#line 128
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 128
      if (! (j < 256)) {
#line 128
        goto while_break___2;
      }
      {
#line 129
      c1 = read8(in);
#line 130
      c2 = read8(in);
#line 131
      c3 = read8(in);
#line 133
      ins = (uint8 )((((int )c1 >> 2) & 16) | (((int )c2 >> 4) & 15));
#line 134
      note = (uint8 )((int )c1 & 63);
#line 135
      fxt = (uint8 )((int )c2 & 15);
#line 136
      fxp = c3;
      }
#line 138
      if ((int )fxt == 13) {
#line 139
        c3 = (uint8 )((int )fxp / 10);
#line 140
        c4 = (uint8 )((int )fxp % 10);
#line 141
        fxp = (uint8 )(16 * (int )c3 + (int )c4);
      }
#line 144
      tmp[j * 4] = (uint8 )((int )ins & 240);
#line 145
      tmp[j * 4] = (uint8 )((int )tmp[j * 4] | (int )ptk_table[note][0]);
#line 146
      tmp[j * 4 + 1] = (uint8 )ptk_table[note][1];
#line 147
      tmp[j * 4 + 2] = (uint8 )((((int )ins << 4) & 240) | (int )fxt);
#line 148
      tmp[j * 4 + 3] = fxp;
#line 128
      j ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 150
    fwrite((void const   */* __restrict  */)(tmp), (size_t )1024, (size_t )1, (FILE */* __restrict  */)out);
#line 127
    i___3 ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 154
  pw_move_data(out, in, ssize);
  }
#line 156
  return (0);
}
}
#line 160 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/prowizard/unic.c"
static int test_unic_id(uint8 *data , int s ) 
{ 
  int j ;
  int k ;
  int l ;
  int n___0 ;
  int start ;
  int ssize ;
  uint32 tmp ;
  int x ;
  uint16 tmp___0 ;
  uint16 tmp___1 ;
  uint16 tmp___2 ;
  int x___0 ;

  {
#line 163
  start = 0;
  {
#line 166
  while (1) {
    while_continue: /* CIL Label */ ;
#line 166
    if (s < 1084) {
#line 166
      return (1084 - s);
    }
#line 166
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 168
  tmp = readmem32b((data + start) + 1080);
  }
#line 168
  if (tmp != ((((77U << 24) | (46U << 16)) | (75U << 8)) | 46U)) {
#line 169
    return (-1);
  }
#line 172
  ssize = 0;
#line 173
  k = 0;
  {
#line 173
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 173
    if (! (k < 31)) {
#line 173
      goto while_break___0;
    }
    {
#line 174
    x = start + k * 30;
#line 176
    tmp___0 = readmem16b((data + x) + 42);
#line 176
    j = (int )tmp___0 * 2;
#line 177
    ssize += j;
#line 178
    tmp___1 = readmem16b((data + x) + 46);
#line 178
    tmp___2 = readmem16b((data + x) + 48);
#line 178
    n___0 = ((int )tmp___1 + (int )tmp___2) * 2;
    }
#line 180
    if (j + 2 < n___0) {
#line 181
      return (-1);
    }
#line 173
    k ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 184
  if (ssize <= 2) {
#line 185
    return (-1);
  }
#line 188
  k = 0;
  {
#line 188
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 188
    if (! (k < 31)) {
#line 188
      goto while_break___1;
    }
#line 189
    x___0 = start + k * 30;
#line 191
    if ((int )*(data + (x___0 + 40)) > 15) {
#line 192
      return (-1);
    } else
#line 191
    if (*(data + (x___0 + 44))) {
#line 192
      return (-1);
    } else
#line 191
    if ((int )*(data + (x___0 + 45)) > 64) {
#line 192
      return (-1);
    }
#line 188
    k ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 196
  l = (int )*(data + (start + 950));
#line 197
  if (l > 127) {
#line 198
    return (-1);
  } else
#line 197
  if (l == 0) {
#line 198
    return (-1);
  }
#line 201
  k = 0;
#line 202
  j = 0;
  {
#line 202
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 202
    if (! (j < l)) {
#line 202
      goto while_break___2;
    }
#line 203
    if ((int )*(data + ((start + 952) + j)) > k) {
#line 204
      k = (int )*(data + ((start + 952) + j));
    }
#line 205
    if ((int )*(data + ((start + 952) + j)) > 127) {
#line 206
      return (-1);
    }
#line 202
    j ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 211
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 211
    if (! (j != 128)) {
#line 211
      goto while_break___3;
    }
#line 212
    if ((int )*(data + ((start + 952) + j)) != 0) {
#line 213
      return (-1);
    }
#line 214
    j ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 217
  k ++;
  {
#line 219
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 219
    if (s < 1084 + (k * 256) * 3) {
#line 219
      return ((1084 + (k * 256) * 3) - s);
    }
#line 219
    goto while_break___4;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 227
  j = 0;
  {
#line 227
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 227
    if (! (j < k << 8)) {
#line 227
      goto while_break___5;
    }
#line 229
    if ((int )*(data + ((start + 1084) + j * 3)) > 116) {
#line 230
      return (-1);
    }
#line 227
    j ++;
  }
  while_break___5: /* CIL Label */ ;
  }
#line 233
  return (0);
}
}
#line 237 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/prowizard/unic.c"
static int test_unic_emptyid(uint8 *data , int s ) 
{ 
  int j ;
  int k ;
  int l ;
  int m___0 ;
  int n___0 ;
  int o___0 ;
  int start ;
  int ssize ;
  uint32 tmp ;
  int x ;
  int y ;

  {
#line 240
  start = 0;
  {
#line 243
  while (1) {
    while_continue: /* CIL Label */ ;
#line 243
    if (s < 1084) {
#line 243
      return (1084 - s);
    }
#line 243
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 246
  tmp = readmem32b((data + start) + 1080);
  }
#line 246
  if (tmp != 0U) {
#line 247
    return (-1);
  }
#line 250
  ssize = 0;
#line 251
  o___0 = 0;
#line 252
  k = 0;
  {
#line 252
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 252
    if (! (k < 31)) {
#line 252
      goto while_break___0;
    }
#line 253
    x = start + k * 30;
#line 255
    j = (((int )*(data + (x + 42)) << 8) + (int )*(data + (x + 43))) * 2;
#line 256
    m___0 = (((int )*(data + (x + 46)) << 8) + (int )*(data + (x + 47))) * 2;
#line 257
    n___0 = (((int )*(data + (x + 48)) << 8) + (int )*(data + (x + 49))) * 2;
#line 258
    ssize += j;
#line 260
    if (n___0 != 0) {
#line 260
      if (j + 2 < m___0 + n___0) {
#line 261
        return (-1);
      }
    }
#line 263
    if (j > 65535) {
#line 264
      return (-1);
    } else
#line 263
    if (m___0 > 65535) {
#line 264
      return (-1);
    } else
#line 263
    if (n___0 > 65535) {
#line 264
      return (-1);
    }
#line 266
    if ((int )*(data + (x + 45)) > 64) {
#line 267
      return (-1);
    }
#line 270
    if (((int )*(data + (x + 40)) << 8) + (int )*(data + (x + 41)) != 0) {
#line 270
      if (j == 0) {
#line 273
        return (-1);
      } else {
#line 270
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 270
    if ((int )*(data + (x + 40)) * 256 + (int )*(data + (x + 41)) > 8) {
#line 270
      if ((int )*(data + (x + 40)) * 256 + (int )*(data + (x + 41)) < 247) {
#line 273
        return (-1);
      }
    }
#line 276
    if (m___0 != 0) {
#line 276
      if (n___0 <= 2) {
#line 277
        return (-1);
      }
    }
#line 279
    if ((int )*(data + (x + 45)) != 0) {
#line 279
      if (j == 0) {
#line 280
        return (-1);
      }
    }
#line 283
    if (j != 0) {
#line 284
      o___0 = j + 1;
    }
#line 252
    k ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 287
  if (ssize <= 2) {
#line 288
    return (-1);
  }
#line 291
  l = (int )*(data + (start + 950));
#line 292
  if (l > 127) {
#line 293
    return (-1);
  } else
#line 292
  if (l == 0) {
#line 293
    return (-1);
  }
#line 296
  k = 0;
#line 297
  j = 0;
  {
#line 297
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 297
    if (! (j < l)) {
#line 297
      goto while_break___1;
    }
#line 298
    if ((int )*(data + ((start + 952) + j)) > k) {
#line 299
      k = (int )*(data + ((start + 952) + j));
    }
#line 300
    if ((int )*(data + ((start + 952) + j)) > 127) {
#line 301
      return (-1);
    }
#line 297
    j ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 306
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 306
    if (! (j != 128)) {
#line 306
      goto while_break___2;
    }
#line 307
    if ((int )*(data + ((start + 952) + j)) != 0) {
#line 308
      return (-1);
    }
#line 309
    j ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 312
  k ++;
  {
#line 320
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 320
    if (s < (1084 + (k * 256) * 3) + 2) {
#line 320
      return (((1084 + (k * 256) * 3) + 2) - s);
    }
#line 320
    goto while_break___3;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 322
  j = 0;
  {
#line 322
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 322
    if (! (j < k << 8)) {
#line 322
      goto while_break___4;
    }
#line 323
    y = (start + 1084) + j * 3;
#line 326
    if ((int )*(data + y) > 116) {
#line 327
      return (-1);
    }
#line 329
    if (((int )*(data + y) & 63) > 36) {
#line 330
      return (-1);
    }
#line 332
    if (((int )*(data + (y + 1)) & 15) == 12) {
#line 332
      if ((int )*(data + (y + 2)) > 64) {
#line 334
        return (-1);
      }
    }
#line 336
    if (((int )*(data + (y + 1)) & 15) == 11) {
#line 336
      if ((int )*(data + (y + 2)) > 127) {
#line 338
        return (-1);
      }
    }
#line 340
    if (((int )*(data + (y + 1)) & 15) == 13) {
#line 340
      if ((int )*(data + (y + 2)) > 64) {
#line 342
        return (-1);
      }
    }
#line 344
    n___0 = (((int )*(data + y) >> 2) & 48) | (((int )*(data + (((start + 1085) + j * 3) + 1)) >> 4) & 15);
#line 347
    if (n___0 > o___0) {
#line 348
      return (-1);
    }
#line 322
    j ++;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 351
  return (0);
}
}
#line 355 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/prowizard/unic.c"
static int test_unic_noid(uint8 *data , int s ) 
{ 
  int j ;
  int k ;
  int l ;
  int m___0 ;
  int n___0 ;
  int o___0 ;
  int start ;
  int ssize ;
  uint32 tmp ;
  int x ;
  int y ;

  {
#line 358
  start = 0;
  {
#line 361
  while (1) {
    while_continue: /* CIL Label */ ;
#line 361
    if (s < 1084) {
#line 361
      return (1084 - s);
    }
#line 361
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 364
  tmp = readmem32b((data + start) + 1080);
  }
#line 364
  if (tmp == 0U) {
#line 365
    return (-1);
  }
#line 368
  ssize = 0;
#line 369
  o___0 = 0;
#line 370
  k = 0;
  {
#line 370
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 370
    if (! (k < 31)) {
#line 370
      goto while_break___0;
    }
#line 371
    x = start + k * 30;
#line 373
    j = (((int )*(data + (x + 42)) << 8) + (int )*(data + (x + 43))) * 2;
#line 374
    m___0 = (((int )*(data + (x + 46)) << 8) + (int )*(data + (x + 47))) * 2;
#line 375
    n___0 = (((int )*(data + (x + 48)) << 8) + (int )*(data + (x + 49))) * 2;
#line 377
    ssize += j;
#line 378
    if (n___0 != 0) {
#line 378
      if (j + 2 < m___0 + n___0) {
#line 379
        return (-1);
      }
    }
#line 382
    if (j > 65535) {
#line 383
      return (-1);
    } else
#line 382
    if (m___0 > 65535) {
#line 383
      return (-1);
    } else
#line 382
    if (n___0 > 65535) {
#line 383
      return (-1);
    }
#line 386
    if ((int )*(data + (x + 45)) > 64) {
#line 387
      return (-1);
    }
#line 390
    if ((int )*(data + (x + 40)) * 256 + (int )*(data + (x + 41)) != 0) {
#line 390
      if (j == 0) {
#line 393
        return (-1);
      } else {
#line 390
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 390
    if ((int )*(data + (x + 40)) * 256 + (int )*(data + (x + 41)) > 8) {
#line 390
      if ((int )*(data + (x + 40)) * 256 + (int )*(data + (x + 41)) < 247) {
#line 393
        return (-1);
      }
    }
#line 396
    if (m___0 != 0) {
#line 396
      if (n___0 <= 2) {
#line 397
        return (-1);
      }
    }
#line 399
    if ((int )*(data + (x + 45)) != 0) {
#line 399
      if (j == 0) {
#line 400
        return (-1);
      }
    }
#line 403
    if (j != 0) {
#line 404
      o___0 = j + 1;
    }
#line 370
    k ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 406
  if (ssize <= 2) {
#line 407
    return (-1);
  }
#line 410
  l = (int )*(data + (start + 950));
#line 411
  if (l > 127) {
#line 412
    return (-1);
  } else
#line 411
  if (l == 0) {
#line 412
    return (-1);
  }
#line 415
  k = 0;
#line 416
  j = 0;
  {
#line 416
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 416
    if (! (j < l)) {
#line 416
      goto while_break___1;
    }
#line 417
    if ((int )*(data + ((start + 952) + j)) > k) {
#line 418
      k = (int )*(data + ((start + 952) + j));
    }
#line 419
    if ((int )*(data + ((start + 952) + j)) > 127) {
#line 420
      return (-1);
    }
#line 416
    j ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 425
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 425
    if (! (j != 128)) {
#line 425
      goto while_break___2;
    }
#line 426
    if ((int )*(data + ((start + 952) + j)) != 0) {
#line 427
      return (-1);
    }
#line 428
    j ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 431
  k ++;
  {
#line 443
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 443
    if (s < (1080 + (k * 256) * 3) + 2) {
#line 443
      return (((1080 + (k * 256) * 3) + 2) - s);
    }
#line 443
    goto while_break___3;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 445
  j = 0;
  {
#line 445
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 445
    if (! (j < k << 8)) {
#line 445
      goto while_break___4;
    }
#line 446
    y = (start + 1080) + j * 3;
#line 449
    if ((int )*(data + y) > 116) {
#line 450
      return (-1);
    }
#line 451
    if (((int )*(data + y) & 63) > 36) {
#line 452
      return (-1);
    }
#line 453
    if (((int )*(data + (y + 1)) & 15) == 12) {
#line 453
      if ((int )*(data + (y + 2)) > 64) {
#line 454
        return (-1);
      }
    }
#line 456
    if (((int )*(data + (y + 1)) & 15) == 11) {
#line 456
      if ((int )*(data + (y + 2)) > 127) {
#line 457
        return (-1);
      }
    }
#line 459
    if (((int )*(data + (y + 1)) & 15) == 13) {
#line 459
      if ((int )*(data + (y + 2)) > 64) {
#line 460
        return (-1);
      }
    }
#line 462
    n___0 = (((int )*(data + y) >> 2) & 48) | (((int )*(data + (((start + 1081) + j * 3) + 1)) >> 4) & 15);
#line 465
    if (n___0 > o___0) {
#line 466
      return (-1);
    }
#line 445
    j ++;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 470
  j = 0;
  {
#line 470
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 470
    if (! (j < 20)) {
#line 470
      goto while_break___5;
    }
#line 471
    if ((int )*(data + (start + j)) != 0) {
#line 471
      if ((int )*(data + (start + j)) < 32) {
#line 473
        return (-1);
      } else {
#line 471
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 471
    if ((int )*(data + (start + j)) > 180) {
#line 473
      return (-1);
    }
#line 470
    j ++;
  }
  while_break___5: /* CIL Label */ ;
  }
#line 476
  return (0);
}
}
#line 85 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/prowizard/prowiz.h"
struct pw_format pw_tdd ;
#line 13 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/prowizard/tdd.c"
static int test_tdd(uint8 *data , int s ) ;
#line 14
static int depack_tdd(FILE *in , FILE *out ) ;
#line 16 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/prowizard/tdd.c"
struct pw_format pw_tdd  =    {(char *)"TDD", (char *)"The Dark Demon", 0, & test_tdd, & depack_tdd, 0, {(struct list_head *)0,
                                                                              (struct list_head *)0}};
#line 25 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/prowizard/tdd.c"
static int depack_tdd(FILE *in , FILE *out ) 
{ 
  uint8 *tmp ;
  uint8 pat___0[1024] ;
  uint8 pmax ;
  int i___3 ;
  int j ;
  int k ;
  int size___0 ;
  int ssize ;
  int saddr[31] ;
  int ssizes[31] ;
  void *tmp___0 ;
  uint32 tmp___1 ;
  uint16 tmp___2 ;
  uint8 tmp___3 ;
  uint8 tmp___4 ;
  uint32 tmp___5 ;
  uint16 tmp___6 ;
  void *tmp___7 ;
  int x ;
  void *__cil_tmp22 ;
  void *__cil_tmp23 ;
  void *__cil_tmp24 ;

  {
  {
#line 31
  ssize = 0;
#line 35
  memset((void *)(saddr), 0, (size_t )124);
#line 36
  memset((void *)(ssizes), 0, (size_t )124);
#line 39
  pw_write_zero(out, 1080);
#line 42
  tmp___0 = malloc((size_t )130);
#line 42
  tmp = (uint8 *)tmp___0;
#line 43
  memset((void *)tmp, 0, (size_t )130);
#line 44
  fseek(out, 950L, 0);
#line 45
  fread((void */* __restrict  */)tmp, (size_t )130, (size_t )1, (FILE */* __restrict  */)in);
#line 46
  fwrite((void const   */* __restrict  */)tmp, (size_t )130, (size_t )1, (FILE */* __restrict  */)out);
#line 48
  i___3 = 0;
#line 48
  pmax = (uint8 )i___3;
  }
  {
#line 48
  while (1) {
    while_continue: /* CIL Label */ ;
#line 48
    if (! (i___3 < 128)) {
#line 48
      goto while_break;
    }
#line 49
    if ((int )*(tmp + (i___3 + 2)) > (int )pmax) {
#line 50
      pmax = *(tmp + (i___3 + 2));
    }
#line 48
    i___3 ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 51
  free((void *)tmp);
#line 54
  i___3 = 0;
  }
  {
#line 54
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 54
    if (! (i___3 < 31)) {
#line 54
      goto while_break___0;
    }
    {
#line 55
    fseek(out, (long )(42 + i___3 * 30), 0);
#line 57
    tmp___1 = read32b(in);
#line 57
    saddr[i___3] = (int )tmp___1;
#line 60
    tmp___2 = read16b(in);
#line 60
    size___0 = (int )tmp___2;
#line 60
    write16b(out, (uint16 )size___0);
#line 61
    ssize += size___0;
#line 62
    ssizes[i___3] = size___0;
#line 64
    tmp___3 = read8(in);
#line 64
    write8(out, tmp___3);
#line 65
    tmp___4 = read8(in);
#line 65
    write8(out, tmp___4);
#line 67
    tmp___5 = read32b(in);
#line 67
    write16b(out, (uint16 )((tmp___5 - (uint32 )saddr[i___3]) / 2U));
#line 68
    tmp___6 = read16b(in);
#line 68
    write16b(out, tmp___6);
#line 54
    i___3 ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 72
  fseek(in, (long )ssize, 1);
#line 75
  fseek(out, 0L, 2);
#line 76
  write32b(out, (((77U << 24) | (46U << 16)) | (75U << 8)) | 46U);
#line 79
  tmp___7 = malloc((size_t )1024);
#line 79
  tmp = (uint8 *)tmp___7;
#line 80
  i___3 = 0;
  }
  {
#line 80
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 80
    if (! (i___3 <= (int )pmax)) {
#line 80
      goto while_break___1;
    }
    {
#line 81
    memset((void *)tmp, 0, (size_t )1024);
#line 82
    memset((void *)(pat___0), 0, (size_t )1024);
#line 83
    fread((void */* __restrict  */)tmp, (size_t )1024, (size_t )1, (FILE */* __restrict  */)in);
#line 84
    j = 0;
    }
    {
#line 84
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 84
      if (! (j < 64)) {
#line 84
        goto while_break___2;
      }
#line 85
      k = 0;
      {
#line 85
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 85
        if (! (k < 4)) {
#line 85
          goto while_break___3;
        }
#line 86
        x = j * 16 + k * 4;
#line 89
        pat___0[x + 3] = *(tmp + (x + 3));
#line 92
        pat___0[x + 2] = (uint8 )((int )*(tmp + (x + 2)) & 15);
#line 95
        pat___0[x] = (uint8 )((int )*(tmp + x) & 240);
#line 96
        pat___0[x + 2] = (uint8 )((int )pat___0[x + 2] | (((int )*(tmp + x) << 4) & 240));
#line 99
        pat___0[x] = (uint8 )((int )pat___0[x] | (int )ptk_table[(int )*(tmp + (x + 1)) / 2][0]);
#line 100
        pat___0[x + 1] = (uint8 )ptk_table[(int )*(tmp + (x + 1)) / 2][1];
#line 85
        k ++;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 84
      j ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 103
    fwrite((void const   */* __restrict  */)(pat___0), (size_t )1024, (size_t )1,
           (FILE */* __restrict  */)out);
#line 80
    i___3 ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 105
  free((void *)tmp);
#line 108
  i___3 = 0;
  }
  {
#line 108
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 108
    if (! (i___3 < 31)) {
#line 108
      goto while_break___4;
    }
#line 109
    if (ssizes[i___3] == 0) {
#line 110
      goto __Cont;
    }
    {
#line 111
    fseek(in, (long )saddr[i___3], 0);
#line 112
    pw_move_data(out, in, ssizes[i___3]);
    }
    __Cont: /* CIL Label */ 
#line 108
    i___3 ++;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 115
  return (0);
}
}
#line 119 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/prowizard/tdd.c"
static int test_tdd(uint8 *data , int s ) 
{ 
  int j ;
  int k ;
  int l ;
  int m___0 ;
  int n___0 ;
  int start ;
  int ssize ;
  uint8 *d ;
  uint32 tmp ;
  uint16 tmp___0 ;
  uint32 tmp___1 ;
  uint16 tmp___2 ;

  {
#line 122
  start = 0;
  {
#line 124
  while (1) {
    while_continue: /* CIL Label */ ;
#line 124
    if (s < 564) {
#line 124
      return (564 - s);
    }
#line 124
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 127
  ssize = 0;
#line 128
  j = 0;
  {
#line 128
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 128
    if (! (j < 31)) {
#line 128
      goto while_break___0;
    }
    {
#line 129
    d = (data + start) + j * 14;
#line 131
    tmp = readmem32b(d + 130);
#line 131
    k = (int )tmp;
#line 132
    tmp___0 = readmem16b(d + 134);
#line 132
    l = (int )tmp___0;
#line 133
    tmp___1 = readmem32b(d + 138);
#line 133
    m___0 = (int )tmp___1;
#line 134
    tmp___2 = readmem16b(d + 142);
#line 134
    n___0 = (int )tmp___2;
    }
#line 137
    if ((int )*(data + ((start + j * 14) + 137)) > 64) {
#line 138
      return (-1);
    }
#line 141
    if (m___0 < k) {
#line 142
      return (-1);
    }
#line 145
    if (k < 564) {
#line 146
      return (-1);
    } else
#line 145
    if (m___0 < 564) {
#line 146
      return (-1);
    }
#line 149
    if (m___0 - k > l) {
#line 150
      return (-1);
    }
#line 153
    if ((m___0 - k) + n___0 > l + 2) {
#line 154
      return (-1);
    }
#line 156
    ssize += l;
#line 128
    j ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 159
  if (ssize <= 2) {
#line 160
    return (-1);
  } else
#line 159
  if (ssize > 2031585) {
#line 160
    return (-1);
  }
#line 173
  if ((int )*(data + start) > 127) {
#line 174
    return (-1);
  } else
#line 173
  if ((int )*(data + start) == 0) {
#line 174
    return (-1);
  }
#line 177
  k = 0;
#line 178
  j = 0;
  {
#line 178
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 178
    if (! (j < 128)) {
#line 178
      goto while_break___1;
    }
#line 179
    if ((int )*(data + ((start + j) + 2)) > 127) {
#line 180
      return (-1);
    }
#line 181
    if ((int )*(data + ((start + j) + 2)) > k) {
#line 182
      k = (int )*(data + ((start + j) + 2));
    }
#line 178
    j ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 184
  k ++;
#line 185
  k *= 1024;
#line 188
  j = (int )*(data + start) + 2;
  {
#line 188
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 188
    if (! (j < 128)) {
#line 188
      goto while_break___2;
    }
#line 189
    if ((int )*(data + ((start + j) + 2)) != 0) {
#line 190
      return (-1);
    }
#line 188
    j ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 202
  l = (start + 564) + ssize;
#line 205
  j = 0;
  {
#line 205
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 205
    if (! (j < k)) {
#line 205
      goto while_break___3;
    }
#line 207
    if ((int )*(data + (l + j)) > 31) {
#line 208
      return (-1);
    }
#line 211
    if ((int )*(data + ((l + j) + 1)) > 72) {
#line 212
      return (-1);
    } else
#line 211
    if (((int )*(data + ((l + j) + 1)) & 1) == 1) {
#line 212
      return (-1);
    }
#line 215
    if (((int )*(data + ((l + j) + 2)) & 15) == 12) {
#line 215
      if ((int )*(data + ((l + j) + 3)) > 64) {
#line 216
        return (-1);
      }
    }
#line 219
    if (((int )*(data + ((l + j) + 2)) & 15) == 13) {
#line 219
      if ((int )*(data + ((l + j) + 3)) > 64) {
#line 220
        return (-1);
      }
    }
#line 223
    if (((int )*(data + ((l + j) + 2)) & 15) == 11) {
#line 224
      return (-1);
    }
#line 205
    j += 4;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 227
  return (-1);
}
}
#line 82 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/prowizard/prowiz.h"
struct pw_format pw_pru2 ;
#line 12 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/prowizard/prun2.c"
static int test_pru2(uint8 *data , int s ) ;
#line 13
static int depack_pru2(FILE *in , FILE *out ) ;
#line 16 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/prowizard/prun2.c"
struct pw_format pw_pru2  =    {(char *)"PRU2", (char *)"Prorunner 2.0", 0, & test_pru2, & depack_pru2, 0, {(struct list_head *)0,
                                                                                (struct list_head *)0}};
#line 25 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/prowizard/prun2.c"
static int depack_pru2(FILE *in , FILE *out ) 
{ 
  uint8 header[2048] ;
  uint8 c1 ;
  uint8 c2 ;
  uint8 c3 ;
  uint8 c4 ;
  uint8 npat ;
  uint8 ptable[128] ;
  uint8 max ;
  uint8 v[4][4] ;
  int size___0 ;
  int ssize ;
  int i___3 ;
  int j ;
  uint16 tmp ;
  uint8 tmp___0 ;
  uint8 tmp___1 ;
  uint16 tmp___2 ;
  uint16 tmp___3 ;
  uint8 tmp___4 ;
  void *__cil_tmp22 ;
  void *__cil_tmp23 ;
  void *__cil_tmp24 ;
  int __cil_tmp25 ;
  void *__cil_tmp26 ;

  {
  {
#line 31
  max = (uint8 )0;
#line 33
  ssize = 0;
#line 36
  memset((void *)(header), 0, (size_t )2048);
#line 37
  memset((void *)(ptable), 0, (size_t )128);
#line 39
  pw_write_zero(out, 20);
#line 41
  fseek(in, 8L, 0);
#line 43
  i___3 = 0;
  }
  {
#line 43
  while (1) {
    while_continue: /* CIL Label */ ;
#line 43
    if (! (i___3 < 31)) {
#line 43
      goto while_break;
    }
    {
#line 44
    pw_write_zero(out, 22);
#line 45
    tmp = read16b(in);
#line 45
    size___0 = (int )tmp;
#line 45
    write16b(out, (uint16 )size___0);
#line 46
    ssize += size___0 * 2;
#line 47
    tmp___0 = read8(in);
#line 47
    write8(out, tmp___0);
#line 48
    tmp___1 = read8(in);
#line 48
    write8(out, tmp___1);
#line 49
    tmp___2 = read16b(in);
#line 49
    write16b(out, tmp___2);
#line 50
    tmp___3 = read16b(in);
#line 50
    write16b(out, tmp___3);
#line 43
    i___3 ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 53
  npat = read8(in);
#line 53
  write8(out, npat);
#line 54
  tmp___4 = read8(in);
#line 54
  write8(out, tmp___4);
#line 56
  i___3 = 0;
  }
  {
#line 56
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 56
    if (! (i___3 < 128)) {
#line 56
      goto while_break___0;
    }
    {
#line 57
    c1 = read8(in);
#line 57
    write8(out, c1);
    }
#line 58
    if ((int )c1 > (int )max) {
#line 58
      max = c1;
    } else {
#line 58
      max = max;
    }
#line 56
    i___3 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 61
  write32b(out, (((77U << 24) | (46U << 16)) | (75U << 8)) | 46U);
#line 64
  fseek(in, 770L, 0);
#line 66
  i___3 = 0;
  }
  {
#line 66
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 66
    if (! (i___3 <= (int )max)) {
#line 66
      goto while_break___1;
    }
#line 67
    j = 0;
    {
#line 67
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 67
      if (! (j < 256)) {
#line 67
        goto while_break___2;
      }
      {
#line 68
      c4 = (uint8 )0;
#line 68
      c3 = c4;
#line 68
      c2 = c3;
#line 68
      c1 = c2;
#line 69
      header[0] = read8(in);
      }
#line 70
      if ((int )header[0] == 128) {
        {
#line 71
        write32b(out, (uint32 )0);
        }
      } else
#line 72
      if ((int )header[0] == 192) {
        {
#line 73
        fwrite((void const   */* __restrict  */)(v[0]), (size_t )4, (size_t )1, (FILE */* __restrict  */)out);
#line 74
        c1 = v[0][0];
#line 75
        c2 = v[0][1];
#line 76
        c3 = v[0][2];
#line 77
        c4 = v[0][3];
        }
      } else
#line 78
      if ((int )header[0] != 192) {
#line 78
        if ((int )header[0] != 192) {
          {
#line 79
          header[1] = read8(in);
#line 80
          header[2] = read8(in);
#line 82
          c1 = (uint8 )(((int )header[1] & 128) >> 3);
#line 83
          c1 = (uint8 )((int )c1 | (int )ptk_table[(int )header[0] >> 1][0]);
#line 84
          c2 = (uint8 )ptk_table[(int )header[0] >> 1][1];
#line 85
          c3 = (uint8 )(((int )header[1] & 112) << 1);
#line 86
          c3 = (uint8 )((int )c3 | (((int )header[0] & 1) << 4));
#line 87
          c3 = (uint8 )((int )c3 | ((int )header[1] & 15));
#line 88
          c4 = header[2];
#line 90
          write8(out, c1);
#line 91
          write8(out, c2);
#line 92
          write8(out, c3);
#line 93
          write8(out, c4);
          }
        }
      }
#line 97
      v[0][0] = v[1][0];
#line 98
      v[0][1] = v[1][1];
#line 99
      v[0][2] = v[1][2];
#line 100
      v[0][3] = v[1][3];
#line 102
      v[1][0] = v[2][0];
#line 103
      v[1][1] = v[2][1];
#line 104
      v[1][2] = v[2][2];
#line 105
      v[1][3] = v[2][3];
#line 107
      v[2][0] = v[3][0];
#line 108
      v[2][1] = v[3][1];
#line 109
      v[2][2] = v[3][2];
#line 110
      v[2][3] = v[3][3];
#line 112
      v[3][0] = c1;
#line 113
      v[3][1] = c2;
#line 114
      v[3][2] = c3;
#line 115
      v[3][3] = c4;
#line 67
      j ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 66
    i___3 ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 120
  pw_move_data(out, in, ssize);
  }
#line 122
  return (0);
}
}
#line 126 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/prowizard/prun2.c"
static int test_pru2(uint8 *data , int s ) 
{ 
  int k ;
  int start ;

  {
#line 129
  start = 0;
  {
#line 131
  while (1) {
    while_continue: /* CIL Label */ ;
#line 131
    if (s < 260) {
#line 131
      return (260 - s);
    }
#line 131
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 133
  if ((int )*(data + 0) != 83) {
#line 134
    return (-1);
  } else
#line 133
  if ((int )*(data + 1) != 78) {
#line 134
    return (-1);
  } else
#line 133
  if ((int )*(data + 2) != 84) {
#line 134
    return (-1);
  } else
#line 133
  if ((int )*(data + 3) != 33) {
#line 134
    return (-1);
  }
#line 145
  k = 0;
  {
#line 145
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 145
    if (! (k < 31)) {
#line 145
      goto while_break___0;
    }
#line 146
    if ((int )*(data + ((start + 11) + k * 8)) > 64) {
#line 147
      return (-1);
    }
#line 145
    k ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 151
  k = 0;
  {
#line 151
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 151
    if (! (k < 31)) {
#line 151
      goto while_break___1;
    }
#line 152
    if ((int )*(data + ((start + 10) + k * 8)) > 15) {
#line 153
      return (-1);
    }
#line 151
    k ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 156
  return (0);
}
}
#line 81 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/prowizard/prowiz.h"
struct pw_format pw_pru1 ;
#line 13 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/prowizard/prun1.c"
static int test_pru1(uint8 *data , int s ) ;
#line 14
static int depack_pru1(FILE *in , FILE *out ) ;
#line 16 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/prowizard/prun1.c"
struct pw_format pw_pru1  =    {(char *)"PRU1", (char *)"Prorunner 1.0", 0, & test_pru1, & depack_pru1, 0, {(struct list_head *)0,
                                                                                (struct list_head *)0}};
#line 25 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/prowizard/prun1.c"
static int depack_pru1(FILE *in , FILE *out ) 
{ 
  uint8 header[2048] ;
  uint8 c1 ;
  uint8 c2 ;
  uint8 c3 ;
  uint8 c4 ;
  uint8 npat ;
  uint8 max ;
  uint8 ptable[128] ;
  int ssize ;
  int i___3 ;
  int j ;
  uint16 tmp ;
  void *__cil_tmp15 ;
  void *__cil_tmp16 ;

  {
  {
#line 31
  ssize = 0;
#line 34
  memset((void *)(header), 0, (size_t )2048);
#line 35
  memset((void *)(ptable), 0, (size_t )128);
#line 38
  fread((void */* __restrict  */)(header), (size_t )950, (size_t )1, (FILE */* __restrict  */)in);
#line 39
  fwrite((void const   */* __restrict  */)(header), (size_t )950, (size_t )1, (FILE */* __restrict  */)out);
#line 42
  i___3 = 0;
  }
  {
#line 42
  while (1) {
    while_continue: /* CIL Label */ ;
#line 42
    if (! (i___3 < 31)) {
#line 42
      goto while_break;
    }
    {
#line 43
    tmp = readmem16b((header + i___3 * 30) + 42);
#line 43
    ssize += (int )tmp * 2;
#line 42
    i___3 ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 46
  npat = read8(in);
#line 46
  write8(out, npat);
#line 48
  memset((void *)(header), 0, (size_t )2048);
#line 51
  fread((void */* __restrict  */)(header), (size_t )129, (size_t )1, (FILE */* __restrict  */)in);
#line 52
  fwrite((void const   */* __restrict  */)(header), (size_t )129, (size_t )1, (FILE */* __restrict  */)out);
#line 55
  write32b(out, (((77U << 24) | (46U << 16)) | (75U << 8)) | 46U);
#line 58
  max = (uint8 )0;
#line 59
  i___3 = 1;
  }
  {
#line 59
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 59
    if (! (i___3 < 129)) {
#line 59
      goto while_break___0;
    }
#line 60
    if ((int )header[i___3] > (int )max) {
#line 61
      max = header[i___3];
    }
#line 59
    i___3 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 65
  fseek(in, 1084L, 0);
#line 66
  i___3 = 0;
  }
  {
#line 66
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 66
    if (! (i___3 <= (int )max)) {
#line 66
      goto while_break___1;
    }
#line 67
    j = 0;
    {
#line 67
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 67
      if (! (j < 256)) {
#line 67
        goto while_break___2;
      }
      {
#line 68
      header[0] = read8(in);
#line 69
      header[1] = read8(in);
#line 70
      header[2] = read8(in);
#line 71
      header[3] = read8(in);
#line 72
      c1 = (uint8 )((int )header[0] & 240);
#line 73
      c3 = (uint8 )(((int )header[0] & 15) << 4);
#line 74
      c3 = (uint8 )((int )c3 | (int )header[2]);
#line 75
      c4 = header[3];
#line 76
      c1 = (uint8 )((int )c1 | (int )ptk_table[header[1]][0]);
#line 77
      c2 = (uint8 )ptk_table[header[1]][1];
#line 78
      write8(out, c1);
#line 79
      write8(out, c2);
#line 80
      write8(out, c3);
#line 81
      write8(out, c4);
#line 67
      j ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
#line 66
    i___3 ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 86
  pw_move_data(out, in, ssize);
  }
#line 88
  return (0);
}
}
#line 92 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/prowizard/prun1.c"
static int test_pru1(uint8 *data , int s ) 
{ 
  int start ;

  {
#line 94
  start = 0;
  {
#line 96
  while (1) {
    while_continue: /* CIL Label */ ;
#line 96
    if (s < 1080) {
#line 96
      return (1080 - s);
    }
#line 96
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 98
  if ((int )*(data + 1080) != 83) {
#line 100
    return (-1);
  } else
#line 98
  if ((int )*(data + 1081) != 78) {
#line 100
    return (-1);
  } else
#line 98
  if ((int )*(data + 1082) != 84) {
#line 100
    return (-1);
  } else
#line 98
  if ((int )*(data + 1083) != 46) {
#line 100
    return (-1);
  }
#line 103
  if ((int )*(data + (start + 951)) != 127) {
#line 104
    return (-1);
  }
#line 107
  if ((int )*(data + (start + 950)) > 127) {
#line 108
    return (-1);
  }
#line 110
  return (0);
}
}
#line 79 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/prowizard/prowiz.h"
struct pw_format pw_pha ;
#line 13 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/prowizard/pha.c"
static int test_pha(uint8 *data , int s ) ;
#line 14
static int depack_pha(FILE *in , FILE *out ) ;
#line 16 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/prowizard/pha.c"
struct pw_format pw_pha  =    {(char *)"PHA", (char *)"Pha Packer", 0, & test_pha, & depack_pha, 0, {(struct list_head *)0,
                                                                          (struct list_head *)0}};
#line 24 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/prowizard/pha.c"
static int depack_pha(FILE *in , FILE *out ) 
{ 
  uint8 c1 ;
  uint8 c2 ;
  uint8 pnum[128] ;
  uint8 pnum1[128] ;
  uint8 nop ;
  uint8 *pdata ;
  uint8 *pat___0 ;
  uint8 onote[4][4] ;
  uint8 note ;
  uint8 ins ;
  uint8 fxt ;
  uint8 fxp ;
  uint8 npat ;
  int paddr[128] ;
  int i___3 ;
  int j ;
  int k ;
  int paddr1[128] ;
  int paddr2[128] ;
  int tmp_ptr ;
  int tmp1 ;
  int tmp2 ;
  int Start_Pat_Address ;
  int psize ;
  int size___0 ;
  int ssize ;
  int sdata_Address ;
  short ocpt[4] ;
  uint16 tmp ;
  uint8 tmp___0 ;
  uint16 tmp___1 ;
  uint16 tmp___2 ;
  uint32 tmp___3 ;
  int tmp___4 ;
  long tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  void *__cil_tmp40 ;
  void *__cil_tmp41 ;
  void *__cil_tmp42 ;
  int __cil_tmp43 ;
  void *__cil_tmp44 ;
  void *__cil_tmp45 ;
  void *__cil_tmp46 ;
  void *__cil_tmp47 ;
  void *__cil_tmp48 ;

  {
  {
#line 34
  npat = (uint8 )0;
#line 42
  ssize = 0;
#line 46
  memset((void *)(paddr), 0, (size_t )512);
#line 47
  memset((void *)(paddr1), 0, (size_t )512);
#line 48
  memset((void *)(paddr2), 0, (size_t )512);
#line 49
  memset((void *)(pnum), 0, (size_t )128);
#line 50
  memset((void *)(pnum1), 0, (size_t )128);
#line 51
  memset((void *)(onote), 0, (size_t )16);
#line 52
  memset((void *)(ocpt), 0, (size_t )8);
#line 54
  pw_write_zero(out, 20);
#line 56
  i___3 = 0;
  }
  {
#line 56
  while (1) {
    while_continue: /* CIL Label */ ;
#line 56
    if (! (i___3 < 31)) {
#line 56
      goto while_break;
    }
    {
#line 57
    pw_write_zero(out, 22);
#line 58
    tmp = read16b(in);
#line 58
    size___0 = (int )tmp;
#line 58
    write16b(out, (uint16 )size___0);
#line 59
    ssize += size___0 * 2;
#line 60
    read8(in);
#line 61
    write8(out, (uint8 )0);
#line 62
    tmp___0 = read8(in);
#line 62
    write8(out, tmp___0);
#line 63
    tmp___1 = read16b(in);
#line 63
    write16b(out, tmp___1);
#line 64
    tmp___2 = read16b(in);
#line 64
    write16b(out, tmp___2);
#line 66
    read32b(in);
#line 68
    c1 = read8(in);
    }
#line 69
    if ((int )c1 != 0) {
#line 70
      c1 = (uint8 )((int )c1 + 11);
    }
    {
#line 71
    fseek(out, -6L, 2);
#line 72
    write8(out, c1);
#line 73
    fseek(out, 0L, 2);
#line 74
    fseek(in, 1L, 1);
#line 56
    i___3 ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 77
  fseek(in, 14L, 1);
#line 79
  i___3 = 0;
  }
  {
#line 79
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 79
    if (! (i___3 < 128)) {
#line 79
      goto while_break___0;
    }
    {
#line 80
    tmp___3 = read32b(in);
#line 80
    paddr[i___3] = (int )tmp___3;
#line 79
    i___3 ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 84
  tmp_ptr = 0;
#line 85
  i___3 = 0;
  {
#line 85
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 85
    if (! (i___3 < 128)) {
#line 85
      goto while_break___1;
    }
#line 86
    if (i___3 == 0) {
#line 87
      pnum[0] = (uint8 )0;
#line 88
      tmp_ptr ++;
#line 89
      goto __Cont;
    }
#line 92
    j = 0;
    {
#line 92
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 92
      if (! (j < i___3)) {
#line 92
        goto while_break___2;
      }
#line 93
      if (paddr[i___3] == paddr[j]) {
#line 94
        pnum[i___3] = pnum[j];
#line 95
        goto while_break___2;
      }
#line 92
      j ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 98
    if (j == i___3) {
#line 99
      tmp___4 = tmp_ptr;
#line 99
      tmp_ptr ++;
#line 99
      pnum[i___3] = (uint8 )tmp___4;
    }
    __Cont: /* CIL Label */ 
#line 85
    i___3 ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 103
  i___3 = 0;
  {
#line 103
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 103
    if (! (i___3 < 128)) {
#line 103
      goto while_break___3;
    }
#line 104
    paddr1[i___3] = paddr[i___3];
#line 103
    i___3 ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  restart: 
#line 107
  i___3 = 0;
  {
#line 107
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 107
    if (! (i___3 < 128)) {
#line 107
      goto while_break___4;
    }
#line 108
    j = 0;
    {
#line 108
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 108
      if (! (j < i___3)) {
#line 108
        goto while_break___5;
      }
#line 109
      if (paddr1[i___3] < paddr1[j]) {
#line 110
        tmp2 = (int )pnum[j];
#line 111
        pnum[j] = pnum[i___3];
#line 112
        pnum[i___3] = (uint8 )tmp2;
#line 113
        tmp1 = paddr1[j];
#line 114
        paddr1[j] = paddr1[i___3];
#line 115
        paddr1[i___3] = tmp1;
#line 116
        goto restart;
      }
#line 108
      j ++;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 107
    i___3 ++;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 121
  j = 0;
#line 122
  i___3 = 0;
  {
#line 122
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 122
    if (! (i___3 < 128)) {
#line 122
      goto while_break___6;
    }
#line 123
    if (i___3 == 0) {
#line 124
      paddr2[j] = paddr1[i___3];
#line 125
      goto __Cont___0;
    }
#line 128
    if (paddr1[i___3] == paddr2[j]) {
#line 129
      goto __Cont___0;
    }
#line 130
    j ++;
#line 130
    paddr2[j] = paddr1[i___3];
    __Cont___0: /* CIL Label */ 
#line 122
    i___3 ++;
  }
  while_break___6: /* CIL Label */ ;
  }
  {
#line 134
  memset((void *)(paddr1), 0, (size_t )512);
#line 135
  j = 0;
#line 136
  k = paddr[0];
#line 138
  i___3 = 0;
  }
  {
#line 138
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 138
    if (! (i___3 < 120)) {
#line 138
      goto while_break___7;
    }
#line 139
    paddr1[j] = paddr2[i___3];
#line 140
    j ++;
#line 141
    if (paddr2[i___3 + 1] - paddr2[i___3] > 1024) {
#line 142
      paddr1[j] = paddr2[i___3] + 1024;
#line 143
      j ++;
    }
#line 138
    i___3 ++;
  }
  while_break___7: /* CIL Label */ ;
  }
#line 147
  c1 = (uint8 )0;
  {
#line 147
  while (1) {
    while_continue___8: /* CIL Label */ ;
#line 147
    if (! ((int )c1 < 128)) {
#line 147
      goto while_break___8;
    }
#line 148
    c2 = (uint8 )0;
    {
#line 148
    while (1) {
      while_continue___9: /* CIL Label */ ;
#line 148
      if (! ((int )c2 < 128)) {
#line 148
        goto while_break___9;
      }
#line 149
      if (paddr[c1] == paddr1[c2]) {
#line 150
        pnum1[c1] = c2;
      }
#line 148
      c2 = (uint8 )((int )c2 + 1);
    }
    while_break___9: /* CIL Label */ ;
    }
#line 147
    c1 = (uint8 )((int )c1 + 1);
  }
  while_break___8: /* CIL Label */ ;
  }
  {
#line 154
  memset((void *)(pnum), 0, (size_t )128);
#line 155
  Start_Pat_Address = 999999;
#line 156
  i___3 = 0;
  }
  {
#line 156
  while (1) {
    while_continue___10: /* CIL Label */ ;
#line 156
    if (! (i___3 < 128)) {
#line 156
      goto while_break___10;
    }
#line 157
    pnum[i___3] = pnum1[i___3];
#line 158
    if (paddr[i___3] < Start_Pat_Address) {
#line 159
      Start_Pat_Address = paddr[i___3];
    }
#line 156
    i___3 ++;
  }
  while_break___10: /* CIL Label */ ;
  }
#line 163
  nop = (uint8 )128;
  {
#line 163
  while (1) {
    while_continue___11: /* CIL Label */ ;
#line 163
    if (! ((int )nop > 0)) {
#line 163
      goto while_break___11;
    }
#line 164
    if ((int )pnum[(int )nop - 1] != 0) {
#line 165
      goto while_break___11;
    }
#line 163
    nop = (uint8 )((int )nop - 1);
  }
  while_break___11: /* CIL Label */ ;
  }
  {
#line 169
  write8(out, nop);
#line 172
  i___3 = 0;
  }
  {
#line 172
  while (1) {
    while_continue___12: /* CIL Label */ ;
#line 172
    if (! (i___3 < (int )nop)) {
#line 172
      goto while_break___12;
    }
#line 173
    if ((int )pnum[i___3] > (int )npat) {
#line 174
      npat = pnum[i___3];
    }
#line 172
    i___3 ++;
  }
  while_break___12: /* CIL Label */ ;
  }
  {
#line 176
  write8(out, (uint8 )127);
#line 178
  i___3 = 0;
  }
  {
#line 178
  while (1) {
    while_continue___13: /* CIL Label */ ;
#line 178
    if (! (i___3 < 128)) {
#line 178
      goto while_break___13;
    }
    {
#line 179
    write8(out, pnum[i___3]);
#line 178
    i___3 ++;
    }
  }
  while_break___13: /* CIL Label */ ;
  }
  {
#line 181
  write32b(out, (((77U << 24) | (46U << 16)) | (75U << 8)) | 46U);
#line 183
  tmp___5 = ftell(in);
#line 183
  sdata_Address = (int )tmp___5;
#line 184
  fseek(in, (long )Start_Pat_Address, 0);
#line 196
  psize = (int )npat * 1024;
#line 197
  tmp___6 = malloc((size_t )psize);
#line 197
  pdata = (uint8 *)tmp___6;
#line 198
  fread((void */* __restrict  */)pdata, (size_t )1, (size_t )psize, (FILE */* __restrict  */)in);
#line 199
  npat = (uint8 )((int )npat + 1);
#line 200
  tmp___7 = malloc((size_t )((int )npat * 1024));
#line 200
  pat___0 = (uint8 *)tmp___7;
#line 201
  memset((void *)pat___0, 0, (size_t )((int )npat * 1024));
#line 203
  j = 0;
#line 204
  i___3 = 0;
  }
  {
#line 204
  while (1) {
    while_continue___14: /* CIL Label */ ;
#line 204
    if (! (j < (int )npat * 1024)) {
#line 204
      goto while_break___14;
    }
#line 205
    if ((int )*(pdata + i___3) == 255) {
#line 206
      i___3 ++;
#line 207
      ocpt[(k + 3) % 4] = (short )(255 - (int )*(pdata + i___3));
#line 208
      goto __Cont___1;
    }
#line 210
    if ((int )ocpt[k % 4] != 0) {
#line 211
      ins = onote[k % 4][0];
#line 212
      note = onote[k % 4][1];
#line 213
      fxt = onote[k % 4][2];
#line 214
      fxp = onote[k % 4][3];
#line 215
      ocpt[k % 4] = (short )((int )ocpt[k % 4] - 1);
#line 217
      *(pat___0 + j) = (uint8 )((int )ins & 240);
#line 218
      *(pat___0 + j) = (uint8 )((int )*(pat___0 + j) | (int )ptk_table[(int )note / 2][0]);
#line 219
      *(pat___0 + (j + 1)) = (uint8 )ptk_table[(int )note / 2][1];
#line 220
      *(pat___0 + (j + 2)) = (uint8 )(((int )ins << 4) & 240);
#line 221
      *(pat___0 + (j + 2)) = (uint8 )((int )*(pat___0 + (j + 2)) | (int )fxt);
#line 222
      *(pat___0 + (j + 3)) = fxp;
#line 223
      k ++;
#line 224
      j += 4;
#line 225
      i___3 --;
#line 226
      goto __Cont___1;
    }
#line 228
    ins = *(pdata + i___3);
#line 229
    note = *(pdata + (i___3 + 1));
#line 230
    fxt = *(pdata + (i___3 + 2));
#line 231
    fxp = *(pdata + (i___3 + 3));
#line 232
    onote[k % 4][0] = ins;
#line 233
    onote[k % 4][1] = note;
#line 234
    onote[k % 4][2] = fxt;
#line 235
    onote[k % 4][3] = fxp;
#line 236
    i___3 += 3;
#line 237
    *(pat___0 + j) = (uint8 )((int )ins & 240);
#line 238
    *(pat___0 + j) = (uint8 )((int )*(pat___0 + j) | (int )ptk_table[(int )note / 2][0]);
#line 239
    *(pat___0 + (j + 1)) = (uint8 )ptk_table[(int )note / 2][1];
#line 240
    *(pat___0 + (j + 2)) = (uint8 )(((int )ins << 4) & 240);
#line 241
    *(pat___0 + (j + 2)) = (uint8 )((int )*(pat___0 + (j + 2)) | (int )fxt);
#line 242
    *(pat___0 + (j + 3)) = fxp;
#line 243
    k ++;
#line 244
    j += 4;
    __Cont___1: /* CIL Label */ 
#line 204
    i___3 ++;
  }
  while_break___14: /* CIL Label */ ;
  }
  {
#line 246
  fwrite((void const   */* __restrict  */)pat___0, (size_t )((int )npat * 1024), (size_t )1,
         (FILE */* __restrict  */)out);
#line 247
  free((void *)pdata);
#line 248
  free((void *)pat___0);
#line 251
  fseek(in, (long )sdata_Address, 0);
#line 252
  pw_move_data(out, in, ssize);
  }
#line 254
  return (0);
}
}
#line 258 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/prowizard/pha.c"
static int test_pha(uint8 *data , int s ) 
{ 
  int j ;
  int k ;
  int l ;
  int m___0 ;
  int n___0 ;
  int start ;
  int ssize ;

  {
#line 261
  start = 0;
  {
#line 263
  while (1) {
    while_continue: /* CIL Label */ ;
#line 263
    if (s < 963) {
#line 263
      return (963 - s);
    }
#line 263
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 265
  if ((int )*(data + 10) != 3) {
#line 266
    return (-1);
  } else
#line 265
  if ((int )*(data + 11) != 192) {
#line 266
    return (-1);
  }
#line 269
  l = 0;
#line 270
  j = 0;
  {
#line 270
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 270
    if (! (j < 31)) {
#line 270
      goto while_break___0;
    }
#line 272
    n___0 = (((int )*(data + (start + j * 14)) << 8) + (int )*(data + ((start + j * 14) + 1))) * 2;
#line 274
    l += n___0;
#line 276
    m___0 = (((int )*(data + ((start + j * 14) + 4)) << 8) + (int )*(data + ((start + j * 14) + 5))) * 2;
#line 279
    if ((int )*(data + ((start + 3) + j * 14)) > 64) {
#line 280
      return (-1);
    }
#line 282
    if (m___0 > l) {
#line 283
      return (-1);
    }
#line 285
    k = ((((int )*(data + ((start + 8) + j * 14)) << 24) + ((int )*(data + ((start + 9) + j * 14)) << 16)) + ((int )*(data + ((start + 10) + j * 14)) << 8)) + (int )*(data + ((start + 11) + j * 14));
#line 291
    if (k < 960) {
#line 292
      return (-1);
    }
#line 270
    j ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 295
  if (l <= 2) {
#line 296
    return (-1);
  } else
#line 295
  if (l > 2031585) {
#line 296
    return (-1);
  }
#line 301
  l += 960;
#line 302
  k = 0;
#line 303
  j = 0;
  {
#line 303
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 303
    if (! (j < 128)) {
#line 303
      goto while_break___1;
    }
#line 304
    ssize = ((((int )*(data + ((start + 448) + j * 4)) << 24) + ((int )*(data + ((start + 449) + j * 4)) << 16)) + ((int )*(data + ((start + 450) + j * 4)) << 8)) + (int )*(data + ((start + 451) + j * 4));
#line 309
    if (ssize > k) {
#line 310
      k = ssize;
    }
#line 312
    if (ssize + 2 < l) {
#line 313
      return (-1);
    }
#line 303
    j ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 315
  ssize = 0;
#line 318
  return (0);
}
}
#line 53 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/prowizard/prowiz.h"
short const   tun_table[16][36] ;
#line 73
struct pw_format pw_p18a ;
#line 16 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/prowizard/pm18a.c"
static int test_p18a(uint8 *data , int s ) ;
#line 17
static int depack_p18a(FILE *in , FILE *out ) ;
#line 19 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/prowizard/pm18a.c"
struct pw_format pw_p18a  =    {(char *)"P18A", (char *)"Promizer 1.8a", 0, & test_p18a, & depack_p18a, 0, {(struct list_head *)0,
                                                                                (struct list_head *)0}};
#line 30 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/prowizard/pm18a.c"
static int depack_p18a(FILE *in , FILE *out ) 
{ 
  uint8 c3 ;
  short pat_max ;
  int tmp_ptr ;
  int refmax ;
  uint8 pnum[128] ;
  int paddr[128] ;
  short pptr[64][256] ;
  uint8 NOP ;
  uint8 *reftab ;
  uint8 pat___0[128][1024] ;
  int i___3 ;
  int j ;
  int k ;
  int l ;
  int size___0 ;
  int ssize ;
  int psize ;
  int SDAV ;
  uint8 FLAG ;
  uint8 fin[31] ;
  uint8 oins[4] ;
  short per ;
  uint16 tmp ;
  uint8 tmp___0 ;
  uint8 tmp___1 ;
  uint16 tmp___2 ;
  uint16 tmp___3 ;
  uint16 tmp___4 ;
  uint32 tmp___5 ;
  int tmp___6 ;
  uint32 tmp___7 ;
  int x ;
  uint16 tmp___8 ;
  void *tmp___9 ;
  int x___0 ;
  uint16 tmp___10 ;
  int y ;
  uint16 tmp___11 ;
  uint16 tmp___12 ;
  uint16 tmp___13 ;
  uint32 tmp___14 ;
  void *__cil_tmp44 ;
  void *__cil_tmp45 ;
  void *__cil_tmp46 ;
  int __cil_tmp47 ;
  void *__cil_tmp48 ;
  void *__cil_tmp49 ;
  int __cil_tmp50 ;
  void *__cil_tmp51 ;
  void *__cil_tmp52 ;
  void *__cil_tmp53 ;

  {
  {
#line 39
  NOP = (uint8 )0;
#line 42
  i___3 = 0;
#line 42
  j = 0;
#line 42
  k = 0;
#line 42
  l = 0;
#line 46
  FLAG = (uint8 )1;
#line 51
  memset((void *)(pnum), 0, (size_t )128);
#line 52
  memset((void *)(pptr), 0, (size_t )(64 << 8));
#line 53
  memset((void *)(pat___0), 0, (size_t )131072);
#line 54
  memset((void *)(fin), 0, (size_t )31);
#line 55
  memset((void *)(oins), 0, (size_t )4);
#line 56
  memset((void *)(paddr), 0, (size_t )512);
#line 58
  pw_write_zero(out, 20);
#line 61
  fseek(in, 4464L, 0);
#line 63
  ssize = 0;
#line 64
  i___3 = 0;
  }
  {
#line 64
  while (1) {
    while_continue: /* CIL Label */ ;
#line 64
    if (! (i___3 < 31)) {
#line 64
      goto while_break;
    }
    {
#line 65
    pw_write_zero(out, 22);
#line 66
    tmp = read16b(in);
#line 66
    size___0 = (int )tmp;
#line 66
    write16b(out, (uint16 )size___0);
#line 67
    ssize += size___0 * 2;
#line 68
    tmp___0 = read8(in);
#line 68
    fin[i___3] = tmp___0;
#line 68
    write8(out, tmp___0);
#line 69
    tmp___1 = read8(in);
#line 69
    write8(out, tmp___1);
#line 70
    tmp___2 = read16b(in);
#line 70
    write16b(out, tmp___2);
#line 71
    tmp___3 = read16b(in);
#line 71
    write16b(out, tmp___3);
#line 64
    i___3 ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 74
  tmp___4 = read16b(in);
#line 74
  NOP = (uint8 )((int )tmp___4 / 4);
#line 74
  write8(out, NOP);
#line 75
  write8(out, (uint8 )127);
#line 77
  i___3 = 0;
  }
  {
#line 77
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 77
    if (! (i___3 < 128)) {
#line 77
      goto while_break___0;
    }
    {
#line 78
    tmp___5 = read32b(in);
#line 78
    paddr[i___3] = (int )tmp___5;
#line 77
    i___3 ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 82
  tmp_ptr = 0;
#line 83
  i___3 = 0;
  {
#line 83
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 83
    if (! (i___3 < (int )NOP)) {
#line 83
      goto while_break___1;
    }
#line 84
    if (i___3 == 0) {
#line 85
      pnum[0] = (uint8 )0;
#line 86
      tmp_ptr ++;
#line 87
      goto __Cont;
    }
#line 89
    j = 0;
    {
#line 89
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 89
      if (! (j < i___3)) {
#line 89
        goto while_break___2;
      }
#line 90
      if (paddr[i___3] == paddr[j]) {
#line 91
        pnum[i___3] = pnum[j];
#line 92
        goto while_break___2;
      }
#line 89
      j ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 95
    if (j == i___3) {
#line 96
      tmp___6 = tmp_ptr;
#line 96
      tmp_ptr ++;
#line 96
      pnum[i___3] = (uint8 )tmp___6;
    }
    __Cont: /* CIL Label */ 
#line 83
    i___3 ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 99
  pat_max = (short )(tmp_ptr - 1);
#line 101
  fwrite((void const   */* __restrict  */)(pnum), (size_t )128, (size_t )1, (FILE */* __restrict  */)out);
#line 102
  write32b(out, (((77U << 24) | (46U << 16)) | (75U << 8)) | 46U);
#line 108
  fseek(in, 4460L, 0);
#line 109
  tmp___7 = read32b(in);
#line 109
  psize = (int )tmp___7;
#line 110
  fseek(in, 5226L, 0);
#line 113
  refmax = 0;
#line 114
  j = 0;
  }
  {
#line 114
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 114
    if (! (j < psize)) {
#line 114
      goto while_break___3;
    }
    {
#line 115
    tmp___8 = read16b(in);
#line 115
    x = (int )tmp___8;
    }
#line 116
    if (x > refmax) {
#line 117
      refmax = x;
    }
#line 114
    j += 2;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 121
  refmax ++;
#line 122
  i___3 = refmax * 4;
#line 123
  tmp___9 = malloc((size_t )i___3);
#line 123
  reftab = (uint8 *)tmp___9;
#line 124
  fread((void */* __restrict  */)reftab, (size_t )i___3, (size_t )1, (FILE */* __restrict  */)in);
#line 125
  fseek(in, 5226L, 0);
#line 127
  k = 0;
#line 128
  j = 0;
  }
  {
#line 128
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 128
    if (! (j <= (int )pat_max)) {
#line 128
      goto while_break___4;
    }
    {
#line 129
    fseek(in, (long )(paddr[j] + 5226), 0);
#line 130
    i___3 = 0;
    }
    {
#line 130
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 130
      if (! (i___3 < 64)) {
#line 130
        goto while_break___5;
      }
      {
#line 132
      tmp___10 = read16b(in);
#line 132
      x___0 = (int )tmp___10 * 4;
#line 133
      y = i___3 * 16;
#line 135
      k += 2;
#line 136
      pat___0[j][y] = *(reftab + x___0);
#line 137
      pat___0[j][y + 1] = *(reftab + (x___0 + 1));
#line 138
      pat___0[j][y + 2] = *(reftab + (x___0 + 2));
#line 139
      pat___0[j][y + 3] = *(reftab + (x___0 + 3));
#line 141
      c3 = (uint8 )((((int )pat___0[j][y + 2] >> 4) & 15) | ((int )pat___0[j][y] & 240));
      }
#line 143
      if (c3) {
#line 144
        oins[0] = c3;
      }
#line 146
      per = (short )((((int )pat___0[j][y] & 15) << 8) + (int )pat___0[j][y + 1]);
#line 148
      if (per) {
#line 148
        if (fin[(int )oins[0] - 1]) {
#line 149
          l = 0;
          {
#line 149
          while (1) {
            while_continue___6: /* CIL Label */ ;
#line 149
            if (! (l < 36)) {
#line 149
              goto while_break___6;
            }
#line 150
            if ((int const   )tun_table[fin[(int )oins[0] - 1]][l] == (int const   )per) {
#line 151
              pat___0[j][y] = (uint8 )((int )pat___0[j][y] & 240);
#line 152
              pat___0[j][y] = (uint8 )((int )pat___0[j][y] | (int )ptk_table[l + 1][0]);
#line 153
              pat___0[j][y + 1] = (uint8 )ptk_table[l + 1][1];
#line 154
              goto while_break___6;
            }
#line 149
            l ++;
          }
          while_break___6: /* CIL Label */ ;
          }
        }
      }
#line 158
      if (((int )pat___0[j][y + 2] & 15) == 13) {
#line 160
        FLAG = (uint8 )0;
      } else
#line 158
      if (((int )pat___0[j][y + 2] & 15) == 11) {
#line 160
        FLAG = (uint8 )0;
      }
      {
#line 165
      tmp___11 = read16b(in);
#line 165
      x___0 = (int )tmp___11 * 4;
#line 166
      k += 2;
#line 167
      pat___0[j][y + 4] = *(reftab + x___0);
#line 168
      pat___0[j][y + 5] = *(reftab + (x___0 + 1));
#line 169
      pat___0[j][y + 6] = *(reftab + (x___0 + 2));
#line 170
      pat___0[j][y + 7] = *(reftab + (x___0 + 3));
#line 171
      c3 = (uint8 )((((int )pat___0[j][y + 6] >> 4) & 15) | ((int )pat___0[j][y + 4] & 240));
      }
#line 174
      if (c3) {
#line 175
        oins[1] = c3;
      }
#line 177
      per = (short )((((int )pat___0[j][y + 4] & 15) << 8) + (int )pat___0[j][y + 5]);
#line 178
      if ((int )per != 0) {
#line 178
        if ((int )fin[(int )oins[1] - 1] != 0) {
#line 179
          l = 0;
          {
#line 179
          while (1) {
            while_continue___7: /* CIL Label */ ;
#line 179
            if (! (l < 36)) {
#line 179
              goto while_break___7;
            }
#line 180
            if ((int const   )tun_table[fin[(int )oins[1] - 1]][l] == (int const   )per) {
#line 181
              pat___0[j][y + 4] = (uint8 )((int )pat___0[j][y + 4] & 240);
#line 182
              pat___0[j][y + 4] = (uint8 )((int )pat___0[j][y + 4] | (int )ptk_table[l + 1][0]);
#line 183
              pat___0[j][y + 5] = (uint8 )ptk_table[l + 1][1];
#line 184
              goto while_break___7;
            }
#line 179
            l ++;
          }
          while_break___7: /* CIL Label */ ;
          }
        }
      }
#line 188
      if (((int )pat___0[j][y + 6] & 15) == 13) {
#line 190
        FLAG = (uint8 )0;
      } else
#line 188
      if (((int )pat___0[j][y + 6] & 15) == 11) {
#line 190
        FLAG = (uint8 )0;
      }
      {
#line 195
      tmp___12 = read16b(in);
#line 195
      x___0 = (int )tmp___12 * 4;
#line 196
      k += 2;
#line 197
      pat___0[j][y + 8] = *(reftab + x___0);
#line 198
      pat___0[j][y + 9] = *(reftab + (x___0 + 1));
#line 199
      pat___0[j][y + 10] = *(reftab + (x___0 + 2));
#line 200
      pat___0[j][y + 11] = *(reftab + (x___0 + 3));
#line 201
      c3 = (uint8 )((((int )pat___0[j][y + 10] >> 4) & 15) | ((int )pat___0[j][y + 8] & 240));
      }
#line 204
      if (c3) {
#line 205
        oins[2] = c3;
      }
#line 207
      per = (short )((((int )pat___0[j][y + 8] & 15) << 8) + (int )pat___0[j][y + 9]);
#line 208
      if ((int )per != 0) {
#line 208
        if ((int )fin[(int )oins[2] - 1] != 0) {
#line 210
          l = 0;
          {
#line 210
          while (1) {
            while_continue___8: /* CIL Label */ ;
#line 210
            if (! (l < 36)) {
#line 210
              goto while_break___8;
            }
#line 211
            if ((int const   )tun_table[fin[(int )oins[2] - 1]][l] == (int const   )per) {
#line 212
              pat___0[j][y + 8] = (uint8 )((int )pat___0[j][y + 8] & 240);
#line 213
              pat___0[j][y + 8] = (uint8 )((int )pat___0[j][y + 8] | (int )ptk_table[l + 1][0]);
#line 215
              pat___0[j][y + 9] = (uint8 )ptk_table[l + 1][1];
#line 217
              goto while_break___8;
            }
#line 210
            l ++;
          }
          while_break___8: /* CIL Label */ ;
          }
        }
      }
#line 221
      if (((int )pat___0[j][y + 10] & 15) == 13) {
#line 223
        FLAG = (uint8 )0;
      } else
#line 221
      if (((int )pat___0[j][y + 10] & 15) == 11) {
#line 223
        FLAG = (uint8 )0;
      }
      {
#line 228
      tmp___13 = read16b(in);
#line 228
      x___0 = (int )tmp___13 * 4;
#line 229
      k += 2;
#line 230
      pat___0[j][y + 12] = *(reftab + x___0);
#line 231
      pat___0[j][y + 13] = *(reftab + (x___0 + 1));
#line 232
      pat___0[j][y + 14] = *(reftab + (x___0 + 2));
#line 233
      pat___0[j][y + 15] = *(reftab + (x___0 + 3));
#line 234
      c3 = (uint8 )((((int )pat___0[j][y + 14] >> 4) & 15) | ((int )pat___0[j][y + 12] & 240));
      }
#line 235
      if ((int )c3 != 0) {
#line 236
        oins[3] = c3;
      }
#line 238
      per = (short )((((int )pat___0[j][y + 12] & 15) << 8) + (int )pat___0[j][y + 13]);
#line 239
      if ((int )per != 0) {
#line 239
        if ((int )fin[(int )oins[3] - 1] != 0) {
#line 241
          l = 0;
          {
#line 241
          while (1) {
            while_continue___9: /* CIL Label */ ;
#line 241
            if (! (l < 36)) {
#line 241
              goto while_break___9;
            }
#line 242
            if ((int const   )tun_table[fin[(int )oins[3] - 1]][l] == (int const   )per) {
#line 243
              pat___0[j][y + 12] = (uint8 )((int )pat___0[j][y + 12] & 240);
#line 244
              pat___0[j][y + 12] = (uint8 )((int )pat___0[j][y + 12] | (int )ptk_table[l + 1][0]);
#line 245
              pat___0[j][y + 13] = (uint8 )ptk_table[l + 1][1];
#line 246
              goto while_break___9;
            }
#line 241
            l ++;
          }
          while_break___9: /* CIL Label */ ;
          }
        }
      }
#line 250
      if (((int )pat___0[j][y + 14] & 15) == 13) {
#line 252
        FLAG = (uint8 )0;
      } else
#line 250
      if (((int )pat___0[j][y + 14] & 15) == 11) {
#line 252
        FLAG = (uint8 )0;
      }
#line 255
      if ((int )FLAG == 0) {
#line 256
        FLAG = (uint8 )1;
#line 257
        goto while_break___5;
      }
#line 130
      i___3 ++;
    }
    while_break___5: /* CIL Label */ ;
    }
    {
#line 260
    fwrite((void const   */* __restrict  */)(pat___0[j]), (size_t )1024, (size_t )1,
           (FILE */* __restrict  */)out);
#line 128
    j ++;
    }
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 265
  free((void *)reftab);
#line 267
  fseek(in, 4456L, 0);
#line 268
  tmp___14 = read32b(in);
#line 268
  SDAV = (int )tmp___14;
#line 269
  fseek(in, (long )(4460 + SDAV), 0);
#line 272
  pw_move_data(out, in, ssize);
  }
#line 274
  return (0);
}
}
#line 277 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/prowizard/pm18a.c"
static int test_p18a(uint8 *data , int s ) 
{ 
  int i___3 ;
  int j ;
  int k ;
  int start ;
  uint32 tmp ;
  uint16 tmp___0 ;

  {
#line 279
  i___3 = 0;
#line 280
  start = 0;
  {
#line 283
  while (1) {
    while_continue: /* CIL Label */ ;
#line 283
    if (s < 22) {
#line 283
      return (22 - s);
    }
#line 283
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 285
  if ((int )*(data + i___3) != 96) {
#line 293
    return (-1);
  } else
#line 285
  if ((int )*(data + (i___3 + 1)) != 56) {
#line 293
    return (-1);
  } else
#line 285
  if ((int )*(data + (i___3 + 2)) != 96) {
#line 293
    return (-1);
  } else
#line 285
  if ((int )*(data + (i___3 + 3)) != 0) {
#line 293
    return (-1);
  } else
#line 285
  if ((int )*(data + (i___3 + 4)) != 0) {
#line 293
    return (-1);
  } else
#line 285
  if ((int )*(data + (i___3 + 5)) != 160) {
#line 293
    return (-1);
  } else
#line 285
  if ((int )*(data + (i___3 + 6)) != 96) {
#line 293
    return (-1);
  } else
#line 285
  if ((int )*(data + (i___3 + 7)) != 0) {
#line 293
    return (-1);
  } else
#line 285
  if ((int )*(data + (i___3 + 8)) != 1) {
#line 293
    return (-1);
  } else
#line 285
  if ((int )*(data + (i___3 + 9)) != 62) {
#line 293
    return (-1);
  } else
#line 285
  if ((int )*(data + (i___3 + 10)) != 96) {
#line 293
    return (-1);
  } else
#line 285
  if ((int )*(data + (i___3 + 11)) != 0) {
#line 293
    return (-1);
  } else
#line 285
  if ((int )*(data + (i___3 + 12)) != 1) {
#line 293
    return (-1);
  } else
#line 285
  if ((int )*(data + (i___3 + 13)) != 12) {
#line 293
    return (-1);
  } else
#line 285
  if ((int )*(data + (i___3 + 14)) != 72) {
#line 293
    return (-1);
  } else
#line 285
  if ((int )*(data + (i___3 + 15)) != 231) {
#line 293
    return (-1);
  }
#line 296
  if ((int )*(data + (start + 21)) != 210) {
#line 297
    return (-1);
  }
  {
#line 300
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 300
    if (s < 4460) {
#line 300
      return (4460 - s);
    }
#line 300
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 301
  tmp = readmem32b((data + start) + 4456);
#line 301
  j = (int )tmp;
  }
  {
#line 311
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 311
    if (s < 4714) {
#line 311
      return (4714 - s);
    }
#line 311
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 312
  tmp___0 = readmem16b((data + start) + 4712);
#line 312
  k = (int )tmp___0;
  }
#line 313
  if (k & 3) {
#line 314
    return (-1);
  }
#line 317
  if ((int )*(data + (start + 36)) != 17) {
#line 318
    return (-1);
  }
#line 321
  if ((int )*(data + (start + 37)) != 0) {
#line 322
    return (-1);
  }
#line 324
  return (0);
}
}
#line 72 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/prowizard/prowiz.h"
struct pw_format pw_p10c ;
#line 14 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/prowizard/pm10c.c"
static int test_p10c(uint8 *data , int s ) ;
#line 15
static int depack_p10c(FILE *in , FILE *out ) ;
#line 17 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/prowizard/pm10c.c"
struct pw_format pw_p10c  =    {(char *)"P10C", (char *)"Promizer 1.0c", 0, & test_p10c, & depack_p10c, 0, {(struct list_head *)0,
                                                                                (struct list_head *)0}};
#line 28 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/prowizard/pm10c.c"
static int depack_p10c(FILE *in , FILE *out ) 
{ 
  uint8 c1 ;
  uint8 c2 ;
  uint8 c3 ;
  short pat_max ;
  long tmp_ptr ;
  long tmp1 ;
  long tmp2 ;
  short refmax ;
  uint8 pnum[128] ;
  uint8 pnum1[128] ;
  int paddr[128] ;
  int paddr1[128] ;
  int paddr2[128] ;
  short pptr[64][256] ;
  uint8 NOP ;
  uint8 *reftab ;
  uint8 pat___0[128][1024] ;
  int i___3 ;
  int j ;
  int k ;
  int l ;
  int size___0 ;
  int ssize ;
  int psize ;
  int SDAV ;
  uint8 FLAG ;
  uint8 fin[31] ;
  uint8 oldins[4] ;
  short per ;
  uint16 tmp ;
  uint8 tmp___0 ;
  uint8 tmp___1 ;
  uint16 tmp___2 ;
  uint16 tmp___3 ;
  uint16 tmp___4 ;
  uint32 tmp___5 ;
  long tmp___6 ;
  uint32 tmp___7 ;
  int x ;
  uint16 tmp___8 ;
  void *tmp___9 ;
  int x___0 ;
  int y ;
  uint16 tmp___10 ;
  uint16 tmp___11 ;
  uint16 tmp___12 ;
  uint16 tmp___13 ;
  uint32 tmp___14 ;
  void *__cil_tmp51 ;
  void *__cil_tmp52 ;
  void *__cil_tmp53 ;
  void *__cil_tmp54 ;
  void *__cil_tmp55 ;
  void *__cil_tmp56 ;
  int __cil_tmp57 ;
  void *__cil_tmp58 ;
  void *__cil_tmp59 ;
  int __cil_tmp60 ;
  void *__cil_tmp61 ;
  void *__cil_tmp62 ;
  void *__cil_tmp63 ;

  {
  {
#line 31
  pat_max = (short)0;
#line 33
  refmax = (short)0;
#line 40
  NOP = (uint8 )0;
#line 44
  ssize = 0;
#line 47
  FLAG = (uint8 )1;
#line 52
  memset((void *)(pnum), 0, (size_t )128);
#line 53
  memset((void *)(pnum1), 0, (size_t )128);
#line 54
  memset((void *)(pptr), 0, (size_t )(64 << 8));
#line 55
  memset((void *)(pat___0), 0, (size_t )131072);
#line 56
  memset((void *)(fin), 0, (size_t )31);
#line 57
  memset((void *)(oldins), 0, (size_t )4);
#line 58
  memset((void *)(paddr), 0, (size_t )512);
#line 59
  memset((void *)(paddr1), 0, (size_t )512);
#line 61
  i___3 = 0;
  }
  {
#line 61
  while (1) {
    while_continue: /* CIL Label */ ;
#line 61
    if (! (i___3 < 128)) {
#line 61
      goto while_break;
    }
#line 62
    paddr2[i___3] = 9999;
#line 61
    i___3 ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 64
  pw_write_zero(out, 20);
#line 67
  fseek(in, 4460L, 0);
#line 69
  i___3 = 0;
  }
  {
#line 69
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 69
    if (! (i___3 < 31)) {
#line 69
      goto while_break___0;
    }
    {
#line 70
    pw_write_zero(out, 22);
#line 71
    tmp = read16b(in);
#line 71
    size___0 = (int )tmp;
#line 71
    write16b(out, (uint16 )size___0);
#line 72
    ssize += size___0 * 2;
#line 73
    tmp___0 = read8(in);
#line 73
    fin[i___3] = tmp___0;
#line 73
    write8(out, tmp___0);
#line 74
    tmp___1 = read8(in);
#line 74
    write8(out, tmp___1);
#line 75
    tmp___2 = read16b(in);
#line 75
    write16b(out, tmp___2);
#line 76
    tmp___3 = read16b(in);
#line 76
    write16b(out, tmp___3);
#line 69
    i___3 ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 79
  tmp___4 = read16b(in);
#line 79
  NOP = (uint8 )((int )tmp___4 / 4);
#line 79
  write8(out, NOP);
#line 80
  write8(out, (uint8 )127);
#line 82
  i___3 = 0;
  }
  {
#line 82
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 82
    if (! (i___3 < 128)) {
#line 82
      goto while_break___1;
    }
    {
#line 83
    tmp___5 = read32b(in);
#line 83
    paddr[i___3] = (int )tmp___5;
#line 82
    i___3 ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 87
  tmp_ptr = 0L;
#line 88
  i___3 = 0;
  {
#line 88
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 88
    if (! (i___3 < (int )NOP)) {
#line 88
      goto while_break___2;
    }
#line 89
    if (i___3 == 0) {
#line 90
      pnum[0] = (uint8 )0;
#line 91
      tmp_ptr ++;
#line 92
      goto __Cont;
    }
#line 95
    j = 0;
    {
#line 95
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 95
      if (! (j < i___3)) {
#line 95
        goto while_break___3;
      }
#line 96
      if (paddr[i___3] == paddr[j]) {
#line 97
        pnum[i___3] = pnum[j];
#line 98
        goto while_break___3;
      }
#line 95
      j ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 101
    if (j == i___3) {
#line 102
      tmp___6 = tmp_ptr;
#line 102
      tmp_ptr ++;
#line 102
      pnum[i___3] = (uint8 )tmp___6;
    }
    __Cont: /* CIL Label */ 
#line 88
    i___3 ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 105
  pat_max = (short )(tmp_ptr - 1L);
#line 108
  i___3 = 0;
  {
#line 108
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 108
    if (! (i___3 < (int )NOP)) {
#line 108
      goto while_break___4;
    }
#line 109
    paddr1[i___3] = paddr[i___3];
#line 108
    i___3 ++;
  }
  while_break___4: /* CIL Label */ ;
  }
  restart: 
#line 112
  i___3 = 0;
  {
#line 112
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 112
    if (! (i___3 < (int )NOP)) {
#line 112
      goto while_break___5;
    }
#line 113
    j = 0;
    {
#line 113
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 113
      if (! (j < i___3)) {
#line 113
        goto while_break___6;
      }
#line 114
      if (paddr1[i___3] < paddr1[j]) {
#line 115
        tmp2 = (long )pnum[j];
#line 116
        pnum[j] = pnum[i___3];
#line 117
        pnum[i___3] = (uint8 )tmp2;
#line 118
        tmp1 = (long )paddr1[j];
#line 119
        paddr1[j] = paddr1[i___3];
#line 120
        paddr1[i___3] = (int )tmp1;
#line 121
        goto restart;
      }
#line 113
      j ++;
    }
    while_break___6: /* CIL Label */ ;
    }
#line 112
    i___3 ++;
  }
  while_break___5: /* CIL Label */ ;
  }
#line 126
  i___3 = 0;
#line 126
  j = i___3;
  {
#line 126
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 126
    if (! (i___3 < (int )NOP)) {
#line 126
      goto while_break___7;
    }
#line 127
    if (i___3 == 0) {
#line 128
      paddr2[j] = paddr1[i___3];
#line 129
      goto __Cont___0;
    }
#line 132
    if (paddr1[i___3] == paddr2[j]) {
#line 133
      goto __Cont___0;
    }
#line 134
    j ++;
#line 134
    paddr2[j] = paddr1[i___3];
    __Cont___0: /* CIL Label */ 
#line 126
    i___3 ++;
  }
  while_break___7: /* CIL Label */ ;
  }
#line 137
  c1 = (uint8 )0;
  {
#line 137
  while (1) {
    while_continue___8: /* CIL Label */ ;
#line 137
    if (! ((int )c1 < (int )NOP)) {
#line 137
      goto while_break___8;
    }
#line 138
    c2 = (uint8 )0;
    {
#line 138
    while (1) {
      while_continue___9: /* CIL Label */ ;
#line 138
      if (! ((int )c2 < (int )NOP)) {
#line 138
        goto while_break___9;
      }
#line 139
      if (paddr[c1] == paddr2[c2]) {
#line 140
        pnum1[c1] = c2;
      }
#line 138
      c2 = (uint8 )((int )c2 + 1);
    }
    while_break___9: /* CIL Label */ ;
    }
#line 137
    c1 = (uint8 )((int )c1 + 1);
  }
  while_break___8: /* CIL Label */ ;
  }
#line 144
  i___3 = 0;
  {
#line 144
  while (1) {
    while_continue___10: /* CIL Label */ ;
#line 144
    if (! (i___3 < (int )NOP)) {
#line 144
      goto while_break___10;
    }
#line 145
    pnum[i___3] = pnum1[i___3];
#line 144
    i___3 ++;
  }
  while_break___10: /* CIL Label */ ;
  }
#line 148
  c1 = (uint8 )0;
  {
#line 148
  while (1) {
    while_continue___11: /* CIL Label */ ;
#line 148
    if (! ((int )c1 < 128)) {
#line 148
      goto while_break___11;
    }
    {
#line 149
    fwrite((void const   */* __restrict  */)(& pnum[c1]), (size_t )1, (size_t )1,
           (FILE */* __restrict  */)out);
#line 148
    c1 = (uint8 )((int )c1 + 1);
    }
  }
  while_break___11: /* CIL Label */ ;
  }
  {
#line 151
  write32b(out, (((77U << 24) | (46U << 16)) | (75U << 8)) | 46U);
#line 156
  fseek(in, 4456L, 0);
#line 157
  tmp___7 = read32b(in);
#line 157
  psize = (int )tmp___7;
#line 160
  fseek(in, 5222L, 0);
#line 162
  j = 0;
  }
  {
#line 162
  while (1) {
    while_continue___12: /* CIL Label */ ;
#line 162
    if (! (j < psize)) {
#line 162
      goto while_break___12;
    }
    {
#line 164
    tmp___8 = read16b(in);
#line 164
    x = (int )tmp___8;
    }
#line 164
    if (x > (int )refmax) {
#line 165
      refmax = (short )x;
    }
#line 162
    j += 2;
  }
  while_break___12: /* CIL Label */ ;
  }
  {
#line 169
  refmax = (short )((int )refmax + 1);
#line 170
  i___3 = (int )refmax * 4;
#line 171
  tmp___9 = malloc((size_t )i___3);
#line 171
  reftab = (uint8 *)tmp___9;
#line 172
  fread((void */* __restrict  */)reftab, (size_t )i___3, (size_t )1, (FILE */* __restrict  */)in);
#line 175
  fseek(in, 5222L, 0);
#line 177
  j = 0;
#line 177
  k = j;
  }
  {
#line 177
  while (1) {
    while_continue___13: /* CIL Label */ ;
#line 177
    if (! (j <= (int )pat_max)) {
#line 177
      goto while_break___13;
    }
#line 178
    i___3 = 0;
    {
#line 178
    while (1) {
      while_continue___14: /* CIL Label */ ;
#line 178
      if (! (i___3 < 64)) {
#line 178
        goto while_break___14;
      }
      {
#line 179
      y = i___3 * 16;
#line 183
      tmp___10 = read16b(in);
#line 183
      x___0 = (int )tmp___10;
#line 184
      k += 2;
#line 185
      pat___0[j][y] = *(reftab + x___0 * 4);
#line 186
      pat___0[j][y + 1] = *(reftab + (x___0 * 4 + 1));
#line 187
      pat___0[j][y + 2] = *(reftab + (x___0 * 4 + 2));
#line 188
      pat___0[j][y + 3] = *(reftab + (x___0 * 4 + 3));
#line 190
      c3 = (uint8 )((((int )pat___0[j][y + 2] >> 4) & 15) | ((int )pat___0[j][y] & 240));
      }
#line 192
      if ((int )c3 != 0) {
#line 193
        oldins[0] = c3;
      }
#line 195
      per = (short )((((int )pat___0[j][y] & 15) << 8) + (int )pat___0[j][y + 1]);
#line 197
      if ((int )per != 0) {
#line 197
        if ((int )fin[(int )oldins[0] - 1] != 0) {
#line 198
          l = 0;
          {
#line 198
          while (1) {
            while_continue___15: /* CIL Label */ ;
#line 198
            if (! (l < 36)) {
#line 198
              goto while_break___15;
            }
#line 199
            if ((int const   )tun_table[fin[(int )oldins[0] - 1]][l] == (int const   )per) {
#line 201
              pat___0[j][y] = (uint8 )((int )pat___0[j][y] & 240);
#line 202
              pat___0[j][y] = (uint8 )((int )pat___0[j][y] | (int )ptk_table[l + 1][0]);
#line 204
              pat___0[j][y + 1] = (uint8 )ptk_table[l + 1][1];
#line 206
              goto while_break___15;
            }
#line 198
            l ++;
          }
          while_break___15: /* CIL Label */ ;
          }
        }
      }
#line 211
      if (((int )pat___0[j][y + 2] & 15) == 13) {
#line 213
        FLAG = (uint8 )0;
      } else
#line 211
      if (((int )pat___0[j][y + 2] & 15) == 11) {
#line 213
        FLAG = (uint8 )0;
      }
      {
#line 218
      tmp___11 = read16b(in);
#line 218
      x___0 = (int )tmp___11;
#line 219
      k += 2;
#line 220
      pat___0[j][y + 4] = *(reftab + x___0 * 4);
#line 221
      pat___0[j][y + 5] = *(reftab + (x___0 * 4 + 1));
#line 222
      pat___0[j][y + 6] = *(reftab + (x___0 * 4 + 2));
#line 223
      pat___0[j][y + 7] = *(reftab + (x___0 * 4 + 3));
#line 225
      c3 = (uint8 )((((int )pat___0[j][y + 6] >> 4) & 15) | ((int )pat___0[j][y + 4] & 240));
      }
#line 228
      if ((int )c3 != 0) {
#line 229
        oldins[1] = c3;
      }
#line 231
      per = (short )((((int )pat___0[j][y + 4] & 15) << 8) + (int )pat___0[j][y + 5]);
#line 233
      if ((int )per != 0) {
#line 233
        if ((int )fin[(int )oldins[1] - 1] != 0) {
#line 234
          l = 0;
          {
#line 234
          while (1) {
            while_continue___16: /* CIL Label */ ;
#line 234
            if (! (l < 36)) {
#line 234
              goto while_break___16;
            }
#line 235
            if ((int const   )tun_table[fin[(int )oldins[1] - 1]][l] == (int const   )per) {
#line 237
              pat___0[j][y + 4] = (uint8 )((int )pat___0[j][y + 4] & 240);
#line 238
              pat___0[j][y + 4] = (uint8 )((int )pat___0[j][y + 4] | (int )ptk_table[l + 1][0]);
#line 240
              pat___0[j][y + 5] = (uint8 )ptk_table[l + 1][1];
#line 242
              goto while_break___16;
            }
#line 234
            l ++;
          }
          while_break___16: /* CIL Label */ ;
          }
        }
      }
#line 247
      if (((int )pat___0[j][y + 6] & 15) == 13) {
#line 249
        FLAG = (uint8 )0;
      } else
#line 247
      if (((int )pat___0[j][y + 6] & 15) == 11) {
#line 249
        FLAG = (uint8 )0;
      }
      {
#line 254
      tmp___12 = read16b(in);
#line 254
      x___0 = (int )tmp___12;
#line 255
      k += 2;
#line 256
      pat___0[j][y + 8] = *(reftab + x___0 * 4);
#line 257
      pat___0[j][y + 9] = *(reftab + (x___0 * 4 + 1));
#line 258
      pat___0[j][y + 10] = *(reftab + (x___0 * 4 + 2));
#line 259
      pat___0[j][y + 11] = *(reftab + (x___0 * 4 + 3));
#line 261
      c3 = (uint8 )((((int )pat___0[j][y + 10] >> 4) & 15) | ((int )pat___0[j][y + 8] & 240));
      }
#line 264
      if ((int )c3 != 0) {
#line 265
        oldins[2] = c3;
      }
#line 267
      per = (short )((((int )pat___0[j][y + 8] & 15) << 8) + (int )pat___0[j][y + 9]);
#line 269
      if ((int )per != 0) {
#line 269
        if ((int )fin[(int )oldins[2] - 1] != 0) {
#line 270
          l = 0;
          {
#line 270
          while (1) {
            while_continue___17: /* CIL Label */ ;
#line 270
            if (! (l < 36)) {
#line 270
              goto while_break___17;
            }
#line 271
            if ((int const   )tun_table[fin[(int )oldins[2] - 1]][l] == (int const   )per) {
#line 273
              pat___0[j][y + 8] = (uint8 )((int )pat___0[j][y + 8] & 240);
#line 274
              pat___0[j][y + 8] = (uint8 )((int )pat___0[j][y + 8] | (int )ptk_table[l + 1][0]);
#line 276
              pat___0[j][y + 9] = (uint8 )ptk_table[l + 1][1];
#line 278
              goto while_break___17;
            }
#line 270
            l ++;
          }
          while_break___17: /* CIL Label */ ;
          }
        }
      }
#line 283
      if (((int )pat___0[j][y + 10] & 15) == 13) {
#line 285
        FLAG = (uint8 )0;
      } else
#line 283
      if (((int )pat___0[j][y + 10] & 15) == 11) {
#line 285
        FLAG = (uint8 )0;
      }
      {
#line 290
      tmp___13 = read16b(in);
#line 290
      x___0 = (int )tmp___13;
#line 291
      k += 2;
#line 292
      pat___0[j][y + 12] = *(reftab + x___0 * 4);
#line 293
      pat___0[j][y + 13] = *(reftab + (x___0 * 4 + 1));
#line 294
      pat___0[j][y + 14] = *(reftab + (x___0 * 4 + 2));
#line 295
      pat___0[j][y + 15] = *(reftab + (x___0 * 4 + 3));
#line 297
      c3 = (uint8 )((((int )pat___0[j][y + 14] >> 4) & 15) | ((int )pat___0[j][y + 12] & 240));
      }
#line 300
      if ((int )c3 != 0) {
#line 301
        oldins[3] = c3;
      }
#line 303
      per = (short )((((int )pat___0[j][y + 12] & 15) << 8) + (int )pat___0[j][y + 13]);
#line 305
      if ((int )per != 0) {
#line 305
        if ((int )fin[(int )oldins[3] - 1] != 0) {
#line 306
          l = 0;
          {
#line 306
          while (1) {
            while_continue___18: /* CIL Label */ ;
#line 306
            if (! (l < 36)) {
#line 306
              goto while_break___18;
            }
#line 307
            if ((int const   )tun_table[fin[(int )oldins[3] - 1]][l] == (int const   )per) {
#line 309
              pat___0[j][y + 12] = (uint8 )((int )pat___0[j][y + 12] & 240);
#line 310
              pat___0[j][y + 12] = (uint8 )((int )pat___0[j][y + 12] | (int )ptk_table[l + 1][0]);
#line 312
              pat___0[j][y + 13] = (uint8 )ptk_table[l + 1][1];
#line 314
              goto while_break___18;
            }
#line 306
            l ++;
          }
          while_break___18: /* CIL Label */ ;
          }
        }
      }
#line 318
      if (((int )pat___0[j][y + 14] & 15) == 13) {
#line 320
        FLAG = (uint8 )0;
      } else
#line 318
      if (((int )pat___0[j][y + 14] & 15) == 11) {
#line 320
        FLAG = (uint8 )0;
      }
#line 323
      if ((int )FLAG == 0) {
#line 324
        FLAG = (uint8 )1;
#line 325
        goto while_break___14;
      }
#line 178
      i___3 ++;
    }
    while_break___14: /* CIL Label */ ;
    }
    {
#line 328
    fwrite((void const   */* __restrict  */)(pat___0[j]), (size_t )1024, (size_t )1,
           (FILE */* __restrict  */)out);
#line 177
    j ++;
    }
  }
  while_break___13: /* CIL Label */ ;
  }
  {
#line 331
  free((void *)reftab);
#line 333
  fseek(in, 4452L, 0);
#line 334
  tmp___14 = read32b(in);
#line 334
  SDAV = (int )tmp___14;
#line 335
  fseek(in, (long )(4456 + SDAV), 0);
#line 337
  pw_move_data(out, in, ssize);
  }
#line 339
  return (0);
}
}
#line 342 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/prowizard/pm10c.c"
static int test_p10c(uint8 *data , int s ) 
{ 
  int i___3 ;
  int j ;
  int k ;
  int l ;
  int start ;

  {
#line 344
  i___3 = 0;
#line 345
  start = 0;
  {
#line 348
  while (1) {
    while_continue: /* CIL Label */ ;
#line 348
    if (s < 22) {
#line 348
      return (22 - s);
    }
#line 348
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 350
  if ((int )*(data + i___3) != 96) {
#line 358
    return (-1);
  } else
#line 350
  if ((int )*(data + (i___3 + 1)) != 56) {
#line 358
    return (-1);
  } else
#line 350
  if ((int )*(data + (i___3 + 2)) != 96) {
#line 358
    return (-1);
  } else
#line 350
  if ((int )*(data + (i___3 + 3)) != 0) {
#line 358
    return (-1);
  } else
#line 350
  if ((int )*(data + (i___3 + 4)) != 0) {
#line 358
    return (-1);
  } else
#line 350
  if ((int )*(data + (i___3 + 5)) != 160) {
#line 358
    return (-1);
  } else
#line 350
  if ((int )*(data + (i___3 + 6)) != 96) {
#line 358
    return (-1);
  } else
#line 350
  if ((int )*(data + (i___3 + 7)) != 0) {
#line 358
    return (-1);
  } else
#line 350
  if ((int )*(data + (i___3 + 8)) != 1) {
#line 358
    return (-1);
  } else
#line 350
  if ((int )*(data + (i___3 + 9)) != 62) {
#line 358
    return (-1);
  } else
#line 350
  if ((int )*(data + (i___3 + 10)) != 96) {
#line 358
    return (-1);
  } else
#line 350
  if ((int )*(data + (i___3 + 11)) != 0) {
#line 358
    return (-1);
  } else
#line 350
  if ((int )*(data + (i___3 + 12)) != 1) {
#line 358
    return (-1);
  } else
#line 350
  if ((int )*(data + (i___3 + 13)) != 12) {
#line 358
    return (-1);
  } else
#line 350
  if ((int )*(data + (i___3 + 14)) != 72) {
#line 358
    return (-1);
  } else
#line 350
  if ((int )*(data + (i___3 + 15)) != 231) {
#line 358
    return (-1);
  }
#line 361
  if ((int )*(data + (start + 21)) != 206) {
#line 362
    return (-1);
  }
  {
#line 364
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 364
    if (s < 4714) {
#line 364
      return (4714 - s);
    }
#line 364
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 367
  j = ((((int )*(data + (start + 4452)) << 24) + ((int )*(data + (start + 4453)) << 16)) + ((int )*(data + (start + 4454)) << 8)) + (int )*(data + (start + 4455));
#line 376
  k = ((int )*(data + (start + 4712)) << 8) + (int )*(data + (start + 4713));
#line 377
  l = k / 4;
#line 378
  l *= 4;
#line 379
  if (l != k) {
#line 380
    return (-1);
  }
#line 383
  if ((int )*(data + (start + 36)) != 16) {
#line 384
    return (-1);
  }
#line 387
  if ((int )*(data + (start + 37)) != 252) {
#line 388
    return (-1);
  }
#line 390
  return (0);
}
}
#line 77 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/prowizard/prowiz.h"
struct pw_format pw_p60a ;
#line 19 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/prowizard/p60a.c"
static int test_p60a(uint8 *data , int s ) ;
#line 20
static int depack_p60a(FILE *in , FILE *out ) ;
#line 22 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/prowizard/p60a.c"
struct pw_format pw_p60a  =    {(char *)"P60A", (char *)"The Player 6.0a", 0, & test_p60a, & depack_p60a, 0, {(struct list_head *)0,
                                                                                  (struct list_head *)0}};
#line 33 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/prowizard/p60a.c"
static int depack_p60a(FILE *in , FILE *out ) 
{ 
  uint8 c1 ;
  uint8 c2 ;
  uint8 c3 ;
  uint8 c4 ;
  uint8 c5 ;
  uint8 c6 ;
  int max_row ;
  signed char *insDataWork ;
  uint8 PatPos ;
  uint8 npat ;
  uint8 nins ;
  uint8 tdata[512][256] ;
  uint8 ptable[128] ;
  int isize[31] ;
  uint8 PACK[31] ;
  uint8 GLOBAL_DELTA ;
  uint8 GLOBAL_PACK ;
  int taddr[128][4] ;
  int tdata_addr ;
  int sdata_addr ;
  int ssize ;
  int i___3 ;
  int j ;
  int k ;
  int l ;
  int a ;
  int b___1 ;
  int smp_size[31] ;
  int saddr[32] ;
  int unpacked_ssize ;
  int val ;
  uint8 buf___1[1024] ;
  uint16 tmp ;
  uint32 tmp___0 ;
  int tmp___1 ;
  uint16 tmp___2 ;
  uint8 tmp___3 ;
  uint16 tmp___4 ;
  uint16 tmp___5 ;
  long tmp___6 ;
  uint8 *x ;
  uint8 *tmp___7 ;
  uint8 *tmp___8 ;
  uint8 *tmp___9 ;
  uint8 *tmp___10 ;
  uint8 *tmp___11 ;
  uint8 *tmp___12 ;
  uint8 *tmp___13 ;
  uint8 *tmp___14 ;
  long tmp___15 ;
  uint8 *tmp___16 ;
  uint8 *tmp___17 ;
  uint8 *tmp___18 ;
  uint8 *tmp___19 ;
  uint8 *tmp___20 ;
  uint8 *tmp___21 ;
  uint8 *tmp___22 ;
  uint8 *tmp___23 ;
  uint8 *tmp___24 ;
  uint8 *tmp___25 ;
  uint8 *tmp___26 ;
  uint8 *tmp___27 ;
  uint8 *tmp___28 ;
  uint8 *tmp___29 ;
  uint8 *tmp___30 ;
  uint8 *tmp___31 ;
  void *tmp___32 ;
  void *__cil_tmp70 ;
  int __cil_tmp71 ;
  void *__cil_tmp72 ;
  void *__cil_tmp73 ;
  void *__cil_tmp74 ;
  void *__cil_tmp75 ;
  void *__cil_tmp76 ;
  int __cil_tmp77 ;
  void *__cil_tmp78 ;
  void *__cil_tmp79 ;
  void *__cil_tmp80 ;
  void *__cil_tmp81 ;

  {
  {
#line 38
  PatPos = (uint8 )0;
#line 39
  npat = (uint8 )0;
#line 40
  nins = (uint8 )0;
#line 46
  GLOBAL_DELTA = (uint8 )2;
#line 47
  GLOBAL_PACK = (uint8 )2;
#line 49
  tdata_addr = 0;
#line 50
  sdata_addr = 0;
#line 51
  ssize = 0;
#line 52
  i___3 = 0;
#line 59
  memset((void *)(taddr), 0, (size_t )2048);
#line 60
  memset((void *)(tdata), 0, (size_t )(512 << 8));
#line 61
  memset((void *)(ptable), 0, (size_t )128);
#line 62
  memset((void *)(smp_size), 0, (size_t )124);
#line 63
  memset((void *)(saddr), 0, (size_t )128);
#line 64
  memset((void *)(isize), 0, (size_t )(31UL * sizeof(int )));
#line 65
  i___3 = 0;
  }
  {
#line 65
  while (1) {
    while_continue: /* CIL Label */ ;
#line 65
    if (! (i___3 < 31)) {
#line 65
      goto while_break;
    }
#line 66
    PACK[i___3] = (uint8 )2;
#line 65
    i___3 ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 70
  tmp = read16b(in);
#line 70
  sdata_addr = (int )tmp;
#line 71
  npat = read8(in);
#line 72
  nins = read8(in);
  }
#line 74
  if (((int )nins & 128) == 128) {
#line 76
    GLOBAL_DELTA = (uint8 )1;
  }
#line 78
  if (((int )nins & 64) == 64) {
#line 82
    GLOBAL_PACK = (uint8 )1;
#line 84
    return (-1);
  }
#line 87
  nins = (uint8 )((int )nins & 63);
#line 89
  if ((int )GLOBAL_PACK == 1) {
    {
#line 90
    tmp___0 = read32b(in);
#line 90
    unpacked_ssize = (int )tmp___0;
    }
  }
  {
#line 92
  pw_write_zero(out, 20);
#line 95
  i___3 = 0;
  }
  {
#line 95
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 95
    if (! (i___3 < (int )nins)) {
#line 95
      goto while_break___0;
    }
    {
#line 96
    pw_write_zero(out, 22);
#line 98
    tmp___2 = read16b(in);
#line 98
    tmp___1 = (int )tmp___2;
#line 98
    isize[i___3] = tmp___1;
#line 98
    j = tmp___1;
    }
#line 100
    if (j > 65280) {
#line 101
      smp_size[i___3] = smp_size[65535 - j];
#line 102
      isize[i___3] = isize[65535 - j];
#line 103
      saddr[i___3 + 1] = saddr[(65535 - j) + 1];
    } else {
#line 105
      saddr[i___3 + 1] = saddr[i___3] + smp_size[i___3 - 1];
#line 106
      smp_size[i___3] = j * 2;
#line 107
      ssize += smp_size[i___3];
    }
    {
#line 109
    j = smp_size[i___3] / 2;
#line 111
    write16b(out, (uint16 )isize[i___3]);
#line 113
    c1 = read8(in);
    }
#line 114
    if (((int )c1 & 64) == 64) {
#line 115
      PACK[i___3] = (uint8 )1;
    }
    {
#line 116
    write8(out, (uint8 )((int )c1 & 63));
#line 118
    tmp___3 = read8(in);
#line 118
    write8(out, tmp___3);
#line 119
    tmp___4 = read16b(in);
#line 119
    val = (int )tmp___4;
    }
#line 121
    if (val == 65535) {
      {
#line 122
      write16b(out, (uint16 )0);
#line 123
      write16b(out, (uint16 )1);
      }
    } else {
      {
#line 125
      write16b(out, (uint16 )val);
#line 126
      write16b(out, (uint16 )(j - val));
      }
    }
#line 95
    i___3 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 131
  memset((void *)(buf___1), 0, (size_t )30);
#line 132
  buf___1[29] = (uint8 )1;
  }
  {
#line 133
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 133
    if (! (i___3 < 31)) {
#line 133
      goto while_break___1;
    }
    {
#line 134
    fwrite((void const   */* __restrict  */)(buf___1), (size_t )30, (size_t )1, (FILE */* __restrict  */)out);
#line 133
    i___3 ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 137
  i___3 = 0;
  {
#line 137
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 137
    if (! (i___3 < (int )npat)) {
#line 137
      goto while_break___2;
    }
#line 138
    j = 0;
    {
#line 138
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 138
      if (! (j < 4)) {
#line 138
        goto while_break___3;
      }
      {
#line 139
      tmp___5 = read16b(in);
#line 139
      taddr[i___3][j] = (int )tmp___5;
#line 138
      j ++;
      }
    }
    while_break___3: /* CIL Label */ ;
    }
#line 137
    i___3 ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 143
  PatPos = (uint8 )0;
  {
#line 143
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 143
    if (! ((int )PatPos < 128)) {
#line 143
      goto while_break___4;
    }
    {
#line 144
    c1 = read8(in);
    }
#line 145
    if ((int )c1 == 255) {
#line 146
      goto while_break___4;
    }
#line 147
    ptable[PatPos] = c1;
#line 143
    PatPos = (uint8 )((int )PatPos + 1);
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 149
  write8(out, PatPos);
#line 150
  write8(out, (uint8 )127);
#line 151
  fwrite((void const   */* __restrict  */)(ptable), (size_t )128, (size_t )1, (FILE */* __restrict  */)out);
#line 152
  write32b(out, (((77U << 24) | (46U << 16)) | (75U << 8)) | 46U);
#line 154
  tmp___6 = ftell(in);
#line 154
  tdata_addr = (int )tmp___6;
#line 158
  i___3 = 0;
  }
  {
#line 158
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 158
    if (! (i___3 < (int )npat)) {
#line 158
      goto while_break___5;
    }
#line 159
    max_row = 63;
#line 160
    j = 0;
    {
#line 160
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 160
      if (! (j < 4)) {
#line 160
        goto while_break___6;
      }
      {
#line 161
      fseek(in, (long )(taddr[i___3][j] + tdata_addr), 0);
#line 162
      k = 0;
      }
      {
#line 162
      while (1) {
        while_continue___7: /* CIL Label */ ;
#line 162
        if (! (k <= max_row)) {
#line 162
          goto while_break___7;
        }
        {
#line 163
        x = & tdata[i___3 * 4 + j][k * 4];
#line 164
        c1 = read8(in);
#line 165
        c2 = read8(in);
#line 166
        c3 = read8(in);
        }
#line 168
        if (((int )c1 & 128) == 128) {
#line 168
          if ((int )c1 != 128) {
            {
#line 169
            c4 = read8(in);
#line 170
            c1 = (uint8 )(255 - (int )c1);
#line 172
            tmp___7 = x;
#line 172
            x ++;
#line 172
            *tmp___7 = (uint8 )((((int )c1 << 4) & 16) | (int )ptk_table[(int )c1 / 2][0]);
#line 173
            tmp___8 = x;
#line 173
            x ++;
#line 173
            *tmp___8 = (uint8 )ptk_table[(int )c1 / 2][1];
#line 175
            c6 = (uint8 )((int )c2 & 15);
            }
#line 176
            if ((int )c6 == 8) {
#line 177
              c2 = (uint8 )((int )c2 - 8);
            }
#line 179
            tmp___9 = x;
#line 179
            x ++;
#line 179
            *tmp___9 = c2;
#line 181
            if ((int )c6 == 5) {
#line 181
              goto _L;
            } else
#line 181
            if ((int )c6 == 6) {
#line 181
              goto _L;
            } else
#line 181
            if ((int )c6 == 10) {
              _L: /* CIL Label */ 
#line 182
              if ((int )c3 > 127) {
#line 182
                c3 = (uint8 )((256 - (int )c3) << 4);
              } else {
#line 182
                c3 = c3;
              }
            }
#line 184
            tmp___10 = x;
#line 184
            x ++;
#line 184
            *tmp___10 = c3;
#line 186
            if ((int )c6 == 13) {
#line 187
              max_row = k;
#line 188
              k = 9999;
#line 189
              goto __Cont;
            }
#line 191
            if ((int )c6 == 11) {
#line 192
              max_row = k;
#line 193
              k = 9999;
#line 194
              goto __Cont;
            }
#line 196
            if ((int )c4 < 128) {
#line 197
              k += (int )c4;
#line 198
              goto __Cont;
            }
#line 200
            c4 = (uint8 )(256 - (int )c4);
#line 202
            l = 0;
            {
#line 202
            while (1) {
              while_continue___8: /* CIL Label */ ;
#line 202
              if (! (l < (int )c4)) {
#line 202
                goto while_break___8;
              }
#line 203
              k ++;
#line 204
              x = & tdata[i___3 * 4 + j][k * 4];
#line 206
              tmp___11 = x;
#line 206
              x ++;
#line 206
              *tmp___11 = (uint8 )((((int )c1 << 4) & 16) | (int )ptk_table[(int )c1 / 2][0]);
#line 207
              tmp___12 = x;
#line 207
              x ++;
#line 207
              *tmp___12 = (uint8 )ptk_table[(int )c1 / 2][1];
#line 209
              c6 = (uint8 )((int )c2 & 15);
#line 210
              if ((int )c6 == 8) {
#line 211
                c2 = (uint8 )((int )c2 - 8);
              }
#line 213
              tmp___13 = x;
#line 213
              x ++;
#line 213
              *tmp___13 = c2;
#line 215
              if ((int )c6 == 5) {
#line 215
                goto _L___0;
              } else
#line 215
              if ((int )c6 == 6) {
#line 215
                goto _L___0;
              } else
#line 215
              if ((int )c6 == 10) {
                _L___0: /* CIL Label */ 
#line 216
                if ((int )c3 > 127) {
#line 216
                  c3 = (uint8 )((256 - (int )c3) << 4);
                } else {
#line 216
                  c3 = c3;
                }
              }
#line 218
              tmp___14 = x;
#line 218
              x ++;
#line 218
              *tmp___14 = c3;
#line 202
              l ++;
            }
            while_break___8: /* CIL Label */ ;
            }
#line 220
            goto __Cont;
          }
        }
#line 223
        if ((int )c1 == 128) {
          {
#line 224
          c4 = read8(in);
#line 225
          tmp___15 = ftell(in);
#line 225
          a = (int )tmp___15;
#line 226
          c5 = c2;
#line 227
          fseek(in, (long )(- (((int )c3 << 8) + (int )c4)), 1);
#line 228
          l = 0;
          }
          {
#line 228
          while (1) {
            while_continue___9: /* CIL Label */ ;
#line 228
            if (! (l <= (int )c5)) {
#line 228
              goto while_break___9;
            }
            {
#line 229
            x = & tdata[i___3 * 4 + j][k * 4];
#line 231
            c1 = read8(in);
#line 232
            c2 = read8(in);
#line 233
            c3 = read8(in);
            }
#line 235
            if (((int )c1 & 128) == 128) {
#line 235
              if ((int )c1 != 128) {
                {
#line 236
                c4 = read8(in);
#line 237
                c1 = (uint8 )(255 - (int )c1);
#line 238
                tmp___16 = x;
#line 238
                x ++;
#line 238
                *tmp___16 = (uint8 )((((int )c1 << 4) & 16) | (int )ptk_table[(int )c1 / 2][0]);
#line 239
                tmp___17 = x;
#line 239
                x ++;
#line 239
                *tmp___17 = (uint8 )ptk_table[(int )c1 / 2][1];
#line 241
                c6 = (uint8 )((int )c2 & 15);
                }
#line 242
                if ((int )c6 == 8) {
#line 243
                  c2 = (uint8 )((int )c2 - 8);
                }
#line 245
                tmp___18 = x;
#line 245
                x ++;
#line 245
                *tmp___18 = c2;
#line 247
                if ((int )c6 == 5) {
#line 247
                  goto _L___1;
                } else
#line 247
                if ((int )c6 == 6) {
#line 247
                  goto _L___1;
                } else
#line 247
                if ((int )c6 == 10) {
                  _L___1: /* CIL Label */ 
#line 248
                  if ((int )c3 > 127) {
#line 248
                    c3 = (uint8 )((256 - (int )c3) << 4);
                  } else {
#line 248
                    c3 = c3;
                  }
                }
#line 250
                tmp___19 = x;
#line 250
                x ++;
#line 250
                *tmp___19 = c3;
#line 252
                if ((int )c6 == 13) {
#line 253
                  max_row = k;
#line 254
                  l = 9999;
#line 254
                  k = l;
#line 255
                  goto __Cont___0;
                }
#line 257
                if ((int )c6 == 11) {
#line 258
                  max_row = k;
#line 259
                  l = 9999;
#line 259
                  k = l;
#line 260
                  goto __Cont___0;
                }
#line 262
                if ((int )c4 < 128) {
#line 263
                  k += (int )c4;
#line 264
                  goto __Cont___0;
                }
#line 266
                c4 = (uint8 )(256 - (int )c4);
#line 268
                b___1 = 0;
                {
#line 268
                while (1) {
                  while_continue___10: /* CIL Label */ ;
#line 268
                  if (! (b___1 < (int )c4)) {
#line 268
                    goto while_break___10;
                  }
#line 269
                  k ++;
#line 270
                  x = & tdata[i___3 * 4 + j][k * 4];
#line 272
                  tmp___20 = x;
#line 272
                  x ++;
#line 272
                  *tmp___20 = (uint8 )((((int )c1 << 4) & 16) | (int )ptk_table[(int )c1 / 2][0]);
#line 274
                  tmp___21 = x;
#line 274
                  x ++;
#line 274
                  *tmp___21 = (uint8 )ptk_table[(int )c1 / 2][1];
#line 276
                  c6 = (uint8 )((int )c2 & 15);
#line 277
                  if ((int )c6 == 8) {
#line 278
                    c2 = (uint8 )((int )c2 - 8);
                  }
#line 280
                  tmp___22 = x;
#line 280
                  x ++;
#line 280
                  *tmp___22 = c2;
#line 282
                  if ((int )c6 == 5) {
#line 282
                    goto _L___2;
                  } else
#line 282
                  if ((int )c6 == 6) {
#line 282
                    goto _L___2;
                  } else
#line 282
                  if ((int )c6 == 10) {
                    _L___2: /* CIL Label */ 
#line 283
                    if ((int )c3 > 127) {
#line 283
                      c3 = (uint8 )((256 - (int )c3) << 4);
                    } else {
#line 283
                      c3 = c3;
                    }
                  }
#line 284
                  tmp___23 = x;
#line 284
                  x ++;
#line 284
                  *tmp___23 = c3;
#line 268
                  b___1 ++;
                }
                while_break___10: /* CIL Label */ ;
                }
              }
            }
#line 288
            x = & tdata[i___3 * 4 + j][k * 4];
#line 290
            tmp___24 = x;
#line 290
            x ++;
#line 290
            *tmp___24 = (uint8 )((((int )c1 << 4) & 16) | (int )ptk_table[(int )c1 / 2][0]);
#line 291
            tmp___25 = x;
#line 291
            x ++;
#line 291
            *tmp___25 = (uint8 )ptk_table[(int )c1 / 2][1];
#line 293
            c6 = (uint8 )((int )c2 & 15);
#line 294
            if ((int )c6 == 8) {
#line 295
              c2 = (uint8 )((int )c2 - 8);
            }
#line 297
            tmp___26 = x;
#line 297
            x ++;
#line 297
            *tmp___26 = c2;
#line 299
            if ((int )c6 == 5) {
#line 299
              goto _L___3;
            } else
#line 299
            if ((int )c6 == 6) {
#line 299
              goto _L___3;
            } else
#line 299
            if ((int )c6 == 10) {
              _L___3: /* CIL Label */ 
#line 300
              if ((int )c3 > 127) {
#line 300
                c3 = (uint8 )((256 - (int )c3) << 4);
              } else {
#line 300
                c3 = c3;
              }
            }
#line 302
            tmp___27 = x;
#line 302
            x ++;
#line 302
            *tmp___27 = c3;
            __Cont___0: /* CIL Label */ 
#line 228
            l ++;
#line 228
            k ++;
          }
          while_break___9: /* CIL Label */ ;
          }
          {
#line 305
          fseek(in, (long )a, 0);
#line 306
          k --;
          }
#line 307
          goto __Cont;
        }
#line 310
        x = & tdata[i___3 * 4 + j][k * 4];
#line 312
        tmp___28 = x;
#line 312
        x ++;
#line 312
        *tmp___28 = (uint8 )((((int )c1 << 4) & 16) | (int )ptk_table[(int )c1 / 2][0]);
#line 313
        tmp___29 = x;
#line 313
        x ++;
#line 313
        *tmp___29 = (uint8 )ptk_table[(int )c1 / 2][1];
#line 315
        c6 = (uint8 )((int )c2 & 15);
#line 316
        if ((int )c6 == 8) {
#line 317
          c2 = (uint8 )((int )c2 - 8);
        }
#line 319
        tmp___30 = x;
#line 319
        x ++;
#line 319
        *tmp___30 = c2;
#line 321
        if ((int )c6 == 5) {
#line 321
          goto _L___4;
        } else
#line 321
        if ((int )c6 == 6) {
#line 321
          goto _L___4;
        } else
#line 321
        if ((int )c6 == 10) {
          _L___4: /* CIL Label */ 
#line 322
          if ((int )c3 > 127) {
#line 322
            c3 = (uint8 )((256 - (int )c3) << 4);
          } else {
#line 322
            c3 = c3;
          }
        }
#line 324
        tmp___31 = x;
#line 324
        x ++;
#line 324
        *tmp___31 = c3;
#line 326
        if ((int )c6 == 13) {
#line 327
          max_row = k;
#line 328
          goto while_break___7;
        }
#line 330
        if ((int )c6 == 11) {
#line 331
          max_row = k;
#line 332
          goto while_break___7;
        }
        __Cont: /* CIL Label */ 
#line 162
        k ++;
      }
      while_break___7: /* CIL Label */ ;
      }
#line 160
      j ++;
    }
    while_break___6: /* CIL Label */ ;
    }
#line 158
    i___3 ++;
  }
  while_break___5: /* CIL Label */ ;
  }
#line 340
  i___3 = 0;
  {
#line 340
  while (1) {
    while_continue___11: /* CIL Label */ ;
#line 340
    if (! (i___3 < (int )npat)) {
#line 340
      goto while_break___11;
    }
    {
#line 341
    memset((void *)(buf___1), 0, (size_t )1024);
#line 342
    j = 0;
    }
    {
#line 342
    while (1) {
      while_continue___12: /* CIL Label */ ;
#line 342
      if (! (j < 64)) {
#line 342
        goto while_break___12;
      }
#line 343
      k = 0;
      {
#line 343
      while (1) {
        while_continue___13: /* CIL Label */ ;
#line 343
        if (! (k < 4)) {
#line 343
          goto while_break___13;
        }
        {
#line 344
        memcpy((void */* __restrict  */)(& buf___1[j * 16 + k * 4]), (void const   */* __restrict  */)(& tdata[k + i___3 * 4][j * 4]),
               (size_t )4);
#line 343
        k ++;
        }
      }
      while_break___13: /* CIL Label */ ;
      }
#line 342
      j ++;
    }
    while_break___12: /* CIL Label */ ;
    }
    {
#line 346
    fwrite((void const   */* __restrict  */)(buf___1), (size_t )1024, (size_t )1,
           (FILE */* __restrict  */)out);
#line 340
    i___3 ++;
    }
  }
  while_break___11: /* CIL Label */ ;
  }
  {
#line 350
  fseek(in, (long )sdata_addr, 0);
#line 353
  i___3 = 0;
  }
  {
#line 353
  while (1) {
    while_continue___14: /* CIL Label */ ;
#line 353
    if (! (i___3 < (int )nins)) {
#line 353
      goto while_break___14;
    }
    {
#line 354
    fseek(in, (long )(sdata_addr + saddr[i___3 + 1]), 0);
#line 355
    tmp___32 = malloc((size_t )smp_size[i___3]);
#line 355
    insDataWork = (signed char *)tmp___32;
#line 356
    memset((void *)insDataWork, 0, (size_t )smp_size[i___3]);
#line 357
    fread((void */* __restrict  */)insDataWork, (size_t )smp_size[i___3], (size_t )1,
          (FILE */* __restrict  */)in);
    }
#line 358
    if ((int )GLOBAL_DELTA == 1) {
#line 359
      c1 = (uint8 )0;
#line 360
      j = 1;
      {
#line 360
      while (1) {
        while_continue___15: /* CIL Label */ ;
#line 360
        if (! (j < smp_size[i___3])) {
#line 360
          goto while_break___15;
        }
#line 361
        c2 = (uint8 )*(insDataWork + j);
#line 362
        c2 = (uint8 )(256 - (int )c2);
#line 363
        c3 = (uint8 )((int )c2 + (int )c1);
#line 364
        *(insDataWork + j) = (signed char )c3;
#line 365
        c1 = c3;
#line 360
        j ++;
      }
      while_break___15: /* CIL Label */ ;
      }
    }
    {
#line 368
    fwrite((void const   */* __restrict  */)insDataWork, (size_t )smp_size[i___3],
           (size_t )1, (FILE */* __restrict  */)out);
#line 369
    free((void *)insDataWork);
#line 353
    i___3 ++;
    }
  }
  while_break___14: /* CIL Label */ ;
  }
#line 372
  if ((int )GLOBAL_DELTA == 1) {
#line 373
    pw_p60a.flags |= 2;
  }
#line 375
  return (0);
}
}
#line 379 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/prowizard/p60a.c"
static int test_p60a(uint8 *data , int s ) 
{ 
  int j ;
  int k ;
  int l ;
  int m___0 ;
  int n___0 ;
  int o___0 ;
  int start ;
  int ssize ;

  {
#line 382
  start = 0;
#line 388
  m___0 = (int )*(data + (start + 2));
#line 389
  if (m___0 > 127) {
#line 390
    return (-1);
  } else
#line 389
  if (m___0 == 0) {
#line 390
    return (-1);
  }
#line 394
  k = (int )*(data + (start + 3)) & 63;
#line 395
  if (k > 31) {
#line 396
    return (-1);
  } else
#line 395
  if (k == 0) {
#line 396
    return (-1);
  }
#line 398
  l = 0;
  {
#line 398
  while (1) {
    while_continue: /* CIL Label */ ;
#line 398
    if (! (l < k)) {
#line 398
      goto while_break;
    }
#line 400
    if ((int )*(data + ((start + 7) + l * 6)) > 64) {
#line 401
      return (-1);
    }
#line 404
    if ((int )*(data + ((start + 6) + l * 6)) > 15) {
#line 405
      return (-1);
    }
#line 398
    l ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 409
  ssize = 0;
#line 410
  n___0 = 0;
  {
#line 410
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 410
    if (! (n___0 < k)) {
#line 410
      goto while_break___0;
    }
#line 411
    o___0 = ((int )*(data + ((start + 4) + n___0 * 6)) << 8) + (int )*(data + ((start + 5) + n___0 * 6));
#line 412
    if (o___0 < 65503) {
#line 412
      if (o___0 > 32768) {
#line 413
        return (-1);
      } else {
#line 412
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 412
    if (o___0 == 0) {
#line 413
      return (-1);
    }
#line 415
    if (o___0 < 65280) {
#line 416
      ssize += o___0 * 2;
    }
#line 418
    j = ((int )*(data + ((start + 8) + n___0 * 6)) << 8) + (int )*(data + ((start + 9) + n___0 * 6));
#line 419
    if (j != 65535) {
#line 419
      if (j >= o___0) {
#line 420
        return (-1);
      }
    }
#line 422
    if (o___0 > 65503) {
#line 423
      if (65535 - o___0 > k) {
#line 424
        return (-1);
      }
    }
#line 410
    n___0 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 430
  j = ((int )*(data + start) << 8) + (int )*(data + (start + 1));
#line 431
  if (j < (k * 6 + 4) + m___0 * 8) {
#line 432
    return (-1);
  }
#line 435
  l = 0;
  {
#line 435
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 435
    if (! (l < m___0 * 4)) {
#line 435
      goto while_break___1;
    }
#line 436
    o___0 = ((int )*(data + (((start + 4) + k * 6) + l * 2)) << 8) + (int )*(data + ((((start + 4) + k * 6) + l * 2) + 1));
#line 438
    if (((o___0 + k * 6) + 4) + m___0 * 8 > j) {
#line 439
      return (-1);
    }
#line 435
    l ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 443
  l = 0;
#line 444
  o___0 = 0;
  {
#line 446
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 446
    if (s < ((start + k * 6) + 4) + m___0 * 8) {
#line 446
      return ((((start + k * 6) + 4) + m___0 * 8) - s);
    }
#line 446
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 448
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 448
    if ((int )*(data + ((((start + k * 6) + 4) + m___0 * 8) + l)) != 255) {
#line 448
      if (! (l < 128)) {
#line 448
        goto while_break___3;
      }
    } else {
#line 448
      goto while_break___3;
    }
#line 449
    if ((int )*(data + ((((start + k * 6) + 4) + m___0 * 8) + l)) > m___0 - 1) {
#line 450
      return (-1);
    }
#line 452
    if ((int )*(data + ((((start + k * 6) + 4) + m___0 * 8) + l)) > o___0) {
#line 453
      o___0 = (int )*(data + ((((start + k * 6) + 4) + m___0 * 8) + l));
    }
#line 454
    l ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 458
  if (((k * 6 + 4) + m___0 * 8) + l > j) {
#line 459
    return (-1);
  }
#line 461
  if (l == 0) {
#line 462
    return (-1);
  } else
#line 461
  if (l == 128) {
#line 462
    return (-1);
  }
#line 464
  o___0 ++;
  {
#line 469
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 469
    if (s < (start + j) + 1) {
#line 469
      return (((start + j) + 1) - s);
    }
#line 469
    goto while_break___4;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 471
  l ++;
#line 472
  n___0 = ((k * 6 + 4) + m___0 * 8) + l;
  {
#line 472
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 472
    if (! (n___0 < j)) {
#line 472
      goto while_break___5;
    }
#line 473
    if (((int )*(data + (start + n___0)) & 128) == 0) {
#line 474
      if ((int )*(data + (start + n___0)) > 73) {
#line 475
        return (-1);
      }
#line 477
      if (((((int )*(data + (start + n___0)) << 4) & 16) | (((int )*(data + ((start + n___0) + 1)) >> 4) & 15)) > k) {
#line 479
        return (-1);
      }
#line 480
      n___0 += 2;
    } else {
#line 482
      n___0 += 3;
    }
#line 472
    n___0 ++;
  }
  while_break___5: /* CIL Label */ ;
  }
#line 485
  return (0);
}
}
#line 70 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/prowizard/prowiz.h"
struct pw_format pw_np3 ;
#line 15 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/prowizard/np3.c"
static int test_np3(uint8 *data , int s ) ;
#line 16
static int depack_np3(FILE *in , FILE *out ) ;
#line 18 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/prowizard/np3.c"
struct pw_format pw_np3  =    {(char *)"NP3", (char *)"Noisepacker v3", 0, & test_np3, & depack_np3, 0, {(struct list_head *)0,
                                                                              (struct list_head *)0}};
#line 27 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/prowizard/np3.c"
static int depack_np3(FILE *in , FILE *out ) 
{ 
  uint8 *tmp ;
  uint8 *buffer ;
  uint8 c1 ;
  uint8 c2 ;
  uint8 c3 ;
  uint8 c4 ;
  uint8 npos ;
  uint8 nins ;
  uint8 ptable[128] ;
  uint8 pat_max ;
  int filesize ;
  int OverallCpt ;
  int Max_Add ;
  int ssize ;
  int tsize ;
  int taddr[128][4] ;
  int Unknown1 ;
  int i___3 ;
  int j ;
  int k ;
  int l ;
  int tdata ;
  int saddr ;
  long tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  void *__cil_tmp32 ;
  void *__cil_tmp33 ;
  int __cil_tmp34 ;
  void *__cil_tmp35 ;

  {
  {
#line 34
  pat_max = (uint8 )0;
#line 35
  filesize = 0;
#line 36
  OverallCpt = 0;
#line 37
  Max_Add = 0;
#line 38
  ssize = 0;
#line 42
  i___3 = 0;
#line 42
  j = 0;
#line 42
  l = 0;
#line 44
  saddr = 0;
#line 46
  memset((void *)(ptable), 0, (size_t )128);
#line 47
  memset((void *)(taddr), 0, (size_t )2048);
#line 50
  fseek(in, 0L, 2);
#line 51
  tmp___0 = ftell(in);
#line 51
  filesize = (int )tmp___0;
#line 52
  fseek(in, 0L, 0);
#line 55
  tmp___1 = malloc((size_t )filesize);
#line 55
  buffer = (uint8 *)tmp___1;
#line 56
  memset((void *)buffer, 0, (size_t )filesize);
#line 57
  fread((void */* __restrict  */)buffer, (size_t )filesize, (size_t )1, (FILE */* __restrict  */)in);
#line 60
  nins = (uint8 )((((int )*(buffer + 0) << 4) & 240) | (((int )*(buffer + 1) >> 4) & 15));
#line 63
  tmp___2 = malloc((size_t )20);
#line 63
  tmp = (uint8 *)tmp___2;
#line 64
  memset((void *)tmp, 0, (size_t )20);
#line 65
  fwrite((void const   */* __restrict  */)tmp, (size_t )20, (size_t )1, (FILE */* __restrict  */)out);
#line 66
  free((void *)tmp);
#line 69
  npos = (uint8 )((int )*(buffer + 3) / 2);
#line 73
  Unknown1 = ((int )*(buffer + 4) << 8) + (int )*(buffer + 5);
#line 76
  tsize = ((int )*(buffer + 6) << 8) + (int )*(buffer + 7);
#line 79
  tmp___3 = malloc((size_t )22);
#line 79
  tmp = (uint8 *)tmp___3;
#line 80
  memset((void *)tmp, 0, (size_t )22);
#line 81
  OverallCpt = 8;
#line 82
  i___3 = 0;
  }
  {
#line 82
  while (1) {
    while_continue: /* CIL Label */ ;
#line 82
    if (! (i___3 < (int )nins)) {
#line 82
      goto while_break;
    }
    {
#line 84
    fwrite((void const   */* __restrict  */)tmp, (size_t )22, (size_t )1, (FILE */* __restrict  */)out);
#line 86
    fwrite((void const   */* __restrict  */)(buffer + (OverallCpt + 6)), (size_t )2,
           (size_t )1, (FILE */* __restrict  */)out);
#line 87
    ssize += (((int )*(buffer + (OverallCpt + 6)) << 8) + (int )*(buffer + (OverallCpt + 7))) * 2;
#line 90
    fwrite((void const   */* __restrict  */)(buffer + OverallCpt), (size_t )1, (size_t )1,
           (FILE */* __restrict  */)out);
#line 92
    fwrite((void const   */* __restrict  */)(buffer + (OverallCpt + 1)), (size_t )1,
           (size_t )1, (FILE */* __restrict  */)out);
#line 94
    fwrite((void const   */* __restrict  */)(buffer + (OverallCpt + 14)), (size_t )2,
           (size_t )1, (FILE */* __restrict  */)out);
#line 96
    fwrite((void const   */* __restrict  */)(buffer + (OverallCpt + 12)), (size_t )2,
           (size_t )1, (FILE */* __restrict  */)out);
#line 97
    OverallCpt += 16;
#line 82
    i___3 ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 102
  free((void *)tmp);
#line 103
  tmp___4 = malloc((size_t )30);
#line 103
  tmp = (uint8 *)tmp___4;
#line 104
  memset((void *)tmp, 0, (size_t )30);
#line 105
  *(tmp + 29) = (uint8 )1;
  }
  {
#line 106
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 106
    if (! (i___3 != 31)) {
#line 106
      goto while_break___0;
    }
    {
#line 107
    fwrite((void const   */* __restrict  */)tmp, (size_t )30, (size_t )1, (FILE */* __restrict  */)out);
#line 108
    i___3 ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 110
  free((void *)tmp);
#line 113
  fwrite((void const   */* __restrict  */)(& npos), (size_t )1, (size_t )1, (FILE */* __restrict  */)out);
#line 116
  c1 = (uint8 )127;
#line 117
  fwrite((void const   */* __restrict  */)(& c1), (size_t )1, (size_t )1, (FILE */* __restrict  */)out);
#line 121
  OverallCpt += 4;
#line 124
  pat_max = (uint8 )0;
#line 125
  i___3 = 0;
  }
  {
#line 125
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 125
    if (! (i___3 < (int )npos)) {
#line 125
      goto while_break___1;
    }
#line 126
    ptable[i___3] = (uint8 )((((int )*(buffer + (OverallCpt + i___3 * 2)) << 8) + (int )*(buffer + ((OverallCpt + i___3 * 2) + 1))) / 8);
#line 129
    if ((int )ptable[i___3] > (int )pat_max) {
#line 130
      pat_max = ptable[i___3];
    }
#line 125
    i___3 ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 132
  OverallCpt += (int )npos * 2;
#line 133
  pat_max = (uint8 )((int )pat_max + 1);
#line 137
  fwrite((void const   */* __restrict  */)(ptable), (size_t )128, (size_t )1, (FILE */* __restrict  */)out);
#line 140
  c1 = (uint8 )'M';
#line 141
  c2 = (uint8 )'.';
#line 142
  c3 = (uint8 )'K';
#line 143
  fwrite((void const   */* __restrict  */)(& c1), (size_t )1, (size_t )1, (FILE */* __restrict  */)out);
#line 144
  fwrite((void const   */* __restrict  */)(& c2), (size_t )1, (size_t )1, (FILE */* __restrict  */)out);
#line 145
  fwrite((void const   */* __restrict  */)(& c3), (size_t )1, (size_t )1, (FILE */* __restrict  */)out);
#line 146
  fwrite((void const   */* __restrict  */)(& c2), (size_t )1, (size_t )1, (FILE */* __restrict  */)out);
#line 150
  i___3 = 0;
  }
  {
#line 150
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 150
    if (! (i___3 < (int )pat_max)) {
#line 150
      goto while_break___2;
    }
#line 151
    taddr[i___3][0] = ((int )*(buffer + (OverallCpt + i___3 * 8)) << 8) + (int )*(buffer + ((OverallCpt + i___3 * 8) + 1));
#line 154
    if (taddr[i___3][0] > Max_Add) {
#line 155
      Max_Add = taddr[i___3][0];
    }
#line 156
    taddr[i___3][1] = ((int )*(buffer + ((OverallCpt + i___3 * 8) + 2)) << 8) + (int )*(buffer + ((OverallCpt + i___3 * 8) + 3));
#line 159
    if (taddr[i___3][1] > Max_Add) {
#line 160
      Max_Add = taddr[i___3][1];
    }
#line 161
    taddr[i___3][2] = ((int )*(buffer + ((OverallCpt + i___3 * 8) + 4)) << 8) + (int )*(buffer + ((OverallCpt + i___3 * 8) + 5));
#line 164
    if (taddr[i___3][2] > Max_Add) {
#line 165
      Max_Add = taddr[i___3][2];
    }
#line 166
    taddr[i___3][3] = ((int )*(buffer + ((OverallCpt + i___3 * 8) + 6)) << 8) + (int )*(buffer + ((OverallCpt + i___3 * 8) + 7));
#line 169
    if (taddr[i___3][3] > Max_Add) {
#line 170
      Max_Add = taddr[i___3][3];
    }
#line 150
    i___3 ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 172
  tdata = OverallCpt + (int )pat_max * 8;
#line 176
  tmp___5 = malloc((size_t )1024);
#line 176
  tmp = (uint8 *)tmp___5;
#line 177
  i___3 = 0;
  }
  {
#line 177
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 177
    if (! (i___3 < (int )pat_max)) {
#line 177
      goto while_break___3;
    }
    {
#line 178
    memset((void *)tmp, 0, (size_t )1024);
#line 179
    j = 0;
    }
    {
#line 179
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 179
      if (! (j < 4)) {
#line 179
        goto while_break___4;
      }
#line 180
      l = tdata + taddr[i___3][3 - j];
#line 181
      k = 0;
      {
#line 181
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 181
        if (! (k < 64)) {
#line 181
          goto while_break___5;
        }
#line 182
        c1 = *(buffer + l);
#line 183
        l ++;
#line 184
        if ((int )c1 >= 128) {
#line 185
          k += (256 - (int )c1) - 1;
#line 186
          goto __Cont;
        }
#line 188
        c2 = *(buffer + l);
#line 189
        l ++;
#line 190
        c3 = *(buffer + l);
#line 191
        l ++;
#line 193
        *(tmp + (k * 16 + j * 4)) = (uint8 )(((int )c1 << 4) & 16);
#line 194
        c4 = (uint8 )(((int )c1 & 254) / 2);
#line 195
        *(tmp + (k * 16 + j * 4)) = (uint8 )((int )*(tmp + (k * 16 + j * 4)) | (int )ptk_table[c4][0]);
#line 196
        *(tmp + ((k * 16 + j * 4) + 1)) = (uint8 )ptk_table[c4][1];
#line 197
        if (((int )c2 & 15) == 8) {
#line 198
          c2 = (uint8 )((int )c2 & 240);
        }
#line 199
        if (((int )c2 & 15) == 7) {
#line 200
          c2 = (uint8 )(((int )c2 & 240) + 10);
#line 201
          if ((int )c3 > 128) {
#line 202
            c3 = (uint8 )(256 - (int )c3);
          } else {
#line 204
            c3 = (uint8 )(((int )c3 << 4) & 240);
          }
        }
#line 206
        if (((int )c2 & 15) == 6) {
#line 207
          if ((int )c3 > 128) {
#line 208
            c3 = (uint8 )(256 - (int )c3);
          } else {
#line 210
            c3 = (uint8 )(((int )c3 << 4) & 240);
          }
        }
#line 212
        if (((int )c2 & 15) == 5) {
#line 213
          if ((int )c3 > 128) {
#line 214
            c3 = (uint8 )(256 - (int )c3);
          } else {
#line 216
            c3 = (uint8 )(((int )c3 << 4) & 240);
          }
        }
#line 218
        if (((int )c2 & 15) == 14) {
#line 219
          c3 = (uint8 )1;
        }
#line 221
        if (((int )c2 & 15) == 11) {
#line 222
          c3 = (uint8 )((int )c3 + 4);
#line 223
          c3 = (uint8 )((int )c3 / 2);
        }
#line 225
        *(tmp + ((k * 16 + j * 4) + 2)) = c2;
#line 226
        *(tmp + ((k * 16 + j * 4) + 3)) = c3;
#line 227
        if (((int )c2 & 15) == 13) {
#line 228
          k = 100;
        }
        __Cont: /* CIL Label */ 
#line 181
        k ++;
      }
      while_break___5: /* CIL Label */ ;
      }
#line 230
      if (l > saddr) {
#line 231
        saddr = l;
      }
#line 179
      j ++;
    }
    while_break___4: /* CIL Label */ ;
    }
    {
#line 233
    fwrite((void const   */* __restrict  */)tmp, (size_t )1024, (size_t )1, (FILE */* __restrict  */)out);
#line 177
    i___3 ++;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 235
  free((void *)tmp);
  }
#line 238
  if ((saddr / 2) * 2 != saddr) {
#line 239
    saddr ++;
  }
  {
#line 240
  OverallCpt = saddr;
#line 242
  fwrite((void const   */* __restrict  */)(buffer + saddr), (size_t )ssize, (size_t )1,
         (FILE */* __restrict  */)out);
  }
#line 244
  return (0);
}
}
#line 248 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/prowizard/np3.c"
static int test_np3(uint8 *data , int s ) 
{ 
  int j ;
  int k ;
  int l ;
  int m___0 ;
  int n___0 ;
  int o___0 ;
  int start ;
  int ssize ;

  {
#line 251
  start = 0;
  {
#line 253
  while (1) {
    while_continue: /* CIL Label */ ;
#line 253
    if (s < 10) {
#line 253
      return (10 - s);
    }
#line 253
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 256
  j = ((int )*(data + (start + 2)) << 8) + (int )*(data + (start + 3));
#line 258
  if ((j / 2) * 2 != j) {
#line 259
    return (-1);
  } else
#line 258
  if (j == 0) {
#line 259
    return (-1);
  }
#line 262
  if (((int )*(data + (start + 1)) & 15) != 12) {
#line 263
    return (-1);
  }
#line 265
  l = (((int )*(data + start) << 4) & 240) | (((int )*(data + (start + 1)) >> 4) & 15);
#line 267
  if (l > 31) {
#line 268
    return (-1);
  } else
#line 267
  if (l == 0) {
#line 268
    return (-1);
  }
#line 272
  k = 0;
  {
#line 272
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 272
    if (! (k < l)) {
#line 272
      goto while_break___0;
    }
#line 273
    if ((int )*(data + ((start + 9) + k * 16)) > 64) {
#line 274
      return (-1);
    }
#line 272
    k ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 278
  ssize = 0;
#line 279
  k = 0;
  {
#line 279
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 279
    if (! (k < l)) {
#line 279
      goto while_break___1;
    }
#line 280
    o___0 = ((int )*(data + ((start + k * 16) + 14)) << 8) + (int )*(data + ((start + k * 16) + 15));
#line 282
    m___0 = ((int )*(data + ((start + k * 16) + 20)) << 8) + (int )*(data + ((start + k * 16) + 21));
#line 284
    n___0 = ((int )*(data + ((start + k * 16) + 22)) << 8) + (int )*(data + ((start + k * 16) + 23));
#line 286
    o___0 *= 2;
#line 287
    m___0 *= 2;
#line 288
    n___0 *= 2;
#line 290
    if (o___0 > 65535) {
#line 291
      return (-1);
    } else
#line 290
    if (m___0 > 65535) {
#line 291
      return (-1);
    } else
#line 290
    if (n___0 > 65535) {
#line 291
      return (-1);
    }
#line 293
    if (m___0 + n___0 > o___0 + 2) {
#line 294
      return (-1);
    }
#line 296
    if (n___0 != 0) {
#line 296
      if (m___0 == 0) {
#line 297
        return (-1);
      }
    }
#line 299
    ssize += o___0;
#line 279
    k ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 302
  if (ssize <= 4) {
#line 303
    return (-1);
  }
#line 306
  l *= 16;
#line 307
  l += 8;
#line 308
  l += 4;
#line 312
  n___0 = 0;
#line 313
  k = 0;
  {
#line 313
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 313
    if (! (k < j)) {
#line 313
      goto while_break___2;
    }
#line 314
    m___0 = ((int )*(data + ((start + l) + k)) << 8) + (int )*(data + (((start + l) + k) + 1));
#line 315
    if ((m___0 / 8) * 8 != m___0) {
#line 316
      return (-1);
    }
#line 317
    if (m___0 > n___0) {
#line 318
      n___0 = m___0;
    }
#line 313
    k += 2;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 320
  l += j;
#line 321
  l += n___0;
#line 322
  l += 8;
#line 328
  k = ((int )*(data + (start + 6)) << 8) + (int )*(data + (start + 7));
#line 329
  if (k <= 63) {
#line 330
    return (-1);
  }
  {
#line 332
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 332
    if (s < (start + l) + k) {
#line 332
      return (((start + l) + k) - s);
    }
#line 332
    goto while_break___3;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 337
  j = (((int )*(data + start) << 4) & 240) | (((int )*(data + (start + 1)) >> 4) & 15);
#line 338
  m___0 = 0;
  {
#line 338
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 338
    if (! (m___0 < k)) {
#line 338
      goto while_break___4;
    }
#line 339
    if (((int )*(data + ((start + l) + m___0)) & 128) == 128) {
#line 340
      goto __Cont;
    }
#line 343
    if ((int )*(data + ((start + l) + m___0)) > 73) {
#line 345
      return (-1);
    } else
#line 343
    if (((int )*(data + (((start + l) + m___0) + 1)) & 15) == 10) {
#line 345
      return (-1);
    }
#line 348
    if (((int )*(data + (((start + l) + m___0) + 1)) & 15) == 13) {
#line 348
      if ((int )*(data + (((start + l) + m___0) + 2)) > 64) {
#line 350
        return (-1);
      }
    }
#line 353
    if (((((int )*(data + ((start + l) + m___0)) << 4) & 16) | (((int )*(data + (((start + l) + m___0) + 1)) >> 4) & 15)) > j) {
#line 355
      return (-1);
    }
#line 358
    if ((int )*(data + ((start + l) + m___0)) == 0) {
#line 358
      if ((int )*(data + (((start + l) + m___0) + 1)) == 0) {
#line 358
        if ((int )*(data + (((start + l) + m___0) + 2)) == 0) {
#line 358
          if (m___0 < k - 3) {
#line 360
            return (-1);
          }
        }
      }
    }
#line 362
    m___0 += 2;
    __Cont: /* CIL Label */ 
#line 338
    m___0 ++;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 369
  return (0);
}
}
#line 69 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/prowizard/prowiz.h"
struct pw_format pw_np2 ;
#line 12 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/prowizard/np2.c"
static int test_np2(uint8 *data , int s ) ;
#line 13
static int depack_np2(FILE *in , FILE *out ) ;
#line 15 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/prowizard/np2.c"
struct pw_format pw_np2  =    {(char *)"NP2", (char *)"Noisepacker v2", 0, & test_np2, & depack_np2, 0, {(struct list_head *)0,
                                                                              (struct list_head *)0}};
#line 23 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/prowizard/np2.c"
static int depack_np2(FILE *in , FILE *out ) 
{ 
  uint8 tmp[1024] ;
  uint8 c1 ;
  uint8 c2 ;
  uint8 c3 ;
  uint8 c4 ;
  uint8 npos ;
  uint8 nsmp ;
  uint8 ptable[128] ;
  uint8 npat ;
  int max_addr ;
  int size___0 ;
  int ssize ;
  int tsize ;
  int trk_addr[128][4] ;
  int i___3 ;
  int j ;
  int k ;
  int trk_start ;
  uint8 tmp___0 ;
  uint16 tmp___1 ;
  uint16 tmp___2 ;
  uint8 tmp___3 ;
  uint8 tmp___4 ;
  uint16 tmp___5 ;
  uint16 tmp___6 ;
  uint16 tmp___7 ;
  uint16 tmp___8 ;
  uint16 tmp___9 ;
  uint16 tmp___10 ;
  uint16 tmp___11 ;
  long tmp___12 ;
  int x ;
  void *__cil_tmp35 ;
  void *__cil_tmp36 ;
  void *__cil_tmp37 ;
  int __cil_tmp38 ;
  void *__cil_tmp39 ;

  {
  {
#line 32
  ssize = 0;
#line 38
  memset((void *)(ptable), 0, (size_t )128);
#line 39
  memset((void *)(trk_addr), 0, (size_t )2048);
#line 41
  c1 = read8(in);
#line 42
  c2 = read8(in);
#line 43
  nsmp = (uint8 )((((int )c1 << 4) & 240) | (((int )c2 >> 4) & 15));
#line 45
  pw_write_zero(out, 20);
#line 47
  read8(in);
#line 48
  tmp___0 = read8(in);
#line 48
  npos = (uint8 )((int )tmp___0 / 2);
#line 49
  read16b(in);
#line 50
  tmp___1 = read16b(in);
#line 50
  tsize = (int )tmp___1;
#line 53
  i___3 = 0;
  }
  {
#line 53
  while (1) {
    while_continue: /* CIL Label */ ;
#line 53
    if (! (i___3 < (int )nsmp)) {
#line 53
      goto while_break;
    }
    {
#line 54
    read32b(in);
#line 55
    pw_write_zero(out, 22);
#line 56
    tmp___2 = read16b(in);
#line 56
    size___0 = (int )tmp___2;
#line 56
    write16b(out, (uint16 )size___0);
#line 57
    ssize += size___0 * 2;
#line 58
    tmp___3 = read8(in);
#line 58
    write8(out, tmp___3);
#line 59
    tmp___4 = read8(in);
#line 59
    write8(out, tmp___4);
#line 60
    read32b(in);
#line 61
    tmp___5 = read16b(in);
#line 61
    size___0 = (int )tmp___5;
#line 62
    tmp___6 = read16b(in);
#line 62
    write16b(out, tmp___6);
#line 63
    write16b(out, (uint16 )size___0);
#line 53
    i___3 ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 67
  memset((void *)(tmp), 0, (size_t )30);
#line 68
  tmp[29] = (uint8 )1;
  }
  {
#line 69
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 69
    if (! (i___3 != 31)) {
#line 69
      goto while_break___0;
    }
    {
#line 70
    fwrite((void const   */* __restrict  */)(tmp), (size_t )30, (size_t )1, (FILE */* __restrict  */)out);
#line 69
    i___3 ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 72
  write8(out, npos);
#line 73
  write8(out, (uint8 )127);
#line 75
  fseek(in, 2L, 1);
#line 76
  fseek(in, 2L, 1);
#line 79
  i___3 = 0;
#line 79
  npat = (uint8 )i___3;
  }
  {
#line 79
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 79
    if (! (i___3 < (int )npos)) {
#line 79
      goto while_break___1;
    }
    {
#line 80
    tmp___7 = read16b(in);
#line 80
    ptable[i___3] = (uint8 )((int )tmp___7 / 8);
    }
#line 81
    if ((int )ptable[i___3] > (int )npat) {
#line 82
      npat = ptable[i___3];
    }
#line 79
    i___3 ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 84
  npat = (uint8 )((int )npat + 1);
#line 86
  fwrite((void const   */* __restrict  */)(ptable), (size_t )128, (size_t )1, (FILE */* __restrict  */)out);
#line 87
  write32b(out, (((77U << 24) | (46U << 16)) | (75U << 8)) | 46U);
#line 90
  i___3 = 0;
#line 90
  max_addr = i___3;
  }
  {
#line 90
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 90
    if (! (i___3 < (int )npat)) {
#line 90
      goto while_break___2;
    }
    {
#line 91
    tmp___8 = read16b(in);
#line 91
    trk_addr[i___3][0] = (int )tmp___8;
    }
#line 92
    if (trk_addr[i___3][0] > max_addr) {
#line 93
      max_addr = trk_addr[i___3][0];
    }
    {
#line 94
    tmp___9 = read16b(in);
#line 94
    trk_addr[i___3][1] = (int )tmp___9;
    }
#line 95
    if (trk_addr[i___3][1] > max_addr) {
#line 96
      max_addr = trk_addr[i___3][1];
    }
    {
#line 97
    tmp___10 = read16b(in);
#line 97
    trk_addr[i___3][2] = (int )tmp___10;
    }
#line 98
    if (trk_addr[i___3][2] > max_addr) {
#line 99
      max_addr = trk_addr[i___3][2];
    }
    {
#line 100
    tmp___11 = read16b(in);
#line 100
    trk_addr[i___3][3] = (int )tmp___11;
    }
#line 101
    if (trk_addr[i___3][3] > max_addr) {
#line 102
      max_addr = trk_addr[i___3][3];
    }
#line 90
    i___3 ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 104
  tmp___12 = ftell(in);
#line 104
  trk_start = (int )tmp___12;
#line 107
  i___3 = 0;
  }
  {
#line 107
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 107
    if (! (i___3 < (int )npat)) {
#line 107
      goto while_break___3;
    }
    {
#line 108
    memset((void *)(tmp), 0, (size_t )1024);
#line 109
    j = 0;
    }
    {
#line 109
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 109
      if (! (j < 4)) {
#line 109
        goto while_break___4;
      }
      {
#line 110
      fseek(in, (long )(trk_start + trk_addr[i___3][3 - j]), 0);
#line 111
      k = 0;
      }
      {
#line 111
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 111
        if (! (k < 64)) {
#line 111
          goto while_break___5;
        }
        {
#line 112
        x = k * 16 + j * 4;
#line 114
        c1 = read8(in);
#line 115
        c2 = read8(in);
#line 116
        c3 = read8(in);
#line 118
        tmp[x] = (uint8 )(((int )c1 << 4) & 16);
#line 120
        c4 = (uint8 )(((int )c1 & 254) / 2);
#line 121
        tmp[x] = (uint8 )((int )tmp[x] | (int )ptk_table[c4][0]);
#line 122
        tmp[x + 1] = (uint8 )ptk_table[c4][1];
        }
#line 124
        if (((int )c2 & 15) == 8) {
#line 125
          c2 = (uint8 )((int )c2 & 240);
        }
#line 126
        if (((int )c2 & 15) == 7) {
#line 127
          c2 = (uint8 )(((int )c2 & 240) + 10);
#line 128
          if ((int )c3 > 128) {
#line 129
            c3 = (uint8 )(256 - (int )c3);
          } else {
#line 131
            c3 = (uint8 )(((int )c3 << 4) & 240);
          }
        }
#line 133
        if (((int )c2 & 15) == 6) {
#line 134
          if ((int )c3 > 128) {
#line 135
            c3 = (uint8 )(256 - (int )c3);
          } else {
#line 137
            c3 = (uint8 )(((int )c3 << 4) & 240);
          }
        }
#line 139
        if (((int )c2 & 15) == 5) {
#line 140
          if ((int )c3 > 128) {
#line 141
            c3 = (uint8 )(256 - (int )c3);
          } else {
#line 143
            c3 = (uint8 )(((int )c3 << 4) & 240);
          }
        }
#line 145
        if (((int )c2 & 15) == 14) {
#line 146
          c3 = (uint8 )((int )c3 - 1);
        }
#line 148
        if (((int )c2 & 15) == 11) {
#line 149
          c3 = (uint8 )((int )c3 + 4);
#line 150
          c3 = (uint8 )((int )c3 / 2);
        }
#line 152
        tmp[x + 2] = c2;
#line 153
        tmp[x + 3] = c3;
#line 111
        k ++;
      }
      while_break___5: /* CIL Label */ ;
      }
#line 109
      j ++;
    }
    while_break___4: /* CIL Label */ ;
    }
    {
#line 156
    fwrite((void const   */* __restrict  */)(tmp), (size_t )1024, (size_t )1, (FILE */* __restrict  */)out);
#line 107
    i___3 ++;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 160
  fseek(in, (long )((max_addr + 192) + trk_start), 0);
#line 161
  pw_move_data(out, in, ssize);
  }
#line 163
  return (0);
}
}
#line 167 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/prowizard/np2.c"
static int test_np2(uint8 *data , int s ) 
{ 
  int j ;
  int k ;
  int l ;
  int o___0 ;
  int m___0 ;
  int n___0 ;
  int start ;
  int ssize ;
  int x ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
  {
#line 172
  while (1) {
    while_continue: /* CIL Label */ ;
#line 172
    if (s < 1024) {
#line 172
      return (1024 - s);
    }
#line 172
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 181
  start = 0;
#line 184
  j = ((int )*(data + (start + 2)) << 8) + (int )*(data + (start + 3));
#line 185
  if (j & 1) {
#line 186
    return (-1);
  } else
#line 185
  if (j == 0) {
#line 186
    return (-1);
  }
#line 189
  if (((int )*(data + (start + 1)) & 15) != 12) {
#line 190
    return (-1);
  }
#line 193
  l = (((int )*(data + start) << 4) & 240) | (((int )*(data + (start + 1)) >> 4) & 15);
#line 194
  if (l > 31) {
#line 195
    return (-1);
  } else
#line 194
  if (l == 0) {
#line 195
    return (-1);
  }
#line 198
  k = 0;
  {
#line 198
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 198
    if (! (k < l)) {
#line 198
      goto while_break___0;
    }
#line 199
    if ((int )*(data + ((start + 15) + k * 16)) > 64) {
#line 200
      return (-1);
    }
#line 198
    k ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 204
  ssize = 0;
#line 205
  k = 0;
  {
#line 205
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 205
    if (! (k < l)) {
#line 205
      goto while_break___1;
    }
#line 206
    x = start + k * 16;
#line 208
    o___0 = 2 * (((int )*(data + (x + 12)) << 8) + (int )*(data + (x + 13)));
#line 209
    m___0 = 2 * (((int )*(data + (x + 20)) << 8) + (int )*(data + (x + 21)));
#line 210
    n___0 = 2 * (((int )*(data + (x + 22)) << 8) + (int )*(data + (x + 23)));
#line 212
    if (o___0 > 65535) {
#line 213
      return (-1);
    } else
#line 212
    if (m___0 > 65535) {
#line 213
      return (-1);
    } else
#line 212
    if (n___0 > 65535) {
#line 213
      return (-1);
    }
#line 215
    if (m___0 + n___0 > o___0 + 2) {
#line 216
      return (-1);
    }
#line 218
    if (n___0 != 0) {
#line 218
      if (m___0 == 0) {
#line 219
        return (-1);
      }
    }
#line 221
    ssize += o___0;
#line 205
    k ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 224
  if (ssize <= 4) {
#line 225
    return (-1);
  }
#line 227
  l *= 16;
#line 228
  l += 12;
#line 232
  n___0 = 0;
#line 233
  k = 0;
  {
#line 233
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 233
    if (! (k < j)) {
#line 233
      goto while_break___2;
    }
#line 234
    m___0 = ((int )*(data + ((start + l) + k)) << 8) + (int )*(data + (((start + l) + k) + 1));
#line 235
    if ((m___0 / 8) * 8 != m___0) {
#line 236
      return (-1);
    }
#line 237
    if (m___0 > n___0) {
#line 238
      n___0 = m___0;
    }
#line 233
    k += 2;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 241
  l += (j + n___0) + 8;
#line 248
  k = ((int )*(data + (start + 6)) << 8) + (int )*(data + (start + 7));
#line 249
  if (k < 192) {
#line 250
    return (-1);
  } else
#line 249
  if ((k / 192) * 192 != k) {
#line 250
    return (-1);
  }
  {
#line 252
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 252
    if (s < (k + l) + 16) {
#line 252
      return (((k + l) + 16) - s);
    }
#line 252
    goto while_break___3;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 255
  j = (((int )*(data + start) << 4) & 240) | (((int )*(data + (start + 1)) >> 4) & 15);
#line 256
  m___0 = 0;
  {
#line 256
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 256
    if (! (m___0 < k)) {
#line 256
      goto while_break___4;
    }
#line 257
    if ((int )*(data + ((start + l) + m___0)) > 73) {
      {
#line 258
      printf((char const   */* __restrict  */)"Fail 1 on m = %d\n", m___0);
      }
#line 259
      return (-1);
    }
#line 262
    if (((((int )*(data + ((start + l) + m___0)) << 4) & 16) | (((int )*(data + (((start + l) + m___0) + 1)) >> 4) & 15)) > j) {
      {
#line 264
      printf((char const   */* __restrict  */)"Fail 2 on m = %d", m___0);
      }
#line 265
      return (-1);
    }
#line 268
    n___0 = (int )*(data + (((start + l) + m___0) + 1)) & 15;
#line 269
    if (n___0 == 0) {
#line 269
      if ((int )*(data + (((start + l) + m___0) + 2)) != 0) {
        {
#line 270
        printf((char const   */* __restrict  */)"Fail 3 on m = %d", m___0);
        }
#line 271
        return (-1);
      }
    }
#line 256
    m___0 += 3;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 279
  return (0);
}
}
#line 68 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/prowizard/prowiz.h"
struct pw_format pw_np1 ;
#line 12 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/prowizard/np1.c"
static int test_np1(uint8 *data , int s ) ;
#line 13
static int depack_np1(FILE *in , FILE *out ) ;
#line 15 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/prowizard/np1.c"
struct pw_format pw_np1  =    {(char *)"NP1", (char *)"NoisePacker v1", 0, & test_np1, & depack_np1, 0, {(struct list_head *)0,
                                                                              (struct list_head *)0}};
#line 24 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/prowizard/np1.c"
static int depack_np1(FILE *in , FILE *out ) 
{ 
  uint8 *tmp ;
  uint8 c1 ;
  uint8 c2 ;
  uint8 c3 ;
  uint8 c4 ;
  uint8 npos ;
  uint8 nins ;
  uint8 ptable[128] ;
  uint8 pat_max ;
  int Max_Add ;
  int ssize ;
  int tsize ;
  int taddr[128][4] ;
  int Unknown1 ;
  int i___3 ;
  int j ;
  int k ;
  int tdata ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  long tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  void *__cil_tmp27 ;
  void *__cil_tmp28 ;
  int __cil_tmp29 ;
  void *__cil_tmp30 ;

  {
  {
#line 31
  pat_max = (uint8 )0;
#line 32
  Max_Add = 0;
#line 33
  ssize = 0;
#line 37
  i___3 = 0;
#line 37
  j = 0;
#line 40
  memset((void *)(ptable), 0, (size_t )128);
#line 41
  memset((void *)(taddr), 0, (size_t )2048);
#line 44
  fread((void */* __restrict  */)(& c1), (size_t )1, (size_t )1, (FILE */* __restrict  */)in);
#line 45
  fread((void */* __restrict  */)(& c2), (size_t )1, (size_t )1, (FILE */* __restrict  */)in);
#line 46
  nins = (uint8 )((((int )c1 << 4) & 240) | (((int )c2 >> 4) & 15));
#line 50
  tmp___0 = malloc((size_t )20);
#line 50
  tmp = (uint8 *)tmp___0;
#line 51
  memset((void *)tmp, 0, (size_t )20);
#line 52
  fwrite((void const   */* __restrict  */)tmp, (size_t )20, (size_t )1, (FILE */* __restrict  */)out);
#line 53
  free((void *)tmp);
#line 56
  fread((void */* __restrict  */)(& c1), (size_t )1, (size_t )1, (FILE */* __restrict  */)in);
#line 57
  fread((void */* __restrict  */)(& c2), (size_t )1, (size_t )1, (FILE */* __restrict  */)in);
#line 58
  npos = (uint8 )((int )c2 / 2);
#line 62
  fread((void */* __restrict  */)(& c1), (size_t )1, (size_t )1, (FILE */* __restrict  */)in);
#line 63
  fread((void */* __restrict  */)(& c2), (size_t )1, (size_t )1, (FILE */* __restrict  */)in);
#line 64
  Unknown1 = ((int )c1 << 8) + (int )c2;
#line 67
  fread((void */* __restrict  */)(& c1), (size_t )1, (size_t )1, (FILE */* __restrict  */)in);
#line 68
  fread((void */* __restrict  */)(& c2), (size_t )1, (size_t )1, (FILE */* __restrict  */)in);
#line 69
  tsize = ((int )c1 << 8) + (int )c2;
#line 73
  tmp___1 = malloc((size_t )22);
#line 73
  tmp = (uint8 *)tmp___1;
#line 74
  memset((void *)tmp, 0, (size_t )22);
#line 75
  i___3 = 0;
  }
  {
#line 75
  while (1) {
    while_continue: /* CIL Label */ ;
#line 75
    if (! (i___3 < (int )nins)) {
#line 75
      goto while_break;
    }
    {
#line 77
    fseek(in, 4L, 1);
#line 79
    fwrite((void const   */* __restrict  */)tmp, (size_t )22, (size_t )1, (FILE */* __restrict  */)out);
#line 81
    fread((void */* __restrict  */)(& c1), (size_t )1, (size_t )1, (FILE */* __restrict  */)in);
#line 82
    fread((void */* __restrict  */)(& c2), (size_t )1, (size_t )1, (FILE */* __restrict  */)in);
#line 83
    fwrite((void const   */* __restrict  */)(& c1), (size_t )1, (size_t )1, (FILE */* __restrict  */)out);
#line 84
    fwrite((void const   */* __restrict  */)(& c2), (size_t )1, (size_t )1, (FILE */* __restrict  */)out);
#line 85
    ssize += (((int )c1 << 8) + (int )c2) * 2;
#line 87
    fread((void */* __restrict  */)(& c1), (size_t )1, (size_t )1, (FILE */* __restrict  */)in);
#line 88
    fwrite((void const   */* __restrict  */)(& c1), (size_t )1, (size_t )1, (FILE */* __restrict  */)out);
#line 90
    fread((void */* __restrict  */)(& c1), (size_t )1, (size_t )1, (FILE */* __restrict  */)in);
#line 91
    fwrite((void const   */* __restrict  */)(& c1), (size_t )1, (size_t )1, (FILE */* __restrict  */)out);
#line 93
    fseek(in, 4L, 1);
#line 95
    fread((void */* __restrict  */)(& c1), (size_t )1, (size_t )1, (FILE */* __restrict  */)in);
#line 96
    fread((void */* __restrict  */)(& c2), (size_t )1, (size_t )1, (FILE */* __restrict  */)in);
#line 98
    fread((void */* __restrict  */)(& c3), (size_t )1, (size_t )1, (FILE */* __restrict  */)in);
#line 99
    fread((void */* __restrict  */)(& c4), (size_t )1, (size_t )1, (FILE */* __restrict  */)in);
#line 101
    c4 = (uint8 )((int )c4 / 2);
    }
#line 102
    if (((int )c3 / 2) * 2 != (int )c3) {
#line 103
      if ((int )c4 < 128) {
#line 104
        c4 = (uint8 )((int )c4 + 128);
      } else {
#line 106
        c4 = (uint8 )((int )c4 - 128);
#line 107
        c3 = (uint8 )((int )c3 + 1);
      }
    }
    {
#line 110
    c3 = (uint8 )((int )c3 / 2);
#line 111
    fwrite((void const   */* __restrict  */)(& c3), (size_t )1, (size_t )1, (FILE */* __restrict  */)out);
#line 112
    fwrite((void const   */* __restrict  */)(& c4), (size_t )1, (size_t )1, (FILE */* __restrict  */)out);
#line 114
    fwrite((void const   */* __restrict  */)(& c1), (size_t )1, (size_t )1, (FILE */* __restrict  */)out);
#line 115
    fwrite((void const   */* __restrict  */)(& c2), (size_t )1, (size_t )1, (FILE */* __restrict  */)out);
#line 75
    i___3 ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 120
  free((void *)tmp);
#line 121
  tmp___2 = malloc((size_t )30);
#line 121
  tmp = (uint8 *)tmp___2;
#line 122
  memset((void *)tmp, 0, (size_t )30);
#line 123
  *(tmp + 29) = (uint8 )1;
  }
  {
#line 124
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 124
    if (! (i___3 != 31)) {
#line 124
      goto while_break___0;
    }
    {
#line 125
    fwrite((void const   */* __restrict  */)tmp, (size_t )30, (size_t )1, (FILE */* __restrict  */)out);
#line 126
    i___3 ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 128
  free((void *)tmp);
#line 131
  fwrite((void const   */* __restrict  */)(& npos), (size_t )1, (size_t )1, (FILE */* __restrict  */)out);
#line 134
  c1 = (uint8 )127;
#line 135
  fwrite((void const   */* __restrict  */)(& c1), (size_t )1, (size_t )1, (FILE */* __restrict  */)out);
#line 138
  fseek(in, 2L, 1);
#line 141
  fseek(in, 2L, 1);
#line 144
  pat_max = (uint8 )0;
#line 145
  i___3 = 0;
  }
  {
#line 145
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 145
    if (! (i___3 < (int )npos)) {
#line 145
      goto while_break___1;
    }
    {
#line 146
    fread((void */* __restrict  */)(& c1), (size_t )1, (size_t )1, (FILE */* __restrict  */)in);
#line 147
    fread((void */* __restrict  */)(& c2), (size_t )1, (size_t )1, (FILE */* __restrict  */)in);
#line 148
    ptable[i___3] = (uint8 )((((int )c1 << 8) + (int )c2) / 8);
    }
#line 149
    if ((int )ptable[i___3] > (int )pat_max) {
#line 150
      pat_max = ptable[i___3];
    }
#line 145
    i___3 ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 152
  pat_max = (uint8 )((int )pat_max + 1);
#line 156
  fwrite((void const   */* __restrict  */)(ptable), (size_t )128, (size_t )1, (FILE */* __restrict  */)out);
#line 159
  c1 = (uint8 )'M';
#line 160
  c2 = (uint8 )'.';
#line 161
  c3 = (uint8 )'K';
#line 162
  fwrite((void const   */* __restrict  */)(& c1), (size_t )1, (size_t )1, (FILE */* __restrict  */)out);
#line 163
  fwrite((void const   */* __restrict  */)(& c2), (size_t )1, (size_t )1, (FILE */* __restrict  */)out);
#line 164
  fwrite((void const   */* __restrict  */)(& c3), (size_t )1, (size_t )1, (FILE */* __restrict  */)out);
#line 165
  fwrite((void const   */* __restrict  */)(& c2), (size_t )1, (size_t )1, (FILE */* __restrict  */)out);
#line 168
  i___3 = 0;
  }
  {
#line 168
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 168
    if (! (i___3 < (int )pat_max)) {
#line 168
      goto while_break___2;
    }
    {
#line 169
    fread((void */* __restrict  */)(& c1), (size_t )1, (size_t )1, (FILE */* __restrict  */)in);
#line 170
    fread((void */* __restrict  */)(& c2), (size_t )1, (size_t )1, (FILE */* __restrict  */)in);
#line 171
    taddr[i___3][0] = ((int )c1 << 8) + (int )c2;
    }
#line 172
    if (taddr[i___3][0] > Max_Add) {
#line 173
      Max_Add = taddr[i___3][0];
    }
    {
#line 174
    fread((void */* __restrict  */)(& c1), (size_t )1, (size_t )1, (FILE */* __restrict  */)in);
#line 175
    fread((void */* __restrict  */)(& c2), (size_t )1, (size_t )1, (FILE */* __restrict  */)in);
#line 176
    taddr[i___3][1] = ((int )c1 << 8) + (int )c2;
    }
#line 177
    if (taddr[i___3][1] > Max_Add) {
#line 178
      Max_Add = taddr[i___3][1];
    }
    {
#line 179
    fread((void */* __restrict  */)(& c1), (size_t )1, (size_t )1, (FILE */* __restrict  */)in);
#line 180
    fread((void */* __restrict  */)(& c2), (size_t )1, (size_t )1, (FILE */* __restrict  */)in);
#line 181
    taddr[i___3][2] = ((int )c1 << 8) + (int )c2;
    }
#line 182
    if (taddr[i___3][2] > Max_Add) {
#line 183
      Max_Add = taddr[i___3][2];
    }
    {
#line 184
    fread((void */* __restrict  */)(& c1), (size_t )1, (size_t )1, (FILE */* __restrict  */)in);
#line 185
    fread((void */* __restrict  */)(& c2), (size_t )1, (size_t )1, (FILE */* __restrict  */)in);
#line 186
    taddr[i___3][3] = ((int )c1 << 8) + (int )c2;
    }
#line 187
    if (taddr[i___3][3] > Max_Add) {
#line 188
      Max_Add = taddr[i___3][3];
    }
#line 168
    i___3 ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 190
  tmp___3 = ftell(in);
#line 190
  tdata = (int )tmp___3;
#line 193
  tmp___4 = malloc((size_t )1024);
#line 193
  tmp = (uint8 *)tmp___4;
#line 194
  i___3 = 0;
  }
  {
#line 194
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 194
    if (! (i___3 < (int )pat_max)) {
#line 194
      goto while_break___3;
    }
    {
#line 195
    memset((void *)tmp, 0, (size_t )1024);
#line 196
    j = 0;
    }
    {
#line 196
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 196
      if (! (j < 4)) {
#line 196
        goto while_break___4;
      }
      {
#line 197
      fseek(in, (long )(tdata + taddr[i___3][3 - j]), 0);
#line 200
      k = 0;
      }
      {
#line 200
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 200
        if (! (k < 64)) {
#line 200
          goto while_break___5;
        }
        {
#line 201
        fread((void */* __restrict  */)(& c1), (size_t )1, (size_t )1, (FILE */* __restrict  */)in);
#line 202
        fread((void */* __restrict  */)(& c2), (size_t )1, (size_t )1, (FILE */* __restrict  */)in);
#line 203
        fread((void */* __restrict  */)(& c3), (size_t )1, (size_t )1, (FILE */* __restrict  */)in);
#line 204
        *(tmp + (k * 16 + j * 4)) = (uint8 )(((int )c1 << 4) & 16);
#line 205
        c4 = (uint8 )(((int )c1 & 254) / 2);
#line 206
        *(tmp + (k * 16 + j * 4)) = (uint8 )((int )*(tmp + (k * 16 + j * 4)) | (int )ptk_table[c4][0]);
#line 207
        *(tmp + ((k * 16 + j * 4) + 1)) = (uint8 )ptk_table[c4][1];
        }
#line 208
        if (((int )c2 & 15) == 8) {
#line 209
          c2 = (uint8 )((int )c2 & 240);
        }
#line 210
        if (((int )c2 & 15) == 7) {
#line 211
          c2 = (uint8 )(((int )c2 & 240) + 10);
#line 212
          if ((int )c3 > 128) {
#line 213
            c3 = (uint8 )(256 - (int )c3);
          } else {
#line 215
            c3 = (uint8 )(((int )c3 << 4) & 240);
          }
        }
#line 217
        if (((int )c2 & 15) == 6) {
#line 218
          if ((int )c3 > 128) {
#line 219
            c3 = (uint8 )(256 - (int )c3);
          } else {
#line 221
            c3 = (uint8 )(((int )c3 << 4) & 240);
          }
        }
#line 223
        if (((int )c2 & 15) == 5) {
#line 224
          if ((int )c3 > 128) {
#line 225
            c3 = (uint8 )(256 - (int )c3);
          } else {
#line 227
            c3 = (uint8 )(((int )c3 << 4) & 240);
          }
        }
#line 229
        if (((int )c2 & 15) == 11) {
#line 230
          c3 = (uint8 )((int )c3 + 4);
#line 231
          c3 = (uint8 )((int )c3 / 2);
        }
#line 233
        *(tmp + ((k * 16 + j * 4) + 2)) = c2;
#line 234
        *(tmp + ((k * 16 + j * 4) + 3)) = c3;
#line 200
        k ++;
      }
      while_break___5: /* CIL Label */ ;
      }
#line 196
      j ++;
    }
    while_break___4: /* CIL Label */ ;
    }
    {
#line 237
    fwrite((void const   */* __restrict  */)tmp, (size_t )1024, (size_t )1, (FILE */* __restrict  */)out);
#line 194
    i___3 ++;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 239
  free((void *)tmp);
#line 242
  fseek(in, (long )((Max_Add + 192) + tdata), 0);
#line 243
  tmp___5 = malloc((size_t )ssize);
#line 243
  tmp = (uint8 *)tmp___5;
#line 244
  memset((void *)tmp, 0, (size_t )ssize);
#line 245
  fread((void */* __restrict  */)tmp, (size_t )ssize, (size_t )1, (FILE */* __restrict  */)in);
#line 246
  fwrite((void const   */* __restrict  */)tmp, (size_t )ssize, (size_t )1, (FILE */* __restrict  */)out);
#line 247
  free((void *)tmp);
  }
#line 249
  return (0);
}
}
#line 252 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/prowizard/np1.c"
static int test_np1(uint8 *data , int s ) 
{ 
  int j ;
  int k ;
  int l ;
  int m___0 ;
  int n___0 ;
  int o___0 ;
  int start ;
  int ssize ;

  {
#line 255
  start = 0;
#line 258
  j = ((int )*(data + (start + 2)) << 8) + (int )*(data + (start + 3));
#line 259
  if ((j / 2) * 2 != j) {
#line 260
    return (-1);
  } else
#line 259
  if (j == 0) {
#line 260
    return (-1);
  }
#line 263
  if (((int )*(data + (start + 1)) & 15) != 12) {
#line 264
    return (-1);
  }
#line 266
  l = (((int )*(data + start) << 4) & 240) | (((int )*(data + (start + 1)) >> 4) & 15);
#line 267
  if (l > 31) {
#line 268
    return (-1);
  } else
#line 267
  if (l == 0) {
#line 268
    return (-1);
  }
  {
#line 271
  while (1) {
    while_continue: /* CIL Label */ ;
#line 271
    if (s < (start + 15) + l * 16) {
#line 271
      return (((start + 15) + l * 16) - s);
    }
#line 271
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 274
  k = 0;
  {
#line 274
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 274
    if (! (k < l)) {
#line 274
      goto while_break___0;
    }
#line 275
    if ((int )*(data + ((start + 15) + k * 16)) > 64) {
#line 276
      return (-1);
    }
#line 274
    k ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 280
  ssize = 0;
#line 281
  k = 0;
  {
#line 281
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 281
    if (! (k < l)) {
#line 281
      goto while_break___1;
    }
#line 282
    o___0 = ((int )*(data + ((start + k * 16) + 12)) << 8) + (int )*(data + ((start + k * 16) + 13));
#line 283
    m___0 = ((int )*(data + ((start + k * 16) + 20)) << 8) + (int )*(data + ((start + k * 16) + 21));
#line 284
    n___0 = ((int )*(data + ((start + k * 16) + 22)) << 8) + (int )*(data + ((start + k * 16) + 23));
#line 285
    o___0 *= 2;
#line 286
    m___0 *= 2;
#line 288
    if (o___0 > 65535) {
#line 289
      return (-1);
    } else
#line 288
    if (m___0 > 65535) {
#line 289
      return (-1);
    } else
#line 288
    if (n___0 > 65535) {
#line 289
      return (-1);
    }
#line 291
    if (m___0 + n___0 > o___0 + 2) {
#line 292
      return (-1);
    }
#line 294
    if (n___0 != 0) {
#line 294
      if (m___0 == 0) {
#line 295
        return (-1);
      }
    }
#line 297
    ssize += o___0;
#line 281
    k ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 300
  if (ssize <= 4) {
#line 301
    return (-1);
  }
#line 304
  l *= 16;
#line 305
  l += 8;
#line 306
  l += 4;
#line 310
  n___0 = 0;
#line 311
  k = 0;
  {
#line 311
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 311
    if (! (k < j)) {
#line 311
      goto while_break___2;
    }
#line 312
    m___0 = ((int )*(data + ((start + l) + k)) << 8) + (int )*(data + (((start + l) + k) + 1));
#line 313
    if ((m___0 / 8) * 8 != m___0) {
#line 314
      return (-1);
    }
#line 315
    if (m___0 > n___0) {
#line 316
      n___0 = m___0;
    }
#line 311
    k += 2;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 319
  l += j;
#line 320
  l += n___0;
#line 321
  l += 8;
#line 326
  k = ((int )*(data + (start + 6)) << 8) + (int )*(data + (start + 7));
#line 327
  if (k < 192) {
#line 328
    return (-1);
  } else
#line 327
  if ((k / 192) * 192 != k) {
#line 328
    return (-1);
  }
  {
#line 330
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 330
    if (s < (start + l) + k) {
#line 330
      return (((start + l) + k) - s);
    }
#line 330
    goto while_break___3;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 333
  m___0 = 0;
  {
#line 333
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 333
    if (! (m___0 < k)) {
#line 333
      goto while_break___4;
    }
#line 334
    if ((int )*(data + ((start + l) + m___0)) > 73) {
#line 335
      return (-1);
    }
#line 333
    m___0 += 3;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 342
  return (0);
}
}
#line 66 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/prowizard/prowiz.h"
struct pw_format pw_mp_id ;
#line 67
struct pw_format pw_mp_noid ;
#line 15 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/prowizard/mp.c"
static int depack_mp(FILE *in , FILE *out ) ;
#line 16
static int test_mp_id(uint8 *data , int s ) ;
#line 17
static int test_mp_noid(uint8 *data , int s ) ;
#line 19 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/prowizard/mp.c"
struct pw_format pw_mp_id  =    {(char *)"MP", (char *)"Module Protector", 0, & test_mp_id, & depack_mp, 0, {(struct list_head *)0,
                                                                                (struct list_head *)0}};
#line 27 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/prowizard/mp.c"
struct pw_format pw_mp_noid  =    {(char *)"MP", (char *)"Module Protector noID", 0, & test_mp_noid, & depack_mp,
    0, {(struct list_head *)0, (struct list_head *)0}};
#line 36 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/prowizard/mp.c"
static int depack_mp(FILE *in , FILE *out ) 
{ 
  uint8 c1 ;
  uint8 ptable[128] ;
  uint8 max ;
  int i___3 ;
  int size___0 ;
  int ssize ;
  uint32 tmp ;
  uint16 tmp___0 ;
  uint8 tmp___1 ;
  uint8 tmp___2 ;
  uint16 tmp___3 ;
  uint16 tmp___4 ;
  uint8 tmp___5 ;
  uint8 tmp___6 ;
  uint32 tmp___7 ;
  void *__cil_tmp18 ;

  {
  {
#line 42
  ssize = 0;
#line 44
  memset((void *)(ptable), 0, (size_t )128);
#line 46
  pw_write_zero(out, 20);
#line 48
  tmp = read32b(in);
  }
#line 48
  if (tmp != ((((84U << 24) | (82U << 16)) | (75U << 8)) | 49U)) {
    {
#line 49
    fseek(in, -4L, 1);
    }
  }
#line 51
  i___3 = 0;
  {
#line 51
  while (1) {
    while_continue: /* CIL Label */ ;
#line 51
    if (! (i___3 < 31)) {
#line 51
      goto while_break;
    }
    {
#line 52
    pw_write_zero(out, 22);
#line 53
    tmp___0 = read16b(in);
#line 53
    size___0 = (int )tmp___0;
#line 53
    write16b(out, (uint16 )size___0);
#line 54
    ssize += size___0 * 2;
#line 55
    tmp___1 = read8(in);
#line 55
    write8(out, tmp___1);
#line 56
    tmp___2 = read8(in);
#line 56
    write8(out, tmp___2);
#line 57
    tmp___3 = read16b(in);
#line 57
    write16b(out, tmp___3);
#line 58
    tmp___4 = read16b(in);
#line 58
    write16b(out, tmp___4);
#line 51
    i___3 ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 61
  tmp___5 = read8(in);
#line 61
  write8(out, tmp___5);
#line 62
  tmp___6 = read8(in);
#line 62
  write8(out, tmp___6);
#line 64
  i___3 = 0;
#line 64
  max = (uint8 )i___3;
  }
  {
#line 64
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 64
    if (! (i___3 < 128)) {
#line 64
      goto while_break___0;
    }
    {
#line 65
    c1 = read8(in);
#line 65
    write8(out, c1);
    }
#line 66
    if ((int )c1 > (int )max) {
#line 67
      max = c1;
    }
#line 64
    i___3 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 69
  max = (uint8 )((int )max + 1);
#line 71
  write32b(out, (((77U << 24) | (46U << 16)) | (75U << 8)) | 46U);
#line 73
  tmp___7 = read32b(in);
  }
#line 73
  if (tmp___7 != 0U) {
    {
#line 74
    fseek(in, -4L, 1);
    }
  }
  {
#line 76
  pw_move_data(out, in, 1024 * (int )max);
#line 77
  pw_move_data(out, in, ssize);
  }
#line 79
  return (0);
}
}
#line 83 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/prowizard/mp.c"
static int test_mp_noid(uint8 *data , int s ) 
{ 
  int start ;
  int ssize ;
  int j ;
  int k ;
  int l ;
  int m___0 ;
  int n___0 ;
  int x ;
  uint16 tmp ;
  uint16 tmp___0 ;
  uint16 tmp___1 ;
  int x___0 ;
  int x___1 ;
  uint16 tmp___2 ;
  uint16 tmp___3 ;
  uint16 tmp___4 ;

  {
#line 88
  start = 0;
#line 98
  l = 0;
#line 99
  j = 0;
  {
#line 99
  while (1) {
    while_continue: /* CIL Label */ ;
#line 99
    if (! (j < 31)) {
#line 99
      goto while_break;
    }
    {
#line 100
    x = start + 8 * j;
#line 102
    tmp = readmem16b(data + x);
#line 102
    k = (int )tmp * 2;
#line 103
    tmp___0 = readmem16b((data + x) + 4);
#line 103
    m___0 = (int )tmp___0 * 2;
#line 104
    tmp___1 = readmem16b((data + x) + 6);
#line 104
    n___0 = (int )tmp___1 * 2;
#line 105
    l += k;
    }
#line 108
    if ((int )*(data + (x + 2)) > 15) {
#line 109
      return (-1);
    }
#line 112
    if (n___0 != 2) {
#line 112
      if (m___0 + n___0 > k) {
#line 113
        return (-1);
      }
    }
#line 116
    if (n___0 > k + 2) {
#line 117
      return (-1);
    }
#line 120
    if (m___0 != 0) {
#line 120
      if (n___0 <= 2) {
#line 121
        return (-1);
      }
    }
#line 124
    if (k != 0) {
#line 124
      if (n___0 == 0) {
#line 125
        return (-1);
      }
    }
#line 99
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 128
  if (l <= 2) {
#line 129
    return (-1);
  }
#line 132
  l = (int )*(data + (start + 248));
#line 133
  if (l > 127) {
#line 134
    return (-1);
  } else
#line 133
  if (l == 0) {
#line 134
    return (-1);
  }
#line 138
  k = 0;
#line 139
  j = 0;
  {
#line 139
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 139
    if (! (j < 128)) {
#line 139
      goto while_break___0;
    }
#line 140
    if ((int )*(data + ((start + 250) + j)) > k) {
#line 141
      k = (int )*(data + ((start + 250) + j));
    }
#line 142
    if ((int )*(data + ((start + 250) + j)) > 127) {
#line 143
      return (-1);
    }
#line 144
    if (j > l + 3) {
#line 145
      if ((int )*(data + ((start + 250) + j)) != 0) {
#line 146
        return (-1);
      }
    }
#line 139
    j ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 149
  k ++;
#line 153
  j = 0;
  {
#line 153
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 153
    if (! (j < 256 * k)) {
#line 153
      goto while_break___1;
    }
#line 154
    x___0 = start + j * 4;
#line 156
    l = (int )*(data + (x___0 + 378));
#line 157
    if (l > 19) {
#line 157
      if (l != 74) {
#line 158
        return (-1);
      }
    }
#line 160
    ssize = (int )*(data + (x___0 + 378)) & 15;
#line 161
    ssize *= 256;
#line 162
    ssize += (int )*(data + (x___0 + 379));
#line 164
    if (ssize > 0) {
#line 164
      if (ssize < 113) {
#line 165
        return (-1);
      }
    }
#line 153
    j ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 169
  j = 0;
  {
#line 169
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 169
    if (! (j < 31)) {
#line 169
      goto while_break___2;
    }
    {
#line 170
    x___1 = start + j * 8;
#line 172
    tmp___2 = readmem16b(data + x___1);
#line 172
    k = (int )tmp___2 * 2;
#line 173
    tmp___3 = readmem16b((data + x___1) + 4);
#line 173
    tmp___4 = readmem16b((data + x___1) + 6);
#line 173
    l = ((int )tmp___3 + (int )tmp___4) * 2;
    }
#line 175
    if (l > k + 2) {
#line 176
      return (-1);
    }
#line 169
    j ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 179
  return (0);
}
}
#line 183 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/prowizard/mp.c"
static int test_mp_id(uint8 *data , int s ) 
{ 
  int j ;
  int l ;
  int k ;
  int start ;
  uint32 tmp ;

  {
  {
#line 186
  start = 0;
#line 189
  tmp = readmem32b(data);
  }
#line 189
  if (tmp != ((((84U << 24) | (82U << 16)) | (75U << 8)) | 49U)) {
#line 190
    return (-1);
  }
#line 193
  j = 0;
  {
#line 193
  while (1) {
    while_continue: /* CIL Label */ ;
#line 193
    if (! (j < 31)) {
#line 193
      goto while_break;
    }
#line 194
    if ((int )*(data + ((start + 6) + 8 * j)) > 15) {
#line 195
      return (-1);
    }
#line 193
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 199
  l = (int )*(data + (start + 252));
#line 200
  if (l > 127) {
#line 201
    return (-1);
  } else
#line 200
  if (l == 0) {
#line 201
    return (-1);
  }
#line 204
  k = 0;
#line 205
  j = 0;
  {
#line 205
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 205
    if (! (j < 128)) {
#line 205
      goto while_break___0;
    }
#line 206
    if ((int )*(data + ((start + 254) + j)) > k) {
#line 207
      k = (int )*(data + ((start + 254) + j));
    }
#line 208
    if ((int )*(data + ((start + 254) + j)) > 127) {
#line 209
      return (-1);
    }
#line 205
    j ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 211
  k ++;
#line 215
  j = 0;
  {
#line 215
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 215
    if (! (j < 256 * k)) {
#line 215
      goto while_break___1;
    }
#line 216
    l = (int )*(data + ((start + 382) + j * 4));
#line 217
    if (l > 19) {
#line 218
      return (-1);
    }
#line 215
    j ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 221
  return (0);
}
}
#line 65 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/prowizard/prowiz.h"
struct pw_format pw_ksm ;
#line 13 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/prowizard/ksm.c"
static int test_ksm(uint8 *data , int s ) ;
#line 14
static int depack_ksm(FILE *in , FILE *out ) ;
#line 16 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/prowizard/ksm.c"
struct pw_format pw_ksm  =    {(char *)"KSM", (char *)"Kefrens Sound Machine", 0, & test_ksm, & depack_ksm, 0,
    {(struct list_head *)0, (struct list_head *)0}};
#line 28 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/prowizard/ksm.c"
static int depack_ksm(FILE *in , FILE *out ) 
{ 
  uint8 tmp[1024] ;
  uint8 c1 ;
  uint8 c5 ;
  uint8 plist[128] ;
  uint8 trknum[128][4] ;
  uint8 real_tnum[128][4] ;
  uint8 tdata[4][192] ;
  uint8 Max ;
  uint8 PatPos ;
  uint8 Status ;
  int ssize ;
  int i___3 ;
  int j ;
  int k ;
  uint16 tmp___0 ;
  uint8 tmp___1 ;
  uint16 tmp___2 ;
  int tmp___3 ;
  int x ;
  void *__cil_tmp22 ;
  void *__cil_tmp23 ;
  void *__cil_tmp24 ;
  int __cil_tmp25 ;
  void *__cil_tmp26 ;
  void *__cil_tmp27 ;
  int __cil_tmp28 ;
  void *__cil_tmp29 ;
  void *__cil_tmp30 ;
  int __cil_tmp31 ;
  void *__cil_tmp32 ;

  {
  {
#line 38
  Status = (uint8 )1;
#line 39
  ssize = 0;
#line 42
  memset((void *)(plist), 0, (size_t )128);
#line 43
  memset((void *)(trknum), 0, (size_t )512);
#line 44
  memset((void *)(real_tnum), 0, (size_t )512);
#line 47
  fseek(in, 2L, 0);
#line 48
  pw_move_data(out, in, 13);
#line 49
  pw_write_zero(out, 7);
#line 53
  fseek(in, 32L, 0);
#line 54
  i___3 = 0;
  }
  {
#line 54
  while (1) {
    while_continue: /* CIL Label */ ;
#line 54
    if (! (i___3 < 15)) {
#line 54
      goto while_break;
    }
    {
#line 55
    pw_write_zero(out, 22);
#line 56
    fseek(in, 20L, 1);
#line 57
    tmp___0 = read16b(in);
#line 57
    k = (int )tmp___0;
#line 57
    write16b(out, (uint16 )(k / 2));
#line 58
    ssize += k;
#line 59
    write8(out, (uint8 )0);
#line 60
    tmp___1 = read8(in);
#line 60
    write8(out, tmp___1);
#line 61
    read8(in);
#line 62
    tmp___2 = read16b(in);
#line 62
    j = (int )tmp___2;
#line 62
    write16b(out, (uint16 )(j / 2));
#line 63
    j = k - j;
    }
#line 64
    if (j != k) {
#line 64
      tmp___3 = j / 2;
    } else {
#line 64
      tmp___3 = 1;
    }
    {
#line 64
    write16b(out, (uint16 )tmp___3);
#line 65
    fseek(in, 6L, 1);
#line 54
    i___3 ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 68
  memset((void *)(tmp), 0, (size_t )30);
#line 69
  tmp[29] = (uint8 )1;
#line 70
  i___3 = 0;
  }
  {
#line 70
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 70
    if (! (i___3 < 16)) {
#line 70
      goto while_break___0;
    }
    {
#line 71
    fwrite((void const   */* __restrict  */)(tmp), (size_t )30, (size_t )1, (FILE */* __restrict  */)out);
#line 70
    i___3 ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 74
  fseek(in, 512L, 0);
#line 75
  PatPos = (uint8 )0;
#line 75
  Max = PatPos;
  }
  {
#line 75
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 75
    if (! ((int )PatPos < 128)) {
#line 75
      goto while_break___1;
    }
    {
#line 76
    fread((void */* __restrict  */)(& trknum[PatPos][0]), (size_t )1, (size_t )1,
          (FILE */* __restrict  */)in);
#line 77
    fread((void */* __restrict  */)(& trknum[PatPos][1]), (size_t )1, (size_t )1,
          (FILE */* __restrict  */)in);
#line 78
    fread((void */* __restrict  */)(& trknum[PatPos][2]), (size_t )1, (size_t )1,
          (FILE */* __restrict  */)in);
#line 79
    fread((void */* __restrict  */)(& trknum[PatPos][3]), (size_t )1, (size_t )1,
          (FILE */* __restrict  */)in);
    }
#line 80
    if ((int )trknum[PatPos][0] == 255) {
#line 81
      goto while_break___1;
    }
#line 82
    if ((int )trknum[PatPos][0] > (int )Max) {
#line 83
      Max = trknum[PatPos][0];
    }
#line 84
    if ((int )trknum[PatPos][1] > (int )Max) {
#line 85
      Max = trknum[PatPos][1];
    }
#line 86
    if ((int )trknum[PatPos][2] > (int )Max) {
#line 87
      Max = trknum[PatPos][2];
    }
#line 88
    if ((int )trknum[PatPos][3] > (int )Max) {
#line 89
      Max = trknum[PatPos][3];
    }
#line 75
    PatPos = (uint8 )((int )PatPos + 1);
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 92
  write8(out, PatPos);
#line 93
  write8(out, (uint8 )127);
#line 96
  c5 = (uint8 )0;
#line 97
  i___3 = 0;
  }
  {
#line 97
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 97
    if (! (i___3 < (int )PatPos)) {
#line 97
      goto while_break___2;
    }
#line 98
    if (i___3 == 0) {
#line 99
      plist[0] = c5;
#line 100
      c5 = (uint8 )((int )c5 + 1);
#line 101
      goto __Cont;
    }
#line 103
    j = 0;
    {
#line 103
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 103
      if (! (j < i___3)) {
#line 103
        goto while_break___3;
      }
#line 104
      Status = (uint8 )1;
#line 105
      k = 0;
      {
#line 105
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 105
        if (! (k < 4)) {
#line 105
          goto while_break___4;
        }
#line 106
        if ((int )trknum[j][k] != (int )trknum[i___3][k]) {
#line 108
          Status = (uint8 )2;
#line 109
          goto while_break___4;
        }
#line 105
        k ++;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 112
      if ((int )Status == 1) {
#line 113
        plist[i___3] = plist[j];
#line 114
        goto while_break___3;
      }
#line 103
      j ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 117
    if ((int )Status == 2) {
#line 118
      plist[i___3] = c5;
#line 119
      c5 = (uint8 )((int )c5 + 1);
    }
#line 121
    Status = (uint8 )1;
    __Cont: /* CIL Label */ 
#line 97
    i___3 ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 126
  c1 = (uint8 )0;
#line 127
  i___3 = 0;
  {
#line 127
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 127
    if (! (i___3 < (int )PatPos)) {
#line 127
      goto while_break___5;
    }
#line 128
    if (i___3 == 0) {
#line 129
      real_tnum[c1][0] = trknum[i___3][0];
#line 130
      real_tnum[c1][1] = trknum[i___3][1];
#line 131
      real_tnum[c1][2] = trknum[i___3][2];
#line 132
      real_tnum[c1][3] = trknum[i___3][3];
#line 133
      c1 = (uint8 )((int )c1 + 1);
#line 134
      goto __Cont___0;
    }
#line 136
    j = 0;
    {
#line 136
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 136
      if (! (j < i___3)) {
#line 136
        goto while_break___6;
      }
#line 137
      Status = (uint8 )1;
#line 138
      if ((int )plist[i___3] == (int )plist[j]) {
#line 139
        Status = (uint8 )2;
#line 140
        goto while_break___6;
      }
#line 136
      j ++;
    }
    while_break___6: /* CIL Label */ ;
    }
#line 143
    if ((int )Status == 2) {
#line 144
      goto __Cont___0;
    }
#line 145
    real_tnum[c1][0] = trknum[i___3][0];
#line 146
    real_tnum[c1][1] = trknum[i___3][1];
#line 147
    real_tnum[c1][2] = trknum[i___3][2];
#line 148
    real_tnum[c1][3] = trknum[i___3][3];
#line 149
    c1 = (uint8 )((int )c1 + 1);
#line 150
    Status = (uint8 )1;
    __Cont___0: /* CIL Label */ 
#line 127
    i___3 ++;
  }
  while_break___5: /* CIL Label */ ;
  }
  {
#line 153
  fwrite((void const   */* __restrict  */)(plist), (size_t )128, (size_t )1, (FILE */* __restrict  */)out);
#line 154
  write32b(out, (((77U << 24) | (46U << 16)) | (75U << 8)) | 46U);
#line 157
  i___3 = 0;
  }
  {
#line 157
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 157
    if (! (i___3 < (int )c5)) {
#line 157
      goto while_break___7;
    }
    {
#line 158
    memset((void *)(tmp), 0, (size_t )1024);
#line 159
    memset((void *)(tdata), 0, (size_t )768);
#line 160
    fseek(in, (long )(1536 + 192 * (int )real_tnum[i___3][0]), 0);
#line 161
    fread((void */* __restrict  */)(tdata[0]), (size_t )192, (size_t )1, (FILE */* __restrict  */)in);
#line 162
    fseek(in, (long )(1536 + 192 * (int )real_tnum[i___3][1]), 0);
#line 163
    fread((void */* __restrict  */)(tdata[1]), (size_t )192, (size_t )1, (FILE */* __restrict  */)in);
#line 164
    fseek(in, (long )(1536 + 192 * (int )real_tnum[i___3][2]), 0);
#line 165
    fread((void */* __restrict  */)(tdata[2]), (size_t )192, (size_t )1, (FILE */* __restrict  */)in);
#line 166
    fseek(in, (long )(1536 + 192 * (int )real_tnum[i___3][3]), 0);
#line 167
    fread((void */* __restrict  */)(tdata[3]), (size_t )192, (size_t )1, (FILE */* __restrict  */)in);
#line 169
    j = 0;
    }
    {
#line 169
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 169
      if (! (j < 64)) {
#line 169
        goto while_break___8;
      }
#line 170
      x = j * 16;
#line 172
      tmp[x] = (uint8 )ptk_table[tdata[0][j * 3]][0];
#line 173
      tmp[x + 1] = (uint8 )ptk_table[tdata[0][j * 3]][1];
#line 174
      if (((int )tdata[0][j * 3 + 1] & 15) == 13) {
#line 175
        tdata[0][j * 3 + 1] = (uint8 )((int )tdata[0][j * 3 + 1] - 3);
      }
#line 176
      tmp[x + 2] = tdata[0][j * 3 + 1];
#line 177
      tmp[x + 3] = tdata[0][j * 3 + 2];
#line 179
      tmp[x + 4] = (uint8 )ptk_table[tdata[1][j * 3]][0];
#line 180
      tmp[x + 5] = (uint8 )ptk_table[tdata[1][j * 3]][1];
#line 181
      if (((int )tdata[1][j * 3 + 1] & 15) == 13) {
#line 182
        tdata[1][j * 3 + 1] = (uint8 )((int )tdata[1][j * 3 + 1] - 3);
      }
#line 183
      tmp[x + 6] = tdata[1][j * 3 + 1];
#line 184
      tmp[x + 7] = tdata[1][j * 3 + 2];
#line 186
      tmp[x + 8] = (uint8 )ptk_table[tdata[2][j * 3]][0];
#line 187
      tmp[x + 9] = (uint8 )ptk_table[tdata[2][j * 3]][1];
#line 188
      if (((int )tdata[2][j * 3 + 1] & 15) == 13) {
#line 189
        tdata[2][j * 3 + 1] = (uint8 )((int )tdata[2][j * 3 + 1] - 3);
      }
#line 190
      tmp[x + 10] = tdata[2][j * 3 + 1];
#line 191
      tmp[x + 11] = tdata[2][j * 3 + 2];
#line 193
      tmp[x + 12] = (uint8 )ptk_table[tdata[3][j * 3]][0];
#line 194
      tmp[x + 13] = (uint8 )ptk_table[tdata[3][j * 3]][1];
#line 195
      if (((int )tdata[3][j * 3 + 1] & 15) == 13) {
#line 196
        tdata[3][j * 3 + 1] = (uint8 )((int )tdata[3][j * 3 + 1] - 3);
      }
#line 197
      tmp[x + 14] = tdata[3][j * 3 + 1];
#line 198
      tmp[x + 15] = tdata[3][j * 3 + 2];
#line 169
      j ++;
    }
    while_break___8: /* CIL Label */ ;
    }
    {
#line 201
    fwrite((void const   */* __restrict  */)(tmp), (size_t )1024, (size_t )1, (FILE */* __restrict  */)out);
#line 157
    i___3 ++;
    }
  }
  while_break___7: /* CIL Label */ ;
  }
  {
#line 205
  fseek(in, (long )(1536 + 192 * ((int )Max + 1)), 0);
#line 206
  pw_move_data(out, in, ssize);
  }
#line 208
  return (0);
}
}
#line 211 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/prowizard/ksm.c"
static int test_ksm(uint8 *data , int s ) 
{ 
  int j ;
  int k ;
  int l ;
  int start ;

  {
#line 214
  start = 0;
  {
#line 216
  while (1) {
    while_continue: /* CIL Label */ ;
#line 216
    if (s < 1536) {
#line 216
      return (1536 - s);
    }
#line 216
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 218
  if ((int )*(data + start) != 77) {
#line 219
    return (-1);
  } else
#line 218
  if ((int )*(data + (start + 1)) != 46) {
#line 219
    return (-1);
  }
#line 222
  if ((int )*(data + (start + 15)) != 97) {
#line 223
    return (-1);
  }
#line 226
  k = 0;
  {
#line 226
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 226
    if (! (k < 15)) {
#line 226
      goto while_break___0;
    }
#line 227
    if ((int )*(data + ((start + 54) + k * 32)) > 64) {
#line 228
      return (-1);
    }
#line 226
    k ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 234
  j = 0;
#line 235
  k = 0;
  {
#line 235
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 235
    if (! (k < 1024)) {
#line 235
      goto while_break___1;
    }
#line 236
    if ((int )*(data + ((start + k) + 512)) == 255) {
#line 237
      goto while_break___1;
    }
#line 238
    if ((int )*(data + ((start + k) + 512)) > j) {
#line 239
      j = (int )*(data + ((start + k) + 512));
    }
#line 235
    k ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 242
  if (k == 1024) {
#line 243
    return (-1);
  }
#line 245
  if (j == 0) {
#line 246
    return (-1);
  }
  {
#line 248
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 248
    if (s < ((start + 1536) + j * 192) + 189) {
#line 248
      return ((((start + 1536) + j * 192) + 189) - s);
    }
#line 248
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 252
  k = 0;
  {
#line 252
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 252
    if (! (k <= j)) {
#line 252
      goto while_break___3;
    }
#line 253
    l = 0;
    {
#line 253
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 253
      if (! (l < 64)) {
#line 253
        goto while_break___4;
      }
#line 254
      if ((int )*(data + (((start + 1536) + k * 192) + l * 3)) > 36) {
#line 255
        return (-1);
      }
#line 253
      l ++;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 252
    k ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 261
  return (0);
}
}
#line 64 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/prowizard/prowiz.h"
struct pw_format pw_kris ;
#line 12 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/prowizard/kris.c"
static int test_kris(uint8 *data , int s ) ;
#line 13
static int depack_kris(FILE *in , FILE *out ) ;
#line 15 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/prowizard/kris.c"
struct pw_format pw_kris  =    {(char *)"KRIS", (char *)"ChipTracker", 0, & test_kris, & depack_kris, 0, {(struct list_head *)0,
                                                                              (struct list_head *)0}};
#line 24 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/prowizard/kris.c"
static int depack_kris(FILE *in , FILE *out ) 
{ 
  uint8 tmp[1025] ;
  uint8 c3 ;
  uint8 npat ;
  uint8 max ;
  uint8 ptable[128] ;
  uint8 note ;
  uint8 ins ;
  uint8 fxt ;
  uint8 fxp ;
  uint8 tdata[512][256] ;
  short taddr[128][4] ;
  short maxtaddr ;
  int i___3 ;
  int j ;
  int k ;
  int size___0 ;
  int ssize ;
  uint16 tmp___0 ;
  uint8 tmp___1 ;
  uint8 tmp___2 ;
  uint16 tmp___3 ;
  uint16 tmp___4 ;
  uint8 tmp___5 ;
  uint16 tmp___6 ;
  void *__cil_tmp27 ;
  void *__cil_tmp28 ;
  void *__cil_tmp29 ;
  int __cil_tmp30 ;
  void *__cil_tmp31 ;
  void *__cil_tmp32 ;
  int __cil_tmp33 ;
  void *__cil_tmp34 ;

  {
  {
#line 33
  maxtaddr = (short)0;
#line 35
  ssize = 0;
#line 37
  memset((void *)(tmp), 0, (size_t )1025);
#line 38
  memset((void *)(ptable), 0, (size_t )128);
#line 39
  memset((void *)(taddr), 0, (size_t )1024);
#line 40
  memset((void *)(tdata), 0, (size_t )(512 << 8));
#line 42
  pw_move_data(out, in, 20);
#line 43
  fseek(in, 2L, 1);
#line 46
  i___3 = 0;
  }
  {
#line 46
  while (1) {
    while_continue: /* CIL Label */ ;
#line 46
    if (! (i___3 < 31)) {
#line 46
      goto while_break;
    }
    {
#line 48
    fread((void */* __restrict  */)(tmp), (size_t )22, (size_t )1, (FILE */* __restrict  */)in);
    }
#line 49
    if ((int )tmp[0] == 1) {
#line 50
      tmp[0] = (uint8 )0;
    }
    {
#line 51
    fwrite((void const   */* __restrict  */)(tmp), (size_t )22, (size_t )1, (FILE */* __restrict  */)out);
#line 53
    tmp___0 = read16b(in);
#line 53
    size___0 = (int )tmp___0;
#line 53
    write16b(out, (uint16 )size___0);
#line 54
    ssize += size___0 * 2;
#line 55
    tmp___1 = read8(in);
#line 55
    write8(out, tmp___1);
#line 56
    tmp___2 = read8(in);
#line 56
    write8(out, tmp___2);
#line 57
    tmp___3 = read16b(in);
#line 57
    write16b(out, (uint16 )((int )tmp___3 / 2));
#line 58
    tmp___4 = read16b(in);
#line 58
    write16b(out, tmp___4);
#line 46
    i___3 ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 61
  read32b(in);
#line 62
  npat = read8(in);
#line 62
  write8(out, npat);
#line 63
  tmp___5 = read8(in);
#line 63
  write8(out, tmp___5);
#line 66
  c3 = (uint8 )0;
#line 67
  k = 0;
#line 68
  i___3 = 0;
  }
  {
#line 68
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 68
    if (! (i___3 < 128)) {
#line 68
      goto while_break___0;
    }
#line 69
    j = 0;
    {
#line 69
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 69
      if (! (j < 4)) {
#line 69
        goto while_break___1;
      }
      {
#line 70
      tmp___6 = read16b(in);
#line 70
      taddr[k][j] = (short )tmp___6;
      }
#line 71
      if ((int )taddr[k][j] > (int )maxtaddr) {
#line 72
        maxtaddr = taddr[k][j];
      }
#line 69
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 74
    j = 0;
    {
#line 74
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 74
      if (! (j < k)) {
#line 74
        goto while_break___2;
      }
#line 75
      if ((int )taddr[j][0] == (int )taddr[k][0]) {
#line 75
        if ((int )taddr[j][1] == (int )taddr[k][1]) {
#line 75
          if ((int )taddr[j][2] == (int )taddr[k][2]) {
#line 75
            if ((int )taddr[j][3] == (int )taddr[k][3]) {
#line 79
              ptable[i___3] = ptable[j];
#line 80
              k --;
#line 81
              goto while_break___2;
            }
          }
        }
      }
#line 74
      j ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 84
    if (k == j) {
#line 85
      ptable[i___3] = c3;
#line 86
      c3 = (uint8 )((int )c3 + 1);
    }
    {
#line 88
    write8(out, ptable[i___3]);
#line 68
    i___3 ++;
#line 68
    k ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 91
  max = (uint8 )((int )c3 - 1);
#line 93
  write32b(out, (((77U << 24) | (46U << 16)) | (75U << 8)) | 46U);
#line 95
  read16b(in);
#line 98
  i___3 = 0;
  }
  {
#line 98
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 98
    if (! (i___3 <= (int )maxtaddr / 256)) {
#line 98
      goto while_break___3;
    }
    {
#line 99
    memset((void *)(tmp), 0, (size_t )1025);
#line 100
    fread((void */* __restrict  */)(tmp), (size_t )256, (size_t )1, (FILE */* __restrict  */)in);
#line 102
    j = 0;
    }
    {
#line 102
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 102
      if (! (j < 64)) {
#line 102
        goto while_break___4;
      }
#line 103
      note = tmp[j * 4];
#line 104
      ins = tmp[j * 4 + 1];
#line 105
      fxt = (uint8 )((int )tmp[j * 4 + 2] & 15);
#line 106
      fxp = tmp[j * 4 + 3];
#line 108
      tdata[i___3][j * 4] = (uint8 )((int )ins & 240);
#line 110
      if ((int )note != 168) {
#line 111
        tdata[i___3][j * 4] = (uint8 )((int )tdata[i___3][j * 4] | (int )ptk_table[(int )note / 2 - 35][0]);
#line 113
        tdata[i___3][j * 4 + 1] = (uint8 )((int )tdata[i___3][j * 4 + 1] | (int )ptk_table[(int )note / 2 - 35][1]);
      }
#line 116
      tdata[i___3][j * 4 + 2] = (uint8 )(((int )ins << 4) & 240);
#line 117
      tdata[i___3][j * 4 + 2] = (uint8 )((int )tdata[i___3][j * 4 + 2] | ((int )fxt & 15));
#line 118
      tdata[i___3][j * 4 + 3] = fxp;
#line 102
      j ++;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 98
    i___3 ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 122
  i___3 = 0;
  {
#line 122
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 122
    if (! (i___3 <= (int )max)) {
#line 122
      goto while_break___5;
    }
    {
#line 123
    memset((void *)(tmp), 0, (size_t )1025);
#line 124
    j = 0;
    }
    {
#line 124
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 124
      if (! (j < 64)) {
#line 124
        goto while_break___6;
      }
#line 125
      tmp[j * 16] = tdata[(int )taddr[i___3][0] / 256][j * 4];
#line 126
      tmp[j * 16 + 1] = tdata[(int )taddr[i___3][0] / 256][j * 4 + 1];
#line 127
      tmp[j * 16 + 2] = tdata[(int )taddr[i___3][0] / 256][j * 4 + 2];
#line 128
      tmp[j * 16 + 3] = tdata[(int )taddr[i___3][0] / 256][j * 4 + 3];
#line 130
      tmp[j * 16 + 4] = tdata[(int )taddr[i___3][1] / 256][j * 4];
#line 131
      tmp[j * 16 + 5] = tdata[(int )taddr[i___3][1] / 256][j * 4 + 1];
#line 132
      tmp[j * 16 + 6] = tdata[(int )taddr[i___3][1] / 256][j * 4 + 2];
#line 133
      tmp[j * 16 + 7] = tdata[(int )taddr[i___3][1] / 256][j * 4 + 3];
#line 135
      tmp[j * 16 + 8] = tdata[(int )taddr[i___3][2] / 256][j * 4];
#line 136
      tmp[j * 16 + 9] = tdata[(int )taddr[i___3][2] / 256][j * 4 + 1];
#line 137
      tmp[j * 16 + 10] = tdata[(int )taddr[i___3][2] / 256][j * 4 + 2];
#line 138
      tmp[j * 16 + 11] = tdata[(int )taddr[i___3][2] / 256][j * 4 + 3];
#line 140
      tmp[j * 16 + 12] = tdata[(int )taddr[i___3][3] / 256][j * 4];
#line 141
      tmp[j * 16 + 13] = tdata[(int )taddr[i___3][3] / 256][j * 4 + 1];
#line 142
      tmp[j * 16 + 14] = tdata[(int )taddr[i___3][3] / 256][j * 4 + 2];
#line 143
      tmp[j * 16 + 15] = tdata[(int )taddr[i___3][3] / 256][j * 4 + 3];
#line 124
      j ++;
    }
    while_break___6: /* CIL Label */ ;
    }
    {
#line 145
    fwrite((void const   */* __restrict  */)(tmp), (size_t )1024, (size_t )1, (FILE */* __restrict  */)out);
#line 122
    i___3 ++;
    }
  }
  while_break___5: /* CIL Label */ ;
  }
  {
#line 149
  pw_move_data(out, in, ssize);
  }
#line 151
  return (0);
}
}
#line 154 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/prowizard/kris.c"
static int test_kris(uint8 *data , int s ) 
{ 
  int j ;
  int start ;

  {
#line 157
  start = 0;
  {
#line 160
  while (1) {
    while_continue: /* CIL Label */ ;
#line 160
    if (s < 1024) {
#line 160
      return (1024 - s);
    }
#line 160
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 162
  if ((int )*(data + 952) != 75) {
#line 164
    return (-1);
  } else
#line 162
  if ((int )*(data + 953) != 82) {
#line 164
    return (-1);
  } else
#line 162
  if ((int )*(data + 954) != 73) {
#line 164
    return (-1);
  } else
#line 162
  if ((int )*(data + 955) != 83) {
#line 164
    return (-1);
  }
#line 167
  j = 0;
  {
#line 167
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 167
    if (! (j < 31)) {
#line 167
      goto while_break___0;
    }
#line 168
    if ((int )*(data + (47 + j * 30)) > 64) {
#line 169
      return (-1);
    }
#line 170
    if ((int )*(data + (46 + j * 30)) > 15) {
#line 171
      return (-1);
    }
#line 167
    j ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 175
  j = 0;
  {
#line 175
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 175
    if (! (j < 31)) {
#line 175
      goto while_break___1;
    }
#line 176
    if ((int )*(data + ((start + j * 30) + 47)) > 64) {
#line 177
      return (-1);
    }
#line 175
    j ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 180
  return (0);
}
}
#line 56 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/prowizard/prowiz.h"
struct pw_format pw_crb ;
#line 15 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/prowizard/heatseek.c"
static int test_crb(uint8 *data , int s ) ;
#line 16
static int depack_crb(FILE *in , FILE *out ) ;
#line 18 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/prowizard/heatseek.c"
struct pw_format pw_crb  =    {(char *)"CRB", (char *)"Heatseeker 1.0", 0, & test_crb, & depack_crb, 0, {(struct list_head *)0,
                                                                              (struct list_head *)0}};
#line 27 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/prowizard/heatseek.c"
static int depack_crb(FILE *in , FILE *out ) 
{ 
  uint8 c1 ;
  uint8 c2 ;
  uint8 c3 ;
  uint8 c4 ;
  uint8 ptable[128] ;
  uint8 pat_pos ;
  uint8 pat_max ;
  uint8 pat___0[1024] ;
  int taddr[512] ;
  int i___3 ;
  int j ;
  int k ;
  int l ;
  int m___0 ;
  int size___0 ;
  int ssize ;
  uint16 tmp ;
  uint8 tmp___0 ;
  uint8 tmp___1 ;
  uint16 tmp___2 ;
  uint16 tmp___3 ;
  int tmp___4 ;
  uint8 tmp___5 ;
  long tmp___6 ;
  int y ;
  long tmp___7 ;
  int x ;
  void *__cil_tmp30 ;
  void *__cil_tmp31 ;
  void *__cil_tmp32 ;

  {
  {
#line 35
  ssize = 0;
#line 37
  memset((void *)(ptable), 0, (size_t )128);
#line 38
  memset((void *)(taddr), 0, (size_t )2048);
#line 40
  pw_write_zero(out, 20);
#line 43
  i___3 = 0;
  }
  {
#line 43
  while (1) {
    while_continue: /* CIL Label */ ;
#line 43
    if (! (i___3 < 31)) {
#line 43
      goto while_break;
    }
    {
#line 44
    pw_write_zero(out, 22);
#line 45
    tmp = read16b(in);
#line 45
    size___0 = (int )tmp;
#line 45
    write16b(out, (uint16 )size___0);
#line 46
    ssize += size___0 * 2;
#line 47
    tmp___0 = read8(in);
#line 47
    write8(out, tmp___0);
#line 48
    tmp___1 = read8(in);
#line 48
    write8(out, tmp___1);
#line 49
    tmp___2 = read16b(in);
#line 49
    write16b(out, tmp___2);
#line 50
    tmp___3 = read16b(in);
#line 50
    size___0 = (int )tmp___3;
    }
#line 51
    if (size___0) {
#line 51
      tmp___4 = size___0;
    } else {
#line 51
      tmp___4 = 1;
    }
    {
#line 51
    write16b(out, (uint16 )tmp___4);
#line 43
    i___3 ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 54
  pat_pos = read8(in);
#line 54
  write8(out, pat_pos);
#line 55
  tmp___5 = read8(in);
#line 55
  write8(out, tmp___5);
#line 58
  i___3 = 0;
#line 58
  pat_max = (uint8 )i___3;
  }
  {
#line 58
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 58
    if (! (i___3 < 128)) {
#line 58
      goto while_break___0;
    }
    {
#line 59
    c1 = read8(in);
#line 59
    write8(out, c1);
    }
#line 60
    if ((int )c1 > (int )pat_max) {
#line 61
      pat_max = c1;
    }
#line 58
    i___3 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 63
  pat_max = (uint8 )((int )pat_max + 1);
#line 66
  write32b(out, (((77U << 24) | (46U << 16)) | (75U << 8)) | 46U);
#line 69
  i___3 = 0;
  }
  {
#line 69
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 69
    if (! (i___3 < (int )pat_max)) {
#line 69
      goto while_break___1;
    }
    {
#line 70
    memset((void *)(pat___0), 0, (size_t )1024);
#line 71
    j = 0;
    }
    {
#line 71
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 71
      if (! (j < 4)) {
#line 71
        goto while_break___2;
      }
      {
#line 72
      tmp___6 = ftell(in);
#line 72
      taddr[i___3 * 4 + j] = (int )tmp___6;
#line 73
      k = 0;
      }
      {
#line 73
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 73
        if (! (k < 64)) {
#line 73
          goto while_break___3;
        }
        {
#line 74
        y = k * 16 + j * 4;
#line 76
        c1 = read8(in);
        }
#line 77
        if ((int )c1 == 128) {
          {
#line 78
          c2 = read8(in);
#line 79
          c3 = read8(in);
#line 80
          c4 = read8(in);
#line 81
          k += (int )c4;
          }
#line 82
          goto __Cont;
        }
#line 84
        if ((int )c1 == 192) {
          {
#line 85
          c2 = read8(in);
#line 86
          c3 = read8(in);
#line 87
          c4 = read8(in);
#line 88
          tmp___7 = ftell(in);
#line 88
          l = (int )tmp___7;
#line 89
          fseek(in, (long )taddr[(((int )c3 << 8) + (int )c4) / 4], 0);
#line 91
          m___0 = 0;
          }
          {
#line 91
          while (1) {
            while_continue___4: /* CIL Label */ ;
#line 91
            if (! (m___0 < 64)) {
#line 91
              goto while_break___4;
            }
            {
#line 92
            x = m___0 * 16 + j * 4;
#line 94
            c1 = read8(in);
            }
#line 95
            if ((int )c1 == 128) {
              {
#line 96
              c2 = read8(in);
#line 97
              c3 = read8(in);
#line 98
              c4 = read8(in);
#line 99
              m___0 += (int )c4;
              }
#line 100
              goto __Cont___0;
            }
            {
#line 102
            pat___0[x] = c1;
#line 103
            pat___0[x + 1] = read8(in);
#line 104
            pat___0[x + 2] = read8(in);
#line 105
            pat___0[x + 3] = read8(in);
            }
            __Cont___0: /* CIL Label */ 
#line 91
            m___0 ++;
          }
          while_break___4: /* CIL Label */ ;
          }
          {
#line 107
          fseek(in, (long )l, 0);
#line 108
          k += 100;
          }
#line 109
          goto __Cont;
        }
        {
#line 111
        pat___0[y] = c1;
#line 112
        pat___0[y + 1] = read8(in);
#line 113
        pat___0[y + 2] = read8(in);
#line 114
        pat___0[y + 3] = read8(in);
        }
        __Cont: /* CIL Label */ 
#line 73
        k ++;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 71
      j ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 117
    fwrite((void const   */* __restrict  */)(pat___0), (size_t )1024, (size_t )1,
           (FILE */* __restrict  */)out);
#line 69
    i___3 ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 121
  pw_move_data(out, in, ssize);
  }
#line 123
  return (0);
}
}
#line 127 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/prowizard/heatseek.c"
static int test_crb(uint8 *data , int s ) 
{ 
  int j ;
  int k ;
  int l ;
  int m___0 ;
  int n___0 ;
  int o___0 ;
  int start ;
  int ssize ;
  uint16 tmp ;
  uint16 tmp___0 ;
  uint16 tmp___1 ;

  {
#line 130
  start = 0;
  {
#line 132
  while (1) {
    while_continue: /* CIL Label */ ;
#line 132
    if (s < 378) {
#line 132
      return (378 - s);
    }
#line 132
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 135
  if ((int )*(data + (start + 248)) > 127) {
#line 136
    return (-1);
  } else
#line 135
  if ((int )*(data + (start + 248)) == 0) {
#line 136
    return (-1);
  }
#line 139
  if ((int )*(data + (start + 249)) != 127) {
#line 140
    return (-1);
  }
#line 143
  ssize = 0;
#line 144
  k = 0;
  {
#line 144
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 144
    if (! (k < 31)) {
#line 144
      goto while_break___0;
    }
#line 145
    if ((int )*(data + ((start + 2) + k * 8)) > 15) {
#line 146
      return (-1);
    }
#line 149
    if ((int )*(data + ((start + 3) + k * 8)) > 64) {
#line 150
      return (-1);
    }
    {
#line 152
    tmp = readmem16b((data + start) + k * 8);
#line 152
    j = (int )tmp * 2;
#line 153
    tmp___0 = readmem16b(((data + start) + k * 8) + 4);
#line 153
    m___0 = (int )tmp___0 * 2;
#line 154
    tmp___1 = readmem16b(((data + start) + k * 8) + 6);
#line 154
    n___0 = (int )tmp___1 * 2;
    }
#line 156
    if (j > 65535) {
#line 157
      return (-1);
    } else
#line 156
    if (m___0 > 65535) {
#line 157
      return (-1);
    } else
#line 156
    if (n___0 > 65535) {
#line 157
      return (-1);
    }
#line 160
    if (n___0 != 0) {
#line 160
      if (n___0 != 2) {
#line 160
        if (m___0 + n___0 > j) {
#line 161
          return (-1);
        }
      }
    }
#line 163
    if (m___0 != 0) {
#line 163
      if (n___0 <= 2) {
#line 164
        return (-1);
      }
    }
#line 166
    ssize += j;
#line 144
    k ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 170
  if (ssize <= 4) {
#line 171
    return (-1);
  }
#line 174
  l = 0;
#line 175
  j = 0;
  {
#line 175
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 175
    if (! (j < 128)) {
#line 175
      goto while_break___1;
    }
#line 176
    if ((int )*(data + ((start + 250) + j)) > 127) {
#line 177
      return (-1);
    }
#line 178
    if ((int )*(data + ((start + 250) + j)) > l) {
#line 179
      l = (int )*(data + ((start + 250) + j));
    }
#line 175
    j ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 183
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 183
    if (s < 379 + ((4 * l) * 4) * 64) {
#line 183
      return ((379 + ((4 * l) * 4) * 64) - s);
    }
#line 183
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 186
  k = 0;
#line 187
  j = 0;
#line 188
  m___0 = 0;
  {
#line 188
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 188
    if (! (m___0 <= l)) {
#line 188
      goto while_break___3;
    }
#line 189
    n___0 = 0;
    {
#line 189
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 189
      if (! (n___0 < 4)) {
#line 189
        goto while_break___4;
      }
#line 190
      o___0 = 0;
      {
#line 190
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 190
        if (! (o___0 < 64)) {
#line 190
          goto while_break___5;
        }
        {
#line 192
        if (((int )*(data + ((start + 378) + j)) & 192) == 0) {
#line 192
          goto case_0;
        }
#line 198
        if (((int )*(data + ((start + 378) + j)) & 192) == 128) {
#line 198
          goto case_128;
        }
#line 205
        if (((int )*(data + ((start + 378) + j)) & 192) == 192) {
#line 205
          goto case_192;
        }
#line 212
        goto switch_default;
        case_0: /* CIL Label */ 
#line 193
        if (((int )*(data + ((start + 378) + j)) & 15) > 3) {
#line 194
          return (-1);
        }
#line 195
        k += 4;
#line 196
        j += 4;
#line 197
        goto switch_break;
        case_128: /* CIL Label */ 
#line 199
        if ((int )*(data + ((start + 379) + j)) != 0) {
#line 200
          return (-1);
        }
#line 201
        o___0 += (int )*(data + ((start + 381) + j));
#line 202
        j += 4;
#line 203
        k += 4;
#line 204
        goto switch_break;
        case_192: /* CIL Label */ 
#line 206
        if ((int )*(data + ((start + 379) + j)) != 0) {
#line 207
          return (-1);
        }
#line 208
        o___0 = 100;
#line 209
        j += 4;
#line 210
        k += 4;
#line 211
        goto switch_break;
        switch_default: /* CIL Label */ 
#line 213
        goto switch_break;
        switch_break: /* CIL Label */ ;
        }
#line 190
        o___0 ++;
      }
      while_break___5: /* CIL Label */ ;
      }
#line 189
      n___0 ++;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 188
    m___0 ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 222
  return (0);
}
}
#line 63 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/prowizard/prowiz.h"
struct pw_format pw_gmc ;
#line 12 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/prowizard/gmc.c"
static int depack_GMC(FILE *in , FILE *out ) ;
#line 13
static int test_GMC(uint8 *data , int s ) ;
#line 15 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/prowizard/gmc.c"
struct pw_format pw_gmc  =    {(char *)"GMC", (char *)"Game Music Creator", 0, & test_GMC, & depack_GMC, 0, {(struct list_head *)0,
                                                                                  (struct list_head *)0}};
#line 23 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/prowizard/gmc.c"
static int depack_GMC(FILE *in , FILE *out ) 
{ 
  uint8 tmp[1024] ;
  uint8 ptable[128] ;
  uint8 max ;
  uint8 PatPos ;
  uint16 len ;
  uint16 looplen ;
  long ssize ;
  long i___3 ;
  long j ;
  uint8 tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  uint16 tmp___3 ;
  void *__cil_tmp16 ;
  void *__cil_tmp17 ;

  {
  {
#line 30
  ssize = 0L;
#line 31
  i___3 = 0L;
#line 31
  j = 0L;
#line 33
  memset((void *)(ptable), 0, (size_t )128);
#line 35
  pw_write_zero(out, 20);
#line 37
  i___3 = 0L;
  }
  {
#line 37
  while (1) {
    while_continue: /* CIL Label */ ;
#line 37
    if (! (i___3 < 15L)) {
#line 37
      goto while_break;
    }
    {
#line 38
    pw_write_zero(out, 22);
#line 39
    read32b(in);
#line 40
    len = read16b(in);
#line 40
    write16b(out, len);
#line 41
    ssize += (long )((int )len * 2);
#line 42
    read8(in);
#line 43
    write8(out, (uint8 )0);
#line 44
    tmp___0 = read8(in);
#line 44
    write8(out, tmp___0);
#line 45
    read32b(in);
#line 47
    looplen = read16b(in);
    }
#line 48
    if ((int )looplen > 2) {
#line 48
      tmp___1 = (int )len - (int )looplen;
    } else {
#line 48
      tmp___1 = 0;
    }
    {
#line 48
    write16b(out, (uint16 )tmp___1);
    }
#line 49
    if ((int )looplen <= 2) {
#line 49
      tmp___2 = 1;
    } else {
#line 49
      tmp___2 = (int )looplen;
    }
    {
#line 49
    write16b(out, (uint16 )tmp___2);
#line 50
    read16b(in);
#line 37
    i___3 ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 53
  memset((void *)(tmp), 0, (size_t )30);
#line 54
  tmp[29] = (uint8 )1;
#line 55
  i___3 = 0L;
  }
  {
#line 55
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 55
    if (! (i___3 < 16L)) {
#line 55
      goto while_break___0;
    }
    {
#line 56
    fwrite((void const   */* __restrict  */)(tmp), (size_t )30, (size_t )1, (FILE */* __restrict  */)out);
#line 55
    i___3 ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 58
  fseek(in, 243L, 0);
#line 59
  PatPos = read8(in);
#line 59
  write8(out, PatPos);
#line 60
  write8(out, (uint8 )127);
#line 64
  i___3 = 0L;
  }
  {
#line 64
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 64
    if (! (i___3 < 100L)) {
#line 64
      goto while_break___1;
    }
    {
#line 65
    tmp___3 = read16b(in);
#line 65
    ptable[i___3] = (uint8 )((int )tmp___3 / 1024);
#line 64
    i___3 ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 66
  fwrite((void const   */* __restrict  */)(ptable), (size_t )128, (size_t )1, (FILE */* __restrict  */)out);
#line 69
  i___3 = 0L;
#line 69
  max = (uint8 )i___3;
  }
  {
#line 69
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 69
    if (! (i___3 < 128L)) {
#line 69
      goto while_break___2;
    }
#line 70
    if ((int )ptable[i___3] > (int )max) {
#line 71
      max = ptable[i___3];
    }
#line 69
    i___3 ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 75
  write32b(out, (((77U << 24) | (46U << 16)) | (75U << 8)) | 46U);
#line 78
  fseek(in, 444L, 0);
#line 79
  i___3 = 0L;
  }
  {
#line 79
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 79
    if (! (i___3 <= (long )max)) {
#line 79
      goto while_break___3;
    }
    {
#line 80
    memset((void *)(tmp), 0, (size_t )1024);
#line 81
    fread((void */* __restrict  */)(tmp), (size_t )1024, (size_t )1, (FILE */* __restrict  */)in);
#line 82
    j = 0L;
    }
    {
#line 82
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 82
      if (! (j < 256L)) {
#line 82
        goto while_break___4;
      }
      {
#line 84
      if (((int )tmp[j * 4L + 2L] & 15) == 3) {
#line 84
        goto case_3;
      }
#line 87
      if (((int )tmp[j * 4L + 2L] & 15) == 4) {
#line 87
        goto case_4;
      }
#line 90
      if (((int )tmp[j * 4L + 2L] & 15) == 5) {
#line 90
        goto case_5;
      }
#line 93
      if (((int )tmp[j * 4L + 2L] & 15) == 6) {
#line 93
        goto case_6;
      }
#line 96
      if (((int )tmp[j * 4L + 2L] & 15) == 7) {
#line 96
        goto case_7;
      }
#line 99
      if (((int )tmp[j * 4L + 2L] & 15) == 8) {
#line 99
        goto case_8;
      }
#line 102
      goto switch_default;
      case_3: /* CIL Label */ 
#line 85
      tmp[j * 4L + 2L] = (uint8 )((int )tmp[j * 4L + 2L] + 9);
#line 86
      goto switch_break;
      case_4: /* CIL Label */ 
#line 88
      tmp[j * 4L + 2L] = (uint8 )((int )tmp[j * 4L + 2L] + 9);
#line 89
      goto switch_break;
      case_5: /* CIL Label */ 
#line 91
      tmp[j * 4L + 2L] = (uint8 )((int )tmp[j * 4L + 2L] + 6);
#line 92
      goto switch_break;
      case_6: /* CIL Label */ 
#line 94
      tmp[j * 4L + 2L] = (uint8 )((int )tmp[j * 4L + 2L] + 8);
#line 95
      goto switch_break;
      case_7: /* CIL Label */ 
#line 97
      tmp[j * 4L + 2L] = (uint8 )((int )tmp[j * 4L + 2L] + 7);
#line 98
      goto switch_break;
      case_8: /* CIL Label */ 
#line 100
      tmp[j * 4L + 2L] = (uint8 )((int )tmp[j * 4L + 2L] + 7);
#line 101
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 103
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
#line 82
      j ++;
    }
    while_break___4: /* CIL Label */ ;
    }
    {
#line 106
    fwrite((void const   */* __restrict  */)(tmp), (size_t )1024, (size_t )1, (FILE */* __restrict  */)out);
#line 79
    i___3 ++;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 110
  pw_move_data(out, in, (int )ssize);
  }
#line 112
  return (0);
}
}
#line 115 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/prowizard/gmc.c"
static int test_GMC(uint8 *data , int s ) 
{ 
  int j ;
  int k ;
  int l ;
  int m___0 ;
  int n___0 ;
  int o___0 ;
  int start ;
  uint16 tmp ;
  int offset ;
  uint8 *d ;

  {
#line 118
  start = 0;
  {
#line 120
  while (1) {
    while_continue: /* CIL Label */ ;
#line 120
    if (s < 1024) {
#line 120
      return (1024 - s);
    }
#line 120
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 132
  m___0 = 0;
#line 133
  j = 0;
#line 134
  k = 0;
  {
#line 134
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 134
    if (! (k < 15)) {
#line 134
      goto while_break___0;
    }
#line 135
    o___0 = ((int )*(data + ((start + 16 * k) + 4)) << 8) + (int )*(data + ((start + 16 * k) + 5));
#line 136
    n___0 = ((int )*(data + ((start + 16 * k) + 12)) << 8) + (int )*(data + ((start + 16 * k) + 13));
#line 138
    o___0 *= 2;
#line 141
    if ((int )*(data + ((start + 7) + 16 * k)) > 64) {
#line 142
      return (-1);
    }
#line 145
    if (o___0 > 65535) {
#line 146
      return (-1);
    }
#line 148
    if (n___0 > o___0) {
#line 149
      return (-1);
    }
#line 151
    m___0 += o___0;
#line 152
    if (o___0 != 0) {
#line 153
      j = k + 1;
    }
#line 134
    k ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 155
  if (m___0 <= 4) {
#line 156
    return (-1);
  }
#line 160
  if ((int )*(data + (start + 243)) > 100) {
#line 161
    return (-1);
  } else
#line 160
  if ((int )*(data + (start + 243)) == 0) {
#line 161
    return (-1);
  }
#line 164
  l = 0;
#line 165
  n___0 = 0;
  {
#line 165
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 165
    if (! (n___0 < 100)) {
#line 165
      goto while_break___1;
    }
    {
#line 166
    tmp = readmem16b(((data + start) + 244) + n___0 * 2);
#line 166
    k = (int )tmp;
    }
#line 167
    if (k & 1023) {
#line 168
      return (-1);
    }
#line 169
    if (k >> 10 > l) {
#line 169
      l = k >> 10;
    } else {
#line 169
      l = l;
    }
#line 165
    n___0 ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 171
  l ++;
#line 174
  if (l == 1) {
#line 175
    return (-1);
  } else
#line 174
  if (l > 100) {
#line 175
    return (-1);
  }
  {
#line 177
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 177
    if (s < ((444 + k * 1024) + n___0 * 4) + 3) {
#line 177
      return ((((444 + k * 1024) + n___0 * 4) + 3) - s);
    }
#line 177
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 180
  o___0 = (int )*(data + (start + 243));
#line 181
  k = 0;
  {
#line 181
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 181
    if (! (k < l)) {
#line 181
      goto while_break___3;
    }
#line 182
    n___0 = 0;
    {
#line 182
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 182
      if (! (n___0 < 256)) {
#line 182
        goto while_break___4;
      }
#line 183
      offset = ((start + 444) + k * 1024) + n___0 * 4;
#line 184
      d = data + offset;
#line 186
      if (offset > 65532) {
#line 187
        return (-1);
      }
#line 190
      if (((int )*(d + 2) & 15) >= 144) {
#line 191
        return (-1);
      }
#line 197
      if (((int )*(d + 2) & 15) == 3) {
#line 197
        if ((int )*(d + 3) > 64) {
#line 198
          return (-1);
        }
      }
#line 200
      if (((int )*(d + 2) & 15) == 4) {
#line 200
        if ((int )*(d + 3) > 99) {
#line 201
          return (-1);
        }
      }
#line 203
      if (((int )*(d + 2) & 15) == 5) {
#line 203
        if ((int )*(d + 3) > o___0 + 1) {
#line 204
          return (-1);
        }
      }
#line 206
      if (((int )*(d + 2) & 15) == 6) {
#line 206
        if ((int )*(d + 3) >= 2) {
#line 207
          return (-1);
        }
      }
#line 209
      if (((int )*(d + 2) & 15) == 7) {
#line 209
        if ((int )*(d + 3) >= 2) {
#line 210
          return (-1);
        }
      }
#line 182
      n___0 ++;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 181
    k ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 214
  return (0);
}
}
#line 62 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/prowizard/prowiz.h"
struct pw_format pw_fuzz ;
#line 21 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/prowizard/fuzzac.c"
static int test_fuzz(uint8 *data , int s ) ;
#line 22
static int depack_fuzz(FILE *in , FILE *out ) ;
#line 24 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/prowizard/fuzzac.c"
struct pw_format pw_fuzz  =    {(char *)"FUZZ", (char *)"Fuzzac Packer", 0, & test_fuzz, & depack_fuzz, 0, {(struct list_head *)0,
                                                                                (struct list_head *)0}};
#line 37 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/prowizard/fuzzac.c"
static int depack_fuzz(FILE *in , FILE *out ) 
{ 
  uint8 c1 ;
  uint8 c2 ;
  uint8 c3 ;
  uint8 c4 ;
  uint8 c5 ;
  uint8 PatPos ;
  uint8 *tmp ;
  uint8 NbrTracks ;
  uint8 Pattern[1024] ;
  uint8 PatternList[128] ;
  uint8 Track_Numbers[128][16] ;
  uint8 Track_Numbers_Real[128][4] ;
  uint8 Track_Datas[4][256] ;
  uint8 Status ;
  long ssize ;
  long i___3 ;
  long j ;
  long k ;
  long l ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *__cil_tmp24 ;
  void *__cil_tmp25 ;
  void *__cil_tmp26 ;
  int __cil_tmp27 ;
  void *__cil_tmp28 ;
  void *__cil_tmp29 ;
  int __cil_tmp30 ;
  void *__cil_tmp31 ;
  void *__cil_tmp32 ;
  int __cil_tmp33 ;
  void *__cil_tmp34 ;

  {
  {
#line 48
  Status = (uint8 )1;
#line 49
  ssize = 0L;
#line 52
  memset((void *)(Track_Numbers), 0, (size_t )2048);
#line 53
  memset((void *)(Track_Numbers_Real), 0, (size_t )512);
#line 54
  memset((void *)(PatternList), 0, (size_t )128);
#line 57
  fseek(in, 4L, 0);
#line 60
  fseek(in, 2L, 1);
#line 63
  tmp___0 = malloc((size_t )20);
#line 63
  tmp = (uint8 *)tmp___0;
#line 64
  memset((void *)tmp, 0, (size_t )20);
#line 65
  fwrite((void const   */* __restrict  */)tmp, (size_t )20, (size_t )1, (FILE */* __restrict  */)out);
#line 66
  free((void *)tmp);
#line 70
  i___3 = 0L;
  }
  {
#line 70
  while (1) {
    while_continue: /* CIL Label */ ;
#line 70
    if (! (i___3 < 31L)) {
#line 70
      goto while_break;
    }
#line 71
    c1 = (uint8 )0;
#line 72
    j = 0L;
    {
#line 72
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 72
      if (! (j < 22L)) {
#line 72
        goto while_break___0;
      }
      {
#line 73
      fread((void */* __restrict  */)(& c1), (size_t )1, (size_t )1, (FILE */* __restrict  */)in);
#line 74
      fwrite((void const   */* __restrict  */)(& c1), (size_t )1, (size_t )1, (FILE */* __restrict  */)out);
#line 72
      j ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 77
    fseek(in, 38L, 1);
#line 79
    fread((void */* __restrict  */)(& c1), (size_t )1, (size_t )1, (FILE */* __restrict  */)in);
#line 80
    fread((void */* __restrict  */)(& c2), (size_t )1, (size_t )1, (FILE */* __restrict  */)in);
#line 81
    ssize += (long )((((int )c1 << 8) + (int )c2) * 2);
#line 82
    fwrite((void const   */* __restrict  */)(& c1), (size_t )1, (size_t )1, (FILE */* __restrict  */)out);
#line 83
    fwrite((void const   */* __restrict  */)(& c2), (size_t )1, (size_t )1, (FILE */* __restrict  */)out);
#line 84
    fread((void */* __restrict  */)(& c1), (size_t )1, (size_t )1, (FILE */* __restrict  */)in);
#line 85
    fread((void */* __restrict  */)(& c2), (size_t )1, (size_t )1, (FILE */* __restrict  */)in);
#line 86
    fread((void */* __restrict  */)(& c3), (size_t )1, (size_t )1, (FILE */* __restrict  */)in);
#line 87
    fread((void */* __restrict  */)(& c4), (size_t )1, (size_t )1, (FILE */* __restrict  */)in);
#line 88
    fread((void */* __restrict  */)(& c5), (size_t )1, (size_t )1, (FILE */* __restrict  */)in);
#line 89
    fwrite((void const   */* __restrict  */)(& c5), (size_t )1, (size_t )1, (FILE */* __restrict  */)out);
#line 90
    fread((void */* __restrict  */)(& c5), (size_t )1, (size_t )1, (FILE */* __restrict  */)in);
#line 91
    fwrite((void const   */* __restrict  */)(& c5), (size_t )1, (size_t )1, (FILE */* __restrict  */)out);
#line 92
    fwrite((void const   */* __restrict  */)(& c1), (size_t )1, (size_t )1, (FILE */* __restrict  */)out);
#line 93
    fwrite((void const   */* __restrict  */)(& c2), (size_t )1, (size_t )1, (FILE */* __restrict  */)out);
    }
#line 95
    if (((int )c3 << 8) + (int )c4 == 0) {
#line 96
      c4 = (uint8 )1;
    }
    {
#line 97
    fwrite((void const   */* __restrict  */)(& c3), (size_t )1, (size_t )1, (FILE */* __restrict  */)out);
#line 98
    fwrite((void const   */* __restrict  */)(& c4), (size_t )1, (size_t )1, (FILE */* __restrict  */)out);
#line 70
    i___3 ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 104
  fread((void */* __restrict  */)(& PatPos), (size_t )1, (size_t )1, (FILE */* __restrict  */)in);
#line 105
  fwrite((void const   */* __restrict  */)(& PatPos), (size_t )1, (size_t )1, (FILE */* __restrict  */)out);
#line 109
  fread((void */* __restrict  */)(& NbrTracks), (size_t )1, (size_t )1, (FILE */* __restrict  */)in);
#line 112
  c1 = (uint8 )127;
#line 113
  fwrite((void const   */* __restrict  */)(& c1), (size_t )1, (size_t )1, (FILE */* __restrict  */)out);
#line 117
  fseek(in, 2118L, 0);
#line 120
  i___3 = 0L;
  }
  {
#line 120
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 120
    if (! (i___3 < 4L)) {
#line 120
      goto while_break___1;
    }
#line 121
    j = 0L;
    {
#line 121
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 121
      if (! (j < (long )PatPos)) {
#line 121
        goto while_break___2;
      }
      {
#line 122
      fread((void */* __restrict  */)(& Track_Numbers[j][i___3 * 4L]), (size_t )1,
            (size_t )1, (FILE */* __restrict  */)in);
#line 123
      fread((void */* __restrict  */)(& Track_Numbers[j][i___3 * 4L + 1L]), (size_t )1,
            (size_t )1, (FILE */* __restrict  */)in);
#line 124
      fread((void */* __restrict  */)(& Track_Numbers[j][i___3 * 4L + 2L]), (size_t )1,
            (size_t )1, (FILE */* __restrict  */)in);
#line 125
      fread((void */* __restrict  */)(& Track_Numbers[j][i___3 * 4L + 3L]), (size_t )1,
            (size_t )1, (FILE */* __restrict  */)in);
#line 121
      j ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
#line 120
    i___3 ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 131
  c5 = (uint8 )0;
#line 132
  i___3 = 0L;
  {
#line 132
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 132
    if (! (i___3 < (long )PatPos)) {
#line 132
      goto while_break___3;
    }
#line 133
    if (i___3 == 0L) {
#line 134
      PatternList[0] = c5;
#line 135
      c5 = (uint8 )((int )c5 + 1);
#line 136
      goto __Cont;
    }
#line 138
    j = 0L;
    {
#line 138
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 138
      if (! (j < i___3)) {
#line 138
        goto while_break___4;
      }
#line 139
      Status = (uint8 )1;
#line 140
      k = 0L;
      {
#line 140
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 140
        if (! (k < 4L)) {
#line 140
          goto while_break___5;
        }
#line 141
        if ((int )Track_Numbers[j][k * 4L] != (int )Track_Numbers[i___3][k * 4L]) {
#line 143
          Status = (uint8 )2;
#line 144
          goto while_break___5;
        }
#line 140
        k ++;
      }
      while_break___5: /* CIL Label */ ;
      }
#line 147
      if ((int )Status == 1) {
#line 148
        PatternList[i___3] = PatternList[j];
#line 149
        goto while_break___4;
      }
#line 138
      j ++;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 152
    if ((int )Status == 2) {
#line 153
      PatternList[i___3] = c5;
#line 154
      c5 = (uint8 )((int )c5 + 1);
    }
#line 156
    Status = (uint8 )1;
    __Cont: /* CIL Label */ 
#line 132
    i___3 ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 162
  c1 = (uint8 )0;
#line 163
  i___3 = 0L;
  {
#line 163
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 163
    if (! (i___3 < (long )PatPos)) {
#line 163
      goto while_break___6;
    }
#line 164
    if (i___3 == 0L) {
#line 165
      Track_Numbers_Real[c1][0] = Track_Numbers[i___3][0];
#line 166
      Track_Numbers_Real[c1][1] = Track_Numbers[i___3][4];
#line 167
      Track_Numbers_Real[c1][2] = Track_Numbers[i___3][8];
#line 168
      Track_Numbers_Real[c1][3] = Track_Numbers[i___3][12];
#line 169
      c1 = (uint8 )((int )c1 + 1);
#line 170
      goto __Cont___0;
    }
#line 172
    j = 0L;
    {
#line 172
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 172
      if (! (j < i___3)) {
#line 172
        goto while_break___7;
      }
#line 173
      Status = (uint8 )1;
#line 174
      if ((int )PatternList[i___3] == (int )PatternList[j]) {
#line 175
        Status = (uint8 )2;
#line 176
        goto while_break___7;
      }
#line 172
      j ++;
    }
    while_break___7: /* CIL Label */ ;
    }
#line 179
    if ((int )Status == 2) {
#line 180
      goto __Cont___0;
    }
#line 181
    Track_Numbers_Real[c1][0] = Track_Numbers[i___3][0];
#line 182
    Track_Numbers_Real[c1][1] = Track_Numbers[i___3][4];
#line 183
    Track_Numbers_Real[c1][2] = Track_Numbers[i___3][8];
#line 184
    Track_Numbers_Real[c1][3] = Track_Numbers[i___3][12];
#line 185
    c1 = (uint8 )((int )c1 + 1);
#line 186
    Status = (uint8 )1;
    __Cont___0: /* CIL Label */ 
#line 163
    i___3 ++;
  }
  while_break___6: /* CIL Label */ ;
  }
  {
#line 190
  fwrite((void const   */* __restrict  */)(PatternList), (size_t )128, (size_t )1,
         (FILE */* __restrict  */)out);
#line 193
  c1 = (uint8 )'M';
#line 194
  c2 = (uint8 )'.';
#line 195
  c3 = (uint8 )'K';
#line 196
  fwrite((void const   */* __restrict  */)(& c1), (size_t )1, (size_t )1, (FILE */* __restrict  */)out);
#line 197
  fwrite((void const   */* __restrict  */)(& c2), (size_t )1, (size_t )1, (FILE */* __restrict  */)out);
#line 198
  fwrite((void const   */* __restrict  */)(& c3), (size_t )1, (size_t )1, (FILE */* __restrict  */)out);
#line 199
  fwrite((void const   */* __restrict  */)(& c2), (size_t )1, (size_t )1, (FILE */* __restrict  */)out);
#line 205
  l = (long )(2118 + (int )PatPos * 16);
#line 206
  i___3 = 0L;
  }
  {
#line 206
  while (1) {
    while_continue___8: /* CIL Label */ ;
#line 206
    if (! (i___3 < (long )c5)) {
#line 206
      goto while_break___8;
    }
    {
#line 207
    memset((void *)(Pattern), 0, (size_t )1024);
#line 208
    memset((void *)(Track_Datas), 0, (size_t )(4 << 8));
#line 209
    fseek(in, l + (long )((int )Track_Numbers_Real[i___3][0] << 8), 0);
#line 210
    fread((void */* __restrict  */)(Track_Datas[0]), (size_t )256, (size_t )1, (FILE */* __restrict  */)in);
#line 211
    fseek(in, l + (long )((int )Track_Numbers_Real[i___3][1] << 8), 0);
#line 212
    fread((void */* __restrict  */)(Track_Datas[1]), (size_t )256, (size_t )1, (FILE */* __restrict  */)in);
#line 213
    fseek(in, l + (long )((int )Track_Numbers_Real[i___3][2] << 8), 0);
#line 214
    fread((void */* __restrict  */)(Track_Datas[2]), (size_t )256, (size_t )1, (FILE */* __restrict  */)in);
#line 215
    fseek(in, l + (long )((int )Track_Numbers_Real[i___3][3] << 8), 0);
#line 216
    fread((void */* __restrict  */)(Track_Datas[3]), (size_t )256, (size_t )1, (FILE */* __restrict  */)in);
#line 218
    j = 0L;
    }
    {
#line 218
    while (1) {
      while_continue___9: /* CIL Label */ ;
#line 218
      if (! (j < 64L)) {
#line 218
        goto while_break___9;
      }
#line 219
      Pattern[j * 16L] = Track_Datas[0][j * 4L];
#line 220
      Pattern[j * 16L + 1L] = Track_Datas[0][j * 4L + 1L];
#line 221
      Pattern[j * 16L + 2L] = Track_Datas[0][j * 4L + 2L];
#line 222
      Pattern[j * 16L + 3L] = Track_Datas[0][j * 4L + 3L];
#line 223
      Pattern[j * 16L + 4L] = Track_Datas[1][j * 4L];
#line 224
      Pattern[j * 16L + 5L] = Track_Datas[1][j * 4L + 1L];
#line 225
      Pattern[j * 16L + 6L] = Track_Datas[1][j * 4L + 2L];
#line 226
      Pattern[j * 16L + 7L] = Track_Datas[1][j * 4L + 3L];
#line 227
      Pattern[j * 16L + 8L] = Track_Datas[2][j * 4L];
#line 228
      Pattern[j * 16L + 9L] = Track_Datas[2][j * 4L + 1L];
#line 229
      Pattern[j * 16L + 10L] = Track_Datas[2][j * 4L + 2L];
#line 230
      Pattern[j * 16L + 11L] = Track_Datas[2][j * 4L + 3L];
#line 231
      Pattern[j * 16L + 12L] = Track_Datas[3][j * 4L];
#line 232
      Pattern[j * 16L + 13L] = Track_Datas[3][j * 4L + 1L];
#line 233
      Pattern[j * 16L + 14L] = Track_Datas[3][j * 4L + 2L];
#line 234
      Pattern[j * 16L + 15L] = Track_Datas[3][j * 4L + 3L];
#line 218
      j ++;
    }
    while_break___9: /* CIL Label */ ;
    }
    {
#line 237
    fwrite((void const   */* __restrict  */)(Pattern), (size_t )1024, (size_t )1,
           (FILE */* __restrict  */)out);
#line 206
    i___3 ++;
    }
  }
  while_break___8: /* CIL Label */ ;
  }
  {
#line 246
  fseek(in, (l + (long )((int )NbrTracks << 8)) + 4L, 0);
#line 249
  tmp___1 = malloc((size_t )ssize);
#line 249
  tmp = (uint8 *)tmp___1;
#line 250
  fread((void */* __restrict  */)tmp, (size_t )ssize, (size_t )1, (FILE */* __restrict  */)in);
#line 251
  fwrite((void const   */* __restrict  */)tmp, (size_t )ssize, (size_t )1, (FILE */* __restrict  */)out);
#line 252
  free((void *)tmp);
  }
#line 255
  return (0);
}
}
#line 259 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/prowizard/fuzzac.c"
static int test_fuzz(uint8 *data , int s ) 
{ 
  int j ;
  int k ;
  int start ;
  int ssize ;

  {
#line 262
  start = 0;
#line 262
  ssize = 0;
#line 264
  if ((int )*(data + 0) != 77) {
#line 265
    return (-1);
  } else
#line 264
  if ((int )*(data + 1) != 49) {
#line 265
    return (-1);
  } else
#line 264
  if ((int )*(data + 2) != 46) {
#line 265
    return (-1);
  } else
#line 264
  if ((int )*(data + 3) != 48) {
#line 265
    return (-1);
  }
#line 268
  k = 0;
  {
#line 268
  while (1) {
    while_continue: /* CIL Label */ ;
#line 268
    if (! (k < 31)) {
#line 268
      goto while_break;
    }
#line 269
    if ((int )*(data + ((start + 72) + k * 68)) > 15) {
#line 270
      return (-1);
    }
#line 268
    k ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 274
  k = 0;
  {
#line 274
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 274
    if (! (k < 31)) {
#line 274
      goto while_break___0;
    }
#line 275
    if ((int )*(data + ((start + 73) + k * 68)) > 64) {
#line 276
      return (-1);
    }
#line 274
    k ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 280
  k = 0;
  {
#line 280
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 280
    if (! (k < 31)) {
#line 280
      goto while_break___1;
    }
#line 281
    j = ((int )*(data + ((start + 66) + k * 68)) << 8) + (int )*(data + ((start + 67) + k * 68));
#line 283
    if (j > 32768) {
#line 284
      return (-1);
    }
#line 285
    ssize += j * 2;
#line 280
    k ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 289
  if ((int )*(data + (start + 2114)) == 0) {
#line 290
    return (-1);
  }
#line 292
  return (0);
}
}
#line 61 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/prowizard/prowiz.h"
struct pw_format pw_fchs ;
#line 12 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/prowizard/fuchs.c"
static int test_fuchs(uint8 *data , int s ) ;
#line 13
static int depack_fuchs(FILE *in , FILE *out ) ;
#line 15 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/prowizard/fuchs.c"
struct pw_format pw_fchs  =    {(char *)"FCHS", (char *)"Fuchs Tracker", 0, & test_fuchs, & depack_fuchs, 0, {(struct list_head *)0,
                                                                                  (struct list_head *)0}};
#line 24 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/prowizard/fuchs.c"
static int depack_fuchs(FILE *in , FILE *out ) 
{ 
  uint8 *tmp ;
  uint8 c1 ;
  uint8 pmax ;
  int ssize ;
  int SampleSizes[16] ;
  int LoopStart[16] ;
  int i___3 ;
  int j ;
  uint32 tmp___0 ;
  int tmp___1 ;
  uint16 tmp___2 ;
  uint8 tmp___3 ;
  int tmp___4 ;
  uint16 tmp___5 ;
  uint8 tmp___6 ;
  uint32 tmp___7 ;
  void *tmp___8 ;
  void *__cil_tmp20 ;
  void *__cil_tmp21 ;

  {
  {
#line 29
  ssize = 0;
#line 34
  memset((void *)(SampleSizes), 0, (size_t )64);
#line 35
  memset((void *)(LoopStart), 0, (size_t )64);
#line 37
  pw_write_zero(out, 1080);
#line 38
  fseek(out, 0L, 0);
#line 39
  pw_move_data(out, in, 10);
#line 40
  tmp___0 = read32b(in);
#line 40
  ssize = (int )tmp___0;
#line 43
  i___3 = 0;
  }
  {
#line 43
  while (1) {
    while_continue: /* CIL Label */ ;
#line 43
    if (! (i___3 < 16)) {
#line 43
      goto while_break;
    }
    {
#line 44
    fseek(out, (long )(42 + i___3 * 30), 0);
#line 45
    tmp___2 = read16b(in);
#line 45
    tmp___1 = (int )tmp___2;
#line 45
    SampleSizes[i___3] = tmp___1;
#line 45
    write16b(out, (uint16 )(tmp___1 / 2));
#line 43
    i___3 ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 49
  i___3 = 0;
  {
#line 49
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 49
    if (! (i___3 < 16)) {
#line 49
      goto while_break___0;
    }
    {
#line 50
    fseek(out, (long )(45 + i___3 * 30), 0);
#line 51
    fseek(in, 1L, 1);
#line 52
    tmp___3 = read8(in);
#line 52
    write8(out, tmp___3);
#line 49
    i___3 ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 56
  i___3 = 0;
  {
#line 56
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 56
    if (! (i___3 < 16)) {
#line 56
      goto while_break___1;
    }
    {
#line 57
    fseek(out, (long )(46 + i___3 * 30), 0);
#line 58
    tmp___5 = read16b(in);
#line 58
    tmp___4 = (int )tmp___5;
#line 58
    LoopStart[i___3] = tmp___4;
#line 58
    write8(out, (uint8 )(tmp___4 / 2));
#line 56
    i___3 ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 62
  i___3 = 0;
  {
#line 62
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 62
    if (! (i___3 < 16)) {
#line 62
      goto while_break___2;
    }
    {
#line 63
    fseek(out, (long )(48 + i___3 * 30), 0);
#line 64
    j = SampleSizes[i___3] - LoopStart[i___3];
    }
#line 65
    if (j == 0) {
      {
#line 66
      write16b(out, (uint16 )1);
      }
    } else
#line 65
    if (LoopStart[i___3] == 0) {
      {
#line 66
      write16b(out, (uint16 )1);
      }
    } else {
      {
#line 68
      write16b(out, (uint16 )(j / 2));
      }
    }
#line 62
    i___3 ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 72
  i___3 = 16;
  {
#line 72
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 72
    if (! (i___3 < 31)) {
#line 72
      goto while_break___3;
    }
    {
#line 73
    fseek(out, (long )(48 + i___3 * 30), 0);
#line 74
    write16b(out, (uint16 )1);
#line 72
    i___3 ++;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 81
  fseek(out, 950L, 0);
#line 83
  fseek(in, 1L, 1);
#line 84
  tmp___6 = read8(in);
#line 84
  write8(out, tmp___6);
#line 87
  write8(out, (uint8 )127);
#line 90
  i___3 = 0;
#line 90
  pmax = (uint8 )i___3;
  }
  {
#line 90
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 90
    if (! (i___3 < 40)) {
#line 90
      goto while_break___4;
    }
    {
#line 91
    fseek(in, 1L, 1);
#line 92
    c1 = read8(in);
#line 92
    write8(out, c1);
    }
#line 93
    if ((int )c1 > (int )pmax) {
#line 94
      pmax = c1;
    }
#line 90
    i___3 ++;
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 98
  fseek(out, 0L, 2);
#line 99
  write32b(out, (((77U << 24) | (46U << 16)) | (75U << 8)) | 46U);
#line 104
  fseek(in, 4L, 1);
#line 107
  tmp___7 = read32b(in);
#line 107
  j = (int )tmp___7;
#line 110
  tmp___8 = malloc((size_t )j);
#line 110
  tmp = (uint8 *)tmp___8;
#line 111
  fread((void */* __restrict  */)tmp, (size_t )j, (size_t )1, (FILE */* __restrict  */)in);
#line 114
  i___3 = 0;
  }
  {
#line 114
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 114
    if (! (i___3 < j)) {
#line 114
      goto while_break___5;
    }
#line 116
    if (((int )*(tmp + (i___3 + 2)) & 15) == 12) {
#line 117
      c1 = *(tmp + (i___3 + 3));
#line 118
      if ((int )c1 <= 9) {
#line 119
        *(tmp + (i___3 + 3)) = c1;
#line 120
        goto __Cont;
      }
#line 122
      if ((int )c1 >= 16) {
#line 122
        if ((int )c1 <= 25) {
#line 123
          *(tmp + (i___3 + 3)) = (uint8 )((int )c1 - 6);
#line 124
          goto __Cont;
        }
      }
#line 126
      if ((int )c1 >= 32) {
#line 126
        if ((int )c1 <= 41) {
#line 127
          *(tmp + (i___3 + 3)) = (uint8 )((int )c1 - 12);
#line 128
          goto __Cont;
        }
      }
#line 130
      if ((int )c1 >= 48) {
#line 130
        if ((int )c1 <= 57) {
#line 131
          *(tmp + (i___3 + 3)) = (uint8 )((int )c1 - 18);
#line 132
          goto __Cont;
        }
      }
#line 134
      if ((int )c1 >= 64) {
#line 134
        if ((int )c1 <= 73) {
#line 135
          *(tmp + (i___3 + 3)) = (uint8 )((int )c1 - 24);
#line 136
          goto __Cont;
        }
      }
#line 138
      if ((int )c1 >= 80) {
#line 138
        if ((int )c1 <= 89) {
#line 139
          *(tmp + (i___3 + 3)) = (uint8 )((int )c1 - 30);
#line 140
          goto __Cont;
        }
      }
#line 142
      if ((int )c1 >= 96) {
#line 142
        if ((int )c1 <= 100) {
#line 143
          *(tmp + (i___3 + 3)) = (uint8 )((int )c1 - 36);
#line 144
          goto __Cont;
        }
      }
    }
    __Cont: /* CIL Label */ 
#line 114
    i___3 += 4;
  }
  while_break___5: /* CIL Label */ ;
  }
  {
#line 150
  fwrite((void const   */* __restrict  */)tmp, (size_t )j, (size_t )1, (FILE */* __restrict  */)out);
#line 151
  free((void *)tmp);
#line 154
  fseek(in, 4L, 1);
#line 155
  i___3 = 0;
  }
  {
#line 155
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 155
    if (! (i___3 < 16)) {
#line 155
      goto while_break___6;
    }
#line 156
    if (SampleSizes[i___3] != 0) {
      {
#line 157
      pw_move_data(out, in, SampleSizes[i___3]);
      }
    }
#line 155
    i___3 ++;
  }
  while_break___6: /* CIL Label */ ;
  }
#line 160
  return (0);
}
}
#line 164 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/prowizard/fuchs.c"
static int test_fuchs(uint8 *data , int s ) 
{ 
  int start ;
  int j ;
  int k ;
  int m___0 ;
  int n___0 ;
  int o___0 ;
  uint32 tmp ;

  {
  {
#line 166
  start = 0;
#line 178
  tmp = readmem32b(data + 192);
  }
#line 178
  if (tmp != 1397706311U) {
#line 179
    return (-1);
  }
#line 182
  j = ((((int )*(data + (start + 10)) << 24) + ((int )*(data + (start + 11)) << 16)) + ((int )*(data + (start + 12)) << 8)) + (int )*(data + (start + 13));
#line 185
  if (j <= 2) {
#line 186
    return (-1);
  } else
#line 185
  if (j >= 1048560) {
#line 186
    return (-1);
  }
#line 189
  m___0 = 0;
#line 190
  k = 0;
  {
#line 190
  while (1) {
    while_continue: /* CIL Label */ ;
#line 190
    if (! (k < 16)) {
#line 190
      goto while_break;
    }
#line 192
    o___0 = ((int )*(data + ((start + k * 2) + 14)) << 8) + (int )*(data + ((start + k * 2) + 15));
#line 194
    n___0 = ((int )*(data + ((start + k * 2) + 78)) << 8) + (int )*(data + ((start + k * 2) + 79));
#line 197
    if ((int )*(data + ((start + 46) + k * 2)) > 64) {
#line 198
      return (-1);
    }
#line 201
    if (o___0 < n___0) {
#line 202
      return (-1);
    }
#line 204
    m___0 += o___0;
#line 190
    k ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 210
  if (m___0 <= 2) {
#line 211
    return (-1);
  } else
#line 210
  if (m___0 > j) {
#line 211
    return (-1);
  }
#line 214
  k = 0;
#line 215
  j = 0;
  {
#line 215
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 215
    if (! (j < 40)) {
#line 215
      goto while_break___0;
    }
#line 216
    n___0 = (int )*(data + ((start + j * 2) + 113));
#line 217
    if (n___0 > 40) {
#line 218
      return (-1);
    }
#line 219
    if (n___0 > k) {
#line 220
      k = n___0;
    }
#line 215
    j ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 236
  return (0);
}
}
#line 60 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/prowizard/prowiz.h"
struct pw_format pw_fcm ;
#line 12 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/prowizard/fc-m.c"
static int test_fcm(uint8 *data , int s ) ;
#line 13
static int depack_fcm(FILE *in , FILE *out ) ;
#line 15 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/prowizard/fc-m.c"
struct pw_format pw_fcm  =    {(char *)"FCM", (char *)"FC-M Packer", 0, & test_fcm, & depack_fcm, 0, {(struct list_head *)0,
                                                                           (struct list_head *)0}};
#line 24 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/prowizard/fc-m.c"
static int depack_fcm(FILE *in , FILE *out ) 
{ 
  uint8 c1 ;
  uint8 ptable[128] ;
  uint8 pat_pos ;
  uint8 pat_max ;
  int i___3 ;
  int size___0 ;
  int ssize ;
  uint16 tmp ;
  uint8 tmp___0 ;
  uint8 tmp___1 ;
  uint16 tmp___2 ;
  uint16 tmp___3 ;
  uint8 tmp___4 ;
  void *__cil_tmp16 ;

  {
  {
#line 31
  ssize = 0;
#line 33
  memset((void *)(ptable), 0, (size_t )128);
#line 35
  read32b(in);
#line 36
  read16b(in);
#line 37
  read32b(in);
#line 38
  pw_move_data(out, in, 20);
#line 39
  read32b(in);
#line 42
  i___3 = 0;
  }
  {
#line 42
  while (1) {
    while_continue: /* CIL Label */ ;
#line 42
    if (! (i___3 < 31)) {
#line 42
      goto while_break;
    }
    {
#line 43
    pw_write_zero(out, 22);
#line 44
    tmp = read16b(in);
#line 44
    size___0 = (int )tmp;
#line 44
    write16b(out, (uint16 )size___0);
#line 45
    ssize += size___0 * 2;
#line 46
    tmp___0 = read8(in);
#line 46
    write8(out, tmp___0);
#line 47
    tmp___1 = read8(in);
#line 47
    write8(out, tmp___1);
#line 48
    tmp___2 = read16b(in);
#line 48
    write16b(out, tmp___2);
#line 49
    tmp___3 = read16b(in);
#line 49
    size___0 = (int )tmp___3;
    }
#line 50
    if (size___0 == 0) {
#line 51
      size___0 = 1;
    }
    {
#line 52
    write16b(out, (uint16 )size___0);
#line 42
    i___3 ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 55
  read32b(in);
#line 56
  pat_pos = read8(in);
#line 56
  write8(out, pat_pos);
#line 57
  tmp___4 = read8(in);
#line 57
  write8(out, tmp___4);
#line 58
  read32b(in);
#line 61
  i___3 = 0;
#line 61
  pat_max = (uint8 )i___3;
  }
  {
#line 61
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 61
    if (! (i___3 < (int )pat_pos)) {
#line 61
      goto while_break___0;
    }
    {
#line 62
    c1 = read8(in);
#line 62
    write8(out, c1);
    }
#line 63
    if ((int )c1 > (int )pat_max) {
#line 64
      pat_max = c1;
    }
#line 61
    i___3 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 66
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 66
    if (! (i___3 < 128)) {
#line 66
      goto while_break___1;
    }
    {
#line 67
    write8(out, (uint8 )0);
#line 66
    i___3 ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 69
  write32b(out, (((77U << 24) | (46U << 16)) | (75U << 8)) | 46U);
#line 70
  read32b(in);
#line 72
  i___3 = 0;
  }
  {
#line 72
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 72
    if (! (i___3 <= (int )pat_max)) {
#line 72
      goto while_break___2;
    }
    {
#line 73
    pw_move_data(out, in, 1024);
#line 72
    i___3 ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 75
  read32b(in);
#line 76
  pw_move_data(out, in, ssize);
  }
#line 78
  return (0);
}
}
#line 82 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/prowizard/fc-m.c"
static int test_fcm(uint8 *data , int s ) 
{ 
  int start ;
  int j ;

  {
#line 84
  start = 0;
  {
#line 87
  while (1) {
    while_continue: /* CIL Label */ ;
#line 87
    if (s < 285) {
#line 87
      return (285 - s);
    }
#line 87
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 90
  if ((int )*(data + 0) != 70) {
#line 92
    return (-1);
  } else
#line 90
  if ((int )*(data + 1) != 67) {
#line 92
    return (-1);
  } else
#line 90
  if ((int )*(data + 2) != 45) {
#line 92
    return (-1);
  } else
#line 90
  if ((int )*(data + 3) != 77) {
#line 92
    return (-1);
  }
#line 95
  if ((int )*(data + (start + 4)) != 1) {
#line 96
    return (-1);
  }
#line 99
  if ((int )*(data + (start + 5)) != 0) {
#line 100
    return (-1);
  }
#line 103
  j = 0;
  {
#line 103
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 103
    if (! (j < 31)) {
#line 103
      goto while_break___0;
    }
#line 104
    if ((int )*(data + ((start + 37) + 8 * j)) > 64) {
#line 105
      return (-1);
    }
#line 103
    j ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 108
  return (0);
}
}
#line 58 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/prowizard/prowiz.h"
struct pw_format pw_eu ;
#line 12 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/prowizard/eureka.c"
static int test_eu(uint8 *data , int s ) ;
#line 13
static int depack_eu(FILE *in , FILE *out ) ;
#line 15 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/prowizard/eureka.c"
struct pw_format pw_eu  =    {(char *)"EU", (char *)"Eureka Packer", 0, & test_eu, & depack_eu, 0, {(struct list_head *)0,
                                                                          (struct list_head *)0}};
#line 23 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/prowizard/eureka.c"
static int depack_eu(FILE *in , FILE *out ) 
{ 
  uint8 *tmp ;
  uint8 c1 ;
  uint8 c2 ;
  uint8 c3 ;
  uint8 c4 ;
  uint8 npat ;
  uint8 ptable[128] ;
  uint8 pat_max ;
  long Sample_Start_Address ;
  long ssize ;
  long Track_Address[128][4] ;
  long i___3 ;
  long j ;
  long k ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *__cil_tmp20 ;
  void *__cil_tmp21 ;
  int __cil_tmp22 ;
  void *__cil_tmp23 ;

  {
  {
#line 26
  c1 = (uint8 )0;
#line 26
  c2 = (uint8 )0;
#line 26
  c3 = (uint8 )0;
#line 26
  c4 = (uint8 )0;
#line 27
  npat = (uint8 )0;
#line 29
  pat_max = (uint8 )0;
#line 30
  Sample_Start_Address = 0L;
#line 31
  ssize = 0L;
#line 33
  i___3 = 0L;
#line 33
  j = 0L;
#line 35
  memset((void *)(ptable), 0, (size_t )128);
#line 38
  tmp___0 = malloc((size_t )1080);
#line 38
  tmp = (uint8 *)tmp___0;
#line 39
  memset((void *)tmp, 0, (size_t )1080);
#line 40
  fread((void */* __restrict  */)tmp, (size_t )1080, (size_t )1, (FILE */* __restrict  */)in);
#line 41
  fwrite((void const   */* __restrict  */)tmp, (size_t )1080, (size_t )1, (FILE */* __restrict  */)out);
#line 45
  i___3 = 0L;
  }
  {
#line 45
  while (1) {
    while_continue: /* CIL Label */ ;
#line 45
    if (! (i___3 < 31L)) {
#line 45
      goto while_break;
    }
#line 46
    ssize += (long )((((int )*(tmp + (i___3 * 30L + 42L)) << 8) + (int )*(tmp + (i___3 * 30L + 43L))) * 2);
#line 45
    i___3 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 52
  npat = *(tmp + 950);
#line 56
  pat_max = (uint8 )0;
#line 57
  i___3 = 0L;
  {
#line 57
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 57
    if (! (i___3 < 128L)) {
#line 57
      goto while_break___0;
    }
#line 58
    ptable[i___3] = *(tmp + (952L + i___3));
#line 59
    if ((int )ptable[i___3] > (int )pat_max) {
#line 60
      pat_max = ptable[i___3];
    }
#line 57
    i___3 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 62
  pat_max = (uint8 )((int )pat_max + 1);
#line 64
  free((void *)tmp);
#line 67
  c1 = (uint8 )'M';
#line 68
  c2 = (uint8 )'.';
#line 69
  c3 = (uint8 )'K';
#line 70
  fwrite((void const   */* __restrict  */)(& c1), (size_t )1, (size_t )1, (FILE */* __restrict  */)out);
#line 71
  fwrite((void const   */* __restrict  */)(& c2), (size_t )1, (size_t )1, (FILE */* __restrict  */)out);
#line 72
  fwrite((void const   */* __restrict  */)(& c3), (size_t )1, (size_t )1, (FILE */* __restrict  */)out);
#line 73
  fwrite((void const   */* __restrict  */)(& c2), (size_t )1, (size_t )1, (FILE */* __restrict  */)out);
#line 77
  fread((void */* __restrict  */)(& c1), (size_t )1, (size_t )1, (FILE */* __restrict  */)in);
#line 78
  fread((void */* __restrict  */)(& c2), (size_t )1, (size_t )1, (FILE */* __restrict  */)in);
#line 79
  fread((void */* __restrict  */)(& c3), (size_t )1, (size_t )1, (FILE */* __restrict  */)in);
#line 80
  fread((void */* __restrict  */)(& c4), (size_t )1, (size_t )1, (FILE */* __restrict  */)in);
#line 81
  Sample_Start_Address = (long )(((((int )c1 << 24) + ((int )c2 << 16)) + ((int )c3 << 8)) + (int )c4);
#line 86
  i___3 = 0L;
  }
  {
#line 86
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 86
    if (! (i___3 < (long )pat_max)) {
#line 86
      goto while_break___1;
    }
#line 87
    j = 0L;
    {
#line 87
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 87
      if (! (j < 4L)) {
#line 87
        goto while_break___2;
      }
      {
#line 88
      fread((void */* __restrict  */)(& c1), (size_t )1, (size_t )1, (FILE */* __restrict  */)in);
#line 89
      fread((void */* __restrict  */)(& c2), (size_t )1, (size_t )1, (FILE */* __restrict  */)in);
#line 90
      Track_Address[i___3][j] = (long )(((int )c1 << 8) + (int )c2);
#line 87
      j ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
#line 86
    i___3 ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 95
  tmp___1 = malloc((size_t )1024);
#line 95
  tmp = (uint8 *)tmp___1;
#line 96
  i___3 = 0L;
  }
  {
#line 96
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 96
    if (! (i___3 < (long )pat_max)) {
#line 96
      goto while_break___3;
    }
    {
#line 97
    memset((void *)tmp, 0, (size_t )1024);
#line 98
    j = 0L;
    }
    {
#line 98
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 98
      if (! (j < 4L)) {
#line 98
        goto while_break___4;
      }
      {
#line 99
      fseek(in, Track_Address[i___3][j], 0);
#line 100
      k = 0L;
      }
      {
#line 100
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 100
        if (! (k < 64L)) {
#line 100
          goto while_break___5;
        }
        {
#line 101
        fread((void */* __restrict  */)(& c1), (size_t )1, (size_t )1, (FILE */* __restrict  */)in);
        }
#line 102
        if (((int )c1 & 192) == 0) {
          {
#line 103
          fread((void */* __restrict  */)(& c2), (size_t )1, (size_t )1, (FILE */* __restrict  */)in);
#line 104
          fread((void */* __restrict  */)(& c3), (size_t )1, (size_t )1, (FILE */* __restrict  */)in);
#line 105
          fread((void */* __restrict  */)(& c4), (size_t )1, (size_t )1, (FILE */* __restrict  */)in);
#line 106
          *(tmp + (k * 16L + j * 4L)) = c1;
#line 107
          *(tmp + ((k * 16L + j * 4L) + 1L)) = c2;
#line 108
          *(tmp + ((k * 16L + j * 4L) + 2L)) = c3;
#line 109
          *(tmp + ((k * 16L + j * 4L) + 3L)) = c4;
          }
#line 110
          goto __Cont;
        }
#line 112
        if (((int )c1 & 192) == 192) {
#line 113
          k += (long )((int )c1 & 63);
#line 114
          goto __Cont;
        }
#line 116
        if (((int )c1 & 192) == 64) {
          {
#line 117
          fread((void */* __restrict  */)(& c2), (size_t )1, (size_t )1, (FILE */* __restrict  */)in);
#line 118
          *(tmp + ((k * 16L + j * 4L) + 2L)) = (uint8 )((int )c1 & 15);
#line 120
          *(tmp + ((k * 16L + j * 4L) + 3L)) = c2;
          }
#line 121
          goto __Cont;
        }
#line 123
        if (((int )c1 & 192) == 128) {
          {
#line 124
          fread((void */* __restrict  */)(& c2), (size_t )1, (size_t )1, (FILE */* __restrict  */)in);
#line 125
          fread((void */* __restrict  */)(& c3), (size_t )1, (size_t )1, (FILE */* __restrict  */)in);
#line 126
          *(tmp + (k * 16L + j * 4L)) = c2;
#line 127
          *(tmp + ((k * 16L + j * 4L) + 1L)) = c3;
#line 128
          *(tmp + ((k * 16L + j * 4L) + 2L)) = (uint8 )(((int )c1 << 4) & 240);
          }
#line 130
          goto __Cont;
        }
        __Cont: /* CIL Label */ 
#line 100
        k ++;
      }
      while_break___5: /* CIL Label */ ;
      }
#line 98
      j ++;
    }
    while_break___4: /* CIL Label */ ;
    }
    {
#line 134
    fwrite((void const   */* __restrict  */)tmp, (size_t )1024, (size_t )1, (FILE */* __restrict  */)out);
#line 96
    i___3 ++;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 137
  free((void *)tmp);
#line 140
  fseek(in, Sample_Start_Address, 0);
#line 143
  tmp___2 = malloc((size_t )ssize);
#line 143
  tmp = (uint8 *)tmp___2;
#line 144
  memset((void *)tmp, 0, (size_t )ssize);
#line 145
  fread((void */* __restrict  */)tmp, (size_t )ssize, (size_t )1, (FILE */* __restrict  */)in);
#line 146
  fwrite((void const   */* __restrict  */)tmp, (size_t )ssize, (size_t )1, (FILE */* __restrict  */)out);
#line 147
  free((void *)tmp);
  }
#line 149
  return (0);
}
}
#line 152 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/prowizard/eureka.c"
static int test_eu(uint8 *data , int s ) 
{ 
  int j ;
  int k ;
  int l ;
  int m___0 ;
  int n___0 ;
  int o___0 ;
  int start ;

  {
#line 155
  start = 0;
  {
#line 157
  while (1) {
    while_continue: /* CIL Label */ ;
#line 157
    if (s < 1084) {
#line 157
      return (1084 - s);
    }
#line 157
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 160
  j = (int )*(data + (start + 950));
#line 161
  if (j == 0) {
#line 162
    return (-1);
  } else
#line 161
  if (j > 127) {
#line 162
    return (-1);
  }
#line 165
  k = 0;
  {
#line 165
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 165
    if (! (k < 31)) {
#line 165
      goto while_break___0;
    }
#line 166
    o___0 = ((int )*(data + ((start + 42) + k * 30)) << 8) + (int )*(data + ((start + 43) + k * 30));
#line 168
    m___0 = ((int )*(data + ((start + 46) + k * 30)) << 8) + (int )*(data + ((start + 47) + k * 30));
#line 170
    n___0 = ((int )*(data + ((start + 48) + k * 30)) << 8) + (int )*(data + ((start + 49) + k * 30));
#line 172
    o___0 *= 2;
#line 173
    m___0 *= 2;
#line 174
    n___0 *= 2;
#line 175
    if (o___0 > 65535) {
#line 176
      return (-1);
    } else
#line 175
    if (m___0 > 65535) {
#line 176
      return (-1);
    } else
#line 175
    if (n___0 > 65535) {
#line 176
      return (-1);
    }
#line 178
    if (m___0 + n___0 > o___0 + 2) {
#line 179
      return (-1);
    }
#line 181
    if ((int )*(data + ((start + 44) + k * 30)) > 15) {
#line 183
      return (-1);
    } else
#line 181
    if ((int )*(data + ((start + 45) + k * 30)) > 64) {
#line 183
      return (-1);
    }
#line 165
    k ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 188
  l = ((((int )*(data + (start + 1080)) << 24) + ((int )*(data + (start + 1081)) << 16)) + ((int )*(data + (start + 1082)) << 8)) + (int )*(data + (start + 1083));
#line 196
  if (l < 1084) {
#line 197
    return (-1);
  }
#line 199
  m___0 = 0;
#line 201
  k = 0;
  {
#line 201
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 201
    if (! (k < j)) {
#line 201
      goto while_break___1;
    }
#line 202
    n___0 = (int )*(data + ((start + 952) + k));
#line 203
    if (n___0 > m___0) {
#line 204
      m___0 = n___0;
    }
#line 205
    if (n___0 > 127) {
#line 206
      return (-1);
    }
#line 201
    k ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 208
  k += 2;
  {
#line 210
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 210
    if (! (k != 128)) {
#line 210
      goto while_break___2;
    }
#line 211
    if ((int )*(data + ((start + 952) + k)) != 0) {
#line 212
      return (-1);
    }
#line 213
    k ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 215
  m___0 ++;
#line 223
  n___0 = 0;
#line 224
  j = 999999;
  {
#line 226
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 226
    if (s < (start + (m___0 * 4) * 2) + 1085) {
#line 226
      return (((start + (m___0 * 4) * 2) + 1085) - s);
    }
#line 226
    goto while_break___3;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 228
  k = 0;
  {
#line 228
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 228
    if (! (k < m___0 * 4)) {
#line 228
      goto while_break___4;
    }
#line 229
    o___0 = ((int )*(data + ((start + k * 2) + 1084)) << 8) + (int )*(data + ((start + k * 2) + 1085));
#line 231
    if (o___0 > l) {
#line 232
      return (-1);
    } else
#line 231
    if (o___0 < 1084) {
#line 232
      return (-1);
    }
#line 233
    if (o___0 > n___0) {
#line 234
      n___0 = o___0;
    }
#line 235
    if (o___0 < j) {
#line 236
      j = o___0;
    }
#line 228
    k ++;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 243
  k = j;
  {
#line 243
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 243
    if (! (k < o___0)) {
#line 243
      goto while_break___5;
    }
#line 244
    if (((int )*(data + (start + k)) & 192) == 192) {
#line 245
      goto __Cont;
    }
#line 246
    if (((int )*(data + (start + k)) & 192) == 128) {
#line 247
      k += 2;
#line 248
      goto __Cont;
    }
#line 250
    if (((int )*(data + (start + k)) & 192) == 64) {
#line 251
      if (((int )*(data + (start + k)) & 63) == 0) {
#line 251
        if ((int )*(data + ((start + k) + 1)) == 0) {
#line 253
          return (-1);
        }
      }
#line 254
      k ++;
#line 255
      goto __Cont;
    }
#line 257
    if (((int )*(data + (start + k)) & 192) == 0) {
#line 258
      if ((int )*(data + (start + k)) > 19) {
#line 259
        return (-1);
      }
#line 260
      k += 3;
#line 261
      goto __Cont;
    }
    __Cont: /* CIL Label */ 
#line 243
    k ++;
  }
  while_break___5: /* CIL Label */ ;
  }
#line 265
  return (0);
}
}
#line 57 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/prowizard/prowiz.h"
struct pw_format pw_di ;
#line 12 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/prowizard/di.c"
static int test_di(uint8 *data , int s ) ;
#line 13
static int depack_di(FILE *in , FILE *out ) ;
#line 15 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/prowizard/di.c"
struct pw_format pw_di  =    {(char *)"DI", (char *)"Digital Illusions", 0, & test_di, & depack_di, 0, {(struct list_head *)0,
                                                                              (struct list_head *)0}};
#line 24 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/prowizard/di.c"
static int depack_di(FILE *in , FILE *out ) 
{ 
  uint8 c1 ;
  uint8 c2 ;
  uint8 c3 ;
  uint8 note ;
  uint8 ins ;
  uint8 fxt ;
  uint8 fxp ;
  uint8 ptk_tab[5] ;
  uint8 nins ;
  uint8 npat ;
  uint8 max ;
  uint8 ptable[128] ;
  uint16 paddr[128] ;
  uint8 tmp[50] ;
  int i___3 ;
  int k ;
  int seq_offs ;
  int pat_offs ;
  int smp_offs ;
  int pos___0 ;
  int size___0 ;
  int ssize ;
  uint16 tmp___0 ;
  uint32 tmp___1 ;
  uint32 tmp___2 ;
  uint32 tmp___3 ;
  uint16 tmp___4 ;
  uint8 tmp___5 ;
  uint8 tmp___6 ;
  uint16 tmp___7 ;
  uint16 tmp___8 ;
  long tmp___9 ;
  int tmp___10 ;
  void *__cil_tmp36 ;
  void *__cil_tmp37 ;
  void *__cil_tmp38 ;
  void *__cil_tmp39 ;

  {
  {
#line 36
  ssize = 0;
#line 38
  memset((void *)(ptable), 0, (size_t )128);
#line 39
  memset((void *)(ptk_tab), 0, (size_t )5);
#line 40
  memset((void *)(paddr), 0, (size_t )128);
#line 42
  pw_write_zero(out, 20);
#line 44
  tmp___0 = read16b(in);
#line 44
  nins = (uint8 )tmp___0;
#line 45
  tmp___1 = read32b(in);
#line 45
  seq_offs = (int )tmp___1;
#line 46
  tmp___2 = read32b(in);
#line 46
  pat_offs = (int )tmp___2;
#line 47
  tmp___3 = read32b(in);
#line 47
  smp_offs = (int )tmp___3;
#line 49
  i___3 = 0;
  }
  {
#line 49
  while (1) {
    while_continue: /* CIL Label */ ;
#line 49
    if (! (i___3 < (int )nins)) {
#line 49
      goto while_break;
    }
    {
#line 50
    pw_write_zero(out, 22);
#line 51
    tmp___4 = read16b(in);
#line 51
    size___0 = (int )tmp___4;
#line 51
    write16b(out, (uint16 )size___0);
#line 52
    ssize += size___0 * 2;
#line 53
    tmp___5 = read8(in);
#line 53
    write8(out, tmp___5);
#line 54
    tmp___6 = read8(in);
#line 54
    write8(out, tmp___6);
#line 55
    tmp___7 = read16b(in);
#line 55
    write16b(out, tmp___7);
#line 56
    tmp___8 = read16b(in);
#line 56
    write16b(out, tmp___8);
#line 49
    i___3 ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 59
  tmp[29] = (uint8 )1;
#line 60
  i___3 = (int )nins;
  {
#line 60
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 60
    if (! (i___3 < 31)) {
#line 60
      goto while_break___0;
    }
    {
#line 61
    fwrite((void const   */* __restrict  */)(tmp), (size_t )30, (size_t )1, (FILE */* __restrict  */)out);
#line 60
    i___3 ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 63
  tmp___9 = ftell(in);
#line 63
  pos___0 = (int )tmp___9;
#line 64
  fseek(in, (long )seq_offs, 0);
#line 66
  i___3 = 0;
  }
  {
#line 67
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 68
    c1 = read8(in);
#line 69
    tmp___10 = i___3;
#line 69
    i___3 ++;
#line 69
    ptable[tmp___10] = c1;
    }
#line 67
    if (! ((int )c1 != 255)) {
#line 67
      goto while_break___1;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 72
  ptable[i___3 - 1] = (uint8 )0;
#line 73
  npat = (uint8 )(i___3 - 1);
#line 73
  write8(out, npat);
#line 75
  write8(out, (uint8 )127);
#line 77
  i___3 = 0;
#line 77
  max = (uint8 )i___3;
  }
  {
#line 77
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 77
    if (! (i___3 < 128)) {
#line 77
      goto while_break___2;
    }
    {
#line 78
    write8(out, ptable[i___3]);
    }
#line 79
    if ((int )ptable[i___3] > (int )max) {
#line 80
      max = ptable[i___3];
    }
#line 77
    i___3 ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 83
  write32b(out, (((77U << 24) | (46U << 16)) | (75U << 8)) | 46U);
#line 85
  fseek(in, (long )pos___0, 0);
#line 86
  i___3 = 0;
  }
  {
#line 86
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 86
    if (! (i___3 <= (int )max)) {
#line 86
      goto while_break___3;
    }
    {
#line 87
    paddr[i___3] = read16b(in);
#line 86
    i___3 ++;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
#line 89
  i___3 = 0;
  {
#line 89
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 89
    if (! (i___3 <= (int )max)) {
#line 89
      goto while_break___4;
    }
    {
#line 90
    fseek(in, (long )paddr[i___3], 0);
#line 91
    k = 0;
    }
    {
#line 91
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 91
      if (! (k < 256)) {
#line 91
        goto while_break___5;
      }
      {
#line 92
      memset((void *)(ptk_tab), 0, (size_t )5);
#line 93
      c1 = read8(in);
      }
#line 94
      if (((int )c1 & 128) == 0) {
        {
#line 95
        c2 = read8(in);
#line 96
        note = (uint8 )((((int )c1 << 4) & 48) | (((int )c2 >> 4) & 15));
#line 97
        ptk_tab[0] = (uint8 )ptk_table[note][0];
#line 98
        ptk_tab[1] = (uint8 )ptk_table[note][1];
#line 99
        ins = (uint8 )(((int )c1 >> 2) & 31);
#line 100
        ptk_tab[0] = (uint8 )((int )ptk_tab[0] | ((int )ins & 240));
#line 101
        ptk_tab[2] = (uint8 )(((int )ins << 4) & 240);
#line 102
        fxt = (uint8 )((int )c2 & 15);
#line 103
        ptk_tab[2] = (uint8 )((int )ptk_tab[2] | (int )fxt);
#line 104
        fxp = (uint8 )0;
#line 105
        ptk_tab[3] = fxp;
#line 106
        fwrite((void const   */* __restrict  */)(ptk_tab), (size_t )4, (size_t )1,
               (FILE */* __restrict  */)out);
        }
#line 107
        goto __Cont;
      }
#line 109
      if ((int )c1 == 255) {
        {
#line 110
        memset((void *)(ptk_tab), 0, (size_t )5);
#line 111
        fwrite((void const   */* __restrict  */)(ptk_tab), (size_t )4, (size_t )1,
               (FILE */* __restrict  */)out);
        }
#line 112
        goto __Cont;
      }
      {
#line 114
      c2 = read8(in);
#line 115
      c3 = read8(in);
#line 116
      note = (uint8 )((((int )c1 << 4) & 48) | (((int )c2 >> 4) & 15));
#line 117
      ptk_tab[0] = (uint8 )ptk_table[note][0];
#line 118
      ptk_tab[1] = (uint8 )ptk_table[note][1];
#line 119
      ins = (uint8 )(((int )c1 >> 2) & 31);
#line 120
      ptk_tab[0] = (uint8 )((int )ptk_tab[0] | ((int )ins & 240));
#line 121
      ptk_tab[2] = (uint8 )(((int )ins << 4) & 240);
#line 122
      fxt = (uint8 )((int )c2 & 15);
#line 123
      ptk_tab[2] = (uint8 )((int )ptk_tab[2] | (int )fxt);
#line 124
      fxp = c3;
#line 125
      ptk_tab[3] = fxp;
#line 126
      fwrite((void const   */* __restrict  */)(ptk_tab), (size_t )4, (size_t )1, (FILE */* __restrict  */)out);
      }
      __Cont: /* CIL Label */ 
#line 91
      k ++;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 89
    i___3 ++;
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 130
  fseek(in, (long )smp_offs, 0);
#line 131
  pw_move_data(out, in, ssize);
  }
#line 133
  return (0);
}
}
#line 137 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/prowizard/di.c"
static int test_di(uint8 *data , int s ) 
{ 
  int ssize ;
  int start ;
  int j ;
  int k ;
  int l ;
  int m___0 ;
  int n___0 ;
  int o___0 ;

  {
#line 139
  start = 0;
  {
#line 142
  while (1) {
    while_continue: /* CIL Label */ ;
#line 142
    if (s < 21) {
#line 142
      return (21 - s);
    }
#line 142
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 153
  k = ((int )*(data + start) << 8) + (int )*(data + (start + 1));
#line 154
  if (k > 31) {
#line 155
    return (-1);
  }
#line 159
  l = 0;
#line 160
  j = 0;
  {
#line 160
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 160
    if (! (j < k)) {
#line 160
      goto while_break___0;
    }
#line 161
    o___0 = (((int )*(data + (start + 14)) << 8) + (int )*(data + (start + 15))) * 2;
#line 162
    m___0 = (((int )*(data + (start + 18)) << 8) + (int )*(data + (start + 19))) * 2;
#line 163
    n___0 = (((int )*(data + (start + 20)) << 8) + (int )*(data + (start + 21))) * 2;
#line 165
    if (o___0 > 65535) {
#line 166
      return (-1);
    } else
#line 165
    if (m___0 > 65535) {
#line 166
      return (-1);
    } else
#line 165
    if (n___0 > 65535) {
#line 166
      return (-1);
    }
#line 168
    if (m___0 + n___0 > o___0) {
#line 169
      return (-1);
    }
#line 171
    if ((int )*(data + ((start + 16) + j * 8)) > 15) {
#line 172
      return (-1);
    }
#line 174
    if ((int )*(data + ((start + 17) + j * 8)) > 64) {
#line 175
      return (-1);
    }
#line 178
    l += o___0;
#line 160
    j ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 180
  if (l <= 2) {
#line 181
    return (-1);
  }
#line 186
  ssize = k;
#line 189
  j = ((((int )*(data + (start + 2)) << 24) + ((int )*(data + (start + 3)) << 16)) + ((int )*(data + (start + 4)) << 8)) + (int )*(data + (start + 5));
#line 193
  k = ((((int )*(data + (start + 6)) << 24) + ((int )*(data + (start + 7)) << 16)) + ((int )*(data + (start + 8)) << 8)) + (int )*(data + (start + 9));
#line 197
  l = ((((int )*(data + (start + 10)) << 24) + ((int )*(data + (start + 11)) << 16)) + ((int )*(data + (start + 12)) << 8)) + (int )*(data + (start + 13));
#line 200
  if (k <= j) {
#line 201
    return (-1);
  } else
#line 200
  if (l <= j) {
#line 201
    return (-1);
  } else
#line 200
  if (l <= k) {
#line 201
    return (-1);
  }
#line 203
  if (k - j > 128) {
#line 204
    return (-1);
  }
#line 212
  ssize *= 8;
#line 213
  ssize += 2;
#line 214
  if (j < ssize) {
#line 215
    return (-1);
  }
  {
#line 225
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 225
    if (s < (start + k) - 1) {
#line 225
      return (((start + k) - 1) - s);
    }
#line 225
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 228
  m___0 = j;
  {
#line 228
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 228
    if (! (m___0 < k - 1)) {
#line 228
      goto while_break___2;
    }
#line 229
    if ((int )*(data + (start + m___0)) > 128) {
#line 230
      return (-1);
    }
#line 228
    m___0 ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 234
  if ((int )*(data + ((start + k) - 1)) != 255) {
#line 235
    return (-1);
  }
#line 239
  if (l > 65535) {
#line 240
    return (-1);
  }
#line 242
  return (0);
}
}
#line 55 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/prowizard/prowiz.h"
struct pw_format pw_ac1d ;
#line 14 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/prowizard/ac1d.c"
static int depack_AC1D(FILE *in , FILE *out ) ;
#line 15
static int test_AC1D(uint8 *data , int s ) ;
#line 17 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/prowizard/ac1d.c"
struct pw_format pw_ac1d  =    {(char *)"AC1D", (char *)"AC1D Packer", 0, & test_AC1D, & depack_AC1D, 0, {(struct list_head *)0,
                                                                              (struct list_head *)0}};
#line 26 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/prowizard/ac1d.c"
static int depack_AC1D(FILE *in , FILE *out ) 
{ 
  uint8 NO_NOTE ;
  uint8 c1 ;
  uint8 c2 ;
  uint8 c3 ;
  uint8 c4 ;
  uint8 npos ;
  uint8 ntk_byte ;
  uint8 tmp[1024] ;
  uint8 npat ;
  uint8 note ;
  uint8 ins ;
  uint8 fxt ;
  uint8 fxp ;
  int size___0 ;
  int saddr ;
  int ssize ;
  int paddr[128] ;
  int psize[128] ;
  int tsize1 ;
  int tsize2 ;
  int tsize3 ;
  int i___3 ;
  int j ;
  int k ;
  uint32 tmp___0 ;
  uint16 tmp___1 ;
  uint8 tmp___2 ;
  uint8 tmp___3 ;
  uint16 tmp___4 ;
  uint16 tmp___5 ;
  uint32 tmp___6 ;
  uint32 tmp___7 ;
  uint32 tmp___8 ;
  uint32 tmp___9 ;
  int x ;
  void *__cil_tmp38 ;
  void *__cil_tmp39 ;
  void *__cil_tmp40 ;

  {
  {
#line 28
  NO_NOTE = (uint8 )255;
#line 37
  ssize = 0;
#line 43
  memset((void *)(paddr), 0, (size_t )512);
#line 44
  memset((void *)(psize), 0, (size_t )512);
#line 46
  npos = read8(in);
#line 47
  ntk_byte = read8(in);
#line 48
  read16b(in);
#line 49
  tmp___0 = read32b(in);
#line 49
  saddr = (int )tmp___0;
#line 51
  pw_write_zero(out, 20);
#line 53
  i___3 = 0;
  }
  {
#line 53
  while (1) {
    while_continue: /* CIL Label */ ;
#line 53
    if (! (i___3 < 31)) {
#line 53
      goto while_break;
    }
    {
#line 54
    pw_write_zero(out, 22);
#line 55
    tmp___1 = read16b(in);
#line 55
    size___0 = (int )tmp___1;
#line 55
    write16b(out, (uint16 )size___0);
#line 56
    ssize += size___0 * 2;
#line 57
    tmp___2 = read8(in);
#line 57
    write8(out, tmp___2);
#line 58
    tmp___3 = read8(in);
#line 58
    write8(out, tmp___3);
#line 59
    tmp___4 = read16b(in);
#line 59
    write16b(out, tmp___4);
#line 60
    tmp___5 = read16b(in);
#line 60
    write16b(out, tmp___5);
#line 53
    i___3 ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 64
  npat = (uint8 )0;
  {
#line 64
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 64
    if (! ((int )npat < 128)) {
#line 64
      goto while_break___0;
    }
    {
#line 65
    tmp___6 = read32b(in);
#line 65
    paddr[npat] = (int )tmp___6;
    }
#line 66
    if (paddr[npat] == 0) {
#line 67
      goto while_break___0;
    }
#line 64
    npat = (uint8 )((int )npat + 1);
  }
  while_break___0: /* CIL Label */ ;
  }
#line 69
  npat = (uint8 )((int )npat - 1);
#line 71
  i___3 = 0;
  {
#line 71
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 71
    if (! (i___3 < (int )npat - 1)) {
#line 71
      goto while_break___1;
    }
#line 72
    psize[i___3] = paddr[i___3 + 1] - paddr[i___3];
#line 71
    i___3 ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 74
  write8(out, npos);
#line 75
  write8(out, ntk_byte);
#line 77
  fseek(in, 768L, 0);
#line 78
  pw_move_data(out, in, 128);
#line 80
  write32b(out, (((77U << 24) | (46U << 16)) | (75U << 8)) | 46U);
#line 83
  i___3 = 0;
  }
  {
#line 83
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 83
    if (! (i___3 < (int )npat)) {
#line 83
      goto while_break___2;
    }
    {
#line 84
    fseek(in, (long )paddr[i___3], 0);
#line 85
    tmp___7 = read32b(in);
#line 85
    tsize1 = (int )tmp___7;
#line 86
    tmp___8 = read32b(in);
#line 86
    tsize2 = (int )tmp___8;
#line 87
    tmp___9 = read32b(in);
#line 87
    tsize3 = (int )tmp___9;
#line 89
    memset((void *)(tmp), 0, (size_t )1024);
#line 90
    k = 0;
    }
    {
#line 90
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 90
      if (! (k < 4)) {
#line 90
        goto while_break___3;
      }
#line 91
      j = 0;
      {
#line 91
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 91
        if (! (j < 64)) {
#line 91
          goto while_break___4;
        }
        {
#line 92
        x = j * 16 + k * 4;
#line 94
        fxp = (uint8 )0;
#line 94
        fxt = fxp;
#line 94
        ins = fxt;
#line 94
        note = ins;
#line 95
        c1 = read8(in);
        }
#line 96
        if (((int )c1 & 128) == 128) {
#line 97
          c4 = (uint8 )((int )c1 & 127);
#line 98
          j += (int )c4 - 1;
#line 99
          goto __Cont;
        }
        {
#line 102
        c2 = read8(in);
#line 103
        ins = (uint8 )(((int )c1 & 192) >> 2);
#line 104
        ins = (uint8 )((int )ins | (((int )c2 >> 4) & 15));
#line 105
        note = (uint8 )((int )c1 & 63);
        }
#line 106
        if ((int )note == 63) {
#line 107
          note = NO_NOTE;
        } else
#line 108
        if ((int )note != 0) {
#line 109
          note = (uint8 )((int )note - 11);
        }
#line 110
        if ((int )note == 0) {
#line 111
          note = (uint8 )((int )note + 1);
        }
#line 112
        tmp[x] = (uint8 )((int )ins & 240);
#line 113
        if ((int )note != (int )NO_NOTE) {
#line 114
          tmp[x] = (uint8 )((int )tmp[x] | (int )ptk_table[note][0]);
#line 115
          tmp[x + 1] = (uint8 )ptk_table[note][1];
        }
#line 117
        if (((int )c2 & 15) == 7) {
#line 118
          fxt = (uint8 )0;
#line 119
          fxp = (uint8 )0;
#line 120
          tmp[x + 2] = (uint8 )(((int )ins << 4) & 240);
#line 121
          goto __Cont;
        }
        {
#line 124
        c3 = read8(in);
#line 125
        fxt = (uint8 )((int )c2 & 15);
#line 126
        fxp = c3;
#line 127
        tmp[x + 2] = (uint8 )(((int )ins << 4) & 240);
#line 128
        tmp[x + 2] = (uint8 )((int )tmp[x + 2] | (int )fxt);
#line 129
        tmp[x + 3] = fxp;
        }
        __Cont: /* CIL Label */ 
#line 91
        j ++;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 90
      k ++;
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 132
    fwrite((void const   */* __restrict  */)(tmp), (size_t )1024, (size_t )1, (FILE */* __restrict  */)out);
#line 83
    i___3 ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 136
  fseek(in, (long )saddr, 0);
#line 137
  pw_move_data(out, in, ssize);
  }
#line 139
  return (0);
}
}
#line 143 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/prowizard/ac1d.c"
static int test_AC1D(uint8 *data , int s ) 
{ 
  int j ;
  int k ;
  int start ;

  {
#line 146
  start = 0;
  {
#line 148
  while (1) {
    while_continue: /* CIL Label */ ;
#line 148
    if (s < 896) {
#line 148
      return (896 - s);
    }
#line 148
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 151
  if ((int )*(data + 2) != 172) {
#line 152
    return (-1);
  } else
#line 151
  if ((int )*(data + 3) != 29) {
#line 152
    return (-1);
  }
#line 155
  if ((int )*(data + start) > 127) {
#line 156
    return (-1);
  }
#line 159
  k = 0;
  {
#line 159
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 159
    if (! (k < 31)) {
#line 159
      goto while_break___0;
    }
#line 160
    if ((int )*(data + ((start + 10) + 8 * k)) > 15) {
#line 161
      return (-1);
    }
#line 159
    k ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 165
  j = 0;
  {
#line 165
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 165
    if (! (j < 128)) {
#line 165
      goto while_break___1;
    }
#line 166
    if ((int )*(data + ((start + 768) + j)) > 127) {
#line 167
      return (-1);
    }
#line 165
    j ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 170
  return (0);
}
}
#line 6 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/prowizard/tuning.c"
short const   tun_table[16][36]  = 
#line 6 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/prowizard/tuning.c"
  { {        (short const   )856,        (short const   )808,        (short const   )762,        (short const   )720, 
            (short const   )678,        (short const   )640,        (short const   )604,        (short const   )570, 
            (short const   )538,        (short const   )508,        (short const   )480,        (short const   )453, 
            (short const   )428,        (short const   )404,        (short const   )381,        (short const   )360, 
            (short const   )339,        (short const   )320,        (short const   )302,        (short const   )285, 
            (short const   )269,        (short const   )254,        (short const   )240,        (short const   )226, 
            (short const   )214,        (short const   )202,        (short const   )190,        (short const   )180, 
            (short const   )170,        (short const   )160,        (short const   )151,        (short const   )143, 
            (short const   )135,        (short const   )127,        (short const   )120,        (short const   )113}, 
   {        (short const   )850,        (short const   )802,        (short const   )757,        (short const   )715, 
            (short const   )674,        (short const   )637,        (short const   )601,        (short const   )567, 
            (short const   )535,        (short const   )505,        (short const   )477,        (short const   )450, 
            (short const   )425,        (short const   )401,        (short const   )379,        (short const   )357, 
            (short const   )337,        (short const   )318,        (short const   )300,        (short const   )284, 
            (short const   )268,        (short const   )253,        (short const   )239,        (short const   )225, 
            (short const   )213,        (short const   )201,        (short const   )189,        (short const   )179, 
            (short const   )169,        (short const   )159,        (short const   )150,        (short const   )142, 
            (short const   )134,        (short const   )126,        (short const   )119,        (short const   )113}, 
   {        (short const   )844,        (short const   )796,        (short const   )752,        (short const   )709, 
            (short const   )670,        (short const   )632,        (short const   )597,        (short const   )563, 
            (short const   )532,        (short const   )502,        (short const   )474,        (short const   )447, 
            (short const   )422,        (short const   )398,        (short const   )376,        (short const   )355, 
            (short const   )335,        (short const   )316,        (short const   )298,        (short const   )282, 
            (short const   )266,        (short const   )251,        (short const   )237,        (short const   )224, 
            (short const   )211,        (short const   )199,        (short const   )188,        (short const   )177, 
            (short const   )167,        (short const   )158,        (short const   )149,        (short const   )141, 
            (short const   )133,        (short const   )125,        (short const   )118,        (short const   )112}, 
   {        (short const   )838,        (short const   )791,        (short const   )746,        (short const   )704, 
            (short const   )665,        (short const   )628,        (short const   )592,        (short const   )559, 
            (short const   )528,        (short const   )498,        (short const   )470,        (short const   )444, 
            (short const   )419,        (short const   )395,        (short const   )373,        (short const   )352, 
            (short const   )332,        (short const   )314,        (short const   )296,        (short const   )280, 
            (short const   )264,        (short const   )249,        (short const   )235,        (short const   )222, 
            (short const   )209,        (short const   )198,        (short const   )187,        (short const   )176, 
            (short const   )166,        (short const   )157,        (short const   )148,        (short const   )140, 
            (short const   )132,        (short const   )125,        (short const   )118,        (short const   )111}, 
   {        (short const   )832,        (short const   )785,        (short const   )741,        (short const   )699, 
            (short const   )660,        (short const   )623,        (short const   )588,        (short const   )555, 
            (short const   )524,        (short const   )495,        (short const   )467,        (short const   )441, 
            (short const   )416,        (short const   )392,        (short const   )370,        (short const   )350, 
            (short const   )330,        (short const   )312,        (short const   )294,        (short const   )278, 
            (short const   )262,        (short const   )247,        (short const   )233,        (short const   )220, 
            (short const   )208,        (short const   )196,        (short const   )185,        (short const   )175, 
            (short const   )165,        (short const   )156,        (short const   )147,        (short const   )139, 
            (short const   )131,        (short const   )124,        (short const   )117,        (short const   )110}, 
   {        (short const   )826,        (short const   )779,        (short const   )736,        (short const   )694, 
            (short const   )655,        (short const   )619,        (short const   )584,        (short const   )551, 
            (short const   )520,        (short const   )491,        (short const   )463,        (short const   )437, 
            (short const   )413,        (short const   )390,        (short const   )368,        (short const   )347, 
            (short const   )328,        (short const   )309,        (short const   )292,        (short const   )276, 
            (short const   )260,        (short const   )245,        (short const   )232,        (short const   )219, 
            (short const   )206,        (short const   )195,        (short const   )184,        (short const   )174, 
            (short const   )164,        (short const   )155,        (short const   )146,        (short const   )138, 
            (short const   )130,        (short const   )123,        (short const   )116,        (short const   )109}, 
   {        (short const   )820,        (short const   )774,        (short const   )730,        (short const   )689, 
            (short const   )651,        (short const   )614,        (short const   )580,        (short const   )547, 
            (short const   )516,        (short const   )487,        (short const   )460,        (short const   )434, 
            (short const   )410,        (short const   )387,        (short const   )365,        (short const   )345, 
            (short const   )325,        (short const   )307,        (short const   )290,        (short const   )274, 
            (short const   )258,        (short const   )244,        (short const   )230,        (short const   )217, 
            (short const   )205,        (short const   )193,        (short const   )183,        (short const   )172, 
            (short const   )163,        (short const   )154,        (short const   )145,        (short const   )137, 
            (short const   )129,        (short const   )122,        (short const   )115,        (short const   )109}, 
   {        (short const   )814,        (short const   )768,        (short const   )725,        (short const   )684, 
            (short const   )646,        (short const   )610,        (short const   )575,        (short const   )543, 
            (short const   )513,        (short const   )484,        (short const   )457,        (short const   )431, 
            (short const   )407,        (short const   )384,        (short const   )363,        (short const   )342, 
            (short const   )323,        (short const   )305,        (short const   )288,        (short const   )272, 
            (short const   )256,        (short const   )242,        (short const   )228,        (short const   )216, 
            (short const   )204,        (short const   )192,        (short const   )181,        (short const   )171, 
            (short const   )161,        (short const   )152,        (short const   )144,        (short const   )136, 
            (short const   )128,        (short const   )121,        (short const   )114,        (short const   )108}, 
   {        (short const   )907,        (short const   )856,        (short const   )808,        (short const   )762, 
            (short const   )720,        (short const   )678,        (short const   )640,        (short const   )604, 
            (short const   )570,        (short const   )538,        (short const   )508,        (short const   )480, 
            (short const   )453,        (short const   )428,        (short const   )404,        (short const   )381, 
            (short const   )360,        (short const   )339,        (short const   )320,        (short const   )302, 
            (short const   )285,        (short const   )269,        (short const   )254,        (short const   )240, 
            (short const   )226,        (short const   )214,        (short const   )202,        (short const   )190, 
            (short const   )180,        (short const   )170,        (short const   )160,        (short const   )151, 
            (short const   )143,        (short const   )135,        (short const   )127,        (short const   )120}, 
   {        (short const   )900,        (short const   )850,        (short const   )802,        (short const   )757, 
            (short const   )715,        (short const   )675,        (short const   )636,        (short const   )601, 
            (short const   )567,        (short const   )535,        (short const   )505,        (short const   )477, 
            (short const   )450,        (short const   )425,        (short const   )401,        (short const   )379, 
            (short const   )357,        (short const   )337,        (short const   )318,        (short const   )300, 
            (short const   )284,        (short const   )268,        (short const   )253,        (short const   )238, 
            (short const   )225,        (short const   )212,        (short const   )200,        (short const   )189, 
            (short const   )179,        (short const   )169,        (short const   )159,        (short const   )150, 
            (short const   )142,        (short const   )134,        (short const   )126,        (short const   )119}, 
   {        (short const   )894,        (short const   )844,        (short const   )796,        (short const   )752, 
            (short const   )709,        (short const   )670,        (short const   )632,        (short const   )597, 
            (short const   )563,        (short const   )532,        (short const   )502,        (short const   )474, 
            (short const   )447,        (short const   )422,        (short const   )398,        (short const   )376, 
            (short const   )355,        (short const   )335,        (short const   )316,        (short const   )298, 
            (short const   )282,        (short const   )266,        (short const   )251,        (short const   )237, 
            (short const   )223,        (short const   )211,        (short const   )199,        (short const   )188, 
            (short const   )177,        (short const   )167,        (short const   )158,        (short const   )149, 
            (short const   )141,        (short const   )133,        (short const   )125,        (short const   )118}, 
   {        (short const   )887,        (short const   )838,        (short const   )791,        (short const   )746, 
            (short const   )704,        (short const   )665,        (short const   )628,        (short const   )592, 
            (short const   )559,        (short const   )528,        (short const   )498,        (short const   )470, 
            (short const   )444,        (short const   )419,        (short const   )395,        (short const   )373, 
            (short const   )352,        (short const   )332,        (short const   )314,        (short const   )296, 
            (short const   )280,        (short const   )264,        (short const   )249,        (short const   )235, 
            (short const   )222,        (short const   )209,        (short const   )198,        (short const   )187, 
            (short const   )176,        (short const   )166,        (short const   )157,        (short const   )148, 
            (short const   )140,        (short const   )132,        (short const   )125,        (short const   )118}, 
   {        (short const   )881,        (short const   )832,        (short const   )785,        (short const   )741, 
            (short const   )699,        (short const   )660,        (short const   )623,        (short const   )588, 
            (short const   )555,        (short const   )524,        (short const   )494,        (short const   )467, 
            (short const   )441,        (short const   )416,        (short const   )392,        (short const   )370, 
            (short const   )350,        (short const   )330,        (short const   )312,        (short const   )294, 
            (short const   )278,        (short const   )262,        (short const   )247,        (short const   )233, 
            (short const   )220,        (short const   )208,        (short const   )196,        (short const   )185, 
            (short const   )175,        (short const   )165,        (short const   )156,        (short const   )147, 
            (short const   )139,        (short const   )131,        (short const   )123,        (short const   )117}, 
   {        (short const   )875,        (short const   )826,        (short const   )779,        (short const   )736, 
            (short const   )694,        (short const   )655,        (short const   )619,        (short const   )584, 
            (short const   )551,        (short const   )520,        (short const   )491,        (short const   )463, 
            (short const   )437,        (short const   )413,        (short const   )390,        (short const   )368, 
            (short const   )347,        (short const   )328,        (short const   )309,        (short const   )292, 
            (short const   )276,        (short const   )260,        (short const   )245,        (short const   )232, 
            (short const   )219,        (short const   )206,        (short const   )195,        (short const   )184, 
            (short const   )174,        (short const   )164,        (short const   )155,        (short const   )146, 
            (short const   )138,        (short const   )130,        (short const   )123,        (short const   )116}, 
   {        (short const   )868,        (short const   )820,        (short const   )774,        (short const   )730, 
            (short const   )689,        (short const   )651,        (short const   )614,        (short const   )580, 
            (short const   )547,        (short const   )516,        (short const   )487,        (short const   )460, 
            (short const   )434,        (short const   )410,        (short const   )387,        (short const   )365, 
            (short const   )345,        (short const   )325,        (short const   )307,        (short const   )290, 
            (short const   )274,        (short const   )258,        (short const   )244,        (short const   )230, 
            (short const   )217,        (short const   )205,        (short const   )193,        (short const   )183, 
            (short const   )172,        (short const   )163,        (short const   )154,        (short const   )145, 
            (short const   )137,        (short const   )129,        (short const   )122,        (short const   )115}, 
   {        (short const   )862,        (short const   )814,        (short const   )768,        (short const   )725, 
            (short const   )684,        (short const   )646,        (short const   )610,        (short const   )575, 
            (short const   )543,        (short const   )513,        (short const   )484,        (short const   )457, 
            (short const   )431,        (short const   )407,        (short const   )384,        (short const   )363, 
            (short const   )342,        (short const   )323,        (short const   )305,        (short const   )288, 
            (short const   )272,        (short const   )256,        (short const   )242,        (short const   )228, 
            (short const   )216,        (short const   )203,        (short const   )192,        (short const   )181, 
            (short const   )171,        (short const   )161,        (short const   )152,        (short const   )144, 
            (short const   )136,        (short const   )128,        (short const   )121,        (short const   )114}};
#line 4 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/prowizard/ptktable.c"
uint8 const   ptk_table[37][2]  = 
#line 4 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/prowizard/ptktable.c"
  { {        (uint8 const   )0,        (uint8 const   )0}, 
   {        (uint8 const   )3,        (uint8 const   )88}, 
   {        (uint8 const   )3,        (uint8 const   )40}, 
   {        (uint8 const   )2,        (uint8 const   )250}, 
   {        (uint8 const   )2,        (uint8 const   )208}, 
   {        (uint8 const   )2,        (uint8 const   )166}, 
   {        (uint8 const   )2,        (uint8 const   )128}, 
   {        (uint8 const   )2,        (uint8 const   )92}, 
   {        (uint8 const   )2,        (uint8 const   )58}, 
   {        (uint8 const   )2,        (uint8 const   )26}, 
   {        (uint8 const   )1,        (uint8 const   )252}, 
   {        (uint8 const   )1,        (uint8 const   )224}, 
   {        (uint8 const   )1,        (uint8 const   )197}, 
   {        (uint8 const   )1,        (uint8 const   )172}, 
   {        (uint8 const   )1,        (uint8 const   )148}, 
   {        (uint8 const   )1,        (uint8 const   )125}, 
   {        (uint8 const   )1,        (uint8 const   )104}, 
   {        (uint8 const   )1,        (uint8 const   )83}, 
   {        (uint8 const   )1,        (uint8 const   )64}, 
   {        (uint8 const   )1,        (uint8 const   )46}, 
   {        (uint8 const   )1,        (uint8 const   )29}, 
   {        (uint8 const   )1,        (uint8 const   )13}, 
   {        (uint8 const   )0,        (uint8 const   )254}, 
   {        (uint8 const   )0,        (uint8 const   )240}, 
   {        (uint8 const   )0,        (uint8 const   )226}, 
   {        (uint8 const   )0,        (uint8 const   )214}, 
   {        (uint8 const   )0,        (uint8 const   )202}, 
   {        (uint8 const   )0,        (uint8 const   )190}, 
   {        (uint8 const   )0,        (uint8 const   )180}, 
   {        (uint8 const   )0,        (uint8 const   )170}, 
   {        (uint8 const   )0,        (uint8 const   )160}, 
   {        (uint8 const   )0,        (uint8 const   )151}, 
   {        (uint8 const   )0,        (uint8 const   )143}, 
   {        (uint8 const   )0,        (uint8 const   )135}, 
   {        (uint8 const   )0,        (uint8 const   )127}, 
   {        (uint8 const   )0,        (uint8 const   )120}, 
   {        (uint8 const   )0,        (uint8 const   )113}};
#line 46 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/prowizard/prowiz.h"
int pw_wizardry(int in , int out , struct pw_format **fmt___0 ) ;
#line 50
int pw_check(unsigned char *b___1 , int s ) ;
#line 23 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/prowizard/prowiz.c"
static int check(unsigned char *b___1 , int s ) ;
#line 25 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/prowizard/prowiz.c"
static struct list_head pw_format_list  =    {& pw_format_list, & pw_format_list};
#line 28 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/prowizard/prowiz.c"
int pw_enable(char *id , int enable ) 
{ 
  struct list_head *tmp ;
  struct pw_format *format ;
  int tmp___0 ;

  {
#line 33
  tmp = pw_format_list.next;
  {
#line 33
  while (1) {
    while_continue: /* CIL Label */ ;
#line 33
    if (! ((unsigned long )tmp != (unsigned long )(& pw_format_list))) {
#line 33
      goto while_break;
    }
    {
#line 34
    format = (struct pw_format *)((char *)tmp - (unsigned long )(& ((struct pw_format *)0)->list));
#line 35
    tmp___0 = strcmp((char const   *)id, (char const   *)format->id);
    }
#line 35
    if (! tmp___0) {
#line 36
      format->enable = enable;
#line 37
      return (0);
    }
#line 33
    tmp = tmp->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 41
  return (1);
}
}
#line 44 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/prowizard/prowiz.c"
int pw_register(struct pw_format *f ) 
{ 


  {
  {
#line 46
  f->enable = 1;
#line 47
  list_add_tail(& f->list, & pw_format_list);
#line 48
  register_format(f->id, f->name);
  }
#line 49
  return (0);
}
}
#line 52 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/prowizard/prowiz.c"
int pw_unregister(struct pw_format *f ) 
{ 


  {
  {
#line 54
  list_del(& f->list);
  }
#line 55
  return (0);
}
}
#line 58 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/prowizard/prowiz.c"
int pw_move_data(FILE *out , FILE *in , int len ) 
{ 
  uint8 buf___1[1024] ;
  int l ;
  int tmp ;
  size_t tmp___0 ;
  void *__cil_tmp8 ;

  {
  {
#line 63
  while (1) {
    while_continue: /* CIL Label */ ;
#line 64
    if (len > 1024) {
#line 64
      tmp = 1024;
    } else {
#line 64
      tmp = len;
    }
    {
#line 64
    tmp___0 = fread((void */* __restrict  */)(buf___1), (size_t )1, (size_t )tmp,
                    (FILE */* __restrict  */)in);
#line 64
    l = (int )tmp___0;
#line 65
    fwrite((void const   */* __restrict  */)(buf___1), (size_t )1, (size_t )l, (FILE */* __restrict  */)out);
#line 66
    len -= l;
    }
#line 63
    if (l > 0) {
#line 63
      if (! (len > 0)) {
#line 63
        goto while_break;
      }
    } else {
#line 63
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 69
  return (0);
}
}
#line 72 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/prowizard/prowiz.c"
int pw_write_zero(FILE *out , int len ) 
{ 
  uint8 buf___1[1024] ;
  int l ;
  void *__cil_tmp5 ;

  {
  {
#line 77
  while (1) {
    while_continue: /* CIL Label */ ;
#line 78
    if (len > 1024) {
#line 78
      l = 1024;
    } else {
#line 78
      l = len;
    }
    {
#line 79
    memset((void *)(buf___1), 0, (size_t )l);
#line 80
    fwrite((void const   */* __restrict  */)(buf___1), (size_t )1, (size_t )l, (FILE */* __restrict  */)out);
#line 81
    len -= l;
    }
#line 77
    if (l > 0) {
#line 77
      if (! (len > 0)) {
#line 77
        goto while_break;
      }
    } else {
#line 77
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 84
  return (0);
}
}
#line 87 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/prowizard/prowiz.c"
int pw_init(void) 
{ 


  {
  {
#line 90
  pw_register(& pw_ac1d);
#line 92
  pw_register(& pw_fchs);
#line 93
  pw_register(& pw_fcm);
#line 94
  pw_register(& pw_fuzz);
#line 95
  pw_register(& pw_kris);
#line 96
  pw_register(& pw_ksm);
#line 97
  pw_register(& pw_mp_id);
#line 98
  pw_register(& pw_p18a);
#line 99
  pw_register(& pw_p10c);
#line 100
  pw_register(& pw_pru1);
#line 101
  pw_register(& pw_pru2);
#line 102
  pw_register(& pw_pha);
#line 103
  pw_register(& pw_wn);
#line 104
  pw_register(& pw_unic_id);
#line 105
  pw_register(& pw_tp3);
#line 108
  pw_register(& pw_xann);
#line 109
  pw_register(& pw_mp_noid);
#line 110
  pw_register(& pw_di);
#line 111
  pw_register(& pw_eu);
#line 112
  pw_register(& pw_p4x);
#line 113
  pw_register(& pw_pp21);
#line 114
  pw_register(& pw_p50a);
#line 115
  pw_register(& pw_p60a);
#line 116
  pw_register(& pw_np2);
#line 117
  pw_register(& pw_np1);
#line 118
  pw_register(& pw_np3);
#line 119
  pw_register(& pw_zen);
#line 120
  pw_register(& pw_unic_emptyid);
#line 121
  pw_register(& pw_unic_noid);
#line 122
  pw_register(& pw_unic2);
#line 123
  pw_register(& pw_crb);
#line 124
  pw_register(& pw_tdd);
#line 125
  pw_register(& pw_starpack);
#line 126
  pw_register(& pw_gmc);
  }
#line 128
  return (0);
}
}
#line 131 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/prowizard/prowiz.c"
struct list_head *checked_format  =    & pw_format_list;
#line 133 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/prowizard/prowiz.c"
int pw_wizardry(int in , int out , struct pw_format **fmt___0 ) 
{ 
  struct list_head *tmp ;
  struct pw_format *format ;
  struct stat st ;
  int size___0 ;
  int in_size ;
  uint8 *data ;
  FILE *file_in ;
  FILE *file_out ;
  int tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  int tmp___3 ;
  void *__cil_tmp16 ;
  void *__cil_tmp17 ;
  void *__cil_tmp18 ;
  void *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;

  {
  {
#line 138
  size___0 = -1;
#line 142
  file_in = fdopen(in, "rb");
  }
#line 143
  if ((unsigned long )file_in == (unsigned long )((void *)0)) {
#line 144
    return (-1);
  }
  {
#line 146
  file_out = fdopen(out, "w+b");
#line 148
  tmp___0 = fileno(file_in);
#line 148
  tmp___1 = fstat(tmp___0, & st);
  }
#line 148
  if (tmp___1 < 0) {
#line 149
    in_size = -1;
  } else {
#line 151
    in_size = (int )st.st_size;
  }
#line 154
  if (in_size < 2048) {
#line 155
    return (-2);
  }
  {
#line 158
  tmp___2 = malloc((size_t )(in_size + 4096));
#line 158
  data = (uint8 *)tmp___2;
  }
#line 159
  if ((unsigned long )data == (unsigned long )((void *)0)) {
    {
#line 160
    perror("Couldn\'t allocate memory");
    }
#line 161
    return (-1);
  }
  {
#line 163
  fread((void */* __restrict  */)data, (size_t )in_size, (size_t )1, (FILE */* __restrict  */)file_in);
  }
#line 170
  if ((unsigned long )checked_format != (unsigned long )(& pw_format_list)) {
#line 171
    goto checked;
  }
#line 173
  tmp = pw_format_list.next;
  {
#line 173
  while (1) {
    while_continue: /* CIL Label */ ;
#line 173
    if (! ((unsigned long )tmp != (unsigned long )(& pw_format_list))) {
#line 173
      goto while_break;
    }
#line 174
    format = (struct pw_format *)((char *)tmp - (unsigned long )(& ((struct pw_format *)0)->list));
    {
#line 175
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 175
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 176
    tmp___3 = (*(format->test))(data, in_size);
    }
#line 176
    if (tmp___3 >= 0) {
#line 177
      goto done;
    }
#line 173
    tmp = tmp->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 179
  return (-1);
  checked: 
#line 182
  format = (struct pw_format *)((char *)checked_format - (unsigned long )(& ((struct pw_format *)0)->list));
  {
#line 183
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 183
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 184
  checked_format = & pw_format_list;
  done: 
  {
#line 187
  fseek(file_in, 0L, 0);
#line 188
  size___0 = -1;
  }
#line 189
  if (format->depack) {
    {
#line 190
    size___0 = (*(format->depack))(file_in, file_out);
    }
  }
#line 192
  if (size___0 < 0) {
#line 193
    return (-1);
  }
  {
#line 196
  fflush(file_out);
#line 202
  free((void *)data);
  }
#line 204
  if (fmt___0) {
#line 205
    *fmt___0 = format;
  }
#line 207
  return (0);
}
}
#line 210 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/prowizard/prowiz.c"
static struct list_head *shortcut  =    & pw_format_list;
#line 211 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/prowizard/prowiz.c"
static int check(unsigned char *b___1 , int s ) 
{ 
  struct list_head *tmp ;
  struct pw_format *format ;
  int extra ;

  {
#line 217
  tmp = shortcut->next;
  {
#line 217
  while (1) {
    while_continue: /* CIL Label */ ;
#line 217
    if (! ((unsigned long )tmp != (unsigned long )shortcut)) {
#line 217
      goto while_break;
    }
#line 218
    if ((unsigned long )tmp == (unsigned long )(& pw_format_list)) {
#line 219
      goto while_break;
    }
#line 220
    format = (struct pw_format *)((char *)tmp - (unsigned long )(& ((struct pw_format *)0)->list));
    {
#line 221
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 221
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 222
    extra = (*(format->test))(b___1, s);
    }
#line 222
    if (extra > 0) {
      {
#line 223
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 223
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 224
      shortcut = tmp->prev;
#line 225
      return (extra);
    }
#line 227
    if (extra == 0) {
      {
#line 228
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 228
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 229
      checked_format = tmp;
#line 230
      shortcut = & pw_format_list;
#line 231
      return (0);
    }
#line 217
    tmp = tmp->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 235
  shortcut = & pw_format_list;
#line 236
  return (-1);
}
}
#line 239 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/prowizard/prowiz.c"
int pw_check(unsigned char *b___1 , int s ) 
{ 
  int tmp ;

  {
  {
#line 241
  tmp = check(b___1, s);
  }
#line 241
  return (tmp);
}
}
#line 23 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/load.h"
void read_title(FILE *f , char *t , int s ) ;
#line 24
void set_xxh_defaults(struct xxm_header *xxh ) ;
#line 29 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/iff.h"
void iff_chunk(struct xmp_context *ctx___0 , FILE *f ) ;
#line 30
void iff_register(char *id , void (*loader)(struct xmp_context * , int  , FILE * ) ) ;
#line 32
void iff_setflag(int i___3 ) ;
#line 33
void iff_release(void) ;
#line 24 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/gal4_load.c"
static int gal4_test(FILE *f , char *t , int const   start ) ;
#line 25
static int gal4_load(struct xmp_context *ctx___0 , FILE *f , int const   start ) ;
#line 27 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/gal4_load.c"
struct xmp_loader_info gal4_loader  =    {(char *)"GAL4", (char *)"Galaxy Music System 4.0", & gal4_test, & gal4_load, 0,
    {(struct list_head *)0, (struct list_head *)0}};
#line 34 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/gal4_load.c"
static int gal4_test(FILE *f , char *t , int const   start ) 
{ 
  uint32 tmp ;
  uint32 tmp___0 ;
  uint32 tmp___1 ;

  {
  {
#line 36
  tmp = read32b(f);
  }
#line 36
  if (tmp != ((((82U << 24) | (73U << 16)) | (70U << 8)) | 70U)) {
#line 37
    return (-1);
  }
  {
#line 39
  read32b(f);
#line 41
  tmp___0 = read32b(f);
  }
#line 41
  if (tmp___0 != ((((65U << 24) | (77U << 16)) | (70U << 8)) | 70U)) {
#line 42
    return (-1);
  }
  {
#line 44
  tmp___1 = read32b(f);
  }
#line 44
  if (tmp___1 != ((((77U << 24) | (65U << 16)) | (73U << 8)) | 78U)) {
#line 45
    return (-1);
  }
  {
#line 47
  read_title(f, t, 0);
  }
#line 49
  return (0);
}
}
#line 52 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/gal4_load.c"
static int snum  ;
#line 54 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/gal4_load.c"
static void get_main(struct xmp_context *ctx___0 , int size___0 , FILE *f ) 
{ 
  struct xmp_player_context *p ;
  struct xmp_mod_context *m___0 ;
  char buf___1[64] ;
  int flags ;
  uint8 tmp ;
  uint8 tmp___0 ;
  uint8 tmp___1 ;
  uint8 tmp___2 ;
  void *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
  {
#line 56
  p = & ctx___0->p;
#line 57
  m___0 = & p->m;
#line 61
  fread((void */* __restrict  */)(buf___1), (size_t )1, (size_t )64, (FILE */* __restrict  */)f);
#line 62
  strncpy((char */* __restrict  */)(m___0->name), (char const   */* __restrict  */)(buf___1),
          (size_t )64);
#line 63
  strcpy((char */* __restrict  */)(m___0->type), (char const   */* __restrict  */)"Galaxy Music System 4.0");
#line 65
  tmp = read8(f);
#line 65
  flags = (int )tmp;
  }
#line 66
  if (~ flags & 1) {
#line 67
    (m___0->xxh)->flg = 1;
  }
  {
#line 68
  tmp___0 = read8(f);
#line 68
  (m___0->xxh)->chn = (int )tmp___0;
#line 69
  tmp___1 = read8(f);
#line 69
  (m___0->xxh)->tpo = (int )tmp___1;
#line 70
  tmp___2 = read8(f);
#line 70
  (m___0->xxh)->bpm = (int )tmp___2;
#line 71
  read16l(f);
#line 72
  read16l(f);
#line 73
  read8(f);
  }
#line 74
  return;
}
}
#line 76 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/gal4_load.c"
static void get_ordr(struct xmp_context *ctx___0 , int size___0 , FILE *f ) 
{ 
  struct xmp_player_context *p ;
  struct xmp_mod_context *m___0 ;
  int i___3 ;
  uint8 tmp ;

  {
  {
#line 78
  p = & ctx___0->p;
#line 79
  m___0 = & p->m;
#line 82
  tmp = read8(f);
#line 82
  (m___0->xxh)->len = (int )tmp;
#line 84
  i___3 = 0;
  }
  {
#line 84
  while (1) {
    while_continue: /* CIL Label */ ;
#line 84
    if (! (i___3 < (m___0->xxh)->len)) {
#line 84
      goto while_break;
    }
    {
#line 85
    m___0->xxo[i___3] = read8(f);
#line 84
    i___3 ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 86
  return;
}
}
#line 88 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/gal4_load.c"
static void get_patt_cnt(struct xmp_context *ctx___0 , int size___0 , FILE *f ) 
{ 
  struct xmp_player_context *p ;
  struct xmp_mod_context *m___0 ;
  int i___3 ;
  uint8 tmp ;

  {
  {
#line 90
  p = & ctx___0->p;
#line 91
  m___0 = & p->m;
#line 94
  tmp = read8(f);
#line 94
  i___3 = (int )tmp + 1;
  }
#line 96
  if (i___3 > (m___0->xxh)->pat) {
#line 97
    (m___0->xxh)->pat = i___3;
  }
#line 98
  return;
}
}
#line 100 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/gal4_load.c"
static void get_inst_cnt(struct xmp_context *ctx___0 , int size___0 , FILE *f ) 
{ 
  struct xmp_player_context *p ;
  struct xmp_mod_context *m___0 ;
  int i___3 ;
  uint8 tmp ;
  uint8 tmp___0 ;

  {
  {
#line 102
  p = & ctx___0->p;
#line 103
  m___0 = & p->m;
#line 106
  read8(f);
#line 107
  tmp = read8(f);
#line 107
  i___3 = (int )tmp + 1;
  }
#line 109
  if (i___3 > (m___0->xxh)->ins) {
#line 110
    (m___0->xxh)->ins = i___3;
  }
  {
#line 112
  fseek(f, 28L, 1);
#line 114
  tmp___0 = read8(f);
#line 114
  (m___0->xxh)->smp += (int )tmp___0;
  }
#line 115
  return;
}
}
#line 117 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/gal4_load.c"
static void get_patt(struct xmp_context *ctx___0 , int size___0 , FILE *f ) 
{ 
  struct xmp_player_context *p ;
  struct xmp_mod_context *m___0 ;
  struct xxm_event *event ;
  struct xxm_event dummy___3 ;
  int i___3 ;
  int len ;
  int chan ;
  int rows___1 ;
  int r ;
  uint8 flag ;
  uint8 tmp ;
  uint32 tmp___0 ;
  uint8 tmp___1 ;
  void *tmp___2 ;
  int j ;
  void *tmp___3 ;
  uint8 fxp ;
  uint8 tmp___4 ;
  uint8 fxt ;
  uint8 tmp___5 ;
  uint8 tmp___6 ;
  void *__cil_tmp25 ;
  char *__cil_tmp26 ;

  {
  {
#line 119
  p = & ctx___0->p;
#line 120
  m___0 = & p->m;
#line 126
  tmp = read8(f);
#line 126
  i___3 = (int )tmp;
#line 127
  tmp___0 = read32l(f);
#line 127
  len = (int )tmp___0;
#line 129
  tmp___1 = read8(f);
#line 129
  rows___1 = (int )tmp___1 + 1;
  }
  {
#line 131
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 131
    tmp___2 = calloc((size_t )1, (size_t )(sizeof(struct xxm_pattern ) + sizeof(struct xxm_trackinfo ) * (unsigned long )((m___0->xxh)->chn - 1)));
#line 131
    *(m___0->xxp + i___3) = (struct xxm_pattern *)tmp___2;
    }
#line 131
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 132
  (*(m___0->xxp + i___3))->rows = rows___1;
  {
#line 133
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 133
    j = 0;
    {
#line 133
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 133
      if (! (j < (m___0->xxh)->chn)) {
#line 133
        goto while_break___1;
      }
      {
#line 133
      (*(m___0->xxp + i___3))->info[j].index = i___3 * (m___0->xxh)->chn + j;
#line 133
      tmp___3 = calloc((size_t )(sizeof(struct xxm_track ) + sizeof(struct xxm_event ) * (unsigned long )(*(m___0->xxp + i___3))->rows),
                       (size_t )1);
#line 133
      *(m___0->xxt + (i___3 * (m___0->xxh)->chn + j)) = (struct xxm_track *)tmp___3;
#line 133
      (*(m___0->xxt + (i___3 * (m___0->xxh)->chn + j)))->rows = (*(m___0->xxp + i___3))->rows;
#line 133
      j ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 133
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 135
  r = 0;
  {
#line 135
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 135
    if (! (r < rows___1)) {
#line 135
      goto while_break___2;
    }
    {
#line 136
    flag = read8(f);
    }
#line 136
    if ((int )flag == 0) {
#line 137
      r ++;
#line 138
      goto __Cont;
    }
#line 141
    chan = (int )flag & 31;
#line 143
    if (chan < (m___0->xxh)->chn) {
#line 143
      event = & (*(m___0->xxt + (*(m___0->xxp + i___3))->info[chan].index))->event[r];
    } else {
#line 143
      event = & dummy___3;
    }
#line 145
    if ((int )flag & 128) {
      {
#line 146
      tmp___4 = read8(f);
#line 146
      fxp = tmp___4;
#line 147
      tmp___5 = read8(f);
#line 147
      fxt = tmp___5;
      }
      {
#line 150
      if ((int )fxt == 20) {
#line 150
        goto case_20;
      }
#line 153
      goto switch_default;
      case_20: /* CIL Label */ 
#line 151
      fxt = (uint8 )163;
#line 152
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 154
      if ((int )fxt > 15) {
        {
#line 155
        printf((char const   */* __restrict  */)"unknown effect %02x %02x\n", (int )fxt,
               (int )fxp);
#line 156
        fxp = (uint8 )0;
#line 156
        fxt = fxp;
        }
      }
      switch_break: /* CIL Label */ ;
      }
#line 160
      event->fxt = fxt;
#line 161
      event->fxp = fxp;
    }
#line 164
    if ((int )flag & 64) {
      {
#line 165
      event->ins = read8(f);
#line 166
      event->note = read8(f);
      }
#line 168
      if ((int )event->note == 128) {
#line 169
        event->note = (uint8 )129;
      } else
#line 170
      if ((int )event->note > 12) {
#line 171
        event->note = (uint8 )((int )event->note - 12);
      } else {
#line 173
        event->note = (uint8 )0;
      }
    }
#line 177
    if ((int )flag & 32) {
      {
#line 178
      tmp___6 = read8(f);
#line 178
      event->vol = (uint8 )(1 + (int )tmp___6 / 2);
      }
    }
    __Cont: /* CIL Label */ ;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 181
  return;
}
}
#line 183 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/gal4_load.c"
static void get_inst(struct xmp_context *ctx___0 , int size___0 , FILE *f ) 
{ 
  struct xmp_player_context *p ;
  struct xmp_mod_context *m___0 ;
  int i___3 ;
  int j ;
  int srate ;
  int finetune ;
  int flags ;
  int val ;
  int vwf ;
  int vra ;
  int vde ;
  int vsw ;
  int fade ;
  uint8 buf___1[30] ;
  uint8 tmp ;
  uint8 tmp___0 ;
  uint8 tmp___1 ;
  uint8 tmp___2 ;
  uint8 tmp___3 ;
  uint16 tmp___4 ;
  uint8 tmp___5 ;
  uint8 tmp___6 ;
  uint8 tmp___7 ;
  uint8 tmp___8 ;
  void *tmp___9 ;
  void *tmp___10 ;
  uint16 tmp___11 ;
  uint16 tmp___12 ;
  uint8 tmp___13 ;
  void *tmp___14 ;
  uint8 tmp___15 ;
  uint8 tmp___16 ;
  uint8 tmp___17 ;
  uint32 tmp___18 ;
  uint32 tmp___19 ;
  uint32 tmp___20 ;
  uint32 tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  void *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;

  {
  {
#line 185
  p = & ctx___0->p;
#line 186
  m___0 = & p->m;
#line 192
  read8(f);
#line 193
  tmp = read8(f);
#line 193
  i___3 = (int )tmp;
  }
#line 195
  if (m___0->verbosity > 1) {
#line 195
    if (i___3 == 0) {
      {
#line 196
      report((char *)"\n     Instrument name                  Smp Len   LBeg  LEnd  L Vol Pan C2Spd");
      }
    }
  }
  {
#line 199
  fread((void */* __restrict  */)(& (m___0->xxih + i___3)->name), (size_t )1, (size_t )28,
        (FILE */* __restrict  */)f);
#line 200
  str_adj((char *)((m___0->xxih + i___3)->name));
#line 202
  tmp___0 = read8(f);
#line 202
  (m___0->xxih + i___3)->nsm = (int )tmp___0;
#line 203
  fseek(f, 12L, 1);
#line 204
  fread((void */* __restrict  */)(& (m___0->xxim + i___3)->ins), (size_t )1, (size_t )96,
        (FILE */* __restrict  */)f);
#line 206
  fseek(f, 11L, 1);
#line 207
  tmp___1 = read8(f);
#line 207
  vwf = (int )tmp___1;
#line 208
  tmp___2 = read8(f);
#line 208
  vsw = (int )tmp___2;
#line 209
  read8(f);
#line 210
  read8(f);
#line 211
  tmp___3 = read8(f);
#line 211
  vde = (int )tmp___3 / 4;
#line 212
  tmp___4 = read16l(f);
#line 212
  vra = (int )tmp___4 / 16;
#line 213
  read8(f);
#line 215
  tmp___5 = read8(f);
#line 215
  val = (int )tmp___5;
  }
#line 216
  if ((val & 15) & 1) {
#line 217
    (m___0->xxih + i___3)->aei.flg |= 1;
  }
#line 218
  if ((val & 15) & 2) {
#line 219
    (m___0->xxih + i___3)->aei.flg |= 2;
  }
#line 220
  if ((val & 15) & 4) {
#line 221
    (m___0->xxih + i___3)->aei.flg |= 4;
  }
#line 222
  if (((val & 240) >> 4) & 1) {
#line 223
    (m___0->xxih + i___3)->pei.flg |= 1;
  }
#line 224
  if (((val & 240) >> 4) & 2) {
#line 225
    (m___0->xxih + i___3)->pei.flg |= 2;
  }
#line 226
  if (((val & 240) >> 4) & 4) {
#line 227
    (m___0->xxih + i___3)->pei.flg |= 4;
  }
  {
#line 229
  tmp___6 = read8(f);
#line 229
  val = (int )tmp___6;
#line 230
  (m___0->xxih + i___3)->aei.npt = (val & 15) + 1;
#line 231
  (m___0->xxih + i___3)->pei.npt = ((val & 240) >> 4) + 1;
#line 233
  tmp___7 = read8(f);
#line 233
  val = (int )tmp___7;
#line 234
  (m___0->xxih + i___3)->aei.sus = val & 15;
#line 235
  (m___0->xxih + i___3)->pei.sus = (val & 240) >> 4;
#line 237
  tmp___8 = read8(f);
#line 237
  val = (int )tmp___8;
#line 238
  (m___0->xxih + i___3)->aei.lps = val & 15;
#line 239
  (m___0->xxih + i___3)->pei.lps = (val & 240) >> 4;
#line 241
  read8(f);
#line 242
  (m___0->xxih + i___3)->aei.lpe = val & 15;
#line 243
  (m___0->xxih + i___3)->pei.lpe = (val & 240) >> 4;
  }
#line 245
  if ((m___0->xxih + i___3)->aei.npt) {
    {
#line 246
    tmp___9 = calloc((size_t )4, (size_t )(m___0->xxih + i___3)->aei.npt);
#line 246
    *(m___0->xxae + i___3) = (uint16 *)tmp___9;
    }
  } else {
#line 248
    (m___0->xxih + i___3)->aei.flg &= -2;
  }
#line 250
  if ((m___0->xxih + i___3)->pei.npt) {
    {
#line 251
    tmp___10 = calloc((size_t )4, (size_t )(m___0->xxih + i___3)->pei.npt);
#line 251
    *(m___0->xxpe + i___3) = (uint16 *)tmp___10;
    }
  } else {
#line 253
    (m___0->xxih + i___3)->pei.flg &= -2;
  }
  {
#line 255
  fread((void */* __restrict  */)(buf___1), (size_t )1, (size_t )30, (FILE */* __restrict  */)f);
#line 256
  j = 0;
  }
  {
#line 256
  while (1) {
    while_continue: /* CIL Label */ ;
#line 256
    if (! (j < (m___0->xxih + i___3)->aei.npt)) {
#line 256
      goto while_break;
    }
    {
#line 257
    tmp___11 = readmem16l(buf___1 + j * 3);
#line 257
    *(*(m___0->xxae + i___3) + j * 2) = (uint16 )((int )tmp___11 / 16);
#line 258
    *(*(m___0->xxae + i___3) + (j * 2 + 1)) = (uint16 )buf___1[j * 3 + 2];
#line 256
    j ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 261
  fread((void */* __restrict  */)(buf___1), (size_t )1, (size_t )30, (FILE */* __restrict  */)f);
#line 262
  j = 0;
  }
  {
#line 262
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 262
    if (! (j < (m___0->xxih + i___3)->pei.npt)) {
#line 262
      goto while_break___0;
    }
    {
#line 263
    tmp___12 = readmem16l(buf___1 + j * 3);
#line 263
    *(*(m___0->xxpe + i___3) + j * 2) = (uint16 )((int )tmp___12 / 16);
#line 264
    *(*(m___0->xxpe + i___3) + (j * 2 + 1)) = (uint16 )buf___1[j * 3 + 2];
#line 262
    j ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 267
  tmp___13 = read8(f);
#line 267
  fade = (int )tmp___13;
#line 268
  read8(f);
#line 270
  reportv(ctx___0, 1, (char *)"\n[%2X] %-28.28s  %2d ", i___3, (m___0->xxih + i___3)->name,
          (m___0->xxih + i___3)->nsm);
  }
#line 273
  if ((m___0->xxih + i___3)->nsm == 0) {
#line 274
    return;
  }
  {
#line 276
  tmp___14 = calloc((size_t )sizeof(struct xxm_instrument ), (size_t )(m___0->xxih + i___3)->nsm);
#line 276
  *(m___0->xxi + i___3) = (struct xxm_instrument *)tmp___14;
#line 278
  j = 0;
  }
  {
#line 278
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 278
    if (! (j < (m___0->xxih + i___3)->nsm)) {
#line 278
      goto while_break___1;
    }
    {
#line 279
    read32b(f);
#line 280
    read32b(f);
#line 282
    fread((void */* __restrict  */)(& (m___0->xxs + snum)->name), (size_t )1, (size_t )28,
          (FILE */* __restrict  */)f);
#line 283
    str_adj((char *)((m___0->xxs + snum)->name));
#line 285
    tmp___15 = read8(f);
#line 285
    (*(m___0->xxi + i___3) + j)->pan = (int )tmp___15 * 4;
    }
#line 286
    if ((*(m___0->xxi + i___3) + j)->pan == 0) {
#line 287
      (*(m___0->xxi + i___3) + j)->pan = 128;
    }
    {
#line 289
    tmp___16 = read8(f);
#line 289
    (*(m___0->xxi + i___3) + j)->vol = (int )tmp___16;
#line 290
    tmp___17 = read8(f);
#line 290
    flags = (int )tmp___17;
#line 291
    read8(f);
#line 293
    (*(m___0->xxi + i___3) + j)->vwf = vwf;
#line 294
    (*(m___0->xxi + i___3) + j)->vde = vde;
#line 295
    (*(m___0->xxi + i___3) + j)->vra = vra;
#line 296
    (*(m___0->xxi + i___3) + j)->vsw = vsw;
#line 297
    (*(m___0->xxi + i___3) + j)->sid = snum;
#line 299
    tmp___18 = read32l(f);
#line 299
    (m___0->xxs + snum)->len = (int )tmp___18;
#line 300
    tmp___19 = read32l(f);
#line 300
    (m___0->xxs + snum)->lps = (int )tmp___19;
#line 301
    tmp___20 = read32l(f);
#line 301
    (m___0->xxs + snum)->lpe = (int )tmp___20;
#line 303
    (m___0->xxs + snum)->flg = 0;
    }
#line 304
    if (flags & 4) {
#line 305
      (m___0->xxs + snum)->flg |= 1;
    }
#line 306
    if (flags & 8) {
#line 307
      (m___0->xxs + snum)->flg |= 4;
    }
#line 308
    if (flags & 16) {
#line 309
      (m___0->xxs + snum)->flg |= 8;
    }
#line 313
    if ((m___0->xxs + snum)->flg & 1) {
#line 314
      (m___0->xxs + snum)->len <<= 1;
#line 315
      (m___0->xxs + snum)->lps <<= 1;
#line 316
      (m___0->xxs + snum)->lpe <<= 1;
    }
    {
#line 319
    tmp___21 = read32l(f);
#line 319
    srate = (int )tmp___21;
#line 320
    finetune = 0;
#line 321
    c2spd_to_note(srate, & (*(m___0->xxi + i___3) + j)->xpo, & (*(m___0->xxi + i___3) + j)->fin);
#line 322
    (*(m___0->xxi + i___3) + j)->fin += finetune;
#line 324
    read32l(f);
#line 325
    read32l(f);
    }
#line 327
    if (j > 0) {
      {
#line 328
      reportv(ctx___0, 1, (char *)"\n                                      ");
      }
    }
#line 330
    if ((m___0->xxs + snum)->flg & 8) {
#line 330
      tmp___23 = 'B';
    } else {
#line 330
      if ((m___0->xxs + snum)->flg & 4) {
#line 330
        tmp___22 = 'L';
      } else {
#line 330
        tmp___22 = ' ';
      }
#line 330
      tmp___23 = tmp___22;
    }
#line 330
    if ((m___0->xxs + snum)->flg & 1) {
#line 330
      tmp___24 = '+';
    } else {
#line 330
      tmp___24 = ' ';
    }
    {
#line 330
    reportv(ctx___0, 1, (char *)"[%X] %05x%c%05x %05x %c V%02x P%02x %5d ", j, (m___0->xxs + snum)->len,
            tmp___24, (m___0->xxs + snum)->lps, (m___0->xxs + snum)->lpe, tmp___23,
            (*(m___0->xxi + i___3) + j)->vol, (*(m___0->xxi + i___3) + j)->pan, srate);
    }
#line 341
    if ((m___0->xxs + snum)->len > 1) {
      {
#line 342
      xmp_drv_loadpatch(ctx___0, f, snum, m___0->c4rate, 0, m___0->xxs + snum, (char *)((void *)0));
#line 343
      reportv(ctx___0, 0, (char *)".");
      }
    }
#line 278
    j ++;
#line 278
    snum ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 346
  return;
}
}
#line 348 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/gal4_load.c"
static int gal4_load(struct xmp_context *ctx___0 , FILE *f , int const   start ) 
{ 
  struct xmp_player_context *p ;
  struct xmp_mod_context *m___0 ;
  int i___3 ;
  int offset ;
  uint8 **tmp ;
  long tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  void *tmp___9 ;
  void *tmp___10 ;
  void *tmp___11 ;
  int tmp___12 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;

  {
#line 350
  p = & ctx___0->p;
#line 351
  m___0 = & p->m;
  {
#line 354
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 354
    fseek(f, (long )start, 0);
#line 354
    tmp = (uint8 **)((void *)0);
#line 354
    m___0->med_wav_table = tmp;
#line 354
    m___0->med_vol_table = tmp;
#line 354
    set_xxh_defaults(m___0->xxh);
    }
#line 354
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 356
  read32b(f);
#line 357
  read32b(f);
#line 358
  read32b(f);
#line 360
  tmp___0 = ftell(f);
#line 360
  offset = (int )tmp___0;
#line 362
  tmp___1 = 0;
#line 362
  (m___0->xxh)->ins = tmp___1;
#line 362
  (m___0->xxh)->smp = tmp___1;
#line 364
  iff_register((char *)"MAIN", & get_main);
#line 365
  iff_register((char *)"ORDR", & get_ordr);
#line 366
  iff_register((char *)"PATT", & get_patt_cnt);
#line 367
  iff_register((char *)"INST", & get_inst_cnt);
#line 368
  iff_setflag(1);
#line 369
  iff_setflag(32);
  }
  {
#line 372
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 372
    tmp___2 = feof(f);
    }
#line 372
    if (tmp___2) {
#line 372
      goto while_break___0;
    }
    {
#line 373
    iff_chunk(ctx___0, f);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 375
  iff_release();
#line 377
  (m___0->xxh)->trk = (m___0->xxh)->pat * (m___0->xxh)->chn;
  }
  {
#line 379
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 379
    if (m___0->verbosity) {
#line 379
      if (m___0->name[0]) {
        {
#line 379
        report((char *)"Module title   : %s\n", m___0->name);
        }
      }
#line 379
      if (m___0->type[0]) {
        {
#line 379
        report((char *)"Module type    : %s\n", m___0->type);
        }
      }
#line 379
      if (m___0->author[0]) {
        {
#line 379
        report((char *)"Author name    : %s\n", m___0->author);
        }
      }
#line 379
      if ((m___0->xxh)->len) {
        {
#line 379
        report((char *)"Module length  : %d patterns\n", (m___0->xxh)->len);
        }
      }
    }
#line 379
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 380
  while (1) {
    while_continue___2: /* CIL Label */ ;
    {
#line 380
    tmp___3 = calloc((size_t )sizeof(struct xxm_instrument_header ), (size_t )(m___0->xxh)->ins);
#line 380
    m___0->xxih = (struct xxm_instrument_header *)tmp___3;
#line 380
    tmp___4 = calloc((size_t )sizeof(struct xxm_instrument_map ), (size_t )(m___0->xxh)->ins);
#line 380
    m___0->xxim = (struct xxm_instrument_map *)tmp___4;
#line 380
    tmp___5 = calloc((size_t )sizeof(struct xxm_instrument *), (size_t )(m___0->xxh)->ins);
#line 380
    m___0->xxi = (struct xxm_instrument **)tmp___5;
    }
#line 380
    if ((m___0->xxh)->smp) {
      {
#line 380
      tmp___6 = calloc((size_t )sizeof(struct xxm_sample ), (size_t )(m___0->xxh)->smp);
#line 380
      m___0->xxs = (struct xxm_sample *)tmp___6;
      }
    }
    {
#line 380
    tmp___7 = calloc((size_t )sizeof(uint16 *), (size_t )(m___0->xxh)->ins);
#line 380
    m___0->xxae = (uint16 **)tmp___7;
#line 380
    tmp___8 = calloc((size_t )sizeof(uint16 *), (size_t )(m___0->xxh)->ins);
#line 380
    m___0->xxpe = (uint16 **)tmp___8;
#line 380
    tmp___9 = calloc((size_t )sizeof(uint16 *), (size_t )(m___0->xxh)->ins);
#line 380
    m___0->xxfe = (uint16 **)tmp___9;
    }
#line 380
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 381
  while (1) {
    while_continue___3: /* CIL Label */ ;
    {
#line 381
    tmp___10 = calloc((size_t )sizeof(struct xxm_track *), (size_t )(m___0->xxh)->trk);
#line 381
    m___0->xxt = (struct xxm_track **)tmp___10;
#line 381
    tmp___11 = calloc((size_t )sizeof(struct xxm_pattern *), (size_t )((m___0->xxh)->pat + 1));
#line 381
    m___0->xxp = (struct xxm_pattern **)tmp___11;
    }
#line 381
    goto while_break___3;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 383
  if (m___0->verbosity > 0) {
    {
#line 384
    report((char *)"Stored patterns: %d\n", (m___0->xxh)->pat);
#line 385
    report((char *)"Stored samples : %d ", (m___0->xxh)->smp);
    }
  }
  {
#line 388
  fseek(f, (long )(start + (int const   )offset), 0);
#line 389
  snum = 0;
#line 391
  iff_register((char *)"PATT", & get_patt);
#line 392
  iff_register((char *)"INST", & get_inst);
#line 393
  iff_setflag(1);
#line 394
  iff_setflag(32);
  }
  {
#line 397
  while (1) {
    while_continue___4: /* CIL Label */ ;
    {
#line 397
    tmp___12 = feof(f);
    }
#line 397
    if (tmp___12) {
#line 397
      goto while_break___4;
    }
    {
#line 398
    iff_chunk(ctx___0, f);
    }
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 400
  iff_release();
#line 402
  reportv(ctx___0, 0, (char *)"\n");
#line 404
  i___3 = 0;
  }
  {
#line 404
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 404
    if (! (i___3 < (m___0->xxh)->chn)) {
#line 404
      goto while_break___5;
    }
#line 405
    m___0->xxc[i___3].pan = 128;
#line 404
    i___3 ++;
  }
  while_break___5: /* CIL Label */ ;
  }
#line 407
  return (0);
}
}
#line 27 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/gal5_load.c"
static int gal5_test(FILE *f , char *t , int const   start ) ;
#line 28
static int gal5_load(struct xmp_context *ctx___0 , FILE *f , int const   start ) ;
#line 30 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/gal5_load.c"
struct xmp_loader_info gal5_loader  =    {(char *)"GAL5", (char *)"Galaxy Music System 5.0", & gal5_test, & gal5_load, 0,
    {(struct list_head *)0, (struct list_head *)0}};
#line 37 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/gal5_load.c"
static uint8 chn_pan[64]  ;
#line 39 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/gal5_load.c"
static int gal5_test(FILE *f , char *t , int const   start ) 
{ 
  uint32 tmp ;
  uint32 tmp___0 ;
  uint32 tmp___1 ;

  {
  {
#line 41
  tmp = read32b(f);
  }
#line 41
  if (tmp != ((((82U << 24) | (73U << 16)) | (70U << 8)) | 70U)) {
#line 42
    return (-1);
  }
  {
#line 44
  read32b(f);
#line 46
  tmp___0 = read32b(f);
  }
#line 46
  if (tmp___0 != ((((65U << 24) | (77U << 16)) | (32U << 8)) | 32U)) {
#line 47
    return (-1);
  }
  {
#line 49
  tmp___1 = read32b(f);
  }
#line 49
  if (tmp___1 != ((((73U << 24) | (78U << 16)) | (73U << 8)) | 84U)) {
#line 50
    return (-1);
  }
  {
#line 52
  read_title(f, t, 0);
  }
#line 54
  return (0);
}
}
#line 57 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/gal5_load.c"
static void get_init(struct xmp_context *ctx___0 , int size___0 , FILE *f ) 
{ 
  struct xmp_player_context *p ;
  struct xmp_mod_context *m___0 ;
  char buf___1[64] ;
  int flags ;
  uint8 tmp ;
  uint8 tmp___0 ;
  uint8 tmp___1 ;
  uint8 tmp___2 ;
  void *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
  {
#line 59
  p = & ctx___0->p;
#line 60
  m___0 = & p->m;
#line 64
  fread((void */* __restrict  */)(buf___1), (size_t )1, (size_t )64, (FILE */* __restrict  */)f);
#line 65
  strncpy((char */* __restrict  */)(m___0->name), (char const   */* __restrict  */)(buf___1),
          (size_t )64);
#line 66
  strcpy((char */* __restrict  */)(m___0->type), (char const   */* __restrict  */)"Galaxy Music System 5.0");
#line 67
  tmp = read8(f);
#line 67
  flags = (int )tmp;
  }
#line 68
  if (~ flags & 1) {
#line 69
    (m___0->xxh)->flg = 1;
  }
  {
#line 70
  tmp___0 = read8(f);
#line 70
  (m___0->xxh)->chn = (int )tmp___0;
#line 71
  tmp___1 = read8(f);
#line 71
  (m___0->xxh)->tpo = (int )tmp___1;
#line 72
  tmp___2 = read8(f);
#line 72
  (m___0->xxh)->bpm = (int )tmp___2;
#line 73
  read16l(f);
#line 74
  read16l(f);
#line 75
  read8(f);
#line 76
  fread((void */* __restrict  */)(chn_pan), (size_t )1, (size_t )64, (FILE */* __restrict  */)f);
  }
#line 77
  return;
}
}
#line 79 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/gal5_load.c"
static void get_ordr___0(struct xmp_context *ctx___0 , int size___0 , FILE *f ) 
{ 
  struct xmp_player_context *p ;
  struct xmp_mod_context *m___0 ;
  int i___3 ;
  uint8 tmp ;

  {
  {
#line 81
  p = & ctx___0->p;
#line 82
  m___0 = & p->m;
#line 85
  tmp = read8(f);
#line 85
  (m___0->xxh)->len = (int )tmp + 1;
#line 88
  i___3 = 0;
  }
  {
#line 88
  while (1) {
    while_continue: /* CIL Label */ ;
#line 88
    if (! (i___3 < (m___0->xxh)->len)) {
#line 88
      goto while_break;
    }
    {
#line 89
    m___0->xxo[i___3] = read8(f);
#line 88
    i___3 ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 90
  return;
}
}
#line 92 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/gal5_load.c"
static void get_patt_cnt___0(struct xmp_context *ctx___0 , int size___0 , FILE *f ) 
{ 
  struct xmp_player_context *p ;
  struct xmp_mod_context *m___0 ;
  int i___3 ;
  uint8 tmp ;

  {
  {
#line 94
  p = & ctx___0->p;
#line 95
  m___0 = & p->m;
#line 98
  tmp = read8(f);
#line 98
  i___3 = (int )tmp + 1;
  }
#line 100
  if (i___3 > (m___0->xxh)->pat) {
#line 101
    (m___0->xxh)->pat = i___3;
  }
#line 102
  return;
}
}
#line 104 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/gal5_load.c"
static void get_inst_cnt___0(struct xmp_context *ctx___0 , int size___0 , FILE *f ) 
{ 
  struct xmp_player_context *p ;
  struct xmp_mod_context *m___0 ;
  int i___3 ;
  uint8 tmp ;

  {
  {
#line 106
  p = & ctx___0->p;
#line 107
  m___0 = & p->m;
#line 110
  read32b(f);
#line 111
  read8(f);
#line 112
  tmp = read8(f);
#line 112
  i___3 = (int )tmp + 1;
  }
#line 114
  if (i___3 > (m___0->xxh)->ins) {
#line 115
    (m___0->xxh)->ins = i___3;
  }
#line 116
  return;
}
}
#line 118 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/gal5_load.c"
static void get_patt___0(struct xmp_context *ctx___0 , int size___0 , FILE *f ) 
{ 
  struct xmp_player_context *p ;
  struct xmp_mod_context *m___0 ;
  struct xxm_event *event ;
  struct xxm_event dummy___3 ;
  int i___3 ;
  int len ;
  int chan ;
  int rows___1 ;
  int r ;
  uint8 flag ;
  uint8 tmp ;
  uint32 tmp___0 ;
  uint8 tmp___1 ;
  void *tmp___2 ;
  int j ;
  void *tmp___3 ;
  uint8 fxp ;
  uint8 tmp___4 ;
  uint8 fxt ;
  uint8 tmp___5 ;
  uint8 tmp___6 ;
  void *__cil_tmp25 ;
  char *__cil_tmp26 ;

  {
  {
#line 120
  p = & ctx___0->p;
#line 121
  m___0 = & p->m;
#line 127
  tmp = read8(f);
#line 127
  i___3 = (int )tmp;
#line 128
  tmp___0 = read32l(f);
#line 128
  len = (int )tmp___0;
#line 130
  tmp___1 = read8(f);
#line 130
  rows___1 = (int )tmp___1 + 1;
  }
  {
#line 132
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 132
    tmp___2 = calloc((size_t )1, (size_t )(sizeof(struct xxm_pattern ) + sizeof(struct xxm_trackinfo ) * (unsigned long )((m___0->xxh)->chn - 1)));
#line 132
    *(m___0->xxp + i___3) = (struct xxm_pattern *)tmp___2;
    }
#line 132
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 133
  (*(m___0->xxp + i___3))->rows = rows___1;
  {
#line 134
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 134
    j = 0;
    {
#line 134
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 134
      if (! (j < (m___0->xxh)->chn)) {
#line 134
        goto while_break___1;
      }
      {
#line 134
      (*(m___0->xxp + i___3))->info[j].index = i___3 * (m___0->xxh)->chn + j;
#line 134
      tmp___3 = calloc((size_t )(sizeof(struct xxm_track ) + sizeof(struct xxm_event ) * (unsigned long )(*(m___0->xxp + i___3))->rows),
                       (size_t )1);
#line 134
      *(m___0->xxt + (i___3 * (m___0->xxh)->chn + j)) = (struct xxm_track *)tmp___3;
#line 134
      (*(m___0->xxt + (i___3 * (m___0->xxh)->chn + j)))->rows = (*(m___0->xxp + i___3))->rows;
#line 134
      j ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 134
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 136
  r = 0;
  {
#line 136
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 136
    if (! (r < rows___1)) {
#line 136
      goto while_break___2;
    }
    {
#line 137
    flag = read8(f);
    }
#line 137
    if ((int )flag == 0) {
#line 138
      r ++;
#line 139
      goto __Cont;
    }
#line 142
    chan = (int )flag & 31;
#line 144
    if (chan < (m___0->xxh)->chn) {
#line 144
      event = & (*(m___0->xxt + (*(m___0->xxp + i___3))->info[chan].index))->event[r];
    } else {
#line 144
      event = & dummy___3;
    }
#line 146
    if ((int )flag & 128) {
      {
#line 147
      tmp___4 = read8(f);
#line 147
      fxp = tmp___4;
#line 148
      tmp___5 = read8(f);
#line 148
      fxt = tmp___5;
      }
      {
#line 151
      if ((int )fxt == 20) {
#line 151
        goto case_20;
      }
#line 154
      goto switch_default;
      case_20: /* CIL Label */ 
#line 152
      fxt = (uint8 )163;
#line 153
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 155
      if ((int )fxt > 15) {
        {
#line 156
        printf((char const   */* __restrict  */)"unknown effect %02x %02x\n", (int )fxt,
               (int )fxp);
#line 157
        fxp = (uint8 )0;
#line 157
        fxt = fxp;
        }
      }
      switch_break: /* CIL Label */ ;
      }
#line 161
      event->fxt = fxt;
#line 162
      event->fxp = fxp;
    }
#line 165
    if ((int )flag & 64) {
      {
#line 166
      event->ins = read8(f);
#line 167
      event->note = read8(f);
      }
#line 169
      if ((int )event->note == 128) {
#line 170
        event->note = (uint8 )129;
      } else
#line 171
      if ((int )event->note > 12) {
#line 172
        event->note = (uint8 )((int )event->note - 12);
      } else {
#line 174
        event->note = (uint8 )0;
      }
    }
#line 178
    if ((int )flag & 32) {
      {
#line 179
      tmp___6 = read8(f);
#line 179
      event->vol = (uint8 )(1 + (int )tmp___6 / 2);
      }
    }
    __Cont: /* CIL Label */ ;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 182
  return;
}
}
#line 184 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/gal5_load.c"
static void get_inst___0(struct xmp_context *ctx___0 , int size___0 , FILE *f ) 
{ 
  struct xmp_player_context *p ;
  struct xmp_mod_context *m___0 ;
  int i___3 ;
  int srate ;
  int finetune ;
  int flags ;
  uint8 tmp ;
  uint16 tmp___0 ;
  void *tmp___1 ;
  uint8 tmp___2 ;
  uint16 tmp___3 ;
  uint16 tmp___4 ;
  uint32 tmp___5 ;
  uint32 tmp___6 ;
  uint32 tmp___7 ;
  uint32 tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;

  {
  {
#line 186
  p = & ctx___0->p;
#line 187
  m___0 = & p->m;
#line 190
  read32b(f);
#line 191
  read8(f);
#line 192
  tmp = read8(f);
#line 192
  i___3 = (int )tmp;
  }
#line 194
  if (m___0->verbosity > 1) {
#line 194
    if (i___3 == 0) {
      {
#line 195
      report((char *)"\n     Instrument name                  Smp Len   LBeg  LEnd  L Vol Flag C2Spd");
      }
    }
  }
  {
#line 198
  fread((void */* __restrict  */)(& (m___0->xxih + i___3)->name), (size_t )1, (size_t )28,
        (FILE */* __restrict  */)f);
#line 199
  str_adj((char *)((m___0->xxih + i___3)->name));
#line 201
  fseek(f, 290L, 1);
#line 202
  tmp___0 = read16l(f);
#line 202
  (m___0->xxih + i___3)->nsm = (int )tmp___0;
#line 204
  reportv(ctx___0, 1, (char *)"\n[%2X] %-28.28s  %2d ", i___3, (m___0->xxih + i___3)->name,
          (m___0->xxih + i___3)->nsm);
  }
#line 207
  if ((m___0->xxih + i___3)->nsm == 0) {
#line 208
    return;
  }
  {
#line 210
  tmp___1 = calloc((size_t )sizeof(struct xxm_instrument ), (size_t )(m___0->xxih + i___3)->nsm);
#line 210
  *(m___0->xxi + i___3) = (struct xxm_instrument *)tmp___1;
#line 214
  read32b(f);
#line 215
  read32b(f);
#line 216
  read32b(f);
#line 217
  read32b(f);
#line 218
  read32b(f);
#line 219
  read32b(f);
#line 221
  fread((void */* __restrict  */)(& (m___0->xxs + i___3)->name), (size_t )1, (size_t )28,
        (FILE */* __restrict  */)f);
#line 222
  str_adj((char *)((m___0->xxs + i___3)->name));
#line 224
  read32b(f);
#line 225
  read8(f);
#line 227
  (*(m___0->xxi + i___3) + 0)->sid = i___3;
#line 228
  tmp___2 = read8(f);
#line 228
  (m___0->xxih + i___3)->vol = (int )tmp___2;
#line 229
  (*(m___0->xxi + i___3) + 0)->pan = 128;
#line 230
  tmp___3 = read16l(f);
#line 230
  (*(m___0->xxi + i___3) + 0)->vol = ((int )tmp___3 + 1) / 512;
#line 231
  tmp___4 = read16l(f);
#line 231
  flags = (int )tmp___4;
#line 232
  read16l(f);
#line 233
  tmp___5 = read32l(f);
#line 233
  (m___0->xxs + i___3)->len = (int )tmp___5;
#line 234
  tmp___6 = read32l(f);
#line 234
  (m___0->xxs + i___3)->lps = (int )tmp___6;
#line 235
  tmp___7 = read32l(f);
#line 235
  (m___0->xxs + i___3)->lpe = (int )tmp___7;
#line 237
  (m___0->xxs + i___3)->flg = 0;
  }
#line 238
  if (flags & 4) {
#line 239
    (m___0->xxs + i___3)->flg |= 1;
  }
#line 240
  if (flags & 8) {
#line 241
    (m___0->xxs + i___3)->flg |= 4;
  }
#line 242
  if (flags & 16) {
#line 243
    (m___0->xxs + i___3)->flg |= 12;
  }
#line 244
  if (~ flags & 128) {
#line 245
    (m___0->xxs + i___3)->flg |= 2;
  }
  {
#line 247
  tmp___8 = read32l(f);
#line 247
  srate = (int )tmp___8;
#line 248
  finetune = 0;
#line 249
  c2spd_to_note(srate, & (*(m___0->xxi + i___3) + 0)->xpo, & (*(m___0->xxi + i___3) + 0)->fin);
#line 250
  (*(m___0->xxi + i___3) + 0)->fin += finetune;
#line 252
  read32l(f);
#line 253
  read32l(f);
  }
#line 255
  if ((m___0->xxs + i___3)->flg & 8) {
#line 255
    tmp___10 = 'B';
  } else {
#line 255
    if ((m___0->xxs + i___3)->flg & 4) {
#line 255
      tmp___9 = 'L';
    } else {
#line 255
      tmp___9 = ' ';
    }
#line 255
    tmp___10 = tmp___9;
  }
#line 255
  if ((m___0->xxs + i___3)->flg & 1) {
#line 255
    tmp___11 = '+';
  } else {
#line 255
    tmp___11 = ' ';
  }
  {
#line 255
  reportv(ctx___0, 1, (char *)"[%x] %05x%c%05x %05x %c V%02x %04x %5d ", 0, (m___0->xxs + i___3)->len,
          tmp___11, (m___0->xxs + i___3)->lps, (m___0->xxs + i___3)->lpe, tmp___10,
          (*(m___0->xxi + i___3) + 0)->vol, flags, srate);
  }
#line 264
  if ((m___0->xxs + i___3)->len > 1) {
    {
#line 265
    xmp_drv_loadpatch(ctx___0, f, i___3, m___0->c4rate, 0, m___0->xxs + i___3, (char *)((void *)0));
#line 266
    reportv(ctx___0, 0, (char *)".");
    }
  }
#line 268
  return;
}
}
#line 270 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/gal5_load.c"
static int gal5_load(struct xmp_context *ctx___0 , FILE *f , int const   start ) 
{ 
  struct xmp_player_context *p ;
  struct xmp_mod_context *m___0 ;
  int i___3 ;
  int offset ;
  uint8 **tmp ;
  long tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  void *tmp___9 ;
  void *tmp___10 ;
  void *tmp___11 ;
  int tmp___12 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;

  {
#line 272
  p = & ctx___0->p;
#line 273
  m___0 = & p->m;
  {
#line 276
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 276
    fseek(f, (long )start, 0);
#line 276
    tmp = (uint8 **)((void *)0);
#line 276
    m___0->med_wav_table = tmp;
#line 276
    m___0->med_vol_table = tmp;
#line 276
    set_xxh_defaults(m___0->xxh);
    }
#line 276
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 278
  read32b(f);
#line 279
  read32b(f);
#line 280
  read32b(f);
#line 282
  tmp___0 = ftell(f);
#line 282
  offset = (int )tmp___0;
#line 284
  tmp___1 = 0;
#line 284
  (m___0->xxh)->ins = tmp___1;
#line 284
  (m___0->xxh)->smp = tmp___1;
#line 286
  iff_register((char *)"INIT", & get_init);
#line 287
  iff_register((char *)"ORDR", & get_ordr___0);
#line 288
  iff_register((char *)"PATT", & get_patt_cnt___0);
#line 289
  iff_register((char *)"INST", & get_inst_cnt___0);
#line 290
  iff_setflag(1);
#line 291
  iff_setflag(16);
#line 292
  iff_setflag(4);
  }
  {
#line 295
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 295
    tmp___2 = feof(f);
    }
#line 295
    if (tmp___2) {
#line 295
      goto while_break___0;
    }
    {
#line 296
    iff_chunk(ctx___0, f);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 298
  iff_release();
#line 300
  (m___0->xxh)->trk = (m___0->xxh)->pat * (m___0->xxh)->chn;
#line 301
  (m___0->xxh)->smp = (m___0->xxh)->ins;
  }
  {
#line 303
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 303
    if (m___0->verbosity) {
#line 303
      if (m___0->name[0]) {
        {
#line 303
        report((char *)"Module title   : %s\n", m___0->name);
        }
      }
#line 303
      if (m___0->type[0]) {
        {
#line 303
        report((char *)"Module type    : %s\n", m___0->type);
        }
      }
#line 303
      if (m___0->author[0]) {
        {
#line 303
        report((char *)"Author name    : %s\n", m___0->author);
        }
      }
#line 303
      if ((m___0->xxh)->len) {
        {
#line 303
        report((char *)"Module length  : %d patterns\n", (m___0->xxh)->len);
        }
      }
    }
#line 303
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 304
  while (1) {
    while_continue___2: /* CIL Label */ ;
    {
#line 304
    tmp___3 = calloc((size_t )sizeof(struct xxm_instrument_header ), (size_t )(m___0->xxh)->ins);
#line 304
    m___0->xxih = (struct xxm_instrument_header *)tmp___3;
#line 304
    tmp___4 = calloc((size_t )sizeof(struct xxm_instrument_map ), (size_t )(m___0->xxh)->ins);
#line 304
    m___0->xxim = (struct xxm_instrument_map *)tmp___4;
#line 304
    tmp___5 = calloc((size_t )sizeof(struct xxm_instrument *), (size_t )(m___0->xxh)->ins);
#line 304
    m___0->xxi = (struct xxm_instrument **)tmp___5;
    }
#line 304
    if ((m___0->xxh)->smp) {
      {
#line 304
      tmp___6 = calloc((size_t )sizeof(struct xxm_sample ), (size_t )(m___0->xxh)->smp);
#line 304
      m___0->xxs = (struct xxm_sample *)tmp___6;
      }
    }
    {
#line 304
    tmp___7 = calloc((size_t )sizeof(uint16 *), (size_t )(m___0->xxh)->ins);
#line 304
    m___0->xxae = (uint16 **)tmp___7;
#line 304
    tmp___8 = calloc((size_t )sizeof(uint16 *), (size_t )(m___0->xxh)->ins);
#line 304
    m___0->xxpe = (uint16 **)tmp___8;
#line 304
    tmp___9 = calloc((size_t )sizeof(uint16 *), (size_t )(m___0->xxh)->ins);
#line 304
    m___0->xxfe = (uint16 **)tmp___9;
    }
#line 304
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 305
  while (1) {
    while_continue___3: /* CIL Label */ ;
    {
#line 305
    tmp___10 = calloc((size_t )sizeof(struct xxm_track *), (size_t )(m___0->xxh)->trk);
#line 305
    m___0->xxt = (struct xxm_track **)tmp___10;
#line 305
    tmp___11 = calloc((size_t )sizeof(struct xxm_pattern *), (size_t )((m___0->xxh)->pat + 1));
#line 305
    m___0->xxp = (struct xxm_pattern **)tmp___11;
    }
#line 305
    goto while_break___3;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 307
  if (m___0->verbosity > 0) {
    {
#line 308
    report((char *)"Stored patterns: %d\n", (m___0->xxh)->pat);
#line 309
    report((char *)"Stored samples : %d ", (m___0->xxh)->smp);
    }
  }
  {
#line 312
  fseek(f, (long )(start + (int const   )offset), 0);
#line 314
  iff_register((char *)"PATT", & get_patt___0);
#line 315
  iff_register((char *)"INST", & get_inst___0);
#line 316
  iff_setflag(1);
#line 317
  iff_setflag(16);
#line 318
  iff_setflag(4);
  }
  {
#line 321
  while (1) {
    while_continue___4: /* CIL Label */ ;
    {
#line 321
    tmp___12 = feof(f);
    }
#line 321
    if (tmp___12) {
#line 321
      goto while_break___4;
    }
    {
#line 322
    iff_chunk(ctx___0, f);
    }
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 324
  iff_release();
#line 326
  reportv(ctx___0, 0, (char *)"\n");
#line 328
  i___3 = 0;
  }
  {
#line 328
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 328
    if (! (i___3 < (m___0->xxh)->chn)) {
#line 328
      goto while_break___5;
    }
#line 329
    m___0->xxc[i___3].pan = (int )chn_pan[i___3] * 2;
#line 328
    i___3 ++;
  }
  while_break___5: /* CIL Label */ ;
  }
#line 331
  return (0);
}
}
#line 21 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/load.h"
char *copy_adjust(uint8 *s , uint8 *r , int n___0 ) ;
#line 25
void cvt_pt_event(struct xxm_event *event , uint8 *mod_event ) ;
#line 22 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/pw_load.c"
static int pw_test(FILE *f , char *t , int const   start ) ;
#line 23
static int pw_load(struct xmp_context *ctx___0 , FILE *f , int const   start ) ;
#line 25 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/pw_load.c"
struct xmp_loader_info pw_loader  =    {(char *)"pw", (char *)"prowizard", & pw_test, & pw_load, 0, {(struct list_head *)0,
                                                                 (struct list_head *)0}};
#line 34 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/pw_load.c"
static int pw_test(FILE *f , char *t , int const   start ) 
{ 
  unsigned char *b___1 ;
  int extra ;
  int s ;
  void *tmp ;
  void *tmp___0 ;
  struct pw_format *format ;

  {
  {
#line 38
  s = 65536;
#line 40
  tmp = calloc((size_t )1, (size_t )65536);
#line 40
  b___1 = (unsigned char *)tmp;
#line 41
  fread((void */* __restrict  */)b___1, (size_t )s, (size_t )1, (FILE */* __restrict  */)f);
  }
  {
#line 43
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 43
    extra = pw_check(b___1, s);
    }
#line 43
    if (! (extra > 0)) {
#line 43
      goto while_break;
    }
    {
#line 44
    tmp___0 = realloc((void *)b___1, (size_t )(s + extra));
#line 44
    b___1 = (unsigned char *)tmp___0;
#line 45
    fread((void */* __restrict  */)(b___1 + s), (size_t )extra, (size_t )1, (FILE */* __restrict  */)f);
#line 46
    s += extra;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 49
  free((void *)b___1);
  }
#line 51
  if (extra == 0) {
#line 53
    format = (struct pw_format *)((char *)checked_format - (unsigned long )(& ((struct pw_format *)0)->list));
#line 54
    if (format->enable) {
#line 55
      return (0);
    }
  }
#line 58
  return (-1);
}
}
#line 61 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/pw_load.c"
static int pw_load(struct xmp_context *ctx___0 , FILE *f , int const   start ) 
{ 
  struct xmp_player_context *p ;
  struct xmp_mod_context *m___0 ;
  struct xmp_options *o___0 ;
  struct xxm_event *event ;
  struct mod_header mh ;
  uint8 mod_event[4] ;
  struct pw_format *fmt___0 ;
  char tmp[4096] ;
  int i___3 ;
  int j ;
  int fd___1 ;
  int tmp___0 ;
  int tmp___1 ;
  uint8 **tmp___2 ;
  uint8 tmp___3 ;
  uint8 tmp___4 ;
  int tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  void *tmp___9 ;
  void *tmp___10 ;
  void *tmp___11 ;
  void *tmp___12 ;
  void *tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  void *tmp___16 ;
  void *tmp___17 ;
  void *tmp___18 ;
  int j___0 ;
  void *tmp___19 ;
  void *__cil_tmp36 ;
  void *__cil_tmp37 ;
  void *__cil_tmp38 ;
  int __cil_tmp39 ;
  void *__cil_tmp40 ;
  void *__cil_tmp41 ;
  void *__cil_tmp42 ;
  void *__cil_tmp43 ;
  void *__cil_tmp44 ;
  void *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;

  {
  {
#line 63
  p = & ctx___0->p;
#line 64
  m___0 = & p->m;
#line 65
  o___0 = & ctx___0->o;
#line 76
  get_temp_dir(tmp, 4096);
#line 77
  strncat((char */* __restrict  */)(tmp), (char const   */* __restrict  */)"xmp_XXXXXX",
          (size_t )4096);
#line 79
  fd___1 = mkstemp(tmp);
  }
#line 79
  if (fd___1 < 0) {
#line 80
    return (-1);
  }
  {
#line 82
  tmp___0 = fileno(f);
#line 82
  tmp___1 = pw_wizardry(tmp___0, fd___1, & fmt___0);
  }
#line 82
  if (tmp___1 < 0) {
    {
#line 83
    close(fd___1);
#line 84
    unlink((char const   *)(tmp));
    }
#line 85
    return (-1);
  }
  {
#line 88
  f = fdopen(fd___1, "w+b");
  }
#line 88
  if ((unsigned long )f == (unsigned long )((void *)0)) {
    {
#line 89
    close(fd___1);
#line 90
    unlink((char const   *)(tmp));
    }
#line 91
    return (-1);
  }
  {
#line 97
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 97
    fseek(f, (long )start, 0);
#line 97
    tmp___2 = (uint8 **)((void *)0);
#line 97
    m___0->med_wav_table = tmp___2;
#line 97
    m___0->med_vol_table = tmp___2;
#line 97
    set_xxh_defaults(m___0->xxh);
    }
#line 97
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 99
  fread((void */* __restrict  */)(& mh.name), (size_t )20, (size_t )1, (FILE */* __restrict  */)f);
#line 100
  i___3 = 0;
  }
  {
#line 100
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 100
    if (! (i___3 < 31)) {
#line 100
      goto while_break___0;
    }
    {
#line 101
    fread((void */* __restrict  */)(& mh.ins[i___3].name), (size_t )22, (size_t )1,
          (FILE */* __restrict  */)f);
#line 102
    mh.ins[i___3].size = read16b(f);
#line 103
    tmp___3 = read8(f);
#line 103
    mh.ins[i___3].finetune = (int8 )tmp___3;
#line 104
    tmp___4 = read8(f);
#line 104
    mh.ins[i___3].volume = (int8 )tmp___4;
#line 105
    mh.ins[i___3].loop_start = read16b(f);
#line 106
    mh.ins[i___3].loop_size = read16b(f);
#line 100
    i___3 ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 108
  mh.len = read8(f);
#line 109
  mh.restart = read8(f);
#line 110
  fread((void */* __restrict  */)(& mh.order), (size_t )128, (size_t )1, (FILE */* __restrict  */)f);
#line 111
  fread((void */* __restrict  */)(& mh.magic), (size_t )4, (size_t )1, (FILE */* __restrict  */)f);
#line 113
  tmp___5 = memcmp((void const   *)(mh.magic), (void const   *)"M.K.", (size_t )4);
  }
#line 113
  if (tmp___5) {
#line 114
    goto err;
  }
  {
#line 116
  (m___0->xxh)->ins = 31;
#line 117
  (m___0->xxh)->smp = (m___0->xxh)->ins;
#line 118
  (m___0->xxh)->chn = 4;
#line 119
  (m___0->xxh)->len = (int )mh.len;
#line 120
  (m___0->xxh)->rst = (int )mh.restart;
#line 121
  memcpy((void */* __restrict  */)(m___0->xxo), (void const   */* __restrict  */)(mh.order),
         (size_t )128);
#line 123
  i___3 = 0;
  }
  {
#line 123
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 123
    if (! (i___3 < 128)) {
#line 123
      goto while_break___1;
    }
#line 124
    if ((m___0->xxh)->chn > 4) {
#line 125
      m___0->xxo[i___3] = (uint8 )((int )m___0->xxo[i___3] >> 1);
    }
#line 126
    if ((int )m___0->xxo[i___3] > (m___0->xxh)->pat) {
#line 127
      (m___0->xxh)->pat = (int )m___0->xxo[i___3];
    }
#line 123
    i___3 ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 130
  ((m___0->xxh)->pat) ++;
#line 132
  (m___0->xxh)->trk = (m___0->xxh)->chn * (m___0->xxh)->pat;
#line 134
  strncpy((char */* __restrict  */)(m___0->name), (char const   */* __restrict  */)((char *)(mh.name)),
          (size_t )20);
#line 135
  sprintf((char */* __restrict  */)(m___0->type), (char const   */* __restrict  */)"%s (%s)",
          fmt___0->id, fmt___0->name);
  }
  {
#line 136
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 136
    if (m___0->verbosity) {
#line 136
      if (m___0->name[0]) {
        {
#line 136
        report((char *)"Module title   : %s\n", m___0->name);
        }
      }
#line 136
      if (m___0->type[0]) {
        {
#line 136
        report((char *)"Module type    : %s\n", m___0->type);
        }
      }
#line 136
      if (m___0->author[0]) {
        {
#line 136
        report((char *)"Author name    : %s\n", m___0->author);
        }
      }
#line 136
      if ((m___0->xxh)->len) {
        {
#line 136
        report((char *)"Module length  : %d patterns\n", (m___0->xxh)->len);
        }
      }
    }
#line 136
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 138
  while (1) {
    while_continue___3: /* CIL Label */ ;
    {
#line 138
    tmp___6 = calloc((size_t )sizeof(struct xxm_instrument_header ), (size_t )(m___0->xxh)->ins);
#line 138
    m___0->xxih = (struct xxm_instrument_header *)tmp___6;
#line 138
    tmp___7 = calloc((size_t )sizeof(struct xxm_instrument_map ), (size_t )(m___0->xxh)->ins);
#line 138
    m___0->xxim = (struct xxm_instrument_map *)tmp___7;
#line 138
    tmp___8 = calloc((size_t )sizeof(struct xxm_instrument *), (size_t )(m___0->xxh)->ins);
#line 138
    m___0->xxi = (struct xxm_instrument **)tmp___8;
    }
#line 138
    if ((m___0->xxh)->smp) {
      {
#line 138
      tmp___9 = calloc((size_t )sizeof(struct xxm_sample ), (size_t )(m___0->xxh)->smp);
#line 138
      m___0->xxs = (struct xxm_sample *)tmp___9;
      }
    }
    {
#line 138
    tmp___10 = calloc((size_t )sizeof(uint16 *), (size_t )(m___0->xxh)->ins);
#line 138
    m___0->xxae = (uint16 **)tmp___10;
#line 138
    tmp___11 = calloc((size_t )sizeof(uint16 *), (size_t )(m___0->xxh)->ins);
#line 138
    m___0->xxpe = (uint16 **)tmp___11;
#line 138
    tmp___12 = calloc((size_t )sizeof(uint16 *), (size_t )(m___0->xxh)->ins);
#line 138
    m___0->xxfe = (uint16 **)tmp___12;
    }
#line 138
    goto while_break___3;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 140
  reportv(ctx___0, 1, (char *)"     Instrument name        Len  LBeg LEnd L Vol Fin\n");
#line 143
  i___3 = 0;
  }
  {
#line 143
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 143
    if (! (i___3 < (m___0->xxh)->ins)) {
#line 143
      goto while_break___4;
    }
    {
#line 144
    tmp___13 = calloc((size_t )sizeof(struct xxm_instrument ), (size_t )1);
#line 144
    *(m___0->xxi + i___3) = (struct xxm_instrument *)tmp___13;
#line 145
    (m___0->xxs + i___3)->len = 2 * (int )mh.ins[i___3].size;
#line 146
    (m___0->xxs + i___3)->lps = 2 * (int )mh.ins[i___3].loop_start;
#line 147
    (m___0->xxs + i___3)->lpe = (m___0->xxs + i___3)->lps + 2 * (int )mh.ins[i___3].loop_size;
    }
#line 148
    if ((int )mh.ins[i___3].loop_size > 1) {
#line 148
      (m___0->xxs + i___3)->flg = 4;
    } else {
#line 148
      (m___0->xxs + i___3)->flg = 0;
    }
#line 149
    (*(m___0->xxi + i___3) + 0)->fin = (int )((int8 )((int )mh.ins[i___3].finetune << 4));
#line 150
    (*(m___0->xxi + i___3) + 0)->vol = (int )mh.ins[i___3].volume;
#line 151
    (*(m___0->xxi + i___3) + 0)->pan = 128;
#line 152
    (*(m___0->xxi + i___3) + 0)->sid = i___3;
#line 153
    (m___0->xxih + i___3)->nsm = ! (! (m___0->xxs + i___3)->len);
#line 154
    (m___0->xxih + i___3)->rls = 4095;
#line 156
    if ((m___0->xxs + i___3)->flg & 4) {
#line 157
      if ((m___0->xxs + i___3)->lps == 0) {
#line 157
        if ((m___0->xxs + i___3)->len > (m___0->xxs + i___3)->lpe) {
#line 158
          (m___0->xxs + i___3)->flg |= 128;
        }
      }
    }
    {
#line 161
    copy_adjust((m___0->xxih + i___3)->name, mh.ins[i___3].name, 22);
    }
#line 163
    if (m___0->verbosity > 1) {
#line 164
      if ((m___0->xxih + i___3)->name[0]) {
#line 164
        goto _L;
      } else
#line 164
      if ((m___0->xxs + i___3)->len > 2) {
        _L: /* CIL Label */ 
#line 165
        if ((m___0->xxs + i___3)->flg & 128) {
#line 165
          tmp___14 = '!';
        } else {
#line 165
          tmp___14 = ' ';
        }
#line 165
        if ((int )mh.ins[i___3].loop_size > 1) {
#line 165
          tmp___15 = 'L';
        } else {
#line 165
          tmp___15 = ' ';
        }
        {
#line 165
        report((char *)"[%2X] %-22.22s %04x %04x %04x %c V%02x %+d %c\n", i___3, (m___0->xxih + i___3)->name,
               (m___0->xxs + i___3)->len, (m___0->xxs + i___3)->lps, (m___0->xxs + i___3)->lpe,
               tmp___15, (*(m___0->xxi + i___3) + 0)->vol, (*(m___0->xxi + i___3) + 0)->fin >> 4,
               tmp___14);
        }
      }
    }
#line 143
    i___3 ++;
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 176
  while (1) {
    while_continue___5: /* CIL Label */ ;
    {
#line 176
    tmp___16 = calloc((size_t )sizeof(struct xxm_track *), (size_t )(m___0->xxh)->trk);
#line 176
    m___0->xxt = (struct xxm_track **)tmp___16;
#line 176
    tmp___17 = calloc((size_t )sizeof(struct xxm_pattern *), (size_t )((m___0->xxh)->pat + 1));
#line 176
    m___0->xxp = (struct xxm_pattern **)tmp___17;
    }
#line 176
    goto while_break___5;
  }
  while_break___5: /* CIL Label */ ;
  }
  {
#line 179
  reportv(ctx___0, 0, (char *)"Stored patterns: %d ", (m___0->xxh)->pat);
#line 181
  i___3 = 0;
  }
  {
#line 181
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 181
    if (! (i___3 < (m___0->xxh)->pat)) {
#line 181
      goto while_break___6;
    }
    {
#line 182
    while (1) {
      while_continue___7: /* CIL Label */ ;
      {
#line 182
      tmp___18 = calloc((size_t )1, (size_t )(sizeof(struct xxm_pattern ) + sizeof(struct xxm_trackinfo ) * (unsigned long )((m___0->xxh)->chn - 1)));
#line 182
      *(m___0->xxp + i___3) = (struct xxm_pattern *)tmp___18;
      }
#line 182
      goto while_break___7;
    }
    while_break___7: /* CIL Label */ ;
    }
#line 183
    (*(m___0->xxp + i___3))->rows = 64;
    {
#line 184
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 184
      j___0 = 0;
      {
#line 184
      while (1) {
        while_continue___9: /* CIL Label */ ;
#line 184
        if (! (j___0 < (m___0->xxh)->chn)) {
#line 184
          goto while_break___9;
        }
        {
#line 184
        (*(m___0->xxp + i___3))->info[j___0].index = i___3 * (m___0->xxh)->chn + j___0;
#line 184
        tmp___19 = calloc((size_t )(sizeof(struct xxm_track ) + sizeof(struct xxm_event ) * (unsigned long )(*(m___0->xxp + i___3))->rows),
                          (size_t )1);
#line 184
        *(m___0->xxt + (i___3 * (m___0->xxh)->chn + j___0)) = (struct xxm_track *)tmp___19;
#line 184
        (*(m___0->xxt + (i___3 * (m___0->xxh)->chn + j___0)))->rows = (*(m___0->xxp + i___3))->rows;
#line 184
        j___0 ++;
        }
      }
      while_break___9: /* CIL Label */ ;
      }
#line 184
      goto while_break___8;
    }
    while_break___8: /* CIL Label */ ;
    }
#line 185
    j = 0;
    {
#line 185
    while (1) {
      while_continue___10: /* CIL Label */ ;
#line 185
      if (! (j < 256)) {
#line 185
        goto while_break___10;
      }
      {
#line 186
      event = & (*(m___0->xxt + (*(m___0->xxp + i___3))->info[j % 4].index))->event[j / 4];
#line 187
      fread((void */* __restrict  */)(mod_event), (size_t )1, (size_t )4, (FILE */* __restrict  */)f);
#line 188
      cvt_pt_event(event, mod_event);
#line 185
      j ++;
      }
    }
    while_break___10: /* CIL Label */ ;
    }
    {
#line 190
    reportv(ctx___0, 0, (char *)".");
#line 181
    i___3 ++;
    }
  }
  while_break___6: /* CIL Label */ ;
  }
#line 193
  (m___0->xxh)->flg |= 2;
#line 195
  if (o___0->skipsmp) {
#line 196
    goto end;
  }
  {
#line 200
  reportv(ctx___0, 0, (char *)"\nStored samples : %d ", (m___0->xxh)->smp);
#line 201
  i___3 = 0;
  }
  {
#line 201
  while (1) {
    while_continue___11: /* CIL Label */ ;
#line 201
    if (! (i___3 < (m___0->xxh)->smp)) {
#line 201
      goto while_break___11;
    }
    {
#line 202
    xmp_drv_loadpatch(ctx___0, f, (*(m___0->xxi + i___3) + 0)->sid, m___0->c4rate,
                      0, m___0->xxs + (*(m___0->xxi + i___3) + 0)->sid, (char *)((void *)0));
#line 204
    reportv(ctx___0, 0, (char *)".");
#line 201
    i___3 ++;
    }
  }
  while_break___11: /* CIL Label */ ;
  }
  {
#line 206
  reportv(ctx___0, 0, (char *)"\n");
  }
  end: 
  {
#line 209
  fclose(f);
#line 210
  unlink((char const   *)(tmp));
  }
#line 211
  return (0);
  err: 
  {
#line 214
  fclose(f);
#line 215
  unlink((char const   *)(tmp));
  }
#line 216
  return (-1);
}
}
#line 15 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/coco_load.c"
static int coco_test(FILE *f , char *t , int const   start ) ;
#line 16
static int coco_load(struct xmp_context *ctx___0 , FILE *f , int const   start ) ;
#line 18 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/coco_load.c"
struct xmp_loader_info coco_loader  =    {(char *)"COCO", (char *)"Coconizer", & coco_test, & coco_load, 0, {(struct list_head *)0,
                                                                       (struct list_head *)0}};
#line 25 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/coco_load.c"
static int coco_test(FILE *f , char *t , int const   start ) 
{ 
  uint8 x ;
  uint32 y ;
  int n___0 ;
  uint8 tmp ;
  uint8 tmp___0 ;
  uint8 tmp___1 ;

  {
  {
#line 31
  read32l(f);
#line 32
  read8(f);
#line 34
  tmp = read8(f);
#line 34
  x = (uint8 )((int )tmp & 63);
  }
#line 35
  if ((int )x != 4) {
#line 35
    if ((int )x != 8) {
#line 36
      return (-1);
    }
  }
  {
#line 38
  fseek(f, 19L, 1);
#line 40
  tmp___0 = read8(f);
  }
#line 40
  if ((int )tmp___0 != 13) {
#line 41
    return (-1);
  }
  {
#line 43
  tmp___1 = read8(f);
#line 43
  n___0 = (int )tmp___1;
#line 44
  read8(f);
#line 45
  read8(f);
#line 47
  y = read32l(f);
  }
#line 48
  if (y < 64U) {
#line 49
    return (-1);
  } else
#line 48
  if (y > 1048576U) {
#line 49
    return (-1);
  }
  {
#line 51
  y = read32l(f);
  }
#line 52
  if (y < 64U) {
#line 53
    return (-1);
  } else
#line 52
  if (y > 1048576U) {
#line 53
    return (-1);
  }
  {
#line 55
  y = read32l(f);
  }
#line 56
  if (y < 64U) {
#line 57
    return (-1);
  } else
#line 56
  if (y > 1048576U) {
#line 57
    return (-1);
  }
  {
#line 59
  fseek(f, (long )(start + 1), 0);
#line 60
  read_title(f, t, 19);
  }
#line 62
  return (0);
}
}
#line 65 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/coco_load.c"
static int coco_load(struct xmp_context *ctx___0 , FILE *f , int const   start ) 
{ 
  struct xmp_player_context *p ;
  struct xmp_mod_context *m___0 ;
  struct xxm_event *event ;
  int i___3 ;
  int j ;
  int seq_ptr ;
  int pat_ptr ;
  int smp_ptr ;
  unsigned char x ;
  uint8 **tmp ;
  uint8 tmp___0 ;
  int tmp___1 ;
  uint8 tmp___2 ;
  uint8 tmp___3 ;
  uint8 tmp___4 ;
  uint32 tmp___5 ;
  uint32 tmp___6 ;
  uint32 tmp___7 ;
  void *tmp___8 ;
  void *tmp___9 ;
  void *tmp___10 ;
  void *tmp___11 ;
  void *tmp___12 ;
  void *tmp___13 ;
  void *tmp___14 ;
  void *tmp___15 ;
  uint16 tmp___16 ;
  int val ;
  uint16 tmp___17 ;
  uint32 tmp___18 ;
  uint32 tmp___19 ;
  uint16 tmp___20 ;
  uint32 tmp___21 ;
  uint32 tmp___22 ;
  int tmp___23 ;
  size_t tmp___24 ;
  void *tmp___25 ;
  void *tmp___26 ;
  void *tmp___27 ;
  int j___0 ;
  void *tmp___28 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;

  {
#line 67
  p = & ctx___0->p;
#line 68
  m___0 = & p->m;
  {
#line 74
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 74
    fseek(f, (long )start, 0);
#line 74
    tmp = (uint8 **)((void *)0);
#line 74
    m___0->med_wav_table = tmp;
#line 74
    m___0->med_vol_table = tmp;
#line 74
    set_xxh_defaults(m___0->xxh);
    }
#line 74
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 76
  read32l(f);
#line 77
  read8(f);
#line 79
  tmp___0 = read8(f);
#line 79
  (m___0->xxh)->chn = (int )tmp___0 & 63;
#line 80
  read_title(f, m___0->name, 19);
#line 81
  read8(f);
#line 83
  strcpy((char */* __restrict  */)(m___0->type), (char const   */* __restrict  */)"Coconizer");
#line 85
  tmp___2 = read8(f);
#line 85
  tmp___1 = (int )tmp___2;
#line 85
  (m___0->xxh)->smp = tmp___1;
#line 85
  (m___0->xxh)->ins = tmp___1;
#line 86
  tmp___3 = read8(f);
#line 86
  (m___0->xxh)->len = (int )tmp___3;
#line 87
  tmp___4 = read8(f);
#line 87
  (m___0->xxh)->pat = (int )tmp___4;
#line 88
  (m___0->xxh)->trk = (m___0->xxh)->pat * (m___0->xxh)->chn;
#line 90
  tmp___5 = read32l(f);
#line 90
  seq_ptr = (int )tmp___5;
#line 91
  tmp___6 = read32l(f);
#line 91
  pat_ptr = (int )tmp___6;
#line 92
  tmp___7 = read32l(f);
#line 92
  smp_ptr = (int )tmp___7;
  }
  {
#line 94
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 94
    if (m___0->verbosity) {
#line 94
      if (m___0->name[0]) {
        {
#line 94
        report((char *)"Module title   : %s\n", m___0->name);
        }
      }
#line 94
      if (m___0->type[0]) {
        {
#line 94
        report((char *)"Module type    : %s\n", m___0->type);
        }
      }
#line 94
      if (m___0->author[0]) {
        {
#line 94
        report((char *)"Author name    : %s\n", m___0->author);
        }
      }
#line 94
      if ((m___0->xxh)->len) {
        {
#line 94
        report((char *)"Module length  : %d patterns\n", (m___0->xxh)->len);
        }
      }
    }
#line 94
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 95
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 95
    tmp___8 = calloc((size_t )sizeof(struct xxm_instrument_header ), (size_t )(m___0->xxh)->ins);
#line 95
    m___0->xxih = (struct xxm_instrument_header *)tmp___8;
#line 95
    tmp___9 = calloc((size_t )sizeof(struct xxm_instrument_map ), (size_t )(m___0->xxh)->ins);
#line 95
    m___0->xxim = (struct xxm_instrument_map *)tmp___9;
#line 95
    tmp___10 = calloc((size_t )sizeof(struct xxm_instrument *), (size_t )(m___0->xxh)->ins);
#line 95
    m___0->xxi = (struct xxm_instrument **)tmp___10;
    }
#line 95
    if ((m___0->xxh)->smp) {
      {
#line 95
      tmp___11 = calloc((size_t )sizeof(struct xxm_sample ), (size_t )(m___0->xxh)->smp);
#line 95
      m___0->xxs = (struct xxm_sample *)tmp___11;
      }
    }
    {
#line 95
    tmp___12 = calloc((size_t )sizeof(uint16 *), (size_t )(m___0->xxh)->ins);
#line 95
    m___0->xxae = (uint16 **)tmp___12;
#line 95
    tmp___13 = calloc((size_t )sizeof(uint16 *), (size_t )(m___0->xxh)->ins);
#line 95
    m___0->xxpe = (uint16 **)tmp___13;
#line 95
    tmp___14 = calloc((size_t )sizeof(uint16 *), (size_t )(m___0->xxh)->ins);
#line 95
    m___0->xxfe = (uint16 **)tmp___14;
    }
#line 95
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 97
  reportv(ctx___0, 1, (char *)"     Name        Len  LBeg LEnd L Vol\n");
#line 99
  i___3 = 0;
  }
  {
#line 99
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 99
    if (! (i___3 < (m___0->xxh)->ins)) {
#line 99
      goto while_break___2;
    }
    {
#line 100
    tmp___15 = calloc((size_t )sizeof(struct xxm_instrument ), (size_t )1);
#line 100
    *(m___0->xxi + i___3) = (struct xxm_instrument *)tmp___15;
#line 102
    tmp___16 = read16l(f);
#line 102
    (m___0->xxs + i___3)->len = (int )tmp___16;
#line 104
    (*(m___0->xxi + i___3) + 0)->vol = 64;
#line 105
    (*(m___0->xxi + i___3) + 0)->pan = 128;
    }
    {
#line 107
    while (1) {
      while_continue___3: /* CIL Label */ ;
      {
#line 110
      x = read8(f);
      }
      {
#line 111
      if ((int )x == 0) {
#line 111
        goto case_0;
      }
#line 126
      if ((int )x == 254) {
#line 126
        goto case_254;
      }
#line 110
      goto switch_break;
      case_0: /* CIL Label */ 
      {
#line 112
      tmp___17 = read16l(f);
#line 112
      val = (int )tmp___17;
      }
      {
#line 113
      if (val == 0) {
#line 113
        goto case_0___0;
      }
#line 121
      goto switch_default;
      case_0___0: /* CIL Label */ 
      {
#line 114
      tmp___18 = read32l(f);
#line 114
      (m___0->xxs + i___3)->lps = (int )tmp___18;
#line 115
      tmp___19 = read32l(f);
#line 115
      (m___0->xxs + i___3)->lpe = (int )((uint32 )(m___0->xxs + i___3)->lps + tmp___19);
      }
#line 117
      if ((m___0->xxs + i___3)->lps > 0) {
#line 117
        (m___0->xxs + i___3)->flg = 4;
      } else {
#line 117
        (m___0->xxs + i___3)->flg = 0;
      }
#line 119
      x = (unsigned char)254;
#line 120
      goto switch_break___0;
      switch_default: /* CIL Label */ 
#line 122
      (*(m___0->xxi + i___3) + 0)->vol = 64 - (val >> 8);
#line 123
      goto switch_break___0;
      switch_break___0: /* CIL Label */ ;
      }
#line 125
      goto switch_break;
      case_254: /* CIL Label */ 
      {
#line 127
      tmp___20 = read16l(f);
      }
      {
#line 128
      if ((int )tmp___20 == 6) {
#line 128
        goto case_6;
      }
#line 136
      if ((int )tmp___20 == 14) {
#line 136
        goto case_14;
      }
#line 136
      if ((int )tmp___20 == 11) {
#line 136
        goto case_14;
      }
#line 127
      goto switch_break___1;
      case_6: /* CIL Label */ 
      {
#line 129
      tmp___21 = read32l(f);
#line 129
      (m___0->xxs + i___3)->lps = (int )tmp___21;
#line 130
      tmp___22 = read32l(f);
#line 130
      (m___0->xxs + i___3)->lpe = (int )((uint32 )(m___0->xxs + i___3)->lps + tmp___22);
      }
#line 132
      if ((m___0->xxs + i___3)->lps > 0) {
#line 132
        (m___0->xxs + i___3)->flg = 4;
      } else {
#line 132
        (m___0->xxs + i___3)->flg = 0;
      }
#line 134
      goto switch_break___1;
      case_14: /* CIL Label */ 
      case_11: /* CIL Label */ 
#line 137
      goto switch_break___1;
      switch_break___1: /* CIL Label */ ;
      }
#line 139
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
#line 107
      if (! ((int )x != 254)) {
#line 107
        goto while_break___3;
      }
    }
    while_break___3: /* CIL Label */ ;
    }
#line 143
    j = 0;
    {
#line 143
    while (1) {
      while_continue___4: /* CIL Label */ ;
      {
#line 143
      x = read8(f);
      }
#line 143
      if (! ((int )x != 13)) {
#line 143
        goto while_break___4;
      }
#line 144
      (m___0->xxih + i___3)->name[j] = x;
#line 143
      j ++;
    }
    while_break___4: /* CIL Label */ ;
    }
    {
#line 146
    read8(f);
#line 147
    read8(f);
#line 148
    read8(f);
#line 150
    (m___0->xxih + i___3)->nsm = ! (! (m___0->xxs + i___3)->len);
#line 151
    (*(m___0->xxi + i___3) + 0)->sid = i___3;
    }
#line 153
    if (m___0->verbosity > 1) {
      {
#line 153
      tmp___24 = strlen((char const   *)((char *)((m___0->xxih + i___3)->name)));
      }
#line 153
      if (tmp___24) {
#line 153
        goto _L;
      } else
#line 153
      if ((m___0->xxs + i___3)->len > 1) {
        _L: /* CIL Label */ 
#line 154
        if ((m___0->xxs + i___3)->flg & 4) {
#line 154
          tmp___23 = 'L';
        } else {
#line 154
          tmp___23 = ' ';
        }
        {
#line 154
        report((char *)"[%2X] %-10.10s %04x %04x %04x %c V%02x\n", i___3, (m___0->xxih + i___3)->name,
               (m___0->xxs + i___3)->len, (m___0->xxs + i___3)->lps, (m___0->xxs + i___3)->lpe,
               tmp___23, (*(m___0->xxi + i___3) + 0)->vol);
        }
      }
    }
#line 99
    i___3 ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 164
  fseek(f, (long )(start + (int const   )seq_ptr), 0);
#line 165
  i___3 = 0;
  }
  {
#line 165
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 165
    if (! (i___3 < (m___0->xxh)->len)) {
#line 165
      goto while_break___5;
    }
    {
#line 166
    m___0->xxo[i___3] = read8(f);
#line 165
    i___3 ++;
    }
  }
  while_break___5: /* CIL Label */ ;
  }
  {
#line 171
  while (1) {
    while_continue___6: /* CIL Label */ ;
    {
#line 171
    tmp___25 = calloc((size_t )sizeof(struct xxm_track *), (size_t )(m___0->xxh)->trk);
#line 171
    m___0->xxt = (struct xxm_track **)tmp___25;
#line 171
    tmp___26 = calloc((size_t )sizeof(struct xxm_pattern *), (size_t )((m___0->xxh)->pat + 1));
#line 171
    m___0->xxp = (struct xxm_pattern **)tmp___26;
    }
#line 171
    goto while_break___6;
  }
  while_break___6: /* CIL Label */ ;
  }
  {
#line 173
  reportv(ctx___0, 0, (char *)"Stored patterns: %d ", (m___0->xxh)->pat);
#line 175
  i___3 = 0;
  }
  {
#line 175
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 175
    if (! (i___3 < (m___0->xxh)->pat)) {
#line 175
      goto while_break___7;
    }
    {
#line 176
    while (1) {
      while_continue___8: /* CIL Label */ ;
      {
#line 176
      tmp___27 = calloc((size_t )1, (size_t )(sizeof(struct xxm_pattern ) + sizeof(struct xxm_trackinfo ) * (unsigned long )((m___0->xxh)->chn - 1)));
#line 176
      *(m___0->xxp + i___3) = (struct xxm_pattern *)tmp___27;
      }
#line 176
      goto while_break___8;
    }
    while_break___8: /* CIL Label */ ;
    }
#line 177
    (*(m___0->xxp + i___3))->rows = 64;
    {
#line 178
    while (1) {
      while_continue___9: /* CIL Label */ ;
#line 178
      j___0 = 0;
      {
#line 178
      while (1) {
        while_continue___10: /* CIL Label */ ;
#line 178
        if (! (j___0 < (m___0->xxh)->chn)) {
#line 178
          goto while_break___10;
        }
        {
#line 178
        (*(m___0->xxp + i___3))->info[j___0].index = i___3 * (m___0->xxh)->chn + j___0;
#line 178
        tmp___28 = calloc((size_t )(sizeof(struct xxm_track ) + sizeof(struct xxm_event ) * (unsigned long )(*(m___0->xxp + i___3))->rows),
                          (size_t )1);
#line 178
        *(m___0->xxt + (i___3 * (m___0->xxh)->chn + j___0)) = (struct xxm_track *)tmp___28;
#line 178
        (*(m___0->xxt + (i___3 * (m___0->xxh)->chn + j___0)))->rows = (*(m___0->xxp + i___3))->rows;
#line 178
        j___0 ++;
        }
      }
      while_break___10: /* CIL Label */ ;
      }
#line 178
      goto while_break___9;
    }
    while_break___9: /* CIL Label */ ;
    }
#line 180
    j = 0;
    {
#line 180
    while (1) {
      while_continue___11: /* CIL Label */ ;
#line 180
      if (! (j < 64 * (m___0->xxh)->chn)) {
#line 180
        goto while_break___11;
      }
      {
#line 181
      event = & (*(m___0->xxt + (*(m___0->xxp + i___3))->info[j % (m___0->xxh)->chn].index))->event[j / (m___0->xxh)->chn];
#line 182
      event->note = read8(f);
#line 183
      event->ins = read8(f);
#line 184
      event->fxt = (uint8 )0;
#line 185
      event->fxp = (uint8 )0;
#line 180
      j ++;
      }
    }
    while_break___11: /* CIL Label */ ;
    }
    {
#line 188
    reportv(ctx___0, 0, (char *)".");
#line 175
    i___3 ++;
    }
  }
  while_break___7: /* CIL Label */ ;
  }
  {
#line 190
  reportv(ctx___0, 0, (char *)"\n");
  }
#line 209
  return (0);
}
}
#line 25 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/gdm_load.c"
static char *fmt[10]  = 
#line 25 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/gdm_load.c"
  {      (char *)"?",      (char *)"MOD",      (char *)"MTM",      (char *)"S3M", 
        (char *)"669",      (char *)"FAR",      (char *)"ULT",      (char *)"STM", 
        (char *)"MED",      (char *)"unknown"};
#line 38
static int gdm_test(FILE *f , char *t , int const   start ) ;
#line 39
static int gdm_load(struct xmp_context *ctx___0 , FILE *f , int const   start ) ;
#line 41 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/gdm_load.c"
struct xmp_loader_info gdm_loader  =    {(char *)"GDM", (char *)"Generic Digital Music", & gdm_test, & gdm_load, 0, {(struct list_head *)0,
                                                                                (struct list_head *)0}};
#line 48 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/gdm_load.c"
static int gdm_test(FILE *f , char *t , int const   start ) 
{ 
  uint32 tmp ;
  uint32 tmp___0 ;

  {
  {
#line 50
  tmp = read32b(f);
  }
#line 50
  if (tmp != ((((71U << 24) | (68U << 16)) | (77U << 8)) | 254U)) {
#line 51
    return (-1);
  }
  {
#line 53
  fseek(f, (long )(start + 71), 0);
#line 54
  tmp___0 = read32b(f);
  }
#line 54
  if (tmp___0 != ((((71U << 24) | (77U << 16)) | (70U << 8)) | 83U)) {
#line 55
    return (-1);
  }
  {
#line 57
  fseek(f, (long )(start + 4), 0);
#line 58
  read_title(f, t, 32);
  }
#line 60
  return (0);
}
}
#line 65 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/gdm_load.c"
void fix_effect(uint8 *fxt , uint8 *fxp ) 
{ 
  uint8 tmp ;
  uint8 tmp___0 ;
  uint8 tmp___1 ;

  {
  {
#line 68
  if ((int )*fxt == 0) {
#line 68
    goto case_0;
  }
#line 77
  if ((int )*fxt == 7) {
#line 77
    goto case_7;
  }
#line 77
  if ((int )*fxt == 6) {
#line 77
    goto case_7;
  }
#line 77
  if ((int )*fxt == 5) {
#line 77
    goto case_7;
  }
#line 77
  if ((int )*fxt == 4) {
#line 77
    goto case_7;
  }
#line 77
  if ((int )*fxt == 3) {
#line 77
    goto case_7;
  }
#line 77
  if ((int )*fxt == 2) {
#line 77
    goto case_7;
  }
#line 77
  if ((int )*fxt == 1) {
#line 77
    goto case_7;
  }
#line 79
  if ((int )*fxt == 8) {
#line 79
    goto case_8;
  }
#line 88
  if ((int )*fxt == 15) {
#line 88
    goto case_15;
  }
#line 88
  if ((int )*fxt == 14) {
#line 88
    goto case_15;
  }
#line 88
  if ((int )*fxt == 13) {
#line 88
    goto case_15;
  }
#line 88
  if ((int )*fxt == 12) {
#line 88
    goto case_15;
  }
#line 88
  if ((int )*fxt == 11) {
#line 88
    goto case_15;
  }
#line 88
  if ((int )*fxt == 10) {
#line 88
    goto case_15;
  }
#line 88
  if ((int )*fxt == 9) {
#line 88
    goto case_15;
  }
#line 90
  if ((int )*fxt == 16) {
#line 90
    goto case_16;
  }
#line 93
  if ((int )*fxt == 17) {
#line 93
    goto case_17;
  }
#line 96
  if ((int )*fxt == 18) {
#line 96
    goto case_18;
  }
#line 99
  if ((int )*fxt == 19) {
#line 99
    goto case_19;
  }
#line 102
  if ((int )*fxt == 20) {
#line 102
    goto case_20;
  }
#line 105
  if ((int )*fxt == 30) {
#line 105
    goto case_30;
  }
#line 108
  if ((int )*fxt == 31) {
#line 108
    goto case_31;
  }
#line 111
  goto switch_default;
  case_0: /* CIL Label */ 
#line 69
  *fxp = (uint8 )0;
#line 70
  goto switch_break;
  case_7: /* CIL Label */ 
  case_6: /* CIL Label */ 
  case_5: /* CIL Label */ 
  case_4: /* CIL Label */ 
  case_3: /* CIL Label */ 
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
#line 78
  goto switch_break;
  case_8: /* CIL Label */ 
#line 80
  *fxt = (uint8 )29;
#line 81
  goto switch_break;
  case_15: /* CIL Label */ 
  case_14: /* CIL Label */ 
  case_13: /* CIL Label */ 
  case_12: /* CIL Label */ 
  case_11: /* CIL Label */ 
  case_10: /* CIL Label */ 
  case_9: /* CIL Label */ 
#line 89
  goto switch_break;
  case_16: /* CIL Label */ 
#line 91
  *fxt = (uint8 )0;
#line 92
  goto switch_break;
  case_17: /* CIL Label */ 
#line 94
  tmp = (uint8 )0;
#line 94
  *fxp = tmp;
#line 94
  *fxt = tmp;
#line 95
  goto switch_break;
  case_18: /* CIL Label */ 
#line 97
  *fxt = (uint8 )27;
#line 98
  goto switch_break;
  case_19: /* CIL Label */ 
#line 100
  *fxt = (uint8 )16;
#line 101
  goto switch_break;
  case_20: /* CIL Label */ 
#line 103
  *fxt = (uint8 )172;
#line 104
  goto switch_break;
  case_30: /* CIL Label */ 
#line 106
  tmp___0 = (uint8 )0;
#line 106
  *fxp = tmp___0;
#line 106
  *fxt = tmp___0;
#line 107
  goto switch_break;
  case_31: /* CIL Label */ 
#line 109
  *fxt = (uint8 )171;
#line 110
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 112
  tmp___1 = (uint8 )0;
#line 112
  *fxp = tmp___1;
#line 112
  *fxt = tmp___1;
  switch_break: /* CIL Label */ ;
  }
#line 114
  return;
}
}
#line 117 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/gdm_load.c"
static int gdm_load(struct xmp_context *ctx___0 , FILE *f , int const   start ) 
{ 
  struct xmp_player_context *p ;
  struct xmp_mod_context *m___0 ;
  struct xxm_event *event ;
  int vermaj ;
  int vermin ;
  int tvmaj ;
  int tvmin ;
  int tracker ;
  int origfmt ;
  int ord_ofs ;
  int pat_ofs ;
  int ins_ofs ;
  int smp_ofs ;
  uint8 buffer[32] ;
  uint8 panmap[32] ;
  int i___3 ;
  uint8 **tmp ;
  uint8 tmp___0 ;
  uint8 tmp___1 ;
  uint16 tmp___2 ;
  uint8 tmp___3 ;
  uint8 tmp___4 ;
  uint8 tmp___5 ;
  uint8 tmp___6 ;
  uint8 tmp___7 ;
  uint16 tmp___8 ;
  uint32 tmp___9 ;
  uint8 tmp___10 ;
  uint32 tmp___11 ;
  uint8 tmp___12 ;
  uint32 tmp___13 ;
  uint32 tmp___14 ;
  int tmp___15 ;
  uint8 tmp___16 ;
  void *tmp___17 ;
  void *tmp___18 ;
  void *tmp___19 ;
  void *tmp___20 ;
  void *tmp___21 ;
  void *tmp___22 ;
  void *tmp___23 ;
  int flg ;
  int c4spd ;
  int vol ;
  int pan ;
  void *tmp___24 ;
  uint32 tmp___25 ;
  uint32 tmp___26 ;
  uint32 tmp___27 ;
  uint8 tmp___28 ;
  uint16 tmp___29 ;
  uint8 tmp___30 ;
  uint8 tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;
  size_t tmp___34 ;
  void *tmp___35 ;
  void *tmp___36 ;
  int len ;
  int c___0 ;
  int r ;
  int k ;
  void *tmp___37 ;
  int j ;
  void *tmp___38 ;
  uint16 tmp___39 ;
  uint8 tmp___40 ;
  uint8 tmp___41 ;
  uint8 tmp___42 ;
  void *__cil_tmp73 ;
  void *__cil_tmp74 ;
  char *__cil_tmp75 ;
  char *__cil_tmp76 ;
  char *__cil_tmp77 ;
  char *__cil_tmp78 ;
  char *__cil_tmp79 ;
  char *__cil_tmp80 ;
  char *__cil_tmp81 ;
  char *__cil_tmp82 ;
  char *__cil_tmp83 ;
  char *__cil_tmp84 ;
  char *__cil_tmp85 ;
  char *__cil_tmp86 ;
  char *__cil_tmp87 ;
  char *__cil_tmp88 ;
  char *__cil_tmp89 ;
  char *__cil_tmp90 ;
  char *__cil_tmp91 ;
  char *__cil_tmp92 ;

  {
#line 119
  p = & ctx___0->p;
#line 120
  m___0 = & p->m;
  {
#line 127
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 127
    fseek(f, (long )start, 0);
#line 127
    tmp = (uint8 **)((void *)0);
#line 127
    m___0->med_wav_table = tmp;
#line 127
    m___0->med_vol_table = tmp;
#line 127
    set_xxh_defaults(m___0->xxh);
    }
#line 127
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 129
  read32b(f);
#line 130
  fread((void */* __restrict  */)(m___0->name), (size_t )1, (size_t )32, (FILE */* __restrict  */)f);
#line 131
  fread((void */* __restrict  */)(m___0->author), (size_t )1, (size_t )32, (FILE */* __restrict  */)f);
#line 133
  fseek(f, 7L, 1);
#line 135
  tmp___0 = read8(f);
#line 135
  vermaj = (int )tmp___0;
#line 136
  tmp___1 = read8(f);
#line 136
  vermin = (int )tmp___1;
#line 137
  tmp___2 = read16l(f);
#line 137
  tracker = (int )tmp___2;
#line 138
  tmp___3 = read8(f);
#line 138
  tvmaj = (int )tmp___3;
#line 139
  tmp___4 = read8(f);
#line 139
  tvmin = (int )tmp___4;
  }
#line 141
  if (tracker == 0) {
    {
#line 142
    sprintf((char */* __restrict  */)(m___0->type), (char const   */* __restrict  */)"GDM %d.%02d, (2GDM %d.%02d)",
            vermaj, vermin, tvmaj, tvmin);
    }
  } else {
    {
#line 145
    sprintf((char */* __restrict  */)(m___0->type), (char const   */* __restrict  */)"GDM %d.%02d (unknown tracker %d.%02d)",
            vermaj, vermin, tvmaj, tvmin);
    }
  }
  {
#line 149
  fread((void */* __restrict  */)(panmap), (size_t )32, (size_t )1, (FILE */* __restrict  */)f);
#line 150
  i___3 = 0;
  }
  {
#line 150
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 150
    if (! (i___3 < 32)) {
#line 150
      goto while_break___0;
    }
#line 151
    if ((int )panmap[i___3] != 255) {
#line 152
      (m___0->xxh)->chn = i___3 + 1;
    }
#line 153
    if ((int )panmap[i___3] == 16) {
#line 154
      panmap[i___3] = (uint8 )8;
    }
#line 155
    m___0->xxc[i___3].pan = 128 + ((int )panmap[i___3] - 8) * 16;
#line 150
    i___3 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 158
  tmp___5 = read8(f);
#line 158
  (m___0->xxh)->gvl = (int )tmp___5;
#line 159
  tmp___6 = read8(f);
#line 159
  (m___0->xxh)->tpo = (int )tmp___6;
#line 160
  tmp___7 = read8(f);
#line 160
  (m___0->xxh)->bpm = (int )tmp___7;
#line 161
  tmp___8 = read16l(f);
#line 161
  origfmt = (int )tmp___8;
#line 162
  tmp___9 = read32l(f);
#line 162
  ord_ofs = (int )tmp___9;
#line 163
  tmp___10 = read8(f);
#line 163
  (m___0->xxh)->len = (int )tmp___10 + 1;
#line 164
  tmp___11 = read32l(f);
#line 164
  pat_ofs = (int )tmp___11;
#line 165
  tmp___12 = read8(f);
#line 165
  (m___0->xxh)->pat = (int )tmp___12 + 1;
#line 166
  tmp___13 = read32l(f);
#line 166
  ins_ofs = (int )tmp___13;
#line 167
  tmp___14 = read32l(f);
#line 167
  smp_ofs = (int )tmp___14;
#line 168
  tmp___16 = read8(f);
#line 168
  tmp___15 = (int )tmp___16 + 1;
#line 168
  (m___0->xxh)->smp = tmp___15;
#line 168
  (m___0->xxh)->ins = tmp___15;
#line 169
  (m___0->xxh)->trk = (m___0->xxh)->pat * (m___0->xxh)->chn;
  }
  {
#line 171
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 171
    if (m___0->verbosity) {
#line 171
      if (m___0->name[0]) {
        {
#line 171
        report((char *)"Module title   : %s\n", m___0->name);
        }
      }
#line 171
      if (m___0->type[0]) {
        {
#line 171
        report((char *)"Module type    : %s\n", m___0->type);
        }
      }
#line 171
      if (m___0->author[0]) {
        {
#line 171
        report((char *)"Author name    : %s\n", m___0->author);
        }
      }
#line 171
      if ((m___0->xxh)->len) {
        {
#line 171
        report((char *)"Module length  : %d patterns\n", (m___0->xxh)->len);
        }
      }
    }
#line 171
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 173
  if (origfmt > 9) {
#line 174
    origfmt = 9;
  }
  {
#line 175
  reportv(ctx___0, 0, (char *)"Orig format    : %s\n", fmt[origfmt]);
#line 177
  fseek(f, (long )(start + (int const   )ord_ofs), 0);
#line 179
  i___3 = 0;
  }
  {
#line 179
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 179
    if (! (i___3 < (m___0->xxh)->len)) {
#line 179
      goto while_break___2;
    }
    {
#line 180
    m___0->xxo[i___3] = read8(f);
#line 179
    i___3 ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 184
  fseek(f, (long )(start + (int const   )ins_ofs), 0);
  }
  {
#line 186
  while (1) {
    while_continue___3: /* CIL Label */ ;
    {
#line 186
    tmp___17 = calloc((size_t )sizeof(struct xxm_instrument_header ), (size_t )(m___0->xxh)->ins);
#line 186
    m___0->xxih = (struct xxm_instrument_header *)tmp___17;
#line 186
    tmp___18 = calloc((size_t )sizeof(struct xxm_instrument_map ), (size_t )(m___0->xxh)->ins);
#line 186
    m___0->xxim = (struct xxm_instrument_map *)tmp___18;
#line 186
    tmp___19 = calloc((size_t )sizeof(struct xxm_instrument *), (size_t )(m___0->xxh)->ins);
#line 186
    m___0->xxi = (struct xxm_instrument **)tmp___19;
    }
#line 186
    if ((m___0->xxh)->smp) {
      {
#line 186
      tmp___20 = calloc((size_t )sizeof(struct xxm_sample ), (size_t )(m___0->xxh)->smp);
#line 186
      m___0->xxs = (struct xxm_sample *)tmp___20;
      }
    }
    {
#line 186
    tmp___21 = calloc((size_t )sizeof(uint16 *), (size_t )(m___0->xxh)->ins);
#line 186
    m___0->xxae = (uint16 **)tmp___21;
#line 186
    tmp___22 = calloc((size_t )sizeof(uint16 *), (size_t )(m___0->xxh)->ins);
#line 186
    m___0->xxpe = (uint16 **)tmp___22;
#line 186
    tmp___23 = calloc((size_t )sizeof(uint16 *), (size_t )(m___0->xxh)->ins);
#line 186
    m___0->xxfe = (uint16 **)tmp___23;
    }
#line 186
    goto while_break___3;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 188
  reportv(ctx___0, 1, (char *)"     Name                             Len   LBeg  LEnd  L Vol Pan C4Spd\n");
#line 190
  i___3 = 0;
  }
  {
#line 190
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 190
    if (! (i___3 < (m___0->xxh)->ins)) {
#line 190
      goto while_break___4;
    }
    {
#line 193
    tmp___24 = calloc((size_t )sizeof(struct xxm_instrument ), (size_t )1);
#line 193
    *(m___0->xxi + i___3) = (struct xxm_instrument *)tmp___24;
#line 194
    fread((void */* __restrict  */)(buffer), (size_t )32, (size_t )1, (FILE */* __restrict  */)f);
#line 195
    copy_adjust((m___0->xxih + i___3)->name, buffer, 32);
#line 196
    fseek(f, 12L, 1);
#line 197
    read8(f);
#line 198
    tmp___25 = read32l(f);
#line 198
    (m___0->xxs + i___3)->len = (int )tmp___25;
#line 199
    tmp___26 = read32l(f);
#line 199
    (m___0->xxs + i___3)->lps = (int )tmp___26;
#line 200
    tmp___27 = read32l(f);
#line 200
    (m___0->xxs + i___3)->lpe = (int )tmp___27;
#line 201
    tmp___28 = read8(f);
#line 201
    flg = (int )tmp___28;
#line 202
    tmp___29 = read16l(f);
#line 202
    c4spd = (int )tmp___29;
#line 203
    tmp___30 = read8(f);
#line 203
    vol = (int )tmp___30;
#line 204
    tmp___31 = read8(f);
#line 204
    pan = (int )tmp___31;
    }
#line 206
    if (vol > 64) {
#line 206
      (*(m___0->xxi + i___3) + 0)->vol = 64;
    } else {
#line 206
      (*(m___0->xxi + i___3) + 0)->vol = vol;
    }
#line 207
    if (pan > 15) {
#line 207
      (*(m___0->xxi + i___3) + 0)->pan = 128;
    } else {
#line 207
      (*(m___0->xxi + i___3) + 0)->pan = 128 + (pan - 8) * 16;
    }
    {
#line 208
    c2spd_to_note(c4spd, & (*(m___0->xxi + i___3) + 0)->xpo, & (*(m___0->xxi + i___3) + 0)->fin);
#line 210
    (m___0->xxih + i___3)->nsm = ! (! (m___0->xxs + i___3)->len);
#line 211
    (*(m___0->xxi + i___3) + 0)->sid = i___3;
#line 212
    (m___0->xxs + i___3)->flg = 0;
    }
#line 214
    if (flg & 1) {
#line 215
      (m___0->xxs + i___3)->flg |= 4;
    }
#line 216
    if (flg & 2) {
#line 217
      (m___0->xxs + i___3)->flg |= 1;
    }
#line 219
    if (m___0->verbosity > 1) {
      {
#line 219
      tmp___34 = strlen((char const   *)((char *)((m___0->xxih + i___3)->name)));
      }
#line 219
      if (tmp___34) {
#line 219
        goto _L;
      } else
#line 219
      if ((m___0->xxs + i___3)->len > 1) {
        _L: /* CIL Label */ 
#line 220
        if ((m___0->xxs + i___3)->flg & 4) {
#line 220
          tmp___32 = 'L';
        } else {
#line 220
          tmp___32 = ' ';
        }
#line 220
        if ((m___0->xxs + i___3)->flg & 1) {
#line 220
          tmp___33 = '+';
        } else {
#line 220
          tmp___33 = ' ';
        }
        {
#line 220
        report((char *)"[%2X] %-32.32s %05x%c%05x %05x %c V%02x P%02x %5d\n", i___3,
               (m___0->xxih + i___3)->name, (m___0->xxs + i___3)->len, tmp___33, (m___0->xxs + i___3)->lps,
               (m___0->xxs + i___3)->lpe, tmp___32, (*(m___0->xxi + i___3) + 0)->vol,
               (*(m___0->xxi + i___3) + 0)->pan, c4spd);
        }
      }
    }
#line 190
    i___3 ++;
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 235
  fseek(f, (long )(start + (int const   )pat_ofs), 0);
  }
  {
#line 237
  while (1) {
    while_continue___5: /* CIL Label */ ;
    {
#line 237
    tmp___35 = calloc((size_t )sizeof(struct xxm_track *), (size_t )(m___0->xxh)->trk);
#line 237
    m___0->xxt = (struct xxm_track **)tmp___35;
#line 237
    tmp___36 = calloc((size_t )sizeof(struct xxm_pattern *), (size_t )((m___0->xxh)->pat + 1));
#line 237
    m___0->xxp = (struct xxm_pattern **)tmp___36;
    }
#line 237
    goto while_break___5;
  }
  while_break___5: /* CIL Label */ ;
  }
  {
#line 239
  reportv(ctx___0, 0, (char *)"Stored patterns: %d ", (m___0->xxh)->pat);
#line 241
  i___3 = 0;
  }
  {
#line 241
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 241
    if (! (i___3 < (m___0->xxh)->pat)) {
#line 241
      goto while_break___6;
    }
    {
#line 244
    while (1) {
      while_continue___7: /* CIL Label */ ;
      {
#line 244
      tmp___37 = calloc((size_t )1, (size_t )(sizeof(struct xxm_pattern ) + sizeof(struct xxm_trackinfo ) * (unsigned long )((m___0->xxh)->chn - 1)));
#line 244
      *(m___0->xxp + i___3) = (struct xxm_pattern *)tmp___37;
      }
#line 244
      goto while_break___7;
    }
    while_break___7: /* CIL Label */ ;
    }
#line 245
    (*(m___0->xxp + i___3))->rows = 64;
    {
#line 246
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 246
      j = 0;
      {
#line 246
      while (1) {
        while_continue___9: /* CIL Label */ ;
#line 246
        if (! (j < (m___0->xxh)->chn)) {
#line 246
          goto while_break___9;
        }
        {
#line 246
        (*(m___0->xxp + i___3))->info[j].index = i___3 * (m___0->xxh)->chn + j;
#line 246
        tmp___38 = calloc((size_t )(sizeof(struct xxm_track ) + sizeof(struct xxm_event ) * (unsigned long )(*(m___0->xxp + i___3))->rows),
                          (size_t )1);
#line 246
        *(m___0->xxt + (i___3 * (m___0->xxh)->chn + j)) = (struct xxm_track *)tmp___38;
#line 246
        (*(m___0->xxt + (i___3 * (m___0->xxh)->chn + j)))->rows = (*(m___0->xxp + i___3))->rows;
#line 246
        j ++;
        }
      }
      while_break___9: /* CIL Label */ ;
      }
#line 246
      goto while_break___8;
    }
    while_break___8: /* CIL Label */ ;
    }
    {
#line 248
    tmp___39 = read16l(f);
#line 248
    len = (int )tmp___39;
#line 249
    len -= 2;
#line 251
    r = 0;
    }
    {
#line 251
    while (1) {
      while_continue___10: /* CIL Label */ ;
#line 251
      if (! (len > 0)) {
#line 251
        goto while_break___10;
      }
      {
#line 252
      tmp___40 = read8(f);
#line 252
      c___0 = (int )tmp___40;
#line 253
      len --;
      }
#line 255
      if (c___0 == 0) {
#line 256
        r ++;
#line 257
        goto __Cont;
      }
#line 260
      if (! ((c___0 & 31) < (m___0->xxh)->chn)) {
        {
#line 260
        __assert_fail("(c & 0x1f) < m->xxh->chn", "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/gdm_load.c",
                      260U, "gdm_load");
        }
      }
#line 261
      event = & (*(m___0->xxt + (*(m___0->xxp + i___3))->info[c___0 & 31].index))->event[r];
#line 263
      if (c___0 & 32) {
        {
#line 264
        tmp___41 = read8(f);
#line 264
        k = (int )tmp___41;
#line 265
        event->note = (uint8 )(12 * (((k & 127) & 240) >> 4) + (k & 15));
#line 266
        event->ins = read8(f);
#line 267
        len -= 2;
        }
      }
#line 270
      if (c___0 & 64) {
        {
#line 271
        while (1) {
          while_continue___11: /* CIL Label */ ;
          {
#line 272
          tmp___42 = read8(f);
#line 272
          k = (int )tmp___42;
#line 273
          len --;
          }
          {
#line 275
          if ((k & 192) >> 6 == 0) {
#line 275
            goto case_0;
          }
#line 281
          if ((k & 192) >> 6 == 1) {
#line 281
            goto case_1;
          }
#line 287
          if ((k & 192) >> 6 == 2) {
#line 287
            goto case_2;
          }
#line 274
          goto switch_break;
          case_0: /* CIL Label */ 
          {
#line 276
          event->fxt = (uint8 )(k & 31);
#line 277
          event->fxp = read8(f);
#line 278
          len --;
#line 279
          fix_effect(& event->fxt, & event->fxp);
          }
#line 280
          goto switch_break;
          case_1: /* CIL Label */ 
          {
#line 282
          event->f2t = (uint8 )(k & 31);
#line 283
          event->f2p = read8(f);
#line 284
          len --;
#line 285
          fix_effect(& event->f2t, & event->f2p);
          }
#line 286
          goto switch_break;
          case_2: /* CIL Label */ 
          {
#line 288
          read8(f);
#line 289
          len --;
          }
          switch_break: /* CIL Label */ ;
          }
#line 271
          if (! (k & 32)) {
#line 271
            goto while_break___11;
          }
        }
        while_break___11: /* CIL Label */ ;
        }
      }
      __Cont: /* CIL Label */ ;
    }
    while_break___10: /* CIL Label */ ;
    }
    {
#line 295
    reportv(ctx___0, 0, (char *)".");
#line 241
    i___3 ++;
    }
  }
  while_break___6: /* CIL Label */ ;
  }
  {
#line 297
  reportv(ctx___0, 0, (char *)"\n");
#line 301
  fseek(f, (long )(start + (int const   )smp_ofs), 0);
#line 303
  reportv(ctx___0, 0, (char *)"Stored samples : %d ", (m___0->xxh)->smp);
#line 304
  i___3 = 0;
  }
  {
#line 304
  while (1) {
    while_continue___12: /* CIL Label */ ;
#line 304
    if (! (i___3 < (m___0->xxh)->ins)) {
#line 304
      goto while_break___12;
    }
    {
#line 305
    xmp_drv_loadpatch(ctx___0, f, (*(m___0->xxi + i___3) + 0)->sid, m___0->c4rate,
                      2, m___0->xxs + (*(m___0->xxi + i___3) + 0)->sid, (char *)((void *)0));
#line 307
    reportv(ctx___0, 0, (char *)".");
#line 304
    i___3 ++;
    }
  }
  while_break___12: /* CIL Label */ ;
  }
  {
#line 309
  reportv(ctx___0, 0, (char *)"\n");
  }
#line 311
  return (0);
}
}
#line 25 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/umx_load.c"
static int umx_test(FILE *f , char *t , int const   start ) ;
#line 26
static int umx_load(struct xmp_context *ctx___0 , FILE *f , int const   start ) ;
#line 28 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/umx_load.c"
struct xmp_loader_info umx_loader  =    {(char *)"UMX", (char *)"Epic Games Unreal/UT", & umx_test, & umx_load, 0, {(struct list_head *)0,
                                                                               (struct list_head *)0}};
#line 35 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/umx_load.c"
static int umx_test(FILE *f , char *t , int const   start ) 
{ 
  int i___3 ;
  int offset ;
  uint8 buf___1[1500] ;
  uint8 *b___1 ;
  uint32 id ;
  int tmp ;
  void *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
  {
#line 37
  offset = -1;
#line 38
  b___1 = buf___1;
#line 41
  fread((void */* __restrict  */)(buf___1), (size_t )1, (size_t )1500, (FILE */* __restrict  */)f);
#line 42
  id = readmem32b(b___1);
  }
#line 44
  if (id != ((((193U << 24) | (131U << 16)) | (42U << 8)) | 158U)) {
#line 45
    return (-1);
  }
#line 47
  i___3 = 0;
  {
#line 47
  while (1) {
    while_continue: /* CIL Label */ ;
#line 47
    if (! (i___3 < 1500)) {
#line 47
      goto while_break;
    }
    {
#line 48
    id = readmem32b(b___1);
#line 50
    tmp = memcmp((void const   *)b___1, (void const   *)"Extended Module:", (size_t )16);
    }
#line 50
    if (! tmp) {
#line 51
      offset = i___3;
#line 52
      goto while_break;
    }
#line 54
    if (id == ((((73U << 24) | (77U << 16)) | (80U << 8)) | 77U)) {
#line 55
      offset = i___3;
#line 56
      goto while_break;
    }
#line 58
    if (i___3 > 44) {
#line 58
      if (id == ((((83U << 24) | (67U << 16)) | (82U << 8)) | 77U)) {
#line 59
        offset = i___3 - 44;
#line 60
        goto while_break;
      }
    }
#line 62
    if (i___3 > 1080) {
#line 62
      if (id == ((((77U << 24) | (46U << 16)) | (75U << 8)) | 46U)) {
#line 63
        offset = i___3 - 1080;
#line 64
        goto while_break;
      }
    }
#line 47
    i___3 ++;
#line 47
    b___1 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 68
  if (offset < 0) {
#line 69
    return (-1);
  }
#line 71
  return (0);
}
}
#line 75 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/umx_load.c"
static int load(struct xmp_context *ctx___0 , FILE *f , char *fmt___0 , int offset ) 
{ 
  struct xmp_loader_info *li ;
  struct list_head *head ;
  int tmp ;
  int tmp___0 ;

  {
#line 80
  head = loader_list.next;
  {
#line 80
  while (1) {
    while_continue: /* CIL Label */ ;
#line 80
    if (! ((unsigned long )head != (unsigned long )(& loader_list))) {
#line 80
      goto while_break;
    }
    {
#line 81
    li = (struct xmp_loader_info *)((char *)head - (unsigned long )(& ((struct xmp_loader_info *)0)->list));
#line 82
    tmp___0 = strcmp((char const   *)li->id, (char const   *)fmt___0);
    }
#line 82
    if (tmp___0 == 0) {
      {
#line 83
      tmp = (*(li->loader))(ctx___0, f, (int const   )offset);
      }
#line 83
      if (tmp == 0) {
#line 84
        return (0);
      }
    }
#line 80
    head = head->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 88
  return (-1);
}
}
#line 92 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/umx_load.c"
static int umx_load(struct xmp_context *ctx___0 , FILE *f , int const   start ) 
{ 
  struct xmp_player_context *p ;
  struct xmp_mod_context *m___0 ;
  int i___3 ;
  uint8 buf___1[1500] ;
  uint8 *b___1 ;
  uint32 id ;
  uint8 **tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  void *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;

  {
#line 94
  p = & ctx___0->p;
#line 95
  m___0 = & p->m;
#line 97
  b___1 = buf___1;
  {
#line 100
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 100
    fseek(f, (long )start, 0);
#line 100
    tmp = (uint8 **)((void *)0);
#line 100
    m___0->med_wav_table = tmp;
#line 100
    m___0->med_vol_table = tmp;
#line 100
    set_xxh_defaults(m___0->xxh);
    }
#line 100
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 102
  reportv(ctx___0, 0, (char *)"Container type : Epic Games UMX\n");
#line 104
  fread((void */* __restrict  */)(buf___1), (size_t )1, (size_t )1500, (FILE */* __restrict  */)f);
#line 106
  i___3 = 0;
  }
  {
#line 106
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 106
    if (! (i___3 < 1500)) {
#line 106
      goto while_break___0;
    }
    {
#line 107
    id = readmem32b(b___1);
#line 109
    tmp___1 = memcmp((void const   *)b___1, (void const   *)"Extended Module:", (size_t )16);
    }
#line 109
    if (! tmp___1) {
      {
#line 110
      tmp___0 = load(ctx___0, f, (char *)"XM", i___3);
      }
#line 110
      return (tmp___0);
    }
#line 111
    if (id == ((((73U << 24) | (77U << 16)) | (80U << 8)) | 77U)) {
      {
#line 112
      tmp___2 = load(ctx___0, f, (char *)"IT", i___3);
      }
#line 112
      return (tmp___2);
    }
#line 113
    if (i___3 > 44) {
#line 113
      if (id == ((((83U << 24) | (67U << 16)) | (82U << 8)) | 77U)) {
        {
#line 114
        tmp___3 = load(ctx___0, f, (char *)"S3M", i___3 - 44);
        }
#line 114
        return (tmp___3);
      }
    }
#line 115
    if (i___3 > 1080) {
#line 115
      if (id == ((((77U << 24) | (46U << 16)) | (75U << 8)) | 46U)) {
        {
#line 116
        tmp___4 = load(ctx___0, f, (char *)"MOD", i___3 - 1080);
        }
#line 116
        return (tmp___4);
      }
    }
#line 106
    i___3 ++;
#line 106
    b___1 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 119
  return (-1);
}
}
#line 24 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/dbm_load.c"
static int dbm_test(FILE *f , char *t , int const   start ) ;
#line 25
static int dbm_load(struct xmp_context *ctx___0 , FILE *f , int const   start ) ;
#line 27 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/dbm_load.c"
struct xmp_loader_info dbm_loader  =    {(char *)"DBM", (char *)"DigiBooster Pro", & dbm_test, & dbm_load, 0, {(struct list_head *)0,
                                                                          (struct list_head *)0}};
#line 34 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/dbm_load.c"
static int dbm_test(FILE *f , char *t , int const   start ) 
{ 
  uint32 tmp ;

  {
  {
#line 36
  tmp = read32b(f);
  }
#line 36
  if (tmp != ((((68U << 24) | (66U << 16)) | (77U << 8)) | 48U)) {
#line 37
    return (-1);
  }
  {
#line 39
  fseek(f, 12L, 1);
#line 40
  read_title(f, t, 44);
  }
#line 42
  return (0);
}
}
#line 47 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/dbm_load.c"
static int have_song  ;
#line 50 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/dbm_load.c"
static void get_info(struct xmp_context *ctx___0 , int size___0 , FILE *f ) 
{ 
  struct xmp_player_context *p ;
  struct xmp_mod_context *m___0 ;
  uint16 tmp ;
  uint16 tmp___0 ;
  uint16 tmp___1 ;
  uint16 tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  void *tmp___9 ;

  {
  {
#line 52
  p = & ctx___0->p;
#line 53
  m___0 = & p->m;
#line 55
  tmp = read16b(f);
#line 55
  (m___0->xxh)->ins = (int )tmp;
#line 56
  tmp___0 = read16b(f);
#line 56
  (m___0->xxh)->smp = (int )tmp___0;
#line 57
  read16b(f);
#line 58
  tmp___1 = read16b(f);
#line 58
  (m___0->xxh)->pat = (int )tmp___1;
#line 59
  tmp___2 = read16b(f);
#line 59
  (m___0->xxh)->chn = (int )tmp___2;
#line 61
  (m___0->xxh)->trk = (m___0->xxh)->pat * (m___0->xxh)->chn;
  }
  {
#line 63
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 63
    tmp___3 = calloc((size_t )sizeof(struct xxm_instrument_header ), (size_t )(m___0->xxh)->ins);
#line 63
    m___0->xxih = (struct xxm_instrument_header *)tmp___3;
#line 63
    tmp___4 = calloc((size_t )sizeof(struct xxm_instrument_map ), (size_t )(m___0->xxh)->ins);
#line 63
    m___0->xxim = (struct xxm_instrument_map *)tmp___4;
#line 63
    tmp___5 = calloc((size_t )sizeof(struct xxm_instrument *), (size_t )(m___0->xxh)->ins);
#line 63
    m___0->xxi = (struct xxm_instrument **)tmp___5;
    }
#line 63
    if ((m___0->xxh)->smp) {
      {
#line 63
      tmp___6 = calloc((size_t )sizeof(struct xxm_sample ), (size_t )(m___0->xxh)->smp);
#line 63
      m___0->xxs = (struct xxm_sample *)tmp___6;
      }
    }
    {
#line 63
    tmp___7 = calloc((size_t )sizeof(uint16 *), (size_t )(m___0->xxh)->ins);
#line 63
    m___0->xxae = (uint16 **)tmp___7;
#line 63
    tmp___8 = calloc((size_t )sizeof(uint16 *), (size_t )(m___0->xxh)->ins);
#line 63
    m___0->xxpe = (uint16 **)tmp___8;
#line 63
    tmp___9 = calloc((size_t )sizeof(uint16 *), (size_t )(m___0->xxh)->ins);
#line 63
    m___0->xxfe = (uint16 **)tmp___9;
    }
#line 63
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 64
  return;
}
}
#line 66 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/dbm_load.c"
static void get_song(struct xmp_context *ctx___0 , int size___0 , FILE *f ) 
{ 
  struct xmp_player_context *p ;
  struct xmp_mod_context *m___0 ;
  int i___3 ;
  char buffer[50] ;
  uint16 tmp ;
  uint16 tmp___0 ;
  void *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
#line 68
  p = & ctx___0->p;
#line 69
  m___0 = & p->m;
#line 73
  if (have_song) {
#line 74
    return;
  }
  {
#line 76
  have_song = 1;
#line 78
  fread((void */* __restrict  */)(buffer), (size_t )44, (size_t )1, (FILE */* __restrict  */)f);
  }
#line 79
  if (m___0->verbosity > 0) {
#line 79
    if (buffer[0]) {
      {
#line 80
      report((char *)"Song name      : %s\n", buffer);
      }
    }
  }
  {
#line 82
  tmp = read16b(f);
#line 82
  (m___0->xxh)->len = (int )tmp;
#line 83
  reportv(ctx___0, 0, (char *)"Song length    : %d patterns\n", (m___0->xxh)->len);
#line 84
  i___3 = 0;
  }
  {
#line 84
  while (1) {
    while_continue: /* CIL Label */ ;
#line 84
    if (! (i___3 < (m___0->xxh)->len)) {
#line 84
      goto while_break;
    }
    {
#line 85
    tmp___0 = read16b(f);
#line 85
    m___0->xxo[i___3] = (uint8 )tmp___0;
#line 84
    i___3 ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 86
  return;
}
}
#line 88 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/dbm_load.c"
static void get_inst___1(struct xmp_context *ctx___0 , int size___0 , FILE *f ) 
{ 
  struct xmp_player_context *p ;
  struct xmp_mod_context *m___0 ;
  int i___3 ;
  int c2spd___0 ;
  int flags ;
  int snum___0 ;
  uint8 buffer[50] ;
  void *tmp ;
  uint16 tmp___0 ;
  uint16 tmp___1 ;
  uint32 tmp___2 ;
  uint32 tmp___3 ;
  uint32 tmp___4 ;
  uint16 tmp___5 ;
  uint16 tmp___6 ;
  int tmp___7 ;
  void *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;

  {
  {
#line 90
  p = & ctx___0->p;
#line 91
  m___0 = & p->m;
#line 96
  reportv(ctx___0, 0, (char *)"Instruments    : %d ", (m___0->xxh)->ins);
#line 98
  reportv(ctx___0, 1, (char *)"\n     Instrument name                Smp Vol Pan C2Spd");
#line 100
  i___3 = 0;
  }
  {
#line 100
  while (1) {
    while_continue: /* CIL Label */ ;
#line 100
    if (! (i___3 < (m___0->xxh)->ins)) {
#line 100
      goto while_break;
    }
    {
#line 101
    tmp = calloc((size_t )sizeof(struct xxm_instrument ), (size_t )1);
#line 101
    *(m___0->xxi + i___3) = (struct xxm_instrument *)tmp;
#line 103
    (m___0->xxih + i___3)->nsm = 1;
#line 104
    fread((void */* __restrict  */)(buffer), (size_t )30, (size_t )1, (FILE */* __restrict  */)f);
#line 105
    copy_adjust((m___0->xxih + i___3)->name, buffer, 30);
#line 106
    tmp___0 = read16b(f);
#line 106
    snum___0 = (int )tmp___0;
    }
#line 107
    if (snum___0 == 0) {
#line 108
      goto __Cont;
    } else
#line 107
    if (snum___0 > (m___0->xxh)->smp) {
#line 108
      goto __Cont;
    }
    {
#line 109
    snum___0 --;
#line 109
    (*(m___0->xxi + i___3) + 0)->sid = snum___0;
#line 110
    tmp___1 = read16b(f);
#line 110
    (*(m___0->xxi + i___3) + 0)->vol = (int )tmp___1;
#line 111
    tmp___2 = read32b(f);
#line 111
    c2spd___0 = (int )tmp___2;
#line 112
    tmp___3 = read32b(f);
#line 112
    (m___0->xxs + snum___0)->lps = (int )tmp___3;
#line 113
    tmp___4 = read32b(f);
#line 113
    (m___0->xxs + snum___0)->lpe = (int )((uint32 )(m___0->xxs + i___3)->lps + tmp___4);
#line 114
    tmp___5 = read16b(f);
#line 114
    (*(m___0->xxi + i___3) + 0)->pan = 128 + (int )((int16 )tmp___5);
    }
#line 115
    if ((*(m___0->xxi + i___3) + 0)->pan > 255) {
#line 116
      (*(m___0->xxi + i___3) + 0)->pan = 255;
    }
    {
#line 117
    tmp___6 = read16b(f);
#line 117
    flags = (int )tmp___6;
    }
#line 118
    if (flags & 3) {
#line 118
      (m___0->xxs + snum___0)->flg = 4;
    } else {
#line 118
      (m___0->xxs + snum___0)->flg = 0;
    }
#line 119
    if (flags & 2) {
#line 119
      tmp___7 = 8;
    } else {
#line 119
      tmp___7 = 0;
    }
    {
#line 119
    (m___0->xxs + snum___0)->flg |= tmp___7;
#line 121
    c2spd_to_note(c2spd___0, & (*(m___0->xxi + i___3) + 0)->xpo, & (*(m___0->xxi + i___3) + 0)->fin);
#line 123
    reportv(ctx___0, 1, (char *)"\n[%2X] %-30.30s #%02X V%02x P%02x %5d ", i___3,
            (m___0->xxih + i___3)->name, snum___0, (*(m___0->xxi + i___3) + 0)->vol,
            (*(m___0->xxi + i___3) + 0)->pan, c2spd___0);
#line 127
    reportv(ctx___0, 0, (char *)".");
    }
    __Cont: /* CIL Label */ 
#line 100
    i___3 ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 129
  reportv(ctx___0, 0, (char *)"\n");
  }
#line 130
  return;
}
}
#line 132 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/dbm_load.c"
static void get_patt___1(struct xmp_context *ctx___0 , int size___0 , FILE *f ) 
{ 
  struct xmp_player_context *p ;
  struct xmp_mod_context *m___0 ;
  int i___3 ;
  int c___0 ;
  int r ;
  int n___0 ;
  int sz ;
  struct xxm_event *event ;
  struct xxm_event dummy___3 ;
  uint8 x ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  uint16 tmp___2 ;
  int j ;
  void *tmp___3 ;
  uint32 tmp___4 ;
  uint8 tmp___5 ;
  uint8 tmp___6 ;
  uint8 tmp___7 ;
  uint8 tmp___8 ;
  void *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;

  {
#line 134
  p = & ctx___0->p;
#line 135
  m___0 = & p->m;
  {
#line 140
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 140
    tmp = calloc((size_t )sizeof(struct xxm_track *), (size_t )(m___0->xxh)->trk);
#line 140
    m___0->xxt = (struct xxm_track **)tmp;
#line 140
    tmp___0 = calloc((size_t )sizeof(struct xxm_pattern *), (size_t )((m___0->xxh)->pat + 1));
#line 140
    m___0->xxp = (struct xxm_pattern **)tmp___0;
    }
#line 140
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 142
  reportv(ctx___0, 0, (char *)"Stored patterns: %d ", (m___0->xxh)->pat);
#line 149
  i___3 = 0;
  }
  {
#line 149
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 149
    if (! (i___3 < (m___0->xxh)->pat)) {
#line 149
      goto while_break___0;
    }
    {
#line 150
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 150
      tmp___1 = calloc((size_t )1, (size_t )(sizeof(struct xxm_pattern ) + sizeof(struct xxm_trackinfo ) * (unsigned long )((m___0->xxh)->chn - 1)));
#line 150
      *(m___0->xxp + i___3) = (struct xxm_pattern *)tmp___1;
      }
#line 150
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 151
    tmp___2 = read16b(f);
#line 151
    (*(m___0->xxp + i___3))->rows = (int )tmp___2;
    }
    {
#line 152
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 152
      j = 0;
      {
#line 152
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 152
        if (! (j < (m___0->xxh)->chn)) {
#line 152
          goto while_break___3;
        }
        {
#line 152
        (*(m___0->xxp + i___3))->info[j].index = i___3 * (m___0->xxh)->chn + j;
#line 152
        tmp___3 = calloc((size_t )(sizeof(struct xxm_track ) + sizeof(struct xxm_event ) * (unsigned long )(*(m___0->xxp + i___3))->rows),
                         (size_t )1);
#line 152
        *(m___0->xxt + (i___3 * (m___0->xxh)->chn + j)) = (struct xxm_track *)tmp___3;
#line 152
        (*(m___0->xxt + (i___3 * (m___0->xxh)->chn + j)))->rows = (*(m___0->xxp + i___3))->rows;
#line 152
        j ++;
        }
      }
      while_break___3: /* CIL Label */ ;
      }
#line 152
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 154
    tmp___4 = read32b(f);
#line 154
    sz = (int )tmp___4;
#line 157
    r = 0;
#line 158
    c___0 = -1;
    }
    {
#line 160
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 160
      if (! (sz > 0)) {
#line 160
        goto while_break___4;
      }
      {
#line 162
      tmp___5 = read8(f);
#line 162
      c___0 = (int )tmp___5;
#line 163
      sz --;
      }
#line 163
      if (sz <= 0) {
#line 163
        goto while_break___4;
      }
#line 166
      if (c___0 == 0) {
#line 167
        r ++;
#line 168
        c___0 = -1;
#line 169
        goto while_continue___4;
      }
      {
#line 171
      c___0 --;
#line 173
      tmp___6 = read8(f);
#line 173
      n___0 = (int )tmp___6;
#line 174
      sz --;
      }
#line 174
      if (sz <= 0) {
#line 174
        goto while_break___4;
      }
#line 177
      if (c___0 >= (m___0->xxh)->chn) {
#line 178
        event = & dummy___3;
      } else
#line 177
      if (r >= (*(m___0->xxp + i___3))->rows) {
#line 178
        event = & dummy___3;
      } else {
#line 180
        event = & (*(m___0->xxt + (*(m___0->xxp + i___3))->info[c___0].index))->event[r];
      }
#line 182
      if (n___0 & 1) {
        {
#line 183
        x = read8(f);
#line 184
        event->note = (uint8 )((1 + (((int )x & 240) >> 4) * 12) + ((int )x & 15));
#line 185
        sz --;
        }
#line 185
        if (sz <= 0) {
#line 185
          goto while_break___4;
        }
      }
#line 187
      if (n___0 & 2) {
        {
#line 188
        event->ins = read8(f);
#line 189
        sz --;
        }
#line 189
        if (sz <= 0) {
#line 189
          goto while_break___4;
        }
      }
#line 191
      if (n___0 & 4) {
        {
#line 192
        event->fxt = read8(f);
#line 193
        sz --;
        }
#line 193
        if (sz <= 0) {
#line 193
          goto while_break___4;
        }
      }
#line 195
      if (n___0 & 8) {
        {
#line 196
        event->fxp = read8(f);
#line 197
        sz --;
        }
#line 197
        if (sz <= 0) {
#line 197
          goto while_break___4;
        }
      }
#line 199
      if (n___0 & 16) {
        {
#line 200
        event->f2t = read8(f);
#line 201
        sz --;
        }
#line 201
        if (sz <= 0) {
#line 201
          goto while_break___4;
        }
      }
#line 203
      if (n___0 & 32) {
        {
#line 204
        event->f2p = read8(f);
#line 205
        sz --;
        }
#line 205
        if (sz <= 0) {
#line 205
          goto while_break___4;
        }
      }
#line 208
      if ((int )event->fxt == 28) {
#line 209
        event->fxt = (uint8 )171;
      }
#line 211
      if ((int )event->fxt > 28) {
#line 212
        tmp___7 = (uint8 )0;
#line 212
        event->f2p = tmp___7;
#line 212
        event->fxt = tmp___7;
      }
#line 214
      if ((int )event->f2t == 28) {
#line 215
        event->f2t = (uint8 )171;
      }
#line 217
      if ((int )event->f2t > 28) {
#line 218
        tmp___8 = (uint8 )0;
#line 218
        event->f2p = tmp___8;
#line 218
        event->f2t = tmp___8;
      }
    }
    while_break___4: /* CIL Label */ ;
    }
    {
#line 220
    reportv(ctx___0, 0, (char *)".");
#line 149
    i___3 ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 222
  reportv(ctx___0, 0, (char *)"\n");
  }
#line 223
  return;
}
}
#line 225 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/dbm_load.c"
static void get_smpl(struct xmp_context *ctx___0 , int size___0 , FILE *f ) 
{ 
  struct xmp_player_context *p ;
  struct xmp_mod_context *m___0 ;
  int i___3 ;
  int flags ;
  uint32 tmp ;
  uint32 tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;

  {
  {
#line 227
  p = & ctx___0->p;
#line 228
  m___0 = & p->m;
#line 231
  reportv(ctx___0, 0, (char *)"Stored samples : %d ", (m___0->xxh)->smp);
#line 233
  reportv(ctx___0, 2, (char *)"\n     Flags    Len   LBeg  LEnd  L");
#line 235
  i___3 = 0;
  }
  {
#line 235
  while (1) {
    while_continue: /* CIL Label */ ;
#line 235
    if (! (i___3 < (m___0->xxh)->smp)) {
#line 235
      goto while_break;
    }
    {
#line 236
    tmp = read32b(f);
#line 236
    flags = (int )tmp;
#line 237
    tmp___0 = read32b(f);
#line 237
    (m___0->xxs + i___3)->len = (int )tmp___0;
    }
#line 239
    if (flags & 2) {
#line 240
      (m___0->xxs + i___3)->flg |= 1;
#line 241
      (m___0->xxs + i___3)->len <<= 1;
#line 242
      (m___0->xxs + i___3)->lps <<= 1;
#line 243
      (m___0->xxs + i___3)->lpe <<= 1;
    }
#line 246
    if (flags & 4) {
      {
#line 247
      (m___0->xxs + i___3)->len <<= 2;
#line 248
      fseek(f, (long )(m___0->xxs + i___3)->len, 1);
      }
#line 249
      goto __Cont;
    }
    {
#line 252
    xmp_drv_loadpatch(ctx___0, f, i___3, m___0->c4rate, 64, m___0->xxs + i___3, (char *)((void *)0));
    }
#line 255
    if ((m___0->xxs + i___3)->len == 0) {
#line 256
      goto __Cont;
    }
#line 258
    if ((m___0->xxs + i___3)->flg & 4) {
#line 258
      if ((m___0->xxs + i___3)->flg & 8) {
#line 258
        tmp___1 = 'B';
      } else {
#line 258
        tmp___1 = 'L';
      }
#line 258
      tmp___2 = tmp___1;
    } else {
#line 258
      tmp___2 = ' ';
    }
#line 258
    if ((m___0->xxs + i___3)->flg & 1) {
#line 258
      tmp___3 = '+';
    } else {
#line 258
      tmp___3 = ' ';
    }
    {
#line 258
    reportv(ctx___0, 2, (char *)"\n[%2X] %08x %05x%c%05x %05x %c ", i___3, flags,
            (m___0->xxs + i___3)->len, tmp___3, (m___0->xxs + i___3)->lps, (m___0->xxs + i___3)->lpe,
            tmp___2);
#line 265
    reportv(ctx___0, 0, (char *)".");
    }
    __Cont: /* CIL Label */ 
#line 235
    i___3 ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 267
  reportv(ctx___0, 0, (char *)"\n");
  }
#line 268
  return;
}
}
#line 270 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/dbm_load.c"
static void get_venv(struct xmp_context *ctx___0 , int size___0 , FILE *f ) 
{ 
  struct xmp_player_context *p ;
  struct xmp_mod_context *m___0 ;
  int i___3 ;
  int j ;
  int nenv ;
  int ins ;
  uint16 tmp ;
  void *tmp___0 ;
  uint16 tmp___1 ;
  uint8 tmp___2 ;
  uint8 tmp___3 ;
  uint8 tmp___4 ;
  uint8 tmp___5 ;
  uint8 tmp___6 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;

  {
  {
#line 272
  p = & ctx___0->p;
#line 273
  m___0 = & p->m;
#line 276
  tmp = read16b(f);
#line 276
  nenv = (int )tmp;
#line 278
  reportv(ctx___0, 1, (char *)"Vol envelopes  : %d ", nenv);
#line 280
  i___3 = 0;
  }
  {
#line 280
  while (1) {
    while_continue: /* CIL Label */ ;
#line 280
    if (! (i___3 < (m___0->xxh)->ins)) {
#line 280
      goto while_break;
    }
    {
#line 281
    tmp___0 = calloc((size_t )4, (size_t )32);
#line 281
    *(m___0->xxae + i___3) = (uint16 *)tmp___0;
#line 280
    i___3 ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 284
  i___3 = 0;
  {
#line 284
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 284
    if (! (i___3 < nenv)) {
#line 284
      goto while_break___0;
    }
    {
#line 285
    tmp___1 = read16b(f);
#line 285
    ins = (int )tmp___1 - 1;
#line 286
    tmp___2 = read8(f);
#line 286
    (m___0->xxih + ins)->aei.flg = (int )tmp___2 & 7;
#line 287
    tmp___3 = read8(f);
#line 287
    (m___0->xxih + ins)->aei.npt = (int )tmp___3;
#line 288
    tmp___4 = read8(f);
#line 288
    (m___0->xxih + ins)->aei.sus = (int )tmp___4;
#line 289
    tmp___5 = read8(f);
#line 289
    (m___0->xxih + ins)->aei.lps = (int )tmp___5;
#line 290
    tmp___6 = read8(f);
#line 290
    (m___0->xxih + ins)->aei.lpe = (int )tmp___6;
#line 291
    read8(f);
#line 294
    j = 0;
    }
    {
#line 294
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 294
      if (! (j < 32)) {
#line 294
        goto while_break___1;
      }
      {
#line 295
      *(*(m___0->xxae + ins) + j * 2) = read16b(f);
#line 296
      *(*(m___0->xxae + ins) + (j * 2 + 1)) = read16b(f);
#line 294
      j ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 298
    reportv(ctx___0, 1, (char *)".");
#line 284
    i___3 ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 300
  reportv(ctx___0, 1, (char *)"\n");
  }
#line 301
  return;
}
}
#line 303 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/dbm_load.c"
static int dbm_load(struct xmp_context *ctx___0 , FILE *f , int const   start ) 
{ 
  struct xmp_player_context *p ;
  struct xmp_mod_context *m___0 ;
  char name[44] ;
  uint16 version ;
  int i___3 ;
  uint8 **tmp ;
  int tmp___0 ;
  void *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;

  {
#line 305
  p = & ctx___0->p;
#line 306
  m___0 = & p->m;
  {
#line 311
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 311
    fseek(f, (long )start, 0);
#line 311
    tmp = (uint8 **)((void *)0);
#line 311
    m___0->med_wav_table = tmp;
#line 311
    m___0->med_vol_table = tmp;
#line 311
    set_xxh_defaults(m___0->xxh);
    }
#line 311
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 313
  read32b(f);
#line 315
  have_song = 0;
#line 316
  version = read16b(f);
#line 318
  fseek(f, 10L, 1);
#line 319
  fread((void */* __restrict  */)(name), (size_t )1, (size_t )44, (FILE */* __restrict  */)f);
#line 322
  iff_register((char *)"INFO", & get_info);
#line 323
  iff_register((char *)"SONG", & get_song);
#line 324
  iff_register((char *)"INST", & get_inst___1);
#line 325
  iff_register((char *)"PATT", & get_patt___1);
#line 326
  iff_register((char *)"SMPL", & get_smpl);
#line 327
  iff_register((char *)"VENV", & get_venv);
#line 329
  strncpy((char */* __restrict  */)(m___0->name), (char const   */* __restrict  */)(name),
          (size_t )64);
#line 330
  snprintf((char */* __restrict  */)(m___0->type), (size_t )64, (char const   */* __restrict  */)"DBM0 (DigiBooster Pro %d.%02x)",
           (int )version >> 8, (int )version & 255);
  }
  {
#line 332
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 332
    if (m___0->verbosity) {
#line 332
      if (m___0->name[0]) {
        {
#line 332
        report((char *)"Module title   : %s\n", m___0->name);
        }
      }
#line 332
      if (m___0->type[0]) {
        {
#line 332
        report((char *)"Module type    : %s\n", m___0->type);
        }
      }
#line 332
      if (m___0->author[0]) {
        {
#line 332
        report((char *)"Author name    : %s\n", m___0->author);
        }
      }
#line 332
      if ((m___0->xxh)->len) {
        {
#line 332
        report((char *)"Module length  : %d patterns\n", (m___0->xxh)->len);
        }
      }
    }
#line 332
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 335
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 335
    tmp___0 = feof(f);
    }
#line 335
    if (tmp___0) {
#line 335
      goto while_break___1;
    }
    {
#line 336
    iff_chunk(ctx___0, f);
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 338
  iff_release();
#line 340
  i___3 = 0;
  }
  {
#line 340
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 340
    if (! (i___3 < (m___0->xxh)->chn)) {
#line 340
      goto while_break___2;
    }
#line 341
    m___0->xxc[i___3].pan = 128;
#line 340
    i___3 ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 343
  return (0);
}
}
#line 8 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/asif.h"
int asif_load(struct xmp_context *ctx___0 , FILE *f , int i___3 ) ;
#line 32 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/ssmt_load.c"
static int mtp_test(FILE *f , char *t , int const   start ) ;
#line 33
static int mtp_load(struct xmp_context *ctx___0 , FILE *f , int const   start ) ;
#line 35 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/ssmt_load.c"
struct xmp_loader_info mtp_loader  =    {(char *)"MTP", (char *)"Soundsmith/MegaTracker", & mtp_test, & mtp_load, 0, {(struct list_head *)0,
                                                                                 (struct list_head *)0}};
#line 42 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/ssmt_load.c"
static int mtp_test(FILE *f , char *t , int const   start ) 
{ 
  char buf___1[6] ;
  int tmp ;
  int tmp___0 ;
  void *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
  {
#line 46
  fread((void */* __restrict  */)(buf___1), (size_t )6, (size_t )1, (FILE */* __restrict  */)f);
#line 47
  tmp = memcmp((void const   *)(buf___1), (void const   *)"SONGOK", (size_t )6);
  }
#line 47
  if (tmp) {
    {
#line 47
    tmp___0 = memcmp((void const   *)(buf___1), (void const   *)"IAN92a", (size_t )6);
    }
#line 47
    if (tmp___0) {
#line 48
      return (-1);
    }
  }
  {
#line 50
  read_title(f, t, 0);
  }
#line 52
  return (0);
}
}
#line 61 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/ssmt_load.c"
static int mtp_load(struct xmp_context *ctx___0 , FILE *f , int const   start ) 
{ 
  struct xmp_player_context *p ;
  struct xmp_mod_context *m___0 ;
  struct xxm_event *event ;
  int i___3 ;
  int j ;
  int k ;
  uint8 buffer[25] ;
  int blocksize ;
  FILE *s ;
  uint8 **tmp ;
  int tmp___0 ;
  int tmp___1 ;
  uint16 tmp___2 ;
  uint16 tmp___3 ;
  int tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  void *tmp___9 ;
  void *tmp___10 ;
  void *tmp___11 ;
  void *tmp___12 ;
  uint8 tmp___13 ;
  uint8 tmp___14 ;
  void *tmp___15 ;
  void *tmp___16 ;
  void *tmp___17 ;
  int j___0 ;
  void *tmp___18 ;
  uint8 x ;
  char filename[1024] ;
  int tmp___19 ;
  size_t tmp___20 ;
  void *__cil_tmp38 ;
  void *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;

  {
#line 63
  p = & ctx___0->p;
#line 64
  m___0 = & p->m;
  {
#line 71
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 71
    fseek(f, (long )start, 0);
#line 71
    tmp = (uint8 **)((void *)0);
#line 71
    m___0->med_wav_table = tmp;
#line 71
    m___0->med_vol_table = tmp;
#line 71
    set_xxh_defaults(m___0->xxh);
    }
#line 71
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 73
  fread((void */* __restrict  */)(buffer), (size_t )6, (size_t )1, (FILE */* __restrict  */)f);
#line 75
  tmp___1 = memcmp((void const   *)(buffer), (void const   *)"SONGOK", (size_t )6);
  }
#line 75
  if (tmp___1) {
    {
#line 77
    tmp___0 = memcmp((void const   *)(buffer), (void const   *)"IAN92a", (size_t )8);
    }
#line 77
    if (tmp___0) {
#line 80
      return (-1);
    } else {
      {
#line 78
      strcpy((char */* __restrict  */)(m___0->type), (char const   */* __restrict  */)"IIgs MegaTracker");
      }
    }
  } else {
    {
#line 76
    strcpy((char */* __restrict  */)(m___0->type), (char const   */* __restrict  */)"IIgs SoundSmith");
    }
  }
  {
#line 82
  tmp___2 = read16l(f);
#line 82
  blocksize = (int )tmp___2;
#line 83
  tmp___3 = read16l(f);
#line 83
  (m___0->xxh)->tpo = (int )tmp___3;
#line 84
  fseek(f, 10L, 1);
#line 86
  tmp___4 = 15;
#line 86
  (m___0->xxh)->smp = tmp___4;
#line 86
  (m___0->xxh)->ins = tmp___4;
  }
  {
#line 87
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 87
    tmp___5 = calloc((size_t )sizeof(struct xxm_instrument_header ), (size_t )(m___0->xxh)->ins);
#line 87
    m___0->xxih = (struct xxm_instrument_header *)tmp___5;
#line 87
    tmp___6 = calloc((size_t )sizeof(struct xxm_instrument_map ), (size_t )(m___0->xxh)->ins);
#line 87
    m___0->xxim = (struct xxm_instrument_map *)tmp___6;
#line 87
    tmp___7 = calloc((size_t )sizeof(struct xxm_instrument *), (size_t )(m___0->xxh)->ins);
#line 87
    m___0->xxi = (struct xxm_instrument **)tmp___7;
    }
#line 87
    if ((m___0->xxh)->smp) {
      {
#line 87
      tmp___8 = calloc((size_t )sizeof(struct xxm_sample ), (size_t )(m___0->xxh)->smp);
#line 87
      m___0->xxs = (struct xxm_sample *)tmp___8;
      }
    }
    {
#line 87
    tmp___9 = calloc((size_t )sizeof(uint16 *), (size_t )(m___0->xxh)->ins);
#line 87
    m___0->xxae = (uint16 **)tmp___9;
#line 87
    tmp___10 = calloc((size_t )sizeof(uint16 *), (size_t )(m___0->xxh)->ins);
#line 87
    m___0->xxpe = (uint16 **)tmp___10;
#line 87
    tmp___11 = calloc((size_t )sizeof(uint16 *), (size_t )(m___0->xxh)->ins);
#line 87
    m___0->xxfe = (uint16 **)tmp___11;
    }
#line 87
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 89
  i___3 = 0;
  {
#line 89
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 89
    if (! (i___3 < (m___0->xxh)->ins)) {
#line 89
      goto while_break___1;
    }
    {
#line 90
    tmp___12 = calloc((size_t )sizeof(struct xxm_instrument ), (size_t )1);
#line 90
    *(m___0->xxi + i___3) = (struct xxm_instrument *)tmp___12;
#line 92
    fread((void */* __restrict  */)(buffer), (size_t )1, (size_t )22, (FILE */* __restrict  */)f);
    }
#line 93
    if (buffer[0]) {
      {
#line 94
      buffer[(int )buffer[0] + 1] = (uint8 )0;
#line 95
      copy_adjust((m___0->xxih + i___3)->name, buffer + 1, 22);
      }
    }
    {
#line 97
    read16l(f);
#line 98
    tmp___13 = read8(f);
#line 98
    (*(m___0->xxi + i___3) + 0)->vol = (int )tmp___13 >> 2;
#line 99
    (*(m___0->xxi + i___3) + 0)->pan = 128;
#line 100
    fseek(f, 5L, 1);
#line 89
    i___3 ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 103
  tmp___14 = read8(f);
#line 103
  (m___0->xxh)->len = (int )tmp___14 & 127;
#line 104
  read8(f);
#line 105
  fread((void */* __restrict  */)(m___0->xxo), (size_t )1, (size_t )128, (FILE */* __restrict  */)f);
  }
  {
#line 107
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 107
    if (m___0->verbosity) {
#line 107
      if (m___0->name[0]) {
        {
#line 107
        report((char *)"Module title   : %s\n", m___0->name);
        }
      }
#line 107
      if (m___0->type[0]) {
        {
#line 107
        report((char *)"Module type    : %s\n", m___0->type);
        }
      }
#line 107
      if (m___0->author[0]) {
        {
#line 107
        report((char *)"Author name    : %s\n", m___0->author);
        }
      }
#line 107
      if ((m___0->xxh)->len) {
        {
#line 107
        report((char *)"Module length  : %d patterns\n", (m___0->xxh)->len);
        }
      }
    }
#line 107
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 109
  fseek(f, (long )(start + 600), 0);
#line 111
  (m___0->xxh)->chn = 14;
#line 112
  (m___0->xxh)->pat = blocksize / 896;
#line 113
  (m___0->xxh)->trk = (m___0->xxh)->pat * (m___0->xxh)->chn;
  }
  {
#line 115
  while (1) {
    while_continue___3: /* CIL Label */ ;
    {
#line 115
    tmp___15 = calloc((size_t )sizeof(struct xxm_track *), (size_t )(m___0->xxh)->trk);
#line 115
    m___0->xxt = (struct xxm_track **)tmp___15;
#line 115
    tmp___16 = calloc((size_t )sizeof(struct xxm_pattern *), (size_t )((m___0->xxh)->pat + 1));
#line 115
    m___0->xxp = (struct xxm_pattern **)tmp___16;
    }
#line 115
    goto while_break___3;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 118
  reportv(ctx___0, 0, (char *)"Stored patterns: %d ", (m___0->xxh)->pat);
#line 121
  i___3 = 0;
  }
  {
#line 121
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 121
    if (! (i___3 < (m___0->xxh)->pat)) {
#line 121
      goto while_break___4;
    }
    {
#line 122
    while (1) {
      while_continue___5: /* CIL Label */ ;
      {
#line 122
      tmp___17 = calloc((size_t )1, (size_t )(sizeof(struct xxm_pattern ) + sizeof(struct xxm_trackinfo ) * (unsigned long )((m___0->xxh)->chn - 1)));
#line 122
      *(m___0->xxp + i___3) = (struct xxm_pattern *)tmp___17;
      }
#line 122
      goto while_break___5;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 123
    (*(m___0->xxp + i___3))->rows = 64;
    {
#line 124
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 124
      j___0 = 0;
      {
#line 124
      while (1) {
        while_continue___7: /* CIL Label */ ;
#line 124
        if (! (j___0 < (m___0->xxh)->chn)) {
#line 124
          goto while_break___7;
        }
        {
#line 124
        (*(m___0->xxp + i___3))->info[j___0].index = i___3 * (m___0->xxh)->chn + j___0;
#line 124
        tmp___18 = calloc((size_t )(sizeof(struct xxm_track ) + sizeof(struct xxm_event ) * (unsigned long )(*(m___0->xxp + i___3))->rows),
                          (size_t )1);
#line 124
        *(m___0->xxt + (i___3 * (m___0->xxh)->chn + j___0)) = (struct xxm_track *)tmp___18;
#line 124
        (*(m___0->xxt + (i___3 * (m___0->xxh)->chn + j___0)))->rows = (*(m___0->xxp + i___3))->rows;
#line 124
        j___0 ++;
        }
      }
      while_break___7: /* CIL Label */ ;
      }
#line 124
      goto while_break___6;
    }
    while_break___6: /* CIL Label */ ;
    }
#line 126
    j = 0;
    {
#line 126
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 126
      if (! (j < (*(m___0->xxp + i___3))->rows)) {
#line 126
        goto while_break___8;
      }
#line 127
      k = 0;
      {
#line 127
      while (1) {
        while_continue___9: /* CIL Label */ ;
#line 127
        if (! (k < (m___0->xxh)->chn)) {
#line 127
          goto while_break___9;
        }
        {
#line 128
        event = & (*(m___0->xxt + (*(m___0->xxp + i___3))->info[k].index))->event[j];
#line 129
        event->note = read8(f);
        }
#line 130
        if (event->note) {
#line 131
          event->note = (uint8 )((int )event->note + 12);
        }
#line 127
        k ++;
      }
      while_break___9: /* CIL Label */ ;
      }
#line 126
      j ++;
    }
    while_break___8: /* CIL Label */ ;
    }
    {
#line 134
    reportv(ctx___0, 0, (char *)".");
#line 121
    i___3 ++;
    }
  }
  while_break___4: /* CIL Label */ ;
  }
#line 138
  i___3 = 0;
  {
#line 138
  while (1) {
    while_continue___10: /* CIL Label */ ;
#line 138
    if (! (i___3 < (m___0->xxh)->pat)) {
#line 138
      goto while_break___10;
    }
#line 139
    j = 0;
    {
#line 139
    while (1) {
      while_continue___11: /* CIL Label */ ;
#line 139
      if (! (j < (*(m___0->xxp + i___3))->rows)) {
#line 139
        goto while_break___11;
      }
#line 140
      k = 0;
      {
#line 140
      while (1) {
        while_continue___12: /* CIL Label */ ;
#line 140
        if (! (k < (m___0->xxh)->chn)) {
#line 140
          goto while_break___12;
        }
        {
#line 142
        event = & (*(m___0->xxt + (*(m___0->xxp + i___3))->info[k].index))->event[j];
#line 143
        x = read8(f);
#line 144
        event->ins = (uint8 )((int )x >> 4);
        }
        {
#line 147
        if (((int )x & 15) == 0) {
#line 147
          goto case_0;
        }
#line 150
        if (((int )x & 15) == 3) {
#line 150
          goto case_3;
        }
#line 153
        if (((int )x & 15) == 5) {
#line 153
          goto case_5;
        }
#line 156
        if (((int )x & 15) == 6) {
#line 156
          goto case_6;
        }
#line 159
        if (((int )x & 15) == 15) {
#line 159
          goto case_15;
        }
#line 146
        goto switch_break;
        case_0: /* CIL Label */ 
#line 148
        event->fxt = (uint8 )0;
#line 149
        goto switch_break;
        case_3: /* CIL Label */ 
#line 151
        event->fxt = (uint8 )12;
#line 152
        goto switch_break;
        case_5: /* CIL Label */ 
#line 154
        event->fxt = (uint8 )161;
#line 155
        goto switch_break;
        case_6: /* CIL Label */ 
#line 157
        event->fxt = (uint8 )160;
#line 158
        goto switch_break;
        case_15: /* CIL Label */ 
#line 160
        event->fxt = (uint8 )15;
#line 161
        goto switch_break;
        switch_break: /* CIL Label */ ;
        }
#line 140
        k ++;
      }
      while_break___12: /* CIL Label */ ;
      }
#line 139
      j ++;
    }
    while_break___11: /* CIL Label */ ;
    }
#line 138
    i___3 ++;
  }
  while_break___10: /* CIL Label */ ;
  }
#line 168
  i___3 = 0;
  {
#line 168
  while (1) {
    while_continue___13: /* CIL Label */ ;
#line 168
    if (! (i___3 < (m___0->xxh)->pat)) {
#line 168
      goto while_break___13;
    }
#line 169
    j = 0;
    {
#line 169
    while (1) {
      while_continue___14: /* CIL Label */ ;
#line 169
      if (! (j < (*(m___0->xxp + i___3))->rows)) {
#line 169
        goto while_break___14;
      }
#line 170
      k = 0;
      {
#line 170
      while (1) {
        while_continue___15: /* CIL Label */ ;
#line 170
        if (! (k < (m___0->xxh)->chn)) {
#line 170
          goto while_break___15;
        }
        {
#line 171
        event = & (*(m___0->xxt + (*(m___0->xxp + i___3))->info[k].index))->event[j];
#line 172
        event->fxp = read8(f);
        }
        {
#line 177
        if ((int )event->fxt == 160) {
#line 177
          goto case_160;
        }
#line 177
        if ((int )event->fxt == 161) {
#line 177
          goto case_160;
        }
#line 177
        if ((int )event->fxt == 12) {
#line 177
          goto case_160;
        }
#line 174
        goto switch_break___0;
        case_160: /* CIL Label */ 
        case_161: /* CIL Label */ 
        case_12: /* CIL Label */ 
#line 178
        event->fxp = (uint8 )((int )event->fxp >> 2);
        switch_break___0: /* CIL Label */ ;
        }
#line 170
        k ++;
      }
      while_break___15: /* CIL Label */ ;
      }
#line 169
      j ++;
    }
    while_break___14: /* CIL Label */ ;
    }
#line 168
    i___3 ++;
  }
  while_break___13: /* CIL Label */ ;
  }
  {
#line 184
  reportv(ctx___0, 0, (char *)"\n");
#line 187
  reportv(ctx___0, 0, (char *)"Instruments    : %d ", (m___0->xxh)->ins);
#line 188
  reportv(ctx___0, 1, (char *)"\n     Name                   Len  LBeg LEnd L Vol");
#line 190
  i___3 = 0;
  }
  {
#line 190
  while (1) {
    while_continue___16: /* CIL Label */ ;
#line 190
    if (! (i___3 < (m___0->xxh)->ins)) {
#line 190
      goto while_break___16;
    }
#line 193
    if (! (m___0->xxih + i___3)->name[0]) {
#line 194
      goto __Cont;
    }
    {
#line 196
    strncpy((char */* __restrict  */)(filename), (char const   */* __restrict  */)m___0->dirname,
            (size_t )255);
    }
#line 197
    if (filename[0]) {
      {
#line 198
      strncat((char */* __restrict  */)(filename), (char const   */* __restrict  */)"/",
              (size_t )255);
      }
    }
    {
#line 199
    strncat((char */* __restrict  */)(filename), (char const   */* __restrict  */)((char *)((m___0->xxih + i___3)->name)),
            (size_t )255);
#line 201
    s = fopen((char const   */* __restrict  */)(filename), (char const   */* __restrict  */)"rb");
    }
#line 201
    if ((unsigned long )s != (unsigned long )((void *)0)) {
      {
#line 202
      asif_load(ctx___0, s, i___3);
#line 203
      fclose(s);
      }
    }
#line 214
    if (m___0->verbosity > 1) {
      {
#line 214
      tmp___20 = strlen((char const   *)((char *)((m___0->xxih + i___3)->name)));
      }
#line 214
      if (tmp___20) {
#line 214
        goto _L;
      } else
#line 214
      if ((m___0->xxs + i___3)->len > 1) {
        _L: /* CIL Label */ 
#line 215
        if ((m___0->xxs + i___3)->flg & 4) {
#line 215
          tmp___19 = 'L';
        } else {
#line 215
          tmp___19 = ' ';
        }
        {
#line 215
        report((char *)"\n[%2X] %-22.22s %04x %04x %04x %c V%02x", i___3, (m___0->xxih + i___3)->name,
               (m___0->xxs + i___3)->len, (m___0->xxs + i___3)->lps, (m___0->xxs + i___3)->lpe,
               tmp___19, (*(m___0->xxi + i___3) + 0)->vol);
        }
      }
    }
    __Cont: /* CIL Label */ 
#line 190
    i___3 ++;
  }
  while_break___16: /* CIL Label */ ;
  }
  {
#line 222
  reportv(ctx___0, 0, (char *)"\n");
  }
#line 224
  return (0);
}
}
#line 25 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/med4_load.c"
static int med4_test(FILE *f , char *t , int const   start ) ;
#line 26
static int med4_load(struct xmp_context *ctx___0 , FILE *f , int const   start ) ;
#line 28 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/med4_load.c"
struct xmp_loader_info med4_loader  =    {(char *)"MED4", (char *)"MED 2.10", & med4_test, & med4_load, 0, {(struct list_head *)0,
                                                                      (struct list_head *)0}};
#line 35 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/med4_load.c"
static int med4_test(FILE *f , char *t , int const   start ) 
{ 
  uint32 tmp ;

  {
  {
#line 37
  tmp = read32b(f);
  }
#line 37
  if (tmp != ((((77U << 24) | (69U << 16)) | (68U << 8)) | 4U)) {
#line 38
    return (-1);
  }
  {
#line 40
  read_title(f, t, 0);
  }
#line 42
  return (0);
}
}
#line 46 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/med4_load.c"
static int read4_ctl  ;
#line 48 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/med4_load.c"
static void fix_effect___0(struct xxm_event *event ) 
{ 
  uint8 tmp ;
  uint8 tmp___0 ;
  uint8 tmp___1 ;

  {
  {
#line 53
  if ((int )event->fxt == 2) {
#line 53
    goto case_2;
  }
#line 53
  if ((int )event->fxt == 1) {
#line 53
    goto case_2;
  }
#line 53
  if ((int )event->fxt == 0) {
#line 53
    goto case_2;
  }
#line 55
  if ((int )event->fxt == 3) {
#line 55
    goto case_3;
  }
#line 58
  if ((int )event->fxt == 12) {
#line 58
    goto case_12;
  }
#line 62
  if ((int )event->fxt == 13) {
#line 62
    goto case_13;
  }
#line 65
  if ((int )event->fxt == 15) {
#line 65
    goto case_15;
  }
#line 87
  goto switch_default;
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
  case_0: /* CIL Label */ 
#line 54
  goto switch_break;
  case_3: /* CIL Label */ 
#line 56
  event->fxt = (uint8 )4;
#line 57
  goto switch_break;
  case_12: /* CIL Label */ 
#line 59
  event->fxp = (uint8 )((((int )event->fxp & 240) >> 4) * 10 + ((int )event->fxp & 15));
#line 61
  goto switch_break;
  case_13: /* CIL Label */ 
#line 63
  event->fxt = (uint8 )10;
#line 64
  goto switch_break;
  case_15: /* CIL Label */ 
#line 66
  if ((int )event->fxp == 0) {
#line 67
    event->fxt = (uint8 )13;
  }
#line 68
  if ((int )event->fxp == 255) {
#line 69
    tmp = (uint8 )0;
#line 69
    event->fxt = tmp;
#line 69
    event->fxp = tmp;
#line 70
    event->vol = (uint8 )1;
  } else
#line 71
  if ((int )event->fxp == 254) {
#line 72
    tmp___0 = (uint8 )0;
#line 72
    event->fxt = tmp___0;
#line 72
    event->fxp = tmp___0;
  } else
#line 73
  if ((int )event->fxp == 241) {
#line 74
    event->fxt = (uint8 )14;
#line 75
    event->fxp = (uint8 )((9 << 4) | 3);
  } else
#line 76
  if ((int )event->fxp == 242) {
#line 77
    event->fxt = (uint8 )14;
#line 78
    event->fxp = (uint8 )((12 << 4) | 3);
  } else
#line 79
  if ((int )event->fxp == 243) {
#line 80
    event->fxt = (uint8 )14;
#line 81
    event->fxp = (uint8 )((13 << 4) | 3);
  } else
#line 82
  if ((int )event->fxp > 10) {
#line 83
    event->fxt = (uint8 )171;
#line 84
    event->fxp = (uint8 )((125 * (int )event->fxp) / 33);
  }
#line 86
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 88
  tmp___1 = (uint8 )0;
#line 88
  event->fxt = tmp___1;
#line 88
  event->fxp = tmp___1;
  switch_break: /* CIL Label */ ;
  }
#line 90
  return;
}
}
#line 94
__inline static uint8 read4(FILE *f ) ;
#line 94 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/med4_load.c"
static uint8 b  =    (uint8 )0;
#line 92 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/med4_load.c"
__inline static uint8 read4(FILE *f ) 
{ 
  uint8 ret ;

  {
#line 97
  if (read4_ctl & 1) {
#line 98
    ret = (uint8 )((int )b & 15);
  } else {
    {
#line 100
    b = read8(f);
#line 101
    ret = (uint8 )((int )b >> 4);
    }
  }
#line 104
  read4_ctl ^= 1;
#line 106
  return (ret);
}
}
#line 109 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/med4_load.c"
__inline static uint16 read12b(FILE *f ) 
{ 
  uint32 a ;
  uint32 b___1 ;
  uint32 c___0 ;
  uint8 tmp ;
  uint8 tmp___0 ;
  uint8 tmp___1 ;

  {
  {
#line 113
  tmp = read4(f);
#line 113
  a = (uint32 )tmp;
#line 114
  tmp___0 = read4(f);
#line 114
  b___1 = (uint32 )tmp___0;
#line 115
  tmp___1 = read4(f);
#line 115
  c___0 = (uint32 )tmp___1;
  }
#line 117
  return ((uint16 )(((a << 8) | (b___1 << 4)) | c___0));
}
}
#line 120 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/med4_load.c"
static int med4_load(struct xmp_context *ctx___0 , FILE *f , int const   start ) 
{ 
  struct xmp_player_context *p ;
  struct xmp_mod_context *m___0 ;
  int i___3 ;
  int j ;
  int k ;
  uint32 m0 ;
  uint32 mask ;
  int transp ;
  int masksz ;
  int pos___0 ;
  int vermaj ;
  int vermin ;
  uint8 trkvol[16] ;
  uint8 buf___1[1024] ;
  struct xxm_event *event ;
  int flags ;
  int hexvol ;
  uint8 **tmp ;
  long tmp___0 ;
  int tmp___1 ;
  uint8 tmp___2 ;
  uint8 tmp___3 ;
  int tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  void *tmp___9 ;
  void *tmp___10 ;
  void *tmp___11 ;
  uint8 c___0 ;
  uint8 size___0 ;
  uint8 buf___2[40] ;
  uint16 loop_len ;
  void *tmp___12 ;
  uint16 tmp___13 ;
  uint16 tmp___14 ;
  uint8 tmp___15 ;
  uint16 tmp___16 ;
  uint16 tmp___17 ;
  uint16 tmp___18 ;
  int8 tmp___19 ;
  int8 tmp___20 ;
  uint8 tmp___21 ;
  uint8 tmp___22 ;
  void *tmp___23 ;
  void *tmp___24 ;
  int size___1 ;
  int plen ;
  uint8 ctl ;
  uint8 chmsk ;
  uint8 chn ;
  uint8 rows___1 ;
  uint32 linemsk0 ;
  uint32 fxmsk0 ;
  uint32 linemsk1 ;
  uint32 fxmsk1 ;
  uint32 x ;
  uint8 tmp___25 ;
  uint8 tmp___26 ;
  uint16 tmp___27 ;
  void *tmp___28 ;
  int j___0 ;
  void *tmp___29 ;
  uint32 tmp___30 ;
  uint32 tmp___31 ;
  uint32 tmp___32 ;
  uint32 tmp___33 ;
  uint32 tmp___34 ;
  uint32 tmp___35 ;
  uint32 tmp___36 ;
  uint32 tmp___37 ;
  uint8 tmp___38 ;
  uint16 tmp___39 ;
  uint16 tmp___40 ;
  uint16 tmp___41 ;
  uint16 tmp___42 ;
  uint16 tmp___43 ;
  int tmp___44 ;
  void *__cil_tmp83 ;
  void *__cil_tmp84 ;
  void *__cil_tmp85 ;
  char *__cil_tmp86 ;
  char *__cil_tmp87 ;
  char *__cil_tmp88 ;
  char *__cil_tmp89 ;
  char *__cil_tmp90 ;
  char *__cil_tmp91 ;
  char *__cil_tmp92 ;
  char *__cil_tmp93 ;
  char *__cil_tmp94 ;
  char *__cil_tmp95 ;
  char *__cil_tmp96 ;
  char *__cil_tmp97 ;
  char *__cil_tmp98 ;
  char *__cil_tmp99 ;
  char *__cil_tmp100 ;

  {
#line 122
  p = & ctx___0->p;
#line 123
  m___0 = & p->m;
#line 130
  hexvol = 0;
  {
#line 132
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 132
    fseek(f, (long )start, 0);
#line 132
    tmp = (uint8 **)((void *)0);
#line 132
    m___0->med_wav_table = tmp;
#line 132
    m___0->med_vol_table = tmp;
#line 132
    set_xxh_defaults(m___0->xxh);
    }
#line 132
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 134
  read32b(f);
#line 136
  vermaj = 2;
#line 137
  vermin = 10;
#line 142
  tmp___0 = ftell(f);
#line 142
  pos___0 = (int )tmp___0;
#line 143
  fseek(f, 0L, 2);
#line 144
  fseek(f, -1023L, 1);
#line 145
  fread((void */* __restrict  */)(buf___1), (size_t )1, (size_t )1024, (FILE */* __restrict  */)f);
#line 146
  fseek(f, (long )(start + (int const   )pos___0), 0);
#line 147
  i___3 = 0;
  }
  {
#line 147
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 147
    if (! (i___3 < 1012)) {
#line 147
      goto while_break___0;
    }
    {
#line 148
    tmp___1 = memcmp((void const   *)(buf___1 + i___3), (void const   *)"MEDV\000\000\000\004",
                     (size_t )8);
    }
#line 148
    if (! tmp___1) {
#line 149
      vermaj = (int )*((buf___1 + i___3) + 10);
#line 150
      vermin = (int )*((buf___1 + i___3) + 11);
#line 151
      goto while_break___0;
    }
#line 147
    i___3 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 155
  sprintf((char */* __restrict  */)(m___0->type), (char const   */* __restrict  */)"MED4 (MED %d.%02d)",
          vermaj, vermin);
#line 157
  tmp___2 = read8(f);
#line 157
  m0 = (uint32 )tmp___2;
#line 159
  masksz = 0;
#line 159
  mask = (uint32 )masksz;
#line 160
  i___3 = 0;
  }
  {
#line 160
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 160
    if (! (i___3 < 8)) {
#line 160
      goto while_break___1;
    }
#line 161
    if (m0 & 128U) {
      {
#line 162
      mask <<= 8;
#line 163
      tmp___3 = read8(f);
#line 163
      mask |= (unsigned int )tmp___3;
#line 164
      masksz ++;
      }
    }
#line 160
    i___3 ++;
#line 160
    m0 <<= 1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 167
  mask <<= 32 - masksz * 8;
#line 169
  tmp___4 = 32;
#line 169
  (m___0->xxh)->smp = tmp___4;
#line 169
  (m___0->xxh)->ins = tmp___4;
  {
#line 170
  while (1) {
    while_continue___2: /* CIL Label */ ;
    {
#line 170
    tmp___5 = calloc((size_t )sizeof(struct xxm_instrument_header ), (size_t )(m___0->xxh)->ins);
#line 170
    m___0->xxih = (struct xxm_instrument_header *)tmp___5;
#line 170
    tmp___6 = calloc((size_t )sizeof(struct xxm_instrument_map ), (size_t )(m___0->xxh)->ins);
#line 170
    m___0->xxim = (struct xxm_instrument_map *)tmp___6;
#line 170
    tmp___7 = calloc((size_t )sizeof(struct xxm_instrument *), (size_t )(m___0->xxh)->ins);
#line 170
    m___0->xxi = (struct xxm_instrument **)tmp___7;
    }
#line 170
    if ((m___0->xxh)->smp) {
      {
#line 170
      tmp___8 = calloc((size_t )sizeof(struct xxm_sample ), (size_t )(m___0->xxh)->smp);
#line 170
      m___0->xxs = (struct xxm_sample *)tmp___8;
      }
    }
    {
#line 170
    tmp___9 = calloc((size_t )sizeof(uint16 *), (size_t )(m___0->xxh)->ins);
#line 170
    m___0->xxae = (uint16 **)tmp___9;
#line 170
    tmp___10 = calloc((size_t )sizeof(uint16 *), (size_t )(m___0->xxh)->ins);
#line 170
    m___0->xxpe = (uint16 **)tmp___10;
#line 170
    tmp___11 = calloc((size_t )sizeof(uint16 *), (size_t )(m___0->xxh)->ins);
#line 170
    m___0->xxfe = (uint16 **)tmp___11;
    }
#line 170
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 173
  i___3 = 0;
  {
#line 173
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 173
    if (! (i___3 < 32)) {
#line 173
      goto while_break___3;
    }
    {
#line 177
    tmp___12 = calloc((size_t )sizeof(struct xxm_instrument ), (size_t )1);
#line 177
    *(m___0->xxi + i___3) = (struct xxm_instrument *)tmp___12;
    }
#line 179
    if (~ mask & 2147483648U) {
#line 180
      goto __Cont;
    }
    {
#line 182
    c___0 = read8(f);
#line 184
    size___0 = read8(f);
#line 185
    j = 0;
    }
    {
#line 185
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 185
      if (! (j < (int )size___0)) {
#line 185
        goto while_break___4;
      }
      {
#line 186
      buf___2[j] = read8(f);
#line 185
      j ++;
      }
    }
    while_break___4: /* CIL Label */ ;
    }
#line 187
    buf___2[j] = (uint8 )0;
#line 189
    (m___0->xxs + i___3)->lps = 0;
#line 190
    loop_len = (uint16 )0;
#line 191
    (*(m___0->xxi + i___3) + 0)->vol = 64;
#line 200
    if (((int )c___0 & 1) == 0) {
      {
#line 201
      tmp___13 = read16b(f);
#line 201
      (m___0->xxs + i___3)->lps = (int )tmp___13 << 1;
      }
    }
#line 202
    if (((int )c___0 & 2) == 0) {
      {
#line 203
      tmp___14 = read16b(f);
#line 203
      loop_len = (uint16 )((int )tmp___14 << 1);
      }
    }
#line 204
    if (((int )c___0 & 48) == 0) {
      {
#line 205
      tmp___15 = read8(f);
#line 205
      (*(m___0->xxi + i___3) + 0)->vol = (int )tmp___15;
      }
    }
#line 207
    (m___0->xxs + i___3)->lpe = (m___0->xxs + i___3)->lps + (int )loop_len;
#line 208
    if ((int )loop_len > 0) {
#line 209
      (m___0->xxs + i___3)->flg |= 4;
    }
    {
#line 211
    copy_adjust((m___0->xxih + i___3)->name, buf___2, 32);
    }
    __Cont: /* CIL Label */ 
#line 173
    i___3 ++;
#line 173
    mask <<= 1;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 215
  tmp___16 = read16b(f);
#line 215
  (m___0->xxh)->pat = (int )tmp___16;
#line 216
  tmp___17 = read16b(f);
#line 216
  (m___0->xxh)->len = (int )tmp___17;
#line 217
  fread((void */* __restrict  */)(m___0->xxo), (size_t )1, (size_t )(m___0->xxh)->len,
        (FILE */* __restrict  */)f);
#line 218
  tmp___18 = read16b(f);
#line 218
  (m___0->xxh)->bpm = (125 * (int )tmp___18) / 33;
#line 219
  tmp___19 = read8s(f);
#line 219
  transp = (int )tmp___19;
#line 220
  read8s(f);
#line 221
  tmp___20 = read8s(f);
#line 221
  flags = (int )tmp___20;
#line 222
  tmp___21 = read8(f);
#line 222
  (m___0->xxh)->tpo = (int )tmp___21;
  }
#line 224
  if (~ flags & 32) {
#line 225
    m___0->quirk |= (1 << 13) | (1 << 15);
  }
#line 227
  if (flags & 16) {
#line 228
    hexvol = 1;
  }
#line 231
  if (vermaj == 2) {
#line 232
    if (flags & 32) {
#line 232
      (m___0->xxh)->tpo = 5;
    } else {
#line 232
      (m___0->xxh)->tpo = 6;
    }
  }
  {
#line 234
  fseek(f, 20L, 1);
#line 236
  fread((void */* __restrict  */)(trkvol), (size_t )1, (size_t )16, (FILE */* __restrict  */)f);
#line 237
  read8(f);
  }
  {
#line 239
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 239
    if (m___0->verbosity) {
#line 239
      if (m___0->name[0]) {
        {
#line 239
        report((char *)"Module title   : %s\n", m___0->name);
        }
      }
#line 239
      if (m___0->type[0]) {
        {
#line 239
        report((char *)"Module type    : %s\n", m___0->type);
        }
      }
#line 239
      if (m___0->author[0]) {
        {
#line 239
        report((char *)"Author name    : %s\n", m___0->author);
        }
      }
#line 239
      if ((m___0->xxh)->len) {
        {
#line 239
        report((char *)"Module length  : %d patterns\n", (m___0->xxh)->len);
        }
      }
    }
#line 239
    goto while_break___5;
  }
  while_break___5: /* CIL Label */ ;
  }
  {
#line 241
  reportv(ctx___0, 0, (char *)"Play transpose : %d semitones\n", transp);
#line 243
  i___3 = 0;
  }
  {
#line 243
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 243
    if (! (i___3 < 32)) {
#line 243
      goto while_break___6;
    }
#line 244
    (*(m___0->xxi + i___3) + 0)->xpo += transp;
#line 243
    i___3 ++;
  }
  while_break___6: /* CIL Label */ ;
  }
  {
#line 246
  read8(f);
#line 247
  tmp___22 = read8(f);
#line 247
  (m___0->xxh)->chn = (int )tmp___22;
#line 248
  fseek(f, -2L, 1);
#line 249
  (m___0->xxh)->trk = (m___0->xxh)->chn * (m___0->xxh)->pat;
  }
  {
#line 251
  while (1) {
    while_continue___7: /* CIL Label */ ;
    {
#line 251
    tmp___23 = calloc((size_t )sizeof(struct xxm_track *), (size_t )(m___0->xxh)->trk);
#line 251
    m___0->xxt = (struct xxm_track **)tmp___23;
#line 251
    tmp___24 = calloc((size_t )sizeof(struct xxm_pattern *), (size_t )((m___0->xxh)->pat + 1));
#line 251
    m___0->xxp = (struct xxm_pattern **)tmp___24;
    }
#line 251
    goto while_break___7;
  }
  while_break___7: /* CIL Label */ ;
  }
  {
#line 254
  reportv(ctx___0, 0, (char *)"Stored patterns: %d ", (m___0->xxh)->pat);
#line 256
  i___3 = 0;
  }
  {
#line 256
  while (1) {
    while_continue___8: /* CIL Label */ ;
#line 256
    if (! (i___3 < (m___0->xxh)->pat)) {
#line 256
      goto while_break___8;
    }
    {
#line 264
    tmp___25 = read8(f);
#line 264
    size___1 = (int )tmp___25;
#line 265
    chn = read8(f);
#line 266
    tmp___26 = read8(f);
#line 266
    rows___1 = (uint8 )((int )tmp___26 + 1);
#line 267
    tmp___27 = read16b(f);
#line 267
    plen = (int )tmp___27;
#line 268
    ctl = read8(f);
    }
    {
#line 270
    while (1) {
      while_continue___9: /* CIL Label */ ;
      {
#line 270
      tmp___28 = calloc((size_t )1, (size_t )(sizeof(struct xxm_pattern ) + sizeof(struct xxm_trackinfo ) * (unsigned long )((m___0->xxh)->chn - 1)));
#line 270
      *(m___0->xxp + i___3) = (struct xxm_pattern *)tmp___28;
      }
#line 270
      goto while_break___9;
    }
    while_break___9: /* CIL Label */ ;
    }
#line 271
    (*(m___0->xxp + i___3))->rows = (int )rows___1;
    {
#line 272
    while (1) {
      while_continue___10: /* CIL Label */ ;
#line 272
      j___0 = 0;
      {
#line 272
      while (1) {
        while_continue___11: /* CIL Label */ ;
#line 272
        if (! (j___0 < (m___0->xxh)->chn)) {
#line 272
          goto while_break___11;
        }
        {
#line 272
        (*(m___0->xxp + i___3))->info[j___0].index = i___3 * (m___0->xxh)->chn + j___0;
#line 272
        tmp___29 = calloc((size_t )(sizeof(struct xxm_track ) + sizeof(struct xxm_event ) * (unsigned long )(*(m___0->xxp + i___3))->rows),
                          (size_t )1);
#line 272
        *(m___0->xxt + (i___3 * (m___0->xxh)->chn + j___0)) = (struct xxm_track *)tmp___29;
#line 272
        (*(m___0->xxt + (i___3 * (m___0->xxh)->chn + j___0)))->rows = (*(m___0->xxp + i___3))->rows;
#line 272
        j___0 ++;
        }
      }
      while_break___11: /* CIL Label */ ;
      }
#line 272
      goto while_break___10;
    }
    while_break___10: /* CIL Label */ ;
    }
#line 274
    if ((int )ctl & 128) {
#line 274
      linemsk0 = (uint32 )(~ 0);
    } else {
#line 274
      if ((int )ctl & 64) {
#line 274
        tmp___31 = (uint32 )0;
      } else {
        {
#line 274
        tmp___30 = read32b(f);
#line 274
        tmp___31 = tmp___30;
        }
      }
#line 274
      linemsk0 = tmp___31;
    }
#line 275
    if ((int )ctl & 32) {
#line 275
      fxmsk0 = (uint32 )(~ 0);
    } else {
#line 275
      if ((int )ctl & 16) {
#line 275
        tmp___33 = (uint32 )0;
      } else {
        {
#line 275
        tmp___32 = read32b(f);
#line 275
        tmp___33 = tmp___32;
        }
      }
#line 275
      fxmsk0 = tmp___33;
    }
#line 276
    if ((int )ctl & 8) {
#line 276
      linemsk1 = (uint32 )(~ 0);
    } else {
#line 276
      if ((int )ctl & 4) {
#line 276
        tmp___35 = (uint32 )0;
      } else {
        {
#line 276
        tmp___34 = read32b(f);
#line 276
        tmp___35 = tmp___34;
        }
      }
#line 276
      linemsk1 = tmp___35;
    }
#line 277
    if ((int )ctl & 2) {
#line 277
      fxmsk1 = (uint32 )(~ 0);
    } else {
#line 277
      if ((int )ctl & 1) {
#line 277
        tmp___37 = (uint32 )0;
      } else {
        {
#line 277
        tmp___36 = read32b(f);
#line 277
        tmp___37 = tmp___36;
        }
      }
#line 277
      fxmsk1 = tmp___37;
    }
    {
#line 289
    tmp___38 = read8(f);
#line 289
    x = (uint32 )tmp___38;
#line 292
    read4_ctl = 0;
#line 294
    j = 0;
    }
    {
#line 294
    while (1) {
      while_continue___12: /* CIL Label */ ;
#line 294
      if (! (j < 32)) {
#line 294
        goto while_break___12;
      }
#line 295
      if (linemsk0 & 2147483648U) {
        {
#line 296
        chmsk = read4(f);
#line 297
        k = 0;
        }
        {
#line 297
        while (1) {
          while_continue___13: /* CIL Label */ ;
#line 297
          if (! (k < 4)) {
#line 297
            goto while_break___13;
          }
#line 298
          event = & (*(m___0->xxt + (*(m___0->xxp + i___3))->info[k].index))->event[j];
#line 300
          if ((int )chmsk & 8) {
            {
#line 301
            tmp___39 = read12b(f);
#line 301
            x = (uint32 )tmp___39;
#line 302
            event->note = (uint8 )(x >> 4);
            }
#line 303
            if (event->note) {
#line 304
              event->note = (uint8 )((int )event->note + 36);
            }
#line 305
            event->ins = (uint8 )(x & 15U);
          }
#line 297
          k ++;
#line 297
          chmsk = (uint8 )((int )chmsk << 1);
        }
        while_break___13: /* CIL Label */ ;
        }
      }
#line 310
      if (fxmsk0 & 2147483648U) {
        {
#line 311
        chmsk = read4(f);
#line 312
        k = 0;
        }
        {
#line 312
        while (1) {
          while_continue___14: /* CIL Label */ ;
#line 312
          if (! (k < 4)) {
#line 312
            goto while_break___14;
          }
#line 313
          event = & (*(m___0->xxt + (*(m___0->xxp + i___3))->info[k].index))->event[j];
#line 315
          if ((int )chmsk & 8) {
            {
#line 316
            tmp___40 = read12b(f);
#line 316
            x = (uint32 )tmp___40;
#line 317
            event->fxt = (uint8 )(x >> 8);
#line 318
            event->fxp = (uint8 )(x & 255U);
#line 319
            fix_effect___0(event);
            }
          }
#line 312
          k ++;
#line 312
          chmsk = (uint8 )((int )chmsk << 1);
        }
        while_break___14: /* CIL Label */ ;
        }
      }
#line 294
      j ++;
#line 294
      linemsk0 <<= 1;
#line 294
      fxmsk0 <<= 1;
    }
    while_break___12: /* CIL Label */ ;
    }
#line 337
    j = 32;
    {
#line 337
    while (1) {
      while_continue___15: /* CIL Label */ ;
#line 337
      if (! (j < 64)) {
#line 337
        goto while_break___15;
      }
#line 338
      if (linemsk1 & 2147483648U) {
        {
#line 339
        chmsk = read4(f);
#line 340
        k = 0;
        }
        {
#line 340
        while (1) {
          while_continue___16: /* CIL Label */ ;
#line 340
          if (! (k < 4)) {
#line 340
            goto while_break___16;
          }
#line 341
          event = & (*(m___0->xxt + (*(m___0->xxp + i___3))->info[k].index))->event[j];
#line 343
          if ((int )chmsk & 8) {
            {
#line 344
            tmp___41 = read12b(f);
#line 344
            x = (uint32 )tmp___41;
#line 345
            event->note = (uint8 )(x >> 4);
            }
#line 346
            if (event->note) {
#line 347
              event->note = (uint8 )((int )event->note + 36);
            }
#line 348
            event->ins = (uint8 )(x & 15U);
          }
#line 340
          k ++;
#line 340
          chmsk = (uint8 )((int )chmsk << 1);
        }
        while_break___16: /* CIL Label */ ;
        }
      }
#line 353
      if (fxmsk1 & 2147483648U) {
        {
#line 354
        chmsk = read4(f);
#line 355
        k = 0;
        }
        {
#line 355
        while (1) {
          while_continue___17: /* CIL Label */ ;
#line 355
          if (! (k < 4)) {
#line 355
            goto while_break___17;
          }
#line 356
          event = & (*(m___0->xxt + (*(m___0->xxp + i___3))->info[k].index))->event[j];
#line 358
          if ((int )chmsk & 8) {
            {
#line 359
            tmp___42 = read12b(f);
#line 359
            x = (uint32 )tmp___42;
#line 360
            event->fxt = (uint8 )(x >> 8);
#line 361
            event->fxp = (uint8 )(x & 255U);
#line 362
            fix_effect___0(event);
            }
          }
#line 355
          k ++;
#line 355
          chmsk = (uint8 )((int )chmsk << 1);
        }
        while_break___17: /* CIL Label */ ;
        }
      }
#line 337
      j ++;
#line 337
      linemsk1 <<= 1;
#line 337
      fxmsk1 <<= 1;
    }
    while_break___15: /* CIL Label */ ;
    }
    {
#line 380
    reportv(ctx___0, 0, (char *)".");
#line 256
    i___3 ++;
    }
  }
  while_break___8: /* CIL Label */ ;
  }
  {
#line 382
  reportv(ctx___0, 0, (char *)"\n");
#line 386
  reportv(ctx___0, 0, (char *)"Instruments    : %d ", (m___0->xxh)->ins);
#line 387
  reportv(ctx___0, 1, (char *)"\n     Instrument name                  Len  LBeg LEnd L Vol Xpo");
#line 389
  mask = read32b(f);
#line 391
  read16b(f);
#line 395
  mask <<= 1;
#line 396
  i___3 = 0;
  }
  {
#line 396
  while (1) {
    while_continue___18: /* CIL Label */ ;
#line 396
    if (! (i___3 < 32)) {
#line 396
      goto while_break___18;
    }
#line 397
    if (~ mask & 2147483648U) {
#line 398
      goto __Cont___0;
    }
    {
#line 400
    read16b(f);
#line 401
    read16b(f);
#line 402
    tmp___43 = read16b(f);
#line 402
    (m___0->xxs + i___3)->len = (int )tmp___43;
#line 404
    (*(m___0->xxi + i___3) + 0)->sid = i___3;
#line 405
    (m___0->xxih + i___3)->nsm = ! (! (m___0->xxs + i___3)->len);
    }
#line 407
    if ((m___0->xxs + i___3)->flg & 4) {
#line 407
      tmp___44 = 'L';
    } else {
#line 407
      tmp___44 = ' ';
    }
    {
#line 407
    reportv(ctx___0, 1, (char *)"\n[%2X] %-32.32s %04x %04x %04x %c V%02x %+03d ",
            i___3, (m___0->xxih + i___3)->name, (m___0->xxs + i___3)->len, (m___0->xxs + i___3)->lps,
            (m___0->xxs + i___3)->lpe, tmp___44, (*(m___0->xxi + i___3) + 0)->vol,
            (*(m___0->xxi + i___3) + 0)->xpo);
#line 413
    xmp_drv_loadpatch(ctx___0, f, (*(m___0->xxi + i___3) + 0)->sid, m___0->c4rate,
                      0, m___0->xxs + (*(m___0->xxi + i___3) + 0)->sid, (char *)((void *)0));
#line 415
    reportv(ctx___0, 0, (char *)".");
    }
    __Cont___0: /* CIL Label */ 
#line 396
    i___3 ++;
#line 396
    mask <<= 1;
  }
  while_break___18: /* CIL Label */ ;
  }
  {
#line 417
  reportv(ctx___0, 0, (char *)"\n");
  }
#line 419
  return (0);
}
}
#line 26 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/med3_load.c"
static int med3_test(FILE *f , char *t , int const   start ) ;
#line 27
static int med3_load(struct xmp_context *ctx___0 , FILE *f , int const   start ) ;
#line 29 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/med3_load.c"
struct xmp_loader_info med3_loader  =    {(char *)"MED3", (char *)"MED 2.00", & med3_test, & med3_load, 0, {(struct list_head *)0,
                                                                      (struct list_head *)0}};
#line 36 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/med3_load.c"
static int med3_test(FILE *f , char *t , int const   start ) 
{ 
  uint32 tmp ;

  {
  {
#line 38
  tmp = read32b(f);
  }
#line 38
  if (tmp != ((((77U << 24) | (69U << 16)) | (68U << 8)) | 3U)) {
#line 39
    return (-1);
  }
  {
#line 41
  read_title(f, t, 0);
  }
#line 43
  return (0);
}
}
#line 64 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/med3_load.c"
static uint8 get_nibble(uint8 *mem , uint16 *nbnum ) 
{ 
  uint8 *mloc ;
  uint8 res ;

  {
#line 66
  mloc = mem + (int )*nbnum / 2;
#line 68
  if ((int )*nbnum & 1) {
#line 69
    res = (uint8 )((int )*mloc & 15);
  } else {
#line 71
    res = (uint8 )((int )*mloc >> 4);
  }
#line 72
  *nbnum = (uint16 )((int )*nbnum + 1);
#line 74
  return (res);
}
}
#line 77 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/med3_load.c"
static uint16 get_nibbles(uint8 *mem , uint16 *nbnum , uint8 nbs ) 
{ 
  uint16 res ;
  uint8 tmp ;
  uint8 tmp___0 ;

  {
#line 79
  res = (uint16 )0;
  {
#line 81
  while (1) {
    while_continue: /* CIL Label */ ;
#line 81
    tmp___0 = nbs;
#line 81
    nbs = (uint8 )((int )nbs - 1);
#line 81
    if (! tmp___0) {
#line 81
      goto while_break;
    }
    {
#line 82
    res = (uint16 )((int )res << 4);
#line 83
    tmp = get_nibble(mem, nbnum);
#line 83
    res = (uint16 )((int )res | (int )tmp);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 86
  return (res);
}
}
#line 89 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/med3_load.c"
static void unpack_block(struct xmp_context *ctx___0 , uint16 bnum , uint8 *from ) 
{ 
  struct xmp_player_context *p ;
  struct xmp_mod_context *m___0 ;
  struct xxm_event *event ;
  uint32 linemsk0 ;
  uint32 linemsk1 ;
  uint32 fxmsk0 ;
  uint32 fxmsk1 ;
  uint32 *lmptr ;
  uint32 *fxptr ;
  uint16 fromn ;
  uint16 lmsk ;
  uint8 *fromst ;
  uint8 bcnt ;
  uint8 *tmpto ;
  uint8 *patbuf ;
  uint8 *to ;
  int i___3 ;
  int j ;
  int trkn ;
  void *tmp ;
  uint16 tmp___0 ;
  uint8 tmp___1 ;
  uint8 tmp___2 ;
  uint16 tmp___3 ;
  uint8 tmp___4 ;
  uint8 tmp___5 ;
  uint8 tmp___6 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;

  {
  {
#line 91
  p = & ctx___0->p;
#line 92
  m___0 = & p->m;
#line 94
  linemsk0 = *((uint32 *)from);
#line 94
  linemsk1 = *((uint32 *)from + 1);
#line 95
  fxmsk0 = *((uint32 *)from + 2);
#line 95
  fxmsk1 = *((uint32 *)from + 3);
#line 96
  lmptr = & linemsk0;
#line 96
  fxptr = & fxmsk0;
#line 97
  fromn = (uint16 )0;
#line 98
  fromst = from + 16;
#line 100
  trkn = (m___0->xxh)->chn;
#line 102
  from += 16;
#line 103
  tmp = calloc((size_t )3, (size_t )256);
#line 103
  to = (uint8 *)tmp;
#line 103
  patbuf = to;
  }
#line 104
  if (! to) {
    {
#line 104
    __assert_fail("to", "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/med3_load.c",
                  104U, "unpack_block");
    }
  }
#line 106
  i___3 = 0;
  {
#line 106
  while (1) {
    while_continue: /* CIL Label */ ;
#line 106
    if (! (i___3 < 64)) {
#line 106
      goto while_break;
    }
#line 107
    if (i___3 == 32) {
#line 108
      lmptr = & linemsk1;
#line 109
      fxptr = & fxmsk1;
    }
#line 112
    if (*lmptr & 2147483648U) {
      {
#line 113
      lmsk = get_nibbles(fromst, & fromn, (uint8 )(trkn / 4));
#line 114
      lmsk = (uint16 )((int )lmsk << (16 - trkn));
#line 115
      tmpto = to;
#line 117
      bcnt = (uint8 )0;
      }
      {
#line 117
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 117
        if (! ((int )bcnt < trkn)) {
#line 117
          goto while_break___0;
        }
#line 118
        if ((int )lmsk & 32768) {
          {
#line 119
          tmp___0 = get_nibbles(fromst, & fromn, (uint8 )2);
#line 119
          *tmpto = (uint8 )tmp___0;
#line 121
          tmp___1 = get_nibble(fromst, & fromn);
#line 121
          *(tmpto + 1) = (uint8 )((int )tmp___1 << 4);
          }
        }
#line 124
        lmsk = (uint16 )((int )lmsk << 1);
#line 125
        tmpto += 3;
#line 117
        bcnt = (uint8 )((int )bcnt + 1);
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 129
    if (*fxptr & 2147483648U) {
      {
#line 130
      lmsk = get_nibbles(fromst, & fromn, (uint8 )(trkn / 4));
#line 131
      lmsk = (uint16 )((int )lmsk << (16 - trkn));
#line 132
      tmpto = to;
#line 134
      bcnt = (uint8 )0;
      }
      {
#line 134
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 134
        if (! ((int )bcnt < trkn)) {
#line 134
          goto while_break___1;
        }
#line 135
        if ((int )lmsk & 32768) {
          {
#line 136
          tmp___2 = get_nibble(fromst, & fromn);
#line 136
          *(tmpto + 1) = (uint8 )((int )*(tmpto + 1) | (int )tmp___2);
#line 138
          tmp___3 = get_nibbles(fromst, & fromn, (uint8 )2);
#line 138
          *(tmpto + 2) = (uint8 )tmp___3;
          }
        }
#line 141
        lmsk = (uint16 )((int )lmsk << 1);
#line 142
        tmpto += 3;
#line 134
        bcnt = (uint8 )((int )bcnt + 1);
      }
      while_break___1: /* CIL Label */ ;
      }
    }
#line 145
    to += 3 * trkn;
#line 146
    *lmptr <<= 1;
#line 147
    *fxptr <<= 1;
#line 106
    i___3 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 150
  i___3 = 0;
  {
#line 150
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 150
    if (! (i___3 < 64)) {
#line 150
      goto while_break___2;
    }
#line 151
    j = 0;
    {
#line 151
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 151
      if (! (j < 4)) {
#line 151
        goto while_break___3;
      }
#line 152
      event = & (*(m___0->xxt + (*(m___0->xxp + bnum))->info[j].index))->event[i___3];
#line 154
      event->note = *(patbuf + (i___3 * 12 + j * 3));
#line 155
      if (event->note) {
#line 156
        event->note = (uint8 )((int )event->note + 36);
      }
#line 157
      event->ins = (uint8 )((int )*(patbuf + ((i___3 * 12 + j * 3) + 1)) >> 4);
#line 158
      if (event->ins) {
#line 159
        event->ins = (uint8 )((int )event->ins + 1);
      }
#line 160
      event->fxt = (uint8 )((int )*(patbuf + ((i___3 * 12 + j * 3) + 1)) & 15);
#line 161
      event->fxp = *(patbuf + ((i___3 * 12 + j * 3) + 2));
      {
#line 166
      if ((int )event->fxt == 2) {
#line 166
        goto case_2;
      }
#line 166
      if ((int )event->fxt == 1) {
#line 166
        goto case_2;
      }
#line 166
      if ((int )event->fxt == 0) {
#line 166
        goto case_2;
      }
#line 168
      if ((int )event->fxt == 3) {
#line 168
        goto case_3;
      }
#line 171
      if ((int )event->fxt == 12) {
#line 171
        goto case_12;
      }
#line 175
      if ((int )event->fxt == 13) {
#line 175
        goto case_13;
      }
#line 178
      if ((int )event->fxt == 15) {
#line 178
        goto case_15;
      }
#line 200
      goto switch_default;
      case_2: /* CIL Label */ 
      case_1: /* CIL Label */ 
      case_0: /* CIL Label */ 
#line 167
      goto switch_break;
      case_3: /* CIL Label */ 
#line 169
      event->fxt = (uint8 )4;
#line 170
      goto switch_break;
      case_12: /* CIL Label */ 
#line 172
      event->fxp = (uint8 )((((int )event->fxp & 240) >> 4) * 10 + ((int )event->fxp & 15));
#line 174
      goto switch_break;
      case_13: /* CIL Label */ 
#line 176
      event->fxt = (uint8 )10;
#line 177
      goto switch_break;
      case_15: /* CIL Label */ 
#line 179
      if ((int )event->fxp == 0) {
#line 180
        event->fxt = (uint8 )13;
      }
#line 181
      if ((int )event->fxp == 255) {
#line 182
        tmp___4 = (uint8 )0;
#line 182
        event->fxt = tmp___4;
#line 182
        event->fxp = tmp___4;
#line 183
        event->vol = (uint8 )1;
      } else
#line 184
      if ((int )event->fxp == 254) {
#line 185
        tmp___5 = (uint8 )0;
#line 185
        event->fxt = tmp___5;
#line 185
        event->fxp = tmp___5;
      } else
#line 186
      if ((int )event->fxp == 241) {
#line 187
        event->fxt = (uint8 )14;
#line 188
        event->fxp = (uint8 )((9 << 4) | 3);
      } else
#line 189
      if ((int )event->fxp == 242) {
#line 190
        event->fxt = (uint8 )14;
#line 191
        event->fxp = (uint8 )((12 << 4) | 3);
      } else
#line 192
      if ((int )event->fxp == 243) {
#line 193
        event->fxt = (uint8 )14;
#line 194
        event->fxp = (uint8 )((13 << 4) | 3);
      } else
#line 195
      if ((int )event->fxp > 10) {
#line 196
        event->fxt = (uint8 )171;
#line 197
        event->fxp = (uint8 )((125 * (int )event->fxp) / 33);
      }
#line 199
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 201
      tmp___6 = (uint8 )0;
#line 201
      event->fxt = tmp___6;
#line 201
      event->fxp = tmp___6;
      switch_break: /* CIL Label */ ;
      }
#line 151
      j ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 150
    i___3 ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 206
  free((void *)patbuf);
  }
#line 207
  return;
}
}
#line 210 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/med3_load.c"
static int med3_load(struct xmp_context *ctx___0 , FILE *f , int const   start ) 
{ 
  struct xmp_player_context *p ;
  struct xmp_mod_context *m___0 ;
  int i___3 ;
  int j ;
  uint32 mask ;
  int transp ;
  int sliding ;
  uint8 **tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  uint8 c___0 ;
  uint8 buf___1[40] ;
  void *tmp___8 ;
  uint8 tmp___9 ;
  uint16 tmp___10 ;
  uint32 lsiz ;
  uint16 tmp___11 ;
  int tmp___12 ;
  uint16 tmp___13 ;
  uint16 tmp___14 ;
  uint16 tmp___15 ;
  int8 tmp___16 ;
  uint16 tmp___17 ;
  void *tmp___18 ;
  void *tmp___19 ;
  uint32 *conv ;
  uint8 b___1 ;
  uint8 tracks ;
  uint16 convsz ;
  void *tmp___20 ;
  int j___0 ;
  void *tmp___21 ;
  void *tmp___22 ;
  uint32 tmp___23 ;
  uint16 tmp___24 ;
  int tmp___25 ;
  void *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;

  {
#line 212
  p = & ctx___0->p;
#line 213
  m___0 = & p->m;
  {
#line 218
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 218
    fseek(f, (long )start, 0);
#line 218
    tmp = (uint8 **)((void *)0);
#line 218
    m___0->med_wav_table = tmp;
#line 218
    m___0->med_vol_table = tmp;
#line 218
    set_xxh_defaults(m___0->xxh);
    }
#line 218
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 220
  read32b(f);
#line 222
  strcpy((char */* __restrict  */)(m___0->type), (char const   */* __restrict  */)"MED3 (MED 2.00)");
#line 224
  tmp___0 = 32;
#line 224
  (m___0->xxh)->smp = tmp___0;
#line 224
  (m___0->xxh)->ins = tmp___0;
  }
  {
#line 225
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 225
    tmp___1 = calloc((size_t )sizeof(struct xxm_instrument_header ), (size_t )(m___0->xxh)->ins);
#line 225
    m___0->xxih = (struct xxm_instrument_header *)tmp___1;
#line 225
    tmp___2 = calloc((size_t )sizeof(struct xxm_instrument_map ), (size_t )(m___0->xxh)->ins);
#line 225
    m___0->xxim = (struct xxm_instrument_map *)tmp___2;
#line 225
    tmp___3 = calloc((size_t )sizeof(struct xxm_instrument *), (size_t )(m___0->xxh)->ins);
#line 225
    m___0->xxi = (struct xxm_instrument **)tmp___3;
    }
#line 225
    if ((m___0->xxh)->smp) {
      {
#line 225
      tmp___4 = calloc((size_t )sizeof(struct xxm_sample ), (size_t )(m___0->xxh)->smp);
#line 225
      m___0->xxs = (struct xxm_sample *)tmp___4;
      }
    }
    {
#line 225
    tmp___5 = calloc((size_t )sizeof(uint16 *), (size_t )(m___0->xxh)->ins);
#line 225
    m___0->xxae = (uint16 **)tmp___5;
#line 225
    tmp___6 = calloc((size_t )sizeof(uint16 *), (size_t )(m___0->xxh)->ins);
#line 225
    m___0->xxpe = (uint16 **)tmp___6;
#line 225
    tmp___7 = calloc((size_t )sizeof(uint16 *), (size_t )(m___0->xxh)->ins);
#line 225
    m___0->xxfe = (uint16 **)tmp___7;
    }
#line 225
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 228
  i___3 = 0;
  {
#line 228
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 228
    if (! (i___3 < 32)) {
#line 228
      goto while_break___1;
    }
#line 230
    j = 0;
    {
#line 230
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 230
      if (! (j < 40)) {
#line 230
        goto while_break___2;
      }
      {
#line 231
      c___0 = read8(f);
#line 232
      buf___1[j] = c___0;
      }
#line 233
      if ((int )c___0 == 0) {
#line 234
        goto while_break___2;
      }
#line 230
      j ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 236
    copy_adjust((m___0->xxih + i___3)->name, buf___1, 32);
#line 237
    tmp___8 = calloc((size_t )sizeof(struct xxm_instrument ), (size_t )1);
#line 237
    *(m___0->xxi + i___3) = (struct xxm_instrument *)tmp___8;
#line 228
    i___3 ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 241
  mask = read32b(f);
#line 242
  i___3 = 0;
  }
  {
#line 242
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 242
    if (! (i___3 < 32)) {
#line 242
      goto while_break___3;
    }
#line 243
    if (mask & 2147483648U) {
      {
#line 243
      tmp___9 = read8(f);
#line 243
      (*(m___0->xxi + i___3) + 0)->vol = (int )tmp___9;
      }
    } else {
#line 243
      (*(m___0->xxi + i___3) + 0)->vol = 0;
    }
#line 244
    (*(m___0->xxi + i___3) + 0)->pan = 128;
#line 245
    (*(m___0->xxi + i___3) + 0)->fin = 0;
#line 246
    (*(m___0->xxi + i___3) + 0)->sid = i___3;
#line 242
    i___3 ++;
#line 242
    mask <<= 1;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 250
  mask = read32b(f);
#line 251
  i___3 = 0;
  }
  {
#line 251
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 251
    if (! (i___3 < 32)) {
#line 251
      goto while_break___4;
    }
#line 252
    if (mask & 2147483648U) {
      {
#line 252
      tmp___10 = read16b(f);
#line 252
      (m___0->xxs + i___3)->lps = (int )tmp___10;
      }
    } else {
#line 252
      (m___0->xxs + i___3)->lps = 0;
    }
#line 251
    i___3 ++;
#line 251
    mask <<= 1;
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 256
  mask = read32b(f);
#line 257
  i___3 = 0;
  }
  {
#line 257
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 257
    if (! (i___3 < 32)) {
#line 257
      goto while_break___5;
    }
#line 258
    if (mask & 2147483648U) {
      {
#line 258
      tmp___11 = read16b(f);
#line 258
      tmp___12 = (int )tmp___11;
      }
    } else {
#line 258
      tmp___12 = 0;
    }
#line 258
    lsiz = (uint32 )tmp___12;
#line 259
    (m___0->xxs + i___3)->len = (int )((uint32 )(m___0->xxs + i___3)->lps + lsiz);
#line 260
    (m___0->xxs + i___3)->lpe = (int )((uint32 )(m___0->xxs + i___3)->lps + lsiz);
#line 261
    if (lsiz > 1U) {
#line 261
      (m___0->xxs + i___3)->flg = 4;
    } else {
#line 261
      (m___0->xxs + i___3)->flg = 0;
    }
#line 257
    i___3 ++;
#line 257
    mask <<= 1;
  }
  while_break___5: /* CIL Label */ ;
  }
  {
#line 264
  (m___0->xxh)->chn = 4;
#line 265
  tmp___13 = read16b(f);
#line 265
  (m___0->xxh)->pat = (int )tmp___13;
#line 266
  (m___0->xxh)->trk = (m___0->xxh)->chn * (m___0->xxh)->pat;
#line 268
  tmp___14 = read16b(f);
#line 268
  (m___0->xxh)->len = (int )tmp___14;
#line 269
  fread((void */* __restrict  */)(m___0->xxo), (size_t )1, (size_t )(m___0->xxh)->len,
        (FILE */* __restrict  */)f);
#line 270
  tmp___15 = read16b(f);
#line 270
  (m___0->xxh)->tpo = (int )tmp___15;
  }
#line 271
  if ((m___0->xxh)->tpo > 10) {
#line 272
    (m___0->xxh)->bpm = (125 * (m___0->xxh)->tpo) / 33;
#line 273
    (m___0->xxh)->tpo = 6;
  }
  {
#line 275
  tmp___16 = read8s(f);
#line 275
  transp = (int )tmp___16;
#line 276
  read8(f);
#line 277
  tmp___17 = read16b(f);
#line 277
  sliding = (int )tmp___17;
#line 278
  read32b(f);
#line 279
  fseek(f, 16L, 1);
#line 282
  mask = read32b(f);
#line 283
  i___3 = 0;
  }
  {
#line 283
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 283
    if (! (i___3 < 32)) {
#line 283
      goto while_break___6;
    }
#line 284
    if (mask & 2147483648U) {
      {
#line 285
      read8(f);
      }
    }
#line 283
    i___3 ++;
#line 283
    mask <<= 1;
  }
  while_break___6: /* CIL Label */ ;
  }
  {
#line 289
  mask = read32b(f);
#line 290
  i___3 = 0;
  }
  {
#line 290
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 290
    if (! (i___3 < 32)) {
#line 290
      goto while_break___7;
    }
#line 291
    if (mask & 2147483648U) {
      {
#line 292
      read8(f);
      }
    }
#line 290
    i___3 ++;
#line 290
    mask <<= 1;
  }
  while_break___7: /* CIL Label */ ;
  }
  {
#line 295
  while (1) {
    while_continue___8: /* CIL Label */ ;
#line 295
    if (m___0->verbosity) {
#line 295
      if (m___0->name[0]) {
        {
#line 295
        report((char *)"Module title   : %s\n", m___0->name);
        }
      }
#line 295
      if (m___0->type[0]) {
        {
#line 295
        report((char *)"Module type    : %s\n", m___0->type);
        }
      }
#line 295
      if (m___0->author[0]) {
        {
#line 295
        report((char *)"Author name    : %s\n", m___0->author);
        }
      }
#line 295
      if ((m___0->xxh)->len) {
        {
#line 295
        report((char *)"Module length  : %d patterns\n", (m___0->xxh)->len);
        }
      }
    }
#line 295
    goto while_break___8;
  }
  while_break___8: /* CIL Label */ ;
  }
  {
#line 297
  reportv(ctx___0, 0, (char *)"Sliding        : %d\n", sliding);
#line 298
  reportv(ctx___0, 0, (char *)"Play transpose : %d semitones\n", transp);
  }
#line 300
  if (sliding == 6) {
#line 301
    m___0->quirk |= (1 << 13) | (1 << 15);
  }
#line 303
  i___3 = 0;
  {
#line 303
  while (1) {
    while_continue___9: /* CIL Label */ ;
#line 303
    if (! (i___3 < 32)) {
#line 303
      goto while_break___9;
    }
#line 304
    (*(m___0->xxi + i___3) + 0)->xpo = transp;
#line 303
    i___3 ++;
  }
  while_break___9: /* CIL Label */ ;
  }
  {
#line 306
  while (1) {
    while_continue___10: /* CIL Label */ ;
    {
#line 306
    tmp___18 = calloc((size_t )sizeof(struct xxm_track *), (size_t )(m___0->xxh)->trk);
#line 306
    m___0->xxt = (struct xxm_track **)tmp___18;
#line 306
    tmp___19 = calloc((size_t )sizeof(struct xxm_pattern *), (size_t )((m___0->xxh)->pat + 1));
#line 306
    m___0->xxp = (struct xxm_pattern **)tmp___19;
    }
#line 306
    goto while_break___10;
  }
  while_break___10: /* CIL Label */ ;
  }
  {
#line 309
  reportv(ctx___0, 0, (char *)"Stored patterns: %d ", (m___0->xxh)->pat);
#line 311
  i___3 = 0;
  }
  {
#line 311
  while (1) {
    while_continue___11: /* CIL Label */ ;
#line 311
    if (! (i___3 < (m___0->xxh)->pat)) {
#line 311
      goto while_break___11;
    }
    {
#line 316
    while (1) {
      while_continue___12: /* CIL Label */ ;
      {
#line 316
      tmp___20 = calloc((size_t )1, (size_t )(sizeof(struct xxm_pattern ) + sizeof(struct xxm_trackinfo ) * (unsigned long )((m___0->xxh)->chn - 1)));
#line 316
      *(m___0->xxp + i___3) = (struct xxm_pattern *)tmp___20;
      }
#line 316
      goto while_break___12;
    }
    while_break___12: /* CIL Label */ ;
    }
#line 317
    (*(m___0->xxp + i___3))->rows = 64;
    {
#line 318
    while (1) {
      while_continue___13: /* CIL Label */ ;
#line 318
      j___0 = 0;
      {
#line 318
      while (1) {
        while_continue___14: /* CIL Label */ ;
#line 318
        if (! (j___0 < (m___0->xxh)->chn)) {
#line 318
          goto while_break___14;
        }
        {
#line 318
        (*(m___0->xxp + i___3))->info[j___0].index = i___3 * (m___0->xxh)->chn + j___0;
#line 318
        tmp___21 = calloc((size_t )(sizeof(struct xxm_track ) + sizeof(struct xxm_event ) * (unsigned long )(*(m___0->xxp + i___3))->rows),
                          (size_t )1);
#line 318
        *(m___0->xxt + (i___3 * (m___0->xxh)->chn + j___0)) = (struct xxm_track *)tmp___21;
#line 318
        (*(m___0->xxt + (i___3 * (m___0->xxh)->chn + j___0)))->rows = (*(m___0->xxp + i___3))->rows;
#line 318
        j___0 ++;
        }
      }
      while_break___14: /* CIL Label */ ;
      }
#line 318
      goto while_break___13;
    }
    while_break___13: /* CIL Label */ ;
    }
    {
#line 320
    tracks = read8(f);
#line 322
    b___1 = read8(f);
#line 323
    convsz = read16b(f);
#line 324
    tmp___22 = calloc((size_t )1, (size_t )((int )convsz + 16));
#line 324
    conv = (uint32 *)tmp___22;
    }
#line 325
    if (! conv) {
      {
#line 325
      __assert_fail("conv", "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/med3_load.c",
                    325U, "med3_load");
      }
    }
#line 327
    if ((int )b___1 & 16) {
#line 328
      *conv = (uint32 )0L;
    } else
#line 329
    if ((int )b___1 & 1) {
#line 330
      *conv = 4294967295U;
    } else {
      {
#line 332
      *conv = read32b(f);
      }
    }
#line 334
    if ((int )b___1 & 32) {
#line 335
      *(conv + 1) = (uint32 )0L;
    } else
#line 336
    if ((int )b___1 & 2) {
#line 337
      *(conv + 1) = 4294967295U;
    } else {
      {
#line 339
      *(conv + 1) = read32b(f);
      }
    }
#line 341
    if ((int )b___1 & 64) {
#line 342
      *(conv + 2) = (uint32 )0L;
    } else
#line 343
    if ((int )b___1 & 4) {
#line 344
      *(conv + 2) = 4294967295U;
    } else {
      {
#line 346
      *(conv + 2) = read32b(f);
      }
    }
#line 348
    if ((int )b___1 & 128) {
#line 349
      *(conv + 3) = (uint32 )0L;
    } else
#line 350
    if ((int )b___1 & 8) {
#line 351
      *(conv + 3) = 4294967295U;
    } else {
      {
#line 353
      *(conv + 3) = read32b(f);
      }
    }
    {
#line 355
    fread((void */* __restrict  */)(conv + 4), (size_t )1, (size_t )convsz, (FILE */* __restrict  */)f);
#line 357
    unpack_block(ctx___0, (uint16 )i___3, (uint8 *)conv);
#line 359
    free((void *)conv);
#line 361
    reportv(ctx___0, 0, (char *)".");
#line 311
    i___3 ++;
    }
  }
  while_break___11: /* CIL Label */ ;
  }
  {
#line 363
  reportv(ctx___0, 0, (char *)"\n");
#line 367
  reportv(ctx___0, 0, (char *)"Instruments    : %d ", (m___0->xxh)->ins);
#line 368
  reportv(ctx___0, 1, (char *)"\n     Instrument name                  Len  LBeg LEnd L Vol");
#line 370
  mask = read32b(f);
#line 371
  i___3 = 0;
  }
  {
#line 371
  while (1) {
    while_continue___15: /* CIL Label */ ;
#line 371
    if (! (i___3 < 32)) {
#line 371
      goto while_break___15;
    }
#line 372
    if (~ mask & 2147483648U) {
#line 373
      goto __Cont;
    }
    {
#line 375
    tmp___23 = read32b(f);
#line 375
    (m___0->xxs + i___3)->len = (int )tmp___23;
#line 376
    tmp___24 = read16b(f);
    }
#line 376
    if (tmp___24) {
#line 377
      goto __Cont;
    }
#line 379
    (m___0->xxih + i___3)->nsm = ! (! (m___0->xxs + i___3)->len);
#line 381
    if ((m___0->xxs + i___3)->flg & 4) {
#line 381
      tmp___25 = 'L';
    } else {
#line 381
      tmp___25 = ' ';
    }
    {
#line 381
    reportv(ctx___0, 1, (char *)"\n[%2X] %-32.32s %04x %04x %04x %c V%02x ", i___3,
            (m___0->xxih + i___3)->name, (m___0->xxs + i___3)->len, (m___0->xxs + i___3)->lps,
            (m___0->xxs + i___3)->lpe, tmp___25, (*(m___0->xxi + i___3) + 0)->vol);
#line 387
    xmp_drv_loadpatch(ctx___0, f, (*(m___0->xxi + i___3) + 0)->sid, m___0->c4rate,
                      0, m___0->xxs + (*(m___0->xxi + i___3) + 0)->sid, (char *)((void *)0));
#line 389
    reportv(ctx___0, 0, (char *)".");
    }
    __Cont: /* CIL Label */ 
#line 371
    i___3 ++;
#line 371
    mask <<= 1;
  }
  while_break___15: /* CIL Label */ ;
  }
  {
#line 391
  reportv(ctx___0, 0, (char *)"\n");
  }
#line 393
  return (0);
}
}
#line 20 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/mgt_load.c"
static int mgt_test(FILE *f , char *t , int const   start ) ;
#line 21
static int mgt_load(struct xmp_context *ctx___0 , FILE *f , int const   start ) ;
#line 23 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/mgt_load.c"
struct xmp_loader_info mgt_loader  =    {(char *)"MGT", (char *)"Megatracker", & mgt_test, & mgt_load, 0, {(struct list_head *)0,
                                                                      (struct list_head *)0}};
#line 30 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/mgt_load.c"
static int mgt_test(FILE *f , char *t , int const   start ) 
{ 
  int sng_ptr ;
  uint32 tmp ;
  uint32 tmp___0 ;
  uint32 tmp___1 ;

  {
  {
#line 34
  tmp = read24b(f);
  }
#line 34
  if (tmp != (((77U << 16) | (71U << 8)) | 84U)) {
#line 35
    return (-1);
  }
  {
#line 36
  read8(f);
#line 37
  tmp___0 = read32b(f);
  }
#line 37
  if (tmp___0 != ((((189U << 24) | (77U << 16)) | (67U << 8)) | 83U)) {
#line 38
    return (-1);
  }
  {
#line 40
  fseek(f, 18L, 1);
#line 41
  tmp___1 = read32b(f);
#line 41
  sng_ptr = (int )tmp___1;
#line 42
  fseek(f, (long )(start + (int const   )sng_ptr), 0);
#line 44
  read_title(f, t, 32);
  }
#line 46
  return (0);
}
}
#line 49 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/mgt_load.c"
static int mgt_load(struct xmp_context *ctx___0 , FILE *f , int const   start ) 
{ 
  struct xmp_player_context *p ;
  struct xmp_mod_context *m___0 ;
  struct xxm_event *event ;
  int i___3 ;
  int j ;
  int ver___0 ;
  int sng_ptr ;
  int seq_ptr ;
  int ins_ptr ;
  int pat_ptr ;
  int trk_ptr ;
  int smp_ptr ;
  int sdata[64] ;
  uint8 **tmp ;
  uint8 tmp___0 ;
  uint16 tmp___1 ;
  uint16 tmp___2 ;
  uint16 tmp___3 ;
  uint16 tmp___4 ;
  int tmp___5 ;
  uint16 tmp___6 ;
  uint32 tmp___7 ;
  uint32 tmp___8 ;
  uint32 tmp___9 ;
  uint32 tmp___10 ;
  uint32 tmp___11 ;
  uint32 tmp___12 ;
  uint32 tmp___13 ;
  uint16 tmp___14 ;
  uint16 tmp___15 ;
  uint8 tmp___16 ;
  uint8 tmp___17 ;
  uint16 tmp___18 ;
  void *tmp___19 ;
  void *tmp___20 ;
  void *tmp___21 ;
  void *tmp___22 ;
  void *tmp___23 ;
  void *tmp___24 ;
  void *tmp___25 ;
  int c2spd___0 ;
  int flags ;
  void *tmp___26 ;
  uint32 tmp___27 ;
  uint32 tmp___28 ;
  uint32 tmp___29 ;
  uint32 tmp___30 ;
  uint32 tmp___31 ;
  uint16 tmp___32 ;
  uint8 tmp___33 ;
  int tmp___34 ;
  uint8 tmp___35 ;
  int tmp___36 ;
  int tmp___37 ;
  size_t tmp___38 ;
  void *tmp___39 ;
  void *tmp___40 ;
  int offset ;
  int rows___1 ;
  uint8 b___1 ;
  uint32 tmp___41 ;
  uint16 tmp___42 ;
  void *tmp___43 ;
  uint8 note ;
  uint8 f2p ;
  uint8 tmp___44 ;
  void *tmp___45 ;
  void *tmp___46 ;
  uint16 tmp___47 ;
  uint16 tmp___48 ;
  void *__cil_tmp74 ;
  char *__cil_tmp75 ;
  char *__cil_tmp76 ;
  char *__cil_tmp77 ;
  char *__cil_tmp78 ;
  char *__cil_tmp79 ;
  char *__cil_tmp80 ;
  char *__cil_tmp81 ;
  char *__cil_tmp82 ;
  char *__cil_tmp83 ;
  char *__cil_tmp84 ;
  char *__cil_tmp85 ;
  char *__cil_tmp86 ;
  char *__cil_tmp87 ;
  char *__cil_tmp88 ;
  char *__cil_tmp89 ;
  char *__cil_tmp90 ;

  {
#line 51
  p = & ctx___0->p;
#line 52
  m___0 = & p->m;
  {
#line 59
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 59
    fseek(f, (long )start, 0);
#line 59
    tmp = (uint8 **)((void *)0);
#line 59
    m___0->med_wav_table = tmp;
#line 59
    m___0->med_vol_table = tmp;
#line 59
    set_xxh_defaults(m___0->xxh);
    }
#line 59
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 61
  read24b(f);
#line 62
  tmp___0 = read8(f);
#line 62
  ver___0 = (int )tmp___0;
#line 63
  read32b(f);
#line 65
  sprintf((char */* __restrict  */)(m___0->type), (char const   */* __restrict  */)"MGT v%d.%d (Megatracker)",
          (ver___0 & 240) >> 4, ver___0 & 15);
#line 67
  tmp___1 = read16b(f);
#line 67
  (m___0->xxh)->chn = (int )tmp___1;
#line 68
  read16b(f);
#line 69
  tmp___2 = read16b(f);
#line 69
  (m___0->xxh)->len = (int )tmp___2;
#line 70
  tmp___3 = read16b(f);
#line 70
  (m___0->xxh)->pat = (int )tmp___3;
#line 71
  tmp___4 = read16b(f);
#line 71
  (m___0->xxh)->trk = (int )tmp___4;
#line 72
  tmp___6 = read16b(f);
#line 72
  tmp___5 = (int )tmp___6;
#line 72
  (m___0->xxh)->smp = tmp___5;
#line 72
  (m___0->xxh)->ins = tmp___5;
#line 73
  read16b(f);
#line 74
  read32b(f);
#line 76
  tmp___7 = read32b(f);
#line 76
  sng_ptr = (int )tmp___7;
#line 77
  tmp___8 = read32b(f);
#line 77
  seq_ptr = (int )tmp___8;
#line 78
  tmp___9 = read32b(f);
#line 78
  ins_ptr = (int )tmp___9;
#line 79
  tmp___10 = read32b(f);
#line 79
  pat_ptr = (int )tmp___10;
#line 80
  tmp___11 = read32b(f);
#line 80
  trk_ptr = (int )tmp___11;
#line 81
  tmp___12 = read32b(f);
#line 81
  smp_ptr = (int )tmp___12;
#line 82
  read32b(f);
#line 83
  read32b(f);
#line 85
  fseek(f, (long )(start + (int const   )sng_ptr), 0);
#line 87
  fread((void */* __restrict  */)(m___0->name), (size_t )1, (size_t )32, (FILE */* __restrict  */)f);
#line 88
  tmp___13 = read32b(f);
#line 88
  seq_ptr = (int )tmp___13;
#line 89
  tmp___14 = read16b(f);
#line 89
  (m___0->xxh)->len = (int )tmp___14;
#line 90
  tmp___15 = read16b(f);
#line 90
  (m___0->xxh)->rst = (int )tmp___15;
#line 91
  tmp___16 = read8(f);
#line 91
  (m___0->xxh)->bpm = (int )tmp___16;
#line 92
  tmp___17 = read8(f);
#line 92
  (m___0->xxh)->tpo = (int )tmp___17;
#line 93
  read16b(f);
#line 94
  read8(f);
#line 95
  read8(f);
#line 97
  i___3 = 0;
  }
  {
#line 97
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 97
    if (! (i___3 < (m___0->xxh)->chn)) {
#line 97
      goto while_break___0;
    }
    {
#line 98
    read16b(f);
#line 97
    i___3 ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 101
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 101
    if (m___0->verbosity) {
#line 101
      if (m___0->name[0]) {
        {
#line 101
        report((char *)"Module title   : %s\n", m___0->name);
        }
      }
#line 101
      if (m___0->type[0]) {
        {
#line 101
        report((char *)"Module type    : %s\n", m___0->type);
        }
      }
#line 101
      if (m___0->author[0]) {
        {
#line 101
        report((char *)"Author name    : %s\n", m___0->author);
        }
      }
#line 101
      if ((m___0->xxh)->len) {
        {
#line 101
        report((char *)"Module length  : %d patterns\n", (m___0->xxh)->len);
        }
      }
    }
#line 101
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 105
  fseek(f, (long )(start + (int const   )seq_ptr), 0);
#line 106
  i___3 = 0;
  }
  {
#line 106
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 106
    if (! (i___3 < (m___0->xxh)->len)) {
#line 106
      goto while_break___2;
    }
    {
#line 107
    tmp___18 = read16b(f);
#line 107
    m___0->xxo[i___3] = (uint8 )tmp___18;
#line 106
    i___3 ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 111
  while (1) {
    while_continue___3: /* CIL Label */ ;
    {
#line 111
    tmp___19 = calloc((size_t )sizeof(struct xxm_instrument_header ), (size_t )(m___0->xxh)->ins);
#line 111
    m___0->xxih = (struct xxm_instrument_header *)tmp___19;
#line 111
    tmp___20 = calloc((size_t )sizeof(struct xxm_instrument_map ), (size_t )(m___0->xxh)->ins);
#line 111
    m___0->xxim = (struct xxm_instrument_map *)tmp___20;
#line 111
    tmp___21 = calloc((size_t )sizeof(struct xxm_instrument *), (size_t )(m___0->xxh)->ins);
#line 111
    m___0->xxi = (struct xxm_instrument **)tmp___21;
    }
#line 111
    if ((m___0->xxh)->smp) {
      {
#line 111
      tmp___22 = calloc((size_t )sizeof(struct xxm_sample ), (size_t )(m___0->xxh)->smp);
#line 111
      m___0->xxs = (struct xxm_sample *)tmp___22;
      }
    }
    {
#line 111
    tmp___23 = calloc((size_t )sizeof(uint16 *), (size_t )(m___0->xxh)->ins);
#line 111
    m___0->xxae = (uint16 **)tmp___23;
#line 111
    tmp___24 = calloc((size_t )sizeof(uint16 *), (size_t )(m___0->xxh)->ins);
#line 111
    m___0->xxpe = (uint16 **)tmp___24;
#line 111
    tmp___25 = calloc((size_t )sizeof(uint16 *), (size_t )(m___0->xxh)->ins);
#line 111
    m___0->xxfe = (uint16 **)tmp___25;
    }
#line 111
    goto while_break___3;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 113
  fseek(f, (long )(start + (int const   )ins_ptr), 0);
#line 114
  reportv(ctx___0, 1, (char *)"     Name                             Len  LBeg LEnd L Vol C2Spd\n");
#line 116
  i___3 = 0;
  }
  {
#line 116
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 116
    if (! (i___3 < (m___0->xxh)->ins)) {
#line 116
      goto while_break___4;
    }
    {
#line 119
    tmp___26 = calloc((size_t )sizeof(struct xxm_instrument ), (size_t )1);
#line 119
    *(m___0->xxi + i___3) = (struct xxm_instrument *)tmp___26;
#line 121
    fread((void */* __restrict  */)((m___0->xxih + i___3)->name), (size_t )1, (size_t )32,
          (FILE */* __restrict  */)f);
#line 122
    tmp___27 = read32b(f);
#line 122
    sdata[i___3] = (int )tmp___27;
#line 123
    tmp___28 = read32b(f);
#line 123
    (m___0->xxs + i___3)->len = (int )tmp___28;
#line 124
    tmp___29 = read32b(f);
#line 124
    (m___0->xxs + i___3)->lps = (int )tmp___29;
#line 125
    tmp___30 = read32b(f);
#line 125
    (m___0->xxs + i___3)->lpe = (int )((uint32 )(m___0->xxs + i___3)->lps + tmp___30);
#line 126
    read32b(f);
#line 127
    read32b(f);
#line 128
    tmp___31 = read32b(f);
#line 128
    c2spd___0 = (int )tmp___31;
#line 129
    c2spd_to_note(c2spd___0, & (*(m___0->xxi + i___3) + 0)->xpo, & (*(m___0->xxi + i___3) + 0)->fin);
#line 130
    tmp___32 = read16b(f);
#line 130
    (*(m___0->xxi + i___3) + 0)->vol = (int )tmp___32 >> 4;
#line 131
    read8(f);
#line 132
    read8(f);
#line 133
    (*(m___0->xxi + i___3) + 0)->pan = 128;
#line 134
    tmp___33 = read8(f);
#line 134
    flags = (int )tmp___33;
    }
#line 135
    if (flags & 3) {
#line 135
      (m___0->xxs + i___3)->flg = 4;
    } else {
#line 135
      (m___0->xxs + i___3)->flg = 0;
    }
#line 136
    if (flags & 2) {
#line 136
      tmp___34 = 8;
    } else {
#line 136
      tmp___34 = 0;
    }
    {
#line 136
    (m___0->xxs + i___3)->flg |= tmp___34;
#line 137
    tmp___35 = read8(f);
#line 137
    (*(m___0->xxi + i___3) + 0)->fin = (*(m___0->xxi + i___3) + 0)->fin;
#line 138
    read8(f);
#line 139
    read8(f);
#line 140
    read8(f);
#line 141
    read8(f);
#line 142
    read16b(f);
#line 143
    read32b(f);
#line 144
    read32b(f);
#line 146
    (m___0->xxih + i___3)->nsm = ! (! (m___0->xxs + i___3)->len);
#line 147
    (*(m___0->xxi + i___3) + 0)->sid = i___3;
    }
#line 149
    if (m___0->verbosity > 1) {
      {
#line 149
      tmp___38 = strlen((char const   *)((char *)((m___0->xxih + i___3)->name)));
      }
#line 149
      if (tmp___38) {
#line 149
        goto _L;
      } else
#line 149
      if ((m___0->xxs + i___3)->len > 1) {
        _L: /* CIL Label */ 
#line 150
        if ((m___0->xxs + i___3)->flg & 8) {
#line 150
          tmp___37 = 'B';
        } else {
#line 150
          if ((m___0->xxs + i___3)->flg & 4) {
#line 150
            tmp___36 = 'L';
          } else {
#line 150
            tmp___36 = ' ';
          }
#line 150
          tmp___37 = tmp___36;
        }
        {
#line 150
        report((char *)"[%2X] %-32.32s %04x %04x %04x %c V%02x %5d\n", i___3, (m___0->xxih + i___3)->name,
               (m___0->xxs + i___3)->len, (m___0->xxs + i___3)->lps, (m___0->xxs + i___3)->lpe,
               tmp___37, (*(m___0->xxi + i___3) + 0)->vol, c2spd___0);
        }
      }
    }
#line 116
    i___3 ++;
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 160
  while (1) {
    while_continue___5: /* CIL Label */ ;
    {
#line 160
    tmp___39 = calloc((size_t )sizeof(struct xxm_track *), (size_t )(m___0->xxh)->trk);
#line 160
    m___0->xxt = (struct xxm_track **)tmp___39;
#line 160
    tmp___40 = calloc((size_t )sizeof(struct xxm_pattern *), (size_t )((m___0->xxh)->pat + 1));
#line 160
    m___0->xxp = (struct xxm_pattern **)tmp___40;
    }
#line 160
    goto while_break___5;
  }
  while_break___5: /* CIL Label */ ;
  }
  {
#line 162
  reportv(ctx___0, 0, (char *)"Stored tracks  : %d ", (m___0->xxh)->trk);
#line 166
  i___3 = 1;
  }
  {
#line 166
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 166
    if (! (i___3 < (m___0->xxh)->trk)) {
#line 166
      goto while_break___6;
    }
    {
#line 170
    fseek(f, (long )((start + (int const   )trk_ptr) + (int const   )(i___3 * 4)),
          0);
#line 171
    tmp___41 = read32b(f);
#line 171
    offset = (int )tmp___41;
#line 172
    fseek(f, (long )(start + (int const   )offset), 0);
#line 174
    tmp___42 = read16b(f);
#line 174
    rows___1 = (int )tmp___42;
#line 175
    tmp___43 = calloc((size_t )(sizeof(struct xxm_track ) + sizeof(struct xxm_event ) * (unsigned long )rows___1),
                      (size_t )1);
#line 175
    *(m___0->xxt + i___3) = (struct xxm_track *)tmp___43;
#line 177
    (*(m___0->xxt + i___3))->rows = rows___1;
#line 180
    j = 0;
    }
    {
#line 180
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 180
      if (! (j < rows___1)) {
#line 180
        goto while_break___7;
      }
      {
#line 183
      b___1 = read8(f);
#line 184
      j += (int )b___1 & 3;
#line 186
      note = (uint8 )0;
#line 187
      event = & (*(m___0->xxt + i___3))->event[j];
      }
#line 188
      if ((int )b___1 & 4) {
        {
#line 189
        note = read8(f);
        }
      }
#line 190
      if ((int )b___1 & 8) {
        {
#line 191
        event->ins = read8(f);
        }
      }
#line 192
      if ((int )b___1 & 16) {
        {
#line 193
        event->vol = read8(f);
        }
      }
#line 194
      if ((int )b___1 & 32) {
        {
#line 195
        event->fxt = read8(f);
        }
      }
#line 196
      if ((int )b___1 & 64) {
        {
#line 197
        event->fxp = read8(f);
        }
      }
#line 198
      if ((int )b___1 & 128) {
        {
#line 199
        f2p = read8(f);
        }
      }
#line 201
      if ((int )note == 1) {
#line 202
        event->note = (uint8 )129;
      } else
#line 203
      if ((int )note > 11) {
#line 204
        event->note = (uint8 )((int )note - 11);
      }
#line 207
      if (! ((int )event->fxt < 16)) {
        {
#line 216
        if ((int )event->fxt == 30) {
#line 216
          goto case_30;
        }
#line 216
        if ((int )event->fxt == 29) {
#line 216
          goto case_30;
        }
#line 216
        if ((int )event->fxt == 28) {
#line 216
          goto case_30;
        }
#line 216
        if ((int )event->fxt == 23) {
#line 216
          goto case_30;
        }
#line 216
        if ((int )event->fxt == 21) {
#line 216
          goto case_30;
        }
#line 216
        if ((int )event->fxt == 20) {
#line 216
          goto case_30;
        }
#line 216
        if ((int )event->fxt == 19) {
#line 216
          goto case_30;
        }
#line 221
        goto switch_default;
        case_30: /* CIL Label */ 
        case_29: /* CIL Label */ 
        case_28: /* CIL Label */ 
        case_23: /* CIL Label */ 
        case_21: /* CIL Label */ 
        case_20: /* CIL Label */ 
        case_19: /* CIL Label */ 
#line 217
        event->fxt = (uint8 )14;
#line 218
        event->fxp = (uint8 )((((int )event->fxt & 15) << 4) | ((int )event->fxp & 15));
#line 220
        goto switch_break;
        switch_default: /* CIL Label */ 
#line 222
        tmp___44 = (uint8 )0;
#line 222
        event->fxp = tmp___44;
#line 222
        event->fxt = tmp___44;
        switch_break: /* CIL Label */ ;
        }
      }
#line 226
      if ((int )event->vol >= 16) {
#line 226
        if ((int )event->vol <= 80) {
#line 227
          event->vol = (uint8 )((int )event->vol - 15);
#line 228
          goto __Cont;
        }
      }
      {
#line 232
      if ((int )event->vol >> 4 == 6) {
#line 232
        goto case_6;
      }
#line 236
      if ((int )event->vol >> 4 == 7) {
#line 236
        goto case_7;
      }
#line 240
      if ((int )event->vol >> 4 == 8) {
#line 240
        goto case_8;
      }
#line 245
      if ((int )event->vol >> 4 == 9) {
#line 245
        goto case_9;
      }
#line 250
      if ((int )event->vol >> 4 == 10) {
#line 250
        goto case_10;
      }
#line 254
      if ((int )event->vol >> 4 == 11) {
#line 254
        goto case_11;
      }
#line 258
      if ((int )event->vol >> 4 == 12) {
#line 258
        goto case_12;
      }
#line 262
      if ((int )event->vol >> 4 == 13) {
#line 262
        goto case_13;
      }
#line 266
      if ((int )event->vol >> 4 == 14) {
#line 266
        goto case_14;
      }
#line 270
      if ((int )event->vol >> 4 == 15) {
#line 270
        goto case_15;
      }
#line 231
      goto switch_break___0;
      case_6: /* CIL Label */ 
#line 233
      event->f2t = (uint8 )164;
#line 234
      event->f2p = (uint8 )((int )event->vol - 96);
#line 235
      goto switch_break___0;
      case_7: /* CIL Label */ 
#line 237
      event->f2t = (uint8 )164;
#line 238
      event->f2p = (uint8 )(((int )event->vol - 112) << 4);
#line 239
      goto switch_break___0;
      case_8: /* CIL Label */ 
#line 241
      event->f2t = (uint8 )14;
#line 242
      event->f2p = (uint8 )((11 << 4) | ((int )event->vol - 128));
#line 244
      goto switch_break___0;
      case_9: /* CIL Label */ 
#line 246
      event->f2t = (uint8 )14;
#line 247
      event->f2p = (uint8 )((10 << 4) | ((int )event->vol - 144));
#line 249
      goto switch_break___0;
      case_10: /* CIL Label */ 
#line 251
      event->f2t = (uint8 )4;
#line 252
      event->f2p = (uint8 )(((int )event->vol - 160) << 4);
#line 253
      goto switch_break___0;
      case_11: /* CIL Label */ 
#line 255
      event->f2t = (uint8 )4;
#line 256
      event->f2p = (uint8 )((int )event->vol - 176);
#line 257
      goto switch_break___0;
      case_12: /* CIL Label */ 
#line 259
      event->f2t = (uint8 )8;
#line 260
      event->f2p = (uint8 )((((int )event->vol - 192) << 4) + 8);
#line 261
      goto switch_break___0;
      case_13: /* CIL Label */ 
#line 263
      event->f2t = (uint8 )25;
#line 264
      event->f2p = (uint8 )(((int )event->vol - 208) << 4);
#line 265
      goto switch_break___0;
      case_14: /* CIL Label */ 
#line 267
      event->f2t = (uint8 )25;
#line 268
      event->f2p = (uint8 )((int )event->vol - 224);
#line 269
      goto switch_break___0;
      case_15: /* CIL Label */ 
#line 271
      event->f2t = (uint8 )3;
#line 272
      event->f2p = (uint8 )(((int )event->vol - 240) << 4);
#line 273
      goto switch_break___0;
      switch_break___0: /* CIL Label */ ;
      }
#line 276
      event->vol = (uint8 )0;
      __Cont: /* CIL Label */ 
#line 180
      j ++;
    }
    while_break___7: /* CIL Label */ ;
    }
#line 283
    if (m___0->verbosity > 0) {
#line 283
      if (i___3 % (m___0->xxh)->chn == 0) {
        {
#line 284
        report((char *)".");
        }
      }
    }
#line 166
    i___3 ++;
  }
  while_break___6: /* CIL Label */ ;
  }
  {
#line 286
  reportv(ctx___0, 0, (char *)"\n");
#line 289
  tmp___45 = calloc((size_t )((sizeof(struct xxm_track ) + sizeof(struct xxm_event ) * 64UL) - 1UL),
                    (size_t )1);
#line 289
  *(m___0->xxt + 0) = (struct xxm_track *)tmp___45;
#line 291
  (*(m___0->xxt + 0))->rows = 64;
#line 295
  reportv(ctx___0, 0, (char *)"Stored patterns: %d ", (m___0->xxh)->pat);
#line 296
  fseek(f, (long )(start + (int const   )pat_ptr), 0);
#line 298
  i___3 = 0;
  }
  {
#line 298
  while (1) {
    while_continue___8: /* CIL Label */ ;
#line 298
    if (! (i___3 < (m___0->xxh)->pat)) {
#line 298
      goto while_break___8;
    }
    {
#line 299
    while (1) {
      while_continue___9: /* CIL Label */ ;
      {
#line 299
      tmp___46 = calloc((size_t )1, (size_t )(sizeof(struct xxm_pattern ) + sizeof(struct xxm_trackinfo ) * (unsigned long )((m___0->xxh)->chn - 1)));
#line 299
      *(m___0->xxp + i___3) = (struct xxm_pattern *)tmp___46;
      }
#line 299
      goto while_break___9;
    }
    while_break___9: /* CIL Label */ ;
    }
    {
#line 301
    tmp___47 = read16b(f);
#line 301
    (*(m___0->xxp + i___3))->rows = (int )tmp___47;
#line 302
    j = 0;
    }
    {
#line 302
    while (1) {
      while_continue___10: /* CIL Label */ ;
#line 302
      if (! (j < (m___0->xxh)->chn)) {
#line 302
        goto while_break___10;
      }
      {
#line 303
      tmp___48 = read16b(f);
#line 303
      (*(m___0->xxp + i___3))->info[j].index = (int )tmp___48 - 1;
#line 302
      j ++;
      }
    }
    while_break___10: /* CIL Label */ ;
    }
    {
#line 307
    reportv(ctx___0, 0, (char *)".");
#line 298
    i___3 ++;
    }
  }
  while_break___8: /* CIL Label */ ;
  }
  {
#line 310
  reportv(ctx___0, 0, (char *)"\n");
#line 314
  reportv(ctx___0, 0, (char *)"Stored samples : %d ", (m___0->xxh)->smp);
#line 316
  i___3 = 0;
  }
  {
#line 316
  while (1) {
    while_continue___11: /* CIL Label */ ;
#line 316
    if (! (i___3 < (m___0->xxh)->ins)) {
#line 316
      goto while_break___11;
    }
#line 317
    if ((m___0->xxih + i___3)->nsm == 0) {
#line 318
      goto __Cont___0;
    }
    {
#line 320
    fseek(f, (long )(start + (int const   )sdata[i___3]), 0);
#line 321
    xmp_drv_loadpatch(ctx___0, f, (*(m___0->xxi + i___3) + 0)->sid, m___0->c4rate,
                      0, m___0->xxs + (*(m___0->xxi + i___3) + 0)->sid, (char *)((void *)0));
#line 323
    reportv(ctx___0, 0, (char *)".");
    }
    __Cont___0: /* CIL Label */ 
#line 316
    i___3 ++;
  }
  while_break___11: /* CIL Label */ ;
  }
  {
#line 325
  reportv(ctx___0, 0, (char *)"\n");
  }
#line 327
  return (0);
}
}
#line 19 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/dtt_load.c"
static int dtt_test(FILE *f , char *t , int const   start ) ;
#line 20
static int dtt_load(struct xmp_context *ctx___0 , FILE *f , int const   start ) ;
#line 22 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/dtt_load.c"
struct xmp_loader_info dtt_loader  =    {(char *)"DTT", (char *)"Desktop Tracker", & dtt_test, & dtt_load, 0, {(struct list_head *)0,
                                                                          (struct list_head *)0}};
#line 29 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/dtt_load.c"
static int dtt_test(FILE *f , char *t , int const   start ) 
{ 
  uint32 tmp ;

  {
  {
#line 31
  tmp = read32b(f);
  }
#line 31
  if (tmp != ((((68U << 24) | (115U << 16)) | (107U << 8)) | 84U)) {
#line 32
    return (-1);
  }
  {
#line 34
  read_title(f, t, 64);
  }
#line 36
  return (0);
}
}
#line 39 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/dtt_load.c"
static int dtt_load(struct xmp_context *ctx___0 , FILE *f , int const   start ) 
{ 
  struct xmp_player_context *p ;
  struct xmp_mod_context *m___0 ;
  struct xxm_event *event ;
  int i___3 ;
  int j ;
  int k ;
  int n___0 ;
  uint8 buf___1[100] ;
  uint32 flags ;
  uint32 pofs[256] ;
  uint8 plen[256] ;
  int sdata[64] ;
  uint8 **tmp ;
  uint32 tmp___0 ;
  uint32 tmp___1 ;
  uint32 tmp___2 ;
  uint32 tmp___3 ;
  uint32 tmp___4 ;
  int tmp___5 ;
  uint32 tmp___6 ;
  int x ;
  uint32 tmp___7 ;
  int x___0 ;
  uint8 tmp___8 ;
  void *tmp___9 ;
  void *tmp___10 ;
  void *tmp___11 ;
  void *tmp___12 ;
  void *tmp___13 ;
  void *tmp___14 ;
  void *tmp___15 ;
  int c2spd___0 ;
  int looplen ;
  void *tmp___16 ;
  uint8 tmp___17 ;
  uint32 tmp___18 ;
  uint32 tmp___19 ;
  uint32 tmp___20 ;
  uint32 tmp___21 ;
  uint32 tmp___22 ;
  int tmp___23 ;
  size_t tmp___24 ;
  void *tmp___25 ;
  void *tmp___26 ;
  void *tmp___27 ;
  int j___0 ;
  void *tmp___28 ;
  uint32 x___1 ;
  void *__cil_tmp52 ;
  void *__cil_tmp53 ;
  void *__cil_tmp54 ;
  void *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;
  char *__cil_tmp66 ;
  char *__cil_tmp67 ;
  char *__cil_tmp68 ;

  {
#line 41
  p = & ctx___0->p;
#line 42
  m___0 = & p->m;
  {
#line 52
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 52
    fseek(f, (long )start, 0);
#line 52
    tmp = (uint8 **)((void *)0);
#line 52
    m___0->med_wav_table = tmp;
#line 52
    m___0->med_vol_table = tmp;
#line 52
    set_xxh_defaults(m___0->xxh);
    }
#line 52
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 54
  read32b(f);
#line 56
  strcpy((char */* __restrict  */)(m___0->type), (char const   */* __restrict  */)"Desktop Tracker");
#line 58
  fread((void */* __restrict  */)(buf___1), (size_t )1, (size_t )64, (FILE */* __restrict  */)f);
#line 59
  strncpy((char */* __restrict  */)(m___0->name), (char const   */* __restrict  */)((char *)(buf___1)),
          (size_t )64);
#line 60
  fread((void */* __restrict  */)(buf___1), (size_t )1, (size_t )64, (FILE */* __restrict  */)f);
#line 61
  strncpy((char */* __restrict  */)(m___0->author), (char const   */* __restrict  */)((char *)(buf___1)),
          (size_t )64);
#line 63
  flags = read32l(f);
#line 64
  tmp___0 = read32l(f);
#line 64
  (m___0->xxh)->chn = (int )tmp___0;
#line 65
  tmp___1 = read32l(f);
#line 65
  (m___0->xxh)->len = (int )tmp___1;
#line 66
  fread((void */* __restrict  */)(buf___1), (size_t )1, (size_t )8, (FILE */* __restrict  */)f);
#line 67
  tmp___2 = read32l(f);
#line 67
  (m___0->xxh)->tpo = (int )tmp___2;
#line 68
  tmp___3 = read32l(f);
#line 68
  (m___0->xxh)->rst = (int )tmp___3;
#line 69
  tmp___4 = read32l(f);
#line 69
  (m___0->xxh)->pat = (int )tmp___4;
#line 70
  tmp___6 = read32l(f);
#line 70
  tmp___5 = (int )tmp___6;
#line 70
  (m___0->xxh)->smp = tmp___5;
#line 70
  (m___0->xxh)->ins = tmp___5;
#line 71
  (m___0->xxh)->trk = (m___0->xxh)->pat * (m___0->xxh)->chn;
#line 73
  fread((void */* __restrict  */)(m___0->xxo), (size_t )1, (size_t )((long )((m___0->xxh)->len + 3) & -4L),
        (FILE */* __restrict  */)f);
  }
  {
#line 75
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 75
    if (m___0->verbosity) {
#line 75
      if (m___0->name[0]) {
        {
#line 75
        report((char *)"Module title   : %s\n", m___0->name);
        }
      }
#line 75
      if (m___0->type[0]) {
        {
#line 75
        report((char *)"Module type    : %s\n", m___0->type);
        }
      }
#line 75
      if (m___0->author[0]) {
        {
#line 75
        report((char *)"Author name    : %s\n", m___0->author);
        }
      }
#line 75
      if ((m___0->xxh)->len) {
        {
#line 75
        report((char *)"Module length  : %d patterns\n", (m___0->xxh)->len);
        }
      }
    }
#line 75
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 77
  i___3 = 0;
  {
#line 77
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 77
    if (! (i___3 < (m___0->xxh)->pat)) {
#line 77
      goto while_break___1;
    }
    {
#line 78
    tmp___7 = read32l(f);
#line 78
    x = (int )tmp___7;
    }
#line 79
    if (i___3 < 256) {
#line 80
      pofs[i___3] = (uint32 )x;
    }
#line 77
    i___3 ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 83
  n___0 = (int )((long )((m___0->xxh)->pat + 3) & -4L);
#line 84
  i___3 = 0;
  {
#line 84
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 84
    if (! (i___3 < n___0)) {
#line 84
      goto while_break___2;
    }
    {
#line 85
    tmp___8 = read8(f);
#line 85
    x___0 = (int )tmp___8;
    }
#line 86
    if (i___3 < 256) {
#line 87
      plen[i___3] = (uint8 )x___0;
    }
#line 84
    i___3 ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 90
  while (1) {
    while_continue___3: /* CIL Label */ ;
    {
#line 90
    tmp___9 = calloc((size_t )sizeof(struct xxm_instrument_header ), (size_t )(m___0->xxh)->ins);
#line 90
    m___0->xxih = (struct xxm_instrument_header *)tmp___9;
#line 90
    tmp___10 = calloc((size_t )sizeof(struct xxm_instrument_map ), (size_t )(m___0->xxh)->ins);
#line 90
    m___0->xxim = (struct xxm_instrument_map *)tmp___10;
#line 90
    tmp___11 = calloc((size_t )sizeof(struct xxm_instrument *), (size_t )(m___0->xxh)->ins);
#line 90
    m___0->xxi = (struct xxm_instrument **)tmp___11;
    }
#line 90
    if ((m___0->xxh)->smp) {
      {
#line 90
      tmp___12 = calloc((size_t )sizeof(struct xxm_sample ), (size_t )(m___0->xxh)->smp);
#line 90
      m___0->xxs = (struct xxm_sample *)tmp___12;
      }
    }
    {
#line 90
    tmp___13 = calloc((size_t )sizeof(uint16 *), (size_t )(m___0->xxh)->ins);
#line 90
    m___0->xxae = (uint16 **)tmp___13;
#line 90
    tmp___14 = calloc((size_t )sizeof(uint16 *), (size_t )(m___0->xxh)->ins);
#line 90
    m___0->xxpe = (uint16 **)tmp___14;
#line 90
    tmp___15 = calloc((size_t )sizeof(uint16 *), (size_t )(m___0->xxh)->ins);
#line 90
    m___0->xxfe = (uint16 **)tmp___15;
    }
#line 90
    goto while_break___3;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 93
  reportv(ctx___0, 1, (char *)"     Name                              Len  LBeg LEnd L Vol\n");
#line 94
  i___3 = 0;
  }
  {
#line 94
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 94
    if (! (i___3 < (m___0->xxh)->ins)) {
#line 94
      goto while_break___4;
    }
    {
#line 97
    tmp___16 = calloc((size_t )sizeof(struct xxm_instrument ), (size_t )1);
#line 97
    *(m___0->xxi + i___3) = (struct xxm_instrument *)tmp___16;
#line 98
    read8(f);
#line 99
    tmp___17 = read8(f);
#line 99
    (*(m___0->xxi + i___3) + 0)->vol = (int )tmp___17 >> 1;
#line 100
    (*(m___0->xxi + i___3) + 0)->pan = 128;
#line 101
    read16l(f);
#line 102
    tmp___18 = read32l(f);
#line 102
    c2spd___0 = (int )tmp___18;
#line 103
    read32l(f);
#line 104
    read32l(f);
#line 105
    tmp___19 = read32l(f);
#line 105
    (m___0->xxs + i___3)->lps = (int )tmp___19;
#line 106
    tmp___20 = read32l(f);
#line 106
    looplen = (int )tmp___20;
    }
#line 107
    if (looplen > 0) {
#line 107
      (m___0->xxs + i___3)->flg = 4;
    } else {
#line 107
      (m___0->xxs + i___3)->flg = 0;
    }
    {
#line 108
    (m___0->xxs + i___3)->lpe = (m___0->xxs + i___3)->lps + looplen;
#line 109
    tmp___21 = read32l(f);
#line 109
    (m___0->xxs + i___3)->len = (int )tmp___21;
#line 110
    fread((void */* __restrict  */)(buf___1), (size_t )1, (size_t )32, (FILE */* __restrict  */)f);
#line 111
    copy_adjust((m___0->xxih + i___3)->name, buf___1, 32);
#line 112
    tmp___22 = read32l(f);
#line 112
    sdata[i___3] = (int )tmp___22;
#line 114
    (m___0->xxih + i___3)->nsm = ! (! (m___0->xxs + i___3)->len);
#line 115
    (*(m___0->xxi + i___3) + 0)->sid = i___3;
    }
#line 117
    if (m___0->verbosity > 1) {
      {
#line 117
      tmp___24 = strlen((char const   *)((char *)((m___0->xxih + i___3)->name)));
      }
#line 117
      if (tmp___24) {
#line 117
        goto _L;
      } else
#line 117
      if ((m___0->xxs + i___3)->len > 1) {
        _L: /* CIL Label */ 
#line 118
        if ((m___0->xxs + i___3)->flg & 4) {
#line 118
          tmp___23 = 'L';
        } else {
#line 118
          tmp___23 = ' ';
        }
        {
#line 118
        report((char *)"[%2X] %-32.32s  %04x %04x %04x %c V%02x\n", i___3, (m___0->xxih + i___3)->name,
               (m___0->xxs + i___3)->len, (m___0->xxs + i___3)->lps, (m___0->xxs + i___3)->lpe,
               tmp___23, (*(m___0->xxi + i___3) + 0)->vol, c2spd___0);
        }
      }
    }
#line 94
    i___3 ++;
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 126
  while (1) {
    while_continue___5: /* CIL Label */ ;
    {
#line 126
    tmp___25 = calloc((size_t )sizeof(struct xxm_track *), (size_t )(m___0->xxh)->trk);
#line 126
    m___0->xxt = (struct xxm_track **)tmp___25;
#line 126
    tmp___26 = calloc((size_t )sizeof(struct xxm_pattern *), (size_t )((m___0->xxh)->pat + 1));
#line 126
    m___0->xxp = (struct xxm_pattern **)tmp___26;
    }
#line 126
    goto while_break___5;
  }
  while_break___5: /* CIL Label */ ;
  }
  {
#line 129
  reportv(ctx___0, 0, (char *)"Stored patterns: %d ", (m___0->xxh)->pat);
#line 131
  i___3 = 0;
  }
  {
#line 131
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 131
    if (! (i___3 < (m___0->xxh)->pat)) {
#line 131
      goto while_break___6;
    }
    {
#line 132
    while (1) {
      while_continue___7: /* CIL Label */ ;
      {
#line 132
      tmp___27 = calloc((size_t )1, (size_t )(sizeof(struct xxm_pattern ) + sizeof(struct xxm_trackinfo ) * (unsigned long )((m___0->xxh)->chn - 1)));
#line 132
      *(m___0->xxp + i___3) = (struct xxm_pattern *)tmp___27;
      }
#line 132
      goto while_break___7;
    }
    while_break___7: /* CIL Label */ ;
    }
#line 133
    (*(m___0->xxp + i___3))->rows = (int )plen[i___3];
    {
#line 134
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 134
      j___0 = 0;
      {
#line 134
      while (1) {
        while_continue___9: /* CIL Label */ ;
#line 134
        if (! (j___0 < (m___0->xxh)->chn)) {
#line 134
          goto while_break___9;
        }
        {
#line 134
        (*(m___0->xxp + i___3))->info[j___0].index = i___3 * (m___0->xxh)->chn + j___0;
#line 134
        tmp___28 = calloc((size_t )(sizeof(struct xxm_track ) + sizeof(struct xxm_event ) * (unsigned long )(*(m___0->xxp + i___3))->rows),
                          (size_t )1);
#line 134
        *(m___0->xxt + (i___3 * (m___0->xxh)->chn + j___0)) = (struct xxm_track *)tmp___28;
#line 134
        (*(m___0->xxt + (i___3 * (m___0->xxh)->chn + j___0)))->rows = (*(m___0->xxp + i___3))->rows;
#line 134
        j___0 ++;
        }
      }
      while_break___9: /* CIL Label */ ;
      }
#line 134
      goto while_break___8;
    }
    while_break___8: /* CIL Label */ ;
    }
    {
#line 136
    fseek(f, (long )((uint32 )start + pofs[i___3]), 0);
#line 138
    j = 0;
    }
    {
#line 138
    while (1) {
      while_continue___10: /* CIL Label */ ;
#line 138
      if (! (j < (*(m___0->xxp + i___3))->rows)) {
#line 138
        goto while_break___10;
      }
#line 139
      k = 0;
      {
#line 139
      while (1) {
        while_continue___11: /* CIL Label */ ;
#line 139
        if (! (k < (m___0->xxh)->chn)) {
#line 139
          goto while_break___11;
        }
        {
#line 142
        event = & (*(m___0->xxt + (*(m___0->xxp + i___3))->info[k].index))->event[j];
#line 143
        x___1 = read32l(f);
#line 145
        event->ins = (uint8 )(x___1 & 63U);
#line 146
        event->note = (uint8 )((x___1 & 4032U) >> 6);
#line 147
        event->fxt = (uint8 )((x___1 & 126976U) >> 12);
        }
#line 149
        if (event->note) {
#line 150
          event->note = (uint8 )((int )event->note + 36);
        }
#line 153
        if (x___1 & (unsigned int )(31 << 17)) {
          {
#line 154
          event->f2p = (uint8 )((x___1 & 4063232U) >> 17);
#line 155
          x___1 = read32l(f);
#line 156
          event->fxp = (uint8 )(x___1 & 255U);
#line 157
          event->f2p = (uint8 )((x___1 & 65280U) >> 8);
          }
        } else {
#line 159
          event->fxp = (uint8 )((x___1 & 4227858432U) >> 18);
        }
#line 139
        k ++;
      }
      while_break___11: /* CIL Label */ ;
      }
#line 138
      j ++;
    }
    while_break___10: /* CIL Label */ ;
    }
    {
#line 163
    reportv(ctx___0, 0, (char *)".");
#line 131
    i___3 ++;
    }
  }
  while_break___6: /* CIL Label */ ;
  }
  {
#line 165
  reportv(ctx___0, 0, (char *)"\n");
#line 168
  reportv(ctx___0, 0, (char *)"Stored samples : %d ", (m___0->xxh)->smp);
#line 169
  i___3 = 0;
  }
  {
#line 169
  while (1) {
    while_continue___12: /* CIL Label */ ;
#line 169
    if (! (i___3 < (m___0->xxh)->ins)) {
#line 169
      goto while_break___12;
    }
    {
#line 170
    fseek(f, (long )(start + (int const   )sdata[i___3]), 0);
#line 171
    xmp_drv_loadpatch(ctx___0, f, (*(m___0->xxi + i___3) + 0)->sid, m___0->c4rate,
                      128, m___0->xxs + (*(m___0->xxi + i___3) + 0)->sid, (char *)((void *)0));
#line 173
    reportv(ctx___0, 0, (char *)".");
#line 169
    i___3 ++;
    }
  }
  while_break___12: /* CIL Label */ ;
  }
  {
#line 175
  reportv(ctx___0, 0, (char *)"\n");
  }
#line 177
  return (0);
}
}
#line 17 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/sym_load.c"
static int sym_test(FILE *f , char *t , int const   start ) ;
#line 18
static int sym_load(struct xmp_context *ctx___0 , FILE *f , int const   start ) ;
#line 20 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/sym_load.c"
struct xmp_loader_info sym_loader  =    {(char *)"DSYM", (char *)"Digital Symphony", & sym_test, & sym_load, 0, {(struct list_head *)0,
                                                                            (struct list_head *)0}};
#line 27 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/sym_load.c"
static int sym_test(FILE *f , char *t , int const   start ) 
{ 
  uint32 a ;
  uint32 b___1 ;
  int i___3 ;
  int ver___0 ;
  uint8 tmp ;
  uint8 tmp___0 ;
  uint8 tmp___1 ;

  {
  {
#line 32
  a = read32b(f);
#line 33
  b___1 = read32b(f);
  }
#line 35
  if (a != 33624851U) {
#line 36
    return (-1);
  } else
#line 35
  if (b___1 != 336724235U) {
#line 36
    return (-1);
  }
  {
#line 38
  tmp = read8(f);
#line 38
  ver___0 = (int )tmp;
  }
#line 40
  if (ver___0 > 0) {
#line 41
    return (-1);
  }
  {
#line 43
  read8(f);
#line 44
  read16l(f);
#line 45
  read16l(f);
#line 46
  read24l(f);
#line 48
  i___3 = 0;
  }
  {
#line 48
  while (1) {
    while_continue: /* CIL Label */ ;
#line 48
    if (! (i___3 < 63)) {
#line 48
      goto while_break;
    }
    {
#line 49
    tmp___0 = read8(f);
    }
#line 49
    if (~ ((int )tmp___0) & 128) {
      {
#line 50
      read24l(f);
      }
    }
#line 48
    i___3 ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 53
  tmp___1 = read8(f);
#line 53
  read_title(f, t, (int )tmp___1);
  }
#line 55
  return (0);
}
}
#line 60 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/sym_load.c"
static void fix_effect___1(struct xxm_event *e , int parm ) 
{ 


  {
  {
#line 65
  if ((int )e->fxt == 2) {
#line 65
    goto case_2;
  }
#line 65
  if ((int )e->fxt == 1) {
#line 65
    goto case_2;
  }
#line 65
  if ((int )e->fxt == 0) {
#line 65
    goto case_2;
  }
#line 74
  if ((int )e->fxt == 7) {
#line 74
    goto case_7;
  }
#line 74
  if ((int )e->fxt == 6) {
#line 74
    goto case_7;
  }
#line 74
  if ((int )e->fxt == 5) {
#line 74
    goto case_7;
  }
#line 74
  if ((int )e->fxt == 4) {
#line 74
    goto case_7;
  }
#line 74
  if ((int )e->fxt == 3) {
#line 74
    goto case_7;
  }
#line 77
  if ((int )e->fxt == 9) {
#line 77
    goto case_9;
  }
#line 80
  if ((int )e->fxt == 10) {
#line 80
    goto case_10;
  }
#line 88
  if ((int )e->fxt == 15) {
#line 88
    goto case_15;
  }
#line 88
  if ((int )e->fxt == 13) {
#line 88
    goto case_15;
  }
#line 88
  if ((int )e->fxt == 12) {
#line 88
    goto case_15;
  }
#line 88
  if ((int )e->fxt == 11) {
#line 88
    goto case_15;
  }
#line 92
  if ((int )e->fxt == 18) {
#line 92
    goto case_18;
  }
#line 92
  if ((int )e->fxt == 17) {
#line 92
    goto case_18;
  }
#line 95
  if ((int )e->fxt == 19) {
#line 95
    goto case_19;
  }
#line 99
  if ((int )e->fxt == 20) {
#line 99
    goto case_20;
  }
#line 103
  if ((int )e->fxt == 21) {
#line 103
    goto case_21;
  }
#line 107
  if ((int )e->fxt == 22) {
#line 107
    goto case_22;
  }
#line 111
  if ((int )e->fxt == 23) {
#line 111
    goto case_23;
  }
#line 115
  if ((int )e->fxt == 25) {
#line 115
    goto case_25;
  }
#line 119
  if ((int )e->fxt == 26) {
#line 119
    goto case_26;
  }
#line 123
  if ((int )e->fxt == 27) {
#line 123
    goto case_27;
  }
#line 127
  if ((int )e->fxt == 28) {
#line 127
    goto case_28;
  }
#line 131
  if ((int )e->fxt == 29) {
#line 131
    goto case_29;
  }
#line 135
  if ((int )e->fxt == 30) {
#line 135
    goto case_30;
  }
#line 139
  if ((int )e->fxt == 31) {
#line 139
    goto case_31;
  }
#line 144
  if ((int )e->fxt == 34) {
#line 144
    goto case_34;
  }
#line 144
  if ((int )e->fxt == 33) {
#line 144
    goto case_34;
  }
#line 144
  if ((int )e->fxt == 32) {
#line 144
    goto case_34;
  }
#line 155
  goto switch_default;
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
  case_0: /* CIL Label */ 
#line 66
  e->fxp = (uint8 )(parm & 255);
#line 67
  e->f2t = (uint8 )160;
#line 68
  e->f2p = (uint8 )(parm >> 8);
#line 69
  goto switch_break;
  case_7: /* CIL Label */ 
  case_6: /* CIL Label */ 
  case_5: /* CIL Label */ 
  case_4: /* CIL Label */ 
  case_3: /* CIL Label */ 
#line 75
  e->fxp = (uint8 )parm;
#line 76
  goto switch_break;
  case_9: /* CIL Label */ 
#line 78
  e->fxp = (uint8 )(parm >> 1);
#line 79
  goto switch_break;
  case_10: /* CIL Label */ 
#line 81
  e->fxp = (uint8 )(parm & 255);
#line 82
  e->f2t = (uint8 )14;
#line 83
  e->f2p = (uint8 )((1 << 4) | ((parm & 3840) >> 8));
#line 84
  goto switch_break;
  case_15: /* CIL Label */ 
  case_13: /* CIL Label */ 
  case_12: /* CIL Label */ 
  case_11: /* CIL Label */ 
#line 89
  e->fxp = (uint8 )parm;
#line 90
  goto switch_break;
  case_18: /* CIL Label */ 
  case_17: /* CIL Label */ 
#line 93
  e->fxt = (uint8 )0;
#line 94
  goto switch_break;
  case_19: /* CIL Label */ 
#line 96
  e->fxt = (uint8 )14;
#line 97
  e->fxp = (uint8 )((3 << 4) | (parm & 15));
#line 98
  goto switch_break;
  case_20: /* CIL Label */ 
#line 100
  e->fxt = (uint8 )14;
#line 101
  e->fxp = (uint8 )((4 << 4) | (parm & 15));
#line 102
  goto switch_break;
  case_21: /* CIL Label */ 
#line 104
  e->fxt = (uint8 )14;
#line 105
  e->fxp = (uint8 )((5 << 4) | (parm & 15));
#line 106
  goto switch_break;
  case_22: /* CIL Label */ 
#line 108
  e->fxt = (uint8 )14;
#line 109
  e->fxp = (uint8 )((6 << 4) | (parm & 15));
#line 110
  goto switch_break;
  case_23: /* CIL Label */ 
#line 112
  e->fxt = (uint8 )14;
#line 113
  e->fxp = (uint8 )((7 << 4) | (parm & 15));
#line 114
  goto switch_break;
  case_25: /* CIL Label */ 
#line 116
  e->fxt = (uint8 )14;
#line 117
  e->fxp = (uint8 )((9 << 4) | (parm & 15));
#line 118
  goto switch_break;
  case_26: /* CIL Label */ 
#line 120
  e->fxt = (uint8 )14;
#line 121
  e->fxp = (uint8 )((1 << 4) | (parm & 15));
#line 122
  goto switch_break;
  case_27: /* CIL Label */ 
#line 124
  e->fxt = (uint8 )14;
#line 125
  e->fxp = (uint8 )((2 << 4) | (parm & 15));
#line 126
  goto switch_break;
  case_28: /* CIL Label */ 
#line 128
  e->fxt = (uint8 )14;
#line 129
  e->fxp = (uint8 )((12 << 4) | (parm & 15));
#line 130
  goto switch_break;
  case_29: /* CIL Label */ 
#line 132
  e->fxt = (uint8 )14;
#line 133
  e->fxp = (uint8 )((13 << 4) | (parm & 15));
#line 134
  goto switch_break;
  case_30: /* CIL Label */ 
#line 136
  e->fxt = (uint8 )14;
#line 137
  e->fxp = (uint8 )((14 << 4) | (parm & 15));
#line 138
  goto switch_break;
  case_31: /* CIL Label */ 
#line 140
  e->fxt = (uint8 )0;
#line 141
  goto switch_break;
  case_34: /* CIL Label */ 
  case_33: /* CIL Label */ 
  case_32: /* CIL Label */ 
#line 145
  e->fxp = (uint8 )(parm & 255);
#line 146
  e->f2t = (uint8 )161;
#line 147
  e->f2p = (uint8 )(parm >> 8);
#line 148
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 156
  e->fxt = (uint8 )0;
  switch_break: /* CIL Label */ ;
  }
#line 158
  return;
}
}
#line 160 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/sym_load.c"
static uint32 readptr32l(uint8 *p ) 
{ 
  uint32 a ;
  uint32 b___1 ;
  uint32 c___0 ;
  uint32 d ;
  uint8 *tmp ;
  uint8 *tmp___0 ;
  uint8 *tmp___1 ;
  uint8 *tmp___2 ;

  {
#line 164
  tmp = p;
#line 164
  p ++;
#line 164
  a = (uint32 )*tmp;
#line 165
  tmp___0 = p;
#line 165
  p ++;
#line 165
  b___1 = (uint32 )*tmp___0;
#line 166
  tmp___1 = p;
#line 166
  p ++;
#line 166
  c___0 = (uint32 )*tmp___1;
#line 167
  tmp___2 = p;
#line 167
  p ++;
#line 167
  d = (uint32 )*tmp___2;
#line 169
  return ((((d << 24) | (c___0 << 16)) | (b___1 << 8)) | a);
}
}
#line 172 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/sym_load.c"
static uint32 readptr16l(uint8 *p ) 
{ 
  uint32 a ;
  uint32 b___1 ;
  uint8 *tmp ;
  uint8 *tmp___0 ;

  {
#line 176
  tmp = p;
#line 176
  p ++;
#line 176
  a = (uint32 )*tmp;
#line 177
  tmp___0 = p;
#line 177
  p ++;
#line 177
  b___1 = (uint32 )*tmp___0;
#line 179
  return ((b___1 << 8) | a);
}
}
#line 182 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/sym_load.c"
static int sym_load(struct xmp_context *ctx___0 , FILE *f , int const   start ) 
{ 
  struct xmp_player_context *p ;
  struct xmp_mod_context *m___0 ;
  struct xxm_event *event ;
  int i___3 ;
  int j ;
  int ver___0 ;
  int infolen ;
  int sn[64] ;
  uint32 a ;
  uint32 b___1 ;
  uint8 *buf___1 ;
  int size___0 ;
  uint8 **tmp ;
  uint8 tmp___0 ;
  uint8 tmp___1 ;
  int tmp___2 ;
  uint16 tmp___3 ;
  uint16 tmp___4 ;
  uint32 tmp___5 ;
  int tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  void *tmp___9 ;
  void *tmp___10 ;
  void *tmp___11 ;
  void *tmp___12 ;
  void *tmp___13 ;
  void *tmp___14 ;
  uint8 tmp___15 ;
  uint32 tmp___16 ;
  uint8 tmp___17 ;
  void *tmp___18 ;
  void *tmp___19 ;
  uint8 tmp___20 ;
  char const   *tmp___21 ;
  void *tmp___22 ;
  void *tmp___23 ;
  int idx___0 ;
  uint32 tmp___24 ;
  uint8 tmp___25 ;
  char const   *tmp___26 ;
  void *tmp___27 ;
  void *tmp___28 ;
  int parm ;
  void *tmp___29 ;
  uint8 buf___2[128] ;
  int looplen ;
  uint32 tmp___30 ;
  uint32 tmp___31 ;
  uint8 tmp___32 ;
  uint8 tmp___33 ;
  int tmp___34 ;
  size_t tmp___35 ;
  uint8 tmp___36 ;
  uint8 *b___2 ;
  void *tmp___37 ;
  void *__cil_tmp60 ;
  void *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;
  char *__cil_tmp66 ;
  char *__cil_tmp67 ;
  char *__cil_tmp68 ;
  char *__cil_tmp69 ;
  char *__cil_tmp70 ;
  char *__cil_tmp71 ;
  char *__cil_tmp72 ;
  char *__cil_tmp73 ;
  char *__cil_tmp74 ;
  char *__cil_tmp75 ;
  char *__cil_tmp76 ;
  char *__cil_tmp77 ;
  char *__cil_tmp78 ;
  char *__cil_tmp79 ;
  char *__cil_tmp80 ;
  char *__cil_tmp81 ;
  char *__cil_tmp82 ;

  {
#line 184
  p = & ctx___0->p;
#line 185
  m___0 = & p->m;
  {
#line 193
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 193
    fseek(f, (long )start, 0);
#line 193
    tmp = (uint8 **)((void *)0);
#line 193
    m___0->med_wav_table = tmp;
#line 193
    m___0->med_vol_table = tmp;
#line 193
    set_xxh_defaults(m___0->xxh);
    }
#line 193
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 195
  fseek(f, 8L, 1);
#line 197
  tmp___0 = read8(f);
#line 197
  ver___0 = (int )tmp___0;
#line 198
  sprintf((char */* __restrict  */)(m___0->type), (char const   */* __restrict  */)"BASSTRAK v%d (Digital Symphony)",
          ver___0);
#line 200
  tmp___1 = read8(f);
#line 200
  (m___0->xxh)->chn = (int )tmp___1;
#line 201
  tmp___3 = read16l(f);
#line 201
  tmp___2 = (int )tmp___3;
#line 201
  (m___0->xxh)->pat = tmp___2;
#line 201
  (m___0->xxh)->len = tmp___2;
#line 202
  tmp___4 = read16l(f);
#line 202
  (m___0->xxh)->trk = (int )tmp___4;
#line 203
  tmp___5 = read24l(f);
#line 203
  infolen = (int )tmp___5;
#line 205
  tmp___6 = 63;
#line 205
  (m___0->xxh)->smp = tmp___6;
#line 205
  (m___0->xxh)->ins = tmp___6;
  }
  {
#line 207
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 207
    tmp___7 = calloc((size_t )sizeof(struct xxm_instrument_header ), (size_t )(m___0->xxh)->ins);
#line 207
    m___0->xxih = (struct xxm_instrument_header *)tmp___7;
#line 207
    tmp___8 = calloc((size_t )sizeof(struct xxm_instrument_map ), (size_t )(m___0->xxh)->ins);
#line 207
    m___0->xxim = (struct xxm_instrument_map *)tmp___8;
#line 207
    tmp___9 = calloc((size_t )sizeof(struct xxm_instrument *), (size_t )(m___0->xxh)->ins);
#line 207
    m___0->xxi = (struct xxm_instrument **)tmp___9;
    }
#line 207
    if ((m___0->xxh)->smp) {
      {
#line 207
      tmp___10 = calloc((size_t )sizeof(struct xxm_sample ), (size_t )(m___0->xxh)->smp);
#line 207
      m___0->xxs = (struct xxm_sample *)tmp___10;
      }
    }
    {
#line 207
    tmp___11 = calloc((size_t )sizeof(uint16 *), (size_t )(m___0->xxh)->ins);
#line 207
    m___0->xxae = (uint16 **)tmp___11;
#line 207
    tmp___12 = calloc((size_t )sizeof(uint16 *), (size_t )(m___0->xxh)->ins);
#line 207
    m___0->xxpe = (uint16 **)tmp___12;
#line 207
    tmp___13 = calloc((size_t )sizeof(uint16 *), (size_t )(m___0->xxh)->ins);
#line 207
    m___0->xxfe = (uint16 **)tmp___13;
    }
#line 207
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 209
  i___3 = 0;
  {
#line 209
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 209
    if (! (i___3 < (m___0->xxh)->ins)) {
#line 209
      goto while_break___1;
    }
    {
#line 210
    tmp___14 = calloc((size_t )sizeof(struct xxm_instrument ), (size_t )1);
#line 210
    *(m___0->xxi + i___3) = (struct xxm_instrument *)tmp___14;
#line 212
    tmp___15 = read8(f);
#line 212
    sn[i___3] = (int )tmp___15;
    }
#line 214
    if (~ sn[i___3] & 128) {
      {
#line 215
      tmp___16 = read24l(f);
#line 215
      (m___0->xxs + i___3)->len = (int )(tmp___16 << 1);
      }
    }
#line 209
    i___3 ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 218
  tmp___17 = read8(f);
#line 218
  a = (uint32 )tmp___17;
#line 220
  fread((void */* __restrict  */)(m___0->name), (size_t )1, a, (FILE */* __restrict  */)f);
#line 221
  fseek(f, 8L, 1);
  }
  {
#line 223
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 223
    if (m___0->verbosity) {
#line 223
      if (m___0->name[0]) {
        {
#line 223
        report((char *)"Module title   : %s\n", m___0->name);
        }
      }
#line 223
      if (m___0->type[0]) {
        {
#line 223
        report((char *)"Module type    : %s\n", m___0->type);
        }
      }
#line 223
      if (m___0->author[0]) {
        {
#line 223
        report((char *)"Author name    : %s\n", m___0->author);
        }
      }
#line 223
      if ((m___0->xxh)->len) {
        {
#line 223
        report((char *)"Module length  : %d patterns\n", (m___0->xxh)->len);
        }
      }
    }
#line 223
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 225
  ((m___0->xxh)->trk) ++;
  {
#line 226
  while (1) {
    while_continue___3: /* CIL Label */ ;
    {
#line 226
    tmp___18 = calloc((size_t )sizeof(struct xxm_track *), (size_t )(m___0->xxh)->trk);
#line 226
    m___0->xxt = (struct xxm_track **)tmp___18;
#line 226
    tmp___19 = calloc((size_t )sizeof(struct xxm_pattern *), (size_t )((m___0->xxh)->pat + 1));
#line 226
    m___0->xxp = (struct xxm_pattern **)tmp___19;
    }
#line 226
    goto while_break___3;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 229
  tmp___20 = read8(f);
#line 229
  a = (uint32 )tmp___20;
  }
#line 231
  if (a != 0U) {
#line 231
    if (a != 1U) {
#line 232
      return (-1);
    }
  }
#line 234
  if (a) {
#line 234
    tmp___21 = "yes";
  } else {
#line 234
    tmp___21 = "no";
  }
  {
#line 234
  reportv(ctx___0, 1, (char *)"Packed sequence: %s\n", tmp___21);
#line 236
  size___0 = ((m___0->xxh)->len * (m___0->xxh)->chn) * 2;
#line 237
  tmp___22 = malloc((size_t )size___0);
#line 237
  buf___1 = (uint8 *)tmp___22;
  }
#line 239
  if (a) {
    {
#line 240
    read_lzw_dynamic(f, buf___1, 13, 0, (unsigned long )size___0, (unsigned long )size___0,
                     (int )((((1L | (1L << 1)) | (1L << 2)) | (1L << 3)) | (1L << 4)));
    }
  } else {
    {
#line 242
    fread((void */* __restrict  */)buf___1, (size_t )1, (size_t )size___0, (FILE */* __restrict  */)f);
    }
  }
#line 245
  i___3 = 0;
  {
#line 245
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 245
    if (! (i___3 < (m___0->xxh)->len)) {
#line 245
      goto while_break___4;
    }
    {
#line 246
    while (1) {
      while_continue___5: /* CIL Label */ ;
      {
#line 246
      tmp___23 = calloc((size_t )1, (size_t )(sizeof(struct xxm_pattern ) + sizeof(struct xxm_trackinfo ) * (unsigned long )((m___0->xxh)->chn - 1)));
#line 246
      *(m___0->xxp + i___3) = (struct xxm_pattern *)tmp___23;
      }
#line 246
      goto while_break___5;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 247
    (*(m___0->xxp + i___3))->rows = 64;
#line 248
    j = 0;
    {
#line 248
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 248
      if (! (j < (m___0->xxh)->chn)) {
#line 248
        goto while_break___6;
      }
      {
#line 249
      idx___0 = 2 * (i___3 * (m___0->xxh)->chn + j);
#line 250
      tmp___24 = readptr16l(buf___1 + idx___0);
#line 250
      (*(m___0->xxp + i___3))->info[j].index = (int )tmp___24;
      }
#line 252
      if ((*(m___0->xxp + i___3))->info[j].index == 4096) {
#line 253
        (*(m___0->xxp + i___3))->info[j].index = (m___0->xxh)->trk - 1;
      }
#line 248
      j ++;
    }
    while_break___6: /* CIL Label */ ;
    }
#line 256
    m___0->xxo[i___3] = (uint8 )i___3;
#line 245
    i___3 ++;
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 258
  free((void *)buf___1);
#line 262
  tmp___25 = read8(f);
#line 262
  a = (uint32 )tmp___25;
  }
#line 264
  if (a != 0U) {
#line 264
    if (a != 1U) {
#line 265
      return (-1);
    }
  }
#line 267
  if (a) {
#line 267
    tmp___26 = "yes";
  } else {
#line 267
    tmp___26 = "no";
  }
  {
#line 267
  reportv(ctx___0, 1, (char *)"Packed tracks  : %s\n", tmp___26);
#line 268
  reportv(ctx___0, 0, (char *)"Stored tracks  : %d ", (m___0->xxh)->trk - 1);
#line 270
  size___0 = (64 * ((m___0->xxh)->trk - 1)) * 4;
#line 271
  tmp___27 = malloc((size_t )size___0);
#line 271
  buf___1 = (uint8 *)tmp___27;
  }
#line 273
  if (a) {
    {
#line 274
    read_lzw_dynamic(f, buf___1, 13, 0, (unsigned long )size___0, (unsigned long )size___0,
                     (int )((((1L | (1L << 1)) | (1L << 2)) | (1L << 3)) | (1L << 4)));
    }
  } else {
    {
#line 276
    fread((void */* __restrict  */)buf___1, (size_t )1, (size_t )size___0, (FILE */* __restrict  */)f);
    }
  }
#line 279
  i___3 = 0;
  {
#line 279
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 279
    if (! (i___3 < (m___0->xxh)->trk - 1)) {
#line 279
      goto while_break___7;
    }
    {
#line 280
    tmp___28 = calloc((size_t )((sizeof(struct xxm_track ) + sizeof(struct xxm_event ) * 64UL) - 1UL),
                      (size_t )1);
#line 280
    *(m___0->xxt + i___3) = (struct xxm_track *)tmp___28;
#line 282
    (*(m___0->xxt + i___3))->rows = 64;
#line 284
    j = 0;
    }
    {
#line 284
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 284
      if (! (j < (*(m___0->xxt + i___3))->rows)) {
#line 284
        goto while_break___8;
      }
      {
#line 287
      event = & (*(m___0->xxt + i___3))->event[j];
#line 289
      b___1 = readptr32l(buf___1 + 4 * (i___3 * 64 + j));
#line 290
      event->note = (uint8 )(b___1 & 63U);
      }
#line 291
      if (event->note) {
#line 292
        event->note = (uint8 )((int )event->note + 36);
      }
      {
#line 293
      event->ins = (uint8 )((b___1 & 8128U) >> 6);
#line 294
      event->fxt = (uint8 )((b___1 & 1032192U) >> 14);
#line 295
      parm = (int )((b___1 & 4293918720U) >> 20);
#line 297
      fix_effect___1(event, parm);
#line 284
      j ++;
      }
    }
    while_break___8: /* CIL Label */ ;
    }
#line 299
    if (m___0->verbosity > 0) {
#line 300
      if (i___3 % (m___0->xxh)->chn == 0) {
        {
#line 301
        reportv(ctx___0, 0, (char *)".");
        }
      }
    }
#line 279
    i___3 ++;
  }
  while_break___7: /* CIL Label */ ;
  }
  {
#line 304
  reportv(ctx___0, 0, (char *)"\n");
#line 306
  free((void *)buf___1);
#line 309
  tmp___29 = calloc((size_t )((sizeof(struct xxm_track ) + sizeof(struct xxm_event ) * 64UL) - 1UL),
                    (size_t )1);
#line 309
  *(m___0->xxt + i___3) = (struct xxm_track *)tmp___29;
#line 311
  (*(m___0->xxt + i___3))->rows = 64;
#line 315
  reportv(ctx___0, 0, (char *)"Instruments    : %d ", (m___0->xxh)->ins);
#line 316
  reportv(ctx___0, 1, (char *)"\n     Instrument Name        Len   LBeg  LEnd  L Vol Fin");
#line 318
  i___3 = 0;
  }
  {
#line 318
  while (1) {
    while_continue___9: /* CIL Label */ ;
#line 318
    if (! (i___3 < (m___0->xxh)->ins)) {
#line 318
      goto while_break___9;
    }
    {
#line 321
    memset((void *)(buf___2), 0, (size_t )128);
#line 322
    fread((void */* __restrict  */)(buf___2), (size_t )1, (size_t )(sn[i___3] & 127),
          (FILE */* __restrict  */)f);
#line 323
    copy_adjust((m___0->xxih + i___3)->name, buf___2, 32);
    }
#line 325
    if (~ sn[i___3] & 128) {
      {
#line 328
      tmp___30 = read24l(f);
#line 328
      (m___0->xxs + i___3)->lps = (int )(tmp___30 << 1);
#line 329
      tmp___31 = read24l(f);
#line 329
      looplen = (int )(tmp___31 << 1);
      }
#line 330
      if (looplen > 2) {
#line 331
        (m___0->xxs + i___3)->flg |= 4;
      }
      {
#line 332
      (m___0->xxs + i___3)->lpe = (m___0->xxs + i___3)->lps + looplen;
#line 333
      (m___0->xxih + i___3)->nsm = 1;
#line 334
      tmp___32 = read8(f);
#line 334
      (*(m___0->xxi + i___3) + 0)->vol = (int )tmp___32;
#line 335
      (*(m___0->xxi + i___3) + 0)->pan = 128;
#line 338
      tmp___33 = read8(f);
#line 338
      (*(m___0->xxi + i___3) + 0)->fin = (int )((int8 )((int )tmp___33 << 3));
#line 339
      (*(m___0->xxi + i___3) + 0)->sid = i___3;
      }
    }
#line 342
    if (m___0->verbosity > 1) {
      {
#line 342
      tmp___35 = strlen((char const   *)((char *)((m___0->xxih + i___3)->name)));
      }
#line 342
      if (tmp___35) {
#line 342
        goto _L;
      } else
#line 342
      if ((m___0->xxs + i___3)->len > 1) {
        _L: /* CIL Label */ 
#line 343
        if ((m___0->xxs + i___3)->flg & 4) {
#line 343
          tmp___34 = 'L';
        } else {
#line 343
          tmp___34 = ' ';
        }
        {
#line 343
        report((char *)"\n[%2X] %-22.22s %05x %05x %05x %c V%02x %+03d ", i___3, (m___0->xxih + i___3)->name,
               (m___0->xxs + i___3)->len, (m___0->xxs + i___3)->lps, (m___0->xxs + i___3)->lpe,
               tmp___34, (*(m___0->xxi + i___3) + 0)->vol, (*(m___0->xxi + i___3) + 0)->fin);
        }
      }
    }
#line 350
    if (sn[i___3] & 128) {
#line 351
      goto __Cont;
    } else
#line 350
    if ((m___0->xxs + i___3)->len == 0) {
#line 351
      goto __Cont;
    }
    {
#line 353
    tmp___36 = read8(f);
#line 353
    a = (uint32 )tmp___36;
    }
#line 355
    if (a != 0U) {
#line 355
      if (a != 1U) {
#line 355
        if (a != 4U) {
#line 356
          return (-1);
        }
      }
    }
#line 358
    if (a == 1U) {
      {
#line 359
      tmp___37 = malloc((size_t )(m___0->xxs + i___3)->len);
#line 359
      b___2 = (uint8 *)tmp___37;
#line 360
      read_lzw_dynamic(f, b___2, 13, 0, (unsigned long )(m___0->xxs + i___3)->len,
                       (unsigned long )(m___0->xxs + i___3)->len, (int )((((1L | (1L << 1)) | (1L << 2)) | (1L << 3)) | (1L << 4)));
#line 362
      xmp_drv_loadpatch(ctx___0, (FILE *)((void *)0), (*(m___0->xxi + i___3) + 0)->sid,
                        m___0->c4rate, 17, m___0->xxs + (*(m___0->xxi + i___3) + 0)->sid,
                        (char *)b___2);
#line 365
      free((void *)b___2);
#line 366
      reportv(ctx___0, 0, (char *)"c");
      }
    } else
#line 367
    if (a == 4U) {
      {
#line 368
      xmp_drv_loadpatch(ctx___0, f, (*(m___0->xxi + i___3) + 0)->sid, m___0->c4rate,
                        128, m___0->xxs + (*(m___0->xxi + i___3) + 0)->sid, (char *)((void *)0));
#line 370
      reportv(ctx___0, 0, (char *)"C");
      }
    } else {
      {
#line 372
      xmp_drv_loadpatch(ctx___0, f, (*(m___0->xxi + i___3) + 0)->sid, m___0->c4rate,
                        128, m___0->xxs + (*(m___0->xxi + i___3) + 0)->sid, (char *)((void *)0));
#line 374
      reportv(ctx___0, 0, (char *)".");
      }
    }
    __Cont: /* CIL Label */ 
#line 318
    i___3 ++;
  }
  while_break___9: /* CIL Label */ ;
  }
  {
#line 377
  reportv(ctx___0, 0, (char *)"\n");
  }
#line 379
  return (0);
}
}
#line 20 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/arch_load.c"
static int arch_test(FILE *f , char *t , int const   start ) ;
#line 21
static int arch_load(struct xmp_context *ctx___0 , FILE *f , int const   start ) ;
#line 23 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/arch_load.c"
struct xmp_loader_info arch_loader  =    {(char *)"MUSX", (char *)"Archimedes Tracker", & arch_test, & arch_load, 0, {(struct list_head *)0,
                                                                                (struct list_head *)0}};
#line 30 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/arch_load.c"
static int arch_test(FILE *f , char *t , int const   start ) 
{ 
  uint32 tmp ;
  uint32 id ;
  uint32 tmp___0 ;
  uint32 len ;
  uint32 tmp___1 ;
  int tmp___2 ;

  {
  {
#line 32
  tmp = read32b(f);
  }
#line 32
  if (tmp != ((((77U << 24) | (85U << 16)) | (83U << 8)) | 88U)) {
#line 33
    return (-1);
  }
  {
#line 35
  read32l(f);
  }
  {
#line 37
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 37
    tmp___2 = feof(f);
    }
#line 37
    if (tmp___2) {
#line 37
      goto while_break;
    }
    {
#line 38
    tmp___0 = read32b(f);
#line 38
    id = tmp___0;
#line 39
    tmp___1 = read32l(f);
#line 39
    len = tmp___1;
    }
#line 41
    if (id == ((((77U << 24) | (78U << 16)) | (65U << 8)) | 77U)) {
      {
#line 42
      read_title(f, t, 32);
      }
#line 43
      return (0);
    }
    {
#line 46
    fseek(f, (long )len, 1);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 49
  read_title(f, t, 0);
  }
#line 51
  return (0);
}
}
#line 55 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/arch_load.c"
static int year___0  ;
#line 55 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/arch_load.c"
static int month___0  ;
#line 55 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/arch_load.c"
static int day___0  ;
#line 56 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/arch_load.c"
static int pflag  ;
#line 56 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/arch_load.c"
static int sflag  ;
#line 56 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/arch_load.c"
static int max_ins  ;
#line 57 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/arch_load.c"
static uint8 ster[8]  ;
#line 57 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/arch_load.c"
static uint8 rows___0[64]  ;
#line 59 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/arch_load.c"
static void fix_effect___2(struct xxm_event *e ) 
{ 
  uint8 tmp ;
  uint8 tmp___0 ;
  uint8 tmp___1 ;

  {
  {
#line 62
  if ((int )e->fxt == 0) {
#line 62
    goto case_0;
  }
#line 67
  if ((int )e->fxt == 1) {
#line 67
    goto case_1;
  }
#line 70
  if ((int )e->fxt == 2) {
#line 70
    goto case_2;
  }
#line 73
  if ((int )e->fxt == 11) {
#line 73
    goto case_11;
  }
#line 76
  if ((int )e->fxt == 14) {
#line 76
    goto case_14;
  }
#line 80
  if ((int )e->fxt == 16) {
#line 80
    goto case_16;
  }
#line 83
  if ((int )e->fxt == 17) {
#line 83
    goto case_17;
  }
#line 86
  if ((int )e->fxt == 19) {
#line 86
    goto case_19;
  }
#line 89
  if ((int )e->fxt == 21) {
#line 89
    goto case_21;
  }
#line 93
  if ((int )e->fxt == 28) {
#line 93
    goto case_28;
  }
#line 96
  if ((int )e->fxt == 31) {
#line 96
    goto case_31;
  }
#line 99
  goto switch_default;
  case_0: /* CIL Label */ 
#line 63
  e->fxt = (uint8 )0;
#line 66
  goto switch_break;
  case_1: /* CIL Label */ 
#line 68
  e->fxt = (uint8 )1;
#line 69
  goto switch_break;
  case_2: /* CIL Label */ 
#line 71
  e->fxt = (uint8 )2;
#line 72
  goto switch_break;
  case_11: /* CIL Label */ 
#line 74
  e->fxt = (uint8 )13;
#line 75
  goto switch_break;
  case_14: /* CIL Label */ 
#line 77
  tmp = (uint8 )0;
#line 77
  e->fxp = tmp;
#line 77
  e->fxt = tmp;
#line 79
  goto switch_break;
  case_16: /* CIL Label */ 
#line 81
  e->fxt = (uint8 )160;
#line 82
  goto switch_break;
  case_17: /* CIL Label */ 
#line 84
  e->fxt = (uint8 )161;
#line 85
  goto switch_break;
  case_19: /* CIL Label */ 
#line 87
  e->fxt = (uint8 )11;
#line 88
  goto switch_break;
  case_21: /* CIL Label */ 
#line 90
  tmp___0 = (uint8 )0;
#line 90
  e->fxp = tmp___0;
#line 90
  e->fxt = tmp___0;
#line 92
  goto switch_break;
  case_28: /* CIL Label */ 
#line 94
  e->fxt = (uint8 )15;
#line 95
  goto switch_break;
  case_31: /* CIL Label */ 
#line 97
  e->fxt = (uint8 )12;
#line 98
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 100
  tmp___1 = (uint8 )0;
#line 100
  e->fxp = tmp___1;
#line 100
  e->fxt = tmp___1;
  switch_break: /* CIL Label */ ;
  }
#line 102
  return;
}
}
#line 104 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/arch_load.c"
static void get_tinf(struct xmp_context *ctx___0 , int size___0 , FILE *f ) 
{ 
  int x ;
  uint8 tmp ;
  uint8 tmp___0 ;
  uint8 tmp___1 ;
  uint8 tmp___2 ;

  {
  {
#line 108
  tmp = read8(f);
#line 108
  x = (int )tmp;
#line 109
  year___0 = ((x & 240) >> 4) * 10 + (x & 15);
#line 110
  tmp___0 = read8(f);
#line 110
  x = (int )tmp___0;
#line 111
  year___0 += ((x & 240) >> 4) * 1000 + (x & 15) * 100;
#line 113
  tmp___1 = read8(f);
#line 113
  x = (int )tmp___1;
#line 114
  month___0 = ((x & 240) >> 4) * 10 + (x & 15);
#line 116
  tmp___2 = read8(f);
#line 116
  x = (int )tmp___2;
#line 117
  day___0 = ((x & 240) >> 4) * 10 + (x & 15);
  }
#line 118
  return;
}
}
#line 120 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/arch_load.c"
static void get_mvox(struct xmp_context *ctx___0 , int size___0 , FILE *f ) 
{ 
  struct xmp_player_context *p ;
  struct xmp_mod_context *m___0 ;
  uint32 tmp ;

  {
  {
#line 122
  p = & ctx___0->p;
#line 123
  m___0 = & p->m;
#line 125
  tmp = read32l(f);
#line 125
  (m___0->xxh)->chn = (int )tmp;
  }
#line 126
  return;
}
}
#line 128 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/arch_load.c"
static void get_ster(struct xmp_context *ctx___0 , int size___0 , FILE *f ) 
{ 


  {
  {
#line 130
  fread((void */* __restrict  */)(ster), (size_t )1, (size_t )8, (FILE */* __restrict  */)f);
  }
#line 131
  return;
}
}
#line 133 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/arch_load.c"
static void get_mnam(struct xmp_context *ctx___0 , int size___0 , FILE *f ) 
{ 
  struct xmp_player_context *p ;
  struct xmp_mod_context *m___0 ;

  {
  {
#line 135
  p = & ctx___0->p;
#line 136
  m___0 = & p->m;
#line 138
  fread((void */* __restrict  */)(m___0->name), (size_t )1, (size_t )32, (FILE */* __restrict  */)f);
  }
#line 139
  return;
}
}
#line 141 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/arch_load.c"
static void get_anam(struct xmp_context *ctx___0 , int size___0 , FILE *f ) 
{ 
  struct xmp_player_context *p ;
  struct xmp_mod_context *m___0 ;

  {
  {
#line 143
  p = & ctx___0->p;
#line 144
  m___0 = & p->m;
#line 146
  fread((void */* __restrict  */)(m___0->author), (size_t )1, (size_t )32, (FILE */* __restrict  */)f);
  }
#line 147
  return;
}
}
#line 149 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/arch_load.c"
static void get_mlen(struct xmp_context *ctx___0 , int size___0 , FILE *f ) 
{ 
  struct xmp_player_context *p ;
  struct xmp_mod_context *m___0 ;
  uint32 tmp ;

  {
  {
#line 151
  p = & ctx___0->p;
#line 152
  m___0 = & p->m;
#line 154
  tmp = read32l(f);
#line 154
  (m___0->xxh)->len = (int )tmp;
  }
#line 155
  return;
}
}
#line 157 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/arch_load.c"
static void get_pnum(struct xmp_context *ctx___0 , int size___0 , FILE *f ) 
{ 
  struct xmp_player_context *p ;
  struct xmp_mod_context *m___0 ;
  uint32 tmp ;

  {
  {
#line 159
  p = & ctx___0->p;
#line 160
  m___0 = & p->m;
#line 162
  tmp = read32l(f);
#line 162
  (m___0->xxh)->pat = (int )tmp;
  }
#line 163
  return;
}
}
#line 165 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/arch_load.c"
static void get_plen(struct xmp_context *ctx___0 , int size___0 , FILE *f ) 
{ 


  {
  {
#line 167
  fread((void */* __restrict  */)(rows___0), (size_t )1, (size_t )64, (FILE */* __restrict  */)f);
  }
#line 168
  return;
}
}
#line 170 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/arch_load.c"
static void get_sequ(struct xmp_context *ctx___0 , int size___0 , FILE *f ) 
{ 
  struct xmp_player_context *p ;
  struct xmp_mod_context *m___0 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
  {
#line 172
  p = & ctx___0->p;
#line 173
  m___0 = & p->m;
#line 175
  fread((void */* __restrict  */)(m___0->xxo), (size_t )1, (size_t )128, (FILE */* __restrict  */)f);
#line 177
  strcpy((char */* __restrict  */)(m___0->type), (char const   */* __restrict  */)"MUSX (Archimedes Tracker)");
  }
  {
#line 179
  while (1) {
    while_continue: /* CIL Label */ ;
#line 179
    if (m___0->verbosity) {
#line 179
      if (m___0->name[0]) {
        {
#line 179
        report((char *)"Module title   : %s\n", m___0->name);
        }
      }
#line 179
      if (m___0->type[0]) {
        {
#line 179
        report((char *)"Module type    : %s\n", m___0->type);
        }
      }
#line 179
      if (m___0->author[0]) {
        {
#line 179
        report((char *)"Author name    : %s\n", m___0->author);
        }
      }
#line 179
      if ((m___0->xxh)->len) {
        {
#line 179
        report((char *)"Module length  : %d patterns\n", (m___0->xxh)->len);
        }
      }
    }
#line 179
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 180
  reportv(ctx___0, 0, (char *)"Creation date  : %02d/%02d/%04d\n", day___0, month___0,
          year___0);
  }
#line 181
  return;
}
}
#line 187
static void get_patt___2(struct xmp_context *ctx___0 , int size___0 , FILE *f ) ;
#line 187 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/arch_load.c"
static int i___0  =    0;
#line 183 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/arch_load.c"
static void get_patt___2(struct xmp_context *ctx___0 , int size___0 , FILE *f ) 
{ 
  struct xmp_player_context *p ;
  struct xmp_mod_context *m___0 ;
  int j ;
  int k ;
  struct xxm_event *event ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  int j___0 ;
  void *tmp___2 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
#line 185
  p = & ctx___0->p;
#line 186
  m___0 = & p->m;
#line 191
  if (! pflag) {
    {
#line 192
    reportv(ctx___0, 0, (char *)"Stored patterns: %d ", (m___0->xxh)->pat);
#line 193
    pflag = 1;
#line 194
    i___0 = 0;
#line 195
    (m___0->xxh)->trk = (m___0->xxh)->pat * (m___0->xxh)->chn;
    }
    {
#line 196
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 196
      tmp = calloc((size_t )sizeof(struct xxm_track *), (size_t )(m___0->xxh)->trk);
#line 196
      m___0->xxt = (struct xxm_track **)tmp;
#line 196
      tmp___0 = calloc((size_t )sizeof(struct xxm_pattern *), (size_t )((m___0->xxh)->pat + 1));
#line 196
      m___0->xxp = (struct xxm_pattern **)tmp___0;
      }
#line 196
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 199
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 199
    tmp___1 = calloc((size_t )1, (size_t )(sizeof(struct xxm_pattern ) + sizeof(struct xxm_trackinfo ) * (unsigned long )((m___0->xxh)->chn - 1)));
#line 199
    *(m___0->xxp + i___0) = (struct xxm_pattern *)tmp___1;
    }
#line 199
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 200
  (*(m___0->xxp + i___0))->rows = (int )rows___0[i___0];
  {
#line 201
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 201
    j___0 = 0;
    {
#line 201
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 201
      if (! (j___0 < (m___0->xxh)->chn)) {
#line 201
        goto while_break___2;
      }
      {
#line 201
      (*(m___0->xxp + i___0))->info[j___0].index = i___0 * (m___0->xxh)->chn + j___0;
#line 201
      tmp___2 = calloc((size_t )(sizeof(struct xxm_track ) + sizeof(struct xxm_event ) * (unsigned long )(*(m___0->xxp + i___0))->rows),
                       (size_t )1);
#line 201
      *(m___0->xxt + (i___0 * (m___0->xxh)->chn + j___0)) = (struct xxm_track *)tmp___2;
#line 201
      (*(m___0->xxt + (i___0 * (m___0->xxh)->chn + j___0)))->rows = (*(m___0->xxp + i___0))->rows;
#line 201
      j___0 ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
#line 201
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 203
  j = 0;
  {
#line 203
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 203
    if (! (j < (int )rows___0[i___0])) {
#line 203
      goto while_break___3;
    }
#line 204
    k = 0;
    {
#line 204
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 204
      if (! (k < (m___0->xxh)->chn)) {
#line 204
        goto while_break___4;
      }
      {
#line 205
      event = & (*(m___0->xxt + (*(m___0->xxp + i___0))->info[k].index))->event[j];
#line 207
      event->fxp = read8(f);
#line 208
      event->fxt = read8(f);
#line 209
      event->ins = read8(f);
#line 210
      event->note = read8(f);
      }
#line 212
      if (event->note) {
#line 213
        event->note = (uint8 )((int )event->note + 36);
      }
      {
#line 215
      fix_effect___2(event);
#line 204
      k ++;
      }
    }
    while_break___4: /* CIL Label */ ;
    }
#line 203
    j ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 219
  i___0 ++;
#line 220
  reportv(ctx___0, 0, (char *)".");
  }
#line 221
  return;
}
}
#line 227
static void get_samp(struct xmp_context *ctx___0 , int size___0 , FILE *f ) ;
#line 227 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/arch_load.c"
static int i___1  =    0;
#line 223 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/arch_load.c"
static void get_samp(struct xmp_context *ctx___0 , int size___0 , FILE *f ) 
{ 
  struct xmp_player_context *p ;
  struct xmp_mod_context *m___0 ;
  int tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  uint32 tmp___8 ;
  uint32 tmp___9 ;
  uint32 tmp___10 ;
  uint32 tmp___11 ;
  int tmp___12 ;
  size_t tmp___13 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;

  {
#line 225
  p = & ctx___0->p;
#line 226
  m___0 = & p->m;
#line 229
  if (! sflag) {
#line 230
    tmp = 36;
#line 230
    (m___0->xxh)->ins = tmp;
#line 230
    (m___0->xxh)->smp = tmp;
    {
#line 231
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 231
      tmp___0 = calloc((size_t )sizeof(struct xxm_instrument_header ), (size_t )(m___0->xxh)->ins);
#line 231
      m___0->xxih = (struct xxm_instrument_header *)tmp___0;
#line 231
      tmp___1 = calloc((size_t )sizeof(struct xxm_instrument_map ), (size_t )(m___0->xxh)->ins);
#line 231
      m___0->xxim = (struct xxm_instrument_map *)tmp___1;
#line 231
      tmp___2 = calloc((size_t )sizeof(struct xxm_instrument *), (size_t )(m___0->xxh)->ins);
#line 231
      m___0->xxi = (struct xxm_instrument **)tmp___2;
      }
#line 231
      if ((m___0->xxh)->smp) {
        {
#line 231
        tmp___3 = calloc((size_t )sizeof(struct xxm_sample ), (size_t )(m___0->xxh)->smp);
#line 231
        m___0->xxs = (struct xxm_sample *)tmp___3;
        }
      }
      {
#line 231
      tmp___4 = calloc((size_t )sizeof(uint16 *), (size_t )(m___0->xxh)->ins);
#line 231
      m___0->xxae = (uint16 **)tmp___4;
#line 231
      tmp___5 = calloc((size_t )sizeof(uint16 *), (size_t )(m___0->xxh)->ins);
#line 231
      m___0->xxpe = (uint16 **)tmp___5;
#line 231
      tmp___6 = calloc((size_t )sizeof(uint16 *), (size_t )(m___0->xxh)->ins);
#line 231
      m___0->xxfe = (uint16 **)tmp___6;
      }
#line 231
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 232
    reportv(ctx___0, 0, (char *)"\nInstruments    : %d ", (m___0->xxh)->ins);
#line 233
    reportv(ctx___0, 1, (char *)"\n     Instrument name      Len   LBeg  LEnd  L Vol");
#line 234
    sflag = 1;
#line 235
    max_ins = 0;
#line 236
    i___1 = 0;
    }
  }
  {
#line 239
  tmp___7 = calloc((size_t )sizeof(struct xxm_instrument ), (size_t )1);
#line 239
  *(m___0->xxi + i___1) = (struct xxm_instrument *)tmp___7;
#line 240
  read32l(f);
#line 241
  read32l(f);
#line 242
  fread((void */* __restrict  */)((m___0->xxih + i___1)->name), (size_t )1, (size_t )20,
        (FILE */* __restrict  */)f);
#line 243
  read32l(f);
#line 244
  read32l(f);
#line 245
  tmp___8 = read32l(f);
#line 245
  (*(m___0->xxi + i___1) + 0)->vol = (int )(tmp___8 >> 2);
#line 246
  read32l(f);
#line 247
  read32l(f);
#line 248
  tmp___9 = read32l(f);
#line 248
  (m___0->xxs + i___1)->len = (int )tmp___9;
#line 249
  read32l(f);
#line 250
  read32l(f);
#line 251
  tmp___10 = read32l(f);
#line 251
  (m___0->xxs + i___1)->lps = (int )tmp___10;
#line 252
  read32l(f);
#line 253
  read32l(f);
#line 254
  tmp___11 = read32l(f);
#line 254
  (m___0->xxs + i___1)->lpe = (int )tmp___11;
#line 255
  read32l(f);
#line 256
  read32l(f);
#line 257
  read32l(f);
#line 259
  (m___0->xxih + i___1)->nsm = 1;
#line 260
  (*(m___0->xxi + i___1) + 0)->sid = i___1;
#line 261
  (*(m___0->xxi + i___1) + 0)->pan = 128;
  }
#line 263
  if ((m___0->xxs + i___1)->lpe > 2) {
#line 264
    (m___0->xxs + i___1)->flg = 4;
#line 265
    (m___0->xxs + i___1)->lpe = (m___0->xxs + i___1)->lps + (m___0->xxs + i___1)->lpe;
  }
  {
#line 268
  xmp_drv_loadpatch(ctx___0, f, (*(m___0->xxi + i___1) + 0)->sid, m___0->c4rate, 128,
                    m___0->xxs + (*(m___0->xxi + i___1) + 0)->sid, (char *)((void *)0));
#line 271
  tmp___13 = strlen((char const   *)((char *)((m___0->xxih + i___1)->name)));
  }
#line 271
  if (tmp___13) {
#line 271
    goto _L;
  } else
#line 271
  if ((m___0->xxs + i___1)->len > 0) {
    _L: /* CIL Label */ 
#line 272
    if (m___0->verbosity > 1) {
#line 273
      if ((m___0->xxs + i___1)->flg & 4) {
#line 273
        tmp___12 = 'L';
      } else {
#line 273
        tmp___12 = ' ';
      }
      {
#line 273
      report((char *)"\n[%2X] %-20.20s %05x %05x %05x %c V%02x", i___1, (m___0->xxih + i___1)->name,
             (m___0->xxs + i___1)->len, (m___0->xxs + i___1)->lps, (m___0->xxs + i___1)->lpe,
             tmp___12, (*(m___0->xxi + i___1) + 0)->vol);
      }
    } else {
      {
#line 281
      reportv(ctx___0, 0, (char *)".");
      }
    }
  }
#line 284
  i___1 ++;
#line 285
  max_ins ++;
#line 286
  return;
}
}
#line 288 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/arch_load.c"
static int arch_load(struct xmp_context *ctx___0 , FILE *f , int const   start ) 
{ 
  struct xmp_player_context *p ;
  struct xmp_mod_context *m___0 ;
  uint8 **tmp ;
  int tmp___0 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;

  {
#line 290
  p = & ctx___0->p;
#line 291
  m___0 = & p->m;
  {
#line 293
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 293
    fseek(f, (long )start, 0);
#line 293
    tmp = (uint8 **)((void *)0);
#line 293
    m___0->med_wav_table = tmp;
#line 293
    m___0->med_vol_table = tmp;
#line 293
    set_xxh_defaults(m___0->xxh);
    }
#line 293
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 295
  read32b(f);
#line 296
  read32b(f);
#line 298
  sflag = 0;
#line 298
  pflag = sflag;
#line 301
  iff_register((char *)"TINF", & get_tinf);
#line 302
  iff_register((char *)"MVOX", & get_mvox);
#line 303
  iff_register((char *)"STER", & get_ster);
#line 304
  iff_register((char *)"MNAM", & get_mnam);
#line 305
  iff_register((char *)"ANAM", & get_anam);
#line 306
  iff_register((char *)"MLEN", & get_mlen);
#line 307
  iff_register((char *)"PNUM", & get_pnum);
#line 308
  iff_register((char *)"PLEN", & get_plen);
#line 309
  iff_register((char *)"SEQU", & get_sequ);
#line 310
  iff_register((char *)"PATT", & get_patt___2);
#line 311
  iff_register((char *)"SAMP", & get_samp);
#line 313
  iff_setflag(1);
  }
  {
#line 316
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 316
    tmp___0 = feof(f);
    }
#line 316
    if (tmp___0) {
#line 316
      goto while_break___0;
    }
    {
#line 317
    iff_chunk(ctx___0, f);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 319
  reportv(ctx___0, 0, (char *)"\n");
#line 321
  iff_release();
  }
#line 323
  return (0);
}
}
#line 21 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/no_load.c"
static int no_test(FILE *f , char *t , int const   start ) ;
#line 22
static int no_load(struct xmp_context *ctx___0 , FILE *f , int const   start ) ;
#line 24 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/no_load.c"
struct xmp_loader_info no_loader  =    {(char *)"NO", (char *)"Liquid Tracker (old)", & no_test, & no_load, 0, {(struct list_head *)0,
                                                                            (struct list_head *)0}};
#line 31 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/no_load.c"
static int no_test(FILE *f , char *t , int const   start ) 
{ 
  uint32 tmp ;
  uint8 tmp___0 ;

  {
  {
#line 33
  tmp = read32b(f);
  }
#line 33
  if (tmp != 1313800192U) {
#line 34
    return (-1);
  }
  {
#line 36
  tmp___0 = read8(f);
#line 36
  read_title(f, t, (int )tmp___0);
  }
#line 38
  return (0);
}
}
#line 42 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/no_load.c"
static uint8 fx[15]  = 
#line 42
  {      (uint8 )0,      (uint8 )0,      (uint8 )13,      (uint8 )0, 
        (uint8 )0,      (uint8 )0,      (uint8 )0,      (uint8 )0, 
        (uint8 )0,      (uint8 )0,      (uint8 )0,      (uint8 )0, 
        (uint8 )0,      (uint8 )0,      (uint8 )0};
#line 61 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/no_load.c"
static int no_load(struct xmp_context *ctx___0 , FILE *f , int const   start ) 
{ 
  struct xmp_player_context *p ;
  struct xmp_mod_context *m___0 ;
  struct xxm_event *event ;
  int i___3 ;
  int j ;
  int k ;
  int nsize ;
  uint8 **tmp ;
  uint8 tmp___0 ;
  uint8 x ;
  uint8 tmp___1 ;
  uint8 tmp___2 ;
  uint8 tmp___3 ;
  int tmp___4 ;
  uint8 x___0 ;
  uint8 tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  void *tmp___9 ;
  void *tmp___10 ;
  void *tmp___11 ;
  void *tmp___12 ;
  int hasname ;
  int c2spd___0 ;
  void *tmp___13 ;
  uint8 tmp___14 ;
  uint8 x___1 ;
  uint8 tmp___15 ;
  uint8 tmp___16 ;
  uint16 tmp___17 ;
  uint16 tmp___18 ;
  uint16 tmp___19 ;
  uint16 tmp___20 ;
  int tmp___21 ;
  size_t tmp___22 ;
  void *tmp___23 ;
  void *tmp___24 ;
  void *tmp___25 ;
  int j___0 ;
  void *tmp___26 ;
  uint32 x___2 ;
  uint32 note ;
  uint32 ins ;
  uint32 vol ;
  uint32 fxt ;
  uint32 fxp ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;

  {
#line 63
  p = & ctx___0->p;
#line 64
  m___0 = & p->m;
  {
#line 69
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 69
    fseek(f, (long )start, 0);
#line 69
    tmp = (uint8 **)((void *)0);
#line 69
    m___0->med_wav_table = tmp;
#line 69
    m___0->med_vol_table = tmp;
#line 69
    set_xxh_defaults(m___0->xxh);
    }
#line 69
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 71
  read32b(f);
#line 73
  strcpy((char */* __restrict  */)(m___0->type), (char const   */* __restrict  */)"NO (old Liquid Tracker)");
#line 75
  tmp___0 = read8(f);
#line 75
  nsize = (int )tmp___0;
#line 76
  i___3 = 0;
  }
  {
#line 76
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 76
    if (! (i___3 < nsize)) {
#line 76
      goto while_break___0;
    }
    {
#line 77
    tmp___1 = read8(f);
#line 77
    x = tmp___1;
    }
#line 78
    if (i___3 < 64) {
#line 79
      m___0->name[i___3] = (char )x;
    }
#line 76
    i___3 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 82
  read16l(f);
#line 83
  read16l(f);
#line 84
  read16l(f);
#line 85
  read16l(f);
#line 86
  read8(f);
#line 87
  tmp___2 = read8(f);
#line 87
  (m___0->xxh)->pat = (int )tmp___2;
#line 88
  read8(f);
#line 89
  tmp___3 = read8(f);
#line 89
  (m___0->xxh)->chn = (int )tmp___3;
#line 90
  (m___0->xxh)->trk = (m___0->xxh)->pat * (m___0->xxh)->chn;
#line 91
  read8(f);
#line 92
  read16l(f);
#line 93
  read16l(f);
#line 94
  read8(f);
#line 95
  tmp___4 = 63;
#line 95
  (m___0->xxh)->smp = tmp___4;
#line 95
  (m___0->xxh)->ins = tmp___4;
#line 97
  i___3 = 0;
  }
  {
#line 97
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 97
    if (! (i___3 < 256)) {
#line 97
      goto while_break___1;
    }
    {
#line 98
    tmp___5 = read8(f);
#line 98
    x___0 = tmp___5;
    }
#line 99
    if ((int )x___0 == 255) {
#line 100
      goto while_break___1;
    }
#line 101
    m___0->xxo[i___3] = x___0;
#line 97
    i___3 ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 103
  fseek(f, (long )(255 - i___3), 1);
#line 104
  (m___0->xxh)->len = i___3;
  }
  {
#line 106
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 106
    if (m___0->verbosity) {
#line 106
      if (m___0->name[0]) {
        {
#line 106
        report((char *)"Module title   : %s\n", m___0->name);
        }
      }
#line 106
      if (m___0->type[0]) {
        {
#line 106
        report((char *)"Module type    : %s\n", m___0->type);
        }
      }
#line 106
      if (m___0->author[0]) {
        {
#line 106
        report((char *)"Author name    : %s\n", m___0->author);
        }
      }
#line 106
      if ((m___0->xxh)->len) {
        {
#line 106
        report((char *)"Module length  : %d patterns\n", (m___0->xxh)->len);
        }
      }
    }
#line 106
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 108
  while (1) {
    while_continue___3: /* CIL Label */ ;
    {
#line 108
    tmp___6 = calloc((size_t )sizeof(struct xxm_instrument_header ), (size_t )(m___0->xxh)->ins);
#line 108
    m___0->xxih = (struct xxm_instrument_header *)tmp___6;
#line 108
    tmp___7 = calloc((size_t )sizeof(struct xxm_instrument_map ), (size_t )(m___0->xxh)->ins);
#line 108
    m___0->xxim = (struct xxm_instrument_map *)tmp___7;
#line 108
    tmp___8 = calloc((size_t )sizeof(struct xxm_instrument *), (size_t )(m___0->xxh)->ins);
#line 108
    m___0->xxi = (struct xxm_instrument **)tmp___8;
    }
#line 108
    if ((m___0->xxh)->smp) {
      {
#line 108
      tmp___9 = calloc((size_t )sizeof(struct xxm_sample ), (size_t )(m___0->xxh)->smp);
#line 108
      m___0->xxs = (struct xxm_sample *)tmp___9;
      }
    }
    {
#line 108
    tmp___10 = calloc((size_t )sizeof(uint16 *), (size_t )(m___0->xxh)->ins);
#line 108
    m___0->xxae = (uint16 **)tmp___10;
#line 108
    tmp___11 = calloc((size_t )sizeof(uint16 *), (size_t )(m___0->xxh)->ins);
#line 108
    m___0->xxpe = (uint16 **)tmp___11;
#line 108
    tmp___12 = calloc((size_t )sizeof(uint16 *), (size_t )(m___0->xxh)->ins);
#line 108
    m___0->xxfe = (uint16 **)tmp___12;
    }
#line 108
    goto while_break___3;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 109
  reportv(ctx___0, 1, (char *)"     Instrument name         SLen SBeg SEnd L Vol C2spd\n");
#line 112
  i___3 = 0;
  }
  {
#line 112
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 112
    if (! (i___3 < (m___0->xxh)->ins)) {
#line 112
      goto while_break___4;
    }
    {
#line 115
    tmp___13 = calloc((size_t )sizeof(struct xxm_instrument ), (size_t )1);
#line 115
    *(m___0->xxi + i___3) = (struct xxm_instrument *)tmp___13;
#line 117
    tmp___14 = read8(f);
#line 117
    nsize = (int )tmp___14;
#line 118
    hasname = 0;
#line 119
    j = 0;
    }
    {
#line 119
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 119
      if (! (j < nsize)) {
#line 119
        goto while_break___5;
      }
      {
#line 120
      tmp___15 = read8(f);
#line 120
      x___1 = tmp___15;
      }
#line 121
      if ((int )x___1 != 32) {
#line 122
        hasname = 1;
      }
#line 123
      if (j < 32) {
#line 124
        (m___0->xxih + i___3)->name[j] = x___1;
      }
#line 119
      j ++;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 126
    if (! hasname) {
#line 127
      (m___0->xxih + i___3)->name[0] = (uint8 )0;
    }
    {
#line 129
    read32l(f);
#line 130
    read32l(f);
#line 131
    tmp___16 = read8(f);
#line 131
    (*(m___0->xxi + i___3) + 0)->vol = (int )tmp___16;
#line 132
    tmp___17 = read16l(f);
#line 132
    c2spd___0 = (int )tmp___17;
#line 133
    tmp___18 = read16l(f);
#line 133
    (m___0->xxs + i___3)->len = (int )tmp___18;
#line 134
    tmp___19 = read16l(f);
#line 134
    (m___0->xxs + i___3)->lps = (int )tmp___19;
#line 135
    tmp___20 = read16l(f);
#line 135
    (m___0->xxs + i___3)->lpe = (int )tmp___20;
#line 136
    read32l(f);
#line 137
    read16l(f);
#line 139
    (m___0->xxih + i___3)->nsm = ! (! (m___0->xxs + i___3)->len);
#line 140
    (m___0->xxs + i___3)->lps = 0;
#line 141
    (m___0->xxs + i___3)->lpe = 0;
    }
#line 142
    if ((m___0->xxs + i___3)->lpe > 0) {
#line 142
      (m___0->xxs + i___3)->flg = 4;
    } else {
#line 142
      (m___0->xxs + i___3)->flg = 0;
    }
#line 143
    (*(m___0->xxi + i___3) + 0)->fin = 0;
#line 144
    (*(m___0->xxi + i___3) + 0)->pan = 128;
#line 145
    (*(m___0->xxi + i___3) + 0)->sid = i___3;
#line 147
    if (m___0->verbosity > 1) {
      {
#line 147
      tmp___22 = strlen((char const   *)((char *)((m___0->xxih + i___3)->name)));
      }
#line 147
      if (tmp___22) {
#line 147
        goto _L;
      } else
#line 147
      if ((m___0->xxs + i___3)->len > 1) {
        _L: /* CIL Label */ 
#line 148
        if ((m___0->xxs + i___3)->flg & 4) {
#line 148
          tmp___21 = 'L';
        } else {
#line 148
          tmp___21 = ' ';
        }
        {
#line 148
        report((char *)"[%2X] %-22.22s  %04x %04x %04x %c V%02x %5d\n", i___3, (m___0->xxih + i___3)->name,
               (m___0->xxs + i___3)->len, (m___0->xxs + i___3)->lps, (m___0->xxs + i___3)->lpe,
               tmp___21, (*(m___0->xxi + i___3) + 0)->vol, c2spd___0);
        }
      }
    }
    {
#line 155
    c2spd___0 = (8363 * c2spd___0) / 8448;
#line 156
    c2spd_to_note(c2spd___0, & (*(m___0->xxi + i___3) + 0)->xpo, & (*(m___0->xxi + i___3) + 0)->fin);
#line 112
    i___3 ++;
    }
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 159
  while (1) {
    while_continue___6: /* CIL Label */ ;
    {
#line 159
    tmp___23 = calloc((size_t )sizeof(struct xxm_track *), (size_t )(m___0->xxh)->trk);
#line 159
    m___0->xxt = (struct xxm_track **)tmp___23;
#line 159
    tmp___24 = calloc((size_t )sizeof(struct xxm_pattern *), (size_t )((m___0->xxh)->pat + 1));
#line 159
    m___0->xxp = (struct xxm_pattern **)tmp___24;
    }
#line 159
    goto while_break___6;
  }
  while_break___6: /* CIL Label */ ;
  }
  {
#line 162
  reportv(ctx___0, 0, (char *)"Stored patterns: %d ", (m___0->xxh)->pat);
#line 164
  i___3 = 0;
  }
  {
#line 164
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 164
    if (! (i___3 < (m___0->xxh)->pat)) {
#line 164
      goto while_break___7;
    }
    {
#line 166
    while (1) {
      while_continue___8: /* CIL Label */ ;
      {
#line 166
      tmp___25 = calloc((size_t )1, (size_t )(sizeof(struct xxm_pattern ) + sizeof(struct xxm_trackinfo ) * (unsigned long )((m___0->xxh)->chn - 1)));
#line 166
      *(m___0->xxp + i___3) = (struct xxm_pattern *)tmp___25;
      }
#line 166
      goto while_break___8;
    }
    while_break___8: /* CIL Label */ ;
    }
#line 167
    (*(m___0->xxp + i___3))->rows = 64;
    {
#line 168
    while (1) {
      while_continue___9: /* CIL Label */ ;
#line 168
      j___0 = 0;
      {
#line 168
      while (1) {
        while_continue___10: /* CIL Label */ ;
#line 168
        if (! (j___0 < (m___0->xxh)->chn)) {
#line 168
          goto while_break___10;
        }
        {
#line 168
        (*(m___0->xxp + i___3))->info[j___0].index = i___3 * (m___0->xxh)->chn + j___0;
#line 168
        tmp___26 = calloc((size_t )(sizeof(struct xxm_track ) + sizeof(struct xxm_event ) * (unsigned long )(*(m___0->xxp + i___3))->rows),
                          (size_t )1);
#line 168
        *(m___0->xxt + (i___3 * (m___0->xxh)->chn + j___0)) = (struct xxm_track *)tmp___26;
#line 168
        (*(m___0->xxt + (i___3 * (m___0->xxh)->chn + j___0)))->rows = (*(m___0->xxp + i___3))->rows;
#line 168
        j___0 ++;
        }
      }
      while_break___10: /* CIL Label */ ;
      }
#line 168
      goto while_break___9;
    }
    while_break___9: /* CIL Label */ ;
    }
#line 170
    j = 0;
    {
#line 170
    while (1) {
      while_continue___11: /* CIL Label */ ;
#line 170
      if (! (j < (*(m___0->xxp + i___3))->rows)) {
#line 170
        goto while_break___11;
      }
#line 171
      k = 0;
      {
#line 171
      while (1) {
        while_continue___12: /* CIL Label */ ;
#line 171
        if (! (k < (m___0->xxh)->chn)) {
#line 171
          goto while_break___12;
        }
        {
#line 174
        event = & (*(m___0->xxt + (*(m___0->xxp + i___3))->info[k].index))->event[j];
#line 176
        x___2 = read32l(f);
#line 177
        note = x___2 & 63U;
#line 178
        ins = (x___2 & 8128U) >> 6;
#line 179
        vol = (x___2 & 1040384U) >> 13;
#line 180
        fxt = (x___2 & 15728640U) >> 20;
#line 181
        fxp = (x___2 & 4278190080U) >> 24;
        }
#line 183
        if (note != 63U) {
#line 184
          event->note = (uint8 )(24U + note);
        }
#line 185
        if (ins != 127U) {
#line 186
          event->ins = (uint8 )(1U + ins);
        }
#line 187
        if (vol != 127U) {
#line 188
          event->vol = (uint8 )vol;
        }
#line 189
        if (fxt != 15U) {
#line 190
          event->fxt = fx[fxt];
#line 191
          event->fxp = (uint8 )fxp;
        }
#line 171
        k ++;
      }
      while_break___12: /* CIL Label */ ;
      }
#line 170
      j ++;
    }
    while_break___11: /* CIL Label */ ;
    }
    {
#line 195
    reportv(ctx___0, 0, (char *)".");
#line 164
    i___3 ++;
    }
  }
  while_break___7: /* CIL Label */ ;
  }
  {
#line 197
  reportv(ctx___0, 0, (char *)"\n");
#line 200
  reportv(ctx___0, 0, (char *)"Stored samples : %d ", (m___0->xxh)->smp);
#line 201
  i___3 = 0;
  }
  {
#line 201
  while (1) {
    while_continue___13: /* CIL Label */ ;
#line 201
    if (! (i___3 < (m___0->xxh)->ins)) {
#line 201
      goto while_break___13;
    }
#line 202
    if ((m___0->xxs + i___3)->len == 0) {
#line 203
      goto __Cont;
    }
    {
#line 204
    xmp_drv_loadpatch(ctx___0, f, (*(m___0->xxi + i___3) + 0)->sid, m___0->c4rate,
                      2, m___0->xxs + (*(m___0->xxi + i___3) + 0)->sid, (char *)((void *)0));
#line 206
    reportv(ctx___0, 0, (char *)".");
    }
    __Cont: /* CIL Label */ 
#line 201
    i___3 ++;
  }
  while_break___13: /* CIL Label */ ;
  }
  {
#line 208
  reportv(ctx___0, 0, (char *)"\n");
  }
#line 210
  return (0);
}
}
#line 17 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/gtk_load.c"
static int gtk_test(FILE *f , char *t , int const   start ) ;
#line 18
static int gtk_load(struct xmp_context *ctx___0 , FILE *f , int const   start ) ;
#line 20 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/gtk_load.c"
struct xmp_loader_info gtk_loader  =    {(char *)"GTK", (char *)"Graoumf Tracker", & gtk_test, & gtk_load, 0, {(struct list_head *)0,
                                                                          (struct list_head *)0}};
#line 27 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/gtk_load.c"
static int gtk_test(FILE *f , char *t , int const   start ) 
{ 
  char buf___1[4] ;
  int tmp ;
  void *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
  {
#line 31
  fread((void */* __restrict  */)(buf___1), (size_t )4, (size_t )1, (FILE */* __restrict  */)f);
#line 32
  tmp = memcmp((void const   *)(buf___1), (void const   *)"GTK", (size_t )3);
  }
#line 32
  if (tmp) {
#line 33
    return (-1);
  } else
#line 32
  if ((int )buf___1[3] > 4) {
#line 33
    return (-1);
  }
  {
#line 35
  read_title(f, t, 32);
  }
#line 37
  return (0);
}
}
#line 40 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/gtk_load.c"
static int gtk_load(struct xmp_context *ctx___0 , FILE *f , int const   start ) 
{ 
  struct xmp_player_context *p ;
  struct xmp_mod_context *m___0 ;
  struct xxm_event *event ;
  int i___3 ;
  int j ;
  int k ;
  uint8 buffer[40] ;
  int rows___1 ;
  int bits ;
  int c2spd___0 ;
  int size___0 ;
  int ver___0 ;
  int patmax ;
  uint8 **tmp ;
  uint16 tmp___0 ;
  uint16 tmp___1 ;
  uint16 tmp___2 ;
  uint16 tmp___3 ;
  uint16 tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  void *tmp___9 ;
  void *tmp___10 ;
  void *tmp___11 ;
  void *tmp___12 ;
  uint32 tmp___13 ;
  uint32 tmp___14 ;
  uint32 tmp___15 ;
  uint16 tmp___16 ;
  uint16 tmp___17 ;
  uint32 tmp___18 ;
  uint32 tmp___19 ;
  uint32 tmp___20 ;
  uint16 tmp___21 ;
  int8 tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  size_t tmp___26 ;
  uint16 tmp___27 ;
  void *tmp___28 ;
  void *tmp___29 ;
  void *tmp___30 ;
  int j___0 ;
  void *tmp___31 ;
  void *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;
  char *__cil_tmp66 ;
  char *__cil_tmp67 ;

  {
#line 42
  p = & ctx___0->p;
#line 43
  m___0 = & p->m;
  {
#line 50
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 50
    fseek(f, (long )start, 0);
#line 50
    tmp = (uint8 **)((void *)0);
#line 50
    m___0->med_wav_table = tmp;
#line 50
    m___0->med_vol_table = tmp;
#line 50
    set_xxh_defaults(m___0->xxh);
    }
#line 50
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 52
  fread((void */* __restrict  */)(buffer), (size_t )4, (size_t )1, (FILE */* __restrict  */)f);
#line 53
  ver___0 = (int )buffer[3];
#line 54
  fread((void */* __restrict  */)(m___0->name), (size_t )32, (size_t )1, (FILE */* __restrict  */)f);
#line 55
  sprintf((char */* __restrict  */)(m___0->type), (char const   */* __restrict  */)"GTK v%d (Graoumf Tracker)",
          ver___0);
#line 56
  fseek(f, 160L, 1);
#line 58
  tmp___0 = read16b(f);
#line 58
  (m___0->xxh)->ins = (int )tmp___0;
#line 59
  (m___0->xxh)->smp = (m___0->xxh)->ins;
#line 60
  tmp___1 = read16b(f);
#line 60
  rows___1 = (int )tmp___1;
#line 61
  tmp___2 = read16b(f);
#line 61
  (m___0->xxh)->chn = (int )tmp___2;
#line 62
  tmp___3 = read16b(f);
#line 62
  (m___0->xxh)->len = (int )tmp___3;
#line 63
  tmp___4 = read16b(f);
#line 63
  (m___0->xxh)->rst = (int )tmp___4;
  }
  {
#line 65
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 65
    if (m___0->verbosity) {
#line 65
      if (m___0->name[0]) {
        {
#line 65
        report((char *)"Module title   : %s\n", m___0->name);
        }
      }
#line 65
      if (m___0->type[0]) {
        {
#line 65
        report((char *)"Module type    : %s\n", m___0->type);
        }
      }
#line 65
      if (m___0->author[0]) {
        {
#line 65
        report((char *)"Author name    : %s\n", m___0->author);
        }
      }
#line 65
      if ((m___0->xxh)->len) {
        {
#line 65
        report((char *)"Module length  : %d patterns\n", (m___0->xxh)->len);
        }
      }
    }
#line 65
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 67
  reportv(ctx___0, 0, (char *)"Instruments    : %d ", (m___0->xxh)->ins);
#line 68
  reportv(ctx___0, 1, (char *)"\n     Name                          Len   LBeg  LSiz  L Vol Fin  C2spd");
  }
  {
#line 70
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 70
    tmp___5 = calloc((size_t )sizeof(struct xxm_instrument_header ), (size_t )(m___0->xxh)->ins);
#line 70
    m___0->xxih = (struct xxm_instrument_header *)tmp___5;
#line 70
    tmp___6 = calloc((size_t )sizeof(struct xxm_instrument_map ), (size_t )(m___0->xxh)->ins);
#line 70
    m___0->xxim = (struct xxm_instrument_map *)tmp___6;
#line 70
    tmp___7 = calloc((size_t )sizeof(struct xxm_instrument *), (size_t )(m___0->xxh)->ins);
#line 70
    m___0->xxi = (struct xxm_instrument **)tmp___7;
    }
#line 70
    if ((m___0->xxh)->smp) {
      {
#line 70
      tmp___8 = calloc((size_t )sizeof(struct xxm_sample ), (size_t )(m___0->xxh)->smp);
#line 70
      m___0->xxs = (struct xxm_sample *)tmp___8;
      }
    }
    {
#line 70
    tmp___9 = calloc((size_t )sizeof(uint16 *), (size_t )(m___0->xxh)->ins);
#line 70
    m___0->xxae = (uint16 **)tmp___9;
#line 70
    tmp___10 = calloc((size_t )sizeof(uint16 *), (size_t )(m___0->xxh)->ins);
#line 70
    m___0->xxpe = (uint16 **)tmp___10;
#line 70
    tmp___11 = calloc((size_t )sizeof(uint16 *), (size_t )(m___0->xxh)->ins);
#line 70
    m___0->xxfe = (uint16 **)tmp___11;
    }
#line 70
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 71
  i___3 = 0;
  {
#line 71
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 71
    if (! (i___3 < (m___0->xxh)->ins)) {
#line 71
      goto while_break___2;
    }
    {
#line 72
    tmp___12 = calloc((size_t )sizeof(struct xxm_instrument ), (size_t )1);
#line 72
    *(m___0->xxi + i___3) = (struct xxm_instrument *)tmp___12;
#line 73
    fread((void */* __restrict  */)(buffer), (size_t )28, (size_t )1, (FILE */* __restrict  */)f);
#line 74
    copy_adjust((m___0->xxih + i___3)->name, buffer, 28);
    }
#line 76
    if (ver___0 == 1) {
      {
#line 77
      read32b(f);
#line 78
      tmp___13 = read32b(f);
#line 78
      (m___0->xxs + i___3)->len = (int )tmp___13;
#line 79
      tmp___14 = read32b(f);
#line 79
      (m___0->xxs + i___3)->lps = (int )tmp___14;
#line 80
      tmp___15 = read32b(f);
#line 80
      size___0 = (int )tmp___15;
#line 81
      (m___0->xxs + i___3)->lpe = ((m___0->xxs + i___3)->lps + size___0) - 1;
#line 82
      read16b(f);
#line 83
      read16b(f);
#line 84
      (*(m___0->xxi + i___3) + 0)->vol = 64;
#line 85
      (*(m___0->xxi + i___3) + 0)->pan = 128;
#line 86
      bits = 1;
#line 87
      c2spd___0 = 8363;
      }
    } else {
      {
#line 89
      fseek(f, 14L, 1);
#line 90
      read16b(f);
#line 91
      tmp___16 = read16b(f);
#line 91
      bits = (int )tmp___16;
#line 92
      tmp___17 = read16b(f);
#line 92
      c2spd___0 = (int )tmp___17;
#line 93
      c2spd_to_note(c2spd___0, & (*(m___0->xxi + i___3) + 0)->xpo, & (*(m___0->xxi + i___3) + 0)->fin);
#line 94
      tmp___18 = read32b(f);
#line 94
      (m___0->xxs + i___3)->len = (int )tmp___18;
#line 95
      tmp___19 = read32b(f);
#line 95
      (m___0->xxs + i___3)->lps = (int )tmp___19;
#line 96
      tmp___20 = read32b(f);
#line 96
      size___0 = (int )tmp___20;
#line 97
      (m___0->xxs + i___3)->lpe = ((m___0->xxs + i___3)->lps + size___0) - 1;
#line 98
      tmp___21 = read16b(f);
#line 98
      (*(m___0->xxi + i___3) + 0)->vol = (int )tmp___21 / 4;
#line 99
      read8(f);
#line 100
      tmp___22 = read8s(f);
#line 100
      (*(m___0->xxi + i___3) + 0)->fin = (int )tmp___22;
      }
    }
#line 103
    (m___0->xxih + i___3)->nsm = ! (! (m___0->xxs + i___3)->len);
#line 104
    (*(m___0->xxi + i___3) + 0)->sid = i___3;
#line 105
    if (size___0 > 2) {
#line 105
      (m___0->xxs + i___3)->flg = 4;
    } else {
#line 105
      (m___0->xxs + i___3)->flg = 0;
    }
#line 106
    if (bits > 1) {
#line 106
      tmp___23 = 1;
    } else {
#line 106
      tmp___23 = 0;
    }
    {
#line 106
    (m___0->xxs + i___3)->flg |= tmp___23;
#line 108
    tmp___26 = strlen((char const   *)((char *)((m___0->xxih + i___3)->name)));
    }
#line 108
    if (tmp___26) {
#line 108
      goto _L;
    } else
#line 108
    if ((m___0->xxs + i___3)->len > 1) {
      _L: /* CIL Label */ 
#line 109
      if (m___0->verbosity > 1) {
#line 110
        if ((m___0->xxs + i___3)->flg & 4) {
#line 110
          tmp___24 = 'L';
        } else {
#line 110
          tmp___24 = ' ';
        }
#line 110
        if (bits > 1) {
#line 110
          tmp___25 = '+';
        } else {
#line 110
          tmp___25 = ' ';
        }
        {
#line 110
        report((char *)"\n[%2X] %-28.28s  %05x%c%05x %05x %c V%02x F%+03d %5d", i___3,
               (m___0->xxih + i___3)->name, (m___0->xxs + i___3)->len, tmp___25, (m___0->xxs + i___3)->lps,
               size___0, tmp___24, (*(m___0->xxi + i___3) + 0)->vol, (*(m___0->xxi + i___3) + 0)->fin,
               c2spd___0);
        }
      } else {
        {
#line 121
        report((char *)".");
        }
      }
    }
#line 71
    i___3 ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 125
  reportv(ctx___0, 0, (char *)"\n");
#line 127
  i___3 = 0;
  }
  {
#line 127
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 127
    if (! (i___3 < 256)) {
#line 127
      goto while_break___3;
    }
    {
#line 128
    tmp___27 = read16b(f);
#line 128
    m___0->xxo[i___3] = (uint8 )tmp___27;
#line 127
    i___3 ++;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
#line 130
  i___3 = 0;
#line 130
  patmax = i___3;
  {
#line 130
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 130
    if (! (i___3 < (m___0->xxh)->len)) {
#line 130
      goto while_break___4;
    }
#line 131
    if ((int )m___0->xxo[i___3] > patmax) {
#line 132
      patmax = (int )m___0->xxo[i___3];
    }
#line 130
    i___3 ++;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 135
  (m___0->xxh)->pat = patmax + 1;
#line 136
  (m___0->xxh)->trk = (m___0->xxh)->pat * (m___0->xxh)->chn;
  {
#line 138
  while (1) {
    while_continue___5: /* CIL Label */ ;
    {
#line 138
    tmp___28 = calloc((size_t )sizeof(struct xxm_track *), (size_t )(m___0->xxh)->trk);
#line 138
    m___0->xxt = (struct xxm_track **)tmp___28;
#line 138
    tmp___29 = calloc((size_t )sizeof(struct xxm_pattern *), (size_t )((m___0->xxh)->pat + 1));
#line 138
    m___0->xxp = (struct xxm_pattern **)tmp___29;
    }
#line 138
    goto while_break___5;
  }
  while_break___5: /* CIL Label */ ;
  }
  {
#line 141
  reportv(ctx___0, 0, (char *)"Stored patterns: %d ", (m___0->xxh)->pat);
#line 143
  i___3 = 0;
  }
  {
#line 143
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 143
    if (! (i___3 < (m___0->xxh)->pat)) {
#line 143
      goto while_break___6;
    }
    {
#line 144
    while (1) {
      while_continue___7: /* CIL Label */ ;
      {
#line 144
      tmp___30 = calloc((size_t )1, (size_t )(sizeof(struct xxm_pattern ) + sizeof(struct xxm_trackinfo ) * (unsigned long )((m___0->xxh)->chn - 1)));
#line 144
      *(m___0->xxp + i___3) = (struct xxm_pattern *)tmp___30;
      }
#line 144
      goto while_break___7;
    }
    while_break___7: /* CIL Label */ ;
    }
#line 145
    (*(m___0->xxp + i___3))->rows = rows___1;
    {
#line 146
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 146
      j___0 = 0;
      {
#line 146
      while (1) {
        while_continue___9: /* CIL Label */ ;
#line 146
        if (! (j___0 < (m___0->xxh)->chn)) {
#line 146
          goto while_break___9;
        }
        {
#line 146
        (*(m___0->xxp + i___3))->info[j___0].index = i___3 * (m___0->xxh)->chn + j___0;
#line 146
        tmp___31 = calloc((size_t )(sizeof(struct xxm_track ) + sizeof(struct xxm_event ) * (unsigned long )(*(m___0->xxp + i___3))->rows),
                          (size_t )1);
#line 146
        *(m___0->xxt + (i___3 * (m___0->xxh)->chn + j___0)) = (struct xxm_track *)tmp___31;
#line 146
        (*(m___0->xxt + (i___3 * (m___0->xxh)->chn + j___0)))->rows = (*(m___0->xxp + i___3))->rows;
#line 146
        j___0 ++;
        }
      }
      while_break___9: /* CIL Label */ ;
      }
#line 146
      goto while_break___8;
    }
    while_break___8: /* CIL Label */ ;
    }
#line 148
    j = 0;
    {
#line 148
    while (1) {
      while_continue___10: /* CIL Label */ ;
#line 148
      if (! (j < (*(m___0->xxp + i___3))->rows)) {
#line 148
        goto while_break___10;
      }
#line 149
      k = 0;
      {
#line 149
      while (1) {
        while_continue___11: /* CIL Label */ ;
#line 149
        if (! (k < (m___0->xxh)->chn)) {
#line 149
          goto while_break___11;
        }
        {
#line 150
        event = & (*(m___0->xxt + (*(m___0->xxp + i___3))->info[k].index))->event[j];
#line 152
        event->note = read8(f);
#line 153
        event->ins = read8(f);
#line 154
        event->fxt = read8(f);
#line 155
        event->fxp = read8(f);
        }
#line 156
        if (ver___0 >= 4) {
          {
#line 157
          event->vol = read8(f);
          }
        }
#line 161
        if ((int )event->fxt > 15) {
#line 163
          event->fxt = (uint8 )0;
#line 164
          event->fxp = (uint8 )0;
        } else
#line 161
        if ((int )event->fxt == 14) {
#line 163
          event->fxt = (uint8 )0;
#line 164
          event->fxp = (uint8 )0;
        } else
#line 161
        if ((int )event->fxt == 12) {
#line 163
          event->fxt = (uint8 )0;
#line 164
          event->fxp = (uint8 )0;
        }
#line 149
        k ++;
      }
      while_break___11: /* CIL Label */ ;
      }
#line 148
      j ++;
    }
    while_break___10: /* CIL Label */ ;
    }
    {
#line 168
    reportv(ctx___0, 0, (char *)".");
#line 143
    i___3 ++;
    }
  }
  while_break___6: /* CIL Label */ ;
  }
  {
#line 170
  reportv(ctx___0, 0, (char *)"\n");
#line 173
  reportv(ctx___0, 0, (char *)"Stored samples : %d ", (m___0->xxh)->smp);
#line 174
  i___3 = 0;
  }
  {
#line 174
  while (1) {
    while_continue___12: /* CIL Label */ ;
#line 174
    if (! (i___3 < (m___0->xxh)->ins)) {
#line 174
      goto while_break___12;
    }
#line 175
    if ((m___0->xxs + i___3)->len == 0) {
#line 176
      goto __Cont;
    }
    {
#line 177
    xmp_drv_loadpatch(ctx___0, f, (*(m___0->xxi + i___3) + 0)->sid, m___0->c4rate,
                      0, m___0->xxs + (*(m___0->xxi + i___3) + 0)->sid, (char *)((void *)0));
#line 179
    reportv(ctx___0, 0, (char *)".");
    }
    __Cont: /* CIL Label */ 
#line 174
    i___3 ++;
  }
  while_break___12: /* CIL Label */ ;
  }
  {
#line 181
  reportv(ctx___0, 0, (char *)"\n");
  }
#line 183
  return (0);
}
}
#line 22 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/dt_load.c"
static int dt_test(FILE *f , char *t , int const   start ) ;
#line 23
static int dt_load(struct xmp_context *ctx___0 , FILE *f , int const   start ) ;
#line 25 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/dt_load.c"
struct xmp_loader_info dt_loader  =    {(char *)"DTM", (char *)"Digital Tracker", & dt_test, & dt_load, 0, {(struct list_head *)0,
                                                                        (struct list_head *)0}};
#line 32 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/dt_load.c"
static int dt_test(FILE *f , char *t , int const   start ) 
{ 
  uint32 tmp ;

  {
  {
#line 34
  tmp = read32b(f);
  }
#line 34
  if (tmp != ((((68U << 24) | (46U << 16)) | (84U << 8)) | 46U)) {
#line 35
    return (-1);
  }
  {
#line 37
  read_title(f, t, 0);
  }
#line 39
  return (0);
}
}
#line 43 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/dt_load.c"
static int pflag___0  ;
#line 43 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/dt_load.c"
static int sflag___0  ;
#line 44 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/dt_load.c"
static int realpat  ;
#line 47 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/dt_load.c"
static void get_d_t_(struct xmp_context *ctx___0 , int size___0 , FILE *f ) 
{ 
  struct xmp_player_context *p ;
  struct xmp_mod_context *m___0 ;
  int b___1 ;
  uint16 tmp ;
  uint16 tmp___0 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
  {
#line 49
  p = & ctx___0->p;
#line 50
  m___0 = & p->m;
#line 53
  read16b(f);
#line 54
  read16b(f);
#line 55
  read16b(f);
#line 56
  tmp = read16b(f);
#line 56
  (m___0->xxh)->tpo = (int )tmp;
#line 57
  tmp___0 = read16b(f);
#line 57
  b___1 = (int )tmp___0;
  }
#line 57
  if (b___1 > 0) {
#line 58
    (m___0->xxh)->bpm = b___1;
  }
  {
#line 59
  read32b(f);
#line 61
  fread((void */* __restrict  */)(m___0->name), (size_t )32, (size_t )1, (FILE */* __restrict  */)f);
#line 62
  strcpy((char */* __restrict  */)(m___0->type), (char const   */* __restrict  */)"DTM (Digital Tracker)");
  }
  {
#line 64
  while (1) {
    while_continue: /* CIL Label */ ;
#line 64
    if (m___0->verbosity) {
#line 64
      if (m___0->name[0]) {
        {
#line 64
        report((char *)"Module title   : %s\n", m___0->name);
        }
      }
#line 64
      if (m___0->type[0]) {
        {
#line 64
        report((char *)"Module type    : %s\n", m___0->type);
        }
      }
#line 64
      if (m___0->author[0]) {
        {
#line 64
        report((char *)"Author name    : %s\n", m___0->author);
        }
      }
#line 64
      if ((m___0->xxh)->len) {
        {
#line 64
        report((char *)"Module length  : %d patterns\n", (m___0->xxh)->len);
        }
      }
    }
#line 64
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 65
  return;
}
}
#line 67 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/dt_load.c"
static void get_s_q_(struct xmp_context *ctx___0 , int size___0 , FILE *f ) 
{ 
  struct xmp_player_context *p ;
  struct xmp_mod_context *m___0 ;
  int i___3 ;
  int maxpat ;
  uint16 tmp ;
  uint16 tmp___0 ;

  {
  {
#line 69
  p = & ctx___0->p;
#line 70
  m___0 = & p->m;
#line 73
  tmp = read16b(f);
#line 73
  (m___0->xxh)->len = (int )tmp;
#line 74
  tmp___0 = read16b(f);
#line 74
  (m___0->xxh)->rst = (int )tmp___0;
#line 75
  read32b(f);
#line 77
  i___3 = 0;
#line 77
  maxpat = i___3;
  }
  {
#line 77
  while (1) {
    while_continue: /* CIL Label */ ;
#line 77
    if (! (i___3 < 128)) {
#line 77
      goto while_break;
    }
    {
#line 78
    m___0->xxo[i___3] = read8(f);
    }
#line 79
    if ((int )m___0->xxo[i___3] > maxpat) {
#line 80
      maxpat = (int )m___0->xxo[i___3];
    }
#line 77
    i___3 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 82
  (m___0->xxh)->pat = maxpat + 1;
#line 83
  return;
}
}
#line 85 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/dt_load.c"
static void get_patt___3(struct xmp_context *ctx___0 , int size___0 , FILE *f ) 
{ 
  struct xmp_player_context *p ;
  struct xmp_mod_context *m___0 ;
  uint16 tmp ;
  uint16 tmp___0 ;

  {
  {
#line 87
  p = & ctx___0->p;
#line 88
  m___0 = & p->m;
#line 90
  tmp = read16b(f);
#line 90
  (m___0->xxh)->chn = (int )tmp;
#line 91
  tmp___0 = read16b(f);
#line 91
  realpat = (int )tmp___0;
#line 92
  (m___0->xxh)->trk = (m___0->xxh)->chn * (m___0->xxh)->pat;
  }
#line 93
  return;
}
}
#line 95 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/dt_load.c"
static void get_inst___2(struct xmp_context *ctx___0 , int size___0 , FILE *f ) 
{ 
  struct xmp_player_context *p ;
  struct xmp_mod_context *m___0 ;
  int i___3 ;
  int c2spd___0 ;
  uint8 name[30] ;
  int tmp ;
  uint16 tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  int fine ;
  int replen ;
  int flag ;
  void *tmp___8 ;
  uint32 tmp___9 ;
  int8 tmp___10 ;
  uint8 tmp___11 ;
  uint32 tmp___12 ;
  uint32 tmp___13 ;
  uint16 tmp___14 ;
  int tmp___15 ;
  uint32 tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  size_t tmp___20 ;
  void *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;

  {
  {
#line 97
  p = & ctx___0->p;
#line 98
  m___0 = & p->m;
#line 102
  tmp___0 = read16b(f);
#line 102
  tmp = (int )tmp___0;
#line 102
  (m___0->xxh)->smp = tmp;
#line 102
  (m___0->xxh)->ins = tmp;
#line 103
  reportv(ctx___0, 0, (char *)"Instruments    : %d ", (m___0->xxh)->ins);
  }
  {
#line 105
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 105
    tmp___1 = calloc((size_t )sizeof(struct xxm_instrument_header ), (size_t )(m___0->xxh)->ins);
#line 105
    m___0->xxih = (struct xxm_instrument_header *)tmp___1;
#line 105
    tmp___2 = calloc((size_t )sizeof(struct xxm_instrument_map ), (size_t )(m___0->xxh)->ins);
#line 105
    m___0->xxim = (struct xxm_instrument_map *)tmp___2;
#line 105
    tmp___3 = calloc((size_t )sizeof(struct xxm_instrument *), (size_t )(m___0->xxh)->ins);
#line 105
    m___0->xxi = (struct xxm_instrument **)tmp___3;
    }
#line 105
    if ((m___0->xxh)->smp) {
      {
#line 105
      tmp___4 = calloc((size_t )sizeof(struct xxm_sample ), (size_t )(m___0->xxh)->smp);
#line 105
      m___0->xxs = (struct xxm_sample *)tmp___4;
      }
    }
    {
#line 105
    tmp___5 = calloc((size_t )sizeof(uint16 *), (size_t )(m___0->xxh)->ins);
#line 105
    m___0->xxae = (uint16 **)tmp___5;
#line 105
    tmp___6 = calloc((size_t )sizeof(uint16 *), (size_t )(m___0->xxh)->ins);
#line 105
    m___0->xxpe = (uint16 **)tmp___6;
#line 105
    tmp___7 = calloc((size_t )sizeof(uint16 *), (size_t )(m___0->xxh)->ins);
#line 105
    m___0->xxfe = (uint16 **)tmp___7;
    }
#line 105
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 107
  reportv(ctx___0, 1, (char *)"\n     Instrument name        Len   LBeg  LSize LS Res Vol Fine C2Spd");
#line 108
  i___3 = 0;
  }
  {
#line 108
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 108
    if (! (i___3 < (m___0->xxh)->ins)) {
#line 108
      goto while_break___0;
    }
    {
#line 111
    tmp___8 = calloc((size_t )sizeof(struct xxm_instrument ), (size_t )1);
#line 111
    *(m___0->xxi + i___3) = (struct xxm_instrument *)tmp___8;
#line 113
    read32b(f);
#line 114
    tmp___9 = read32b(f);
#line 114
    (m___0->xxs + i___3)->len = (int )tmp___9;
#line 115
    (m___0->xxih + i___3)->nsm = ! (! (m___0->xxs + i___3)->len);
#line 116
    tmp___10 = read8s(f);
#line 116
    fine = (int )tmp___10;
#line 117
    tmp___11 = read8(f);
#line 117
    (*(m___0->xxi + i___3) + 0)->vol = (int )tmp___11;
#line 118
    (*(m___0->xxi + i___3) + 0)->pan = 128;
#line 119
    tmp___12 = read32b(f);
#line 119
    (m___0->xxs + i___3)->lps = (int )tmp___12;
#line 120
    tmp___13 = read32b(f);
#line 120
    replen = (int )tmp___13;
#line 121
    (m___0->xxs + i___3)->lpe = ((m___0->xxs + i___3)->lps + replen) - 1;
    }
#line 122
    if (replen > 2) {
#line 122
      (m___0->xxs + i___3)->flg = 4;
    } else {
#line 122
      (m___0->xxs + i___3)->flg = 0;
    }
    {
#line 124
    fread((void */* __restrict  */)(name), (size_t )22, (size_t )1, (FILE */* __restrict  */)f);
#line 125
    copy_adjust((m___0->xxih + i___3)->name, name, 22);
#line 127
    tmp___14 = read16b(f);
#line 127
    flag = (int )tmp___14;
    }
#line 128
    if ((flag & 255) > 8) {
#line 128
      tmp___15 = 1;
    } else {
#line 128
      tmp___15 = 0;
    }
    {
#line 128
    (m___0->xxs + i___3)->flg |= tmp___15;
#line 130
    read32b(f);
#line 131
    tmp___16 = read32b(f);
#line 131
    c2spd___0 = (int )tmp___16;
#line 132
    c2spd_to_note(c2spd___0, & (*(m___0->xxi + i___3) + 0)->xpo, & (*(m___0->xxi + i___3) + 0)->fin);
#line 135
    (*(m___0->xxi + i___3) + 0)->fin += fine;
#line 137
    (*(m___0->xxi + i___3) + 0)->sid = i___3;
#line 139
    tmp___20 = strlen((char const   *)((char *)((m___0->xxih + i___3)->name)));
    }
#line 139
    if (tmp___20) {
#line 139
      goto _L;
    } else
#line 139
    if ((m___0->xxs + i___3)->len > 0) {
      _L: /* CIL Label */ 
#line 140
      if (m___0->verbosity > 1) {
#line 141
        if (flag & 256) {
#line 141
          tmp___17 = 'S';
        } else {
#line 141
          tmp___17 = ' ';
        }
#line 141
        if ((m___0->xxs + i___3)->flg & 4) {
#line 141
          tmp___18 = 'L';
        } else {
#line 141
          tmp___18 = ' ';
        }
#line 141
        if ((m___0->xxs + i___3)->flg & 1) {
#line 141
          tmp___19 = '+';
        } else {
#line 141
          tmp___19 = ' ';
        }
        {
#line 141
        report((char *)"\n[%2X] %-22.22s %05x%c%05x %05x %c%c %2db V%02x F%+03d %5d",
               i___3, (m___0->xxih + i___3)->name, (m___0->xxs + i___3)->len, tmp___19,
               (m___0->xxs + i___3)->lps, replen, tmp___18, tmp___17, flag & 255,
               (*(m___0->xxi + i___3) + 0)->vol, fine, c2spd___0);
        }
      } else {
        {
#line 154
        report((char *)".");
        }
      }
    }
#line 108
    i___3 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 157
  reportv(ctx___0, 0, (char *)"\n");
  }
#line 158
  return;
}
}
#line 166 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/dt_load.c"
static int last_pat  ;
#line 160 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/dt_load.c"
static void get_dapt(struct xmp_context *ctx___0 , int size___0 , FILE *f ) 
{ 
  struct xmp_player_context *p ;
  struct xmp_mod_context *m___0 ;
  int pat___0 ;
  int i___3 ;
  int j ;
  int k ;
  struct xxm_event *event ;
  int rows___1 ;
  void *tmp ;
  void *tmp___0 ;
  uint16 tmp___1 ;
  uint16 tmp___2 ;
  void *tmp___3 ;
  int j___0 ;
  void *tmp___4 ;
  uint8 a ;
  uint8 b___1 ;
  uint8 c___0 ;
  uint8 d ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;

  {
#line 162
  p = & ctx___0->p;
#line 163
  m___0 = & p->m;
#line 169
  if (! pflag___0) {
    {
#line 170
    reportv(ctx___0, 0, (char *)"Stored patterns: %d ", (m___0->xxh)->pat);
#line 171
    pflag___0 = 1;
#line 172
    last_pat = 0;
    }
    {
#line 173
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 173
      tmp = calloc((size_t )sizeof(struct xxm_track *), (size_t )(m___0->xxh)->trk);
#line 173
      m___0->xxt = (struct xxm_track **)tmp;
#line 173
      tmp___0 = calloc((size_t )sizeof(struct xxm_pattern *), (size_t )((m___0->xxh)->pat + 1));
#line 173
      m___0->xxp = (struct xxm_pattern **)tmp___0;
      }
#line 173
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 176
  read32b(f);
#line 177
  tmp___1 = read16b(f);
#line 177
  pat___0 = (int )tmp___1;
#line 177
  i___3 = pat___0;
#line 178
  tmp___2 = read16b(f);
#line 178
  rows___1 = (int )tmp___2;
#line 180
  i___3 = last_pat;
  }
  {
#line 180
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 180
    if (! (i___3 <= pat___0)) {
#line 180
      goto while_break___0;
    }
    {
#line 181
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 181
      tmp___3 = calloc((size_t )1, (size_t )(sizeof(struct xxm_pattern ) + sizeof(struct xxm_trackinfo ) * (unsigned long )((m___0->xxh)->chn - 1)));
#line 181
      *(m___0->xxp + i___3) = (struct xxm_pattern *)tmp___3;
      }
#line 181
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 182
    (*(m___0->xxp + i___3))->rows = rows___1;
    {
#line 183
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 183
      j___0 = 0;
      {
#line 183
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 183
        if (! (j___0 < (m___0->xxh)->chn)) {
#line 183
          goto while_break___3;
        }
        {
#line 183
        (*(m___0->xxp + i___3))->info[j___0].index = i___3 * (m___0->xxh)->chn + j___0;
#line 183
        tmp___4 = calloc((size_t )(sizeof(struct xxm_track ) + sizeof(struct xxm_event ) * (unsigned long )(*(m___0->xxp + i___3))->rows),
                         (size_t )1);
#line 183
        *(m___0->xxt + (i___3 * (m___0->xxh)->chn + j___0)) = (struct xxm_track *)tmp___4;
#line 183
        (*(m___0->xxt + (i___3 * (m___0->xxh)->chn + j___0)))->rows = (*(m___0->xxp + i___3))->rows;
#line 183
        j___0 ++;
        }
      }
      while_break___3: /* CIL Label */ ;
      }
#line 183
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 180
    i___3 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 185
  last_pat = pat___0 + 1;
#line 187
  j = 0;
  {
#line 187
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 187
    if (! (j < rows___1)) {
#line 187
      goto while_break___4;
    }
#line 188
    k = 0;
    {
#line 188
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 188
      if (! (k < (m___0->xxh)->chn)) {
#line 188
        goto while_break___5;
      }
      {
#line 191
      event = & (*(m___0->xxt + (*(m___0->xxp + pat___0))->info[k].index))->event[j];
#line 192
      a = read8(f);
#line 193
      b___1 = read8(f);
#line 194
      c___0 = read8(f);
#line 195
      d = read8(f);
      }
#line 196
      if (a) {
#line 197
        a = (uint8 )((int )a - 1);
#line 198
        event->note = (uint8 )(12 * ((int )a >> 4) + ((int )a & 15));
      }
#line 200
      event->vol = (uint8 )(((int )b___1 & 252) >> 2);
#line 201
      event->ins = (uint8 )((((int )b___1 & 3) << 4) + ((int )c___0 >> 4));
#line 202
      event->fxt = (uint8 )((int )c___0 & 15);
#line 203
      event->fxp = d;
#line 188
      k ++;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 187
    j ++;
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 207
  reportv(ctx___0, 0, (char *)".");
  }
#line 208
  return;
}
}
#line 214
static void get_dait(struct xmp_context *ctx___0 , int size___0 , FILE *f ) ;
#line 214 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/dt_load.c"
static int i___2  =    0;
#line 210 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/dt_load.c"
static void get_dait(struct xmp_context *ctx___0 , int size___0 , FILE *f ) 
{ 
  struct xmp_player_context *p ;
  struct xmp_mod_context *m___0 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
#line 212
  p = & ctx___0->p;
#line 213
  m___0 = & p->m;
#line 216
  if (! sflag___0) {
    {
#line 217
    reportv(ctx___0, 0, (char *)"\nStored samples : %d ", (m___0->xxh)->smp);
#line 218
    sflag___0 = 1;
#line 219
    i___2 = 0;
    }
  }
#line 222
  if (size___0 > 2) {
    {
#line 223
    xmp_drv_loadpatch(ctx___0, f, (*(m___0->xxi + i___2) + 0)->sid, m___0->c4rate,
                      64, m___0->xxs + (*(m___0->xxi + i___2) + 0)->sid, (char *)((void *)0));
#line 225
    reportv(ctx___0, 0, (char *)".");
    }
  }
#line 228
  i___2 ++;
#line 229
  return;
}
}
#line 231 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/dt_load.c"
static int dt_load(struct xmp_context *ctx___0 , FILE *f , int const   start ) 
{ 
  struct xmp_player_context *p ;
  struct xmp_mod_context *m___0 ;
  uint8 **tmp ;
  int tmp___0 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
#line 233
  p = & ctx___0->p;
#line 234
  m___0 = & p->m;
  {
#line 236
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 236
    fseek(f, (long )start, 0);
#line 236
    tmp = (uint8 **)((void *)0);
#line 236
    m___0->med_wav_table = tmp;
#line 236
    m___0->med_vol_table = tmp;
#line 236
    set_xxh_defaults(m___0->xxh);
    }
#line 236
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 238
  sflag___0 = 0;
#line 238
  pflag___0 = sflag___0;
#line 241
  iff_register((char *)"D.T.", & get_d_t_);
#line 242
  iff_register((char *)"S.Q.", & get_s_q_);
#line 243
  iff_register((char *)"PATT", & get_patt___3);
#line 244
  iff_register((char *)"INST", & get_inst___2);
#line 245
  iff_register((char *)"DAPT", & get_dapt);
#line 246
  iff_register((char *)"DAIT", & get_dait);
  }
  {
#line 249
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 249
    tmp___0 = feof(f);
    }
#line 249
    if (tmp___0) {
#line 249
      goto while_break___0;
    }
    {
#line 250
    iff_chunk(ctx___0, f);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 252
  reportv(ctx___0, 0, (char *)"\n");
#line 254
  iff_release();
  }
#line 256
  return (0);
}
}
#line 24 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/tcb_load.c"
static int tcb_test(FILE *f , char *t , int const   start ) ;
#line 25
static int tcb_load(struct xmp_context *ctx___0 , FILE *f , int const   start ) ;
#line 27 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/tcb_load.c"
struct xmp_loader_info tcb_loader  =    {(char *)"TCB", (char *)"TCB Tracker", & tcb_test, & tcb_load, 0, {(struct list_head *)0,
                                                                      (struct list_head *)0}};
#line 34 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/tcb_load.c"
static int tcb_test(FILE *f , char *t , int const   start ) 
{ 
  uint8 buffer[10] ;
  int tmp ;
  int tmp___0 ;
  void *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
  {
#line 38
  fread((void */* __restrict  */)(buffer), (size_t )8, (size_t )1, (FILE */* __restrict  */)f);
#line 39
  tmp = memcmp((void const   *)(buffer), (void const   *)"AN COOL.", (size_t )8);
  }
#line 39
  if (tmp) {
    {
#line 39
    tmp___0 = memcmp((void const   *)(buffer), (void const   *)"AN COOL!", (size_t )8);
    }
#line 39
    if (tmp___0) {
#line 40
      return (-1);
    }
  }
  {
#line 42
  read_title(f, t, 0);
  }
#line 44
  return (0);
}
}
#line 47 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/tcb_load.c"
static int tcb_load(struct xmp_context *ctx___0 , FILE *f , int const   start ) 
{ 
  struct xmp_player_context *p ;
  struct xmp_mod_context *m___0 ;
  struct xxm_event *event ;
  int i___3 ;
  int j ;
  int k ;
  uint8 buffer[10] ;
  int base_offs ;
  int soffs[16] ;
  uint8 unk1[16] ;
  uint8 unk2[16] ;
  uint8 unk3[16] ;
  uint8 **tmp ;
  uint16 tmp___0 ;
  uint8 tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  void *tmp___9 ;
  void *tmp___10 ;
  void *tmp___11 ;
  void *tmp___12 ;
  int j___0 ;
  void *tmp___13 ;
  int b___1 ;
  uint8 tmp___14 ;
  uint8 tmp___15 ;
  long tmp___16 ;
  uint8 tmp___17 ;
  uint32 tmp___18 ;
  uint32 tmp___19 ;
  int tmp___20 ;
  size_t tmp___21 ;
  void *__cil_tmp41 ;
  void *__cil_tmp42 ;
  void *__cil_tmp43 ;
  void *__cil_tmp44 ;
  void *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;

  {
#line 49
  p = & ctx___0->p;
#line 50
  m___0 = & p->m;
  {
#line 57
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 57
    fseek(f, (long )start, 0);
#line 57
    tmp = (uint8 **)((void *)0);
#line 57
    m___0->med_wav_table = tmp;
#line 57
    m___0->med_vol_table = tmp;
#line 57
    set_xxh_defaults(m___0->xxh);
    }
#line 57
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 59
  fread((void */* __restrict  */)(buffer), (size_t )8, (size_t )1, (FILE */* __restrict  */)f);
#line 61
  sprintf((char */* __restrict  */)(m___0->type), (char const   */* __restrict  */)"%-8.8s (TCB Tracker)",
          buffer);
#line 63
  read16b(f);
#line 64
  tmp___0 = read16b(f);
#line 64
  (m___0->xxh)->pat = (int )tmp___0;
#line 65
  (m___0->xxh)->ins = 16;
#line 66
  (m___0->xxh)->smp = (m___0->xxh)->ins;
#line 67
  (m___0->xxh)->chn = 4;
#line 68
  (m___0->xxh)->trk = (m___0->xxh)->pat * (m___0->xxh)->chn;
#line 69
  (m___0->xxh)->flg |= 2;
#line 71
  read16b(f);
#line 73
  i___3 = 0;
  }
  {
#line 73
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 73
    if (! (i___3 < 128)) {
#line 73
      goto while_break___0;
    }
    {
#line 74
    m___0->xxo[i___3] = read8(f);
#line 73
    i___3 ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 76
  tmp___1 = read8(f);
#line 76
  (m___0->xxh)->len = (int )tmp___1;
#line 77
  read8(f);
#line 78
  read16b(f);
  }
  {
#line 80
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 80
    if (m___0->verbosity) {
#line 80
      if (m___0->name[0]) {
        {
#line 80
        report((char *)"Module title   : %s\n", m___0->name);
        }
      }
#line 80
      if (m___0->type[0]) {
        {
#line 80
        report((char *)"Module type    : %s\n", m___0->type);
        }
      }
#line 80
      if (m___0->author[0]) {
        {
#line 80
        report((char *)"Author name    : %s\n", m___0->author);
        }
      }
#line 80
      if ((m___0->xxh)->len) {
        {
#line 80
        report((char *)"Module length  : %d patterns\n", (m___0->xxh)->len);
        }
      }
    }
#line 80
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 82
  while (1) {
    while_continue___2: /* CIL Label */ ;
    {
#line 82
    tmp___2 = calloc((size_t )sizeof(struct xxm_instrument_header ), (size_t )(m___0->xxh)->ins);
#line 82
    m___0->xxih = (struct xxm_instrument_header *)tmp___2;
#line 82
    tmp___3 = calloc((size_t )sizeof(struct xxm_instrument_map ), (size_t )(m___0->xxh)->ins);
#line 82
    m___0->xxim = (struct xxm_instrument_map *)tmp___3;
#line 82
    tmp___4 = calloc((size_t )sizeof(struct xxm_instrument *), (size_t )(m___0->xxh)->ins);
#line 82
    m___0->xxi = (struct xxm_instrument **)tmp___4;
    }
#line 82
    if ((m___0->xxh)->smp) {
      {
#line 82
      tmp___5 = calloc((size_t )sizeof(struct xxm_sample ), (size_t )(m___0->xxh)->smp);
#line 82
      m___0->xxs = (struct xxm_sample *)tmp___5;
      }
    }
    {
#line 82
    tmp___6 = calloc((size_t )sizeof(uint16 *), (size_t )(m___0->xxh)->ins);
#line 82
    m___0->xxae = (uint16 **)tmp___6;
#line 82
    tmp___7 = calloc((size_t )sizeof(uint16 *), (size_t )(m___0->xxh)->ins);
#line 82
    m___0->xxpe = (uint16 **)tmp___7;
#line 82
    tmp___8 = calloc((size_t )sizeof(uint16 *), (size_t )(m___0->xxh)->ins);
#line 82
    m___0->xxfe = (uint16 **)tmp___8;
    }
#line 82
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 85
  i___3 = 0;
  {
#line 85
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 85
    if (! (i___3 < (m___0->xxh)->ins)) {
#line 85
      goto while_break___3;
    }
    {
#line 86
    tmp___9 = calloc((size_t )sizeof(struct xxm_instrument ), (size_t )1);
#line 86
    *(m___0->xxi + i___3) = (struct xxm_instrument *)tmp___9;
#line 87
    fread((void */* __restrict  */)(buffer), (size_t )8, (size_t )1, (FILE */* __restrict  */)f);
#line 88
    copy_adjust((m___0->xxih + i___3)->name, buffer, 8);
#line 85
    i___3 ++;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 91
  read16b(f);
#line 92
  i___3 = 0;
  }
  {
#line 92
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 92
    if (! (i___3 < 5)) {
#line 92
      goto while_break___4;
    }
    {
#line 93
    read16b(f);
#line 92
    i___3 ++;
    }
  }
  while_break___4: /* CIL Label */ ;
  }
#line 94
  i___3 = 0;
  {
#line 94
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 94
    if (! (i___3 < 5)) {
#line 94
      goto while_break___5;
    }
    {
#line 95
    read16b(f);
#line 94
    i___3 ++;
    }
  }
  while_break___5: /* CIL Label */ ;
  }
#line 96
  i___3 = 0;
  {
#line 96
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 96
    if (! (i___3 < 5)) {
#line 96
      goto while_break___6;
    }
    {
#line 97
    read16b(f);
#line 96
    i___3 ++;
    }
  }
  while_break___6: /* CIL Label */ ;
  }
  {
#line 99
  while (1) {
    while_continue___7: /* CIL Label */ ;
    {
#line 99
    tmp___10 = calloc((size_t )sizeof(struct xxm_track *), (size_t )(m___0->xxh)->trk);
#line 99
    m___0->xxt = (struct xxm_track **)tmp___10;
#line 99
    tmp___11 = calloc((size_t )sizeof(struct xxm_pattern *), (size_t )((m___0->xxh)->pat + 1));
#line 99
    m___0->xxp = (struct xxm_pattern **)tmp___11;
    }
#line 99
    goto while_break___7;
  }
  while_break___7: /* CIL Label */ ;
  }
  {
#line 102
  reportv(ctx___0, 0, (char *)"Stored patterns: %d ", (m___0->xxh)->pat);
#line 104
  i___3 = 0;
  }
  {
#line 104
  while (1) {
    while_continue___8: /* CIL Label */ ;
#line 104
    if (! (i___3 < (m___0->xxh)->pat)) {
#line 104
      goto while_break___8;
    }
    {
#line 105
    while (1) {
      while_continue___9: /* CIL Label */ ;
      {
#line 105
      tmp___12 = calloc((size_t )1, (size_t )(sizeof(struct xxm_pattern ) + sizeof(struct xxm_trackinfo ) * (unsigned long )((m___0->xxh)->chn - 1)));
#line 105
      *(m___0->xxp + i___3) = (struct xxm_pattern *)tmp___12;
      }
#line 105
      goto while_break___9;
    }
    while_break___9: /* CIL Label */ ;
    }
#line 106
    (*(m___0->xxp + i___3))->rows = 64;
    {
#line 107
    while (1) {
      while_continue___10: /* CIL Label */ ;
#line 107
      j___0 = 0;
      {
#line 107
      while (1) {
        while_continue___11: /* CIL Label */ ;
#line 107
        if (! (j___0 < (m___0->xxh)->chn)) {
#line 107
          goto while_break___11;
        }
        {
#line 107
        (*(m___0->xxp + i___3))->info[j___0].index = i___3 * (m___0->xxh)->chn + j___0;
#line 107
        tmp___13 = calloc((size_t )(sizeof(struct xxm_track ) + sizeof(struct xxm_event ) * (unsigned long )(*(m___0->xxp + i___3))->rows),
                          (size_t )1);
#line 107
        *(m___0->xxt + (i___3 * (m___0->xxh)->chn + j___0)) = (struct xxm_track *)tmp___13;
#line 107
        (*(m___0->xxt + (i___3 * (m___0->xxh)->chn + j___0)))->rows = (*(m___0->xxp + i___3))->rows;
#line 107
        j___0 ++;
        }
      }
      while_break___11: /* CIL Label */ ;
      }
#line 107
      goto while_break___10;
    }
    while_break___10: /* CIL Label */ ;
    }
#line 109
    j = 0;
    {
#line 109
    while (1) {
      while_continue___12: /* CIL Label */ ;
#line 109
      if (! (j < (*(m___0->xxp + i___3))->rows)) {
#line 109
        goto while_break___12;
      }
#line 110
      k = 0;
      {
#line 110
      while (1) {
        while_continue___13: /* CIL Label */ ;
#line 110
        if (! (k < (m___0->xxh)->chn)) {
#line 110
          goto while_break___13;
        }
        {
#line 112
        event = & (*(m___0->xxt + (*(m___0->xxp + i___3))->info[k].index))->event[j];
#line 114
        tmp___14 = read8(f);
#line 114
        b___1 = (int )tmp___14;
        }
#line 115
        if (b___1) {
#line 116
          event->note = (uint8 )(12 * (b___1 >> 4));
#line 117
          event->note = (uint8 )((int )event->note + ((b___1 & 15) + 24));
        }
        {
#line 119
        tmp___15 = read8(f);
#line 119
        b___1 = (int )tmp___15;
#line 120
        event->ins = (uint8 )(b___1 >> 4);
        }
#line 121
        if (event->ins) {
#line 122
          event->ins = (uint8 )((int )event->ins + 1);
        }
#line 123
        b___1 &= 15;
#line 123
        if (b___1) {
          {
#line 125
          if (b___1 == 13) {
#line 125
            goto case_13;
          }
#line 129
          goto switch_default;
          case_13: /* CIL Label */ 
#line 126
          event->fxt = (uint8 )13;
#line 127
          event->fxp = (uint8 )0;
#line 128
          goto switch_break;
          switch_default: /* CIL Label */ 
          {
#line 130
          printf((char const   */* __restrict  */)"---> %02x\n", b___1);
          }
          switch_break: /* CIL Label */ ;
          }
        }
#line 110
        k ++;
      }
      while_break___13: /* CIL Label */ ;
      }
#line 109
      j ++;
    }
    while_break___12: /* CIL Label */ ;
    }
    {
#line 135
    reportv(ctx___0, 0, (char *)".");
#line 104
    i___3 ++;
    }
  }
  while_break___8: /* CIL Label */ ;
  }
  {
#line 137
  reportv(ctx___0, 0, (char *)"\n");
#line 139
  tmp___16 = ftell(f);
#line 139
  base_offs = (int )tmp___16;
#line 140
  read32b(f);
#line 143
  reportv(ctx___0, 1, (char *)"     Name      Len  LBeg LEnd L Vol  ?? ?? ??\n");
#line 145
  i___3 = 0;
  }
  {
#line 145
  while (1) {
    while_continue___14: /* CIL Label */ ;
#line 145
    if (! (i___3 < (m___0->xxh)->ins)) {
#line 145
      goto while_break___14;
    }
    {
#line 146
    tmp___17 = read8(f);
#line 146
    (*(m___0->xxi + i___3) + 0)->vol = (int )tmp___17 / 2;
#line 147
    (*(m___0->xxi + i___3) + 0)->pan = 128;
#line 148
    unk1[i___3] = read8(f);
#line 149
    unk2[i___3] = read8(f);
#line 150
    unk3[i___3] = read8(f);
#line 145
    i___3 ++;
    }
  }
  while_break___14: /* CIL Label */ ;
  }
#line 154
  i___3 = 0;
  {
#line 154
  while (1) {
    while_continue___15: /* CIL Label */ ;
#line 154
    if (! (i___3 < (m___0->xxh)->ins)) {
#line 154
      goto while_break___15;
    }
    {
#line 155
    tmp___18 = read32b(f);
#line 155
    soffs[i___3] = (int )tmp___18;
#line 156
    tmp___19 = read32b(f);
#line 156
    (m___0->xxs + i___3)->len = (int )tmp___19;
#line 154
    i___3 ++;
    }
  }
  while_break___15: /* CIL Label */ ;
  }
  {
#line 159
  read32b(f);
#line 160
  read32b(f);
#line 161
  read32b(f);
#line 162
  read32b(f);
#line 164
  i___3 = 0;
  }
  {
#line 164
  while (1) {
    while_continue___16: /* CIL Label */ ;
#line 164
    if (! (i___3 < (m___0->xxh)->ins)) {
#line 164
      goto while_break___16;
    }
#line 165
    (m___0->xxih + i___3)->nsm = ! (! (m___0->xxs + i___3)->len);
#line 166
    (m___0->xxs + i___3)->lps = 0;
#line 167
    (m___0->xxs + i___3)->lpe = 0;
#line 168
    if ((m___0->xxs + i___3)->lpe > 0) {
#line 168
      (m___0->xxs + i___3)->flg = 4;
    } else {
#line 168
      (m___0->xxs + i___3)->flg = 0;
    }
#line 169
    (*(m___0->xxi + i___3) + 0)->fin = 0;
#line 170
    (*(m___0->xxi + i___3) + 0)->pan = 128;
#line 171
    (*(m___0->xxi + i___3) + 0)->sid = i___3;
#line 173
    if (m___0->verbosity > 1) {
      {
#line 173
      tmp___21 = strlen((char const   *)((char *)((m___0->xxih + i___3)->name)));
      }
#line 173
      if (tmp___21) {
#line 173
        goto _L;
      } else
#line 173
      if ((m___0->xxs + i___3)->len > 1) {
        _L: /* CIL Label */ 
#line 174
        if ((m___0->xxs + i___3)->flg & 4) {
#line 174
          tmp___20 = 'L';
        } else {
#line 174
          tmp___20 = ' ';
        }
        {
#line 174
        report((char *)"[%2X] %-8.8s  %04x %04x %04x %c V%02x  %02x %02x %02x\n",
               i___3, (m___0->xxih + i___3)->name, (m___0->xxs + i___3)->len, (m___0->xxs + i___3)->lps,
               (m___0->xxs + i___3)->lpe, tmp___20, (*(m___0->xxi + i___3) + 0)->vol,
               (int )unk1[i___3], (int )unk2[i___3], (int )unk3[i___3]);
        }
      }
    }
#line 164
    i___3 ++;
  }
  while_break___16: /* CIL Label */ ;
  }
  {
#line 184
  reportv(ctx___0, 0, (char *)"Stored samples : %d ", (m___0->xxh)->smp);
#line 185
  i___3 = 0;
  }
  {
#line 185
  while (1) {
    while_continue___17: /* CIL Label */ ;
#line 185
    if (! (i___3 < (m___0->xxh)->ins)) {
#line 185
      goto while_break___17;
    }
    {
#line 186
    fseek(f, (long )((start + (int const   )base_offs) + (int const   )soffs[i___3]),
          0);
#line 187
    xmp_drv_loadpatch(ctx___0, f, (*(m___0->xxi + i___3) + 0)->sid, m___0->c4rate,
                      2, m___0->xxs + (*(m___0->xxi + i___3) + 0)->sid, (char *)((void *)0));
#line 189
    reportv(ctx___0, 0, (char *)".");
#line 185
    i___3 ++;
    }
  }
  while_break___17: /* CIL Label */ ;
  }
  {
#line 191
  reportv(ctx___0, 0, (char *)"\n");
  }
#line 193
  return (0);
}
}
#line 24 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/dmf_load.c"
static int dmf_test(FILE *f , char *t , int const   start ) ;
#line 25
static int dmf_load(struct xmp_context *ctx___0 , FILE *f , int const   start ) ;
#line 27 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/dmf_load.c"
struct xmp_loader_info dmf_loader  =    {(char *)"DMF", (char *)"X-Tracker", & dmf_test, & dmf_load, 0, {(struct list_head *)0,
                                                                    (struct list_head *)0}};
#line 34 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/dmf_load.c"
static int dmf_test(FILE *f , char *t , int const   start ) 
{ 
  uint32 tmp ;

  {
  {
#line 36
  tmp = read32b(f);
  }
#line 36
  if (tmp != ((((68U << 24) | (68U << 16)) | (77U << 8)) | 70U)) {
#line 37
    return (-1);
  }
  {
#line 39
  fseek(f, 9L, 1);
#line 40
  read_title(f, t, 30);
  }
#line 42
  return (0);
}
}
#line 46 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/dmf_load.c"
static int ver  ;
#line 47 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/dmf_load.c"
static uint8 packtype[256]  ;
#line 64 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/dmf_load.c"
static uint8 read_bits(struct htree *tree , int nbits ) 
{ 
  uint8 x ;
  uint8 bitv ;
  uint8 *tmp ;
  int tmp___0 ;

  {
#line 66
  x = (uint8 )0;
#line 66
  bitv = (uint8 )1;
  {
#line 67
  while (1) {
    while_continue: /* CIL Label */ ;
#line 67
    tmp___0 = nbits;
#line 67
    nbits --;
#line 67
    if (! tmp___0) {
#line 67
      goto while_break;
    }
#line 68
    if (tree->bitnum) {
#line 69
      (tree->bitnum) --;
    } else {
#line 71
      if ((unsigned long )tree->ibuf < (unsigned long )tree->ibufmax) {
#line 71
        tmp = tree->ibuf;
#line 71
        (tree->ibuf) ++;
#line 71
        tree->bitbuf = (uint32 )*tmp;
      } else {
#line 71
        tree->bitbuf = (uint32 )0;
      }
#line 73
      tree->bitnum = 7;
    }
#line 75
    if (tree->bitbuf & 1U) {
#line 75
      x = (uint8 )((int )x | (int )bitv);
    }
#line 76
    bitv = (uint8 )((int )bitv << 1);
#line 77
    tree->bitbuf >>= 1;
  }
  while_break: /* CIL Label */ ;
  }
#line 79
  return (x);
}
}
#line 83 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/dmf_load.c"
static void new_node(struct htree *tree ) 
{ 
  uint8 isleft ;
  uint8 isright ;
  int actnode ;

  {
#line 88
  actnode = tree->nodecount;
#line 90
  if (actnode > 255) {
#line 91
    return;
  }
  {
#line 93
  tree->nodes[actnode].value = read_bits(tree, 7);
#line 94
  isleft = read_bits(tree, 1);
#line 95
  isright = read_bits(tree, 1);
#line 96
  actnode = tree->lastnode;
  }
#line 98
  if (actnode > 255) {
#line 99
    return;
  }
#line 101
  (tree->nodecount) ++;
#line 102
  tree->lastnode = tree->nodecount;
#line 104
  if (isleft) {
    {
#line 105
    tree->nodes[actnode].left = (short )tree->lastnode;
#line 106
    new_node(tree);
    }
  } else {
#line 108
    tree->nodes[actnode].left = (short)-1;
  }
#line 111
  tree->lastnode = tree->nodecount;
#line 113
  if (isright) {
    {
#line 114
    tree->nodes[actnode].right = (short )tree->lastnode;
#line 115
    new_node(tree);
    }
  } else {
#line 117
    tree->nodes[actnode].right = (short)-1;
  }
#line 119
  return;
}
}
#line 121 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/dmf_load.c"
static int unpack___0(uint8 *psample , uint8 *ibuf___0 , uint8 *ibufmax , uint32 maxlen ) 
{ 
  struct htree tree ;
  int i___3 ;
  int actnode ;
  uint8 value ;
  uint8 sign ;
  uint8 delta ;
  uint8 tmp ;
  void *__cil_tmp12 ;
  void *__cil_tmp13 ;
  int __cil_tmp14 ;
  void *__cil_tmp15 ;

  {
  {
#line 125
  delta = (uint8 )0;
#line 127
  memset((void *)(& tree), 0, (size_t )sizeof(tree));
#line 128
  tree.ibuf = ibuf___0;
#line 129
  tree.ibufmax = ibufmax;
#line 130
  new_node(& tree);
#line 131
  value = (uint8 )0;
#line 133
  i___3 = 0;
  }
  {
#line 133
  while (1) {
    while_continue: /* CIL Label */ ;
#line 133
    if (! ((uint32 )i___3 < maxlen)) {
#line 133
      goto while_break;
    }
    {
#line 134
    actnode = 0;
#line 135
    sign = read_bits(& tree, 1);
    }
    {
#line 137
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 138
      tmp = read_bits(& tree, 1);
      }
#line 138
      if (tmp) {
#line 139
        actnode = (int )tree.nodes[actnode].right;
      } else {
#line 141
        actnode = (int )tree.nodes[actnode].left;
      }
#line 142
      if (actnode > 255) {
#line 142
        goto while_break___0;
      }
#line 143
      delta = tree.nodes[actnode].value;
#line 144
      if ((unsigned long )tree.ibuf >= (unsigned long )tree.ibufmax) {
#line 144
        if (! tree.bitnum) {
#line 144
          goto while_break___0;
        }
      }
#line 137
      if ((int )tree.nodes[actnode].left >= 0) {
#line 137
        if (! ((int )tree.nodes[actnode].right >= 0)) {
#line 137
          goto while_break___0;
        }
      } else {
#line 137
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 148
    if (sign) {
#line 149
      delta = (uint8 )((int )delta ^ 255);
    }
#line 150
    value = (uint8 )((int )value + (int )delta);
#line 151
    if (i___3) {
#line 151
      *(psample + i___3) = value;
    } else {
#line 151
      *(psample + i___3) = (uint8 )0;
    }
#line 133
    i___3 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 154
  return ((int )(tree.ibuf - ibuf___0));
}
}
#line 162 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/dmf_load.c"
static void get_sequ___0(struct xmp_context *ctx___0 , int size___0 , FILE *f ) 
{ 
  struct xmp_player_context *p ;
  struct xmp_mod_context *m___0 ;
  int i___3 ;
  uint16 tmp ;

  {
  {
#line 164
  p = & ctx___0->p;
#line 165
  m___0 = & p->m;
#line 168
  read16l(f);
#line 169
  read16l(f);
#line 171
  (m___0->xxh)->len = (size___0 - 4) / 2;
  }
#line 172
  if ((m___0->xxh)->len > 255) {
#line 173
    (m___0->xxh)->len = 255;
  }
#line 175
  i___3 = 0;
  {
#line 175
  while (1) {
    while_continue: /* CIL Label */ ;
#line 175
    if (! (i___3 < (m___0->xxh)->len)) {
#line 175
      goto while_break;
    }
    {
#line 176
    tmp = read16l(f);
#line 176
    m___0->xxo[i___3] = (uint8 )tmp;
#line 175
    i___3 ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 177
  return;
}
}
#line 179 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/dmf_load.c"
static void get_patt___4(struct xmp_context *ctx___0 , int size___0 , FILE *f ) 
{ 
  struct xmp_player_context *p ;
  struct xmp_mod_context *m___0 ;
  int i___3 ;
  int j ;
  int r ;
  int chn ;
  int patsize ;
  int info ;
  int counter ;
  int data ;
  int track_counter[32] ;
  struct xxm_event *event ;
  uint16 tmp ;
  uint8 tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  uint8 tmp___4 ;
  uint16 tmp___5 ;
  int j___0 ;
  void *tmp___6 ;
  uint32 tmp___7 ;
  uint8 tmp___8 ;
  uint8 tmp___9 ;
  uint8 tmp___10 ;
  int b___1 ;
  int fxt ;
  int fxp ;
  uint8 tmp___11 ;
  uint8 tmp___12 ;
  uint8 tmp___13 ;
  uint8 tmp___14 ;
  uint8 tmp___15 ;
  uint8 tmp___16 ;
  uint8 tmp___17 ;
  uint8 tmp___18 ;
  uint8 tmp___19 ;
  void *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;

  {
  {
#line 181
  p = & ctx___0->p;
#line 182
  m___0 = & p->m;
#line 189
  tmp = read16l(f);
#line 189
  (m___0->xxh)->pat = (int )tmp;
#line 190
  tmp___0 = read8(f);
#line 190
  (m___0->xxh)->chn = (int )tmp___0;
#line 191
  (m___0->xxh)->trk = (m___0->xxh)->chn * (m___0->xxh)->pat;
  }
  {
#line 193
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 193
    tmp___1 = calloc((size_t )sizeof(struct xxm_track *), (size_t )(m___0->xxh)->trk);
#line 193
    m___0->xxt = (struct xxm_track **)tmp___1;
#line 193
    tmp___2 = calloc((size_t )sizeof(struct xxm_pattern *), (size_t )((m___0->xxh)->pat + 1));
#line 193
    m___0->xxp = (struct xxm_pattern **)tmp___2;
    }
#line 193
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 195
  if (m___0->verbosity > 0) {
    {
#line 196
    report((char *)"Stored patterns: %d ", (m___0->xxh)->pat);
    }
  }
#line 198
  i___3 = 0;
  {
#line 198
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 198
    if (! (i___3 < (m___0->xxh)->pat)) {
#line 198
      goto while_break___0;
    }
    {
#line 199
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 199
      tmp___3 = calloc((size_t )1, (size_t )(sizeof(struct xxm_pattern ) + sizeof(struct xxm_trackinfo ) * (unsigned long )((m___0->xxh)->chn - 1)));
#line 199
      *(m___0->xxp + i___3) = (struct xxm_pattern *)tmp___3;
      }
#line 199
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 200
    tmp___4 = read8(f);
#line 200
    chn = (int )tmp___4;
#line 201
    read8(f);
#line 202
    tmp___5 = read16l(f);
#line 202
    (*(m___0->xxp + i___3))->rows = (int )tmp___5;
    }
    {
#line 203
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 203
      j___0 = 0;
      {
#line 203
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 203
        if (! (j___0 < (m___0->xxh)->chn)) {
#line 203
          goto while_break___3;
        }
        {
#line 203
        (*(m___0->xxp + i___3))->info[j___0].index = i___3 * (m___0->xxh)->chn + j___0;
#line 203
        tmp___6 = calloc((size_t )(sizeof(struct xxm_track ) + sizeof(struct xxm_event ) * (unsigned long )(*(m___0->xxp + i___3))->rows),
                         (size_t )1);
#line 203
        *(m___0->xxt + (i___3 * (m___0->xxh)->chn + j___0)) = (struct xxm_track *)tmp___6;
#line 203
        (*(m___0->xxt + (i___3 * (m___0->xxh)->chn + j___0)))->rows = (*(m___0->xxp + i___3))->rows;
#line 203
        j___0 ++;
        }
      }
      while_break___3: /* CIL Label */ ;
      }
#line 203
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 205
    tmp___7 = read32l(f);
#line 205
    patsize = (int )tmp___7;
#line 207
    j = 0;
    }
    {
#line 207
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 207
      if (! (j < chn)) {
#line 207
        goto while_break___4;
      }
#line 208
      track_counter[j] = 0;
#line 207
      j ++;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 210
    r = 0;
#line 210
    counter = r;
    {
#line 210
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 210
      if (! (r < (*(m___0->xxp + i___3))->rows)) {
#line 210
        goto while_break___5;
      }
#line 211
      if (counter == 0) {
        {
#line 213
        tmp___8 = read8(f);
#line 213
        info = (int )tmp___8;
        }
#line 214
        if (info & 128) {
          {
#line 214
          tmp___9 = read8(f);
#line 214
          counter = (int )tmp___9;
          }
        } else {
#line 214
          counter = 0;
        }
#line 215
        if (info & 63) {
          {
#line 215
          tmp___10 = read8(f);
#line 215
          data = (int )tmp___10;
          }
        } else {
#line 215
          data = 0;
        }
      } else {
#line 217
        counter --;
      }
#line 220
      j = 0;
      {
#line 220
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 220
        if (! (j < chn)) {
#line 220
          goto while_break___6;
        }
#line 223
        event = & (*(m___0->xxt + (*(m___0->xxp + i___3))->info[j].index))->event[r];
#line 225
        if (track_counter[j] == 0) {
          {
#line 226
          tmp___11 = read8(f);
#line 226
          b___1 = (int )tmp___11;
          }
#line 228
          if (b___1 & 128) {
            {
#line 229
            tmp___12 = read8(f);
#line 229
            track_counter[j] = (int )tmp___12;
            }
          }
#line 230
          if (b___1 & 64) {
            {
#line 231
            event->ins = read8(f);
            }
          }
#line 232
          if (b___1 & 32) {
            {
#line 233
            tmp___13 = read8(f);
#line 233
            event->note = (uint8 )(12 + (int )tmp___13);
            }
          }
#line 234
          if (b___1 & 16) {
            {
#line 235
            event->vol = read8(f);
            }
          }
#line 236
          if (b___1 & 8) {
            {
#line 237
            tmp___14 = read8(f);
#line 237
            fxt = (int )tmp___14;
#line 238
            tmp___15 = read8(f);
#line 238
            fxp = (int )tmp___15;
            }
          }
#line 240
          if (b___1 & 4) {
            {
#line 241
            tmp___16 = read8(f);
#line 241
            fxt = (int )tmp___16;
#line 242
            tmp___17 = read8(f);
#line 242
            fxp = (int )tmp___17;
            }
          }
#line 244
          if (b___1 & 2) {
            {
#line 245
            tmp___18 = read8(f);
#line 245
            fxt = (int )tmp___18;
#line 246
            tmp___19 = read8(f);
#line 246
            fxp = (int )tmp___19;
            }
            {
#line 248
            if (fxt == 2) {
#line 248
              goto case_2;
            }
#line 247
            goto switch_break;
            case_2: /* CIL Label */ 
#line 249
            event->fxt = (uint8 )161;
#line 250
            event->fxp = (uint8 )fxp;
#line 251
            goto switch_break;
            switch_break: /* CIL Label */ ;
            }
          }
        } else {
#line 255
          (track_counter[j]) --;
        }
#line 220
        j ++;
      }
      while_break___6: /* CIL Label */ ;
      }
#line 210
      r ++;
    }
    while_break___5: /* CIL Label */ ;
    }
    {
#line 259
    reportv(ctx___0, 0, (char *)".");
#line 198
    i___3 ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 261
  reportv(ctx___0, 0, (char *)"\n");
  }
#line 262
  return;
}
}
#line 264 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/dmf_load.c"
static void get_smpi(struct xmp_context *ctx___0 , int size___0 , FILE *f ) 
{ 
  struct xmp_player_context *p ;
  struct xmp_mod_context *m___0 ;
  int i___3 ;
  int namelen ;
  int c3spd ;
  int flag ;
  uint8 name[30] ;
  int tmp ;
  uint8 tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  int x ;
  void *tmp___8 ;
  uint8 tmp___9 ;
  int tmp___10 ;
  size_t tmp___11 ;
  int tmp___12 ;
  uint32 tmp___13 ;
  uint32 tmp___14 ;
  uint32 tmp___15 ;
  uint16 tmp___16 ;
  uint8 tmp___17 ;
  uint8 tmp___18 ;
  int tmp___19 ;
  size_t tmp___20 ;
  void *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;

  {
  {
#line 266
  p = & ctx___0->p;
#line 267
  m___0 = & p->m;
#line 271
  tmp___0 = read8(f);
#line 271
  tmp = (int )tmp___0;
#line 271
  (m___0->xxh)->smp = tmp;
#line 271
  (m___0->xxh)->ins = tmp;
  }
  {
#line 273
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 273
    tmp___1 = calloc((size_t )sizeof(struct xxm_instrument_header ), (size_t )(m___0->xxh)->ins);
#line 273
    m___0->xxih = (struct xxm_instrument_header *)tmp___1;
#line 273
    tmp___2 = calloc((size_t )sizeof(struct xxm_instrument_map ), (size_t )(m___0->xxh)->ins);
#line 273
    m___0->xxim = (struct xxm_instrument_map *)tmp___2;
#line 273
    tmp___3 = calloc((size_t )sizeof(struct xxm_instrument *), (size_t )(m___0->xxh)->ins);
#line 273
    m___0->xxi = (struct xxm_instrument **)tmp___3;
    }
#line 273
    if ((m___0->xxh)->smp) {
      {
#line 273
      tmp___4 = calloc((size_t )sizeof(struct xxm_sample ), (size_t )(m___0->xxh)->smp);
#line 273
      m___0->xxs = (struct xxm_sample *)tmp___4;
      }
    }
    {
#line 273
    tmp___5 = calloc((size_t )sizeof(uint16 *), (size_t )(m___0->xxh)->ins);
#line 273
    m___0->xxae = (uint16 **)tmp___5;
#line 273
    tmp___6 = calloc((size_t )sizeof(uint16 *), (size_t )(m___0->xxh)->ins);
#line 273
    m___0->xxpe = (uint16 **)tmp___6;
#line 273
    tmp___7 = calloc((size_t )sizeof(uint16 *), (size_t )(m___0->xxh)->ins);
#line 273
    m___0->xxfe = (uint16 **)tmp___7;
    }
#line 273
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 275
  reportv(ctx___0, 0, (char *)"Instruments    : %d\n", (m___0->xxh)->ins);
#line 277
  i___3 = 0;
  }
  {
#line 277
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 277
    if (! (i___3 < (m___0->xxh)->ins)) {
#line 277
      goto while_break___0;
    }
    {
#line 280
    tmp___8 = calloc((size_t )sizeof(struct xxm_instrument ), (size_t )1);
#line 280
    *(m___0->xxi + i___3) = (struct xxm_instrument *)tmp___8;
#line 282
    tmp___9 = read8(f);
#line 282
    namelen = (int )tmp___9;
    }
#line 283
    if (namelen > 30) {
#line 283
      tmp___10 = 30;
    } else {
#line 283
      tmp___10 = namelen;
    }
    {
#line 283
    tmp___11 = fread((void */* __restrict  */)(name), (size_t )1, (size_t )tmp___10,
                     (FILE */* __restrict  */)f);
#line 283
    x = (int )((size_t )namelen - tmp___11);
#line 284
    copy_adjust((m___0->xxih + i___3)->name, name, namelen);
#line 285
    name[namelen] = (uint8 )0;
    }
    {
#line 286
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 286
      tmp___12 = x;
#line 286
      x --;
#line 286
      if (! tmp___12) {
#line 286
        goto while_break___1;
      }
      {
#line 287
      read8(f);
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 289
    tmp___13 = read32l(f);
#line 289
    (m___0->xxs + i___3)->len = (int )tmp___13;
#line 290
    tmp___14 = read32l(f);
#line 290
    (m___0->xxs + i___3)->lps = (int )tmp___14;
#line 291
    tmp___15 = read32l(f);
#line 291
    (m___0->xxs + i___3)->lpe = (int )tmp___15;
#line 292
    (m___0->xxih + i___3)->nsm = ! (! (m___0->xxs + i___3)->len);
#line 293
    tmp___16 = read16l(f);
#line 293
    c3spd = (int )tmp___16;
#line 294
    c2spd_to_note(c3spd, & (*(m___0->xxi + i___3) + 0)->xpo, & (*(m___0->xxi + i___3) + 0)->fin);
#line 295
    tmp___17 = read8(f);
#line 295
    (*(m___0->xxi + i___3) + 0)->vol = (int )tmp___17;
#line 296
    (*(m___0->xxi + i___3) + 0)->pan = 128;
#line 297
    (*(m___0->xxi + i___3) + 0)->sid = i___3;
#line 298
    tmp___18 = read8(f);
#line 298
    flag = (int )tmp___18;
    }
#line 299
    if (flag & 1) {
#line 299
      (m___0->xxs + i___3)->flg = 4;
    } else {
#line 299
      (m___0->xxs + i___3)->flg = 0;
    }
#line 300
    if (ver >= 8) {
      {
#line 301
      fseek(f, 8L, 1);
      }
    }
    {
#line 302
    read16l(f);
#line 303
    read32l(f);
#line 305
    packtype[i___3] = (uint8 )((flag & 12) >> 2);
    }
#line 306
    if (m___0->verbosity > 1) {
      {
#line 306
      tmp___20 = strlen((char const   *)((char *)((m___0->xxih + i___3)->name)));
      }
#line 306
      if (tmp___20) {
#line 306
        goto _L;
      } else
#line 306
      if ((m___0->xxs + i___3)->len > 1) {
        _L: /* CIL Label */ 
#line 307
        if ((m___0->xxs + i___3)->flg & 4) {
#line 307
          tmp___19 = 'L';
        } else {
#line 307
          tmp___19 = ' ';
        }
        {
#line 307
        report((char *)"[%2X] %-30.30s %05x %05x %05x %c P%c %5d V%02x\n", i___3,
               name, (m___0->xxs + i___3)->len, (m___0->xxs + i___3)->lps & 1048575,
               (m___0->xxs + i___3)->lpe & 1048575, tmp___19, 48 + (int )packtype[i___3],
               c3spd, (*(m___0->xxi + i___3) + 0)->vol);
        }
      }
    }
#line 277
    i___3 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 315
  return;
}
}
#line 317 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/dmf_load.c"
static void get_smpd(struct xmp_context *ctx___0 , int size___0 , FILE *f ) 
{ 
  struct xmp_player_context *p ;
  struct xmp_mod_context *m___0 ;
  int i___3 ;
  int smpsize ;
  uint8 *data ;
  uint8 *ibuf___0 ;
  void *tmp ;
  void *tmp___0 ;
  uint32 tmp___1 ;
  char const   *tmp___2 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;

  {
  {
#line 319
  p = & ctx___0->p;
#line 320
  m___0 = & p->m;
#line 325
  reportv(ctx___0, 0, (char *)"Stored samples : %d ", (m___0->xxh)->ins);
#line 327
  i___3 = 0;
#line 327
  smpsize = i___3;
  }
  {
#line 327
  while (1) {
    while_continue: /* CIL Label */ ;
#line 327
    if (! (i___3 < (m___0->xxh)->smp)) {
#line 327
      goto while_break;
    }
#line 328
    if ((m___0->xxs + i___3)->len > smpsize) {
#line 329
      smpsize = (m___0->xxs + i___3)->len;
    }
#line 327
    i___3 ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 333
  tmp = malloc((size_t )smpsize);
#line 333
  data = (uint8 *)tmp;
  }
#line 334
  if (! ((unsigned long )data != (unsigned long )((void *)0))) {
    {
#line 334
    __assert_fail("data != ((void *)0)", "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/dmf_load.c",
                  334U, "get_smpd");
    }
  }
  {
#line 335
  tmp___0 = malloc((size_t )smpsize);
#line 335
  ibuf___0 = (uint8 *)tmp___0;
  }
#line 336
  if (! ((unsigned long )ibuf___0 != (unsigned long )((void *)0))) {
    {
#line 336
    __assert_fail("ibuf != ((void *)0)", "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/dmf_load.c",
                  336U, "get_smpd");
    }
  }
#line 338
  i___3 = 0;
  {
#line 338
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 338
    if (! (i___3 < (m___0->xxh)->smp)) {
#line 338
      goto while_break___0;
    }
    {
#line 339
    tmp___1 = read32l(f);
#line 339
    smpsize = (int )tmp___1;
    }
#line 340
    if (smpsize == 0) {
#line 341
      goto __Cont;
    }
    {
#line 344
    if ((int )packtype[i___3] == 0) {
#line 344
      goto case_0;
    }
#line 348
    if ((int )packtype[i___3] == 1) {
#line 348
      goto case_1;
    }
#line 354
    goto switch_default;
    case_0: /* CIL Label */ 
    {
#line 345
    xmp_drv_loadpatch(ctx___0, f, (*(m___0->xxi + i___3) + 0)->sid, m___0->c4rate,
                      0, m___0->xxs + (*(m___0->xxi + i___3) + 0)->sid, (char *)((void *)0));
    }
#line 347
    goto switch_break;
    case_1: /* CIL Label */ 
    {
#line 349
    fread((void */* __restrict  */)ibuf___0, (size_t )smpsize, (size_t )1, (FILE */* __restrict  */)f);
#line 350
    unpack___0(data, ibuf___0, ibuf___0 + smpsize, (uint32 )(m___0->xxs + i___3)->len);
#line 351
    xmp_drv_loadpatch(ctx___0, (FILE *)((void *)0), i___3, m___0->c4rate, 16, m___0->xxs + i___3,
                      (char *)data);
    }
#line 353
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 355
    fseek(f, (long )smpsize, 1);
    }
    switch_break: /* CIL Label */ ;
    }
#line 357
    if (packtype[i___3]) {
#line 357
      tmp___2 = "c";
    } else {
#line 357
      tmp___2 = ".";
    }
    {
#line 357
    reportv(ctx___0, 0, (char *)tmp___2);
    }
    __Cont: /* CIL Label */ 
#line 338
    i___3 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 359
  reportv(ctx___0, 0, (char *)"\n");
#line 361
  free((void *)ibuf___0);
#line 362
  free((void *)data);
  }
#line 363
  return;
}
}
#line 365 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/dmf_load.c"
static int dmf_load(struct xmp_context *ctx___0 , FILE *f , int const   start ) 
{ 
  struct xmp_player_context *p ;
  struct xmp_mod_context *m___0 ;
  char composer[64] ;
  uint8 date[3] ;
  char tracker_name[10] ;
  uint8 **tmp ;
  uint8 tmp___0 ;
  int tmp___1 ;
  void *__cil_tmp12 ;
  void *__cil_tmp13 ;
  void *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;

  {
#line 367
  p = & ctx___0->p;
#line 368
  m___0 = & p->m;
  {
#line 373
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 373
    fseek(f, (long )start, 0);
#line 373
    tmp = (uint8 **)((void *)0);
#line 373
    m___0->med_wav_table = tmp;
#line 373
    m___0->med_vol_table = tmp;
#line 373
    set_xxh_defaults(m___0->xxh);
    }
#line 373
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 375
  read32b(f);
#line 377
  tmp___0 = read8(f);
#line 377
  ver = (int )tmp___0;
#line 378
  fread((void */* __restrict  */)(tracker_name), (size_t )8, (size_t )1, (FILE */* __restrict  */)f);
#line 379
  snprintf((char */* __restrict  */)(m___0->type), (size_t )64, (char const   */* __restrict  */)"D-Lusion Digital Music File v%d (%s)",
           ver, tracker_name);
#line 381
  tracker_name[8] = (char)0;
#line 382
  fread((void */* __restrict  */)(m___0->name), (size_t )30, (size_t )1, (FILE */* __restrict  */)f);
#line 383
  fread((void */* __restrict  */)(composer), (size_t )20, (size_t )1, (FILE */* __restrict  */)f);
#line 384
  fread((void */* __restrict  */)(date), (size_t )3, (size_t )1, (FILE */* __restrict  */)f);
  }
  {
#line 386
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 386
    if (m___0->verbosity) {
#line 386
      if (m___0->name[0]) {
        {
#line 386
        report((char *)"Module title   : %s\n", m___0->name);
        }
      }
#line 386
      if (m___0->type[0]) {
        {
#line 386
        report((char *)"Module type    : %s\n", m___0->type);
        }
      }
#line 386
      if (m___0->author[0]) {
        {
#line 386
        report((char *)"Author name    : %s\n", m___0->author);
        }
      }
#line 386
      if ((m___0->xxh)->len) {
        {
#line 386
        report((char *)"Module length  : %d patterns\n", (m___0->xxh)->len);
        }
      }
    }
#line 386
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 387
  if (m___0->verbosity > 0) {
    {
#line 388
    report((char *)"Composer name  : %s\n", composer);
#line 389
    report((char *)"Creation date  : %02d/%02d/%04d\n", (int )date[0], (int )date[1],
           1900 + (int )date[2]);
    }
  }
  {
#line 394
  iff_register((char *)"SEQU", & get_sequ___0);
#line 395
  iff_register((char *)"PATT", & get_patt___4);
#line 396
  iff_register((char *)"SMPI", & get_smpi);
#line 397
  iff_register((char *)"SMPD", & get_smpd);
#line 398
  iff_setflag(1);
  }
  {
#line 401
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 401
    tmp___1 = feof(f);
    }
#line 401
    if (tmp___1) {
#line 401
      goto while_break___1;
    }
    {
#line 402
    iff_chunk(ctx___0, f);
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 404
  m___0->volbase = 255;
#line 406
  iff_release();
  }
#line 408
  return (0);
}
}
#line 18 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/rtm_load.c"
static int rtm_test(FILE *f , char *t , int const   start ) ;
#line 19
static int rtm_load(struct xmp_context *ctx___0 , FILE *f , int const   start ) ;
#line 21 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/rtm_load.c"
struct xmp_loader_info rtm_loader  =    {(char *)"RTM", (char *)"Real Tracker", & rtm_test, & rtm_load, 0, {(struct list_head *)0,
                                                                       (struct list_head *)0}};
#line 28 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/rtm_load.c"
static int rtm_test(FILE *f , char *t , int const   start ) 
{ 
  char buf___1[4] ;
  int tmp ;
  uint8 tmp___0 ;
  void *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
  {
#line 32
  fread((void */* __restrict  */)(buf___1), (size_t )4, (size_t )1, (FILE */* __restrict  */)f);
#line 33
  tmp = memcmp((void const   *)(buf___1), (void const   *)"RTMM", (size_t )4);
  }
#line 33
  if (tmp) {
#line 34
    return (-1);
  }
  {
#line 36
  tmp___0 = read8(f);
  }
#line 36
  if ((int )tmp___0 != 32) {
#line 37
    return (-1);
  }
  {
#line 39
  read_title(f, t, 32);
  }
#line 41
  return (0);
}
}
#line 47 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/rtm_load.c"
static int read_object_header(FILE *f , struct ObjectHeader *h ) 
{ 
  uint8 tmp ;
  uint8 tmp___0 ;

  {
  {
#line 49
  fread((void */* __restrict  */)(& h->id), (size_t )4, (size_t )1, (FILE */* __restrict  */)f);
  }
  {
#line 50
  while (1) {
    while_continue: /* CIL Label */ ;
#line 50
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 52
  tmp = read8(f);
#line 52
  h->rc = (char )tmp;
  }
#line 53
  if ((int )h->rc != 32) {
#line 54
    return (-1);
  }
  {
#line 55
  fread((void */* __restrict  */)(& h->name), (size_t )32, (size_t )1, (FILE */* __restrict  */)f);
#line 56
  tmp___0 = read8(f);
#line 56
  h->eof = (char )tmp___0;
#line 57
  h->version = read16l(f);
#line 58
  h->headerSize = read16l(f);
  }
  {
#line 59
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 59
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 61
  return (0);
}
}
#line 65 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/rtm_load.c"
static int rtm_load(struct xmp_context *ctx___0 , FILE *f , int const   start ) 
{ 
  struct xmp_player_context *p ;
  struct xmp_mod_context *m___0 ;
  int i___3 ;
  int j ;
  int r ;
  struct xxm_event *event ;
  struct ObjectHeader oh ;
  struct RTMMHeader rh ;
  struct RTNDHeader rp ;
  struct RTINHeader ri ;
  struct RTSMHeader rs ;
  int offset ;
  int smpnum ;
  uint8 **tmp ;
  uint16 tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  uint8 c___0 ;
  void *tmp___3 ;
  int j___0 ;
  void *tmp___4 ;
  uint8 tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  void *tmp___9 ;
  void *tmp___10 ;
  void *tmp___11 ;
  void *tmp___12 ;
  size_t tmp___13 ;
  size_t tmp___14 ;
  uint32 tmp___15 ;
  uint32 tmp___16 ;
  uint32 tmp___17 ;
  uint32 tmp___18 ;
  uint8 tmp___19 ;
  uint8 tmp___20 ;
  uint8 tmp___21 ;
  uint8 tmp___22 ;
  size_t tmp___23 ;
  void *tmp___24 ;
  void *tmp___25 ;
  void *tmp___26 ;
  uint32 tmp___27 ;
  uint8 tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;
  char const   *tmp___34 ;
  size_t tmp___35 ;
  void *tmp___36 ;
  void *__cil_tmp57 ;
  void *__cil_tmp58 ;
  void *__cil_tmp59 ;
  void *__cil_tmp60 ;
  void *__cil_tmp61 ;
  void *__cil_tmp62 ;
  void *__cil_tmp63 ;
  void *__cil_tmp64 ;
  void *__cil_tmp65 ;
  void *__cil_tmp66 ;
  void *__cil_tmp67 ;
  void *__cil_tmp68 ;
  int __cil_tmp69 ;
  void *__cil_tmp70 ;
  void *__cil_tmp71 ;
  void *__cil_tmp72 ;
  int __cil_tmp73 ;
  void *__cil_tmp74 ;
  void *__cil_tmp75 ;
  char *__cil_tmp76 ;
  char *__cil_tmp77 ;
  char *__cil_tmp78 ;
  char *__cil_tmp79 ;
  char *__cil_tmp80 ;
  char *__cil_tmp81 ;
  char *__cil_tmp82 ;
  char *__cil_tmp83 ;
  char *__cil_tmp84 ;
  char *__cil_tmp85 ;
  char *__cil_tmp86 ;
  char *__cil_tmp87 ;
  char *__cil_tmp88 ;
  char *__cil_tmp89 ;
  char *__cil_tmp90 ;
  char *__cil_tmp91 ;
  char *__cil_tmp92 ;
  char *__cil_tmp93 ;
  char *__cil_tmp94 ;
  char *__cil_tmp95 ;
  char *__cil_tmp96 ;
  char *__cil_tmp97 ;

  {
#line 67
  p = & ctx___0->p;
#line 68
  m___0 = & p->m;
  {
#line 78
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 78
    fseek(f, (long )start, 0);
#line 78
    tmp = (uint8 **)((void *)0);
#line 78
    m___0->med_wav_table = tmp;
#line 78
    m___0->med_vol_table = tmp;
#line 78
    set_xxh_defaults(m___0->xxh);
    }
#line 78
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 80
  read_object_header(f, & oh);
#line 82
  fread((void */* __restrict  */)(& rh.software), (size_t )1, (size_t )20, (FILE */* __restrict  */)f);
#line 83
  fread((void */* __restrict  */)(& rh.composer), (size_t )1, (size_t )32, (FILE */* __restrict  */)f);
#line 84
  rh.flags = read16l(f);
#line 85
  rh.ntrack = read8(f);
#line 86
  rh.ninstr = read8(f);
#line 87
  rh.nposition = read16l(f);
#line 88
  rh.npattern = read16l(f);
#line 89
  rh.speed = read8(f);
#line 90
  rh.tempo = read8(f);
#line 91
  fread((void */* __restrict  */)(& rh.panning), (size_t )32, (size_t )1, (FILE */* __restrict  */)f);
#line 92
  rh.extraDataSize = read32l(f);
#line 93
  i___3 = 0;
  }
  {
#line 93
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 93
    if (! (i___3 < (int )rh.nposition)) {
#line 93
      goto while_break___0;
    }
    {
#line 94
    tmp___0 = read16l(f);
#line 94
    m___0->xxo[i___3] = (uint8 )tmp___0;
#line 93
    i___3 ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 96
  strncpy((char */* __restrict  */)(m___0->name), (char const   */* __restrict  */)(oh.name),
          (size_t )20);
#line 97
  snprintf((char */* __restrict  */)(m___0->type), (size_t )64, (char const   */* __restrict  */)"RTMM %d.%02d (%s)",
           (int )oh.version >> 8, (int )oh.version & 255, rh.software);
#line 100
  (m___0->xxh)->len = (int )rh.nposition;
#line 101
  (m___0->xxh)->pat = (int )rh.npattern;
#line 102
  (m___0->xxh)->chn = (int )rh.ntrack;
#line 103
  (m___0->xxh)->trk = (m___0->xxh)->chn * (m___0->xxh)->pat + 1;
#line 104
  (m___0->xxh)->ins = (int )rh.ninstr;
#line 105
  (m___0->xxh)->tpo = (int )rh.speed;
#line 106
  (m___0->xxh)->bpm = (int )rh.tempo;
  }
#line 107
  if ((int )rh.flags & 1) {
#line 107
    (m___0->xxh)->flg = 1;
  } else {
#line 107
    (m___0->xxh)->flg = 0;
  }
  {
#line 109
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 109
    if (m___0->verbosity) {
#line 109
      if (m___0->name[0]) {
        {
#line 109
        report((char *)"Module title   : %s\n", m___0->name);
        }
      }
#line 109
      if (m___0->type[0]) {
        {
#line 109
        report((char *)"Module type    : %s\n", m___0->type);
        }
      }
#line 109
      if (m___0->author[0]) {
        {
#line 109
        report((char *)"Author name    : %s\n", m___0->author);
        }
      }
#line 109
      if ((m___0->xxh)->len) {
        {
#line 109
        report((char *)"Module length  : %d patterns\n", (m___0->xxh)->len);
        }
      }
    }
#line 109
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 111
  i___3 = 0;
  {
#line 111
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 111
    if (! (i___3 < (m___0->xxh)->chn)) {
#line 111
      goto while_break___2;
    }
#line 112
    m___0->xxc[i___3].pan = (int )rh.panning[i___3] & 255;
#line 111
    i___3 ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 114
  while (1) {
    while_continue___3: /* CIL Label */ ;
    {
#line 114
    tmp___1 = calloc((size_t )sizeof(struct xxm_track *), (size_t )(m___0->xxh)->trk);
#line 114
    m___0->xxt = (struct xxm_track **)tmp___1;
#line 114
    tmp___2 = calloc((size_t )sizeof(struct xxm_pattern *), (size_t )((m___0->xxh)->pat + 1));
#line 114
    m___0->xxp = (struct xxm_pattern **)tmp___2;
    }
#line 114
    goto while_break___3;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 116
  if (m___0->verbosity > 0) {
    {
#line 117
    report((char *)"Stored patterns: %d ", (m___0->xxh)->pat);
    }
  }
#line 119
  offset = (int )((DWORD )(42 + (int )oh.headerSize) + rh.extraDataSize);
#line 121
  i___3 = 0;
  {
#line 121
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 121
    if (! (i___3 < (m___0->xxh)->pat)) {
#line 121
      goto while_break___4;
    }
    {
#line 124
    fseek(f, (long )(start + (int const   )offset), 0);
#line 126
    read_object_header(f, & oh);
#line 128
    rp.flags = read16l(f);
#line 129
    rp.ntrack = read8(f);
#line 130
    rp.nrows = read16l(f);
#line 131
    rp.datasize = read32l(f);
#line 133
    offset = (int )((DWORD )offset + ((DWORD )(42 + (int )oh.headerSize) + rp.datasize));
    }
    {
#line 135
    while (1) {
      while_continue___5: /* CIL Label */ ;
      {
#line 135
      tmp___3 = calloc((size_t )1, (size_t )(sizeof(struct xxm_pattern ) + sizeof(struct xxm_trackinfo ) * (unsigned long )((m___0->xxh)->chn - 1)));
#line 135
      *(m___0->xxp + i___3) = (struct xxm_pattern *)tmp___3;
      }
#line 135
      goto while_break___5;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 136
    (*(m___0->xxp + i___3))->rows = (int )rp.nrows;
    {
#line 137
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 137
      j___0 = 0;
      {
#line 137
      while (1) {
        while_continue___7: /* CIL Label */ ;
#line 137
        if (! (j___0 < (m___0->xxh)->chn)) {
#line 137
          goto while_break___7;
        }
        {
#line 137
        (*(m___0->xxp + i___3))->info[j___0].index = i___3 * (m___0->xxh)->chn + j___0;
#line 137
        tmp___4 = calloc((size_t )(sizeof(struct xxm_track ) + sizeof(struct xxm_event ) * (unsigned long )(*(m___0->xxp + i___3))->rows),
                         (size_t )1);
#line 137
        *(m___0->xxt + (i___3 * (m___0->xxh)->chn + j___0)) = (struct xxm_track *)tmp___4;
#line 137
        (*(m___0->xxt + (i___3 * (m___0->xxh)->chn + j___0)))->rows = (*(m___0->xxp + i___3))->rows;
#line 137
        j___0 ++;
        }
      }
      while_break___7: /* CIL Label */ ;
      }
#line 137
      goto while_break___6;
    }
    while_break___6: /* CIL Label */ ;
    }
#line 139
    r = 0;
    {
#line 139
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 139
      if (! (r < (int )rp.nrows)) {
#line 139
        goto while_break___8;
      }
#line 140
      j = 0;
      {
#line 140
      while (1) {
        while_continue___9: /* CIL Label */ ;
#line 140
        if (! (j < (int )rp.ntrack)) {
#line 140
          goto while_break___9;
        }
        {
#line 141
        event = & (*(m___0->xxt + (*(m___0->xxp + i___3))->info[j].index))->event[r];
#line 142
        c___0 = read8(f);
        }
#line 143
        if ((int )c___0 == 0) {
#line 144
          goto while_break___9;
        }
#line 145
        if ((int )c___0 & 1) {
          {
#line 146
          tmp___5 = read8(f);
#line 146
          j = (int )tmp___5;
#line 147
          event = & (*(m___0->xxt + (*(m___0->xxp + i___3))->info[j].index))->event[r];
          }
        }
#line 149
        if ((int )c___0 & 2) {
          {
#line 150
          event->note = read8(f);
          }
#line 151
          if ((int )event->note == 97) {
#line 152
            event->note = (uint8 )129;
          }
        }
#line 154
        if ((int )c___0 & 4) {
          {
#line 155
          event->ins = read8(f);
          }
        }
#line 156
        if ((int )c___0 & 8) {
          {
#line 157
          event->fxt = read8(f);
          }
        }
#line 158
        if ((int )c___0 & 16) {
          {
#line 159
          event->fxp = read8(f);
          }
        }
#line 160
        if ((int )c___0 & 32) {
          {
#line 161
          event->f2t = read8(f);
          }
        }
#line 162
        if ((int )c___0 & 64) {
          {
#line 163
          event->f2p = read8(f);
          }
        }
#line 140
        j ++;
      }
      while_break___9: /* CIL Label */ ;
      }
#line 139
      r ++;
    }
    while_break___8: /* CIL Label */ ;
    }
#line 168
    if (m___0->verbosity > 0) {
      {
#line 169
      report((char *)".");
      }
    }
#line 121
    i___3 ++;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 172
  if (m___0->verbosity > 0) {
    {
#line 173
    report((char *)"\n");
    }
  }
#line 179
  if (m___0->verbosity > 0) {
    {
#line 180
    report((char *)"Instruments    : %d ", (m___0->xxh)->ins);
    }
  }
#line 181
  if (m___0->verbosity > 1) {
    {
#line 182
    report((char *)"\n");
    }
  }
  {
#line 184
  fseek(f, (long )(start + (int const   )offset), 0);
#line 187
  (m___0->xxh)->smp = 1024;
  }
  {
#line 189
  while (1) {
    while_continue___10: /* CIL Label */ ;
    {
#line 189
    tmp___6 = calloc((size_t )sizeof(struct xxm_instrument_header ), (size_t )(m___0->xxh)->ins);
#line 189
    m___0->xxih = (struct xxm_instrument_header *)tmp___6;
#line 189
    tmp___7 = calloc((size_t )sizeof(struct xxm_instrument_map ), (size_t )(m___0->xxh)->ins);
#line 189
    m___0->xxim = (struct xxm_instrument_map *)tmp___7;
#line 189
    tmp___8 = calloc((size_t )sizeof(struct xxm_instrument *), (size_t )(m___0->xxh)->ins);
#line 189
    m___0->xxi = (struct xxm_instrument **)tmp___8;
    }
#line 189
    if ((m___0->xxh)->smp) {
      {
#line 189
      tmp___9 = calloc((size_t )sizeof(struct xxm_sample ), (size_t )(m___0->xxh)->smp);
#line 189
      m___0->xxs = (struct xxm_sample *)tmp___9;
      }
    }
    {
#line 189
    tmp___10 = calloc((size_t )sizeof(uint16 *), (size_t )(m___0->xxh)->ins);
#line 189
    m___0->xxae = (uint16 **)tmp___10;
#line 189
    tmp___11 = calloc((size_t )sizeof(uint16 *), (size_t )(m___0->xxh)->ins);
#line 189
    m___0->xxpe = (uint16 **)tmp___11;
#line 189
    tmp___12 = calloc((size_t )sizeof(uint16 *), (size_t )(m___0->xxh)->ins);
#line 189
    m___0->xxfe = (uint16 **)tmp___12;
    }
#line 189
    goto while_break___10;
  }
  while_break___10: /* CIL Label */ ;
  }
#line 191
  i___3 = 0;
#line 191
  smpnum = i___3;
  {
#line 191
  while (1) {
    while_continue___11: /* CIL Label */ ;
#line 191
    if (! (i___3 < (m___0->xxh)->ins)) {
#line 191
      goto while_break___11;
    }
    {
#line 192
    read_object_header(f, & oh);
#line 194
    copy_adjust((m___0->xxih + i___3)->name, (uint8 *)(& oh.name), 32);
    }
#line 196
    if ((int )oh.headerSize == 0) {
#line 197
      if (m___0->verbosity > 1) {
        {
#line 197
        tmp___13 = strlen((char const   *)((char *)((m___0->xxih + i___3)->name)));
        }
#line 197
        if (tmp___13) {
          {
#line 198
          report((char *)"[%2X] %-26.26s %2d ", i___3, (m___0->xxih + i___3)->name,
                 (m___0->xxih + i___3)->nsm);
          }
        }
      }
#line 201
      ri.nsample = (BYTE )0;
#line 202
      if (m___0->verbosity > 1) {
        {
#line 202
        tmp___14 = strlen((char const   *)((char *)((m___0->xxih + i___3)->name)));
        }
#line 202
        if (tmp___14) {
          {
#line 203
          report((char *)"\n");
          }
        } else
#line 202
        if ((m___0->xxih + i___3)->nsm) {
          {
#line 203
          report((char *)"\n");
          }
        }
      }
#line 204
      goto __Cont;
    }
    {
#line 207
    ri.nsample = read8(f);
#line 208
    ri.flags = read16l(f);
#line 209
    fread((void */* __restrict  */)(& ri.table), (size_t )120, (size_t )1, (FILE */* __restrict  */)f);
#line 211
    ri.volumeEnv.npoint = read8(f);
#line 212
    j = 0;
    }
    {
#line 212
    while (1) {
      while_continue___12: /* CIL Label */ ;
#line 212
      if (! (j < 12)) {
#line 212
        goto while_break___12;
      }
      {
#line 213
      tmp___15 = read32l(f);
#line 213
      ri.volumeEnv.point[j].x = (long )tmp___15;
#line 214
      tmp___16 = read32l(f);
#line 214
      ri.volumeEnv.point[j].y = (long )tmp___16;
#line 212
      j ++;
      }
    }
    while_break___12: /* CIL Label */ ;
    }
    {
#line 216
    ri.volumeEnv.sustain = read8(f);
#line 217
    ri.volumeEnv.loopstart = read8(f);
#line 218
    ri.volumeEnv.loopend = read8(f);
#line 219
    ri.volumeEnv.flags = read16l(f);
#line 221
    ri.panningEnv.npoint = read8(f);
#line 222
    j = 0;
    }
    {
#line 222
    while (1) {
      while_continue___13: /* CIL Label */ ;
#line 222
      if (! (j < 12)) {
#line 222
        goto while_break___13;
      }
      {
#line 223
      tmp___17 = read32l(f);
#line 223
      ri.panningEnv.point[j].x = (long )tmp___17;
#line 224
      tmp___18 = read32l(f);
#line 224
      ri.panningEnv.point[j].y = (long )tmp___18;
#line 222
      j ++;
      }
    }
    while_break___13: /* CIL Label */ ;
    }
    {
#line 226
    ri.panningEnv.sustain = read8(f);
#line 227
    ri.panningEnv.loopstart = read8(f);
#line 228
    ri.panningEnv.loopend = read8(f);
#line 229
    ri.panningEnv.flags = read16l(f);
#line 231
    tmp___19 = read8(f);
#line 231
    ri.vibflg = (char )tmp___19;
#line 232
    tmp___20 = read8(f);
#line 232
    ri.vibsweep = (char )tmp___20;
#line 233
    tmp___21 = read8(f);
#line 233
    ri.vibdepth = (char )tmp___21;
#line 234
    tmp___22 = read8(f);
#line 234
    ri.vibrate = (char )tmp___22;
#line 235
    ri.volfade = read16l(f);
#line 243
    (m___0->xxih + i___3)->nsm = (int )ri.nsample;
    }
#line 244
    if (m___0->verbosity > 1) {
      {
#line 244
      tmp___23 = strlen((char const   *)((char *)((m___0->xxih + i___3)->name)));
      }
#line 244
      if (tmp___23) {
        {
#line 245
        report((char *)"[%2X] %-26.26s %2d ", i___3, (m___0->xxih + i___3)->name,
               (m___0->xxih + i___3)->nsm);
        }
      } else
#line 244
      if (ri.nsample) {
        {
#line 245
        report((char *)"[%2X] %-26.26s %2d ", i___3, (m___0->xxih + i___3)->name,
               (m___0->xxih + i___3)->nsm);
        }
      }
    }
#line 248
    if ((m___0->xxih + i___3)->nsm > 16) {
#line 249
      (m___0->xxih + i___3)->nsm = 16;
    }
    {
#line 250
    tmp___24 = calloc((size_t )sizeof(struct xxm_instrument ), (size_t )(m___0->xxih + i___3)->nsm);
#line 250
    *(m___0->xxi + i___3) = (struct xxm_instrument *)tmp___24;
#line 252
    j = 0;
    }
    {
#line 252
    while (1) {
      while_continue___14: /* CIL Label */ ;
#line 252
      if (! (j < 108)) {
#line 252
        goto while_break___14;
      }
#line 253
      (m___0->xxim)->ins[j] = ri.table[j + 12];
#line 252
      j ++;
    }
    while_break___14: /* CIL Label */ ;
    }
#line 256
    (m___0->xxih + i___3)->rls = (int )ri.volfade;
#line 257
    (m___0->xxih + i___3)->aei.npt = (int )ri.volumeEnv.npoint;
#line 258
    (m___0->xxih + i___3)->aei.sus = (int )ri.volumeEnv.sustain;
#line 259
    (m___0->xxih + i___3)->aei.lps = (int )ri.volumeEnv.loopstart;
#line 260
    (m___0->xxih + i___3)->aei.lpe = (int )ri.volumeEnv.loopend;
#line 261
    (m___0->xxih + i___3)->aei.flg = (int )ri.volumeEnv.flags;
#line 262
    (m___0->xxih + i___3)->pei.npt = (int )ri.panningEnv.npoint;
#line 263
    (m___0->xxih + i___3)->pei.sus = (int )ri.panningEnv.sustain;
#line 264
    (m___0->xxih + i___3)->pei.lps = (int )ri.panningEnv.loopstart;
#line 265
    (m___0->xxih + i___3)->pei.lpe = (int )ri.panningEnv.loopend;
#line 266
    (m___0->xxih + i___3)->pei.flg = (int )ri.panningEnv.flags;
#line 267
    if ((m___0->xxih + i___3)->aei.npt) {
      {
#line 268
      tmp___25 = calloc((size_t )4, (size_t )(m___0->xxih + i___3)->aei.npt);
#line 268
      *(m___0->xxae + i___3) = (uint16 *)tmp___25;
      }
    } else {
#line 270
      (m___0->xxih + i___3)->aei.flg &= -2;
    }
#line 271
    if ((m___0->xxih + i___3)->pei.npt) {
      {
#line 272
      tmp___26 = calloc((size_t )4, (size_t )(m___0->xxih + i___3)->pei.npt);
#line 272
      *(m___0->xxpe + i___3) = (uint16 *)tmp___26;
      }
    } else {
#line 274
      (m___0->xxih + i___3)->pei.flg &= -2;
    }
#line 276
    j = 0;
    {
#line 276
    while (1) {
      while_continue___15: /* CIL Label */ ;
#line 276
      if (! (j < (m___0->xxih + i___3)->aei.npt)) {
#line 276
        goto while_break___15;
      }
#line 277
      *(*(m___0->xxae + i___3) + j * 2) = (uint16 )ri.volumeEnv.point[j].x;
#line 278
      *(*(m___0->xxae + i___3) + (j * 2 + 1)) = (uint16 )(ri.volumeEnv.point[j].y / 2L);
#line 276
      j ++;
    }
    while_break___15: /* CIL Label */ ;
    }
#line 280
    j = 0;
    {
#line 280
    while (1) {
      while_continue___16: /* CIL Label */ ;
#line 280
      if (! (j < (m___0->xxih + i___3)->pei.npt)) {
#line 280
        goto while_break___16;
      }
#line 281
      *(*(m___0->xxpe + i___3) + j * 2) = (uint16 )ri.panningEnv.point[j].x;
#line 282
      *(*(m___0->xxpe + i___3) + (j * 2 + 1)) = (uint16 )(32L + ri.panningEnv.point[j].y / 2L);
#line 280
      j ++;
    }
    while_break___16: /* CIL Label */ ;
    }
#line 286
    j = 0;
    {
#line 286
    while (1) {
      while_continue___17: /* CIL Label */ ;
#line 286
      if (! (j < (m___0->xxih + i___3)->nsm)) {
#line 286
        goto while_break___17;
      }
      {
#line 287
      read_object_header(f, & oh);
#line 289
      rs.flags = read16l(f);
#line 290
      rs.basevolume = read8(f);
#line 291
      rs.defaultvolume = read8(f);
#line 292
      rs.length = read32l(f);
#line 293
      tmp___27 = read32l(f);
#line 293
      rs.loop = (long )tmp___27;
#line 294
      rs.loopbegin = read32l(f);
#line 295
      rs.loopend = read32l(f);
#line 296
      rs.basefreq = read32l(f);
#line 297
      rs.basenote = read8(f);
#line 298
      tmp___28 = read8(f);
#line 298
      rs.panning = (char )tmp___28;
#line 300
      c2spd_to_note((int )rs.basefreq, & (*(m___0->xxi + i___3) + 0)->xpo, & (*(m___0->xxi + i___3) + 0)->fin);
#line 302
      (*(m___0->xxi + i___3) + j)->xpo += 48 - (int )rs.basenote;
#line 304
      (*(m___0->xxi + i___3) + j)->vol = ((int )rs.defaultvolume * (int )rs.basevolume) / 64;
#line 305
      (*(m___0->xxi + i___3) + j)->pan = 128 + (int )rs.panning * 2;
#line 306
      (*(m___0->xxi + i___3) + j)->vwf = (int )ri.vibflg;
#line 307
      (*(m___0->xxi + i___3) + j)->vde = (int )ri.vibdepth;
#line 308
      (*(m___0->xxi + i___3) + j)->vra = (int )ri.vibrate;
#line 309
      (*(m___0->xxi + i___3) + j)->vsw = (int )ri.vibsweep;
#line 310
      (*(m___0->xxi + i___3) + j)->sid = smpnum;
      }
#line 312
      if (smpnum >= 1024) {
        {
#line 313
        fseek(f, (long )rs.length, 1);
        }
#line 314
        goto __Cont___0;
      }
      {
#line 317
      copy_adjust((m___0->xxs + smpnum)->name, (uint8 *)(oh.name), 32);
#line 319
      (m___0->xxs + smpnum)->len = (int )rs.length;
#line 320
      (m___0->xxs + smpnum)->lps = (int )rs.loopbegin;
#line 321
      (m___0->xxs + smpnum)->lpe = (int )rs.loopend;
      }
#line 322
      if ((int )rs.flags & 2) {
#line 322
        (m___0->xxs + smpnum)->flg = 1;
      } else {
#line 322
        (m___0->xxs + smpnum)->flg = 0;
      }
#line 323
      if (rs.loop & 3L) {
#line 323
        tmp___29 = 4;
      } else {
#line 323
        tmp___29 = 0;
      }
#line 323
      (m___0->xxs + smpnum)->flg |= tmp___29;
#line 324
      if (rs.loop == 2L) {
#line 324
        tmp___30 = 8;
      } else {
#line 324
        tmp___30 = 0;
      }
#line 324
      (m___0->xxs + smpnum)->flg |= tmp___30;
#line 326
      if (m___0->verbosity > 1) {
#line 326
        if (rs.length) {
#line 327
          if ((m___0->xxs + (*(m___0->xxi + i___3) + j)->sid)->flg & 8) {
#line 327
            tmp___32 = 'B';
          } else {
#line 327
            if ((m___0->xxs + (*(m___0->xxi + i___3) + j)->sid)->flg & 4) {
#line 327
              tmp___31 = 'L';
            } else {
#line 327
              tmp___31 = ' ';
            }
#line 327
            tmp___32 = tmp___31;
          }
#line 327
          if ((m___0->xxs + (*(m___0->xxi + i___3) + j)->sid)->flg & 1) {
#line 327
            tmp___33 = '+';
          } else {
#line 327
            tmp___33 = ' ';
          }
#line 327
          if (j) {
#line 327
            tmp___34 = "\n\t\t\t\t    ";
          } else {
#line 327
            tmp___34 = " ";
          }
          {
#line 327
          report((char *)"%s[%1x] %05x%c%05x %05x %c V%02x F%+04d P%02x R%+03d", tmp___34,
                 j, (m___0->xxs + (*(m___0->xxi + i___3) + j)->sid)->len, tmp___33,
                 (m___0->xxs + (*(m___0->xxi + i___3) + j)->sid)->lps, (m___0->xxs + (*(m___0->xxi + i___3) + j)->sid)->lpe,
                 tmp___32, (*(m___0->xxi + i___3) + j)->vol, (*(m___0->xxi + i___3) + j)->fin,
                 (*(m___0->xxi + i___3) + j)->pan, (*(m___0->xxi + i___3) + j)->xpo);
          }
        }
      }
      {
#line 341
      xmp_drv_loadpatch(ctx___0, f, (*(m___0->xxi + i___3) + j)->sid, m___0->c4rate,
                        1, m___0->xxs + (*(m___0->xxi + i___3) + j)->sid, (char *)((void *)0));
      }
      __Cont___0: /* CIL Label */ 
#line 286
      j ++;
#line 286
      smpnum ++;
    }
    while_break___17: /* CIL Label */ ;
    }
#line 344
    if (m___0->verbosity == 1) {
      {
#line 345
      report((char *)".");
      }
    }
#line 347
    if (m___0->verbosity > 1) {
      {
#line 347
      tmp___35 = strlen((char const   *)((char *)((m___0->xxih + i___3)->name)));
      }
#line 347
      if (tmp___35) {
        {
#line 348
        report((char *)"\n");
        }
      } else
#line 347
      if (ri.nsample) {
        {
#line 348
        report((char *)"\n");
        }
      }
    }
    __Cont: /* CIL Label */ 
#line 191
    i___3 ++;
  }
  while_break___11: /* CIL Label */ ;
  }
#line 350
  if (m___0->verbosity == 1) {
    {
#line 351
    report((char *)"\n");
    }
  }
  {
#line 353
  (m___0->xxh)->smp = smpnum;
#line 354
  tmp___36 = realloc((void *)m___0->xxs, (size_t )(sizeof(struct xxm_sample ) * (unsigned long )(m___0->xxh)->smp));
#line 354
  m___0->xxs = (struct xxm_sample *)tmp___36;
#line 356
  m___0->quirk |= ((1 << 8) | (1 << 7)) | (1 << 9);
  }
#line 358
  return (0);
}
}
#line 17 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/mmd3_load.c"
static int mmd3_test(FILE *f , char *t , int const   start ) ;
#line 18
static int mmd3_load(struct xmp_context *ctx___0 , FILE *f , int const   start ) ;
#line 20 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/mmd3_load.c"
struct xmp_loader_info mmd3_loader  =    {(char *)"MMD2/3", (char *)"OctaMED v5/OctaMED SS", & mmd3_test, & mmd3_load, 0,
    {(struct list_head *)0, (struct list_head *)0}};
#line 27 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/mmd3_load.c"
static int mmd3_test(FILE *f , char *t , int const   start ) 
{ 
  char id[4] ;
  uint32 offset ;
  uint32 len ;
  int tmp ;
  int tmp___0 ;
  void *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
  {
#line 32
  fread((void */* __restrict  */)(id), (size_t )4, (size_t )1, (FILE */* __restrict  */)f);
#line 34
  tmp = memcmp((void const   *)(id), (void const   *)"MMD2", (size_t )4);
  }
#line 34
  if (tmp) {
    {
#line 34
    tmp___0 = memcmp((void const   *)(id), (void const   *)"MMD3", (size_t )4);
    }
#line 34
    if (tmp___0) {
#line 35
      return (-1);
    }
  }
  {
#line 37
  fseek(f, 28L, 1);
#line 38
  offset = read32b(f);
  }
#line 40
  if (offset) {
    {
#line 41
    fseek(f, (long )(((uint32 )start + offset) + 44U), 0);
#line 42
    offset = read32b(f);
#line 43
    len = read32b(f);
#line 44
    fseek(f, (long )((uint32 )start + offset), 0);
#line 45
    read_title(f, t, (int )len);
    }
  } else {
    {
#line 47
    read_title(f, t, 0);
    }
  }
#line 50
  return (0);
}
}
#line 55 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/mmd3_load.c"
static char *inst_type[10]  = 
#line 55
  {      (char *)"HYB",      (char *)"SYN",      (char *)"SMP",      (char *)"I5O", 
        (char *)"I3O",      (char *)"I2O",      (char *)"I4O",      (char *)"I6O", 
        (char *)"I7O",      (char *)"EXT"};
#line 68 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/mmd3_load.c"
static int bpm_on  ;
#line 68 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/mmd3_load.c"
static int bpmlen  ;
#line 70 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/mmd3_load.c"
static void xlat_fx(struct xxm_event *event ) 
{ 
  uint8 tmp ;
  uint8 tmp___0 ;
  uint8 tmp___1 ;

  {
#line 72
  if ((int )event->fxt > 15) {
#line 73
    tmp = (uint8 )0;
#line 73
    event->fxp = tmp;
#line 73
    event->fxt = tmp;
#line 74
    return;
  }
  {
#line 78
  if ((int )event->fxt == 5) {
#line 78
    goto case_5;
  }
#line 82
  if ((int )event->fxt == 7) {
#line 82
    goto case_7;
  }
#line 82
  if ((int )event->fxt == 6) {
#line 82
    goto case_7;
  }
#line 84
  if ((int )event->fxt == 8) {
#line 84
    goto case_8;
  }
#line 86
  if ((int )event->fxt == 9) {
#line 86
    goto case_9;
  }
#line 89
  if ((int )event->fxt == 13) {
#line 89
    goto case_13;
  }
#line 92
  if ((int )event->fxt == 14) {
#line 92
    goto case_14;
  }
#line 94
  if ((int )event->fxt == 15) {
#line 94
    goto case_15;
  }
#line 77
  goto switch_break;
  case_5: /* CIL Label */ 
#line 79
  event->fxp = (uint8 )((((int )event->fxp & 15) << 4) | (((int )event->fxp & 240) >> 4));
#line 80
  goto switch_break;
  case_7: /* CIL Label */ 
  case_6: /* CIL Label */ 
#line 83
  goto switch_break;
  case_8: /* CIL Label */ 
#line 85
  goto switch_break;
  case_9: /* CIL Label */ 
#line 87
  event->fxt = (uint8 )15;
#line 88
  goto switch_break;
  case_13: /* CIL Label */ 
#line 90
  event->fxt = (uint8 )10;
#line 91
  goto switch_break;
  case_14: /* CIL Label */ 
#line 93
  goto switch_break;
  case_15: /* CIL Label */ 
#line 95
  if ((int )event->fxp == 0) {
#line 96
    event->fxt = (uint8 )13;
#line 97
    goto switch_break;
  } else
#line 98
  if ((int )event->fxp <= 10) {
#line 99
    goto switch_break;
  } else
#line 100
  if ((int )event->fxp <= 240) {
#line 101
    event->fxt = (uint8 )171;
#line 102
    if (bpm_on) {
#line 103
      event->fxp = (uint8 )(((int )event->fxp * 8) / bpmlen);
    }
#line 104
    goto switch_break;
  } else {
    {
#line 106
    if ((int )event->fxp == 241) {
#line 106
      goto case_241;
    }
#line 110
    if ((int )event->fxp == 242) {
#line 110
      goto case_242;
    }
#line 114
    if ((int )event->fxp == 243) {
#line 114
      goto case_243;
    }
#line 123
    if ((int )event->fxp == 254) {
#line 123
      goto case_254;
    }
#line 123
    if ((int )event->fxp == 253) {
#line 123
      goto case_254;
    }
#line 123
    if ((int )event->fxp == 251) {
#line 123
      goto case_254;
    }
#line 123
    if ((int )event->fxp == 250) {
#line 123
      goto case_254;
    }
#line 123
    if ((int )event->fxp == 249) {
#line 123
      goto case_254;
    }
#line 123
    if ((int )event->fxp == 248) {
#line 123
      goto case_254;
    }
#line 126
    if ((int )event->fxp == 255) {
#line 126
      goto case_255;
    }
#line 130
    goto switch_default;
    case_241: /* CIL Label */ 
#line 107
    event->fxt = (uint8 )14;
#line 108
    event->fxp = (uint8 )((9 << 4) | 3);
#line 109
    goto switch_break___0;
    case_242: /* CIL Label */ 
#line 111
    event->fxt = (uint8 )14;
#line 112
    event->fxp = (uint8 )((13 << 4) | 3);
#line 113
    goto switch_break___0;
    case_243: /* CIL Label */ 
#line 115
    event->fxt = (uint8 )14;
#line 116
    event->fxp = (uint8 )((9 << 4) | 2);
#line 117
    goto switch_break___0;
    case_254: /* CIL Label */ 
    case_253: /* CIL Label */ 
    case_251: /* CIL Label */ 
    case_250: /* CIL Label */ 
    case_249: /* CIL Label */ 
    case_248: /* CIL Label */ 
#line 124
    tmp___0 = (uint8 )0;
#line 124
    event->fxp = tmp___0;
#line 124
    event->fxt = tmp___0;
#line 125
    goto switch_break___0;
    case_255: /* CIL Label */ 
#line 127
    event->fxt = (uint8 )14;
#line 128
    event->fxp = (uint8 )((12 << 4) | 3);
#line 129
    goto switch_break___0;
    switch_default: /* CIL Label */ 
#line 131
    tmp___1 = (uint8 )0;
#line 131
    event->fxp = tmp___1;
#line 131
    event->fxt = tmp___1;
    switch_break___0: /* CIL Label */ ;
    }
  }
#line 133
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 135
  return;
}
}
#line 137 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/mmd3_load.c"
static int mmd3_load(struct xmp_context *ctx___0 , FILE *f , int const   start ) 
{ 
  struct xmp_player_context *p ;
  struct xmp_mod_context *m___0 ;
  int i___3 ;
  int j ;
  int k ;
  struct MMD0 header ;
  struct MMD2song song ;
  struct MMD1Block block ;
  struct InstrHdr instr ;
  struct SynthInstr synth ;
  struct InstrExt exp_smp ;
  struct MMD0exp expdata ;
  struct xxm_event *event ;
  int ver___0 ;
  int smp_idx ;
  uint8 e[4] ;
  int song_offset ;
  int seqtable_offset ;
  int trackvols_offset ;
  int trackpans_offset ;
  int blockarr_offset ;
  int smplarr_offset ;
  int expdata_offset ;
  int expsmp_offset ;
  int songname_offset ;
  int iinfo_offset ;
  int playseq_offset ;
  int pos___0 ;
  uint8 **tmp ;
  uint32 tmp___0 ;
  uint32 tmp___1 ;
  uint32 tmp___2 ;
  uint32 tmp___3 ;
  uint16 tmp___4 ;
  uint32 tmp___5 ;
  uint32 tmp___6 ;
  uint32 tmp___7 ;
  uint8 tmp___8 ;
  uint8 tmp___9 ;
  uint32 tmp___10 ;
  uint16 tmp___11 ;
  uint16 tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  uint32 smpl_offset ;
  int16 type ;
  uint16 tmp___15 ;
  uint16 tmp___16 ;
  uint32 tmp___17 ;
  uint32 tmp___18 ;
  uint32 tmp___19 ;
  uint8 tmp___20 ;
  int block_offset ;
  uint32 tmp___21 ;
  char const   *tmp___22 ;
  void *tmp___23 ;
  void *tmp___24 ;
  int block_offset___0 ;
  uint32 tmp___25 ;
  void *tmp___26 ;
  int j___0 ;
  void *tmp___27 ;
  void *tmp___28 ;
  void *tmp___29 ;
  void *tmp___30 ;
  void *tmp___31 ;
  void *tmp___32 ;
  void *tmp___33 ;
  void *tmp___34 ;
  void *tmp___35 ;
  void *tmp___36 ;
  int smpl_offset___0 ;
  uint32 tmp___37 ;
  uint16 tmp___38 ;
  long tmp___39 ;
  int t ;
  char name[40] ;
  unsigned int tmp___40 ;
  char const   *tmp___41 ;
  uint8 tmp___42 ;
  int length ;
  int type___0 ;
  int pos___1 ;
  long tmp___43 ;
  uint32 tmp___44 ;
  uint32 tmp___45 ;
  uint16 tmp___46 ;
  void *tmp___47 ;
  void *tmp___48 ;
  void *tmp___49 ;
  int pos___2 ;
  long tmp___50 ;
  void *tmp___51 ;
  uint16 tmp___52 ;
  void *tmp___53 ;
  void *tmp___54 ;
  void *tmp___55 ;
  int tmp___56 ;
  uint8 tmp___57 ;
  int p___0 ;
  int8 tmp___58 ;
  int tmp___59 ;
  void *__cil_tmp106 ;
  void *__cil_tmp107 ;
  void *__cil_tmp108 ;
  void *__cil_tmp109 ;
  int __cil_tmp110 ;
  void *__cil_tmp111 ;
  void *__cil_tmp112 ;
  void *__cil_tmp113 ;
  void *__cil_tmp114 ;
  void *__cil_tmp115 ;
  void *__cil_tmp116 ;
  void *__cil_tmp117 ;
  void *__cil_tmp118 ;
  void *__cil_tmp119 ;
  void *__cil_tmp120 ;
  void *__cil_tmp121 ;
  void *__cil_tmp122 ;
  void *__cil_tmp123 ;
  void *__cil_tmp124 ;
  void *__cil_tmp125 ;
  void *__cil_tmp126 ;
  char *__cil_tmp127 ;
  char *__cil_tmp128 ;
  char *__cil_tmp129 ;
  char *__cil_tmp130 ;
  char *__cil_tmp131 ;
  char *__cil_tmp132 ;
  char *__cil_tmp133 ;
  char *__cil_tmp134 ;
  char *__cil_tmp135 ;
  char *__cil_tmp136 ;
  char *__cil_tmp137 ;
  char *__cil_tmp138 ;
  char *__cil_tmp139 ;
  char *__cil_tmp140 ;
  char *__cil_tmp141 ;
  char *__cil_tmp142 ;
  char *__cil_tmp143 ;
  char *__cil_tmp144 ;
  char *__cil_tmp145 ;
  char *__cil_tmp146 ;
  char *__cil_tmp147 ;
  char *__cil_tmp148 ;
  char *__cil_tmp149 ;
  char *__cil_tmp150 ;
  char *__cil_tmp151 ;
  char *__cil_tmp152 ;

  {
#line 139
  p = & ctx___0->p;
#line 140
  m___0 = & p->m;
#line 150
  ver___0 = 0;
#line 151
  smp_idx = 0;
  {
#line 166
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 166
    fseek(f, (long )start, 0);
#line 166
    tmp = (uint8 **)((void *)0);
#line 166
    m___0->med_wav_table = tmp;
#line 166
    m___0->med_vol_table = tmp;
#line 166
    set_xxh_defaults(m___0->xxh);
    }
#line 166
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 168
  fread((void */* __restrict  */)(& header.id), (size_t )4, (size_t )1, (FILE */* __restrict  */)f);
#line 170
  ver___0 = ((int )*((char *)(& header.id) + 3) - 49) + 1;
  }
  {
#line 172
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 172
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 173
  header.modlen = read32b(f);
#line 174
  tmp___0 = read32b(f);
#line 174
  song_offset = (int )tmp___0;
  }
  {
#line 175
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 175
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 176
  read16b(f);
#line 177
  read16b(f);
#line 178
  tmp___1 = read32b(f);
#line 178
  blockarr_offset = (int )tmp___1;
  }
  {
#line 179
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 179
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 180
  read32b(f);
#line 181
  tmp___2 = read32b(f);
#line 181
  smplarr_offset = (int )tmp___2;
  }
  {
#line 182
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 182
    goto while_break___3;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 183
  read32b(f);
#line 184
  tmp___3 = read32b(f);
#line 184
  expdata_offset = (int )tmp___3;
  }
  {
#line 185
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 185
    goto while_break___4;
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 186
  read32b(f);
#line 187
  header.pstate = read16b(f);
#line 188
  header.pblock = read16b(f);
#line 189
  header.pline = read16b(f);
#line 190
  header.pseqnum = read16b(f);
#line 191
  tmp___4 = read16b(f);
#line 191
  header.actplayline = (WORD___0 )tmp___4;
#line 192
  header.counter = read8(f);
#line 193
  header.extra_songs = read8(f);
  }
  {
#line 198
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 198
    goto while_break___5;
  }
  while_break___5: /* CIL Label */ ;
  }
  {
#line 199
  fseek(f, (long )(start + (int const   )song_offset), 0);
#line 200
  i___3 = 0;
  }
  {
#line 200
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 200
    if (! (i___3 < 63)) {
#line 200
      goto while_break___6;
    }
    {
#line 201
    song.sample[i___3].rep = read16b(f);
#line 202
    song.sample[i___3].replen = read16b(f);
#line 203
    song.sample[i___3].midich = read8(f);
#line 204
    song.sample[i___3].midipreset = read8(f);
#line 205
    song.sample[i___3].svol = read8(f);
#line 206
    song.sample[i___3].strans = read8s(f);
#line 200
    i___3 ++;
    }
  }
  while_break___6: /* CIL Label */ ;
  }
  {
#line 208
  song.numblocks = read16b(f);
#line 209
  song.songlen = read16b(f);
  }
  {
#line 210
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 210
    goto while_break___7;
  }
  while_break___7: /* CIL Label */ ;
  }
  {
#line 211
  tmp___5 = read32b(f);
#line 211
  seqtable_offset = (int )tmp___5;
#line 212
  read32b(f);
#line 213
  tmp___6 = read32b(f);
#line 213
  trackvols_offset = (int )tmp___6;
#line 214
  song.numtracks = read16b(f);
#line 215
  song.numpseqs = read16b(f);
#line 216
  tmp___7 = read32b(f);
#line 216
  trackpans_offset = (int )tmp___7;
#line 217
  song.flags3 = read32b(f);
#line 218
  song.voladj = read16b(f);
#line 219
  song.channels = read16b(f);
#line 220
  song.mix_echotype = read8(f);
#line 221
  song.mix_echodepth = read8(f);
#line 222
  song.mix_echolen = read16b(f);
#line 223
  tmp___8 = read8(f);
#line 223
  song.mix_stereosep = (BYTE___0 )tmp___8;
#line 225
  fseek(f, 223L, 1);
#line 227
  song.deftempo = read16b(f);
#line 228
  tmp___9 = read8(f);
#line 228
  song.playtransp = (BYTE___0 )tmp___9;
#line 229
  song.flags = read8(f);
#line 230
  song.flags2 = read8(f);
#line 231
  song.tempo2 = read8(f);
#line 232
  i___3 = 0;
  }
  {
#line 232
  while (1) {
    while_continue___8: /* CIL Label */ ;
#line 232
    if (! (i___3 < 16)) {
#line 232
      goto while_break___8;
    }
    {
#line 233
    read8(f);
#line 232
    i___3 ++;
    }
  }
  while_break___8: /* CIL Label */ ;
  }
  {
#line 234
  song.mastervol = read8(f);
#line 235
  song.numsamples = read8(f);
#line 240
  fseek(f, (long )(start + (int const   )seqtable_offset), 0);
#line 241
  tmp___10 = read32b(f);
#line 241
  playseq_offset = (int )tmp___10;
#line 242
  fseek(f, (long )(start + (int const   )playseq_offset), 0);
#line 243
  fseek(f, 32L, 1);
#line 244
  read32b(f);
#line 245
  read32b(f);
#line 246
  tmp___11 = read16b(f);
#line 246
  (m___0->xxh)->len = (int )tmp___11;
#line 247
  i___3 = 0;
  }
  {
#line 247
  while (1) {
    while_continue___9: /* CIL Label */ ;
#line 247
    if (! (i___3 < (m___0->xxh)->len)) {
#line 247
      goto while_break___9;
    }
    {
#line 248
    tmp___12 = read16b(f);
#line 248
    m___0->xxo[i___3] = (uint8 )tmp___12;
#line 247
    i___3 ++;
    }
  }
  while_break___9: /* CIL Label */ ;
  }
#line 253
  m___0->c4rate = 8363;
#line 254
  if ((int )song.flags & 32) {
#line 254
    tmp___13 = 0;
  } else {
#line 254
    tmp___13 = 1 << 13;
  }
#line 254
  m___0->quirk |= tmp___13;
#line 255
  bpm_on = (int )song.flags2 & 32;
#line 256
  bpmlen = 1 + ((int )song.flags2 & 31);
#line 257
  if (bpm_on) {
#line 257
    tmp___14 = 0;
  } else {
#line 257
    tmp___14 = 1;
  }
#line 257
  m___0->quirk |= tmp___14;
#line 270
  if (! bpm_on) {
#line 270
    if ((int )song.deftempo < 10) {
#line 271
      song.deftempo = (UWORD )(53 - (int )song.deftempo * 2);
    }
  }
#line 274
  if (bpm_on) {
#line 275
    (m___0->xxh)->tpo = 3;
#line 276
    (m___0->xxh)->bpm = ((int )song.deftempo * 8) / bpmlen;
  } else {
#line 278
    (m___0->xxh)->tpo = (int )song.tempo2;
#line 279
    (m___0->xxh)->bpm = (int )song.deftempo;
#line 281
    if ((m___0->xxh)->bpm <= 10) {
#line 282
      (m___0->xxh)->bpm = ((m___0->xxh)->bpm * 33) / 6;
    }
  }
#line 285
  (m___0->xxh)->pat = (int )song.numblocks;
#line 286
  (m___0->xxh)->ins = (int )song.numsamples;
#line 288
  (m___0->xxh)->rst = 0;
#line 289
  (m___0->xxh)->chn = 0;
#line 290
  m___0->name[0] = (char)0;
#line 295
  (m___0->xxh)->smp = 0;
#line 296
  i___3 = 0;
  {
#line 296
  while (1) {
    while_continue___10: /* CIL Label */ ;
#line 296
    if (! (i___3 < (m___0->xxh)->ins)) {
#line 296
      goto while_break___10;
    }
    {
#line 299
    fseek(f, (long )((start + (int const   )smplarr_offset) + (int const   )(i___3 * 4)),
          0);
#line 300
    smpl_offset = read32b(f);
    }
#line 301
    if (smpl_offset == 0U) {
#line 302
      goto __Cont;
    }
    {
#line 303
    fseek(f, (long )((uint32 )start + smpl_offset), 0);
#line 304
    read32b(f);
#line 305
    tmp___15 = read16b(f);
#line 305
    type = (int16 )tmp___15;
    }
#line 306
    if ((int )type == -1) {
      {
#line 307
      fseek(f, 14L, 1);
#line 308
      tmp___16 = read16b(f);
#line 308
      (m___0->xxh)->smp += (int )tmp___16;
      }
    } else {
#line 310
      ((m___0->xxh)->smp) ++;
    }
    __Cont: /* CIL Label */ 
#line 296
    i___3 ++;
  }
  while_break___10: /* CIL Label */ ;
  }
  {
#line 317
  while (1) {
    while_continue___11: /* CIL Label */ ;
#line 317
    goto while_break___11;
  }
  while_break___11: /* CIL Label */ ;
  }
#line 318
  expdata.s_ext_entries = (UWORD )0;
#line 319
  expdata.s_ext_entrsz = (UWORD )0;
#line 320
  expdata.i_ext_entries = (UWORD )0;
#line 321
  expdata.i_ext_entrsz = (UWORD )0;
#line 322
  expsmp_offset = 0;
#line 323
  iinfo_offset = 0;
#line 324
  if (expdata_offset) {
    {
#line 325
    fseek(f, (long )(start + (int const   )expdata_offset), 0);
#line 326
    read32b(f);
#line 327
    tmp___17 = read32b(f);
#line 327
    expsmp_offset = (int )tmp___17;
    }
    {
#line 328
    while (1) {
      while_continue___12: /* CIL Label */ ;
#line 328
      goto while_break___12;
    }
    while_break___12: /* CIL Label */ ;
    }
    {
#line 329
    expdata.s_ext_entries = read16b(f);
#line 330
    expdata.s_ext_entrsz = read16b(f);
#line 331
    read32b(f);
#line 332
    read32b(f);
#line 333
    tmp___18 = read32b(f);
#line 333
    iinfo_offset = (int )tmp___18;
    }
    {
#line 334
    while (1) {
      while_continue___13: /* CIL Label */ ;
#line 334
      goto while_break___13;
    }
    while_break___13: /* CIL Label */ ;
    }
    {
#line 335
    expdata.i_ext_entries = read16b(f);
#line 336
    expdata.i_ext_entrsz = read16b(f);
#line 337
    read32b(f);
#line 338
    read32b(f);
#line 339
    read32b(f);
#line 340
    read32b(f);
#line 341
    tmp___19 = read32b(f);
#line 341
    songname_offset = (int )tmp___19;
    }
    {
#line 342
    while (1) {
      while_continue___14: /* CIL Label */ ;
#line 342
      goto while_break___14;
    }
    while_break___14: /* CIL Label */ ;
    }
    {
#line 343
    expdata.songnamelen = read32b(f);
#line 344
    fseek(f, (long )(start + (int const   )songname_offset), 0);
    }
    {
#line 345
    while (1) {
      while_continue___15: /* CIL Label */ ;
#line 345
      goto while_break___15;
    }
    while_break___15: /* CIL Label */ ;
    }
#line 346
    i___3 = 0;
    {
#line 346
    while (1) {
      while_continue___16: /* CIL Label */ ;
#line 346
      if (! ((ULONG )i___3 < expdata.songnamelen)) {
#line 346
        goto while_break___16;
      }
#line 347
      if (i___3 >= 64) {
#line 348
        goto while_break___16;
      }
      {
#line 349
      tmp___20 = read8(f);
#line 349
      m___0->name[i___3] = (char )tmp___20;
#line 346
      i___3 ++;
      }
    }
    while_break___16: /* CIL Label */ ;
    }
  }
  {
#line 356
  while (1) {
    while_continue___17: /* CIL Label */ ;
#line 356
    goto while_break___17;
  }
  while_break___17: /* CIL Label */ ;
  }
#line 358
  i___3 = 0;
  {
#line 358
  while (1) {
    while_continue___18: /* CIL Label */ ;
#line 358
    if (! (i___3 < (m___0->xxh)->pat)) {
#line 358
      goto while_break___18;
    }
    {
#line 361
    fseek(f, (long )((start + (int const   )blockarr_offset) + (int const   )(i___3 * 4)),
          0);
#line 362
    tmp___21 = read32b(f);
#line 362
    block_offset = (int )tmp___21;
    }
    {
#line 363
    while (1) {
      while_continue___19: /* CIL Label */ ;
#line 363
      goto while_break___19;
    }
    while_break___19: /* CIL Label */ ;
    }
#line 364
    if (block_offset == 0) {
#line 365
      goto __Cont___0;
    }
    {
#line 366
    fseek(f, (long )(start + (int const   )block_offset), 0);
#line 368
    block.numtracks = read16b(f);
#line 369
    block.lines = read16b(f);
    }
#line 371
    if ((int )block.numtracks > (m___0->xxh)->chn) {
#line 372
      (m___0->xxh)->chn = (int )block.numtracks;
    }
    __Cont___0: /* CIL Label */ 
#line 358
    i___3 ++;
  }
  while_break___18: /* CIL Label */ ;
  }
#line 375
  (m___0->xxh)->trk = (m___0->xxh)->pat * (m___0->xxh)->chn;
#line 377
  if (ver___0 == 2) {
    {
#line 378
    sprintf((char */* __restrict  */)(m___0->type), (char const   */* __restrict  */)"MMD%c (OctaMED v5)",
            48 + ver___0);
    }
  } else {
    {
#line 380
    sprintf((char */* __restrict  */)(m___0->type), (char const   */* __restrict  */)"MMD%c (OctaMED Soundstudio)",
            48 + ver___0);
    }
  }
  {
#line 382
  while (1) {
    while_continue___20: /* CIL Label */ ;
#line 382
    if (m___0->verbosity) {
#line 382
      if (m___0->name[0]) {
        {
#line 382
        report((char *)"Module title   : %s\n", m___0->name);
        }
      }
#line 382
      if (m___0->type[0]) {
        {
#line 382
        report((char *)"Module type    : %s\n", m___0->type);
        }
      }
#line 382
      if (m___0->author[0]) {
        {
#line 382
        report((char *)"Author name    : %s\n", m___0->author);
        }
      }
#line 382
      if ((m___0->xxh)->len) {
        {
#line 382
        report((char *)"Module length  : %d patterns\n", (m___0->xxh)->len);
        }
      }
    }
#line 382
    goto while_break___20;
  }
  while_break___20: /* CIL Label */ ;
  }
#line 384
  if (m___0->verbosity > 0) {
#line 385
    if (bpm_on) {
#line 385
      tmp___22 = "on";
    } else {
#line 385
      tmp___22 = "off";
    }
    {
#line 385
    report((char *)"BPM mode       : %s", tmp___22);
    }
#line 386
    if (bpm_on) {
      {
#line 387
      report((char *)" (length = %d)", bpmlen);
      }
    }
    {
#line 388
    report((char *)"\n");
    }
#line 389
    if (m___0->verbosity > 1) {
#line 389
      if (song.playtransp) {
        {
#line 390
        report((char *)"Song transpose : %d\n", (int )song.playtransp);
        }
      }
    }
    {
#line 391
    report((char *)"Stored patterns: %d ", (m___0->xxh)->pat);
    }
  }
  {
#line 397
  while (1) {
    while_continue___21: /* CIL Label */ ;
#line 397
    goto while_break___21;
  }
  while_break___21: /* CIL Label */ ;
  }
  {
#line 398
  while (1) {
    while_continue___22: /* CIL Label */ ;
    {
#line 398
    tmp___23 = calloc((size_t )sizeof(struct xxm_track *), (size_t )(m___0->xxh)->trk);
#line 398
    m___0->xxt = (struct xxm_track **)tmp___23;
#line 398
    tmp___24 = calloc((size_t )sizeof(struct xxm_pattern *), (size_t )((m___0->xxh)->pat + 1));
#line 398
    m___0->xxp = (struct xxm_pattern **)tmp___24;
    }
#line 398
    goto while_break___22;
  }
  while_break___22: /* CIL Label */ ;
  }
#line 400
  i___3 = 0;
  {
#line 400
  while (1) {
    while_continue___23: /* CIL Label */ ;
#line 400
    if (! (i___3 < (m___0->xxh)->pat)) {
#line 400
      goto while_break___23;
    }
    {
#line 403
    fseek(f, (long )((start + (int const   )blockarr_offset) + (int const   )(i___3 * 4)),
          0);
#line 404
    tmp___25 = read32b(f);
#line 404
    block_offset___0 = (int )tmp___25;
    }
#line 405
    if (block_offset___0 == 0) {
#line 406
      goto __Cont___1;
    }
    {
#line 407
    fseek(f, (long )(start + (int const   )block_offset___0), 0);
#line 409
    block.numtracks = read16b(f);
#line 410
    block.lines = read16b(f);
#line 411
    read32b(f);
    }
    {
#line 413
    while (1) {
      while_continue___24: /* CIL Label */ ;
      {
#line 413
      tmp___26 = calloc((size_t )1, (size_t )(sizeof(struct xxm_pattern ) + sizeof(struct xxm_trackinfo ) * (unsigned long )((m___0->xxh)->chn - 1)));
#line 413
      *(m___0->xxp + i___3) = (struct xxm_pattern *)tmp___26;
      }
#line 413
      goto while_break___24;
    }
    while_break___24: /* CIL Label */ ;
    }
#line 415
    (*(m___0->xxp + i___3))->rows = (int )block.lines + 1;
    {
#line 416
    while (1) {
      while_continue___25: /* CIL Label */ ;
#line 416
      j___0 = 0;
      {
#line 416
      while (1) {
        while_continue___26: /* CIL Label */ ;
#line 416
        if (! (j___0 < (m___0->xxh)->chn)) {
#line 416
          goto while_break___26;
        }
        {
#line 416
        (*(m___0->xxp + i___3))->info[j___0].index = i___3 * (m___0->xxh)->chn + j___0;
#line 416
        tmp___27 = calloc((size_t )(sizeof(struct xxm_track ) + sizeof(struct xxm_event ) * (unsigned long )(*(m___0->xxp + i___3))->rows),
                          (size_t )1);
#line 416
        *(m___0->xxt + (i___3 * (m___0->xxh)->chn + j___0)) = (struct xxm_track *)tmp___27;
#line 416
        (*(m___0->xxt + (i___3 * (m___0->xxh)->chn + j___0)))->rows = (*(m___0->xxp + i___3))->rows;
#line 416
        j___0 ++;
        }
      }
      while_break___26: /* CIL Label */ ;
      }
#line 416
      goto while_break___25;
    }
    while_break___25: /* CIL Label */ ;
    }
#line 418
    j = 0;
    {
#line 418
    while (1) {
      while_continue___27: /* CIL Label */ ;
#line 418
      if (! (j < (*(m___0->xxp + i___3))->rows)) {
#line 418
        goto while_break___27;
      }
#line 419
      k = 0;
      {
#line 419
      while (1) {
        while_continue___28: /* CIL Label */ ;
#line 419
        if (! (k < (int )block.numtracks)) {
#line 419
          goto while_break___28;
        }
        {
#line 420
        e[0] = read8(f);
#line 421
        e[1] = read8(f);
#line 422
        e[2] = read8(f);
#line 423
        e[3] = read8(f);
#line 425
        event = & (*(m___0->xxt + (*(m___0->xxp + i___3))->info[k].index))->event[j];
#line 426
        event->note = (uint8 )((int )e[0] & 127);
        }
#line 427
        if (event->note) {
#line 428
          event->note = (uint8 )((int )event->note + (12 + (int )song.playtransp));
        }
        {
#line 429
        event->ins = (uint8 )((int )e[1] & 63);
#line 430
        event->fxt = e[2];
#line 431
        event->fxp = e[3];
#line 432
        xlat_fx(event);
#line 419
        k ++;
        }
      }
      while_break___28: /* CIL Label */ ;
      }
#line 418
      j ++;
    }
    while_break___27: /* CIL Label */ ;
    }
    {
#line 435
    reportv(ctx___0, 0, (char *)".");
    }
    __Cont___1: /* CIL Label */ 
#line 400
    i___3 ++;
  }
  while_break___23: /* CIL Label */ ;
  }
  {
#line 437
  reportv(ctx___0, 0, (char *)"\n");
#line 439
  tmp___28 = calloc((size_t )sizeof(uint8 *), (size_t )(m___0->xxh)->ins);
#line 439
  m___0->med_vol_table = (uint8 **)tmp___28;
#line 440
  tmp___29 = calloc((size_t )sizeof(uint8 *), (size_t )(m___0->xxh)->ins);
#line 440
  m___0->med_wav_table = (uint8 **)tmp___29;
  }
  {
#line 445
  while (1) {
    while_continue___29: /* CIL Label */ ;
#line 445
    goto while_break___29;
  }
  while_break___29: /* CIL Label */ ;
  }
  {
#line 446
  while (1) {
    while_continue___30: /* CIL Label */ ;
    {
#line 446
    tmp___30 = calloc((size_t )sizeof(struct xxm_instrument_header ), (size_t )(m___0->xxh)->ins);
#line 446
    m___0->xxih = (struct xxm_instrument_header *)tmp___30;
#line 446
    tmp___31 = calloc((size_t )sizeof(struct xxm_instrument_map ), (size_t )(m___0->xxh)->ins);
#line 446
    m___0->xxim = (struct xxm_instrument_map *)tmp___31;
#line 446
    tmp___32 = calloc((size_t )sizeof(struct xxm_instrument *), (size_t )(m___0->xxh)->ins);
#line 446
    m___0->xxi = (struct xxm_instrument **)tmp___32;
    }
#line 446
    if ((m___0->xxh)->smp) {
      {
#line 446
      tmp___33 = calloc((size_t )sizeof(struct xxm_sample ), (size_t )(m___0->xxh)->smp);
#line 446
      m___0->xxs = (struct xxm_sample *)tmp___33;
      }
    }
    {
#line 446
    tmp___34 = calloc((size_t )sizeof(uint16 *), (size_t )(m___0->xxh)->ins);
#line 446
    m___0->xxae = (uint16 **)tmp___34;
#line 446
    tmp___35 = calloc((size_t )sizeof(uint16 *), (size_t )(m___0->xxh)->ins);
#line 446
    m___0->xxpe = (uint16 **)tmp___35;
#line 446
    tmp___36 = calloc((size_t )sizeof(uint16 *), (size_t )(m___0->xxh)->ins);
#line 446
    m___0->xxfe = (uint16 **)tmp___36;
    }
#line 446
    goto while_break___30;
  }
  while_break___30: /* CIL Label */ ;
  }
  {
#line 448
  reportv(ctx___0, 0, (char *)"Instruments    : %d ", (m___0->xxh)->ins);
#line 449
  reportv(ctx___0, 1, (char *)"\n     Instrument name                          Typ Len   LBeg  LEnd  Vl Xpo Ft");
#line 451
  i___3 = 0;
#line 451
  smp_idx = i___3;
  }
  {
#line 451
  while (1) {
    while_continue___31: /* CIL Label */ ;
#line 451
    if (! (i___3 < (m___0->xxh)->ins)) {
#line 451
      goto while_break___31;
    }
    {
#line 453
    fseek(f, (long )((start + (int const   )smplarr_offset) + (int const   )(i___3 * 4)),
          0);
#line 454
    tmp___37 = read32b(f);
#line 454
    smpl_offset___0 = (int )tmp___37;
    }
#line 456
    if (smpl_offset___0 == 0) {
#line 457
      goto __Cont___2;
    }
    {
#line 459
    fseek(f, (long )(start + (int const   )smpl_offset___0), 0);
#line 460
    instr.length = read32b(f);
#line 461
    tmp___38 = read16b(f);
#line 461
    instr.type = (WORD___0 )tmp___38;
#line 463
    tmp___39 = ftell(f);
#line 463
    pos___0 = (int )tmp___39;
    }
#line 465
    if (m___0->verbosity > 1) {
#line 468
      name[0] = (char )'\000';
#line 468
      tmp___40 = 1U;
      {
#line 468
      while (1) {
        while_continue___32: /* CIL Label */ ;
#line 468
        if (tmp___40 >= 40U) {
#line 468
          goto while_break___32;
        }
#line 468
        name[tmp___40] = (char)0;
#line 468
        tmp___40 ++;
      }
      while_break___32: /* CIL Label */ ;
      }
#line 469
      if (expdata_offset) {
#line 469
        if (i___3 < (int )expdata.i_ext_entries) {
          {
#line 470
          fseek(f, (long )(iinfo_offset + i___3 * (int )expdata.i_ext_entrsz), 0);
#line 472
          fread((void */* __restrict  */)(name), (size_t )40, (size_t )1, (FILE */* __restrict  */)f);
          }
        }
      }
#line 475
      t = ((int )instr.type + 2) & -49;
#line 476
      if (t <= 9) {
#line 476
        tmp___41 = (char const   *)inst_type[t];
      } else {
#line 476
        tmp___41 = "???";
      }
      {
#line 476
      report((char *)"\n[%2x] %-40.40s %s ", i___3, name, tmp___41);
      }
    }
#line 480
    exp_smp.finetune = (BYTE___0 )0;
#line 481
    if (expdata_offset) {
#line 481
      if (i___3 < (int )expdata.s_ext_entries) {
        {
#line 482
        fseek(f, (long )(expsmp_offset + i___3 * (int )expdata.s_ext_entrsz), 0);
#line 484
        exp_smp.hold = read8(f);
#line 485
        exp_smp.decay = read8(f);
#line 486
        exp_smp.suppress_midi_off = read8(f);
#line 487
        tmp___42 = read8(f);
#line 487
        exp_smp.finetune = (BYTE___0 )tmp___42;
        }
#line 489
        if ((int )expdata.s_ext_entrsz > 4) {
          {
#line 490
          exp_smp.default_pitch = read8(f);
#line 491
          exp_smp.instr_flags = read8(f);
          }
        }
      }
    }
    {
#line 495
    fseek(f, (long )(start + (int const   )pos___0), 0);
    }
#line 497
    if ((int )instr.type == -2) {
      {
#line 499
      tmp___43 = ftell(f);
#line 499
      pos___1 = (int )tmp___43;
#line 501
      synth.defaultdecay = read8(f);
#line 502
      fseek(f, 3L, 1);
#line 503
      synth.rep = read16b(f);
#line 504
      synth.replen = read16b(f);
#line 505
      synth.voltbllen = read16b(f);
#line 506
      synth.wftbllen = read16b(f);
#line 507
      synth.volspeed = read8(f);
#line 508
      synth.wfspeed = read8(f);
#line 509
      synth.wforms = read16b(f);
#line 510
      fread((void */* __restrict  */)(synth.voltbl), (size_t )1, (size_t )128, (FILE */* __restrict  */)f);
#line 511
      fread((void */* __restrict  */)(synth.wftbl), (size_t )1, (size_t )128, (FILE */* __restrict  */)f);
#line 513
      tmp___44 = read32b(f);
#line 513
      fseek(f, (long )((uint32 )((start + (int const   )pos___1) - 6) + tmp___44),
            0);
#line 514
      tmp___45 = read32b(f);
#line 514
      length = (int )tmp___45;
#line 515
      tmp___46 = read16b(f);
#line 515
      type___0 = (int )tmp___46;
#line 517
      tmp___47 = calloc((size_t )sizeof(struct xxm_instrument ), (size_t )1);
#line 517
      *(m___0->xxi + i___3) = (struct xxm_instrument *)tmp___47;
#line 518
      (m___0->xxih + i___3)->nsm = 1;
#line 519
      (m___0->xxih + i___3)->vts = (int )synth.volspeed;
#line 520
      (m___0->xxih + i___3)->wts = (int )synth.wfspeed;
#line 521
      (*(m___0->xxi + i___3) + 0)->pan = 128;
#line 522
      (*(m___0->xxi + i___3) + 0)->vol = (int )song.sample[i___3].svol;
#line 523
      (*(m___0->xxi + i___3) + 0)->xpo = (int )song.sample[i___3].strans;
#line 524
      (*(m___0->xxi + i___3) + 0)->sid = smp_idx;
#line 525
      (*(m___0->xxi + i___3) + 0)->fin = (int )exp_smp.finetune;
#line 526
      (m___0->xxs + smp_idx)->len = length;
#line 527
      (m___0->xxs + smp_idx)->lps = 2 * (int )song.sample[i___3].rep;
#line 528
      (m___0->xxs + smp_idx)->lpe = (m___0->xxs + smp_idx)->lps + 2 * (int )song.sample[i___3].replen;
      }
#line 530
      if ((int )song.sample[i___3].replen > 1) {
#line 530
        (m___0->xxs + smp_idx)->flg = 4;
      } else {
#line 530
        (m___0->xxs + smp_idx)->flg = 0;
      }
      {
#line 533
      reportv(ctx___0, 1, (char *)"%05x %05x %05x %02x %+3d %+1d ", (m___0->xxs + smp_idx)->len,
              (m___0->xxs + smp_idx)->lps, (m___0->xxs + smp_idx)->lpe, (*(m___0->xxi + i___3) + 0)->vol,
              (*(m___0->xxi + i___3) + 0)->xpo, (*(m___0->xxi + i___3) + 0)->fin >> 4);
#line 539
      xmp_drv_loadpatch(ctx___0, f, smp_idx, m___0->c4rate, 0, m___0->xxs + smp_idx,
                        (char *)((void *)0));
#line 542
      smp_idx ++;
#line 544
      tmp___48 = calloc((size_t )1, (size_t )synth.voltbllen);
#line 544
      *(m___0->med_vol_table + i___3) = (uint8 *)tmp___48;
#line 545
      memcpy((void */* __restrict  */)*(m___0->med_vol_table + i___3), (void const   */* __restrict  */)(synth.voltbl),
             (size_t )synth.voltbllen);
#line 547
      tmp___49 = calloc((size_t )1, (size_t )synth.wftbllen);
#line 547
      *(m___0->med_wav_table + i___3) = (uint8 *)tmp___49;
#line 548
      memcpy((void */* __restrict  */)*(m___0->med_wav_table + i___3), (void const   */* __restrict  */)(synth.wftbl),
             (size_t )synth.wftbllen);
#line 550
      reportv(ctx___0, 0, (char *)".");
      }
#line 552
      goto __Cont___2;
    }
#line 555
    if ((int )instr.type == -1) {
      {
#line 556
      tmp___50 = ftell(f);
#line 556
      pos___2 = (int )tmp___50;
#line 558
      synth.defaultdecay = read8(f);
#line 559
      fseek(f, 3L, 1);
#line 560
      synth.rep = read16b(f);
#line 561
      synth.replen = read16b(f);
#line 562
      synth.voltbllen = read16b(f);
#line 563
      synth.wftbllen = read16b(f);
#line 564
      synth.volspeed = read8(f);
#line 565
      synth.wfspeed = read8(f);
#line 566
      synth.wforms = read16b(f);
#line 567
      fread((void */* __restrict  */)(synth.voltbl), (size_t )1, (size_t )128, (FILE */* __restrict  */)f);
#line 568
      fread((void */* __restrict  */)(synth.wftbl), (size_t )1, (size_t )128, (FILE */* __restrict  */)f);
#line 569
      j = 0;
      }
      {
#line 569
      while (1) {
        while_continue___33: /* CIL Label */ ;
#line 569
        if (! (j < 64)) {
#line 569
          goto while_break___33;
        }
        {
#line 570
        synth.wf[j] = read32b(f);
#line 569
        j ++;
        }
      }
      while_break___33: /* CIL Label */ ;
      }
      {
#line 572
      reportv(ctx___0, 1, (char *)"VS:%02x WS:%02x WF:%02x %02x %+3d %+1d ", (int )synth.volspeed,
              (int )synth.wfspeed, (int )synth.wforms & 255, (int )song.sample[i___3].svol,
              (int )song.sample[i___3].strans, (int )exp_smp.finetune);
      }
#line 579
      if ((int )synth.wforms == 65535) {
#line 580
        goto __Cont___2;
      }
      {
#line 582
      tmp___51 = calloc((size_t )sizeof(struct xxm_instrument ), (size_t )synth.wforms);
#line 582
      *(m___0->xxi + i___3) = (struct xxm_instrument *)tmp___51;
#line 584
      (m___0->xxih + i___3)->nsm = (int )synth.wforms;
#line 585
      (m___0->xxih + i___3)->vts = (int )synth.volspeed;
#line 586
      (m___0->xxih + i___3)->wts = (int )synth.wfspeed;
#line 588
      j = 0;
      }
      {
#line 588
      while (1) {
        while_continue___34: /* CIL Label */ ;
#line 588
        if (! (j < (int )synth.wforms)) {
#line 588
          goto while_break___34;
        }
        {
#line 589
        (*(m___0->xxi + i___3) + j)->pan = 128;
#line 590
        (*(m___0->xxi + i___3) + j)->vol = (int )song.sample[i___3].svol;
#line 591
        (*(m___0->xxi + i___3) + j)->xpo = (int )song.sample[i___3].strans - 24;
#line 592
        (*(m___0->xxi + i___3) + j)->sid = smp_idx;
#line 593
        (*(m___0->xxi + i___3) + j)->fin = (int )exp_smp.finetune;
#line 595
        fseek(f, (long )((ULONG )((start + (int const   )pos___2) - 6) + synth.wf[j]),
              0);
#line 597
        tmp___52 = read16b(f);
#line 597
        (m___0->xxs + smp_idx)->len = (int )tmp___52 * 2;
#line 598
        (m___0->xxs + smp_idx)->lps = 0;
#line 599
        (m___0->xxs + smp_idx)->lpe = (m___0->xxs + smp_idx)->len;
#line 600
        (m___0->xxs + smp_idx)->flg = 4;
#line 602
        xmp_drv_loadpatch(ctx___0, f, smp_idx, m___0->c4rate, 32, m___0->xxs + smp_idx,
                          (char *)((void *)0));
#line 606
        smp_idx ++;
#line 588
        j ++;
        }
      }
      while_break___34: /* CIL Label */ ;
      }
      {
#line 609
      tmp___53 = calloc((size_t )1, (size_t )synth.voltbllen);
#line 609
      *(m___0->med_vol_table + i___3) = (uint8 *)tmp___53;
#line 610
      memcpy((void */* __restrict  */)*(m___0->med_vol_table + i___3), (void const   */* __restrict  */)(synth.voltbl),
             (size_t )synth.voltbllen);
#line 612
      tmp___54 = calloc((size_t )1, (size_t )synth.wftbllen);
#line 612
      *(m___0->med_wav_table + i___3) = (uint8 *)tmp___54;
#line 613
      memcpy((void */* __restrict  */)*(m___0->med_wav_table + i___3), (void const   */* __restrict  */)(synth.wftbl),
             (size_t )synth.wftbllen);
#line 615
      reportv(ctx___0, 0, (char *)".");
      }
#line 617
      goto __Cont___2;
    }
#line 620
    if (((int )instr.type & -49) != 0) {
#line 621
      goto __Cont___2;
    }
    {
#line 624
    tmp___55 = calloc((size_t )sizeof(struct xxm_instrument ), (size_t )1);
#line 624
    *(m___0->xxi + i___3) = (struct xxm_instrument *)tmp___55;
#line 625
    (m___0->xxih + i___3)->nsm = 1;
#line 627
    (*(m___0->xxi + i___3) + 0)->vol = (int )song.sample[i___3].svol;
#line 628
    (*(m___0->xxi + i___3) + 0)->pan = 128;
#line 629
    (*(m___0->xxi + i___3) + 0)->xpo = (int )song.sample[i___3].strans;
#line 630
    (*(m___0->xxi + i___3) + 0)->sid = smp_idx;
#line 631
    (*(m___0->xxi + i___3) + 0)->fin = (int )exp_smp.finetune << 4;
#line 633
    (m___0->xxs + smp_idx)->len = (int )instr.length;
#line 634
    (m___0->xxs + smp_idx)->lps = 2 * (int )song.sample[i___3].rep;
#line 635
    (m___0->xxs + smp_idx)->lpe = (m___0->xxs + smp_idx)->lps + 2 * (int )song.sample[i___3].replen;
#line 637
    (m___0->xxs + smp_idx)->flg = 0;
    }
#line 638
    if ((int )song.sample[i___3].replen > 1) {
#line 639
      (m___0->xxs + smp_idx)->flg |= 4;
    }
#line 640
    if ((int )instr.type & 16) {
#line 641
      (m___0->xxs + smp_idx)->flg |= 1;
    }
#line 650
    if ((m___0->xxs + smp_idx)->flg & 1) {
#line 650
      tmp___56 = '+';
    } else {
#line 650
      tmp___56 = ' ';
    }
    {
#line 650
    reportv(ctx___0, 1, (char *)"%05x%c%05x %05x %02x %+3d %+1d ", (m___0->xxs + smp_idx)->len,
            tmp___56, (m___0->xxs + smp_idx)->lps, (m___0->xxs + smp_idx)->lpe, (*(m___0->xxi + i___3) + 0)->vol,
            (*(m___0->xxi + i___3) + 0)->xpo, (*(m___0->xxi + i___3) + 0)->fin >> 4);
#line 659
    fseek(f, (long )((start + (int const   )smpl_offset___0) + 6), 0);
#line 660
    xmp_drv_loadpatch(ctx___0, f, smp_idx, m___0->c4rate, 64, m___0->xxs + smp_idx,
                      (char *)((void *)0));
#line 663
    reportv(ctx___0, 0, (char *)".");
#line 665
    smp_idx ++;
    }
    __Cont___2: /* CIL Label */ 
#line 451
    i___3 ++;
  }
  while_break___31: /* CIL Label */ ;
  }
  {
#line 668
  reportv(ctx___0, 0, (char *)"\n");
#line 670
  fseek(f, (long )(start + (int const   )trackvols_offset), 0);
#line 671
  i___3 = 0;
  }
  {
#line 671
  while (1) {
    while_continue___35: /* CIL Label */ ;
#line 671
    if (! (i___3 < (m___0->xxh)->chn)) {
#line 671
      goto while_break___35;
    }
    {
#line 672
    tmp___57 = read8(f);
#line 672
    m___0->xxc[i___3].vol = (int )tmp___57;
#line 671
    i___3 ++;
    }
  }
  while_break___35: /* CIL Label */ ;
  }
#line 674
  if (trackpans_offset) {
    {
#line 675
    fseek(f, (long )(start + (int const   )trackpans_offset), 0);
#line 676
    i___3 = 0;
    }
    {
#line 676
    while (1) {
      while_continue___36: /* CIL Label */ ;
#line 676
      if (! (i___3 < (m___0->xxh)->chn)) {
#line 676
        goto while_break___36;
      }
      {
#line 677
      tmp___58 = read8s(f);
#line 677
      p___0 = 8 * (int )tmp___58;
      }
#line 678
      if (p___0 > 127) {
#line 678
        tmp___59 = 127;
      } else {
#line 678
        tmp___59 = p___0;
      }
#line 678
      m___0->xxc[i___3].pan = 128 + tmp___59;
#line 676
      i___3 ++;
    }
    while_break___36: /* CIL Label */ ;
    }
  } else {
#line 681
    i___3 = 0;
    {
#line 681
    while (1) {
      while_continue___37: /* CIL Label */ ;
#line 681
      if (! (i___3 < (m___0->xxh)->chn)) {
#line 681
        goto while_break___37;
      }
#line 682
      m___0->xxc[i___3].pan = 128;
#line 681
      i___3 ++;
    }
    while_break___37: /* CIL Label */ ;
    }
  }
#line 685
  return (0);
}
}
#line 21 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/mmd1_load.c"
static int mmd1_test(FILE *f , char *t , int const   start ) ;
#line 22
static int mmd1_load(struct xmp_context *ctx___0 , FILE *f , int const   start ) ;
#line 24 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/mmd1_load.c"
struct xmp_loader_info mmd1_loader  =    {(char *)"MMD0/1", (char *)"MED 2.10/OctaMED", & mmd1_test, & mmd1_load, 0, {(struct list_head *)0,
                                                                                (struct list_head *)0}};
#line 31 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/mmd1_load.c"
static int mmd1_test(FILE *f , char *t , int const   start ) 
{ 
  char id[4] ;
  uint32 offset ;
  uint32 len ;
  int tmp ;
  int tmp___0 ;
  void *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
  {
#line 36
  fread((void */* __restrict  */)(id), (size_t )4, (size_t )1, (FILE */* __restrict  */)f);
#line 38
  tmp = memcmp((void const   *)(id), (void const   *)"MMD0", (size_t )4);
  }
#line 38
  if (tmp) {
    {
#line 38
    tmp___0 = memcmp((void const   *)(id), (void const   *)"MMD1", (size_t )4);
    }
#line 38
    if (tmp___0) {
#line 39
      return (-1);
    }
  }
  {
#line 41
  fseek(f, 28L, 1);
#line 42
  offset = read32b(f);
  }
#line 44
  if (offset) {
    {
#line 45
    fseek(f, (long )(((uint32 )start + offset) + 44U), 0);
#line 46
    offset = read32b(f);
#line 47
    len = read32b(f);
#line 48
    fseek(f, (long )((uint32 )start + offset), 0);
#line 49
    read_title(f, t, (int )len);
    }
  } else {
    {
#line 51
    read_title(f, t, 0);
    }
  }
#line 54
  return (0);
}
}
#line 59 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/mmd1_load.c"
static char *inst_type___0[10]  = 
#line 59
  {      (char *)"HYB",      (char *)"SYN",      (char *)"SMP",      (char *)"I5O", 
        (char *)"I3O",      (char *)"I2O",      (char *)"I4O",      (char *)"I6O", 
        (char *)"I7O",      (char *)"EXT"};
#line 72 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/mmd1_load.c"
static int bpm_on___0  ;
#line 72 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/mmd1_load.c"
static int bpmlen___0  ;
#line 74 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/mmd1_load.c"
static void xlat_fx___0(struct xxm_event *event ) 
{ 
  uint8 tmp ;
  uint8 tmp___0 ;
  uint8 tmp___1 ;

  {
#line 76
  if ((int )event->fxt > 15) {
#line 77
    tmp = (uint8 )0;
#line 77
    event->fxp = tmp;
#line 77
    event->fxt = tmp;
#line 78
    return;
  }
  {
#line 82
  if ((int )event->fxt == 5) {
#line 82
    goto case_5;
  }
#line 86
  if ((int )event->fxt == 7) {
#line 86
    goto case_7;
  }
#line 86
  if ((int )event->fxt == 6) {
#line 86
    goto case_7;
  }
#line 88
  if ((int )event->fxt == 8) {
#line 88
    goto case_8;
  }
#line 90
  if ((int )event->fxt == 9) {
#line 90
    goto case_9;
  }
#line 93
  if ((int )event->fxt == 13) {
#line 93
    goto case_13;
  }
#line 96
  if ((int )event->fxt == 14) {
#line 96
    goto case_14;
  }
#line 98
  if ((int )event->fxt == 15) {
#line 98
    goto case_15;
  }
#line 81
  goto switch_break;
  case_5: /* CIL Label */ 
#line 83
  event->fxp = (uint8 )((((int )event->fxp & 15) << 4) | (((int )event->fxp & 240) >> 4));
#line 84
  goto switch_break;
  case_7: /* CIL Label */ 
  case_6: /* CIL Label */ 
#line 87
  goto switch_break;
  case_8: /* CIL Label */ 
#line 89
  goto switch_break;
  case_9: /* CIL Label */ 
#line 91
  event->fxt = (uint8 )15;
#line 92
  goto switch_break;
  case_13: /* CIL Label */ 
#line 94
  event->fxt = (uint8 )10;
#line 95
  goto switch_break;
  case_14: /* CIL Label */ 
#line 97
  goto switch_break;
  case_15: /* CIL Label */ 
#line 99
  if ((int )event->fxp == 0) {
#line 100
    event->fxt = (uint8 )13;
#line 101
    goto switch_break;
  } else
#line 102
  if ((int )event->fxp <= 10) {
#line 103
    goto switch_break;
  } else
#line 104
  if ((int )event->fxp <= 240) {
#line 105
    event->fxt = (uint8 )171;
#line 106
    if (bpm_on___0) {
#line 107
      event->fxp = (uint8 )(((int )event->fxp * 8) / bpmlen___0);
    }
#line 108
    goto switch_break;
  } else {
    {
#line 110
    if ((int )event->fxp == 241) {
#line 110
      goto case_241;
    }
#line 114
    if ((int )event->fxp == 242) {
#line 114
      goto case_242;
    }
#line 118
    if ((int )event->fxp == 243) {
#line 118
      goto case_243;
    }
#line 127
    if ((int )event->fxp == 254) {
#line 127
      goto case_254;
    }
#line 127
    if ((int )event->fxp == 253) {
#line 127
      goto case_254;
    }
#line 127
    if ((int )event->fxp == 251) {
#line 127
      goto case_254;
    }
#line 127
    if ((int )event->fxp == 250) {
#line 127
      goto case_254;
    }
#line 127
    if ((int )event->fxp == 249) {
#line 127
      goto case_254;
    }
#line 127
    if ((int )event->fxp == 248) {
#line 127
      goto case_254;
    }
#line 130
    if ((int )event->fxp == 255) {
#line 130
      goto case_255;
    }
#line 134
    goto switch_default;
    case_241: /* CIL Label */ 
#line 111
    event->fxt = (uint8 )14;
#line 112
    event->fxp = (uint8 )((9 << 4) | 3);
#line 113
    goto switch_break___0;
    case_242: /* CIL Label */ 
#line 115
    event->fxt = (uint8 )14;
#line 116
    event->fxp = (uint8 )((13 << 4) | 3);
#line 117
    goto switch_break___0;
    case_243: /* CIL Label */ 
#line 119
    event->fxt = (uint8 )14;
#line 120
    event->fxp = (uint8 )((9 << 4) | 2);
#line 121
    goto switch_break___0;
    case_254: /* CIL Label */ 
    case_253: /* CIL Label */ 
    case_251: /* CIL Label */ 
    case_250: /* CIL Label */ 
    case_249: /* CIL Label */ 
    case_248: /* CIL Label */ 
#line 128
    tmp___0 = (uint8 )0;
#line 128
    event->fxp = tmp___0;
#line 128
    event->fxt = tmp___0;
#line 129
    goto switch_break___0;
    case_255: /* CIL Label */ 
#line 131
    event->fxt = (uint8 )14;
#line 132
    event->fxp = (uint8 )((12 << 4) | 3);
#line 133
    goto switch_break___0;
    switch_default: /* CIL Label */ 
#line 135
    tmp___1 = (uint8 )0;
#line 135
    event->fxp = tmp___1;
#line 135
    event->fxt = tmp___1;
    switch_break___0: /* CIL Label */ ;
    }
  }
#line 137
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 139
  return;
}
}
#line 141 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/mmd1_load.c"
static int mmd1_load(struct xmp_context *ctx___0 , FILE *f , int const   start ) 
{ 
  struct xmp_player_context *p ;
  struct xmp_mod_context *m___0 ;
  int i___3 ;
  int j ;
  int k ;
  struct MMD0 header ;
  struct MMD0song song ;
  struct MMD1Block block ;
  struct InstrHdr instr ;
  struct SynthInstr synth ;
  struct InstrExt exp_smp ;
  struct MMD0exp expdata ;
  struct xxm_event *event ;
  int ver___0 ;
  int smp_idx ;
  uint8 e[4] ;
  int song_offset ;
  int blockarr_offset ;
  int smplarr_offset ;
  int expdata_offset ;
  int expsmp_offset ;
  int songname_offset ;
  int iinfo_offset ;
  int pos___0 ;
  uint8 **tmp ;
  uint32 tmp___0 ;
  uint32 tmp___1 ;
  uint32 tmp___2 ;
  uint32 tmp___3 ;
  uint16 tmp___4 ;
  uint8 tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  uint32 smpl_offset ;
  int16 type ;
  uint16 tmp___8 ;
  uint16 tmp___9 ;
  uint32 tmp___10 ;
  uint32 tmp___11 ;
  uint32 tmp___12 ;
  uint8 tmp___13 ;
  int block_offset ;
  uint32 tmp___14 ;
  uint8 tmp___15 ;
  uint8 tmp___16 ;
  char const   *tmp___17 ;
  char const   *tmp___18 ;
  char const   *tmp___19 ;
  void *tmp___20 ;
  void *tmp___21 ;
  int block_offset___0 ;
  uint32 tmp___22 ;
  uint8 tmp___23 ;
  uint8 tmp___24 ;
  void *tmp___25 ;
  int j___0 ;
  void *tmp___26 ;
  void *tmp___27 ;
  void *tmp___28 ;
  void *tmp___29 ;
  void *tmp___30 ;
  void *tmp___31 ;
  void *tmp___32 ;
  void *tmp___33 ;
  void *tmp___34 ;
  void *tmp___35 ;
  int smpl_offset___0 ;
  uint32 tmp___36 ;
  uint16 tmp___37 ;
  long tmp___38 ;
  char name[40] ;
  unsigned int tmp___39 ;
  char const   *tmp___40 ;
  uint8 tmp___41 ;
  int length ;
  int type___0 ;
  int pos___1 ;
  long tmp___42 ;
  uint32 tmp___43 ;
  uint32 tmp___44 ;
  uint16 tmp___45 ;
  void *tmp___46 ;
  void *tmp___47 ;
  void *tmp___48 ;
  int pos___2 ;
  long tmp___49 ;
  void *tmp___50 ;
  uint16 tmp___51 ;
  void *tmp___52 ;
  void *tmp___53 ;
  void *tmp___54 ;
  void *__cil_tmp95 ;
  void *__cil_tmp96 ;
  void *__cil_tmp97 ;
  void *__cil_tmp98 ;
  int __cil_tmp99 ;
  void *__cil_tmp100 ;
  void *__cil_tmp101 ;
  void *__cil_tmp102 ;
  void *__cil_tmp103 ;
  void *__cil_tmp104 ;
  void *__cil_tmp105 ;
  void *__cil_tmp106 ;
  void *__cil_tmp107 ;
  void *__cil_tmp108 ;
  void *__cil_tmp109 ;
  void *__cil_tmp110 ;
  void *__cil_tmp111 ;
  void *__cil_tmp112 ;
  void *__cil_tmp113 ;
  void *__cil_tmp114 ;
  void *__cil_tmp115 ;
  char *__cil_tmp116 ;
  char *__cil_tmp117 ;
  char *__cil_tmp118 ;
  char *__cil_tmp119 ;
  char *__cil_tmp120 ;
  char *__cil_tmp121 ;
  char *__cil_tmp122 ;
  char *__cil_tmp123 ;
  char *__cil_tmp124 ;
  char *__cil_tmp125 ;
  char *__cil_tmp126 ;
  char *__cil_tmp127 ;
  char *__cil_tmp128 ;
  char *__cil_tmp129 ;
  char *__cil_tmp130 ;
  char *__cil_tmp131 ;
  char *__cil_tmp132 ;
  char *__cil_tmp133 ;
  char *__cil_tmp134 ;
  char *__cil_tmp135 ;
  char *__cil_tmp136 ;
  char *__cil_tmp137 ;
  char *__cil_tmp138 ;
  char *__cil_tmp139 ;
  char *__cil_tmp140 ;
  char *__cil_tmp141 ;
  char *__cil_tmp142 ;

  {
#line 143
  p = & ctx___0->p;
#line 144
  m___0 = & p->m;
#line 154
  ver___0 = 0;
#line 155
  smp_idx = 0;
  {
#line 166
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 166
    fseek(f, (long )start, 0);
#line 166
    tmp = (uint8 **)((void *)0);
#line 166
    m___0->med_wav_table = tmp;
#line 166
    m___0->med_vol_table = tmp;
#line 166
    set_xxh_defaults(m___0->xxh);
    }
#line 166
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 168
  fread((void */* __restrict  */)(& header.id), (size_t )4, (size_t )1, (FILE */* __restrict  */)f);
#line 170
  ver___0 = ((int )*((char *)(& header.id) + 3) - 49) + 1;
  }
  {
#line 172
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 172
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 173
  header.modlen = read32b(f);
#line 174
  tmp___0 = read32b(f);
#line 174
  song_offset = (int )tmp___0;
  }
  {
#line 175
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 175
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 176
  read16b(f);
#line 177
  read16b(f);
#line 178
  tmp___1 = read32b(f);
#line 178
  blockarr_offset = (int )tmp___1;
  }
  {
#line 179
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 179
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 180
  read32b(f);
#line 181
  tmp___2 = read32b(f);
#line 181
  smplarr_offset = (int )tmp___2;
  }
  {
#line 182
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 182
    goto while_break___3;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 183
  read32b(f);
#line 184
  tmp___3 = read32b(f);
#line 184
  expdata_offset = (int )tmp___3;
  }
  {
#line 185
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 185
    goto while_break___4;
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 186
  read32b(f);
#line 187
  header.pstate = read16b(f);
#line 188
  header.pblock = read16b(f);
#line 189
  header.pline = read16b(f);
#line 190
  header.pseqnum = read16b(f);
#line 191
  tmp___4 = read16b(f);
#line 191
  header.actplayline = (WORD___0 )tmp___4;
#line 192
  header.counter = read8(f);
#line 193
  header.extra_songs = read8(f);
  }
  {
#line 198
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 198
    goto while_break___5;
  }
  while_break___5: /* CIL Label */ ;
  }
  {
#line 199
  fseek(f, (long )(start + (int const   )song_offset), 0);
#line 200
  i___3 = 0;
  }
  {
#line 200
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 200
    if (! (i___3 < 63)) {
#line 200
      goto while_break___6;
    }
    {
#line 201
    song.sample[i___3].rep = read16b(f);
#line 202
    song.sample[i___3].replen = read16b(f);
#line 203
    song.sample[i___3].midich = read8(f);
#line 204
    song.sample[i___3].midipreset = read8(f);
#line 205
    song.sample[i___3].svol = read8(f);
#line 206
    song.sample[i___3].strans = read8s(f);
#line 200
    i___3 ++;
    }
  }
  while_break___6: /* CIL Label */ ;
  }
  {
#line 208
  song.numblocks = read16b(f);
#line 209
  song.songlen = read16b(f);
  }
  {
#line 210
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 210
    goto while_break___7;
  }
  while_break___7: /* CIL Label */ ;
  }
#line 211
  i___3 = 0;
  {
#line 211
  while (1) {
    while_continue___8: /* CIL Label */ ;
#line 211
    if (! (i___3 < 256)) {
#line 211
      goto while_break___8;
    }
    {
#line 212
    song.playseq[i___3] = read8(f);
#line 211
    i___3 ++;
    }
  }
  while_break___8: /* CIL Label */ ;
  }
  {
#line 213
  song.deftempo = read16b(f);
#line 214
  tmp___5 = read8(f);
#line 214
  song.playtransp = (BYTE___0 )tmp___5;
#line 215
  song.flags = read8(f);
#line 216
  song.flags2 = read8(f);
#line 217
  song.tempo2 = read8(f);
#line 218
  i___3 = 0;
  }
  {
#line 218
  while (1) {
    while_continue___9: /* CIL Label */ ;
#line 218
    if (! (i___3 < 16)) {
#line 218
      goto while_break___9;
    }
    {
#line 219
    song.trkvol[i___3] = read8(f);
#line 218
    i___3 ++;
    }
  }
  while_break___9: /* CIL Label */ ;
  }
  {
#line 220
  song.mastervol = read8(f);
#line 221
  song.numsamples = read8(f);
#line 226
  m___0->c4rate = 8363;
  }
#line 227
  if ((int )song.flags & 32) {
#line 227
    tmp___6 = 0;
  } else {
#line 227
    tmp___6 = 1 << 13;
  }
#line 227
  m___0->quirk |= tmp___6;
#line 228
  bpm_on___0 = (int )song.flags2 & 32;
#line 229
  bpmlen___0 = 1 + ((int )song.flags2 & 31);
#line 230
  if (bpm_on___0) {
#line 230
    tmp___7 = 0;
  } else {
#line 230
    tmp___7 = 1;
  }
#line 230
  m___0->quirk |= tmp___7;
#line 243
  if (! bpm_on___0) {
#line 243
    if ((int )song.deftempo < 10) {
#line 244
      song.deftempo = (UWORD )(53 - (int )song.deftempo * 2);
    }
  }
#line 247
  if (bpm_on___0) {
#line 248
    (m___0->xxh)->tpo = 3;
#line 249
    (m___0->xxh)->bpm = ((int )song.deftempo * 8) / bpmlen___0;
  } else {
#line 251
    (m___0->xxh)->tpo = (int )song.tempo2;
#line 252
    (m___0->xxh)->bpm = (int )song.deftempo;
#line 254
    if ((m___0->xxh)->bpm <= 10) {
#line 255
      (m___0->xxh)->bpm = ((m___0->xxh)->bpm * 33) / 6;
    }
  }
  {
#line 258
  (m___0->xxh)->pat = (int )song.numblocks;
#line 259
  (m___0->xxh)->ins = (int )song.numsamples;
#line 261
  (m___0->xxh)->len = (int )song.songlen;
#line 262
  (m___0->xxh)->rst = 0;
#line 263
  (m___0->xxh)->chn = 0;
#line 264
  memcpy((void */* __restrict  */)(m___0->xxo), (void const   */* __restrict  */)(song.playseq),
         (size_t )(m___0->xxh)->len);
#line 265
  m___0->name[0] = (char)0;
#line 270
  (m___0->xxh)->smp = 0;
#line 271
  i___3 = 0;
  }
  {
#line 271
  while (1) {
    while_continue___10: /* CIL Label */ ;
#line 271
    if (! (i___3 < (m___0->xxh)->ins)) {
#line 271
      goto while_break___10;
    }
    {
#line 274
    fseek(f, (long )((start + (int const   )smplarr_offset) + (int const   )(i___3 * 4)),
          0);
#line 275
    smpl_offset = read32b(f);
    }
#line 276
    if (smpl_offset == 0U) {
#line 277
      goto __Cont;
    }
    {
#line 278
    fseek(f, (long )((uint32 )start + smpl_offset), 0);
#line 279
    read32b(f);
#line 280
    tmp___8 = read16b(f);
#line 280
    type = (int16 )tmp___8;
    }
#line 281
    if ((int )type == -1) {
      {
#line 282
      fseek(f, 14L, 1);
#line 283
      tmp___9 = read16b(f);
#line 283
      (m___0->xxh)->smp += (int )tmp___9;
      }
    } else {
#line 285
      ((m___0->xxh)->smp) ++;
    }
    __Cont: /* CIL Label */ 
#line 271
    i___3 ++;
  }
  while_break___10: /* CIL Label */ ;
  }
  {
#line 292
  while (1) {
    while_continue___11: /* CIL Label */ ;
#line 292
    goto while_break___11;
  }
  while_break___11: /* CIL Label */ ;
  }
#line 293
  expdata.s_ext_entries = (UWORD )0;
#line 294
  expdata.s_ext_entrsz = (UWORD )0;
#line 295
  expdata.i_ext_entries = (UWORD )0;
#line 296
  expdata.i_ext_entrsz = (UWORD )0;
#line 297
  expsmp_offset = 0;
#line 298
  iinfo_offset = 0;
#line 299
  if (expdata_offset) {
    {
#line 300
    fseek(f, (long )(start + (int const   )expdata_offset), 0);
#line 301
    read32b(f);
#line 302
    tmp___10 = read32b(f);
#line 302
    expsmp_offset = (int )tmp___10;
    }
    {
#line 303
    while (1) {
      while_continue___12: /* CIL Label */ ;
#line 303
      goto while_break___12;
    }
    while_break___12: /* CIL Label */ ;
    }
    {
#line 304
    expdata.s_ext_entries = read16b(f);
#line 305
    expdata.s_ext_entrsz = read16b(f);
#line 306
    read32b(f);
#line 307
    read32b(f);
#line 308
    tmp___11 = read32b(f);
#line 308
    iinfo_offset = (int )tmp___11;
    }
    {
#line 309
    while (1) {
      while_continue___13: /* CIL Label */ ;
#line 309
      goto while_break___13;
    }
    while_break___13: /* CIL Label */ ;
    }
    {
#line 310
    expdata.i_ext_entries = read16b(f);
#line 311
    expdata.i_ext_entrsz = read16b(f);
#line 312
    read32b(f);
#line 313
    read32b(f);
#line 314
    read32b(f);
#line 315
    read32b(f);
#line 316
    tmp___12 = read32b(f);
#line 316
    songname_offset = (int )tmp___12;
    }
    {
#line 317
    while (1) {
      while_continue___14: /* CIL Label */ ;
#line 317
      goto while_break___14;
    }
    while_break___14: /* CIL Label */ ;
    }
    {
#line 318
    expdata.songnamelen = read32b(f);
#line 319
    fseek(f, (long )(start + (int const   )songname_offset), 0);
    }
    {
#line 320
    while (1) {
      while_continue___15: /* CIL Label */ ;
#line 320
      goto while_break___15;
    }
    while_break___15: /* CIL Label */ ;
    }
#line 321
    i___3 = 0;
    {
#line 321
    while (1) {
      while_continue___16: /* CIL Label */ ;
#line 321
      if (! ((ULONG )i___3 < expdata.songnamelen)) {
#line 321
        goto while_break___16;
      }
#line 322
      if (i___3 >= 64) {
#line 323
        goto while_break___16;
      }
      {
#line 324
      tmp___13 = read8(f);
#line 324
      m___0->name[i___3] = (char )tmp___13;
#line 321
      i___3 ++;
      }
    }
    while_break___16: /* CIL Label */ ;
    }
  }
  {
#line 331
  while (1) {
    while_continue___17: /* CIL Label */ ;
#line 331
    goto while_break___17;
  }
  while_break___17: /* CIL Label */ ;
  }
#line 333
  i___3 = 0;
  {
#line 333
  while (1) {
    while_continue___18: /* CIL Label */ ;
#line 333
    if (! (i___3 < (m___0->xxh)->pat)) {
#line 333
      goto while_break___18;
    }
    {
#line 336
    fseek(f, (long )((start + (int const   )blockarr_offset) + (int const   )(i___3 * 4)),
          0);
#line 337
    tmp___14 = read32b(f);
#line 337
    block_offset = (int )tmp___14;
    }
    {
#line 338
    while (1) {
      while_continue___19: /* CIL Label */ ;
#line 338
      goto while_break___19;
    }
    while_break___19: /* CIL Label */ ;
    }
#line 339
    if (block_offset == 0) {
#line 340
      goto __Cont___0;
    }
    {
#line 341
    fseek(f, (long )(start + (int const   )block_offset), 0);
    }
#line 343
    if (ver___0 > 0) {
      {
#line 344
      block.numtracks = read16b(f);
#line 345
      block.lines = read16b(f);
      }
    } else {
      {
#line 347
      tmp___15 = read8(f);
#line 347
      block.numtracks = (UWORD )tmp___15;
#line 348
      tmp___16 = read8(f);
#line 348
      block.lines = (UWORD )tmp___16;
      }
    }
#line 351
    if ((int )block.numtracks > (m___0->xxh)->chn) {
#line 352
      (m___0->xxh)->chn = (int )block.numtracks;
    }
    __Cont___0: /* CIL Label */ 
#line 333
    i___3 ++;
  }
  while_break___18: /* CIL Label */ ;
  }
#line 355
  (m___0->xxh)->trk = (m___0->xxh)->pat * (m___0->xxh)->chn;
#line 357
  if (ver___0 == 0) {
#line 357
    if ((m___0->xxh)->chn > 4) {
#line 357
      tmp___17 = "MMD0 (OctaMED 2.00)";
    } else {
#line 357
      tmp___17 = "MMD0 (MED 2.10)";
    }
#line 357
    tmp___18 = tmp___17;
  } else {
#line 357
    tmp___18 = "MMD1 (OctaMED 4.00)";
  }
  {
#line 357
  strcpy((char */* __restrict  */)(m___0->type), (char const   */* __restrict  */)tmp___18);
  }
  {
#line 360
  while (1) {
    while_continue___20: /* CIL Label */ ;
#line 360
    if (m___0->verbosity) {
#line 360
      if (m___0->name[0]) {
        {
#line 360
        report((char *)"Module title   : %s\n", m___0->name);
        }
      }
#line 360
      if (m___0->type[0]) {
        {
#line 360
        report((char *)"Module type    : %s\n", m___0->type);
        }
      }
#line 360
      if (m___0->author[0]) {
        {
#line 360
        report((char *)"Author name    : %s\n", m___0->author);
        }
      }
#line 360
      if ((m___0->xxh)->len) {
        {
#line 360
        report((char *)"Module length  : %d patterns\n", (m___0->xxh)->len);
        }
      }
    }
#line 360
    goto while_break___20;
  }
  while_break___20: /* CIL Label */ ;
  }
#line 362
  if (m___0->verbosity > 0) {
#line 363
    if (bpm_on___0) {
#line 363
      tmp___19 = "on";
    } else {
#line 363
      tmp___19 = "off";
    }
    {
#line 363
    report((char *)"BPM mode       : %s", tmp___19);
    }
#line 364
    if (bpm_on___0) {
      {
#line 365
      report((char *)" (length = %d)", bpmlen___0);
      }
    }
    {
#line 366
    report((char *)"\n");
    }
#line 367
    if (m___0->verbosity > 1) {
#line 367
      if (song.playtransp) {
        {
#line 368
        report((char *)"Song transpose : %d\n", (int )song.playtransp);
        }
      }
    }
    {
#line 369
    report((char *)"Stored patterns: %d ", (m___0->xxh)->pat);
    }
  }
  {
#line 375
  while (1) {
    while_continue___21: /* CIL Label */ ;
#line 375
    goto while_break___21;
  }
  while_break___21: /* CIL Label */ ;
  }
  {
#line 376
  while (1) {
    while_continue___22: /* CIL Label */ ;
    {
#line 376
    tmp___20 = calloc((size_t )sizeof(struct xxm_track *), (size_t )(m___0->xxh)->trk);
#line 376
    m___0->xxt = (struct xxm_track **)tmp___20;
#line 376
    tmp___21 = calloc((size_t )sizeof(struct xxm_pattern *), (size_t )((m___0->xxh)->pat + 1));
#line 376
    m___0->xxp = (struct xxm_pattern **)tmp___21;
    }
#line 376
    goto while_break___22;
  }
  while_break___22: /* CIL Label */ ;
  }
#line 378
  i___3 = 0;
  {
#line 378
  while (1) {
    while_continue___23: /* CIL Label */ ;
#line 378
    if (! (i___3 < (m___0->xxh)->pat)) {
#line 378
      goto while_break___23;
    }
    {
#line 381
    fseek(f, (long )((start + (int const   )blockarr_offset) + (int const   )(i___3 * 4)),
          0);
#line 382
    tmp___22 = read32b(f);
#line 382
    block_offset___0 = (int )tmp___22;
    }
#line 383
    if (block_offset___0 == 0) {
#line 384
      goto __Cont___1;
    }
    {
#line 385
    fseek(f, (long )(start + (int const   )block_offset___0), 0);
    }
#line 387
    if (ver___0 > 0) {
      {
#line 388
      block.numtracks = read16b(f);
#line 389
      block.lines = read16b(f);
#line 390
      read32b(f);
      }
    } else {
      {
#line 392
      tmp___23 = read8(f);
#line 392
      block.numtracks = (UWORD )tmp___23;
#line 393
      tmp___24 = read8(f);
#line 393
      block.lines = (UWORD )tmp___24;
      }
    }
    {
#line 396
    while (1) {
      while_continue___24: /* CIL Label */ ;
      {
#line 396
      tmp___25 = calloc((size_t )1, (size_t )(sizeof(struct xxm_pattern ) + sizeof(struct xxm_trackinfo ) * (unsigned long )((m___0->xxh)->chn - 1)));
#line 396
      *(m___0->xxp + i___3) = (struct xxm_pattern *)tmp___25;
      }
#line 396
      goto while_break___24;
    }
    while_break___24: /* CIL Label */ ;
    }
#line 398
    (*(m___0->xxp + i___3))->rows = (int )block.lines + 1;
    {
#line 399
    while (1) {
      while_continue___25: /* CIL Label */ ;
#line 399
      j___0 = 0;
      {
#line 399
      while (1) {
        while_continue___26: /* CIL Label */ ;
#line 399
        if (! (j___0 < (m___0->xxh)->chn)) {
#line 399
          goto while_break___26;
        }
        {
#line 399
        (*(m___0->xxp + i___3))->info[j___0].index = i___3 * (m___0->xxh)->chn + j___0;
#line 399
        tmp___26 = calloc((size_t )(sizeof(struct xxm_track ) + sizeof(struct xxm_event ) * (unsigned long )(*(m___0->xxp + i___3))->rows),
                          (size_t )1);
#line 399
        *(m___0->xxt + (i___3 * (m___0->xxh)->chn + j___0)) = (struct xxm_track *)tmp___26;
#line 399
        (*(m___0->xxt + (i___3 * (m___0->xxh)->chn + j___0)))->rows = (*(m___0->xxp + i___3))->rows;
#line 399
        j___0 ++;
        }
      }
      while_break___26: /* CIL Label */ ;
      }
#line 399
      goto while_break___25;
    }
    while_break___25: /* CIL Label */ ;
    }
#line 401
    if (ver___0 > 0) {
#line 402
      j = 0;
      {
#line 402
      while (1) {
        while_continue___27: /* CIL Label */ ;
#line 402
        if (! (j < (*(m___0->xxp + i___3))->rows)) {
#line 402
          goto while_break___27;
        }
#line 403
        k = 0;
        {
#line 403
        while (1) {
          while_continue___28: /* CIL Label */ ;
#line 403
          if (! (k < (int )block.numtracks)) {
#line 403
            goto while_break___28;
          }
          {
#line 404
          e[0] = read8(f);
#line 405
          e[1] = read8(f);
#line 406
          e[2] = read8(f);
#line 407
          e[3] = read8(f);
#line 409
          event = & (*(m___0->xxt + (*(m___0->xxp + i___3))->info[k].index))->event[j];
#line 410
          event->note = (uint8 )((int )e[0] & 127);
          }
#line 411
          if (event->note) {
#line 412
            event->note = (uint8 )((int )event->note + (36 + (int )song.playtransp));
          }
          {
#line 414
          event->ins = (uint8 )((int )e[1] & 63);
#line 415
          event->fxt = e[2];
#line 416
          event->fxp = e[3];
#line 417
          xlat_fx___0(event);
#line 403
          k ++;
          }
        }
        while_break___28: /* CIL Label */ ;
        }
#line 402
        j ++;
      }
      while_break___27: /* CIL Label */ ;
      }
    } else {
#line 421
      j = 0;
      {
#line 421
      while (1) {
        while_continue___29: /* CIL Label */ ;
#line 421
        if (! (j < (*(m___0->xxp + i___3))->rows)) {
#line 421
          goto while_break___29;
        }
#line 422
        k = 0;
        {
#line 422
        while (1) {
          while_continue___30: /* CIL Label */ ;
#line 422
          if (! (k < (int )block.numtracks)) {
#line 422
            goto while_break___30;
          }
          {
#line 423
          e[0] = read8(f);
#line 424
          e[1] = read8(f);
#line 425
          e[2] = read8(f);
#line 427
          event = & (*(m___0->xxt + (*(m___0->xxp + i___3))->info[k].index))->event[j];
#line 428
          event->note = (uint8 )((int )e[0] & 63);
          }
#line 429
          if (event->note) {
#line 430
            event->note = (uint8 )((int )event->note + 36);
          }
          {
#line 431
          event->ins = (uint8 )((((int )e[1] >> 4) | (((int )e[0] & 128) >> 3)) | (((int )e[0] & 64) >> 1));
#line 434
          event->fxt = (uint8 )((int )e[1] & 15);
#line 435
          event->fxp = e[2];
#line 436
          xlat_fx___0(event);
#line 422
          k ++;
          }
        }
        while_break___30: /* CIL Label */ ;
        }
#line 421
        j ++;
      }
      while_break___29: /* CIL Label */ ;
      }
    }
    {
#line 440
    reportv(ctx___0, 0, (char *)".");
    }
    __Cont___1: /* CIL Label */ 
#line 378
    i___3 ++;
  }
  while_break___23: /* CIL Label */ ;
  }
  {
#line 442
  reportv(ctx___0, 0, (char *)"\n");
#line 444
  tmp___27 = calloc((size_t )sizeof(uint8 *), (size_t )(m___0->xxh)->ins);
#line 444
  m___0->med_vol_table = (uint8 **)tmp___27;
#line 445
  tmp___28 = calloc((size_t )sizeof(uint8 *), (size_t )(m___0->xxh)->ins);
#line 445
  m___0->med_wav_table = (uint8 **)tmp___28;
  }
  {
#line 450
  while (1) {
    while_continue___31: /* CIL Label */ ;
#line 450
    goto while_break___31;
  }
  while_break___31: /* CIL Label */ ;
  }
  {
#line 451
  while (1) {
    while_continue___32: /* CIL Label */ ;
    {
#line 451
    tmp___29 = calloc((size_t )sizeof(struct xxm_instrument_header ), (size_t )(m___0->xxh)->ins);
#line 451
    m___0->xxih = (struct xxm_instrument_header *)tmp___29;
#line 451
    tmp___30 = calloc((size_t )sizeof(struct xxm_instrument_map ), (size_t )(m___0->xxh)->ins);
#line 451
    m___0->xxim = (struct xxm_instrument_map *)tmp___30;
#line 451
    tmp___31 = calloc((size_t )sizeof(struct xxm_instrument *), (size_t )(m___0->xxh)->ins);
#line 451
    m___0->xxi = (struct xxm_instrument **)tmp___31;
    }
#line 451
    if ((m___0->xxh)->smp) {
      {
#line 451
      tmp___32 = calloc((size_t )sizeof(struct xxm_sample ), (size_t )(m___0->xxh)->smp);
#line 451
      m___0->xxs = (struct xxm_sample *)tmp___32;
      }
    }
    {
#line 451
    tmp___33 = calloc((size_t )sizeof(uint16 *), (size_t )(m___0->xxh)->ins);
#line 451
    m___0->xxae = (uint16 **)tmp___33;
#line 451
    tmp___34 = calloc((size_t )sizeof(uint16 *), (size_t )(m___0->xxh)->ins);
#line 451
    m___0->xxpe = (uint16 **)tmp___34;
#line 451
    tmp___35 = calloc((size_t )sizeof(uint16 *), (size_t )(m___0->xxh)->ins);
#line 451
    m___0->xxfe = (uint16 **)tmp___35;
    }
#line 451
    goto while_break___32;
  }
  while_break___32: /* CIL Label */ ;
  }
  {
#line 453
  reportv(ctx___0, 0, (char *)"Instruments    : %d ", (m___0->xxh)->ins);
#line 454
  reportv(ctx___0, 1, (char *)"\n     Instrument name                          Typ Len   LBeg  LEnd  Vl Xpo Ft");
#line 456
  i___3 = 0;
#line 456
  smp_idx = i___3;
  }
  {
#line 456
  while (1) {
    while_continue___33: /* CIL Label */ ;
#line 456
    if (! (i___3 < (m___0->xxh)->ins)) {
#line 456
      goto while_break___33;
    }
    {
#line 458
    fseek(f, (long )((start + (int const   )smplarr_offset) + (int const   )(i___3 * 4)),
          0);
#line 459
    tmp___36 = read32b(f);
#line 459
    smpl_offset___0 = (int )tmp___36;
    }
#line 461
    if (smpl_offset___0 == 0) {
#line 462
      goto __Cont___2;
    }
    {
#line 464
    fseek(f, (long )(start + (int const   )smpl_offset___0), 0);
#line 465
    instr.length = read32b(f);
#line 466
    tmp___37 = read16b(f);
#line 466
    instr.type = (WORD___0 )tmp___37;
#line 468
    tmp___38 = ftell(f);
#line 468
    pos___0 = (int )tmp___38;
    }
#line 470
    if (m___0->verbosity > 1) {
#line 471
      name[0] = (char )'\000';
#line 471
      tmp___39 = 1U;
      {
#line 471
      while (1) {
        while_continue___34: /* CIL Label */ ;
#line 471
        if (tmp___39 >= 40U) {
#line 471
          goto while_break___34;
        }
#line 471
        name[tmp___39] = (char)0;
#line 471
        tmp___39 ++;
      }
      while_break___34: /* CIL Label */ ;
      }
#line 472
      if (expdata_offset) {
#line 472
        if (i___3 < (int )expdata.i_ext_entries) {
          {
#line 473
          fseek(f, (long )(iinfo_offset + i___3 * (int )expdata.i_ext_entrsz), 0);
#line 475
          fread((void */* __restrict  */)(name), (size_t )40, (size_t )1, (FILE */* __restrict  */)f);
          }
        }
      }
#line 478
      if ((int )instr.type + 2 <= 9) {
#line 478
        tmp___40 = (char const   *)inst_type___0[(int )instr.type + 2];
      } else {
#line 478
        tmp___40 = "???";
      }
      {
#line 478
      report((char *)"\n[%2x] %-40.40s %s ", i___3, name, tmp___40);
      }
    }
#line 483
    exp_smp.finetune = (BYTE___0 )0;
#line 484
    if (expdata_offset) {
#line 484
      if (i___3 < (int )expdata.s_ext_entries) {
        {
#line 485
        fseek(f, (long )(expsmp_offset + i___3 * (int )expdata.s_ext_entrsz), 0);
#line 487
        exp_smp.hold = read8(f);
#line 488
        exp_smp.decay = read8(f);
#line 489
        exp_smp.suppress_midi_off = read8(f);
#line 490
        tmp___41 = read8(f);
#line 490
        exp_smp.finetune = (BYTE___0 )tmp___41;
        }
      }
    }
    {
#line 494
    fseek(f, (long )(start + (int const   )pos___0), 0);
    }
#line 496
    if ((int )instr.type == -2) {
      {
#line 498
      tmp___42 = ftell(f);
#line 498
      pos___1 = (int )tmp___42;
#line 500
      synth.defaultdecay = read8(f);
#line 501
      fseek(f, 3L, 1);
#line 502
      synth.rep = read16b(f);
#line 503
      synth.replen = read16b(f);
#line 504
      synth.voltbllen = read16b(f);
#line 505
      synth.wftbllen = read16b(f);
#line 506
      synth.volspeed = read8(f);
#line 507
      synth.wfspeed = read8(f);
#line 508
      synth.wforms = read16b(f);
#line 509
      fread((void */* __restrict  */)(synth.voltbl), (size_t )1, (size_t )128, (FILE */* __restrict  */)f);
#line 510
      fread((void */* __restrict  */)(synth.wftbl), (size_t )1, (size_t )128, (FILE */* __restrict  */)f);
#line 512
      tmp___43 = read32b(f);
#line 512
      fseek(f, (long )((uint32 )((start + (int const   )pos___1) - 6) + tmp___43),
            0);
#line 513
      tmp___44 = read32b(f);
#line 513
      length = (int )tmp___44;
#line 514
      tmp___45 = read16b(f);
#line 514
      type___0 = (int )tmp___45;
#line 516
      tmp___46 = calloc((size_t )sizeof(struct xxm_instrument ), (size_t )1);
#line 516
      *(m___0->xxi + i___3) = (struct xxm_instrument *)tmp___46;
#line 517
      (m___0->xxih + i___3)->nsm = 1;
#line 518
      (m___0->xxih + i___3)->vts = (int )synth.volspeed;
#line 519
      (m___0->xxih + i___3)->wts = (int )synth.wfspeed;
#line 520
      (*(m___0->xxi + i___3) + 0)->pan = 128;
#line 521
      (*(m___0->xxi + i___3) + 0)->vol = (int )song.sample[i___3].svol;
#line 522
      (*(m___0->xxi + i___3) + 0)->xpo = (int )song.sample[i___3].strans;
#line 523
      (*(m___0->xxi + i___3) + 0)->sid = smp_idx;
#line 524
      (*(m___0->xxi + i___3) + 0)->fin = (int )exp_smp.finetune;
#line 525
      (m___0->xxs + smp_idx)->len = length;
#line 526
      (m___0->xxs + smp_idx)->lps = 2 * (int )song.sample[i___3].rep;
#line 527
      (m___0->xxs + smp_idx)->lpe = (m___0->xxs + smp_idx)->lps + 2 * (int )song.sample[i___3].replen;
      }
#line 529
      if ((int )song.sample[i___3].replen > 1) {
#line 529
        (m___0->xxs + smp_idx)->flg = 4;
      } else {
#line 529
        (m___0->xxs + smp_idx)->flg = 0;
      }
      {
#line 532
      reportv(ctx___0, 1, (char *)"%05x %05x %05x %02x %+3d %+1d ", (m___0->xxs + smp_idx)->len,
              (m___0->xxs + smp_idx)->lps, (m___0->xxs + smp_idx)->lpe, (*(m___0->xxi + i___3) + 0)->vol,
              (*(m___0->xxi + i___3) + 0)->xpo, (*(m___0->xxi + i___3) + 0)->fin >> 4);
#line 538
      xmp_drv_loadpatch(ctx___0, f, smp_idx, m___0->c4rate, 0, m___0->xxs + smp_idx,
                        (char *)((void *)0));
#line 541
      smp_idx ++;
#line 543
      tmp___47 = calloc((size_t )1, (size_t )synth.voltbllen);
#line 543
      *(m___0->med_vol_table + i___3) = (uint8 *)tmp___47;
#line 544
      memcpy((void */* __restrict  */)*(m___0->med_vol_table + i___3), (void const   */* __restrict  */)(synth.voltbl),
             (size_t )synth.voltbllen);
#line 546
      tmp___48 = calloc((size_t )1, (size_t )synth.wftbllen);
#line 546
      *(m___0->med_wav_table + i___3) = (uint8 *)tmp___48;
#line 547
      memcpy((void */* __restrict  */)*(m___0->med_wav_table + i___3), (void const   */* __restrict  */)(synth.wftbl),
             (size_t )synth.wftbllen);
#line 549
      reportv(ctx___0, 0, (char *)".");
      }
#line 551
      goto __Cont___2;
    }
#line 554
    if ((int )instr.type == -1) {
      {
#line 555
      tmp___49 = ftell(f);
#line 555
      pos___2 = (int )tmp___49;
#line 557
      synth.defaultdecay = read8(f);
#line 558
      fseek(f, 3L, 1);
#line 559
      synth.rep = read16b(f);
#line 560
      synth.replen = read16b(f);
#line 561
      synth.voltbllen = read16b(f);
#line 562
      synth.wftbllen = read16b(f);
#line 563
      synth.volspeed = read8(f);
#line 564
      synth.wfspeed = read8(f);
#line 565
      synth.wforms = read16b(f);
#line 566
      fread((void */* __restrict  */)(synth.voltbl), (size_t )1, (size_t )128, (FILE */* __restrict  */)f);
#line 567
      fread((void */* __restrict  */)(synth.wftbl), (size_t )1, (size_t )128, (FILE */* __restrict  */)f);
#line 568
      j = 0;
      }
      {
#line 568
      while (1) {
        while_continue___35: /* CIL Label */ ;
#line 568
        if (! (j < 64)) {
#line 568
          goto while_break___35;
        }
        {
#line 569
        synth.wf[j] = read32b(f);
#line 568
        j ++;
        }
      }
      while_break___35: /* CIL Label */ ;
      }
      {
#line 571
      reportv(ctx___0, 1, (char *)"VS:%02x WS:%02x WF:%02x %02x %+3d %+1d ", (int )synth.volspeed,
              (int )synth.wfspeed, (int )synth.wforms & 255, (int )song.sample[i___3].svol,
              (int )song.sample[i___3].strans, (int )exp_smp.finetune);
      }
#line 578
      if ((int )synth.wforms == 65535) {
#line 579
        goto __Cont___2;
      }
      {
#line 581
      tmp___50 = calloc((size_t )sizeof(struct xxm_instrument ), (size_t )synth.wforms);
#line 581
      *(m___0->xxi + i___3) = (struct xxm_instrument *)tmp___50;
#line 583
      (m___0->xxih + i___3)->nsm = (int )synth.wforms;
#line 584
      (m___0->xxih + i___3)->vts = (int )synth.volspeed;
#line 585
      (m___0->xxih + i___3)->wts = (int )synth.wfspeed;
#line 587
      j = 0;
      }
      {
#line 587
      while (1) {
        while_continue___36: /* CIL Label */ ;
#line 587
        if (! (j < (int )synth.wforms)) {
#line 587
          goto while_break___36;
        }
        {
#line 588
        (*(m___0->xxi + i___3) + j)->pan = 128;
#line 589
        (*(m___0->xxi + i___3) + j)->vol = (int )song.sample[i___3].svol;
#line 590
        (*(m___0->xxi + i___3) + j)->xpo = (int )song.sample[i___3].strans - 24;
#line 591
        (*(m___0->xxi + i___3) + j)->sid = smp_idx;
#line 592
        (*(m___0->xxi + i___3) + j)->fin = (int )exp_smp.finetune;
#line 594
        fseek(f, (long )((ULONG )((start + (int const   )pos___2) - 6) + synth.wf[j]),
              0);
#line 596
        tmp___51 = read16b(f);
#line 596
        (m___0->xxs + smp_idx)->len = (int )tmp___51 * 2;
#line 597
        (m___0->xxs + smp_idx)->lps = 0;
#line 598
        (m___0->xxs + smp_idx)->lpe = (m___0->xxs + smp_idx)->len;
#line 599
        (m___0->xxs + smp_idx)->flg = 4;
#line 601
        xmp_drv_loadpatch(ctx___0, f, smp_idx, m___0->c4rate, 32, m___0->xxs + smp_idx,
                          (char *)((void *)0));
#line 605
        smp_idx ++;
#line 587
        j ++;
        }
      }
      while_break___36: /* CIL Label */ ;
      }
      {
#line 608
      tmp___52 = calloc((size_t )1, (size_t )synth.voltbllen);
#line 608
      *(m___0->med_vol_table + i___3) = (uint8 *)tmp___52;
#line 609
      memcpy((void */* __restrict  */)*(m___0->med_vol_table + i___3), (void const   */* __restrict  */)(synth.voltbl),
             (size_t )synth.voltbllen);
#line 611
      tmp___53 = calloc((size_t )1, (size_t )synth.wftbllen);
#line 611
      *(m___0->med_wav_table + i___3) = (uint8 *)tmp___53;
#line 612
      memcpy((void */* __restrict  */)*(m___0->med_wav_table + i___3), (void const   */* __restrict  */)(synth.wftbl),
             (size_t )synth.wftbllen);
#line 614
      reportv(ctx___0, 0, (char *)".");
      }
#line 616
      goto __Cont___2;
    }
#line 619
    if ((int )instr.type != 0) {
#line 620
      goto __Cont___2;
    }
    {
#line 623
    tmp___54 = calloc((size_t )sizeof(struct xxm_instrument ), (size_t )1);
#line 623
    *(m___0->xxi + i___3) = (struct xxm_instrument *)tmp___54;
#line 624
    (m___0->xxih + i___3)->nsm = 1;
#line 626
    (*(m___0->xxi + i___3) + 0)->vol = (int )song.sample[i___3].svol;
#line 627
    (*(m___0->xxi + i___3) + 0)->pan = 128;
#line 628
    (*(m___0->xxi + i___3) + 0)->xpo = (int )song.sample[i___3].strans;
#line 629
    (*(m___0->xxi + i___3) + 0)->sid = smp_idx;
#line 630
    (*(m___0->xxi + i___3) + 0)->fin = (int )exp_smp.finetune << 4;
#line 632
    (m___0->xxs + smp_idx)->len = (int )instr.length;
#line 633
    (m___0->xxs + smp_idx)->lps = 2 * (int )song.sample[i___3].rep;
#line 634
    (m___0->xxs + smp_idx)->lpe = (m___0->xxs + smp_idx)->lps + 2 * (int )song.sample[i___3].replen;
#line 637
    (m___0->xxs + smp_idx)->flg = 0;
    }
#line 638
    if ((int )song.sample[i___3].replen > 1) {
#line 639
      (m___0->xxs + smp_idx)->flg |= 4;
    }
    {
#line 641
    reportv(ctx___0, 1, (char *)"%05x %05x %05x %02x %+3d %+1d ", (m___0->xxs + smp_idx)->len,
            (m___0->xxs + smp_idx)->lps, (m___0->xxs + smp_idx)->lpe, (*(m___0->xxi + i___3) + 0)->vol,
            (*(m___0->xxi + i___3) + 0)->xpo, (*(m___0->xxi + i___3) + 0)->fin >> 4);
#line 649
    fseek(f, (long )((start + (int const   )smpl_offset___0) + 6), 0);
#line 650
    xmp_drv_loadpatch(ctx___0, f, smp_idx, m___0->c4rate, 0, m___0->xxs + smp_idx,
                      (char *)((void *)0));
#line 653
    reportv(ctx___0, 0, (char *)".");
#line 655
    smp_idx ++;
    }
    __Cont___2: /* CIL Label */ 
#line 456
    i___3 ++;
  }
  while_break___33: /* CIL Label */ ;
  }
  {
#line 658
  reportv(ctx___0, 0, (char *)"\n");
#line 668
  i___3 = 0;
  }
  {
#line 668
  while (1) {
    while_continue___37: /* CIL Label */ ;
#line 668
    if (! (i___3 < (m___0->xxh)->pat)) {
#line 668
      goto while_break___37;
    }
#line 669
    j = 0;
    {
#line 669
    while (1) {
      while_continue___38: /* CIL Label */ ;
#line 669
      if (! (j < (*(m___0->xxp + i___3))->rows)) {
#line 669
        goto while_break___38;
      }
#line 670
      k = 0;
      {
#line 670
      while (1) {
        while_continue___39: /* CIL Label */ ;
#line 670
        if (! (k < (m___0->xxh)->chn)) {
#line 670
          goto while_break___39;
        }
#line 671
        event = & (*(m___0->xxt + (*(m___0->xxp + i___3))->info[k].index))->event[j];
#line 673
        if (! event->note) {
#line 674
          goto __Cont___3;
        } else
#line 673
        if (! event->ins) {
#line 674
          goto __Cont___3;
        }
#line 677
        if (! *(p->m.med_wav_table + ((int )event->ins - 1))) {
          {
#line 678
          while (1) {
            while_continue___40: /* CIL Label */ ;
#line 678
            if (! ((int )event->note > 71)) {
#line 678
              goto while_break___40;
            }
#line 679
            event->note = (uint8 )((int )event->note - 12);
          }
          while_break___40: /* CIL Label */ ;
          }
        }
        __Cont___3: /* CIL Label */ 
#line 670
        k ++;
      }
      while_break___39: /* CIL Label */ ;
      }
#line 669
      j ++;
    }
    while_break___38: /* CIL Label */ ;
    }
#line 668
    i___3 ++;
  }
  while_break___37: /* CIL Label */ ;
  }
#line 685
  i___3 = 0;
  {
#line 685
  while (1) {
    while_continue___41: /* CIL Label */ ;
#line 685
    if (! (i___3 < (m___0->xxh)->chn)) {
#line 685
      goto while_break___41;
    }
#line 686
    m___0->xxc[i___3].vol = (int )song.trkvol[i___3];
#line 687
    m___0->xxc[i___3].pan = (((i___3 + 1) / 2) % 2) * 255;
#line 685
    i___3 ++;
  }
  while_break___41: /* CIL Label */ ;
  }
#line 690
  return (0);
}
}
#line 26 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/load.h"
void disable_continue_fx(struct xxm_event *event ) ;
#line 26 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/stim_load.c"
static int stim_test(FILE *f , char *t , int const   start ) ;
#line 27
static int stim_load(struct xmp_context *ctx___0 , FILE *f , int const   start ) ;
#line 29 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/stim_load.c"
struct xmp_loader_info stim_loader  =    {(char *)"STIM", (char *)"Slamtilt", & stim_test, & stim_load, 0, {(struct list_head *)0,
                                                                      (struct list_head *)0}};
#line 36 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/stim_load.c"
static int stim_test(FILE *f , char *t , int const   start ) 
{ 
  uint32 tmp ;

  {
  {
#line 38
  tmp = read32b(f);
  }
#line 38
  if (tmp != ((((83U << 24) | (84U << 16)) | (73U << 8)) | 77U)) {
#line 39
    return (-1);
  }
  {
#line 41
  read_title(f, t, 0);
  }
#line 43
  return (0);
}
}
#line 68 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/stim_load.c"
static int stim_load(struct xmp_context *ctx___0 , FILE *f , int const   start ) 
{ 
  struct xmp_player_context *p ;
  struct xmp_mod_context *m___0 ;
  int i___3 ;
  int j ;
  int k ;
  struct xxm_event *event ;
  struct stim_header sh ;
  struct stim_instrument si___0 ;
  uint8 b1 ;
  uint8 b2 ;
  uint8 b3 ;
  uint8 **tmp ;
  uint32 tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  int j___0 ;
  void *tmp___4 ;
  uint8 tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  void *tmp___9 ;
  void *tmp___10 ;
  void *tmp___11 ;
  void *tmp___12 ;
  void *tmp___13 ;
  int tmp___14 ;
  void *__cil_tmp32 ;
  void *__cil_tmp33 ;
  void *__cil_tmp34 ;
  void *__cil_tmp35 ;
  void *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;

  {
#line 70
  p = & ctx___0->p;
#line 71
  m___0 = & p->m;
  {
#line 78
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 78
    fseek(f, (long )start, 0);
#line 78
    tmp = (uint8 **)((void *)0);
#line 78
    m___0->med_wav_table = tmp;
#line 78
    m___0->med_vol_table = tmp;
#line 78
    set_xxh_defaults(m___0->xxh);
    }
#line 78
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 80
  sh.id = read32b(f);
#line 81
  sh.smpaddr = read32b(f);
#line 82
  read32b(f);
#line 83
  read32b(f);
#line 84
  sh.nos = read16b(f);
#line 85
  sh.len = read16b(f);
#line 86
  sh.pat = read16b(f);
#line 87
  fread((void */* __restrict  */)(& sh.order), (size_t )128, (size_t )1, (FILE */* __restrict  */)f);
#line 88
  i___3 = 0;
  }
  {
#line 88
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 88
    if (! (i___3 < 64)) {
#line 88
      goto while_break___0;
    }
    {
#line 89
    tmp___0 = read32b(f);
#line 89
    sh.pataddr[i___3] = tmp___0 + 12U;
#line 88
    i___3 ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 91
  (m___0->xxh)->len = (int )sh.len;
#line 92
  (m___0->xxh)->pat = (int )sh.pat;
#line 93
  (m___0->xxh)->ins = (int )sh.nos;
#line 94
  (m___0->xxh)->smp = (m___0->xxh)->ins;
#line 95
  (m___0->xxh)->trk = (m___0->xxh)->pat * (m___0->xxh)->chn;
#line 97
  i___3 = 0;
  {
#line 97
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 97
    if (! (i___3 < (m___0->xxh)->len)) {
#line 97
      goto while_break___1;
    }
#line 98
    m___0->xxo[i___3] = sh.order[i___3];
#line 97
    i___3 ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 100
  sprintf((char */* __restrict  */)(m___0->type), (char const   */* __restrict  */)"STIM (Slamtilt)");
  }
  {
#line 102
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 102
    if (m___0->verbosity) {
#line 102
      if (m___0->name[0]) {
        {
#line 102
        report((char *)"Module title   : %s\n", m___0->name);
        }
      }
#line 102
      if (m___0->type[0]) {
        {
#line 102
        report((char *)"Module type    : %s\n", m___0->type);
        }
      }
#line 102
      if (m___0->author[0]) {
        {
#line 102
        report((char *)"Author name    : %s\n", m___0->author);
        }
      }
#line 102
      if ((m___0->xxh)->len) {
        {
#line 102
        report((char *)"Module length  : %d patterns\n", (m___0->xxh)->len);
        }
      }
    }
#line 102
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 104
  while (1) {
    while_continue___3: /* CIL Label */ ;
    {
#line 104
    tmp___1 = calloc((size_t )sizeof(struct xxm_track *), (size_t )(m___0->xxh)->trk);
#line 104
    m___0->xxt = (struct xxm_track **)tmp___1;
#line 104
    tmp___2 = calloc((size_t )sizeof(struct xxm_pattern *), (size_t )((m___0->xxh)->pat + 1));
#line 104
    m___0->xxp = (struct xxm_pattern **)tmp___2;
    }
#line 104
    goto while_break___3;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 107
  if (m___0->verbosity > 0) {
    {
#line 108
    report((char *)"Stored patterns: %d ", (m___0->xxh)->pat);
    }
  }
#line 110
  i___3 = 0;
  {
#line 110
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 110
    if (! (i___3 < (m___0->xxh)->pat)) {
#line 110
      goto while_break___4;
    }
    {
#line 111
    while (1) {
      while_continue___5: /* CIL Label */ ;
      {
#line 111
      tmp___3 = calloc((size_t )1, (size_t )(sizeof(struct xxm_pattern ) + sizeof(struct xxm_trackinfo ) * (unsigned long )((m___0->xxh)->chn - 1)));
#line 111
      *(m___0->xxp + i___3) = (struct xxm_pattern *)tmp___3;
      }
#line 111
      goto while_break___5;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 112
    (*(m___0->xxp + i___3))->rows = 64;
    {
#line 113
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 113
      j___0 = 0;
      {
#line 113
      while (1) {
        while_continue___7: /* CIL Label */ ;
#line 113
        if (! (j___0 < (m___0->xxh)->chn)) {
#line 113
          goto while_break___7;
        }
        {
#line 113
        (*(m___0->xxp + i___3))->info[j___0].index = i___3 * (m___0->xxh)->chn + j___0;
#line 113
        tmp___4 = calloc((size_t )(sizeof(struct xxm_track ) + sizeof(struct xxm_event ) * (unsigned long )(*(m___0->xxp + i___3))->rows),
                         (size_t )1);
#line 113
        *(m___0->xxt + (i___3 * (m___0->xxh)->chn + j___0)) = (struct xxm_track *)tmp___4;
#line 113
        (*(m___0->xxt + (i___3 * (m___0->xxh)->chn + j___0)))->rows = (*(m___0->xxp + i___3))->rows;
#line 113
        j___0 ++;
        }
      }
      while_break___7: /* CIL Label */ ;
      }
#line 113
      goto while_break___6;
    }
    while_break___6: /* CIL Label */ ;
    }
    {
#line 115
    fseek(f, (long )(((uint32 )start + sh.pataddr[i___3]) + 8U), 0);
#line 117
    j = 0;
    }
    {
#line 117
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 117
      if (! (j < 4)) {
#line 117
        goto while_break___8;
      }
#line 118
      k = 0;
      {
#line 118
      while (1) {
        while_continue___9: /* CIL Label */ ;
#line 118
        if (! (k < 64)) {
#line 118
          goto while_break___9;
        }
        {
#line 119
        event = & (*(m___0->xxt + (*(m___0->xxp + i___3))->info[j].index))->event[k];
#line 120
        b1 = read8(f);
        }
#line 122
        if ((int )b1 & 128) {
#line 123
          k += (int )b1 & 127;
#line 124
          goto __Cont;
        }
        {
#line 140
        b2 = read8(f);
#line 141
        b3 = read8(f);
#line 143
        tmp___5 = (uint8 )((int )b2 & 63);
#line 143
        event->note = tmp___5;
        }
#line 143
        if ((int )tmp___5 != 0) {
#line 144
          event->note = (uint8 )((int )event->note + 35);
        }
        {
#line 145
        event->ins = (uint8 )((int )b1 & 31);
#line 146
        event->fxt = (uint8 )((((int )b2 >> 4) & 12) | ((int )b1 >> 5));
#line 147
        event->fxp = b3;
#line 149
        disable_continue_fx(event);
        }
        __Cont: /* CIL Label */ 
#line 118
        k ++;
      }
      while_break___9: /* CIL Label */ ;
      }
#line 117
      j ++;
    }
    while_break___8: /* CIL Label */ ;
    }
#line 153
    if (m___0->verbosity > 0) {
      {
#line 154
      report((char *)".");
      }
    }
#line 110
    i___3 ++;
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 157
  while (1) {
    while_continue___10: /* CIL Label */ ;
    {
#line 157
    tmp___6 = calloc((size_t )sizeof(struct xxm_instrument_header ), (size_t )(m___0->xxh)->ins);
#line 157
    m___0->xxih = (struct xxm_instrument_header *)tmp___6;
#line 157
    tmp___7 = calloc((size_t )sizeof(struct xxm_instrument_map ), (size_t )(m___0->xxh)->ins);
#line 157
    m___0->xxim = (struct xxm_instrument_map *)tmp___7;
#line 157
    tmp___8 = calloc((size_t )sizeof(struct xxm_instrument *), (size_t )(m___0->xxh)->ins);
#line 157
    m___0->xxi = (struct xxm_instrument **)tmp___8;
    }
#line 157
    if ((m___0->xxh)->smp) {
      {
#line 157
      tmp___9 = calloc((size_t )sizeof(struct xxm_sample ), (size_t )(m___0->xxh)->smp);
#line 157
      m___0->xxs = (struct xxm_sample *)tmp___9;
      }
    }
    {
#line 157
    tmp___10 = calloc((size_t )sizeof(uint16 *), (size_t )(m___0->xxh)->ins);
#line 157
    m___0->xxae = (uint16 **)tmp___10;
#line 157
    tmp___11 = calloc((size_t )sizeof(uint16 *), (size_t )(m___0->xxh)->ins);
#line 157
    m___0->xxpe = (uint16 **)tmp___11;
#line 157
    tmp___12 = calloc((size_t )sizeof(uint16 *), (size_t )(m___0->xxh)->ins);
#line 157
    m___0->xxfe = (uint16 **)tmp___12;
    }
#line 157
    goto while_break___10;
  }
  while_break___10: /* CIL Label */ ;
  }
#line 159
  if (m___0->verbosity > 0) {
    {
#line 160
    report((char *)"\nStored samples : %d ", (m___0->xxh)->smp);
    }
  }
  {
#line 162
  fseek(f, (long )(((uint32 )start + sh.smpaddr) + (uint32 )((m___0->xxh)->smp * 4)),
        0);
#line 164
  i___3 = 0;
  }
  {
#line 164
  while (1) {
    while_continue___11: /* CIL Label */ ;
#line 164
    if (! (i___3 < (m___0->xxh)->smp)) {
#line 164
      goto while_break___11;
    }
    {
#line 165
    si___0.size = read16b(f);
#line 166
    si___0.finetune = read8(f);
#line 167
    si___0.volume = read8(f);
#line 168
    si___0.loop_start = read16b(f);
#line 169
    si___0.loop_size = read16b(f);
#line 171
    tmp___13 = calloc((size_t )sizeof(struct xxm_instrument ), (size_t )1);
#line 171
    *(m___0->xxi + i___3) = (struct xxm_instrument *)tmp___13;
#line 172
    (m___0->xxs + i___3)->len = 2 * (int )si___0.size;
#line 173
    (m___0->xxs + i___3)->lps = 2 * (int )si___0.loop_start;
#line 174
    (m___0->xxs + i___3)->lpe = (m___0->xxs + i___3)->lps + 2 * (int )si___0.loop_size;
    }
#line 175
    if ((int )si___0.loop_size > 1) {
#line 175
      (m___0->xxs + i___3)->flg = 4;
    } else {
#line 175
      (m___0->xxs + i___3)->flg = 0;
    }
#line 176
    (*(m___0->xxi + i___3) + 0)->fin = (int )((int8 )((int )si___0.finetune << 4));
#line 177
    (*(m___0->xxi + i___3) + 0)->vol = (int )si___0.volume;
#line 178
    (*(m___0->xxi + i___3) + 0)->pan = 128;
#line 179
    (*(m___0->xxi + i___3) + 0)->sid = i___3;
#line 180
    (m___0->xxih + i___3)->nsm = ! (! (m___0->xxs + i___3)->len);
#line 181
    (m___0->xxih + i___3)->rls = 4095;
#line 183
    if (m___0->verbosity > 1) {
#line 183
      if ((m___0->xxs + i___3)->len > 2) {
#line 184
        if ((int )si___0.loop_size > 1) {
#line 184
          tmp___14 = 'L';
        } else {
#line 184
          tmp___14 = ' ';
        }
        {
#line 184
        report((char *)"\n[%2X] %04x %04x %04x %c V%02x %+d ", i___3, (m___0->xxs + i___3)->len,
               (m___0->xxs + i___3)->lps, (m___0->xxs + i___3)->lpe, tmp___14, (*(m___0->xxi + i___3) + 0)->vol,
               (*(m___0->xxi + i___3) + 0)->fin >> 4);
        }
      }
    }
#line 190
    if (! (m___0->xxs + i___3)->len) {
#line 191
      goto __Cont___0;
    }
    {
#line 192
    xmp_drv_loadpatch(ctx___0, f, (*(m___0->xxi + i___3) + 0)->sid, m___0->c4rate,
                      0, m___0->xxs + (*(m___0->xxi + i___3) + 0)->sid, (char *)((void *)0));
    }
#line 194
    if (m___0->verbosity > 0) {
      {
#line 195
      report((char *)".");
      }
    }
    __Cont___0: /* CIL Label */ 
#line 164
    i___3 ++;
  }
  while_break___11: /* CIL Label */ ;
  }
#line 198
  if (m___0->verbosity > 0) {
    {
#line 199
    report((char *)"\n");
    }
  }
#line 201
  (m___0->xxh)->flg |= 2;
#line 203
  return (0);
}
}
#line 19 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/psm_load.c"
static int psm_test(FILE *f , char *t , int const   start ) ;
#line 20
static int psm_load(struct xmp_context *ctx___0 , FILE *f , int const   start ) ;
#line 22 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/psm_load.c"
struct xmp_loader_info psm_loader  =    {(char *)"PSM", (char *)"Protracker Studio", & psm_test, & psm_load, 0, {(struct list_head *)0,
                                                                            (struct list_head *)0}};
#line 29 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/psm_load.c"
static int psm_test(FILE *f , char *t , int const   start ) 
{ 
  uint32 tmp ;

  {
  {
#line 31
  tmp = read32b(f);
  }
#line 31
  if (tmp != ((((80U << 24) | (83U << 16)) | (77U << 8)) | 254U)) {
#line 32
    return (-1);
  }
  {
#line 34
  read_title(f, t, 60);
  }
#line 36
  return (0);
}
}
#line 42 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/psm_load.c"
static int psm_load(struct xmp_context *ctx___0 , FILE *f , int const   start ) 
{ 
  struct xmp_player_context *p ;
  struct xmp_mod_context *m___0 ;
  int c___0 ;
  int r ;
  int i___3 ;
  struct xxm_event *event ;
  uint8 buf___1[1024] ;
  uint32 p_ord ;
  uint32 p_chn ;
  uint32 p_pat ;
  uint32 p_ins ;
  uint32 p_smp[64] ;
  int type ;
  int ver___0 ;
  int mode___1 ;
  uint8 **tmp ;
  uint8 tmp___0 ;
  uint8 tmp___1 ;
  uint8 tmp___2 ;
  uint8 tmp___3 ;
  uint8 tmp___4 ;
  uint16 tmp___5 ;
  uint16 tmp___6 ;
  uint16 tmp___7 ;
  uint16 tmp___8 ;
  void *tmp___9 ;
  void *tmp___10 ;
  void *tmp___11 ;
  void *tmp___12 ;
  void *tmp___13 ;
  void *tmp___14 ;
  void *tmp___15 ;
  uint16 flags ;
  uint16 c2spd___0 ;
  int finetune ;
  void *tmp___16 ;
  uint8 tmp___17 ;
  uint32 tmp___18 ;
  uint32 tmp___19 ;
  uint32 tmp___20 ;
  uint8 tmp___21 ;
  uint8 tmp___22 ;
  uint16 tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  size_t tmp___26 ;
  void *tmp___27 ;
  void *tmp___28 ;
  int len ;
  uint8 b___1 ;
  uint8 rows___1 ;
  uint8 chan ;
  uint16 tmp___29 ;
  void *tmp___30 ;
  int j ;
  void *tmp___31 ;
  uint8 tmp___32 ;
  uint8 tmp___33 ;
  void *__cil_tmp62 ;
  void *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;
  char *__cil_tmp66 ;
  char *__cil_tmp67 ;
  char *__cil_tmp68 ;
  char *__cil_tmp69 ;
  char *__cil_tmp70 ;
  char *__cil_tmp71 ;
  char *__cil_tmp72 ;
  char *__cil_tmp73 ;
  char *__cil_tmp74 ;
  char *__cil_tmp75 ;
  char *__cil_tmp76 ;

  {
#line 44
  p = & ctx___0->p;
#line 45
  m___0 = & p->m;
  {
#line 53
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 53
    fseek(f, (long )start, 0);
#line 53
    tmp = (uint8 **)((void *)0);
#line 53
    m___0->med_wav_table = tmp;
#line 53
    m___0->med_vol_table = tmp;
#line 53
    set_xxh_defaults(m___0->xxh);
    }
#line 53
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 55
  read32b(f);
#line 57
  fread((void */* __restrict  */)(buf___1), (size_t )1, (size_t )60, (FILE */* __restrict  */)f);
#line 58
  strncpy((char */* __restrict  */)(m___0->name), (char const   */* __restrict  */)((char *)(buf___1)),
          (size_t )64);
#line 60
  tmp___0 = read8(f);
#line 60
  type = (int )tmp___0;
#line 61
  tmp___1 = read8(f);
#line 61
  ver___0 = (int )tmp___1;
#line 62
  tmp___2 = read8(f);
#line 62
  mode___1 = (int )tmp___2;
  }
#line 64
  if (type & 1) {
#line 65
    return (-1);
  }
  {
#line 67
  sprintf((char */* __restrict  */)(m___0->type), (char const   */* __restrict  */)"PSM %d.%02d (Protracker Studio)",
          (ver___0 & 240) >> 4, ver___0 & 15);
#line 70
  tmp___3 = read8(f);
#line 70
  (m___0->xxh)->tpo = (int )tmp___3;
#line 71
  tmp___4 = read8(f);
#line 71
  (m___0->xxh)->bpm = (int )tmp___4;
#line 72
  read8(f);
#line 73
  read16l(f);
#line 74
  tmp___5 = read16l(f);
#line 74
  (m___0->xxh)->len = (int )tmp___5;
#line 75
  tmp___6 = read16l(f);
#line 75
  (m___0->xxh)->pat = (int )tmp___6;
#line 76
  tmp___7 = read16l(f);
#line 76
  (m___0->xxh)->ins = (int )tmp___7;
#line 77
  tmp___8 = read16l(f);
#line 77
  (m___0->xxh)->chn = (int )tmp___8;
#line 78
  read16l(f);
#line 79
  (m___0->xxh)->smp = (m___0->xxh)->ins;
#line 80
  (m___0->xxh)->trk = (m___0->xxh)->pat * (m___0->xxh)->chn;
#line 82
  p_ord = read32l(f);
#line 83
  p_chn = read32l(f);
#line 84
  p_pat = read32l(f);
#line 85
  p_ins = read32l(f);
  }
  {
#line 90
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 90
    if (m___0->verbosity) {
#line 90
      if (m___0->name[0]) {
        {
#line 90
        report((char *)"Module title   : %s\n", m___0->name);
        }
      }
#line 90
      if (m___0->type[0]) {
        {
#line 90
        report((char *)"Module type    : %s\n", m___0->type);
        }
      }
#line 90
      if (m___0->author[0]) {
        {
#line 90
        report((char *)"Author name    : %s\n", m___0->author);
        }
      }
#line 90
      if ((m___0->xxh)->len) {
        {
#line 90
        report((char *)"Module length  : %d patterns\n", (m___0->xxh)->len);
        }
      }
    }
#line 90
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 92
  fseek(f, (long )((uint32 )start + p_ord), 0);
#line 93
  fread((void */* __restrict  */)(m___0->xxo), (size_t )1, (size_t )(m___0->xxh)->len,
        (FILE */* __restrict  */)f);
#line 95
  fseek(f, (long )((uint32 )start + p_chn), 0);
#line 96
  fread((void */* __restrict  */)(buf___1), (size_t )1, (size_t )16, (FILE */* __restrict  */)f);
  }
  {
#line 98
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 98
    tmp___9 = calloc((size_t )sizeof(struct xxm_instrument_header ), (size_t )(m___0->xxh)->ins);
#line 98
    m___0->xxih = (struct xxm_instrument_header *)tmp___9;
#line 98
    tmp___10 = calloc((size_t )sizeof(struct xxm_instrument_map ), (size_t )(m___0->xxh)->ins);
#line 98
    m___0->xxim = (struct xxm_instrument_map *)tmp___10;
#line 98
    tmp___11 = calloc((size_t )sizeof(struct xxm_instrument *), (size_t )(m___0->xxh)->ins);
#line 98
    m___0->xxi = (struct xxm_instrument **)tmp___11;
    }
#line 98
    if ((m___0->xxh)->smp) {
      {
#line 98
      tmp___12 = calloc((size_t )sizeof(struct xxm_sample ), (size_t )(m___0->xxh)->smp);
#line 98
      m___0->xxs = (struct xxm_sample *)tmp___12;
      }
    }
    {
#line 98
    tmp___13 = calloc((size_t )sizeof(uint16 *), (size_t )(m___0->xxh)->ins);
#line 98
    m___0->xxae = (uint16 **)tmp___13;
#line 98
    tmp___14 = calloc((size_t )sizeof(uint16 *), (size_t )(m___0->xxh)->ins);
#line 98
    m___0->xxpe = (uint16 **)tmp___14;
#line 98
    tmp___15 = calloc((size_t )sizeof(uint16 *), (size_t )(m___0->xxh)->ins);
#line 98
    m___0->xxfe = (uint16 **)tmp___15;
    }
#line 98
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 100
  reportv(ctx___0, 1, (char *)"     Sample name           Len   LBeg LEnd L Vol C2Spd\n");
#line 102
  fseek(f, (long )((uint32 )start + p_ins), 0);
#line 103
  i___3 = 0;
  }
  {
#line 103
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 103
    if (! (i___3 < (m___0->xxh)->ins)) {
#line 103
      goto while_break___2;
    }
    {
#line 107
    tmp___16 = calloc((size_t )sizeof(struct xxm_instrument ), (size_t )1);
#line 107
    *(m___0->xxi + i___3) = (struct xxm_instrument *)tmp___16;
#line 109
    fread((void */* __restrict  */)(buf___1), (size_t )1, (size_t )13, (FILE */* __restrict  */)f);
#line 110
    fread((void */* __restrict  */)(buf___1), (size_t )1, (size_t )24, (FILE */* __restrict  */)f);
#line 111
    strncpy((char */* __restrict  */)((char *)((m___0->xxih + i___3)->name)), (char const   */* __restrict  */)((char *)(buf___1)),
            (size_t )24);
#line 112
    str_adj((char *)((m___0->xxih + i___3)->name));
#line 113
    p_smp[i___3] = read32l(f);
#line 114
    read32l(f);
#line 115
    read16l(f);
#line 116
    tmp___17 = read8(f);
#line 116
    flags = (uint16 )tmp___17;
#line 117
    tmp___18 = read32l(f);
#line 117
    (m___0->xxs + i___3)->len = (int )tmp___18;
#line 118
    tmp___19 = read32l(f);
#line 118
    (m___0->xxs + i___3)->lps = (int )tmp___19;
#line 119
    tmp___20 = read32l(f);
#line 119
    (m___0->xxs + i___3)->lpe = (int )tmp___20;
#line 120
    tmp___21 = read8(f);
#line 120
    finetune = (int )((int8 )((int )tmp___21 << 4));
#line 121
    tmp___22 = read8(f);
#line 121
    (*(m___0->xxi + i___3) + 0)->vol = (int )tmp___22;
#line 122
    tmp___23 = read16l(f);
#line 122
    c2spd___0 = (uint16 )((8363 * (int )tmp___23) / 8448);
#line 123
    (*(m___0->xxi + i___3) + 0)->pan = 128;
#line 124
    (*(m___0->xxi + i___3) + 0)->sid = i___3;
#line 125
    (m___0->xxih + i___3)->nsm = ! (! (m___0->xxs + i___3)->len);
    }
#line 126
    if ((int )flags & 128) {
#line 126
      (m___0->xxs + i___3)->flg = 4;
    } else {
#line 126
      (m___0->xxs + i___3)->flg = 0;
    }
#line 127
    if ((int )flags & 32) {
#line 127
      tmp___24 = 8;
    } else {
#line 127
      tmp___24 = 0;
    }
    {
#line 127
    (m___0->xxs + i___3)->flg |= tmp___24;
#line 128
    c2spd_to_note((int )c2spd___0, & (*(m___0->xxi + i___3) + 0)->xpo, & (*(m___0->xxi + i___3) + 0)->fin);
#line 129
    (*(m___0->xxi + i___3) + 0)->fin += finetune;
    }
#line 131
    if (m___0->verbosity > 1) {
      {
#line 131
      tmp___26 = strlen((char const   *)((char *)((m___0->xxih + i___3)->name)));
      }
#line 131
      if (tmp___26) {
#line 131
        goto _L;
      } else
#line 131
      if ((m___0->xxs + i___3)->len > 1) {
        _L: /* CIL Label */ 
#line 132
        if ((m___0->xxs + i___3)->flg & 4) {
#line 132
          tmp___25 = 'L';
        } else {
#line 132
          tmp___25 = ' ';
        }
        {
#line 132
        report((char *)"[%2X] %-22.22s %04x %04x %04x %c V%02x %5d\n", i___3, (m___0->xxih + i___3)->name,
               (m___0->xxs + i___3)->len, (m___0->xxs + i___3)->lps, (m___0->xxs + i___3)->lpe,
               tmp___25, (*(m___0->xxi + i___3) + 0)->vol, (int )c2spd___0);
        }
      }
    }
#line 103
    i___3 ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 140
  while (1) {
    while_continue___3: /* CIL Label */ ;
    {
#line 140
    tmp___27 = calloc((size_t )sizeof(struct xxm_track *), (size_t )(m___0->xxh)->trk);
#line 140
    m___0->xxt = (struct xxm_track **)tmp___27;
#line 140
    tmp___28 = calloc((size_t )sizeof(struct xxm_pattern *), (size_t )((m___0->xxh)->pat + 1));
#line 140
    m___0->xxp = (struct xxm_pattern **)tmp___28;
    }
#line 140
    goto while_break___3;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 142
  reportv(ctx___0, 0, (char *)"Stored patterns: %d ", (m___0->xxh)->pat);
#line 144
  fseek(f, (long )((uint32 )start + p_pat), 0);
#line 145
  i___3 = 0;
  }
  {
#line 145
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 145
    if (! (i___3 < (m___0->xxh)->pat)) {
#line 145
      goto while_break___4;
    }
    {
#line 149
    tmp___29 = read16l(f);
#line 149
    len = (int )tmp___29 - 4;
#line 150
    rows___1 = read8(f);
#line 151
    chan = read8(f);
    }
    {
#line 153
    while (1) {
      while_continue___5: /* CIL Label */ ;
      {
#line 153
      tmp___30 = calloc((size_t )1, (size_t )(sizeof(struct xxm_pattern ) + sizeof(struct xxm_trackinfo ) * (unsigned long )((m___0->xxh)->chn - 1)));
#line 153
      *(m___0->xxp + i___3) = (struct xxm_pattern *)tmp___30;
      }
#line 153
      goto while_break___5;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 154
    (*(m___0->xxp + i___3))->rows = (int )rows___1;
    {
#line 155
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 155
      j = 0;
      {
#line 155
      while (1) {
        while_continue___7: /* CIL Label */ ;
#line 155
        if (! (j < (m___0->xxh)->chn)) {
#line 155
          goto while_break___7;
        }
        {
#line 155
        (*(m___0->xxp + i___3))->info[j].index = i___3 * (m___0->xxh)->chn + j;
#line 155
        tmp___31 = calloc((size_t )(sizeof(struct xxm_track ) + sizeof(struct xxm_event ) * (unsigned long )(*(m___0->xxp + i___3))->rows),
                          (size_t )1);
#line 155
        *(m___0->xxt + (i___3 * (m___0->xxh)->chn + j)) = (struct xxm_track *)tmp___31;
#line 155
        (*(m___0->xxt + (i___3 * (m___0->xxh)->chn + j)))->rows = (*(m___0->xxp + i___3))->rows;
#line 155
        j ++;
        }
      }
      while_break___7: /* CIL Label */ ;
      }
#line 155
      goto while_break___6;
    }
    while_break___6: /* CIL Label */ ;
    }
#line 157
    r = 0;
    {
#line 157
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 157
      if (! (r < (int )rows___1)) {
#line 157
        goto while_break___8;
      }
      {
#line 158
      while (1) {
        while_continue___9: /* CIL Label */ ;
#line 158
        if (! (len > 0)) {
#line 158
          goto while_break___9;
        }
        {
#line 159
        b___1 = read8(f);
#line 160
        len --;
        }
#line 162
        if ((int )b___1 == 0) {
#line 163
          goto while_break___9;
        }
#line 165
        c___0 = (int )b___1 & 15;
#line 166
        event = & (*(m___0->xxt + (*(m___0->xxp + i___3))->info[c___0].index))->event[r];
#line 168
        if ((int )b___1 & 128) {
          {
#line 169
          tmp___32 = read8(f);
#line 169
          event->note = (uint8 )(((int )tmp___32 + 24) + 1);
#line 170
          event->ins = read8(f);
#line 171
          len -= 2;
          }
        }
#line 174
        if ((int )b___1 & 64) {
          {
#line 175
          tmp___33 = read8(f);
#line 175
          event->vol = (uint8 )((int )tmp___33 + 1);
#line 176
          len --;
          }
        }
#line 179
        if ((int )b___1 & 32) {
          {
#line 180
          event->fxt = read8(f);
#line 181
          event->fxp = read8(f);
#line 182
          len -= 2;
          }
        }
      }
      while_break___9: /* CIL Label */ ;
      }
#line 157
      r ++;
    }
    while_break___8: /* CIL Label */ ;
    }
#line 188
    if (len > 0) {
      {
#line 189
      fseek(f, (long )len, 1);
      }
    }
    {
#line 191
    reportv(ctx___0, 0, (char *)".");
#line 145
    i___3 ++;
    }
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 193
  reportv(ctx___0, 0, (char *)"\n");
#line 197
  reportv(ctx___0, 0, (char *)"Stored samples : %d ", (m___0->xxh)->smp);
#line 199
  i___3 = 0;
  }
  {
#line 199
  while (1) {
    while_continue___10: /* CIL Label */ ;
#line 199
    if (! (i___3 < (m___0->xxh)->ins)) {
#line 199
      goto while_break___10;
    }
    {
#line 200
    fseek(f, (long )((uint32 )start + p_smp[i___3]), 0);
#line 201
    xmp_drv_loadpatch(ctx___0, f, (*(m___0->xxi + i___3) + 0)->sid, m___0->c4rate,
                      1, m___0->xxs + (*(m___0->xxi + i___3) + 0)->sid, (char *)((void *)0));
#line 203
    reportv(ctx___0, 0, (char *)".");
#line 199
    i___3 ++;
    }
  }
  while_break___10: /* CIL Label */ ;
  }
  {
#line 205
  reportv(ctx___0, 0, (char *)"\n");
  }
#line 207
  return (0);
}
}
#line 25 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/amf_load.c"
static int amf_test(FILE *f , char *t , int const   start ) ;
#line 26
static int amf_load(struct xmp_context *ctx___0 , FILE *f , int const   start ) ;
#line 28 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/amf_load.c"
struct xmp_loader_info amf_loader  =    {(char *)"AMF", (char *)"DSMI Advanced Module Format", & amf_test, & amf_load,
    0, {(struct list_head *)0, (struct list_head *)0}};
#line 35 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/amf_load.c"
static int amf_test(FILE *f , char *t , int const   start ) 
{ 
  char buf___1[4] ;
  int ver___0 ;
  uint8 tmp ;
  void *__cil_tmp7 ;

  {
  {
#line 40
  fread((void */* __restrict  */)(buf___1), (size_t )1, (size_t )3, (FILE */* __restrict  */)f);
  }
#line 41
  if ((int )buf___1[0] != 65) {
#line 42
    return (-1);
  } else
#line 41
  if ((int )buf___1[1] != 77) {
#line 42
    return (-1);
  } else
#line 41
  if ((int )buf___1[2] != 70) {
#line 42
    return (-1);
  }
  {
#line 44
  tmp = read8(f);
#line 44
  ver___0 = (int )tmp;
  }
#line 45
  if (ver___0 < 10) {
#line 46
    return (-1);
  } else
#line 45
  if (ver___0 > 14) {
#line 46
    return (-1);
  }
  {
#line 48
  read_title(f, t, 32);
  }
#line 50
  return (0);
}
}
#line 54 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/amf_load.c"
static int amf_load(struct xmp_context *ctx___0 , FILE *f , int const   start ) 
{ 
  struct xmp_player_context *p ;
  struct xmp_mod_context *m___0 ;
  int i___3 ;
  int j ;
  struct xxm_event *event ;
  uint8 buf___1[1024] ;
  int *trkmap ;
  int newtrk ;
  int ver___0 ;
  uint8 **tmp ;
  uint8 tmp___0 ;
  uint8 tmp___1 ;
  uint8 tmp___2 ;
  uint16 tmp___3 ;
  uint8 tmp___4 ;
  uint8 tmp___5 ;
  uint8 tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  uint16 tmp___9 ;
  uint16 t ;
  uint16 tmp___10 ;
  void *tmp___11 ;
  void *tmp___12 ;
  void *tmp___13 ;
  void *tmp___14 ;
  void *tmp___15 ;
  void *tmp___16 ;
  void *tmp___17 ;
  uint8 b___1 ;
  int c2spd___0 ;
  void *tmp___18 ;
  uint32 tmp___19 ;
  uint16 tmp___20 ;
  uint8 tmp___21 ;
  uint16 tmp___22 ;
  uint32 tmp___23 ;
  uint32 tmp___24 ;
  int tmp___25 ;
  size_t tmp___26 ;
  void *tmp___27 ;
  uint16 t___0 ;
  int k ;
  void *tmp___28 ;
  uint8 t1 ;
  uint8 t2 ;
  uint8 t3 ;
  int size___0 ;
  void *tmp___29 ;
  uint32 tmp___30 ;
  uint8 fxp ;
  uint8 fxt ;
  void *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;
  char *__cil_tmp66 ;
  char *__cil_tmp67 ;
  char *__cil_tmp68 ;
  char *__cil_tmp69 ;
  char *__cil_tmp70 ;
  char *__cil_tmp71 ;
  char *__cil_tmp72 ;

  {
#line 56
  p = & ctx___0->p;
#line 57
  m___0 = & p->m;
  {
#line 64
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 64
    fseek(f, (long )start, 0);
#line 64
    tmp = (uint8 **)((void *)0);
#line 64
    m___0->med_wav_table = tmp;
#line 64
    m___0->med_vol_table = tmp;
#line 64
    set_xxh_defaults(m___0->xxh);
    }
#line 64
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 66
  fread((void */* __restrict  */)(buf___1), (size_t )1, (size_t )3, (FILE */* __restrict  */)f);
#line 67
  tmp___0 = read8(f);
#line 67
  ver___0 = (int )tmp___0;
#line 69
  fread((void */* __restrict  */)(buf___1), (size_t )1, (size_t )32, (FILE */* __restrict  */)f);
#line 70
  strncpy((char */* __restrict  */)(m___0->name), (char const   */* __restrict  */)((char *)(buf___1)),
          (size_t )32);
#line 71
  sprintf((char */* __restrict  */)(m___0->type), (char const   */* __restrict  */)"DSMI %d.%d",
          ver___0 / 10, ver___0 % 10);
#line 73
  tmp___1 = read8(f);
#line 73
  (m___0->xxh)->ins = (int )tmp___1;
#line 74
  tmp___2 = read8(f);
#line 74
  (m___0->xxh)->len = (int )tmp___2;
#line 75
  tmp___3 = read16l(f);
#line 75
  (m___0->xxh)->trk = (int )tmp___3;
#line 76
  tmp___4 = read8(f);
#line 76
  (m___0->xxh)->chn = (int )tmp___4;
#line 78
  (m___0->xxh)->smp = (m___0->xxh)->ins;
#line 79
  (m___0->xxh)->pat = (m___0->xxh)->len;
  }
#line 81
  if (ver___0 == 10) {
    {
#line 82
    fread((void */* __restrict  */)(buf___1), (size_t )1, (size_t )16, (FILE */* __restrict  */)f);
    }
  }
#line 84
  if (ver___0 >= 13) {
    {
#line 85
    fread((void */* __restrict  */)(buf___1), (size_t )1, (size_t )32, (FILE */* __restrict  */)f);
#line 86
    i___3 = 0;
    }
    {
#line 86
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 86
      if (! (i___3 < 32)) {
#line 86
        goto while_break___0;
      }
#line 87
      m___0->xxc[0].pan = 128 + 2 * (int )((int8 )buf___1[i___3]);
#line 86
      i___3 ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 89
    tmp___5 = read8(f);
#line 89
    (m___0->xxh)->bpm = (int )tmp___5;
#line 90
    tmp___6 = read8(f);
#line 90
    (m___0->xxh)->tpo = (int )tmp___6;
    }
  } else
#line 91
  if (ver___0 >= 11) {
    {
#line 92
    fread((void */* __restrict  */)(buf___1), (size_t )1, (size_t )16, (FILE */* __restrict  */)f);
    }
  }
  {
#line 95
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 95
    if (m___0->verbosity) {
#line 95
      if (m___0->name[0]) {
        {
#line 95
        report((char *)"Module title   : %s\n", m___0->name);
        }
      }
#line 95
      if (m___0->type[0]) {
        {
#line 95
        report((char *)"Module type    : %s\n", m___0->type);
        }
      }
#line 95
      if (m___0->author[0]) {
        {
#line 95
        report((char *)"Author name    : %s\n", m___0->author);
        }
      }
#line 95
      if ((m___0->xxh)->len) {
        {
#line 95
        report((char *)"Module length  : %d patterns\n", (m___0->xxh)->len);
        }
      }
    }
#line 95
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 100
  i___3 = 0;
  {
#line 100
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 100
    if (! (i___3 < (m___0->xxh)->len)) {
#line 100
      goto while_break___2;
    }
#line 101
    m___0->xxo[i___3] = (uint8 )i___3;
#line 100
    i___3 ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 103
  reportv(ctx___0, 0, (char *)"Stored patterns: %d ", (m___0->xxh)->pat);
#line 105
  tmp___7 = calloc((size_t )sizeof(struct xxm_pattern *), (size_t )((m___0->xxh)->pat + 1));
#line 105
  m___0->xxp = (struct xxm_pattern **)tmp___7;
#line 107
  i___3 = 0;
  }
  {
#line 107
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 107
    if (! (i___3 < (m___0->xxh)->pat)) {
#line 107
      goto while_break___3;
    }
    {
#line 108
    while (1) {
      while_continue___4: /* CIL Label */ ;
      {
#line 108
      tmp___8 = calloc((size_t )1, (size_t )(sizeof(struct xxm_pattern ) + sizeof(struct xxm_trackinfo ) * (unsigned long )((m___0->xxh)->chn - 1)));
#line 108
      *(m___0->xxp + i___3) = (struct xxm_pattern *)tmp___8;
      }
#line 108
      goto while_break___4;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 109
    if (ver___0 >= 14) {
      {
#line 109
      tmp___9 = read16l(f);
#line 109
      (*(m___0->xxp + i___3))->rows = (int )tmp___9;
      }
    } else {
#line 109
      (*(m___0->xxp + i___3))->rows = 64;
    }
#line 110
    j = 0;
    {
#line 110
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 110
      if (! (j < (m___0->xxh)->chn)) {
#line 110
        goto while_break___5;
      }
      {
#line 111
      tmp___10 = read16l(f);
#line 111
      t = tmp___10;
#line 112
      (*(m___0->xxp + i___3))->info[j].index = (int )t;
#line 110
      j ++;
      }
    }
    while_break___5: /* CIL Label */ ;
    }
    {
#line 114
    reportv(ctx___0, 0, (char *)".");
#line 107
    i___3 ++;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 116
  reportv(ctx___0, 0, (char *)"\n");
  }
  {
#line 121
  while (1) {
    while_continue___6: /* CIL Label */ ;
    {
#line 121
    tmp___11 = calloc((size_t )sizeof(struct xxm_instrument_header ), (size_t )(m___0->xxh)->ins);
#line 121
    m___0->xxih = (struct xxm_instrument_header *)tmp___11;
#line 121
    tmp___12 = calloc((size_t )sizeof(struct xxm_instrument_map ), (size_t )(m___0->xxh)->ins);
#line 121
    m___0->xxim = (struct xxm_instrument_map *)tmp___12;
#line 121
    tmp___13 = calloc((size_t )sizeof(struct xxm_instrument *), (size_t )(m___0->xxh)->ins);
#line 121
    m___0->xxi = (struct xxm_instrument **)tmp___13;
    }
#line 121
    if ((m___0->xxh)->smp) {
      {
#line 121
      tmp___14 = calloc((size_t )sizeof(struct xxm_sample ), (size_t )(m___0->xxh)->smp);
#line 121
      m___0->xxs = (struct xxm_sample *)tmp___14;
      }
    }
    {
#line 121
    tmp___15 = calloc((size_t )sizeof(uint16 *), (size_t )(m___0->xxh)->ins);
#line 121
    m___0->xxae = (uint16 **)tmp___15;
#line 121
    tmp___16 = calloc((size_t )sizeof(uint16 *), (size_t )(m___0->xxh)->ins);
#line 121
    m___0->xxpe = (uint16 **)tmp___16;
#line 121
    tmp___17 = calloc((size_t )sizeof(uint16 *), (size_t )(m___0->xxh)->ins);
#line 121
    m___0->xxfe = (uint16 **)tmp___17;
    }
#line 121
    goto while_break___6;
  }
  while_break___6: /* CIL Label */ ;
  }
#line 123
  if (m___0->verbosity > 1) {
    {
#line 124
    report((char *)"     Sample name                      Len   LBeg  LEnd  L Vol C2Spd\n");
    }
  }
#line 126
  i___3 = 0;
  {
#line 126
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 126
    if (! (i___3 < (m___0->xxh)->ins)) {
#line 126
      goto while_break___7;
    }
    {
#line 130
    tmp___18 = calloc((size_t )sizeof(struct xxm_instrument ), (size_t )1);
#line 130
    *(m___0->xxi + i___3) = (struct xxm_instrument *)tmp___18;
#line 132
    b___1 = read8(f);
    }
#line 133
    if (b___1) {
#line 133
      (m___0->xxih + i___3)->nsm = 1;
    } else {
#line 133
      (m___0->xxih + i___3)->nsm = 0;
    }
    {
#line 135
    fread((void */* __restrict  */)(buf___1), (size_t )1, (size_t )32, (FILE */* __restrict  */)f);
#line 136
    copy_adjust((m___0->xxih + i___3)->name, buf___1, 32);
#line 138
    fread((void */* __restrict  */)(buf___1), (size_t )1, (size_t )13, (FILE */* __restrict  */)f);
#line 139
    read32l(f);
#line 141
    (*(m___0->xxi + i___3) + 0)->sid = i___3;
#line 142
    (*(m___0->xxi + i___3) + 0)->pan = 128;
#line 143
    tmp___19 = read32l(f);
#line 143
    (m___0->xxs + i___3)->len = (int )tmp___19;
#line 144
    tmp___20 = read16l(f);
#line 144
    c2spd___0 = (int )tmp___20;
#line 145
    c2spd_to_note(c2spd___0, & (*(m___0->xxi + i___3) + 0)->xpo, & (*(m___0->xxi + i___3) + 0)->fin);
#line 146
    tmp___21 = read8(f);
#line 146
    (*(m___0->xxi + i___3) + 0)->vol = (int )tmp___21;
    }
#line 148
    if (ver___0 <= 10) {
      {
#line 149
      tmp___22 = read16l(f);
#line 149
      (m___0->xxs + i___3)->lps = (int )tmp___22;
#line 150
      (m___0->xxs + i___3)->lpe = (m___0->xxs + i___3)->len - 1;
      }
    } else {
      {
#line 152
      tmp___23 = read32l(f);
#line 152
      (m___0->xxs + i___3)->lps = (int )tmp___23;
#line 153
      tmp___24 = read32l(f);
#line 153
      (m___0->xxs + i___3)->lpe = (int )tmp___24;
      }
    }
#line 155
    if ((m___0->xxs + i___3)->lps > 0) {
#line 155
      (m___0->xxs + i___3)->flg = 4;
    } else {
#line 155
      (m___0->xxs + i___3)->flg = 0;
    }
#line 157
    if (m___0->verbosity > 1) {
      {
#line 157
      tmp___26 = strlen((char const   *)((char *)((m___0->xxih + i___3)->name)));
      }
#line 157
      if (tmp___26) {
#line 157
        goto _L;
      } else
#line 157
      if ((m___0->xxs + i___3)->len) {
        _L: /* CIL Label */ 
#line 158
        if ((m___0->xxs + i___3)->flg & 4) {
#line 158
          tmp___25 = 'L';
        } else {
#line 158
          tmp___25 = ' ';
        }
        {
#line 158
        report((char *)"[%2X] %-32.32s %05x %05x %05x %c V%02x %5d\n", i___3, (m___0->xxih + i___3)->name,
               (m___0->xxs + i___3)->len, (m___0->xxs + i___3)->lps, (m___0->xxs + i___3)->lpe,
               tmp___25, (*(m___0->xxi + i___3) + 0)->vol, c2spd___0);
        }
      }
    }
#line 126
    i___3 ++;
  }
  while_break___7: /* CIL Label */ ;
  }
  {
#line 168
  tmp___27 = calloc((size_t )sizeof(int ), (size_t )(m___0->xxh)->trk);
#line 168
  trkmap = (int *)tmp___27;
#line 169
  newtrk = 0;
#line 171
  i___3 = 0;
  }
  {
#line 171
  while (1) {
    while_continue___8: /* CIL Label */ ;
#line 171
    if (! (i___3 < (m___0->xxh)->trk)) {
#line 171
      goto while_break___8;
    }
    {
#line 173
    t___0 = read16l(f);
#line 174
    *(trkmap + i___3) = (int )t___0 - 1;
    }
#line 175
    if ((int )t___0 > newtrk) {
#line 175
      newtrk = (int )t___0;
    }
#line 171
    i___3 ++;
  }
  while_break___8: /* CIL Label */ ;
  }
#line 179
  i___3 = 0;
  {
#line 179
  while (1) {
    while_continue___9: /* CIL Label */ ;
#line 179
    if (! (i___3 < (m___0->xxh)->pat)) {
#line 179
      goto while_break___9;
    }
#line 180
    j = 0;
    {
#line 180
    while (1) {
      while_continue___10: /* CIL Label */ ;
#line 180
      if (! (j < (m___0->xxh)->chn)) {
#line 180
        goto while_break___10;
      }
#line 181
      k = (*(m___0->xxp + i___3))->info[j].index - 1;
#line 182
      if (k < 0) {
#line 183
        k = 0;
      }
#line 184
      (*(m___0->xxp + i___3))->info[j].index = *(trkmap + k);
#line 180
      j ++;
    }
    while_break___10: /* CIL Label */ ;
    }
#line 179
    i___3 ++;
  }
  while_break___9: /* CIL Label */ ;
  }
  {
#line 188
  (m___0->xxh)->trk = newtrk;
#line 189
  free((void *)trkmap);
#line 191
  reportv(ctx___0, 0, (char *)"Stored tracks  : %d ", (m___0->xxh)->trk);
#line 192
  tmp___28 = calloc((size_t )sizeof(struct xxm_track *), (size_t )(m___0->xxh)->trk);
#line 192
  m___0->xxt = (struct xxm_track **)tmp___28;
#line 194
  i___3 = 0;
  }
  {
#line 194
  while (1) {
    while_continue___11: /* CIL Label */ ;
#line 194
    if (! (i___3 < (m___0->xxh)->trk)) {
#line 194
      goto while_break___11;
    }
    {
#line 198
    tmp___29 = calloc((size_t )((sizeof(struct xxm_track ) + sizeof(struct xxm_event ) * 64UL) - 1UL),
                      (size_t )1);
#line 198
    *(m___0->xxt + i___3) = (struct xxm_track *)tmp___29;
#line 200
    (*(m___0->xxt + i___3))->rows = 64;
#line 202
    tmp___30 = read24l(f);
#line 202
    size___0 = (int )tmp___30;
#line 205
    j = 0;
    }
    {
#line 205
    while (1) {
      while_continue___12: /* CIL Label */ ;
#line 205
      if (! (j < size___0)) {
#line 205
        goto while_break___12;
      }
      {
#line 206
      t1 = read8(f);
#line 207
      t2 = read8(f);
#line 208
      t3 = read8(f);
      }
#line 211
      if ((int )t1 == 255) {
#line 211
        if ((int )t2 == 255) {
#line 211
          if ((int )t3 == 255) {
#line 212
            goto while_break___12;
          }
        }
      }
#line 214
      event = & (*(m___0->xxt + i___3))->event[t1];
#line 216
      if ((int )t2 < 127) {
#line 217
        if ((int )t2 > 12) {
#line 218
          event->note = (uint8 )(((int )t2 + 1) - 12);
        }
      } else
#line 219
      if ((int )t2 == 127) {
        {
#line 220
        memcpy((void */* __restrict  */)event, (void const   */* __restrict  */)(& (*(m___0->xxt + i___3))->event[(int )t1 - 1]),
               (size_t )sizeof(struct xxm_event ));
        }
      } else
#line 222
      if ((int )t2 == 128) {
#line 223
        event->ins = (uint8 )((int )t3 + 1);
      } else {
#line 227
        fxt = (uint8 )0;
#line 227
        fxp = fxt;
        {
#line 230
        if ((int )t2 == 129) {
#line 230
          goto case_129;
        }
#line 234
        if ((int )t2 == 130) {
#line 234
          goto case_130;
        }
#line 248
        if ((int )t2 == 131) {
#line 248
          goto case_131;
        }
#line 251
        if ((int )t2 == 132) {
#line 251
          goto case_132;
        }
#line 260
        if ((int )t2 == 133) {
#line 260
          goto case_133;
        }
#line 263
        if ((int )t2 == 134) {
#line 263
          goto case_134;
        }
#line 267
        if ((int )t2 == 135) {
#line 267
          goto case_135;
        }
#line 271
        if ((int )t2 == 136) {
#line 271
          goto case_136;
        }
#line 275
        if ((int )t2 == 137) {
#line 275
          goto case_137;
        }
#line 279
        if ((int )t2 == 138) {
#line 279
          goto case_138;
        }
#line 288
        if ((int )t2 == 139) {
#line 288
          goto case_139;
        }
#line 297
        if ((int )t2 == 140) {
#line 297
          goto case_140;
        }
#line 301
        if ((int )t2 == 141) {
#line 301
          goto case_141;
        }
#line 305
        if ((int )t2 == 142) {
#line 305
          goto case_142;
        }
#line 308
        if ((int )t2 == 143) {
#line 308
          goto case_143;
        }
#line 312
        if ((int )t2 == 144) {
#line 312
          goto case_144;
        }
#line 316
        if ((int )t2 == 145) {
#line 316
          goto case_145;
        }
#line 327
        if ((int )t2 == 146) {
#line 327
          goto case_146;
        }
#line 336
        if ((int )t2 == 147) {
#line 336
          goto case_147;
        }
#line 340
        if ((int )t2 == 148) {
#line 340
          goto case_148;
        }
#line 344
        if ((int )t2 == 149) {
#line 344
          goto case_149;
        }
#line 350
        if ((int )t2 == 150) {
#line 350
          goto case_150;
        }
#line 359
        if ((int )t2 == 151) {
#line 359
          goto case_151;
        }
#line 229
        goto switch_break;
        case_129: /* CIL Label */ 
#line 231
        fxt = (uint8 )15;
#line 232
        fxp = t3;
#line 233
        goto switch_break;
        case_130: /* CIL Label */ 
#line 247
        goto switch_break;
        case_131: /* CIL Label */ 
#line 249
        event->vol = t3;
#line 250
        goto switch_break;
        case_132: /* CIL Label */ 
#line 252
        if ((int )((int8 )t3) > 0) {
#line 253
          fxt = (uint8 )2;
#line 254
          fxp = t3;
        } else {
#line 256
          fxt = (uint8 )1;
#line 257
          fxp = (uint8 )(- ((int )((int8 )t3)));
        }
#line 259
        goto switch_break;
        case_133: /* CIL Label */ 
#line 262
        goto switch_break;
        case_134: /* CIL Label */ 
#line 264
        fxt = (uint8 )3;
#line 265
        fxp = t3;
#line 266
        goto switch_break;
        case_135: /* CIL Label */ 
#line 268
        fxt = (uint8 )29;
#line 269
        fxp = t3;
#line 270
        goto switch_break;
        case_136: /* CIL Label */ 
#line 272
        fxt = (uint8 )0;
#line 273
        fxp = t3;
#line 274
        goto switch_break;
        case_137: /* CIL Label */ 
#line 276
        fxt = (uint8 )4;
#line 277
        fxp = t3;
#line 278
        goto switch_break;
        case_138: /* CIL Label */ 
#line 280
        if ((int )((int8 )t3) > 0) {
#line 281
          fxt = (uint8 )5;
#line 282
          fxp = (uint8 )((int )t3 << 4);
        } else {
#line 284
          fxt = (uint8 )5;
#line 285
          fxp = (uint8 )(- ((int )((int8 )t3)) & 15);
        }
#line 287
        goto switch_break;
        case_139: /* CIL Label */ 
#line 289
        if ((int )((int8 )t3) > 0) {
#line 290
          fxt = (uint8 )6;
#line 291
          fxp = (uint8 )((int )t3 << 4);
        } else {
#line 293
          fxt = (uint8 )6;
#line 294
          fxp = (uint8 )(- ((int )((int8 )t3)) & 15);
        }
#line 296
        goto switch_break;
        case_140: /* CIL Label */ 
#line 298
        fxt = (uint8 )13;
#line 299
        fxp = t3;
#line 300
        goto switch_break;
        case_141: /* CIL Label */ 
#line 302
        fxt = (uint8 )11;
#line 303
        fxp = t3;
#line 304
        goto switch_break;
        case_142: /* CIL Label */ 
#line 307
        goto switch_break;
        case_143: /* CIL Label */ 
#line 309
        fxt = (uint8 )14;
#line 310
        fxp = (uint8 )((9 << 4) | ((int )t3 & 15));
#line 311
        goto switch_break;
        case_144: /* CIL Label */ 
#line 313
        fxt = (uint8 )9;
#line 314
        fxp = t3;
#line 315
        goto switch_break;
        case_145: /* CIL Label */ 
#line 317
        if ((int )((int8 )t3) > 0) {
#line 318
          fxt = (uint8 )14;
#line 319
          fxp = (uint8 )((10 << 4) | ((int )t3 & 15));
        } else {
#line 322
          fxt = (uint8 )14;
#line 323
          fxp = (uint8 )((11 << 4) | ((int )t3 & 15));
        }
#line 326
        goto switch_break;
        case_146: /* CIL Label */ 
#line 328
        if ((int )((int8 )t3) > 0) {
#line 329
          fxt = (uint8 )2;
#line 330
          fxp = (uint8 )(240 | ((int )fxp & 15));
        } else {
#line 332
          fxt = (uint8 )1;
#line 333
          fxp = (uint8 )(240 | ((int )fxp & 15));
        }
#line 335
        goto switch_break;
        case_147: /* CIL Label */ 
#line 337
        fxt = (uint8 )14;
#line 338
        fxp = (uint8 )((13 << 4) | ((int )t3 & 15));
#line 339
        goto switch_break;
        case_148: /* CIL Label */ 
#line 341
        fxt = (uint8 )14;
#line 342
        fxp = (uint8 )((12 << 4) | ((int )t3 & 15));
#line 343
        goto switch_break;
        case_149: /* CIL Label */ 
#line 345
        fxt = (uint8 )15;
#line 346
        if ((int )t3 < 33) {
#line 347
          t3 = (uint8 )33;
        }
#line 348
        fxp = t3;
#line 349
        goto switch_break;
        case_150: /* CIL Label */ 
#line 351
        if ((int )((int8 )t3) > 0) {
#line 352
          fxt = (uint8 )2;
#line 353
          fxp = (uint8 )(224 | ((int )fxp & 15));
        } else {
#line 355
          fxt = (uint8 )1;
#line 356
          fxp = (uint8 )(224 | ((int )fxp & 15));
        }
#line 358
        goto switch_break;
        case_151: /* CIL Label */ 
#line 360
        fxt = (uint8 )8;
#line 361
        fxp = (uint8 )(128 + 2 * (int )((int8 )t3));
#line 362
        goto switch_break;
        switch_break: /* CIL Label */ ;
        }
#line 365
        event->fxt = fxt;
#line 366
        event->fxp = fxp;
      }
#line 205
      j ++;
    }
    while_break___12: /* CIL Label */ ;
    }
#line 370
    if ((m___0->verbosity > 0) & ! (i___3 % 4)) {
      {
#line 370
      report((char *)".");
      }
    }
#line 194
    i___3 ++;
  }
  while_break___11: /* CIL Label */ ;
  }
  {
#line 372
  reportv(ctx___0, 0, (char *)"\n");
#line 377
  reportv(ctx___0, 0, (char *)"Stored samples : %d ", (m___0->xxh)->smp);
#line 379
  i___3 = 0;
  }
  {
#line 379
  while (1) {
    while_continue___13: /* CIL Label */ ;
#line 379
    if (! (i___3 < (m___0->xxh)->ins)) {
#line 379
      goto while_break___13;
    }
    {
#line 380
    xmp_drv_loadpatch(ctx___0, f, (*(m___0->xxi + i___3) + 0)->sid, m___0->c4rate,
                      2, m___0->xxs + (*(m___0->xxi + i___3) + 0)->sid, (char *)((void *)0));
#line 382
    reportv(ctx___0, 0, (char *)".");
#line 379
    i___3 ++;
    }
  }
  while_break___13: /* CIL Label */ ;
  }
  {
#line 384
  reportv(ctx___0, 0, (char *)"\n");
#line 386
  m___0->quirk |= 1 << 12;
  }
#line 388
  return (0);
}
}
#line 66 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/masi_load.c"
static int masi_test(FILE *f , char *t , int const   start ) ;
#line 67
static int masi_load(struct xmp_context *ctx___0 , FILE *f , int const   start ) ;
#line 69 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/masi_load.c"
struct xmp_loader_info masi_loader  =    {(char *)"MASI", (char *)"Epic MegaGames MASI", & masi_test, & masi_load, 0, {(struct list_head *)0,
                                                                                 (struct list_head *)0}};
#line 76 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/masi_load.c"
static int masi_test(FILE *f , char *t , int const   start ) 
{ 
  uint32 tmp ;

  {
  {
#line 78
  tmp = read32b(f);
  }
#line 78
  if (tmp != ((((80U << 24) | (83U << 16)) | (77U << 8)) | 32U)) {
#line 79
    return (-1);
  }
  {
#line 81
  read_title(f, t, 0);
  }
#line 83
  return (0);
}
}
#line 86 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/masi_load.c"
static int sinaria  ;
#line 88 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/masi_load.c"
static int cur_pat  ;
#line 89 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/masi_load.c"
static int cur_ins  ;
#line 90 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/masi_load.c"
uint8 *pnam  ;
#line 91 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/masi_load.c"
uint8 *pord  ;
#line 94 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/masi_load.c"
static void get_sdft(struct xmp_context *ctx___0 , int size___0 , FILE *f ) 
{ 


  {
#line 96
  return;
}
}
#line 98 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/masi_load.c"
static void get_titl(struct xmp_context *ctx___0 , int size___0 , FILE *f ) 
{ 
  struct xmp_player_context *p ;
  struct xmp_mod_context *m___0 ;
  char buf___1[40] ;
  int tmp ;
  void *__cil_tmp8 ;

  {
  {
#line 100
  p = & ctx___0->p;
#line 101
  m___0 = & p->m;
#line 104
  fread((void */* __restrict  */)(buf___1), (size_t )1, (size_t )40, (FILE */* __restrict  */)f);
  }
#line 105
  if (size___0 > 32) {
#line 105
    tmp = 32;
  } else {
#line 105
    tmp = size___0;
  }
  {
#line 105
  strncpy((char */* __restrict  */)(m___0->name), (char const   */* __restrict  */)(buf___1),
          (size_t )tmp);
  }
#line 106
  return;
}
}
#line 108 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/masi_load.c"
static void get_dsmp_cnt(struct xmp_context *ctx___0 , int size___0 , FILE *f ) 
{ 
  struct xmp_player_context *p ;
  struct xmp_mod_context *m___0 ;

  {
#line 110
  p = & ctx___0->p;
#line 111
  m___0 = & p->m;
#line 113
  ((m___0->xxh)->ins) ++;
#line 114
  (m___0->xxh)->smp = (m___0->xxh)->ins;
#line 115
  return;
}
}
#line 117 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/masi_load.c"
static void get_pbod_cnt(struct xmp_context *ctx___0 , int size___0 , FILE *f ) 
{ 
  struct xmp_player_context *p ;
  struct xmp_mod_context *m___0 ;
  char buf___1[20] ;
  void *__cil_tmp7 ;

  {
  {
#line 119
  p = & ctx___0->p;
#line 120
  m___0 = & p->m;
#line 123
  ((m___0->xxh)->pat) ++;
#line 124
  fread((void */* __restrict  */)(buf___1), (size_t )1, (size_t )20, (FILE */* __restrict  */)f);
  }
#line 125
  if ((int )buf___1[9] != 0) {
#line 125
    if ((int )buf___1[13] == 0) {
#line 126
      sinaria = 1;
    }
  }
#line 127
  return;
}
}
#line 130 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/masi_load.c"
static void get_dsmp(struct xmp_context *ctx___0 , int size___0 , FILE *f ) 
{ 
  struct xmp_player_context *p ;
  struct xmp_mod_context *m___0 ;
  int i___3 ;
  int srate ;
  int finetune ;
  int tmp ;
  void *tmp___0 ;
  uint32 tmp___1 ;
  uint32 tmp___2 ;
  uint32 tmp___3 ;
  int8 tmp___4 ;
  uint8 tmp___5 ;
  uint32 tmp___6 ;
  int tmp___7 ;
  size_t tmp___8 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;

  {
  {
#line 132
  p = & ctx___0->p;
#line 133
  m___0 = & p->m;
#line 137
  read8(f);
#line 138
  fseek(f, 8L, 1);
  }
#line 139
  if (sinaria) {
#line 139
    tmp = 8;
  } else {
#line 139
    tmp = 4;
  }
  {
#line 139
  fseek(f, (long )tmp, 1);
  }
#line 141
  if (m___0->verbosity > 1) {
#line 141
    if (cur_ins == 0) {
      {
#line 142
      report((char *)"\n     Instrument name                  Len   LBeg  LEnd  L Vol Fine C2Spd");
      }
    }
  }
  {
#line 144
  i___3 = cur_ins;
#line 145
  tmp___0 = calloc((size_t )sizeof(struct xxm_instrument ), (size_t )1);
#line 145
  *(m___0->xxi + i___3) = (struct xxm_instrument *)tmp___0;
#line 147
  fread((void */* __restrict  */)(& (m___0->xxih + i___3)->name), (size_t )1, (size_t )34,
        (FILE */* __restrict  */)f);
#line 148
  str_adj((char *)((m___0->xxih + i___3)->name));
#line 149
  fseek(f, 5L, 1);
#line 150
  read8(f);
#line 151
  read8(f);
#line 152
  tmp___1 = read32l(f);
#line 152
  (m___0->xxs + i___3)->len = (int )tmp___1;
#line 153
  (m___0->xxih + i___3)->nsm = ! (! (m___0->xxs + i___3)->len);
#line 154
  tmp___2 = read32l(f);
#line 154
  (m___0->xxs + i___3)->lps = (int )tmp___2;
#line 155
  tmp___3 = read32l(f);
#line 155
  (m___0->xxs + i___3)->lpe = (int )tmp___3;
  }
#line 156
  if ((m___0->xxs + i___3)->lpe > 2) {
#line 156
    (m___0->xxs + i___3)->flg = 4;
  } else {
#line 156
    (m___0->xxs + i___3)->flg = 0;
  }
  {
#line 157
  read16l(f);
  }
#line 159
  if ((m___0->xxs + i___3)->lpe < 0) {
#line 160
    (m___0->xxs + i___3)->lpe = 0;
  }
#line 162
  finetune = 0;
#line 163
  if (sinaria) {
#line 164
    if ((m___0->xxs + i___3)->len > 2) {
#line 165
      (m___0->xxs + i___3)->len -= 2;
    }
#line 166
    if ((m___0->xxs + i___3)->lpe > 2) {
#line 167
      (m___0->xxs + i___3)->lpe -= 2;
    }
    {
#line 169
    tmp___4 = read8s(f);
#line 169
    finetune = (int )((int8 )((int )tmp___4 << 4));
    }
  }
  {
#line 172
  tmp___5 = read8(f);
#line 172
  (*(m___0->xxi + i___3) + 0)->vol = (int )tmp___5 / 2 + 1;
#line 173
  read32l(f);
#line 174
  (*(m___0->xxi + i___3) + 0)->pan = 128;
#line 175
  (*(m___0->xxi + i___3) + 0)->sid = i___3;
#line 176
  tmp___6 = read32l(f);
#line 176
  srate = (int )tmp___6;
  }
#line 178
  if (m___0->verbosity > 1) {
    {
#line 178
    tmp___8 = strlen((char const   *)((char *)((m___0->xxih + i___3)->name)));
    }
#line 178
    if (tmp___8) {
#line 178
      goto _L;
    } else
#line 178
    if ((m___0->xxs + i___3)->len > 1) {
      _L: /* CIL Label */ 
#line 179
      if ((m___0->xxs + i___3)->flg & 4) {
#line 179
        tmp___7 = 'L';
      } else {
#line 179
        tmp___7 = ' ';
      }
      {
#line 179
      report((char *)"\n[%2X] %-32.32s %05x %05x %05x %c V%02x %+04d %5d", i___3,
             (m___0->xxih + i___3)->name, (m___0->xxs + i___3)->len, (m___0->xxs + i___3)->lps,
             (m___0->xxs + i___3)->lpe, tmp___7, (*(m___0->xxi + i___3) + 0)->vol,
             finetune, srate);
      }
    }
  }
  {
#line 183
  srate = (8363 * srate) / 8448;
#line 184
  c2spd_to_note(srate, & (*(m___0->xxi + i___3) + 0)->xpo, & (*(m___0->xxi + i___3) + 0)->fin);
#line 185
  (*(m___0->xxi + i___3) + 0)->fin += finetune;
#line 187
  fseek(f, 16L, 1);
#line 188
  xmp_drv_loadpatch(ctx___0, f, i___3, m___0->c4rate, 4, m___0->xxs + i___3, (char *)((void *)0));
#line 190
  cur_ins ++;
  }
#line 191
  return;
}
}
#line 194 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/masi_load.c"
static void get_pbod(struct xmp_context *ctx___0 , int size___0 , FILE *f ) 
{ 
  struct xmp_player_context *p ;
  struct xmp_mod_context *m___0 ;
  int i___3 ;
  int r ;
  struct xxm_event *event ;
  struct xxm_event dummy___3 ;
  uint8 flag ;
  uint8 chan ;
  uint32 len ;
  int rows___1 ;
  int rowlen ;
  int tmp ;
  uint16 tmp___0 ;
  void *tmp___1 ;
  int j ;
  void *tmp___2 ;
  uint16 tmp___3 ;
  uint8 note ;
  uint8 tmp___4 ;
  uint8 tmp___5 ;
  uint8 tmp___6 ;
  uint8 fxt ;
  uint8 tmp___7 ;
  uint8 fxp ;
  uint8 tmp___8 ;
  uint8 note___0 ;
  void *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;

  {
  {
#line 196
  p = & ctx___0->p;
#line 197
  m___0 = & p->m;
#line 204
  i___3 = cur_pat;
#line 206
  len = read32l(f);
  }
#line 207
  if (sinaria) {
#line 207
    tmp = 8;
  } else {
#line 207
    tmp = 4;
  }
  {
#line 207
  fread((void */* __restrict  */)(pnam + i___3 * 8), (size_t )1, (size_t )tmp, (FILE */* __restrict  */)f);
#line 209
  tmp___0 = read16l(f);
#line 209
  rows___1 = (int )tmp___0;
  }
  {
#line 211
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 211
    tmp___1 = calloc((size_t )1, (size_t )(sizeof(struct xxm_pattern ) + sizeof(struct xxm_trackinfo ) * (unsigned long )((m___0->xxh)->chn - 1)));
#line 211
    *(m___0->xxp + i___3) = (struct xxm_pattern *)tmp___1;
    }
#line 211
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 212
  (*(m___0->xxp + i___3))->rows = rows___1;
  {
#line 213
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 213
    j = 0;
    {
#line 213
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 213
      if (! (j < (m___0->xxh)->chn)) {
#line 213
        goto while_break___1;
      }
      {
#line 213
      (*(m___0->xxp + i___3))->info[j].index = i___3 * (m___0->xxh)->chn + j;
#line 213
      tmp___2 = calloc((size_t )(sizeof(struct xxm_track ) + sizeof(struct xxm_event ) * (unsigned long )(*(m___0->xxp + i___3))->rows),
                       (size_t )1);
#line 213
      *(m___0->xxt + (i___3 * (m___0->xxh)->chn + j)) = (struct xxm_track *)tmp___2;
#line 213
      (*(m___0->xxt + (i___3 * (m___0->xxh)->chn + j)))->rows = (*(m___0->xxp + i___3))->rows;
#line 213
      j ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 213
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 215
  r = 0;
  {
#line 217
  while (1) {
    while_continue___2: /* CIL Label */ ;
    {
#line 218
    tmp___3 = read16l(f);
#line 218
    rowlen = (int )tmp___3 - 2;
    }
    {
#line 219
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 219
      if (! (rowlen > 0)) {
#line 219
        goto while_break___3;
      }
      {
#line 220
      flag = read8(f);
      }
#line 222
      if (rowlen == 1) {
#line 223
        goto while_break___3;
      }
      {
#line 225
      chan = read8(f);
#line 226
      rowlen -= 2;
      }
#line 228
      if ((int )chan < (m___0->xxh)->chn) {
#line 228
        event = & (*(m___0->xxt + (*(m___0->xxp + i___3))->info[chan].index))->event[r];
      } else {
#line 228
        event = & dummy___3;
      }
#line 230
      if ((int )flag & 128) {
        {
#line 231
        tmp___4 = read8(f);
#line 231
        note = tmp___4;
#line 232
        rowlen --;
        }
#line 233
        if (sinaria) {
#line 234
          note = (uint8 )((int )note + 25);
        } else {
#line 236
          note = (uint8 )((((int )note >> 4) * 12 + ((int )note & 15)) + 2);
        }
#line 237
        event->note = note;
      }
#line 240
      if ((int )flag & 64) {
        {
#line 241
        tmp___5 = read8(f);
#line 241
        event->ins = (uint8 )((int )tmp___5 + 1);
#line 242
        rowlen --;
        }
      }
#line 245
      if ((int )flag & 32) {
        {
#line 246
        tmp___6 = read8(f);
#line 246
        event->vol = (uint8 )((int )tmp___6 / 2);
#line 247
        rowlen --;
        }
      }
#line 250
      if ((int )flag & 16) {
        {
#line 251
        tmp___7 = read8(f);
#line 251
        fxt = tmp___7;
#line 252
        tmp___8 = read8(f);
#line 252
        fxp = tmp___8;
#line 253
        rowlen -= 2;
        }
#line 256
        if ((int )fxt >= 64) {
          {
#line 258
          if ((int )fxp >> 4 == 0) {
#line 258
            goto case_0;
          }
#line 266
          goto switch_default;
          case_0: /* CIL Label */ 
#line 260
          note___0 = (uint8 )((((int )fxt >> 4) * 12 + ((int )fxt & 15)) + 2);
#line 262
          event->note = note___0;
#line 263
          fxt = (uint8 )3;
#line 264
          fxp = (uint8 )(((int )fxp + 1) * 2);
#line 265
          goto switch_break;
          switch_default: /* CIL Label */ 
          {
#line 267
          printf((char const   */* __restrict  */)"p%d r%d c%d: compressed event %02x %02x\n",
                 i___3, r, (int )chan, (int )fxt, (int )fxp);
          }
          switch_break: /* CIL Label */ ;
          }
        } else {
          {
#line 271
          if ((int )fxt == 1) {
#line 271
            goto case_1;
          }
#line 276
          if ((int )fxt == 2) {
#line 276
            goto case_2;
          }
#line 280
          if ((int )fxt == 3) {
#line 280
            goto case_3;
          }
#line 285
          if ((int )fxt == 4) {
#line 285
            goto case_4;
          }
#line 289
          if ((int )fxt == 12) {
#line 289
            goto case_12;
          }
#line 293
          if ((int )fxt == 14) {
#line 293
            goto case_14;
          }
#line 297
          if ((int )fxt == 15) {
#line 297
            goto case_15;
          }
#line 301
          if ((int )fxt == 21) {
#line 301
            goto case_21;
          }
#line 306
          if ((int )fxt == 42) {
#line 306
            goto case_42;
          }
#line 310
          if ((int )fxt == 41) {
#line 310
            goto case_41;
          }
#line 314
          if ((int )fxt == 51) {
#line 314
            goto case_51;
          }
#line 317
          if ((int )fxt == 52) {
#line 317
            goto case_52;
          }
#line 320
          if ((int )fxt == 61) {
#line 320
            goto case_61;
          }
#line 323
          if ((int )fxt == 62) {
#line 323
            goto case_62;
          }
#line 326
          goto switch_default___0;
          case_1: /* CIL Label */ 
#line 272
          fxt = (uint8 )14;
#line 273
          fxp = (uint8 )((10 << 4) | ((int )fxp / 2 & 15));
#line 275
          goto switch_break___0;
          case_2: /* CIL Label */ 
#line 277
          fxt = (uint8 )10;
#line 278
          fxp = (uint8 )((int )fxp / 2 << 4);
#line 279
          goto switch_break___0;
          case_3: /* CIL Label */ 
#line 281
          fxt = (uint8 )14;
#line 282
          fxp = (uint8 )((11 << 4) | ((int )fxp / 2 & 15));
#line 284
          goto switch_break___0;
          case_4: /* CIL Label */ 
#line 286
          fxt = (uint8 )10;
#line 287
          fxp = (uint8 )((int )fxp / 2);
#line 288
          goto switch_break___0;
          case_12: /* CIL Label */ 
#line 290
          fxt = (uint8 )1;
#line 291
          fxp = (uint8 )(((int )fxp - 1) / 2);
#line 292
          goto switch_break___0;
          case_14: /* CIL Label */ 
#line 294
          fxt = (uint8 )2;
#line 295
          fxp = (uint8 )(((int )fxp - 1) / 2);
#line 296
          goto switch_break___0;
          case_15: /* CIL Label */ 
#line 298
          fxt = (uint8 )3;
#line 299
          fxp = (uint8 )((int )fxp / 4);
#line 300
          goto switch_break___0;
          case_21: /* CIL Label */ 
#line 302
          if (sinaria) {
#line 302
            fxt = (uint8 )4;
          } else {
#line 302
            fxt = (uint8 )172;
          }
#line 305
          goto switch_break___0;
          case_42: /* CIL Label */ 
#line 307
          fxt = (uint8 )14;
#line 308
          fxp = (uint8 )((9 << 4) | ((int )fxp & 15));
#line 309
          goto switch_break___0;
          case_41: /* CIL Label */ 
          {
#line 311
          read16l(f);
#line 312
          rowlen -= 2;
          }
#line 313
          goto switch_break___0;
          case_51: /* CIL Label */ 
#line 315
          fxt = (uint8 )11;
#line 316
          goto switch_break___0;
          case_52: /* CIL Label */ 
#line 318
          fxt = (uint8 )13;
#line 319
          goto switch_break___0;
          case_61: /* CIL Label */ 
#line 321
          fxt = (uint8 )15;
#line 322
          goto switch_break___0;
          case_62: /* CIL Label */ 
#line 324
          fxt = (uint8 )15;
#line 325
          goto switch_break___0;
          switch_default___0: /* CIL Label */ 
          {
#line 327
          printf((char const   */* __restrict  */)"p%d r%d c%d: unknown effect %02x %02x\n",
                 i___3, r, (int )chan, (int )fxt, (int )fxp);
#line 328
          fxp = (uint8 )0;
#line 328
          fxt = fxp;
          }
          switch_break___0: /* CIL Label */ ;
          }
        }
#line 331
        event->fxt = fxt;
#line 332
        event->fxp = fxp;
      }
    }
    while_break___3: /* CIL Label */ ;
    }
#line 335
    r ++;
#line 217
    if (! (r < rows___1)) {
#line 217
      goto while_break___2;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 338
  cur_pat ++;
#line 339
  return;
}
}
#line 341 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/masi_load.c"
static void get_song___0(struct xmp_context *ctx___0 , int size___0 , FILE *f ) 
{ 
  struct xmp_player_context *p ;
  struct xmp_mod_context *m___0 ;
  uint8 tmp ;

  {
  {
#line 343
  p = & ctx___0->p;
#line 344
  m___0 = & p->m;
#line 346
  fseek(f, 10L, 1);
#line 347
  tmp = read8(f);
#line 347
  (m___0->xxh)->chn = (int )tmp;
  }
#line 348
  return;
}
}
#line 350 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/masi_load.c"
static void get_song_2(struct xmp_context *ctx___0 , int size___0 , FILE *f ) 
{ 
  struct xmp_player_context *p ;
  struct xmp_mod_context *m___0 ;
  uint32 magic ;
  char c___0 ;
  char buf___1[20] ;
  int i___3 ;
  int skip___0 ;
  uint32 tmp ;
  uint8 tmp___0 ;
  uint8 tmp___1 ;
  uint8 tmp___2 ;
  uint8 tmp___3 ;
  uint8 tmp___4 ;
  uint8 tmp___5 ;
  uint8 tmp___6 ;
  int tmp___7 ;
  void *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;

  {
  {
#line 352
  p = & ctx___0->p;
#line 353
  m___0 = & p->m;
#line 358
  fread((void */* __restrict  */)(buf___1), (size_t )1, (size_t )9, (FILE */* __restrict  */)f);
#line 359
  read16l(f);
#line 361
  reportv(ctx___0, 2, (char *)"\nSubsong title  : %-9.9s", buf___1);
#line 363
  magic = read32b(f);
  }
  {
#line 364
  while (1) {
    while_continue: /* CIL Label */ ;
#line 364
    if (! (magic != ((((79U << 24) | (80U << 16)) | (76U << 8)) | 72U))) {
#line 364
      goto while_break;
    }
    {
#line 366
    tmp = read32l(f);
#line 366
    skip___0 = (int )tmp;
#line 367
    fseek(f, (long )skip___0, 1);
#line 368
    magic = read32b(f);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 371
  read32l(f);
#line 373
  fseek(f, 9L, 1);
#line 375
  tmp___0 = read8(f);
#line 375
  c___0 = (char )tmp___0;
#line 376
  i___3 = 0;
  }
  {
#line 376
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 376
    if (! ((int )c___0 != 1)) {
#line 376
      goto while_break___0;
    }
    {
#line 378
    if ((int )c___0 == 7) {
#line 378
      goto case_7;
    }
#line 383
    if ((int )c___0 == 13) {
#line 383
      goto case_13;
    }
#line 389
    if ((int )c___0 == 14) {
#line 389
      goto case_14;
    }
#line 393
    goto switch_default;
    case_7: /* CIL Label */ 
    {
#line 379
    tmp___2 = read8(f);
#line 379
    (m___0->xxh)->tpo = (int )tmp___2;
#line 380
    read8(f);
#line 381
    tmp___3 = read8(f);
#line 381
    (m___0->xxh)->bpm = (int )tmp___3;
    }
#line 382
    goto switch_break;
    case_13: /* CIL Label */ 
    {
#line 384
    read8(f);
#line 385
    tmp___4 = read8(f);
#line 385
    m___0->xxc[i___3].pan = (int )tmp___4;
#line 386
    read8(f);
#line 387
    i___3 ++;
    }
#line 388
    goto switch_break;
    case_14: /* CIL Label */ 
    {
#line 390
    read8(f);
#line 391
    read8(f);
    }
#line 392
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 394
    tmp___5 = read8(f);
#line 394
    printf((char const   */* __restrict  */)"channel %d: %02x %02x\n", i___3, (int )c___0,
           (int )tmp___5);
    }
    switch_break: /* CIL Label */ ;
    }
    {
#line 376
    tmp___1 = read8(f);
#line 376
    c___0 = (char )tmp___1;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 398
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 398
    if (! ((int )c___0 == 1)) {
#line 398
      goto while_break___1;
    }
#line 399
    if (sinaria) {
#line 399
      tmp___7 = 8;
    } else {
#line 399
      tmp___7 = 4;
    }
    {
#line 399
    fread((void */* __restrict  */)(pord + (m___0->xxh)->len * 8), (size_t )1, (size_t )tmp___7,
          (FILE */* __restrict  */)f);
#line 400
    ((m___0->xxh)->len) ++;
#line 398
    tmp___6 = read8(f);
#line 398
    c___0 = (char )tmp___6;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 402
  return;
}
}
#line 404 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/masi_load.c"
static int masi_load(struct xmp_context *ctx___0 , FILE *f , int const   start ) 
{ 
  struct xmp_player_context *p ;
  struct xmp_mod_context *m___0 ;
  int offset ;
  int i___3 ;
  int j ;
  uint8 **tmp ;
  int tmp___0 ;
  long tmp___1 ;
  int tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  char const   *tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  void *tmp___9 ;
  void *tmp___10 ;
  void *tmp___11 ;
  void *tmp___12 ;
  void *tmp___13 ;
  void *tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;

  {
#line 406
  p = & ctx___0->p;
#line 407
  m___0 = & p->m;
  {
#line 411
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 411
    fseek(f, (long )start, 0);
#line 411
    tmp = (uint8 **)((void *)0);
#line 411
    m___0->med_wav_table = tmp;
#line 411
    m___0->med_vol_table = tmp;
#line 411
    set_xxh_defaults(m___0->xxh);
    }
#line 411
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 413
  read32b(f);
#line 415
  sinaria = 0;
#line 416
  m___0->name[0] = (char)0;
#line 418
  fseek(f, 8L, 1);
#line 419
  tmp___0 = 0;
#line 419
  (m___0->xxh)->ins = tmp___0;
#line 419
  (m___0->xxh)->smp = tmp___0;
#line 420
  cur_pat = 0;
#line 421
  cur_ins = 0;
#line 422
  tmp___1 = ftell(f);
#line 422
  offset = (int )tmp___1;
#line 425
  iff_register((char *)"TITL", & get_titl);
#line 426
  iff_register((char *)"SDFT", & get_sdft);
#line 427
  iff_register((char *)"SONG", & get_song___0);
#line 428
  iff_register((char *)"DSMP", & get_dsmp_cnt);
#line 429
  iff_register((char *)"PBOD", & get_pbod_cnt);
#line 430
  iff_setflag(1);
  }
  {
#line 433
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 433
    tmp___2 = feof(f);
    }
#line 433
    if (tmp___2) {
#line 433
      goto while_break___0;
    }
    {
#line 434
    iff_chunk(ctx___0, f);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 436
  iff_release();
#line 438
  (m___0->xxh)->trk = (m___0->xxh)->pat * (m___0->xxh)->chn;
#line 439
  tmp___3 = malloc((size_t )((m___0->xxh)->pat * 8));
#line 439
  pnam = (uint8 *)tmp___3;
#line 440
  tmp___4 = malloc((size_t )2040);
#line 440
  pord = (uint8 *)tmp___4;
  }
#line 442
  if (sinaria) {
#line 442
    tmp___5 = "MASI (Sinaria PSM)";
  } else {
#line 442
    tmp___5 = "MASI (Epic MegaGames MASI)";
  }
  {
#line 442
  strcpy((char */* __restrict  */)(m___0->type), (char const   */* __restrict  */)tmp___5);
  }
  {
#line 445
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 445
    if (m___0->verbosity) {
#line 445
      if (m___0->name[0]) {
        {
#line 445
        report((char *)"Module title   : %s\n", m___0->name);
        }
      }
#line 445
      if (m___0->type[0]) {
        {
#line 445
        report((char *)"Module type    : %s\n", m___0->type);
        }
      }
#line 445
      if (m___0->author[0]) {
        {
#line 445
        report((char *)"Author name    : %s\n", m___0->author);
        }
      }
#line 445
      if ((m___0->xxh)->len) {
        {
#line 445
        report((char *)"Module length  : %d patterns\n", (m___0->xxh)->len);
        }
      }
    }
#line 445
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 446
  while (1) {
    while_continue___2: /* CIL Label */ ;
    {
#line 446
    tmp___6 = calloc((size_t )sizeof(struct xxm_instrument_header ), (size_t )(m___0->xxh)->ins);
#line 446
    m___0->xxih = (struct xxm_instrument_header *)tmp___6;
#line 446
    tmp___7 = calloc((size_t )sizeof(struct xxm_instrument_map ), (size_t )(m___0->xxh)->ins);
#line 446
    m___0->xxim = (struct xxm_instrument_map *)tmp___7;
#line 446
    tmp___8 = calloc((size_t )sizeof(struct xxm_instrument *), (size_t )(m___0->xxh)->ins);
#line 446
    m___0->xxi = (struct xxm_instrument **)tmp___8;
    }
#line 446
    if ((m___0->xxh)->smp) {
      {
#line 446
      tmp___9 = calloc((size_t )sizeof(struct xxm_sample ), (size_t )(m___0->xxh)->smp);
#line 446
      m___0->xxs = (struct xxm_sample *)tmp___9;
      }
    }
    {
#line 446
    tmp___10 = calloc((size_t )sizeof(uint16 *), (size_t )(m___0->xxh)->ins);
#line 446
    m___0->xxae = (uint16 **)tmp___10;
#line 446
    tmp___11 = calloc((size_t )sizeof(uint16 *), (size_t )(m___0->xxh)->ins);
#line 446
    m___0->xxpe = (uint16 **)tmp___11;
#line 446
    tmp___12 = calloc((size_t )sizeof(uint16 *), (size_t )(m___0->xxh)->ins);
#line 446
    m___0->xxfe = (uint16 **)tmp___12;
    }
#line 446
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 447
  while (1) {
    while_continue___3: /* CIL Label */ ;
    {
#line 447
    tmp___13 = calloc((size_t )sizeof(struct xxm_track *), (size_t )(m___0->xxh)->trk);
#line 447
    m___0->xxt = (struct xxm_track **)tmp___13;
#line 447
    tmp___14 = calloc((size_t )sizeof(struct xxm_pattern *), (size_t )((m___0->xxh)->pat + 1));
#line 447
    m___0->xxp = (struct xxm_pattern **)tmp___14;
    }
#line 447
    goto while_break___3;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 449
  if (m___0->verbosity > 0) {
    {
#line 450
    report((char *)"Stored patterns: %d\n", (m___0->xxh)->pat);
#line 451
    report((char *)"Stored samples : %d", (m___0->xxh)->smp);
    }
  }
  {
#line 454
  fseek(f, (long )(start + (int const   )offset), 0);
#line 456
  (m___0->xxh)->len = 0;
#line 458
  iff_register((char *)"SONG", & get_song_2);
#line 459
  iff_register((char *)"DSMP", & get_dsmp);
#line 460
  iff_register((char *)"PBOD", & get_pbod);
#line 461
  iff_setflag(1);
  }
  {
#line 464
  while (1) {
    while_continue___4: /* CIL Label */ ;
    {
#line 464
    tmp___15 = feof(f);
    }
#line 464
    if (tmp___15) {
#line 464
      goto while_break___4;
    }
    {
#line 465
    iff_chunk(ctx___0, f);
    }
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 467
  iff_release();
#line 469
  i___3 = 0;
  }
  {
#line 469
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 469
    if (! (i___3 < (m___0->xxh)->len)) {
#line 469
      goto while_break___5;
    }
#line 470
    j = 0;
    {
#line 470
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 470
      if (! (j < (m___0->xxh)->pat)) {
#line 470
        goto while_break___6;
      }
#line 471
      if (sinaria) {
#line 471
        tmp___16 = 8;
      } else {
#line 471
        tmp___16 = 4;
      }
      {
#line 471
      tmp___17 = memcmp((void const   *)(pord + i___3 * 8), (void const   *)(pnam + j * 8),
                        (size_t )tmp___16);
      }
#line 471
      if (! tmp___17) {
#line 472
        m___0->xxo[i___3] = (uint8 )j;
#line 473
        goto while_break___6;
      }
#line 470
      j ++;
    }
    while_break___6: /* CIL Label */ ;
    }
#line 477
    if (j == (m___0->xxh)->pat) {
#line 478
      goto while_break___5;
    }
#line 469
    i___3 ++;
  }
  while_break___5: /* CIL Label */ ;
  }
  {
#line 481
  free((void *)pnam);
#line 482
  free((void *)pord);
#line 484
  reportv(ctx___0, 0, (char *)"\n");
  }
#line 486
  return (0);
}
}
#line 22 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/load.h"
int test_name(uint8 *s , int n___0 ) ;
#line 58 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/ims_load.c"
static int ims_test(FILE *f , char *t , int const   start ) ;
#line 59
static int ims_load(struct xmp_context *ctx___0 , FILE *f , int const   start ) ;
#line 61 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/ims_load.c"
struct xmp_loader_info ims_loader  =    {(char *)"IMS", (char *)"Images Music System", & ims_test, & ims_load, 0, {(struct list_head *)0,
                                                                              (struct list_head *)0}};
#line 68 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/ims_load.c"
static int ims_test(FILE *f , char *t , int const   start ) 
{ 
  int i___3 ;
  int smp_size ;
  int pat___0 ;
  struct ims_header ih ;
  uint16 tmp ;
  int tmp___0 ;
  void *__cil_tmp10 ;
  void *__cil_tmp11 ;
  void *__cil_tmp12 ;
  int __cil_tmp13 ;
  void *__cil_tmp14 ;
  void *__cil_tmp15 ;
  void *__cil_tmp16 ;
  void *__cil_tmp17 ;

  {
  {
#line 74
  smp_size = 0;
#line 76
  fread((void */* __restrict  */)(& ih.title), (size_t )20, (size_t )1, (FILE */* __restrict  */)f);
#line 78
  i___3 = 0;
  }
  {
#line 78
  while (1) {
    while_continue: /* CIL Label */ ;
#line 78
    if (! (i___3 < 31)) {
#line 78
      goto while_break;
    }
    {
#line 79
    fread((void */* __restrict  */)(& ih.ins[i___3].name), (size_t )20, (size_t )1,
          (FILE */* __restrict  */)f);
#line 80
    tmp = read16b(f);
#line 80
    ih.ins[i___3].finetune = (int16 )tmp;
#line 81
    ih.ins[i___3].size = read16b(f);
#line 82
    ih.ins[i___3].unknown = read8(f);
#line 83
    ih.ins[i___3].volume = read8(f);
#line 84
    ih.ins[i___3].loop_start = read16b(f);
#line 85
    ih.ins[i___3].loop_size = read16b(f);
#line 87
    smp_size += (int )ih.ins[i___3].size * 2;
#line 89
    tmp___0 = test_name(ih.ins[i___3].name, 20);
    }
#line 89
    if (tmp___0 < 0) {
#line 90
      return (-1);
    }
#line 92
    if ((int )ih.ins[i___3].volume > 64) {
#line 93
      return (-1);
    }
#line 95
    if ((int )ih.ins[i___3].size > 32768) {
#line 96
      return (-1);
    }
#line 98
    if ((int )ih.ins[i___3].loop_start > (int )ih.ins[i___3].size) {
#line 99
      return (-1);
    }
#line 101
    if (ih.ins[i___3].size) {
#line 101
      if ((int )ih.ins[i___3].loop_size > 2 * (int )ih.ins[i___3].size) {
#line 102
        return (-1);
      }
    }
#line 78
    i___3 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 105
  if (smp_size < 8) {
#line 106
    return (-1);
  }
  {
#line 108
  ih.len = read8(f);
#line 109
  ih.zero = read8(f);
#line 110
  fread((void */* __restrict  */)(& ih.orders), (size_t )128, (size_t )1, (FILE */* __restrict  */)f);
#line 111
  fread((void */* __restrict  */)(& ih.magic), (size_t )4, (size_t )1, (FILE */* __restrict  */)f);
  }
#line 113
  if ((int )ih.zero > 1) {
#line 114
    return (-1);
  }
#line 116
  if ((int )ih.magic[3] != 60) {
#line 117
    return (-1);
  }
#line 119
  if ((int )ih.len > 127) {
#line 120
    return (-1);
  }
#line 122
  i___3 = 0;
#line 122
  pat___0 = i___3;
  {
#line 122
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 122
    if (! (i___3 < (int )ih.len)) {
#line 122
      goto while_break___0;
    }
#line 123
    if ((int )ih.orders[i___3] > pat___0) {
#line 124
      pat___0 = (int )ih.orders[i___3];
    }
#line 122
    i___3 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 125
  pat___0 ++;
#line 127
  if (pat___0 > 127) {
#line 128
    return (-1);
  } else
#line 127
  if ((int )ih.len == 0) {
#line 128
    return (-1);
  } else
#line 127
  if ((int )ih.len > 127) {
#line 128
    return (-1);
  }
  {
#line 130
  fseek(f, (long )start, 0);
#line 131
  read_title(f, t, 20);
  }
#line 133
  return (0);
}
}
#line 137 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/ims_load.c"
static int ims_load(struct xmp_context *ctx___0 , FILE *f , int const   start ) 
{ 
  struct xmp_player_context *p ;
  struct xmp_mod_context *m___0 ;
  int i___3 ;
  int j ;
  int smp_size ;
  struct xxm_event *event ;
  struct ims_header ih ;
  uint8 ims_event[3] ;
  int xpo ;
  uint8 **tmp ;
  uint16 tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  int tmp___9 ;
  size_t tmp___10 ;
  void *tmp___11 ;
  void *tmp___12 ;
  void *tmp___13 ;
  int j___0 ;
  void *tmp___14 ;
  void *__cil_tmp30 ;
  void *__cil_tmp31 ;
  void *__cil_tmp32 ;
  int __cil_tmp33 ;
  void *__cil_tmp34 ;
  void *__cil_tmp35 ;
  void *__cil_tmp36 ;
  void *__cil_tmp37 ;
  void *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;

  {
#line 139
  p = & ctx___0->p;
#line 140
  m___0 = & p->m;
#line 146
  xpo = 21;
  {
#line 148
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 148
    fseek(f, (long )start, 0);
#line 148
    tmp = (uint8 **)((void *)0);
#line 148
    m___0->med_wav_table = tmp;
#line 148
    m___0->med_vol_table = tmp;
#line 148
    set_xxh_defaults(m___0->xxh);
    }
#line 148
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 150
  (m___0->xxh)->ins = 31;
#line 151
  (m___0->xxh)->smp = (m___0->xxh)->ins;
#line 152
  smp_size = 0;
#line 154
  fread((void */* __restrict  */)(& ih.title), (size_t )20, (size_t )1, (FILE */* __restrict  */)f);
#line 156
  i___3 = 0;
  }
  {
#line 156
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 156
    if (! (i___3 < 31)) {
#line 156
      goto while_break___0;
    }
    {
#line 157
    fread((void */* __restrict  */)(& ih.ins[i___3].name), (size_t )20, (size_t )1,
          (FILE */* __restrict  */)f);
#line 158
    tmp___0 = read16b(f);
#line 158
    ih.ins[i___3].finetune = (int16 )tmp___0;
#line 159
    ih.ins[i___3].size = read16b(f);
#line 160
    ih.ins[i___3].unknown = read8(f);
#line 161
    ih.ins[i___3].volume = read8(f);
#line 162
    ih.ins[i___3].loop_start = read16b(f);
#line 163
    ih.ins[i___3].loop_size = read16b(f);
#line 165
    smp_size += (int )ih.ins[i___3].size * 2;
#line 156
    i___3 ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 168
  ih.len = read8(f);
#line 169
  ih.zero = read8(f);
#line 170
  fread((void */* __restrict  */)(& ih.orders), (size_t )128, (size_t )1, (FILE */* __restrict  */)f);
#line 171
  fread((void */* __restrict  */)(& ih.magic), (size_t )4, (size_t )1, (FILE */* __restrict  */)f);
#line 173
  (m___0->xxh)->len = (int )ih.len;
#line 174
  memcpy((void */* __restrict  */)(m___0->xxo), (void const   */* __restrict  */)(ih.orders),
         (size_t )(m___0->xxh)->len);
#line 176
  i___3 = 0;
  }
  {
#line 176
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 176
    if (! (i___3 < (m___0->xxh)->len)) {
#line 176
      goto while_break___1;
    }
#line 177
    if ((int )m___0->xxo[i___3] > (m___0->xxh)->pat) {
#line 178
      (m___0->xxh)->pat = (int )m___0->xxo[i___3];
    }
#line 176
    i___3 ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 180
  ((m___0->xxh)->pat) ++;
#line 181
  (m___0->xxh)->trk = (m___0->xxh)->chn * (m___0->xxh)->pat;
#line 183
  strncpy((char */* __restrict  */)(m___0->name), (char const   */* __restrict  */)((char *)(ih.title)),
          (size_t )20);
#line 184
  sprintf((char */* __restrict  */)(m___0->type), (char const   */* __restrict  */)"IMS (Images Music System)");
  }
  {
#line 186
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 186
    if (m___0->verbosity) {
#line 186
      if (m___0->name[0]) {
        {
#line 186
        report((char *)"Module title   : %s\n", m___0->name);
        }
      }
#line 186
      if (m___0->type[0]) {
        {
#line 186
        report((char *)"Module type    : %s\n", m___0->type);
        }
      }
#line 186
      if (m___0->author[0]) {
        {
#line 186
        report((char *)"Author name    : %s\n", m___0->author);
        }
      }
#line 186
      if ((m___0->xxh)->len) {
        {
#line 186
        report((char *)"Module length  : %d patterns\n", (m___0->xxh)->len);
        }
      }
    }
#line 186
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 188
  while (1) {
    while_continue___3: /* CIL Label */ ;
    {
#line 188
    tmp___1 = calloc((size_t )sizeof(struct xxm_instrument_header ), (size_t )(m___0->xxh)->ins);
#line 188
    m___0->xxih = (struct xxm_instrument_header *)tmp___1;
#line 188
    tmp___2 = calloc((size_t )sizeof(struct xxm_instrument_map ), (size_t )(m___0->xxh)->ins);
#line 188
    m___0->xxim = (struct xxm_instrument_map *)tmp___2;
#line 188
    tmp___3 = calloc((size_t )sizeof(struct xxm_instrument *), (size_t )(m___0->xxh)->ins);
#line 188
    m___0->xxi = (struct xxm_instrument **)tmp___3;
    }
#line 188
    if ((m___0->xxh)->smp) {
      {
#line 188
      tmp___4 = calloc((size_t )sizeof(struct xxm_sample ), (size_t )(m___0->xxh)->smp);
#line 188
      m___0->xxs = (struct xxm_sample *)tmp___4;
      }
    }
    {
#line 188
    tmp___5 = calloc((size_t )sizeof(uint16 *), (size_t )(m___0->xxh)->ins);
#line 188
    m___0->xxae = (uint16 **)tmp___5;
#line 188
    tmp___6 = calloc((size_t )sizeof(uint16 *), (size_t )(m___0->xxh)->ins);
#line 188
    m___0->xxpe = (uint16 **)tmp___6;
#line 188
    tmp___7 = calloc((size_t )sizeof(uint16 *), (size_t )(m___0->xxh)->ins);
#line 188
    m___0->xxfe = (uint16 **)tmp___7;
    }
#line 188
    goto while_break___3;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 190
  i___3 = 0;
  {
#line 190
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 190
    if (! (i___3 < (m___0->xxh)->ins)) {
#line 190
      goto while_break___4;
    }
    {
#line 191
    tmp___8 = calloc((size_t )sizeof(struct xxm_instrument ), (size_t )1);
#line 191
    *(m___0->xxi + i___3) = (struct xxm_instrument *)tmp___8;
#line 192
    (m___0->xxs + i___3)->len = 2 * (int )ih.ins[i___3].size;
#line 193
    (m___0->xxs + i___3)->lpe = (m___0->xxs + i___3)->lps + 2 * (int )ih.ins[i___3].loop_size;
    }
#line 194
    if ((int )ih.ins[i___3].loop_size > 1) {
#line 194
      (m___0->xxs + i___3)->flg = 4;
    } else {
#line 194
      (m___0->xxs + i___3)->flg = 0;
    }
    {
#line 195
    (*(m___0->xxi + i___3) + 0)->fin = 0;
#line 196
    (*(m___0->xxi + i___3) + 0)->vol = (int )ih.ins[i___3].volume;
#line 197
    (*(m___0->xxi + i___3) + 0)->pan = 128;
#line 198
    (*(m___0->xxi + i___3) + 0)->sid = i___3;
#line 199
    (m___0->xxih + i___3)->nsm = ! (! (m___0->xxs + i___3)->len);
#line 200
    (m___0->xxih + i___3)->rls = 4095;
#line 202
    copy_adjust((m___0->xxih + i___3)->name, ih.ins[i___3].name, 20);
    }
#line 204
    if (m___0->verbosity > 1) {
      {
#line 204
      tmp___10 = strlen((char const   *)((char *)((m___0->xxih + i___3)->name)));
      }
#line 204
      if (tmp___10) {
#line 204
        goto _L;
      } else
#line 204
      if ((m___0->xxs + i___3)->len > 2) {
        _L: /* CIL Label */ 
#line 206
        if ((int )ih.ins[i___3].loop_size > 1) {
#line 206
          tmp___9 = 'L';
        } else {
#line 206
          tmp___9 = ' ';
        }
        {
#line 206
        report((char *)"[%2X] %-20.20s %04x %04x %04x %c V%02x %+d\n", i___3, (m___0->xxih + i___3)->name,
               (m___0->xxs + i___3)->len, (m___0->xxs + i___3)->lps, (m___0->xxs + i___3)->lpe,
               tmp___9, (*(m___0->xxi + i___3) + 0)->vol, (*(m___0->xxi + i___3) + 0)->fin >> 4);
        }
      }
    }
#line 190
    i___3 ++;
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 213
  while (1) {
    while_continue___5: /* CIL Label */ ;
    {
#line 213
    tmp___11 = calloc((size_t )sizeof(struct xxm_track *), (size_t )(m___0->xxh)->trk);
#line 213
    m___0->xxt = (struct xxm_track **)tmp___11;
#line 213
    tmp___12 = calloc((size_t )sizeof(struct xxm_pattern *), (size_t )((m___0->xxh)->pat + 1));
#line 213
    m___0->xxp = (struct xxm_pattern **)tmp___12;
    }
#line 213
    goto while_break___5;
  }
  while_break___5: /* CIL Label */ ;
  }
  {
#line 216
  reportv(ctx___0, 0, (char *)"Stored patterns: %d ", (m___0->xxh)->pat);
#line 218
  i___3 = 0;
  }
  {
#line 218
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 218
    if (! (i___3 < (m___0->xxh)->pat)) {
#line 218
      goto while_break___6;
    }
    {
#line 219
    while (1) {
      while_continue___7: /* CIL Label */ ;
      {
#line 219
      tmp___13 = calloc((size_t )1, (size_t )(sizeof(struct xxm_pattern ) + sizeof(struct xxm_trackinfo ) * (unsigned long )((m___0->xxh)->chn - 1)));
#line 219
      *(m___0->xxp + i___3) = (struct xxm_pattern *)tmp___13;
      }
#line 219
      goto while_break___7;
    }
    while_break___7: /* CIL Label */ ;
    }
#line 220
    (*(m___0->xxp + i___3))->rows = 64;
    {
#line 221
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 221
      j___0 = 0;
      {
#line 221
      while (1) {
        while_continue___9: /* CIL Label */ ;
#line 221
        if (! (j___0 < (m___0->xxh)->chn)) {
#line 221
          goto while_break___9;
        }
        {
#line 221
        (*(m___0->xxp + i___3))->info[j___0].index = i___3 * (m___0->xxh)->chn + j___0;
#line 221
        tmp___14 = calloc((size_t )(sizeof(struct xxm_track ) + sizeof(struct xxm_event ) * (unsigned long )(*(m___0->xxp + i___3))->rows),
                          (size_t )1);
#line 221
        *(m___0->xxt + (i___3 * (m___0->xxh)->chn + j___0)) = (struct xxm_track *)tmp___14;
#line 221
        (*(m___0->xxt + (i___3 * (m___0->xxh)->chn + j___0)))->rows = (*(m___0->xxp + i___3))->rows;
#line 221
        j___0 ++;
        }
      }
      while_break___9: /* CIL Label */ ;
      }
#line 221
      goto while_break___8;
    }
    while_break___8: /* CIL Label */ ;
    }
#line 222
    j = 0;
    {
#line 222
    while (1) {
      while_continue___10: /* CIL Label */ ;
#line 222
      if (! (j < 256)) {
#line 222
        goto while_break___10;
      }
      {
#line 223
      event = & (*(m___0->xxt + (*(m___0->xxp + i___3))->info[j & 3].index))->event[j >> 2];
#line 224
      fread((void */* __restrict  */)(ims_event), (size_t )1, (size_t )3, (FILE */* __restrict  */)f);
#line 235
      event->note = (uint8 )((int )ims_event[0] & 63);
      }
#line 236
      if ((int )event->note != 0) {
#line 236
        if ((int )event->note != 63) {
#line 237
          event->note = (uint8 )((int )event->note + xpo);
        } else {
#line 239
          event->note = (uint8 )0;
        }
      } else {
#line 239
        event->note = (uint8 )0;
      }
      {
#line 240
      event->ins = (uint8 )((((int )ims_event[0] & 64) >> 2) | (((int )ims_event[1] & 240) >> 4));
#line 241
      event->fxt = (uint8 )((int )ims_event[1] & 15);
#line 242
      event->fxp = ims_event[2];
#line 244
      disable_continue_fx(event);
      }
#line 253
      if ((int )event->fxt == 13) {
#line 254
        event->fxp = (uint8 )(((int )event->fxp / 10 << 4) | (int )event->fxp % 10);
      }
#line 222
      j ++;
    }
    while_break___10: /* CIL Label */ ;
    }
    {
#line 256
    reportv(ctx___0, 0, (char *)".");
#line 218
    i___3 ++;
    }
  }
  while_break___6: /* CIL Label */ ;
  }
  {
#line 259
  (m___0->xxh)->flg |= 2;
#line 263
  reportv(ctx___0, 0, (char *)"\nStored samples : %d ", (m___0->xxh)->smp);
#line 264
  i___3 = 0;
  }
  {
#line 264
  while (1) {
    while_continue___11: /* CIL Label */ ;
#line 264
    if (! (i___3 < (m___0->xxh)->smp)) {
#line 264
      goto while_break___11;
    }
#line 265
    if (! (m___0->xxs + i___3)->len) {
#line 266
      goto __Cont;
    }
    {
#line 267
    xmp_drv_loadpatch(ctx___0, f, (*(m___0->xxi + i___3) + 0)->sid, m___0->c4rate,
                      0, m___0->xxs + (*(m___0->xxi + i___3) + 0)->sid, (char *)((void *)0));
#line 269
    reportv(ctx___0, 0, (char *)".");
    }
    __Cont: /* CIL Label */ 
#line 264
    i___3 ++;
  }
  while_break___11: /* CIL Label */ ;
  }
  {
#line 271
  reportv(ctx___0, 0, (char *)"\n");
  }
#line 273
  return (0);
}
}
#line 23 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/liq_load.c"
static int liq_test(FILE *f , char *t , int const   start ) ;
#line 24
static int liq_load(struct xmp_context *ctx___0 , FILE *f , int const   start ) ;
#line 26 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/liq_load.c"
struct xmp_loader_info liq_loader  =    {(char *)"LIQ", (char *)"Liquid Tracker", & liq_test, & liq_load, 0, {(struct list_head *)0,
                                                                         (struct list_head *)0}};
#line 33 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/liq_load.c"
static int liq_test(FILE *f , char *t , int const   start ) 
{ 
  char buf___1[15] ;
  int tmp ;
  void *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
  {
#line 37
  fread((void */* __restrict  */)(buf___1), (size_t )1, (size_t )15, (FILE */* __restrict  */)f);
#line 38
  tmp = memcmp((void const   *)(buf___1), (void const   *)"Liquid Module:", (size_t )14);
  }
#line 38
  if (tmp) {
#line 39
    return (-1);
  }
  {
#line 41
  read_title(f, t, 30);
  }
#line 43
  return (0);
}
}
#line 50 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/liq_load.c"
static uint8 fx___0[25]  = 
#line 50
  {      (uint8 )0,      (uint8 )171,      (uint8 )13,      (uint8 )2, 
        (uint8 )255,      (uint8 )172,      (uint8 )255,      (uint8 )255, 
        (uint8 )255,      (uint8 )11,      (uint8 )255,      (uint8 )10, 
        (uint8 )14,      (uint8 )3,      (uint8 )9,      (uint8 )255, 
        (uint8 )255,      (uint8 )255,      (uint8 )163,      (uint8 )7, 
        (uint8 )1,      (uint8 )4,      (uint8 )255,      (uint8 )5, 
        (uint8 )6};
#line 80 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/liq_load.c"
static void xlat_fx___1(int c___0 , struct xxm_event *e ) 
{ 
  uint8 h ;
  uint8 l ;
  uint8 tmp ;
  uint8 tmp___0 ;
  uint8 tmp___1 ;

  {
#line 82
  h = (uint8 )(((int )e->fxp & 240) >> 4);
#line 82
  l = (uint8 )((int )e->fxp & 15);
#line 84
  tmp = fx___0[e->fxt];
#line 84
  e->fxt = tmp;
  {
#line 85
  if ((int )tmp == 14) {
#line 85
    goto case_14;
  }
#line 116
  if ((int )tmp == 255) {
#line 116
    goto case_255;
  }
#line 84
  goto switch_break;
  case_14: /* CIL Label */ 
  {
#line 87
  if ((int )h == 3) {
#line 87
    goto case_3;
  }
#line 90
  if ((int )h == 4) {
#line 90
    goto case_4;
  }
#line 93
  if ((int )h == 5) {
#line 93
    goto case_5;
  }
#line 96
  if ((int )h == 6) {
#line 96
    goto case_6;
  }
#line 99
  if ((int )h == 7) {
#line 99
    goto case_7;
  }
#line 102
  if ((int )h == 12) {
#line 102
    goto case_12;
  }
#line 105
  if ((int )h == 13) {
#line 105
    goto case_13;
  }
#line 108
  if ((int )h == 14) {
#line 108
    goto case_14___0;
  }
#line 111
  goto switch_default;
  case_3: /* CIL Label */ 
#line 88
  e->fxp = (uint8 )((int )l | (3 << 4));
#line 89
  goto switch_break___0;
  case_4: /* CIL Label */ 
#line 91
  e->fxp = (uint8 )((int )l | (4 << 4));
#line 92
  goto switch_break___0;
  case_5: /* CIL Label */ 
#line 94
  e->fxp = (uint8 )((int )l | (5 << 4));
#line 95
  goto switch_break___0;
  case_6: /* CIL Label */ 
#line 97
  e->fxp = (uint8 )((int )l | (6 << 4));
#line 98
  goto switch_break___0;
  case_7: /* CIL Label */ 
#line 100
  e->fxp = (uint8 )((int )l | (7 << 4));
#line 101
  goto switch_break___0;
  case_12: /* CIL Label */ 
#line 103
  e->fxp = (uint8 )((int )l | (12 << 4));
#line 104
  goto switch_break___0;
  case_13: /* CIL Label */ 
#line 106
  e->fxp = (uint8 )((int )l | (13 << 4));
#line 107
  goto switch_break___0;
  case_14___0: /* CIL Label */ 
#line 109
  e->fxp = (uint8 )((int )l | (14 << 4));
#line 110
  goto switch_break___0;
  switch_default: /* CIL Label */ 
#line 112
  tmp___0 = (uint8 )0;
#line 112
  e->fxp = tmp___0;
#line 112
  e->fxt = tmp___0;
#line 113
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
#line 115
  goto switch_break;
  case_255: /* CIL Label */ 
#line 117
  tmp___1 = (uint8 )0;
#line 117
  e->fxp = tmp___1;
#line 117
  e->fxt = tmp___1;
#line 118
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 120
  return;
}
}
#line 123 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/liq_load.c"
static void decode_event(uint8 x1 , struct xxm_event *event , FILE *f ) 
{ 
  uint8 x2 ;
  uint8 tmp ;
  uint8 tmp___0 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;

  {
  {
#line 127
  memset((void *)event, 0, (size_t )sizeof(struct xxm_event ));
  }
#line 129
  if ((int )x1 & 1) {
    {
#line 130
    x2 = read8(f);
    }
#line 131
    if ((int )x2 == 254) {
#line 132
      event->note = (uint8 )129;
    } else {
#line 134
      event->note = (uint8 )(((int )x2 + 1) + 24);
    }
  }
#line 137
  if ((int )x1 & 2) {
    {
#line 138
    tmp = read8(f);
#line 138
    event->ins = (uint8 )((int )tmp + 1);
    }
  }
#line 140
  if ((int )x1 & 4) {
    {
#line 141
    event->vol = read8(f);
    }
  }
#line 143
  if ((int )x1 & 8) {
    {
#line 144
    tmp___0 = read8(f);
#line 144
    event->fxt = (uint8 )((int )tmp___0 - 65);
    }
  }
#line 146
  if ((int )x1 & 16) {
    {
#line 147
    event->fxp = read8(f);
    }
  }
  {
#line 149
  while (1) {
    while_continue: /* CIL Label */ ;
#line 149
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 152
  if (! ((int )event->note <= 107)) {
#line 152
    if (! ((int )event->note == 129)) {
      {
#line 152
      __assert_fail("event->note <= 107 || event->note == 0x81", "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/liq_load.c",
                    152U, "decode_event");
      }
    }
  }
#line 153
  if (! ((int )event->ins <= 100)) {
    {
#line 153
    __assert_fail("event->ins <= 100", "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/liq_load.c",
                  153U, "decode_event");
    }
  }
#line 154
  if (! ((int )event->vol <= 64)) {
    {
#line 154
    __assert_fail("event->vol <= 64", "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/liq_load.c",
                  154U, "decode_event");
    }
  }
#line 155
  if (! ((int )event->fxt <= 26)) {
    {
#line 155
    __assert_fail("event->fxt <= 26", "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/liq_load.c",
                  155U, "decode_event");
    }
  }
#line 156
  return;
}
}
#line 158 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/liq_load.c"
static int liq_load(struct xmp_context *ctx___0 , FILE *f , int const   start ) 
{ 
  struct xmp_player_context *p ;
  struct xmp_mod_context *m___0 ;
  int i___3 ;
  struct xxm_event *event ;
  struct liq_header lh ;
  struct liq_instrument li ;
  struct liq_pattern lp ;
  uint8 x1 ;
  uint8 x2 ;
  uint32 pmag ;
  char tracker_name[21] ;
  uint8 **tmp ;
  int tmp___0 ;
  uint8 tmp___1 ;
  uint8 tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  int row ;
  int channel ;
  int count ;
  void *tmp___5 ;
  int j ;
  void *tmp___6 ;
  long tmp___7 ;
  long tmp___8 ;
  void *tmp___9 ;
  void *tmp___10 ;
  void *tmp___11 ;
  void *tmp___12 ;
  void *tmp___13 ;
  void *tmp___14 ;
  void *tmp___15 ;
  unsigned char b___1[4] ;
  void *tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  size_t tmp___19 ;
  void *__cil_tmp41 ;
  void *__cil_tmp42 ;
  void *__cil_tmp43 ;
  void *__cil_tmp44 ;
  void *__cil_tmp45 ;
  void *__cil_tmp46 ;
  void *__cil_tmp47 ;
  void *__cil_tmp48 ;
  void *__cil_tmp49 ;
  void *__cil_tmp50 ;
  void *__cil_tmp51 ;
  void *__cil_tmp52 ;
  void *__cil_tmp53 ;
  void *__cil_tmp54 ;
  void *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;
  char *__cil_tmp66 ;
  char *__cil_tmp67 ;
  char *__cil_tmp68 ;
  char *__cil_tmp69 ;
  char *__cil_tmp70 ;
  char *__cil_tmp71 ;
  char *__cil_tmp72 ;
  char *__cil_tmp73 ;
  char *__cil_tmp74 ;
  char *__cil_tmp75 ;
  char *__cil_tmp76 ;
  char *__cil_tmp77 ;
  char *__cil_tmp78 ;
  char *__cil_tmp79 ;
  char *__cil_tmp80 ;
  char *__cil_tmp81 ;
  char *__cil_tmp82 ;
  char *__cil_tmp83 ;
  char *__cil_tmp84 ;
  char *__cil_tmp85 ;
  char *__cil_tmp86 ;
  char *__cil_tmp87 ;
  char *__cil_tmp88 ;
  char *__cil_tmp89 ;
  char *__cil_tmp90 ;
  char *__cil_tmp91 ;
  char *__cil_tmp92 ;
  char *__cil_tmp93 ;
  char *__cil_tmp94 ;
  char *__cil_tmp95 ;
  char *__cil_tmp96 ;
  char *__cil_tmp97 ;

  {
#line 160
  p = & ctx___0->p;
#line 161
  m___0 = & p->m;
#line 163
  event = (struct xxm_event *)((void *)0);
  {
#line 171
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 171
    fseek(f, (long )start, 0);
#line 171
    tmp = (uint8 **)((void *)0);
#line 171
    m___0->med_wav_table = tmp;
#line 171
    m___0->med_vol_table = tmp;
#line 171
    set_xxh_defaults(m___0->xxh);
    }
#line 171
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 173
  fread((void */* __restrict  */)(& lh.magic), (size_t )14, (size_t )1, (FILE */* __restrict  */)f);
#line 174
  fread((void */* __restrict  */)(& lh.name), (size_t )30, (size_t )1, (FILE */* __restrict  */)f);
#line 175
  fread((void */* __restrict  */)(& lh.author), (size_t )20, (size_t )1, (FILE */* __restrict  */)f);
#line 176
  read8(f);
#line 177
  fread((void */* __restrict  */)(& lh.tracker), (size_t )20, (size_t )1, (FILE */* __restrict  */)f);
#line 179
  lh.version = read16l(f);
#line 180
  lh.speed = read16l(f);
#line 181
  lh.bpm = read16l(f);
#line 182
  lh.low = read16l(f);
#line 183
  lh.high = read16l(f);
#line 184
  lh.chn = read16l(f);
#line 185
  lh.flags = read32l(f);
#line 186
  lh.pat = read16l(f);
#line 187
  lh.ins = read16l(f);
#line 188
  lh.len = read16l(f);
#line 189
  lh.hdrsz = read16l(f);
  }
#line 191
  if ((int )lh.version >> 8 == 0) {
    {
#line 192
    lh.hdrsz = lh.len;
#line 193
    lh.len = (uint16 )0;
#line 194
    fseek(f, -2L, 1);
    }
  }
  {
#line 197
  (m___0->xxh)->tpo = (int )lh.speed;
#line 198
  (m___0->xxh)->bpm = (int )lh.bpm;
#line 199
  (m___0->xxh)->chn = (int )lh.chn;
#line 200
  (m___0->xxh)->pat = (int )lh.pat;
#line 201
  tmp___0 = (int )lh.ins;
#line 201
  (m___0->xxh)->smp = tmp___0;
#line 201
  (m___0->xxh)->ins = tmp___0;
#line 202
  (m___0->xxh)->len = (int )lh.len;
#line 203
  (m___0->xxh)->trk = (m___0->xxh)->chn * (m___0->xxh)->pat;
#line 204
  (m___0->xxh)->flg = 4;
#line 206
  strncpy((char */* __restrict  */)(m___0->name), (char const   */* __restrict  */)((char *)(lh.name)),
          (size_t )30);
#line 207
  strncpy((char */* __restrict  */)(tracker_name), (char const   */* __restrict  */)((char *)(lh.tracker)),
          (size_t )20);
#line 208
  strncpy((char */* __restrict  */)(m___0->author), (char const   */* __restrict  */)((char *)(lh.author)),
          (size_t )20);
#line 209
  tracker_name[20] = (char)0;
#line 210
  i___3 = 20;
  }
  {
#line 210
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 210
    if (! (i___3 >= 0)) {
#line 210
      goto while_break___0;
    }
#line 211
    if ((int )tracker_name[i___3] == 32) {
#line 212
      tracker_name[i___3] = (char)0;
    }
#line 213
    if (tracker_name[i___3]) {
#line 214
      goto while_break___0;
    }
#line 210
    i___3 --;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 216
  snprintf((char */* __restrict  */)(m___0->type), (size_t )64, (char const   */* __restrict  */)"LIQ %d.%02d (%s)",
           (int )lh.version >> 8, (int )lh.version & 255, tracker_name);
  }
#line 219
  if ((int )lh.version > 0) {
#line 220
    i___3 = 0;
    {
#line 220
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 220
      if (! (i___3 < (m___0->xxh)->chn)) {
#line 220
        goto while_break___1;
      }
      {
#line 221
      tmp___1 = read8(f);
#line 221
      m___0->xxc[i___3].pan = (int )tmp___1 << 2;
#line 220
      i___3 ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 223
    i___3 = 0;
    {
#line 223
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 223
      if (! (i___3 < (m___0->xxh)->chn)) {
#line 223
        goto while_break___2;
      }
      {
#line 224
      tmp___2 = read8(f);
#line 224
      m___0->xxc[i___3].vol = (int )tmp___2;
#line 223
      i___3 ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 226
    fread((void */* __restrict  */)(m___0->xxo), (size_t )1, (size_t )(m___0->xxh)->len,
          (FILE */* __restrict  */)f);
#line 229
    fseek(f, (long )((int )lh.hdrsz - ((109 + (m___0->xxh)->chn * 2) + (m___0->xxh)->len)),
          1);
    }
  } else {
    {
#line 231
    fseek(f, (long )(start + 240), 0);
#line 232
    fread((void */* __restrict  */)(m___0->xxo), (size_t )1, (size_t )256, (FILE */* __restrict  */)f);
#line 233
    fseek(f, (long )(start + (int const   )lh.hdrsz), 0);
#line 235
    i___3 = 0;
    }
    {
#line 235
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 235
      if (! (i___3 < 256)) {
#line 235
        goto while_break___3;
      }
#line 236
      if ((int )m___0->xxo[i___3] == 255) {
#line 237
        goto while_break___3;
      }
#line 235
      i___3 ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 239
    (m___0->xxh)->len = i___3;
  }
  {
#line 242
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 242
    if (m___0->verbosity) {
#line 242
      if (m___0->name[0]) {
        {
#line 242
        report((char *)"Module title   : %s\n", m___0->name);
        }
      }
#line 242
      if (m___0->type[0]) {
        {
#line 242
        report((char *)"Module type    : %s\n", m___0->type);
        }
      }
#line 242
      if (m___0->author[0]) {
        {
#line 242
        report((char *)"Author name    : %s\n", m___0->author);
        }
      }
#line 242
      if ((m___0->xxh)->len) {
        {
#line 242
        report((char *)"Module length  : %d patterns\n", (m___0->xxh)->len);
        }
      }
    }
#line 242
    goto while_break___4;
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 245
  while (1) {
    while_continue___5: /* CIL Label */ ;
    {
#line 245
    tmp___3 = calloc((size_t )sizeof(struct xxm_track *), (size_t )(m___0->xxh)->trk);
#line 245
    m___0->xxt = (struct xxm_track **)tmp___3;
#line 245
    tmp___4 = calloc((size_t )sizeof(struct xxm_pattern *), (size_t )((m___0->xxh)->pat + 1));
#line 245
    m___0->xxp = (struct xxm_pattern **)tmp___4;
    }
#line 245
    goto while_break___5;
  }
  while_break___5: /* CIL Label */ ;
  }
  {
#line 249
  reportv(ctx___0, 0, (char *)"Stored patterns: %d ", (m___0->xxh)->pat);
#line 251
  x2 = (uint8 )0;
#line 251
  x1 = x2;
#line 252
  i___3 = 0;
  }
  {
#line 252
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 252
    if (! (i___3 < (m___0->xxh)->pat)) {
#line 252
      goto while_break___6;
    }
    {
#line 255
    while (1) {
      while_continue___7: /* CIL Label */ ;
      {
#line 255
      tmp___5 = calloc((size_t )1, (size_t )(sizeof(struct xxm_pattern ) + sizeof(struct xxm_trackinfo ) * (unsigned long )((m___0->xxh)->chn - 1)));
#line 255
      *(m___0->xxp + i___3) = (struct xxm_pattern *)tmp___5;
      }
#line 255
      goto while_break___7;
    }
    while_break___7: /* CIL Label */ ;
    }
    {
#line 256
    pmag = read32b(f);
    }
#line 257
    if (pmag == 555819297U) {
#line 258
      goto __Cont;
    }
#line 259
    if (! (pmag == 1280311296U)) {
      {
#line 259
      __assert_fail("pmag == 0x4c500000", "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/liq_load.c",
                    259U, "liq_load");
      }
    }
    {
#line 261
    fread((void */* __restrict  */)(& lp.name), (size_t )30, (size_t )1, (FILE */* __restrict  */)f);
#line 262
    lp.rows = read16l(f);
#line 263
    lp.size = read32l(f);
#line 264
    lp.reserved = read32l(f);
    }
    {
#line 266
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 266
      goto while_break___8;
    }
    while_break___8: /* CIL Label */ ;
    }
#line 267
    (*(m___0->xxp + i___3))->rows = (int )lp.rows;
    {
#line 268
    while (1) {
      while_continue___9: /* CIL Label */ ;
#line 268
      j = 0;
      {
#line 268
      while (1) {
        while_continue___10: /* CIL Label */ ;
#line 268
        if (! (j < (m___0->xxh)->chn)) {
#line 268
          goto while_break___10;
        }
        {
#line 268
        (*(m___0->xxp + i___3))->info[j].index = i___3 * (m___0->xxh)->chn + j;
#line 268
        tmp___6 = calloc((size_t )(sizeof(struct xxm_track ) + sizeof(struct xxm_event ) * (unsigned long )(*(m___0->xxp + i___3))->rows),
                         (size_t )1);
#line 268
        *(m___0->xxt + (i___3 * (m___0->xxh)->chn + j)) = (struct xxm_track *)tmp___6;
#line 268
        (*(m___0->xxt + (i___3 * (m___0->xxh)->chn + j)))->rows = (*(m___0->xxp + i___3))->rows;
#line 268
        j ++;
        }
      }
      while_break___10: /* CIL Label */ ;
      }
#line 268
      goto while_break___9;
    }
    while_break___9: /* CIL Label */ ;
    }
    {
#line 270
    row = 0;
#line 271
    channel = 0;
#line 272
    tmp___7 = ftell(f);
#line 272
    count = (int )tmp___7;
    }
    read_event: 
#line 283
    event = & (*(m___0->xxt + (*(m___0->xxp + i___3))->info[channel].index))->event[row];
#line 285
    if (x2) {
      {
#line 286
      decode_event(x1, event, f);
#line 287
      xlat_fx___1(channel, event);
#line 288
      x2 = (uint8 )((int )x2 - 1);
      }
#line 289
      goto next_row;
    }
    {
#line 292
    x1 = read8(f);
    }
    test_event: 
#line 295
    event = & (*(m___0->xxt + (*(m___0->xxp + i___3))->info[channel].index))->event[row];
    {
#line 296
    while (1) {
      while_continue___11: /* CIL Label */ ;
#line 296
      goto while_break___11;
    }
    while_break___11: /* CIL Label */ ;
    }
    {
#line 300
    if ((int )x1 == 192) {
#line 300
      goto case_192;
    }
#line 304
    if ((int )x1 == 225) {
#line 304
      goto case_225;
    }
#line 309
    if ((int )x1 == 160) {
#line 309
      goto case_160;
    }
#line 318
    if ((int )x1 == 224) {
#line 318
      goto case_224;
    }
#line 323
    if ((int )x1 == 128) {
#line 323
      goto case_128;
    }
#line 299
    goto switch_break;
    case_192: /* CIL Label */ 
    {
#line 301
    while (1) {
      while_continue___12: /* CIL Label */ ;
#line 301
      goto while_break___12;
    }
    while_break___12: /* CIL Label */ ;
    }
    {
#line 302
    tmp___8 = ftell(f);
    }
#line 302
    if (! (tmp___8 - (long )count == (long )lp.size)) {
      {
#line 302
      __assert_fail("ftell (f) - count == lp.size", "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/liq_load.c",
                    302U, "liq_load");
      }
    }
#line 303
    goto next_pattern;
    case_225: /* CIL Label */ 
    {
#line 305
    x1 = read8(f);
#line 306
    channel += (int )x1;
    }
    {
#line 307
    while (1) {
      while_continue___13: /* CIL Label */ ;
#line 307
      goto while_break___13;
    }
    while_break___13: /* CIL Label */ ;
    }
    case_160: /* CIL Label */ 
    {
#line 310
    while (1) {
      while_continue___14: /* CIL Label */ ;
#line 310
      goto while_break___14;
    }
    while_break___14: /* CIL Label */ ;
    }
#line 311
    channel ++;
#line 312
    if (channel >= (m___0->xxh)->chn) {
      {
#line 313
      while (1) {
        while_continue___15: /* CIL Label */ ;
#line 313
        goto while_break___15;
      }
      while_break___15: /* CIL Label */ ;
      }
#line 314
      channel --;
    }
#line 316
    row = -1;
#line 317
    goto next_row;
    case_224: /* CIL Label */ 
    {
#line 319
    x1 = read8(f);
    }
    {
#line 320
    while (1) {
      while_continue___16: /* CIL Label */ ;
#line 320
      goto while_break___16;
    }
    while_break___16: /* CIL Label */ ;
    }
#line 321
    row += (int )x1;
    case_128: /* CIL Label */ 
    {
#line 324
    while (1) {
      while_continue___17: /* CIL Label */ ;
#line 324
      goto while_break___17;
    }
    while_break___17: /* CIL Label */ ;
    }
#line 325
    goto next_row;
    switch_break: /* CIL Label */ ;
    }
#line 328
    if ((int )x1 > 192) {
#line 328
      if ((int )x1 < 224) {
        {
#line 329
        while (1) {
          while_continue___18: /* CIL Label */ ;
#line 329
          goto while_break___18;
        }
        while_break___18: /* CIL Label */ ;
        }
        {
#line 330
        decode_event(x1, event, f);
#line 331
        xlat_fx___1(channel, event);
        }
#line 332
        goto next_row;
      }
    }
#line 335
    if ((int )x1 > 160) {
#line 335
      if ((int )x1 < 192) {
        {
#line 336
        x2 = read8(f);
        }
        {
#line 337
        while (1) {
          while_continue___19: /* CIL Label */ ;
#line 337
          goto while_break___19;
        }
        while_break___19: /* CIL Label */ ;
        }
        {
#line 338
        decode_event(x1, event, f);
#line 339
        xlat_fx___1(channel, event);
        }
#line 340
        goto next_row;
      }
    }
#line 343
    if ((int )x1 > 128) {
#line 343
      if ((int )x1 < 160) {
        {
#line 344
        x2 = read8(f);
        }
        {
#line 345
        while (1) {
          while_continue___20: /* CIL Label */ ;
#line 345
          goto while_break___20;
        }
        while_break___20: /* CIL Label */ ;
        }
        {
#line 346
        decode_event(x1, event, f);
#line 347
        xlat_fx___1(channel, event);
        }
        {
#line 348
        while (1) {
          while_continue___21: /* CIL Label */ ;
#line 348
          if (! x2) {
#line 348
            goto while_break___21;
          }
          {
#line 349
          row ++;
#line 350
          memcpy((void */* __restrict  */)(& (*(m___0->xxt + (*(m___0->xxp + i___3))->info[channel].index))->event[row]),
                 (void const   */* __restrict  */)event, (size_t )sizeof(struct xxm_event ));
#line 351
          x2 = (uint8 )((int )x2 - 1);
          }
        }
        while_break___21: /* CIL Label */ ;
        }
#line 353
        goto next_row;
      }
    }
    {
#line 357
    while (1) {
      while_continue___22: /* CIL Label */ ;
#line 357
      goto while_break___22;
    }
    while_break___22: /* CIL Label */ ;
    }
#line 358
    if ((int )x1 != 255) {
#line 359
      event->note = (uint8 )(25 + (int )x1);
    } else
#line 360
    if ((int )x1 == 254) {
#line 361
      event->note = (uint8 )129;
    }
    {
#line 363
    x1 = read8(f);
    }
#line 364
    if ((int )x1 > 100) {
#line 365
      row ++;
#line 366
      goto test_event;
    }
#line 368
    if ((int )x1 != 255) {
#line 369
      event->ins = (uint8 )((int )x1 + 1);
    }
    {
#line 371
    x1 = read8(f);
    }
#line 372
    if ((int )x1 != 255) {
#line 373
      event->vol = x1;
    }
    {
#line 375
    x1 = read8(f);
    }
#line 376
    if ((int )x1 != 255) {
#line 377
      event->fxt = (uint8 )((int )x1 - 65);
    }
    {
#line 379
    x1 = read8(f);
#line 380
    event->fxp = x1;
    }
#line 382
    if (! ((int )event->fxt <= 26)) {
      {
#line 382
      __assert_fail("event->fxt <= 26", "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/liq_load.c",
                    382U, "liq_load");
      }
    }
    {
#line 384
    xlat_fx___1(channel, event);
    }
    {
#line 386
    while (1) {
      while_continue___23: /* CIL Label */ ;
#line 386
      goto while_break___23;
    }
    while_break___23: /* CIL Label */ ;
    }
#line 389
    if (! ((int )event->note <= 107)) {
#line 389
      if (! ((int )event->note == 129)) {
        {
#line 389
        __assert_fail("event->note <= 107 || event->note == 0x81", "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/liq_load.c",
                      389U, "liq_load");
        }
      }
    }
#line 390
    if (! ((int )event->ins <= 100)) {
      {
#line 390
      __assert_fail("event->ins <= 100", "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/liq_load.c",
                    390U, "liq_load");
      }
    }
#line 391
    if (! ((int )event->vol <= 65)) {
      {
#line 391
      __assert_fail("event->vol <= 65", "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/liq_load.c",
                    391U, "liq_load");
      }
    }
    next_row: 
#line 394
    row ++;
#line 395
    if (row >= (*(m___0->xxp + i___3))->rows) {
#line 396
      row = 0;
#line 397
      x2 = (uint8 )0;
#line 398
      channel ++;
#line 401
      if (channel >= (m___0->xxh)->chn) {
#line 402
        channel = 0;
      }
    }
#line 406
    goto read_event;
    next_pattern: 
    {
#line 409
    reportv(ctx___0, 0, (char *)".");
    }
    __Cont: /* CIL Label */ 
#line 252
    i___3 ++;
  }
  while_break___6: /* CIL Label */ ;
  }
  {
#line 414
  while (1) {
    while_continue___24: /* CIL Label */ ;
    {
#line 414
    tmp___9 = calloc((size_t )sizeof(struct xxm_instrument_header ), (size_t )(m___0->xxh)->ins);
#line 414
    m___0->xxih = (struct xxm_instrument_header *)tmp___9;
#line 414
    tmp___10 = calloc((size_t )sizeof(struct xxm_instrument_map ), (size_t )(m___0->xxh)->ins);
#line 414
    m___0->xxim = (struct xxm_instrument_map *)tmp___10;
#line 414
    tmp___11 = calloc((size_t )sizeof(struct xxm_instrument *), (size_t )(m___0->xxh)->ins);
#line 414
    m___0->xxi = (struct xxm_instrument **)tmp___11;
    }
#line 414
    if ((m___0->xxh)->smp) {
      {
#line 414
      tmp___12 = calloc((size_t )sizeof(struct xxm_sample ), (size_t )(m___0->xxh)->smp);
#line 414
      m___0->xxs = (struct xxm_sample *)tmp___12;
      }
    }
    {
#line 414
    tmp___13 = calloc((size_t )sizeof(uint16 *), (size_t )(m___0->xxh)->ins);
#line 414
    m___0->xxae = (uint16 **)tmp___13;
#line 414
    tmp___14 = calloc((size_t )sizeof(uint16 *), (size_t )(m___0->xxh)->ins);
#line 414
    m___0->xxpe = (uint16 **)tmp___14;
#line 414
    tmp___15 = calloc((size_t )sizeof(uint16 *), (size_t )(m___0->xxh)->ins);
#line 414
    m___0->xxfe = (uint16 **)tmp___15;
    }
#line 414
    goto while_break___24;
  }
  while_break___24: /* CIL Label */ ;
  }
  {
#line 416
  reportv(ctx___0, 0, (char *)"\nInstruments    : %d ", (m___0->xxh)->ins);
#line 418
  reportv(ctx___0, 1, (char *)"\n     Instrument name                Size  Start End Loop Vol   Ver  C2Spd");
#line 421
  i___3 = 0;
  }
  {
#line 421
  while (1) {
    while_continue___25: /* CIL Label */ ;
#line 421
    if (! (i___3 < (m___0->xxh)->ins)) {
#line 421
      goto while_break___25;
    }
    {
#line 424
    tmp___16 = calloc((size_t )sizeof(struct xxm_instrument ), (size_t )1);
#line 424
    *(m___0->xxi + i___3) = (struct xxm_instrument *)tmp___16;
#line 425
    fread((void */* __restrict  */)(& b___1), (size_t )1, (size_t )4, (FILE */* __restrict  */)f);
    }
#line 427
    if ((int )b___1[0] == 63) {
#line 427
      if ((int )b___1[1] == 63) {
#line 427
        if ((int )b___1[2] == 63) {
#line 427
          if ((int )b___1[3] == 63) {
#line 428
            goto __Cont___0;
          }
        }
      }
    }
#line 429
    if ((int )b___1[0] == 76) {
#line 429
      if ((int )b___1[1] == 68) {
#line 429
        if ((int )b___1[2] == 83) {
#line 429
          if (! ((int )b___1[3] == 83)) {
            {
#line 429
            __assert_fail("b[0] == \'L\' && b[1] == \'D\' && b[2] == \'S\' && b[3] == \'S\'",
                          "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/liq_load.c",
                          429U, "liq_load");
            }
          }
        } else {
          {
#line 429
          __assert_fail("b[0] == \'L\' && b[1] == \'D\' && b[2] == \'S\' && b[3] == \'S\'",
                        "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/liq_load.c",
                        429U, "liq_load");
          }
        }
      } else {
        {
#line 429
        __assert_fail("b[0] == \'L\' && b[1] == \'D\' && b[2] == \'S\' && b[3] == \'S\'",
                      "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/liq_load.c",
                      429U, "liq_load");
        }
      }
    } else {
      {
#line 429
      __assert_fail("b[0] == \'L\' && b[1] == \'D\' && b[2] == \'S\' && b[3] == \'S\'",
                    "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/liq_load.c",
                    429U, "liq_load");
      }
    }
    {
#line 430
    while (1) {
      while_continue___26: /* CIL Label */ ;
#line 430
      goto while_break___26;
    }
    while_break___26: /* CIL Label */ ;
    }
    {
#line 432
    li.version = read16l(f);
#line 433
    fread((void */* __restrict  */)(& li.name), (size_t )30, (size_t )1, (FILE */* __restrict  */)f);
#line 434
    fread((void */* __restrict  */)(& li.editor), (size_t )20, (size_t )1, (FILE */* __restrict  */)f);
#line 435
    fread((void */* __restrict  */)(& li.author), (size_t )20, (size_t )1, (FILE */* __restrict  */)f);
#line 436
    li.hw_id = read8(f);
#line 438
    li.length = read32l(f);
#line 439
    li.loopstart = read32l(f);
#line 440
    li.loopend = read32l(f);
#line 441
    li.c2spd = read32l(f);
#line 443
    li.vol = read8(f);
#line 444
    li.flags = read8(f);
#line 445
    li.pan = read8(f);
#line 446
    li.midi_ins = read8(f);
#line 447
    li.gvl = read8(f);
#line 448
    li.chord = read8(f);
#line 450
    li.hdrsz = read16l(f);
#line 451
    li.comp = read16l(f);
#line 452
    li.crc = read32l(f);
#line 454
    li.midi_ch = read8(f);
#line 455
    fread((void */* __restrict  */)(& li.rsvd), (size_t )11, (size_t )1, (FILE */* __restrict  */)f);
#line 456
    fread((void */* __restrict  */)(& li.filename), (size_t )25, (size_t )1, (FILE */* __restrict  */)f);
#line 458
    (m___0->xxih + i___3)->nsm = ! (! li.length);
#line 459
    (m___0->xxih + i___3)->vol = 64;
#line 460
    (m___0->xxs + i___3)->len = (int )li.length;
#line 461
    (m___0->xxs + i___3)->lps = (int )li.loopstart;
#line 462
    (m___0->xxs + i___3)->lpe = (int )li.loopend;
    }
#line 464
    if ((int )li.flags & 1) {
#line 465
      (m___0->xxs + i___3)->flg = 1;
    }
#line 467
    if (li.loopend > 0U) {
#line 468
      (m___0->xxs + i___3)->flg = 4;
    }
    {
#line 472
    li.gvl = (uint8 )64;
#line 474
    (*(m___0->xxi + i___3) + 0)->vol = (int )li.vol;
#line 475
    (*(m___0->xxi + i___3) + 0)->gvl = (int )li.gvl;
#line 476
    (*(m___0->xxi + i___3) + 0)->pan = (int )li.pan;
#line 477
    (*(m___0->xxi + i___3) + 0)->sid = i___3;
#line 479
    copy_adjust((m___0->xxih + i___3)->name, li.name, 32);
    }
#line 481
    if (m___0->verbosity > 1) {
      {
#line 481
      tmp___19 = strlen((char const   *)((char *)((m___0->xxih + i___3)->name)));
      }
#line 481
      if (tmp___19) {
#line 481
        goto _L;
      } else
#line 481
      if ((m___0->xxs + i___3)->len) {
        _L: /* CIL Label */ 
#line 482
        if ((m___0->xxs + i___3)->flg & 4) {
#line 482
          tmp___17 = 'L';
        } else {
#line 482
          tmp___17 = ' ';
        }
#line 482
        if ((m___0->xxs + i___3)->flg & 1) {
#line 482
          tmp___18 = '+';
        } else {
#line 482
          tmp___18 = ' ';
        }
        {
#line 482
        report((char *)"\n[%2X] %-30.30s %05x%c%05x %05x %c %02x %02x %2d.%02d %5d ",
               i___3, (m___0->xxih + i___3)->name, (m___0->xxs + i___3)->len, tmp___18,
               (m___0->xxs + i___3)->lps, (m___0->xxs + i___3)->lpe, tmp___17, (*(m___0->xxi + i___3) + 0)->vol,
               (*(m___0->xxi + i___3) + 0)->gvl, (int )li.version >> 8, (int )li.version & 255,
               li.c2spd);
        }
      }
    }
    {
#line 491
    c2spd_to_note((int )li.c2spd, & (*(m___0->xxi + i___3) + 0)->xpo, & (*(m___0->xxi + i___3) + 0)->fin);
#line 492
    fseek(f, (long )((int )li.hdrsz - 144), 1);
    }
#line 494
    if (! (m___0->xxs + i___3)->len) {
#line 495
      goto __Cont___0;
    }
    {
#line 496
    xmp_drv_loadpatch(ctx___0, f, (*(m___0->xxi + i___3) + 0)->sid, m___0->c4rate,
                      0, m___0->xxs + i___3, (char *)((void *)0));
#line 497
    reportv(ctx___0, 0, (char *)".");
    }
    __Cont___0: /* CIL Label */ 
#line 421
    i___3 ++;
  }
  while_break___25: /* CIL Label */ ;
  }
  {
#line 499
  reportv(ctx___0, 0, (char *)"\n");
  }
#line 501
  return (0);
}
}
#line 24 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/hsc_load.c"
static int hsc_test(FILE *f , char *t , int const   start ) ;
#line 25
static int hsc_load(struct xmp_context *ctx___0 , FILE *f , int const   start ) ;
#line 27 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/hsc_load.c"
struct xmp_loader_info hsc_loader  =    {(char *)"HSC", (char *)"HSC-Tracker", & hsc_test, & hsc_load, 0, {(struct list_head *)0,
                                                                      (struct list_head *)0}};
#line 34 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/hsc_load.c"
static int hsc_test(FILE *f , char *t , int const   start ) 
{ 
  int p ;
  int i___3 ;
  int r ;
  int c___0 ;
  uint8 buf___1[1200] ;
  size_t tmp ;
  uint8 n___0 ;
  uint8 m___0 ;
  void *__cil_tmp12 ;

  {
  {
#line 39
  fseek(f, 1536L, 1);
#line 41
  tmp = fread((void */* __restrict  */)(buf___1), (size_t )1, (size_t )51, (FILE */* __restrict  */)f);
  }
#line 41
  if (tmp != 51U) {
#line 42
    return (-1);
  }
#line 44
  i___3 = 0;
#line 44
  p = i___3;
  {
#line 44
  while (1) {
    while_continue: /* CIL Label */ ;
#line 44
    if (! (i___3 < 51)) {
#line 44
      goto while_break;
    }
#line 45
    if ((int )buf___1[i___3] == 255) {
#line 46
      goto while_break;
    }
#line 47
    if ((int )buf___1[i___3] > p) {
#line 48
      p = (int )buf___1[i___3];
    }
#line 44
    i___3 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 50
  if (! i___3) {
#line 51
    return (-1);
  } else
#line 50
  if (! p) {
#line 51
    return (-1);
  } else
#line 50
  if (i___3 > 50) {
#line 51
    return (-1);
  } else
#line 50
  if (p > 50) {
#line 51
    return (-1);
  }
#line 53
  i___3 = 0;
  {
#line 53
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 53
    if (! (i___3 < p)) {
#line 53
      goto while_break___0;
    }
    {
#line 54
    fread((void */* __restrict  */)(buf___1), (size_t )1, (size_t )1152, (FILE */* __restrict  */)f);
#line 55
    r = 0;
    }
    {
#line 55
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 55
      if (! (r < 64)) {
#line 55
        goto while_break___1;
      }
#line 56
      c___0 = 0;
      {
#line 56
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 56
        if (! (c___0 < 9)) {
#line 56
          goto while_break___2;
        }
#line 57
        n___0 = buf___1[(r * 9) * 2 + c___0 * 2];
#line 58
        m___0 = buf___1[((r * 9) * 2 + c___0 * 2) + 1];
#line 59
        if ((int )m___0 > 6) {
#line 59
          if ((int )m___0 < 16) {
#line 59
            if ((int )n___0 != 128) {
#line 60
              return (-1);
            }
          }
        }
#line 61
        if (((int )m___0 & 240) >> 4 > 6) {
#line 61
          if (((int )m___0 & 240) >> 4 < 10) {
#line 62
            return (-1);
          }
        }
#line 56
        c___0 ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 55
      r ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 53
    i___3 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 67
  read_title(f, t, 0);
  }
#line 69
  return (0);
}
}
#line 72 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/hsc_load.c"
static int hsc_load(struct xmp_context *ctx___0 , FILE *f , int const   start ) 
{ 
  struct xmp_player_context *p ;
  struct xmp_mod_context *m___0 ;
  int pat___0 ;
  int i___3 ;
  int r ;
  int c___0 ;
  struct xxm_event *event ;
  uint8 *x ;
  uint8 *sid ;
  uint8 e[2] ;
  uint8 buf___1[1536] ;
  uint8 **tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  int j ;
  int x___0 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  void *tmp___16 ;
  void *tmp___17 ;
  int ins[9] ;
  void *tmp___18 ;
  int j___0 ;
  void *tmp___19 ;
  void *__cil_tmp40 ;
  void *__cil_tmp41 ;
  void *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;

  {
#line 74
  p = & ctx___0->p;
#line 75
  m___0 = & p->m;
  {
#line 80
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 80
    fseek(f, (long )start, 0);
#line 80
    tmp = (uint8 **)((void *)0);
#line 80
    m___0->med_wav_table = tmp;
#line 80
    m___0->med_vol_table = tmp;
#line 80
    set_xxh_defaults(m___0->xxh);
    }
#line 80
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 82
  fread((void */* __restrict  */)(buf___1), (size_t )1, (size_t )1536, (FILE */* __restrict  */)f);
#line 84
  x = buf___1;
#line 85
  i___3 = 0;
  }
  {
#line 85
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 85
    if (! (i___3 < 128)) {
#line 85
      goto while_break___0;
    }
#line 86
    if ((int )*(x + 9) & -4) {
#line 87
      goto while_break___0;
    } else
#line 86
    if ((int )*(x + 10) & -4) {
#line 87
      goto while_break___0;
    }
#line 88
    if ((int )*(x + 8) & -16) {
#line 89
      goto while_break___0;
    }
#line 85
    i___3 ++;
#line 85
    x += 12;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 92
  (m___0->xxh)->ins = i___3;
#line 94
  fseek(f, (long )start, 0);
#line 96
  (m___0->xxh)->chn = 9;
#line 97
  (m___0->xxh)->bpm = 135;
#line 98
  (m___0->xxh)->tpo = 6;
#line 99
  (m___0->xxh)->smp = 0;
#line 100
  (m___0->xxh)->flg = 1;
#line 102
  sprintf((char */* __restrict  */)(m___0->type), (char const   */* __restrict  */)"HSC (HSC-Tracker)");
  }
  {
#line 104
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 104
    if (m___0->verbosity) {
#line 104
      if (m___0->name[0]) {
        {
#line 104
        report((char *)"Module title   : %s\n", m___0->name);
        }
      }
#line 104
      if (m___0->type[0]) {
        {
#line 104
        report((char *)"Module type    : %s\n", m___0->type);
        }
      }
#line 104
      if (m___0->author[0]) {
        {
#line 104
        report((char *)"Author name    : %s\n", m___0->author);
        }
      }
#line 104
      if ((m___0->xxh)->len) {
        {
#line 104
        report((char *)"Module length  : %d patterns\n", (m___0->xxh)->len);
        }
      }
    }
#line 104
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 106
  reportv(ctx___0, 1, (char *)"               Modulator                       Carrier               Common\n     Char Fr LS OL At De Su Re WS   Char Fr LS OL At De Su Re WS   Fbk Alg Fin\n");
  }
  {
#line 111
  while (1) {
    while_continue___2: /* CIL Label */ ;
    {
#line 111
    tmp___0 = calloc((size_t )sizeof(struct xxm_instrument_header ), (size_t )(m___0->xxh)->ins);
#line 111
    m___0->xxih = (struct xxm_instrument_header *)tmp___0;
#line 111
    tmp___1 = calloc((size_t )sizeof(struct xxm_instrument_map ), (size_t )(m___0->xxh)->ins);
#line 111
    m___0->xxim = (struct xxm_instrument_map *)tmp___1;
#line 111
    tmp___2 = calloc((size_t )sizeof(struct xxm_instrument *), (size_t )(m___0->xxh)->ins);
#line 111
    m___0->xxi = (struct xxm_instrument **)tmp___2;
    }
#line 111
    if ((m___0->xxh)->smp) {
      {
#line 111
      tmp___3 = calloc((size_t )sizeof(struct xxm_sample ), (size_t )(m___0->xxh)->smp);
#line 111
      m___0->xxs = (struct xxm_sample *)tmp___3;
      }
    }
    {
#line 111
    tmp___4 = calloc((size_t )sizeof(uint16 *), (size_t )(m___0->xxh)->ins);
#line 111
    m___0->xxae = (uint16 **)tmp___4;
#line 111
    tmp___5 = calloc((size_t )sizeof(uint16 *), (size_t )(m___0->xxh)->ins);
#line 111
    m___0->xxpe = (uint16 **)tmp___5;
#line 111
    tmp___6 = calloc((size_t )sizeof(uint16 *), (size_t )(m___0->xxh)->ins);
#line 111
    m___0->xxfe = (uint16 **)tmp___6;
    }
#line 111
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 113
  fread((void */* __restrict  */)(buf___1), (size_t )1, (size_t )1536, (FILE */* __restrict  */)f);
#line 114
  sid = buf___1;
#line 115
  i___3 = 0;
  }
  {
#line 115
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 115
    if (! (i___3 < (m___0->xxh)->ins)) {
#line 115
      goto while_break___3;
    }
    {
#line 116
    xmp_cvt_hsc2sbi((char *)sid);
#line 118
    tmp___7 = calloc((size_t )sizeof(struct xxm_instrument ), (size_t )1);
#line 118
    *(m___0->xxi + i___3) = (struct xxm_instrument *)tmp___7;
#line 119
    (m___0->xxih + i___3)->nsm = 1;
#line 120
    (*(m___0->xxi + i___3) + 0)->vol = 64;
#line 121
    (*(m___0->xxi + i___3) + 0)->fin = (int )((int8 )*(sid + 11)) / 4;
#line 122
    (*(m___0->xxi + i___3) + 0)->pan = 128;
#line 123
    (*(m___0->xxi + i___3) + 0)->xpo = 0;
#line 124
    (*(m___0->xxi + i___3) + 0)->sid = i___3;
#line 125
    (m___0->xxih + i___3)->rls = ((int )*(sid + 7) & 15) * 32;
    }
#line 127
    if (m___0->verbosity > 1) {
#line 130
      x___0 = 0;
#line 130
      j = x___0;
      {
#line 130
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 130
        if (! (j < 12)) {
#line 130
          goto while_break___4;
        }
#line 131
        x___0 |= (int )*(sid + j);
#line 130
        j ++;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 133
      if (! x___0) {
#line 134
        goto skip;
      }
      {
#line 136
      report((char *)"[%2X] ", i___3);
      }
#line 138
      if ((int )*(sid + 0) & 16) {
#line 138
        tmp___8 = 'e';
      } else {
#line 138
        tmp___8 = '-';
      }
#line 138
      if ((int )*(sid + 0) & 32) {
#line 138
        tmp___9 = 's';
      } else {
#line 138
        tmp___9 = '-';
      }
#line 138
      if ((int )*(sid + 0) & 64) {
#line 138
        tmp___10 = 'v';
      } else {
#line 138
        tmp___10 = '-';
      }
#line 138
      if ((int )*(sid + 0) & 128) {
#line 138
        tmp___11 = 'a';
      } else {
#line 138
        tmp___11 = '-';
      }
      {
#line 138
      report((char *)"%c%c%c%c %2d ", tmp___11, tmp___10, tmp___9, tmp___8, (int )*(sid + 0) & 15);
#line 142
      report((char *)"%2d %2d ", (int )*(sid + 2) >> 6, (int )*(sid + 2) & 63);
#line 143
      report((char *)"%2d %2d ", (int )*(sid + 4) >> 4, (int )*(sid + 4) & 15);
#line 144
      report((char *)"%2d %2d ", (int )*(sid + 6) >> 4, (int )*(sid + 6) & 15);
#line 145
      report((char *)"%2d   ", (int )*(sid + 8));
      }
#line 147
      if ((int )*(sid + 1) & 16) {
#line 147
        tmp___12 = 'e';
      } else {
#line 147
        tmp___12 = '-';
      }
#line 147
      if ((int )*(sid + 1) & 32) {
#line 147
        tmp___13 = 's';
      } else {
#line 147
        tmp___13 = '-';
      }
#line 147
      if ((int )*(sid + 1) & 64) {
#line 147
        tmp___14 = 'v';
      } else {
#line 147
        tmp___14 = '-';
      }
#line 147
      if ((int )*(sid + 1) & 128) {
#line 147
        tmp___15 = 'a';
      } else {
#line 147
        tmp___15 = '-';
      }
      {
#line 147
      report((char *)"%c%c%c%c %2d ", tmp___15, tmp___14, tmp___13, tmp___12, (int )*(sid + 1) & 15);
#line 151
      report((char *)"%2d %2d ", (int )*(sid + 3) >> 6, (int )*(sid + 3) & 63);
#line 152
      report((char *)"%2d %2d ", (int )*(sid + 5) >> 4, (int )*(sid + 5) & 15);
#line 153
      report((char *)"%2d %2d ", (int )*(sid + 7) >> 4, (int )*(sid + 7) & 15);
#line 154
      report((char *)"%2d   ", (int )*(sid + 9));
#line 156
      report((char *)"%2d  %2d %4d\n", (int )*(sid + 10) >> 1, (int )*(sid + 10) & 1,
             (int )((int8 )*(sid + 11)));
      }
    }
    skip: 
    {
#line 160
    xmp_drv_loadpatch(ctx___0, f, i___3, 0, 0, (struct xxm_sample *)((void *)0), (char *)sid);
#line 115
    i___3 ++;
#line 115
    sid += 12;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
#line 164
  i___3 = 0;
#line 164
  pat___0 = i___3;
  {
#line 164
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 164
    if (! (i___3 < 51)) {
#line 164
      goto while_break___5;
    }
    {
#line 165
    fread((void */* __restrict  */)(& m___0->xxo[i___3]), (size_t )1, (size_t )1,
          (FILE */* __restrict  */)f);
    }
#line 166
    if ((int )m___0->xxo[i___3] & 128) {
#line 167
      goto while_break___5;
    }
#line 168
    if ((int )m___0->xxo[i___3] > pat___0) {
#line 169
      pat___0 = (int )m___0->xxo[i___3];
    }
#line 164
    i___3 ++;
  }
  while_break___5: /* CIL Label */ ;
  }
  {
#line 171
  fseek(f, (long )(50 - i___3), 1);
#line 172
  (m___0->xxh)->len = i___3;
#line 173
  (m___0->xxh)->pat = pat___0 + 1;
#line 174
  (m___0->xxh)->trk = (m___0->xxh)->pat * (m___0->xxh)->chn;
  }
#line 176
  if (m___0->verbosity > 0) {
    {
#line 177
    report((char *)"Module length  : %d patterns\n", (m___0->xxh)->len);
#line 178
    report((char *)"Instruments    : %d\n", (m___0->xxh)->ins);
#line 179
    report((char *)"Stored patterns: %d ", (m___0->xxh)->pat);
    }
  }
  {
#line 181
  while (1) {
    while_continue___6: /* CIL Label */ ;
    {
#line 181
    tmp___16 = calloc((size_t )sizeof(struct xxm_track *), (size_t )(m___0->xxh)->trk);
#line 181
    m___0->xxt = (struct xxm_track **)tmp___16;
#line 181
    tmp___17 = calloc((size_t )sizeof(struct xxm_pattern *), (size_t )((m___0->xxh)->pat + 1));
#line 181
    m___0->xxp = (struct xxm_pattern **)tmp___17;
    }
#line 181
    goto while_break___6;
  }
  while_break___6: /* CIL Label */ ;
  }
#line 184
  i___3 = 0;
  {
#line 184
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 184
    if (! (i___3 < (m___0->xxh)->pat)) {
#line 184
      goto while_break___7;
    }
#line 185
    ins[0] = 1;
#line 185
    ins[1] = 2;
#line 185
    ins[2] = 3;
#line 185
    ins[3] = 4;
#line 185
    ins[4] = 5;
#line 185
    ins[5] = 6;
#line 185
    ins[6] = 7;
#line 185
    ins[7] = 8;
#line 185
    ins[8] = 9;
    {
#line 187
    while (1) {
      while_continue___8: /* CIL Label */ ;
      {
#line 187
      tmp___18 = calloc((size_t )1, (size_t )(sizeof(struct xxm_pattern ) + sizeof(struct xxm_trackinfo ) * (unsigned long )((m___0->xxh)->chn - 1)));
#line 187
      *(m___0->xxp + i___3) = (struct xxm_pattern *)tmp___18;
      }
#line 187
      goto while_break___8;
    }
    while_break___8: /* CIL Label */ ;
    }
#line 188
    (*(m___0->xxp + i___3))->rows = 64;
    {
#line 189
    while (1) {
      while_continue___9: /* CIL Label */ ;
#line 189
      j___0 = 0;
      {
#line 189
      while (1) {
        while_continue___10: /* CIL Label */ ;
#line 189
        if (! (j___0 < (m___0->xxh)->chn)) {
#line 189
          goto while_break___10;
        }
        {
#line 189
        (*(m___0->xxp + i___3))->info[j___0].index = i___3 * (m___0->xxh)->chn + j___0;
#line 189
        tmp___19 = calloc((size_t )(sizeof(struct xxm_track ) + sizeof(struct xxm_event ) * (unsigned long )(*(m___0->xxp + i___3))->rows),
                          (size_t )1);
#line 189
        *(m___0->xxt + (i___3 * (m___0->xxh)->chn + j___0)) = (struct xxm_track *)tmp___19;
#line 189
        (*(m___0->xxt + (i___3 * (m___0->xxh)->chn + j___0)))->rows = (*(m___0->xxp + i___3))->rows;
#line 189
        j___0 ++;
        }
      }
      while_break___10: /* CIL Label */ ;
      }
#line 189
      goto while_break___9;
    }
    while_break___9: /* CIL Label */ ;
    }
#line 190
    r = 0;
    {
#line 190
    while (1) {
      while_continue___11: /* CIL Label */ ;
#line 190
      if (! (r < (*(m___0->xxp + i___3))->rows)) {
#line 190
        goto while_break___11;
      }
#line 191
      c___0 = 0;
      {
#line 191
      while (1) {
        while_continue___12: /* CIL Label */ ;
#line 191
        if (! (c___0 < 9)) {
#line 191
          goto while_break___12;
        }
        {
#line 192
        fread((void */* __restrict  */)(e), (size_t )1, (size_t )2, (FILE */* __restrict  */)f);
#line 193
        event = & (*(m___0->xxt + (*(m___0->xxp + i___3))->info[c___0].index))->event[r];
        }
#line 194
        if ((int )e[0] & 128) {
#line 195
          ins[c___0] = (int )e[1] + 1;
        } else
#line 196
        if ((int )e[0] == 127) {
#line 197
          event->note = (uint8 )129;
        } else
#line 198
        if ((int )e[0] > 0) {
#line 199
          event->note = (uint8 )((int )e[0] + 13);
#line 200
          event->ins = (uint8 )ins[c___0];
        }
#line 203
        event->fxt = (uint8 )0;
#line 204
        event->fxp = (uint8 )0;
#line 206
        if ((int )e[1] == 1) {
#line 207
          event->fxt = (uint8 )13;
#line 208
          event->fxp = (uint8 )0;
        }
#line 191
        c___0 ++;
      }
      while_break___12: /* CIL Label */ ;
      }
#line 190
      r ++;
    }
    while_break___11: /* CIL Label */ ;
    }
    {
#line 212
    reportv(ctx___0, 0, (char *)".");
#line 184
    i___3 ++;
    }
  }
  while_break___7: /* CIL Label */ ;
  }
  {
#line 214
  reportv(ctx___0, 0, (char *)"\n");
#line 216
  i___3 = 0;
  }
  {
#line 216
  while (1) {
    while_continue___13: /* CIL Label */ ;
#line 216
    if (! (i___3 < (m___0->xxh)->chn)) {
#line 216
      goto while_break___13;
    }
#line 217
    m___0->xxc[i___3].pan = 128;
#line 218
    m___0->xxc[i___3].flg = 1;
#line 216
    i___3 ++;
  }
  while_break___13: /* CIL Label */ ;
  }
#line 221
  return (0);
}
}
#line 21 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/ice_load.c"
static int ice_test(FILE *f , char *t , int const   start ) ;
#line 22
static int ice_load(struct xmp_context *ctx___0 , FILE *f , int const   start ) ;
#line 24 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/ice_load.c"
struct xmp_loader_info ice_loader  =    {(char *)"MTN", (char *)"Soundtracker 2.6/Ice Tracker", & ice_test, & ice_load,
    0, {(struct list_head *)0, (struct list_head *)0}};
#line 31 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/ice_load.c"
static int ice_test(FILE *f , char *t , int const   start ) 
{ 
  uint32 magic ;

  {
  {
#line 35
  fseek(f, (long )(start + 1464), 0);
#line 36
  magic = read32b(f);
  }
#line 37
  if (magic != (((77U << 24) | (84U << 16)) | (78U << 8))) {
#line 37
    if (magic != ((((73U << 24) | (84U << 16)) | (49U << 8)) | 48U)) {
#line 38
      return (-1);
    }
  }
  {
#line 40
  fseek(f, (long )start, 0);
#line 41
  read_title(f, t, 28);
  }
#line 43
  return (0);
}
}
#line 66 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/ice_load.c"
static int ice_load(struct xmp_context *ctx___0 , FILE *f , int const   start ) 
{ 
  struct xmp_player_context *p ;
  struct xmp_mod_context *m___0 ;
  int i___3 ;
  int j ;
  struct xxm_event *event ;
  struct ice_header ih ;
  uint8 ev[4] ;
  uint8 **tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  void *tmp___11 ;
  void *tmp___12 ;
  void *tmp___13 ;
  void *tmp___14 ;
  void *__cil_tmp27 ;
  void *__cil_tmp28 ;
  void *__cil_tmp29 ;
  int __cil_tmp30 ;
  void *__cil_tmp31 ;
  void *__cil_tmp32 ;
  void *__cil_tmp33 ;
  int __cil_tmp34 ;
  void *__cil_tmp35 ;
  void *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;

  {
#line 68
  p = & ctx___0->p;
#line 69
  m___0 = & p->m;
  {
#line 75
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 75
    fseek(f, (long )start, 0);
#line 75
    tmp = (uint8 **)((void *)0);
#line 75
    m___0->med_wav_table = tmp;
#line 75
    m___0->med_vol_table = tmp;
#line 75
    set_xxh_defaults(m___0->xxh);
    }
#line 75
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 77
  fread((void */* __restrict  */)(& ih.title), (size_t )20, (size_t )1, (FILE */* __restrict  */)f);
#line 78
  i___3 = 0;
  }
  {
#line 78
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 78
    if (! (i___3 < 31)) {
#line 78
      goto while_break___0;
    }
    {
#line 79
    fread((void */* __restrict  */)(& ih.ins[i___3].name), (size_t )22, (size_t )1,
          (FILE */* __restrict  */)f);
#line 80
    ih.ins[i___3].len = read16b(f);
#line 81
    ih.ins[i___3].finetune = read8(f);
#line 82
    ih.ins[i___3].volume = read8(f);
#line 83
    ih.ins[i___3].loop_start = read16b(f);
#line 84
    ih.ins[i___3].loop_size = read16b(f);
#line 78
    i___3 ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 86
  ih.len = read8(f);
#line 87
  ih.trk = read8(f);
#line 88
  fread((void */* __restrict  */)(& ih.ord), (size_t )512, (size_t )1, (FILE */* __restrict  */)f);
#line 89
  ih.magic = read32b(f);
  }
#line 91
  if (ih.magic == ((((73U << 24) | (84U << 16)) | (49U << 8)) | 48U)) {
    {
#line 92
    strcpy((char */* __restrict  */)(m___0->type), (char const   */* __restrict  */)"IT10 (Ice Tracker)");
    }
  } else
#line 93
  if (ih.magic == (((77U << 24) | (84U << 16)) | (78U << 8))) {
    {
#line 94
    strcpy((char */* __restrict  */)(m___0->type), (char const   */* __restrict  */)"MTN (Soundtracker 2.6)");
    }
  } else {
#line 96
    return (-1);
  }
  {
#line 98
  (m___0->xxh)->ins = 31;
#line 99
  (m___0->xxh)->smp = (m___0->xxh)->ins;
#line 100
  (m___0->xxh)->pat = (int )ih.len;
#line 101
  (m___0->xxh)->len = (int )ih.len;
#line 102
  (m___0->xxh)->trk = (int )ih.trk;
#line 104
  strncpy((char */* __restrict  */)(m___0->name), (char const   */* __restrict  */)(ih.title),
          (size_t )20);
  }
  {
#line 105
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 105
    if (m___0->verbosity) {
#line 105
      if (m___0->name[0]) {
        {
#line 105
        report((char *)"Module title   : %s\n", m___0->name);
        }
      }
#line 105
      if (m___0->type[0]) {
        {
#line 105
        report((char *)"Module type    : %s\n", m___0->type);
        }
      }
#line 105
      if (m___0->author[0]) {
        {
#line 105
        report((char *)"Author name    : %s\n", m___0->author);
        }
      }
#line 105
      if ((m___0->xxh)->len) {
        {
#line 105
        report((char *)"Module length  : %d patterns\n", (m___0->xxh)->len);
        }
      }
    }
#line 105
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 107
  while (1) {
    while_continue___2: /* CIL Label */ ;
    {
#line 107
    tmp___0 = calloc((size_t )sizeof(struct xxm_instrument_header ), (size_t )(m___0->xxh)->ins);
#line 107
    m___0->xxih = (struct xxm_instrument_header *)tmp___0;
#line 107
    tmp___1 = calloc((size_t )sizeof(struct xxm_instrument_map ), (size_t )(m___0->xxh)->ins);
#line 107
    m___0->xxim = (struct xxm_instrument_map *)tmp___1;
#line 107
    tmp___2 = calloc((size_t )sizeof(struct xxm_instrument *), (size_t )(m___0->xxh)->ins);
#line 107
    m___0->xxi = (struct xxm_instrument **)tmp___2;
    }
#line 107
    if ((m___0->xxh)->smp) {
      {
#line 107
      tmp___3 = calloc((size_t )sizeof(struct xxm_sample ), (size_t )(m___0->xxh)->smp);
#line 107
      m___0->xxs = (struct xxm_sample *)tmp___3;
      }
    }
    {
#line 107
    tmp___4 = calloc((size_t )sizeof(uint16 *), (size_t )(m___0->xxh)->ins);
#line 107
    m___0->xxae = (uint16 **)tmp___4;
#line 107
    tmp___5 = calloc((size_t )sizeof(uint16 *), (size_t )(m___0->xxh)->ins);
#line 107
    m___0->xxpe = (uint16 **)tmp___5;
#line 107
    tmp___6 = calloc((size_t )sizeof(uint16 *), (size_t )(m___0->xxh)->ins);
#line 107
    m___0->xxfe = (uint16 **)tmp___6;
    }
#line 107
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 109
  reportv(ctx___0, 1, (char *)"     Instrument name        Len  LBeg LEnd L Vl Ft\n");
#line 111
  i___3 = 0;
  }
  {
#line 111
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 111
    if (! (i___3 < (m___0->xxh)->ins)) {
#line 111
      goto while_break___3;
    }
    {
#line 112
    tmp___7 = calloc((size_t )sizeof(struct xxm_instrument ), (size_t )1);
#line 112
    *(m___0->xxi + i___3) = (struct xxm_instrument *)tmp___7;
#line 113
    tmp___8 = 2 * (int )ih.ins[i___3].len;
#line 113
    (m___0->xxs + i___3)->len = tmp___8;
    }
#line 113
    if (tmp___8) {
#line 113
      tmp___9 = 1;
    } else {
#line 113
      tmp___9 = 0;
    }
#line 113
    (m___0->xxih + i___3)->nsm = tmp___9;
#line 114
    (m___0->xxs + i___3)->lps = 2 * (int )ih.ins[i___3].loop_start;
#line 115
    (m___0->xxs + i___3)->lpe = (m___0->xxs + i___3)->lps + 2 * (int )ih.ins[i___3].loop_size;
#line 116
    if ((int )ih.ins[i___3].loop_size > 1) {
#line 116
      (m___0->xxs + i___3)->flg = 4;
    } else {
#line 116
      (m___0->xxs + i___3)->flg = 0;
    }
#line 117
    (*(m___0->xxi + i___3) + 0)->vol = (int )ih.ins[i___3].volume;
#line 118
    (*(m___0->xxi + i___3) + 0)->fin = (int )((int16 )ih.ins[i___3].finetune) / 72 << 4;
#line 119
    (*(m___0->xxi + i___3) + 0)->pan = 128;
#line 120
    (*(m___0->xxi + i___3) + 0)->sid = i___3;
#line 121
    if (m___0->verbosity > 1) {
#line 121
      if ((m___0->xxs + i___3)->len > 2) {
#line 122
        if ((m___0->xxs + i___3)->flg & 4) {
#line 122
          tmp___10 = 'L';
        } else {
#line 122
          tmp___10 = ' ';
        }
        {
#line 122
        report((char *)"[%2X] %-22.22s %04x %04x %04x %c %02x %+01x\n", i___3, ih.ins[i___3].name,
               (m___0->xxs + i___3)->len, (m___0->xxs + i___3)->lps, (m___0->xxs + i___3)->lpe,
               tmp___10, (*(m___0->xxi + i___3) + 0)->vol, (*(m___0->xxi + i___3) + 0)->fin >> 4);
        }
      }
    }
#line 111
    i___3 ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 128
  while (1) {
    while_continue___4: /* CIL Label */ ;
    {
#line 128
    tmp___11 = calloc((size_t )sizeof(struct xxm_track *), (size_t )(m___0->xxh)->trk);
#line 128
    m___0->xxt = (struct xxm_track **)tmp___11;
#line 128
    tmp___12 = calloc((size_t )sizeof(struct xxm_pattern *), (size_t )((m___0->xxh)->pat + 1));
#line 128
    m___0->xxp = (struct xxm_pattern **)tmp___12;
    }
#line 128
    goto while_break___4;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 130
  if (m___0->verbosity > 0) {
    {
#line 131
    report((char *)"Stored patterns: %d ", (m___0->xxh)->pat);
    }
  }
#line 133
  i___3 = 0;
  {
#line 133
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 133
    if (! (i___3 < (m___0->xxh)->pat)) {
#line 133
      goto while_break___5;
    }
    {
#line 134
    while (1) {
      while_continue___6: /* CIL Label */ ;
      {
#line 134
      tmp___13 = calloc((size_t )1, (size_t )(sizeof(struct xxm_pattern ) + sizeof(struct xxm_trackinfo ) * (unsigned long )((m___0->xxh)->chn - 1)));
#line 134
      *(m___0->xxp + i___3) = (struct xxm_pattern *)tmp___13;
      }
#line 134
      goto while_break___6;
    }
    while_break___6: /* CIL Label */ ;
    }
#line 135
    (*(m___0->xxp + i___3))->rows = 64;
#line 136
    j = 0;
    {
#line 136
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 136
      if (! (j < (m___0->xxh)->chn)) {
#line 136
        goto while_break___7;
      }
#line 137
      (*(m___0->xxp + i___3))->info[j].index = (int )ih.ord[i___3][j];
#line 136
      j ++;
    }
    while_break___7: /* CIL Label */ ;
    }
    {
#line 139
    m___0->xxo[i___3] = (uint8 )i___3;
#line 141
    reportv(ctx___0, 0, (char *)".");
#line 133
    i___3 ++;
    }
  }
  while_break___5: /* CIL Label */ ;
  }
  {
#line 144
  reportv(ctx___0, 0, (char *)"\nStored tracks  : %d ", (m___0->xxh)->trk);
#line 146
  i___3 = 0;
  }
  {
#line 146
  while (1) {
    while_continue___8: /* CIL Label */ ;
#line 146
    if (! (i___3 < (m___0->xxh)->trk)) {
#line 146
      goto while_break___8;
    }
    {
#line 147
    tmp___14 = calloc((size_t )(sizeof(struct xxm_track ) + sizeof(struct xxm_event ) * 64UL),
                      (size_t )1);
#line 147
    *(m___0->xxt + i___3) = (struct xxm_track *)tmp___14;
#line 149
    (*(m___0->xxt + i___3))->rows = 64;
#line 150
    j = 0;
    }
    {
#line 150
    while (1) {
      while_continue___9: /* CIL Label */ ;
#line 150
      if (! (j < (*(m___0->xxt + i___3))->rows)) {
#line 150
        goto while_break___9;
      }
      {
#line 151
      event = & (*(m___0->xxt + i___3))->event[j];
#line 152
      fread((void */* __restrict  */)(ev), (size_t )1, (size_t )4, (FILE */* __restrict  */)f);
#line 153
      cvt_pt_event(event, ev);
#line 150
      j ++;
      }
    }
    while_break___9: /* CIL Label */ ;
    }
#line 156
    if (m___0->verbosity > 0) {
#line 156
      if (! (i___3 % (m___0->xxh)->chn)) {
        {
#line 157
        report((char *)".");
        }
      }
    }
#line 146
    i___3 ++;
  }
  while_break___8: /* CIL Label */ ;
  }
  {
#line 160
  (m___0->xxh)->flg |= 2;
#line 164
  reportv(ctx___0, 0, (char *)"\nStored samples : %d ", (m___0->xxh)->smp);
#line 166
  i___3 = 0;
  }
  {
#line 166
  while (1) {
    while_continue___10: /* CIL Label */ ;
#line 166
    if (! (i___3 < (m___0->xxh)->ins)) {
#line 166
      goto while_break___10;
    }
#line 167
    if ((m___0->xxs + i___3)->len <= 4) {
#line 168
      goto __Cont;
    }
    {
#line 169
    xmp_drv_loadpatch(ctx___0, f, i___3, m___0->c4rate, 0, m___0->xxs + i___3, (char *)((void *)0));
#line 170
    reportv(ctx___0, 0, (char *)".");
    }
    __Cont: /* CIL Label */ 
#line 166
    i___3 ++;
  }
  while_break___10: /* CIL Label */ ;
  }
  {
#line 172
  reportv(ctx___0, 0, (char *)"\n");
  }
#line 174
  return (0);
}
}
#line 18 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/fnk_load.c"
static int fnk_test(FILE *f , char *t , int const   start ) ;
#line 19
static int fnk_load(struct xmp_context *ctx___0 , FILE *f , int const   start ) ;
#line 21 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/fnk_load.c"
struct xmp_loader_info fnk_loader  =    {(char *)"FNK", (char *)"Funktracker", & fnk_test, & fnk_load, 0, {(struct list_head *)0,
                                                                      (struct list_head *)0}};
#line 28 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/fnk_load.c"
static int fnk_test(FILE *f , char *t , int const   start ) 
{ 
  uint8 a ;
  uint8 b___1 ;
  uint32 tmp ;

  {
  {
#line 32
  tmp = read32b(f);
  }
#line 32
  if (tmp != ((((70U << 24) | (117U << 16)) | (110U << 8)) | 107U)) {
#line 33
    return (-1);
  }
  {
#line 35
  read8(f);
#line 36
  a = read8(f);
#line 37
  b___1 = read8(f);
#line 38
  read8(f);
  }
#line 40
  if ((int )a >> 1 < 10) {
#line 41
    return (-1);
  }
#line 43
  if (((int )b___1 & 240) >> 4 > 7) {
#line 44
    return (-1);
  } else
#line 43
  if (((int )b___1 & 15) > 9) {
#line 44
    return (-1);
  }
  {
#line 46
  read_title(f, t, 0);
  }
#line 48
  return (0);
}
}
#line 75 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/fnk_load.c"
static int fnk_load(struct xmp_context *ctx___0 , FILE *f , int const   start ) 
{ 
  struct xmp_player_context *p ;
  struct xmp_mod_context *m___0 ;
  int i___3 ;
  int j ;
  int day___1 ;
  int month___1 ;
  int year___1 ;
  struct xxm_event *event ;
  struct fnk_header ffh ;
  uint8 ev[3] ;
  uint8 **tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  size_t tmp___12 ;
  void *tmp___13 ;
  void *tmp___14 ;
  void *tmp___15 ;
  int j___0 ;
  void *tmp___16 ;
  void *__cil_tmp33 ;
  void *__cil_tmp34 ;
  void *__cil_tmp35 ;
  void *__cil_tmp36 ;
  void *__cil_tmp37 ;
  void *__cil_tmp38 ;
  void *__cil_tmp39 ;
  int __cil_tmp40 ;
  void *__cil_tmp41 ;
  void *__cil_tmp42 ;
  void *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;

  {
#line 77
  p = & ctx___0->p;
#line 78
  m___0 = & p->m;
  {
#line 85
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 85
    fseek(f, (long )start, 0);
#line 85
    tmp = (uint8 **)((void *)0);
#line 85
    m___0->med_wav_table = tmp;
#line 85
    m___0->med_vol_table = tmp;
#line 85
    set_xxh_defaults(m___0->xxh);
    }
#line 85
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 87
  fread((void */* __restrict  */)(& ffh.marker), (size_t )4, (size_t )1, (FILE */* __restrict  */)f);
#line 88
  fread((void */* __restrict  */)(& ffh.info), (size_t )4, (size_t )1, (FILE */* __restrict  */)f);
#line 89
  ffh.filesize = read32l(f);
#line 90
  fread((void */* __restrict  */)(& ffh.fmt), (size_t )4, (size_t )1, (FILE */* __restrict  */)f);
#line 91
  ffh.loop = read8(f);
#line 92
  fread((void */* __restrict  */)(& ffh.order), (size_t )256, (size_t )1, (FILE */* __restrict  */)f);
#line 93
  fread((void */* __restrict  */)(& ffh.pbrk), (size_t )128, (size_t )1, (FILE */* __restrict  */)f);
#line 95
  i___3 = 0;
  }
  {
#line 95
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 95
    if (! (i___3 < 64)) {
#line 95
      goto while_break___0;
    }
    {
#line 96
    fread((void */* __restrict  */)(& ffh.fih[i___3].name), (size_t )19, (size_t )1,
          (FILE */* __restrict  */)f);
#line 97
    ffh.fih[i___3].loop_start = read32l(f);
#line 98
    ffh.fih[i___3].length = read32l(f);
#line 99
    ffh.fih[i___3].volume = read8(f);
#line 100
    ffh.fih[i___3].pan = read8(f);
#line 101
    ffh.fih[i___3].shifter = read8(f);
#line 102
    ffh.fih[i___3].waveform = read8(f);
#line 103
    ffh.fih[i___3].retrig = read8(f);
#line 95
    i___3 ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 106
  day___1 = (int )ffh.info[0] & 31;
#line 107
  month___1 = (((int )ffh.info[1] & 1) << 3) | (((int )ffh.info[0] & 224) >> 5);
#line 108
  year___1 = 1980 + (((int )ffh.info[1] & 254) >> 1);
#line 110
  tmp___0 = 64;
#line 110
  (m___0->xxh)->ins = tmp___0;
#line 110
  (m___0->xxh)->smp = tmp___0;
#line 112
  i___3 = 0;
  {
#line 112
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 112
    if (i___3 < 256) {
#line 112
      if (! ((int )ffh.order[i___3] != 255)) {
#line 112
        goto while_break___1;
      }
    } else {
#line 112
      goto while_break___1;
    }
#line 113
    if ((int )ffh.order[i___3] > (m___0->xxh)->pat) {
#line 114
      (m___0->xxh)->pat = (int )ffh.order[i___3];
    }
#line 112
    i___3 ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 116
  ((m___0->xxh)->pat) ++;
#line 118
  (m___0->xxh)->len = i___3;
#line 119
  memcpy((void */* __restrict  */)(m___0->xxo), (void const   */* __restrict  */)(ffh.order),
         (size_t )(m___0->xxh)->len);
#line 121
  (m___0->xxh)->tpo = 4;
#line 122
  (m___0->xxh)->bpm = 125;
#line 123
  (m___0->xxh)->chn = 0;
  }
#line 129
  if ((int )ffh.fmt[0] == 70) {
#line 129
    if ((int )ffh.fmt[1] == 50) {
#line 130
      if (((int )((int8 )ffh.info[3]) >> 1) & 64) {
#line 131
        (m___0->xxh)->bpm -= ((int )ffh.info[3] >> 1) & 63;
      } else {
#line 133
        (m___0->xxh)->bpm += ((int )ffh.info[3] >> 1) & 63;
      }
      {
#line 135
      strcpy((char */* __restrict  */)(m___0->type), (char const   */* __restrict  */)"FNK R2 (FunktrackerGOLD)");
      }
    } else {
#line 129
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 136
  if ((int )ffh.fmt[0] == 70) {
#line 136
    if ((int )ffh.fmt[1] == 118) {
      {
#line 137
      strcpy((char */* __restrict  */)(m___0->type), (char const   */* __restrict  */)"FNK R1 (Funktracker)");
      }
    } else
#line 136
    if ((int )ffh.fmt[1] == 107) {
      {
#line 137
      strcpy((char */* __restrict  */)(m___0->type), (char const   */* __restrict  */)"FNK R1 (Funktracker)");
      }
    } else {
      {
#line 139
      (m___0->xxh)->chn = 8;
#line 140
      strcpy((char */* __restrict  */)(m___0->type), (char const   */* __restrict  */)"FNK R0 (Funktracker DOS32)");
      }
    }
  } else {
    {
#line 139
    (m___0->xxh)->chn = 8;
#line 140
    strcpy((char */* __restrict  */)(m___0->type), (char const   */* __restrict  */)"FNK R0 (Funktracker DOS32)");
    }
  }
#line 143
  if ((m___0->xxh)->chn == 0) {
#line 144
    if ((int )ffh.fmt[2] < 48) {
#line 144
      (m___0->xxh)->chn = 8;
    } else
#line 144
    if ((int )ffh.fmt[2] > 57) {
#line 144
      (m___0->xxh)->chn = 8;
    } else
#line 144
    if ((int )ffh.fmt[3] < 48) {
#line 144
      (m___0->xxh)->chn = 8;
    } else
#line 144
    if ((int )ffh.fmt[3] > 57) {
#line 144
      (m___0->xxh)->chn = 8;
    } else {
#line 144
      (m___0->xxh)->chn = (((int )ffh.fmt[2] - 48) * 10 + (int )ffh.fmt[3]) - 48;
    }
  }
#line 149
  (m___0->xxh)->bpm = (4 * (m___0->xxh)->bpm) / 5;
#line 150
  (m___0->xxh)->trk = (m___0->xxh)->chn * (m___0->xxh)->pat;
#line 152
  (m___0->xxh)->flg |= 1;
  {
#line 154
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 154
    if (m___0->verbosity) {
#line 154
      if (m___0->name[0]) {
        {
#line 154
        report((char *)"Module title   : %s\n", m___0->name);
        }
      }
#line 154
      if (m___0->type[0]) {
        {
#line 154
        report((char *)"Module type    : %s\n", m___0->type);
        }
      }
#line 154
      if (m___0->author[0]) {
        {
#line 154
        report((char *)"Author name    : %s\n", m___0->author);
        }
      }
#line 154
      if ((m___0->xxh)->len) {
        {
#line 154
        report((char *)"Module length  : %d patterns\n", (m___0->xxh)->len);
        }
      }
    }
#line 154
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 156
  reportv(ctx___0, 0, (char *)"Creation date  : %02d/%02d/%04d\n", day___1, month___1,
          year___1);
  }
  {
#line 158
  while (1) {
    while_continue___3: /* CIL Label */ ;
    {
#line 158
    tmp___1 = calloc((size_t )sizeof(struct xxm_instrument_header ), (size_t )(m___0->xxh)->ins);
#line 158
    m___0->xxih = (struct xxm_instrument_header *)tmp___1;
#line 158
    tmp___2 = calloc((size_t )sizeof(struct xxm_instrument_map ), (size_t )(m___0->xxh)->ins);
#line 158
    m___0->xxim = (struct xxm_instrument_map *)tmp___2;
#line 158
    tmp___3 = calloc((size_t )sizeof(struct xxm_instrument *), (size_t )(m___0->xxh)->ins);
#line 158
    m___0->xxi = (struct xxm_instrument **)tmp___3;
    }
#line 158
    if ((m___0->xxh)->smp) {
      {
#line 158
      tmp___4 = calloc((size_t )sizeof(struct xxm_sample ), (size_t )(m___0->xxh)->smp);
#line 158
      m___0->xxs = (struct xxm_sample *)tmp___4;
      }
    }
    {
#line 158
    tmp___5 = calloc((size_t )sizeof(uint16 *), (size_t )(m___0->xxh)->ins);
#line 158
    m___0->xxae = (uint16 **)tmp___5;
#line 158
    tmp___6 = calloc((size_t )sizeof(uint16 *), (size_t )(m___0->xxh)->ins);
#line 158
    m___0->xxpe = (uint16 **)tmp___6;
#line 158
    tmp___7 = calloc((size_t )sizeof(uint16 *), (size_t )(m___0->xxh)->ins);
#line 158
    m___0->xxfe = (uint16 **)tmp___7;
    }
#line 158
    goto while_break___3;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 161
  i___3 = 0;
  {
#line 161
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 161
    if (! (i___3 < (m___0->xxh)->ins)) {
#line 161
      goto while_break___4;
    }
    {
#line 162
    tmp___8 = calloc((size_t )sizeof(struct xxm_instrument ), (size_t )1);
#line 162
    *(m___0->xxi + i___3) = (struct xxm_instrument *)tmp___8;
#line 163
    tmp___9 = (int )ffh.fih[i___3].length;
#line 163
    (m___0->xxs + i___3)->len = tmp___9;
    }
#line 163
    if (tmp___9) {
#line 163
      tmp___10 = 1;
    } else {
#line 163
      tmp___10 = 0;
    }
#line 163
    (m___0->xxih + i___3)->nsm = tmp___10;
#line 164
    (m___0->xxs + i___3)->lps = (int )ffh.fih[i___3].loop_start;
#line 165
    if ((m___0->xxs + i___3)->lps == -1) {
#line 166
      (m___0->xxs + i___3)->lps = 0;
    }
#line 167
    (m___0->xxs + i___3)->lpe = (int )ffh.fih[i___3].length;
#line 168
    if (ffh.fih[i___3].loop_start != 4294967295U) {
#line 168
      (m___0->xxs + i___3)->flg = 4;
    } else {
#line 168
      (m___0->xxs + i___3)->flg = 0;
    }
    {
#line 169
    (*(m___0->xxi + i___3) + 0)->vol = (int )ffh.fih[i___3].volume;
#line 170
    (*(m___0->xxi + i___3) + 0)->pan = (int )ffh.fih[i___3].pan;
#line 171
    (*(m___0->xxi + i___3) + 0)->sid = i___3;
#line 173
    copy_adjust((m___0->xxih + i___3)->name, ffh.fih[i___3].name, 19);
    }
#line 175
    if (m___0->verbosity > 1) {
      {
#line 175
      tmp___12 = strlen((char const   *)((char *)((m___0->xxih + i___3)->name)));
      }
#line 175
      if (tmp___12) {
#line 175
        goto _L___0;
      } else
#line 175
      if ((m___0->xxs + i___3)->len > 2) {
        _L___0: /* CIL Label */ 
#line 176
        if ((m___0->xxs + i___3)->flg & 4) {
#line 176
          tmp___11 = 'L';
        } else {
#line 176
          tmp___11 = ' ';
        }
        {
#line 176
        report((char *)"[%2X] %-20.20s %04x %04x %04x %c V%02x P%02x\n", i___3, (m___0->xxih + i___3)->name,
               (m___0->xxs + i___3)->len, (m___0->xxs + i___3)->lps, (m___0->xxs + i___3)->lpe,
               tmp___11, (*(m___0->xxi + i___3) + 0)->vol, (*(m___0->xxi + i___3) + 0)->pan);
        }
      }
    }
#line 161
    i___3 ++;
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 183
  while (1) {
    while_continue___5: /* CIL Label */ ;
    {
#line 183
    tmp___13 = calloc((size_t )sizeof(struct xxm_track *), (size_t )(m___0->xxh)->trk);
#line 183
    m___0->xxt = (struct xxm_track **)tmp___13;
#line 183
    tmp___14 = calloc((size_t )sizeof(struct xxm_pattern *), (size_t )((m___0->xxh)->pat + 1));
#line 183
    m___0->xxp = (struct xxm_pattern **)tmp___14;
    }
#line 183
    goto while_break___5;
  }
  while_break___5: /* CIL Label */ ;
  }
  {
#line 186
  reportv(ctx___0, 0, (char *)"Stored patterns: %d ", (m___0->xxh)->pat);
#line 188
  i___3 = 0;
  }
  {
#line 188
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 188
    if (! (i___3 < (m___0->xxh)->pat)) {
#line 188
      goto while_break___6;
    }
    {
#line 189
    while (1) {
      while_continue___7: /* CIL Label */ ;
      {
#line 189
      tmp___15 = calloc((size_t )1, (size_t )(sizeof(struct xxm_pattern ) + sizeof(struct xxm_trackinfo ) * (unsigned long )((m___0->xxh)->chn - 1)));
#line 189
      *(m___0->xxp + i___3) = (struct xxm_pattern *)tmp___15;
      }
#line 189
      goto while_break___7;
    }
    while_break___7: /* CIL Label */ ;
    }
#line 190
    (*(m___0->xxp + i___3))->rows = 64;
    {
#line 191
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 191
      j___0 = 0;
      {
#line 191
      while (1) {
        while_continue___9: /* CIL Label */ ;
#line 191
        if (! (j___0 < (m___0->xxh)->chn)) {
#line 191
          goto while_break___9;
        }
        {
#line 191
        (*(m___0->xxp + i___3))->info[j___0].index = i___3 * (m___0->xxh)->chn + j___0;
#line 191
        tmp___16 = calloc((size_t )(sizeof(struct xxm_track ) + sizeof(struct xxm_event ) * (unsigned long )(*(m___0->xxp + i___3))->rows),
                          (size_t )1);
#line 191
        *(m___0->xxt + (i___3 * (m___0->xxh)->chn + j___0)) = (struct xxm_track *)tmp___16;
#line 191
        (*(m___0->xxt + (i___3 * (m___0->xxh)->chn + j___0)))->rows = (*(m___0->xxp + i___3))->rows;
#line 191
        j___0 ++;
        }
      }
      while_break___9: /* CIL Label */ ;
      }
#line 191
      goto while_break___8;
    }
    while_break___8: /* CIL Label */ ;
    }
#line 193
    (*(m___0->xxt + (*(m___0->xxp + i___3))->info[1].index))->event[ffh.pbrk[i___3]].f2t = (uint8 )13;
#line 195
    j = 0;
    {
#line 195
    while (1) {
      while_continue___10: /* CIL Label */ ;
#line 195
      if (! (j < 64 * (m___0->xxh)->chn)) {
#line 195
        goto while_break___10;
      }
      {
#line 196
      event = & (*(m___0->xxt + (*(m___0->xxp + i___3))->info[j % (m___0->xxh)->chn].index))->event[j / (m___0->xxh)->chn];
#line 197
      fread((void */* __restrict  */)(& ev), (size_t )1, (size_t )3, (FILE */* __restrict  */)f);
      }
      {
#line 202
      if ((int )ev[0] >> 2 == 61) {
#line 202
        goto case_61;
      }
#line 202
      if ((int )ev[0] >> 2 == 62) {
#line 202
        goto case_61;
      }
#line 202
      if ((int )ev[0] >> 2 == 63) {
#line 202
        goto case_61;
      }
#line 204
      goto switch_default;
      case_61: /* CIL Label */ 
      case_62: /* CIL Label */ 
      case_63: /* CIL Label */ 
#line 203
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 205
      event->note = (uint8 )(25 + ((int )ev[0] >> 2));
#line 206
      event->ins = (uint8 )((1 + (((int )ev[1] & 240) >> 4)) + (((int )ev[0] & 3) << 4));
#line 207
      event->vol = ffh.fih[(int )event->ins - 1].volume;
      switch_break: /* CIL Label */ ;
      }
      {
#line 211
      if (((int )ev[1] & 15) == 0) {
#line 211
        goto case_0;
      }
#line 215
      if (((int )ev[1] & 15) == 1) {
#line 215
        goto case_1;
      }
#line 219
      if (((int )ev[1] & 15) == 2) {
#line 219
        goto case_2;
      }
#line 223
      if (((int )ev[1] & 15) == 3) {
#line 223
        goto case_3;
      }
#line 227
      if (((int )ev[1] & 15) == 6) {
#line 227
        goto case_6;
      }
#line 231
      if (((int )ev[1] & 15) == 7) {
#line 231
        goto case_7;
      }
#line 235
      if (((int )ev[1] & 15) == 11) {
#line 235
        goto case_11;
      }
#line 239
      if (((int )ev[1] & 15) == 13) {
#line 239
        goto case_13;
      }
#line 243
      if (((int )ev[1] & 15) == 14) {
#line 243
        goto case_14;
      }
#line 210
      goto switch_break___0;
      case_0: /* CIL Label */ 
#line 212
      event->fxt = (uint8 )121;
#line 213
      event->fxp = ev[2];
#line 214
      goto switch_break___0;
      case_1: /* CIL Label */ 
#line 216
      event->fxt = (uint8 )120;
#line 217
      event->fxp = ev[2];
#line 218
      goto switch_break___0;
      case_2: /* CIL Label */ 
#line 220
      event->fxt = (uint8 )122;
#line 221
      event->fxp = ev[2];
#line 222
      goto switch_break___0;
      case_3: /* CIL Label */ 
#line 224
      event->fxt = (uint8 )123;
#line 225
      event->fxp = ev[2];
#line 226
      goto switch_break___0;
      case_6: /* CIL Label */ 
#line 228
      event->fxt = (uint8 )124;
#line 229
      event->fxp = (uint8 )((int )ev[2] << 1);
#line 230
      goto switch_break___0;
      case_7: /* CIL Label */ 
#line 232
      event->fxt = (uint8 )125;
#line 233
      event->fxp = (uint8 )((int )ev[2] << 1);
#line 234
      goto switch_break___0;
      case_11: /* CIL Label */ 
#line 236
      event->fxt = (uint8 )0;
#line 237
      event->fxp = ev[2];
#line 238
      goto switch_break___0;
      case_13: /* CIL Label */ 
#line 240
      event->fxt = (uint8 )12;
#line 241
      event->fxp = ev[2];
#line 242
      goto switch_break___0;
      case_14: /* CIL Label */ 
#line 244
      if ((int )ev[2] == 10) {
#line 245
        event->fxt = (uint8 )127;
#line 246
        goto switch_break___0;
      } else
#line 244
      if ((int )ev[2] == 11) {
#line 245
        event->fxt = (uint8 )127;
#line 246
        goto switch_break___0;
      } else
#line 244
      if ((int )ev[2] == 12) {
#line 245
        event->fxt = (uint8 )127;
#line 246
        goto switch_break___0;
      }
      {
#line 250
      if (((int )ev[2] & 240) >> 4 == 1) {
#line 250
        goto case_1___0;
      }
#line 254
      if (((int )ev[2] & 240) >> 4 == 2) {
#line 254
        goto case_2___0;
      }
#line 258
      if (((int )ev[2] & 240) >> 4 == 13) {
#line 258
        goto case_13___0;
      }
#line 262
      if (((int )ev[2] & 240) >> 4 == 14) {
#line 262
        goto case_14___0;
      }
#line 266
      if (((int )ev[2] & 240) >> 4 == 15) {
#line 266
        goto case_15;
      }
#line 249
      goto switch_break___1;
      case_1___0: /* CIL Label */ 
#line 251
      event->fxt = (uint8 )14;
#line 252
      event->fxp = (uint8 )((12 << 4) | ((int )ev[2] & 15));
#line 253
      goto switch_break___1;
      case_2___0: /* CIL Label */ 
#line 255
      event->fxt = (uint8 )14;
#line 256
      event->fxp = (uint8 )((13 << 4) | ((int )ev[2] & 15));
#line 257
      goto switch_break___1;
      case_13___0: /* CIL Label */ 
#line 259
      event->fxt = (uint8 )14;
#line 260
      event->fxp = (uint8 )((9 << 4) | ((int )ev[2] & 15));
#line 261
      goto switch_break___1;
      case_14___0: /* CIL Label */ 
#line 263
      event->fxt = (uint8 )8;
#line 264
      event->fxp = (uint8 )(8 + (((int )ev[2] & 15) << 4));
#line 265
      goto switch_break___1;
      case_15: /* CIL Label */ 
#line 267
      event->fxt = (uint8 )15;
#line 268
      event->fxp = (uint8 )((int )ev[2] & 15);
#line 269
      goto switch_break___1;
      switch_break___1: /* CIL Label */ ;
      }
      switch_break___0: /* CIL Label */ ;
      }
#line 195
      j ++;
    }
    while_break___10: /* CIL Label */ ;
    }
    {
#line 273
    reportv(ctx___0, 0, (char *)".");
#line 188
    i___3 ++;
    }
  }
  while_break___6: /* CIL Label */ ;
  }
  {
#line 277
  reportv(ctx___0, 0, (char *)"\nStored samples : %d ", (m___0->xxh)->smp);
#line 279
  i___3 = 0;
  }
  {
#line 279
  while (1) {
    while_continue___11: /* CIL Label */ ;
#line 279
    if (! (i___3 < (m___0->xxh)->ins)) {
#line 279
      goto while_break___11;
    }
#line 280
    if ((m___0->xxs + i___3)->len <= 2) {
#line 281
      goto __Cont;
    }
    {
#line 283
    xmp_drv_loadpatch(ctx___0, f, (*(m___0->xxi + i___3) + 0)->sid, m___0->c4rate,
                      0, m___0->xxs + i___3, (char *)((void *)0));
#line 286
    reportv(ctx___0, 0, (char *)".");
    }
    __Cont: /* CIL Label */ 
#line 279
    i___3 ++;
  }
  while_break___11: /* CIL Label */ ;
  }
  {
#line 289
  reportv(ctx___0, 0, (char *)"\n");
#line 291
  i___3 = 0;
  }
  {
#line 291
  while (1) {
    while_continue___12: /* CIL Label */ ;
#line 291
    if (! (i___3 < (m___0->xxh)->chn)) {
#line 291
      goto while_break___12;
    }
#line 292
    m___0->xxc[i___3].pan = 128;
#line 291
    i___3 ++;
  }
  while_break___12: /* CIL Label */ ;
  }
#line 294
  m___0->volbase = 255;
#line 295
  m___0->quirk = 1 << 13;
#line 297
  return (0);
}
}
#line 31 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/digi_load.c"
static int digi_test(FILE *f , char *t , int const   start ) ;
#line 32
static int digi_load(struct xmp_context *ctx___0 , FILE *f , int const   start ) ;
#line 34 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/digi_load.c"
struct xmp_loader_info digi_loader  =    {(char *)"DIGI", (char *)"DIGI Booster", & digi_test, & digi_load, 0, {(struct list_head *)0,
                                                                          (struct list_head *)0}};
#line 41 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/digi_load.c"
static int digi_test(FILE *f , char *t , int const   start ) 
{ 
  char buf___1[20] ;
  int tmp ;
  void *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
  {
#line 45
  fread((void */* __restrict  */)(buf___1), (size_t )20, (size_t )1, (FILE */* __restrict  */)f);
#line 47
  tmp = memcmp((void const   *)(buf___1), (void const   *)"DIGI Booster module", (size_t )19);
  }
#line 47
  if (tmp) {
#line 48
    return (-1);
  }
  {
#line 50
  fseek(f, 156L, 1);
#line 51
  fseek(f, 384L, 1);
#line 52
  fseek(f, 64L, 1);
#line 54
  read_title(f, t, 32);
  }
#line 56
  return (0);
}
}
#line 80 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/digi_load.c"
static int digi_load(struct xmp_context *ctx___0 , FILE *f , int const   start ) 
{ 
  struct xmp_player_context *p ;
  struct xmp_mod_context *m___0 ;
  struct xxm_event *event ;
  struct digi_header dh ;
  uint8 digi_event[4] ;
  uint8 chn_table[64] ;
  uint16 w ;
  int i___3 ;
  int j ;
  int k ;
  int c___0 ;
  uint8 **tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  size_t tmp___11 ;
  void *tmp___12 ;
  void *tmp___13 ;
  void *tmp___14 ;
  int j___0 ;
  void *tmp___15 ;
  uint16 tmp___16 ;
  uint8 tmp___17 ;
  uint8 tmp___18 ;
  void *__cil_tmp36 ;
  void *__cil_tmp37 ;
  void *__cil_tmp38 ;
  void *__cil_tmp39 ;
  void *__cil_tmp40 ;
  void *__cil_tmp41 ;
  void *__cil_tmp42 ;
  void *__cil_tmp43 ;
  void *__cil_tmp44 ;
  void *__cil_tmp45 ;
  void *__cil_tmp46 ;
  void *__cil_tmp47 ;
  int __cil_tmp48 ;
  void *__cil_tmp49 ;
  void *__cil_tmp50 ;
  void *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;

  {
#line 82
  p = & ctx___0->p;
#line 83
  m___0 = & p->m;
#line 84
  event = (struct xxm_event *)0;
  {
#line 90
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 90
    fseek(f, (long )start, 0);
#line 90
    tmp = (uint8 **)((void *)0);
#line 90
    m___0->med_wav_table = tmp;
#line 90
    m___0->med_vol_table = tmp;
#line 90
    set_xxh_defaults(m___0->xxh);
    }
#line 90
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 92
  fread((void */* __restrict  */)(& dh.id), (size_t )20, (size_t )1, (FILE */* __restrict  */)f);
#line 94
  fread((void */* __restrict  */)(& dh.vstr), (size_t )4, (size_t )1, (FILE */* __restrict  */)f);
#line 95
  dh.ver = read8(f);
#line 96
  dh.chn = read8(f);
#line 97
  dh.pack = read8(f);
#line 98
  fread((void */* __restrict  */)(& dh.unknown), (size_t )19, (size_t )1, (FILE */* __restrict  */)f);
#line 99
  dh.pat = read8(f);
#line 100
  dh.len = read8(f);
#line 101
  fread((void */* __restrict  */)(& dh.ord), (size_t )128, (size_t )1, (FILE */* __restrict  */)f);
#line 103
  i___3 = 0;
  }
  {
#line 103
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 103
    if (! (i___3 < 31)) {
#line 103
      goto while_break___0;
    }
    {
#line 104
    dh.slen[i___3] = read32b(f);
#line 103
    i___3 ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 105
  i___3 = 0;
  {
#line 105
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 105
    if (! (i___3 < 31)) {
#line 105
      goto while_break___1;
    }
    {
#line 106
    dh.sloop[i___3] = read32b(f);
#line 105
    i___3 ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 107
  i___3 = 0;
  {
#line 107
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 107
    if (! (i___3 < 31)) {
#line 107
      goto while_break___2;
    }
    {
#line 108
    dh.sllen[i___3] = read32b(f);
#line 107
    i___3 ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 109
  i___3 = 0;
  {
#line 109
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 109
    if (! (i___3 < 31)) {
#line 109
      goto while_break___3;
    }
    {
#line 110
    dh.vol[i___3] = read8(f);
#line 109
    i___3 ++;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
#line 111
  i___3 = 0;
  {
#line 111
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 111
    if (! (i___3 < 31)) {
#line 111
      goto while_break___4;
    }
    {
#line 112
    dh.fin[i___3] = read8(f);
#line 111
    i___3 ++;
    }
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 114
  fread((void */* __restrict  */)(& dh.title), (size_t )32, (size_t )1, (FILE */* __restrict  */)f);
#line 116
  i___3 = 0;
  }
  {
#line 116
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 116
    if (! (i___3 < 31)) {
#line 116
      goto while_break___5;
    }
    {
#line 117
    fread((void */* __restrict  */)(& dh.insname[i___3]), (size_t )30, (size_t )1,
          (FILE */* __restrict  */)f);
#line 116
    i___3 ++;
    }
  }
  while_break___5: /* CIL Label */ ;
  }
  {
#line 119
  (m___0->xxh)->ins = 31;
#line 120
  (m___0->xxh)->smp = (m___0->xxh)->ins;
#line 121
  (m___0->xxh)->pat = (int )dh.pat + 1;
#line 122
  (m___0->xxh)->chn = (int )dh.chn;
#line 123
  (m___0->xxh)->trk = (m___0->xxh)->pat * (m___0->xxh)->chn;
#line 124
  (m___0->xxh)->len = (int )dh.len + 1;
#line 125
  (m___0->xxh)->flg |= 2;
#line 127
  copy_adjust((uint8 *)(m___0->name), dh.title, 32);
#line 128
  sprintf((char */* __restrict  */)(m___0->type), (char const   */* __restrict  */)"DIGI (DIGI Booster %-4.4s)",
          dh.vstr);
  }
  {
#line 130
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 130
    if (m___0->verbosity) {
#line 130
      if (m___0->name[0]) {
        {
#line 130
        report((char *)"Module title   : %s\n", m___0->name);
        }
      }
#line 130
      if (m___0->type[0]) {
        {
#line 130
        report((char *)"Module type    : %s\n", m___0->type);
        }
      }
#line 130
      if (m___0->author[0]) {
        {
#line 130
        report((char *)"Author name    : %s\n", m___0->author);
        }
      }
#line 130
      if ((m___0->xxh)->len) {
        {
#line 130
        report((char *)"Module length  : %d patterns\n", (m___0->xxh)->len);
        }
      }
    }
#line 130
    goto while_break___6;
  }
  while_break___6: /* CIL Label */ ;
  }
#line 132
  i___3 = 0;
  {
#line 132
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 132
    if (! (i___3 < (m___0->xxh)->len)) {
#line 132
      goto while_break___7;
    }
#line 133
    m___0->xxo[i___3] = dh.ord[i___3];
#line 132
    i___3 ++;
  }
  while_break___7: /* CIL Label */ ;
  }
  {
#line 135
  while (1) {
    while_continue___8: /* CIL Label */ ;
    {
#line 135
    tmp___0 = calloc((size_t )sizeof(struct xxm_instrument_header ), (size_t )(m___0->xxh)->ins);
#line 135
    m___0->xxih = (struct xxm_instrument_header *)tmp___0;
#line 135
    tmp___1 = calloc((size_t )sizeof(struct xxm_instrument_map ), (size_t )(m___0->xxh)->ins);
#line 135
    m___0->xxim = (struct xxm_instrument_map *)tmp___1;
#line 135
    tmp___2 = calloc((size_t )sizeof(struct xxm_instrument *), (size_t )(m___0->xxh)->ins);
#line 135
    m___0->xxi = (struct xxm_instrument **)tmp___2;
    }
#line 135
    if ((m___0->xxh)->smp) {
      {
#line 135
      tmp___3 = calloc((size_t )sizeof(struct xxm_sample ), (size_t )(m___0->xxh)->smp);
#line 135
      m___0->xxs = (struct xxm_sample *)tmp___3;
      }
    }
    {
#line 135
    tmp___4 = calloc((size_t )sizeof(uint16 *), (size_t )(m___0->xxh)->ins);
#line 135
    m___0->xxae = (uint16 **)tmp___4;
#line 135
    tmp___5 = calloc((size_t )sizeof(uint16 *), (size_t )(m___0->xxh)->ins);
#line 135
    m___0->xxpe = (uint16 **)tmp___5;
#line 135
    tmp___6 = calloc((size_t )sizeof(uint16 *), (size_t )(m___0->xxh)->ins);
#line 135
    m___0->xxfe = (uint16 **)tmp___6;
    }
#line 135
    goto while_break___8;
  }
  while_break___8: /* CIL Label */ ;
  }
#line 139
  if (m___0->verbosity > 1) {
    {
#line 140
    report((char *)"     Sample name                    Len  LBeg LEnd L Vol\n");
    }
  }
#line 142
  i___3 = 0;
  {
#line 142
  while (1) {
    while_continue___9: /* CIL Label */ ;
#line 142
    if (! (i___3 < (m___0->xxh)->ins)) {
#line 142
      goto while_break___9;
    }
    {
#line 143
    tmp___7 = calloc((size_t )sizeof(struct xxm_instrument ), (size_t )1);
#line 143
    *(m___0->xxi + i___3) = (struct xxm_instrument *)tmp___7;
#line 144
    tmp___8 = (int )dh.slen[i___3];
#line 144
    (m___0->xxs + i___3)->len = tmp___8;
    }
#line 144
    if (tmp___8) {
#line 144
      tmp___9 = 1;
    } else {
#line 144
      tmp___9 = 0;
    }
#line 144
    (m___0->xxih + i___3)->nsm = tmp___9;
#line 145
    (m___0->xxs + i___3)->lps = (int )dh.sloop[i___3];
#line 146
    (m___0->xxs + i___3)->lpe = (int )(dh.sloop[i___3] + dh.sllen[i___3]);
#line 147
    if ((m___0->xxs + i___3)->lpe > 0) {
#line 147
      (m___0->xxs + i___3)->flg = 4;
    } else {
#line 147
      (m___0->xxs + i___3)->flg = 0;
    }
    {
#line 148
    (*(m___0->xxi + i___3) + 0)->vol = (int )dh.vol[i___3];
#line 149
    (*(m___0->xxi + i___3) + 0)->fin = (int )dh.fin[i___3];
#line 150
    (*(m___0->xxi + i___3) + 0)->pan = 128;
#line 151
    (*(m___0->xxi + i___3) + 0)->sid = i___3;
#line 153
    copy_adjust((m___0->xxih + i___3)->name, dh.insname[i___3], 30);
    }
#line 155
    if (m___0->verbosity > 1) {
      {
#line 155
      tmp___11 = strlen((char const   *)((char *)((m___0->xxih + i___3)->name)));
      }
#line 155
      if (tmp___11) {
#line 155
        goto _L;
      } else
#line 155
      if ((m___0->xxs + i___3)->len > 1) {
        _L: /* CIL Label */ 
#line 156
        if ((m___0->xxs + i___3)->flg & 4) {
#line 156
          tmp___10 = 'L';
        } else {
#line 156
          tmp___10 = ' ';
        }
        {
#line 156
        report((char *)"[%2X] %-30.30s %04x %04x %04x %c V%02x\n", i___3, (m___0->xxih + i___3)->name,
               (m___0->xxs + i___3)->len, (m___0->xxs + i___3)->lps, (m___0->xxs + i___3)->lpe,
               tmp___10, (*(m___0->xxi + i___3) + 0)->vol);
        }
      }
    }
#line 142
    i___3 ++;
  }
  while_break___9: /* CIL Label */ ;
  }
  {
#line 162
  while (1) {
    while_continue___10: /* CIL Label */ ;
    {
#line 162
    tmp___12 = calloc((size_t )sizeof(struct xxm_track *), (size_t )(m___0->xxh)->trk);
#line 162
    m___0->xxt = (struct xxm_track **)tmp___12;
#line 162
    tmp___13 = calloc((size_t )sizeof(struct xxm_pattern *), (size_t )((m___0->xxh)->pat + 1));
#line 162
    m___0->xxp = (struct xxm_pattern **)tmp___13;
    }
#line 162
    goto while_break___10;
  }
  while_break___10: /* CIL Label */ ;
  }
  {
#line 165
  reportv(ctx___0, 0, (char *)"Stored patterns: %d ", (m___0->xxh)->pat);
#line 167
  i___3 = 0;
  }
  {
#line 167
  while (1) {
    while_continue___11: /* CIL Label */ ;
#line 167
    if (! (i___3 < (m___0->xxh)->pat)) {
#line 167
      goto while_break___11;
    }
    {
#line 168
    while (1) {
      while_continue___12: /* CIL Label */ ;
      {
#line 168
      tmp___14 = calloc((size_t )1, (size_t )(sizeof(struct xxm_pattern ) + sizeof(struct xxm_trackinfo ) * (unsigned long )((m___0->xxh)->chn - 1)));
#line 168
      *(m___0->xxp + i___3) = (struct xxm_pattern *)tmp___14;
      }
#line 168
      goto while_break___12;
    }
    while_break___12: /* CIL Label */ ;
    }
#line 169
    (*(m___0->xxp + i___3))->rows = 64;
    {
#line 170
    while (1) {
      while_continue___13: /* CIL Label */ ;
#line 170
      j___0 = 0;
      {
#line 170
      while (1) {
        while_continue___14: /* CIL Label */ ;
#line 170
        if (! (j___0 < (m___0->xxh)->chn)) {
#line 170
          goto while_break___14;
        }
        {
#line 170
        (*(m___0->xxp + i___3))->info[j___0].index = i___3 * (m___0->xxh)->chn + j___0;
#line 170
        tmp___15 = calloc((size_t )(sizeof(struct xxm_track ) + sizeof(struct xxm_event ) * (unsigned long )(*(m___0->xxp + i___3))->rows),
                          (size_t )1);
#line 170
        *(m___0->xxt + (i___3 * (m___0->xxh)->chn + j___0)) = (struct xxm_track *)tmp___15;
#line 170
        (*(m___0->xxt + (i___3 * (m___0->xxh)->chn + j___0)))->rows = (*(m___0->xxp + i___3))->rows;
#line 170
        j___0 ++;
        }
      }
      while_break___14: /* CIL Label */ ;
      }
#line 170
      goto while_break___13;
    }
    while_break___13: /* CIL Label */ ;
    }
#line 172
    if (dh.pack) {
      {
#line 173
      tmp___16 = read16b(f);
#line 173
      w = (uint16 )(((int )tmp___16 - 64) >> 2);
#line 174
      fread((void */* __restrict  */)(chn_table), (size_t )1, (size_t )64, (FILE */* __restrict  */)f);
      }
    } else {
      {
#line 176
      w = (uint16 )(64 * (m___0->xxh)->chn);
#line 177
      memset((void *)(chn_table), 255, (size_t )64);
      }
    }
#line 180
    j = 0;
    {
#line 180
    while (1) {
      while_continue___15: /* CIL Label */ ;
#line 180
      if (! (j < 64)) {
#line 180
        goto while_break___15;
      }
#line 181
      c___0 = 0;
#line 181
      k = 128;
      {
#line 181
      while (1) {
        while_continue___16: /* CIL Label */ ;
#line 181
        if (! (c___0 < (m___0->xxh)->chn)) {
#line 181
          goto while_break___16;
        }
#line 182
        if ((int )chn_table[j] & k) {
          {
#line 183
          fread((void */* __restrict  */)(digi_event), (size_t )4, (size_t )1, (FILE */* __restrict  */)f);
#line 184
          event = & (*(m___0->xxt + (*(m___0->xxp + i___3))->info[c___0].index))->event[j];
#line 185
          cvt_pt_event(event, digi_event);
          }
          {
#line 187
          if ((int )event->fxt == 8) {
#line 187
            goto case_8;
          }
#line 190
          if ((int )event->fxt == 14) {
#line 190
            goto case_14;
          }
#line 186
          goto switch_break;
          case_8: /* CIL Label */ 
#line 188
          tmp___17 = (uint8 )0;
#line 188
          event->fxp = tmp___17;
#line 188
          event->fxt = tmp___17;
#line 189
          goto switch_break;
          case_14: /* CIL Label */ 
          {
#line 195
          if (((int )event->fxp & 240) >> 4 == 9) {
#line 195
            goto case_9;
          }
#line 195
          if (((int )event->fxp & 240) >> 4 == 8) {
#line 195
            goto case_9;
          }
#line 195
          if (((int )event->fxp & 240) >> 4 == 3) {
#line 195
            goto case_9;
          }
#line 195
          if (((int )event->fxp & 240) >> 4 == 0) {
#line 195
            goto case_9;
          }
#line 198
          if (((int )event->fxp & 240) >> 4 == 4) {
#line 198
            goto case_4;
          }
#line 191
          goto switch_break___0;
          case_9: /* CIL Label */ 
          case_8___0: /* CIL Label */ 
          case_3: /* CIL Label */ 
          case_0: /* CIL Label */ 
#line 196
          tmp___18 = (uint8 )0;
#line 196
          event->fxp = tmp___18;
#line 196
          event->fxt = tmp___18;
#line 197
          goto switch_break___0;
          case_4: /* CIL Label */ 
#line 199
          event->fxt = (uint8 )12;
#line 200
          event->fxp = (uint8 )0;
#line 201
          goto switch_break___0;
          switch_break___0: /* CIL Label */ ;
          }
          switch_break: /* CIL Label */ ;
          }
#line 204
          w = (uint16 )((int )w - 1);
        }
#line 181
        c___0 ++;
#line 181
        k >>= 1;
      }
      while_break___16: /* CIL Label */ ;
      }
#line 180
      j ++;
    }
    while_break___15: /* CIL Label */ ;
    }
#line 209
    if (w) {
      {
#line 210
      report((char *)"WARNING! Corrupted file (w = %d)", (int )w);
      }
    }
    {
#line 212
    reportv(ctx___0, 0, (char *)".");
#line 167
    i___3 ++;
    }
  }
  while_break___11: /* CIL Label */ ;
  }
  {
#line 214
  reportv(ctx___0, 0, (char *)"\n");
#line 217
  reportv(ctx___0, 0, (char *)"Stored samples : %d ", (m___0->xxh)->smp);
#line 218
  i___3 = 0;
  }
  {
#line 218
  while (1) {
    while_continue___17: /* CIL Label */ ;
#line 218
    if (! (i___3 < (m___0->xxh)->ins)) {
#line 218
      goto while_break___17;
    }
    {
#line 219
    xmp_drv_loadpatch(ctx___0, f, (*(m___0->xxi + i___3) + 0)->sid, m___0->c4rate,
                      0, m___0->xxs + (*(m___0->xxi + i___3) + 0)->sid, (char *)((void *)0));
#line 221
    reportv(ctx___0, 0, (char *)".");
#line 218
    i___3 ++;
    }
  }
  while_break___17: /* CIL Label */ ;
  }
  {
#line 223
  reportv(ctx___0, 0, (char *)"\n");
  }
#line 227
  return (0);
}
}
#line 24 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/imf_load.c"
static int imf_test(FILE *f , char *t , int const   start ) ;
#line 25
static int imf_load(struct xmp_context *ctx___0 , FILE *f , int const   start ) ;
#line 27 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/imf_load.c"
struct xmp_loader_info imf_loader  =    {(char *)"IMF", (char *)"Imago Orpheus", & imf_test, & imf_load, 0, {(struct list_head *)0,
                                                                        (struct list_head *)0}};
#line 34 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/imf_load.c"
static int imf_test(FILE *f , char *t , int const   start ) 
{ 
  uint32 tmp ;

  {
  {
#line 36
  fseek(f, (long )(start + 60), 0);
#line 37
  tmp = read32b(f);
  }
#line 37
  if (tmp != ((((73U << 24) | (77U << 16)) | (49U << 8)) | 48U)) {
#line 38
    return (-1);
  }
  {
#line 40
  read_title(f, t, 32);
  }
#line 42
  return (0);
}
}
#line 49 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/imf_load.c"
static uint8 arpeggio_val[32]  ;
#line 52 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/imf_load.c"
static uint8 fx___1[36]  = 
#line 52
  {      (uint8 )255,      (uint8 )163,      (uint8 )171,      (uint8 )3, 
        (uint8 )5,      (uint8 )4,      (uint8 )6,      (uint8 )172, 
        (uint8 )7,      (uint8 )0,      (uint8 )8,      (uint8 )25, 
        (uint8 )12,      (uint8 )10,      (uint8 )165,      (uint8 )166, 
        (uint8 )157,      (uint8 )156,      (uint8 )1,      (uint8 )2, 
        (uint8 )254,      (uint8 )253,      (uint8 )132,      (uint8 )133, 
        (uint8 )9,      (uint8 )255,      (uint8 )20,      (uint8 )27, 
        (uint8 )29,      (uint8 )11,      (uint8 )13,      (uint8 )16, 
        (uint8 )17,      (uint8 )14,      (uint8 )169,      (uint8 )170};
#line 93 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/imf_load.c"
static void xlat_fx___2(int c___0 , uint8 *fxt , uint8 *fxp ) 
{ 
  uint8 h ;
  uint8 l ;
  uint8 tmp ;
  uint8 tmp___0 ;
  uint8 tmp___1 ;
  uint8 tmp___2 ;

  {
#line 95
  h = (uint8 )(((int )*fxp & 240) >> 4);
#line 95
  l = (uint8 )((int )*fxp & 15);
#line 97
  tmp = fx___1[*fxt];
#line 97
  *fxt = tmp;
  {
#line 98
  if ((int )tmp == 0) {
#line 98
    goto case_0;
  }
#line 104
  if ((int )tmp == 254) {
#line 104
    goto case_254;
  }
#line 111
  if ((int )tmp == 253) {
#line 111
    goto case_253;
  }
#line 118
  if ((int )tmp == 14) {
#line 118
    goto case_14;
  }
#line 150
  if ((int )tmp == 255) {
#line 150
    goto case_255;
  }
#line 97
  goto switch_break;
  case_0: /* CIL Label */ 
#line 99
  if (*fxp) {
#line 100
    arpeggio_val[c___0] = *fxp;
  } else {
#line 102
    *fxp = arpeggio_val[c___0];
  }
#line 103
  goto switch_break;
  case_254: /* CIL Label */ 
#line 105
  *fxt = (uint8 )1;
#line 106
  if ((int )*fxp < 48) {
#line 107
    *fxp = (uint8 )((((int )*fxp >> 2) & 15) | 224);
  } else {
#line 109
    *fxp = (uint8 )((((int )*fxp >> 4) & 15) | 240);
  }
#line 110
  goto switch_break;
  case_253: /* CIL Label */ 
#line 112
  *fxt = (uint8 )2;
#line 113
  if ((int )*fxp < 48) {
#line 114
    *fxp = (uint8 )((((int )*fxp >> 2) & 15) | 224);
  } else {
#line 116
    *fxp = (uint8 )((((int )*fxp >> 4) & 15) | 240);
  }
#line 117
  goto switch_break;
  case_14: /* CIL Label */ 
  {
#line 127
  if ((int )h == 15) {
#line 127
    goto case_15;
  }
#line 127
  if ((int )h == 14) {
#line 127
    goto case_15;
  }
#line 127
  if ((int )h == 9) {
#line 127
    goto case_15;
  }
#line 127
  if ((int )h == 7) {
#line 127
    goto case_15;
  }
#line 127
  if ((int )h == 6) {
#line 127
    goto case_15;
  }
#line 127
  if ((int )h == 4) {
#line 127
    goto case_15;
  }
#line 127
  if ((int )h == 2) {
#line 127
    goto case_15;
  }
#line 127
  if ((int )h == 1) {
#line 127
    goto case_15;
  }
#line 130
  if ((int )h == 3) {
#line 130
    goto case_3;
  }
#line 133
  if ((int )h == 5) {
#line 133
    goto case_5;
  }
#line 136
  if ((int )h == 8) {
#line 136
    goto case_8;
  }
#line 139
  if ((int )h == 10) {
#line 139
    goto case_10;
  }
#line 142
  if ((int )h == 11) {
#line 142
    goto case_11;
  }
#line 145
  if ((int )h == 12) {
#line 145
    goto case_12;
  }
#line 119
  goto switch_break___0;
  case_15: /* CIL Label */ 
  case_14___0: /* CIL Label */ 
  case_9: /* CIL Label */ 
  case_7: /* CIL Label */ 
  case_6: /* CIL Label */ 
  case_4: /* CIL Label */ 
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
#line 128
  tmp___0 = (uint8 )0;
#line 128
  *fxt = tmp___0;
#line 128
  *fxp = tmp___0;
#line 129
  goto switch_break___0;
  case_3: /* CIL Label */ 
#line 131
  *fxp = (uint8 )((int )l | (3 << 4));
#line 132
  goto switch_break___0;
  case_5: /* CIL Label */ 
#line 134
  *fxp = (uint8 )((int )l | (4 << 4));
#line 135
  goto switch_break___0;
  case_8: /* CIL Label */ 
#line 137
  *fxp = (uint8 )((int )l | (7 << 4));
#line 138
  goto switch_break___0;
  case_10: /* CIL Label */ 
#line 140
  *fxp = (uint8 )((int )l | (6 << 4));
#line 141
  goto switch_break___0;
  case_11: /* CIL Label */ 
#line 143
  *fxp = (uint8 )((int )l | (14 << 4));
#line 144
  goto switch_break___0;
  case_12: /* CIL Label */ 
#line 146
  if ((int )l == 0) {
#line 147
    tmp___1 = (uint8 )0;
#line 147
    *fxp = tmp___1;
#line 147
    *fxt = tmp___1;
  }
  switch_break___0: /* CIL Label */ ;
  }
#line 149
  goto switch_break;
  case_255: /* CIL Label */ 
#line 151
  tmp___2 = (uint8 )0;
#line 151
  *fxp = tmp___2;
#line 151
  *fxt = tmp___2;
#line 152
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 154
  return;
}
}
#line 157 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/imf_load.c"
static int imf_load(struct xmp_context *ctx___0 , FILE *f , int const   start ) 
{ 
  struct xmp_player_context *p ;
  struct xmp_mod_context *m___0 ;
  int c___0 ;
  int r ;
  int i___3 ;
  int j ;
  struct xxm_event *event ;
  struct xxm_event dummy___3 ;
  struct imf_header ih ;
  struct imf_instrument ii ;
  struct imf_sample is ;
  int pat_len ;
  int smp_num ;
  uint8 n___0 ;
  uint8 b___1 ;
  uint8 **tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  uint16 tmp___3 ;
  uint16 tmp___4 ;
  int j___0 ;
  void *tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  void *tmp___9 ;
  void *tmp___10 ;
  void *tmp___11 ;
  void *tmp___12 ;
  void *tmp___13 ;
  int tmp___14 ;
  size_t tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  void *tmp___18 ;
  int tmp___19 ;
  void *tmp___20 ;
  void *__cil_tmp42 ;
  void *__cil_tmp43 ;
  void *__cil_tmp44 ;
  void *__cil_tmp45 ;
  void *__cil_tmp46 ;
  void *__cil_tmp47 ;
  int __cil_tmp48 ;
  void *__cil_tmp49 ;
  void *__cil_tmp50 ;
  void *__cil_tmp51 ;
  void *__cil_tmp52 ;
  void *__cil_tmp53 ;
  void *__cil_tmp54 ;
  void *__cil_tmp55 ;
  void *__cil_tmp56 ;
  void *__cil_tmp57 ;
  void *__cil_tmp58 ;
  void *__cil_tmp59 ;
  int __cil_tmp60 ;
  void *__cil_tmp61 ;
  void *__cil_tmp62 ;
  void *__cil_tmp63 ;
  void *__cil_tmp64 ;
  void *__cil_tmp65 ;
  void *__cil_tmp66 ;
  void *__cil_tmp67 ;
  char *__cil_tmp68 ;
  char *__cil_tmp69 ;
  char *__cil_tmp70 ;
  char *__cil_tmp71 ;
  char *__cil_tmp72 ;
  char *__cil_tmp73 ;
  char *__cil_tmp74 ;
  char *__cil_tmp75 ;
  char *__cil_tmp76 ;
  char *__cil_tmp77 ;
  char *__cil_tmp78 ;
  char *__cil_tmp79 ;
  char *__cil_tmp80 ;
  char *__cil_tmp81 ;
  char *__cil_tmp82 ;

  {
#line 159
  p = & ctx___0->p;
#line 160
  m___0 = & p->m;
#line 162
  event = (struct xxm_event *)0;
  {
#line 169
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 169
    fseek(f, (long )start, 0);
#line 169
    tmp = (uint8 **)((void *)0);
#line 169
    m___0->med_wav_table = tmp;
#line 169
    m___0->med_vol_table = tmp;
#line 169
    set_xxh_defaults(m___0->xxh);
    }
#line 169
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 172
  fread((void */* __restrict  */)(& ih.name), (size_t )32, (size_t )1, (FILE */* __restrict  */)f);
#line 173
  ih.len = read16l(f);
#line 174
  ih.pat = read16l(f);
#line 175
  ih.ins = read16l(f);
#line 176
  ih.flg = read16l(f);
#line 177
  fread((void */* __restrict  */)(& ih.unused1), (size_t )8, (size_t )1, (FILE */* __restrict  */)f);
#line 178
  ih.tpo = read8(f);
#line 179
  ih.bpm = read8(f);
#line 180
  ih.vol = read8(f);
#line 181
  ih.amp = read8(f);
#line 182
  fread((void */* __restrict  */)(& ih.unused2), (size_t )8, (size_t )1, (FILE */* __restrict  */)f);
#line 183
  ih.magic = read32b(f);
#line 185
  i___3 = 0;
  }
  {
#line 185
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 185
    if (! (i___3 < 32)) {
#line 185
      goto while_break___0;
    }
    {
#line 186
    fread((void */* __restrict  */)(& ih.chn[i___3].name), (size_t )12, (size_t )1,
          (FILE */* __restrict  */)f);
#line 187
    ih.chn[i___3].status = read8(f);
#line 188
    ih.chn[i___3].pan = read8(f);
#line 189
    ih.chn[i___3].chorus = read8(f);
#line 190
    ih.chn[i___3].reverb = read8(f);
#line 185
    i___3 ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 193
  fread((void */* __restrict  */)(& ih.pos), (size_t )256, (size_t )1, (FILE */* __restrict  */)f);
#line 200
  copy_adjust((uint8 *)(m___0->name), (uint8 *)(ih.name), 32);
#line 202
  (m___0->xxh)->len = (int )ih.len;
#line 203
  (m___0->xxh)->ins = (int )ih.ins;
#line 204
  (m___0->xxh)->smp = 1024;
#line 205
  (m___0->xxh)->pat = (int )ih.pat;
  }
#line 207
  if ((int )ih.flg & 1) {
#line 208
    (m___0->xxh)->flg |= 1;
  }
  {
#line 210
  (m___0->xxh)->tpo = (int )ih.tpo;
#line 211
  (m___0->xxh)->bpm = (int )ih.bpm;
#line 213
  sprintf((char */* __restrict  */)(m___0->type), (char const   */* __restrict  */)"IM10 (Imago Orpheus)");
  }
  {
#line 215
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 215
    if (m___0->verbosity) {
#line 215
      if (m___0->name[0]) {
        {
#line 215
        report((char *)"Module title   : %s\n", m___0->name);
        }
      }
#line 215
      if (m___0->type[0]) {
        {
#line 215
        report((char *)"Module type    : %s\n", m___0->type);
        }
      }
#line 215
      if (m___0->author[0]) {
        {
#line 215
        report((char *)"Author name    : %s\n", m___0->author);
        }
      }
#line 215
      if ((m___0->xxh)->len) {
        {
#line 215
        report((char *)"Module length  : %d patterns\n", (m___0->xxh)->len);
        }
      }
    }
#line 215
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 217
  i___3 = 0;
#line 217
  (m___0->xxh)->chn = i___3;
  {
#line 217
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 217
    if (! (i___3 < 32)) {
#line 217
      goto while_break___2;
    }
#line 218
    if ((int )ih.chn[i___3].status != 0) {
#line 219
      (m___0->xxh)->chn = i___3 + 1;
    } else {
#line 221
      goto __Cont;
    }
#line 222
    m___0->xxc[i___3].pan = (int )ih.chn[i___3].pan;
#line 223
    m___0->xxc[i___3].cho = (int )ih.chn[i___3].chorus;
#line 224
    m___0->xxc[i___3].rvb = (int )ih.chn[i___3].reverb;
#line 225
    m___0->xxc[i___3].flg |= 2;
    __Cont: /* CIL Label */ 
#line 217
    i___3 ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 227
  (m___0->xxh)->trk = (m___0->xxh)->pat * (m___0->xxh)->chn;
#line 229
  memcpy((void */* __restrict  */)(m___0->xxo), (void const   */* __restrict  */)(ih.pos),
         (size_t )(m___0->xxh)->len);
#line 230
  i___3 = 0;
  }
  {
#line 230
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 230
    if (! (i___3 < (m___0->xxh)->len)) {
#line 230
      goto while_break___3;
    }
#line 231
    if ((int )m___0->xxo[i___3] == 255) {
#line 232
      m___0->xxo[i___3] = (uint8 )((int )m___0->xxo[i___3] - 1);
    }
#line 230
    i___3 ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 234
  m___0->c4rate = 8363;
#line 235
  m___0->quirk |= 1 << 12;
  {
#line 237
  while (1) {
    while_continue___4: /* CIL Label */ ;
    {
#line 237
    tmp___0 = calloc((size_t )sizeof(struct xxm_track *), (size_t )(m___0->xxh)->trk);
#line 237
    m___0->xxt = (struct xxm_track **)tmp___0;
#line 237
    tmp___1 = calloc((size_t )sizeof(struct xxm_pattern *), (size_t )((m___0->xxh)->pat + 1));
#line 237
    m___0->xxp = (struct xxm_pattern **)tmp___1;
    }
#line 237
    goto while_break___4;
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 241
  reportv(ctx___0, 0, (char *)"Stored patterns: %d ", (m___0->xxh)->pat);
#line 243
  memset((void *)(arpeggio_val), 0, (size_t )32);
#line 245
  i___3 = 0;
  }
  {
#line 245
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 245
    if (! (i___3 < (m___0->xxh)->pat)) {
#line 245
      goto while_break___5;
    }
    {
#line 246
    while (1) {
      while_continue___6: /* CIL Label */ ;
      {
#line 246
      tmp___2 = calloc((size_t )1, (size_t )(sizeof(struct xxm_pattern ) + sizeof(struct xxm_trackinfo ) * (unsigned long )((m___0->xxh)->chn - 1)));
#line 246
      *(m___0->xxp + i___3) = (struct xxm_pattern *)tmp___2;
      }
#line 246
      goto while_break___6;
    }
    while_break___6: /* CIL Label */ ;
    }
    {
#line 248
    tmp___3 = read16l(f);
#line 248
    pat_len = (int )tmp___3 - 4;
#line 249
    tmp___4 = read16l(f);
#line 249
    (*(m___0->xxp + i___3))->rows = (int )tmp___4;
    }
    {
#line 250
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 250
      j___0 = 0;
      {
#line 250
      while (1) {
        while_continue___8: /* CIL Label */ ;
#line 250
        if (! (j___0 < (m___0->xxh)->chn)) {
#line 250
          goto while_break___8;
        }
        {
#line 250
        (*(m___0->xxp + i___3))->info[j___0].index = i___3 * (m___0->xxh)->chn + j___0;
#line 250
        tmp___5 = calloc((size_t )(sizeof(struct xxm_track ) + sizeof(struct xxm_event ) * (unsigned long )(*(m___0->xxp + i___3))->rows),
                         (size_t )1);
#line 250
        *(m___0->xxt + (i___3 * (m___0->xxh)->chn + j___0)) = (struct xxm_track *)tmp___5;
#line 250
        (*(m___0->xxt + (i___3 * (m___0->xxh)->chn + j___0)))->rows = (*(m___0->xxp + i___3))->rows;
#line 250
        j___0 ++;
        }
      }
      while_break___8: /* CIL Label */ ;
      }
#line 250
      goto while_break___7;
    }
    while_break___7: /* CIL Label */ ;
    }
#line 252
    r = 0;
    {
#line 254
    while (1) {
      while_continue___9: /* CIL Label */ ;
#line 254
      pat_len --;
#line 254
      if (! (pat_len >= 0)) {
#line 254
        goto while_break___9;
      }
      {
#line 255
      b___1 = read8(f);
      }
#line 257
      if ((int )b___1 == 0) {
#line 258
        r ++;
#line 259
        goto while_continue___9;
      }
#line 262
      c___0 = (int )b___1 & 31;
#line 263
      if (c___0 >= (m___0->xxh)->chn) {
#line 263
        event = & dummy___3;
      } else {
#line 263
        event = & (*(m___0->xxt + (*(m___0->xxp + i___3))->info[c___0].index))->event[r];
      }
#line 265
      if ((int )b___1 & 32) {
        {
#line 266
        n___0 = read8(f);
        }
        {
#line 269
        if ((int )n___0 == 160) {
#line 269
          goto case_160;
        }
#line 269
        if ((int )n___0 == 255) {
#line 269
          goto case_160;
        }
#line 272
        goto switch_default;
        case_160: /* CIL Label */ 
        case_255: /* CIL Label */ 
#line 270
        n___0 = (uint8 )129;
#line 271
        goto switch_break;
        switch_default: /* CIL Label */ 
#line 273
        n___0 = (uint8 )((1 + 12 * (((int )n___0 & 240) >> 4)) + ((int )n___0 & 15));
        switch_break: /* CIL Label */ ;
        }
        {
#line 276
        event->note = n___0;
#line 277
        event->ins = read8(f);
#line 278
        pat_len -= 2;
        }
      }
#line 280
      if ((int )b___1 & 128) {
        {
#line 281
        event->fxt = read8(f);
#line 282
        event->fxp = read8(f);
#line 283
        xlat_fx___2(c___0, & event->fxt, & event->fxp);
#line 284
        pat_len -= 2;
        }
      }
#line 286
      if ((int )b___1 & 64) {
        {
#line 287
        event->f2t = read8(f);
#line 288
        event->f2p = read8(f);
#line 289
        xlat_fx___2(c___0, & event->f2t, & event->f2p);
#line 290
        pat_len -= 2;
        }
      }
    }
    while_break___9: /* CIL Label */ ;
    }
    {
#line 293
    reportv(ctx___0, 0, (char *)".");
#line 245
    i___3 ++;
    }
  }
  while_break___5: /* CIL Label */ ;
  }
  {
#line 295
  reportv(ctx___0, 0, (char *)"\n");
  }
  {
#line 297
  while (1) {
    while_continue___10: /* CIL Label */ ;
    {
#line 297
    tmp___6 = calloc((size_t )sizeof(struct xxm_instrument_header ), (size_t )(m___0->xxh)->ins);
#line 297
    m___0->xxih = (struct xxm_instrument_header *)tmp___6;
#line 297
    tmp___7 = calloc((size_t )sizeof(struct xxm_instrument_map ), (size_t )(m___0->xxh)->ins);
#line 297
    m___0->xxim = (struct xxm_instrument_map *)tmp___7;
#line 297
    tmp___8 = calloc((size_t )sizeof(struct xxm_instrument *), (size_t )(m___0->xxh)->ins);
#line 297
    m___0->xxi = (struct xxm_instrument **)tmp___8;
    }
#line 297
    if ((m___0->xxh)->smp) {
      {
#line 297
      tmp___9 = calloc((size_t )sizeof(struct xxm_sample ), (size_t )(m___0->xxh)->smp);
#line 297
      m___0->xxs = (struct xxm_sample *)tmp___9;
      }
    }
    {
#line 297
    tmp___10 = calloc((size_t )sizeof(uint16 *), (size_t )(m___0->xxh)->ins);
#line 297
    m___0->xxae = (uint16 **)tmp___10;
#line 297
    tmp___11 = calloc((size_t )sizeof(uint16 *), (size_t )(m___0->xxh)->ins);
#line 297
    m___0->xxpe = (uint16 **)tmp___11;
#line 297
    tmp___12 = calloc((size_t )sizeof(uint16 *), (size_t )(m___0->xxh)->ins);
#line 297
    m___0->xxfe = (uint16 **)tmp___12;
    }
#line 297
    goto while_break___10;
  }
  while_break___10: /* CIL Label */ ;
  }
  {
#line 301
  reportv(ctx___0, 0, (char *)"Instruments    : %d ", (m___0->xxh)->ins);
#line 303
  reportv(ctx___0, 1, (char *)"\n     Instrument name                NSm Fade Env Smp# Len   Start End   C2Spd");
#line 306
  i___3 = 0;
#line 306
  smp_num = i___3;
  }
  {
#line 306
  while (1) {
    while_continue___11: /* CIL Label */ ;
#line 306
    if (! (i___3 < (m___0->xxh)->ins)) {
#line 306
      goto while_break___11;
    }
    {
#line 308
    fread((void */* __restrict  */)(& ii.name), (size_t )32, (size_t )1, (FILE */* __restrict  */)f);
#line 309
    fread((void */* __restrict  */)(& ii.map), (size_t )120, (size_t )1, (FILE */* __restrict  */)f);
#line 310
    fread((void */* __restrict  */)(& ii.unused), (size_t )8, (size_t )1, (FILE */* __restrict  */)f);
#line 311
    j = 0;
    }
    {
#line 311
    while (1) {
      while_continue___12: /* CIL Label */ ;
#line 311
      if (! (j < 32)) {
#line 311
        goto while_break___12;
      }
      {
#line 312
      ii.vol_env[j] = read16l(f);
#line 311
      j ++;
      }
    }
    while_break___12: /* CIL Label */ ;
    }
#line 313
    j = 0;
    {
#line 313
    while (1) {
      while_continue___13: /* CIL Label */ ;
#line 313
      if (! (j < 32)) {
#line 313
        goto while_break___13;
      }
      {
#line 314
      ii.pan_env[j] = read16l(f);
#line 313
      j ++;
      }
    }
    while_break___13: /* CIL Label */ ;
    }
#line 315
    j = 0;
    {
#line 315
    while (1) {
      while_continue___14: /* CIL Label */ ;
#line 315
      if (! (j < 32)) {
#line 315
        goto while_break___14;
      }
      {
#line 316
      ii.pitch_env[j] = read16l(f);
#line 315
      j ++;
      }
    }
    while_break___14: /* CIL Label */ ;
    }
#line 317
    j = 0;
    {
#line 317
    while (1) {
      while_continue___15: /* CIL Label */ ;
#line 317
      if (! (j < 3)) {
#line 317
        goto while_break___15;
      }
      {
#line 318
      ii.env[j].npt = read8(f);
#line 319
      ii.env[j].sus = read8(f);
#line 320
      ii.env[j].lps = read8(f);
#line 321
      ii.env[j].lpe = read8(f);
#line 322
      ii.env[j].flg = read8(f);
#line 323
      fread((void */* __restrict  */)(& ii.env[j].unused), (size_t )3, (size_t )1,
            (FILE */* __restrict  */)f);
#line 317
      j ++;
      }
    }
    while_break___15: /* CIL Label */ ;
    }
    {
#line 325
    ii.fadeout = read16l(f);
#line 326
    ii.nsm = read16l(f);
#line 327
    ii.magic = read32b(f);
    }
#line 329
    if (ii.magic != ((((73U << 24) | (73U << 16)) | (49U << 8)) | 48U)) {
#line 330
      return (-2);
    }
#line 332
    if (ii.nsm) {
      {
#line 333
      tmp___13 = calloc((size_t )sizeof(struct xxm_instrument ), (size_t )ii.nsm);
#line 333
      *(m___0->xxi + i___3) = (struct xxm_instrument *)tmp___13;
      }
    }
    {
#line 335
    (m___0->xxih + i___3)->nsm = (int )ii.nsm;
#line 337
    str_adj(ii.name);
#line 338
    strncpy((char */* __restrict  */)((char *)((m___0->xxih + i___3)->name)), (char const   */* __restrict  */)(ii.name),
            (size_t )24);
#line 340
    memcpy((void */* __restrict  */)((m___0->xxim + i___3)->ins), (void const   */* __restrict  */)(ii.map),
           (size_t )108);
    }
#line 342
    if (m___0->verbosity > 1) {
      {
#line 342
      tmp___15 = strlen((char const   *)(ii.name));
      }
#line 342
      if (tmp___15) {
#line 342
        goto _L;
      } else
#line 342
      if (ii.nsm) {
        _L: /* CIL Label */ 
#line 343
        if ((int )ii.env[0].flg & 1) {
#line 343
          tmp___14 = 'V';
        } else {
#line 343
          tmp___14 = '-';
        }
        {
#line 343
        report((char *)"\n[%2X] %-31.31s %2d %4x %c%c%c ", i___3, ii.name, (int )ii.nsm,
               (int )ii.fadeout, tmp___14, '-', '-');
        }
      }
    }
#line 348
    (m___0->xxih + i___3)->aei.npt = (int )ii.env[0].npt;
#line 349
    (m___0->xxih + i___3)->aei.sus = (int )ii.env[0].sus;
#line 350
    (m___0->xxih + i___3)->aei.lps = (int )ii.env[0].lps;
#line 351
    (m___0->xxih + i___3)->aei.lpe = (int )ii.env[0].lpe;
#line 352
    if ((int )ii.env[0].flg & 1) {
#line 352
      (m___0->xxih + i___3)->aei.flg = 1;
    } else {
#line 352
      (m___0->xxih + i___3)->aei.flg = 0;
    }
#line 353
    if ((int )ii.env[0].flg & 2) {
#line 353
      tmp___16 = 2;
    } else {
#line 353
      tmp___16 = 0;
    }
#line 353
    (m___0->xxih + i___3)->aei.flg |= tmp___16;
#line 354
    if ((int )ii.env[0].flg & 4) {
#line 354
      tmp___17 = 4;
    } else {
#line 354
      tmp___17 = 0;
    }
#line 354
    (m___0->xxih + i___3)->aei.flg |= tmp___17;
#line 356
    if ((m___0->xxih + i___3)->aei.npt) {
      {
#line 357
      tmp___18 = calloc((size_t )4, (size_t )(m___0->xxih + i___3)->aei.npt);
#line 357
      *(m___0->xxae + i___3) = (uint16 *)tmp___18;
      }
    }
#line 359
    j = 0;
    {
#line 359
    while (1) {
      while_continue___16: /* CIL Label */ ;
#line 359
      if (! (j < (m___0->xxih + i___3)->aei.npt)) {
#line 359
        goto while_break___16;
      }
#line 360
      *(*(m___0->xxae + i___3) + j * 2) = ii.vol_env[j * 2];
#line 361
      *(*(m___0->xxae + i___3) + (j * 2 + 1)) = ii.vol_env[j * 2 + 1];
#line 359
      j ++;
    }
    while_break___16: /* CIL Label */ ;
    }
#line 364
    j = 0;
    {
#line 364
    while (1) {
      while_continue___17: /* CIL Label */ ;
#line 364
      if (! (j < (int )ii.nsm)) {
#line 364
        goto while_break___17;
      }
      {
#line 366
      fread((void */* __restrict  */)(& is.name), (size_t )13, (size_t )1, (FILE */* __restrict  */)f);
#line 367
      fread((void */* __restrict  */)(& is.unused1), (size_t )3, (size_t )1, (FILE */* __restrict  */)f);
#line 368
      is.len = read32l(f);
#line 369
      is.lps = read32l(f);
#line 370
      is.lpe = read32l(f);
#line 371
      is.rate = read32l(f);
#line 372
      is.vol = read8(f);
#line 373
      is.pan = read8(f);
#line 374
      fread((void */* __restrict  */)(& is.unused2), (size_t )14, (size_t )1, (FILE */* __restrict  */)f);
#line 375
      is.flg = read8(f);
#line 376
      fread((void */* __restrict  */)(& is.unused3), (size_t )5, (size_t )1, (FILE */* __restrict  */)f);
#line 377
      is.ems = read16l(f);
#line 378
      is.dram = read32l(f);
#line 379
      is.magic = read32b(f);
#line 381
      (*(m___0->xxi + i___3) + j)->sid = smp_num;
#line 382
      (*(m___0->xxi + i___3) + j)->vol = (int )is.vol;
#line 383
      (*(m___0->xxi + i___3) + j)->pan = (int )is.pan;
#line 384
      (m___0->xxs + smp_num)->len = (int )is.len;
#line 385
      (m___0->xxs + smp_num)->lps = (int )is.lps;
#line 386
      (m___0->xxs + smp_num)->lpe = (int )is.lpe;
      }
#line 387
      if ((int )is.flg & 1) {
#line 387
        (m___0->xxs + smp_num)->flg = 4;
      } else {
#line 387
        (m___0->xxs + smp_num)->flg = 0;
      }
#line 388
      if ((int )is.flg & 4) {
#line 388
        tmp___19 = 1;
      } else {
#line 388
        tmp___19 = 0;
      }
#line 388
      (m___0->xxs + smp_num)->flg |= tmp___19;
#line 390
      if (m___0->verbosity > 1) {
#line 391
        if (j) {
          {
#line 392
          report((char *)"\n\t\t\t\t\t\t ");
          }
        }
        {
#line 393
        report((char *)"[%02x] %05x %05x %05x %5d ", j, is.len, is.lps, is.lpe, is.rate);
        }
      }
      {
#line 396
      c2spd_to_note((int )is.rate, & (*(m___0->xxi + i___3) + j)->xpo, & (*(m___0->xxi + i___3) + j)->fin);
      }
#line 398
      if (! (m___0->xxs + smp_num)->len) {
#line 399
        goto __Cont___0;
      }
      {
#line 401
      xmp_drv_loadpatch(ctx___0, f, (*(m___0->xxi + i___3) + j)->sid, m___0->c4rate,
                        0, m___0->xxs + (*(m___0->xxi + i___3) + j)->sid, (char *)((void *)0));
#line 404
      reportv(ctx___0, 0, (char *)".");
      }
      __Cont___0: /* CIL Label */ 
#line 364
      j ++;
#line 364
      smp_num ++;
    }
    while_break___17: /* CIL Label */ ;
    }
#line 306
    i___3 ++;
  }
  while_break___11: /* CIL Label */ ;
  }
  {
#line 407
  (m___0->xxh)->smp = smp_num;
#line 408
  tmp___20 = realloc((void *)m___0->xxs, (size_t )(sizeof(struct xxm_sample ) * (unsigned long )(m___0->xxh)->smp));
#line 408
  m___0->xxs = (struct xxm_sample *)tmp___20;
#line 410
  reportv(ctx___0, 0, (char *)"\n");
#line 412
  m___0->flags |= 1 << 8;
#line 413
  m___0->quirk |= ((((1 << 5) | (1 << 4)) | (1 << 1)) | (1 << 14)) | (1 << 17);
  }
#line 415
  return (0);
}
}
#line 21 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/emod_load.c"
static int emod_test(FILE *f , char *t , int const   start ) ;
#line 22
static int emod_load(struct xmp_context *ctx___0 , FILE *f , int const   start ) ;
#line 24 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/emod_load.c"
struct xmp_loader_info emod_loader  =    {(char *)"EMOD", (char *)"Quadra Composer", & emod_test, & emod_load, 0, {(struct list_head *)0,
                                                                             (struct list_head *)0}};
#line 31 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/emod_load.c"
static int emod_test(FILE *f , char *t , int const   start ) 
{ 
  uint32 tmp ;
  uint32 tmp___0 ;

  {
  {
#line 33
  tmp = read32b(f);
  }
#line 33
  if (tmp != ((((70U << 24) | (79U << 16)) | (82U << 8)) | 77U)) {
#line 34
    return (-1);
  }
  {
#line 36
  read32b(f);
#line 38
  tmp___0 = read32b(f);
  }
#line 38
  if (tmp___0 != ((((69U << 24) | (77U << 16)) | (79U << 8)) | 68U)) {
#line 39
    return (-1);
  }
  {
#line 41
  read_title(f, t, 0);
  }
#line 43
  return (0);
}
}
#line 47 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/emod_load.c"
static uint8 *reorder  ;
#line 50 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/emod_load.c"
static void get_emic(struct xmp_context *ctx___0 , int size___0 , FILE *f ) 
{ 
  struct xmp_player_context *p ;
  struct xmp_mod_context *m___0 ;
  int i___3 ;
  int ver___0 ;
  uint16 tmp ;
  uint8 tmp___0 ;
  uint8 tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  void *tmp___9 ;
  uint8 tmp___10 ;
  uint16 tmp___11 ;
  uint8 tmp___13 ;
  uint8 tmp___14 ;
  uint16 tmp___15 ;
  uint16 tmp___16 ;
  int tmp___17 ;
  size_t tmp___18 ;
  uint8 tmp___19 ;
  void *tmp___20 ;
  void *tmp___21 ;
  void *tmp___22 ;
  uint8 tmp___23 ;
  void *tmp___24 ;
  uint8 tmp___25 ;
  int j ;
  void *tmp___26 ;
  uint8 tmp___27 ;
  uint8 tmp___28 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;

  {
  {
#line 52
  p = & ctx___0->p;
#line 53
  m___0 = & p->m;
#line 56
  tmp = read16b(f);
#line 56
  ver___0 = (int )tmp;
#line 57
  fread((void */* __restrict  */)(m___0->name), (size_t )1, (size_t )20, (FILE */* __restrict  */)f);
#line 58
  fread((void */* __restrict  */)(m___0->author), (size_t )1, (size_t )20, (FILE */* __restrict  */)f);
#line 59
  tmp___0 = read8(f);
#line 59
  (m___0->xxh)->bpm = (int )tmp___0;
#line 60
  tmp___1 = read8(f);
#line 60
  (m___0->xxh)->ins = (int )tmp___1;
#line 61
  (m___0->xxh)->smp = (m___0->xxh)->ins;
#line 63
  (m___0->xxh)->flg |= 2;
#line 65
  snprintf((char */* __restrict  */)(m___0->type), (size_t )64, (char const   */* __restrict  */)"EMOD v%d (Quadra Composer)",
           ver___0);
  }
  {
#line 66
  while (1) {
    while_continue: /* CIL Label */ ;
#line 66
    if (m___0->verbosity) {
#line 66
      if (m___0->name[0]) {
        {
#line 66
        report((char *)"Module title   : %s\n", m___0->name);
        }
      }
#line 66
      if (m___0->type[0]) {
        {
#line 66
        report((char *)"Module type    : %s\n", m___0->type);
        }
      }
#line 66
      if (m___0->author[0]) {
        {
#line 66
        report((char *)"Author name    : %s\n", m___0->author);
        }
      }
#line 66
      if ((m___0->xxh)->len) {
        {
#line 66
        report((char *)"Module length  : %d patterns\n", (m___0->xxh)->len);
        }
      }
    }
#line 66
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 68
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 68
    tmp___2 = calloc((size_t )sizeof(struct xxm_instrument_header ), (size_t )(m___0->xxh)->ins);
#line 68
    m___0->xxih = (struct xxm_instrument_header *)tmp___2;
#line 68
    tmp___3 = calloc((size_t )sizeof(struct xxm_instrument_map ), (size_t )(m___0->xxh)->ins);
#line 68
    m___0->xxim = (struct xxm_instrument_map *)tmp___3;
#line 68
    tmp___4 = calloc((size_t )sizeof(struct xxm_instrument *), (size_t )(m___0->xxh)->ins);
#line 68
    m___0->xxi = (struct xxm_instrument **)tmp___4;
    }
#line 68
    if ((m___0->xxh)->smp) {
      {
#line 68
      tmp___5 = calloc((size_t )sizeof(struct xxm_sample ), (size_t )(m___0->xxh)->smp);
#line 68
      m___0->xxs = (struct xxm_sample *)tmp___5;
      }
    }
    {
#line 68
    tmp___6 = calloc((size_t )sizeof(uint16 *), (size_t )(m___0->xxh)->ins);
#line 68
    m___0->xxae = (uint16 **)tmp___6;
#line 68
    tmp___7 = calloc((size_t )sizeof(uint16 *), (size_t )(m___0->xxh)->ins);
#line 68
    m___0->xxpe = (uint16 **)tmp___7;
#line 68
    tmp___8 = calloc((size_t )sizeof(uint16 *), (size_t )(m___0->xxh)->ins);
#line 68
    m___0->xxfe = (uint16 **)tmp___8;
    }
#line 68
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 70
  reportv(ctx___0, 1, (char *)"     Instrument name      Len  LBeg LEnd L Vol Fin\n");
#line 72
  i___3 = 0;
  }
  {
#line 72
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 72
    if (! (i___3 < (m___0->xxh)->ins)) {
#line 72
      goto while_break___1;
    }
    {
#line 73
    tmp___9 = calloc((size_t )sizeof(struct xxm_instrument ), (size_t )1);
#line 73
    *(m___0->xxi + i___3) = (struct xxm_instrument *)tmp___9;
#line 75
    read8(f);
#line 76
    tmp___10 = read8(f);
#line 76
    (*(m___0->xxi + i___3) + 0)->vol = (int )tmp___10;
#line 77
    tmp___11 = read16b(f);
#line 77
    (m___0->xxs + i___3)->len = 2 * (int )tmp___11;
#line 78
    fread((void */* __restrict  */)((m___0->xxih + i___3)->name), (size_t )1, (size_t )20,
          (FILE */* __restrict  */)f);
#line 79
    tmp___13 = read8(f);
    }
#line 79
    if ((int )tmp___13 & 1) {
#line 79
      (m___0->xxs + i___3)->flg = 4;
    } else {
#line 79
      (m___0->xxs + i___3)->flg = 0;
    }
    {
#line 80
    tmp___14 = read8(f);
#line 80
    (*(m___0->xxi + i___3) + 0)->fin = (int )tmp___14;
#line 81
    tmp___15 = read16b(f);
#line 81
    (m___0->xxs + i___3)->lps = 2 * (int )tmp___15;
#line 82
    tmp___16 = read16b(f);
#line 82
    (m___0->xxs + i___3)->lpe = (m___0->xxs + i___3)->lps + 2 * (int )tmp___16;
#line 83
    read32b(f);
#line 85
    (m___0->xxih + i___3)->nsm = 1;
#line 86
    (*(m___0->xxi + i___3) + 0)->pan = 128;
#line 87
    (*(m___0->xxi + i___3) + 0)->sid = i___3;
    }
#line 89
    if (m___0->verbosity > 1) {
      {
#line 89
      tmp___18 = strlen((char const   *)((char *)((m___0->xxih + i___3)->name)));
      }
#line 89
      if (tmp___18) {
#line 89
        goto _L;
      } else
#line 89
      if ((m___0->xxs + i___3)->len > 2) {
        _L: /* CIL Label */ 
#line 90
        if ((m___0->xxs + i___3)->flg & 4) {
#line 90
          tmp___17 = 'L';
        } else {
#line 90
          tmp___17 = ' ';
        }
        {
#line 90
        report((char *)"[%2X] %-20.20s %05x %05x %05x %c V%02x %+d\n", i___3, (m___0->xxih + i___3)->name,
               (m___0->xxs + i___3)->len, (m___0->xxs + i___3)->lps, (m___0->xxs + i___3)->lpe,
               tmp___17, (*(m___0->xxi + i___3) + 0)->vol, (*(m___0->xxi + i___3) + 0)->fin >> 4);
        }
      }
    }
#line 72
    i___3 ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 97
  read8(f);
#line 98
  tmp___19 = read8(f);
#line 98
  (m___0->xxh)->pat = (int )tmp___19;
#line 100
  (m___0->xxh)->trk = (m___0->xxh)->pat * (m___0->xxh)->chn;
  }
  {
#line 102
  while (1) {
    while_continue___2: /* CIL Label */ ;
    {
#line 102
    tmp___20 = calloc((size_t )sizeof(struct xxm_track *), (size_t )(m___0->xxh)->trk);
#line 102
    m___0->xxt = (struct xxm_track **)tmp___20;
#line 102
    tmp___21 = calloc((size_t )sizeof(struct xxm_pattern *), (size_t )((m___0->xxh)->pat + 1));
#line 102
    m___0->xxp = (struct xxm_pattern **)tmp___21;
    }
#line 102
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 104
  tmp___22 = calloc((size_t )1, (size_t )256);
#line 104
  reorder = (uint8 *)tmp___22;
#line 106
  i___3 = 0;
  }
  {
#line 106
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 106
    if (! (i___3 < (m___0->xxh)->pat)) {
#line 106
      goto while_break___3;
    }
    {
#line 107
    tmp___23 = read8(f);
#line 107
    *(reorder + tmp___23) = (uint8 )i___3;
    }
    {
#line 108
    while (1) {
      while_continue___4: /* CIL Label */ ;
      {
#line 108
      tmp___24 = calloc((size_t )1, (size_t )(sizeof(struct xxm_pattern ) + sizeof(struct xxm_trackinfo ) * (unsigned long )((m___0->xxh)->chn - 1)));
#line 108
      *(m___0->xxp + i___3) = (struct xxm_pattern *)tmp___24;
      }
#line 108
      goto while_break___4;
    }
    while_break___4: /* CIL Label */ ;
    }
    {
#line 109
    tmp___25 = read8(f);
#line 109
    (*(m___0->xxp + i___3))->rows = (int )tmp___25 + 1;
    }
    {
#line 110
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 110
      j = 0;
      {
#line 110
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 110
        if (! (j < (m___0->xxh)->chn)) {
#line 110
          goto while_break___6;
        }
        {
#line 110
        (*(m___0->xxp + i___3))->info[j].index = i___3 * (m___0->xxh)->chn + j;
#line 110
        tmp___26 = calloc((size_t )(sizeof(struct xxm_track ) + sizeof(struct xxm_event ) * (unsigned long )(*(m___0->xxp + i___3))->rows),
                          (size_t )1);
#line 110
        *(m___0->xxt + (i___3 * (m___0->xxh)->chn + j)) = (struct xxm_track *)tmp___26;
#line 110
        (*(m___0->xxt + (i___3 * (m___0->xxh)->chn + j)))->rows = (*(m___0->xxp + i___3))->rows;
#line 110
        j ++;
        }
      }
      while_break___6: /* CIL Label */ ;
      }
#line 110
      goto while_break___5;
    }
    while_break___5: /* CIL Label */ ;
    }
    {
#line 111
    fseek(f, 20L, 1);
#line 112
    read32b(f);
#line 106
    i___3 ++;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 115
  tmp___27 = read8(f);
#line 115
  (m___0->xxh)->len = (int )tmp___27;
#line 117
  reportv(ctx___0, 0, (char *)"Module length  : %d\n", (m___0->xxh)->len);
#line 119
  i___3 = 0;
  }
  {
#line 119
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 119
    if (! (i___3 < (m___0->xxh)->len)) {
#line 119
      goto while_break___7;
    }
    {
#line 120
    tmp___28 = read8(f);
#line 120
    m___0->xxo[i___3] = *(reorder + tmp___28);
#line 119
    i___3 ++;
    }
  }
  while_break___7: /* CIL Label */ ;
  }
#line 121
  return;
}
}
#line 124 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/emod_load.c"
static void get_patt___5(struct xmp_context *ctx___0 , int size___0 , FILE *f ) 
{ 
  struct xmp_player_context *p ;
  struct xmp_mod_context *m___0 ;
  int i___3 ;
  int j ;
  int k ;
  struct xxm_event *event ;
  uint8 x ;
  uint8 tmp ;
  uint8 tmp___0 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
  {
#line 126
  p = & ctx___0->p;
#line 127
  m___0 = & p->m;
#line 132
  reportv(ctx___0, 0, (char *)"Stored patterns: %d ", (m___0->xxh)->pat);
#line 134
  i___3 = 0;
  }
  {
#line 134
  while (1) {
    while_continue: /* CIL Label */ ;
#line 134
    if (! (i___3 < (m___0->xxh)->pat)) {
#line 134
      goto while_break;
    }
#line 135
    j = 0;
    {
#line 135
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 135
      if (! (j < (*(m___0->xxp + i___3))->rows)) {
#line 135
        goto while_break___0;
      }
#line 136
      k = 0;
      {
#line 136
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 136
        if (! (k < (m___0->xxh)->chn)) {
#line 136
          goto while_break___1;
        }
        {
#line 137
        event = & (*(m___0->xxt + (*(m___0->xxp + i___3))->info[k].index))->event[j];
#line 138
        event->ins = read8(f);
#line 139
        tmp = read8(f);
#line 139
        event->note = (uint8 )((int )tmp + 1);
        }
#line 140
        if ((int )event->note != 0) {
#line 141
          event->note = (uint8 )((int )event->note + 36);
        }
        {
#line 142
        tmp___0 = read8(f);
#line 142
        event->fxt = (uint8 )((int )tmp___0 & 15);
#line 143
        event->fxp = read8(f);
        }
        {
#line 147
        if ((int )event->fxt == 4) {
#line 147
          goto case_4;
        }
#line 151
        if ((int )event->fxt == 9) {
#line 151
          goto case_9;
        }
#line 154
        if ((int )event->fxt == 11) {
#line 154
          goto case_11;
        }
#line 146
        goto switch_break;
        case_4: /* CIL Label */ 
#line 148
        x = event->fxp;
#line 149
        event->fxp = (uint8 )(((int )x & 240) | (((int )x << 1) & 15));
#line 150
        goto switch_break;
        case_9: /* CIL Label */ 
#line 152
        event->fxt = (uint8 )((int )event->fxt << 1);
#line 153
        goto switch_break;
        case_11: /* CIL Label */ 
#line 155
        x = event->fxt;
#line 156
        event->fxt = (uint8 )(16 * ((int )x / 10) + (int )x % 10);
#line 157
        goto switch_break;
        switch_break: /* CIL Label */ ;
        }
#line 136
        k ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 135
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 161
    reportv(ctx___0, 0, (char *)".");
#line 134
    i___3 ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 163
  reportv(ctx___0, 0, (char *)"\n");
  }
#line 164
  return;
}
}
#line 167 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/emod_load.c"
static void get_8smp(struct xmp_context *ctx___0 , int size___0 , FILE *f ) 
{ 
  struct xmp_player_context *p ;
  struct xmp_mod_context *m___0 ;
  int i___3 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
  {
#line 169
  p = & ctx___0->p;
#line 170
  m___0 = & p->m;
#line 173
  reportv(ctx___0, 0, (char *)"Stored samples : %d ", (m___0->xxh)->smp);
#line 175
  i___3 = 0;
  }
  {
#line 175
  while (1) {
    while_continue: /* CIL Label */ ;
#line 175
    if (! (i___3 < (m___0->xxh)->smp)) {
#line 175
      goto while_break;
    }
    {
#line 176
    xmp_drv_loadpatch(ctx___0, f, i___3, m___0->c4rate, 0, m___0->xxs + i___3, (char *)((void *)0));
#line 177
    reportv(ctx___0, 0, (char *)".");
#line 175
    i___3 ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 179
  reportv(ctx___0, 0, (char *)"\n");
  }
#line 180
  return;
}
}
#line 183 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/emod_load.c"
static int emod_load(struct xmp_context *ctx___0 , FILE *f , int const   start ) 
{ 
  struct xmp_player_context *p ;
  struct xmp_mod_context *m___0 ;
  uint8 **tmp ;
  int tmp___0 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
#line 185
  p = & ctx___0->p;
#line 186
  m___0 = & p->m;
  {
#line 188
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 188
    fseek(f, (long )start, 0);
#line 188
    tmp = (uint8 **)((void *)0);
#line 188
    m___0->med_wav_table = tmp;
#line 188
    m___0->med_vol_table = tmp;
#line 188
    set_xxh_defaults(m___0->xxh);
    }
#line 188
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 190
  read32b(f);
#line 191
  read32b(f);
#line 192
  read32b(f);
#line 195
  iff_register((char *)"EMIC", & get_emic);
#line 196
  iff_register((char *)"PATT", & get_patt___5);
#line 197
  iff_register((char *)"8SMP", & get_8smp);
  }
  {
#line 200
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 200
    tmp___0 = feof(f);
    }
#line 200
    if (tmp___0) {
#line 200
      goto while_break___0;
    }
    {
#line 201
    iff_chunk(ctx___0, f);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 203
  iff_release();
#line 204
  free((void *)reorder);
  }
#line 206
  return (0);
}
}
#line 25 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/st_load.c"
static int st_test(FILE *f , char *t , int const   start ) ;
#line 26
static int st_load(struct xmp_context *ctx___0 , FILE *f , int const   start ) ;
#line 28 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/st_load.c"
struct xmp_loader_info st_loader  =    {(char *)"ST", (char *)"Soundtracker", & st_test, & st_load, 0, {(struct list_head *)0,
                                                                    (struct list_head *)0}};
#line 35 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/st_load.c"
static int period[37]  = 
#line 35
  {      856,      808,      762,      720, 
        678,      640,      604,      570, 
        538,      508,      480,      453, 
        428,      404,      381,      360, 
        339,      320,      302,      285, 
        269,      254,      240,      226, 
        214,      202,      190,      180, 
        170,      160,      151,      143, 
        135,      127,      120,      113, 
        -1};
#line 42 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/st_load.c"
static int st_test(FILE *f , char *t , int const   start ) 
{ 
  int i___3 ;
  int j ;
  int k ;
  int pat___0 ;
  int smp_size ;
  struct st_header mh ;
  uint8 mod_event[4] ;
  struct stat st ;
  int tmp ;
  int tmp___0 ;
  uint8 tmp___1 ;
  uint8 tmp___2 ;
  int tmp___3 ;
  int p ;
  void *__cil_tmp18 ;
  void *__cil_tmp19 ;
  void *__cil_tmp20 ;
  int __cil_tmp21 ;
  void *__cil_tmp22 ;
  void *__cil_tmp23 ;
  void *__cil_tmp24 ;
  void *__cil_tmp25 ;
  void *__cil_tmp26 ;
  void *__cil_tmp27 ;
  void *__cil_tmp28 ;
  void *__cil_tmp29 ;

  {
  {
#line 50
  tmp = fileno(f);
#line 50
  fstat(tmp, & st);
#line 52
  smp_size = 0;
#line 54
  fread((void */* __restrict  */)(mh.name), (size_t )1, (size_t )20, (FILE */* __restrict  */)f);
#line 55
  tmp___0 = test_name(mh.name, 20);
  }
#line 55
  if (tmp___0 < 0) {
#line 56
    return (-1);
  }
#line 58
  i___3 = 0;
  {
#line 58
  while (1) {
    while_continue: /* CIL Label */ ;
#line 58
    if (! (i___3 < 15)) {
#line 58
      goto while_break;
    }
    {
#line 59
    fread((void */* __restrict  */)(mh.ins[i___3].name), (size_t )1, (size_t )22,
          (FILE */* __restrict  */)f);
#line 60
    mh.ins[i___3].size = read16b(f);
#line 61
    tmp___1 = read8(f);
#line 61
    mh.ins[i___3].finetune = (int8 )tmp___1;
#line 62
    tmp___2 = read8(f);
#line 62
    mh.ins[i___3].volume = (int8 )tmp___2;
#line 63
    mh.ins[i___3].loop_start = read16b(f);
#line 64
    mh.ins[i___3].loop_size = read16b(f);
#line 58
    i___3 ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 66
  mh.len = read8(f);
#line 67
  mh.restart = read8(f);
#line 68
  fread((void */* __restrict  */)(mh.order), (size_t )1, (size_t )128, (FILE */* __restrict  */)f);
#line 70
  i___3 = 0;
#line 70
  pat___0 = i___3;
  }
  {
#line 70
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 70
    if (! (i___3 < 128)) {
#line 70
      goto while_break___0;
    }
#line 71
    if ((int )mh.order[i___3] > 127) {
#line 72
      return (-1);
    }
#line 73
    if ((int )mh.order[i___3] > pat___0) {
#line 74
      pat___0 = (int )mh.order[i___3];
    }
#line 70
    i___3 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 76
  pat___0 ++;
#line 78
  if (pat___0 > 127) {
#line 79
    return (-1);
  } else
#line 78
  if ((int )mh.len == 0) {
#line 79
    return (-1);
  } else
#line 78
  if ((int )mh.len > 127) {
#line 79
    return (-1);
  }
#line 81
  i___3 = 0;
  {
#line 81
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 81
    if (! (i___3 < 15)) {
#line 81
      goto while_break___1;
    }
    {
#line 82
    tmp___3 = test_name(mh.ins[i___3].name, 22);
    }
#line 82
    if (tmp___3 < 0) {
#line 83
      return (-1);
    }
#line 85
    if ((int )mh.ins[i___3].volume > 64) {
#line 86
      return (-1);
    }
#line 88
    if ((int )mh.ins[i___3].finetune > 15) {
#line 89
      return (-1);
    }
#line 91
    if ((int )mh.ins[i___3].size > 32768) {
#line 92
      return (-1);
    }
#line 94
    if ((int )mh.ins[i___3].loop_start >> 1 > 32768) {
#line 95
      return (-1);
    }
#line 97
    if ((int )mh.ins[i___3].loop_size > 32768) {
#line 98
      return (-1);
    }
#line 106
    if ((int )mh.ins[i___3].loop_start >> 1 > (int )mh.ins[i___3].size) {
#line 107
      return (-1);
    }
#line 109
    if (mh.ins[i___3].size) {
#line 109
      if ((int )mh.ins[i___3].loop_start >> 1 == (int )mh.ins[i___3].size) {
#line 110
        return (-1);
      }
    }
#line 112
    if ((int )mh.ins[i___3].size == 0) {
#line 112
      if ((int )mh.ins[i___3].loop_start > 0) {
#line 113
        return (-1);
      }
    }
#line 115
    smp_size += 2 * (int )mh.ins[i___3].size;
#line 81
    i___3 ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 118
  if (smp_size < 8) {
#line 119
    return (-1);
  }
#line 121
  if (st.st_size < (__off_t )((600 + pat___0 * 1024) + smp_size)) {
#line 122
    return (-1);
  }
#line 124
  i___3 = 0;
  {
#line 124
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 124
    if (! (i___3 < pat___0)) {
#line 124
      goto while_break___2;
    }
#line 125
    j = 0;
    {
#line 125
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 125
      if (! (j < 256)) {
#line 125
        goto while_break___3;
      }
      {
#line 128
      fread((void */* __restrict  */)(mod_event), (size_t )1, (size_t )4, (FILE */* __restrict  */)f);
      }
#line 130
      if (((int )mod_event[0] & 240) >> 4) {
#line 131
        return (-1);
      }
#line 133
      p = 256 * ((int )mod_event[0] & 15) + (int )mod_event[1];
#line 135
      if (p == 0) {
#line 136
        goto __Cont;
      }
#line 138
      if (p == 162) {
#line 139
        goto __Cont;
      }
#line 141
      k = 0;
      {
#line 141
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 141
        if (! (period[k] >= 0)) {
#line 141
          goto while_break___4;
        }
#line 142
        if (p == period[k]) {
#line 143
          goto while_break___4;
        }
#line 141
        k ++;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 145
      if (period[k] < 0) {
#line 146
        return (-1);
      }
      __Cont: /* CIL Label */ 
#line 125
      j ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 124
    i___3 ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 150
  return (0);
}
}
#line 153 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/st_load.c"
static int st_load(struct xmp_context *ctx___0 , FILE *f , int const   start ) 
{ 
  struct xmp_player_context *p ;
  struct xmp_mod_context *m___0 ;
  struct xmp_options *o___0 ;
  int i___3 ;
  int j ;
  int smp_size ;
  int pat_size ;
  struct xxm_event ev ;
  struct xxm_event *event ;
  struct st_header mh ;
  uint8 mod_event[4] ;
  int ust ;
  int nt ;
  int serr ;
  char *modtype ;
  int fxused ;
  int pos___0 ;
  uint8 **tmp ;
  uint8 tmp___0 ;
  uint8 tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  void *tmp___9 ;
  long tmp___10 ;
  void *tmp___11 ;
  void *tmp___12 ;
  void *tmp___13 ;
  int j___0 ;
  void *tmp___14 ;
  int tmp___15 ;
  void *__cil_tmp39 ;
  void *__cil_tmp40 ;
  void *__cil_tmp41 ;
  void *__cil_tmp42 ;
  int __cil_tmp43 ;
  void *__cil_tmp44 ;
  void *__cil_tmp45 ;
  void *__cil_tmp46 ;
  void *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;
  char *__cil_tmp66 ;
  char *__cil_tmp67 ;
  char *__cil_tmp68 ;
  char *__cil_tmp69 ;

  {
#line 155
  p = & ctx___0->p;
#line 156
  m___0 = & p->m;
#line 157
  o___0 = & ctx___0->o;
#line 163
  ust = 1;
#line 163
  nt = 0;
#line 163
  serr = 0;
  {
#line 169
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 169
    fseek(f, (long )start, 0);
#line 169
    tmp = (uint8 **)((void *)0);
#line 169
    m___0->med_wav_table = tmp;
#line 169
    m___0->med_vol_table = tmp;
#line 169
    set_xxh_defaults(m___0->xxh);
    }
#line 169
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 171
  (m___0->xxh)->ins = 15;
#line 172
  (m___0->xxh)->smp = (m___0->xxh)->ins;
#line 173
  smp_size = 0;
#line 174
  pat_size = 0;
#line 176
  fread((void */* __restrict  */)(mh.name), (size_t )1, (size_t )20, (FILE */* __restrict  */)f);
#line 177
  i___3 = 0;
  }
  {
#line 177
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 177
    if (! (i___3 < 15)) {
#line 177
      goto while_break___0;
    }
    {
#line 178
    fread((void */* __restrict  */)(mh.ins[i___3].name), (size_t )1, (size_t )22,
          (FILE */* __restrict  */)f);
#line 179
    mh.ins[i___3].size = read16b(f);
#line 180
    tmp___0 = read8(f);
#line 180
    mh.ins[i___3].finetune = (int8 )tmp___0;
#line 181
    tmp___1 = read8(f);
#line 181
    mh.ins[i___3].volume = (int8 )tmp___1;
#line 182
    mh.ins[i___3].loop_start = read16b(f);
#line 183
    mh.ins[i___3].loop_size = read16b(f);
#line 177
    i___3 ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 185
  mh.len = read8(f);
#line 186
  mh.restart = read8(f);
#line 187
  fread((void */* __restrict  */)(mh.order), (size_t )1, (size_t )128, (FILE */* __restrict  */)f);
#line 189
  (m___0->xxh)->len = (int )mh.len;
#line 190
  (m___0->xxh)->rst = (int )mh.restart;
  }
#line 195
  if ((m___0->xxh)->rst < 64) {
#line 196
    ust = 0;
  }
  {
#line 198
  memcpy((void */* __restrict  */)(m___0->xxo), (void const   */* __restrict  */)(mh.order),
         (size_t )128);
#line 200
  i___3 = 0;
  }
  {
#line 200
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 200
    if (! (i___3 < 128)) {
#line 200
      goto while_break___1;
    }
#line 201
    if ((int )m___0->xxo[i___3] > (m___0->xxh)->pat) {
#line 202
      (m___0->xxh)->pat = (int )m___0->xxo[i___3];
    }
#line 200
    i___3 ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 203
  ((m___0->xxh)->pat) ++;
#line 205
  pat_size = (256 * (m___0->xxh)->chn) * (m___0->xxh)->pat;
#line 207
  i___3 = 0;
  {
#line 207
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 207
    if (! (i___3 < (m___0->xxh)->ins)) {
#line 207
      goto while_break___2;
    }
#line 211
    if (mh.ins[i___3].finetune) {
#line 212
      ust = 0;
    }
#line 214
    if ((int )mh.ins[i___3].size == 0) {
#line 214
      if ((int )mh.ins[i___3].loop_size == 1) {
#line 215
        nt = 1;
      }
    }
#line 221
    if ((int )mh.ins[i___3].size > 4999) {
#line 223
      ust = 0;
    } else
#line 221
    if ((int )mh.ins[i___3].loop_start > 9999) {
#line 223
      ust = 0;
    } else
#line 221
    if ((int )mh.ins[i___3].loop_size > 4999) {
#line 223
      ust = 0;
    }
#line 225
    smp_size += 2 * (int )mh.ins[i___3].size;
#line 207
    i___3 ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 228
  while (1) {
    while_continue___3: /* CIL Label */ ;
    {
#line 228
    tmp___2 = calloc((size_t )sizeof(struct xxm_instrument_header ), (size_t )(m___0->xxh)->ins);
#line 228
    m___0->xxih = (struct xxm_instrument_header *)tmp___2;
#line 228
    tmp___3 = calloc((size_t )sizeof(struct xxm_instrument_map ), (size_t )(m___0->xxh)->ins);
#line 228
    m___0->xxim = (struct xxm_instrument_map *)tmp___3;
#line 228
    tmp___4 = calloc((size_t )sizeof(struct xxm_instrument *), (size_t )(m___0->xxh)->ins);
#line 228
    m___0->xxi = (struct xxm_instrument **)tmp___4;
    }
#line 228
    if ((m___0->xxh)->smp) {
      {
#line 228
      tmp___5 = calloc((size_t )sizeof(struct xxm_sample ), (size_t )(m___0->xxh)->smp);
#line 228
      m___0->xxs = (struct xxm_sample *)tmp___5;
      }
    }
    {
#line 228
    tmp___6 = calloc((size_t )sizeof(uint16 *), (size_t )(m___0->xxh)->ins);
#line 228
    m___0->xxae = (uint16 **)tmp___6;
#line 228
    tmp___7 = calloc((size_t )sizeof(uint16 *), (size_t )(m___0->xxh)->ins);
#line 228
    m___0->xxpe = (uint16 **)tmp___7;
#line 228
    tmp___8 = calloc((size_t )sizeof(uint16 *), (size_t )(m___0->xxh)->ins);
#line 228
    m___0->xxfe = (uint16 **)tmp___8;
    }
#line 228
    goto while_break___3;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 230
  i___3 = 0;
  {
#line 230
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 230
    if (! (i___3 < (m___0->xxh)->ins)) {
#line 230
      goto while_break___4;
    }
    {
#line 231
    tmp___9 = calloc((size_t )sizeof(struct xxm_instrument ), (size_t )1);
#line 231
    *(m___0->xxi + i___3) = (struct xxm_instrument *)tmp___9;
#line 232
    (m___0->xxs + i___3)->len = 2 * (int )mh.ins[i___3].size;
#line 233
    (m___0->xxs + i___3)->lps = (int )mh.ins[i___3].loop_start;
#line 234
    (m___0->xxs + i___3)->lpe = (m___0->xxs + i___3)->lps + 2 * (int )mh.ins[i___3].loop_size;
    }
#line 235
    if ((int )mh.ins[i___3].loop_size > 1) {
#line 235
      (m___0->xxs + i___3)->flg = 4;
    } else {
#line 235
      (m___0->xxs + i___3)->flg = 0;
    }
    {
#line 236
    (*(m___0->xxi + i___3) + 0)->fin = (int )((int8 )((int )mh.ins[i___3].finetune << 4));
#line 237
    (*(m___0->xxi + i___3) + 0)->vol = (int )mh.ins[i___3].volume;
#line 238
    (*(m___0->xxi + i___3) + 0)->pan = 128;
#line 239
    (*(m___0->xxi + i___3) + 0)->sid = i___3;
#line 240
    (m___0->xxih + i___3)->nsm = ! (! (m___0->xxs + i___3)->len);
#line 241
    strncpy((char */* __restrict  */)((char *)((m___0->xxih + i___3)->name)), (char const   */* __restrict  */)((char *)(mh.ins[i___3].name)),
            (size_t )22);
#line 242
    str_adj((char *)((m___0->xxih + i___3)->name));
#line 230
    i___3 ++;
    }
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 245
  (m___0->xxh)->trk = (m___0->xxh)->chn * (m___0->xxh)->pat;
#line 247
  strncpy((char */* __restrict  */)(m___0->name), (char const   */* __restrict  */)((char *)(mh.name)),
          (size_t )20);
#line 250
  fxused = 0;
#line 251
  tmp___10 = ftell(f);
#line 251
  pos___0 = (int )tmp___10;
#line 253
  i___3 = 0;
  }
  {
#line 253
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 253
    if (! (i___3 < (m___0->xxh)->pat)) {
#line 253
      goto while_break___5;
    }
#line 254
    j = 0;
    {
#line 254
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 254
      if (! (j < 64 * (m___0->xxh)->chn)) {
#line 254
        goto while_break___6;
      }
      {
#line 255
      fread((void */* __restrict  */)(mod_event), (size_t )1, (size_t )4, (FILE */* __restrict  */)f);
#line 257
      cvt_pt_event(& ev, mod_event);
      }
#line 259
      if (ev.fxt) {
#line 260
        fxused |= 1 << (int )ev.fxt;
      } else
#line 261
      if (ev.fxp) {
#line 262
        fxused |= 1;
      }
#line 267
      if (ev.fxt) {
#line 267
        if ((int )ev.fxt != 1) {
#line 267
          if ((int )ev.fxt != 2) {
#line 268
            ust = 0;
          }
        }
      }
#line 271
      if ((int )ev.fxt == 1) {
#line 272
        if ((int )ev.fxp == 0) {
#line 273
          ust = 0;
        }
      }
#line 278
      if ((int )ev.fxt == 2) {
#line 279
        if (((int )ev.fxp & 15) != 0) {
#line 279
          if (((int )ev.fxp & 240) != 0) {
#line 280
            ust = 0;
          }
        }
      }
#line 254
      j ++;
    }
    while_break___6: /* CIL Label */ ;
    }
#line 253
    i___3 ++;
  }
  while_break___5: /* CIL Label */ ;
  }
#line 285
  if (fxused & -7) {
#line 286
    ust = 0;
  }
#line 288
  if (ust) {
#line 289
    modtype = (char *)"Ultimate Soundtracker";
  } else
#line 290
  if ((fxused & -53256) == 0) {
#line 291
    modtype = (char *)"Soundtracker IX";
  } else
#line 292
  if ((fxused & -63496) == 0) {
#line 293
    modtype = (char *)"D.O.C. Soundtracker";
  } else
#line 294
  if ((fxused & -64520) == 0) {
#line 295
    modtype = (char *)"Soundtracker 2.3/2.4";
  } else
#line 296
  if ((fxused & -64576) == 0) {
#line 297
    modtype = (char *)"Noisetracker 1.0/1.2";
  } else
#line 298
  if ((fxused & -64704) == 0) {
#line 299
    modtype = (char *)"Noisetracker 2.0";
  } else {
#line 301
    modtype = (char *)"unknown tracker";
  }
#line 303
  if (ust) {
    {
#line 304
    snprintf((char */* __restrict  */)(m___0->type), (size_t )64, (char const   */* __restrict  */)"UST (%s)",
             modtype);
    }
  } else {
    {
#line 306
    snprintf((char */* __restrict  */)(m___0->type), (size_t )64, (char const   */* __restrict  */)"ST (%s)",
             modtype);
    }
  }
  {
#line 308
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 308
    if (m___0->verbosity) {
#line 308
      if (m___0->name[0]) {
        {
#line 308
        report((char *)"Module title   : %s\n", m___0->name);
        }
      }
#line 308
      if (m___0->type[0]) {
        {
#line 308
        report((char *)"Module type    : %s\n", m___0->type);
        }
      }
#line 308
      if (m___0->author[0]) {
        {
#line 308
        report((char *)"Author name    : %s\n", m___0->author);
        }
      }
#line 308
      if ((m___0->xxh)->len) {
        {
#line 308
        report((char *)"Module length  : %d patterns\n", (m___0->xxh)->len);
        }
      }
    }
#line 308
    goto while_break___7;
  }
  while_break___7: /* CIL Label */ ;
  }
#line 310
  if (serr) {
#line 310
    if (m___0->verbosity > 2) {
      {
#line 311
      report((char *)"File size error: %d\n", serr);
      }
    }
  }
  {
#line 313
  fseek(f, (long )(start + (int const   )pos___0), 0);
  }
  {
#line 315
  while (1) {
    while_continue___8: /* CIL Label */ ;
    {
#line 315
    tmp___11 = calloc((size_t )sizeof(struct xxm_track *), (size_t )(m___0->xxh)->trk);
#line 315
    m___0->xxt = (struct xxm_track **)tmp___11;
#line 315
    tmp___12 = calloc((size_t )sizeof(struct xxm_pattern *), (size_t )((m___0->xxh)->pat + 1));
#line 315
    m___0->xxp = (struct xxm_pattern **)tmp___12;
    }
#line 315
    goto while_break___8;
  }
  while_break___8: /* CIL Label */ ;
  }
  {
#line 319
  reportv(ctx___0, 0, (char *)"Stored patterns: %d ", (m___0->xxh)->pat);
#line 321
  i___3 = 0;
  }
  {
#line 321
  while (1) {
    while_continue___9: /* CIL Label */ ;
#line 321
    if (! (i___3 < (m___0->xxh)->pat)) {
#line 321
      goto while_break___9;
    }
    {
#line 322
    while (1) {
      while_continue___10: /* CIL Label */ ;
      {
#line 322
      tmp___13 = calloc((size_t )1, (size_t )(sizeof(struct xxm_pattern ) + sizeof(struct xxm_trackinfo ) * (unsigned long )((m___0->xxh)->chn - 1)));
#line 322
      *(m___0->xxp + i___3) = (struct xxm_pattern *)tmp___13;
      }
#line 322
      goto while_break___10;
    }
    while_break___10: /* CIL Label */ ;
    }
#line 323
    (*(m___0->xxp + i___3))->rows = 64;
    {
#line 324
    while (1) {
      while_continue___11: /* CIL Label */ ;
#line 324
      j___0 = 0;
      {
#line 324
      while (1) {
        while_continue___12: /* CIL Label */ ;
#line 324
        if (! (j___0 < (m___0->xxh)->chn)) {
#line 324
          goto while_break___12;
        }
        {
#line 324
        (*(m___0->xxp + i___3))->info[j___0].index = i___3 * (m___0->xxh)->chn + j___0;
#line 324
        tmp___14 = calloc((size_t )(sizeof(struct xxm_track ) + sizeof(struct xxm_event ) * (unsigned long )(*(m___0->xxp + i___3))->rows),
                          (size_t )1);
#line 324
        *(m___0->xxt + (i___3 * (m___0->xxh)->chn + j___0)) = (struct xxm_track *)tmp___14;
#line 324
        (*(m___0->xxt + (i___3 * (m___0->xxh)->chn + j___0)))->rows = (*(m___0->xxp + i___3))->rows;
#line 324
        j___0 ++;
        }
      }
      while_break___12: /* CIL Label */ ;
      }
#line 324
      goto while_break___11;
    }
    while_break___11: /* CIL Label */ ;
    }
#line 325
    j = 0;
    {
#line 325
    while (1) {
      while_continue___13: /* CIL Label */ ;
#line 325
      if (! (j < 64 * (m___0->xxh)->chn)) {
#line 325
        goto while_break___13;
      }
      {
#line 326
      event = & (*(m___0->xxt + (*(m___0->xxp + i___3))->info[j % (m___0->xxh)->chn].index))->event[j / (m___0->xxh)->chn];
#line 327
      fread((void */* __restrict  */)(mod_event), (size_t )1, (size_t )4, (FILE */* __restrict  */)f);
#line 329
      cvt_pt_event(event, mod_event);
#line 325
      j ++;
      }
    }
    while_break___13: /* CIL Label */ ;
    }
    {
#line 331
    reportv(ctx___0, 0, (char *)".");
#line 321
    i___3 ++;
    }
  }
  while_break___9: /* CIL Label */ ;
  }
  {
#line 333
  reportv(ctx___0, 0, (char *)"\n");
#line 335
  reportv(ctx___0, 1, (char *)"     Instrument name        Len  LBeg LEnd L Vol Fin\n");
#line 337
  i___3 = 0;
  }
  {
#line 337
  while (1) {
    while_continue___14: /* CIL Label */ ;
#line 337
    if (m___0->verbosity > 1) {
#line 337
      if (! (i___3 < (m___0->xxh)->ins)) {
#line 337
        goto while_break___14;
      }
    } else {
#line 337
      goto while_break___14;
    }
#line 338
    if ((m___0->xxih + i___3)->name[0]) {
#line 338
      goto _L;
    } else
#line 338
    if ((m___0->xxs + i___3)->len > 2) {
      _L: /* CIL Label */ 
#line 339
      if ((int )mh.ins[i___3].loop_size > 1) {
#line 339
        tmp___15 = 'L';
      } else {
#line 339
        tmp___15 = ' ';
      }
      {
#line 339
      report((char *)"[%2X] %-22.22s %04x %04x %04x %c V%02x %+d\n", i___3, (m___0->xxih + i___3)->name,
             (m___0->xxs + i___3)->len, (m___0->xxs + i___3)->lps, (m___0->xxs + i___3)->lpe,
             tmp___15, (*(m___0->xxi + i___3) + 0)->vol, (*(m___0->xxi + i___3) + 0)->fin >> 4);
      }
    }
#line 337
    i___3 ++;
  }
  while_break___14: /* CIL Label */ ;
  }
#line 346
  (m___0->xxh)->flg |= 2;
#line 349
  if (ust) {
#line 351
    (m___0->xxh)->bpm = (m___0->xxh)->rst;
#line 352
    (m___0->xxh)->rst = 0;
#line 355
    i___3 = 0;
    {
#line 355
    while (1) {
      while_continue___15: /* CIL Label */ ;
#line 355
      if (! (i___3 < (m___0->xxh)->ins)) {
#line 355
        goto while_break___15;
      }
#line 355
      i___3 ++;
    }
    while_break___15: /* CIL Label */ ;
    }
#line 360
    i___3 = 0;
    {
#line 360
    while (1) {
      while_continue___16: /* CIL Label */ ;
#line 360
      if (! (i___3 < (m___0->xxh)->pat)) {
#line 360
        goto while_break___16;
      }
#line 361
      j = 0;
      {
#line 361
      while (1) {
        while_continue___17: /* CIL Label */ ;
#line 361
        if (! (j < 64 * (m___0->xxh)->chn)) {
#line 361
          goto while_break___17;
        }
#line 362
        event = & (*(m___0->xxt + (*(m___0->xxp + i___3))->info[j % (m___0->xxh)->chn].index))->event[j / (m___0->xxh)->chn];
#line 363
        if ((int )event->fxt == 1) {
#line 364
          event->fxt = (uint8 )0;
        } else
#line 365
        if ((int )event->fxt == 2) {
#line 365
          if (((int )event->fxp & 240) == 0) {
#line 366
            event->fxt = (uint8 )1;
          } else {
#line 365
            goto _L___0;
          }
        } else
        _L___0: /* CIL Label */ 
#line 367
        if ((int )event->fxt == 2) {
#line 367
          if (((int )event->fxp & 15) == 0) {
#line 368
            event->fxp = (uint8 )((int )event->fxp >> 4);
          }
        }
#line 361
        j ++;
      }
      while_break___17: /* CIL Label */ ;
      }
#line 360
      i___3 ++;
    }
    while_break___16: /* CIL Label */ ;
    }
  } else
#line 372
  if ((m___0->xxh)->rst >= (m___0->xxh)->len) {
#line 373
    (m___0->xxh)->rst = 0;
  }
#line 376
  if (o___0->skipsmp) {
#line 377
    return (0);
  }
  {
#line 381
  reportv(ctx___0, 0, (char *)"Stored samples : %d ", (m___0->xxh)->smp);
#line 383
  i___3 = 0;
  }
  {
#line 383
  while (1) {
    while_continue___18: /* CIL Label */ ;
#line 383
    if (! (i___3 < (m___0->xxh)->smp)) {
#line 383
      goto while_break___18;
    }
#line 384
    if (! (m___0->xxs + i___3)->len) {
#line 385
      goto __Cont;
    }
    {
#line 386
    xmp_drv_loadpatch(ctx___0, f, (*(m___0->xxi + i___3) + 0)->sid, m___0->c4rate,
                      0, m___0->xxs + (*(m___0->xxi + i___3) + 0)->sid, (char *)((void *)0));
#line 388
    reportv(ctx___0, 0, (char *)".");
    }
    __Cont: /* CIL Label */ 
#line 383
    i___3 ++;
  }
  while_break___18: /* CIL Label */ ;
  }
  {
#line 390
  reportv(ctx___0, 0, (char *)"\n");
  }
#line 392
  return (0);
}
}
#line 17 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/flt_load.c"
static int flt_test(FILE *f , char *t , int const   start ) ;
#line 18
static int flt_load(struct xmp_context *ctx___0 , FILE *f , int const   start ) ;
#line 20 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/flt_load.c"
struct xmp_loader_info flt_loader  =    {(char *)"FLT", (char *)"Startrekker/Audio Sculpture", & flt_test, & flt_load,
    0, {(struct list_head *)0, (struct list_head *)0}};
#line 27 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/flt_load.c"
static int flt_test(FILE *f , char *t , int const   start ) 
{ 
  char buf___1[4] ;
  int tmp ;
  int tmp___0 ;
  void *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
  {
#line 31
  fseek(f, (long )(start + 1080), 0);
#line 32
  fread((void */* __restrict  */)(buf___1), (size_t )4, (size_t )1, (FILE */* __restrict  */)f);
#line 35
  tmp = memcmp((void const   *)(buf___1), (void const   *)"FLT", (size_t )3);
  }
#line 35
  if (tmp) {
    {
#line 35
    tmp___0 = memcmp((void const   *)(buf___1), (void const   *)"EXO", (size_t )3);
    }
#line 35
    if (tmp___0) {
#line 36
      return (-1);
    }
  }
#line 38
  if ((int )buf___1[3] != 52) {
#line 38
    if ((int )buf___1[3] != 56) {
#line 38
      if ((int )buf___1[3] != 77) {
#line 39
        return (-1);
      }
    }
  }
  {
#line 41
  fseek(f, (long )start, 0);
#line 42
  read_title(f, t, 28);
  }
#line 44
  return (0);
}
}
#line 51 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/flt_load.c"
static int8 am_waveform[3][32]  = { {        (int8 )0,        (int8 )25,        (int8 )49,        (int8 )71, 
            (int8 )90,        (int8 )106,        (int8 )117,        (int8 )125, 
            (int8 )127,        (int8 )125,        (int8 )117,        (int8 )106, 
            (int8 )90,        (int8 )71,        (int8 )49,        (int8 )25, 
            (int8 )0,        (int8 )-25,        (int8 )-49,        (int8 )-71, 
            (int8 )-90,        (int8 )-106,        (int8 )-117,        (int8 )-125, 
            (int8 )-127,        (int8 )-125,        (int8 )-117,        (int8 )-106, 
            (int8 )-90,        (int8 )-71,        (int8 )-49,        (int8 )-25}, 
   {        (int8 )-128,        (int8 )-120,        (int8 )-112,        (int8 )-104, 
            (int8 )-96,        (int8 )-88,        (int8 )-80,        (int8 )-72, 
            (int8 )-64,        (int8 )-56,        (int8 )-48,        (int8 )-40, 
            (int8 )-32,        (int8 )-24,        (int8 )-16,        (int8 )-8, 
            (int8 )0,        (int8 )8,        (int8 )16,        (int8 )24, 
            (int8 )32,        (int8 )40,        (int8 )48,        (int8 )56, 
            (int8 )64,        (int8 )72,        (int8 )80,        (int8 )88, 
            (int8 )96,        (int8 )104,        (int8 )112,        (int8 )120}, 
   {        (int8 )-128,        (int8 )-128,        (int8 )-128,        (int8 )-128, 
            (int8 )-128,        (int8 )-128,        (int8 )-128,        (int8 )-128, 
            (int8 )-128,        (int8 )-128,        (int8 )-128,        (int8 )-128, 
            (int8 )-128,        (int8 )-128,        (int8 )-128,        (int8 )-128, 
            (int8 )127,        (int8 )127,        (int8 )127,        (int8 )127, 
            (int8 )127,        (int8 )127,        (int8 )127,        (int8 )127, 
            (int8 )127,        (int8 )127,        (int8 )127,        (int8 )127, 
            (int8 )127,        (int8 )127,        (int8 )127,        (int8 )127}};
#line 71 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/flt_load.c"
static int8 am_noise[1024]  ;
#line 93 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/flt_load.c"
static int is_am_instrument(FILE *nt , int i___3 ) 
{ 
  char buf___1[2] ;
  int16 wf ;
  int tmp ;
  uint16 tmp___0 ;
  void *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
  {
#line 98
  fseek(nt, (long )(144 + i___3 * 120), 0);
#line 99
  fread((void */* __restrict  */)(buf___1), (size_t )1, (size_t )2, (FILE */* __restrict  */)nt);
#line 100
  tmp = memcmp((void const   *)(buf___1), (void const   *)"AM", (size_t )2);
  }
#line 100
  if (tmp) {
#line 101
    return (0);
  }
  {
#line 103
  fseek(nt, 24L, 1);
#line 104
  tmp___0 = read16b(nt);
#line 104
  wf = (int16 )tmp___0;
  }
#line 105
  if ((int )wf < 0) {
#line 106
    return (0);
  } else
#line 105
  if ((int )wf > 3) {
#line 106
    return (0);
  }
#line 108
  return (1);
}
}
#line 111 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/flt_load.c"
static void read_am_instrument(struct xmp_context *ctx___0 , FILE *nt , int i___3 ) 
{ 
  struct xmp_player_context *p ;
  struct xmp_mod_context *m___0 ;
  struct am_instrument am ;
  char *wave ;
  int a ;
  int b___1 ;
  uint16 tmp ;
  uint16 tmp___0 ;
  uint16 tmp___1 ;
  uint16 tmp___2 ;
  uint16 tmp___3 ;
  uint16 tmp___4 ;
  uint16 tmp___5 ;
  uint16 tmp___6 ;
  uint16 tmp___7 ;
  uint16 tmp___8 ;
  uint16 tmp___9 ;
  uint16 tmp___10 ;
  uint16 tmp___11 ;
  uint16 tmp___12 ;
  int j ;
  int tmp___13 ;
  void *tmp___14 ;
  void *tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  void *__cil_tmp30 ;
  char *__cil_tmp31 ;

  {
  {
#line 113
  p = & ctx___0->p;
#line 114
  m___0 = & p->m;
#line 119
  fseek(nt, (long )(((144 + i___3 * 120) + 2) + 4), 0);
#line 120
  tmp = read16b(nt);
#line 120
  am.l0 = (int16 )tmp;
#line 121
  tmp___0 = read16b(nt);
#line 121
  am.a1l = (int16 )tmp___0;
#line 122
  tmp___1 = read16b(nt);
#line 122
  am.a1s = (int16 )tmp___1;
#line 123
  tmp___2 = read16b(nt);
#line 123
  am.a2l = (int16 )tmp___2;
#line 124
  tmp___3 = read16b(nt);
#line 124
  am.a2s = (int16 )tmp___3;
#line 125
  tmp___4 = read16b(nt);
#line 125
  am.sl = (int16 )tmp___4;
#line 126
  tmp___5 = read16b(nt);
#line 126
  am.ds = (int16 )tmp___5;
#line 127
  tmp___6 = read16b(nt);
#line 127
  am.st = (int16 )tmp___6;
#line 128
  read16b(nt);
#line 129
  tmp___7 = read16b(nt);
#line 129
  am.rs = (int16 )tmp___7;
#line 130
  tmp___8 = read16b(nt);
#line 130
  am.wf = (int16 )tmp___8;
#line 131
  tmp___9 = read16b(nt);
#line 131
  am.p_fall = (int16 )(- ((int )((int16 )tmp___9)));
#line 132
  tmp___10 = read16b(nt);
#line 132
  am.v_amp = (int16 )tmp___10;
#line 133
  tmp___11 = read16b(nt);
#line 133
  am.v_spd = (int16 )tmp___11;
#line 134
  tmp___12 = read16b(nt);
#line 134
  am.fq = (int16 )tmp___12;
  }
#line 141
  if ((int )am.wf < 3) {
#line 142
    (m___0->xxs + i___3)->len = 32;
#line 143
    (m___0->xxs + i___3)->lps = 0;
#line 144
    (m___0->xxs + i___3)->lpe = 32;
#line 145
    wave = (char *)(& am_waveform[am.wf][0]);
  } else {
#line 149
    (m___0->xxs + i___3)->len = 1024;
#line 150
    (m___0->xxs + i___3)->lps = 0;
#line 151
    (m___0->xxs + i___3)->lpe = 1024;
#line 153
    j = 0;
    {
#line 153
    while (1) {
      while_continue: /* CIL Label */ ;
#line 153
      if (! (j < 1024)) {
#line 153
        goto while_break;
      }
      {
#line 154
      tmp___13 = rand();
#line 154
      am_noise[j] = (int8 )(tmp___13 % 256);
#line 153
      j ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 156
    wave = (char *)(& am_noise[0]);
  }
#line 159
  (m___0->xxs + i___3)->flg = 4;
#line 160
  (*(m___0->xxi + i___3) + 0)->vol = 64;
#line 161
  (m___0->xxih + i___3)->nsm = 1;
#line 162
  (*(m___0->xxi + i___3) + 0)->xpo = -12 * (int )am.fq;
#line 163
  (*(m___0->xxi + i___3) + 0)->vwf = 0;
#line 164
  (*(m___0->xxi + i___3) + 0)->vde = (int )am.v_amp;
#line 165
  (*(m___0->xxi + i___3) + 0)->vra = (int )am.v_spd;
#line 181
  if ((int )am.a1s == 0) {
#line 181
    am.a1s = (int16 )1;
  }
#line 182
  if ((int )am.a2s == 0) {
#line 182
    am.a2s = (int16 )1;
  }
#line 183
  if ((int )am.ds == 0) {
#line 183
    am.ds = (int16 )1;
  }
#line 184
  if ((int )am.rs == 0) {
#line 184
    am.rs = (int16 )1;
  }
  {
#line 186
  (m___0->xxih + i___3)->aei.npt = 6;
#line 187
  (m___0->xxih + i___3)->aei.flg = 1;
#line 188
  tmp___14 = calloc((size_t )4, (size_t )(m___0->xxih + i___3)->aei.npt);
#line 188
  *(m___0->xxae + i___3) = (uint16 *)tmp___14;
#line 190
  *(*(m___0->xxae + i___3) + 0) = (uint16 )0;
#line 191
  *(*(m___0->xxae + i___3) + 1) = (uint16 )((int )am.l0 / 4);
  }
#line 213
  if ((int )am.a1l > (int )am.l0) {
#line 214
    a = (int )am.a1l - (int )am.l0;
#line 215
    b___1 = 256 - (int )am.l0;
  } else {
#line 217
    a = (int )am.l0 - (int )am.a1l;
#line 218
    b___1 = (int )am.l0;
  }
#line 220
  if (b___1 == 0) {
#line 220
    b___1 = 1;
  }
#line 222
  *(*(m___0->xxae + i___3) + 2) = (uint16 )((int )*(*(m___0->xxae + i___3) + 0) + (256 * a) / ((int )am.a1s * b___1));
#line 224
  *(*(m___0->xxae + i___3) + 3) = (uint16 )((int )am.a1l / 4);
#line 226
  if ((int )am.a2l > (int )am.a1l) {
#line 227
    a = (int )am.a2l - (int )am.a1l;
#line 228
    b___1 = 256 - (int )am.a1l;
  } else {
#line 230
    a = (int )am.a1l - (int )am.a2l;
#line 231
    b___1 = (int )am.a1l;
  }
#line 233
  if (b___1 == 0) {
#line 233
    b___1 = 1;
  }
#line 235
  *(*(m___0->xxae + i___3) + 4) = (uint16 )((int )*(*(m___0->xxae + i___3) + 2) + (256 * a) / ((int )am.a2s * b___1));
#line 237
  *(*(m___0->xxae + i___3) + 5) = (uint16 )((int )am.a2l / 4);
#line 239
  if ((int )am.sl > (int )am.a2l) {
#line 240
    a = (int )am.sl - (int )am.a2l;
#line 241
    b___1 = 256 - (int )am.a2l;
  } else {
#line 243
    a = (int )am.a2l - (int )am.sl;
#line 244
    b___1 = (int )am.a2l;
  }
#line 246
  if (b___1 == 0) {
#line 246
    b___1 = 1;
  }
#line 248
  *(*(m___0->xxae + i___3) + 6) = (uint16 )((int )*(*(m___0->xxae + i___3) + 4) + (256 * a) / ((int )am.ds * b___1));
#line 250
  *(*(m___0->xxae + i___3) + 7) = (uint16 )((int )am.sl / 4);
#line 251
  *(*(m___0->xxae + i___3) + 8) = (uint16 )((int )*(*(m___0->xxae + i___3) + 6) + (int )am.st);
#line 252
  *(*(m___0->xxae + i___3) + 9) = (uint16 )((int )am.sl / 4);
#line 253
  *(*(m___0->xxae + i___3) + 10) = (uint16 )((int )*(*(m___0->xxae + i___3) + 8) + 256 / (int )am.rs);
#line 254
  *(*(m___0->xxae + i___3) + 11) = (uint16 )0;
#line 260
  if (am.p_fall) {
    {
#line 261
    (m___0->xxih + i___3)->fei.npt = 2;
#line 262
    (m___0->xxih + i___3)->fei.flg = 1;
#line 263
    tmp___15 = calloc((size_t )4, (size_t )(m___0->xxih + i___3)->fei.npt);
#line 263
    *(m___0->xxfe + i___3) = (uint16 *)tmp___15;
#line 265
    *(*(m___0->xxfe + i___3) + 0) = (uint16 )0;
#line 266
    *(*(m___0->xxfe + i___3) + 1) = (uint16 )0;
#line 268
    tmp___16 = abs((int )am.p_fall);
#line 268
    *(*(m___0->xxfe + i___3) + 2) = (uint16 )(1024 / tmp___16);
    }
#line 269
    if ((int )am.p_fall < 0) {
#line 269
      tmp___17 = -256;
    } else {
#line 269
      tmp___17 = 256;
    }
#line 269
    *(*(m___0->xxfe + i___3) + 3) = (uint16 )(10 * tmp___17);
  }
  {
#line 272
  xmp_drv_loadpatch(ctx___0, (FILE *)((void *)0), (*(m___0->xxi + i___3) + 0)->sid,
                    m___0->c4rate, 16, m___0->xxs + (*(m___0->xxi + i___3) + 0)->sid,
                    wave);
#line 275
  reportv(ctx___0, 0, (char *)"A");
  }
#line 276
  return;
}
}
#line 279 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/flt_load.c"
static int flt_load(struct xmp_context *ctx___0 , FILE *f , int const   start ) 
{ 
  struct xmp_player_context *p ;
  struct xmp_mod_context *m___0 ;
  struct xmp_options *o___0 ;
  int i___3 ;
  int j ;
  struct xxm_event *event ;
  struct mod_header mh ;
  uint8 mod_event[4] ;
  char *tracker ;
  char filename[1024] ;
  char buf___1[16] ;
  FILE *nt ;
  int am_synth ;
  uint8 **tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  uint8 tmp___3 ;
  uint8 tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  void *tmp___9 ;
  void *tmp___10 ;
  void *tmp___11 ;
  void *tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  void *tmp___16 ;
  void *tmp___17 ;
  void *tmp___18 ;
  int j___0 ;
  void *tmp___19 ;
  uint8 tmp___20 ;
  int tmp___21 ;
  void *__cil_tmp41 ;
  void *__cil_tmp42 ;
  void *__cil_tmp43 ;
  int __cil_tmp44 ;
  void *__cil_tmp45 ;
  void *__cil_tmp46 ;
  void *__cil_tmp47 ;
  void *__cil_tmp48 ;
  void *__cil_tmp49 ;
  void *__cil_tmp50 ;
  void *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;
  char *__cil_tmp66 ;
  char *__cil_tmp67 ;
  char *__cil_tmp68 ;
  char *__cil_tmp69 ;
  char *__cil_tmp70 ;
  char *__cil_tmp71 ;
  char *__cil_tmp72 ;
  char *__cil_tmp73 ;
  char *__cil_tmp74 ;
  char *__cil_tmp75 ;
  char *__cil_tmp76 ;
  char *__cil_tmp77 ;
  char *__cil_tmp78 ;
  char *__cil_tmp79 ;

  {
#line 281
  p = & ctx___0->p;
#line 282
  m___0 = & p->m;
#line 283
  o___0 = & ctx___0->o;
  {
#line 294
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 294
    fseek(f, (long )start, 0);
#line 294
    tmp = (uint8 **)((void *)0);
#line 294
    m___0->med_wav_table = tmp;
#line 294
    m___0->med_vol_table = tmp;
#line 294
    set_xxh_defaults(m___0->xxh);
    }
#line 294
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 297
  am_synth = 0;
#line 298
  snprintf((char */* __restrict  */)(filename), (size_t )1024, (char const   */* __restrict  */)"%s%s.NT",
           m___0->dirname, m___0->basename);
#line 299
  nt = fopen((char const   */* __restrict  */)(filename), (char const   */* __restrict  */)"rb");
  }
#line 299
  if ((unsigned long )nt == (unsigned long )((void *)0)) {
    {
#line 300
    snprintf((char */* __restrict  */)(filename), (size_t )1024, (char const   */* __restrict  */)"%s%s.nt",
             m___0->dirname, m___0->basename);
#line 301
    nt = fopen((char const   */* __restrict  */)(filename), (char const   */* __restrict  */)"rb");
    }
#line 301
    if ((unsigned long )nt == (unsigned long )((void *)0)) {
      {
#line 302
      snprintf((char */* __restrict  */)(filename), (size_t )1024, (char const   */* __restrict  */)"%s%s.AS",
               m___0->dirname, m___0->basename);
#line 303
      nt = fopen((char const   */* __restrict  */)(filename), (char const   */* __restrict  */)"rb");
      }
#line 303
      if ((unsigned long )nt == (unsigned long )((void *)0)) {
        {
#line 304
        snprintf((char */* __restrict  */)(filename), (size_t )1024, (char const   */* __restrict  */)"%s%s.as",
                 m___0->dirname, m___0->basename);
#line 305
        nt = fopen((char const   */* __restrict  */)(filename), (char const   */* __restrict  */)"rb");
        }
      }
    }
  }
#line 310
  tracker = (char *)"Startrekker";
#line 312
  if (nt) {
    {
#line 313
    fread((void */* __restrict  */)(buf___1), (size_t )1, (size_t )16, (FILE */* __restrict  */)nt);
#line 314
    tmp___2 = memcmp((void const   *)(buf___1), (void const   *)"ST1.2 ModuleINFO",
                     (size_t )16);
    }
#line 314
    if (tmp___2 == 0) {
#line 315
      am_synth = 1;
#line 316
      tracker = (char *)"Startrekker 1.2";
    } else {
      {
#line 317
      tmp___1 = memcmp((void const   *)(buf___1), (void const   *)"ST1.3 ModuleINFO",
                       (size_t )16);
      }
#line 317
      if (tmp___1 == 0) {
#line 318
        am_synth = 1;
#line 319
        tracker = (char *)"Startrekker 1.3";
      } else {
        {
#line 320
        tmp___0 = memcmp((void const   *)(buf___1), (void const   *)"AudioSculpture10",
                         (size_t )16);
        }
#line 320
        if (tmp___0 == 0) {
#line 321
          am_synth = 1;
#line 322
          tracker = (char *)"AudioSculpture 1.0";
        }
      }
    }
  }
  {
#line 326
  fread((void */* __restrict  */)(& mh.name), (size_t )20, (size_t )1, (FILE */* __restrict  */)f);
#line 327
  i___3 = 0;
  }
  {
#line 327
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 327
    if (! (i___3 < 31)) {
#line 327
      goto while_break___0;
    }
    {
#line 328
    fread((void */* __restrict  */)(& mh.ins[i___3].name), (size_t )22, (size_t )1,
          (FILE */* __restrict  */)f);
#line 329
    mh.ins[i___3].size = read16b(f);
#line 330
    tmp___3 = read8(f);
#line 330
    mh.ins[i___3].finetune = (int8 )tmp___3;
#line 331
    tmp___4 = read8(f);
#line 331
    mh.ins[i___3].volume = (int8 )tmp___4;
#line 332
    mh.ins[i___3].loop_start = read16b(f);
#line 333
    mh.ins[i___3].loop_size = read16b(f);
#line 327
    i___3 ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 335
  mh.len = read8(f);
#line 336
  mh.restart = read8(f);
#line 337
  fread((void */* __restrict  */)(& mh.order), (size_t )128, (size_t )1, (FILE */* __restrict  */)f);
#line 338
  fread((void */* __restrict  */)(& mh.magic), (size_t )4, (size_t )1, (FILE */* __restrict  */)f);
  }
#line 340
  if ((int )mh.magic[3] == 52) {
#line 341
    (m___0->xxh)->chn = 4;
  } else {
#line 343
    (m___0->xxh)->chn = 8;
  }
  {
#line 345
  (m___0->xxh)->ins = 31;
#line 346
  (m___0->xxh)->smp = (m___0->xxh)->ins;
#line 347
  (m___0->xxh)->len = (int )mh.len;
#line 348
  (m___0->xxh)->rst = (int )mh.restart;
#line 349
  memcpy((void */* __restrict  */)(m___0->xxo), (void const   */* __restrict  */)(mh.order),
         (size_t )128);
#line 351
  i___3 = 0;
  }
  {
#line 351
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 351
    if (! (i___3 < 128)) {
#line 351
      goto while_break___1;
    }
#line 352
    if ((m___0->xxh)->chn > 4) {
#line 353
      m___0->xxo[i___3] = (uint8 )((int )m___0->xxo[i___3] >> 1);
    }
#line 354
    if ((int )m___0->xxo[i___3] > (m___0->xxh)->pat) {
#line 355
      (m___0->xxh)->pat = (int )m___0->xxo[i___3];
    }
#line 351
    i___3 ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 358
  ((m___0->xxh)->pat) ++;
#line 360
  (m___0->xxh)->trk = (m___0->xxh)->chn * (m___0->xxh)->pat;
#line 362
  strncpy((char */* __restrict  */)(m___0->name), (char const   */* __restrict  */)((char *)(mh.name)),
          (size_t )20);
#line 363
  sprintf((char */* __restrict  */)(m___0->type), (char const   */* __restrict  */)"%4.4s (%s)",
          mh.magic, tracker);
  }
  {
#line 364
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 364
    if (m___0->verbosity) {
#line 364
      if (m___0->name[0]) {
        {
#line 364
        report((char *)"Module title   : %s\n", m___0->name);
        }
      }
#line 364
      if (m___0->type[0]) {
        {
#line 364
        report((char *)"Module type    : %s\n", m___0->type);
        }
      }
#line 364
      if (m___0->author[0]) {
        {
#line 364
        report((char *)"Author name    : %s\n", m___0->author);
        }
      }
#line 364
      if ((m___0->xxh)->len) {
        {
#line 364
        report((char *)"Module length  : %d patterns\n", (m___0->xxh)->len);
        }
      }
    }
#line 364
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 366
  while (1) {
    while_continue___3: /* CIL Label */ ;
    {
#line 366
    tmp___5 = calloc((size_t )sizeof(struct xxm_instrument_header ), (size_t )(m___0->xxh)->ins);
#line 366
    m___0->xxih = (struct xxm_instrument_header *)tmp___5;
#line 366
    tmp___6 = calloc((size_t )sizeof(struct xxm_instrument_map ), (size_t )(m___0->xxh)->ins);
#line 366
    m___0->xxim = (struct xxm_instrument_map *)tmp___6;
#line 366
    tmp___7 = calloc((size_t )sizeof(struct xxm_instrument *), (size_t )(m___0->xxh)->ins);
#line 366
    m___0->xxi = (struct xxm_instrument **)tmp___7;
    }
#line 366
    if ((m___0->xxh)->smp) {
      {
#line 366
      tmp___8 = calloc((size_t )sizeof(struct xxm_sample ), (size_t )(m___0->xxh)->smp);
#line 366
      m___0->xxs = (struct xxm_sample *)tmp___8;
      }
    }
    {
#line 366
    tmp___9 = calloc((size_t )sizeof(uint16 *), (size_t )(m___0->xxh)->ins);
#line 366
    m___0->xxae = (uint16 **)tmp___9;
#line 366
    tmp___10 = calloc((size_t )sizeof(uint16 *), (size_t )(m___0->xxh)->ins);
#line 366
    m___0->xxpe = (uint16 **)tmp___10;
#line 366
    tmp___11 = calloc((size_t )sizeof(uint16 *), (size_t )(m___0->xxh)->ins);
#line 366
    m___0->xxfe = (uint16 **)tmp___11;
    }
#line 366
    goto while_break___3;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 368
  reportv(ctx___0, 1, (char *)"     Instrument name        Len  LBeg LEnd L Vol Fin\n");
#line 370
  i___3 = 0;
  }
  {
#line 370
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 370
    if (! (i___3 < (m___0->xxh)->ins)) {
#line 370
      goto while_break___4;
    }
    {
#line 371
    tmp___12 = calloc((size_t )sizeof(struct xxm_instrument ), (size_t )1);
#line 371
    *(m___0->xxi + i___3) = (struct xxm_instrument *)tmp___12;
#line 372
    (m___0->xxs + i___3)->len = 2 * (int )mh.ins[i___3].size;
#line 373
    (m___0->xxs + i___3)->lps = 2 * (int )mh.ins[i___3].loop_start;
#line 374
    (m___0->xxs + i___3)->lpe = (m___0->xxs + i___3)->lps + 2 * (int )mh.ins[i___3].loop_size;
    }
#line 375
    if ((int )mh.ins[i___3].loop_size > 1) {
#line 375
      (m___0->xxs + i___3)->flg = 4;
    } else {
#line 375
      (m___0->xxs + i___3)->flg = 0;
    }
#line 376
    (*(m___0->xxi + i___3) + 0)->fin = (int )((int8 )((int )mh.ins[i___3].finetune << 4));
#line 377
    (*(m___0->xxi + i___3) + 0)->vol = (int )mh.ins[i___3].volume;
#line 378
    (*(m___0->xxi + i___3) + 0)->pan = 128;
#line 379
    (*(m___0->xxi + i___3) + 0)->sid = i___3;
#line 380
    (m___0->xxih + i___3)->nsm = ! (! (m___0->xxs + i___3)->len);
#line 381
    (m___0->xxih + i___3)->rls = 4095;
#line 383
    if ((m___0->xxs + i___3)->flg & 4) {
#line 384
      if ((m___0->xxs + i___3)->lps == 0) {
#line 384
        if ((m___0->xxs + i___3)->len > (m___0->xxs + i___3)->lpe) {
#line 385
          (m___0->xxs + i___3)->flg |= 128;
        }
      }
    }
    {
#line 388
    copy_adjust((m___0->xxih + i___3)->name, mh.ins[i___3].name, 22);
    }
#line 390
    if (m___0->verbosity > 1) {
#line 391
      if (am_synth) {
        {
#line 391
        tmp___15 = is_am_instrument(nt, i___3);
        }
#line 391
        if (tmp___15) {
          {
#line 392
          report((char *)"[%2X] %-22.22s SYNT ---- ----   V40 %+d\n", i___3, (m___0->xxih + i___3)->name,
                 (*(m___0->xxi + i___3) + 0)->fin >> 4);
          }
        } else {
#line 391
          goto _L___0;
        }
      } else
      _L___0: /* CIL Label */ 
#line 394
      if ((m___0->xxih + i___3)->name[0]) {
#line 394
        goto _L;
      } else
#line 394
      if ((m___0->xxs + i___3)->len > 2) {
        _L: /* CIL Label */ 
#line 395
        if ((m___0->xxs + i___3)->flg & 128) {
#line 395
          tmp___13 = '!';
        } else {
#line 395
          tmp___13 = ' ';
        }
#line 395
        if ((int )mh.ins[i___3].loop_size > 1) {
#line 395
          tmp___14 = 'L';
        } else {
#line 395
          tmp___14 = ' ';
        }
        {
#line 395
        report((char *)"[%2X] %-22.22s %04x %04x %04x %c V%02x %+d %c\n", i___3, (m___0->xxih + i___3)->name,
               (m___0->xxs + i___3)->len, (m___0->xxs + i___3)->lps, (m___0->xxs + i___3)->lpe,
               tmp___14, (*(m___0->xxi + i___3) + 0)->vol, (*(m___0->xxi + i___3) + 0)->fin >> 4,
               tmp___13);
        }
      }
    }
#line 370
    i___3 ++;
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 404
  while (1) {
    while_continue___5: /* CIL Label */ ;
    {
#line 404
    tmp___16 = calloc((size_t )sizeof(struct xxm_track *), (size_t )(m___0->xxh)->trk);
#line 404
    m___0->xxt = (struct xxm_track **)tmp___16;
#line 404
    tmp___17 = calloc((size_t )sizeof(struct xxm_pattern *), (size_t )((m___0->xxh)->pat + 1));
#line 404
    m___0->xxp = (struct xxm_pattern **)tmp___17;
    }
#line 404
    goto while_break___5;
  }
  while_break___5: /* CIL Label */ ;
  }
  {
#line 407
  reportv(ctx___0, 0, (char *)"Stored patterns: %d ", (m___0->xxh)->pat);
#line 420
  i___3 = 0;
  }
  {
#line 420
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 420
    if (! (i___3 < (m___0->xxh)->pat)) {
#line 420
      goto while_break___6;
    }
    {
#line 421
    while (1) {
      while_continue___7: /* CIL Label */ ;
      {
#line 421
      tmp___18 = calloc((size_t )1, (size_t )(sizeof(struct xxm_pattern ) + sizeof(struct xxm_trackinfo ) * (unsigned long )((m___0->xxh)->chn - 1)));
#line 421
      *(m___0->xxp + i___3) = (struct xxm_pattern *)tmp___18;
      }
#line 421
      goto while_break___7;
    }
    while_break___7: /* CIL Label */ ;
    }
#line 422
    (*(m___0->xxp + i___3))->rows = 64;
    {
#line 423
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 423
      j___0 = 0;
      {
#line 423
      while (1) {
        while_continue___9: /* CIL Label */ ;
#line 423
        if (! (j___0 < (m___0->xxh)->chn)) {
#line 423
          goto while_break___9;
        }
        {
#line 423
        (*(m___0->xxp + i___3))->info[j___0].index = i___3 * (m___0->xxh)->chn + j___0;
#line 423
        tmp___19 = calloc((size_t )(sizeof(struct xxm_track ) + sizeof(struct xxm_event ) * (unsigned long )(*(m___0->xxp + i___3))->rows),
                          (size_t )1);
#line 423
        *(m___0->xxt + (i___3 * (m___0->xxh)->chn + j___0)) = (struct xxm_track *)tmp___19;
#line 423
        (*(m___0->xxt + (i___3 * (m___0->xxh)->chn + j___0)))->rows = (*(m___0->xxp + i___3))->rows;
#line 423
        j___0 ++;
        }
      }
      while_break___9: /* CIL Label */ ;
      }
#line 423
      goto while_break___8;
    }
    while_break___8: /* CIL Label */ ;
    }
#line 424
    j = 0;
    {
#line 424
    while (1) {
      while_continue___10: /* CIL Label */ ;
#line 424
      if (! (j < 256)) {
#line 424
        goto while_break___10;
      }
      {
#line 425
      event = & (*(m___0->xxt + (*(m___0->xxp + i___3))->info[j % 4].index))->event[j / 4];
#line 426
      fread((void */* __restrict  */)(mod_event), (size_t )1, (size_t )4, (FILE */* __restrict  */)f);
#line 427
      cvt_pt_event(event, mod_event);
#line 424
      j ++;
      }
    }
    while_break___10: /* CIL Label */ ;
    }
#line 429
    if ((m___0->xxh)->chn > 4) {
#line 430
      j = 0;
      {
#line 430
      while (1) {
        while_continue___11: /* CIL Label */ ;
#line 430
        if (! (j < 256)) {
#line 430
          goto while_break___11;
        }
        {
#line 431
        event = & (*(m___0->xxt + (*(m___0->xxp + i___3))->info[j % 4 + 4].index))->event[j / 4];
#line 432
        fread((void */* __restrict  */)(mod_event), (size_t )1, (size_t )4, (FILE */* __restrict  */)f);
#line 433
        cvt_pt_event(event, mod_event);
        }
#line 436
        if ((int )event->fxt == 14) {
#line 437
          tmp___20 = (uint8 )0;
#line 437
          event->fxp = tmp___20;
#line 437
          event->fxt = tmp___20;
        }
#line 430
        j ++;
      }
      while_break___11: /* CIL Label */ ;
      }
    }
    {
#line 440
    reportv(ctx___0, 0, (char *)".");
#line 420
    i___3 ++;
    }
  }
  while_break___6: /* CIL Label */ ;
  }
#line 447
  if (o___0->skipsmp) {
#line 448
    return (0);
  }
  {
#line 452
  reportv(ctx___0, 0, (char *)"\nStored samples : %d ", (m___0->xxh)->smp);
#line 453
  i___3 = 0;
  }
  {
#line 453
  while (1) {
    while_continue___12: /* CIL Label */ ;
#line 453
    if (! (i___3 < (m___0->xxh)->smp)) {
#line 453
      goto while_break___12;
    }
#line 454
    if ((m___0->xxs + i___3)->len == 0) {
#line 455
      if (am_synth) {
        {
#line 455
        tmp___21 = is_am_instrument(nt, i___3);
        }
#line 455
        if (tmp___21) {
          {
#line 456
          read_am_instrument(ctx___0, nt, i___3);
          }
        }
      }
#line 458
      goto __Cont;
    }
    {
#line 460
    xmp_drv_loadpatch(ctx___0, f, (*(m___0->xxi + i___3) + 0)->sid, m___0->c4rate,
                      0, m___0->xxs + (*(m___0->xxi + i___3) + 0)->sid, (char *)((void *)0));
#line 462
    reportv(ctx___0, 0, (char *)".");
    }
    __Cont: /* CIL Label */ 
#line 453
    i___3 ++;
  }
  while_break___12: /* CIL Label */ ;
  }
  {
#line 464
  reportv(ctx___0, 0, (char *)"\n");
  }
#line 466
  if (nt) {
    {
#line 467
    fclose(nt);
    }
  }
#line 469
  return (0);
}
}
#line 29 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/sfx_load.c"
static int sfx_test(FILE *f , char *t , int const   start ) ;
#line 30
static int sfx_load(struct xmp_context *ctx___0 , FILE *f , int const   start ) ;
#line 32 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/sfx_load.c"
struct xmp_loader_info sfx_loader  =    {(char *)"SFX", (char *)"SoundFX", & sfx_test, & sfx_load, 0, {(struct list_head *)0,
                                                                  (struct list_head *)0}};
#line 39 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/sfx_load.c"
static int sfx_test(FILE *f , char *t , int const   start ) 
{ 
  uint32 a ;
  uint32 b___1 ;

  {
  {
#line 43
  fseek(f, 60L, 1);
#line 44
  a = read32b(f);
#line 45
  fseek(f, 60L, 1);
#line 46
  b___1 = read32b(f);
  }
#line 48
  if (a != ((((83U << 24) | (79U << 16)) | (78U << 8)) | 71U)) {
#line 48
    if (b___1 != ((((83U << 24) | (79U << 16)) | (78U << 8)) | 71U)) {
#line 49
      return (-1);
    }
  }
  {
#line 51
  read_title(f, t, 0);
  }
#line 53
  return (0);
}
}
#line 79 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/sfx_load.c"
static int sfx_13_20_load(struct xmp_context *ctx___0 , FILE *f , int const   nins ,
                          int const   start ) 
{ 
  struct xmp_player_context *p ;
  struct xmp_mod_context *m___0 ;
  int i___3 ;
  int j ;
  struct xxm_event *event ;
  struct sfx_header sfx ;
  struct sfx_header2 sfx2 ;
  uint8 ev[4] ;
  int ins_size[31] ;
  struct sfx_ins ins[31] ;
  uint8 **tmp ;
  uint32 tmp___0 ;
  char const   *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  void *tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  size_t tmp___13 ;
  void *tmp___14 ;
  void *tmp___15 ;
  void *tmp___16 ;
  int j___0 ;
  void *tmp___17 ;
  int tmp___18 ;
  uint8 tmp___19 ;
  void *__cil_tmp37 ;
  void *__cil_tmp38 ;
  void *__cil_tmp39 ;
  void *__cil_tmp40 ;
  void *__cil_tmp41 ;
  void *__cil_tmp42 ;
  void *__cil_tmp43 ;
  int __cil_tmp44 ;
  void *__cil_tmp45 ;
  void *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;

  {
#line 81
  p = & ctx___0->p;
#line 82
  m___0 = & p->m;
  {
#line 91
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 91
    fseek(f, (long )start, 0);
#line 91
    tmp = (uint8 **)((void *)0);
#line 91
    m___0->med_wav_table = tmp;
#line 91
    m___0->med_vol_table = tmp;
#line 91
    set_xxh_defaults(m___0->xxh);
    }
#line 91
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 93
  i___3 = 0;
  {
#line 93
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 93
    if (! (i___3 < (int )nins)) {
#line 93
      goto while_break___0;
    }
    {
#line 94
    tmp___0 = read32b(f);
#line 94
    ins_size[i___3] = (int )tmp___0;
#line 93
    i___3 ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 96
  sfx.magic = read32b(f);
#line 97
  sfx.delay = read16b(f);
#line 98
  fread((void */* __restrict  */)(& sfx.unknown), (size_t )14, (size_t )1, (FILE */* __restrict  */)f);
  }
#line 100
  if (sfx.magic != ((((83U << 24) | (79U << 16)) | (78U << 8)) | 71U)) {
#line 101
    return (-1);
  }
#line 103
  (m___0->xxh)->ins = (int )nins;
#line 104
  (m___0->xxh)->smp = (m___0->xxh)->ins;
#line 105
  (m___0->xxh)->bpm = 1776930 / (int )sfx.delay;
#line 107
  i___3 = 0;
  {
#line 107
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 107
    if (! (i___3 < (m___0->xxh)->ins)) {
#line 107
      goto while_break___1;
    }
    {
#line 108
    fread((void */* __restrict  */)(& ins[i___3].name), (size_t )22, (size_t )1, (FILE */* __restrict  */)f);
#line 109
    ins[i___3].len = read16b(f);
#line 110
    ins[i___3].finetune = read8(f);
#line 111
    ins[i___3].volume = read8(f);
#line 112
    ins[i___3].loop_start = read16b(f);
#line 113
    ins[i___3].loop_length = read16b(f);
#line 107
    i___3 ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 116
  sfx2.len = read8(f);
#line 117
  sfx2.restart = read8(f);
#line 118
  fread((void */* __restrict  */)(& sfx2.order), (size_t )128, (size_t )1, (FILE */* __restrict  */)f);
#line 120
  (m___0->xxh)->len = (int )sfx2.len;
  }
#line 121
  if ((m___0->xxh)->len > 127) {
#line 122
    return (-1);
  }
  {
#line 124
  memcpy((void */* __restrict  */)(m___0->xxo), (void const   */* __restrict  */)(sfx2.order),
         (size_t )(m___0->xxh)->len);
#line 125
  i___3 = 0;
#line 125
  (m___0->xxh)->pat = i___3;
  }
  {
#line 125
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 125
    if (! (i___3 < (m___0->xxh)->len)) {
#line 125
      goto while_break___2;
    }
#line 126
    if ((int )m___0->xxo[i___3] > (m___0->xxh)->pat) {
#line 127
      (m___0->xxh)->pat = (int )m___0->xxo[i___3];
    }
#line 125
    i___3 ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 128
  ((m___0->xxh)->pat) ++;
#line 130
  (m___0->xxh)->trk = (m___0->xxh)->chn * (m___0->xxh)->pat;
#line 132
  if ((m___0->xxh)->ins == 15) {
#line 132
    tmp___1 = "SoundFX 1.3";
  } else {
#line 132
    tmp___1 = "SoundFX 2.0";
  }
  {
#line 132
  strcpy((char */* __restrict  */)(m___0->type), (char const   */* __restrict  */)tmp___1);
  }
  {
#line 134
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 134
    if (m___0->verbosity) {
#line 134
      if (m___0->name[0]) {
        {
#line 134
        report((char *)"Module title   : %s\n", m___0->name);
        }
      }
#line 134
      if (m___0->type[0]) {
        {
#line 134
        report((char *)"Module type    : %s\n", m___0->type);
        }
      }
#line 134
      if (m___0->author[0]) {
        {
#line 134
        report((char *)"Author name    : %s\n", m___0->author);
        }
      }
#line 134
      if ((m___0->xxh)->len) {
        {
#line 134
        report((char *)"Module length  : %d patterns\n", (m___0->xxh)->len);
        }
      }
    }
#line 134
    goto while_break___3;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 136
  while (1) {
    while_continue___4: /* CIL Label */ ;
    {
#line 136
    tmp___2 = calloc((size_t )sizeof(struct xxm_instrument_header ), (size_t )(m___0->xxh)->ins);
#line 136
    m___0->xxih = (struct xxm_instrument_header *)tmp___2;
#line 136
    tmp___3 = calloc((size_t )sizeof(struct xxm_instrument_map ), (size_t )(m___0->xxh)->ins);
#line 136
    m___0->xxim = (struct xxm_instrument_map *)tmp___3;
#line 136
    tmp___4 = calloc((size_t )sizeof(struct xxm_instrument *), (size_t )(m___0->xxh)->ins);
#line 136
    m___0->xxi = (struct xxm_instrument **)tmp___4;
    }
#line 136
    if ((m___0->xxh)->smp) {
      {
#line 136
      tmp___5 = calloc((size_t )sizeof(struct xxm_sample ), (size_t )(m___0->xxh)->smp);
#line 136
      m___0->xxs = (struct xxm_sample *)tmp___5;
      }
    }
    {
#line 136
    tmp___6 = calloc((size_t )sizeof(uint16 *), (size_t )(m___0->xxh)->ins);
#line 136
    m___0->xxae = (uint16 **)tmp___6;
#line 136
    tmp___7 = calloc((size_t )sizeof(uint16 *), (size_t )(m___0->xxh)->ins);
#line 136
    m___0->xxpe = (uint16 **)tmp___7;
#line 136
    tmp___8 = calloc((size_t )sizeof(uint16 *), (size_t )(m___0->xxh)->ins);
#line 136
    m___0->xxfe = (uint16 **)tmp___8;
    }
#line 136
    goto while_break___4;
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 138
  reportv(ctx___0, 1, (char *)"     Instrument name        Len  LBeg LEnd L Vol Fin\n");
#line 140
  i___3 = 0;
  }
  {
#line 140
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 140
    if (! (i___3 < (m___0->xxh)->ins)) {
#line 140
      goto while_break___5;
    }
    {
#line 141
    tmp___9 = calloc((size_t )sizeof(struct xxm_instrument ), (size_t )1);
#line 141
    *(m___0->xxi + i___3) = (struct xxm_instrument *)tmp___9;
#line 142
    tmp___10 = ins_size[i___3];
#line 142
    (m___0->xxs + i___3)->len = tmp___10;
    }
#line 142
    if (tmp___10) {
#line 142
      tmp___11 = 1;
    } else {
#line 142
      tmp___11 = 0;
    }
#line 142
    (m___0->xxih + i___3)->nsm = tmp___11;
#line 143
    (m___0->xxs + i___3)->lps = (int )ins[i___3].loop_start;
#line 144
    (m___0->xxs + i___3)->lpe = (m___0->xxs + i___3)->lps + 2 * (int )ins[i___3].loop_length;
#line 145
    if ((int )ins[i___3].loop_length > 1) {
#line 145
      (m___0->xxs + i___3)->flg = 4;
    } else {
#line 145
      (m___0->xxs + i___3)->flg = 0;
    }
    {
#line 146
    (*(m___0->xxi + i___3) + 0)->vol = (int )ins[i___3].volume;
#line 147
    (*(m___0->xxi + i___3) + 0)->fin = (int )((int8 )((int )ins[i___3].finetune << 4));
#line 148
    (*(m___0->xxi + i___3) + 0)->pan = 128;
#line 149
    (*(m___0->xxi + i___3) + 0)->sid = i___3;
#line 151
    copy_adjust((m___0->xxih + i___3)->name, ins[i___3].name, 22);
    }
#line 153
    if (m___0->verbosity > 1) {
      {
#line 153
      tmp___13 = strlen((char const   *)((char *)((m___0->xxih + i___3)->name)));
      }
#line 153
      if (tmp___13) {
#line 153
        goto _L;
      } else
#line 153
      if ((m___0->xxs + i___3)->len > 2) {
        _L: /* CIL Label */ 
#line 154
        if ((m___0->xxs + i___3)->flg & 4) {
#line 154
          tmp___12 = 'L';
        } else {
#line 154
          tmp___12 = ' ';
        }
        {
#line 154
        report((char *)"[%2X] %-22.22s %04x %04x %04x %c  %02x %+d\n", i___3, (m___0->xxih + i___3)->name,
               (m___0->xxs + i___3)->len, (m___0->xxs + i___3)->lps, (m___0->xxs + i___3)->lpe,
               tmp___12, (*(m___0->xxi + i___3) + 0)->vol, (*(m___0->xxi + i___3) + 0)->fin >> 4);
        }
      }
    }
#line 140
    i___3 ++;
  }
  while_break___5: /* CIL Label */ ;
  }
  {
#line 160
  while (1) {
    while_continue___6: /* CIL Label */ ;
    {
#line 160
    tmp___14 = calloc((size_t )sizeof(struct xxm_track *), (size_t )(m___0->xxh)->trk);
#line 160
    m___0->xxt = (struct xxm_track **)tmp___14;
#line 160
    tmp___15 = calloc((size_t )sizeof(struct xxm_pattern *), (size_t )((m___0->xxh)->pat + 1));
#line 160
    m___0->xxp = (struct xxm_pattern **)tmp___15;
    }
#line 160
    goto while_break___6;
  }
  while_break___6: /* CIL Label */ ;
  }
  {
#line 162
  reportv(ctx___0, 0, (char *)"Stored patterns: %d ", (m___0->xxh)->pat);
#line 164
  i___3 = 0;
  }
  {
#line 164
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 164
    if (! (i___3 < (m___0->xxh)->pat)) {
#line 164
      goto while_break___7;
    }
    {
#line 165
    while (1) {
      while_continue___8: /* CIL Label */ ;
      {
#line 165
      tmp___16 = calloc((size_t )1, (size_t )(sizeof(struct xxm_pattern ) + sizeof(struct xxm_trackinfo ) * (unsigned long )((m___0->xxh)->chn - 1)));
#line 165
      *(m___0->xxp + i___3) = (struct xxm_pattern *)tmp___16;
      }
#line 165
      goto while_break___8;
    }
    while_break___8: /* CIL Label */ ;
    }
#line 166
    (*(m___0->xxp + i___3))->rows = 64;
    {
#line 167
    while (1) {
      while_continue___9: /* CIL Label */ ;
#line 167
      j___0 = 0;
      {
#line 167
      while (1) {
        while_continue___10: /* CIL Label */ ;
#line 167
        if (! (j___0 < (m___0->xxh)->chn)) {
#line 167
          goto while_break___10;
        }
        {
#line 167
        (*(m___0->xxp + i___3))->info[j___0].index = i___3 * (m___0->xxh)->chn + j___0;
#line 167
        tmp___17 = calloc((size_t )(sizeof(struct xxm_track ) + sizeof(struct xxm_event ) * (unsigned long )(*(m___0->xxp + i___3))->rows),
                          (size_t )1);
#line 167
        *(m___0->xxt + (i___3 * (m___0->xxh)->chn + j___0)) = (struct xxm_track *)tmp___17;
#line 167
        (*(m___0->xxt + (i___3 * (m___0->xxh)->chn + j___0)))->rows = (*(m___0->xxp + i___3))->rows;
#line 167
        j___0 ++;
        }
      }
      while_break___10: /* CIL Label */ ;
      }
#line 167
      goto while_break___9;
    }
    while_break___9: /* CIL Label */ ;
    }
#line 169
    j = 0;
    {
#line 169
    while (1) {
      while_continue___11: /* CIL Label */ ;
#line 169
      if (! (j < 64 * (m___0->xxh)->chn)) {
#line 169
        goto while_break___11;
      }
      {
#line 170
      event = & (*(m___0->xxt + (*(m___0->xxp + i___3))->info[j % (m___0->xxh)->chn].index))->event[j / (m___0->xxh)->chn];
#line 171
      fread((void */* __restrict  */)(ev), (size_t )1, (size_t )4, (FILE */* __restrict  */)f);
#line 173
      tmp___18 = period_to_note((((int )ev[0] & 15) << 8) | (int )ev[1]);
#line 173
      event->note = (uint8 )tmp___18;
#line 174
      event->ins = (uint8 )(((((int )ev[0] & 240) >> 4) << 4) | (((int )ev[2] & 240) >> 4));
#line 175
      event->fxp = ev[3];
      }
      {
#line 178
      if (((int )ev[2] & 15) == 1) {
#line 178
        goto case_1;
      }
#line 181
      if (((int )ev[2] & 15) == 2) {
#line 181
        goto case_2;
      }
#line 190
      if (((int )ev[2] & 15) == 5) {
#line 190
        goto case_5;
      }
#line 193
      if (((int )ev[2] & 15) == 6) {
#line 193
        goto case_6;
      }
#line 201
      goto switch_default;
      case_1: /* CIL Label */ 
#line 179
      event->fxt = (uint8 )0;
#line 180
      goto switch_break;
      case_2: /* CIL Label */ 
#line 182
      if ((int )event->fxp >> 4) {
#line 183
        event->fxt = (uint8 )2;
#line 184
        event->fxp = (uint8 )((int )event->fxp >> 4);
      } else
#line 185
      if ((int )event->fxp & 15) {
#line 186
        event->fxt = (uint8 )1;
#line 187
        event->fxp = (uint8 )((int )event->fxp & 15);
      }
#line 189
      goto switch_break;
      case_5: /* CIL Label */ 
#line 191
      event->fxt = (uint8 )161;
#line 192
      goto switch_break;
      case_6: /* CIL Label */ 
#line 194
      event->fxt = (uint8 )12;
#line 195
      event->fxp = (uint8 )(64 - (int )ev[3]);
#line 196
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 202
      tmp___19 = (uint8 )0;
#line 202
      event->fxp = tmp___19;
#line 202
      event->fxt = tmp___19;
#line 203
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
#line 169
      j ++;
    }
    while_break___11: /* CIL Label */ ;
    }
    {
#line 206
    reportv(ctx___0, 0, (char *)".");
#line 164
    i___3 ++;
    }
  }
  while_break___7: /* CIL Label */ ;
  }
  {
#line 209
  (m___0->xxh)->flg |= 2;
#line 213
  reportv(ctx___0, 0, (char *)"\nStored samples : %d ", (m___0->xxh)->smp);
#line 215
  i___3 = 0;
  }
  {
#line 215
  while (1) {
    while_continue___12: /* CIL Label */ ;
#line 215
    if (! (i___3 < (m___0->xxh)->ins)) {
#line 215
      goto while_break___12;
    }
#line 216
    if ((m___0->xxs + i___3)->len <= 2) {
#line 217
      goto __Cont;
    }
    {
#line 218
    xmp_drv_loadpatch(ctx___0, f, i___3, m___0->c4rate, 0, m___0->xxs + i___3, (char *)((void *)0));
    }
#line 219
    if (m___0->verbosity > 0) {
      {
#line 220
      report((char *)".");
      }
    }
    __Cont: /* CIL Label */ 
#line 215
    i___3 ++;
  }
  while_break___12: /* CIL Label */ ;
  }
  {
#line 222
  reportv(ctx___0, 0, (char *)"\n");
  }
#line 224
  return (0);
}
}
#line 228 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/sfx_load.c"
static int sfx_load(struct xmp_context *ctx___0 , FILE *f , int const   start ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
#line 230
  tmp___0 = sfx_13_20_load(ctx___0, f, (int const   )15, start);
  }
#line 230
  if (tmp___0 < 0) {
    {
#line 231
    tmp = sfx_13_20_load(ctx___0, f, (int const   )31, start);
    }
#line 231
    return (tmp);
  }
#line 232
  return (0);
}
}
#line 21 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/pt3_load.c"
static int pt3_test(FILE *f , char *t , int const   start ) ;
#line 22
static int pt3_load(struct xmp_context *ctx___0 , FILE *f , int const   start ) ;
#line 23
static int ptdt_load(struct xmp_context *ctx___0 , FILE *f , int const   start ) ;
#line 25 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/pt3_load.c"
struct xmp_loader_info pt3_loader  =    {(char *)"PT3", (char *)"Protracker 3", & pt3_test, & pt3_load, 0, {(struct list_head *)0,
                                                                       (struct list_head *)0}};
#line 32 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/pt3_load.c"
static int pt3_test(FILE *f , char *t , int const   start ) 
{ 
  uint32 form ;
  uint32 id ;

  {
  {
#line 36
  form = read32b(f);
#line 37
  read32b(f);
#line 38
  id = read32b(f);
  }
#line 40
  if (form != ((((70U << 24) | (79U << 16)) | (82U << 8)) | 77U)) {
#line 41
    return (-1);
  } else
#line 40
  if (id != ((((77U << 24) | (79U << 16)) | (68U << 8)) | 76U)) {
#line 41
    return (-1);
  }
  {
#line 43
  read_title(f, t, 0);
  }
#line 45
  return (0);
}
}
#line 58 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/pt3_load.c"
static void get_info___0(struct xmp_context *ctx___0 , int size___0 , FILE *f ) 
{ 
  struct xmp_player_context *p ;
  struct xmp_mod_context *m___0 ;
  int flags ;
  int day___1 ;
  int month___1 ;
  int year___1 ;
  int hour___0 ;
  int min ;
  int sec ;
  int dhour ;
  int dmin ;
  int dsec ;
  uint16 tmp ;
  uint16 tmp___0 ;
  uint16 tmp___1 ;
  uint16 tmp___2 ;
  uint16 tmp___3 ;
  uint16 tmp___4 ;
  uint16 tmp___5 ;
  uint16 tmp___6 ;
  uint16 tmp___7 ;
  uint16 tmp___8 ;
  uint16 tmp___9 ;
  uint16 tmp___10 ;
  uint16 tmp___11 ;
  uint16 tmp___12 ;
  uint16 tmp___13 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;

  {
  {
#line 60
  p = & ctx___0->p;
#line 61
  m___0 = & p->m;
#line 66
  fread((void */* __restrict  */)(m___0->name), (size_t )1, (size_t )32, (FILE */* __restrict  */)f);
#line 67
  tmp = read16b(f);
#line 67
  (m___0->xxh)->ins = (int )tmp;
#line 68
  tmp___0 = read16b(f);
#line 68
  (m___0->xxh)->len = (int )tmp___0;
#line 69
  tmp___1 = read16b(f);
#line 69
  (m___0->xxh)->pat = (int )tmp___1;
#line 70
  tmp___2 = read16b(f);
#line 70
  (m___0->xxh)->gvl = (int )tmp___2;
#line 71
  tmp___3 = read16b(f);
#line 71
  (m___0->xxh)->bpm = (int )tmp___3;
#line 72
  tmp___4 = read16b(f);
#line 72
  flags = (int )tmp___4;
#line 73
  tmp___5 = read16b(f);
#line 73
  day___1 = (int )tmp___5;
#line 74
  tmp___6 = read16b(f);
#line 74
  month___1 = (int )tmp___6;
#line 75
  tmp___7 = read16b(f);
#line 75
  year___1 = (int )tmp___7;
#line 76
  tmp___8 = read16b(f);
#line 76
  hour___0 = (int )tmp___8;
#line 77
  tmp___9 = read16b(f);
#line 77
  min = (int )tmp___9;
#line 78
  tmp___10 = read16b(f);
#line 78
  sec = (int )tmp___10;
#line 79
  tmp___11 = read16b(f);
#line 79
  dhour = (int )tmp___11;
#line 80
  tmp___12 = read16b(f);
#line 80
  dmin = (int )tmp___12;
#line 81
  tmp___13 = read16b(f);
#line 81
  dsec = (int )tmp___13;
  }
  {
#line 83
  while (1) {
    while_continue: /* CIL Label */ ;
#line 83
    if (m___0->verbosity) {
#line 83
      if (m___0->name[0]) {
        {
#line 83
        report((char *)"Module title   : %s\n", m___0->name);
        }
      }
#line 83
      if (m___0->type[0]) {
        {
#line 83
        report((char *)"Module type    : %s\n", m___0->type);
        }
      }
#line 83
      if (m___0->author[0]) {
        {
#line 83
        report((char *)"Author name    : %s\n", m___0->author);
        }
      }
#line 83
      if ((m___0->xxh)->len) {
        {
#line 83
        report((char *)"Module length  : %d patterns\n", (m___0->xxh)->len);
        }
      }
    }
#line 83
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 85
  reportv(ctx___0, 0, (char *)"Creation date  : %02d/%02d/%02d %02d:%02d:%02d\n",
          day___1, month___1, year___1, hour___0, min, sec);
#line 87
  reportv(ctx___0, 0, (char *)"Playing time   : %02d:%02d:%02d\n", dhour, dmin, dsec);
  }
#line 88
  return;
}
}
#line 90 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/pt3_load.c"
static void get_cmnt(struct xmp_context *ctx___0 , int size___0 , FILE *f ) 
{ 
  char *__cil_tmp4 ;

  {
  {
#line 92
  reportv(ctx___0, 0, (char *)"Comment size   : %d\n", size___0);
  }
#line 93
  return;
}
}
#line 95 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/pt3_load.c"
static void get_ptdt(struct xmp_context *ctx___0 , int size___0 , FILE *f ) 
{ 


  {
  {
#line 97
  ptdt_load(ctx___0, f, (int const   )0);
  }
#line 98
  return;
}
}
#line 100 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/pt3_load.c"
static int pt3_load(struct xmp_context *ctx___0 , FILE *f , int const   start ) 
{ 
  struct xmp_player_context *p ;
  struct xmp_mod_context *m___0 ;
  char buf___1[20] ;
  uint8 **tmp ;
  int tmp___0 ;
  void *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
#line 102
  p = & ctx___0->p;
#line 103
  m___0 = & p->m;
  {
#line 106
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 106
    fseek(f, (long )start, 0);
#line 106
    tmp = (uint8 **)((void *)0);
#line 106
    m___0->med_wav_table = tmp;
#line 106
    m___0->med_vol_table = tmp;
#line 106
    set_xxh_defaults(m___0->xxh);
    }
#line 106
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 108
  read32b(f);
#line 109
  read32b(f);
#line 110
  read32b(f);
#line 112
  read32b(f);
#line 113
  read32b(f);
#line 115
  fread((void */* __restrict  */)(buf___1), (size_t )1, (size_t )10, (FILE */* __restrict  */)f);
#line 116
  sprintf((char */* __restrict  */)(m___0->type), (char const   */* __restrict  */)"%-6.6s (Protracker IFFMODL)",
          buf___1 + 4);
#line 119
  iff_register((char *)"INFO", & get_info___0);
#line 120
  iff_register((char *)"CMNT", & get_cmnt);
#line 121
  iff_register((char *)"PTDT", & get_ptdt);
#line 123
  iff_setflag(2);
  }
  {
#line 126
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 126
    tmp___0 = feof(f);
    }
#line 126
    if (tmp___0) {
#line 126
      goto while_break___0;
    }
    {
#line 127
    iff_chunk(ctx___0, f);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 129
  iff_release();
  }
#line 131
  return (0);
}
}
#line 134 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/pt3_load.c"
static int ptdt_load(struct xmp_context *ctx___0 , FILE *f , int const   start ) 
{ 
  struct xmp_player_context *p ;
  struct xmp_mod_context *m___0 ;
  int i___3 ;
  int j ;
  struct xxm_event *event ;
  struct mod_header mh ;
  uint8 mod_event[4] ;
  uint8 tmp ;
  uint8 tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  void *tmp___11 ;
  void *tmp___12 ;
  void *tmp___13 ;
  int j___0 ;
  void *tmp___14 ;
  void *__cil_tmp28 ;
  void *__cil_tmp29 ;
  void *__cil_tmp30 ;
  int __cil_tmp31 ;
  void *__cil_tmp32 ;
  void *__cil_tmp33 ;
  void *__cil_tmp34 ;
  void *__cil_tmp35 ;
  void *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;

  {
  {
#line 136
  p = & ctx___0->p;
#line 137
  m___0 = & p->m;
#line 143
  fread((void */* __restrict  */)(& mh.name), (size_t )20, (size_t )1, (FILE */* __restrict  */)f);
#line 144
  i___3 = 0;
  }
  {
#line 144
  while (1) {
    while_continue: /* CIL Label */ ;
#line 144
    if (! (i___3 < 31)) {
#line 144
      goto while_break;
    }
    {
#line 145
    fread((void */* __restrict  */)(& mh.ins[i___3].name), (size_t )22, (size_t )1,
          (FILE */* __restrict  */)f);
#line 146
    mh.ins[i___3].size = read16b(f);
#line 147
    tmp = read8(f);
#line 147
    mh.ins[i___3].finetune = (int8 )tmp;
#line 148
    tmp___0 = read8(f);
#line 148
    mh.ins[i___3].volume = (int8 )tmp___0;
#line 149
    mh.ins[i___3].loop_start = read16b(f);
#line 150
    mh.ins[i___3].loop_size = read16b(f);
#line 144
    i___3 ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 152
  mh.len = read8(f);
#line 153
  mh.restart = read8(f);
#line 154
  fread((void */* __restrict  */)(& mh.order), (size_t )128, (size_t )1, (FILE */* __restrict  */)f);
#line 155
  fread((void */* __restrict  */)(& mh.magic), (size_t )4, (size_t )1, (FILE */* __restrict  */)f);
#line 157
  (m___0->xxh)->ins = 31;
#line 158
  (m___0->xxh)->smp = (m___0->xxh)->ins;
#line 159
  (m___0->xxh)->chn = 4;
#line 160
  (m___0->xxh)->len = (int )mh.len;
#line 161
  (m___0->xxh)->rst = (int )mh.restart;
#line 162
  memcpy((void */* __restrict  */)(m___0->xxo), (void const   */* __restrict  */)(mh.order),
         (size_t )128);
#line 164
  i___3 = 0;
  }
  {
#line 164
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 164
    if (! (i___3 < 128)) {
#line 164
      goto while_break___0;
    }
#line 165
    if ((int )m___0->xxo[i___3] > (m___0->xxh)->pat) {
#line 166
      (m___0->xxh)->pat = (int )m___0->xxo[i___3];
    }
#line 164
    i___3 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 169
  ((m___0->xxh)->pat) ++;
#line 170
  (m___0->xxh)->trk = (m___0->xxh)->chn * (m___0->xxh)->pat;
  {
#line 172
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 172
    tmp___1 = calloc((size_t )sizeof(struct xxm_instrument_header ), (size_t )(m___0->xxh)->ins);
#line 172
    m___0->xxih = (struct xxm_instrument_header *)tmp___1;
#line 172
    tmp___2 = calloc((size_t )sizeof(struct xxm_instrument_map ), (size_t )(m___0->xxh)->ins);
#line 172
    m___0->xxim = (struct xxm_instrument_map *)tmp___2;
#line 172
    tmp___3 = calloc((size_t )sizeof(struct xxm_instrument *), (size_t )(m___0->xxh)->ins);
#line 172
    m___0->xxi = (struct xxm_instrument **)tmp___3;
    }
#line 172
    if ((m___0->xxh)->smp) {
      {
#line 172
      tmp___4 = calloc((size_t )sizeof(struct xxm_sample ), (size_t )(m___0->xxh)->smp);
#line 172
      m___0->xxs = (struct xxm_sample *)tmp___4;
      }
    }
    {
#line 172
    tmp___5 = calloc((size_t )sizeof(uint16 *), (size_t )(m___0->xxh)->ins);
#line 172
    m___0->xxae = (uint16 **)tmp___5;
#line 172
    tmp___6 = calloc((size_t )sizeof(uint16 *), (size_t )(m___0->xxh)->ins);
#line 172
    m___0->xxpe = (uint16 **)tmp___6;
#line 172
    tmp___7 = calloc((size_t )sizeof(uint16 *), (size_t )(m___0->xxh)->ins);
#line 172
    m___0->xxfe = (uint16 **)tmp___7;
    }
#line 172
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 174
  reportv(ctx___0, 1, (char *)"     Instrument name        Len  LBeg LEnd L Vol Fin\n");
#line 177
  i___3 = 0;
  }
  {
#line 177
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 177
    if (! (i___3 < (m___0->xxh)->ins)) {
#line 177
      goto while_break___2;
    }
    {
#line 178
    tmp___8 = calloc((size_t )sizeof(struct xxm_instrument ), (size_t )1);
#line 178
    *(m___0->xxi + i___3) = (struct xxm_instrument *)tmp___8;
#line 179
    (m___0->xxs + i___3)->len = 2 * (int )mh.ins[i___3].size;
#line 180
    (m___0->xxs + i___3)->lps = 2 * (int )mh.ins[i___3].loop_start;
#line 181
    (m___0->xxs + i___3)->lpe = (m___0->xxs + i___3)->lps + 2 * (int )mh.ins[i___3].loop_size;
    }
#line 182
    if ((int )mh.ins[i___3].loop_size > 1) {
#line 182
      (m___0->xxs + i___3)->flg = 4;
    } else {
#line 182
      (m___0->xxs + i___3)->flg = 0;
    }
#line 183
    if ((m___0->xxs + i___3)->flg & 4) {
#line 184
      if ((m___0->xxs + i___3)->len == 0) {
#line 184
        if ((m___0->xxs + i___3)->len > (m___0->xxs + i___3)->lpe) {
#line 185
          (m___0->xxs + i___3)->flg |= 128;
        }
      }
    }
    {
#line 187
    (*(m___0->xxi + i___3) + 0)->fin = (int )((int8 )((int )mh.ins[i___3].finetune << 4));
#line 188
    (*(m___0->xxi + i___3) + 0)->vol = (int )mh.ins[i___3].volume;
#line 189
    (*(m___0->xxi + i___3) + 0)->pan = 128;
#line 190
    (*(m___0->xxi + i___3) + 0)->sid = i___3;
#line 191
    (m___0->xxih + i___3)->nsm = ! (! (m___0->xxs + i___3)->len);
#line 192
    (m___0->xxih + i___3)->rls = 4095;
#line 194
    copy_adjust((m___0->xxih + i___3)->name, mh.ins[i___3].name, 22);
    }
#line 196
    if (m___0->verbosity > 1) {
#line 196
      if ((m___0->xxih + i___3)->name[0]) {
#line 196
        goto _L;
      } else
#line 196
      if ((m___0->xxs + i___3)->len > 2) {
        _L: /* CIL Label */ 
#line 197
        if ((m___0->xxs + i___3)->flg & 128) {
#line 197
          tmp___9 = '!';
        } else {
#line 197
          tmp___9 = ' ';
        }
#line 197
        if ((int )mh.ins[i___3].loop_size > 1) {
#line 197
          tmp___10 = 'L';
        } else {
#line 197
          tmp___10 = ' ';
        }
        {
#line 197
        report((char *)"[%2X] %-22.22s %04x %04x %04x %c V%02x %+d %c\n", i___3, (m___0->xxih + i___3)->name,
               (m___0->xxs + i___3)->len, (m___0->xxs + i___3)->lps, (m___0->xxs + i___3)->lpe,
               tmp___10, (*(m___0->xxi + i___3) + 0)->vol, (*(m___0->xxi + i___3) + 0)->fin >> 4,
               tmp___9);
        }
      }
    }
#line 177
    i___3 ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 208
  while (1) {
    while_continue___3: /* CIL Label */ ;
    {
#line 208
    tmp___11 = calloc((size_t )sizeof(struct xxm_track *), (size_t )(m___0->xxh)->trk);
#line 208
    m___0->xxt = (struct xxm_track **)tmp___11;
#line 208
    tmp___12 = calloc((size_t )sizeof(struct xxm_pattern *), (size_t )((m___0->xxh)->pat + 1));
#line 208
    m___0->xxp = (struct xxm_pattern **)tmp___12;
    }
#line 208
    goto while_break___3;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 211
  reportv(ctx___0, 0, (char *)"Stored patterns: %d ", (m___0->xxh)->pat);
#line 213
  i___3 = 0;
  }
  {
#line 213
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 213
    if (! (i___3 < (m___0->xxh)->pat)) {
#line 213
      goto while_break___4;
    }
    {
#line 214
    while (1) {
      while_continue___5: /* CIL Label */ ;
      {
#line 214
      tmp___13 = calloc((size_t )1, (size_t )(sizeof(struct xxm_pattern ) + sizeof(struct xxm_trackinfo ) * (unsigned long )((m___0->xxh)->chn - 1)));
#line 214
      *(m___0->xxp + i___3) = (struct xxm_pattern *)tmp___13;
      }
#line 214
      goto while_break___5;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 215
    (*(m___0->xxp + i___3))->rows = 64;
    {
#line 216
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 216
      j___0 = 0;
      {
#line 216
      while (1) {
        while_continue___7: /* CIL Label */ ;
#line 216
        if (! (j___0 < (m___0->xxh)->chn)) {
#line 216
          goto while_break___7;
        }
        {
#line 216
        (*(m___0->xxp + i___3))->info[j___0].index = i___3 * (m___0->xxh)->chn + j___0;
#line 216
        tmp___14 = calloc((size_t )(sizeof(struct xxm_track ) + sizeof(struct xxm_event ) * (unsigned long )(*(m___0->xxp + i___3))->rows),
                          (size_t )1);
#line 216
        *(m___0->xxt + (i___3 * (m___0->xxh)->chn + j___0)) = (struct xxm_track *)tmp___14;
#line 216
        (*(m___0->xxt + (i___3 * (m___0->xxh)->chn + j___0)))->rows = (*(m___0->xxp + i___3))->rows;
#line 216
        j___0 ++;
        }
      }
      while_break___7: /* CIL Label */ ;
      }
#line 216
      goto while_break___6;
    }
    while_break___6: /* CIL Label */ ;
    }
#line 217
    j = 0;
    {
#line 217
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 217
      if (! (j < 256)) {
#line 217
        goto while_break___8;
      }
      {
#line 218
      event = & (*(m___0->xxt + (*(m___0->xxp + i___3))->info[j % 4].index))->event[j / 4];
#line 219
      fread((void */* __restrict  */)(mod_event), (size_t )1, (size_t )4, (FILE */* __restrict  */)f);
#line 220
      cvt_pt_event(event, mod_event);
#line 217
      j ++;
      }
    }
    while_break___8: /* CIL Label */ ;
    }
    {
#line 222
    reportv(ctx___0, 0, (char *)".");
#line 213
    i___3 ++;
    }
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 225
  (m___0->xxh)->flg |= 2;
#line 228
  reportv(ctx___0, 0, (char *)"\nStored samples : %d ", (m___0->xxh)->smp);
#line 230
  i___3 = 0;
  }
  {
#line 230
  while (1) {
    while_continue___9: /* CIL Label */ ;
#line 230
    if (! (i___3 < (m___0->xxh)->smp)) {
#line 230
      goto while_break___9;
    }
#line 231
    if (! (m___0->xxs + i___3)->len) {
#line 232
      goto __Cont;
    }
    {
#line 233
    xmp_drv_loadpatch(ctx___0, f, (*(m___0->xxi + i___3) + 0)->sid, m___0->c4rate,
                      0, m___0->xxs + (*(m___0->xxi + i___3) + 0)->sid, (char *)((void *)0));
#line 235
    reportv(ctx___0, 0, (char *)".");
    }
    __Cont: /* CIL Label */ 
#line 230
    i___3 ++;
  }
  while_break___9: /* CIL Label */ ;
  }
  {
#line 237
  reportv(ctx___0, 0, (char *)"\n");
  }
#line 239
  return (0);
}
}
#line 33 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/stx_load.c"
static int stx_test(FILE *f , char *t , int const   start ) ;
#line 34
static int stx_load(struct xmp_context *ctx___0 , FILE *f , int const   start ) ;
#line 36 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/stx_load.c"
struct xmp_loader_info stx_loader  =    {(char *)"STX", (char *)"STMIK 0.2", & stx_test, & stx_load, 0, {(struct list_head *)0,
                                                                    (struct list_head *)0}};
#line 43 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/stx_load.c"
static int stx_test(FILE *f , char *t , int const   start ) 
{ 
  char buf___1[8] ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  void *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
  {
#line 47
  fseek(f, (long )(start + 20), 0);
#line 48
  fread((void */* __restrict  */)(buf___1), (size_t )8, (size_t )1, (FILE */* __restrict  */)f);
#line 49
  tmp = memcmp((void const   *)(buf___1), (void const   *)"!Scream!", (size_t )8);
  }
#line 49
  if (tmp) {
    {
#line 49
    tmp___0 = memcmp((void const   *)(buf___1), (void const   *)"BMOD2STM", (size_t )8);
    }
#line 49
    if (tmp___0) {
#line 50
      return (-1);
    }
  }
  {
#line 52
  fseek(f, (long )(start + 60), 0);
#line 53
  fread((void */* __restrict  */)(buf___1), (size_t )4, (size_t )1, (FILE */* __restrict  */)f);
#line 54
  tmp___1 = memcmp((void const   *)(buf___1), (void const   *)"SCRM", (size_t )4);
  }
#line 54
  if (tmp___1) {
#line 55
    return (-1);
  }
  {
#line 57
  fseek(f, (long )start, 0);
#line 58
  read_title(f, t, 20);
  }
#line 60
  return (0);
}
}
#line 65 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/stx_load.c"
static uint16 *pp_ins  ;
#line 66 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/stx_load.c"
static uint16 *pp_pat  ;
#line 68 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/stx_load.c"
static uint8 fx___2[11]  = 
#line 68
  {      (uint8 )255,      (uint8 )15,      (uint8 )11,      (uint8 )13, 
        (uint8 )10,      (uint8 )2,      (uint8 )1,      (uint8 )3, 
        (uint8 )4,      (uint8 )29,      (uint8 )0};
#line 78 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/stx_load.c"
static int stx_load(struct xmp_context *ctx___0 , FILE *f , int const   start ) 
{ 
  struct xmp_player_context *p ;
  struct xmp_mod_context *m___0 ;
  int c___0 ;
  int r ;
  int i___3 ;
  int broken ;
  struct xxm_event *event ;
  struct xxm_event dummy___3 ;
  struct stx_file_header sfh ;
  struct stx_instrument_header sih ;
  uint8 n___0 ;
  uint8 b___1 ;
  uint16 x16 ;
  int bmod2stm ;
  uint8 **tmp ;
  int tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  void *tmp___9 ;
  void *tmp___10 ;
  void *tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  size_t tmp___15 ;
  void *tmp___16 ;
  void *tmp___17 ;
  void *tmp___18 ;
  int j ;
  void *tmp___19 ;
  uint8 tmp___20 ;
  uint8 tmp___21 ;
  uint8 tmp___22 ;
  void *__cil_tmp43 ;
  void *__cil_tmp44 ;
  void *__cil_tmp45 ;
  void *__cil_tmp46 ;
  void *__cil_tmp47 ;
  void *__cil_tmp48 ;
  void *__cil_tmp49 ;
  void *__cil_tmp50 ;
  void *__cil_tmp51 ;
  void *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;
  char *__cil_tmp66 ;
  char *__cil_tmp67 ;

  {
#line 80
  p = & ctx___0->p;
#line 81
  m___0 = & p->m;
#line 82
  broken = 0;
#line 83
  event = (struct xxm_event *)0;
#line 88
  bmod2stm = 0;
  {
#line 90
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 90
    fseek(f, (long )start, 0);
#line 90
    tmp = (uint8 **)((void *)0);
#line 90
    m___0->med_wav_table = tmp;
#line 90
    m___0->med_vol_table = tmp;
#line 90
    set_xxh_defaults(m___0->xxh);
    }
#line 90
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 92
  fread((void */* __restrict  */)(& sfh.name), (size_t )20, (size_t )1, (FILE */* __restrict  */)f);
#line 93
  fread((void */* __restrict  */)(& sfh.magic), (size_t )8, (size_t )1, (FILE */* __restrict  */)f);
#line 94
  sfh.psize = read16l(f);
#line 95
  sfh.unknown1 = read16l(f);
#line 96
  sfh.pp_pat = read16l(f);
#line 97
  sfh.pp_ins = read16l(f);
#line 98
  sfh.pp_chn = read16l(f);
#line 99
  sfh.unknown2 = read16l(f);
#line 100
  sfh.unknown3 = read16l(f);
#line 101
  sfh.gvol = read8(f);
#line 102
  sfh.tempo = read8(f);
#line 103
  sfh.unknown4 = read16l(f);
#line 104
  sfh.unknown5 = read16l(f);
#line 105
  sfh.patnum = read16l(f);
#line 106
  sfh.insnum = read16l(f);
#line 107
  sfh.ordnum = read16l(f);
#line 108
  sfh.unknown6 = read16l(f);
#line 109
  sfh.unknown7 = read16l(f);
#line 110
  sfh.unknown8 = read16l(f);
#line 111
  fread((void */* __restrict  */)(& sfh.magic2), (size_t )4, (size_t )1, (FILE */* __restrict  */)f);
#line 114
  tmp___0 = strncmp((char const   *)((char *)(sfh.magic)), "BMOD2STM", (size_t )8);
  }
#line 114
  if (! tmp___0) {
#line 115
    bmod2stm = 1;
  }
  {
#line 123
  (m___0->xxh)->ins = (int )sfh.insnum;
#line 124
  (m___0->xxh)->pat = (int )sfh.patnum;
#line 125
  (m___0->xxh)->trk = (m___0->xxh)->pat * (m___0->xxh)->chn;
#line 126
  (m___0->xxh)->len = (int )sfh.ordnum;
#line 127
  (m___0->xxh)->tpo = ((int )sfh.tempo & 240) >> 4;
#line 128
  (m___0->xxh)->smp = (m___0->xxh)->ins;
#line 129
  m___0->c4rate = 8363;
#line 134
  fseek(f, (long )(start + (int const   )((int )sfh.pp_pat << 4)), 0);
#line 135
  x16 = read16l(f);
#line 136
  fseek(f, (long )(start + (int const   )((int )x16 << 4)), 0);
#line 137
  x16 = read16l(f);
  }
#line 138
  if ((int )x16 == (int )sfh.psize) {
#line 139
    broken = 1;
  }
  {
#line 141
  strncpy((char */* __restrict  */)(m___0->name), (char const   */* __restrict  */)((char *)(sfh.name)),
          (size_t )20);
  }
#line 142
  if (bmod2stm) {
    {
#line 143
    sprintf((char */* __restrict  */)(m___0->type), (char const   */* __restrict  */)"STMIK 0.2 (BMOD2STM)");
    }
  } else {
#line 145
    if (broken) {
#line 145
      tmp___1 = 0;
    } else {
#line 145
      tmp___1 = 1;
    }
    {
#line 145
    snprintf((char */* __restrict  */)(m___0->type), (size_t )64, (char const   */* __restrict  */)"STMIK 0.2 (STM2STX 1.%d)",
             tmp___1);
    }
  }
  {
#line 148
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 148
    if (m___0->verbosity) {
#line 148
      if (m___0->name[0]) {
        {
#line 148
        report((char *)"Module title   : %s\n", m___0->name);
        }
      }
#line 148
      if (m___0->type[0]) {
        {
#line 148
        report((char *)"Module type    : %s\n", m___0->type);
        }
      }
#line 148
      if (m___0->author[0]) {
        {
#line 148
        report((char *)"Author name    : %s\n", m___0->author);
        }
      }
#line 148
      if ((m___0->xxh)->len) {
        {
#line 148
        report((char *)"Module length  : %d patterns\n", (m___0->xxh)->len);
        }
      }
    }
#line 148
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 150
  tmp___2 = calloc((size_t )2, (size_t )(m___0->xxh)->pat);
#line 150
  pp_pat = (uint16 *)tmp___2;
#line 151
  tmp___3 = calloc((size_t )2, (size_t )(m___0->xxh)->ins);
#line 151
  pp_ins = (uint16 *)tmp___3;
#line 154
  fseek(f, (long )(start + (int const   )((int )sfh.pp_pat << 4)), 0);
#line 155
  i___3 = 0;
  }
  {
#line 155
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 155
    if (! (i___3 < (m___0->xxh)->pat)) {
#line 155
      goto while_break___1;
    }
    {
#line 156
    *(pp_pat + i___3) = read16l(f);
#line 155
    i___3 ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 159
  fseek(f, (long )(start + (int const   )((int )sfh.pp_ins << 4)), 0);
#line 160
  i___3 = 0;
  }
  {
#line 160
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 160
    if (! (i___3 < (m___0->xxh)->ins)) {
#line 160
      goto while_break___2;
    }
    {
#line 161
    *(pp_ins + i___3) = read16l(f);
#line 160
    i___3 ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 164
  fseek(f, (long )((start + (int const   )((int )sfh.pp_chn << 4)) + 32), 0);
#line 167
  i___3 = 0;
  }
  {
#line 167
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 167
    if (! (i___3 < (m___0->xxh)->len)) {
#line 167
      goto while_break___3;
    }
    {
#line 168
    m___0->xxo[i___3] = read8(f);
#line 169
    fseek(f, 4L, 1);
#line 167
    i___3 ++;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 172
  while (1) {
    while_continue___4: /* CIL Label */ ;
    {
#line 172
    tmp___4 = calloc((size_t )sizeof(struct xxm_instrument_header ), (size_t )(m___0->xxh)->ins);
#line 172
    m___0->xxih = (struct xxm_instrument_header *)tmp___4;
#line 172
    tmp___5 = calloc((size_t )sizeof(struct xxm_instrument_map ), (size_t )(m___0->xxh)->ins);
#line 172
    m___0->xxim = (struct xxm_instrument_map *)tmp___5;
#line 172
    tmp___6 = calloc((size_t )sizeof(struct xxm_instrument *), (size_t )(m___0->xxh)->ins);
#line 172
    m___0->xxi = (struct xxm_instrument **)tmp___6;
    }
#line 172
    if ((m___0->xxh)->smp) {
      {
#line 172
      tmp___7 = calloc((size_t )sizeof(struct xxm_sample ), (size_t )(m___0->xxh)->smp);
#line 172
      m___0->xxs = (struct xxm_sample *)tmp___7;
      }
    }
    {
#line 172
    tmp___8 = calloc((size_t )sizeof(uint16 *), (size_t )(m___0->xxh)->ins);
#line 172
    m___0->xxae = (uint16 **)tmp___8;
#line 172
    tmp___9 = calloc((size_t )sizeof(uint16 *), (size_t )(m___0->xxh)->ins);
#line 172
    m___0->xxpe = (uint16 **)tmp___9;
#line 172
    tmp___10 = calloc((size_t )sizeof(uint16 *), (size_t )(m___0->xxh)->ins);
#line 172
    m___0->xxfe = (uint16 **)tmp___10;
    }
#line 172
    goto while_break___4;
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 176
  reportv(ctx___0, 1, (char *)"     Sample name    Len  LBeg LEnd L Vol C2Spd\n");
#line 178
  i___3 = 0;
  }
  {
#line 178
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 178
    if (! (i___3 < (m___0->xxh)->ins)) {
#line 178
      goto while_break___5;
    }
    {
#line 179
    tmp___11 = calloc((size_t )sizeof(struct xxm_instrument ), (size_t )1);
#line 179
    *(m___0->xxi + i___3) = (struct xxm_instrument *)tmp___11;
#line 180
    fseek(f, (long )(start + (int const   )((int )*(pp_ins + i___3) << 4)), 0);
#line 182
    sih.type = read8(f);
#line 183
    fread((void */* __restrict  */)(& sih.dosname), (size_t )13, (size_t )1, (FILE */* __restrict  */)f);
#line 184
    sih.memseg = read16l(f);
#line 185
    sih.length = read32l(f);
#line 186
    sih.loopbeg = read32l(f);
#line 187
    sih.loopend = read32l(f);
#line 188
    sih.vol = read8(f);
#line 189
    sih.rsvd1 = read8(f);
#line 190
    sih.pack = read8(f);
#line 191
    sih.flags = read8(f);
#line 192
    sih.c2spd = read16l(f);
#line 193
    sih.rsvd2 = read16l(f);
#line 194
    fread((void */* __restrict  */)(& sih.rsvd3), (size_t )4, (size_t )1, (FILE */* __restrict  */)f);
#line 195
    sih.int_gp = read16l(f);
#line 196
    sih.int_512 = read16l(f);
#line 197
    sih.int_last = read32l(f);
#line 198
    fread((void */* __restrict  */)(& sih.name), (size_t )28, (size_t )1, (FILE */* __restrict  */)f);
#line 199
    fread((void */* __restrict  */)(& sih.magic), (size_t )4, (size_t )1, (FILE */* __restrict  */)f);
#line 201
    tmp___12 = (int )sih.length;
#line 201
    (m___0->xxs + i___3)->len = tmp___12;
    }
#line 201
    if (tmp___12) {
#line 201
      tmp___13 = 1;
    } else {
#line 201
      tmp___13 = 0;
    }
#line 201
    (m___0->xxih + i___3)->nsm = tmp___13;
#line 202
    (m___0->xxs + i___3)->lps = (int )sih.loopbeg;
#line 203
    (m___0->xxs + i___3)->lpe = (int )sih.loopend;
#line 204
    if ((m___0->xxs + i___3)->lpe == 65535) {
#line 205
      (m___0->xxs + i___3)->lpe = 0;
    }
#line 206
    if ((m___0->xxs + i___3)->lpe > 0) {
#line 206
      (m___0->xxs + i___3)->flg = 4;
    } else {
#line 206
      (m___0->xxs + i___3)->flg = 0;
    }
    {
#line 207
    (*(m___0->xxi + i___3) + 0)->vol = (int )sih.vol;
#line 208
    (*(m___0->xxi + i___3) + 0)->pan = 128;
#line 209
    (*(m___0->xxi + i___3) + 0)->sid = i___3;
#line 211
    copy_adjust((m___0->xxih + i___3)->name, sih.name, 12);
    }
#line 213
    if (m___0->verbosity > 1) {
      {
#line 213
      tmp___15 = strlen((char const   *)((char *)((m___0->xxih + i___3)->name)));
      }
#line 213
      if (tmp___15) {
#line 213
        goto _L;
      } else
#line 213
      if ((m___0->xxs + i___3)->len > 1) {
        _L: /* CIL Label */ 
#line 215
        if ((m___0->xxs + i___3)->flg & 4) {
#line 215
          tmp___14 = 'L';
        } else {
#line 215
          tmp___14 = ' ';
        }
        {
#line 215
        report((char *)"[%2X] %-14.14s %04x %04x %04x %c V%02x %5d\n", i___3, (m___0->xxih + i___3)->name,
               (m___0->xxs + i___3)->len, (m___0->xxs + i___3)->lps, (m___0->xxs + i___3)->lpe,
               tmp___14, (*(m___0->xxi + i___3) + 0)->vol, (int )sih.c2spd);
        }
      }
    }
    {
#line 220
    sih.c2spd = (uint16 )((8363 * (int )sih.c2spd) / 8448);
#line 221
    c2spd_to_note((int )sih.c2spd, & (*(m___0->xxi + i___3) + 0)->xpo, & (*(m___0->xxi + i___3) + 0)->fin);
#line 178
    i___3 ++;
    }
  }
  while_break___5: /* CIL Label */ ;
  }
  {
#line 224
  while (1) {
    while_continue___6: /* CIL Label */ ;
    {
#line 224
    tmp___16 = calloc((size_t )sizeof(struct xxm_track *), (size_t )(m___0->xxh)->trk);
#line 224
    m___0->xxt = (struct xxm_track **)tmp___16;
#line 224
    tmp___17 = calloc((size_t )sizeof(struct xxm_pattern *), (size_t )((m___0->xxh)->pat + 1));
#line 224
    m___0->xxp = (struct xxm_pattern **)tmp___17;
    }
#line 224
    goto while_break___6;
  }
  while_break___6: /* CIL Label */ ;
  }
  {
#line 227
  reportv(ctx___0, 0, (char *)"Stored patterns: %d ", (m___0->xxh)->pat);
#line 229
  i___3 = 0;
  }
  {
#line 229
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 229
    if (! (i___3 < (m___0->xxh)->pat)) {
#line 229
      goto while_break___7;
    }
    {
#line 230
    while (1) {
      while_continue___8: /* CIL Label */ ;
      {
#line 230
      tmp___18 = calloc((size_t )1, (size_t )(sizeof(struct xxm_pattern ) + sizeof(struct xxm_trackinfo ) * (unsigned long )((m___0->xxh)->chn - 1)));
#line 230
      *(m___0->xxp + i___3) = (struct xxm_pattern *)tmp___18;
      }
#line 230
      goto while_break___8;
    }
    while_break___8: /* CIL Label */ ;
    }
#line 231
    (*(m___0->xxp + i___3))->rows = 64;
    {
#line 232
    while (1) {
      while_continue___9: /* CIL Label */ ;
#line 232
      j = 0;
      {
#line 232
      while (1) {
        while_continue___10: /* CIL Label */ ;
#line 232
        if (! (j < (m___0->xxh)->chn)) {
#line 232
          goto while_break___10;
        }
        {
#line 232
        (*(m___0->xxp + i___3))->info[j].index = i___3 * (m___0->xxh)->chn + j;
#line 232
        tmp___19 = calloc((size_t )(sizeof(struct xxm_track ) + sizeof(struct xxm_event ) * (unsigned long )(*(m___0->xxp + i___3))->rows),
                          (size_t )1);
#line 232
        *(m___0->xxt + (i___3 * (m___0->xxh)->chn + j)) = (struct xxm_track *)tmp___19;
#line 232
        (*(m___0->xxt + (i___3 * (m___0->xxh)->chn + j)))->rows = (*(m___0->xxp + i___3))->rows;
#line 232
        j ++;
        }
      }
      while_break___10: /* CIL Label */ ;
      }
#line 232
      goto while_break___9;
    }
    while_break___9: /* CIL Label */ ;
    }
#line 234
    if (! *(pp_pat + i___3)) {
#line 235
      goto __Cont;
    }
    {
#line 237
    fseek(f, (long )(start + (int const   )((int )*(pp_pat + i___3) << 4)), 0);
    }
#line 238
    if (broken) {
      {
#line 239
      fseek(f, 2L, 1);
      }
    }
#line 241
    r = 0;
    {
#line 241
    while (1) {
      while_continue___11: /* CIL Label */ ;
#line 241
      if (! (r < 64)) {
#line 241
        goto while_break___11;
      }
      {
#line 242
      b___1 = read8(f);
      }
#line 244
      if ((int )b___1 == 0) {
#line 245
        r ++;
#line 246
        goto __Cont___0;
      }
#line 249
      c___0 = (int )b___1 & 31;
#line 250
      if (c___0 >= (m___0->xxh)->chn) {
#line 250
        event = & dummy___3;
      } else {
#line 250
        event = & (*(m___0->xxt + (*(m___0->xxp + i___3))->info[c___0].index))->event[r];
      }
#line 252
      if ((int )b___1 & 32) {
        {
#line 253
        n___0 = read8(f);
        }
        {
#line 256
        if ((int )n___0 == 255) {
#line 256
          goto case_255;
        }
#line 259
        if ((int )n___0 == 254) {
#line 259
          goto case_254;
        }
#line 262
        goto switch_default;
        case_255: /* CIL Label */ 
#line 257
        n___0 = (uint8 )0;
#line 258
        goto switch_break;
        case_254: /* CIL Label */ 
#line 260
        n___0 = (uint8 )129;
#line 261
        goto switch_break;
        switch_default: /* CIL Label */ 
#line 263
        n___0 = (uint8 )((25 + 12 * (((int )n___0 & 240) >> 4)) + ((int )n___0 & 15));
        switch_break: /* CIL Label */ ;
        }
        {
#line 266
        event->note = n___0;
#line 267
        event->ins = read8(f);
        }
      }
#line 270
      if ((int )b___1 & 64) {
        {
#line 271
        tmp___20 = read8(f);
#line 271
        event->vol = (uint8 )((int )tmp___20 + 1);
        }
      }
#line 274
      if ((int )b___1 & 128) {
        {
#line 275
        tmp___21 = read8(f);
#line 275
        event->fxt = fx___2[tmp___21];
#line 276
        event->fxp = read8(f);
        }
        {
#line 278
        if ((int )event->fxt == 15) {
#line 278
          goto case_15;
        }
#line 281
        if ((int )event->fxt == 255) {
#line 281
          goto case_255___0;
        }
#line 277
        goto switch_break___0;
        case_15: /* CIL Label */ 
#line 279
        event->fxp = (uint8 )(((int )event->fxp & 240) >> 4);
#line 280
        goto switch_break___0;
        case_255___0: /* CIL Label */ 
#line 282
        tmp___22 = (uint8 )0;
#line 282
        event->fxt = tmp___22;
#line 282
        event->fxp = tmp___22;
#line 283
        goto switch_break___0;
        switch_break___0: /* CIL Label */ ;
        }
      }
      __Cont___0: /* CIL Label */ ;
    }
    while_break___11: /* CIL Label */ ;
    }
    {
#line 288
    reportv(ctx___0, 0, (char *)".");
    }
    __Cont: /* CIL Label */ 
#line 229
    i___3 ++;
  }
  while_break___7: /* CIL Label */ ;
  }
  {
#line 290
  reportv(ctx___0, 0, (char *)"\n");
#line 292
  free((void *)pp_pat);
#line 293
  free((void *)pp_ins);
#line 296
  reportv(ctx___0, 0, (char *)"Stored samples : %d ", (m___0->xxh)->smp);
#line 298
  i___3 = 0;
  }
  {
#line 298
  while (1) {
    while_continue___12: /* CIL Label */ ;
#line 298
    if (! (i___3 < (m___0->xxh)->ins)) {
#line 298
      goto while_break___12;
    }
    {
#line 299
    xmp_drv_loadpatch(ctx___0, f, (*(m___0->xxi + i___3) + 0)->sid, m___0->c4rate,
                      0, m___0->xxs + (*(m___0->xxi + i___3) + 0)->sid, (char *)((void *)0));
#line 301
    reportv(ctx___0, 0, (char *)".");
#line 298
    i___3 ++;
    }
  }
  while_break___12: /* CIL Label */ ;
  }
  {
#line 303
  reportv(ctx___0, 0, (char *)"\n");
#line 305
  m___0->quirk |= (1 << 13) | (((((1 << 5) | (1 << 4)) | (1 << 1)) | (1 << 14)) | (1 << 17));
  }
#line 307
  return (0);
}
}
#line 27 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/load.h"
void clean_s3m_seq(struct xxm_header *xxh , uint8 *xxo ) ;
#line 29
uint8 ord_xlat[255] ;
#line 21 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/it_load.c"
static int it_test(FILE *f , char *t , int const   start ) ;
#line 22
static int it_load(struct xmp_context *ctx___0 , FILE *f , int const   start ) ;
#line 24 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/it_load.c"
struct xmp_loader_info it_loader  =    {(char *)"IT", (char *)"Impulse Tracker", & it_test, & it_load, 0, {(struct list_head *)0,
                                                                       (struct list_head *)0}};
#line 31 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/it_load.c"
static int it_test(FILE *f , char *t , int const   start ) 
{ 
  uint32 tmp ;

  {
  {
#line 33
  tmp = read32b(f);
  }
#line 33
  if (tmp != ((((73U << 24) | (77U << 16)) | (80U << 8)) | 77U)) {
#line 34
    return (-1);
  }
  {
#line 36
  read_title(f, t, 26);
  }
#line 38
  return (0);
}
}
#line 47 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/it_load.c"
static uint32 *pp_ins___0  ;
#line 48 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/it_load.c"
static uint32 *pp_smp  ;
#line 49 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/it_load.c"
static uint32 *pp_pat___0  ;
#line 50 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/it_load.c"
static uint8 arpeggio_val___0[64]  ;
#line 51 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/it_load.c"
static uint8 last_h[64]  ;
#line 51 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/it_load.c"
static uint8 last_fxp[64]  ;
#line 53 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/it_load.c"
static uint8 fx___3[27]  = 
#line 53
  {      (uint8 )255,      (uint8 )163,      (uint8 )11,      (uint8 )13, 
        (uint8 )10,      (uint8 )2,      (uint8 )1,      (uint8 )3, 
        (uint8 )4,      (uint8 )29,      (uint8 )0,      (uint8 )6, 
        (uint8 )5,      (uint8 )128,      (uint8 )129,      (uint8 )9, 
        (uint8 )255,      (uint8 )27,      (uint8 )7,      (uint8 )254, 
        (uint8 )173,      (uint8 )255,      (uint8 )16,      (uint8 )17, 
        (uint8 )255,      (uint8 )255,      (uint8 )132};
#line 83 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/it_load.c"
static char *nna[4]  = {      (char *)"cut",      (char *)"cont",      (char *)"off",      (char *)"fade"};
#line 84 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/it_load.c"
static char *dct[4]  = {      (char *)"off",      (char *)"note",      (char *)"smp",      (char *)"inst"};
#line 85 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/it_load.c"
static int dca2nna[3]  = {      0,      2,      3};
#line 86 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/it_load.c"
static int new_fx  ;
#line 88
extern int itsex_decompress8(FILE * , void * , int  , int  ) ;
#line 89
extern int itsex_decompress16(FILE * , void * , int  , int  ) ;
#line 92 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/it_load.c"
static void xlat_fx___3(int c___0 , struct xxm_event *e ) 
{ 
  uint8 h ;
  uint8 l ;
  uint8 tmp ;
  uint8 tmp___0 ;
  uint8 tmp___1 ;
  uint8 tmp___2 ;
  uint8 tmp___3 ;
  uint8 tmp___4 ;

  {
#line 94
  h = (uint8 )(((int )e->fxp & 240) >> 4);
#line 94
  l = (uint8 )((int )e->fxp & 15);
#line 96
  tmp = fx___3[e->fxt];
#line 96
  e->fxt = tmp;
  {
#line 97
  if ((int )tmp == 0) {
#line 97
    goto case_0;
  }
#line 103
  if ((int )tmp == 11) {
#line 103
    goto case_11;
  }
#line 106
  if ((int )tmp == 4) {
#line 106
    goto case_4;
  }
#line 110
  if ((int )tmp == 254) {
#line 110
    goto case_254;
  }
#line 166
  if ((int )tmp == 132) {
#line 166
    goto case_132;
  }
#line 174
  if ((int )tmp == 29) {
#line 174
    goto case_29;
  }
#line 180
  if ((int )tmp == 255) {
#line 180
    goto case_255;
  }
#line 96
  goto switch_break;
  case_0: /* CIL Label */ 
#line 98
  if (e->fxp) {
#line 99
    arpeggio_val___0[c___0] = e->fxp;
  } else {
#line 101
    e->fxp = arpeggio_val___0[c___0];
  }
#line 102
  goto switch_break;
  case_11: /* CIL Label */ 
#line 104
  e->fxp = ord_xlat[e->fxp];
#line 105
  goto switch_break;
  case_4: /* CIL Label */ 
#line 107
  if (new_fx) {
#line 108
    e->fxt = (uint8 )134;
  }
#line 109
  goto switch_break;
  case_254: /* CIL Label */ 
#line 111
  e->fxt = (uint8 )14;
#line 113
  if ((int )h == 0) {
#line 113
    if ((int )e->fxp == 0) {
#line 114
      h = last_h[c___0];
#line 115
      e->fxp = last_fxp[c___0];
    } else {
#line 117
      last_h[c___0] = h;
#line 118
      last_fxp[c___0] = e->fxp;
    }
  } else {
#line 117
    last_h[c___0] = h;
#line 118
    last_fxp[c___0] = e->fxp;
  }
  {
#line 122
  if ((int )h == 1) {
#line 122
    goto case_1;
  }
#line 125
  if ((int )h == 2) {
#line 125
    goto case_2;
  }
#line 128
  if ((int )h == 3) {
#line 128
    goto case_3;
  }
#line 131
  if ((int )h == 4) {
#line 131
    goto case_4___0;
  }
#line 134
  if ((int )h == 5) {
#line 134
    goto case_5;
  }
#line 137
  if ((int )h == 6) {
#line 137
    goto case_6;
  }
#line 140
  if ((int )h == 7) {
#line 140
    goto case_7;
  }
#line 144
  if ((int )h == 8) {
#line 144
    goto case_8;
  }
#line 148
  if ((int )h == 9) {
#line 148
    goto case_9;
  }
#line 151
  if ((int )h == 11) {
#line 151
    goto case_11___0;
  }
#line 155
  if ((int )h == 13) {
#line 155
    goto case_13;
  }
#line 155
  if ((int )h == 12) {
#line 155
    goto case_13;
  }
#line 160
  if ((int )h == 14) {
#line 160
    goto case_14;
  }
#line 162
  goto switch_default;
  case_1: /* CIL Label */ 
#line 123
  e->fxp = (uint8 )(48 | (int )l);
#line 124
  goto switch_break___0;
  case_2: /* CIL Label */ 
#line 126
  e->fxp = (uint8 )(80 | (int )l);
#line 127
  goto switch_break___0;
  case_3: /* CIL Label */ 
#line 129
  e->fxp = (uint8 )(64 | (int )l);
#line 130
  goto switch_break___0;
  case_4___0: /* CIL Label */ 
#line 132
  e->fxp = (uint8 )(112 | (int )l);
#line 133
  goto switch_break___0;
  case_5: /* CIL Label */ 
#line 135
  tmp___0 = (uint8 )0;
#line 135
  e->fxp = tmp___0;
#line 135
  e->fxt = tmp___0;
#line 136
  goto switch_break___0;
  case_6: /* CIL Label */ 
#line 138
  e->fxp = (uint8 )(224 | (int )l);
#line 139
  goto switch_break___0;
  case_7: /* CIL Label */ 
#line 141
  e->fxt = (uint8 )131;
#line 142
  e->fxp = (uint8 )((int )e->fxp & 15);
#line 143
  goto switch_break___0;
  case_8: /* CIL Label */ 
#line 145
  e->fxt = (uint8 )8;
#line 146
  e->fxp = (uint8 )((int )l << 4);
#line 147
  goto switch_break___0;
  case_9: /* CIL Label */ 
#line 149
  tmp___1 = (uint8 )0;
#line 149
  e->fxp = tmp___1;
#line 149
  e->fxt = tmp___1;
#line 150
  goto switch_break___0;
  case_11___0: /* CIL Label */ 
#line 152
  e->fxp = (uint8 )(96 | (int )l);
#line 153
  goto switch_break___0;
  case_13: /* CIL Label */ 
  case_12: /* CIL Label */ 
#line 156
  tmp___2 = l;
#line 156
  e->fxp = tmp___2;
#line 156
  if ((int )tmp___2 == 0) {
#line 157
    e->fxp = (uint8 )((int )e->fxp + 1);
  }
#line 158
  e->fxp = (uint8 )((int )e->fxp | ((int )h << 4));
#line 159
  goto switch_break___0;
  case_14: /* CIL Label */ 
#line 161
  goto switch_break___0;
  switch_default: /* CIL Label */ 
#line 163
  tmp___3 = (uint8 )0;
#line 163
  e->fxp = tmp___3;
#line 163
  e->fxt = tmp___3;
  switch_break___0: /* CIL Label */ ;
  }
#line 165
  goto switch_break;
  case_132: /* CIL Label */ 
#line 167
  if ((int )e->fxp > 127) {
#line 167
    if ((int )e->fxp < 144) {
#line 168
      e->fxt = (uint8 )133;
#line 169
      e->fxp = (uint8 )(((int )e->fxp - 128) * 16);
    } else {
#line 171
      e->fxp = (uint8 )((int )e->fxp * 2);
    }
  } else {
#line 171
    e->fxp = (uint8 )((int )e->fxp * 2);
  }
#line 173
  goto switch_break;
  case_29: /* CIL Label */ 
#line 175
  if (! ((int )e->fxp & 15)) {
#line 176
    e->fxp = (uint8 )((int )e->fxp | 1);
  }
#line 177
  if (! (((int )e->fxp & 240) >> 4)) {
#line 178
    e->fxp = (uint8 )((int )e->fxp | 16);
  }
#line 179
  goto switch_break;
  case_255: /* CIL Label */ 
#line 181
  tmp___4 = (uint8 )0;
#line 181
  e->fxp = tmp___4;
#line 181
  e->fxt = tmp___4;
#line 182
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 184
  return;
}
}
#line 187 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/it_load.c"
static void xlat_volfx(struct xxm_event *event ) 
{ 
  int b___1 ;

  {
#line 191
  b___1 = (int )event->vol;
#line 192
  event->vol = (uint8 )0;
#line 194
  if (b___1 <= 64) {
#line 195
    event->vol = (uint8 )(b___1 + 1);
  } else
#line 196
  if (b___1 >= 65) {
#line 196
    if (b___1 <= 74) {
#line 197
      event->f2t = (uint8 )14;
#line 198
      event->f2p = (uint8 )((10 << 4) | (b___1 - 65));
    } else {
#line 196
      goto _L___5;
    }
  } else
  _L___5: /* CIL Label */ 
#line 199
  if (b___1 >= 75) {
#line 199
    if (b___1 <= 84) {
#line 200
      event->f2t = (uint8 )14;
#line 201
      event->f2p = (uint8 )((11 << 4) | (b___1 - 75));
    } else {
#line 199
      goto _L___4;
    }
  } else
  _L___4: /* CIL Label */ 
#line 202
  if (b___1 >= 85) {
#line 202
    if (b___1 <= 94) {
#line 203
      event->f2t = (uint8 )164;
#line 204
      event->f2p = (uint8 )((b___1 - 85) << 4);
    } else {
#line 202
      goto _L___3;
    }
  } else
  _L___3: /* CIL Label */ 
#line 205
  if (b___1 >= 95) {
#line 205
    if (b___1 <= 104) {
#line 206
      event->f2t = (uint8 )164;
#line 207
      event->f2p = (uint8 )(b___1 - 95);
    } else {
#line 205
      goto _L___2;
    }
  } else
  _L___2: /* CIL Label */ 
#line 208
  if (b___1 >= 105) {
#line 208
    if (b___1 <= 114) {
#line 209
      event->f2t = (uint8 )2;
#line 210
      event->f2p = (uint8 )((b___1 - 105) << 2);
    } else {
#line 208
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
#line 211
  if (b___1 >= 115) {
#line 211
    if (b___1 <= 124) {
#line 212
      event->f2t = (uint8 )1;
#line 213
      event->f2p = (uint8 )((b___1 - 115) << 2);
    } else {
#line 211
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 214
  if (b___1 >= 128) {
#line 214
    if (b___1 <= 192) {
#line 215
      if (b___1 == 192) {
#line 216
        b___1 = 191;
      }
#line 217
      event->f2t = (uint8 )8;
#line 218
      event->f2p = (uint8 )((b___1 - 128) << 2);
    } else {
#line 214
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 219
  if (b___1 >= 193) {
#line 219
    if (b___1 <= 202) {
#line 220
      event->f2t = (uint8 )3;
#line 221
      event->f2p = (uint8 )(1 << (b___1 - 193));
    }
  }
#line 228
  return;
}
}
#line 231 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/it_load.c"
static void fix_name(uint8 *s , int l ) 
{ 
  int i___3 ;

  {
#line 236
  l --;
#line 236
  i___3 = 0;
  {
#line 236
  while (1) {
    while_continue: /* CIL Label */ ;
#line 236
    if (! (i___3 < l)) {
#line 236
      goto while_break;
    }
#line 237
    if ((int )*(s + i___3) == 0) {
#line 238
      *(s + i___3) = (uint8 )' ';
    }
#line 236
    i___3 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 240
  i___3 --;
  {
#line 240
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 240
    if (i___3 >= 0) {
#line 240
      if (! ((int )*(s + i___3) == 32)) {
#line 240
        goto while_break___0;
      }
    } else {
#line 240
      goto while_break___0;
    }
#line 241
    if ((int )*(s + i___3) == 32) {
#line 242
      *(s + i___3) = (uint8 )0;
    }
#line 240
    i___3 --;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 244
  return;
}
}
#line 247 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/it_load.c"
static int it_load(struct xmp_context *ctx___0 , FILE *f , int const   start ) 
{ 
  struct xmp_player_context *p ;
  struct xmp_mod_context *m___0 ;
  struct xmp_options *o___0 ;
  int r ;
  int c___0 ;
  int i___3 ;
  int j ;
  int k ;
  int pat_len ;
  struct xxm_event *event ;
  struct xxm_event dummy___3 ;
  struct xxm_event lastevent[64] ;
  struct it_file_header ifh ;
  struct it_instrument1_header i1h ;
  struct it_instrument2_header i2h ;
  struct it_sample_header ish ;
  struct it_envelope env ;
  uint8 b___1 ;
  uint8 mask[64] ;
  int max_ch ;
  int flag ;
  int inst_map[120] ;
  int inst_rmap[108] ;
  char tracker_name[80] ;
  int mpt ;
  uint8 **tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  char const   *tmp___5 ;
  char const   *tmp___6 ;
  char const   *tmp___7 ;
  char *tmp___8 ;
  void *tmp___9 ;
  long tmp___10 ;
  void *tmp___11 ;
  void *tmp___12 ;
  void *tmp___13 ;
  void *tmp___14 ;
  void *tmp___15 ;
  void *tmp___16 ;
  void *tmp___17 ;
  uint8 tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  void *tmp___21 ;
  uint8 tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  void *tmp___25 ;
  uint8 tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  void *tmp___29 ;
  void *tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;
  int tmp___35 ;
  char const   *tmp___36 ;
  char const   *tmp___37 ;
  char const   *tmp___38 ;
  int tmp___39 ;
  int tmp___40 ;
  void *tmp___41 ;
  int tmp___42 ;
  void *tmp___43 ;
  int tmp___44 ;
  int tmp___45 ;
  int tmp___46 ;
  char const   *tmp___47 ;
  char const   *tmp___48 ;
  void *tmp___49 ;
  uint8 tmp___50 ;
  int tmp___51 ;
  int tmp___52 ;
  int tmp___53 ;
  size_t tmp___54 ;
  int cvt ;
  char *buf___1 ;
  void *tmp___55 ;
  void *tmp___56 ;
  void *tmp___57 ;
  void *tmp___58 ;
  void *tmp___59 ;
  uint16 tmp___60 ;
  uint16 tmp___61 ;
  int j___0 ;
  void *tmp___62 ;
  uint8 tmp___63 ;
  uint8 tmp___64 ;
  uint8 tmp___65 ;
  void *__cil_tmp99 ;
  void *__cil_tmp100 ;
  int __cil_tmp101 ;
  void *__cil_tmp102 ;
  void *__cil_tmp103 ;
  void *__cil_tmp104 ;
  void *__cil_tmp105 ;
  void *__cil_tmp106 ;
  void *__cil_tmp107 ;
  void *__cil_tmp108 ;
  void *__cil_tmp109 ;
  void *__cil_tmp110 ;
  void *__cil_tmp111 ;
  void *__cil_tmp112 ;
  void *__cil_tmp113 ;
  void *__cil_tmp114 ;
  void *__cil_tmp115 ;
  void *__cil_tmp116 ;
  void *__cil_tmp117 ;
  void *__cil_tmp118 ;
  void *__cil_tmp119 ;
  void *__cil_tmp120 ;
  void *__cil_tmp121 ;
  void *__cil_tmp122 ;
  void *__cil_tmp123 ;
  void *__cil_tmp124 ;
  int __cil_tmp125 ;
  void *__cil_tmp126 ;
  void *__cil_tmp127 ;
  void *__cil_tmp128 ;
  void *__cil_tmp129 ;
  void *__cil_tmp130 ;
  char *__cil_tmp131 ;
  char *__cil_tmp132 ;
  char *__cil_tmp133 ;
  char *__cil_tmp134 ;
  char *__cil_tmp135 ;
  char *__cil_tmp136 ;
  char *__cil_tmp137 ;
  char *__cil_tmp138 ;
  char *__cil_tmp139 ;
  char *__cil_tmp140 ;
  char *__cil_tmp141 ;
  char *__cil_tmp142 ;
  char *__cil_tmp143 ;
  char *__cil_tmp144 ;
  char *__cil_tmp145 ;
  char *__cil_tmp146 ;
  char *__cil_tmp147 ;
  char *__cil_tmp148 ;
  char *__cil_tmp149 ;
  char *__cil_tmp150 ;
  char *__cil_tmp151 ;
  char *__cil_tmp152 ;
  char *__cil_tmp153 ;
  char *__cil_tmp154 ;
  char *__cil_tmp155 ;
  char *__cil_tmp156 ;
  char *__cil_tmp157 ;
  char *__cil_tmp158 ;
  char *__cil_tmp159 ;
  char *__cil_tmp160 ;
  char *__cil_tmp161 ;
  char *__cil_tmp162 ;
  char *__cil_tmp163 ;
  char *__cil_tmp164 ;
  char *__cil_tmp165 ;
  char *__cil_tmp166 ;
  char *__cil_tmp167 ;
  char *__cil_tmp168 ;
  char *__cil_tmp169 ;
  char *__cil_tmp170 ;
  char *__cil_tmp171 ;
  char *__cil_tmp172 ;
  char *__cil_tmp173 ;
  char *__cil_tmp174 ;
  char *__cil_tmp175 ;
  char *__cil_tmp176 ;
  char *__cil_tmp177 ;
  char *__cil_tmp178 ;

  {
#line 249
  p = & ctx___0->p;
#line 250
  m___0 = & p->m;
#line 251
  o___0 = & ctx___0->o;
#line 263
  mpt = 0;
  {
#line 265
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 265
    fseek(f, (long )start, 0);
#line 265
    tmp = (uint8 **)((void *)0);
#line 265
    m___0->med_wav_table = tmp;
#line 265
    m___0->med_vol_table = tmp;
#line 265
    set_xxh_defaults(m___0->xxh);
    }
#line 265
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 268
  read32b(f);
#line 270
  fread((void */* __restrict  */)(& ifh.name), (size_t )26, (size_t )1, (FILE */* __restrict  */)f);
#line 271
  fread((void */* __restrict  */)(& ifh.rsvd1), (size_t )2, (size_t )1, (FILE */* __restrict  */)f);
#line 273
  ifh.ordnum = read16l(f);
#line 274
  ifh.insnum = read16l(f);
#line 275
  ifh.smpnum = read16l(f);
#line 276
  ifh.patnum = read16l(f);
#line 278
  ifh.cwt = read16l(f);
#line 279
  ifh.cmwt = read16l(f);
#line 280
  ifh.flags = read16l(f);
#line 281
  ifh.special = read16l(f);
#line 283
  ifh.gv = read8(f);
#line 284
  ifh.mv = read8(f);
#line 285
  ifh.is = read8(f);
#line 286
  ifh.it = read8(f);
#line 287
  ifh.sep = read8(f);
#line 288
  ifh.zero = read8(f);
#line 290
  ifh.msglen = read16l(f);
#line 291
  ifh.msgofs = read32l(f);
#line 293
  fread((void */* __restrict  */)(& ifh.rsvd2), (size_t )4, (size_t )1, (FILE */* __restrict  */)f);
#line 294
  fread((void */* __restrict  */)(& ifh.chpan), (size_t )64, (size_t )1, (FILE */* __restrict  */)f);
#line 295
  fread((void */* __restrict  */)(& ifh.chvol), (size_t )64, (size_t )1, (FILE */* __restrict  */)f);
#line 297
  strcpy((char */* __restrict  */)(m___0->name), (char const   */* __restrict  */)((char *)(ifh.name)));
#line 298
  (m___0->xxh)->len = (int )ifh.ordnum;
#line 299
  (m___0->xxh)->ins = (int )ifh.insnum;
#line 300
  (m___0->xxh)->smp = (int )ifh.smpnum;
#line 301
  (m___0->xxh)->pat = (int )ifh.patnum;
  }
#line 302
  if ((m___0->xxh)->ins) {
    {
#line 302
    tmp___0 = calloc((size_t )4, (size_t )(m___0->xxh)->ins);
#line 302
    pp_ins___0 = (uint32 *)tmp___0;
    }
  } else {
#line 302
    pp_ins___0 = (uint32 *)((void *)0);
  }
  {
#line 303
  tmp___1 = calloc((size_t )4, (size_t )(m___0->xxh)->smp);
#line 303
  pp_smp = (uint32 *)tmp___1;
#line 304
  tmp___2 = calloc((size_t )4, (size_t )(m___0->xxh)->pat);
#line 304
  pp_pat___0 = (uint32 *)tmp___2;
#line 305
  (m___0->xxh)->tpo = (int )ifh.is;
#line 306
  (m___0->xxh)->bpm = (int )ifh.it;
  }
#line 307
  if ((int )ifh.flags & 8) {
#line 307
    (m___0->xxh)->flg = 1;
  } else {
#line 307
    (m___0->xxh)->flg = 0;
  }
#line 308
  if ((int )ifh.flags & 4) {
#line 308
    if ((int )ifh.cmwt >= 512) {
#line 308
      tmp___3 = 4;
    } else {
#line 308
      tmp___3 = 0;
    }
  } else {
#line 308
    tmp___3 = 0;
  }
#line 308
  (m___0->xxh)->flg |= tmp___3;
#line 311
  (m___0->xxh)->chn = 64;
#line 313
  i___3 = 0;
  {
#line 313
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 313
    if (! (i___3 < 64)) {
#line 313
      goto while_break___0;
    }
#line 314
    if ((int )ifh.chpan[i___3] == 100) {
#line 315
      ifh.chpan[i___3] = (uint8 )32;
    }
#line 317
    if ((int )ifh.chpan[i___3] & 128) {
#line 318
      ifh.chvol[i___3] = (uint8 )0;
#line 319
      m___0->xxc[i___3].flg |= 4;
    }
#line 322
    if ((int )ifh.flags & 1) {
#line 323
      m___0->xxc[i___3].pan = (int )ifh.chpan[i___3] * 128 >> 5;
#line 324
      if (m___0->xxc[i___3].pan > 255) {
#line 325
        m___0->xxc[i___3].pan = 255;
      }
    } else {
#line 327
      m___0->xxc[i___3].pan = 128;
    }
#line 330
    m___0->xxc[i___3].vol = (int )ifh.chvol[i___3];
#line 313
    i___3 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 332
  fread((void */* __restrict  */)(m___0->xxo), (size_t )1, (size_t )(m___0->xxh)->len,
        (FILE */* __restrict  */)f);
#line 333
  clean_s3m_seq(m___0->xxh, m___0->xxo);
  }
#line 335
  if ((int )ifh.flags & 16) {
#line 335
    new_fx = 0;
  } else {
#line 335
    new_fx = 1;
  }
#line 338
  i___3 = 0;
  {
#line 338
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 338
    if (! (i___3 < (m___0->xxh)->len - 1)) {
#line 338
      goto while_break___1;
    }
#line 339
    if ((int )m___0->xxo[i___3] == 254) {
      {
#line 340
      memmove((void *)(& m___0->xxo[i___3]), (void const   *)(& m___0->xxo[i___3 + 1]),
              (size_t )(((m___0->xxh)->len - i___3) - 1));
#line 341
      ((m___0->xxh)->len) --;
      }
    }
#line 338
    i___3 ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 344
  i___3 = 0;
  {
#line 344
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 344
    if (! (i___3 < (m___0->xxh)->ins)) {
#line 344
      goto while_break___2;
    }
    {
#line 345
    *(pp_ins___0 + i___3) = read32l(f);
#line 344
    i___3 ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 346
  i___3 = 0;
  {
#line 346
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 346
    if (! (i___3 < (m___0->xxh)->smp)) {
#line 346
      goto while_break___3;
    }
    {
#line 347
    *(pp_smp + i___3) = read32l(f);
#line 346
    i___3 ++;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
#line 348
  i___3 = 0;
  {
#line 348
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 348
    if (! (i___3 < (m___0->xxh)->pat)) {
#line 348
      goto while_break___4;
    }
    {
#line 349
    *(pp_pat___0 + i___3) = read32l(f);
#line 348
    i___3 ++;
    }
  }
  while_break___4: /* CIL Label */ ;
  }
#line 351
  m___0->c4rate = 8363;
#line 352
  m___0->quirk |= (1 << 12) | (1 << 2);
  {
#line 357
  if ((int )ifh.cwt >> 8 == 0) {
#line 357
    goto case_0;
  }
#line 361
  if ((int )ifh.cwt >> 8 == 2) {
#line 361
    goto case_2;
  }
#line 361
  if ((int )ifh.cwt >> 8 == 1) {
#line 361
    goto case_2;
  }
#line 378
  if ((int )ifh.cwt >> 8 == 8) {
#line 378
    goto case_8;
  }
#line 385
  if ((int )ifh.cwt >> 8 == 16) {
#line 385
    goto case_16;
  }
#line 389
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 358
  sprintf((char */* __restrict  */)(tracker_name), (char const   */* __restrict  */)"unmo3");
  }
#line 359
  goto switch_break;
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
#line 362
  if ((int )ifh.cmwt == 512) {
#line 362
    if ((int )ifh.cwt == 535) {
      {
#line 363
      sprintf((char */* __restrict  */)(tracker_name), (char const   */* __restrict  */)"ModPlug Tracker 1.16");
      }
#line 365
      if ((int )ifh.flags & 4) {
#line 365
        ifh.cmwt = (uint16 )532;
      } else {
#line 365
        ifh.cmwt = (uint16 )256;
      }
#line 366
      mpt = 1;
    } else {
#line 362
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 367
  if ((int )ifh.cwt == 534) {
    {
#line 368
    sprintf((char */* __restrict  */)(tracker_name), (char const   */* __restrict  */)"Impulse Tracker 2.14v3");
    }
  } else
#line 369
  if ((int )ifh.cwt == 535) {
    {
#line 370
    sprintf((char */* __restrict  */)(tracker_name), (char const   */* __restrict  */)"Impulse Tracker 2.14v5");
    }
  } else
#line 371
  if ((int )ifh.cwt == 532) {
    {
#line 371
    tmp___4 = memcmp((void const   *)(ifh.rsvd2), (void const   *)"CHBI", (size_t )4);
    }
#line 371
    if (tmp___4) {
      {
#line 374
      sprintf((char */* __restrict  */)(tracker_name), (char const   */* __restrict  */)"Impulse Tracker %d.%02x",
              ((int )ifh.cwt & 3840) >> 8, (int )ifh.cwt & 255);
      }
    } else {
      {
#line 372
      sprintf((char */* __restrict  */)(tracker_name), (char const   */* __restrict  */)"Chibi Tracker");
      }
    }
  } else {
    {
#line 374
    sprintf((char */* __restrict  */)(tracker_name), (char const   */* __restrict  */)"Impulse Tracker %d.%02x",
            ((int )ifh.cwt & 3840) >> 8, (int )ifh.cwt & 255);
    }
  }
#line 377
  goto switch_break;
  case_8: /* CIL Label */ 
#line 379
  if ((int )ifh.cwt == 2184) {
    {
#line 380
    sprintf((char */* __restrict  */)(tracker_name), (char const   */* __restrict  */)"ModPlug Tracker >= 1.17");
    }
  } else {
    {
#line 382
    sprintf((char */* __restrict  */)(tracker_name), (char const   */* __restrict  */)"unknown (%04x)",
            (int )ifh.cwt);
    }
  }
#line 384
  goto switch_break;
  case_16: /* CIL Label */ 
  {
#line 386
  sprintf((char */* __restrict  */)(tracker_name), (char const   */* __restrict  */)"Schism Tracker %d.%02x",
          ((int )ifh.cwt & 3840) >> 8, (int )ifh.cwt & 255);
  }
#line 388
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 390
  sprintf((char */* __restrict  */)(tracker_name), (char const   */* __restrict  */)"unknown (%04x)",
          (int )ifh.cwt);
  }
  switch_break: /* CIL Label */ ;
  }
  {
#line 393
  sprintf((char */* __restrict  */)(m___0->type), (char const   */* __restrict  */)"IMPM %d.%02x (%s)",
          (int )ifh.cmwt >> 8, (int )ifh.cmwt & 255, tracker_name);
  }
  {
#line 396
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 396
    if (m___0->verbosity) {
#line 396
      if (m___0->name[0]) {
        {
#line 396
        report((char *)"Module title   : %s\n", m___0->name);
        }
      }
#line 396
      if (m___0->type[0]) {
        {
#line 396
        report((char *)"Module type    : %s\n", m___0->type);
        }
      }
#line 396
      if (m___0->author[0]) {
        {
#line 396
        report((char *)"Author name    : %s\n", m___0->author);
        }
      }
#line 396
      if ((m___0->xxh)->len) {
        {
#line 396
        report((char *)"Module length  : %d patterns\n", (m___0->xxh)->len);
        }
      }
    }
#line 396
    goto while_break___5;
  }
  while_break___5: /* CIL Label */ ;
  }
#line 398
  if ((int )ifh.flags & 16) {
#line 398
    tmp___5 = "old";
  } else {
#line 398
    tmp___5 = "IT";
  }
#line 398
  if ((int )ifh.flags & 4) {
#line 398
    if ((int )ifh.cmwt >= 512) {
#line 398
      tmp___6 = "new";
    } else {
#line 398
      tmp___6 = "old";
    }
#line 398
    tmp___7 = tmp___6;
  } else {
#line 398
    tmp___7 = "sample";
  }
  {
#line 398
  reportv(ctx___0, 0, (char *)"Instr/FX mode  : %s/%s", tmp___7, tmp___5);
  }
#line 403
  if (~ ((int )ifh.flags) & 4) {
#line 404
    (m___0->xxh)->ins = (m___0->xxh)->smp;
  }
#line 406
  if ((int )ifh.special & 1) {
    {
#line 407
    tmp___9 = malloc((size_t )((int )ifh.msglen + 1));
#line 407
    tmp___8 = (char *)tmp___9;
#line 407
    m___0->comment = tmp___8;
    }
#line 407
    if ((unsigned long )tmp___8 == (unsigned long )((void *)0)) {
#line 408
      return (-1);
    }
    {
#line 409
    tmp___10 = ftell(f);
#line 409
    i___3 = (int )tmp___10;
#line 410
    fseek(f, (long )((uint32 )start + ifh.msgofs), 0);
#line 411
    reportv(ctx___0, 2, (char *)"\nMessage length : %d\n| ", (int )ifh.msglen);
#line 412
    j = 0;
    }
    {
#line 412
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 412
      if (! (j < (int )ifh.msglen)) {
#line 412
        goto while_break___6;
      }
      {
#line 413
      b___1 = read8(f);
      }
#line 414
      if ((int )b___1 == 13) {
#line 415
        b___1 = (uint8 )'\n';
      }
#line 416
      if ((int )b___1 < 32) {
#line 416
        goto _L___0;
      } else
#line 416
      if ((int )b___1 > 127) {
        _L___0: /* CIL Label */ 
#line 416
        if ((int )b___1 != 10) {
#line 416
          if ((int )b___1 != 9) {
#line 417
            b___1 = (uint8 )'.';
          }
        }
      }
      {
#line 418
      *(m___0->comment + j) = (char )b___1;
#line 419
      reportv(ctx___0, 2, (char *)"%c", (int )b___1);
      }
#line 420
      if ((int )b___1 == 10) {
        {
#line 421
        reportv(ctx___0, 2, (char *)"| ");
        }
      }
#line 412
      j ++;
    }
    while_break___6: /* CIL Label */ ;
    }
    {
#line 423
    *(m___0->comment + j) = (char)0;
#line 425
    fseek(f, (long )i___3, 0);
    }
  }
  {
#line 428
  while (1) {
    while_continue___7: /* CIL Label */ ;
    {
#line 428
    tmp___11 = calloc((size_t )sizeof(struct xxm_instrument_header ), (size_t )(m___0->xxh)->ins);
#line 428
    m___0->xxih = (struct xxm_instrument_header *)tmp___11;
#line 428
    tmp___12 = calloc((size_t )sizeof(struct xxm_instrument_map ), (size_t )(m___0->xxh)->ins);
#line 428
    m___0->xxim = (struct xxm_instrument_map *)tmp___12;
#line 428
    tmp___13 = calloc((size_t )sizeof(struct xxm_instrument *), (size_t )(m___0->xxh)->ins);
#line 428
    m___0->xxi = (struct xxm_instrument **)tmp___13;
    }
#line 428
    if ((m___0->xxh)->smp) {
      {
#line 428
      tmp___14 = calloc((size_t )sizeof(struct xxm_sample ), (size_t )(m___0->xxh)->smp);
#line 428
      m___0->xxs = (struct xxm_sample *)tmp___14;
      }
    }
    {
#line 428
    tmp___15 = calloc((size_t )sizeof(uint16 *), (size_t )(m___0->xxh)->ins);
#line 428
    m___0->xxae = (uint16 **)tmp___15;
#line 428
    tmp___16 = calloc((size_t )sizeof(uint16 *), (size_t )(m___0->xxh)->ins);
#line 428
    m___0->xxpe = (uint16 **)tmp___16;
#line 428
    tmp___17 = calloc((size_t )sizeof(uint16 *), (size_t )(m___0->xxh)->ins);
#line 428
    m___0->xxfe = (uint16 **)tmp___17;
    }
#line 428
    goto while_break___7;
  }
  while_break___7: /* CIL Label */ ;
  }
#line 430
  if ((m___0->xxh)->ins) {
#line 430
    if (m___0->verbosity > 0) {
#line 430
      if ((int )ifh.flags & 4) {
        {
#line 431
        report((char *)"\nInstruments    : %d ", (m___0->xxh)->ins);
        }
#line 432
        if (m___0->verbosity > 1) {
#line 433
          if ((int )ifh.cmwt >= 512) {
            {
#line 434
            report((char *)"\n     Instrument name            NNA  DCT  DCA  Fade  GbV Pan RV Env NSm FC FR");
            }
          } else {
            {
#line 437
            report((char *)"\n     Instrument name            NNA  DNC  Fade  VolEnv NSm");
            }
          }
        }
      }
    }
  }
#line 442
  i___3 = 0;
  {
#line 442
  while (1) {
    while_continue___8: /* CIL Label */ ;
#line 442
    if (! (i___3 < (m___0->xxh)->ins)) {
#line 442
      goto while_break___8;
    }
#line 449
    if ((int )ifh.flags & 4) {
#line 449
      if ((int )ifh.cmwt >= 512) {
        {
#line 451
        fseek(f, (long )((uint32 )start + *(pp_ins___0 + i___3)), 0);
#line 453
        i2h.magic = read32b(f);
#line 454
        fread((void */* __restrict  */)(& i2h.dosname), (size_t )12, (size_t )1, (FILE */* __restrict  */)f);
#line 455
        i2h.zero = read8(f);
#line 456
        i2h.nna = read8(f);
#line 457
        i2h.dct = read8(f);
#line 458
        i2h.dca = read8(f);
#line 459
        i2h.fadeout = read16l(f);
#line 461
        i2h.pps = read8(f);
#line 462
        i2h.ppc = read8(f);
#line 463
        i2h.gbv = read8(f);
#line 464
        i2h.dfp = read8(f);
#line 465
        i2h.rv = read8(f);
#line 466
        i2h.rp = read8(f);
#line 467
        i2h.trkvers = read16l(f);
#line 469
        i2h.nos = read8(f);
#line 470
        i2h.rsvd1 = read8(f);
#line 471
        fread((void */* __restrict  */)(& i2h.name), (size_t )26, (size_t )1, (FILE */* __restrict  */)f);
#line 473
        fix_name(i2h.name, 26);
#line 475
        i2h.ifc = read8(f);
#line 476
        i2h.ifr = read8(f);
#line 477
        i2h.mch = read8(f);
#line 478
        i2h.mpr = read8(f);
#line 479
        i2h.mbnk = read16l(f);
#line 480
        fread((void */* __restrict  */)(& i2h.keys), (size_t )240, (size_t )1, (FILE */* __restrict  */)f);
#line 482
        copy_adjust((m___0->xxih + i___3)->name, i2h.name, 24);
#line 483
        (m___0->xxih + i___3)->rls = (int )i2h.fadeout << 6;
#line 514
        env.flg = read8(f);
#line 514
        env.num = read8(f);
#line 514
        env.lpb = read8(f);
#line 514
        env.lpe = read8(f);
#line 514
        env.slb = read8(f);
#line 514
        env.sle = read8(f);
#line 514
        j = 0;
        }
        {
#line 514
        while (1) {
          while_continue___9: /* CIL Label */ ;
#line 514
          if (! (j < 25)) {
#line 514
            goto while_break___9;
          }
          {
#line 514
          tmp___18 = read8(f);
#line 514
          env.node[j].y = (int8 )tmp___18;
#line 514
          env.node[j].x = read16l(f);
#line 514
          j ++;
          }
        }
        while_break___9: /* CIL Label */ ;
        }
        {
#line 514
        env.unused = read8(f);
        }
#line 514
        if ((int )env.flg & 1) {
#line 514
          (m___0->xxih + i___3)->aei.flg = 1;
        } else {
#line 514
          (m___0->xxih + i___3)->aei.flg = 0;
        }
#line 514
        if ((int )env.flg & 2) {
#line 514
          tmp___19 = 4;
        } else {
#line 514
          tmp___19 = 0;
        }
#line 514
        (m___0->xxih + i___3)->aei.flg |= tmp___19;
#line 514
        if ((int )env.flg & 4) {
#line 514
          tmp___20 = 2;
        } else {
#line 514
          tmp___20 = 0;
        }
#line 514
        (m___0->xxih + i___3)->aei.flg |= tmp___20;
#line 514
        (m___0->xxih + i___3)->aei.npt = (int )env.num;
#line 514
        (m___0->xxih + i___3)->aei.sus = (int )env.slb;
#line 514
        (m___0->xxih + i___3)->aei.sue = (int )env.sle;
#line 514
        (m___0->xxih + i___3)->aei.lps = (int )env.lpb;
#line 514
        (m___0->xxih + i___3)->aei.lpe = (int )env.lpe;
#line 514
        if (env.num) {
          {
#line 514
          tmp___21 = calloc((size_t )4, (size_t )env.num);
#line 514
          *(m___0->xxae + i___3) = (uint16 *)tmp___21;
          }
        }
#line 514
        j = 0;
        {
#line 514
        while (1) {
          while_continue___10: /* CIL Label */ ;
#line 514
          if (! (j < (int )env.num)) {
#line 514
            goto while_break___10;
          }
#line 514
          *(*(m___0->xxae + i___3) + j * 2) = env.node[j].x;
#line 514
          *(*(m___0->xxae + i___3) + (j * 2 + 1)) = (uint16 )env.node[j].y;
#line 514
          j ++;
        }
        while_break___10: /* CIL Label */ ;
        }
        {
#line 515
        env.flg = read8(f);
#line 515
        env.num = read8(f);
#line 515
        env.lpb = read8(f);
#line 515
        env.lpe = read8(f);
#line 515
        env.slb = read8(f);
#line 515
        env.sle = read8(f);
#line 515
        j = 0;
        }
        {
#line 515
        while (1) {
          while_continue___11: /* CIL Label */ ;
#line 515
          if (! (j < 25)) {
#line 515
            goto while_break___11;
          }
          {
#line 515
          tmp___22 = read8(f);
#line 515
          env.node[j].y = (int8 )tmp___22;
#line 515
          env.node[j].x = read16l(f);
#line 515
          j ++;
          }
        }
        while_break___11: /* CIL Label */ ;
        }
        {
#line 515
        env.unused = read8(f);
        }
#line 515
        if ((int )env.flg & 1) {
#line 515
          (m___0->xxih + i___3)->pei.flg = 1;
        } else {
#line 515
          (m___0->xxih + i___3)->pei.flg = 0;
        }
#line 515
        if ((int )env.flg & 2) {
#line 515
          tmp___23 = 4;
        } else {
#line 515
          tmp___23 = 0;
        }
#line 515
        (m___0->xxih + i___3)->pei.flg |= tmp___23;
#line 515
        if ((int )env.flg & 4) {
#line 515
          tmp___24 = 2;
        } else {
#line 515
          tmp___24 = 0;
        }
#line 515
        (m___0->xxih + i___3)->pei.flg |= tmp___24;
#line 515
        (m___0->xxih + i___3)->pei.npt = (int )env.num;
#line 515
        (m___0->xxih + i___3)->pei.sus = (int )env.slb;
#line 515
        (m___0->xxih + i___3)->pei.sue = (int )env.sle;
#line 515
        (m___0->xxih + i___3)->pei.lps = (int )env.lpb;
#line 515
        (m___0->xxih + i___3)->pei.lpe = (int )env.lpe;
#line 515
        if (env.num) {
          {
#line 515
          tmp___25 = calloc((size_t )4, (size_t )env.num);
#line 515
          *(m___0->xxpe + i___3) = (uint16 *)tmp___25;
          }
        }
#line 515
        j = 0;
        {
#line 515
        while (1) {
          while_continue___12: /* CIL Label */ ;
#line 515
          if (! (j < (int )env.num)) {
#line 515
            goto while_break___12;
          }
#line 515
          *(*(m___0->xxpe + i___3) + j * 2) = env.node[j].x;
#line 515
          *(*(m___0->xxpe + i___3) + (j * 2 + 1)) = (uint16 )env.node[j].y;
#line 515
          j ++;
        }
        while_break___12: /* CIL Label */ ;
        }
        {
#line 516
        env.flg = read8(f);
#line 516
        env.num = read8(f);
#line 516
        env.lpb = read8(f);
#line 516
        env.lpe = read8(f);
#line 516
        env.slb = read8(f);
#line 516
        env.sle = read8(f);
#line 516
        j = 0;
        }
        {
#line 516
        while (1) {
          while_continue___13: /* CIL Label */ ;
#line 516
          if (! (j < 25)) {
#line 516
            goto while_break___13;
          }
          {
#line 516
          tmp___26 = read8(f);
#line 516
          env.node[j].y = (int8 )tmp___26;
#line 516
          env.node[j].x = read16l(f);
#line 516
          j ++;
          }
        }
        while_break___13: /* CIL Label */ ;
        }
        {
#line 516
        env.unused = read8(f);
        }
#line 516
        if ((int )env.flg & 1) {
#line 516
          (m___0->xxih + i___3)->fei.flg = 1;
        } else {
#line 516
          (m___0->xxih + i___3)->fei.flg = 0;
        }
#line 516
        if ((int )env.flg & 2) {
#line 516
          tmp___27 = 4;
        } else {
#line 516
          tmp___27 = 0;
        }
#line 516
        (m___0->xxih + i___3)->fei.flg |= tmp___27;
#line 516
        if ((int )env.flg & 4) {
#line 516
          tmp___28 = 2;
        } else {
#line 516
          tmp___28 = 0;
        }
#line 516
        (m___0->xxih + i___3)->fei.flg |= tmp___28;
#line 516
        (m___0->xxih + i___3)->fei.npt = (int )env.num;
#line 516
        (m___0->xxih + i___3)->fei.sus = (int )env.slb;
#line 516
        (m___0->xxih + i___3)->fei.sue = (int )env.sle;
#line 516
        (m___0->xxih + i___3)->fei.lps = (int )env.lpb;
#line 516
        (m___0->xxih + i___3)->fei.lpe = (int )env.lpe;
#line 516
        if (env.num) {
          {
#line 516
          tmp___29 = calloc((size_t )4, (size_t )env.num);
#line 516
          *(m___0->xxfe + i___3) = (uint16 *)tmp___29;
          }
        }
#line 516
        j = 0;
        {
#line 516
        while (1) {
          while_continue___14: /* CIL Label */ ;
#line 516
          if (! (j < (int )env.num)) {
#line 516
            goto while_break___14;
          }
#line 516
          *(*(m___0->xxfe + i___3) + j * 2) = env.node[j].x;
#line 516
          *(*(m___0->xxfe + i___3) + (j * 2 + 1)) = (uint16 )env.node[j].y;
#line 516
          j ++;
        }
        while_break___14: /* CIL Label */ ;
        }
#line 518
        if ((m___0->xxih + i___3)->pei.flg & 1) {
#line 519
          j = 0;
          {
#line 519
          while (1) {
            while_continue___15: /* CIL Label */ ;
#line 519
            if (! (j < (m___0->xxih + i___3)->pei.npt)) {
#line 519
              goto while_break___15;
            }
#line 520
            *(*(m___0->xxpe + i___3) + (j * 2 + 1)) = (uint16 )((int )*(*(m___0->xxpe + i___3) + (j * 2 + 1)) + 32);
#line 519
            j ++;
          }
          while_break___15: /* CIL Label */ ;
          }
        }
#line 522
        if ((int )env.flg & 128) {
#line 523
          (m___0->xxih + i___3)->fei.flg |= 8;
#line 524
          j = 0;
          {
#line 524
          while (1) {
            while_continue___16: /* CIL Label */ ;
#line 524
            if (! (j < (int )env.num)) {
#line 524
              goto while_break___16;
            }
#line 525
            *(*(m___0->xxfe + i___3) + (j * 2 + 1)) = (uint16 )((int )*(*(m___0->xxfe + i___3) + (j * 2 + 1)) + 32);
#line 526
            *(*(m___0->xxfe + i___3) + (j * 2 + 1)) = (uint16 )((int )*(*(m___0->xxfe + i___3) + (j * 2 + 1)) * 4);
#line 524
            j ++;
          }
          while_break___16: /* CIL Label */ ;
          }
        } else {
#line 530
          j = 0;
          {
#line 530
          while (1) {
            while_continue___17: /* CIL Label */ ;
#line 530
            if (! (j < (int )env.num)) {
#line 530
              goto while_break___17;
            }
#line 531
            *(*(m___0->xxfe + i___3) + (j * 2 + 1)) = (uint16 )((int )*(*(m___0->xxfe + i___3) + (j * 2 + 1)) * 50);
#line 530
            j ++;
          }
          while_break___17: /* CIL Label */ ;
          }
        }
#line 535
        j = 0;
        {
#line 535
        while (1) {
          while_continue___18: /* CIL Label */ ;
#line 535
          if (! (j < 108)) {
#line 535
            goto while_break___18;
          }
#line 536
          inst_map[j] = -1;
#line 535
          j ++;
        }
        while_break___18: /* CIL Label */ ;
        }
#line 538
        j = 0;
#line 538
        k = j;
        {
#line 538
        while (1) {
          while_continue___19: /* CIL Label */ ;
#line 538
          if (! (j < 108)) {
#line 538
            goto while_break___19;
          }
#line 539
          c___0 = (int )i2h.keys[25 + j * 2] - 1;
#line 540
          if (c___0 < 0) {
#line 541
            (m___0->xxim + i___3)->ins[j] = (uint8 )255;
#line 542
            (m___0->xxim + i___3)->xpo[j] = (int8 )0;
#line 543
            goto __Cont;
          }
#line 545
          if (inst_map[c___0] == -1) {
#line 546
            inst_map[c___0] = k;
#line 547
            inst_rmap[k] = c___0;
#line 548
            k ++;
          }
#line 550
          (m___0->xxim + i___3)->ins[j] = (uint8 )inst_map[c___0];
#line 551
          (m___0->xxim + i___3)->xpo[j] = (int8 )((int )i2h.keys[24 + j * 2] - (j + 12));
          __Cont: /* CIL Label */ 
#line 538
          j ++;
        }
        while_break___19: /* CIL Label */ ;
        }
#line 554
        (m___0->xxih + i___3)->nsm = k;
#line 555
        (m___0->xxih + i___3)->vol = (int )i2h.gbv >> 1;
#line 557
        if (k) {
          {
#line 558
          tmp___30 = calloc((size_t )sizeof(struct xxm_instrument ), (size_t )k);
#line 558
          *(m___0->xxi + i___3) = (struct xxm_instrument *)tmp___30;
#line 559
          j = 0;
          }
          {
#line 559
          while (1) {
            while_continue___20: /* CIL Label */ ;
#line 559
            if (! (j < k)) {
#line 559
              goto while_break___20;
            }
#line 560
            (*(m___0->xxi + i___3) + j)->sid = inst_rmap[j];
#line 561
            (*(m___0->xxi + i___3) + j)->nna = (int )i2h.nna;
#line 562
            (*(m___0->xxi + i___3) + j)->dct = (int )i2h.dct;
#line 563
            (*(m___0->xxi + i___3) + j)->dca = dca2nna[(int )i2h.dca & 3];
#line 564
            if ((int )i2h.dfp & 128) {
#line 564
              (*(m___0->xxi + i___3) + j)->pan = 128;
            } else {
#line 564
              (*(m___0->xxi + i___3) + j)->pan = (int )i2h.dfp * 4;
            }
#line 565
            (*(m___0->xxi + i___3) + j)->ifc = (int )i2h.ifc;
#line 566
            (*(m___0->xxi + i___3) + j)->ifr = (int )i2h.ifr;
#line 559
            j ++;
          }
          while_break___20: /* CIL Label */ ;
          }
        }
#line 570
        if ((int )env.flg & 1) {
#line 570
          if ((int )env.flg & 128) {
#line 570
            tmp___31 = 'F';
          } else {
#line 570
            tmp___31 = 'P';
          }
#line 570
          tmp___32 = tmp___31;
        } else {
#line 570
          tmp___32 = '-';
        }
#line 570
        if ((m___0->xxih + i___3)->pei.flg & 1) {
#line 570
          tmp___33 = 'P';
        } else {
#line 570
          tmp___33 = '-';
        }
#line 570
        if ((m___0->xxih + i___3)->aei.flg & 1) {
#line 570
          tmp___34 = 'V';
        } else {
#line 570
          tmp___34 = '-';
        }
#line 570
        if ((int )i2h.dfp & 128) {
#line 570
          tmp___35 = 128;
        } else {
#line 570
          tmp___35 = (int )i2h.dfp * 4;
        }
#line 570
        if ((int )i2h.dca < 3) {
#line 570
          tmp___36 = (char const   *)nna[dca2nna[i2h.dca]];
        } else {
#line 570
          tmp___36 = "none";
        }
#line 570
        if ((int )i2h.dct < 4) {
#line 570
          tmp___37 = (char const   *)dct[i2h.dct];
        } else {
#line 570
          tmp___37 = "none";
        }
#line 570
        if ((int )i2h.nna < 4) {
#line 570
          tmp___38 = (char const   *)nna[i2h.nna];
        } else {
#line 570
          tmp___38 = "none";
        }
        {
#line 570
        reportv(ctx___0, 1, (char *)"\n[%2X] %-26.26s %-4.4s %-4.4s %-4.4s %4d %4d  %2x %02x %c%c%c %3d %02x %02x ",
                i___3, i2h.name, tmp___38, tmp___37, tmp___36, (int )i2h.fadeout,
                (int )i2h.gbv, tmp___35, (int )i2h.rv, tmp___34, tmp___33, tmp___32,
                (m___0->xxih + i___3)->nsm, (int )i2h.ifc, (int )i2h.ifr);
#line 588
        reportv(ctx___0, 0, (char *)".");
        }
      } else {
#line 449
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */ 
#line 590
    if ((int )ifh.flags & 4) {
      {
#line 592
      fseek(f, (long )((uint32 )start + *(pp_ins___0 + i___3)), 0);
#line 594
      i1h.magic = read32b(f);
#line 595
      fread((void */* __restrict  */)(& i1h.dosname), (size_t )12, (size_t )1, (FILE */* __restrict  */)f);
#line 597
      i1h.zero = read8(f);
#line 598
      i1h.flags = read8(f);
#line 599
      i1h.vls = read8(f);
#line 600
      i1h.vle = read8(f);
#line 601
      i1h.sls = read8(f);
#line 602
      i1h.sle = read8(f);
#line 603
      i1h.rsvd1 = read16l(f);
#line 604
      i1h.fadeout = read16l(f);
#line 606
      i1h.nna = read8(f);
#line 607
      i1h.dnc = read8(f);
#line 608
      i1h.trkvers = read16l(f);
#line 609
      i1h.nos = read8(f);
#line 610
      i1h.rsvd2 = read8(f);
#line 612
      fread((void */* __restrict  */)(& i1h.name), (size_t )26, (size_t )1, (FILE */* __restrict  */)f);
#line 614
      fix_name(i1h.name, 26);
#line 616
      fread((void */* __restrict  */)(& i1h.rsvd3), (size_t )6, (size_t )1, (FILE */* __restrict  */)f);
#line 617
      fread((void */* __restrict  */)(& i1h.keys), (size_t )240, (size_t )1, (FILE */* __restrict  */)f);
#line 618
      fread((void */* __restrict  */)(& i1h.epoint), (size_t )200, (size_t )1, (FILE */* __restrict  */)f);
#line 619
      fread((void */* __restrict  */)(& i1h.enode), (size_t )50, (size_t )1, (FILE */* __restrict  */)f);
#line 621
      copy_adjust((m___0->xxih + i___3)->name, i1h.name, 24);
#line 623
      (m___0->xxih + i___3)->rls = (int )i1h.fadeout << 7;
      }
#line 625
      if ((int )i1h.flags & 1) {
#line 625
        (m___0->xxih + i___3)->aei.flg = 1;
      } else {
#line 625
        (m___0->xxih + i___3)->aei.flg = 0;
      }
#line 626
      if ((int )i1h.flags & 2) {
#line 626
        tmp___39 = 4;
      } else {
#line 626
        tmp___39 = 0;
      }
#line 626
      (m___0->xxih + i___3)->aei.flg |= tmp___39;
#line 627
      if ((int )i1h.flags & 4) {
#line 627
        tmp___40 = 2;
      } else {
#line 627
        tmp___40 = 0;
      }
#line 627
      (m___0->xxih + i___3)->aei.flg |= tmp___40;
#line 628
      (m___0->xxih + i___3)->aei.lps = (int )i1h.vls;
#line 629
      (m___0->xxih + i___3)->aei.lpe = (int )i1h.vle;
#line 630
      (m___0->xxih + i___3)->aei.sus = (int )i1h.sls;
#line 631
      (m___0->xxih + i___3)->aei.sue = (int )i1h.sle;
#line 633
      k = 0;
      {
#line 633
      while (1) {
        while_continue___21: /* CIL Label */ ;
#line 633
        if (! ((int )i1h.enode[k * 2] != 255)) {
#line 633
          goto while_break___21;
        }
#line 633
        k ++;
      }
      while_break___21: /* CIL Label */ ;
      }
      {
#line 634
      tmp___41 = calloc((size_t )4, (size_t )k);
#line 634
      *(m___0->xxae + i___3) = (uint16 *)tmp___41;
#line 635
      (m___0->xxih + i___3)->aei.npt = k;
      }
      {
#line 635
      while (1) {
        while_continue___22: /* CIL Label */ ;
#line 635
        tmp___42 = k;
#line 635
        k --;
#line 635
        if (! tmp___42) {
#line 635
          goto while_break___22;
        }
#line 636
        *(*(m___0->xxae + i___3) + k * 2) = (uint16 )i1h.enode[k * 2];
#line 637
        *(*(m___0->xxae + i___3) + (k * 2 + 1)) = (uint16 )i1h.enode[k * 2 + 1];
      }
      while_break___22: /* CIL Label */ ;
      }
#line 641
      j = 0;
      {
#line 641
      while (1) {
        while_continue___23: /* CIL Label */ ;
#line 641
        if (! (j < 108)) {
#line 641
          goto while_break___23;
        }
#line 642
        inst_map[j] = -1;
#line 641
        j ++;
      }
      while_break___23: /* CIL Label */ ;
      }
#line 644
      j = 0;
#line 644
      k = j;
      {
#line 644
      while (1) {
        while_continue___24: /* CIL Label */ ;
#line 644
        if (! (j < 108)) {
#line 644
          goto while_break___24;
        }
#line 645
        c___0 = (int )i1h.keys[25 + j * 2] - 1;
#line 646
        if (c___0 < 0) {
#line 647
          (m___0->xxim + i___3)->ins[j] = (uint8 )255;
#line 648
          (m___0->xxim + i___3)->xpo[j] = (int8 )0;
#line 649
          goto __Cont___0;
        }
#line 651
        if (inst_map[c___0] == -1) {
#line 652
          inst_map[c___0] = k;
#line 653
          inst_rmap[k] = c___0;
#line 654
          k ++;
        }
#line 656
        (m___0->xxim + i___3)->ins[j] = (uint8 )inst_map[c___0];
#line 657
        (m___0->xxim + i___3)->xpo[j] = (int8 )((int )i1h.keys[24 + j * 2] - (j + 12));
        __Cont___0: /* CIL Label */ 
#line 644
        j ++;
      }
      while_break___24: /* CIL Label */ ;
      }
#line 660
      (m___0->xxih + i___3)->nsm = k;
#line 661
      (m___0->xxih + i___3)->vol = (int )i2h.gbv >> 1;
#line 663
      if (k) {
        {
#line 664
        tmp___43 = calloc((size_t )sizeof(struct xxm_instrument ), (size_t )k);
#line 664
        *(m___0->xxi + i___3) = (struct xxm_instrument *)tmp___43;
#line 665
        j = 0;
        }
        {
#line 665
        while (1) {
          while_continue___25: /* CIL Label */ ;
#line 665
          if (! (j < k)) {
#line 665
            goto while_break___25;
          }
#line 666
          (*(m___0->xxi + i___3) + j)->sid = inst_rmap[j];
#line 667
          (*(m___0->xxi + i___3) + j)->nna = (int )i1h.nna;
#line 668
          if (i1h.dnc) {
#line 668
            (*(m___0->xxi + i___3) + j)->dct = 1;
          } else {
#line 668
            (*(m___0->xxi + i___3) + j)->dct = 0;
          }
#line 669
          (*(m___0->xxi + i___3) + j)->dca = 0;
#line 670
          (*(m___0->xxi + i___3) + j)->pan = 128;
#line 665
          j ++;
        }
        while_break___25: /* CIL Label */ ;
        }
      }
#line 674
      if ((m___0->xxih + i___3)->aei.flg & 2) {
#line 674
        tmp___44 = 'S';
      } else {
#line 674
        tmp___44 = '-';
      }
#line 674
      if ((m___0->xxih + i___3)->aei.flg & 4) {
#line 674
        tmp___45 = 'L';
      } else {
#line 674
        tmp___45 = '-';
      }
#line 674
      if ((m___0->xxih + i___3)->aei.flg & 1) {
#line 674
        tmp___46 = 'V';
      } else {
#line 674
        tmp___46 = '-';
      }
#line 674
      if (i1h.dnc) {
#line 674
        tmp___47 = "on";
      } else {
#line 674
        tmp___47 = "off";
      }
#line 674
      if ((int )i1h.nna < 4) {
#line 674
        tmp___48 = (char const   *)nna[i1h.nna];
      } else {
#line 674
        tmp___48 = "none";
      }
      {
#line 674
      reportv(ctx___0, 1, (char *)"\n[%2X] %-26.26s %-4.4s %-4.4s %4d  %2d %c%c%c %3d ",
              i___3, i1h.name, tmp___48, tmp___47, (int )i1h.fadeout, (m___0->xxih + i___3)->aei.npt,
              tmp___46, tmp___45, tmp___44, (m___0->xxih + i___3)->nsm);
#line 686
      reportv(ctx___0, 0, (char *)".");
      }
    }
#line 442
    i___3 ++;
  }
  while_break___8: /* CIL Label */ ;
  }
  {
#line 690
  reportv(ctx___0, 0, (char *)"\nStored Samples : %d ", (m___0->xxh)->smp);
  }
#line 692
  if (m___0->verbosity > 2) {
    {
#line 693
    report((char *)"\n     Sample name                Len   LBeg  LEnd  SBeg  SEnd  FlCv VlGv C5Spd");
    }
  } else
#line 692
  if (~ ((int )ifh.flags) & 4) {
#line 692
    if (m___0->verbosity > 1) {
      {
#line 693
      report((char *)"\n     Sample name                Len   LBeg  LEnd  SBeg  SEnd  FlCv VlGv C5Spd");
      }
    }
  }
#line 697
  i___3 = 0;
  {
#line 697
  while (1) {
    while_continue___26: /* CIL Label */ ;
#line 697
    if (! (i___3 < (m___0->xxh)->smp)) {
#line 697
      goto while_break___26;
    }
#line 698
    if (~ ((int )ifh.flags) & 4) {
      {
#line 699
      tmp___49 = calloc((size_t )sizeof(struct xxm_instrument ), (size_t )1);
#line 699
      *(m___0->xxi + i___3) = (struct xxm_instrument *)tmp___49;
      }
    }
    {
#line 700
    fseek(f, (long )((uint32 )start + *(pp_smp + i___3)), 0);
#line 702
    ish.magic = read32b(f);
#line 703
    fread((void */* __restrict  */)(& ish.dosname), (size_t )12, (size_t )1, (FILE */* __restrict  */)f);
#line 704
    ish.zero = read8(f);
    }
#line 705
    if (mpt) {
      {
#line 705
      read8(f);
#line 705
      ish.gvl = (uint8 )64;
      }
    } else {
      {
#line 705
      tmp___50 = read8(f);
#line 705
      ish.gvl = tmp___50;
      }
    }
    {
#line 706
    ish.flags = read8(f);
#line 707
    ish.vol = read8(f);
#line 708
    fread((void */* __restrict  */)(& ish.name), (size_t )26, (size_t )1, (FILE */* __restrict  */)f);
#line 710
    fix_name(ish.name, 26);
#line 712
    ish.convert = read8(f);
#line 713
    ish.dfp = read8(f);
#line 714
    ish.length = read32l(f);
#line 715
    ish.loopbeg = read32l(f);
#line 716
    ish.loopend = read32l(f);
#line 717
    ish.c5spd = read32l(f);
#line 718
    ish.sloopbeg = read32l(f);
#line 719
    ish.sloopend = read32l(f);
#line 720
    ish.sample_ptr = read32l(f);
#line 722
    ish.vis = read8(f);
#line 723
    ish.vid = read8(f);
#line 724
    ish.vir = read8(f);
#line 725
    ish.vit = read8(f);
    }
#line 730
    if (ish.magic != ((((73U << 24) | (77U << 16)) | (80U << 8)) | 83U)) {
#line 731
      goto __Cont___1;
    }
#line 733
    if ((int )ish.flags & 2) {
#line 734
      (m___0->xxs + i___3)->len = (int )(ish.length * 2U);
#line 735
      (m___0->xxs + i___3)->lps = (int )(ish.loopbeg * 2U);
#line 736
      (m___0->xxs + i___3)->lpe = (int )(ish.loopend * 2U);
#line 737
      (m___0->xxs + i___3)->flg = 1;
    } else {
#line 739
      (m___0->xxs + i___3)->len = (int )ish.length;
#line 740
      (m___0->xxs + i___3)->lps = (int )ish.loopbeg;
#line 741
      (m___0->xxs + i___3)->lpe = (int )ish.loopend;
    }
#line 744
    if ((int )ish.flags & 16) {
#line 744
      tmp___51 = 4;
    } else {
#line 744
      tmp___51 = 0;
    }
#line 744
    (m___0->xxs + i___3)->flg |= tmp___51;
#line 745
    if ((int )ish.flags & 64) {
#line 745
      tmp___52 = 8;
    } else {
#line 745
      tmp___52 = 0;
    }
#line 745
    (m___0->xxs + i___3)->flg |= tmp___52;
#line 747
    if (~ ((int )ifh.flags) & 4) {
      {
#line 749
      (*(m___0->xxi + i___3) + 0)->vol = (int )ish.vol;
#line 750
      (*(m___0->xxi + i___3) + 0)->pan = 128;
#line 751
      (*(m___0->xxi + i___3) + 0)->sid = i___3;
#line 752
      (m___0->xxih + i___3)->nsm = ! (! (m___0->xxs + i___3)->len);
#line 753
      copy_adjust((m___0->xxih + i___3)->name, ish.name, 24);
      }
    } else {
      {
#line 755
      copy_adjust((m___0->xxs + i___3)->name, ish.name, 24);
      }
    }
#line 758
    if (m___0->verbosity > 2) {
#line 758
      goto _L___3;
    } else
#line 758
    if (~ ((int )ifh.flags) & 4) {
#line 758
      if (m___0->verbosity > 1) {
        _L___3: /* CIL Label */ 
        {
#line 759
        tmp___54 = strlen((char const   *)((char *)(ish.name)));
        }
#line 759
        if (tmp___54) {
#line 759
          goto _L___2;
        } else
#line 759
        if ((m___0->xxs + i___3)->len > 1) {
          _L___2: /* CIL Label */ 
#line 760
          if ((int )ish.flags & 2) {
#line 760
            tmp___53 = '+';
          } else {
#line 760
            tmp___53 = ' ';
          }
          {
#line 760
          report((char *)"\n[%2X] %-26.26s %05x%c%05x %05x %05x %05x %02x%02x %02x%02x %5d ",
                 i___3, ish.name, (m___0->xxs + i___3)->len, tmp___53, (m___0->xxs + i___3)->lps,
                 (m___0->xxs + i___3)->lpe, ish.sloopbeg, ish.sloopend, (int )ish.flags,
                 (int )ish.convert, (int )ish.vol, (int )ish.gvl, ish.c5spd);
          }
        }
      }
    }
#line 781
    j = 0;
    {
#line 781
    while (1) {
      while_continue___27: /* CIL Label */ ;
#line 781
      if (! (j < (m___0->xxh)->ins)) {
#line 781
        goto while_break___27;
      }
#line 782
      k = 0;
      {
#line 782
      while (1) {
        while_continue___28: /* CIL Label */ ;
#line 782
        if (! (k < (m___0->xxih + j)->nsm)) {
#line 782
          goto while_break___28;
        }
#line 783
        if ((*(m___0->xxi + j) + k)->sid == i___3) {
          {
#line 784
          (*(m___0->xxi + j) + k)->vol = (int )ish.vol;
#line 785
          (*(m___0->xxi + j) + k)->gvl = (int )ish.gvl;
#line 786
          c2spd_to_note((int )ish.c5spd, & (*(m___0->xxi + j) + k)->xpo, & (*(m___0->xxi + j) + k)->fin);
          }
        }
#line 782
        k ++;
      }
      while_break___28: /* CIL Label */ ;
      }
#line 781
      j ++;
    }
    while_break___27: /* CIL Label */ ;
    }
#line 791
    if ((int )ish.flags & 1) {
#line 791
      if ((m___0->xxs + i___3)->len > 1) {
#line 792
        cvt = 0;
#line 794
        if (o___0->skipsmp) {
#line 795
          goto __Cont___1;
        }
        {
#line 797
        fseek(f, (long )((uint32 )start + ish.sample_ptr), 0);
        }
#line 799
        if (~ ((int )ish.convert) & 1) {
#line 800
          cvt |= 2;
        }
#line 803
        if ((int )ish.flags & 8) {
          {
#line 805
          tmp___55 = calloc((size_t )1, (size_t )(m___0->xxs + i___3)->len);
#line 805
          buf___1 = (char *)tmp___55;
          }
#line 807
          if ((int )ish.flags & 2) {
            {
#line 808
            itsex_decompress16(f, (void *)buf___1, (m___0->xxs + i___3)->len >> 1,
                               (int )ish.convert & 4);
            }
#line 813
            if (o___0->big_endian) {
              {
#line 814
              xmp_cvt_sex((m___0->xxs + i___3)->len, buf___1);
              }
            }
          } else {
            {
#line 816
            itsex_decompress8(f, (void *)buf___1, (m___0->xxs + i___3)->len, (int )ifh.cmwt == 533);
            }
          }
          {
#line 819
          xmp_drv_loadpatch(ctx___0, (FILE *)((void *)0), i___3, m___0->c4rate, 16 | cvt,
                            m___0->xxs + i___3, buf___1);
#line 821
          free((void *)buf___1);
#line 822
          reportv(ctx___0, 0, (char *)"c");
          }
        } else {
#line 824
          if (o___0->skipsmp) {
            {
#line 825
            fseek(f, (long )(m___0->xxs + i___3)->len, 1);
            }
#line 826
            goto __Cont___1;
          }
          {
#line 829
          xmp_drv_loadpatch(ctx___0, f, i___3, m___0->c4rate, cvt, m___0->xxs + i___3,
                            (char *)((void *)0));
#line 831
          reportv(ctx___0, 0, (char *)".");
          }
        }
      }
    }
    __Cont___1: /* CIL Label */ 
#line 697
    i___3 ++;
  }
  while_break___26: /* CIL Label */ ;
  }
  {
#line 836
  reportv(ctx___0, 0, (char *)"\nStored Patterns: %d ", (m___0->xxh)->pat);
#line 838
  (m___0->xxh)->trk = (m___0->xxh)->pat * (m___0->xxh)->chn;
#line 839
  memset((void *)(arpeggio_val___0), 0, (size_t )64);
#line 840
  memset((void *)(last_h), 0, (size_t )64);
#line 841
  memset((void *)(last_fxp), 0, (size_t )64);
  }
  {
#line 843
  while (1) {
    while_continue___29: /* CIL Label */ ;
    {
#line 843
    tmp___56 = calloc((size_t )sizeof(struct xxm_track *), (size_t )(m___0->xxh)->trk);
#line 843
    m___0->xxt = (struct xxm_track **)tmp___56;
#line 843
    tmp___57 = calloc((size_t )sizeof(struct xxm_pattern *), (size_t )((m___0->xxh)->pat + 1));
#line 843
    m___0->xxp = (struct xxm_pattern **)tmp___57;
    }
#line 843
    goto while_break___29;
  }
  while_break___29: /* CIL Label */ ;
  }
#line 846
  i___3 = 0;
#line 846
  max_ch = i___3;
  {
#line 846
  while (1) {
    while_continue___30: /* CIL Label */ ;
#line 846
    if (! (i___3 < (m___0->xxh)->pat)) {
#line 846
      goto while_break___30;
    }
    {
#line 847
    while (1) {
      while_continue___31: /* CIL Label */ ;
      {
#line 847
      tmp___58 = calloc((size_t )1, (size_t )(sizeof(struct xxm_pattern ) + sizeof(struct xxm_trackinfo ) * (unsigned long )((m___0->xxh)->chn - 1)));
#line 847
      *(m___0->xxp + i___3) = (struct xxm_pattern *)tmp___58;
      }
#line 847
      goto while_break___31;
    }
    while_break___31: /* CIL Label */ ;
    }
#line 848
    r = 0;
#line 850
    if (! *(pp_pat___0 + i___3)) {
      {
#line 851
      (*(m___0->xxp + i___3))->rows = 64;
#line 852
      tmp___59 = calloc((size_t )(sizeof(struct xxm_track ) + sizeof(struct xxm_event ) * 64UL),
                        (size_t )1);
#line 852
      *(m___0->xxt + i___3 * (m___0->xxh)->chn) = (struct xxm_track *)tmp___59;
#line 854
      (*(m___0->xxt + i___3 * (m___0->xxh)->chn))->rows = 64;
#line 855
      j = 0;
      }
      {
#line 855
      while (1) {
        while_continue___32: /* CIL Label */ ;
#line 855
        if (! (j < (m___0->xxh)->chn)) {
#line 855
          goto while_break___32;
        }
#line 856
        (*(m___0->xxp + i___3))->info[j].index = i___3 * (m___0->xxh)->chn;
#line 855
        j ++;
      }
      while_break___32: /* CIL Label */ ;
      }
#line 857
      goto __Cont___2;
    }
    {
#line 859
    fseek(f, (long )((uint32 )start + *(pp_pat___0 + i___3)), 0);
#line 860
    tmp___60 = read16l(f);
#line 860
    pat_len = (int )tmp___60;
#line 861
    tmp___61 = read16l(f);
#line 861
    (*(m___0->xxp + i___3))->rows = (int )tmp___61;
    }
    {
#line 862
    while (1) {
      while_continue___33: /* CIL Label */ ;
#line 862
      j___0 = 0;
      {
#line 862
      while (1) {
        while_continue___34: /* CIL Label */ ;
#line 862
        if (! (j___0 < (m___0->xxh)->chn)) {
#line 862
          goto while_break___34;
        }
        {
#line 862
        (*(m___0->xxp + i___3))->info[j___0].index = i___3 * (m___0->xxh)->chn + j___0;
#line 862
        tmp___62 = calloc((size_t )(sizeof(struct xxm_track ) + sizeof(struct xxm_event ) * (unsigned long )(*(m___0->xxp + i___3))->rows),
                          (size_t )1);
#line 862
        *(m___0->xxt + (i___3 * (m___0->xxh)->chn + j___0)) = (struct xxm_track *)tmp___62;
#line 862
        (*(m___0->xxt + (i___3 * (m___0->xxh)->chn + j___0)))->rows = (*(m___0->xxp + i___3))->rows;
#line 862
        j___0 ++;
        }
      }
      while_break___34: /* CIL Label */ ;
      }
#line 862
      goto while_break___33;
    }
    while_break___33: /* CIL Label */ ;
    }
    {
#line 863
    memset((void *)(mask), 0, (size_t )64);
#line 864
    read16l(f);
#line 865
    read16l(f);
    }
    {
#line 867
    while (1) {
      while_continue___35: /* CIL Label */ ;
#line 867
      pat_len --;
#line 867
      if (! (pat_len >= 0)) {
#line 867
        goto while_break___35;
      }
      {
#line 868
      b___1 = read8(f);
      }
#line 869
      if (! b___1) {
#line 870
        r ++;
#line 871
        goto while_continue___35;
      }
#line 873
      c___0 = ((int )b___1 - 1) & 63;
#line 875
      if ((int )b___1 & 128) {
        {
#line 876
        mask[c___0] = read8(f);
#line 877
        pat_len --;
        }
      }
#line 885
      if (c___0 >= (m___0->xxh)->chn) {
#line 885
        event = & dummy___3;
      } else {
#line 885
        event = & (*(m___0->xxt + (*(m___0->xxp + i___3))->info[c___0].index))->event[r];
      }
#line 886
      if ((int )mask[c___0] & 1) {
        {
#line 887
        b___1 = read8(f);
        }
#line 889
        if ((int )b___1 > 127) {
#line 889
          if ((int )b___1 < 253) {
#line 890
            b___1 = (uint8 )0;
          }
        }
        {
#line 893
        if ((int )b___1 == 255) {
#line 893
          goto case_255;
        }
#line 896
        if ((int )b___1 == 254) {
#line 896
          goto case_254;
        }
#line 899
        if ((int )b___1 == 253) {
#line 899
          goto case_253;
        }
#line 902
        goto switch_default___0;
        case_255: /* CIL Label */ 
#line 894
        b___1 = (uint8 )129;
#line 895
        goto switch_break___0;
        case_254: /* CIL Label */ 
#line 897
        b___1 = (uint8 )130;
#line 898
        goto switch_break___0;
        case_253: /* CIL Label */ 
#line 900
        b___1 = (uint8 )131;
#line 901
        goto switch_break___0;
        switch_default___0: /* CIL Label */ 
#line 903
        if ((int )b___1 < 11) {
#line 904
          b___1 = (uint8 )0;
        } else {
#line 906
          b___1 = (uint8 )((int )b___1 - 11);
        }
        switch_break___0: /* CIL Label */ ;
        }
#line 908
        tmp___63 = b___1;
#line 908
        event->note = tmp___63;
#line 908
        lastevent[c___0].note = tmp___63;
#line 909
        pat_len --;
      }
#line 911
      if ((int )mask[c___0] & 2) {
        {
#line 912
        b___1 = read8(f);
#line 913
        tmp___64 = b___1;
#line 913
        event->ins = tmp___64;
#line 913
        lastevent[c___0].ins = tmp___64;
#line 914
        pat_len --;
        }
      }
#line 916
      if ((int )mask[c___0] & 4) {
        {
#line 917
        b___1 = read8(f);
#line 918
        tmp___65 = b___1;
#line 918
        event->vol = tmp___65;
#line 918
        lastevent[c___0].vol = tmp___65;
#line 919
        xlat_volfx(event);
#line 920
        pat_len --;
        }
      }
#line 922
      if ((int )mask[c___0] & 8) {
        {
#line 923
        b___1 = read8(f);
#line 924
        event->fxt = b___1;
#line 925
        event->fxp = read8(f);
#line 926
        xlat_fx___3(c___0, event);
#line 927
        lastevent[c___0].fxt = event->fxt;
#line 928
        lastevent[c___0].fxp = event->fxp;
#line 929
        pat_len -= 2;
        }
      }
#line 931
      if ((int )mask[c___0] & 16) {
#line 932
        event->note = lastevent[c___0].note;
      }
#line 934
      if ((int )mask[c___0] & 32) {
#line 935
        event->ins = lastevent[c___0].ins;
      }
#line 937
      if ((int )mask[c___0] & 64) {
        {
#line 938
        event->vol = lastevent[c___0].vol;
#line 939
        xlat_volfx(event);
        }
      }
#line 941
      if ((int )mask[c___0] & 128) {
#line 942
        event->fxt = lastevent[c___0].fxt;
#line 943
        event->fxp = lastevent[c___0].fxp;
      }
    }
    while_break___35: /* CIL Label */ ;
    }
    {
#line 946
    reportv(ctx___0, 0, (char *)".");
#line 949
    c___0 = (m___0->xxh)->chn - 1;
    }
    {
#line 949
    while (1) {
      while_continue___36: /* CIL Label */ ;
#line 949
      if (! (c___0 >= max_ch)) {
#line 949
        goto while_break___36;
      }
#line 950
      j = 0;
#line 950
      flag = j;
      {
#line 950
      while (1) {
        while_continue___37: /* CIL Label */ ;
#line 950
        if (! (j < (*(m___0->xxt + (*(m___0->xxp + i___3))->info[c___0].index))->rows)) {
#line 950
          goto while_break___37;
        }
#line 951
        event = & (*(m___0->xxt + (*(m___0->xxp + i___3))->info[c___0].index))->event[j];
#line 952
        if (event->note) {
#line 954
          flag = 1;
#line 955
          goto while_break___37;
        } else
#line 952
        if (event->vol) {
#line 954
          flag = 1;
#line 955
          goto while_break___37;
        } else
#line 952
        if (event->ins) {
#line 954
          flag = 1;
#line 955
          goto while_break___37;
        } else
#line 952
        if (event->fxt) {
#line 954
          flag = 1;
#line 955
          goto while_break___37;
        } else
#line 952
        if (event->fxp) {
#line 954
          flag = 1;
#line 955
          goto while_break___37;
        } else
#line 952
        if (event->f2t) {
#line 954
          flag = 1;
#line 955
          goto while_break___37;
        } else
#line 952
        if (event->f2p) {
#line 954
          flag = 1;
#line 955
          goto while_break___37;
        }
#line 950
        j ++;
      }
      while_break___37: /* CIL Label */ ;
      }
#line 958
      if (flag) {
#line 958
        if (c___0 > max_ch) {
#line 959
          max_ch = c___0;
        }
      }
#line 949
      c___0 --;
    }
    while_break___36: /* CIL Label */ ;
    }
    __Cont___2: /* CIL Label */ 
#line 846
    i___3 ++;
  }
  while_break___30: /* CIL Label */ ;
  }
  {
#line 963
  free((void *)pp_pat___0);
#line 964
  free((void *)pp_smp);
  }
#line 965
  if (pp_ins___0) {
    {
#line 966
    free((void *)pp_ins___0);
    }
  }
#line 968
  (m___0->xxh)->chn = max_ch + 1;
#line 969
  m___0->flags |= (1 << 5) | (1 << 8);
#line 970
  m___0->quirk |= (((((((((1 << 5) | (1 << 6)) | (1 << 2)) | (1 << 1)) | (1 << 9)) | (1 << 3)) | (1 << 17)) | (1 << 14)) | (1 << 19)) | (1 << 20);
#line 971
  if (~ ((int )ifh.flags) & 32) {
#line 972
    m___0->quirk |= 1 << 18;
  }
  {
#line 974
  reportv(ctx___0, 0, (char *)"\n");
  }
#line 976
  return (0);
}
}
#line 31 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/iff.h"
void iff_idsize(int n___0 ) ;
#line 27 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/mdl_load.c"
static int mdl_test(FILE *f , char *t , int const   start ) ;
#line 28
static int mdl_load(struct xmp_context *ctx___0 , FILE *f , int const   start ) ;
#line 30 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/mdl_load.c"
struct xmp_loader_info mdl_loader  =    {(char *)"MDL", (char *)"Digitrakker", & mdl_test, & mdl_load, 0, {(struct list_head *)0,
                                                                      (struct list_head *)0}};
#line 37 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/mdl_load.c"
static int mdl_test(FILE *f , char *t , int const   start ) 
{ 
  uint16 id ;
  uint32 tmp ;

  {
  {
#line 41
  tmp = read32b(f);
  }
#line 41
  if (tmp != ((((68U << 24) | (77U << 16)) | (68U << 8)) | 76U)) {
#line 42
    return (-1);
  }
  {
#line 44
  read8(f);
#line 45
  id = read16b(f);
  }
#line 47
  if ((int )id == 18766) {
    {
#line 48
    read32b(f);
#line 49
    read_title(f, t, 32);
    }
  } else {
    {
#line 51
    read_title(f, t, 0);
    }
  }
#line 54
  return (0);
}
}
#line 73 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/mdl_load.c"
static int *i_index  ;
#line 74 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/mdl_load.c"
static int *s_index  ;
#line 75 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/mdl_load.c"
static int *v_index  ;
#line 76 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/mdl_load.c"
static int *p_index  ;
#line 77 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/mdl_load.c"
static int *f_index  ;
#line 78 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/mdl_load.c"
static int *c2spd  ;
#line 79 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/mdl_load.c"
static int *packinfo  ;
#line 80 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/mdl_load.c"
static int v_envnum  ;
#line 81 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/mdl_load.c"
static int p_envnum  ;
#line 82 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/mdl_load.c"
static int f_envnum  ;
#line 83 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/mdl_load.c"
static struct mdl_envelope *v_env  ;
#line 84 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/mdl_load.c"
static struct mdl_envelope *p_env  ;
#line 85 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/mdl_load.c"
static struct mdl_envelope *f_env  ;
#line 92 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/mdl_load.c"
static void xlat_fx_common(uint8 *t , uint8 *p ) 
{ 
  uint8 tmp ;
  uint8 tmp___0 ;

  {
  {
#line 95
  if ((int )*t == 0) {
#line 95
    goto case_0;
  }
#line 98
  if ((int )*t == 7) {
#line 98
    goto case_7;
  }
#line 103
  if ((int )*t == 10) {
#line 103
    goto case_10;
  }
#line 103
  if ((int )*t == 9) {
#line 103
    goto case_10;
  }
#line 103
  if ((int )*t == 8) {
#line 103
    goto case_10;
  }
#line 108
  if ((int )*t == 13) {
#line 108
    goto case_13;
  }
#line 108
  if ((int )*t == 12) {
#line 108
    goto case_13;
  }
#line 108
  if ((int )*t == 11) {
#line 108
    goto case_13;
  }
#line 111
  if ((int )*t == 14) {
#line 111
    goto case_14;
  }
#line 128
  if ((int )*t == 15) {
#line 128
    goto case_15;
  }
#line 94
  goto switch_break;
  case_0: /* CIL Label */ 
#line 96
  *p = (uint8 )0;
#line 97
  goto switch_break;
  case_7: /* CIL Label */ 
#line 99
  *t = (uint8 )171;
#line 100
  goto switch_break;
  case_10: /* CIL Label */ 
  case_9: /* CIL Label */ 
  case_8: /* CIL Label */ 
#line 104
  tmp = (uint8 )0;
#line 104
  *p = tmp;
#line 104
  *t = tmp;
#line 105
  goto switch_break;
  case_13: /* CIL Label */ 
  case_12: /* CIL Label */ 
  case_11: /* CIL Label */ 
#line 110
  goto switch_break;
  case_14: /* CIL Label */ 
  {
#line 115
  if (((int )*p & 240) >> 4 == 8) {
#line 115
    goto case_8___0;
  }
#line 115
  if (((int )*p & 240) >> 4 == 3) {
#line 115
    goto case_8___0;
  }
#line 115
  if (((int )*p & 240) >> 4 == 0) {
#line 115
    goto case_8___0;
  }
#line 118
  if (((int )*p & 240) >> 4 == 1) {
#line 118
    goto case_1;
  }
#line 122
  if (((int )*p & 240) >> 4 == 2) {
#line 122
    goto case_2;
  }
#line 112
  goto switch_break___0;
  case_8___0: /* CIL Label */ 
  case_3: /* CIL Label */ 
  case_0___0: /* CIL Label */ 
#line 116
  tmp___0 = (uint8 )0;
#line 116
  *p = tmp___0;
#line 116
  *t = tmp___0;
#line 117
  goto switch_break___0;
  case_1: /* CIL Label */ 
#line 119
  *t = (uint8 )25;
#line 120
  *p = (uint8 )((int )*p << 4);
#line 121
  goto switch_break___0;
  case_2: /* CIL Label */ 
#line 123
  *t = (uint8 )25;
#line 124
  *p = (uint8 )((int )*p & 15);
#line 125
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
#line 127
  goto switch_break;
  case_15: /* CIL Label */ 
#line 129
  *t = (uint8 )163;
#line 130
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 132
  return;
}
}
#line 134 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/mdl_load.c"
static void xlat_fx1(uint8 *t , uint8 *p ) 
{ 
  uint8 tmp ;

  {
  {
#line 137
  if ((int )*t == 5) {
#line 137
    goto case_5;
  }
#line 140
  if ((int )*t == 6) {
#line 140
    goto case_6;
  }
#line 136
  goto switch_break;
  case_5: /* CIL Label */ 
#line 138
  *t = (uint8 )0;
#line 139
  goto switch_break;
  case_6: /* CIL Label */ 
#line 141
  tmp = (uint8 )0;
#line 141
  *p = tmp;
#line 141
  *t = tmp;
#line 142
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 145
  xlat_fx_common(t, p);
  }
#line 146
  return;
}
}
#line 149 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/mdl_load.c"
static void xlat_fx2(uint8 *t , uint8 *p ) 
{ 
  uint8 tmp ;

  {
  {
#line 152
  if ((int )*t == 1) {
#line 152
    goto case_1;
  }
#line 155
  if ((int )*t == 2) {
#line 155
    goto case_2;
  }
#line 158
  if ((int )*t == 3) {
#line 158
    goto case_3;
  }
#line 161
  if ((int )*t == 4) {
#line 161
    goto case_4;
  }
#line 164
  if ((int )*t == 5) {
#line 164
    goto case_5;
  }
#line 167
  if ((int )*t == 6) {
#line 167
    goto case_6;
  }
#line 151
  goto switch_break;
  case_1: /* CIL Label */ 
#line 153
  *t = (uint8 )160;
#line 154
  goto switch_break;
  case_2: /* CIL Label */ 
#line 156
  *t = (uint8 )161;
#line 157
  goto switch_break;
  case_3: /* CIL Label */ 
#line 159
  *t = (uint8 )27;
#line 160
  goto switch_break;
  case_4: /* CIL Label */ 
#line 162
  *t = (uint8 )7;
#line 163
  goto switch_break;
  case_5: /* CIL Label */ 
#line 165
  *t = (uint8 )29;
#line 166
  goto switch_break;
  case_6: /* CIL Label */ 
#line 168
  tmp = (uint8 )0;
#line 168
  *p = tmp;
#line 168
  *t = tmp;
#line 169
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 172
  xlat_fx_common(t, p);
  }
#line 173
  return;
}
}
#line 178
static unsigned int get_bits(char i___3 , uint8 **buf___1 , int *len ) ;
#line 178 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/mdl_load.c"
static uint32 b___0  =    (uint32 )0;
#line 178 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/mdl_load.c"
static uint32 n  =    (uint32 )32;
#line 176 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/mdl_load.c"
static unsigned int get_bits(char i___3 , uint8 **buf___1 , int *len ) 
{ 
  unsigned int x ;
  uint8 *tmp ;
  uint32 tmp___0 ;

  {
#line 181
  if ((int )i___3 == 0) {
    {
#line 182
    b___0 = readmem32l(*buf___1);
#line 183
    *buf___1 += 4;
#line 183
    *len -= 4;
#line 184
    n = (uint32 )32;
    }
#line 185
    return (0U);
  }
#line 188
  x = b___0 & (unsigned int )((1 << (int )i___3) - 1);
#line 189
  b___0 >>= (int )i___3;
#line 190
  n -= (uint32 )i___3;
#line 190
  if (n <= 24U) {
#line 191
    if (*len == 0) {
#line 192
      return (x);
    }
    {
#line 193
    tmp = *buf___1;
#line 193
    (*buf___1) ++;
#line 193
    tmp___0 = readmem32l(tmp);
#line 193
    b___0 |= tmp___0 << n;
#line 194
    n += 8U;
#line 194
    (*len) --;
    }
  }
#line 197
  return (x);
}
}
#line 223 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/mdl_load.c"
static void unpack_sample8(uint8 *t , uint8 *f , int len , int l ) 
{ 
  int i___3 ;
  int s ;
  uint8 b___1 ;
  uint8 d ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;
  unsigned int tmp___3 ;
  uint8 *tmp___4 ;

  {
  {
#line 228
  get_bits((char)0, & f, & len);
#line 230
  d = (uint8 )0;
#line 230
  b___1 = d;
#line 230
  i___3 = (int )b___1;
  }
  {
#line 230
  while (1) {
    while_continue: /* CIL Label */ ;
#line 230
    if (! (i___3 < l)) {
#line 230
      goto while_break;
    }
    {
#line 231
    tmp = get_bits((char)1, & f, & len);
#line 231
    s = (int )tmp;
#line 232
    tmp___3 = get_bits((char)1, & f, & len);
    }
#line 232
    if (tmp___3) {
      {
#line 233
      tmp___0 = get_bits((char)3, & f, & len);
#line 233
      b___1 = (uint8 )tmp___0;
      }
    } else {
#line 235
      b___1 = (uint8 )8;
      {
#line 236
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 236
        if (len >= 0) {
          {
#line 236
          tmp___1 = get_bits((char)1, & f, & len);
          }
#line 236
          if (tmp___1) {
#line 236
            goto while_break___0;
          }
        } else {
#line 236
          goto while_break___0;
        }
#line 237
        b___1 = (uint8 )((int )b___1 + 16);
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 238
      tmp___2 = get_bits((char)4, & f, & len);
#line 238
      b___1 = (uint8 )((unsigned int )b___1 + tmp___2);
      }
    }
#line 241
    if (s) {
#line 242
      b___1 = (uint8 )((int )b___1 ^ 255);
    }
#line 244
    d = (uint8 )((int )d + (int )b___1);
#line 245
    tmp___4 = t;
#line 245
    t ++;
#line 245
    *tmp___4 = d;
#line 230
    i___3 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 247
  return;
}
}
#line 261 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/mdl_load.c"
static void unpack_sample16(uint8 *t , uint8 *f , int len , int l ) 
{ 
  int i___3 ;
  int lo ;
  int s ;
  uint8 b___1 ;
  uint8 d ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;
  unsigned int tmp___3 ;
  unsigned int tmp___4 ;
  uint8 *tmp___5 ;
  uint8 *tmp___6 ;

  {
  {
#line 266
  get_bits((char)0, & f, & len);
#line 268
  d = (uint8 )0;
#line 268
  b___1 = d;
#line 268
  lo = (int )b___1;
#line 268
  i___3 = lo;
  }
  {
#line 268
  while (1) {
    while_continue: /* CIL Label */ ;
#line 268
    if (! (i___3 < l)) {
#line 268
      goto while_break;
    }
    {
#line 269
    tmp = get_bits((char)8, & f, & len);
#line 269
    lo = (int )tmp;
#line 270
    tmp___0 = get_bits((char)1, & f, & len);
#line 270
    s = (int )tmp___0;
#line 271
    tmp___4 = get_bits((char)1, & f, & len);
    }
#line 271
    if (tmp___4) {
      {
#line 272
      tmp___1 = get_bits((char)3, & f, & len);
#line 272
      b___1 = (uint8 )tmp___1;
      }
    } else {
#line 274
      b___1 = (uint8 )8;
      {
#line 275
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 275
        if (len >= 0) {
          {
#line 275
          tmp___2 = get_bits((char)1, & f, & len);
          }
#line 275
          if (tmp___2) {
#line 275
            goto while_break___0;
          }
        } else {
#line 275
          goto while_break___0;
        }
#line 276
        b___1 = (uint8 )((int )b___1 + 16);
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 277
      tmp___3 = get_bits((char)4, & f, & len);
#line 277
      b___1 = (uint8 )((unsigned int )b___1 + tmp___3);
      }
    }
#line 280
    if (s) {
#line 281
      b___1 = (uint8 )((int )b___1 ^ 255);
    }
#line 282
    d = (uint8 )((int )d + (int )b___1);
#line 284
    tmp___5 = t;
#line 284
    t ++;
#line 284
    *tmp___5 = (uint8 )lo;
#line 285
    tmp___6 = t;
#line 285
    t ++;
#line 285
    *tmp___6 = d;
#line 268
    i___3 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 287
  return;
}
}
#line 294 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/mdl_load.c"
static void get_chunk_in(struct xmp_context *ctx___0 , int size___0 , FILE *f ) 
{ 
  struct xmp_player_context *p ;
  struct xmp_mod_context *m___0 ;
  int i___3 ;
  uint16 tmp ;
  uint16 tmp___0 ;
  uint8 tmp___1 ;
  uint8 tmp___2 ;
  uint8 chinfo ;
  uint8 tmp___3 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;

  {
  {
#line 296
  p = & ctx___0->p;
#line 297
  m___0 = & p->m;
#line 300
  fread((void */* __restrict  */)(m___0->name), (size_t )1, (size_t )32, (FILE */* __restrict  */)f);
#line 301
  fread((void */* __restrict  */)(m___0->author), (size_t )1, (size_t )20, (FILE */* __restrict  */)f);
#line 303
  tmp = read16l(f);
#line 303
  (m___0->xxh)->len = (int )tmp;
#line 304
  tmp___0 = read16l(f);
#line 304
  (m___0->xxh)->rst = (int )tmp___0;
#line 305
  read8(f);
#line 306
  tmp___1 = read8(f);
#line 306
  (m___0->xxh)->tpo = (int )tmp___1;
#line 307
  tmp___2 = read8(f);
#line 307
  (m___0->xxh)->bpm = (int )tmp___2;
#line 309
  i___3 = 0;
  }
  {
#line 309
  while (1) {
    while_continue: /* CIL Label */ ;
#line 309
    if (! (i___3 < 32)) {
#line 309
      goto while_break;
    }
    {
#line 310
    tmp___3 = read8(f);
#line 310
    chinfo = tmp___3;
    }
#line 311
    if ((int )chinfo & 128) {
#line 312
      goto while_break;
    }
#line 313
    m___0->xxc[i___3].pan = (int )chinfo << 1;
#line 309
    i___3 ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 315
  (m___0->xxh)->chn = i___3;
#line 316
  fseek(f, (long )((32 - i___3) - 1), 1);
#line 318
  fread((void */* __restrict  */)(m___0->xxo), (size_t )1, (size_t )(m___0->xxh)->len,
        (FILE */* __restrict  */)f);
  }
  {
#line 320
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 320
    if (m___0->verbosity) {
#line 320
      if (m___0->name[0]) {
        {
#line 320
        report((char *)"Module title   : %s\n", m___0->name);
        }
      }
#line 320
      if (m___0->type[0]) {
        {
#line 320
        report((char *)"Module type    : %s\n", m___0->type);
        }
      }
#line 320
      if (m___0->author[0]) {
        {
#line 320
        report((char *)"Author name    : %s\n", m___0->author);
        }
      }
#line 320
      if ((m___0->xxh)->len) {
        {
#line 320
        report((char *)"Module length  : %d patterns\n", (m___0->xxh)->len);
        }
      }
    }
#line 320
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 321
  return;
}
}
#line 323 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/mdl_load.c"
static void get_chunk_pa(struct xmp_context *ctx___0 , int size___0 , FILE *f ) 
{ 
  struct xmp_player_context *p ;
  struct xmp_mod_context *m___0 ;
  int i___3 ;
  int j ;
  int chn ;
  int x ;
  uint8 tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  uint8 tmp___3 ;
  uint8 tmp___4 ;
  uint16 tmp___5 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;

  {
  {
#line 325
  p = & ctx___0->p;
#line 326
  m___0 = & p->m;
#line 330
  tmp = read8(f);
#line 330
  (m___0->xxh)->pat = (int )tmp;
#line 331
  (m___0->xxh)->trk = (m___0->xxh)->pat * (m___0->xxh)->chn + 1;
  }
  {
#line 333
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 333
    tmp___0 = calloc((size_t )sizeof(struct xxm_track *), (size_t )(m___0->xxh)->trk);
#line 333
    m___0->xxt = (struct xxm_track **)tmp___0;
#line 333
    tmp___1 = calloc((size_t )sizeof(struct xxm_pattern *), (size_t )((m___0->xxh)->pat + 1));
#line 333
    m___0->xxp = (struct xxm_pattern **)tmp___1;
    }
#line 333
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 334
  reportv(ctx___0, 0, (char *)"Stored patterns: %d ", (m___0->xxh)->pat);
#line 336
  i___3 = 0;
  }
  {
#line 336
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 336
    if (! (i___3 < (m___0->xxh)->pat)) {
#line 336
      goto while_break___0;
    }
    {
#line 337
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 337
      tmp___2 = calloc((size_t )1, (size_t )(sizeof(struct xxm_pattern ) + sizeof(struct xxm_trackinfo ) * (unsigned long )((m___0->xxh)->chn - 1)));
#line 337
      *(m___0->xxp + i___3) = (struct xxm_pattern *)tmp___2;
      }
#line 337
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 338
    tmp___3 = read8(f);
#line 338
    chn = (int )tmp___3;
#line 339
    tmp___4 = read8(f);
#line 339
    (*(m___0->xxp + i___3))->rows = (int )tmp___4 + 1;
#line 341
    fseek(f, 16L, 1);
#line 342
    j = 0;
    }
    {
#line 342
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 342
      if (! (j < chn)) {
#line 342
        goto while_break___2;
      }
      {
#line 343
      tmp___5 = read16l(f);
#line 343
      x = (int )tmp___5;
      }
#line 344
      if (j < (m___0->xxh)->chn) {
#line 345
        (*(m___0->xxp + i___3))->info[j].index = x;
      }
#line 342
      j ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 347
    reportv(ctx___0, 0, (char *)".");
#line 336
    i___3 ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 349
  reportv(ctx___0, 0, (char *)"\n");
  }
#line 350
  return;
}
}
#line 352 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/mdl_load.c"
static void get_chunk_p0(struct xmp_context *ctx___0 , int size___0 , FILE *f ) 
{ 
  struct xmp_player_context *p ;
  struct xmp_mod_context *m___0 ;
  int i___3 ;
  int j ;
  uint16 x16 ;
  uint8 tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
  {
#line 354
  p = & ctx___0->p;
#line 355
  m___0 = & p->m;
#line 359
  tmp = read8(f);
#line 359
  (m___0->xxh)->pat = (int )tmp;
#line 360
  (m___0->xxh)->trk = (m___0->xxh)->pat * (m___0->xxh)->chn + 1;
  }
  {
#line 362
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 362
    tmp___0 = calloc((size_t )sizeof(struct xxm_track *), (size_t )(m___0->xxh)->trk);
#line 362
    m___0->xxt = (struct xxm_track **)tmp___0;
#line 362
    tmp___1 = calloc((size_t )sizeof(struct xxm_pattern *), (size_t )((m___0->xxh)->pat + 1));
#line 362
    m___0->xxp = (struct xxm_pattern **)tmp___1;
    }
#line 362
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 363
  reportv(ctx___0, 0, (char *)"Stored patterns: %d ", (m___0->xxh)->pat);
#line 365
  i___3 = 0;
  }
  {
#line 365
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 365
    if (! (i___3 < (m___0->xxh)->pat)) {
#line 365
      goto while_break___0;
    }
    {
#line 366
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 366
      tmp___2 = calloc((size_t )1, (size_t )(sizeof(struct xxm_pattern ) + sizeof(struct xxm_trackinfo ) * (unsigned long )((m___0->xxh)->chn - 1)));
#line 366
      *(m___0->xxp + i___3) = (struct xxm_pattern *)tmp___2;
      }
#line 366
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 367
    (*(m___0->xxp + i___3))->rows = 64;
#line 369
    j = 0;
    {
#line 369
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 369
      if (! (j < 32)) {
#line 369
        goto while_break___2;
      }
      {
#line 370
      x16 = read16l(f);
      }
#line 371
      if (j < (m___0->xxh)->chn) {
#line 372
        (*(m___0->xxp + i___3))->info[j].index = (int )x16;
      }
#line 369
      j ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 374
    reportv(ctx___0, 0, (char *)".");
#line 365
    i___3 ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 376
  reportv(ctx___0, 0, (char *)"\n");
  }
#line 377
  return;
}
}
#line 379 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/mdl_load.c"
static void get_chunk_tr(struct xmp_context *ctx___0 , int size___0 , FILE *f ) 
{ 
  struct xmp_player_context *p ;
  struct xmp_mod_context *m___0 ;
  int i___3 ;
  int j ;
  int k ;
  int row ;
  int len ;
  struct xxm_track *track ;
  uint16 tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  uint16 tmp___3 ;
  uint8 tmp___4 ;
  uint8 b___1 ;
  uint8 tmp___5 ;
  uint8 tmp___6 ;
  void *tmp___7 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;

  {
  {
#line 381
  p = & ctx___0->p;
#line 382
  m___0 = & p->m;
#line 386
  tmp = read16l(f);
#line 386
  (m___0->xxh)->trk = (int )tmp + 1;
#line 387
  tmp___0 = realloc((void *)m___0->xxt, (size_t )(sizeof(struct xxm_track *) * (unsigned long )(m___0->xxh)->trk));
#line 387
  m___0->xxt = (struct xxm_track **)tmp___0;
#line 389
  reportv(ctx___0, 0, (char *)"Stored tracks  : %d ", (m___0->xxh)->trk);
#line 391
  tmp___1 = calloc((size_t )1, (size_t )(sizeof(struct xxm_track ) + sizeof(struct xxm_event ) * 256UL));
#line 391
  track = (struct xxm_track *)tmp___1;
#line 395
  tmp___2 = calloc((size_t )1, (size_t )(sizeof(struct xxm_track ) + 256UL * sizeof(struct xxm_event )));
#line 395
  *(m___0->xxt + 0) = (struct xxm_track *)tmp___2;
#line 397
  (*(m___0->xxt + 0))->rows = 256;
#line 399
  i___3 = 1;
  }
  {
#line 399
  while (1) {
    while_continue: /* CIL Label */ ;
#line 399
    if (! (i___3 < (m___0->xxh)->trk)) {
#line 399
      goto while_break;
    }
    {
#line 401
    tmp___3 = read16l(f);
#line 401
    len = (int )tmp___3;
#line 403
    memset((void *)track, 0, (size_t )(sizeof(struct xxm_track ) + sizeof(struct xxm_event ) * 256UL));
#line 406
    row = 0;
    }
    {
#line 406
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 406
      if (! len) {
#line 406
        goto while_break___0;
      }
      {
#line 407
      tmp___4 = read8(f);
#line 407
      j = (int )tmp___4;
#line 408
      len --;
      }
      {
#line 410
      if ((j & 3) == 0) {
#line 410
        goto case_0;
      }
#line 413
      if ((j & 3) == 1) {
#line 413
        goto case_1;
      }
#line 419
      if ((j & 3) == 2) {
#line 419
        goto case_2;
      }
#line 423
      if ((j & 3) == 3) {
#line 423
        goto case_3;
      }
#line 409
      goto switch_break;
      case_0: /* CIL Label */ 
#line 411
      row += j >> 2;
#line 412
      goto switch_break;
      case_1: /* CIL Label */ 
#line 414
      k = 0;
      {
#line 414
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 414
        if (! (k <= j >> 2)) {
#line 414
          goto while_break___1;
        }
        {
#line 415
        memcpy((void */* __restrict  */)(& track->event[row + k]), (void const   */* __restrict  */)(& track->event[row - 1]),
               (size_t )sizeof(struct xxm_event ));
#line 414
        k ++;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 417
      row += k - 1;
#line 418
      goto switch_break;
      case_2: /* CIL Label */ 
      {
#line 420
      memcpy((void */* __restrict  */)(& track->event[row]), (void const   */* __restrict  */)(& track->event[j >> 2]),
             (size_t )sizeof(struct xxm_event ));
      }
#line 422
      goto switch_break;
      case_3: /* CIL Label */ 
#line 424
      if (j & 4) {
        {
#line 425
        tmp___5 = read8(f);
#line 425
        b___1 = tmp___5;
#line 426
        len --;
        }
#line 427
        if ((int )b___1 == 255) {
#line 427
          track->event[row].note = (uint8 )129;
        } else {
#line 427
          track->event[row].note = b___1;
        }
      }
#line 429
      if (j & 8) {
        {
#line 430
        len --;
#line 430
        track->event[row].ins = read8(f);
        }
      }
#line 431
      if (j & 16) {
        {
#line 432
        len --;
#line 432
        track->event[row].vol = read8(f);
        }
      }
#line 433
      if (j & 32) {
        {
#line 434
        len --;
#line 434
        tmp___6 = read8(f);
#line 434
        k = (int )tmp___6;
#line 435
        track->event[row].fxt = (uint8 )(k & 15);
#line 436
        track->event[row].f2t = (uint8 )((k & 240) >> 4);
        }
      }
#line 438
      if (j & 64) {
        {
#line 439
        len --;
#line 439
        track->event[row].fxp = read8(f);
        }
      }
#line 440
      if (j & 128) {
        {
#line 441
        len --;
#line 441
        track->event[row].f2p = read8(f);
        }
      }
#line 442
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
      {
#line 445
      xlat_fx1(& track->event[row].fxt, & track->event[row].fxp);
#line 446
      xlat_fx2(& track->event[row].f2t, & track->event[row].f2p);
#line 448
      row ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 451
    if (row <= 64) {
#line 452
      row = 64;
    } else
#line 453
    if (row <= 128) {
#line 454
      row = 128;
    } else {
#line 455
      row = 256;
    }
    {
#line 457
    tmp___7 = calloc((size_t )1, (size_t )(sizeof(struct xxm_track ) + sizeof(struct xxm_event ) * (unsigned long )row));
#line 457
    *(m___0->xxt + i___3) = (struct xxm_track *)tmp___7;
#line 459
    memcpy((void */* __restrict  */)*(m___0->xxt + i___3), (void const   */* __restrict  */)track,
           (size_t )(sizeof(struct xxm_track ) + sizeof(struct xxm_event ) * (unsigned long )row));
#line 461
    (*(m___0->xxt + i___3))->rows = row;
    }
#line 463
    if (m___0->verbosity > 0) {
#line 463
      if (! (i___3 % (m___0->xxh)->chn)) {
        {
#line 464
        report((char *)".");
        }
      }
    }
#line 399
    i___3 ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 467
  free((void *)track);
#line 469
  reportv(ctx___0, 0, (char *)"\n");
  }
#line 470
  return;
}
}
#line 472 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/mdl_load.c"
static void get_chunk_ii(struct xmp_context *ctx___0 , int size___0 , FILE *f ) 
{ 
  struct xmp_player_context *p ;
  struct xmp_mod_context *m___0 ;
  int i___3 ;
  int j ;
  int k ;
  int map ;
  int last_map ;
  uint8 tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  uint8 tmp___7 ;
  uint8 tmp___8 ;
  size_t tmp___9 ;
  void *tmp___10 ;
  int x ;
  uint8 tmp___11 ;
  uint8 tmp___12 ;
  uint8 tmp___13 ;
  uint8 tmp___14 ;
  uint8 tmp___15 ;
  uint8 tmp___16 ;
  uint16 tmp___17 ;
  uint8 tmp___18 ;
  uint8 tmp___19 ;
  uint8 tmp___20 ;
  uint8 tmp___21 ;
  uint8 tmp___22 ;
  char const   *tmp___23 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;

  {
  {
#line 474
  p = & ctx___0->p;
#line 475
  m___0 = & p->m;
#line 479
  tmp = read8(f);
#line 479
  (m___0->xxh)->ins = (int )tmp;
#line 480
  reportv(ctx___0, 0, (char *)"Instruments    : %d ", (m___0->xxh)->ins);
  }
  {
#line 482
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 482
    tmp___0 = calloc((size_t )sizeof(struct xxm_instrument_header ), (size_t )(m___0->xxh)->ins);
#line 482
    m___0->xxih = (struct xxm_instrument_header *)tmp___0;
#line 482
    tmp___1 = calloc((size_t )sizeof(struct xxm_instrument_map ), (size_t )(m___0->xxh)->ins);
#line 482
    m___0->xxim = (struct xxm_instrument_map *)tmp___1;
#line 482
    tmp___2 = calloc((size_t )sizeof(struct xxm_instrument *), (size_t )(m___0->xxh)->ins);
#line 482
    m___0->xxi = (struct xxm_instrument **)tmp___2;
    }
#line 482
    if ((m___0->xxh)->smp) {
      {
#line 482
      tmp___3 = calloc((size_t )sizeof(struct xxm_sample ), (size_t )(m___0->xxh)->smp);
#line 482
      m___0->xxs = (struct xxm_sample *)tmp___3;
      }
    }
    {
#line 482
    tmp___4 = calloc((size_t )sizeof(uint16 *), (size_t )(m___0->xxh)->ins);
#line 482
    m___0->xxae = (uint16 **)tmp___4;
#line 482
    tmp___5 = calloc((size_t )sizeof(uint16 *), (size_t )(m___0->xxh)->ins);
#line 482
    m___0->xxpe = (uint16 **)tmp___5;
#line 482
    tmp___6 = calloc((size_t )sizeof(uint16 *), (size_t )(m___0->xxh)->ins);
#line 482
    m___0->xxfe = (uint16 **)tmp___6;
    }
#line 482
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 484
  i___3 = 0;
  {
#line 484
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 484
    if (! (i___3 < (m___0->xxh)->ins)) {
#line 484
      goto while_break___0;
    }
    {
#line 485
    tmp___7 = read8(f);
#line 485
    *(i_index + i___3) = (int )tmp___7;
#line 486
    tmp___8 = read8(f);
#line 486
    (m___0->xxih + i___3)->nsm = (int )tmp___8;
#line 487
    fread((void */* __restrict  */)((m___0->xxih + i___3)->name), (size_t )1, (size_t )32,
          (FILE */* __restrict  */)f);
#line 488
    str_adj((char *)((m___0->xxih + i___3)->name));
    }
#line 490
    if (m___0->verbosity > 1) {
      {
#line 490
      tmp___9 = strlen((char const   *)((char *)((m___0->xxih + i___3)->name)));
      }
#line 490
      if (tmp___9) {
        {
#line 491
        report((char *)"\n[%2X] %-32.32s %2d ", *(i_index + i___3), (m___0->xxih + i___3)->name,
               (m___0->xxih + i___3)->nsm);
        }
      } else
#line 490
      if ((m___0->xxih + i___3)->nsm) {
        {
#line 491
        report((char *)"\n[%2X] %-32.32s %2d ", *(i_index + i___3), (m___0->xxih + i___3)->name,
               (m___0->xxih + i___3)->nsm);
        }
      }
    }
    {
#line 495
    tmp___10 = calloc((size_t )sizeof(struct xxm_instrument ), (size_t )(m___0->xxih + i___3)->nsm);
#line 495
    *(m___0->xxi + i___3) = (struct xxm_instrument *)tmp___10;
#line 497
    j = 0;
    }
    {
#line 497
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 497
      if (! (j < 108)) {
#line 497
        goto while_break___1;
      }
#line 498
      (m___0->xxim + i___3)->ins[j] = (uint8 )-1;
#line 497
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 500
    j = 0;
#line 500
    last_map = j;
    {
#line 500
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 500
      if (! (j < (m___0->xxih + i___3)->nsm)) {
#line 500
        goto while_break___2;
      }
      {
#line 503
      tmp___11 = read8(f);
#line 503
      (*(m___0->xxi + i___3) + j)->sid = (int )tmp___11;
#line 504
      tmp___12 = read8(f);
#line 504
      map = (int )tmp___12;
#line 505
      tmp___13 = read8(f);
#line 505
      (*(m___0->xxi + i___3) + j)->vol = (int )tmp___13;
#line 506
      k = last_map;
      }
      {
#line 506
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 506
        if (! (k <= map)) {
#line 506
          goto while_break___3;
        }
#line 507
        if (k < 108) {
#line 508
          (m___0->xxim + i___3)->ins[k] = (uint8 )j;
        }
#line 506
        k ++;
      }
      while_break___3: /* CIL Label */ ;
      }
      {
#line 510
      last_map = map + 1;
#line 512
      tmp___14 = read8(f);
#line 512
      x = (int )tmp___14;
      }
#line 513
      if (j == 0) {
#line 514
        if (x & 128) {
#line 514
          *(v_index + i___3) = x & 63;
        } else {
#line 514
          *(v_index + i___3) = -1;
        }
      }
#line 515
      if (~ x & 64) {
#line 516
        (*(m___0->xxi + i___3) + j)->vol = 255;
      }
      {
#line 518
      tmp___15 = read8(f);
#line 518
      (*(m___0->xxi + i___3) + j)->pan = (int )tmp___15 << 1;
#line 520
      tmp___16 = read8(f);
#line 520
      x = (int )tmp___16;
      }
#line 521
      if (j == 0) {
#line 522
        if (x & 128) {
#line 522
          *(p_index + i___3) = x & 63;
        } else {
#line 522
          *(p_index + i___3) = -1;
        }
      }
#line 523
      if (~ x & 64) {
#line 524
        (*(m___0->xxi + i___3) + j)->pan = 128;
      }
      {
#line 526
      tmp___17 = read16l(f);
#line 526
      x = (int )tmp___17;
      }
#line 527
      if (j == 0) {
#line 528
        (m___0->xxih + i___3)->rls = x;
      }
      {
#line 530
      tmp___18 = read8(f);
#line 530
      (*(m___0->xxi + i___3) + j)->vra = (int )tmp___18;
#line 531
      tmp___19 = read8(f);
#line 531
      (*(m___0->xxi + i___3) + j)->vde = (int )tmp___19;
#line 532
      tmp___20 = read8(f);
#line 532
      (*(m___0->xxi + i___3) + j)->vsw = (int )tmp___20;
#line 533
      tmp___21 = read8(f);
#line 533
      (*(m___0->xxi + i___3) + j)->vwf = (int )tmp___21;
#line 534
      read8(f);
#line 536
      tmp___22 = read8(f);
#line 536
      x = (int )tmp___22;
      }
#line 537
      if (j == 0) {
#line 538
        if (x & 128) {
#line 538
          *(f_index + i___3) = x & 63;
        } else {
#line 538
          *(f_index + i___3) = -1;
        }
      }
#line 540
      if (m___0->verbosity > 1) {
#line 541
        if (j) {
#line 541
          tmp___23 = "\n\t\t\t\t\t ";
        } else {
#line 541
          tmp___23 = "";
        }
        {
#line 541
        report((char *)"%s[%2x] V%02x S%02x  ", tmp___23, j, (*(m___0->xxi + i___3) + j)->vol,
               (*(m___0->xxi + i___3) + j)->sid);
        }
#line 543
        if (*(v_index + i___3) >= 0) {
          {
#line 544
          report((char *)"v%02x ", *(v_index + i___3));
          }
        } else {
          {
#line 546
          report((char *)"v-- ");
          }
        }
#line 547
        if (*(p_index + i___3) >= 0) {
          {
#line 548
          report((char *)"p%02x ", *(p_index + i___3));
          }
        } else {
          {
#line 550
          report((char *)"p-- ");
          }
        }
#line 551
        if (*(f_index + i___3) >= 0) {
          {
#line 552
          report((char *)"p%02x ", *(f_index + i___3));
          }
        } else {
          {
#line 554
          report((char *)"f-- ");
          }
        }
      } else
#line 555
      if ((m___0->verbosity > 0) == 1) {
        {
#line 556
        report((char *)".");
        }
      }
#line 500
      j ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 484
    i___3 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 559
  reportv(ctx___0, 0, (char *)"\n");
  }
#line 560
  return;
}
}
#line 562 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/mdl_load.c"
static void get_chunk_is(struct xmp_context *ctx___0 , int size___0 , FILE *f ) 
{ 
  struct xmp_player_context *p ;
  struct xmp_mod_context *m___0 ;
  int i___3 ;
  char buf___1[64] ;
  uint8 x ;
  uint8 tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  uint8 tmp___2 ;
  uint32 tmp___3 ;
  uint32 tmp___4 ;
  uint32 tmp___5 ;
  uint32 tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  void *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;

  {
  {
#line 564
  p = & ctx___0->p;
#line 565
  m___0 = & p->m;
#line 570
  tmp = read8(f);
#line 570
  (m___0->xxh)->smp = (int )tmp;
#line 571
  tmp___0 = calloc((size_t )sizeof(struct xxm_sample ), (size_t )(m___0->xxh)->smp);
#line 571
  m___0->xxs = (struct xxm_sample *)tmp___0;
#line 572
  tmp___1 = calloc((size_t )sizeof(int ), (size_t )(m___0->xxh)->smp);
#line 572
  packinfo = (int *)tmp___1;
#line 574
  reportv(ctx___0, 1, (char *)"Sample infos   : %d ", (m___0->xxh)->smp);
#line 576
  i___3 = 0;
  }
  {
#line 576
  while (1) {
    while_continue: /* CIL Label */ ;
#line 576
    if (! (i___3 < (m___0->xxh)->smp)) {
#line 576
      goto while_break;
    }
    {
#line 577
    tmp___2 = read8(f);
#line 577
    *(s_index + i___3) = (int )tmp___2;
#line 578
    fread((void */* __restrict  */)(buf___1), (size_t )1, (size_t )32, (FILE */* __restrict  */)f);
#line 579
    str_adj(buf___1);
#line 580
    reportv(ctx___0, 2, (char *)"\n[%2X] %-32.32s ", *(s_index + i___3), buf___1);
#line 581
    fseek(f, 8L, 1);
#line 583
    tmp___3 = read32l(f);
#line 583
    *(c2spd + i___3) = (int )tmp___3;
#line 585
    tmp___4 = read32l(f);
#line 585
    (m___0->xxs + i___3)->len = (int )tmp___4;
#line 586
    tmp___5 = read32l(f);
#line 586
    (m___0->xxs + i___3)->lps = (int )tmp___5;
#line 587
    tmp___6 = read32l(f);
#line 587
    (m___0->xxs + i___3)->lpe = (int )tmp___6;
    }
#line 589
    if ((m___0->xxs + i___3)->lpe > 0) {
#line 589
      (m___0->xxs + i___3)->flg = 4;
    } else {
#line 589
      (m___0->xxs + i___3)->flg = 0;
    }
#line 590
    (m___0->xxs + i___3)->lpe = (m___0->xxs + i___3)->lps + (m___0->xxs + i___3)->lpe;
#line 591
    if ((m___0->xxs + i___3)->lpe > 0) {
#line 592
      ((m___0->xxs + i___3)->lpe) --;
    }
    {
#line 594
    read8(f);
#line 595
    x = read8(f);
    }
#line 596
    if ((int )x & 1) {
#line 596
      tmp___7 = 1;
    } else {
#line 596
      tmp___7 = 0;
    }
#line 596
    (m___0->xxs + i___3)->flg |= tmp___7;
#line 597
    if ((int )x & 2) {
#line 597
      tmp___8 = 8;
    } else {
#line 597
      tmp___8 = 0;
    }
#line 597
    (m___0->xxs + i___3)->flg |= tmp___8;
#line 598
    *(packinfo + i___3) = ((int )x & 12) >> 2;
#line 600
    if (m___0->verbosity > 2) {
#line 601
      if ((m___0->xxs + i___3)->flg & 4) {
#line 601
        tmp___9 = 'L';
      } else {
#line 601
        tmp___9 = ' ';
      }
#line 601
      if ((m___0->xxs + i___3)->flg & 1) {
#line 601
        tmp___10 = '+';
      } else {
#line 601
        tmp___10 = ' ';
      }
      {
#line 601
      report((char *)"%05x%c %05x %05x %c %6d ", (m___0->xxs + i___3)->len, tmp___10,
             (m___0->xxs + i___3)->lps, (m___0->xxs + i___3)->lpe, tmp___9, *(c2spd + i___3));
      }
      {
#line 609
      if (*(packinfo + i___3) == 0) {
#line 609
        goto case_0;
      }
#line 612
      if (*(packinfo + i___3) == 1) {
#line 612
        goto case_1;
      }
#line 615
      if (*(packinfo + i___3) == 2) {
#line 615
        goto case_2;
      }
#line 618
      if (*(packinfo + i___3) == 3) {
#line 618
        goto case_3;
      }
#line 608
      goto switch_break;
      case_0: /* CIL Label */ 
      {
#line 610
      report((char *)"[nopack]");
      }
#line 611
      goto switch_break;
      case_1: /* CIL Label */ 
      {
#line 613
      report((char *)"[pack08]");
      }
#line 614
      goto switch_break;
      case_2: /* CIL Label */ 
      {
#line 616
      report((char *)"[pack16]");
      }
#line 617
      goto switch_break;
      case_3: /* CIL Label */ 
      {
#line 619
      report((char *)"[error ]");
      }
#line 620
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    } else {
      {
#line 623
      reportv(ctx___0, 1, (char *)".");
      }
    }
#line 576
    i___3 ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 626
  reportv(ctx___0, 1, (char *)"\n");
  }
#line 627
  return;
}
}
#line 629 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/mdl_load.c"
static void get_chunk_i0(struct xmp_context *ctx___0 , int size___0 , FILE *f ) 
{ 
  struct xmp_player_context *p ;
  struct xmp_mod_context *m___0 ;
  int i___3 ;
  char buf___1[64] ;
  uint8 x ;
  int tmp ;
  uint8 tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  void *tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  uint8 tmp___12 ;
  uint16 tmp___13 ;
  uint32 tmp___14 ;
  uint32 tmp___15 ;
  uint32 tmp___16 ;
  uint8 tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  void *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;

  {
  {
#line 631
  p = & ctx___0->p;
#line 632
  m___0 = & p->m;
#line 637
  tmp___0 = read8(f);
#line 637
  tmp = (int )tmp___0;
#line 637
  (m___0->xxh)->smp = tmp;
#line 637
  (m___0->xxh)->ins = tmp;
#line 639
  reportv(ctx___0, 0, (char *)"Instruments    : %d ", (m___0->xxh)->ins);
  }
  {
#line 641
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 641
    tmp___1 = calloc((size_t )sizeof(struct xxm_instrument_header ), (size_t )(m___0->xxh)->ins);
#line 641
    m___0->xxih = (struct xxm_instrument_header *)tmp___1;
#line 641
    tmp___2 = calloc((size_t )sizeof(struct xxm_instrument_map ), (size_t )(m___0->xxh)->ins);
#line 641
    m___0->xxim = (struct xxm_instrument_map *)tmp___2;
#line 641
    tmp___3 = calloc((size_t )sizeof(struct xxm_instrument *), (size_t )(m___0->xxh)->ins);
#line 641
    m___0->xxi = (struct xxm_instrument **)tmp___3;
    }
#line 641
    if ((m___0->xxh)->smp) {
      {
#line 641
      tmp___4 = calloc((size_t )sizeof(struct xxm_sample ), (size_t )(m___0->xxh)->smp);
#line 641
      m___0->xxs = (struct xxm_sample *)tmp___4;
      }
    }
    {
#line 641
    tmp___5 = calloc((size_t )sizeof(uint16 *), (size_t )(m___0->xxh)->ins);
#line 641
    m___0->xxae = (uint16 **)tmp___5;
#line 641
    tmp___6 = calloc((size_t )sizeof(uint16 *), (size_t )(m___0->xxh)->ins);
#line 641
    m___0->xxpe = (uint16 **)tmp___6;
#line 641
    tmp___7 = calloc((size_t )sizeof(uint16 *), (size_t )(m___0->xxh)->ins);
#line 641
    m___0->xxfe = (uint16 **)tmp___7;
    }
#line 641
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 643
  tmp___8 = calloc((size_t )sizeof(int ), (size_t )(m___0->xxh)->smp);
#line 643
  packinfo = (int *)tmp___8;
#line 645
  i___3 = 0;
  }
  {
#line 645
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 645
    if (! (i___3 < (m___0->xxh)->ins)) {
#line 645
      goto while_break___0;
    }
    {
#line 646
    (m___0->xxih + i___3)->nsm = 1;
#line 647
    tmp___9 = calloc((size_t )sizeof(struct xxm_instrument ), (size_t )1);
#line 647
    *(m___0->xxi + i___3) = (struct xxm_instrument *)tmp___9;
#line 648
    tmp___12 = read8(f);
#line 648
    tmp___11 = (int )tmp___12;
#line 648
    *(s_index + i___3) = tmp___11;
#line 648
    tmp___10 = tmp___11;
#line 648
    *(i_index + i___3) = tmp___10;
#line 648
    (*(m___0->xxi + i___3) + 0)->sid = tmp___10;
#line 650
    fread((void */* __restrict  */)(buf___1), (size_t )1, (size_t )32, (FILE */* __restrict  */)f);
#line 651
    str_adj(buf___1);
#line 652
    reportv(ctx___0, 1, (char *)"\n[%2X] %-32.32s ", *(i_index + i___3), buf___1);
#line 653
    fseek(f, 8L, 1);
#line 655
    tmp___13 = read16l(f);
#line 655
    *(c2spd + i___3) = (int )tmp___13;
#line 657
    tmp___14 = read32l(f);
#line 657
    (m___0->xxs + i___3)->len = (int )tmp___14;
#line 658
    tmp___15 = read32l(f);
#line 658
    (m___0->xxs + i___3)->lps = (int )tmp___15;
#line 659
    tmp___16 = read32l(f);
#line 659
    (m___0->xxs + i___3)->lpe = (int )tmp___16;
    }
#line 661
    if ((m___0->xxs + i___3)->lpe > 0) {
#line 661
      (m___0->xxs + i___3)->flg = 4;
    } else {
#line 661
      (m___0->xxs + i___3)->flg = 0;
    }
    {
#line 662
    (m___0->xxs + i___3)->lpe = (m___0->xxs + i___3)->lps + (m___0->xxs + i___3)->lpe;
#line 664
    tmp___17 = read8(f);
#line 664
    (*(m___0->xxi + i___3) + 0)->vol = (int )tmp___17;
#line 665
    (*(m___0->xxi + i___3) + 0)->pan = 128;
#line 667
    x = read8(f);
    }
#line 668
    if ((int )x & 1) {
#line 668
      tmp___18 = 1;
    } else {
#line 668
      tmp___18 = 0;
    }
#line 668
    (m___0->xxs + i___3)->flg |= tmp___18;
#line 669
    if ((int )x & 2) {
#line 669
      tmp___19 = 8;
    } else {
#line 669
      tmp___19 = 0;
    }
#line 669
    (m___0->xxs + i___3)->flg |= tmp___19;
#line 670
    *(packinfo + i___3) = ((int )x & 12) >> 2;
#line 672
    if (m___0->verbosity > 1) {
#line 673
      if ((m___0->xxs + i___3)->flg & 1) {
#line 673
        tmp___20 = '+';
      } else {
#line 673
        tmp___20 = ' ';
      }
      {
#line 673
      report((char *)"%5d V%02x %05x%c %05x %05x ", *(c2spd + i___3), (*(m___0->xxi + i___3) + 0)->vol,
             (m___0->xxs + i___3)->len, tmp___20, (m___0->xxs + i___3)->lps, (m___0->xxs + i___3)->lpe);
      }
      {
#line 678
      if (*(packinfo + i___3) == 0) {
#line 678
        goto case_0;
      }
#line 681
      if (*(packinfo + i___3) == 1) {
#line 681
        goto case_1;
      }
#line 684
      if (*(packinfo + i___3) == 2) {
#line 684
        goto case_2;
      }
#line 687
      if (*(packinfo + i___3) == 3) {
#line 687
        goto case_3;
      }
#line 677
      goto switch_break;
      case_0: /* CIL Label */ 
      {
#line 679
      report((char *)"[nopack]");
      }
#line 680
      goto switch_break;
      case_1: /* CIL Label */ 
      {
#line 682
      report((char *)"[pack08]");
      }
#line 683
      goto switch_break;
      case_2: /* CIL Label */ 
      {
#line 685
      report((char *)"[pack16]");
      }
#line 686
      goto switch_break;
      case_3: /* CIL Label */ 
      {
#line 688
      report((char *)"[error ]");
      }
#line 689
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    } else {
      {
#line 692
      reportv(ctx___0, 0, (char *)".");
      }
    }
#line 645
    i___3 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 695
  reportv(ctx___0, 0, (char *)"\n");
  }
#line 696
  return;
}
}
#line 698 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/mdl_load.c"
static void get_chunk_sa(struct xmp_context *ctx___0 , int size___0 , FILE *f ) 
{ 
  struct xmp_player_context *p ;
  struct xmp_mod_context *m___0 ;
  struct xmp_options *o___0 ;
  int i___3 ;
  int len ;
  uint8 *smpbuf ;
  uint8 *buf___1 ;
  int tmp ;
  void *tmp___0 ;
  uint32 tmp___1 ;
  void *tmp___2 ;
  uint32 tmp___3 ;
  void *tmp___4 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;

  {
#line 700
  p = & ctx___0->p;
#line 701
  m___0 = & p->m;
#line 702
  o___0 = & ctx___0->o;
#line 706
  if (o___0->skipsmp) {
#line 707
    return;
  }
  {
#line 709
  reportv(ctx___0, 0, (char *)"Stored samples : %d ", (m___0->xxh)->smp);
#line 711
  i___3 = 0;
  }
  {
#line 711
  while (1) {
    while_continue: /* CIL Label */ ;
#line 711
    if (! (i___3 < (m___0->xxh)->smp)) {
#line 711
      goto while_break;
    }
#line 712
    if ((m___0->xxs + i___3)->flg & 1) {
#line 712
      tmp = (m___0->xxs + i___3)->len << 1;
    } else {
#line 712
      tmp = (m___0->xxs + i___3)->len;
    }
    {
#line 712
    tmp___0 = calloc((size_t )1, (size_t )tmp);
#line 712
    smpbuf = (uint8 *)tmp___0;
    }
    {
#line 716
    if (*(packinfo + i___3) == 0) {
#line 716
      goto case_0;
    }
#line 719
    if (*(packinfo + i___3) == 1) {
#line 719
      goto case_1;
    }
#line 726
    if (*(packinfo + i___3) == 2) {
#line 726
      goto case_2;
    }
#line 715
    goto switch_break;
    case_0: /* CIL Label */ 
    {
#line 717
    fread((void */* __restrict  */)smpbuf, (size_t )1, (size_t )(m___0->xxs + i___3)->len,
          (FILE */* __restrict  */)f);
    }
#line 718
    goto switch_break;
    case_1: /* CIL Label */ 
    {
#line 720
    tmp___1 = read32l(f);
#line 720
    len = (int )tmp___1;
#line 721
    tmp___2 = malloc((size_t )(len + 4));
#line 721
    buf___1 = (uint8 *)tmp___2;
#line 722
    fread((void */* __restrict  */)buf___1, (size_t )1, (size_t )len, (FILE */* __restrict  */)f);
#line 723
    unpack_sample8(smpbuf, buf___1, len, (m___0->xxs + i___3)->len);
#line 724
    free((void *)buf___1);
    }
#line 725
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 727
    tmp___3 = read32l(f);
#line 727
    len = (int )tmp___3;
#line 728
    tmp___4 = malloc((size_t )(len + 4));
#line 728
    buf___1 = (uint8 *)tmp___4;
#line 729
    fread((void */* __restrict  */)buf___1, (size_t )1, (size_t )len, (FILE */* __restrict  */)f);
#line 730
    unpack_sample16(smpbuf, buf___1, len, (m___0->xxs + i___3)->len >> 1);
#line 731
    free((void *)buf___1);
    }
#line 732
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
    {
#line 735
    xmp_drv_loadpatch(ctx___0, (FILE *)((void *)0), i___3, m___0->c4rate, 16, m___0->xxs + i___3,
                      (char *)smpbuf);
#line 738
    free((void *)smpbuf);
#line 740
    reportv(ctx___0, 0, (char *)".");
#line 711
    i___3 ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 742
  reportv(ctx___0, 0, (char *)"\n");
#line 744
  free((void *)packinfo);
  }
#line 745
  return;
}
}
#line 747 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/mdl_load.c"
static void get_chunk_ve(struct xmp_context *ctx___0 , int size___0 , FILE *f ) 
{ 
  int i___3 ;
  uint8 tmp ;
  void *tmp___0 ;
  char *__cil_tmp7 ;

  {
  {
#line 751
  tmp = read8(f);
#line 751
  v_envnum = (int )tmp;
  }
#line 751
  if (v_envnum == 0) {
#line 752
    return;
  }
  {
#line 754
  reportv(ctx___0, 1, (char *)"Vol envelopes  : %d\n", v_envnum);
#line 756
  tmp___0 = calloc((size_t )v_envnum, (size_t )sizeof(struct mdl_envelope ));
#line 756
  v_env = (struct mdl_envelope *)tmp___0;
#line 758
  i___3 = 0;
  }
  {
#line 758
  while (1) {
    while_continue: /* CIL Label */ ;
#line 758
    if (! (i___3 < v_envnum)) {
#line 758
      goto while_break;
    }
    {
#line 759
    (v_env + i___3)->num = read8(f);
#line 760
    fread((void */* __restrict  */)((v_env + i___3)->data), (size_t )1, (size_t )30,
          (FILE */* __restrict  */)f);
#line 761
    (v_env + i___3)->sus = read8(f);
#line 762
    (v_env + i___3)->loop = read8(f);
#line 758
    i___3 ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 764
  return;
}
}
#line 766 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/mdl_load.c"
static void get_chunk_pe(struct xmp_context *ctx___0 , int size___0 , FILE *f ) 
{ 
  int i___3 ;
  uint8 tmp ;
  void *tmp___0 ;
  char *__cil_tmp7 ;

  {
  {
#line 770
  tmp = read8(f);
#line 770
  p_envnum = (int )tmp;
  }
#line 770
  if (p_envnum == 0) {
#line 771
    return;
  }
  {
#line 773
  reportv(ctx___0, 1, (char *)"Pan envelopes  : %d\n", p_envnum);
#line 775
  tmp___0 = calloc((size_t )p_envnum, (size_t )sizeof(struct mdl_envelope ));
#line 775
  p_env = (struct mdl_envelope *)tmp___0;
#line 777
  i___3 = 0;
  }
  {
#line 777
  while (1) {
    while_continue: /* CIL Label */ ;
#line 777
    if (! (i___3 < p_envnum)) {
#line 777
      goto while_break;
    }
    {
#line 778
    (p_env + i___3)->num = read8(f);
#line 779
    fread((void */* __restrict  */)((p_env + i___3)->data), (size_t )1, (size_t )30,
          (FILE */* __restrict  */)f);
#line 780
    (p_env + i___3)->sus = read8(f);
#line 781
    (p_env + i___3)->loop = read8(f);
#line 777
    i___3 ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 783
  return;
}
}
#line 785 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/mdl_load.c"
static void get_chunk_fe(struct xmp_context *ctx___0 , int size___0 , FILE *f ) 
{ 
  int i___3 ;
  uint8 tmp ;
  void *tmp___0 ;
  char *__cil_tmp7 ;

  {
  {
#line 789
  tmp = read8(f);
#line 789
  f_envnum = (int )tmp;
  }
#line 789
  if (f_envnum == 0) {
#line 790
    return;
  }
  {
#line 792
  reportv(ctx___0, 1, (char *)"Pitch envelopes: %d\n", f_envnum);
#line 794
  tmp___0 = calloc((size_t )f_envnum, (size_t )sizeof(struct mdl_envelope ));
#line 794
  f_env = (struct mdl_envelope *)tmp___0;
#line 796
  i___3 = 0;
  }
  {
#line 796
  while (1) {
    while_continue: /* CIL Label */ ;
#line 796
    if (! (i___3 < f_envnum)) {
#line 796
      goto while_break;
    }
    {
#line 797
    (f_env + i___3)->num = read8(f);
#line 798
    fread((void */* __restrict  */)((f_env + i___3)->data), (size_t )1, (size_t )30,
          (FILE */* __restrict  */)f);
#line 799
    (f_env + i___3)->sus = read8(f);
#line 800
    (f_env + i___3)->loop = read8(f);
#line 796
    i___3 ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 802
  return;
}
}
#line 805 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/mdl_load.c"
static int mdl_load(struct xmp_context *ctx___0 , FILE *f , int const   start ) 
{ 
  struct xmp_player_context *p ;
  struct xmp_mod_context *m___0 ;
  int i___3 ;
  int j ;
  int k ;
  int l ;
  char buf___1[8] ;
  uint8 **tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  void *tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  void *tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  void *tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  void *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;

  {
#line 807
  p = & ctx___0->p;
#line 808
  m___0 = & p->m;
  {
#line 812
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 812
    fseek(f, (long )start, 0);
#line 812
    tmp = (uint8 **)((void *)0);
#line 812
    m___0->med_wav_table = tmp;
#line 812
    m___0->med_vol_table = tmp;
#line 812
    set_xxh_defaults(m___0->xxh);
    }
#line 812
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 815
  read32b(f);
#line 816
  fread((void */* __restrict  */)(buf___1), (size_t )1, (size_t )1, (FILE */* __restrict  */)f);
#line 819
  iff_register((char *)"IN", & get_chunk_in);
#line 820
  iff_register((char *)"TR", & get_chunk_tr);
#line 821
  iff_register((char *)"SA", & get_chunk_sa);
#line 822
  iff_register((char *)"VE", & get_chunk_ve);
#line 823
  iff_register((char *)"PE", & get_chunk_pe);
#line 824
  iff_register((char *)"FE", & get_chunk_fe);
  }
#line 826
  if (((int )buf___1[0] & 240) >> 4) {
    {
#line 827
    iff_register((char *)"II", & get_chunk_ii);
#line 828
    iff_register((char *)"PA", & get_chunk_pa);
#line 829
    iff_register((char *)"IS", & get_chunk_is);
    }
  } else {
    {
#line 831
    iff_register((char *)"PA", & get_chunk_p0);
#line 832
    iff_register((char *)"IS", & get_chunk_i0);
    }
  }
  {
#line 839
  iff_idsize(2);
#line 840
  iff_setflag(1);
#line 842
  sprintf((char */* __restrict  */)(m___0->type), (char const   */* __restrict  */)"DMDL %d.%d (Digitrakker)",
          ((int )buf___1[0] & 240) >> 4, (int )buf___1[0] & 15);
#line 844
  m___0->volbase = 255;
#line 845
  m___0->c4rate = 8363;
#line 847
  f_envnum = 0;
#line 847
  p_envnum = f_envnum;
#line 847
  v_envnum = p_envnum;
#line 848
  tmp___0 = calloc((size_t )256, (size_t )sizeof(int ));
#line 848
  s_index = (int *)tmp___0;
#line 849
  tmp___1 = calloc((size_t )256, (size_t )sizeof(int ));
#line 849
  i_index = (int *)tmp___1;
#line 850
  tmp___2 = malloc((size_t )(256UL * sizeof(int )));
#line 850
  v_index = (int *)tmp___2;
#line 851
  tmp___3 = malloc((size_t )(256UL * sizeof(int )));
#line 851
  p_index = (int *)tmp___3;
#line 852
  tmp___4 = malloc((size_t )(256UL * sizeof(int )));
#line 852
  f_index = (int *)tmp___4;
#line 853
  tmp___5 = calloc((size_t )256, (size_t )sizeof(int ));
#line 853
  c2spd = (int *)tmp___5;
#line 855
  i___3 = 0;
  }
  {
#line 855
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 855
    if (! (i___3 < 256)) {
#line 855
      goto while_break___0;
    }
#line 856
    tmp___7 = -1;
#line 856
    *(f_index + i___3) = tmp___7;
#line 856
    tmp___6 = tmp___7;
#line 856
    *(p_index + i___3) = tmp___6;
#line 856
    *(v_index + i___3) = tmp___6;
#line 855
    i___3 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 860
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 860
    tmp___8 = feof(f);
    }
#line 860
    if (tmp___8) {
#line 860
      goto while_break___1;
    }
    {
#line 861
    iff_chunk(ctx___0, f);
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 863
  iff_release();
#line 869
  i___3 = 0;
  }
  {
#line 869
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 869
    if (! (i___3 < (m___0->xxh)->pat)) {
#line 869
      goto while_break___2;
    }
#line 870
    j = 0;
    {
#line 870
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 870
      if (! (j < (*(m___0->xxp + i___3))->rows)) {
#line 870
        goto while_break___3;
      }
#line 871
      k = 0;
      {
#line 871
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 871
        if (! (k < (m___0->xxh)->chn)) {
#line 871
          goto while_break___4;
        }
#line 872
        l = 0;
        {
#line 872
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 872
          if (! (l < (m___0->xxh)->ins)) {
#line 872
            goto while_break___5;
          }
#line 873
          if (j >= (*(m___0->xxt + (*(m___0->xxp + i___3))->info[k].index))->rows) {
#line 874
            goto __Cont;
          }
#line 876
          if ((*(m___0->xxt + (*(m___0->xxp + i___3))->info[k].index))->event[j].ins) {
#line 876
            if ((int )(*(m___0->xxt + (*(m___0->xxp + i___3))->info[k].index))->event[j].ins == *(i_index + l)) {
#line 877
              (*(m___0->xxt + (*(m___0->xxp + i___3))->info[k].index))->event[j].ins = (uint8 )(l + 1);
#line 878
              goto while_break___5;
            }
          }
          __Cont: /* CIL Label */ 
#line 872
          l ++;
        }
        while_break___5: /* CIL Label */ ;
        }
#line 871
        k ++;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 870
      j ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 869
    i___3 ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 882
  i___3 = 0;
  {
#line 882
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 882
    if (! (i___3 < (m___0->xxh)->ins)) {
#line 882
      goto while_break___6;
    }
#line 887
    if (*(v_index + i___3) >= 0) {
      {
#line 888
      (m___0->xxih + i___3)->aei.flg = 1;
#line 889
      (m___0->xxih + i___3)->aei.npt = 16;
#line 890
      tmp___9 = calloc((size_t )4, (size_t )(m___0->xxih + i___3)->aei.npt);
#line 890
      *(m___0->xxae + i___3) = (uint16 *)tmp___9;
#line 892
      j = 0;
      }
      {
#line 892
      while (1) {
        while_continue___7: /* CIL Label */ ;
#line 892
        if (! (j < v_envnum)) {
#line 892
          goto while_break___7;
        }
#line 893
        if (*(v_index + i___3) == j) {
#line 894
          if ((int )(v_env + j)->sus & 16) {
#line 894
            tmp___10 = 2;
          } else {
#line 894
            tmp___10 = 0;
          }
#line 894
          (m___0->xxih + i___3)->aei.flg |= tmp___10;
#line 895
          if ((int )(v_env + j)->sus & 32) {
#line 895
            tmp___11 = 4;
          } else {
#line 895
            tmp___11 = 0;
          }
#line 895
          (m___0->xxih + i___3)->aei.flg |= tmp___11;
#line 896
          (m___0->xxih + i___3)->aei.sus = (int )(v_env + j)->sus & 15;
#line 897
          (m___0->xxih + i___3)->aei.lps = (int )(v_env + j)->loop & 15;
#line 898
          (m___0->xxih + i___3)->aei.lpe = (int )(v_env + j)->loop & 240;
#line 899
          *(*(m___0->xxae + i___3) + 0) = (uint16 )0;
#line 900
          k = 1;
          {
#line 900
          while (1) {
            while_continue___8: /* CIL Label */ ;
#line 900
            if (! (k < (m___0->xxih + i___3)->aei.npt)) {
#line 900
              goto while_break___8;
            }
#line 901
            *(*(m___0->xxae + i___3) + k * 2) = (uint16 )((int )*(*(m___0->xxae + i___3) + (k - 1) * 2) + (int )(v_env + j)->data[(k - 1) * 2]);
#line 903
            if ((int )(v_env + j)->data[k * 2] == 0) {
#line 904
              goto while_break___8;
            }
#line 905
            *(*(m___0->xxae + i___3) + (k * 2 + 1)) = (uint16 )(v_env + j)->data[(k - 1) * 2 + 1];
#line 900
            k ++;
          }
          while_break___8: /* CIL Label */ ;
          }
#line 907
          (m___0->xxih + i___3)->aei.npt = k;
#line 908
          goto while_break___7;
        }
#line 892
        j ++;
      }
      while_break___7: /* CIL Label */ ;
      }
    }
#line 914
    if (*(p_index + i___3) >= 0) {
      {
#line 915
      (m___0->xxih + i___3)->pei.flg = 1;
#line 916
      (m___0->xxih + i___3)->pei.npt = 16;
#line 917
      tmp___12 = calloc((size_t )4, (size_t )(m___0->xxih + i___3)->pei.npt);
#line 917
      *(m___0->xxpe + i___3) = (uint16 *)tmp___12;
#line 919
      j = 0;
      }
      {
#line 919
      while (1) {
        while_continue___9: /* CIL Label */ ;
#line 919
        if (! (j < p_envnum)) {
#line 919
          goto while_break___9;
        }
#line 920
        if (*(p_index + i___3) == j) {
#line 921
          if ((int )(p_env + j)->sus & 16) {
#line 921
            tmp___13 = 2;
          } else {
#line 921
            tmp___13 = 0;
          }
#line 921
          (m___0->xxih + i___3)->pei.flg |= tmp___13;
#line 922
          if ((int )(p_env + j)->sus & 32) {
#line 922
            tmp___14 = 4;
          } else {
#line 922
            tmp___14 = 0;
          }
#line 922
          (m___0->xxih + i___3)->pei.flg |= tmp___14;
#line 923
          (m___0->xxih + i___3)->pei.sus = (int )(p_env + j)->sus & 15;
#line 924
          (m___0->xxih + i___3)->pei.lps = (int )(p_env + j)->loop & 15;
#line 925
          (m___0->xxih + i___3)->pei.lpe = (int )(p_env + j)->loop & 240;
#line 926
          *(*(m___0->xxpe + i___3) + 0) = (uint16 )0;
#line 928
          k = 1;
          {
#line 928
          while (1) {
            while_continue___10: /* CIL Label */ ;
#line 928
            if (! (k < (m___0->xxih + i___3)->pei.npt)) {
#line 928
              goto while_break___10;
            }
#line 929
            *(*(m___0->xxpe + i___3) + k * 2) = (uint16 )((int )*(*(m___0->xxpe + i___3) + (k - 1) * 2) + (int )(p_env + j)->data[(k - 1) * 2]);
#line 931
            if ((int )(p_env + j)->data[k * 2] == 0) {
#line 932
              goto while_break___10;
            }
#line 933
            *(*(m___0->xxpe + i___3) + (k * 2 + 1)) = (uint16 )(p_env + j)->data[(k - 1) * 2 + 1];
#line 928
            k ++;
          }
          while_break___10: /* CIL Label */ ;
          }
#line 935
          (m___0->xxih + i___3)->pei.npt = k;
#line 936
          goto while_break___9;
        }
#line 919
        j ++;
      }
      while_break___9: /* CIL Label */ ;
      }
    }
#line 942
    if (*(f_index + i___3) >= 0) {
      {
#line 943
      (m___0->xxih + i___3)->fei.flg = 1;
#line 944
      (m___0->xxih + i___3)->fei.npt = 16;
#line 945
      tmp___15 = calloc((size_t )4, (size_t )(m___0->xxih + i___3)->fei.npt);
#line 945
      *(m___0->xxfe + i___3) = (uint16 *)tmp___15;
#line 947
      j = 0;
      }
      {
#line 947
      while (1) {
        while_continue___11: /* CIL Label */ ;
#line 947
        if (! (j < f_envnum)) {
#line 947
          goto while_break___11;
        }
#line 948
        if (*(f_index + i___3) == j) {
#line 949
          if ((int )(f_env + j)->sus & 16) {
#line 949
            tmp___16 = 2;
          } else {
#line 949
            tmp___16 = 0;
          }
#line 949
          (m___0->xxih + i___3)->fei.flg |= tmp___16;
#line 950
          if ((int )(f_env + j)->sus & 32) {
#line 950
            tmp___17 = 4;
          } else {
#line 950
            tmp___17 = 0;
          }
#line 950
          (m___0->xxih + i___3)->fei.flg |= tmp___17;
#line 951
          (m___0->xxih + i___3)->fei.sus = (int )(f_env + j)->sus & 15;
#line 952
          (m___0->xxih + i___3)->fei.lps = (int )(f_env + j)->loop & 15;
#line 953
          (m___0->xxih + i___3)->fei.lpe = (int )(f_env + j)->loop & 240;
#line 954
          *(*(m___0->xxfe + i___3) + 0) = (uint16 )0;
#line 955
          *(*(m___0->xxfe + i___3) + 1) = (uint16 )32;
#line 957
          k = 1;
          {
#line 957
          while (1) {
            while_continue___12: /* CIL Label */ ;
#line 957
            if (! (k < (m___0->xxih + i___3)->fei.npt)) {
#line 957
              goto while_break___12;
            }
#line 958
            *(*(m___0->xxfe + i___3) + k * 2) = (uint16 )((int )*(*(m___0->xxfe + i___3) + (k - 1) * 2) + (int )(f_env + j)->data[(k - 1) * 2]);
#line 960
            if ((int )(f_env + j)->data[k * 2] == 0) {
#line 961
              goto while_break___12;
            }
#line 962
            *(*(m___0->xxfe + i___3) + (k * 2 + 1)) = (uint16 )((int )(f_env + j)->data[(k - 1) * 2 + 1] * 4);
#line 957
            k ++;
          }
          while_break___12: /* CIL Label */ ;
          }
#line 965
          (m___0->xxih + i___3)->fei.npt = k;
#line 966
          goto while_break___11;
        }
#line 947
        j ++;
      }
      while_break___11: /* CIL Label */ ;
      }
    }
#line 971
    j = 0;
    {
#line 971
    while (1) {
      while_continue___13: /* CIL Label */ ;
#line 971
      if (! (j < (m___0->xxih + i___3)->nsm)) {
#line 971
        goto while_break___13;
      }
#line 972
      k = 0;
      {
#line 972
      while (1) {
        while_continue___14: /* CIL Label */ ;
#line 972
        if (! (k < (m___0->xxh)->smp)) {
#line 972
          goto while_break___14;
        }
#line 973
        if ((*(m___0->xxi + i___3) + j)->sid == *(s_index + k)) {
          {
#line 974
          (*(m___0->xxi + i___3) + j)->sid = k;
#line 975
          c2spd_to_note(*(c2spd + k), & (*(m___0->xxi + i___3) + j)->xpo, & (*(m___0->xxi + i___3) + j)->fin);
          }
#line 976
          goto while_break___14;
        }
#line 972
        k ++;
      }
      while_break___14: /* CIL Label */ ;
      }
#line 971
      j ++;
    }
    while_break___13: /* CIL Label */ ;
    }
#line 882
    i___3 ++;
  }
  while_break___6: /* CIL Label */ ;
  }
  {
#line 980
  free((void *)c2spd);
#line 981
  free((void *)f_index);
#line 982
  free((void *)p_index);
#line 983
  free((void *)v_index);
#line 984
  free((void *)i_index);
#line 985
  free((void *)s_index);
  }
#line 987
  if (v_envnum) {
    {
#line 988
    free((void *)v_env);
    }
  }
#line 989
  if (p_envnum) {
    {
#line 990
    free((void *)p_env);
    }
  }
#line 991
  if (f_envnum) {
    {
#line 992
    free((void *)f_env);
    }
  }
#line 994
  m___0->quirk |= 1 << 12;
#line 996
  return (0);
}
}
#line 26 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/ult_load.c"
static int ult_test(FILE *f , char *t , int const   start ) ;
#line 27
static int ult_load(struct xmp_context *ctx___0 , FILE *f , int const   start ) ;
#line 29 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/ult_load.c"
struct xmp_loader_info ult_loader  =    {(char *)"ULT", (char *)"Ultra Tracker", & ult_test, & ult_load, 0, {(struct list_head *)0,
                                                                        (struct list_head *)0}};
#line 36 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/ult_load.c"
static int ult_test(FILE *f , char *t , int const   start ) 
{ 
  char buf___1[15] ;
  int tmp ;
  void *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
  {
#line 40
  fread((void */* __restrict  */)(buf___1), (size_t )1, (size_t )15, (FILE */* __restrict  */)f);
#line 41
  tmp = memcmp((void const   *)(buf___1), (void const   *)"MAS_UTrack_V000", (size_t )14);
  }
#line 41
  if (tmp) {
#line 42
    return (-1);
  }
#line 44
  if ((int )buf___1[14] < 48) {
#line 45
    return (-1);
  } else
#line 44
  if ((int )buf___1[14] > 52) {
#line 45
    return (-1);
  }
  {
#line 47
  read_title(f, t, 32);
  }
#line 49
  return (0);
}
}
#line 89 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/ult_load.c"
static char *verstr[4]  = {      (char *)"< 1.4",      (char *)"1.4",      (char *)"1.5",      (char *)"1.6"};
#line 94 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/ult_load.c"
static int ult_load(struct xmp_context *ctx___0 , FILE *f , int const   start ) 
{ 
  struct xmp_player_context *p ;
  struct xmp_mod_context *m___0 ;
  int i___3 ;
  int j ;
  int k ;
  int ver___0 ;
  int cnt ;
  struct xxm_event *event ;
  struct ult_header ufh ;
  struct ult_header2 ufh2 ;
  struct ult_instrument uih ;
  struct ult_event ue ;
  int keep_porta1 ;
  int keep_porta2 ;
  uint8 x8 ;
  uint8 **tmp ;
  int tmp___0 ;
  uint8 tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  void *tmp___9 ;
  uint16 tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  size_t tmp___13 ;
  void *tmp___14 ;
  void *tmp___15 ;
  void *tmp___16 ;
  int j___0 ;
  void *tmp___17 ;
  uint8 tmp___18 ;
  uint8 tmp___19 ;
  uint8 tmp___20 ;
  void *__cil_tmp42 ;
  void *__cil_tmp43 ;
  void *__cil_tmp44 ;
  void *__cil_tmp45 ;
  void *__cil_tmp46 ;
  void *__cil_tmp47 ;
  void *__cil_tmp48 ;
  void *__cil_tmp49 ;
  void *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;

  {
#line 96
  p = & ctx___0->p;
#line 97
  m___0 = & p->m;
#line 104
  keep_porta1 = 0;
#line 104
  keep_porta2 = 0;
  {
#line 107
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 107
    fseek(f, (long )start, 0);
#line 107
    tmp = (uint8 **)((void *)0);
#line 107
    m___0->med_wav_table = tmp;
#line 107
    m___0->med_vol_table = tmp;
#line 107
    set_xxh_defaults(m___0->xxh);
    }
#line 107
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 109
  fread((void */* __restrict  */)(& ufh.magic), (size_t )15, (size_t )1, (FILE */* __restrict  */)f);
#line 110
  fread((void */* __restrict  */)(& ufh.name), (size_t )32, (size_t )1, (FILE */* __restrict  */)f);
#line 111
  ufh.msgsize = read8(f);
#line 113
  ver___0 = (int )ufh.magic[14] - 48;
#line 115
  strncpy((char */* __restrict  */)(m___0->name), (char const   */* __restrict  */)((char *)(ufh.name)),
          (size_t )32);
#line 116
  ufh.name[0] = (uint8 )0;
#line 117
  sprintf((char */* __restrict  */)(m___0->type), (char const   */* __restrict  */)"ULT V%04d (Ultra Tracker %s)",
          ver___0, verstr[ver___0 - 1]);
  }
  {
#line 119
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 119
    if (m___0->verbosity) {
#line 119
      if (m___0->name[0]) {
        {
#line 119
        report((char *)"Module title   : %s\n", m___0->name);
        }
      }
#line 119
      if (m___0->type[0]) {
        {
#line 119
        report((char *)"Module type    : %s\n", m___0->type);
        }
      }
#line 119
      if (m___0->author[0]) {
        {
#line 119
        report((char *)"Author name    : %s\n", m___0->author);
        }
      }
#line 119
      if ((m___0->xxh)->len) {
        {
#line 119
        report((char *)"Module length  : %d patterns\n", (m___0->xxh)->len);
        }
      }
    }
#line 119
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 121
  fseek(f, (long )((int )ufh.msgsize * 32), 1);
#line 123
  tmp___1 = read8(f);
#line 123
  tmp___0 = (int )tmp___1;
#line 123
  (m___0->xxh)->smp = tmp___0;
#line 123
  (m___0->xxh)->ins = tmp___0;
  }
  {
#line 128
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 128
    tmp___2 = calloc((size_t )sizeof(struct xxm_instrument_header ), (size_t )(m___0->xxh)->ins);
#line 128
    m___0->xxih = (struct xxm_instrument_header *)tmp___2;
#line 128
    tmp___3 = calloc((size_t )sizeof(struct xxm_instrument_map ), (size_t )(m___0->xxh)->ins);
#line 128
    m___0->xxim = (struct xxm_instrument_map *)tmp___3;
#line 128
    tmp___4 = calloc((size_t )sizeof(struct xxm_instrument *), (size_t )(m___0->xxh)->ins);
#line 128
    m___0->xxi = (struct xxm_instrument **)tmp___4;
    }
#line 128
    if ((m___0->xxh)->smp) {
      {
#line 128
      tmp___5 = calloc((size_t )sizeof(struct xxm_sample ), (size_t )(m___0->xxh)->smp);
#line 128
      m___0->xxs = (struct xxm_sample *)tmp___5;
      }
    }
    {
#line 128
    tmp___6 = calloc((size_t )sizeof(uint16 *), (size_t )(m___0->xxh)->ins);
#line 128
    m___0->xxae = (uint16 **)tmp___6;
#line 128
    tmp___7 = calloc((size_t )sizeof(uint16 *), (size_t )(m___0->xxh)->ins);
#line 128
    m___0->xxpe = (uint16 **)tmp___7;
#line 128
    tmp___8 = calloc((size_t )sizeof(uint16 *), (size_t )(m___0->xxh)->ins);
#line 128
    m___0->xxfe = (uint16 **)tmp___8;
    }
#line 128
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 130
  reportv(ctx___0, 1, (char *)"Instruments    : %d ", (m___0->xxh)->ins);
#line 132
  i___3 = 0;
  }
  {
#line 132
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 132
    if (! (i___3 < (m___0->xxh)->ins)) {
#line 132
      goto while_break___2;
    }
    {
#line 133
    tmp___9 = calloc((size_t )sizeof(struct xxm_instrument ), (size_t )1);
#line 133
    *(m___0->xxi + i___3) = (struct xxm_instrument *)tmp___9;
#line 135
    fread((void */* __restrict  */)(& uih.name), (size_t )32, (size_t )1, (FILE */* __restrict  */)f);
#line 136
    fread((void */* __restrict  */)(& uih.dosname), (size_t )12, (size_t )1, (FILE */* __restrict  */)f);
#line 137
    uih.loop_start = read32l(f);
#line 138
    uih.loopend = read32l(f);
#line 139
    uih.sizestart = read32l(f);
#line 140
    uih.sizeend = read32l(f);
#line 141
    uih.volume = read8(f);
#line 142
    uih.bidiloop = read8(f);
#line 143
    uih.finetune = read16l(f);
    }
#line 144
    if (ver___0 < 4) {
#line 144
      uih.c2spd = (uint16 )0;
    } else {
      {
#line 144
      tmp___10 = read16l(f);
#line 144
      uih.c2spd = tmp___10;
      }
    }
#line 146
    if (ver___0 > 3) {
#line 147
      uih.c2spd = (uint16 )((int )uih.c2spd ^ (int )uih.finetune);
#line 148
      uih.finetune = (uint16 )((int )uih.finetune ^ (int )uih.c2spd);
#line 149
      uih.c2spd = (uint16 )((int )uih.c2spd ^ (int )uih.finetune);
    }
#line 151
    (m___0->xxs + i___3)->len = (int )(uih.sizeend - uih.sizestart);
#line 152
    (m___0->xxih + i___3)->nsm = ! (! (m___0->xxs + i___3)->len);
#line 153
    (m___0->xxs + i___3)->lps = (int )uih.loop_start;
#line 154
    (m___0->xxs + i___3)->lpe = (int )uih.loopend;
    {
#line 176
    if ((int )uih.bidiloop == 4) {
#line 176
      goto case_4;
    }
#line 176
    if ((int )uih.bidiloop == 20) {
#line 176
      goto case_4;
    }
#line 181
    if ((int )uih.bidiloop == 24) {
#line 181
      goto case_24;
    }
#line 181
    if ((int )uih.bidiloop == 8) {
#line 181
      goto case_24;
    }
#line 185
    if ((int )uih.bidiloop == 28) {
#line 185
      goto case_28;
    }
#line 185
    if ((int )uih.bidiloop == 12) {
#line 185
      goto case_28;
    }
#line 174
    goto switch_break;
    case_4: /* CIL Label */ 
    case_20: /* CIL Label */ 
#line 177
    (m___0->xxs + i___3)->flg = 1;
#line 178
    (m___0->xxs + i___3)->len <<= 1;
#line 179
    goto switch_break;
    case_24: /* CIL Label */ 
    case_8: /* CIL Label */ 
#line 182
    (m___0->xxs + i___3)->flg = 4;
#line 183
    goto switch_break;
    case_28: /* CIL Label */ 
    case_12: /* CIL Label */ 
#line 186
    (m___0->xxs + i___3)->flg = 5;
#line 187
    (m___0->xxs + i___3)->len <<= 1;
#line 188
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
    {
#line 192
    (*(m___0->xxi + i___3) + 0)->vol = (int )uih.volume;
#line 193
    (*(m___0->xxi + i___3) + 0)->pan = 128;
#line 194
    (*(m___0->xxi + i___3) + 0)->sid = i___3;
#line 196
    copy_adjust((m___0->xxih + i___3)->name, uih.name, 24);
    }
#line 198
    if (m___0->verbosity > 1) {
      {
#line 198
      tmp___13 = strlen((char const   *)((char *)(uih.name)));
      }
#line 198
      if (tmp___13) {
#line 198
        goto _L;
      } else
#line 198
      if ((m___0->xxs + i___3)->len) {
        _L: /* CIL Label */ 
#line 199
        if ((m___0->xxs + i___3)->flg & 4) {
#line 199
          tmp___11 = 'L';
        } else {
#line 199
          tmp___11 = ' ';
        }
#line 199
        if ((m___0->xxs + i___3)->flg & 1) {
#line 199
          tmp___12 = '+';
        } else {
#line 199
          tmp___12 = ' ';
        }
        {
#line 199
        report((char *)"\n[%2X] %-32.32s %05x%c%05x %05x %c V%02x F%04x %5d", i___3,
               uih.name, (m___0->xxs + i___3)->len, tmp___12, (m___0->xxs + i___3)->lps,
               (m___0->xxs + i___3)->lpe, tmp___11, (*(m___0->xxi + i___3) + 0)->vol,
               (int )uih.finetune, (int )uih.c2spd);
        }
      }
    }
#line 207
    if (ver___0 > 3) {
      {
#line 208
      c2spd_to_note((int )uih.c2spd, & (*(m___0->xxi + i___3) + 0)->xpo, & (*(m___0->xxi + i___3) + 0)->fin);
      }
    }
#line 132
    i___3 ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 211
  reportv(ctx___0, 1, (char *)"\n");
#line 213
  fread((void */* __restrict  */)(& ufh2.order), (size_t )256, (size_t )1, (FILE */* __restrict  */)f);
#line 214
  ufh2.channels = read8(f);
#line 215
  ufh2.patterns = read8(f);
#line 217
  i___3 = 0;
  }
  {
#line 217
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 217
    if (! (i___3 < 256)) {
#line 217
      goto while_break___3;
    }
#line 218
    if ((int )ufh2.order[i___3] == 255) {
#line 219
      goto while_break___3;
    }
#line 220
    m___0->xxo[i___3] = ufh2.order[i___3];
#line 217
    i___3 ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 222
  (m___0->xxh)->len = i___3;
#line 223
  (m___0->xxh)->chn = (int )ufh2.channels + 1;
#line 224
  (m___0->xxh)->pat = (int )ufh2.patterns + 1;
#line 225
  (m___0->xxh)->tpo = 6;
#line 226
  (m___0->xxh)->bpm = 125;
#line 227
  (m___0->xxh)->trk = (m___0->xxh)->chn * (m___0->xxh)->pat;
#line 229
  i___3 = 0;
  {
#line 229
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 229
    if (! (i___3 < (m___0->xxh)->chn)) {
#line 229
      goto while_break___4;
    }
#line 230
    if (ver___0 >= 3) {
      {
#line 231
      x8 = read8(f);
#line 232
      m___0->xxc[i___3].pan = (255 * (int )x8) / 15;
      }
    } else {
#line 234
      m___0->xxc[i___3].pan = (((i___3 + 1) / 2) % 2) * 255;
    }
#line 229
    i___3 ++;
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 238
  while (1) {
    while_continue___5: /* CIL Label */ ;
    {
#line 238
    tmp___14 = calloc((size_t )sizeof(struct xxm_track *), (size_t )(m___0->xxh)->trk);
#line 238
    m___0->xxt = (struct xxm_track **)tmp___14;
#line 238
    tmp___15 = calloc((size_t )sizeof(struct xxm_pattern *), (size_t )((m___0->xxh)->pat + 1));
#line 238
    m___0->xxp = (struct xxm_pattern **)tmp___15;
    }
#line 238
    goto while_break___5;
  }
  while_break___5: /* CIL Label */ ;
  }
#line 242
  if (m___0->verbosity > 0) {
    {
#line 243
    report((char *)"Stored patterns: %d ", (m___0->xxh)->pat);
    }
  }
#line 246
  i___3 = 0;
  {
#line 246
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 246
    if (! (i___3 < (m___0->xxh)->pat)) {
#line 246
      goto while_break___6;
    }
    {
#line 247
    while (1) {
      while_continue___7: /* CIL Label */ ;
      {
#line 247
      tmp___16 = calloc((size_t )1, (size_t )(sizeof(struct xxm_pattern ) + sizeof(struct xxm_trackinfo ) * (unsigned long )((m___0->xxh)->chn - 1)));
#line 247
      *(m___0->xxp + i___3) = (struct xxm_pattern *)tmp___16;
      }
#line 247
      goto while_break___7;
    }
    while_break___7: /* CIL Label */ ;
    }
#line 248
    (*(m___0->xxp + i___3))->rows = 64;
    {
#line 249
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 249
      j___0 = 0;
      {
#line 249
      while (1) {
        while_continue___9: /* CIL Label */ ;
#line 249
        if (! (j___0 < (m___0->xxh)->chn)) {
#line 249
          goto while_break___9;
        }
        {
#line 249
        (*(m___0->xxp + i___3))->info[j___0].index = i___3 * (m___0->xxh)->chn + j___0;
#line 249
        tmp___17 = calloc((size_t )(sizeof(struct xxm_track ) + sizeof(struct xxm_event ) * (unsigned long )(*(m___0->xxp + i___3))->rows),
                          (size_t )1);
#line 249
        *(m___0->xxt + (i___3 * (m___0->xxh)->chn + j___0)) = (struct xxm_track *)tmp___17;
#line 249
        (*(m___0->xxt + (i___3 * (m___0->xxh)->chn + j___0)))->rows = (*(m___0->xxp + i___3))->rows;
#line 249
        j___0 ++;
        }
      }
      while_break___9: /* CIL Label */ ;
      }
#line 249
      goto while_break___8;
    }
    while_break___8: /* CIL Label */ ;
    }
#line 246
    i___3 ++;
  }
  while_break___6: /* CIL Label */ ;
  }
#line 252
  i___3 = 0;
  {
#line 252
  while (1) {
    while_continue___10: /* CIL Label */ ;
#line 252
    if (! (i___3 < (m___0->xxh)->chn)) {
#line 252
      goto while_break___10;
    }
#line 253
    j = 0;
    {
#line 253
    while (1) {
      while_continue___11: /* CIL Label */ ;
#line 253
      if (! (j < 64 * (m___0->xxh)->pat)) {
#line 253
        goto while_break___11;
      }
      {
#line 254
      cnt = 1;
#line 255
      x8 = read8(f);
      }
#line 256
      if ((int )x8 == 252) {
        {
#line 257
        tmp___18 = read8(f);
#line 257
        cnt = (int )tmp___18;
#line 258
        x8 = read8(f);
        }
      }
      {
#line 260
      fread((void */* __restrict  */)(& ue), (size_t )4, (size_t )1, (FILE */* __restrict  */)f);
      }
#line 262
      if (cnt == 0) {
#line 263
        cnt ++;
      }
#line 265
      k = 0;
      {
#line 265
      while (1) {
        while_continue___12: /* CIL Label */ ;
#line 265
        if (! (k < cnt)) {
#line 265
          goto while_break___12;
        }
        {
#line 266
        event = & (*(m___0->xxt + (*(m___0->xxp + (j >> 6)))->info[i___3].index))->event[j & 63];
#line 267
        memset((void *)event, 0, (size_t )sizeof(struct xxm_event ));
        }
#line 268
        if (x8) {
#line 269
          event->note = (uint8 )((int )x8 + 24);
        }
#line 270
        event->ins = ue.ins;
#line 271
        event->fxt = (uint8 )(((int )ue.fxt & 240) >> 4);
#line 272
        event->f2t = (uint8 )((int )ue.fxt & 15);
#line 273
        event->fxp = ue.fxp;
#line 274
        event->f2p = ue.f2p;
        {
#line 277
        if ((int )event->fxt == 0) {
#line 277
          goto case_0;
        }
#line 285
        if ((int )event->fxt == 3) {
#line 285
          goto case_3;
        }
#line 289
        if ((int )event->fxt == 6) {
#line 289
          goto case_6;
        }
#line 289
        if ((int )event->fxt == 5) {
#line 289
          goto case_6;
        }
#line 292
        if ((int )event->fxt == 11) {
#line 292
          goto case_11;
        }
#line 296
        if ((int )event->fxt == 9) {
#line 296
          goto case_9;
        }
#line 276
        goto switch_break___0;
        case_0: /* CIL Label */ 
#line 278
        if (event->fxp) {
#line 279
          keep_porta1 = 0;
        }
#line 280
        if (keep_porta1) {
#line 281
          event->fxt = (uint8 )3;
#line 282
          keep_porta1 --;
        }
#line 284
        goto switch_break___0;
        case_3: /* CIL Label */ 
#line 286
        keep_porta1 = 32;
#line 287
        goto switch_break___0;
        case_6: /* CIL Label */ 
        case_5: /* CIL Label */ 
#line 290
        tmp___19 = (uint8 )0;
#line 290
        event->fxp = tmp___19;
#line 290
        event->fxt = tmp___19;
#line 291
        goto switch_break___0;
        case_11: /* CIL Label */ 
#line 293
        event->fxt = (uint8 )8;
#line 294
        event->fxp = (uint8 )((int )event->fxp << 4);
#line 295
        goto switch_break___0;
        case_9: /* CIL Label */ 
#line 298
        event->fxp = (uint8 )((int )event->fxp << 2);
#line 299
        goto switch_break___0;
        switch_break___0: /* CIL Label */ ;
        }
        {
#line 303
        if ((int )event->f2t == 0) {
#line 303
          goto case_0___0;
        }
#line 311
        if ((int )event->f2t == 3) {
#line 311
          goto case_3___0;
        }
#line 315
        if ((int )event->f2t == 6) {
#line 315
          goto case_6___0;
        }
#line 315
        if ((int )event->f2t == 5) {
#line 315
          goto case_6___0;
        }
#line 318
        if ((int )event->f2t == 11) {
#line 318
          goto case_11___0;
        }
#line 322
        if ((int )event->f2t == 9) {
#line 322
          goto case_9___0;
        }
#line 302
        goto switch_break___1;
        case_0___0: /* CIL Label */ 
#line 304
        if (event->f2p) {
#line 305
          keep_porta2 = 0;
        }
#line 306
        if (keep_porta2) {
#line 307
          event->f2t = (uint8 )3;
#line 308
          keep_porta2 --;
        }
#line 310
        goto switch_break___1;
        case_3___0: /* CIL Label */ 
#line 312
        keep_porta2 = 32;
#line 313
        goto switch_break___1;
        case_6___0: /* CIL Label */ 
        case_5___0: /* CIL Label */ 
#line 316
        tmp___20 = (uint8 )0;
#line 316
        event->f2p = tmp___20;
#line 316
        event->f2t = tmp___20;
#line 317
        goto switch_break___1;
        case_11___0: /* CIL Label */ 
#line 319
        event->f2t = (uint8 )8;
#line 320
        event->f2p = (uint8 )((int )event->f2p << 4);
#line 321
        goto switch_break___1;
        case_9___0: /* CIL Label */ 
#line 324
        event->f2p = (uint8 )((int )event->f2p << 2);
#line 325
        goto switch_break___1;
        switch_break___1: /* CIL Label */ ;
        }
#line 265
        k ++;
#line 265
        j ++;
      }
      while_break___12: /* CIL Label */ ;
      }
#line 329
      if (m___0->verbosity > 0) {
#line 329
        if (j % (64 * (m___0->xxh)->chn) == 0) {
          {
#line 330
          report((char *)".");
          }
        }
      }
    }
    while_break___11: /* CIL Label */ ;
    }
#line 252
    i___3 ++;
  }
  while_break___10: /* CIL Label */ ;
  }
  {
#line 334
  reportv(ctx___0, 0, (char *)"\nStored samples : %d ", (m___0->xxh)->smp);
#line 336
  i___3 = 0;
  }
  {
#line 336
  while (1) {
    while_continue___13: /* CIL Label */ ;
#line 336
    if (! (i___3 < (m___0->xxh)->ins)) {
#line 336
      goto while_break___13;
    }
#line 337
    if (! (m___0->xxs + i___3)->len) {
#line 338
      goto __Cont;
    }
    {
#line 339
    xmp_drv_loadpatch(ctx___0, f, i___3, m___0->c4rate, 0, m___0->xxs + i___3, (char *)((void *)0));
#line 340
    reportv(ctx___0, 0, (char *)".");
    }
    __Cont: /* CIL Label */ 
#line 336
    i___3 ++;
  }
  while_break___13: /* CIL Label */ ;
  }
  {
#line 342
  reportv(ctx___0, 0, (char *)"\n");
#line 344
  m___0->volbase = 256;
  }
#line 346
  return (0);
}
}
#line 15 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/rad_load.c"
static int rad_test(FILE *f , char *t , int const   start ) ;
#line 16
static int rad_load(struct xmp_context *ctx___0 , FILE *f , int const   start ) ;
#line 18 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/rad_load.c"
struct xmp_loader_info rad_loader  =    {(char *)"RAD", (char *)"Reality Adlib Tracker", & rad_test, & rad_load, 0, {(struct list_head *)0,
                                                                                (struct list_head *)0}};
#line 25 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/rad_load.c"
static int rad_test(FILE *f , char *t , int const   start ) 
{ 
  char buf___1[16] ;
  int tmp ;
  void *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
  {
#line 29
  fread((void */* __restrict  */)(buf___1), (size_t )1, (size_t )16, (FILE */* __restrict  */)f);
#line 30
  tmp = memcmp((void const   *)(buf___1), (void const   *)"RAD by REALiTY!!", (size_t )16);
  }
#line 30
  if (tmp) {
#line 31
    return (-1);
  }
  {
#line 33
  read_title(f, t, 0);
  }
#line 35
  return (0);
}
}
#line 44 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/rad_load.c"
static int rad_load(struct xmp_context *ctx___0 , FILE *f , int const   start ) 
{ 
  struct xmp_player_context *p ;
  struct xmp_mod_context *m___0 ;
  struct xxm_event *event ;
  int i___3 ;
  int j ;
  uint8 sid[11] ;
  uint16 ppat[32] ;
  uint8 b___1 ;
  uint8 r ;
  uint8 c___0 ;
  uint8 version ;
  uint8 flags ;
  uint8 **tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  void *tmp___8 ;
  void *tmp___9 ;
  void *tmp___10 ;
  void *tmp___11 ;
  void *tmp___12 ;
  void *tmp___13 ;
  void *tmp___14 ;
  void *tmp___15 ;
  uint8 tmp___16 ;
  int tmp___17 ;
  void *tmp___18 ;
  void *tmp___19 ;
  void *tmp___20 ;
  int j___0 ;
  void *tmp___21 ;
  void *__cil_tmp40 ;
  void *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;
  char *__cil_tmp66 ;
  char *__cil_tmp67 ;
  char *__cil_tmp68 ;
  char *__cil_tmp69 ;
  char *__cil_tmp70 ;
  char *__cil_tmp71 ;
  char *__cil_tmp72 ;

  {
#line 46
  p = & ctx___0->p;
#line 47
  m___0 = & p->m;
  {
#line 56
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 56
    fseek(f, (long )start, 0);
#line 56
    tmp = (uint8 **)((void *)0);
#line 56
    m___0->med_wav_table = tmp;
#line 56
    m___0->med_vol_table = tmp;
#line 56
    set_xxh_defaults(m___0->xxh);
    }
#line 56
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 58
  fseek(f, 16L, 0);
#line 59
  version = read8(f);
#line 60
  flags = read8(f);
#line 62
  (m___0->xxh)->chn = 9;
#line 63
  (m___0->xxh)->bpm = 125;
#line 64
  (m___0->xxh)->tpo = (int )flags & 31;
#line 65
  (m___0->xxh)->flg = 1;
  }
#line 67
  if ((m___0->xxh)->tpo <= 2) {
#line 68
    (m___0->xxh)->tpo = 6;
  }
  {
#line 69
  (m___0->xxh)->smp = 0;
#line 71
  sprintf((char */* __restrict  */)(m___0->type), (char const   */* __restrict  */)"RAD %d.%d (Reality Adlib Tracker)",
          ((int )version & 240) >> 4, (int )version & 15);
  }
  {
#line 74
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 74
    if (m___0->verbosity) {
#line 74
      if (m___0->name[0]) {
        {
#line 74
        report((char *)"Module title   : %s\n", m___0->name);
        }
      }
#line 74
      if (m___0->type[0]) {
        {
#line 74
        report((char *)"Module type    : %s\n", m___0->type);
        }
      }
#line 74
      if (m___0->author[0]) {
        {
#line 74
        report((char *)"Author name    : %s\n", m___0->author);
        }
      }
#line 74
      if ((m___0->xxh)->len) {
        {
#line 74
        report((char *)"Module length  : %d patterns\n", (m___0->xxh)->len);
        }
      }
    }
#line 74
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 77
  if ((int )flags & 128) {
    {
#line 78
    reportv(ctx___0, 1, (char *)"|");
    }
    {
#line 79
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 79
      b___1 = read8(f);
      }
#line 79
      if (! ((int )b___1 != 0)) {
#line 79
        goto while_break___1;
      }
#line 80
      if (m___0->verbosity > 1) {
#line 81
        if ((int )b___1 == 1) {
          {
#line 82
          report((char *)"\n|");
          }
        } else
#line 83
        if ((int )b___1 < 32) {
#line 84
          i___3 = 0;
          {
#line 84
          while (1) {
            while_continue___2: /* CIL Label */ ;
#line 84
            if (! (i___3 < (int )b___1)) {
#line 84
              goto while_break___2;
            }
            {
#line 85
            report((char *)" ");
#line 84
            i___3 ++;
            }
          }
          while_break___2: /* CIL Label */ ;
          }
        } else
#line 86
        if ((int )b___1 < 128) {
          {
#line 87
          report((char *)"%c", (int )b___1);
          }
        } else {
          {
#line 89
          report((char *)".");
          }
        }
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 93
    reportv(ctx___0, 1, (char *)"\n");
    }
  }
  {
#line 96
  reportv(ctx___0, 1, (char *)"               Modulator                       Carrier             Common\n     Char Fr LS OL At De Su Re WS   Char Fr LS OL At De Su Re WS   Fbk Alg\n");
#line 102
  (m___0->xxh)->ins = 0;
  }
  {
#line 104
  while (1) {
    while_continue___3: /* CIL Label */ ;
    {
#line 104
    b___1 = read8(f);
    }
#line 104
    if (! ((int )b___1 != 0)) {
#line 104
      goto while_break___3;
    }
    {
#line 105
    (m___0->xxh)->ins = (int )b___1;
#line 107
    fread((void */* __restrict  */)(sid), (size_t )1, (size_t )11, (FILE */* __restrict  */)f);
#line 108
    xmp_cvt_hsc2sbi((char *)(sid));
    }
#line 109
    if (m___0->verbosity > 1) {
      {
#line 110
      report((char *)"[%2X] ", (int )b___1 - 1);
      }
#line 112
      if ((int )sid[0] & 16) {
#line 112
        tmp___0 = 'e';
      } else {
#line 112
        tmp___0 = '-';
      }
#line 112
      if ((int )sid[0] & 32) {
#line 112
        tmp___1 = 's';
      } else {
#line 112
        tmp___1 = '-';
      }
#line 112
      if ((int )sid[0] & 64) {
#line 112
        tmp___2 = 'v';
      } else {
#line 112
        tmp___2 = '-';
      }
#line 112
      if ((int )sid[0] & 128) {
#line 112
        tmp___3 = 'a';
      } else {
#line 112
        tmp___3 = '-';
      }
      {
#line 112
      report((char *)"%c%c%c%c %2d ", tmp___3, tmp___2, tmp___1, tmp___0, (int )sid[0] & 15);
#line 117
      report((char *)"%2d %2d ", (int )sid[2] >> 6, (int )sid[2] & 63);
#line 118
      report((char *)"%2d %2d ", (int )sid[4] >> 4, (int )sid[4] & 15);
#line 119
      report((char *)"%2d %2d ", (int )sid[6] >> 4, (int )sid[6] & 15);
#line 120
      report((char *)"%2d   ", (int )sid[8]);
      }
#line 122
      if ((int )sid[1] & 16) {
#line 122
        tmp___4 = 'e';
      } else {
#line 122
        tmp___4 = '-';
      }
#line 122
      if ((int )sid[1] & 32) {
#line 122
        tmp___5 = 's';
      } else {
#line 122
        tmp___5 = '-';
      }
#line 122
      if ((int )sid[1] & 64) {
#line 122
        tmp___6 = 'v';
      } else {
#line 122
        tmp___6 = '-';
      }
#line 122
      if ((int )sid[1] & 128) {
#line 122
        tmp___7 = 'a';
      } else {
#line 122
        tmp___7 = '-';
      }
      {
#line 122
      report((char *)"%c%c%c%c %2d ", tmp___7, tmp___6, tmp___5, tmp___4, (int )sid[1] & 15);
#line 127
      report((char *)"%2d %2d ", (int )sid[3] >> 6, (int )sid[3] & 63);
#line 128
      report((char *)"%2d %2d ", (int )sid[5] >> 4, (int )sid[5] & 15);
#line 129
      report((char *)"%2d %2d ", (int )sid[7] >> 4, (int )sid[7] & 15);
#line 130
      report((char *)"%2d   ", (int )sid[9]);
#line 132
      report((char *)"%2d  %2d\n", (int )sid[10] >> 1, (int )sid[10] & 1);
      }
    }
    {
#line 134
    xmp_drv_loadpatch(ctx___0, f, (int )b___1 - 1, 0, 0, (struct xxm_sample *)((void *)0),
                      (char *)(sid));
    }
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 137
  while (1) {
    while_continue___4: /* CIL Label */ ;
    {
#line 137
    tmp___8 = calloc((size_t )sizeof(struct xxm_instrument_header ), (size_t )(m___0->xxh)->ins);
#line 137
    m___0->xxih = (struct xxm_instrument_header *)tmp___8;
#line 137
    tmp___9 = calloc((size_t )sizeof(struct xxm_instrument_map ), (size_t )(m___0->xxh)->ins);
#line 137
    m___0->xxim = (struct xxm_instrument_map *)tmp___9;
#line 137
    tmp___10 = calloc((size_t )sizeof(struct xxm_instrument *), (size_t )(m___0->xxh)->ins);
#line 137
    m___0->xxi = (struct xxm_instrument **)tmp___10;
    }
#line 137
    if ((m___0->xxh)->smp) {
      {
#line 137
      tmp___11 = calloc((size_t )sizeof(struct xxm_sample ), (size_t )(m___0->xxh)->smp);
#line 137
      m___0->xxs = (struct xxm_sample *)tmp___11;
      }
    }
    {
#line 137
    tmp___12 = calloc((size_t )sizeof(uint16 *), (size_t )(m___0->xxh)->ins);
#line 137
    m___0->xxae = (uint16 **)tmp___12;
#line 137
    tmp___13 = calloc((size_t )sizeof(uint16 *), (size_t )(m___0->xxh)->ins);
#line 137
    m___0->xxpe = (uint16 **)tmp___13;
#line 137
    tmp___14 = calloc((size_t )sizeof(uint16 *), (size_t )(m___0->xxh)->ins);
#line 137
    m___0->xxfe = (uint16 **)tmp___14;
    }
#line 137
    goto while_break___4;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 139
  i___3 = 0;
  {
#line 139
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 139
    if (! (i___3 < (m___0->xxh)->ins)) {
#line 139
      goto while_break___5;
    }
    {
#line 140
    tmp___15 = calloc((size_t )sizeof(struct xxm_instrument ), (size_t )1);
#line 140
    *(m___0->xxi + i___3) = (struct xxm_instrument *)tmp___15;
#line 141
    (m___0->xxih + i___3)->nsm = 1;
#line 142
    (*(m___0->xxi + i___3) + 0)->vol = 64;
#line 143
    (*(m___0->xxi + i___3) + 0)->pan = 128;
#line 144
    (*(m___0->xxi + i___3) + 0)->xpo = -1;
#line 145
    (*(m___0->xxi + i___3) + 0)->sid = i___3;
#line 139
    i___3 ++;
    }
  }
  while_break___5: /* CIL Label */ ;
  }
  {
#line 149
  tmp___16 = read8(f);
#line 149
  (m___0->xxh)->len = (int )tmp___16;
#line 151
  i___3 = 0;
#line 151
  j = i___3;
  }
  {
#line 151
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 151
    if (! (i___3 < (m___0->xxh)->len)) {
#line 151
      goto while_break___6;
    }
    {
#line 152
    b___1 = read8(f);
    }
#line 153
    if ((int )b___1 < 128) {
#line 154
      tmp___17 = j;
#line 154
      j ++;
#line 154
      m___0->xxo[tmp___17] = b___1;
    }
#line 151
    i___3 ++;
  }
  while_break___6: /* CIL Label */ ;
  }
#line 158
  i___3 = 0;
#line 158
  (m___0->xxh)->pat = i___3;
  {
#line 158
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 158
    if (! (i___3 < 32)) {
#line 158
      goto while_break___7;
    }
    {
#line 159
    ppat[i___3] = read16l(f);
    }
#line 160
    if (ppat[i___3]) {
#line 161
      ((m___0->xxh)->pat) ++;
    }
#line 158
    i___3 ++;
  }
  while_break___7: /* CIL Label */ ;
  }
#line 163
  (m___0->xxh)->trk = (m___0->xxh)->pat * (m___0->xxh)->chn;
#line 165
  if (m___0->verbosity > 0) {
    {
#line 166
    report((char *)"Module length  : %d patterns\n", (m___0->xxh)->len);
#line 167
    report((char *)"Instruments    : %d\n", (m___0->xxh)->ins);
#line 168
    report((char *)"Stored patterns: %d ", (m___0->xxh)->pat);
    }
  }
  {
#line 170
  while (1) {
    while_continue___8: /* CIL Label */ ;
    {
#line 170
    tmp___18 = calloc((size_t )sizeof(struct xxm_track *), (size_t )(m___0->xxh)->trk);
#line 170
    m___0->xxt = (struct xxm_track **)tmp___18;
#line 170
    tmp___19 = calloc((size_t )sizeof(struct xxm_pattern *), (size_t )((m___0->xxh)->pat + 1));
#line 170
    m___0->xxp = (struct xxm_pattern **)tmp___19;
    }
#line 170
    goto while_break___8;
  }
  while_break___8: /* CIL Label */ ;
  }
#line 173
  i___3 = 0;
  {
#line 173
  while (1) {
    while_continue___9: /* CIL Label */ ;
#line 173
    if (! (i___3 < (m___0->xxh)->pat)) {
#line 173
      goto while_break___9;
    }
    {
#line 174
    while (1) {
      while_continue___10: /* CIL Label */ ;
      {
#line 174
      tmp___20 = calloc((size_t )1, (size_t )(sizeof(struct xxm_pattern ) + sizeof(struct xxm_trackinfo ) * (unsigned long )((m___0->xxh)->chn - 1)));
#line 174
      *(m___0->xxp + i___3) = (struct xxm_pattern *)tmp___20;
      }
#line 174
      goto while_break___10;
    }
    while_break___10: /* CIL Label */ ;
    }
#line 175
    (*(m___0->xxp + i___3))->rows = 64;
    {
#line 176
    while (1) {
      while_continue___11: /* CIL Label */ ;
#line 176
      j___0 = 0;
      {
#line 176
      while (1) {
        while_continue___12: /* CIL Label */ ;
#line 176
        if (! (j___0 < (m___0->xxh)->chn)) {
#line 176
          goto while_break___12;
        }
        {
#line 176
        (*(m___0->xxp + i___3))->info[j___0].index = i___3 * (m___0->xxh)->chn + j___0;
#line 176
        tmp___21 = calloc((size_t )(sizeof(struct xxm_track ) + sizeof(struct xxm_event ) * (unsigned long )(*(m___0->xxp + i___3))->rows),
                          (size_t )1);
#line 176
        *(m___0->xxt + (i___3 * (m___0->xxh)->chn + j___0)) = (struct xxm_track *)tmp___21;
#line 176
        (*(m___0->xxt + (i___3 * (m___0->xxh)->chn + j___0)))->rows = (*(m___0->xxp + i___3))->rows;
#line 176
        j___0 ++;
        }
      }
      while_break___12: /* CIL Label */ ;
      }
#line 176
      goto while_break___11;
    }
    while_break___11: /* CIL Label */ ;
    }
#line 178
    if ((int )ppat[i___3] == 0) {
#line 179
      goto __Cont;
    }
    {
#line 181
    fseek(f, (long )(start + (int const   )ppat[i___3]), 0);
    }
    {
#line 183
    while (1) {
      while_continue___13: /* CIL Label */ ;
      {
#line 184
      r = read8(f);
      }
#line 186
      if (((int )r & 127) >= 64) {
        {
#line 187
        report((char *)"** Whoops! row = %d\n", (int )r);
        }
      }
      {
#line 189
      while (1) {
        while_continue___14: /* CIL Label */ ;
        {
#line 190
        c___0 = read8(f);
        }
#line 192
        if (((int )c___0 & 127) >= (m___0->xxh)->chn) {
          {
#line 193
          report((char *)"** Whoops! channel = %d\n", (int )c___0);
          }
        }
        {
#line 195
        event = & (*(m___0->xxt + (*(m___0->xxp + i___3))->info[(int )c___0 & 127].index))->event[(int )r & 127];
#line 197
        b___1 = read8(f);
#line 198
        event->ins = (uint8 )(((int )b___1 & 128) >> 3);
#line 199
        event->note = (uint8 )((int )b___1 & 15);
        }
#line 201
        if ((int )event->note == 15) {
#line 202
          event->note = (uint8 )129;
        } else
#line 203
        if (event->note) {
#line 204
          event->note = (uint8 )((int )event->note + (14 + 12 * (((int )b___1 & 112) >> 4)));
        }
        {
#line 207
        b___1 = read8(f);
#line 208
        event->ins = (uint8 )((int )event->ins | (((int )b___1 & 240) >> 4));
#line 209
        event->fxt = (uint8 )((int )b___1 & 15);
        }
#line 210
        if (event->fxt) {
          {
#line 211
          b___1 = read8(f);
#line 212
          event->fxp = b___1;
          }
#line 215
          if ((int )event->fxt == 15) {
#line 215
            if ((int )event->fxp <= 2) {
#line 217
              event->fxp = (uint8 )6;
            }
          }
        }
#line 189
        if (! (~ ((int )c___0) & 128)) {
#line 189
          goto while_break___14;
        }
      }
      while_break___14: /* CIL Label */ ;
      }
#line 183
      if (! (~ ((int )r) & 128)) {
#line 183
        goto while_break___13;
      }
    }
    while_break___13: /* CIL Label */ ;
    }
    {
#line 222
    reportv(ctx___0, 0, (char *)".");
    }
    __Cont: /* CIL Label */ 
#line 173
    i___3 ++;
  }
  while_break___9: /* CIL Label */ ;
  }
  {
#line 224
  reportv(ctx___0, 0, (char *)"\n");
#line 226
  i___3 = 0;
  }
  {
#line 226
  while (1) {
    while_continue___15: /* CIL Label */ ;
#line 226
    if (! (i___3 < (m___0->xxh)->chn)) {
#line 226
      goto while_break___15;
    }
#line 227
    m___0->xxc[i___3].pan = 128;
#line 228
    m___0->xxc[i___3].flg = 1;
#line 226
    i___3 ++;
  }
  while_break___15: /* CIL Label */ ;
  }
#line 231
  return (0);
}
}
#line 16 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/amd_load.c"
static int amd_test(FILE *f , char *t , int const   start ) ;
#line 17
static int amd_load(struct xmp_context *ctx___0 , FILE *f , int const   start ) ;
#line 19 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/amd_load.c"
struct xmp_loader_info amd_loader  =    {(char *)"AMD", (char *)"Amusic Adlib Tracker", & amd_test, & amd_load, 0, {(struct list_head *)0,
                                                                               (struct list_head *)0}};
#line 26 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/amd_load.c"
static int amd_test(FILE *f , char *t , int const   start ) 
{ 
  char buf___1[9] ;
  int tmp ;
  int tmp___0 ;
  void *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
  {
#line 30
  fseek(f, (long )(start + 1062), 0);
#line 31
  fread((void */* __restrict  */)(buf___1), (size_t )1, (size_t )9, (FILE */* __restrict  */)f);
#line 33
  tmp = memcmp((void const   *)(buf___1), (void const   *)"<o", (size_t )2);
  }
#line 33
  if (tmp) {
#line 34
    return (-1);
  } else {
    {
#line 33
    tmp___0 = memcmp((void const   *)(buf___1 + 6), (void const   *)"RoR", (size_t )3);
    }
#line 33
    if (tmp___0) {
#line 34
      return (-1);
    }
  }
  {
#line 36
  fseek(f, (long )start, 0);
#line 37
  read_title(f, t, 24);
  }
#line 39
  return (0);
}
}
#line 61 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/amd_load.c"
static int reg_xlat[11]  = 
#line 61
  {      0,      5,      1,      6, 
        2,      7,      3,      8, 
        4,      9,      10};
#line 64 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/amd_load.c"
static int amd_load(struct xmp_context *ctx___0 , FILE *f , int const   start ) 
{ 
  struct xmp_player_context *p ;
  struct xmp_mod_context *m___0 ;
  int r ;
  int i___3 ;
  int j ;
  int tmode ;
  struct amd_file_header afh ;
  struct xxm_event *event ;
  char regs[11] ;
  uint16 w ;
  uint8 b___1 ;
  uint8 **tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  void *tmp___9 ;
  void *tmp___10 ;
  void *tmp___11 ;
  uint8 tmp___12 ;
  void *__cil_tmp29 ;
  void *__cil_tmp30 ;
  void *__cil_tmp31 ;
  void *__cil_tmp32 ;
  int __cil_tmp33 ;
  void *__cil_tmp34 ;
  void *__cil_tmp35 ;
  void *__cil_tmp36 ;
  void *__cil_tmp37 ;
  void *__cil_tmp38 ;
  void *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;

  {
#line 66
  p = & ctx___0->p;
#line 67
  m___0 = & p->m;
#line 68
  tmode = 1;
  {
#line 75
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 75
    fseek(f, (long )start, 0);
#line 75
    tmp = (uint8 **)((void *)0);
#line 75
    m___0->med_wav_table = tmp;
#line 75
    m___0->med_vol_table = tmp;
#line 75
    set_xxh_defaults(m___0->xxh);
    }
#line 75
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 77
  fread((void */* __restrict  */)(& afh.name), (size_t )24, (size_t )1, (FILE */* __restrict  */)f);
#line 78
  fread((void */* __restrict  */)(& afh.author), (size_t )24, (size_t )1, (FILE */* __restrict  */)f);
#line 79
  i___3 = 0;
  }
  {
#line 79
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 79
    if (! (i___3 < 26)) {
#line 79
      goto while_break___0;
    }
    {
#line 80
    fread((void */* __restrict  */)(& afh.ins[i___3].name), (size_t )23, (size_t )1,
          (FILE */* __restrict  */)f);
#line 81
    fread((void */* __restrict  */)(& afh.ins[i___3].reg), (size_t )11, (size_t )1,
          (FILE */* __restrict  */)f);
#line 79
    i___3 ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 83
  afh.len = read8(f);
#line 84
  afh.pat = read8(f);
#line 85
  fread((void */* __restrict  */)(& afh.order), (size_t )128, (size_t )1, (FILE */* __restrict  */)f);
#line 86
  fread((void */* __restrict  */)(& afh.magic), (size_t )9, (size_t )1, (FILE */* __restrict  */)f);
#line 87
  afh.version = read8(f);
#line 89
  (m___0->xxh)->chn = 9;
#line 90
  (m___0->xxh)->bpm = 125;
#line 91
  (m___0->xxh)->tpo = 6;
#line 92
  (m___0->xxh)->len = (int )afh.len;
#line 93
  (m___0->xxh)->pat = (int )afh.pat + 1;
#line 94
  (m___0->xxh)->ins = 26;
#line 95
  (m___0->xxh)->smp = 0;
#line 96
  memcpy((void */* __restrict  */)(m___0->xxo), (void const   */* __restrict  */)(afh.order),
         (size_t )(m___0->xxh)->len);
#line 98
  strcpy((char */* __restrict  */)(m___0->type), (char const   */* __restrict  */)"Amusic");
#line 99
  strncpy((char */* __restrict  */)(m___0->name), (char const   */* __restrict  */)((char *)(afh.name)),
          (size_t )24);
#line 100
  strncpy((char */* __restrict  */)(m___0->author), (char const   */* __restrict  */)((char *)(afh.author)),
          (size_t )24);
  }
  {
#line 102
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 102
    if (m___0->verbosity) {
#line 102
      if (m___0->name[0]) {
        {
#line 102
        report((char *)"Module title   : %s\n", m___0->name);
        }
      }
#line 102
      if (m___0->type[0]) {
        {
#line 102
        report((char *)"Module type    : %s\n", m___0->type);
        }
      }
#line 102
      if (m___0->author[0]) {
        {
#line 102
        report((char *)"Author name    : %s\n", m___0->author);
        }
      }
#line 102
      if ((m___0->xxh)->len) {
        {
#line 102
        report((char *)"Module length  : %d patterns\n", (m___0->xxh)->len);
        }
      }
    }
#line 102
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 104
  if (m___0->verbosity > 0) {
    {
#line 105
    report((char *)"Instruments    : %d ", (m___0->xxh)->ins);
    }
  }
  {
#line 107
  while (1) {
    while_continue___2: /* CIL Label */ ;
    {
#line 107
    tmp___0 = calloc((size_t )sizeof(struct xxm_instrument_header ), (size_t )(m___0->xxh)->ins);
#line 107
    m___0->xxih = (struct xxm_instrument_header *)tmp___0;
#line 107
    tmp___1 = calloc((size_t )sizeof(struct xxm_instrument_map ), (size_t )(m___0->xxh)->ins);
#line 107
    m___0->xxim = (struct xxm_instrument_map *)tmp___1;
#line 107
    tmp___2 = calloc((size_t )sizeof(struct xxm_instrument *), (size_t )(m___0->xxh)->ins);
#line 107
    m___0->xxi = (struct xxm_instrument **)tmp___2;
    }
#line 107
    if ((m___0->xxh)->smp) {
      {
#line 107
      tmp___3 = calloc((size_t )sizeof(struct xxm_sample ), (size_t )(m___0->xxh)->smp);
#line 107
      m___0->xxs = (struct xxm_sample *)tmp___3;
      }
    }
    {
#line 107
    tmp___4 = calloc((size_t )sizeof(uint16 *), (size_t )(m___0->xxh)->ins);
#line 107
    m___0->xxae = (uint16 **)tmp___4;
#line 107
    tmp___5 = calloc((size_t )sizeof(uint16 *), (size_t )(m___0->xxh)->ins);
#line 107
    m___0->xxpe = (uint16 **)tmp___5;
#line 107
    tmp___6 = calloc((size_t )sizeof(uint16 *), (size_t )(m___0->xxh)->ins);
#line 107
    m___0->xxfe = (uint16 **)tmp___6;
    }
#line 107
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 110
  i___3 = 0;
  {
#line 110
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 110
    if (! (i___3 < (m___0->xxh)->ins)) {
#line 110
      goto while_break___3;
    }
    {
#line 111
    tmp___7 = calloc((size_t )sizeof(struct xxm_instrument ), (size_t )1);
#line 111
    *(m___0->xxi + i___3) = (struct xxm_instrument *)tmp___7;
#line 113
    copy_adjust((m___0->xxih + i___3)->name, afh.ins[i___3].name, 23);
#line 115
    (m___0->xxih + i___3)->nsm = 1;
#line 116
    (*(m___0->xxi + i___3) + 0)->vol = 64;
#line 117
    (*(m___0->xxi + i___3) + 0)->pan = 128;
#line 118
    (*(m___0->xxi + i___3) + 0)->sid = i___3;
#line 119
    (*(m___0->xxi + i___3) + 0)->xpo = -1;
#line 121
    j = 0;
    }
    {
#line 121
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 121
      if (! (j < 11)) {
#line 121
        goto while_break___4;
      }
#line 122
      regs[j] = (char )afh.ins[i___3].reg[reg_xlat[j]];
#line 121
      j ++;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 124
    if (m___0->verbosity > 1) {
      {
#line 125
      report((char *)"\n[%2X] %-23.23s ", i___3, (m___0->xxih + i___3)->name);
      }
#line 126
      if (((((((((((int )regs[0] | (int )regs[1]) | (int )regs[2]) | (int )regs[3]) | (int )regs[4]) | (int )regs[5]) | (int )regs[6]) | (int )regs[7]) | (int )regs[8]) | (int )regs[9]) | (int )regs[10]) {
#line 128
        j = 0;
        {
#line 128
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 128
          if (! (j < 11)) {
#line 128
            goto while_break___5;
          }
          {
#line 129
          report((char *)"%02x ", (int )((uint8 )regs[j]));
#line 128
          j ++;
          }
        }
        while_break___5: /* CIL Label */ ;
        }
      }
    }
#line 132
    if ((m___0->verbosity > 0) == 1) {
      {
#line 133
      report((char *)".");
      }
    }
    {
#line 134
    xmp_drv_loadpatch(ctx___0, f, (*(m___0->xxi + i___3) + 0)->sid, 0, 0, (struct xxm_sample *)((void *)0),
                      regs);
#line 110
    i___3 ++;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
#line 136
  if (m___0->verbosity > 0) {
    {
#line 137
    report((char *)"\n");
    }
  }
#line 139
  if (! afh.version) {
    {
#line 140
    report((char *)"Aborting: Unpacked modules not supported. Please contact the authors.\n");
    }
#line 142
    return (-1);
  }
#line 144
  if (m___0->verbosity > 0) {
    {
#line 145
    report((char *)"Stored patterns: %d ", (m___0->xxh)->pat);
    }
  }
  {
#line 146
  tmp___8 = calloc((size_t )sizeof(struct xxm_pattern *), (size_t )((m___0->xxh)->pat + 1));
#line 146
  m___0->xxp = (struct xxm_pattern **)tmp___8;
#line 148
  i___3 = 0;
  }
  {
#line 148
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 148
    if (! (i___3 < (m___0->xxh)->pat)) {
#line 148
      goto while_break___6;
    }
    {
#line 149
    while (1) {
      while_continue___7: /* CIL Label */ ;
      {
#line 149
      tmp___9 = calloc((size_t )1, (size_t )(sizeof(struct xxm_pattern ) + sizeof(struct xxm_trackinfo ) * (unsigned long )((m___0->xxh)->chn - 1)));
#line 149
      *(m___0->xxp + i___3) = (struct xxm_pattern *)tmp___9;
      }
#line 149
      goto while_break___7;
    }
    while_break___7: /* CIL Label */ ;
    }
#line 150
    j = 0;
    {
#line 150
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 150
      if (! (j < 9)) {
#line 150
        goto while_break___8;
      }
      {
#line 151
      w = read16l(f);
#line 152
      (*(m___0->xxp + i___3))->info[j].index = (int )w;
      }
#line 153
      if ((int )w > (m___0->xxh)->trk) {
#line 154
        (m___0->xxh)->trk = (int )w;
      }
#line 150
      j ++;
    }
    while_break___8: /* CIL Label */ ;
    }
#line 156
    (*(m___0->xxp + i___3))->rows = 64;
#line 157
    if (m___0->verbosity > 0) {
      {
#line 158
      report((char *)".");
      }
    }
#line 148
    i___3 ++;
  }
  while_break___6: /* CIL Label */ ;
  }
  {
#line 160
  ((m___0->xxh)->trk) ++;
#line 162
  w = read16l(f);
  }
#line 163
  if (m___0->verbosity > 0) {
    {
#line 164
    report((char *)"\nStored tracks  : %d ", (int )w);
    }
  }
  {
#line 165
  tmp___10 = calloc((size_t )sizeof(struct xxm_track *), (size_t )(m___0->xxh)->trk);
#line 165
  m___0->xxt = (struct xxm_track **)tmp___10;
#line 166
  (m___0->xxh)->trk = (int )w;
#line 168
  i___3 = 0;
  }
  {
#line 168
  while (1) {
    while_continue___9: /* CIL Label */ ;
#line 168
    if (! (i___3 < (m___0->xxh)->trk)) {
#line 168
      goto while_break___9;
    }
    {
#line 169
    w = read16l(f);
#line 170
    tmp___11 = calloc((size_t )(sizeof(struct xxm_track ) + sizeof(struct xxm_event ) * 64UL),
                      (size_t )1);
#line 170
    *(m___0->xxt + w) = (struct xxm_track *)tmp___11;
#line 172
    (*(m___0->xxt + w))->rows = 64;
#line 173
    r = 0;
    }
    {
#line 173
    while (1) {
      while_continue___10: /* CIL Label */ ;
#line 173
      if (! (r < 64)) {
#line 173
        goto while_break___10;
      }
      {
#line 174
      event = & (*(m___0->xxt + w))->event[r];
#line 175
      b___1 = read8(f);
      }
#line 176
      if ((int )b___1 & 128) {
#line 177
        r += ((int )b___1 & 127) - 1;
#line 178
        goto __Cont;
      }
      {
#line 180
      event->fxp = b___1;
#line 181
      b___1 = read8(f);
#line 182
      event->ins = (uint8 )(((int )b___1 & 240) >> 4);
#line 183
      b___1 = (uint8 )((int )b___1 & 15);
      }
      {
#line 184
      if ((int )b___1 == 0) {
#line 184
        goto case_0;
      }
#line 186
      if ((int )b___1 == 4) {
#line 186
        goto case_4;
      }
#line 193
      if ((int )b___1 == 9) {
#line 193
        goto case_9;
      }
#line 193
      if ((int )b___1 == 8) {
#line 193
        goto case_9;
      }
#line 193
      if ((int )b___1 == 3) {
#line 193
        goto case_9;
      }
#line 193
      if ((int )b___1 == 2) {
#line 193
        goto case_9;
      }
#line 193
      if ((int )b___1 == 1) {
#line 193
        goto case_9;
      }
#line 196
      if ((int )b___1 == 5) {
#line 196
        goto case_5;
      }
#line 199
      if ((int )b___1 == 6) {
#line 199
        goto case_6;
      }
#line 202
      if ((int )b___1 == 7) {
#line 202
        goto case_7;
      }
#line 183
      goto switch_break;
      case_0: /* CIL Label */ 
#line 185
      goto switch_break;
      case_4: /* CIL Label */ 
#line 187
      b___1 = (uint8 )12;
#line 188
      goto switch_break;
      case_9: /* CIL Label */ 
      case_8: /* CIL Label */ 
      case_3: /* CIL Label */ 
      case_2: /* CIL Label */ 
      case_1: /* CIL Label */ 
#line 194
      b___1 = (uint8 )0;
#line 194
      event->fxp = b___1;
#line 195
      goto switch_break;
      case_5: /* CIL Label */ 
#line 197
      b___1 = (uint8 )11;
#line 198
      goto switch_break;
      case_6: /* CIL Label */ 
#line 200
      b___1 = (uint8 )13;
#line 201
      goto switch_break;
      case_7: /* CIL Label */ 
#line 203
      if (! event->fxp) {
#line 204
        tmode = 3;
      }
#line 205
      if ((int )event->fxp > 31) {
#line 206
        b___1 = (uint8 )0;
#line 206
        event->fxp = b___1;
#line 207
        goto switch_break;
      }
#line 209
      event->fxp = (uint8 )((int )event->fxp * tmode);
#line 210
      b___1 = (uint8 )15;
#line 211
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
      {
#line 213
      event->fxt = b___1;
#line 214
      b___1 = read8(f);
#line 215
      event->ins = (uint8 )((int )event->ins | (((int )b___1 & 1) << 4));
#line 216
      tmp___12 = (uint8 )(((int )b___1 & 240) >> 4);
#line 216
      event->note = tmp___12;
      }
#line 216
      if (tmp___12) {
#line 217
        event->note = (uint8 )((int )event->note + (1 + (((int )b___1 & 14) >> 1)) * 12);
      }
      __Cont: /* CIL Label */ 
#line 173
      r ++;
    }
    while_break___10: /* CIL Label */ ;
    }
#line 219
    if (m___0->verbosity > 0) {
#line 219
      if (! (i___3 % 9)) {
        {
#line 220
        report((char *)".");
        }
      }
    }
#line 168
    i___3 ++;
  }
  while_break___9: /* CIL Label */ ;
  }
#line 222
  if (m___0->verbosity > 0) {
    {
#line 223
    report((char *)"\n");
    }
  }
#line 225
  i___3 = 0;
  {
#line 225
  while (1) {
    while_continue___11: /* CIL Label */ ;
#line 225
    if (! (i___3 < (m___0->xxh)->chn)) {
#line 225
      goto while_break___11;
    }
#line 226
    m___0->xxc[i___3].pan = 128;
#line 227
    m___0->xxc[i___3].flg = 1;
#line 225
    i___3 ++;
  }
  while_break___11: /* CIL Label */ ;
  }
#line 229
  return (0);
}
}
#line 28 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/alm_load.c"
static int alm_test(FILE *f , char *t , int const   start ) ;
#line 29
static int alm_load(struct xmp_context *ctx___0 , FILE *f , int const   start ) ;
#line 31 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/alm_load.c"
struct xmp_loader_info alm_loader  =    {(char *)"ALM", (char *)"Aley Keptr", & alm_test, & alm_load, 0, {(struct list_head *)0,
                                                                     (struct list_head *)0}};
#line 38 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/alm_load.c"
static int alm_test(FILE *f , char *t , int const   start ) 
{ 
  char buf___1[7] ;
  int tmp ;
  int tmp___0 ;
  void *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
  {
#line 42
  fread((void */* __restrict  */)(buf___1), (size_t )1, (size_t )7, (FILE */* __restrict  */)f);
#line 43
  tmp = memcmp((void const   *)(buf___1), (void const   *)"ALEYMOD", (size_t )7);
  }
#line 43
  if (tmp) {
    {
#line 43
    tmp___0 = memcmp((void const   *)(buf___1), (void const   *)"ALEY MO", (size_t )7);
    }
#line 43
    if (tmp___0) {
#line 44
      return (-1);
    }
  }
  {
#line 46
  read_title(f, t, 0);
  }
#line 48
  return (0);
}
}
#line 63 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/alm_load.c"
static int alm_load(struct xmp_context *ctx___0 , FILE *f , int const   start ) 
{ 
  struct xmp_player_context *p ;
  struct xmp_mod_context *m___0 ;
  int i___3 ;
  int j ;
  struct alm_file_header afh ;
  struct xxm_event *event ;
  struct stat stat___0 ;
  uint8 b___1 ;
  char *basename ;
  char filename[255] ;
  char modulename[255] ;
  FILE *s ;
  uint8 **tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  int j___0 ;
  void *tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  void *tmp___9 ;
  void *tmp___10 ;
  void *tmp___11 ;
  void *tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  uint16 tmp___15 ;
  uint16 tmp___16 ;
  int tmp___17 ;
  size_t tmp___18 ;
  void *__cil_tmp37 ;
  void *__cil_tmp38 ;
  void *__cil_tmp39 ;
  void *__cil_tmp40 ;
  void *__cil_tmp41 ;
  void *__cil_tmp42 ;
  void *__cil_tmp43 ;
  void *__cil_tmp44 ;
  void *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;

  {
#line 65
  p = & ctx___0->p;
#line 66
  m___0 = & p->m;
  {
#line 77
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 77
    fseek(f, (long )start, 0);
#line 77
    tmp = (uint8 **)((void *)0);
#line 77
    m___0->med_wav_table = tmp;
#line 77
    m___0->med_vol_table = tmp;
#line 77
    set_xxh_defaults(m___0->xxh);
    }
#line 77
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 79
  fread((void */* __restrict  */)(& afh.id), (size_t )7, (size_t )1, (FILE */* __restrict  */)f);
#line 81
  tmp___0 = strncmp((char const   *)((char *)(afh.id)), "ALEYMOD", (size_t )7);
  }
#line 81
  if (! tmp___0) {
#line 82
    (m___0->xxh)->tpo = (int )afh.speed / 2;
  }
  {
#line 84
  strncpy((char */* __restrict  */)(modulename), (char const   */* __restrict  */)m___0->filename,
          (size_t )255);
#line 85
  basename = strtok((char */* __restrict  */)(modulename), (char const   */* __restrict  */)".");
#line 87
  afh.speed = read8(f);
#line 88
  afh.length = read8(f);
#line 89
  afh.restart = read8(f);
#line 90
  fread((void */* __restrict  */)(& afh.order), (size_t )128, (size_t )1, (FILE */* __restrict  */)f);
#line 92
  (m___0->xxh)->len = (int )afh.length;
#line 93
  (m___0->xxh)->rst = (int )afh.restart;
#line 94
  memcpy((void */* __restrict  */)(m___0->xxo), (void const   */* __restrict  */)(afh.order),
         (size_t )(m___0->xxh)->len);
#line 96
  i___3 = 0;
#line 96
  (m___0->xxh)->pat = i___3;
  }
  {
#line 96
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 96
    if (! (i___3 < (m___0->xxh)->len)) {
#line 96
      goto while_break___0;
    }
#line 97
    if ((m___0->xxh)->pat < (int )afh.order[i___3]) {
#line 98
      (m___0->xxh)->pat = (int )afh.order[i___3];
    }
#line 96
    i___3 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 99
  ((m___0->xxh)->pat) ++;
#line 101
  (m___0->xxh)->ins = 31;
#line 102
  (m___0->xxh)->trk = (m___0->xxh)->pat * (m___0->xxh)->chn;
#line 103
  (m___0->xxh)->smp = (m___0->xxh)->ins;
#line 104
  m___0->c4rate = 8363;
#line 106
  sprintf((char */* __restrict  */)(m___0->type), (char const   */* __restrict  */)"Aley\'s Module");
  }
  {
#line 108
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 108
    if (m___0->verbosity) {
#line 108
      if (m___0->name[0]) {
        {
#line 108
        report((char *)"Module title   : %s\n", m___0->name);
        }
      }
#line 108
      if (m___0->type[0]) {
        {
#line 108
        report((char *)"Module type    : %s\n", m___0->type);
        }
      }
#line 108
      if (m___0->author[0]) {
        {
#line 108
        report((char *)"Author name    : %s\n", m___0->author);
        }
      }
#line 108
      if ((m___0->xxh)->len) {
        {
#line 108
        report((char *)"Module length  : %d patterns\n", (m___0->xxh)->len);
        }
      }
    }
#line 108
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 110
  while (1) {
    while_continue___2: /* CIL Label */ ;
    {
#line 110
    tmp___1 = calloc((size_t )sizeof(struct xxm_track *), (size_t )(m___0->xxh)->trk);
#line 110
    m___0->xxt = (struct xxm_track **)tmp___1;
#line 110
    tmp___2 = calloc((size_t )sizeof(struct xxm_pattern *), (size_t )((m___0->xxh)->pat + 1));
#line 110
    m___0->xxp = (struct xxm_pattern **)tmp___2;
    }
#line 110
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 113
  reportv(ctx___0, 0, (char *)"Stored patterns: %d ", (m___0->xxh)->pat);
#line 115
  i___3 = 0;
  }
  {
#line 115
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 115
    if (! (i___3 < (m___0->xxh)->pat)) {
#line 115
      goto while_break___3;
    }
    {
#line 116
    while (1) {
      while_continue___4: /* CIL Label */ ;
      {
#line 116
      tmp___3 = calloc((size_t )1, (size_t )(sizeof(struct xxm_pattern ) + sizeof(struct xxm_trackinfo ) * (unsigned long )((m___0->xxh)->chn - 1)));
#line 116
      *(m___0->xxp + i___3) = (struct xxm_pattern *)tmp___3;
      }
#line 116
      goto while_break___4;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 117
    (*(m___0->xxp + i___3))->rows = 64;
    {
#line 118
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 118
      j___0 = 0;
      {
#line 118
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 118
        if (! (j___0 < (m___0->xxh)->chn)) {
#line 118
          goto while_break___6;
        }
        {
#line 118
        (*(m___0->xxp + i___3))->info[j___0].index = i___3 * (m___0->xxh)->chn + j___0;
#line 118
        tmp___4 = calloc((size_t )(sizeof(struct xxm_track ) + sizeof(struct xxm_event ) * (unsigned long )(*(m___0->xxp + i___3))->rows),
                         (size_t )1);
#line 118
        *(m___0->xxt + (i___3 * (m___0->xxh)->chn + j___0)) = (struct xxm_track *)tmp___4;
#line 118
        (*(m___0->xxt + (i___3 * (m___0->xxh)->chn + j___0)))->rows = (*(m___0->xxp + i___3))->rows;
#line 118
        j___0 ++;
        }
      }
      while_break___6: /* CIL Label */ ;
      }
#line 118
      goto while_break___5;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 119
    j = 0;
    {
#line 119
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 119
      if (! (j < 64 * (m___0->xxh)->chn)) {
#line 119
        goto while_break___7;
      }
      {
#line 120
      event = & (*(m___0->xxt + (*(m___0->xxp + i___3))->info[j % (m___0->xxh)->chn].index))->event[j / (m___0->xxh)->chn];
#line 121
      b___1 = read8(f);
      }
#line 122
      if (b___1) {
#line 123
        if ((int )b___1 == 37) {
#line 123
          event->note = (uint8 )97;
        } else {
#line 123
          event->note = (uint8 )((int )b___1 + 36);
        }
      }
      {
#line 124
      event->ins = read8(f);
#line 119
      j ++;
      }
    }
    while_break___7: /* CIL Label */ ;
    }
    {
#line 126
    reportv(ctx___0, 0, (char *)".");
#line 115
    i___3 ++;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 128
  reportv(ctx___0, 0, (char *)"\n");
  }
  {
#line 130
  while (1) {
    while_continue___8: /* CIL Label */ ;
    {
#line 130
    tmp___5 = calloc((size_t )sizeof(struct xxm_instrument_header ), (size_t )(m___0->xxh)->ins);
#line 130
    m___0->xxih = (struct xxm_instrument_header *)tmp___5;
#line 130
    tmp___6 = calloc((size_t )sizeof(struct xxm_instrument_map ), (size_t )(m___0->xxh)->ins);
#line 130
    m___0->xxim = (struct xxm_instrument_map *)tmp___6;
#line 130
    tmp___7 = calloc((size_t )sizeof(struct xxm_instrument *), (size_t )(m___0->xxh)->ins);
#line 130
    m___0->xxi = (struct xxm_instrument **)tmp___7;
    }
#line 130
    if ((m___0->xxh)->smp) {
      {
#line 130
      tmp___8 = calloc((size_t )sizeof(struct xxm_sample ), (size_t )(m___0->xxh)->smp);
#line 130
      m___0->xxs = (struct xxm_sample *)tmp___8;
      }
    }
    {
#line 130
    tmp___9 = calloc((size_t )sizeof(uint16 *), (size_t )(m___0->xxh)->ins);
#line 130
    m___0->xxae = (uint16 **)tmp___9;
#line 130
    tmp___10 = calloc((size_t )sizeof(uint16 *), (size_t )(m___0->xxh)->ins);
#line 130
    m___0->xxpe = (uint16 **)tmp___10;
#line 130
    tmp___11 = calloc((size_t )sizeof(uint16 *), (size_t )(m___0->xxh)->ins);
#line 130
    m___0->xxfe = (uint16 **)tmp___11;
    }
#line 130
    goto while_break___8;
  }
  while_break___8: /* CIL Label */ ;
  }
  {
#line 134
  reportv(ctx___0, 0, (char *)"Loading samples: %d ", (m___0->xxh)->ins);
#line 136
  i___3 = 0;
  }
  {
#line 136
  while (1) {
    while_continue___9: /* CIL Label */ ;
#line 136
    if (! (i___3 < (m___0->xxh)->ins)) {
#line 136
      goto while_break___9;
    }
    {
#line 137
    tmp___12 = calloc((size_t )sizeof(struct xxm_instrument ), (size_t )1);
#line 137
    *(m___0->xxi + i___3) = (struct xxm_instrument *)tmp___12;
#line 138
    snprintf((char */* __restrict  */)(filename), (size_t )255, (char const   */* __restrict  */)"%s.%d",
             basename, i___3 + 1);
#line 139
    s = fopen((char const   */* __restrict  */)(filename), (char const   */* __restrict  */)"rb");
#line 141
    tmp___13 = (unsigned long )s != (unsigned long )((void *)0);
#line 141
    (m___0->xxih + i___3)->nsm = tmp___13;
    }
#line 141
    if (! tmp___13) {
#line 142
      goto __Cont;
    }
    {
#line 144
    tmp___14 = fileno(s);
#line 144
    fstat(tmp___14, & stat___0);
#line 145
    b___1 = read8(s);
#line 146
    (m___0->xxs + i___3)->len = (int )(stat___0.st_size - (__off_t )(5 * ! b___1));
    }
#line 148
    if (! b___1) {
      {
#line 149
      tmp___15 = read16l(f);
#line 149
      (m___0->xxs + i___3)->lps = (int )tmp___15;
#line 150
      tmp___16 = read16l(f);
#line 150
      (m___0->xxs + i___3)->lpe = (int )tmp___16;
      }
#line 151
      if ((m___0->xxs + i___3)->lpe > (m___0->xxs + i___3)->lps) {
#line 151
        (m___0->xxs + i___3)->flg = 4;
      } else {
#line 151
        (m___0->xxs + i___3)->flg = 0;
      }
    } else {
      {
#line 153
      fseek(s, 0L, 0);
      }
    }
#line 156
    (*(m___0->xxi + i___3) + 0)->pan = 128;
#line 157
    (*(m___0->xxi + i___3) + 0)->vol = 64;
#line 158
    (*(m___0->xxi + i___3) + 0)->sid = i___3;
#line 160
    if (m___0->verbosity > 1) {
      {
#line 160
      tmp___18 = strlen((char const   *)((char *)((m___0->xxih + i___3)->name)));
      }
#line 160
      if (tmp___18) {
#line 160
        goto _L;
      } else
#line 160
      if ((m___0->xxs + i___3)->len > 1) {
        _L: /* CIL Label */ 
#line 162
        if ((m___0->xxs + i___3)->flg & 4) {
#line 162
          tmp___17 = 'L';
        } else {
#line 162
          tmp___17 = ' ';
        }
        {
#line 162
        report((char *)"\n[%2X] %-14.14s %04x %04x %04x %c V%02x ", i___3, filename,
               (m___0->xxs + i___3)->len, (m___0->xxs + i___3)->lps, (m___0->xxs + i___3)->lpe,
               tmp___17, (*(m___0->xxi + i___3) + 0)->vol);
        }
      }
    }
    {
#line 167
    xmp_drv_loadpatch(ctx___0, s, (*(m___0->xxi + i___3) + 0)->sid, m___0->c4rate,
                      2, m___0->xxs + (*(m___0->xxi + i___3) + 0)->sid, (char *)((void *)0));
#line 170
    fclose(s);
#line 172
    reportv(ctx___0, 0, (char *)".");
    }
    __Cont: /* CIL Label */ 
#line 136
    i___3 ++;
  }
  while_break___9: /* CIL Label */ ;
  }
  {
#line 174
  reportv(ctx___0, 0, (char *)"\n");
#line 177
  i___3 = 0;
  }
  {
#line 177
  while (1) {
    while_continue___10: /* CIL Label */ ;
#line 177
    if (! (i___3 < (m___0->xxh)->chn)) {
#line 177
      goto while_break___10;
    }
#line 178
    m___0->xxc[i___3].pan = (i___3 % 2) * 255;
#line 177
    i___3 ++;
  }
  while_break___10: /* CIL Label */ ;
  }
#line 180
  return (0);
}
}
#line 22 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/okt_load.c"
static int okt_test(FILE *f , char *t , int const   start ) ;
#line 23
static int okt_load(struct xmp_context *ctx___0 , FILE *f , int const   start ) ;
#line 25 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/okt_load.c"
struct xmp_loader_info okt_loader  =    {(char *)"OKT", (char *)"Oktalyzer", & okt_test, & okt_load, 0, {(struct list_head *)0,
                                                                    (struct list_head *)0}};
#line 32 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/okt_load.c"
static int okt_test(FILE *f , char *t , int const   start ) 
{ 
  char magic[8] ;
  int tmp ;
  void *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
  {
#line 36
  fread((void */* __restrict  */)(magic), (size_t )1, (size_t )8, (FILE */* __restrict  */)f);
#line 37
  tmp = strncmp((char const   *)(magic), "OKTASONG", (size_t )8);
  }
#line 37
  if (tmp) {
#line 38
    return (-1);
  }
  {
#line 40
  read_title(f, t, 0);
  }
#line 42
  return (0);
}
}
#line 52 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/okt_load.c"
static int mode___0[36]  ;
#line 53 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/okt_load.c"
static int idx[36]  ;
#line 54 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/okt_load.c"
static int pattern  =    0;
#line 55 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/okt_load.c"
static int sample  =    0;
#line 58 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/okt_load.c"
static int fx___4[32]  = 
#line 58
  {      255,      1,      2,      255, 
        255,      255,      255,      255, 
        255,      255,      112,      113, 
        114,      156,      255,      255, 
        255,      157,      255,      255, 
        255,      117,      255,      255, 
        255,      11,      255,      255, 
        15,      255,      118,      12};
#line 94 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/okt_load.c"
static void get_cmod(struct xmp_context *ctx___0 , int size___0 , FILE *f ) 
{ 
  struct xmp_player_context *p ;
  struct xmp_mod_context *m___0 ;
  int i___3 ;
  int j ;
  int k ;
  uint16 tmp ;

  {
#line 96
  p = & ctx___0->p;
#line 97
  m___0 = & p->m;
#line 100
  (m___0->xxh)->chn = 0;
#line 101
  i___3 = 0;
  {
#line 101
  while (1) {
    while_continue: /* CIL Label */ ;
#line 101
    if (! (i___3 < 4)) {
#line 101
      goto while_break;
    }
    {
#line 102
    tmp = read16b(f);
#line 102
    j = (int )tmp;
#line 103
    k = ! (! j);
    }
    {
#line 103
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 103
      if (! (k >= 0)) {
#line 103
        goto while_break___0;
      }
#line 104
      m___0->xxc[(m___0->xxh)->chn].pan = (((i___3 + 1) / 2) % 2) * 255;
#line 105
      ((m___0->xxh)->chn) ++;
#line 103
      k --;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 101
    i___3 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 108
  return;
}
}
#line 111 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/okt_load.c"
static void get_samp___0(struct xmp_context *ctx___0 , int size___0 , FILE *f ) 
{ 
  struct xmp_player_context *p ;
  struct xmp_mod_context *m___0 ;
  int i___3 ;
  int j ;
  int looplen ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  uint32 tmp___7 ;
  uint16 tmp___8 ;
  uint16 tmp___9 ;
  uint16 tmp___10 ;
  uint16 tmp___11 ;
  int tmp___12 ;
  size_t tmp___13 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;

  {
#line 113
  p = & ctx___0->p;
#line 114
  m___0 = & p->m;
#line 119
  (m___0->xxh)->ins = size___0 / 32;
#line 120
  (m___0->xxh)->smp = (m___0->xxh)->ins;
  {
#line 122
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 122
    tmp = calloc((size_t )sizeof(struct xxm_instrument_header ), (size_t )(m___0->xxh)->ins);
#line 122
    m___0->xxih = (struct xxm_instrument_header *)tmp;
#line 122
    tmp___0 = calloc((size_t )sizeof(struct xxm_instrument_map ), (size_t )(m___0->xxh)->ins);
#line 122
    m___0->xxim = (struct xxm_instrument_map *)tmp___0;
#line 122
    tmp___1 = calloc((size_t )sizeof(struct xxm_instrument *), (size_t )(m___0->xxh)->ins);
#line 122
    m___0->xxi = (struct xxm_instrument **)tmp___1;
    }
#line 122
    if ((m___0->xxh)->smp) {
      {
#line 122
      tmp___2 = calloc((size_t )sizeof(struct xxm_sample ), (size_t )(m___0->xxh)->smp);
#line 122
      m___0->xxs = (struct xxm_sample *)tmp___2;
      }
    }
    {
#line 122
    tmp___3 = calloc((size_t )sizeof(uint16 *), (size_t )(m___0->xxh)->ins);
#line 122
    m___0->xxae = (uint16 **)tmp___3;
#line 122
    tmp___4 = calloc((size_t )sizeof(uint16 *), (size_t )(m___0->xxh)->ins);
#line 122
    m___0->xxpe = (uint16 **)tmp___4;
#line 122
    tmp___5 = calloc((size_t )sizeof(uint16 *), (size_t )(m___0->xxh)->ins);
#line 122
    m___0->xxfe = (uint16 **)tmp___5;
    }
#line 122
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 124
  reportv(ctx___0, 1, (char *)"     Instrument name      Len   Lbeg  Lend  L Vol Mod\n");
#line 125
  i___3 = 0;
#line 125
  j = i___3;
  }
  {
#line 125
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 125
    if (! (i___3 < (m___0->xxh)->ins)) {
#line 125
      goto while_break___0;
    }
    {
#line 126
    tmp___6 = calloc((size_t )sizeof(struct xxm_instrument ), (size_t )1);
#line 126
    *(m___0->xxi + i___3) = (struct xxm_instrument *)tmp___6;
#line 128
    fread((void */* __restrict  */)((m___0->xxih + i___3)->name), (size_t )1, (size_t )20,
          (FILE */* __restrict  */)f);
#line 129
    str_adj((char *)((m___0->xxih + i___3)->name));
#line 132
    tmp___7 = read32b(f);
#line 132
    (m___0->xxs + i___3)->len = (int )(tmp___7 & 4294967294U);
#line 133
    tmp___8 = read16b(f);
#line 133
    (m___0->xxs + i___3)->lps = (int )tmp___8;
#line 134
    tmp___9 = read16b(f);
#line 134
    looplen = (int )tmp___9;
#line 135
    (m___0->xxs + i___3)->lpe = (m___0->xxs + i___3)->lps + looplen;
#line 136
    tmp___10 = read16b(f);
#line 136
    (*(m___0->xxi + i___3) + 0)->vol = (int )tmp___10;
#line 137
    tmp___11 = read16b(f);
#line 137
    mode___0[i___3] = (int )tmp___11;
#line 139
    (m___0->xxih + i___3)->nsm = ! (! (m___0->xxs + i___3)->len);
    }
#line 140
    if (looplen > 2) {
#line 140
      (m___0->xxs + i___3)->flg = 4;
    } else {
#line 140
      (m___0->xxs + i___3)->flg = 0;
    }
#line 141
    (*(m___0->xxi + i___3) + 0)->pan = 128;
#line 142
    (*(m___0->xxi + i___3) + 0)->sid = j;
#line 144
    idx[j] = i___3;
#line 146
    if (m___0->verbosity > 1) {
      {
#line 146
      tmp___13 = strlen((char const   *)((char *)((m___0->xxih + i___3)->name)));
      }
#line 146
      if (tmp___13) {
#line 146
        goto _L;
      } else
#line 146
      if ((m___0->xxs + i___3)->len > 1) {
        _L: /* CIL Label */ 
#line 147
        if ((m___0->xxs + i___3)->flg & 4) {
#line 147
          tmp___12 = 'L';
        } else {
#line 147
          tmp___12 = ' ';
        }
        {
#line 147
        report((char *)"[%2X] %-20.20s %05x %05x %05x %c V%02x M%02x\n", i___3, (m___0->xxih + i___3)->name,
               (m___0->xxs + i___3)->len, (m___0->xxs + i___3)->lps, (m___0->xxs + i___3)->lpe,
               tmp___12, (*(m___0->xxi + i___3) + 0)->vol, mode___0[i___3]);
        }
      }
    }
#line 150
    if ((m___0->xxih + i___3)->nsm) {
#line 151
      j ++;
    }
#line 125
    i___3 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 153
  return;
}
}
#line 156 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/okt_load.c"
static void get_spee(struct xmp_context *ctx___0 , int size___0 , FILE *f ) 
{ 
  struct xmp_player_context *p ;
  struct xmp_mod_context *m___0 ;
  uint16 tmp ;

  {
  {
#line 158
  p = & ctx___0->p;
#line 159
  m___0 = & p->m;
#line 161
  tmp = read16b(f);
#line 161
  (m___0->xxh)->tpo = (int )tmp;
#line 162
  (m___0->xxh)->bpm = 125;
  }
#line 163
  return;
}
}
#line 166 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/okt_load.c"
static void get_slen(struct xmp_context *ctx___0 , int size___0 , FILE *f ) 
{ 
  struct xmp_player_context *p ;
  struct xmp_mod_context *m___0 ;
  uint16 tmp ;

  {
  {
#line 168
  p = & ctx___0->p;
#line 169
  m___0 = & p->m;
#line 171
  tmp = read16b(f);
#line 171
  (m___0->xxh)->pat = (int )tmp;
#line 172
  (m___0->xxh)->trk = (m___0->xxh)->pat * (m___0->xxh)->chn;
  }
#line 173
  return;
}
}
#line 176 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/okt_load.c"
static void get_plen___0(struct xmp_context *ctx___0 , int size___0 , FILE *f ) 
{ 
  struct xmp_player_context *p ;
  struct xmp_mod_context *m___0 ;
  uint16 tmp ;
  char *__cil_tmp7 ;

  {
  {
#line 178
  p = & ctx___0->p;
#line 179
  m___0 = & p->m;
#line 181
  tmp = read16b(f);
#line 181
  (m___0->xxh)->len = (int )tmp;
#line 182
  reportv(ctx___0, 0, (char *)"Module length  : %d patterns\n", (m___0->xxh)->len);
  }
#line 183
  return;
}
}
#line 186 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/okt_load.c"
static void get_patt___6(struct xmp_context *ctx___0 , int size___0 , FILE *f ) 
{ 
  struct xmp_player_context *p ;
  struct xmp_mod_context *m___0 ;

  {
  {
#line 188
  p = & ctx___0->p;
#line 189
  m___0 = & p->m;
#line 191
  fread((void */* __restrict  */)(m___0->xxo), (size_t )1, (size_t )(m___0->xxh)->len,
        (FILE */* __restrict  */)f);
  }
#line 192
  return;
}
}
#line 195 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/okt_load.c"
static void get_pbod___0(struct xmp_context *ctx___0 , int size___0 , FILE *f ) 
{ 
  struct xmp_player_context *p ;
  struct xmp_mod_context *m___0 ;
  int j ;
  uint16 rows___1 ;
  struct xxm_event *event ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  int j___0 ;
  void *tmp___2 ;
  uint8 note ;
  uint8 ins ;
  uint8 tmp___3 ;
  uint8 tmp___4 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;

  {
#line 197
  p = & ctx___0->p;
#line 198
  m___0 = & p->m;
#line 204
  if (pattern >= (m___0->xxh)->pat) {
#line 205
    return;
  }
#line 207
  if (! pattern) {
    {
#line 208
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 208
      tmp = calloc((size_t )sizeof(struct xxm_track *), (size_t )(m___0->xxh)->trk);
#line 208
      m___0->xxt = (struct xxm_track **)tmp;
#line 208
      tmp___0 = calloc((size_t )sizeof(struct xxm_pattern *), (size_t )((m___0->xxh)->pat + 1));
#line 208
      m___0->xxp = (struct xxm_pattern **)tmp___0;
      }
#line 208
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 209
    reportv(ctx___0, 0, (char *)"Stored patterns: %d ", (m___0->xxh)->pat);
    }
  }
  {
#line 212
  rows___1 = read16b(f);
  }
  {
#line 214
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 214
    tmp___1 = calloc((size_t )1, (size_t )(sizeof(struct xxm_pattern ) + sizeof(struct xxm_trackinfo ) * (unsigned long )((m___0->xxh)->chn - 1)));
#line 214
    *(m___0->xxp + pattern) = (struct xxm_pattern *)tmp___1;
    }
#line 214
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 215
  (*(m___0->xxp + pattern))->rows = (int )rows___1;
  {
#line 216
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 216
    j___0 = 0;
    {
#line 216
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 216
      if (! (j___0 < (m___0->xxh)->chn)) {
#line 216
        goto while_break___2;
      }
      {
#line 216
      (*(m___0->xxp + pattern))->info[j___0].index = pattern * (m___0->xxh)->chn + j___0;
#line 216
      tmp___2 = calloc((size_t )(sizeof(struct xxm_track ) + sizeof(struct xxm_event ) * (unsigned long )(*(m___0->xxp + pattern))->rows),
                       (size_t )1);
#line 216
      *(m___0->xxt + (pattern * (m___0->xxh)->chn + j___0)) = (struct xxm_track *)tmp___2;
#line 216
      (*(m___0->xxt + (pattern * (m___0->xxh)->chn + j___0)))->rows = (*(m___0->xxp + pattern))->rows;
#line 216
      j___0 ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
#line 216
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 218
  j = 0;
  {
#line 218
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 218
    if (! (j < (int )rows___1 * (m___0->xxh)->chn)) {
#line 218
      goto while_break___3;
    }
    {
#line 221
    event = & (*(m___0->xxt + (*(m___0->xxp + pattern))->info[j % (m___0->xxh)->chn].index))->event[j / (m___0->xxh)->chn];
#line 222
    memset((void *)event, 0, (size_t )sizeof(struct xxm_event ));
#line 224
    note = read8(f);
#line 225
    ins = read8(f);
    }
#line 227
    if (note) {
#line 228
      event->note = (uint8 )(36 + (int )note);
#line 229
      event->ins = (uint8 )(1 + (int )ins);
    }
    {
#line 232
    tmp___3 = read8(f);
#line 232
    event->fxt = (uint8 )fx___4[tmp___3];
#line 233
    event->fxp = read8(f);
    }
#line 235
    if ((int )event->fxt == 12) {
#line 235
      if ((int )event->fxp > 64) {
#line 236
        if ((int )event->fxp <= 80) {
#line 237
          event->fxt = (uint8 )10;
#line 238
          event->fxp = (uint8 )((int )event->fxp - 64);
        } else
#line 239
        if ((int )event->fxp <= 96) {
#line 240
          event->fxt = (uint8 )10;
#line 241
          event->fxp = (uint8 )(((int )event->fxp - 80) << 4);
        } else
#line 242
        if ((int )event->fxp <= 112) {
#line 243
          event->fxt = (uint8 )14;
#line 244
          event->fxp = (uint8 )((11 << 4) | ((int )event->fxp - 96));
        } else
#line 245
        if ((int )event->fxp <= 128) {
#line 246
          event->fxt = (uint8 )14;
#line 247
          event->fxp = (uint8 )((10 << 4) | ((int )event->fxp - 112));
        }
      }
    }
#line 250
    if ((int )event->fxt == 0) {
#line 251
      event->fxp = (uint8 )(((24 - (((int )event->fxp & 240) >> 4)) % 12 << 4) | ((int )event->fxp & 15));
    }
#line 252
    if ((int )event->fxt == 255) {
#line 253
      tmp___4 = (uint8 )0;
#line 253
      event->fxp = tmp___4;
#line 253
      event->fxt = tmp___4;
    }
#line 218
    j ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 255
  reportv(ctx___0, 0, (char *)".");
#line 256
  pattern ++;
  }
#line 257
  return;
}
}
#line 260 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/okt_load.c"
static void get_sbod(struct xmp_context *ctx___0 , int size___0 , FILE *f ) 
{ 
  struct xmp_player_context *p ;
  struct xmp_mod_context *m___0 ;
  int flags ;
  int i___3 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
#line 262
  p = & ctx___0->p;
#line 263
  m___0 = & p->m;
#line 265
  flags = 0;
#line 268
  if (sample >= (m___0->xxh)->ins) {
#line 269
    return;
  }
#line 271
  if (! sample) {
#line 271
    if (m___0->verbosity > 0) {
      {
#line 272
      report((char *)"\nStored samples : %d ", (m___0->xxh)->smp);
      }
    }
  }
#line 274
  i___3 = idx[sample];
#line 275
  if (mode___0[i___3] == 0) {
#line 276
    flags = 8;
  } else
#line 275
  if (mode___0[i___3] == 2) {
#line 276
    flags = 8;
  }
  {
#line 278
  xmp_drv_loadpatch(ctx___0, f, sample, m___0->c4rate, flags, m___0->xxs + i___3,
                    (char *)((void *)0));
#line 280
  reportv(ctx___0, 0, (char *)".");
#line 282
  sample ++;
  }
#line 283
  return;
}
}
#line 286 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/okt_load.c"
static int okt_load(struct xmp_context *ctx___0 , FILE *f , int const   start ) 
{ 
  struct xmp_player_context *p ;
  struct xmp_mod_context *m___0 ;
  uint8 **tmp ;
  int tmp___0 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;

  {
#line 288
  p = & ctx___0->p;
#line 289
  m___0 = & p->m;
  {
#line 291
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 291
    fseek(f, (long )start, 0);
#line 291
    tmp = (uint8 **)((void *)0);
#line 291
    m___0->med_wav_table = tmp;
#line 291
    m___0->med_vol_table = tmp;
#line 291
    set_xxh_defaults(m___0->xxh);
    }
#line 291
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 293
  fseek(f, 8L, 1);
#line 295
  sample = 0;
#line 295
  pattern = sample;
#line 298
  iff_register((char *)"CMOD", & get_cmod);
#line 299
  iff_register((char *)"SAMP", & get_samp___0);
#line 300
  iff_register((char *)"SPEE", & get_spee);
#line 301
  iff_register((char *)"SLEN", & get_slen);
#line 302
  iff_register((char *)"PLEN", & get_plen___0);
#line 303
  iff_register((char *)"PATT", & get_patt___6);
#line 304
  iff_register((char *)"PBOD", & get_pbod___0);
#line 305
  iff_register((char *)"SBOD", & get_sbod);
#line 307
  strcpy((char */* __restrict  */)(m___0->type), (char const   */* __restrict  */)"OKT (Oktalyzer)");
  }
  {
#line 309
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 309
    if (m___0->verbosity) {
#line 309
      if (m___0->name[0]) {
        {
#line 309
        report((char *)"Module title   : %s\n", m___0->name);
        }
      }
#line 309
      if (m___0->type[0]) {
        {
#line 309
        report((char *)"Module type    : %s\n", m___0->type);
        }
      }
#line 309
      if (m___0->author[0]) {
        {
#line 309
        report((char *)"Author name    : %s\n", m___0->author);
        }
      }
#line 309
      if ((m___0->xxh)->len) {
        {
#line 309
        report((char *)"Module length  : %d patterns\n", (m___0->xxh)->len);
        }
      }
    }
#line 309
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 312
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 312
    tmp___0 = feof(f);
    }
#line 312
    if (tmp___0) {
#line 312
      goto while_break___1;
    }
    {
#line 313
    iff_chunk(ctx___0, f);
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 315
  iff_release();
#line 317
  reportv(ctx___0, 0, (char *)"\n");
  }
#line 319
  return (0);
}
}
#line 20 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/ptm_load.c"
static int ptm_test(FILE *f , char *t , int const   start ) ;
#line 21
static int ptm_load(struct xmp_context *ctx___0 , FILE *f , int const   start ) ;
#line 23 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/ptm_load.c"
struct xmp_loader_info ptm_loader  =    {(char *)"PTM", (char *)"Poly Tracker", & ptm_test, & ptm_load, 0, {(struct list_head *)0,
                                                                       (struct list_head *)0}};
#line 30 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/ptm_load.c"
static int ptm_test(FILE *f , char *t , int const   start ) 
{ 
  uint32 tmp ;

  {
  {
#line 32
  fseek(f, (long )(start + 44), 0);
#line 33
  tmp = read32b(f);
  }
#line 33
  if (tmp != ((((80U << 24) | (84U << 16)) | (77U << 8)) | 70U)) {
#line 34
    return (-1);
  }
  {
#line 36
  fseek(f, (long )start, 0);
#line 37
  read_title(f, t, 28);
  }
#line 39
  return (0);
}
}
#line 43 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/ptm_load.c"
static int ptm_vol[65]  = 
#line 43
  {      0,      5,      8,      10, 
        12,      14,      15,      17, 
        18,      20,      21,      22, 
        23,      25,      26,      27, 
        28,      29,      30,      31, 
        32,      33,      34,      35, 
        36,      37,      37,      38, 
        39,      40,      41,      42, 
        42,      43,      44,      45, 
        46,      46,      47,      48, 
        49,      49,      50,      51, 
        51,      52,      53,      54, 
        54,      55,      56,      56, 
        57,      58,      58,      59, 
        59,      60,      61,      61, 
        62,      63,      63,      64, 
        64};
#line 52 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/ptm_load.c"
static int ptm_load(struct xmp_context *ctx___0 , FILE *f , int const   start ) 
{ 
  struct xmp_player_context *p ;
  struct xmp_mod_context *m___0 ;
  int c___0 ;
  int r ;
  int i___3 ;
  int smp_ofs[256] ;
  struct xxm_event *event ;
  struct ptm_file_header pfh ;
  struct ptm_instrument_header pih ;
  uint8 n___0 ;
  uint8 b___1 ;
  uint8 **tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  size_t tmp___14 ;
  void *tmp___15 ;
  void *tmp___16 ;
  void *tmp___17 ;
  int j ;
  void *tmp___18 ;
  uint8 tmp___19 ;
  uint8 tmp___20 ;
  uint8 tmp___21 ;
  void *__cil_tmp39 ;
  void *__cil_tmp40 ;
  void *__cil_tmp41 ;
  void *__cil_tmp42 ;
  void *__cil_tmp43 ;
  void *__cil_tmp44 ;
  void *__cil_tmp45 ;
  void *__cil_tmp46 ;
  void *__cil_tmp47 ;
  void *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;

  {
#line 54
  p = & ctx___0->p;
#line 55
  m___0 = & p->m;
  {
#line 62
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 62
    fseek(f, (long )start, 0);
#line 62
    tmp = (uint8 **)((void *)0);
#line 62
    m___0->med_wav_table = tmp;
#line 62
    m___0->med_vol_table = tmp;
#line 62
    set_xxh_defaults(m___0->xxh);
    }
#line 62
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 66
  fread((void */* __restrict  */)(& pfh.name), (size_t )28, (size_t )1, (FILE */* __restrict  */)f);
#line 67
  pfh.doseof = read8(f);
#line 68
  pfh.vermin = read8(f);
#line 69
  pfh.vermaj = read8(f);
#line 70
  pfh.rsvd1 = read8(f);
#line 71
  pfh.ordnum = read16l(f);
#line 72
  pfh.insnum = read16l(f);
#line 73
  pfh.patnum = read16l(f);
#line 74
  pfh.chnnum = read16l(f);
#line 75
  pfh.flags = read16l(f);
#line 76
  pfh.rsvd2 = read16l(f);
#line 77
  pfh.magic = read32b(f);
#line 84
  fread((void */* __restrict  */)(& pfh.rsvd3), (size_t )16, (size_t )1, (FILE */* __restrict  */)f);
#line 85
  fread((void */* __restrict  */)(& pfh.chset), (size_t )32, (size_t )1, (FILE */* __restrict  */)f);
#line 86
  fread((void */* __restrict  */)(& pfh.order), (size_t )256, (size_t )1, (FILE */* __restrict  */)f);
#line 87
  i___3 = 0;
  }
  {
#line 87
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 87
    if (! (i___3 < 128)) {
#line 87
      goto while_break___0;
    }
    {
#line 88
    pfh.patseg[i___3] = read16l(f);
#line 87
    i___3 ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 90
  (m___0->xxh)->len = (int )pfh.ordnum;
#line 91
  (m___0->xxh)->ins = (int )pfh.insnum;
#line 92
  (m___0->xxh)->pat = (int )pfh.patnum;
#line 93
  (m___0->xxh)->chn = (int )pfh.chnnum;
#line 94
  (m___0->xxh)->trk = (m___0->xxh)->pat * (m___0->xxh)->chn;
#line 95
  (m___0->xxh)->smp = (m___0->xxh)->ins;
#line 96
  (m___0->xxh)->tpo = 6;
#line 97
  (m___0->xxh)->bpm = 125;
#line 98
  memcpy((void */* __restrict  */)(m___0->xxo), (void const   */* __restrict  */)(pfh.order),
         (size_t )256);
#line 100
  m___0->c4rate = 8363;
#line 102
  copy_adjust((uint8 *)(m___0->name), pfh.name, 28);
#line 103
  sprintf((char */* __restrict  */)(m___0->type), (char const   */* __restrict  */)"PTMF %d.%02x (Poly Tracker)",
          (int )pfh.vermaj, (int )pfh.vermin);
  }
  {
#line 106
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 106
    if (m___0->verbosity) {
#line 106
      if (m___0->name[0]) {
        {
#line 106
        report((char *)"Module title   : %s\n", m___0->name);
        }
      }
#line 106
      if (m___0->type[0]) {
        {
#line 106
        report((char *)"Module type    : %s\n", m___0->type);
        }
      }
#line 106
      if (m___0->author[0]) {
        {
#line 106
        report((char *)"Author name    : %s\n", m___0->author);
        }
      }
#line 106
      if ((m___0->xxh)->len) {
        {
#line 106
        report((char *)"Module length  : %d patterns\n", (m___0->xxh)->len);
        }
      }
    }
#line 106
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 108
  while (1) {
    while_continue___2: /* CIL Label */ ;
    {
#line 108
    tmp___0 = calloc((size_t )sizeof(struct xxm_instrument_header ), (size_t )(m___0->xxh)->ins);
#line 108
    m___0->xxih = (struct xxm_instrument_header *)tmp___0;
#line 108
    tmp___1 = calloc((size_t )sizeof(struct xxm_instrument_map ), (size_t )(m___0->xxh)->ins);
#line 108
    m___0->xxim = (struct xxm_instrument_map *)tmp___1;
#line 108
    tmp___2 = calloc((size_t )sizeof(struct xxm_instrument *), (size_t )(m___0->xxh)->ins);
#line 108
    m___0->xxi = (struct xxm_instrument **)tmp___2;
    }
#line 108
    if ((m___0->xxh)->smp) {
      {
#line 108
      tmp___3 = calloc((size_t )sizeof(struct xxm_sample ), (size_t )(m___0->xxh)->smp);
#line 108
      m___0->xxs = (struct xxm_sample *)tmp___3;
      }
    }
    {
#line 108
    tmp___4 = calloc((size_t )sizeof(uint16 *), (size_t )(m___0->xxh)->ins);
#line 108
    m___0->xxae = (uint16 **)tmp___4;
#line 108
    tmp___5 = calloc((size_t )sizeof(uint16 *), (size_t )(m___0->xxh)->ins);
#line 108
    m___0->xxpe = (uint16 **)tmp___5;
#line 108
    tmp___6 = calloc((size_t )sizeof(uint16 *), (size_t )(m___0->xxh)->ins);
#line 108
    m___0->xxfe = (uint16 **)tmp___6;
    }
#line 108
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 112
  reportv(ctx___0, 1, (char *)"     Instrument name              Len   LBeg  LEnd  L Vol C4Spd\n");
#line 114
  i___3 = 0;
  }
  {
#line 114
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 114
    if (! (i___3 < (m___0->xxh)->ins)) {
#line 114
      goto while_break___3;
    }
    {
#line 115
    tmp___7 = calloc((size_t )sizeof(struct xxm_instrument ), (size_t )1);
#line 115
    *(m___0->xxi + i___3) = (struct xxm_instrument *)tmp___7;
#line 117
    pih.type = read8(f);
#line 118
    fread((void */* __restrict  */)(& pih.dosname), (size_t )12, (size_t )1, (FILE */* __restrict  */)f);
#line 119
    pih.vol = read8(f);
#line 120
    pih.c4spd = read16l(f);
#line 121
    pih.smpseg = read16l(f);
#line 122
    pih.smpofs = read32l(f);
#line 123
    pih.length = read32l(f);
#line 124
    pih.loopbeg = read32l(f);
#line 125
    pih.loopend = read32l(f);
#line 126
    pih.gusbeg = read32l(f);
#line 127
    pih.guslps = read32l(f);
#line 128
    pih.guslpe = read32l(f);
#line 129
    pih.gusflg = read8(f);
#line 130
    pih.rsvd1 = read8(f);
#line 131
    fread((void */* __restrict  */)(& pih.name), (size_t )28, (size_t )1, (FILE */* __restrict  */)f);
#line 132
    pih.magic = read32b(f);
    }
#line 134
    if (((int )pih.type & 3) != 1) {
#line 135
      goto __Cont;
    }
#line 137
    smp_ofs[i___3] = (int )pih.smpofs;
#line 138
    tmp___8 = (int )pih.length;
#line 138
    (m___0->xxs + i___3)->len = tmp___8;
#line 138
    if (tmp___8) {
#line 138
      tmp___9 = 1;
    } else {
#line 138
      tmp___9 = 0;
    }
#line 138
    (m___0->xxih + i___3)->nsm = tmp___9;
#line 139
    (m___0->xxs + i___3)->lps = (int )pih.loopbeg;
#line 140
    (m___0->xxs + i___3)->lpe = (int )pih.loopend;
#line 141
    if ((m___0->xxs + i___3)->lpe) {
#line 142
      ((m___0->xxs + i___3)->lpe) --;
    }
#line 143
    if ((int )pih.type & 4) {
#line 143
      (m___0->xxs + i___3)->flg = 4;
    } else {
#line 143
      (m___0->xxs + i___3)->flg = 0;
    }
#line 144
    if ((int )pih.type & 8) {
#line 144
      tmp___10 = 12;
    } else {
#line 144
      tmp___10 = 0;
    }
#line 144
    (m___0->xxs + i___3)->flg |= tmp___10;
#line 145
    if ((int )pih.type & 16) {
#line 145
      tmp___11 = 1;
    } else {
#line 145
      tmp___11 = 0;
    }
    {
#line 145
    (m___0->xxs + i___3)->flg |= tmp___11;
#line 146
    (*(m___0->xxi + i___3) + 0)->vol = (int )pih.vol;
#line 147
    (*(m___0->xxi + i___3) + 0)->pan = 128;
#line 148
    (*(m___0->xxi + i___3) + 0)->sid = i___3;
#line 149
    pih.magic = (uint32 )0;
#line 151
    copy_adjust((m___0->xxih + i___3)->name, pih.name, 28);
    }
#line 153
    if (m___0->verbosity > 1) {
      {
#line 153
      tmp___14 = strlen((char const   *)((char *)((m___0->xxih + i___3)->name)));
      }
#line 153
      if (tmp___14) {
#line 153
        goto _L;
      } else
#line 153
      if ((m___0->xxs + i___3)->len) {
        _L: /* CIL Label */ 
#line 154
        if ((m___0->xxs + i___3)->flg & 4) {
#line 154
          tmp___12 = 'L';
        } else {
#line 154
          tmp___12 = ' ';
        }
#line 154
        if ((int )pih.type & 16) {
#line 154
          tmp___13 = '+';
        } else {
#line 154
          tmp___13 = ' ';
        }
        {
#line 154
        report((char *)"[%2X] %-28.28s %05x%c%05x %05x %c V%02x %5d\n", i___3, (m___0->xxih + i___3)->name,
               (m___0->xxs + i___3)->len, tmp___13, (m___0->xxs + i___3)->lps, (m___0->xxs + i___3)->lpe,
               tmp___12, (*(m___0->xxi + i___3) + 0)->vol, (int )pih.c4spd);
        }
      }
    }
    {
#line 160
    c2spd_to_note((int )pih.c4spd, & (*(m___0->xxi + i___3) + 0)->xpo, & (*(m___0->xxi + i___3) + 0)->fin);
    }
    __Cont: /* CIL Label */ 
#line 114
    i___3 ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 163
  while (1) {
    while_continue___4: /* CIL Label */ ;
    {
#line 163
    tmp___15 = calloc((size_t )sizeof(struct xxm_track *), (size_t )(m___0->xxh)->trk);
#line 163
    m___0->xxt = (struct xxm_track **)tmp___15;
#line 163
    tmp___16 = calloc((size_t )sizeof(struct xxm_pattern *), (size_t )((m___0->xxh)->pat + 1));
#line 163
    m___0->xxp = (struct xxm_pattern **)tmp___16;
    }
#line 163
    goto while_break___4;
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 166
  reportv(ctx___0, 0, (char *)"Stored patterns: %d ", (m___0->xxh)->pat);
#line 168
  i___3 = 0;
  }
  {
#line 168
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 168
    if (! (i___3 < (m___0->xxh)->pat)) {
#line 168
      goto while_break___5;
    }
#line 169
    if (! pfh.patseg[i___3]) {
#line 170
      goto __Cont___0;
    }
    {
#line 171
    while (1) {
      while_continue___6: /* CIL Label */ ;
      {
#line 171
      tmp___17 = calloc((size_t )1, (size_t )(sizeof(struct xxm_pattern ) + sizeof(struct xxm_trackinfo ) * (unsigned long )((m___0->xxh)->chn - 1)));
#line 171
      *(m___0->xxp + i___3) = (struct xxm_pattern *)tmp___17;
      }
#line 171
      goto while_break___6;
    }
    while_break___6: /* CIL Label */ ;
    }
#line 172
    (*(m___0->xxp + i___3))->rows = 64;
    {
#line 173
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 173
      j = 0;
      {
#line 173
      while (1) {
        while_continue___8: /* CIL Label */ ;
#line 173
        if (! (j < (m___0->xxh)->chn)) {
#line 173
          goto while_break___8;
        }
        {
#line 173
        (*(m___0->xxp + i___3))->info[j].index = i___3 * (m___0->xxh)->chn + j;
#line 173
        tmp___18 = calloc((size_t )(sizeof(struct xxm_track ) + sizeof(struct xxm_event ) * (unsigned long )(*(m___0->xxp + i___3))->rows),
                          (size_t )1);
#line 173
        *(m___0->xxt + (i___3 * (m___0->xxh)->chn + j)) = (struct xxm_track *)tmp___18;
#line 173
        (*(m___0->xxt + (i___3 * (m___0->xxh)->chn + j)))->rows = (*(m___0->xxp + i___3))->rows;
#line 173
        j ++;
        }
      }
      while_break___8: /* CIL Label */ ;
      }
#line 173
      goto while_break___7;
    }
    while_break___7: /* CIL Label */ ;
    }
    {
#line 174
    fseek(f, (long )start + 16L * (long )pfh.patseg[i___3], 0);
#line 175
    r = 0;
    }
    {
#line 176
    while (1) {
      while_continue___9: /* CIL Label */ ;
#line 176
      if (! (r < 64)) {
#line 176
        goto while_break___9;
      }
      {
#line 177
      b___1 = read8(f);
      }
#line 178
      if (! b___1) {
#line 179
        r ++;
#line 180
        goto while_continue___9;
      }
#line 183
      c___0 = (int )b___1 & 31;
#line 184
      if (c___0 >= (m___0->xxh)->chn) {
#line 185
        goto while_continue___9;
      }
#line 187
      event = & (*(m___0->xxt + (*(m___0->xxp + i___3))->info[c___0].index))->event[r];
#line 188
      if ((int )b___1 & 32) {
        {
#line 189
        n___0 = read8(f);
        }
        {
#line 191
        if ((int )n___0 == 255) {
#line 191
          goto case_255;
        }
#line 194
        if ((int )n___0 == 254) {
#line 194
          goto case_254;
        }
#line 190
        goto switch_break;
        case_255: /* CIL Label */ 
#line 192
        n___0 = (uint8 )0;
#line 193
        goto switch_break;
        case_254: /* CIL Label */ 
#line 195
        n___0 = (uint8 )129;
#line 196
        goto switch_break;
        switch_break: /* CIL Label */ ;
        }
        {
#line 198
        event->note = n___0;
#line 199
        event->ins = read8(f);
        }
      }
#line 201
      if ((int )b___1 & 64) {
        {
#line 202
        event->fxt = read8(f);
#line 203
        event->fxp = read8(f);
        }
#line 205
        if ((int )event->fxt > 23) {
#line 206
          tmp___19 = (uint8 )0;
#line 206
          event->fxp = tmp___19;
#line 206
          event->fxt = tmp___19;
        }
        {
#line 209
        if ((int )event->fxt == 14) {
#line 209
          goto case_14;
        }
#line 215
        if ((int )event->fxt == 16) {
#line 215
          goto case_16;
        }
#line 218
        if ((int )event->fxt == 17) {
#line 218
          goto case_17;
        }
#line 221
        if ((int )event->fxt == 18) {
#line 221
          goto case_18;
        }
#line 224
        if ((int )event->fxt == 19) {
#line 224
          goto case_19;
        }
#line 227
        if ((int )event->fxt == 20) {
#line 227
          goto case_20;
        }
#line 230
        if ((int )event->fxt == 21) {
#line 230
          goto case_21;
        }
#line 233
        if ((int )event->fxt == 22) {
#line 233
          goto case_22;
        }
#line 236
        if ((int )event->fxt == 23) {
#line 236
          goto case_23;
        }
#line 208
        goto switch_break___0;
        case_14: /* CIL Label */ 
#line 210
        if (((int )event->fxp & 240) >> 4 == 8) {
#line 211
          event->fxt = (uint8 )8;
#line 212
          event->fxp = (uint8 )(((int )event->fxp & 15) << 4);
        }
#line 214
        goto switch_break___0;
        case_16: /* CIL Label */ 
#line 216
        event->fxt = (uint8 )16;
#line 217
        goto switch_break___0;
        case_17: /* CIL Label */ 
#line 219
        event->fxt = (uint8 )27;
#line 220
        goto switch_break___0;
        case_18: /* CIL Label */ 
#line 222
        event->fxt = (uint8 )172;
#line 223
        goto switch_break___0;
        case_19: /* CIL Label */ 
#line 225
        event->fxt = (uint8 )156;
#line 226
        goto switch_break___0;
        case_20: /* CIL Label */ 
#line 228
        event->fxt = (uint8 )157;
#line 229
        goto switch_break___0;
        case_21: /* CIL Label */ 
#line 231
        event->fxt = (uint8 )159;
#line 232
        goto switch_break___0;
        case_22: /* CIL Label */ 
#line 234
        event->fxt = (uint8 )158;
#line 235
        goto switch_break___0;
        case_23: /* CIL Label */ 
#line 237
        tmp___20 = (uint8 )0;
#line 237
        event->fxp = tmp___20;
#line 237
        event->fxt = tmp___20;
#line 238
        goto switch_break___0;
        switch_break___0: /* CIL Label */ ;
        }
      }
#line 241
      if ((int )b___1 & 128) {
        {
#line 242
        tmp___21 = read8(f);
#line 242
        event->vol = (uint8 )((int )tmp___21 + 1);
        }
      }
    }
    while_break___9: /* CIL Label */ ;
    }
    {
#line 245
    reportv(ctx___0, 0, (char *)".");
    }
    __Cont___0: /* CIL Label */ 
#line 168
    i___3 ++;
  }
  while_break___5: /* CIL Label */ ;
  }
  {
#line 248
  reportv(ctx___0, 0, (char *)"\nStored samples : %d ", (m___0->xxh)->smp);
#line 250
  i___3 = 0;
  }
  {
#line 250
  while (1) {
    while_continue___10: /* CIL Label */ ;
#line 250
    if (! (i___3 < (m___0->xxh)->smp)) {
#line 250
      goto while_break___10;
    }
#line 251
    if (! (m___0->xxs + i___3)->len) {
#line 252
      goto __Cont___1;
    }
    {
#line 253
    fseek(f, (long )(start + (int const   )smp_ofs[(*(m___0->xxi + i___3) + 0)->sid]),
          0);
#line 254
    xmp_drv_loadpatch(ctx___0, f, (*(m___0->xxi + i___3) + 0)->sid, m___0->c4rate,
                      4, m___0->xxs + (*(m___0->xxi + i___3) + 0)->sid, (char *)((void *)0));
#line 256
    reportv(ctx___0, 0, (char *)".");
    }
    __Cont___1: /* CIL Label */ 
#line 250
    i___3 ++;
  }
  while_break___10: /* CIL Label */ ;
  }
  {
#line 258
  reportv(ctx___0, 0, (char *)"\n");
#line 260
  m___0->vol_xlat = ptm_vol;
#line 262
  i___3 = 0;
  }
  {
#line 262
  while (1) {
    while_continue___11: /* CIL Label */ ;
#line 262
    if (! (i___3 < (m___0->xxh)->chn)) {
#line 262
      goto while_break___11;
    }
#line 263
    m___0->xxc[i___3].pan = (int )pfh.chset[i___3] << 4;
#line 262
    i___3 ++;
  }
  while_break___11: /* CIL Label */ ;
  }
#line 265
  return (0);
}
}
#line 16 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/mtm_load.c"
static int mtm_test(FILE *f , char *t , int const   start ) ;
#line 17
static int mtm_load(struct xmp_context *ctx___0 , FILE *f , int const   start ) ;
#line 19 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/mtm_load.c"
struct xmp_loader_info mtm_loader  =    {(char *)"MTM", (char *)"Multitracker", & mtm_test, & mtm_load, 0, {(struct list_head *)0,
                                                                       (struct list_head *)0}};
#line 26 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/mtm_load.c"
static int mtm_test(FILE *f , char *t , int const   start ) 
{ 
  uint8 buf___1[4] ;
  int tmp ;
  void *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
  {
#line 30
  fread((void */* __restrict  */)(buf___1), (size_t )1, (size_t )4, (FILE */* __restrict  */)f);
#line 31
  tmp = memcmp((void const   *)(buf___1), (void const   *)"MTM", (size_t )3);
  }
#line 31
  if (tmp) {
#line 32
    return (-1);
  }
#line 33
  if ((int )buf___1[3] != 16) {
#line 34
    return (-1);
  }
  {
#line 36
  read_title(f, t, 20);
  }
#line 38
  return (0);
}
}
#line 42 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/mtm_load.c"
static int mtm_load(struct xmp_context *ctx___0 , FILE *f , int const   start ) 
{ 
  struct xmp_player_context *p ;
  struct xmp_mod_context *m___0 ;
  int i___3 ;
  int j ;
  struct mtm_file_header mfh ;
  struct mtm_instrument_header mih ;
  uint8 mt[192] ;
  uint16 mp[32] ;
  uint8 **tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  size_t tmp___13 ;
  void *tmp___14 ;
  void *tmp___15 ;
  void *tmp___16 ;
  uint8 tmp___17 ;
  uint8 tmp___18 ;
  void *tmp___19 ;
  void *__cil_tmp33 ;
  void *__cil_tmp34 ;
  void *__cil_tmp35 ;
  void *__cil_tmp36 ;
  void *__cil_tmp37 ;
  void *__cil_tmp38 ;
  void *__cil_tmp39 ;
  void *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;

  {
#line 44
  p = & ctx___0->p;
#line 45
  m___0 = & p->m;
  {
#line 52
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 52
    fseek(f, (long )start, 0);
#line 52
    tmp = (uint8 **)((void *)0);
#line 52
    m___0->med_wav_table = tmp;
#line 52
    m___0->med_vol_table = tmp;
#line 52
    set_xxh_defaults(m___0->xxh);
    }
#line 52
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 54
  fread((void */* __restrict  */)(& mfh.magic), (size_t )3, (size_t )1, (FILE */* __restrict  */)f);
#line 55
  mfh.version = read8(f);
#line 56
  fread((void */* __restrict  */)(& mfh.name), (size_t )20, (size_t )1, (FILE */* __restrict  */)f);
#line 57
  mfh.tracks = read16l(f);
#line 58
  mfh.patterns = read8(f);
#line 59
  mfh.modlen = read8(f);
#line 60
  mfh.extralen = read16l(f);
#line 61
  mfh.samples = read8(f);
#line 62
  mfh.attr = read8(f);
#line 63
  mfh.rows = read8(f);
#line 64
  mfh.channels = read8(f);
#line 65
  fread((void */* __restrict  */)(& mfh.pan), (size_t )32, (size_t )1, (FILE */* __restrict  */)f);
#line 72
  (m___0->xxh)->trk = (int )mfh.tracks + 1;
#line 73
  (m___0->xxh)->pat = (int )mfh.patterns + 1;
#line 74
  (m___0->xxh)->len = (int )mfh.modlen + 1;
#line 75
  (m___0->xxh)->ins = (int )mfh.samples;
#line 76
  (m___0->xxh)->smp = (m___0->xxh)->ins;
#line 77
  (m___0->xxh)->chn = (int )mfh.channels;
#line 78
  (m___0->xxh)->tpo = 6;
#line 79
  (m___0->xxh)->bpm = 125;
#line 81
  strncpy((char */* __restrict  */)(m___0->name), (char const   */* __restrict  */)((char *)(mfh.name)),
          (size_t )20);
#line 82
  sprintf((char */* __restrict  */)(m___0->type), (char const   */* __restrict  */)"MTM (MultiTracker %d.%02d)",
          ((int )mfh.version & 240) >> 4, (int )mfh.version & 15);
  }
  {
#line 85
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 85
    if (m___0->verbosity) {
#line 85
      if (m___0->name[0]) {
        {
#line 85
        report((char *)"Module title   : %s\n", m___0->name);
        }
      }
#line 85
      if (m___0->type[0]) {
        {
#line 85
        report((char *)"Module type    : %s\n", m___0->type);
        }
      }
#line 85
      if (m___0->author[0]) {
        {
#line 85
        report((char *)"Author name    : %s\n", m___0->author);
        }
      }
#line 85
      if ((m___0->xxh)->len) {
        {
#line 85
        report((char *)"Module length  : %d patterns\n", (m___0->xxh)->len);
        }
      }
    }
#line 85
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 87
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 87
    tmp___0 = calloc((size_t )sizeof(struct xxm_instrument_header ), (size_t )(m___0->xxh)->ins);
#line 87
    m___0->xxih = (struct xxm_instrument_header *)tmp___0;
#line 87
    tmp___1 = calloc((size_t )sizeof(struct xxm_instrument_map ), (size_t )(m___0->xxh)->ins);
#line 87
    m___0->xxim = (struct xxm_instrument_map *)tmp___1;
#line 87
    tmp___2 = calloc((size_t )sizeof(struct xxm_instrument *), (size_t )(m___0->xxh)->ins);
#line 87
    m___0->xxi = (struct xxm_instrument **)tmp___2;
    }
#line 87
    if ((m___0->xxh)->smp) {
      {
#line 87
      tmp___3 = calloc((size_t )sizeof(struct xxm_sample ), (size_t )(m___0->xxh)->smp);
#line 87
      m___0->xxs = (struct xxm_sample *)tmp___3;
      }
    }
    {
#line 87
    tmp___4 = calloc((size_t )sizeof(uint16 *), (size_t )(m___0->xxh)->ins);
#line 87
    m___0->xxae = (uint16 **)tmp___4;
#line 87
    tmp___5 = calloc((size_t )sizeof(uint16 *), (size_t )(m___0->xxh)->ins);
#line 87
    m___0->xxpe = (uint16 **)tmp___5;
#line 87
    tmp___6 = calloc((size_t )sizeof(uint16 *), (size_t )(m___0->xxh)->ins);
#line 87
    m___0->xxfe = (uint16 **)tmp___6;
    }
#line 87
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 90
  i___3 = 0;
  {
#line 90
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 90
    if (! (i___3 < (m___0->xxh)->ins)) {
#line 90
      goto while_break___2;
    }
    {
#line 91
    tmp___7 = calloc((size_t )sizeof(struct xxm_instrument ), (size_t )1);
#line 91
    *(m___0->xxi + i___3) = (struct xxm_instrument *)tmp___7;
#line 93
    fread((void */* __restrict  */)(& mih.name), (size_t )22, (size_t )1, (FILE */* __restrict  */)f);
#line 94
    mih.length = read32l(f);
#line 95
    mih.loop_start = read32l(f);
#line 96
    mih.loopend = read32l(f);
#line 97
    mih.finetune = read8(f);
#line 98
    mih.volume = read8(f);
#line 99
    mih.attr = read8(f);
#line 101
    tmp___8 = (int )mih.length;
#line 101
    (m___0->xxs + i___3)->len = tmp___8;
    }
#line 101
    if (tmp___8) {
#line 101
      tmp___9 = 1;
    } else {
#line 101
      tmp___9 = 0;
    }
#line 101
    (m___0->xxih + i___3)->nsm = tmp___9;
#line 102
    (m___0->xxs + i___3)->lps = (int )mih.loop_start;
#line 103
    (m___0->xxs + i___3)->lpe = (int )mih.loopend;
#line 104
    if ((m___0->xxs + i___3)->lpe) {
#line 104
      (m___0->xxs + i___3)->flg = 4;
    } else {
#line 104
      (m___0->xxs + i___3)->flg = 0;
    }
#line 105
    if ((int )mfh.attr & 1) {
#line 105
      tmp___10 = 1;
    } else {
#line 105
      tmp___10 = 0;
    }
    {
#line 105
    (m___0->xxs + i___3)->flg |= tmp___10;
#line 106
    (*(m___0->xxi + i___3) + 0)->vol = (int )mih.volume;
#line 107
    (*(m___0->xxi + i___3) + 0)->fin = 128 + (int )((int8 )((int )mih.finetune << 4));
#line 108
    (*(m___0->xxi + i___3) + 0)->pan = 128;
#line 109
    (*(m___0->xxi + i___3) + 0)->sid = i___3;
#line 111
    copy_adjust((m___0->xxih + i___3)->name, mih.name, 22);
    }
#line 113
    if (m___0->verbosity > 1) {
      {
#line 113
      tmp___13 = strlen((char const   *)((char *)((m___0->xxih + i___3)->name)));
      }
#line 113
      if (tmp___13) {
#line 113
        goto _L;
      } else
#line 113
      if ((m___0->xxs + i___3)->len) {
        _L: /* CIL Label */ 
#line 114
        if ((m___0->xxs + i___3)->flg & 4) {
#line 114
          tmp___11 = 'L';
        } else {
#line 114
          tmp___11 = ' ';
        }
#line 114
        if ((m___0->xxs + i___3)->flg & 1) {
#line 114
          tmp___12 = '+';
        } else {
#line 114
          tmp___12 = ' ';
        }
        {
#line 114
        report((char *)"[%2X] %-22.22s %04x%c%04x %04x %c V%02x F%+03d\n", i___3,
               (m___0->xxih + i___3)->name, (m___0->xxs + i___3)->len, tmp___12, (m___0->xxs + i___3)->lps,
               (m___0->xxs + i___3)->lpe, tmp___11, (*(m___0->xxi + i___3) + 0)->vol,
               (*(m___0->xxi + i___3) + 0)->fin - 128);
        }
      }
    }
#line 90
    i___3 ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 120
  fread((void */* __restrict  */)(m___0->xxo), (size_t )1, (size_t )128, (FILE */* __restrict  */)f);
  }
  {
#line 122
  while (1) {
    while_continue___3: /* CIL Label */ ;
    {
#line 122
    tmp___14 = calloc((size_t )sizeof(struct xxm_track *), (size_t )(m___0->xxh)->trk);
#line 122
    m___0->xxt = (struct xxm_track **)tmp___14;
#line 122
    tmp___15 = calloc((size_t )sizeof(struct xxm_pattern *), (size_t )((m___0->xxh)->pat + 1));
#line 122
    m___0->xxp = (struct xxm_pattern **)tmp___15;
    }
#line 122
    goto while_break___3;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 124
  reportv(ctx___0, 0, (char *)"Stored tracks  : %d ", (m___0->xxh)->trk - 1);
#line 126
  i___3 = 0;
  }
  {
#line 126
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 126
    if (! (i___3 < (m___0->xxh)->trk)) {
#line 126
      goto while_break___4;
    }
    {
#line 127
    tmp___16 = calloc((size_t )(sizeof(struct xxm_track ) + sizeof(struct xxm_event ) * (unsigned long )mfh.rows),
                      (size_t )1);
#line 127
    *(m___0->xxt + i___3) = (struct xxm_track *)tmp___16;
#line 129
    (*(m___0->xxt + i___3))->rows = (int )mfh.rows;
    }
#line 130
    if (! i___3) {
#line 131
      goto __Cont;
    }
    {
#line 132
    fread((void */* __restrict  */)(& mt), (size_t )3, (size_t )64, (FILE */* __restrict  */)f);
#line 133
    j = 0;
    }
    {
#line 133
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 133
      if (! (j < 64)) {
#line 133
        goto while_break___5;
      }
#line 134
      tmp___17 = (uint8 )((int )mt[j * 3] >> 2);
#line 134
      (*(m___0->xxt + i___3))->event[j].note = tmp___17;
#line 134
      if (tmp___17) {
#line 135
        (*(m___0->xxt + i___3))->event[j].note = (uint8 )((int )(*(m___0->xxt + i___3))->event[j].note + 25);
      }
#line 136
      (*(m___0->xxt + i___3))->event[j].ins = (uint8 )((((int )mt[j * 3] & 3) << 4) + (((int )mt[j * 3 + 1] & 240) >> 4));
#line 137
      (*(m___0->xxt + i___3))->event[j].fxt = (uint8 )((int )mt[j * 3 + 1] & 15);
#line 138
      (*(m___0->xxt + i___3))->event[j].fxp = mt[j * 3 + 2];
#line 139
      if ((int )(*(m___0->xxt + i___3))->event[j].fxt > 15) {
#line 140
        tmp___18 = (uint8 )0;
#line 140
        (*(m___0->xxt + i___3))->event[j].fxp = tmp___18;
#line 140
        (*(m___0->xxt + i___3))->event[j].fxt = tmp___18;
      }
#line 142
      if ((int )(*(m___0->xxt + i___3))->event[j].fxt == 14) {
#line 142
        if (((int )(*(m___0->xxt + i___3))->event[j].fxp & 240) >> 4 == 8) {
#line 144
          (*(m___0->xxt + i___3))->event[j].fxt = (uint8 )8;
#line 145
          (*(m___0->xxt + i___3))->event[j].fxp = (uint8 )((int )(*(m___0->xxt + i___3))->event[j].fxp << 4);
        }
      }
#line 133
      j ++;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 148
    if (m___0->verbosity > 0) {
#line 148
      if (! (i___3 % (m___0->xxh)->chn)) {
        {
#line 149
        report((char *)".");
        }
      }
    }
    __Cont: /* CIL Label */ 
#line 126
    i___3 ++;
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 151
  reportv(ctx___0, 0, (char *)"\n");
#line 154
  reportv(ctx___0, 0, (char *)"Stored patterns: %d ", (m___0->xxh)->pat - 1);
#line 156
  i___3 = 0;
  }
  {
#line 156
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 156
    if (! (i___3 < (m___0->xxh)->pat)) {
#line 156
      goto while_break___6;
    }
    {
#line 157
    while (1) {
      while_continue___7: /* CIL Label */ ;
      {
#line 157
      tmp___19 = calloc((size_t )1, (size_t )(sizeof(struct xxm_pattern ) + sizeof(struct xxm_trackinfo ) * (unsigned long )((m___0->xxh)->chn - 1)));
#line 157
      *(m___0->xxp + i___3) = (struct xxm_pattern *)tmp___19;
      }
#line 157
      goto while_break___7;
    }
    while_break___7: /* CIL Label */ ;
    }
#line 158
    (*(m___0->xxp + i___3))->rows = 64;
#line 159
    j = 0;
    {
#line 159
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 159
      if (! (j < 32)) {
#line 159
        goto while_break___8;
      }
      {
#line 160
      mp[j] = read16l(f);
#line 159
      j ++;
      }
    }
    while_break___8: /* CIL Label */ ;
    }
#line 161
    j = 0;
    {
#line 161
    while (1) {
      while_continue___9: /* CIL Label */ ;
#line 161
      if (! (j < (m___0->xxh)->chn)) {
#line 161
        goto while_break___9;
      }
#line 162
      (*(m___0->xxp + i___3))->info[j].index = (int )mp[j];
#line 161
      j ++;
    }
    while_break___9: /* CIL Label */ ;
    }
    {
#line 163
    reportv(ctx___0, 0, (char *)".");
#line 156
    i___3 ++;
    }
  }
  while_break___6: /* CIL Label */ ;
  }
  {
#line 167
  fseek(f, (long )mfh.extralen, 1);
#line 170
  reportv(ctx___0, 0, (char *)"\nStored samples : %d ", (m___0->xxh)->smp);
#line 171
  i___3 = 0;
  }
  {
#line 171
  while (1) {
    while_continue___10: /* CIL Label */ ;
#line 171
    if (! (i___3 < (m___0->xxh)->ins)) {
#line 171
      goto while_break___10;
    }
    {
#line 172
    xmp_drv_loadpatch(ctx___0, f, (*(m___0->xxi + i___3) + 0)->sid, m___0->c4rate,
                      2, m___0->xxs + (*(m___0->xxi + i___3) + 0)->sid, (char *)((void *)0));
#line 174
    reportv(ctx___0, 0, (char *)".");
#line 171
    i___3 ++;
    }
  }
  while_break___10: /* CIL Label */ ;
  }
  {
#line 176
  reportv(ctx___0, 0, (char *)"\n");
#line 178
  i___3 = 0;
  }
  {
#line 178
  while (1) {
    while_continue___11: /* CIL Label */ ;
#line 178
    if (! (i___3 < (m___0->xxh)->chn)) {
#line 178
      goto while_break___11;
    }
#line 179
    m___0->xxc[i___3].pan = (int )mfh.pan[i___3] << 4;
#line 178
    i___3 ++;
  }
  while_break___11: /* CIL Label */ ;
  }
#line 181
  return (0);
}
}
#line 26 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/far_load.c"
static int far_test(FILE *f , char *t , int const   start ) ;
#line 27
static int far_load(struct xmp_context *ctx___0 , FILE *f , int const   start ) ;
#line 29 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/far_load.c"
struct xmp_loader_info far_loader  =    {(char *)"FAR", (char *)"Farandole Composer", & far_test, & far_load, 0, {(struct list_head *)0,
                                                                             (struct list_head *)0}};
#line 36 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/far_load.c"
static int far_test(FILE *f , char *t , int const   start ) 
{ 
  uint32 tmp ;

  {
  {
#line 38
  tmp = read32b(f);
  }
#line 38
  if (tmp != ((((70U << 24) | (65U << 16)) | (82U << 8)) | 254U)) {
#line 39
    return (-1);
  }
  {
#line 41
  read_title(f, t, 40);
  }
#line 43
  return (0);
}
}
#line 56 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/far_load.c"
static uint8 fx___5[16]  = 
#line 56
  {      (uint8 )255,      (uint8 )249,      (uint8 )248,      (uint8 )122, 
        (uint8 )251,      (uint8 )254,      (uint8 )4,      (uint8 )253, 
        (uint8 )252,      (uint8 )123,      (uint8 )255,      (uint8 )255, 
        (uint8 )250,      (uint8 )255,      (uint8 )255,      (uint8 )15};
#line 76 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/far_load.c"
static int far_load(struct xmp_context *ctx___0 , FILE *f , int const   start ) 
{ 
  struct xmp_player_context *p ;
  struct xmp_mod_context *m___0 ;
  int i___3 ;
  int j ;
  int vib___0 ;
  struct xxm_event *event ;
  struct far_header ffh ;
  struct far_header2 ffh2 ;
  struct far_instrument fih ;
  uint8 sample_map[8] ;
  uint8 **tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  uint8 brk ;
  uint8 note ;
  uint8 ins ;
  uint8 vol ;
  uint8 fxb ;
  void *tmp___2 ;
  int j___0 ;
  void *tmp___3 ;
  uint8 tmp___4 ;
  uint8 tmp___5 ;
  uint8 tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  void *tmp___9 ;
  void *tmp___10 ;
  void *tmp___11 ;
  void *tmp___12 ;
  void *tmp___13 ;
  void *tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  size_t tmp___19 ;
  void *__cil_tmp41 ;
  void *__cil_tmp42 ;
  void *__cil_tmp43 ;
  void *__cil_tmp44 ;
  void *__cil_tmp45 ;
  void *__cil_tmp46 ;
  void *__cil_tmp47 ;
  void *__cil_tmp48 ;
  void *__cil_tmp49 ;
  void *__cil_tmp50 ;
  void *__cil_tmp51 ;
  void *__cil_tmp52 ;
  void *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;

  {
#line 78
  p = & ctx___0->p;
#line 79
  m___0 = & p->m;
#line 80
  vib___0 = 0;
  {
#line 87
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 87
    fseek(f, (long )start, 0);
#line 87
    tmp = (uint8 **)((void *)0);
#line 87
    m___0->med_wav_table = tmp;
#line 87
    m___0->med_vol_table = tmp;
#line 87
    set_xxh_defaults(m___0->xxh);
    }
#line 87
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 89
  read32b(f);
#line 90
  fread((void */* __restrict  */)(& ffh.name), (size_t )40, (size_t )1, (FILE */* __restrict  */)f);
#line 91
  fread((void */* __restrict  */)(& ffh.crlf), (size_t )3, (size_t )1, (FILE */* __restrict  */)f);
#line 92
  ffh.headersize = read16l(f);
#line 93
  ffh.version = read8(f);
#line 94
  fread((void */* __restrict  */)(& ffh.ch_on), (size_t )16, (size_t )1, (FILE */* __restrict  */)f);
#line 95
  fseek(f, 9L, 1);
#line 96
  ffh.tempo = read8(f);
#line 97
  fread((void */* __restrict  */)(& ffh.pan), (size_t )16, (size_t )1, (FILE */* __restrict  */)f);
#line 98
  read32l(f);
#line 99
  ffh.textlen = read16l(f);
#line 101
  fseek(f, (long )ffh.textlen, 1);
#line 103
  fread((void */* __restrict  */)(& ffh2.order), (size_t )256, (size_t )1, (FILE */* __restrict  */)f);
#line 104
  ffh2.patterns = read8(f);
#line 105
  ffh2.songlen = read8(f);
#line 106
  ffh2.restart = read8(f);
#line 107
  i___3 = 0;
  }
  {
#line 107
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 107
    if (! (i___3 < 256)) {
#line 107
      goto while_break___0;
    }
    {
#line 108
    ffh2.patsize[i___3] = read16l(f);
#line 107
    i___3 ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 110
  (m___0->xxh)->chn = 16;
#line 112
  (m___0->xxh)->len = (int )ffh2.songlen;
#line 113
  (m___0->xxh)->tpo = 6;
#line 114
  (m___0->xxh)->bpm = 480 / (int )ffh.tempo;
#line 115
  memcpy((void */* __restrict  */)(m___0->xxo), (void const   */* __restrict  */)(ffh2.order),
         (size_t )(m___0->xxh)->len);
#line 117
  i___3 = 0;
#line 117
  (m___0->xxh)->pat = i___3;
  }
  {
#line 117
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 117
    if (! (i___3 < 256)) {
#line 117
      goto while_break___1;
    }
#line 118
    if (ffh2.patsize[i___3]) {
#line 119
      (m___0->xxh)->pat = i___3 + 1;
    }
#line 117
    i___3 ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 122
  (m___0->xxh)->trk = (m___0->xxh)->chn * (m___0->xxh)->pat;
#line 124
  strncpy((char */* __restrict  */)(m___0->name), (char const   */* __restrict  */)((char *)(ffh.name)),
          (size_t )40);
#line 125
  sprintf((char */* __restrict  */)(m___0->type), (char const   */* __restrict  */)"FAR (Farandole Composer %d.%d)",
          ((int )ffh.version & 240) >> 4, (int )ffh.version & 15);
  }
  {
#line 128
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 128
    if (m___0->verbosity) {
#line 128
      if (m___0->name[0]) {
        {
#line 128
        report((char *)"Module title   : %s\n", m___0->name);
        }
      }
#line 128
      if (m___0->type[0]) {
        {
#line 128
        report((char *)"Module type    : %s\n", m___0->type);
        }
      }
#line 128
      if (m___0->author[0]) {
        {
#line 128
        report((char *)"Author name    : %s\n", m___0->author);
        }
      }
#line 128
      if ((m___0->xxh)->len) {
        {
#line 128
        report((char *)"Module length  : %d patterns\n", (m___0->xxh)->len);
        }
      }
    }
#line 128
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 130
  while (1) {
    while_continue___3: /* CIL Label */ ;
    {
#line 130
    tmp___0 = calloc((size_t )sizeof(struct xxm_track *), (size_t )(m___0->xxh)->trk);
#line 130
    m___0->xxt = (struct xxm_track **)tmp___0;
#line 130
    tmp___1 = calloc((size_t )sizeof(struct xxm_pattern *), (size_t )((m___0->xxh)->pat + 1));
#line 130
    m___0->xxp = (struct xxm_pattern **)tmp___1;
    }
#line 130
    goto while_break___3;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 133
  if (m___0->verbosity > 0) {
    {
#line 134
    report((char *)"Comment bytes  : %d\n", (int )ffh.textlen);
#line 135
    report((char *)"Stored patterns: %d ", (m___0->xxh)->pat);
    }
  }
#line 138
  i___3 = 0;
  {
#line 138
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 138
    if (! (i___3 < (m___0->xxh)->pat)) {
#line 138
      goto while_break___4;
    }
    {
#line 141
    while (1) {
      while_continue___5: /* CIL Label */ ;
      {
#line 141
      tmp___2 = calloc((size_t )1, (size_t )(sizeof(struct xxm_pattern ) + sizeof(struct xxm_trackinfo ) * (unsigned long )((m___0->xxh)->chn - 1)));
#line 141
      *(m___0->xxp + i___3) = (struct xxm_pattern *)tmp___2;
      }
#line 141
      goto while_break___5;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 142
    if (! ffh2.patsize[i___3]) {
#line 143
      goto __Cont;
    }
#line 144
    (*(m___0->xxp + i___3))->rows = ((int )ffh2.patsize[i___3] - 2) / 64;
    {
#line 145
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 145
      j___0 = 0;
      {
#line 145
      while (1) {
        while_continue___7: /* CIL Label */ ;
#line 145
        if (! (j___0 < (m___0->xxh)->chn)) {
#line 145
          goto while_break___7;
        }
        {
#line 145
        (*(m___0->xxp + i___3))->info[j___0].index = i___3 * (m___0->xxh)->chn + j___0;
#line 145
        tmp___3 = calloc((size_t )(sizeof(struct xxm_track ) + sizeof(struct xxm_event ) * (unsigned long )(*(m___0->xxp + i___3))->rows),
                         (size_t )1);
#line 145
        *(m___0->xxt + (i___3 * (m___0->xxh)->chn + j___0)) = (struct xxm_track *)tmp___3;
#line 145
        (*(m___0->xxt + (i___3 * (m___0->xxh)->chn + j___0)))->rows = (*(m___0->xxp + i___3))->rows;
#line 145
        j___0 ++;
        }
      }
      while_break___7: /* CIL Label */ ;
      }
#line 145
      goto while_break___6;
    }
    while_break___6: /* CIL Label */ ;
    }
    {
#line 147
    tmp___4 = read8(f);
#line 147
    brk = (uint8 )((int )tmp___4 + 1);
#line 148
    read8(f);
#line 150
    j = 0;
    }
    {
#line 150
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 150
      if (! (j < (*(m___0->xxp + i___3))->rows * (m___0->xxh)->chn)) {
#line 150
        goto while_break___8;
      }
#line 151
      event = & (*(m___0->xxt + (*(m___0->xxp + i___3))->info[j % (m___0->xxh)->chn].index))->event[j / (m___0->xxh)->chn];
#line 153
      if (j % (m___0->xxh)->chn == 0) {
#line 153
        if (j / (m___0->xxh)->chn == (int )brk) {
#line 154
          event->f2t = (uint8 )13;
        }
      }
      {
#line 156
      note = read8(f);
#line 157
      ins = read8(f);
#line 158
      vol = read8(f);
#line 159
      fxb = read8(f);
      }
#line 161
      if (note) {
#line 162
        event->note = (uint8 )((int )note + 36);
      }
#line 163
      if (event->note) {
#line 164
        event->ins = (uint8 )((int )ins + 1);
      } else
#line 163
      if (ins) {
#line 164
        event->ins = (uint8 )((int )ins + 1);
      }
#line 166
      vol = (uint8 )(16 * ((int )vol & 15) + (((int )vol & 240) >> 4));
#line 168
      if (vol) {
#line 169
        event->vol = (uint8 )((int )vol - 16);
      }
#line 171
      event->fxt = fx___5[((int )fxb & 240) >> 4];
#line 172
      event->fxp = (uint8 )((int )fxb & 15);
      {
#line 175
      if ((int )event->fxt == 255) {
#line 175
        goto case_255;
      }
#line 178
      if ((int )event->fxt == 249) {
#line 178
        goto case_249;
      }
#line 182
      if ((int )event->fxt == 248) {
#line 182
        goto case_248;
      }
#line 186
      if ((int )event->fxt == 251) {
#line 186
        goto case_251;
      }
#line 190
      if ((int )event->fxt == 250) {
#line 190
        goto case_250;
      }
#line 194
      if ((int )event->fxt == 254) {
#line 194
        goto case_254;
      }
#line 198
      if ((int )event->fxt == 4) {
#line 198
        goto case_4;
      }
#line 201
      if ((int )event->fxt == 123) {
#line 201
        goto case_123;
      }
#line 204
      if ((int )event->fxt == 253) {
#line 204
        goto case_253;
      }
#line 208
      if ((int )event->fxt == 252) {
#line 208
        goto case_252;
      }
#line 212
      if ((int )event->fxt == 15) {
#line 212
        goto case_15;
      }
#line 174
      goto switch_break;
      case_255: /* CIL Label */ 
#line 176
      tmp___5 = (uint8 )0;
#line 176
      event->fxp = tmp___5;
#line 176
      event->fxt = tmp___5;
#line 177
      goto switch_break;
      case_249: /* CIL Label */ 
#line 179
      event->fxt = (uint8 )14;
#line 180
      event->fxp = (uint8 )((int )event->fxp | (1 << 4));
#line 181
      goto switch_break;
      case_248: /* CIL Label */ 
#line 183
      event->fxt = (uint8 )14;
#line 184
      event->fxp = (uint8 )((int )event->fxp | (2 << 4));
#line 185
      goto switch_break;
      case_251: /* CIL Label */ 
#line 187
      event->fxt = (uint8 )14;
#line 188
      event->fxp = (uint8 )((int )event->fxp | (9 << 4));
#line 189
      goto switch_break;
      case_250: /* CIL Label */ 
#line 191
      event->fxt = (uint8 )14;
#line 192
      event->fxp = (uint8 )((int )event->fxp | (13 << 4));
#line 193
      goto switch_break;
      case_254: /* CIL Label */ 
#line 195
      vib___0 = (int )event->fxp & 15;
#line 196
      tmp___6 = (uint8 )0;
#line 196
      event->fxp = tmp___6;
#line 196
      event->fxt = tmp___6;
#line 197
      goto switch_break;
      case_4: /* CIL Label */ 
#line 199
      event->fxp = (uint8 )(((int )event->fxp << 4) + vib___0);
#line 200
      goto switch_break;
      case_123: /* CIL Label */ 
#line 202
      event->fxp = (uint8 )(((int )event->fxp << 4) + vib___0);
#line 203
      goto switch_break;
      case_253: /* CIL Label */ 
#line 205
      event->fxt = (uint8 )14;
#line 206
      event->fxp = (uint8 )((int )event->fxp | (10 << 4));
#line 207
      goto switch_break;
      case_252: /* CIL Label */ 
#line 209
      event->fxt = (uint8 )14;
#line 210
      event->fxp = (uint8 )((int )event->fxp | (11 << 4));
#line 211
      goto switch_break;
      case_15: /* CIL Label */ 
#line 213
      event->fxp = (uint8 )(480 / (int )event->fxp);
#line 214
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
#line 150
      j ++;
    }
    while_break___8: /* CIL Label */ ;
    }
    {
#line 217
    reportv(ctx___0, 0, (char *)".");
    }
    __Cont: /* CIL Label */ 
#line 138
    i___3 ++;
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 220
  (m___0->xxh)->ins = -1;
#line 221
  fread((void */* __restrict  */)(sample_map), (size_t )1, (size_t )8, (FILE */* __restrict  */)f);
#line 222
  i___3 = 0;
  }
  {
#line 222
  while (1) {
    while_continue___9: /* CIL Label */ ;
#line 222
    if (! (i___3 < 64)) {
#line 222
      goto while_break___9;
    }
#line 223
    if ((int )sample_map[i___3 / 8] & (1 << i___3 % 8)) {
#line 224
      (m___0->xxh)->ins = i___3;
    }
#line 222
    i___3 ++;
  }
  while_break___9: /* CIL Label */ ;
  }
#line 226
  ((m___0->xxh)->ins) ++;
#line 228
  (m___0->xxh)->smp = (m___0->xxh)->ins;
  {
#line 230
  while (1) {
    while_continue___10: /* CIL Label */ ;
    {
#line 230
    tmp___7 = calloc((size_t )sizeof(struct xxm_instrument_header ), (size_t )(m___0->xxh)->ins);
#line 230
    m___0->xxih = (struct xxm_instrument_header *)tmp___7;
#line 230
    tmp___8 = calloc((size_t )sizeof(struct xxm_instrument_map ), (size_t )(m___0->xxh)->ins);
#line 230
    m___0->xxim = (struct xxm_instrument_map *)tmp___8;
#line 230
    tmp___9 = calloc((size_t )sizeof(struct xxm_instrument *), (size_t )(m___0->xxh)->ins);
#line 230
    m___0->xxi = (struct xxm_instrument **)tmp___9;
    }
#line 230
    if ((m___0->xxh)->smp) {
      {
#line 230
      tmp___10 = calloc((size_t )sizeof(struct xxm_sample ), (size_t )(m___0->xxh)->smp);
#line 230
      m___0->xxs = (struct xxm_sample *)tmp___10;
      }
    }
    {
#line 230
    tmp___11 = calloc((size_t )sizeof(uint16 *), (size_t )(m___0->xxh)->ins);
#line 230
    m___0->xxae = (uint16 **)tmp___11;
#line 230
    tmp___12 = calloc((size_t )sizeof(uint16 *), (size_t )(m___0->xxh)->ins);
#line 230
    m___0->xxpe = (uint16 **)tmp___12;
#line 230
    tmp___13 = calloc((size_t )sizeof(uint16 *), (size_t )(m___0->xxh)->ins);
#line 230
    m___0->xxfe = (uint16 **)tmp___13;
    }
#line 230
    goto while_break___10;
  }
  while_break___10: /* CIL Label */ ;
  }
  {
#line 233
  reportv(ctx___0, 0, (char *)"\nInstruments    : %d ", (m___0->xxh)->ins);
#line 235
  i___3 = 0;
  }
  {
#line 235
  while (1) {
    while_continue___11: /* CIL Label */ ;
#line 235
    if (! (i___3 < (m___0->xxh)->ins)) {
#line 235
      goto while_break___11;
    }
#line 236
    if (! ((int )sample_map[i___3 / 8] & (1 << i___3 % 8))) {
#line 237
      goto __Cont___0;
    }
    {
#line 239
    tmp___14 = calloc((size_t )sizeof(struct xxm_instrument ), (size_t )1);
#line 239
    *(m___0->xxi + i___3) = (struct xxm_instrument *)tmp___14;
#line 241
    fread((void */* __restrict  */)(& fih.name), (size_t )32, (size_t )1, (FILE */* __restrict  */)f);
#line 242
    fih.length = read32l(f);
#line 243
    fih.finetune = read8(f);
#line 244
    fih.volume = read8(f);
#line 245
    fih.loop_start = read32l(f);
#line 246
    fih.loopend = read32l(f);
#line 247
    fih.sampletype = read8(f);
#line 248
    fih.loopmode = read8(f);
#line 250
    fih.length &= 65535U;
#line 251
    fih.loop_start &= 65535U;
#line 252
    fih.loopend &= 65535U;
#line 253
    tmp___15 = (int )fih.length;
#line 253
    (m___0->xxs + i___3)->len = tmp___15;
    }
#line 253
    if (tmp___15) {
#line 253
      tmp___16 = 1;
    } else {
#line 253
      tmp___16 = 0;
    }
#line 253
    (m___0->xxih + i___3)->nsm = tmp___16;
#line 254
    (m___0->xxs + i___3)->lps = (int )fih.loop_start;
#line 255
    (m___0->xxs + i___3)->lpe = (int )fih.loopend;
#line 256
    if (fih.sampletype) {
#line 256
      (m___0->xxs + i___3)->flg = 1;
    } else {
#line 256
      (m___0->xxs + i___3)->flg = 0;
    }
#line 257
    if (fih.loopmode) {
#line 257
      tmp___17 = 4;
    } else {
#line 257
      tmp___17 = 0;
    }
    {
#line 257
    (m___0->xxs + i___3)->flg |= tmp___17;
#line 258
    (*(m___0->xxi + i___3) + 0)->vol = 255;
#line 259
    (*(m___0->xxi + i___3) + 0)->sid = i___3;
#line 261
    copy_adjust((m___0->xxih + i___3)->name, fih.name, 32);
    }
#line 263
    if (m___0->verbosity > 1) {
      {
#line 263
      tmp___19 = strlen((char const   *)((char *)((m___0->xxih + i___3)->name)));
      }
#line 263
      if (tmp___19) {
#line 263
        goto _L;
      } else
#line 263
      if ((m___0->xxs + i___3)->len) {
        _L: /* CIL Label */ 
#line 263
        if ((m___0->xxs + i___3)->lps != 65535) {
#line 264
          if (fih.loopmode) {
#line 264
            tmp___18 = 'L';
          } else {
#line 264
            tmp___18 = ' ';
          }
          {
#line 264
          report((char *)"\n[%2X] %-32.32s %04x %04x %04x %c V%02x ", i___3, (m___0->xxih + i___3)->name,
                 (m___0->xxs + i___3)->len, (m___0->xxs + i___3)->lps, (m___0->xxs + i___3)->lpe,
                 tmp___18, (*(m___0->xxi + i___3) + 0)->vol);
#line 268
          reportv(ctx___0, 0, (char *)".");
          }
        }
      }
    }
    {
#line 270
    xmp_drv_loadpatch(ctx___0, f, (*(m___0->xxi + i___3) + 0)->sid, m___0->c4rate,
                      0, m___0->xxs + i___3, (char *)((void *)0));
    }
    __Cont___0: /* CIL Label */ 
#line 235
    i___3 ++;
  }
  while_break___11: /* CIL Label */ ;
  }
  {
#line 272
  reportv(ctx___0, 0, (char *)"\n");
#line 274
  m___0->volbase = 255;
  }
#line 276
  return (0);
}
}
#line 16 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/669_load.c"
static int ssn_test(FILE *f , char *t , int const   start ) ;
#line 17
static int ssn_load(struct xmp_context *ctx___0 , FILE *f , int const   start ) ;
#line 19 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/669_load.c"
struct xmp_loader_info ssn_loader  =    {(char *)"669", (char *)"Composer 669", & ssn_test, & ssn_load, 0, {(struct list_head *)0,
                                                                       (struct list_head *)0}};
#line 26 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/669_load.c"
static int ssn_test(FILE *f , char *t , int const   start ) 
{ 
  uint16 id ;
  uint8 tmp ;

  {
  {
#line 30
  id = read16b(f);
  }
#line 31
  if ((int )id != 26982) {
#line 31
    if ((int )id != 19022) {
#line 32
      return (-1);
    }
  }
  {
#line 34
  fseek(f, 238L, 1);
#line 35
  tmp = read8(f);
  }
#line 35
  if ((int )tmp != 255) {
#line 36
    return (-1);
  }
  {
#line 38
  fseek(f, 2L, 1);
#line 39
  read_title(f, t, 36);
  }
#line 41
  return (0);
}
}
#line 69 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/669_load.c"
static uint8 fx___6[6]  = {      (uint8 )121,      (uint8 )120,      (uint8 )122,      (uint8 )166, 
        (uint8 )123,      (uint8 )126};
#line 79 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/669_load.c"
static int ssn_load(struct xmp_context *ctx___0 , FILE *f , int const   start ) 
{ 
  struct xmp_player_context *p ;
  struct xmp_mod_context *m___0 ;
  int i___3 ;
  int j ;
  struct xxm_event *event ;
  struct ssn_file_header sfh ;
  struct ssn_instrument_header sih ;
  uint8 ev[3] ;
  uint8 **tmp ;
  char const   *tmp___1 ;
  int tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  void *tmp___9 ;
  void *tmp___10 ;
  void *tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  size_t tmp___15 ;
  void *tmp___16 ;
  void *tmp___17 ;
  void *tmp___18 ;
  int j___0 ;
  void *tmp___19 ;
  void *__cil_tmp34 ;
  void *__cil_tmp35 ;
  void *__cil_tmp36 ;
  void *__cil_tmp37 ;
  void *__cil_tmp38 ;
  void *__cil_tmp39 ;
  void *__cil_tmp40 ;
  void *__cil_tmp41 ;
  void *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;

  {
#line 81
  p = & ctx___0->p;
#line 82
  m___0 = & p->m;
  {
#line 89
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 89
    fseek(f, (long )start, 0);
#line 89
    tmp = (uint8 **)((void *)0);
#line 89
    m___0->med_wav_table = tmp;
#line 89
    m___0->med_vol_table = tmp;
#line 89
    set_xxh_defaults(m___0->xxh);
    }
#line 89
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 91
  fread((void */* __restrict  */)(& sfh.marker), (size_t )2, (size_t )1, (FILE */* __restrict  */)f);
#line 92
  fread((void */* __restrict  */)(& sfh.message), (size_t )108, (size_t )1, (FILE */* __restrict  */)f);
#line 93
  sfh.nos = read8(f);
#line 94
  sfh.nop = read8(f);
#line 95
  sfh.loop = read8(f);
#line 96
  fread((void */* __restrict  */)(& sfh.order), (size_t )128, (size_t )1, (FILE */* __restrict  */)f);
#line 97
  fread((void */* __restrict  */)(& sfh.tempo), (size_t )128, (size_t )1, (FILE */* __restrict  */)f);
#line 98
  fread((void */* __restrict  */)(& sfh.pbrk), (size_t )128, (size_t )1, (FILE */* __restrict  */)f);
#line 100
  (m___0->xxh)->chn = 8;
#line 101
  (m___0->xxh)->ins = (int )sfh.nos;
#line 102
  (m___0->xxh)->pat = (int )sfh.nop;
#line 103
  (m___0->xxh)->trk = (m___0->xxh)->chn * (m___0->xxh)->pat;
#line 104
  i___3 = 0;
  }
  {
#line 104
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 104
    if (! (i___3 < 128)) {
#line 104
      goto while_break___0;
    }
#line 105
    if ((int )sfh.order[i___3] > (int )sfh.nop) {
#line 106
      goto while_break___0;
    }
#line 104
    i___3 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 107
  (m___0->xxh)->len = i___3;
#line 108
  memcpy((void */* __restrict  */)(m___0->xxo), (void const   */* __restrict  */)(sfh.order),
         (size_t )(m___0->xxh)->len);
#line 109
  (m___0->xxh)->tpo = 6;
#line 110
  (m___0->xxh)->bpm = 76;
#line 111
  (m___0->xxh)->smp = (m___0->xxh)->ins;
#line 112
  (m___0->xxh)->flg |= 1;
#line 114
  copy_adjust((uint8 *)(m___0->name), sfh.message, 36);
#line 115
  tmp___2 = strncmp((char const   *)((char *)(sfh.marker)), "if", (size_t )2);
  }
#line 115
  if (tmp___2) {
#line 115
    tmp___1 = "669 (UNIS 669)";
  } else {
#line 115
    tmp___1 = "669 (Composer 669)";
  }
  {
#line 115
  strcpy((char */* __restrict  */)(m___0->type), (char const   */* __restrict  */)tmp___1);
  }
  {
#line 118
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 118
    if (m___0->verbosity) {
#line 118
      if (m___0->name[0]) {
        {
#line 118
        report((char *)"Module title   : %s\n", m___0->name);
        }
      }
#line 118
      if (m___0->type[0]) {
        {
#line 118
        report((char *)"Module type    : %s\n", m___0->type);
        }
      }
#line 118
      if (m___0->author[0]) {
        {
#line 118
        report((char *)"Author name    : %s\n", m___0->author);
        }
      }
#line 118
      if ((m___0->xxh)->len) {
        {
#line 118
        report((char *)"Module length  : %d patterns\n", (m___0->xxh)->len);
        }
      }
    }
#line 118
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 120
  tmp___3 = malloc((size_t )109);
#line 120
  m___0->comment = (char *)tmp___3;
#line 121
  memcpy((void */* __restrict  */)m___0->comment, (void const   */* __restrict  */)(sfh.message),
         (size_t )108);
#line 122
  *(m___0->comment + 108) = (char)0;
  }
#line 124
  if (m___0->verbosity > 1) {
    {
#line 125
    report((char *)"| %-36.36s\n", sfh.message);
#line 126
    report((char *)"| %-36.36s\n", sfh.message + 36);
#line 127
    report((char *)"| %-36.36s\n", sfh.message + 72);
    }
  }
  {
#line 132
  while (1) {
    while_continue___2: /* CIL Label */ ;
    {
#line 132
    tmp___4 = calloc((size_t )sizeof(struct xxm_instrument_header ), (size_t )(m___0->xxh)->ins);
#line 132
    m___0->xxih = (struct xxm_instrument_header *)tmp___4;
#line 132
    tmp___5 = calloc((size_t )sizeof(struct xxm_instrument_map ), (size_t )(m___0->xxh)->ins);
#line 132
    m___0->xxim = (struct xxm_instrument_map *)tmp___5;
#line 132
    tmp___6 = calloc((size_t )sizeof(struct xxm_instrument *), (size_t )(m___0->xxh)->ins);
#line 132
    m___0->xxi = (struct xxm_instrument **)tmp___6;
    }
#line 132
    if ((m___0->xxh)->smp) {
      {
#line 132
      tmp___7 = calloc((size_t )sizeof(struct xxm_sample ), (size_t )(m___0->xxh)->smp);
#line 132
      m___0->xxs = (struct xxm_sample *)tmp___7;
      }
    }
    {
#line 132
    tmp___8 = calloc((size_t )sizeof(uint16 *), (size_t )(m___0->xxh)->ins);
#line 132
    m___0->xxae = (uint16 **)tmp___8;
#line 132
    tmp___9 = calloc((size_t )sizeof(uint16 *), (size_t )(m___0->xxh)->ins);
#line 132
    m___0->xxpe = (uint16 **)tmp___9;
#line 132
    tmp___10 = calloc((size_t )sizeof(uint16 *), (size_t )(m___0->xxh)->ins);
#line 132
    m___0->xxfe = (uint16 **)tmp___10;
    }
#line 132
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 134
  reportv(ctx___0, 0, (char *)"Instruments    : %d\n", (m___0->xxh)->pat);
#line 135
  reportv(ctx___0, 1, (char *)"     Instrument     Len  LBeg LEnd L\n");
#line 137
  i___3 = 0;
  }
  {
#line 137
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 137
    if (! (i___3 < (m___0->xxh)->ins)) {
#line 137
      goto while_break___3;
    }
    {
#line 138
    tmp___11 = calloc((size_t )sizeof(struct xxm_instrument ), (size_t )1);
#line 138
    *(m___0->xxi + i___3) = (struct xxm_instrument *)tmp___11;
#line 140
    fread((void */* __restrict  */)(& sih.name), (size_t )13, (size_t )1, (FILE */* __restrict  */)f);
#line 141
    sih.length = read32l(f);
#line 142
    sih.loop_start = read32l(f);
#line 143
    sih.loopend = read32l(f);
#line 145
    tmp___12 = (int )sih.length;
#line 145
    (m___0->xxs + i___3)->len = tmp___12;
    }
#line 145
    if (tmp___12) {
#line 145
      tmp___13 = 1;
    } else {
#line 145
      tmp___13 = 0;
    }
#line 145
    (m___0->xxih + i___3)->nsm = tmp___13;
#line 146
    (m___0->xxs + i___3)->lps = (int )sih.loop_start;
#line 147
    if (sih.loopend >= 1048575U) {
#line 147
      (m___0->xxs + i___3)->lpe = 0;
    } else {
#line 147
      (m___0->xxs + i___3)->lpe = (int )sih.loopend;
    }
#line 148
    if ((m___0->xxs + i___3)->lpe) {
#line 148
      (m___0->xxs + i___3)->flg = 4;
    } else {
#line 148
      (m___0->xxs + i___3)->flg = 0;
    }
    {
#line 149
    (*(m___0->xxi + i___3) + 0)->vol = 64;
#line 150
    (*(m___0->xxi + i___3) + 0)->pan = 128;
#line 151
    (*(m___0->xxi + i___3) + 0)->sid = i___3;
#line 153
    copy_adjust((m___0->xxih + i___3)->name, sih.name, 13);
    }
#line 155
    if (m___0->verbosity > 1) {
      {
#line 155
      tmp___15 = strlen((char const   *)((char *)((m___0->xxih + i___3)->name)));
      }
#line 155
      if (tmp___15) {
#line 155
        goto _L;
      } else
#line 155
      if ((m___0->xxs + i___3)->len > 2) {
        _L: /* CIL Label */ 
#line 156
        if ((m___0->xxs + i___3)->flg & 4) {
#line 156
          tmp___14 = 'L';
        } else {
#line 156
          tmp___14 = ' ';
        }
        {
#line 156
        report((char *)"[%2X] %-14.14s %04x %04x %04x %c\n", i___3, (m___0->xxih + i___3)->name,
               (m___0->xxs + i___3)->len, (m___0->xxs + i___3)->lps, (m___0->xxs + i___3)->lpe,
               tmp___14);
        }
      }
    }
#line 137
    i___3 ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 161
  while (1) {
    while_continue___4: /* CIL Label */ ;
    {
#line 161
    tmp___16 = calloc((size_t )sizeof(struct xxm_track *), (size_t )(m___0->xxh)->trk);
#line 161
    m___0->xxt = (struct xxm_track **)tmp___16;
#line 161
    tmp___17 = calloc((size_t )sizeof(struct xxm_pattern *), (size_t )((m___0->xxh)->pat + 1));
#line 161
    m___0->xxp = (struct xxm_pattern **)tmp___17;
    }
#line 161
    goto while_break___4;
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 164
  reportv(ctx___0, 0, (char *)"Stored patterns: %d ", (m___0->xxh)->pat);
#line 165
  i___3 = 0;
  }
  {
#line 165
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 165
    if (! (i___3 < (m___0->xxh)->pat)) {
#line 165
      goto while_break___5;
    }
    {
#line 166
    while (1) {
      while_continue___6: /* CIL Label */ ;
      {
#line 166
      tmp___18 = calloc((size_t )1, (size_t )(sizeof(struct xxm_pattern ) + sizeof(struct xxm_trackinfo ) * (unsigned long )((m___0->xxh)->chn - 1)));
#line 166
      *(m___0->xxp + i___3) = (struct xxm_pattern *)tmp___18;
      }
#line 166
      goto while_break___6;
    }
    while_break___6: /* CIL Label */ ;
    }
#line 167
    (*(m___0->xxp + i___3))->rows = 64;
    {
#line 168
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 168
      j___0 = 0;
      {
#line 168
      while (1) {
        while_continue___8: /* CIL Label */ ;
#line 168
        if (! (j___0 < (m___0->xxh)->chn)) {
#line 168
          goto while_break___8;
        }
        {
#line 168
        (*(m___0->xxp + i___3))->info[j___0].index = i___3 * (m___0->xxh)->chn + j___0;
#line 168
        tmp___19 = calloc((size_t )(sizeof(struct xxm_track ) + sizeof(struct xxm_event ) * (unsigned long )(*(m___0->xxp + i___3))->rows),
                          (size_t )1);
#line 168
        *(m___0->xxt + (i___3 * (m___0->xxh)->chn + j___0)) = (struct xxm_track *)tmp___19;
#line 168
        (*(m___0->xxt + (i___3 * (m___0->xxh)->chn + j___0)))->rows = (*(m___0->xxp + i___3))->rows;
#line 168
        j___0 ++;
        }
      }
      while_break___8: /* CIL Label */ ;
      }
#line 168
      goto while_break___7;
    }
    while_break___7: /* CIL Label */ ;
    }
#line 170
    (*(m___0->xxt + (*(m___0->xxp + i___3))->info[0].index))->event[0].f2t = (uint8 )126;
#line 171
    (*(m___0->xxt + (*(m___0->xxp + i___3))->info[0].index))->event[0].f2p = sfh.tempo[i___3];
#line 172
    (*(m___0->xxt + (*(m___0->xxp + i___3))->info[1].index))->event[sfh.pbrk[i___3]].f2t = (uint8 )13;
#line 173
    (*(m___0->xxt + (*(m___0->xxp + i___3))->info[1].index))->event[sfh.pbrk[i___3]].f2p = (uint8 )0;
#line 175
    j = 0;
    {
#line 175
    while (1) {
      while_continue___9: /* CIL Label */ ;
#line 175
      if (! (j < 512)) {
#line 175
        goto while_break___9;
      }
      {
#line 176
      event = & (*(m___0->xxt + (*(m___0->xxp + i___3))->info[j % 8].index))->event[j / 8];
#line 177
      fread((void */* __restrict  */)(& ev), (size_t )1, (size_t )3, (FILE */* __restrict  */)f);
      }
#line 179
      if (((int )ev[0] & 254) != 254) {
#line 180
        event->note = (uint8 )(25 + ((int )ev[0] >> 2));
#line 181
        event->ins = (uint8 )((1 + (((int )ev[1] & 240) >> 4)) + (((int )ev[0] & 3) << 4));
      }
#line 184
      if ((int )ev[0] != 255) {
#line 185
        event->vol = (uint8 )((((int )ev[1] & 15) << 2) + 1);
      }
#line 187
      if ((int )ev[2] != 255) {
#line 188
        if (((int )ev[2] & 240) >> 4 > 5) {
#line 189
          goto __Cont;
        }
#line 195
        if ((((int )ev[2] < 5) & 240) >> 4) {
#line 195
          if (! event->ins) {
#line 196
            goto __Cont;
          }
        }
#line 198
        event->fxt = fx___6[((int )ev[2] & 240) >> 4];
        {
#line 203
        if ((int )event->fxt == 122) {
#line 203
          goto case_122;
        }
#line 203
        if ((int )event->fxt == 120) {
#line 203
          goto case_122;
        }
#line 203
        if ((int )event->fxt == 121) {
#line 203
          goto case_122;
        }
#line 206
        if ((int )event->fxt == 123) {
#line 206
          goto case_123;
        }
#line 209
        if ((int )event->fxt == 166) {
#line 209
          goto case_166;
        }
#line 212
        if ((int )event->fxt == 126) {
#line 212
          goto case_126;
        }
#line 200
        goto switch_break;
        case_122: /* CIL Label */ 
        case_120: /* CIL Label */ 
        case_121: /* CIL Label */ 
#line 204
        event->fxp = (uint8 )((int )ev[2] & 15);
#line 205
        goto switch_break;
        case_123: /* CIL Label */ 
#line 207
        event->fxp = (uint8 )1;
#line 208
        goto switch_break;
        case_166: /* CIL Label */ 
#line 210
        event->fxp = (uint8 )(128 + (((int )ev[2] & 15) << 4));
#line 211
        goto switch_break;
        case_126: /* CIL Label */ 
#line 213
        event->fxp = (uint8 )((int )ev[2] & 15);
#line 214
        event->f2t = (uint8 )127;
#line 215
        goto switch_break;
        switch_break: /* CIL Label */ ;
        }
      }
      __Cont: /* CIL Label */ 
#line 175
      j ++;
    }
    while_break___9: /* CIL Label */ ;
    }
    {
#line 219
    reportv(ctx___0, 0, (char *)".");
#line 165
    i___3 ++;
    }
  }
  while_break___5: /* CIL Label */ ;
  }
  {
#line 223
  reportv(ctx___0, 0, (char *)"\nStored samples : %d ", (m___0->xxh)->smp);
#line 225
  i___3 = 0;
  }
  {
#line 225
  while (1) {
    while_continue___10: /* CIL Label */ ;
#line 225
    if (! (i___3 < (m___0->xxh)->ins)) {
#line 225
      goto while_break___10;
    }
#line 226
    if ((m___0->xxs + i___3)->len <= 2) {
#line 227
      goto __Cont___0;
    }
    {
#line 228
    xmp_drv_loadpatch(ctx___0, f, (*(m___0->xxi + i___3) + 0)->sid, m___0->c4rate,
                      2, m___0->xxs + i___3, (char *)((void *)0));
#line 230
    reportv(ctx___0, 0, (char *)".");
    }
    __Cont___0: /* CIL Label */ 
#line 225
    i___3 ++;
  }
  while_break___10: /* CIL Label */ ;
  }
  {
#line 232
  reportv(ctx___0, 0, (char *)"\n");
#line 234
  i___3 = 0;
  }
  {
#line 234
  while (1) {
    while_continue___11: /* CIL Label */ ;
#line 234
    if (! (i___3 < (m___0->xxh)->chn)) {
#line 234
      goto while_break___11;
    }
#line 235
    m___0->xxc[i___3].pan = (i___3 % 2) * 255;
#line 234
    i___3 ++;
  }
  while_break___11: /* CIL Label */ ;
  }
#line 237
  m___0->quirk |= 1 << 16;
#line 239
  return (0);
}
}
#line 18 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/stm_load.c"
static int stm_test(FILE *f , char *t , int const   start ) ;
#line 19
static int stm_load(struct xmp_context *ctx___0 , FILE *f , int const   start ) ;
#line 21 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/stm_load.c"
struct xmp_loader_info stm_loader  =    {(char *)"STM", (char *)"Scream Tracker 2", & stm_test, & stm_load, 0, {(struct list_head *)0,
                                                                           (struct list_head *)0}};
#line 28 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/stm_load.c"
static int stm_test(FILE *f , char *t , int const   start ) 
{ 
  char buf___1[8] ;
  int tmp ;
  int tmp___0 ;
  uint8 tmp___1 ;
  uint8 tmp___2 ;
  void *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
  {
#line 32
  fseek(f, (long )(start + 20), 0);
#line 33
  fread((void */* __restrict  */)(buf___1), (size_t )8, (size_t )1, (FILE */* __restrict  */)f);
#line 34
  tmp = memcmp((void const   *)(buf___1), (void const   *)"!Scream!", (size_t )8);
  }
#line 34
  if (tmp) {
    {
#line 34
    tmp___0 = memcmp((void const   *)(buf___1), (void const   *)"BMOD2STM", (size_t )8);
    }
#line 34
    if (tmp___0) {
#line 35
      return (-1);
    }
  }
  {
#line 37
  read8(f);
#line 39
  tmp___1 = read8(f);
  }
#line 39
  if ((int )tmp___1 != 2) {
#line 40
    return (-1);
  }
  {
#line 42
  tmp___2 = read8(f);
  }
#line 42
  if ((int )tmp___2 < 1) {
#line 43
    return (-1);
  }
  {
#line 45
  fseek(f, (long )start, 0);
#line 46
  read_title(f, t, 20);
  }
#line 48
  return (0);
}
}
#line 65 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/stm_load.c"
static uint8 fx___7[11]  = 
#line 65
  {      (uint8 )255,      (uint8 )15,      (uint8 )11,      (uint8 )13, 
        (uint8 )10,      (uint8 )2,      (uint8 )1,      (uint8 )3, 
        (uint8 )4,      (uint8 )29,      (uint8 )0};
#line 75 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/stm_load.c"
static int stm_load(struct xmp_context *ctx___0 , FILE *f , int const   start ) 
{ 
  struct xmp_player_context *p ;
  struct xmp_mod_context *m___0 ;
  int i___3 ;
  int j ;
  struct xxm_event *event ;
  struct stm_file_header sfh ;
  uint8 b___1 ;
  int bmod2stm ;
  uint8 **tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  size_t tmp___12 ;
  void *tmp___13 ;
  void *tmp___14 ;
  void *tmp___15 ;
  int j___0 ;
  void *tmp___16 ;
  uint8 tmp___17 ;
  void *__cil_tmp32 ;
  void *__cil_tmp33 ;
  void *__cil_tmp34 ;
  void *__cil_tmp35 ;
  void *__cil_tmp36 ;
  int __cil_tmp37 ;
  void *__cil_tmp38 ;
  void *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;

  {
#line 77
  p = & ctx___0->p;
#line 78
  m___0 = & p->m;
#line 83
  bmod2stm = 0;
  {
#line 85
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 85
    fseek(f, (long )start, 0);
#line 85
    tmp = (uint8 **)((void *)0);
#line 85
    m___0->med_wav_table = tmp;
#line 85
    m___0->med_vol_table = tmp;
#line 85
    set_xxh_defaults(m___0->xxh);
    }
#line 85
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 87
  fread((void */* __restrict  */)(& sfh.name), (size_t )20, (size_t )1, (FILE */* __restrict  */)f);
#line 88
  fread((void */* __restrict  */)(& sfh.magic), (size_t )8, (size_t )1, (FILE */* __restrict  */)f);
#line 89
  sfh.rsvd1 = read8(f);
#line 90
  sfh.type = read8(f);
#line 91
  sfh.vermaj = read8(f);
#line 92
  sfh.vermin = read8(f);
#line 93
  sfh.tempo = read8(f);
#line 94
  sfh.patterns = read8(f);
#line 95
  sfh.gvol = read8(f);
#line 96
  fread((void */* __restrict  */)(& sfh.rsvd2), (size_t )13, (size_t )1, (FILE */* __restrict  */)f);
#line 98
  i___3 = 0;
  }
  {
#line 98
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 98
    if (! (i___3 < 31)) {
#line 98
      goto while_break___0;
    }
    {
#line 99
    fread((void */* __restrict  */)(& sfh.ins[i___3].name), (size_t )12, (size_t )1,
          (FILE */* __restrict  */)f);
#line 100
    sfh.ins[i___3].id = read8(f);
#line 101
    sfh.ins[i___3].idisk = read8(f);
#line 102
    sfh.ins[i___3].rsvd1 = read16l(f);
#line 103
    sfh.ins[i___3].length = read16l(f);
#line 104
    sfh.ins[i___3].loopbeg = read16l(f);
#line 105
    sfh.ins[i___3].loopend = read16l(f);
#line 106
    sfh.ins[i___3].volume = read8(f);
#line 107
    sfh.ins[i___3].rsvd2 = read8(f);
#line 108
    sfh.ins[i___3].c2spd = read16l(f);
#line 109
    sfh.ins[i___3].rsvd3 = read32l(f);
#line 110
    sfh.ins[i___3].paralen = read16l(f);
#line 98
    i___3 ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 113
  tmp___0 = strncmp((char const   *)((char *)(sfh.magic)), "BMOD2STM", (size_t )8);
  }
#line 113
  if (! tmp___0) {
#line 114
    bmod2stm = 1;
  }
  {
#line 116
  (m___0->xxh)->pat = (int )sfh.patterns;
#line 117
  (m___0->xxh)->trk = (m___0->xxh)->pat * (m___0->xxh)->chn;
#line 118
  (m___0->xxh)->tpo = ((int )sfh.tempo & 240) >> 4;
#line 119
  (m___0->xxh)->ins = 31;
#line 120
  (m___0->xxh)->smp = (m___0->xxh)->ins;
#line 121
  m___0->c4rate = 8363;
#line 123
  copy_adjust((uint8 *)(m___0->name), sfh.name, 20);
  }
#line 125
  if (bmod2stm) {
    {
#line 126
    snprintf((char */* __restrict  */)(m___0->type), (size_t )64, (char const   */* __restrict  */)"!Scream! (BMOD2STM)");
    }
  } else {
    {
#line 128
    snprintf((char */* __restrict  */)(m___0->type), (size_t )64, (char const   */* __restrict  */)"!Scream! (Scream Tracker %d.%02d)",
             (int )sfh.vermaj, (int )sfh.vermin);
    }
  }
  {
#line 132
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 132
    if (m___0->verbosity) {
#line 132
      if (m___0->name[0]) {
        {
#line 132
        report((char *)"Module title   : %s\n", m___0->name);
        }
      }
#line 132
      if (m___0->type[0]) {
        {
#line 132
        report((char *)"Module type    : %s\n", m___0->type);
        }
      }
#line 132
      if (m___0->author[0]) {
        {
#line 132
        report((char *)"Author name    : %s\n", m___0->author);
        }
      }
#line 132
      if ((m___0->xxh)->len) {
        {
#line 132
        report((char *)"Module length  : %d patterns\n", (m___0->xxh)->len);
        }
      }
    }
#line 132
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 134
  while (1) {
    while_continue___2: /* CIL Label */ ;
    {
#line 134
    tmp___1 = calloc((size_t )sizeof(struct xxm_instrument_header ), (size_t )(m___0->xxh)->ins);
#line 134
    m___0->xxih = (struct xxm_instrument_header *)tmp___1;
#line 134
    tmp___2 = calloc((size_t )sizeof(struct xxm_instrument_map ), (size_t )(m___0->xxh)->ins);
#line 134
    m___0->xxim = (struct xxm_instrument_map *)tmp___2;
#line 134
    tmp___3 = calloc((size_t )sizeof(struct xxm_instrument *), (size_t )(m___0->xxh)->ins);
#line 134
    m___0->xxi = (struct xxm_instrument **)tmp___3;
    }
#line 134
    if ((m___0->xxh)->smp) {
      {
#line 134
      tmp___4 = calloc((size_t )sizeof(struct xxm_sample ), (size_t )(m___0->xxh)->smp);
#line 134
      m___0->xxs = (struct xxm_sample *)tmp___4;
      }
    }
    {
#line 134
    tmp___5 = calloc((size_t )sizeof(uint16 *), (size_t )(m___0->xxh)->ins);
#line 134
    m___0->xxae = (uint16 **)tmp___5;
#line 134
    tmp___6 = calloc((size_t )sizeof(uint16 *), (size_t )(m___0->xxh)->ins);
#line 134
    m___0->xxpe = (uint16 **)tmp___6;
#line 134
    tmp___7 = calloc((size_t )sizeof(uint16 *), (size_t )(m___0->xxh)->ins);
#line 134
    m___0->xxfe = (uint16 **)tmp___7;
    }
#line 134
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 136
  reportv(ctx___0, 1, (char *)"     Sample name    Len  LBeg LEnd L Vol C2Spd\n");
#line 139
  i___3 = 0;
  }
  {
#line 139
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 139
    if (! (i___3 < (m___0->xxh)->ins)) {
#line 139
      goto while_break___3;
    }
    {
#line 140
    tmp___8 = calloc((size_t )sizeof(struct xxm_instrument ), (size_t )1);
#line 140
    *(m___0->xxi + i___3) = (struct xxm_instrument *)tmp___8;
#line 141
    tmp___9 = (int )sfh.ins[i___3].length;
#line 141
    (m___0->xxs + i___3)->len = tmp___9;
    }
#line 141
    if (tmp___9) {
#line 141
      tmp___10 = 1;
    } else {
#line 141
      tmp___10 = 0;
    }
#line 141
    (m___0->xxih + i___3)->nsm = tmp___10;
#line 142
    (m___0->xxs + i___3)->lps = (int )sfh.ins[i___3].loopbeg;
#line 143
    (m___0->xxs + i___3)->lpe = (int )sfh.ins[i___3].loopend;
#line 144
    if ((m___0->xxs + i___3)->lpe == 65535) {
#line 145
      (m___0->xxs + i___3)->lpe = 0;
    }
#line 146
    if ((m___0->xxs + i___3)->lpe > 0) {
#line 146
      (m___0->xxs + i___3)->flg = 4;
    } else {
#line 146
      (m___0->xxs + i___3)->flg = 0;
    }
    {
#line 147
    (*(m___0->xxi + i___3) + 0)->vol = (int )sfh.ins[i___3].volume;
#line 148
    (*(m___0->xxi + i___3) + 0)->pan = 128;
#line 149
    (*(m___0->xxi + i___3) + 0)->sid = i___3;
#line 151
    copy_adjust((m___0->xxih + i___3)->name, sfh.ins[i___3].name, 12);
    }
#line 153
    if (m___0->verbosity > 1) {
      {
#line 153
      tmp___12 = strlen((char const   *)((char *)((m___0->xxih + i___3)->name)));
      }
#line 153
      if (tmp___12) {
#line 153
        goto _L;
      } else
#line 153
      if ((m___0->xxs + i___3)->len > 1) {
        _L: /* CIL Label */ 
#line 154
        if ((m___0->xxs + i___3)->flg & 4) {
#line 154
          tmp___11 = 'L';
        } else {
#line 154
          tmp___11 = ' ';
        }
        {
#line 154
        report((char *)"[%2X] %-14.14s %04x %04x %04x %c V%02x %5d\n", i___3, (m___0->xxih + i___3)->name,
               (m___0->xxs + i___3)->len, (m___0->xxs + i___3)->lps, (m___0->xxs + i___3)->lpe,
               tmp___11, (*(m___0->xxi + i___3) + 0)->vol, (int )sfh.ins[i___3].c2spd);
        }
      }
    }
    {
#line 159
    sfh.ins[i___3].c2spd = (uint16 )((8363 * (int )sfh.ins[i___3].c2spd) / 8448);
#line 160
    c2spd_to_note((int )sfh.ins[i___3].c2spd, & (*(m___0->xxi + i___3) + 0)->xpo,
                  & (*(m___0->xxi + i___3) + 0)->fin);
#line 139
    i___3 ++;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 163
  fread((void */* __restrict  */)(m___0->xxo), (size_t )1, (size_t )128, (FILE */* __restrict  */)f);
#line 165
  i___3 = 0;
  }
  {
#line 165
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 165
    if (! (i___3 < 128)) {
#line 165
      goto while_break___4;
    }
#line 166
    if ((int )m___0->xxo[i___3] >= (m___0->xxh)->pat) {
#line 167
      goto while_break___4;
    }
#line 165
    i___3 ++;
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 169
  (m___0->xxh)->len = i___3;
#line 171
  reportv(ctx___0, 0, (char *)"Module length  : %d patterns\n", (m___0->xxh)->len);
  }
  {
#line 173
  while (1) {
    while_continue___5: /* CIL Label */ ;
    {
#line 173
    tmp___13 = calloc((size_t )sizeof(struct xxm_track *), (size_t )(m___0->xxh)->trk);
#line 173
    m___0->xxt = (struct xxm_track **)tmp___13;
#line 173
    tmp___14 = calloc((size_t )sizeof(struct xxm_pattern *), (size_t )((m___0->xxh)->pat + 1));
#line 173
    m___0->xxp = (struct xxm_pattern **)tmp___14;
    }
#line 173
    goto while_break___5;
  }
  while_break___5: /* CIL Label */ ;
  }
  {
#line 176
  reportv(ctx___0, 0, (char *)"Stored patterns: %d ", (m___0->xxh)->pat);
#line 178
  i___3 = 0;
  }
  {
#line 178
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 178
    if (! (i___3 < (m___0->xxh)->pat)) {
#line 178
      goto while_break___6;
    }
    {
#line 179
    while (1) {
      while_continue___7: /* CIL Label */ ;
      {
#line 179
      tmp___15 = calloc((size_t )1, (size_t )(sizeof(struct xxm_pattern ) + sizeof(struct xxm_trackinfo ) * (unsigned long )((m___0->xxh)->chn - 1)));
#line 179
      *(m___0->xxp + i___3) = (struct xxm_pattern *)tmp___15;
      }
#line 179
      goto while_break___7;
    }
    while_break___7: /* CIL Label */ ;
    }
#line 180
    (*(m___0->xxp + i___3))->rows = 64;
    {
#line 181
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 181
      j___0 = 0;
      {
#line 181
      while (1) {
        while_continue___9: /* CIL Label */ ;
#line 181
        if (! (j___0 < (m___0->xxh)->chn)) {
#line 181
          goto while_break___9;
        }
        {
#line 181
        (*(m___0->xxp + i___3))->info[j___0].index = i___3 * (m___0->xxh)->chn + j___0;
#line 181
        tmp___16 = calloc((size_t )(sizeof(struct xxm_track ) + sizeof(struct xxm_event ) * (unsigned long )(*(m___0->xxp + i___3))->rows),
                          (size_t )1);
#line 181
        *(m___0->xxt + (i___3 * (m___0->xxh)->chn + j___0)) = (struct xxm_track *)tmp___16;
#line 181
        (*(m___0->xxt + (i___3 * (m___0->xxh)->chn + j___0)))->rows = (*(m___0->xxp + i___3))->rows;
#line 181
        j___0 ++;
        }
      }
      while_break___9: /* CIL Label */ ;
      }
#line 181
      goto while_break___8;
    }
    while_break___8: /* CIL Label */ ;
    }
#line 182
    j = 0;
    {
#line 182
    while (1) {
      while_continue___10: /* CIL Label */ ;
#line 182
      if (! (j < 64 * (m___0->xxh)->chn)) {
#line 182
        goto while_break___10;
      }
      {
#line 183
      event = & (*(m___0->xxt + (*(m___0->xxp + i___3))->info[j % (m___0->xxh)->chn].index))->event[j / (m___0->xxh)->chn];
#line 184
      b___1 = read8(f);
#line 185
      memset((void *)event, 0, (size_t )sizeof(struct xxm_event ));
      }
      {
#line 189
      if ((int )b___1 == 253) {
#line 189
        goto case_253;
      }
#line 189
      if ((int )b___1 == 252) {
#line 189
        goto case_253;
      }
#line 189
      if ((int )b___1 == 251) {
#line 189
        goto case_253;
      }
#line 191
      if ((int )b___1 == 255) {
#line 191
        goto case_255;
      }
#line 193
      goto switch_default;
      case_253: /* CIL Label */ 
      case_252: /* CIL Label */ 
      case_251: /* CIL Label */ 
#line 190
      goto switch_break;
      case_255: /* CIL Label */ 
#line 192
      b___1 = (uint8 )0;
      switch_default: /* CIL Label */ 
#line 194
      if (b___1) {
#line 194
        event->note = (uint8 )((1 + ((int )b___1 & 15)) + 12 * (2 + (((int )b___1 & 240) >> 4)));
      } else {
#line 194
        event->note = (uint8 )0;
      }
      {
#line 195
      b___1 = read8(f);
#line 196
      event->vol = (uint8 )((int )b___1 & 7);
#line 197
      event->ins = (uint8 )(((int )b___1 & 248) >> 3);
#line 198
      b___1 = read8(f);
#line 199
      event->vol = (uint8 )((int )event->vol + (((int )b___1 & 240) >> 1));
      }
#line 200
      if ((int )event->vol > 64) {
#line 201
        event->vol = (uint8 )0;
      } else {
#line 203
        event->vol = (uint8 )((int )event->vol + 1);
      }
      {
#line 204
      event->fxt = fx___7[(int )b___1 & 15];
#line 205
      event->fxp = read8(f);
      }
      {
#line 207
      if ((int )event->fxt == 15) {
#line 207
        goto case_15;
      }
#line 210
      if ((int )event->fxt == 255) {
#line 210
        goto case_255___0;
      }
#line 206
      goto switch_break___0;
      case_15: /* CIL Label */ 
#line 208
      event->fxp = (uint8 )(((int )event->fxp & 240) >> 4);
#line 209
      goto switch_break___0;
      case_255___0: /* CIL Label */ 
#line 211
      tmp___17 = (uint8 )0;
#line 211
      event->fxt = tmp___17;
#line 211
      event->fxp = tmp___17;
#line 212
      goto switch_break___0;
      switch_break___0: /* CIL Label */ ;
      }
      switch_break: /* CIL Label */ ;
      }
#line 182
      j ++;
    }
    while_break___10: /* CIL Label */ ;
    }
    {
#line 216
    reportv(ctx___0, 0, (char *)".");
#line 178
    i___3 ++;
    }
  }
  while_break___6: /* CIL Label */ ;
  }
  {
#line 220
  reportv(ctx___0, 0, (char *)"\nStored samples : %d ", (m___0->xxh)->smp);
#line 222
  i___3 = 0;
  }
  {
#line 222
  while (1) {
    while_continue___11: /* CIL Label */ ;
#line 222
    if (! (i___3 < (m___0->xxh)->ins)) {
#line 222
      goto while_break___11;
    }
    {
#line 223
    xmp_drv_loadpatch(ctx___0, f, (*(m___0->xxi + i___3) + 0)->sid, m___0->c4rate,
                      0, m___0->xxs + (*(m___0->xxi + i___3) + 0)->sid, (char *)((void *)0));
#line 225
    reportv(ctx___0, 0, (char *)".");
#line 222
    i___3 ++;
    }
  }
  while_break___11: /* CIL Label */ ;
  }
  {
#line 227
  reportv(ctx___0, 0, (char *)"\n");
#line 229
  m___0->quirk |= (1 << 13) | (((((1 << 5) | (1 << 4)) | (1 << 1)) | (1 << 14)) | (1 << 17));
  }
#line 231
  return (0);
}
}
#line 72 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/s3m_load.c"
static int s3m_test(FILE *f , char *t , int const   start ) ;
#line 73
static int s3m_load(struct xmp_context *ctx___0 , FILE *f , int const   start ) ;
#line 75 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/s3m_load.c"
struct xmp_loader_info s3m_loader  =    {(char *)"S3M", (char *)"Scream Tracker 3", & s3m_test, & s3m_load, 0, {(struct list_head *)0,
                                                                           (struct list_head *)0}};
#line 82 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/s3m_load.c"
static int s3m_test(FILE *f , char *t , int const   start ) 
{ 
  uint32 tmp ;

  {
  {
#line 84
  fseek(f, (long )(start + 44), 0);
#line 85
  tmp = read32b(f);
  }
#line 85
  if (tmp != ((((83U << 24) | (67U << 16)) | (82U << 8)) | 77U)) {
#line 86
    return (-1);
  }
  {
#line 88
  fseek(f, (long )start, 0);
#line 89
  read_title(f, t, 28);
  }
#line 91
  return (0);
}
}
#line 104 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/s3m_load.c"
static uint16 *pp_ins___1  ;
#line 105 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/s3m_load.c"
static uint16 *pp_pat___1  ;
#line 106 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/s3m_load.c"
static uint8 arpeggio_val___1[32]  ;
#line 109 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/s3m_load.c"
static uint8 fx___8[27]  = 
#line 109
  {      (uint8 )255,      (uint8 )163,      (uint8 )11,      (uint8 )13, 
        (uint8 )10,      (uint8 )2,      (uint8 )1,      (uint8 )3, 
        (uint8 )4,      (uint8 )29,      (uint8 )0,      (uint8 )6, 
        (uint8 )5,      (uint8 )255,      (uint8 )255,      (uint8 )9, 
        (uint8 )255,      (uint8 )27,      (uint8 )7,      (uint8 )254, 
        (uint8 )171,      (uint8 )172,      (uint8 )16,      (uint8 )255, 
        (uint8 )255,      (uint8 )255,      (uint8 )255};
#line 142 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/s3m_load.c"
static void xlat_fx___4(int c___0 , struct xxm_event *e ) 
{ 
  uint8 h ;
  uint8 l ;
  uint8 tmp ;
  uint8 tmp___0 ;
  uint8 tmp___1 ;
  uint8 tmp___2 ;

  {
#line 144
  h = (uint8 )(((int )e->fxp & 240) >> 4);
#line 144
  l = (uint8 )((int )e->fxp & 15);
#line 146
  tmp = fx___8[e->fxt];
#line 146
  e->fxt = tmp;
  {
#line 147
  if ((int )tmp == 0) {
#line 147
    goto case_0;
  }
#line 153
  if ((int )tmp == 11) {
#line 153
    goto case_11;
  }
#line 156
  if ((int )tmp == 254) {
#line 156
    goto case_254;
  }
#line 190
  if ((int )tmp == 255) {
#line 190
    goto case_255;
  }
#line 146
  goto switch_break;
  case_0: /* CIL Label */ 
#line 148
  if (e->fxp) {
#line 149
    arpeggio_val___1[c___0] = e->fxp;
  } else {
#line 151
    e->fxp = arpeggio_val___1[c___0];
  }
#line 152
  goto switch_break;
  case_11: /* CIL Label */ 
#line 154
  e->fxp = ord_xlat[e->fxp];
#line 155
  goto switch_break;
  case_254: /* CIL Label */ 
#line 157
  e->fxt = (uint8 )14;
  {
#line 159
  if ((int )h == 1) {
#line 159
    goto case_1;
  }
#line 162
  if ((int )h == 2) {
#line 162
    goto case_2;
  }
#line 165
  if ((int )h == 3) {
#line 165
    goto case_3;
  }
#line 168
  if ((int )h == 4) {
#line 168
    goto case_4;
  }
#line 175
  if ((int )h == 10) {
#line 175
    goto case_10;
  }
#line 175
  if ((int )h == 9) {
#line 175
    goto case_10;
  }
#line 175
  if ((int )h == 7) {
#line 175
    goto case_10;
  }
#line 175
  if ((int )h == 6) {
#line 175
    goto case_10;
  }
#line 175
  if ((int )h == 5) {
#line 175
    goto case_10;
  }
#line 178
  if ((int )h == 8) {
#line 178
    goto case_8;
  }
#line 182
  if ((int )h == 11) {
#line 182
    goto case_11___0;
  }
#line 185
  if ((int )h == 12) {
#line 185
    goto case_12;
  }
#line 158
  goto switch_break___0;
  case_1: /* CIL Label */ 
#line 160
  e->fxp = (uint8 )(((int )e->fxp & 15) | (3 << 4));
#line 161
  goto switch_break___0;
  case_2: /* CIL Label */ 
#line 163
  e->fxp = (uint8 )(((int )e->fxp & 15) | (5 << 4));
#line 164
  goto switch_break___0;
  case_3: /* CIL Label */ 
#line 166
  e->fxp = (uint8 )(((int )e->fxp & 15) | (4 << 4));
#line 167
  goto switch_break___0;
  case_4: /* CIL Label */ 
#line 169
  e->fxp = (uint8 )(((int )e->fxp & 15) | (7 << 4));
#line 170
  goto switch_break___0;
  case_10: /* CIL Label */ 
  case_9: /* CIL Label */ 
  case_7: /* CIL Label */ 
  case_6: /* CIL Label */ 
  case_5: /* CIL Label */ 
#line 176
  tmp___0 = (uint8 )0;
#line 176
  e->fxp = tmp___0;
#line 176
  e->fxt = tmp___0;
#line 177
  goto switch_break___0;
  case_8: /* CIL Label */ 
#line 179
  e->fxt = (uint8 )22;
#line 180
  e->fxp = (uint8 )((int )l << 4);
#line 181
  goto switch_break___0;
  case_11___0: /* CIL Label */ 
#line 183
  e->fxp = (uint8 )(((int )e->fxp & 15) | (6 << 4));
#line 184
  goto switch_break___0;
  case_12: /* CIL Label */ 
#line 186
  if (! l) {
#line 187
    tmp___1 = (uint8 )0;
#line 187
    e->fxp = tmp___1;
#line 187
    e->fxt = tmp___1;
  }
  switch_break___0: /* CIL Label */ ;
  }
#line 189
  goto switch_break;
  case_255: /* CIL Label */ 
#line 191
  tmp___2 = (uint8 )0;
#line 191
  e->fxp = tmp___2;
#line 191
  e->fxt = tmp___2;
#line 192
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 194
  return;
}
}
#line 197 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/s3m_load.c"
static int s3m_load(struct xmp_context *ctx___0 , FILE *f , int const   start ) 
{ 
  struct xmp_player_context *p ;
  struct xmp_mod_context *m___0 ;
  int c___0 ;
  int r ;
  int i___3 ;
  int j ;
  struct s3m_adlib_header sah ;
  struct xxm_event *event ;
  struct xxm_event dummy___3 ;
  struct s3m_file_header sfh ;
  struct s3m_instrument_header sih ;
  int pat_len ;
  uint8 n___0 ;
  uint8 b___1 ;
  uint8 x8 ;
  char tracker_name[80] ;
  int quirk87 ;
  uint8 **tmp ;
  int i___4 ;
  int i___5 ;
  int i___6 ;
  void *tmp___0 ;
  void *tmp___1 ;
  int x ;
  uint8 x___0 ;
  uint8 tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  int j___0 ;
  void *tmp___6 ;
  uint16 tmp___7 ;
  uint8 tmp___8 ;
  char const   *tmp___9 ;
  char const   *tmp___10 ;
  void *tmp___11 ;
  void *tmp___12 ;
  void *tmp___13 ;
  void *tmp___14 ;
  void *tmp___15 ;
  void *tmp___16 ;
  void *tmp___17 ;
  void *tmp___18 ;
  int i___7 ;
  int i___8 ;
  int i___9 ;
  int i___10 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  size_t tmp___24 ;
  void *__cil_tmp57 ;
  void *__cil_tmp58 ;
  void *__cil_tmp59 ;
  void *__cil_tmp60 ;
  void *__cil_tmp61 ;
  void *__cil_tmp62 ;
  void *__cil_tmp63 ;
  void *__cil_tmp64 ;
  void *__cil_tmp65 ;
  void *__cil_tmp66 ;
  void *__cil_tmp67 ;
  void *__cil_tmp68 ;
  void *__cil_tmp69 ;
  void *__cil_tmp70 ;
  void *__cil_tmp71 ;
  void *__cil_tmp72 ;
  void *__cil_tmp73 ;
  void *__cil_tmp74 ;
  char *__cil_tmp75 ;
  char *__cil_tmp76 ;
  char *__cil_tmp77 ;
  char *__cil_tmp78 ;
  char *__cil_tmp79 ;
  char *__cil_tmp80 ;
  char *__cil_tmp81 ;
  char *__cil_tmp82 ;
  char *__cil_tmp83 ;
  char *__cil_tmp84 ;
  char *__cil_tmp85 ;
  char *__cil_tmp86 ;
  char *__cil_tmp87 ;
  char *__cil_tmp88 ;
  char *__cil_tmp89 ;
  char *__cil_tmp90 ;
  char *__cil_tmp91 ;
  char *__cil_tmp92 ;
  char *__cil_tmp93 ;
  char *__cil_tmp94 ;
  char *__cil_tmp95 ;
  char *__cil_tmp96 ;
  char *__cil_tmp97 ;
  char *__cil_tmp98 ;
  char *__cil_tmp99 ;
  char *__cil_tmp100 ;
  char *__cil_tmp101 ;
  char *__cil_tmp102 ;
  char *__cil_tmp103 ;

  {
#line 199
  p = & ctx___0->p;
#line 200
  m___0 = & p->m;
#line 203
  event = (struct xxm_event *)0;
#line 209
  quirk87 = 0;
  {
#line 211
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 211
    fseek(f, (long )start, 0);
#line 211
    tmp = (uint8 **)((void *)0);
#line 211
    m___0->med_wav_table = tmp;
#line 211
    m___0->med_vol_table = tmp;
#line 211
    set_xxh_defaults(m___0->xxh);
    }
#line 211
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 213
  fread((void */* __restrict  */)(& sfh.name), (size_t )28, (size_t )1, (FILE */* __restrict  */)f);
#line 214
  read8(f);
#line 215
  sfh.type = read8(f);
#line 216
  read16l(f);
#line 217
  sfh.ordnum = read16l(f);
#line 218
  sfh.insnum = read16l(f);
#line 219
  sfh.patnum = read16l(f);
#line 220
  sfh.flags = read16l(f);
#line 221
  sfh.version = read16l(f);
#line 222
  sfh.ffi = read16l(f);
#line 223
  sfh.magic = read32b(f);
#line 224
  sfh.gv = read8(f);
#line 225
  sfh.is = read8(f);
#line 226
  sfh.it = read8(f);
#line 227
  sfh.mv = read8(f);
#line 228
  sfh.uc = read8(f);
#line 229
  sfh.dp = read8(f);
#line 230
  read32l(f);
#line 231
  read32l(f);
#line 232
  sfh.special = read16l(f);
#line 233
  fread((void */* __restrict  */)(sfh.chset), (size_t )32, (size_t )1, (FILE */* __restrict  */)f);
  }
#line 241
  if ((int )sfh.version == 4865) {
#line 241
    if ((int )sfh.name[27] == 135) {
#line 242
      quirk87 = 1;
    }
  }
#line 244
  if (quirk87) {
    {
#line 245
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 245
      i___4 = 0;
      {
#line 245
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 245
        if (! ((unsigned long )i___4 < sizeof(sfh.name))) {
#line 245
          goto while_break___1;
        }
#line 245
        if ((int )*((uint8 *)(& sfh.name) + i___4) == 135) {
#line 245
          *((uint8 *)(& sfh.name) + i___4) = (uint8 )0;
        }
#line 245
        i___4 ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 245
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 246
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 246
      i___5 = 0;
      {
#line 246
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 246
        if (! ((unsigned long )i___5 < sizeof(sfh.patnum))) {
#line 246
          goto while_break___3;
        }
#line 246
        if ((int )*((uint8 *)(& sfh.patnum) + i___5) == 135) {
#line 246
          *((uint8 *)(& sfh.patnum) + i___5) = (uint8 )0;
        }
#line 246
        i___5 ++;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 246
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 247
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 247
      i___6 = 0;
      {
#line 247
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 247
        if (! ((unsigned long )i___6 < sizeof(sfh.flags))) {
#line 247
          goto while_break___5;
        }
#line 247
        if ((int )*((uint8 *)(& sfh.flags) + i___6) == 135) {
#line 247
          *((uint8 *)(& sfh.flags) + i___6) = (uint8 )0;
        }
#line 247
        i___6 ++;
      }
      while_break___5: /* CIL Label */ ;
      }
#line 247
      goto while_break___4;
    }
    while_break___4: /* CIL Label */ ;
    }
  }
  {
#line 250
  copy_adjust((uint8 *)(m___0->name), sfh.name, 28);
#line 253
  (m___0->xxh)->len = (int )sfh.ordnum;
#line 254
  (m___0->xxh)->ins = (int )sfh.insnum;
#line 255
  (m___0->xxh)->smp = (m___0->xxh)->ins;
#line 256
  (m___0->xxh)->pat = (int )sfh.patnum;
#line 257
  tmp___0 = calloc((size_t )2, (size_t )(m___0->xxh)->ins);
#line 257
  pp_ins___1 = (uint16 *)tmp___0;
#line 258
  tmp___1 = calloc((size_t )2, (size_t )(m___0->xxh)->pat);
#line 258
  pp_pat___1 = (uint16 *)tmp___1;
  }
#line 259
  if ((int )sfh.flags & 16) {
#line 260
    (m___0->xxh)->flg |= 2;
  }
#line 261
  if ((int )sfh.flags & 64) {
#line 262
    m___0->quirk |= 1 << 13;
  }
#line 264
  (m___0->xxh)->tpo = (int )sfh.is;
#line 265
  (m___0->xxh)->bpm = (int )sfh.it;
#line 267
  i___3 = 0;
  {
#line 267
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 267
    if (! (i___3 < 32)) {
#line 267
      goto while_break___6;
    }
#line 268
    if ((int )sfh.chset[i___3] == 255) {
#line 269
      goto __Cont;
    }
#line 271
    (m___0->xxh)->chn = i___3 + 1;
#line 273
    if ((int )sfh.mv & 128) {
#line 274
      x = (int )sfh.chset[i___3] & 127;
#line 275
      if ((x & 15) < 8) {
#line 275
        m___0->xxc[i___3].pan = 0;
      } else {
#line 275
        m___0->xxc[i___3].pan = 255;
      }
    } else {
#line 277
      m___0->xxc[i___3].pan = 128;
    }
    __Cont: /* CIL Label */ 
#line 267
    i___3 ++;
  }
  while_break___6: /* CIL Label */ ;
  }
  {
#line 280
  (m___0->xxh)->trk = (m___0->xxh)->pat * (m___0->xxh)->chn;
#line 282
  fread((void */* __restrict  */)(m___0->xxo), (size_t )1, (size_t )(m___0->xxh)->len,
        (FILE */* __restrict  */)f);
#line 283
  clean_s3m_seq(m___0->xxh, m___0->xxo);
#line 285
  i___3 = 0;
  }
  {
#line 285
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 285
    if (! (i___3 < (m___0->xxh)->ins)) {
#line 285
      goto while_break___7;
    }
    {
#line 286
    *(pp_ins___1 + i___3) = read16l(f);
#line 285
    i___3 ++;
    }
  }
  while_break___7: /* CIL Label */ ;
  }
#line 288
  i___3 = 0;
  {
#line 288
  while (1) {
    while_continue___8: /* CIL Label */ ;
#line 288
    if (! (i___3 < (m___0->xxh)->pat)) {
#line 288
      goto while_break___8;
    }
    {
#line 289
    *(pp_pat___1 + i___3) = read16l(f);
#line 288
    i___3 ++;
    }
  }
  while_break___8: /* CIL Label */ ;
  }
#line 293
  i___3 = 0;
#line 293
  sfh.dp = (uint8 )((int )sfh.dp - 252);
  {
#line 293
  while (1) {
    while_continue___9: /* CIL Label */ ;
#line 293
    if (! sfh.dp) {
#line 293
      if (! (i___3 < 32)) {
#line 293
        goto while_break___9;
      }
    } else {
#line 293
      goto while_break___9;
    }
    {
#line 294
    tmp___2 = read8(f);
#line 294
    x___0 = tmp___2;
    }
#line 295
    if ((int )x___0 & 32) {
#line 296
      m___0->xxc[i___3].pan = ((int )x___0 << 4) & 255;
    } else
#line 298
    if ((int )sfh.mv % 128) {
#line 298
      m___0->xxc[i___3].pan = 48 + 160 * (i___3 & 1);
    } else {
#line 298
      m___0->xxc[i___3].pan = 128;
    }
#line 293
    i___3 ++;
  }
  while_break___9: /* CIL Label */ ;
  }
#line 301
  m___0->c4rate = 8363;
#line 302
  m___0->quirk |= 1 << 12;
#line 304
  if ((int )sfh.version == 4864) {
#line 305
    m___0->quirk |= 1 << 13;
  }
  {
#line 308
  if ((int )sfh.version >> 12 == 1) {
#line 308
    goto case_1;
  }
#line 313
  if ((int )sfh.version >> 12 == 2) {
#line 313
    goto case_2;
  }
#line 317
  if ((int )sfh.version >> 12 == 3) {
#line 317
    goto case_3;
  }
#line 327
  if ((int )sfh.version >> 12 == 4) {
#line 327
    goto case_4;
  }
#line 331
  if ((int )sfh.version >> 12 == 5) {
#line 331
    goto case_5;
  }
#line 335
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 309
  sprintf((char */* __restrict  */)(tracker_name), (char const   */* __restrict  */)"Scream Tracker %d.%02x",
          ((int )sfh.version & 3840) >> 8, (int )sfh.version & 255);
#line 311
  m___0->quirk |= 1 << 11;
  }
#line 312
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 314
  sprintf((char */* __restrict  */)(tracker_name), (char const   */* __restrict  */)"Imago Orpheus %d.%02x",
          ((int )sfh.version & 3840) >> 8, (int )sfh.version & 255);
  }
#line 316
  goto switch_break;
  case_3: /* CIL Label */ 
#line 318
  if ((int )sfh.version == 12822) {
    {
#line 319
    strcpy((char */* __restrict  */)(tracker_name), (char const   */* __restrict  */)"Impulse Tracker 2.14v3");
    }
  } else
#line 320
  if ((int )sfh.version == 12823) {
    {
#line 321
    strcpy((char */* __restrict  */)(tracker_name), (char const   */* __restrict  */)"Impulse Tracker 2.14v5");
    }
  } else {
    {
#line 323
    sprintf((char */* __restrict  */)(tracker_name), (char const   */* __restrict  */)"Impulse Tracker %d.%02x",
            ((int )sfh.version & 3840) >> 8, (int )sfh.version & 255);
    }
  }
#line 326
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 328
  sprintf((char */* __restrict  */)(tracker_name), (char const   */* __restrict  */)"Schism Tracker %d.%02x",
          ((int )sfh.version & 3840) >> 8, (int )sfh.version & 255);
  }
#line 330
  goto switch_break;
  case_5: /* CIL Label */ 
  {
#line 332
  sprintf((char */* __restrict  */)(tracker_name), (char const   */* __restrict  */)"OpenMPT %d.%02x",
          ((int )sfh.version & 3840) >> 8, (int )sfh.version & 255);
  }
#line 334
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 336
  snprintf((char */* __restrict  */)(tracker_name), (size_t )80, (char const   */* __restrict  */)"unknown (%04x)",
           (int )sfh.version);
  }
  switch_break: /* CIL Label */ ;
  }
  {
#line 339
  snprintf((char */* __restrict  */)(m___0->type), (size_t )64, (char const   */* __restrict  */)"SCRM (%s)",
           tracker_name);
  }
  {
#line 341
  while (1) {
    while_continue___10: /* CIL Label */ ;
#line 341
    if (m___0->verbosity) {
#line 341
      if (m___0->name[0]) {
        {
#line 341
        report((char *)"Module title   : %s\n", m___0->name);
        }
      }
#line 341
      if (m___0->type[0]) {
        {
#line 341
        report((char *)"Module type    : %s\n", m___0->type);
        }
      }
#line 341
      if (m___0->author[0]) {
        {
#line 341
        report((char *)"Author name    : %s\n", m___0->author);
        }
      }
#line 341
      if ((m___0->xxh)->len) {
        {
#line 341
        report((char *)"Module length  : %d patterns\n", (m___0->xxh)->len);
        }
      }
    }
#line 341
    goto while_break___10;
  }
  while_break___10: /* CIL Label */ ;
  }
  {
#line 343
  while (1) {
    while_continue___11: /* CIL Label */ ;
    {
#line 343
    tmp___3 = calloc((size_t )sizeof(struct xxm_track *), (size_t )(m___0->xxh)->trk);
#line 343
    m___0->xxt = (struct xxm_track **)tmp___3;
#line 343
    tmp___4 = calloc((size_t )sizeof(struct xxm_pattern *), (size_t )((m___0->xxh)->pat + 1));
#line 343
    m___0->xxp = (struct xxm_pattern **)tmp___4;
    }
#line 343
    goto while_break___11;
  }
  while_break___11: /* CIL Label */ ;
  }
  {
#line 347
  reportv(ctx___0, 0, (char *)"Stored patterns: %d ", (m___0->xxh)->pat);
#line 349
  memset((void *)(arpeggio_val___1), 0, (size_t )32);
#line 351
  i___3 = 0;
  }
  {
#line 351
  while (1) {
    while_continue___12: /* CIL Label */ ;
#line 351
    if (! (i___3 < (m___0->xxh)->pat)) {
#line 351
      goto while_break___12;
    }
    {
#line 352
    while (1) {
      while_continue___13: /* CIL Label */ ;
      {
#line 352
      tmp___5 = calloc((size_t )1, (size_t )(sizeof(struct xxm_pattern ) + sizeof(struct xxm_trackinfo ) * (unsigned long )((m___0->xxh)->chn - 1)));
#line 352
      *(m___0->xxp + i___3) = (struct xxm_pattern *)tmp___5;
      }
#line 352
      goto while_break___13;
    }
    while_break___13: /* CIL Label */ ;
    }
#line 353
    (*(m___0->xxp + i___3))->rows = 64;
    {
#line 354
    while (1) {
      while_continue___14: /* CIL Label */ ;
#line 354
      j___0 = 0;
      {
#line 354
      while (1) {
        while_continue___15: /* CIL Label */ ;
#line 354
        if (! (j___0 < (m___0->xxh)->chn)) {
#line 354
          goto while_break___15;
        }
        {
#line 354
        (*(m___0->xxp + i___3))->info[j___0].index = i___3 * (m___0->xxh)->chn + j___0;
#line 354
        tmp___6 = calloc((size_t )(sizeof(struct xxm_track ) + sizeof(struct xxm_event ) * (unsigned long )(*(m___0->xxp + i___3))->rows),
                         (size_t )1);
#line 354
        *(m___0->xxt + (i___3 * (m___0->xxh)->chn + j___0)) = (struct xxm_track *)tmp___6;
#line 354
        (*(m___0->xxt + (i___3 * (m___0->xxh)->chn + j___0)))->rows = (*(m___0->xxp + i___3))->rows;
#line 354
        j___0 ++;
        }
      }
      while_break___15: /* CIL Label */ ;
      }
#line 354
      goto while_break___14;
    }
    while_break___14: /* CIL Label */ ;
    }
#line 356
    if (! *(pp_pat___1 + i___3)) {
#line 357
      goto __Cont___0;
    }
    {
#line 359
    fseek(f, (long )(start + (int const   )((int )*(pp_pat___1 + i___3) * 16)), 0);
#line 360
    r = 0;
#line 361
    tmp___7 = read16l(f);
#line 361
    pat_len = (int )tmp___7 - 2;
    }
    {
#line 367
    while (1) {
      while_continue___16: /* CIL Label */ ;
#line 367
      if (! (r < (*(m___0->xxp + i___3))->rows)) {
#line 367
        goto while_break___16;
      }
      {
#line 368
      b___1 = read8(f);
      }
#line 370
      if ((int )b___1 == 0) {
#line 371
        r ++;
#line 372
        goto while_continue___16;
      }
#line 375
      c___0 = (int )b___1 & 31;
#line 376
      if (c___0 >= (m___0->xxh)->chn) {
#line 376
        event = & dummy___3;
      } else {
#line 376
        event = & (*(m___0->xxt + (*(m___0->xxp + i___3))->info[c___0].index))->event[r];
      }
#line 378
      if ((int )b___1 & 32) {
        {
#line 379
        n___0 = read8(f);
        }
        {
#line 380
        if ((int )n___0 == 255) {
#line 380
          goto case_255;
        }
#line 383
        if ((int )n___0 == 254) {
#line 383
          goto case_254;
        }
#line 386
        goto switch_default___0;
        case_255: /* CIL Label */ 
#line 381
        n___0 = (uint8 )0;
#line 382
        goto switch_break___0;
        case_254: /* CIL Label */ 
#line 384
        n___0 = (uint8 )129;
#line 385
        goto switch_break___0;
        switch_default___0: /* CIL Label */ 
#line 387
        n___0 = (uint8 )((1 + 12 * (((int )n___0 & 240) >> 4)) + ((int )n___0 & 15));
        switch_break___0: /* CIL Label */ ;
        }
        {
#line 389
        event->note = n___0;
#line 390
        event->ins = read8(f);
#line 391
        pat_len -= 2;
        }
      }
#line 394
      if ((int )b___1 & 64) {
        {
#line 395
        tmp___8 = read8(f);
#line 395
        event->vol = (uint8 )((int )tmp___8 + 1);
#line 396
        pat_len --;
        }
      }
#line 399
      if ((int )b___1 & 128) {
        {
#line 400
        event->fxt = read8(f);
#line 401
        event->fxp = read8(f);
#line 402
        xlat_fx___4(c___0, event);
#line 403
        pat_len -= 2;
        }
      }
    }
    while_break___16: /* CIL Label */ ;
    }
    {
#line 406
    reportv(ctx___0, 0, (char *)".");
    }
    __Cont___0: /* CIL Label */ 
#line 351
    i___3 ++;
  }
  while_break___12: /* CIL Label */ ;
  }
  {
#line 408
  reportv(ctx___0, 0, (char *)"\n");
  }
#line 410
  if ((int )sfh.mv & 128) {
#line 410
    tmp___9 = "yes";
  } else {
#line 410
    tmp___9 = "no";
  }
  {
#line 410
  reportv(ctx___0, 1, (char *)"Stereo enabled : %s\n", tmp___9);
  }
#line 411
  if (sfh.dp) {
#line 411
    tmp___10 = "no";
  } else {
#line 411
    tmp___10 = "yes";
  }
  {
#line 411
  reportv(ctx___0, 1, (char *)"Pan settings   : %s\n", tmp___10);
  }
  {
#line 413
  while (1) {
    while_continue___17: /* CIL Label */ ;
    {
#line 413
    tmp___11 = calloc((size_t )sizeof(struct xxm_instrument_header ), (size_t )(m___0->xxh)->ins);
#line 413
    m___0->xxih = (struct xxm_instrument_header *)tmp___11;
#line 413
    tmp___12 = calloc((size_t )sizeof(struct xxm_instrument_map ), (size_t )(m___0->xxh)->ins);
#line 413
    m___0->xxim = (struct xxm_instrument_map *)tmp___12;
#line 413
    tmp___13 = calloc((size_t )sizeof(struct xxm_instrument *), (size_t )(m___0->xxh)->ins);
#line 413
    m___0->xxi = (struct xxm_instrument **)tmp___13;
    }
#line 413
    if ((m___0->xxh)->smp) {
      {
#line 413
      tmp___14 = calloc((size_t )sizeof(struct xxm_sample ), (size_t )(m___0->xxh)->smp);
#line 413
      m___0->xxs = (struct xxm_sample *)tmp___14;
      }
    }
    {
#line 413
    tmp___15 = calloc((size_t )sizeof(uint16 *), (size_t )(m___0->xxh)->ins);
#line 413
    m___0->xxae = (uint16 **)tmp___15;
#line 413
    tmp___16 = calloc((size_t )sizeof(uint16 *), (size_t )(m___0->xxh)->ins);
#line 413
    m___0->xxpe = (uint16 **)tmp___16;
#line 413
    tmp___17 = calloc((size_t )sizeof(uint16 *), (size_t )(m___0->xxh)->ins);
#line 413
    m___0->xxfe = (uint16 **)tmp___17;
    }
#line 413
    goto while_break___17;
  }
  while_break___17: /* CIL Label */ ;
  }
  {
#line 417
  reportv(ctx___0, 0, (char *)"Instruments    : %d ", (m___0->xxh)->ins);
#line 419
  i___3 = 0;
  }
  {
#line 419
  while (1) {
    while_continue___18: /* CIL Label */ ;
#line 419
    if (! (i___3 < (m___0->xxh)->ins)) {
#line 419
      goto while_break___18;
    }
    {
#line 420
    tmp___18 = calloc((size_t )sizeof(struct xxm_instrument ), (size_t )1);
#line 420
    *(m___0->xxi + i___3) = (struct xxm_instrument *)tmp___18;
#line 421
    fseek(f, (long )(start + (int const   )((int )*(pp_ins___1 + i___3) * 16)), 0);
#line 422
    x8 = read8(f);
#line 423
    (*(m___0->xxi + i___3) + 0)->pan = 128;
#line 424
    (*(m___0->xxi + i___3) + 0)->sid = i___3;
    }
#line 426
    if ((int )x8 >= 2) {
      {
#line 429
      fread((void */* __restrict  */)(& sah.dosname), (size_t )12, (size_t )1, (FILE */* __restrict  */)f);
#line 430
      fread((void */* __restrict  */)(& sah.rsvd1), (size_t )3, (size_t )1, (FILE */* __restrict  */)f);
#line 431
      fread((void */* __restrict  */)(& sah.reg), (size_t )12, (size_t )1, (FILE */* __restrict  */)f);
#line 432
      sah.vol = read8(f);
#line 433
      sah.dsk = read8(f);
#line 434
      read16l(f);
#line 435
      sah.c2spd = read16l(f);
#line 436
      read16l(f);
#line 437
      fread((void */* __restrict  */)(& sah.rsvd4), (size_t )12, (size_t )1, (FILE */* __restrict  */)f);
#line 438
      fread((void */* __restrict  */)(& sah.name), (size_t )28, (size_t )1, (FILE */* __restrict  */)f);
#line 439
      sah.magic = read32b(f);
      }
#line 441
      if (sah.magic != ((((83U << 24) | (67U << 16)) | (82U << 8)) | 73U)) {
#line 442
        return (-2);
      }
      {
#line 443
      sah.magic = (uint32 )0;
#line 445
      copy_adjust((m___0->xxih + i___3)->name, sah.name, 28);
#line 447
      (m___0->xxih + i___3)->nsm = 1;
#line 448
      (*(m___0->xxi + i___3) + 0)->vol = (int )sah.vol;
#line 449
      c2spd_to_note((int )sah.c2spd, & (*(m___0->xxi + i___3) + 0)->xpo, & (*(m___0->xxi + i___3) + 0)->fin);
#line 450
      (*(m___0->xxi + i___3) + 0)->xpo += 12;
#line 451
      xmp_drv_loadpatch(ctx___0, f, (*(m___0->xxi + i___3) + 0)->sid, 0, 0, (struct xxm_sample *)((void *)0),
                        (char *)(& sah.reg));
      }
#line 452
      if (m___0->verbosity > 0) {
#line 453
        if (m___0->verbosity > 1) {
          {
#line 454
          report((char *)"\n[%2X] %-28.28s ", i___3, (m___0->xxih + i___3)->name);
#line 455
          j = 0;
          }
          {
#line 455
          while (1) {
            while_continue___19: /* CIL Label */ ;
#line 455
            if (! (j < 11)) {
#line 455
              goto while_break___19;
            }
            {
#line 456
            report((char *)"%02x ", (int )sah.reg[j]);
#line 455
            j ++;
            }
          }
          while_break___19: /* CIL Label */ ;
          }
        } else {
          {
#line 458
          report((char *)".");
          }
        }
      }
#line 462
      goto __Cont___1;
    }
    {
#line 465
    fread((void */* __restrict  */)(& sih.dosname), (size_t )13, (size_t )1, (FILE */* __restrict  */)f);
#line 466
    sih.memseg = read16l(f);
#line 467
    sih.length = read32l(f);
#line 468
    sih.loopbeg = read32l(f);
#line 469
    sih.loopend = read32l(f);
#line 470
    sih.vol = read8(f);
#line 471
    sih.rsvd1 = read8(f);
#line 472
    sih.pack = read8(f);
#line 473
    sih.flags = read8(f);
#line 474
    sih.c2spd = read16l(f);
#line 475
    sih.rsvd2 = read16l(f);
#line 476
    fread((void */* __restrict  */)(& sih.rsvd3), (size_t )4, (size_t )1, (FILE */* __restrict  */)f);
#line 477
    sih.int_gp = read16l(f);
#line 478
    sih.int_512 = read16l(f);
#line 479
    sih.int_last = read32l(f);
#line 480
    fread((void */* __restrict  */)(& sih.name), (size_t )28, (size_t )1, (FILE */* __restrict  */)f);
#line 481
    sih.magic = read32b(f);
    }
#line 483
    if ((int )x8 == 1) {
#line 483
      if (sih.magic != ((((83U << 24) | (67U << 16)) | (82U << 8)) | 83U)) {
#line 484
        return (-2);
      }
    }
#line 486
    if (quirk87) {
      {
#line 487
      while (1) {
        while_continue___20: /* CIL Label */ ;
#line 487
        i___7 = 0;
        {
#line 487
        while (1) {
          while_continue___21: /* CIL Label */ ;
#line 487
          if (! ((unsigned long )i___7 < sizeof(sih.length))) {
#line 487
            goto while_break___21;
          }
#line 487
          if ((int )*((uint8 *)(& sih.length) + i___7) == 135) {
#line 487
            *((uint8 *)(& sih.length) + i___7) = (uint8 )0;
          }
#line 487
          i___7 ++;
        }
        while_break___21: /* CIL Label */ ;
        }
#line 487
        goto while_break___20;
      }
      while_break___20: /* CIL Label */ ;
      }
      {
#line 488
      while (1) {
        while_continue___22: /* CIL Label */ ;
#line 488
        i___8 = 0;
        {
#line 488
        while (1) {
          while_continue___23: /* CIL Label */ ;
#line 488
          if (! ((unsigned long )i___8 < sizeof(sih.loopbeg))) {
#line 488
            goto while_break___23;
          }
#line 488
          if ((int )*((uint8 *)(& sih.loopbeg) + i___8) == 135) {
#line 488
            *((uint8 *)(& sih.loopbeg) + i___8) = (uint8 )0;
          }
#line 488
          i___8 ++;
        }
        while_break___23: /* CIL Label */ ;
        }
#line 488
        goto while_break___22;
      }
      while_break___22: /* CIL Label */ ;
      }
      {
#line 489
      while (1) {
        while_continue___24: /* CIL Label */ ;
#line 489
        i___9 = 0;
        {
#line 489
        while (1) {
          while_continue___25: /* CIL Label */ ;
#line 489
          if (! ((unsigned long )i___9 < sizeof(sih.loopend))) {
#line 489
            goto while_break___25;
          }
#line 489
          if ((int )*((uint8 *)(& sih.loopend) + i___9) == 135) {
#line 489
            *((uint8 *)(& sih.loopend) + i___9) = (uint8 )0;
          }
#line 489
          i___9 ++;
        }
        while_break___25: /* CIL Label */ ;
        }
#line 489
        goto while_break___24;
      }
      while_break___24: /* CIL Label */ ;
      }
      {
#line 490
      while (1) {
        while_continue___26: /* CIL Label */ ;
#line 490
        i___10 = 0;
        {
#line 490
        while (1) {
          while_continue___27: /* CIL Label */ ;
#line 490
          if (! ((unsigned long )i___10 < sizeof(sih.flags))) {
#line 490
            goto while_break___27;
          }
#line 490
          if ((int )*(& sih.flags + i___10) == 135) {
#line 490
            *(& sih.flags + i___10) = (uint8 )0;
          }
#line 490
          i___10 ++;
        }
        while_break___27: /* CIL Label */ ;
        }
#line 490
        goto while_break___26;
      }
      while_break___26: /* CIL Label */ ;
      }
    }
#line 493
    tmp___19 = (int )sih.length;
#line 493
    (m___0->xxs + i___3)->len = tmp___19;
#line 493
    if (tmp___19) {
#line 493
      tmp___20 = 1;
    } else {
#line 493
      tmp___20 = 0;
    }
#line 493
    (m___0->xxih + i___3)->nsm = tmp___20;
#line 494
    (m___0->xxs + i___3)->lps = (int )sih.loopbeg;
#line 495
    (m___0->xxs + i___3)->lpe = (int )sih.loopend;
#line 497
    if ((int )sih.flags & 1) {
#line 497
      (m___0->xxs + i___3)->flg = 4;
    } else {
#line 497
      (m___0->xxs + i___3)->flg = 0;
    }
#line 498
    if ((int )sih.flags & 4) {
#line 498
      tmp___21 = 1;
    } else {
#line 498
      tmp___21 = 0;
    }
    {
#line 498
    (m___0->xxs + i___3)->flg |= tmp___21;
#line 499
    (*(m___0->xxi + i___3) + 0)->vol = (int )sih.vol;
#line 500
    sih.magic = (uint32 )0;
#line 502
    copy_adjust((m___0->xxih + i___3)->name, sih.name, 28);
    }
#line 504
    if (m___0->verbosity > 1) {
      {
#line 504
      tmp___24 = strlen((char const   *)((char *)(sih.name)));
      }
#line 504
      if (tmp___24) {
#line 504
        goto _L;
      } else
#line 504
      if ((m___0->xxs + i___3)->len) {
        _L: /* CIL Label */ 
#line 505
        if ((m___0->xxs + i___3)->flg & 4) {
#line 505
          tmp___22 = 'L';
        } else {
#line 505
          tmp___22 = ' ';
        }
#line 505
        if ((m___0->xxs + i___3)->flg & 1) {
#line 505
          tmp___23 = '+';
        } else {
#line 505
          tmp___23 = ' ';
        }
        {
#line 505
        report((char *)"\n[%2X] %-28.28s %04x%c%04x %04x %c V%02x %5d ", i___3, (m___0->xxih + i___3)->name,
               (m___0->xxs + i___3)->len, tmp___23, (m___0->xxs + i___3)->lps, (m___0->xxs + i___3)->lpe,
               tmp___22, (*(m___0->xxi + i___3) + 0)->vol, (int )sih.c2spd);
        }
      }
    }
    {
#line 512
    c2spd_to_note((int )sih.c2spd, & (*(m___0->xxi + i___3) + 0)->xpo, & (*(m___0->xxi + i___3) + 0)->fin);
#line 514
    fseek(f, (long )start + 16L * (long )sih.memseg, 0);
#line 515
    xmp_drv_loadpatch(ctx___0, f, (*(m___0->xxi + i___3) + 0)->sid, m___0->c4rate,
                      ((int )sfh.ffi - 1) * 2, m___0->xxs + i___3, (char *)((void *)0));
    }
#line 518
    if (m___0->verbosity > 0) {
#line 518
      if ((m___0->xxs + i___3)->len) {
        {
#line 519
        report((char *)".");
        }
      }
    }
    __Cont___1: /* CIL Label */ 
#line 419
    i___3 ++;
  }
  while_break___18: /* CIL Label */ ;
  }
  {
#line 521
  reportv(ctx___0, 0, (char *)"\n");
#line 523
  free((void *)pp_pat___1);
#line 524
  free((void *)pp_ins___1);
#line 526
  m___0->quirk |= ((((1 << 5) | (1 << 4)) | (1 << 1)) | (1 << 14)) | (1 << 17);
  }
#line 528
  return (0);
}
}
#line 135 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strcat)(char * __restrict  __dest ,
                                                                                       char const   * __restrict  __src ) ;
#line 35 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/mod_load.c"
struct __anonstruct_mod_magic_48 mod_magic[13]  = 
#line 35 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/mod_load.c"
  {      {(char *)"M.K.", 0, 1, (char *)"Protracker", 4}, 
        {(char *)"M!K!", 1, 1, (char *)"Protracker", 4}, 
        {(char *)"M&K!", 1, 1, (char *)"Noisetracker", 4}, 
        {(char *)"N.T.", 1, 1, (char *)"Noisetracker", 4}, 
        {(char *)"6CHN", 0, 0, (char *)"Fast Tracker", 6}, 
        {(char *)"8CHN", 0, 0, (char *)"Fast Tracker", 8}, 
        {(char *)"CD61", 1, 0, (char *)"Octalyser", 6}, 
        {(char *)"CD81", 1, 0, (char *)"Octalyser", 8}, 
        {(char *)"TDZ4", 1, 0, (char *)"TakeTracker", 4}, 
        {(char *)"FA04", 1, 0, (char *)"Digital Tracker", 4}, 
        {(char *)"FA06", 1, 0, (char *)"Digital Tracker", 6}, 
        {(char *)"FA08", 1, 0, (char *)"Digital Tracker", 8}, 
        {(char *)"", 0, 0, (char *)0, 0}};
#line 58
static int mod_test(FILE *f , char *t , int const   start ) ;
#line 59
static int mod_load(struct xmp_context *ctx___0 , FILE *f , int const   start ) ;
#line 61 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/mod_load.c"
struct xmp_loader_info mod_loader  =    {(char *)"MOD", (char *)"Noise/Fast/Protracker", & mod_test, & mod_load, 0, {(struct list_head *)0,
                                                                                (struct list_head *)0}};
#line 68 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/mod_load.c"
static int mod_test(FILE *f , char *t , int const   start ) 
{ 
  int i___3 ;
  char buf___1[4] ;
  struct stat st ;
  int smp_size ;
  int num_pat ;
  int tmp ;
  unsigned short const   **tmp___0 ;
  unsigned short const   **tmp___1 ;
  int tmp___2 ;
  unsigned short const   **tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  uint16 tmp___6 ;
  uint8 x ;
  uint8 tmp___7 ;
  void *__cil_tmp19 ;
  void *__cil_tmp20 ;
  void *__cil_tmp21 ;
  void *__cil_tmp22 ;
  void *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;

  {
  {
#line 75
  fseek(f, (long )(start + 1080), 0);
#line 76
  fread((void */* __restrict  */)(buf___1), (size_t )4, (size_t )1, (FILE */* __restrict  */)f);
#line 78
  tmp = strncmp((char const   *)(buf___1 + 2), "CH", (size_t )2);
  }
#line 78
  if (! tmp) {
    {
#line 78
    tmp___0 = __ctype_b_loc();
    }
#line 78
    if ((int const   )*(*tmp___0 + (int )buf___1[0]) & 2048) {
      {
#line 78
      tmp___1 = __ctype_b_loc();
      }
#line 78
      if ((int const   )*(*tmp___1 + (int )buf___1[1]) & 2048) {
#line 79
        i___3 = (((int )buf___1[0] - 48) * 10 + (int )buf___1[1]) - 48;
#line 80
        if (i___3 > 0) {
#line 80
          if (i___3 <= 32) {
#line 81
            return (0);
          }
        }
      }
    }
  }
  {
#line 84
  tmp___2 = strncmp((char const   *)(buf___1 + 1), "CHN", (size_t )3);
  }
#line 84
  if (! tmp___2) {
    {
#line 84
    tmp___3 = __ctype_b_loc();
    }
#line 84
    if ((int const   )*(*tmp___3 + (int )buf___1[0]) & 2048) {
#line 85
      if ((int )buf___1[0] - 48) {
#line 86
        return (0);
      }
    }
  }
#line 89
  i___3 = 0;
  {
#line 89
  while (1) {
    while_continue: /* CIL Label */ ;
#line 89
    if (! mod_magic[i___3].ch) {
#line 89
      goto while_break;
    }
    {
#line 90
    tmp___4 = memcmp((void const   *)(buf___1), (void const   *)mod_magic[i___3].magic,
                     (size_t )4);
    }
#line 90
    if (! tmp___4) {
#line 91
      goto while_break;
    }
#line 89
    i___3 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 93
  if (mod_magic[i___3].ch == 0) {
#line 94
    return (-1);
  }
  {
#line 106
  tmp___5 = fileno(f);
#line 106
  fstat(tmp___5, & st);
#line 107
  smp_size = 0;
#line 108
  fseek(f, (long )(start + 20), 0);
#line 111
  i___3 = 0;
  }
  {
#line 111
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 111
    if (! (i___3 < 31)) {
#line 111
      goto while_break___0;
    }
    {
#line 112
    fseek(f, 22L, 1);
#line 113
    tmp___6 = read16b(f);
#line 113
    smp_size += 2 * (int )tmp___6;
#line 114
    fseek(f, 6L, 1);
#line 111
    i___3 ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 118
  num_pat = 0;
#line 119
  fseek(f, (long )(start + 952), 0);
#line 120
  i___3 = 0;
  }
  {
#line 120
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 120
    if (! (i___3 < 128)) {
#line 120
      goto while_break___1;
    }
    {
#line 121
    tmp___7 = read8(f);
#line 121
    x = tmp___7;
    }
#line 122
    if ((int )x > 127) {
#line 123
      goto while_break___1;
    }
#line 124
    if ((int )x > num_pat) {
#line 125
      num_pat = (int )x;
    }
#line 120
    i___3 ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 127
  num_pat ++;
#line 129
  if ((__off_t )(((start + 1084) + (int const   )(num_pat * 768)) + (int const   )smp_size) == st.st_size) {
#line 130
    return (-1);
  }
  {
#line 132
  fseek(f, (long )start, 0);
#line 133
  read_title(f, t, 20);
  }
#line 135
  return (0);
}
}
#line 139 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/mod_load.c"
static int is_st_ins(char *s ) 
{ 
  unsigned short const   **tmp ;
  unsigned short const   **tmp___0 ;

  {
#line 141
  if ((int )*(s + 0) != 115) {
#line 141
    if ((int )*(s + 0) != 83) {
#line 142
      return (0);
    }
  }
#line 143
  if ((int )*(s + 1) != 116) {
#line 143
    if ((int )*(s + 1) != 84) {
#line 144
      return (0);
    }
  }
#line 145
  if ((int )*(s + 2) != 45) {
#line 146
    return (0);
  } else
#line 145
  if ((int )*(s + 5) != 58) {
#line 146
    return (0);
  }
  {
#line 147
  tmp = __ctype_b_loc();
  }
#line 147
  if ((int const   )*(*tmp + (int )*(s + 3)) & 2048) {
    {
#line 147
    tmp___0 = __ctype_b_loc();
    }
#line 147
    if (! ((int const   )*(*tmp___0 + (int )*(s + 4)) & 2048)) {
#line 148
      return (0);
    }
  } else {
#line 148
    return (0);
  }
#line 150
  return (1);
}
}
#line 154 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/mod_load.c"
static int mod_load(struct xmp_context *ctx___0 , FILE *f , int const   start ) 
{ 
  struct xmp_player_context *p ;
  struct xmp_mod_context *m___0 ;
  struct xmp_options *o___0 ;
  int i___3 ;
  int j ;
  int smp_size ;
  int pat_size ;
  int wow ;
  int ptsong ;
  struct xxm_event *event ;
  struct mod_header mh ;
  uint8 mod_event[4] ;
  char *x ;
  char pathname[256] ;
  unsigned int tmp ;
  char *tracker ;
  int lps_mult ;
  int tmp___0 ;
  int detected ;
  char magic[8] ;
  char idbuffer[32] ;
  int ptkloop ;
  uint8 **tmp___1 ;
  uint8 tmp___2 ;
  uint8 tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  unsigned short const   **tmp___8 ;
  int tmp___9 ;
  unsigned short const   **tmp___10 ;
  unsigned short const   **tmp___11 ;
  void *tmp___12 ;
  void *tmp___13 ;
  void *tmp___14 ;
  void *tmp___15 ;
  void *tmp___16 ;
  void *tmp___17 ;
  void *tmp___18 ;
  void *tmp___19 ;
  int pos___0 ;
  long tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  size_t tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;
  void *tmp___32 ;
  void *tmp___33 ;
  void *tmp___34 ;
  int j___0 ;
  void *tmp___35 ;
  FILE *s ;
  char sn[256] ;
  void *__cil_tmp65 ;
  void *__cil_tmp66 ;
  void *__cil_tmp67 ;
  int __cil_tmp68 ;
  void *__cil_tmp69 ;
  void *__cil_tmp70 ;
  void *__cil_tmp71 ;
  void *__cil_tmp72 ;
  void *__cil_tmp73 ;
  void *__cil_tmp74 ;
  void *__cil_tmp75 ;
  void *__cil_tmp76 ;
  void *__cil_tmp77 ;
  char *__cil_tmp78 ;
  char *__cil_tmp79 ;
  char *__cil_tmp80 ;
  char *__cil_tmp81 ;
  char *__cil_tmp82 ;
  char *__cil_tmp83 ;
  char *__cil_tmp84 ;
  char *__cil_tmp85 ;
  char *__cil_tmp86 ;
  char *__cil_tmp87 ;
  char *__cil_tmp88 ;
  char *__cil_tmp89 ;
  char *__cil_tmp90 ;
  char *__cil_tmp91 ;
  char *__cil_tmp92 ;
  char *__cil_tmp93 ;
  char *__cil_tmp94 ;
  char *__cil_tmp95 ;
  char *__cil_tmp96 ;
  char *__cil_tmp97 ;
  char *__cil_tmp98 ;
  char *__cil_tmp99 ;
  char *__cil_tmp100 ;
  char *__cil_tmp101 ;
  char *__cil_tmp102 ;
  char *__cil_tmp103 ;
  char *__cil_tmp104 ;
  char *__cil_tmp105 ;
  char *__cil_tmp106 ;
  char *__cil_tmp107 ;
  char *__cil_tmp108 ;
  char *__cil_tmp109 ;
  char *__cil_tmp110 ;
  char *__cil_tmp111 ;
  char *__cil_tmp112 ;
  char *__cil_tmp113 ;
  char *__cil_tmp114 ;
  char *__cil_tmp115 ;
  char *__cil_tmp116 ;
  char *__cil_tmp117 ;
  char *__cil_tmp118 ;
  char *__cil_tmp119 ;
  char *__cil_tmp120 ;
  char *__cil_tmp121 ;
  char *__cil_tmp122 ;
  char *__cil_tmp123 ;

  {
#line 156
  p = & ctx___0->p;
#line 157
  m___0 = & p->m;
#line 158
  o___0 = & ctx___0->o;
#line 160
  ptsong = 0;
#line 164
  pathname[0] = (char )'\000';
#line 164
  tmp = 1U;
  {
#line 164
  while (1) {
    while_continue: /* CIL Label */ ;
#line 164
    if (tmp >= 256U) {
#line 164
      goto while_break;
    }
#line 164
    pathname[tmp] = (char)0;
#line 164
    tmp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 164
  tracker = (char *)"";
#line 165
  if (m___0->flags & (1 << 7)) {
#line 165
    tmp___0 = 1;
  } else {
#line 165
    tmp___0 = 2;
  }
#line 165
  lps_mult = tmp___0;
#line 166
  detected = 0;
#line 168
  ptkloop = 0;
  {
#line 170
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 170
    fseek(f, (long )start, 0);
#line 170
    tmp___1 = (uint8 **)((void *)0);
#line 170
    m___0->med_wav_table = tmp___1;
#line 170
    m___0->med_vol_table = tmp___1;
#line 170
    set_xxh_defaults(m___0->xxh);
    }
#line 170
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 172
  (m___0->xxh)->ins = 31;
#line 173
  (m___0->xxh)->smp = (m___0->xxh)->ins;
#line 174
  (m___0->xxh)->chn = 0;
#line 175
  smp_size = 0;
#line 176
  pat_size = 0;
#line 178
  (m___0->xxh)->flg |= 2;
#line 180
  fread((void */* __restrict  */)(& mh.name), (size_t )20, (size_t )1, (FILE */* __restrict  */)f);
#line 181
  i___3 = 0;
  }
  {
#line 181
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 181
    if (! (i___3 < 31)) {
#line 181
      goto while_break___1;
    }
    {
#line 182
    fread((void */* __restrict  */)(& mh.ins[i___3].name), (size_t )22, (size_t )1,
          (FILE */* __restrict  */)f);
#line 183
    mh.ins[i___3].size = read16b(f);
#line 184
    tmp___2 = read8(f);
#line 184
    mh.ins[i___3].finetune = (int8 )tmp___2;
#line 185
    tmp___3 = read8(f);
#line 185
    mh.ins[i___3].volume = (int8 )tmp___3;
#line 186
    mh.ins[i___3].loop_start = read16b(f);
#line 187
    mh.ins[i___3].loop_size = read16b(f);
#line 189
    smp_size += 2 * (int )mh.ins[i___3].size;
#line 181
    i___3 ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 191
  mh.len = read8(f);
#line 192
  mh.restart = read8(f);
#line 193
  fread((void */* __restrict  */)(& mh.order), (size_t )128, (size_t )1, (FILE */* __restrict  */)f);
#line 194
  memset((void *)(magic), 0, (size_t )8);
#line 195
  fread((void */* __restrict  */)(magic), (size_t )4, (size_t )1, (FILE */* __restrict  */)f);
#line 197
  i___3 = 0;
  }
  {
#line 197
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 197
    if (! mod_magic[i___3].ch) {
#line 197
      goto while_break___2;
    }
    {
#line 198
    tmp___4 = strncmp((char const   *)(magic), (char const   *)mod_magic[i___3].magic,
                      (size_t )4);
    }
#line 198
    if (! tmp___4) {
#line 199
      (m___0->xxh)->chn = mod_magic[i___3].ch;
#line 200
      tracker = mod_magic[i___3].tracker;
#line 201
      detected = mod_magic[i___3].flag;
#line 202
      ptkloop = mod_magic[i___3].ptkloop;
#line 203
      goto while_break___2;
    }
#line 197
    i___3 ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 207
  if (! (m___0->xxh)->chn) {
    {
#line 208
    tmp___9 = strncmp((char const   *)(magic + 2), "CH", (size_t )2);
    }
#line 208
    if (tmp___9) {
      _L___0: /* CIL Label */ 
      {
#line 213
      tmp___7 = strncmp((char const   *)(magic + 1), "CHN", (size_t )3);
      }
#line 213
      if (tmp___7) {
#line 218
        return (-1);
      } else {
        {
#line 213
        tmp___8 = __ctype_b_loc();
        }
#line 213
        if ((int const   )*(*tmp___8 + (int )magic[0]) & 2048) {
#line 215
          tmp___6 = (int )magic[0] - 48;
#line 215
          (m___0->xxh)->chn = tmp___6;
#line 215
          if (! tmp___6) {
#line 216
            return (-1);
          }
        } else {
#line 218
          return (-1);
        }
      }
    } else {
      {
#line 208
      tmp___10 = __ctype_b_loc();
      }
#line 208
      if ((int const   )*(*tmp___10 + (int )magic[0]) & 2048) {
        {
#line 208
        tmp___11 = __ctype_b_loc();
        }
#line 208
        if ((int const   )*(*tmp___11 + (int )magic[1]) & 2048) {
#line 210
          tmp___5 = (((int )magic[0] - 48) * 10 + (int )magic[1]) - 48;
#line 210
          (m___0->xxh)->chn = tmp___5;
#line 210
          if (tmp___5 > 32) {
#line 212
            return (-1);
          }
        } else {
#line 208
          goto _L___0;
        }
      } else {
#line 208
        goto _L___0;
      }
    }
#line 219
    tracker = (char *)"TakeTracker/FastTracker II";
#line 220
    detected = 1;
#line 221
    (m___0->xxh)->flg &= -3;
  }
  {
#line 224
  strncpy((char */* __restrict  */)(m___0->name), (char const   */* __restrict  */)((char *)(mh.name)),
          (size_t )20);
#line 226
  (m___0->xxh)->len = (int )mh.len;
  }
#line 229
  if ((m___0->xxh)->rst >= (m___0->xxh)->len) {
#line 230
    (m___0->xxh)->rst = 0;
  }
  {
#line 231
  memcpy((void */* __restrict  */)(m___0->xxo), (void const   */* __restrict  */)(mh.order),
         (size_t )128);
#line 233
  i___3 = 0;
  }
  {
#line 233
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 233
    if (! (i___3 < 128)) {
#line 233
      goto while_break___3;
    }
#line 235
    if ((int )m___0->xxo[i___3] > 127) {
#line 236
      goto while_break___3;
    }
#line 237
    if ((int )m___0->xxo[i___3] > (m___0->xxh)->pat) {
#line 238
      (m___0->xxh)->pat = (int )m___0->xxo[i___3];
    }
#line 233
    i___3 ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 240
  ((m___0->xxh)->pat) ++;
#line 242
  pat_size = (256 * (m___0->xxh)->chn) * (m___0->xxh)->pat;
  {
#line 244
  while (1) {
    while_continue___4: /* CIL Label */ ;
    {
#line 244
    tmp___12 = calloc((size_t )sizeof(struct xxm_instrument_header ), (size_t )(m___0->xxh)->ins);
#line 244
    m___0->xxih = (struct xxm_instrument_header *)tmp___12;
#line 244
    tmp___13 = calloc((size_t )sizeof(struct xxm_instrument_map ), (size_t )(m___0->xxh)->ins);
#line 244
    m___0->xxim = (struct xxm_instrument_map *)tmp___13;
#line 244
    tmp___14 = calloc((size_t )sizeof(struct xxm_instrument *), (size_t )(m___0->xxh)->ins);
#line 244
    m___0->xxi = (struct xxm_instrument **)tmp___14;
    }
#line 244
    if ((m___0->xxh)->smp) {
      {
#line 244
      tmp___15 = calloc((size_t )sizeof(struct xxm_sample ), (size_t )(m___0->xxh)->smp);
#line 244
      m___0->xxs = (struct xxm_sample *)tmp___15;
      }
    }
    {
#line 244
    tmp___16 = calloc((size_t )sizeof(uint16 *), (size_t )(m___0->xxh)->ins);
#line 244
    m___0->xxae = (uint16 **)tmp___16;
#line 244
    tmp___17 = calloc((size_t )sizeof(uint16 *), (size_t )(m___0->xxh)->ins);
#line 244
    m___0->xxpe = (uint16 **)tmp___17;
#line 244
    tmp___18 = calloc((size_t )sizeof(uint16 *), (size_t )(m___0->xxh)->ins);
#line 244
    m___0->xxfe = (uint16 **)tmp___18;
    }
#line 244
    goto while_break___4;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 246
  i___3 = 0;
  {
#line 246
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 246
    if (! (i___3 < (m___0->xxh)->ins)) {
#line 246
      goto while_break___5;
    }
    {
#line 247
    tmp___19 = calloc((size_t )sizeof(struct xxm_instrument ), (size_t )1);
#line 247
    *(m___0->xxi + i___3) = (struct xxm_instrument *)tmp___19;
#line 248
    (m___0->xxs + i___3)->len = 2 * (int )mh.ins[i___3].size;
#line 249
    (m___0->xxs + i___3)->lps = lps_mult * (int )mh.ins[i___3].loop_start;
#line 250
    (m___0->xxs + i___3)->lpe = (m___0->xxs + i___3)->lps + 2 * (int )mh.ins[i___3].loop_size;
    }
#line 251
    if ((m___0->xxs + i___3)->lpe > (m___0->xxs + i___3)->len) {
#line 252
      (m___0->xxs + i___3)->lpe = (m___0->xxs + i___3)->len;
    }
#line 253
    if ((int )mh.ins[i___3].loop_size > 1) {
#line 253
      if ((m___0->xxs + i___3)->lpe > 8) {
#line 253
        (m___0->xxs + i___3)->flg = 4;
      } else {
#line 253
        (m___0->xxs + i___3)->flg = 0;
      }
    } else {
#line 253
      (m___0->xxs + i___3)->flg = 0;
    }
    {
#line 255
    (*(m___0->xxi + i___3) + 0)->fin = (int )((int8 )((int )mh.ins[i___3].finetune << 4));
#line 256
    (*(m___0->xxi + i___3) + 0)->vol = (int )mh.ins[i___3].volume;
#line 257
    (*(m___0->xxi + i___3) + 0)->pan = 128;
#line 258
    (*(m___0->xxi + i___3) + 0)->sid = i___3;
#line 259
    (m___0->xxih + i___3)->nsm = ! (! (m___0->xxs + i___3)->len);
#line 260
    copy_adjust((m___0->xxih + i___3)->name, mh.ins[i___3].name, 22);
#line 246
    i___3 ++;
    }
  }
  while_break___5: /* CIL Label */ ;
  }
#line 267
  if (detected) {
#line 268
    goto skip_test;
  }
#line 280
  if ((1084 + (((m___0->xxh)->pat * 4) * (m___0->xxh)->chn) * 64) + smp_size < m___0->size) {
    {
#line 281
    tmp___20 = ftell(f);
#line 281
    pos___0 = (int )tmp___20;
#line 282
    fseek(f, (long )(((start + 1084) + (int const   )((((m___0->xxh)->pat * 4) * (m___0->xxh)->chn) * 64)) + (int const   )smp_size),
          0);
#line 283
    fread((void */* __restrict  */)(idbuffer), (size_t )1, (size_t )4, (FILE */* __restrict  */)f);
#line 284
    fseek(f, (long )(start + (int const   )pos___0), 0);
#line 286
    tmp___21 = memcmp((void const   *)(idbuffer), (void const   *)"FLEX", (size_t )4);
    }
#line 286
    if (! tmp___21) {
#line 287
      tracker = (char *)"Flextrax";
#line 288
      ptkloop = 0;
#line 289
      goto skip_test;
    }
  }
  {
#line 302
  tmp___24 = strncmp((char const   *)(magic), "M.K.", (size_t )4);
  }
#line 302
  if (tmp___24) {
#line 302
    tmp___25 = 0;
  } else
#line 302
  if ((1084 + ((m___0->xxh)->pat * 32) * 64) + smp_size == m___0->size) {
#line 302
    tmp___25 = 1;
  } else {
#line 302
    tmp___25 = 0;
  }
#line 302
  wow = tmp___25;
#line 302
  if (wow) {
#line 304
    (m___0->xxh)->chn = 8;
#line 305
    tracker = (char *)"Mod\'s Grave";
#line 306
    ptkloop = 0;
#line 307
    goto skip_test;
  } else {
    {
#line 312
    tmp___22 = strncmp((char const   *)(magic), "M.K.", (size_t )4);
    }
#line 312
    if (tmp___22) {
#line 312
      tmp___23 = 0;
    } else
#line 312
    if (1084 + (m___0->xxh)->pat * 1024 == m___0->size) {
#line 312
      tmp___23 = 1;
    } else {
#line 312
      tmp___23 = 0;
    }
#line 312
    ptsong = tmp___23;
#line 312
    if (ptsong) {
#line 314
      tracker = (char *)"Protracker";
#line 315
      goto skip_test;
    }
  }
#line 320
  if ((m___0->xxh)->chn == 4) {
#line 320
    if ((int )mh.restart == (m___0->xxh)->pat) {
#line 321
      tracker = (char *)"Soundtracker";
    } else {
#line 320
      goto _L___2;
    }
  } else
  _L___2: /* CIL Label */ 
#line 322
  if ((m___0->xxh)->chn == 4) {
#line 322
    if ((int )mh.restart == 120) {
#line 323
      tracker = (char *)"Noisetracker";
#line 324
      ptkloop = 1;
    } else {
#line 322
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
#line 325
  if ((int )mh.restart < 127) {
#line 326
    if ((m___0->xxh)->chn == 4) {
#line 327
      tracker = (char *)"Noisetracker";
#line 328
      ptkloop = 1;
    } else {
#line 330
      tracker = (char *)"unknown tracker";
#line 331
      ptkloop = 0;
    }
#line 333
    (m___0->xxh)->rst = (int )mh.restart;
  }
#line 336
  if ((m___0->xxh)->chn != 4) {
#line 336
    if ((int )mh.restart == 127) {
#line 337
      tracker = (char *)"Scream Tracker 3";
#line 338
      ptkloop = 0;
#line 339
      (m___0->xxh)->flg &= -3;
    }
  }
#line 342
  if ((m___0->xxh)->chn == 4) {
#line 342
    if ((int )mh.restart == 127) {
#line 343
      i___3 = 0;
      {
#line 343
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 343
        if (! (i___3 < 31)) {
#line 343
          goto while_break___6;
        }
#line 344
        if ((int )mh.ins[i___3].loop_size == 0) {
#line 345
          goto while_break___6;
        }
#line 343
        i___3 ++;
      }
      while_break___6: /* CIL Label */ ;
      }
#line 347
      if (i___3 < 31) {
#line 348
        tracker = (char *)"Protracker clone";
#line 349
        ptkloop = 0;
      }
    }
  }
#line 353
  if ((int )mh.restart != 120) {
#line 353
    if ((int )mh.restart < 127) {
#line 354
      i___3 = 0;
      {
#line 354
      while (1) {
        while_continue___7: /* CIL Label */ ;
#line 354
        if (! (i___3 < 31)) {
#line 354
          goto while_break___7;
        }
#line 355
        if ((int )mh.ins[i___3].loop_size == 0) {
#line 356
          goto while_break___7;
        }
#line 354
        i___3 ++;
      }
      while_break___7: /* CIL Label */ ;
      }
#line 358
      if (i___3 == 31) {
#line 359
        i___3 = 0;
        {
#line 359
        while (1) {
          while_continue___8: /* CIL Label */ ;
#line 359
          if (! (i___3 < 31)) {
#line 359
            goto while_break___8;
          }
#line 360
          if ((int )mh.ins[i___3].size == 1) {
#line 360
            if ((int )mh.ins[i___3].volume == 0) {
#line 361
              tracker = (char *)"Probably converted";
#line 362
              ptkloop = 0;
#line 363
              goto skip_test;
            }
          }
#line 359
          i___3 ++;
        }
        while_break___8: /* CIL Label */ ;
        }
#line 367
        i___3 = 0;
        {
#line 367
        while (1) {
          while_continue___9: /* CIL Label */ ;
#line 367
          if (! (i___3 < 31)) {
#line 367
            goto while_break___9;
          }
          {
#line 368
          tmp___26 = is_st_ins((char *)(mh.ins[i___3].name));
          }
#line 368
          if (tmp___26) {
#line 369
            goto while_break___9;
          }
#line 367
          i___3 ++;
        }
        while_break___9: /* CIL Label */ ;
        }
#line 371
        if (i___3 == 31) {
#line 372
          i___3 = 0;
          {
#line 372
          while (1) {
            while_continue___10: /* CIL Label */ ;
#line 372
            if (! (i___3 < 31)) {
#line 372
              goto while_break___10;
            }
#line 373
            if ((int )mh.ins[i___3].size == 0) {
#line 373
              if ((int )mh.ins[i___3].loop_size == 1) {
                {
#line 375
                if ((m___0->xxh)->chn == 4) {
#line 375
                  goto case_4;
                }
#line 379
                if ((m___0->xxh)->chn == 8) {
#line 379
                  goto case_8;
                }
#line 379
                if ((m___0->xxh)->chn == 6) {
#line 379
                  goto case_8;
                }
#line 383
                goto switch_default;
                case_4: /* CIL Label */ 
#line 376
                tracker = (char *)"old Noisetracker/Octalyzer";
#line 377
                goto switch_break;
                case_8: /* CIL Label */ 
                case_6: /* CIL Label */ 
#line 380
                tracker = (char *)"Octalyser";
#line 381
                ptkloop = 0;
#line 382
                goto switch_break;
                switch_default: /* CIL Label */ 
#line 384
                tracker = (char *)"unknown tracker";
#line 385
                ptkloop = 0;
                switch_break: /* CIL Label */ ;
                }
#line 387
                goto skip_test;
              }
            }
#line 372
            i___3 ++;
          }
          while_break___10: /* CIL Label */ ;
          }
#line 391
          if ((m___0->xxh)->chn == 4) {
#line 392
            tracker = (char *)"Maybe Protracker";
#line 393
            ptkloop = 0;
          } else
#line 394
          if ((m___0->xxh)->chn == 6) {
#line 395
            tracker = (char *)"FastTracker 1.01?";
#line 396
            ptkloop = 0;
#line 397
            (m___0->xxh)->flg &= -3;
          } else
#line 394
          if ((m___0->xxh)->chn == 8) {
#line 395
            tracker = (char *)"FastTracker 1.01?";
#line 396
            ptkloop = 0;
#line 397
            (m___0->xxh)->flg &= -3;
          } else {
#line 399
            tracker = (char *)"unknown tracker";
#line 400
            ptkloop = 0;
          }
        }
      } else {
#line 404
        i___3 = 15;
        {
#line 404
        while (1) {
          while_continue___11: /* CIL Label */ ;
#line 404
          if (! (i___3 < 31)) {
#line 404
            goto while_break___11;
          }
          {
#line 405
          tmp___27 = strlen((char const   *)((char *)(mh.ins[i___3].name)));
          }
#line 405
          if (tmp___27) {
#line 406
            goto while_break___11;
          } else
#line 405
          if ((int )mh.ins[i___3].size > 0) {
#line 406
            goto while_break___11;
          }
#line 404
          i___3 ++;
        }
        while_break___11: /* CIL Label */ ;
        }
#line 408
        if (i___3 == 31) {
          {
#line 408
          tmp___28 = is_st_ins((char *)(mh.ins[14].name));
          }
#line 408
          if (tmp___28) {
#line 409
            tracker = (char *)"converted 15 instrument";
#line 410
            ptkloop = 0;
#line 411
            goto skip_test;
          }
        }
#line 415
        i___3 = 0;
        {
#line 415
        while (1) {
          while_continue___12: /* CIL Label */ ;
#line 415
          if (! (i___3 < 31)) {
#line 415
            goto while_break___12;
          }
          {
#line 416
          tmp___29 = is_st_ins((char *)(mh.ins[i___3].name));
          }
#line 416
          if (tmp___29) {
#line 417
            goto while_break___12;
          }
#line 415
          i___3 ++;
        }
        while_break___12: /* CIL Label */ ;
        }
#line 419
        if (i___3 < 31) {
#line 420
          tracker = (char *)"unknown/converted";
#line 421
          ptkloop = 0;
#line 422
          goto skip_test;
        }
#line 425
        if ((m___0->xxh)->chn == 4) {
#line 426
          tracker = (char *)"Fast Tracker";
#line 427
          ptkloop = 0;
#line 428
          (m___0->xxh)->flg &= -3;
#line 429
          goto skip_test;
        } else
#line 425
        if ((m___0->xxh)->chn == 6) {
#line 426
          tracker = (char *)"Fast Tracker";
#line 427
          ptkloop = 0;
#line 428
          (m___0->xxh)->flg &= -3;
#line 429
          goto skip_test;
        } else
#line 425
        if ((m___0->xxh)->chn == 8) {
#line 426
          tracker = (char *)"Fast Tracker";
#line 427
          ptkloop = 0;
#line 428
          (m___0->xxh)->flg &= -3;
#line 429
          goto skip_test;
        }
#line 432
        tracker = (char *)"unknown tracker";
#line 433
        ptkloop = 0;
      }
    }
  }
  skip_test: 
  {
#line 440
  (m___0->xxh)->trk = (m___0->xxh)->chn * (m___0->xxh)->pat;
#line 442
  snprintf((char */* __restrict  */)(m___0->type), (size_t )64, (char const   */* __restrict  */)"%s (%s)",
           magic, tracker);
  }
  {
#line 443
  while (1) {
    while_continue___13: /* CIL Label */ ;
#line 443
    if (m___0->verbosity) {
#line 443
      if (m___0->name[0]) {
        {
#line 443
        report((char *)"Module title   : %s\n", m___0->name);
        }
      }
#line 443
      if (m___0->type[0]) {
        {
#line 443
        report((char *)"Module type    : %s\n", m___0->type);
        }
      }
#line 443
      if (m___0->author[0]) {
        {
#line 443
        report((char *)"Author name    : %s\n", m___0->author);
        }
      }
#line 443
      if ((m___0->xxh)->len) {
        {
#line 443
        report((char *)"Module length  : %d patterns\n", (m___0->xxh)->len);
        }
      }
    }
#line 443
    goto while_break___13;
  }
  while_break___13: /* CIL Label */ ;
  }
#line 445
  if (m___0->verbosity > 1) {
    {
#line 446
    report((char *)"     Instrument name        Len  LBeg LEnd L Vol Fin\n");
#line 448
    i___3 = 0;
    }
    {
#line 448
    while (1) {
      while_continue___14: /* CIL Label */ ;
#line 448
      if (! (i___3 < (m___0->xxh)->ins)) {
#line 448
        goto while_break___14;
      }
#line 449
      if (m___0->verbosity > 1) {
#line 449
        if ((m___0->xxih + i___3)->name[0]) {
#line 449
          goto _L___3;
        } else
#line 449
        if ((m___0->xxs + i___3)->len > 2) {
          _L___3: /* CIL Label */ 
#line 450
          if (ptkloop) {
#line 450
            if ((m___0->xxs + i___3)->lps == 0) {
#line 450
              if ((int )mh.ins[i___3].loop_size > 1) {
#line 450
                if ((m___0->xxs + i___3)->len > (m___0->xxs + i___3)->lpe) {
#line 450
                  tmp___30 = '!';
                } else {
#line 450
                  tmp___30 = ' ';
                }
              } else {
#line 450
                tmp___30 = ' ';
              }
            } else {
#line 450
              tmp___30 = ' ';
            }
          } else {
#line 450
            tmp___30 = ' ';
          }
#line 450
          if ((int )mh.ins[i___3].loop_size > 1) {
#line 450
            if ((m___0->xxs + i___3)->lpe > 8) {
#line 450
              tmp___31 = 'L';
            } else {
#line 450
              tmp___31 = ' ';
            }
          } else {
#line 450
            tmp___31 = ' ';
          }
          {
#line 450
          report((char *)"[%2X] %-22.22s %04x %04x %04x %c V%02x %+d %c\n", i___3,
                 (m___0->xxih + i___3)->name, (m___0->xxs + i___3)->len, (m___0->xxs + i___3)->lps,
                 (m___0->xxs + i___3)->lpe, tmp___31, (*(m___0->xxi + i___3) + 0)->vol,
                 (*(m___0->xxi + i___3) + 0)->fin >> 4, tmp___30);
          }
        }
      }
#line 448
      i___3 ++;
    }
    while_break___14: /* CIL Label */ ;
    }
  }
  {
#line 462
  while (1) {
    while_continue___15: /* CIL Label */ ;
    {
#line 462
    tmp___32 = calloc((size_t )sizeof(struct xxm_track *), (size_t )(m___0->xxh)->trk);
#line 462
    m___0->xxt = (struct xxm_track **)tmp___32;
#line 462
    tmp___33 = calloc((size_t )sizeof(struct xxm_pattern *), (size_t )((m___0->xxh)->pat + 1));
#line 462
    m___0->xxp = (struct xxm_pattern **)tmp___33;
    }
#line 462
    goto while_break___15;
  }
  while_break___15: /* CIL Label */ ;
  }
  {
#line 465
  reportv(ctx___0, 0, (char *)"Stored patterns: %d ", (m___0->xxh)->pat);
#line 467
  i___3 = 0;
  }
  {
#line 467
  while (1) {
    while_continue___16: /* CIL Label */ ;
#line 467
    if (! (i___3 < (m___0->xxh)->pat)) {
#line 467
      goto while_break___16;
    }
    {
#line 468
    while (1) {
      while_continue___17: /* CIL Label */ ;
      {
#line 468
      tmp___34 = calloc((size_t )1, (size_t )(sizeof(struct xxm_pattern ) + sizeof(struct xxm_trackinfo ) * (unsigned long )((m___0->xxh)->chn - 1)));
#line 468
      *(m___0->xxp + i___3) = (struct xxm_pattern *)tmp___34;
      }
#line 468
      goto while_break___17;
    }
    while_break___17: /* CIL Label */ ;
    }
#line 469
    (*(m___0->xxp + i___3))->rows = 64;
    {
#line 470
    while (1) {
      while_continue___18: /* CIL Label */ ;
#line 470
      j___0 = 0;
      {
#line 470
      while (1) {
        while_continue___19: /* CIL Label */ ;
#line 470
        if (! (j___0 < (m___0->xxh)->chn)) {
#line 470
          goto while_break___19;
        }
        {
#line 470
        (*(m___0->xxp + i___3))->info[j___0].index = i___3 * (m___0->xxh)->chn + j___0;
#line 470
        tmp___35 = calloc((size_t )(sizeof(struct xxm_track ) + sizeof(struct xxm_event ) * (unsigned long )(*(m___0->xxp + i___3))->rows),
                          (size_t )1);
#line 470
        *(m___0->xxt + (i___3 * (m___0->xxh)->chn + j___0)) = (struct xxm_track *)tmp___35;
#line 470
        (*(m___0->xxt + (i___3 * (m___0->xxh)->chn + j___0)))->rows = (*(m___0->xxp + i___3))->rows;
#line 470
        j___0 ++;
        }
      }
      while_break___19: /* CIL Label */ ;
      }
#line 470
      goto while_break___18;
    }
    while_break___18: /* CIL Label */ ;
    }
#line 471
    j = 0;
    {
#line 471
    while (1) {
      while_continue___20: /* CIL Label */ ;
#line 471
      if (! (j < 64 * (m___0->xxh)->chn)) {
#line 471
        goto while_break___20;
      }
      {
#line 472
      event = & (*(m___0->xxt + (*(m___0->xxp + i___3))->info[j % (m___0->xxh)->chn].index))->event[j / (m___0->xxh)->chn];
#line 473
      fread((void */* __restrict  */)(mod_event), (size_t )1, (size_t )4, (FILE */* __restrict  */)f);
#line 475
      cvt_pt_event(event, mod_event);
#line 471
      j ++;
      }
    }
    while_break___20: /* CIL Label */ ;
    }
    {
#line 477
    reportv(ctx___0, 0, (char *)".");
#line 467
    i___3 ++;
    }
  }
  while_break___16: /* CIL Label */ ;
  }
#line 481
  if (o___0->skipsmp) {
#line 482
    return (0);
  }
  {
#line 486
  x = strrchr((char const   *)m___0->filename, '/');
  }
#line 486
  if (x) {
    {
#line 487
    *x = (char)0;
#line 488
    strcpy((char */* __restrict  */)(pathname), (char const   */* __restrict  */)m___0->filename);
#line 489
    strcat((char */* __restrict  */)(pathname), (char const   */* __restrict  */)"/");
#line 490
    *x = (char )'/';
    }
  }
  {
#line 493
  reportv(ctx___0, 0, (char *)"\nStored samples : %d ", (m___0->xxh)->smp);
#line 495
  i___3 = 0;
  }
  {
#line 495
  while (1) {
    while_continue___21: /* CIL Label */ ;
#line 495
    if (! (i___3 < (m___0->xxh)->smp)) {
#line 495
      goto while_break___21;
    }
#line 496
    if (! (m___0->xxs + i___3)->len) {
#line 497
      goto __Cont;
    }
#line 499
    if ((m___0->xxs + i___3)->flg & 4) {
#line 500
      if (ptkloop) {
#line 500
        if ((m___0->xxs + i___3)->lps == 0) {
#line 500
          if ((m___0->xxs + i___3)->len > (m___0->xxs + i___3)->lpe) {
#line 501
            (m___0->xxs + i___3)->flg |= 128;
          }
        }
      }
    }
#line 504
    if (ptsong) {
      {
#line 507
      snprintf((char */* __restrict  */)(sn), (size_t )64, (char const   */* __restrict  */)"%s%s",
               pathname, (m___0->xxih + i___3)->name);
#line 509
      s = fopen((char const   */* __restrict  */)(sn), (char const   */* __restrict  */)"rb");
      }
#line 509
      if (s) {
        {
#line 510
        xmp_drv_loadpatch(ctx___0, s, (*(m___0->xxi + i___3) + 0)->sid, m___0->c4rate,
                          0, m___0->xxs + (*(m___0->xxi + i___3) + 0)->sid, (char *)((void *)0));
#line 512
        reportv(ctx___0, 0, (char *)".");
        }
      }
    } else {
      {
#line 515
      xmp_drv_loadpatch(ctx___0, f, (*(m___0->xxi + i___3) + 0)->sid, m___0->c4rate,
                        0, m___0->xxs + (*(m___0->xxi + i___3) + 0)->sid, (char *)((void *)0));
#line 517
      reportv(ctx___0, 0, (char *)".");
      }
    }
    __Cont: /* CIL Label */ 
#line 495
    i___3 ++;
  }
  while_break___21: /* CIL Label */ ;
  }
  {
#line 520
  reportv(ctx___0, 0, (char *)"\n");
  }
#line 522
  if ((m___0->xxh)->chn > 4) {
#line 523
    (m___0->xxh)->flg &= -3;
#line 524
    m___0->quirk |= ((1 << 8) | (1 << 7)) | (1 << 9);
  }
#line 527
  return (0);
}
}
#line 31 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/xm_load.c"
static int xm_test(FILE *f , char *t , int const   start ) ;
#line 32
static int xm_load(struct xmp_context *ctx___0 , FILE *f , int const   start ) ;
#line 34 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/xm_load.c"
struct xmp_loader_info xm_loader  =    {(char *)"XM", (char *)"Fast Tracker II", & xm_test, & xm_load, 0, {(struct list_head *)0,
                                                                       (struct list_head *)0}};
#line 41 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/xm_load.c"
static int xm_test(FILE *f , char *t , int const   start ) 
{ 
  char buf___1[20] ;
  int tmp ;
  void *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
  {
#line 45
  fread((void */* __restrict  */)(buf___1), (size_t )17, (size_t )1, (FILE */* __restrict  */)f);
#line 46
  tmp = memcmp((void const   *)(buf___1), (void const   *)"Extended Module: ", (size_t )17);
  }
#line 46
  if (tmp) {
#line 47
    return (-1);
  }
  {
#line 49
  read_title(f, t, 20);
  }
#line 51
  return (0);
}
}
#line 54 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/xm_load.c"
static int xm_load(struct xmp_context *ctx___0 , FILE *f , int const   start ) 
{ 
  struct xmp_player_context *p ;
  struct xmp_mod_context *m___0 ;
  int i___3 ;
  int j ;
  int r ;
  int sample_num ;
  uint8 *patbuf ;
  uint8 *pat___0 ;
  uint8 b___1 ;
  struct xxm_event *event ;
  struct xm_file_header xfh ;
  struct xm_pattern_header xph ;
  struct xm_instrument_header xih ;
  struct xm_instrument___0 xi ;
  struct xm_sample_header xsh[16] ;
  char tracker_name[21] ;
  int fix_loop ;
  uint8 **tmp ;
  int tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  uint16 tmp___4 ;
  uint8 tmp___5 ;
  void *tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int j___0 ;
  void *tmp___9 ;
  void *tmp___10 ;
  uint8 *tmp___11 ;
  uint8 *tmp___12 ;
  uint8 *tmp___13 ;
  uint8 *tmp___14 ;
  uint8 *tmp___15 ;
  uint8 *tmp___16 ;
  uint8 *tmp___17 ;
  uint8 *tmp___18 ;
  uint8 *tmp___19 ;
  uint8 *tmp___20 ;
  void *tmp___21 ;
  void *tmp___22 ;
  void *tmp___23 ;
  void *tmp___24 ;
  void *tmp___25 ;
  void *tmp___26 ;
  void *tmp___27 ;
  void *tmp___28 ;
  void *tmp___29 ;
  int tmp___30 ;
  size_t tmp___31 ;
  void *tmp___32 ;
  void *tmp___33 ;
  void *tmp___34 ;
  int tmp___35 ;
  int tmp___36 ;
  int tmp___37 ;
  int tmp___38 ;
  int tmp___39 ;
  char const   *tmp___40 ;
  size_t tmp___41 ;
  void *tmp___42 ;
  void *__cil_tmp66 ;
  void *__cil_tmp67 ;
  void *__cil_tmp68 ;
  void *__cil_tmp69 ;
  void *__cil_tmp70 ;
  void *__cil_tmp71 ;
  void *__cil_tmp72 ;
  void *__cil_tmp73 ;
  void *__cil_tmp74 ;
  void *__cil_tmp75 ;
  void *__cil_tmp76 ;
  void *__cil_tmp77 ;
  void *__cil_tmp78 ;
  int __cil_tmp79 ;
  void *__cil_tmp80 ;
  void *__cil_tmp81 ;
  void *__cil_tmp82 ;
  char *__cil_tmp83 ;
  char *__cil_tmp84 ;
  char *__cil_tmp85 ;
  char *__cil_tmp86 ;
  char *__cil_tmp87 ;
  char *__cil_tmp88 ;
  char *__cil_tmp89 ;
  char *__cil_tmp90 ;
  char *__cil_tmp91 ;
  char *__cil_tmp92 ;
  char *__cil_tmp93 ;
  char *__cil_tmp94 ;
  char *__cil_tmp95 ;
  char *__cil_tmp96 ;
  char *__cil_tmp97 ;
  char *__cil_tmp98 ;
  char *__cil_tmp99 ;
  char *__cil_tmp100 ;
  char *__cil_tmp101 ;
  char *__cil_tmp102 ;
  char *__cil_tmp103 ;
  char *__cil_tmp104 ;
  char *__cil_tmp105 ;
  char *__cil_tmp106 ;
  char *__cil_tmp107 ;
  char *__cil_tmp108 ;
  char *__cil_tmp109 ;
  char *__cil_tmp110 ;
  char *__cil_tmp111 ;
  char *__cil_tmp112 ;

  {
#line 56
  p = & ctx___0->p;
#line 57
  m___0 = & p->m;
#line 59
  sample_num = 0;
#line 68
  fix_loop = 0;
  {
#line 70
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 70
    fseek(f, (long )start, 0);
#line 70
    tmp = (uint8 **)((void *)0);
#line 70
    m___0->med_wav_table = tmp;
#line 70
    m___0->med_vol_table = tmp;
#line 70
    set_xxh_defaults(m___0->xxh);
    }
#line 70
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 72
  fread((void */* __restrict  */)(& xfh.id), (size_t )17, (size_t )1, (FILE */* __restrict  */)f);
#line 73
  fread((void */* __restrict  */)(& xfh.name), (size_t )20, (size_t )1, (FILE */* __restrict  */)f);
#line 74
  read8(f);
#line 75
  fread((void */* __restrict  */)(& xfh.tracker), (size_t )20, (size_t )1, (FILE */* __restrict  */)f);
#line 76
  xfh.version = read16l(f);
#line 77
  xfh.headersz = read32l(f);
#line 78
  xfh.songlen = read16l(f);
#line 79
  xfh.restart = read16l(f);
#line 80
  xfh.channels = read16l(f);
#line 81
  xfh.patterns = read16l(f);
#line 82
  xfh.instruments = read16l(f);
#line 83
  xfh.flags = read16l(f);
#line 84
  xfh.tempo = read16l(f);
#line 85
  xfh.bpm = read16l(f);
#line 86
  fread((void */* __restrict  */)(& xfh.order), (size_t )256, (size_t )1, (FILE */* __restrict  */)f);
#line 88
  strncpy((char */* __restrict  */)(m___0->name), (char const   */* __restrict  */)((char *)(xfh.name)),
          (size_t )20);
#line 90
  (m___0->xxh)->len = (int )xfh.songlen;
#line 91
  (m___0->xxh)->rst = (int )xfh.restart;
#line 92
  (m___0->xxh)->chn = (int )xfh.channels;
#line 93
  (m___0->xxh)->pat = (int )xfh.patterns;
#line 94
  (m___0->xxh)->trk = (m___0->xxh)->chn * (m___0->xxh)->pat + 1;
#line 95
  (m___0->xxh)->ins = (int )xfh.instruments;
#line 96
  (m___0->xxh)->tpo = (int )xfh.tempo;
#line 97
  (m___0->xxh)->bpm = (int )xfh.bpm;
  }
#line 98
  if ((int )xfh.flags & 1) {
#line 98
    (m___0->xxh)->flg = 1;
  } else {
#line 98
    (m___0->xxh)->flg = 0;
  }
  {
#line 99
  memcpy((void */* __restrict  */)(m___0->xxo), (void const   */* __restrict  */)(xfh.order),
         (size_t )(m___0->xxh)->len);
#line 100
  tracker_name[20] = (char)0;
#line 101
  snprintf((char */* __restrict  */)(tracker_name), (size_t )20, (char const   */* __restrict  */)"%-20.20s",
           xfh.tracker);
#line 102
  i___3 = 20;
  }
  {
#line 102
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 102
    if (! (i___3 >= 0)) {
#line 102
      goto while_break___0;
    }
#line 103
    if ((int )tracker_name[i___3] == 32) {
#line 104
      tracker_name[i___3] = (char)0;
    }
#line 105
    if (tracker_name[i___3]) {
#line 106
      goto while_break___0;
    }
#line 102
    i___3 --;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 109
  if (xfh.headersz == 275U) {
    {
#line 110
    strcpy((char */* __restrict  */)(tracker_name), (char const   */* __restrict  */)"unknown tracker");
    }
  } else
#line 111
  if ((int )tracker_name[0] == 0) {
    {
#line 112
    strcpy((char */* __restrict  */)(tracker_name), (char const   */* __restrict  */)"Digitrakker");
#line 113
    fix_loop = 1;
    }
  }
  {
#line 117
  tmp___0 = strncmp((char const   *)(tracker_name), "MED2XM by J.Pynnone", (size_t )19);
  }
#line 117
  if (! tmp___0) {
#line 118
    if ((m___0->xxh)->bpm <= 10) {
#line 119
      (m___0->xxh)->bpm = (125 * (53 - (m___0->xxh)->bpm * 2)) / 33;
    }
  }
  {
#line 121
  tmp___1 = strncmp((char const   *)(tracker_name), "FastTracker v 2.00", (size_t )18);
  }
#line 121
  if (! tmp___1) {
    {
#line 122
    strcpy((char */* __restrict  */)(tracker_name), (char const   */* __restrict  */)"old ModPlug Tracker");
    }
  }
  {
#line 124
  snprintf((char */* __restrict  */)(m___0->type), (size_t )64, (char const   */* __restrict  */)"XM %d.%02d (%s)",
           (int )xfh.version >> 8, (int )xfh.version & 255, tracker_name);
  }
  {
#line 127
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 127
    if (m___0->verbosity) {
#line 127
      if (m___0->name[0]) {
        {
#line 127
        report((char *)"Module title   : %s\n", m___0->name);
        }
      }
#line 127
      if (m___0->type[0]) {
        {
#line 127
        report((char *)"Module type    : %s\n", m___0->type);
        }
      }
#line 127
      if (m___0->author[0]) {
        {
#line 127
        report((char *)"Author name    : %s\n", m___0->author);
        }
      }
#line 127
      if ((m___0->xxh)->len) {
        {
#line 127
        report((char *)"Module length  : %d patterns\n", (m___0->xxh)->len);
        }
      }
    }
#line 127
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 131
  fseek(f, (long )(((uint32 )start + xfh.headersz) + 60U), 0);
  }
#line 136
  if ((int )xfh.version <= 259) {
#line 137
    goto load_instruments;
  }
  load_patterns: 
  {
#line 140
  while (1) {
    while_continue___2: /* CIL Label */ ;
    {
#line 140
    tmp___2 = calloc((size_t )sizeof(struct xxm_track *), (size_t )(m___0->xxh)->trk);
#line 140
    m___0->xxt = (struct xxm_track **)tmp___2;
#line 140
    tmp___3 = calloc((size_t )sizeof(struct xxm_pattern *), (size_t )((m___0->xxh)->pat + 1));
#line 140
    m___0->xxp = (struct xxm_pattern **)tmp___3;
    }
#line 140
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 142
  reportv(ctx___0, 0, (char *)"Stored patterns: %d ", (m___0->xxh)->pat);
#line 147
  i___3 = 0;
  }
  {
#line 147
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 147
    if (! (i___3 < (m___0->xxh)->pat)) {
#line 147
      goto while_break___3;
    }
    {
#line 148
    xph.length = read32l(f);
#line 149
    xph.packing = read8(f);
    }
#line 150
    if ((int )xfh.version > 258) {
      {
#line 150
      tmp___4 = read16l(f);
#line 150
      xph.rows = tmp___4;
      }
    } else {
      {
#line 150
      tmp___5 = read8(f);
#line 150
      xph.rows = (uint16 )((int )tmp___5 + 1);
      }
    }
    {
#line 151
    xph.datasize = read16l(f);
    }
    {
#line 153
    while (1) {
      while_continue___4: /* CIL Label */ ;
      {
#line 153
      tmp___6 = calloc((size_t )1, (size_t )(sizeof(struct xxm_pattern ) + sizeof(struct xxm_trackinfo ) * (unsigned long )((m___0->xxh)->chn - 1)));
#line 153
      *(m___0->xxp + i___3) = (struct xxm_pattern *)tmp___6;
      }
#line 153
      goto while_break___4;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 154
    tmp___8 = (int )xph.rows;
#line 154
    (*(m___0->xxp + i___3))->rows = tmp___8;
#line 154
    r = tmp___8;
#line 154
    if (! r) {
#line 155
      tmp___7 = 256;
#line 155
      (*(m___0->xxp + i___3))->rows = tmp___7;
#line 155
      r = tmp___7;
    }
    {
#line 156
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 156
      j___0 = 0;
      {
#line 156
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 156
        if (! (j___0 < (m___0->xxh)->chn)) {
#line 156
          goto while_break___6;
        }
        {
#line 156
        (*(m___0->xxp + i___3))->info[j___0].index = i___3 * (m___0->xxh)->chn + j___0;
#line 156
        tmp___9 = calloc((size_t )(sizeof(struct xxm_track ) + sizeof(struct xxm_event ) * (unsigned long )(*(m___0->xxp + i___3))->rows),
                         (size_t )1);
#line 156
        *(m___0->xxt + (i___3 * (m___0->xxh)->chn + j___0)) = (struct xxm_track *)tmp___9;
#line 156
        (*(m___0->xxt + (i___3 * (m___0->xxh)->chn + j___0)))->rows = (*(m___0->xxp + i___3))->rows;
#line 156
        j___0 ++;
        }
      }
      while_break___6: /* CIL Label */ ;
      }
#line 156
      goto while_break___5;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 158
    if (xph.datasize) {
      {
#line 159
      tmp___10 = calloc((size_t )1, (size_t )xph.datasize);
#line 159
      patbuf = (uint8 *)tmp___10;
#line 159
      pat___0 = patbuf;
#line 160
      fread((void */* __restrict  */)patbuf, (size_t )1, (size_t )xph.datasize, (FILE */* __restrict  */)f);
#line 161
      j = 0;
      }
      {
#line 161
      while (1) {
        while_continue___7: /* CIL Label */ ;
#line 161
        if (! (j < (m___0->xxh)->chn * r)) {
#line 161
          goto while_break___7;
        }
#line 162
        if (pat___0 - patbuf >= (long )xph.datasize) {
#line 163
          goto while_break___7;
        }
#line 164
        event = & (*(m___0->xxt + (*(m___0->xxp + i___3))->info[j % (m___0->xxh)->chn].index))->event[j / (m___0->xxh)->chn];
#line 165
        tmp___20 = pat___0;
#line 165
        pat___0 ++;
#line 165
        b___1 = *tmp___20;
#line 165
        if ((int )b___1 & 128) {
#line 166
          if ((int )b___1 & 1) {
#line 167
            tmp___11 = pat___0;
#line 167
            pat___0 ++;
#line 167
            event->note = *tmp___11;
          }
#line 168
          if ((int )b___1 & 2) {
#line 169
            if ((int )*pat___0 & 128) {
#line 170
              goto while_break___7;
            }
#line 171
            tmp___12 = pat___0;
#line 171
            pat___0 ++;
#line 171
            event->ins = *tmp___12;
          }
#line 173
          if ((int )b___1 & 4) {
#line 174
            tmp___13 = pat___0;
#line 174
            pat___0 ++;
#line 174
            event->vol = *tmp___13;
          }
#line 175
          if ((int )b___1 & 8) {
#line 176
            tmp___14 = pat___0;
#line 176
            pat___0 ++;
#line 176
            event->fxt = *tmp___14;
          }
#line 184
          if ((int )b___1 & 16) {
#line 185
            tmp___15 = pat___0;
#line 185
            pat___0 ++;
#line 185
            event->fxp = *tmp___15;
          }
        } else {
#line 187
          event->note = b___1;
#line 188
          tmp___16 = pat___0;
#line 188
          pat___0 ++;
#line 188
          event->ins = *tmp___16;
#line 189
          tmp___17 = pat___0;
#line 189
          pat___0 ++;
#line 189
          event->vol = *tmp___17;
#line 190
          tmp___18 = pat___0;
#line 190
          pat___0 ++;
#line 190
          event->fxt = *tmp___18;
#line 191
          tmp___19 = pat___0;
#line 191
          pat___0 ++;
#line 191
          event->fxp = *tmp___19;
        }
#line 194
        if ((int )event->note == 97) {
#line 195
          event->note = (uint8 )129;
        }
#line 197
        if (! event->vol) {
#line 198
          goto __Cont;
        }
#line 201
        if ((int )event->vol >= 16) {
#line 201
          if ((int )event->vol <= 80) {
#line 202
            event->vol = (uint8 )((int )event->vol - 15);
#line 203
            goto __Cont;
          }
        }
        {
#line 207
        if ((int )event->vol >> 4 == 6) {
#line 207
          goto case_6;
        }
#line 211
        if ((int )event->vol >> 4 == 7) {
#line 211
          goto case_7;
        }
#line 215
        if ((int )event->vol >> 4 == 8) {
#line 215
          goto case_8;
        }
#line 219
        if ((int )event->vol >> 4 == 9) {
#line 219
          goto case_9;
        }
#line 223
        if ((int )event->vol >> 4 == 10) {
#line 223
          goto case_10;
        }
#line 227
        if ((int )event->vol >> 4 == 11) {
#line 227
          goto case_11;
        }
#line 231
        if ((int )event->vol >> 4 == 12) {
#line 231
          goto case_12;
        }
#line 235
        if ((int )event->vol >> 4 == 13) {
#line 235
          goto case_13;
        }
#line 239
        if ((int )event->vol >> 4 == 14) {
#line 239
          goto case_14;
        }
#line 243
        if ((int )event->vol >> 4 == 15) {
#line 243
          goto case_15;
        }
#line 206
        goto switch_break;
        case_6: /* CIL Label */ 
#line 208
        event->f2t = (uint8 )164;
#line 209
        event->f2p = (uint8 )((int )event->vol - 96);
#line 210
        goto switch_break;
        case_7: /* CIL Label */ 
#line 212
        event->f2t = (uint8 )164;
#line 213
        event->f2p = (uint8 )(((int )event->vol - 112) << 4);
#line 214
        goto switch_break;
        case_8: /* CIL Label */ 
#line 216
        event->f2t = (uint8 )14;
#line 217
        event->f2p = (uint8 )((11 << 4) | ((int )event->vol - 128));
#line 218
        goto switch_break;
        case_9: /* CIL Label */ 
#line 220
        event->f2t = (uint8 )14;
#line 221
        event->f2p = (uint8 )((10 << 4) | ((int )event->vol - 144));
#line 222
        goto switch_break;
        case_10: /* CIL Label */ 
#line 224
        event->f2t = (uint8 )4;
#line 225
        event->f2p = (uint8 )(((int )event->vol - 160) << 4);
#line 226
        goto switch_break;
        case_11: /* CIL Label */ 
#line 228
        event->f2t = (uint8 )4;
#line 229
        event->f2p = (uint8 )((int )event->vol - 176);
#line 230
        goto switch_break;
        case_12: /* CIL Label */ 
#line 232
        event->f2t = (uint8 )8;
#line 233
        event->f2p = (uint8 )((((int )event->vol - 192) << 4) + 8);
#line 234
        goto switch_break;
        case_13: /* CIL Label */ 
#line 236
        event->f2t = (uint8 )25;
#line 237
        event->f2p = (uint8 )(((int )event->vol - 208) << 4);
#line 238
        goto switch_break;
        case_14: /* CIL Label */ 
#line 240
        event->f2t = (uint8 )25;
#line 241
        event->f2p = (uint8 )((int )event->vol - 224);
#line 242
        goto switch_break;
        case_15: /* CIL Label */ 
#line 244
        event->f2t = (uint8 )3;
#line 245
        event->f2p = (uint8 )(((int )event->vol - 240) << 4);
#line 246
        goto switch_break;
        switch_break: /* CIL Label */ ;
        }
#line 248
        event->vol = (uint8 )0;
        __Cont: /* CIL Label */ 
#line 161
        j ++;
      }
      while_break___7: /* CIL Label */ ;
      }
      {
#line 250
      free((void *)patbuf);
      }
#line 251
      if (m___0->verbosity > 0) {
        {
#line 252
        report((char *)".");
        }
      }
    }
#line 147
    i___3 ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 257
  while (1) {
    while_continue___8: /* CIL Label */ ;
    {
#line 257
    tmp___21 = calloc((size_t )1, (size_t )(sizeof(struct xxm_pattern ) + sizeof(struct xxm_trackinfo ) * (unsigned long )((m___0->xxh)->chn - 1)));
#line 257
    *(m___0->xxp + i___3) = (struct xxm_pattern *)tmp___21;
    }
#line 257
    goto while_break___8;
  }
  while_break___8: /* CIL Label */ ;
  }
  {
#line 259
  (*(m___0->xxp + i___3))->rows = 64;
#line 260
  tmp___22 = calloc((size_t )1, (size_t )(sizeof(struct xxm_track ) + sizeof(struct xxm_event ) * 64UL));
#line 260
  *(m___0->xxt + i___3 * (m___0->xxh)->chn) = (struct xxm_track *)tmp___22;
#line 262
  (*(m___0->xxt + i___3 * (m___0->xxh)->chn))->rows = 64;
#line 263
  j = 0;
  }
  {
#line 263
  while (1) {
    while_continue___9: /* CIL Label */ ;
#line 263
    if (! (j < (m___0->xxh)->chn)) {
#line 263
      goto while_break___9;
    }
#line 264
    (*(m___0->xxp + i___3))->info[j].index = i___3 * (m___0->xxh)->chn;
#line 263
    j ++;
  }
  while_break___9: /* CIL Label */ ;
  }
#line 265
  ((m___0->xxh)->pat) ++;
#line 267
  if ((int )xfh.version <= 259) {
    {
#line 268
    reportv(ctx___0, 0, (char *)"\n");
    }
#line 269
    goto load_samples;
  }
  {
#line 271
  reportv(ctx___0, 0, (char *)"\n");
  }
  load_instruments: 
  {
#line 274
  reportv(ctx___0, 0, (char *)"Instruments    : %d ", (m___0->xxh)->ins);
#line 275
  reportv(ctx___0, 1, (char *)"\n     Instrument name            Smp Size   LStart LEnd   L Vol Fine  Pan Xpo\n");
#line 278
  (m___0->xxh)->smp = 1024;
  }
  {
#line 280
  while (1) {
    while_continue___10: /* CIL Label */ ;
    {
#line 280
    tmp___23 = calloc((size_t )sizeof(struct xxm_instrument_header ), (size_t )(m___0->xxh)->ins);
#line 280
    m___0->xxih = (struct xxm_instrument_header *)tmp___23;
#line 280
    tmp___24 = calloc((size_t )sizeof(struct xxm_instrument_map ), (size_t )(m___0->xxh)->ins);
#line 280
    m___0->xxim = (struct xxm_instrument_map *)tmp___24;
#line 280
    tmp___25 = calloc((size_t )sizeof(struct xxm_instrument *), (size_t )(m___0->xxh)->ins);
#line 280
    m___0->xxi = (struct xxm_instrument **)tmp___25;
    }
#line 280
    if ((m___0->xxh)->smp) {
      {
#line 280
      tmp___26 = calloc((size_t )sizeof(struct xxm_sample ), (size_t )(m___0->xxh)->smp);
#line 280
      m___0->xxs = (struct xxm_sample *)tmp___26;
      }
    }
    {
#line 280
    tmp___27 = calloc((size_t )sizeof(uint16 *), (size_t )(m___0->xxh)->ins);
#line 280
    m___0->xxae = (uint16 **)tmp___27;
#line 280
    tmp___28 = calloc((size_t )sizeof(uint16 *), (size_t )(m___0->xxh)->ins);
#line 280
    m___0->xxpe = (uint16 **)tmp___28;
#line 280
    tmp___29 = calloc((size_t )sizeof(uint16 *), (size_t )(m___0->xxh)->ins);
#line 280
    m___0->xxfe = (uint16 **)tmp___29;
    }
#line 280
    goto while_break___10;
  }
  while_break___10: /* CIL Label */ ;
  }
#line 282
  i___3 = 0;
  {
#line 282
  while (1) {
    while_continue___11: /* CIL Label */ ;
#line 282
    if (! (i___3 < (m___0->xxh)->ins)) {
#line 282
      goto while_break___11;
    }
    {
#line 284
    xih.size = read32l(f);
#line 290
    tmp___30 = feof(f);
    }
#line 290
    if (tmp___30) {
#line 291
      (m___0->xxh)->ins = i___3;
#line 292
      goto while_break___11;
    }
    {
#line 295
    fread((void */* __restrict  */)(& xih.name), (size_t )22, (size_t )1, (FILE */* __restrict  */)f);
#line 296
    xih.type = read8(f);
#line 297
    xih.samples = read16l(f);
#line 298
    xih.sh_size = read32l(f);
    }
#line 301
    if ((int )xih.samples > 16) {
#line 302
      (m___0->xxh)->ins = i___3;
#line 303
      goto while_break___11;
    } else
#line 301
    if ((int )xih.samples > 0) {
#line 301
      if (xih.sh_size > 256U) {
#line 302
        (m___0->xxh)->ins = i___3;
#line 303
        goto while_break___11;
      }
    }
    {
#line 306
    copy_adjust((m___0->xxih + i___3)->name, xih.name, 22);
#line 308
    (m___0->xxih + i___3)->nsm = (int )xih.samples;
    }
#line 309
    if ((m___0->xxih + i___3)->nsm > 16) {
#line 310
      (m___0->xxih + i___3)->nsm = 16;
    }
#line 312
    if (m___0->verbosity > 1) {
      {
#line 312
      tmp___31 = strlen((char const   *)((char *)((m___0->xxih + i___3)->name)));
      }
#line 312
      if (tmp___31) {
        {
#line 313
        report((char *)"[%2X] %-22.22s %2d ", i___3, (m___0->xxih + i___3)->name,
               (m___0->xxih + i___3)->nsm);
        }
      } else
#line 312
      if ((m___0->xxih + i___3)->nsm) {
        {
#line 313
        report((char *)"[%2X] %-22.22s %2d ", i___3, (m___0->xxih + i___3)->name,
               (m___0->xxih + i___3)->nsm);
        }
      }
    }
#line 315
    if ((m___0->xxih + i___3)->nsm) {
      {
#line 316
      tmp___32 = calloc((size_t )sizeof(struct xxm_instrument ), (size_t )(m___0->xxih + i___3)->nsm);
#line 316
      *(m___0->xxi + i___3) = (struct xxm_instrument *)tmp___32;
#line 318
      fread((void */* __restrict  */)(& xi.sample), (size_t )96, (size_t )1, (FILE */* __restrict  */)f);
#line 319
      j = 0;
      }
      {
#line 319
      while (1) {
        while_continue___12: /* CIL Label */ ;
#line 319
        if (! (j < 24)) {
#line 319
          goto while_break___12;
        }
        {
#line 320
        xi.v_env[j] = read16l(f);
#line 319
        j ++;
        }
      }
      while_break___12: /* CIL Label */ ;
      }
#line 321
      j = 0;
      {
#line 321
      while (1) {
        while_continue___13: /* CIL Label */ ;
#line 321
        if (! (j < 24)) {
#line 321
          goto while_break___13;
        }
        {
#line 322
        xi.p_env[j] = read16l(f);
#line 321
        j ++;
        }
      }
      while_break___13: /* CIL Label */ ;
      }
      {
#line 323
      xi.v_pts = read8(f);
#line 324
      xi.p_pts = read8(f);
#line 325
      xi.v_sus = read8(f);
#line 326
      xi.v_start = read8(f);
#line 327
      xi.v_end = read8(f);
#line 328
      xi.p_sus = read8(f);
#line 329
      xi.p_start = read8(f);
#line 330
      xi.p_end = read8(f);
#line 331
      xi.v_type = read8(f);
#line 332
      xi.p_type = read8(f);
#line 333
      xi.y_wave = read8(f);
#line 334
      xi.y_sweep = read8(f);
#line 335
      xi.y_depth = read8(f);
#line 336
      xi.y_rate = read8(f);
#line 337
      xi.v_fade = read16l(f);
#line 340
      fseek(f, (long )(((int )xih.size - 33) - 208), 1);
#line 343
      (m___0->xxih + i___3)->rls = (int )xi.v_fade;
#line 344
      (m___0->xxih + i___3)->aei.npt = (int )xi.v_pts;
#line 345
      (m___0->xxih + i___3)->aei.sus = (int )xi.v_sus;
#line 346
      (m___0->xxih + i___3)->aei.lps = (int )xi.v_start;
#line 347
      (m___0->xxih + i___3)->aei.lpe = (int )xi.v_end;
#line 348
      (m___0->xxih + i___3)->aei.flg = (int )xi.v_type;
#line 349
      (m___0->xxih + i___3)->pei.npt = (int )xi.p_pts;
#line 350
      (m___0->xxih + i___3)->pei.sus = (int )xi.p_sus;
#line 351
      (m___0->xxih + i___3)->pei.lps = (int )xi.p_start;
#line 352
      (m___0->xxih + i___3)->pei.lpe = (int )xi.p_end;
#line 353
      (m___0->xxih + i___3)->pei.flg = (int )xi.p_type;
      }
#line 354
      if ((m___0->xxih + i___3)->aei.npt) {
        {
#line 355
        tmp___33 = calloc((size_t )4, (size_t )(m___0->xxih + i___3)->aei.npt);
#line 355
        *(m___0->xxae + i___3) = (uint16 *)tmp___33;
        }
      } else {
#line 357
        (m___0->xxih + i___3)->aei.flg &= -2;
      }
#line 358
      if ((m___0->xxih + i___3)->pei.npt) {
        {
#line 359
        tmp___34 = calloc((size_t )4, (size_t )(m___0->xxih + i___3)->pei.npt);
#line 359
        *(m___0->xxpe + i___3) = (uint16 *)tmp___34;
        }
      } else {
#line 361
        (m___0->xxih + i___3)->pei.flg &= -2;
      }
      {
#line 362
      memcpy((void */* __restrict  */)*(m___0->xxae + i___3), (void const   */* __restrict  */)(xi.v_env),
             (size_t )((m___0->xxih + i___3)->aei.npt * 4));
#line 363
      memcpy((void */* __restrict  */)*(m___0->xxpe + i___3), (void const   */* __restrict  */)(xi.p_env),
             (size_t )((m___0->xxih + i___3)->pei.npt * 4));
#line 365
      j = 0;
      }
      {
#line 365
      while (1) {
        while_continue___14: /* CIL Label */ ;
#line 365
        if (! (j < 108)) {
#line 365
          goto while_break___14;
        }
#line 366
        (m___0->xxim + i___3)->ins[j] = (uint8 )-1;
#line 365
        j ++;
      }
      while_break___14: /* CIL Label */ ;
      }
      {
#line 368
      memcpy((void */* __restrict  */)(& (m___0->xxim + i___3)->ins), (void const   */* __restrict  */)(xi.sample),
             (size_t )96);
#line 369
      j = 0;
      }
      {
#line 369
      while (1) {
        while_continue___15: /* CIL Label */ ;
#line 369
        if (! (j < 96)) {
#line 369
          goto while_break___15;
        }
#line 370
        if ((int )(m___0->xxim + i___3)->ins[j] >= (m___0->xxih + i___3)->nsm) {
#line 371
          (m___0->xxim + i___3)->ins[j] = (uint8 )1024;
        }
#line 369
        j ++;
      }
      while_break___15: /* CIL Label */ ;
      }
#line 374
      j = 0;
      {
#line 374
      while (1) {
        while_continue___16: /* CIL Label */ ;
#line 374
        if (! (j < (m___0->xxih + i___3)->nsm)) {
#line 374
          goto while_break___16;
        }
        {
#line 375
        xsh[j].length = read32l(f);
#line 376
        xsh[j].loop_start = read32l(f);
#line 377
        xsh[j].loop_length = read32l(f);
#line 378
        xsh[j].volume = read8(f);
#line 379
        xsh[j].finetune = read8s(f);
#line 380
        xsh[j].type = read8(f);
#line 381
        xsh[j].pan = read8(f);
#line 382
        xsh[j].relnote = read8s(f);
#line 383
        xsh[j].reserved = read8(f);
#line 384
        fread((void */* __restrict  */)(& xsh[j].name), (size_t )22, (size_t )1, (FILE */* __restrict  */)f);
#line 386
        (*(m___0->xxi + i___3) + j)->vol = (int )xsh[j].volume;
#line 387
        (*(m___0->xxi + i___3) + j)->pan = (int )xsh[j].pan;
#line 388
        (*(m___0->xxi + i___3) + j)->xpo = (int )xsh[j].relnote;
#line 389
        (*(m___0->xxi + i___3) + j)->fin = (int )xsh[j].finetune;
#line 390
        (*(m___0->xxi + i___3) + j)->vwf = (int )xi.y_wave;
#line 391
        (*(m___0->xxi + i___3) + j)->vde = (int )xi.y_depth;
#line 392
        (*(m___0->xxi + i___3) + j)->vra = (int )xi.y_rate;
#line 393
        (*(m___0->xxi + i___3) + j)->vsw = (int )xi.y_sweep;
#line 394
        (*(m___0->xxi + i___3) + j)->sid = sample_num;
        }
#line 395
        if (sample_num >= 1024) {
#line 396
          goto __Cont___0;
        }
        {
#line 398
        copy_adjust((m___0->xxs + sample_num)->name, xsh[j].name, 22);
#line 400
        (m___0->xxs + sample_num)->len = (int )xsh[j].length;
#line 401
        (m___0->xxs + sample_num)->lps = (int )xsh[j].loop_start;
        }
#line 402
        if (fix_loop) {
#line 402
          if ((m___0->xxs + sample_num)->lps > 0) {
#line 403
            ((m___0->xxs + sample_num)->lps) --;
          }
        }
#line 404
        (m___0->xxs + sample_num)->lpe = (int )(xsh[j].loop_start + xsh[j].loop_length);
#line 405
        if ((int )xsh[j].type & 16) {
#line 405
          (m___0->xxs + sample_num)->flg = 1;
        } else {
#line 405
          (m___0->xxs + sample_num)->flg = 0;
        }
#line 407
        if ((int )xsh[j].type & 1) {
#line 407
          tmp___35 = 4;
        } else {
#line 407
          tmp___35 = 0;
        }
#line 407
        (m___0->xxs + sample_num)->flg |= tmp___35;
#line 409
        if ((int )xsh[j].type & 2) {
#line 409
          tmp___36 = 12;
        } else {
#line 409
          tmp___36 = 0;
        }
#line 409
        (m___0->xxs + sample_num)->flg |= tmp___36;
        __Cont___0: /* CIL Label */ 
#line 374
        j ++;
#line 374
        sample_num ++;
      }
      while_break___16: /* CIL Label */ ;
      }
#line 412
      j = 0;
      {
#line 412
      while (1) {
        while_continue___17: /* CIL Label */ ;
#line 412
        if (! (j < (m___0->xxih + i___3)->nsm)) {
#line 412
          goto while_break___17;
        }
#line 413
        if (sample_num >= 1024) {
#line 414
          goto __Cont___1;
        }
#line 415
        if (m___0->verbosity > 1) {
#line 415
          if (xsh[j].length) {
#line 416
            if ((m___0->xxs + (*(m___0->xxi + i___3) + j)->sid)->flg & 8) {
#line 416
              tmp___38 = 'B';
            } else {
#line 416
              if ((m___0->xxs + (*(m___0->xxi + i___3) + j)->sid)->flg & 4) {
#line 416
                tmp___37 = 'L';
              } else {
#line 416
                tmp___37 = ' ';
              }
#line 416
              tmp___38 = tmp___37;
            }
#line 416
            if ((m___0->xxs + (*(m___0->xxi + i___3) + j)->sid)->flg & 1) {
#line 416
              tmp___39 = '+';
            } else {
#line 416
              tmp___39 = ' ';
            }
#line 416
            if (j) {
#line 416
              tmp___40 = "\n\t\t\t\t";
            } else {
#line 416
              tmp___40 = "\t";
            }
            {
#line 416
            report((char *)"%s[%1x] %06x%c%06x %06x %c V%02x F%+04d P%02x R%+03d",
                   tmp___40, j, (m___0->xxs + (*(m___0->xxi + i___3) + j)->sid)->len,
                   tmp___39, (m___0->xxs + (*(m___0->xxi + i___3) + j)->sid)->lps,
                   (m___0->xxs + (*(m___0->xxi + i___3) + j)->sid)->lpe, tmp___38,
                   (*(m___0->xxi + i___3) + j)->vol, (*(m___0->xxi + i___3) + j)->fin,
                   (*(m___0->xxi + i___3) + j)->pan, (*(m___0->xxi + i___3) + j)->xpo);
            }
          }
        }
#line 428
        if ((int )xfh.version > 259) {
          {
#line 429
          xmp_drv_loadpatch(ctx___0, f, (*(m___0->xxi + i___3) + j)->sid, m___0->c4rate,
                            1, m___0->xxs + (*(m___0->xxi + i___3) + j)->sid, (char *)((void *)0));
          }
        }
        __Cont___1: /* CIL Label */ 
#line 412
        j ++;
      }
      while_break___17: /* CIL Label */ ;
      }
#line 432
      if (m___0->verbosity == 1) {
        {
#line 433
        report((char *)".");
        }
      }
    } else {
      {
#line 454
      fseek(f, (long )((int )xih.size - 33), 1);
      }
    }
#line 457
    if (m___0->verbosity > 1) {
      {
#line 457
      tmp___41 = strlen((char const   *)((char *)((m___0->xxih + i___3)->name)));
      }
#line 457
      if (tmp___41) {
        {
#line 458
        report((char *)"\n");
        }
      } else
#line 457
      if (xih.samples) {
        {
#line 458
        report((char *)"\n");
        }
      }
    }
#line 282
    i___3 ++;
  }
  while_break___11: /* CIL Label */ ;
  }
  {
#line 460
  (m___0->xxh)->smp = sample_num;
#line 461
  tmp___42 = realloc((void *)m___0->xxs, (size_t )(sizeof(struct xxm_sample ) * (unsigned long )(m___0->xxh)->smp));
#line 461
  m___0->xxs = (struct xxm_sample *)tmp___42;
  }
#line 463
  if ((int )xfh.version <= 259) {
#line 464
    if (m___0->verbosity > 0) {
#line 464
      if (m___0->verbosity < 2) {
        {
#line 465
        report((char *)"\n");
        }
      }
    }
#line 466
    goto load_patterns;
  }
  load_samples: 
#line 470
  if (m___0->verbosity > 0) {
#line 470
    if ((int )xfh.version <= 259) {
      {
#line 471
      report((char *)"Stored samples : %d ", (m___0->xxh)->smp);
      }
    } else {
#line 470
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 470
  if (m___0->verbosity > 1) {
    {
#line 471
    report((char *)"Stored samples : %d ", (m___0->xxh)->smp);
    }
  }
#line 475
  if ((int )xfh.version <= 259) {
#line 476
    i___3 = 0;
    {
#line 476
    while (1) {
      while_continue___18: /* CIL Label */ ;
#line 476
      if (! (i___3 < (m___0->xxh)->ins)) {
#line 476
        goto while_break___18;
      }
#line 477
      j = 0;
      {
#line 477
      while (1) {
        while_continue___19: /* CIL Label */ ;
#line 477
        if (! (j < (m___0->xxih + i___3)->nsm)) {
#line 477
          goto while_break___19;
        }
        {
#line 478
        xmp_drv_loadpatch(ctx___0, f, (*(m___0->xxi + i___3) + j)->sid, m___0->c4rate,
                          1, m___0->xxs + (*(m___0->xxi + i___3) + j)->sid, (char *)((void *)0));
#line 480
        reportv(ctx___0, 0, (char *)".");
#line 477
        j ++;
        }
      }
      while_break___19: /* CIL Label */ ;
      }
#line 476
      i___3 ++;
    }
    while_break___18: /* CIL Label */ ;
    }
  }
  {
#line 484
  reportv(ctx___0, 0, (char *)"\n");
#line 490
  i___3 = 0;
  }
  {
#line 490
  while (1) {
    while_continue___20: /* CIL Label */ ;
#line 490
    if (! (i___3 < (m___0->xxh)->chn)) {
#line 490
      goto while_break___20;
    }
#line 491
    if (m___0->flags & (1 << 6)) {
#line 491
      m___0->xxc[i___3].pan = 128;
    } else {
#line 491
      m___0->xxc[i___3].pan = (((i___3 + 1) / 2) % 2) * 255;
    }
#line 490
    i___3 ++;
  }
  while_break___20: /* CIL Label */ ;
  }
#line 494
  m___0->quirk |= ((1 << 8) | (1 << 7)) | (1 << 9);
#line 496
  return (0);
}
}
#line 17 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/asif.c"
int asif_load(struct xmp_context *ctx___0 , FILE *f , int i___3 ) 
{ 
  struct xmp_player_context *p ;
  struct xmp_mod_context *m___0 ;
  int size___0 ;
  int pos___0 ;
  uint32 id ;
  int chunk ;
  int j ;
  uint32 tmp ;
  uint32 tmp___0 ;
  uint32 tmp___1 ;
  uint32 tmp___2 ;
  long tmp___3 ;
  uint8 tmp___4 ;
  uint16 tmp___5 ;
  uint16 tmp___6 ;
  uint16 tmp___7 ;
  uint8 tmp___8 ;

  {
#line 19
  p = & ctx___0->p;
#line 20
  m___0 = & p->m;
#line 26
  if ((unsigned long )f == (unsigned long )((void *)0)) {
#line 27
    return (-1);
  }
  {
#line 29
  tmp = read32b(f);
  }
#line 29
  if (tmp != ((((70U << 24) | (79U << 16)) | (82U << 8)) | 77U)) {
#line 30
    return (-1);
  }
  {
#line 31
  tmp___0 = read32b(f);
#line 31
  size___0 = (int )tmp___0;
#line 33
  tmp___1 = read32b(f);
  }
#line 33
  if (tmp___1 != ((((65U << 24) | (83U << 16)) | (73U << 8)) | 70U)) {
#line 34
    return (-1);
  }
#line 36
  chunk = 0;
  {
#line 36
  while (1) {
    while_continue: /* CIL Label */ ;
#line 36
    if (! (chunk < 2)) {
#line 36
      goto while_break;
    }
    {
#line 37
    id = read32b(f);
#line 38
    tmp___2 = read32b(f);
#line 38
    size___0 = (int )tmp___2;
#line 39
    tmp___3 = ftell(f);
#line 39
    pos___0 = (int )(tmp___3 + (long )size___0);
    }
    {
#line 42
    if (id == ((((87U << 24) | (65U << 16)) | (86U << 8)) | 69U)) {
#line 42
      goto case_exp;
    }
#line 65
    if (id == ((((73U << 24) | (78U << 16)) | (83U << 8)) | 84U)) {
#line 65
      goto case_exp___0;
    }
#line 41
    goto switch_break;
    case_exp: /* CIL Label */ 
    {
#line 45
    tmp___4 = read8(f);
#line 45
    fseek(f, (long )tmp___4, 1);
#line 46
    tmp___5 = read16l(f);
#line 46
    (m___0->xxs + i___3)->len = (int )tmp___5 + 1;
#line 47
    tmp___6 = read16l(f);
#line 47
    size___0 = (int )tmp___6;
#line 52
    j = 0;
    }
    {
#line 52
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 52
      if (! (j < size___0)) {
#line 52
        goto while_break___0;
      }
      {
#line 53
      read16l(f);
#line 54
      tmp___7 = read16l(f);
#line 54
      (m___0->xxs + j)->len = 256 * (int )tmp___7;
#line 55
      read16l(f);
#line 56
      read16l(f);
#line 52
      j ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 59
    xmp_drv_loadpatch(ctx___0, f, i___3, m___0->c4rate, 2, m___0->xxs + i___3, (char *)((void *)0));
#line 62
    chunk ++;
    }
#line 63
    goto switch_break;
    case_exp___0: /* CIL Label */ 
    {
#line 68
    tmp___8 = read8(f);
#line 68
    fseek(f, (long )tmp___8, 1);
#line 70
    read16l(f);
#line 71
    fseek(f, 24L, 1);
#line 72
    read8(f);
#line 73
    read8(f);
#line 74
    read8(f);
#line 75
    read8(f);
#line 76
    read8(f);
#line 77
    read8(f);
#line 79
    (m___0->xxih + i___3)->nsm = 1;
#line 80
    (*(m___0->xxi + i___3) + 0)->vol = 64;
#line 81
    (*(m___0->xxi + i___3) + 0)->pan = 128;
#line 82
    (*(m___0->xxi + i___3) + 0)->sid = i___3;
#line 84
    chunk ++;
    }
    switch_break: /* CIL Label */ ;
    }
    {
#line 87
    fseek(f, (long )pos___0, 0);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 90
  return (0);
}
}
#line 157 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/itsex.c"
static uint8 *sourcebuffer  =    (uint8 *)((void *)0);
#line 158 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/itsex.c"
static uint8 *ibuf  =    (uint8 *)((void *)0);
#line 159 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/itsex.c"
static uint32 bitlen  ;
#line 160 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/itsex.c"
static uint8 bitnum  ;
#line 162 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/itsex.c"
__inline static uint32 readbits(uint8 n___0 ) 
{ 
  uint32 retval ;
  int offset ;
  int m___0 ;
  char *__cil_tmp5 ;

  {
#line 164
  retval = (uint32 )0;
#line 165
  offset = 0;
  {
#line 166
  while (1) {
    while_continue: /* CIL Label */ ;
#line 166
    if (! n___0) {
#line 166
      goto while_break;
    }
#line 167
    m___0 = (int )n___0;
#line 169
    if (! bitlen) {
      {
#line 170
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"readbits: ran out of buffer\n");
      }
#line 171
      return ((uint32 )0);
    }
#line 174
    if (m___0 > (int )bitnum) {
#line 175
      m___0 = (int )bitnum;
    }
#line 176
    retval = (uint32 )((long )retval | (((long )*ibuf & ((1L << m___0) - 1L)) << offset));
#line 177
    *ibuf = (uint8 )((int )*ibuf >> m___0);
#line 178
    n___0 = (uint8 )((int )n___0 - m___0);
#line 179
    offset += m___0;
#line 180
    bitnum = (uint8 )((int )bitnum - m___0);
#line 180
    if (! bitnum) {
#line 181
      bitlen --;
#line 182
      ibuf ++;
#line 183
      bitnum = (uint8 )8;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 186
  return (retval);
}
}
#line 189 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/itsex.c"
static int readblock(FILE *f ) 
{ 
  uint16 size___0 ;
  void *tmp ;
  size_t tmp___0 ;

  {
  {
#line 193
  size___0 = read16l(f);
  }
#line 195
  if (! size___0) {
#line 196
    return (0);
  }
  {
#line 197
  tmp = malloc((size_t )size___0);
#line 197
  sourcebuffer = (uint8 *)tmp;
  }
#line 197
  if (! sourcebuffer) {
#line 198
    return (0);
  }
  {
#line 200
  tmp___0 = fread((void */* __restrict  */)sourcebuffer, (size_t )size___0, (size_t )1,
                  (FILE */* __restrict  */)f);
  }
#line 200
  if (tmp___0 != 1U) {
    {
#line 201
    free((void *)sourcebuffer);
#line 202
    sourcebuffer = (uint8 *)((void *)0);
    }
#line 203
    return (0);
  }
#line 205
  ibuf = sourcebuffer;
#line 206
  bitnum = (uint8 )8;
#line 207
  bitlen = (uint32 )size___0;
#line 208
  return (1);
}
}
#line 211 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/itsex.c"
static int freeblock(void) 
{ 


  {
#line 213
  if (sourcebuffer) {
    {
#line 214
    free((void *)sourcebuffer);
    }
  }
#line 215
  sourcebuffer = (uint8 *)((void *)0);
#line 216
  return (1);
}
}
#line 229 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/itsex.c"
int itsex_decompress8(FILE *module , void *dst , int len , char it215 ) 
{ 
  sbyte *destbuf ;
  word blklen ;
  word blkpos ;
  byte width ;
  word value ;
  sbyte d1 ;
  sbyte d2 ;
  sbyte *destpos ;
  int tmp ;
  sbyte v ;
  uint32 tmp___0 ;
  uint32 tmp___1 ;
  byte border ;
  byte shift ;
  sbyte *tmp___2 ;

  {
#line 240
  destbuf = (sbyte *)dst;
#line 241
  if (! destbuf) {
#line 242
    return (0);
  }
  {
#line 244
  memset((void *)destbuf, 0, (size_t )len);
#line 245
  destpos = destbuf;
  }
  {
#line 248
  while (1) {
    while_continue: /* CIL Label */ ;
#line 248
    if (! len) {
#line 248
      goto while_break;
    }
    {
#line 251
    tmp = readblock(module);
    }
#line 251
    if (! tmp) {
#line 252
      return (0);
    }
#line 253
    if (len < 32768) {
#line 253
      blklen = (word )len;
    } else {
#line 253
      blklen = (word )32768;
    }
#line 254
    blkpos = (word )0;
#line 256
    width = (byte )9;
#line 257
    d2 = (sbyte )0;
#line 257
    d1 = d2;
    {
#line 260
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 260
      if (! ((int )blkpos < (int )blklen)) {
#line 260
        goto while_break___0;
      }
      {
#line 263
      tmp___0 = readbits(width);
#line 263
      value = (word )tmp___0;
      }
#line 265
      if ((int )width < 7) {
#line 266
        if ((int )value == 1 << ((int )width - 1)) {
          {
#line 267
          tmp___1 = readbits((uint8 )3);
#line 267
          value = (word )(tmp___1 + 1U);
          }
#line 268
          if ((int )value < (int )width) {
#line 268
            width = (byte )value;
          } else {
#line 268
            width = (byte )((int )value + 1);
          }
#line 269
          goto while_continue___0;
        }
      } else
#line 271
      if ((int )width < 9) {
#line 272
        border = (byte )((255 >> (9 - (int )width)) - 4);
#line 274
        if ((int )value > (int )border) {
#line 274
          if ((int )value <= (int )border + 8) {
#line 275
            value = (word )((int )value - (int )border);
#line 276
            if ((int )value < (int )width) {
#line 276
              width = (byte )value;
            } else {
#line 276
              width = (byte )((int )value + 1);
            }
#line 277
            goto while_continue___0;
          }
        }
      } else
#line 279
      if ((int )width == 9) {
#line 280
        if ((int )value & 256) {
#line 281
          width = (byte )(((int )value + 1) & 255);
#line 282
          goto while_continue___0;
        }
      } else {
        {
#line 285
        freeblock();
        }
#line 286
        return (0);
      }
#line 291
      if ((int )width < 8) {
#line 292
        shift = (byte )(8 - (int )width);
#line 293
        v = (sbyte )((int )value << (int )shift);
#line 294
        v = (sbyte )((int )v >> (int )shift);
      } else {
#line 296
        v = (sbyte )value;
      }
#line 299
      d1 = (sbyte )((int )d1 + (int )v);
#line 300
      d2 = (sbyte )((int )d2 + (int )d1);
#line 303
      tmp___2 = destpos;
#line 303
      destpos ++;
#line 303
      if (it215) {
#line 303
        *tmp___2 = d2;
      } else {
#line 303
        *tmp___2 = d1;
      }
#line 304
      blkpos = (word )((int )blkpos + 1);
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 309
    freeblock();
#line 310
    len -= (int )blklen;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 313
  return (1);
}
}
#line 321 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/itsex.c"
int itsex_decompress16(FILE *module , void *dst , int len , char it215 ) 
{ 
  sword *destbuf ;
  word blklen ;
  word blkpos ;
  byte width ;
  dword value ;
  sword d1 ;
  sword d2 ;
  sword *destpos ;
  int tmp ;
  sword v ;
  uint32 tmp___0 ;
  word border ;
  byte shift ;
  sword *tmp___1 ;

  {
#line 332
  destbuf = (sword *)dst;
#line 333
  if (! destbuf) {
#line 334
    return (0);
  }
  {
#line 336
  memset((void *)destbuf, 0, (size_t )(len << 1));
#line 337
  destpos = destbuf;
  }
  {
#line 340
  while (1) {
    while_continue: /* CIL Label */ ;
#line 340
    if (! len) {
#line 340
      goto while_break;
    }
    {
#line 344
    tmp = readblock(module);
    }
#line 344
    if (! tmp) {
#line 345
      return (0);
    }
#line 346
    if (len < 16384) {
#line 346
      blklen = (word )len;
    } else {
#line 346
      blklen = (word )16384;
    }
#line 347
    blkpos = (word )0;
#line 349
    width = (byte )17;
#line 350
    d2 = (sword )0;
#line 350
    d1 = d2;
    {
#line 353
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 353
      if (! ((int )blkpos < (int )blklen)) {
#line 353
        goto while_break___0;
      }
      {
#line 356
      value = readbits(width);
      }
#line 358
      if ((int )width < 7) {
#line 359
        if (value == (dword )(1 << ((int )width - 1))) {
          {
#line 360
          tmp___0 = readbits((uint8 )4);
#line 360
          value = tmp___0 + 1U;
          }
#line 361
          if (value < (dword )width) {
#line 361
            width = (byte )value;
          } else {
#line 361
            width = (byte )(value + 1U);
          }
#line 362
          goto while_continue___0;
        }
      } else
#line 364
      if ((int )width < 17) {
#line 365
        border = (word )((65535 >> (17 - (int )width)) - 8);
#line 367
        if (value > (dword )border) {
#line 367
          if (value <= (dword )((int )border + 16)) {
#line 368
            value -= (dword )border;
#line 369
            if (value < (dword )width) {
#line 369
              width = (byte )value;
            } else {
#line 369
              width = (byte )(value + 1U);
            }
#line 370
            goto while_continue___0;
          }
        }
      } else
#line 372
      if ((int )width == 17) {
#line 373
        if (value & 65536U) {
#line 374
          width = (byte )((value + 1U) & 255U);
#line 375
          goto while_continue___0;
        }
      } else {
        {
#line 378
        freeblock();
        }
#line 379
        return (0);
      }
#line 384
      if ((int )width < 16) {
#line 385
        shift = (byte )(16 - (int )width);
#line 386
        v = (sword )(value << (int )shift);
#line 387
        v = (sword )((int )v >> (int )shift);
      } else {
#line 389
        v = (sword )value;
      }
#line 392
      d1 = (sword )((int )d1 + (int )v);
#line 393
      d2 = (sword )((int )d2 + (int )d1);
#line 396
      tmp___1 = destpos;
#line 396
      destpos ++;
#line 396
      if (it215) {
#line 396
        *tmp___1 = d2;
      } else {
#line 396
        *tmp___1 = d1;
      }
#line 397
      blkpos = (word )((int )blkpos + 1);
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 401
    freeblock();
#line 402
    len -= (int )blklen;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 405
  return (1);
}
}
#line 34 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/iff.h"
int iff_process(struct xmp_context *ctx___0 , char *id , long size___0 , FILE *f ) ;
#line 22 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/iff.c"
static struct list_head iff_list  =    {& iff_list, & iff_list};
#line 24 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/iff.c"
static int __id_size  ;
#line 25 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/iff.c"
static int __flags  ;
#line 27 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/iff.c"
void iff_chunk(struct xmp_context *ctx___0 , FILE *f ) 
{ 
  long size___0 ;
  char id[17] ;
  unsigned int tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  uint32 tmp___2 ;
  uint32 tmp___3 ;
  void *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
#line 30
  id[0] = (char )'\000';
#line 30
  tmp = 1U;
  {
#line 30
  while (1) {
    while_continue: /* CIL Label */ ;
#line 30
    if (tmp >= 17U) {
#line 30
      goto while_break;
    }
#line 30
    id[tmp] = (char)0;
#line 30
    tmp ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 32
  tmp___0 = fread((void */* __restrict  */)(id), (size_t )1, (size_t )__id_size, (FILE */* __restrict  */)f);
  }
#line 32
  if (tmp___0 != (size_t )__id_size) {
#line 33
    return;
  }
#line 35
  if (__flags & 16) {
    {
#line 37
    tmp___1 = strncmp((char const   *)(id), "RIFF", (size_t )4);
    }
#line 37
    if (! tmp___1) {
      {
#line 38
      read32b(f);
#line 39
      read32b(f);
#line 40
      fread((void */* __restrict  */)(id), (size_t )1, (size_t )__id_size, (FILE */* __restrict  */)f);
      }
    }
  }
#line 44
  if (__flags & 1) {
    {
#line 44
    tmp___2 = read32l(f);
#line 44
    size___0 = (long )tmp___2;
    }
  } else {
    {
#line 44
    tmp___3 = read32b(f);
#line 44
    size___0 = (long )tmp___3;
    }
  }
#line 46
  if (__flags & 4) {
#line 47
    size___0 = (size___0 + 1L) & -2L;
  }
#line 49
  if (__flags & 8) {
#line 50
    size___0 = (size___0 + 3L) & -4L;
  }
#line 52
  if (__flags & 2) {
#line 53
    size___0 -= (long )(__id_size + 4);
  }
  {
#line 55
  iff_process(ctx___0, id, size___0, f);
  }
#line 56
  return;
}
}
#line 59 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/iff.c"
void iff_register(char *id , void (*loader)(struct xmp_context * , int  , FILE * ) ) 
{ 
  struct iff_info *f ;
  void *tmp ;
  void *__cil_tmp5 ;
  void *__cil_tmp6 ;

  {
  {
#line 63
  __id_size = 4;
#line 64
  __flags = 0;
#line 66
  tmp = malloc((size_t )sizeof(struct iff_info ));
#line 66
  f = (struct iff_info *)tmp;
#line 67
  strcpy((char */* __restrict  */)(f->id), (char const   */* __restrict  */)id);
#line 68
  f->loader = loader;
#line 70
  list_add_tail(& f->list, & iff_list);
  }
#line 71
  return;
}
}
#line 74 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/iff.c"
void iff_release(void) 
{ 
  struct list_head *tmp ;
  struct iff_info *i___3 ;

  {
#line 80
  tmp = iff_list.next;
  {
#line 80
  while (1) {
    while_continue: /* CIL Label */ ;
#line 80
    if (! ((unsigned long )tmp != (unsigned long )(& iff_list))) {
#line 80
      goto while_break;
    }
    {
#line 81
    i___3 = (struct iff_info *)((char *)tmp - (unsigned long )(& ((struct iff_info *)0)->list));
#line 82
    list_del(& i___3->list);
#line 83
    tmp = tmp->next;
#line 84
    free((void *)i___3);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 86
  return;
}
}
#line 89 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/iff.c"
int iff_process(struct xmp_context *ctx___0 , char *id , long size___0 , FILE *f ) 
{ 
  struct list_head *tmp ;
  struct iff_info *i___3 ;
  int pos___0 ;
  long tmp___0 ;
  int tmp___1 ;

  {
  {
#line 95
  tmp___0 = ftell(f);
#line 95
  pos___0 = (int )tmp___0;
#line 97
  tmp = iff_list.next;
  }
  {
#line 97
  while (1) {
    while_continue: /* CIL Label */ ;
#line 97
    if (! ((unsigned long )tmp != (unsigned long )(& iff_list))) {
#line 97
      goto while_break;
    }
#line 98
    i___3 = (struct iff_info *)((char *)tmp - (unsigned long )(& ((struct iff_info *)0)->list));
#line 99
    if (id) {
      {
#line 99
      tmp___1 = strncmp((char const   *)id, (char const   *)(i___3->id), (size_t )__id_size);
      }
#line 99
      if (! tmp___1) {
        {
#line 100
        (*(i___3->loader))(ctx___0, (int )size___0, f);
        }
#line 101
        goto while_break;
      }
    }
#line 97
    tmp = tmp->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 105
  fseek(f, (long )pos___0 + size___0, 0);
  }
#line 107
  return (0);
}
}
#line 113 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/iff.c"
void iff_idsize(int n___0 ) 
{ 


  {
#line 115
  __id_size = n___0;
#line 116
  return;
}
}
#line 118 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/iff.c"
void iff_setflag(int i___3 ) 
{ 


  {
#line 120
  __flags |= i___3;
#line 121
  return;
}
}
#line 29 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/load.h"
uint8 ord_xlat[255]  ;
#line 21 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/common.c"
char *copy_adjust(uint8 *s , uint8 *r , int n___0 ) 
{ 
  int i___3 ;
  size_t tmp ;
  size_t tmp___0 ;
  unsigned short const   **tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;

  {
  {
#line 25
  tmp___0 = strlen((char const   *)((char *)r));
  }
#line 25
  if ((size_t )n___0 > tmp___0) {
    {
#line 26
    tmp = strlen((char const   *)((char *)r));
#line 26
    n___0 = (int )tmp;
    }
  }
  {
#line 28
  memset((void *)s, 0, (size_t )n___0);
#line 29
  strncpy((char */* __restrict  */)((char *)s), (char const   */* __restrict  */)((char *)r),
          (size_t )n___0);
#line 31
  i___3 = 0;
  }
  {
#line 31
  while (1) {
    while_continue: /* CIL Label */ ;
#line 31
    if (! (i___3 < n___0)) {
#line 31
      goto while_break;
    }
    {
#line 32
    tmp___1 = __ctype_b_loc();
    }
#line 32
    if ((int const   )*(*tmp___1 + (int )*(s + i___3)) & 16384) {
#line 32
      if ((int )*(s + i___3) > 127) {
#line 33
        *(s + i___3) = (uint8 )'.';
      }
    } else {
#line 33
      *(s + i___3) = (uint8 )'.';
    }
#line 31
    i___3 ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 36
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 36
    if (*s) {
      {
#line 36
      tmp___3 = strlen((char const   *)((char *)s));
      }
#line 36
      if (! ((int )*(s + (tmp___3 - 1U)) == 32)) {
#line 36
        goto while_break___0;
      }
    } else {
#line 36
      goto while_break___0;
    }
    {
#line 37
    tmp___2 = strlen((char const   *)((char *)s));
#line 37
    *(s + (tmp___2 - 1U)) = (uint8 )0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 39
  return ((char *)s);
}
}
#line 42 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/common.c"
int test_name(uint8 *s , int n___0 ) 
{ 
  int i___3 ;

  {
#line 46
  i___3 = 0;
  {
#line 46
  while (1) {
    while_continue: /* CIL Label */ ;
#line 46
    if (! (i___3 < n___0)) {
#line 46
      goto while_break;
    }
#line 47
    if ((int )*(s + i___3) > 127) {
#line 48
      return (-1);
    }
#line 49
    if ((int )*(s + i___3) > 0) {
#line 49
      if ((int )*(s + i___3) < 32) {
#line 50
        return (-1);
      }
    }
#line 46
    i___3 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 53
  return (0);
}
}
#line 56 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/common.c"
void read_title(FILE *f , char *t , int s ) 
{ 
  uint8 buf___1[64] ;
  void *__cil_tmp5 ;

  {
#line 60
  if ((unsigned long )t == (unsigned long )((void *)0)) {
#line 61
    return;
  }
#line 63
  if (s >= 64) {
#line 64
    s = 63;
  }
  {
#line 66
  memset((void *)t, 0, (size_t )(s + 1));
#line 68
  fread((void */* __restrict  */)(buf___1), (size_t )1, (size_t )s, (FILE */* __restrict  */)f);
#line 69
  buf___1[s] = (uint8 )0;
#line 70
  copy_adjust((uint8 *)t, buf___1, s);
  }
#line 71
  return;
}
}
#line 73 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/common.c"
void set_xxh_defaults(struct xxm_header *xxh ) 
{ 


  {
  {
#line 75
  memset((void *)xxh, 0, (size_t )sizeof(struct xxm_header ));
#line 76
  xxh->gvl = 64;
#line 77
  xxh->tpo = 6;
#line 78
  xxh->bpm = 125;
#line 79
  xxh->chn = 4;
  }
#line 80
  return;
}
}
#line 82 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/common.c"
void cvt_pt_event(struct xxm_event *event , uint8 *mod_event ) 
{ 
  int tmp ;

  {
  {
#line 84
  tmp = period_to_note((((int )*(mod_event + 0) & 15) << 8) + (int )*(mod_event + 1));
#line 84
  event->note = (uint8 )tmp;
#line 85
  event->ins = (uint8 )(((((int )*(mod_event + 0) & 240) >> 4) << 4) | (((int )*(mod_event + 2) & 240) >> 4));
#line 86
  event->fxt = (uint8 )((int )*(mod_event + 2) & 15);
#line 87
  event->fxp = *(mod_event + 3);
#line 89
  disable_continue_fx(event);
  }
#line 90
  return;
}
}
#line 92 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/common.c"
void disable_continue_fx(struct xxm_event *event ) 
{ 


  {
#line 94
  if (! event->fxp) {
    {
#line 96
    if ((int )event->fxt == 5) {
#line 96
      goto case_5;
    }
#line 99
    if ((int )event->fxt == 6) {
#line 99
      goto case_6;
    }
#line 104
    if ((int )event->fxt == 10) {
#line 104
      goto case_10;
    }
#line 104
    if ((int )event->fxt == 2) {
#line 104
      goto case_10;
    }
#line 104
    if ((int )event->fxt == 1) {
#line 104
      goto case_10;
    }
#line 95
    goto switch_break;
    case_5: /* CIL Label */ 
#line 97
    event->fxt = (uint8 )3;
#line 98
    goto switch_break;
    case_6: /* CIL Label */ 
#line 100
    event->fxt = (uint8 )4;
#line 101
    goto switch_break;
    case_10: /* CIL Label */ 
    case_2: /* CIL Label */ 
    case_1: /* CIL Label */ 
#line 105
    event->fxt = (uint8 )0;
    switch_break: /* CIL Label */ ;
    }
  }
#line 108
  return;
}
}
#line 114 "/home/wslee/benchmarks/sound/xmp-3.0.0+20090923/src/loaders/common.c"
void clean_s3m_seq(struct xxm_header *xxh , uint8 *xxo ) 
{ 
  int i___3 ;
  int j ;

  {
#line 120
  j = 0;
#line 120
  i___3 = j;
  {
#line 120
  while (1) {
    while_continue: /* CIL Label */ ;
#line 120
    if (! (i___3 < xxh->len)) {
#line 120
      goto while_break;
    }
    {
#line 121
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 121
      if (! ((int )*(xxo + i___3) == 254)) {
#line 121
        goto while_break___0;
      }
      {
#line 122
      (xxh->len) --;
#line 123
      ord_xlat[j] = (uint8 )i___3;
#line 125
      j ++;
#line 127
      memmove((void *)(xxo + i___3), (void const   *)((xxo + i___3) + 1), (size_t )(xxh->len - i___3));
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 130
    ord_xlat[j] = (uint8 )i___3;
#line 133
    if ((int )*(xxo + i___3) == 255) {
#line 134
      xxh->len = i___3;
#line 135
      goto while_break;
    }
#line 120
    i___3 ++;
#line 120
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 140
  return;
}
}
