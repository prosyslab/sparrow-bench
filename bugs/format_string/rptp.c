/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 211 "/usr/lib/gcc/i486-linux-gnu/4.4.3/include/stddef.h"
typedef unsigned int size_t;
#line 56 "/usr/include/bits/types.h"
typedef long long __quad_t;
#line 141 "/usr/include/bits/types.h"
typedef long __off_t;
#line 142 "/usr/include/bits/types.h"
typedef __quad_t __off64_t;
#line 45 "/usr/include/stdio.h"
struct _IO_FILE;
#line 49 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 180 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 186 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 271 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 135 "/usr/include/bits/types.h"
typedef unsigned int __uid_t;
#line 136 "/usr/include/bits/types.h"
typedef unsigned int __gid_t;
#line 11 "/home/wslee/benchmarks/sound/rplay-3.3.2/lib/tilde.h"
typedef char *CPFunction();
#line 50 "/usr/include/pwd.h"
struct passwd {
   char *pw_name ;
   char *pw_passwd ;
   __uid_t pw_uid ;
   __gid_t pw_gid ;
   char *pw_gecos ;
   char *pw_dir ;
   char *pw_shell ;
};
#line 25 "/home/wslee/benchmarks/sound/rplay-3.3.2/lib/hash.h"
struct hash_entry {
   char const   *hash_string ;
   void *hash_value ;
};
#line 35 "/home/wslee/benchmarks/sound/rplay-3.3.2/lib/hash.h"
struct hash_control {
   struct hash_entry *hash_where ;
   int hash_sizelog ;
   int hash_mask ;
   int hash_full ;
   struct hash_entry *hash_wall ;
   int hash_stat[6] ;
};
#line 149 "/usr/include/bits/types.h"
typedef long __time_t;
#line 151 "/usr/include/bits/types.h"
typedef long __suseconds_t;
#line 180 "/usr/include/bits/types.h"
typedef int __ssize_t;
#line 110 "/usr/include/sys/types.h"
typedef __ssize_t ssize_t;
#line 69 "/usr/include/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 55 "/usr/include/sys/select.h"
typedef long __fd_mask;
#line 67 "/usr/include/sys/select.h"
struct __anonstruct_fd_set_3 {
   __fd_mask __fds_bits[1024 / (8 * (int )sizeof(__fd_mask ))] ;
};
#line 67 "/usr/include/sys/select.h"
typedef struct __anonstruct_fd_set_3 fd_set;
#line 40 "/usr/lib/gcc/i486-linux-gnu/4.4.3/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 102 "/usr/lib/gcc/i486-linux-gnu/4.4.3/include/stdarg.h"
typedef __gnuc_va_list va_list;
#line 45 "/home/wslee/benchmarks/sound/rplay-3.3.2/librplay/async.c"
struct obuf_s {
   struct obuf_s *next ;
   char *data ;
   char *current ;
   int length ;
   void (*callback)() ;
};
#line 45 "/home/wslee/benchmarks/sound/rplay-3.3.2/librplay/async.c"
typedef struct obuf_s obuf;
#line 54 "/home/wslee/benchmarks/sound/rplay-3.3.2/librplay/async.c"
struct ibuf_s {
   struct ibuf_s *next ;
   char *data ;
   char *current ;
   int length ;
};
#line 54 "/home/wslee/benchmarks/sound/rplay-3.3.2/librplay/async.c"
typedef struct ibuf_s ibuf;
#line 62 "/home/wslee/benchmarks/sound/rplay-3.3.2/librplay/async.c"
struct __anonstruct_grp_32 {
   obuf *olist ;
   obuf *otail ;
   ibuf *ilist ;
   ibuf *itail ;
   int writing ;
   int notify_mask ;
   void (*rcallback)() ;
   int rraw ;
   void (*wcallback)() ;
   int wraw ;
};
#line 62 "/home/wslee/benchmarks/sound/rplay-3.3.2/librplay/async.c"
typedef struct __anonstruct_grp_32 grp;
#line 636 "/home/wslee/benchmarks/sound/rplay-3.3.2/librplay/async.c"
struct __anonstruct_events_33 {
   char *event ;
   int mask ;
};
#line 34 "/usr/include/bits/types.h"
typedef unsigned long __u_long;
#line 192 "/usr/include/bits/types.h"
typedef unsigned int __socklen_t;
#line 38 "/usr/include/sys/types.h"
typedef __u_long u_long;
#line 35 "/usr/include/bits/socket.h"
typedef __socklen_t socklen_t;
#line 29 "/usr/include/bits/sockaddr.h"
typedef unsigned short sa_family_t;
#line 174 "/usr/include/bits/socket.h"
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14] ;
};
#line 50 "/usr/include/stdint.h"
typedef unsigned short uint16_t;
#line 52 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 97 "/usr/include/netinet/in.h"
typedef uint16_t in_port_t;
#line 141 "/usr/include/netinet/in.h"
typedef uint32_t in_addr_t;
#line 142 "/usr/include/netinet/in.h"
struct in_addr {
   in_addr_t s_addr ;
};
#line 225 "/usr/include/netinet/in.h"
struct sockaddr_in {
   sa_family_t sin_family ;
   in_port_t sin_port ;
   struct in_addr sin_addr ;
   unsigned char sin_zero[((sizeof(struct sockaddr ) - sizeof(unsigned short )) - sizeof(in_port_t )) - sizeof(struct in_addr )] ;
};
#line 99 "/usr/include/netdb.h"
struct hostent {
   char *h_name ;
   char **h_aliases ;
   int h_addrtype ;
   int h_length ;
   char **h_addr_list ;
};
#line 499 "/home/wslee/benchmarks/sound/rplay-3.3.2/librplay/rptp.c"
struct _list {
   struct _list *next ;
   char *name ;
   char *value ;
};
#line 499 "/home/wslee/benchmarks/sound/rplay-3.3.2/librplay/rptp.c"
typedef struct _list LIST;
#line 76 "/usr/include/time.h"
typedef __time_t time_t;
#line 193 "../include/rplay.h"
struct _rplay_attrs {
   struct _rplay_attrs *next ;
   char *sound ;
   int volume ;
   int count ;
   char *rptp_server ;
   unsigned short rptp_server_port ;
   int rptp_search ;
   unsigned long sample_rate ;
   char *client_data ;
};
#line 193 "../include/rplay.h"
typedef struct _rplay_attrs RPLAY_ATTRS;
#line 208 "../include/rplay.h"
struct _rplay {
   struct _rplay_attrs *attrs ;
   struct _rplay_attrs **attrsp ;
   char *buf ;
   int len ;
   int size ;
   int command ;
   int nsounds ;
   int count ;
   int priority ;
   int random_sound ;
   char *list_name ;
   int id ;
   unsigned long sequence ;
   unsigned short data_size ;
   char *data ;
};
#line 208 "../include/rplay.h"
typedef struct _rplay RPLAY;
#line 256 "/usr/include/netdb.h"
struct servent {
   char *s_name ;
   char **s_aliases ;
   int s_port ;
   char *s_proto ;
};
#line 57 "/usr/include/bits/types.h"
typedef unsigned long long __u_quad_t;
#line 134 "/usr/include/bits/types.h"
typedef __u_quad_t __dev_t;
#line 137 "/usr/include/bits/types.h"
typedef unsigned long __ino_t;
#line 139 "/usr/include/bits/types.h"
typedef unsigned int __mode_t;
#line 140 "/usr/include/bits/types.h"
typedef unsigned int __nlink_t;
#line 164 "/usr/include/bits/types.h"
typedef long __blksize_t;
#line 169 "/usr/include/bits/types.h"
typedef long __blkcnt_t;
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   long tv_nsec ;
};
#line 43 "/usr/include/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   unsigned short __pad1 ;
   __ino_t st_ino ;
   __mode_t st_mode ;
   __nlink_t st_nlink ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   __dev_t st_rdev ;
   unsigned short __pad2 ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   unsigned long __unused4 ;
   unsigned long __unused5 ;
};
#line 77 "./../lib/getopt.h"
struct option {
   char const   *name ;
   int has_arg ;
   int *flag ;
   int val ;
};
#line 41 "/home/wslee/benchmarks/sound/rplay-3.3.2/rptp/rptp.c"
struct __anonstruct_COMMAND_29 {
   char *name ;
   int min_args ;
   int max_args ;
   char *usage ;
   void (*func)(int argc , char **argv ) ;
};
#line 41 "/home/wslee/benchmarks/sound/rplay-3.3.2/rptp/rptp.c"
typedef struct __anonstruct_COMMAND_29 COMMAND;
#line 471 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *malloc(size_t __size )  __attribute__((__malloc__)) ;
#line 485
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__)) realloc)(void *__ptr ,
                                                                                              size_t __size ) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void exit(int __status ) ;
#line 147 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 333
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 34 "/home/wslee/benchmarks/sound/rplay-3.3.2/lib/xmalloc.c"
void *xmalloc(size_t size ) 
{ 
  void *p ;
  void *tmp ;
  char *__cil_tmp4 ;

  {
  {
#line 44
  tmp = malloc(size);
#line 44
  p = tmp;
  }
#line 45
  if ((unsigned long )p == (unsigned long )((void *)0)) {
    {
#line 47
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"xmalloc: Virtual memory exhausted.\n");
#line 48
    exit(1);
    }
  }
#line 50
  return (p);
}
}
#line 54 "/home/wslee/benchmarks/sound/rplay-3.3.2/lib/xmalloc.c"
void *xrealloc(void *oldmem , size_t size ) 
{ 
  void *newmem ;
  void *tmp ;
  void *tmp___0 ;
  char *__cil_tmp6 ;

  {
#line 65
  if (size == 0U) {
#line 67
    size = (size_t )1;
  }
#line 70
  if (oldmem) {
    {
#line 70
    tmp = realloc(oldmem, size);
#line 70
    newmem = tmp;
    }
  } else {
    {
#line 70
    tmp___0 = malloc(size);
#line 70
    newmem = tmp___0;
    }
  }
#line 72
  if (! newmem) {
    {
#line 74
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"xrealloc: Virtual memory exhausted.\n");
#line 75
    exit(1);
    }
  }
#line 78
  return (newmem);
}
}
#line 127 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strcpy)(char * __restrict  __dest ,
                                                                                       char const   * __restrict  __src ) ;
#line 130
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strncpy)(char * __restrict  __dest ,
                                                                                        char const   * __restrict  __src ,
                                                                                        size_t __n ) ;
#line 135
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strcat)(char * __restrict  __dest ,
                                                                                       char const   * __restrict  __src ) ;
#line 145
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) strncmp)(char const   *__s1 ,
                                                                                      char const   *__s2 ,
                                                                                      size_t __n )  __attribute__((__pure__)) ;
#line 397
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1))) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 488 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void free(void *__ptr ) ;
#line 566
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1))) getenv)(char const   *__name ) ;
#line 19 "/home/wslee/benchmarks/sound/rplay-3.3.2/lib/tilde.h"
CPFunction *tilde_expansion_failure_hook ;
#line 24
char **tilde_additional_prefixes ;
#line 29
char **tilde_additional_suffixes ;
#line 32
char *tilde_expand(char *string ) ;
#line 36
char *tilde_expand_word(char *filename ) ;
#line 79 "/usr/include/pwd.h"
extern void endpwent(void) ;
#line 111
extern struct passwd *getpwuid(__uid_t __uid ) ;
#line 117
extern struct passwd *getpwnam(char const   *__name ) ;
#line 49 "/home/wslee/benchmarks/sound/rplay-3.3.2/lib/tilde.c"
#line 67
#line 73 "/home/wslee/benchmarks/sound/rplay-3.3.2/lib/tilde.c"
static char *default_prefixes[3]  = {      (char *)" ~",      (char *)"\t~",      (char *)((void *)0)};
#line 79 "/home/wslee/benchmarks/sound/rplay-3.3.2/lib/tilde.c"
static char *default_suffixes[3]  = {      (char *)" ",      (char *)"\n",      (char *)((void *)0)};
#line 86 "/home/wslee/benchmarks/sound/rplay-3.3.2/lib/tilde.c"
CPFunction *tilde_expansion_failure_hook  =    (CPFunction *)((void *)0);
#line 91 "/home/wslee/benchmarks/sound/rplay-3.3.2/lib/tilde.c"
char **tilde_additional_prefixes  =    default_prefixes;
#line 96 "/home/wslee/benchmarks/sound/rplay-3.3.2/lib/tilde.c"
char **tilde_additional_suffixes  =    default_suffixes;
#line 101 "/home/wslee/benchmarks/sound/rplay-3.3.2/lib/tilde.c"
static int tilde_find_prefix(char *string , int *len ) 
{ 
  register int i ;
  register int j ;
  register int string_len ;
  register char **prefixes ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;

  {
  {
#line 107
  prefixes = tilde_additional_prefixes;
#line 109
  tmp = strlen((char const   *)string);
#line 109
  string_len = (int )tmp;
#line 110
  *len = 0;
  }
#line 112
  if (! *string) {
#line 113
    return (0);
  } else
#line 112
  if ((int )*string == 126) {
#line 113
    return (0);
  }
#line 115
  if (prefixes) {
#line 117
    i = 0;
    {
#line 117
    while (1) {
      while_continue: /* CIL Label */ ;
#line 117
      if (! (i < string_len)) {
#line 117
        goto while_break;
      }
#line 119
      j = 0;
      {
#line 119
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 119
        if (! *(prefixes + j)) {
#line 119
          goto while_break___0;
        }
        {
#line 121
        tmp___1 = strlen((char const   *)*(prefixes + j));
#line 121
        tmp___2 = strncmp((char const   *)(string + i), (char const   *)*(prefixes + j),
                          tmp___1);
        }
#line 121
        if (tmp___2 == 0) {
          {
#line 123
          tmp___0 = strlen((char const   *)*(prefixes + j));
#line 123
          *len = (int )(tmp___0 - 1U);
          }
#line 124
          return (i + *len);
        }
#line 119
        j ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 117
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 129
  return (string_len);
}
}
#line 134 "/home/wslee/benchmarks/sound/rplay-3.3.2/lib/tilde.c"
static int tilde_find_suffix(char *string ) 
{ 
  register int i ;
  register int j ;
  register int string_len ;
  register char **suffixes ;
  size_t tmp ;
  size_t tmp___0 ;
  int tmp___1 ;

  {
  {
#line 139
  suffixes = tilde_additional_suffixes;
#line 141
  tmp = strlen((char const   *)string);
#line 141
  string_len = (int )tmp;
#line 143
  i = 0;
  }
  {
#line 143
  while (1) {
    while_continue: /* CIL Label */ ;
#line 143
    if (! (i < string_len)) {
#line 143
      goto while_break;
    }
#line 145
    if ((int )*(string + i) == 47) {
#line 146
      goto while_break;
    } else
#line 145
    if (! *(string + i)) {
#line 146
      goto while_break;
    }
#line 148
    j = 0;
    {
#line 148
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 148
      if (suffixes) {
#line 148
        if (! *(suffixes + j)) {
#line 148
          goto while_break___0;
        }
      } else {
#line 148
        goto while_break___0;
      }
      {
#line 150
      tmp___0 = strlen((char const   *)*(suffixes + j));
#line 150
      tmp___1 = strncmp((char const   *)(string + i), (char const   *)*(suffixes + j),
                        tmp___0);
      }
#line 150
      if (tmp___1 == 0) {
#line 151
        return (i);
      }
#line 148
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 143
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 154
  return (i);
}
}
#line 158 "/home/wslee/benchmarks/sound/rplay-3.3.2/lib/tilde.c"
char *tilde_expand(char *string ) 
{ 
  char *result ;
  int result_size ;
  int result_index ;
  register int start ;
  register int end ;
  char *tilde_word ;
  char *expansion ;
  int len ;
  char *tmp ;
  char *tmp___0 ;
  size_t tmp___1 ;
  char *tmp___2 ;

  {
#line 165
  result_index = 0;
#line 165
  result_size = result_index;
#line 166
  result = (char *)((void *)0);
  {
#line 169
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 176
    start = tilde_find_prefix(string, & len);
    }
#line 179
    if ((result_index + start) + 1 > result_size) {
      {
#line 180
      result_size += start + 20;
#line 180
      tmp = xrealloc(result, 1 + result_size);
#line 180
      result = tmp;
      }
    }
    {
#line 182
    strncpy((char */* __restrict  */)(result + result_index), (char const   */* __restrict  */)string,
            (size_t )start);
#line 183
    result_index += start;
#line 186
    string += start;
#line 190
    end = tilde_find_suffix(string);
    }
#line 193
    if (! start) {
#line 193
      if (! end) {
#line 194
        goto while_break;
      }
    }
    {
#line 197
    tmp___0 = xmalloc(1 + end);
#line 197
    tilde_word = tmp___0;
#line 198
    strncpy((char */* __restrict  */)tilde_word, (char const   */* __restrict  */)string,
            (size_t )end);
#line 199
    *(tilde_word + end) = (char )'\000';
#line 200
    string += end;
#line 202
    expansion = tilde_expand_word(tilde_word);
#line 203
    free((void *)tilde_word);
#line 205
    tmp___1 = strlen((char const   *)expansion);
#line 205
    len = (int )tmp___1;
    }
#line 206
    if ((result_index + len) + 1 > result_size) {
      {
#line 207
      result_size += len + 20;
#line 207
      tmp___2 = xrealloc(result, 1 + result_size);
#line 207
      result = tmp___2;
      }
    }
    {
#line 209
    strcpy((char */* __restrict  */)(result + result_index), (char const   */* __restrict  */)expansion);
#line 210
    result_index += len;
#line 211
    free((void *)expansion);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 214
  *(result + result_index) = (char )'\000';
#line 216
  return (result);
}
}
#line 243
extern int ( /* missing proto */  getuid)() ;
#line 221 "/home/wslee/benchmarks/sound/rplay-3.3.2/lib/tilde.c"
char *tilde_expand_word(char *filename ) 
{ 
  char *dirname ;
  size_t tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *temp_name ;
  char *temp_home ;
  char *tmp___2 ;
  struct passwd *entry ;
  int tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  char *username ;
  struct passwd *user_entry ;
  int i ;
  size_t tmp___7 ;
  char *expansion ;
  size_t tmp___8 ;
  size_t tmp___9 ;
  size_t tmp___10 ;
  size_t tmp___11 ;
  char *__cil_tmp23 ;

  {
#line 227
  if (filename) {
    {
#line 227
    tmp = strlen((char const   *)filename);
#line 227
    tmp___0 = xmalloc(1U + tmp);
#line 227
    tmp___1 = strcpy((char */* __restrict  */)tmp___0, (char const   */* __restrict  */)filename);
#line 227
    dirname = tmp___1;
    }
  } else {
#line 227
    dirname = (char *)((void *)0);
  }
#line 229
  if (dirname) {
#line 229
    if ((int )*dirname == 126) {
#line 232
      if (! *(dirname + 1)) {
#line 232
        goto _L;
      } else
#line 232
      if ((int )*(dirname + 1) == 47) {
        _L: /* CIL Label */ 
        {
#line 235
        tmp___2 = getenv("HOME");
#line 235
        temp_home = tmp___2;
        }
#line 239
        if (! temp_home) {
          {
#line 243
          tmp___3 = getuid();
#line 243
          entry = getpwuid((__uid_t )tmp___3);
          }
#line 244
          if (entry) {
#line 245
            temp_home = entry->pw_dir;
          }
        }
        {
#line 248
        tmp___4 = strlen((char const   *)(dirname + 1));
        }
#line 248
        if (temp_home) {
          {
#line 248
          tmp___5 = strlen((char const   *)temp_home);
#line 248
          tmp___6 = tmp___5;
          }
        } else {
#line 248
          tmp___6 = (size_t )0;
        }
        {
#line 248
        temp_name = xmalloc((1U + tmp___4) + tmp___6);
#line 250
        *(temp_name + 0) = (char )'\000';
        }
#line 251
        if (temp_home) {
          {
#line 252
          strcpy((char */* __restrict  */)temp_name, (char const   */* __restrict  */)temp_home);
          }
        }
        {
#line 253
        strcat((char */* __restrict  */)temp_name, (char const   */* __restrict  */)(dirname + 1));
#line 254
        free((void *)dirname);
#line 255
        dirname = temp_name;
        }
      } else {
        {
#line 263
        tmp___7 = strlen((char const   *)dirname);
#line 263
        username = xmalloc(tmp___7);
#line 264
        i = 1;
        }
        {
#line 264
        while (1) {
          while_continue: /* CIL Label */ ;
#line 264
          if (*(dirname + i)) {
#line 264
            if (! ((int )*(dirname + i) != 47)) {
#line 264
              goto while_break;
            }
          } else {
#line 264
            goto while_break;
          }
#line 265
          *(username + (i - 1)) = *(dirname + i);
#line 264
          i ++;
        }
        while_break: /* CIL Label */ ;
        }
        {
#line 266
        *(username + (i - 1)) = (char )'\000';
#line 268
        user_entry = getpwnam((char const   *)username);
        }
#line 268
        if ((unsigned long )user_entry == (unsigned long )((struct passwd *)0)) {
#line 273
          if (tilde_expansion_failure_hook) {
            {
#line 277
            expansion = (*tilde_expansion_failure_hook)(username);
            }
#line 279
            if (expansion) {
              {
#line 281
              tmp___8 = strlen((char const   *)expansion);
#line 281
              tmp___9 = strlen((char const   *)(dirname + i));
#line 281
              temp_name = xmalloc((1U + tmp___8) + tmp___9);
#line 283
              strcpy((char */* __restrict  */)temp_name, (char const   */* __restrict  */)expansion);
#line 284
              strcat((char */* __restrict  */)temp_name, (char const   */* __restrict  */)(dirname + i));
#line 285
              free((void *)expansion);
#line 286
              free((void *)dirname);
#line 287
              dirname = temp_name;
              }
            }
          }
        } else {
          {
#line 294
          tmp___10 = strlen((char const   *)user_entry->pw_dir);
#line 294
          tmp___11 = strlen((char const   *)(dirname + i));
#line 294
          temp_name = xmalloc((1U + tmp___10) + tmp___11);
#line 296
          strcpy((char */* __restrict  */)temp_name, (char const   */* __restrict  */)user_entry->pw_dir);
#line 297
          strcat((char */* __restrict  */)temp_name, (char const   */* __restrict  */)(dirname + i));
#line 298
          free((void *)dirname);
#line 299
          dirname = temp_name;
          }
        }
        {
#line 301
        endpwent();
#line 302
        free((void *)username);
        }
      }
    }
  }
#line 305
  return (dirname);
}
}
#line 50 "/home/wslee/benchmarks/sound/rplay-3.3.2/lib/hash.h"
struct hash_control *hash_new(void) ;
#line 51
void hash_die(struct hash_control *handle ) ;
#line 52
void hash_say(struct hash_control *handle , int *buffer , int bufsiz ) ;
#line 54
void *hash_delete(struct hash_control *handle , char const   *string ) ;
#line 56
void *hash_replace(struct hash_control *handle , char const   *string , void *value ) ;
#line 58
char const   *hash_insert(struct hash_control *handle , char const   *string , void *value ) ;
#line 61
char *hash_apply(struct hash_control *handle , char *(*function)(char const   *str ,
                                                                 void *val ) ) ;
#line 64
void *hash_find(struct hash_control *handle , char const   *string ) ;
#line 66
char const   *hash_jam(struct hash_control *handle , char const   *string , void *value ) ;
#line 240 "/home/wslee/benchmarks/sound/rplay-3.3.2/lib/hash.c"
static char hash_found  ;
#line 242
static struct hash_entry *hash_ask(struct hash_control *handle , char const   *string ,
                                   int access ) ;
#line 244
static int hash_code(struct hash_control *handle , char const   *string ) ;
#line 245
static char const   *hash_grow(struct hash_control *handle ) ;
#line 249 "/home/wslee/benchmarks/sound/rplay-3.3.2/lib/hash.c"
struct hash_control *hash_new(void) 
{ 
  struct hash_control *retval ;
  struct hash_entry *room ;
  struct hash_entry *wall ;
  struct hash_entry *entry ;
  int *ip ;
  int *nd ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 259
  tmp = xmalloc((size_t )(sizeof(struct hash_entry ) * (unsigned long )((1 << 11) + 1)));
#line 259
  room = (struct hash_entry *)tmp;
#line 262
  tmp___0 = xmalloc((size_t )sizeof(struct hash_control ));
#line 262
  retval = (struct hash_control *)tmp___0;
#line 264
  nd = retval->hash_stat + 6;
#line 265
  ip = retval->hash_stat;
  }
  {
#line 265
  while (1) {
    while_continue: /* CIL Label */ ;
#line 265
    if (! ((unsigned long )ip < (unsigned long )nd)) {
#line 265
      goto while_break;
    }
#line 266
    *ip = 0;
#line 265
    ip ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 268
  retval->hash_stat[0] = 1 << 11;
#line 269
  retval->hash_mask = (1 << 11) - 1;
#line 270
  retval->hash_sizelog = 11;
#line 272
  retval->hash_where = room;
#line 273
  wall = room + (1 << 11);
#line 273
  retval->hash_wall = wall;
#line 275
  retval->hash_full = (1 << 11) / 2;
#line 276
  entry = room;
  {
#line 276
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 276
    if (! ((unsigned long )entry <= (unsigned long )wall)) {
#line 276
      goto while_break___0;
    }
#line 277
    entry->hash_string = (char const   *)((void *)0);
#line 276
    entry ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 278
  return (retval);
}
}
#line 291 "/home/wslee/benchmarks/sound/rplay-3.3.2/lib/hash.c"
void hash_die(struct hash_control *handle ) 
{ 


  {
  {
#line 295
  free((void *)((char *)handle->hash_where));
#line 296
  free((void *)((char *)handle));
  }
#line 297
  return;
}
}
#line 312 "/home/wslee/benchmarks/sound/rplay-3.3.2/lib/hash.c"
void hash_say(struct hash_control *handle , int *buffer , int bufsiz ) 
{ 
  int *nd ;
  int *ip ;
  int tmp ;
  int *tmp___0 ;

  {
#line 321
  ip = handle->hash_stat;
#line 322
  if (bufsiz - 1 < 6) {
#line 322
    tmp = bufsiz - 1;
  } else {
#line 322
    tmp = 6;
  }
#line 322
  nd = ip + tmp;
#line 323
  if (bufsiz > 0) {
#line 325
    tmp___0 = buffer;
#line 325
    buffer ++;
#line 325
    *tmp___0 = 6;
    {
#line 326
    while (1) {
      while_continue: /* CIL Label */ ;
#line 326
      if (! ((unsigned long )ip < (unsigned long )nd)) {
#line 326
        goto while_break;
      }
#line 328
      *buffer = *ip;
#line 326
      ip ++;
#line 326
      buffer ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 331
  return;
}
}
#line 342 "/home/wslee/benchmarks/sound/rplay-3.3.2/lib/hash.c"
void *hash_delete(struct hash_control *handle , char const   *string ) 
{ 
  void *retval ;
  struct hash_entry *entry ;

  {
  {
#line 351
  entry = hash_ask(handle, string, 1);
  }
#line 352
  if (hash_found) {
#line 354
    retval = entry->hash_value;
#line 355
    entry->hash_string = (char const   *)((void *)1);
#line 356
    (handle->hash_stat[5]) --;
  } else {
#line 366
    retval = (void *)0;
  }
#line 368
  return (retval);
}
}
#line 379 "/home/wslee/benchmarks/sound/rplay-3.3.2/lib/hash.c"
void *hash_replace(struct hash_control *handle , char const   *string , void *value ) 
{ 
  struct hash_entry *entry ;
  char *retval ;

  {
  {
#line 388
  entry = hash_ask(handle, string, 1);
  }
#line 389
  if (hash_found) {
#line 391
    retval = (char *)entry->hash_value;
#line 392
    entry->hash_value = value;
  } else {
#line 396
    retval = (char *)((void *)0);
  }
#line 399
  return ((void *)retval);
}
}
#line 410 "/home/wslee/benchmarks/sound/rplay-3.3.2/lib/hash.c"
char const   *hash_insert(struct hash_control *handle , char const   *string , void *value ) 
{ 
  struct hash_entry *entry ;
  char const   *retval ;
  char *__cil_tmp6 ;

  {
#line 419
  retval = (char const   *)0;
#line 420
  if (handle->hash_stat[5] > handle->hash_full) {
    {
#line 422
    retval = hash_grow(handle);
    }
  }
#line 424
  if (! retval) {
    {
#line 426
    entry = hash_ask(handle, string, 1);
    }
#line 427
    if (hash_found) {
#line 429
      retval = "exists";
    } else {
#line 433
      entry->hash_value = value;
#line 434
      entry->hash_string = string;
#line 435
      (handle->hash_stat[5]) ++;
    }
  }
#line 438
  return (retval);
}
}
#line 455 "/home/wslee/benchmarks/sound/rplay-3.3.2/lib/hash.c"
char const   *hash_jam(struct hash_control *handle , char const   *string , void *value ) 
{ 
  char const   *retval ;
  struct hash_entry *entry ;

  {
#line 464
  retval = (char const   *)0;
#line 465
  if (handle->hash_stat[5] > handle->hash_full) {
    {
#line 467
    retval = hash_grow(handle);
    }
  }
#line 469
  if (! retval) {
    {
#line 471
    entry = hash_ask(handle, string, 1);
    }
#line 472
    if (! hash_found) {
#line 474
      entry->hash_string = string;
#line 475
      (handle->hash_stat[5]) ++;
    }
#line 477
    entry->hash_value = value;
  }
#line 479
  return (retval);
}
}
#line 493 "/home/wslee/benchmarks/sound/rplay-3.3.2/lib/hash.c"
static char const   *hash_grow(struct hash_control *handle ) 
{ 
  struct hash_entry *newwall ;
  struct hash_entry *newwhere ;
  struct hash_entry *newtrack ;
  struct hash_entry *oldtrack ;
  struct hash_entry *oldwhere ;
  struct hash_entry *oldwall ;
  int temp ;
  int newsize ;
  char const   *string ;
  char const   *retval ;
  void *tmp ;
  char *__cil_tmp13 ;

  {
  {
#line 514
  oldwhere = handle->hash_where;
#line 515
  oldwall = handle->hash_wall;
#line 522
  temp = handle->hash_stat[0];
#line 523
  tmp = xmalloc((size_t )((unsigned long )((temp + temp) + 1) * sizeof(struct hash_entry )));
#line 523
  newwhere = (struct hash_entry *)tmp;
  }
#line 523
  if ((unsigned long )newwhere != (unsigned long )((void *)0)) {
#line 529
    retval = (char const   *)0;
#line 535
    handle->hash_mask = (handle->hash_mask + handle->hash_mask) + 1;
#line 536
    handle->hash_stat[0] <<= 1;
#line 537
    newsize = handle->hash_stat[0];
#line 538
    handle->hash_where = newwhere;
#line 539
    handle->hash_full <<= 1;
#line 540
    (handle->hash_sizelog) ++;
#line 541
    handle->hash_stat[5] = 0;
#line 542
    newwall = newwhere + newsize;
#line 542
    handle->hash_wall = newwall;
#line 547
    newtrack = newwhere;
    {
#line 547
    while (1) {
      while_continue: /* CIL Label */ ;
#line 547
      if (! ((unsigned long )newtrack <= (unsigned long )newwall)) {
#line 547
        goto while_break;
      }
#line 549
      newtrack->hash_string = (char const   *)((void *)0);
#line 547
      newtrack ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 555
    handle->hash_stat[5] = 0;
#line 556
    oldtrack = oldwhere;
    {
#line 556
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 556
      if (! ((unsigned long )oldtrack < (unsigned long )oldwall)) {
#line 556
        goto while_break___0;
      }
#line 557
      string = oldtrack->hash_string;
#line 557
      if ((unsigned long )string != (unsigned long )((void *)0)) {
#line 557
        if ((unsigned long )string != (unsigned long )((void *)1)) {
          {
#line 558
          retval = hash_jam(handle, string, oldtrack->hash_value);
          }
#line 558
          if (retval) {
#line 559
            goto while_break___0;
          }
        }
      }
#line 556
      oldtrack ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 567
    if (! retval) {
      {
#line 573
      free((void *)((char *)oldwhere));
      }
    }
  } else {
#line 581
    retval = "no room";
  }
#line 583
  return (retval);
}
}
#line 632 "/home/wslee/benchmarks/sound/rplay-3.3.2/lib/hash.c"
char *hash_apply(struct hash_control *handle , char *(*function)(char const   *str ,
                                                                 void *val ) ) 
{ 
  struct hash_entry *entry ;
  struct hash_entry *wall ;

  {
#line 640
  wall = handle->hash_wall;
#line 641
  entry = handle->hash_where;
  {
#line 641
  while (1) {
    while_continue: /* CIL Label */ ;
#line 641
    if (! ((unsigned long )entry < (unsigned long )wall)) {
#line 641
      goto while_break;
    }
#line 643
    if (entry->hash_string) {
#line 643
      if ((unsigned long )entry->hash_string != (unsigned long )((void *)1)) {
        {
#line 645
        (*function)(entry->hash_string, entry->hash_value);
        }
      }
    }
#line 641
    entry ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 648
  return ((char *)((void *)0));
}
}
#line 657 "/home/wslee/benchmarks/sound/rplay-3.3.2/lib/hash.c"
void *hash_find(struct hash_control *handle , char const   *string ) 
{ 
  struct hash_entry *entry ;

  {
  {
#line 664
  entry = hash_ask(handle, string, 0);
  }
#line 665
  if (hash_found) {
#line 666
    return (entry->hash_value);
  } else {
#line 668
    return ((void *)0);
  }
}
}
#line 680 "/home/wslee/benchmarks/sound/rplay-3.3.2/lib/hash.c"
static struct hash_entry *hash_ask(struct hash_control *handle , char const   *string ,
                                   int access ) 
{ 
  char const   *string1 ;
  char const   *s ;
  int c ;
  struct hash_entry *slot ;
  int collision ;
  int tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;

  {
  {
#line 693
  tmp = hash_code(handle, string);
#line 693
  slot = handle->hash_where + tmp;
#line 695
  (handle->hash_stat[1 + access]) ++;
#line 696
  collision = 0;
#line 697
  hash_found = (char)0;
  }
  {
#line 698
  while (1) {
    while_continue: /* CIL Label */ ;
#line 698
    s = slot->hash_string;
#line 698
    if ((unsigned long )s != (unsigned long )((void *)0)) {
#line 698
      if (! ((unsigned long )s != (unsigned long )((void *)1))) {
#line 698
        goto while_break;
      }
    } else {
#line 698
      goto while_break;
    }
#line 700
    string1 = string;
    {
#line 700
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 702
      tmp___0 = s;
#line 702
      s ++;
#line 702
      c = (int )*tmp___0;
#line 702
      if (c == 0) {
#line 704
        if (! *string1) {
#line 705
          hash_found = (char)1;
        }
#line 706
        goto while_break___0;
      }
#line 708
      tmp___1 = string1;
#line 708
      string1 ++;
#line 708
      if ((int const   )*tmp___1 != (int const   )c) {
#line 709
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 711
    if (hash_found) {
#line 712
      goto while_break;
    }
#line 713
    collision ++;
#line 714
    slot ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 724
  if ((unsigned long )slot == (unsigned long )handle->hash_wall) {
#line 726
    slot = handle->hash_where;
    {
#line 727
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 727
      s = slot->hash_string;
#line 727
      if ((unsigned long )s != (unsigned long )((void *)0)) {
#line 727
        if (! ((unsigned long )s != (unsigned long )((void *)1))) {
#line 727
          goto while_break___1;
        }
      } else {
#line 727
        goto while_break___1;
      }
#line 729
      string1 = string;
      {
#line 729
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 729
        if (! *s) {
#line 729
          goto while_break___2;
        }
#line 731
        if ((int const   )*string1 != (int const   )*s) {
#line 732
          goto while_break___2;
        }
#line 729
        string1 ++;
#line 729
        s ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 734
      if ((int const   )*s == (int const   )*string1) {
#line 736
        hash_found = (char)1;
#line 737
        goto while_break___1;
      }
#line 739
      collision ++;
#line 740
      slot ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 750
  handle->hash_stat[3 + access] += collision;
#line 751
  return (slot);
}
}
#line 760 "/home/wslee/benchmarks/sound/rplay-3.3.2/lib/hash.c"
static int hash_code(struct hash_control *handle , char const   *string ) 
{ 
  long h ;
  long c ;
  int n ;
  char const   *tmp ;

  {
#line 769
  n = handle->hash_sizelog - 3;
#line 770
  h = 0L;
  {
#line 771
  while (1) {
    while_continue: /* CIL Label */ ;
#line 771
    tmp = string;
#line 771
    string ++;
#line 771
    c = (long )*tmp;
#line 771
    if (! (c != 0L)) {
#line 771
      goto while_break;
    }
#line 773
    h += c;
#line 774
    h = ((h << 3) + (h >> n)) + c;
  }
  while_break: /* CIL Label */ ;
  }
#line 776
  return ((int )(h & (long )handle->hash_mask));
}
}
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
#line 109 "/usr/include/sys/select.h"
extern int select(int __nfds , fd_set * __restrict  __readfds , fd_set * __restrict  __writefds ,
                  fd_set * __restrict  __exceptfds , struct timeval * __restrict  __timeout ) ;
#line 356 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int vsprintf(char * __restrict  __s , char const   * __restrict  __format ,
                                                  __gnuc_va_list __arg ) ;
#line 229 "../include/rplay.h"
int rptp_errno ;
#line 276
char *rptp_parse(char *response___0 , char *name ) ;
#line 277
int rptp_async_putline(int rptp_fd___0 , void (*callback)() , char *fmt  , ...) ;
#line 278
int rptp_async_write(int rptp_fd___0 , void (*callback)() , char *ptr , int nbytes ) ;
#line 279
void rptp_async_register(int rptp_fd___0 , int what , void (*callback)() ) ;
#line 280
void rptp_async_notify(int rptp_fd___0 , int mask , void (*callback)() ) ;
#line 281
void rptp_async_process(int rptp_fd___0 , int what ) ;
#line 282
int rptp_main_loop(void) ;
#line 283
void rptp_stop_main_loop(int return_value ) ;
#line 43 "/usr/include/bits/errno.h"
extern  __attribute__((__nothrow__)) int *__errno_location(void)  __attribute__((__const__)) ;
#line 357 "/usr/include/unistd.h"
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 363
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 43 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2))) memcpy)(void * __restrict  __dest ,
                                                                                       void const   * __restrict  __src ,
                                                                                       size_t __n ) ;
#line 94
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1))) memchr)(void const   *__s ,
                                                                                     int __c ,
                                                                                     size_t __n )  __attribute__((__pure__)) ;
#line 142
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) strcmp)(char const   *__s1 ,
                                                                                     char const   *__s2 )  __attribute__((__pure__)) ;
#line 260
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1))) strrchr)(char const   *__s ,
                                                                                      int __c )  __attribute__((__pure__)) ;
#line 77 "/home/wslee/benchmarks/sound/rplay-3.3.2/librplay/async.c"
static grp group[1024]  ;
#line 78 "/home/wslee/benchmarks/sound/rplay-3.3.2/librplay/async.c"
static int looping  ;
#line 79 "/home/wslee/benchmarks/sound/rplay-3.3.2/librplay/async.c"
static int main_loop_return_value  ;
#line 83
static void write_proc(int rptp_fd___0 ) ;
#line 84
static void do_register(int rptp_fd___0 ) ;
#line 85
static void do_unregister(int rptp_fd___0 ) ;
#line 86
static void notify_line(int rptp_fd___0 , char *line___0 ) ;
#line 87
static void read_proc(int rptp_fd___0 ) ;
#line 88
static void process_input(int rptp_fd___0 ) ;
#line 102 "/home/wslee/benchmarks/sound/rplay-3.3.2/librplay/async.c"
int rptp_main_loop(void) 
{ 
  fd_set read_fds ;
  fd_set write_fds ;
  int i ;
  int n ;
  int __d0 ;
  int __d1 ;
  int __d0___0 ;
  int __d1___0 ;
  int *tmp ;

  {
#line 109
  looping = 1;
#line 110
  main_loop_return_value = 0;
  {
#line 111
  while (1) {
    while_continue: /* CIL Label */ ;
#line 111
    if (! looping) {
#line 111
      goto while_break;
    }
    {
#line 113
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 113
      __asm__  volatile   ("cld; rep; "
                           "stosl": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                           "1" (& read_fds.__fds_bits[0]): "memory");
#line 113
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 114
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 114
      __asm__  volatile   ("cld; rep; "
                           "stosl": "=c" (__d0___0), "=D" (__d1___0): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                           "1" (& write_fds.__fds_bits[0]): "memory");
#line 114
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 116
    i = 0;
    {
#line 116
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 116
      if (! (i < 1024)) {
#line 116
        goto while_break___2;
      }
#line 118
      if (group[i].olist) {
#line 119
        write_fds.__fds_bits[i / (8 * (int )sizeof(__fd_mask ))] |= 1L << i % (8 * (int )sizeof(__fd_mask ));
      }
#line 120
      if (group[i].rcallback) {
#line 121
        read_fds.__fds_bits[i / (8 * (int )sizeof(__fd_mask ))] |= 1L << i % (8 * (int )sizeof(__fd_mask ));
      }
#line 116
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 124
    n = select(1024, (fd_set */* __restrict  */)(& read_fds), (fd_set */* __restrict  */)(& write_fds),
               (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)((void *)0));
    }
#line 125
    if (n < 0) {
      {
#line 127
      tmp = __errno_location();
      }
#line 127
      if (*tmp == 4) {
#line 128
        goto while_continue;
      }
#line 129
      return (-1);
    }
#line 132
    i = 0;
    {
#line 132
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 132
      if (i < 1024) {
#line 132
        if (! n) {
#line 132
          goto while_break___3;
        }
      } else {
#line 132
        goto while_break___3;
      }
#line 134
      if ((read_fds.__fds_bits[i / (8 * (int )sizeof(__fd_mask ))] & (1L << i % (8 * (int )sizeof(__fd_mask )))) != 0L) {
#line 136
        n --;
#line 137
        if (group[i].rcallback) {
          {
#line 138
          rptp_async_process(i, 1);
          }
        }
      }
#line 140
      if ((write_fds.__fds_bits[i / (8 * (int )sizeof(__fd_mask ))] & (1L << i % (8 * (int )sizeof(__fd_mask )))) != 0L) {
#line 142
        n --;
#line 143
        if (group[i].writing) {
          {
#line 144
          rptp_async_process(i, 2);
          }
        }
      }
#line 132
      i ++;
    }
    while_break___3: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 148
  return (main_loop_return_value);
}
}
#line 157 "/home/wslee/benchmarks/sound/rplay-3.3.2/librplay/async.c"
void rptp_stop_main_loop(int return_value ) 
{ 


  {
#line 165
  looping = 0;
#line 166
  main_loop_return_value = return_value;
#line 167
  return;
}
}
#line 176 "/home/wslee/benchmarks/sound/rplay-3.3.2/librplay/async.c"
int rptp_async_putline(int rptp_fd___0 , void (*callback)() , char *fmt  , ...) 
{ 
  va_list args ;
  char buf___1[1024] ;
  int tmp___2 ;
  size_t tmp___3 ;
  int tmp___4 ;
  size_t tmp___5 ;
  void *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
  {
#line 188
  __builtin_va_start(args, fmt);
  }
#line 201
  if (rptp_fd___0 < 0) {
#line 203
    rptp_errno = 4;
#line 204
    return (-1);
  } else
#line 201
  if (rptp_fd___0 >= 1024) {
#line 203
    rptp_errno = 4;
#line 204
    return (-1);
  }
  {
#line 207
  rptp_errno = 0;
#line 209
  vsprintf((char */* __restrict  */)(buf___1), (char const   */* __restrict  */)fmt,
           args);
#line 210
  __builtin_va_end(args);
#line 211
  strcat((char */* __restrict  */)(buf___1), (char const   */* __restrict  */)"\r\n");
#line 213
  tmp___3 = strlen((char const   *)(buf___1));
#line 213
  tmp___4 = rptp_async_write(rptp_fd___0, callback, buf___1, (int )tmp___3);
#line 213
  tmp___5 = strlen((char const   *)(buf___1));
  }
#line 213
  if ((size_t )tmp___4 != tmp___5) {
#line 213
    tmp___2 = -1;
  } else {
#line 213
    tmp___2 = 0;
  }
#line 213
  return (tmp___2);
}
}
#line 224 "/home/wslee/benchmarks/sound/rplay-3.3.2/librplay/async.c"
int rptp_async_write(int rptp_fd___0 , void (*callback)() , char *ptr , int nbytes ) 
{ 
  obuf *new ;
  void *tmp ;
  void *tmp___0 ;
  obuf *tmp___1 ;

  {
#line 237
  if (rptp_fd___0 < 0) {
#line 239
    rptp_errno = 4;
#line 240
    return (-1);
  } else
#line 237
  if (rptp_fd___0 >= 1024) {
#line 239
    rptp_errno = 4;
#line 240
    return (-1);
  }
  {
#line 246
  tmp = malloc((size_t )sizeof(obuf ));
#line 246
  new = (obuf *)tmp;
#line 247
  new->next = (struct obuf_s *)((void *)0);
  }
#line 248
  if (nbytes > 0) {
#line 248
    if (ptr) {
      {
#line 250
      tmp___0 = malloc((size_t )nbytes);
#line 250
      new->data = (char *)tmp___0;
#line 251
      memcpy((void */* __restrict  */)new->data, (void const   */* __restrict  */)ptr,
             (size_t )nbytes);
      }
    } else {
#line 255
      new->data = (char *)((void *)0);
    }
  } else {
#line 255
    new->data = (char *)((void *)0);
  }
#line 257
  new->current = new->data;
#line 258
  new->length = nbytes;
#line 259
  new->callback = callback;
#line 264
  if (group[rptp_fd___0].otail) {
#line 266
    (group[rptp_fd___0].otail)->next = new;
#line 267
    group[rptp_fd___0].otail = new;
  } else {
#line 271
    tmp___1 = new;
#line 271
    group[rptp_fd___0].olist = tmp___1;
#line 271
    group[rptp_fd___0].otail = tmp___1;
  }
#line 278
  if (! group[rptp_fd___0].writing) {
    {
#line 280
    do_register(rptp_fd___0);
    }
  }
#line 282
  return (0);
}
}
#line 305 "/home/wslee/benchmarks/sound/rplay-3.3.2/librplay/async.c"
void rptp_async_register(int rptp_fd___0 , int what , void (*callback)() ) 
{ 


  {
#line 315
  if (rptp_fd___0 < 0) {
#line 317
    rptp_errno = 4;
#line 318
    return;
  } else
#line 315
  if (rptp_fd___0 >= 1024) {
#line 317
    rptp_errno = 4;
#line 318
    return;
  }
  {
#line 323
  if (what == 2) {
#line 323
    goto case_2;
  }
#line 328
  if (what == 6) {
#line 328
    goto case_6;
  }
#line 333
  if (what == 1) {
#line 333
    goto case_1;
  }
#line 321
  goto switch_break;
  case_2: /* CIL Label */ 
#line 324
  group[rptp_fd___0].wcallback = callback;
#line 325
  group[rptp_fd___0].wraw = 0;
#line 326
  goto switch_break;
  case_6: /* CIL Label */ 
#line 329
  group[rptp_fd___0].wcallback = callback;
#line 330
  group[rptp_fd___0].wraw = 1;
#line 331
  goto switch_break;
  case_1: /* CIL Label */ 
#line 334
  group[rptp_fd___0].rcallback = callback;
#line 335
  group[rptp_fd___0].rraw = 1;
#line 336
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 338
  return;
}
}
#line 350 "/home/wslee/benchmarks/sound/rplay-3.3.2/librplay/async.c"
void rptp_async_process(int rptp_fd___0 , int what ) 
{ 


  {
#line 359
  if (rptp_fd___0 < 0) {
#line 361
    rptp_errno = 4;
#line 362
    return;
  } else
#line 359
  if (rptp_fd___0 >= 1024) {
#line 361
    rptp_errno = 4;
#line 362
    return;
  }
  {
#line 367
  if (what == 1) {
#line 367
    goto case_1;
  }
#line 374
  if (what == 2) {
#line 374
    goto case_2;
  }
#line 365
  goto switch_break;
  case_1: /* CIL Label */ 
#line 368
  if (group[rptp_fd___0].rraw) {
#line 368
    if (group[rptp_fd___0].rcallback) {
      {
#line 369
      (*(group[rptp_fd___0].rcallback))(rptp_fd___0);
      }
    } else {
      {
#line 371
      read_proc(rptp_fd___0);
      }
    }
  } else {
    {
#line 371
    read_proc(rptp_fd___0);
    }
  }
#line 372
  goto switch_break;
  case_2: /* CIL Label */ 
#line 375
  if (group[rptp_fd___0].wraw) {
#line 375
    if (group[rptp_fd___0].wcallback) {
      {
#line 376
      (*(group[rptp_fd___0].wcallback))(rptp_fd___0);
      }
    } else {
      {
#line 378
      write_proc(rptp_fd___0);
      }
    }
  } else {
    {
#line 378
    write_proc(rptp_fd___0);
    }
  }
#line 379
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 381
  return;
}
}
#line 394 "/home/wslee/benchmarks/sound/rplay-3.3.2/librplay/async.c"
void rptp_async_notify(int rptp_fd___0 , int mask , void (*callback)() ) 
{ 
  char command___0[1024] ;
  char *p ;
  void *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;

  {
  {
#line 407
  strcpy((char */* __restrict  */)(command___0), (char const   */* __restrict  */)"set notify=");
  }
#line 409
  if (mask & (1 << 4)) {
    {
#line 410
    strcat((char */* __restrict  */)(command___0), (char const   */* __restrict  */)"continue,");
    }
  }
#line 411
  if (mask & (1 << 5)) {
    {
#line 412
    strcat((char */* __restrict  */)(command___0), (char const   */* __restrict  */)"done,");
    }
  }
#line 413
  if (mask & (1 << 6)) {
    {
#line 414
    strcat((char */* __restrict  */)(command___0), (char const   */* __restrict  */)"pause,");
    }
  }
#line 415
  if (mask & (1 << 7)) {
    {
#line 416
    strcat((char */* __restrict  */)(command___0), (char const   */* __restrict  */)"play,");
    }
  }
#line 417
  if (mask & (1 << 8)) {
    {
#line 418
    strcat((char */* __restrict  */)(command___0), (char const   */* __restrict  */)"skip,");
    }
  }
#line 419
  if (mask & (1 << 9)) {
    {
#line 420
    strcat((char */* __restrict  */)(command___0), (char const   */* __restrict  */)"state,");
    }
  }
#line 421
  if (mask & (1 << 10)) {
    {
#line 422
    strcat((char */* __restrict  */)(command___0), (char const   */* __restrict  */)"stop,");
    }
  }
#line 423
  if (mask & (1 << 11)) {
    {
#line 424
    strcat((char */* __restrict  */)(command___0), (char const   */* __restrict  */)"volume,");
    }
  }
#line 425
  if (mask & (1 << 13)) {
    {
#line 426
    strcat((char */* __restrict  */)(command___0), (char const   */* __restrict  */)"flow,");
    }
  }
#line 427
  if (mask & (1 << 14)) {
    {
#line 428
    strcat((char */* __restrict  */)(command___0), (char const   */* __restrict  */)"modify,");
    }
  }
#line 429
  if (mask & (1 << 15)) {
    {
#line 430
    strcat((char */* __restrict  */)(command___0), (char const   */* __restrict  */)"level,");
    }
  }
#line 431
  if (mask & (1 << 16)) {
    {
#line 432
    strcat((char */* __restrict  */)(command___0), (char const   */* __restrict  */)"position,");
    }
  }
  {
#line 434
  p = strrchr((char const   *)(command___0), ',');
  }
#line 435
  if (! p) {
    {
#line 436
    strcat((char */* __restrict  */)(command___0), (char const   */* __restrict  */)"none");
    }
  } else {
#line 438
    *p = (char )'\000';
  }
  {
#line 440
  rptp_async_putline(rptp_fd___0, (void (*)())((void *)0), command___0);
#line 442
  group[rptp_fd___0].rcallback = callback;
#line 443
  group[rptp_fd___0].notify_mask = mask;
#line 444
  group[rptp_fd___0].rraw = 0;
  }
#line 445
  return;
}
}
#line 457 "/home/wslee/benchmarks/sound/rplay-3.3.2/librplay/async.c"
static void write_proc(int rptp_fd___0 ) 
{ 
  obuf *current ;
  int n ;

  {
#line 467
  if (! group[rptp_fd___0].olist) {
    {
#line 469
    do_unregister(rptp_fd___0);
    }
  }
#line 472
  current = group[rptp_fd___0].olist;
#line 473
  if (current->current) {
    {
#line 475
    n = write(rptp_fd___0, (void const   *)current->current, (size_t )current->length);
    }
#line 476
    if (n < 0) {
#line 478
      return;
    }
  } else {
#line 483
    n = 0;
  }
#line 485
  current->length -= n;
#line 486
  current->current += n;
#line 487
  if (current->length <= 0) {
#line 489
    if (current->callback) {
      {
#line 491
      (*(current->callback))(rptp_fd___0);
      }
    }
#line 493
    if (current->data) {
      {
#line 495
      free((void *)current->data);
      }
    }
#line 497
    group[rptp_fd___0].olist = current->next;
#line 498
    if ((unsigned long )group[rptp_fd___0].otail == (unsigned long )current) {
#line 500
      group[rptp_fd___0].otail = (obuf *)((void *)0);
    }
    {
#line 502
    free((void *)current);
    }
#line 504
    if (! group[rptp_fd___0].olist) {
      {
#line 506
      do_unregister(rptp_fd___0);
      }
    }
  }
#line 509
  return;
}
}
#line 516 "/home/wslee/benchmarks/sound/rplay-3.3.2/librplay/async.c"
static void read_proc(int rptp_fd___0 ) 
{ 
  char buffer[1024] ;
  int n ;
  ibuf *new ;
  void *tmp ;
  void *tmp___0 ;
  ibuf *tmp___1 ;
  void *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
  {
#line 527
  n = read(rptp_fd___0, (void *)(buffer), (size_t )sizeof(buffer));
  }
#line 528
  if (n <= 0) {
#line 530
    if (group[rptp_fd___0].notify_mask & (1 << 12)) {
#line 530
      if (group[rptp_fd___0].rcallback) {
        {
#line 532
        (*(group[rptp_fd___0].rcallback))(rptp_fd___0, 1 << 12, "");
#line 533
        group[rptp_fd___0].rcallback = (void (*)())((void *)0);
        }
      }
    }
#line 535
    return;
  }
  {
#line 538
  tmp = malloc((size_t )sizeof(ibuf ));
#line 538
  new = (ibuf *)tmp;
#line 539
  new->next = (struct ibuf_s *)((void *)0);
#line 540
  tmp___0 = malloc((size_t )n);
#line 540
  new->data = (char *)tmp___0;
#line 541
  memcpy((void */* __restrict  */)new->data, (void const   */* __restrict  */)(buffer),
         (size_t )n);
#line 542
  new->length = n;
#line 543
  new->current = new->data;
  }
#line 545
  if (group[rptp_fd___0].itail) {
#line 547
    (group[rptp_fd___0].itail)->next = new;
#line 548
    group[rptp_fd___0].itail = new;
  } else {
#line 552
    tmp___1 = new;
#line 552
    group[rptp_fd___0].ilist = tmp___1;
#line 552
    group[rptp_fd___0].itail = tmp___1;
  }
  {
#line 555
  process_input(rptp_fd___0);
  }
#line 556
  return;
}
}
#line 574 "/home/wslee/benchmarks/sound/rplay-3.3.2/librplay/async.c"
static char line[2048]  = {      (char )'\000'};
#line 575 "/home/wslee/benchmarks/sound/rplay-3.3.2/librplay/async.c"
static int length  =    0;
#line 564 "/home/wslee/benchmarks/sound/rplay-3.3.2/librplay/async.c"
static void process_input(int rptp_fd___0 ) 
{ 
  char *p ;
  ibuf *ptr ;
  ibuf *tmp ;
  ibuf *tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 577
  while (1) {
    while_continue: /* CIL Label */ ;
#line 577
    ptr = group[rptp_fd___0].ilist;
#line 577
    if (! ptr) {
#line 577
      goto while_break;
    }
    {
#line 579
    tmp___1 = memchr((void const   *)ptr->current, '\r', (size_t )ptr->length);
#line 579
    p = (char *)tmp___1;
    }
#line 579
    if (p) {
      {
#line 581
      memcpy((void */* __restrict  */)(& line[length]), (void const   */* __restrict  */)ptr->current,
             (size_t )(p - ptr->current));
#line 582
      length = (int )((long )length + (p - ptr->current));
#line 583
      line[length] = (char )'\000';
#line 584
      notify_line(rptp_fd___0, line);
#line 585
      length = 0;
#line 587
      p += 2;
      }
#line 588
      if ((unsigned long )p < (unsigned long )(ptr->current + ptr->length)) {
#line 593
        ptr->length = (int )((long )ptr->length - (p - ptr->current));
#line 594
        ptr->current = p;
      } else {
        {
#line 598
        free((void *)ptr->data);
        }
#line 599
        if ((unsigned long )ptr == (unsigned long )group[rptp_fd___0].itail) {
#line 601
          tmp = (ibuf *)((void *)0);
#line 601
          group[rptp_fd___0].itail = tmp;
#line 601
          group[rptp_fd___0].ilist = tmp;
        } else {
#line 605
          group[rptp_fd___0].ilist = ptr->next;
        }
        {
#line 607
        free((void *)ptr);
        }
      }
    } else {
      {
#line 616
      memcpy((void */* __restrict  */)(& line[length]), (void const   */* __restrict  */)ptr->current,
             (size_t )ptr->length);
#line 617
      length += ptr->length;
#line 618
      free((void *)ptr->data);
      }
#line 619
      if ((unsigned long )ptr == (unsigned long )group[rptp_fd___0].itail) {
#line 621
        tmp___0 = (ibuf *)((void *)0);
#line 621
        group[rptp_fd___0].itail = tmp___0;
#line 621
        group[rptp_fd___0].ilist = tmp___0;
      } else {
#line 625
        group[rptp_fd___0].ilist = ptr->next;
      }
      {
#line 627
      free((void *)ptr);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 630
  return;
}
}
#line 636 "/home/wslee/benchmarks/sound/rplay-3.3.2/librplay/async.c"
static struct __anonstruct_events_33 events[13]  = 
#line 636
  {      {(char *)"continue", 1 << 4}, 
        {(char *)"done", 1 << 5}, 
        {(char *)"pause", 1 << 6}, 
        {(char *)"play", 1 << 7}, 
        {(char *)"skip", 1 << 8}, 
        {(char *)"state", 1 << 9}, 
        {(char *)"stop", 1 << 10}, 
        {(char *)"volume", 1 << 11}, 
        {(char *)"flow", 1 << 13}, 
        {(char *)"modify", 1 << 14}, 
        {(char *)"level", 1 << 15}, 
        {(char *)"position", 1 << 16}, 
        {(char *)((void *)0), 0}};
#line 662 "/home/wslee/benchmarks/sound/rplay-3.3.2/librplay/async.c"
static void notify_line(int rptp_fd___0 , char *line___0 ) 
{ 
  int what ;
  char *event ;
  int i ;
  int tmp ;
  char *__cil_tmp7 ;

  {
#line 679
  if (! group[rptp_fd___0].rcallback) {
#line 680
    return;
  }
  {
#line 684
  if ((int )*line___0 == 43) {
#line 684
    goto case_43;
  }
#line 688
  if ((int )*line___0 == 45) {
#line 688
    goto case_45;
  }
#line 692
  if ((int )*line___0 == 33) {
#line 692
    goto case_33;
  }
#line 696
  if ((int )*line___0 == 64) {
#line 696
    goto case_64;
  }
#line 709
  goto switch_default;
  case_43: /* CIL Label */ 
#line 685
  what = 1;
#line 686
  goto switch_break;
  case_45: /* CIL Label */ 
#line 689
  what = 1 << 1;
#line 690
  goto switch_break;
  case_33: /* CIL Label */ 
#line 693
  what = 1 << 2;
#line 694
  goto switch_break;
  case_64: /* CIL Label */ 
  {
#line 697
  event = rptp_parse(line___0, (char *)"event");
#line 698
  what = 1 << 3;
#line 699
  i = 0;
  }
  {
#line 699
  while (1) {
    while_continue: /* CIL Label */ ;
#line 699
    if (! events[i].event) {
#line 699
      goto while_break;
    }
    {
#line 701
    tmp = strcmp((char const   *)events[i].event, (char const   *)event);
    }
#line 701
    if (tmp == 0) {
#line 703
      what = events[i].mask;
#line 704
      goto while_break;
    }
#line 699
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 707
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 710
  what = 1 << 3;
#line 711
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 713
  if (what & group[rptp_fd___0].notify_mask) {
    {
#line 715
    (*(group[rptp_fd___0].rcallback))(rptp_fd___0, what, line___0);
    }
  }
#line 723
  return;
}
}
#line 730 "/home/wslee/benchmarks/sound/rplay-3.3.2/librplay/async.c"
static void do_register(int rptp_fd___0 ) 
{ 


  {
#line 738
  if (group[rptp_fd___0].wcallback) {
    {
#line 740
    (*(group[rptp_fd___0].wcallback))(rptp_fd___0, 1);
    }
  }
#line 742
  group[rptp_fd___0].writing = 1;
#line 743
  return;
}
}
#line 750 "/home/wslee/benchmarks/sound/rplay-3.3.2/librplay/async.c"
static void do_unregister(int rptp_fd___0 ) 
{ 


  {
#line 758
  if (group[rptp_fd___0].wcallback) {
    {
#line 760
    (*(group[rptp_fd___0].wcallback))(rptp_fd___0, 2);
    }
  }
#line 762
  group[rptp_fd___0].writing = 0;
#line 763
  return;
}
}
#line 105 "/usr/include/sys/socket.h"
extern  __attribute__((__nothrow__)) int socket(int __domain , int __type , int __protocol ) ;
#line 129
extern int connect(int __fd , struct sockaddr  const  *__addr , socklen_t __len ) ;
#line 148
extern ssize_t recv(int __fd , void *__buf , size_t __n , int __flags ) ;
#line 370 "/usr/include/netinet/in.h"
extern  __attribute__((__nothrow__)) uint16_t htons(uint16_t __hostshort )  __attribute__((__const__)) ;
#line 231 "../include/rplay.h"
char *rptp_errlist[11] ;
#line 262
int rplay_ping(char *host ) ;
#line 268
int rptp_open(char *host , int port , char *response___0 , int response_size ) ;
#line 269
int rptp_read(int rptp_fd___0 , char *ptr , int nbytes ) ;
#line 270
int rptp_write(int rptp_fd___0 , char *ptr , int nbytes ) ;
#line 271
int rptp_close(int rptp_fd___0 ) ;
#line 272
void rptp_perror(char *message ) ;
#line 273
int rptp_putline(int rptp_fd___0 , char *fmt  , ...) ;
#line 274
int rptp_getline(int rptp_fd___0 , char *buf___1 , int nbytes ) ;
#line 275
int rptp_command(int rptp_fd___0 , char *command___0 , char *response___0 , int response_size ) ;
#line 143 "/usr/include/netdb.h"
extern struct hostent *gethostbyname(char const   *__name ) ;
#line 350 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 441
extern unsigned int sleep(unsigned int __seconds ) ;
#line 64 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1))) memset)(void *__s ,
                                                                                     int __c ,
                                                                                     size_t __n ) ;
#line 173
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1))) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 233
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1))) strchr)(char const   *__s ,
                                                                                     int __c )  __attribute__((__pure__)) ;
#line 312
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strpbrk)(char const   *__s ,
                                                                                        char const   *__accept )  __attribute__((__pure__)) ;
#line 49 "/home/wslee/benchmarks/sound/rplay-3.3.2/librplay/rptp.c"
int rptp_errno  =    0;
#line 51 "/home/wslee/benchmarks/sound/rplay-3.3.2/librplay/rptp.c"
char *rptp_errlist[11]  = 
#line 51
  {      (char *)"no error",      (char *)"out of memory",      (char *)"host not found",      (char *)"connection failed", 
        (char *)"cannot create socket",      (char *)"cannot open socket",      (char *)"cannot read from socket",      (char *)"cannot write to socket", 
        (char *)"cannot ping rplay server",      (char *)"connection timeout",      (char *)"RPTP protocol error"};
#line 67
extern unsigned long inet_addr(char *rp ) ;
#line 102 "/home/wslee/benchmarks/sound/rplay-3.3.2/librplay/rptp.c"
int rptp_open(char *host , int port , char *response___0 , int response_size ) 
{ 
  u_long addr ;
  struct sockaddr_in s ;
  struct hostent *hp ;
  int rptp_fd___0 ;
  int i ;
  int n ;
  int tmp ;
  int *tmp___0 ;

  {
  {
#line 119
  rptp_errno = 0;
#line 121
  memset((void *)((char *)(& s)), 0, (size_t )sizeof(s));
#line 123
  addr = inet_addr(host);
  }
#line 124
  if (addr == 4294967295UL) {
    {
#line 126
    hp = gethostbyname((char const   *)host);
    }
#line 127
    if ((unsigned long )hp == (unsigned long )((void *)0)) {
#line 129
      rptp_errno = 2;
#line 130
      return (-1);
    }
    {
#line 132
    memcpy((void */* __restrict  */)((char *)(& s.sin_addr.s_addr)), (void const   */* __restrict  */)*(hp->h_addr_list + 0),
           (size_t )hp->h_length);
    }
  } else {
    {
#line 136
    memcpy((void */* __restrict  */)((char *)(& s.sin_addr.s_addr)), (void const   */* __restrict  */)((char *)(& addr)),
           (size_t )sizeof(addr));
    }
  }
  {
#line 139
  s.sin_port = htons((uint16_t )port);
#line 140
  s.sin_family = (sa_family_t )2;
#line 142
  i = 0;
  }
  {
#line 142
  while (1) {
    while_continue: /* CIL Label */ ;
#line 142
    if (! (i < 3)) {
#line 142
      goto while_break;
    }
    {
#line 144
    tmp = rplay_ping(host);
    }
#line 144
    if (tmp < 0) {
#line 146
      rptp_errno = 8;
#line 147
      return (-1);
    }
    {
#line 150
    rptp_fd___0 = socket(2, 1, 0);
    }
#line 151
    if (rptp_fd___0 < 0) {
#line 153
      rptp_errno = 4;
#line 154
      return (-1);
    }
    {
#line 157
    n = connect(rptp_fd___0, (struct sockaddr  const  *)((struct sockaddr *)(& s)),
                (socklen_t )sizeof(s));
    }
#line 158
    if (n == 0) {
      {
#line 163
      rptp_getline(rptp_fd___0, response___0, response_size);
      }
#line 164
      if ((int )*(response___0 + 0) == 45) {
#line 166
        rptp_errno = 5;
#line 167
        return (-1);
      }
#line 169
      return (rptp_fd___0);
    }
    {
#line 172
    tmp___0 = __errno_location();
    }
    {
#line 175
    if (*tmp___0 == 4) {
#line 175
      goto case_4;
    }
#line 175
    if (*tmp___0 == 111) {
#line 175
      goto case_4;
    }
#line 183
    goto switch_default;
    case_4: /* CIL Label */ 
    case_111: /* CIL Label */ 
    {
#line 176
    close(rptp_fd___0);
    }
#line 177
    if (i + 1 != 3) {
      {
#line 179
      sleep(5U);
      }
    }
#line 181
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 184
    rptp_errno = 3;
#line 185
    return (-1);
    switch_break: /* CIL Label */ ;
    }
#line 142
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 189
  rptp_errno = 3;
#line 191
  return (-1);
}
}
#line 203 "/home/wslee/benchmarks/sound/rplay-3.3.2/librplay/rptp.c"
int rptp_read(int rptp_fd___0 , char *ptr , int nbytes ) 
{ 
  int nleft ;
  int nread ;
  int *tmp ;

  {
#line 215
  rptp_errno = 0;
#line 217
  nleft = nbytes;
  {
#line 219
  while (1) {
    while_continue: /* CIL Label */ ;
#line 219
    if (! (nleft > 0)) {
#line 219
      goto while_break;
    }
    {
#line 221
    nread = read(rptp_fd___0, (void *)ptr, (size_t )nleft);
    }
#line 222
    if (nread < 0) {
      {
#line 224
      tmp = __errno_location();
      }
#line 224
      if (*tmp == 4) {
#line 226
        goto while_continue;
      }
#line 228
      rptp_errno = 6;
#line 229
      return (-1);
    }
#line 231
    if (nread == 0) {
#line 233
      goto while_break;
    }
#line 235
    nleft -= nread;
#line 236
    ptr += nread;
  }
  while_break: /* CIL Label */ ;
  }
#line 239
  return (nbytes - nleft);
}
}
#line 251 "/home/wslee/benchmarks/sound/rplay-3.3.2/librplay/rptp.c"
int rptp_write(int rptp_fd___0 , char *ptr , int nbytes ) 
{ 
  int nleft ;
  int nwritten ;
  int *tmp ;

  {
#line 263
  rptp_errno = 0;
#line 265
  nleft = nbytes;
  {
#line 267
  while (1) {
    while_continue: /* CIL Label */ ;
#line 267
    if (! (nleft > 0)) {
#line 267
      goto while_break;
    }
    {
#line 269
    nwritten = write(rptp_fd___0, (void const   *)ptr, (size_t )nleft);
    }
#line 270
    if (nwritten < 0) {
      {
#line 272
      tmp = __errno_location();
      }
#line 272
      if (*tmp == 4) {
#line 274
        goto while_continue;
      }
#line 276
      rptp_errno = 7;
#line 277
      return (-1);
    } else
#line 279
    if (nwritten == 0) {
#line 281
      rptp_errno = 7;
#line 282
      return (-1);
    }
#line 284
    nleft -= nwritten;
#line 285
    ptr += nwritten;
  }
  while_break: /* CIL Label */ ;
  }
#line 288
  return (nbytes - nleft);
}
}
#line 297 "/home/wslee/benchmarks/sound/rplay-3.3.2/librplay/rptp.c"
int rptp_putline(int rptp_fd___0 , char *fmt  , ...) 
{ 
  va_list args ;
  char buf___1[1024] ;
  int tmp___2 ;
  size_t tmp___3 ;
  int tmp___4 ;
  size_t tmp___5 ;
  void *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
  {
#line 309
  __builtin_va_start(args, fmt);
#line 318
  rptp_errno = 0;
#line 320
  vsprintf((char */* __restrict  */)(buf___1), (char const   */* __restrict  */)fmt,
           args);
#line 321
  __builtin_va_end(args);
#line 322
  strcat((char */* __restrict  */)(buf___1), (char const   */* __restrict  */)"\r\n");
#line 324
  tmp___3 = strlen((char const   *)(buf___1));
#line 324
  tmp___4 = rptp_write(rptp_fd___0, buf___1, (int )tmp___3);
#line 324
  tmp___5 = strlen((char const   *)(buf___1));
  }
#line 324
  if ((size_t )tmp___4 != tmp___5) {
#line 324
    tmp___2 = -1;
  } else {
#line 324
    tmp___2 = 0;
  }
#line 324
  return (tmp___2);
}
}
#line 333 "/home/wslee/benchmarks/sound/rplay-3.3.2/librplay/rptp.c"
int rptp_getline(int rptp_fd___0 , char *buf___1 , int nbytes ) 
{ 
  int i ;
  int n ;
  int nleft ;
  int x ;
  char *ptr ;
  char tmp_buf[1024] ;
  int *tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  void *__cil_tmp13 ;

  {
#line 347
  rptp_errno = 0;
#line 349
  nleft = nbytes;
#line 350
  ptr = buf___1;
  {
#line 352
  while (1) {
    while_continue: /* CIL Label */ ;
#line 352
    if (! (nleft > 0)) {
#line 352
      goto while_break;
    }
    {
#line 358
    n = recv(rptp_fd___0, (void *)ptr, (size_t )nleft, 2);
    }
#line 359
    if (n < 0) {
      {
#line 361
      tmp = __errno_location();
      }
#line 361
      if (*tmp == 4) {
#line 363
        goto while_continue;
      }
#line 365
      rptp_errno = 6;
#line 366
      return (-1);
    } else
#line 368
    if (n == 0) {
#line 370
      rptp_errno = 6;
#line 371
      return (-1);
    }
#line 373
    nleft -= n;
#line 374
    i = 0;
    {
#line 374
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 374
      if (! (i < n)) {
#line 374
        goto while_break___0;
      }
#line 376
      if ((int )*(ptr + i) == 13) {
#line 378
        *(ptr + i) = (char )'\000';
      } else
#line 380
      if ((int )*(ptr + i) == 10) {
#line 382
        *(ptr + i) = (char )'\000';
#line 383
        goto while_break___0;
      }
#line 374
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    again: 
#line 387
    if (i == n) {
#line 387
      tmp___0 = n;
    } else {
#line 387
      tmp___0 = i + 1;
    }
    {
#line 387
    x = read(rptp_fd___0, (void *)(tmp_buf), (size_t )tmp___0);
    }
#line 388
    if (x < 0) {
      {
#line 390
      tmp___1 = __errno_location();
      }
#line 390
      if (*tmp___1 == 4) {
#line 392
        goto again;
      }
#line 394
      rptp_errno = 6;
#line 395
      return (-1);
    } else
#line 397
    if (x == 0) {
#line 399
      rptp_errno = 6;
#line 400
      return (-1);
    } else
#line 402
    if (i < n) {
#line 404
      return (0);
    } else {
#line 408
      ptr += n;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 412
  rptp_errno = 6;
#line 414
  return (-1);
}
}
#line 422 "/home/wslee/benchmarks/sound/rplay-3.3.2/librplay/rptp.c"
int rptp_command(int rptp_fd___0 , char *command___0 , char *response___0 , int response_size ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
#line 433
  rptp_errno = 0;
#line 435
  tmp = rptp_putline(rptp_fd___0, command___0);
  }
#line 435
  if (tmp < 0) {
#line 437
    return (-1);
  }
  {
#line 439
  tmp___0 = rptp_getline(rptp_fd___0, response___0, response_size);
  }
#line 439
  if (tmp___0 < 0) {
#line 441
    return (-1);
  }
  {
#line 445
  if ((int )*(response___0 + 0) == 33) {
#line 445
    goto case_33;
  }
#line 449
  if ((int )*(response___0 + 0) == 45) {
#line 449
    goto case_45;
  }
#line 453
  if ((int )*(response___0 + 0) == 64) {
#line 453
    goto case_64;
  }
#line 453
  if ((int )*(response___0 + 0) == 43) {
#line 453
    goto case_64;
  }
#line 456
  goto switch_default;
  case_33: /* CIL Label */ 
#line 446
  rptp_errno = 9;
#line 447
  return (-1);
  case_45: /* CIL Label */ 
#line 450
  return (1);
  case_64: /* CIL Label */ 
  case_43: /* CIL Label */ 
#line 454
  return (0);
  switch_default: /* CIL Label */ 
#line 457
  rptp_errno = 10;
#line 458
  return (-1);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 466 "/home/wslee/benchmarks/sound/rplay-3.3.2/librplay/rptp.c"
int rptp_close(int rptp_fd___0 ) 
{ 


  {
  {
#line 474
  rptp_errno = 0;
#line 476
  close(rptp_fd___0);
  }
#line 478
  return (0);
}
}
#line 485 "/home/wslee/benchmarks/sound/rplay-3.3.2/librplay/rptp.c"
void rptp_perror(char *message ) 
{ 
  char *__cil_tmp2 ;

  {
  {
#line 493
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s\n",
          message, rptp_errlist[rptp_errno]);
  }
#line 494
  return;
}
}
#line 507 "/home/wslee/benchmarks/sound/rplay-3.3.2/librplay/rptp.c"
static LIST *list  =    (LIST *)((void *)0);
#line 507 "/home/wslee/benchmarks/sound/rplay-3.3.2/librplay/rptp.c"
static LIST **list_next  =    & list;
#line 541 "/home/wslee/benchmarks/sound/rplay-3.3.2/librplay/rptp.c"
static char *buf  ;
#line 542 "/home/wslee/benchmarks/sound/rplay-3.3.2/librplay/rptp.c"
static LIST *list_pos  ;
#line 542 "/home/wslee/benchmarks/sound/rplay-3.3.2/librplay/rptp.c"
static LIST *cache_pos  ;
#line 579
extern int ( /* missing proto */  isspace)() ;
#line 532 "/home/wslee/benchmarks/sound/rplay-3.3.2/librplay/rptp.c"
char *rptp_parse(char *response___0 , char *name ) 
{ 
  char *p ;
  char *response_name ;
  char *response_value ;
  LIST *l ;
  int tmp ;
  int tmp___0 ;
  int quoted ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  void *tmp___4 ;
  LIST *l___0 ;
  char *p___0 ;
  int tmp___5 ;
  int tmp___6 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;

  {
#line 545
  if (! response___0) {
#line 545
    if (! name) {
#line 545
      if (! list_pos) {
#line 547
        return ((char *)((void *)0));
      } else {
#line 545
        goto _L___1;
      }
    } else {
#line 545
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
#line 550
  if (response___0) {
#line 553
    response_name = (char *)"";
#line 553
    response_value = (char *)"";
    {
#line 555
    while (1) {
      while_continue: /* CIL Label */ ;
#line 555
      if (! list) {
#line 555
        goto while_break;
      }
      {
#line 555
      l = list;
#line 555
      list = list->next;
#line 555
      free((void *)((char *)l));
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 555
    list = (LIST *)((void *)0);
#line 555
    list_next = & list;
#line 556
    if (buf) {
      {
#line 558
      free((void *)buf);
      }
    }
    {
#line 560
    buf = strdup((char const   *)response___0);
#line 562
    p = buf;
    }
    {
#line 569
    if ((int )*p == 64) {
#line 569
      goto case_64;
    }
#line 569
    if ((int )*p == 43) {
#line 569
      goto case_64;
    }
#line 569
    if ((int )*p == 45) {
#line 569
      goto case_64;
    }
#line 565
    goto switch_break;
    case_64: /* CIL Label */ 
    case_43: /* CIL Label */ 
    case_45: /* CIL Label */ 
#line 570
    p ++;
#line 571
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
    {
#line 574
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 574
      if (p) {
#line 574
        if (! *p) {
#line 574
          goto while_break___0;
        }
      } else {
#line 574
        goto while_break___0;
      }
      {
#line 577
      tmp___0 = isspace((int )*p);
      }
#line 577
      if (tmp___0) {
#line 579
        p ++;
        {
#line 579
        while (1) {
          while_continue___1: /* CIL Label */ ;
          {
#line 579
          tmp = isspace((int )*p);
          }
#line 579
          if (! tmp) {
#line 579
            goto while_break___1;
          }
#line 579
          p ++;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 580
        goto while_continue___0;
      }
      {
#line 584
      response_name = p;
#line 585
      p = strpbrk((char const   *)p, "= \t\r\n");
      }
#line 588
      if (p) {
#line 588
        if ((int )*p == 61) {
#line 590
          quoted = 0;
#line 592
          tmp___1 = p;
#line 592
          p ++;
#line 592
          *tmp___1 = (char )'\000';
#line 594
          if ((int )*p == 34) {
#line 596
            p ++;
#line 597
            quoted ++;
          }
#line 600
          response_value = p;
#line 601
          if (quoted) {
            {
#line 603
            p = strchr((char const   *)p, '\"');
            }
          } else {
            {
#line 607
            p = strpbrk((char const   *)p, " \t\r\n");
            }
          }
#line 609
          if (p) {
#line 611
            tmp___2 = p;
#line 611
            p ++;
#line 611
            *tmp___2 = (char )'\000';
          }
        } else {
#line 588
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 614
      if (p) {
#line 616
        tmp___3 = p;
#line 616
        p ++;
#line 616
        *tmp___3 = (char )'\000';
      }
      {
#line 619
      tmp___4 = malloc((size_t )sizeof(LIST ));
#line 619
      *list_next = (LIST *)tmp___4;
      }
#line 619
      if (! *list_next) {
#line 619
        return ((char *)((void *)0));
      }
#line 619
      (*list_next)->name = response_name;
#line 619
      (*list_next)->value = response_value;
#line 619
      list_next = & (*list_next)->next;
#line 619
      *list_next = (LIST *)((void *)0);
#line 620
      response_name = (char *)"";
#line 621
      response_value = (char *)"";
    }
    while_break___0: /* CIL Label */ ;
    }
#line 624
    list_pos = list;
#line 625
    cache_pos = (LIST *)((void *)0);
  }
#line 629
  if (name) {
    {
#line 635
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 635
      if (! ((int )*name == 45)) {
#line 635
        goto while_break___2;
      }
#line 637
      name ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 640
    if (cache_pos) {
#line 642
      p___0 = cache_pos->name;
      {
#line 642
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 642
        if (*p___0) {
#line 642
          if (! ((int )*p___0 == 45)) {
#line 642
            goto while_break___3;
          }
        } else {
#line 642
          goto while_break___3;
        }
#line 642
        p___0 ++;
      }
      while_break___3: /* CIL Label */ ;
      }
      {
#line 643
      tmp___5 = strcmp((char const   *)name, (char const   *)p___0);
      }
#line 643
      if (tmp___5 == 0) {
#line 645
        return (cache_pos->value);
      }
    }
#line 649
    l___0 = list;
    {
#line 649
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 649
      if (! l___0) {
#line 649
        goto while_break___4;
      }
#line 651
      p___0 = l___0->name;
      {
#line 651
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 651
        if (*p___0) {
#line 651
          if (! ((int )*p___0 == 45)) {
#line 651
            goto while_break___5;
          }
        } else {
#line 651
          goto while_break___5;
        }
#line 651
        p___0 ++;
      }
      while_break___5: /* CIL Label */ ;
      }
      {
#line 652
      tmp___6 = strcmp((char const   *)p___0, (char const   *)name);
      }
#line 652
      if (tmp___6 == 0) {
#line 654
        return (l___0->value);
      }
#line 649
      l___0 = l___0->next;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 657
    return ((char *)((void *)0));
  } else
#line 660
  if (list_pos) {
#line 662
    cache_pos = list_pos;
#line 663
    list_pos = list_pos->next;
#line 664
    return (cache_pos->name);
  }
#line 667
  return ((char *)((void *)0));
}
}
/* compiler builtin: 
   void __builtin_va_arg(__builtin_va_list  , unsigned long  , void * ) ;  */
#line 197 "/usr/include/sys/socket.h"
extern  __attribute__((__nothrow__)) int setsockopt(int __fd , int __level , int __optname ,
                                                    void const   *__optval , socklen_t __optlen ) ;
#line 365 "/usr/include/netinet/in.h"
extern  __attribute__((__nothrow__)) uint32_t ntohl(uint32_t __netlong )  __attribute__((__const__)) ;
#line 366
extern  __attribute__((__nothrow__)) uint16_t ntohs(uint16_t __netshort )  __attribute__((__const__)) ;
#line 368
extern  __attribute__((__nothrow__)) uint32_t htonl(uint32_t __hostlong )  __attribute__((__const__)) ;
#line 339 "/usr/include/stdio.h"
extern int printf(char const   * __restrict  __format  , ...) ;
#line 327 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) long random(void) ;
#line 330
extern  __attribute__((__nothrow__)) void srandom(unsigned int __seed ) ;
#line 228 "../include/rplay.h"
int rplay_errno  ;
#line 230
char *rplay_errlist[13] ;
#line 243
RPLAY *rplay_create(int command___0 ) ;
#line 244
char *rplay_convert(char *p ) ;
#line 245
int rplay_pack(RPLAY *rp ) ;
#line 246
RPLAY *rplay_unpack(char *packet ) ;
#line 247
void rplay_destroy(RPLAY *rp ) ;
#line 248
long rplay_set(RPLAY *rp  , ...) ;
#line 249
long rplay_get(RPLAY *rp  , ...) ;
#line 250
int rplay_open(char *host ) ;
#line 251
int rplay_open_port(char *host , int port ) ;
#line 252
int rplay_open_sockaddr_in(struct sockaddr_in *saddr ) ;
#line 253
int rplay(int rplay_fd , RPLAY *rp ) ;
#line 254
int rplay_close(int rplay_fd ) ;
#line 255
void rplay_perror(char *s ) ;
#line 256
int rplay_open_display(void) ;
#line 257
int rplay_display(char *sound ) ;
#line 258
int rplay_local(char *sound ) ;
#line 259
int rplay_host(char *host , char *sound ) ;
#line 260
int rplay_host_volume(char *host , char *sound , int volume ) ;
#line 261
int rplay_sound(int rplay_fd , char *sound ) ;
#line 263
int rplay_ping_sockaddr_in(struct sockaddr_in *saddr ) ;
#line 264
int rplay_ping_sockfd(int rplay_fd ) ;
#line 265
char *rplay_default_host(void) ;
#line 266
int rplay_default(char *sound ) ;
#line 267
int rplay_open_default(void) ;
#line 289 "/usr/include/netdb.h"
extern struct servent *getservbyname(char const   *__name , char const   *__proto ) ;
#line 54 "/usr/include/arpa/inet.h"
extern  __attribute__((__nothrow__)) char *inet_ntoa(struct in_addr __in ) ;
#line 895 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) gethostname)(char *__name ,
                                                                                        size_t __len ) ;
#line 58 "/home/wslee/benchmarks/sound/rplay-3.3.2/librplay/rplay.c"
char *rplay_errlist[13]  = 
#line 58 "/home/wslee/benchmarks/sound/rplay-3.3.2/librplay/rplay.c"
  {      (char *)"no error",      (char *)"out of memory",      (char *)"host not found",      (char *)"cannot connect to socket", 
        (char *)"cannot create socket",      (char *)"error writing to socket",      (char *)"error closing socket",      (char *)"max packet size exceeded", 
        (char *)"cannot enable broadcast",      (char *)"unknown rplay attribute",      (char *)"unknown rplay command",      (char *)"illegal rplay index value", 
        (char *)"unknown rplay modifier"};
#line 111 "/home/wslee/benchmarks/sound/rplay-3.3.2/librplay/rplay.c"
static RPLAY_ATTRS *rplay_attrs_create(void) 
{ 
  RPLAY_ATTRS *attrs ;
  void *tmp ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;

  {
  {
#line 120
  tmp = malloc((size_t )sizeof(RPLAY_ATTRS ));
#line 120
  attrs = (RPLAY_ATTRS *)tmp;
  }
#line 121
  if ((unsigned long )attrs == (unsigned long )((void *)0)) {
#line 123
    return ((RPLAY_ATTRS *)((void *)0));
  }
#line 125
  attrs->next = (struct _rplay_attrs *)((void *)0);
#line 126
  attrs->sound = (char *)"";
#line 127
  attrs->volume = 127;
#line 128
  attrs->count = 1;
#line 129
  attrs->rptp_server = (char *)((void *)0);
#line 130
  attrs->rptp_server_port = (unsigned short)5556;
#line 131
  attrs->rptp_search = 1;
#line 132
  attrs->sample_rate = 0UL;
#line 133
  attrs->client_data = (char *)"";
#line 135
  return (attrs);
}
}
#line 142 "/home/wslee/benchmarks/sound/rplay-3.3.2/librplay/rplay.c"
static void rplay_attrs_destroy(RPLAY_ATTRS *attrs ) 
{ 


  {
#line 150
  if (*(attrs->sound)) {
    {
#line 152
    free((void *)attrs->sound);
    }
  }
#line 154
  if (attrs->rptp_server) {
    {
#line 156
    free((void *)attrs->rptp_server);
    }
  }
#line 158
  if (*(attrs->client_data)) {
    {
#line 160
    free((void *)attrs->client_data);
    }
  }
  {
#line 162
  free((void *)((char *)attrs));
  }
#line 163
  return;
}
}
#line 196 "/home/wslee/benchmarks/sound/rplay-3.3.2/librplay/rplay.c"
int rplay_pack(RPLAY *rp ) 
{ 
  RPLAY_ATTRS *attrs ;
  int len ;
  int grow ;
  int i ;
  unsigned char val ;
  unsigned long lval ;
  unsigned short sval ;
  short size ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  size_t tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  uint32_t tmp___9 ;
  void *tmp___10 ;
  void *tmp___11 ;
  uint32_t tmp___12 ;
  void *tmp___13 ;
  void *tmp___14 ;
  void *tmp___15 ;
  void *tmp___16 ;
  void *tmp___17 ;
  void *tmp___18 ;
  size_t tmp___19 ;
  void *tmp___20 ;
  void *tmp___21 ;
  void *tmp___22 ;
  void *tmp___23 ;
  void *tmp___24 ;
  void *tmp___25 ;
  size_t tmp___26 ;
  void *tmp___27 ;
  void *tmp___28 ;
  uint16_t tmp___29 ;
  void *tmp___30 ;
  void *tmp___31 ;
  void *tmp___32 ;
  void *tmp___33 ;
  uint32_t tmp___34 ;
  void *tmp___35 ;
  void *tmp___36 ;
  size_t tmp___37 ;
  void *tmp___38 ;
  void *tmp___39 ;
  void *tmp___40 ;
  void *tmp___41 ;

  {
#line 205
  grow = 0;
#line 211
  rp->len = 0;
#line 212
  val = (unsigned char)30;
#line 213
  grow = 0;
  {
#line 213
  while (1) {
    while_continue: /* CIL Label */ ;
#line 213
    if (! ((unsigned long )rp->len + sizeof(val) > (unsigned long )rp->size)) {
#line 213
      goto while_break;
    }
#line 213
    grow ++;
#line 213
    rp->size += 128;
#line 213
    if (rp->size > 8192) {
#line 213
      rplay_errno = 7;
#line 213
      return (-1);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 213
  if (grow) {
    {
#line 213
    tmp = realloc((void *)rp->buf, (size_t )rp->size);
#line 213
    rp->buf = (char *)tmp;
    }
#line 213
    if ((unsigned long )rp->buf == (unsigned long )((void *)0)) {
#line 213
      rplay_errno = 1;
#line 213
      return (-1);
    }
  }
  {
#line 213
  memcpy((void */* __restrict  */)(rp->buf + rp->len), (void const   */* __restrict  */)((char *)(& val)),
         (size_t )sizeof(val));
#line 213
  rp->len = (int )((unsigned long )rp->len + sizeof(val));
#line 214
  val = (unsigned char )rp->command;
#line 215
  grow = 0;
  }
  {
#line 215
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 215
    if (! ((unsigned long )rp->len + sizeof(val) > (unsigned long )rp->size)) {
#line 215
      goto while_break___0;
    }
#line 215
    grow ++;
#line 215
    rp->size += 128;
#line 215
    if (rp->size > 8192) {
#line 215
      rplay_errno = 7;
#line 215
      return (-1);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 215
  if (grow) {
    {
#line 215
    tmp___0 = realloc((void *)rp->buf, (size_t )rp->size);
#line 215
    rp->buf = (char *)tmp___0;
    }
#line 215
    if ((unsigned long )rp->buf == (unsigned long )((void *)0)) {
#line 215
      rplay_errno = 1;
#line 215
      return (-1);
    }
  }
  {
#line 215
  memcpy((void */* __restrict  */)(rp->buf + rp->len), (void const   */* __restrict  */)((char *)(& val)),
         (size_t )sizeof(val));
#line 215
  rp->len = (int )((unsigned long )rp->len + sizeof(val));
  }
#line 217
  if (rp->count != 1) {
#line 219
    val = (unsigned char)14;
#line 220
    grow = 0;
    {
#line 220
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 220
      if (! ((unsigned long )rp->len + sizeof(val) > (unsigned long )rp->size)) {
#line 220
        goto while_break___1;
      }
#line 220
      grow ++;
#line 220
      rp->size += 128;
#line 220
      if (rp->size > 8192) {
#line 220
        rplay_errno = 7;
#line 220
        return (-1);
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 220
    if (grow) {
      {
#line 220
      tmp___1 = realloc((void *)rp->buf, (size_t )rp->size);
#line 220
      rp->buf = (char *)tmp___1;
      }
#line 220
      if ((unsigned long )rp->buf == (unsigned long )((void *)0)) {
#line 220
        rplay_errno = 1;
#line 220
        return (-1);
      }
    }
    {
#line 220
    memcpy((void */* __restrict  */)(rp->buf + rp->len), (void const   */* __restrict  */)((char *)(& val)),
           (size_t )sizeof(val));
#line 220
    rp->len = (int )((unsigned long )rp->len + sizeof(val));
#line 221
    val = (unsigned char )rp->count;
#line 222
    grow = 0;
    }
    {
#line 222
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 222
      if (! ((unsigned long )rp->len + sizeof(val) > (unsigned long )rp->size)) {
#line 222
        goto while_break___2;
      }
#line 222
      grow ++;
#line 222
      rp->size += 128;
#line 222
      if (rp->size > 8192) {
#line 222
        rplay_errno = 7;
#line 222
        return (-1);
      }
    }
    while_break___2: /* CIL Label */ ;
    }
#line 222
    if (grow) {
      {
#line 222
      tmp___2 = realloc((void *)rp->buf, (size_t )rp->size);
#line 222
      rp->buf = (char *)tmp___2;
      }
#line 222
      if ((unsigned long )rp->buf == (unsigned long )((void *)0)) {
#line 222
        rplay_errno = 1;
#line 222
        return (-1);
      }
    }
    {
#line 222
    memcpy((void */* __restrict  */)(rp->buf + rp->len), (void const   */* __restrict  */)((char *)(& val)),
           (size_t )sizeof(val));
#line 222
    rp->len = (int )((unsigned long )rp->len + sizeof(val));
    }
  }
#line 225
  if (rp->priority != 0) {
#line 227
    val = (unsigned char)15;
#line 228
    grow = 0;
    {
#line 228
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 228
      if (! ((unsigned long )rp->len + sizeof(val) > (unsigned long )rp->size)) {
#line 228
        goto while_break___3;
      }
#line 228
      grow ++;
#line 228
      rp->size += 128;
#line 228
      if (rp->size > 8192) {
#line 228
        rplay_errno = 7;
#line 228
        return (-1);
      }
    }
    while_break___3: /* CIL Label */ ;
    }
#line 228
    if (grow) {
      {
#line 228
      tmp___3 = realloc((void *)rp->buf, (size_t )rp->size);
#line 228
      rp->buf = (char *)tmp___3;
      }
#line 228
      if ((unsigned long )rp->buf == (unsigned long )((void *)0)) {
#line 228
        rplay_errno = 1;
#line 228
        return (-1);
      }
    }
    {
#line 228
    memcpy((void */* __restrict  */)(rp->buf + rp->len), (void const   */* __restrict  */)((char *)(& val)),
           (size_t )sizeof(val));
#line 228
    rp->len = (int )((unsigned long )rp->len + sizeof(val));
#line 229
    val = (unsigned char )rp->priority;
#line 230
    grow = 0;
    }
    {
#line 230
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 230
      if (! ((unsigned long )rp->len + sizeof(val) > (unsigned long )rp->size)) {
#line 230
        goto while_break___4;
      }
#line 230
      grow ++;
#line 230
      rp->size += 128;
#line 230
      if (rp->size > 8192) {
#line 230
        rplay_errno = 7;
#line 230
        return (-1);
      }
    }
    while_break___4: /* CIL Label */ ;
    }
#line 230
    if (grow) {
      {
#line 230
      tmp___4 = realloc((void *)rp->buf, (size_t )rp->size);
#line 230
      rp->buf = (char *)tmp___4;
      }
#line 230
      if ((unsigned long )rp->buf == (unsigned long )((void *)0)) {
#line 230
        rplay_errno = 1;
#line 230
        return (-1);
      }
    }
    {
#line 230
    memcpy((void */* __restrict  */)(rp->buf + rp->len), (void const   */* __restrict  */)((char *)(& val)),
           (size_t )sizeof(val));
#line 230
    rp->len = (int )((unsigned long )rp->len + sizeof(val));
    }
  }
#line 233
  if (*(rp->list_name)) {
#line 235
    val = (unsigned char)26;
#line 236
    grow = 0;
    {
#line 236
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 236
      if (! ((unsigned long )rp->len + sizeof(val) > (unsigned long )rp->size)) {
#line 236
        goto while_break___5;
      }
#line 236
      grow ++;
#line 236
      rp->size += 128;
#line 236
      if (rp->size > 8192) {
#line 236
        rplay_errno = 7;
#line 236
        return (-1);
      }
    }
    while_break___5: /* CIL Label */ ;
    }
#line 236
    if (grow) {
      {
#line 236
      tmp___5 = realloc((void *)rp->buf, (size_t )rp->size);
#line 236
      rp->buf = (char *)tmp___5;
      }
#line 236
      if ((unsigned long )rp->buf == (unsigned long )((void *)0)) {
#line 236
        rplay_errno = 1;
#line 236
        return (-1);
      }
    }
    {
#line 236
    memcpy((void */* __restrict  */)(rp->buf + rp->len), (void const   */* __restrict  */)((char *)(& val)),
           (size_t )sizeof(val));
#line 236
    rp->len = (int )((unsigned long )rp->len + sizeof(val));
#line 237
    tmp___6 = strlen((char const   *)rp->list_name);
#line 237
    len = (int )(tmp___6 + 1U);
#line 238
    grow = 0;
    }
    {
#line 238
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 238
      if (! (rp->len + len > rp->size)) {
#line 238
        goto while_break___6;
      }
#line 238
      grow ++;
#line 238
      rp->size += 128;
#line 238
      if (rp->size > 8192) {
#line 238
        rplay_errno = 7;
#line 238
        return (-1);
      }
    }
    while_break___6: /* CIL Label */ ;
    }
#line 238
    if (grow) {
      {
#line 238
      tmp___7 = realloc((void *)rp->buf, (size_t )rp->size);
#line 238
      rp->buf = (char *)tmp___7;
      }
#line 238
      if ((unsigned long )rp->buf == (unsigned long )((void *)0)) {
#line 238
        rplay_errno = 1;
#line 238
        return (-1);
      }
    }
    {
#line 238
    memcpy((void */* __restrict  */)(rp->buf + rp->len), (void const   */* __restrict  */)rp->list_name,
           (size_t )len);
#line 238
    rp->len += len;
    }
  }
#line 241
  if (rp->id != 0) {
#line 243
    val = (unsigned char)28;
#line 244
    grow = 0;
    {
#line 244
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 244
      if (! ((unsigned long )rp->len + sizeof(val) > (unsigned long )rp->size)) {
#line 244
        goto while_break___7;
      }
#line 244
      grow ++;
#line 244
      rp->size += 128;
#line 244
      if (rp->size > 8192) {
#line 244
        rplay_errno = 7;
#line 244
        return (-1);
      }
    }
    while_break___7: /* CIL Label */ ;
    }
#line 244
    if (grow) {
      {
#line 244
      tmp___8 = realloc((void *)rp->buf, (size_t )rp->size);
#line 244
      rp->buf = (char *)tmp___8;
      }
#line 244
      if ((unsigned long )rp->buf == (unsigned long )((void *)0)) {
#line 244
        rplay_errno = 1;
#line 244
        return (-1);
      }
    }
    {
#line 244
    memcpy((void */* __restrict  */)(rp->buf + rp->len), (void const   */* __restrict  */)((char *)(& val)),
           (size_t )sizeof(val));
#line 244
    rp->len = (int )((unsigned long )rp->len + sizeof(val));
#line 245
    tmp___9 = htonl((uint32_t )rp->id);
#line 245
    lval = (unsigned long )tmp___9;
#line 246
    grow = 0;
    }
    {
#line 246
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 246
      if (! ((unsigned long )rp->len + sizeof(lval) > (unsigned long )rp->size)) {
#line 246
        goto while_break___8;
      }
#line 246
      grow ++;
#line 246
      rp->size += 128;
#line 246
      if (rp->size > 8192) {
#line 246
        rplay_errno = 7;
#line 246
        return (-1);
      }
    }
    while_break___8: /* CIL Label */ ;
    }
#line 246
    if (grow) {
      {
#line 246
      tmp___10 = realloc((void *)rp->buf, (size_t )rp->size);
#line 246
      rp->buf = (char *)tmp___10;
      }
#line 246
      if ((unsigned long )rp->buf == (unsigned long )((void *)0)) {
#line 246
        rplay_errno = 1;
#line 246
        return (-1);
      }
    }
    {
#line 246
    memcpy((void */* __restrict  */)(rp->buf + rp->len), (void const   */* __restrict  */)((char *)(& lval)),
           (size_t )sizeof(lval));
#line 246
    rp->len = (int )((unsigned long )rp->len + sizeof(lval));
    }
  }
#line 249
  if (rp->sequence != 0xffffffffffffffffUL) {
#line 251
    val = (unsigned char)29;
#line 252
    grow = 0;
    {
#line 252
    while (1) {
      while_continue___9: /* CIL Label */ ;
#line 252
      if (! ((unsigned long )rp->len + sizeof(val) > (unsigned long )rp->size)) {
#line 252
        goto while_break___9;
      }
#line 252
      grow ++;
#line 252
      rp->size += 128;
#line 252
      if (rp->size > 8192) {
#line 252
        rplay_errno = 7;
#line 252
        return (-1);
      }
    }
    while_break___9: /* CIL Label */ ;
    }
#line 252
    if (grow) {
      {
#line 252
      tmp___11 = realloc((void *)rp->buf, (size_t )rp->size);
#line 252
      rp->buf = (char *)tmp___11;
      }
#line 252
      if ((unsigned long )rp->buf == (unsigned long )((void *)0)) {
#line 252
        rplay_errno = 1;
#line 252
        return (-1);
      }
    }
    {
#line 252
    memcpy((void */* __restrict  */)(rp->buf + rp->len), (void const   */* __restrict  */)((char *)(& val)),
           (size_t )sizeof(val));
#line 252
    rp->len = (int )((unsigned long )rp->len + sizeof(val));
#line 253
    tmp___12 = htonl((uint32_t )rp->sequence);
#line 253
    lval = (unsigned long )tmp___12;
#line 254
    grow = 0;
    }
    {
#line 254
    while (1) {
      while_continue___10: /* CIL Label */ ;
#line 254
      if (! ((unsigned long )rp->len + sizeof(lval) > (unsigned long )rp->size)) {
#line 254
        goto while_break___10;
      }
#line 254
      grow ++;
#line 254
      rp->size += 128;
#line 254
      if (rp->size > 8192) {
#line 254
        rplay_errno = 7;
#line 254
        return (-1);
      }
    }
    while_break___10: /* CIL Label */ ;
    }
#line 254
    if (grow) {
      {
#line 254
      tmp___13 = realloc((void *)rp->buf, (size_t )rp->size);
#line 254
      rp->buf = (char *)tmp___13;
      }
#line 254
      if ((unsigned long )rp->buf == (unsigned long )((void *)0)) {
#line 254
        rplay_errno = 1;
#line 254
        return (-1);
      }
    }
    {
#line 254
    memcpy((void */* __restrict  */)(rp->buf + rp->len), (void const   */* __restrict  */)((char *)(& lval)),
           (size_t )sizeof(lval));
#line 254
    rp->len = (int )((unsigned long )rp->len + sizeof(lval));
    }
  }
#line 257
  if ((unsigned long )rp->data != (unsigned long )((char *)0)) {
#line 257
    if ((int )rp->data_size > 0) {
#line 259
      val = (unsigned char)31;
#line 260
      grow = 0;
      {
#line 260
      while (1) {
        while_continue___11: /* CIL Label */ ;
#line 260
        if (! ((unsigned long )rp->len + sizeof(val) > (unsigned long )rp->size)) {
#line 260
          goto while_break___11;
        }
#line 260
        grow ++;
#line 260
        rp->size += 128;
#line 260
        if (rp->size > 8192) {
#line 260
          rplay_errno = 7;
#line 260
          return (-1);
        }
      }
      while_break___11: /* CIL Label */ ;
      }
#line 260
      if (grow) {
        {
#line 260
        tmp___14 = realloc((void *)rp->buf, (size_t )rp->size);
#line 260
        rp->buf = (char *)tmp___14;
        }
#line 260
        if ((unsigned long )rp->buf == (unsigned long )((void *)0)) {
#line 260
          rplay_errno = 1;
#line 260
          return (-1);
        }
      }
      {
#line 260
      memcpy((void */* __restrict  */)(rp->buf + rp->len), (void const   */* __restrict  */)((char *)(& val)),
             (size_t )sizeof(val));
#line 260
      rp->len = (int )((unsigned long )rp->len + sizeof(val));
#line 261
      sval = htons(rp->data_size);
#line 262
      grow = 0;
      }
      {
#line 262
      while (1) {
        while_continue___12: /* CIL Label */ ;
#line 262
        if (! ((unsigned long )rp->len + sizeof(sval) > (unsigned long )rp->size)) {
#line 262
          goto while_break___12;
        }
#line 262
        grow ++;
#line 262
        rp->size += 128;
#line 262
        if (rp->size > 8192) {
#line 262
          rplay_errno = 7;
#line 262
          return (-1);
        }
      }
      while_break___12: /* CIL Label */ ;
      }
#line 262
      if (grow) {
        {
#line 262
        tmp___15 = realloc((void *)rp->buf, (size_t )rp->size);
#line 262
        rp->buf = (char *)tmp___15;
        }
#line 262
        if ((unsigned long )rp->buf == (unsigned long )((void *)0)) {
#line 262
          rplay_errno = 1;
#line 262
          return (-1);
        }
      }
      {
#line 262
      memcpy((void */* __restrict  */)(rp->buf + rp->len), (void const   */* __restrict  */)((char *)(& sval)),
             (size_t )sizeof(sval));
#line 262
      rp->len = (int )((unsigned long )rp->len + sizeof(sval));
#line 264
      val = (unsigned char)30;
#line 265
      grow = 0;
      }
      {
#line 265
      while (1) {
        while_continue___13: /* CIL Label */ ;
#line 265
        if (! ((unsigned long )rp->len + sizeof(val) > (unsigned long )rp->size)) {
#line 265
          goto while_break___13;
        }
#line 265
        grow ++;
#line 265
        rp->size += 128;
#line 265
        if (rp->size > 8192) {
#line 265
          rplay_errno = 7;
#line 265
          return (-1);
        }
      }
      while_break___13: /* CIL Label */ ;
      }
#line 265
      if (grow) {
        {
#line 265
        tmp___16 = realloc((void *)rp->buf, (size_t )rp->size);
#line 265
        rp->buf = (char *)tmp___16;
        }
#line 265
        if ((unsigned long )rp->buf == (unsigned long )((void *)0)) {
#line 265
          rplay_errno = 1;
#line 265
          return (-1);
        }
      }
      {
#line 265
      memcpy((void */* __restrict  */)(rp->buf + rp->len), (void const   */* __restrict  */)((char *)(& val)),
             (size_t )sizeof(val));
#line 265
      rp->len = (int )((unsigned long )rp->len + sizeof(val));
#line 266
      grow = 0;
      }
      {
#line 266
      while (1) {
        while_continue___14: /* CIL Label */ ;
#line 266
        if (! (rp->len + (int )rp->data_size > rp->size)) {
#line 266
          goto while_break___14;
        }
#line 266
        grow ++;
#line 266
        rp->size += 128;
#line 266
        if (rp->size > 8192) {
#line 266
          rplay_errno = 7;
#line 266
          return (-1);
        }
      }
      while_break___14: /* CIL Label */ ;
      }
#line 266
      if (grow) {
        {
#line 266
        tmp___17 = realloc((void *)rp->buf, (size_t )rp->size);
#line 266
        rp->buf = (char *)tmp___17;
        }
#line 266
        if ((unsigned long )rp->buf == (unsigned long )((void *)0)) {
#line 266
          rplay_errno = 1;
#line 266
          return (-1);
        }
      }
      {
#line 266
      memcpy((void */* __restrict  */)(rp->buf + rp->len), (void const   */* __restrict  */)rp->data,
             (size_t )rp->data_size);
#line 266
      rp->len += (int )rp->data_size;
      }
    }
  }
#line 269
  i = 0;
#line 269
  attrs = rp->attrs;
  {
#line 269
  while (1) {
    while_continue___15: /* CIL Label */ ;
#line 269
    if (! attrs) {
#line 269
      goto while_break___15;
    }
#line 271
    if (rp->random_sound != -1) {
#line 273
      if (i != rp->random_sound) {
#line 275
        goto __Cont;
      }
    }
#line 279
    if (*(attrs->sound)) {
#line 281
      val = (unsigned char)5;
#line 282
      grow = 0;
      {
#line 282
      while (1) {
        while_continue___16: /* CIL Label */ ;
#line 282
        if (! ((unsigned long )rp->len + sizeof(val) > (unsigned long )rp->size)) {
#line 282
          goto while_break___16;
        }
#line 282
        grow ++;
#line 282
        rp->size += 128;
#line 282
        if (rp->size > 8192) {
#line 282
          rplay_errno = 7;
#line 282
          return (-1);
        }
      }
      while_break___16: /* CIL Label */ ;
      }
#line 282
      if (grow) {
        {
#line 282
        tmp___18 = realloc((void *)rp->buf, (size_t )rp->size);
#line 282
        rp->buf = (char *)tmp___18;
        }
#line 282
        if ((unsigned long )rp->buf == (unsigned long )((void *)0)) {
#line 282
          rplay_errno = 1;
#line 282
          return (-1);
        }
      }
      {
#line 282
      memcpy((void */* __restrict  */)(rp->buf + rp->len), (void const   */* __restrict  */)((char *)(& val)),
             (size_t )sizeof(val));
#line 282
      rp->len = (int )((unsigned long )rp->len + sizeof(val));
#line 283
      tmp___19 = strlen((char const   *)attrs->sound);
#line 283
      len = (int )(tmp___19 + 1U);
#line 284
      grow = 0;
      }
      {
#line 284
      while (1) {
        while_continue___17: /* CIL Label */ ;
#line 284
        if (! (rp->len + len > rp->size)) {
#line 284
          goto while_break___17;
        }
#line 284
        grow ++;
#line 284
        rp->size += 128;
#line 284
        if (rp->size > 8192) {
#line 284
          rplay_errno = 7;
#line 284
          return (-1);
        }
      }
      while_break___17: /* CIL Label */ ;
      }
#line 284
      if (grow) {
        {
#line 284
        tmp___20 = realloc((void *)rp->buf, (size_t )rp->size);
#line 284
        rp->buf = (char *)tmp___20;
        }
#line 284
        if ((unsigned long )rp->buf == (unsigned long )((void *)0)) {
#line 284
          rplay_errno = 1;
#line 284
          return (-1);
        }
      }
      {
#line 284
      memcpy((void */* __restrict  */)(rp->buf + rp->len), (void const   */* __restrict  */)attrs->sound,
             (size_t )len);
#line 284
      rp->len += len;
      }
    }
#line 287
    if (attrs->volume != 127) {
#line 289
      val = (unsigned char)6;
#line 290
      grow = 0;
      {
#line 290
      while (1) {
        while_continue___18: /* CIL Label */ ;
#line 290
        if (! ((unsigned long )rp->len + sizeof(val) > (unsigned long )rp->size)) {
#line 290
          goto while_break___18;
        }
#line 290
        grow ++;
#line 290
        rp->size += 128;
#line 290
        if (rp->size > 8192) {
#line 290
          rplay_errno = 7;
#line 290
          return (-1);
        }
      }
      while_break___18: /* CIL Label */ ;
      }
#line 290
      if (grow) {
        {
#line 290
        tmp___21 = realloc((void *)rp->buf, (size_t )rp->size);
#line 290
        rp->buf = (char *)tmp___21;
        }
#line 290
        if ((unsigned long )rp->buf == (unsigned long )((void *)0)) {
#line 290
          rplay_errno = 1;
#line 290
          return (-1);
        }
      }
      {
#line 290
      memcpy((void */* __restrict  */)(rp->buf + rp->len), (void const   */* __restrict  */)((char *)(& val)),
             (size_t )sizeof(val));
#line 290
      rp->len = (int )((unsigned long )rp->len + sizeof(val));
#line 291
      val = (unsigned char )attrs->volume;
#line 292
      grow = 0;
      }
      {
#line 292
      while (1) {
        while_continue___19: /* CIL Label */ ;
#line 292
        if (! ((unsigned long )rp->len + sizeof(val) > (unsigned long )rp->size)) {
#line 292
          goto while_break___19;
        }
#line 292
        grow ++;
#line 292
        rp->size += 128;
#line 292
        if (rp->size > 8192) {
#line 292
          rplay_errno = 7;
#line 292
          return (-1);
        }
      }
      while_break___19: /* CIL Label */ ;
      }
#line 292
      if (grow) {
        {
#line 292
        tmp___22 = realloc((void *)rp->buf, (size_t )rp->size);
#line 292
        rp->buf = (char *)tmp___22;
        }
#line 292
        if ((unsigned long )rp->buf == (unsigned long )((void *)0)) {
#line 292
          rplay_errno = 1;
#line 292
          return (-1);
        }
      }
      {
#line 292
      memcpy((void */* __restrict  */)(rp->buf + rp->len), (void const   */* __restrict  */)((char *)(& val)),
             (size_t )sizeof(val));
#line 292
      rp->len = (int )((unsigned long )rp->len + sizeof(val));
      }
    }
#line 295
    if (attrs->count != 1) {
#line 297
      val = (unsigned char)13;
#line 298
      grow = 0;
      {
#line 298
      while (1) {
        while_continue___20: /* CIL Label */ ;
#line 298
        if (! ((unsigned long )rp->len + sizeof(val) > (unsigned long )rp->size)) {
#line 298
          goto while_break___20;
        }
#line 298
        grow ++;
#line 298
        rp->size += 128;
#line 298
        if (rp->size > 8192) {
#line 298
          rplay_errno = 7;
#line 298
          return (-1);
        }
      }
      while_break___20: /* CIL Label */ ;
      }
#line 298
      if (grow) {
        {
#line 298
        tmp___23 = realloc((void *)rp->buf, (size_t )rp->size);
#line 298
        rp->buf = (char *)tmp___23;
        }
#line 298
        if ((unsigned long )rp->buf == (unsigned long )((void *)0)) {
#line 298
          rplay_errno = 1;
#line 298
          return (-1);
        }
      }
      {
#line 298
      memcpy((void */* __restrict  */)(rp->buf + rp->len), (void const   */* __restrict  */)((char *)(& val)),
             (size_t )sizeof(val));
#line 298
      rp->len = (int )((unsigned long )rp->len + sizeof(val));
#line 299
      val = (unsigned char )attrs->count;
#line 300
      grow = 0;
      }
      {
#line 300
      while (1) {
        while_continue___21: /* CIL Label */ ;
#line 300
        if (! ((unsigned long )rp->len + sizeof(val) > (unsigned long )rp->size)) {
#line 300
          goto while_break___21;
        }
#line 300
        grow ++;
#line 300
        rp->size += 128;
#line 300
        if (rp->size > 8192) {
#line 300
          rplay_errno = 7;
#line 300
          return (-1);
        }
      }
      while_break___21: /* CIL Label */ ;
      }
#line 300
      if (grow) {
        {
#line 300
        tmp___24 = realloc((void *)rp->buf, (size_t )rp->size);
#line 300
        rp->buf = (char *)tmp___24;
        }
#line 300
        if ((unsigned long )rp->buf == (unsigned long )((void *)0)) {
#line 300
          rplay_errno = 1;
#line 300
          return (-1);
        }
      }
      {
#line 300
      memcpy((void */* __restrict  */)(rp->buf + rp->len), (void const   */* __restrict  */)((char *)(& val)),
             (size_t )sizeof(val));
#line 300
      rp->len = (int )((unsigned long )rp->len + sizeof(val));
      }
    }
#line 303
    if (attrs->rptp_server) {
#line 305
      val = (unsigned char)18;
#line 306
      grow = 0;
      {
#line 306
      while (1) {
        while_continue___22: /* CIL Label */ ;
#line 306
        if (! ((unsigned long )rp->len + sizeof(val) > (unsigned long )rp->size)) {
#line 306
          goto while_break___22;
        }
#line 306
        grow ++;
#line 306
        rp->size += 128;
#line 306
        if (rp->size > 8192) {
#line 306
          rplay_errno = 7;
#line 306
          return (-1);
        }
      }
      while_break___22: /* CIL Label */ ;
      }
#line 306
      if (grow) {
        {
#line 306
        tmp___25 = realloc((void *)rp->buf, (size_t )rp->size);
#line 306
        rp->buf = (char *)tmp___25;
        }
#line 306
        if ((unsigned long )rp->buf == (unsigned long )((void *)0)) {
#line 306
          rplay_errno = 1;
#line 306
          return (-1);
        }
      }
      {
#line 306
      memcpy((void */* __restrict  */)(rp->buf + rp->len), (void const   */* __restrict  */)((char *)(& val)),
             (size_t )sizeof(val));
#line 306
      rp->len = (int )((unsigned long )rp->len + sizeof(val));
#line 307
      tmp___26 = strlen((char const   *)attrs->rptp_server);
#line 307
      len = (int )(tmp___26 + 1U);
#line 308
      grow = 0;
      }
      {
#line 308
      while (1) {
        while_continue___23: /* CIL Label */ ;
#line 308
        if (! (rp->len + len > rp->size)) {
#line 308
          goto while_break___23;
        }
#line 308
        grow ++;
#line 308
        rp->size += 128;
#line 308
        if (rp->size > 8192) {
#line 308
          rplay_errno = 7;
#line 308
          return (-1);
        }
      }
      while_break___23: /* CIL Label */ ;
      }
#line 308
      if (grow) {
        {
#line 308
        tmp___27 = realloc((void *)rp->buf, (size_t )rp->size);
#line 308
        rp->buf = (char *)tmp___27;
        }
#line 308
        if ((unsigned long )rp->buf == (unsigned long )((void *)0)) {
#line 308
          rplay_errno = 1;
#line 308
          return (-1);
        }
      }
      {
#line 308
      memcpy((void */* __restrict  */)(rp->buf + rp->len), (void const   */* __restrict  */)attrs->rptp_server,
             (size_t )len);
#line 308
      rp->len += len;
      }
    }
#line 311
    if ((int )attrs->rptp_server_port != 5556) {
#line 313
      val = (unsigned char)19;
#line 314
      grow = 0;
      {
#line 314
      while (1) {
        while_continue___24: /* CIL Label */ ;
#line 314
        if (! ((unsigned long )rp->len + sizeof(val) > (unsigned long )rp->size)) {
#line 314
          goto while_break___24;
        }
#line 314
        grow ++;
#line 314
        rp->size += 128;
#line 314
        if (rp->size > 8192) {
#line 314
          rplay_errno = 7;
#line 314
          return (-1);
        }
      }
      while_break___24: /* CIL Label */ ;
      }
#line 314
      if (grow) {
        {
#line 314
        tmp___28 = realloc((void *)rp->buf, (size_t )rp->size);
#line 314
        rp->buf = (char *)tmp___28;
        }
#line 314
        if ((unsigned long )rp->buf == (unsigned long )((void *)0)) {
#line 314
          rplay_errno = 1;
#line 314
          return (-1);
        }
      }
      {
#line 314
      memcpy((void */* __restrict  */)(rp->buf + rp->len), (void const   */* __restrict  */)((char *)(& val)),
             (size_t )sizeof(val));
#line 314
      rp->len = (int )((unsigned long )rp->len + sizeof(val));
#line 315
      tmp___29 = htons(attrs->rptp_server_port);
#line 315
      size = (short )tmp___29;
#line 316
      grow = 0;
      }
      {
#line 316
      while (1) {
        while_continue___25: /* CIL Label */ ;
#line 316
        if (! ((unsigned long )rp->len + sizeof(size) > (unsigned long )rp->size)) {
#line 316
          goto while_break___25;
        }
#line 316
        grow ++;
#line 316
        rp->size += 128;
#line 316
        if (rp->size > 8192) {
#line 316
          rplay_errno = 7;
#line 316
          return (-1);
        }
      }
      while_break___25: /* CIL Label */ ;
      }
#line 316
      if (grow) {
        {
#line 316
        tmp___30 = realloc((void *)rp->buf, (size_t )rp->size);
#line 316
        rp->buf = (char *)tmp___30;
        }
#line 316
        if ((unsigned long )rp->buf == (unsigned long )((void *)0)) {
#line 316
          rplay_errno = 1;
#line 316
          return (-1);
        }
      }
      {
#line 316
      memcpy((void */* __restrict  */)(rp->buf + rp->len), (void const   */* __restrict  */)((char *)(& size)),
             (size_t )sizeof(size));
#line 316
      rp->len = (int )((unsigned long )rp->len + sizeof(size));
      }
    }
#line 319
    if (attrs->rptp_search == 0) {
#line 321
      val = (unsigned char)20;
#line 322
      grow = 0;
      {
#line 322
      while (1) {
        while_continue___26: /* CIL Label */ ;
#line 322
        if (! ((unsigned long )rp->len + sizeof(val) > (unsigned long )rp->size)) {
#line 322
          goto while_break___26;
        }
#line 322
        grow ++;
#line 322
        rp->size += 128;
#line 322
        if (rp->size > 8192) {
#line 322
          rplay_errno = 7;
#line 322
          return (-1);
        }
      }
      while_break___26: /* CIL Label */ ;
      }
#line 322
      if (grow) {
        {
#line 322
        tmp___31 = realloc((void *)rp->buf, (size_t )rp->size);
#line 322
        rp->buf = (char *)tmp___31;
        }
#line 322
        if ((unsigned long )rp->buf == (unsigned long )((void *)0)) {
#line 322
          rplay_errno = 1;
#line 322
          return (-1);
        }
      }
      {
#line 322
      memcpy((void */* __restrict  */)(rp->buf + rp->len), (void const   */* __restrict  */)((char *)(& val)),
             (size_t )sizeof(val));
#line 322
      rp->len = (int )((unsigned long )rp->len + sizeof(val));
#line 323
      val = (unsigned char )attrs->rptp_search;
#line 324
      grow = 0;
      }
      {
#line 324
      while (1) {
        while_continue___27: /* CIL Label */ ;
#line 324
        if (! ((unsigned long )rp->len + sizeof(val) > (unsigned long )rp->size)) {
#line 324
          goto while_break___27;
        }
#line 324
        grow ++;
#line 324
        rp->size += 128;
#line 324
        if (rp->size > 8192) {
#line 324
          rplay_errno = 7;
#line 324
          return (-1);
        }
      }
      while_break___27: /* CIL Label */ ;
      }
#line 324
      if (grow) {
        {
#line 324
        tmp___32 = realloc((void *)rp->buf, (size_t )rp->size);
#line 324
        rp->buf = (char *)tmp___32;
        }
#line 324
        if ((unsigned long )rp->buf == (unsigned long )((void *)0)) {
#line 324
          rplay_errno = 1;
#line 324
          return (-1);
        }
      }
      {
#line 324
      memcpy((void */* __restrict  */)(rp->buf + rp->len), (void const   */* __restrict  */)((char *)(& val)),
             (size_t )sizeof(val));
#line 324
      rp->len = (int )((unsigned long )rp->len + sizeof(val));
      }
    }
#line 327
    if (attrs->sample_rate != 0UL) {
#line 329
      val = (unsigned char)22;
#line 330
      grow = 0;
      {
#line 330
      while (1) {
        while_continue___28: /* CIL Label */ ;
#line 330
        if (! ((unsigned long )rp->len + sizeof(val) > (unsigned long )rp->size)) {
#line 330
          goto while_break___28;
        }
#line 330
        grow ++;
#line 330
        rp->size += 128;
#line 330
        if (rp->size > 8192) {
#line 330
          rplay_errno = 7;
#line 330
          return (-1);
        }
      }
      while_break___28: /* CIL Label */ ;
      }
#line 330
      if (grow) {
        {
#line 330
        tmp___33 = realloc((void *)rp->buf, (size_t )rp->size);
#line 330
        rp->buf = (char *)tmp___33;
        }
#line 330
        if ((unsigned long )rp->buf == (unsigned long )((void *)0)) {
#line 330
          rplay_errno = 1;
#line 330
          return (-1);
        }
      }
      {
#line 330
      memcpy((void */* __restrict  */)(rp->buf + rp->len), (void const   */* __restrict  */)((char *)(& val)),
             (size_t )sizeof(val));
#line 330
      rp->len = (int )((unsigned long )rp->len + sizeof(val));
#line 331
      tmp___34 = htonl((uint32_t )attrs->sample_rate);
#line 331
      lval = (unsigned long )tmp___34;
#line 332
      grow = 0;
      }
      {
#line 332
      while (1) {
        while_continue___29: /* CIL Label */ ;
#line 332
        if (! ((unsigned long )rp->len + sizeof(lval) > (unsigned long )rp->size)) {
#line 332
          goto while_break___29;
        }
#line 332
        grow ++;
#line 332
        rp->size += 128;
#line 332
        if (rp->size > 8192) {
#line 332
          rplay_errno = 7;
#line 332
          return (-1);
        }
      }
      while_break___29: /* CIL Label */ ;
      }
#line 332
      if (grow) {
        {
#line 332
        tmp___35 = realloc((void *)rp->buf, (size_t )rp->size);
#line 332
        rp->buf = (char *)tmp___35;
        }
#line 332
        if ((unsigned long )rp->buf == (unsigned long )((void *)0)) {
#line 332
          rplay_errno = 1;
#line 332
          return (-1);
        }
      }
      {
#line 332
      memcpy((void */* __restrict  */)(rp->buf + rp->len), (void const   */* __restrict  */)((char *)(& lval)),
             (size_t )sizeof(lval));
#line 332
      rp->len = (int )((unsigned long )rp->len + sizeof(lval));
      }
    }
#line 335
    if (*(attrs->client_data)) {
#line 337
      val = (unsigned char)25;
#line 338
      grow = 0;
      {
#line 338
      while (1) {
        while_continue___30: /* CIL Label */ ;
#line 338
        if (! ((unsigned long )rp->len + sizeof(val) > (unsigned long )rp->size)) {
#line 338
          goto while_break___30;
        }
#line 338
        grow ++;
#line 338
        rp->size += 128;
#line 338
        if (rp->size > 8192) {
#line 338
          rplay_errno = 7;
#line 338
          return (-1);
        }
      }
      while_break___30: /* CIL Label */ ;
      }
#line 338
      if (grow) {
        {
#line 338
        tmp___36 = realloc((void *)rp->buf, (size_t )rp->size);
#line 338
        rp->buf = (char *)tmp___36;
        }
#line 338
        if ((unsigned long )rp->buf == (unsigned long )((void *)0)) {
#line 338
          rplay_errno = 1;
#line 338
          return (-1);
        }
      }
      {
#line 338
      memcpy((void */* __restrict  */)(rp->buf + rp->len), (void const   */* __restrict  */)((char *)(& val)),
             (size_t )sizeof(val));
#line 338
      rp->len = (int )((unsigned long )rp->len + sizeof(val));
#line 339
      tmp___37 = strlen((char const   *)attrs->client_data);
#line 339
      len = (int )(tmp___37 + 1U);
#line 340
      grow = 0;
      }
      {
#line 340
      while (1) {
        while_continue___31: /* CIL Label */ ;
#line 340
        if (! (rp->len + len > rp->size)) {
#line 340
          goto while_break___31;
        }
#line 340
        grow ++;
#line 340
        rp->size += 128;
#line 340
        if (rp->size > 8192) {
#line 340
          rplay_errno = 7;
#line 340
          return (-1);
        }
      }
      while_break___31: /* CIL Label */ ;
      }
#line 340
      if (grow) {
        {
#line 340
        tmp___38 = realloc((void *)rp->buf, (size_t )rp->size);
#line 340
        rp->buf = (char *)tmp___38;
        }
#line 340
        if ((unsigned long )rp->buf == (unsigned long )((void *)0)) {
#line 340
          rplay_errno = 1;
#line 340
          return (-1);
        }
      }
      {
#line 340
      memcpy((void */* __restrict  */)(rp->buf + rp->len), (void const   */* __restrict  */)attrs->client_data,
             (size_t )len);
#line 340
      rp->len += len;
      }
    }
#line 343
    val = (unsigned char)0;
#line 344
    grow = 0;
    {
#line 344
    while (1) {
      while_continue___32: /* CIL Label */ ;
#line 344
      if (! ((unsigned long )rp->len + sizeof(val) > (unsigned long )rp->size)) {
#line 344
        goto while_break___32;
      }
#line 344
      grow ++;
#line 344
      rp->size += 128;
#line 344
      if (rp->size > 8192) {
#line 344
        rplay_errno = 7;
#line 344
        return (-1);
      }
    }
    while_break___32: /* CIL Label */ ;
    }
#line 344
    if (grow) {
      {
#line 344
      tmp___39 = realloc((void *)rp->buf, (size_t )rp->size);
#line 344
      rp->buf = (char *)tmp___39;
      }
#line 344
      if ((unsigned long )rp->buf == (unsigned long )((void *)0)) {
#line 344
        rplay_errno = 1;
#line 344
        return (-1);
      }
    }
    {
#line 344
    memcpy((void */* __restrict  */)(rp->buf + rp->len), (void const   */* __restrict  */)((char *)(& val)),
           (size_t )sizeof(val));
#line 344
    rp->len = (int )((unsigned long )rp->len + sizeof(val));
    }
    __Cont: /* CIL Label */ 
#line 269
    attrs = attrs->next;
#line 269
    i ++;
  }
  while_break___15: /* CIL Label */ ;
  }
#line 347
  if (i == 0) {
#line 349
    val = (unsigned char)0;
#line 350
    grow = 0;
    {
#line 350
    while (1) {
      while_continue___33: /* CIL Label */ ;
#line 350
      if (! ((unsigned long )rp->len + sizeof(val) > (unsigned long )rp->size)) {
#line 350
        goto while_break___33;
      }
#line 350
      grow ++;
#line 350
      rp->size += 128;
#line 350
      if (rp->size > 8192) {
#line 350
        rplay_errno = 7;
#line 350
        return (-1);
      }
    }
    while_break___33: /* CIL Label */ ;
    }
#line 350
    if (grow) {
      {
#line 350
      tmp___40 = realloc((void *)rp->buf, (size_t )rp->size);
#line 350
      rp->buf = (char *)tmp___40;
      }
#line 350
      if ((unsigned long )rp->buf == (unsigned long )((void *)0)) {
#line 350
        rplay_errno = 1;
#line 350
        return (-1);
      }
    }
    {
#line 350
    memcpy((void */* __restrict  */)(rp->buf + rp->len), (void const   */* __restrict  */)((char *)(& val)),
           (size_t )sizeof(val));
#line 350
    rp->len = (int )((unsigned long )rp->len + sizeof(val));
    }
  }
#line 353
  val = (unsigned char)0;
#line 354
  grow = 0;
  {
#line 354
  while (1) {
    while_continue___34: /* CIL Label */ ;
#line 354
    if (! ((unsigned long )rp->len + sizeof(val) > (unsigned long )rp->size)) {
#line 354
      goto while_break___34;
    }
#line 354
    grow ++;
#line 354
    rp->size += 128;
#line 354
    if (rp->size > 8192) {
#line 354
      rplay_errno = 7;
#line 354
      return (-1);
    }
  }
  while_break___34: /* CIL Label */ ;
  }
#line 354
  if (grow) {
    {
#line 354
    tmp___41 = realloc((void *)rp->buf, (size_t )rp->size);
#line 354
    rp->buf = (char *)tmp___41;
    }
#line 354
    if ((unsigned long )rp->buf == (unsigned long )((void *)0)) {
#line 354
      rplay_errno = 1;
#line 354
      return (-1);
    }
  }
  {
#line 354
  memcpy((void */* __restrict  */)(rp->buf + rp->len), (void const   */* __restrict  */)((char *)(& val)),
         (size_t )sizeof(val));
#line 354
  rp->len = (int )((unsigned long )rp->len + sizeof(val));
  }
#line 356
  return (0);
}
}
#line 363 "/home/wslee/benchmarks/sound/rplay-3.3.2/librplay/rplay.c"
RPLAY *rplay_unpack(char *packet ) 
{ 
  RPLAY *rp ;
  int still_going ;
  int version ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  size_t tmp___3 ;
  char *tmp___4 ;
  size_t tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  size_t tmp___8 ;
  char *tmp___9 ;
  uint32_t tmp___10 ;
  size_t tmp___11 ;
  uint32_t tmp___12 ;
  uint32_t tmp___13 ;
  void *tmp___14 ;
  char *__cil_tmp21 ;

  {
  {
#line 372
  still_going = 1;
#line 375
  rplay_errno = 0;
#line 377
  tmp = packet;
#line 377
  packet ++;
#line 377
  version = (int )*tmp;
#line 378
  tmp___0 = packet;
#line 378
  packet ++;
#line 378
  rp = rplay_create((int )*tmp___0);
  }
#line 379
  if ((unsigned long )rp == (unsigned long )((void *)0)) {
#line 381
    rplay_errno = 1;
#line 382
    return ((RPLAY *)((void *)0));
  }
  {
#line 385
  *(rp->attrsp) = rplay_attrs_create();
  }
#line 386
  if ((unsigned long )*(rp->attrsp) == (unsigned long )((void *)0)) {
#line 388
    rplay_errno = 1;
#line 389
    return ((RPLAY *)((void *)0));
  }
  {
#line 392
  while (1) {
    while_continue: /* CIL Label */ ;
#line 392
    if (! still_going) {
#line 392
      goto while_break;
    }
#line 394
    tmp___1 = packet;
#line 394
    packet ++;
    {
#line 396
    if ((int )*tmp___1 == 14) {
#line 396
      goto case_14;
    }
#line 400
    if ((int )*tmp___1 == 26) {
#line 400
      goto case_26;
    }
#line 405
    if ((int )*tmp___1 == 15) {
#line 405
      goto case_15;
    }
#line 409
    if ((int )*tmp___1 == 5) {
#line 409
      goto case_5;
    }
#line 414
    if ((int )*tmp___1 == 6) {
#line 414
      goto case_6;
    }
#line 418
    if ((int )*tmp___1 == 13) {
#line 418
      goto case_13;
    }
#line 422
    if ((int )*tmp___1 == 18) {
#line 422
      goto case_18;
    }
#line 427
    if ((int )*tmp___1 == 19) {
#line 427
      goto case_19;
    }
#line 434
    if ((int )*tmp___1 == 20) {
#line 434
      goto case_20;
    }
#line 438
    if ((int )*tmp___1 == 22) {
#line 438
      goto case_22;
    }
#line 445
    if ((int )*tmp___1 == 25) {
#line 445
      goto case_25;
    }
#line 450
    if ((int )*tmp___1 == 28) {
#line 450
      goto case_28;
    }
#line 456
    if ((int )*tmp___1 == 29) {
#line 456
      goto case_29;
    }
#line 462
    if ((int )*tmp___1 == 31) {
#line 462
      goto case_31;
    }
#line 468
    if ((int )*tmp___1 == 30) {
#line 468
      goto case_30;
    }
#line 474
    if ((int )*tmp___1 == 0) {
#line 474
      goto case_0;
    }
#line 492
    goto switch_default;
    case_14: /* CIL Label */ 
#line 397
    tmp___2 = packet;
#line 397
    packet ++;
#line 397
    rp->count = (int )((unsigned char )*tmp___2);
#line 398
    goto switch_break;
    case_26: /* CIL Label */ 
    {
#line 401
    rp->list_name = strdup((char const   *)packet);
#line 402
    tmp___3 = strlen((char const   *)packet);
#line 402
    packet += tmp___3 + 1U;
    }
#line 403
    goto switch_break;
    case_15: /* CIL Label */ 
#line 406
    tmp___4 = packet;
#line 406
    packet ++;
#line 406
    rp->priority = (int )((unsigned char )*tmp___4);
#line 407
    goto switch_break;
    case_5: /* CIL Label */ 
    {
#line 410
    (*(rp->attrsp))->sound = strdup((char const   *)packet);
#line 411
    tmp___5 = strlen((char const   *)packet);
#line 411
    packet += tmp___5 + 1U;
    }
#line 412
    goto switch_break;
    case_6: /* CIL Label */ 
#line 415
    tmp___6 = packet;
#line 415
    packet ++;
#line 415
    (*(rp->attrsp))->volume = (int )((unsigned char )*tmp___6);
#line 416
    goto switch_break;
    case_13: /* CIL Label */ 
#line 419
    tmp___7 = packet;
#line 419
    packet ++;
#line 419
    (*(rp->attrsp))->count = (int )((unsigned char )*tmp___7);
#line 420
    goto switch_break;
    case_18: /* CIL Label */ 
    {
#line 423
    (*(rp->attrsp))->rptp_server = strdup((char const   *)packet);
#line 424
    tmp___8 = strlen((char const   *)packet);
#line 424
    packet += tmp___8 + 1U;
    }
#line 425
    goto switch_break;
    case_19: /* CIL Label */ 
    {
#line 428
    memcpy((void */* __restrict  */)((char *)(& (*(rp->attrsp))->rptp_server_port)),
           (void const   */* __restrict  */)packet, (size_t )sizeof((*(rp->attrsp))->rptp_server_port));
#line 429
    (*(rp->attrsp))->rptp_server_port = ntohs((*(rp->attrsp))->rptp_server_port);
#line 430
    packet += sizeof((*(rp->attrsp))->rptp_server_port);
    }
#line 431
    goto switch_break;
    case_20: /* CIL Label */ 
#line 435
    tmp___9 = packet;
#line 435
    packet ++;
#line 435
    (*(rp->attrsp))->rptp_search = (int )((unsigned char )*tmp___9);
#line 436
    goto switch_break;
    case_22: /* CIL Label */ 
    {
#line 439
    memcpy((void */* __restrict  */)((char *)(& (*(rp->attrsp))->sample_rate)), (void const   */* __restrict  */)packet,
           (size_t )sizeof((*(rp->attrsp))->sample_rate));
#line 441
    tmp___10 = ntohl((uint32_t )(*(rp->attrsp))->sample_rate);
#line 441
    (*(rp->attrsp))->sample_rate = (unsigned long )tmp___10;
#line 442
    packet += sizeof((*(rp->attrsp))->sample_rate);
    }
#line 443
    goto switch_break;
    case_25: /* CIL Label */ 
    {
#line 446
    (*(rp->attrsp))->client_data = strdup((char const   *)packet);
#line 447
    tmp___11 = strlen((char const   *)packet);
#line 447
    packet += tmp___11 + 1U;
    }
#line 448
    goto switch_break;
    case_28: /* CIL Label */ 
    {
#line 451
    memcpy((void */* __restrict  */)((char *)(& rp->id)), (void const   */* __restrict  */)packet,
           (size_t )sizeof(rp->id));
#line 452
    tmp___12 = ntohl((uint32_t )rp->id);
#line 452
    rp->id = (int )tmp___12;
#line 453
    packet += sizeof(rp->id);
    }
#line 454
    goto switch_break;
    case_29: /* CIL Label */ 
    {
#line 457
    memcpy((void */* __restrict  */)((char *)(& rp->sequence)), (void const   */* __restrict  */)packet,
           (size_t )sizeof(rp->sequence));
#line 458
    tmp___13 = ntohl((uint32_t )rp->sequence);
#line 458
    rp->sequence = (unsigned long )tmp___13;
#line 459
    packet += sizeof(rp->sequence);
    }
#line 460
    goto switch_break;
    case_31: /* CIL Label */ 
    {
#line 463
    memcpy((void */* __restrict  */)((char *)(& rp->data_size)), (void const   */* __restrict  */)packet,
           (size_t )sizeof(rp->data_size));
#line 464
    rp->data_size = ntohs(rp->data_size);
#line 465
    packet += sizeof(rp->data_size);
    }
#line 466
    goto switch_break;
    case_30: /* CIL Label */ 
    {
#line 469
    tmp___14 = malloc((size_t )rp->data_size);
#line 469
    rp->data = (char *)tmp___14;
#line 470
    memcpy((void */* __restrict  */)rp->data, (void const   */* __restrict  */)packet,
           (size_t )rp->data_size);
#line 471
    packet += (int )rp->data_size;
    }
#line 472
    goto switch_break;
    case_0: /* CIL Label */ 
#line 475
    (rp->nsounds) ++;
#line 476
    rp->attrsp = & (*(rp->attrsp))->next;
#line 477
    if ((int )*packet == 0) {
#line 479
      still_going = 0;
    } else {
      {
#line 483
      *(rp->attrsp) = rplay_attrs_create();
      }
#line 484
      if ((unsigned long )*(rp->attrsp) == (unsigned long )((void *)0)) {
#line 486
        rplay_errno = 1;
#line 487
        return ((RPLAY *)((void *)0));
      }
    }
#line 490
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 493
    rplay_errno = 9;
#line 495
    printf((char const   */* __restrict  */)"unpack: unknown attr \'%d\'\n", (int )*packet);
    }
#line 497
    return ((RPLAY *)((void *)0));
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 501
  return (rp);
}
}
#line 511 "/home/wslee/benchmarks/sound/rplay-3.3.2/librplay/rplay.c"
RPLAY *rplay_create(int command___0 ) 
{ 
  RPLAY *rp ;
  void *tmp ;
  void *tmp___0 ;
  char *__cil_tmp5 ;

  {
  {
#line 521
  rplay_errno = 0;
#line 523
  tmp = malloc((size_t )sizeof(RPLAY ));
#line 523
  rp = (RPLAY *)tmp;
  }
#line 524
  if ((unsigned long )rp == (unsigned long )((void *)0)) {
#line 526
    rplay_errno = 1;
#line 527
    return ((RPLAY *)((void *)0));
  }
  {
#line 530
  rp->attrs = (struct _rplay_attrs *)((void *)0);
#line 531
  rp->attrsp = & rp->attrs;
#line 532
  tmp___0 = malloc((size_t )128);
#line 532
  rp->buf = (char *)tmp___0;
  }
#line 533
  if ((unsigned long )rp->buf == (unsigned long )((void *)0)) {
#line 535
    rplay_errno = 1;
#line 536
    return ((RPLAY *)((void *)0));
  }
#line 539
  rp->len = 0;
#line 540
  rp->size = 0;
#line 541
  rp->command = 0;
#line 542
  rp->nsounds = 0;
#line 543
  rp->count = 1;
#line 544
  rp->priority = 0;
#line 545
  rp->random_sound = -1;
#line 546
  rp->list_name = (char *)"";
#line 547
  rp->id = 0;
#line 548
  rp->sequence = 0xffffffffffffffffUL;
#line 549
  rp->data = (char *)((void *)0);
#line 550
  rp->data_size = (unsigned short)0;
  {
#line 561
  if (command___0 == 27) {
#line 561
    goto case_27;
  }
#line 561
  if (command___0 == 24) {
#line 561
    goto case_27;
  }
#line 561
  if (command___0 == 23) {
#line 561
    goto case_27;
  }
#line 561
  if (command___0 == 17) {
#line 561
    goto case_27;
  }
#line 561
  if (command___0 == 4) {
#line 561
    goto case_27;
  }
#line 561
  if (command___0 == 3) {
#line 561
    goto case_27;
  }
#line 561
  if (command___0 == 2) {
#line 561
    goto case_27;
  }
#line 561
  if (command___0 == 1) {
#line 561
    goto case_27;
  }
#line 565
  goto switch_default;
  case_27: /* CIL Label */ 
  case_24: /* CIL Label */ 
  case_23: /* CIL Label */ 
  case_17: /* CIL Label */ 
  case_4: /* CIL Label */ 
  case_3: /* CIL Label */ 
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
#line 562
  rp->command = command___0;
#line 563
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 566
  rplay_errno = 10;
#line 567
  return ((RPLAY *)((void *)0));
  switch_break: /* CIL Label */ ;
  }
#line 570
  return (rp);
}
}
#line 577 "/home/wslee/benchmarks/sound/rplay-3.3.2/librplay/rplay.c"
static RPLAY_ATTRS *get_attrs(RPLAY_ATTRS *attrs , int index___0 ) 
{ 
  int i ;

  {
#line 588
  if (index___0 < 0) {
#line 590
    return ((RPLAY_ATTRS *)((void *)0));
  }
#line 593
  i = 0;
  {
#line 593
  while (1) {
    while_continue: /* CIL Label */ ;
#line 593
    if (i < index___0) {
#line 593
      if (! attrs) {
#line 593
        goto while_break;
      }
    } else {
#line 593
      goto while_break;
    }
#line 593
    i ++;
#line 593
    attrs = attrs->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 595
  return (attrs);
}
}
#line 747
extern int ( /* missing proto */  time)() ;
#line 605 "/home/wslee/benchmarks/sound/rplay-3.3.2/librplay/rplay.c"
long rplay_set(RPLAY *rp  , ...) 
{ 
  va_list args ;
  RPLAY_ATTRS *attrs ;
  RPLAY_ATTRS *prev ;
  RPLAY_ATTRS *curr ;
  int index___0 ;
  int i ;
  int modifier ;
  char *data ;
  time_t seed ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  long tmp___8 ;
  int tmp___9 ;
  unsigned long tmp___10 ;
  char *tmp___11 ;
  unsigned short tmp___12 ;
  void *tmp___13 ;
  int attribute ;
  int tmp___14 ;
  char *tmp___16 ;
  int tmp___17 ;
  char *tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  struct hostent *hp ;
  u_long addr ;
  struct sockaddr_in s ;
  char *host ;
  char *tmp___23 ;
  char hostname[64] ;
  int tmp___24 ;
  char *tmp___25 ;
  in_addr_t tmp___26 ;
  char *tmp___27 ;
  long tmp___29 ;
  int tmp___30 ;
  unsigned long tmp___31 ;
  char *tmp___33 ;
  int tmp___34 ;
  int tmp___35 ;
  void *__cil_tmp54 ;

  {
  {
#line 614
  attrs = (RPLAY_ATTRS *)((void *)0);
#line 614
  prev = (RPLAY_ATTRS *)((void *)0);
#line 620
  __builtin_va_start(args, rp);
#line 627
  rplay_errno = 0;
#line 629
  tmp = __builtin_va_arg(args, long );
#line 629
  modifier = tmp;
  }
  {
#line 633
  if (modifier == 9) {
#line 633
    goto case_9;
  }
#line 644
  if (modifier == 10) {
#line 644
    goto case_10;
  }
#line 683
  if (modifier == 11) {
#line 683
    goto case_11;
  }
#line 720
  if (modifier == 12) {
#line 720
    goto case_12;
  }
#line 730
  if (modifier == 14) {
#line 730
    goto case_14;
  }
#line 734
  if (modifier == 26) {
#line 734
    goto case_26;
  }
#line 742
  if (modifier == 15) {
#line 742
    goto case_15;
  }
#line 746
  if (modifier == 16) {
#line 746
    goto case_16;
  }
#line 752
  if (modifier == 28) {
#line 752
    goto case_28;
  }
#line 756
  if (modifier == 29) {
#line 756
    goto case_29;
  }
#line 760
  if (modifier == 31) {
#line 760
    goto case_31;
  }
#line 764
  if (modifier == 30) {
#line 764
    goto case_30;
  }
#line 781
  goto switch_default;
  case_9: /* CIL Label */ 
  {
#line 634
  attrs = rplay_attrs_create();
#line 634
  *(rp->attrsp) = attrs;
  }
#line 635
  if ((unsigned long )attrs == (unsigned long )((void *)0)) {
#line 637
    rplay_errno = 1;
#line 638
    return (-1L);
  }
#line 640
  rp->attrsp = & attrs->next;
#line 641
  (rp->nsounds) ++;
#line 642
  goto switch_break;
  case_10: /* CIL Label */ 
  {
#line 645
  tmp___0 = __builtin_va_arg(args, long );
#line 645
  index___0 = tmp___0;
  }
#line 646
  if (index___0 < 0) {
#line 648
    rplay_errno = 11;
#line 649
    return (-1L);
  }
#line 651
  i = 0;
#line 651
  curr = rp->attrs;
  {
#line 651
  while (1) {
    while_continue: /* CIL Label */ ;
#line 651
    if (i < index___0) {
#line 651
      if (! curr) {
#line 651
        goto while_break;
      }
    } else {
#line 651
      goto while_break;
    }
#line 653
    prev = curr;
#line 654
    curr = curr->next;
#line 651
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 656
  if ((unsigned long )curr == (unsigned long )((void *)0)) {
#line 656
    if (i != index___0) {
#line 658
      rplay_errno = 11;
#line 659
      return (-1L);
    }
  }
  {
#line 661
  attrs = rplay_attrs_create();
  }
#line 662
  if ((unsigned long )attrs == (unsigned long )((void *)0)) {
#line 664
    rplay_errno = 1;
#line 665
    return (-1L);
  }
#line 667
  if (prev) {
#line 669
    prev->next = attrs;
  } else {
#line 673
    *(rp->attrsp) = attrs;
  }
#line 675
  attrs->next = curr;
#line 676
  if ((unsigned long )attrs->next == (unsigned long )((void *)0)) {
#line 678
    rp->attrsp = & attrs->next;
  }
#line 680
  (rp->nsounds) ++;
#line 681
  goto switch_break;
  case_11: /* CIL Label */ 
  {
#line 684
  tmp___1 = __builtin_va_arg(args, long );
#line 684
  index___0 = tmp___1;
  }
#line 685
  if (index___0 < 0) {
#line 687
    rplay_errno = 11;
#line 688
    return (-1L);
  }
#line 690
  i = 0;
#line 690
  curr = rp->attrs;
  {
#line 690
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 690
    if (i < index___0) {
#line 690
      if (! curr) {
#line 690
        goto while_break___0;
      }
    } else {
#line 690
      goto while_break___0;
    }
#line 692
    prev = curr;
#line 693
    curr = curr->next;
#line 690
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 695
  if ((unsigned long )curr == (unsigned long )((void *)0)) {
#line 697
    rplay_errno = 11;
#line 698
    return (-1L);
  }
#line 700
  if (prev) {
#line 702
    prev->next = curr->next;
#line 703
    if ((unsigned long )prev->next == (unsigned long )((void *)0)) {
#line 705
      rp->attrsp = & prev->next;
    }
  } else {
#line 710
    rp->attrs = curr->next;
#line 711
    if ((unsigned long )rp->attrs == (unsigned long )((void *)0)) {
#line 713
      rp->attrsp = & rp->attrs;
    }
  }
  {
#line 716
  rplay_attrs_destroy(curr);
#line 717
  (rp->nsounds) --;
  }
#line 718
  goto switch_break;
  case_12: /* CIL Label */ 
  {
#line 721
  tmp___2 = __builtin_va_arg(args, long );
#line 721
  index___0 = tmp___2;
#line 722
  attrs = get_attrs(rp->attrs, index___0);
  }
#line 723
  if ((unsigned long )attrs == (unsigned long )((void *)0)) {
#line 725
    rplay_errno = 11;
#line 726
    return (-1L);
  }
#line 728
  goto switch_break;
  case_14: /* CIL Label */ 
  {
#line 731
  tmp___3 = __builtin_va_arg(args, long );
#line 731
  rp->count = tmp___3;
  }
#line 732
  goto switch_break;
  case_26: /* CIL Label */ 
#line 735
  if (*(rp->list_name)) {
    {
#line 737
    free((void *)rp->list_name);
    }
  }
  {
#line 739
  tmp___5 = __builtin_va_arg(args, char *);
#line 739
  rp->list_name = strdup((char const   *)tmp___5);
  }
#line 740
  goto switch_break;
  case_15: /* CIL Label */ 
  {
#line 743
  tmp___6 = __builtin_va_arg(args, long );
#line 743
  rp->priority = tmp___6;
  }
#line 744
  goto switch_break;
  case_16: /* CIL Label */ 
  {
#line 747
  tmp___7 = time(0);
#line 747
  seed = (time_t )tmp___7;
#line 748
  srandom((unsigned int )((int )seed));
#line 749
  tmp___8 = random();
#line 749
  rp->random_sound = (int )(tmp___8 % (long )rp->nsounds);
  }
#line 750
  goto switch_break;
  case_28: /* CIL Label */ 
  {
#line 753
  tmp___9 = __builtin_va_arg(args, long );
#line 753
  rp->id = tmp___9;
  }
#line 754
  goto switch_break;
  case_29: /* CIL Label */ 
  {
#line 757
  tmp___10 = __builtin_va_arg(args, unsigned long );
#line 757
  rp->sequence = tmp___10;
  }
#line 758
  goto switch_break;
  case_31: /* CIL Label */ 
#line 761
  rplay_errno = 12;
#line 762
  return (-1L);
  case_30: /* CIL Label */ 
#line 765
  if (rp->data) {
    {
#line 767
    free((void *)rp->data);
    }
  }
  {
#line 770
  tmp___11 = __builtin_va_arg(args, char *);
#line 770
  data = tmp___11;
#line 771
  tmp___12 = __builtin_va_arg(args, long );
#line 771
  rp->data_size = tmp___12;
#line 772
  tmp___13 = malloc((size_t )rp->data_size);
#line 772
  rp->data = (char *)tmp___13;
  }
#line 773
  if ((unsigned long )rp->data == (unsigned long )((void *)0)) {
#line 775
    rplay_errno = 1;
#line 776
    return (-1L);
  }
  {
#line 778
  memcpy((void */* __restrict  */)rp->data, (void const   */* __restrict  */)data,
         (size_t )rp->data_size);
  }
#line 779
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 782
  rplay_errno = 12;
#line 783
  return (-1L);
  switch_break: /* CIL Label */ ;
  }
#line 786
  if (attrs) {
    {
#line 790
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 790
      tmp___34 = __builtin_va_arg(args, long );
#line 790
      attribute = tmp___34;
      }
#line 790
      if (! attribute) {
#line 790
        goto while_break___1;
      }
      {
#line 794
      if (attribute == 14) {
#line 794
        goto case_14___0;
      }
#line 798
      if (attribute == 26) {
#line 798
        goto case_26___0;
      }
#line 806
      if (attribute == 15) {
#line 806
        goto case_15___0;
      }
#line 810
      if (attribute == 5) {
#line 810
        goto case_5;
      }
#line 818
      if (attribute == 6) {
#line 818
        goto case_6;
      }
#line 822
      if (attribute == 13) {
#line 822
        goto case_13;
      }
#line 827
      if (attribute == 21) {
#line 827
        goto case_21;
      }
#line 827
      if (attribute == 18) {
#line 827
        goto case_21;
      }
#line 869
      if (attribute == 19) {
#line 869
        goto case_19;
      }
#line 873
      if (attribute == 20) {
#line 873
        goto case_20;
      }
#line 877
      if (attribute == 22) {
#line 877
        goto case_22;
      }
#line 881
      if (attribute == 25) {
#line 881
        goto case_25;
      }
#line 889
      goto switch_default___0;
      case_14___0: /* CIL Label */ 
      {
#line 795
      tmp___14 = __builtin_va_arg(args, long );
#line 795
      rp->count = tmp___14;
      }
#line 796
      goto switch_break___0;
      case_26___0: /* CIL Label */ 
#line 799
      if (*(rp->list_name)) {
        {
#line 801
        free((void *)rp->list_name);
        }
      }
      {
#line 803
      tmp___16 = __builtin_va_arg(args, char *);
#line 803
      rp->list_name = strdup((char const   *)tmp___16);
      }
#line 804
      goto switch_break___0;
      case_15___0: /* CIL Label */ 
      {
#line 807
      tmp___17 = __builtin_va_arg(args, long );
#line 807
      rp->priority = tmp___17;
      }
#line 808
      goto switch_break___0;
      case_5: /* CIL Label */ 
#line 811
      if (*(attrs->sound)) {
        {
#line 813
        free((void *)attrs->sound);
        }
      }
      {
#line 815
      tmp___19 = __builtin_va_arg(args, char *);
#line 815
      attrs->sound = strdup((char const   *)tmp___19);
      }
#line 816
      goto switch_break___0;
      case_6: /* CIL Label */ 
      {
#line 819
      tmp___20 = __builtin_va_arg(args, long );
#line 819
      attrs->volume = tmp___20;
      }
#line 820
      goto switch_break___0;
      case_13: /* CIL Label */ 
      {
#line 823
      tmp___21 = __builtin_va_arg(args, long );
#line 823
      attrs->count = tmp___21;
      }
#line 824
      goto switch_break___0;
      case_21: /* CIL Label */ 
      case_18: /* CIL Label */ 
      {
#line 832
      tmp___23 = __builtin_va_arg(args, char *);
#line 832
      host = tmp___23;
      }
#line 835
      if (attribute == 21) {
        {
#line 837
        tmp___24 = gethostname(hostname, (size_t )sizeof(hostname));
        }
#line 837
        if (tmp___24 < 0) {
#line 839
          rplay_errno = 2;
#line 840
          return (-1L);
        }
#line 842
        host = hostname;
      } else {
        {
#line 846
        tmp___25 = __builtin_va_arg(args, char *);
#line 846
        host = tmp___25;
        }
      }
      {
#line 849
      memset((void *)((char *)(& s)), 0, (size_t )sizeof(s));
#line 850
      tmp___26 = inet_addr((char const   *)host);
#line 850
      addr = (u_long )tmp___26;
      }
#line 851
      if (addr == 4294967295UL) {
        {
#line 853
        hp = gethostbyname((char const   *)host);
        }
#line 854
        if ((unsigned long )hp == (unsigned long )((void *)0)) {
#line 856
          rplay_errno = 2;
#line 857
          return (-1L);
        }
        {
#line 859
        memcpy((void */* __restrict  */)((char *)(& s.sin_addr.s_addr)), (void const   */* __restrict  */)*(hp->h_addr_list + 0),
               (size_t )hp->h_length);
        }
      } else {
        {
#line 863
        memcpy((void */* __restrict  */)((char *)(& s.sin_addr.s_addr)), (void const   */* __restrict  */)((char *)(& addr)),
               (size_t )sizeof(addr));
        }
      }
      {
#line 865
      tmp___27 = inet_ntoa(s.sin_addr);
#line 865
      attrs->rptp_server = strdup((char const   *)tmp___27);
      }
#line 866
      goto switch_break___0;
      case_19: /* CIL Label */ 
      {
#line 870
      tmp___29 = __builtin_va_arg(args, long );
#line 870
      attrs->rptp_server_port = (unsigned short )tmp___29;
      }
#line 871
      goto switch_break___0;
      case_20: /* CIL Label */ 
      {
#line 874
      tmp___30 = __builtin_va_arg(args, long );
#line 874
      attrs->rptp_search = tmp___30;
      }
#line 875
      goto switch_break___0;
      case_22: /* CIL Label */ 
      {
#line 878
      tmp___31 = __builtin_va_arg(args, unsigned long );
#line 878
      attrs->sample_rate = tmp___31;
      }
#line 879
      goto switch_break___0;
      case_25: /* CIL Label */ 
#line 882
      if (*(attrs->client_data)) {
        {
#line 884
        free((void *)attrs->client_data);
        }
      }
      {
#line 886
      tmp___33 = __builtin_va_arg(args, char *);
#line 886
      attrs->client_data = strdup((char const   *)tmp___33);
      }
#line 887
      goto switch_break___0;
      switch_default___0: /* CIL Label */ 
#line 890
      rplay_errno = 9;
#line 891
      return (-1L);
      switch_break___0: /* CIL Label */ ;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  {
#line 896
  tmp___35 = rplay_pack(rp);
  }
#line 896
  return ((long )tmp___35);
}
}
#line 903 "/home/wslee/benchmarks/sound/rplay-3.3.2/librplay/rplay.c"
long rplay_get(RPLAY *rp  , ...) 
{ 
  va_list args ;
  RPLAY_ATTRS *attrs ;
  int get ;
  int index___0 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
  {
#line 916
  __builtin_va_start(args, rp);
#line 922
  rplay_errno = 0;
#line 924
  tmp = __builtin_va_arg(args, long );
#line 924
  get = tmp;
  }
  {
#line 928
  if (get == 7) {
#line 928
    goto case_7;
  }
#line 931
  if (get == 8) {
#line 931
    goto case_8;
  }
#line 934
  if (get == 14) {
#line 934
    goto case_14;
  }
#line 937
  if (get == 26) {
#line 937
    goto case_26;
  }
#line 940
  if (get == 15) {
#line 940
    goto case_15;
  }
#line 943
  if (get == 16) {
#line 943
    goto case_16;
  }
#line 946
  if (get == 28) {
#line 946
    goto case_28;
  }
#line 949
  if (get == 29) {
#line 949
    goto case_29;
  }
#line 952
  if (get == 31) {
#line 952
    goto case_31;
  }
#line 955
  if (get == 30) {
#line 955
    goto case_30;
  }
#line 958
  if (get == 5) {
#line 958
    goto case_5;
  }
#line 968
  if (get == 6) {
#line 968
    goto case_6;
  }
#line 978
  if (get == 13) {
#line 978
    goto case_13;
  }
#line 988
  if (get == 18) {
#line 988
    goto case_18;
  }
#line 998
  if (get == 19) {
#line 998
    goto case_19;
  }
#line 1008
  if (get == 20) {
#line 1008
    goto case_20;
  }
#line 1018
  if (get == 22) {
#line 1018
    goto case_22;
  }
#line 1028
  if (get == 25) {
#line 1028
    goto case_25;
  }
#line 1038
  goto switch_default;
  case_7: /* CIL Label */ 
#line 929
  return ((long )rp->nsounds);
  case_8: /* CIL Label */ 
#line 932
  return ((long )rp->command);
  case_14: /* CIL Label */ 
#line 935
  return ((long )rp->count);
  case_26: /* CIL Label */ 
#line 938
  return ((long )rp->list_name);
  case_15: /* CIL Label */ 
#line 941
  return ((long )rp->priority);
  case_16: /* CIL Label */ 
#line 944
  return ((long )rp->random_sound);
  case_28: /* CIL Label */ 
#line 947
  return ((long )rp->id);
  case_29: /* CIL Label */ 
#line 950
  return ((long )rp->sequence);
  case_31: /* CIL Label */ 
#line 953
  return ((long )rp->data_size);
  case_30: /* CIL Label */ 
#line 956
  return ((long )rp->data);
  case_5: /* CIL Label */ 
  {
#line 959
  tmp___0 = __builtin_va_arg(args, long );
#line 959
  index___0 = tmp___0;
#line 960
  attrs = get_attrs(rp->attrs, index___0);
  }
#line 961
  if ((unsigned long )attrs == (unsigned long )((void *)0)) {
#line 963
    rplay_errno = 11;
#line 964
    return (-1L);
  }
#line 966
  return ((long )attrs->sound);
  case_6: /* CIL Label */ 
  {
#line 969
  tmp___1 = __builtin_va_arg(args, long );
#line 969
  index___0 = tmp___1;
#line 970
  attrs = get_attrs(rp->attrs, index___0);
  }
#line 971
  if ((unsigned long )attrs == (unsigned long )((void *)0)) {
#line 973
    rplay_errno = 11;
#line 974
    return (-1L);
  }
#line 976
  return ((long )attrs->volume);
  case_13: /* CIL Label */ 
  {
#line 979
  tmp___2 = __builtin_va_arg(args, long );
#line 979
  index___0 = tmp___2;
#line 980
  attrs = get_attrs(rp->attrs, index___0);
  }
#line 981
  if ((unsigned long )attrs == (unsigned long )((void *)0)) {
#line 983
    rplay_errno = 11;
#line 984
    return (-1L);
  }
#line 986
  return ((long )attrs->count);
  case_18: /* CIL Label */ 
  {
#line 989
  tmp___3 = __builtin_va_arg(args, long );
#line 989
  index___0 = tmp___3;
#line 990
  attrs = get_attrs(rp->attrs, index___0);
  }
#line 991
  if ((unsigned long )attrs == (unsigned long )((void *)0)) {
#line 993
    rplay_errno = 11;
#line 994
    return (-1L);
  }
#line 996
  return ((long )attrs->rptp_server);
  case_19: /* CIL Label */ 
  {
#line 999
  tmp___4 = __builtin_va_arg(args, long );
#line 999
  index___0 = tmp___4;
#line 1000
  attrs = get_attrs(rp->attrs, index___0);
  }
#line 1001
  if ((unsigned long )attrs == (unsigned long )((void *)0)) {
#line 1003
    rplay_errno = 11;
#line 1004
    return (-1L);
  }
#line 1006
  return ((long )attrs->rptp_server_port);
  case_20: /* CIL Label */ 
  {
#line 1009
  tmp___5 = __builtin_va_arg(args, long );
#line 1009
  index___0 = tmp___5;
#line 1010
  attrs = get_attrs(rp->attrs, index___0);
  }
#line 1011
  if ((unsigned long )attrs == (unsigned long )((void *)0)) {
#line 1013
    rplay_errno = 11;
#line 1014
    return (-1L);
  }
#line 1016
  return ((long )attrs->rptp_search);
  case_22: /* CIL Label */ 
  {
#line 1019
  tmp___6 = __builtin_va_arg(args, long );
#line 1019
  index___0 = tmp___6;
#line 1020
  attrs = get_attrs(rp->attrs, index___0);
  }
#line 1021
  if ((unsigned long )attrs == (unsigned long )((void *)0)) {
#line 1023
    rplay_errno = 11;
#line 1024
    return (-1L);
  }
#line 1026
  return ((long )attrs->sample_rate);
  case_25: /* CIL Label */ 
  {
#line 1029
  tmp___7 = __builtin_va_arg(args, int );
#line 1029
  index___0 = tmp___7;
#line 1030
  attrs = get_attrs(rp->attrs, index___0);
  }
#line 1031
  if ((unsigned long )attrs == (unsigned long )((void *)0)) {
#line 1033
    rplay_errno = 11;
#line 1034
    return (-1L);
  }
#line 1036
  return ((long )attrs->client_data);
  switch_default: /* CIL Label */ 
#line 1039
  rplay_errno = 9;
#line 1040
  return (-1L);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 1048 "/home/wslee/benchmarks/sound/rplay-3.3.2/librplay/rplay.c"
void rplay_destroy(RPLAY *rp ) 
{ 
  RPLAY_ATTRS *p ;
  RPLAY_ATTRS *q ;

  {
#line 1058
  rplay_errno = 0;
#line 1060
  p = rp->attrs;
  {
#line 1060
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1060
    if (! p) {
#line 1060
      goto while_break;
    }
    {
#line 1060
    q = p;
#line 1060
    p = p->next;
#line 1060
    rplay_attrs_destroy(q);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1061
  if (*(rp->list_name)) {
    {
#line 1063
    free((void *)rp->list_name);
    }
  }
#line 1065
  if (rp->data) {
    {
#line 1067
    free((void *)rp->data);
    }
  }
  {
#line 1069
  free((void *)rp->buf);
#line 1070
  free((void *)((char *)rp));
  }
#line 1071
  return;
}
}
#line 1086 "/home/wslee/benchmarks/sound/rplay-3.3.2/librplay/rplay.c"
static char buf___0[8192]  ;
#line 1078 "/home/wslee/benchmarks/sound/rplay-3.3.2/librplay/rplay.c"
char *rplay_convert(char *p ) 
{ 
  char *q ;
  int len ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  size_t tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;

  {
#line 1087
  q = buf___0;
#line 1090
  tmp = q;
#line 1090
  q ++;
#line 1090
  *tmp = (char)30;
#line 1091
  tmp___0 = p;
#line 1091
  p ++;
  {
#line 1093
  if ((int )*tmp___0 == 1) {
#line 1093
    goto case_1;
  }
#line 1097
  if ((int )*tmp___0 == 2) {
#line 1097
    goto case_2;
  }
#line 1101
  if ((int )*tmp___0 == 3) {
#line 1101
    goto case_3;
  }
#line 1105
  if ((int )*tmp___0 == 4) {
#line 1105
    goto case_4;
  }
#line 1091
  goto switch_break;
  case_1: /* CIL Label */ 
#line 1094
  tmp___1 = q;
#line 1094
  q ++;
#line 1094
  *tmp___1 = (char)1;
#line 1095
  goto switch_break;
  case_2: /* CIL Label */ 
#line 1098
  tmp___2 = q;
#line 1098
  q ++;
#line 1098
  *tmp___2 = (char)2;
#line 1099
  goto switch_break;
  case_3: /* CIL Label */ 
#line 1102
  tmp___3 = q;
#line 1102
  q ++;
#line 1102
  *tmp___3 = (char)3;
#line 1103
  goto switch_break;
  case_4: /* CIL Label */ 
#line 1106
  tmp___4 = q;
#line 1106
  q ++;
#line 1106
  *tmp___4 = (char)4;
#line 1107
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 1110
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1112
    tmp___5 = q;
#line 1112
    q ++;
#line 1112
    *tmp___5 = (char)5;
#line 1113
    strcpy((char */* __restrict  */)q, (char const   */* __restrict  */)p);
#line 1114
    tmp___6 = strlen((char const   *)p);
#line 1114
    len = (int )(tmp___6 + 1U);
#line 1115
    p += len;
#line 1116
    q += len;
#line 1117
    tmp___7 = q;
#line 1117
    q ++;
#line 1117
    *tmp___7 = (char)6;
#line 1118
    tmp___8 = q;
#line 1118
    q ++;
#line 1118
    tmp___9 = p;
#line 1118
    p ++;
#line 1118
    *tmp___8 = *tmp___9;
#line 1119
    tmp___10 = q;
#line 1119
    q ++;
#line 1119
    *tmp___10 = (char)0;
    }
#line 1110
    if (! *p) {
#line 1110
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1123
  tmp___11 = q;
#line 1123
  q ++;
#line 1123
  *tmp___11 = (char)0;
#line 1125
  return (buf___0);
}
}
#line 1129 "/home/wslee/benchmarks/sound/rplay-3.3.2/librplay/rplay.c"
static int default_rplay_port(void) 
{ 
  struct servent *sp ;
  int port ;
  uint16_t tmp ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
#line 1135
  sp = getservbyname("rplay", "udp");
  }
#line 1136
  if (sp) {
    {
#line 1138
    tmp = ntohs((uint16_t )sp->s_port);
#line 1138
    port = (int )tmp;
    }
  } else {
#line 1142
    port = 5555;
  }
#line 1145
  return (port);
}
}
#line 1149 "/home/wslee/benchmarks/sound/rplay-3.3.2/librplay/rplay.c"
int rplay_open(char *host ) 
{ 
  int port ;
  int tmp ;

  {
  {
#line 1159
  port = default_rplay_port();
#line 1161
  tmp = rplay_open_port(host, port);
  }
#line 1161
  return (tmp);
}
}
#line 1170 "/home/wslee/benchmarks/sound/rplay-3.3.2/librplay/rplay.c"
int rplay_open_port(char *host , int port ) 
{ 
  struct hostent *hp ;
  u_long addr ;
  struct sockaddr_in s ;
  in_addr_t tmp ;
  int tmp___0 ;

  {
  {
#line 1183
  rplay_errno = 0;
#line 1185
  memset((void *)((char *)(& s)), 0, (size_t )sizeof(s));
#line 1187
  tmp = inet_addr((char const   *)host);
#line 1187
  addr = (u_long )tmp;
  }
#line 1188
  if (addr == 4294967295UL) {
    {
#line 1190
    hp = gethostbyname((char const   *)host);
    }
#line 1191
    if ((unsigned long )hp == (unsigned long )((void *)0)) {
#line 1193
      rplay_errno = 2;
#line 1194
      return (-1);
    }
    {
#line 1196
    memcpy((void */* __restrict  */)((char *)(& s.sin_addr.s_addr)), (void const   */* __restrict  */)*(hp->h_addr_list + 0),
           (size_t )hp->h_length);
    }
  } else {
    {
#line 1200
    memcpy((void */* __restrict  */)((char *)(& s.sin_addr.s_addr)), (void const   */* __restrict  */)((char *)(& addr)),
           (size_t )sizeof(addr));
    }
  }
  {
#line 1203
  s.sin_port = htons((uint16_t )port);
#line 1204
  s.sin_family = (sa_family_t )2;
#line 1206
  tmp___0 = rplay_open_sockaddr_in(& s);
  }
#line 1206
  return (tmp___0);
}
}
#line 1210 "/home/wslee/benchmarks/sound/rplay-3.3.2/librplay/rplay.c"
int rplay_open_sockaddr_in(struct sockaddr_in *saddr ) 
{ 
  int rplay_fd ;
  int on ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 1219
  on = 1;
#line 1221
  rplay_fd = socket(2, 2, 0);
  }
#line 1222
  if (rplay_fd < 0) {
#line 1224
    rplay_errno = 4;
#line 1225
    return (-1);
  }
  {
#line 1231
  tmp = setsockopt(rplay_fd, 1, 6, (void const   *)((char *)(& on)), (socklen_t )sizeof(on));
  }
#line 1231
  if (tmp < 0) {
#line 1233
    rplay_errno = 8;
#line 1234
    return (-1);
  }
  {
#line 1237
  tmp___0 = connect(rplay_fd, (struct sockaddr  const  *)((struct sockaddr *)saddr),
                    (socklen_t )sizeof(*saddr));
  }
#line 1237
  if (tmp___0 < 0) {
#line 1239
    rplay_errno = 3;
#line 1240
    return (-1);
  }
#line 1243
  return (rplay_fd);
}
}
#line 1250 "/home/wslee/benchmarks/sound/rplay-3.3.2/librplay/rplay.c"
int rplay(int rplay_fd , RPLAY *rp ) 
{ 
  ssize_t tmp ;

  {
  {
#line 1259
  rplay_errno = 0;
#line 1261
  tmp = write(rplay_fd, (void const   *)rp->buf, (size_t )rp->len);
  }
#line 1261
  if (tmp != rp->len) {
#line 1263
    rplay_errno = 5;
#line 1264
    return (-1);
  }
#line 1267
  return (0);
}
}
#line 1274 "/home/wslee/benchmarks/sound/rplay-3.3.2/librplay/rplay.c"
int rplay_close(int rplay_fd ) 
{ 
  int tmp ;

  {
  {
#line 1282
  rplay_errno = 0;
#line 1284
  tmp = close(rplay_fd);
  }
#line 1284
  if (tmp < 0) {
#line 1286
    rplay_errno = 6;
#line 1287
    return (-1);
  }
#line 1290
  return (0);
}
}
#line 1297 "/home/wslee/benchmarks/sound/rplay-3.3.2/librplay/rplay.c"
void rplay_perror(char *s ) 
{ 
  char *__cil_tmp2 ;

  {
  {
#line 1305
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s\n",
          s, rplay_errlist[rplay_errno]);
  }
#line 1306
  return;
}
}
#line 1313 "/home/wslee/benchmarks/sound/rplay-3.3.2/librplay/rplay.c"
int rplay_open_display(void) 
{ 
  char *display ;
  char *p ;
  char host[64] ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  void *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;

  {
  {
#line 1323
  display = getenv("DISPLAY");
  }
#line 1324
  if ((unsigned long )display == (unsigned long )((void *)0)) {
    {
#line 1326
    strcpy((char */* __restrict  */)(host), (char const   */* __restrict  */)"localhost");
    }
  } else
#line 1324
  if ((int )*(display + 0) == 58) {
    {
#line 1326
    strcpy((char */* __restrict  */)(host), (char const   */* __restrict  */)"localhost");
    }
  } else {
    {
#line 1330
    strcpy((char */* __restrict  */)(host), (char const   */* __restrict  */)display);
#line 1331
    p = strchr((char const   *)(host), ':');
    }
#line 1332
    if (p) {
#line 1334
      *p = (char )'\000';
    }
    {
#line 1336
    tmp = strcmp((char const   *)(host), "unix");
    }
#line 1336
    if (tmp == 0) {
      {
#line 1338
      strcpy((char */* __restrict  */)(host), (char const   */* __restrict  */)"localhost");
      }
    } else {
      {
#line 1336
      tmp___0 = strcmp((char const   *)(host), "local");
      }
#line 1336
      if (tmp___0 == 0) {
        {
#line 1338
        strcpy((char */* __restrict  */)(host), (char const   */* __restrict  */)"localhost");
        }
      } else {
        {
#line 1336
        tmp___1 = strcmp((char const   *)(host), "X");
        }
#line 1336
        if (tmp___1 == 0) {
          {
#line 1338
          strcpy((char */* __restrict  */)(host), (char const   */* __restrict  */)"localhost");
          }
        }
      }
    }
  }
  {
#line 1342
  tmp___2 = rplay_open(host);
  }
#line 1342
  return (tmp___2);
}
}
#line 1349 "/home/wslee/benchmarks/sound/rplay-3.3.2/librplay/rplay.c"
int rplay_display(char *sound ) 
{ 
  int rplay_fd ;
  int tmp ;

  {
  {
#line 1359
  rplay_fd = rplay_open_display();
  }
#line 1360
  if (rplay_fd < 0) {
#line 1362
    return (-1);
  }
  {
#line 1365
  tmp = rplay_sound(rplay_fd, sound);
  }
#line 1365
  return (tmp);
}
}
#line 1372 "/home/wslee/benchmarks/sound/rplay-3.3.2/librplay/rplay.c"
int rplay_local(char *sound ) 
{ 
  int tmp ;
  char *__cil_tmp3 ;

  {
  {
#line 1380
  tmp = rplay_host((char *)"localhost", sound);
  }
#line 1380
  return (tmp);
}
}
#line 1387 "/home/wslee/benchmarks/sound/rplay-3.3.2/librplay/rplay.c"
int rplay_host(char *host , char *sound ) 
{ 
  int rplay_fd ;
  int tmp ;

  {
  {
#line 1398
  rplay_fd = rplay_open(host);
  }
#line 1399
  if (rplay_fd < 0) {
#line 1401
    return (-1);
  }
  {
#line 1404
  tmp = rplay_sound(rplay_fd, sound);
  }
#line 1404
  return (tmp);
}
}
#line 1411 "/home/wslee/benchmarks/sound/rplay-3.3.2/librplay/rplay.c"
int rplay_sound(int rplay_fd , char *sound ) 
{ 
  RPLAY *rp ;
  long tmp ;
  int tmp___0 ;

  {
  {
#line 1422
  rp = rplay_create(1);
  }
#line 1423
  if ((unsigned long )rp == (unsigned long )((void *)0)) {
#line 1425
    return (-1);
  }
  {
#line 1428
  tmp = rplay_set(rp, 9, 5, sound, (void *)0);
  }
#line 1428
  if (tmp < 0L) {
#line 1430
    return (-1);
  }
  {
#line 1433
  tmp___0 = rplay(rplay_fd, rp);
  }
#line 1433
  if (tmp___0 < 0) {
#line 1435
    return (-1);
  }
  {
#line 1438
  rplay_destroy(rp);
  }
#line 1440
  return (0);
}
}
#line 1447 "/home/wslee/benchmarks/sound/rplay-3.3.2/librplay/rplay.c"
int rplay_ping(char *host ) 
{ 
  int rplay_fd ;
  int port ;
  int error1 ;
  int error2 ;

  {
  {
#line 1457
  error1 = 0;
#line 1457
  error2 = 0;
#line 1460
  port = default_rplay_port();
#line 1461
  rplay_fd = rplay_open_port(host, port);
  }
#line 1462
  if (rplay_fd < 0) {
#line 1464
    return (-1);
  }
  {
#line 1466
  error1 = rplay_ping_sockfd(rplay_fd);
  }
#line 1470
  if (port == 5555) {
#line 1472
    port = 55555;
  } else {
#line 1476
    port = 5555;
  }
  {
#line 1480
  rplay_fd = rplay_open_port(host, port);
  }
#line 1481
  if (rplay_fd < 0) {
#line 1483
    return (-1);
  }
  {
#line 1485
  error2 = rplay_ping_sockfd(rplay_fd);
  }
#line 1489
  if (error1 < 0) {
#line 1489
    if (error2 < 0) {
#line 1491
      return (-1);
    } else {
#line 1495
      return (0);
    }
  } else {
#line 1495
    return (0);
  }
}
}
#line 1500 "/home/wslee/benchmarks/sound/rplay-3.3.2/librplay/rplay.c"
int rplay_ping_sockfd(int rplay_fd ) 
{ 
  RPLAY *rp ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 1510
  rp = rplay_create(17);
  }
#line 1511
  if ((unsigned long )rp == (unsigned long )((void *)0)) {
#line 1513
    return (-1);
  }
  {
#line 1516
  tmp = rplay_pack(rp);
  }
#line 1516
  if (tmp < 0) {
#line 1518
    return (-1);
  }
  {
#line 1521
  tmp___0 = rplay(rplay_fd, rp);
  }
#line 1521
  if (tmp___0 < 0) {
#line 1523
    return (-1);
  }
  {
#line 1526
  rplay_close(rplay_fd);
#line 1527
  rplay_destroy(rp);
  }
#line 1529
  return (0);
}
}
#line 1533 "/home/wslee/benchmarks/sound/rplay-3.3.2/librplay/rplay.c"
int rplay_ping_sockaddr_in(struct sockaddr_in *saddr ) 
{ 
  int rplay_fd ;
  int tmp ;

  {
  {
#line 1543
  rplay_fd = rplay_open_sockaddr_in(saddr);
  }
#line 1544
  if (rplay_fd < 0) {
#line 1546
    return (-1);
  }
  {
#line 1549
  tmp = rplay_ping_sockfd(rplay_fd);
  }
#line 1549
  return (tmp);
}
}
#line 1556 "/home/wslee/benchmarks/sound/rplay-3.3.2/librplay/rplay.c"
int rplay_host_volume(char *host , char *sound , int volume ) 
{ 
  int rplay_fd ;
  RPLAY *rp ;
  long tmp ;
  int tmp___0 ;

  {
  {
#line 1569
  rplay_fd = rplay_open(host);
  }
#line 1570
  if (rplay_fd < 0) {
#line 1572
    return (-1);
  }
  {
#line 1575
  rp = rplay_create(1);
  }
#line 1576
  if ((unsigned long )rp == (unsigned long )((void *)0)) {
#line 1578
    return (-1);
  }
  {
#line 1581
  tmp = rplay_set(rp, 9, 5, sound, 6, volume, (void *)0);
  }
#line 1581
  if (tmp < 0L) {
#line 1583
    return (-1);
  }
  {
#line 1586
  tmp___0 = rplay(rplay_fd, rp);
  }
#line 1586
  if (tmp___0 < 0) {
#line 1588
    return (-1);
  }
  {
#line 1591
  rplay_destroy(rp);
  }
#line 1593
  return (0);
}
}
#line 1600 "/home/wslee/benchmarks/sound/rplay-3.3.2/librplay/rplay.c"
char *rplay_default_host(void) 
{ 
  char *host ;
  char const   *tmp ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;

  {
  {
#line 1609
  host = getenv("RPLAY_HOST");
  }
#line 1611
  if (host) {
#line 1611
    tmp = (char const   *)host;
  } else {
#line 1611
    tmp = "localhost";
  }
#line 1611
  return ((char *)tmp);
}
}
#line 1618 "/home/wslee/benchmarks/sound/rplay-3.3.2/librplay/rplay.c"
int rplay_default(char *sound ) 
{ 
  char *tmp ;
  int tmp___0 ;

  {
  {
#line 1626
  tmp = rplay_default_host();
#line 1626
  tmp___0 = rplay_host(tmp, sound);
  }
#line 1626
  return (tmp___0);
}
}
#line 1633 "/home/wslee/benchmarks/sound/rplay-3.3.2/librplay/rplay.c"
int rplay_open_default(void) 
{ 
  char *tmp ;
  int tmp___0 ;

  {
  {
#line 1640
  tmp = rplay_default_host();
#line 1640
  tmp___0 = rplay_open(tmp);
  }
#line 1640
  return (tmp___0);
}
}
#line 209 "/usr/include/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) stat)(char const   * __restrict  __file ,
                                                                                   struct stat * __restrict  __buf ) ;
#line 145 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 146
extern struct _IO_FILE *stdout ;
#line 214
extern int fclose(FILE *__stream ) ;
#line 219
extern int fflush(FILE *__stream ) ;
#line 249
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 341
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 604
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 682
extern size_t fread(void * __restrict  __ptr , size_t __size , size_t __n , FILE * __restrict  __stream ) ;
#line 688
extern size_t fwrite(void const   * __restrict  __ptr , size_t __size , size_t __n ,
                     FILE * __restrict  __s ) ;
#line 819
extern void perror(char const   *__s ) ;
#line 346 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(2))) strtok)(char * __restrict  __s ,
                                                                                     char const   * __restrict  __delim ) ;
#line 534
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) strcasecmp)(char const   *__s1 ,
                                                                                         char const   *__s2 )  __attribute__((__pure__)) ;
#line 148 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 31 "./../lib/getopt.h"
extern char *optarg ;
#line 45
extern int optind ;
#line 106
extern int getopt_long(int argc , char * const  *argv , char const   *shortopts ,
                       struct option  const  *longopts , int *longind ) ;
#line 56 "/home/wslee/benchmarks/sound/rplay-3.3.2/rptp/rptp.c"
void command_open(int argc , char **argv ) ;
#line 57
void command_close(int argc , char **argv ) ;
#line 58
void command_play(int argc , char **argv ) ;
#line 59
void command_help(int argc , char **argv ) ;
#line 60
void command_list(int argc , char **argv ) ;
#line 61
void command_quit(int argc , char **argv ) ;
#line 62
void command_put(int argc , char **argv ) ;
#line 63
void command_get(int argc , char **argv ) ;
#line 64
void command_unknown(int argc , char **argv ) ;
#line 65
void command_set(int argc , char **argv ) ;
#line 66
void command_status(int argc , char **argv ) ;
#line 67
void command_generic(int argc , char **argv ) ;
#line 68
void command_volume(int argc , char **argv ) ;
#line 69
void command_skip(int argc , char **argv ) ;
#line 71
void command_monitor(int argc , char **argv ) ;
#line 72
void argv_to_command(char **argv ) ;
#line 73
int connected(void) ;
#line 74
void done(int exit_value ) ;
#line 75
void usage(void) ;
#line 76
void do_application(void) ;
#line 77
void do_error(char *response___0 ) ;
#line 102 "/home/wslee/benchmarks/sound/rplay-3.3.2/rptp/rptp.c"
COMMAND commands[22]  = 
#line 102
  {      {(char *)"access", 0, 0, (char *)"", & command_generic}, 
        {(char *)"close", 0, 0, (char *)"", & command_close}, 
        {(char *)"continue", 1, -1, (char *)"#id|sound ...", & command_play}, 
        {(char *)"find", 1, 1, (char *)"sound", & command_generic}, 
        {(char *)"get", 1, 2, (char *)"sound [filename]", & command_get}, 
        {(char *)"help", 0, 1, (char *)"[command]", & command_help}, 
        {(char *)"info", 1, 1, (char *)"sound", & command_generic}, 
        {(char *)"list", 0, 1, (char *)"[connections|hosts|servers|spool|sounds]", & command_list}, 
        {(char *)"monitor",
      0, 0, (char *)"", & command_monitor}, 
        {(char *)"open", 1, 2, (char *)"hostname [port]", & command_open}, 
        {(char *)"pause", 1, -1, (char *)"#id|sound ...", & command_play}, 
        {(char *)"play", 1, -1, (char *)"[options] sound ...", & command_play}, 
        {(char *)"put", 1, 1, (char *)"sound", & command_put}, 
        {(char *)"quit", 0, 0, (char *)"", & command_quit}, 
        {(char *)"reset", 0, 0, (char *)"", & command_generic}, 
        {(char *)"set", 1, -1, (char *)"name=value", & command_set}, 
        {(char *)"skip", 0, 2, (char *)"[#id] [[+|-]count]", & command_skip}, 
        {(char *)"status", 0, 0, (char *)"", & command_status}, 
        {(char *)"stop", 1, -1, (char *)"#id|sound ...", & command_play}, 
        {(char *)"version", 0, 0, (char *)"", & command_generic}, 
        {(char *)"volume", 0, 1, (char *)"[[+|-]volume]", & command_volume}, 
        {(char *)"wait", 1, -1, (char *)"#id|command|event-list", & command_generic}};
#line 130 "/home/wslee/benchmarks/sound/rplay-3.3.2/rptp/rptp.c"
static struct option longopts[7]  = {      {"help", 0, (int *)((void *)0), 1}, 
        {"host", 1, (int *)((void *)0), 'h'}, 
        {"port", 1, (int *)((void *)0), 'p'}, 
        {"prompt", 1, (int *)((void *)0), 2}, 
        {"raw", 0, (int *)((void *)0), 'r'}, 
        {"version", 0, (int *)((void *)0), 'v'}, 
        {(char const   *)((void *)0), 0, (int *)((void *)0), 0}};
#line 141 "/home/wslee/benchmarks/sound/rplay-3.3.2/rptp/rptp.c"
int rptp_fd  =    -1;
#line 142 "/home/wslee/benchmarks/sound/rplay-3.3.2/rptp/rptp.c"
char rptp_buf[4096]  ;
#line 143 "/home/wslee/benchmarks/sound/rplay-3.3.2/rptp/rptp.c"
char command[1024]  ;
#line 144 "/home/wslee/benchmarks/sound/rplay-3.3.2/rptp/rptp.c"
char response[1024]  ;
#line 145 "/home/wslee/benchmarks/sound/rplay-3.3.2/rptp/rptp.c"
char *prompt  =    (char *)"rptp> ";
#line 146 "/home/wslee/benchmarks/sound/rplay-3.3.2/rptp/rptp.c"
int interactive  =    1;
#line 147 "/home/wslee/benchmarks/sound/rplay-3.3.2/rptp/rptp.c"
int raw  =    0;
#line 153 "/home/wslee/benchmarks/sound/rplay-3.3.2/rptp/rptp.c"
int main(int argc , char **argv ) 
{ 
  char buf___1[256] ;
  int i ;
  int port ;
  int c ;
  char *av[32] ;
  char *p ;
  char *host ;
  int ac ;
  int first ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;
  int i___0 ;
  int tmp___5 ;
  int tmp___6 ;
  void *__cil_tmp22 ;
  void *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;

  {
#line 162
  port = 5556;
#line 164
  host = (char *)((void *)0);
  {
#line 168
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 168
    c = getopt_long(argc, (char * const  *)argv, "+h:p:rv", (struct option  const  *)(longopts),
                    (int *)0);
    }
#line 168
    if (! (c != -1)) {
#line 168
      goto while_break;
    }
    {
#line 172
    if (c == 0) {
#line 172
      goto case_0;
    }
#line 176
    if (c == 1) {
#line 176
      goto case_1;
    }
#line 180
    if (c == 2) {
#line 180
      goto case_2;
    }
#line 184
    if (c == 104) {
#line 184
      goto case_104;
    }
#line 188
    if (c == 112) {
#line 188
      goto case_112;
    }
#line 192
    if (c == 114) {
#line 192
      goto case_114;
    }
#line 196
    if (c == 118) {
#line 196
      goto case_118;
    }
#line 200
    goto switch_default;
    case_0: /* CIL Label */ 
#line 174
    goto switch_break;
    case_1: /* CIL Label */ 
    {
#line 177
    usage();
#line 178
    done(0);
    }
    case_2: /* CIL Label */ 
#line 181
    prompt = optarg;
#line 182
    goto switch_break;
    case_104: /* CIL Label */ 
#line 185
    host = optarg;
#line 186
    goto switch_break;
    case_112: /* CIL Label */ 
    {
#line 189
    port = atoi((char const   *)optarg);
    }
#line 190
    goto switch_break;
    case_114: /* CIL Label */ 
#line 193
    raw ++;
#line 194
    goto switch_break;
    case_118: /* CIL Label */ 
    {
#line 197
    printf((char const   */* __restrict  */)"rplay %s\n", "3.3.2");
#line 198
    done(0);
    }
    switch_default: /* CIL Label */ 
    {
#line 201
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Try `rptp --help\' for more information.\n");
#line 202
    exit(1);
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 206
  if (optind != argc) {
#line 208
    interactive = 0;
  }
#line 211
  if ((unsigned long )host == (unsigned long )((void *)0)) {
    {
#line 213
    host = rplay_default_host();
    }
  }
  {
#line 216
  rptp_fd = rptp_open(host, port, response, (int )sizeof(response));
  }
#line 217
  if (rptp_fd < 0) {
    {
#line 219
    rptp_perror((char *)"open");
    }
  } else
#line 221
  if (interactive) {
#line 223
    if (raw) {
      {
#line 225
      printf((char const   */* __restrict  */)"%s\n", response);
      }
    } else {
      {
#line 229
      tmp___1 = strchr((char const   *)(response), '=');
      }
#line 229
      if (tmp___1) {
        {
#line 231
        rptp_parse(response, (char *)0);
#line 232
        tmp = rptp_parse((char *)0, (char *)"version");
#line 232
        tmp___0 = rptp_parse((char *)0, (char *)"host");
#line 232
        printf((char const   */* __restrict  */)"%s rplayd %s connected\n", tmp___0,
               tmp);
        }
      } else {
        {
#line 238
        printf((char const   */* __restrict  */)"Connected to %s port %d.\n", host,
               port);
#line 239
        printf((char const   */* __restrict  */)"%s\n", response + 1);
        }
      }
    }
  }
  {
#line 244
  do_application();
  }
  {
#line 246
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 248
    if (interactive) {
#line 250
      if (! raw) {
        {
#line 261
        printf((char const   */* __restrict  */)prompt);
#line 262
        fflush(stdout);
        }
      }
      {
#line 267
      tmp___2 = fgets((char */* __restrict  */)(buf___1), (int )sizeof(buf___1), (FILE */* __restrict  */)stdin);
      }
#line 267
      if ((unsigned long )tmp___2 == (unsigned long )((void *)0)) {
        {
#line 269
        done(0);
        }
      }
#line 272
      first = 1;
#line 273
      ac = 0;
      {
#line 274
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 274
        if (first) {
#line 274
          tmp___4 = buf___1;
        } else {
#line 274
          tmp___4 = (char *)((void *)0);
        }
        {
#line 274
        p = strtok((char */* __restrict  */)tmp___4, (char const   */* __restrict  */)" \t\r\n");
        }
#line 274
        if (! p) {
#line 274
          goto while_break___1;
        }
#line 276
        tmp___3 = ac;
#line 276
        ac ++;
#line 276
        av[tmp___3] = p;
#line 277
        first = 0;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 279
      av[ac] = (char *)((void *)0);
    } else {
#line 285
      ac = 0;
#line 286
      i___0 = optind;
      {
#line 286
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 286
        if (! (i___0 < argc)) {
#line 286
          goto while_break___2;
        }
#line 288
        tmp___5 = ac;
#line 288
        ac ++;
#line 288
        av[tmp___5] = *(argv + i___0);
#line 286
        i___0 ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 290
      av[ac] = (char *)((void *)0);
    }
#line 293
    if ((unsigned long )av[0] == (unsigned long )((void *)0)) {
#line 295
      goto __Cont;
    }
#line 298
    i = 0;
    {
#line 298
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 298
      if (! ((unsigned long )i < sizeof(commands) / sizeof(COMMAND ))) {
#line 298
        goto while_break___3;
      }
      {
#line 300
      tmp___6 = strcasecmp((char const   *)commands[i].name, (char const   *)av[0]);
      }
#line 300
      if (tmp___6 == 0) {
#line 302
        if (commands[i].min_args >= 0) {
#line 302
          if (ac - 1 < commands[i].min_args) {
            {
#line 305
            printf((char const   */* __restrict  */)"Usage: %s %s\n", commands[i].name,
                   commands[i].usage);
            }
          } else {
#line 302
            goto _L;
          }
        } else
        _L: /* CIL Label */ 
#line 302
        if (commands[i].max_args >= 0) {
#line 302
          if (ac - 1 > commands[i].max_args) {
            {
#line 305
            printf((char const   */* __restrict  */)"Usage: %s %s\n", commands[i].name,
                   commands[i].usage);
            }
          } else {
            {
#line 309
            (*(commands[i].func))(ac, av);
            }
          }
        } else {
          {
#line 309
          (*(commands[i].func))(ac, av);
          }
        }
#line 311
        goto while_break___3;
      }
#line 298
      i ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 314
    if ((unsigned long )i == sizeof(commands) / sizeof(COMMAND )) {
      {
#line 316
      command_unknown(ac, av);
      }
    }
    __Cont: /* CIL Label */ 
#line 246
    if (! interactive) {
#line 246
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 321
  done(0);
  }
#line 322
  return (0);
}
}
#line 325 "/home/wslee/benchmarks/sound/rplay-3.3.2/rptp/rptp.c"
void argv_to_command(char **argv ) 
{ 
  char *__cil_tmp2 ;

  {
#line 333
  command[0] = (char )'\000';
  {
#line 334
  while (1) {
    while_continue: /* CIL Label */ ;
#line 334
    if (! *argv) {
#line 334
      goto while_break;
    }
    {
#line 336
    strcat((char */* __restrict  */)(command), (char const   */* __restrict  */)*argv);
    }
#line 337
    if (*(argv + 1)) {
      {
#line 339
      strcat((char */* __restrict  */)(command), (char const   */* __restrict  */)" ");
      }
    }
#line 334
    argv ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 342
  return;
}
}
#line 344 "/home/wslee/benchmarks/sound/rplay-3.3.2/rptp/rptp.c"
int connected(void) 
{ 
  char *__cil_tmp1 ;

  {
#line 347
  if (rptp_fd != -1) {
#line 349
    return (1);
  } else {
    {
#line 353
    printf((char const   */* __restrict  */)"You\'re not connected, use `open\' first.\n");
    }
#line 354
    return (0);
  }
}
}
#line 359 "/home/wslee/benchmarks/sound/rplay-3.3.2/rptp/rptp.c"
void command_open(int argc , char **argv ) 
{ 
  int port ;
  int tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
#line 370
  if (rptp_fd != -1) {
    {
#line 372
    printf((char const   */* __restrict  */)"You\'re already connected, use `close\' first.\n");
    }
  } else {
#line 376
    if (argc == 3) {
      {
#line 376
      tmp = atoi((char const   *)*(argv + 2));
#line 376
      port = tmp;
      }
    } else {
#line 376
      port = 5556;
    }
    {
#line 377
    rptp_fd = rptp_open(*(argv + 1), port, response, (int )sizeof(response));
    }
#line 378
    if (rptp_fd < 0) {
      {
#line 380
      rptp_perror((char *)"open");
      }
    } else {
#line 384
      if (raw) {
        {
#line 386
        printf((char const   */* __restrict  */)"%s\n", response);
        }
      } else {
        {
#line 390
        tmp___2 = strchr((char const   *)(response), '=');
        }
#line 390
        if (tmp___2) {
          {
#line 392
          tmp___0 = rptp_parse((char *)0, (char *)"version");
#line 392
          tmp___1 = rptp_parse(response, (char *)"host");
#line 392
          printf((char const   */* __restrict  */)"%s rplayd %s connected\n", tmp___1,
                 tmp___0);
          }
        } else {
          {
#line 398
          printf((char const   */* __restrict  */)"Connected to %s port %d.\n", *(argv + 1),
                 port);
#line 399
          printf((char const   */* __restrict  */)"%s\n", response + 1);
          }
        }
      }
      {
#line 402
      do_application();
      }
    }
  }
#line 405
  return;
}
}
#line 408 "/home/wslee/benchmarks/sound/rplay-3.3.2/rptp/rptp.c"
void command_close(int argc , char **argv ) 
{ 
  int tmp ;
  char *__cil_tmp4 ;

  {
  {
#line 417
  tmp = connected();
  }
#line 417
  if (tmp) {
    {
#line 419
    rptp_close(rptp_fd);
#line 420
    rptp_fd = -1;
    }
#line 421
    if (interactive) {
      {
#line 423
      printf((char const   */* __restrict  */)"Connection closed.\n");
      }
    }
  }
#line 426
  return;
}
}
#line 429 "/home/wslee/benchmarks/sound/rplay-3.3.2/rptp/rptp.c"
void command_play(int argc , char **argv ) 
{ 
  int tmp ;
  int tmp___0 ;
  char *__cil_tmp5 ;

  {
  {
#line 438
  argv_to_command(argv);
#line 440
  tmp = connected();
  }
#line 440
  if (! tmp) {
#line 442
    return;
  }
  {
#line 445
  tmp___0 = rptp_command(rptp_fd, command, response, (int )sizeof(response));
  }
  {
#line 447
  if (tmp___0 == -1) {
#line 447
    goto case_neg_1;
  }
#line 452
  if (tmp___0 == 1) {
#line 452
    goto case_1;
  }
#line 456
  if (tmp___0 == 0) {
#line 456
    goto case_0;
  }
#line 445
  goto switch_break;
  case_neg_1: /* CIL Label */ 
  {
#line 448
  rptp_perror(*(argv + 0));
#line 449
  command_close(argc, argv);
  }
#line 450
  return;
  case_1: /* CIL Label */ 
  {
#line 453
  do_error(response);
  }
#line 454
  return;
  case_0: /* CIL Label */ 
#line 457
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 460
  if (raw) {
    {
#line 462
    printf((char const   */* __restrict  */)"%s\n", response);
    }
  }
#line 464
  return;
}
}
#line 467 "/home/wslee/benchmarks/sound/rplay-3.3.2/rptp/rptp.c"
void command_generic(int argc , char **argv ) 
{ 
  int tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  char *__cil_tmp6 ;

  {
  {
#line 476
  argv_to_command(argv);
#line 478
  tmp = connected();
  }
#line 478
  if (! tmp) {
#line 480
    return;
  }
  {
#line 483
  tmp___0 = rptp_command(rptp_fd, command, response, (int )sizeof(response));
  }
  {
#line 485
  if (tmp___0 == -1) {
#line 485
    goto case_neg_1;
  }
#line 490
  if (tmp___0 == 1) {
#line 490
    goto case_1;
  }
#line 494
  if (tmp___0 == 0) {
#line 494
    goto case_0;
  }
#line 483
  goto switch_break;
  case_neg_1: /* CIL Label */ 
  {
#line 486
  rptp_perror(*(argv + 0));
#line 487
  command_close(argc, argv);
  }
#line 488
  return;
  case_1: /* CIL Label */ 
  {
#line 491
  do_error(response);
  }
#line 492
  return;
  case_0: /* CIL Label */ 
#line 495
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 498
  if (raw) {
#line 498
    tmp___1 = response;
  } else {
#line 498
    tmp___1 = response + 1;
  }
  {
#line 498
  printf((char const   */* __restrict  */)"%s\n", tmp___1);
  }
#line 499
  return;
}
}
#line 502 "/home/wslee/benchmarks/sound/rplay-3.3.2/rptp/rptp.c"
void command_help(int argc , char **argv ) 
{ 
  int i ;
  int tmp ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;

  {
#line 513
  if (argc == 2) {
#line 515
    i = 0;
    {
#line 515
    while (1) {
      while_continue: /* CIL Label */ ;
#line 515
      if (! ((unsigned long )i < sizeof(commands) / sizeof(COMMAND ))) {
#line 515
        goto while_break;
      }
      {
#line 517
      tmp = strcasecmp((char const   *)commands[i].name, (char const   *)*(argv + 1));
      }
#line 517
      if (tmp == 0) {
        {
#line 519
        printf((char const   */* __restrict  */)"Usage: %s %s\n", commands[i].name,
               commands[i].usage);
        }
#line 520
        return;
      }
#line 515
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 523
    command_unknown(argc, argv);
    }
  } else {
    {
#line 527
    printf((char const   */* __restrict  */)"access   Display remote access permissions.\n");
#line 528
    printf((char const   */* __restrict  */)"close    Close the current server connection.\n");
#line 529
    printf((char const   */* __restrict  */)"continue Continue paused sounds.\n");
#line 530
    printf((char const   */* __restrict  */)"find     Search for a sound.\n");
#line 531
    printf((char const   */* __restrict  */)"get      Retrieve a sound.\n");
#line 532
    printf((char const   */* __restrict  */)"help     Display help information.\n");
#line 533
    printf((char const   */* __restrict  */)"info     Display sound information.\n");
#line 534
    printf((char const   */* __restrict  */)"list     Display various server information.\n");
#line 535
    printf((char const   */* __restrict  */)"open     Connect to a server.\n");
#line 536
    printf((char const   */* __restrict  */)"pause    Pause sounds that are playing.\n");
#line 537
    printf((char const   */* __restrict  */)"play     Play sounds\n");
#line 538
    printf((char const   */* __restrict  */)"put      Send a sound.\n");
#line 539
    printf((char const   */* __restrict  */)"quit     Terminate the rptp session.\n");
#line 540
    printf((char const   */* __restrict  */)"reset    Tell the server to reset itself.\n");
#line 541
    printf((char const   */* __restrict  */)"set      Change server settings.\n");
#line 542
    printf((char const   */* __restrict  */)"skip     Skip sounds in a sound list.\n");
#line 543
    printf((char const   */* __restrict  */)"status   Display server statistics.\n");
#line 544
    printf((char const   */* __restrict  */)"stop     Stop sounds that are playing.\n");
#line 545
    printf((char const   */* __restrict  */)"version  Display the version of the server.\n");
#line 546
    printf((char const   */* __restrict  */)"volume   Get and set the volume of the audio device.\n");
#line 547
    printf((char const   */* __restrict  */)"wait     Wait for a spool id, volume change, or command execution.\n");
    }
  }
#line 549
  return;
}
}
#line 552 "/home/wslee/benchmarks/sound/rplay-3.3.2/rptp/rptp.c"
void command_list(int argc , char **argv ) 
{ 
  int n ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
  {
#line 563
  tmp = connected();
  }
#line 563
  if (! tmp) {
#line 565
    return;
  }
  {
#line 568
  argv_to_command(argv);
#line 570
  tmp___0 = rptp_command(rptp_fd, command, response, (int )sizeof(response));
  }
  {
#line 572
  if (tmp___0 == -1) {
#line 572
    goto case_neg_1;
  }
#line 577
  if (tmp___0 == 1) {
#line 577
    goto case_1;
  }
#line 581
  if (tmp___0 == 0) {
#line 581
    goto case_0;
  }
#line 570
  goto switch_break;
  case_neg_1: /* CIL Label */ 
  {
#line 573
  rptp_perror(*(argv + 0));
#line 574
  command_close(argc, argv);
  }
#line 575
  return;
  case_1: /* CIL Label */ 
  {
#line 578
  do_error(response);
  }
#line 579
  return;
  case_0: /* CIL Label */ 
#line 582
  if (raw) {
    {
#line 584
    printf((char const   */* __restrict  */)"%s\n", response);
    }
  }
#line 586
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 589
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 591
    n = rptp_getline(rptp_fd, rptp_buf, (int )sizeof(rptp_buf));
    }
#line 592
    if (n < 0) {
      {
#line 594
      rptp_perror((char *)"list");
#line 595
      command_close(argc, argv);
      }
#line 596
      goto while_break;
    }
    {
#line 598
    tmp___1 = strcmp((char const   *)(rptp_buf), ".");
    }
#line 598
    if (tmp___1 == 0) {
#line 600
      if (raw) {
        {
#line 602
        printf((char const   */* __restrict  */)"%s\n", rptp_buf);
        }
      }
#line 604
      goto while_break;
    }
    {
#line 606
    printf((char const   */* __restrict  */)"%s\n", rptp_buf);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 608
  return;
}
}
#line 611 "/home/wslee/benchmarks/sound/rplay-3.3.2/rptp/rptp.c"
void command_quit(int argc , char **argv ) 
{ 
  char *__cil_tmp3 ;

  {
#line 620
  if (rptp_fd != -1) {
    {
#line 622
    rptp_close(rptp_fd);
#line 623
    printf((char const   */* __restrict  */)"Connection closed.\n");
    }
  }
  {
#line 625
  done(0);
  }
#line 626
  return;
}
}
#line 629 "/home/wslee/benchmarks/sound/rplay-3.3.2/rptp/rptp.c"
void command_put(int argc , char **argv ) 
{ 
  FILE *fp ;
  int size ;
  int n ;
  int nwritten ;
  struct stat st ;
  char line___0[1024] ;
  int total_size ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  void *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;

  {
  {
#line 644
  tmp = connected();
  }
#line 644
  if (! tmp) {
#line 646
    return;
  }
  {
#line 649
  tmp___0 = stat((char const   */* __restrict  */)*(argv + 1), (struct stat */* __restrict  */)(& st));
  }
#line 649
  if (tmp___0 < 0) {
    {
#line 651
    perror((char const   *)*(argv + 1));
    }
#line 652
    return;
  }
  {
#line 654
  fp = fopen((char const   */* __restrict  */)*(argv + 1), (char const   */* __restrict  */)"r");
  }
#line 655
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
    {
#line 657
    perror((char const   *)*(argv + 1));
    }
#line 658
    return;
  }
  {
#line 660
  size = (int )st.st_size;
#line 662
  sprintf((char */* __restrict  */)(line___0), (char const   */* __restrict  */)"put sound=%s size=%d",
          *(argv + 1), size);
#line 664
  tmp___1 = rptp_command(rptp_fd, line___0, response, (int )sizeof(response));
  }
  {
#line 666
  if (tmp___1 == -1) {
#line 666
    goto case_neg_1;
  }
#line 671
  if (tmp___1 == 1) {
#line 671
    goto case_1;
  }
#line 675
  if (tmp___1 == 0) {
#line 675
    goto case_0;
  }
#line 664
  goto switch_break;
  case_neg_1: /* CIL Label */ 
  {
#line 667
  rptp_perror(*(argv + 0));
#line 668
  command_close(argc, argv);
  }
#line 669
  return;
  case_1: /* CIL Label */ 
  {
#line 672
  do_error(response);
  }
#line 673
  return;
  case_0: /* CIL Label */ 
#line 676
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 679
  if (raw) {
    {
#line 681
    printf((char const   */* __restrict  */)"%s\n", response);
    }
  }
#line 684
  total_size = size;
  {
#line 685
  while (1) {
    while_continue: /* CIL Label */ ;
#line 685
    if (! (size > 0)) {
#line 685
      goto while_break;
    }
    {
#line 687
    tmp___2 = fread((void */* __restrict  */)(rptp_buf), (size_t )1, (size_t )sizeof(rptp_buf),
                    (FILE */* __restrict  */)fp);
#line 687
    n = (int )tmp___2;
#line 688
    nwritten = rptp_write(rptp_fd, rptp_buf, n);
    }
#line 689
    if (nwritten != n) {
      {
#line 691
      rptp_perror((char *)"put");
#line 692
      command_close(argc, argv);
      }
#line 693
      goto while_break;
    }
    {
#line 695
    size -= nwritten;
#line 697
    sprintf((char */* __restrict  */)(line___0), (char const   */* __restrict  */)"\r%s %d/%d %d%%",
            *(argv + 1), total_size - size, total_size, (int )(((float )(total_size - size) / (float )total_size) * (float )100));
#line 700
    tmp___3 = strlen((char const   *)(line___0));
#line 700
    write(2, line___0, tmp___3);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 702
  write(2, "\n", 1);
#line 703
  fclose(fp);
  }
#line 704
  return;
}
}
#line 707 "/home/wslee/benchmarks/sound/rplay-3.3.2/rptp/rptp.c"
void command_get(int argc , char **argv ) 
{ 
  FILE *fp ;
  char *filename ;
  char *p ;
  int size ;
  int n ;
  int nread ;
  int total_size ;
  char line___0[1024] ;
  int tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  size_t tmp___4 ;
  void *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;

  {
  {
#line 722
  tmp = connected();
  }
#line 722
  if (! tmp) {
#line 724
    return;
  }
#line 727
  if (argc == 3) {
#line 729
    filename = *(argv + 2);
#line 730
    *(argv + 2) = (char *)((void *)0);
  } else {
#line 734
    filename = *(argv + 1);
  }
  {
#line 737
  sprintf((char */* __restrict  */)(line___0), (char const   */* __restrict  */)"get sound=%s",
          *(argv + 1));
#line 739
  tmp___0 = rptp_command(rptp_fd, line___0, response, (int )sizeof(response));
  }
  {
#line 741
  if (tmp___0 == -1) {
#line 741
    goto case_neg_1;
  }
#line 746
  if (tmp___0 == 1) {
#line 746
    goto case_1;
  }
#line 750
  if (tmp___0 == 0) {
#line 750
    goto case_0;
  }
#line 739
  goto switch_break;
  case_neg_1: /* CIL Label */ 
  {
#line 742
  rptp_perror(*(argv + 0));
#line 743
  command_close(argc, argv);
  }
#line 744
  return;
  case_1: /* CIL Label */ 
  {
#line 747
  do_error(response);
  }
#line 748
  return;
  case_0: /* CIL Label */ 
#line 751
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 754
  if (raw) {
    {
#line 755
    printf((char const   */* __restrict  */)"%s\n", response);
    }
  }
  {
#line 757
  fp = fopen((char const   */* __restrict  */)filename, (char const   */* __restrict  */)"w");
  }
#line 758
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
    {
#line 760
    perror((char const   *)filename);
    }
#line 761
    return;
  }
  {
#line 764
  tmp___3 = strchr((char const   *)(response), '=');
  }
#line 764
  if (tmp___3) {
    {
#line 766
    tmp___1 = rptp_parse(response, (char *)"size");
#line 766
    size = atoi((char const   *)tmp___1);
    }
  } else {
    {
#line 770
    p = strtok((char */* __restrict  */)(response + 1), (char const   */* __restrict  */)" ");
#line 771
    tmp___2 = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)"\r\n");
#line 771
    size = atoi((char const   *)tmp___2);
    }
  }
#line 774
  total_size = size;
  {
#line 775
  while (1) {
    while_continue: /* CIL Label */ ;
#line 775
    if (! (size > 0)) {
#line 775
      goto while_break;
    }
#line 777
    if (sizeof(rptp_buf) < (unsigned long )size) {
#line 777
      n = (int )sizeof(rptp_buf);
    } else {
#line 777
      n = size;
    }
    {
#line 778
    nread = rptp_read(rptp_fd, rptp_buf, n);
    }
#line 779
    if (nread != n) {
      {
#line 781
      rptp_perror((char *)"get");
      }
#line 782
      goto while_break;
    }
    {
#line 784
    fwrite((void const   */* __restrict  */)(rptp_buf), (size_t )1, (size_t )n, (FILE */* __restrict  */)fp);
#line 785
    size -= n;
#line 787
    sprintf((char */* __restrict  */)(line___0), (char const   */* __restrict  */)"\r%s %d/%d %d%%",
            filename, total_size - size, total_size, (int )(((float )(total_size - size) / (float )total_size) * (float )100));
#line 790
    tmp___4 = strlen((char const   *)(line___0));
#line 790
    write(2, line___0, tmp___4);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 792
  write(2, "\n", 1);
#line 793
  fclose(fp);
  }
#line 794
  return;
}
}
#line 797 "/home/wslee/benchmarks/sound/rplay-3.3.2/rptp/rptp.c"
void command_unknown(int argc , char **argv ) 
{ 
  char *__cil_tmp3 ;

  {
  {
#line 806
  printf((char const   */* __restrict  */)"unknown command `%s\'.\n", *(argv + 0));
  }
#line 807
  return;
}
}
#line 810 "/home/wslee/benchmarks/sound/rplay-3.3.2/rptp/rptp.c"
void command_status(int argc , char **argv ) 
{ 
  int tmp ;
  int tmp___0 ;
  int first ;
  char *name ;
  char *value ;
  char *tmp___1 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
  {
#line 819
  argv_to_command(argv);
#line 821
  tmp = connected();
  }
#line 821
  if (! tmp) {
#line 823
    return;
  }
  {
#line 826
  tmp___0 = rptp_command(rptp_fd, command, response, (int )sizeof(response));
  }
  {
#line 828
  if (tmp___0 == -1) {
#line 828
    goto case_neg_1;
  }
#line 833
  if (tmp___0 == 1) {
#line 833
    goto case_1;
  }
#line 837
  if (tmp___0 == 0) {
#line 837
    goto case_0;
  }
#line 826
  goto switch_break;
  case_neg_1: /* CIL Label */ 
  {
#line 829
  rptp_perror(*(argv + 0));
#line 830
  command_close(argc, argv);
  }
#line 831
  return;
  case_1: /* CIL Label */ 
  {
#line 834
  do_error(response);
  }
#line 835
  return;
  case_0: /* CIL Label */ 
#line 838
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 841
  if (raw) {
    {
#line 843
    printf((char const   */* __restrict  */)"%s\n", response);
    }
  } else {
#line 847
    first = 1;
    {
#line 850
    while (1) {
      while_continue: /* CIL Label */ ;
#line 850
      if (first) {
#line 850
        tmp___1 = response;
      } else {
#line 850
        tmp___1 = (char *)0;
      }
      {
#line 850
      name = rptp_parse(tmp___1, (char *)0);
      }
#line 850
      if (! name) {
#line 850
        goto while_break;
      }
      {
#line 852
      first = 0;
#line 853
      value = rptp_parse((char *)0, name);
#line 854
      printf((char const   */* __restrict  */)"%s=%s\n", name, value);
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 857
  return;
}
}
#line 860 "/home/wslee/benchmarks/sound/rplay-3.3.2/rptp/rptp.c"
void command_volume(int argc , char **argv ) 
{ 
  char *volume ;
  int tmp ;
  int tmp___0 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
  {
#line 871
  tmp = connected();
  }
#line 871
  if (! tmp) {
#line 873
    return;
  }
#line 876
  if (argc == 2) {
    {
#line 878
    sprintf((char */* __restrict  */)(command), (char const   */* __restrict  */)"set volume=%s",
            *(argv + 1));
    }
  } else {
    {
#line 882
    sprintf((char */* __restrict  */)(command), (char const   */* __restrict  */)"set volume");
    }
  }
  {
#line 885
  tmp___0 = rptp_command(rptp_fd, command, response, (int )sizeof(response));
  }
  {
#line 887
  if (tmp___0 == -1) {
#line 887
    goto case_neg_1;
  }
#line 892
  if (tmp___0 == 1) {
#line 892
    goto case_1;
  }
#line 896
  if (tmp___0 == 0) {
#line 896
    goto case_0;
  }
#line 885
  goto switch_break;
  case_neg_1: /* CIL Label */ 
  {
#line 888
  rptp_perror(*(argv + 0));
#line 889
  command_close(argc, argv);
  }
#line 890
  return;
  case_1: /* CIL Label */ 
  {
#line 893
  do_error(response);
  }
#line 894
  return;
  case_0: /* CIL Label */ 
#line 897
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 900
  volume = rptp_parse(response, (char *)"volume");
  }
#line 901
  if (volume) {
#line 901
    if (*volume) {
      {
#line 903
      printf((char const   */* __restrict  */)"volume=%s\n", volume);
      }
    } else {
      {
#line 907
      printf((char const   */* __restrict  */)"unknown response `%s\'\n", response);
      }
    }
  } else {
    {
#line 907
    printf((char const   */* __restrict  */)"unknown response `%s\'\n", response);
    }
  }
#line 909
  return;
}
}
#line 912 "/home/wslee/benchmarks/sound/rplay-3.3.2/rptp/rptp.c"
void command_skip(int argc , char **argv ) 
{ 
  char *value ;
  int tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
  {
#line 923
  tmp = connected();
  }
#line 923
  if (! tmp) {
#line 925
    return;
  }
  {
#line 928
  tmp___0 = strchr((char const   *)(command), '=');
  }
#line 928
  if (! tmp___0) {
#line 932
    if (argc == 3) {
      {
#line 934
      sprintf((char */* __restrict  */)(command), (char const   */* __restrict  */)"skip id=%s count=%s",
              *(argv + 1), *(argv + 2));
      }
    } else
#line 936
    if (argc == 2) {
      {
#line 938
      sprintf((char */* __restrict  */)(command), (char const   */* __restrict  */)"skip id=%s count=1",
              *(argv + 1));
      }
    } else {
      {
#line 942
      sprintf((char */* __restrict  */)(command), (char const   */* __restrict  */)"skip id=#0 count=1");
      }
    }
  }
  {
#line 945
  tmp___1 = rptp_command(rptp_fd, command, response, (int )sizeof(response));
  }
  {
#line 947
  if (tmp___1 == -1) {
#line 947
    goto case_neg_1;
  }
#line 952
  if (tmp___1 == 1) {
#line 952
    goto case_1;
  }
#line 956
  if (tmp___1 == 0) {
#line 956
    goto case_0;
  }
#line 945
  goto switch_break;
  case_neg_1: /* CIL Label */ 
  {
#line 948
  rptp_perror(*(argv + 0));
#line 949
  command_close(argc, argv);
  }
#line 950
  return;
  case_1: /* CIL Label */ 
  {
#line 953
  do_error(response);
  }
#line 954
  return;
  case_0: /* CIL Label */ 
#line 957
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 960
  value = rptp_parse(response, (char *)"message");
  }
#line 961
  if (value) {
#line 961
    if (*value) {
      {
#line 963
      printf((char const   */* __restrict  */)"%s\n", value);
      }
    } else {
      {
#line 967
      printf((char const   */* __restrict  */)"unknown response `%s\'\n", response);
      }
    }
  } else {
    {
#line 967
    printf((char const   */* __restrict  */)"unknown response `%s\'\n", response);
    }
  }
#line 969
  return;
}
}
#line 972 "/home/wslee/benchmarks/sound/rplay-3.3.2/rptp/rptp.c"
void command_set(int argc , char **argv ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
#line 983
  tmp = connected();
  }
#line 983
  if (! tmp) {
#line 985
    return;
  }
  {
#line 988
  argv_to_command(argv);
#line 990
  tmp___0 = rptp_command(rptp_fd, command, response, (int )sizeof(response));
  }
  {
#line 992
  if (tmp___0 == -1) {
#line 992
    goto case_neg_1;
  }
#line 997
  if (tmp___0 == 1) {
#line 997
    goto case_1;
  }
#line 1001
  if (tmp___0 == 0) {
#line 1001
    goto case_0;
  }
#line 990
  goto switch_break;
  case_neg_1: /* CIL Label */ 
  {
#line 993
  rptp_perror(*(argv + 0));
#line 994
  command_close(argc, argv);
  }
#line 995
  return;
  case_1: /* CIL Label */ 
  {
#line 998
  do_error(response);
  }
#line 999
  return;
  case_0: /* CIL Label */ 
#line 1002
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1004
  return;
}
}
#line 1007 "/home/wslee/benchmarks/sound/rplay-3.3.2/rptp/rptp.c"
void command_monitor(int argc , char **argv ) 
{ 
  char *p ;
  char buf___1[8192] ;
  int n ;
  int size ;
  int sample_rate ;
  int precision ;
  int channels ;
  int sample_size ;
  int tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  char const   *tmp___2 ;
  void *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;

  {
  {
#line 1022
  tmp = connected();
  }
#line 1022
  if (! tmp) {
#line 1024
    return;
  }
  {
#line 1027
  sprintf((char */* __restrict  */)(command), (char const   */* __restrict  */)"monitor");
#line 1029
  tmp___0 = rptp_command(rptp_fd, command, response, (int )sizeof(response));
  }
  {
#line 1031
  if (tmp___0 == -1) {
#line 1031
    goto case_neg_1;
  }
#line 1036
  if (tmp___0 == 1) {
#line 1036
    goto case_1;
  }
#line 1040
  if (tmp___0 == 0) {
#line 1040
    goto case_0;
  }
#line 1029
  goto switch_break;
  case_neg_1: /* CIL Label */ 
  {
#line 1032
  rptp_perror(*(argv + 0));
#line 1033
  command_close(argc, argv);
  }
#line 1034
  return;
  case_1: /* CIL Label */ 
  {
#line 1037
  do_error(response);
  }
#line 1038
  return;
  case_0: /* CIL Label */ 
#line 1041
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 1044
  tmp___1 = rptp_parse(response, (char *)"audio-info");
#line 1044
  p = strtok((char */* __restrict  */)tmp___1, (char const   */* __restrict  */)",");
#line 1047
  p = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)",");
  }
#line 1048
  if (p) {
    {
#line 1048
    sample_rate = atoi((char const   *)p);
    }
  }
  {
#line 1050
  p = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)",");
  }
#line 1051
  if (p) {
    {
#line 1051
    precision = atoi((char const   *)p);
    }
  }
  {
#line 1053
  p = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)",");
  }
#line 1054
  if (p) {
    {
#line 1054
    channels = atoi((char const   *)p);
    }
  }
#line 1056
  sample_size = (precision / 8) * channels;
#line 1058
  if (channels == 2) {
#line 1058
    tmp___2 = "stereo";
  } else {
#line 1058
    tmp___2 = "mono";
  }
  {
#line 1058
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%dhz %dbit %s\n",
          sample_rate, precision, tmp___2);
  }
  {
#line 1061
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1061
    n = read(rptp_fd, buf___1, sizeof(buf___1));
    }
#line 1061
    if (! (n > 0)) {
#line 1061
      goto while_break;
    }
    {
#line 1063
    write(1, buf___1, n);
#line 1064
    size += n;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1066
  close(rptp_fd);
  }
#line 1067
  return;
}
}
#line 1069 "/home/wslee/benchmarks/sound/rplay-3.3.2/rptp/rptp.c"
void do_application(void) 
{ 
  int tmp ;
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;

  {
  {
#line 1072
  sprintf((char */* __restrict  */)(command), (char const   */* __restrict  */)"set application=\"rptp %s\"",
          "3.3.2");
#line 1074
  tmp = rptp_command(rptp_fd, command, response, (int )sizeof(response));
  }
  {
#line 1076
  if (tmp == -1) {
#line 1076
    goto case_neg_1;
  }
#line 1082
  if (tmp == 1) {
#line 1082
    goto case_1;
  }
#line 1086
  if (tmp == 0) {
#line 1086
    goto case_0;
  }
#line 1074
  goto switch_break;
  case_neg_1: /* CIL Label */ 
  {
#line 1077
  rptp_perror((char *)"application");
#line 1078
  rptp_close(rptp_fd);
#line 1079
  rptp_fd = -1;
  }
#line 1080
  return;
  case_1: /* CIL Label */ 
  {
#line 1083
  do_error(response);
  }
#line 1084
  return;
  case_0: /* CIL Label */ 
#line 1087
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1089
  return;
}
}
#line 1092 "/home/wslee/benchmarks/sound/rplay-3.3.2/rptp/rptp.c"
void do_error(char *response___0 ) 
{ 
  char *error ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
#line 1100
  if (raw) {
    {
#line 1102
    printf((char const   */* __restrict  */)"%s\n", response___0);
    }
  } else {
    {
#line 1108
    error = rptp_parse(response___0, (char *)"error");
    }
#line 1109
    if (! error) {
#line 1111
      error = response___0;
    } else
#line 1109
    if (! *error) {
#line 1111
      error = response___0;
    }
    {
#line 1113
    printf((char const   */* __restrict  */)"%s\n", error);
    }
  }
#line 1115
  return;
}
}
#line 1117 "/home/wslee/benchmarks/sound/rplay-3.3.2/rptp/rptp.c"
void usage(void) 
{ 
  char *tmp ;
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;

  {
  {
#line 1120
  printf((char const   */* __restrict  */)"\nrplay %s\n\n", "3.3.2");
#line 1121
  printf((char const   */* __restrict  */)"usage: rptp [options] [command]\n");
#line 1122
  printf((char const   */* __restrict  */)"--help\n");
#line 1123
  printf((char const   */* __restrict  */)"\tDisplay helpful information.\n");
#line 1124
  printf((char const   */* __restrict  */)"\n");
#line 1126
  printf((char const   */* __restrict  */)"-h HOST, --host=HOST\n");
#line 1127
  tmp = rplay_default_host();
#line 1127
  printf((char const   */* __restrict  */)"\tSpecify the RPTP host, default = %s.\n",
         tmp);
#line 1129
  printf((char const   */* __restrict  */)"\n");
#line 1131
  printf((char const   */* __restrict  */)"-p PORT, --port=PORT\n");
#line 1132
  printf((char const   */* __restrict  */)"\tUse PORT instead of the default RPTP port, default = %d.\n",
         5556);
#line 1133
  printf((char const   */* __restrict  */)"\n");
#line 1135
  printf((char const   */* __restrict  */)"-r, --raw\n");
#line 1136
  printf((char const   */* __restrict  */)"\tEnable raw RPTP mode.\n");
#line 1137
  printf((char const   */* __restrict  */)"\n");
#line 1139
  printf((char const   */* __restrict  */)"-v, --version\n");
#line 1140
  printf((char const   */* __restrict  */)"\tDisplay rplay version information.\n");
  }
#line 1141
  return;
}
}
#line 1144 "/home/wslee/benchmarks/sound/rplay-3.3.2/rptp/rptp.c"
void done(int exit_value ) 
{ 


  {
  {
#line 1152
  exit(exit_value);
  }
}
}
