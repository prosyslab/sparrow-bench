/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 44
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 144 "/usr/include/libio.h"
struct _IO_FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 102 "/usr/include/stdio.h"
typedef __ssize_t ssize_t;
#line 48 "/usr/include/stdint.h"
typedef unsigned char uint8_t;
#line 49 "/usr/include/stdint.h"
typedef unsigned short uint16_t;
#line 51 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 26 "/usr/include/asm-generic/int-ll64.h"
typedef unsigned int __u32;
#line 29 "/usr/include/linux/cramfs_fs.h"
struct cramfs_inode {
   __u32 mode : 16 ;
   __u32 uid : 16 ;
   __u32 size : 24 ;
   __u32 gid : 8 ;
   __u32 namelen : 6 ;
   __u32 offset : 26 ;
};
#line 368 "/usr/include/x86_64-linux-gnu/zconf.h"
typedef unsigned char Byte;
#line 370 "/usr/include/x86_64-linux-gnu/zconf.h"
typedef unsigned int uInt;
#line 371 "/usr/include/x86_64-linux-gnu/zconf.h"
typedef unsigned long uLong;
#line 377 "/usr/include/x86_64-linux-gnu/zconf.h"
typedef Byte Bytef;
/* compiler builtin: 
   int __builtin_bswap32(int  ) ;  */
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 362
extern int printf(char const   * __restrict  __format  , ...) ;
#line 846
extern void perror(char const   *__s ) ;
#line 44 "/usr/include/x86_64-linux-gnu/bits/byteswap.h"
__inline static unsigned int __bswap_32(unsigned int __bsx ) 
{ 
  int tmp ;

  {
  {
#line 47
  tmp = __builtin_bswap32((int )__bsx);
  }
#line 47
  return ((unsigned int )tmp);
}
}
#line 334 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __off_t ( __attribute__((__leaf__)) lseek)(int __fd ,
                                                                                __off_t __offset ,
                                                                                int __whence ) ;
#line 353
extern int close(int __fd ) ;
#line 360
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 366
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 1600 "/usr/include/zlib.h"
extern uLong crc32(uLong crc , Bytef const   *buf , uInt len ) ;
#line 57 "/usr/include/x86_64-linux-gnu/sys/mman.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) mmap)(void *__addr ,
                                                                             size_t __len ,
                                                                             int __prot ,
                                                                             int __flags ,
                                                                             int __fd ,
                                                                             __off_t __offset ) ;
#line 76
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) munmap)(void *__addr ,
                                                                             size_t __len ) ;
#line 146 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 27 "/home/june/repo/benchmarks/collector/temp/cramfsswap-1.4.1ubuntu1/cramfsswap.c"
int main(int argc , char **argv ) 
{ 
  uint32_t superblock_in[16] ;
  uint32_t superblock_out[16] ;
  uint32_t flags ;
  uint32_t blockpointer_in ;
  uint32_t blockpointer_out ;
  uint32_t blockpointer_last ;
  uint32_t crc ;
  uint32_t *mapping ;
  uint16_t endiantest ;
  uint8_t inode_in[12] ;
  uint8_t inode_out[12] ;
  struct cramfs_inode inode ;
  unsigned int filecnt ;
  unsigned int file ;
  unsigned int filepos ;
  unsigned int remaining ;
  unsigned int nblocks ;
  unsigned int copybytes ;
  unsigned int readbytes ;
  unsigned int x ;
  unsigned int *fileoffset ;
  unsigned int *filesize ;
  unsigned char buffer[16384] ;
  unsigned char is_hostorder ;
  unsigned char host_is_le ;
  unsigned char file_is_le ;
  int infile ;
  int outfile ;
  int size ;
  ssize_t tmp ;
  unsigned int tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  ssize_t tmp___3 ;
  ssize_t tmp___4 ;
  ssize_t tmp___5 ;
  ssize_t tmp___6 ;
  ssize_t tmp___7 ;
  __off_t tmp___8 ;
  void *tmp___9 ;
  uLong tmp___10 ;
  unsigned int tmp___11 ;
  uLong tmp___12 ;
  unsigned int tmp___13 ;

  {
#line 43
  if (argc != 3) {
    {
#line 45
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Usage: %s <in> <out>\n",
            *(argv + 0));
#line 46
    exit(1);
    }
  }
  {
#line 49
  infile = open((char const   *)*(argv + 1), 0);
  }
#line 49
  if (infile < 0) {
    {
#line 51
    perror("while trying to open binary input file");
#line 52
    exit(1);
    }
  }
  {
#line 54
  outfile = open((char const   *)*(argv + 2), 578, 420);
  }
#line 54
  if (outfile < 0) {
    {
#line 56
    perror("while trying to open image output file");
#line 57
    exit(1);
    }
  }
  {
#line 60
  tmp = read(infile, (void *)(& superblock_in), sizeof(superblock_in));
  }
#line 60
  if ((unsigned long )tmp != sizeof(superblock_in)) {
    {
#line 62
    perror("while trying to read superblock");
#line 63
    exit(1);
    }
  }
#line 67
  endiantest = (uint16_t )1;
#line 68
  if ((int )*((uint8_t *)(& endiantest) + 0) == 1) {
#line 69
    host_is_le = (unsigned char)1;
  } else {
#line 71
    host_is_le = (unsigned char)0;
  }
#line 74
  if (superblock_in[0] == 684539205U) {
#line 76
    is_hostorder = (unsigned char)1;
#line 77
    file_is_le = host_is_le;
  } else {
    {
#line 79
    tmp___0 = __bswap_32(684539205U);
    }
#line 79
    if (superblock_in[0] == tmp___0) {
#line 81
      is_hostorder = (unsigned char)0;
#line 82
      file_is_le = (unsigned char )(! host_is_le);
    } else {
      {
#line 86
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"cramfs magic not detected\n");
#line 87
      exit(1);
      }
    }
  }
#line 90
  if (file_is_le) {
    {
#line 91
    printf((char const   */* __restrict  */)"Filesystem is little endian, will be converted to big endian.\n");
    }
  } else {
    {
#line 93
    printf((char const   */* __restrict  */)"Filesystem is big endian, will be converted to little endian.\n");
    }
  }
  {
#line 96
  superblock_out[0] = __bswap_32(superblock_in[0]);
#line 97
  superblock_out[1] = __bswap_32(superblock_in[1]);
#line 98
  superblock_out[2] = __bswap_32(superblock_in[2]);
#line 99
  superblock_out[3] = __bswap_32(superblock_in[3]);
#line 100
  superblock_out[4] = superblock_in[4];
#line 101
  superblock_out[5] = superblock_in[5];
#line 102
  superblock_out[6] = superblock_in[6];
#line 103
  superblock_out[7] = superblock_in[7];
#line 104
  superblock_out[8] = __bswap_32(superblock_in[8]);
#line 105
  superblock_out[9] = __bswap_32(superblock_in[9]);
#line 106
  superblock_out[10] = __bswap_32(superblock_in[10]);
#line 107
  superblock_out[11] = __bswap_32(superblock_in[11]);
#line 108
  superblock_out[12] = superblock_in[12];
#line 109
  superblock_out[13] = superblock_in[13];
#line 110
  superblock_out[14] = superblock_in[14];
#line 111
  superblock_out[15] = superblock_in[15];
#line 112
  write(outfile, (void const   *)(& superblock_out), sizeof(superblock_out));
  }
#line 116
  if (is_hostorder) {
#line 117
    flags = superblock_in[2];
  } else {
#line 119
    flags = superblock_out[2];
  }
#line 123
  if ((flags & 1U) == 0U) {
    {
#line 125
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: Not cramfs version 2!\n");
#line 126
    exit(1);
    }
  }
#line 130
  if (flags & 256U) {
    {
#line 132
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: Filesystem contains holes (not supported yet)\n");
#line 133
    exit(1);
    }
  }
#line 137
  if (flags & 1024U) {
    {
#line 139
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: Filesystem has shifted root fs flag (not supported)\n");
#line 140
    exit(1);
    }
  }
#line 144
  if (flags & 4294967292U) {
    {
#line 146
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: Filesystem has unknown/unsupported flag set!\n");
#line 147
    exit(1);
    }
  }
#line 151
  if (is_hostorder) {
#line 152
    filecnt = superblock_in[11];
  } else {
#line 154
    filecnt = superblock_out[11];
  }
  {
#line 155
  printf((char const   */* __restrict  */)"Filesystem contains %d files.\n", filecnt - 1U);
#line 157
  tmp___1 = malloc((unsigned long )filecnt * sizeof(*fileoffset));
#line 157
  fileoffset = (unsigned int *)tmp___1;
  }
#line 158
  if ((unsigned long )fileoffset == (unsigned long )((void *)0)) {
    {
#line 159
    perror("fileoffset malloc error");
#line 160
    exit(1);
    }
  }
  {
#line 163
  tmp___2 = malloc((unsigned long )filecnt * sizeof(*filesize));
#line 163
  filesize = (unsigned int *)tmp___2;
  }
#line 164
  if ((unsigned long )filesize == (unsigned long )((void *)0)) {
    {
#line 165
    free((void *)fileoffset);
#line 165
    fileoffset = (unsigned int *)((void *)0);
#line 166
    perror("filesize malloc error");
#line 167
    exit(1);
    }
  }
#line 171
  filepos = 16U;
#line 174
  remaining = 0U;
#line 177
  file = 0U;
  {
#line 177
  while (1) {
    while_continue: /* CIL Label */ ;
#line 177
    if (! (file < filecnt)) {
#line 177
      goto while_break;
    }
    {
#line 180
    tmp___3 = read(infile, (void *)(& inode_in), sizeof(inode_in));
    }
#line 180
    if ((unsigned long )tmp___3 != sizeof(inode_in)) {
      {
#line 182
      perror("while trying to read directory entry");
#line 183
      exit(1);
      }
    }
#line 188
    inode_out[0] = inode_in[1];
#line 189
    inode_out[1] = inode_in[0];
#line 191
    inode_out[2] = inode_in[3];
#line 192
    inode_out[3] = inode_in[2];
#line 194
    inode_out[4] = inode_in[6];
#line 195
    inode_out[5] = inode_in[5];
#line 196
    inode_out[6] = inode_in[4];
#line 198
    inode_out[7] = inode_in[7];
#line 203
    if (file_is_le) {
#line 205
      inode_out[8] = (uint8_t )((((int )inode_in[8] & 63) << 2) | (((int )inode_in[11] & 192) >> 6));
#line 208
      inode_out[9] = (uint8_t )((((int )inode_in[11] & 63) << 2) | (((int )inode_in[10] & 192) >> 6));
#line 211
      inode_out[10] = (uint8_t )((((int )inode_in[10] & 63) << 2) | (((int )inode_in[9] & 192) >> 6));
#line 214
      inode_out[11] = (uint8_t )((((int )inode_in[9] & 63) << 2) | (((int )inode_in[8] & 192) >> 6));
    } else {
#line 218
      inode_out[8] = (uint8_t )((((int )inode_in[8] & 253) >> 2) | (((int )inode_in[11] & 3) << 6));
#line 221
      inode_out[9] = (uint8_t )((((int )inode_in[11] & 253) >> 2) | (((int )inode_in[10] & 3) << 6));
#line 224
      inode_out[10] = (uint8_t )((((int )inode_in[10] & 253) >> 2) | (((int )inode_in[9] & 3) << 6));
#line 227
      inode_out[11] = (uint8_t )((((int )inode_in[9] & 253) >> 2) | (((int )inode_in[8] & 3) << 6));
    }
#line 231
    if (is_hostorder) {
      {
#line 234
      memcpy((void */* __restrict  */)(& inode), (void const   */* __restrict  */)(& inode_in),
             sizeof(inode_in));
      }
    } else {
      {
#line 238
      memcpy((void */* __restrict  */)(& inode), (void const   */* __restrict  */)(& inode_out),
             sizeof(inode_in));
      }
    }
    {
#line 242
    write(outfile, (void const   *)(& inode_out), sizeof(inode_out));
#line 245
    tmp___4 = read(infile, (void *)(& buffer), (size_t )(inode.namelen << 2));
    }
#line 245
    if (tmp___4 != (ssize_t )(inode.namelen << 2)) {
      {
#line 247
      perror("while trying to read filename");
#line 248
      exit(1);
      }
    }
    {
#line 250
    write(outfile, (void const   *)(& buffer), (size_t )(inode.namelen << 2));
#line 253
    *(filesize + file) = inode.size;
#line 254
    *(fileoffset + file) = inode.offset;
#line 257
    filepos += inode.namelen + 3U;
    }
#line 260
    if ((inode.mode & 61440U) == 32768U) {
#line 260
      goto _L;
    } else
#line 260
    if ((inode.mode & 61440U) == 40960U) {
      _L: /* CIL Label */ 
#line 260
      if (inode.size > 0U) {
#line 262
        remaining ++;
      }
    }
#line 177
    file ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 272
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 272
    if (! remaining) {
#line 272
      goto while_break___0;
    }
#line 275
    file = 1U;
    {
#line 275
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 275
      if (*(fileoffset + file) != filepos) {
#line 275
        if (! (file < filecnt)) {
#line 275
          goto while_break___1;
        }
      } else {
#line 275
        goto while_break___1;
      }
#line 275
      file ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 276
    if (*(fileoffset + file) != filepos) {
      {
#line 279
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Did not find the file which starts at word %x, aborting...\n",
              filepos);
#line 280
      exit(1);
      }
    }
#line 285
    x = 1U;
    {
#line 285
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 285
      if (! (x < filecnt)) {
#line 285
        goto while_break___2;
      }
#line 286
      if (*(fileoffset + x) == filepos) {
#line 287
        remaining --;
      }
#line 285
      x ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 290
    nblocks = (*(filesize + file) - 1U) / 4096U + 1U;
#line 293
    x = 0U;
    {
#line 293
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 293
      if (! (x < nblocks)) {
#line 293
        goto while_break___3;
      }
      {
#line 295
      tmp___5 = read(infile, (void *)(& blockpointer_in), (size_t )4);
      }
#line 295
      if (tmp___5 != 4L) {
        {
#line 297
        perror("while trying to read blockpointer");
#line 298
        exit(1);
        }
      }
      {
#line 301
      blockpointer_out = __bswap_32(blockpointer_in);
#line 302
      write(outfile, (void const   *)(& blockpointer_out), (size_t )4);
#line 304
      filepos ++;
#line 293
      x ++;
      }
    }
    while_break___3: /* CIL Label */ ;
    }
#line 309
    if (is_hostorder) {
#line 310
      blockpointer_last = blockpointer_in;
    } else {
#line 312
      blockpointer_last = blockpointer_out;
    }
#line 315
    blockpointer_last += (4U - blockpointer_last % 4U) % 4U;
#line 318
    copybytes = blockpointer_last - (filepos << 2);
    {
#line 319
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 319
      if (! (copybytes > 0U)) {
#line 319
        goto while_break___4;
      }
#line 321
      if (copybytes > 16384U) {
#line 321
        readbytes = 16384U;
      } else {
#line 321
        readbytes = copybytes;
      }
      {
#line 323
      tmp___6 = read(infile, (void *)(& buffer), (size_t )readbytes);
      }
#line 323
      if (tmp___6 != (ssize_t )readbytes) {
        {
#line 325
        perror("while trying to read file data");
#line 326
        exit(1);
        }
      }
      {
#line 328
      write(outfile, (void const   *)(& buffer), (size_t )readbytes);
#line 330
      copybytes -= readbytes;
      }
    }
    while_break___4: /* CIL Label */ ;
    }
#line 334
    filepos = blockpointer_last >> 2;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 338
  while (1) {
    while_continue___5: /* CIL Label */ ;
    {
#line 340
    tmp___7 = read(infile, (void *)(& buffer), (size_t )16384);
#line 340
    readbytes = (unsigned int )tmp___7;
#line 341
    write(outfile, (void const   *)(& buffer), (size_t )readbytes);
    }
#line 338
    if (! (readbytes > 0U)) {
#line 338
      goto while_break___5;
    }
  }
  while_break___5: /* CIL Label */ ;
  }
  {
#line 345
  tmp___8 = lseek(outfile, (__off_t )0, 1);
#line 345
  size = (int )tmp___8;
#line 346
  tmp___9 = mmap((void *)0, (size_t )size, 3, 1, outfile, (__off_t )0);
#line 346
  mapping = (uint32_t *)tmp___9;
  }
#line 347
  if ((unsigned long )mapping != (unsigned long )((void *)-1)) {
    {
#line 348
    tmp___10 = crc32((uLong )0L, (Bytef const   *)0, (uInt )0);
#line 348
    crc = (uint32_t )tmp___10;
    }
#line 349
    if (is_hostorder) {
      {
#line 349
      tmp___11 = __bswap_32(crc);
#line 349
      *(mapping + 8) = tmp___11;
      }
    } else {
#line 349
      *(mapping + 8) = crc;
    }
    {
#line 350
    tmp___12 = crc32((uLong )crc, (Bytef const   *)((unsigned char *)mapping), (uInt )size);
#line 350
    crc = (uint32_t )tmp___12;
#line 351
    printf((char const   */* __restrict  */)"CRC: 0x%08x\n", crc);
    }
#line 352
    if (is_hostorder) {
      {
#line 352
      tmp___13 = __bswap_32(crc);
#line 352
      *(mapping + 8) = tmp___13;
      }
    } else {
#line 352
      *(mapping + 8) = crc;
    }
    {
#line 353
    munmap((void *)mapping, (size_t )size);
    }
  } else {
    {
#line 356
    perror("mapping failed");
    }
  }
  {
#line 360
  close(infile);
#line 361
  close(outfile);
#line 363
  exit(0);
  }
}
}
