/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 44 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __uint64_t;
#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 49 "/usr/include/stdint.h"
typedef unsigned short uint16_t;
#line 51 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 55 "/usr/include/stdint.h"
typedef unsigned long uint64_t;
#line 94 "/usr/lib/ocaml/caml/config.h"
typedef int int32;
#line 123 "/usr/lib/ocaml/caml/config.h"
typedef long long int64;
#line 128 "/usr/lib/ocaml/caml/config.h"
typedef long intnat;
#line 129 "/usr/lib/ocaml/caml/config.h"
typedef unsigned long uintnat;
#line 58 "/usr/lib/ocaml/caml/mlvalues.h"
typedef intnat value;
#line 59 "/usr/lib/ocaml/caml/mlvalues.h"
typedef uintnat header_t;
#line 60 "/usr/lib/ocaml/caml/mlvalues.h"
typedef uintnat mlsize_t;
#line 61 "/usr/lib/ocaml/caml/mlvalues.h"
typedef unsigned int tag_t;
#line 49 "/usr/lib/ocaml/caml/memory.h"
struct caml__roots_block {
   struct caml__roots_block *next ;
   intnat ntables ;
   intnat nitems ;
   value *tables[5] ;
};
#line 73 "/usr/lib/ocaml/caml/bigarray.h"
struct caml_ba_proxy {
   intnat refcount ;
   void *data ;
   uintnat size ;
};
#line 79 "/usr/lib/ocaml/caml/bigarray.h"
struct caml_ba_array {
   void *data ;
   intnat num_dims ;
   intnat flags ;
   struct caml_ba_proxy *proxy ;
   intnat dim[1] ;
};
#line 31 "/usr/lib/ocaml/caml/misc.h"
typedef size_t asize_t;
/* compiler builtin: 
   long __builtin_expect(long  , long  ) ;  */
/* compiler builtin: 
   int __builtin_bswap32(int  ) ;  */
/* compiler builtin: 
   long __builtin_bswap64(long  ) ;  */
#line 44 "/usr/include/x86_64-linux-gnu/bits/byteswap.h"
__inline static unsigned int __bswap_32(unsigned int __bsx ) 
{ 
  int tmp ;

  {
  {
#line 47
  tmp = __builtin_bswap32((int )__bsx);
  }
#line 47
  return ((unsigned int )tmp);
}
}
#line 108 "/usr/include/x86_64-linux-gnu/bits/byteswap.h"
__inline static __uint64_t __bswap_64(__uint64_t __bsx ) 
{ 
  long tmp ;

  {
  {
#line 111
  tmp = __builtin_bswap64((long )__bsx);
  }
#line 111
  return ((__uint64_t )tmp);
}
}
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 276 "/usr/lib/ocaml/caml/mlvalues.h"
extern header_t caml_atom_table[] ;
#line 56 "/usr/lib/ocaml/caml/memory.h"
extern struct caml__roots_block *caml_local_roots ;
#line 28 "/usr/lib/ocaml/caml/alloc.h"
extern value caml_alloc(mlsize_t  , tag_t  ) ;
#line 29
extern value caml_alloc_small(mlsize_t  , tag_t  ) ;
#line 31
extern value caml_alloc_string(mlsize_t  ) ;
#line 34
extern value caml_copy_double(double  ) ;
#line 35
extern value caml_copy_int32(int32  ) ;
#line 36
extern value caml_copy_int64(int64  ) ;
#line 37
extern value caml_copy_nativeint(intnat  ) ;
#line 29 "/usr/lib/ocaml/caml/fail.h"
extern  __attribute__((__noreturn__)) void caml_raise(value bucket ) ;
#line 30
extern  __attribute__((__noreturn__)) void caml_raise_constant(value tag ) ;
#line 31
extern  __attribute__((__noreturn__)) void caml_raise_with_arg(value tag , value arg ) ;
#line 43
extern  __attribute__((__noreturn__)) void caml_array_bound_error(void) ;
#line 113 "/usr/lib/ocaml/caml/bigarray.h"
extern value caml_ba_alloc(int flags , int num_dims , void *data , intnat *dim ) ;
#line 44 "/usr/lib/ocaml/caml/callback.h"
extern value *caml_named_value(char const   *name ) ;
#line 28 "/usr/lib/ocaml/caml/signals.h"
extern void caml_enter_blocking_section(void) ;
#line 29
extern void caml_leave_blocking_section(void) ;
#line 161 "/home/june/repo/benchmarks/collector/temp/bin-prot-109.30.00/_build/lib/common_stubs.h"
value *v_bin_prot_exc_Buffer_short ;
#line 7 "/home/june/repo/benchmarks/collector/temp/bin-prot-109.30.00/_build/lib/read_stubs.c"
static value *v_exc_Error  =    (value *)((void *)0);
#line 8 "/home/june/repo/benchmarks/collector/temp/bin-prot-109.30.00/_build/lib/read_stubs.c"
static value *v_exc_Read_error  =    (value *)((void *)0);
#line 10 "/home/june/repo/benchmarks/collector/temp/bin-prot-109.30.00/_build/lib/read_stubs.c"
value bin_prot_unsafe_read_c_init_stub(value v_unit  __attribute__((__unused__)) ) 
{ 


  {
  {
#line 12
  v_exc_Error = caml_named_value("Bin_prot.Unsafe_read_c.Error");
  }
#line 13
  return (1L);
}
}
#line 16 "/home/june/repo/benchmarks/collector/temp/bin-prot-109.30.00/_build/lib/read_stubs.c"
value bin_prot_read_ml_init_stub(value v_unit  __attribute__((__unused__)) ) 
{ 


  {
  {
#line 18
  v_exc_Read_error = caml_named_value("Bin_prot.Common.Read_error");
  }
#line 19
  return (1L);
}
}
#line 40
__inline static  __attribute__((__noreturn__)) value ( __attribute__((__always_inline__)) raise_Error)(int loc ) ;
#line 42
__inline static  __attribute__((__noreturn__)) value ( __attribute__((__always_inline__)) raise_Error)(int loc ) ;
#line 42 "/home/june/repo/benchmarks/collector/temp/bin-prot-109.30.00/_build/lib/read_stubs.c"
__inline static value ( __attribute__((__always_inline__)) raise_Error)(int loc ) 
{ 


  {
  {
#line 44
  caml_raise_with_arg(*v_exc_Error, ((intnat )loc << 1) + 1L);
  }
}
}
#line 47
__inline static  __attribute__((__noreturn__)) void ( __attribute__((__always_inline__)) raise_Read_error)(int loc ,
                                                                                                           unsigned long pos ) ;
#line 49
__inline static  __attribute__((__noreturn__)) void ( __attribute__((__always_inline__)) raise_Read_error)(int loc ,
                                                                                                           unsigned long pos ) ;
#line 49 "/home/june/repo/benchmarks/collector/temp/bin-prot-109.30.00/_build/lib/read_stubs.c"
__inline static void ( __attribute__((__always_inline__)) raise_Read_error)(int loc ,
                                                                            unsigned long pos ) 
{ 
  value v_exc ;
  value tmp ;

  {
  {
#line 51
  tmp = caml_alloc_small((mlsize_t )3, (tag_t )0);
#line 51
  v_exc = tmp;
#line 52
  *((value *)v_exc + 0) = *v_exc_Read_error;
#line 53
  *((value *)v_exc + 1) = ((intnat )loc << 1) + 1L;
#line 54
  *((value *)v_exc + 2) = ((intnat )pos << 1) + 1L;
#line 55
  caml_raise(v_exc);
  }
}
}
#line 104 "/home/june/repo/benchmarks/collector/temp/bin-prot-109.30.00/_build/lib/read_stubs.c"
__inline static char ( __attribute__((__always_inline__)) safe_read_neg_int8)(char **sptr_ptr ,
                                                                              char *eptr ) 
{ 
  char *sptr ;
  char *next ;
  char n ;
  long tmp ;
  long tmp___0 ;

  {
  {
#line 104
  sptr = *sptr_ptr;
#line 104
  next = sptr + 1;
#line 104
  tmp = __builtin_expect((long )(! (! ((unsigned long )next > (unsigned long )eptr))),
                         0L);
  }
#line 104
  if (tmp) {
    {
#line 104
    caml_raise_constant(*v_bin_prot_exc_Buffer_short);
    }
  }
  {
#line 104
  n = *sptr;
#line 104
  tmp___0 = __builtin_expect((long )(! (! ((int )n >= 0))), 0L);
  }
#line 104
  if (tmp___0) {
    {
#line 104
    *sptr_ptr = sptr - 1;
#line 104
    raise_Error(0);
    }
  }
#line 104
  *sptr_ptr = next;
#line 104
  return (n);
}
}
#line 110 "/home/june/repo/benchmarks/collector/temp/bin-prot-109.30.00/_build/lib/read_stubs.c"
__inline static short ( __attribute__((__always_inline__)) safe_read_int16)(char **sptr_ptr ,
                                                                            char *eptr ) 
{ 
  char *sptr ;
  char *next ;
  short n ;
  long tmp ;
  uint16_t __n ;

  {
  {
#line 110
  sptr = *sptr_ptr;
#line 110
  next = sptr + 2;
#line 110
  tmp = __builtin_expect((long )(! (! ((unsigned long )next > (unsigned long )eptr))),
                         0L);
  }
#line 110
  if (tmp) {
    {
#line 110
    caml_raise_constant(*v_bin_prot_exc_Buffer_short);
    }
  }
  {
#line 110
  memcpy((void */* __restrict  */)(& __n), (void const   */* __restrict  */)sptr,
         (size_t )2);
#line 110
  n = (short )__n;
#line 110
  *sptr_ptr = next;
  }
#line 110
  return (n);
}
}
#line 113 "/home/june/repo/benchmarks/collector/temp/bin-prot-109.30.00/_build/lib/read_stubs.c"
__inline static int ( __attribute__((__always_inline__)) safe_read_int32)(char **sptr_ptr ,
                                                                          char *eptr ) 
{ 
  char *sptr ;
  char *next ;
  int n ;
  long tmp ;
  uint32_t __n ;

  {
  {
#line 113
  sptr = *sptr_ptr;
#line 113
  next = sptr + 4;
#line 113
  tmp = __builtin_expect((long )(! (! ((unsigned long )next > (unsigned long )eptr))),
                         0L);
  }
#line 113
  if (tmp) {
    {
#line 113
    caml_raise_constant(*v_bin_prot_exc_Buffer_short);
    }
  }
  {
#line 113
  memcpy((void */* __restrict  */)(& __n), (void const   */* __restrict  */)sptr,
         (size_t )4);
#line 113
  n = (int )__n;
#line 113
  *sptr_ptr = next;
  }
#line 113
  return (n);
}
}
#line 124 "/home/june/repo/benchmarks/collector/temp/bin-prot-109.30.00/_build/lib/read_stubs.c"
__inline static long ( __attribute__((__always_inline__)) safe_read_int64)(char **sptr_ptr ,
                                                                           char *eptr ) 
{ 
  char *sptr ;
  char *next ;
  long n ;
  long tmp ;
  uint64_t __n ;
  int tmp___0 ;
  long tmp___1 ;

  {
  {
#line 124
  sptr = *sptr_ptr;
#line 124
  next = sptr + 8;
#line 124
  tmp = __builtin_expect((long )(! (! ((unsigned long )next > (unsigned long )eptr))),
                         0L);
  }
#line 124
  if (tmp) {
    {
#line 124
    caml_raise_constant(*v_bin_prot_exc_Buffer_short);
    }
  }
  {
#line 124
  memcpy((void */* __restrict  */)(& __n), (void const   */* __restrict  */)sptr,
         (size_t )8);
#line 124
  n = (long )__n;
  }
#line 124
  if (n < -4611686018427387904L) {
#line 124
    tmp___0 = 1;
  } else
#line 124
  if (n > 4611686018427387903L) {
#line 124
    tmp___0 = 1;
  } else {
#line 124
    tmp___0 = 0;
  }
  {
#line 124
  tmp___1 = __builtin_expect((long )tmp___0, 0L);
  }
#line 124
  if (tmp___1) {
    {
#line 124
    *sptr_ptr = sptr - 1;
#line 124
    raise_Error(2);
    }
  }
#line 124
  *sptr_ptr = next;
#line 124
  return (n);
}
}
#line 129 "/home/june/repo/benchmarks/collector/temp/bin-prot-109.30.00/_build/lib/read_stubs.c"
__inline static long ( __attribute__((__always_inline__)) safe_read_nocheck_int64)(char **sptr_ptr ,
                                                                                   char *eptr ) 
{ 
  char *sptr ;
  char *next ;
  long n ;
  long tmp ;
  uint64_t __n ;

  {
  {
#line 129
  sptr = *sptr_ptr;
#line 129
  next = sptr + 8;
#line 129
  tmp = __builtin_expect((long )(! (! ((unsigned long )next > (unsigned long )eptr))),
                         0L);
  }
#line 129
  if (tmp) {
    {
#line 129
    caml_raise_constant(*v_bin_prot_exc_Buffer_short);
    }
  }
  {
#line 129
  memcpy((void */* __restrict  */)(& __n), (void const   */* __restrict  */)sptr,
         (size_t )8);
#line 129
  n = (long )__n;
#line 129
  *sptr_ptr = next;
  }
#line 129
  return (n);
}
}
#line 132 "/home/june/repo/benchmarks/collector/temp/bin-prot-109.30.00/_build/lib/read_stubs.c"
__inline static long ( __attribute__((__always_inline__)) read_int)(char **sptr_ptr ,
                                                                    char *eptr ) 
{ 
  char *sptr ;
  int code ;
  long tmp ;
  long tmp___0 ;
  short tmp___1 ;
  long tmp___2 ;
  char tmp___3 ;
  long tmp___4 ;
  int tmp___5 ;
  long tmp___6 ;
  long tmp___7 ;
  long tmp___8 ;

  {
  {
#line 134
  sptr = *sptr_ptr;
#line 136
  tmp = __builtin_expect((long )(! (! ((unsigned long )sptr >= (unsigned long )eptr))),
                         0L);
  }
#line 136
  if (tmp) {
    {
#line 136
    caml_raise_constant(*v_bin_prot_exc_Buffer_short);
    }
  }
  {
#line 137
  code = (int )*sptr;
#line 138
  *sptr_ptr = sptr + 1;
#line 139
  tmp___0 = __builtin_expect((long )(! (! (code >= 0))), 1L);
  }
#line 139
  if (tmp___0) {
#line 139
    return ((long )code);
  }
  {
#line 140
  tmp___2 = __builtin_expect((long )(! (! (code == -2))), 1L);
  }
#line 140
  if (tmp___2) {
    {
#line 140
    tmp___1 = safe_read_int16(sptr_ptr, eptr);
    }
#line 140
    return ((long )tmp___1);
  }
  {
#line 141
  tmp___4 = __builtin_expect((long )(! (! (code == -1))), 1L);
  }
#line 141
  if (tmp___4) {
    {
#line 141
    tmp___3 = safe_read_neg_int8(sptr_ptr, eptr);
    }
#line 141
    return ((long )tmp___3);
  }
  {
#line 142
  tmp___6 = __builtin_expect((long )(! (! (code == -3))), 1L);
  }
#line 142
  if (tmp___6) {
    {
#line 142
    tmp___5 = safe_read_int32(sptr_ptr, eptr);
    }
#line 142
    return ((long )tmp___5);
  }
  {
#line 144
  tmp___8 = __builtin_expect((long )(! (! (code == -4))), 1L);
  }
#line 144
  if (tmp___8) {
    {
#line 144
    tmp___7 = safe_read_int64(sptr_ptr, eptr);
    }
#line 144
    return (tmp___7);
  }
  {
#line 146
  *sptr_ptr = sptr;
#line 147
  raise_Error(1);
  }
}
}
#line 150 "/home/june/repo/benchmarks/collector/temp/bin-prot-109.30.00/_build/lib/read_stubs.c"
value read_int_stub(char **sptr_ptr , char *eptr ) 
{ 
  long tmp ;

  {
  {
#line 152
  tmp = read_int(sptr_ptr, eptr);
  }
#line 152
  return ((tmp << 1) + 1L);
}
}
#line 158 "/home/june/repo/benchmarks/collector/temp/bin-prot-109.30.00/_build/lib/read_stubs.c"
__inline static unsigned short ( __attribute__((__always_inline__)) safe_read_nat0_16)(char **sptr_ptr ,
                                                                                       char *eptr ) 
{ 
  char *sptr ;
  char *next ;
  unsigned short n ;
  long tmp ;
  uint16_t __n ;

  {
  {
#line 158
  sptr = *sptr_ptr;
#line 158
  next = sptr + 2;
#line 158
  tmp = __builtin_expect((long )(! (! ((unsigned long )next > (unsigned long )eptr))),
                         0L);
  }
#line 158
  if (tmp) {
    {
#line 158
    caml_raise_constant(*v_bin_prot_exc_Buffer_short);
    }
  }
  {
#line 158
  memcpy((void */* __restrict  */)(& __n), (void const   */* __restrict  */)sptr,
         (size_t )2);
#line 158
  n = __n;
#line 158
  *sptr_ptr = next;
  }
#line 158
  return (n);
}
}
#line 161 "/home/june/repo/benchmarks/collector/temp/bin-prot-109.30.00/_build/lib/read_stubs.c"
__inline static unsigned int ( __attribute__((__always_inline__)) safe_read_nat0_32)(char **sptr_ptr ,
                                                                                     char *eptr ) 
{ 
  char *sptr ;
  char *next ;
  unsigned int n ;
  long tmp ;
  uint32_t __n ;

  {
  {
#line 161
  sptr = *sptr_ptr;
#line 161
  next = sptr + 4;
#line 161
  tmp = __builtin_expect((long )(! (! ((unsigned long )next > (unsigned long )eptr))),
                         0L);
  }
#line 161
  if (tmp) {
    {
#line 161
    caml_raise_constant(*v_bin_prot_exc_Buffer_short);
    }
  }
  {
#line 161
  memcpy((void */* __restrict  */)(& __n), (void const   */* __restrict  */)sptr,
         (size_t )4);
#line 161
  n = __n;
#line 161
  *sptr_ptr = next;
  }
#line 161
  return (n);
}
}
#line 172 "/home/june/repo/benchmarks/collector/temp/bin-prot-109.30.00/_build/lib/read_stubs.c"
__inline static unsigned long ( __attribute__((__always_inline__)) safe_read_nat0_64)(char **sptr_ptr ,
                                                                                      char *eptr ) 
{ 
  char *sptr ;
  char *next ;
  unsigned long n ;
  long tmp ;
  uint64_t __n ;
  long tmp___0 ;

  {
  {
#line 172
  sptr = *sptr_ptr;
#line 172
  next = sptr + 8;
#line 172
  tmp = __builtin_expect((long )(! (! ((unsigned long )next > (unsigned long )eptr))),
                         0L);
  }
#line 172
  if (tmp) {
    {
#line 172
    caml_raise_constant(*v_bin_prot_exc_Buffer_short);
    }
  }
  {
#line 172
  memcpy((void */* __restrict  */)(& __n), (void const   */* __restrict  */)sptr,
         (size_t )8);
#line 172
  n = __n;
#line 172
  tmp___0 = __builtin_expect((long )(! (! (n > 4611686018427387903UL))), 0L);
  }
#line 172
  if (tmp___0) {
    {
#line 172
    *sptr_ptr = sptr - 1;
#line 172
    raise_Error(4);
    }
  }
#line 172
  *sptr_ptr = next;
#line 172
  return (n);
}
}
#line 179 "/home/june/repo/benchmarks/collector/temp/bin-prot-109.30.00/_build/lib/read_stubs.c"
__inline static unsigned long ( __attribute__((__always_inline__)) read_nat0)(char **sptr_ptr ,
                                                                              char *eptr ) 
{ 
  char *sptr ;
  int code ;
  long tmp ;
  long tmp___0 ;
  unsigned short tmp___1 ;
  long tmp___2 ;
  unsigned int tmp___3 ;
  long tmp___4 ;
  unsigned long tmp___5 ;
  long tmp___6 ;

  {
  {
#line 181
  sptr = *sptr_ptr;
#line 183
  tmp = __builtin_expect((long )(! (! ((unsigned long )sptr >= (unsigned long )eptr))),
                         0L);
  }
#line 183
  if (tmp) {
    {
#line 183
    caml_raise_constant(*v_bin_prot_exc_Buffer_short);
    }
  }
  {
#line 184
  code = (int )*sptr;
#line 185
  *sptr_ptr = sptr + 1;
#line 186
  tmp___0 = __builtin_expect((long )(! (! (code >= 0))), 1L);
  }
#line 186
  if (tmp___0) {
#line 186
    return ((unsigned long )code);
  }
  {
#line 187
  tmp___2 = __builtin_expect((long )(! (! (code == -2))), 1L);
  }
#line 187
  if (tmp___2) {
    {
#line 187
    tmp___1 = safe_read_nat0_16(sptr_ptr, eptr);
    }
#line 187
    return ((unsigned long )tmp___1);
  }
  {
#line 188
  tmp___4 = __builtin_expect((long )(! (! (code == -3))), 1L);
  }
#line 188
  if (tmp___4) {
    {
#line 188
    tmp___3 = safe_read_nat0_32(sptr_ptr, eptr);
    }
#line 188
    return ((unsigned long )tmp___3);
  }
  {
#line 190
  tmp___6 = __builtin_expect((long )(! (! (code == -4))), 1L);
  }
#line 190
  if (tmp___6) {
    {
#line 190
    tmp___5 = safe_read_nat0_64(sptr_ptr, eptr);
    }
#line 190
    return (tmp___5);
  }
  {
#line 192
  *sptr_ptr = sptr;
#line 193
  raise_Error(3);
  }
}
}
#line 196 "/home/june/repo/benchmarks/collector/temp/bin-prot-109.30.00/_build/lib/read_stubs.c"
value read_nat0_stub(char **sptr_ptr , char *eptr ) 
{ 
  unsigned long tmp ;

  {
  {
#line 198
  tmp = read_nat0(sptr_ptr, eptr);
  }
#line 198
  return (((intnat )tmp << 1) + 1L);
}
}
#line 204 "/home/june/repo/benchmarks/collector/temp/bin-prot-109.30.00/_build/lib/read_stubs.c"
__inline static long ( __attribute__((__always_inline__)) read_int32)(char **sptr_ptr ,
                                                                      char *eptr ) 
{ 
  char *sptr ;
  int code ;
  long tmp ;
  long tmp___0 ;
  short tmp___1 ;
  long tmp___2 ;
  char tmp___3 ;
  long tmp___4 ;
  int tmp___5 ;
  long tmp___6 ;

  {
  {
#line 206
  sptr = *sptr_ptr;
#line 208
  tmp = __builtin_expect((long )(! (! ((unsigned long )sptr >= (unsigned long )eptr))),
                         0L);
  }
#line 208
  if (tmp) {
    {
#line 208
    caml_raise_constant(*v_bin_prot_exc_Buffer_short);
    }
  }
  {
#line 209
  code = (int )*sptr;
#line 210
  *sptr_ptr = sptr + 1;
#line 211
  tmp___0 = __builtin_expect((long )(! (! (code >= 0))), 1L);
  }
#line 211
  if (tmp___0) {
#line 211
    return ((long )code);
  }
  {
#line 212
  tmp___2 = __builtin_expect((long )(! (! (code == -2))), 1L);
  }
#line 212
  if (tmp___2) {
    {
#line 212
    tmp___1 = safe_read_int16(sptr_ptr, eptr);
    }
#line 212
    return ((long )tmp___1);
  }
  {
#line 213
  tmp___4 = __builtin_expect((long )(! (! (code == -1))), 1L);
  }
#line 213
  if (tmp___4) {
    {
#line 213
    tmp___3 = safe_read_neg_int8(sptr_ptr, eptr);
    }
#line 213
    return ((long )tmp___3);
  }
  {
#line 214
  tmp___6 = __builtin_expect((long )(! (! (code == -3))), 1L);
  }
#line 214
  if (tmp___6) {
    {
#line 216
    tmp___5 = safe_read_int32(sptr_ptr, eptr);
    }
#line 216
    return ((long )tmp___5);
  }
  {
#line 220
  *sptr_ptr = sptr;
#line 221
  raise_Error(5);
  }
}
}
#line 224 "/home/june/repo/benchmarks/collector/temp/bin-prot-109.30.00/_build/lib/read_stubs.c"
value read_int32_stub(char **sptr_ptr , char *eptr ) 
{ 
  long tmp ;
  value tmp___0 ;

  {
  {
#line 226
  tmp = read_int32(sptr_ptr, eptr);
#line 226
  tmp___0 = caml_copy_int32((int32 )tmp);
  }
#line 226
  return (tmp___0);
}
}
#line 232 "/home/june/repo/benchmarks/collector/temp/bin-prot-109.30.00/_build/lib/read_stubs.c"
__inline static int64 ( __attribute__((__always_inline__)) read_int64)(char **sptr_ptr ,
                                                                       char *eptr ) 
{ 
  char *sptr ;
  int code ;
  long tmp ;
  long tmp___0 ;
  short tmp___1 ;
  long tmp___2 ;
  char tmp___3 ;
  long tmp___4 ;
  int tmp___5 ;
  long tmp___6 ;
  long tmp___7 ;
  long tmp___8 ;

  {
  {
#line 234
  sptr = *sptr_ptr;
#line 236
  tmp = __builtin_expect((long )(! (! ((unsigned long )sptr >= (unsigned long )eptr))),
                         0L);
  }
#line 236
  if (tmp) {
    {
#line 236
    caml_raise_constant(*v_bin_prot_exc_Buffer_short);
    }
  }
  {
#line 237
  code = (int )*sptr;
#line 238
  *sptr_ptr = sptr + 1;
#line 240
  tmp___0 = __builtin_expect((long )(! (! (code >= 0))), 1L);
  }
#line 240
  if (tmp___0) {
#line 241
    return ((int64 )code);
  }
  {
#line 242
  tmp___2 = __builtin_expect((long )(! (! (code == -2))), 1L);
  }
#line 242
  if (tmp___2) {
    {
#line 242
    tmp___1 = safe_read_int16(sptr_ptr, eptr);
    }
#line 242
    return ((int64 )tmp___1);
  }
  {
#line 243
  tmp___4 = __builtin_expect((long )(! (! (code == -1))), 1L);
  }
#line 243
  if (tmp___4) {
    {
#line 243
    tmp___3 = safe_read_neg_int8(sptr_ptr, eptr);
    }
#line 243
    return ((int64 )tmp___3);
  }
  {
#line 244
  tmp___6 = __builtin_expect((long )(! (! (code == -3))), 1L);
  }
#line 244
  if (tmp___6) {
    {
#line 244
    tmp___5 = safe_read_int32(sptr_ptr, eptr);
    }
#line 244
    return ((int64 )tmp___5);
  }
  {
#line 245
  tmp___8 = __builtin_expect((long )(! (! (code == -4))), 1L);
  }
#line 245
  if (tmp___8) {
    {
#line 245
    tmp___7 = safe_read_nocheck_int64(sptr_ptr, eptr);
    }
#line 245
    return ((int64 )tmp___7);
  }
  {
#line 260
  *sptr_ptr = sptr;
#line 261
  raise_Error(6);
  }
}
}
#line 264 "/home/june/repo/benchmarks/collector/temp/bin-prot-109.30.00/_build/lib/read_stubs.c"
value read_int64_stub(char **sptr_ptr , char *eptr ) 
{ 
  int64 tmp ;
  value tmp___0 ;

  {
  {
#line 266
  tmp = read_int64(sptr_ptr, eptr);
#line 266
  tmp___0 = caml_copy_int64(tmp);
  }
#line 266
  return (tmp___0);
}
}
#line 272 "/home/june/repo/benchmarks/collector/temp/bin-prot-109.30.00/_build/lib/read_stubs.c"
__inline static long ( __attribute__((__always_inline__)) read_nativeint)(char **sptr_ptr ,
                                                                          char *eptr ) 
{ 
  char *sptr ;
  int code ;
  long tmp ;
  long tmp___0 ;
  short tmp___1 ;
  long tmp___2 ;
  char tmp___3 ;
  long tmp___4 ;
  int tmp___5 ;
  long tmp___6 ;
  long tmp___7 ;
  long tmp___8 ;

  {
  {
#line 274
  sptr = *sptr_ptr;
#line 276
  tmp = __builtin_expect((long )(! (! ((unsigned long )sptr >= (unsigned long )eptr))),
                         0L);
  }
#line 276
  if (tmp) {
    {
#line 276
    caml_raise_constant(*v_bin_prot_exc_Buffer_short);
    }
  }
  {
#line 277
  code = (int )*sptr;
#line 278
  *sptr_ptr = sptr + 1;
#line 279
  tmp___0 = __builtin_expect((long )(! (! (code >= 0))), 1L);
  }
#line 279
  if (tmp___0) {
#line 279
    return ((long )code);
  }
  {
#line 280
  tmp___2 = __builtin_expect((long )(! (! (code == -2))), 1L);
  }
#line 280
  if (tmp___2) {
    {
#line 280
    tmp___1 = safe_read_int16(sptr_ptr, eptr);
    }
#line 280
    return ((long )tmp___1);
  }
  {
#line 281
  tmp___4 = __builtin_expect((long )(! (! (code == -1))), 1L);
  }
#line 281
  if (tmp___4) {
    {
#line 281
    tmp___3 = safe_read_neg_int8(sptr_ptr, eptr);
    }
#line 281
    return ((long )tmp___3);
  }
  {
#line 283
  tmp___6 = __builtin_expect((long )(! (! (code == -3))), 1L);
  }
#line 283
  if (tmp___6) {
    {
#line 283
    tmp___5 = safe_read_int32(sptr_ptr, eptr);
    }
#line 283
    return ((long )tmp___5);
  }
  {
#line 284
  tmp___8 = __builtin_expect((long )(! (! (code == -4))), 1L);
  }
#line 284
  if (tmp___8) {
    {
#line 284
    tmp___7 = safe_read_nocheck_int64(sptr_ptr, eptr);
    }
#line 284
    return (tmp___7);
  }
  {
#line 288
  *sptr_ptr = sptr;
#line 289
  raise_Error(7);
  }
}
}
#line 292 "/home/june/repo/benchmarks/collector/temp/bin-prot-109.30.00/_build/lib/read_stubs.c"
value read_nativeint_stub(char **sptr_ptr , char *eptr ) 
{ 
  long tmp ;
  value tmp___0 ;

  {
  {
#line 294
  tmp = read_nativeint(sptr_ptr, eptr);
#line 294
  tmp___0 = caml_copy_nativeint(tmp);
  }
#line 294
  return (tmp___0);
}
}
#line 300 "/home/june/repo/benchmarks/collector/temp/bin-prot-109.30.00/_build/lib/read_stubs.c"
value read_unit_stub(char **sptr_ptr , char *eptr ) 
{ 
  char *sptr ;
  int res ;
  long tmp ;

  {
  {
#line 302
  sptr = *sptr_ptr;
#line 304
  tmp = __builtin_expect((long )(! (! ((unsigned long )sptr >= (unsigned long )eptr))),
                         0L);
  }
#line 304
  if (tmp) {
    {
#line 304
    caml_raise_constant(*v_bin_prot_exc_Buffer_short);
    }
  }
#line 305
  res = (int )*sptr;
#line 306
  if (res == 0) {
#line 306
    sptr ++;
#line 306
    *sptr_ptr = sptr;
#line 306
    return (1L);
  }
  {
#line 307
  raise_Error(8);
  }
}
}
#line 326 "/home/june/repo/benchmarks/collector/temp/bin-prot-109.30.00/_build/lib/read_stubs.c"
value read_bool_stub(char **sptr_ptr , char *eptr ) 
{ 
  char *sptr ;
  int res ;
  long tmp ;

  {
  {
#line 326
  sptr = *sptr_ptr;
#line 326
  tmp = __builtin_expect((long )(! (! ((unsigned long )sptr >= (unsigned long )eptr))),
                         0L);
  }
#line 326
  if (tmp) {
    {
#line 326
    caml_raise_constant(*v_bin_prot_exc_Buffer_short);
    }
  }
#line 326
  res = (int )*sptr;
#line 326
  if (res == 0) {
#line 326
    sptr ++;
#line 326
    *sptr_ptr = sptr;
#line 326
    return (1L);
  }
#line 326
  if (res == 1) {
#line 326
    sptr ++;
#line 326
    *sptr_ptr = sptr;
#line 326
    return ((1L << 1) + 1L);
  }
  {
#line 326
  raise_Error(9);
  }
}
}
#line 327 "/home/june/repo/benchmarks/collector/temp/bin-prot-109.30.00/_build/lib/read_stubs.c"
value read_option_bool_stub(char **sptr_ptr , char *eptr ) 
{ 
  char *sptr ;
  int res ;
  long tmp ;

  {
  {
#line 327
  sptr = *sptr_ptr;
#line 327
  tmp = __builtin_expect((long )(! (! ((unsigned long )sptr >= (unsigned long )eptr))),
                         0L);
  }
#line 327
  if (tmp) {
    {
#line 327
    caml_raise_constant(*v_bin_prot_exc_Buffer_short);
    }
  }
#line 327
  res = (int )*sptr;
#line 327
  if (res == 0) {
#line 327
    sptr ++;
#line 327
    *sptr_ptr = sptr;
#line 327
    return (1L);
  }
#line 327
  if (res == 1) {
#line 327
    sptr ++;
#line 327
    *sptr_ptr = sptr;
#line 327
    return ((1L << 1) + 1L);
  }
  {
#line 327
  raise_Error(10);
  }
}
}
#line 332 "/home/june/repo/benchmarks/collector/temp/bin-prot-109.30.00/_build/lib/read_stubs.c"
value read_char_stub(char **sptr_ptr , char *eptr ) 
{ 
  char *sptr ;
  unsigned char res ;
  long tmp ;

  {
  {
#line 334
  sptr = *sptr_ptr;
#line 336
  tmp = __builtin_expect((long )(! (! ((unsigned long )sptr >= (unsigned long )eptr))),
                         0L);
  }
#line 336
  if (tmp) {
    {
#line 336
    caml_raise_constant(*v_bin_prot_exc_Buffer_short);
    }
  }
#line 337
  res = (unsigned char )*sptr;
#line 338
  sptr ++;
#line 338
  *sptr_ptr = sptr;
#line 339
  return (((intnat )res << 1) + 1L);
}
}
#line 341 "/home/june/repo/benchmarks/collector/temp/bin-prot-109.30.00/_build/lib/read_stubs.c"
value ml_read_char_stub(value v_buf , value v_pos_ref ) 
{ 
  struct caml__roots_block *caml__frame ;
  struct caml__roots_block caml__roots_v_buf ;
  int caml__dummy_v_buf  __attribute__((__unused__)) ;
  struct caml_ba_array *buf ;
  char *start ;
  long pos ;
  char *sptr ;
  char **sptr_ptr ;
  char *eptr ;
  value v_res ;
  long tmp ;
  value caml__temp_result ;

  {
  {
#line 341
  caml__frame = caml_local_roots;
#line 341
  caml__roots_v_buf.next = caml_local_roots;
#line 341
  caml_local_roots = & caml__roots_v_buf;
#line 341
  caml__roots_v_buf.nitems = (intnat )1;
#line 341
  caml__roots_v_buf.ntables = (intnat )2;
#line 341
  caml__roots_v_buf.tables[0] = & v_buf;
#line 341
  caml__roots_v_buf.tables[1] = & v_pos_ref;
#line 341
  caml__dummy_v_buf = 0;
#line 341
  buf = (struct caml_ba_array *)((void *)((value *)v_buf + 1));
#line 341
  start = (char *)buf->data;
#line 341
  pos = *((value *)v_pos_ref + 0) >> 1;
#line 341
  sptr = start + pos;
#line 341
  sptr_ptr = & sptr;
#line 341
  eptr = start + buf->dim[0];
#line 341
  tmp = __builtin_expect((long )(! (! (pos < 0L))), 0L);
  }
#line 341
  if (tmp) {
    {
#line 341
    caml_array_bound_error();
    }
  }
  {
#line 341
  v_res = read_char_stub(sptr_ptr, eptr);
#line 341
  *((value *)v_pos_ref + 0) = ((sptr - start) << 1) + 1L;
  }
  {
#line 341
  while (1) {
    while_continue: /* CIL Label */ ;
#line 341
    caml__temp_result = v_res;
#line 341
    caml_local_roots = caml__frame;
#line 341
    return (caml__temp_result);
#line 341
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 341
  return (0L);
}
}
#line 346 "/home/june/repo/benchmarks/collector/temp/bin-prot-109.30.00/_build/lib/read_stubs.c"
value read_string_stub(char **sptr_ptr , char *eptr ) 
{ 
  value v_res ;
  char *start ;
  unsigned long len ;
  unsigned long tmp ;
  char *sptr ;
  char *next ;
  long tmp___0 ;
  long tmp___1 ;

  {
  {
#line 349
  start = *sptr_ptr;
#line 350
  tmp = read_nat0(sptr_ptr, eptr);
#line 350
  len = tmp;
#line 351
  sptr = *sptr_ptr;
#line 352
  next = sptr + len;
#line 353
  tmp___0 = __builtin_expect((long )(! (! (len > (unsigned long )((1L << 54) - 1L) * sizeof(value ) - 1UL))),
                             0L);
  }
#line 353
  if (tmp___0) {
    {
#line 354
    *sptr_ptr = start;
#line 355
    raise_Error(11);
    }
  }
  {
#line 357
  tmp___1 = __builtin_expect((long )(! (! ((unsigned long )next > (unsigned long )eptr))),
                             0L);
  }
#line 357
  if (tmp___1) {
    {
#line 357
    caml_raise_constant(*v_bin_prot_exc_Buffer_short);
    }
  }
  {
#line 358
  *sptr_ptr = next;
#line 359
  v_res = caml_alloc_string(len);
#line 360
  memcpy((void */* __restrict  */)((char *)v_res), (void const   */* __restrict  */)sptr,
         len);
  }
#line 361
  return (v_res);
}
}
#line 367 "/home/june/repo/benchmarks/collector/temp/bin-prot-109.30.00/_build/lib/read_stubs.c"
__inline value ( __attribute__((__always_inline__)) read_float_stub)(char **sptr_ptr ,
                                                                     char *eptr ) 
{ 
  char *sptr ;
  char *next ;
  double n ;
  long tmp ;
  value tmp___0 ;

  {
  {
#line 369
  sptr = *sptr_ptr;
#line 370
  next = sptr + sizeof(double );
#line 372
  tmp = __builtin_expect((long )(! (! ((unsigned long )next > (unsigned long )eptr))),
                         0L);
  }
#line 372
  if (tmp) {
    {
#line 372
    caml_raise_constant(*v_bin_prot_exc_Buffer_short);
    }
  }
  {
#line 373
  *sptr_ptr = next;
#line 374
  memcpy((void */* __restrict  */)(& n), (void const   */* __restrict  */)sptr, sizeof(double ));
#line 375
  tmp___0 = caml_copy_double(n);
  }
#line 375
  return (tmp___0);
}
}
#line 378 "/home/june/repo/benchmarks/collector/temp/bin-prot-109.30.00/_build/lib/read_stubs.c"
value ml_read_float_stub(value v_buf , value v_pos_ref ) 
{ 
  struct caml__roots_block *caml__frame ;
  struct caml__roots_block caml__roots_v_buf ;
  int caml__dummy_v_buf  __attribute__((__unused__)) ;
  struct caml_ba_array *buf ;
  char *start ;
  long pos ;
  char *sptr ;
  char **sptr_ptr ;
  char *eptr ;
  value v_res ;
  long tmp ;
  value caml__temp_result ;

  {
  {
#line 378
  caml__frame = caml_local_roots;
#line 378
  caml__roots_v_buf.next = caml_local_roots;
#line 378
  caml_local_roots = & caml__roots_v_buf;
#line 378
  caml__roots_v_buf.nitems = (intnat )1;
#line 378
  caml__roots_v_buf.ntables = (intnat )2;
#line 378
  caml__roots_v_buf.tables[0] = & v_buf;
#line 378
  caml__roots_v_buf.tables[1] = & v_pos_ref;
#line 378
  caml__dummy_v_buf = 0;
#line 378
  buf = (struct caml_ba_array *)((void *)((value *)v_buf + 1));
#line 378
  start = (char *)buf->data;
#line 378
  pos = *((value *)v_pos_ref + 0) >> 1;
#line 378
  sptr = start + pos;
#line 378
  sptr_ptr = & sptr;
#line 378
  eptr = start + buf->dim[0];
#line 378
  tmp = __builtin_expect((long )(! (! (pos < 0L))), 0L);
  }
#line 378
  if (tmp) {
    {
#line 378
    caml_array_bound_error();
    }
  }
  {
#line 378
  v_res = read_float_stub(sptr_ptr, eptr);
#line 378
  *((value *)v_pos_ref + 0) = ((sptr - start) << 1) + 1L;
  }
  {
#line 378
  while (1) {
    while_continue: /* CIL Label */ ;
#line 378
    caml__temp_result = v_res;
#line 378
    caml_local_roots = caml__frame;
#line 378
    return (caml__temp_result);
#line 378
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 378
  return (0L);
}
}
#line 380 "/home/june/repo/benchmarks/collector/temp/bin-prot-109.30.00/_build/lib/read_stubs.c"
value read_float_array_stub(char **sptr_ptr , char *eptr ) 
{ 
  char *start ;
  unsigned long len ;
  unsigned long tmp ;
  unsigned long tot_size ;
  unsigned long wsize ;
  char *sptr ;
  char *next ;
  value v_res ;
  long tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;

  {
  {
#line 382
  start = *sptr_ptr;
#line 383
  tmp = read_nat0(sptr_ptr, eptr);
#line 383
  len = tmp;
#line 389
  tmp___0 = __builtin_expect((long )(! (! (len == 0UL))), 0L);
  }
#line 389
  if (tmp___0) {
#line 389
    return ((value )(& caml_atom_table[0] + 1));
  }
  {
#line 390
  wsize = len * (sizeof(double ) / sizeof(value ));
#line 391
  tmp___1 = __builtin_expect((long )(! (! (wsize > (unsigned long )((1L << 54) - 1L)))),
                             0L);
  }
#line 391
  if (tmp___1) {
    {
#line 392
    *sptr_ptr = start;
#line 393
    raise_Error(13);
    }
  }
  {
#line 395
  sptr = *sptr_ptr;
#line 396
  tot_size = len * sizeof(double );
#line 397
  next = sptr + tot_size;
#line 398
  tmp___2 = __builtin_expect((long )(! (! ((unsigned long )next > (unsigned long )eptr))),
                             0L);
  }
#line 398
  if (tmp___2) {
    {
#line 398
    caml_raise_constant(*v_bin_prot_exc_Buffer_short);
    }
  }
  {
#line 399
  *sptr_ptr = next;
#line 400
  v_res = caml_alloc(wsize, (tag_t )254);
#line 401
  memcpy((void */* __restrict  */)((double *)v_res), (void const   */* __restrict  */)sptr,
         tot_size);
  }
#line 402
  return (v_res);
}
}
#line 405 "/home/june/repo/benchmarks/collector/temp/bin-prot-109.30.00/_build/lib/read_stubs.c"
value ml_read_float_array_stub(value v_buf , value v_pos_ref ) 
{ 
  struct caml__roots_block *caml__frame ;
  struct caml__roots_block caml__roots_v_buf ;
  int caml__dummy_v_buf  __attribute__((__unused__)) ;
  struct caml_ba_array *buf ;
  char *start ;
  long pos ;
  char *sptr ;
  char **sptr_ptr ;
  char *eptr ;
  value v_res ;
  unsigned long len ;
  unsigned long tot_size ;
  unsigned long wsize ;
  char *next ;
  long tmp ;
  value caml__temp_result ;
  long tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  value caml__temp_result___0 ;

  {
  {
#line 407
  caml__frame = caml_local_roots;
#line 407
  caml__roots_v_buf.next = caml_local_roots;
#line 407
  caml_local_roots = & caml__roots_v_buf;
#line 407
  caml__roots_v_buf.nitems = (intnat )1;
#line 407
  caml__roots_v_buf.ntables = (intnat )2;
#line 407
  caml__roots_v_buf.tables[0] = & v_buf;
#line 407
  caml__roots_v_buf.tables[1] = & v_pos_ref;
#line 407
  caml__dummy_v_buf = 0;
#line 408
  buf = (struct caml_ba_array *)((void *)((value *)v_buf + 1));
#line 409
  start = (char *)buf->data;
#line 410
  pos = *((value *)v_pos_ref + 0) >> 1;
#line 411
  sptr = start + pos;
#line 412
  sptr_ptr = & sptr;
#line 413
  eptr = start + buf->dim[0];
#line 419
  tmp = __builtin_expect((long )(! (! (pos < 0L))), 0L);
  }
#line 419
  if (tmp) {
    {
#line 419
    caml_array_bound_error();
    }
  }
  {
#line 420
  len = read_nat0(sptr_ptr, eptr);
#line 421
  tmp___0 = __builtin_expect((long )(! (! (len == 0UL))), 0L);
  }
#line 421
  if (tmp___0) {
#line 422
    *((value *)v_pos_ref + 0) = ((sptr - start) << 1) + 1L;
    {
#line 423
    while (1) {
      while_continue: /* CIL Label */ ;
#line 423
      caml__temp_result = (value )(& caml_atom_table[0] + 1);
#line 423
      caml_local_roots = caml__frame;
#line 423
      return (caml__temp_result);
#line 423
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 425
  wsize = len * (sizeof(double ) / sizeof(value ));
#line 426
  tmp___1 = __builtin_expect((long )(! (! (wsize > (unsigned long )((1L << 54) - 1L)))),
                             0L);
  }
#line 426
  if (tmp___1) {
    {
#line 427
    raise_Read_error(13, (unsigned long )pos);
    }
  }
  {
#line 428
  tot_size = len * sizeof(double );
#line 429
  next = sptr + tot_size;
#line 430
  tmp___2 = __builtin_expect((long )(! (! ((unsigned long )next > (unsigned long )eptr))),
                             0L);
  }
#line 430
  if (tmp___2) {
    {
#line 430
    caml_raise_constant(*v_bin_prot_exc_Buffer_short);
    }
  }
  {
#line 431
  v_res = caml_alloc(wsize, (tag_t )254);
#line 432
  memcpy((void */* __restrict  */)((double *)v_res), (void const   */* __restrict  */)sptr,
         tot_size);
#line 433
  *((value *)v_pos_ref + 0) = ((next - start) << 1) + 1L;
  }
  {
#line 434
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 434
    caml__temp_result___0 = v_res;
#line 434
    caml_local_roots = caml__frame;
#line 434
    return (caml__temp_result___0);
#line 434
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 435
  return (0L);
}
}
#line 440 "/home/june/repo/benchmarks/collector/temp/bin-prot-109.30.00/_build/lib/read_stubs.c"
value read_variant_tag_stub(char **sptr_ptr , char *eptr ) 
{ 
  char *sptr ;
  char *next ;
  int n ;
  long tmp ;
  uint32_t __n ;
  long tmp___0 ;

  {
  {
#line 442
  sptr = *sptr_ptr;
#line 443
  next = sptr + 4;
#line 445
  tmp = __builtin_expect((long )(! (! ((unsigned long )next > (unsigned long )eptr))),
                         0L);
  }
#line 445
  if (tmp) {
    {
#line 445
    caml_raise_constant(*v_bin_prot_exc_Buffer_short);
    }
  }
  {
#line 446
  memcpy((void */* __restrict  */)(& __n), (void const   */* __restrict  */)sptr,
         (size_t )4);
#line 446
  n = (int )__n;
#line 447
  tmp___0 = __builtin_expect((long )(! (! ((n & 1) != 0))), 1L);
  }
#line 447
  if (tmp___0) {
#line 448
    *sptr_ptr = next;
#line 449
    return ((value )n);
  }
  {
#line 451
  raise_Error(12);
  }
}
}
#line 454 "/home/june/repo/benchmarks/collector/temp/bin-prot-109.30.00/_build/lib/read_stubs.c"
value ml_read_variant_tag_stub(value v_buf , value v_pos_ref ) 
{ 
  struct caml_ba_array *buf ;
  char *start ;
  long pos ;
  char *sptr ;
  unsigned long next_pos ;
  int n ;
  long tmp ;
  long tmp___0 ;
  uint32_t __n ;
  long tmp___1 ;

  {
  {
#line 456
  buf = (struct caml_ba_array *)((void *)((value *)v_buf + 1));
#line 457
  start = (char *)buf->data;
#line 458
  pos = *((value *)v_pos_ref + 0) >> 1;
#line 459
  sptr = start + pos;
#line 460
  next_pos = (unsigned long )pos + 4UL;
#line 462
  tmp = __builtin_expect((long )(! (! (pos < 0L))), 0L);
  }
#line 462
  if (tmp) {
    {
#line 462
    caml_array_bound_error();
    }
  }
  {
#line 463
  tmp___0 = __builtin_expect((long )(! (! (next_pos > (unsigned long )buf->dim[0]))),
                             0L);
  }
#line 463
  if (tmp___0) {
    {
#line 464
    caml_raise_constant(*v_bin_prot_exc_Buffer_short);
    }
  }
  {
#line 465
  memcpy((void */* __restrict  */)(& __n), (void const   */* __restrict  */)sptr,
         (size_t )4);
#line 465
  n = (int )__n;
#line 466
  tmp___1 = __builtin_expect((long )(! (! ((n & 1) != 0))), 1L);
  }
#line 466
  if (tmp___1) {
#line 467
    *((value *)v_pos_ref + 0) = ((intnat )next_pos << 1) + 1L;
#line 468
    return ((value )n);
  } else {
    {
#line 470
    raise_Read_error(12, (unsigned long )pos);
    }
  }
}
}
#line 476 "/home/june/repo/benchmarks/collector/temp/bin-prot-109.30.00/_build/lib/read_stubs.c"
__inline value ( __attribute__((__always_inline__)) read_raw_string_stub)(char **sptr_ptr ,
                                                                          char *eptr ,
                                                                          value v_str ,
                                                                          value v_pos ,
                                                                          value v_len ) 
{ 
  size_t pos ;
  size_t len ;
  char *sptr ;
  char *next ;
  long tmp ;

  {
  {
#line 479
  pos = (size_t )(v_pos >> 1);
#line 479
  len = (size_t )(v_len >> 1);
#line 480
  sptr = *sptr_ptr;
#line 481
  next = sptr + len;
#line 482
  tmp = __builtin_expect((long )(! (! ((unsigned long )next > (unsigned long )eptr))),
                         0L);
  }
#line 482
  if (tmp) {
    {
#line 482
    caml_raise_constant(*v_bin_prot_exc_Buffer_short);
    }
  }
  {
#line 483
  *sptr_ptr = next;
#line 484
  memcpy((void */* __restrict  */)((char *)v_str + pos), (void const   */* __restrict  */)sptr,
         len);
  }
#line 485
  return (1L);
}
}
#line 519 "/home/june/repo/benchmarks/collector/temp/bin-prot-109.30.00/_build/lib/read_stubs.c"
__inline value ( __attribute__((__always_inline__)) read_bigstring_stub)(char **sptr_ptr ,
                                                                         char *eptr ) 
{ 
  unsigned long len ;
  unsigned long tmp ;
  unsigned long tot_size ;
  char *sptr ;
  char *next ;
  intnat dim ;
  value v_res ;
  long tmp___0 ;
  struct caml__roots_block caml__roots_block ;
  long tmp___1 ;

  {
  {
#line 519
  tmp = read_nat0(sptr_ptr, eptr);
#line 519
  len = tmp;
#line 519
  tot_size = len * sizeof(char );
#line 519
  sptr = *sptr_ptr;
#line 519
  next = sptr + tot_size;
#line 519
  tmp___0 = __builtin_expect((long )(! (! ((unsigned long )next > (unsigned long )eptr))),
                             0L);
  }
#line 519
  if (tmp___0) {
    {
#line 519
    caml_raise_constant(*v_bin_prot_exc_Buffer_short);
    }
  }
  {
#line 519
  dim = (intnat )len;
#line 519
  v_res = caml_ba_alloc(3, 1, (void *)0, & dim);
#line 519
  *sptr_ptr = next;
#line 519
  tmp___1 = __builtin_expect((long )(! (! (tot_size > 65536UL))), 0L);
  }
#line 519
  if (tmp___1) {
    {
#line 519
    caml__roots_block.next = caml_local_roots;
#line 519
    caml_local_roots = & caml__roots_block;
#line 519
    caml__roots_block.nitems = (intnat )1;
#line 519
    caml__roots_block.ntables = (intnat )1;
#line 519
    caml__roots_block.tables[0] = & v_res;
#line 519
    caml_enter_blocking_section();
#line 519
    memcpy((void */* __restrict  */)((char *)((struct caml_ba_array *)((void *)((value *)v_res + 1)))->data),
           (void const   */* __restrict  */)sptr, tot_size);
#line 519
    caml_leave_blocking_section();
#line 519
    caml_local_roots = caml__roots_block.next;
    }
  } else {
    {
#line 519
    memcpy((void */* __restrict  */)((char *)((struct caml_ba_array *)((void *)((value *)v_res + 1)))->data),
           (void const   */* __restrict  */)sptr, tot_size);
    }
  }
#line 519
  return (v_res);
}
}
#line 519 "/home/june/repo/benchmarks/collector/temp/bin-prot-109.30.00/_build/lib/read_stubs.c"
value ml_read_bigstring_stub(value v_buf , value v_pos_ref ) 
{ 
  struct caml__roots_block *caml__frame ;
  struct caml__roots_block caml__roots_v_buf ;
  int caml__dummy_v_buf  __attribute__((__unused__)) ;
  struct caml_ba_array *buf ;
  char *start ;
  long pos ;
  char *sptr ;
  char **sptr_ptr ;
  char *eptr ;
  value v_res ;
  long tmp ;
  value caml__temp_result ;

  {
  {
#line 519
  caml__frame = caml_local_roots;
#line 519
  caml__roots_v_buf.next = caml_local_roots;
#line 519
  caml_local_roots = & caml__roots_v_buf;
#line 519
  caml__roots_v_buf.nitems = (intnat )1;
#line 519
  caml__roots_v_buf.ntables = (intnat )2;
#line 519
  caml__roots_v_buf.tables[0] = & v_buf;
#line 519
  caml__roots_v_buf.tables[1] = & v_pos_ref;
#line 519
  caml__dummy_v_buf = 0;
#line 519
  buf = (struct caml_ba_array *)((void *)((value *)v_buf + 1));
#line 519
  start = (char *)buf->data;
#line 519
  pos = *((value *)v_pos_ref + 0) >> 1;
#line 519
  sptr = start + pos;
#line 519
  sptr_ptr = & sptr;
#line 519
  eptr = start + buf->dim[0];
#line 519
  tmp = __builtin_expect((long )(! (! (pos < 0L))), 0L);
  }
#line 519
  if (tmp) {
    {
#line 519
    caml_array_bound_error();
    }
  }
  {
#line 519
  v_res = read_bigstring_stub(sptr_ptr, eptr);
#line 519
  *((value *)v_pos_ref + 0) = ((sptr - start) << 1) + 1L;
  }
  {
#line 519
  while (1) {
    while_continue: /* CIL Label */ ;
#line 519
    caml__temp_result = v_res;
#line 519
    caml_local_roots = caml__frame;
#line 519
    return (caml__temp_result);
#line 519
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 519
  return (0L);
}
}
#line 554 "/home/june/repo/benchmarks/collector/temp/bin-prot-109.30.00/_build/lib/read_stubs.c"
__inline value ( __attribute__((__always_inline__)) read_float32_vec_stub)(char **sptr_ptr ,
                                                                           char *eptr ) 
{ 
  unsigned long len ;
  unsigned long tmp ;
  unsigned long tot_size ;
  char *sptr ;
  char *next ;
  intnat dim ;
  value v_res ;
  long tmp___0 ;
  struct caml__roots_block caml__roots_block ;
  long tmp___1 ;

  {
  {
#line 554
  tmp = read_nat0(sptr_ptr, eptr);
#line 554
  len = tmp;
#line 554
  tot_size = len * sizeof(float );
#line 554
  sptr = *sptr_ptr;
#line 554
  next = sptr + tot_size;
#line 554
  tmp___0 = __builtin_expect((long )(! (! ((unsigned long )next > (unsigned long )eptr))),
                             0L);
  }
#line 554
  if (tmp___0) {
    {
#line 554
    caml_raise_constant(*v_bin_prot_exc_Buffer_short);
    }
  }
  {
#line 554
  dim = (intnat )len;
#line 554
  v_res = caml_ba_alloc(256, 1, (void *)0, & dim);
#line 554
  *sptr_ptr = next;
#line 554
  tmp___1 = __builtin_expect((long )(! (! (tot_size > 65536UL))), 0L);
  }
#line 554
  if (tmp___1) {
    {
#line 554
    caml__roots_block.next = caml_local_roots;
#line 554
    caml_local_roots = & caml__roots_block;
#line 554
    caml__roots_block.nitems = (intnat )1;
#line 554
    caml__roots_block.ntables = (intnat )1;
#line 554
    caml__roots_block.tables[0] = & v_res;
#line 554
    caml_enter_blocking_section();
#line 554
    memcpy((void */* __restrict  */)((float *)((struct caml_ba_array *)((void *)((value *)v_res + 1)))->data),
           (void const   */* __restrict  */)sptr, tot_size);
#line 554
    caml_leave_blocking_section();
#line 554
    caml_local_roots = caml__roots_block.next;
    }
  } else {
    {
#line 554
    memcpy((void */* __restrict  */)((float *)((struct caml_ba_array *)((void *)((value *)v_res + 1)))->data),
           (void const   */* __restrict  */)sptr, tot_size);
    }
  }
#line 554
  return (v_res);
}
}
#line 554 "/home/june/repo/benchmarks/collector/temp/bin-prot-109.30.00/_build/lib/read_stubs.c"
value ml_read_float32_vec_stub(value v_buf , value v_pos_ref ) 
{ 
  struct caml__roots_block *caml__frame ;
  struct caml__roots_block caml__roots_v_buf ;
  int caml__dummy_v_buf  __attribute__((__unused__)) ;
  struct caml_ba_array *buf ;
  char *start ;
  long pos ;
  char *sptr ;
  char **sptr_ptr ;
  char *eptr ;
  value v_res ;
  long tmp ;
  value caml__temp_result ;

  {
  {
#line 554
  caml__frame = caml_local_roots;
#line 554
  caml__roots_v_buf.next = caml_local_roots;
#line 554
  caml_local_roots = & caml__roots_v_buf;
#line 554
  caml__roots_v_buf.nitems = (intnat )1;
#line 554
  caml__roots_v_buf.ntables = (intnat )2;
#line 554
  caml__roots_v_buf.tables[0] = & v_buf;
#line 554
  caml__roots_v_buf.tables[1] = & v_pos_ref;
#line 554
  caml__dummy_v_buf = 0;
#line 554
  buf = (struct caml_ba_array *)((void *)((value *)v_buf + 1));
#line 554
  start = (char *)buf->data;
#line 554
  pos = *((value *)v_pos_ref + 0) >> 1;
#line 554
  sptr = start + pos;
#line 554
  sptr_ptr = & sptr;
#line 554
  eptr = start + buf->dim[0];
#line 554
  tmp = __builtin_expect((long )(! (! (pos < 0L))), 0L);
  }
#line 554
  if (tmp) {
    {
#line 554
    caml_array_bound_error();
    }
  }
  {
#line 554
  v_res = read_float32_vec_stub(sptr_ptr, eptr);
#line 554
  *((value *)v_pos_ref + 0) = ((sptr - start) << 1) + 1L;
  }
  {
#line 554
  while (1) {
    while_continue: /* CIL Label */ ;
#line 554
    caml__temp_result = v_res;
#line 554
    caml_local_roots = caml__frame;
#line 554
    return (caml__temp_result);
#line 554
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 554
  return (0L);
}
}
#line 554 "/home/june/repo/benchmarks/collector/temp/bin-prot-109.30.00/_build/lib/read_stubs.c"
__inline value ( __attribute__((__always_inline__)) read_float32_mat_stub)(char **sptr_ptr ,
                                                                           char *eptr ) 
{ 
  unsigned long dim1 ;
  unsigned long tmp ;
  unsigned long dim2 ;
  unsigned long tmp___0 ;
  unsigned long size ;
  unsigned long tot_size ;
  char *sptr ;
  char *next ;
  intnat dims[2] ;
  value v_res ;
  long tmp___1 ;
  struct caml__roots_block caml__roots_block ;
  long tmp___2 ;

  {
  {
#line 554
  tmp = read_nat0(sptr_ptr, eptr);
#line 554
  dim1 = tmp;
#line 554
  tmp___0 = read_nat0(sptr_ptr, eptr);
#line 554
  dim2 = tmp___0;
#line 554
  size = dim1 * dim2;
#line 554
  tot_size = size * sizeof(float );
#line 554
  sptr = *sptr_ptr;
#line 554
  next = sptr + tot_size;
#line 554
  tmp___1 = __builtin_expect((long )(! (! ((unsigned long )next > (unsigned long )eptr))),
                             0L);
  }
#line 554
  if (tmp___1) {
    {
#line 554
    caml_raise_constant(*v_bin_prot_exc_Buffer_short);
    }
  }
  {
#line 554
  dims[0] = (intnat )dim1;
#line 554
  dims[1] = (intnat )dim2;
#line 554
  v_res = caml_ba_alloc(256, 2, (void *)0, dims);
#line 554
  *sptr_ptr = next;
#line 554
  tmp___2 = __builtin_expect((long )(! (! (tot_size > 65536UL))), 0L);
  }
#line 554
  if (tmp___2) {
    {
#line 554
    caml__roots_block.next = caml_local_roots;
#line 554
    caml_local_roots = & caml__roots_block;
#line 554
    caml__roots_block.nitems = (intnat )1;
#line 554
    caml__roots_block.ntables = (intnat )1;
#line 554
    caml__roots_block.tables[0] = & v_res;
#line 554
    caml_enter_blocking_section();
#line 554
    memcpy((void */* __restrict  */)((float *)((struct caml_ba_array *)((void *)((value *)v_res + 1)))->data),
           (void const   */* __restrict  */)sptr, tot_size);
#line 554
    caml_leave_blocking_section();
#line 554
    caml_local_roots = caml__roots_block.next;
    }
  } else {
    {
#line 554
    memcpy((void */* __restrict  */)((float *)((struct caml_ba_array *)((void *)((value *)v_res + 1)))->data),
           (void const   */* __restrict  */)sptr, tot_size);
    }
  }
#line 554
  return (v_res);
}
}
#line 554 "/home/june/repo/benchmarks/collector/temp/bin-prot-109.30.00/_build/lib/read_stubs.c"
value ml_read_float32_mat_stub(value v_buf , value v_pos_ref ) 
{ 
  struct caml__roots_block *caml__frame ;
  struct caml__roots_block caml__roots_v_buf ;
  int caml__dummy_v_buf  __attribute__((__unused__)) ;
  struct caml_ba_array *buf ;
  char *start ;
  long pos ;
  char *sptr ;
  char **sptr_ptr ;
  char *eptr ;
  value v_res ;
  long tmp ;
  value caml__temp_result ;

  {
  {
#line 554
  caml__frame = caml_local_roots;
#line 554
  caml__roots_v_buf.next = caml_local_roots;
#line 554
  caml_local_roots = & caml__roots_v_buf;
#line 554
  caml__roots_v_buf.nitems = (intnat )1;
#line 554
  caml__roots_v_buf.ntables = (intnat )2;
#line 554
  caml__roots_v_buf.tables[0] = & v_buf;
#line 554
  caml__roots_v_buf.tables[1] = & v_pos_ref;
#line 554
  caml__dummy_v_buf = 0;
#line 554
  buf = (struct caml_ba_array *)((void *)((value *)v_buf + 1));
#line 554
  start = (char *)buf->data;
#line 554
  pos = *((value *)v_pos_ref + 0) >> 1;
#line 554
  sptr = start + pos;
#line 554
  sptr_ptr = & sptr;
#line 554
  eptr = start + buf->dim[0];
#line 554
  tmp = __builtin_expect((long )(! (! (pos < 0L))), 0L);
  }
#line 554
  if (tmp) {
    {
#line 554
    caml_array_bound_error();
    }
  }
  {
#line 554
  v_res = read_float32_mat_stub(sptr_ptr, eptr);
#line 554
  *((value *)v_pos_ref + 0) = ((sptr - start) << 1) + 1L;
  }
  {
#line 554
  while (1) {
    while_continue: /* CIL Label */ ;
#line 554
    caml__temp_result = v_res;
#line 554
    caml_local_roots = caml__frame;
#line 554
    return (caml__temp_result);
#line 554
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 554
  return (0L);
}
}
#line 555 "/home/june/repo/benchmarks/collector/temp/bin-prot-109.30.00/_build/lib/read_stubs.c"
__inline value ( __attribute__((__always_inline__)) read_float64_vec_stub)(char **sptr_ptr ,
                                                                           char *eptr ) 
{ 
  unsigned long len ;
  unsigned long tmp ;
  unsigned long tot_size ;
  char *sptr ;
  char *next ;
  intnat dim ;
  value v_res ;
  long tmp___0 ;
  struct caml__roots_block caml__roots_block ;
  long tmp___1 ;

  {
  {
#line 555
  tmp = read_nat0(sptr_ptr, eptr);
#line 555
  len = tmp;
#line 555
  tot_size = len * sizeof(double );
#line 555
  sptr = *sptr_ptr;
#line 555
  next = sptr + tot_size;
#line 555
  tmp___0 = __builtin_expect((long )(! (! ((unsigned long )next > (unsigned long )eptr))),
                             0L);
  }
#line 555
  if (tmp___0) {
    {
#line 555
    caml_raise_constant(*v_bin_prot_exc_Buffer_short);
    }
  }
  {
#line 555
  dim = (intnat )len;
#line 555
  v_res = caml_ba_alloc(257, 1, (void *)0, & dim);
#line 555
  *sptr_ptr = next;
#line 555
  tmp___1 = __builtin_expect((long )(! (! (tot_size > 65536UL))), 0L);
  }
#line 555
  if (tmp___1) {
    {
#line 555
    caml__roots_block.next = caml_local_roots;
#line 555
    caml_local_roots = & caml__roots_block;
#line 555
    caml__roots_block.nitems = (intnat )1;
#line 555
    caml__roots_block.ntables = (intnat )1;
#line 555
    caml__roots_block.tables[0] = & v_res;
#line 555
    caml_enter_blocking_section();
#line 555
    memcpy((void */* __restrict  */)((double *)((struct caml_ba_array *)((void *)((value *)v_res + 1)))->data),
           (void const   */* __restrict  */)sptr, tot_size);
#line 555
    caml_leave_blocking_section();
#line 555
    caml_local_roots = caml__roots_block.next;
    }
  } else {
    {
#line 555
    memcpy((void */* __restrict  */)((double *)((struct caml_ba_array *)((void *)((value *)v_res + 1)))->data),
           (void const   */* __restrict  */)sptr, tot_size);
    }
  }
#line 555
  return (v_res);
}
}
#line 555 "/home/june/repo/benchmarks/collector/temp/bin-prot-109.30.00/_build/lib/read_stubs.c"
value ml_read_float64_vec_stub(value v_buf , value v_pos_ref ) 
{ 
  struct caml__roots_block *caml__frame ;
  struct caml__roots_block caml__roots_v_buf ;
  int caml__dummy_v_buf  __attribute__((__unused__)) ;
  struct caml_ba_array *buf ;
  char *start ;
  long pos ;
  char *sptr ;
  char **sptr_ptr ;
  char *eptr ;
  value v_res ;
  long tmp ;
  value caml__temp_result ;

  {
  {
#line 555
  caml__frame = caml_local_roots;
#line 555
  caml__roots_v_buf.next = caml_local_roots;
#line 555
  caml_local_roots = & caml__roots_v_buf;
#line 555
  caml__roots_v_buf.nitems = (intnat )1;
#line 555
  caml__roots_v_buf.ntables = (intnat )2;
#line 555
  caml__roots_v_buf.tables[0] = & v_buf;
#line 555
  caml__roots_v_buf.tables[1] = & v_pos_ref;
#line 555
  caml__dummy_v_buf = 0;
#line 555
  buf = (struct caml_ba_array *)((void *)((value *)v_buf + 1));
#line 555
  start = (char *)buf->data;
#line 555
  pos = *((value *)v_pos_ref + 0) >> 1;
#line 555
  sptr = start + pos;
#line 555
  sptr_ptr = & sptr;
#line 555
  eptr = start + buf->dim[0];
#line 555
  tmp = __builtin_expect((long )(! (! (pos < 0L))), 0L);
  }
#line 555
  if (tmp) {
    {
#line 555
    caml_array_bound_error();
    }
  }
  {
#line 555
  v_res = read_float64_vec_stub(sptr_ptr, eptr);
#line 555
  *((value *)v_pos_ref + 0) = ((sptr - start) << 1) + 1L;
  }
  {
#line 555
  while (1) {
    while_continue: /* CIL Label */ ;
#line 555
    caml__temp_result = v_res;
#line 555
    caml_local_roots = caml__frame;
#line 555
    return (caml__temp_result);
#line 555
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 555
  return (0L);
}
}
#line 555 "/home/june/repo/benchmarks/collector/temp/bin-prot-109.30.00/_build/lib/read_stubs.c"
__inline value ( __attribute__((__always_inline__)) read_float64_mat_stub)(char **sptr_ptr ,
                                                                           char *eptr ) 
{ 
  unsigned long dim1 ;
  unsigned long tmp ;
  unsigned long dim2 ;
  unsigned long tmp___0 ;
  unsigned long size ;
  unsigned long tot_size ;
  char *sptr ;
  char *next ;
  intnat dims[2] ;
  value v_res ;
  long tmp___1 ;
  struct caml__roots_block caml__roots_block ;
  long tmp___2 ;

  {
  {
#line 555
  tmp = read_nat0(sptr_ptr, eptr);
#line 555
  dim1 = tmp;
#line 555
  tmp___0 = read_nat0(sptr_ptr, eptr);
#line 555
  dim2 = tmp___0;
#line 555
  size = dim1 * dim2;
#line 555
  tot_size = size * sizeof(double );
#line 555
  sptr = *sptr_ptr;
#line 555
  next = sptr + tot_size;
#line 555
  tmp___1 = __builtin_expect((long )(! (! ((unsigned long )next > (unsigned long )eptr))),
                             0L);
  }
#line 555
  if (tmp___1) {
    {
#line 555
    caml_raise_constant(*v_bin_prot_exc_Buffer_short);
    }
  }
  {
#line 555
  dims[0] = (intnat )dim1;
#line 555
  dims[1] = (intnat )dim2;
#line 555
  v_res = caml_ba_alloc(257, 2, (void *)0, dims);
#line 555
  *sptr_ptr = next;
#line 555
  tmp___2 = __builtin_expect((long )(! (! (tot_size > 65536UL))), 0L);
  }
#line 555
  if (tmp___2) {
    {
#line 555
    caml__roots_block.next = caml_local_roots;
#line 555
    caml_local_roots = & caml__roots_block;
#line 555
    caml__roots_block.nitems = (intnat )1;
#line 555
    caml__roots_block.ntables = (intnat )1;
#line 555
    caml__roots_block.tables[0] = & v_res;
#line 555
    caml_enter_blocking_section();
#line 555
    memcpy((void */* __restrict  */)((double *)((struct caml_ba_array *)((void *)((value *)v_res + 1)))->data),
           (void const   */* __restrict  */)sptr, tot_size);
#line 555
    caml_leave_blocking_section();
#line 555
    caml_local_roots = caml__roots_block.next;
    }
  } else {
    {
#line 555
    memcpy((void */* __restrict  */)((double *)((struct caml_ba_array *)((void *)((value *)v_res + 1)))->data),
           (void const   */* __restrict  */)sptr, tot_size);
    }
  }
#line 555
  return (v_res);
}
}
#line 555 "/home/june/repo/benchmarks/collector/temp/bin-prot-109.30.00/_build/lib/read_stubs.c"
value ml_read_float64_mat_stub(value v_buf , value v_pos_ref ) 
{ 
  struct caml__roots_block *caml__frame ;
  struct caml__roots_block caml__roots_v_buf ;
  int caml__dummy_v_buf  __attribute__((__unused__)) ;
  struct caml_ba_array *buf ;
  char *start ;
  long pos ;
  char *sptr ;
  char **sptr_ptr ;
  char *eptr ;
  value v_res ;
  long tmp ;
  value caml__temp_result ;

  {
  {
#line 555
  caml__frame = caml_local_roots;
#line 555
  caml__roots_v_buf.next = caml_local_roots;
#line 555
  caml_local_roots = & caml__roots_v_buf;
#line 555
  caml__roots_v_buf.nitems = (intnat )1;
#line 555
  caml__roots_v_buf.ntables = (intnat )2;
#line 555
  caml__roots_v_buf.tables[0] = & v_buf;
#line 555
  caml__roots_v_buf.tables[1] = & v_pos_ref;
#line 555
  caml__dummy_v_buf = 0;
#line 555
  buf = (struct caml_ba_array *)((void *)((value *)v_buf + 1));
#line 555
  start = (char *)buf->data;
#line 555
  pos = *((value *)v_pos_ref + 0) >> 1;
#line 555
  sptr = start + pos;
#line 555
  sptr_ptr = & sptr;
#line 555
  eptr = start + buf->dim[0];
#line 555
  tmp = __builtin_expect((long )(! (! (pos < 0L))), 0L);
  }
#line 555
  if (tmp) {
    {
#line 555
    caml_array_bound_error();
    }
  }
  {
#line 555
  v_res = read_float64_mat_stub(sptr_ptr, eptr);
#line 555
  *((value *)v_pos_ref + 0) = ((sptr - start) << 1) + 1L;
  }
  {
#line 555
  while (1) {
    while_continue: /* CIL Label */ ;
#line 555
    caml__temp_result = v_res;
#line 555
    caml_local_roots = caml__frame;
#line 555
    return (caml__temp_result);
#line 555
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 555
  return (0L);
}
}
#line 560 "/home/june/repo/benchmarks/collector/temp/bin-prot-109.30.00/_build/lib/read_stubs.c"
value read_int_16bit_stub(char **sptr_ptr , char *eptr ) 
{ 
  unsigned short res ;
  unsigned short tmp ;

  {
  {
#line 562
  tmp = safe_read_nat0_16(sptr_ptr, eptr);
#line 562
  res = tmp;
  }
#line 563
  return (((intnat )res << 1) + 1L);
}
}
#line 565 "/home/june/repo/benchmarks/collector/temp/bin-prot-109.30.00/_build/lib/read_stubs.c"
value ml_read_int_16bit_stub(value v_buf , value v_pos_ref ) 
{ 
  struct caml__roots_block *caml__frame ;
  struct caml__roots_block caml__roots_v_buf ;
  int caml__dummy_v_buf  __attribute__((__unused__)) ;
  struct caml_ba_array *buf ;
  char *start ;
  long pos ;
  char *sptr ;
  char **sptr_ptr ;
  char *eptr ;
  value v_res ;
  long tmp ;
  value caml__temp_result ;

  {
  {
#line 565
  caml__frame = caml_local_roots;
#line 565
  caml__roots_v_buf.next = caml_local_roots;
#line 565
  caml_local_roots = & caml__roots_v_buf;
#line 565
  caml__roots_v_buf.nitems = (intnat )1;
#line 565
  caml__roots_v_buf.ntables = (intnat )2;
#line 565
  caml__roots_v_buf.tables[0] = & v_buf;
#line 565
  caml__roots_v_buf.tables[1] = & v_pos_ref;
#line 565
  caml__dummy_v_buf = 0;
#line 565
  buf = (struct caml_ba_array *)((void *)((value *)v_buf + 1));
#line 565
  start = (char *)buf->data;
#line 565
  pos = *((value *)v_pos_ref + 0) >> 1;
#line 565
  sptr = start + pos;
#line 565
  sptr_ptr = & sptr;
#line 565
  eptr = start + buf->dim[0];
#line 565
  tmp = __builtin_expect((long )(! (! (pos < 0L))), 0L);
  }
#line 565
  if (tmp) {
    {
#line 565
    caml_array_bound_error();
    }
  }
  {
#line 565
  v_res = read_int_16bit_stub(sptr_ptr, eptr);
#line 565
  *((value *)v_pos_ref + 0) = ((sptr - start) << 1) + 1L;
  }
  {
#line 565
  while (1) {
    while_continue: /* CIL Label */ ;
#line 565
    caml__temp_result = v_res;
#line 565
    caml_local_roots = caml__frame;
#line 565
    return (caml__temp_result);
#line 565
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 565
  return (0L);
}
}
#line 567 "/home/june/repo/benchmarks/collector/temp/bin-prot-109.30.00/_build/lib/read_stubs.c"
value read_int_32bit_stub(char **sptr_ptr , char *eptr ) 
{ 
  unsigned int res ;
  unsigned int tmp ;

  {
  {
#line 569
  tmp = safe_read_nat0_32(sptr_ptr, eptr);
#line 569
  res = tmp;
  }
#line 570
  return (((intnat )res << 1) + 1L);
}
}
#line 572 "/home/june/repo/benchmarks/collector/temp/bin-prot-109.30.00/_build/lib/read_stubs.c"
value ml_read_int_32bit_stub(value v_buf , value v_pos_ref ) 
{ 
  struct caml__roots_block *caml__frame ;
  struct caml__roots_block caml__roots_v_buf ;
  int caml__dummy_v_buf  __attribute__((__unused__)) ;
  struct caml_ba_array *buf ;
  char *start ;
  long pos ;
  char *sptr ;
  char **sptr_ptr ;
  char *eptr ;
  value v_res ;
  long tmp ;
  value caml__temp_result ;

  {
  {
#line 572
  caml__frame = caml_local_roots;
#line 572
  caml__roots_v_buf.next = caml_local_roots;
#line 572
  caml_local_roots = & caml__roots_v_buf;
#line 572
  caml__roots_v_buf.nitems = (intnat )1;
#line 572
  caml__roots_v_buf.ntables = (intnat )2;
#line 572
  caml__roots_v_buf.tables[0] = & v_buf;
#line 572
  caml__roots_v_buf.tables[1] = & v_pos_ref;
#line 572
  caml__dummy_v_buf = 0;
#line 572
  buf = (struct caml_ba_array *)((void *)((value *)v_buf + 1));
#line 572
  start = (char *)buf->data;
#line 572
  pos = *((value *)v_pos_ref + 0) >> 1;
#line 572
  sptr = start + pos;
#line 572
  sptr_ptr = & sptr;
#line 572
  eptr = start + buf->dim[0];
#line 572
  tmp = __builtin_expect((long )(! (! (pos < 0L))), 0L);
  }
#line 572
  if (tmp) {
    {
#line 572
    caml_array_bound_error();
    }
  }
  {
#line 572
  v_res = read_int_32bit_stub(sptr_ptr, eptr);
#line 572
  *((value *)v_pos_ref + 0) = ((sptr - start) << 1) + 1L;
  }
  {
#line 572
  while (1) {
    while_continue: /* CIL Label */ ;
#line 572
    caml__temp_result = v_res;
#line 572
    caml_local_roots = caml__frame;
#line 572
    return (caml__temp_result);
#line 572
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 572
  return (0L);
}
}
#line 574 "/home/june/repo/benchmarks/collector/temp/bin-prot-109.30.00/_build/lib/read_stubs.c"
__inline value ( __attribute__((__always_inline__)) read_int_64bit_stub)(char **sptr_ptr ,
                                                                         char *eptr ) 
{ 
  long n ;
  char *sptr ;
  char *next ;
  long tmp ;
  uint64_t __n ;
  int tmp___0 ;
  long tmp___1 ;

  {
  {
#line 580
  sptr = *sptr_ptr;
#line 581
  next = sptr + 8;
#line 582
  tmp = __builtin_expect((long )(! (! ((unsigned long )next > (unsigned long )eptr))),
                         0L);
  }
#line 582
  if (tmp) {
    {
#line 582
    caml_raise_constant(*v_bin_prot_exc_Buffer_short);
    }
  }
  {
#line 584
  memcpy((void */* __restrict  */)(& __n), (void const   */* __restrict  */)sptr,
         (size_t )8);
#line 584
  n = (long )__n;
  }
#line 585
  if (n < -4611686018427387904L) {
#line 585
    tmp___0 = 1;
  } else
#line 585
  if (n > 4611686018427387903L) {
#line 585
    tmp___0 = 1;
  } else {
#line 585
    tmp___0 = 0;
  }
  {
#line 585
  tmp___1 = __builtin_expect((long )tmp___0, 0L);
  }
#line 585
  if (tmp___1) {
    {
#line 586
    raise_Error(2);
    }
  }
#line 597
  *sptr_ptr = next;
#line 598
  return ((n << 1) + 1L);
}
}
#line 600 "/home/june/repo/benchmarks/collector/temp/bin-prot-109.30.00/_build/lib/read_stubs.c"
value ml_read_int_64bit_stub(value v_buf , value v_pos_ref ) 
{ 
  struct caml__roots_block *caml__frame ;
  struct caml__roots_block caml__roots_v_buf ;
  int caml__dummy_v_buf  __attribute__((__unused__)) ;
  struct caml_ba_array *buf ;
  char *start ;
  long pos ;
  char *sptr ;
  char **sptr_ptr ;
  char *eptr ;
  value v_res ;
  long tmp ;
  value caml__temp_result ;

  {
  {
#line 600
  caml__frame = caml_local_roots;
#line 600
  caml__roots_v_buf.next = caml_local_roots;
#line 600
  caml_local_roots = & caml__roots_v_buf;
#line 600
  caml__roots_v_buf.nitems = (intnat )1;
#line 600
  caml__roots_v_buf.ntables = (intnat )2;
#line 600
  caml__roots_v_buf.tables[0] = & v_buf;
#line 600
  caml__roots_v_buf.tables[1] = & v_pos_ref;
#line 600
  caml__dummy_v_buf = 0;
#line 600
  buf = (struct caml_ba_array *)((void *)((value *)v_buf + 1));
#line 600
  start = (char *)buf->data;
#line 600
  pos = *((value *)v_pos_ref + 0) >> 1;
#line 600
  sptr = start + pos;
#line 600
  sptr_ptr = & sptr;
#line 600
  eptr = start + buf->dim[0];
#line 600
  tmp = __builtin_expect((long )(! (! (pos < 0L))), 0L);
  }
#line 600
  if (tmp) {
    {
#line 600
    caml_array_bound_error();
    }
  }
  {
#line 600
  v_res = read_int_64bit_stub(sptr_ptr, eptr);
#line 600
  *((value *)v_pos_ref + 0) = ((sptr - start) << 1) + 1L;
  }
  {
#line 600
  while (1) {
    while_continue: /* CIL Label */ ;
#line 600
    caml__temp_result = v_res;
#line 600
    caml_local_roots = caml__frame;
#line 600
    return (caml__temp_result);
#line 600
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 600
  return (0L);
}
}
#line 602 "/home/june/repo/benchmarks/collector/temp/bin-prot-109.30.00/_build/lib/read_stubs.c"
__inline value ( __attribute__((__always_inline__)) read_int64_bits_stub)(char **sptr_ptr ,
                                                                          char *eptr ) 
{ 
  int64 n ;
  value v_res ;
  char *sptr ;
  char *next ;
  long tmp ;
  uint64_t __n ;

  {
  {
#line 606
  sptr = *sptr_ptr;
#line 607
  next = sptr + 8;
#line 608
  tmp = __builtin_expect((long )(! (! ((unsigned long )next > (unsigned long )eptr))),
                         0L);
  }
#line 608
  if (tmp) {
    {
#line 608
    caml_raise_constant(*v_bin_prot_exc_Buffer_short);
    }
  }
  {
#line 610
  memcpy((void */* __restrict  */)(& __n), (void const   */* __restrict  */)sptr,
         (size_t )8);
#line 610
  n = (int64 )__n;
#line 614
  v_res = caml_copy_int64(n);
#line 615
  *sptr_ptr = next;
  }
#line 616
  return (v_res);
}
}
#line 618 "/home/june/repo/benchmarks/collector/temp/bin-prot-109.30.00/_build/lib/read_stubs.c"
value ml_read_int64_bits_stub(value v_buf , value v_pos_ref ) 
{ 
  struct caml__roots_block *caml__frame ;
  struct caml__roots_block caml__roots_v_buf ;
  int caml__dummy_v_buf  __attribute__((__unused__)) ;
  struct caml_ba_array *buf ;
  char *start ;
  long pos ;
  char *sptr ;
  char **sptr_ptr ;
  char *eptr ;
  value v_res ;
  long tmp ;
  value caml__temp_result ;

  {
  {
#line 618
  caml__frame = caml_local_roots;
#line 618
  caml__roots_v_buf.next = caml_local_roots;
#line 618
  caml_local_roots = & caml__roots_v_buf;
#line 618
  caml__roots_v_buf.nitems = (intnat )1;
#line 618
  caml__roots_v_buf.ntables = (intnat )2;
#line 618
  caml__roots_v_buf.tables[0] = & v_buf;
#line 618
  caml__roots_v_buf.tables[1] = & v_pos_ref;
#line 618
  caml__dummy_v_buf = 0;
#line 618
  buf = (struct caml_ba_array *)((void *)((value *)v_buf + 1));
#line 618
  start = (char *)buf->data;
#line 618
  pos = *((value *)v_pos_ref + 0) >> 1;
#line 618
  sptr = start + pos;
#line 618
  sptr_ptr = & sptr;
#line 618
  eptr = start + buf->dim[0];
#line 618
  tmp = __builtin_expect((long )(! (! (pos < 0L))), 0L);
  }
#line 618
  if (tmp) {
    {
#line 618
    caml_array_bound_error();
    }
  }
  {
#line 618
  v_res = read_int64_bits_stub(sptr_ptr, eptr);
#line 618
  *((value *)v_pos_ref + 0) = ((sptr - start) << 1) + 1L;
  }
  {
#line 618
  while (1) {
    while_continue: /* CIL Label */ ;
#line 618
    caml__temp_result = v_res;
#line 618
    caml_local_roots = caml__frame;
#line 618
    return (caml__temp_result);
#line 618
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 618
  return (0L);
}
}
#line 620 "/home/june/repo/benchmarks/collector/temp/bin-prot-109.30.00/_build/lib/read_stubs.c"
__inline value ( __attribute__((__always_inline__)) read_network16_int_stub)(char **sptr_ptr ,
                                                                             char *eptr ) 
{ 
  char *sptr ;
  char *next ;
  long tmp ;
  uint16_t __n ;
  unsigned short __v ;
  unsigned short __x ;

  {
  {
#line 622
  sptr = *sptr_ptr;
#line 623
  next = sptr + 2;
#line 624
  tmp = __builtin_expect((long )(! (! ((unsigned long )next > (unsigned long )eptr))),
                         0L);
  }
#line 624
  if (tmp) {
    {
#line 624
    caml_raise_constant(*v_bin_prot_exc_Buffer_short);
    }
  }
  {
#line 625
  *sptr_ptr = next;
#line 626
  memcpy((void */* __restrict  */)(& __n), (void const   */* __restrict  */)sptr,
         (size_t )2);
#line 626
  __x = __n;
#line 626
  __asm__  ("rorw $8, %w0": "=r" (__v): "0" (__x): "cc");
  }
#line 626
  return (((intnat )__v << 1) + 1L);
}
}
#line 628 "/home/june/repo/benchmarks/collector/temp/bin-prot-109.30.00/_build/lib/read_stubs.c"
value ml_read_network16_int_stub(value v_buf , value v_pos_ref ) 
{ 
  struct caml__roots_block *caml__frame ;
  struct caml__roots_block caml__roots_v_buf ;
  int caml__dummy_v_buf  __attribute__((__unused__)) ;
  struct caml_ba_array *buf ;
  char *start ;
  long pos ;
  char *sptr ;
  char **sptr_ptr ;
  char *eptr ;
  value v_res ;
  long tmp ;
  value caml__temp_result ;

  {
  {
#line 628
  caml__frame = caml_local_roots;
#line 628
  caml__roots_v_buf.next = caml_local_roots;
#line 628
  caml_local_roots = & caml__roots_v_buf;
#line 628
  caml__roots_v_buf.nitems = (intnat )1;
#line 628
  caml__roots_v_buf.ntables = (intnat )2;
#line 628
  caml__roots_v_buf.tables[0] = & v_buf;
#line 628
  caml__roots_v_buf.tables[1] = & v_pos_ref;
#line 628
  caml__dummy_v_buf = 0;
#line 628
  buf = (struct caml_ba_array *)((void *)((value *)v_buf + 1));
#line 628
  start = (char *)buf->data;
#line 628
  pos = *((value *)v_pos_ref + 0) >> 1;
#line 628
  sptr = start + pos;
#line 628
  sptr_ptr = & sptr;
#line 628
  eptr = start + buf->dim[0];
#line 628
  tmp = __builtin_expect((long )(! (! (pos < 0L))), 0L);
  }
#line 628
  if (tmp) {
    {
#line 628
    caml_array_bound_error();
    }
  }
  {
#line 628
  v_res = read_network16_int_stub(sptr_ptr, eptr);
#line 628
  *((value *)v_pos_ref + 0) = ((sptr - start) << 1) + 1L;
  }
  {
#line 628
  while (1) {
    while_continue: /* CIL Label */ ;
#line 628
    caml__temp_result = v_res;
#line 628
    caml_local_roots = caml__frame;
#line 628
    return (caml__temp_result);
#line 628
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 628
  return (0L);
}
}
#line 630 "/home/june/repo/benchmarks/collector/temp/bin-prot-109.30.00/_build/lib/read_stubs.c"
__inline value ( __attribute__((__always_inline__)) read_network32_int_stub)(char **sptr_ptr ,
                                                                             char *eptr ) 
{ 
  char *sptr ;
  char *next ;
  int n ;
  long tmp ;
  uint32_t __n ;
  unsigned int tmp___0 ;

  {
  {
#line 632
  sptr = *sptr_ptr;
#line 633
  next = sptr + 4;
#line 635
  tmp = __builtin_expect((long )(! (! ((unsigned long )next > (unsigned long )eptr))),
                         0L);
  }
#line 635
  if (tmp) {
    {
#line 635
    caml_raise_constant(*v_bin_prot_exc_Buffer_short);
    }
  }
  {
#line 636
  memcpy((void */* __restrict  */)(& __n), (void const   */* __restrict  */)sptr,
         (size_t )4);
#line 636
  tmp___0 = __bswap_32(__n);
#line 636
  n = (int )tmp___0;
#line 638
  *sptr_ptr = next;
  }
#line 639
  return (((intnat )((uint32_t )n) << 1) + 1L);
}
}
#line 647 "/home/june/repo/benchmarks/collector/temp/bin-prot-109.30.00/_build/lib/read_stubs.c"
value ml_read_network32_int_stub(value v_buf , value v_pos_ref ) 
{ 
  struct caml__roots_block *caml__frame ;
  struct caml__roots_block caml__roots_v_buf ;
  int caml__dummy_v_buf  __attribute__((__unused__)) ;
  struct caml_ba_array *buf ;
  char *start ;
  long pos ;
  char *sptr ;
  char **sptr_ptr ;
  char *eptr ;
  value v_res ;
  long tmp ;
  value caml__temp_result ;

  {
  {
#line 647
  caml__frame = caml_local_roots;
#line 647
  caml__roots_v_buf.next = caml_local_roots;
#line 647
  caml_local_roots = & caml__roots_v_buf;
#line 647
  caml__roots_v_buf.nitems = (intnat )1;
#line 647
  caml__roots_v_buf.ntables = (intnat )2;
#line 647
  caml__roots_v_buf.tables[0] = & v_buf;
#line 647
  caml__roots_v_buf.tables[1] = & v_pos_ref;
#line 647
  caml__dummy_v_buf = 0;
#line 647
  buf = (struct caml_ba_array *)((void *)((value *)v_buf + 1));
#line 647
  start = (char *)buf->data;
#line 647
  pos = *((value *)v_pos_ref + 0) >> 1;
#line 647
  sptr = start + pos;
#line 647
  sptr_ptr = & sptr;
#line 647
  eptr = start + buf->dim[0];
#line 647
  tmp = __builtin_expect((long )(! (! (pos < 0L))), 0L);
  }
#line 647
  if (tmp) {
    {
#line 647
    caml_array_bound_error();
    }
  }
  {
#line 647
  v_res = read_network32_int_stub(sptr_ptr, eptr);
#line 647
  *((value *)v_pos_ref + 0) = ((sptr - start) << 1) + 1L;
  }
  {
#line 647
  while (1) {
    while_continue: /* CIL Label */ ;
#line 647
    caml__temp_result = v_res;
#line 647
    caml_local_roots = caml__frame;
#line 647
    return (caml__temp_result);
#line 647
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 647
  return (0L);
}
}
#line 649 "/home/june/repo/benchmarks/collector/temp/bin-prot-109.30.00/_build/lib/read_stubs.c"
__inline value ( __attribute__((__always_inline__)) read_network32_int32_stub)(char **sptr_ptr ,
                                                                               char *eptr ) 
{ 
  char *sptr ;
  char *next ;
  long tmp ;
  uint32_t __n ;
  unsigned int tmp___0 ;
  value tmp___1 ;

  {
  {
#line 651
  sptr = *sptr_ptr;
#line 652
  next = sptr + 4;
#line 653
  tmp = __builtin_expect((long )(! (! ((unsigned long )next > (unsigned long )eptr))),
                         0L);
  }
#line 653
  if (tmp) {
    {
#line 653
    caml_raise_constant(*v_bin_prot_exc_Buffer_short);
    }
  }
  {
#line 654
  *sptr_ptr = next;
#line 655
  memcpy((void */* __restrict  */)(& __n), (void const   */* __restrict  */)sptr,
         (size_t )4);
#line 655
  tmp___0 = __bswap_32(__n);
#line 655
  tmp___1 = caml_copy_int32((int32 )tmp___0);
  }
#line 655
  return (tmp___1);
}
}
#line 657 "/home/june/repo/benchmarks/collector/temp/bin-prot-109.30.00/_build/lib/read_stubs.c"
value ml_read_network32_int32_stub(value v_buf , value v_pos_ref ) 
{ 
  struct caml__roots_block *caml__frame ;
  struct caml__roots_block caml__roots_v_buf ;
  int caml__dummy_v_buf  __attribute__((__unused__)) ;
  struct caml_ba_array *buf ;
  char *start ;
  long pos ;
  char *sptr ;
  char **sptr_ptr ;
  char *eptr ;
  value v_res ;
  long tmp ;
  value caml__temp_result ;

  {
  {
#line 657
  caml__frame = caml_local_roots;
#line 657
  caml__roots_v_buf.next = caml_local_roots;
#line 657
  caml_local_roots = & caml__roots_v_buf;
#line 657
  caml__roots_v_buf.nitems = (intnat )1;
#line 657
  caml__roots_v_buf.ntables = (intnat )2;
#line 657
  caml__roots_v_buf.tables[0] = & v_buf;
#line 657
  caml__roots_v_buf.tables[1] = & v_pos_ref;
#line 657
  caml__dummy_v_buf = 0;
#line 657
  buf = (struct caml_ba_array *)((void *)((value *)v_buf + 1));
#line 657
  start = (char *)buf->data;
#line 657
  pos = *((value *)v_pos_ref + 0) >> 1;
#line 657
  sptr = start + pos;
#line 657
  sptr_ptr = & sptr;
#line 657
  eptr = start + buf->dim[0];
#line 657
  tmp = __builtin_expect((long )(! (! (pos < 0L))), 0L);
  }
#line 657
  if (tmp) {
    {
#line 657
    caml_array_bound_error();
    }
  }
  {
#line 657
  v_res = read_network32_int32_stub(sptr_ptr, eptr);
#line 657
  *((value *)v_pos_ref + 0) = ((sptr - start) << 1) + 1L;
  }
  {
#line 657
  while (1) {
    while_continue: /* CIL Label */ ;
#line 657
    caml__temp_result = v_res;
#line 657
    caml_local_roots = caml__frame;
#line 657
    return (caml__temp_result);
#line 657
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 657
  return (0L);
}
}
#line 659 "/home/june/repo/benchmarks/collector/temp/bin-prot-109.30.00/_build/lib/read_stubs.c"
__inline value ( __attribute__((__always_inline__)) read_network64_int_stub)(char **sptr_ptr ,
                                                                             char *eptr ) 
{ 
  char *sptr ;
  char *next ;
  long n ;
  long tmp ;
  uint64_t __n ;
  __uint64_t tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;

  {
  {
#line 661
  sptr = *sptr_ptr;
#line 662
  next = sptr + 8;
#line 664
  tmp = __builtin_expect((long )(! (! ((unsigned long )next > (unsigned long )eptr))),
                         0L);
  }
#line 664
  if (tmp) {
    {
#line 664
    caml_raise_constant(*v_bin_prot_exc_Buffer_short);
    }
  }
  {
#line 666
  memcpy((void */* __restrict  */)(& __n), (void const   */* __restrict  */)sptr,
         (size_t )8);
#line 666
  tmp___0 = __bswap_64(__n);
#line 666
  n = (long )tmp___0;
  }
#line 667
  if (n < -4611686018427387904L) {
#line 667
    tmp___1 = 1;
  } else
#line 667
  if (n > 4611686018427387903L) {
#line 667
    tmp___1 = 1;
  } else {
#line 667
    tmp___1 = 0;
  }
  {
#line 667
  tmp___2 = __builtin_expect((long )tmp___1, 0L);
  }
#line 667
  if (tmp___2) {
    {
#line 668
    raise_Error(2);
    }
  }
#line 679
  *sptr_ptr = next;
#line 680
  return ((n << 1) + 1L);
}
}
#line 682 "/home/june/repo/benchmarks/collector/temp/bin-prot-109.30.00/_build/lib/read_stubs.c"
value ml_read_network64_int_stub(value v_buf , value v_pos_ref ) 
{ 
  struct caml__roots_block *caml__frame ;
  struct caml__roots_block caml__roots_v_buf ;
  int caml__dummy_v_buf  __attribute__((__unused__)) ;
  struct caml_ba_array *buf ;
  char *start ;
  long pos ;
  char *sptr ;
  char **sptr_ptr ;
  char *eptr ;
  value v_res ;
  long tmp ;
  value caml__temp_result ;

  {
  {
#line 682
  caml__frame = caml_local_roots;
#line 682
  caml__roots_v_buf.next = caml_local_roots;
#line 682
  caml_local_roots = & caml__roots_v_buf;
#line 682
  caml__roots_v_buf.nitems = (intnat )1;
#line 682
  caml__roots_v_buf.ntables = (intnat )2;
#line 682
  caml__roots_v_buf.tables[0] = & v_buf;
#line 682
  caml__roots_v_buf.tables[1] = & v_pos_ref;
#line 682
  caml__dummy_v_buf = 0;
#line 682
  buf = (struct caml_ba_array *)((void *)((value *)v_buf + 1));
#line 682
  start = (char *)buf->data;
#line 682
  pos = *((value *)v_pos_ref + 0) >> 1;
#line 682
  sptr = start + pos;
#line 682
  sptr_ptr = & sptr;
#line 682
  eptr = start + buf->dim[0];
#line 682
  tmp = __builtin_expect((long )(! (! (pos < 0L))), 0L);
  }
#line 682
  if (tmp) {
    {
#line 682
    caml_array_bound_error();
    }
  }
  {
#line 682
  v_res = read_network64_int_stub(sptr_ptr, eptr);
#line 682
  *((value *)v_pos_ref + 0) = ((sptr - start) << 1) + 1L;
  }
  {
#line 682
  while (1) {
    while_continue: /* CIL Label */ ;
#line 682
    caml__temp_result = v_res;
#line 682
    caml_local_roots = caml__frame;
#line 682
    return (caml__temp_result);
#line 682
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 682
  return (0L);
}
}
#line 684 "/home/june/repo/benchmarks/collector/temp/bin-prot-109.30.00/_build/lib/read_stubs.c"
__inline value ( __attribute__((__always_inline__)) read_network64_int64_stub)(char **sptr_ptr ,
                                                                               char *eptr ) 
{ 
  char *sptr ;
  char *next ;
  int64 n ;
  long tmp ;
  uint64_t __n ;
  __uint64_t tmp___0 ;
  value tmp___1 ;

  {
  {
#line 686
  sptr = *sptr_ptr;
#line 687
  next = sptr + 8;
#line 689
  tmp = __builtin_expect((long )(! (! ((unsigned long )next > (unsigned long )eptr))),
                         0L);
  }
#line 689
  if (tmp) {
    {
#line 689
    caml_raise_constant(*v_bin_prot_exc_Buffer_short);
    }
  }
  {
#line 690
  *sptr_ptr = next;
#line 692
  memcpy((void */* __restrict  */)(& __n), (void const   */* __restrict  */)sptr,
         (size_t )8);
#line 692
  tmp___0 = __bswap_64(__n);
#line 692
  n = (int64 )((long )tmp___0);
#line 696
  tmp___1 = caml_copy_int64(n);
  }
#line 696
  return (tmp___1);
}
}
#line 698 "/home/june/repo/benchmarks/collector/temp/bin-prot-109.30.00/_build/lib/read_stubs.c"
value ml_read_network64_int64_stub(value v_buf , value v_pos_ref ) 
{ 
  struct caml__roots_block *caml__frame ;
  struct caml__roots_block caml__roots_v_buf ;
  int caml__dummy_v_buf  __attribute__((__unused__)) ;
  struct caml_ba_array *buf ;
  char *start ;
  long pos ;
  char *sptr ;
  char **sptr_ptr ;
  char *eptr ;
  value v_res ;
  long tmp ;
  value caml__temp_result ;

  {
  {
#line 698
  caml__frame = caml_local_roots;
#line 698
  caml__roots_v_buf.next = caml_local_roots;
#line 698
  caml_local_roots = & caml__roots_v_buf;
#line 698
  caml__roots_v_buf.nitems = (intnat )1;
#line 698
  caml__roots_v_buf.ntables = (intnat )2;
#line 698
  caml__roots_v_buf.tables[0] = & v_buf;
#line 698
  caml__roots_v_buf.tables[1] = & v_pos_ref;
#line 698
  caml__dummy_v_buf = 0;
#line 698
  buf = (struct caml_ba_array *)((void *)((value *)v_buf + 1));
#line 698
  start = (char *)buf->data;
#line 698
  pos = *((value *)v_pos_ref + 0) >> 1;
#line 698
  sptr = start + pos;
#line 698
  sptr_ptr = & sptr;
#line 698
  eptr = start + buf->dim[0];
#line 698
  tmp = __builtin_expect((long )(! (! (pos < 0L))), 0L);
  }
#line 698
  if (tmp) {
    {
#line 698
    caml_array_bound_error();
    }
  }
  {
#line 698
  v_res = read_network64_int64_stub(sptr_ptr, eptr);
#line 698
  *((value *)v_pos_ref + 0) = ((sptr - start) << 1) + 1L;
  }
  {
#line 698
  while (1) {
    while_continue: /* CIL Label */ ;
#line 698
    caml__temp_result = v_res;
#line 698
    caml_local_roots = caml__frame;
#line 698
    return (caml__temp_result);
#line 698
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 698
  return (0L);
}
}
#line 50 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memmove)(void *__dest ,
                                                                                                  void const   *__src ,
                                                                                                  size_t __n ) ;
#line 483 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 38 "/usr/lib/ocaml/caml/memory.h"
extern void *caml_stat_alloc(asize_t  ) ;
#line 161 "/home/june/repo/benchmarks/collector/temp/bin-prot-109.30.00/_build/lib/common_stubs.h"
value *v_bin_prot_exc_Buffer_short  ;
#line 7 "/home/june/repo/benchmarks/collector/temp/bin-prot-109.30.00/_build/lib/common_stubs.c"
value bin_prot_common_init_stub(value v_unit  __attribute__((__unused__)) ) 
{ 


  {
  {
#line 9
  v_bin_prot_exc_Buffer_short = caml_named_value("Bin_prot.Common.Buffer_short");
  }
#line 11
  return (1L);
}
}
#line 17 "/home/june/repo/benchmarks/collector/temp/bin-prot-109.30.00/_build/lib/common_stubs.c"
__inline value __attribute__((__pure__))  ( __attribute__((__always_inline__)) get_buf_ptr_stub)(value v_buf ,
                                                                                                 value v_pos ) 
{ 
  char *sptr ;
  char *eptr ;

  {
#line 19
  sptr = (char *)((struct caml_ba_array *)((void *)((value *)v_buf + 1)))->data;
#line 20
  eptr = sptr + (v_pos >> 1);
#line 21
  return ((value __attribute__((__pure__))  )((value )eptr));
}
}
#line 24
__inline value ( __attribute__((__always_inline__)) get_buf_pos_stub)(value v_start ,
                                                                      value v_cur )  __attribute__((__const__)) ;
#line 24 "/home/june/repo/benchmarks/collector/temp/bin-prot-109.30.00/_build/lib/common_stubs.c"
__inline value ( __attribute__((__always_inline__)) get_buf_pos_stub)(value v_start ,
                                                                      value v_cur ) 
{ 


  {
#line 27
  return ((((char *)v_cur - (char *)v_start) << 1) + 1L);
}
}
#line 30 "/home/june/repo/benchmarks/collector/temp/bin-prot-109.30.00/_build/lib/common_stubs.c"
value get_safe_buf_pos_stub(value v_buf  __attribute__((__unused__)) , value v_start ,
                            value v_cur ) 
{ 
  value tmp ;

  {
  {
#line 33
  tmp = get_buf_pos_stub(v_start, v_cur);
  }
#line 33
  return (tmp);
}
}
#line 36 "/home/june/repo/benchmarks/collector/temp/bin-prot-109.30.00/_build/lib/common_stubs.c"
value shift_sptr_stub(char *sptr , value v_n ) 
{ 


  {
#line 38
  return ((value )(sptr + (v_n >> 1)));
}
}
#line 41 "/home/june/repo/benchmarks/collector/temp/bin-prot-109.30.00/_build/lib/common_stubs.c"
value get_eptr_from_sptr_ptr(char **sptr_ptr , value v_pos ) 
{ 


  {
#line 43
  return ((value )(*sptr_ptr + (v_pos >> 1)));
}
}
#line 46 "/home/june/repo/benchmarks/collector/temp/bin-prot-109.30.00/_build/lib/common_stubs.c"
char __attribute__((__malloc__))  **alloc_sptr_ptr_stub(value v_buf , value v_pos ) 
{ 
  char **sptr_ptr ;
  void *tmp ;
  value __attribute__((__pure__))  tmp___0 ;

  {
  {
#line 48
  tmp = caml_stat_alloc(sizeof(char *));
#line 48
  sptr_ptr = (char **)tmp;
#line 49
  tmp___0 = get_buf_ptr_stub(v_buf, v_pos);
#line 49
  *sptr_ptr = (char *)tmp___0;
  }
#line 50
  return ((char __attribute__((__malloc__))  **)sptr_ptr);
}
}
#line 53 "/home/june/repo/benchmarks/collector/temp/bin-prot-109.30.00/_build/lib/common_stubs.c"
value dealloc_sptr_ptr_stub(value v_buf , char **sptr_ptr ) 
{ 
  unsigned long pos ;

  {
  {
#line 55
  pos = (unsigned long )(*sptr_ptr - (char *)((struct caml_ba_array *)((void *)((value *)v_buf + 1)))->data);
#line 56
  free((void *)sptr_ptr);
  }
#line 57
  return (((intnat )pos << 1) + 1L);
}
}
#line 60 "/home/june/repo/benchmarks/collector/temp/bin-prot-109.30.00/_build/lib/common_stubs.c"
value set_sptr_ptr_stub(char **sptr_ptr , value v_buf , value v_pos ) 
{ 


  {
#line 62
  *sptr_ptr = (char *)((struct caml_ba_array *)((void *)((value *)v_buf + 1)))->data + (v_pos >> 1);
#line 63
  return (1L);
}
}
#line 66 "/home/june/repo/benchmarks/collector/temp/bin-prot-109.30.00/_build/lib/common_stubs.c"
value __attribute__((__pure__))  get_sptr_ptr_stub(char **sptr_ptr , value v_buf ) 
{ 


  {
#line 68
  return ((value __attribute__((__pure__))  )(((*sptr_ptr - (char *)((struct caml_ba_array *)((void *)((value *)v_buf + 1)))->data) << 1) + 1L));
}
}
#line 71 "/home/june/repo/benchmarks/collector/temp/bin-prot-109.30.00/_build/lib/common_stubs.c"
value __attribute__((__pure__))  get_sptr_ptr_sptr_stub(char **sptr_ptr ) 
{ 


  {
#line 73
  return ((value __attribute__((__pure__))  )((value )*sptr_ptr));
}
}
#line 76 "/home/june/repo/benchmarks/collector/temp/bin-prot-109.30.00/_build/lib/common_stubs.c"
value set_sptr_ptr_sptr_stub(char **sptr_ptr , char *sptr ) 
{ 


  {
#line 78
  *sptr_ptr = sptr;
#line 79
  return (1L);
}
}
#line 82 "/home/june/repo/benchmarks/collector/temp/bin-prot-109.30.00/_build/lib/common_stubs.c"
value get_ptr_string_stub(char *sptr , char *eptr ) 
{ 
  unsigned long len ;
  value v_str ;
  value tmp ;

  {
  {
#line 84
  len = (unsigned long )(eptr - sptr);
#line 85
  tmp = caml_alloc_string(len);
#line 85
  v_str = tmp;
#line 86
  memcpy((void */* __restrict  */)((char *)v_str), (void const   */* __restrict  */)sptr,
         len);
  }
#line 87
  return (v_str);
}
}
#line 93 "/home/june/repo/benchmarks/collector/temp/bin-prot-109.30.00/_build/lib/common_stubs.c"
__inline static char __attribute__((__pure__))  *( __attribute__((__always_inline__)) get_buf)(value v_buf ,
                                                                                               value v_pos ) 
{ 


  {
#line 95
  return ((char __attribute__((__pure__))  *)((char *)((struct caml_ba_array *)((void *)((value *)v_buf + 1)))->data + (v_pos >> 1)));
}
}
#line 98 "/home/june/repo/benchmarks/collector/temp/bin-prot-109.30.00/_build/lib/common_stubs.c"
value bin_prot_blit_string_buf_stub(value v_src_pos , value v_str , value v_dst_pos ,
                                    value v_buf , value v_len ) 
{ 
  char *str ;
  char *buf ;
  char __attribute__((__pure__))  *tmp ;

  {
  {
#line 101
  str = (char *)v_str + (v_src_pos >> 1);
#line 102
  tmp = get_buf(v_buf, v_dst_pos);
#line 102
  buf = (char *)tmp;
#line 103
  memcpy((void */* __restrict  */)buf, (void const   */* __restrict  */)str, (size_t )(v_len >> 1));
  }
#line 104
  return (1L);
}
}
#line 107 "/home/june/repo/benchmarks/collector/temp/bin-prot-109.30.00/_build/lib/common_stubs.c"
value bin_prot_blit_buf_string_stub(value v_src_pos , value v_buf , value v_dst_pos ,
                                    value v_str , value v_len ) 
{ 
  char *buf ;
  char __attribute__((__pure__))  *tmp ;
  char *str ;

  {
  {
#line 110
  tmp = get_buf(v_buf, v_src_pos);
#line 110
  buf = (char *)tmp;
#line 111
  str = (char *)v_str + (v_dst_pos >> 1);
#line 112
  memcpy((void */* __restrict  */)str, (void const   */* __restrict  */)buf, (size_t )(v_len >> 1));
  }
#line 113
  return (1L);
}
}
#line 116 "/home/june/repo/benchmarks/collector/temp/bin-prot-109.30.00/_build/lib/common_stubs.c"
value bin_prot_blit_buf_stub(value v_src_pos , value v_src , value v_dst_pos , value v_dst ,
                             value v_len ) 
{ 
  struct caml_ba_array *ba_src ;
  struct caml_ba_array *ba_dst ;
  char *src ;
  char *dst ;
  size_t len ;
  struct caml__roots_block caml__roots_block ;
  long tmp ;
  long tmp___0 ;
  long tmp___1 ;

  {
  {
#line 119
  ba_src = (struct caml_ba_array *)((void *)((value *)v_src + 1));
#line 120
  ba_dst = (struct caml_ba_array *)((void *)((value *)v_dst + 1));
#line 121
  src = (char *)ba_src->data + (v_src_pos >> 1);
#line 122
  dst = (char *)ba_dst->data + (v_dst_pos >> 1);
#line 123
  len = (size_t )(v_len >> 1);
#line 124
  tmp = __builtin_expect((long )(! (! (len > 65536UL))), 0L);
  }
#line 124
  if (tmp) {
#line 124
    goto _L;
  } else {
    {
#line 124
    tmp___0 = __builtin_expect((long )(! (! ((ba_src->flags & 1024L) != 0L))), 0L);
    }
#line 124
    if (tmp___0) {
#line 124
      goto _L;
    } else {
      {
#line 124
      tmp___1 = __builtin_expect((long )(! (! ((ba_dst->flags & 1024L) != 0L))), 0L);
      }
#line 124
      if (tmp___1) {
        _L: /* CIL Label */ 
        {
#line 132
        caml__roots_block.next = caml_local_roots;
#line 132
        caml_local_roots = & caml__roots_block;
#line 132
        caml__roots_block.nitems = (intnat )1;
#line 132
        caml__roots_block.ntables = (intnat )2;
#line 132
        caml__roots_block.tables[0] = & v_src;
#line 132
        caml__roots_block.tables[1] = & v_dst;
#line 133
        caml_enter_blocking_section();
#line 134
        memmove((void *)dst, (void const   *)src, len);
#line 135
        caml_leave_blocking_section();
#line 136
        caml_local_roots = caml__roots_block.next;
        }
      } else {
        {
#line 138
        memmove((void *)dst, (void const   *)src, len);
        }
      }
    }
  }
#line 139
  return (1L);
}
}
#line 227 "/usr/lib/ocaml/caml/mlvalues.h"
extern mlsize_t caml_string_length(value  ) ;
#line 23 "/home/june/repo/benchmarks/collector/temp/bin-prot-109.30.00/_build/lib/write_stubs.c"
__inline static void ( __attribute__((__always_inline__)) do_write_small_int)(char *sptr ,
                                                                              char n ) 
{ 


  {
#line 25
  *sptr = n;
#line 26
  return;
}
}
#line 28 "/home/june/repo/benchmarks/collector/temp/bin-prot-109.30.00/_build/lib/write_stubs.c"
__inline static value ( __attribute__((__always_inline__)) write_small_int)(char *sptr ,
                                                                            char *eptr ,
                                                                            char n ) 
{ 
  long tmp ;

  {
  {
#line 30
  tmp = __builtin_expect((long )(! (! ((unsigned long )sptr >= (unsigned long )eptr))),
                         0L);
  }
#line 30
  if (tmp) {
    {
#line 30
    caml_raise_constant(*v_bin_prot_exc_Buffer_short);
    }
  }
  {
#line 31
  do_write_small_int(sptr, n);
  }
#line 32
  return ((value )(sptr + 1));
}
}
#line 35 "/home/june/repo/benchmarks/collector/temp/bin-prot-109.30.00/_build/lib/write_stubs.c"
__inline static void ( __attribute__((__always_inline__)) do_write_neg_int8)(char *sptr ,
                                                                             char n ) 
{ 
  char *tmp ;

  {
#line 37
  tmp = sptr;
#line 37
  sptr ++;
#line 37
  *tmp = (char)-1;
#line 38
  *sptr = n;
#line 39
  return;
}
}
#line 41 "/home/june/repo/benchmarks/collector/temp/bin-prot-109.30.00/_build/lib/write_stubs.c"
__inline static value ( __attribute__((__always_inline__)) write_neg_int8)(char *sptr ,
                                                                           char *eptr ,
                                                                           char n ) 
{ 
  char *next ;
  long tmp ;

  {
  {
#line 43
  next = sptr + 2;
#line 44
  tmp = __builtin_expect((long )(! (! ((unsigned long )next > (unsigned long )eptr))),
                         0L);
  }
#line 44
  if (tmp) {
    {
#line 44
    caml_raise_constant(*v_bin_prot_exc_Buffer_short);
    }
  }
  {
#line 45
  do_write_neg_int8(sptr, n);
  }
#line 46
  return ((value )next);
}
}
#line 49 "/home/june/repo/benchmarks/collector/temp/bin-prot-109.30.00/_build/lib/write_stubs.c"
__inline static void ( __attribute__((__always_inline__)) do_write_int16)(char *sptr ,
                                                                          short n ) 
{ 
  char *tmp ;
  uint16_t __n ;

  {
  {
#line 51
  tmp = sptr;
#line 51
  sptr ++;
#line 51
  *tmp = (char)-2;
#line 52
  __n = (uint16_t )n;
#line 52
  memcpy((void */* __restrict  */)sptr, (void const   */* __restrict  */)(& __n),
         (size_t )2);
  }
#line 53
  return;
}
}
#line 55 "/home/june/repo/benchmarks/collector/temp/bin-prot-109.30.00/_build/lib/write_stubs.c"
__inline static value ( __attribute__((__always_inline__)) write_int16)(char *sptr ,
                                                                        char *eptr ,
                                                                        short n ) 
{ 
  char *next ;
  long tmp ;

  {
  {
#line 57
  next = sptr + 3;
#line 58
  tmp = __builtin_expect((long )(! (! ((unsigned long )next > (unsigned long )eptr))),
                         0L);
  }
#line 58
  if (tmp) {
    {
#line 58
    caml_raise_constant(*v_bin_prot_exc_Buffer_short);
    }
  }
  {
#line 59
  do_write_int16(sptr, n);
  }
#line 60
  return ((value )next);
}
}
#line 63 "/home/june/repo/benchmarks/collector/temp/bin-prot-109.30.00/_build/lib/write_stubs.c"
__inline static void ( __attribute__((__always_inline__)) do_write_int32)(char *sptr ,
                                                                          int n ) 
{ 
  char *tmp ;
  uint32_t __n ;

  {
  {
#line 65
  tmp = sptr;
#line 65
  sptr ++;
#line 65
  *tmp = (char)-3;
#line 66
  __n = (uint32_t )n;
#line 66
  memcpy((void */* __restrict  */)sptr, (void const   */* __restrict  */)(& __n),
         (size_t )4);
  }
#line 67
  return;
}
}
#line 69 "/home/june/repo/benchmarks/collector/temp/bin-prot-109.30.00/_build/lib/write_stubs.c"
__inline static value ( __attribute__((__always_inline__)) write_int32)(char *sptr ,
                                                                        char *eptr ,
                                                                        int n ) 
{ 
  char *next ;
  long tmp ;

  {
  {
#line 71
  next = sptr + 5;
#line 72
  tmp = __builtin_expect((long )(! (! ((unsigned long )next > (unsigned long )eptr))),
                         0L);
  }
#line 72
  if (tmp) {
    {
#line 72
    caml_raise_constant(*v_bin_prot_exc_Buffer_short);
    }
  }
  {
#line 73
  do_write_int32(sptr, n);
  }
#line 74
  return ((value )next);
}
}
#line 78 "/home/june/repo/benchmarks/collector/temp/bin-prot-109.30.00/_build/lib/write_stubs.c"
__inline static void ( __attribute__((__always_inline__)) do_write_int64)(char *sptr ,
                                                                          long n ) 
{ 
  char *tmp ;
  uint64_t __n ;

  {
  {
#line 80
  tmp = sptr;
#line 80
  sptr ++;
#line 80
  *tmp = (char)-4;
#line 81
  __n = (uint64_t )n;
#line 81
  memcpy((void */* __restrict  */)sptr, (void const   */* __restrict  */)(& __n),
         (size_t )8);
  }
#line 82
  return;
}
}
#line 84 "/home/june/repo/benchmarks/collector/temp/bin-prot-109.30.00/_build/lib/write_stubs.c"
__inline static value ( __attribute__((__always_inline__)) write_int64)(char *sptr ,
                                                                        char *eptr ,
                                                                        long n ) 
{ 
  char *next ;
  long tmp ;

  {
  {
#line 86
  next = sptr + 9;
#line 87
  tmp = __builtin_expect((long )(! (! ((unsigned long )next > (unsigned long )eptr))),
                         0L);
  }
#line 87
  if (tmp) {
    {
#line 87
    caml_raise_constant(*v_bin_prot_exc_Buffer_short);
    }
  }
  {
#line 88
  do_write_int64(sptr, n);
  }
#line 89
  return ((value )next);
}
}
#line 93 "/home/june/repo/benchmarks/collector/temp/bin-prot-109.30.00/_build/lib/write_stubs.c"
__inline static value ( __attribute__((__always_inline__)) write_int_nat0)(char *sptr ,
                                                                           char *eptr ,
                                                                           unsigned long n ) 
{ 
  value tmp ;
  long tmp___0 ;
  value tmp___1 ;
  long tmp___2 ;
  value tmp___3 ;
  long tmp___4 ;
  value tmp___5 ;

  {
  {
#line 95
  tmp___0 = __builtin_expect((long )(! (! (n < 128UL))), 1L);
  }
#line 95
  if (tmp___0) {
    {
#line 95
    tmp = write_small_int(sptr, eptr, (char )n);
    }
#line 95
    return (tmp);
  }
  {
#line 96
  tmp___2 = __builtin_expect((long )(! (! (n < 32768UL))), 1L);
  }
#line 96
  if (tmp___2) {
    {
#line 96
    tmp___1 = write_int16(sptr, eptr, (short )n);
    }
#line 96
    return (tmp___1);
  }
  {
#line 98
  tmp___4 = __builtin_expect((long )(! (! (n >= 2147483648UL))), 0L);
  }
#line 98
  if (tmp___4) {
    {
#line 98
    tmp___3 = write_int64(sptr, eptr, (long )n);
    }
#line 98
    return (tmp___3);
  }
  {
#line 100
  tmp___5 = write_int32(sptr, eptr, (int )n);
  }
#line 100
  return (tmp___5);
}
}
#line 103 "/home/june/repo/benchmarks/collector/temp/bin-prot-109.30.00/_build/lib/write_stubs.c"
__inline static value ( __attribute__((__always_inline__)) write_int_negative)(char *sptr ,
                                                                               char *eptr ,
                                                                               long n ) 
{ 
  value tmp ;
  long tmp___0 ;
  value tmp___1 ;
  long tmp___2 ;
  value tmp___3 ;
  long tmp___4 ;
  value tmp___5 ;

  {
  {
#line 105
  tmp___0 = __builtin_expect((long )(! (! (n >= -128L))), 1L);
  }
#line 105
  if (tmp___0) {
    {
#line 105
    tmp = write_neg_int8(sptr, eptr, (char )n);
    }
#line 105
    return (tmp);
  }
  {
#line 106
  tmp___2 = __builtin_expect((long )(! (! (n >= -32768L))), 1L);
  }
#line 106
  if (tmp___2) {
    {
#line 106
    tmp___1 = write_int16(sptr, eptr, (short )n);
    }
#line 106
    return (tmp___1);
  }
  {
#line 108
  tmp___4 = __builtin_expect((long )(! (! (n < (-0x7FFFFFFF-1)))), 0L);
  }
#line 108
  if (tmp___4) {
    {
#line 108
    tmp___3 = write_int64(sptr, eptr, n);
    }
#line 108
    return (tmp___3);
  }
  {
#line 110
  tmp___5 = write_int32(sptr, eptr, (int )n);
  }
#line 110
  return (tmp___5);
}
}
#line 113 "/home/june/repo/benchmarks/collector/temp/bin-prot-109.30.00/_build/lib/write_stubs.c"
__inline static value ( __attribute__((__always_inline__)) write_int)(char *sptr ,
                                                                      char *eptr ,
                                                                      long n ) 
{ 
  value tmp ;
  long tmp___0 ;
  value tmp___1 ;

  {
  {
#line 116
  tmp___0 = __builtin_expect((long )(! (! (n >= 0L))), 1L);
  }
#line 116
  if (tmp___0) {
    {
#line 116
    tmp = write_int_nat0(sptr, eptr, (unsigned long )n);
    }
#line 116
    return (tmp);
  }
  {
#line 118
  tmp___1 = write_int_negative(sptr, eptr, n);
  }
#line 118
  return (tmp___1);
}
}
#line 121 "/home/june/repo/benchmarks/collector/temp/bin-prot-109.30.00/_build/lib/write_stubs.c"
value write_int_stub(char *sptr , char *eptr , value v_n ) 
{ 
  value tmp ;

  {
  {
#line 123
  tmp = write_int(sptr, eptr, v_n >> 1);
  }
#line 123
  return (tmp);
}
}
#line 129 "/home/june/repo/benchmarks/collector/temp/bin-prot-109.30.00/_build/lib/write_stubs.c"
__inline static value ( __attribute__((__always_inline__)) write_nat0)(char *sptr ,
                                                                       char *eptr ,
                                                                       unsigned long n ) 
{ 
  value tmp ;
  long tmp___0 ;
  value tmp___1 ;
  long tmp___2 ;
  value tmp___3 ;
  long tmp___4 ;
  value tmp___5 ;

  {
  {
#line 131
  tmp___0 = __builtin_expect((long )(! (! (n < 128UL))), 1L);
  }
#line 131
  if (tmp___0) {
    {
#line 131
    tmp = write_small_int(sptr, eptr, (char )n);
    }
#line 131
    return (tmp);
  }
  {
#line 132
  tmp___2 = __builtin_expect((long )(! (! (n < 65536UL))), 1L);
  }
#line 132
  if (tmp___2) {
    {
#line 132
    tmp___1 = write_int16(sptr, eptr, (short )n);
    }
#line 132
    return (tmp___1);
  }
  {
#line 134
  tmp___4 = __builtin_expect((long )(! (! (n >= 4294967296UL))), 0L);
  }
#line 134
  if (tmp___4) {
    {
#line 134
    tmp___3 = write_int64(sptr, eptr, (long )n);
    }
#line 134
    return (tmp___3);
  }
  {
#line 136
  tmp___5 = write_int32(sptr, eptr, (int )n);
  }
#line 136
  return (tmp___5);
}
}
#line 139 "/home/june/repo/benchmarks/collector/temp/bin-prot-109.30.00/_build/lib/write_stubs.c"
value write_nat0_stub(char *sptr , char *eptr , value v_n ) 
{ 
  value tmp ;

  {
  {
#line 141
  tmp = write_nat0(sptr, eptr, (unsigned long )(v_n >> 1));
  }
#line 141
  return (tmp);
}
}
#line 147 "/home/june/repo/benchmarks/collector/temp/bin-prot-109.30.00/_build/lib/write_stubs.c"
value write_int32_stub(char *sptr , char *eptr , value v_n ) 
{ 
  value tmp ;

  {
  {
#line 149
  tmp = write_int(sptr, eptr, (long )*((int32 *)((void *)((value *)v_n + 1))));
  }
#line 149
  return (tmp);
}
}
#line 191 "/home/june/repo/benchmarks/collector/temp/bin-prot-109.30.00/_build/lib/write_stubs.c"
value write_int64_stub(char *sptr , char *eptr , value v_n ) 
{ 
  int64 n ;
  value tmp ;

  {
  {
#line 193
  n = *((int64 *)((void *)((value *)v_n + 1)));
#line 195
  tmp = write_int(sptr, eptr, (long )n);
  }
#line 195
  return (tmp);
}
}
#line 205 "/home/june/repo/benchmarks/collector/temp/bin-prot-109.30.00/_build/lib/write_stubs.c"
value write_nativeint_stub(char *sptr , char *eptr , value v_n ) 
{ 
  long n ;
  value tmp ;

  {
  {
#line 207
  n = *((intnat *)((void *)((value *)v_n + 1)));
#line 208
  tmp = write_int(sptr, eptr, n);
  }
#line 208
  return (tmp);
}
}
#line 214 "/home/june/repo/benchmarks/collector/temp/bin-prot-109.30.00/_build/lib/write_stubs.c"
value write_small_int_stub(char *sptr , char *eptr , value v_n ) 
{ 
  value tmp ;

  {
  {
#line 216
  tmp = write_small_int(sptr, eptr, (char )((int )(v_n >> 1)));
  }
#line 216
  return (tmp);
}
}
#line 222 "/home/june/repo/benchmarks/collector/temp/bin-prot-109.30.00/_build/lib/write_stubs.c"
value write_string_stub(char *sptr , char *eptr , value v_str ) 
{ 
  char *str ;
  unsigned long len ;
  mlsize_t tmp ;
  char *next ;
  char *dst ;
  long tmp___0 ;
  unsigned long tmp___1 ;
  int tmp___2 ;
  long tmp___3 ;
  unsigned long tmp___4 ;
  int tmp___5 ;
  long tmp___6 ;
  long tmp___7 ;
  long tmp___8 ;
  long tmp___9 ;
  long tmp___10 ;
  long tmp___11 ;
  long tmp___12 ;
  long tmp___13 ;
  long tmp___14 ;

  {
  {
#line 224
  str = (char *)v_str;
#line 225
  tmp = caml_string_length(v_str);
#line 225
  len = tmp;
#line 227
  tmp___7 = __builtin_expect((long )(! (! (len < 20UL))), 1L);
  }
#line 227
  if (tmp___7) {
    {
#line 229
    dst = sptr + 1;
#line 230
    next = dst + len;
#line 231
    tmp___0 = __builtin_expect((long )(! (! ((unsigned long )next > (unsigned long )eptr))),
                               0L);
    }
#line 231
    if (tmp___0) {
      {
#line 232
      caml_raise_constant(*v_bin_prot_exc_Buffer_short);
      }
    }
#line 233
    *sptr = (char )len;
#line 234
    tmp___4 = len;
#line 234
    len --;
#line 234
    if (tmp___4 > 0UL) {
#line 234
      tmp___5 = 1;
    } else {
#line 234
      tmp___5 = 0;
    }
    {
#line 234
    tmp___6 = __builtin_expect((long )tmp___5, 1L);
    }
#line 234
    if (tmp___6) {
      {
#line 235
      while (1) {
        while_continue: /* CIL Label */ ;
#line 235
        *(dst + len) = *(str + len);
#line 235
        tmp___1 = len;
#line 235
        len --;
#line 235
        if (tmp___1 != 0UL) {
#line 235
          tmp___2 = 1;
        } else {
#line 235
          tmp___2 = 0;
        }
        {
#line 235
        tmp___3 = __builtin_expect((long )tmp___2, 1L);
        }
#line 235
        if (! tmp___3) {
#line 235
          goto while_break;
        }
      }
      while_break: /* CIL Label */ ;
      }
    }
#line 236
    return ((value )next);
  }
  {
#line 238
  tmp___9 = __builtin_expect((long )(! (! (len < 128UL))), 1L);
  }
#line 238
  if (tmp___9) {
    {
#line 239
    dst = sptr + 1;
#line 240
    next = dst + len;
#line 241
    tmp___8 = __builtin_expect((long )(! (! ((unsigned long )next > (unsigned long )eptr))),
                               0L);
    }
#line 241
    if (tmp___8) {
      {
#line 242
      caml_raise_constant(*v_bin_prot_exc_Buffer_short);
      }
    }
    {
#line 243
    *sptr = (char )len;
#line 244
    memcpy((void */* __restrict  */)dst, (void const   */* __restrict  */)str, len);
    }
#line 245
    return ((value )next);
  }
  {
#line 247
  tmp___11 = __builtin_expect((long )(! (! (len < 65536UL))), 1L);
  }
#line 247
  if (tmp___11) {
    {
#line 248
    dst = sptr + 3;
#line 249
    next = dst + len;
#line 250
    tmp___10 = __builtin_expect((long )(! (! ((unsigned long )next > (unsigned long )eptr))),
                                0L);
    }
#line 250
    if (tmp___10) {
      {
#line 251
      caml_raise_constant(*v_bin_prot_exc_Buffer_short);
      }
    }
    {
#line 252
    do_write_int16(sptr, (short )len);
#line 253
    memcpy((void */* __restrict  */)dst, (void const   */* __restrict  */)str, len);
    }
#line 254
    return ((value )next);
  }
  {
#line 257
  tmp___14 = __builtin_expect((long )(! (! (len >= 4294967296UL))), 0L);
  }
#line 257
  if (tmp___14) {
    {
#line 258
    dst = sptr + 9;
#line 259
    next = dst + len;
#line 260
    tmp___12 = __builtin_expect((long )(! (! ((unsigned long )next > (unsigned long )eptr))),
                                0L);
    }
#line 260
    if (tmp___12) {
      {
#line 261
      caml_raise_constant(*v_bin_prot_exc_Buffer_short);
      }
    }
    {
#line 262
    do_write_int64(sptr, (long )len);
#line 263
    memcpy((void */* __restrict  */)dst, (void const   */* __restrict  */)str, len);
    }
#line 264
    return ((value )next);
  } else {
    {
#line 268
    dst = sptr + 5;
#line 269
    next = dst + len;
#line 270
    tmp___13 = __builtin_expect((long )(! (! ((unsigned long )next > (unsigned long )eptr))),
                                0L);
    }
#line 270
    if (tmp___13) {
      {
#line 271
      caml_raise_constant(*v_bin_prot_exc_Buffer_short);
      }
    }
    {
#line 272
    do_write_int32(sptr, (int )((unsigned int )len));
#line 273
    memcpy((void */* __restrict  */)dst, (void const   */* __restrict  */)str, len);
    }
#line 274
    return ((value )next);
  }
}
}
#line 281 "/home/june/repo/benchmarks/collector/temp/bin-prot-109.30.00/_build/lib/write_stubs.c"
__inline value ( __attribute__((__always_inline__)) write_float_stub)(char *sptr ,
                                                                      char *eptr ,
                                                                      value v_n ) 
{ 
  char *next ;
  double n ;
  long tmp ;

  {
  {
#line 283
  next = sptr + sizeof(double );
#line 284
  n = *((double *)v_n);
#line 285
  tmp = __builtin_expect((long )(! (! ((unsigned long )next > (unsigned long )eptr))),
                         0L);
  }
#line 285
  if (tmp) {
    {
#line 285
    caml_raise_constant(*v_bin_prot_exc_Buffer_short);
    }
  }
  {
#line 286
  memcpy((void */* __restrict  */)sptr, (void const   */* __restrict  */)(& n), sizeof(double ));
  }
#line 287
  return ((value )next);
}
}
#line 290 "/home/june/repo/benchmarks/collector/temp/bin-prot-109.30.00/_build/lib/write_stubs.c"
value ml_write_float_stub(value v_buf , value v_pos , value v_v ) 
{ 
  struct caml_ba_array *buf ;
  char *start ;
  long pos ;
  char *sptr ;
  char *eptr ;
  long tmp ;
  value tmp___0 ;

  {
  {
#line 290
  buf = (struct caml_ba_array *)((void *)((value *)v_buf + 1));
#line 290
  start = (char *)buf->data;
#line 290
  pos = v_pos >> 1;
#line 290
  sptr = start + pos;
#line 290
  eptr = start + buf->dim[0];
#line 290
  tmp = __builtin_expect((long )(! (! (pos < 0L))), 0L);
  }
#line 290
  if (tmp) {
    {
#line 290
    caml_array_bound_error();
    }
  }
  {
#line 290
  tmp___0 = write_float_stub(sptr, eptr, v_v);
#line 290
  sptr = (char *)tmp___0;
  }
#line 290
  return (((sptr - start) << 1) + 1L);
}
}
#line 292 "/home/june/repo/benchmarks/collector/temp/bin-prot-109.30.00/_build/lib/write_stubs.c"
__inline value ( __attribute__((__always_inline__)) write_float_array_stub)(char *sptr ,
                                                                            char *eptr ,
                                                                            value v_ar ) 
{ 
  unsigned long wlen ;
  double *src ;
  unsigned long len ;
  unsigned long tot_size ;
  char *next ;
  char *dst ;
  long tmp ;
  long tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;
  long tmp___4 ;
  long tmp___5 ;

  {
  {
#line 294
  wlen = *((header_t *)v_ar + -1) >> 10;
#line 295
  src = (double *)v_ar;
#line 296
  len = wlen / (sizeof(double ) / sizeof(value ));
#line 297
  tot_size = len * sizeof(double );
#line 299
  tmp___0 = __builtin_expect((long )(! (! (len < 128UL))), 1L);
  }
#line 299
  if (tmp___0) {
    {
#line 300
    dst = sptr + 1;
#line 301
    next = dst + tot_size;
#line 302
    tmp = __builtin_expect((long )(! (! ((unsigned long )next > (unsigned long )eptr))),
                           0L);
    }
#line 302
    if (tmp) {
      {
#line 303
      caml_raise_constant(*v_bin_prot_exc_Buffer_short);
      }
    }
    {
#line 304
    *sptr = (char )len;
#line 305
    memcpy((void */* __restrict  */)dst, (void const   */* __restrict  */)src, tot_size);
    }
#line 306
    return ((value )next);
  }
  {
#line 308
  tmp___2 = __builtin_expect((long )(! (! (len < 65536UL))), 1L);
  }
#line 308
  if (tmp___2) {
    {
#line 309
    dst = sptr + 3;
#line 310
    next = dst + tot_size;
#line 311
    tmp___1 = __builtin_expect((long )(! (! ((unsigned long )next > (unsigned long )eptr))),
                               0L);
    }
#line 311
    if (tmp___1) {
      {
#line 312
      caml_raise_constant(*v_bin_prot_exc_Buffer_short);
      }
    }
    {
#line 313
    do_write_int16(sptr, (short )len);
#line 314
    memcpy((void */* __restrict  */)dst, (void const   */* __restrict  */)src, tot_size);
    }
#line 315
    return ((value )next);
  }
  {
#line 318
  tmp___5 = __builtin_expect((long )(! (! (len >= 4294967296UL))), 1L);
  }
#line 318
  if (tmp___5) {
    {
#line 319
    dst = sptr + 9;
#line 320
    next = dst + tot_size;
#line 321
    tmp___3 = __builtin_expect((long )(! (! ((unsigned long )next > (unsigned long )eptr))),
                               0L);
    }
#line 321
    if (tmp___3) {
      {
#line 322
      caml_raise_constant(*v_bin_prot_exc_Buffer_short);
      }
    }
    {
#line 323
    do_write_int64(sptr, (long )len);
#line 324
    memcpy((void */* __restrict  */)dst, (void const   */* __restrict  */)src, tot_size);
    }
#line 325
    return ((value )next);
  } else {
    {
#line 329
    dst = sptr + 5;
#line 330
    next = dst + tot_size;
#line 331
    tmp___4 = __builtin_expect((long )(! (! ((unsigned long )next > (unsigned long )eptr))),
                               0L);
    }
#line 331
    if (tmp___4) {
      {
#line 332
      caml_raise_constant(*v_bin_prot_exc_Buffer_short);
      }
    }
    {
#line 333
    do_write_int32(sptr, (int )len);
#line 334
    memcpy((void */* __restrict  */)dst, (void const   */* __restrict  */)src, tot_size);
    }
#line 335
    return ((value )next);
  }
}
}
#line 339 "/home/june/repo/benchmarks/collector/temp/bin-prot-109.30.00/_build/lib/write_stubs.c"
value ml_write_float_array_stub(value v_buf , value v_pos , value v_v ) 
{ 
  struct caml_ba_array *buf ;
  char *start ;
  long pos ;
  char *sptr ;
  char *eptr ;
  long tmp ;
  value tmp___0 ;

  {
  {
#line 339
  buf = (struct caml_ba_array *)((void *)((value *)v_buf + 1));
#line 339
  start = (char *)buf->data;
#line 339
  pos = v_pos >> 1;
#line 339
  sptr = start + pos;
#line 339
  eptr = start + buf->dim[0];
#line 339
  tmp = __builtin_expect((long )(! (! (pos < 0L))), 0L);
  }
#line 339
  if (tmp) {
    {
#line 339
    caml_array_bound_error();
    }
  }
  {
#line 339
  tmp___0 = write_float_array_stub(sptr, eptr, v_v);
#line 339
  sptr = (char *)tmp___0;
  }
#line 339
  return (((sptr - start) << 1) + 1L);
}
}
#line 344 "/home/june/repo/benchmarks/collector/temp/bin-prot-109.30.00/_build/lib/write_stubs.c"
__inline value ( __attribute__((__always_inline__)) write_variant_tag_stub)(char *sptr ,
                                                                            char *eptr ,
                                                                            value v_tag ) 
{ 
  char *next ;
  int tag ;
  long tmp ;
  value tmp___0 ;
  uint32_t __n ;

  {
  {
#line 347
  next = sptr + 4;
#line 349
  tmp = __builtin_expect((long )(! (! ((unsigned long )next > (unsigned long )eptr))),
                         0L);
  }
#line 349
  if (tmp) {
    {
#line 349
    caml_raise_constant(*v_bin_prot_exc_Buffer_short);
    }
  }
#line 350
  if ((v_tag & 1L) == 0L) {
#line 350
    tmp___0 = *((value *)v_tag + 0);
  } else {
#line 350
    tmp___0 = v_tag;
  }
  {
#line 350
  tag = (int )tmp___0;
#line 351
  __n = (uint32_t )tag;
#line 351
  memcpy((void */* __restrict  */)sptr, (void const   */* __restrict  */)(& __n),
         (size_t )4);
  }
#line 352
  return ((value )next);
}
}
#line 355 "/home/june/repo/benchmarks/collector/temp/bin-prot-109.30.00/_build/lib/write_stubs.c"
value ml_write_variant_tag_stub(value v_buf , value v_pos , value v_v ) 
{ 
  struct caml_ba_array *buf ;
  char *start ;
  long pos ;
  char *sptr ;
  char *eptr ;
  long tmp ;
  value tmp___0 ;

  {
  {
#line 355
  buf = (struct caml_ba_array *)((void *)((value *)v_buf + 1));
#line 355
  start = (char *)buf->data;
#line 355
  pos = v_pos >> 1;
#line 355
  sptr = start + pos;
#line 355
  eptr = start + buf->dim[0];
#line 355
  tmp = __builtin_expect((long )(! (! (pos < 0L))), 0L);
  }
#line 355
  if (tmp) {
    {
#line 355
    caml_array_bound_error();
    }
  }
  {
#line 355
  tmp___0 = write_variant_tag_stub(sptr, eptr, v_v);
#line 355
  sptr = (char *)tmp___0;
  }
#line 355
  return (((sptr - start) << 1) + 1L);
}
}
#line 360 "/home/june/repo/benchmarks/collector/temp/bin-prot-109.30.00/_build/lib/write_stubs.c"
__inline value ( __attribute__((__always_inline__)) write_raw_string_stub)(char *sptr ,
                                                                           char *eptr ,
                                                                           value v_str ,
                                                                           value v_pos ,
                                                                           value v_len ) 
{ 
  size_t pos ;
  size_t len ;
  char *next ;
  long tmp ;

  {
  {
#line 363
  pos = (size_t )(v_pos >> 1);
#line 363
  len = (size_t )(v_len >> 1);
#line 364
  next = sptr + len;
#line 365
  tmp = __builtin_expect((long )(! (! ((unsigned long )next > (unsigned long )eptr))),
                         0L);
  }
#line 365
  if (tmp) {
    {
#line 365
    caml_raise_constant(*v_bin_prot_exc_Buffer_short);
    }
  }
  {
#line 366
  memcpy((void */* __restrict  */)sptr, (void const   */* __restrict  */)((char *)v_str + pos),
         len);
  }
#line 367
  return ((value )next);
}
}
#line 373 "/home/june/repo/benchmarks/collector/temp/bin-prot-109.30.00/_build/lib/write_stubs.c"
__inline static value ( __attribute__((__always_inline__)) write_area)(value v , void *sptr ,
                                                                       char *eptr ,
                                                                       void *src ,
                                                                       unsigned long len ,
                                                                       size_t tot_size ) 
{ 
  char *next ;
  char *dst ;
  long tmp ;
  long tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;
  struct caml__roots_block caml__roots_block ;
  long tmp___4 ;
  struct caml__roots_block caml__roots_block___0 ;
  long tmp___5 ;

  {
  {
#line 378
  tmp___0 = __builtin_expect((long )(! (! (len < 128UL))), 1L);
  }
#line 378
  if (tmp___0) {
    {
#line 379
    dst = (char *)sptr + 1;
#line 380
    next = dst + tot_size;
#line 381
    tmp = __builtin_expect((long )(! (! ((unsigned long )next > (unsigned long )eptr))),
                           0L);
    }
#line 381
    if (tmp) {
      {
#line 382
      caml_raise_constant(*v_bin_prot_exc_Buffer_short);
      }
    }
    {
#line 383
    *((char *)sptr) = (char )len;
#line 384
    memcpy((void */* __restrict  */)dst, (void const   */* __restrict  */)src, tot_size);
    }
#line 385
    return ((value )next);
  }
  {
#line 387
  tmp___2 = __builtin_expect((long )(! (! (len < 65536UL))), 1L);
  }
#line 387
  if (tmp___2) {
    {
#line 388
    dst = (char *)sptr + 3;
#line 389
    next = dst + tot_size;
#line 390
    tmp___1 = __builtin_expect((long )(! (! ((unsigned long )next > (unsigned long )eptr))),
                               0L);
    }
#line 390
    if (tmp___1) {
      {
#line 391
      caml_raise_constant(*v_bin_prot_exc_Buffer_short);
      }
    }
    {
#line 392
    do_write_int16((char *)sptr, (short )len);
#line 393
    memcpy((void */* __restrict  */)dst, (void const   */* __restrict  */)src, tot_size);
    }
#line 394
    return ((value )next);
  }
  {
#line 397
  tmp___5 = __builtin_expect((long )(! (! (len >= 4294967296UL))), 0L);
  }
#line 397
  if (tmp___5) {
    {
#line 398
    dst = (char *)sptr + 9;
#line 399
    next = dst + tot_size;
#line 400
    tmp___3 = __builtin_expect((long )(! (! ((unsigned long )next > (unsigned long )eptr))),
                               0L);
    }
#line 400
    if (tmp___3) {
      {
#line 401
      caml_raise_constant(*v_bin_prot_exc_Buffer_short);
      }
    }
    {
#line 402
    caml__roots_block.next = caml_local_roots;
#line 402
    caml_local_roots = & caml__roots_block;
#line 402
    caml__roots_block.nitems = (intnat )1;
#line 402
    caml__roots_block.ntables = (intnat )1;
#line 402
    caml__roots_block.tables[0] = & v;
#line 403
    caml_enter_blocking_section();
#line 404
    do_write_int64((char *)sptr, (long )len);
#line 405
    memcpy((void */* __restrict  */)dst, (void const   */* __restrict  */)src, tot_size);
#line 406
    caml_leave_blocking_section();
#line 407
    caml_local_roots = caml__roots_block.next;
    }
#line 408
    return ((value )next);
  } else {
    {
#line 412
    dst = (char *)sptr + 5;
#line 413
    next = dst + tot_size;
#line 414
    tmp___4 = __builtin_expect((long )(! (! ((unsigned long )next > (unsigned long )eptr))),
                               0L);
    }
#line 414
    if (tmp___4) {
      {
#line 415
      caml_raise_constant(*v_bin_prot_exc_Buffer_short);
      }
    }
    {
#line 416
    caml__roots_block___0.next = caml_local_roots;
#line 416
    caml_local_roots = & caml__roots_block___0;
#line 416
    caml__roots_block___0.nitems = (intnat )1;
#line 416
    caml__roots_block___0.ntables = (intnat )1;
#line 416
    caml__roots_block___0.tables[0] = & v;
#line 417
    caml_enter_blocking_section();
#line 418
    do_write_int32((char *)sptr, (int )len);
#line 419
    memcpy((void */* __restrict  */)dst, (void const   */* __restrict  */)src, tot_size);
#line 420
    caml_leave_blocking_section();
#line 421
    caml_local_roots = caml__roots_block___0.next;
    }
#line 422
    return ((value )next);
  }
}
}
#line 439 "/home/june/repo/benchmarks/collector/temp/bin-prot-109.30.00/_build/lib/write_stubs.c"
__inline value ( __attribute__((__always_inline__)) write_bigstring_stub)(char *sptr ,
                                                                          char *eptr ,
                                                                          value v_v ) 
{ 
  struct caml_ba_array *vec ;
  unsigned long len ;
  value tmp ;

  {
  {
#line 439
  vec = (struct caml_ba_array *)((void *)((value *)v_v + 1));
#line 439
  len = (unsigned long )vec->dim[0];
#line 439
  tmp = write_area(v_v, (void *)sptr, eptr, vec->data, len, len * sizeof(char ));
  }
#line 439
  return (tmp);
}
}
#line 439 "/home/june/repo/benchmarks/collector/temp/bin-prot-109.30.00/_build/lib/write_stubs.c"
value ml_write_bigstring_stub(value v_buf , value v_pos , value v_v ) 
{ 
  struct caml_ba_array *buf ;
  char *start ;
  long pos ;
  char *sptr ;
  char *eptr ;
  long tmp ;
  value tmp___0 ;

  {
  {
#line 439
  buf = (struct caml_ba_array *)((void *)((value *)v_buf + 1));
#line 439
  start = (char *)buf->data;
#line 439
  pos = v_pos >> 1;
#line 439
  sptr = start + pos;
#line 439
  eptr = start + buf->dim[0];
#line 439
  tmp = __builtin_expect((long )(! (! (pos < 0L))), 0L);
  }
#line 439
  if (tmp) {
    {
#line 439
    caml_array_bound_error();
    }
  }
  {
#line 439
  tmp___0 = write_bigstring_stub(sptr, eptr, v_v);
#line 439
  sptr = (char *)tmp___0;
  }
#line 439
  return (((sptr - start) << 1) + 1L);
}
}
#line 458 "/home/june/repo/benchmarks/collector/temp/bin-prot-109.30.00/_build/lib/write_stubs.c"
__inline value ( __attribute__((__always_inline__)) write_float32_vec_stub)(char *sptr ,
                                                                            char *eptr ,
                                                                            value v_v ) 
{ 
  struct caml_ba_array *vec ;
  unsigned long len ;
  value tmp ;

  {
  {
#line 458
  vec = (struct caml_ba_array *)((void *)((value *)v_v + 1));
#line 458
  len = (unsigned long )vec->dim[0];
#line 458
  tmp = write_area(v_v, (void *)sptr, eptr, vec->data, len, len * sizeof(float ));
  }
#line 458
  return (tmp);
}
}
#line 458 "/home/june/repo/benchmarks/collector/temp/bin-prot-109.30.00/_build/lib/write_stubs.c"
value ml_write_float32_vec_stub(value v_buf , value v_pos , value v_v ) 
{ 
  struct caml_ba_array *buf ;
  char *start ;
  long pos ;
  char *sptr ;
  char *eptr ;
  long tmp ;
  value tmp___0 ;

  {
  {
#line 458
  buf = (struct caml_ba_array *)((void *)((value *)v_buf + 1));
#line 458
  start = (char *)buf->data;
#line 458
  pos = v_pos >> 1;
#line 458
  sptr = start + pos;
#line 458
  eptr = start + buf->dim[0];
#line 458
  tmp = __builtin_expect((long )(! (! (pos < 0L))), 0L);
  }
#line 458
  if (tmp) {
    {
#line 458
    caml_array_bound_error();
    }
  }
  {
#line 458
  tmp___0 = write_float32_vec_stub(sptr, eptr, v_v);
#line 458
  sptr = (char *)tmp___0;
  }
#line 458
  return (((sptr - start) << 1) + 1L);
}
}
#line 458 "/home/june/repo/benchmarks/collector/temp/bin-prot-109.30.00/_build/lib/write_stubs.c"
__inline value ( __attribute__((__always_inline__)) write_float32_mat_stub)(char *sptr ,
                                                                            char *eptr ,
                                                                            value v_m ) 
{ 
  struct caml_ba_array *mat ;
  unsigned long dim1 ;
  unsigned long dim2 ;
  unsigned long size ;
  value tmp ;
  value tmp___0 ;

  {
  {
#line 458
  mat = (struct caml_ba_array *)((void *)((value *)v_m + 1));
#line 458
  dim1 = (unsigned long )mat->dim[0];
#line 458
  dim2 = (unsigned long )mat->dim[1];
#line 458
  size = dim1 * dim2;
#line 458
  tmp = write_nat0(sptr, eptr, dim1);
#line 458
  sptr = (char *)tmp;
#line 458
  tmp___0 = write_area(v_m, (void *)sptr, eptr, mat->data, dim2, size * sizeof(float ));
  }
#line 458
  return (tmp___0);
}
}
#line 458 "/home/june/repo/benchmarks/collector/temp/bin-prot-109.30.00/_build/lib/write_stubs.c"
value ml_write_float32_mat_stub(value v_buf , value v_pos , value v_v ) 
{ 
  struct caml_ba_array *buf ;
  char *start ;
  long pos ;
  char *sptr ;
  char *eptr ;
  long tmp ;
  value tmp___0 ;

  {
  {
#line 458
  buf = (struct caml_ba_array *)((void *)((value *)v_buf + 1));
#line 458
  start = (char *)buf->data;
#line 458
  pos = v_pos >> 1;
#line 458
  sptr = start + pos;
#line 458
  eptr = start + buf->dim[0];
#line 458
  tmp = __builtin_expect((long )(! (! (pos < 0L))), 0L);
  }
#line 458
  if (tmp) {
    {
#line 458
    caml_array_bound_error();
    }
  }
  {
#line 458
  tmp___0 = write_float32_mat_stub(sptr, eptr, v_v);
#line 458
  sptr = (char *)tmp___0;
  }
#line 458
  return (((sptr - start) << 1) + 1L);
}
}
#line 459 "/home/june/repo/benchmarks/collector/temp/bin-prot-109.30.00/_build/lib/write_stubs.c"
__inline value ( __attribute__((__always_inline__)) write_float64_vec_stub)(char *sptr ,
                                                                            char *eptr ,
                                                                            value v_v ) 
{ 
  struct caml_ba_array *vec ;
  unsigned long len ;
  value tmp ;

  {
  {
#line 459
  vec = (struct caml_ba_array *)((void *)((value *)v_v + 1));
#line 459
  len = (unsigned long )vec->dim[0];
#line 459
  tmp = write_area(v_v, (void *)sptr, eptr, vec->data, len, len * sizeof(double ));
  }
#line 459
  return (tmp);
}
}
#line 459 "/home/june/repo/benchmarks/collector/temp/bin-prot-109.30.00/_build/lib/write_stubs.c"
value ml_write_float64_vec_stub(value v_buf , value v_pos , value v_v ) 
{ 
  struct caml_ba_array *buf ;
  char *start ;
  long pos ;
  char *sptr ;
  char *eptr ;
  long tmp ;
  value tmp___0 ;

  {
  {
#line 459
  buf = (struct caml_ba_array *)((void *)((value *)v_buf + 1));
#line 459
  start = (char *)buf->data;
#line 459
  pos = v_pos >> 1;
#line 459
  sptr = start + pos;
#line 459
  eptr = start + buf->dim[0];
#line 459
  tmp = __builtin_expect((long )(! (! (pos < 0L))), 0L);
  }
#line 459
  if (tmp) {
    {
#line 459
    caml_array_bound_error();
    }
  }
  {
#line 459
  tmp___0 = write_float64_vec_stub(sptr, eptr, v_v);
#line 459
  sptr = (char *)tmp___0;
  }
#line 459
  return (((sptr - start) << 1) + 1L);
}
}
#line 459 "/home/june/repo/benchmarks/collector/temp/bin-prot-109.30.00/_build/lib/write_stubs.c"
__inline value ( __attribute__((__always_inline__)) write_float64_mat_stub)(char *sptr ,
                                                                            char *eptr ,
                                                                            value v_m ) 
{ 
  struct caml_ba_array *mat ;
  unsigned long dim1 ;
  unsigned long dim2 ;
  unsigned long size ;
  value tmp ;
  value tmp___0 ;

  {
  {
#line 459
  mat = (struct caml_ba_array *)((void *)((value *)v_m + 1));
#line 459
  dim1 = (unsigned long )mat->dim[0];
#line 459
  dim2 = (unsigned long )mat->dim[1];
#line 459
  size = dim1 * dim2;
#line 459
  tmp = write_nat0(sptr, eptr, dim1);
#line 459
  sptr = (char *)tmp;
#line 459
  tmp___0 = write_area(v_m, (void *)sptr, eptr, mat->data, dim2, size * sizeof(double ));
  }
#line 459
  return (tmp___0);
}
}
#line 459 "/home/june/repo/benchmarks/collector/temp/bin-prot-109.30.00/_build/lib/write_stubs.c"
value ml_write_float64_mat_stub(value v_buf , value v_pos , value v_v ) 
{ 
  struct caml_ba_array *buf ;
  char *start ;
  long pos ;
  char *sptr ;
  char *eptr ;
  long tmp ;
  value tmp___0 ;

  {
  {
#line 459
  buf = (struct caml_ba_array *)((void *)((value *)v_buf + 1));
#line 459
  start = (char *)buf->data;
#line 459
  pos = v_pos >> 1;
#line 459
  sptr = start + pos;
#line 459
  eptr = start + buf->dim[0];
#line 459
  tmp = __builtin_expect((long )(! (! (pos < 0L))), 0L);
  }
#line 459
  if (tmp) {
    {
#line 459
    caml_array_bound_error();
    }
  }
  {
#line 459
  tmp___0 = write_float64_mat_stub(sptr, eptr, v_v);
#line 459
  sptr = (char *)tmp___0;
  }
#line 459
  return (((sptr - start) << 1) + 1L);
}
}
#line 464 "/home/june/repo/benchmarks/collector/temp/bin-prot-109.30.00/_build/lib/write_stubs.c"
value write_int_8bit_stub(char *sptr , char *eptr , value v_n ) 
{ 
  char *next ;
  long tmp ;

  {
  {
#line 466
  next = sptr + 1;
#line 467
  tmp = __builtin_expect((long )(! (! ((unsigned long )next > (unsigned long )eptr))),
                         0L);
  }
#line 467
  if (tmp) {
    {
#line 467
    caml_raise_constant(*v_bin_prot_exc_Buffer_short);
    }
  }
#line 468
  *sptr = (char )((int )(v_n >> 1));
#line 469
  return ((value )next);
}
}
#line 471 "/home/june/repo/benchmarks/collector/temp/bin-prot-109.30.00/_build/lib/write_stubs.c"
value ml_write_int_8bit_stub(value v_buf , value v_pos , value v_v ) 
{ 
  struct caml_ba_array *buf ;
  char *start ;
  long pos ;
  char *sptr ;
  char *eptr ;
  long tmp ;
  value tmp___0 ;

  {
  {
#line 471
  buf = (struct caml_ba_array *)((void *)((value *)v_buf + 1));
#line 471
  start = (char *)buf->data;
#line 471
  pos = v_pos >> 1;
#line 471
  sptr = start + pos;
#line 471
  eptr = start + buf->dim[0];
#line 471
  tmp = __builtin_expect((long )(! (! (pos < 0L))), 0L);
  }
#line 471
  if (tmp) {
    {
#line 471
    caml_array_bound_error();
    }
  }
  {
#line 471
  tmp___0 = write_int_8bit_stub(sptr, eptr, v_v);
#line 471
  sptr = (char *)tmp___0;
  }
#line 471
  return (((sptr - start) << 1) + 1L);
}
}
#line 473 "/home/june/repo/benchmarks/collector/temp/bin-prot-109.30.00/_build/lib/write_stubs.c"
value write_int_16bit_stub(char *sptr , char *eptr , value v_n ) 
{ 
  char *next ;
  long tmp ;
  uint16_t __n ;

  {
  {
#line 475
  next = sptr + 2;
#line 476
  tmp = __builtin_expect((long )(! (! ((unsigned long )next > (unsigned long )eptr))),
                         0L);
  }
#line 476
  if (tmp) {
    {
#line 476
    caml_raise_constant(*v_bin_prot_exc_Buffer_short);
    }
  }
  {
#line 477
  __n = (uint16_t )((int )(v_n >> 1));
#line 477
  memcpy((void */* __restrict  */)sptr, (void const   */* __restrict  */)(& __n),
         (size_t )2);
  }
#line 478
  return ((value )next);
}
}
#line 480 "/home/june/repo/benchmarks/collector/temp/bin-prot-109.30.00/_build/lib/write_stubs.c"
value ml_write_int_16bit_stub(value v_buf , value v_pos , value v_v ) 
{ 
  struct caml_ba_array *buf ;
  char *start ;
  long pos ;
  char *sptr ;
  char *eptr ;
  long tmp ;
  value tmp___0 ;

  {
  {
#line 480
  buf = (struct caml_ba_array *)((void *)((value *)v_buf + 1));
#line 480
  start = (char *)buf->data;
#line 480
  pos = v_pos >> 1;
#line 480
  sptr = start + pos;
#line 480
  eptr = start + buf->dim[0];
#line 480
  tmp = __builtin_expect((long )(! (! (pos < 0L))), 0L);
  }
#line 480
  if (tmp) {
    {
#line 480
    caml_array_bound_error();
    }
  }
  {
#line 480
  tmp___0 = write_int_16bit_stub(sptr, eptr, v_v);
#line 480
  sptr = (char *)tmp___0;
  }
#line 480
  return (((sptr - start) << 1) + 1L);
}
}
#line 482 "/home/june/repo/benchmarks/collector/temp/bin-prot-109.30.00/_build/lib/write_stubs.c"
value write_int_32bit_stub(char *sptr , char *eptr , value v_n ) 
{ 
  char *next ;
  long tmp ;
  uint32_t __n ;

  {
  {
#line 484
  next = sptr + 4;
#line 485
  tmp = __builtin_expect((long )(! (! ((unsigned long )next > (unsigned long )eptr))),
                         0L);
  }
#line 485
  if (tmp) {
    {
#line 485
    caml_raise_constant(*v_bin_prot_exc_Buffer_short);
    }
  }
  {
#line 486
  __n = (uint32_t )((int )(v_n >> 1));
#line 486
  memcpy((void */* __restrict  */)sptr, (void const   */* __restrict  */)(& __n),
         (size_t )4);
  }
#line 487
  return ((value )next);
}
}
#line 489 "/home/june/repo/benchmarks/collector/temp/bin-prot-109.30.00/_build/lib/write_stubs.c"
value ml_write_int_32bit_stub(value v_buf , value v_pos , value v_v ) 
{ 
  struct caml_ba_array *buf ;
  char *start ;
  long pos ;
  char *sptr ;
  char *eptr ;
  long tmp ;
  value tmp___0 ;

  {
  {
#line 489
  buf = (struct caml_ba_array *)((void *)((value *)v_buf + 1));
#line 489
  start = (char *)buf->data;
#line 489
  pos = v_pos >> 1;
#line 489
  sptr = start + pos;
#line 489
  eptr = start + buf->dim[0];
#line 489
  tmp = __builtin_expect((long )(! (! (pos < 0L))), 0L);
  }
#line 489
  if (tmp) {
    {
#line 489
    caml_array_bound_error();
    }
  }
  {
#line 489
  tmp___0 = write_int_32bit_stub(sptr, eptr, v_v);
#line 489
  sptr = (char *)tmp___0;
  }
#line 489
  return (((sptr - start) << 1) + 1L);
}
}
#line 491 "/home/june/repo/benchmarks/collector/temp/bin-prot-109.30.00/_build/lib/write_stubs.c"
value write_int_64bit_stub(char *sptr , char *eptr , value v_n ) 
{ 
  char *next ;
  long tmp ;
  uint64_t __n ;

  {
  {
#line 493
  next = sptr + 8;
#line 494
  tmp = __builtin_expect((long )(! (! ((unsigned long )next > (unsigned long )eptr))),
                         0L);
  }
#line 494
  if (tmp) {
    {
#line 494
    caml_raise_constant(*v_bin_prot_exc_Buffer_short);
    }
  }
  {
#line 496
  __n = (uint64_t )(v_n >> 1);
#line 496
  memcpy((void */* __restrict  */)sptr, (void const   */* __restrict  */)(& __n),
         (size_t )8);
  }
#line 505
  return ((value )next);
}
}
#line 507 "/home/june/repo/benchmarks/collector/temp/bin-prot-109.30.00/_build/lib/write_stubs.c"
value ml_write_int_64bit_stub(value v_buf , value v_pos , value v_v ) 
{ 
  struct caml_ba_array *buf ;
  char *start ;
  long pos ;
  char *sptr ;
  char *eptr ;
  long tmp ;
  value tmp___0 ;

  {
  {
#line 507
  buf = (struct caml_ba_array *)((void *)((value *)v_buf + 1));
#line 507
  start = (char *)buf->data;
#line 507
  pos = v_pos >> 1;
#line 507
  sptr = start + pos;
#line 507
  eptr = start + buf->dim[0];
#line 507
  tmp = __builtin_expect((long )(! (! (pos < 0L))), 0L);
  }
#line 507
  if (tmp) {
    {
#line 507
    caml_array_bound_error();
    }
  }
  {
#line 507
  tmp___0 = write_int_64bit_stub(sptr, eptr, v_v);
#line 507
  sptr = (char *)tmp___0;
  }
#line 507
  return (((sptr - start) << 1) + 1L);
}
}
#line 509 "/home/june/repo/benchmarks/collector/temp/bin-prot-109.30.00/_build/lib/write_stubs.c"
__inline value ( __attribute__((__always_inline__)) write_int64_bits_stub)(char *sptr ,
                                                                           char *eptr ,
                                                                           value v_n ) 
{ 
  char *next ;
  long tmp ;
  uint64_t __n ;

  {
  {
#line 511
  next = sptr + 8;
#line 512
  tmp = __builtin_expect((long )(! (! ((unsigned long )next > (unsigned long )eptr))),
                         0L);
  }
#line 512
  if (tmp) {
    {
#line 512
    caml_raise_constant(*v_bin_prot_exc_Buffer_short);
    }
  }
  {
#line 514
  __n = (uint64_t )*((int64 *)((void *)((value *)v_n + 1)));
#line 514
  memcpy((void */* __restrict  */)sptr, (void const   */* __restrict  */)(& __n),
         (size_t )8);
  }
#line 524
  return ((value )next);
}
}
#line 526 "/home/june/repo/benchmarks/collector/temp/bin-prot-109.30.00/_build/lib/write_stubs.c"
value ml_write_int64_bits_stub(value v_buf , value v_pos , value v_v ) 
{ 
  struct caml_ba_array *buf ;
  char *start ;
  long pos ;
  char *sptr ;
  char *eptr ;
  long tmp ;
  value tmp___0 ;

  {
  {
#line 526
  buf = (struct caml_ba_array *)((void *)((value *)v_buf + 1));
#line 526
  start = (char *)buf->data;
#line 526
  pos = v_pos >> 1;
#line 526
  sptr = start + pos;
#line 526
  eptr = start + buf->dim[0];
#line 526
  tmp = __builtin_expect((long )(! (! (pos < 0L))), 0L);
  }
#line 526
  if (tmp) {
    {
#line 526
    caml_array_bound_error();
    }
  }
  {
#line 526
  tmp___0 = write_int64_bits_stub(sptr, eptr, v_v);
#line 526
  sptr = (char *)tmp___0;
  }
#line 526
  return (((sptr - start) << 1) + 1L);
}
}
#line 528 "/home/june/repo/benchmarks/collector/temp/bin-prot-109.30.00/_build/lib/write_stubs.c"
__inline value ( __attribute__((__always_inline__)) write_network16_int_stub)(char *sptr ,
                                                                              char *eptr ,
                                                                              value v_n ) 
{ 
  char *next ;
  long tmp ;
  uint16_t __n ;
  unsigned short __v ;
  unsigned short __x ;

  {
  {
#line 531
  next = sptr + 2;
#line 532
  tmp = __builtin_expect((long )(! (! ((unsigned long )next > (unsigned long )eptr))),
                         0L);
  }
#line 532
  if (tmp) {
    {
#line 532
    caml_raise_constant(*v_bin_prot_exc_Buffer_short);
    }
  }
  {
#line 533
  __x = (unsigned short )((int )(v_n >> 1));
#line 533
  __asm__  ("rorw $8, %w0": "=r" (__v): "0" (__x): "cc");
#line 533
  __n = __v;
#line 533
  memcpy((void */* __restrict  */)sptr, (void const   */* __restrict  */)(& __n),
         (size_t )2);
  }
#line 534
  return ((value )next);
}
}
#line 536 "/home/june/repo/benchmarks/collector/temp/bin-prot-109.30.00/_build/lib/write_stubs.c"
value ml_write_network16_int_stub(value v_buf , value v_pos , value v_v ) 
{ 
  struct caml_ba_array *buf ;
  char *start ;
  long pos ;
  char *sptr ;
  char *eptr ;
  long tmp ;
  value tmp___0 ;

  {
  {
#line 536
  buf = (struct caml_ba_array *)((void *)((value *)v_buf + 1));
#line 536
  start = (char *)buf->data;
#line 536
  pos = v_pos >> 1;
#line 536
  sptr = start + pos;
#line 536
  eptr = start + buf->dim[0];
#line 536
  tmp = __builtin_expect((long )(! (! (pos < 0L))), 0L);
  }
#line 536
  if (tmp) {
    {
#line 536
    caml_array_bound_error();
    }
  }
  {
#line 536
  tmp___0 = write_network16_int_stub(sptr, eptr, v_v);
#line 536
  sptr = (char *)tmp___0;
  }
#line 536
  return (((sptr - start) << 1) + 1L);
}
}
#line 538 "/home/june/repo/benchmarks/collector/temp/bin-prot-109.30.00/_build/lib/write_stubs.c"
__inline value ( __attribute__((__always_inline__)) write_network32_int_stub)(char *sptr ,
                                                                              char *eptr ,
                                                                              value v_n ) 
{ 
  char *next ;
  long tmp ;
  uint32_t __n ;
  unsigned int tmp___0 ;

  {
  {
#line 541
  next = sptr + 4;
#line 542
  tmp = __builtin_expect((long )(! (! ((unsigned long )next > (unsigned long )eptr))),
                         0L);
  }
#line 542
  if (tmp) {
    {
#line 542
    caml_raise_constant(*v_bin_prot_exc_Buffer_short);
    }
  }
  {
#line 543
  tmp___0 = __bswap_32((unsigned int )((int )(v_n >> 1)));
#line 543
  __n = tmp___0;
#line 543
  memcpy((void */* __restrict  */)sptr, (void const   */* __restrict  */)(& __n),
         (size_t )4);
  }
#line 544
  return ((value )next);
}
}
#line 546 "/home/june/repo/benchmarks/collector/temp/bin-prot-109.30.00/_build/lib/write_stubs.c"
value ml_write_network32_int_stub(value v_buf , value v_pos , value v_v ) 
{ 
  struct caml_ba_array *buf ;
  char *start ;
  long pos ;
  char *sptr ;
  char *eptr ;
  long tmp ;
  value tmp___0 ;

  {
  {
#line 546
  buf = (struct caml_ba_array *)((void *)((value *)v_buf + 1));
#line 546
  start = (char *)buf->data;
#line 546
  pos = v_pos >> 1;
#line 546
  sptr = start + pos;
#line 546
  eptr = start + buf->dim[0];
#line 546
  tmp = __builtin_expect((long )(! (! (pos < 0L))), 0L);
  }
#line 546
  if (tmp) {
    {
#line 546
    caml_array_bound_error();
    }
  }
  {
#line 546
  tmp___0 = write_network32_int_stub(sptr, eptr, v_v);
#line 546
  sptr = (char *)tmp___0;
  }
#line 546
  return (((sptr - start) << 1) + 1L);
}
}
#line 548 "/home/june/repo/benchmarks/collector/temp/bin-prot-109.30.00/_build/lib/write_stubs.c"
__inline value ( __attribute__((__always_inline__)) write_network32_int32_stub)(char *sptr ,
                                                                                char *eptr ,
                                                                                value v_n ) 
{ 
  char *next ;
  long tmp ;
  uint32_t __n ;
  unsigned int tmp___0 ;

  {
  {
#line 551
  next = sptr + 4;
#line 552
  tmp = __builtin_expect((long )(! (! ((unsigned long )next > (unsigned long )eptr))),
                         0L);
  }
#line 552
  if (tmp) {
    {
#line 552
    caml_raise_constant(*v_bin_prot_exc_Buffer_short);
    }
  }
  {
#line 553
  tmp___0 = __bswap_32((unsigned int )*((int32 *)((void *)((value *)v_n + 1))));
#line 553
  __n = tmp___0;
#line 553
  memcpy((void */* __restrict  */)sptr, (void const   */* __restrict  */)(& __n),
         (size_t )4);
  }
#line 554
  return ((value )next);
}
}
#line 556 "/home/june/repo/benchmarks/collector/temp/bin-prot-109.30.00/_build/lib/write_stubs.c"
value ml_write_network32_int32_stub(value v_buf , value v_pos , value v_v ) 
{ 
  struct caml_ba_array *buf ;
  char *start ;
  long pos ;
  char *sptr ;
  char *eptr ;
  long tmp ;
  value tmp___0 ;

  {
  {
#line 556
  buf = (struct caml_ba_array *)((void *)((value *)v_buf + 1));
#line 556
  start = (char *)buf->data;
#line 556
  pos = v_pos >> 1;
#line 556
  sptr = start + pos;
#line 556
  eptr = start + buf->dim[0];
#line 556
  tmp = __builtin_expect((long )(! (! (pos < 0L))), 0L);
  }
#line 556
  if (tmp) {
    {
#line 556
    caml_array_bound_error();
    }
  }
  {
#line 556
  tmp___0 = write_network32_int32_stub(sptr, eptr, v_v);
#line 556
  sptr = (char *)tmp___0;
  }
#line 556
  return (((sptr - start) << 1) + 1L);
}
}
#line 558 "/home/june/repo/benchmarks/collector/temp/bin-prot-109.30.00/_build/lib/write_stubs.c"
__inline value ( __attribute__((__always_inline__)) write_network64_int_stub)(char *sptr ,
                                                                              char *eptr ,
                                                                              value v_n ) 
{ 
  char *next ;
  long tmp ;
  uint64_t __n ;
  __uint64_t tmp___0 ;

  {
  {
#line 561
  next = sptr + 8;
#line 562
  tmp = __builtin_expect((long )(! (! ((unsigned long )next > (unsigned long )eptr))),
                         0L);
  }
#line 562
  if (tmp) {
    {
#line 562
    caml_raise_constant(*v_bin_prot_exc_Buffer_short);
    }
  }
  {
#line 564
  tmp___0 = __bswap_64((__uint64_t )(v_n >> 1));
#line 564
  __n = tmp___0;
#line 564
  memcpy((void */* __restrict  */)sptr, (void const   */* __restrict  */)(& __n),
         (size_t )8);
  }
#line 572
  return ((value )next);
}
}
#line 574 "/home/june/repo/benchmarks/collector/temp/bin-prot-109.30.00/_build/lib/write_stubs.c"
value ml_write_network64_int_stub(value v_buf , value v_pos , value v_v ) 
{ 
  struct caml_ba_array *buf ;
  char *start ;
  long pos ;
  char *sptr ;
  char *eptr ;
  long tmp ;
  value tmp___0 ;

  {
  {
#line 574
  buf = (struct caml_ba_array *)((void *)((value *)v_buf + 1));
#line 574
  start = (char *)buf->data;
#line 574
  pos = v_pos >> 1;
#line 574
  sptr = start + pos;
#line 574
  eptr = start + buf->dim[0];
#line 574
  tmp = __builtin_expect((long )(! (! (pos < 0L))), 0L);
  }
#line 574
  if (tmp) {
    {
#line 574
    caml_array_bound_error();
    }
  }
  {
#line 574
  tmp___0 = write_network64_int_stub(sptr, eptr, v_v);
#line 574
  sptr = (char *)tmp___0;
  }
#line 574
  return (((sptr - start) << 1) + 1L);
}
}
#line 576 "/home/june/repo/benchmarks/collector/temp/bin-prot-109.30.00/_build/lib/write_stubs.c"
__inline value ( __attribute__((__always_inline__)) write_network64_int64_stub)(char *sptr ,
                                                                                char *eptr ,
                                                                                value v_n ) 
{ 
  char *next ;
  long tmp ;
  uint64_t __n ;
  __uint64_t tmp___0 ;

  {
  {
#line 579
  next = sptr + 8;
#line 580
  tmp = __builtin_expect((long )(! (! ((unsigned long )next > (unsigned long )eptr))),
                         0L);
  }
#line 580
  if (tmp) {
    {
#line 580
    caml_raise_constant(*v_bin_prot_exc_Buffer_short);
    }
  }
  {
#line 582
  tmp___0 = __bswap_64((__uint64_t )*((int64 *)((void *)((value *)v_n + 1))));
#line 582
  __n = tmp___0;
#line 582
  memcpy((void */* __restrict  */)sptr, (void const   */* __restrict  */)(& __n),
         (size_t )8);
  }
#line 592
  return ((value )next);
}
}
#line 594 "/home/june/repo/benchmarks/collector/temp/bin-prot-109.30.00/_build/lib/write_stubs.c"
value ml_write_network64_int64_stub(value v_buf , value v_pos , value v_v ) 
{ 
  struct caml_ba_array *buf ;
  char *start ;
  long pos ;
  char *sptr ;
  char *eptr ;
  long tmp ;
  value tmp___0 ;

  {
  {
#line 594
  buf = (struct caml_ba_array *)((void *)((value *)v_buf + 1));
#line 594
  start = (char *)buf->data;
#line 594
  pos = v_pos >> 1;
#line 594
  sptr = start + pos;
#line 594
  eptr = start + buf->dim[0];
#line 594
  tmp = __builtin_expect((long )(! (! (pos < 0L))), 0L);
  }
#line 594
  if (tmp) {
    {
#line 594
    caml_array_bound_error();
    }
  }
  {
#line 594
  tmp___0 = write_network64_int64_stub(sptr, eptr, v_v);
#line 594
  sptr = (char *)tmp___0;
  }
#line 594
  return (((sptr - start) << 1) + 1L);
}
}
