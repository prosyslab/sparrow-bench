/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 133 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 136 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __rlim_t;
#line 260 "/usr/include/unistd.h"
typedef __pid_t pid_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/resource.h"
typedef __rlim_t rlim_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/resource.h"
struct rlimit {
   rlim_t rlim_cur ;
   rlim_t rlim_max ;
};
#line 42 "/usr/include/x86_64-linux-gnu/sys/resource.h"
typedef int __rlimit_resource_t;
#line 353 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 497
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) chdir)(char const   *__path ) ;
#line 534
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) dup2)(int __fd ,
                                                                           int __fd2 ) ;
#line 551
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) execve)(char const   *__path ,
                                                                                               char * const  *__argv ,
                                                                                               char * const  *__envp ) ;
#line 603
extern  __attribute__((__noreturn__)) void _exit(int __status ) ;
#line 756
extern  __attribute__((__nothrow__)) __pid_t fork(void) ;
#line 50 "/usr/include/x86_64-linux-gnu/sys/resource.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getrlimit)(__rlimit_resource_t __resource ,
                                                                                struct rlimit *__rlimits ) ;
#line 10 "/home/june/repo/benchmarks/collector/temp/enigmail-1.8.2/ipc/src/subprocess.c"
void closeOtherFds(int fdIn , int fdOut , int fdErr , int const   *dupFds , int skipFd ) 
{ 
  int maxFD ;
  int i ;
  int j ;
  struct rlimit rl ;
  int tmp ;
  int closeFd ;

  {
  {
#line 12
  maxFD = 256;
#line 16
  tmp = getrlimit(7, & rl);
  }
#line 16
  if (tmp == 0) {
#line 17
    if (rl.rlim_cur < 999999UL) {
#line 18
      maxFD = (int )rl.rlim_cur;
    }
  }
#line 23
  i = 3 + skipFd;
  {
#line 23
  while (1) {
    while_continue: /* CIL Label */ ;
#line 23
    if (! (i < maxFD)) {
#line 23
      goto while_break;
    }
#line 24
    closeFd = 1;
#line 25
    if (i != fdIn) {
#line 25
      if (i != fdOut) {
#line 25
        if (i != fdErr) {
#line 26
          j = 0;
          {
#line 26
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 26
            if (! (j < skipFd)) {
#line 26
              goto while_break___0;
            }
#line 27
            if (i == (int )*(dupFds + j)) {
#line 27
              closeFd = 0;
            }
#line 26
            j ++;
          }
          while_break___0: /* CIL Label */ ;
          }
#line 29
          if (closeFd) {
            {
#line 29
            close(i);
            }
          }
        }
      }
    }
#line 23
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 32
  return;
}
}
#line 48 "/home/june/repo/benchmarks/collector/temp/enigmail-1.8.2/ipc/src/subprocess.c"
pid_t launchProcess(char const   *path , char * const  *argv , char * const  *envp ,
                    char const   *workdir , int const   *fd_in , int const   *fd_out ,
                    int const   *fd_err , int const   *dupFds ) 
{ 
  pid_t pid ;
  int mergeStderr ;
  int tmp ;
  int countFd ;
  int i ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 59
  if (fd_err) {
#line 59
    tmp = 0;
  } else {
#line 59
    tmp = 1;
  }
  {
#line 59
  mergeStderr = tmp;
#line 61
  pid = fork();
  }
#line 62
  if (pid == 0) {
#line 63
    countFd = 0;
#line 66
    if (workdir) {
      {
#line 67
      tmp___0 = chdir(workdir);
      }
#line 67
      if (tmp___0 < 0) {
        {
#line 68
        _exit(126);
        }
      }
    }
    {
#line 72
    while (1) {
      while_continue: /* CIL Label */ ;
#line 72
      if (! (*(dupFds + countFd) > 0)) {
#line 72
        goto while_break;
      }
#line 73
      countFd ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 76
    if (fd_err) {
#line 76
      tmp___1 = *(fd_err + 1);
    } else {
#line 76
      tmp___1 = (int const   )0;
    }
    {
#line 76
    closeOtherFds((int )*(fd_in + 0), (int )*(fd_out + 1), (int )tmp___1, dupFds,
                  countFd);
#line 78
    close((int )*(fd_in + 1));
#line 79
    close((int )*(fd_out + 0));
    }
#line 80
    if (! mergeStderr) {
      {
#line 81
      close((int )*(fd_err + 0));
      }
    }
    {
#line 82
    close(0);
#line 83
    dup2((int )*(fd_in + 0), 0);
#line 84
    close(1);
#line 85
    dup2((int )*(fd_out + 1), 1);
#line 86
    close(2);
    }
#line 88
    if (mergeStderr) {
#line 88
      tmp___2 = *(fd_out + 1);
    } else {
#line 88
      tmp___2 = *(fd_err + 1);
    }
    {
#line 88
    dup2((int )tmp___2, 2);
#line 90
    i = 0;
    }
    {
#line 90
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 90
      if (! (i < countFd)) {
#line 90
        goto while_break___0;
      }
      {
#line 91
      dup2((int )*(dupFds + i), 3 + i);
#line 90
      i ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 94
    execve(path, argv, envp);
#line 95
    _exit(1);
    }
  }
#line 99
  return (pid);
}
}
