/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 140 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __useconds_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 44 "/usr/include/scsi/sg.h"
struct sg_io_hdr {
   int interface_id ;
   int dxfer_direction ;
   unsigned char cmd_len ;
   unsigned char mx_sb_len ;
   unsigned short iovec_count ;
   unsigned int dxfer_len ;
   void *dxferp ;
   unsigned char *cmdp ;
   unsigned char *sbp ;
   unsigned int timeout ;
   unsigned int flags ;
   int pack_id ;
   void *usr_ptr ;
   unsigned char status ;
   unsigned char masked_status ;
   unsigned char msg_status ;
   unsigned char sb_len_wr ;
   unsigned short host_status ;
   unsigned short driver_status ;
   int resid ;
   unsigned int duration ;
   unsigned int info ;
};
#line 44 "/usr/include/scsi/sg.h"
typedef struct sg_io_hdr sg_io_hdr_t;
#line 102 "/usr/include/scsi/sg.h"
struct sg_scsi_id {
   int host_no ;
   int channel ;
   int scsi_id ;
   int lun ;
   int scsi_type ;
   short h_cmd_per_lun ;
   short d_queue_depth ;
   int unused[2] ;
};
#line 93 "/home/wheatley/newnew/temp/lakai-0.1/lakai.h"
typedef int LHANDLE;
#line 105 "/home/wheatley/newnew/temp/lakai-0.1/lakai.h"
struct __anonstruct_LakaiStatus_28 {
   int osversion ;
   int nummaxblocks ;
   int numfreeblocks ;
   int nummaxsamples ;
   int numfreesamples ;
   int eoxchannel ;
};
#line 105 "/home/wheatley/newnew/temp/lakai-0.1/lakai.h"
typedef struct __anonstruct_LakaiStatus_28 LakaiStatus;
#line 118 "/home/wheatley/newnew/temp/lakai-0.1/lakai.h"
struct __anonstruct_LakaiProgramList_29 {
   int numprogs ;
   char **prognames ;
};
#line 118 "/home/wheatley/newnew/temp/lakai-0.1/lakai.h"
typedef struct __anonstruct_LakaiProgramList_29 LakaiProgramList;
#line 127 "/home/wheatley/newnew/temp/lakai-0.1/lakai.h"
struct __anonstruct_LakaiSampleList_30 {
   int numsamples ;
   char **samplenames ;
};
#line 127 "/home/wheatley/newnew/temp/lakai-0.1/lakai.h"
typedef struct __anonstruct_LakaiSampleList_30 LakaiSampleList;
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 580
extern int putchar(int __c ) ;
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 353 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 460
extern int usleep(__useconds_t __useconds ) ;
#line 146 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 66
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 41 "/usr/include/x86_64-linux-gnu/sys/ioctl.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ioctl)(int __fd ,
                                                                            unsigned long __request 
                                                                            , ...) ;
#line 580 "/home/wheatley/newnew/temp/lakai-0.1/lakai.h"
void lakai_init(void) ;
#line 597
LHANDLE lakai_open(char *devname ) ;
#line 618
int lakai_close(LHANDLE handle ) ;
#line 652
int lakai_setmode(LHANDLE handle , int mode ) ;
#line 671
void lakai_asciitoakai(char *src , char *dst , int len ) ;
#line 691
void lakai_akaitoascii(char *src , char *dst , int len ) ;
#line 788
long lakai_get_sample(LHANDLE handle , int samplenum , char *buffer , long locat ,
                      long len ) ;
#line 878
int lakai_get_status_report(LHANDLE handle , LakaiStatus *ls ) ;
#line 895
int lakai_get_program_list(LHANDLE handle , LakaiProgramList *lp ) ;
#line 912
void lakai_free_program_list(LakaiProgramList *lp ) ;
#line 929
int lakai_get_sample_list(LHANDLE handle , LakaiSampleList *ls ) ;
#line 947
void lakai_free_sample_list(LakaiSampleList *ls ) ;
#line 970
int lakai_get_program(LHANDLE handle , int prognum , unsigned char *data ) ;
#line 991
int lakai_get_keygroup(LHANDLE handle , int prognum , int keygroupnum , unsigned char *data ) ;
#line 1010
int lakai_get_sample_header(LHANDLE handle , int samplenum , unsigned char *data ) ;
#line 1030
int lakai_put_sample_header(LHANDLE handle , int samplenum , unsigned char *data ,
                            int len ) ;
#line 1049
int lakai_delete_program(LHANDLE handle , int prognum ) ;
#line 1070
int lakai_delete_keygroup(LHANDLE handle , int prognum , int kgrpnum ) ;
#line 1091
int lakai_delete_sample(LHANDLE handle , int samplenum ) ;
#line 1109
int lakai_get_miscdata(LHANDLE handle , unsigned char *data ) ;
#line 1146
int lakai_put_program(LHANDLE handle , int prognum , unsigned char *data , int len ) ;
#line 1173
int lakai_put_keygroup(LHANDLE handle , int prognum , int kgrpnum , unsigned char *data ,
                       int len ) ;
#line 1191
long lakai_put_sample(LHANDLE handle , int samplenum , char *buffer , long locat ,
                      long len ) ;
#line 34 "/home/wheatley/newnew/temp/lakai-0.1/lakai.c"
static int open_cnt  =    -1;
#line 35 "/home/wheatley/newnew/temp/lakai-0.1/lakai.c"
static int fhandles[16]  ;
#line 38
static int send_command(int sg_fd , char *cmdblk___8 , int dirflag , void *tosamp_ptr ,
                        int tosamp_len , void *fromsamp_ptr , int fromsamp_len ) ;
#line 41
static void hexprint(unsigned char *buf , int len ) ;
#line 43
static int sendrecv_scsimidi(LHANDLE handle , char *sysexblk , unsigned int sysexblksize ,
                             char *destbuf ) ;
#line 44
static int sendrecv_scsimidi2(LHANDLE handle , char *sysexblk , unsigned int sysexblksize ,
                              char *buf ) ;
#line 46
static long getbulkdata(LHANDLE handle , int numbytes , char *buf ) ;
#line 47
static long putbulkdata(LHANDLE handle , int numbytes , char *buf ) ;
#line 55 "/home/wheatley/newnew/temp/lakai-0.1/lakai.c"
void lakai_init(void) 
{ 
  int i ;

  {
#line 59
  if (open_cnt == -1) {
#line 61
    i = 0;
    {
#line 61
    while (1) {
      while_continue: /* CIL Label */ ;
#line 61
      if (! (i < 16)) {
#line 61
        goto while_break;
      }
#line 62
      fhandles[i] = -1;
#line 61
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 64
  return;
}
}
#line 71 "/home/wheatley/newnew/temp/lakai-0.1/lakai.c"
LHANDLE lakai_open(char *devname ) 
{ 
  int sg_fd ;
  int k ;
  int slotpos ;
  struct sg_scsi_id sg_scsiid ;
  int tmp ;
  int tmp___0 ;

  {
#line 77
  if (open_cnt == 15) {
    {
#line 79
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"lakai_open: Maximum open count of liblakai reached.\n");
    }
#line 80
    return (-1);
  }
#line 83
  slotpos = 0;
  {
#line 83
  while (1) {
    while_continue: /* CIL Label */ ;
#line 83
    if (! (slotpos < 16)) {
#line 83
      goto while_break;
    }
#line 85
    if (fhandles[slotpos] == -1) {
#line 86
      goto while_break;
    }
#line 83
    slotpos ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 88
  if (slotpos == 16) {
    {
#line 90
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"lakai_open: no free slot found\n");
    }
#line 91
    return (-1);
  }
  {
#line 95
  sg_fd = open((char const   *)devname, 2);
  }
#line 96
  if (sg_fd < 0) {
    {
#line 98
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"lakai_open: error opening file: %s\n",
            devname);
    }
#line 99
    return (-1);
  }
  {
#line 102
  tmp = ioctl(sg_fd, 8834UL, & k);
  }
#line 102
  if (tmp < 0) {
    {
#line 104
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unable to do ioctl() SG_GET_VERSION_NUM on sg device\n");
    }
#line 105
    return (-1);
  }
#line 108
  if (k < 30000) {
    {
#line 110
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"sg device\'s version is too old (below version 3)\n");
#line 111
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Please get a more recent kernel\n");
#line 112
    close(sg_fd);
    }
#line 113
    return (-1);
  }
  {
#line 117
  tmp___0 = ioctl(sg_fd, 8822UL, & sg_scsiid);
  }
#line 117
  if (tmp___0 < 0) {
    {
#line 119
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unable to do ioctl() SG_GET_SCSI_ID on sg device\n");
#line 120
    close(sg_fd);
    }
#line 121
    return (-1);
  }
#line 134
  if (sg_scsiid.scsi_type != 3) {
    {
#line 136
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Incorrect device type - should be a PROCESSOR device\n");
#line 137
    close(sg_fd);
    }
#line 138
    return (-1);
  }
#line 142
  open_cnt ++;
#line 143
  fhandles[slotpos] = sg_fd;
#line 145
  return (slotpos);
}
}
#line 154 "/home/wheatley/newnew/temp/lakai-0.1/lakai.c"
int lakai_close(LHANDLE handle ) 
{ 


  {
#line 156
  if (fhandles[handle] == -1) {
    {
#line 158
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"lakai_close: Bad file handle\n");
    }
#line 159
    return (-1);
  } else
#line 156
  if (handle < 0) {
    {
#line 158
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"lakai_close: Bad file handle\n");
    }
#line 159
    return (-1);
  } else
#line 156
  if (handle > 16) {
    {
#line 158
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"lakai_close: Bad file handle\n");
    }
#line 159
    return (-1);
  }
  {
#line 161
  close(fhandles[handle]);
#line 162
  fhandles[handle] = -1;
#line 163
  open_cnt --;
  }
#line 164
  return (0);
}
}
#line 175 "/home/wheatley/newnew/temp/lakai-0.1/lakai.c"
static unsigned char cmdblk[6]  = {      (unsigned char)9,      (unsigned char)0,      (unsigned char)1,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0};
#line 173 "/home/wheatley/newnew/temp/lakai-0.1/lakai.c"
int lakai_setmode(LHANDLE handle , int mode ) 
{ 
  int tmp ;

  {
#line 189
  if (mode == 0) {
#line 191
    cmdblk[2] = (unsigned char)0;
#line 192
    cmdblk[3] = (unsigned char)0;
  } else
#line 194
  if (mode == 1) {
#line 196
    cmdblk[2] = (unsigned char)1;
#line 197
    cmdblk[3] = (unsigned char)0;
  } else
#line 199
  if (mode == 2) {
#line 201
    cmdblk[2] = (unsigned char)1;
#line 202
    cmdblk[3] = (unsigned char)1;
  } else {
    {
#line 206
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Illegal mode in lakai_setmode()\n");
    }
#line 207
    return (-1);
  }
#line 210
  if (fhandles[handle] == -1) {
    {
#line 212
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"lakai_setmode: Bad file handle\n");
    }
#line 213
    return (-1);
  } else
#line 210
  if (handle < 0) {
    {
#line 212
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"lakai_setmode: Bad file handle\n");
    }
#line 213
    return (-1);
  } else
#line 210
  if (handle > 16) {
    {
#line 212
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"lakai_setmode: Bad file handle\n");
    }
#line 213
    return (-1);
  }
  {
#line 216
  tmp = send_command(fhandles[handle], (char *)(cmdblk), 1, (void *)0, 0, (void *)0,
                     0);
  }
#line 216
  if (tmp != 0) {
    {
#line 218
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"lakai_setmode() FAILED\n");
    }
#line 219
    return (-1);
  }
#line 221
  return (0);
}
}
#line 234 "/home/wheatley/newnew/temp/lakai-0.1/lakai.c"
static unsigned char cmdblk1[6]  = {      (unsigned char)240,      (unsigned char)71,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)72,      (unsigned char)247};
#line 229 "/home/wheatley/newnew/temp/lakai-0.1/lakai.c"
int lakai_get_status_report(LHANDLE handle , LakaiStatus *ls ) 
{ 
  unsigned char statusbuf[100] ;
  int statuslen ;

  {
#line 237
  if (fhandles[handle] == -1) {
    {
#line 239
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"lakai_get_status_report(): Bad file handle\n");
    }
#line 240
    return (-1);
  } else
#line 237
  if (handle < 0) {
    {
#line 239
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"lakai_get_status_report(): Bad file handle\n");
    }
#line 240
    return (-1);
  } else
#line 237
  if (handle > 16) {
    {
#line 239
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"lakai_get_status_report(): Bad file handle\n");
    }
#line 240
    return (-1);
  }
  {
#line 246
  statuslen = sendrecv_scsimidi(handle, (char *)(cmdblk1), (unsigned int )sizeof(cmdblk1),
                                (char *)(statusbuf));
  }
#line 247
  if (! (statuslen > 0)) {
    {
#line 256
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Seems there were problems in receiving..\n");
    }
  }
#line 262
  return (0);
}
}
#line 274 "/home/wheatley/newnew/temp/lakai-0.1/lakai.c"
static unsigned char cmdblk1___0[6]  = {      (unsigned char)240,      (unsigned char)71,      (unsigned char)0,      (unsigned char)2, 
        (unsigned char)72,      (unsigned char)247};
#line 269 "/home/wheatley/newnew/temp/lakai-0.1/lakai.c"
int lakai_get_program_list(LHANDLE handle , LakaiProgramList *lp ) 
{ 
  unsigned char finalbuf[2048] ;
  int i ;
  int finallen ;
  int numprogs ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 277
  if (fhandles[handle] == -1) {
    {
#line 279
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"lakai_get_program_list(): Bad file handle\n");
    }
#line 280
    return (-1);
  } else
#line 277
  if (handle < 0) {
    {
#line 279
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"lakai_get_program_list(): Bad file handle\n");
    }
#line 280
    return (-1);
  } else
#line 277
  if (handle > 16) {
    {
#line 279
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"lakai_get_program_list(): Bad file handle\n");
    }
#line 280
    return (-1);
  }
  {
#line 283
  finallen = sendrecv_scsimidi(handle, (char *)(cmdblk1___0), (unsigned int )sizeof(cmdblk1___0),
                               (char *)(finalbuf));
  }
#line 284
  if (! (finallen > 0)) {
    {
#line 293
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Seems there were problems in receiving..\n");
    }
  }
#line 296
  numprogs = (int )finalbuf[5] + 128 * (int )finalbuf[6];
#line 298
  if ((int )finalbuf[0] == 240) {
#line 298
    if ((int )*(finalbuf + 3) == 3) {
      {
#line 300
      tmp = malloc((unsigned long )numprogs * sizeof(char *));
#line 300
      lp->prognames = (char **)tmp;
      }
#line 301
      if (! lp->prognames) {
        {
#line 303
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"lakai_get_program_list(): Unable to malloc prognames\n");
        }
#line 304
        return (-1);
      }
#line 306
      i = 0;
      {
#line 306
      while (1) {
        while_continue: /* CIL Label */ ;
#line 306
        if (! (i < numprogs)) {
#line 306
          goto while_break;
        }
        {
#line 308
        tmp___0 = malloc((size_t )13);
#line 308
        *(lp->prognames + i) = (char *)tmp___0;
        }
#line 309
        if (! *(lp->prognames + i)) {
          {
#line 311
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"lakai_get_program_list(): Unable to malloc progname slot\n");
          }
#line 312
          return (-1);
        }
        {
#line 314
        lakai_akaitoascii((char *)((finalbuf + 7) + i * 12), *(lp->prognames + i),
                          12);
#line 315
        *(*(lp->prognames + i) + 12) = (char )'\000';
#line 306
        i ++;
        }
      }
      while_break: /* CIL Label */ ;
      }
#line 317
      lp->numprogs = numprogs;
    } else {
      {
#line 320
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"lakai_get_program_list(): bad answer from sampler\n");
      }
    }
  } else {
    {
#line 320
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"lakai_get_program_list(): bad answer from sampler\n");
    }
  }
#line 322
  return (numprogs);
}
}
#line 329 "/home/wheatley/newnew/temp/lakai-0.1/lakai.c"
void lakai_free_program_list(LakaiProgramList *lp ) 
{ 
  int i ;

  {
#line 333
  if (lp) {
#line 335
    if (lp->numprogs > 0) {
#line 337
      i = 0;
      {
#line 337
      while (1) {
        while_continue: /* CIL Label */ ;
#line 337
        if (! (i < lp->numprogs)) {
#line 337
          goto while_break;
        }
#line 339
        if (*(lp->prognames + i)) {
          {
#line 342
          free((void *)*(lp->prognames + i));
          }
        }
#line 337
        i ++;
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 346
      free((void *)lp->prognames);
      }
    }
  }
#line 349
  return;
}
}
#line 360 "/home/wheatley/newnew/temp/lakai-0.1/lakai.c"
static unsigned char cmdblk1___1[6]  = {      (unsigned char)240,      (unsigned char)71,      (unsigned char)0,      (unsigned char)4, 
        (unsigned char)72,      (unsigned char)247};
#line 355 "/home/wheatley/newnew/temp/lakai-0.1/lakai.c"
int lakai_get_sample_list(LHANDLE handle , LakaiSampleList *ls ) 
{ 
  unsigned char finalbuf[2048] ;
  int i ;
  int finallen ;
  int numsamples ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 363
  if (fhandles[handle] == -1) {
    {
#line 365
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"lakai_get_sample_list(): Bad file handle\n");
    }
#line 366
    return (-1);
  } else
#line 363
  if (handle < 0) {
    {
#line 365
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"lakai_get_sample_list(): Bad file handle\n");
    }
#line 366
    return (-1);
  } else
#line 363
  if (handle > 16) {
    {
#line 365
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"lakai_get_sample_list(): Bad file handle\n");
    }
#line 366
    return (-1);
  }
  {
#line 369
  finallen = sendrecv_scsimidi(handle, (char *)(cmdblk1___1), (unsigned int )sizeof(cmdblk1___1),
                               (char *)(finalbuf));
  }
#line 370
  if (! (finallen > 0)) {
    {
#line 379
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Seems there were problems in receiving..\n");
    }
  }
#line 382
  numsamples = (int )finalbuf[5] + 128 * (int )finalbuf[6];
#line 384
  if ((int )finalbuf[0] == 240) {
#line 384
    if ((int )*(finalbuf + 3) == 5) {
      {
#line 386
      tmp = malloc((unsigned long )numsamples * sizeof(char *));
#line 386
      ls->samplenames = (char **)tmp;
      }
#line 387
      if (! ls->samplenames) {
        {
#line 389
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"lakai_get_sample_list(): Unable to malloc samplenames\n");
        }
#line 390
        return (-1);
      }
#line 392
      i = 0;
      {
#line 392
      while (1) {
        while_continue: /* CIL Label */ ;
#line 392
        if (! (i < numsamples)) {
#line 392
          goto while_break;
        }
        {
#line 394
        tmp___0 = malloc((size_t )13);
#line 394
        *(ls->samplenames + i) = (char *)tmp___0;
        }
#line 395
        if (! *(ls->samplenames + i)) {
          {
#line 397
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"lakai_get_sample_list(): Unable to malloc samplename slot\n");
          }
#line 398
          return (-1);
        }
        {
#line 400
        lakai_akaitoascii((char *)((finalbuf + 7) + i * 12), *(ls->samplenames + i),
                          12);
#line 401
        *(*(ls->samplenames + i) + 12) = (char )'\000';
#line 392
        i ++;
        }
      }
      while_break: /* CIL Label */ ;
      }
#line 403
      ls->numsamples = numsamples;
    } else {
      {
#line 407
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"lakai_get_sample_list(): bad answer from sampler\n");
      }
#line 408
      return (-1);
    }
  } else {
    {
#line 407
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"lakai_get_sample_list(): bad answer from sampler\n");
    }
#line 408
    return (-1);
  }
#line 411
  return (numsamples);
}
}
#line 418 "/home/wheatley/newnew/temp/lakai-0.1/lakai.c"
void lakai_free_sample_list(LakaiSampleList *ls ) 
{ 
  int i ;

  {
#line 422
  if (ls) {
#line 424
    if (ls->numsamples > 0) {
#line 426
      i = 0;
      {
#line 426
      while (1) {
        while_continue: /* CIL Label */ ;
#line 426
        if (! (i < ls->numsamples)) {
#line 426
          goto while_break;
        }
#line 428
        if (*(ls->samplenames + i)) {
          {
#line 431
          free((void *)*(ls->samplenames + i));
          }
        }
#line 426
        i ++;
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 435
      free((void *)ls->samplenames);
      }
    }
  }
#line 438
  return;
}
}
#line 452 "/home/wheatley/newnew/temp/lakai-0.1/lakai.c"
static unsigned char cmdblk1___2[8]  = 
#line 452
  {      (unsigned char)240,      (unsigned char)71,      (unsigned char)0,      (unsigned char)6, 
        (unsigned char)72,      (unsigned char)0,      (unsigned char)0,      (unsigned char)247};
#line 447 "/home/wheatley/newnew/temp/lakai-0.1/lakai.c"
int lakai_get_program(LHANDLE handle , int prognum , unsigned char *data ) 
{ 
  unsigned char finalbuf[1024] ;
  int i ;
  int finallen ;
  int numvals ;

  {
#line 457
  if (fhandles[handle] == -1) {
    {
#line 459
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"lakai_get_program(): Bad file handle\n");
    }
#line 460
    return (-1);
  } else
#line 457
  if (handle < 0) {
    {
#line 459
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"lakai_get_program(): Bad file handle\n");
    }
#line 460
    return (-1);
  } else
#line 457
  if (handle > 16) {
    {
#line 459
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"lakai_get_program(): Bad file handle\n");
    }
#line 460
    return (-1);
  }
#line 463
  if (prognum < 0) {
    {
#line 465
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"lakai_get_program(): Illegal program number\n");
    }
#line 466
    return (-1);
  } else
#line 463
  if (prognum > 16383) {
    {
#line 465
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"lakai_get_program(): Illegal program number\n");
    }
#line 466
    return (-1);
  }
  {
#line 469
  cmdblk1___2[6] = (unsigned char )(prognum / 128);
#line 470
  cmdblk1___2[5] = (unsigned char )(prognum - (int )cmdblk1___2[6] * 128);
#line 472
  finallen = sendrecv_scsimidi(handle, (char *)(cmdblk1___2), (unsigned int )sizeof(cmdblk1___2),
                               (char *)(finalbuf));
  }
#line 473
  if (finallen <= 0) {
    {
#line 475
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Seems there were problems in receiving..\n");
    }
#line 476
    return (-1);
  }
#line 484
  numvals = (finallen - 8) / 2;
#line 485
  i = 0;
  {
#line 485
  while (1) {
    while_continue: /* CIL Label */ ;
#line 485
    if (! (i < numvals)) {
#line 485
      goto while_break;
    }
#line 487
    *(data + i) = (unsigned char )((int )finalbuf[7 + i * 2] | ((int )finalbuf[(7 + i * 2) + 1] << 4));
#line 485
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 535
  return (numvals);
}
}
#line 550 "/home/wheatley/newnew/temp/lakai-0.1/lakai.c"
static unsigned char cmdblk1___3[9]  = 
#line 550
  {      (unsigned char)240,      (unsigned char)71,      (unsigned char)0,      (unsigned char)8, 
        (unsigned char)72,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)247};
#line 545 "/home/wheatley/newnew/temp/lakai-0.1/lakai.c"
int lakai_get_keygroup(LHANDLE handle , int prognum , int keygroupnum , unsigned char *data ) 
{ 
  unsigned char finalbuf[1024] ;
  int i ;
  int finallen ;
  int numvals ;

  {
#line 557
  if (fhandles[handle] == -1) {
    {
#line 559
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"lakai_get_keygroup(): Bad file handle\n");
    }
#line 560
    return (-1);
  } else
#line 557
  if (handle < 0) {
    {
#line 559
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"lakai_get_keygroup(): Bad file handle\n");
    }
#line 560
    return (-1);
  } else
#line 557
  if (handle > 16) {
    {
#line 559
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"lakai_get_keygroup(): Bad file handle\n");
    }
#line 560
    return (-1);
  }
#line 563
  if (prognum < 0) {
    {
#line 565
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"lakai_get_keygroup(): Illegal program number\n");
    }
#line 566
    return (-1);
  } else
#line 563
  if (prognum > 16383) {
    {
#line 565
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"lakai_get_keygroup(): Illegal program number\n");
    }
#line 566
    return (-1);
  }
#line 569
  cmdblk1___3[6] = (unsigned char )(prognum / 128);
#line 570
  cmdblk1___3[5] = (unsigned char )(prognum - (int )cmdblk1___3[6] * 128);
#line 572
  if (keygroupnum < 0) {
    {
#line 574
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"lakai_get_keygroup(): Illegal keygroup number\n");
    }
#line 575
    return (-1);
  } else
#line 572
  if (keygroupnum > 99) {
    {
#line 574
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"lakai_get_keygroup(): Illegal keygroup number\n");
    }
#line 575
    return (-1);
  }
  {
#line 578
  cmdblk1___3[7] = (unsigned char )keygroupnum;
#line 580
  finallen = sendrecv_scsimidi(handle, (char *)(cmdblk1___3), (unsigned int )sizeof(cmdblk1___3),
                               (char *)(finalbuf));
  }
#line 581
  if (finallen <= 0) {
    {
#line 583
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Seems there were problems in receiving..\n");
    }
#line 584
    return (-1);
  }
#line 592
  numvals = (finallen - 9) / 2;
#line 593
  i = 0;
  {
#line 593
  while (1) {
    while_continue: /* CIL Label */ ;
#line 593
    if (! (i < numvals)) {
#line 593
      goto while_break;
    }
#line 595
    *(data + i) = (unsigned char )((int )finalbuf[8 + i * 2] | ((int )finalbuf[(8 + i * 2) + 1] << 4));
#line 593
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 603
  return (numvals);
}
}
#line 621 "/home/wheatley/newnew/temp/lakai-0.1/lakai.c"
static unsigned char cmdblk1___4[8]  = 
#line 621
  {      (unsigned char)240,      (unsigned char)71,      (unsigned char)0,      (unsigned char)10, 
        (unsigned char)72,      (unsigned char)0,      (unsigned char)0,      (unsigned char)247};
#line 616 "/home/wheatley/newnew/temp/lakai-0.1/lakai.c"
int lakai_get_sample_header(LHANDLE handle , int samplenum , unsigned char *data ) 
{ 
  unsigned char finalbuf[1024] ;
  int i ;
  int finallen ;
  int numvals ;

  {
#line 628
  if (fhandles[handle] == -1) {
    {
#line 630
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"lakai_get_sample_header(): Bad file handle\n");
    }
#line 631
    return (-1);
  } else
#line 628
  if (handle < 0) {
    {
#line 630
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"lakai_get_sample_header(): Bad file handle\n");
    }
#line 631
    return (-1);
  } else
#line 628
  if (handle > 16) {
    {
#line 630
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"lakai_get_sample_header(): Bad file handle\n");
    }
#line 631
    return (-1);
  }
#line 634
  if (samplenum < 0) {
    {
#line 636
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"lakai_get_sample_header(): Illegal sample number\n");
    }
#line 637
    return (-1);
  } else
#line 634
  if (samplenum > 16383) {
    {
#line 636
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"lakai_get_sample_header(): Illegal sample number\n");
    }
#line 637
    return (-1);
  }
  {
#line 640
  cmdblk1___4[6] = (unsigned char )(samplenum / 128);
#line 641
  cmdblk1___4[5] = (unsigned char )(samplenum - (int )cmdblk1___4[6] * 128);
#line 643
  finallen = sendrecv_scsimidi(handle, (char *)(cmdblk1___4), (unsigned int )sizeof(cmdblk1___4),
                               (char *)(finalbuf));
  }
#line 644
  if (finallen <= 0) {
    {
#line 646
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Seems there were problems in receiving..\n");
    }
#line 647
    return (-1);
  }
#line 655
  numvals = (finallen - 8) / 2;
#line 656
  i = 0;
  {
#line 656
  while (1) {
    while_continue: /* CIL Label */ ;
#line 656
    if (! (i < numvals)) {
#line 656
      goto while_break;
    }
#line 658
    *(data + i) = (unsigned char )((int )finalbuf[7 + i * 2] | ((int )finalbuf[(7 + i * 2) + 1] << 4));
#line 656
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 673
  return (numvals);
}
}
#line 693 "/home/wheatley/newnew/temp/lakai-0.1/lakai.c"
static unsigned char cmdblk1___5[7]  = {      (unsigned char)240,      (unsigned char)71,      (unsigned char)0,      (unsigned char)11, 
        (unsigned char)72,      (unsigned char)0,      (unsigned char)0};
#line 687 "/home/wheatley/newnew/temp/lakai-0.1/lakai.c"
int lakai_put_sample_header(LHANDLE handle , int samplenum , unsigned char *data ,
                            int len ) 
{ 
  unsigned char finalbuf[1024] ;
  unsigned char resbuf[1024] ;
  int i ;
  int finallen ;
  int numvals ;

  {
#line 700
  if (fhandles[handle] == -1) {
    {
#line 702
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"lakai_put_sample_header(): Bad file handle\n");
    }
#line 703
    return (-1);
  } else
#line 700
  if (handle < 0) {
    {
#line 702
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"lakai_put_sample_header(): Bad file handle\n");
    }
#line 703
    return (-1);
  } else
#line 700
  if (handle > 16) {
    {
#line 702
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"lakai_put_sample_header(): Bad file handle\n");
    }
#line 703
    return (-1);
  }
#line 706
  if (samplenum < 0) {
    {
#line 708
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"lakai_put_sample_header(): Illegal sample number\n");
    }
#line 709
    return (-1);
  } else
#line 706
  if (samplenum > 16383) {
    {
#line 708
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"lakai_put_sample_header(): Illegal sample number\n");
    }
#line 709
    return (-1);
  }
  {
#line 712
  cmdblk1___5[6] = (unsigned char )(samplenum / 128);
#line 713
  cmdblk1___5[5] = (unsigned char )(samplenum - (int )cmdblk1___5[6] * 128);
#line 716
  memcpy((void */* __restrict  */)(finalbuf), (void const   */* __restrict  */)(cmdblk1___5),
         sizeof(cmdblk1___5));
#line 718
  i = 0;
  }
  {
#line 718
  while (1) {
    while_continue: /* CIL Label */ ;
#line 718
    if (! (i < len)) {
#line 718
      goto while_break;
    }
#line 720
    finalbuf[sizeof(cmdblk1___5) + (unsigned long )(i * 2)] = (unsigned char )((int )*(data + i) & 15);
#line 721
    finalbuf[(sizeof(cmdblk1___5) + (unsigned long )(i * 2)) + 1UL] = (unsigned char )(((int )*(data + i) & 240) >> 4);
#line 718
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 723
  finalbuf[sizeof(cmdblk1___5) + (unsigned long )(2 * len)] = (unsigned char)247;
#line 726
  finallen = sendrecv_scsimidi(handle, (char *)(finalbuf), (unsigned int )((sizeof(cmdblk1___5) + (unsigned long )(len * 2)) + 1UL),
                               (char *)(resbuf));
  }
#line 728
  if (finallen <= 0) {
    {
#line 730
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Seems there were problems in receiving..\n");
    }
#line 731
    return (-1);
  }
#line 735
  return (numvals);
}
}
#line 747 "/home/wheatley/newnew/temp/lakai-0.1/lakai.c"
static unsigned char cmdblk1___6[8]  = 
#line 747
  {      (unsigned char)240,      (unsigned char)71,      (unsigned char)0,      (unsigned char)18, 
        (unsigned char)72,      (unsigned char)0,      (unsigned char)0,      (unsigned char)247};
#line 742 "/home/wheatley/newnew/temp/lakai-0.1/lakai.c"
int lakai_delete_program(LHANDLE handle , int prognum ) 
{ 
  unsigned char statusbuf[100] ;
  int statuslen ;

  {
#line 750
  if (fhandles[handle] == -1) {
    {
#line 752
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"lakai_delete_program(): Bad file handle\n");
    }
#line 753
    return (-1);
  } else
#line 750
  if (handle < 0) {
    {
#line 752
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"lakai_delete_program(): Bad file handle\n");
    }
#line 753
    return (-1);
  } else
#line 750
  if (handle > 16) {
    {
#line 752
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"lakai_delete_program(): Bad file handle\n");
    }
#line 753
    return (-1);
  }
#line 756
  if (prognum < 0) {
    {
#line 758
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"lakai_delete_program(): Illegal program number\n");
    }
#line 759
    return (-1);
  } else
#line 756
  if (prognum > 16383) {
    {
#line 758
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"lakai_delete_program(): Illegal program number\n");
    }
#line 759
    return (-1);
  }
  {
#line 762
  cmdblk1___6[6] = (unsigned char )(prognum / 128);
#line 763
  cmdblk1___6[5] = (unsigned char )(prognum - (int )cmdblk1___6[6] * 128);
#line 765
  statuslen = sendrecv_scsimidi(handle, (char *)(cmdblk1___6), (unsigned int )sizeof(cmdblk1___6),
                                (char *)(statusbuf));
  }
#line 767
  if (! (statuslen > 0)) {
    {
#line 776
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Seems there were problems in receiving..\n");
    }
  }
#line 779
  return (0);
}
}
#line 792 "/home/wheatley/newnew/temp/lakai-0.1/lakai.c"
static unsigned char cmdblk1___7[9]  = 
#line 792
  {      (unsigned char)240,      (unsigned char)71,      (unsigned char)0,      (unsigned char)19, 
        (unsigned char)72,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)247};
#line 787 "/home/wheatley/newnew/temp/lakai-0.1/lakai.c"
int lakai_delete_keygroup(LHANDLE handle , int prognum , int kgrpnum ) 
{ 
  unsigned char statusbuf[100] ;
  int statuslen ;

  {
#line 795
  if (fhandles[handle] == -1) {
    {
#line 797
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"lakai_delete_keygroup(): Bad file handle\n");
    }
#line 798
    return (-1);
  } else
#line 795
  if (handle < 0) {
    {
#line 797
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"lakai_delete_keygroup(): Bad file handle\n");
    }
#line 798
    return (-1);
  } else
#line 795
  if (handle > 16) {
    {
#line 797
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"lakai_delete_keygroup(): Bad file handle\n");
    }
#line 798
    return (-1);
  }
#line 801
  if (prognum < 0) {
    {
#line 803
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"lakai_delete_keygroup(): Illegal program number\n");
    }
#line 804
    return (-1);
  } else
#line 801
  if (prognum > 16383) {
    {
#line 803
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"lakai_delete_keygroup(): Illegal program number\n");
    }
#line 804
    return (-1);
  }
#line 807
  if (kgrpnum < 0) {
    {
#line 809
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"lakai_delete_keygroup(): Illegal keygroup number\n");
    }
#line 810
    return (-1);
  } else
#line 807
  if (kgrpnum > 99) {
    {
#line 809
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"lakai_delete_keygroup(): Illegal keygroup number\n");
    }
#line 810
    return (-1);
  }
  {
#line 812
  cmdblk1___7[6] = (unsigned char )(prognum / 128);
#line 813
  cmdblk1___7[5] = (unsigned char )(prognum - (int )cmdblk1___7[6] * 128);
#line 815
  cmdblk1___7[7] = (unsigned char )kgrpnum;
#line 817
  statuslen = sendrecv_scsimidi(handle, (char *)(cmdblk1___7), (unsigned int )sizeof(cmdblk1___7),
                                (char *)(statusbuf));
  }
#line 819
  if (! (statuslen > 0)) {
    {
#line 828
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Seems there were problems in receiving..\n");
    }
  }
#line 831
  return (0);
}
}
#line 846 "/home/wheatley/newnew/temp/lakai-0.1/lakai.c"
static unsigned char cmdblk1___8[8]  = 
#line 846
  {      (unsigned char)240,      (unsigned char)71,      (unsigned char)0,      (unsigned char)20, 
        (unsigned char)72,      (unsigned char)0,      (unsigned char)0,      (unsigned char)247};
#line 841 "/home/wheatley/newnew/temp/lakai-0.1/lakai.c"
int lakai_delete_sample(LHANDLE handle , int samplenum ) 
{ 
  unsigned char statusbuf[100] ;
  int statuslen ;

  {
#line 849
  if (fhandles[handle] == -1) {
    {
#line 851
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"lakai_delete_sample(): Bad file handle\n");
    }
#line 852
    return (-1);
  } else
#line 849
  if (handle < 0) {
    {
#line 851
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"lakai_delete_sample(): Bad file handle\n");
    }
#line 852
    return (-1);
  } else
#line 849
  if (handle > 16) {
    {
#line 851
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"lakai_delete_sample(): Bad file handle\n");
    }
#line 852
    return (-1);
  }
#line 855
  if (samplenum < 0) {
    {
#line 857
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"lakai_delete_sample(): Illegal sample number\n");
    }
#line 858
    return (-1);
  } else
#line 855
  if (samplenum > 16383) {
    {
#line 857
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"lakai_delete_sample(): Illegal sample number\n");
    }
#line 858
    return (-1);
  }
  {
#line 861
  cmdblk1___8[6] = (unsigned char )(samplenum / 128);
#line 862
  cmdblk1___8[5] = (unsigned char )(samplenum - (int )cmdblk1___8[6] * 128);
#line 864
  statuslen = sendrecv_scsimidi(handle, (char *)(cmdblk1___8), (unsigned int )sizeof(cmdblk1___8),
                                (char *)(statusbuf));
  }
#line 866
  if (! (statuslen > 0)) {
    {
#line 875
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Seems there were problems in receiving..\n");
    }
  }
#line 878
  return (0);
}
}
#line 887 "/home/wheatley/newnew/temp/lakai-0.1/lakai.c"
long lakai_get_sample(LHANDLE handle , int samplenum , char *buffer , long locat ,
                      long len ) 
{ 
  int availbytes ;
  int stilltoget ;
  int getnow ;
  int ret ;
  unsigned char statusbuf[100] ;
  unsigned char *ptr ;
  unsigned char cmdblk1___44[18] ;
  long tmp ;

  {
#line 892
  cmdblk1___44[0] = (unsigned char)240;
#line 892
  cmdblk1___44[1] = (unsigned char)71;
#line 892
  cmdblk1___44[2] = (unsigned char)0;
#line 892
  cmdblk1___44[3] = (unsigned char)12;
#line 892
  cmdblk1___44[4] = (unsigned char)72;
#line 892
  cmdblk1___44[5] = (unsigned char)0;
#line 892
  cmdblk1___44[6] = (unsigned char)0;
#line 892
  cmdblk1___44[7] = (unsigned char)0;
#line 892
  cmdblk1___44[8] = (unsigned char)0;
#line 892
  cmdblk1___44[9] = (unsigned char)0;
#line 892
  cmdblk1___44[10] = (unsigned char)0;
#line 892
  cmdblk1___44[11] = (unsigned char)0;
#line 892
  cmdblk1___44[12] = (unsigned char)0;
#line 892
  cmdblk1___44[13] = (unsigned char)0;
#line 892
  cmdblk1___44[14] = (unsigned char)0;
#line 892
  cmdblk1___44[15] = (unsigned char)1;
#line 892
  cmdblk1___44[16] = (unsigned char)0;
#line 892
  cmdblk1___44[17] = (unsigned char)247;
#line 900
  if (fhandles[handle] == -1) {
    {
#line 902
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"lakai_get_sample: Bad file handle\n");
    }
#line 903
    return (-1L);
  } else
#line 900
  if (handle < 0) {
    {
#line 902
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"lakai_get_sample: Bad file handle\n");
    }
#line 903
    return (-1L);
  } else
#line 900
  if (handle > 16) {
    {
#line 902
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"lakai_get_sample: Bad file handle\n");
    }
#line 903
    return (-1L);
  }
  {
#line 907
  cmdblk1___44[5] = (unsigned char )(samplenum & 127);
#line 908
  cmdblk1___44[6] = (unsigned char )((samplenum >> 7) & 127);
#line 911
  cmdblk1___44[7] = (unsigned char )(locat & 127L);
#line 912
  cmdblk1___44[8] = (unsigned char )((locat >> 7) & 127L);
#line 913
  cmdblk1___44[9] = (unsigned char )((locat >> 14) & 127L);
#line 914
  cmdblk1___44[10] = (unsigned char )((locat >> 21) & 127L);
#line 916
  cmdblk1___44[11] = (unsigned char )(len & 127L);
#line 917
  cmdblk1___44[12] = (unsigned char )((len >> 7) & 127L);
#line 918
  cmdblk1___44[13] = (unsigned char )((len >> 14) & 127L);
#line 919
  cmdblk1___44[14] = (unsigned char )((len >> 21) & 127L);
#line 921
  lakai_setmode(handle, 2);
#line 923
  availbytes = sendrecv_scsimidi2(handle, (char *)(cmdblk1___44), (unsigned int )sizeof(cmdblk1___44),
                                  (char *)(statusbuf));
  }
#line 924
  if (! (availbytes > 0)) {
    {
#line 932
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Seems there were problems in receiving..\n");
    }
  }
#line 935
  stilltoget = availbytes;
#line 936
  ptr = (unsigned char *)buffer;
  {
#line 937
  while (1) {
    while_continue: /* CIL Label */ ;
#line 937
    if (! (stilltoget > 0)) {
#line 937
      goto while_break;
    }
#line 939
    if (stilltoget < 65534) {
#line 940
      getnow = stilltoget;
    } else {
#line 942
      getnow = 65534;
    }
    {
#line 943
    tmp = getbulkdata(handle, getnow, (char *)ptr);
#line 943
    ret = (int )tmp;
#line 947
    stilltoget -= getnow;
#line 948
    ptr += getnow;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 951
  lakai_setmode(handle, 0);
  }
#line 953
  return (0L);
}
}
#line 965 "/home/wheatley/newnew/temp/lakai-0.1/lakai.c"
static unsigned char cmdblk1___9[6]  = {      (unsigned char)240,      (unsigned char)71,      (unsigned char)0,      (unsigned char)16, 
        (unsigned char)72,      (unsigned char)247};
#line 960 "/home/wheatley/newnew/temp/lakai-0.1/lakai.c"
int lakai_get_miscdata(LHANDLE handle , unsigned char *data ) 
{ 
  unsigned char finalbuf[1024] ;
  int i ;
  int finallen ;
  int numvals ;

  {
#line 968
  if (fhandles[handle] == -1) {
    {
#line 970
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"lakai_get_get_miscata(): Bad file handle\n");
    }
#line 971
    return (-1);
  } else
#line 968
  if (handle < 0) {
    {
#line 970
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"lakai_get_get_miscata(): Bad file handle\n");
    }
#line 971
    return (-1);
  } else
#line 968
  if (handle > 16) {
    {
#line 970
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"lakai_get_get_miscata(): Bad file handle\n");
    }
#line 971
    return (-1);
  }
  {
#line 974
  finallen = sendrecv_scsimidi(handle, (char *)(cmdblk1___9), (unsigned int )sizeof(cmdblk1___9),
                               (char *)(finalbuf));
  }
#line 975
  if (finallen <= 0) {
    {
#line 977
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Seems there were problems in receiving..\n");
    }
#line 978
    return (-1);
  }
#line 986
  numvals = (finallen - 6) / 2;
#line 987
  i = 0;
  {
#line 987
  while (1) {
    while_continue: /* CIL Label */ ;
#line 987
    if (! (i < numvals)) {
#line 987
      goto while_break;
    }
#line 989
    *(data + i) = (unsigned char )((int )finalbuf[5 + i * 2] | ((int )finalbuf[(5 + i * 2) + 1] << 4));
#line 987
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 997
  return (numvals);
}
}
#line 1011 "/home/wheatley/newnew/temp/lakai-0.1/lakai.c"
static unsigned char cmdblk1___10[7]  = {      (unsigned char)240,      (unsigned char)71,      (unsigned char)0,      (unsigned char)7, 
        (unsigned char)72,      (unsigned char)0,      (unsigned char)0};
#line 1005 "/home/wheatley/newnew/temp/lakai-0.1/lakai.c"
int lakai_put_program(LHANDLE handle , int prognum , unsigned char *data , int len ) 
{ 
  unsigned char finalbuf[1024] ;
  unsigned char resbuf[128] ;
  int i ;
  int finallen ;

  {
#line 1017
  if (fhandles[handle] == -1) {
    {
#line 1019
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"lakai_put_program(): Bad file handle\n");
    }
#line 1020
    return (-1);
  } else
#line 1017
  if (handle < 0) {
    {
#line 1019
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"lakai_put_program(): Bad file handle\n");
    }
#line 1020
    return (-1);
  } else
#line 1017
  if (handle > 16) {
    {
#line 1019
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"lakai_put_program(): Bad file handle\n");
    }
#line 1020
    return (-1);
  }
#line 1023
  if (prognum < 0) {
    {
#line 1025
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"lakai_put_program(): Illegal program number\n");
    }
#line 1026
    return (-1);
  } else
#line 1023
  if (prognum > 16383) {
    {
#line 1025
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"lakai_put_program(): Illegal program number\n");
    }
#line 1026
    return (-1);
  }
  {
#line 1034
  cmdblk1___10[6] = (unsigned char )(prognum / 128);
#line 1035
  cmdblk1___10[5] = (unsigned char )(prognum - (int )cmdblk1___10[6] * 128);
#line 1038
  memcpy((void */* __restrict  */)(finalbuf), (void const   */* __restrict  */)(cmdblk1___10),
         sizeof(cmdblk1___10));
#line 1040
  i = 0;
  }
  {
#line 1040
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1040
    if (! (i < len)) {
#line 1040
      goto while_break;
    }
#line 1042
    finalbuf[sizeof(cmdblk1___10) + (unsigned long )(i * 2)] = (unsigned char )((int )*(data + i) & 15);
#line 1043
    finalbuf[(sizeof(cmdblk1___10) + (unsigned long )(i * 2)) + 1UL] = (unsigned char )(((int )*(data + i) & 240) >> 4);
#line 1040
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1045
  finalbuf[sizeof(cmdblk1___10) + (unsigned long )(2 * len)] = (unsigned char)247;
#line 1052
  finallen = sendrecv_scsimidi(handle, (char *)(finalbuf), (unsigned int )((sizeof(cmdblk1___10) + (unsigned long )(len * 2)) + 1UL),
                               (char *)(resbuf));
  }
#line 1053
  if (finallen <= 0) {
    {
#line 1055
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"lakai_put_program(): Seems there were problems in receiving..\n");
    }
#line 1056
    return (-1);
  }
#line 1065
  return (0);
}
}
#line 1082 "/home/wheatley/newnew/temp/lakai-0.1/lakai.c"
static unsigned char cmdblk1___11[8]  = 
#line 1082
  {      (unsigned char)240,      (unsigned char)71,      (unsigned char)0,      (unsigned char)9, 
        (unsigned char)72,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0};
#line 1076 "/home/wheatley/newnew/temp/lakai-0.1/lakai.c"
int lakai_put_keygroup(LHANDLE handle , int prognum , int kgrpnum , unsigned char *data ,
                       int len ) 
{ 
  unsigned char finalbuf[1024] ;
  unsigned char resbuf[128] ;
  int i ;
  int finallen ;

  {
#line 1090
  if (fhandles[handle] == -1) {
    {
#line 1092
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"lakai_put_keygroup(): Bad file handle\n");
    }
#line 1093
    return (-1);
  } else
#line 1090
  if (handle < 0) {
    {
#line 1092
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"lakai_put_keygroup(): Bad file handle\n");
    }
#line 1093
    return (-1);
  } else
#line 1090
  if (handle > 16) {
    {
#line 1092
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"lakai_put_keygroup(): Bad file handle\n");
    }
#line 1093
    return (-1);
  }
#line 1096
  if (prognum < 0) {
    {
#line 1098
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"lakai_put_keygroup(): Illegal program number\n");
    }
#line 1099
    return (-1);
  } else
#line 1096
  if (prognum > 16383) {
    {
#line 1098
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"lakai_put_keygroup(): Illegal program number\n");
    }
#line 1099
    return (-1);
  }
#line 1102
  if (kgrpnum > 255) {
    {
#line 1104
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"lakai_put_keygroup(): Illegal keygroup number\n");
    }
#line 1105
    return (-1);
  }
  {
#line 1113
  cmdblk1___11[6] = (unsigned char )(prognum / 128);
#line 1114
  cmdblk1___11[5] = (unsigned char )(prognum - (int )cmdblk1___11[6] * 128);
#line 1116
  cmdblk1___11[7] = (unsigned char )kgrpnum;
#line 1119
  memcpy((void */* __restrict  */)(finalbuf), (void const   */* __restrict  */)(cmdblk1___11),
         sizeof(cmdblk1___11));
#line 1121
  i = 0;
  }
  {
#line 1121
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1121
    if (! (i < len)) {
#line 1121
      goto while_break;
    }
#line 1123
    finalbuf[sizeof(cmdblk1___11) + (unsigned long )(i * 2)] = (unsigned char )((int )*(data + i) & 15);
#line 1124
    finalbuf[(sizeof(cmdblk1___11) + (unsigned long )(i * 2)) + 1UL] = (unsigned char )(((int )*(data + i) & 240) >> 4);
#line 1121
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1126
  finalbuf[sizeof(cmdblk1___11) + (unsigned long )(2 * len)] = (unsigned char)247;
#line 1133
  finallen = sendrecv_scsimidi(handle, (char *)(finalbuf), (unsigned int )((sizeof(cmdblk1___11) + (unsigned long )(len * 2)) + 1UL),
                               (char *)(resbuf));
  }
#line 1134
  if (finallen <= 0) {
    {
#line 1136
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"lakai_put_keygroup(): Seems there were problems in receiving..\n");
    }
#line 1137
    return (-1);
  }
#line 1139
  return (0);
}
}
#line 1150 "/home/wheatley/newnew/temp/lakai-0.1/lakai.c"
long lakai_put_sample(LHANDLE handle , int samplenum , char *buffer , long locat ,
                      long len ) 
{ 
  int availbytes ;
  int stilltoput ;
  int putnow ;
  int ret ;
  unsigned char statusbuf[100] ;
  unsigned char *ptr ;
  int len_samples ;
  unsigned char cmdblk1___44[16] ;
  long tmp ;

  {
#line 1155
  len_samples = (int )(len / 2L);
#line 1156
  cmdblk1___44[0] = (unsigned char)240;
#line 1156
  cmdblk1___44[1] = (unsigned char)71;
#line 1156
  cmdblk1___44[2] = (unsigned char)0;
#line 1156
  cmdblk1___44[3] = (unsigned char)13;
#line 1156
  cmdblk1___44[4] = (unsigned char)72;
#line 1156
  cmdblk1___44[5] = (unsigned char)0;
#line 1156
  cmdblk1___44[6] = (unsigned char)0;
#line 1156
  cmdblk1___44[7] = (unsigned char)0;
#line 1156
  cmdblk1___44[8] = (unsigned char)0;
#line 1156
  cmdblk1___44[9] = (unsigned char)0;
#line 1156
  cmdblk1___44[10] = (unsigned char)0;
#line 1156
  cmdblk1___44[11] = (unsigned char)0;
#line 1156
  cmdblk1___44[12] = (unsigned char)0;
#line 1156
  cmdblk1___44[13] = (unsigned char)0;
#line 1156
  cmdblk1___44[14] = (unsigned char)0;
#line 1156
  cmdblk1___44[15] = (unsigned char)247;
#line 1166
  if (fhandles[handle] == -1) {
    {
#line 1168
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"lakai_put_sample: Bad file handle\n");
    }
#line 1169
    return (-1L);
  } else
#line 1166
  if (handle < 0) {
    {
#line 1168
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"lakai_put_sample: Bad file handle\n");
    }
#line 1169
    return (-1L);
  } else
#line 1166
  if (handle > 16) {
    {
#line 1168
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"lakai_put_sample: Bad file handle\n");
    }
#line 1169
    return (-1L);
  }
  {
#line 1173
  cmdblk1___44[5] = (unsigned char )(samplenum & 127);
#line 1174
  cmdblk1___44[6] = (unsigned char )((samplenum >> 7) & 127);
#line 1177
  cmdblk1___44[7] = (unsigned char )(locat & 127L);
#line 1178
  cmdblk1___44[8] = (unsigned char )((locat >> 7) & 127L);
#line 1179
  cmdblk1___44[9] = (unsigned char )((locat >> 14) & 127L);
#line 1180
  cmdblk1___44[10] = (unsigned char )((locat >> 21) & 127L);
#line 1182
  cmdblk1___44[11] = (unsigned char )(len_samples & 127);
#line 1183
  cmdblk1___44[12] = (unsigned char )((len_samples >> 7) & 127);
#line 1184
  cmdblk1___44[13] = (unsigned char )((len_samples >> 14) & 127);
#line 1185
  cmdblk1___44[14] = (unsigned char )((len_samples >> 21) & 127);
#line 1188
  lakai_setmode(handle, 2);
#line 1190
  availbytes = sendrecv_scsimidi2(handle, (char *)(cmdblk1___44), (unsigned int )sizeof(cmdblk1___44),
                                  (char *)(statusbuf));
#line 1207
  usleep((__useconds_t )100000);
#line 1209
  stilltoput = (int )len;
#line 1210
  ptr = (unsigned char *)buffer;
  }
  {
#line 1211
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1211
    if (! (stilltoput > 0)) {
#line 1211
      goto while_break;
    }
#line 1213
    if (stilltoput < 65534) {
#line 1214
      putnow = stilltoput;
    } else {
#line 1216
      putnow = 65534;
    }
    {
#line 1217
    tmp = putbulkdata(handle, putnow, (char *)ptr);
#line 1217
    ret = (int )tmp;
#line 1219
    stilltoput -= putnow;
#line 1220
    ptr += putnow;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1223
  lakai_setmode(handle, 0);
  }
#line 1225
  return (0L);
}
}
#line 1235 "/home/wheatley/newnew/temp/lakai-0.1/lakai.c"
void lakai_asciitoakai(char *src , char *dst , int len ) 
{ 
  int i ;
  unsigned char val_in ;
  unsigned char val_out ;

  {
#line 1239
  i = 0;
  {
#line 1239
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1239
    if (! (i < len)) {
#line 1239
      goto while_break;
    }
#line 1241
    val_in = (unsigned char )*(src + i);
#line 1242
    if ((int )val_in >= 48) {
#line 1242
      if ((int )val_in <= 57) {
#line 1243
        val_out = (unsigned char )((int )val_in - 48);
      } else {
#line 1242
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */ 
#line 1244
    if ((int )val_in >= 65) {
#line 1244
      if ((int )val_in <= 90) {
#line 1245
        val_out = (unsigned char )((int )val_in - 54);
      } else {
#line 1244
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 1246
    if ((int )val_in >= 97) {
#line 1246
      if ((int )val_in <= 122) {
#line 1247
        val_out = (unsigned char )((int )val_in - 86);
      } else {
#line 1246
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 1248
    if ((int )val_in == 35) {
#line 1249
      val_out = (unsigned char)37;
    } else
#line 1250
    if ((int )val_in == 43) {
#line 1251
      val_out = (unsigned char)38;
    } else
#line 1252
    if ((int )val_in == 45) {
#line 1253
      val_out = (unsigned char)39;
    } else
#line 1254
    if ((int )val_in == 46) {
#line 1255
      val_out = (unsigned char)40;
    } else {
#line 1257
      val_out = (unsigned char)38;
    }
#line 1259
    *(dst + i) = (char )val_out;
#line 1239
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1261
  return;
}
}
#line 1270 "/home/wheatley/newnew/temp/lakai-0.1/lakai.c"
void lakai_akaitoascii(char *src , char *dst , int len ) 
{ 
  int i ;
  unsigned char val_in ;
  unsigned char val_out ;

  {
#line 1274
  i = 0;
  {
#line 1274
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1274
    if (! (i < len)) {
#line 1274
      goto while_break;
    }
#line 1276
    val_in = (unsigned char )*(src + i);
#line 1277
    if ((int )val_in <= 9) {
#line 1278
      val_out = (unsigned char )((int )val_in + 48);
    } else
#line 1279
    if ((int )val_in >= 11) {
#line 1279
      if ((int )val_in <= 36) {
#line 1280
        val_out = (unsigned char )((int )val_in + 54);
      } else {
#line 1279
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 1281
    if ((int )val_in == 37) {
#line 1282
      val_out = (unsigned char)35;
    } else
#line 1283
    if ((int )val_in == 38) {
#line 1284
      val_out = (unsigned char)43;
    } else
#line 1285
    if ((int )val_in == 39) {
#line 1286
      val_out = (unsigned char)45;
    } else
#line 1287
    if ((int )val_in == 40) {
#line 1288
      val_out = (unsigned char)46;
    } else {
#line 1290
      val_out = (unsigned char)32;
    }
#line 1292
    *(dst + i) = (char )val_out;
#line 1274
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1294
  return;
}
}
#line 1324 "/home/wheatley/newnew/temp/lakai-0.1/lakai.c"
static int send_command(int sg_fd , char *cmdblk___8 , int dirflag , void *tosamp_ptr ,
                        int tosamp_len , void *fromsamp_ptr , int fromsamp_len ) 
{ 
  sg_io_hdr_t io_hdr ;
  unsigned char sense_buffer[32] ;
  int tmp ;

  {
  {
#line 1332
  memset((void *)(& io_hdr), 0, sizeof(sg_io_hdr_t ));
#line 1333
  io_hdr.interface_id = 'S';
#line 1334
  io_hdr.cmd_len = (unsigned char)6;
#line 1336
  io_hdr.mx_sb_len = (unsigned char )sizeof(sense_buffer);
  }
#line 1338
  if (dirflag == 0) {
#line 1341
    io_hdr.dxfer_direction = -3;
#line 1342
    io_hdr.dxfer_len = (unsigned int )fromsamp_len;
#line 1343
    io_hdr.dxferp = fromsamp_ptr;
  } else {
#line 1348
    io_hdr.dxfer_direction = -2;
#line 1349
    io_hdr.dxfer_len = (unsigned int )tosamp_len;
#line 1350
    io_hdr.dxferp = tosamp_ptr;
  }
  {
#line 1360
  io_hdr.cmdp = (unsigned char *)cmdblk___8;
#line 1361
  io_hdr.sbp = sense_buffer;
#line 1362
  io_hdr.timeout = 20000U;
#line 1367
  tmp = ioctl(sg_fd, 8837UL, & io_hdr);
  }
#line 1367
  if (tmp < 0) {
    {
#line 1369
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"send_command(): ioctl(SG_IO, ..) failed\n");
    }
#line 1370
    return (-1);
  }
#line 1381
  if (! ((io_hdr.info & 1U) == 0U)) {
    {
#line 1387
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"### return code: NOT OK\n");
    }
#line 1388
    return (-1);
  }
#line 1391
  if ((int )io_hdr.sb_len_wr > 0) {
    {
#line 1393
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Something (%d bytes) is in the sense buffer.\n",
            (int )io_hdr.sb_len_wr);
#line 1394
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Dump of sense buffer follows:\n");
#line 1395
    hexprint(io_hdr.sbp, (int )io_hdr.sb_len_wr);
    }
#line 1396
    return (-1);
  }
#line 1399
  return (0);
}
}
#line 1406 "/home/wheatley/newnew/temp/lakai-0.1/lakai.c"
static void hexprint(unsigned char *buf , int len ) 
{ 
  unsigned char hexlist[17] ;
  unsigned short i ;

  {
#line 1408
  hexlist[0] = (unsigned char )'0';
#line 1408
  hexlist[1] = (unsigned char )'1';
#line 1408
  hexlist[2] = (unsigned char )'2';
#line 1408
  hexlist[3] = (unsigned char )'3';
#line 1408
  hexlist[4] = (unsigned char )'4';
#line 1408
  hexlist[5] = (unsigned char )'5';
#line 1408
  hexlist[6] = (unsigned char )'6';
#line 1408
  hexlist[7] = (unsigned char )'7';
#line 1408
  hexlist[8] = (unsigned char )'8';
#line 1408
  hexlist[9] = (unsigned char )'9';
#line 1408
  hexlist[10] = (unsigned char )'A';
#line 1408
  hexlist[11] = (unsigned char )'B';
#line 1408
  hexlist[12] = (unsigned char )'C';
#line 1408
  hexlist[13] = (unsigned char )'D';
#line 1408
  hexlist[14] = (unsigned char )'E';
#line 1408
  hexlist[15] = (unsigned char )'F';
#line 1408
  hexlist[16] = (unsigned char )'\000';
#line 1411
  i = (unsigned short)0;
  {
#line 1411
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1411
    if (! ((int )i < len)) {
#line 1411
      goto while_break;
    }
#line 1413
    if ((int )i % 16 == 0) {
      {
#line 1416
      putchar((int )hexlist[((int )i >> 12) & 15]);
#line 1417
      putchar((int )hexlist[((int )i >> 8) & 15]);
#line 1418
      putchar((int )hexlist[((int )i >> 4) & 15]);
#line 1419
      putchar((int )hexlist[(int )i & 15]);
#line 1420
      putchar(':');
      }
    }
#line 1422
    if ((int )i % 8 == 0) {
      {
#line 1423
      putchar(' ');
      }
    }
    {
#line 1425
    putchar((int )hexlist[(int )*(buf + (int )i) >> 4]);
#line 1426
    putchar((int )hexlist[(int )*(buf + (int )i) & 15]);
#line 1427
    putchar(' ');
    }
#line 1429
    if (((int )i + 1) % 16 == 0) {
      {
#line 1430
      putchar('\n');
      }
    }
#line 1411
    i = (unsigned short )((int )i + 1);
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1432
  putchar('\n');
  }
#line 1433
  return;
}
}
#line 1485 "/home/wheatley/newnew/temp/lakai-0.1/lakai.c"
static unsigned char cmdblk1___12[6]  = {      (unsigned char)12,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)255,      (unsigned char)0};
#line 1493 "/home/wheatley/newnew/temp/lakai-0.1/lakai.c"
static unsigned char cmdblk2[6]  = {      (unsigned char)13,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0};
#line 1501 "/home/wheatley/newnew/temp/lakai-0.1/lakai.c"
static unsigned char cmdblk3[6]  = {      (unsigned char)14,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0};
#line 1480 "/home/wheatley/newnew/temp/lakai-0.1/lakai.c"
static int sendrecv_scsimidi(LHANDLE handle , char *sysexblk , unsigned int sysexblksize ,
                             char *destbuf ) 
{ 
  unsigned char outbuf[32] ;
  int templen ;
  int currentlen ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 1509
  if (fhandles[handle] == -1) {
    {
#line 1511
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"sendrecv_scsimidi: Bad file handle\n");
    }
#line 1512
    return (-1);
  } else
#line 1509
  if (handle < 0) {
    {
#line 1511
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"sendrecv_scsimidi: Bad file handle\n");
    }
#line 1512
    return (-1);
  } else
#line 1509
  if (handle > 16) {
    {
#line 1511
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"sendrecv_scsimidi: Bad file handle\n");
    }
#line 1512
    return (-1);
  }
#line 1516
  if (sysexblksize > 65534U) {
    {
#line 1518
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"sendrecv_scsimidi: Error: SysEx msg too long\n!");
    }
#line 1519
    return (-1);
  }
  {
#line 1522
  cmdblk1___12[4] = (unsigned char )((int )((unsigned char )sysexblksize) & 255);
#line 1523
  cmdblk1___12[3] = (unsigned char )((sysexblksize & 65280U) >> 8);
#line 1524
  cmdblk1___12[2] = (unsigned char )((sysexblksize & 16711680U) >> 16);
#line 1526
  lakai_setmode(handle, 1);
#line 1533
  tmp = send_command(fhandles[handle], (char *)(cmdblk1___12), 1, (void *)sysexblk,
                     (int )sysexblksize, (void *)0, 0);
  }
#line 1533
  if (tmp < 0) {
    {
#line 1535
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"sendrecv_scsimidi: Problems in part 1\n");
#line 1536
    lakai_setmode(handle, 0);
    }
#line 1537
    return (-1);
  }
#line 1541
  currentlen = 0;
  {
#line 1543
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1546
    tmp___0 = send_command(fhandles[handle], (char *)(cmdblk2), 0, (void *)0, 0, (void *)(outbuf),
                           3);
    }
#line 1546
    if (tmp___0 < 0) {
      {
#line 1548
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"sendrecv_scsimidi: Problems in part 2\n");
#line 1549
      lakai_setmode(handle, 0);
      }
#line 1550
      return (-1);
    }
#line 1556
    templen = (((int )outbuf[0] << 16) + ((int )outbuf[1] << 8)) + (int )outbuf[2];
#line 1559
    if (templen > 0) {
      {
#line 1561
      cmdblk3[2] = outbuf[0];
#line 1562
      cmdblk3[3] = outbuf[1];
#line 1563
      cmdblk3[4] = outbuf[2];
#line 1566
      tmp___1 = send_command(fhandles[handle], (char *)(cmdblk3), 0, (void *)0, 0,
                             (void *)(destbuf + currentlen), templen);
      }
#line 1566
      if (tmp___1 < 0) {
        {
#line 1569
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"sendrecv_scsimidi: Problems in part 3\n");
#line 1570
        lakai_setmode(handle, 0);
        }
#line 1571
        return (-1);
      }
#line 1574
      currentlen += templen;
    }
#line 1543
    if (! (templen > 0)) {
#line 1543
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1580
  lakai_setmode(handle, 0);
  }
#line 1581
  return (currentlen);
}
}
#line 1594 "/home/wheatley/newnew/temp/lakai-0.1/lakai.c"
static unsigned char cmdblk1___13[6]  = {      (unsigned char)12,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)255,      (unsigned char)0};
#line 1602 "/home/wheatley/newnew/temp/lakai-0.1/lakai.c"
static unsigned char cmdblk2___0[6]  = {      (unsigned char)13,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)128};
#line 1589 "/home/wheatley/newnew/temp/lakai-0.1/lakai.c"
static int sendrecv_scsimidi2(LHANDLE handle , char *sysexblk , unsigned int sysexblksize ,
                              char *buf ) 
{ 
  unsigned char outbuf[32] ;
  int templen ;
  int tmp ;
  int tmp___0 ;

  {
#line 1610
  if (fhandles[handle] == -1) {
    {
#line 1612
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"sendrecv_scsimidi2: Bad file handle\n");
    }
#line 1613
    return (-1);
  } else
#line 1610
  if (handle < 0) {
    {
#line 1612
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"sendrecv_scsimidi2: Bad file handle\n");
    }
#line 1613
    return (-1);
  } else
#line 1610
  if (handle > 16) {
    {
#line 1612
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"sendrecv_scsimidi2: Bad file handle\n");
    }
#line 1613
    return (-1);
  }
#line 1616
  if (sysexblksize > 65534U) {
    {
#line 1618
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"sendrecv_scsimidi2: Error: SysEx msg too long\n!");
    }
#line 1619
    return (-1);
  }
  {
#line 1623
  cmdblk1___13[4] = (unsigned char )((int )((unsigned char )sysexblksize) & 255);
#line 1624
  cmdblk1___13[3] = (unsigned char )((sysexblksize & 65280U) >> 8);
#line 1625
  cmdblk1___13[2] = (unsigned char )((sysexblksize & 16711680U) >> 16);
#line 1631
  tmp = send_command(fhandles[handle], (char *)(cmdblk1___13), 1, (void *)sysexblk,
                     (int )sysexblksize, (void *)0, 0);
  }
#line 1631
  if (tmp < 0) {
    {
#line 1633
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"sendrecv_scsimidi2: Problems in part 1\n");
#line 1634
    lakai_setmode(handle, 0);
    }
#line 1635
    return (-1);
  }
  {
#line 1639
  tmp___0 = send_command(fhandles[handle], (char *)(cmdblk2___0), 0, (void *)0, 0,
                         (void *)(outbuf), 3);
  }
#line 1639
  if (tmp___0 < 0) {
    {
#line 1641
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"sendrecv_scsimidi2: Problems in part 2\n");
#line 1642
    lakai_setmode(handle, 0);
    }
#line 1643
    return (-1);
  }
#line 1647
  templen = (((int )outbuf[0] << 16) + ((int )outbuf[1] << 8)) + (int )outbuf[2];
#line 1651
  return (templen);
}
}
#line 1716 "/home/wheatley/newnew/temp/lakai-0.1/lakai.c"
static unsigned char cmdblk___0[6]  = {      (unsigned char)14,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0};
#line 1714 "/home/wheatley/newnew/temp/lakai-0.1/lakai.c"
static long getbulkdata(LHANDLE handle , int numbytes , char *buf ) 
{ 
  int tmp ;

  {
#line 1724
  if (fhandles[handle] == -1) {
    {
#line 1726
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"getbulkdata: Bad file handle\n");
    }
#line 1727
    return (-1L);
  } else
#line 1724
  if (handle < 0) {
    {
#line 1726
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"getbulkdata: Bad file handle\n");
    }
#line 1727
    return (-1L);
  } else
#line 1724
  if (handle > 16) {
    {
#line 1726
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"getbulkdata: Bad file handle\n");
    }
#line 1727
    return (-1L);
  }
#line 1730
  if (numbytes > 65536) {
    {
#line 1732
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"getbulkdata: Error: numbytes too large\n!");
    }
#line 1733
    return (-1L);
  }
  {
#line 1737
  cmdblk___0[3] = (unsigned char )(numbytes >> 8);
#line 1738
  cmdblk___0[4] = (unsigned char )(numbytes & 255);
#line 1739
  cmdblk___0[5] = (unsigned char)128;
#line 1741
  tmp = send_command(fhandles[handle], (char *)(cmdblk___0), 0, (void *)0, 0, (void *)buf,
                     numbytes);
  }
#line 1741
  if (tmp < 0) {
    {
#line 1743
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"getbulkdata: Problems in part 1\n");
#line 1744
    lakai_setmode(handle, 0);
    }
#line 1745
    return (-1L);
  }
#line 1748
  return ((long )numbytes);
}
}
#line 1770 "/home/wheatley/newnew/temp/lakai-0.1/lakai.c"
static unsigned char cmdblk___1[6]  = {      (unsigned char)12,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0};
#line 1768 "/home/wheatley/newnew/temp/lakai-0.1/lakai.c"
static long putbulkdata(LHANDLE handle , int numbytes , char *buf ) 
{ 
  int tmp ;

  {
#line 1778
  if (fhandles[handle] == -1) {
    {
#line 1780
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"putbulkdata: Bad file handle\n");
    }
#line 1781
    return (-1L);
  } else
#line 1778
  if (handle < 0) {
    {
#line 1780
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"putbulkdata: Bad file handle\n");
    }
#line 1781
    return (-1L);
  } else
#line 1778
  if (handle > 16) {
    {
#line 1780
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"putbulkdata: Bad file handle\n");
    }
#line 1781
    return (-1L);
  }
#line 1784
  if (numbytes > 65536) {
    {
#line 1786
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"putbulkdata: Error: numbytes too large\n!");
    }
#line 1787
    return (-1L);
  }
  {
#line 1791
  cmdblk___1[3] = (unsigned char )(numbytes >> 8);
#line 1792
  cmdblk___1[4] = (unsigned char )(numbytes & 255);
#line 1793
  cmdblk___1[5] = (unsigned char)128;
#line 1795
  tmp = send_command(fhandles[handle], (char *)(cmdblk___1), 1, (void *)buf, numbytes,
                     (void *)0, 0);
  }
#line 1795
  if (tmp < 0) {
    {
#line 1797
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"putbulkdata: Problems in part 1\n");
#line 1798
    lakai_setmode(handle, 0);
    }
#line 1799
    return (-1L);
  }
#line 1804
  return ((long )numbytes);
}
}
#line 34 "/home/wheatley/newnew/temp/lakai-0.1/lakai.c"
static int open_cnt___0  =    -1;
#line 35 "/home/wheatley/newnew/temp/lakai-0.1/lakai.c"
static int fhandles___0[16]  ;
#line 38
static int send_command___0(int sg_fd , char *cmdblk___8 , int dirflag , void *tosamp_ptr ,
                            int tosamp_len , void *fromsamp_ptr , int fromsamp_len ) ;
#line 41
static void hexprint___0(unsigned char *buf , int len ) ;
#line 43
static int sendrecv_scsimidi___0(LHANDLE handle , char *sysexblk , unsigned int sysexblksize ,
                                 char *destbuf ) ;
#line 44
static int sendrecv_scsimidi2___0(LHANDLE handle , char *sysexblk , unsigned int sysexblksize ,
                                  char *buf ) ;
#line 46
static long getbulkdata___0(LHANDLE handle , int numbytes , char *buf ) ;
#line 47
static long putbulkdata___0(LHANDLE handle , int numbytes , char *buf ) ;
#line 175 "/home/wheatley/newnew/temp/lakai-0.1/lakai.c"
static unsigned char cmdblk___2[6]  = {      (unsigned char)9,      (unsigned char)0,      (unsigned char)1,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0};
#line 234 "/home/wheatley/newnew/temp/lakai-0.1/lakai.c"
static unsigned char cmdblk1___14[6]  = {      (unsigned char)240,      (unsigned char)71,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)72,      (unsigned char)247};
#line 274 "/home/wheatley/newnew/temp/lakai-0.1/lakai.c"
static unsigned char cmdblk1___15[6]  = {      (unsigned char)240,      (unsigned char)71,      (unsigned char)0,      (unsigned char)2, 
        (unsigned char)72,      (unsigned char)247};
#line 360 "/home/wheatley/newnew/temp/lakai-0.1/lakai.c"
static unsigned char cmdblk1___16[6]  = {      (unsigned char)240,      (unsigned char)71,      (unsigned char)0,      (unsigned char)4, 
        (unsigned char)72,      (unsigned char)247};
#line 452 "/home/wheatley/newnew/temp/lakai-0.1/lakai.c"
static unsigned char cmdblk1___17[8]  = 
#line 452
  {      (unsigned char)240,      (unsigned char)71,      (unsigned char)0,      (unsigned char)6, 
        (unsigned char)72,      (unsigned char)0,      (unsigned char)0,      (unsigned char)247};
#line 550 "/home/wheatley/newnew/temp/lakai-0.1/lakai.c"
static unsigned char cmdblk1___18[9]  = 
#line 550
  {      (unsigned char)240,      (unsigned char)71,      (unsigned char)0,      (unsigned char)8, 
        (unsigned char)72,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)247};
#line 621 "/home/wheatley/newnew/temp/lakai-0.1/lakai.c"
static unsigned char cmdblk1___19[8]  = 
#line 621
  {      (unsigned char)240,      (unsigned char)71,      (unsigned char)0,      (unsigned char)10, 
        (unsigned char)72,      (unsigned char)0,      (unsigned char)0,      (unsigned char)247};
#line 693 "/home/wheatley/newnew/temp/lakai-0.1/lakai.c"
static unsigned char cmdblk1___20[7]  = {      (unsigned char)240,      (unsigned char)71,      (unsigned char)0,      (unsigned char)11, 
        (unsigned char)72,      (unsigned char)0,      (unsigned char)0};
#line 747 "/home/wheatley/newnew/temp/lakai-0.1/lakai.c"
static unsigned char cmdblk1___21[8]  = 
#line 747
  {      (unsigned char)240,      (unsigned char)71,      (unsigned char)0,      (unsigned char)18, 
        (unsigned char)72,      (unsigned char)0,      (unsigned char)0,      (unsigned char)247};
#line 792 "/home/wheatley/newnew/temp/lakai-0.1/lakai.c"
static unsigned char cmdblk1___22[9]  = 
#line 792
  {      (unsigned char)240,      (unsigned char)71,      (unsigned char)0,      (unsigned char)19, 
        (unsigned char)72,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)247};
#line 846 "/home/wheatley/newnew/temp/lakai-0.1/lakai.c"
static unsigned char cmdblk1___23[8]  = 
#line 846
  {      (unsigned char)240,      (unsigned char)71,      (unsigned char)0,      (unsigned char)20, 
        (unsigned char)72,      (unsigned char)0,      (unsigned char)0,      (unsigned char)247};
#line 965 "/home/wheatley/newnew/temp/lakai-0.1/lakai.c"
static unsigned char cmdblk1___24[6]  = {      (unsigned char)240,      (unsigned char)71,      (unsigned char)0,      (unsigned char)16, 
        (unsigned char)72,      (unsigned char)247};
#line 1011 "/home/wheatley/newnew/temp/lakai-0.1/lakai.c"
static unsigned char cmdblk1___25[7]  = {      (unsigned char)240,      (unsigned char)71,      (unsigned char)0,      (unsigned char)7, 
        (unsigned char)72,      (unsigned char)0,      (unsigned char)0};
#line 1082 "/home/wheatley/newnew/temp/lakai-0.1/lakai.c"
static unsigned char cmdblk1___26[8]  = 
#line 1082
  {      (unsigned char)240,      (unsigned char)71,      (unsigned char)0,      (unsigned char)9, 
        (unsigned char)72,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0};
#line 1324 "/home/wheatley/newnew/temp/lakai-0.1/lakai.c"
static int send_command___0(int sg_fd , char *cmdblk___8 , int dirflag , void *tosamp_ptr ,
                            int tosamp_len , void *fromsamp_ptr , int fromsamp_len ) 
{ 
  sg_io_hdr_t io_hdr ;
  unsigned char sense_buffer[32] ;
  int tmp ;

  {
  {
#line 1332
  memset((void *)(& io_hdr), 0, sizeof(sg_io_hdr_t ));
#line 1333
  io_hdr.interface_id = 'S';
#line 1334
  io_hdr.cmd_len = (unsigned char)6;
#line 1336
  io_hdr.mx_sb_len = (unsigned char )sizeof(sense_buffer);
  }
#line 1338
  if (dirflag == 0) {
#line 1341
    io_hdr.dxfer_direction = -3;
#line 1342
    io_hdr.dxfer_len = (unsigned int )fromsamp_len;
#line 1343
    io_hdr.dxferp = fromsamp_ptr;
  } else {
#line 1348
    io_hdr.dxfer_direction = -2;
#line 1349
    io_hdr.dxfer_len = (unsigned int )tosamp_len;
#line 1350
    io_hdr.dxferp = tosamp_ptr;
  }
  {
#line 1360
  io_hdr.cmdp = (unsigned char *)cmdblk___8;
#line 1361
  io_hdr.sbp = sense_buffer;
#line 1362
  io_hdr.timeout = 20000U;
#line 1367
  tmp = ioctl(sg_fd, 8837UL, & io_hdr);
  }
#line 1367
  if (tmp < 0) {
    {
#line 1369
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"send_command(): ioctl(SG_IO, ..) failed\n");
    }
#line 1370
    return (-1);
  }
#line 1381
  if (! ((io_hdr.info & 1U) == 0U)) {
    {
#line 1387
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"### return code: NOT OK\n");
    }
#line 1388
    return (-1);
  }
#line 1391
  if ((int )io_hdr.sb_len_wr > 0) {
    {
#line 1393
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Something (%d bytes) is in the sense buffer.\n",
            (int )io_hdr.sb_len_wr);
#line 1394
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Dump of sense buffer follows:\n");
#line 1395
    hexprint___0(io_hdr.sbp, (int )io_hdr.sb_len_wr);
    }
#line 1396
    return (-1);
  }
#line 1399
  return (0);
}
}
#line 1406 "/home/wheatley/newnew/temp/lakai-0.1/lakai.c"
static void hexprint___0(unsigned char *buf , int len ) 
{ 
  unsigned char hexlist[17] ;
  unsigned short i ;

  {
#line 1408
  hexlist[0] = (unsigned char )'0';
#line 1408
  hexlist[1] = (unsigned char )'1';
#line 1408
  hexlist[2] = (unsigned char )'2';
#line 1408
  hexlist[3] = (unsigned char )'3';
#line 1408
  hexlist[4] = (unsigned char )'4';
#line 1408
  hexlist[5] = (unsigned char )'5';
#line 1408
  hexlist[6] = (unsigned char )'6';
#line 1408
  hexlist[7] = (unsigned char )'7';
#line 1408
  hexlist[8] = (unsigned char )'8';
#line 1408
  hexlist[9] = (unsigned char )'9';
#line 1408
  hexlist[10] = (unsigned char )'A';
#line 1408
  hexlist[11] = (unsigned char )'B';
#line 1408
  hexlist[12] = (unsigned char )'C';
#line 1408
  hexlist[13] = (unsigned char )'D';
#line 1408
  hexlist[14] = (unsigned char )'E';
#line 1408
  hexlist[15] = (unsigned char )'F';
#line 1408
  hexlist[16] = (unsigned char )'\000';
#line 1411
  i = (unsigned short)0;
  {
#line 1411
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1411
    if (! ((int )i < len)) {
#line 1411
      goto while_break;
    }
#line 1413
    if ((int )i % 16 == 0) {
      {
#line 1416
      putchar((int )hexlist[((int )i >> 12) & 15]);
#line 1417
      putchar((int )hexlist[((int )i >> 8) & 15]);
#line 1418
      putchar((int )hexlist[((int )i >> 4) & 15]);
#line 1419
      putchar((int )hexlist[(int )i & 15]);
#line 1420
      putchar(':');
      }
    }
#line 1422
    if ((int )i % 8 == 0) {
      {
#line 1423
      putchar(' ');
      }
    }
    {
#line 1425
    putchar((int )hexlist[(int )*(buf + (int )i) >> 4]);
#line 1426
    putchar((int )hexlist[(int )*(buf + (int )i) & 15]);
#line 1427
    putchar(' ');
    }
#line 1429
    if (((int )i + 1) % 16 == 0) {
      {
#line 1430
      putchar('\n');
      }
    }
#line 1411
    i = (unsigned short )((int )i + 1);
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1432
  putchar('\n');
  }
#line 1433
  return;
}
}
#line 1485 "/home/wheatley/newnew/temp/lakai-0.1/lakai.c"
static unsigned char cmdblk1___27[6]  = {      (unsigned char)12,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)255,      (unsigned char)0};
#line 1493 "/home/wheatley/newnew/temp/lakai-0.1/lakai.c"
static unsigned char cmdblk2___1[6]  = {      (unsigned char)13,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0};
#line 1501 "/home/wheatley/newnew/temp/lakai-0.1/lakai.c"
static unsigned char cmdblk3___0[6]  = {      (unsigned char)14,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0};
#line 1480 "/home/wheatley/newnew/temp/lakai-0.1/lakai.c"
static int sendrecv_scsimidi___0(LHANDLE handle , char *sysexblk , unsigned int sysexblksize ,
                                 char *destbuf ) 
{ 
  unsigned char outbuf[32] ;
  int templen ;
  int currentlen ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 1509
  if (fhandles___0[handle] == -1) {
    {
#line 1511
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"sendrecv_scsimidi: Bad file handle\n");
    }
#line 1512
    return (-1);
  } else
#line 1509
  if (handle < 0) {
    {
#line 1511
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"sendrecv_scsimidi: Bad file handle\n");
    }
#line 1512
    return (-1);
  } else
#line 1509
  if (handle > 16) {
    {
#line 1511
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"sendrecv_scsimidi: Bad file handle\n");
    }
#line 1512
    return (-1);
  }
#line 1516
  if (sysexblksize > 65534U) {
    {
#line 1518
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"sendrecv_scsimidi: Error: SysEx msg too long\n!");
    }
#line 1519
    return (-1);
  }
  {
#line 1522
  cmdblk1___27[4] = (unsigned char )((int )((unsigned char )sysexblksize) & 255);
#line 1523
  cmdblk1___27[3] = (unsigned char )((sysexblksize & 65280U) >> 8);
#line 1524
  cmdblk1___27[2] = (unsigned char )((sysexblksize & 16711680U) >> 16);
#line 1526
  lakai_setmode(handle, 1);
#line 1533
  tmp = send_command___0(fhandles___0[handle], (char *)(cmdblk1___27), 1, (void *)sysexblk,
                         (int )sysexblksize, (void *)0, 0);
  }
#line 1533
  if (tmp < 0) {
    {
#line 1535
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"sendrecv_scsimidi: Problems in part 1\n");
#line 1536
    lakai_setmode(handle, 0);
    }
#line 1537
    return (-1);
  }
#line 1541
  currentlen = 0;
  {
#line 1543
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1546
    tmp___0 = send_command___0(fhandles___0[handle], (char *)(cmdblk2___1), 0, (void *)0,
                               0, (void *)(outbuf), 3);
    }
#line 1546
    if (tmp___0 < 0) {
      {
#line 1548
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"sendrecv_scsimidi: Problems in part 2\n");
#line 1549
      lakai_setmode(handle, 0);
      }
#line 1550
      return (-1);
    }
#line 1556
    templen = (((int )outbuf[0] << 16) + ((int )outbuf[1] << 8)) + (int )outbuf[2];
#line 1559
    if (templen > 0) {
      {
#line 1561
      cmdblk3___0[2] = outbuf[0];
#line 1562
      cmdblk3___0[3] = outbuf[1];
#line 1563
      cmdblk3___0[4] = outbuf[2];
#line 1566
      tmp___1 = send_command___0(fhandles___0[handle], (char *)(cmdblk3___0), 0, (void *)0,
                                 0, (void *)(destbuf + currentlen), templen);
      }
#line 1566
      if (tmp___1 < 0) {
        {
#line 1569
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"sendrecv_scsimidi: Problems in part 3\n");
#line 1570
        lakai_setmode(handle, 0);
        }
#line 1571
        return (-1);
      }
#line 1574
      currentlen += templen;
    }
#line 1543
    if (! (templen > 0)) {
#line 1543
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1580
  lakai_setmode(handle, 0);
  }
#line 1581
  return (currentlen);
}
}
#line 1594 "/home/wheatley/newnew/temp/lakai-0.1/lakai.c"
static unsigned char cmdblk1___28[6]  = {      (unsigned char)12,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)255,      (unsigned char)0};
#line 1602 "/home/wheatley/newnew/temp/lakai-0.1/lakai.c"
static unsigned char cmdblk2___2[6]  = {      (unsigned char)13,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)128};
#line 1589 "/home/wheatley/newnew/temp/lakai-0.1/lakai.c"
static int sendrecv_scsimidi2___0(LHANDLE handle , char *sysexblk , unsigned int sysexblksize ,
                                  char *buf ) 
{ 
  unsigned char outbuf[32] ;
  int templen ;
  int tmp ;
  int tmp___0 ;

  {
#line 1610
  if (fhandles___0[handle] == -1) {
    {
#line 1612
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"sendrecv_scsimidi2: Bad file handle\n");
    }
#line 1613
    return (-1);
  } else
#line 1610
  if (handle < 0) {
    {
#line 1612
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"sendrecv_scsimidi2: Bad file handle\n");
    }
#line 1613
    return (-1);
  } else
#line 1610
  if (handle > 16) {
    {
#line 1612
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"sendrecv_scsimidi2: Bad file handle\n");
    }
#line 1613
    return (-1);
  }
#line 1616
  if (sysexblksize > 65534U) {
    {
#line 1618
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"sendrecv_scsimidi2: Error: SysEx msg too long\n!");
    }
#line 1619
    return (-1);
  }
  {
#line 1623
  cmdblk1___28[4] = (unsigned char )((int )((unsigned char )sysexblksize) & 255);
#line 1624
  cmdblk1___28[3] = (unsigned char )((sysexblksize & 65280U) >> 8);
#line 1625
  cmdblk1___28[2] = (unsigned char )((sysexblksize & 16711680U) >> 16);
#line 1631
  tmp = send_command___0(fhandles___0[handle], (char *)(cmdblk1___28), 1, (void *)sysexblk,
                         (int )sysexblksize, (void *)0, 0);
  }
#line 1631
  if (tmp < 0) {
    {
#line 1633
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"sendrecv_scsimidi2: Problems in part 1\n");
#line 1634
    lakai_setmode(handle, 0);
    }
#line 1635
    return (-1);
  }
  {
#line 1639
  tmp___0 = send_command___0(fhandles___0[handle], (char *)(cmdblk2___2), 0, (void *)0,
                             0, (void *)(outbuf), 3);
  }
#line 1639
  if (tmp___0 < 0) {
    {
#line 1641
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"sendrecv_scsimidi2: Problems in part 2\n");
#line 1642
    lakai_setmode(handle, 0);
    }
#line 1643
    return (-1);
  }
#line 1647
  templen = (((int )outbuf[0] << 16) + ((int )outbuf[1] << 8)) + (int )outbuf[2];
#line 1651
  return (templen);
}
}
#line 1716 "/home/wheatley/newnew/temp/lakai-0.1/lakai.c"
static unsigned char cmdblk___3[6]  = {      (unsigned char)14,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0};
#line 1714 "/home/wheatley/newnew/temp/lakai-0.1/lakai.c"
static long getbulkdata___0(LHANDLE handle , int numbytes , char *buf ) 
{ 
  int tmp ;

  {
#line 1724
  if (fhandles___0[handle] == -1) {
    {
#line 1726
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"getbulkdata: Bad file handle\n");
    }
#line 1727
    return (-1L);
  } else
#line 1724
  if (handle < 0) {
    {
#line 1726
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"getbulkdata: Bad file handle\n");
    }
#line 1727
    return (-1L);
  } else
#line 1724
  if (handle > 16) {
    {
#line 1726
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"getbulkdata: Bad file handle\n");
    }
#line 1727
    return (-1L);
  }
#line 1730
  if (numbytes > 65536) {
    {
#line 1732
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"getbulkdata: Error: numbytes too large\n!");
    }
#line 1733
    return (-1L);
  }
  {
#line 1737
  cmdblk___3[3] = (unsigned char )(numbytes >> 8);
#line 1738
  cmdblk___3[4] = (unsigned char )(numbytes & 255);
#line 1739
  cmdblk___3[5] = (unsigned char)128;
#line 1741
  tmp = send_command___0(fhandles___0[handle], (char *)(cmdblk___3), 0, (void *)0,
                         0, (void *)buf, numbytes);
  }
#line 1741
  if (tmp < 0) {
    {
#line 1743
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"getbulkdata: Problems in part 1\n");
#line 1744
    lakai_setmode(handle, 0);
    }
#line 1745
    return (-1L);
  }
#line 1748
  return ((long )numbytes);
}
}
#line 1770 "/home/wheatley/newnew/temp/lakai-0.1/lakai.c"
static unsigned char cmdblk___4[6]  = {      (unsigned char)12,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0};
#line 1768 "/home/wheatley/newnew/temp/lakai-0.1/lakai.c"
static long putbulkdata___0(LHANDLE handle , int numbytes , char *buf ) 
{ 
  int tmp ;

  {
#line 1778
  if (fhandles___0[handle] == -1) {
    {
#line 1780
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"putbulkdata: Bad file handle\n");
    }
#line 1781
    return (-1L);
  } else
#line 1778
  if (handle < 0) {
    {
#line 1780
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"putbulkdata: Bad file handle\n");
    }
#line 1781
    return (-1L);
  } else
#line 1778
  if (handle > 16) {
    {
#line 1780
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"putbulkdata: Bad file handle\n");
    }
#line 1781
    return (-1L);
  }
#line 1784
  if (numbytes > 65536) {
    {
#line 1786
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"putbulkdata: Error: numbytes too large\n!");
    }
#line 1787
    return (-1L);
  }
  {
#line 1791
  cmdblk___4[3] = (unsigned char )(numbytes >> 8);
#line 1792
  cmdblk___4[4] = (unsigned char )(numbytes & 255);
#line 1793
  cmdblk___4[5] = (unsigned char)128;
#line 1795
  tmp = send_command___0(fhandles___0[handle], (char *)(cmdblk___4), 1, (void *)buf,
                         numbytes, (void *)0, 0);
  }
#line 1795
  if (tmp < 0) {
    {
#line 1797
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"putbulkdata: Problems in part 1\n");
#line 1798
    lakai_setmode(handle, 0);
    }
#line 1799
    return (-1L);
  }
#line 1804
  return ((long )numbytes);
}
}
#line 34 "/home/wheatley/newnew/temp/lakai-0.1/lakai.c"
static int open_cnt___1  =    -1;
#line 35 "/home/wheatley/newnew/temp/lakai-0.1/lakai.c"
static int fhandles___1[16]  ;
#line 38
static int send_command___1(int sg_fd , char *cmdblk___8 , int dirflag , void *tosamp_ptr ,
                            int tosamp_len , void *fromsamp_ptr , int fromsamp_len ) ;
#line 41
static void hexprint___1(unsigned char *buf , int len ) ;
#line 43
static int sendrecv_scsimidi___1(LHANDLE handle , char *sysexblk , unsigned int sysexblksize ,
                                 char *destbuf ) ;
#line 44
static int sendrecv_scsimidi2___1(LHANDLE handle , char *sysexblk , unsigned int sysexblksize ,
                                  char *buf ) ;
#line 46
static long getbulkdata___1(LHANDLE handle , int numbytes , char *buf ) ;
#line 47
static long putbulkdata___1(LHANDLE handle , int numbytes , char *buf ) ;
#line 175 "/home/wheatley/newnew/temp/lakai-0.1/lakai.c"
static unsigned char cmdblk___5[6]  = {      (unsigned char)9,      (unsigned char)0,      (unsigned char)1,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0};
#line 234 "/home/wheatley/newnew/temp/lakai-0.1/lakai.c"
static unsigned char cmdblk1___29[6]  = {      (unsigned char)240,      (unsigned char)71,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)72,      (unsigned char)247};
#line 274 "/home/wheatley/newnew/temp/lakai-0.1/lakai.c"
static unsigned char cmdblk1___30[6]  = {      (unsigned char)240,      (unsigned char)71,      (unsigned char)0,      (unsigned char)2, 
        (unsigned char)72,      (unsigned char)247};
#line 360 "/home/wheatley/newnew/temp/lakai-0.1/lakai.c"
static unsigned char cmdblk1___31[6]  = {      (unsigned char)240,      (unsigned char)71,      (unsigned char)0,      (unsigned char)4, 
        (unsigned char)72,      (unsigned char)247};
#line 452 "/home/wheatley/newnew/temp/lakai-0.1/lakai.c"
static unsigned char cmdblk1___32[8]  = 
#line 452
  {      (unsigned char)240,      (unsigned char)71,      (unsigned char)0,      (unsigned char)6, 
        (unsigned char)72,      (unsigned char)0,      (unsigned char)0,      (unsigned char)247};
#line 550 "/home/wheatley/newnew/temp/lakai-0.1/lakai.c"
static unsigned char cmdblk1___33[9]  = 
#line 550
  {      (unsigned char)240,      (unsigned char)71,      (unsigned char)0,      (unsigned char)8, 
        (unsigned char)72,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)247};
#line 621 "/home/wheatley/newnew/temp/lakai-0.1/lakai.c"
static unsigned char cmdblk1___34[8]  = 
#line 621
  {      (unsigned char)240,      (unsigned char)71,      (unsigned char)0,      (unsigned char)10, 
        (unsigned char)72,      (unsigned char)0,      (unsigned char)0,      (unsigned char)247};
#line 693 "/home/wheatley/newnew/temp/lakai-0.1/lakai.c"
static unsigned char cmdblk1___35[7]  = {      (unsigned char)240,      (unsigned char)71,      (unsigned char)0,      (unsigned char)11, 
        (unsigned char)72,      (unsigned char)0,      (unsigned char)0};
#line 747 "/home/wheatley/newnew/temp/lakai-0.1/lakai.c"
static unsigned char cmdblk1___36[8]  = 
#line 747
  {      (unsigned char)240,      (unsigned char)71,      (unsigned char)0,      (unsigned char)18, 
        (unsigned char)72,      (unsigned char)0,      (unsigned char)0,      (unsigned char)247};
#line 792 "/home/wheatley/newnew/temp/lakai-0.1/lakai.c"
static unsigned char cmdblk1___37[9]  = 
#line 792
  {      (unsigned char)240,      (unsigned char)71,      (unsigned char)0,      (unsigned char)19, 
        (unsigned char)72,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)247};
#line 846 "/home/wheatley/newnew/temp/lakai-0.1/lakai.c"
static unsigned char cmdblk1___38[8]  = 
#line 846
  {      (unsigned char)240,      (unsigned char)71,      (unsigned char)0,      (unsigned char)20, 
        (unsigned char)72,      (unsigned char)0,      (unsigned char)0,      (unsigned char)247};
#line 965 "/home/wheatley/newnew/temp/lakai-0.1/lakai.c"
static unsigned char cmdblk1___39[6]  = {      (unsigned char)240,      (unsigned char)71,      (unsigned char)0,      (unsigned char)16, 
        (unsigned char)72,      (unsigned char)247};
#line 1011 "/home/wheatley/newnew/temp/lakai-0.1/lakai.c"
static unsigned char cmdblk1___40[7]  = {      (unsigned char)240,      (unsigned char)71,      (unsigned char)0,      (unsigned char)7, 
        (unsigned char)72,      (unsigned char)0,      (unsigned char)0};
#line 1082 "/home/wheatley/newnew/temp/lakai-0.1/lakai.c"
static unsigned char cmdblk1___41[8]  = 
#line 1082
  {      (unsigned char)240,      (unsigned char)71,      (unsigned char)0,      (unsigned char)9, 
        (unsigned char)72,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0};
#line 1324 "/home/wheatley/newnew/temp/lakai-0.1/lakai.c"
static int send_command___1(int sg_fd , char *cmdblk___8 , int dirflag , void *tosamp_ptr ,
                            int tosamp_len , void *fromsamp_ptr , int fromsamp_len ) 
{ 
  sg_io_hdr_t io_hdr ;
  unsigned char sense_buffer[32] ;
  int tmp ;

  {
  {
#line 1332
  memset((void *)(& io_hdr), 0, sizeof(sg_io_hdr_t ));
#line 1333
  io_hdr.interface_id = 'S';
#line 1334
  io_hdr.cmd_len = (unsigned char)6;
#line 1336
  io_hdr.mx_sb_len = (unsigned char )sizeof(sense_buffer);
  }
#line 1338
  if (dirflag == 0) {
#line 1341
    io_hdr.dxfer_direction = -3;
#line 1342
    io_hdr.dxfer_len = (unsigned int )fromsamp_len;
#line 1343
    io_hdr.dxferp = fromsamp_ptr;
  } else {
#line 1348
    io_hdr.dxfer_direction = -2;
#line 1349
    io_hdr.dxfer_len = (unsigned int )tosamp_len;
#line 1350
    io_hdr.dxferp = tosamp_ptr;
  }
  {
#line 1360
  io_hdr.cmdp = (unsigned char *)cmdblk___8;
#line 1361
  io_hdr.sbp = sense_buffer;
#line 1362
  io_hdr.timeout = 20000U;
#line 1367
  tmp = ioctl(sg_fd, 8837UL, & io_hdr);
  }
#line 1367
  if (tmp < 0) {
    {
#line 1369
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"send_command(): ioctl(SG_IO, ..) failed\n");
    }
#line 1370
    return (-1);
  }
#line 1381
  if (! ((io_hdr.info & 1U) == 0U)) {
    {
#line 1387
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"### return code: NOT OK\n");
    }
#line 1388
    return (-1);
  }
#line 1391
  if ((int )io_hdr.sb_len_wr > 0) {
    {
#line 1393
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Something (%d bytes) is in the sense buffer.\n",
            (int )io_hdr.sb_len_wr);
#line 1394
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Dump of sense buffer follows:\n");
#line 1395
    hexprint___1(io_hdr.sbp, (int )io_hdr.sb_len_wr);
    }
#line 1396
    return (-1);
  }
#line 1399
  return (0);
}
}
#line 1406 "/home/wheatley/newnew/temp/lakai-0.1/lakai.c"
static void hexprint___1(unsigned char *buf , int len ) 
{ 
  unsigned char hexlist[17] ;
  unsigned short i ;

  {
#line 1408
  hexlist[0] = (unsigned char )'0';
#line 1408
  hexlist[1] = (unsigned char )'1';
#line 1408
  hexlist[2] = (unsigned char )'2';
#line 1408
  hexlist[3] = (unsigned char )'3';
#line 1408
  hexlist[4] = (unsigned char )'4';
#line 1408
  hexlist[5] = (unsigned char )'5';
#line 1408
  hexlist[6] = (unsigned char )'6';
#line 1408
  hexlist[7] = (unsigned char )'7';
#line 1408
  hexlist[8] = (unsigned char )'8';
#line 1408
  hexlist[9] = (unsigned char )'9';
#line 1408
  hexlist[10] = (unsigned char )'A';
#line 1408
  hexlist[11] = (unsigned char )'B';
#line 1408
  hexlist[12] = (unsigned char )'C';
#line 1408
  hexlist[13] = (unsigned char )'D';
#line 1408
  hexlist[14] = (unsigned char )'E';
#line 1408
  hexlist[15] = (unsigned char )'F';
#line 1408
  hexlist[16] = (unsigned char )'\000';
#line 1411
  i = (unsigned short)0;
  {
#line 1411
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1411
    if (! ((int )i < len)) {
#line 1411
      goto while_break;
    }
#line 1413
    if ((int )i % 16 == 0) {
      {
#line 1416
      putchar((int )hexlist[((int )i >> 12) & 15]);
#line 1417
      putchar((int )hexlist[((int )i >> 8) & 15]);
#line 1418
      putchar((int )hexlist[((int )i >> 4) & 15]);
#line 1419
      putchar((int )hexlist[(int )i & 15]);
#line 1420
      putchar(':');
      }
    }
#line 1422
    if ((int )i % 8 == 0) {
      {
#line 1423
      putchar(' ');
      }
    }
    {
#line 1425
    putchar((int )hexlist[(int )*(buf + (int )i) >> 4]);
#line 1426
    putchar((int )hexlist[(int )*(buf + (int )i) & 15]);
#line 1427
    putchar(' ');
    }
#line 1429
    if (((int )i + 1) % 16 == 0) {
      {
#line 1430
      putchar('\n');
      }
    }
#line 1411
    i = (unsigned short )((int )i + 1);
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1432
  putchar('\n');
  }
#line 1433
  return;
}
}
#line 1485 "/home/wheatley/newnew/temp/lakai-0.1/lakai.c"
static unsigned char cmdblk1___42[6]  = {      (unsigned char)12,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)255,      (unsigned char)0};
#line 1493 "/home/wheatley/newnew/temp/lakai-0.1/lakai.c"
static unsigned char cmdblk2___3[6]  = {      (unsigned char)13,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0};
#line 1501 "/home/wheatley/newnew/temp/lakai-0.1/lakai.c"
static unsigned char cmdblk3___1[6]  = {      (unsigned char)14,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0};
#line 1480 "/home/wheatley/newnew/temp/lakai-0.1/lakai.c"
static int sendrecv_scsimidi___1(LHANDLE handle , char *sysexblk , unsigned int sysexblksize ,
                                 char *destbuf ) 
{ 
  unsigned char outbuf[32] ;
  int templen ;
  int currentlen ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 1509
  if (fhandles___1[handle] == -1) {
    {
#line 1511
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"sendrecv_scsimidi: Bad file handle\n");
    }
#line 1512
    return (-1);
  } else
#line 1509
  if (handle < 0) {
    {
#line 1511
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"sendrecv_scsimidi: Bad file handle\n");
    }
#line 1512
    return (-1);
  } else
#line 1509
  if (handle > 16) {
    {
#line 1511
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"sendrecv_scsimidi: Bad file handle\n");
    }
#line 1512
    return (-1);
  }
#line 1516
  if (sysexblksize > 65534U) {
    {
#line 1518
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"sendrecv_scsimidi: Error: SysEx msg too long\n!");
    }
#line 1519
    return (-1);
  }
  {
#line 1522
  cmdblk1___42[4] = (unsigned char )((int )((unsigned char )sysexblksize) & 255);
#line 1523
  cmdblk1___42[3] = (unsigned char )((sysexblksize & 65280U) >> 8);
#line 1524
  cmdblk1___42[2] = (unsigned char )((sysexblksize & 16711680U) >> 16);
#line 1526
  lakai_setmode(handle, 1);
#line 1533
  tmp = send_command___1(fhandles___1[handle], (char *)(cmdblk1___42), 1, (void *)sysexblk,
                         (int )sysexblksize, (void *)0, 0);
  }
#line 1533
  if (tmp < 0) {
    {
#line 1535
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"sendrecv_scsimidi: Problems in part 1\n");
#line 1536
    lakai_setmode(handle, 0);
    }
#line 1537
    return (-1);
  }
#line 1541
  currentlen = 0;
  {
#line 1543
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1546
    tmp___0 = send_command___1(fhandles___1[handle], (char *)(cmdblk2___3), 0, (void *)0,
                               0, (void *)(outbuf), 3);
    }
#line 1546
    if (tmp___0 < 0) {
      {
#line 1548
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"sendrecv_scsimidi: Problems in part 2\n");
#line 1549
      lakai_setmode(handle, 0);
      }
#line 1550
      return (-1);
    }
#line 1556
    templen = (((int )outbuf[0] << 16) + ((int )outbuf[1] << 8)) + (int )outbuf[2];
#line 1559
    if (templen > 0) {
      {
#line 1561
      cmdblk3___1[2] = outbuf[0];
#line 1562
      cmdblk3___1[3] = outbuf[1];
#line 1563
      cmdblk3___1[4] = outbuf[2];
#line 1566
      tmp___1 = send_command___1(fhandles___1[handle], (char *)(cmdblk3___1), 0, (void *)0,
                                 0, (void *)(destbuf + currentlen), templen);
      }
#line 1566
      if (tmp___1 < 0) {
        {
#line 1569
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"sendrecv_scsimidi: Problems in part 3\n");
#line 1570
        lakai_setmode(handle, 0);
        }
#line 1571
        return (-1);
      }
#line 1574
      currentlen += templen;
    }
#line 1543
    if (! (templen > 0)) {
#line 1543
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1580
  lakai_setmode(handle, 0);
  }
#line 1581
  return (currentlen);
}
}
#line 1594 "/home/wheatley/newnew/temp/lakai-0.1/lakai.c"
static unsigned char cmdblk1___43[6]  = {      (unsigned char)12,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)255,      (unsigned char)0};
#line 1602 "/home/wheatley/newnew/temp/lakai-0.1/lakai.c"
static unsigned char cmdblk2___4[6]  = {      (unsigned char)13,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)128};
#line 1589 "/home/wheatley/newnew/temp/lakai-0.1/lakai.c"
static int sendrecv_scsimidi2___1(LHANDLE handle , char *sysexblk , unsigned int sysexblksize ,
                                  char *buf ) 
{ 
  unsigned char outbuf[32] ;
  int templen ;
  int tmp ;
  int tmp___0 ;

  {
#line 1610
  if (fhandles___1[handle] == -1) {
    {
#line 1612
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"sendrecv_scsimidi2: Bad file handle\n");
    }
#line 1613
    return (-1);
  } else
#line 1610
  if (handle < 0) {
    {
#line 1612
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"sendrecv_scsimidi2: Bad file handle\n");
    }
#line 1613
    return (-1);
  } else
#line 1610
  if (handle > 16) {
    {
#line 1612
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"sendrecv_scsimidi2: Bad file handle\n");
    }
#line 1613
    return (-1);
  }
#line 1616
  if (sysexblksize > 65534U) {
    {
#line 1618
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"sendrecv_scsimidi2: Error: SysEx msg too long\n!");
    }
#line 1619
    return (-1);
  }
  {
#line 1623
  cmdblk1___43[4] = (unsigned char )((int )((unsigned char )sysexblksize) & 255);
#line 1624
  cmdblk1___43[3] = (unsigned char )((sysexblksize & 65280U) >> 8);
#line 1625
  cmdblk1___43[2] = (unsigned char )((sysexblksize & 16711680U) >> 16);
#line 1631
  tmp = send_command___1(fhandles___1[handle], (char *)(cmdblk1___43), 1, (void *)sysexblk,
                         (int )sysexblksize, (void *)0, 0);
  }
#line 1631
  if (tmp < 0) {
    {
#line 1633
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"sendrecv_scsimidi2: Problems in part 1\n");
#line 1634
    lakai_setmode(handle, 0);
    }
#line 1635
    return (-1);
  }
  {
#line 1639
  tmp___0 = send_command___1(fhandles___1[handle], (char *)(cmdblk2___4), 0, (void *)0,
                             0, (void *)(outbuf), 3);
  }
#line 1639
  if (tmp___0 < 0) {
    {
#line 1641
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"sendrecv_scsimidi2: Problems in part 2\n");
#line 1642
    lakai_setmode(handle, 0);
    }
#line 1643
    return (-1);
  }
#line 1647
  templen = (((int )outbuf[0] << 16) + ((int )outbuf[1] << 8)) + (int )outbuf[2];
#line 1651
  return (templen);
}
}
#line 1716 "/home/wheatley/newnew/temp/lakai-0.1/lakai.c"
static unsigned char cmdblk___6[6]  = {      (unsigned char)14,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0};
#line 1714 "/home/wheatley/newnew/temp/lakai-0.1/lakai.c"
static long getbulkdata___1(LHANDLE handle , int numbytes , char *buf ) 
{ 
  int tmp ;

  {
#line 1724
  if (fhandles___1[handle] == -1) {
    {
#line 1726
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"getbulkdata: Bad file handle\n");
    }
#line 1727
    return (-1L);
  } else
#line 1724
  if (handle < 0) {
    {
#line 1726
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"getbulkdata: Bad file handle\n");
    }
#line 1727
    return (-1L);
  } else
#line 1724
  if (handle > 16) {
    {
#line 1726
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"getbulkdata: Bad file handle\n");
    }
#line 1727
    return (-1L);
  }
#line 1730
  if (numbytes > 65536) {
    {
#line 1732
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"getbulkdata: Error: numbytes too large\n!");
    }
#line 1733
    return (-1L);
  }
  {
#line 1737
  cmdblk___6[3] = (unsigned char )(numbytes >> 8);
#line 1738
  cmdblk___6[4] = (unsigned char )(numbytes & 255);
#line 1739
  cmdblk___6[5] = (unsigned char)128;
#line 1741
  tmp = send_command___1(fhandles___1[handle], (char *)(cmdblk___6), 0, (void *)0,
                         0, (void *)buf, numbytes);
  }
#line 1741
  if (tmp < 0) {
    {
#line 1743
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"getbulkdata: Problems in part 1\n");
#line 1744
    lakai_setmode(handle, 0);
    }
#line 1745
    return (-1L);
  }
#line 1748
  return ((long )numbytes);
}
}
#line 1770 "/home/wheatley/newnew/temp/lakai-0.1/lakai.c"
static unsigned char cmdblk___7[6]  = {      (unsigned char)12,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0};
#line 1768 "/home/wheatley/newnew/temp/lakai-0.1/lakai.c"
static long putbulkdata___1(LHANDLE handle , int numbytes , char *buf ) 
{ 
  int tmp ;

  {
#line 1778
  if (fhandles___1[handle] == -1) {
    {
#line 1780
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"putbulkdata: Bad file handle\n");
    }
#line 1781
    return (-1L);
  } else
#line 1778
  if (handle < 0) {
    {
#line 1780
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"putbulkdata: Bad file handle\n");
    }
#line 1781
    return (-1L);
  } else
#line 1778
  if (handle > 16) {
    {
#line 1780
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"putbulkdata: Bad file handle\n");
    }
#line 1781
    return (-1L);
  }
#line 1784
  if (numbytes > 65536) {
    {
#line 1786
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"putbulkdata: Error: numbytes too large\n!");
    }
#line 1787
    return (-1L);
  }
  {
#line 1791
  cmdblk___7[3] = (unsigned char )(numbytes >> 8);
#line 1792
  cmdblk___7[4] = (unsigned char )(numbytes & 255);
#line 1793
  cmdblk___7[5] = (unsigned char)128;
#line 1795
  tmp = send_command___1(fhandles___1[handle], (char *)(cmdblk___7), 1, (void *)buf,
                         numbytes, (void *)0, 0);
  }
#line 1795
  if (tmp < 0) {
    {
#line 1797
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"putbulkdata: Problems in part 1\n");
#line 1798
    lakai_setmode(handle, 0);
    }
#line 1799
    return (-1L);
  }
#line 1804
  return ((long )numbytes);
}
}
