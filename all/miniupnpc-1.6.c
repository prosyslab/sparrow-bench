/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 21 "/home/wheatley/newnew/temp/miniupnpc-1.6/upnpreplyparse.h"
struct __anonstruct_entries_25 {
   struct NameValue *le_next ;
   struct NameValue **le_prev ;
};
#line 21 "/home/wheatley/newnew/temp/miniupnpc-1.6/upnpreplyparse.h"
struct NameValue {
   struct __anonstruct_entries_25 entries ;
   char name[64] ;
   char value[64] ;
};
#line 27 "/home/wheatley/newnew/temp/miniupnpc-1.6/upnpreplyparse.h"
struct listhead {
   struct NameValue *lh_first ;
};
#line 27 "/home/wheatley/newnew/temp/miniupnpc-1.6/upnpreplyparse.h"
struct NameValueParserData {
   struct listhead head ;
   char curelt[64] ;
   char *portListing ;
   int portListingLength ;
};
#line 17 "/home/wheatley/newnew/temp/miniupnpc-1.6/minixml.h"
struct xmlparser {
   char const   *xmlstart ;
   char const   *xmlend ;
   char const   *xml ;
   int xmlsize ;
   void *data ;
   void (*starteltfunc)(void * , char const   * , int  ) ;
   void (*endeltfunc)(void * , char const   * , int  ) ;
   void (*datafunc)(void * , char const   * , int  ) ;
   void (*attfunc)(void * , char const   * , int  , char const   * , int  ) ;
};
#line 15 "/home/wheatley/newnew/temp/miniupnpc-1.6/igd_desc_parse.h"
struct IGDdatas_service {
   char controlurl[128] ;
   char eventsuburl[128] ;
   char scpdurl[128] ;
   char servicetype[128] ;
};
#line 23 "/home/wheatley/newnew/temp/miniupnpc-1.6/igd_desc_parse.h"
struct IGDdatas {
   char cureltname[128] ;
   char urlbase[128] ;
   char presentationurl[128] ;
   int level ;
   struct IGDdatas_service CIF ;
   struct IGDdatas_service first ;
   struct IGDdatas_service second ;
   struct IGDdatas_service IPv6FC ;
   struct IGDdatas_service tmp ;
};
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 189 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __socklen_t;
#line 102 "/usr/include/stdio.h"
typedef __ssize_t ssize_t;
#line 274 "/usr/include/unistd.h"
typedef __socklen_t socklen_t;
#line 28 "/usr/include/x86_64-linux-gnu/bits/sockaddr.h"
typedef unsigned short sa_family_t;
#line 149 "/usr/include/x86_64-linux-gnu/bits/socket.h"
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14] ;
};
#line 29 "/usr/include/x86_64-linux-gnu/sys/un.h"
struct sockaddr_un {
   sa_family_t sun_family ;
   char sun_path[108] ;
};
#line 11 "/home/wheatley/newnew/temp/miniupnpc-1.6/minissdpc.h"
struct UPNPDev;
#line 32 "/home/wheatley/newnew/temp/miniupnpc-1.6/miniupnpc.h"
struct UPNPDev {
   struct UPNPDev *pNext ;
   char *descURL ;
   char *st ;
   char buffer[2] ;
};
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 162 "/usr/include/x86_64-linux-gnu/bits/socket.h"
struct sockaddr_storage {
   sa_family_t ss_family ;
   unsigned long __ss_align ;
   char __ss_padding[128UL - 2UL * sizeof(unsigned long )] ;
};
#line 48 "/usr/include/stdint.h"
typedef unsigned char uint8_t;
#line 49 "/usr/include/stdint.h"
typedef unsigned short uint16_t;
#line 51 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 30 "/usr/include/netinet/in.h"
typedef uint32_t in_addr_t;
#line 31 "/usr/include/netinet/in.h"
struct in_addr {
   in_addr_t s_addr ;
};
#line 117 "/usr/include/netinet/in.h"
typedef uint16_t in_port_t;
#line 209 "/usr/include/netinet/in.h"
union __anonunion___in6_u_55 {
   uint8_t __u6_addr8[16] ;
};
#line 209 "/usr/include/netinet/in.h"
struct in6_addr {
   union __anonunion___in6_u_55 __in6_u ;
};
#line 237 "/usr/include/netinet/in.h"
struct sockaddr_in {
   sa_family_t sin_family ;
   in_port_t sin_port ;
   struct in_addr sin_addr ;
   unsigned char sin_zero[((sizeof(struct sockaddr ) - sizeof(unsigned short )) - sizeof(in_port_t )) - sizeof(struct in_addr )] ;
};
#line 252 "/usr/include/netinet/in.h"
struct sockaddr_in6 {
   sa_family_t sin6_family ;
   in_port_t sin6_port ;
   uint32_t sin6_flowinfo ;
   struct in6_addr sin6_addr ;
   uint32_t sin6_scope_id ;
};
#line 567 "/usr/include/netdb.h"
struct addrinfo {
   int ai_flags ;
   int ai_family ;
   int ai_socktype ;
   int ai_protocol ;
   socklen_t ai_addrlen ;
   struct sockaddr *ai_addr ;
   char *ai_canonname ;
   struct addrinfo *ai_next ;
};
#line 25 "/home/wheatley/newnew/temp/miniupnpc-1.6/miniupnpc.h"
struct UPNParg {
   char const   *elt ;
   char const   *val ;
};
#line 72 "/home/wheatley/newnew/temp/miniupnpc-1.6/miniupnpc.h"
struct UPNPUrls {
   char *controlURL ;
   char *ipcondescURL ;
   char *controlURL_CIF ;
   char *controlURL_6FC ;
};
#line 36 "/usr/include/x86_64-linux-gnu/sys/poll.h"
typedef unsigned long nfds_t;
#line 39 "/usr/include/x86_64-linux-gnu/sys/poll.h"
struct pollfd {
   int fd ;
   short events ;
   short revents ;
};
#line 36 "/home/wheatley/newnew/temp/miniupnpc-1.6/portlistingparse.h"
enum __anonenum_portMappingElt_21 {
    PortMappingEltNone = 0,
    PortMappingEntry = 1,
    NewRemoteHost = 2,
    NewExternalPort = 3,
    NewProtocol = 4,
    NewInternalPort = 5,
    NewInternalClient = 6,
    NewEnabled = 7,
    NewDescription = 8,
    NewLeaseTime = 9
} ;
#line 36 "/home/wheatley/newnew/temp/miniupnpc-1.6/portlistingparse.h"
typedef enum __anonenum_portMappingElt_21 portMappingElt;
#line 43 "/home/wheatley/newnew/temp/miniupnpc-1.6/portlistingparse.h"
struct __anonstruct_entries_22 {
   struct PortMapping *le_next ;
   struct PortMapping **le_prev ;
};
#line 43 "/home/wheatley/newnew/temp/miniupnpc-1.6/portlistingparse.h"
struct PortMapping {
   struct __anonstruct_entries_22 entries ;
   unsigned int leaseTime ;
   unsigned short externalPort ;
   unsigned short internalPort ;
   char remoteHost[64] ;
   char internalClient[64] ;
   char description[64] ;
   char protocol[4] ;
   unsigned char enabled ;
};
#line 55 "/home/wheatley/newnew/temp/miniupnpc-1.6/portlistingparse.h"
struct portmappinglisthead {
   struct PortMapping *lh_first ;
};
#line 55 "/home/wheatley/newnew/temp/miniupnpc-1.6/portlistingparse.h"
struct PortMappingParserData {
   struct portmappinglisthead head ;
   portMappingElt curelt ;
};
#line 13 "/home/wheatley/newnew/temp/miniupnpc-1.6/portlistingparse.c"
struct __anonstruct_elements_23 {
   portMappingElt const   code ;
   char const   * const  str ;
};
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 75 "/usr/include/time.h"
typedef __time_t time_t;
#line 141 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds_t;
#line 30 "/usr/include/x86_64-linux-gnu/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 54 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef long __fd_mask;
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
struct __anonstruct_fd_set_10 {
   __fd_mask __fds_bits[1024 / (8 * (int )sizeof(__fd_mask ))] ;
};
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef struct __anonstruct_fd_set_10 fd_set;
#line 13 "/home/wheatley/newnew/temp/miniupnpc-1.6/portlistingparse.c"
struct __anonstruct_elements_23___0 {
   portMappingElt const   code ;
   char const   * const  str ;
};
#line 13 "/home/wheatley/newnew/temp/miniupnpc-1.6/portlistingparse.c"
struct __anonstruct_elements_23___1 {
   portMappingElt const   code ;
   char const   * const  str ;
};
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 132
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 144
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 35 "/home/wheatley/newnew/temp/miniupnpc-1.6/upnpreplyparse.h"
void ParseNameValue(char const   *buffer , int bufsize , struct NameValueParserData *data___2 ) ;
#line 40
void ClearNameValueList(struct NameValueParserData *pdata ) ;
#line 44
char *GetValueFromNameValueList(struct NameValueParserData *pdata , char const   *Name ) ;
#line 34 "/home/wheatley/newnew/temp/miniupnpc-1.6/minixml.h"
void parsexml(struct xmlparser *parser ) ;
#line 15 "/home/wheatley/newnew/temp/miniupnpc-1.6/upnpreplyparse.c"
static void NameValueParserStartElt(void *d , char const   *name , int l ) 
{ 
  struct NameValueParserData *data___2 ;

  {
#line 18
  data___2 = (struct NameValueParserData *)d;
#line 19
  if (l > 63) {
#line 20
    l = 63;
  }
  {
#line 21
  memcpy((void */* __restrict  */)(data___2->curelt), (void const   */* __restrict  */)name,
         (size_t )l);
#line 22
  data___2->curelt[l] = (char )'\000';
  }
#line 23
  return;
}
}
#line 25 "/home/wheatley/newnew/temp/miniupnpc-1.6/upnpreplyparse.c"
static void NameValueParserGetData(void *d , char const   *datas , int l ) 
{ 
  struct NameValueParserData *data___2 ;
  struct NameValue *nv ;
  void *tmp ;
  void *tmp___0 ;
  struct NameValue *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 28
  data___2 = (struct NameValueParserData *)d;
#line 30
  tmp___2 = strcmp((char const   *)(data___2->curelt), "NewPortListing");
  }
#line 30
  if (tmp___2 == 0) {
    {
#line 33
    tmp = malloc((size_t )(l + 1));
#line 33
    data___2->portListing = (char *)tmp;
    }
#line 34
    if (! data___2->portListing) {
#line 37
      return;
    }
    {
#line 39
    memcpy((void */* __restrict  */)data___2->portListing, (void const   */* __restrict  */)datas,
           (size_t )l);
#line 40
    *(data___2->portListing + l) = (char )'\000';
#line 41
    data___2->portListingLength = l;
    }
  } else {
    {
#line 46
    tmp___0 = malloc(sizeof(struct NameValue ));
#line 46
    nv = (struct NameValue *)tmp___0;
    }
#line 47
    if (l > 63) {
#line 48
      l = 63;
    }
    {
#line 49
    strncpy((char */* __restrict  */)(nv->name), (char const   */* __restrict  */)(data___2->curelt),
            (size_t )64);
#line 50
    nv->name[63] = (char )'\000';
#line 51
    memcpy((void */* __restrict  */)(nv->value), (void const   */* __restrict  */)datas,
           (size_t )l);
#line 52
    nv->value[l] = (char )'\000';
    }
    {
#line 53
    while (1) {
      while_continue: /* CIL Label */ ;
#line 53
      tmp___1 = data___2->head.lh_first;
#line 53
      nv->entries.le_next = tmp___1;
#line 53
      if ((unsigned long )tmp___1 != (unsigned long )((void *)0)) {
#line 53
        (data___2->head.lh_first)->entries.le_prev = & nv->entries.le_next;
      }
#line 53
      data___2->head.lh_first = nv;
#line 53
      nv->entries.le_prev = & data___2->head.lh_first;
#line 53
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 55
  return;
}
}
#line 57 "/home/wheatley/newnew/temp/miniupnpc-1.6/upnpreplyparse.c"
void ParseNameValue(char const   *buffer , int bufsize , struct NameValueParserData *data___2 ) 
{ 
  struct xmlparser parser ;

  {
  {
#line 62
  while (1) {
    while_continue: /* CIL Label */ ;
#line 62
    data___2->head.lh_first = (struct NameValue *)((void *)0);
#line 62
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 63
  data___2->portListing = (char *)((void *)0);
#line 64
  data___2->portListingLength = 0;
#line 66
  parser.xmlstart = buffer;
#line 67
  parser.xmlsize = bufsize;
#line 68
  parser.data = (void *)data___2;
#line 69
  parser.starteltfunc = & NameValueParserStartElt;
#line 70
  parser.endeltfunc = (void (*)(void * , char const   * , int  ))0;
#line 71
  parser.datafunc = & NameValueParserGetData;
#line 72
  parser.attfunc = (void (*)(void * , char const   * , int  , char const   * , int  ))0;
#line 73
  parsexml(& parser);
  }
#line 74
  return;
}
}
#line 76 "/home/wheatley/newnew/temp/miniupnpc-1.6/upnpreplyparse.c"
void ClearNameValueList(struct NameValueParserData *pdata ) 
{ 
  struct NameValue *nv ;

  {
#line 80
  if (pdata->portListing) {
    {
#line 82
    free((void *)pdata->portListing);
#line 83
    pdata->portListing = (char *)((void *)0);
#line 84
    pdata->portListingLength = 0;
    }
  }
  {
#line 86
  while (1) {
    while_continue: /* CIL Label */ ;
#line 86
    nv = pdata->head.lh_first;
#line 86
    if (! ((unsigned long )nv != (unsigned long )((void *)0))) {
#line 86
      goto while_break;
    }
    {
#line 88
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 88
      if ((unsigned long )nv->entries.le_next != (unsigned long )((void *)0)) {
#line 88
        (nv->entries.le_next)->entries.le_prev = nv->entries.le_prev;
      }
#line 88
      *(nv->entries.le_prev) = nv->entries.le_next;
#line 88
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 89
    free((void *)nv);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 91
  return;
}
}
#line 93 "/home/wheatley/newnew/temp/miniupnpc-1.6/upnpreplyparse.c"
char *GetValueFromNameValueList(struct NameValueParserData *pdata , char const   *Name ) 
{ 
  struct NameValue *nv ;
  char *p ;
  int tmp ;

  {
#line 98
  p = (char *)((void *)0);
#line 99
  nv = pdata->head.lh_first;
  {
#line 99
  while (1) {
    while_continue: /* CIL Label */ ;
#line 99
    if ((unsigned long )nv != (unsigned long )((void *)0)) {
#line 99
      if (! ((unsigned long )p == (unsigned long )((void *)0))) {
#line 99
        goto while_break;
      }
    } else {
#line 99
      goto while_break;
    }
    {
#line 103
    tmp = strcmp((char const   *)(nv->name), Name);
    }
#line 103
    if (tmp == 0) {
#line 104
      p = nv->value;
    }
#line 99
    nv = nv->entries.le_next;
  }
  while_break: /* CIL Label */ ;
  }
#line 106
  return (p);
}
}
#line 42 "/home/wheatley/newnew/temp/miniupnpc-1.6/igd_desc_parse.h"
void IGDstartelt(void *d , char const   *name , int l ) ;
#line 43
void IGDendelt(void *d , char const   *name , int l ) ;
#line 44
void IGDdata(void *d , char const   *data___2 , int l ) ;
#line 45
void printIGD(struct IGDdatas *d ) ;
#line 362 "/usr/include/stdio.h"
extern int printf(char const   * __restrict  __format  , ...) ;
#line 69 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) memcmp)(void const   *__s1 ,
                                                                                               void const   *__s2 ,
                                                                                               size_t __n )  __attribute__((__pure__)) ;
#line 15 "/home/wheatley/newnew/temp/miniupnpc-1.6/igd_desc_parse.c"
void IGDstartelt(void *d , char const   *name , int l ) 
{ 
  struct IGDdatas *datas ;
  int tmp ;

  {
#line 17
  datas = (struct IGDdatas *)d;
#line 18
  if (l >= 128) {
#line 19
    l = 127;
  }
  {
#line 20
  memcpy((void */* __restrict  */)(datas->cureltname), (void const   */* __restrict  */)name,
         (size_t )l);
#line 21
  datas->cureltname[l] = (char )'\000';
#line 22
  (datas->level) ++;
  }
#line 23
  if (l == 7) {
    {
#line 23
    tmp = memcmp((void const   *)name, (void const   *)"service", (size_t )l);
    }
#line 23
    if (! tmp) {
#line 24
      datas->tmp.controlurl[0] = (char )'\000';
#line 25
      datas->tmp.eventsuburl[0] = (char )'\000';
#line 26
      datas->tmp.scpdurl[0] = (char )'\000';
#line 27
      datas->tmp.servicetype[0] = (char )'\000';
    }
  }
#line 29
  return;
}
}
#line 34 "/home/wheatley/newnew/temp/miniupnpc-1.6/igd_desc_parse.c"
void IGDendelt(void *d , char const   *name , int l ) 
{ 
  struct IGDdatas *datas ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 36
  datas = (struct IGDdatas *)d;
#line 37
  (datas->level) --;
#line 39
  if (l == 7) {
    {
#line 39
    tmp___3 = memcmp((void const   *)name, (void const   *)"service", (size_t )l);
    }
#line 39
    if (! tmp___3) {
      {
#line 48
      tmp___2 = strcmp((char const   *)(datas->tmp.servicetype), "urn:schemas-upnp-org:service:WANCommonInterfaceConfig:1");
      }
#line 48
      if (0 == tmp___2) {
        {
#line 50
        memcpy((void */* __restrict  */)(& datas->CIF), (void const   */* __restrict  */)(& datas->tmp),
               sizeof(struct IGDdatas_service ));
        }
      } else {
        {
#line 51
        tmp___1 = strcmp((char const   *)(datas->tmp.servicetype), "urn:schemas-upnp-org:service:WANIPv6FirewallControl:1");
        }
#line 51
        if (0 == tmp___1) {
          {
#line 53
          memcpy((void */* __restrict  */)(& datas->IPv6FC), (void const   */* __restrict  */)(& datas->tmp),
                 sizeof(struct IGDdatas_service ));
          }
        } else {
          {
#line 54
          tmp = strcmp((char const   *)(datas->tmp.servicetype), "urn:schemas-upnp-org:service:WANIPConnection:1");
          }
#line 54
          if (0 == tmp) {
#line 54
            goto _L;
          } else {
            {
#line 54
            tmp___0 = strcmp((char const   *)(datas->tmp.servicetype), "urn:schemas-upnp-org:service:WANPPPConnection:1");
            }
#line 54
            if (0 == tmp___0) {
              _L: /* CIL Label */ 
#line 58
              if ((int )datas->first.servicetype[0] == 0) {
                {
#line 59
                memcpy((void */* __restrict  */)(& datas->first), (void const   */* __restrict  */)(& datas->tmp),
                       sizeof(struct IGDdatas_service ));
                }
              } else {
                {
#line 61
                memcpy((void */* __restrict  */)(& datas->second), (void const   */* __restrict  */)(& datas->tmp),
                       sizeof(struct IGDdatas_service ));
                }
              }
            }
          }
        }
      }
    }
  }
#line 65
  return;
}
}
#line 69 "/home/wheatley/newnew/temp/miniupnpc-1.6/igd_desc_parse.c"
void IGDdata(void *d , char const   *data___2 , int l ) 
{ 
  struct IGDdatas *datas ;
  char *dstmember ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  {
#line 71
  datas = (struct IGDdatas *)d;
#line 72
  dstmember = (char *)0;
#line 75
  tmp___4 = strcmp((char const   *)(datas->cureltname), "URLBase");
  }
#line 75
  if (tmp___4) {
    {
#line 77
    tmp___3 = strcmp((char const   *)(datas->cureltname), "presentationURL");
    }
#line 77
    if (tmp___3) {
      {
#line 79
      tmp___2 = strcmp((char const   *)(datas->cureltname), "serviceType");
      }
#line 79
      if (tmp___2) {
        {
#line 81
        tmp___1 = strcmp((char const   *)(datas->cureltname), "controlURL");
        }
#line 81
        if (tmp___1) {
          {
#line 83
          tmp___0 = strcmp((char const   *)(datas->cureltname), "eventSubURL");
          }
#line 83
          if (tmp___0) {
            {
#line 85
            tmp = strcmp((char const   *)(datas->cureltname), "SCPDURL");
            }
#line 85
            if (! tmp) {
#line 86
              dstmember = datas->tmp.scpdurl;
            }
          } else {
#line 84
            dstmember = datas->tmp.eventsuburl;
          }
        } else {
#line 82
          dstmember = datas->tmp.controlurl;
        }
      } else {
#line 80
        dstmember = datas->tmp.servicetype;
      }
    } else {
#line 78
      dstmember = datas->presentationurl;
    }
  } else {
#line 76
    dstmember = datas->urlbase;
  }
#line 89
  if (dstmember) {
#line 91
    if (l >= 128) {
#line 92
      l = 127;
    }
    {
#line 93
    memcpy((void */* __restrict  */)dstmember, (void const   */* __restrict  */)data___2,
           (size_t )l);
#line 94
    *(dstmember + l) = (char )'\000';
    }
  }
#line 96
  return;
}
}
#line 98 "/home/wheatley/newnew/temp/miniupnpc-1.6/igd_desc_parse.c"
void printIGD(struct IGDdatas *d ) 
{ 


  {
  {
#line 100
  printf((char const   */* __restrict  */)"urlbase = \'%s\'\n", d->urlbase);
#line 101
  printf((char const   */* __restrict  */)"WAN Device (Common interface config) :\n");
#line 103
  printf((char const   */* __restrict  */)" serviceType = \'%s\'\n", d->CIF.servicetype);
#line 104
  printf((char const   */* __restrict  */)" controlURL = \'%s\'\n", d->CIF.controlurl);
#line 105
  printf((char const   */* __restrict  */)" eventSubURL = \'%s\'\n", d->CIF.eventsuburl);
#line 106
  printf((char const   */* __restrict  */)" SCPDURL = \'%s\'\n", d->CIF.scpdurl);
#line 107
  printf((char const   */* __restrict  */)"primary WAN Connection Device (IP or PPP Connection):\n");
#line 109
  printf((char const   */* __restrict  */)" servicetype = \'%s\'\n", d->first.servicetype);
#line 110
  printf((char const   */* __restrict  */)" controlURL = \'%s\'\n", d->first.controlurl);
#line 111
  printf((char const   */* __restrict  */)" eventSubURL = \'%s\'\n", d->first.eventsuburl);
#line 112
  printf((char const   */* __restrict  */)" SCPDURL = \'%s\'\n", d->first.scpdurl);
#line 113
  printf((char const   */* __restrict  */)"secondary WAN Connection Device (IP or PPP Connection):\n");
#line 115
  printf((char const   */* __restrict  */)" servicetype = \'%s\'\n", d->second.servicetype);
#line 116
  printf((char const   */* __restrict  */)" controlURL = \'%s\'\n", d->second.controlurl);
#line 117
  printf((char const   */* __restrict  */)" eventSubURL = \'%s\'\n", d->second.eventsuburl);
#line 118
  printf((char const   */* __restrict  */)" SCPDURL = \'%s\'\n", d->second.scpdurl);
#line 119
  printf((char const   */* __restrict  */)"WAN IPv6 Firewall Control :\n");
#line 121
  printf((char const   */* __restrict  */)" servicetype = \'%s\'\n", d->IPv6FC.servicetype);
#line 122
  printf((char const   */* __restrict  */)" controlURL = \'%s\'\n", d->IPv6FC.controlurl);
#line 123
  printf((char const   */* __restrict  */)" eventSubURL = \'%s\'\n", d->IPv6FC.eventsuburl);
#line 124
  printf((char const   */* __restrict  */)" SCPDURL = \'%s\'\n", d->IPv6FC.scpdurl);
  }
#line 125
  return;
}
}
#line 846 "/usr/include/stdio.h"
extern void perror(char const   *__s ) ;
#line 399 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 353 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 360
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 366
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 113 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) socket)(int __domain ,
                                                                             int __type ,
                                                                             int __protocol ) ;
#line 137
extern int connect(int __fd , struct sockaddr  const  *__addr , socklen_t __len ) ;
#line 11 "/home/wheatley/newnew/temp/miniupnpc-1.6/minissdpc.h"
struct UPNPDev *getDevicesFromMiniSSDPD(char const   *devtype , char const   *socketpath ) ;
#line 43 "/home/wheatley/newnew/temp/miniupnpc-1.6/minissdpc.c"
struct UPNPDev *getDevicesFromMiniSSDPD(char const   *devtype , char const   *socketpath ) 
{ 
  struct UPNPDev *tmp ;
  struct UPNPDev *devlist ;
  unsigned char buffer[2048] ;
  ssize_t n ;
  unsigned char *p ;
  unsigned char *url ;
  unsigned int i ;
  unsigned int urlsize ;
  unsigned int stsize ;
  unsigned int usnsize ;
  unsigned int l ;
  int s ;
  struct sockaddr_un addr ;
  int tmp___0 ;
  size_t tmp___1 ;
  unsigned char *tmp___2 ;
  unsigned char *tmp___3 ;
  unsigned char *tmp___4 ;
  unsigned char *tmp___5 ;
  unsigned char *tmp___6 ;
  ssize_t tmp___7 ;
  unsigned char *tmp___8 ;
  unsigned char *tmp___9 ;
  void *tmp___10 ;
  unsigned char *tmp___11 ;

  {
  {
#line 47
  devlist = (struct UPNPDev *)((void *)0);
#line 57
  s = socket(1, 1, 0);
  }
#line 58
  if (s < 0) {
    {
#line 61
    perror("socket(unix)");
    }
#line 62
    return ((struct UPNPDev *)((void *)0));
  }
  {
#line 64
  addr.sun_family = (sa_family_t )1;
#line 65
  strncpy((char */* __restrict  */)(addr.sun_path), (char const   */* __restrict  */)socketpath,
          sizeof(addr.sun_path));
#line 67
  tmp___0 = connect(s, (struct sockaddr  const  *)((struct sockaddr *)(& addr)), (socklen_t )sizeof(struct sockaddr_un ));
  }
#line 67
  if (tmp___0 < 0) {
    {
#line 70
    close(s);
    }
#line 71
    return ((struct UPNPDev *)((void *)0));
  }
  {
#line 73
  tmp___1 = strlen(devtype);
#line 73
  stsize = (unsigned int )tmp___1;
#line 74
  buffer[0] = (unsigned char)1;
#line 75
  p = buffer + 1;
#line 76
  l = stsize;
  }
#line 76
  if (l >= 268435456U) {
#line 76
    tmp___2 = p;
#line 76
    p ++;
#line 76
    *tmp___2 = (unsigned char )((l >> 28) | 128U);
  }
#line 76
  if (l >= 2097152U) {
#line 76
    tmp___3 = p;
#line 76
    p ++;
#line 76
    *tmp___3 = (unsigned char )((l >> 21) | 128U);
  }
#line 76
  if (l >= 16384U) {
#line 76
    tmp___4 = p;
#line 76
    p ++;
#line 76
    *tmp___4 = (unsigned char )((l >> 14) | 128U);
  }
#line 76
  if (l >= 128U) {
#line 76
    tmp___5 = p;
#line 76
    p ++;
#line 76
    *tmp___5 = (unsigned char )((l >> 7) | 128U);
  }
#line 76
  tmp___6 = p;
#line 76
  p ++;
#line 76
  *tmp___6 = (unsigned char )(l & 127U);
#line 77
  if ((unsigned long )(p + stsize) > (unsigned long )(buffer + sizeof(buffer))) {
    {
#line 80
    close(s);
    }
#line 81
    return ((struct UPNPDev *)((void *)0));
  }
  {
#line 83
  memcpy((void */* __restrict  */)p, (void const   */* __restrict  */)devtype, (size_t )stsize);
#line 84
  p += stsize;
#line 85
  tmp___7 = write(s, (void const   *)(buffer), (size_t )(p - buffer));
  }
#line 85
  if (tmp___7 < 0L) {
    {
#line 88
    perror("minissdpc.c: write()");
#line 89
    close(s);
    }
#line 90
    return ((struct UPNPDev *)((void *)0));
  }
  {
#line 92
  n = read(s, (void *)(buffer), sizeof(buffer));
  }
#line 93
  if (n <= 0L) {
    {
#line 95
    perror("minissdpc.c: read()");
#line 96
    close(s);
    }
#line 97
    return ((struct UPNPDev *)((void *)0));
  }
#line 99
  p = buffer + 1;
#line 100
  i = 0U;
  {
#line 100
  while (1) {
    while_continue: /* CIL Label */ ;
#line 100
    if (! (i < (unsigned int )buffer[0])) {
#line 100
      goto while_break;
    }
#line 102
    if ((unsigned long )(p + 2) >= (unsigned long )(buffer + sizeof(buffer))) {
#line 103
      goto while_break;
    }
#line 104
    urlsize = 0U;
    {
#line 104
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 104
      urlsize = (urlsize << 7) | (unsigned int )((int )*p & 127);
#line 104
      tmp___8 = p;
#line 104
      p ++;
#line 104
      if (! ((int )*tmp___8 & 128)) {
#line 104
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 105
    if ((unsigned long )((p + urlsize) + 2) >= (unsigned long )(buffer + sizeof(buffer))) {
#line 106
      goto while_break;
    }
#line 107
    url = p;
#line 108
    p += urlsize;
#line 109
    stsize = 0U;
    {
#line 109
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 109
      stsize = (stsize << 7) | (unsigned int )((int )*p & 127);
#line 109
      tmp___9 = p;
#line 109
      p ++;
#line 109
      if (! ((int )*tmp___9 & 128)) {
#line 109
        goto while_break___1;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 110
    if ((unsigned long )((p + stsize) + 2) >= (unsigned long )(buffer + sizeof(buffer))) {
#line 111
      goto while_break;
    }
    {
#line 112
    tmp___10 = malloc((sizeof(struct UPNPDev ) + (unsigned long )urlsize) + (unsigned long )stsize);
#line 112
    tmp = (struct UPNPDev *)tmp___10;
#line 113
    tmp->pNext = devlist;
#line 114
    tmp->descURL = tmp->buffer;
#line 115
    tmp->st = (tmp->buffer + 1) + urlsize;
#line 116
    memcpy((void */* __restrict  */)(tmp->buffer), (void const   */* __restrict  */)url,
           (size_t )urlsize);
#line 117
    tmp->buffer[urlsize] = (char )'\000';
#line 118
    memcpy((void */* __restrict  */)((tmp->buffer + urlsize) + 1), (void const   */* __restrict  */)p,
           (size_t )stsize);
#line 119
    p += stsize;
#line 120
    tmp->buffer[(urlsize + 1U) + stsize] = (char )'\000';
#line 121
    devlist = tmp;
#line 124
    usnsize = 0U;
    }
    {
#line 124
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 124
      usnsize = (usnsize << 7) | (unsigned int )((int )*p & 127);
#line 124
      tmp___11 = p;
#line 124
      p ++;
#line 124
      if (! ((int )*tmp___11 & 128)) {
#line 124
        goto while_break___2;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
#line 125
    p += usnsize;
#line 126
    if ((unsigned long )p > (unsigned long )(buffer + sizeof(buffer))) {
#line 127
      goto while_break;
    }
#line 100
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 129
  close(s);
  }
#line 130
  return (devlist);
}
}
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 386
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 66 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 236
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 342
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strstr)(char const   *__haystack ,
                                                                                                 char const   *__needle )  __attribute__((__pure__)) ;
#line 123 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) bind)(int __fd ,
                                                                           struct sockaddr  const  *__addr ,
                                                                           socklen_t __len ) ;
#line 163
extern ssize_t sendto(int __fd , void const   *__buf , size_t __n , int __flags ,
                      struct sockaddr  const  *__addr , socklen_t __addr_len ) ;
#line 226
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setsockopt)(int __fd ,
                                                                                 int __level ,
                                                                                 int __optname ,
                                                                                 void const   *__optval ,
                                                                                 socklen_t __optlen ) ;
#line 227 "/usr/include/netinet/in.h"
extern struct in6_addr  const  in6addr_any ;
#line 379
extern  __attribute__((__nothrow__)) uint16_t ( __attribute__((__leaf__)) htons)(uint16_t __hostshort )  __attribute__((__const__)) ;
#line 34 "/usr/include/arpa/inet.h"
extern  __attribute__((__nothrow__)) in_addr_t ( __attribute__((__leaf__)) inet_addr)(char const   *__cp ) ;
#line 662 "/usr/include/netdb.h"
extern int getaddrinfo(char const   * __restrict  __name , char const   * __restrict  __service ,
                       struct addrinfo  const  * __restrict  __req , struct addrinfo ** __restrict  __pai ) ;
#line 668
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) freeaddrinfo)(struct addrinfo *__ai ) ;
#line 671
extern  __attribute__((__nothrow__)) char const   *( __attribute__((__leaf__)) gai_strerror)(int __ecode ) ;
#line 193 "/usr/include/net/if.h"
extern  __attribute__((__nothrow__)) unsigned int ( __attribute__((__leaf__)) if_nametoindex)(char const   *__ifname ) ;
#line 120 "/usr/include/strings.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncasecmp)(char const   *__s1 ,
                                                                                                    char const   *__s2 ,
                                                                                                    size_t __n )  __attribute__((__pure__)) ;
#line 27 "/home/wheatley/newnew/temp/miniupnpc-1.6/miniupnpc.h"
char *simpleUPnPcommand(int s , char const   *url , char const   *service , char const   *action ,
                        struct UPNParg *args , int *bufsize ) ;
#line 52
struct UPNPDev *upnpDiscover(int delay , char const   *multicastif , char const   *minissdpdsock ,
                             int sameport , int ipv6 , int *error ) ;
#line 59
void freeUPNPDevlist(struct UPNPDev *devlist ) ;
#line 64
void parserootdesc(char const   *buffer , int bufsize , struct IGDdatas *data___2 ) ;
#line 91
int UPNP_GetValidIGD(struct UPNPDev *devlist , struct UPNPUrls *urls , struct IGDdatas *data___2 ,
                     char *lanaddr , int lanaddrlen ) ;
#line 102
int UPNP_GetIGDFromUrl(char const   *rootdescurl , struct UPNPUrls *urls , struct IGDdatas *data___2 ,
                       char *lanaddr , int lanaddrlen ) ;
#line 108
void GetUPNPUrls(struct UPNPUrls *urls , struct IGDdatas *data___2 , char const   *descURL ) ;
#line 110
void FreeUPNPUrls(struct UPNPUrls *urls ) ;
#line 113
int UPNPIGD_IsConnected(struct UPNPUrls *urls , struct IGDdatas *data___2 ) ;
#line 17 "/home/wheatley/newnew/temp/miniupnpc-1.6/miniwget.h"
void *getHTTPResponse(int s , int *size ) ;
#line 21
void *miniwget_getaddr(char const   *url , int *size , char *addr , int addrlen ) ;
#line 23
int parseURL(char const   *url , char *hostname , unsigned short *port , char **path ) ;
#line 11 "/home/wheatley/newnew/temp/miniupnpc-1.6/minisoap.h"
int soapPostSubmit(int fd , char const   *url , char const   *host , unsigned short port ,
                   char const   *action , char const   *body , char const   *httpversion ) ;
#line 46 "/home/wheatley/newnew/temp/miniupnpc-1.6/upnpcommands.h"
int UPNP_GetStatusInfo(char const   *controlURL , char const   *servicetype , char *status ,
                       unsigned int *uptime , char *lastconnerror ) ;
#line 14 "/home/wheatley/newnew/temp/miniupnpc-1.6/connecthostport.h"
int connecthostport(char const   *host , unsigned short port ) ;
#line 14 "/home/wheatley/newnew/temp/miniupnpc-1.6/receivedata.h"
int receivedata(int socket___0 , char *data___2 , int length , int timeout ) ;
#line 88 "/home/wheatley/newnew/temp/miniupnpc-1.6/miniupnpc.c"
void parserootdesc(char const   *buffer , int bufsize , struct IGDdatas *data___2 ) 
{ 
  struct xmlparser parser ;

  {
  {
#line 92
  parser.xmlstart = buffer;
#line 93
  parser.xmlsize = bufsize;
#line 94
  parser.data = (void *)data___2;
#line 95
  parser.starteltfunc = & IGDstartelt;
#line 96
  parser.endeltfunc = & IGDendelt;
#line 97
  parser.datafunc = & IGDdata;
#line 98
  parser.attfunc = (void (*)(void * , char const   * , int  , char const   * , int  ))0;
#line 99
  parsexml(& parser);
  }
#line 103
  return;
}
}
#line 110 "/home/wheatley/newnew/temp/miniupnpc-1.6/miniupnpc.c"
char *simpleUPnPcommand2(int s , char const   *url , char const   *service , char const   *action ,
                         struct UPNParg *args , int *bufsize , char const   *httpversion ) 
{ 
  char hostname[65] ;
  unsigned short port ;
  char *path ;
  char soapact[128] ;
  char soapbody[2048] ;
  char *buf ;
  int n ;
  char *p ;
  char const   *pe ;
  char const   *pv ;
  int soapbodylen ;
  char *tmp ;
  char *tmp___0 ;
  char const   *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char const   *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char const   *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  char const   *tmp___15 ;
  int tmp___16 ;
  void *tmp___17 ;

  {
  {
#line 115
  port = (unsigned short)0;
#line 122
  *bufsize = 0;
#line 123
  snprintf((char */* __restrict  */)(soapact), sizeof(soapact), (char const   */* __restrict  */)"%s#%s",
           service, action);
  }
#line 124
  if ((unsigned long )args == (unsigned long )((void *)0)) {
    {
#line 126
    snprintf((char */* __restrict  */)(soapbody), sizeof(soapbody), (char const   */* __restrict  */)"<?xml version=\"1.0\"?>\r\n<s:Envelope xmlns:s=\"http://schemas.xmlsoap.org/soap/envelope/\" s:encodingStyle=\"http://schemas.xmlsoap.org/soap/encoding/\"><s:Body><u:%s xmlns:u=\"%s\"></u:%s></s:Body></s:Envelope>\r\n",
             action, service, action);
    }
  } else {
    {
#line 142
    soapbodylen = snprintf((char */* __restrict  */)(soapbody), sizeof(soapbody),
                           (char const   */* __restrict  */)"<?xml version=\"1.0\"?>\r\n<s:Envelope xmlns:s=\"http://schemas.xmlsoap.org/soap/envelope/\" s:encodingStyle=\"http://schemas.xmlsoap.org/soap/encoding/\"><s:Body><u:%s xmlns:u=\"%s\">",
                           action, service);
#line 150
    p = soapbody + soapbodylen;
    }
    {
#line 151
    while (1) {
      while_continue: /* CIL Label */ ;
#line 151
      if (! args->elt) {
#line 151
        goto while_break;
      }
#line 154
      if ((unsigned long )(soapbody + sizeof(soapbody)) <= (unsigned long )(p + 100)) {
#line 157
        return ((char *)((void *)0));
      }
#line 159
      tmp = p;
#line 159
      p ++;
#line 159
      *tmp = (char )'<';
#line 160
      pe = args->elt;
      {
#line 161
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 161
        if (! *pe) {
#line 161
          goto while_break___0;
        }
#line 162
        tmp___0 = p;
#line 162
        p ++;
#line 162
        tmp___1 = pe;
#line 162
        pe ++;
#line 162
        *tmp___0 = (char )*tmp___1;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 163
      tmp___2 = p;
#line 163
      p ++;
#line 163
      *tmp___2 = (char )'>';
#line 164
      pv = args->val;
#line 164
      if (pv) {
        {
#line 166
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 166
          if (! *pv) {
#line 166
            goto while_break___1;
          }
#line 167
          tmp___3 = p;
#line 167
          p ++;
#line 167
          tmp___4 = pv;
#line 167
          pv ++;
#line 167
          *tmp___3 = (char )*tmp___4;
        }
        while_break___1: /* CIL Label */ ;
        }
      }
#line 169
      tmp___5 = p;
#line 169
      p ++;
#line 169
      *tmp___5 = (char )'<';
#line 170
      tmp___6 = p;
#line 170
      p ++;
#line 170
      *tmp___6 = (char )'/';
#line 171
      pe = args->elt;
      {
#line 172
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 172
        if (! *pe) {
#line 172
          goto while_break___2;
        }
#line 173
        tmp___7 = p;
#line 173
        p ++;
#line 173
        tmp___8 = pe;
#line 173
        pe ++;
#line 173
        *tmp___7 = (char )*tmp___8;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 174
      tmp___9 = p;
#line 174
      p ++;
#line 174
      *tmp___9 = (char )'>';
#line 175
      args ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 177
    tmp___10 = p;
#line 177
    p ++;
#line 177
    *tmp___10 = (char )'<';
#line 178
    tmp___11 = p;
#line 178
    p ++;
#line 178
    *tmp___11 = (char )'/';
#line 179
    tmp___12 = p;
#line 179
    p ++;
#line 179
    *tmp___12 = (char )'u';
#line 180
    tmp___13 = p;
#line 180
    p ++;
#line 180
    *tmp___13 = (char )':';
#line 181
    pe = action;
    {
#line 182
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 182
      if (! *pe) {
#line 182
        goto while_break___3;
      }
#line 183
      tmp___14 = p;
#line 183
      p ++;
#line 183
      tmp___15 = pe;
#line 183
      pe ++;
#line 183
      *tmp___14 = (char )*tmp___15;
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 184
    strncpy((char */* __restrict  */)p, (char const   */* __restrict  */)"></s:Body></s:Envelope>\r\n",
            (size_t )((soapbody + sizeof(soapbody)) - p));
    }
  }
  {
#line 187
  tmp___16 = parseURL(url, hostname, & port, & path);
  }
#line 187
  if (! tmp___16) {
#line 187
    return ((char *)((void *)0));
  }
#line 188
  if (s < 0) {
    {
#line 190
    s = connecthostport((char const   *)(hostname), port);
    }
#line 191
    if (s < 0) {
#line 193
      return ((char *)((void *)0));
    }
  }
  {
#line 197
  n = soapPostSubmit(s, (char const   *)path, (char const   *)(hostname), port, (char const   *)(soapact),
                     (char const   *)(soapbody), httpversion);
  }
#line 198
  if (n <= 0) {
    {
#line 202
    close(s);
    }
#line 203
    return ((char *)((void *)0));
  }
  {
#line 206
  tmp___17 = getHTTPResponse(s, bufsize);
#line 206
  buf = (char *)tmp___17;
#line 213
  close(s);
  }
#line 214
  return (buf);
}
}
#line 222 "/home/wheatley/newnew/temp/miniupnpc-1.6/miniupnpc.c"
char *simpleUPnPcommand(int s , char const   *url , char const   *service , char const   *action ,
                        struct UPNParg *args , int *bufsize ) 
{ 
  char *buf ;

  {
  {
#line 228
  buf = simpleUPnPcommand2(s, url, service, action, args, bufsize, "1.1");
  }
#line 239
  return (buf);
}
}
#line 247 "/home/wheatley/newnew/temp/miniupnpc-1.6/miniupnpc.c"
static void parseMSEARCHReply(char const   *reply , int size , char const   **location ,
                              int *locationsize , char const   **st , int *stsize ) 
{ 
  int a ;
  int b ;
  int i ;
  int tmp ;
  int tmp___0 ;

  {
#line 253
  i = 0;
#line 254
  a = i;
#line 255
  b = 0;
  {
#line 256
  while (1) {
    while_continue: /* CIL Label */ ;
#line 256
    if (! (i < size)) {
#line 256
      goto while_break;
    }
    {
#line 260
    if ((int const   )*(reply + i) == 58) {
#line 260
      goto case_58;
    }
#line 272
    if ((int const   )*(reply + i) == 13) {
#line 272
      goto case_13;
    }
#line 272
    if ((int const   )*(reply + i) == 10) {
#line 272
      goto case_13;
    }
#line 296
    goto switch_default;
    case_58: /* CIL Label */ 
#line 261
    if (b == 0) {
#line 263
      b = i;
    }
#line 270
    goto switch_break;
    case_13: /* CIL Label */ 
    case_10: /* CIL Label */ 
#line 273
    if (b != 0) {
      {
#line 281
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 281
        b ++;
#line 281
        if (! ((int const   )*(reply + b) == 32)) {
#line 281
          goto while_break___0;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 282
      tmp___0 = strncasecmp(reply + a, "location", (size_t )8);
      }
#line 282
      if (0 == tmp___0) {
#line 284
        *location = reply + b;
#line 285
        *locationsize = i - b;
      } else {
        {
#line 287
        tmp = strncasecmp(reply + a, "st", (size_t )2);
        }
#line 287
        if (0 == tmp) {
#line 289
          *st = reply + b;
#line 290
          *stsize = i - b;
        }
      }
#line 292
      b = 0;
    }
#line 294
    a = i + 1;
#line 295
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 297
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 299
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 301
  return;
}
}
#line 326 "/home/wheatley/newnew/temp/miniupnpc-1.6/miniupnpc.c"
static char const   MSearchMsgFmt[77]  = 
#line 326
  {      (char const   )'M',      (char const   )'-',      (char const   )'S',      (char const   )'E', 
        (char const   )'A',      (char const   )'R',      (char const   )'C',      (char const   )'H', 
        (char const   )' ',      (char const   )'*',      (char const   )' ',      (char const   )'H', 
        (char const   )'T',      (char const   )'T',      (char const   )'P',      (char const   )'/', 
        (char const   )'1',      (char const   )'.',      (char const   )'1',      (char const   )'\r', 
        (char const   )'\n',      (char const   )'H',      (char const   )'O',      (char const   )'S', 
        (char const   )'T',      (char const   )':',      (char const   )' ',      (char const   )'%', 
        (char const   )'s',      (char const   )':',      (char const   )'1',      (char const   )'9', 
        (char const   )'0',      (char const   )'0',      (char const   )'\r',      (char const   )'\n', 
        (char const   )'S',      (char const   )'T',      (char const   )':',      (char const   )' ', 
        (char const   )'%',      (char const   )'s',      (char const   )'\r',      (char const   )'\n', 
        (char const   )'M',      (char const   )'A',      (char const   )'N',      (char const   )':', 
        (char const   )' ',      (char const   )'\"',      (char const   )'s',      (char const   )'s', 
        (char const   )'d',      (char const   )'p',      (char const   )':',      (char const   )'d', 
        (char const   )'i',      (char const   )'s',      (char const   )'c',      (char const   )'o', 
        (char const   )'v',      (char const   )'e',      (char const   )'r',      (char const   )'\"', 
        (char const   )'\r',      (char const   )'\n',      (char const   )'M',      (char const   )'X', 
        (char const   )':',      (char const   )' ',      (char const   )'%',      (char const   )'u', 
        (char const   )'\r',      (char const   )'\n',      (char const   )'\r',      (char const   )'\n', 
        (char const   )'\000'};
#line 333 "/home/wheatley/newnew/temp/miniupnpc-1.6/miniupnpc.c"
static char const   * const  deviceList[5]  = {      (char const   */* const  */)"urn:schemas-upnp-org:device:InternetGatewayDevice:1",      (char const   */* const  */)"urn:schemas-upnp-org:service:WANIPConnection:1",      (char const   */* const  */)"urn:schemas-upnp-org:service:WANPPPConnection:1",      (char const   */* const  */)"upnp:rootdevice", 
        (char const   */* const  */)0};
#line 317 "/home/wheatley/newnew/temp/miniupnpc-1.6/miniupnpc.c"
struct UPNPDev *upnpDiscover(int delay , char const   *multicastif , char const   *minissdpdsock ,
                             int sameport , int ipv6 , int *error ) 
{ 
  struct UPNPDev *tmp ;
  struct UPNPDev *devlist ;
  int opt ;
  int deviceIndex ;
  char bufr[1536] ;
  int sudp ;
  int n ;
  struct sockaddr_storage sockudp_r ;
  unsigned int mx ;
  int rv ;
  struct addrinfo hints ;
  struct addrinfo *servinfo ;
  struct addrinfo *p ;
  int linklocal ;
  char *tmp___0 ;
  int tmp___1 ;
  struct sockaddr_in6 *p___0 ;
  struct sockaddr_in *p___1 ;
  int tmp___2 ;
  unsigned int ifindex ;
  unsigned int tmp___3 ;
  int tmp___4 ;
  struct in_addr mc_if ;
  int tmp___5 ;
  unsigned long tmp___6 ;
  int tmp___7 ;
  char const   *tmp___8 ;
  char const   *tmp___9 ;
  char const   *tmp___10 ;
  char const   *tmp___11 ;
  char const   *tmp___12 ;
  ssize_t tmp___13 ;
  char const   *descURL ;
  int urlsize ;
  char const   *st ;
  int stsize ;
  int tmp___14 ;
  int tmp___15 ;
  void *tmp___16 ;

  {
#line 324
  devlist = (struct UPNPDev *)0;
#line 325
  opt = 1;
#line 344
  deviceIndex = 0;
#line 359
  linklocal = 1;
#line 361
  if (error) {
#line 362
    *error = -1;
  }
#line 365
  if (! minissdpdsock) {
#line 366
    minissdpdsock = "/var/run/minissdpd.sock";
  }
  {
#line 367
  while (1) {
    while_continue: /* CIL Label */ ;
#line 367
    if (! devlist) {
#line 367
      if (! deviceList[deviceIndex]) {
#line 367
        goto while_break;
      }
    } else {
#line 367
      goto while_break;
    }
    {
#line 368
    devlist = getDevicesFromMiniSSDPD((char const   *)deviceList[deviceIndex], minissdpdsock);
    }
#line 371
    if (devlist) {
      {
#line 371
      tmp___0 = strstr((char const   *)deviceList[deviceIndex], "rootdevice");
      }
#line 371
      if (! tmp___0) {
#line 372
        if (error) {
#line 373
          *error = 0;
        }
#line 374
        return (devlist);
      }
    }
#line 376
    deviceIndex ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 378
  deviceIndex = 0;
#line 384
  if (ipv6) {
#line 384
    tmp___1 = 10;
  } else {
#line 384
    tmp___1 = 2;
  }
  {
#line 384
  sudp = socket(tmp___1, 2, 0);
  }
#line 386
  if (sudp < 0) {
#line 388
    if (error) {
#line 389
      *error = -101;
    }
    {
#line 390
    perror("socket");
    }
#line 391
    return ((struct UPNPDev *)((void *)0));
  }
  {
#line 394
  memset((void *)(& sockudp_r), 0, sizeof(struct sockaddr_storage ));
  }
#line 395
  if (ipv6) {
#line 396
    p___0 = (struct sockaddr_in6 *)(& sockudp_r);
#line 397
    p___0->sin6_family = (sa_family_t )10;
#line 398
    if (sameport) {
      {
#line 399
      p___0->sin6_port = htons((uint16_t )1900);
      }
    }
#line 400
    p___0->sin6_addr = (struct in6_addr )in6addr_any;
  } else {
#line 402
    p___1 = (struct sockaddr_in *)(& sockudp_r);
#line 403
    p___1->sin_family = (sa_family_t )2;
#line 404
    if (sameport) {
      {
#line 405
      p___1->sin_port = htons((uint16_t )1900);
      }
    }
#line 406
    p___1->sin_addr.s_addr = (in_addr_t )0;
  }
  {
#line 471
  tmp___2 = setsockopt(sudp, 1, 2, (void const   *)(& opt), (socklen_t )sizeof(opt));
  }
#line 471
  if (tmp___2 < 0) {
#line 474
    if (error) {
#line 475
      *error = -101;
    }
    {
#line 476
    perror("setsockopt");
    }
#line 477
    return ((struct UPNPDev *)((void *)0));
  }
#line 480
  if (multicastif) {
#line 482
    if (ipv6) {
      {
#line 487
      tmp___3 = if_nametoindex(multicastif);
#line 487
      ifindex = tmp___3;
#line 488
      tmp___4 = setsockopt(sudp, 41, 17, (void const   *)(& ifindex), (socklen_t )sizeof(& ifindex));
      }
#line 488
      if (tmp___4 < 0) {
        {
#line 490
        perror("setsockopt");
        }
      }
    } else {
      {
#line 499
      mc_if.s_addr = inet_addr(multicastif);
#line 500
      ((struct sockaddr_in *)(& sockudp_r))->sin_addr.s_addr = mc_if.s_addr;
#line 501
      tmp___5 = setsockopt(sudp, 0, 32, (void const   *)((char const   *)(& mc_if)),
                           (socklen_t )sizeof(mc_if));
      }
#line 501
      if (tmp___5 < 0) {
        {
#line 503
        perror("setsockopt");
        }
      }
    }
  }
#line 509
  if (ipv6) {
#line 509
    tmp___6 = sizeof(struct sockaddr_in6 );
  } else {
#line 509
    tmp___6 = sizeof(struct sockaddr_in );
  }
  {
#line 509
  tmp___7 = bind(sudp, (struct sockaddr  const  *)(& sockudp_r), (socklen_t )tmp___6);
  }
#line 509
  if (tmp___7 != 0) {
#line 512
    if (error) {
#line 513
      *error = -101;
    }
    {
#line 514
    perror("bind");
#line 515
    close(sudp);
    }
#line 516
    return ((struct UPNPDev *)((void *)0));
  }
#line 519
  if (error) {
#line 520
    *error = 0;
  }
#line 522
  mx = (unsigned int )delay / 1000U;
#line 524
  n = 0;
  {
#line 524
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 524
    if (! deviceList[deviceIndex]) {
#line 524
      goto while_break___0;
    }
#line 526
    if (n == 0) {
#line 529
      if (ipv6) {
#line 529
        if (linklocal) {
#line 529
          tmp___8 = "[FF02::C]";
        } else {
#line 529
          tmp___8 = "[FF05::C]";
        }
#line 529
        tmp___9 = tmp___8;
      } else {
#line 529
        tmp___9 = "239.255.255.250";
      }
      {
#line 529
      n = snprintf((char */* __restrict  */)(bufr), sizeof(bufr), (char const   */* __restrict  */)(MSearchMsgFmt),
                   tmp___9, deviceList[deviceIndex], mx);
#line 565
      memset((void *)(& hints), 0, sizeof(hints));
#line 566
      hints.ai_family = 0;
#line 567
      hints.ai_socktype = 2;
      }
#line 569
      if (ipv6) {
#line 569
        if (linklocal) {
#line 569
          tmp___11 = "FF02::C";
        } else {
#line 569
          tmp___11 = "FF05::C";
        }
#line 569
        tmp___12 = tmp___11;
      } else {
#line 569
        tmp___12 = "239.255.255.250";
      }
      {
#line 569
      rv = getaddrinfo((char const   */* __restrict  */)tmp___12, (char const   */* __restrict  */)"1900",
                       (struct addrinfo  const  */* __restrict  */)(& hints), (struct addrinfo **/* __restrict  */)(& servinfo));
      }
#line 569
      if (rv != 0) {
#line 573
        if (error) {
#line 574
          *error = -101;
        }
        {
#line 578
        tmp___10 = gai_strerror(rv);
#line 578
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"getaddrinfo: %s\n",
                tmp___10);
        }
#line 580
        goto while_break___0;
      }
#line 582
      p = servinfo;
      {
#line 582
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 582
        if (! p) {
#line 582
          goto while_break___1;
        }
        {
#line 583
        tmp___13 = sendto(sudp, (void const   *)(bufr), (size_t )n, 0, (struct sockaddr  const  *)p->ai_addr,
                          p->ai_addrlen);
#line 583
        n = (int )tmp___13;
        }
#line 584
        if (n < 0) {
          {
#line 585
          perror("sendto");
          }
#line 586
          goto __Cont;
        }
        __Cont: /* CIL Label */ 
#line 582
        p = p->ai_next;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 589
      freeaddrinfo(servinfo);
      }
#line 590
      if (n < 0) {
#line 591
        if (error) {
#line 592
          *error = -101;
        }
#line 593
        goto while_break___0;
      }
    }
    {
#line 598
    n = receivedata(sudp, bufr, (int )sizeof(bufr), delay);
    }
#line 599
    if (n < 0) {
#line 601
      if (error) {
#line 602
        *error = -101;
      }
#line 603
      goto while_break___0;
    } else
#line 604
    if (n == 0) {
#line 606
      if (devlist) {
#line 608
        if (error) {
#line 609
          *error = 0;
        }
#line 610
        goto while_break___0;
      }
#line 612
      if (ipv6) {
#line 613
        if (linklocal) {
#line 614
          linklocal = 0;
#line 615
          deviceIndex --;
        } else {
#line 617
          linklocal = 1;
        }
      }
    } else {
      {
#line 621
      descURL = (char const   *)((void *)0);
#line 622
      urlsize = 0;
#line 623
      st = (char const   *)((void *)0);
#line 624
      stsize = 0;
#line 626
      parseMSEARCHReply((char const   *)(bufr), n, & descURL, & urlsize, & st, & stsize);
      }
#line 627
      if (st) {
#line 627
        if (descURL) {
#line 633
          tmp = devlist;
          {
#line 633
          while (1) {
            while_continue___2: /* CIL Label */ ;
#line 633
            if (! tmp) {
#line 633
              goto while_break___2;
            }
            {
#line 634
            tmp___14 = memcmp((void const   *)tmp->descURL, (void const   *)descURL,
                              (size_t )urlsize);
            }
#line 634
            if (tmp___14 == 0) {
#line 634
              if ((int )*(tmp->descURL + urlsize) == 0) {
                {
#line 634
                tmp___15 = memcmp((void const   *)tmp->st, (void const   *)st, (size_t )stsize);
                }
#line 634
                if (tmp___15 == 0) {
#line 634
                  if ((int )*(tmp->st + stsize) == 0) {
#line 638
                    goto while_break___2;
                  }
                }
              }
            }
#line 633
            tmp = tmp->pNext;
          }
          while_break___2: /* CIL Label */ ;
          }
#line 642
          if (tmp) {
#line 643
            goto __Cont___0;
          }
          {
#line 644
          tmp___16 = malloc((sizeof(struct UPNPDev ) + (unsigned long )urlsize) + (unsigned long )stsize);
#line 644
          tmp = (struct UPNPDev *)tmp___16;
          }
#line 645
          if (! tmp) {
#line 647
            if (error) {
#line 648
              *error = -102;
            }
#line 649
            goto while_break___0;
          }
          {
#line 651
          tmp->pNext = devlist;
#line 652
          tmp->descURL = tmp->buffer;
#line 653
          tmp->st = (tmp->buffer + 1) + urlsize;
#line 654
          memcpy((void */* __restrict  */)(tmp->buffer), (void const   */* __restrict  */)descURL,
                 (size_t )urlsize);
#line 655
          tmp->buffer[urlsize] = (char )'\000';
#line 656
          memcpy((void */* __restrict  */)((tmp->buffer + urlsize) + 1), (void const   */* __restrict  */)st,
                 (size_t )stsize);
#line 657
          tmp->buffer[(urlsize + 1) + stsize] = (char )'\000';
#line 658
          devlist = tmp;
          }
        }
      }
    }
    __Cont___0: /* CIL Label */ 
#line 524
    deviceIndex ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 662
  close(sudp);
  }
#line 663
  return (devlist);
}
}
#line 668 "/home/wheatley/newnew/temp/miniupnpc-1.6/miniupnpc.c"
void freeUPNPDevlist(struct UPNPDev *devlist ) 
{ 
  struct UPNPDev *next ;

  {
  {
#line 671
  while (1) {
    while_continue: /* CIL Label */ ;
#line 671
    if (! devlist) {
#line 671
      goto while_break;
    }
    {
#line 673
    next = devlist->pNext;
#line 674
    free((void *)devlist);
#line 675
    devlist = next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 677
  return;
}
}
#line 679 "/home/wheatley/newnew/temp/miniupnpc-1.6/miniupnpc.c"
static void url_cpy_or_cat(char *dst , char const   *src , int n ) 
{ 
  int l ;
  size_t tmp ;
  int tmp___0 ;

  {
#line 682
  if ((int const   )*(src + 0) == 104) {
#line 682
    if ((int const   )*(src + 1) == 116) {
#line 682
      if ((int const   )*(src + 2) == 116) {
#line 682
        if ((int const   )*(src + 3) == 112) {
#line 682
          if ((int const   )*(src + 4) == 58) {
#line 682
            if ((int const   )*(src + 5) == 47) {
#line 682
              if ((int const   )*(src + 6) == 47) {
                {
#line 690
                strncpy((char */* __restrict  */)dst, (char const   */* __restrict  */)src,
                        (size_t )n);
                }
              } else {
#line 682
                goto _L___4;
              }
            } else {
#line 682
              goto _L___4;
            }
          } else {
#line 682
            goto _L___4;
          }
        } else {
#line 682
          goto _L___4;
        }
      } else {
#line 682
        goto _L___4;
      }
    } else {
#line 682
      goto _L___4;
    }
  } else {
    _L___4: /* CIL Label */ 
    {
#line 694
    tmp = strlen((char const   *)dst);
#line 694
    l = (int )tmp;
    }
#line 695
    if ((int const   )*(src + 0) != 47) {
#line 696
      tmp___0 = l;
#line 696
      l ++;
#line 696
      *(dst + tmp___0) = (char )'/';
    }
#line 697
    if (l <= n) {
      {
#line 698
      strncpy((char */* __restrict  */)(dst + l), (char const   */* __restrict  */)src,
              (size_t )(n - l));
      }
    }
  }
#line 700
  return;
}
}
#line 704 "/home/wheatley/newnew/temp/miniupnpc-1.6/miniupnpc.c"
void GetUPNPUrls(struct UPNPUrls *urls , struct IGDdatas *data___2 , char const   *descURL ) 
{ 
  char *p ;
  int n1 ;
  int n2 ;
  int n3 ;
  int n4 ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;

  {
  {
#line 709
  tmp = strlen((char const   *)(data___2->urlbase));
#line 709
  n1 = (int )tmp;
  }
#line 710
  if (n1 == 0) {
    {
#line 711
    tmp___0 = strlen(descURL);
#line 711
    n1 = (int )tmp___0;
    }
  }
  {
#line 712
  n1 += 2;
#line 713
  n2 = n1;
#line 713
  n3 = n1;
#line 713
  n4 = n1;
#line 714
  tmp___1 = strlen((char const   *)(data___2->first.scpdurl));
#line 714
  n1 = (int )((size_t )n1 + tmp___1);
#line 715
  tmp___2 = strlen((char const   *)(data___2->first.controlurl));
#line 715
  n2 = (int )((size_t )n2 + tmp___2);
#line 716
  tmp___3 = strlen((char const   *)(data___2->CIF.controlurl));
#line 716
  n3 = (int )((size_t )n3 + tmp___3);
#line 717
  tmp___4 = strlen((char const   *)(data___2->IPv6FC.controlurl));
#line 717
  n4 = (int )((size_t )n4 + tmp___4);
#line 719
  tmp___5 = malloc((size_t )n1);
#line 719
  urls->ipcondescURL = (char *)tmp___5;
#line 720
  tmp___6 = malloc((size_t )n2);
#line 720
  urls->controlURL = (char *)tmp___6;
#line 721
  tmp___7 = malloc((size_t )n3);
#line 721
  urls->controlURL_CIF = (char *)tmp___7;
#line 722
  tmp___8 = malloc((size_t )n4);
#line 722
  urls->controlURL_6FC = (char *)tmp___8;
  }
#line 724
  if ((int )data___2->urlbase[0] != 0) {
    {
#line 725
    strncpy((char */* __restrict  */)urls->ipcondescURL, (char const   */* __restrict  */)(data___2->urlbase),
            (size_t )n1);
    }
  } else {
    {
#line 727
    strncpy((char */* __restrict  */)urls->ipcondescURL, (char const   */* __restrict  */)descURL,
            (size_t )n1);
    }
  }
  {
#line 728
  p = strchr((char const   *)(urls->ipcondescURL + 7), '/');
  }
#line 729
  if (p) {
#line 729
    *(p + 0) = (char )'\000';
  }
  {
#line 730
  strncpy((char */* __restrict  */)urls->controlURL, (char const   */* __restrict  */)urls->ipcondescURL,
          (size_t )n2);
#line 731
  strncpy((char */* __restrict  */)urls->controlURL_CIF, (char const   */* __restrict  */)urls->ipcondescURL,
          (size_t )n3);
#line 732
  strncpy((char */* __restrict  */)urls->controlURL_6FC, (char const   */* __restrict  */)urls->ipcondescURL,
          (size_t )n4);
#line 734
  url_cpy_or_cat(urls->ipcondescURL, (char const   *)(data___2->first.scpdurl), n1);
#line 736
  url_cpy_or_cat(urls->controlURL, (char const   *)(data___2->first.controlurl), n2);
#line 738
  url_cpy_or_cat(urls->controlURL_CIF, (char const   *)(data___2->CIF.controlurl),
                 n3);
#line 740
  url_cpy_or_cat(urls->controlURL_6FC, (char const   *)(data___2->IPv6FC.controlurl),
                 n4);
  }
#line 752
  return;
}
}
#line 754 "/home/wheatley/newnew/temp/miniupnpc-1.6/miniupnpc.c"
void FreeUPNPUrls(struct UPNPUrls *urls ) 
{ 


  {
#line 757
  if (! urls) {
#line 758
    return;
  }
  {
#line 759
  free((void *)urls->controlURL);
#line 760
  urls->controlURL = (char *)0;
#line 761
  free((void *)urls->ipcondescURL);
#line 762
  urls->ipcondescURL = (char *)0;
#line 763
  free((void *)urls->controlURL_CIF);
#line 764
  urls->controlURL_CIF = (char *)0;
#line 765
  free((void *)urls->controlURL_6FC);
#line 766
  urls->controlURL_6FC = (char *)0;
  }
#line 767
  return;
}
}
#line 769 "/home/wheatley/newnew/temp/miniupnpc-1.6/miniupnpc.c"
int UPNPIGD_IsConnected(struct UPNPUrls *urls , struct IGDdatas *data___2 ) 
{ 
  char status[64] ;
  unsigned int uptime ;
  int tmp ;

  {
  {
#line 774
  status[0] = (char )'\000';
#line 775
  UPNP_GetStatusInfo((char const   *)urls->controlURL, (char const   *)(data___2->first.servicetype),
                     status, & uptime, (char *)((void *)0));
#line 777
  tmp = strcmp("Connected", (char const   *)(status));
  }
#line 777
  if (0 == tmp) {
#line 779
    return (1);
  } else {
#line 782
    return (0);
  }
}
}
#line 798 "/home/wheatley/newnew/temp/miniupnpc-1.6/miniupnpc.c"
int UPNP_GetValidIGD(struct UPNPDev *devlist , struct UPNPUrls *urls , struct IGDdatas *data___2 ,
                     char *lanaddr , int lanaddrlen ) 
{ 
  char *descXML ;
  int descXMLsize ;
  struct UPNPDev *dev ;
  int ndev ;
  int state ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 805
  descXMLsize = 0;
#line 807
  ndev = 0;
#line 809
  if (! devlist) {
#line 814
    return (0);
  }
#line 816
  state = 1;
  {
#line 816
  while (1) {
    while_continue: /* CIL Label */ ;
#line 816
    if (! (state <= 3)) {
#line 816
      goto while_break;
    }
#line 818
    dev = devlist;
    {
#line 818
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 818
      if (! dev) {
#line 818
        goto while_break___0;
      }
      {
#line 822
      tmp = miniwget_getaddr((char const   *)dev->descURL, & descXMLsize, lanaddr,
                             lanaddrlen);
#line 822
      descXML = (char *)tmp;
      }
#line 824
      if (descXML) {
        {
#line 826
        ndev ++;
#line 827
        memset((void *)data___2, 0, sizeof(struct IGDdatas ));
#line 828
        memset((void *)urls, 0, sizeof(struct UPNPUrls ));
#line 829
        parserootdesc((char const   *)descXML, descXMLsize, data___2);
#line 830
        free((void *)descXML);
#line 831
        descXML = (char *)((void *)0);
#line 832
        tmp___2 = strcmp((char const   *)(data___2->CIF.servicetype), "urn:schemas-upnp-org:service:WANCommonInterfaceConfig:1");
        }
#line 832
        if (0 == tmp___2) {
#line 832
          goto _L;
        } else
#line 832
        if (state >= 3) {
          _L: /* CIL Label */ 
          {
#line 836
          GetUPNPUrls(urls, data___2, (char const   *)dev->descURL);
          }
#line 843
          if (state >= 2) {
#line 844
            return (state);
          } else {
            {
#line 843
            tmp___0 = UPNPIGD_IsConnected(urls, data___2);
            }
#line 843
            if (tmp___0) {
#line 844
              return (state);
            }
          }
          {
#line 845
          FreeUPNPUrls(urls);
          }
#line 846
          if ((int )data___2->second.servicetype[0] != 0) {
            {
#line 852
            memcpy((void */* __restrict  */)(& data___2->tmp), (void const   */* __restrict  */)(& data___2->first),
                   sizeof(struct IGDdatas_service ));
#line 853
            memcpy((void */* __restrict  */)(& data___2->first), (void const   */* __restrict  */)(& data___2->second),
                   sizeof(struct IGDdatas_service ));
#line 854
            memcpy((void */* __restrict  */)(& data___2->second), (void const   */* __restrict  */)(& data___2->tmp),
                   sizeof(struct IGDdatas_service ));
#line 855
            GetUPNPUrls(urls, data___2, (char const   *)dev->descURL);
            }
#line 861
            if (state >= 2) {
#line 862
              return (state);
            } else {
              {
#line 861
              tmp___1 = UPNPIGD_IsConnected(urls, data___2);
              }
#line 861
              if (tmp___1) {
#line 862
                return (state);
              }
            }
            {
#line 863
            FreeUPNPUrls(urls);
            }
          }
        }
        {
#line 866
        memset((void *)data___2, 0, sizeof(struct IGDdatas ));
        }
      }
#line 818
      dev = dev->pNext;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 816
    state ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 876
  return (0);
}
}
#line 884 "/home/wheatley/newnew/temp/miniupnpc-1.6/miniupnpc.c"
int UPNP_GetIGDFromUrl(char const   *rootdescurl , struct UPNPUrls *urls , struct IGDdatas *data___2 ,
                       char *lanaddr , int lanaddrlen ) 
{ 
  char *descXML ;
  int descXMLsize ;
  void *tmp ;

  {
  {
#line 891
  descXMLsize = 0;
#line 892
  tmp = miniwget_getaddr(rootdescurl, & descXMLsize, lanaddr, lanaddrlen);
#line 892
  descXML = (char *)tmp;
  }
#line 894
  if (descXML) {
    {
#line 895
    memset((void *)data___2, 0, sizeof(struct IGDdatas ));
#line 896
    memset((void *)urls, 0, sizeof(struct UPNPUrls ));
#line 897
    parserootdesc((char const   *)descXML, descXMLsize, data___2);
#line 898
    free((void *)descXML);
#line 899
    descXML = (char *)((void *)0);
#line 900
    GetUPNPUrls(urls, data___2, rootdescurl);
    }
#line 901
    return (1);
  } else {
#line 903
    return (0);
  }
}
}
#line 20 "/home/wheatley/newnew/temp/miniupnpc-1.6/upnperrors.h"
char const   *strupnperror(int err ) ;
#line 14 "/home/wheatley/newnew/temp/miniupnpc-1.6/upnperrors.c"
char const   *strupnperror(int err ) 
{ 
  char const   *s ;

  {
#line 16
  s = (char const   *)((void *)0);
  {
#line 18
  if (err == 0) {
#line 18
    goto case_0;
  }
#line 21
  if (err == -1) {
#line 21
    goto case_neg_1;
  }
#line 24
  if (err == -2) {
#line 24
    goto case_neg_2;
  }
#line 27
  if (err == -101) {
#line 27
    goto case_neg_101;
  }
#line 30
  if (err == -102) {
#line 30
    goto case_neg_102;
  }
#line 33
  if (err == 401) {
#line 33
    goto case_401;
  }
#line 36
  if (err == 402) {
#line 36
    goto case_402;
  }
#line 39
  if (err == 501) {
#line 39
    goto case_501;
  }
#line 42
  if (err == 606) {
#line 42
    goto case_606;
  }
#line 45
  if (err == 701) {
#line 45
    goto case_701;
  }
#line 48
  if (err == 702) {
#line 48
    goto case_702;
  }
#line 51
  if (err == 703) {
#line 51
    goto case_703;
  }
#line 54
  if (err == 704) {
#line 54
    goto case_704;
  }
#line 57
  if (err == 705) {
#line 57
    goto case_705;
  }
#line 60
  if (err == 706) {
#line 60
    goto case_706;
  }
#line 63
  if (err == 707) {
#line 63
    goto case_707;
  }
#line 66
  if (err == 708) {
#line 66
    goto case_708;
  }
#line 69
  if (err == 709) {
#line 69
    goto case_709;
  }
#line 72
  if (err == 713) {
#line 72
    goto case_713;
  }
#line 75
  if (err == 714) {
#line 75
    goto case_714;
  }
#line 78
  if (err == 715) {
#line 78
    goto case_715;
  }
#line 81
  if (err == 716) {
#line 81
    goto case_716;
  }
#line 84
  if (err == 718) {
#line 84
    goto case_718;
  }
#line 87
  if (err == 724) {
#line 87
    goto case_724;
  }
#line 90
  if (err == 725) {
#line 90
    goto case_725;
  }
#line 93
  if (err == 726) {
#line 93
    goto case_726;
  }
#line 96
  if (err == 727) {
#line 96
    goto case_727;
  }
#line 99
  goto switch_default;
  case_0: /* CIL Label */ 
#line 19
  s = "Success";
#line 20
  goto switch_break;
  case_neg_1: /* CIL Label */ 
#line 22
  s = "Miniupnpc Unknown Error";
#line 23
  goto switch_break;
  case_neg_2: /* CIL Label */ 
#line 25
  s = "Miniupnpc Invalid Arguments";
#line 26
  goto switch_break;
  case_neg_101: /* CIL Label */ 
#line 28
  s = "Miniupnpc Socket error";
#line 29
  goto switch_break;
  case_neg_102: /* CIL Label */ 
#line 31
  s = "Miniupnpc Memory allocation error";
#line 32
  goto switch_break;
  case_401: /* CIL Label */ 
#line 34
  s = "Invalid Action";
#line 35
  goto switch_break;
  case_402: /* CIL Label */ 
#line 37
  s = "Invalid Args";
#line 38
  goto switch_break;
  case_501: /* CIL Label */ 
#line 40
  s = "Action Failed";
#line 41
  goto switch_break;
  case_606: /* CIL Label */ 
#line 43
  s = "Action not authorized";
#line 44
  goto switch_break;
  case_701: /* CIL Label */ 
#line 46
  s = "PinholeSpaceExhausted";
#line 47
  goto switch_break;
  case_702: /* CIL Label */ 
#line 49
  s = "FirewallDisabled";
#line 50
  goto switch_break;
  case_703: /* CIL Label */ 
#line 52
  s = "InboundPinholeNotAllowed";
#line 53
  goto switch_break;
  case_704: /* CIL Label */ 
#line 55
  s = "NoSuchEntry";
#line 56
  goto switch_break;
  case_705: /* CIL Label */ 
#line 58
  s = "ProtocolNotSupported";
#line 59
  goto switch_break;
  case_706: /* CIL Label */ 
#line 61
  s = "InternalPortWildcardingNotAllowed";
#line 62
  goto switch_break;
  case_707: /* CIL Label */ 
#line 64
  s = "ProtocolWildcardingNotAllowed";
#line 65
  goto switch_break;
  case_708: /* CIL Label */ 
#line 67
  s = "WildcardNotPermittedInSrcIP";
#line 68
  goto switch_break;
  case_709: /* CIL Label */ 
#line 70
  s = "NoPacketSent";
#line 71
  goto switch_break;
  case_713: /* CIL Label */ 
#line 73
  s = "SpecifiedArrayIndexInvalid";
#line 74
  goto switch_break;
  case_714: /* CIL Label */ 
#line 76
  s = "NoSuchEntryInArray";
#line 77
  goto switch_break;
  case_715: /* CIL Label */ 
#line 79
  s = "WildCardNotPermittedInSrcIP";
#line 80
  goto switch_break;
  case_716: /* CIL Label */ 
#line 82
  s = "WildCardNotPermittedInExtPort";
#line 83
  goto switch_break;
  case_718: /* CIL Label */ 
#line 85
  s = "ConflictInMappingEntry";
#line 86
  goto switch_break;
  case_724: /* CIL Label */ 
#line 88
  s = "SamePortValuesRequired";
#line 89
  goto switch_break;
  case_725: /* CIL Label */ 
#line 91
  s = "OnlyPermanentLeasesSupported";
#line 92
  goto switch_break;
  case_726: /* CIL Label */ 
#line 94
  s = "RemoteHostOnlySupportsWildcard";
#line 95
  goto switch_break;
  case_727: /* CIL Label */ 
#line 97
  s = "ExternalPortOnlySupportsWildcard";
#line 98
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 100
  s = (char const   *)((void *)0);
  switch_break: /* CIL Label */ ;
  }
#line 102
  return (s);
}
}
#line 156 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern ssize_t recv(int __fd , void *__buf , size_t __n , int __flags ) ;
#line 57 "/usr/include/x86_64-linux-gnu/sys/poll.h"
extern int poll(struct pollfd *__fds , nfds_t __nfds , int __timeout ) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 35 "/home/wheatley/newnew/temp/miniupnpc-1.6/receivedata.c"
int receivedata(int socket___0 , char *data___2 , int length , int timeout ) 
{ 
  int n ;
  struct pollfd fds[1] ;
  int *tmp ;
  ssize_t tmp___0 ;

  {
  {
#line 43
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 45
    fds[0].fd = socket___0;
#line 46
    fds[0].events = (short)1;
#line 47
    n = poll(fds, (nfds_t )1, timeout);
    }
#line 43
    if (n < 0) {
      {
#line 43
      tmp = __errno_location();
      }
#line 43
      if (! (*tmp == 4)) {
#line 43
        goto while_break;
      }
    } else {
#line 43
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 51
  if (n < 0) {
    {
#line 52
    perror("poll");
    }
#line 53
    return (-1);
  } else
#line 54
  if (n == 0) {
#line 56
    return (0);
  }
  {
#line 74
  tmp___0 = recv(socket___0, (void *)data___2, (size_t )length, 0);
#line 74
  n = (int )tmp___0;
  }
#line 75
  if (n < 0) {
    {
#line 76
    perror("recv");
    }
  }
#line 78
  return (n);
}
}
#line 468 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) calloc)(size_t __nmemb ,
                                                                               size_t __size )  __attribute__((__malloc__)) ;
#line 60 "/home/wheatley/newnew/temp/miniupnpc-1.6/portlistingparse.h"
void ParsePortListing(char const   *buffer , int bufsize , struct PortMappingParserData *pdata ) ;
#line 64
void FreePortListing(struct PortMappingParserData *pdata ) ;
#line 13 "/home/wheatley/newnew/temp/miniupnpc-1.6/portlistingparse.c"
static struct __anonstruct_elements_23  const  elements[10]  = 
#line 13 "/home/wheatley/newnew/temp/miniupnpc-1.6/portlistingparse.c"
  {      {(portMappingElt const   )1, (char const   */* const  */)"PortMappingEntry"}, 
        {(portMappingElt const   )2,
      (char const   */* const  */)"NewRemoteHost"}, 
        {(portMappingElt const   )3, (char const   */* const  */)"NewExternalPort"}, 
        {(portMappingElt const   )4, (char const   */* const  */)"NewProtocol"}, 
        {(portMappingElt const   )5, (char const   */* const  */)"NewInternalPort"}, 
        {(portMappingElt const   )6, (char const   */* const  */)"NewInternalClient"}, 
        {(portMappingElt const   )7,
      (char const   */* const  */)"NewEnabled"}, 
        {(portMappingElt const   )8, (char const   */* const  */)"NewDescription"}, 
        {(portMappingElt const   )9, (char const   */* const  */)"NewLeaseTime"}, 
        {(portMappingElt const   )0, (char const   */* const  */)((void *)0)}};
#line 30 "/home/wheatley/newnew/temp/miniupnpc-1.6/portlistingparse.c"
static unsigned int atoui(char const   *p , int l ) 
{ 
  unsigned int r ;

  {
#line 33
  r = 0U;
  {
#line 34
  while (1) {
    while_continue: /* CIL Label */ ;
#line 34
    if (l > 0) {
#line 34
      if (! *p) {
#line 34
        goto while_break;
      }
    } else {
#line 34
      goto while_break;
    }
#line 36
    if ((int const   )*p >= 48) {
#line 36
      if ((int const   )*p <= 57) {
#line 37
        r = r * 10U + (unsigned int )((int const   )*p - 48);
      } else {
#line 39
        goto while_break;
      }
    } else {
#line 39
      goto while_break;
    }
#line 40
    p ++;
#line 41
    l --;
  }
  while_break: /* CIL Label */ ;
  }
#line 43
  return (r);
}
}
#line 47 "/home/wheatley/newnew/temp/miniupnpc-1.6/portlistingparse.c"
static void startelt(void *d , char const   *name , int l ) 
{ 
  int i ;
  struct PortMappingParserData *pdata ;
  int tmp ;
  struct PortMapping *pm ;
  void *tmp___0 ;
  struct PortMapping *tmp___1 ;

  {
#line 51
  pdata = (struct PortMappingParserData *)d;
#line 52
  pdata->curelt = (portMappingElt )0;
#line 53
  i = 0;
  {
#line 53
  while (1) {
    while_continue: /* CIL Label */ ;
#line 53
    if (! elements[i].str) {
#line 53
      goto while_break;
    }
    {
#line 55
    tmp = memcmp((void const   *)name, (void const   *)elements[i].str, (size_t )l);
    }
#line 55
    if (tmp == 0) {
#line 57
      pdata->curelt = (portMappingElt )elements[i].code;
#line 58
      goto while_break;
    }
#line 53
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 61
  if ((unsigned int )pdata->curelt == 1U) {
    {
#line 64
    tmp___0 = calloc((size_t )1, sizeof(struct PortMapping ));
#line 64
    pm = (struct PortMapping *)tmp___0;
    }
    {
#line 65
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 65
      tmp___1 = pdata->head.lh_first;
#line 65
      pm->entries.le_next = tmp___1;
#line 65
      if ((unsigned long )tmp___1 != (unsigned long )((void *)0)) {
#line 65
        (pdata->head.lh_first)->entries.le_prev = & pm->entries.le_next;
      }
#line 65
      pdata->head.lh_first = pm;
#line 65
      pm->entries.le_prev = & pdata->head.lh_first;
#line 65
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 67
  return;
}
}
#line 70 "/home/wheatley/newnew/temp/miniupnpc-1.6/portlistingparse.c"
static void endelt(void *d , char const   *name , int l ) 
{ 
  struct PortMappingParserData *pdata ;

  {
#line 73
  pdata = (struct PortMappingParserData *)d;
#line 74
  pdata->curelt = (portMappingElt )0;
#line 75
  return;
}
}
#line 78 "/home/wheatley/newnew/temp/miniupnpc-1.6/portlistingparse.c"
static void data(void *d , char const   *data___2 , int l ) 
{ 
  struct PortMapping *pm ;
  struct PortMappingParserData *pdata ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;

  {
#line 82
  pdata = (struct PortMappingParserData *)d;
#line 83
  pm = pdata->head.lh_first;
#line 84
  if (! pm) {
#line 85
    return;
  }
#line 86
  if (l > 63) {
#line 87
    l = 63;
  }
  {
#line 90
  if ((unsigned int )pdata->curelt == 2U) {
#line 90
    goto case_2;
  }
#line 94
  if ((unsigned int )pdata->curelt == 3U) {
#line 94
    goto case_3;
  }
#line 97
  if ((unsigned int )pdata->curelt == 4U) {
#line 97
    goto case_4;
  }
#line 103
  if ((unsigned int )pdata->curelt == 5U) {
#line 103
    goto case_5;
  }
#line 106
  if ((unsigned int )pdata->curelt == 6U) {
#line 106
    goto case_6;
  }
#line 110
  if ((unsigned int )pdata->curelt == 7U) {
#line 110
    goto case_7;
  }
#line 113
  if ((unsigned int )pdata->curelt == 8U) {
#line 113
    goto case_8;
  }
#line 117
  if ((unsigned int )pdata->curelt == 9U) {
#line 117
    goto case_9;
  }
#line 120
  goto switch_default;
  case_2: /* CIL Label */ 
  {
#line 91
  memcpy((void */* __restrict  */)(pm->remoteHost), (void const   */* __restrict  */)data___2,
         (size_t )l);
#line 92
  pm->remoteHost[l] = (char )'\000';
  }
#line 93
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 95
  tmp = atoui(data___2, l);
#line 95
  pm->externalPort = (unsigned short )tmp;
  }
#line 96
  goto switch_break;
  case_4: /* CIL Label */ 
#line 98
  if (l > 3) {
#line 99
    l = 3;
  }
  {
#line 100
  memcpy((void */* __restrict  */)(pm->protocol), (void const   */* __restrict  */)data___2,
         (size_t )l);
#line 101
  pm->protocol[l] = (char )'\000';
  }
#line 102
  goto switch_break;
  case_5: /* CIL Label */ 
  {
#line 104
  tmp___0 = atoui(data___2, l);
#line 104
  pm->internalPort = (unsigned short )tmp___0;
  }
#line 105
  goto switch_break;
  case_6: /* CIL Label */ 
  {
#line 107
  memcpy((void */* __restrict  */)(pm->internalClient), (void const   */* __restrict  */)data___2,
         (size_t )l);
#line 108
  pm->internalClient[l] = (char )'\000';
  }
#line 109
  goto switch_break;
  case_7: /* CIL Label */ 
  {
#line 111
  tmp___1 = atoui(data___2, l);
#line 111
  pm->enabled = (unsigned char )tmp___1;
  }
#line 112
  goto switch_break;
  case_8: /* CIL Label */ 
  {
#line 114
  memcpy((void */* __restrict  */)(pm->description), (void const   */* __restrict  */)data___2,
         (size_t )l);
#line 115
  pm->description[l] = (char )'\000';
  }
#line 116
  goto switch_break;
  case_9: /* CIL Label */ 
  {
#line 118
  pm->leaseTime = atoui(data___2, l);
  }
#line 119
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 121
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 123
  return;
}
}
#line 128 "/home/wheatley/newnew/temp/miniupnpc-1.6/portlistingparse.c"
void ParsePortListing(char const   *buffer , int bufsize , struct PortMappingParserData *pdata ) 
{ 
  struct xmlparser parser ;

  {
  {
#line 134
  memset((void *)pdata, 0, sizeof(struct PortMappingParserData ));
  }
  {
#line 135
  while (1) {
    while_continue: /* CIL Label */ ;
#line 135
    pdata->head.lh_first = (struct PortMapping *)((void *)0);
#line 135
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 137
  parser.xmlstart = buffer;
#line 138
  parser.xmlsize = bufsize;
#line 139
  parser.data = (void *)pdata;
#line 140
  parser.starteltfunc = & startelt;
#line 141
  parser.endeltfunc = & endelt;
#line 142
  parser.datafunc = & data;
#line 143
  parser.attfunc = (void (*)(void * , char const   * , int  , char const   * , int  ))0;
#line 144
  parsexml(& parser);
  }
#line 145
  return;
}
}
#line 147 "/home/wheatley/newnew/temp/miniupnpc-1.6/portlistingparse.c"
void FreePortListing(struct PortMappingParserData *pdata ) 
{ 
  struct PortMapping *pm ;

  {
  {
#line 151
  while (1) {
    while_continue: /* CIL Label */ ;
#line 151
    pm = pdata->head.lh_first;
#line 151
    if (! ((unsigned long )pm != (unsigned long )((void *)0))) {
#line 151
      goto while_break;
    }
    {
#line 153
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 153
      if ((unsigned long )pm->entries.le_next != (unsigned long )((void *)0)) {
#line 153
        (pm->entries.le_next)->entries.le_prev = pm->entries.le_prev;
      }
#line 153
      *(pm->entries.le_prev) = pm->entries.le_next;
#line 153
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 154
    free((void *)pm);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 156
  return;
}
}
#line 192 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t ( __attribute__((__leaf__)) time)(time_t *__timer ) ;
#line 264
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) ctime)(time_t const   *__timer ) ;
#line 25 "/home/wheatley/newnew/temp/miniupnpc-1.6/upnpcommands.h"
unsigned int UPNP_GetTotalBytesSent(char const   *controlURL , char const   *servicetype ) ;
#line 29
unsigned int UPNP_GetTotalBytesReceived(char const   *controlURL , char const   *servicetype ) ;
#line 33
unsigned int UPNP_GetTotalPacketsSent(char const   *controlURL , char const   *servicetype ) ;
#line 37
unsigned int UPNP_GetTotalPacketsReceived(char const   *controlURL , char const   *servicetype ) ;
#line 58
int UPNP_GetConnectionTypeInfo(char const   *controlURL , char const   *servicetype ,
                               char *connectionType ) ;
#line 74
int UPNP_GetExternalIPAddress(char const   *controlURL , char const   *servicetype ,
                              char *extIpAdd ) ;
#line 85
int UPNP_GetLinkLayerMaxBitRates(char const   *controlURL , char const   *servicetype ,
                                 unsigned int *bitrateDown , unsigned int *bitrateUp ) ;
#line 116
int UPNP_AddPortMapping(char const   *controlURL , char const   *servicetype , char const   *extPort ,
                        char const   *inPort , char const   *inClient , char const   *desc ,
                        char const   *proto , char const   *remoteHost , char const   *leaseDuration ) ;
#line 136
int UPNP_DeletePortMapping(char const   *controlURL , char const   *servicetype ,
                           char const   *extPort , char const   *proto , char const   *remoteHost ) ;
#line 162
int UPNP_GetSpecificPortMappingEntry(char const   *controlURL , char const   *servicetype ,
                                     char const   *extPort , char const   *proto ,
                                     char *intClient , char *intPort , char *desc ,
                                     char *enabled , char *leaseDuration ) ;
#line 193
int UPNP_GetGenericPortMappingEntry(char const   *controlURL , char const   *servicetype ,
                                    char const   *index___0 , char *extPort , char *intClient ,
                                    char *intPort , char *protocol , char *desc ,
                                    char *enabled , char *rHost , char *duration ) ;
#line 215
int UPNP_GetListOfPortMappings(char const   *controlURL , char const   *servicetype ,
                               char const   *startPort , char const   *endPort , char const   *protocol ,
                               char const   *numberOfPorts , struct PortMappingParserData *data___2 ) ;
#line 225
int UPNP_GetFirewallStatus(char const   *controlURL , char const   *servicetype ,
                           int *firewallEnabled , int *inboundPinholeAllowed ) ;
#line 231
int UPNP_GetOutboundPinholeTimeout(char const   *controlURL , char const   *servicetype ,
                                   char const   *remoteHost , char const   *remotePort ,
                                   char const   *intClient , char const   *intPort ,
                                   char const   *proto , int *opTimeout ) ;
#line 240
int UPNP_AddPinhole(char const   *controlURL , char const   *servicetype , char const   *remoteHost ,
                    char const   *remotePort , char const   *intClient , char const   *intPort ,
                    char const   *proto , char const   *leaseTime , char *uniqueID ) ;
#line 250
int UPNP_UpdatePinhole(char const   *controlURL , char const   *servicetype , char const   *uniqueID ,
                       char const   *leaseTime ) ;
#line 255
int UPNP_DeletePinhole(char const   *controlURL , char const   *servicetype , char const   *uniqueID ) ;
#line 258
int UPNP_CheckPinholeWorking(char const   *controlURL , char const   *servicetype ,
                             char const   *uniqueID , int *isWorking ) ;
#line 262
int UPNP_GetPinholePackets(char const   *controlURL , char const   *servicetype ,
                           char const   *uniqueID , int *packets ) ;
#line 25 "/home/wheatley/newnew/temp/miniupnpc-1.6/upnpc.c"
char const   *protofix(char const   *proto ) ;
#line 25 "/home/wheatley/newnew/temp/miniupnpc-1.6/upnpc.c"
static char const   proto_tcp[4]  = {      (char const   )'T',      (char const   )'C',      (char const   )'P',      (char const   )0};
#line 26 "/home/wheatley/newnew/temp/miniupnpc-1.6/upnpc.c"
static char const   proto_udp[4]  = {      (char const   )'U',      (char const   )'D',      (char const   )'P',      (char const   )0};
#line 23 "/home/wheatley/newnew/temp/miniupnpc-1.6/upnpc.c"
char const   *protofix(char const   *proto ) 
{ 
  int i ;
  int b ;
  int tmp ;
  int tmp___0 ;

  {
#line 28
  i = 0;
#line 28
  b = 1;
  {
#line 28
  while (1) {
    while_continue: /* CIL Label */ ;
#line 28
    if (! (i < 4)) {
#line 28
      goto while_break;
    }
#line 29
    if (b) {
#line 29
      if ((int const   )*(proto + i) == (int const   )proto_tcp[i]) {
#line 29
        tmp = 1;
      } else
#line 29
      if ((int const   )*(proto + i) == ((int const   )proto_tcp[i] | 32)) {
#line 29
        tmp = 1;
      } else {
#line 29
        tmp = 0;
      }
    } else {
#line 29
      tmp = 0;
    }
#line 29
    b = tmp;
#line 28
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 31
  if (b) {
#line 32
    return (proto_tcp);
  }
#line 33
  i = 0;
#line 33
  b = 1;
  {
#line 33
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 33
    if (! (i < 4)) {
#line 33
      goto while_break___0;
    }
#line 34
    if (b) {
#line 34
      if ((int const   )*(proto + i) == (int const   )proto_udp[i]) {
#line 34
        tmp___0 = 1;
      } else
#line 34
      if ((int const   )*(proto + i) == ((int const   )proto_udp[i] | 32)) {
#line 34
        tmp___0 = 1;
      } else {
#line 34
        tmp___0 = 0;
      }
    } else {
#line 34
      tmp___0 = 0;
    }
#line 34
    b = tmp___0;
#line 33
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 36
  if (b) {
#line 37
    return (proto_udp);
  }
#line 38
  return ((char const   *)0);
}
}
#line 41 "/home/wheatley/newnew/temp/miniupnpc-1.6/upnpc.c"
static void DisplayInfos(struct UPNPUrls *urls , struct IGDdatas *data___2 ) 
{ 
  char externalIPAddress[40] ;
  char connectionType[64] ;
  char status[64] ;
  char lastconnerr[64] ;
  unsigned int uptime ;
  unsigned int brUp ;
  unsigned int brDown ;
  time_t timenow ;
  time_t timestarted ;
  int r ;
  char *tmp ;

  {
  {
#line 52
  UPNP_GetConnectionTypeInfo((char const   *)urls->controlURL, (char const   *)(data___2->first.servicetype),
                             connectionType);
  }
#line 55
  if (connectionType[0]) {
    {
#line 56
    printf((char const   */* __restrict  */)"Connection Type : %s\n", connectionType);
    }
  } else {
    {
#line 58
    printf((char const   */* __restrict  */)"GetConnectionTypeInfo failed.\n");
    }
  }
  {
#line 59
  UPNP_GetStatusInfo((char const   *)urls->controlURL, (char const   *)(data___2->first.servicetype),
                     status, & uptime, lastconnerr);
#line 61
  printf((char const   */* __restrict  */)"Status : %s, uptime=%us, LastConnectionError : %s\n",
         status, uptime, lastconnerr);
#line 63
  timenow = time((time_t *)((void *)0));
#line 64
  timestarted = timenow - (time_t )uptime;
#line 65
  tmp = ctime((time_t const   *)(& timestarted));
#line 65
  printf((char const   */* __restrict  */)"  Time started : %s", tmp);
#line 66
  UPNP_GetLinkLayerMaxBitRates((char const   *)urls->controlURL_CIF, (char const   *)(data___2->CIF.servicetype),
                               & brDown, & brUp);
#line 68
  printf((char const   */* __restrict  */)"MaxBitRateDown : %u bps", brDown);
  }
#line 69
  if (brDown >= 1000000U) {
    {
#line 70
    printf((char const   */* __restrict  */)" (%u.%u Mbps)", brDown / 1000000U, (brDown / 100000U) % 10U);
    }
  } else
#line 71
  if (brDown >= 1000U) {
    {
#line 72
    printf((char const   */* __restrict  */)" (%u Kbps)", brDown / 1000U);
    }
  }
  {
#line 74
  printf((char const   */* __restrict  */)"   MaxBitRateUp %u bps", brUp);
  }
#line 75
  if (brUp >= 1000000U) {
    {
#line 76
    printf((char const   */* __restrict  */)" (%u.%u Mbps)", brUp / 1000000U, (brUp / 100000U) % 10U);
    }
  } else
#line 77
  if (brUp >= 1000U) {
    {
#line 78
    printf((char const   */* __restrict  */)" (%u Kbps)", brUp / 1000U);
    }
  }
  {
#line 80
  printf((char const   */* __restrict  */)"\n");
#line 81
  r = UPNP_GetExternalIPAddress((char const   *)urls->controlURL, (char const   *)(data___2->first.servicetype),
                                externalIPAddress);
  }
#line 84
  if (r != 0) {
    {
#line 85
    printf((char const   */* __restrict  */)"GetExternalIPAddress() returned %d\n",
           r);
    }
  }
#line 86
  if (externalIPAddress[0]) {
    {
#line 87
    printf((char const   */* __restrict  */)"ExternalIPAddress = %s\n", externalIPAddress);
    }
  } else {
    {
#line 89
    printf((char const   */* __restrict  */)"GetExternalIPAddress failed.\n");
    }
  }
#line 90
  return;
}
}
#line 92 "/home/wheatley/newnew/temp/miniupnpc-1.6/upnpc.c"
static void GetConnectionStatus(struct UPNPUrls *urls , struct IGDdatas *data___2 ) 
{ 
  unsigned int bytessent ;
  unsigned int bytesreceived ;
  unsigned int packetsreceived ;
  unsigned int packetssent ;

  {
  {
#line 96
  DisplayInfos(urls, data___2);
#line 97
  bytessent = UPNP_GetTotalBytesSent((char const   *)urls->controlURL_CIF, (char const   *)(data___2->CIF.servicetype));
#line 98
  bytesreceived = UPNP_GetTotalBytesReceived((char const   *)urls->controlURL_CIF,
                                             (char const   *)(data___2->CIF.servicetype));
#line 99
  packetssent = UPNP_GetTotalPacketsSent((char const   *)urls->controlURL_CIF, (char const   *)(data___2->CIF.servicetype));
#line 100
  packetsreceived = UPNP_GetTotalPacketsReceived((char const   *)urls->controlURL_CIF,
                                                 (char const   *)(data___2->CIF.servicetype));
#line 101
  printf((char const   */* __restrict  */)"Bytes:   Sent: %8u\tRecv: %8u\n", bytessent,
         bytesreceived);
#line 102
  printf((char const   */* __restrict  */)"Packets: Sent: %8u\tRecv: %8u\n", packetssent,
         packetsreceived);
  }
#line 103
  return;
}
}
#line 105 "/home/wheatley/newnew/temp/miniupnpc-1.6/upnpc.c"
static void ListRedirections(struct UPNPUrls *urls , struct IGDdatas *data___2 ) 
{ 
  int r ;
  int i ;
  char index___0[6] ;
  char intClient[40] ;
  char intPort[6] ;
  char extPort[6] ;
  char protocol[4] ;
  char desc[80] ;
  char enabled[6] ;
  char rHost[64] ;
  char duration[16] ;
  char const   *tmp ;

  {
#line 109
  i = 0;
  {
#line 122
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 123
    snprintf((char */* __restrict  */)(index___0), (size_t )6, (char const   */* __restrict  */)"%d",
             i);
#line 124
    rHost[0] = (char )'\000';
#line 124
    enabled[0] = (char )'\000';
#line 125
    duration[0] = (char )'\000';
#line 125
    desc[0] = (char )'\000';
#line 126
    extPort[0] = (char )'\000';
#line 126
    intPort[0] = (char )'\000';
#line 126
    intClient[0] = (char )'\000';
#line 127
    r = UPNP_GetGenericPortMappingEntry((char const   *)urls->controlURL, (char const   *)(data___2->first.servicetype),
                                        (char const   *)(index___0), extPort, intClient,
                                        intPort, protocol, desc, enabled, rHost, duration);
    }
#line 133
    if (r == 0) {
      {
#line 141
      printf((char const   */* __restrict  */)"%2d %s %5s->%s:%-5s \'%s\' \'%s\' %s\n",
             i, protocol, extPort, intClient, intPort, desc, rHost, duration);
      }
    } else {
      {
#line 145
      tmp = strupnperror(r);
#line 145
      printf((char const   */* __restrict  */)"GetGenericPortMappingEntry() returned %d (%s)\n",
             r, tmp);
      }
    }
#line 147
    i ++;
#line 122
    if (! (r == 0)) {
#line 122
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 149
  return;
}
}
#line 151 "/home/wheatley/newnew/temp/miniupnpc-1.6/upnpc.c"
static void NewListRedirections(struct UPNPUrls *urls , struct IGDdatas *data___2 ) 
{ 
  int r ;
  int i ;
  struct PortMappingParserData pdata ;
  struct PortMapping *pm ;
  char const   *tmp ;
  char const   *tmp___0 ;

  {
  {
#line 155
  i = 0;
#line 159
  memset((void *)(& pdata), 0, sizeof(struct PortMappingParserData ));
#line 160
  r = UPNP_GetListOfPortMappings((char const   *)urls->controlURL, (char const   *)(data___2->first.servicetype),
                                 "0", "65535", "TCP", "1000", & pdata);
  }
#line 167
  if (r == 0) {
#line 169
    pm = pdata.head.lh_first;
    {
#line 169
    while (1) {
      while_continue: /* CIL Label */ ;
#line 169
      if (! ((unsigned long )pm != (unsigned long )((void *)0))) {
#line 169
        goto while_break;
      }
      {
#line 171
      printf((char const   */* __restrict  */)"%2d %s %5hu->%s:%-5hu \'%s\' \'%s\' %u\n",
             i, pm->protocol, (int )pm->externalPort, pm->internalClient, (int )pm->internalPort,
             pm->description, pm->remoteHost, pm->leaseTime);
#line 176
      i ++;
#line 169
      pm = pm->entries.le_next;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 178
    FreePortListing(& pdata);
    }
  } else {
    {
#line 182
    tmp = strupnperror(r);
#line 182
    printf((char const   */* __restrict  */)"GetListOfPortMappings() returned %d (%s)\n",
           r, tmp);
    }
  }
  {
#line 185
  r = UPNP_GetListOfPortMappings((char const   *)urls->controlURL, (char const   *)(data___2->first.servicetype),
                                 "0", "65535", "UDP", "1000", & pdata);
  }
#line 192
  if (r == 0) {
#line 194
    pm = pdata.head.lh_first;
    {
#line 194
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 194
      if (! ((unsigned long )pm != (unsigned long )((void *)0))) {
#line 194
        goto while_break___0;
      }
      {
#line 196
      printf((char const   */* __restrict  */)"%2d %s %5hu->%s:%-5hu \'%s\' \'%s\' %u\n",
             i, pm->protocol, (int )pm->externalPort, pm->internalClient, (int )pm->internalPort,
             pm->description, pm->remoteHost, pm->leaseTime);
#line 201
      i ++;
#line 194
      pm = pm->entries.le_next;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 203
    FreePortListing(& pdata);
    }
  } else {
    {
#line 207
    tmp___0 = strupnperror(r);
#line 207
    printf((char const   */* __restrict  */)"GetListOfPortMappings() returned %d (%s)\n",
           r, tmp___0);
    }
  }
#line 210
  return;
}
}
#line 217 "/home/wheatley/newnew/temp/miniupnpc-1.6/upnpc.c"
static void SetRedirectAndTest(struct UPNPUrls *urls , struct IGDdatas *data___2 ,
                               char const   *iaddr , char const   *iport , char const   *eport ,
                               char const   *proto , char const   *leaseDuration ) 
{ 
  char externalIPAddress[40] ;
  char intClient[40] ;
  char intPort[6] ;
  char duration[16] ;
  int r ;
  char const   *tmp ;
  char const   *tmp___0 ;

  {
#line 231
  if (! iaddr) {
    {
#line 233
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Wrong arguments\n");
    }
#line 234
    return;
  } else
#line 231
  if (! iport) {
    {
#line 233
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Wrong arguments\n");
    }
#line 234
    return;
  } else
#line 231
  if (! eport) {
    {
#line 233
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Wrong arguments\n");
    }
#line 234
    return;
  } else
#line 231
  if (! proto) {
    {
#line 233
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Wrong arguments\n");
    }
#line 234
    return;
  }
  {
#line 236
  proto = protofix(proto);
  }
#line 237
  if (! proto) {
    {
#line 239
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"invalid protocol\n");
    }
#line 240
    return;
  }
  {
#line 243
  UPNP_GetExternalIPAddress((char const   *)urls->controlURL, (char const   *)(data___2->first.servicetype),
                            externalIPAddress);
  }
#line 246
  if (externalIPAddress[0]) {
    {
#line 247
    printf((char const   */* __restrict  */)"ExternalIPAddress = %s\n", externalIPAddress);
    }
  } else {
    {
#line 249
    printf((char const   */* __restrict  */)"GetExternalIPAddress failed.\n");
    }
  }
  {
#line 251
  r = UPNP_AddPortMapping((char const   *)urls->controlURL, (char const   *)(data___2->first.servicetype),
                          eport, iport, iaddr, (char const   *)0, proto, (char const   *)0,
                          leaseDuration);
  }
#line 253
  if (r != 0) {
    {
#line 254
    tmp = strupnperror(r);
#line 254
    printf((char const   */* __restrict  */)"AddPortMapping(%s, %s, %s) failed with code %d (%s)\n",
           eport, iport, iaddr, r, tmp);
    }
  }
  {
#line 257
  r = UPNP_GetSpecificPortMappingEntry((char const   *)urls->controlURL, (char const   *)(data___2->first.servicetype),
                                       eport, proto, intClient, intPort, (char *)((void *)0),
                                       (char *)((void *)0), duration);
  }
#line 262
  if (r != 0) {
    {
#line 263
    tmp___0 = strupnperror(r);
#line 263
    printf((char const   */* __restrict  */)"GetSpecificPortMappingEntry() failed with code %d (%s)\n",
           r, tmp___0);
    }
  }
#line 266
  if (intClient[0]) {
    {
#line 267
    printf((char const   */* __restrict  */)"InternalIP:Port = %s:%s\n", intClient,
           intPort);
#line 268
    printf((char const   */* __restrict  */)"external %s:%s %s is redirected to internal %s:%s (duration=%s)\n",
           externalIPAddress, eport, proto, intClient, intPort, duration);
    }
  }
#line 271
  return;
}
}
#line 273 "/home/wheatley/newnew/temp/miniupnpc-1.6/upnpc.c"
static void RemoveRedirect(struct UPNPUrls *urls , struct IGDdatas *data___2 , char const   *eport ,
                           char const   *proto ) 
{ 
  int r ;

  {
#line 280
  if (! proto) {
    {
#line 282
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"invalid arguments\n");
    }
#line 283
    return;
  } else
#line 280
  if (! eport) {
    {
#line 282
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"invalid arguments\n");
    }
#line 283
    return;
  }
  {
#line 285
  proto = protofix(proto);
  }
#line 286
  if (! proto) {
    {
#line 288
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"protocol invalid\n");
    }
#line 289
    return;
  }
  {
#line 291
  r = UPNP_DeletePortMapping((char const   *)urls->controlURL, (char const   *)(data___2->first.servicetype),
                             eport, proto, (char const   *)0);
#line 292
  printf((char const   */* __restrict  */)"UPNP_DeletePortMapping() returned : %d\n",
         r);
  }
#line 293
  return;
}
}
#line 296 "/home/wheatley/newnew/temp/miniupnpc-1.6/upnpc.c"
static void GetFirewallStatus(struct UPNPUrls *urls , struct IGDdatas *data___2 ) 
{ 
  unsigned int bytessent ;
  unsigned int bytesreceived ;
  unsigned int packetsreceived ;
  unsigned int packetssent ;
  int firewallEnabled ;
  int inboundPinholeAllowed ;
  char const   *tmp ;
  char const   *tmp___0 ;

  {
  {
#line 299
  firewallEnabled = 0;
#line 299
  inboundPinholeAllowed = 0;
#line 301
  UPNP_GetFirewallStatus((char const   *)urls->controlURL_6FC, (char const   *)(data___2->IPv6FC.servicetype),
                         & firewallEnabled, & inboundPinholeAllowed);
#line 302
  printf((char const   */* __restrict  */)"FirewallEnabled: %d & Inbound Pinhole Allowed: %d\n",
         firewallEnabled, inboundPinholeAllowed);
  }
#line 303
  if (inboundPinholeAllowed) {
#line 303
    tmp = "Yes";
  } else {
#line 303
    tmp = "No";
  }
#line 303
  if (firewallEnabled) {
#line 303
    tmp___0 = "Yes";
  } else {
#line 303
    tmp___0 = "No";
  }
  {
#line 303
  printf((char const   */* __restrict  */)"GetFirewallStatus:\n   Firewall Enabled: %s\n   Inbound Pinhole Allowed: %s\n",
         tmp___0, tmp);
#line 305
  bytessent = UPNP_GetTotalBytesSent((char const   *)urls->controlURL_CIF, (char const   *)(data___2->CIF.servicetype));
#line 306
  bytesreceived = UPNP_GetTotalBytesReceived((char const   *)urls->controlURL_CIF,
                                             (char const   *)(data___2->CIF.servicetype));
#line 307
  packetssent = UPNP_GetTotalPacketsSent((char const   *)urls->controlURL_CIF, (char const   *)(data___2->CIF.servicetype));
#line 308
  packetsreceived = UPNP_GetTotalPacketsReceived((char const   *)urls->controlURL_CIF,
                                                 (char const   *)(data___2->CIF.servicetype));
#line 309
  printf((char const   */* __restrict  */)"Bytes:   Sent: %8u\tRecv: %8u\n", bytessent,
         bytesreceived);
#line 310
  printf((char const   */* __restrict  */)"Packets: Sent: %8u\tRecv: %8u\n", packetssent,
         packetsreceived);
  }
#line 311
  return;
}
}
#line 316 "/home/wheatley/newnew/temp/miniupnpc-1.6/upnpc.c"
static void SetPinholeAndTest(struct UPNPUrls *urls , struct IGDdatas *data___2 ,
                              char const   *remoteaddr , char const   *eport , char const   *intaddr ,
                              char const   *iport , char const   *proto , char const   *lease_time ) 
{ 
  char uniqueID[8] ;
  int r ;
  char const   *tmp ;

  {
#line 325
  if (! intaddr) {
    {
#line 327
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Wrong arguments\n");
    }
#line 328
    return;
  } else
#line 325
  if (! remoteaddr) {
    {
#line 327
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Wrong arguments\n");
    }
#line 328
    return;
  } else
#line 325
  if (! iport) {
    {
#line 327
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Wrong arguments\n");
    }
#line 328
    return;
  } else
#line 325
  if (! eport) {
    {
#line 327
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Wrong arguments\n");
    }
#line 328
    return;
  } else
#line 325
  if (! proto) {
    {
#line 327
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Wrong arguments\n");
    }
#line 328
    return;
  } else
#line 325
  if (! lease_time) {
    {
#line 327
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Wrong arguments\n");
    }
#line 328
    return;
  }
  {
#line 336
  r = UPNP_AddPinhole((char const   *)urls->controlURL_6FC, (char const   *)(data___2->IPv6FC.servicetype),
                      remoteaddr, eport, intaddr, iport, proto, lease_time, uniqueID);
  }
#line 337
  if (r != 0) {
    {
#line 338
    tmp = strupnperror(r);
#line 338
    printf((char const   */* __restrict  */)"AddPinhole([%s]:%s -> [%s]:%s) failed with code %d (%s)\n",
           intaddr, iport, remoteaddr, eport, r, tmp);
    }
  } else {
    {
#line 342
    printf((char const   */* __restrict  */)"AddPinhole: ([%s]:%s -> [%s]:%s) / Pinhole ID = %s\n",
           intaddr, iport, remoteaddr, eport, uniqueID);
    }
  }
#line 348
  return;
}
}
#line 353 "/home/wheatley/newnew/temp/miniupnpc-1.6/upnpc.c"
static void GetPinholeAndUpdate(struct UPNPUrls *urls , struct IGDdatas *data___2 ,
                                char const   *uniqueID , char const   *lease_time ) 
{ 
  int isWorking ;
  int r ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;

  {
#line 356
  isWorking = 0;
#line 359
  if (! uniqueID) {
    {
#line 361
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Wrong arguments\n");
    }
#line 362
    return;
  } else
#line 359
  if (! lease_time) {
    {
#line 361
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Wrong arguments\n");
    }
#line 362
    return;
  }
  {
#line 364
  r = UPNP_CheckPinholeWorking((char const   *)urls->controlURL_6FC, (char const   *)(data___2->IPv6FC.servicetype),
                               uniqueID, & isWorking);
  }
#line 365
  if (isWorking) {
#line 365
    tmp = "Yes";
  } else {
#line 365
    tmp = "No";
  }
  {
#line 365
  printf((char const   */* __restrict  */)"CheckPinholeWorking: Pinhole ID = %s / IsWorking = %s\n",
         uniqueID, tmp);
  }
#line 366
  if (r != 0) {
    {
#line 367
    tmp___0 = strupnperror(r);
#line 367
    printf((char const   */* __restrict  */)"CheckPinholeWorking() failed with code %d (%s)\n",
           r, tmp___0);
    }
  }
#line 368
  if (isWorking) {
#line 368
    goto _L;
  } else
#line 368
  if (r == 709) {
    _L: /* CIL Label */ 
    {
#line 370
    r = UPNP_UpdatePinhole((char const   *)urls->controlURL_6FC, (char const   *)(data___2->IPv6FC.servicetype),
                           uniqueID, lease_time);
#line 371
    printf((char const   */* __restrict  */)"UpdatePinhole: Pinhole ID = %s with Lease Time: %s\n",
           uniqueID, lease_time);
    }
#line 372
    if (r != 0) {
      {
#line 373
      tmp___1 = strupnperror(r);
#line 373
      printf((char const   */* __restrict  */)"UpdatePinhole: ID (%s) failed with code %d (%s)\n",
             uniqueID, r, tmp___1);
      }
    }
  }
#line 375
  return;
}
}
#line 380 "/home/wheatley/newnew/temp/miniupnpc-1.6/upnpc.c"
static void GetPinholeOutboundTimeout(struct UPNPUrls *urls , struct IGDdatas *data___2 ,
                                      char const   *remoteaddr , char const   *eport ,
                                      char const   *intaddr , char const   *iport ,
                                      char const   *proto ) 
{ 
  int timeout ;
  int r ;
  char const   *tmp ;

  {
#line 385
  timeout = 0;
#line 388
  if (! intaddr) {
    {
#line 390
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Wrong arguments\n");
    }
#line 391
    return;
  } else
#line 388
  if (! remoteaddr) {
    {
#line 390
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Wrong arguments\n");
    }
#line 391
    return;
  } else
#line 388
  if (! iport) {
    {
#line 390
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Wrong arguments\n");
    }
#line 391
    return;
  } else
#line 388
  if (! eport) {
    {
#line 390
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Wrong arguments\n");
    }
#line 391
    return;
  } else
#line 388
  if (! proto) {
    {
#line 390
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Wrong arguments\n");
    }
#line 391
    return;
  }
  {
#line 394
  r = UPNP_GetOutboundPinholeTimeout((char const   *)urls->controlURL_6FC, (char const   *)(data___2->IPv6FC.servicetype),
                                     remoteaddr, eport, intaddr, iport, proto, & timeout);
  }
#line 395
  if (r != 0) {
    {
#line 396
    tmp = strupnperror(r);
#line 396
    printf((char const   */* __restrict  */)"GetOutboundPinholeTimeout([%s]:%s -> [%s]:%s) failed with code %d (%s)\n",
           intaddr, iport, remoteaddr, eport, r, tmp);
    }
  } else {
    {
#line 399
    printf((char const   */* __restrict  */)"GetOutboundPinholeTimeout: ([%s]:%s -> [%s]:%s) / Timeout = %d\n",
           intaddr, iport, remoteaddr, eport, timeout);
    }
  }
#line 400
  return;
}
}
#line 402 "/home/wheatley/newnew/temp/miniupnpc-1.6/upnpc.c"
static void GetPinholePackets(struct UPNPUrls *urls , struct IGDdatas *data___2 ,
                              char const   *uniqueID ) 
{ 
  int r ;
  int pinholePackets ;
  char const   *tmp ;

  {
#line 406
  pinholePackets = 0;
#line 407
  if (! uniqueID) {
    {
#line 409
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"invalid arguments\n");
    }
#line 410
    return;
  }
  {
#line 412
  r = UPNP_GetPinholePackets((char const   *)urls->controlURL_6FC, (char const   *)(data___2->IPv6FC.servicetype),
                             uniqueID, & pinholePackets);
  }
#line 413
  if (r != 0) {
    {
#line 414
    tmp = strupnperror(r);
#line 414
    printf((char const   */* __restrict  */)"GetPinholePackets() failed with code %d (%s)\n",
           r, tmp);
    }
  } else {
    {
#line 416
    printf((char const   */* __restrict  */)"GetPinholePackets: Pinhole ID = %s / PinholePackets = %d\n",
           uniqueID, pinholePackets);
    }
  }
#line 417
  return;
}
}
#line 419 "/home/wheatley/newnew/temp/miniupnpc-1.6/upnpc.c"
static void CheckPinhole(struct UPNPUrls *urls , struct IGDdatas *data___2 , char const   *uniqueID ) 
{ 
  int r ;
  int isWorking ;
  char const   *tmp ;
  char const   *tmp___0 ;

  {
#line 423
  isWorking = 0;
#line 424
  if (! uniqueID) {
    {
#line 426
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"invalid arguments\n");
    }
#line 427
    return;
  }
  {
#line 429
  r = UPNP_CheckPinholeWorking((char const   *)urls->controlURL_6FC, (char const   *)(data___2->IPv6FC.servicetype),
                               uniqueID, & isWorking);
  }
#line 430
  if (r != 0) {
    {
#line 431
    tmp = strupnperror(r);
#line 431
    printf((char const   */* __restrict  */)"CheckPinholeWorking() failed with code %d (%s)\n",
           r, tmp);
    }
  } else {
#line 433
    if (isWorking) {
#line 433
      tmp___0 = "Yes";
    } else {
#line 433
      tmp___0 = "No";
    }
    {
#line 433
    printf((char const   */* __restrict  */)"CheckPinholeWorking: Pinhole ID = %s / IsWorking = %s\n",
           uniqueID, tmp___0);
    }
  }
#line 434
  return;
}
}
#line 436 "/home/wheatley/newnew/temp/miniupnpc-1.6/upnpc.c"
static void RemovePinhole(struct UPNPUrls *urls , struct IGDdatas *data___2 , char const   *uniqueID ) 
{ 
  int r ;

  {
#line 441
  if (! uniqueID) {
    {
#line 443
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"invalid arguments\n");
    }
#line 444
    return;
  }
  {
#line 446
  r = UPNP_DeletePinhole((char const   *)urls->controlURL_6FC, (char const   *)(data___2->IPv6FC.servicetype),
                         uniqueID);
#line 447
  printf((char const   */* __restrict  */)"UPNP_DeletePinhole() returned : %d\n",
         r);
  }
#line 448
  return;
}
}
#line 452 "/home/wheatley/newnew/temp/miniupnpc-1.6/upnpc.c"
int main(int argc , char **argv ) 
{ 
  char command ;
  char **commandargv ;
  int commandargc ;
  struct UPNPDev *devlist ;
  char lanaddr[64] ;
  int i ;
  char const   *rootdescurl ;
  char const   *multicastif ;
  char const   *minissdpdpath ;
  int retcode ;
  int error ;
  int ipv6 ;
  struct UPNPDev *device ;
  struct UPNPUrls urls ;
  struct IGDdatas data___2 ;
  char const   *tmp ;
  int tmp___0 ;

  {
  {
#line 454
  command = (char)0;
#line 455
  commandargv = (char **)0;
#line 456
  commandargc = 0;
#line 457
  devlist = (struct UPNPDev *)0;
#line 460
  rootdescurl = (char const   *)0;
#line 461
  multicastif = (char const   *)0;
#line 462
  minissdpdpath = (char const   *)0;
#line 463
  retcode = 0;
#line 464
  error = 0;
#line 465
  ipv6 = 0;
#line 476
  printf((char const   */* __restrict  */)"upnpc : miniupnpc library test client. (c) 2006-2011 Thomas Bernard\n");
#line 477
  printf((char const   */* __restrict  */)"Go to http://miniupnp.free.fr/ or http://miniupnp.tuxfamily.org/\nfor more information.\n");
#line 480
  i = 1;
  }
  {
#line 480
  while (1) {
    while_continue: /* CIL Label */ ;
#line 480
    if (! (i < argc)) {
#line 480
      goto while_break;
    }
#line 482
    if ((int )*(*(argv + i) + 0) == 45) {
#line 484
      if ((int )*(*(argv + i) + 1) == 117) {
#line 485
        i ++;
#line 485
        rootdescurl = (char const   *)*(argv + i);
      } else
#line 486
      if ((int )*(*(argv + i) + 1) == 109) {
#line 487
        i ++;
#line 487
        multicastif = (char const   *)*(argv + i);
      } else
#line 488
      if ((int )*(*(argv + i) + 1) == 112) {
#line 489
        i ++;
#line 489
        minissdpdpath = (char const   *)*(argv + i);
      } else
#line 490
      if ((int )*(*(argv + i) + 1) == 54) {
#line 491
        ipv6 = 1;
      } else {
#line 494
        command = *(*(argv + i) + 1);
#line 495
        i ++;
#line 496
        commandargv = argv + i;
#line 497
        commandargc = argc - i;
#line 498
        goto while_break;
      }
    } else {
      {
#line 503
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"option \'%s\' invalid\n",
              *(argv + i));
      }
    }
#line 480
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 507
  if (! command) {
#line 507
    goto _L;
  } else
#line 507
  if ((int )command == 97) {
#line 507
    if (commandargc < 4) {
#line 507
      goto _L;
    } else {
#line 507
      goto _L___4;
    }
  } else
  _L___4: /* CIL Label */ 
#line 507
  if ((int )command == 100) {
#line 507
    if (argc < 2) {
#line 507
      goto _L;
    } else {
#line 507
      goto _L___3;
    }
  } else
  _L___3: /* CIL Label */ 
#line 507
  if ((int )command == 114) {
#line 507
    if (argc < 2) {
#line 507
      goto _L;
    } else {
#line 507
      goto _L___2;
    }
  } else
  _L___2: /* CIL Label */ 
#line 507
  if ((int )command == 65) {
#line 507
    if (commandargc < 6) {
#line 507
      goto _L;
    } else {
#line 507
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
#line 507
  if ((int )command == 85) {
#line 507
    if (commandargc < 2) {
#line 507
      goto _L;
    } else {
#line 507
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 507
  if ((int )command == 68) {
#line 507
    if (commandargc < 1) {
      _L: /* CIL Label */ 
      {
#line 514
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Usage :\t%s [options] -a ip port external_port protocol [duration]\n\t\tAdd port redirection\n",
              *(argv + 0));
#line 515
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"       \t%s [options] -d external_port protocol [port2 protocol2] [...]\n\t\tDelete port redirection\n",
              *(argv + 0));
#line 516
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"       \t%s [options] -s\n\t\tGet Connection status\n",
              *(argv + 0));
#line 517
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"       \t%s [options] -l\n\t\tList redirections\n",
              *(argv + 0));
#line 518
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"       \t%s [options] -L\n\t\tList redirections (using GetListOfPortMappings, IGD v2)\n",
              *(argv + 0));
#line 519
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"       \t%s [options] -r port1 protocol1 [port2 protocol2] [...]\n\t\tAdd all redirections to the current host\n",
              *(argv + 0));
#line 520
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"       \t%s [options] -A remote_ip remote_port internal_ip internal_port protocol lease_time\n\t\tAdd Pinhole (for IGD:2 only)\n",
              *(argv + 0));
#line 521
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"       \t%s [options] -U uniqueID new_lease_time\n\t\tUpdate Pinhole (for IGD:2 only)\n",
              *(argv + 0));
#line 522
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"       \t%s [options] -C uniqueID\n\t\tCheck if Pinhole is Working (for IGD:2 only)\n",
              *(argv + 0));
#line 523
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"       \t%s [options] -K uniqueID\n\t\tGet Number of packets going through the rule (for IGD:2 only)\n",
              *(argv + 0));
#line 524
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"       \t%s [options] -D uniqueID\n\t\tDelete Pinhole (for IGD:2 only)\n",
              *(argv + 0));
#line 525
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"       \t%s [options] -S\n\t\tGet Firewall status (for IGD:2 only)\n",
              *(argv + 0));
#line 526
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"       \t%s [options] -G remote_ip remote_port internal_ip internal_port protocol\n\t\tGet Outbound Pinhole Timeout (for IGD:2 only)\n",
              *(argv + 0));
#line 527
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"       \t%s [options] -P\n\t\tGet Presentation url\n",
              *(argv + 0));
#line 528
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\nprotocol is UDP or TCP\n");
#line 529
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Options:\n");
#line 530
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  -6 : use ip v6 instead of ip v4.\n");
#line 531
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  -u url : bypass discovery process by providing the XML root description url.\n");
#line 532
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  -m address/interface : provide ip address (ip v4) or interface name (ip v6) to use for sending SSDP multicast packets.\n");
#line 533
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  -p path : use this path for MiniSSDPd socket.\n");
      }
#line 534
      return (1);
    }
  }
#line 537
  if (rootdescurl) {
#line 537
    goto _L___7;
  } else {
    {
#line 537
    devlist = upnpDiscover(2000, multicastif, minissdpdpath, 0, ipv6, & error);
    }
#line 537
    if (devlist) {
      _L___7: /* CIL Label */ 
#line 544
      if (devlist) {
        {
#line 546
        printf((char const   */* __restrict  */)"List of UPNP devices found on the network :\n");
#line 547
        device = devlist;
        }
        {
#line 547
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 547
          if (! device) {
#line 547
            goto while_break___0;
          }
          {
#line 549
          printf((char const   */* __restrict  */)" desc: %s\n st: %s\n\n", device->descURL,
                 device->st);
#line 547
          device = device->pNext;
          }
        }
        while_break___0: /* CIL Label */ ;
        }
      } else {
        {
#line 555
        printf((char const   */* __restrict  */)"upnpDiscover() error code=%d\n",
               error);
        }
      }
#line 557
      i = 1;
#line 558
      if (rootdescurl) {
        {
#line 558
        tmp___0 = UPNP_GetIGDFromUrl(rootdescurl, & urls, & data___2, lanaddr, (int )sizeof(lanaddr));
        }
#line 558
        if (tmp___0) {
#line 558
          goto _L___5;
        } else {
#line 558
          goto _L___6;
        }
      } else {
        _L___6: /* CIL Label */ 
        {
#line 558
        i = UPNP_GetValidIGD(devlist, & urls, & data___2, lanaddr, (int )sizeof(lanaddr));
        }
#line 558
        if (i) {
          _L___5: /* CIL Label */ 
          {
#line 562
          if (i == 1) {
#line 562
            goto case_1;
          }
#line 565
          if (i == 2) {
#line 565
            goto case_2;
          }
#line 569
          if (i == 3) {
#line 569
            goto case_3;
          }
#line 573
          goto switch_default;
          case_1: /* CIL Label */ 
          {
#line 563
          printf((char const   */* __restrict  */)"Found valid IGD : %s\n", urls.controlURL);
          }
#line 564
          goto switch_break;
          case_2: /* CIL Label */ 
          {
#line 566
          printf((char const   */* __restrict  */)"Found a (not connected?) IGD : %s\n",
                 urls.controlURL);
#line 567
          printf((char const   */* __restrict  */)"Trying to continue anyway\n");
          }
#line 568
          goto switch_break;
          case_3: /* CIL Label */ 
          {
#line 570
          printf((char const   */* __restrict  */)"UPnP device found. Is it an IGD ? : %s\n",
                 urls.controlURL);
#line 571
          printf((char const   */* __restrict  */)"Trying to continue anyway\n");
          }
#line 572
          goto switch_break;
          switch_default: /* CIL Label */ 
          {
#line 574
          printf((char const   */* __restrict  */)"Found device (igd ?) : %s\n", urls.controlURL);
#line 575
          printf((char const   */* __restrict  */)"Trying to continue anyway\n");
          }
          switch_break: /* CIL Label */ ;
          }
          {
#line 577
          printf((char const   */* __restrict  */)"Local LAN ip address : %s\n", lanaddr);
          }
          {
#line 590
          if ((int )command == 108) {
#line 590
            goto case_108;
          }
#line 594
          if ((int )command == 76) {
#line 594
            goto case_76;
          }
#line 597
          if ((int )command == 97) {
#line 597
            goto case_97;
          }
#line 603
          if ((int )command == 100) {
#line 603
            goto case_100;
          }
#line 609
          if ((int )command == 115) {
#line 609
            goto case_115;
          }
#line 612
          if ((int )command == 114) {
#line 612
            goto case_114;
          }
#line 621
          if ((int )command == 65) {
#line 621
            goto case_65;
          }
#line 627
          if ((int )command == 85) {
#line 627
            goto case_85;
          }
#line 631
          if ((int )command == 67) {
#line 631
            goto case_67;
          }
#line 637
          if ((int )command == 75) {
#line 637
            goto case_75;
          }
#line 643
          if ((int )command == 68) {
#line 643
            goto case_68;
          }
#line 649
          if ((int )command == 83) {
#line 649
            goto case_83;
          }
#line 652
          if ((int )command == 71) {
#line 652
            goto case_71;
          }
#line 658
          if ((int )command == 80) {
#line 658
            goto case_80;
          }
#line 662
          goto switch_default___0;
          case_108: /* CIL Label */ 
          {
#line 591
          DisplayInfos(& urls, & data___2);
#line 592
          ListRedirections(& urls, & data___2);
          }
#line 593
          goto switch_break___0;
          case_76: /* CIL Label */ 
          {
#line 595
          NewListRedirections(& urls, & data___2);
          }
#line 596
          goto switch_break___0;
          case_97: /* CIL Label */ 
#line 598
          if (commandargc > 4) {
#line 598
            tmp = (char const   *)*(commandargv + 4);
          } else {
#line 598
            tmp = "0";
          }
          {
#line 598
          SetRedirectAndTest(& urls, & data___2, (char const   *)*(commandargv + 0),
                             (char const   *)*(commandargv + 1), (char const   *)*(commandargv + 2),
                             (char const   *)*(commandargv + 3), tmp);
          }
#line 602
          goto switch_break___0;
          case_100: /* CIL Label */ 
#line 604
          i = 0;
          {
#line 604
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 604
            if (! (i < commandargc)) {
#line 604
              goto while_break___1;
            }
            {
#line 606
            RemoveRedirect(& urls, & data___2, (char const   *)*(commandargv + i),
                           (char const   *)*(commandargv + (i + 1)));
#line 604
            i += 2;
            }
          }
          while_break___1: /* CIL Label */ ;
          }
#line 608
          goto switch_break___0;
          case_115: /* CIL Label */ 
          {
#line 610
          GetConnectionStatus(& urls, & data___2);
          }
#line 611
          goto switch_break___0;
          case_114: /* CIL Label */ 
#line 613
          i = 0;
          {
#line 613
          while (1) {
            while_continue___2: /* CIL Label */ ;
#line 613
            if (! (i < commandargc)) {
#line 613
              goto while_break___2;
            }
            {
#line 616
            SetRedirectAndTest(& urls, & data___2, (char const   *)(lanaddr), (char const   *)*(commandargv + i),
                               (char const   *)*(commandargv + i), (char const   *)*(commandargv + (i + 1)),
                               "0");
#line 613
            i += 2;
            }
          }
          while_break___2: /* CIL Label */ ;
          }
#line 620
          goto switch_break___0;
          case_65: /* CIL Label */ 
          {
#line 622
          SetPinholeAndTest(& urls, & data___2, (char const   *)*(commandargv + 0),
                            (char const   *)*(commandargv + 1), (char const   *)*(commandargv + 2),
                            (char const   *)*(commandargv + 3), (char const   *)*(commandargv + 4),
                            (char const   *)*(commandargv + 5));
          }
#line 626
          goto switch_break___0;
          case_85: /* CIL Label */ 
          {
#line 628
          GetPinholeAndUpdate(& urls, & data___2, (char const   *)*(commandargv + 0),
                              (char const   *)*(commandargv + 1));
          }
#line 630
          goto switch_break___0;
          case_67: /* CIL Label */ 
#line 632
          i = 0;
          {
#line 632
          while (1) {
            while_continue___3: /* CIL Label */ ;
#line 632
            if (! (i < commandargc)) {
#line 632
              goto while_break___3;
            }
            {
#line 634
            CheckPinhole(& urls, & data___2, (char const   *)*(commandargv + i));
#line 632
            i ++;
            }
          }
          while_break___3: /* CIL Label */ ;
          }
#line 636
          goto switch_break___0;
          case_75: /* CIL Label */ 
#line 638
          i = 0;
          {
#line 638
          while (1) {
            while_continue___4: /* CIL Label */ ;
#line 638
            if (! (i < commandargc)) {
#line 638
              goto while_break___4;
            }
            {
#line 640
            GetPinholePackets(& urls, & data___2, (char const   *)*(commandargv + i));
#line 638
            i ++;
            }
          }
          while_break___4: /* CIL Label */ ;
          }
#line 642
          goto switch_break___0;
          case_68: /* CIL Label */ 
#line 644
          i = 0;
          {
#line 644
          while (1) {
            while_continue___5: /* CIL Label */ ;
#line 644
            if (! (i < commandargc)) {
#line 644
              goto while_break___5;
            }
            {
#line 646
            RemovePinhole(& urls, & data___2, (char const   *)*(commandargv + i));
#line 644
            i ++;
            }
          }
          while_break___5: /* CIL Label */ ;
          }
#line 648
          goto switch_break___0;
          case_83: /* CIL Label */ 
          {
#line 650
          GetFirewallStatus(& urls, & data___2);
          }
#line 651
          goto switch_break___0;
          case_71: /* CIL Label */ 
          {
#line 653
          GetPinholeOutboundTimeout(& urls, & data___2, (char const   *)*(commandargv + 0),
                                    (char const   *)*(commandargv + 1), (char const   *)*(commandargv + 2),
                                    (char const   *)*(commandargv + 3), (char const   *)*(commandargv + 4));
          }
#line 657
          goto switch_break___0;
          case_80: /* CIL Label */ 
          {
#line 659
          printf((char const   */* __restrict  */)"Presentation URL found:\n");
#line 660
          printf((char const   */* __restrict  */)"            %s\n", data___2.presentationurl);
          }
#line 661
          goto switch_break___0;
          switch_default___0: /* CIL Label */ 
          {
#line 663
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unknown switch -%c\n",
                  (int )command);
#line 664
          retcode = 1;
          }
          switch_break___0: /* CIL Label */ ;
          }
          {
#line 667
          FreeUPNPUrls(& urls);
          }
        } else {
          {
#line 671
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"No valid UPNP Internet Gateway Device found.\n");
#line 672
          retcode = 1;
          }
        }
      }
      {
#line 674
      freeUPNPDevlist(devlist);
#line 674
      devlist = (struct UPNPDev *)0;
      }
    } else {
      {
#line 678
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"No IGD UPnP Device found on the network !\n");
#line 679
      retcode = 1;
      }
    }
  }
#line 681
  return (retcode);
}
}
#line 187 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) unsigned long ( __attribute__((__nonnull__(1),
__leaf__)) strtoul)(char const   * __restrict  __nptr , char ** __restrict  __endptr ,
                    int __base ) ;
#line 433 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sscanf)(char const   * __restrict  __s ,
                                                                             char const   * __restrict  __format 
                                                                             , ...)  __asm__("__isoc99_sscanf")  ;
#line 147 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 143 "/home/wheatley/newnew/temp/miniupnpc-1.6/upnpcommands.h"
int UPNP_GetPortMappingNumberOfEntries(char const   *controlURL , char const   *servicetype ,
                                       unsigned int *numEntries ) ;
#line 15 "/home/wheatley/newnew/temp/miniupnpc-1.6/upnpcommands.c"
static unsigned int my_atoui(char const   *s ) 
{ 
  unsigned long tmp ;
  unsigned int tmp___0 ;

  {
#line 18
  if (s) {
    {
#line 18
    tmp = strtoul((char const   */* __restrict  */)s, (char **/* __restrict  */)((void *)0),
                  0);
#line 18
    tmp___0 = (unsigned int )tmp;
    }
  } else {
#line 18
    tmp___0 = 0U;
  }
#line 18
  return (tmp___0);
}
}
#line 23 "/home/wheatley/newnew/temp/miniupnpc-1.6/upnpcommands.c"
unsigned int UPNP_GetTotalBytesSent(char const   *controlURL , char const   *servicetype ) 
{ 
  struct NameValueParserData pdata ;
  char *buffer ;
  int bufsize ;
  unsigned int r ;
  char *p ;

  {
  {
#line 30
  r = 0U;
#line 32
  buffer = simpleUPnPcommand(-1, controlURL, servicetype, "GetTotalBytesSent", (struct UPNParg *)0,
                             & bufsize);
  }
#line 32
  if (! buffer) {
#line 34
    return (4294967293U);
  }
  {
#line 36
  ParseNameValue((char const   *)buffer, bufsize, & pdata);
#line 38
  free((void *)buffer);
#line 38
  buffer = (char *)((void *)0);
#line 39
  p = GetValueFromNameValueList(& pdata, "NewTotalBytesSent");
#line 40
  r = my_atoui((char const   *)p);
#line 41
  ClearNameValueList(& pdata);
  }
#line 42
  return (r);
}
}
#line 47 "/home/wheatley/newnew/temp/miniupnpc-1.6/upnpcommands.c"
unsigned int UPNP_GetTotalBytesReceived(char const   *controlURL , char const   *servicetype ) 
{ 
  struct NameValueParserData pdata ;
  char *buffer ;
  int bufsize ;
  unsigned int r ;
  char *p ;

  {
  {
#line 54
  r = 0U;
#line 56
  buffer = simpleUPnPcommand(-1, controlURL, servicetype, "GetTotalBytesReceived",
                             (struct UPNParg *)0, & bufsize);
  }
#line 56
  if (! buffer) {
#line 58
    return (4294967293U);
  }
  {
#line 60
  ParseNameValue((char const   *)buffer, bufsize, & pdata);
#line 62
  free((void *)buffer);
#line 62
  buffer = (char *)((void *)0);
#line 63
  p = GetValueFromNameValueList(& pdata, "NewTotalBytesReceived");
#line 64
  r = my_atoui((char const   *)p);
#line 65
  ClearNameValueList(& pdata);
  }
#line 66
  return (r);
}
}
#line 71 "/home/wheatley/newnew/temp/miniupnpc-1.6/upnpcommands.c"
unsigned int UPNP_GetTotalPacketsSent(char const   *controlURL , char const   *servicetype ) 
{ 
  struct NameValueParserData pdata ;
  char *buffer ;
  int bufsize ;
  unsigned int r ;
  char *p ;

  {
  {
#line 78
  r = 0U;
#line 80
  buffer = simpleUPnPcommand(-1, controlURL, servicetype, "GetTotalPacketsSent", (struct UPNParg *)0,
                             & bufsize);
  }
#line 80
  if (! buffer) {
#line 82
    return (4294967293U);
  }
  {
#line 84
  ParseNameValue((char const   *)buffer, bufsize, & pdata);
#line 86
  free((void *)buffer);
#line 86
  buffer = (char *)((void *)0);
#line 87
  p = GetValueFromNameValueList(& pdata, "NewTotalPacketsSent");
#line 88
  r = my_atoui((char const   *)p);
#line 89
  ClearNameValueList(& pdata);
  }
#line 90
  return (r);
}
}
#line 95 "/home/wheatley/newnew/temp/miniupnpc-1.6/upnpcommands.c"
unsigned int UPNP_GetTotalPacketsReceived(char const   *controlURL , char const   *servicetype ) 
{ 
  struct NameValueParserData pdata ;
  char *buffer ;
  int bufsize ;
  unsigned int r ;
  char *p ;

  {
  {
#line 102
  r = 0U;
#line 104
  buffer = simpleUPnPcommand(-1, controlURL, servicetype, "GetTotalPacketsReceived",
                             (struct UPNParg *)0, & bufsize);
  }
#line 104
  if (! buffer) {
#line 106
    return (4294967293U);
  }
  {
#line 108
  ParseNameValue((char const   *)buffer, bufsize, & pdata);
#line 110
  free((void *)buffer);
#line 110
  buffer = (char *)((void *)0);
#line 111
  p = GetValueFromNameValueList(& pdata, "NewTotalPacketsReceived");
#line 112
  r = my_atoui((char const   *)p);
#line 113
  ClearNameValueList(& pdata);
  }
#line 114
  return (r);
}
}
#line 119 "/home/wheatley/newnew/temp/miniupnpc-1.6/upnpcommands.c"
int UPNP_GetStatusInfo(char const   *controlURL , char const   *servicetype , char *status ,
                       unsigned int *uptime , char *lastconnerror ) 
{ 
  struct NameValueParserData pdata ;
  char *buffer ;
  int bufsize ;
  char *p ;
  char *up ;
  char *err ;
  int ret ;

  {
#line 132
  ret = -1;
#line 134
  if (! status) {
#line 134
    if (! uptime) {
#line 135
      return (-2);
    }
  }
  {
#line 137
  buffer = simpleUPnPcommand(-1, controlURL, servicetype, "GetStatusInfo", (struct UPNParg *)0,
                             & bufsize);
  }
#line 137
  if (! buffer) {
#line 139
    return (-3);
  }
  {
#line 141
  ParseNameValue((char const   *)buffer, bufsize, & pdata);
#line 143
  free((void *)buffer);
#line 143
  buffer = (char *)((void *)0);
#line 144
  up = GetValueFromNameValueList(& pdata, "NewUptime");
#line 145
  p = GetValueFromNameValueList(& pdata, "NewConnectionStatus");
#line 146
  err = GetValueFromNameValueList(& pdata, "NewLastConnectionError");
  }
#line 147
  if (p) {
#line 147
    if (up) {
#line 148
      ret = 0;
    }
  }
#line 150
  if (status) {
#line 151
    if (p) {
      {
#line 152
      strncpy((char */* __restrict  */)status, (char const   */* __restrict  */)p,
              (size_t )64);
#line 153
      *(status + 63) = (char )'\000';
      }
    } else {
#line 155
      *(status + 0) = (char )'\000';
    }
  }
#line 158
  if (uptime) {
#line 159
    if (up) {
      {
#line 160
      sscanf((char const   */* __restrict  */)up, (char const   */* __restrict  */)"%u",
             uptime);
      }
    } else {
#line 162
      uptime = (unsigned int *)0;
    }
  }
#line 165
  if (lastconnerror) {
#line 166
    if (err) {
      {
#line 167
      strncpy((char */* __restrict  */)lastconnerror, (char const   */* __restrict  */)err,
              (size_t )64);
#line 168
      *(lastconnerror + 63) = (char )'\000';
      }
    } else {
#line 170
      *(lastconnerror + 0) = (char )'\000';
    }
  }
  {
#line 173
  p = GetValueFromNameValueList(& pdata, "errorCode");
  }
#line 174
  if (p) {
    {
#line 175
    ret = -1;
#line 176
    sscanf((char const   */* __restrict  */)p, (char const   */* __restrict  */)"%d",
           & ret);
    }
  }
  {
#line 178
  ClearNameValueList(& pdata);
  }
#line 179
  return (ret);
}
}
#line 184 "/home/wheatley/newnew/temp/miniupnpc-1.6/upnpcommands.c"
int UPNP_GetConnectionTypeInfo(char const   *controlURL , char const   *servicetype ,
                               char *connectionType ) 
{ 
  struct NameValueParserData pdata ;
  char *buffer ;
  int bufsize ;
  char *p ;
  int ret ;

  {
#line 193
  ret = -1;
#line 195
  if (! connectionType) {
#line 196
    return (-2);
  }
  {
#line 198
  buffer = simpleUPnPcommand(-1, controlURL, servicetype, "GetConnectionTypeInfo",
                             (struct UPNParg *)0, & bufsize);
  }
#line 198
  if (! buffer) {
#line 200
    return (-3);
  }
  {
#line 202
  ParseNameValue((char const   *)buffer, bufsize, & pdata);
#line 203
  free((void *)buffer);
#line 203
  buffer = (char *)((void *)0);
#line 204
  p = GetValueFromNameValueList(& pdata, "NewConnectionType");
  }
#line 207
  if (p) {
    {
#line 208
    strncpy((char */* __restrict  */)connectionType, (char const   */* __restrict  */)p,
            (size_t )64);
#line 209
    *(connectionType + 63) = (char )'\000';
#line 210
    ret = 0;
    }
  } else {
#line 212
    *(connectionType + 0) = (char )'\000';
  }
  {
#line 213
  p = GetValueFromNameValueList(& pdata, "errorCode");
  }
#line 214
  if (p) {
    {
#line 215
    ret = -1;
#line 216
    sscanf((char const   */* __restrict  */)p, (char const   */* __restrict  */)"%d",
           & ret);
    }
  }
  {
#line 218
  ClearNameValueList(& pdata);
  }
#line 219
  return (ret);
}
}
#line 227 "/home/wheatley/newnew/temp/miniupnpc-1.6/upnpcommands.c"
int UPNP_GetLinkLayerMaxBitRates(char const   *controlURL , char const   *servicetype ,
                                 unsigned int *bitrateDown , unsigned int *bitrateUp ) 
{ 
  struct NameValueParserData pdata ;
  char *buffer ;
  int bufsize ;
  int ret ;
  char *down ;
  char *up ;
  char *p ;

  {
#line 236
  ret = -1;
#line 241
  if (! bitrateDown) {
#line 241
    if (! bitrateUp) {
#line 242
      return (-2);
    }
  }
  {
#line 245
  buffer = simpleUPnPcommand(-1, controlURL, servicetype, "GetCommonLinkProperties",
                             (struct UPNParg *)0, & bufsize);
  }
#line 245
  if (! buffer) {
#line 248
    return (-3);
  }
  {
#line 251
  ParseNameValue((char const   *)buffer, bufsize, & pdata);
#line 252
  free((void *)buffer);
#line 252
  buffer = (char *)((void *)0);
#line 255
  down = GetValueFromNameValueList(& pdata, "NewLayer1DownstreamMaxBitRate");
#line 256
  up = GetValueFromNameValueList(& pdata, "NewLayer1UpstreamMaxBitRate");
  }
#line 259
  if (down) {
#line 259
    if (up) {
#line 260
      ret = 0;
    }
  }
#line 262
  if (bitrateDown) {
#line 263
    if (down) {
      {
#line 264
      sscanf((char const   */* __restrict  */)down, (char const   */* __restrict  */)"%u",
             bitrateDown);
      }
    } else {
#line 266
      *bitrateDown = 0U;
    }
  }
#line 269
  if (bitrateUp) {
#line 270
    if (up) {
      {
#line 271
      sscanf((char const   */* __restrict  */)up, (char const   */* __restrict  */)"%u",
             bitrateUp);
      }
    } else {
#line 273
      *bitrateUp = 0U;
    }
  }
  {
#line 275
  p = GetValueFromNameValueList(& pdata, "errorCode");
  }
#line 276
  if (p) {
    {
#line 277
    ret = -1;
#line 278
    sscanf((char const   */* __restrict  */)p, (char const   */* __restrict  */)"%d",
           & ret);
    }
  }
  {
#line 280
  ClearNameValueList(& pdata);
  }
#line 281
  return (ret);
}
}
#line 296 "/home/wheatley/newnew/temp/miniupnpc-1.6/upnpcommands.c"
int UPNP_GetExternalIPAddress(char const   *controlURL , char const   *servicetype ,
                              char *extIpAdd ) 
{ 
  struct NameValueParserData pdata ;
  char *buffer ;
  int bufsize ;
  char *p ;
  int ret ;

  {
#line 305
  ret = -1;
#line 307
  if (! extIpAdd) {
#line 308
    return (-2);
  } else
#line 307
  if (! controlURL) {
#line 308
    return (-2);
  } else
#line 307
  if (! servicetype) {
#line 308
    return (-2);
  }
  {
#line 310
  buffer = simpleUPnPcommand(-1, controlURL, servicetype, "GetExternalIPAddress",
                             (struct UPNParg *)0, & bufsize);
  }
#line 310
  if (! buffer) {
#line 312
    return (-3);
  }
  {
#line 315
  ParseNameValue((char const   *)buffer, bufsize, & pdata);
#line 316
  free((void *)buffer);
#line 316
  buffer = (char *)((void *)0);
#line 318
  p = GetValueFromNameValueList(& pdata, "NewExternalIPAddress");
  }
#line 319
  if (p) {
    {
#line 320
    strncpy((char */* __restrict  */)extIpAdd, (char const   */* __restrict  */)p,
            (size_t )16);
#line 321
    *(extIpAdd + 15) = (char )'\000';
#line 322
    ret = 0;
    }
  } else {
#line 324
    *(extIpAdd + 0) = (char )'\000';
  }
  {
#line 326
  p = GetValueFromNameValueList(& pdata, "errorCode");
  }
#line 327
  if (p) {
    {
#line 328
    ret = -1;
#line 329
    sscanf((char const   */* __restrict  */)p, (char const   */* __restrict  */)"%d",
           & ret);
    }
  }
  {
#line 332
  ClearNameValueList(& pdata);
  }
#line 333
  return (ret);
}
}
#line 336 "/home/wheatley/newnew/temp/miniupnpc-1.6/upnpcommands.c"
int UPNP_AddPortMapping(char const   *controlURL , char const   *servicetype , char const   *extPort ,
                        char const   *inPort , char const   *inClient , char const   *desc ,
                        char const   *proto , char const   *remoteHost , char const   *leaseDuration ) 
{ 
  struct UPNParg *AddPortMappingArgs ;
  char *buffer ;
  int bufsize ;
  struct NameValueParserData pdata ;
  char const   *resVal ;
  int ret ;
  void *tmp ;
  char *tmp___0 ;

  {
#line 353
  if (! inPort) {
#line 354
    return (-2);
  } else
#line 353
  if (! inClient) {
#line 354
    return (-2);
  } else
#line 353
  if (! proto) {
#line 354
    return (-2);
  } else
#line 353
  if (! extPort) {
#line 354
    return (-2);
  }
  {
#line 356
  tmp = calloc((size_t )9, sizeof(struct UPNParg ));
#line 356
  AddPortMappingArgs = (struct UPNParg *)tmp;
#line 357
  (AddPortMappingArgs + 0)->elt = "NewRemoteHost";
#line 358
  (AddPortMappingArgs + 0)->val = remoteHost;
#line 359
  (AddPortMappingArgs + 1)->elt = "NewExternalPort";
#line 360
  (AddPortMappingArgs + 1)->val = extPort;
#line 361
  (AddPortMappingArgs + 2)->elt = "NewProtocol";
#line 362
  (AddPortMappingArgs + 2)->val = proto;
#line 363
  (AddPortMappingArgs + 3)->elt = "NewInternalPort";
#line 364
  (AddPortMappingArgs + 3)->val = inPort;
#line 365
  (AddPortMappingArgs + 4)->elt = "NewInternalClient";
#line 366
  (AddPortMappingArgs + 4)->val = inClient;
#line 367
  (AddPortMappingArgs + 5)->elt = "NewEnabled";
#line 368
  (AddPortMappingArgs + 5)->val = "1";
#line 369
  (AddPortMappingArgs + 6)->elt = "NewPortMappingDescription";
  }
#line 370
  if (desc) {
#line 370
    (AddPortMappingArgs + 6)->val = desc;
  } else {
#line 370
    (AddPortMappingArgs + 6)->val = "libminiupnpc";
  }
#line 371
  (AddPortMappingArgs + 7)->elt = "NewLeaseDuration";
#line 372
  if (leaseDuration) {
#line 372
    (AddPortMappingArgs + 7)->val = leaseDuration;
  } else {
#line 372
    (AddPortMappingArgs + 7)->val = "0";
  }
  {
#line 373
  buffer = simpleUPnPcommand(-1, controlURL, servicetype, "AddPortMapping", AddPortMappingArgs,
                             & bufsize);
  }
#line 373
  if (! buffer) {
    {
#line 376
    free((void *)AddPortMappingArgs);
    }
#line 377
    return (-3);
  }
  {
#line 382
  ParseNameValue((char const   *)buffer, bufsize, & pdata);
#line 383
  free((void *)buffer);
#line 383
  buffer = (char *)((void *)0);
#line 384
  tmp___0 = GetValueFromNameValueList(& pdata, "errorCode");
#line 384
  resVal = (char const   *)tmp___0;
  }
#line 385
  if (resVal) {
    {
#line 387
    ret = -1;
#line 388
    sscanf((char const   */* __restrict  */)resVal, (char const   */* __restrict  */)"%d",
           & ret);
    }
  } else {
#line 390
    ret = 0;
  }
  {
#line 392
  ClearNameValueList(& pdata);
#line 393
  free((void *)AddPortMappingArgs);
  }
#line 394
  return (ret);
}
}
#line 397 "/home/wheatley/newnew/temp/miniupnpc-1.6/upnpcommands.c"
int UPNP_DeletePortMapping(char const   *controlURL , char const   *servicetype ,
                           char const   *extPort , char const   *proto , char const   *remoteHost ) 
{ 
  struct UPNParg *DeletePortMappingArgs ;
  char *buffer ;
  int bufsize ;
  struct NameValueParserData pdata ;
  char const   *resVal ;
  int ret ;
  void *tmp ;
  char *tmp___0 ;

  {
#line 410
  if (! extPort) {
#line 411
    return (-2);
  } else
#line 410
  if (! proto) {
#line 411
    return (-2);
  }
  {
#line 413
  tmp = calloc((size_t )4, sizeof(struct UPNParg ));
#line 413
  DeletePortMappingArgs = (struct UPNParg *)tmp;
#line 414
  (DeletePortMappingArgs + 0)->elt = "NewRemoteHost";
#line 415
  (DeletePortMappingArgs + 0)->val = remoteHost;
#line 416
  (DeletePortMappingArgs + 1)->elt = "NewExternalPort";
#line 417
  (DeletePortMappingArgs + 1)->val = extPort;
#line 418
  (DeletePortMappingArgs + 2)->elt = "NewProtocol";
#line 419
  (DeletePortMappingArgs + 2)->val = proto;
#line 420
  buffer = simpleUPnPcommand(-1, controlURL, servicetype, "DeletePortMapping", DeletePortMappingArgs,
                             & bufsize);
  }
#line 420
  if (! buffer) {
    {
#line 423
    free((void *)DeletePortMappingArgs);
    }
#line 424
    return (-3);
  }
  {
#line 427
  ParseNameValue((char const   *)buffer, bufsize, & pdata);
#line 428
  free((void *)buffer);
#line 428
  buffer = (char *)((void *)0);
#line 429
  tmp___0 = GetValueFromNameValueList(& pdata, "errorCode");
#line 429
  resVal = (char const   *)tmp___0;
  }
#line 430
  if (resVal) {
    {
#line 431
    ret = -1;
#line 432
    sscanf((char const   */* __restrict  */)resVal, (char const   */* __restrict  */)"%d",
           & ret);
    }
  } else {
#line 434
    ret = 0;
  }
  {
#line 436
  ClearNameValueList(& pdata);
#line 437
  free((void *)DeletePortMappingArgs);
  }
#line 438
  return (ret);
}
}
#line 441 "/home/wheatley/newnew/temp/miniupnpc-1.6/upnpcommands.c"
int UPNP_GetGenericPortMappingEntry(char const   *controlURL , char const   *servicetype ,
                                    char const   *index___0 , char *extPort , char *intClient ,
                                    char *intPort , char *protocol , char *desc ,
                                    char *enabled , char *rHost , char *duration ) 
{ 
  struct NameValueParserData pdata ;
  struct UPNParg *GetPortMappingArgs ;
  char *buffer ;
  int bufsize ;
  char *p ;
  int r ;
  void *tmp ;

  {
#line 459
  r = -1;
#line 460
  if (! index___0) {
#line 461
    return (-2);
  }
  {
#line 462
  *(intClient + 0) = (char )'\000';
#line 463
  *(intPort + 0) = (char )'\000';
#line 464
  tmp = calloc((size_t )2, sizeof(struct UPNParg ));
#line 464
  GetPortMappingArgs = (struct UPNParg *)tmp;
#line 465
  (GetPortMappingArgs + 0)->elt = "NewPortMappingIndex";
#line 466
  (GetPortMappingArgs + 0)->val = index___0;
#line 467
  buffer = simpleUPnPcommand(-1, controlURL, servicetype, "GetGenericPortMappingEntry",
                             GetPortMappingArgs, & bufsize);
  }
#line 467
  if (! buffer) {
    {
#line 470
    free((void *)GetPortMappingArgs);
    }
#line 471
    return (-3);
  }
  {
#line 473
  ParseNameValue((char const   *)buffer, bufsize, & pdata);
#line 474
  free((void *)buffer);
#line 474
  buffer = (char *)((void *)0);
#line 476
  p = GetValueFromNameValueList(& pdata, "NewRemoteHost");
  }
#line 477
  if (p) {
#line 477
    if (rHost) {
      {
#line 479
      strncpy((char */* __restrict  */)rHost, (char const   */* __restrict  */)p,
              (size_t )64);
#line 480
      *(rHost + 63) = (char )'\000';
      }
    }
  }
  {
#line 482
  p = GetValueFromNameValueList(& pdata, "NewExternalPort");
  }
#line 483
  if (p) {
#line 483
    if (extPort) {
      {
#line 485
      strncpy((char */* __restrict  */)extPort, (char const   */* __restrict  */)p,
              (size_t )6);
#line 486
      *(extPort + 5) = (char )'\000';
#line 487
      r = 0;
      }
    }
  }
  {
#line 489
  p = GetValueFromNameValueList(& pdata, "NewProtocol");
  }
#line 490
  if (p) {
#line 490
    if (protocol) {
      {
#line 492
      strncpy((char */* __restrict  */)protocol, (char const   */* __restrict  */)p,
              (size_t )4);
#line 493
      *(protocol + 3) = (char )'\000';
      }
    }
  }
  {
#line 495
  p = GetValueFromNameValueList(& pdata, "NewInternalClient");
  }
#line 496
  if (p) {
#line 496
    if (intClient) {
      {
#line 498
      strncpy((char */* __restrict  */)intClient, (char const   */* __restrict  */)p,
              (size_t )16);
#line 499
      *(intClient + 15) = (char )'\000';
#line 500
      r = 0;
      }
    }
  }
  {
#line 502
  p = GetValueFromNameValueList(& pdata, "NewInternalPort");
  }
#line 503
  if (p) {
#line 503
    if (intPort) {
      {
#line 505
      strncpy((char */* __restrict  */)intPort, (char const   */* __restrict  */)p,
              (size_t )6);
#line 506
      *(intPort + 5) = (char )'\000';
      }
    }
  }
  {
#line 508
  p = GetValueFromNameValueList(& pdata, "NewEnabled");
  }
#line 509
  if (p) {
#line 509
    if (enabled) {
      {
#line 511
      strncpy((char */* __restrict  */)enabled, (char const   */* __restrict  */)p,
              (size_t )4);
#line 512
      *(enabled + 3) = (char )'\000';
      }
    }
  }
  {
#line 514
  p = GetValueFromNameValueList(& pdata, "NewPortMappingDescription");
  }
#line 515
  if (p) {
#line 515
    if (desc) {
      {
#line 517
      strncpy((char */* __restrict  */)desc, (char const   */* __restrict  */)p, (size_t )80);
#line 518
      *(desc + 79) = (char )'\000';
      }
    }
  }
  {
#line 520
  p = GetValueFromNameValueList(& pdata, "NewLeaseDuration");
  }
#line 521
  if (p) {
#line 521
    if (duration) {
      {
#line 523
      strncpy((char */* __restrict  */)duration, (char const   */* __restrict  */)p,
              (size_t )16);
#line 524
      *(duration + 15) = (char )'\000';
      }
    }
  }
  {
#line 526
  p = GetValueFromNameValueList(& pdata, "errorCode");
  }
#line 527
  if (p) {
    {
#line 528
    r = -1;
#line 529
    sscanf((char const   */* __restrict  */)p, (char const   */* __restrict  */)"%d",
           & r);
    }
  }
  {
#line 531
  ClearNameValueList(& pdata);
#line 532
  free((void *)GetPortMappingArgs);
  }
#line 533
  return (r);
}
}
#line 536 "/home/wheatley/newnew/temp/miniupnpc-1.6/upnpcommands.c"
int UPNP_GetPortMappingNumberOfEntries(char const   *controlURL , char const   *servicetype ,
                                       unsigned int *numEntries ) 
{ 
  struct NameValueParserData pdata ;
  char *buffer ;
  int bufsize ;
  char *p ;
  int ret ;

  {
  {
#line 545
  ret = -1;
#line 546
  buffer = simpleUPnPcommand(-1, controlURL, servicetype, "GetPortMappingNumberOfEntries",
                             (struct UPNParg *)0, & bufsize);
  }
#line 546
  if (! buffer) {
#line 549
    return (-3);
  }
  {
#line 554
  ParseNameValue((char const   *)buffer, bufsize, & pdata);
#line 555
  free((void *)buffer);
#line 555
  buffer = (char *)((void *)0);
#line 557
  p = GetValueFromNameValueList(& pdata, "NewPortMappingNumberOfEntries");
  }
#line 558
  if (numEntries) {
#line 558
    if (p) {
      {
#line 559
      *numEntries = 0U;
#line 560
      sscanf((char const   */* __restrict  */)p, (char const   */* __restrict  */)"%u",
             numEntries);
#line 561
      ret = 0;
      }
    }
  }
  {
#line 564
  p = GetValueFromNameValueList(& pdata, "errorCode");
  }
#line 565
  if (p) {
    {
#line 566
    ret = -1;
#line 567
    sscanf((char const   */* __restrict  */)p, (char const   */* __restrict  */)"%d",
           & ret);
    }
  }
  {
#line 570
  ClearNameValueList(& pdata);
  }
#line 571
  return (ret);
}
}
#line 577 "/home/wheatley/newnew/temp/miniupnpc-1.6/upnpcommands.c"
int UPNP_GetSpecificPortMappingEntry(char const   *controlURL , char const   *servicetype ,
                                     char const   *extPort , char const   *proto ,
                                     char *intClient , char *intPort , char *desc ,
                                     char *enabled , char *leaseDuration ) 
{ 
  struct NameValueParserData pdata ;
  struct UPNParg *GetPortMappingArgs ;
  char *buffer ;
  int bufsize ;
  char *p ;
  int ret ;
  void *tmp ;

  {
#line 593
  ret = -1;
#line 595
  if (! intPort) {
#line 596
    return (-2);
  } else
#line 595
  if (! intClient) {
#line 596
    return (-2);
  } else
#line 595
  if (! extPort) {
#line 596
    return (-2);
  } else
#line 595
  if (! proto) {
#line 596
    return (-2);
  }
  {
#line 598
  tmp = calloc((size_t )4, sizeof(struct UPNParg ));
#line 598
  GetPortMappingArgs = (struct UPNParg *)tmp;
#line 599
  (GetPortMappingArgs + 0)->elt = "NewRemoteHost";
#line 601
  (GetPortMappingArgs + 1)->elt = "NewExternalPort";
#line 602
  (GetPortMappingArgs + 1)->val = extPort;
#line 603
  (GetPortMappingArgs + 2)->elt = "NewProtocol";
#line 604
  (GetPortMappingArgs + 2)->val = proto;
#line 605
  buffer = simpleUPnPcommand(-1, controlURL, servicetype, "GetSpecificPortMappingEntry",
                             GetPortMappingArgs, & bufsize);
  }
#line 605
  if (! buffer) {
    {
#line 608
    free((void *)GetPortMappingArgs);
    }
#line 609
    return (-3);
  }
  {
#line 612
  ParseNameValue((char const   *)buffer, bufsize, & pdata);
#line 613
  free((void *)buffer);
#line 613
  buffer = (char *)((void *)0);
#line 615
  p = GetValueFromNameValueList(& pdata, "NewInternalClient");
  }
#line 616
  if (p) {
    {
#line 617
    strncpy((char */* __restrict  */)intClient, (char const   */* __restrict  */)p,
            (size_t )16);
#line 618
    *(intClient + 15) = (char )'\000';
#line 619
    ret = 0;
    }
  } else {
#line 621
    *(intClient + 0) = (char )'\000';
  }
  {
#line 623
  p = GetValueFromNameValueList(& pdata, "NewInternalPort");
  }
#line 624
  if (p) {
    {
#line 625
    strncpy((char */* __restrict  */)intPort, (char const   */* __restrict  */)p,
            (size_t )6);
#line 626
    *(intPort + 5) = (char )'\000';
    }
  } else {
#line 628
    *(intPort + 0) = (char )'\000';
  }
  {
#line 630
  p = GetValueFromNameValueList(& pdata, "NewEnabled");
  }
#line 631
  if (p) {
#line 631
    if (enabled) {
      {
#line 632
      strncpy((char */* __restrict  */)enabled, (char const   */* __restrict  */)p,
              (size_t )4);
#line 633
      *(enabled + 3) = (char )'\000';
      }
    }
  }
  {
#line 636
  p = GetValueFromNameValueList(& pdata, "NewPortMappingDescription");
  }
#line 637
  if (p) {
#line 637
    if (desc) {
      {
#line 638
      strncpy((char */* __restrict  */)desc, (char const   */* __restrict  */)p, (size_t )80);
#line 639
      *(desc + 79) = (char )'\000';
      }
    }
  }
  {
#line 642
  p = GetValueFromNameValueList(& pdata, "NewLeaseDuration");
  }
#line 643
  if (p) {
#line 643
    if (leaseDuration) {
      {
#line 645
      strncpy((char */* __restrict  */)leaseDuration, (char const   */* __restrict  */)p,
              (size_t )16);
#line 646
      *(leaseDuration + 15) = (char )'\000';
      }
    }
  }
  {
#line 649
  p = GetValueFromNameValueList(& pdata, "errorCode");
  }
#line 650
  if (p) {
    {
#line 651
    ret = -1;
#line 652
    sscanf((char const   */* __restrict  */)p, (char const   */* __restrict  */)"%d",
           & ret);
    }
  }
  {
#line 655
  ClearNameValueList(& pdata);
#line 656
  free((void *)GetPortMappingArgs);
  }
#line 657
  return (ret);
}
}
#line 668 "/home/wheatley/newnew/temp/miniupnpc-1.6/upnpcommands.c"
int UPNP_GetListOfPortMappings(char const   *controlURL , char const   *servicetype ,
                               char const   *startPort , char const   *endPort , char const   *protocol ,
                               char const   *numberOfPorts , struct PortMappingParserData *data___2 ) 
{ 
  struct NameValueParserData pdata ;
  struct UPNParg *GetListOfPortMappingsArgs ;
  char const   *p ;
  char *buffer ;
  int bufsize ;
  int ret ;
  void *tmp ;
  char *tmp___0 ;

  {
#line 682
  ret = -1;
#line 684
  if (! startPort) {
#line 685
    return (-2);
  } else
#line 684
  if (! endPort) {
#line 685
    return (-2);
  } else
#line 684
  if (! protocol) {
#line 685
    return (-2);
  }
  {
#line 687
  tmp = calloc((size_t )6, sizeof(struct UPNParg ));
#line 687
  GetListOfPortMappingsArgs = (struct UPNParg *)tmp;
#line 688
  (GetListOfPortMappingsArgs + 0)->elt = "NewStartPort";
#line 689
  (GetListOfPortMappingsArgs + 0)->val = startPort;
#line 690
  (GetListOfPortMappingsArgs + 1)->elt = "NewEndPort";
#line 691
  (GetListOfPortMappingsArgs + 1)->val = endPort;
#line 692
  (GetListOfPortMappingsArgs + 2)->elt = "NewProtocol";
#line 693
  (GetListOfPortMappingsArgs + 2)->val = protocol;
#line 694
  (GetListOfPortMappingsArgs + 3)->elt = "NewManage";
#line 695
  (GetListOfPortMappingsArgs + 3)->val = "1";
#line 696
  (GetListOfPortMappingsArgs + 4)->elt = "NewNumberOfPorts";
  }
#line 697
  if (numberOfPorts) {
#line 697
    (GetListOfPortMappingsArgs + 4)->val = numberOfPorts;
  } else {
#line 697
    (GetListOfPortMappingsArgs + 4)->val = "1000";
  }
  {
#line 699
  buffer = simpleUPnPcommand(-1, controlURL, servicetype, "GetListOfPortMappings",
                             GetListOfPortMappingsArgs, & bufsize);
  }
#line 699
  if (! buffer) {
    {
#line 702
    free((void *)GetListOfPortMappingsArgs);
    }
#line 703
    return (-3);
  }
  {
#line 705
  free((void *)GetListOfPortMappingsArgs);
#line 708
  ParseNameValue((char const   *)buffer, bufsize, & pdata);
#line 709
  free((void *)buffer);
#line 709
  buffer = (char *)((void *)0);
  }
#line 717
  if (pdata.portListing) {
    {
#line 721
    ParsePortListing((char const   *)pdata.portListing, pdata.portListingLength, data___2);
#line 723
    ret = 0;
    }
  }
  {
#line 737
  tmp___0 = GetValueFromNameValueList(& pdata, "errorCode");
#line 737
  p = (char const   *)tmp___0;
  }
#line 738
  if (p) {
    {
#line 739
    ret = -1;
#line 740
    sscanf((char const   */* __restrict  */)p, (char const   */* __restrict  */)"%d",
           & ret);
    }
  }
  {
#line 742
  ClearNameValueList(& pdata);
  }
#line 746
  return (ret);
}
}
#line 750 "/home/wheatley/newnew/temp/miniupnpc-1.6/upnpcommands.c"
int UPNP_GetFirewallStatus(char const   *controlURL , char const   *servicetype ,
                           int *firewallEnabled , int *inboundPinholeAllowed ) 
{ 
  struct NameValueParserData pdata ;
  char *buffer ;
  int bufsize ;
  char *fe ;
  char *ipa ;
  char *p ;
  int ret ;
  unsigned int tmp ;
  unsigned int tmp___0 ;

  {
#line 760
  ret = -1;
#line 762
  if (! firewallEnabled) {
#line 762
    if (! inboundPinholeAllowed) {
#line 763
      return (-2);
    }
  }
  {
#line 765
  buffer = simpleUPnPcommand(-1, controlURL, servicetype, "GetFirewallStatus", (struct UPNParg *)0,
                             & bufsize);
  }
#line 767
  if (! buffer) {
#line 768
    return (-3);
  }
  {
#line 770
  ParseNameValue((char const   *)buffer, bufsize, & pdata);
#line 771
  free((void *)buffer);
#line 771
  buffer = (char *)((void *)0);
#line 772
  fe = GetValueFromNameValueList(& pdata, "FirewallEnabled");
#line 773
  ipa = GetValueFromNameValueList(& pdata, "InboundPinholeAllowed");
  }
#line 774
  if (ipa) {
#line 774
    if (fe) {
#line 775
      ret = 0;
    }
  }
#line 776
  if (fe) {
    {
#line 777
    tmp = my_atoui((char const   *)fe);
#line 777
    *firewallEnabled = (int )tmp;
    }
  }
#line 780
  if (ipa) {
    {
#line 781
    tmp___0 = my_atoui((char const   *)ipa);
#line 781
    *inboundPinholeAllowed = (int )tmp___0;
    }
  }
  {
#line 784
  p = GetValueFromNameValueList(& pdata, "errorCode");
  }
#line 785
  if (p) {
    {
#line 787
    ret = -1;
#line 788
    sscanf((char const   */* __restrict  */)p, (char const   */* __restrict  */)"%d",
           & ret);
    }
  }
  {
#line 790
  ClearNameValueList(& pdata);
  }
#line 791
  return (ret);
}
}
#line 794 "/home/wheatley/newnew/temp/miniupnpc-1.6/upnpcommands.c"
int UPNP_GetOutboundPinholeTimeout(char const   *controlURL , char const   *servicetype ,
                                   char const   *remoteHost , char const   *remotePort ,
                                   char const   *intClient , char const   *intPort ,
                                   char const   *proto , int *opTimeout ) 
{ 
  struct UPNParg *GetOutboundPinholeTimeoutArgs ;
  char *buffer ;
  int bufsize ;
  struct NameValueParserData pdata ;
  char const   *resVal ;
  char *p ;
  int ret ;
  void *tmp ;
  char *tmp___0 ;
  unsigned int tmp___1 ;

  {
#line 811
  if (! intPort) {
#line 812
    return (-2);
  } else
#line 811
  if (! intClient) {
#line 812
    return (-2);
  } else
#line 811
  if (! proto) {
#line 812
    return (-2);
  } else
#line 811
  if (! remotePort) {
#line 812
    return (-2);
  } else
#line 811
  if (! remoteHost) {
#line 812
    return (-2);
  }
  {
#line 814
  tmp = calloc((size_t )6, sizeof(struct UPNParg ));
#line 814
  GetOutboundPinholeTimeoutArgs = (struct UPNParg *)tmp;
#line 815
  (GetOutboundPinholeTimeoutArgs + 0)->elt = "RemoteHost";
#line 816
  (GetOutboundPinholeTimeoutArgs + 0)->val = remoteHost;
#line 817
  (GetOutboundPinholeTimeoutArgs + 1)->elt = "RemotePort";
#line 818
  (GetOutboundPinholeTimeoutArgs + 1)->val = remotePort;
#line 819
  (GetOutboundPinholeTimeoutArgs + 2)->elt = "Protocol";
#line 820
  (GetOutboundPinholeTimeoutArgs + 2)->val = proto;
#line 821
  (GetOutboundPinholeTimeoutArgs + 3)->elt = "InternalPort";
#line 822
  (GetOutboundPinholeTimeoutArgs + 3)->val = intPort;
#line 823
  (GetOutboundPinholeTimeoutArgs + 4)->elt = "InternalClient";
#line 824
  (GetOutboundPinholeTimeoutArgs + 4)->val = intClient;
#line 825
  buffer = simpleUPnPcommand(-1, controlURL, servicetype, "GetOutboundPinholeTimeout",
                             GetOutboundPinholeTimeoutArgs, & bufsize);
  }
#line 827
  if (! buffer) {
#line 828
    return (-3);
  }
  {
#line 829
  ParseNameValue((char const   *)buffer, bufsize, & pdata);
#line 830
  free((void *)buffer);
#line 830
  buffer = (char *)((void *)0);
#line 831
  tmp___0 = GetValueFromNameValueList(& pdata, "errorCode");
#line 831
  resVal = (char const   *)tmp___0;
  }
#line 832
  if (resVal) {
    {
#line 834
    ret = -1;
#line 835
    sscanf((char const   */* __restrict  */)resVal, (char const   */* __restrict  */)"%d",
           & ret);
    }
  } else {
    {
#line 839
    ret = 0;
#line 840
    p = GetValueFromNameValueList(& pdata, "OutboundPinholeTimeout");
    }
#line 841
    if (p) {
      {
#line 842
      tmp___1 = my_atoui((char const   *)p);
#line 842
      *opTimeout = (int )tmp___1;
      }
    }
  }
  {
#line 844
  ClearNameValueList(& pdata);
#line 845
  free((void *)GetOutboundPinholeTimeoutArgs);
  }
#line 846
  return (ret);
}
}
#line 849 "/home/wheatley/newnew/temp/miniupnpc-1.6/upnpcommands.c"
int UPNP_AddPinhole(char const   *controlURL , char const   *servicetype , char const   *remoteHost ,
                    char const   *remotePort , char const   *intClient , char const   *intPort ,
                    char const   *proto , char const   *leaseTime , char *uniqueID ) 
{ 
  struct UPNParg *AddPinholeArgs ;
  char *buffer ;
  int bufsize ;
  struct NameValueParserData pdata ;
  char const   *resVal ;
  char *p ;
  int ret ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;

  {
#line 867
  if (! intPort) {
#line 868
    return (-2);
  } else
#line 867
  if (! intClient) {
#line 868
    return (-2);
  } else
#line 867
  if (! proto) {
#line 868
    return (-2);
  } else
#line 867
  if (! remoteHost) {
#line 868
    return (-2);
  } else
#line 867
  if (! remotePort) {
#line 868
    return (-2);
  } else
#line 867
  if (! leaseTime) {
#line 868
    return (-2);
  }
  {
#line 870
  tmp = calloc((size_t )7, sizeof(struct UPNParg ));
#line 870
  AddPinholeArgs = (struct UPNParg *)tmp;
#line 872
  tmp___0 = strncmp(remoteHost, "empty", (size_t )5);
  }
#line 872
  if (tmp___0 == 0) {
#line 874
    (AddPinholeArgs + 0)->elt = "RemoteHost";
#line 875
    (AddPinholeArgs + 0)->val = "";
  } else {
#line 879
    (AddPinholeArgs + 0)->elt = "RemoteHost";
#line 880
    (AddPinholeArgs + 0)->val = remoteHost;
  }
  {
#line 882
  (AddPinholeArgs + 1)->elt = "RemotePort";
#line 883
  (AddPinholeArgs + 1)->val = remotePort;
#line 884
  (AddPinholeArgs + 2)->elt = "Protocol";
#line 885
  (AddPinholeArgs + 2)->val = proto;
#line 886
  (AddPinholeArgs + 3)->elt = "InternalPort";
#line 887
  (AddPinholeArgs + 3)->val = intPort;
#line 888
  tmp___1 = strncmp(intClient, "empty", (size_t )5);
  }
#line 888
  if (tmp___1 == 0) {
#line 890
    (AddPinholeArgs + 4)->elt = "InternalClient";
#line 891
    (AddPinholeArgs + 4)->val = "";
  } else {
#line 895
    (AddPinholeArgs + 4)->elt = "InternalClient";
#line 896
    (AddPinholeArgs + 4)->val = intClient;
  }
  {
#line 898
  (AddPinholeArgs + 5)->elt = "LeaseTime";
#line 899
  (AddPinholeArgs + 5)->val = leaseTime;
#line 900
  buffer = simpleUPnPcommand(-1, controlURL, servicetype, "AddPinhole", AddPinholeArgs,
                             & bufsize);
  }
#line 902
  if (! buffer) {
#line 903
    return (-3);
  }
  {
#line 904
  ParseNameValue((char const   *)buffer, bufsize, & pdata);
#line 905
  free((void *)buffer);
#line 905
  buffer = (char *)((void *)0);
#line 906
  p = GetValueFromNameValueList(& pdata, "UniqueID");
  }
#line 907
  if (p) {
    {
#line 909
    strncpy((char */* __restrict  */)uniqueID, (char const   */* __restrict  */)p,
            (size_t )8);
#line 910
    *(uniqueID + 7) = (char )'\000';
    }
  }
  {
#line 912
  tmp___2 = GetValueFromNameValueList(& pdata, "errorCode");
#line 912
  resVal = (char const   *)tmp___2;
  }
#line 913
  if (resVal) {
    {
#line 916
    ret = -1;
#line 917
    sscanf((char const   */* __restrict  */)resVal, (char const   */* __restrict  */)"%d",
           & ret);
    }
  } else {
#line 921
    ret = 0;
  }
  {
#line 923
  ClearNameValueList(& pdata);
#line 924
  free((void *)AddPinholeArgs);
  }
#line 925
  return (ret);
}
}
#line 928 "/home/wheatley/newnew/temp/miniupnpc-1.6/upnpcommands.c"
int UPNP_UpdatePinhole(char const   *controlURL , char const   *servicetype , char const   *uniqueID ,
                       char const   *leaseTime ) 
{ 
  struct UPNParg *UpdatePinholeArgs ;
  char *buffer ;
  int bufsize ;
  struct NameValueParserData pdata ;
  char const   *resVal ;
  int ret ;
  void *tmp ;
  char *tmp___0 ;

  {
#line 940
  if (! uniqueID) {
#line 941
    return (-2);
  } else
#line 940
  if (! leaseTime) {
#line 941
    return (-2);
  }
  {
#line 943
  tmp = calloc((size_t )3, sizeof(struct UPNParg ));
#line 943
  UpdatePinholeArgs = (struct UPNParg *)tmp;
#line 944
  (UpdatePinholeArgs + 0)->elt = "UniqueID";
#line 945
  (UpdatePinholeArgs + 0)->val = uniqueID;
#line 946
  (UpdatePinholeArgs + 1)->elt = "NewLeaseTime";
#line 947
  (UpdatePinholeArgs + 1)->val = leaseTime;
#line 948
  buffer = simpleUPnPcommand(-1, controlURL, servicetype, "UpdatePinhole", UpdatePinholeArgs,
                             & bufsize);
  }
#line 950
  if (! buffer) {
#line 951
    return (-3);
  }
  {
#line 952
  ParseNameValue((char const   *)buffer, bufsize, & pdata);
#line 953
  free((void *)buffer);
#line 953
  buffer = (char *)((void *)0);
#line 954
  tmp___0 = GetValueFromNameValueList(& pdata, "errorCode");
#line 954
  resVal = (char const   *)tmp___0;
  }
#line 955
  if (resVal) {
    {
#line 958
    ret = -1;
#line 959
    sscanf((char const   */* __restrict  */)resVal, (char const   */* __restrict  */)"%d",
           & ret);
    }
  } else {
#line 963
    ret = 0;
  }
  {
#line 965
  ClearNameValueList(& pdata);
#line 966
  free((void *)UpdatePinholeArgs);
  }
#line 967
  return (ret);
}
}
#line 970 "/home/wheatley/newnew/temp/miniupnpc-1.6/upnpcommands.c"
int UPNP_DeletePinhole(char const   *controlURL , char const   *servicetype , char const   *uniqueID ) 
{ 
  struct UPNParg *DeletePinholeArgs ;
  char *buffer ;
  int bufsize ;
  struct NameValueParserData pdata ;
  char const   *resVal ;
  int ret ;
  void *tmp ;
  char *tmp___0 ;

  {
#line 981
  if (! uniqueID) {
#line 982
    return (-2);
  }
  {
#line 984
  tmp = calloc((size_t )2, sizeof(struct UPNParg ));
#line 984
  DeletePinholeArgs = (struct UPNParg *)tmp;
#line 985
  (DeletePinholeArgs + 0)->elt = "UniqueID";
#line 986
  (DeletePinholeArgs + 0)->val = uniqueID;
#line 987
  buffer = simpleUPnPcommand(-1, controlURL, servicetype, "DeletePinhole", DeletePinholeArgs,
                             & bufsize);
  }
#line 989
  if (! buffer) {
#line 990
    return (-3);
  }
  {
#line 992
  ParseNameValue((char const   *)buffer, bufsize, & pdata);
#line 993
  free((void *)buffer);
#line 993
  buffer = (char *)((void *)0);
#line 994
  tmp___0 = GetValueFromNameValueList(& pdata, "errorCode");
#line 994
  resVal = (char const   *)tmp___0;
  }
#line 995
  if (resVal) {
    {
#line 997
    ret = -1;
#line 998
    sscanf((char const   */* __restrict  */)resVal, (char const   */* __restrict  */)"%d",
           & ret);
    }
  } else {
#line 1002
    ret = 0;
  }
  {
#line 1004
  ClearNameValueList(& pdata);
#line 1005
  free((void *)DeletePinholeArgs);
  }
#line 1006
  return (ret);
}
}
#line 1009 "/home/wheatley/newnew/temp/miniupnpc-1.6/upnpcommands.c"
int UPNP_CheckPinholeWorking(char const   *controlURL , char const   *servicetype ,
                             char const   *uniqueID , int *isWorking ) 
{ 
  struct NameValueParserData pdata ;
  struct UPNParg *CheckPinholeWorkingArgs ;
  char *buffer ;
  int bufsize ;
  char *p ;
  int ret ;
  void *tmp ;
  unsigned int tmp___0 ;

  {
#line 1018
  ret = -1;
#line 1020
  if (! uniqueID) {
#line 1021
    return (-2);
  }
  {
#line 1023
  tmp = calloc((size_t )4, sizeof(struct UPNParg ));
#line 1023
  CheckPinholeWorkingArgs = (struct UPNParg *)tmp;
#line 1024
  (CheckPinholeWorkingArgs + 0)->elt = "UniqueID";
#line 1025
  (CheckPinholeWorkingArgs + 0)->val = uniqueID;
#line 1026
  buffer = simpleUPnPcommand(-1, controlURL, servicetype, "CheckPinholeWorking", CheckPinholeWorkingArgs,
                             & bufsize);
  }
#line 1028
  if (! buffer) {
#line 1029
    return (-3);
  }
  {
#line 1030
  ParseNameValue((char const   *)buffer, bufsize, & pdata);
#line 1031
  free((void *)buffer);
#line 1031
  buffer = (char *)((void *)0);
#line 1033
  p = GetValueFromNameValueList(& pdata, "IsWorking");
  }
#line 1034
  if (p) {
    {
#line 1036
    tmp___0 = my_atoui((char const   *)p);
#line 1036
    *isWorking = (int )tmp___0;
#line 1037
    ret = 0;
    }
  } else {
#line 1040
    *isWorking = 0;
  }
  {
#line 1042
  p = GetValueFromNameValueList(& pdata, "errorCode");
  }
#line 1043
  if (p) {
    {
#line 1045
    ret = -1;
#line 1046
    sscanf((char const   */* __restrict  */)p, (char const   */* __restrict  */)"%d",
           & ret);
    }
  }
  {
#line 1049
  ClearNameValueList(& pdata);
#line 1050
  free((void *)CheckPinholeWorkingArgs);
  }
#line 1051
  return (ret);
}
}
#line 1054 "/home/wheatley/newnew/temp/miniupnpc-1.6/upnpcommands.c"
int UPNP_GetPinholePackets(char const   *controlURL , char const   *servicetype ,
                           char const   *uniqueID , int *packets ) 
{ 
  struct NameValueParserData pdata ;
  struct UPNParg *GetPinholePacketsArgs ;
  char *buffer ;
  int bufsize ;
  char *p ;
  int ret ;
  void *tmp ;
  unsigned int tmp___0 ;

  {
#line 1063
  ret = -1;
#line 1065
  if (! uniqueID) {
#line 1066
    return (-2);
  }
  {
#line 1068
  tmp = calloc((size_t )4, sizeof(struct UPNParg ));
#line 1068
  GetPinholePacketsArgs = (struct UPNParg *)tmp;
#line 1069
  (GetPinholePacketsArgs + 0)->elt = "UniqueID";
#line 1070
  (GetPinholePacketsArgs + 0)->val = uniqueID;
#line 1071
  buffer = simpleUPnPcommand(-1, controlURL, servicetype, "GetPinholePackets", GetPinholePacketsArgs,
                             & bufsize);
  }
#line 1073
  if (! buffer) {
#line 1074
    return (-3);
  }
  {
#line 1075
  ParseNameValue((char const   *)buffer, bufsize, & pdata);
#line 1076
  free((void *)buffer);
#line 1076
  buffer = (char *)((void *)0);
#line 1078
  p = GetValueFromNameValueList(& pdata, "PinholePackets");
  }
#line 1079
  if (p) {
    {
#line 1081
    tmp___0 = my_atoui((char const   *)p);
#line 1081
    *packets = (int )tmp___0;
#line 1082
    ret = 0;
    }
  }
  {
#line 1085
  p = GetValueFromNameValueList(& pdata, "errorCode");
  }
#line 1086
  if (p) {
    {
#line 1088
    ret = -1;
#line 1089
    sscanf((char const   */* __restrict  */)p, (char const   */* __restrict  */)"%d",
           & ret);
    }
  }
  {
#line 1092
  ClearNameValueList(& pdata);
#line 1093
  free((void *)GetPinholePacketsArgs);
  }
#line 1094
  return (ret);
}
}
#line 149 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern ssize_t send(int __fd , void const   *__buf , size_t __n , int __flags ) ;
#line 35 "/home/wheatley/newnew/temp/miniupnpc-1.6/minisoap.c"
static int httpWrite(int fd , char const   *body , int bodysize , char const   *headers ,
                     int headerssize ) 
{ 
  int n ;
  char *p ;
  void *tmp ;
  ssize_t tmp___0 ;

  {
  {
#line 39
  n = 0;
#line 47
  tmp = malloc((size_t )(headerssize + bodysize));
#line 47
  p = (char *)tmp;
  }
#line 48
  if (! p) {
#line 49
    return (0);
  }
  {
#line 50
  memcpy((void */* __restrict  */)p, (void const   */* __restrict  */)headers, (size_t )headerssize);
#line 51
  memcpy((void */* __restrict  */)(p + headerssize), (void const   */* __restrict  */)body,
         (size_t )bodysize);
#line 53
  tmp___0 = send(fd, (void const   *)p, (size_t )(headerssize + bodysize), 0);
#line 53
  n = (int )tmp___0;
  }
#line 54
  if (n < 0) {
    {
#line 55
    perror("send");
    }
  }
  {
#line 68
  free((void *)p);
  }
#line 69
  return (n);
}
}
#line 73 "/home/wheatley/newnew/temp/miniupnpc-1.6/minisoap.c"
int soapPostSubmit(int fd , char const   *url , char const   *host , unsigned short port ,
                   char const   *action , char const   *body , char const   *httpversion ) 
{ 
  int bodysize ;
  char headerbuf[512] ;
  int headerssize ;
  char portstr[8] ;
  size_t tmp ;
  int tmp___0 ;

  {
  {
#line 85
  tmp = strlen(body);
#line 85
  bodysize = (int )tmp;
#line 93
  portstr[0] = (char )'\000';
  }
#line 94
  if ((int )port != 80) {
    {
#line 95
    snprintf((char */* __restrict  */)(portstr), sizeof(portstr), (char const   */* __restrict  */)":%hu",
             (int )port);
    }
  }
  {
#line 96
  headerssize = snprintf((char */* __restrict  */)(headerbuf), sizeof(headerbuf),
                         (char const   */* __restrict  */)"POST %s HTTP/%s\r\nHost: %s%s\r\nUser-Agent: Ubuntu/14.04, UPnP/1.0, MiniUPnPc/1.6\r\nContent-Length: %d\r\nContent-Type: text/xml\r\nSOAPAction: \"%s\"\r\nConnection: Close\r\nCache-Control: no-cache\r\nPragma: no-cache\r\n\r\n",
                         url, httpversion, host, portstr, bodysize, action);
#line 118
  tmp___0 = httpWrite(fd, body, bodysize, (char const   *)(headerbuf), headerssize);
  }
#line 118
  return (tmp___0);
}
}
#line 147 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 480
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 127 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getsockname)(int __fd ,
                                                                                  struct sockaddr * __restrict  __addr ,
                                                                                  socklen_t * __restrict  __len ) ;
#line 677 "/usr/include/netdb.h"
extern int getnameinfo(struct sockaddr  const  * __restrict  __sa , socklen_t __salen ,
                       char * __restrict  __host , socklen_t __hostlen , char * __restrict  __serv ,
                       socklen_t __servlen , int __flags ) ;
#line 19 "/home/wheatley/newnew/temp/miniupnpc-1.6/miniwget.h"
void *miniwget(char const   *url , int *size ) ;
#line 58 "/home/wheatley/newnew/temp/miniupnpc-1.6/miniwget.c"
void *getHTTPResponse(int s , int *size ) 
{ 
  char buf[2048] ;
  int n ;
  int endofheaders ;
  int chunked ;
  int content_length ;
  unsigned int chunksize ;
  unsigned int bytestocopy ;
  char *header_buf ;
  int header_buf_len ;
  int header_buf_used ;
  char *content_buf ;
  int content_buf_len ;
  int content_buf_used ;
  char chunksize_buf[32] ;
  int chunksize_buf_index ;
  void *tmp ;
  void *tmp___0 ;
  int i ;
  int linestart ;
  int colon ;
  int valuestart ;
  void *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int i___0 ;
  int tmp___5 ;
  unsigned short const   **tmp___6 ;
  int j ;
  void *tmp___7 ;
  void *tmp___8 ;

  {
  {
#line 63
  endofheaders = 0;
#line 64
  chunked = 0;
#line 65
  content_length = -1;
#line 66
  chunksize = 0U;
#line 67
  bytestocopy = 0U;
#line 70
  header_buf_len = 2048;
#line 71
  header_buf_used = 0;
#line 73
  content_buf_len = 2048;
#line 74
  content_buf_used = 0;
#line 78
  tmp = malloc((size_t )header_buf_len);
#line 78
  header_buf = (char *)tmp;
#line 79
  tmp___0 = malloc((size_t )content_buf_len);
#line 79
  content_buf = (char *)tmp___0;
#line 80
  chunksize_buf[0] = (char )'\000';
#line 81
  chunksize_buf_index = 0;
  }
  {
#line 83
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 83
    n = receivedata(s, buf, 2048, 5000);
    }
#line 83
    if (! (n > 0)) {
#line 83
      goto while_break;
    }
#line 85
    if (endofheaders == 0) {
#line 88
      linestart = 0;
#line 89
      colon = 0;
#line 90
      valuestart = 0;
#line 91
      if (header_buf_used + n > header_buf_len) {
        {
#line 92
        tmp___1 = realloc((void *)header_buf, (size_t )(header_buf_used + n));
#line 92
        header_buf = (char *)tmp___1;
#line 93
        header_buf_len = header_buf_used + n;
        }
      }
      {
#line 95
      memcpy((void */* __restrict  */)(header_buf + header_buf_used), (void const   */* __restrict  */)(buf),
             (size_t )n);
#line 96
      header_buf_used += n;
#line 99
      i = 0;
      }
      {
#line 100
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 100
        if (i < header_buf_used - 1) {
#line 100
          if (! (endofheaders == 0)) {
#line 100
            goto while_break___0;
          }
        } else {
#line 100
          goto while_break___0;
        }
#line 101
        if ((int )*(header_buf + i) == 13) {
#line 102
          i ++;
#line 103
          if ((int )*(header_buf + i) == 10) {
#line 104
            i ++;
#line 105
            if (i < header_buf_used) {
#line 105
              if ((int )*(header_buf + i) == 13) {
#line 106
                i ++;
#line 107
                if (i < header_buf_used) {
#line 107
                  if ((int )*(header_buf + i) == 10) {
#line 108
                    endofheaders = i + 1;
                  }
                }
              }
            }
          }
        } else
#line 112
        if ((int )*(header_buf + i) == 10) {
#line 113
          i ++;
#line 114
          if ((int )*(header_buf + i) == 10) {
#line 115
            endofheaders = i + 1;
          }
        }
#line 118
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 120
      if (endofheaders == 0) {
#line 121
        goto while_continue;
      }
#line 123
      i = 0;
      {
#line 123
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 123
        if (! (i < endofheaders - 1)) {
#line 123
          goto while_break___1;
        }
#line 124
        if (colon <= linestart) {
#line 124
          if ((int )*(header_buf + i) == 58) {
#line 126
            colon = i;
            {
#line 127
            while (1) {
              while_continue___2: /* CIL Label */ ;
#line 127
              if (i < endofheaders - 1) {
#line 127
                if (! ((int )*(header_buf + (i + 1)) == 32)) {
#line 127
                  if (! ((int )*(header_buf + (i + 1)) == 9)) {
#line 127
                    goto while_break___2;
                  }
                }
              } else {
#line 127
                goto while_break___2;
              }
#line 129
              i ++;
            }
            while_break___2: /* CIL Label */ ;
            }
#line 130
            valuestart = i + 1;
          } else {
#line 124
            goto _L___0;
          }
        } else
        _L___0: /* CIL Label */ 
#line 133
        if ((int )*(header_buf + i) == 13) {
#line 133
          goto _L;
        } else
#line 133
        if ((int )*(header_buf + i) == 10) {
          _L: /* CIL Label */ 
#line 135
          if (colon > linestart) {
#line 135
            if (valuestart > colon) {
              {
#line 142
              tmp___4 = strncasecmp((char const   *)(header_buf + linestart), "content-length",
                                    (size_t )(colon - linestart));
              }
#line 142
              if (0 == tmp___4) {
                {
#line 144
                content_length = atoi((char const   *)(header_buf + valuestart));
                }
              } else {
                {
#line 149
                tmp___2 = strncasecmp((char const   *)(header_buf + linestart), "transfer-encoding",
                                      (size_t )(colon - linestart));
                }
#line 149
                if (0 == tmp___2) {
                  {
#line 149
                  tmp___3 = strncasecmp((char const   *)(header_buf + valuestart),
                                        "chunked", (size_t )7);
                  }
#line 149
                  if (0 == tmp___3) {
#line 155
                    chunked = 1;
                  }
                }
              }
            }
          }
          {
#line 158
          while (1) {
            while_continue___3: /* CIL Label */ ;
#line 158
            if (i < header_buf_used) {
#line 158
              if (! ((int )*(header_buf + i) == 13)) {
#line 158
                if (! ((int )*(header_buf + i) == 10)) {
#line 158
                  goto while_break___3;
                }
              }
            } else {
#line 158
              goto while_break___3;
            }
#line 159
            i ++;
          }
          while_break___3: /* CIL Label */ ;
          }
#line 160
          linestart = i;
#line 161
          colon = linestart;
#line 162
          valuestart = 0;
        }
#line 123
        i ++;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 166
      n = header_buf_used - endofheaders;
#line 167
      memcpy((void */* __restrict  */)(buf), (void const   */* __restrict  */)(header_buf + endofheaders),
             (size_t )n);
      }
    }
#line 170
    if (endofheaders) {
#line 173
      if (chunked) {
#line 175
        i___0 = 0;
        {
#line 176
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 176
          if (! (i___0 < n)) {
#line 176
            goto while_break___4;
          }
#line 178
          if (chunksize == 0U) {
#line 181
            if (chunksize_buf_index == 0) {
#line 183
              if (i___0 < n) {
#line 183
                if ((int )buf[i___0] == 13) {
#line 183
                  i___0 ++;
                }
              }
#line 184
              if (i___0 < n) {
#line 184
                if ((int )buf[i___0] == 10) {
#line 184
                  i___0 ++;
                }
              }
            }
            {
#line 186
            while (1) {
              while_continue___5: /* CIL Label */ ;
#line 186
              if (i___0 < n) {
                {
#line 186
                tmp___6 = __ctype_b_loc();
                }
#line 186
                if ((int const   )*(*tmp___6 + (int )buf[i___0]) & 4096) {
#line 186
                  if (! ((unsigned long )chunksize_buf_index < sizeof(chunksize_buf) - 1UL)) {
#line 186
                    goto while_break___5;
                  }
                } else {
#line 186
                  goto while_break___5;
                }
              } else {
#line 186
                goto while_break___5;
              }
#line 189
              tmp___5 = chunksize_buf_index;
#line 189
              chunksize_buf_index ++;
#line 189
              chunksize_buf[tmp___5] = buf[i___0];
#line 190
              chunksize_buf[chunksize_buf_index] = (char )'\000';
#line 191
              i___0 ++;
            }
            while_break___5: /* CIL Label */ ;
            }
            {
#line 193
            while (1) {
              while_continue___6: /* CIL Label */ ;
#line 193
              if (i___0 < n) {
#line 193
                if ((int )buf[i___0] != 13) {
#line 193
                  if (! ((int )buf[i___0] != 10)) {
#line 193
                    goto while_break___6;
                  }
                } else {
#line 193
                  goto while_break___6;
                }
              } else {
#line 193
                goto while_break___6;
              }
#line 194
              i___0 ++;
            }
            while_break___6: /* CIL Label */ ;
            }
#line 195
            if (i___0 < n) {
#line 195
              if ((int )buf[i___0] == 13) {
#line 195
                i___0 ++;
              }
            }
#line 196
            if (i___0 < n) {
#line 196
              if ((int )buf[i___0] == 10) {
#line 198
                j = 0;
                {
#line 198
                while (1) {
                  while_continue___7: /* CIL Label */ ;
#line 198
                  if (! (j < chunksize_buf_index)) {
#line 198
                    goto while_break___7;
                  }
#line 199
                  if ((int )chunksize_buf[j] >= 48) {
#line 199
                    if ((int )chunksize_buf[j] <= 57) {
#line 201
                      chunksize = (chunksize << 4) + (unsigned int )((int )chunksize_buf[j] - 48);
                    } else {
#line 203
                      chunksize = (chunksize << 4) + (unsigned int )((((int )chunksize_buf[j] | 32) - 97) + 10);
                    }
                  } else {
#line 203
                    chunksize = (chunksize << 4) + (unsigned int )((((int )chunksize_buf[j] | 32) - 97) + 10);
                  }
#line 198
                  j ++;
                }
                while_break___7: /* CIL Label */ ;
                }
#line 205
                chunksize_buf[0] = (char )'\000';
#line 206
                chunksize_buf_index = 0;
#line 207
                i___0 ++;
              } else {
#line 210
                goto while_continue___4;
              }
            } else {
#line 210
              goto while_continue___4;
            }
#line 215
            if (chunksize == 0U) {
#line 221
              goto end_of_stream;
            }
          }
#line 224
          if ((int )chunksize < n - i___0) {
#line 224
            bytestocopy = chunksize;
          } else {
#line 224
            bytestocopy = (unsigned int )(n - i___0);
          }
#line 225
          if ((int )((unsigned int )content_buf_used + bytestocopy) > content_buf_len) {
#line 227
            if (content_length >= content_buf_used + (int )bytestocopy) {
#line 228
              content_buf_len = content_length;
            } else {
#line 230
              content_buf_len = content_buf_used + (int )bytestocopy;
            }
            {
#line 232
            tmp___7 = realloc((void *)content_buf, (size_t )content_buf_len);
#line 232
            content_buf = (char *)tmp___7;
            }
          }
          {
#line 235
          memcpy((void */* __restrict  */)(content_buf + content_buf_used), (void const   */* __restrict  */)(buf + i___0),
                 (size_t )bytestocopy);
#line 236
          content_buf_used = (int )((unsigned int )content_buf_used + bytestocopy);
#line 237
          i___0 = (int )((unsigned int )i___0 + bytestocopy);
#line 238
          chunksize -= bytestocopy;
          }
        }
        while_break___4: /* CIL Label */ ;
        }
      } else {
#line 244
        if (content_length > 0) {
#line 244
          if (content_buf_used + n > content_length) {
#line 247
            n = content_length - content_buf_used;
          }
        }
#line 249
        if (content_buf_used + n > content_buf_len) {
#line 251
          if (content_length >= content_buf_used + n) {
#line 252
            content_buf_len = content_length;
          } else {
#line 254
            content_buf_len = content_buf_used + n;
          }
          {
#line 256
          tmp___8 = realloc((void *)content_buf, (size_t )content_buf_len);
#line 256
          content_buf = (char *)tmp___8;
          }
        }
        {
#line 259
        memcpy((void */* __restrict  */)(content_buf + content_buf_used), (void const   */* __restrict  */)(buf),
               (size_t )n);
#line 260
        content_buf_used += n;
        }
      }
    }
#line 264
    if (content_length > 0) {
#line 264
      if (content_buf_used >= content_length) {
#line 269
        goto while_break;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  end_of_stream: 
  {
#line 273
  free((void *)header_buf);
#line 273
  header_buf = (char *)((void *)0);
#line 274
  *size = content_buf_used;
  }
#line 275
  if (content_buf_used == 0) {
    {
#line 277
    free((void *)content_buf);
#line 278
    content_buf = (char *)((void *)0);
    }
  }
#line 280
  return ((void *)content_buf);
}
}
#line 286 "/home/wheatley/newnew/temp/miniupnpc-1.6/miniwget.c"
static void *miniwget3(char const   *url , char const   *host , unsigned short port ,
                       char const   *path , int *size , char *addr_str , int addr_str_len ,
                       char const   *httpversion ) 
{ 
  char buf[2048] ;
  int s ;
  int n ;
  int len ;
  int sent ;
  void *content ;
  struct sockaddr_storage saddr ;
  socklen_t saddrlen ;
  char const   *tmp ;
  int tmp___0 ;
  ssize_t tmp___1 ;

  {
  {
#line 299
  *size = 0;
#line 300
  s = connecthostport(host, port);
  }
#line 301
  if (s < 0) {
#line 302
    return ((void *)0);
  }
#line 305
  if (addr_str) {
    {
#line 310
    saddrlen = (socklen_t )sizeof(saddr);
#line 311
    tmp___0 = getsockname(s, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& saddr)),
                          (socklen_t */* __restrict  */)(& saddrlen));
    }
#line 311
    if (tmp___0 < 0) {
      {
#line 313
      perror("getsockname");
      }
    } else {
      {
#line 341
      n = getnameinfo((struct sockaddr  const  */* __restrict  */)((struct sockaddr  const  *)(& saddr)),
                      saddrlen, (char */* __restrict  */)addr_str, (socklen_t )addr_str_len,
                      (char */* __restrict  */)((void *)0), (socklen_t )0, 3);
      }
#line 345
      if (n != 0) {
        {
#line 349
        tmp = gai_strerror(n);
#line 349
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"getnameinfo() failed : %s\n",
                tmp);
        }
      }
    }
  }
  {
#line 359
  len = snprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)"GET %s HTTP/%s\r\nHost: %s:%d\r\nConnection: Close\r\nUser-Agent: Ubuntu/14.04, UPnP/1.0, MiniUPnPc/1.6\r\n\r\n",
                 path, httpversion, host, (int )port);
#line 367
  sent = 0;
  }
  {
#line 369
  while (1) {
    while_continue: /* CIL Label */ ;
#line 369
    if (! (sent < len)) {
#line 369
      goto while_break;
    }
    {
#line 371
    tmp___1 = send(s, (void const   *)(buf + sent), (size_t )(len - sent), 0);
#line 371
    n = (int )tmp___1;
    }
#line 372
    if (n < 0) {
      {
#line 374
      perror("send");
#line 375
      close(s);
      }
#line 376
      return ((void *)0);
    } else {
#line 380
      sent += n;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 383
  content = getHTTPResponse(s, size);
#line 384
  close(s);
  }
#line 385
  return (content);
}
}
#line 390 "/home/wheatley/newnew/temp/miniupnpc-1.6/miniwget.c"
static void *miniwget2(char const   *url , char const   *host , unsigned short port ,
                       char const   *path , int *size , char *addr_str , int addr_str_len ) 
{ 
  char *respbuffer ;
  void *tmp ;

  {
  {
#line 397
  tmp = miniwget3(url, host, port, path, size, addr_str, addr_str_len, "1.1");
#line 397
  respbuffer = (char *)tmp;
  }
#line 409
  return ((void *)respbuffer);
}
}
#line 425 "/home/wheatley/newnew/temp/miniupnpc-1.6/miniwget.c"
int parseURL(char const   *url , char *hostname , unsigned short *port , char **path ) 
{ 
  char *p1 ;
  char *p2 ;
  char *p3 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 428
  if (! url) {
#line 429
    return (0);
  }
  {
#line 430
  p1 = strstr(url, "://");
  }
#line 431
  if (! p1) {
#line 432
    return (0);
  }
#line 433
  p1 += 3;
#line 434
  if ((int const   )*(url + 0) != 104) {
#line 436
    return (0);
  } else
#line 434
  if ((int const   )*(url + 1) != 116) {
#line 436
    return (0);
  } else
#line 434
  if ((int const   )*(url + 2) != 116) {
#line 436
    return (0);
  } else
#line 434
  if ((int const   )*(url + 3) != 112) {
#line 436
    return (0);
  }
  {
#line 437
  memset((void *)hostname, 0, (size_t )65);
  }
#line 438
  if ((int )*p1 == 91) {
    {
#line 441
    p2 = strchr((char const   *)p1, ']');
#line 442
    p3 = strchr((char const   *)p1, '/');
    }
#line 443
    if (p2) {
#line 443
      if (p3) {
#line 445
        p2 ++;
#line 446
        if (64 < (int )(p2 - p1)) {
#line 446
          tmp = 64;
        } else {
#line 446
          tmp = (int )(p2 - p1);
        }
        {
#line 446
        strncpy((char */* __restrict  */)hostname, (char const   */* __restrict  */)p1,
                (size_t )tmp);
        }
#line 447
        if ((int )*p2 == 58) {
#line 449
          *port = (unsigned short)0;
#line 450
          p2 ++;
          {
#line 451
          while (1) {
            while_continue: /* CIL Label */ ;
#line 451
            if ((int )*p2 >= 48) {
#line 451
              if (! ((int )*p2 <= 57)) {
#line 451
                goto while_break;
              }
            } else {
#line 451
              goto while_break;
            }
#line 453
            *port = (unsigned short )((int )*port * 10);
#line 454
            *port = (unsigned short )((int )*port + (int )((unsigned short )((int )*p2 - 48)));
#line 455
            p2 ++;
          }
          while_break: /* CIL Label */ ;
          }
        } else {
#line 460
          *port = (unsigned short)80;
        }
#line 462
        *path = p3;
#line 463
        return (1);
      }
    }
  }
  {
#line 466
  p2 = strchr((char const   *)p1, ':');
#line 467
  p3 = strchr((char const   *)p1, '/');
  }
#line 468
  if (! p3) {
#line 469
    return (0);
  }
#line 470
  if (! p2) {
#line 470
    goto _L;
  } else
#line 470
  if ((unsigned long )p2 > (unsigned long )p3) {
    _L: /* CIL Label */ 
#line 472
    if (64 < (int )(p3 - p1)) {
#line 472
      tmp___0 = 64;
    } else {
#line 472
      tmp___0 = (int )(p3 - p1);
    }
    {
#line 472
    strncpy((char */* __restrict  */)hostname, (char const   */* __restrict  */)p1,
            (size_t )tmp___0);
#line 473
    *port = (unsigned short)80;
    }
  } else {
#line 477
    if (64 < (int )(p2 - p1)) {
#line 477
      tmp___1 = 64;
    } else {
#line 477
      tmp___1 = (int )(p2 - p1);
    }
    {
#line 477
    strncpy((char */* __restrict  */)hostname, (char const   */* __restrict  */)p1,
            (size_t )tmp___1);
#line 478
    *port = (unsigned short)0;
#line 479
    p2 ++;
    }
    {
#line 480
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 480
      if ((int )*p2 >= 48) {
#line 480
        if (! ((int )*p2 <= 57)) {
#line 480
          goto while_break___0;
        }
      } else {
#line 480
        goto while_break___0;
      }
#line 482
      *port = (unsigned short )((int )*port * 10);
#line 483
      *port = (unsigned short )((int )*port + (int )((unsigned short )((int )*p2 - 48)));
#line 484
      p2 ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 487
  *path = p3;
#line 488
  return (1);
}
}
#line 491 "/home/wheatley/newnew/temp/miniupnpc-1.6/miniwget.c"
void *miniwget(char const   *url , int *size ) 
{ 
  unsigned short port ;
  char *path ;
  char hostname[65] ;
  int tmp ;
  void *tmp___0 ;

  {
  {
#line 497
  *size = 0;
#line 498
  tmp = parseURL(url, hostname, & port, & path);
  }
#line 498
  if (! tmp) {
#line 499
    return ((void *)0);
  }
  {
#line 503
  tmp___0 = miniwget2(url, (char const   *)(hostname), port, (char const   *)path,
                      size, (char *)0, 0);
  }
#line 503
  return (tmp___0);
}
}
#line 506 "/home/wheatley/newnew/temp/miniupnpc-1.6/miniwget.c"
void *miniwget_getaddr(char const   *url , int *size , char *addr , int addrlen ) 
{ 
  unsigned short port ;
  char *path ;
  char hostname[65] ;
  int tmp ;
  void *tmp___0 ;

  {
#line 512
  *size = 0;
#line 513
  if (addr) {
#line 514
    *(addr + 0) = (char )'\000';
  }
  {
#line 515
  tmp = parseURL(url, hostname, & port, & path);
  }
#line 515
  if (! tmp) {
#line 516
    return ((void *)0);
  }
  {
#line 520
  tmp___0 = miniwget2(url, (char const   *)(hostname), port, (char const   *)path,
                      size, addr, addrlen);
  }
#line 520
  return (tmp___0);
}
}
#line 39 "/home/wheatley/newnew/temp/miniupnpc-1.6/minixml.c"
static int parseatt(struct xmlparser *p ) 
{ 
  char const   *attname ;
  int attnamelen ;
  char const   *attvalue ;
  int attvaluelen ;
  char sep ;
  char const   *tmp ;

  {
  {
#line 45
  while (1) {
    while_continue: /* CIL Label */ ;
#line 45
    if (! ((unsigned long )p->xml < (unsigned long )p->xmlend)) {
#line 45
      goto while_break;
    }
#line 47
    if ((int const   )*(p->xml) == 47) {
#line 48
      return (0);
    } else
#line 47
    if ((int const   )*(p->xml) == 62) {
#line 48
      return (0);
    }
#line 49
    if (! ((int const   )*(p->xml) == 32)) {
#line 49
      if (! ((int const   )*(p->xml) == 9)) {
#line 49
        if (! ((int const   )*(p->xml) == 13)) {
#line 49
          if (! ((int const   )*(p->xml) == 10)) {
#line 52
            attname = p->xml;
#line 53
            attnamelen = 0;
            {
#line 54
            while (1) {
              while_continue___0: /* CIL Label */ ;
#line 54
              if ((int const   )*(p->xml) != 61) {
#line 54
                if ((int const   )*(p->xml) == 32) {
#line 54
                  goto while_break___0;
                } else
#line 54
                if ((int const   )*(p->xml) == 9) {
#line 54
                  goto while_break___0;
                } else
#line 54
                if ((int const   )*(p->xml) == 13) {
#line 54
                  goto while_break___0;
                } else
#line 54
                if ((int const   )*(p->xml) == 10) {
#line 54
                  goto while_break___0;
                }
              } else {
#line 54
                goto while_break___0;
              }
#line 56
              attnamelen ++;
#line 56
              (p->xml) ++;
#line 57
              if ((unsigned long )p->xml >= (unsigned long )p->xmlend) {
#line 58
                return (-1);
              }
            }
            while_break___0: /* CIL Label */ ;
            }
            {
#line 60
            while (1) {
              while_continue___1: /* CIL Label */ ;
#line 60
              tmp = p->xml;
#line 60
              (p->xml) ++;
#line 60
              if (! ((int const   )*tmp != 61)) {
#line 60
                goto while_break___1;
              }
#line 62
              if ((unsigned long )p->xml >= (unsigned long )p->xmlend) {
#line 63
                return (-1);
              }
            }
            while_break___1: /* CIL Label */ ;
            }
            {
#line 65
            while (1) {
              while_continue___2: /* CIL Label */ ;
#line 65
              if (! ((int const   )*(p->xml) == 32)) {
#line 65
                if (! ((int const   )*(p->xml) == 9)) {
#line 65
                  if (! ((int const   )*(p->xml) == 13)) {
#line 65
                    if (! ((int const   )*(p->xml) == 10)) {
#line 65
                      goto while_break___2;
                    }
                  }
                }
              }
#line 67
              (p->xml) ++;
#line 68
              if ((unsigned long )p->xml >= (unsigned long )p->xmlend) {
#line 69
                return (-1);
              }
            }
            while_break___2: /* CIL Label */ ;
            }
#line 71
            sep = (char )*(p->xml);
#line 72
            if ((int )sep == 39) {
#line 72
              goto _L;
            } else
#line 72
            if ((int )sep == 34) {
              _L: /* CIL Label */ 
#line 74
              (p->xml) ++;
#line 75
              if ((unsigned long )p->xml >= (unsigned long )p->xmlend) {
#line 76
                return (-1);
              }
#line 77
              attvalue = p->xml;
#line 78
              attvaluelen = 0;
              {
#line 79
              while (1) {
                while_continue___3: /* CIL Label */ ;
#line 79
                if (! ((int const   )*(p->xml) != (int const   )sep)) {
#line 79
                  goto while_break___3;
                }
#line 81
                attvaluelen ++;
#line 81
                (p->xml) ++;
#line 82
                if ((unsigned long )p->xml >= (unsigned long )p->xmlend) {
#line 83
                  return (-1);
                }
              }
              while_break___3: /* CIL Label */ ;
              }
            } else {
#line 88
              attvalue = p->xml;
#line 89
              attvaluelen = 0;
              {
#line 90
              while (1) {
                while_continue___4: /* CIL Label */ ;
#line 90
                if ((int const   )*(p->xml) == 32) {
#line 90
                  goto while_break___4;
                } else
#line 90
                if ((int const   )*(p->xml) == 9) {
#line 90
                  goto while_break___4;
                } else
#line 90
                if ((int const   )*(p->xml) == 13) {
#line 90
                  goto while_break___4;
                } else
#line 90
                if ((int const   )*(p->xml) == 10) {
#line 90
                  goto while_break___4;
                } else
#line 90
                if ((int const   )*(p->xml) != 62) {
#line 90
                  if (! ((int const   )*(p->xml) != 47)) {
#line 90
                    goto while_break___4;
                  }
                } else {
#line 90
                  goto while_break___4;
                }
#line 93
                attvaluelen ++;
#line 93
                (p->xml) ++;
#line 94
                if ((unsigned long )p->xml >= (unsigned long )p->xmlend) {
#line 95
                  return (-1);
                }
              }
              while_break___4: /* CIL Label */ ;
              }
            }
#line 100
            if (p->attfunc) {
              {
#line 101
              (*(p->attfunc))(p->data, attname, attnamelen, attvalue, attvaluelen);
              }
            }
          }
        }
      }
    }
#line 103
    (p->xml) ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 105
  return (-1);
}
}
#line 110 "/home/wheatley/newnew/temp/miniupnpc-1.6/minixml.c"
static void parseelt(struct xmlparser *p ) 
{ 
  int i ;
  char const   *elementname ;
  int tmp ;
  char const   *data___2 ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 114
  while (1) {
    while_continue: /* CIL Label */ ;
#line 114
    if (! ((unsigned long )p->xml < (unsigned long )(p->xmlend - 1))) {
#line 114
      goto while_break;
    }
#line 116
    if ((int const   )*(p->xml + 0) == 60) {
#line 116
      if ((int const   )*(p->xml + 1) != 63) {
#line 118
        i = 0;
#line 118
        (p->xml) ++;
#line 118
        elementname = p->xml;
        {
#line 119
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 119
          if ((int const   )*(p->xml) == 32) {
#line 119
            goto while_break___0;
          } else
#line 119
          if ((int const   )*(p->xml) == 9) {
#line 119
            goto while_break___0;
          } else
#line 119
          if ((int const   )*(p->xml) == 13) {
#line 119
            goto while_break___0;
          } else
#line 119
          if ((int const   )*(p->xml) == 10) {
#line 119
            goto while_break___0;
          } else
#line 119
          if ((int const   )*(p->xml) != 62) {
#line 119
            if (! ((int const   )*(p->xml) != 47)) {
#line 119
              goto while_break___0;
            }
          } else {
#line 119
            goto while_break___0;
          }
#line 123
          i ++;
#line 123
          (p->xml) ++;
#line 124
          if ((unsigned long )p->xml >= (unsigned long )p->xmlend) {
#line 125
            return;
          }
#line 127
          if ((int const   )*(p->xml) == 58) {
#line 129
            i = 0;
#line 130
            (p->xml) ++;
#line 130
            elementname = p->xml;
          }
        }
        while_break___0: /* CIL Label */ ;
        }
#line 133
        if (i > 0) {
#line 135
          if (p->starteltfunc) {
            {
#line 136
            (*(p->starteltfunc))(p->data, elementname, i);
            }
          }
          {
#line 137
          tmp = parseatt(p);
          }
#line 137
          if (tmp) {
#line 138
            return;
          }
#line 139
          if ((int const   )*(p->xml) != 47) {
#line 142
            i = 0;
#line 142
            (p->xml) ++;
#line 142
            data___2 = p->xml;
#line 143
            if ((unsigned long )p->xml >= (unsigned long )p->xmlend) {
#line 144
              return;
            }
            {
#line 145
            while (1) {
              while_continue___1: /* CIL Label */ ;
#line 145
              if (! ((int const   )*(p->xml) == 32)) {
#line 145
                if (! ((int const   )*(p->xml) == 9)) {
#line 145
                  if (! ((int const   )*(p->xml) == 13)) {
#line 145
                    if (! ((int const   )*(p->xml) == 10)) {
#line 145
                      goto while_break___1;
                    }
                  }
                }
              }
#line 147
              i ++;
#line 147
              (p->xml) ++;
#line 148
              if ((unsigned long )p->xml >= (unsigned long )p->xmlend) {
#line 149
                return;
              }
            }
            while_break___1: /* CIL Label */ ;
            }
            {
#line 151
            tmp___1 = memcmp((void const   *)p->xml, (void const   *)"<![CDATA[",
                             (size_t )9);
            }
#line 151
            if (tmp___1 == 0) {
#line 154
              p->xml += 9;
#line 155
              data___2 = p->xml;
#line 156
              i = 0;
              {
#line 157
              while (1) {
                while_continue___2: /* CIL Label */ ;
                {
#line 157
                tmp___0 = memcmp((void const   *)p->xml, (void const   *)"]]>", (size_t )3);
                }
#line 157
                if (! (tmp___0 != 0)) {
#line 157
                  goto while_break___2;
                }
#line 159
                i ++;
#line 159
                (p->xml) ++;
#line 160
                if ((unsigned long )(p->xml + 3) >= (unsigned long )p->xmlend) {
#line 161
                  return;
                }
              }
              while_break___2: /* CIL Label */ ;
              }
#line 163
              if (i > 0) {
#line 163
                if (p->datafunc) {
                  {
#line 164
                  (*(p->datafunc))(p->data, data___2, i);
                  }
                }
              }
              {
#line 165
              while (1) {
                while_continue___3: /* CIL Label */ ;
#line 165
                if (! ((int const   )*(p->xml) != 60)) {
#line 165
                  goto while_break___3;
                }
#line 167
                (p->xml) ++;
#line 168
                if ((unsigned long )p->xml >= (unsigned long )p->xmlend) {
#line 169
                  return;
                }
              }
              while_break___3: /* CIL Label */ ;
              }
            } else {
              {
#line 174
              while (1) {
                while_continue___4: /* CIL Label */ ;
#line 174
                if (! ((int const   )*(p->xml) != 60)) {
#line 174
                  goto while_break___4;
                }
#line 176
                i ++;
#line 176
                (p->xml) ++;
#line 177
                if ((unsigned long )(p->xml + 1) >= (unsigned long )p->xmlend) {
#line 178
                  return;
                }
              }
              while_break___4: /* CIL Label */ ;
              }
#line 180
              if (i > 0) {
#line 180
                if (p->datafunc) {
#line 180
                  if ((int const   )*(p->xml + 1) == 47) {
                    {
#line 181
                    (*(p->datafunc))(p->data, data___2, i);
                    }
                  }
                }
              }
            }
          }
        } else
#line 185
        if ((int const   )*(p->xml) == 47) {
#line 187
          i = 0;
#line 187
          (p->xml) ++;
#line 187
          elementname = p->xml;
#line 188
          if ((unsigned long )p->xml >= (unsigned long )p->xmlend) {
#line 189
            return;
          }
          {
#line 190
          while (1) {
            while_continue___5: /* CIL Label */ ;
#line 190
            if (! ((int const   )*(p->xml) != 62)) {
#line 190
              goto while_break___5;
            }
#line 192
            i ++;
#line 192
            (p->xml) ++;
#line 193
            if ((unsigned long )p->xml >= (unsigned long )p->xmlend) {
#line 194
              return;
            }
          }
          while_break___5: /* CIL Label */ ;
          }
#line 196
          if (p->endeltfunc) {
            {
#line 197
            (*(p->endeltfunc))(p->data, elementname, i);
            }
          }
#line 198
          (p->xml) ++;
        }
      } else {
#line 203
        (p->xml) ++;
      }
    } else {
#line 203
      (p->xml) ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 206
  return;
}
}
#line 209 "/home/wheatley/newnew/temp/miniupnpc-1.6/minixml.c"
void parsexml(struct xmlparser *parser ) 
{ 


  {
  {
#line 211
  parser->xml = parser->xmlstart;
#line 212
  parser->xmlend = parser->xmlstart + parser->xmlsize;
#line 213
  parseelt(parser);
  }
#line 214
  return;
}
}
#line 106 "/usr/include/x86_64-linux-gnu/sys/select.h"
extern int select(int __nfds , fd_set * __restrict  __readfds , fd_set * __restrict  __writefds ,
                  fd_set * __restrict  __exceptfds , struct timeval * __restrict  __timeout ) ;
#line 219 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getsockopt)(int __fd ,
                                                                                 int __level ,
                                                                                 int __optname ,
                                                                                 void * __restrict  __optval ,
                                                                                 socklen_t * __restrict  __optlen ) ;
#line 55 "/home/wheatley/newnew/temp/miniupnpc-1.6/connecthostport.c"
int connecthostport(char const   *host , unsigned short port ) 
{ 
  int s ;
  int n ;
  char tmp_host[65] ;
  char port_str[8] ;
  struct addrinfo *ai ;
  struct addrinfo *p ;
  struct addrinfo hints ;
  struct timeval timeout ;
  int i ;
  char const   *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  socklen_t len ;
  fd_set wset ;
  int err ;
  int __d0 ;
  int __d1 ;
  int *tmp___2 ;
  int tmp___3 ;
  int *tmp___4 ;
  int *tmp___5 ;

  {
  {
#line 136
  memset((void *)(& hints), 0, sizeof(hints));
#line 139
  hints.ai_flags = 1024;
#line 141
  hints.ai_socktype = 1;
#line 142
  hints.ai_family = 0;
#line 144
  snprintf((char */* __restrict  */)(port_str), sizeof(port_str), (char const   */* __restrict  */)"%hu",
           (int )port);
  }
#line 145
  if ((int const   )*(host + 0) == 91) {
#line 149
    i = 0;
    {
#line 149
    while (1) {
      while_continue: /* CIL Label */ ;
#line 149
      if (*(host + (i + 1))) {
#line 149
        if ((int const   )*(host + (i + 1)) != 93) {
#line 149
          if (! (i < 64)) {
#line 149
            goto while_break;
          }
        } else {
#line 149
          goto while_break;
        }
      } else {
#line 149
        goto while_break;
      }
#line 151
      tmp_host[i] = (char )*(host + (i + 1));
#line 149
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 153
    tmp_host[i] = (char )'\000';
  } else {
    {
#line 157
    strncpy((char */* __restrict  */)(tmp_host), (char const   */* __restrict  */)host,
            (size_t )64);
    }
  }
  {
#line 159
  tmp_host[64] = (char )'\000';
#line 160
  n = getaddrinfo((char const   */* __restrict  */)(tmp_host), (char const   */* __restrict  */)(port_str),
                  (struct addrinfo  const  */* __restrict  */)(& hints), (struct addrinfo **/* __restrict  */)(& ai));
  }
#line 161
  if (n != 0) {
    {
#line 166
    tmp = gai_strerror(n);
#line 166
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"getaddrinfo() error : %s\n",
            tmp);
    }
#line 168
    return (-1);
  }
#line 170
  s = -1;
#line 171
  p = ai;
  {
#line 171
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 171
    if (! p) {
#line 171
      goto while_break___0;
    }
    {
#line 173
    s = socket(p->ai_family, p->ai_socktype, p->ai_protocol);
    }
#line 174
    if (s < 0) {
#line 175
      goto __Cont;
    }
    {
#line 178
    timeout.tv_sec = (__time_t )3;
#line 179
    timeout.tv_usec = (__suseconds_t )0;
#line 180
    tmp___0 = setsockopt(s, 1, 20, (void const   *)(& timeout), (socklen_t )sizeof(struct timeval ));
    }
#line 180
    if (tmp___0 < 0) {
      {
#line 182
      perror("setsockopt");
      }
    }
    {
#line 184
    timeout.tv_sec = (__time_t )3;
#line 185
    timeout.tv_usec = (__suseconds_t )0;
#line 186
    tmp___1 = setsockopt(s, 1, 21, (void const   *)(& timeout), (socklen_t )sizeof(struct timeval ));
    }
#line 186
    if (tmp___1 < 0) {
      {
#line 188
      perror("setsockopt");
      }
    }
    {
#line 191
    n = connect(s, (struct sockaddr  const  *)p->ai_addr, p->ai_addrlen);
    }
    {
#line 193
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 193
      if (n < 0) {
        {
#line 193
        tmp___5 = __errno_location();
        }
#line 193
        if (! (*tmp___5 == 4)) {
#line 193
          goto while_break___1;
        }
      } else {
#line 193
        goto while_break___1;
      }
      {
#line 198
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 198
        __asm__  volatile   ("cld; rep; "
                             "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                             "1" (& wset.__fds_bits[0]): "memory");
#line 198
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
      {
#line 199
      wset.__fds_bits[s / (8 * (int )sizeof(__fd_mask ))] |= 1L << s % (8 * (int )sizeof(__fd_mask ));
#line 200
      n = select(s + 1, (fd_set */* __restrict  */)((void *)0), (fd_set */* __restrict  */)(& wset),
                 (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)((void *)0));
      }
#line 200
      if (n == -1) {
        {
#line 200
        tmp___2 = __errno_location();
        }
#line 200
        if (*tmp___2 == 4) {
#line 201
          goto while_continue___1;
        }
      }
      {
#line 204
      len = (socklen_t )sizeof(err);
#line 205
      tmp___3 = getsockopt(s, 1, 4, (void */* __restrict  */)(& err), (socklen_t */* __restrict  */)(& len));
      }
#line 205
      if (tmp___3 < 0) {
        {
#line 206
        perror("getsockopt");
#line 207
        close(s);
#line 208
        freeaddrinfo(ai);
        }
#line 209
        return (-1);
      }
#line 211
      if (err != 0) {
        {
#line 212
        tmp___4 = __errno_location();
#line 212
        *tmp___4 = err;
#line 213
        n = -1;
        }
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 217
    if (n < 0) {
      {
#line 219
      close(s);
      }
#line 220
      goto __Cont;
    } else {
#line 224
      goto while_break___0;
    }
    __Cont: /* CIL Label */ 
#line 171
    p = p->ai_next;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 227
  freeaddrinfo(ai);
  }
#line 228
  if (s < 0) {
    {
#line 230
    perror("socket");
    }
#line 231
    return (-1);
  }
#line 233
  if (n < 0) {
    {
#line 235
    perror("connect");
    }
#line 236
    return (-1);
  }
#line 239
  return (s);
}
}
#line 247 "/home/wheatley/newnew/temp/miniupnpc-1.6/miniupnpc.c"
static void parseMSEARCHReply___0(char const   *reply , int size , char const   **location ,
                                  int *locationsize , char const   **st , int *stsize ) 
{ 
  int a ;
  int b ;
  int i ;
  int tmp ;
  int tmp___0 ;

  {
#line 253
  i = 0;
#line 254
  a = i;
#line 255
  b = 0;
  {
#line 256
  while (1) {
    while_continue: /* CIL Label */ ;
#line 256
    if (! (i < size)) {
#line 256
      goto while_break;
    }
    {
#line 260
    if ((int const   )*(reply + i) == 58) {
#line 260
      goto case_58;
    }
#line 272
    if ((int const   )*(reply + i) == 13) {
#line 272
      goto case_13;
    }
#line 272
    if ((int const   )*(reply + i) == 10) {
#line 272
      goto case_13;
    }
#line 296
    goto switch_default;
    case_58: /* CIL Label */ 
#line 261
    if (b == 0) {
#line 263
      b = i;
    }
#line 270
    goto switch_break;
    case_13: /* CIL Label */ 
    case_10: /* CIL Label */ 
#line 273
    if (b != 0) {
      {
#line 281
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 281
        b ++;
#line 281
        if (! ((int const   )*(reply + b) == 32)) {
#line 281
          goto while_break___0;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 282
      tmp___0 = strncasecmp(reply + a, "location", (size_t )8);
      }
#line 282
      if (0 == tmp___0) {
#line 284
        *location = reply + b;
#line 285
        *locationsize = i - b;
      } else {
        {
#line 287
        tmp = strncasecmp(reply + a, "st", (size_t )2);
        }
#line 287
        if (0 == tmp) {
#line 289
          *st = reply + b;
#line 290
          *stsize = i - b;
        }
      }
#line 292
      b = 0;
    }
#line 294
    a = i + 1;
#line 295
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 297
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 299
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 301
  return;
}
}
#line 326 "/home/wheatley/newnew/temp/miniupnpc-1.6/miniupnpc.c"
static char const   MSearchMsgFmt___0[77]  = 
#line 326
  {      (char const   )'M',      (char const   )'-',      (char const   )'S',      (char const   )'E', 
        (char const   )'A',      (char const   )'R',      (char const   )'C',      (char const   )'H', 
        (char const   )' ',      (char const   )'*',      (char const   )' ',      (char const   )'H', 
        (char const   )'T',      (char const   )'T',      (char const   )'P',      (char const   )'/', 
        (char const   )'1',      (char const   )'.',      (char const   )'1',      (char const   )'\r', 
        (char const   )'\n',      (char const   )'H',      (char const   )'O',      (char const   )'S', 
        (char const   )'T',      (char const   )':',      (char const   )' ',      (char const   )'%', 
        (char const   )'s',      (char const   )':',      (char const   )'1',      (char const   )'9', 
        (char const   )'0',      (char const   )'0',      (char const   )'\r',      (char const   )'\n', 
        (char const   )'S',      (char const   )'T',      (char const   )':',      (char const   )' ', 
        (char const   )'%',      (char const   )'s',      (char const   )'\r',      (char const   )'\n', 
        (char const   )'M',      (char const   )'A',      (char const   )'N',      (char const   )':', 
        (char const   )' ',      (char const   )'\"',      (char const   )'s',      (char const   )'s', 
        (char const   )'d',      (char const   )'p',      (char const   )':',      (char const   )'d', 
        (char const   )'i',      (char const   )'s',      (char const   )'c',      (char const   )'o', 
        (char const   )'v',      (char const   )'e',      (char const   )'r',      (char const   )'\"', 
        (char const   )'\r',      (char const   )'\n',      (char const   )'M',      (char const   )'X', 
        (char const   )':',      (char const   )' ',      (char const   )'%',      (char const   )'u', 
        (char const   )'\r',      (char const   )'\n',      (char const   )'\r',      (char const   )'\n', 
        (char const   )'\000'};
#line 333 "/home/wheatley/newnew/temp/miniupnpc-1.6/miniupnpc.c"
static char const   * const  deviceList___0[5]  = {      (char const   */* const  */)"urn:schemas-upnp-org:device:InternetGatewayDevice:1",      (char const   */* const  */)"urn:schemas-upnp-org:service:WANIPConnection:1",      (char const   */* const  */)"urn:schemas-upnp-org:service:WANPPPConnection:1",      (char const   */* const  */)"upnp:rootdevice", 
        (char const   */* const  */)0};
#line 679 "/home/wheatley/newnew/temp/miniupnpc-1.6/miniupnpc.c"
static void url_cpy_or_cat___0(char *dst , char const   *src , int n ) 
{ 
  int l ;
  size_t tmp ;
  int tmp___0 ;

  {
#line 682
  if ((int const   )*(src + 0) == 104) {
#line 682
    if ((int const   )*(src + 1) == 116) {
#line 682
      if ((int const   )*(src + 2) == 116) {
#line 682
        if ((int const   )*(src + 3) == 112) {
#line 682
          if ((int const   )*(src + 4) == 58) {
#line 682
            if ((int const   )*(src + 5) == 47) {
#line 682
              if ((int const   )*(src + 6) == 47) {
                {
#line 690
                strncpy((char */* __restrict  */)dst, (char const   */* __restrict  */)src,
                        (size_t )n);
                }
              } else {
#line 682
                goto _L___4;
              }
            } else {
#line 682
              goto _L___4;
            }
          } else {
#line 682
            goto _L___4;
          }
        } else {
#line 682
          goto _L___4;
        }
      } else {
#line 682
        goto _L___4;
      }
    } else {
#line 682
      goto _L___4;
    }
  } else {
    _L___4: /* CIL Label */ 
    {
#line 694
    tmp = strlen((char const   *)dst);
#line 694
    l = (int )tmp;
    }
#line 695
    if ((int const   )*(src + 0) != 47) {
#line 696
      tmp___0 = l;
#line 696
      l ++;
#line 696
      *(dst + tmp___0) = (char )'/';
    }
#line 697
    if (l <= n) {
      {
#line 698
      strncpy((char */* __restrict  */)(dst + l), (char const   */* __restrict  */)src,
              (size_t )(n - l));
      }
    }
  }
#line 700
  return;
}
}
#line 35 "/home/wheatley/newnew/temp/miniupnpc-1.6/minisoap.c"
static int httpWrite___0(int fd , char const   *body , int bodysize , char const   *headers ,
                         int headerssize ) 
{ 
  int n ;
  char *p ;
  void *tmp ;
  ssize_t tmp___0 ;

  {
  {
#line 39
  n = 0;
#line 47
  tmp = malloc((size_t )(headerssize + bodysize));
#line 47
  p = (char *)tmp;
  }
#line 48
  if (! p) {
#line 49
    return (0);
  }
  {
#line 50
  memcpy((void */* __restrict  */)p, (void const   */* __restrict  */)headers, (size_t )headerssize);
#line 51
  memcpy((void */* __restrict  */)(p + headerssize), (void const   */* __restrict  */)body,
         (size_t )bodysize);
#line 53
  tmp___0 = send(fd, (void const   *)p, (size_t )(headerssize + bodysize), 0);
#line 53
  n = (int )tmp___0;
  }
#line 54
  if (n < 0) {
    {
#line 55
    perror("send");
    }
  }
  {
#line 68
  free((void *)p);
  }
#line 69
  return (n);
}
}
#line 39 "/home/wheatley/newnew/temp/miniupnpc-1.6/minixml.c"
static int parseatt___0(struct xmlparser *p ) 
{ 
  char const   *attname ;
  int attnamelen ;
  char const   *attvalue ;
  int attvaluelen ;
  char sep ;
  char const   *tmp ;

  {
  {
#line 45
  while (1) {
    while_continue: /* CIL Label */ ;
#line 45
    if (! ((unsigned long )p->xml < (unsigned long )p->xmlend)) {
#line 45
      goto while_break;
    }
#line 47
    if ((int const   )*(p->xml) == 47) {
#line 48
      return (0);
    } else
#line 47
    if ((int const   )*(p->xml) == 62) {
#line 48
      return (0);
    }
#line 49
    if (! ((int const   )*(p->xml) == 32)) {
#line 49
      if (! ((int const   )*(p->xml) == 9)) {
#line 49
        if (! ((int const   )*(p->xml) == 13)) {
#line 49
          if (! ((int const   )*(p->xml) == 10)) {
#line 52
            attname = p->xml;
#line 53
            attnamelen = 0;
            {
#line 54
            while (1) {
              while_continue___0: /* CIL Label */ ;
#line 54
              if ((int const   )*(p->xml) != 61) {
#line 54
                if ((int const   )*(p->xml) == 32) {
#line 54
                  goto while_break___0;
                } else
#line 54
                if ((int const   )*(p->xml) == 9) {
#line 54
                  goto while_break___0;
                } else
#line 54
                if ((int const   )*(p->xml) == 13) {
#line 54
                  goto while_break___0;
                } else
#line 54
                if ((int const   )*(p->xml) == 10) {
#line 54
                  goto while_break___0;
                }
              } else {
#line 54
                goto while_break___0;
              }
#line 56
              attnamelen ++;
#line 56
              (p->xml) ++;
#line 57
              if ((unsigned long )p->xml >= (unsigned long )p->xmlend) {
#line 58
                return (-1);
              }
            }
            while_break___0: /* CIL Label */ ;
            }
            {
#line 60
            while (1) {
              while_continue___1: /* CIL Label */ ;
#line 60
              tmp = p->xml;
#line 60
              (p->xml) ++;
#line 60
              if (! ((int const   )*tmp != 61)) {
#line 60
                goto while_break___1;
              }
#line 62
              if ((unsigned long )p->xml >= (unsigned long )p->xmlend) {
#line 63
                return (-1);
              }
            }
            while_break___1: /* CIL Label */ ;
            }
            {
#line 65
            while (1) {
              while_continue___2: /* CIL Label */ ;
#line 65
              if (! ((int const   )*(p->xml) == 32)) {
#line 65
                if (! ((int const   )*(p->xml) == 9)) {
#line 65
                  if (! ((int const   )*(p->xml) == 13)) {
#line 65
                    if (! ((int const   )*(p->xml) == 10)) {
#line 65
                      goto while_break___2;
                    }
                  }
                }
              }
#line 67
              (p->xml) ++;
#line 68
              if ((unsigned long )p->xml >= (unsigned long )p->xmlend) {
#line 69
                return (-1);
              }
            }
            while_break___2: /* CIL Label */ ;
            }
#line 71
            sep = (char )*(p->xml);
#line 72
            if ((int )sep == 39) {
#line 72
              goto _L;
            } else
#line 72
            if ((int )sep == 34) {
              _L: /* CIL Label */ 
#line 74
              (p->xml) ++;
#line 75
              if ((unsigned long )p->xml >= (unsigned long )p->xmlend) {
#line 76
                return (-1);
              }
#line 77
              attvalue = p->xml;
#line 78
              attvaluelen = 0;
              {
#line 79
              while (1) {
                while_continue___3: /* CIL Label */ ;
#line 79
                if (! ((int const   )*(p->xml) != (int const   )sep)) {
#line 79
                  goto while_break___3;
                }
#line 81
                attvaluelen ++;
#line 81
                (p->xml) ++;
#line 82
                if ((unsigned long )p->xml >= (unsigned long )p->xmlend) {
#line 83
                  return (-1);
                }
              }
              while_break___3: /* CIL Label */ ;
              }
            } else {
#line 88
              attvalue = p->xml;
#line 89
              attvaluelen = 0;
              {
#line 90
              while (1) {
                while_continue___4: /* CIL Label */ ;
#line 90
                if ((int const   )*(p->xml) == 32) {
#line 90
                  goto while_break___4;
                } else
#line 90
                if ((int const   )*(p->xml) == 9) {
#line 90
                  goto while_break___4;
                } else
#line 90
                if ((int const   )*(p->xml) == 13) {
#line 90
                  goto while_break___4;
                } else
#line 90
                if ((int const   )*(p->xml) == 10) {
#line 90
                  goto while_break___4;
                } else
#line 90
                if ((int const   )*(p->xml) != 62) {
#line 90
                  if (! ((int const   )*(p->xml) != 47)) {
#line 90
                    goto while_break___4;
                  }
                } else {
#line 90
                  goto while_break___4;
                }
#line 93
                attvaluelen ++;
#line 93
                (p->xml) ++;
#line 94
                if ((unsigned long )p->xml >= (unsigned long )p->xmlend) {
#line 95
                  return (-1);
                }
              }
              while_break___4: /* CIL Label */ ;
              }
            }
#line 100
            if (p->attfunc) {
              {
#line 101
              (*(p->attfunc))(p->data, attname, attnamelen, attvalue, attvaluelen);
              }
            }
          }
        }
      }
    }
#line 103
    (p->xml) ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 105
  return (-1);
}
}
#line 110 "/home/wheatley/newnew/temp/miniupnpc-1.6/minixml.c"
static void parseelt___0(struct xmlparser *p ) 
{ 
  int i ;
  char const   *elementname ;
  int tmp ;
  char const   *data___2 ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 114
  while (1) {
    while_continue: /* CIL Label */ ;
#line 114
    if (! ((unsigned long )p->xml < (unsigned long )(p->xmlend - 1))) {
#line 114
      goto while_break;
    }
#line 116
    if ((int const   )*(p->xml + 0) == 60) {
#line 116
      if ((int const   )*(p->xml + 1) != 63) {
#line 118
        i = 0;
#line 118
        (p->xml) ++;
#line 118
        elementname = p->xml;
        {
#line 119
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 119
          if ((int const   )*(p->xml) == 32) {
#line 119
            goto while_break___0;
          } else
#line 119
          if ((int const   )*(p->xml) == 9) {
#line 119
            goto while_break___0;
          } else
#line 119
          if ((int const   )*(p->xml) == 13) {
#line 119
            goto while_break___0;
          } else
#line 119
          if ((int const   )*(p->xml) == 10) {
#line 119
            goto while_break___0;
          } else
#line 119
          if ((int const   )*(p->xml) != 62) {
#line 119
            if (! ((int const   )*(p->xml) != 47)) {
#line 119
              goto while_break___0;
            }
          } else {
#line 119
            goto while_break___0;
          }
#line 123
          i ++;
#line 123
          (p->xml) ++;
#line 124
          if ((unsigned long )p->xml >= (unsigned long )p->xmlend) {
#line 125
            return;
          }
#line 127
          if ((int const   )*(p->xml) == 58) {
#line 129
            i = 0;
#line 130
            (p->xml) ++;
#line 130
            elementname = p->xml;
          }
        }
        while_break___0: /* CIL Label */ ;
        }
#line 133
        if (i > 0) {
#line 135
          if (p->starteltfunc) {
            {
#line 136
            (*(p->starteltfunc))(p->data, elementname, i);
            }
          }
          {
#line 137
          tmp = parseatt___0(p);
          }
#line 137
          if (tmp) {
#line 138
            return;
          }
#line 139
          if ((int const   )*(p->xml) != 47) {
#line 142
            i = 0;
#line 142
            (p->xml) ++;
#line 142
            data___2 = p->xml;
#line 143
            if ((unsigned long )p->xml >= (unsigned long )p->xmlend) {
#line 144
              return;
            }
            {
#line 145
            while (1) {
              while_continue___1: /* CIL Label */ ;
#line 145
              if (! ((int const   )*(p->xml) == 32)) {
#line 145
                if (! ((int const   )*(p->xml) == 9)) {
#line 145
                  if (! ((int const   )*(p->xml) == 13)) {
#line 145
                    if (! ((int const   )*(p->xml) == 10)) {
#line 145
                      goto while_break___1;
                    }
                  }
                }
              }
#line 147
              i ++;
#line 147
              (p->xml) ++;
#line 148
              if ((unsigned long )p->xml >= (unsigned long )p->xmlend) {
#line 149
                return;
              }
            }
            while_break___1: /* CIL Label */ ;
            }
            {
#line 151
            tmp___1 = memcmp((void const   *)p->xml, (void const   *)"<![CDATA[",
                             (size_t )9);
            }
#line 151
            if (tmp___1 == 0) {
#line 154
              p->xml += 9;
#line 155
              data___2 = p->xml;
#line 156
              i = 0;
              {
#line 157
              while (1) {
                while_continue___2: /* CIL Label */ ;
                {
#line 157
                tmp___0 = memcmp((void const   *)p->xml, (void const   *)"]]>", (size_t )3);
                }
#line 157
                if (! (tmp___0 != 0)) {
#line 157
                  goto while_break___2;
                }
#line 159
                i ++;
#line 159
                (p->xml) ++;
#line 160
                if ((unsigned long )(p->xml + 3) >= (unsigned long )p->xmlend) {
#line 161
                  return;
                }
              }
              while_break___2: /* CIL Label */ ;
              }
#line 163
              if (i > 0) {
#line 163
                if (p->datafunc) {
                  {
#line 164
                  (*(p->datafunc))(p->data, data___2, i);
                  }
                }
              }
              {
#line 165
              while (1) {
                while_continue___3: /* CIL Label */ ;
#line 165
                if (! ((int const   )*(p->xml) != 60)) {
#line 165
                  goto while_break___3;
                }
#line 167
                (p->xml) ++;
#line 168
                if ((unsigned long )p->xml >= (unsigned long )p->xmlend) {
#line 169
                  return;
                }
              }
              while_break___3: /* CIL Label */ ;
              }
            } else {
              {
#line 174
              while (1) {
                while_continue___4: /* CIL Label */ ;
#line 174
                if (! ((int const   )*(p->xml) != 60)) {
#line 174
                  goto while_break___4;
                }
#line 176
                i ++;
#line 176
                (p->xml) ++;
#line 177
                if ((unsigned long )(p->xml + 1) >= (unsigned long )p->xmlend) {
#line 178
                  return;
                }
              }
              while_break___4: /* CIL Label */ ;
              }
#line 180
              if (i > 0) {
#line 180
                if (p->datafunc) {
#line 180
                  if ((int const   )*(p->xml + 1) == 47) {
                    {
#line 181
                    (*(p->datafunc))(p->data, data___2, i);
                    }
                  }
                }
              }
            }
          }
        } else
#line 185
        if ((int const   )*(p->xml) == 47) {
#line 187
          i = 0;
#line 187
          (p->xml) ++;
#line 187
          elementname = p->xml;
#line 188
          if ((unsigned long )p->xml >= (unsigned long )p->xmlend) {
#line 189
            return;
          }
          {
#line 190
          while (1) {
            while_continue___5: /* CIL Label */ ;
#line 190
            if (! ((int const   )*(p->xml) != 62)) {
#line 190
              goto while_break___5;
            }
#line 192
            i ++;
#line 192
            (p->xml) ++;
#line 193
            if ((unsigned long )p->xml >= (unsigned long )p->xmlend) {
#line 194
              return;
            }
          }
          while_break___5: /* CIL Label */ ;
          }
#line 196
          if (p->endeltfunc) {
            {
#line 197
            (*(p->endeltfunc))(p->data, elementname, i);
            }
          }
#line 198
          (p->xml) ++;
        }
      } else {
#line 203
        (p->xml) ++;
      }
    } else {
#line 203
      (p->xml) ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 206
  return;
}
}
#line 286 "/home/wheatley/newnew/temp/miniupnpc-1.6/miniwget.c"
static void *miniwget3___0(char const   *url , char const   *host , unsigned short port ,
                           char const   *path , int *size , char *addr_str , int addr_str_len ,
                           char const   *httpversion ) 
{ 
  char buf[2048] ;
  int s ;
  int n ;
  int len ;
  int sent ;
  void *content ;
  struct sockaddr_storage saddr ;
  socklen_t saddrlen ;
  char const   *tmp ;
  int tmp___0 ;
  ssize_t tmp___1 ;

  {
  {
#line 299
  *size = 0;
#line 300
  s = connecthostport(host, port);
  }
#line 301
  if (s < 0) {
#line 302
    return ((void *)0);
  }
#line 305
  if (addr_str) {
    {
#line 310
    saddrlen = (socklen_t )sizeof(saddr);
#line 311
    tmp___0 = getsockname(s, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& saddr)),
                          (socklen_t */* __restrict  */)(& saddrlen));
    }
#line 311
    if (tmp___0 < 0) {
      {
#line 313
      perror("getsockname");
      }
    } else {
      {
#line 341
      n = getnameinfo((struct sockaddr  const  */* __restrict  */)((struct sockaddr  const  *)(& saddr)),
                      saddrlen, (char */* __restrict  */)addr_str, (socklen_t )addr_str_len,
                      (char */* __restrict  */)((void *)0), (socklen_t )0, 3);
      }
#line 345
      if (n != 0) {
        {
#line 349
        tmp = gai_strerror(n);
#line 349
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"getnameinfo() failed : %s\n",
                tmp);
        }
      }
    }
  }
  {
#line 359
  len = snprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)"GET %s HTTP/%s\r\nHost: %s:%d\r\nConnection: Close\r\nUser-Agent: Ubuntu/14.04, UPnP/1.0, MiniUPnPc/1.6\r\n\r\n",
                 path, httpversion, host, (int )port);
#line 367
  sent = 0;
  }
  {
#line 369
  while (1) {
    while_continue: /* CIL Label */ ;
#line 369
    if (! (sent < len)) {
#line 369
      goto while_break;
    }
    {
#line 371
    tmp___1 = send(s, (void const   *)(buf + sent), (size_t )(len - sent), 0);
#line 371
    n = (int )tmp___1;
    }
#line 372
    if (n < 0) {
      {
#line 374
      perror("send");
#line 375
      close(s);
      }
#line 376
      return ((void *)0);
    } else {
#line 380
      sent += n;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 383
  content = getHTTPResponse(s, size);
#line 384
  close(s);
  }
#line 385
  return (content);
}
}
#line 390 "/home/wheatley/newnew/temp/miniupnpc-1.6/miniwget.c"
static void *miniwget2___0(char const   *url , char const   *host , unsigned short port ,
                           char const   *path , int *size , char *addr_str , int addr_str_len ) 
{ 
  char *respbuffer ;
  void *tmp ;

  {
  {
#line 397
  tmp = miniwget3___0(url, host, port, path, size, addr_str, addr_str_len, "1.1");
#line 397
  respbuffer = (char *)tmp;
  }
#line 409
  return ((void *)respbuffer);
}
}
#line 15 "/home/wheatley/newnew/temp/miniupnpc-1.6/upnpcommands.c"
static unsigned int my_atoui___0(char const   *s ) 
{ 
  unsigned long tmp ;
  unsigned int tmp___0 ;

  {
#line 18
  if (s) {
    {
#line 18
    tmp = strtoul((char const   */* __restrict  */)s, (char **/* __restrict  */)((void *)0),
                  0);
#line 18
    tmp___0 = (unsigned int )tmp;
    }
  } else {
#line 18
    tmp___0 = 0U;
  }
#line 18
  return (tmp___0);
}
}
#line 13 "/home/wheatley/newnew/temp/miniupnpc-1.6/portlistingparse.c"
static struct __anonstruct_elements_23___0  const  elements___0[10]  = 
#line 13 "/home/wheatley/newnew/temp/miniupnpc-1.6/portlistingparse.c"
  {      {(portMappingElt const   )1, (char const   */* const  */)"PortMappingEntry"}, 
        {(portMappingElt const   )2,
      (char const   */* const  */)"NewRemoteHost"}, 
        {(portMappingElt const   )3, (char const   */* const  */)"NewExternalPort"}, 
        {(portMappingElt const   )4, (char const   */* const  */)"NewProtocol"}, 
        {(portMappingElt const   )5, (char const   */* const  */)"NewInternalPort"}, 
        {(portMappingElt const   )6, (char const   */* const  */)"NewInternalClient"}, 
        {(portMappingElt const   )7,
      (char const   */* const  */)"NewEnabled"}, 
        {(portMappingElt const   )8, (char const   */* const  */)"NewDescription"}, 
        {(portMappingElt const   )9, (char const   */* const  */)"NewLeaseTime"}, 
        {(portMappingElt const   )0, (char const   */* const  */)((void *)0)}};
#line 30 "/home/wheatley/newnew/temp/miniupnpc-1.6/portlistingparse.c"
static unsigned int atoui___0(char const   *p , int l ) 
{ 
  unsigned int r ;

  {
#line 33
  r = 0U;
  {
#line 34
  while (1) {
    while_continue: /* CIL Label */ ;
#line 34
    if (l > 0) {
#line 34
      if (! *p) {
#line 34
        goto while_break;
      }
    } else {
#line 34
      goto while_break;
    }
#line 36
    if ((int const   )*p >= 48) {
#line 36
      if ((int const   )*p <= 57) {
#line 37
        r = r * 10U + (unsigned int )((int const   )*p - 48);
      } else {
#line 39
        goto while_break;
      }
    } else {
#line 39
      goto while_break;
    }
#line 40
    p ++;
#line 41
    l --;
  }
  while_break: /* CIL Label */ ;
  }
#line 43
  return (r);
}
}
#line 47 "/home/wheatley/newnew/temp/miniupnpc-1.6/portlistingparse.c"
static void startelt___0(void *d , char const   *name , int l ) 
{ 
  int i ;
  struct PortMappingParserData *pdata ;
  int tmp ;
  struct PortMapping *pm ;
  void *tmp___0 ;
  struct PortMapping *tmp___1 ;

  {
#line 51
  pdata = (struct PortMappingParserData *)d;
#line 52
  pdata->curelt = (portMappingElt )0;
#line 53
  i = 0;
  {
#line 53
  while (1) {
    while_continue: /* CIL Label */ ;
#line 53
    if (! elements___0[i].str) {
#line 53
      goto while_break;
    }
    {
#line 55
    tmp = memcmp((void const   *)name, (void const   *)elements___0[i].str, (size_t )l);
    }
#line 55
    if (tmp == 0) {
#line 57
      pdata->curelt = (portMappingElt )elements___0[i].code;
#line 58
      goto while_break;
    }
#line 53
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 61
  if ((unsigned int )pdata->curelt == 1U) {
    {
#line 64
    tmp___0 = calloc((size_t )1, sizeof(struct PortMapping ));
#line 64
    pm = (struct PortMapping *)tmp___0;
    }
    {
#line 65
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 65
      tmp___1 = pdata->head.lh_first;
#line 65
      pm->entries.le_next = tmp___1;
#line 65
      if ((unsigned long )tmp___1 != (unsigned long )((void *)0)) {
#line 65
        (pdata->head.lh_first)->entries.le_prev = & pm->entries.le_next;
      }
#line 65
      pdata->head.lh_first = pm;
#line 65
      pm->entries.le_prev = & pdata->head.lh_first;
#line 65
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 67
  return;
}
}
#line 70 "/home/wheatley/newnew/temp/miniupnpc-1.6/portlistingparse.c"
static void endelt___0(void *d , char const   *name , int l ) 
{ 
  struct PortMappingParserData *pdata ;

  {
#line 73
  pdata = (struct PortMappingParserData *)d;
#line 74
  pdata->curelt = (portMappingElt )0;
#line 75
  return;
}
}
#line 78 "/home/wheatley/newnew/temp/miniupnpc-1.6/portlistingparse.c"
static void data___0(void *d , char const   *data___2 , int l ) 
{ 
  struct PortMapping *pm ;
  struct PortMappingParserData *pdata ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;

  {
#line 82
  pdata = (struct PortMappingParserData *)d;
#line 83
  pm = pdata->head.lh_first;
#line 84
  if (! pm) {
#line 85
    return;
  }
#line 86
  if (l > 63) {
#line 87
    l = 63;
  }
  {
#line 90
  if ((unsigned int )pdata->curelt == 2U) {
#line 90
    goto case_2;
  }
#line 94
  if ((unsigned int )pdata->curelt == 3U) {
#line 94
    goto case_3;
  }
#line 97
  if ((unsigned int )pdata->curelt == 4U) {
#line 97
    goto case_4;
  }
#line 103
  if ((unsigned int )pdata->curelt == 5U) {
#line 103
    goto case_5;
  }
#line 106
  if ((unsigned int )pdata->curelt == 6U) {
#line 106
    goto case_6;
  }
#line 110
  if ((unsigned int )pdata->curelt == 7U) {
#line 110
    goto case_7;
  }
#line 113
  if ((unsigned int )pdata->curelt == 8U) {
#line 113
    goto case_8;
  }
#line 117
  if ((unsigned int )pdata->curelt == 9U) {
#line 117
    goto case_9;
  }
#line 120
  goto switch_default;
  case_2: /* CIL Label */ 
  {
#line 91
  memcpy((void */* __restrict  */)(pm->remoteHost), (void const   */* __restrict  */)data___2,
         (size_t )l);
#line 92
  pm->remoteHost[l] = (char )'\000';
  }
#line 93
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 95
  tmp = atoui___0(data___2, l);
#line 95
  pm->externalPort = (unsigned short )tmp;
  }
#line 96
  goto switch_break;
  case_4: /* CIL Label */ 
#line 98
  if (l > 3) {
#line 99
    l = 3;
  }
  {
#line 100
  memcpy((void */* __restrict  */)(pm->protocol), (void const   */* __restrict  */)data___2,
         (size_t )l);
#line 101
  pm->protocol[l] = (char )'\000';
  }
#line 102
  goto switch_break;
  case_5: /* CIL Label */ 
  {
#line 104
  tmp___0 = atoui___0(data___2, l);
#line 104
  pm->internalPort = (unsigned short )tmp___0;
  }
#line 105
  goto switch_break;
  case_6: /* CIL Label */ 
  {
#line 107
  memcpy((void */* __restrict  */)(pm->internalClient), (void const   */* __restrict  */)data___2,
         (size_t )l);
#line 108
  pm->internalClient[l] = (char )'\000';
  }
#line 109
  goto switch_break;
  case_7: /* CIL Label */ 
  {
#line 111
  tmp___1 = atoui___0(data___2, l);
#line 111
  pm->enabled = (unsigned char )tmp___1;
  }
#line 112
  goto switch_break;
  case_8: /* CIL Label */ 
  {
#line 114
  memcpy((void */* __restrict  */)(pm->description), (void const   */* __restrict  */)data___2,
         (size_t )l);
#line 115
  pm->description[l] = (char )'\000';
  }
#line 116
  goto switch_break;
  case_9: /* CIL Label */ 
  {
#line 118
  pm->leaseTime = atoui___0(data___2, l);
  }
#line 119
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 121
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 123
  return;
}
}
#line 15 "/home/wheatley/newnew/temp/miniupnpc-1.6/upnpreplyparse.c"
static void NameValueParserStartElt___0(void *d , char const   *name , int l ) 
{ 
  struct NameValueParserData *data___2 ;

  {
#line 18
  data___2 = (struct NameValueParserData *)d;
#line 19
  if (l > 63) {
#line 20
    l = 63;
  }
  {
#line 21
  memcpy((void */* __restrict  */)(data___2->curelt), (void const   */* __restrict  */)name,
         (size_t )l);
#line 22
  data___2->curelt[l] = (char )'\000';
  }
#line 23
  return;
}
}
#line 25 "/home/wheatley/newnew/temp/miniupnpc-1.6/upnpreplyparse.c"
static void NameValueParserGetData___0(void *d , char const   *datas , int l ) 
{ 
  struct NameValueParserData *data___2 ;
  struct NameValue *nv ;
  void *tmp ;
  void *tmp___0 ;
  struct NameValue *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 28
  data___2 = (struct NameValueParserData *)d;
#line 30
  tmp___2 = strcmp((char const   *)(data___2->curelt), "NewPortListing");
  }
#line 30
  if (tmp___2 == 0) {
    {
#line 33
    tmp = malloc((size_t )(l + 1));
#line 33
    data___2->portListing = (char *)tmp;
    }
#line 34
    if (! data___2->portListing) {
#line 37
      return;
    }
    {
#line 39
    memcpy((void */* __restrict  */)data___2->portListing, (void const   */* __restrict  */)datas,
           (size_t )l);
#line 40
    *(data___2->portListing + l) = (char )'\000';
#line 41
    data___2->portListingLength = l;
    }
  } else {
    {
#line 46
    tmp___0 = malloc(sizeof(struct NameValue ));
#line 46
    nv = (struct NameValue *)tmp___0;
    }
#line 47
    if (l > 63) {
#line 48
      l = 63;
    }
    {
#line 49
    strncpy((char */* __restrict  */)(nv->name), (char const   */* __restrict  */)(data___2->curelt),
            (size_t )64);
#line 50
    nv->name[63] = (char )'\000';
#line 51
    memcpy((void */* __restrict  */)(nv->value), (void const   */* __restrict  */)datas,
           (size_t )l);
#line 52
    nv->value[l] = (char )'\000';
    }
    {
#line 53
    while (1) {
      while_continue: /* CIL Label */ ;
#line 53
      tmp___1 = data___2->head.lh_first;
#line 53
      nv->entries.le_next = tmp___1;
#line 53
      if ((unsigned long )tmp___1 != (unsigned long )((void *)0)) {
#line 53
        (data___2->head.lh_first)->entries.le_prev = & nv->entries.le_next;
      }
#line 53
      data___2->head.lh_first = nv;
#line 53
      nv->entries.le_prev = & data___2->head.lh_first;
#line 53
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 55
  return;
}
}
#line 35 "/home/wheatley/newnew/temp/miniupnpc-1.6/minisoap.c"
static int httpWrite___1(int fd , char const   *body , int bodysize , char const   *headers ,
                         int headerssize ) 
{ 
  int n ;
  char *p ;
  void *tmp ;
  ssize_t tmp___0 ;

  {
  {
#line 39
  n = 0;
#line 47
  tmp = malloc((size_t )(headerssize + bodysize));
#line 47
  p = (char *)tmp;
  }
#line 48
  if (! p) {
#line 49
    return (0);
  }
  {
#line 50
  memcpy((void */* __restrict  */)p, (void const   */* __restrict  */)headers, (size_t )headerssize);
#line 51
  memcpy((void */* __restrict  */)(p + headerssize), (void const   */* __restrict  */)body,
         (size_t )bodysize);
#line 53
  tmp___0 = send(fd, (void const   *)p, (size_t )(headerssize + bodysize), 0);
#line 53
  n = (int )tmp___0;
  }
#line 54
  if (n < 0) {
    {
#line 55
    perror("send");
    }
  }
  {
#line 68
  free((void *)p);
  }
#line 69
  return (n);
}
}
#line 15 "/home/wheatley/newnew/temp/miniupnpc-1.6/upnpreplyparse.c"
static void NameValueParserStartElt___1(void *d , char const   *name , int l ) 
{ 
  struct NameValueParserData *data___2 ;

  {
#line 18
  data___2 = (struct NameValueParserData *)d;
#line 19
  if (l > 63) {
#line 20
    l = 63;
  }
  {
#line 21
  memcpy((void */* __restrict  */)(data___2->curelt), (void const   */* __restrict  */)name,
         (size_t )l);
#line 22
  data___2->curelt[l] = (char )'\000';
  }
#line 23
  return;
}
}
#line 25 "/home/wheatley/newnew/temp/miniupnpc-1.6/upnpreplyparse.c"
static void NameValueParserGetData___1(void *d , char const   *datas , int l ) 
{ 
  struct NameValueParserData *data___2 ;
  struct NameValue *nv ;
  void *tmp ;
  void *tmp___0 ;
  struct NameValue *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 28
  data___2 = (struct NameValueParserData *)d;
#line 30
  tmp___2 = strcmp((char const   *)(data___2->curelt), "NewPortListing");
  }
#line 30
  if (tmp___2 == 0) {
    {
#line 33
    tmp = malloc((size_t )(l + 1));
#line 33
    data___2->portListing = (char *)tmp;
    }
#line 34
    if (! data___2->portListing) {
#line 37
      return;
    }
    {
#line 39
    memcpy((void */* __restrict  */)data___2->portListing, (void const   */* __restrict  */)datas,
           (size_t )l);
#line 40
    *(data___2->portListing + l) = (char )'\000';
#line 41
    data___2->portListingLength = l;
    }
  } else {
    {
#line 46
    tmp___0 = malloc(sizeof(struct NameValue ));
#line 46
    nv = (struct NameValue *)tmp___0;
    }
#line 47
    if (l > 63) {
#line 48
      l = 63;
    }
    {
#line 49
    strncpy((char */* __restrict  */)(nv->name), (char const   */* __restrict  */)(data___2->curelt),
            (size_t )64);
#line 50
    nv->name[63] = (char )'\000';
#line 51
    memcpy((void */* __restrict  */)(nv->value), (void const   */* __restrict  */)datas,
           (size_t )l);
#line 52
    nv->value[l] = (char )'\000';
    }
    {
#line 53
    while (1) {
      while_continue: /* CIL Label */ ;
#line 53
      tmp___1 = data___2->head.lh_first;
#line 53
      nv->entries.le_next = tmp___1;
#line 53
      if ((unsigned long )tmp___1 != (unsigned long )((void *)0)) {
#line 53
        (data___2->head.lh_first)->entries.le_prev = & nv->entries.le_next;
      }
#line 53
      data___2->head.lh_first = nv;
#line 53
      nv->entries.le_prev = & data___2->head.lh_first;
#line 53
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 55
  return;
}
}
#line 247 "/home/wheatley/newnew/temp/miniupnpc-1.6/miniupnpc.c"
static void parseMSEARCHReply___1(char const   *reply , int size , char const   **location ,
                                  int *locationsize , char const   **st , int *stsize ) 
{ 
  int a ;
  int b ;
  int i ;
  int tmp ;
  int tmp___0 ;

  {
#line 253
  i = 0;
#line 254
  a = i;
#line 255
  b = 0;
  {
#line 256
  while (1) {
    while_continue: /* CIL Label */ ;
#line 256
    if (! (i < size)) {
#line 256
      goto while_break;
    }
    {
#line 260
    if ((int const   )*(reply + i) == 58) {
#line 260
      goto case_58;
    }
#line 272
    if ((int const   )*(reply + i) == 13) {
#line 272
      goto case_13;
    }
#line 272
    if ((int const   )*(reply + i) == 10) {
#line 272
      goto case_13;
    }
#line 296
    goto switch_default;
    case_58: /* CIL Label */ 
#line 261
    if (b == 0) {
#line 263
      b = i;
    }
#line 270
    goto switch_break;
    case_13: /* CIL Label */ 
    case_10: /* CIL Label */ 
#line 273
    if (b != 0) {
      {
#line 281
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 281
        b ++;
#line 281
        if (! ((int const   )*(reply + b) == 32)) {
#line 281
          goto while_break___0;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 282
      tmp___0 = strncasecmp(reply + a, "location", (size_t )8);
      }
#line 282
      if (0 == tmp___0) {
#line 284
        *location = reply + b;
#line 285
        *locationsize = i - b;
      } else {
        {
#line 287
        tmp = strncasecmp(reply + a, "st", (size_t )2);
        }
#line 287
        if (0 == tmp) {
#line 289
          *st = reply + b;
#line 290
          *stsize = i - b;
        }
      }
#line 292
      b = 0;
    }
#line 294
    a = i + 1;
#line 295
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 297
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 299
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 301
  return;
}
}
#line 326 "/home/wheatley/newnew/temp/miniupnpc-1.6/miniupnpc.c"
static char const   MSearchMsgFmt___1[77]  = 
#line 326
  {      (char const   )'M',      (char const   )'-',      (char const   )'S',      (char const   )'E', 
        (char const   )'A',      (char const   )'R',      (char const   )'C',      (char const   )'H', 
        (char const   )' ',      (char const   )'*',      (char const   )' ',      (char const   )'H', 
        (char const   )'T',      (char const   )'T',      (char const   )'P',      (char const   )'/', 
        (char const   )'1',      (char const   )'.',      (char const   )'1',      (char const   )'\r', 
        (char const   )'\n',      (char const   )'H',      (char const   )'O',      (char const   )'S', 
        (char const   )'T',      (char const   )':',      (char const   )' ',      (char const   )'%', 
        (char const   )'s',      (char const   )':',      (char const   )'1',      (char const   )'9', 
        (char const   )'0',      (char const   )'0',      (char const   )'\r',      (char const   )'\n', 
        (char const   )'S',      (char const   )'T',      (char const   )':',      (char const   )' ', 
        (char const   )'%',      (char const   )'s',      (char const   )'\r',      (char const   )'\n', 
        (char const   )'M',      (char const   )'A',      (char const   )'N',      (char const   )':', 
        (char const   )' ',      (char const   )'\"',      (char const   )'s',      (char const   )'s', 
        (char const   )'d',      (char const   )'p',      (char const   )':',      (char const   )'d', 
        (char const   )'i',      (char const   )'s',      (char const   )'c',      (char const   )'o', 
        (char const   )'v',      (char const   )'e',      (char const   )'r',      (char const   )'\"', 
        (char const   )'\r',      (char const   )'\n',      (char const   )'M',      (char const   )'X', 
        (char const   )':',      (char const   )' ',      (char const   )'%',      (char const   )'u', 
        (char const   )'\r',      (char const   )'\n',      (char const   )'\r',      (char const   )'\n', 
        (char const   )'\000'};
#line 333 "/home/wheatley/newnew/temp/miniupnpc-1.6/miniupnpc.c"
static char const   * const  deviceList___1[5]  = {      (char const   */* const  */)"urn:schemas-upnp-org:device:InternetGatewayDevice:1",      (char const   */* const  */)"urn:schemas-upnp-org:service:WANIPConnection:1",      (char const   */* const  */)"urn:schemas-upnp-org:service:WANPPPConnection:1",      (char const   */* const  */)"upnp:rootdevice", 
        (char const   */* const  */)0};
#line 679 "/home/wheatley/newnew/temp/miniupnpc-1.6/miniupnpc.c"
static void url_cpy_or_cat___1(char *dst , char const   *src , int n ) 
{ 
  int l ;
  size_t tmp ;
  int tmp___0 ;

  {
#line 682
  if ((int const   )*(src + 0) == 104) {
#line 682
    if ((int const   )*(src + 1) == 116) {
#line 682
      if ((int const   )*(src + 2) == 116) {
#line 682
        if ((int const   )*(src + 3) == 112) {
#line 682
          if ((int const   )*(src + 4) == 58) {
#line 682
            if ((int const   )*(src + 5) == 47) {
#line 682
              if ((int const   )*(src + 6) == 47) {
                {
#line 690
                strncpy((char */* __restrict  */)dst, (char const   */* __restrict  */)src,
                        (size_t )n);
                }
              } else {
#line 682
                goto _L___4;
              }
            } else {
#line 682
              goto _L___4;
            }
          } else {
#line 682
            goto _L___4;
          }
        } else {
#line 682
          goto _L___4;
        }
      } else {
#line 682
        goto _L___4;
      }
    } else {
#line 682
      goto _L___4;
    }
  } else {
    _L___4: /* CIL Label */ 
    {
#line 694
    tmp = strlen((char const   *)dst);
#line 694
    l = (int )tmp;
    }
#line 695
    if ((int const   )*(src + 0) != 47) {
#line 696
      tmp___0 = l;
#line 696
      l ++;
#line 696
      *(dst + tmp___0) = (char )'/';
    }
#line 697
    if (l <= n) {
      {
#line 698
      strncpy((char */* __restrict  */)(dst + l), (char const   */* __restrict  */)src,
              (size_t )(n - l));
      }
    }
  }
#line 700
  return;
}
}
#line 286 "/home/wheatley/newnew/temp/miniupnpc-1.6/miniwget.c"
static void *miniwget3___1(char const   *url , char const   *host , unsigned short port ,
                           char const   *path , int *size , char *addr_str , int addr_str_len ,
                           char const   *httpversion ) 
{ 
  char buf[2048] ;
  int s ;
  int n ;
  int len ;
  int sent ;
  void *content ;
  struct sockaddr_storage saddr ;
  socklen_t saddrlen ;
  char const   *tmp ;
  int tmp___0 ;
  ssize_t tmp___1 ;

  {
  {
#line 299
  *size = 0;
#line 300
  s = connecthostport(host, port);
  }
#line 301
  if (s < 0) {
#line 302
    return ((void *)0);
  }
#line 305
  if (addr_str) {
    {
#line 310
    saddrlen = (socklen_t )sizeof(saddr);
#line 311
    tmp___0 = getsockname(s, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& saddr)),
                          (socklen_t */* __restrict  */)(& saddrlen));
    }
#line 311
    if (tmp___0 < 0) {
      {
#line 313
      perror("getsockname");
      }
    } else {
      {
#line 341
      n = getnameinfo((struct sockaddr  const  */* __restrict  */)((struct sockaddr  const  *)(& saddr)),
                      saddrlen, (char */* __restrict  */)addr_str, (socklen_t )addr_str_len,
                      (char */* __restrict  */)((void *)0), (socklen_t )0, 3);
      }
#line 345
      if (n != 0) {
        {
#line 349
        tmp = gai_strerror(n);
#line 349
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"getnameinfo() failed : %s\n",
                tmp);
        }
      }
    }
  }
  {
#line 359
  len = snprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)"GET %s HTTP/%s\r\nHost: %s:%d\r\nConnection: Close\r\nUser-Agent: Ubuntu/14.04, UPnP/1.0, MiniUPnPc/1.6\r\n\r\n",
                 path, httpversion, host, (int )port);
#line 367
  sent = 0;
  }
  {
#line 369
  while (1) {
    while_continue: /* CIL Label */ ;
#line 369
    if (! (sent < len)) {
#line 369
      goto while_break;
    }
    {
#line 371
    tmp___1 = send(s, (void const   *)(buf + sent), (size_t )(len - sent), 0);
#line 371
    n = (int )tmp___1;
    }
#line 372
    if (n < 0) {
      {
#line 374
      perror("send");
#line 375
      close(s);
      }
#line 376
      return ((void *)0);
    } else {
#line 380
      sent += n;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 383
  content = getHTTPResponse(s, size);
#line 384
  close(s);
  }
#line 385
  return (content);
}
}
#line 390 "/home/wheatley/newnew/temp/miniupnpc-1.6/miniwget.c"
static void *miniwget2___1(char const   *url , char const   *host , unsigned short port ,
                           char const   *path , int *size , char *addr_str , int addr_str_len ) 
{ 
  char *respbuffer ;
  void *tmp ;

  {
  {
#line 397
  tmp = miniwget3___1(url, host, port, path, size, addr_str, addr_str_len, "1.1");
#line 397
  respbuffer = (char *)tmp;
  }
#line 409
  return ((void *)respbuffer);
}
}
#line 25 "/home/wheatley/newnew/temp/miniupnpc-1.6/upnpc.c"
static char const   proto_tcp___0[4]  = {      (char const   )'T',      (char const   )'C',      (char const   )'P',      (char const   )0};
#line 26 "/home/wheatley/newnew/temp/miniupnpc-1.6/upnpc.c"
static char const   proto_udp___0[4]  = {      (char const   )'U',      (char const   )'D',      (char const   )'P',      (char const   )0};
#line 41 "/home/wheatley/newnew/temp/miniupnpc-1.6/upnpc.c"
static void DisplayInfos___0(struct UPNPUrls *urls , struct IGDdatas *data___2 ) 
{ 
  char externalIPAddress[40] ;
  char connectionType[64] ;
  char status[64] ;
  char lastconnerr[64] ;
  unsigned int uptime ;
  unsigned int brUp ;
  unsigned int brDown ;
  time_t timenow ;
  time_t timestarted ;
  int r ;
  char *tmp ;

  {
  {
#line 52
  UPNP_GetConnectionTypeInfo((char const   *)urls->controlURL, (char const   *)(data___2->first.servicetype),
                             connectionType);
  }
#line 55
  if (connectionType[0]) {
    {
#line 56
    printf((char const   */* __restrict  */)"Connection Type : %s\n", connectionType);
    }
  } else {
    {
#line 58
    printf((char const   */* __restrict  */)"GetConnectionTypeInfo failed.\n");
    }
  }
  {
#line 59
  UPNP_GetStatusInfo((char const   *)urls->controlURL, (char const   *)(data___2->first.servicetype),
                     status, & uptime, lastconnerr);
#line 61
  printf((char const   */* __restrict  */)"Status : %s, uptime=%us, LastConnectionError : %s\n",
         status, uptime, lastconnerr);
#line 63
  timenow = time((time_t *)((void *)0));
#line 64
  timestarted = timenow - (time_t )uptime;
#line 65
  tmp = ctime((time_t const   *)(& timestarted));
#line 65
  printf((char const   */* __restrict  */)"  Time started : %s", tmp);
#line 66
  UPNP_GetLinkLayerMaxBitRates((char const   *)urls->controlURL_CIF, (char const   *)(data___2->CIF.servicetype),
                               & brDown, & brUp);
#line 68
  printf((char const   */* __restrict  */)"MaxBitRateDown : %u bps", brDown);
  }
#line 69
  if (brDown >= 1000000U) {
    {
#line 70
    printf((char const   */* __restrict  */)" (%u.%u Mbps)", brDown / 1000000U, (brDown / 100000U) % 10U);
    }
  } else
#line 71
  if (brDown >= 1000U) {
    {
#line 72
    printf((char const   */* __restrict  */)" (%u Kbps)", brDown / 1000U);
    }
  }
  {
#line 74
  printf((char const   */* __restrict  */)"   MaxBitRateUp %u bps", brUp);
  }
#line 75
  if (brUp >= 1000000U) {
    {
#line 76
    printf((char const   */* __restrict  */)" (%u.%u Mbps)", brUp / 1000000U, (brUp / 100000U) % 10U);
    }
  } else
#line 77
  if (brUp >= 1000U) {
    {
#line 78
    printf((char const   */* __restrict  */)" (%u Kbps)", brUp / 1000U);
    }
  }
  {
#line 80
  printf((char const   */* __restrict  */)"\n");
#line 81
  r = UPNP_GetExternalIPAddress((char const   *)urls->controlURL, (char const   *)(data___2->first.servicetype),
                                externalIPAddress);
  }
#line 84
  if (r != 0) {
    {
#line 85
    printf((char const   */* __restrict  */)"GetExternalIPAddress() returned %d\n",
           r);
    }
  }
#line 86
  if (externalIPAddress[0]) {
    {
#line 87
    printf((char const   */* __restrict  */)"ExternalIPAddress = %s\n", externalIPAddress);
    }
  } else {
    {
#line 89
    printf((char const   */* __restrict  */)"GetExternalIPAddress failed.\n");
    }
  }
#line 90
  return;
}
}
#line 92 "/home/wheatley/newnew/temp/miniupnpc-1.6/upnpc.c"
static void GetConnectionStatus___0(struct UPNPUrls *urls , struct IGDdatas *data___2 ) 
{ 
  unsigned int bytessent ;
  unsigned int bytesreceived ;
  unsigned int packetsreceived ;
  unsigned int packetssent ;

  {
  {
#line 96
  DisplayInfos___0(urls, data___2);
#line 97
  bytessent = UPNP_GetTotalBytesSent((char const   *)urls->controlURL_CIF, (char const   *)(data___2->CIF.servicetype));
#line 98
  bytesreceived = UPNP_GetTotalBytesReceived((char const   *)urls->controlURL_CIF,
                                             (char const   *)(data___2->CIF.servicetype));
#line 99
  packetssent = UPNP_GetTotalPacketsSent((char const   *)urls->controlURL_CIF, (char const   *)(data___2->CIF.servicetype));
#line 100
  packetsreceived = UPNP_GetTotalPacketsReceived((char const   *)urls->controlURL_CIF,
                                                 (char const   *)(data___2->CIF.servicetype));
#line 101
  printf((char const   */* __restrict  */)"Bytes:   Sent: %8u\tRecv: %8u\n", bytessent,
         bytesreceived);
#line 102
  printf((char const   */* __restrict  */)"Packets: Sent: %8u\tRecv: %8u\n", packetssent,
         packetsreceived);
  }
#line 103
  return;
}
}
#line 105 "/home/wheatley/newnew/temp/miniupnpc-1.6/upnpc.c"
static void ListRedirections___0(struct UPNPUrls *urls , struct IGDdatas *data___2 ) 
{ 
  int r ;
  int i ;
  char index___0[6] ;
  char intClient[40] ;
  char intPort[6] ;
  char extPort[6] ;
  char protocol[4] ;
  char desc[80] ;
  char enabled[6] ;
  char rHost[64] ;
  char duration[16] ;
  char const   *tmp ;

  {
#line 109
  i = 0;
  {
#line 122
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 123
    snprintf((char */* __restrict  */)(index___0), (size_t )6, (char const   */* __restrict  */)"%d",
             i);
#line 124
    rHost[0] = (char )'\000';
#line 124
    enabled[0] = (char )'\000';
#line 125
    duration[0] = (char )'\000';
#line 125
    desc[0] = (char )'\000';
#line 126
    extPort[0] = (char )'\000';
#line 126
    intPort[0] = (char )'\000';
#line 126
    intClient[0] = (char )'\000';
#line 127
    r = UPNP_GetGenericPortMappingEntry((char const   *)urls->controlURL, (char const   *)(data___2->first.servicetype),
                                        (char const   *)(index___0), extPort, intClient,
                                        intPort, protocol, desc, enabled, rHost, duration);
    }
#line 133
    if (r == 0) {
      {
#line 141
      printf((char const   */* __restrict  */)"%2d %s %5s->%s:%-5s \'%s\' \'%s\' %s\n",
             i, protocol, extPort, intClient, intPort, desc, rHost, duration);
      }
    } else {
      {
#line 145
      tmp = strupnperror(r);
#line 145
      printf((char const   */* __restrict  */)"GetGenericPortMappingEntry() returned %d (%s)\n",
             r, tmp);
      }
    }
#line 147
    i ++;
#line 122
    if (! (r == 0)) {
#line 122
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 149
  return;
}
}
#line 151 "/home/wheatley/newnew/temp/miniupnpc-1.6/upnpc.c"
static void NewListRedirections___0(struct UPNPUrls *urls , struct IGDdatas *data___2 ) 
{ 
  int r ;
  int i ;
  struct PortMappingParserData pdata ;
  struct PortMapping *pm ;
  char const   *tmp ;
  char const   *tmp___0 ;

  {
  {
#line 155
  i = 0;
#line 159
  memset((void *)(& pdata), 0, sizeof(struct PortMappingParserData ));
#line 160
  r = UPNP_GetListOfPortMappings((char const   *)urls->controlURL, (char const   *)(data___2->first.servicetype),
                                 "0", "65535", "TCP", "1000", & pdata);
  }
#line 167
  if (r == 0) {
#line 169
    pm = pdata.head.lh_first;
    {
#line 169
    while (1) {
      while_continue: /* CIL Label */ ;
#line 169
      if (! ((unsigned long )pm != (unsigned long )((void *)0))) {
#line 169
        goto while_break;
      }
      {
#line 171
      printf((char const   */* __restrict  */)"%2d %s %5hu->%s:%-5hu \'%s\' \'%s\' %u\n",
             i, pm->protocol, (int )pm->externalPort, pm->internalClient, (int )pm->internalPort,
             pm->description, pm->remoteHost, pm->leaseTime);
#line 176
      i ++;
#line 169
      pm = pm->entries.le_next;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 178
    FreePortListing(& pdata);
    }
  } else {
    {
#line 182
    tmp = strupnperror(r);
#line 182
    printf((char const   */* __restrict  */)"GetListOfPortMappings() returned %d (%s)\n",
           r, tmp);
    }
  }
  {
#line 185
  r = UPNP_GetListOfPortMappings((char const   *)urls->controlURL, (char const   *)(data___2->first.servicetype),
                                 "0", "65535", "UDP", "1000", & pdata);
  }
#line 192
  if (r == 0) {
#line 194
    pm = pdata.head.lh_first;
    {
#line 194
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 194
      if (! ((unsigned long )pm != (unsigned long )((void *)0))) {
#line 194
        goto while_break___0;
      }
      {
#line 196
      printf((char const   */* __restrict  */)"%2d %s %5hu->%s:%-5hu \'%s\' \'%s\' %u\n",
             i, pm->protocol, (int )pm->externalPort, pm->internalClient, (int )pm->internalPort,
             pm->description, pm->remoteHost, pm->leaseTime);
#line 201
      i ++;
#line 194
      pm = pm->entries.le_next;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 203
    FreePortListing(& pdata);
    }
  } else {
    {
#line 207
    tmp___0 = strupnperror(r);
#line 207
    printf((char const   */* __restrict  */)"GetListOfPortMappings() returned %d (%s)\n",
           r, tmp___0);
    }
  }
#line 210
  return;
}
}
#line 217 "/home/wheatley/newnew/temp/miniupnpc-1.6/upnpc.c"
static void SetRedirectAndTest___0(struct UPNPUrls *urls , struct IGDdatas *data___2 ,
                                   char const   *iaddr , char const   *iport , char const   *eport ,
                                   char const   *proto , char const   *leaseDuration ) 
{ 
  char externalIPAddress[40] ;
  char intClient[40] ;
  char intPort[6] ;
  char duration[16] ;
  int r ;
  char const   *tmp ;
  char const   *tmp___0 ;

  {
#line 231
  if (! iaddr) {
    {
#line 233
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Wrong arguments\n");
    }
#line 234
    return;
  } else
#line 231
  if (! iport) {
    {
#line 233
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Wrong arguments\n");
    }
#line 234
    return;
  } else
#line 231
  if (! eport) {
    {
#line 233
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Wrong arguments\n");
    }
#line 234
    return;
  } else
#line 231
  if (! proto) {
    {
#line 233
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Wrong arguments\n");
    }
#line 234
    return;
  }
  {
#line 236
  proto = protofix(proto);
  }
#line 237
  if (! proto) {
    {
#line 239
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"invalid protocol\n");
    }
#line 240
    return;
  }
  {
#line 243
  UPNP_GetExternalIPAddress((char const   *)urls->controlURL, (char const   *)(data___2->first.servicetype),
                            externalIPAddress);
  }
#line 246
  if (externalIPAddress[0]) {
    {
#line 247
    printf((char const   */* __restrict  */)"ExternalIPAddress = %s\n", externalIPAddress);
    }
  } else {
    {
#line 249
    printf((char const   */* __restrict  */)"GetExternalIPAddress failed.\n");
    }
  }
  {
#line 251
  r = UPNP_AddPortMapping((char const   *)urls->controlURL, (char const   *)(data___2->first.servicetype),
                          eport, iport, iaddr, (char const   *)0, proto, (char const   *)0,
                          leaseDuration);
  }
#line 253
  if (r != 0) {
    {
#line 254
    tmp = strupnperror(r);
#line 254
    printf((char const   */* __restrict  */)"AddPortMapping(%s, %s, %s) failed with code %d (%s)\n",
           eport, iport, iaddr, r, tmp);
    }
  }
  {
#line 257
  r = UPNP_GetSpecificPortMappingEntry((char const   *)urls->controlURL, (char const   *)(data___2->first.servicetype),
                                       eport, proto, intClient, intPort, (char *)((void *)0),
                                       (char *)((void *)0), duration);
  }
#line 262
  if (r != 0) {
    {
#line 263
    tmp___0 = strupnperror(r);
#line 263
    printf((char const   */* __restrict  */)"GetSpecificPortMappingEntry() failed with code %d (%s)\n",
           r, tmp___0);
    }
  }
#line 266
  if (intClient[0]) {
    {
#line 267
    printf((char const   */* __restrict  */)"InternalIP:Port = %s:%s\n", intClient,
           intPort);
#line 268
    printf((char const   */* __restrict  */)"external %s:%s %s is redirected to internal %s:%s (duration=%s)\n",
           externalIPAddress, eport, proto, intClient, intPort, duration);
    }
  }
#line 271
  return;
}
}
#line 273 "/home/wheatley/newnew/temp/miniupnpc-1.6/upnpc.c"
static void RemoveRedirect___0(struct UPNPUrls *urls , struct IGDdatas *data___2 ,
                               char const   *eport , char const   *proto ) 
{ 
  int r ;

  {
#line 280
  if (! proto) {
    {
#line 282
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"invalid arguments\n");
    }
#line 283
    return;
  } else
#line 280
  if (! eport) {
    {
#line 282
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"invalid arguments\n");
    }
#line 283
    return;
  }
  {
#line 285
  proto = protofix(proto);
  }
#line 286
  if (! proto) {
    {
#line 288
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"protocol invalid\n");
    }
#line 289
    return;
  }
  {
#line 291
  r = UPNP_DeletePortMapping((char const   *)urls->controlURL, (char const   *)(data___2->first.servicetype),
                             eport, proto, (char const   *)0);
#line 292
  printf((char const   */* __restrict  */)"UPNP_DeletePortMapping() returned : %d\n",
         r);
  }
#line 293
  return;
}
}
#line 296 "/home/wheatley/newnew/temp/miniupnpc-1.6/upnpc.c"
static void GetFirewallStatus___0(struct UPNPUrls *urls , struct IGDdatas *data___2 ) 
{ 
  unsigned int bytessent ;
  unsigned int bytesreceived ;
  unsigned int packetsreceived ;
  unsigned int packetssent ;
  int firewallEnabled ;
  int inboundPinholeAllowed ;
  char const   *tmp ;
  char const   *tmp___0 ;

  {
  {
#line 299
  firewallEnabled = 0;
#line 299
  inboundPinholeAllowed = 0;
#line 301
  UPNP_GetFirewallStatus((char const   *)urls->controlURL_6FC, (char const   *)(data___2->IPv6FC.servicetype),
                         & firewallEnabled, & inboundPinholeAllowed);
#line 302
  printf((char const   */* __restrict  */)"FirewallEnabled: %d & Inbound Pinhole Allowed: %d\n",
         firewallEnabled, inboundPinholeAllowed);
  }
#line 303
  if (inboundPinholeAllowed) {
#line 303
    tmp = "Yes";
  } else {
#line 303
    tmp = "No";
  }
#line 303
  if (firewallEnabled) {
#line 303
    tmp___0 = "Yes";
  } else {
#line 303
    tmp___0 = "No";
  }
  {
#line 303
  printf((char const   */* __restrict  */)"GetFirewallStatus:\n   Firewall Enabled: %s\n   Inbound Pinhole Allowed: %s\n",
         tmp___0, tmp);
#line 305
  bytessent = UPNP_GetTotalBytesSent((char const   *)urls->controlURL_CIF, (char const   *)(data___2->CIF.servicetype));
#line 306
  bytesreceived = UPNP_GetTotalBytesReceived((char const   *)urls->controlURL_CIF,
                                             (char const   *)(data___2->CIF.servicetype));
#line 307
  packetssent = UPNP_GetTotalPacketsSent((char const   *)urls->controlURL_CIF, (char const   *)(data___2->CIF.servicetype));
#line 308
  packetsreceived = UPNP_GetTotalPacketsReceived((char const   *)urls->controlURL_CIF,
                                                 (char const   *)(data___2->CIF.servicetype));
#line 309
  printf((char const   */* __restrict  */)"Bytes:   Sent: %8u\tRecv: %8u\n", bytessent,
         bytesreceived);
#line 310
  printf((char const   */* __restrict  */)"Packets: Sent: %8u\tRecv: %8u\n", packetssent,
         packetsreceived);
  }
#line 311
  return;
}
}
#line 316 "/home/wheatley/newnew/temp/miniupnpc-1.6/upnpc.c"
static void SetPinholeAndTest___0(struct UPNPUrls *urls , struct IGDdatas *data___2 ,
                                  char const   *remoteaddr , char const   *eport ,
                                  char const   *intaddr , char const   *iport , char const   *proto ,
                                  char const   *lease_time ) 
{ 
  char uniqueID[8] ;
  int r ;
  char const   *tmp ;

  {
#line 325
  if (! intaddr) {
    {
#line 327
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Wrong arguments\n");
    }
#line 328
    return;
  } else
#line 325
  if (! remoteaddr) {
    {
#line 327
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Wrong arguments\n");
    }
#line 328
    return;
  } else
#line 325
  if (! iport) {
    {
#line 327
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Wrong arguments\n");
    }
#line 328
    return;
  } else
#line 325
  if (! eport) {
    {
#line 327
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Wrong arguments\n");
    }
#line 328
    return;
  } else
#line 325
  if (! proto) {
    {
#line 327
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Wrong arguments\n");
    }
#line 328
    return;
  } else
#line 325
  if (! lease_time) {
    {
#line 327
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Wrong arguments\n");
    }
#line 328
    return;
  }
  {
#line 336
  r = UPNP_AddPinhole((char const   *)urls->controlURL_6FC, (char const   *)(data___2->IPv6FC.servicetype),
                      remoteaddr, eport, intaddr, iport, proto, lease_time, uniqueID);
  }
#line 337
  if (r != 0) {
    {
#line 338
    tmp = strupnperror(r);
#line 338
    printf((char const   */* __restrict  */)"AddPinhole([%s]:%s -> [%s]:%s) failed with code %d (%s)\n",
           intaddr, iport, remoteaddr, eport, r, tmp);
    }
  } else {
    {
#line 342
    printf((char const   */* __restrict  */)"AddPinhole: ([%s]:%s -> [%s]:%s) / Pinhole ID = %s\n",
           intaddr, iport, remoteaddr, eport, uniqueID);
    }
  }
#line 348
  return;
}
}
#line 353 "/home/wheatley/newnew/temp/miniupnpc-1.6/upnpc.c"
static void GetPinholeAndUpdate___0(struct UPNPUrls *urls , struct IGDdatas *data___2 ,
                                    char const   *uniqueID , char const   *lease_time ) 
{ 
  int isWorking ;
  int r ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;

  {
#line 356
  isWorking = 0;
#line 359
  if (! uniqueID) {
    {
#line 361
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Wrong arguments\n");
    }
#line 362
    return;
  } else
#line 359
  if (! lease_time) {
    {
#line 361
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Wrong arguments\n");
    }
#line 362
    return;
  }
  {
#line 364
  r = UPNP_CheckPinholeWorking((char const   *)urls->controlURL_6FC, (char const   *)(data___2->IPv6FC.servicetype),
                               uniqueID, & isWorking);
  }
#line 365
  if (isWorking) {
#line 365
    tmp = "Yes";
  } else {
#line 365
    tmp = "No";
  }
  {
#line 365
  printf((char const   */* __restrict  */)"CheckPinholeWorking: Pinhole ID = %s / IsWorking = %s\n",
         uniqueID, tmp);
  }
#line 366
  if (r != 0) {
    {
#line 367
    tmp___0 = strupnperror(r);
#line 367
    printf((char const   */* __restrict  */)"CheckPinholeWorking() failed with code %d (%s)\n",
           r, tmp___0);
    }
  }
#line 368
  if (isWorking) {
#line 368
    goto _L;
  } else
#line 368
  if (r == 709) {
    _L: /* CIL Label */ 
    {
#line 370
    r = UPNP_UpdatePinhole((char const   *)urls->controlURL_6FC, (char const   *)(data___2->IPv6FC.servicetype),
                           uniqueID, lease_time);
#line 371
    printf((char const   */* __restrict  */)"UpdatePinhole: Pinhole ID = %s with Lease Time: %s\n",
           uniqueID, lease_time);
    }
#line 372
    if (r != 0) {
      {
#line 373
      tmp___1 = strupnperror(r);
#line 373
      printf((char const   */* __restrict  */)"UpdatePinhole: ID (%s) failed with code %d (%s)\n",
             uniqueID, r, tmp___1);
      }
    }
  }
#line 375
  return;
}
}
#line 380 "/home/wheatley/newnew/temp/miniupnpc-1.6/upnpc.c"
static void GetPinholeOutboundTimeout___0(struct UPNPUrls *urls , struct IGDdatas *data___2 ,
                                          char const   *remoteaddr , char const   *eport ,
                                          char const   *intaddr , char const   *iport ,
                                          char const   *proto ) 
{ 
  int timeout ;
  int r ;
  char const   *tmp ;

  {
#line 385
  timeout = 0;
#line 388
  if (! intaddr) {
    {
#line 390
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Wrong arguments\n");
    }
#line 391
    return;
  } else
#line 388
  if (! remoteaddr) {
    {
#line 390
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Wrong arguments\n");
    }
#line 391
    return;
  } else
#line 388
  if (! iport) {
    {
#line 390
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Wrong arguments\n");
    }
#line 391
    return;
  } else
#line 388
  if (! eport) {
    {
#line 390
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Wrong arguments\n");
    }
#line 391
    return;
  } else
#line 388
  if (! proto) {
    {
#line 390
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Wrong arguments\n");
    }
#line 391
    return;
  }
  {
#line 394
  r = UPNP_GetOutboundPinholeTimeout((char const   *)urls->controlURL_6FC, (char const   *)(data___2->IPv6FC.servicetype),
                                     remoteaddr, eport, intaddr, iport, proto, & timeout);
  }
#line 395
  if (r != 0) {
    {
#line 396
    tmp = strupnperror(r);
#line 396
    printf((char const   */* __restrict  */)"GetOutboundPinholeTimeout([%s]:%s -> [%s]:%s) failed with code %d (%s)\n",
           intaddr, iport, remoteaddr, eport, r, tmp);
    }
  } else {
    {
#line 399
    printf((char const   */* __restrict  */)"GetOutboundPinholeTimeout: ([%s]:%s -> [%s]:%s) / Timeout = %d\n",
           intaddr, iport, remoteaddr, eport, timeout);
    }
  }
#line 400
  return;
}
}
#line 402 "/home/wheatley/newnew/temp/miniupnpc-1.6/upnpc.c"
static void GetPinholePackets___0(struct UPNPUrls *urls , struct IGDdatas *data___2 ,
                                  char const   *uniqueID ) 
{ 
  int r ;
  int pinholePackets ;
  char const   *tmp ;

  {
#line 406
  pinholePackets = 0;
#line 407
  if (! uniqueID) {
    {
#line 409
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"invalid arguments\n");
    }
#line 410
    return;
  }
  {
#line 412
  r = UPNP_GetPinholePackets((char const   *)urls->controlURL_6FC, (char const   *)(data___2->IPv6FC.servicetype),
                             uniqueID, & pinholePackets);
  }
#line 413
  if (r != 0) {
    {
#line 414
    tmp = strupnperror(r);
#line 414
    printf((char const   */* __restrict  */)"GetPinholePackets() failed with code %d (%s)\n",
           r, tmp);
    }
  } else {
    {
#line 416
    printf((char const   */* __restrict  */)"GetPinholePackets: Pinhole ID = %s / PinholePackets = %d\n",
           uniqueID, pinholePackets);
    }
  }
#line 417
  return;
}
}
#line 419 "/home/wheatley/newnew/temp/miniupnpc-1.6/upnpc.c"
static void CheckPinhole___0(struct UPNPUrls *urls , struct IGDdatas *data___2 , char const   *uniqueID ) 
{ 
  int r ;
  int isWorking ;
  char const   *tmp ;
  char const   *tmp___0 ;

  {
#line 423
  isWorking = 0;
#line 424
  if (! uniqueID) {
    {
#line 426
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"invalid arguments\n");
    }
#line 427
    return;
  }
  {
#line 429
  r = UPNP_CheckPinholeWorking((char const   *)urls->controlURL_6FC, (char const   *)(data___2->IPv6FC.servicetype),
                               uniqueID, & isWorking);
  }
#line 430
  if (r != 0) {
    {
#line 431
    tmp = strupnperror(r);
#line 431
    printf((char const   */* __restrict  */)"CheckPinholeWorking() failed with code %d (%s)\n",
           r, tmp);
    }
  } else {
#line 433
    if (isWorking) {
#line 433
      tmp___0 = "Yes";
    } else {
#line 433
      tmp___0 = "No";
    }
    {
#line 433
    printf((char const   */* __restrict  */)"CheckPinholeWorking: Pinhole ID = %s / IsWorking = %s\n",
           uniqueID, tmp___0);
    }
  }
#line 434
  return;
}
}
#line 436 "/home/wheatley/newnew/temp/miniupnpc-1.6/upnpc.c"
static void RemovePinhole___0(struct UPNPUrls *urls , struct IGDdatas *data___2 ,
                              char const   *uniqueID ) 
{ 
  int r ;

  {
#line 441
  if (! uniqueID) {
    {
#line 443
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"invalid arguments\n");
    }
#line 444
    return;
  }
  {
#line 446
  r = UPNP_DeletePinhole((char const   *)urls->controlURL_6FC, (char const   *)(data___2->IPv6FC.servicetype),
                         uniqueID);
#line 447
  printf((char const   */* __restrict  */)"UPNP_DeletePinhole() returned : %d\n",
         r);
  }
#line 448
  return;
}
}
#line 15 "/home/wheatley/newnew/temp/miniupnpc-1.6/upnpcommands.c"
static unsigned int my_atoui___1(char const   *s ) 
{ 
  unsigned long tmp ;
  unsigned int tmp___0 ;

  {
#line 18
  if (s) {
    {
#line 18
    tmp = strtoul((char const   */* __restrict  */)s, (char **/* __restrict  */)((void *)0),
                  0);
#line 18
    tmp___0 = (unsigned int )tmp;
    }
  } else {
#line 18
    tmp___0 = 0U;
  }
#line 18
  return (tmp___0);
}
}
#line 39 "/home/wheatley/newnew/temp/miniupnpc-1.6/minixml.c"
static int parseatt___1(struct xmlparser *p ) 
{ 
  char const   *attname ;
  int attnamelen ;
  char const   *attvalue ;
  int attvaluelen ;
  char sep ;
  char const   *tmp ;

  {
  {
#line 45
  while (1) {
    while_continue: /* CIL Label */ ;
#line 45
    if (! ((unsigned long )p->xml < (unsigned long )p->xmlend)) {
#line 45
      goto while_break;
    }
#line 47
    if ((int const   )*(p->xml) == 47) {
#line 48
      return (0);
    } else
#line 47
    if ((int const   )*(p->xml) == 62) {
#line 48
      return (0);
    }
#line 49
    if (! ((int const   )*(p->xml) == 32)) {
#line 49
      if (! ((int const   )*(p->xml) == 9)) {
#line 49
        if (! ((int const   )*(p->xml) == 13)) {
#line 49
          if (! ((int const   )*(p->xml) == 10)) {
#line 52
            attname = p->xml;
#line 53
            attnamelen = 0;
            {
#line 54
            while (1) {
              while_continue___0: /* CIL Label */ ;
#line 54
              if ((int const   )*(p->xml) != 61) {
#line 54
                if ((int const   )*(p->xml) == 32) {
#line 54
                  goto while_break___0;
                } else
#line 54
                if ((int const   )*(p->xml) == 9) {
#line 54
                  goto while_break___0;
                } else
#line 54
                if ((int const   )*(p->xml) == 13) {
#line 54
                  goto while_break___0;
                } else
#line 54
                if ((int const   )*(p->xml) == 10) {
#line 54
                  goto while_break___0;
                }
              } else {
#line 54
                goto while_break___0;
              }
#line 56
              attnamelen ++;
#line 56
              (p->xml) ++;
#line 57
              if ((unsigned long )p->xml >= (unsigned long )p->xmlend) {
#line 58
                return (-1);
              }
            }
            while_break___0: /* CIL Label */ ;
            }
            {
#line 60
            while (1) {
              while_continue___1: /* CIL Label */ ;
#line 60
              tmp = p->xml;
#line 60
              (p->xml) ++;
#line 60
              if (! ((int const   )*tmp != 61)) {
#line 60
                goto while_break___1;
              }
#line 62
              if ((unsigned long )p->xml >= (unsigned long )p->xmlend) {
#line 63
                return (-1);
              }
            }
            while_break___1: /* CIL Label */ ;
            }
            {
#line 65
            while (1) {
              while_continue___2: /* CIL Label */ ;
#line 65
              if (! ((int const   )*(p->xml) == 32)) {
#line 65
                if (! ((int const   )*(p->xml) == 9)) {
#line 65
                  if (! ((int const   )*(p->xml) == 13)) {
#line 65
                    if (! ((int const   )*(p->xml) == 10)) {
#line 65
                      goto while_break___2;
                    }
                  }
                }
              }
#line 67
              (p->xml) ++;
#line 68
              if ((unsigned long )p->xml >= (unsigned long )p->xmlend) {
#line 69
                return (-1);
              }
            }
            while_break___2: /* CIL Label */ ;
            }
#line 71
            sep = (char )*(p->xml);
#line 72
            if ((int )sep == 39) {
#line 72
              goto _L;
            } else
#line 72
            if ((int )sep == 34) {
              _L: /* CIL Label */ 
#line 74
              (p->xml) ++;
#line 75
              if ((unsigned long )p->xml >= (unsigned long )p->xmlend) {
#line 76
                return (-1);
              }
#line 77
              attvalue = p->xml;
#line 78
              attvaluelen = 0;
              {
#line 79
              while (1) {
                while_continue___3: /* CIL Label */ ;
#line 79
                if (! ((int const   )*(p->xml) != (int const   )sep)) {
#line 79
                  goto while_break___3;
                }
#line 81
                attvaluelen ++;
#line 81
                (p->xml) ++;
#line 82
                if ((unsigned long )p->xml >= (unsigned long )p->xmlend) {
#line 83
                  return (-1);
                }
              }
              while_break___3: /* CIL Label */ ;
              }
            } else {
#line 88
              attvalue = p->xml;
#line 89
              attvaluelen = 0;
              {
#line 90
              while (1) {
                while_continue___4: /* CIL Label */ ;
#line 90
                if ((int const   )*(p->xml) == 32) {
#line 90
                  goto while_break___4;
                } else
#line 90
                if ((int const   )*(p->xml) == 9) {
#line 90
                  goto while_break___4;
                } else
#line 90
                if ((int const   )*(p->xml) == 13) {
#line 90
                  goto while_break___4;
                } else
#line 90
                if ((int const   )*(p->xml) == 10) {
#line 90
                  goto while_break___4;
                } else
#line 90
                if ((int const   )*(p->xml) != 62) {
#line 90
                  if (! ((int const   )*(p->xml) != 47)) {
#line 90
                    goto while_break___4;
                  }
                } else {
#line 90
                  goto while_break___4;
                }
#line 93
                attvaluelen ++;
#line 93
                (p->xml) ++;
#line 94
                if ((unsigned long )p->xml >= (unsigned long )p->xmlend) {
#line 95
                  return (-1);
                }
              }
              while_break___4: /* CIL Label */ ;
              }
            }
#line 100
            if (p->attfunc) {
              {
#line 101
              (*(p->attfunc))(p->data, attname, attnamelen, attvalue, attvaluelen);
              }
            }
          }
        }
      }
    }
#line 103
    (p->xml) ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 105
  return (-1);
}
}
#line 110 "/home/wheatley/newnew/temp/miniupnpc-1.6/minixml.c"
static void parseelt___1(struct xmlparser *p ) 
{ 
  int i ;
  char const   *elementname ;
  int tmp ;
  char const   *data___2 ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 114
  while (1) {
    while_continue: /* CIL Label */ ;
#line 114
    if (! ((unsigned long )p->xml < (unsigned long )(p->xmlend - 1))) {
#line 114
      goto while_break;
    }
#line 116
    if ((int const   )*(p->xml + 0) == 60) {
#line 116
      if ((int const   )*(p->xml + 1) != 63) {
#line 118
        i = 0;
#line 118
        (p->xml) ++;
#line 118
        elementname = p->xml;
        {
#line 119
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 119
          if ((int const   )*(p->xml) == 32) {
#line 119
            goto while_break___0;
          } else
#line 119
          if ((int const   )*(p->xml) == 9) {
#line 119
            goto while_break___0;
          } else
#line 119
          if ((int const   )*(p->xml) == 13) {
#line 119
            goto while_break___0;
          } else
#line 119
          if ((int const   )*(p->xml) == 10) {
#line 119
            goto while_break___0;
          } else
#line 119
          if ((int const   )*(p->xml) != 62) {
#line 119
            if (! ((int const   )*(p->xml) != 47)) {
#line 119
              goto while_break___0;
            }
          } else {
#line 119
            goto while_break___0;
          }
#line 123
          i ++;
#line 123
          (p->xml) ++;
#line 124
          if ((unsigned long )p->xml >= (unsigned long )p->xmlend) {
#line 125
            return;
          }
#line 127
          if ((int const   )*(p->xml) == 58) {
#line 129
            i = 0;
#line 130
            (p->xml) ++;
#line 130
            elementname = p->xml;
          }
        }
        while_break___0: /* CIL Label */ ;
        }
#line 133
        if (i > 0) {
#line 135
          if (p->starteltfunc) {
            {
#line 136
            (*(p->starteltfunc))(p->data, elementname, i);
            }
          }
          {
#line 137
          tmp = parseatt___1(p);
          }
#line 137
          if (tmp) {
#line 138
            return;
          }
#line 139
          if ((int const   )*(p->xml) != 47) {
#line 142
            i = 0;
#line 142
            (p->xml) ++;
#line 142
            data___2 = p->xml;
#line 143
            if ((unsigned long )p->xml >= (unsigned long )p->xmlend) {
#line 144
              return;
            }
            {
#line 145
            while (1) {
              while_continue___1: /* CIL Label */ ;
#line 145
              if (! ((int const   )*(p->xml) == 32)) {
#line 145
                if (! ((int const   )*(p->xml) == 9)) {
#line 145
                  if (! ((int const   )*(p->xml) == 13)) {
#line 145
                    if (! ((int const   )*(p->xml) == 10)) {
#line 145
                      goto while_break___1;
                    }
                  }
                }
              }
#line 147
              i ++;
#line 147
              (p->xml) ++;
#line 148
              if ((unsigned long )p->xml >= (unsigned long )p->xmlend) {
#line 149
                return;
              }
            }
            while_break___1: /* CIL Label */ ;
            }
            {
#line 151
            tmp___1 = memcmp((void const   *)p->xml, (void const   *)"<![CDATA[",
                             (size_t )9);
            }
#line 151
            if (tmp___1 == 0) {
#line 154
              p->xml += 9;
#line 155
              data___2 = p->xml;
#line 156
              i = 0;
              {
#line 157
              while (1) {
                while_continue___2: /* CIL Label */ ;
                {
#line 157
                tmp___0 = memcmp((void const   *)p->xml, (void const   *)"]]>", (size_t )3);
                }
#line 157
                if (! (tmp___0 != 0)) {
#line 157
                  goto while_break___2;
                }
#line 159
                i ++;
#line 159
                (p->xml) ++;
#line 160
                if ((unsigned long )(p->xml + 3) >= (unsigned long )p->xmlend) {
#line 161
                  return;
                }
              }
              while_break___2: /* CIL Label */ ;
              }
#line 163
              if (i > 0) {
#line 163
                if (p->datafunc) {
                  {
#line 164
                  (*(p->datafunc))(p->data, data___2, i);
                  }
                }
              }
              {
#line 165
              while (1) {
                while_continue___3: /* CIL Label */ ;
#line 165
                if (! ((int const   )*(p->xml) != 60)) {
#line 165
                  goto while_break___3;
                }
#line 167
                (p->xml) ++;
#line 168
                if ((unsigned long )p->xml >= (unsigned long )p->xmlend) {
#line 169
                  return;
                }
              }
              while_break___3: /* CIL Label */ ;
              }
            } else {
              {
#line 174
              while (1) {
                while_continue___4: /* CIL Label */ ;
#line 174
                if (! ((int const   )*(p->xml) != 60)) {
#line 174
                  goto while_break___4;
                }
#line 176
                i ++;
#line 176
                (p->xml) ++;
#line 177
                if ((unsigned long )(p->xml + 1) >= (unsigned long )p->xmlend) {
#line 178
                  return;
                }
              }
              while_break___4: /* CIL Label */ ;
              }
#line 180
              if (i > 0) {
#line 180
                if (p->datafunc) {
#line 180
                  if ((int const   )*(p->xml + 1) == 47) {
                    {
#line 181
                    (*(p->datafunc))(p->data, data___2, i);
                    }
                  }
                }
              }
            }
          }
        } else
#line 185
        if ((int const   )*(p->xml) == 47) {
#line 187
          i = 0;
#line 187
          (p->xml) ++;
#line 187
          elementname = p->xml;
#line 188
          if ((unsigned long )p->xml >= (unsigned long )p->xmlend) {
#line 189
            return;
          }
          {
#line 190
          while (1) {
            while_continue___5: /* CIL Label */ ;
#line 190
            if (! ((int const   )*(p->xml) != 62)) {
#line 190
              goto while_break___5;
            }
#line 192
            i ++;
#line 192
            (p->xml) ++;
#line 193
            if ((unsigned long )p->xml >= (unsigned long )p->xmlend) {
#line 194
              return;
            }
          }
          while_break___5: /* CIL Label */ ;
          }
#line 196
          if (p->endeltfunc) {
            {
#line 197
            (*(p->endeltfunc))(p->data, elementname, i);
            }
          }
#line 198
          (p->xml) ++;
        }
      } else {
#line 203
        (p->xml) ++;
      }
    } else {
#line 203
      (p->xml) ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 206
  return;
}
}
#line 13 "/home/wheatley/newnew/temp/miniupnpc-1.6/portlistingparse.c"
static struct __anonstruct_elements_23___1  const  elements___1[10]  = 
#line 13 "/home/wheatley/newnew/temp/miniupnpc-1.6/portlistingparse.c"
  {      {(portMappingElt const   )1, (char const   */* const  */)"PortMappingEntry"}, 
        {(portMappingElt const   )2,
      (char const   */* const  */)"NewRemoteHost"}, 
        {(portMappingElt const   )3, (char const   */* const  */)"NewExternalPort"}, 
        {(portMappingElt const   )4, (char const   */* const  */)"NewProtocol"}, 
        {(portMappingElt const   )5, (char const   */* const  */)"NewInternalPort"}, 
        {(portMappingElt const   )6, (char const   */* const  */)"NewInternalClient"}, 
        {(portMappingElt const   )7,
      (char const   */* const  */)"NewEnabled"}, 
        {(portMappingElt const   )8, (char const   */* const  */)"NewDescription"}, 
        {(portMappingElt const   )9, (char const   */* const  */)"NewLeaseTime"}, 
        {(portMappingElt const   )0, (char const   */* const  */)((void *)0)}};
#line 30 "/home/wheatley/newnew/temp/miniupnpc-1.6/portlistingparse.c"
static unsigned int atoui___1(char const   *p , int l ) 
{ 
  unsigned int r ;

  {
#line 33
  r = 0U;
  {
#line 34
  while (1) {
    while_continue: /* CIL Label */ ;
#line 34
    if (l > 0) {
#line 34
      if (! *p) {
#line 34
        goto while_break;
      }
    } else {
#line 34
      goto while_break;
    }
#line 36
    if ((int const   )*p >= 48) {
#line 36
      if ((int const   )*p <= 57) {
#line 37
        r = r * 10U + (unsigned int )((int const   )*p - 48);
      } else {
#line 39
        goto while_break;
      }
    } else {
#line 39
      goto while_break;
    }
#line 40
    p ++;
#line 41
    l --;
  }
  while_break: /* CIL Label */ ;
  }
#line 43
  return (r);
}
}
#line 47 "/home/wheatley/newnew/temp/miniupnpc-1.6/portlistingparse.c"
static void startelt___1(void *d , char const   *name , int l ) 
{ 
  int i ;
  struct PortMappingParserData *pdata ;
  int tmp ;
  struct PortMapping *pm ;
  void *tmp___0 ;
  struct PortMapping *tmp___1 ;

  {
#line 51
  pdata = (struct PortMappingParserData *)d;
#line 52
  pdata->curelt = (portMappingElt )0;
#line 53
  i = 0;
  {
#line 53
  while (1) {
    while_continue: /* CIL Label */ ;
#line 53
    if (! elements___1[i].str) {
#line 53
      goto while_break;
    }
    {
#line 55
    tmp = memcmp((void const   *)name, (void const   *)elements___1[i].str, (size_t )l);
    }
#line 55
    if (tmp == 0) {
#line 57
      pdata->curelt = (portMappingElt )elements___1[i].code;
#line 58
      goto while_break;
    }
#line 53
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 61
  if ((unsigned int )pdata->curelt == 1U) {
    {
#line 64
    tmp___0 = calloc((size_t )1, sizeof(struct PortMapping ));
#line 64
    pm = (struct PortMapping *)tmp___0;
    }
    {
#line 65
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 65
      tmp___1 = pdata->head.lh_first;
#line 65
      pm->entries.le_next = tmp___1;
#line 65
      if ((unsigned long )tmp___1 != (unsigned long )((void *)0)) {
#line 65
        (pdata->head.lh_first)->entries.le_prev = & pm->entries.le_next;
      }
#line 65
      pdata->head.lh_first = pm;
#line 65
      pm->entries.le_prev = & pdata->head.lh_first;
#line 65
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 67
  return;
}
}
#line 70 "/home/wheatley/newnew/temp/miniupnpc-1.6/portlistingparse.c"
static void endelt___1(void *d , char const   *name , int l ) 
{ 
  struct PortMappingParserData *pdata ;

  {
#line 73
  pdata = (struct PortMappingParserData *)d;
#line 74
  pdata->curelt = (portMappingElt )0;
#line 75
  return;
}
}
#line 78 "/home/wheatley/newnew/temp/miniupnpc-1.6/portlistingparse.c"
static void data___1(void *d , char const   *data___2 , int l ) 
{ 
  struct PortMapping *pm ;
  struct PortMappingParserData *pdata ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;

  {
#line 82
  pdata = (struct PortMappingParserData *)d;
#line 83
  pm = pdata->head.lh_first;
#line 84
  if (! pm) {
#line 85
    return;
  }
#line 86
  if (l > 63) {
#line 87
    l = 63;
  }
  {
#line 90
  if ((unsigned int )pdata->curelt == 2U) {
#line 90
    goto case_2;
  }
#line 94
  if ((unsigned int )pdata->curelt == 3U) {
#line 94
    goto case_3;
  }
#line 97
  if ((unsigned int )pdata->curelt == 4U) {
#line 97
    goto case_4;
  }
#line 103
  if ((unsigned int )pdata->curelt == 5U) {
#line 103
    goto case_5;
  }
#line 106
  if ((unsigned int )pdata->curelt == 6U) {
#line 106
    goto case_6;
  }
#line 110
  if ((unsigned int )pdata->curelt == 7U) {
#line 110
    goto case_7;
  }
#line 113
  if ((unsigned int )pdata->curelt == 8U) {
#line 113
    goto case_8;
  }
#line 117
  if ((unsigned int )pdata->curelt == 9U) {
#line 117
    goto case_9;
  }
#line 120
  goto switch_default;
  case_2: /* CIL Label */ 
  {
#line 91
  memcpy((void */* __restrict  */)(pm->remoteHost), (void const   */* __restrict  */)data___2,
         (size_t )l);
#line 92
  pm->remoteHost[l] = (char )'\000';
  }
#line 93
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 95
  tmp = atoui___1(data___2, l);
#line 95
  pm->externalPort = (unsigned short )tmp;
  }
#line 96
  goto switch_break;
  case_4: /* CIL Label */ 
#line 98
  if (l > 3) {
#line 99
    l = 3;
  }
  {
#line 100
  memcpy((void */* __restrict  */)(pm->protocol), (void const   */* __restrict  */)data___2,
         (size_t )l);
#line 101
  pm->protocol[l] = (char )'\000';
  }
#line 102
  goto switch_break;
  case_5: /* CIL Label */ 
  {
#line 104
  tmp___0 = atoui___1(data___2, l);
#line 104
  pm->internalPort = (unsigned short )tmp___0;
  }
#line 105
  goto switch_break;
  case_6: /* CIL Label */ 
  {
#line 107
  memcpy((void */* __restrict  */)(pm->internalClient), (void const   */* __restrict  */)data___2,
         (size_t )l);
#line 108
  pm->internalClient[l] = (char )'\000';
  }
#line 109
  goto switch_break;
  case_7: /* CIL Label */ 
  {
#line 111
  tmp___1 = atoui___1(data___2, l);
#line 111
  pm->enabled = (unsigned char )tmp___1;
  }
#line 112
  goto switch_break;
  case_8: /* CIL Label */ 
  {
#line 114
  memcpy((void */* __restrict  */)(pm->description), (void const   */* __restrict  */)data___2,
         (size_t )l);
#line 115
  pm->description[l] = (char )'\000';
  }
#line 116
  goto switch_break;
  case_9: /* CIL Label */ 
  {
#line 118
  pm->leaseTime = atoui___1(data___2, l);
  }
#line 119
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 121
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 123
  return;
}
}
