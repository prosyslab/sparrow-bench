/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 55 "/usr/include/stdint.h"
typedef unsigned long uint64_t;
#line 124 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 126 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 127 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 130 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 158 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 49 "/usr/include/stdint.h"
typedef unsigned short uint16_t;
#line 22 "/usr/include/x86_64-linux-gnu/bits/dirent.h"
struct dirent {
   __ino_t d_ino ;
   __off_t d_off ;
   unsigned short d_reclen ;
   unsigned char d_type ;
   char d_name[256] ;
};
#line 127 "/usr/include/dirent.h"
struct __dirstream;
#line 127 "/usr/include/dirent.h"
typedef struct __dirstream DIR;
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 233 "/home/wheatley/newnew/temp/missidentify-1.0/main.h"
struct _state {
   uint64_t mode ;
   uint64_t bytes_read ;
   char *file_extension ;
   char *fn ;
   unsigned char *buf ;
   unsigned char *strings ;
   FILE *handle ;
   int has_executable_extension ;
   int is_dll ;
   int is_exe ;
   int is_driver ;
   uint16_t string_len ;
   uint64_t files_processed ;
   int argc ;
   char **argv ;
   char *short_name ;
   char *msg ;
};
#line 233 "/home/wheatley/newnew/temp/missidentify-1.0/main.h"
typedef struct _state state;
#line 48 "/usr/include/stdint.h"
typedef unsigned char uint8_t;
#line 20 "/home/wheatley/newnew/temp/missidentify-1.0/cycles.c"
struct dir_table {
   char *name ;
   struct dir_table *next ;
};
#line 20 "/home/wheatley/newnew/temp/missidentify-1.0/cycles.c"
typedef struct dir_table dir_table;
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 79 "/usr/include/stdio.h"
typedef __gnuc_va_list va_list;
#line 51 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 170 "/home/wheatley/newnew/temp/missidentify-1.0/main.h"
struct _IMAGE_DATA_DIRECTORY {
   uint32_t VirtualAddress ;
   uint32_t Size ;
};
#line 170 "/home/wheatley/newnew/temp/missidentify-1.0/main.h"
typedef struct _IMAGE_DATA_DIRECTORY IMAGE_DATA_DIRECTORY;
#line 177 "/home/wheatley/newnew/temp/missidentify-1.0/main.h"
struct _IMAGE_FILE_HEADER {
   uint16_t Machine ;
   uint16_t NumberOfSections ;
   uint32_t TimeDateStamp ;
   uint32_t PointerToSymbolTable ;
   uint32_t NumberOfSymbols ;
   uint16_t SizeOfOptionalHeader ;
   uint16_t Characteristics ;
};
#line 177 "/home/wheatley/newnew/temp/missidentify-1.0/main.h"
typedef struct _IMAGE_FILE_HEADER IMAGE_FILE_HEADER;
#line 188 "/home/wheatley/newnew/temp/missidentify-1.0/main.h"
struct _IMAGE_OPTIONAL_HEADER {
   uint16_t Magic ;
   unsigned char MajorLinkerVersion ;
   unsigned char MinorLinkerVersion ;
   uint32_t SizeOfCode ;
   uint32_t SizeOfInitializedData ;
   uint32_t SizeOfUninitializedData ;
   uint32_t AddressOfEntryPoint ;
   uint32_t BaseOfCode ;
   uint32_t BaseOfData ;
   uint32_t ImageBase ;
   uint32_t SectionAlignment ;
   uint32_t FileAlignment ;
   uint16_t MajorOperatingSystemVersion ;
   uint16_t MinorOperatingSystemVersion ;
   uint16_t MajorImageVersion ;
   uint16_t MinorImageVersion ;
   uint16_t MajorSubsystemVersion ;
   uint16_t MinorSubsystemVersion ;
   uint32_t Win32VersionValue ;
   uint32_t SizeOfImage ;
   uint32_t SizeOfHeaders ;
   uint32_t CheckSum ;
   uint16_t Subsystem ;
   uint16_t DllCharacteristics ;
   uint32_t SizeOfStackReserve ;
   uint32_t SizeOfStackCommit ;
   uint32_t SizeOfHeapReserve ;
   uint32_t SizeOfHeapCommit ;
   uint32_t LoaderFlags ;
   IMAGE_DATA_DIRECTORY DataDirectory[16] ;
};
#line 188 "/home/wheatley/newnew/temp/missidentify-1.0/main.h"
typedef struct _IMAGE_OPTIONAL_HEADER IMAGE_OPTIONAL_HEADER;
#line 223 "/home/wheatley/newnew/temp/missidentify-1.0/main.h"
struct _IMAGE_NT_HEADERS {
   uint32_t Signature ;
   IMAGE_FILE_HEADER FileHeader ;
   IMAGE_OPTIONAL_HEADER OptionalHeader ;
};
#line 223 "/home/wheatley/newnew/temp/missidentify-1.0/main.h"
typedef struct _IMAGE_NT_HEADERS IMAGE_NT_HEADERS;
#line 386 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 483 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 50 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memmove)(void *__dest ,
                                                                                                  void const   *__src ,
                                                                                                  size_t __n ) ;
#line 132
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 176
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 263
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strrchr)(char const   *__s ,
                                                                                                int __c )  __attribute__((__pure__)) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 275 "/home/wheatley/newnew/temp/missidentify-1.0/main.h"
int my_basename(char *s ) ;
#line 277
int my_dirname(char *c ) ;
#line 279
char *suffix(uint64_t n ) ;
#line 280
void shorten_filename(char *dest , char *src ) ;
#line 30 "/home/wheatley/newnew/temp/missidentify-1.0/helpers.c"
char *suffix(uint64_t n ) 
{ 


  {
  {
#line 34
  if (n % 10UL == 1UL) {
#line 34
    goto case_1;
  }
#line 35
  if (n % 10UL == 2UL) {
#line 35
    goto case_2;
  }
#line 36
  if (n % 10UL == 3UL) {
#line 36
    goto case_3;
  }
#line 32
  goto switch_break;
  case_1: /* CIL Label */ 
#line 34
  return ((char *)"st");
  case_2: /* CIL Label */ 
#line 35
  return ((char *)"nd");
  case_3: /* CIL Label */ 
#line 36
  return ((char *)"rd");
  switch_break: /* CIL Label */ ;
  }
#line 38
  return ((char *)"th");
}
}
#line 42 "/home/wheatley/newnew/temp/missidentify-1.0/helpers.c"
void shorten_filename(char *dest , char *src ) 
{ 
  char *basen ;
  size_t tmp ;
  size_t tmp___0 ;

  {
  {
#line 46
  tmp = strlen((char const   *)src);
  }
#line 46
  if (tmp < 33UL) {
    {
#line 48
    strncpy((char */* __restrict  */)dest, (char const   */* __restrict  */)src, (size_t )33);
    }
#line 49
    return;
  }
  {
#line 52
  basen = strdup((char const   *)src);
  }
#line 53
  if ((unsigned long )((void *)0) == (unsigned long )basen) {
#line 54
    return;
  }
  {
#line 56
  my_basename(basen);
#line 58
  tmp___0 = strlen((char const   *)basen);
  }
#line 58
  if (tmp___0 < 33UL) {
    {
#line 60
    strncpy((char */* __restrict  */)dest, (char const   */* __restrict  */)basen,
            (size_t )33);
    }
#line 61
    return;
  }
  {
#line 64
  *(basen + 30) = (char)0;
#line 65
  snprintf((char */* __restrict  */)dest, (size_t )33, (char const   */* __restrict  */)"%s...",
           basen);
#line 66
  free((void *)basen);
  }
#line 67
  return;
}
}
#line 76 "/home/wheatley/newnew/temp/missidentify-1.0/helpers.c"
void shift_string(char *fn , size_t start , size_t new_start ) 
{ 
  size_t tmp ;
  size_t tmp___0 ;

  {
  {
#line 78
  tmp = strlen((char const   *)fn);
  }
#line 78
  if (start > tmp) {
#line 79
    return;
  } else
#line 78
  if (new_start < start) {
#line 79
    return;
  }
  {
#line 81
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 81
    tmp___0 = strlen((char const   *)fn);
    }
#line 81
    if (! (new_start < tmp___0)) {
#line 81
      goto while_break;
    }
#line 83
    *(fn + start) = *(fn + new_start);
#line 84
    new_start ++;
#line 85
    start ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 88
  *(fn + start) = (char)0;
#line 89
  return;
}
}
#line 94 "/home/wheatley/newnew/temp/missidentify-1.0/helpers.c"
int find_next_comma(char *s , unsigned int start ) 
{ 
  size_t size ;
  size_t tmp ;
  unsigned int pos ;
  int in_quote ;

  {
  {
#line 96
  tmp = strlen((char const   *)s);
#line 96
  size = tmp;
#line 97
  pos = start;
#line 98
  in_quote = 0;
  }
  {
#line 100
  while (1) {
    while_continue: /* CIL Label */ ;
#line 100
    if (! ((size_t )pos < size)) {
#line 100
      goto while_break;
    }
    {
#line 103
    if ((int )*(s + pos) == 34) {
#line 103
      goto case_34;
    }
#line 106
    if ((int )*(s + pos) == 44) {
#line 106
      goto case_44;
    }
#line 102
    goto switch_break;
    case_34: /* CIL Label */ 
#line 104
    in_quote = ! in_quote;
#line 105
    goto switch_break;
    case_44: /* CIL Label */ 
#line 107
    if (in_quote) {
#line 108
      goto switch_break;
    }
#line 115
    return ((int )pos);
    switch_break: /* CIL Label */ ;
    }
#line 117
    pos ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 119
  return (-1);
}
}
#line 126 "/home/wheatley/newnew/temp/missidentify-1.0/helpers.c"
int find_comma_separated_string(char *s , unsigned int n ) 
{ 
  int start ;
  int end ;
  unsigned int count ;
  size_t tmp ;

  {
#line 128
  start = 0;
#line 129
  count = 0U;
  {
#line 130
  while (1) {
    while_continue: /* CIL Label */ ;
#line 130
    if (! (count < n)) {
#line 130
      goto while_break;
    }
    {
#line 132
    start = find_next_comma(s, (unsigned int )start);
    }
#line 132
    if (start == -1) {
#line 133
      return (1);
    }
#line 134
    count ++;
#line 136
    start ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 141
  end = find_next_comma(s, (unsigned int )start);
  }
#line 141
  if (end == -1) {
    {
#line 142
    tmp = strlen((char const   *)s);
#line 142
    end = (int )tmp;
    }
  }
#line 147
  if ((int )*(s + start) == 34) {
#line 148
    start ++;
  }
#line 149
  if ((int )*(s + (end - 1)) == 34) {
#line 150
    end --;
  }
  {
#line 152
  *(s + end) = (char)0;
#line 153
  shift_string(s, (size_t )0, (size_t )start);
  }
#line 155
  return (0);
}
}
#line 164 "/home/wheatley/newnew/temp/missidentify-1.0/helpers.c"
int my_basename(char *s ) 
{ 
  size_t len ;
  char *tmp ;
  char *tmp___0 ;

  {
  {
#line 167
  tmp___0 = strrchr((char const   *)s, '/');
#line 167
  tmp = tmp___0;
  }
#line 169
  if ((unsigned long )((void *)0) == (unsigned long )tmp) {
#line 170
    return (0);
  }
  {
#line 172
  len = strlen((char const   *)tmp);
#line 175
  memmove((void *)s, (void const   *)(tmp + 1), len);
  }
#line 177
  return (0);
}
}
#line 181 "/home/wheatley/newnew/temp/missidentify-1.0/helpers.c"
int my_dirname(char *c ) 
{ 
  char *tmp ;

  {
#line 185
  if ((unsigned long )((void *)0) == (unsigned long )c) {
#line 186
    return (1);
  }
  {
#line 190
  tmp = strrchr((char const   *)c, '/');
  }
#line 191
  if ((unsigned long )((void *)0) != (unsigned long )tmp) {
#line 192
    *(tmp + 1) = (char)0;
  } else {
#line 194
    *(c + 0) = (char)0;
  }
#line 196
  return (0);
}
}
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 147 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 342
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strstr)(char const   *__haystack ,
                                                                                                 char const   *__needle )  __attribute__((__pure__)) ;
#line 413
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
#line 134 "/usr/include/dirent.h"
extern DIR *( __attribute__((__nonnull__(1))) opendir)(char const   *__name ) ;
#line 149
extern int ( __attribute__((__nonnull__(1))) closedir)(DIR *__dirp ) ;
#line 162
extern struct dirent *( __attribute__((__nonnull__(1))) readdir)(DIR *__dirp ) ;
#line 209 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) stat)(char const   * __restrict  __file ,
                                                                                             struct stat * __restrict  __buf ) ;
#line 263
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) lstat)(char const   * __restrict  __file ,
                                                                                              struct stat * __restrict  __buf ) ;
#line 72 "/home/wheatley/newnew/temp/missidentify-1.0/main.h"
extern char *__progname ;
#line 262
int process_normal(state *s , char *fn ) ;
#line 264
int check_file(state *s , char *fn ) ;
#line 289
void print_error_unicode(state *s , char *fn , char *fmt  , ...) ;
#line 293
void internal_error(char *fmt  , ...) ;
#line 298
int have_processed_dir(char *fn ) ;
#line 299
int processing_dir(char *fn ) ;
#line 300
int done_processing_dir(char *fn ) ;
#line 21 "/home/wheatley/newnew/temp/missidentify-1.0/dig.c"
static void remove_double_slash(char *fn ) 
{ 
  size_t tsize ;
  char DOUBLE_DIR[4] ;
  char *tmp ;
  char *new ;
  size_t tmp___0 ;

  {
  {
#line 23
  tsize = sizeof(char );
#line 24
  tmp = fn;
#line 25
  snprintf((char */* __restrict  */)(DOUBLE_DIR), (size_t )3, (char const   */* __restrict  */)"%c%c",
           '/', '/');
#line 27
  new = strstr((char const   *)tmp, (char const   *)(DOUBLE_DIR));
  }
  {
#line 28
  while (1) {
    while_continue: /* CIL Label */ ;
#line 28
    if (! ((unsigned long )((void *)0) != (unsigned long )new)) {
#line 28
      goto while_break;
    }
    {
#line 41
    tmp___0 = strlen((char const   *)new);
#line 41
    memmove((void *)new, (void const   *)(new + tsize), tmp___0);
#line 47
    new = strstr((char const   *)tmp, (char const   *)(DOUBLE_DIR));
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 50
  return;
}
}
#line 53 "/home/wheatley/newnew/temp/missidentify-1.0/dig.c"
static void remove_single_dirs(char *fn ) 
{ 
  unsigned int pos ;
  unsigned int chars_found ;
  size_t sz ;
  size_t tmp ;
  size_t tsize ;

  {
  {
#line 55
  chars_found = 0U;
#line 56
  tmp = strlen((char const   *)fn);
#line 56
  sz = tmp;
#line 56
  tsize = sizeof(char );
#line 58
  pos = 0U;
  }
  {
#line 58
  while (1) {
    while_continue: /* CIL Label */ ;
#line 58
    if (! ((size_t )pos < sz)) {
#line 58
      goto while_break;
    }
#line 61
    if (pos > 0U) {
#line 61
      if ((int )*(fn + (pos - 1U)) == 47) {
#line 61
        if ((int )*(fn + pos) == 46) {
#line 61
          if ((int )*(fn + (pos + 1U)) == 0) {
#line 65
            *(fn + pos) = (char)0;
          }
        }
      }
    }
#line 67
    if ((int )*(fn + pos) == 46) {
#line 67
      if ((int )*(fn + (pos + 1U)) == 47) {
#line 69
        if (chars_found) {
#line 69
          if ((int )*(fn + (pos - 1U)) == 47) {
            {
#line 71
            memmove((void *)(fn + (size_t )pos * tsize), (void const   *)(fn + (size_t )(pos + 2U) * tsize),
                    (sz - (size_t )pos) * tsize);
#line 74
            pos --;
            }
          }
        }
      } else {
#line 79
        chars_found ++;
      }
    } else {
#line 79
      chars_found ++;
    }
#line 58
    pos ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 81
  return;
}
}
#line 84 "/home/wheatley/newnew/temp/missidentify-1.0/dig.c"
void remove_double_dirs(char *fn ) 
{ 
  size_t pos ;
  size_t next_dir ;
  size_t sz ;
  size_t tmp ;
  size_t tsize ;
  size_t tmp___0 ;

  {
  {
#line 86
  tmp = strlen((char const   *)fn);
#line 86
  sz = tmp;
#line 86
  tsize = sizeof(char );
#line 88
  pos = (size_t )0;
  }
  {
#line 88
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 88
    tmp___0 = strlen((char const   *)fn);
    }
#line 88
    if (! (pos < tmp___0)) {
#line 88
      goto while_break;
    }
#line 90
    if ((int )*(fn + pos) == 46) {
#line 90
      if ((int )*(fn + (pos + 1UL)) == 46) {
#line 92
        if (pos > 0UL) {
#line 100
          if ((int )*(fn + (pos - 1UL)) == 47) {
#line 103
            next_dir = pos + 2UL;
#line 107
            if (pos > 1UL) {
#line 108
              pos -= 2UL;
            } else {
#line 110
              pos = (size_t )0;
            }
            {
#line 112
            while (1) {
              while_continue___0: /* CIL Label */ ;
#line 112
              if ((int )*(fn + pos) != 47) {
#line 112
                if (! (pos > 0UL)) {
#line 112
                  goto while_break___0;
                }
              } else {
#line 112
                goto while_break___0;
              }
#line 113
              pos --;
            }
            while_break___0: /* CIL Label */ ;
            }
            {
#line 117
            if ((int )*(fn + next_dir) == 47) {
#line 117
              goto case_47;
            }
#line 121
            if ((int )*(fn + next_dir) == 0) {
#line 121
              goto case_0;
            }
#line 128
            goto switch_default;
            case_47: /* CIL Label */ 
            {
#line 118
            memmove((void *)(fn + pos), (void const   *)(fn + next_dir), ((sz - next_dir) + 1UL) * tsize);
            }
#line 119
            goto switch_break;
            case_0: /* CIL Label */ 
#line 123
            *(fn + (pos + 1UL)) = (char)0;
#line 124
            goto switch_break;
            switch_default: /* CIL Label */ 
#line 129
            pos = next_dir;
            switch_break: /* CIL Label */ ;
            }
          }
        } else {
          {
#line 140
          *(fn + pos) = (char )'/';
#line 141
          memmove((void *)((fn + pos) + 1), (void const   *)((fn + pos) + 3), sz - (pos + 3UL));
          }
        }
      }
    }
#line 88
    pos ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 147
  return;
}
}
#line 210 "/home/wheatley/newnew/temp/missidentify-1.0/dig.c"
static void clean_name(state *s , char *fn ) 
{ 


  {
#line 225
  if (! (s->mode & (unsigned long )(1 << 3))) {
    {
#line 227
    remove_double_slash(fn);
#line 228
    remove_single_dirs(fn);
#line 229
    remove_double_dirs(fn);
    }
  }
#line 232
  return;
}
}
#line 237 "/home/wheatley/newnew/temp/missidentify-1.0/dig.c"
static int is_special_dir(char *d ) 
{ 
  int tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;

  {
  {
#line 239
  tmp = strncmp((char const   *)d, ".", (size_t )1);
  }
#line 239
  if (tmp) {
    _L: /* CIL Label */ 
    {
#line 239
    tmp___1 = strncmp((char const   *)d, "..", (size_t )2);
    }
#line 239
    if (tmp___1) {
#line 239
      tmp___3 = 0;
    } else {
      {
#line 239
      tmp___2 = strlen((char const   *)d);
      }
#line 239
      if (tmp___2 == 2UL) {
#line 239
        tmp___3 = 1;
      } else {
#line 239
        tmp___3 = 0;
      }
    }
  } else {
    {
#line 239
    tmp___0 = strlen((char const   *)d);
    }
#line 239
    if (tmp___0 == 1UL) {
#line 239
      tmp___3 = 1;
    } else {
#line 239
      goto _L;
    }
  }
#line 239
  return (tmp___3);
}
}
#line 245 "/home/wheatley/newnew/temp/missidentify-1.0/dig.c"
static int process_dir(state *s , char *fn ) 
{ 
  int return_value ;
  char *new_file ;
  DIR *current_dir ;
  struct dirent *entry ;
  int tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  {
#line 247
  return_value = 0;
#line 254
  tmp = have_processed_dir(fn);
  }
#line 254
  if (tmp) {
    {
#line 256
    print_error_unicode(s, fn, (char *)"symlink creates cycle");
    }
#line 257
    return (0);
  }
  {
#line 260
  tmp___0 = processing_dir(fn);
  }
#line 260
  if (! tmp___0) {
    {
#line 261
    internal_error((char *)"%s: Cycle checking failed to register directory.", fn);
    }
  }
  {
#line 263
  current_dir = opendir((char const   *)fn);
  }
#line 263
  if ((unsigned long )current_dir == (unsigned long )((void *)0)) {
    {
#line 265
    tmp___1 = __errno_location();
#line 265
    tmp___2 = strerror(*tmp___1);
#line 265
    print_error_unicode(s, fn, (char *)"%s", tmp___2);
    }
#line 266
    return (0);
  }
  {
#line 269
  tmp___3 = malloc(sizeof(char ) * 4096UL);
#line 269
  new_file = (char *)tmp___3;
  }
#line 270
  if ((unsigned long )((void *)0) == (unsigned long )new_file) {
    {
#line 271
    internal_error((char *)"%s: Out of memory", __progname);
    }
  }
  {
#line 273
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 273
    entry = readdir(current_dir);
    }
#line 273
    if (! ((unsigned long )entry != (unsigned long )((void *)0))) {
#line 273
      goto while_break;
    }
    {
#line 275
    tmp___4 = is_special_dir(entry->d_name);
    }
#line 275
    if (tmp___4) {
#line 276
      goto while_continue;
    }
    {
#line 278
    snprintf((char */* __restrict  */)new_file, (size_t )4096, (char const   */* __restrict  */)"%s%c%s",
             fn, '/', entry->d_name);
#line 281
    return_value = process_normal(s, new_file);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 284
  free((void *)new_file);
#line 285
  closedir(current_dir);
#line 287
  tmp___5 = done_processing_dir(fn);
  }
#line 287
  if (! tmp___5) {
    {
#line 288
    internal_error((char *)"%s: Cycle checking failed to unregister directory.", fn);
    }
  }
#line 290
  return (return_value);
}
}
#line 294 "/home/wheatley/newnew/temp/missidentify-1.0/dig.c"
static int file_type_helper(struct stat sb ) 
{ 


  {
#line 296
  if ((sb.st_mode & 61440U) == 32768U) {
#line 297
    return (0);
  }
#line 299
  if ((sb.st_mode & 61440U) == 16384U) {
#line 300
    return (1);
  }
#line 302
  if ((sb.st_mode & 61440U) == 24576U) {
#line 303
    return (4);
  }
#line 305
  if ((sb.st_mode & 61440U) == 8192U) {
#line 306
    return (5);
  }
#line 308
  if ((sb.st_mode & 61440U) == 4096U) {
#line 309
    return (6);
  }
#line 314
  if ((sb.st_mode & 61440U) == 49152U) {
#line 315
    return (7);
  }
#line 317
  if ((sb.st_mode & 61440U) == 40960U) {
#line 318
    return (8);
  }
#line 330
  return (254);
}
}
#line 334 "/home/wheatley/newnew/temp/missidentify-1.0/dig.c"
static int file_type(state *s , char *fn ) 
{ 
  struct stat sb ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 338
  tmp___1 = lstat((char const   */* __restrict  */)fn, (struct stat */* __restrict  */)(& sb));
  }
#line 338
  if (tmp___1) {
    {
#line 340
    tmp = __errno_location();
#line 340
    tmp___0 = strerror(*tmp);
#line 340
    print_error_unicode(s, fn, (char *)"%s", tmp___0);
    }
#line 341
    return (254);
  }
  {
#line 344
  tmp___2 = file_type_helper(sb);
  }
#line 344
  return (tmp___2);
}
}
#line 348
static int should_hash_symlink(state *s , char *fn , int *link_type ) ;
#line 358 "/home/wheatley/newnew/temp/missidentify-1.0/dig.c"
static int should_hash_expert(state *s , char *fn , int type ) 
{ 
  int link_type ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 365
  if (type == 1) {
#line 365
    goto case_1;
  }
#line 378
  if (type == 0) {
#line 378
    goto case_0;
  }
#line 380
  if (type == 4) {
#line 380
    goto case_4;
  }
#line 382
  if (type == 5) {
#line 382
    goto case_5;
  }
#line 384
  if (type == 6) {
#line 384
    goto case_6;
  }
#line 386
  if (type == 7) {
#line 386
    goto case_7;
  }
#line 388
  if (type == 3) {
#line 388
    goto case_3;
  }
#line 390
  if (type == 8) {
#line 390
    goto case_8;
  }
#line 362
  goto switch_break;
  case_1: /* CIL Label */ 
#line 366
  if (s->mode & (unsigned long )(1 << 1)) {
    {
#line 367
    process_dir(s, fn);
    }
  } else {
    {
#line 370
    print_error_unicode(s, fn, (char *)"Is a directory");
    }
  }
#line 372
  return (0);
  case_0: /* CIL Label */ 
#line 378
  if (s->mode & (unsigned long )(1 << 23)) {
#line 378
    return (1);
  }
#line 378
  goto switch_break;
  case_4: /* CIL Label */ 
#line 380
  if (s->mode & (unsigned long )(1 << 26)) {
#line 380
    return (1);
  }
#line 380
  goto switch_break;
  case_5: /* CIL Label */ 
#line 382
  if (s->mode & (unsigned long )(1 << 27)) {
#line 382
    return (1);
  }
#line 382
  goto switch_break;
  case_6: /* CIL Label */ 
#line 384
  if (s->mode & (unsigned long )(1 << 28)) {
#line 384
    return (1);
  }
#line 384
  goto switch_break;
  case_7: /* CIL Label */ 
#line 386
  if (s->mode & (unsigned long )(1 << 29)) {
#line 386
    return (1);
  }
#line 386
  goto switch_break;
  case_3: /* CIL Label */ 
#line 388
  if (s->mode & (unsigned long )(1 << 25)) {
#line 388
    return (1);
  }
#line 388
  goto switch_break;
  case_8: /* CIL Label */ 
#line 399
  if (! (s->mode & (unsigned long )(1 << 30))) {
#line 400
    return (0);
  }
  {
#line 402
  tmp___0 = should_hash_symlink(s, fn, & link_type);
  }
#line 402
  if (tmp___0) {
    {
#line 403
    tmp = should_hash_expert(s, fn, link_type);
    }
#line 403
    return (tmp);
  } else {
#line 405
    return (0);
  }
  switch_break: /* CIL Label */ ;
  }
#line 408
  return (0);
}
}
#line 412 "/home/wheatley/newnew/temp/missidentify-1.0/dig.c"
static int should_hash_symlink(state *s , char *fn , int *link_type ) 
{ 
  int type ;
  struct stat sb ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 420
  tmp___1 = stat((char const   */* __restrict  */)fn, (struct stat */* __restrict  */)(& sb));
  }
#line 420
  if (tmp___1) {
    {
#line 422
    tmp = __errno_location();
#line 422
    tmp___0 = strerror(*tmp);
#line 422
    print_error_unicode(s, fn, (char *)"%s", tmp___0);
    }
#line 423
    return (0);
  }
  {
#line 426
  type = file_type_helper(sb);
  }
#line 428
  if (type == 1) {
#line 430
    if (s->mode & (unsigned long )(1 << 1)) {
      {
#line 431
      process_dir(s, fn);
      }
    } else {
      {
#line 434
      print_error_unicode(s, fn, (char *)"Is a directory");
      }
    }
#line 436
    return (0);
  }
#line 439
  if ((unsigned long )link_type != (unsigned long )((void *)0)) {
#line 440
    *link_type = type;
  }
#line 441
  return (1);
}
}
#line 448 "/home/wheatley/newnew/temp/missidentify-1.0/dig.c"
static int should_hash(state *s , char *fn ) 
{ 
  int type ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 450
  tmp = file_type(s, fn);
#line 450
  type = tmp;
  }
#line 452
  if (s->mode & (unsigned long )(1 << 31)) {
    {
#line 453
    tmp___0 = should_hash_expert(s, fn, type);
    }
#line 453
    return (tmp___0);
  }
#line 455
  if (type == 1) {
#line 457
    if (s->mode & (unsigned long )(1 << 1)) {
      {
#line 458
      process_dir(s, fn);
      }
    } else {
      {
#line 461
      print_error_unicode(s, fn, (char *)"Is a directory");
      }
    }
#line 463
    return (0);
  }
#line 467
  if (type == 8) {
    {
#line 468
    tmp___1 = should_hash_symlink(s, fn, (int *)((void *)0));
    }
#line 468
    return (tmp___1);
  }
#line 471
  if (type == 254) {
#line 472
    return (0);
  }
#line 475
  return (1);
}
}
#line 479 "/home/wheatley/newnew/temp/missidentify-1.0/dig.c"
int process_normal(state *s , char *fn ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
#line 481
  clean_name(s, fn);
#line 483
  tmp___0 = should_hash(s, fn);
  }
#line 483
  if (tmp___0) {
    {
#line 484
    tmp = check_file(s, fn);
    }
#line 484
    return (tmp);
  }
#line 486
  return (0);
}
}
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 362
extern int printf(char const   * __restrict  __format  , ...) ;
#line 150 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1), __leaf__)) atol)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 734
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) realpath)(char const   * __restrict  __name ,
                                                                                 char * __restrict  __resolved ) ;
#line 511 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) getcwd)(char *__buf ,
                                                                               size_t __size ) ;
#line 57 "/usr/include/getopt.h"
extern char *optarg ;
#line 71
extern int optind ;
#line 150
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getopt)(int ___argc ,
                                                                             char * const  *___argv ,
                                                                             char const   *__shortopts ) ;
#line 66 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 285 "/home/wheatley/newnew/temp/missidentify-1.0/main.h"
void print_status(char *fmt  , ...) ;
#line 287
void fatal_error(char *fmt  , ...) ;
#line 6 "/home/wheatley/newnew/temp/missidentify-1.0/main.c"
void usage(void) 
{ 
  char *tmp ;

  {
  {
#line 8
  print_status((char *)"%s version %s by %s", __progname, "1.0", "Jesse Kornblum");
#line 10
  print_status((char *)"Usage: %s [-Vh] [-rablv] [-s|-S len] [FILES]%s", __progname,
               "\n");
#line 12
  print_status((char *)"-r  Recursive mode. All subdirectories are traversed");
#line 13
  print_status((char *)"-q  Silent mode. No error messages are displayed");
#line 14
  print_status((char *)"-a  Display all executable files regardless of extension");
#line 15
  print_status((char *)"-b  Bare filename. No path information displayed");
#line 16
  print_status((char *)"-l  Relative paths in filenames");
#line 17
  tmp = suffix((uint64_t )10);
#line 17
  print_status((char *)"-v  Verbose mode. Displays the filename for every %lu%s file processed",
               (uint64_t )10, tmp);
#line 20
  print_status((char *)"-s|-S Display strings");
#line 22
  print_status((char *)"-V  Display version number and exit");
#line 23
  print_status((char *)"-h  Display this help message");
  }
#line 24
  return;
}
}
#line 27 "/home/wheatley/newnew/temp/missidentify-1.0/main.c"
void try_msg(void) 
{ 


  {
  {
#line 29
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Try `%s -h` for more information.%s",
          __progname, "\n");
  }
#line 30
  return;
}
}
#line 33 "/home/wheatley/newnew/temp/missidentify-1.0/main.c"
int process_cmd_line(state *s , int argc , char **argv ) 
{ 
  int i ;
  uint16_t len ;
  long tmp ;
  void *tmp___0 ;

  {
  {
#line 38
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 38
    i = getopt(argc, (char * const  *)argv, "rqas:S:lbvhV");
    }
#line 38
    if (! (i != -1)) {
#line 38
      goto while_break;
    }
    {
#line 41
    if (i == 114) {
#line 41
      goto case_114;
    }
#line 44
    if (i == 113) {
#line 44
      goto case_113;
    }
#line 47
    if (i == 97) {
#line 47
      goto case_97;
    }
#line 50
    if (i == 83) {
#line 50
      goto case_83;
    }
#line 53
    if (i == 115) {
#line 53
      goto case_115;
    }
#line 66
    if (i == 108) {
#line 66
      goto case_108;
    }
#line 69
    if (i == 98) {
#line 69
      goto case_98;
    }
#line 72
    if (i == 118) {
#line 72
      goto case_118;
    }
#line 75
    if (i == 104) {
#line 75
      goto case_104;
    }
#line 79
    if (i == 86) {
#line 79
      goto case_86;
    }
#line 83
    goto switch_default;
    case_114: /* CIL Label */ 
#line 42
    s->mode |= (unsigned long )(1 << 1);
#line 42
    goto switch_break;
    case_113: /* CIL Label */ 
#line 45
    s->mode |= (unsigned long )(1 << 5);
#line 45
    goto switch_break;
    case_97: /* CIL Label */ 
#line 48
    s->mode |= (unsigned long )(1 << 4);
#line 48
    goto switch_break;
    case_83: /* CIL Label */ 
#line 51
    s->mode |= (unsigned long )(1 << 7);
    case_115: /* CIL Label */ 
    {
#line 54
    tmp = atol((char const   *)optarg);
#line 54
    len = (uint16_t )tmp;
    }
#line 55
    if ((int )len == 0) {
      {
#line 56
      fatal_error((char *)"Invalid string length");
      }
    }
    {
#line 58
    tmp___0 = malloc(sizeof(char ) * (unsigned long )((int )len + 1));
#line 58
    s->strings = (unsigned char *)tmp___0;
    }
#line 59
    if ((unsigned long )((void *)0) == (unsigned long )s->strings) {
      {
#line 60
      fatal_error((char *)"%s: Out of memory", __progname);
      }
    }
#line 62
    s->string_len = (uint16_t )((uint8_t )len);
#line 63
    s->mode |= (unsigned long )(1 << 6);
#line 64
    goto switch_break;
    case_108: /* CIL Label */ 
#line 67
    s->mode |= (unsigned long )(1 << 3);
#line 67
    goto switch_break;
    case_98: /* CIL Label */ 
#line 70
    s->mode |= (unsigned long )(1 << 2);
#line 70
    goto switch_break;
    case_118: /* CIL Label */ 
#line 73
    s->mode |= (unsigned long )(1 << 8);
#line 73
    goto switch_break;
    case_104: /* CIL Label */ 
    {
#line 76
    usage();
#line 77
    exit(0);
    }
    case_86: /* CIL Label */ 
    {
#line 80
    printf((char const   */* __restrict  */)"%s%s", "1.0", "\n");
#line 81
    exit(0);
    }
    switch_default: /* CIL Label */ 
    {
#line 84
    try_msg();
#line 85
    exit(1);
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 89
  return (0);
}
}
#line 95 "/home/wheatley/newnew/temp/missidentify-1.0/main.c"
int initialize_state(state *s ) 
{ 
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 97
  s->mode = (uint64_t )0;
#line 99
  tmp = malloc((size_t )8192);
#line 99
  s->buf = (unsigned char *)tmp;
  }
#line 100
  if ((unsigned long )((void *)0) == (unsigned long )s->buf) {
#line 101
    return (1);
  }
  {
#line 103
  s->files_processed = (uint64_t )0;
#line 105
  tmp___0 = malloc(sizeof(char ) * (74UL * sizeof(char )));
#line 105
  s->short_name = (char *)tmp___0;
  }
#line 105
  if ((unsigned long )((void *)0) == (unsigned long )s->short_name) {
#line 105
    return (1);
  }
  {
#line 105
  memset((void *)s->short_name, 0, (74UL * sizeof(char )) * sizeof(char ));
#line 106
  tmp___1 = malloc(sizeof(char ) * (74UL * sizeof(char )));
#line 106
  s->msg = (char *)tmp___1;
  }
#line 106
  if ((unsigned long )((void *)0) == (unsigned long )s->msg) {
#line 106
    return (1);
  }
  {
#line 106
  memset((void *)s->msg, 0, (74UL * sizeof(char )) * sizeof(char ));
  }
#line 108
  return (0);
}
}
#line 128 "/home/wheatley/newnew/temp/missidentify-1.0/main.c"
static int is_absolute_path(char *fn ) 
{ 


  {
#line 130
  if ((unsigned long )((void *)0) == (unsigned long )fn) {
    {
#line 131
    internal_error((char *)"Unknown error in is_absolute_path");
    }
  }
#line 137
  return (47 == (int )*(fn + 0));
}
}
#line 142 "/home/wheatley/newnew/temp/missidentify-1.0/main.c"
void generate_filename(state *s , char *fn , char *cwd , char *input ) 
{ 
  int tmp ;

  {
#line 144
  if ((unsigned long )((void *)0) == (unsigned long )fn) {
    {
#line 145
    internal_error((char *)"Error calling generate_filename");
    }
  } else
#line 144
  if ((unsigned long )((void *)0) == (unsigned long )input) {
    {
#line 145
    internal_error((char *)"Error calling generate_filename");
    }
  }
#line 147
  if (s->mode & (unsigned long )(1 << 3)) {
    {
#line 148
    strncpy((char */* __restrict  */)fn, (char const   */* __restrict  */)input, (size_t )4096);
    }
  } else {
    {
#line 147
    tmp = is_absolute_path(input);
    }
#line 147
    if (tmp) {
      {
#line 148
      strncpy((char */* __restrict  */)fn, (char const   */* __restrict  */)input,
              (size_t )4096);
      }
    } else
#line 157
    if ((unsigned long )((void *)0) == (unsigned long )cwd) {
      {
#line 161
      realpath((char const   */* __restrict  */)input, (char */* __restrict  */)fn);
      }
    } else {
      {
#line 163
      snprintf((char */* __restrict  */)fn, (size_t )4096, (char const   */* __restrict  */)"%s%c%s",
               cwd, '/', input);
      }
    }
  }
#line 166
  return;
}
}
#line 173 "/home/wheatley/newnew/temp/missidentify-1.0/main.c"
int main(int argc , char **argv ) 
{ 
  int count ;
  int status ;
  state *s ;
  char *fn ;
  char *cwd ;
  void *tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;

  {
  {
#line 183
  tmp = malloc(sizeof(state ));
#line 183
  s = (state *)tmp;
  }
#line 185
  if ((unsigned long )((void *)0) == (unsigned long )s) {
    {
#line 186
    fatal_error((char *)"%s: Unable to allocate state variable", __progname);
    }
  }
  {
#line 188
  tmp___0 = initialize_state(s);
  }
#line 188
  if (tmp___0) {
    {
#line 189
    fatal_error((char *)"%s: Unable to initialize state variable", __progname);
    }
  }
  {
#line 191
  process_cmd_line(s, argc, argv);
#line 197
  s->argc = argc;
#line 198
  s->argv = argv;
  }
#line 204
  if (optind == argc) {
    {
#line 205
    fatal_error((char *)"Processing stdin is not supported in this version");
    }
  } else {
    {
#line 208
    tmp___1 = malloc(sizeof(char ) * 4096UL);
#line 208
    fn = (char *)tmp___1;
    }
#line 208
    if ((unsigned long )((void *)0) == (unsigned long )fn) {
#line 208
      return (1);
    }
    {
#line 208
    memset((void *)fn, 0, 4096UL * sizeof(char ));
#line 209
    tmp___2 = malloc(sizeof(char ) * 4096UL);
#line 209
    cwd = (char *)tmp___2;
    }
#line 209
    if ((unsigned long )((void *)0) == (unsigned long )cwd) {
#line 209
      return (1);
    }
    {
#line 209
    memset((void *)cwd, 0, 4096UL * sizeof(char ));
#line 211
    cwd = getcwd(cwd, (size_t )4096);
    }
#line 212
    if ((unsigned long )((void *)0) == (unsigned long )cwd) {
      {
#line 213
      tmp___3 = __errno_location();
#line 213
      tmp___4 = strerror(*tmp___3);
#line 213
      fatal_error((char *)"%s: %s", __progname, tmp___4);
      }
    }
#line 215
    count = optind;
    {
#line 217
    while (1) {
      while_continue: /* CIL Label */ ;
#line 217
      if (! (count < s->argc)) {
#line 217
        goto while_break;
      }
      {
#line 219
      generate_filename(s, fn, cwd, *(s->argv + count));
#line 224
      status = process_normal(s, fn);
#line 230
      count ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 233
    free((void *)fn);
#line 234
    free((void *)cwd);
    }
  }
#line 239
  return (0);
}
}
#line 25 "/home/wheatley/newnew/temp/missidentify-1.0/cycles.c"
dir_table *my_table  =    (dir_table *)((void *)0);
#line 43 "/home/wheatley/newnew/temp/missidentify-1.0/cycles.c"
int done_processing_dir(char *fn ) 
{ 
  dir_table *last ;
  dir_table *temp ;
  char *d_name ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 46
  tmp = malloc(sizeof(char ) * 4096UL);
#line 46
  d_name = (char *)tmp;
#line 51
  realpath((char const   */* __restrict  */)fn, (char */* __restrict  */)d_name);
  }
#line 54
  if ((unsigned long )my_table == (unsigned long )((void *)0)) {
    {
#line 56
    internal_error((char *)"Table is NULL in done_processing_dir");
#line 59
    free((void *)d_name);
    }
#line 60
    return (0);
  }
  {
#line 63
  temp = my_table;
#line 65
  tmp___0 = strncmp((char const   *)d_name, (char const   *)temp->name, (size_t )4096);
  }
#line 65
  if (! tmp___0) {
    {
#line 67
    my_table = my_table->next;
#line 68
    free((void *)temp->name);
#line 69
    free((void *)temp);
#line 70
    free((void *)d_name);
    }
#line 71
    return (1);
  }
  {
#line 74
  while (1) {
    while_continue: /* CIL Label */ ;
#line 74
    if (! ((unsigned long )temp->next != (unsigned long )((void *)0))) {
#line 74
      goto while_break;
    }
    {
#line 76
    last = temp;
#line 77
    temp = temp->next;
#line 78
    tmp___1 = strncmp((char const   *)d_name, (char const   *)temp->name, (size_t )4096);
    }
#line 78
    if (! tmp___1) {
      {
#line 80
      last->next = temp->next;
#line 81
      free((void *)temp->name);
#line 82
      free((void *)temp);
#line 83
      free((void *)d_name);
      }
#line 84
      return (1);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 88
  internal_error((char *)"%s: Directory %s not found in done_processing_dir", __progname,
                 d_name);
  }
#line 93
  return (0);
}
}
#line 99 "/home/wheatley/newnew/temp/missidentify-1.0/cycles.c"
int processing_dir(char *fn ) 
{ 
  dir_table *new ;
  dir_table *temp ;
  char *d_name ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;

  {
  {
#line 102
  tmp = malloc(sizeof(char ) * 4096UL);
#line 102
  d_name = (char *)tmp;
#line 107
  realpath((char const   */* __restrict  */)fn, (char */* __restrict  */)d_name);
  }
#line 110
  if ((unsigned long )my_table == (unsigned long )((void *)0)) {
    {
#line 112
    tmp___0 = malloc(sizeof(dir_table ));
#line 112
    my_table = (dir_table *)tmp___0;
#line 113
    my_table->name = strdup((char const   *)d_name);
#line 114
    my_table->next = (struct dir_table *)((void *)0);
#line 116
    free((void *)d_name);
    }
#line 117
    return (1);
  }
#line 120
  temp = my_table;
  {
#line 122
  while (1) {
    while_continue: /* CIL Label */ ;
#line 122
    if (! ((unsigned long )temp->next != (unsigned long )((void *)0))) {
#line 122
      goto while_break;
    }
    {
#line 125
    tmp___1 = strncmp((char const   *)temp->name, (char const   *)d_name, (size_t )4096);
    }
#line 125
    if (! tmp___1) {
      {
#line 127
      internal_error((char *)"%s: Attempt to add existing %s in processing_dir", __progname,
                     d_name);
#line 130
      free((void *)d_name);
      }
#line 131
      return (0);
    }
#line 133
    temp = temp->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 136
  tmp___2 = malloc(sizeof(dir_table ));
#line 136
  new = (dir_table *)tmp___2;
#line 137
  new->name = strdup((char const   *)d_name);
#line 138
  new->next = (struct dir_table *)((void *)0);
#line 139
  temp->next = new;
#line 141
  free((void *)d_name);
  }
#line 142
  return (1);
}
}
#line 146 "/home/wheatley/newnew/temp/missidentify-1.0/cycles.c"
int have_processed_dir(char *fn ) 
{ 
  dir_table *temp ;
  char *d_name ;
  void *tmp ;
  int tmp___0 ;

  {
#line 151
  if ((unsigned long )my_table == (unsigned long )((void *)0)) {
#line 152
    return (0);
  }
  {
#line 154
  tmp = malloc(sizeof(char ) * 4096UL);
#line 154
  d_name = (char *)tmp;
#line 158
  realpath((char const   */* __restrict  */)fn, (char */* __restrict  */)d_name);
#line 161
  temp = my_table;
  }
  {
#line 162
  while (1) {
    while_continue: /* CIL Label */ ;
#line 162
    if (! ((unsigned long )temp != (unsigned long )((void *)0))) {
#line 162
      goto while_break;
    }
    {
#line 164
    tmp___0 = strncmp((char const   *)temp->name, (char const   *)d_name, (size_t )4096);
    }
#line 164
    if (! tmp___0) {
      {
#line 166
      free((void *)d_name);
      }
#line 167
      return (1);
    }
#line 170
    temp = temp->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 173
  free((void *)d_name);
  }
#line 174
  return (0);
}
}
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
#line 371 "/usr/include/stdio.h"
extern int vfprintf(FILE * __restrict  __s , char const   * __restrict  __format ,
                    __gnuc_va_list __arg ) ;
#line 377
extern int vprintf(char const   * __restrict  __format , __gnuc_va_list __arg ) ;
#line 286 "/home/wheatley/newnew/temp/missidentify-1.0/main.h"
void print_error(state *s , char *fmt  , ...) ;
#line 288
void display_filename(FILE *out , char *fn ) ;
#line 7 "/home/wheatley/newnew/temp/missidentify-1.0/ui.c"
void print_status(char *fmt  , ...) 
{ 
  va_list ap ;

  {
  {
#line 11
  __builtin_va_start(ap, fmt);
#line 12
  vprintf((char const   */* __restrict  */)fmt, ap);
#line 13
  __builtin_va_end(ap);
#line 15
  printf((char const   */* __restrict  */)"%s", "\n");
  }
#line 16
  return;
}
}
#line 19 "/home/wheatley/newnew/temp/missidentify-1.0/ui.c"
void print_error(state *s , char *fmt  , ...) 
{ 
  va_list ap ;

  {
#line 21
  if (s->mode & (unsigned long )(1 << 5)) {
#line 22
    return;
  }
  {
#line 26
  __builtin_va_start(ap, fmt);
#line 27
  vprintf((char const   */* __restrict  */)fmt, ap);
#line 28
  __builtin_va_end(ap);
#line 30
  printf((char const   */* __restrict  */)"%s", "\n");
  }
#line 32
  return;
}
}
#line 45 "/home/wheatley/newnew/temp/missidentify-1.0/ui.c"
void print_error_unicode(state *s , char *fn , char *fmt  , ...) 
{ 
  va_list ap ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
#line 47
  if (! (s->mode & (unsigned long )(1 << 5))) {
    {
#line 49
    display_filename(stderr, fn);
#line 50
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)": ");
#line 53
    __builtin_va_start(ap, fmt);
#line 53
    tmp___1 = vfprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)fmt,
                       ap);
    }
#line 53
    if (tmp___1 < 0) {
      {
#line 53
      tmp = __errno_location();
#line 53
      tmp___0 = strerror(*tmp);
#line 53
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s",
              __progname, tmp___0);
#line 53
      exit(1);
      }
    }
    {
#line 53
    __builtin_va_end(ap);
#line 53
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s",
            "\n");
    }
  }
#line 55
  return;
}
}
#line 62 "/home/wheatley/newnew/temp/missidentify-1.0/ui.c"
void internal_error(char *fmt  , ...) 
{ 
  va_list ap ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 64
  __builtin_va_start(ap, fmt);
#line 64
  tmp___1 = vfprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)fmt,
                     ap);
  }
#line 64
  if (tmp___1 < 0) {
    {
#line 64
    tmp = __errno_location();
#line 64
    tmp___0 = strerror(*tmp);
#line 64
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s",
            __progname, tmp___0);
#line 64
    exit(1);
    }
  }
  {
#line 64
  __builtin_va_end(ap);
#line 64
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s",
          "\n");
#line 65
  print_status((char *)"%s: Internal error. Contact developer!", __progname);
#line 66
  exit(1);
  }
}
}
#line 71 "/home/wheatley/newnew/temp/missidentify-1.0/ui.c"
void fatal_error(char *fmt  , ...) 
{ 
  va_list ap ;

  {
  {
#line 73
  printf((char const   */* __restrict  */)"%s FATAL: ", __progname);
#line 76
  __builtin_va_start(ap, fmt);
#line 77
  vprintf((char const   */* __restrict  */)fmt, ap);
#line 78
  __builtin_va_end(ap);
#line 80
  printf((char const   */* __restrict  */)"%s", "\n");
#line 81
  exit(1);
  }
}
}
#line 106 "/home/wheatley/newnew/temp/missidentify-1.0/ui.c"
void display_filename(FILE *out , char *fn ) 
{ 


  {
  {
#line 108
  fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"%s", fn);
  }
#line 109
  return;
}
}
#line 169 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 237
extern int fclose(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 709
extern size_t fread(void * __restrict  __ptr , size_t __size , size_t __n , FILE * __restrict  __stream ) ;
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 538 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncasecmp)(char const   *__s1 ,
                                                                                                    char const   *__s2 ,
                                                                                                    size_t __n )  __attribute__((__pure__)) ;
#line 25 "/home/wheatley/newnew/temp/missidentify-1.0/check.c"
int is_executable_extension(char *str ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;

  {
  {
#line 29
  tmp = strncasecmp(".exe", (char const   *)str, (size_t )4);
  }
#line 29
  if (! tmp) {
#line 29
    return (1);
  }
  {
#line 30
  tmp___0 = strncasecmp(".dll", (char const   *)str, (size_t )4);
  }
#line 30
  if (! tmp___0) {
#line 30
    return (1);
  }
  {
#line 31
  tmp___1 = strncasecmp(".com", (char const   *)str, (size_t )4);
  }
#line 31
  if (! tmp___1) {
#line 31
    return (1);
  }
  {
#line 32
  tmp___2 = strncasecmp(".sys", (char const   *)str, (size_t )4);
  }
#line 32
  if (! tmp___2) {
#line 32
    return (1);
  }
  {
#line 33
  tmp___3 = strncasecmp(".cpl", (char const   *)str, (size_t )4);
  }
#line 33
  if (! tmp___3) {
#line 33
    return (1);
  }
  {
#line 34
  tmp___4 = strncasecmp(".hxs", (char const   *)str, (size_t )4);
  }
#line 34
  if (! tmp___4) {
#line 34
    return (1);
  }
  {
#line 35
  tmp___5 = strncasecmp(".hxi", (char const   *)str, (size_t )4);
  }
#line 35
  if (! tmp___5) {
#line 35
    return (1);
  }
  {
#line 36
  tmp___6 = strncasecmp(".olb", (char const   *)str, (size_t )4);
  }
#line 36
  if (! tmp___6) {
#line 36
    return (1);
  }
  {
#line 37
  tmp___7 = strncasecmp(".rll", (char const   *)str, (size_t )4);
  }
#line 37
  if (! tmp___7) {
#line 37
    return (1);
  }
  {
#line 38
  tmp___8 = strncasecmp(".tlb", (char const   *)str, (size_t )4);
  }
#line 38
  if (! tmp___8) {
#line 38
    return (1);
  }
#line 40
  return (0);
}
}
#line 46 "/home/wheatley/newnew/temp/missidentify-1.0/check.c"
int check_buffer(state *s ) 
{ 
  uint16_t *pe_offset ;
  IMAGE_NT_HEADERS *h ;
  uint32_t signature ;

  {
#line 48
  pe_offset = (uint16_t *)(s->buf + 60);
#line 56
  if ((uint64_t )*pe_offset > s->bytes_read) {
    {
#line 58
    print_error_unicode(s, s->fn, (char *)"PE header is beyond the normal range. This is suspicious");
    }
#line 59
    return (1);
  }
#line 62
  h = (IMAGE_NT_HEADERS *)(s->buf + (int )*pe_offset);
#line 63
  signature = h->Signature;
#line 69
  if (17744 != (int )((uint16_t )signature)) {
#line 70
    return (1);
  }
#line 75
  return (0);
}
}
#line 82 "/home/wheatley/newnew/temp/missidentify-1.0/check.c"
static int compute_strings(state *s ) 
{ 
  int count ;
  int recording ;
  uint16_t inpos ;
  uint16_t outpos ;
  unsigned short const   **tmp ;
  unsigned short const   **tmp___0 ;

  {
#line 84
  recording = 0;
#line 85
  inpos = (uint16_t )0;
#line 85
  outpos = (uint16_t )0;
  {
#line 87
  while (1) {
    while_continue: /* CIL Label */ ;
#line 87
    if ((int )outpos < (int )s->string_len) {
#line 87
      if (! ((uint64_t )inpos < s->bytes_read)) {
#line 87
        goto while_break;
      }
    } else {
#line 87
      goto while_break;
    }
#line 89
    if (recording) {
      {
#line 91
      tmp = __ctype_b_loc();
      }
#line 91
      if ((int const   )*(*tmp + (int )*(s->buf + inpos)) & 16384) {
#line 93
        *(s->strings + outpos) = *(s->buf + inpos);
#line 94
        outpos = (uint16_t )((int )outpos + 1);
      } else {
#line 98
        recording = 0;
#line 99
        *(s->strings + outpos) = (unsigned char )',';
#line 100
        outpos = (uint16_t )((int )outpos + 1);
      }
    } else {
#line 105
      count = 0;
      {
#line 106
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 106
        tmp___0 = __ctype_b_loc();
        }
#line 106
        if ((int const   )*(*tmp___0 + (int )*(s->buf + ((int )inpos + count))) & 16384) {
#line 106
          if (! (count < 4)) {
#line 106
            goto while_break___0;
          }
        } else {
#line 106
          goto while_break___0;
        }
#line 107
        count ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 108
      if (4 == count) {
#line 110
        recording = 1;
#line 111
        *(s->strings + outpos) = *(s->buf + inpos);
#line 112
        outpos = (uint16_t )((int )outpos + 1);
      }
    }
#line 116
    inpos = (uint16_t )((int )inpos + 1);
  }
  while_break: /* CIL Label */ ;
  }
#line 119
  return (0);
}
}
#line 123 "/home/wheatley/newnew/temp/missidentify-1.0/check.c"
static int display_result(state *s ) 
{ 


  {
#line 125
  if (! (s->mode & (unsigned long )(1 << 6))) {
    {
#line 127
    display_filename(stdout, s->fn);
#line 128
    print_status((char *)"");
    }
#line 129
    return (0);
  }
  {
#line 132
  memset((void *)s->strings, 0, (size_t )s->string_len);
#line 134
  compute_strings(s);
  }
#line 136
  if (s->mode & (unsigned long )(1 << 7)) {
    {
#line 138
    printf((char const   */* __restrict  */)"%s", s->strings);
#line 139
    display_filename(stdout, s->fn);
#line 140
    printf((char const   */* __restrict  */)"\n");
    }
  } else {
    {
#line 144
    display_filename(stdout, s->fn);
#line 145
    printf((char const   */* __restrict  */)"%s\n", s->strings);
    }
  }
#line 148
  return (0);
}
}
#line 152 "/home/wheatley/newnew/temp/missidentify-1.0/check.c"
int check_file(state *s , char *fn ) 
{ 
  char *basen ;
  int tmp ;
  size_t tmp___0 ;
  uint16_t *mz_header ;
  int tmp___1 ;

  {
#line 154
  basen = (char *)((void *)0);
#line 156
  if (s->mode & (unsigned long )(1 << 2)) {
    {
#line 158
    basen = strdup((char const   *)fn);
#line 159
    tmp = my_basename(basen);
    }
#line 159
    if (tmp) {
      {
#line 161
      free((void *)basen);
#line 162
      print_error_unicode(s, fn, (char *)"Illegal filename");
      }
#line 163
      return (1);
    }
#line 165
    s->fn = basen;
  } else {
#line 168
    s->fn = fn;
  }
#line 170
  if (s->mode & (unsigned long )(1 << 8)) {
#line 172
    (s->files_processed) ++;
#line 173
    if (0UL == s->files_processed % 10UL) {
      {
#line 175
      shorten_filename(s->short_name, fn);
#line 176
      snprintf((char */* __restrict  */)s->msg, (size_t )73, (char const   */* __restrict  */)"%s%s",
               s->short_name, "                                                                                 ");
#line 180
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\r");
#line 181
      display_filename(stderr, s->msg);
      }
    }
  }
  {
#line 186
  s->handle = fopen((char const   */* __restrict  */)fn, (char const   */* __restrict  */)"rb");
  }
#line 187
  if ((unsigned long )((void *)0) == (unsigned long )s->handle) {
#line 189
    if (s->mode & (unsigned long )(1 << 2)) {
      {
#line 190
      free((void *)basen);
      }
    }
#line 191
    return (1);
  }
  {
#line 194
  tmp___0 = strlen((char const   *)fn);
#line 194
  s->file_extension = (fn + tmp___0) - 1;
  }
  {
#line 195
  while (1) {
    while_continue: /* CIL Label */ ;
#line 195
    if ((int )*(s->file_extension + 0) != 46) {
#line 195
      if (! ((unsigned long )s->file_extension != (unsigned long )fn)) {
#line 195
        goto while_break;
      }
    } else {
#line 195
      goto while_break;
    }
#line 196
    (s->file_extension) --;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 198
  s->has_executable_extension = is_executable_extension(s->file_extension);
#line 200
  s->bytes_read = fread((void */* __restrict  */)s->buf, (size_t )1, (size_t )8192,
                        (FILE */* __restrict  */)s->handle);
#line 201
  fclose(s->handle);
  }
#line 203
  if (s->bytes_read < 2UL) {
#line 208
    if (s->mode & (unsigned long )(1 << 2)) {
      {
#line 209
      free((void *)basen);
      }
    }
#line 210
    return (1);
  }
#line 213
  mz_header = (uint16_t *)s->buf;
#line 221
  if (23117 == (int )*mz_header) {
#line 224
    if (s->bytes_read < 62UL) {
#line 225
      return (0);
    }
    {
#line 227
    tmp___1 = check_buffer(s);
    }
#line 227
    if (! tmp___1) {
#line 229
      if (s->mode & (unsigned long )(1 << 4)) {
        {
#line 231
        display_result(s);
        }
#line 232
        if (s->mode & (unsigned long )(1 << 2)) {
          {
#line 233
          free((void *)basen);
          }
        }
#line 234
        return (0);
      }
#line 237
      if (! s->has_executable_extension) {
        {
#line 238
        display_result(s);
        }
      }
    }
  }
#line 243
  if (s->mode & (unsigned long )(1 << 2)) {
    {
#line 244
    free((void *)basen);
    }
  }
#line 245
  return (0);
}
}
