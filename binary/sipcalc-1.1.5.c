/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 200 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef unsigned char u_int8_t;
#line 201 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef unsigned short u_int16_t;
#line 202 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef unsigned int u_int32_t;
#line 82 "../include/sub.h"
union __anonunion_sip_in6_u_33 {
   u_int8_t u6_addr8[16] ;
   u_int16_t u6_addr16[8] ;
   u_int32_t u6_addr32[4] ;
};
#line 82 "../include/sub.h"
struct sip_in6_addr {
   union __anonunion_sip_in6_u_33 sip_in6_u ;
};
#line 94 "../include/sub.h"
struct v4addr {
   char class ;
   char class_remark[64] ;
   char pres_bitmap[36] ;
   int n_nmaskbits ;
   u_int32_t n_cbroadcast ;
   u_int32_t n_broadcast ;
   u_int32_t n_cnaddr ;
   u_int32_t n_naddr ;
   u_int32_t n_cnmask ;
   u_int32_t n_nmask ;
   u_int32_t n_haddr ;
   u_int32_t i_broadcast ;
};
#line 116 "../include/sub.h"
struct v6addr {
   char class_remark[64] ;
   char comment[64] ;
   struct sip_in6_addr haddr ;
   int nmaskbits ;
   struct sip_in6_addr nmask ;
   struct sip_in6_addr prefix ;
   struct sip_in6_addr suffix ;
   struct sip_in6_addr broadcast ;
   int type ;
   int real_v4 ;
};
#line 129 "../include/sub.h"
struct if_info {
   char name[17] ;
   char p_v4addr[19] ;
   char p_v4nmask[16] ;
   char p_v6addr[44] ;
   char errorstr[64] ;
   char cmdstr[128] ;
   short flags ;
   short type ;
   struct v4addr v4ad ;
   struct v6addr v6ad ;
   struct if_info *next ;
};
#line 142 "../include/sub.h"
struct misc_args {
   int numnets ;
   u_int32_t splitmask ;
   struct sip_in6_addr v6splitmask ;
   int v6splitnum ;
};
#line 183 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef char *__caddr_t;
#line 49 "/usr/include/stdint.h"
typedef unsigned short uint16_t;
#line 51 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 28 "/usr/include/x86_64-linux-gnu/bits/sockaddr.h"
typedef unsigned short sa_family_t;
#line 149 "/usr/include/x86_64-linux-gnu/bits/socket.h"
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14] ;
};
#line 30 "/usr/include/netinet/in.h"
typedef uint32_t in_addr_t;
#line 31 "/usr/include/netinet/in.h"
struct in_addr {
   in_addr_t s_addr ;
};
#line 117 "/usr/include/netinet/in.h"
typedef uint16_t in_port_t;
#line 237 "/usr/include/netinet/in.h"
struct sockaddr_in {
   sa_family_t sin_family ;
   in_port_t sin_port ;
   struct in_addr sin_addr ;
   unsigned char sin_zero[((sizeof(struct sockaddr ) - sizeof(unsigned short )) - sizeof(in_port_t )) - sizeof(struct in_addr )] ;
};
#line 111 "/usr/include/net/if.h"
struct ifmap {
   unsigned long mem_start ;
   unsigned long mem_end ;
   unsigned short base_addr ;
   unsigned char irq ;
   unsigned char dma ;
   unsigned char port ;
};
#line 126 "/usr/include/net/if.h"
union __anonunion_ifr_ifrn_37 {
   char ifrn_name[16] ;
};
#line 126 "/usr/include/net/if.h"
union __anonunion_ifr_ifru_38 {
   struct sockaddr ifru_addr ;
   struct sockaddr ifru_dstaddr ;
   struct sockaddr ifru_broadaddr ;
   struct sockaddr ifru_netmask ;
   struct sockaddr ifru_hwaddr ;
   short ifru_flags ;
   int ifru_ivalue ;
   int ifru_mtu ;
   struct ifmap ifru_map ;
   char ifru_slave[16] ;
   char ifru_newname[16] ;
   __caddr_t ifru_data ;
};
#line 126 "/usr/include/net/if.h"
struct ifreq {
   union __anonunion_ifr_ifrn_37 ifr_ifrn ;
   union __anonunion_ifr_ifru_38 ifr_ifru ;
};
#line 176 "/usr/include/net/if.h"
union __anonunion_ifc_ifcu_39 {
   __caddr_t ifcu_buf ;
   struct ifreq *ifcu_req ;
};
#line 176 "/usr/include/net/if.h"
struct ifconf {
   int ifc_len ;
   union __anonunion_ifc_ifcu_39 ifc_ifcu ;
};
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 102 "/usr/include/stdio.h"
typedef __ssize_t ssize_t;
#line 104 "/usr/include/getopt.h"
struct option {
   char const   *name ;
   int has_arg ;
   int *flag ;
   int val ;
};
#line 155 "../include/sub.h"
struct argbox {
   char str[128] ;
   int type ;
   int resolv ;
   struct argbox *next ;
};
#line 162 "../include/sub.h"
struct dnsresp {
   char str[128] ;
   int type ;
   struct dnsresp *next ;
};
#line 48 "/usr/include/stdint.h"
typedef unsigned char uint8_t;
#line 189 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __socklen_t;
#line 33 "/usr/include/x86_64-linux-gnu/bits/socket.h"
typedef __socklen_t socklen_t;
#line 209 "/usr/include/netinet/in.h"
union __anonunion___in6_u_20 {
   uint8_t __u6_addr8[16] ;
   uint16_t __u6_addr16[8] ;
   uint32_t __u6_addr32[4] ;
};
#line 209 "/usr/include/netinet/in.h"
struct in6_addr {
   union __anonunion___in6_u_20 __in6_u ;
};
#line 252 "/usr/include/netinet/in.h"
struct sockaddr_in6 {
   sa_family_t sin6_family ;
   in_port_t sin6_port ;
   uint32_t sin6_flowinfo ;
   struct in6_addr sin6_addr ;
   uint32_t sin6_scope_id ;
};
#line 100 "/usr/include/netdb.h"
struct hostent {
   char *h_name ;
   char **h_aliases ;
   int h_addrtype ;
   int h_length ;
   char **h_addr_list ;
};
#line 567 "/usr/include/netdb.h"
struct addrinfo {
   int ai_flags ;
   int ai_family ;
   int ai_socktype ;
   int ai_protocol ;
   socklen_t ai_addrlen ;
   struct sockaddr *ai_addr ;
   char *ai_canonname ;
   struct addrinfo *ai_next ;
};
#line 149 "../include/sub.h"
struct ipv6_split {
   char ipv6addr[40] ;
   char ipv4addr[16] ;
   char nmask[4] ;
};
#line 362 "/usr/include/stdio.h"
extern int printf(char const   * __restrict  __format  , ...) ;
#line 386
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 137
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcat)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 459
extern  __attribute__((__nothrow__)) void ( __attribute__((__nonnull__(1), __leaf__)) bzero)(void *__s ,
                                                                                             size_t __n ) ;
#line 207 "../include/sub.h"
int out_cmdline(struct if_info *ifarg_cur , int v4args , struct misc_args m_argv4 ,
                int v6args , struct misc_args m_argv6 , int recurse , int index___0 ) ;
#line 222
char *numtoquad(u_int32_t num ) ;
#line 223
char *numtobitmap(u_int32_t num ) ;
#line 239
char *get_comp_v6(struct sip_in6_addr addr ) ;
#line 43 "/home/june/repo/benchmarks/collector/temp/sipcalc-1.1.5/src/sub-output.c"
void show_c_wildcard_info_v4(struct if_info *ifi ) 
{ 
  u_int32_t mask ;
  int bitcount ;
  int x ;
  char *tmp ;
  char *tmp___0 ;

  {
#line 50
  mask = ifi->v4ad.n_haddr ^ 4294967295U;
#line 51
  bitcount = 0;
#line 52
  x = 0;
  {
#line 52
  while (1) {
    while_continue: /* CIL Label */ ;
#line 52
    if (! (x < 32)) {
#line 52
      goto while_break;
    }
#line 53
    if ((mask >> x) & 1U) {
#line 54
      bitcount ++;
    }
#line 52
    x ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 57
  printf((char const   */* __restrict  */)"[WILDCARD]\n");
#line 58
  tmp = numtoquad(ifi->v4ad.n_haddr);
#line 58
  printf((char const   */* __restrict  */)"Wildcard\t\t- %s\n", tmp);
#line 60
  tmp___0 = numtoquad(mask);
#line 60
  printf((char const   */* __restrict  */)"Network mask\t\t- %s\n", tmp___0);
#line 62
  printf((char const   */* __restrict  */)"Network mask (bits)\t- %d\n", bitcount);
#line 64
  printf((char const   */* __restrict  */)"\n");
  }
#line 94
  return;
}
}
#line 98 "/home/june/repo/benchmarks/collector/temp/sipcalc-1.1.5/src/sub-output.c"
void show_split_networks_v4(struct if_info *ifi , u_int32_t splitmask , int v4args ,
                            struct misc_args m_argv4 ) 
{ 
  u_int32_t diff ;
  u_int32_t start ;
  u_int32_t end ;
  int x ;
  struct if_info ifi_tmp ;
  int v4args_tmp ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
#line 106
  v4args_tmp = 0;
#line 108
  if ((v4args & 64) == 64) {
    {
#line 109
    printf((char const   */* __restrict  */)"[Split network - verbose]\n");
    }
  } else {
    {
#line 111
    printf((char const   */* __restrict  */)"[Split network]\n");
    }
  }
#line 113
  if (splitmask < ifi->v4ad.n_nmask) {
    {
#line 114
    printf((char const   */* __restrict  */)"-[ERR : Oversized splitmask]\n\n");
    }
#line 115
    return;
  }
#line 117
  diff = (4294967295U - splitmask) + 1U;
#line 118
  start = ifi->v4ad.n_naddr;
#line 119
  end = (ifi->v4ad.n_naddr + diff) - 1U;
#line 121
  if ((v4args & 64) == 64) {
    {
#line 122
    memcpy((void */* __restrict  */)(& ifi_tmp), (void const   */* __restrict  */)ifi,
           sizeof(struct if_info ));
#line 123
    v4args_tmp = v4args ^ 32;
#line 124
    v4args_tmp ^= 64;
    }
#line 125
    if (! v4args_tmp) {
#line 126
      v4args_tmp = 4;
    }
#line 127
    ifi_tmp.next = (struct if_info *)((void *)0);
  }
#line 130
  x = 0;
  {
#line 131
  while (1) {
    while_continue: /* CIL Label */ ;
#line 131
    if (! (! x)) {
#line 131
      goto while_break;
    }
#line 132
    if ((v4args & 64) != 64) {
      {
#line 133
      tmp = numtoquad(start);
#line 133
      printf((char const   */* __restrict  */)"Network\t\t\t- %-15s - ", tmp);
#line 135
      tmp___0 = numtoquad(end);
#line 135
      printf((char const   */* __restrict  */)"%s\n", tmp___0);
      }
    }
#line 137
    if ((v4args & 64) == 64) {
      {
#line 138
      bzero((void *)(ifi_tmp.p_v4addr), (size_t )19);
#line 139
      bzero((void *)(ifi_tmp.p_v4nmask), (size_t )16);
#line 140
      bzero((void *)(ifi_tmp.p_v6addr), (size_t )44);
#line 141
      tmp___1 = numtoquad(start);
#line 141
      snprintf((char */* __restrict  */)(ifi_tmp.p_v4addr), (size_t )19, (char const   */* __restrict  */)"%s",
               tmp___1);
#line 142
      tmp___2 = numtoquad(splitmask);
#line 142
      snprintf((char */* __restrict  */)(ifi_tmp.p_v4nmask), (size_t )16, (char const   */* __restrict  */)"%s",
               tmp___2);
      }
    }
#line 144
    start += diff;
#line 145
    if (end == 4294967295U) {
#line 146
      x = 1;
    } else
#line 145
    if (end >= ifi->v4ad.n_broadcast) {
#line 146
      x = 1;
    }
#line 147
    end += diff;
#line 149
    if ((v4args & 64) == 64) {
      {
#line 150
      out_cmdline(& ifi_tmp, v4args_tmp, m_argv4, 0, m_argv4, 1, 0);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 153
  printf((char const   */* __restrict  */)"\n");
  }
#line 155
  return;
}
}
#line 158 "/home/june/repo/benchmarks/collector/temp/sipcalc-1.1.5/src/sub-output.c"
int show_networks_v4(struct if_info *ifi , int count___0 ) 
{ 
  u_int32_t diff ;
  u_int32_t start ;
  u_int32_t end ;
  int x ;
  char *tmp ;
  char *tmp___0 ;

  {
  {
#line 164
  printf((char const   */* __restrict  */)"[Networks]\n");
#line 165
  diff = (4294967295U - ifi->v4ad.n_nmask) + 1U;
  }
#line 166
  if (ifi->v4ad.n_nmask > 4294967040U) {
#line 166
    if (count___0 == -1) {
#line 167
      start = ifi->v4ad.n_naddr & 4294967040U;
#line 168
      end = ((ifi->v4ad.n_broadcast & 4294967040U) + diff) - 1U;
    } else {
#line 170
      start = ifi->v4ad.n_naddr;
#line 171
      end = ifi->v4ad.n_broadcast;
    }
  } else {
#line 170
    start = ifi->v4ad.n_naddr;
#line 171
    end = ifi->v4ad.n_broadcast;
  }
#line 174
  x = 0;
  {
#line 175
  while (1) {
    while_continue: /* CIL Label */ ;
#line 175
    if (! x) {
#line 175
      if (! count___0) {
#line 175
        goto while_break;
      }
    } else {
#line 175
      goto while_break;
    }
    {
#line 176
    tmp = numtoquad(start);
#line 176
    printf((char const   */* __restrict  */)"Network\t\t\t- %-15s - ", tmp);
#line 178
    tmp___0 = numtoquad(end);
#line 178
    printf((char const   */* __restrict  */)"%s", tmp___0);
    }
#line 179
    if (start == ifi->v4ad.n_naddr) {
      {
#line 180
      printf((char const   */* __restrict  */)" (current)\n");
      }
    } else {
      {
#line 182
      printf((char const   */* __restrict  */)"\n");
      }
    }
#line 183
    start += diff;
#line 184
    if (end == 4294967295U) {
#line 185
      x = 1;
    }
#line 186
    if ((end & 255U) == 255U) {
#line 186
      if (count___0 == -1) {
#line 187
        x = 1;
      }
    }
#line 188
    end += diff;
#line 189
    if (count___0 > 0) {
#line 190
      count___0 --;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 193
  printf((char const   */* __restrict  */)"\n");
  }
#line 195
  return (0);
}
}
#line 198 "/home/june/repo/benchmarks/collector/temp/sipcalc-1.1.5/src/sub-output.c"
void print_cf_info_v4(struct if_info *ifi ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 201
  printf((char const   */* __restrict  */)"[Classfull]\n");
#line 202
  tmp = numtoquad(ifi->v4ad.n_haddr);
#line 202
  printf((char const   */* __restrict  */)"Host address\t\t- %s\n", tmp);
#line 203
  printf((char const   */* __restrict  */)"Host address (decimal)\t- %u\n", ifi->v4ad.n_haddr);
#line 204
  printf((char const   */* __restrict  */)"Host address (hex)\t- %X\n", ifi->v4ad.n_haddr);
#line 205
  tmp___0 = numtoquad(ifi->v4ad.n_cnaddr);
#line 205
  printf((char const   */* __restrict  */)"Network address\t\t- %s\n", tmp___0);
#line 207
  printf((char const   */* __restrict  */)"Network class\t\t- %c%s\n", (int )ifi->v4ad.class,
         ifi->v4ad.class_remark);
#line 209
  tmp___1 = numtoquad(ifi->v4ad.n_cnmask);
#line 209
  printf((char const   */* __restrict  */)"Network mask\t\t- %s\n", tmp___1);
#line 211
  printf((char const   */* __restrict  */)"Network mask (hex)\t- %X\n", ifi->v4ad.n_cnmask);
#line 212
  tmp___2 = numtoquad(ifi->v4ad.n_cnaddr + (4294967295U - ifi->v4ad.n_cnmask));
#line 212
  printf((char const   */* __restrict  */)"Broadcast address\t- %s\n", tmp___2);
#line 215
  printf((char const   */* __restrict  */)"\n");
  }
#line 217
  return;
}
}
#line 220 "/home/june/repo/benchmarks/collector/temp/sipcalc-1.1.5/src/sub-output.c"
void print_cf_bitmap_v4(struct if_info *ifi ) 
{ 
  char *tmp ;
  char *tmp___0 ;

  {
  {
#line 223
  printf((char const   */* __restrict  */)"[Classfull bitmaps]\n");
#line 224
  tmp = numtobitmap(ifi->v4ad.n_cnaddr);
#line 224
  printf((char const   */* __restrict  */)"Network address\t\t- %s\n", tmp);
#line 226
  tmp___0 = numtobitmap(ifi->v4ad.n_cnmask);
#line 226
  printf((char const   */* __restrict  */)"Network mask\t\t- %s\n", tmp___0);
#line 228
  printf((char const   */* __restrict  */)"\n");
  }
#line 230
  return;
}
}
#line 233 "/home/june/repo/benchmarks/collector/temp/sipcalc-1.1.5/src/sub-output.c"
void print_cidr_info_v4(struct if_info *ifi ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;

  {
  {
#line 236
  printf((char const   */* __restrict  */)"[CIDR]\n");
#line 237
  tmp = numtoquad(ifi->v4ad.n_haddr);
#line 237
  printf((char const   */* __restrict  */)"Host address\t\t- %s\n", tmp);
#line 238
  printf((char const   */* __restrict  */)"Host address (decimal)\t- %u\n", ifi->v4ad.n_haddr);
#line 239
  printf((char const   */* __restrict  */)"Host address (hex)\t- %X\n", ifi->v4ad.n_haddr);
#line 240
  tmp___0 = numtoquad(ifi->v4ad.n_naddr);
#line 240
  printf((char const   */* __restrict  */)"Network address\t\t- %s\n", tmp___0);
#line 242
  tmp___1 = numtoquad(ifi->v4ad.n_nmask);
#line 242
  printf((char const   */* __restrict  */)"Network mask\t\t- %s\n", tmp___1);
#line 243
  printf((char const   */* __restrict  */)"Network mask (bits)\t- %d\n", ifi->v4ad.n_nmaskbits);
#line 244
  printf((char const   */* __restrict  */)"Network mask (hex)\t- %X\n", ifi->v4ad.n_nmask);
#line 245
  tmp___2 = numtoquad(ifi->v4ad.n_broadcast);
#line 245
  printf((char const   */* __restrict  */)"Broadcast address\t- %s\n", tmp___2);
#line 247
  tmp___3 = numtoquad(ifi->v4ad.n_nmask ^ 4294967295U);
#line 247
  printf((char const   */* __restrict  */)"Cisco wildcard\t\t- %s\n", tmp___3);
  }
#line 249
  if (! ifi->v4ad.n_nmask) {
    {
#line 250
    printf((char const   */* __restrict  */)"Addresses in network\t- %u\n", ifi->v4ad.n_broadcast - ifi->v4ad.n_naddr);
    }
  } else {
    {
#line 253
    printf((char const   */* __restrict  */)"Addresses in network\t- %u\n", (ifi->v4ad.n_broadcast - ifi->v4ad.n_naddr) + 1U);
    }
  }
  {
#line 255
  tmp___4 = numtoquad(ifi->v4ad.n_naddr);
#line 255
  printf((char const   */* __restrict  */)"Network range\t\t- %s - ", tmp___4);
#line 256
  tmp___5 = numtoquad(ifi->v4ad.n_broadcast);
#line 256
  printf((char const   */* __restrict  */)"%s\n", tmp___5);
  }
#line 257
  if (ifi->v4ad.n_naddr + 1U <= ifi->v4ad.n_broadcast - 1U) {
    {
#line 258
    tmp___6 = numtoquad(ifi->v4ad.n_naddr + 1U);
#line 258
    printf((char const   */* __restrict  */)"Usable range\t\t- %s - ", tmp___6);
#line 260
    tmp___7 = numtoquad(ifi->v4ad.n_broadcast - 1U);
#line 260
    printf((char const   */* __restrict  */)"%s\n", tmp___7);
    }
  }
  {
#line 262
  printf((char const   */* __restrict  */)"\n");
  }
#line 264
  return;
}
}
#line 267 "/home/june/repo/benchmarks/collector/temp/sipcalc-1.1.5/src/sub-output.c"
void print_cidr_bitmap_v4(struct if_info *ifi ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;

  {
  {
#line 270
  printf((char const   */* __restrict  */)"[CIDR bitmaps]\n");
#line 271
  tmp = numtobitmap(ifi->v4ad.n_haddr);
#line 271
  printf((char const   */* __restrict  */)"Host address\t\t- %s\n", tmp);
#line 273
  tmp___0 = numtobitmap(ifi->v4ad.n_naddr);
#line 273
  printf((char const   */* __restrict  */)"Network address\t\t- %s\n", tmp___0);
#line 275
  tmp___1 = numtobitmap(ifi->v4ad.n_nmask);
#line 275
  printf((char const   */* __restrict  */)"Network mask\t\t- %s\n", tmp___1);
#line 277
  tmp___2 = numtobitmap(ifi->v4ad.n_broadcast);
#line 277
  printf((char const   */* __restrict  */)"Broadcast address\t- %s\n", tmp___2);
#line 279
  tmp___3 = numtobitmap(ifi->v4ad.n_nmask ^ 4294967295U);
#line 279
  printf((char const   */* __restrict  */)"Cisco wildcard\t\t- %s\n", tmp___3);
#line 281
  tmp___4 = numtobitmap(ifi->v4ad.n_naddr);
#line 281
  printf((char const   */* __restrict  */)"Network range\t\t- %s -\n", tmp___4);
#line 283
  tmp___5 = numtobitmap(ifi->v4ad.n_broadcast);
#line 283
  printf((char const   */* __restrict  */)"\t\t\t  %s\n", tmp___5);
  }
#line 285
  if (ifi->v4ad.n_naddr + 1U <= ifi->v4ad.n_broadcast - 1U) {
    {
#line 286
    tmp___6 = numtobitmap(ifi->v4ad.n_naddr + 1U);
#line 286
    printf((char const   */* __restrict  */)"Usable range\t\t- %s -\n", tmp___6);
#line 288
    tmp___7 = numtobitmap(ifi->v4ad.n_broadcast - 1U);
#line 288
    printf((char const   */* __restrict  */)"\t\t\t  %s\n", tmp___7);
    }
  }
  {
#line 291
  printf((char const   */* __restrict  */)"\n");
  }
#line 293
  return;
}
}
#line 296 "/home/june/repo/benchmarks/collector/temp/sipcalc-1.1.5/src/sub-output.c"
void print_comp_v6(struct sip_in6_addr addr ) 
{ 
  int x ;
  int y ;
  int z ;
  int start ;
  int num ;

  {
#line 302
  start = -1;
#line 303
  num = 0;
#line 304
  y = 0;
#line 305
  z = 0;
#line 306
  x = 0;
  {
#line 306
  while (1) {
    while_continue: /* CIL Label */ ;
#line 306
    if (! (x < 8)) {
#line 306
      goto while_break;
    }
#line 307
    if ((int )addr.sip_in6_u.u6_addr16[x] == 0) {
#line 308
      if (y == -1) {
#line 309
        y = x;
      }
#line 310
      z ++;
    } else {
#line 312
      if (z > num) {
#line 312
        if (z > 1) {
#line 313
          start = y;
#line 314
          num = z;
        }
      }
#line 316
      y = -1;
#line 317
      z = 0;
    }
#line 306
    x ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 321
  if (z > num) {
#line 321
    if (z > 1) {
#line 322
      start = y;
#line 323
      num = z;
    }
  }
#line 326
  x = 0;
  {
#line 326
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 326
    if (! (x < 8)) {
#line 326
      goto while_break___0;
    }
#line 327
    if (x == start) {
#line 328
      if (! x) {
        {
#line 329
        printf((char const   */* __restrict  */)":");
        }
      }
      {
#line 330
      printf((char const   */* __restrict  */)":");
#line 331
      x += num - 1;
      }
    } else {
      {
#line 333
      printf((char const   */* __restrict  */)"%x", (int )addr.sip_in6_u.u6_addr16[x]);
      }
#line 334
      if (x != 7) {
        {
#line 335
        printf((char const   */* __restrict  */)":");
        }
      }
    }
#line 326
    x ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 339
  return;
}
}
#line 342 "/home/june/repo/benchmarks/collector/temp/sipcalc-1.1.5/src/sub-output.c"
void print_exp_v4inv6(struct sip_in6_addr addr ) 
{ 
  unsigned char num ;

  {
  {
#line 347
  printf((char const   */* __restrict  */)"%04x:%04x:%04x:%04x:%04x:%04x:", (int )addr.sip_in6_u.u6_addr16[0],
         (int )addr.sip_in6_u.u6_addr16[1], (int )addr.sip_in6_u.u6_addr16[2], (int )addr.sip_in6_u.u6_addr16[3],
         (int )addr.sip_in6_u.u6_addr16[4], (int )addr.sip_in6_u.u6_addr16[5]);
#line 353
  num = (unsigned char )(((int )addr.sip_in6_u.u6_addr16[6] >> 8) & 255);
#line 354
  printf((char const   */* __restrict  */)"%d.", (int )num);
#line 355
  num = (unsigned char )((int )addr.sip_in6_u.u6_addr16[6] & 255);
#line 356
  printf((char const   */* __restrict  */)"%d.", (int )num);
#line 357
  num = (unsigned char )(((int )addr.sip_in6_u.u6_addr16[7] >> 8) & 255);
#line 358
  printf((char const   */* __restrict  */)"%d.", (int )num);
#line 359
  num = (unsigned char )((int )addr.sip_in6_u.u6_addr16[7] & 255);
#line 360
  printf((char const   */* __restrict  */)"%d", (int )num);
  }
#line 362
  return;
}
}
#line 365 "/home/june/repo/benchmarks/collector/temp/sipcalc-1.1.5/src/sub-output.c"
void print_comp_v4inv6(struct sip_in6_addr addr ) 
{ 
  unsigned char v4num ;
  int x ;
  int y ;
  int z ;
  int start ;
  int num ;

  {
#line 372
  start = -1;
#line 373
  num = 0;
#line 374
  y = 0;
#line 375
  z = 0;
#line 376
  x = 0;
  {
#line 376
  while (1) {
    while_continue: /* CIL Label */ ;
#line 376
    if (! (x < 6)) {
#line 376
      goto while_break;
    }
#line 377
    if ((int )addr.sip_in6_u.u6_addr16[x] == 0) {
#line 378
      if (y == -1) {
#line 379
        y = x;
      }
#line 380
      z ++;
    } else {
#line 382
      if (z > num) {
#line 382
        if (z > 1) {
#line 383
          start = y;
#line 384
          num = z;
        }
      }
#line 386
      y = -1;
#line 387
      z = 0;
    }
#line 376
    x ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 391
  if (z > num) {
#line 391
    if (z > 1) {
#line 392
      start = y;
#line 393
      num = z;
    }
  }
#line 396
  x = 0;
  {
#line 396
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 396
    if (! (x < 6)) {
#line 396
      goto while_break___0;
    }
#line 397
    if (x == start) {
#line 398
      if (! x) {
        {
#line 399
        printf((char const   */* __restrict  */)":");
        }
      }
      {
#line 400
      printf((char const   */* __restrict  */)":");
#line 401
      x += num - 1;
      }
    } else {
      {
#line 403
      printf((char const   */* __restrict  */)"%x:", (int )addr.sip_in6_u.u6_addr16[x]);
      }
    }
#line 396
    x ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 407
  v4num = (unsigned char )(((int )addr.sip_in6_u.u6_addr16[6] >> 8) & 255);
#line 408
  printf((char const   */* __restrict  */)"%d.", (int )v4num);
#line 409
  v4num = (unsigned char )((int )addr.sip_in6_u.u6_addr16[6] & 255);
#line 410
  printf((char const   */* __restrict  */)"%d.", (int )v4num);
#line 411
  v4num = (unsigned char )(((int )addr.sip_in6_u.u6_addr16[7] >> 8) & 255);
#line 412
  printf((char const   */* __restrict  */)"%d.", (int )v4num);
#line 413
  v4num = (unsigned char )((int )addr.sip_in6_u.u6_addr16[7] & 255);
#line 414
  printf((char const   */* __restrict  */)"%d", (int )v4num);
  }
#line 416
  return;
}
}
#line 419 "/home/june/repo/benchmarks/collector/temp/sipcalc-1.1.5/src/sub-output.c"
void print_exp_v6(struct sip_in6_addr addr ) 
{ 


  {
  {
#line 422
  printf((char const   */* __restrict  */)"%04x:%04x:%04x:%04x:%04x:%04x:%04x:%04x",
         (int )addr.sip_in6_u.u6_addr16[0], (int )addr.sip_in6_u.u6_addr16[1], (int )addr.sip_in6_u.u6_addr16[2],
         (int )addr.sip_in6_u.u6_addr16[3], (int )addr.sip_in6_u.u6_addr16[4], (int )addr.sip_in6_u.u6_addr16[5],
         (int )addr.sip_in6_u.u6_addr16[6], (int )addr.sip_in6_u.u6_addr16[7]);
  }
#line 430
  return;
}
}
#line 432 "/home/june/repo/benchmarks/collector/temp/sipcalc-1.1.5/src/sub-output.c"
void print_mixed_v6(struct sip_in6_addr addr ) 
{ 


  {
  {
#line 435
  printf((char const   */* __restrict  */)"%x:%x:%x:%x:%x:%x:%x:%x", (int )addr.sip_in6_u.u6_addr16[0],
         (int )addr.sip_in6_u.u6_addr16[1], (int )addr.sip_in6_u.u6_addr16[2], (int )addr.sip_in6_u.u6_addr16[3],
         (int )addr.sip_in6_u.u6_addr16[4], (int )addr.sip_in6_u.u6_addr16[5], (int )addr.sip_in6_u.u6_addr16[6],
         (int )addr.sip_in6_u.u6_addr16[7]);
  }
#line 443
  return;
}
}
#line 445 "/home/june/repo/benchmarks/collector/temp/sipcalc-1.1.5/src/sub-output.c"
void print_revdns_v6(struct sip_in6_addr addr ) 
{ 
  char inbuf[40] ;
  char outbuf[256] ;
  int x ;
  int y ;
  size_t tmp ;

  {
  {
#line 450
  bzero((void *)(inbuf), (size_t )40);
#line 451
  bzero((void *)(outbuf), (size_t )256);
#line 453
  snprintf((char */* __restrict  */)(inbuf), (size_t )39, (char const   */* __restrict  */)"%04x%04x%04x%04x%04x%04x%04x%04x",
           (int )addr.sip_in6_u.u6_addr16[0], (int )addr.sip_in6_u.u6_addr16[1], (int )addr.sip_in6_u.u6_addr16[2],
           (int )addr.sip_in6_u.u6_addr16[3], (int )addr.sip_in6_u.u6_addr16[4], (int )addr.sip_in6_u.u6_addr16[5],
           (int )addr.sip_in6_u.u6_addr16[6], (int )addr.sip_in6_u.u6_addr16[7]);
#line 463
  y = 0;
#line 464
  tmp = strlen((char const   *)(inbuf));
#line 464
  x = (int )(tmp - 1UL);
  }
  {
#line 464
  while (1) {
    while_continue: /* CIL Label */ ;
#line 464
    if (! (x >= 0)) {
#line 464
      goto while_break;
    }
#line 465
    outbuf[y] = inbuf[x];
#line 466
    outbuf[y + 1] = (char )'.';
#line 467
    y += 2;
#line 464
    x --;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 470
  strcat((char */* __restrict  */)(outbuf), (char const   */* __restrict  */)"ip6.arpa.");
#line 472
  printf((char const   */* __restrict  */)"%s", outbuf);
  }
#line 473
  return;
}
}
#line 475 "/home/june/repo/benchmarks/collector/temp/sipcalc-1.1.5/src/sub-output.c"
void print_rev_v6(struct if_info *ifi ) 
{ 


  {
  {
#line 478
  printf((char const   */* __restrict  */)"[IPV6 DNS]\n");
#line 479
  printf((char const   */* __restrict  */)"Reverse DNS (ip6.arpa)\t-\n");
#line 480
  print_revdns_v6(ifi->v6ad.haddr);
#line 481
  printf((char const   */* __restrict  */)"\n");
#line 483
  printf((char const   */* __restrict  */)"\n");
  }
#line 484
  return;
}
}
#line 486 "/home/june/repo/benchmarks/collector/temp/sipcalc-1.1.5/src/sub-output.c"
void print_v6(struct if_info *ifi ) 
{ 


  {
  {
#line 489
  printf((char const   */* __restrict  */)"[IPV6 INFO]\n");
#line 490
  printf((char const   */* __restrict  */)"Expanded Address\t- ");
#line 491
  print_exp_v6(ifi->v6ad.haddr);
#line 492
  printf((char const   */* __restrict  */)"\n");
#line 493
  printf((char const   */* __restrict  */)"Compressed address\t- ");
#line 494
  print_comp_v6(ifi->v6ad.haddr);
#line 495
  printf((char const   */* __restrict  */)"\n");
#line 496
  printf((char const   */* __restrict  */)"Subnet prefix (masked)\t- ");
#line 497
  print_mixed_v6(ifi->v6ad.prefix);
#line 498
  printf((char const   */* __restrict  */)"/%d\n", ifi->v6ad.nmaskbits);
#line 499
  printf((char const   */* __restrict  */)"Address ID (masked)\t- ");
#line 500
  print_mixed_v6(ifi->v6ad.suffix);
#line 501
  printf((char const   */* __restrict  */)"/%d\n", ifi->v6ad.nmaskbits);
#line 502
  printf((char const   */* __restrict  */)"Prefix address\t\t- ");
#line 503
  print_mixed_v6(ifi->v6ad.nmask);
#line 504
  printf((char const   */* __restrict  */)"\n");
#line 505
  printf((char const   */* __restrict  */)"Prefix length\t\t- %d\n", ifi->v6ad.nmaskbits);
#line 506
  printf((char const   */* __restrict  */)"Address type\t\t- %s\n", ifi->v6ad.class_remark);
  }
#line 507
  if (ifi->v6ad.comment[0]) {
    {
#line 508
    printf((char const   */* __restrict  */)"Comment\t\t\t- %s\n", ifi->v6ad.comment);
    }
  }
  {
#line 510
  printf((char const   */* __restrict  */)"Network range\t\t- ");
#line 511
  print_exp_v6(ifi->v6ad.prefix);
#line 512
  printf((char const   */* __restrict  */)" -\n\t\t\t  ");
#line 513
  print_exp_v6(ifi->v6ad.broadcast);
#line 514
  printf((char const   */* __restrict  */)"\n");
#line 516
  printf((char const   */* __restrict  */)"\n");
  }
#line 518
  return;
}
}
#line 521 "/home/june/repo/benchmarks/collector/temp/sipcalc-1.1.5/src/sub-output.c"
void print_v4inv6(struct if_info *ifi ) 
{ 


  {
  {
#line 524
  printf((char const   */* __restrict  */)"[V4INV6]\n");
  }
#line 525
  if (ifi->v6ad.type == 2) {
#line 525
    if (! ifi->v6ad.real_v4) {
      {
#line 526
      printf((char const   */* __restrict  */)"-[INFO : Address was submitted as an IPv4-compatible IPv6 address]\n");
#line 528
      printf((char const   */* __restrict  */)"-[INFO : The Address does not qualify as this as per the guidelines]\n");
#line 530
      printf((char const   */* __restrict  */)"-[INFO : in RFC2373]\n\n");
      }
    }
  }
  {
#line 533
  printf((char const   */* __restrict  */)"Expanded v4inv6 address\t- ");
#line 534
  print_exp_v4inv6(ifi->v6ad.haddr);
#line 535
  printf((char const   */* __restrict  */)"\n");
#line 536
  printf((char const   */* __restrict  */)"Compr. v4inv6 address\t- ");
#line 537
  print_comp_v4inv6(ifi->v6ad.haddr);
#line 538
  printf((char const   */* __restrict  */)"\n");
  }
#line 539
  if (ifi->v6ad.type == 2) {
#line 539
    if (ifi->v6ad.real_v4 == 1) {
      {
#line 540
      printf((char const   */* __restrict  */)"Comment\t\t\t- IPv4-compatible IPv6 address\n");
      }
    }
  }
#line 542
  if (ifi->v6ad.type == 2) {
#line 542
    if (ifi->v6ad.real_v4 == 2) {
      {
#line 543
      printf((char const   */* __restrict  */)"Comment\t\t\t- IPv4-mapped IPv6 address\n");
      }
    }
  }
  {
#line 546
  printf((char const   */* __restrict  */)"\n");
  }
#line 548
  return;
}
}
#line 551 "/home/june/repo/benchmarks/collector/temp/sipcalc-1.1.5/src/sub-output.c"
int v6plus(struct sip_in6_addr *a , struct sip_in6_addr *b ) 
{ 
  int x ;
  int y ;
  int z ;

  {
#line 556
  x = 7;
  {
#line 556
  while (1) {
    while_continue: /* CIL Label */ ;
#line 556
    if (! (x >= 0)) {
#line 556
      goto while_break;
    }
#line 557
    if ((int )a->sip_in6_u.u6_addr16[x] + (int )b->sip_in6_u.u6_addr16[x] > 65535) {
#line 558
      y = x - 1;
#line 559
      z = 0;
      {
#line 560
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 560
        if (y >= 0) {
#line 560
          if (! (! z)) {
#line 560
            goto while_break___0;
          }
        } else {
#line 560
          goto while_break___0;
        }
#line 561
        z = 1;
#line 562
        if ((int )a->sip_in6_u.u6_addr16[y] + 1 > 65535) {
#line 563
          a->sip_in6_u.u6_addr16[y] = (u_int16_t )0;
#line 564
          z = 0;
        } else {
#line 567
          a->sip_in6_u.u6_addr16[y] = (u_int16_t )((int )a->sip_in6_u.u6_addr16[y] + 1);
        }
#line 570
        y --;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 573
      a->sip_in6_u.u6_addr16[x] = (u_int16_t )(((int )a->sip_in6_u.u6_addr16[x] + (int )b->sip_in6_u.u6_addr16[x]) - 65536);
    } else {
#line 576
      a->sip_in6_u.u6_addr16[x] = (u_int16_t )((int )a->sip_in6_u.u6_addr16[x] + (int )b->sip_in6_u.u6_addr16[x]);
    }
#line 556
    x --;
  }
  while_break: /* CIL Label */ ;
  }
#line 580
  return (0);
}
}
#line 583 "/home/june/repo/benchmarks/collector/temp/sipcalc-1.1.5/src/sub-output.c"
void show_split_networks_v6(struct if_info *ifi , struct sip_in6_addr splitmask ,
                            int v6args , struct misc_args m_argv6 ) 
{ 
  struct sip_in6_addr sdiff ;
  struct sip_in6_addr ediff ;
  struct sip_in6_addr start ;
  struct sip_in6_addr end ;
  struct sip_in6_addr tmpaddr ;
  int x ;
  int y ;
  int z ;
  struct if_info ifi_tmp ;
  int v6args_tmp ;
  char *tmp ;

  {
#line 591
  v6args_tmp = 0;
#line 593
  if ((v6args & 16) == 16) {
    {
#line 594
    printf((char const   */* __restrict  */)"[Split network - verbose]\n");
    }
  } else {
    {
#line 596
    printf((char const   */* __restrict  */)"[Split network]\n");
    }
  }
#line 598
  x = 0;
#line 599
  y = 0;
  {
#line 600
  while (1) {
    while_continue: /* CIL Label */ ;
#line 601
    if ((int )splitmask.sip_in6_u.u6_addr16[x] > (int )ifi->v6ad.nmask.sip_in6_u.u6_addr16[x]) {
#line 602
      y = 1;
    }
#line 603
    if ((int )ifi->v6ad.nmask.sip_in6_u.u6_addr16[x] > (int )splitmask.sip_in6_u.u6_addr16[x]) {
#line 604
      y = 2;
    }
#line 605
    x ++;
#line 600
    if (x < 8) {
#line 600
      if (! (! y)) {
#line 600
        goto while_break;
      }
    } else {
#line 600
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 607
  if (y == 2) {
    {
#line 608
    printf((char const   */* __restrict  */)"-[ERR : Oversized splitmask]\n\n");
    }
#line 609
    return;
  }
#line 612
  x = 0;
  {
#line 612
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 612
    if (! (x < 8)) {
#line 612
      goto while_break___0;
    }
#line 613
    if (splitmask.sip_in6_u.u6_addr16) {
#line 614
      sdiff.sip_in6_u.u6_addr16[x] = (u_int16_t )(4294967295U - (unsigned int )splitmask.sip_in6_u.u6_addr16[x]);
    }
#line 615
    start.sip_in6_u.u6_addr16[x] = ifi->v6ad.prefix.sip_in6_u.u6_addr16[x];
#line 616
    end.sip_in6_u.u6_addr16[x] = (u_int16_t )((int )ifi->v6ad.prefix.sip_in6_u.u6_addr16[x] + (int )sdiff.sip_in6_u.u6_addr16[x]);
#line 618
    ediff.sip_in6_u.u6_addr16[x] = sdiff.sip_in6_u.u6_addr16[x];
#line 612
    x ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 620
  x = 0;
  {
#line 620
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 620
    if (! (x < 8)) {
#line 620
      goto while_break___1;
    }
#line 621
    tmpaddr.sip_in6_u.u6_addr16[x] = (u_int16_t )0;
#line 620
    x ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 622
  tmpaddr.sip_in6_u.u6_addr16[7] = (u_int16_t )1;
#line 623
  v6plus(& sdiff, & tmpaddr);
  }
#line 625
  if ((v6args & 16) == 16) {
    {
#line 626
    memcpy((void */* __restrict  */)(& ifi_tmp), (void const   */* __restrict  */)ifi,
           sizeof(struct if_info ));
#line 627
    v6args_tmp = v6args ^ 4;
#line 628
    v6args_tmp ^= 16;
    }
#line 629
    if (! v6args_tmp) {
#line 630
      v6args_tmp = 1;
    }
#line 631
    ifi_tmp.next = (struct if_info *)((void *)0);
  }
#line 634
  x = 0;
  {
#line 635
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 635
    if (! (! x)) {
#line 635
      goto while_break___2;
    }
#line 636
    if ((v6args & 16) != 16) {
      {
#line 637
      printf((char const   */* __restrict  */)"Network\t\t\t- ");
#line 638
      print_exp_v6(start);
#line 639
      printf((char const   */* __restrict  */)" -\n\t\t\t  ");
#line 640
      print_exp_v6(end);
#line 641
      printf((char const   */* __restrict  */)"\n");
      }
    }
#line 644
    if ((v6args & 16) == 16) {
      {
#line 645
      bzero((void *)(ifi_tmp.p_v4addr), (size_t )19);
#line 646
      bzero((void *)(ifi_tmp.p_v4nmask), (size_t )16);
#line 647
      bzero((void *)(ifi_tmp.p_v6addr), (size_t )44);
#line 648
      tmp = get_comp_v6(start);
#line 648
      snprintf((char */* __restrict  */)(ifi_tmp.p_v6addr), (size_t )44, (char const   */* __restrict  */)"%s/%d",
               tmp, m_argv6.v6splitnum);
      }
    }
    {
#line 651
    v6plus(& start, & sdiff);
#line 653
    y = 0;
#line 654
    z = 0;
    }
    {
#line 654
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 654
      if (! (z < 8)) {
#line 654
        goto while_break___3;
      }
#line 655
      if ((int )end.sip_in6_u.u6_addr16[z] != 65535) {
#line 656
        y = 1;
      }
#line 654
      z ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 657
    if (! y) {
#line 658
      x = 1;
    }
#line 660
    y = 0;
#line 661
    z = 0;
    {
#line 662
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 663
      if ((int )end.sip_in6_u.u6_addr16[z] > (int )ifi->v6ad.broadcast.sip_in6_u.u6_addr16[z]) {
#line 665
        y = 1;
      }
#line 666
      if ((int )ifi->v6ad.broadcast.sip_in6_u.u6_addr16[z] > (int )end.sip_in6_u.u6_addr16[z]) {
#line 668
        y = 2;
      }
#line 669
      z ++;
#line 662
      if (z < 8) {
#line 662
        if (! (! y)) {
#line 662
          goto while_break___4;
        }
      } else {
#line 662
        goto while_break___4;
      }
    }
    while_break___4: /* CIL Label */ ;
    }
#line 672
    if (! y) {
#line 673
      x = 1;
    } else
#line 672
    if (y == 1) {
#line 673
      x = 1;
    }
#line 675
    z = 0;
    {
#line 675
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 675
      if (! (z < 8)) {
#line 675
        goto while_break___5;
      }
#line 676
      end.sip_in6_u.u6_addr16[z] = (u_int16_t )0;
#line 675
      z ++;
    }
    while_break___5: /* CIL Label */ ;
    }
    {
#line 678
    v6plus(& end, & start);
#line 679
    v6plus(& end, & ediff);
    }
#line 681
    if ((v6args & 16) == 16) {
      {
#line 682
      out_cmdline(& ifi_tmp, v6args_tmp, m_argv6, v6args_tmp, m_argv6, 1, 0);
      }
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 685
  printf((char const   */* __restrict  */)"\n");
  }
#line 687
  return;
}
}
#line 691 "/home/june/repo/benchmarks/collector/temp/sipcalc-1.1.5/src/sub-output.c"
void print_help(void) 
{ 


  {
  {
#line 694
  printf((char const   */* __restrict  */)"%s %s\n\n", "sipcalc", "1.1.5");
#line 695
  printf((char const   */* __restrict  */)"Usage: %s [OPTIONS]... <[ADDRESS]... [INTERFACE]... | [-]>\n\n",
         "sipcalc");
#line 698
  printf((char const   */* __restrict  */)"Global options:\n");
#line 699
  printf((char const   */* __restrict  */)"  -a, --all\t\t\tAll possible information.\n");
#line 700
  printf((char const   */* __restrict  */)"  -d, --resolve\t\t\tEnable name resolution.\n");
#line 701
  printf((char const   */* __restrict  */)"  -h, --help\t\t\tDisplay this help.\n");
#line 702
  printf((char const   */* __restrict  */)"  -I, --addr-int=INT\t\tAdded an interface.\n");
#line 703
  printf((char const   */* __restrict  */)"  -n, --subnets=NUM\t\tDisplay NUM extra subnets (starting from\n");
#line 705
  printf((char const   */* __restrict  */)"\t\t\t\tthe current subnet). Will display all subnets\n");
#line 706
  printf((char const   */* __restrict  */)"\t\t\t\tin the current /24 if NUM is 0.\n");
#line 707
  printf((char const   */* __restrict  */)"  -u, --split-verbose\t\tVerbose split.\n");
#line 708
  printf((char const   */* __restrict  */)"  -v, --version\t\t\tVersion information.\n");
#line 709
  printf((char const   */* __restrict  */)"  -4, --addr-ipv4=ADDR\t\tAdd an ipv4 address.\n");
#line 710
  printf((char const   */* __restrict  */)"  -6, --addr-ipv6=ADDR\t\tAdd an ipv6 address.\n");
#line 711
  printf((char const   */* __restrict  */)"\n");
#line 712
  printf((char const   */* __restrict  */)"IPv4 options:\n");
#line 713
  printf((char const   */* __restrict  */)"  -b, --cidr-bitmap\t\tCIDR bitmap.\n");
#line 714
  printf((char const   */* __restrict  */)"  -c, --classfull-addr\t\tClassfull address information.\n");
#line 715
  printf((char const   */* __restrict  */)"  -i, --cidr-addr\t\tCIDR address information. (default)\n");
#line 716
  printf((char const   */* __restrict  */)"  -s, --v4split=MASK\t\tSplit the current network into subnets\n");
#line 718
  printf((char const   */* __restrict  */)"\t\t\t\tof MASK size.\n");
#line 719
  printf((char const   */* __restrict  */)"  -w, --wildcard\t\tDisplay information for a wildcard\n");
#line 720
  printf((char const   */* __restrict  */)"\t\t\t\t(inverse mask).\n");
#line 721
  printf((char const   */* __restrict  */)"  -x, --classfull-bitmap\tClassfull bitmap.\n");
#line 722
  printf((char const   */* __restrict  */)"\n");
#line 723
  printf((char const   */* __restrict  */)"IPv6 options:\n");
#line 724
  printf((char const   */* __restrict  */)"  -e, --v4inv6\t\t\tIPv4 compatible IPv6 information.\n");
#line 725
  printf((char const   */* __restrict  */)"  -r, --v6rev\t\t\tIPv6 reverse DNS output.\n");
#line 726
  printf((char const   */* __restrict  */)"  -S, --v6split=MASK\t\tSplit the current network into subnets\n\t\t\t\tof MASK size.\n");
#line 728
  printf((char const   */* __restrict  */)"  -t, --v6-standard\t\tStandard IPv6. (default)\n");
#line 729
  printf((char const   */* __restrict  */)"\n");
#line 730
  printf((char const   */* __restrict  */)"Address must be in the \"standard\" dotted quad format.\n");
#line 731
  printf((char const   */* __restrict  */)"Netmask can be given in three different ways:\n");
#line 732
  printf((char const   */* __restrict  */)" - Number of bits    [/nn]\n");
#line 733
  printf((char const   */* __restrict  */)" - Dotted quad       [nnn.nnn.nnn.nnn]\n");
#line 734
  printf((char const   */* __restrict  */)" - Hex               [0xnnnnnnnn | nnnnnnnn]\n");
#line 735
  printf((char const   */* __restrict  */)"\n");
#line 736
  printf((char const   */* __restrict  */)"Interface must be a valid network interface on the system.\n");
#line 737
  printf((char const   */* __restrict  */)"If this options is used an attempt will be made to gain the address\n");
#line 739
  printf((char const   */* __restrict  */)"and netmask from the specified interface.\n");
#line 740
  printf((char const   */* __restrict  */)"\n");
#line 741
  printf((char const   */* __restrict  */)"Replacing address/interface with \'-\' will use stdin for reading further\n");
#line 743
  printf((char const   */* __restrict  */)"arguments.\n");
#line 744
  printf((char const   */* __restrict  */)"\n");
#line 745
  printf((char const   */* __restrict  */)"Report bugs to <simon@routemeister.net>.\n");
  }
#line 747
  return;
}
}
#line 807 "/home/june/repo/benchmarks/collector/temp/sipcalc-1.1.5/src/sub-output.c"
void print_short_help(void) 
{ 


  {
  {
#line 810
  printf((char const   */* __restrict  */)"Usage: %s [OPTIONS]... <[ADDRESS]... [INTERFACE]... | [-]>\n",
         "sipcalc");
#line 812
  printf((char const   */* __restrict  */)"Try \'%s -h\' for more information.\n",
         "sipcalc");
  }
#line 813
  return;
}
}
#line 815 "/home/june/repo/benchmarks/collector/temp/sipcalc-1.1.5/src/sub-output.c"
void print_version(void) 
{ 


  {
  {
#line 818
  printf((char const   */* __restrict  */)"%s %s\n", "sipcalc", "1.1.5");
#line 819
  printf((char const   */* __restrict  */)"Written by Simon Ekstrand.\n");
#line 820
  printf((char const   */* __restrict  */)"\n");
#line 821
  printf((char const   */* __restrict  */)"Copyright (C) 2003-2005 Simon Ekstrand.\n");
#line 822
  printf((char const   */* __restrict  */)"This is free software; see the source for copying conditions.  There is NO\n");
#line 824
  printf((char const   */* __restrict  */)"warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n");
  }
#line 826
  return;
}
}
#line 846 "/usr/include/stdio.h"
extern void perror(char const   *__s ) ;
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 41 "/usr/include/x86_64-linux-gnu/sys/ioctl.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ioctl)(int __fd ,
                                                                            unsigned long __request 
                                                                            , ...) ;
#line 132 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 113 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) socket)(int __domain ,
                                                                             int __type ,
                                                                             int __protocol ) ;
#line 377 "/usr/include/netinet/in.h"
extern  __attribute__((__nothrow__)) uint32_t ( __attribute__((__leaf__)) htonl)(uint32_t __hostlong )  __attribute__((__const__)) ;
#line 248 "../include/sub.h"
struct if_info *new_if(struct if_info *ifarg_cur ) ;
#line 249
void free_if(struct if_info *if_cur ) ;
#line 250
struct if_info *get_if_ext(void) ;
#line 54 "/home/june/repo/benchmarks/collector/temp/sipcalc-1.1.5/src/interface.c"
struct if_info *new_if(struct if_info *ifarg_cur ) 
{ 
  struct if_info *n_if ;
  void *tmp ;

  {
  {
#line 59
  tmp = malloc(sizeof(struct if_info ));
#line 59
  ifarg_cur->next = (struct if_info *)tmp;
#line 60
  n_if = ifarg_cur->next;
#line 61
  n_if->next = (struct if_info *)((void *)0);
#line 62
  bzero((void *)(n_if->name), (size_t )17);
#line 63
  bzero((void *)(n_if->p_v4addr), (size_t )19);
#line 64
  bzero((void *)(n_if->p_v4nmask), (size_t )16);
#line 65
  bzero((void *)(n_if->errorstr), (size_t )64);
#line 66
  bzero((void *)(n_if->cmdstr), (size_t )128);
#line 67
  n_if->type = (short)0;
  }
#line 69
  return (n_if);
}
}
#line 72 "/home/june/repo/benchmarks/collector/temp/sipcalc-1.1.5/src/interface.c"
void free_if(struct if_info *if_cur ) 
{ 
  struct if_info *if_old ;

  {
  {
#line 77
  while (1) {
    while_continue: /* CIL Label */ ;
#line 77
    if (! if_cur) {
#line 77
      goto while_break;
    }
    {
#line 78
    if_old = if_cur;
#line 79
    if_cur = if_cur->next;
#line 80
    free((void *)if_old);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 82
  return;
}
}
#line 84 "/home/june/repo/benchmarks/collector/temp/sipcalc-1.1.5/src/interface.c"
struct if_info *get_if_ext(void) 
{ 
  int sd ;
  int size ;
  int prev_size ;
  int len ;
  int ifreq_sum ;
  struct ifreq *ifr ;
  struct ifreq ifr_stat ;
  struct ifconf ifc ;
  char *buf ;
  char *ptr ;
  struct if_info *if_start ;
  struct if_info *if_cur ;
  struct sockaddr_in *sin ;
  void *tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;

  {
  {
#line 94
  sd = socket(2, 2, 0);
  }
#line 94
  if (sd < 0) {
    {
#line 95
    perror("socket");
    }
#line 96
    return ((struct if_info *)((void *)0));
  }
#line 99
  prev_size = 0;
#line 100
  size = (int )(5UL * sizeof(struct ifreq ));
  {
#line 101
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 102
    tmp = malloc((size_t )size);
#line 102
    buf = (char *)tmp;
    }
#line 102
    if (! buf) {
      {
#line 103
      perror("malloc");
      }
#line 104
      return ((struct if_info *)((void *)0));
    }
    {
#line 106
    ifc.ifc_len = size;
#line 107
    ifc.ifc_ifcu.ifcu_buf = buf;
#line 108
    tmp___1 = ioctl(sd, 35090UL, & ifc);
    }
#line 108
    if (tmp___1 < 0) {
      {
#line 109
      tmp___0 = __errno_location();
      }
#line 109
      if (*tmp___0 != 22) {
        {
#line 110
        perror("ioctl");
        }
#line 111
        return ((struct if_info *)((void *)0));
      } else
#line 109
      if (prev_size) {
        {
#line 110
        perror("ioctl");
        }
#line 111
        return ((struct if_info *)((void *)0));
      }
    } else {
#line 114
      if (ifc.ifc_len == prev_size) {
#line 115
        goto while_break;
      }
#line 116
      prev_size = ifc.ifc_len;
    }
    {
#line 118
    size = (int )((unsigned long )size + 5UL * sizeof(struct ifreq ));
#line 119
    free((void *)buf);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 122
  if_cur = (struct if_info *)((void *)0);
#line 123
  if_start = (struct if_info *)((void *)0);
#line 124
  ptr = buf;
#line 125
  len = 0;
#line 126
  ifreq_sum = 0;
  {
#line 127
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 127
    if (! ((unsigned long )ptr < (unsigned long )(buf + ifc.ifc_len))) {
#line 127
      goto while_break___0;
    }
#line 128
    if (! if_start) {
      {
#line 129
      tmp___2 = malloc(sizeof(struct if_info ));
#line 129
      if_start = (struct if_info *)tmp___2;
#line 129
      if_cur = if_start;
#line 131
      if_cur->next = (struct if_info *)((void *)0);
      }
    } else {
      {
#line 133
      tmp___3 = malloc(sizeof(struct if_info ));
#line 133
      if_cur->next = (struct if_info *)tmp___3;
#line 135
      if_cur = if_cur->next;
#line 136
      if_cur->next = (struct if_info *)((void *)0);
      }
    }
#line 139
    ifr = (struct ifreq *)ptr;
    {
#line 141
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 141
      if ((unsigned long )ptr < (unsigned long )(buf + ifc.ifc_len)) {
#line 141
        if (ifr) {
#line 141
          if (! ((int )ifr->ifr_ifru.ifru_addr.sa_family != 2)) {
#line 141
            goto while_break___1;
          }
        } else {
#line 141
          goto while_break___1;
        }
      } else {
#line 141
        goto while_break___1;
      }
#line 167
      len = (int )sizeof(struct ifreq );
#line 169
      ptr += len;
#line 170
      ifr = (struct ifreq *)ptr;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 173
    if (! ifr) {
#line 174
      goto while_break___0;
    } else
#line 173
    if ((unsigned long )ptr >= (unsigned long )(buf + ifc.ifc_len)) {
#line 174
      goto while_break___0;
    }
    {
#line 179
    bzero((void *)(if_cur->name), (size_t )17);
#line 180
    strncpy((char */* __restrict  */)(if_cur->name), (char const   */* __restrict  */)(ifr->ifr_ifrn.ifrn_name),
            (size_t )16);
#line 181
    sin = (struct sockaddr_in *)(& ifr->ifr_ifru.ifru_addr);
#line 182
    if_cur->v4ad.n_haddr = htonl(sin->sin_addr.s_addr);
#line 183
    ifr_stat = *ifr;
#line 185
    ioctl(sd, 35091UL, & ifr_stat);
#line 186
    if_cur->flags = ifr_stat.ifr_ifru.ifru_flags;
#line 193
    ioctl(sd, 35099UL, & ifr_stat);
#line 194
    sin = (struct sockaddr_in *)(& ifr_stat.ifr_ifru.ifru_addr);
#line 195
    if_cur->v4ad.n_nmask = htonl(sin->sin_addr.s_addr);
    }
#line 198
    if (((int )if_cur->flags & 2) == 2) {
      {
#line 199
      ioctl(sd, 35097UL, & ifr_stat);
#line 200
      sin = (struct sockaddr_in *)(& ifr_stat.ifr_ifru.ifru_broadaddr);
#line 201
      if_cur->v4ad.i_broadcast = htonl(sin->sin_addr.s_addr);
      }
    }
#line 213
    len = (int )sizeof(struct ifreq );
#line 215
    ptr += len;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 218
  free((void *)buf);
  }
#line 220
  return (if_start);
}
}
#line 147 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 129 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 144
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 342
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strstr)(char const   *__haystack ,
                                                                                                 char const   *__needle )  __attribute__((__pure__)) ;
#line 360 "/usr/include/unistd.h"
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 57 "/usr/include/getopt.h"
extern char *optarg ;
#line 71
extern int optind ;
#line 173
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getopt_long)(int ___argc ,
                                                                                  char * const  *___argv ,
                                                                                  char const   *__shortopts ,
                                                                                  struct option  const  *__longopts ,
                                                                                  int *__longind ) ;
#line 210 "../include/sub.h"
int cleanline(char *sbuf , char *dbuf ) ;
#line 211
int get_stdin(char **args ) ;
#line 217
int validate_v4addr(char *addr ) ;
#line 218
int validate_netmask(char *in_addr ) ;
#line 219
int getsplitnumv4(char *buf , u_int32_t *splitmask ) ;
#line 220
int getsplitnumv6(char *buf , struct sip_in6_addr *splitmask , int *v6splitnum ) ;
#line 225
int get_addrv4(struct if_info *ifi ) ;
#line 226
int get_addrv6(struct if_info *ifi ) ;
#line 232
int validate_v6addr(char *addr ) ;
#line 240
int mk_ipv6addr(struct v6addr *in6_addr , char *addr ) ;
#line 242
void free_dnsresp(struct dnsresp *d_resp ) ;
#line 243
char *resolve_addr(char *addr , int family , struct dnsresp *d_resp ) ;
#line 56 "/home/june/repo/benchmarks/collector/temp/sipcalc-1.1.5/src/sub.c"
int resolve  ;
#line 58 "/home/june/repo/benchmarks/collector/temp/sipcalc-1.1.5/src/sub.c"
int out_cmdline(struct if_info *ifarg_cur , int v4args , struct misc_args m_argv4 ,
                int v6args , struct misc_args m_argv6 , int recurse , int index___0 ) 
{ 
  int ret ;

  {
#line 64
  ret = 0;
#line 66
  if ((int )ifarg_cur->type == 1) {
    {
#line 67
    printf((char const   */* __restrict  */)"-[ipv4 : %s] - %d\n", ifarg_cur->cmdstr,
           index___0);
#line 68
    ret = get_addrv4(ifarg_cur);
    }
  }
#line 71
  if ((int )ifarg_cur->type == 2) {
    {
#line 72
    printf((char const   */* __restrict  */)"-[ipv6 : %s] - %d\n", ifarg_cur->cmdstr,
           index___0);
#line 73
    ret = get_addrv6(ifarg_cur);
    }
  }
#line 76
  if ((int )ifarg_cur->type == 3) {
#line 76
    goto _L;
  } else
#line 76
  if ((int )ifarg_cur->type == 4) {
    _L: /* CIL Label */ 
    {
#line 77
    printf((char const   */* __restrict  */)"-[int-ipv4 : %s] - %d\n", ifarg_cur->cmdstr,
           index___0);
    }
#line 78
    if ((int )ifarg_cur->errorstr[0] != 0) {
      {
#line 79
      printf((char const   */* __restrict  */)"\n-[ERR : %s]\n\n-\n", ifarg_cur->errorstr);
      }
#line 80
      return (0);
    }
    {
#line 83
    ret = get_addrv4(ifarg_cur);
    }
  }
#line 86
  if ((int )ifarg_cur->type == 5) {
    {
#line 87
    printf((char const   */* __restrict  */)"-[unknown : %s] - %d\n", ifarg_cur->cmdstr,
           index___0);
#line 88
    printf((char const   */* __restrict  */)"\n-[ERR : %s]\n\n-\n", ifarg_cur->errorstr);
    }
#line 89
    return (0);
  }
#line 92
  if (ret == -1) {
    {
#line 93
    printf((char const   */* __restrict  */)"\n-[ERR : Invalid address]\n\n-\n");
    }
#line 94
    return (0);
  }
#line 96
  if (ret == -2) {
    {
#line 97
    printf((char const   */* __restrict  */)"\n-[ERR : Invalid netmask]\n\n-\n");
    }
#line 98
    return (0);
  }
#line 101
  if ((int )ifarg_cur->type == 1) {
#line 101
    goto _L___0;
  } else
#line 101
  if ((int )ifarg_cur->type == 3) {
    _L___0: /* CIL Label */ 
#line 102
    if (! v4args) {
#line 103
      v4args = 4;
    }
    {
#line 105
    printf((char const   */* __restrict  */)"\n");
    }
#line 106
    if ((v4args & 1) == 1) {
      {
#line 107
      print_cf_info_v4(ifarg_cur);
      }
    }
#line 108
    if ((v4args & 4) == 4) {
      {
#line 109
      print_cidr_info_v4(ifarg_cur);
      }
    }
#line 110
    if ((v4args & 2) == 2) {
      {
#line 111
      print_cf_bitmap_v4(ifarg_cur);
      }
    }
#line 112
    if ((v4args & 8) == 8) {
      {
#line 113
      print_cidr_bitmap_v4(ifarg_cur);
      }
    }
#line 114
    if ((v4args & 16) == 16) {
      {
#line 115
      show_networks_v4(ifarg_cur, m_argv4.numnets);
      }
    }
#line 116
    if ((v4args & 32) == 32) {
      {
#line 117
      show_split_networks_v4(ifarg_cur, m_argv4.splitmask, v4args, m_argv4);
      }
    }
#line 118
    if ((v4args & 128) == 128) {
      {
#line 119
      show_c_wildcard_info_v4(ifarg_cur);
      }
    }
    {
#line 120
    printf((char const   */* __restrict  */)"-\n");
    }
  }
#line 123
  if ((int )ifarg_cur->type == 2) {
#line 123
    goto _L___1;
  } else
#line 123
  if ((int )ifarg_cur->type == 4) {
    _L___1: /* CIL Label */ 
#line 124
    if (! v6args) {
#line 125
      v6args = 1;
    }
    {
#line 127
    printf((char const   */* __restrict  */)"\n");
    }
#line 128
    if ((v6args & 1) == 1) {
      {
#line 129
      print_v6(ifarg_cur);
      }
    }
#line 130
    if ((v6args & 2) == 2) {
      {
#line 131
      print_v4inv6(ifarg_cur);
      }
    }
#line 132
    if ((v6args & 8) == 8) {
      {
#line 133
      print_rev_v6(ifarg_cur);
      }
    }
#line 134
    if ((v6args & 4) == 4) {
      {
#line 135
      show_split_networks_v6(ifarg_cur, m_argv6.v6splitmask, v6args, m_argv6);
      }
    }
    {
#line 136
    printf((char const   */* __restrict  */)"-\n");
    }
  }
#line 139
  return (0);
}
}
#line 142 "/home/june/repo/benchmarks/collector/temp/sipcalc-1.1.5/src/sub.c"
int cleanline(char *sbuf , char *dbuf ) 
{ 
  int x ;
  int y ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  size_t tmp___7 ;

  {
#line 147
  x = 0;
  {
#line 147
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 147
    tmp = strlen((char const   *)sbuf);
    }
#line 147
    if (! ((size_t )x < tmp)) {
#line 147
      goto while_break;
    }
#line 148
    if ((int )*(sbuf + x) == 10) {
#line 149
      *(sbuf + x) = (char )' ';
    }
#line 150
    if ((int )*(sbuf + x) == 9) {
#line 151
      *(sbuf + x) = (char )' ';
    }
#line 152
    if ((int )*(sbuf + x) == 35) {
#line 153
      *(sbuf + x) = (char )'\000';
    }
#line 147
    x ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 155
  tmp___0 = strlen((char const   *)sbuf);
#line 155
  x = (int )(tmp___0 - 1UL);
  }
  {
#line 156
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 156
    if ((int )*(sbuf + x) == 32) {
#line 156
      if (! (x > -1)) {
#line 156
        goto while_break___0;
      }
    } else {
#line 156
      goto while_break___0;
    }
#line 157
    *(sbuf + x) = (char )'\000';
#line 158
    x --;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 160
  tmp___1 = strlen((char const   *)sbuf);
  }
#line 160
  if (! tmp___1) {
#line 161
    return (0);
  }
#line 163
  x = 0;
#line 164
  y = 0;
  {
#line 165
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 165
    tmp___4 = strlen((char const   *)sbuf);
    }
#line 165
    if (! ((size_t )x < tmp___4)) {
#line 165
      goto while_break___1;
    }
#line 166
    if ((int )*(sbuf + x) == 32) {
#line 166
      if (x) {
#line 167
        *(dbuf + y) = (char )' ';
#line 168
        y ++;
      }
    }
    {
#line 170
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 170
      if ((int )*(sbuf + x) == 32) {
        {
#line 170
        tmp___2 = strlen((char const   *)sbuf);
        }
#line 170
        if (! ((size_t )x < tmp___2)) {
#line 170
          goto while_break___2;
        }
      } else {
#line 170
        goto while_break___2;
      }
#line 171
      x ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 172
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 172
      if ((int )*(sbuf + x) != 32) {
        {
#line 172
        tmp___3 = strlen((char const   *)sbuf);
        }
#line 172
        if (! ((size_t )x < tmp___3)) {
#line 172
          goto while_break___3;
        }
      } else {
#line 172
        goto while_break___3;
      }
#line 173
      *(dbuf + y) = *(sbuf + x);
#line 174
      y ++;
#line 175
      x ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 177
    if ((int )*(dbuf + (y - 1)) == 32) {
#line 178
      return (0);
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 180
  tmp___6 = strlen((char const   *)dbuf);
  }
#line 180
  if ((int )*(dbuf + (tmp___6 - 1UL)) == 32) {
    {
#line 181
    tmp___5 = strlen((char const   *)dbuf);
#line 181
    *(dbuf + (tmp___5 - 1UL)) = (char )'\000';
    }
  }
#line 183
  y = 1;
#line 184
  x = 0;
  {
#line 184
  while (1) {
    while_continue___4: /* CIL Label */ ;
    {
#line 184
    tmp___7 = strlen((char const   *)dbuf);
    }
#line 184
    if (! ((size_t )x < tmp___7)) {
#line 184
      goto while_break___4;
    }
#line 185
    if ((int )*(dbuf + x) == 32) {
#line 186
      y ++;
    }
#line 184
    x ++;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 188
  return (y);
}
}
#line 191 "/home/june/repo/benchmarks/collector/temp/sipcalc-1.1.5/src/sub.c"
int get_stdin(char **args ) 
{ 
  char buf[2] ;
  char sbuf[128] ;
  char dbuf[128] ;
  char *arg1 ;
  char *arg2 ;
  int x ;
  int y ;
  int z ;
  int argmax ;
  void *tmp ;
  void *tmp___0 ;
  ssize_t tmp___1 ;
  ssize_t tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;

  {
  {
#line 197
  bzero((void *)(buf), (size_t )2);
#line 199
  argmax = 19;
#line 200
  tmp = malloc((size_t )argmax);
#line 200
  arg1 = (char *)tmp;
#line 201
  tmp___0 = malloc((size_t )16);
#line 201
  arg2 = (char *)tmp___0;
#line 202
  bzero((void *)arg1, (size_t )argmax);
#line 203
  bzero((void *)arg2, (size_t )16);
#line 204
  bzero((void *)(sbuf), (size_t )128);
#line 205
  bzero((void *)(dbuf), (size_t )128);
  }
  {
#line 207
  while (1) {
    while_continue: /* CIL Label */ ;
#line 207
    if (! (! sbuf[0])) {
#line 207
      goto while_break;
    }
    {
#line 208
    x = 0;
#line 209
    y = 0;
#line 210
    bzero((void *)(sbuf), (size_t )128);
    }
    {
#line 211
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 212
      tmp___1 = read(0, (void *)(buf), (size_t )1);
#line 212
      x = (int )tmp___1;
      }
#line 213
      if (x == 1) {
#line 214
        sbuf[y] = buf[0];
      }
#line 215
      y ++;
#line 211
      if (x > 0) {
#line 211
        if ((int )buf[0] != 10) {
#line 211
          if (! (y < 127)) {
#line 211
            goto while_break___0;
          }
        } else {
#line 211
          goto while_break___0;
        }
      } else {
#line 211
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 217
    if (x < 0) {
      {
#line 218
      free((void *)arg1);
#line 219
      free((void *)arg2);
      }
#line 220
      return (-1);
    }
#line 222
    if (! x) {
#line 223
      goto while_break;
    }
    {
#line 225
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 225
      if ((int )buf[0] != 10) {
#line 225
        if (! (x == 1)) {
#line 225
          goto while_break___1;
        }
      } else {
#line 225
        goto while_break___1;
      }
      {
#line 226
      tmp___2 = read(0, (void *)(buf), (size_t )1);
#line 226
      x = (int )tmp___2;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 227
    if (x < 0) {
      {
#line 228
      free((void *)arg1);
#line 229
      free((void *)arg2);
      }
#line 230
      return (-1);
    }
#line 232
    if (! x) {
#line 233
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 235
  if (! sbuf[0]) {
    {
#line 236
    free((void *)arg1);
#line 237
    free((void *)arg2);
    }
#line 238
    return (-2);
  }
  {
#line 241
  x = cleanline(sbuf, dbuf);
  }
#line 242
  if (x < 1) {
    {
#line 243
    free((void *)arg1);
#line 244
    free((void *)arg2);
    }
#line 245
    return (x);
  }
#line 248
  y = 0;
  {
#line 249
  while (1) {
    while_continue___2: /* CIL Label */ ;
    {
#line 249
    tmp___3 = strlen((char const   *)(dbuf));
    }
#line 249
    if ((size_t )y < tmp___3) {
#line 249
      if (y < argmax) {
#line 249
        if (! ((int )dbuf[y] != 32)) {
#line 249
          goto while_break___2;
        }
      } else {
#line 249
        goto while_break___2;
      }
    } else {
#line 249
      goto while_break___2;
    }
#line 250
    *(arg1 + y) = dbuf[y];
#line 251
    y ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 253
  y ++;
#line 254
  z = 0;
  {
#line 255
  while (1) {
    while_continue___3: /* CIL Label */ ;
    {
#line 255
    tmp___4 = strlen((char const   *)(dbuf));
    }
#line 255
    if ((size_t )y < tmp___4) {
#line 255
      if (z < 15) {
#line 255
        if (! ((int )dbuf[y] != 32)) {
#line 255
          goto while_break___3;
        }
      } else {
#line 255
        goto while_break___3;
      }
    } else {
#line 255
      goto while_break___3;
    }
#line 256
    *(arg2 + z) = dbuf[y];
#line 257
    y ++;
#line 258
    z ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 261
  strncpy((char */* __restrict  */)*(args + 0), (char const   */* __restrict  */)arg1,
          (size_t )127);
#line 262
  strncpy((char */* __restrict  */)*(args + 1), (char const   */* __restrict  */)arg2,
          (size_t )127);
#line 264
  free((void *)arg1);
#line 265
  free((void *)arg2);
  }
#line 267
  return (x);
}
}
#line 270 "/home/june/repo/benchmarks/collector/temp/sipcalc-1.1.5/src/sub.c"
struct argbox *new_arg(struct argbox *abox ) 
{ 
  void *tmp ;

  {
  {
#line 273
  tmp = malloc(sizeof(struct argbox ));
#line 273
  abox->next = (struct argbox *)tmp;
#line 274
  abox = abox->next;
#line 275
  bzero((void *)((char *)abox), (size_t )128);
#line 276
  abox->type = 0;
#line 277
  abox->resolv = 0;
#line 278
  abox->next = (struct argbox *)((void *)0);
  }
#line 280
  return (abox);
}
}
#line 283 "/home/june/repo/benchmarks/collector/temp/sipcalc-1.1.5/src/sub.c"
void free_boxargs(struct argbox *abox ) 
{ 
  struct argbox *old ;

  {
  {
#line 288
  while (1) {
    while_continue: /* CIL Label */ ;
#line 288
    if (! abox) {
#line 288
      goto while_break;
    }
    {
#line 289
    old = abox;
#line 290
    abox = abox->next;
#line 291
    free((void *)old);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 293
  return;
}
}
#line 303 "/home/june/repo/benchmarks/collector/temp/sipcalc-1.1.5/src/sub.c"
struct argbox *get_boxargs(int argc , char **argv , int argcount , struct argbox *abox_cur ) 
{ 
  char expaddr[128] ;
  int x ;
  int y ;
  int error ;
  size_t tmp ;

  {
#line 310
  error = 0;
  {
#line 315
  while (1) {
    while_continue: /* CIL Label */ ;
#line 315
    if (! *(argv + argcount)) {
#line 315
      goto while_break;
    }
    {
#line 316
    bzero((void *)(expaddr), (size_t )128);
#line 318
    strncpy((char */* __restrict  */)(expaddr), (char const   */* __restrict  */)*(argv + argcount),
            (size_t )127);
#line 323
    tmp = strlen((char const   *)*(argv + argcount));
    }
#line 323
    if (tmp > 127UL) {
      {
#line 324
      printf((char const   */* __restrict  */)"-[ERR : INVALID ARG - %s]\n", expaddr);
#line 325
      error = 1;
      }
#line 326
      goto complete;
    }
    {
#line 332
    x = validate_v6addr(expaddr);
    }
#line 333
    if (x) {
      {
#line 334
      strncpy((char */* __restrict  */)(abox_cur->str), (char const   */* __restrict  */)(expaddr),
              (size_t )127);
#line 335
      abox_cur->type = 2;
#line 336
      abox_cur->resolv = 0;
#line 337
      abox_cur = new_arg(abox_cur);
      }
#line 338
      goto complete;
    }
    {
#line 348
    x = validate_netmask(expaddr);
    }
#line 349
    if (x == 2) {
      {
#line 350
      strncpy((char */* __restrict  */)(abox_cur->str), (char const   */* __restrict  */)(expaddr),
              (size_t )127);
#line 351
      abox_cur->type = 1;
#line 352
      abox_cur->resolv = 0;
#line 353
      abox_cur = new_arg(abox_cur);
      }
#line 354
      goto complete;
    }
    {
#line 360
    x = validate_v4addr(expaddr);
    }
#line 361
    if (x) {
#line 362
      y = 0;
#line 367
      if (argcount + 1 < argc) {
        {
#line 368
        y = validate_netmask(*(argv + (argcount + 1)));
        }
      }
#line 373
      if (y == 1) {
        {
#line 374
        snprintf((char */* __restrict  */)(abox_cur->str), (size_t )34, (char const   */* __restrict  */)"%s %s",
                 expaddr, *(argv + (argcount + 1)));
#line 375
        argcount ++;
        }
      } else
#line 373
      if (y == 3) {
        {
#line 374
        snprintf((char */* __restrict  */)(abox_cur->str), (size_t )34, (char const   */* __restrict  */)"%s %s",
                 expaddr, *(argv + (argcount + 1)));
#line 375
        argcount ++;
        }
      } else {
        {
#line 378
        snprintf((char */* __restrict  */)(abox_cur->str), (size_t )18, (char const   */* __restrict  */)"%s",
                 expaddr);
        }
      }
      {
#line 379
      abox_cur->type = 1;
#line 380
      abox_cur->resolv = 0;
#line 381
      abox_cur = new_arg(abox_cur);
      }
#line 382
      goto complete;
    }
#line 385
    y = 0;
#line 386
    if (argcount + 1 < argc) {
      {
#line 387
      y = validate_netmask(*(argv + (argcount + 1)));
      }
    }
#line 388
    if (y == 1) {
      {
#line 389
      snprintf((char */* __restrict  */)(abox_cur->str), (size_t )127, (char const   */* __restrict  */)"%s %s",
               expaddr, *(argv + (argcount + 1)));
#line 390
      argcount ++;
      }
    } else
#line 388
    if (y == 3) {
      {
#line 389
      snprintf((char */* __restrict  */)(abox_cur->str), (size_t )127, (char const   */* __restrict  */)"%s %s",
               expaddr, *(argv + (argcount + 1)));
#line 390
      argcount ++;
      }
    } else {
      {
#line 393
      strncpy((char */* __restrict  */)(abox_cur->str), (char const   */* __restrict  */)(expaddr),
              (size_t )127);
      }
    }
    {
#line 394
    abox_cur->type = 4;
#line 395
    abox_cur->resolv = 1;
#line 396
    abox_cur = new_arg(abox_cur);
    }
    complete: 
    {
#line 399
    bzero((void *)(expaddr), (size_t )128);
#line 400
    argcount ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 403
  if (error) {
    {
#line 404
    printf((char const   */* __restrict  */)"\n");
    }
  }
#line 406
  return (abox_cur);
}
}
#line 409 "/home/june/repo/benchmarks/collector/temp/sipcalc-1.1.5/src/sub.c"
void show_abox(struct argbox *a ) 
{ 


  {
  {
#line 412
  while (1) {
    while_continue: /* CIL Label */ ;
#line 412
    if (! a) {
#line 412
      goto while_break;
    }
    {
#line 413
    printf((char const   */* __restrict  */)"%s - %d - %d\n", a->str, a->type, a->resolv);
#line 414
    a = a->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 416
  return;
}
}
#line 418 "/home/june/repo/benchmarks/collector/temp/sipcalc-1.1.5/src/sub.c"
struct if_info *parse_abox(struct argbox *abox , struct if_info *if_start ) 
{ 
  struct if_info *ifarg_start ;
  struct if_info *ifarg_cur ;
  struct if_info *ifarg_old ;
  struct if_info *if_cur ;
  struct dnsresp *d_resp_start ;
  struct dnsresp *d_resp_cur ;
  char *tmpstr ;
  int x ;
  int if_found ;
  void *tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  void *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  void *tmp___8 ;
  size_t tmp___9 ;
  size_t tmp___10 ;
  int tmp___11 ;

  {
  {
#line 427
  tmp = malloc(sizeof(struct if_info ));
#line 427
  ifarg_start = (struct if_info *)tmp;
#line 427
  ifarg_cur = ifarg_start;
#line 427
  ifarg_old = ifarg_cur;
#line 429
  ifarg_cur->next = (struct if_info *)((void *)0);
#line 430
  bzero((void *)(ifarg_cur->name), (size_t )16);
#line 431
  bzero((void *)(ifarg_cur->p_v4addr), (size_t )19);
#line 432
  bzero((void *)(ifarg_cur->p_v4nmask), (size_t )16);
  }
  {
#line 434
  while (1) {
    while_continue: /* CIL Label */ ;
#line 434
    if (! abox) {
#line 434
      goto while_break;
    }
#line 435
    if (abox->type == 1) {
#line 435
      if (! abox->resolv) {
        {
#line 436
        tmpstr = strstr((char const   *)(abox->str), " ");
        }
#line 437
        if ((unsigned long )tmpstr != (unsigned long )((void *)0)) {
          {
#line 437
          tmp___1 = strlen((char const   *)tmpstr);
          }
#line 437
          if (tmp___1 > 0UL) {
#line 438
            tmpstr ++;
#line 439
            x = 0;
            {
#line 440
            while (1) {
              while_continue___0: /* CIL Label */ ;
#line 440
              if (x < 15) {
#line 440
                if ((int )*(tmpstr + x) != 32) {
                  {
#line 440
                  tmp___0 = strlen((char const   *)tmpstr);
                  }
#line 440
                  if (! ((size_t )x < tmp___0)) {
#line 440
                    goto while_break___0;
                  }
                } else {
#line 440
                  goto while_break___0;
                }
              } else {
#line 440
                goto while_break___0;
              }
#line 441
              ifarg_cur->p_v4nmask[x] = *(tmpstr + x);
#line 442
              x ++;
            }
            while_break___0: /* CIL Label */ ;
            }
          }
        }
#line 446
        x = 0;
        {
#line 447
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 447
          if (x < 18) {
#line 447
            if (! ((int )abox->str[x] != 32)) {
#line 447
              goto while_break___1;
            }
          } else {
#line 447
            goto while_break___1;
          }
#line 448
          ifarg_cur->p_v4addr[x] = abox->str[x];
#line 449
          x ++;
        }
        while_break___1: /* CIL Label */ ;
        }
        {
#line 451
        ifarg_cur->type = (short)1;
#line 452
        strncpy((char */* __restrict  */)(ifarg_cur->cmdstr), (char const   */* __restrict  */)(abox->str),
                (size_t )127);
        }
      }
    }
#line 455
    if (abox->type == 1) {
#line 455
      if (abox->resolv) {
        {
#line 456
        tmp___2 = malloc(sizeof(struct dnsresp ));
#line 456
        d_resp_cur = (struct dnsresp *)tmp___2;
#line 456
        d_resp_start = d_resp_cur;
#line 457
        d_resp_start->next = (struct dnsresp *)((void *)0);
#line 458
        bzero((void *)(d_resp_start->str), (size_t )128);
#line 459
        d_resp_start->type = 0;
#line 460
        tmpstr = resolve_addr(abox->str, 2, d_resp_cur);
        }
#line 461
        if (tmpstr) {
#line 462
          d_resp_cur = d_resp_start;
          {
#line 463
          while (1) {
            while_continue___2: /* CIL Label */ ;
#line 463
            if (! d_resp_cur) {
#line 463
              goto while_break___2;
            }
            {
#line 464
            strncpy((char */* __restrict  */)(ifarg_cur->cmdstr), (char const   */* __restrict  */)(abox->str),
                    (size_t )127);
#line 465
            tmpstr = strstr((char const   *)(d_resp_cur->str), " ");
            }
#line 466
            if ((unsigned long )tmpstr != (unsigned long )((void *)0)) {
              {
#line 466
              tmp___4 = strlen((char const   *)tmpstr);
              }
#line 466
              if (tmp___4 > 0UL) {
#line 467
                tmpstr ++;
#line 468
                x = 0;
                {
#line 469
                while (1) {
                  while_continue___3: /* CIL Label */ ;
#line 469
                  if (x < 15) {
#line 469
                    if ((int )*(tmpstr + x) != 32) {
                      {
#line 469
                      tmp___3 = strlen((char const   *)tmpstr);
                      }
#line 469
                      if (! ((size_t )x < tmp___3)) {
#line 469
                        goto while_break___3;
                      }
                    } else {
#line 469
                      goto while_break___3;
                    }
                  } else {
#line 469
                    goto while_break___3;
                  }
#line 470
                  ifarg_cur->p_v4nmask[x] = *(tmpstr + x);
#line 471
                  x ++;
                }
                while_break___3: /* CIL Label */ ;
                }
              }
            }
#line 475
            x = 0;
            {
#line 476
            while (1) {
              while_continue___4: /* CIL Label */ ;
#line 476
              if (x < 18) {
#line 476
                if (! ((int )d_resp_cur->str[x] != 32)) {
#line 476
                  goto while_break___4;
                }
              } else {
#line 476
                goto while_break___4;
              }
#line 477
              ifarg_cur->p_v4addr[x] = d_resp_cur->str[x];
#line 478
              x ++;
            }
            while_break___4: /* CIL Label */ ;
            }
#line 480
            ifarg_cur->type = (short)1;
#line 481
            if (d_resp_cur->next) {
              {
#line 482
              ifarg_cur = new_if(ifarg_cur);
              }
            }
#line 483
            d_resp_cur = d_resp_cur->next;
          }
          while_break___2: /* CIL Label */ ;
          }
        } else {
          {
#line 487
          strncpy((char */* __restrict  */)(ifarg_cur->p_v4addr), (char const   */* __restrict  */)(abox->str),
                  (size_t )18);
#line 488
          strncpy((char */* __restrict  */)(ifarg_cur->cmdstr), (char const   */* __restrict  */)(abox->str),
                  (size_t )127);
#line 489
          ifarg_cur->type = (short)1;
          }
        }
        {
#line 492
        free_dnsresp(d_resp_start);
        }
      }
    }
#line 495
    if (abox->type == 2) {
#line 495
      if (! abox->resolv) {
        {
#line 496
        strncpy((char */* __restrict  */)(ifarg_cur->p_v6addr), (char const   */* __restrict  */)(abox->str),
                (size_t )43);
#line 497
        strncpy((char */* __restrict  */)(ifarg_cur->cmdstr), (char const   */* __restrict  */)(abox->str),
                (size_t )127);
#line 499
        mk_ipv6addr(& ifarg_cur->v6ad, ifarg_cur->p_v6addr);
#line 500
        ifarg_cur->type = (short)2;
        }
      }
    }
#line 503
    if (abox->type == 2) {
#line 503
      if (abox->resolv) {
        {
#line 504
        tmp___5 = malloc(sizeof(struct dnsresp ));
#line 504
        d_resp_cur = (struct dnsresp *)tmp___5;
#line 504
        d_resp_start = d_resp_cur;
#line 505
        d_resp_start->next = (struct dnsresp *)((void *)0);
#line 506
        bzero((void *)(d_resp_start->str), (size_t )128);
#line 507
        d_resp_start->type = 0;
#line 508
        tmpstr = resolve_addr(abox->str, 10, d_resp_cur);
        }
#line 509
        if (tmpstr) {
#line 510
          d_resp_cur = d_resp_start;
          {
#line 511
          while (1) {
            while_continue___5: /* CIL Label */ ;
#line 511
            if (! d_resp_cur) {
#line 511
              goto while_break___5;
            }
            {
#line 512
            strncpy((char */* __restrict  */)(ifarg_cur->cmdstr), (char const   */* __restrict  */)(abox->str),
                    (size_t )127);
#line 513
            strncpy((char */* __restrict  */)(ifarg_cur->p_v6addr), (char const   */* __restrict  */)(d_resp_cur->str),
                    (size_t )43);
#line 514
            ifarg_cur->type = (short)2;
#line 516
            mk_ipv6addr(& ifarg_cur->v6ad, ifarg_cur->p_v6addr);
            }
#line 518
            if (d_resp_cur->next) {
              {
#line 519
              ifarg_cur = new_if(ifarg_cur);
              }
            }
#line 520
            d_resp_cur = d_resp_cur->next;
          }
          while_break___5: /* CIL Label */ ;
          }
        } else {
          {
#line 524
          strncpy((char */* __restrict  */)(ifarg_cur->cmdstr), (char const   */* __restrict  */)(abox->str),
                  (size_t )127);
#line 525
          strncpy((char */* __restrict  */)(ifarg_cur->p_v6addr), (char const   */* __restrict  */)(abox->str),
                  (size_t )43);
#line 526
          ifarg_cur->type = (short)2;
#line 528
          mk_ipv6addr(& ifarg_cur->v6ad, ifarg_cur->p_v6addr);
          }
        }
        {
#line 531
        free_dnsresp(d_resp_start);
        }
      }
    }
#line 534
    if (abox->type == 3) {
#line 535
      if_cur = if_start;
#line 536
      if_found = 0;
      {
#line 537
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 537
        if (! if_cur) {
#line 537
          goto while_break___6;
        }
        {
#line 538
        tmp___6 = strcmp((char const   *)(abox->str), (char const   *)(if_cur->name));
        }
#line 538
        if (! tmp___6) {
#line 539
          if (if_found) {
            {
#line 540
            ifarg_old = ifarg_cur;
#line 541
            ifarg_cur = new_if(ifarg_cur);
            }
          }
          {
#line 543
          memcpy((void */* __restrict  */)ifarg_cur, (void const   */* __restrict  */)if_cur,
                 sizeof(struct if_info ));
#line 544
          ifarg_cur->type = (short)3;
#line 545
          strncpy((char */* __restrict  */)(ifarg_cur->cmdstr), (char const   */* __restrict  */)(abox->str),
                  (size_t )127);
#line 546
          if_found = 1;
          }
        }
#line 548
        if_cur = if_cur->next;
      }
      while_break___6: /* CIL Label */ ;
      }
#line 550
      if (! if_found) {
        {
#line 551
        strncpy((char */* __restrict  */)(ifarg_cur->name), (char const   */* __restrict  */)(abox->str),
                (size_t )16);
#line 552
        strncpy((char */* __restrict  */)(ifarg_cur->cmdstr), (char const   */* __restrict  */)(abox->str),
                (size_t )127);
#line 553
        snprintf((char */* __restrict  */)(ifarg_cur->errorstr), sizeof(ifarg_cur->errorstr),
                 (char const   */* __restrict  */)"Unable to retrieve interface information");
#line 554
        ifarg_cur->type = (short)3;
        }
      }
    }
#line 558
    if (abox->type == 4) {
#line 558
      if (! abox->resolv) {
#line 559
        if_cur = if_start;
#line 560
        if_found = 0;
        {
#line 561
        while (1) {
          while_continue___7: /* CIL Label */ ;
#line 561
          if (! if_cur) {
#line 561
            goto while_break___7;
          }
          {
#line 562
          tmp___7 = strcmp((char const   *)(abox->str), (char const   *)(if_cur->name));
          }
#line 562
          if (! tmp___7) {
#line 563
            if (if_found) {
              {
#line 564
              ifarg_old = ifarg_cur;
#line 565
              ifarg_cur = new_if(ifarg_cur);
              }
            }
            {
#line 567
            memcpy((void */* __restrict  */)ifarg_cur, (void const   */* __restrict  */)if_cur,
                   sizeof(struct if_info ));
#line 568
            ifarg_cur->type = (short)3;
#line 569
            strncpy((char */* __restrict  */)(ifarg_cur->cmdstr), (char const   */* __restrict  */)(abox->str),
                    (size_t )127);
#line 570
            if_found = 1;
            }
          }
#line 572
          if_cur = if_cur->next;
        }
        while_break___7: /* CIL Label */ ;
        }
#line 574
        if (! if_found) {
          {
#line 575
          strncpy((char */* __restrict  */)(ifarg_cur->name), (char const   */* __restrict  */)(abox->str),
                  (size_t )16);
#line 576
          strncpy((char */* __restrict  */)(ifarg_cur->cmdstr), (char const   */* __restrict  */)(abox->str),
                  (size_t )127);
#line 577
          snprintf((char */* __restrict  */)(ifarg_cur->errorstr), sizeof(ifarg_cur->errorstr),
                   (char const   */* __restrict  */)"Unable to retrieve interface information");
#line 578
          ifarg_cur->type = (short)3;
          }
        }
      }
    }
#line 582
    if (abox->type == 4) {
#line 582
      if (abox->resolv) {
        {
#line 583
        tmp___8 = malloc(sizeof(struct dnsresp ));
#line 583
        d_resp_cur = (struct dnsresp *)tmp___8;
#line 583
        d_resp_start = d_resp_cur;
#line 584
        d_resp_start->next = (struct dnsresp *)((void *)0);
#line 585
        bzero((void *)(d_resp_start->str), (size_t )128);
#line 586
        d_resp_start->type = 0;
#line 587
        tmpstr = resolve_addr(abox->str, 0, d_resp_cur);
        }
#line 588
        if (tmpstr) {
#line 589
          d_resp_cur = d_resp_start;
          {
#line 590
          while (1) {
            while_continue___8: /* CIL Label */ ;
#line 590
            if (! d_resp_cur) {
#line 590
              goto while_break___8;
            }
            {
#line 591
            strncpy((char */* __restrict  */)(ifarg_cur->cmdstr), (char const   */* __restrict  */)(abox->str),
                    (size_t )127);
            }
#line 592
            if (d_resp_cur->type == 10) {
              {
#line 593
              strncpy((char */* __restrict  */)(ifarg_cur->p_v6addr), (char const   */* __restrict  */)(d_resp_cur->str),
                      (size_t )43);
#line 594
              ifarg_cur->type = (short)2;
#line 596
              mk_ipv6addr(& ifarg_cur->v6ad, ifarg_cur->p_v6addr);
              }
            }
#line 598
            if (d_resp_cur->type == 2) {
              {
#line 599
              tmpstr = strstr((char const   *)(d_resp_cur->str), " ");
              }
#line 600
              if ((unsigned long )tmpstr != (unsigned long )((void *)0)) {
                {
#line 600
                tmp___10 = strlen((char const   *)tmpstr);
                }
#line 600
                if (tmp___10 > 0UL) {
#line 601
                  tmpstr ++;
#line 602
                  x = 0;
                  {
#line 603
                  while (1) {
                    while_continue___9: /* CIL Label */ ;
#line 603
                    if (x < 15) {
#line 603
                      if ((int )*(tmpstr + x) != 32) {
                        {
#line 603
                        tmp___9 = strlen((char const   *)tmpstr);
                        }
#line 603
                        if (! ((size_t )x < tmp___9)) {
#line 603
                          goto while_break___9;
                        }
                      } else {
#line 603
                        goto while_break___9;
                      }
                    } else {
#line 603
                      goto while_break___9;
                    }
#line 604
                    ifarg_cur->p_v4nmask[x] = *(tmpstr + x);
#line 605
                    x ++;
                  }
                  while_break___9: /* CIL Label */ ;
                  }
                }
              }
#line 609
              x = 0;
              {
#line 610
              while (1) {
                while_continue___10: /* CIL Label */ ;
#line 610
                if (x < 18) {
#line 610
                  if (! ((int )d_resp_cur->str[x] != 32)) {
#line 610
                    goto while_break___10;
                  }
                } else {
#line 610
                  goto while_break___10;
                }
#line 611
                ifarg_cur->p_v4addr[x] = d_resp_cur->str[x];
#line 612
                x ++;
              }
              while_break___10: /* CIL Label */ ;
              }
#line 614
              ifarg_cur->type = (short)1;
            }
#line 617
            if (d_resp_cur->next) {
              {
#line 618
              ifarg_cur = new_if(ifarg_cur);
              }
            }
#line 619
            d_resp_cur = d_resp_cur->next;
          }
          while_break___8: /* CIL Label */ ;
          }
          {
#line 621
          free_dnsresp(d_resp_start);
          }
        } else {
#line 624
          if_cur = if_start;
#line 625
          if_found = 0;
          {
#line 626
          while (1) {
            while_continue___11: /* CIL Label */ ;
#line 626
            if (! if_cur) {
#line 626
              goto while_break___11;
            }
            {
#line 627
            tmp___11 = strcmp((char const   *)(abox->str), (char const   *)(if_cur->name));
            }
#line 627
            if (! tmp___11) {
#line 628
              if (if_found) {
                {
#line 629
                ifarg_old = ifarg_cur;
#line 630
                ifarg_cur = new_if(ifarg_cur);
                }
              }
              {
#line 632
              memcpy((void */* __restrict  */)ifarg_cur, (void const   */* __restrict  */)if_cur,
                     sizeof(struct if_info ));
#line 633
              ifarg_cur->type = (short)3;
#line 634
              strncpy((char */* __restrict  */)(ifarg_cur->cmdstr), (char const   */* __restrict  */)(abox->str),
                      (size_t )127);
#line 635
              if_found = 1;
              }
            }
#line 637
            if_cur = if_cur->next;
          }
          while_break___11: /* CIL Label */ ;
          }
#line 639
          if (! if_found) {
            {
#line 640
            strncpy((char */* __restrict  */)(ifarg_cur->cmdstr), (char const   */* __restrict  */)(abox->str),
                    (size_t )127);
#line 641
            snprintf((char */* __restrict  */)(ifarg_cur->errorstr), sizeof(ifarg_cur->errorstr),
                     (char const   */* __restrict  */)"Unparsable argument.");
#line 642
            ifarg_cur->type = (short)5;
            }
          }
        }
      }
    }
    {
#line 649
    abox = abox->next;
#line 650
    ifarg_old = ifarg_cur;
#line 651
    ifarg_cur = new_if(ifarg_cur);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 655
  ifarg_old->next = (struct if_info *)((void *)0);
#line 656
  free((void *)ifarg_cur);
#line 657
  ifarg_cur = (struct if_info *)((void *)0);
  }
#line 659
  if ((unsigned long )ifarg_start == (unsigned long )ifarg_cur) {
    {
#line 660
    free((void *)ifarg_start);
    }
#line 661
    return ((struct if_info *)((void *)0));
  }
#line 664
  return (ifarg_start);
}
}
#line 681
int main(int argc , char **argv ) ;
#line 681 "/home/june/repo/benchmarks/collector/temp/sipcalc-1.1.5/src/sub.c"
static struct option l_o[20]  = 
#line 681
  {      {"all", 0, (int *)0, 'a'}, 
        {"cidr-bitmap", 0, (int *)0, 'b'}, 
        {"classfull-addr", 0, (int *)0, 'c'}, 
        {"help", 0, (int *)0, 'h'}, 
        {"cidr-addr", 0, (int *)0, 'i'}, 
        {"subnets", 1, (int *)0, 'n'}, 
        {"v4split", 1, (int *)0, 's'}, 
        {"v6-standard", 0, (int *)0, 't'}, 
        {"version", 0, (int *)0, 'v'}, 
        {"classfull-bitmap", 0, (int *)0, 'x'}, 
        {"addr-ipv4", 1, (int *)0, '4'}, 
        {"addr-ipv6", 1, (int *)0, '6'}, 
        {"addr-int", 1, (int *)0, 'I'}, 
        {"v4inv6", 0, (int *)0, 'e'}, 
        {"v6split", 1, (int *)0, 'S'}, 
        {"v6rev", 0, (int *)0, 'r'}, 
        {"split-verbose", 0, (int *)0, 'u'}, 
        {"resolve", 0, (int *)0, 'd'}, 
        {"wildcard", 0, (int *)0, 'w'}, 
        {(char const   *)0, 0, (int *)0, 0}};
#line 667 "/home/june/repo/benchmarks/collector/temp/sipcalc-1.1.5/src/sub.c"
int main(int argc , char **argv ) 
{ 
  int x ;
  int y ;
  int z ;
  int m ;
  int v4args ;
  int v6args ;
  int iffound ;
  int argcount ;
  int first_err ;
  struct if_info *if_start ;
  struct if_info *if_cur ;
  struct if_info *ifarg_start ;
  struct if_info *ifarg_cur ;
  struct if_info *ifarg_old ;
  int ch ;
  int parse_stdin ;
  int index___0 ;
  struct misc_args m_argv4 ;
  struct misc_args m_argv6 ;
  int split_errv4 ;
  int split_errv6 ;
  char expaddr[128] ;
  char oldcmdstr[128] ;
  struct argbox *abox_start ;
  struct argbox *abox_cur ;
  struct argbox *abox_tmp ;
  char *stdinarg[3] ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  int tmp___8 ;
  size_t tmp___9 ;
  int tmp___10 ;
  void *tmp___11 ;

  {
#line 704
  if (argc < 2) {
    {
#line 705
    print_short_help();
    }
#line 706
    return (0);
  }
  {
#line 709
  parse_stdin = 0;
#line 710
  v4args = 0;
#line 711
  v6args = 0;
#line 712
  m_argv4.splitmask = (u_int32_t )0;
#line 713
  m_argv4.numnets = 0;
#line 714
  m_argv6.splitmask = (u_int32_t )0;
#line 715
  m_argv6.numnets = 0;
#line 716
  split_errv4 = 0;
#line 717
  split_errv6 = 0;
#line 718
  first_err = 1;
#line 719
  ifarg_start = (struct if_info *)((void *)0);
#line 720
  ifarg_old = (struct if_info *)((void *)0);
#line 721
  resolve = 0;
#line 730
  tmp = malloc(sizeof(struct argbox ));
#line 730
  abox_cur = (struct argbox *)tmp;
#line 730
  abox_start = abox_cur;
#line 731
  bzero((void *)((char *)abox_cur), (size_t )128);
#line 732
  abox_cur->type = 0;
#line 733
  abox_cur->resolv = 0;
#line 734
  abox_cur->next = (struct argbox *)((void *)0);
  }
  {
#line 742
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 742
    ch = getopt_long(argc, (char * const  *)argv, "abcdehHiI:n:rs:S:tuvVwx4:6:", (struct option  const  *)(l_o),
                     (int *)((void *)0));
    }
#line 742
    if (! (ch != -1)) {
#line 742
      goto while_break;
    }
    {
#line 749
    if (ch == 97) {
#line 749
      goto case_97;
    }
#line 755
    if (ch == 98) {
#line 755
      goto case_98;
    }
#line 758
    if (ch == 99) {
#line 758
      goto case_99;
    }
#line 761
    if (ch == 100) {
#line 761
      goto case_100;
    }
#line 767
    if (ch == 101) {
#line 767
      goto case_101;
    }
#line 771
    if (ch == 72) {
#line 771
      goto case_72;
    }
#line 771
    if (ch == 104) {
#line 771
      goto case_72;
    }
#line 774
    if (ch == 105) {
#line 774
      goto case_105;
    }
#line 777
    if (ch == 110) {
#line 777
      goto case_110;
    }
#line 781
    if (ch == 114) {
#line 781
      goto case_114;
    }
#line 784
    if (ch == 115) {
#line 784
      goto case_115;
    }
#line 794
    if (ch == 83) {
#line 794
      goto case_83;
    }
#line 804
    if (ch == 116) {
#line 804
      goto case_116;
    }
#line 807
    if (ch == 117) {
#line 807
      goto case_117;
    }
#line 812
    if (ch == 86) {
#line 812
      goto case_86;
    }
#line 812
    if (ch == 118) {
#line 812
      goto case_86;
    }
#line 815
    if (ch == 119) {
#line 815
      goto case_119;
    }
#line 818
    if (ch == 120) {
#line 818
      goto case_120;
    }
#line 821
    if (ch == 63) {
#line 821
      goto case_63;
    }
#line 824
    if (ch == 52) {
#line 824
      goto case_52;
    }
#line 835
    if (ch == 54) {
#line 835
      goto case_54;
    }
#line 844
    if (ch == 73) {
#line 844
      goto case_73;
    }
#line 851
    goto switch_default;
    case_97: /* CIL Label */ 
#line 750
    v4args = ((((v4args | 1) | 2) | 4) | 8) | 16;
#line 753
    v6args = ((v6args | 1) | 2) | 8;
#line 754
    goto switch_break;
    case_98: /* CIL Label */ 
#line 756
    v4args |= 8;
#line 757
    goto switch_break;
    case_99: /* CIL Label */ 
#line 759
    v4args |= 1;
#line 760
    goto switch_break;
    case_100: /* CIL Label */ 
#line 762
    resolve = 1;
#line 766
    goto switch_break;
    case_101: /* CIL Label */ 
#line 768
    v6args |= 2;
#line 769
    goto switch_break;
    case_72: /* CIL Label */ 
    case_104: /* CIL Label */ 
    {
#line 772
    print_help();
    }
#line 773
    return (0);
    case_105: /* CIL Label */ 
#line 775
    v4args |= 4;
#line 776
    goto switch_break;
    case_110: /* CIL Label */ 
    {
#line 778
    v4args |= 16;
#line 779
    m_argv4.numnets = atoi((char const   *)optarg);
    }
#line 780
    goto switch_break;
    case_114: /* CIL Label */ 
#line 782
    v6args |= 8;
#line 783
    goto switch_break;
    case_115: /* CIL Label */ 
    {
#line 785
    y = getsplitnumv4(optarg, & m_argv4.splitmask);
    }
#line 786
    if (! y) {
#line 787
      v4args |= 32;
    } else {
      {
#line 789
      printf((char const   */* __restrict  */)"-[ERR : Invalid IPv4 splitmask, unable to split]\n");
#line 791
      split_errv4 = 1;
      }
    }
#line 793
    goto switch_break;
    case_83: /* CIL Label */ 
    {
#line 795
    y = getsplitnumv6(optarg, & m_argv6.v6splitmask, & m_argv6.v6splitnum);
    }
#line 796
    if (! y) {
#line 797
      v6args |= 4;
    } else {
      {
#line 799
      printf((char const   */* __restrict  */)"-[ERR : Invalid IPv6 splitmask, unable to split]\n");
#line 801
      split_errv6 = 1;
      }
    }
#line 803
    goto switch_break;
    case_116: /* CIL Label */ 
#line 805
    v6args |= 1;
#line 806
    goto switch_break;
    case_117: /* CIL Label */ 
#line 808
    v4args |= 64;
#line 809
    v6args |= 16;
#line 810
    goto switch_break;
    case_86: /* CIL Label */ 
    case_118: /* CIL Label */ 
    {
#line 813
    print_version();
    }
#line 814
    return (0);
    case_119: /* CIL Label */ 
#line 816
    v4args |= 128;
#line 817
    goto switch_break;
    case_120: /* CIL Label */ 
#line 819
    v4args |= 2;
#line 820
    goto switch_break;
    case_63: /* CIL Label */ 
    {
#line 822
    printf((char const   */* __restrict  */)"Try \'%s -h\' for more information.\n",
           "sipcalc");
    }
#line 823
    return (0);
    case_52: /* CIL Label */ 
    {
#line 825
    strncpy((char */* __restrict  */)(abox_cur->str), (char const   */* __restrict  */)optarg,
            (size_t )127);
#line 826
    abox_cur->type = 1;
#line 827
    abox_cur->resolv = 1;
#line 828
    tmp___0 = validate_netmask(optarg);
    }
#line 828
    if (tmp___0 == 2) {
#line 829
      abox_cur->resolv = 0;
    }
    {
#line 830
    tmp___1 = validate_v4addr(optarg);
    }
#line 830
    if (tmp___1 == 1) {
#line 831
      abox_cur->resolv = 0;
    }
    {
#line 832
    abox_cur = new_arg(abox_cur);
    }
#line 834
    goto switch_break;
    case_54: /* CIL Label */ 
    {
#line 836
    strncpy((char */* __restrict  */)(abox_cur->str), (char const   */* __restrict  */)optarg,
            (size_t )127);
#line 837
    abox_cur->type = 2;
#line 838
    abox_cur->resolv = 1;
#line 839
    tmp___2 = validate_v6addr(expaddr);
    }
#line 839
    if (tmp___2 == 1) {
#line 840
      abox_cur->resolv = 0;
    }
    {
#line 841
    abox_cur = new_arg(abox_cur);
    }
#line 843
    goto switch_break;
    case_73: /* CIL Label */ 
    {
#line 845
    strncpy((char */* __restrict  */)(abox_cur->str), (char const   */* __restrict  */)optarg,
            (size_t )127);
#line 846
    abox_cur->type = 3;
#line 847
    abox_cur->resolv = 0;
#line 848
    abox_cur = new_arg(abox_cur);
    }
#line 850
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 852
    print_short_help();
    }
#line 853
    return (0);
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 857
  if (! v4args) {
#line 857
    if (! v6args) {
#line 857
      if (split_errv4) {
        {
#line 858
        printf((char const   */* __restrict  */)"-[ERR : No valid commands recieved]\n");
#line 859
        free_boxargs(abox_start);
        }
#line 860
        return (-1);
      } else
#line 857
      if (split_errv6) {
        {
#line 858
        printf((char const   */* __restrict  */)"-[ERR : No valid commands recieved]\n");
#line 859
        free_boxargs(abox_start);
        }
#line 860
        return (-1);
      }
    }
  }
#line 862
  if (split_errv4) {
    {
#line 863
    printf((char const   */* __restrict  */)"\n");
    }
  } else
#line 862
  if (split_errv6) {
    {
#line 863
    printf((char const   */* __restrict  */)"\n");
    }
  }
#line 865
  argcount = optind;
#line 869
  if (! v4args) {
#line 870
    v4args = 4;
  }
#line 871
  if (! v6args) {
#line 872
    v6args = 1;
  }
#line 873
  if (m_argv4.numnets < 1) {
#line 874
    m_argv4.numnets = -1;
  }
#line 876
  if (*(argv + argcount)) {
#line 877
    if ((int )*(*(argv + argcount) + 0) == 45) {
#line 877
      if ((int )*(*(argv + argcount) + 1) == 0) {
#line 878
        parse_stdin = 1;
      }
    }
  } else
#line 880
  if ((int )abox_start->str[0] == 0) {
    {
#line 881
    print_short_help();
#line 882
    free_boxargs(abox_start);
    }
#line 883
    return (0);
  }
#line 891
  if (! parse_stdin) {
#line 891
    if (*(argv + argcount)) {
      {
#line 892
      abox_cur = get_boxargs(argc, argv, argcount, abox_cur);
#line 894
      abox_tmp = abox_start;
      }
      {
#line 895
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 895
        if (! ((unsigned long )abox_tmp->next != (unsigned long )abox_cur)) {
#line 895
          goto while_break___0;
        }
#line 896
        abox_tmp = abox_tmp->next;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 898
      abox_tmp->next = (struct argbox *)((void *)0);
#line 899
      free((void *)abox_cur);
#line 900
      abox_cur = (struct argbox *)((void *)0);
      }
    }
  }
#line 903
  abox_tmp = abox_start;
#line 904
  if (! resolve) {
    {
#line 905
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 905
      if (! abox_tmp) {
#line 905
        goto while_break___1;
      }
#line 906
      abox_tmp->resolv = 0;
#line 907
      abox_tmp = abox_tmp->next;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  {
#line 919
  if_start = (struct if_info *)((void *)0);
#line 920
  if_cur = (struct if_info *)((void *)0);
#line 921
  if_start = get_if_ext();
#line 921
  if_cur = if_start;
  }
#line 921
  if (! if_cur) {
    {
#line 922
    printf((char const   */* __restrict  */)"-[INFO : Unable to retrieve interface information]\n");
#line 924
    printf((char const   */* __restrict  */)"-[INFO : Will only parse none interface arguments]\n\n");
    }
  }
#line 928
  if (! parse_stdin) {
    {
#line 929
    ifarg_start = parse_abox(abox_start, if_start);
#line 929
    ifarg_cur = ifarg_start;
    }
  }
#line 931
  if (! ifarg_start) {
#line 931
    if (! parse_stdin) {
      {
#line 932
      printf((char const   */* __restrict  */)"-[FATAL : No valid commandline arguments found]\n\n");
      }
#line 933
      return (-1);
    }
  }
  {
#line 936
  iffound = 0;
#line 937
  index___0 = 0;
#line 938
  ifarg_cur = ifarg_start;
#line 939
  bzero((void *)(oldcmdstr), (size_t )128);
  }
  {
#line 940
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 940
    if (ifarg_cur) {
#line 940
      if (! (! parse_stdin)) {
#line 940
        goto while_break___2;
      }
    } else {
#line 940
      goto while_break___2;
    }
    {
#line 941
    tmp___4 = strlen((char const   *)(ifarg_cur->cmdstr));
    }
#line 941
    if (tmp___4 > 0UL) {
      {
#line 942
      tmp___3 = strcmp((char const   *)(ifarg_cur->cmdstr), (char const   *)(oldcmdstr));
      }
#line 942
      if (tmp___3) {
#line 945
        index___0 = 0;
      } else {
#line 943
        index___0 ++;
      }
    } else {
#line 948
      index___0 = 0;
    }
    {
#line 950
    tmp___5 = out_cmdline(ifarg_cur, v4args, m_argv4, v6args, m_argv6, 0, index___0);
#line 950
    iffound += tmp___5;
#line 951
    strcpy((char */* __restrict  */)(oldcmdstr), (char const   */* __restrict  */)(ifarg_cur->cmdstr));
#line 952
    ifarg_cur = ifarg_cur->next;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 955
  z = 0;
#line 956
  y = 1;
  {
#line 957
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 957
    if (parse_stdin) {
#line 957
      if (! (y > -1)) {
#line 957
        goto while_break___3;
      }
    } else {
#line 957
      goto while_break___3;
    }
    {
#line 958
    tmp___6 = malloc((size_t )128);
#line 958
    stdinarg[0] = (char *)tmp___6;
#line 959
    tmp___7 = malloc((size_t )128);
#line 959
    stdinarg[1] = (char *)tmp___7;
#line 960
    stdinarg[2] = (char *)((void *)0);
#line 961
    x = 0;
    }
    {
#line 961
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 961
      if (! (x < 2)) {
#line 961
        goto while_break___4;
      }
      {
#line 962
      bzero((void *)stdinarg[x], (size_t )128);
#line 961
      x ++;
      }
    }
    while_break___4: /* CIL Label */ ;
    }
    {
#line 963
    y = get_stdin(stdinarg);
    }
#line 964
    if (y > 0) {
#line 965
      m = 2;
#line 966
      if ((int )*(stdinarg[1] + 0) == 0) {
        {
#line 967
        free((void *)stdinarg[1]);
#line 968
        stdinarg[1] = (char *)((void *)0);
#line 969
        m = 1;
        }
      }
      {
#line 971
      abox_cur = get_boxargs(m, stdinarg, 0, abox_cur);
#line 972
      abox_tmp = abox_start;
      }
      {
#line 973
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 973
        if ((unsigned long )abox_tmp->next != (unsigned long )abox_cur) {
#line 973
          if (! ((unsigned long )abox_tmp != (unsigned long )abox_cur)) {
#line 973
            goto while_break___5;
          }
        } else {
#line 973
          goto while_break___5;
        }
#line 974
        abox_tmp = abox_tmp->next;
      }
      while_break___5: /* CIL Label */ ;
      }
      {
#line 976
      abox_tmp->next = (struct argbox *)((void *)0);
#line 977
      free((void *)abox_cur);
#line 978
      abox_cur = (struct argbox *)((void *)0);
#line 980
      abox_tmp = abox_start;
      }
#line 981
      if (! resolve) {
        {
#line 982
        while (1) {
          while_continue___6: /* CIL Label */ ;
#line 982
          if (! abox_tmp) {
#line 982
            goto while_break___6;
          }
#line 983
          abox_tmp->resolv = 0;
#line 984
          abox_tmp = abox_tmp->next;
        }
        while_break___6: /* CIL Label */ ;
        }
      }
      {
#line 988
      ifarg_start = parse_abox(abox_start, if_start);
#line 988
      ifarg_cur = ifarg_start;
      }
#line 990
      if (ifarg_start) {
        {
#line 991
        iffound = 0;
#line 992
        index___0 = 0;
#line 993
        ifarg_cur = ifarg_start;
#line 994
        bzero((void *)(oldcmdstr), (size_t )128);
        }
        {
#line 995
        while (1) {
          while_continue___7: /* CIL Label */ ;
#line 995
          if (! ifarg_cur) {
#line 995
            goto while_break___7;
          }
          {
#line 996
          tmp___9 = strlen((char const   *)(ifarg_cur->cmdstr));
          }
#line 996
          if (tmp___9 > 0UL) {
            {
#line 997
            tmp___8 = strcmp((char const   *)(ifarg_cur->cmdstr), (char const   *)(oldcmdstr));
            }
#line 997
            if (tmp___8) {
#line 1000
              index___0 = 0;
            } else {
#line 998
              index___0 ++;
            }
          } else {
#line 1003
            index___0 = 0;
          }
          {
#line 1005
          tmp___10 = out_cmdline(ifarg_cur, v4args, m_argv4, v6args, m_argv6, 0, index___0);
#line 1005
          iffound += tmp___10;
#line 1006
          strcpy((char */* __restrict  */)(oldcmdstr), (char const   */* __restrict  */)(ifarg_cur->cmdstr));
#line 1007
          ifarg_cur = ifarg_cur->next;
          }
        }
        while_break___7: /* CIL Label */ ;
        }
      }
      {
#line 1011
      z = 1;
#line 1012
      free_if(ifarg_start);
#line 1013
      free_boxargs(abox_start);
#line 1014
      tmp___11 = malloc(sizeof(struct argbox ));
#line 1014
      abox_cur = (struct argbox *)tmp___11;
#line 1014
      abox_start = abox_cur;
#line 1015
      bzero((void *)((char *)abox_cur), (size_t )128);
#line 1016
      abox_cur->type = 0;
#line 1017
      abox_cur->resolv = 0;
#line 1018
      abox_cur->next = (struct argbox *)((void *)0);
      }
    }
#line 1020
    x = 0;
    {
#line 1020
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 1020
      if (! (x < 2)) {
#line 1020
        goto while_break___8;
      }
#line 1021
      if (stdinarg[x]) {
        {
#line 1022
        free((void *)stdinarg[x]);
#line 1023
        stdinarg[x] = (char *)((void *)0);
        }
      }
#line 1020
      x ++;
    }
    while_break___8: /* CIL Label */ ;
    }
#line 1026
    if (y == -1) {
      {
#line 1027
      printf((char const   */* __restrict  */)"\n-[ERR : Problem parsing stdin]\n\n");
      }
    }
  }
  while_break___3: /* CIL Label */ ;
  }
#line 1029
  if (parse_stdin) {
    {
#line 1030
    free((void *)stdinarg[0]);
#line 1031
    free((void *)stdinarg[1]);
    }
  }
#line 1034
  if (! z) {
#line 1034
    if (parse_stdin) {
      {
#line 1035
      printf((char const   */* __restrict  */)"-[FATAL : No arguments found on stdin]\n\n");
      }
    }
  }
#line 1037
  if (! parse_stdin) {
    {
#line 1038
    free_if(ifarg_start);
    }
  }
  {
#line 1039
  free_if(if_start);
  }
#line 1041
  return (iffound);
}
}
#line 144 "/usr/include/netdb.h"
extern struct hostent *gethostbyname(char const   *__name ) ;
#line 155
extern struct hostent *gethostbyname2(char const   *__name , int __af ) ;
#line 662
extern int getaddrinfo(char const   * __restrict  __name , char const   * __restrict  __service ,
                       struct addrinfo  const  * __restrict  __req , struct addrinfo ** __restrict  __pai ) ;
#line 668
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) freeaddrinfo)(struct addrinfo *__ai ) ;
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 364 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 183 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1), __leaf__)) strtol)(char const   * __restrict  __nptr ,
                                                                                              char ** __restrict  __endptr ,
                                                                                              int __base ) ;
#line 187
extern  __attribute__((__nothrow__)) unsigned long ( __attribute__((__nonnull__(1),
__leaf__)) strtoul)(char const   * __restrict  __nptr , char ** __restrict  __endptr ,
                    int __base ) ;
#line 66 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 53 "/usr/include/arpa/inet.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) inet_ntoa)(struct in_addr __in ) ;
#line 64
extern  __attribute__((__nothrow__)) char const   *( __attribute__((__leaf__)) inet_ntop)(int __af ,
                                                                                          void const   * __restrict  __cp ,
                                                                                          char * __restrict  __buf ,
                                                                                          socklen_t __len ) ;
#line 216 "../include/sub.h"
int count(char *buf , char ch ) ;
#line 221
int quadtonum(char *quad___0 , u_int32_t *num ) ;
#line 224
int parse_addr(struct if_info *ifi ) ;
#line 227
int split_ipv6addr(char *addr , struct ipv6_split *spstr ) ;
#line 228
int validate_s_v6addr(char *addr , int type ) ;
#line 229
int getcolon(char *addr , int pos , int type ) ;
#line 230
int v6addrtonum(struct ipv6_split spstr , struct v6addr *in6_addr , int type ) ;
#line 231
int v6masktonum(char *nmask , int *nmaskbits , struct sip_in6_addr *in6_addr ) ;
#line 233
int v6addrtoprefix(struct v6addr *in6_addr ) ;
#line 234
int v6addrtosuffix(struct v6addr *in6_addr ) ;
#line 235
int v6addrtobroadcast(struct v6addr *in6_addr ) ;
#line 236
void v6_type(struct v6addr *in6_addr ) ;
#line 237
void v6_comment(struct v6addr *in6_addr ) ;
#line 238
int v6verifyv4(struct sip_in6_addr addr ) ;
#line 241
struct dnsresp *new_dnsresp(struct dnsresp *d_resp ) ;
#line 54 "/home/june/repo/benchmarks/collector/temp/sipcalc-1.1.5/src/sub-func.c"
int count(char *buf , char ch ) 
{ 
  int x ;
  int y ;
  size_t tmp ;

  {
#line 59
  y = 0;
#line 60
  x = 0;
  {
#line 60
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 60
    tmp = strlen((char const   *)buf);
    }
#line 60
    if (! ((size_t )x < tmp)) {
#line 60
      goto while_break;
    }
#line 61
    if ((int )*(buf + x) == (int )ch) {
#line 62
      y ++;
    }
#line 60
    x ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 64
  return (y);
}
}
#line 71 "/home/june/repo/benchmarks/collector/temp/sipcalc-1.1.5/src/sub-func.c"
int validate_v4addr(char *addr ) 
{ 
  int x ;
  int y ;
  int z ;
  int m ;
  char buf[16] ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;

  {
  {
#line 77
  tmp = strlen((char const   *)addr);
  }
#line 77
  if (tmp < 7UL) {
#line 78
    return (0);
  } else {
    {
#line 77
    tmp___0 = strlen((char const   *)addr);
    }
#line 77
    if (tmp___0 > 15UL) {
#line 78
      return (0);
    }
  }
#line 80
  x = 0;
#line 81
  y = 0;
  {
#line 82
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 82
    tmp___1 = strlen((char const   *)addr);
    }
#line 82
    if (! ((size_t )x < tmp___1)) {
#line 82
      goto while_break;
    }
#line 83
    if ((int )*(addr + x) == 46) {
#line 84
      y ++;
    }
#line 85
    x ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 87
  if (y != 3) {
#line 88
    return (0);
  }
#line 90
  x = 0;
#line 91
  y = 0;
  {
#line 92
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 92
    tmp___3 = strlen((char const   *)addr);
    }
#line 92
    if (! ((size_t )x < tmp___3)) {
#line 92
      goto while_break___0;
    }
#line 93
    z = 0;
#line 94
    y = 0;
    {
#line 95
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 95
      tmp___2 = strlen("0123456789.");
      }
#line 95
      if ((size_t )z < tmp___2) {
#line 95
        if (! (! y)) {
#line 95
          goto while_break___1;
        }
      } else {
#line 95
        goto while_break___1;
      }
#line 96
      if ((int )*(addr + x) == (int )*("0123456789." + z)) {
#line 97
        y = 1;
      }
#line 98
      z ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 100
    if (! y) {
#line 101
      return (0);
    }
#line 102
    x ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 105
  if ((int )*(addr + 0) == 46) {
#line 106
    return (0);
  } else {
    {
#line 105
    tmp___4 = strlen((char const   *)addr);
    }
#line 105
    if ((int )*(addr + (tmp___4 - 1UL)) == 46) {
#line 106
      return (0);
    }
  }
#line 108
  x = 0;
  {
#line 109
  while (1) {
    while_continue___2: /* CIL Label */ ;
    {
#line 109
    tmp___5 = strlen((char const   *)addr);
    }
#line 109
    if (! ((size_t )x < tmp___5 - 1UL)) {
#line 109
      goto while_break___2;
    }
#line 110
    if ((int )*(addr + x) == 46) {
#line 110
      if ((int )*(addr + (x + 1)) == 46) {
#line 111
        return (0);
      }
    }
#line 112
    x ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 115
  y = 0;
#line 116
  x = 0;
  {
#line 116
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 116
    if (! (x < 4)) {
#line 116
      goto while_break___3;
    }
    {
#line 117
    z = 0;
#line 118
    bzero((void *)(buf), (size_t )16);
    }
    {
#line 119
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 119
      if ((int )*(addr + y) != 46) {
        {
#line 119
        tmp___6 = strlen((char const   *)addr);
        }
#line 119
        if (! ((size_t )y < tmp___6)) {
#line 119
          goto while_break___4;
        }
      } else {
#line 119
        goto while_break___4;
      }
#line 120
      buf[z] = *(addr + y);
#line 121
      y ++;
#line 122
      z ++;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 124
    if (z > 3) {
#line 125
      return (0);
    }
    {
#line 126
    m = atoi((char const   *)(buf));
    }
#line 127
    if (m < 0) {
#line 128
      return (0);
    } else
#line 127
    if (m > 255) {
#line 128
      return (0);
    }
#line 129
    y ++;
#line 116
    x ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 132
  return (1);
}
}
#line 141 "/home/june/repo/benchmarks/collector/temp/sipcalc-1.1.5/src/sub-func.c"
int validate_netmask(char *in_addr ) 
{ 
  int x ;
  int y ;
  int z ;
  int m ;
  char addr[16] ;
  char *sl ;
  u_int32_t sm ;
  size_t tmp ;
  unsigned short const   **tmp___0 ;
  size_t tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  size_t tmp___7 ;

  {
  {
#line 149
  tmp = strlen((char const   *)in_addr);
  }
#line 149
  if (tmp > 18UL) {
#line 150
    return (0);
  }
#line 152
  x = 0;
#line 153
  y = 0;
#line 154
  z = 0;
  {
#line 155
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 155
    tmp___1 = strlen((char const   *)in_addr);
    }
#line 155
    if ((size_t )x < tmp___1) {
#line 155
      if (! (! y)) {
#line 155
        goto while_break;
      }
    } else {
#line 155
      goto while_break;
    }
    {
#line 156
    tmp___0 = __ctype_b_loc();
    }
#line 156
    if (! ((int const   )*(*tmp___0 + (int )*(in_addr + x)) & 4096)) {
#line 156
      if ((int )*(in_addr + x) != 120) {
#line 156
        if ((int )*(in_addr + x) != 88) {
#line 158
          y = 1;
        }
      }
    }
#line 159
    if ((int )*(in_addr + x) == 120) {
#line 160
      z ++;
#line 161
      y = 0;
    } else
#line 159
    if ((int )*(in_addr + x) == 88) {
#line 160
      z ++;
#line 161
      y = 0;
    }
#line 163
    x ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 166
  x = 0;
#line 167
  if (! y) {
#line 167
    if (z == 1) {
#line 168
      x = 0;
#line 169
      if ((int )*(in_addr + 0) == 120) {
#line 170
        x = 1;
      } else
#line 169
      if ((int )*(in_addr + 0) == 88) {
#line 170
        x = 1;
      }
#line 171
      if (! x) {
#line 172
        if ((int )*(in_addr + 0) == 48) {
#line 172
          if ((int )*(in_addr + 1) == 120) {
#line 174
            x = 1;
          } else
#line 172
          if ((int )*(in_addr + 1) == 88) {
#line 174
            x = 1;
          }
        }
      }
    }
  }
#line 177
  if (x == 1) {
#line 178
    return (3);
  }
  {
#line 180
  bzero((void *)(addr), (size_t )16);
#line 181
  tmp___2 = strstr((char const   *)in_addr, "/");
  }
#line 181
  if (tmp___2) {
#line 182
    x = 0;
    {
#line 183
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 183
      if ((int )*(in_addr + x) != 47) {
#line 183
        if (! (x < 15)) {
#line 183
          goto while_break___0;
        }
      } else {
#line 183
        goto while_break___0;
      }
#line 184
      addr[x] = *(in_addr + x);
#line 185
      x ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  } else {
    {
#line 188
    strncpy((char */* __restrict  */)(addr), (char const   */* __restrict  */)in_addr,
            (size_t )16);
    }
  }
  {
#line 194
  tmp___3 = quadtonum(addr, & sm);
  }
#line 194
  if (tmp___3) {
#line 195
    return (0);
  }
  {
#line 197
  sl = strstr((char const   *)in_addr, "/");
  }
#line 197
  if (! sl) {
#line 198
    y = 0;
#line 199
    x = 0;
    {
#line 199
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 199
      if (! (x < 32)) {
#line 199
        goto while_break___1;
      }
#line 200
      if (! y) {
#line 200
        if (! ((sm >> (31 - x)) & 1U)) {
#line 201
          y = 1;
        }
      }
#line 202
      if (y == 1) {
#line 202
        if ((sm >> (31 - x)) & 1U) {
#line 203
          y = 2;
        }
      }
#line 199
      x ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 205
    if (y == 2) {
#line 206
      return (-1);
    }
#line 211
    return (1);
  }
  {
#line 214
  sl ++;
#line 215
  tmp___4 = strlen((char const   *)sl);
  }
#line 215
  if (tmp___4 < 1UL) {
#line 216
    return (0);
  } else {
    {
#line 215
    tmp___5 = strlen((char const   *)sl);
    }
#line 215
    if (tmp___5 > 2UL) {
#line 216
      return (0);
    }
  }
#line 218
  if ((int )*(sl + 0) == 46) {
#line 219
    return (0);
  } else
#line 218
  if ((int )*(sl + 1) == 46) {
#line 219
    return (0);
  }
#line 221
  x = 0;
#line 222
  y = 0;
  {
#line 223
  while (1) {
    while_continue___2: /* CIL Label */ ;
    {
#line 223
    tmp___7 = strlen((char const   *)sl);
    }
#line 223
    if (! ((size_t )x < tmp___7)) {
#line 223
      goto while_break___2;
    }
#line 224
    z = 0;
#line 225
    y = 0;
    {
#line 226
    while (1) {
      while_continue___3: /* CIL Label */ ;
      {
#line 226
      tmp___6 = strlen("0123456789.");
      }
#line 226
      if ((size_t )z < tmp___6) {
#line 226
        if (! (! y)) {
#line 226
          goto while_break___3;
        }
      } else {
#line 226
        goto while_break___3;
      }
#line 227
      if ((int )*(sl + x) == (int )*("0123456789." + z)) {
#line 228
        y = 1;
      }
#line 229
      z ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 231
    if (! y) {
#line 232
      return (0);
    }
#line 233
    x ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 236
  m = atoi((char const   *)sl);
  }
#line 237
  if (m < 0) {
#line 238
    return (0);
  } else
#line 237
  if (m > 32) {
#line 238
    return (0);
  }
#line 240
  return (2);
}
}
#line 243 "/home/june/repo/benchmarks/collector/temp/sipcalc-1.1.5/src/sub-func.c"
int getsplitnumv4(char *buf , u_int32_t *splitmask ) 
{ 
  int x ;
  int y ;
  u_int32_t sm ;
  size_t tmp ;
  unsigned long tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  size_t tmp___3 ;

  {
  {
#line 249
  tmp = strlen((char const   *)buf);
  }
#line 249
  if (tmp < 1UL) {
#line 250
    return (-1);
  }
  {
#line 252
  tmp___3 = strlen((char const   *)buf);
  }
#line 252
  if (tmp___3 < 4UL) {
#line 253
    if ((int )*(buf + 0) == 47) {
#line 254
      buf ++;
    }
    {
#line 255
    y = atoi((char const   *)buf);
    }
#line 256
    if (y < 1) {
#line 257
      return (-1);
    } else
#line 256
    if (y > 32) {
#line 257
      return (-1);
    }
#line 258
    sm = (u_int32_t )0;
#line 259
    x = 0;
    {
#line 259
    while (1) {
      while_continue: /* CIL Label */ ;
#line 259
      if (! (x < y)) {
#line 259
        goto while_break;
      }
#line 260
      sm |= (unsigned int )(1 << (31 - x));
#line 259
      x ++;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
#line 262
    tmp___2 = strstr((char const   *)buf, ".");
    }
#line 262
    if (tmp___2) {
      {
#line 265
      tmp___1 = quadtonum(buf, & sm);
      }
#line 265
      if (tmp___1) {
#line 266
        return (-1);
      }
    } else {
      {
#line 263
      tmp___0 = strtoul((char const   */* __restrict  */)buf, (char **/* __restrict  */)((char **)((void *)0)),
                        16);
#line 263
      sm = (u_int32_t )tmp___0;
      }
    }
  }
#line 269
  y = 0;
#line 270
  x = 0;
  {
#line 270
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 270
    if (! (x < 32)) {
#line 270
      goto while_break___0;
    }
#line 271
    if (! y) {
#line 271
      if (! ((sm >> (31 - x)) & 1U)) {
#line 272
        y = 1;
      }
    }
#line 273
    if (y == 1) {
#line 273
      if ((sm >> (31 - x)) & 1U) {
#line 274
        y = 2;
      }
    }
#line 270
    x ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 276
  if (y == 2) {
#line 277
    return (-1);
  }
#line 279
  *splitmask = sm;
#line 281
  return (0);
}
}
#line 284 "/home/june/repo/benchmarks/collector/temp/sipcalc-1.1.5/src/sub-func.c"
int getsplitnumv6(char *buf , struct sip_in6_addr *splitmask , int *v6splitnum ) 
{ 
  int x ;
  int y ;
  size_t tmp ;
  size_t tmp___0 ;

  {
  {
#line 289
  tmp = strlen((char const   *)buf);
  }
#line 289
  if (tmp < 1UL) {
#line 290
    return (-1);
  }
  {
#line 291
  tmp___0 = strlen((char const   *)buf);
  }
#line 291
  if (tmp___0 > 4UL) {
#line 292
    return (-1);
  }
#line 294
  if ((int )*(buf + 0) == 47) {
#line 295
    buf ++;
  }
  {
#line 296
  y = atoi((char const   *)buf);
  }
#line 297
  if (y < 1) {
#line 298
    return (-1);
  } else
#line 297
  if (y > 128) {
#line 298
    return (-1);
  }
  {
#line 299
  *v6splitnum = y;
#line 300
  x = v6masktonum(buf, & y, splitmask);
  }
#line 302
  return (0);
}
}
#line 305 "/home/june/repo/benchmarks/collector/temp/sipcalc-1.1.5/src/sub-func.c"
int quadtonum(char *quad___0 , u_int32_t *num ) 
{ 
  char buf[128] ;
  int x ;
  int y ;
  int z ;
  int tmp ;
  size_t tmp___0 ;

  {
  {
#line 311
  tmp = validate_v4addr(quad___0);
  }
#line 311
  if (! tmp) {
#line 312
    return (-1);
  }
  {
#line 314
  bzero((void *)(buf), (size_t )128);
#line 315
  x = 0;
  }
  {
#line 316
  while (1) {
    while_continue: /* CIL Label */ ;
#line 316
    if (! ((int )*(quad___0 + x) != 46)) {
#line 316
      goto while_break;
    }
#line 317
    buf[x] = *(quad___0 + x);
#line 318
    x ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 320
  *num = (u_int32_t )0;
#line 321
  x ++;
#line 322
  y = 0;
  {
#line 322
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 322
    if (! (y < 4)) {
#line 322
      goto while_break___0;
    }
    {
#line 323
    z = atoi((char const   *)(buf));
    }
#line 324
    if (z > 255) {
#line 325
      return (-1);
    } else
#line 324
    if (z < 0) {
#line 325
      return (-1);
    }
    {
#line 326
    *num |= (unsigned int )(z << 8 * (3 - y));
#line 327
    bzero((void *)(buf), (size_t )128);
#line 328
    z = 0;
    }
    {
#line 329
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 329
      if ((int )*(quad___0 + x) != 46) {
#line 329
        if ((int )*(quad___0 + x) != 0) {
          {
#line 329
          tmp___0 = strlen((char const   *)quad___0);
          }
#line 329
          if (! ((size_t )x < tmp___0)) {
#line 329
            goto while_break___1;
          }
        } else {
#line 329
          goto while_break___1;
        }
      } else {
#line 329
        goto while_break___1;
      }
#line 330
      buf[z] = *(quad___0 + x);
#line 331
      x ++;
#line 332
      z ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 334
    x ++;
#line 322
    y ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 337
  return (0);
}
}
#line 344 "/home/june/repo/benchmarks/collector/temp/sipcalc-1.1.5/src/sub-func.c"
static char quad[17]  ;
#line 340 "/home/june/repo/benchmarks/collector/temp/sipcalc-1.1.5/src/sub-func.c"
char *numtoquad(u_int32_t num ) 
{ 
  int a[4] ;
  int x ;

  {
#line 346
  x = 0;
  {
#line 346
  while (1) {
    while_continue: /* CIL Label */ ;
#line 346
    if (! (x < 4)) {
#line 346
      goto while_break;
    }
#line 347
    a[x] = (int )((num >> 8 * (3 - x)) & 255U);
#line 346
    x ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 348
  bzero((void *)(quad), (size_t )17);
#line 349
  snprintf((char */* __restrict  */)(quad), (size_t )16, (char const   */* __restrict  */)"%d.%d.%d.%d",
           a[0], a[1], a[2], a[3]);
  }
#line 351
  return (quad);
}
}
#line 357 "/home/june/repo/benchmarks/collector/temp/sipcalc-1.1.5/src/sub-func.c"
static char bitmap[36]  ;
#line 354 "/home/june/repo/benchmarks/collector/temp/sipcalc-1.1.5/src/sub-func.c"
char *numtobitmap(u_int32_t num ) 
{ 
  int x ;
  int y ;
  int z ;

  {
  {
#line 360
  bzero((void *)(bitmap), (size_t )36);
#line 361
  y = 1;
#line 362
  z = 0;
#line 363
  x = 0;
  }
  {
#line 363
  while (1) {
    while_continue: /* CIL Label */ ;
#line 363
    if (! (x < 32)) {
#line 363
      goto while_break;
    }
#line 364
    if (! ((num >> (31 - x)) & 1U)) {
#line 365
      bitmap[z] = (char )'0';
    } else {
#line 367
      bitmap[z] = (char )'1';
    }
#line 368
    if (y == 8) {
#line 368
      if (z < 34) {
#line 369
        z ++;
#line 370
        bitmap[z] = (char )'.';
#line 371
        y = 0;
      }
    }
#line 373
    y ++;
#line 374
    z ++;
#line 363
    x ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 377
  return (bitmap);
}
}
#line 380 "/home/june/repo/benchmarks/collector/temp/sipcalc-1.1.5/src/sub-func.c"
int parse_addr(struct if_info *ifi ) 
{ 
  char buf[128] ;
  char buf2[128] ;
  char *s_find ;
  int x ;
  int y ;
  int z ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  unsigned long tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;

  {
  {
#line 387
  bzero((void *)(buf), (size_t )128);
#line 388
  bzero((void *)(buf2), (size_t )128);
#line 389
  ifi->v4ad.n_nmaskbits = 0;
  }
#line 394
  if ((int )ifi->p_v4nmask[0] == 0) {
    {
#line 398
    s_find = strstr((char const   *)(ifi->p_v4addr), "/");
    }
#line 398
    if (s_find) {
#line 402
      *s_find = (char )'\000';
#line 403
      s_find ++;
#line 404
      if (! *s_find) {
#line 405
        return (-1);
      }
      {
#line 406
      tmp = strlen((char const   *)s_find);
      }
#line 406
      if (tmp > 2UL) {
#line 407
        return (-2);
      }
#line 409
      x = 0;
#line 410
      y = 0;
      {
#line 411
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 411
        tmp___1 = strlen((char const   *)s_find);
        }
#line 411
        if (! ((size_t )x < tmp___1)) {
#line 411
          goto while_break;
        }
#line 412
        y = 0;
#line 413
        z = 0;
        {
#line 414
        while (1) {
          while_continue___0: /* CIL Label */ ;
          {
#line 414
          tmp___0 = strlen("0123456789");
          }
#line 414
          if ((size_t )z < tmp___0) {
#line 414
            if (! (! y)) {
#line 414
              goto while_break___0;
            }
          } else {
#line 414
            goto while_break___0;
          }
#line 415
          if ((int )*(s_find + x) == (int )*("0123456789" + z)) {
#line 416
            y = 1;
          }
#line 417
          z ++;
        }
        while_break___0: /* CIL Label */ ;
        }
#line 419
        if (! y) {
#line 420
          return (-2);
        }
#line 421
        x ++;
      }
      while_break: /* CIL Label */ ;
      }
#line 424
      buf[0] = *s_find;
#line 425
      *s_find = (char )'\000';
#line 426
      s_find ++;
#line 427
      if (*s_find) {
#line 428
        buf[1] = *s_find;
#line 429
        *s_find = (char )'\000';
      }
      {
#line 432
      ifi->v4ad.n_nmaskbits = atoi((char const   *)(buf));
#line 434
      ifi->v4ad.n_nmask = (u_int32_t )0;
#line 435
      x = 0;
      }
      {
#line 435
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 435
        if (! (x < ifi->v4ad.n_nmaskbits)) {
#line 435
          goto while_break___1;
        }
#line 436
        ifi->v4ad.n_nmask |= (unsigned int )(1 << (31 - x));
#line 435
        x ++;
      }
      while_break___1: /* CIL Label */ ;
      }
    } else {
#line 399
      ifi->v4ad.n_nmask = 4294967295U;
#line 400
      ifi->v4ad.n_nmaskbits = 32;
    }
  } else {
    {
#line 443
    tmp___4 = strstr((char const   *)(ifi->p_v4nmask), ".");
    }
#line 443
    if (tmp___4) {
      {
#line 450
      tmp___3 = quadtonum(ifi->p_v4nmask, & ifi->v4ad.n_nmask);
      }
#line 450
      if (tmp___3) {
#line 451
        return (-2);
      }
    } else {
      {
#line 444
      tmp___2 = strtoul((char const   */* __restrict  */)(ifi->p_v4nmask), (char **/* __restrict  */)((char **)((void *)0)),
                        16);
#line 444
      ifi->v4ad.n_nmask = (u_int32_t )tmp___2;
      }
    }
  }
#line 455
  if (ifi->v4ad.n_nmaskbits < 0) {
#line 456
    return (-2);
  } else
#line 455
  if (ifi->v4ad.n_nmaskbits > 32) {
#line 456
    return (-2);
  }
  {
#line 461
  tmp___5 = quadtonum(ifi->p_v4addr, & ifi->v4ad.n_haddr);
  }
#line 461
  if (tmp___5) {
#line 462
    return (-1);
  }
#line 464
  return (0);
}
}
#line 473 "/home/june/repo/benchmarks/collector/temp/sipcalc-1.1.5/src/sub-func.c"
int get_addrv4(struct if_info *ifi ) 
{ 
  int x ;
  int y ;

  {
#line 478
  x = 0;
#line 479
  if (! ifi->name[0]) {
    {
#line 480
    x = parse_addr(ifi);
    }
  }
#line 482
  if (x) {
#line 483
    return (x);
  }
#line 488
  ifi->v4ad.n_nmaskbits = 0;
#line 489
  x = 0;
  {
#line 489
  while (1) {
    while_continue: /* CIL Label */ ;
#line 489
    if (! (x < 32)) {
#line 489
      goto while_break;
    }
#line 490
    if ((ifi->v4ad.n_nmask >> x) & 1U) {
#line 491
      (ifi->v4ad.n_nmaskbits) ++;
    }
#line 489
    x ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 493
  if (ifi->v4ad.n_nmaskbits < 0) {
#line 494
    return (-2);
  } else
#line 493
  if (ifi->v4ad.n_nmaskbits > 32) {
#line 494
    return (-2);
  }
#line 499
  y = 0;
#line 500
  x = 0;
  {
#line 500
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 500
    if (! (x < 32)) {
#line 500
      goto while_break___0;
    }
#line 501
    if (! y) {
#line 501
      if (! ((ifi->v4ad.n_nmask >> (31 - x)) & 1U)) {
#line 502
        y = 1;
      }
    }
#line 503
    if (y == 1) {
#line 503
      if ((ifi->v4ad.n_nmask >> (31 - x)) & 1U) {
#line 504
        y = 2;
      }
    }
#line 500
    x ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 506
  if (y == 2) {
#line 507
    return (-2);
  }
  {
#line 512
  bzero((void *)(ifi->v4ad.class_remark), (size_t )64);
#line 513
  x = (int )(ifi->v4ad.n_haddr >> 24);
#line 514
  ifi->v4ad.n_cnaddr = (u_int32_t )0;
  }
#line 515
  if (! (x & 128)) {
#line 516
    ifi->v4ad.class = (char )'A';
#line 517
    ifi->v4ad.n_cnmask = 4278190080U;
  }
#line 519
  if ((x & 192) == 128) {
#line 520
    ifi->v4ad.class = (char )'B';
#line 521
    ifi->v4ad.n_cnmask = 4294901760U;
  }
#line 523
  if ((x & 224) == 192) {
#line 524
    ifi->v4ad.class = (char )'C';
#line 525
    ifi->v4ad.n_cnmask = 4294967040U;
  }
#line 527
  if ((x & 240) == 224) {
    {
#line 528
    ifi->v4ad.class = (char )'D';
#line 529
    snprintf((char */* __restrict  */)(ifi->v4ad.class_remark), (size_t )64, (char const   */* __restrict  */)" (multicast network)");
#line 530
    ifi->v4ad.n_cnmask = ifi->v4ad.n_nmask;
    }
  }
#line 532
  if ((x & 248) == 240) {
    {
#line 533
    ifi->v4ad.class = (char )'E';
#line 534
    snprintf((char */* __restrict  */)(ifi->v4ad.class_remark), (size_t )64, (char const   */* __restrict  */)" (reserved for future use)");
#line 536
    ifi->v4ad.n_cnmask = ifi->v4ad.n_nmask;
    }
  }
#line 538
  if ((int )ifi->v4ad.class == 0) {
    {
#line 539
    ifi->v4ad.n_cnmask = ifi->v4ad.n_nmask;
#line 540
    snprintf((char */* __restrict  */)(ifi->v4ad.class_remark), (size_t )64, (char const   */* __restrict  */)"Nonexistant");
    }
  }
#line 546
  ifi->v4ad.n_naddr = ifi->v4ad.n_haddr & ifi->v4ad.n_nmask;
#line 547
  ifi->v4ad.n_cnaddr = ifi->v4ad.n_haddr & ifi->v4ad.n_cnmask;
#line 552
  ifi->v4ad.n_broadcast = (4294967295U - ifi->v4ad.n_nmask) + ifi->v4ad.n_naddr;
#line 555
  return (0);
}
}
#line 564 "/home/june/repo/benchmarks/collector/temp/sipcalc-1.1.5/src/sub-func.c"
int get_addrv6(struct if_info *ifi ) 
{ 
  int x ;

  {
  {
#line 569
  x = mk_ipv6addr(& ifi->v6ad, ifi->p_v6addr);
  }
#line 570
  if (x < 0) {
#line 571
    return (-1);
  }
#line 573
  return (0);
}
}
#line 576 "/home/june/repo/benchmarks/collector/temp/sipcalc-1.1.5/src/sub-func.c"
int split_ipv6addr(char *addr , struct ipv6_split *spstr ) 
{ 
  char *split ;
  int x ;
  int y ;
  int z ;
  size_t tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  size_t tmp___7 ;
  size_t tmp___8 ;
  int tmp___9 ;
  size_t tmp___10 ;
  size_t tmp___11 ;
  size_t tmp___12 ;
  size_t tmp___13 ;

  {
  {
#line 582
  split = strstr((char const   *)addr, "/");
  }
#line 583
  if (split) {
    {
#line 583
    tmp___1 = count(addr, (char )'/');
    }
#line 583
    if (tmp___1 == 1) {
      {
#line 584
      tmp = strlen((char const   *)split);
      }
#line 584
      if (tmp > 1UL) {
        {
#line 584
        tmp___0 = strlen((char const   *)split);
        }
#line 584
        if (tmp___0 < 5UL) {
          {
#line 585
          split ++;
#line 586
          strncpy((char */* __restrict  */)(spstr->nmask), (char const   */* __restrict  */)split,
                  (size_t )3);
          }
        }
      }
    }
  }
  {
#line 590
  x = 0;
#line 591
  y = 0;
#line 592
  split = strstr((char const   *)addr, ".");
  }
#line 593
  if (split) {
    {
#line 594
    tmp___2 = strlen((char const   *)split);
#line 594
    x = (int )tmp___2;
    }
  }
  {
#line 595
  split = strstr((char const   *)addr, ":");
  }
#line 596
  if (split) {
    {
#line 597
    tmp___3 = strlen((char const   *)split);
#line 597
    y = (int )tmp___3;
    }
  }
#line 598
  if (x < y) {
#line 599
    x = 1;
  } else {
#line 601
    x = 0;
  }
  {
#line 603
  tmp___9 = count(addr, (char )'.');
  }
#line 603
  if (tmp___9 == 3) {
#line 603
    if (x) {
      {
#line 604
      split = strstr((char const   *)addr, ".");
#line 605
      tmp___4 = strlen((char const   *)addr);
#line 605
      tmp___5 = strlen((char const   *)split);
#line 605
      x = (int )(tmp___4 - tmp___5);
      }
      {
#line 606
      while (1) {
        while_continue: /* CIL Label */ ;
#line 606
        if (! ((int )*(addr + x) != 58)) {
#line 606
          goto while_break;
        }
#line 607
        x --;
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 608
      x ++;
#line 609
      split = strstr((char const   *)addr, "/");
      }
#line 610
      if (split) {
        {
#line 611
        tmp___6 = strlen((char const   *)addr);
#line 611
        tmp___7 = strlen((char const   *)split);
#line 611
        y = (int )(tmp___6 - tmp___7);
        }
      } else {
        {
#line 613
        tmp___8 = strlen((char const   *)addr);
#line 613
        y = (int )tmp___8;
        }
      }
#line 614
      if (y - x >= 7) {
#line 614
        if (y - x <= 15) {
#line 615
          z = 0;
          {
#line 615
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 615
            if (! (z < y - x)) {
#line 615
              goto while_break___0;
            }
#line 616
            spstr->ipv4addr[z] = *(addr + (x + z));
#line 615
            z ++;
          }
          while_break___0: /* CIL Label */ ;
          }
        }
      }
    }
  }
  {
#line 620
  tmp___10 = strlen((char const   *)addr);
#line 620
  tmp___11 = strlen((char const   *)(spstr->ipv4addr));
#line 620
  tmp___12 = strlen((char const   *)(spstr->nmask));
#line 620
  x = (int )(tmp___10 - (tmp___11 + tmp___12));
#line 621
  tmp___13 = strlen((char const   *)(spstr->nmask));
  }
#line 621
  if (tmp___13 > 0UL) {
#line 622
    x --;
  }
#line 623
  if (x > 1) {
#line 623
    if (x < 40) {
      {
#line 624
      strncpy((char */* __restrict  */)(spstr->ipv6addr), (char const   */* __restrict  */)addr,
              (size_t )x);
      }
    }
  }
#line 626
  return (0);
}
}
#line 629 "/home/june/repo/benchmarks/collector/temp/sipcalc-1.1.5/src/sub-func.c"
int validate_s_v6addr(char *addr , int type ) 
{ 
  int x ;
  int y ;
  int z ;
  int numcolon ;
  int compressed ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  size_t tmp___7 ;
  size_t tmp___8 ;

  {
  {
#line 636
  tmp = strlen((char const   *)addr);
  }
#line 636
  if (tmp < 2UL) {
#line 637
    return (-1);
  }
  {
#line 639
  tmp___0 = strlen((char const   *)addr);
  }
#line 639
  if (tmp___0 > 39UL) {
#line 640
    return (-1);
  }
#line 642
  x = 0;
#line 643
  y = 0;
  {
#line 644
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 644
    tmp___2 = strlen((char const   *)addr);
    }
#line 644
    if (! ((size_t )x < tmp___2)) {
#line 644
      goto while_break;
    }
#line 645
    y = 0;
#line 646
    z = 0;
    {
#line 647
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 647
      tmp___1 = strlen("0123456789ABCDEFabcdef:");
      }
#line 647
      if ((size_t )z < tmp___1) {
#line 647
        if (! (! y)) {
#line 647
          goto while_break___0;
        }
      } else {
#line 647
        goto while_break___0;
      }
#line 648
      if ((int )*(addr + x) == (int )*("0123456789ABCDEFabcdef:" + z)) {
#line 649
        y = 1;
      }
#line 650
      z ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 652
    if (! y) {
#line 653
      return (-1);
    }
#line 654
    x ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 657
  x = 0;
#line 658
  y = 0;
  {
#line 659
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 659
    tmp___3 = strlen((char const   *)addr);
    }
#line 659
    if (! ((size_t )x < tmp___3)) {
#line 659
      goto while_break___1;
    }
#line 660
    if ((int )*(addr + x) == 58) {
#line 661
      y ++;
    } else {
#line 663
      y = 0;
    }
#line 664
    if (y == 3) {
#line 665
      return (-1);
    }
#line 667
    x ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 670
  if ((int )*(addr + 0) == 58) {
#line 670
    if ((int )*(addr + 1) != 58) {
#line 671
      return (-1);
    }
  }
#line 672
  if (type == 1) {
    {
#line 672
    tmp___4 = strlen((char const   *)addr);
    }
#line 672
    if ((int )*(addr + (tmp___4 - 1UL)) == 58) {
      {
#line 672
      tmp___5 = strlen((char const   *)addr);
      }
#line 672
      if ((int )*(addr + (tmp___5 - 2UL)) != 58) {
#line 674
        return (-1);
      }
    }
  }
#line 676
  numcolon = 0;
#line 677
  x = 0;
  {
#line 677
  while (1) {
    while_continue___2: /* CIL Label */ ;
    {
#line 677
    tmp___6 = strlen((char const   *)addr);
    }
#line 677
    if (! ((size_t )x < tmp___6)) {
#line 677
      goto while_break___2;
    }
#line 678
    if ((int )*(addr + x) == 58) {
#line 679
      numcolon ++;
    }
#line 677
    x ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 682
  compressed = 0;
#line 683
  x = 0;
  {
#line 684
  while (1) {
    while_continue___3: /* CIL Label */ ;
    {
#line 684
    tmp___7 = strlen((char const   *)addr);
    }
#line 684
    if (! ((size_t )x < tmp___7 - 1UL)) {
#line 684
      goto while_break___3;
    }
#line 685
    if ((int )*(addr + x) == 58) {
#line 685
      if ((int )*(addr + (x + 1)) == 58) {
#line 686
        compressed ++;
      }
    }
#line 687
    x ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 690
  if (compressed > 1) {
#line 691
    return (-1);
  }
#line 693
  if (! compressed) {
#line 693
    if (numcolon != 7) {
#line 693
      if (type == 1) {
#line 694
        return (-1);
      }
    }
  }
#line 696
  if (! compressed) {
#line 696
    if (numcolon != 6) {
#line 696
      if (type == 2) {
#line 697
        return (-1);
      }
    }
  }
#line 699
  if (compressed) {
#line 699
    if (type == 1) {
#line 700
      if (numcolon > 7) {
#line 701
        return (-1);
      }
    }
  }
#line 704
  if (compressed) {
#line 704
    if (type == 2) {
#line 705
      if (numcolon > 6) {
#line 706
        return (-1);
      }
    }
  }
#line 709
  y = 0;
#line 710
  x = 0;
  {
#line 710
  while (1) {
    while_continue___4: /* CIL Label */ ;
    {
#line 710
    tmp___8 = strlen((char const   *)addr);
    }
#line 710
    if (! ((size_t )x < tmp___8)) {
#line 710
      goto while_break___4;
    }
#line 711
    if ((int )*(addr + x) != 58) {
#line 712
      y ++;
    } else {
#line 714
      y = 0;
    }
#line 716
    if (y > 4) {
#line 717
      goto while_break___4;
    }
#line 710
    x ++;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 720
  if (y > 4) {
#line 721
    return (-1);
  }
#line 723
  return (0);
}
}
#line 726 "/home/june/repo/benchmarks/collector/temp/sipcalc-1.1.5/src/sub-func.c"
int getcolon(char *addr , int pos , int type ) 
{ 
  int x ;
  int y ;
  int compressed ;
  int cstart ;
  int cend ;
  int max ;
  char str[5] ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  size_t tmp___7 ;
  long tmp___8 ;

  {
#line 735
  if (type == 1) {
#line 736
    max = 7;
  }
#line 737
  if (type == 2) {
#line 738
    max = 5;
  }
#line 740
  compressed = 0;
#line 741
  x = 0;
  {
#line 742
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 742
    tmp = strlen((char const   *)addr);
    }
#line 742
    if (! ((size_t )x < tmp - 1UL)) {
#line 742
      goto while_break;
    }
#line 743
    if ((int )*(addr + x) == 58) {
#line 743
      if ((int )*(addr + (x + 1)) == 58) {
#line 744
        compressed ++;
      }
    }
#line 745
    x ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 748
  if (compressed) {
#line 749
    cstart = 0;
#line 750
    x = 0;
    {
#line 751
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 751
      tmp___0 = strlen((char const   *)addr);
      }
#line 751
      if (! ((size_t )x < tmp___0 - 1UL)) {
#line 751
        goto while_break___0;
      }
#line 752
      if ((int )*(addr + x) == 58) {
#line 752
        if ((int )*(addr + (x + 1)) == 58) {
#line 753
          goto while_break___0;
        }
      }
#line 754
      if ((int )*(addr + x) == 58) {
#line 755
        cstart ++;
      }
#line 756
      x ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 758
    x += 2;
#line 759
    cend = 0;
    {
#line 760
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 760
      tmp___1 = strlen((char const   *)addr);
      }
#line 760
      if (! ((size_t )x < tmp___1)) {
#line 760
        goto while_break___1;
      }
#line 761
      if ((int )*(addr + x) == 58) {
#line 762
        cend ++;
      }
#line 763
      x ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 765
    tmp___2 = strlen((char const   *)addr);
    }
#line 765
    if ((int )*(addr + (tmp___2 - 1UL)) == 58) {
      {
#line 765
      tmp___3 = strlen((char const   *)addr);
      }
#line 765
      if ((int )*(addr + (tmp___3 - 2UL)) != 58) {
#line 767
        cend --;
      }
    }
  }
#line 770
  if (! compressed) {
#line 771
    x = 0;
#line 772
    y = 0;
    {
#line 773
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 773
      if (! (x < pos)) {
#line 773
        goto while_break___2;
      }
#line 774
      if ((int )*(addr + y) == 58) {
#line 775
        x ++;
      }
#line 776
      y ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 779
    bzero((void *)(str), (size_t )5);
#line 780
    x = 0;
    }
    {
#line 781
    while (1) {
      while_continue___3: /* CIL Label */ ;
      {
#line 781
      tmp___4 = strlen((char const   *)addr);
      }
#line 781
      if ((size_t )y < tmp___4) {
#line 781
        if (! ((int )*(addr + y) != 58)) {
#line 781
          goto while_break___3;
        }
      } else {
#line 781
        goto while_break___3;
      }
#line 782
      str[x] = *(addr + y);
#line 783
      x ++;
#line 784
      y ++;
    }
    while_break___3: /* CIL Label */ ;
    }
  }
#line 788
  if (compressed) {
    {
#line 789
    bzero((void *)(str), (size_t )5);
    }
#line 790
    if (pos <= cstart) {
#line 791
      x = 0;
#line 792
      y = 0;
      {
#line 793
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 793
        if (! (x < pos)) {
#line 793
          goto while_break___4;
        }
#line 794
        if ((int )*(addr + y) == 58) {
#line 795
          x ++;
        }
#line 796
        y ++;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 799
      x = 0;
      {
#line 800
      while (1) {
        while_continue___5: /* CIL Label */ ;
        {
#line 800
        tmp___5 = strlen((char const   *)addr);
        }
#line 800
        if ((size_t )y < tmp___5) {
#line 800
          if (! ((int )*(addr + y) != 58)) {
#line 800
            goto while_break___5;
          }
        } else {
#line 800
          goto while_break___5;
        }
#line 801
        str[x] = *(addr + y);
#line 802
        x ++;
#line 803
        y ++;
      }
      while_break___5: /* CIL Label */ ;
      }
    }
#line 807
    if (pos > cstart) {
#line 807
      if (pos < max - cend) {
#line 808
        str[0] = (char )'0';
      }
    }
#line 811
    if (pos >= max - cend) {
#line 812
      y = 0;
      {
#line 813
      while (1) {
        while_continue___6: /* CIL Label */ ;
        {
#line 813
        tmp___6 = strlen((char const   *)addr);
        }
#line 813
        if (! ((size_t )y < tmp___6 - 1UL)) {
#line 813
          goto while_break___6;
        }
#line 814
        if ((int )*(addr + y) == 58) {
#line 814
          if ((int )*(addr + (y + 1)) == 58) {
#line 815
            goto while_break___6;
          }
        }
#line 816
        y ++;
      }
      while_break___6: /* CIL Label */ ;
      }
#line 818
      y += 2;
#line 820
      x = max - cend;
      {
#line 821
      while (1) {
        while_continue___7: /* CIL Label */ ;
#line 821
        if (! (x < pos)) {
#line 821
          goto while_break___7;
        }
#line 822
        if ((int )*(addr + y) == 58) {
#line 823
          x ++;
        }
#line 824
        y ++;
      }
      while_break___7: /* CIL Label */ ;
      }
      {
#line 827
      bzero((void *)(str), (size_t )5);
#line 828
      x = 0;
      }
      {
#line 829
      while (1) {
        while_continue___8: /* CIL Label */ ;
        {
#line 829
        tmp___7 = strlen((char const   *)addr);
        }
#line 829
        if ((size_t )y < tmp___7) {
#line 829
          if (! ((int )*(addr + y) != 58)) {
#line 829
            goto while_break___8;
          }
        } else {
#line 829
          goto while_break___8;
        }
#line 830
        str[x] = *(addr + y);
#line 831
        x ++;
#line 832
        y ++;
      }
      while_break___8: /* CIL Label */ ;
      }
    }
  }
#line 838
  if ((int )str[0] == 0) {
#line 839
    str[0] = (char )'0';
  }
  {
#line 840
  tmp___8 = strtol((char const   */* __restrict  */)(str), (char **/* __restrict  */)((char **)((void *)0)),
                   16);
#line 840
  x = (int )tmp___8;
  }
#line 842
  return (x);
}
}
#line 845 "/home/june/repo/benchmarks/collector/temp/sipcalc-1.1.5/src/sub-func.c"
int v6addrtonum(struct ipv6_split spstr , struct v6addr *in6_addr , int type ) 
{ 
  int colon ;
  int x ;
  int y ;
  int z ;
  int n ;
  char buf[128] ;
  int tmp ;
  int tmp___0 ;
  size_t tmp___1 ;

  {
#line 852
  colon = 0;
#line 853
  if (type == 1) {
#line 854
    colon = 8;
  }
#line 855
  if (type == 2) {
#line 856
    colon = 6;
  }
#line 858
  x = 0;
  {
#line 858
  while (1) {
    while_continue: /* CIL Label */ ;
#line 858
    if (! (x < 4)) {
#line 858
      goto while_break;
    }
#line 859
    in6_addr->haddr.sip_in6_u.u6_addr32[x] = (u_int32_t )0;
#line 858
    x ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 862
  x = 0;
  {
#line 862
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 862
    if (! (x < colon)) {
#line 862
      goto while_break___0;
    }
    {
#line 863
    y = getcolon(spstr.ipv6addr, x, type);
#line 864
    in6_addr->haddr.sip_in6_u.u6_addr16[x] = (u_int16_t )y;
#line 862
    x ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 867
  if (type == 2) {
    {
#line 868
    bzero((void *)(buf), (size_t )128);
#line 869
    x = 0;
    }
    {
#line 870
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 870
      if (! ((int )spstr.ipv4addr[x] != 46)) {
#line 870
        goto while_break___1;
      }
#line 871
      buf[x] = spstr.ipv4addr[x];
#line 872
      x ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 874
    x ++;
#line 875
    y = 0;
    {
#line 875
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 875
      if (! (y < 4)) {
#line 875
        goto while_break___2;
      }
#line 876
      if (y == 1) {
        {
#line 877
        tmp = atoi((char const   *)(buf));
#line 877
        in6_addr->haddr.sip_in6_u.u6_addr16[6] = (u_int16_t )((n << 8) | tmp);
        }
      }
#line 880
      if (y == 3) {
        {
#line 881
        tmp___0 = atoi((char const   *)(buf));
#line 881
        in6_addr->haddr.sip_in6_u.u6_addr16[7] = (u_int16_t )((n << 8) | tmp___0);
        }
      }
      {
#line 884
      n = atoi((char const   *)(buf));
#line 886
      bzero((void *)(buf), (size_t )128);
#line 887
      z = 0;
      }
      {
#line 888
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 888
        if ((int )spstr.ipv4addr[x] != 46) {
#line 888
          if ((int )spstr.ipv4addr[x] != 0) {
            {
#line 888
            tmp___1 = strlen((char const   *)(spstr.ipv4addr));
            }
#line 888
            if (! ((size_t )x < tmp___1)) {
#line 888
              goto while_break___3;
            }
          } else {
#line 888
            goto while_break___3;
          }
        } else {
#line 888
          goto while_break___3;
        }
#line 891
        buf[z] = spstr.ipv4addr[x];
#line 892
        x ++;
#line 893
        z ++;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 895
      x ++;
#line 875
      y ++;
    }
    while_break___2: /* CIL Label */ ;
    }
  }
#line 899
  return (0);
}
}
#line 902 "/home/june/repo/benchmarks/collector/temp/sipcalc-1.1.5/src/sub-func.c"
int v6masktonum(char *nmask , int *nmaskbits , struct sip_in6_addr *in6_addr ) 
{ 
  int x ;
  int y ;
  int z ;

  {
#line 907
  if ((int )*(nmask + 0) == 0) {
#line 908
    *nmaskbits = 128;
  } else {
    {
#line 910
    *nmaskbits = atoi((char const   *)nmask);
    }
  }
#line 912
  x = 0;
  {
#line 912
  while (1) {
    while_continue: /* CIL Label */ ;
#line 912
    if (! (x < 4)) {
#line 912
      goto while_break;
    }
#line 913
    in6_addr->sip_in6_u.u6_addr32[x] = (u_int32_t )0;
#line 912
    x ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 915
  y = 0;
#line 916
  z = 0;
#line 917
  x = 0;
  {
#line 917
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 917
    if (! (x < *nmaskbits)) {
#line 917
      goto while_break___0;
    }
#line 918
    in6_addr->sip_in6_u.u6_addr16[y] = (u_int16_t )((int )in6_addr->sip_in6_u.u6_addr16[y] | (1 << (15 - z)));
#line 920
    z ++;
#line 921
    if (z == 16) {
#line 922
      z = 0;
#line 923
      y ++;
    }
#line 917
    x ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 927
  return (0);
}
}
#line 934 "/home/june/repo/benchmarks/collector/temp/sipcalc-1.1.5/src/sub-func.c"
int validate_v6addr(char *addr ) 
{ 
  int x ;
  struct ipv6_split spstr ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 940
  bzero((void *)(spstr.ipv6addr), (size_t )40);
#line 941
  bzero((void *)(spstr.ipv4addr), (size_t )16);
#line 942
  bzero((void *)(spstr.nmask), (size_t )4);
#line 944
  split_ipv6addr(addr, & spstr);
  }
#line 946
  if (! spstr.ipv6addr[0]) {
#line 947
    return (0);
  }
#line 949
  x = 1;
#line 950
  if (spstr.ipv4addr[0]) {
#line 951
    x = 2;
  }
  {
#line 952
  tmp = validate_s_v6addr(spstr.ipv6addr, x);
  }
#line 952
  if (tmp < 0) {
#line 953
    return (0);
  }
#line 955
  if (spstr.ipv4addr[0]) {
    {
#line 956
    tmp___0 = validate_v4addr(spstr.ipv4addr);
    }
#line 956
    if (! tmp___0) {
#line 957
      return (0);
    }
  }
#line 961
  return (1);
}
}
#line 964 "/home/june/repo/benchmarks/collector/temp/sipcalc-1.1.5/src/sub-func.c"
int v6addrtoprefix(struct v6addr *in6_addr ) 
{ 
  int x ;

  {
#line 969
  x = 0;
  {
#line 969
  while (1) {
    while_continue: /* CIL Label */ ;
#line 969
    if (! (x < 8)) {
#line 969
      goto while_break;
    }
#line 970
    in6_addr->prefix.sip_in6_u.u6_addr16[x] = (u_int16_t )((int )in6_addr->haddr.sip_in6_u.u6_addr16[x] & (int )in6_addr->nmask.sip_in6_u.u6_addr16[x]);
#line 969
    x ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 975
  return (0);
}
}
#line 978 "/home/june/repo/benchmarks/collector/temp/sipcalc-1.1.5/src/sub-func.c"
int v6addrtosuffix(struct v6addr *in6_addr ) 
{ 
  int x ;

  {
#line 983
  x = 0;
  {
#line 983
  while (1) {
    while_continue: /* CIL Label */ ;
#line 983
    if (! (x < 8)) {
#line 983
      goto while_break;
    }
#line 984
    in6_addr->suffix.sip_in6_u.u6_addr16[x] = (u_int16_t )((int )in6_addr->haddr.sip_in6_u.u6_addr16[x] & ((int )in6_addr->nmask.sip_in6_u.u6_addr16[x] ^ 65535));
#line 983
    x ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 989
  return (0);
}
}
#line 992 "/home/june/repo/benchmarks/collector/temp/sipcalc-1.1.5/src/sub-func.c"
int v6addrtobroadcast(struct v6addr *in6_addr ) 
{ 
  int x ;

  {
#line 997
  x = 0;
  {
#line 997
  while (1) {
    while_continue: /* CIL Label */ ;
#line 997
    if (! (x < 8)) {
#line 997
      goto while_break;
    }
#line 998
    in6_addr->broadcast.sip_in6_u.u6_addr16[x] = (u_int16_t )((65535 - (int )in6_addr->nmask.sip_in6_u.u6_addr16[x]) + (int )in6_addr->prefix.sip_in6_u.u6_addr16[x]);
#line 997
    x ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1003
  return (0);
}
}
#line 1006 "/home/june/repo/benchmarks/collector/temp/sipcalc-1.1.5/src/sub-func.c"
void v6_type(struct v6addr *in6_addr ) 
{ 
  u_int16_t a ;

  {
#line 1011
  a = in6_addr->haddr.sip_in6_u.u6_addr16[0];
#line 1013
  if ((int )a == 0) {
    {
#line 1014
    snprintf((char */* __restrict  */)(in6_addr->class_remark), (size_t )63, (char const   */* __restrict  */)"Reserved");
    }
  }
#line 1015
  if ((int )a == 2) {
    {
#line 1016
    snprintf((char */* __restrict  */)(in6_addr->class_remark), (size_t )63, (char const   */* __restrict  */)"Reserved for NSAP Allocation");
    }
  } else
#line 1015
  if ((int )a == 3) {
    {
#line 1016
    snprintf((char */* __restrict  */)(in6_addr->class_remark), (size_t )63, (char const   */* __restrict  */)"Reserved for NSAP Allocation");
    }
  }
#line 1018
  if ((int )a == 4) {
    {
#line 1019
    snprintf((char */* __restrict  */)(in6_addr->class_remark), (size_t )63, (char const   */* __restrict  */)"Reserved for IPX Allocation");
    }
  } else
#line 1018
  if ((int )a == 5) {
    {
#line 1019
    snprintf((char */* __restrict  */)(in6_addr->class_remark), (size_t )63, (char const   */* __restrict  */)"Reserved for IPX Allocation");
    }
  }
#line 1021
  if (((int )a & 57344) == 8192) {
    {
#line 1022
    snprintf((char */* __restrict  */)(in6_addr->class_remark), (size_t )63, (char const   */* __restrict  */)"Aggregatable Global Unicast Addresses");
    }
  }
#line 1024
  if (((int )a | 255) == 255) {
    {
#line 1025
    snprintf((char */* __restrict  */)(in6_addr->class_remark), (size_t )63, (char const   */* __restrict  */)"Reserved");
    }
  }
#line 1026
  if (((int )a & 65280) == 65280) {
    {
#line 1027
    snprintf((char */* __restrict  */)(in6_addr->class_remark), (size_t )63, (char const   */* __restrict  */)"Multicast Addresses");
    }
  }
#line 1028
  if (((int )a & 65408) == 65152) {
    {
#line 1029
    snprintf((char */* __restrict  */)(in6_addr->class_remark), (size_t )63, (char const   */* __restrict  */)"Link-Local Unicast Addresses");
    }
  }
#line 1031
  if (((int )a & 65472) == 65216) {
    {
#line 1032
    snprintf((char */* __restrict  */)(in6_addr->class_remark), (size_t )63, (char const   */* __restrict  */)"Site-Local Unicast Addresses");
    }
  }
#line 1035
  if ((int )in6_addr->class_remark[0] == 0) {
    {
#line 1036
    snprintf((char */* __restrict  */)(in6_addr->class_remark), (size_t )63, (char const   */* __restrict  */)"Unassigned");
    }
  }
#line 1038
  return;
}
}
#line 1041 "/home/june/repo/benchmarks/collector/temp/sipcalc-1.1.5/src/sub-func.c"
void v6_comment(struct v6addr *in6_addr ) 
{ 
  int x ;
  int y ;

  {
#line 1046
  y = 0;
#line 1047
  x = 0;
  {
#line 1047
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1047
    if (! (x < 8)) {
#line 1047
      goto while_break;
    }
#line 1048
    if (in6_addr->haddr.sip_in6_u.u6_addr16[x]) {
#line 1049
      y = 1;
    }
#line 1047
    x ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1051
  if (! y) {
    {
#line 1052
    snprintf((char */* __restrict  */)(in6_addr->comment), (size_t )63, (char const   */* __restrict  */)"Unspecified");
    }
  }
#line 1054
  y = 0;
#line 1055
  x = 0;
  {
#line 1055
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1055
    if (! (x < 7)) {
#line 1055
      goto while_break___0;
    }
#line 1056
    if (in6_addr->haddr.sip_in6_u.u6_addr16[x]) {
#line 1057
      y = 1;
    }
#line 1055
    x ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1059
  if (! y) {
#line 1060
    if ((int )in6_addr->haddr.sip_in6_u.u6_addr16[7] == 1) {
      {
#line 1061
      snprintf((char */* __restrict  */)(in6_addr->comment), (size_t )63, (char const   */* __restrict  */)"Loopback");
      }
    }
  }
#line 1063
  return;
}
}
#line 1066 "/home/june/repo/benchmarks/collector/temp/sipcalc-1.1.5/src/sub-func.c"
int v6verifyv4(struct sip_in6_addr addr ) 
{ 
  int x ;
  int y ;

  {
#line 1071
  y = 0;
#line 1072
  x = 0;
  {
#line 1072
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1072
    if (! (x < 5)) {
#line 1072
      goto while_break;
    }
#line 1073
    if (addr.sip_in6_u.u6_addr16[x]) {
#line 1074
      y = 1;
    }
#line 1072
    x ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1077
  if (! y) {
#line 1078
    if (! addr.sip_in6_u.u6_addr16[5]) {
#line 1079
      return (1);
    }
#line 1080
    if ((int )addr.sip_in6_u.u6_addr16[5] == 65535) {
#line 1081
      return (2);
    }
  }
#line 1084
  return (0);
}
}
#line 1090 "/home/june/repo/benchmarks/collector/temp/sipcalc-1.1.5/src/sub-func.c"
static char outad[44]  ;
#line 1087 "/home/june/repo/benchmarks/collector/temp/sipcalc-1.1.5/src/sub-func.c"
char *get_comp_v6(struct sip_in6_addr addr ) 
{ 
  char tmpad[5] ;
  int x ;
  int y ;
  int z ;
  int start ;
  int num ;

  {
  {
#line 1095
  bzero((void *)(outad), (size_t )44);
#line 1097
  start = -1;
#line 1098
  num = 0;
#line 1099
  y = 0;
#line 1100
  z = 0;
#line 1101
  x = 0;
  }
  {
#line 1101
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1101
    if (! (x < 8)) {
#line 1101
      goto while_break;
    }
#line 1102
    if ((int )addr.sip_in6_u.u6_addr16[x] == 0) {
#line 1103
      if (y == -1) {
#line 1104
        y = x;
      }
#line 1105
      z ++;
    } else {
#line 1107
      if (z > num) {
#line 1107
        if (z > 1) {
#line 1108
          start = y;
#line 1109
          num = z;
        }
      }
#line 1111
      y = -1;
#line 1112
      z = 0;
    }
#line 1101
    x ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1116
  if (z > num) {
#line 1116
    if (z > 1) {
#line 1117
      start = y;
#line 1118
      num = z;
    }
  }
#line 1121
  x = 0;
  {
#line 1121
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1121
    if (! (x < 8)) {
#line 1121
      goto while_break___0;
    }
#line 1122
    if (x == start) {
#line 1123
      if (! x) {
        {
#line 1124
        strcat((char */* __restrict  */)(outad), (char const   */* __restrict  */)":");
        }
      }
      {
#line 1125
      strcat((char */* __restrict  */)(outad), (char const   */* __restrict  */)":");
#line 1126
      x += num - 1;
      }
    } else {
      {
#line 1128
      bzero((void *)(tmpad), (size_t )5);
#line 1129
      sprintf((char */* __restrict  */)(tmpad), (char const   */* __restrict  */)"%x",
              (int )addr.sip_in6_u.u6_addr16[x]);
#line 1130
      strcat((char */* __restrict  */)(outad), (char const   */* __restrict  */)(tmpad));
      }
#line 1131
      if (x != 7) {
        {
#line 1132
        strcat((char */* __restrict  */)(outad), (char const   */* __restrict  */)":");
        }
      }
    }
#line 1121
    x ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1136
  return (outad);
}
}
#line 1139 "/home/june/repo/benchmarks/collector/temp/sipcalc-1.1.5/src/sub-func.c"
int mk_ipv6addr(struct v6addr *in6_addr , char *addr ) 
{ 
  int x ;
  int y ;
  int z ;
  struct ipv6_split spstr ;
  int tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;

  {
  {
#line 1145
  bzero((void *)(spstr.ipv6addr), (size_t )40);
#line 1146
  bzero((void *)(spstr.ipv4addr), (size_t )16);
#line 1147
  bzero((void *)(spstr.nmask), (size_t )4);
#line 1149
  split_ipv6addr(addr, & spstr);
  }
#line 1151
  if (! spstr.ipv6addr[0]) {
#line 1152
    return (-1);
  }
#line 1154
  x = 1;
#line 1155
  if (spstr.ipv4addr[0]) {
#line 1156
    x = 2;
  }
  {
#line 1157
  tmp = validate_s_v6addr(spstr.ipv6addr, x);
  }
#line 1157
  if (tmp < 0) {
#line 1158
    return (-1);
  }
#line 1160
  if (spstr.ipv4addr[0]) {
    {
#line 1161
    tmp___0 = validate_v4addr(spstr.ipv4addr);
    }
#line 1161
    if (! tmp___0) {
#line 1162
      return (-1);
    }
  }
#line 1166
  x = 0;
#line 1167
  y = 0;
  {
#line 1168
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1168
    tmp___2 = strlen((char const   *)(spstr.nmask));
    }
#line 1168
    if (! ((size_t )x < tmp___2)) {
#line 1168
      goto while_break;
    }
#line 1169
    y = 0;
#line 1170
    z = 0;
    {
#line 1171
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 1171
      tmp___1 = strlen("0123456789");
      }
#line 1171
      if ((size_t )z < tmp___1) {
#line 1171
        if (! (! y)) {
#line 1171
          goto while_break___0;
        }
      } else {
#line 1171
        goto while_break___0;
      }
#line 1172
      if ((int )spstr.nmask[x] == (int )*("0123456789" + z)) {
#line 1173
        y = 1;
      }
#line 1174
      z ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1176
    if (! y) {
#line 1177
      return (-1);
    }
#line 1179
    x ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1181
  x = atoi((char const   *)(spstr.nmask));
  }
#line 1182
  if (x < 0) {
#line 1183
    return (-1);
  } else
#line 1182
  if (x > 128) {
#line 1183
    return (-1);
  }
#line 1186
  if ((int )spstr.ipv4addr[0] == 0) {
#line 1187
    in6_addr->type = 1;
  } else {
#line 1189
    in6_addr->type = 2;
  }
  {
#line 1191
  v6addrtonum(spstr, in6_addr, in6_addr->type);
#line 1192
  v6masktonum(spstr.nmask, & in6_addr->nmaskbits, & in6_addr->nmask);
#line 1193
  v6addrtoprefix(in6_addr);
#line 1194
  v6addrtosuffix(in6_addr);
#line 1195
  v6addrtobroadcast(in6_addr);
#line 1196
  in6_addr->real_v4 = v6verifyv4(in6_addr->haddr);
#line 1198
  bzero((void *)(in6_addr->class_remark), (size_t )64);
#line 1199
  v6_type(in6_addr);
#line 1200
  bzero((void *)(in6_addr->comment), (size_t )64);
#line 1201
  v6_comment(in6_addr);
  }
#line 1203
  return (0);
}
}
#line 1206 "/home/june/repo/benchmarks/collector/temp/sipcalc-1.1.5/src/sub-func.c"
struct dnsresp *new_dnsresp(struct dnsresp *d_resp ) 
{ 
  void *tmp ;

  {
  {
#line 1209
  tmp = malloc(sizeof(struct dnsresp ));
#line 1209
  d_resp->next = (struct dnsresp *)tmp;
#line 1210
  d_resp = d_resp->next;
#line 1211
  d_resp->next = (struct dnsresp *)((void *)0);
#line 1212
  bzero((void *)(d_resp->str), (size_t )128);
#line 1213
  d_resp->type = 0;
  }
#line 1215
  return (d_resp);
}
}
#line 1218 "/home/june/repo/benchmarks/collector/temp/sipcalc-1.1.5/src/sub-func.c"
void free_dnsresp(struct dnsresp *d_resp ) 
{ 
  struct dnsresp *old ;

  {
  {
#line 1223
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1223
    if (! d_resp) {
#line 1223
      goto while_break;
    }
    {
#line 1224
    old = d_resp;
#line 1225
    d_resp = d_resp->next;
#line 1226
    free((void *)old);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1228
  return;
}
}
#line 1235 "/home/june/repo/benchmarks/collector/temp/sipcalc-1.1.5/src/sub-func.c"
static char retaddr[1024]  ;
#line 1231 "/home/june/repo/benchmarks/collector/temp/sipcalc-1.1.5/src/sub-func.c"
char *_resolv_v4_ghbn(char *raddr , struct dnsresp *d_resp , char *extra ) 
{ 
  struct hostent *he ;
  int x ;
  char *tmp ;
  char *tmp___0 ;

  {
  {
#line 1238
  bzero((void *)(retaddr), (size_t )1024);
#line 1240
  he = gethostbyname((char const   *)raddr);
  }
#line 1241
  if (! he) {
#line 1242
    return ((char *)((void *)0));
  }
#line 1244
  if (he->h_addrtype == 2) {
    {
#line 1245
    tmp = inet_ntoa(*((struct in_addr *)*(he->h_addr_list + 0)));
#line 1245
    snprintf((char */* __restrict  */)(retaddr), (size_t )1023, (char const   */* __restrict  */)"%s%s",
             tmp, extra);
#line 1246
    x = 0;
    }
    {
#line 1247
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1247
      if (! *(he->h_addr_list + x)) {
#line 1247
        goto while_break;
      }
      {
#line 1248
      tmp___0 = inet_ntoa(*((struct in_addr *)*(he->h_addr_list + x)));
#line 1248
      snprintf((char */* __restrict  */)(d_resp->str), (size_t )127, (char const   */* __restrict  */)"%s%s",
               tmp___0, extra);
#line 1249
      d_resp->type = 2;
#line 1250
      x ++;
      }
#line 1251
      if (*(he->h_addr_list + x)) {
        {
#line 1252
        d_resp = new_dnsresp(d_resp);
        }
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 1256
  if ((int )retaddr[0] == 0) {
#line 1257
    return ((char *)((void *)0));
  }
#line 1259
  return (retaddr);
}
}
#line 1274 "/home/june/repo/benchmarks/collector/temp/sipcalc-1.1.5/src/sub-func.c"
static char retaddr___0[1024]  ;
#line 1270 "/home/june/repo/benchmarks/collector/temp/sipcalc-1.1.5/src/sub-func.c"
char *_resolv_v6_ghbn2(char *raddr , struct dnsresp *d_resp , char *extra ) 
{ 
  struct hostent *he ;
  char ip6addr[128] ;
  int x ;
  char const   *tmp ;
  char const   *tmp___0 ;

  {
  {
#line 1278
  bzero((void *)(retaddr___0), (size_t )1024);
#line 1280
  he = gethostbyname2((char const   *)raddr, 10);
  }
#line 1281
  if (! he) {
#line 1282
    return ((char *)((void *)0));
  }
#line 1284
  if (he->h_addrtype == 10) {
    {
#line 1285
    bzero((void *)(ip6addr), (size_t )128);
#line 1286
    tmp = inet_ntop(10, (void const   */* __restrict  */)*(he->h_addr_list + 0), (char */* __restrict  */)(ip6addr),
                    (socklen_t )128);
#line 1286
    snprintf((char */* __restrict  */)(retaddr___0), (size_t )1023, (char const   */* __restrict  */)"%s%s",
             tmp, extra);
#line 1287
    x = 0;
    }
    {
#line 1288
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1288
      if (! *(he->h_addr_list + x)) {
#line 1288
        goto while_break;
      }
      {
#line 1289
      tmp___0 = inet_ntop(10, (void const   */* __restrict  */)*(he->h_addr_list + x),
                          (char */* __restrict  */)(ip6addr), (socklen_t )128);
#line 1289
      snprintf((char */* __restrict  */)(d_resp->str), (size_t )127, (char const   */* __restrict  */)"%s%s",
               tmp___0, extra);
#line 1290
      d_resp->type = 10;
#line 1291
      x ++;
      }
#line 1292
      if (*(he->h_addr_list + x)) {
        {
#line 1293
        d_resp = new_dnsresp(d_resp);
        }
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 1297
  if ((int )retaddr___0[0] == 0) {
#line 1298
    return ((char *)((void *)0));
  }
#line 1300
  return (retaddr___0);
}
}
#line 1318 "/home/june/repo/benchmarks/collector/temp/sipcalc-1.1.5/src/sub-func.c"
static char retaddr___1[1024]  ;
#line 1311 "/home/june/repo/benchmarks/collector/temp/sipcalc-1.1.5/src/sub-func.c"
char *_resolv_v6_gai(char *raddr , struct dnsresp *d_resp , char *extra ) 
{ 
  int x ;
  struct addrinfo hints ;
  struct addrinfo *res ;
  struct addrinfo *res_orig ;
  struct sockaddr_in6 *sin6 ;
  char ip6addr[128] ;
  char const   *tmp ;
  char const   *tmp___0 ;

  {
  {
#line 1321
  memset((void *)(& hints), 0, sizeof(hints));
#line 1322
  hints.ai_family = 10;
#line 1323
  hints.ai_socktype = 0;
#line 1324
  hints.ai_flags = 2;
#line 1325
  hints.ai_protocol = 6;
#line 1326
  x = getaddrinfo((char const   */* __restrict  */)raddr, (char const   */* __restrict  */)((void *)0),
                  (struct addrinfo  const  */* __restrict  */)(& hints), (struct addrinfo **/* __restrict  */)(& res));
  }
#line 1327
  if (x) {
#line 1328
    return ((char *)((void *)0));
  }
#line 1329
  if (! res) {
#line 1330
    return ((char *)((void *)0));
  }
#line 1332
  res_orig = res;
  {
#line 1333
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1333
    if (! res) {
#line 1333
      goto while_break;
    }
    {
#line 1334
    bzero((void *)(ip6addr), (size_t )128);
    }
#line 1335
    if (res->ai_family == 10) {
      {
#line 1336
      sin6 = (struct sockaddr_in6 *)res->ai_addr;
#line 1337
      tmp = inet_ntop(10, (void const   */* __restrict  */)(& sin6->sin6_addr), (char */* __restrict  */)(ip6addr),
                      (socklen_t )128);
#line 1337
      snprintf((char */* __restrict  */)(retaddr___1), (size_t )1023, (char const   */* __restrict  */)"%s%s",
               tmp, extra);
#line 1338
      tmp___0 = inet_ntop(10, (void const   */* __restrict  */)(& sin6->sin6_addr),
                          (char */* __restrict  */)(ip6addr), (socklen_t )128);
#line 1338
      snprintf((char */* __restrict  */)(d_resp->str), (size_t )127, (char const   */* __restrict  */)"%s%s",
               tmp___0, extra);
#line 1339
      d_resp->type = 10;
      }
    }
#line 1341
    if (res->ai_next) {
#line 1341
      if (res->ai_family == 2) {
        {
#line 1342
        d_resp = new_dnsresp(d_resp);
        }
      } else
#line 1341
      if (res->ai_family == 10) {
        {
#line 1342
        d_resp = new_dnsresp(d_resp);
        }
      }
    }
#line 1343
    res = res->ai_next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1346
  freeaddrinfo(res_orig);
  }
#line 1348
  if ((int )retaddr___1[0] == 0) {
#line 1349
    return ((char *)((void *)0));
  }
#line 1351
  return (retaddr___1);
}
}
#line 1370 "/home/june/repo/benchmarks/collector/temp/sipcalc-1.1.5/src/sub-func.c"
static char retaddr___2[1024]  ;
#line 1362 "/home/june/repo/benchmarks/collector/temp/sipcalc-1.1.5/src/sub-func.c"
char *_resolv_unspec_gai(char *raddr , struct dnsresp *d_resp , char *extra ) 
{ 
  int x ;
  struct addrinfo hints ;
  struct addrinfo *res ;
  struct addrinfo *res_orig ;
  struct sockaddr_in *sin ;
  struct sockaddr_in6 *sin6 ;
  char ip6addr[128] ;
  char *tmp ;
  char *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;

  {
  {
#line 1373
  memset((void *)(& hints), 0, sizeof(hints));
#line 1374
  hints.ai_family = 0;
#line 1375
  hints.ai_socktype = 0;
#line 1376
  hints.ai_flags = 2;
#line 1377
  hints.ai_protocol = 6;
#line 1378
  x = getaddrinfo((char const   */* __restrict  */)raddr, (char const   */* __restrict  */)((void *)0),
                  (struct addrinfo  const  */* __restrict  */)(& hints), (struct addrinfo **/* __restrict  */)(& res));
  }
#line 1379
  if (x) {
#line 1380
    return ((char *)((void *)0));
  }
#line 1381
  if (! res) {
#line 1382
    return ((char *)((void *)0));
  }
#line 1384
  res_orig = res;
  {
#line 1386
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1386
    if (! res) {
#line 1386
      goto while_break;
    }
    {
#line 1387
    bzero((void *)(ip6addr), (size_t )128);
    }
#line 1388
    if (res->ai_family == 2) {
      {
#line 1389
      sin = (struct sockaddr_in *)res->ai_addr;
#line 1390
      tmp = inet_ntoa(sin->sin_addr);
#line 1390
      snprintf((char */* __restrict  */)(retaddr___2), (size_t )1023, (char const   */* __restrict  */)"%s%s",
               tmp, extra);
#line 1391
      tmp___0 = inet_ntoa(sin->sin_addr);
#line 1391
      snprintf((char */* __restrict  */)(d_resp->str), (size_t )127, (char const   */* __restrict  */)"%s%s",
               tmp___0, extra);
#line 1392
      d_resp->type = 2;
      }
    }
#line 1394
    if (res->ai_family == 10) {
      {
#line 1395
      sin6 = (struct sockaddr_in6 *)res->ai_addr;
#line 1396
      tmp___1 = inet_ntop(10, (void const   */* __restrict  */)(& sin6->sin6_addr),
                          (char */* __restrict  */)(ip6addr), (socklen_t )128);
#line 1396
      snprintf((char */* __restrict  */)(retaddr___2), (size_t )1023, (char const   */* __restrict  */)"%s%s",
               tmp___1, extra);
#line 1397
      tmp___2 = inet_ntop(10, (void const   */* __restrict  */)(& sin6->sin6_addr),
                          (char */* __restrict  */)(ip6addr), (socklen_t )128);
#line 1397
      snprintf((char */* __restrict  */)(d_resp->str), (size_t )127, (char const   */* __restrict  */)"%s%s",
               tmp___2, extra);
#line 1398
      d_resp->type = 10;
      }
    }
#line 1400
    if (res->ai_next) {
#line 1400
      if (res->ai_family == 2) {
        {
#line 1401
        d_resp = new_dnsresp(d_resp);
        }
      } else
#line 1400
      if (res->ai_family == 10) {
        {
#line 1401
        d_resp = new_dnsresp(d_resp);
        }
      }
    }
#line 1402
    res = res->ai_next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1405
  freeaddrinfo(res_orig);
  }
#line 1407
  if ((int )retaddr___2[0] == 0) {
#line 1408
    return ((char *)((void *)0));
  }
#line 1410
  return (retaddr___2);
}
}
#line 1426 "/home/june/repo/benchmarks/collector/temp/sipcalc-1.1.5/src/sub-func.c"
static char retaddr___3[1024]  ;
#line 1420 "/home/june/repo/benchmarks/collector/temp/sipcalc-1.1.5/src/sub-func.c"
char *resolve_addr(char *addr , int family , struct dnsresp *d_resp ) 
{ 
  char extra[32] ;
  char *tmpstr ;
  char raddr[1024] ;
  struct dnsresp *d_resp_tmp ;
  int f_gethostbyname ;
  int f_gethostbyname2 ;
  int f_getaddrinfo ;
  int f_inet_ntop ;
  int ipv4_cap ;
  int ipv6_cap ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;

  {
#line 1435
  f_gethostbyname = 0;
#line 1436
  f_gethostbyname2 = 0;
#line 1437
  f_getaddrinfo = 0;
#line 1438
  f_inet_ntop = 0;
#line 1439
  ipv4_cap = 0;
#line 1440
  ipv6_cap = 0;
#line 1443
  f_gethostbyname = 1;
#line 1446
  f_gethostbyname2 = 1;
#line 1449
  f_getaddrinfo = 1;
#line 1452
  f_inet_ntop = 1;
#line 1455
  if (f_gethostbyname) {
#line 1456
    ipv4_cap = 1;
  }
#line 1458
  if (f_gethostbyname2) {
#line 1458
    goto _L;
  } else
#line 1458
  if (f_getaddrinfo) {
    _L: /* CIL Label */ 
#line 1458
    if (f_inet_ntop) {
#line 1459
      ipv6_cap = 1;
    }
  }
#line 1461
  if (family != 2) {
#line 1461
    if (family != 10) {
#line 1461
      if (family != 0) {
#line 1462
        return ((char *)((void *)0));
      }
    }
  }
#line 1464
  if (family == 2) {
#line 1464
    if (! ipv4_cap) {
#line 1465
      return ((char *)((void *)0));
    }
  }
#line 1467
  if (family == 10) {
#line 1467
    if (! ipv6_cap) {
#line 1468
      return ((char *)((void *)0));
    }
  }
#line 1470
  if (family == 0) {
#line 1470
    if (! ipv4_cap) {
#line 1470
      if (! ipv6_cap) {
#line 1471
        return ((char *)((void *)0));
      }
    }
  }
  {
#line 1473
  tmp = strlen((char const   *)addr);
  }
#line 1473
  if (tmp > 1023UL) {
#line 1474
    return ((char *)((void *)0));
  }
#line 1476
  if (family == 0) {
#line 1476
    if (! ipv4_cap) {
#line 1477
      family = 10;
    }
  }
#line 1479
  if (family == 0) {
#line 1479
    if (! ipv6_cap) {
#line 1480
      family = 2;
    }
  }
  {
#line 1482
  bzero((void *)(extra), (size_t )32);
#line 1483
  bzero((void *)(raddr), (size_t )1024);
#line 1484
  tmpstr = strstr((char const   *)addr, "/");
  }
#line 1485
  if (tmpstr) {
    {
#line 1486
    strncpy((char */* __restrict  */)(extra), (char const   */* __restrict  */)tmpstr,
            (size_t )31);
#line 1487
    tmp___0 = strlen((char const   *)addr);
#line 1487
    tmp___1 = strlen((char const   *)tmpstr);
#line 1487
    strncpy((char */* __restrict  */)(raddr), (char const   */* __restrict  */)addr,
            tmp___0 - tmp___1);
    }
  } else {
    {
#line 1490
    tmpstr = strstr((char const   *)addr, " ");
    }
#line 1491
    if (tmpstr) {
      {
#line 1492
      strncpy((char */* __restrict  */)(extra), (char const   */* __restrict  */)tmpstr,
              (size_t )31);
#line 1493
      tmp___2 = strlen((char const   *)addr);
#line 1493
      tmp___3 = strlen((char const   *)tmpstr);
#line 1493
      strncpy((char */* __restrict  */)(raddr), (char const   */* __restrict  */)addr,
              tmp___2 - tmp___3);
      }
    } else {
      {
#line 1496
      strncpy((char */* __restrict  */)(raddr), (char const   */* __restrict  */)addr,
              (size_t )1023);
      }
    }
  }
  {
#line 1499
  bzero((void *)(retaddr___3), (size_t )1024);
  }
#line 1501
  if (family == 2) {
    {
#line 1502
    tmpstr = _resolv_v4_ghbn(raddr, d_resp, extra);
    }
#line 1503
    if (! tmpstr) {
#line 1504
      return ((char *)((void *)0));
    }
    {
#line 1505
    strncpy((char */* __restrict  */)(retaddr___3), (char const   */* __restrict  */)tmpstr,
            (size_t )1024);
    }
#line 1506
    return (retaddr___3);
  }
#line 1509
  if (family == 10) {
#line 1510
    if (f_getaddrinfo) {
      {
#line 1511
      tmpstr = _resolv_v6_gai(raddr, d_resp, extra);
      }
#line 1512
      if (! tmpstr) {
#line 1513
        return ((char *)((void *)0));
      }
      {
#line 1514
      strncpy((char */* __restrict  */)(retaddr___3), (char const   */* __restrict  */)tmpstr,
              (size_t )1024);
      }
#line 1515
      return (retaddr___3);
    }
#line 1518
    if (f_gethostbyname2) {
      {
#line 1519
      tmpstr = _resolv_v6_ghbn2(raddr, d_resp, extra);
      }
#line 1520
      if (! tmpstr) {
#line 1521
        return ((char *)((void *)0));
      }
      {
#line 1522
      strncpy((char */* __restrict  */)(retaddr___3), (char const   */* __restrict  */)tmpstr,
              (size_t )1024);
      }
#line 1523
      return (retaddr___3);
    }
  }
#line 1527
  if (family == 0) {
#line 1528
    if (f_getaddrinfo) {
      {
#line 1529
      tmpstr = _resolv_unspec_gai(raddr, d_resp, extra);
      }
#line 1530
      if (! tmpstr) {
#line 1531
        return ((char *)((void *)0));
      }
      {
#line 1532
      strncpy((char */* __restrict  */)(retaddr___3), (char const   */* __restrict  */)tmpstr,
              (size_t )1024);
      }
#line 1533
      return (retaddr___3);
    }
#line 1535
    if (f_gethostbyname) {
#line 1535
      if (f_gethostbyname2) {
        {
#line 1536
        tmpstr = _resolv_v4_ghbn(raddr, d_resp, extra);
        }
#line 1537
        if (tmpstr) {
          {
#line 1538
          strncpy((char */* __restrict  */)(retaddr___3), (char const   */* __restrict  */)tmpstr,
                  (size_t )1024);
#line 1539
          d_resp_tmp = d_resp;
#line 1540
          d_resp = new_dnsresp(d_resp);
          }
        }
        {
#line 1542
        tmpstr = _resolv_v6_ghbn2(raddr, d_resp, extra);
        }
#line 1543
        if (! tmpstr) {
          {
#line 1544
          d_resp_tmp->next = (struct dnsresp *)((void *)0);
#line 1545
          free((void *)d_resp);
          }
        }
#line 1547
        return (retaddr___3);
      }
    }
  }
#line 1551
  return ((char *)((void *)0));
}
}
