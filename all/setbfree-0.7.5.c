/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 43 "/home/june/repo/benchmarks/collector/temp/setbfree-0.7.5/b_overdrive/overmaker.h"
struct mod_call_struct {
   void (*fn)(int  , void * ) ;
   void *handback ;
};
#line 43 "/home/june/repo/benchmarks/collector/temp/setbfree-0.7.5/b_overdrive/overmaker.h"
typedef struct mod_call_struct modCall;
#line 140 "/home/june/repo/benchmarks/collector/temp/setbfree-0.7.5/b_overdrive/overmaker.c"
struct _ipoldesc {
   int terms ;
   int weightIndex[8] ;
   int xzIndex[8] ;
};
#line 140 "/home/june/repo/benchmarks/collector/temp/setbfree-0.7.5/b_overdrive/overmaker.c"
typedef struct _ipoldesc IpolDesc;
#line 364 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 53 "/home/june/repo/benchmarks/collector/temp/setbfree-0.7.5/b_overdrive/overmaker.h"
void codeln(char *s ) ;
#line 54
void vspace(int lines ) ;
#line 56
void commentln(char *s ) ;
#line 57
void pushIndent(void) ;
#line 58
void popIndent(void) ;
#line 60
void bindCallback(int i , void (*func)(int  , void * ) , void *hbk ) ;
#line 31 "/home/june/repo/benchmarks/collector/temp/setbfree-0.7.5/b_overdrive/ovt_biased.c"
static char buf[512]  ;
#line 38 "/home/june/repo/benchmarks/collector/temp/setbfree-0.7.5/b_overdrive/ovt_biased.c"
void hdr_biased(void) 
{ 


  {
  {
#line 39
  commentln((char *)"Variables for the inverted and biased transfer function");
#line 40
  codeln((char *)"float biasBase;");
#line 41
  commentln((char *)"bias and norm are set in function cfg_biased()");
#line 42
  codeln((char *)"float bias;");
#line 43
  codeln((char *)"float norm;");
#line 46
  commentln((char *)"ovt_biased : One sample memory");
#line 47
  codeln((char *)"float adwZ;");
#line 48
  commentln((char *)"ovt_biased : Positive feedback");
#line 49
  codeln((char *)"float adwFb;");
#line 50
  codeln(buf);
#line 54
  codeln((char *)"float adwZ1;");
#line 58
  codeln((char *)"float adwFb2;");
#line 62
  codeln((char *)"float adwGfb;");
#line 63
  codeln((char *)"float adwGfZ;");
#line 67
  codeln((char *)"float sagZgb;");
  }
#line 69
  return;
}
}
#line 71 "/home/june/repo/benchmarks/collector/temp/setbfree-0.7.5/b_overdrive/ovt_biased.c"
void rst_biased(void) 
{ 


  {
  {
#line 72
  sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)"pp->biasBase = %g;",
          0.5347);
#line 73
  codeln(buf);
#line 76
  codeln((char *)"pp->adwZ = 0.0;");
#line 77
  sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)"pp->adwFb = %g;",
          0.5821);
#line 78
  codeln(buf);
#line 82
  codeln((char *)"pp->adwZ1 = 0.0;");
#line 86
  sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)"pp->adwFb2 = %g;",
          0.999);
#line 87
  codeln(buf);
#line 91
  codeln((char *)"pp->adwGfb = -0.6214;");
#line 92
  codeln((char *)"pp->adwGfZ = 0.0;");
#line 96
  sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)"pp->sagZgb = %g;",
          0.0094);
#line 97
  codeln(buf);
  }
#line 99
  return;
}
}
#line 101 "/home/june/repo/benchmarks/collector/temp/setbfree-0.7.5/b_overdrive/ovt_biased.c"
void cfg_biased(void) 
{ 


  {
  {
#line 102
  commentln((char *)"Computes the constants for transfer curve");
#line 103
  codeln((char *)"void cfg_biased (void *pa, float new_bias) {");
#line 104
  pushIndent();
#line 105
  codeln((char *)"struct b_preamp *pp = (struct b_preamp *) pa;");
#line 106
  codeln((char *)"if (0.0 < new_bias) {");
#line 107
  pushIndent();
#line 108
  codeln((char *)"pp->biasBase = new_bias;");
#line 109
  commentln((char *)"If power sag emulation is enabled bias is set there.");
#line 110
  codeln((char *)"pp->bias = pp->biasBase;");
#line 111
  codeln((char *)"pp->norm = 1.0 - (1.0 / (1.0 + (pp->bias * pp->bias)));");
#line 116
  popIndent();
#line 117
  codeln((char *)"}");
#line 118
  popIndent();
#line 119
  codeln((char *)"}");
  }
#line 120
  return;
}
}
#line 122 "/home/june/repo/benchmarks/collector/temp/setbfree-0.7.5/b_overdrive/ovt_biased.c"
void ctl_biased(void) 
{ 


  {
  {
#line 123
  codeln((char *)"void fctl_biased (void *pa, float u) {");
#line 124
  pushIndent();
#line 125
  sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)"float v = %g + ((%g - %g) * (u * u));",
          0.0, 0.7, 0.0);
#line 129
  codeln(buf);
#line 130
  codeln((char *)"cfg_biased (pa, v);");
#line 131
  popIndent();
#line 132
  codeln((char *)"}");
#line 133
  vspace(1);
#line 133
  codeln((char *)"void ctl_biased (void *d, unsigned char uc) {");
#line 133
  pushIndent();
#line 133
  codeln((char *)"fctl_biased (d, uc/127.0);");
#line 133
  popIndent();
#line 133
  codeln((char *)"}");
#line 136
  vspace(3);
#line 137
  commentln((char *)"ovt_biased:Sets the positive feedback");
#line 138
  codeln((char *)"void fctl_biased_fb (void *pa, float u) {");
#line 139
  pushIndent();
#line 140
  codeln((char *)"struct b_preamp *pp = (struct b_preamp *) pa;");
#line 141
  sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)"pp->adwFb = %g * u;",
          0.999);
#line 142
  codeln(buf);
#line 143
  codeln((char *)"printf (\"\\rFbk=%10.4f\", pp->adwFb);");
#line 144
  codeln((char *)"fflush (stdout);");
#line 145
  popIndent();
#line 146
  codeln((char *)"}");
#line 148
  vspace(1);
#line 148
  codeln((char *)"void ctl_biased_fb (void *d, unsigned char uc) {");
#line 148
  pushIndent();
#line 148
  codeln((char *)"fctl_biased_fb (d, uc/127.0);");
#line 148
  popIndent();
#line 148
  codeln((char *)"}");
#line 152
  vspace(3);
#line 153
  commentln((char *)"ovt_biased: Sets sag impact");
#line 154
  codeln((char *)"void fctl_sagtoBias (void *pa, float u) {");
#line 155
  pushIndent();
#line 156
  codeln((char *)"struct b_preamp *pp = (struct b_preamp *) pa;");
#line 157
  sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)"pp->sagZgb = %g + ((%g - %g) * u);",
          0.0, 0.05, 0.0);
#line 161
  codeln(buf);
#line 162
  codeln((char *)"printf (\"\\rpp->ZGB=%10.4f\", pp->sagZgb);");
#line 163
  codeln((char *)"fflush (stdout);");
#line 164
  popIndent();
#line 165
  codeln((char *)"}");
#line 166
  vspace(1);
#line 166
  codeln((char *)"void ctl_sagtoBias (void *d, unsigned char uc) {");
#line 166
  pushIndent();
#line 166
  codeln((char *)"fctl_sagtoBias (d, uc/127.0);");
#line 166
  popIndent();
#line 166
  codeln((char *)"}");
#line 170
  vspace(3);
#line 171
  commentln((char *)"ovt_biased: Postdiff feedback control");
#line 172
  codeln((char *)"void fctl_biased_fb2 (void *pa, float u) {");
#line 173
  pushIndent();
#line 174
  codeln((char *)"struct b_preamp *pp = (struct b_preamp *) pa;");
#line 175
  sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)"pp->adwFb2 = %g * u;",
          0.999);
#line 176
  codeln(buf);
#line 177
  codeln((char *)"printf (\"\\rFb2=%10.4f\", pp->adwFb2);");
#line 178
  codeln((char *)"fflush (stdout);");
#line 179
  popIndent();
#line 180
  codeln((char *)"}");
#line 181
  vspace(1);
#line 181
  codeln((char *)"void ctl_biased_fb2 (void *d, unsigned char uc) {");
#line 181
  pushIndent();
#line 181
  codeln((char *)"fctl_biased_fb2 (d, uc/127.0);");
#line 181
  popIndent();
#line 181
  codeln((char *)"}");
#line 185
  vspace(3);
#line 186
  commentln((char *)"ovt_biased: Global feedback control");
#line 187
  codeln((char *)"void fctl_biased_gfb (void *pa, float u) {");
#line 188
  pushIndent();
#line 189
  codeln((char *)"struct b_preamp *pp = (struct b_preamp *) pa;");
#line 190
  sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)"pp->adwGfb = %g * u;",
          - 0.999);
#line 191
  codeln(buf);
#line 192
  codeln((char *)"printf (\"\\rGfb=%10.4f\", pp->adwGfb);");
#line 193
  codeln((char *)"fflush (stdout);");
#line 194
  popIndent();
#line 195
  codeln((char *)"}");
#line 196
  vspace(1);
#line 196
  codeln((char *)"void ctl_biased_gfb (void *d, unsigned char uc) {");
#line 196
  pushIndent();
#line 196
  codeln((char *)"fctl_biased_gfb (d, uc/127.0);");
#line 196
  popIndent();
#line 196
  codeln((char *)"}");
#line 200
  vspace(3);
#line 201
  commentln((char *)"ovt_biased: Fat control");
#line 202
  codeln((char *)"void ctl_biased_fat (void *pa, unsigned char uc) {");
#line 203
  pushIndent();
#line 204
  codeln((char *)"struct b_preamp *pp = (struct b_preamp *) pa;");
#line 205
  codeln((char *)"if (uc < 64) {");
#line 206
  pushIndent();
#line 207
  codeln((char *)"if (uc < 32) {");
#line 208
  pushIndent();
#line 209
  sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)"pp->adwFb = %g;",
          0.5821);
#line 210
  codeln(buf);
#line 211
  sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)"pp->adwFb2 = %g + ((%g - %g) * (((float) uc) / 31.0));",
          0.999, 0.5821, 0.999);
#line 213
  codeln(buf);
#line 214
  popIndent();
#line 215
  codeln((char *)"} else {");
#line 216
  pushIndent();
#line 217
  sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)"pp->adwFb = %g + ((%g - %g) * (((float) (uc - 32)) / 31.0));",
          0.5821, 0.999, 0.5821);
#line 219
  codeln(buf);
#line 220
  sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)"pp->adwFb2 = %g;",
          0.5821);
#line 221
  codeln(buf);
#line 222
  popIndent();
#line 223
  codeln((char *)"}");
#line 225
  popIndent();
#line 226
  codeln((char *)"} else {");
#line 227
  pushIndent();
#line 228
  sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)"pp->adwFb = %g;",
          0.999);
#line 229
  codeln(buf);
#line 230
  sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)"pp->adwFb2 = %g + ((%g - %g) * (((float) (uc - 64)) / 63.0));",
          0.5821, 0.999, 0.5821);
#line 232
  codeln(buf);
#line 233
  popIndent();
#line 234
  codeln((char *)"}");
#line 236
  popIndent();
#line 237
  codeln((char *)"}");
#line 239
  vspace(1);
#line 239
  codeln((char *)"void fctl_biased_fat (void *d, float f) {");
#line 239
  pushIndent();
#line 239
  codeln((char *)"ctl_biased_fat (d, (unsigned char)(f*127.0));");
#line 239
  popIndent();
#line 239
  codeln((char *)"}");
  }
#line 241
  return;
}
}
#line 246 "/home/june/repo/benchmarks/collector/temp/setbfree-0.7.5/b_overdrive/ovt_biased.c"
void configSection(int i , void *pa ) 
{ 


  {
  {
#line 247
  sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)"if (getConfigParameter_fr (\"%s\", cfg, &pp->adwFb, %g, %g));",
          "xov.ctl_biased_fb", 0.0, 0.999);
#line 252
  codeln(buf);
#line 254
  sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)"else if (getConfigParameter_fr (\"%s\", cfg, &pp->adwFb2, %g, %g));",
          "xov.ctl_biased_fb2", 0.0, 0.999);
#line 259
  codeln(buf);
#line 261
  sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)"else if (getConfigParameter_f (\"%s\", cfg, &pp->sagFb));",
          "xov.ctl_sagtobias");
#line 264
  codeln(buf);
#line 266
  codeln((char *)"else return 0;");
  }
#line 268
  return;
}
}
#line 270 "/home/june/repo/benchmarks/collector/temp/setbfree-0.7.5/b_overdrive/ovt_biased.c"
void configDoc(int i , void *vp ) 
{ 


  {
  {
#line 271
  codeln((char *)"{\"xov.ctl_biased_fb\", CFG_FLOAT, \"0.5821\", \"This parameter behaves somewhat like an analogue tone control for bass mounted before the overdrive stage. Unity is somewhere around the value 0.6, lesser values takes away bass and lowers the volume while higher values gives more bass and more signal into the overdrive. Must be less than 1.0.\"},");
#line 272
  codeln((char *)"{\"xov.ctl_biased_fb2\", CFG_FLOAT, \"0.999\", \"The fb2 parameter has the same function as fb1 but controls the signal after the overdrive stage. Together the two parameters are useful in that they can reduce the amount of bass going into the overdrive and then recover it on the other side. Must be less than 1.0.\"},");
#line 273
  codeln((char *)"{\"xov.ctl_sagtobias\", CFG_FLOAT, \"0.1880\", \"This parameter is part of an attempt to recreate an artefact called \'power sag\'. When a power amplifier is under heavy load the voltage drops and alters the operating parameters of the unit, usually towards more and other kinds of distortion. The sagfb parameter controls the rate of recovery from the sag effect when the load is lifted. Must be less than 1.0.\"},");
  }
#line 274
  return;
}
}
#line 276 "/home/june/repo/benchmarks/collector/temp/setbfree-0.7.5/b_overdrive/ovt_biased.c"
void ini_biased(void) 
{ 


  {
  {
#line 277
  sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)"cfg_biased (pa, %g);",
          0.5347);
#line 278
  codeln(buf);
#line 281
  sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)"pp->adwFb = %g;",
          0.5821);
#line 282
  codeln(buf);
  }
#line 284
  return;
}
}
#line 286 "/home/june/repo/benchmarks/collector/temp/setbfree-0.7.5/b_overdrive/ovt_biased.c"
void xfr_biased(char *xs , char *ys ) 
{ 


  {
  {
#line 287
  commentln((char *)"Adaptive linear-non-linear transfer function");
#line 290
  commentln((char *)"Global negative feedback");
#line 291
  sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)"%s -= (pp->adwGfb * pp->adwGfZ);",
          xs);
#line 292
  codeln(buf);
#line 296
  codeln((char *)"{");
#line 297
  pushIndent();
#line 298
  sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)"float temp = %s - pp->adwZ;",
          xs);
#line 299
  codeln(buf);
#line 300
  sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)"pp->adwZ = %s + (pp->adwZ * pp->adwFb);",
          xs);
#line 301
  codeln(buf);
#line 302
  sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)"%s = temp;",
          xs);
#line 303
  codeln(buf);
#line 304
  popIndent();
#line 305
  codeln((char *)"}");
#line 310
  sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)"if (%s < 0.0) {",
          xs);
#line 311
  codeln(buf);
#line 312
  pushIndent();
#line 315
  sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)"float x2 = %s - pp->bias;",
          xs);
#line 316
  codeln(buf);
#line 318
  sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)"%s = (1.0 / (1.0 + (x2 * x2))) - 1.0 + pp->norm;",
          ys);
#line 319
  codeln(buf);
#line 321
  popIndent();
#line 322
  codeln((char *)"} else {");
#line 323
  pushIndent();
#line 326
  sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)"float x2 = %s + pp->bias;",
          xs);
#line 327
  codeln(buf);
#line 329
  sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)"%s = 1.0 - pp->norm - (1.0 / (1.0 + (x2 * x2)));",
          ys);
#line 330
  codeln(buf);
#line 332
  popIndent();
#line 333
  codeln((char *)"}");
#line 337
  codeln((char *)"{");
#line 338
  pushIndent();
#line 340
  sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)"float temp = %s + (pp->adwFb2 * pp->adwZ1);",
          ys);
#line 341
  codeln(buf);
#line 342
  sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)"%s = temp - pp->adwZ1;",
          ys);
#line 343
  codeln(buf);
#line 344
  codeln((char *)"pp->adwZ1 = temp;");
#line 346
  popIndent();
#line 347
  codeln((char *)"}");
#line 351
  commentln((char *)"Global negative feedback");
#line 352
  sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)"pp->adwGfZ = %s;",
          ys);
#line 353
  codeln(buf);
  }
#line 355
  return;
}
}
#line 360 "/home/june/repo/benchmarks/collector/temp/setbfree-0.7.5/b_overdrive/ovt_biased.c"
void bindCallbacks(void) 
{ 


  {
  {
#line 361
  bindCallback(7, & configSection, (void *)0);
#line 362
  bindCallback(1, & configDoc, (void *)0);
  }
#line 363
  return;
}
}
#line 63 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) cos)(double __x ) ;
#line 65
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) sin)(double __x ) ;
#line 69 "/usr/include/assert.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) __assert_fail)(char const   *__assertion ,
                                                                                                   char const   *__file ,
                                                                                                   unsigned int __line ,
                                                                                                   char const   *__function ) ;
#line 28 "/home/june/repo/benchmarks/collector/temp/setbfree-0.7.5/b_overdrive/filterTools.h"
void sincApply(double fc , int wdw , double *a , int m ) ;
#line 61 "/home/june/repo/benchmarks/collector/temp/setbfree-0.7.5/b_overdrive/filterTools.c"
double wdw_Hamming(int i , int m ) 
{ 
  double tmp ;

  {
#line 62
  if (! (i < m)) {
    {
#line 62
    __assert_fail("i < m", "/home/june/repo/benchmarks/collector/temp/setbfree-0.7.5/b_overdrive/filterTools.c",
                  62U, "wdw_Hamming");
    }
  }
  {
#line 63
  tmp = cos(((2.0 * 3.14159265358979323846) * (double )i) / (double )(m - 1));
  }
#line 63
  return (0.54 - 0.46 * tmp);
}
}
#line 66 "/home/june/repo/benchmarks/collector/temp/setbfree-0.7.5/b_overdrive/filterTools.c"
double wdw_Blackman(int i , int m ) 
{ 
  double tmp ;
  double tmp___0 ;

  {
#line 67
  if (! (i < m)) {
    {
#line 67
    __assert_fail("i < m", "/home/june/repo/benchmarks/collector/temp/setbfree-0.7.5/b_overdrive/filterTools.c",
                  67U, "wdw_Blackman");
    }
  }
  {
#line 68
  tmp = cos((2.0 * 3.14159265358979323846) * ((double )i / (double )(m - 1)));
#line 68
  tmp___0 = cos((4.0 * 3.14159265358979323846) * ((double )i / (double )(m - 1)));
  }
#line 68
  return ((0.42 - 0.50 * tmp) + 0.08 * tmp___0);
}
}
#line 74 "/home/june/repo/benchmarks/collector/temp/setbfree-0.7.5/b_overdrive/filterTools.c"
double wdw_Hanning(int i , int m ) 
{ 
  double tmp ;

  {
#line 75
  if (! (i < m)) {
    {
#line 75
    __assert_fail("i < m", "/home/june/repo/benchmarks/collector/temp/setbfree-0.7.5/b_overdrive/filterTools.c",
                  75U, "wdw_Hanning");
    }
  }
  {
#line 76
  tmp = cos(((2.0 * 3.14159265358979323846) * (double )i) / (double )(m - 1));
  }
#line 76
  return (0.5 - 0.5 * tmp);
}
}
#line 89 "/home/june/repo/benchmarks/collector/temp/setbfree-0.7.5/b_overdrive/filterTools.c"
void sincApply(double fc , int wdw , double *a , int m ) 
{ 
  int i ;
  int Mp ;
  double sum ;
  double k ;
  double tmp ;
  double tmp___0 ;
  double tmp___1 ;
  double tmp___2 ;

  {
#line 91
  Mp = m - 1;
#line 94
  i = 0;
  {
#line 94
  while (1) {
    while_continue: /* CIL Label */ ;
#line 94
    if (! (i < m)) {
#line 94
      goto while_break;
    }
#line 95
    if (i - Mp / 2 == 0) {
#line 96
      *(a + i) = (2.0 * 3.14159265358979323846) * fc;
    } else {
      {
#line 99
      k = (double )(i - Mp / 2);
#line 100
      tmp = sin(((2.0 * 3.14159265358979323846) * fc) * k);
#line 100
      *(a + i) = tmp / k;
      }
      {
#line 103
      if (wdw == 0) {
#line 103
        goto case_0;
      }
#line 106
      if (wdw == 1) {
#line 106
        goto case_1;
      }
#line 109
      if (wdw == 2) {
#line 109
        goto case_2;
      }
#line 112
      goto switch_default;
      case_0: /* CIL Label */ 
      {
#line 104
      tmp___0 = wdw_Hamming(i, m);
#line 104
      *(a + i) *= tmp___0;
      }
#line 105
      goto switch_break;
      case_1: /* CIL Label */ 
      {
#line 107
      tmp___1 = wdw_Blackman(i, m);
#line 107
      *(a + i) *= tmp___1;
      }
#line 108
      goto switch_break;
      case_2: /* CIL Label */ 
      {
#line 110
      tmp___2 = wdw_Hanning(i, m);
#line 110
      *(a + i) *= tmp___2;
      }
#line 111
      goto switch_break;
      switch_default: /* CIL Label */ 
      {
#line 113
      __assert_fail("0", "/home/june/repo/benchmarks/collector/temp/setbfree-0.7.5/b_overdrive/filterTools.c",
                    113U, "sincApply");
      }
      switch_break: /* CIL Label */ ;
      }
    }
#line 94
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 120
  i = 0;
#line 120
  sum = 0.0;
  {
#line 120
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 120
    if (! (i < m)) {
#line 120
      goto while_break___0;
    }
#line 121
    sum += *(a + i);
#line 120
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 126
  i = 0;
  {
#line 126
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 126
    if (! (i < m)) {
#line 126
      goto while_break___1;
    }
#line 127
    *(a + i) /= sum;
#line 126
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 130
  return;
}
}
#line 169 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 52 "/home/june/repo/benchmarks/collector/temp/setbfree-0.7.5/b_overdrive/overmaker.h"
void code(char *s ) ;
#line 55
void comment(char *s ) ;
#line 94 "/home/june/repo/benchmarks/collector/temp/setbfree-0.7.5/b_overdrive/overmaker.c"
static modCall modvec[8]  ;
#line 100 "/home/june/repo/benchmarks/collector/temp/setbfree-0.7.5/b_overdrive/overmaker.c"
static char *localIncludes[2]  = {      (char *)"overdrive.h",      (char *)((void *)0)};
#line 106 "/home/june/repo/benchmarks/collector/temp/setbfree-0.7.5/b_overdrive/overmaker.c"
static char *systemIncludes[1]  = {      (char *)((void *)0)};
#line 111 "/home/june/repo/benchmarks/collector/temp/setbfree-0.7.5/b_overdrive/overmaker.c"
static float ipwdef[33]  ;
#line 119 "/home/june/repo/benchmarks/collector/temp/setbfree-0.7.5/b_overdrive/overmaker.c"
static float aaldef[33]  ;
#line 127 "/home/june/repo/benchmarks/collector/temp/setbfree-0.7.5/b_overdrive/overmaker.c"
static int R  =    4;
#line 146 "/home/june/repo/benchmarks/collector/temp/setbfree-0.7.5/b_overdrive/overmaker.c"
static IpolDesc ipold[4]  ;
#line 148 "/home/june/repo/benchmarks/collector/temp/setbfree-0.7.5/b_overdrive/overmaker.c"
static int wpw  =    63;
#line 149 "/home/june/repo/benchmarks/collector/temp/setbfree-0.7.5/b_overdrive/overmaker.c"
static int wpp  =    60;
#line 151 "/home/june/repo/benchmarks/collector/temp/setbfree-0.7.5/b_overdrive/overmaker.c"
static FILE *outstr  =    (FILE *)((void *)0);
#line 152 "/home/june/repo/benchmarks/collector/temp/setbfree-0.7.5/b_overdrive/overmaker.c"
static int indent  =    0;
#line 153 "/home/june/repo/benchmarks/collector/temp/setbfree-0.7.5/b_overdrive/overmaker.c"
static int indentDone  =    0;
#line 158 "/home/june/repo/benchmarks/collector/temp/setbfree-0.7.5/b_overdrive/overmaker.c"
static int generatePreFilter  =    0;
#line 164 "/home/june/repo/benchmarks/collector/temp/setbfree-0.7.5/b_overdrive/overmaker.c"
static int generatePostFilter  =    0;
#line 172 "/home/june/repo/benchmarks/collector/temp/setbfree-0.7.5/b_overdrive/overmaker.c"
void installFloats(double *d , float *f , size_t len ) 
{ 
  int i ;

  {
#line 174
  i = 0;
  {
#line 174
  while (1) {
    while_continue: /* CIL Label */ ;
#line 174
    if (! ((size_t )i < len)) {
#line 174
      goto while_break;
    }
#line 175
    *(f + i) = (float )*(d + i);
#line 174
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 177
  return;
}
}
#line 182 "/home/june/repo/benchmarks/collector/temp/setbfree-0.7.5/b_overdrive/overmaker.c"
void computeIpolFilter(double fc , int wdw ) 
{ 
  double D[33] ;

  {
  {
#line 187
  sincApply(fc, wdw, D, 33);
#line 188
  installFloats(D, ipwdef, (size_t )33);
  }
#line 189
  return;
}
}
#line 194 "/home/june/repo/benchmarks/collector/temp/setbfree-0.7.5/b_overdrive/overmaker.c"
void computeAalFilter(double fc , int wdw ) 
{ 
  double D[33] ;

  {
  {
#line 199
  sincApply(fc, wdw, D, 33);
#line 200
  installFloats(D, aaldef, (size_t )33);
  }
#line 201
  return;
}
}
#line 206 "/home/june/repo/benchmarks/collector/temp/setbfree-0.7.5/b_overdrive/overmaker.c"
void computeIpolWeights(void) 
{ 
  int row ;
  int wix ;
  int i ;

  {
#line 209
  row = 0;
  {
#line 209
  while (1) {
    while_continue: /* CIL Label */ ;
#line 209
    if (! (row < 4)) {
#line 209
      goto while_break;
    }
#line 211
    i = 0;
#line 214
    wix = - row;
    {
#line 214
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 214
      if (! (wix < 33)) {
#line 214
        goto while_break___0;
      }
#line 215
      if (0 <= wix) {
#line 216
        ipold[row].weightIndex[i] = wix;
#line 217
        ipold[row].xzIndex[i] = - i;
#line 218
        i ++;
#line 218
        ipold[row].terms = i;
      }
#line 214
      wix += 4;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 209
    row ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 222
  return;
}
}
#line 224 "/home/june/repo/benchmarks/collector/temp/setbfree-0.7.5/b_overdrive/overmaker.c"
void setOutputStream(FILE *fp ) 
{ 


  {
#line 225
  outstr = fp;
#line 226
  return;
}
}
#line 228 "/home/june/repo/benchmarks/collector/temp/setbfree-0.7.5/b_overdrive/overmaker.c"
void code(char *s ) 
{ 
  int i ;

  {
#line 231
  if ((unsigned long )outstr == (unsigned long )((void *)0)) {
#line 232
    outstr = stdout;
  }
#line 235
  if (! indentDone) {
#line 236
    i = 0;
    {
#line 236
    while (1) {
      while_continue: /* CIL Label */ ;
#line 236
      if (! (i < indent)) {
#line 236
        goto while_break;
      }
      {
#line 237
      fprintf((FILE */* __restrict  */)outstr, (char const   */* __restrict  */)"%s",
              " ");
#line 236
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 239
    indentDone = 1;
  }
  {
#line 242
  fprintf((FILE */* __restrict  */)outstr, (char const   */* __restrict  */)"%s",
          s);
  }
#line 243
  return;
}
}
#line 245 "/home/june/repo/benchmarks/collector/temp/setbfree-0.7.5/b_overdrive/overmaker.c"
void codeln(char *s ) 
{ 


  {
  {
#line 246
  code(s);
#line 247
  code((char *)"\n");
#line 248
  indentDone = 0;
  }
#line 249
  return;
}
}
#line 251 "/home/june/repo/benchmarks/collector/temp/setbfree-0.7.5/b_overdrive/overmaker.c"
void vspace(int lines ) 
{ 
  int i ;

  {
#line 253
  i = 0;
  {
#line 253
  while (1) {
    while_continue: /* CIL Label */ ;
#line 253
    if (! (i < lines)) {
#line 253
      goto while_break;
    }
    {
#line 254
    codeln((char *)"");
#line 253
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 256
  return;
}
}
#line 258 "/home/june/repo/benchmarks/collector/temp/setbfree-0.7.5/b_overdrive/overmaker.c"
void comment(char *s ) 
{ 


  {
  {
#line 259
  code((char *)"/* ");
#line 260
  code(s);
#line 261
  code((char *)" */");
  }
#line 262
  return;
}
}
#line 264 "/home/june/repo/benchmarks/collector/temp/setbfree-0.7.5/b_overdrive/overmaker.c"
void commentln(char *s ) 
{ 


  {
  {
#line 265
  comment(s);
#line 266
  codeln((char *)"");
  }
#line 267
  return;
}
}
#line 269 "/home/june/repo/benchmarks/collector/temp/setbfree-0.7.5/b_overdrive/overmaker.c"
void pushIndent(void) 
{ 


  {
#line 270
  indent += 2;
#line 271
  return;
}
}
#line 273 "/home/june/repo/benchmarks/collector/temp/setbfree-0.7.5/b_overdrive/overmaker.c"
void popIndent(void) 
{ 


  {
#line 274
  indent -= 2;
#line 275
  return;
}
}
#line 280 "/home/june/repo/benchmarks/collector/temp/setbfree-0.7.5/b_overdrive/overmaker.c"
void includeSystem(char *headerFile ) 
{ 


  {
  {
#line 281
  code((char *)"#include <");
#line 282
  code(headerFile);
#line 283
  codeln((char *)">");
  }
#line 284
  return;
}
}
#line 289 "/home/june/repo/benchmarks/collector/temp/setbfree-0.7.5/b_overdrive/overmaker.c"
void includeLocal(char *headerFile ) 
{ 


  {
  {
#line 290
  code((char *)"#include \"");
#line 291
  code(headerFile);
#line 292
  codeln((char *)"\"");
  }
#line 293
  return;
}
}
#line 298 "/home/june/repo/benchmarks/collector/temp/setbfree-0.7.5/b_overdrive/overmaker.c"
void moduleHeader(void) 
{ 
  int i ;
  char buf___0[512] ;

  {
  {
#line 303
  includeSystem((char *)"stdio.h");
#line 304
  includeSystem((char *)"stdlib.h");
#line 305
  includeSystem((char *)"string.h");
#line 306
  includeSystem((char *)"math.h");
#line 308
  i = 0;
  }
  {
#line 308
  while (1) {
    while_continue: /* CIL Label */ ;
#line 308
    if (! ((unsigned long )systemIncludes[i] != (unsigned long )((void *)0))) {
#line 308
      goto while_break;
    }
    {
#line 309
    includeSystem(systemIncludes[i]);
#line 308
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 312
  i = 0;
  {
#line 312
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 312
    if (! ((unsigned long )localIncludes[i] != (unsigned long )((void *)0))) {
#line 312
      goto while_break___0;
    }
    {
#line 313
    includeLocal(localIncludes[i]);
#line 312
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 321
  vspace(2);
#line 325
  commentln((char *)"Decimation filter definition");
#line 326
  sprintf((char */* __restrict  */)(buf___0), (char const   */* __restrict  */)"static const float aaldef[%d] = {",
          33);
#line 327
  codeln(buf___0);
#line 328
  pushIndent();
#line 329
  i = 0;
  }
  {
#line 329
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 329
    if (! (i < 32)) {
#line 329
      goto while_break___1;
    }
    {
#line 330
    sprintf((char */* __restrict  */)(buf___0), (char const   */* __restrict  */)"%*.*f,",
            wpw, wpp, (double )aaldef[i]);
#line 331
    codeln(buf___0);
#line 329
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 333
  sprintf((char */* __restrict  */)(buf___0), (char const   */* __restrict  */)"%*.*f",
          wpw, wpp, (double )aaldef[i]);
#line 334
  codeln(buf___0);
#line 335
  popIndent();
#line 336
  codeln((char *)"};");
#line 338
  vspace(1);
#line 343
  vspace(1);
#line 345
  commentln((char *)"Weight count for wi[][] above.");
#line 346
  sprintf((char */* __restrict  */)(buf___0), (char const   */* __restrict  */)"static const int wiLen[%d] = {",
          R);
#line 347
  codeln(buf___0);
#line 348
  pushIndent();
#line 349
  i = 0;
  }
  {
#line 349
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 349
    if (! (i < R - 1)) {
#line 349
      goto while_break___2;
    }
    {
#line 350
    sprintf((char */* __restrict  */)(buf___0), (char const   */* __restrict  */)"%d,",
            ipold[i].terms);
#line 351
    codeln(buf___0);
#line 349
    i ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 353
  sprintf((char */* __restrict  */)(buf___0), (char const   */* __restrict  */)"%d",
          ipold[i].terms);
#line 354
  codeln(buf___0);
#line 355
  popIndent();
#line 356
  codeln((char *)"};");
#line 358
  vspace(1);
#line 362
  commentln((char *)"Interpolation filter definition");
#line 364
  sprintf((char */* __restrict  */)(buf___0), (char const   */* __restrict  */)"static const float ipwdef[%d] = {",
          33);
#line 365
  codeln(buf___0);
#line 367
  pushIndent();
#line 369
  i = 0;
  }
  {
#line 369
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 369
    if (! (i < 32)) {
#line 369
      goto while_break___3;
    }
    {
#line 370
    sprintf((char */* __restrict  */)(buf___0), (char const   */* __restrict  */)"% *.*f,",
            wpw, wpp, (double )ipwdef[i]);
#line 371
    codeln(buf___0);
#line 369
    i ++;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 373
  sprintf((char */* __restrict  */)(buf___0), (char const   */* __restrict  */)"% *.*f",
          wpw, wpp, (double )ipwdef[i]);
#line 374
  codeln(buf___0);
#line 376
  popIndent();
#line 378
  codeln((char *)"};");
#line 380
  vspace(1);
#line 631
  vspace(2);
#line 632
  codeln((char *)"struct b_preamp {");
#line 633
  pushIndent();
#line 635
  commentln((char *)"Input history buffer");
#line 636
  sprintf((char */* __restrict  */)(buf___0), (char const   */* __restrict  */)"float xzb[%d];",
          64);
#line 637
  codeln(buf___0);
#line 639
  commentln((char *)"Input history writer");
#line 640
  codeln((char *)"float * xzp;");
#line 641
  commentln((char *)"Input history end sentinel");
#line 642
  codeln((char *)"float * xzpe;");
#line 643
  vspace(1);
#line 644
  commentln((char *)"Negative index access wrap sentinel");
#line 645
  codeln((char *)"float * xzwp;");
#line 647
  commentln((char *)"Transfer-function output history buffer");
#line 648
  sprintf((char */* __restrict  */)(buf___0), (char const   */* __restrict  */)"float yzb[%d];",
          128);
#line 649
  codeln(buf___0);
#line 650
  commentln((char *)"Transfer-function output writer");
#line 651
  codeln((char *)"float * yzp;");
#line 652
  commentln((char *)"Transfer-function output history end sentinel");
#line 653
  codeln((char *)"float * yzpe;");
#line 654
  commentln((char *)"Transfer-function output history wrap sentinel");
#line 655
  codeln((char *)"float * yzwp;");
#line 657
  commentln((char *)"Zero-filled filter of interpolation length");
#line 658
  sprintf((char */* __restrict  */)(buf___0), (char const   */* __restrict  */)"float ipolZeros[%d];",
          33);
#line 659
  codeln(buf___0);
#line 663
  commentln((char *)"Sample-specific runtime interpolation FIRs");
#line 664
  sprintf((char */* __restrict  */)(buf___0), (char const   */* __restrict  */)"float wi[%d][%d];",
          R, 9);
#line 665
  codeln(buf___0);
#line 667
  commentln((char *)"Decimation filter runtime");
#line 668
  sprintf((char */* __restrict  */)(buf___0), (char const   */* __restrict  */)"float aal[%d];",
          33);
#line 669
  codeln(buf___0);
#line 671
  commentln((char *)"Decimation filter end sentinel");
#line 672
  codeln((char *)"float * aalEnd;");
#line 678
  codeln((char *)"size_t ipolFilterLength;");
#line 679
  codeln((char *)"size_t aalFilterLength;");
#line 681
  commentln((char *)"Zero-filled filter of anti-aliasing length");
#line 682
  sprintf((char */* __restrict  */)(buf___0), (char const   */* __restrict  */)"float aalZeros[%d];",
          33);
#line 683
  codeln(buf___0);
#line 685
  commentln((char *)"Clean/overdrive switch");
#line 686
  codeln((char *)"int isClean;");
#line 692
  codeln((char *)"float outputGain;");
#line 703
  vspace(1);
#line 704
  commentln((char *)"Input gain");
#line 705
  codeln((char *)"float inputGain;");
#line 724
  codeln((char *)"float sagZ;");
#line 725
  codeln((char *)"float sagFb;");
#line 729
  hdr_biased();
#line 732
  popIndent();
#line 733
  codeln((char *)"};");
#line 734
  commentln((char *)" *** END STRUCT ***");
#line 735
  vspace(2);
  }
#line 736
  return;
}
}
#line 744 "/home/june/repo/benchmarks/collector/temp/setbfree-0.7.5/b_overdrive/overmaker.c"
void preIpolMixer(void) 
{ 
  int row ;
  int column ;
  char buf___0[512] ;

  {
  {
#line 749
  vspace(3);
#line 751
  commentln((char *)"Remember to call this first with the filter definitions");
#line 752
  commentln((char *)"ipolDef is the interpolation filter definition");
#line 753
  commentln((char *)"aalDef is the anti-aliasing filter definition");
#line 755
  codeln((char *)"void mixFilterWeights (void *pa, const float * ipolDef, const float * aalDef) {");
#line 756
  pushIndent();
#line 757
  codeln((char *)"struct b_preamp *pp = (struct b_preamp *) pa;");
#line 758
  codeln((char *)"int i;");
#line 759
  codeln((char *)"float sum = 0.0;");
#line 760
  vspace(1);
#line 761
  sprintf((char */* __restrict  */)(buf___0), (char const   */* __restrict  */)"float mix[%d];",
          33);
#line 762
  codeln(buf___0);
#line 764
  vspace(1);
#line 766
  commentln((char *)"Copy the interpolation filter weights");
#line 768
  vspace(1);
#line 770
  sprintf((char */* __restrict  */)(buf___0), (char const   */* __restrict  */)"for (i = 0; i < %d; i++) {",
          33);
#line 771
  codeln(buf___0);
#line 772
  pushIndent();
#line 773
  codeln((char *)"mix[i] = ipolDef[i];");
#line 774
  codeln((char *)"sum += fabs (mix[i]);");
#line 775
  popIndent();
#line 776
  codeln((char *)"}");
#line 778
  vspace(1);
#line 780
  commentln((char *)"Normalize the copy");
#line 782
  vspace(1);
#line 784
  sprintf((char */* __restrict  */)(buf___0), (char const   */* __restrict  */)"for (i = 0; i < %d; i++) {",
          33);
#line 785
  codeln(buf___0);
#line 786
  pushIndent();
#line 787
  codeln((char *)"mix[i] /= sum;");
#line 788
  popIndent();
#line 789
  codeln((char *)"}");
#line 791
  vspace(1);
#line 793
  commentln((char *)"Install in correct sequence in runtime array of weights");
#line 795
  vspace(1);
#line 797
  row = 0;
  }
  {
#line 797
  while (1) {
    while_continue: /* CIL Label */ ;
#line 797
    if (! (row < 4)) {
#line 797
      goto while_break;
    }
#line 798
    column = 0;
    {
#line 798
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 798
      if (! (column < ipold[row].terms)) {
#line 798
        goto while_break___0;
      }
      {
#line 799
      sprintf((char */* __restrict  */)(buf___0), (char const   */* __restrict  */)"pp->wi[%d][%d] = mix[%d];",
              row, column, ipold[row].weightIndex[column]);
#line 804
      codeln(buf___0);
#line 798
      column ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 797
    row ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 808
  vspace(1);
#line 810
  commentln((char *)"Copy the anti-aliasing filter definition");
#line 812
  vspace(1);
#line 814
  codeln((char *)"sum = 0.0;");
#line 815
  sprintf((char */* __restrict  */)(buf___0), (char const   */* __restrict  */)"for (i = 0; i < %d; i++) {",
          33);
#line 816
  codeln(buf___0);
#line 817
  pushIndent();
#line 818
  codeln((char *)"mix[i] = aalDef[i];");
#line 819
  codeln((char *)"sum += fabs (mix[i]);");
#line 820
  popIndent();
#line 821
  codeln((char *)"}");
#line 823
  vspace(1);
#line 825
  commentln((char *)"Normalize the weights to unit gain and install");
#line 827
  vspace(1);
#line 829
  sprintf((char */* __restrict  */)(buf___0), (char const   */* __restrict  */)"for (i = 0; i < %d; i++) {",
          33);
#line 830
  codeln(buf___0);
#line 831
  pushIndent();
#line 832
  codeln((char *)"pp->aal[i] = mix[i] / sum;");
#line 833
  popIndent();
#line 834
  codeln((char *)"}");
#line 836
  popIndent();
#line 837
  code((char *)"}");
#line 838
  code((char *)" ");
#line 839
  commentln((char *)"preFilterCompile");
  }
#line 841
  return;
}
}
#line 846 "/home/june/repo/benchmarks/collector/temp/setbfree-0.7.5/b_overdrive/overmaker.c"
void funcHeader(char *funcName ) 
{ 
  char buf___0[512] ;

  {
  {
#line 850
  vspace(3);
#line 852
  sprintf((char */* __restrict  */)(buf___0), (char const   */* __restrict  */)"float * %s (void *pa, const float * inBuf, float * outBuf, size_t buflen)",
          funcName);
#line 855
  codeln(buf___0);
#line 856
  codeln((char *)"{");
#line 857
  pushIndent();
#line 858
  codeln((char *)"struct b_preamp *pp = (struct b_preamp *) pa;");
  }
#line 859
  return;
}
}
#line 864 "/home/june/repo/benchmarks/collector/temp/setbfree-0.7.5/b_overdrive/overmaker.c"
void funcVarDef(void) 
{ 


  {
  {
#line 865
  codeln((char *)"const float * xp = inBuf;");
#line 866
  codeln((char *)"float * yp = outBuf;");
#line 867
  codeln((char *)"int i;");
#line 868
  codeln((char *)"int n;");
  }
#line 869
  return;
}
}
#line 874 "/home/june/repo/benchmarks/collector/temp/setbfree-0.7.5/b_overdrive/overmaker.c"
void funcBody(void (*transferdef)(char * , char * ) ) 
{ 
  char buf___0[512] ;

  {
  {
#line 879
  vspace(1);
#line 880
  codeln((char *)"for (n = 0; n < buflen; n++) {");
#line 881
  pushIndent();
#line 882
  codeln((char *)"float xin;");
#line 883
  codeln((char *)"float u = 0.0;");
#line 884
  codeln((char *)"float v;");
#line 885
  codeln((char *)"float y = 0.0;");
  }
#line 891
  if (generatePreFilter) {
    {
#line 892
    codeln((char *)"float Z0;");
    }
  } else
#line 891
  if (generatePostFilter) {
    {
#line 892
    codeln((char *)"float Z0;");
    }
  }
  {
#line 896
  vspace(1);
#line 897
  commentln((char *)"Place the next input sample in the input history.");
#line 898
  codeln((char *)"if (++(pp->xzp) == pp->xzpe) {");
#line 899
  pushIndent();
#line 900
  codeln((char *)"pp->xzp = pp->xzb;");
#line 901
  popIndent();
#line 902
  codeln((char *)"}");
#line 904
  vspace(1);
#line 907
  codeln((char *)"xin = pp->inputGain * (*xp++);");
#line 914
  codeln((char *)"pp->sagZ = (pp->sagFb * pp->sagZ) + fabsf(xin);");
#line 915
  codeln((char *)"pp->bias = pp->biasBase - (pp->sagZgb * pp->sagZ);");
#line 916
  codeln((char *)"pp->norm = 1.0 - (1.0 / (1.0 + (pp->bias * pp->bias)));");
  }
#line 933
  if (generatePreFilter) {
    {
#line 934
    codeln((char *)"Z0 = xin - (pr_a1 * pr_z1) - (pr_a2 * pr_z2);");
#line 935
    codeln((char *)"*(pp->xzp) = (Z0 * pp->pr_b0) + (pp->pr_b1 * pp->pr_z1) + (pp->pr_b2 * pp->pr_z2);");
#line 936
    codeln((char *)"pp->pr_z2 = pp->pr_z1;");
#line 937
    codeln((char *)"pp->pr_z1 = Z0;");
    }
  } else {
    {
#line 940
    codeln((char *)"*(pp->xzp) = xin;");
    }
  }
  {
#line 944
  vspace(1);
#line 952
  commentln((char *)"Check the input history wrap sentinel");
#line 953
  codeln((char *)"if (pp->xzwp <= pp->xzp) {");
#line 954
  pushIndent();
#line 958
  sprintf((char */* __restrict  */)(buf___0), (char const   */* __restrict  */)"for (i = 0; i < %d; i++) {",
          R);
#line 959
  codeln(buf___0);
#line 960
  pushIndent();
#line 962
  vspace(1);
#line 964
  commentln((char *)"wp is ptr to interpol. filter weights for this sample");
#line 965
  codeln((char *)"float * wp = &(pp->wi[i][0]);");
#line 967
  vspace(1);
#line 969
  commentln((char *)"wpe is FIR weight end sentinel");
#line 970
  codeln((char *)"float * wpe = wp + wiLen[i];");
#line 972
  vspace(1);
#line 974
  commentln((char *)"xr is ptr to samples in input history");
#line 975
  codeln((char *)"float * xr = pp->xzp;");
#line 977
  vspace(1);
#line 979
  commentln((char *)"Apply convolution");
#line 981
  codeln((char *)"while (wp < wpe) {");
#line 982
  pushIndent();
#line 983
  codeln((char *)"u += ((*wp++) * (*xr--));");
#line 984
  popIndent();
#line 985
  codeln((char *)"}");
#line 987
  popIndent();
#line 988
  codeln((char *)"}");
#line 990
  popIndent();
#line 991
  codeln((char *)"}");
#line 992
  codeln((char *)"else {");
#line 993
  pushIndent();
#line 994
  commentln((char *)"Wrapping code");
#line 1004
  sprintf((char */* __restrict  */)(buf___0), (char const   */* __restrict  */)"for (i = 0; i < %d; i++) {",
          R);
#line 1005
  codeln(buf___0);
#line 1006
  pushIndent();
#line 1008
  vspace(1);
#line 1010
  commentln((char *)"Interpolation weights for this sample");
#line 1011
  codeln((char *)"float * wp = &(pp->wi[i][0]);");
#line 1013
  commentln((char *)"Weight end sentinel");
#line 1014
  codeln((char *)"float * wpe = wp + wiLen[i];");
#line 1016
  commentln((char *)"Input history read pointer");
#line 1017
  codeln((char *)"float * xr = pp->xzp;");
#line 1019
  vspace(1);
#line 1021
  codeln((char *)"while (pp->xzb <= xr) {");
#line 1022
  pushIndent();
#line 1023
  codeln((char *)"u += ((*wp++) * (*xr--));");
#line 1024
  popIndent();
#line 1025
  codeln((char *)"}");
#line 1027
  vspace(1);
#line 1029
  sprintf((char */* __restrict  */)(buf___0), (char const   */* __restrict  */)"xr = &(pp->xzb[%d]);",
          63);
#line 1030
  codeln(buf___0);
#line 1032
  vspace(1);
#line 1034
  codeln((char *)"while (wp < wpe) {");
#line 1035
  pushIndent();
#line 1036
  codeln((char *)"u += ((*wp++) * (*xr--));");
#line 1037
  popIndent();
#line 1038
  codeln((char *)"}");
#line 1040
  popIndent();
#line 1041
  codeln((char *)"}");
#line 1043
  popIndent();
#line 1044
  codeln((char *)"}");
#line 1048
  vspace(1);
#line 1050
  commentln((char *)"Apply transfer function");
#line 1051
  commentln((char *)"v = T (u);");
#line 1067
  (*transferdef)((char *)"u", (char *)"v");
#line 1083
  vspace(1);
#line 1085
  commentln((char *)"Put transferred sample in output history.");
#line 1086
  codeln((char *)"if (++pp->yzp == pp->yzpe) {");
#line 1087
  pushIndent();
#line 1088
  codeln((char *)"pp->yzp = pp->yzb;");
#line 1089
  popIndent();
#line 1090
  codeln((char *)"}");
#line 1091
  codeln((char *)"*(pp->yzp) = v;");
#line 1098
  vspace(1);
#line 1100
  commentln((char *)"Decimation");
#line 1101
  codeln((char *)"if (pp->yzwp <= pp->yzp) {");
#line 1102
  pushIndent();
#line 1104
  commentln((char *)"No-wrap code");
#line 1105
  commentln((char *)"wp points to weights in the decimation FIR");
#line 1106
  codeln((char *)"float * wp = pp->aal;");
#line 1107
  codeln((char *)"float * yr = pp->yzp;");
#line 1109
  vspace(1);
#line 1111
  commentln((char *)"Convolve with decimation filter.");
#line 1112
  codeln((char *)"while (wp < pp->aalEnd) {");
#line 1113
  pushIndent();
#line 1114
  codeln((char *)"y += ((*wp++) * (*yr--));");
#line 1115
  popIndent();
#line 1116
  codeln((char *)"}");
#line 1118
  popIndent();
#line 1119
  codeln((char *)"}");
#line 1120
  codeln((char *)"else {");
#line 1121
  pushIndent();
#line 1122
  commentln((char *)"Wrap code");
#line 1125
  codeln((char *)"float * wp = pp->aal;");
#line 1126
  codeln((char *)"float * yr = pp->yzp;");
#line 1128
  vspace(1);
#line 1130
  codeln((char *)"while (pp->yzb <= yr) {");
#line 1131
  pushIndent();
#line 1132
  codeln((char *)"y += ((*wp++) * (*yr--));");
#line 1133
  popIndent();
#line 1134
  codeln((char *)"}");
#line 1136
  vspace(1);
#line 1138
  sprintf((char */* __restrict  */)(buf___0), (char const   */* __restrict  */)"yr = &(pp->yzb[%d]);",
          127);
#line 1139
  codeln(buf___0);
#line 1141
  vspace(1);
#line 1143
  codeln((char *)"while (wp < pp->aalEnd) {");
#line 1144
  pushIndent();
#line 1145
  codeln((char *)"y += ((*wp++) * (*yr--));");
#line 1146
  popIndent();
#line 1147
  codeln((char *)"}");
#line 1149
  popIndent();
#line 1150
  codeln((char *)"}");
#line 1152
  vspace(1);
  }
#line 1154
  if (generatePostFilter) {
    {
#line 1155
    __assert_fail("0", "/home/june/repo/benchmarks/collector/temp/setbfree-0.7.5/b_overdrive/overmaker.c",
                  1155U, "funcBody");
#line 1156
    codeln((char *)"Z0 = y - (de_a1 * de_z1) - (de_a2 * de_z2);");
#line 1157
    codeln((char *)"xin = (de_b0 * Z0) + (de_b1 * de_z1) + (de_b2 * de_z2);");
#line 1158
    codeln((char *)"de_z2 = de_z1;");
#line 1159
    codeln((char *)"de_z1 = Z0;");
    }
  }
  {
#line 1180
  codeln((char *)"*yp++ = pp->outputGain * y;");
#line 1187
  popIndent();
#line 1188
  codeln((char *)"}");
#line 1189
  commentln((char *)"End of for-loop over input buffer");
#line 1190
  codeln((char *)"return outBuf;");
  }
#line 1191
  return;
}
}
#line 1196 "/home/june/repo/benchmarks/collector/temp/setbfree-0.7.5/b_overdrive/overmaker.c"
void funcTrailer(char *funcName ) 
{ 


  {
  {
#line 1197
  popIndent();
#line 1198
  code((char *)"} ");
#line 1199
  commentln(funcName);
  }
#line 1200
  return;
}
}
#line 1205 "/home/june/repo/benchmarks/collector/temp/setbfree-0.7.5/b_overdrive/overmaker.c"
void t_unity(char *xs , char *ys ) 
{ 
  char buf___0[512] ;

  {
#line 1208
  if (! ((unsigned long )xs != (unsigned long )((void *)0))) {
    {
#line 1208
    __assert_fail("xs != ((void *)0)", "/home/june/repo/benchmarks/collector/temp/setbfree-0.7.5/b_overdrive/overmaker.c",
                  1208U, "t_unity");
    }
  }
#line 1209
  if (! ((unsigned long )ys != (unsigned long )((void *)0))) {
    {
#line 1209
    __assert_fail("ys != ((void *)0)", "/home/june/repo/benchmarks/collector/temp/setbfree-0.7.5/b_overdrive/overmaker.c",
                  1209U, "t_unity");
    }
  }
  {
#line 1211
  commentln((char *)"Unity function");
#line 1212
  sprintf((char */* __restrict  */)(buf___0), (char const   */* __restrict  */)"%s = %s;",
          ys, xs);
#line 1213
  codeln(buf___0);
  }
#line 1214
  return;
}
}
#line 1219 "/home/june/repo/benchmarks/collector/temp/setbfree-0.7.5/b_overdrive/overmaker.c"
void t_cubic1(char *xs , char *ys ) 
{ 
  char buf___0[512] ;

  {
  {
#line 1221
  commentln((char *)"Cubic function");
#line 1222
  codeln((char *)"{");
#line 1223
  pushIndent();
#line 1224
  sprintf((char */* __restrict  */)(buf___0), (char const   */* __restrict  */)"float e = 6.0 * %s;",
          xs);
#line 1225
  codeln(buf___0);
#line 1226
  codeln((char *)"if (e < 0.0) {");
#line 1227
  pushIndent();
#line 1228
  codeln((char *)"e = -e;");
#line 1229
  sprintf((char */* __restrict  */)(buf___0), (char const   */* __restrict  */)"%s = (e + e) - (e * e);",
          ys);
#line 1230
  codeln(buf___0);
#line 1231
  sprintf((char */* __restrict  */)(buf___0), (char const   */* __restrict  */)"%s = -%s;",
          ys, ys);
#line 1232
  codeln(buf___0);
#line 1233
  popIndent();
#line 1234
  codeln((char *)"} else {");
#line 1235
  pushIndent();
#line 1236
  sprintf((char */* __restrict  */)(buf___0), (char const   */* __restrict  */)"%s = (e + e) - (e * e);",
          ys);
#line 1237
  codeln(buf___0);
#line 1238
  popIndent();
#line 1239
  codeln((char *)"}");
#line 1240
  popIndent();
#line 1241
  codeln((char *)"}");
  }
#line 1242
  return;
}
}
#line 1246 "/home/june/repo/benchmarks/collector/temp/setbfree-0.7.5/b_overdrive/overmaker.c"
void adapterPreamp(char *funcName ) 
{ 
  int xbufSize ;
  int ybufSize ;
  char buf___0[512] ;

  {
  {
#line 1247
  xbufSize = 256;
#line 1248
  ybufSize = 256;
#line 1251
  vspace(3);
#line 1252
  commentln((char *)"Adapter function");
#line 1253
  codeln((char *)"float * preamp (void * pa,");
#line 1254
  codeln((char *)"                float * inBuf,");
#line 1255
  codeln((char *)"                float * outBuf,");
#line 1256
  codeln((char *)"                size_t bufLengthSamples) {");
#line 1257
  pushIndent();
#line 1258
  codeln((char *)"struct b_preamp *pp = (struct b_preamp *) pa;");
#line 1260
  codeln((char *)"if (pp->isClean) {");
#line 1261
  pushIndent();
#line 1262
  codeln((char *)"memcpy(outBuf, inBuf, bufLengthSamples*sizeof(float));");
#line 1263
  popIndent();
#line 1264
  codeln((char *)"}");
#line 1265
  codeln((char *)"else {");
#line 1266
  pushIndent();
#line 1267
  codeln((char *)"overdrive (pa, inBuf, outBuf, bufLengthSamples);");
#line 1268
  popIndent();
#line 1269
  codeln((char *)"}");
#line 1271
  vspace(1);
#line 1273
  codeln((char *)"return outBuf;");
#line 1275
  popIndent();
#line 1276
  codeln((char *)"}");
#line 1278
  vspace(2);
#line 1279
  codeln((char *)"void * allocPreamp () {");
#line 1280
  pushIndent();
#line 1281
  codeln((char *)"struct b_preamp *pp = (struct b_preamp *) calloc(1, sizeof(struct b_preamp));");
#line 1284
  codeln((char *)"pp->xzp = &(pp->xzb[0]);");
#line 1285
  sprintf((char */* __restrict  */)(buf___0), (char const   */* __restrict  */)"pp->xzpe = &(pp->xzb[%d]);",
          64);
#line 1286
  codeln(buf___0);
#line 1287
  sprintf((char */* __restrict  */)(buf___0), (char const   */* __restrict  */)"pp->xzwp = &(pp->xzb[%d]);",
          9);
#line 1288
  codeln(buf___0);
#line 1289
  codeln((char *)"pp->yzp = &(pp->yzb[0]);");
#line 1290
  sprintf((char */* __restrict  */)(buf___0), (char const   */* __restrict  */)"pp->yzpe = &(pp->yzb[%d]);",
          128);
#line 1291
  codeln(buf___0);
#line 1292
  sprintf((char */* __restrict  */)(buf___0), (char const   */* __restrict  */)"pp->yzwp = &(pp->yzb[%d]);",
          33);
#line 1293
  codeln(buf___0);
#line 1294
  sprintf((char */* __restrict  */)(buf___0), (char const   */* __restrict  */)"pp->aalEnd = &(pp->aal[%d]);",
          33);
#line 1295
  codeln(buf___0);
#line 1297
  sprintf((char */* __restrict  */)(buf___0), (char const   */* __restrict  */)"pp->ipolFilterLength = %d;",
          33);
#line 1298
  codeln(buf___0);
#line 1299
  sprintf((char */* __restrict  */)(buf___0), (char const   */* __restrict  */)"pp->aalFilterLength = %d;",
          33);
#line 1300
  codeln(buf___0);
#line 1301
  codeln((char *)"pp->isClean = 1;");
#line 1307
  sprintf((char */* __restrict  */)(buf___0), (char const   */* __restrict  */)"pp->outputGain = %g;",
          0.8795);
#line 1308
  codeln(buf___0);
#line 1317
  sprintf((char */* __restrict  */)(buf___0), (char const   */* __restrict  */)"pp->inputGain = %g;",
          3.5675);
#line 1318
  codeln(buf___0);
#line 1337
  vspace(3);
#line 1338
  codeln((char *)"pp->sagZ = 0.0;");
#line 1339
  sprintf((char */* __restrict  */)(buf___0), (char const   */* __restrict  */)"pp->sagFb = %g;",
          0.991);
#line 1340
  codeln(buf___0);
#line 1344
  codeln(buf___0);
#line 1346
  rst_biased();
#line 1349
  codeln((char *)"return pp;");
#line 1350
  popIndent();
#line 1351
  codeln((char *)"}");
#line 1352
  vspace(2);
#line 1353
  codeln((char *)"void freePreamp (void * pa) {");
#line 1354
  pushIndent();
#line 1355
  codeln((char *)"struct b_preamp *pp = (struct b_preamp *) pa;");
#line 1356
  codeln((char *)"free(pp);");
#line 1357
  popIndent();
#line 1358
  codeln((char *)"}");
  }
#line 1359
  return;
}
}
#line 1361 "/home/june/repo/benchmarks/collector/temp/setbfree-0.7.5/b_overdrive/overmaker.c"
void legacyInit(void) 
{ 
  char buf___0[512] ;

  {
  {
#line 1363
  vspace(3);
#line 1364
  commentln((char *)"Legacy function");
#line 1365
  codeln((char *)"void initPreamp (void *pa, void *m) {");
#line 1366
  pushIndent();
#line 1367
  codeln((char *)"struct b_preamp *pp = (struct b_preamp *) pa;");
#line 1368
  codeln((char *)"mixFilterWeights (pa, ipwdef, aaldef);");
#line 1395
  sprintf((char */* __restrict  */)(buf___0), (char const   */* __restrict  */)"useMIDIControlFunction (m, \"xov.ctl_biased\", ctl_biased, pa);");
#line 1396
  codeln(buf___0);
#line 1399
  sprintf((char */* __restrict  */)(buf___0), (char const   */* __restrict  */)"useMIDIControlFunction (m, \"xov.ctl_biased_fb\", ctl_biased_fb, pa);");
#line 1401
  codeln(buf___0);
#line 1405
  sprintf((char */* __restrict  */)(buf___0), (char const   */* __restrict  */)"useMIDIControlFunction (m, \"xov.ctl_biased_fb2\", ctl_biased_fb2, pa);");
#line 1407
  codeln(buf___0);
#line 1411
  sprintf((char */* __restrict  */)(buf___0), (char const   */* __restrict  */)"useMIDIControlFunction (m, \"xov.ctl_biased_gfb\", ctl_biased_gfb, pa);");
#line 1413
  codeln(buf___0);
#line 1417
  sprintf((char */* __restrict  */)(buf___0), (char const   */* __restrict  */)"useMIDIControlFunction (m, \"xov.ctl_sagtobias\", ctl_sagtoBias, pa);");
#line 1419
  codeln(buf___0);
#line 1423
  sprintf((char */* __restrict  */)(buf___0), (char const   */* __restrict  */)"useMIDIControlFunction (m, \"overdrive.character\", ctl_biased_fat, pa);");
#line 1428
  codeln(buf___0);
#line 1431
  ini_biased();
#line 1436
  sprintf((char */* __restrict  */)(buf___0), (char const   */* __restrict  */)"useMIDIControlFunction (m, \"overdrive.enable\", setCleanCC, pa);");
#line 1437
  codeln(buf___0);
#line 1440
  sprintf((char */* __restrict  */)(buf___0), (char const   */* __restrict  */)"useMIDIControlFunction (m, \"overdrive.inputgain\", setInputGain, pa);");
#line 1441
  codeln(buf___0);
#line 1445
  sprintf((char */* __restrict  */)(buf___0), (char const   */* __restrict  */)"useMIDIControlFunction (m, \"overdrive.outputgain\", setOutputGain, pa);");
#line 1446
  codeln(buf___0);
#line 1463
  popIndent();
#line 1464
  codeln((char *)"}");
  }
#line 1465
  return;
}
}
#line 1467 "/home/june/repo/benchmarks/collector/temp/setbfree-0.7.5/b_overdrive/overmaker.c"
void legacyConfig(void) 
{ 
  char buf___0[512] ;

  {
  {
#line 1469
  vspace(3);
#line 1470
  commentln((char *)"Legacy function");
#line 1471
  codeln((char *)"int ampConfig (void *pa, ConfigContext * cfg) {");
#line 1472
  pushIndent();
#line 1473
  codeln((char *)"struct b_preamp *pp = (struct b_preamp *) pa;");
#line 1474
  codeln((char *)"int rtn = 1;");
#line 1475
  codeln((char *)"float v = 0;");
#line 1477
  vspace(1);
#line 1478
  commentln((char *)"Config generated by overmaker");
#line 1479
  vspace(1);
#line 1481
  sprintf((char */* __restrict  */)(buf___0), (char const   */* __restrict  */)"if (getConfigParameter_f (\"%s\", cfg, &%s)) return 1;",
          "overdrive.inputgain", "pp->inputGain");
#line 1484
  codeln(buf___0);
#line 1486
  sprintf((char */* __restrict  */)(buf___0), (char const   */* __restrict  */)"else if (getConfigParameter_f (\"%s\", cfg, &%s)) return 1;",
          "overdrive.outputgain", "pp->outputGain");
#line 1489
  codeln(buf___0);
#line 1492
  sprintf((char */* __restrict  */)(buf___0), (char const   */* __restrict  */)"else if (getConfigParameter_f (\"%s\", cfg, &v)) { %s(pp, v); return 1; }",
          "xov.ctl_biased_gfb", "fctl_biased_gfb");
#line 1495
  codeln(buf___0);
#line 1499
  sprintf((char */* __restrict  */)(buf___0), (char const   */* __restrict  */)"else if (getConfigParameter_f (\"%s\", cfg, &v)) { %s(pp, v); return 1; }",
          "xov.ctl_biased", "fctl_biased");
#line 1502
  codeln(buf___0);
#line 1506
  sprintf((char */* __restrict  */)(buf___0), (char const   */* __restrict  */)"else if (getConfigParameter_f (\"%s\", cfg, &v)) { %s(pp, v); return 1; }",
          "overdrive.character", "fctl_biased_fat");
#line 1509
  codeln(buf___0);
#line 1512
  vspace(1);
#line 1513
  commentln((char *)"Config generated by external module");
#line 1514
  vspace(2);
  }
#line 1517
  if ((unsigned long )modvec[7].fn != (unsigned long )((void *)0)) {
    {
#line 1518
    (*(modvec[7].fn))(7, modvec[7].handback);
    }
  }
  {
#line 1520
  codeln((char *)"return rtn;");
#line 1521
  popIndent();
#line 1522
  codeln((char *)"}");
#line 1523
  vspace(2);
#line 1524
  codeln((char *)"static const ConfigDoc doc[] = {");
#line 1525
  pushIndent();
#line 1526
  codeln((char *)"{\"overdrive.inputgain\", CFG_FLOAT, \"0.3567\", \"This is how much the input signal is scaled as it enters the overdrive effect. The default value is quite hot, but you can of course try it in anyway you like; range [0..1]\"},");
#line 1527
  codeln((char *)"{\"overdrive.outputgain\", CFG_FLOAT, \"0.07873\", \"This is how much the signal is scaled as it leaves the overdrive effect. Essentially this value should be as high as possible without clipping (and you *will* notice when it does - Test with a bass-chord on 88 8888 000 with percussion enabled and full swell, but do turn down the amplifier/headphone volume first!); range [0..1]\"},");
#line 1529
  codeln((char *)"{\"xov.ctl_biased\", CFG_FLOAT, \"0.5347\", \"bias base; range [0..1]\"},");
#line 1532
  codeln((char *)"{\"xov.ctl_biased_gfb\", CFG_FLOAT, \"0.6214\", \"Global [negative] feedback control; range [0..1]\"},");
#line 1547
  codeln((char *)"{\"overdrive.character\", CFG_FLOAT, \"-\", \"Abstraction to set xov.ctl_biased_fb and xov.ctl_biased_fb2\"},");
  }
#line 1548
  if ((unsigned long )modvec[1].fn != (unsigned long )((void *)0)) {
    {
#line 1549
    (*(modvec[1].fn))(0, (void *)0);
    }
  }
  {
#line 1551
  codeln((char *)"{NULL}");
#line 1552
  popIndent();
#line 1553
  codeln((char *)"};");
#line 1554
  vspace(2);
#line 1555
  codeln((char *)"const ConfigDoc *ampDoc () {");
#line 1556
  pushIndent();
#line 1557
  codeln((char *)"return doc;");
#line 1558
  popIndent();
#line 1559
  codeln((char *)"}");
  }
#line 1560
  return;
}
}
#line 1562 "/home/june/repo/benchmarks/collector/temp/setbfree-0.7.5/b_overdrive/overmaker.c"
void legacySwell(void) 
{ 


  {
  {
#line 1563
  vspace(3);
#line 1564
  commentln((char *)"Legacy function");
#line 1565
  codeln((char *)"void setSwell (double d) {");
#line 1566
  pushIndent();
#line 1570
  popIndent();
#line 1571
  codeln((char *)"}");
  }
#line 1572
  return;
}
}
#line 1574 "/home/june/repo/benchmarks/collector/temp/setbfree-0.7.5/b_overdrive/overmaker.c"
void legacyGain(void) 
{ 


  {
  {
#line 1575
  vspace(3);
#line 1576
  commentln((char *)"Legacy function");
#line 1577
  codeln((char *)"void set7bitGain (unsigned char b) {");
#line 1578
  pushIndent();
#line 1582
  popIndent();
#line 1583
  codeln((char *)"}");
  }
#line 1584
  return;
}
}
#line 1586 "/home/june/repo/benchmarks/collector/temp/setbfree-0.7.5/b_overdrive/overmaker.c"
void legacyClean(void) 
{ 


  {
  {
#line 1587
  vspace(3);
#line 1588
  codeln((char *)"void setClean (void *pa, int useClean) {");
#line 1589
  pushIndent();
#line 1590
  codeln((char *)"struct b_preamp *pp = (struct b_preamp *) pa;");
#line 1591
  codeln((char *)"pp->isClean = useClean ? 1: 0;");
#line 1592
  popIndent();
#line 1593
  codeln((char *)"}");
#line 1594
  codeln((char *)"void setCleanCC (void *pa, unsigned char uc) {");
#line 1595
  pushIndent();
#line 1596
  codeln((char *)"setClean(pa, uc > 63 ? 0 : 1);");
#line 1597
  popIndent();
#line 1598
  codeln((char *)"}");
  }
#line 1599
  return;
}
}
#line 1605 "/home/june/repo/benchmarks/collector/temp/setbfree-0.7.5/b_overdrive/overmaker.c"
void preFilterDefine(void) 
{ 


  {
  {
#line 1606
  vspace(3);
#line 1607
  commentln((char *)"Prefilter runtime definition");
#line 1608
  codeln((char *)"void preFilterDefine (int type, double fq, double Q, double G)");
#line 1609
  codeln((char *)"{");
#line 1610
  pushIndent();
#line 1611
  codeln((char *)"double C[6];");
#line 1612
  codeln((char *)"eqCompute (type, fq, Q, G, C);");
#line 1613
  codeln((char *)"pr_b0 = (float) C[EQC_B0];");
#line 1614
  codeln((char *)"pr_b1 = (float) C[EQC_B1];");
#line 1615
  codeln((char *)"pr_b2 = (float) C[EQC_B2];");
#line 1616
  codeln((char *)"pr_a1 = (float) C[EQC_A1];");
#line 1617
  codeln((char *)"pr_a2 = (float) C[EQC_A2];");
#line 1619
  codeln((char *)"printf(\"\\rPRE:Hz:%10.4lf:Q:%10.4lf:G:%10.4lf\",fq,Q,G);");
#line 1620
  codeln((char *)"fflush (stdout);");
#line 1622
  popIndent();
#line 1623
  codeln((char *)"}");
  }
#line 1624
  return;
}
}
#line 1630 "/home/june/repo/benchmarks/collector/temp/setbfree-0.7.5/b_overdrive/overmaker.c"
void postFilterDefine(void) 
{ 


  {
  {
#line 1631
  vspace(3);
#line 1632
  commentln((char *)"Postfilter runtime definition");
#line 1633
  codeln((char *)"void postFilterDefine (int type, double fq, double Q, double G)");
#line 1634
  codeln((char *)"{");
#line 1635
  pushIndent();
#line 1636
  codeln((char *)"double C[6];");
#line 1637
  codeln((char *)"eqCompute (type, fq, Q, G, C);");
#line 1638
  codeln((char *)"de_b0 = (float) C[EQC_B0];");
#line 1639
  codeln((char *)"de_b1 = (float) C[EQC_B1];");
#line 1640
  codeln((char *)"de_b2 = (float) C[EQC_B2];");
#line 1641
  codeln((char *)"de_a1 = (float) C[EQC_A1];");
#line 1642
  codeln((char *)"de_a2 = (float) C[EQC_A2];");
#line 1644
  codeln((char *)"printf(\"\\rPST:Hz:%10.4lf:Q:%10.4lf:G:%10.4lf\",fq,Q,G);");
#line 1645
  codeln((char *)"fflush (stdout);");
#line 1647
  popIndent();
#line 1648
  codeln((char *)"}");
  }
#line 1649
  return;
}
}
#line 1769 "/home/june/repo/benchmarks/collector/temp/setbfree-0.7.5/b_overdrive/overmaker.c"
void outputGainControl(void) 
{ 
  char buf___0[512] ;

  {
  {
#line 1771
  vspace(3);
#line 1772
  codeln((char *)"void setOutputGain (void *pa, unsigned char uc) {");
#line 1773
  pushIndent();
#line 1774
  codeln((char *)"struct b_preamp *pp = (struct b_preamp *) pa;");
#line 1775
  sprintf((char */* __restrict  */)(buf___0), (char const   */* __restrict  */)"pp->outputGain = %g + ((%g - %g) * (((float) uc) / 127.0));",
          0.1, 10.0, 0.1);
#line 1779
  codeln(buf___0);
#line 1780
  codeln((char *)"printf (\"\\rOUT:%10.4lf\", pp->outputGain);");
#line 1781
  codeln((char *)"fflush (stdout);");
#line 1782
  popIndent();
#line 1783
  codeln((char *)"}");
#line 1784
  vspace(1);
#line 1784
  codeln((char *)"void fsetOutputGain (void *d, float f) {");
#line 1784
  pushIndent();
#line 1784
  codeln((char *)"setOutputGain (d, (unsigned char)(f*127.0));");
#line 1784
  popIndent();
#line 1784
  codeln((char *)"}");
  }
#line 1785
  return;
}
}
#line 1789 "/home/june/repo/benchmarks/collector/temp/setbfree-0.7.5/b_overdrive/overmaker.c"
void inputGainControl(void) 
{ 
  char buf___0[512] ;

  {
  {
#line 1791
  vspace(3);
#line 1792
  codeln((char *)"void setInputGain (void *pa, unsigned char uc) {");
#line 1793
  pushIndent();
#line 1794
  codeln((char *)"struct b_preamp *pp = (struct b_preamp *) pa;");
#line 1795
  sprintf((char */* __restrict  */)(buf___0), (char const   */* __restrict  */)"pp->inputGain = %g + ((%g - %g) * (((float) uc) / 127.0));",
          0.001, 10.0, 0.001);
#line 1799
  codeln(buf___0);
#line 1800
  codeln((char *)"printf (\"\\rINP:%10.4lf\", pp->inputGain);");
#line 1801
  codeln((char *)"fflush (stdout);");
#line 1802
  popIndent();
#line 1803
  codeln((char *)"}");
#line 1804
  vspace(1);
#line 1804
  codeln((char *)"void fsetInputGain (void *d, float f) {");
#line 1804
  pushIndent();
#line 1804
  codeln((char *)"setInputGain (d, (unsigned char)(f*127.0));");
#line 1804
  popIndent();
#line 1804
  codeln((char *)"}");
  }
#line 1805
  return;
}
}
#line 1882 "/home/june/repo/benchmarks/collector/temp/setbfree-0.7.5/b_overdrive/overmaker.c"
void render(FILE *fp , char *funcName ) 
{ 
  char buf___0[512] ;

  {
  {
#line 1885
  setOutputStream(fp);
#line 1888
  computeIpolFilter(0.25, 0);
#line 1889
  sprintf((char */* __restrict  */)(buf___0), (char const   */* __restrict  */)"Interpolation filter at digital frequency %g",
          0.25);
#line 1890
  commentln(buf___0);
#line 1894
  computeAalFilter(0.25, 0);
#line 1895
  sprintf((char */* __restrict  */)(buf___0), (char const   */* __restrict  */)"Decimation filter at digital frequency %g",
          0.25);
#line 1896
  commentln(buf___0);
#line 1899
  computeIpolWeights();
#line 1901
  moduleHeader();
#line 1903
  preIpolMixer();
#line 1905
  funcHeader(funcName);
#line 1906
  funcVarDef();
#line 1909
  funcBody((void (*)(char * , char * ))(& xfr_biased));
#line 1912
  funcTrailer(funcName);
#line 1914
  adapterPreamp(funcName);
#line 1916
  legacyClean();
#line 1918
  legacyConfig();
#line 1920
  vspace(3);
#line 1923
  cfg_biased();
#line 1944
  ctl_biased();
#line 1948
  inputGainControl();
#line 1952
  outputGainControl();
#line 1967
  legacyInit();
  }
#line 1969
  return;
}
}
#line 1975 "/home/june/repo/benchmarks/collector/temp/setbfree-0.7.5/b_overdrive/overmaker.c"
void bindCallback(int i , void (*func)(int  , void * ) , void *hbk ) 
{ 


  {
#line 1976
  if (0 <= i) {
#line 1976
    if (! (i < 8)) {
      {
#line 1976
      __assert_fail("(0 <= i) && (i < 8)", "/home/june/repo/benchmarks/collector/temp/setbfree-0.7.5/b_overdrive/overmaker.c",
                    1976U, "bindCallback");
      }
    }
  } else {
    {
#line 1976
    __assert_fail("(0 <= i) && (i < 8)", "/home/june/repo/benchmarks/collector/temp/setbfree-0.7.5/b_overdrive/overmaker.c",
                  1976U, "bindCallback");
    }
  }
#line 1977
  modvec[i].fn = func;
#line 1978
  modvec[i].handback = hbk;
#line 1979
  return;
}
}
#line 1984 "/home/june/repo/benchmarks/collector/temp/setbfree-0.7.5/b_overdrive/overmaker.c"
int main(int argc , char **argv ) 
{ 


  {
  {
#line 1987
  bindCallbacks();
#line 1990
  render(stdout, (char *)"overdrive");
  }
#line 1992
  return (0);
}
}
